00:02:04 <conal> andyjgill: thetallguy has
00:02:41 <andyjgill> Thx. Its always an artform getting these tools to work together.
00:03:10 <conal> andyjgill: oops -- i didn't read carefully.  maybe not the lhs2Tex bit.
00:04:03 <andyjgill> :-) I think I've got it working. Trying to start slides for the ww talk, and decided to use beamer.
00:04:20 <conal> andyjgill: ww talk?
00:04:28 <andyjgill> worker/wrapper
00:04:37 <conal> oh, duh
00:05:28 <andyjgill> After a while, everything descends into the lowest common acronym
00:08:02 <Mr_Awesome> the lca?
00:54:00 <sizur> @users
00:54:00 <lambdabot> Maximum users seen in #haskell: 454, currently: 392 (86.3%), active: 2 (0.5%)
00:55:55 <matthew-_> I'm pesudo active
00:59:29 <quicksilver> I'm quasi active
01:01:31 <arke> I'm semi active
01:02:28 <matthew-_> I'm pro biotic
01:09:27 <EvilTerran> ... I'm radioactive?
01:09:58 <sizur> "graduate education tends to liberate one from petty concerns
01:09:58 <sizur> about, e.g., the efficiency of hardware-based integers"
01:12:29 <quicksilver> curious sentence
01:12:34 <quicksilver> maybe it makes more sense in-context
01:13:41 <sizur> "Beginning graduate Haskell programmer" in http://www.willamette.edu/~fruehr/haskell/evolution.html
01:13:42 <lambdabot> Title: The Evolution of a Haskell Programmer
01:14:45 <scook0> :t maybe
01:14:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:14:52 <scook0> :t fromMaybe
01:14:52 <lambdabot> forall a. a -> Maybe a -> a
01:16:20 <sizur> > fromMaybe Nothing
01:16:21 <lambdabot>  Add a type signature
01:16:36 <sizur> > fromMaybe (Nothing::Maybe Int)
01:16:37 <lambdabot>  <Maybe (Maybe Int) -> Maybe Int>
01:17:29 <sizur> > let (a:b:c:_) = [1,2,3,4] in c
01:17:30 <lambdabot>  3
01:17:43 <sizur> > let (a:b:c:_) = [] in c
01:17:52 <lambdabot>   Irrefutable pattern failed for pattern (a : b : c : _)
01:18:24 <sizur> :t iterate
01:18:25 <lambdabot> forall a. (a -> a) -> a -> [a]
01:18:37 <sizur> @src iterate
01:18:37 <lambdabot> iterate f x =  x : iterate f (f x)
01:28:20 <sizur> it might take me year to understand the post-doc fac impl
01:29:24 <Deewiant> factorial, the *hard* way!
01:52:12 <olsner> @pl \l -> map (\n -> l ++ l ++ (replicate n =<< l)) [2..]
01:52:13 <lambdabot> flip map [2..] . liftM2 (.) (++) (liftM2 (.) (++) ((. replicate) . (>>=)))
01:52:38 <olsner> @pl (\n -> l ++ l ++ (replicate n =<< l))
01:52:38 <lambdabot> ((l ++ l) ++) . (l >>=) . replicate
01:52:57 <ac> if you add "deriving Enum" to a type, is there any way to control the value of "fromEnum"?
01:53:18 <olsner> > let bondigi l = map (\n -> l ++ l ++ (replicate n =<< l)) [2..] in bondigi [1,2,3]
01:53:22 <lambdabot>  [[1,2,3,1,2,3,1,1,2,2,3,3],[1,2,3,1,2,3,1,1,1,2,2,2,3,3,3],[1,2,3,1,2,3,1,1,...
01:53:26 <ac> I mean simple way, without manually adding an instance for Enum
01:54:41 <Cale> ac: The order in which you place the constructors.
01:54:46 <sizur> ac: fromEnum has Int type.
01:55:00 <Cale> :t fromEnum
01:55:01 <lambdabot> forall a. (Enum a) => a -> Int
01:58:58 <sizur> when whould one want to use fromEnum?
01:59:55 <sizur> > length [(minBound::Bool)..]
01:59:56 <lambdabot>  2
02:02:09 <roconnor> is there a wiki page on how to use a malicious Ix instanct to segfault when compiled with GHC?
02:02:43 <sjanssen> it's in a trac bug somewheres
02:02:47 <sjanssen> @google evilix
02:02:48 <lambdabot> http://evilix.stumbleupon.com/
02:02:54 <sjanssen> @google evilix haskell
02:02:57 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2006-December/019994.html
02:02:57 <lambdabot> Title: [Haskell-cafe] The Data.Array.* hierarchy is unsafe (or, Segfaulting for fun and ...
02:05:58 <quicksilver> sizur: I consider it more or less part of the contract of Enum that you don't use fromEnum, really.
02:06:11 <quicksilver> you should consider the actual numbers chosen opaque and unimportant.
02:12:06 <ac> hmm. Well in this case I'm using them out of laziness. I'm not epecting a user to use them
02:12:39 <ac> it was easier to throw in a couple bogus entries in to the enum then to make a separate mapping to ints
02:13:40 <sizur> ac what do you use this map for?
02:13:52 <ac> serializing the data
02:14:45 <ac> so actually a mapping to Word8
02:16:27 <sizur> :t scanl
02:16:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
02:17:50 <ibid> mm, lovely mouseover in today's xkcd
02:18:04 <sizur> @pl \a b-> succ a
02:18:04 <lambdabot> const . succ
02:18:51 <sizur> > scanl (const.succ) 1 [(minBound::Bool)..]
02:18:53 <lambdabot>  [1,2,3]
02:22:01 <luqui> what should I use for measuring very accurate time differences?
02:22:02 <sizur> > (tail . scanl (const . succ) 0 . enumFrom) (minBound::Bool)
02:22:05 <lambdabot>  [1,2]
02:22:48 <sizur> luqui: real time or processing time?
02:23:01 <luqui> sizur, real
02:23:18 <luqui> looks like TimeDiff...
02:23:38 <luqui> which looks a little awkward to work with
02:26:08 <ac> record elements must begin with a lower case letter, right?
02:26:20 <luqui> ac, yes
02:26:48 <sizur> remember, they are just functions
02:30:29 <sizur> luqui: real time is very had to get very accurate, depending on what you need. thanks to multithreading and garbage collector.
02:31:30 <sizur> luqui: if you measure real time very accurately, you will get very diverse results from doing the same thing several times.
02:33:40 <ac> so just to make sure, there is no way to prevent record elements from polluting your name space?
02:34:03 <ac> without doing something like manually prefixing each name with the record name?
02:34:53 <sizur> well, i'd not use records at all. but yeah, if you need to, take care of namespace pollution.
02:35:30 <ac> sizur: why not use records? And what would you use in place of them?
02:35:59 <sizur> ac: because they make you think like they are records, when they are not.
02:36:04 <luqui> sizur, doesn't the thread scheduler know?
02:36:12 <luqui> ohh
02:36:23 <sizur> luqui: then you'd need to get processing time, not real time
02:36:30 <luqui> no I'm trying to measure the amount of time that has passed for game logic, not for performance measuring
02:37:08 <sizur> luqui: milliseconds are good enough for that :)
02:37:20 <luqui> I suppose "very" was not correct then :-)
02:37:50 <luqui> is ClockTime good for that, or is there a faster way (dealing with Integers makes me uneasy when I'm doing it tens of thousands of times per frame...)
02:38:34 <luqui> well, I suppose less than tens of thousands.. but still a lot
02:38:57 <ac> aren't records basically a short hand for making a compound type (like "data Foo = Foo Int String") and accessor functions at the same time (like "getNum (Foo n _) = n")?
02:39:17 <dcoutts_> ac: yes, plus update functions
02:39:41 <ac> sizur: I don't see why I wouldn't use them, or what I'd use in place of them
02:39:43 <dcoutts_> foo { getNum = 3 }
02:39:53 <ac> dcoutts_: yeah, that's handy
02:40:08 <dcoutts_> ac: they also allow pattern matching:
02:40:37 <sizur> luqui: are you using openGl?
02:40:38 <dcoutts_> bar Foo { getString = 'x' : rest, getNum = 4 } = ...
02:40:43 <dcoutts_> erm
02:40:47 <dcoutts_> bar (Foo { getString = 'x' : rest, getNum = 4 }) = ...
02:41:10 <sizur> luqui: if you do, there is an optimal time function
02:41:23 <ac> what's the ": rest" mean?
02:41:26 <dcoutts_> ac: I actually find records very handy in more real-world programs where there are just more bits of data to handle
02:41:33 <dcoutts_> ac: it's a (x:xs) style pattern
02:41:57 <dcoutts_> like: case blah of ('x':rest) ->
02:41:58 <ac> ah I see
02:42:15 <ac> that just looked funny there for some reason
02:43:05 <dcoutts_> for example I can validate a proxy url with:
02:43:06 <dcoutts_> uri2proxy (uri@URI { uriScheme = "http:", uriAuthority = Just _ }) = ...
02:43:29 <dcoutts_> g'morning malcolmw
02:43:47 <malcolmw> dcoutts_: moin
02:47:05 <ac> I'm going to be using a lot of records in this code
02:47:16 <ac> @hoogle Int -> ByteString
02:47:17 <lambdabot> Data.ByteString.replicate :: Int -> Word8 -> ByteString
02:47:17 <lambdabot> Data.ByteString.take :: Int -> ByteString -> ByteString
02:47:17 <lambdabot> Data.ByteString.drop :: Int -> ByteString -> ByteString
02:47:44 <ac> @hoogle [Word8] -> ByteString
02:47:48 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
02:47:48 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
02:47:49 <sizur> yeah, it's a convinient shortcut. it just looks ugly to me from philosophical perspective.
02:48:37 <ac> it's not too ugly to me, understanding it's basically a syntactic extension
02:49:27 <ac> I keep finding myself thinking that a simple macro mechanism could be used to specify do notation, records, and other such syntax in Haskell nicely
02:51:39 <sizur> that would be very convinient, but then we're moving closer to lisp again. lispers would find it extatic that another language is approaching it.
02:52:16 <dcoutts_> ac: hmm, there are non-trivial parsing issues with do notation and the other syntactic sugar
02:52:25 <ac> where clauses, module system maybe...
02:52:31 <ac> dcoutts_: that doesn't actually surprise me
02:52:42 <dcoutts_> lisp's macros are one thing because they use no syntax so can be represented generically
02:55:50 <ac> > pack ([1,2,3] :: [Word8])
02:55:52 <lambdabot>   Not in scope: `pack'
02:56:05 <ac> > Data.ByteString.pack ([1,2,3] :: [Word8])
02:56:06 <lambdabot>   Not in scope: `Data.ByteString.pack'
02:57:59 <ac> is there a way to import qualified modules in ghci with :m?
03:04:52 <ac> the only difference between ByteString and ByteString.Char8 is pack and unpack take [Word8]s and Strings respectively?
03:05:15 <ac> and head, etc
03:05:43 <ac> the types Char8 and Word8 are frustratingly simmilar
03:08:43 <roconnor> @seen mattem
03:08:44 <lambdabot> I haven't seen mattem.
03:08:47 <roconnor> @seen mattam
03:08:48 <lambdabot> mattam is in ##logic and #haskell. I don't know when mattam last spoke.
03:17:39 <dcoutts> ac: the point of the .Char8 modules is to treat the ByteString as a sequence of 8 bit characters rather than 8 bit bytes
03:17:39 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:18:09 <dcoutts> ac: the ByteString type is the same, it's just the interpretation that is different between the two modules
03:18:34 <dcoutts> ac: what is it that's frustrating exactly?
03:20:33 <mux> > let transpose [] = pure []; transpose (xs:xss) = (:) <$> ZipList xs <*> transpose xss in getZipList (transpose [[1,2,3],[4,5,6]])
03:20:34 <lambdabot> Terminated
03:21:02 <mux> > let transpose [] = pure []; transpose (xs:xss) = (:) <$> ZipList xs <*> transpose xss in getZipList (transpose [[1,2,3],[4,5,6]])
03:21:03 <lambdabot> Terminated
03:21:06 <mux> damn you LB
03:22:04 <quicksilver> well, the types Char and Word32 are similar in some sense
03:22:07 <quicksilver> oops
03:22:18 <quicksilver> responding whlist scrolled back, again
03:28:51 <ac> dcoutts: hmm. Just mildly irksome that I have to explicitly use two different modules in order to have "pack :: [Word8]" and "pack :: String"
03:29:18 <dcoutts> ac: but those two things are really different, what would you expect?
03:30:06 <quicksilver> that's a *feature*
03:30:11 <quicksilver> it's one of the best things about bytestring
03:30:13 <ac> dcoutts: for all types to work in most all functions!
03:30:25 <quicksilver> that it stops this ridiculous confusion between bytes and characters
03:30:29 <czakey> hi
03:30:34 <quicksilver> or at least works against it
03:30:38 <dcoutts> ac: encoding is a subtle thing, it's very easy to introduce bugs by getting it wrong in non-obvious ways
03:30:43 <czakey> thats me again :>
03:30:46 <dcoutts> using types helps
03:31:07 <czakey> merg l o = case l of [] -> o; x:xs -> case o of [] -> l; y:ys -> if (x <= y) then x:merg xs (y:ys) else y:merg (x:xs) ys
03:31:07 <czakey> msort l = case l of x:xs -> merg (msort ys) (msort zs) where (ys,zs) = splitAt (length xs `div` 2) xs; [x] -> [x]
03:31:12 <ac> I'm guessing that they won't stop me from getting this wrong in a non-obvious (to me) way :-P
03:31:14 <czakey> hot to satisfy case
03:31:15 <czakey> ?
03:32:05 <czakey> I'm guessing
03:32:18 <czakey> that >where< is doing bad things
03:32:25 <czakey> little help?
03:32:34 <quicksilver> czakey: I'm not sure what problem you're facing.
03:32:43 <quicksilver> nested case without layout needs { } I would imagine.
03:32:49 <quicksilver> but I don't know if that's what you're talking about
03:32:59 <czakey> probably
03:33:03 <czakey> thats the problem
03:33:28 <czakey> problem is with msort
03:34:40 <quicksilver> but what *is* the problem?
03:34:45 <quicksilver> is there a compile error?
03:34:51 <czakey> yup
03:34:51 <quicksilver> or does it just not work as you expect!
03:34:56 <quicksilver> well tell us what it is then?
03:35:11 <czakey> just a sec
03:35:22 <czakey>    parse error on input `->'
03:35:50 <czakey> I'm guessing
03:35:53 <czakey> that >where< is doing bad things
03:36:09 <quicksilver> which line?
03:36:13 <quicksilver> ah yes
03:36:16 <quicksilver> you're probably right
03:36:20 <quicksilver> where is a layout thing to
03:36:20 <czakey> msort l = case l of x:xs -> merg (msort ys) (msort zs) where (ys,zs) = splitAt (length xs `div` 2) xs; [x] -> [x]; [] -> []
03:36:28 <quicksilver> you want { } around the where clause
03:36:52 <czakey> before where clause?
03:37:03 <quicksilver> where { foo = bar }
03:37:03 <czakey> ok I'll gona try
03:37:11 <czakey> thanks
03:37:31 <quicksilver> Do you prefer not to use layout?
03:37:49 <quicksilver> If you're not using layout I would personally be in the habit of putting explicit { } everywhere for clarity.
03:38:25 <czakey> I'm just a begginner
03:38:32 <czakey> but you are right
03:38:54 <czakey> now its compiling well
03:39:12 <czakey> but doesn't working as I expected :D
03:39:29 <quicksilver> if you are a beginner I would suggest using layout then
03:39:35 <quicksilver> unless you have a strong preference against it :)
03:39:58 <czakey> none at all
03:40:00 <ac> is there any way to automate serializing records in to ByteStrings?
03:40:25 <czakey> but writing in one line is fancy
03:40:26 <czakey> :P
03:40:33 <quicksilver> ac: see Data.Binary
03:44:15 <ac> quicksilver: don't see anything for records
03:45:11 <quicksilver> ac: I don't think records have anything to do with it.
03:45:13 <ac> but this will definitely be a useful module
03:45:21 <quicksilver> Data.Binary has serialisation for haskell data structures
03:45:26 <quicksilver> who cares if it is:
03:45:52 <quicksilver> data Foo = Foo Int Int or data Foo = Foo {x :: Int, y:: Int}
03:46:03 <quicksilver> it still serialises and deserialises.
03:46:14 <quicksilver> x and y are just sugar
03:48:28 <czakey> hm
03:48:32 <czakey> now I have
03:48:39 <ac> quicksilver: I just have to implement get and put
03:48:40 <czakey> layout
03:48:49 <quicksilver> ac: you could yes, or you could derive them.
03:48:52 <czakey> msort [] = []
03:48:53 <czakey> msort [x] = [x]
03:48:53 <czakey> msort x:xs = merg (msort ys) (msort zs)
03:48:53 <czakey>    where
03:48:53 <czakey>       (ys,zs) = splitAt (length xs `div` 2) xs
03:48:53 <quicksilver> it depends what you want.
03:48:59 <ac> quicksilver: how would I derive them?
03:49:02 <czakey> but
03:49:09 <quicksilver> czakey: don't paste long code here, btw, there is a paste bot
03:49:17 <czakey>   Parse error in pattern
03:49:21 <czakey> sorry
03:49:28 <quicksilver> czakey: you need brackets areound (x:xs)
03:49:34 <czakey> I've forgotten
03:49:46 <czakey> thanks
03:50:43 <ac> quicksilver: If I add "deriving Binary" I see "Binary' is not a derivable class"
03:51:39 <ac> I think I need to enable some sort of extension in order for that to work
03:52:34 <czakey> oh lol
03:52:53 <czakey> *Main> msort [2,3,1,4,7,6]
03:52:54 <czakey> [1,6,7]
03:52:56 <czakey> :D
03:53:03 <czakey> very lazy sorting
03:53:27 <ac> it can be even less than O(N)!
03:53:49 <czakey> yes!
03:54:45 <hpaste>  czakey pasted "super sort - less than O(n)!" at http://hpaste.org/5041
03:54:53 <ac> There are extensions like that, right? It would be cool if I could get binary serialization and deserialization for free
03:54:59 <ac> like read and show
03:55:46 <czakey> I'm suessinng that case is somewhere not working
03:55:47 <quicksilver> ac: no, you need a program to do that.
03:55:52 <quicksilver> ac: try Data.Derive.
03:55:52 <czakey> as expected
03:55:55 <quicksilver> or DrIFT
03:56:10 <czakey> but merg seems to work well
03:56:13 <quicksilver> or I have a sneaking suspicion there is a third option
03:56:58 <ac> quicksilver: you mean a program that generates haskell code?
03:57:26 <quicksilver> that is essentially what they do, yes
03:57:33 <quicksilver> although some of them use TH
03:57:37 <quicksilver> and some of them don't
03:57:44 <Lemmih> czakey: 'msort (x:xs)' should be 'msort xs'.
03:57:58 <ac> ooh boy this is exciting. Maybe I should just write the damn serialize functions. They're really simple... just long
03:58:24 <czakey> Lemmih: thanks
03:58:28 <quicksilver> ac: much simpler to use drift or derive
03:58:32 <ac> not sure I want to jump in to TH ;)
03:59:03 <ac> though I guess I was just complaining about the lack of macros
03:59:04 <quicksilver> you don't need to do anything like that
03:59:08 <quicksilver> you just run the program FFS
03:59:24 <quicksilver> data Foo .... deriving ({-! Binary !-})
03:59:34 <quicksilver> then runn derive foo.hs
03:59:38 <quicksilver> snot hard ;)
03:59:44 <quicksilver> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
03:59:45 <lambdabot> Title: Data.Derive: A User Manual
03:59:49 <ac> I guess not. cool
04:00:22 <quicksilver> or if you like you can use the TH version and not even have to run an extra comman
04:00:31 <quicksilver> just put $(derive makeBinary ''Foo)
04:00:32 <quicksilver> or something
04:00:35 <quicksilver> it's all explained :)
04:01:08 <ac> cabal install derive
04:01:49 <ac> ... "could not find module Data.Map". Another hidden package problem
04:02:47 <quicksilver> bah :(
04:03:10 <quicksilver> looks like it needs collections in it's cabal dependencies perhaps?
04:06:07 <ac> no problem installing darcs version
04:07:59 <ac> which is recommended? TH or cpp?
04:08:57 <quicksilver> not sure
04:09:04 <quicksilver> see which you find most pleasant :)
04:14:52 <matveev> > let a=1e-9; b=1e9; c=b in a + b - c == a + (b - c)
04:14:54 <lambdabot>  False
04:15:29 <matveev> ^^^ is there any chance Haskell can substitute one for another?
04:15:41 <quicksilver> > let a=1e-9; b=1e9; c=b in a + b - c == a + (b - c :: Rational)
04:15:42 <lambdabot>  True
04:16:03 <ac> how do I enable TH?
04:16:22 <quicksilver> matveev: I don't believe haskell has any interesting arithmetic RULES like that
04:16:47 <quicksilver> matveev: you could add some, of course
04:16:56 <ac> ghci -XTemplateHaskell
04:17:04 <matveev> quicksilver: so parenthesis are respected as they are?
04:17:15 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
04:17:17 <lambdabot> Title: 8.8. Template Haskell, http://tinyurl.com/y3camx
04:17:38 <quicksilver> matveev: parenthesis are respected and other operators have defined associativities
04:18:47 <matveev> even with the same "associative"  operator like here   a + (b + c) ?
04:19:05 <quicksilver> haskell has no idea what an associative operator is
04:19:13 <quicksilver> as far as it is concerned, no operators are associative
04:19:56 <matveev> that is sometimes good so, thanks!
04:21:03 <byorgey> matveev: it's floating-point that is the problem, of course.
04:21:08 <ac> how do I see the expanded source, so I can make sense of syntax errors?
04:21:53 <ac> actually, I don't have any syntax errors, just "not in scope: 'ap'"
04:22:26 <quicksilver> import Control.Monad maybe?
04:22:43 <matveev> byorgey: my problem would have been if I had no control over execution order at all, given all the referential transparency thing.
04:24:39 <quicksilver> referential transparency has nothing to do with associativity
04:24:54 <quicksilver> haskell execution order isn't allowed to actually change the AST :)
04:25:06 <quicksilver> it's just allowed to reduce independent parts of the AST in any order
04:25:14 <quicksilver> dependent parts are still, well, dependent...
04:25:59 <ac> quicksilver: thanks, Control.Monad fixed that
04:27:36 <ac> so the "{-! Binary !-}" is actually just a comment and doesn't do anything
04:27:53 <quicksilver> ac: it's there for the external "derive" executable
04:28:05 <quicksilver> ac: it's irrelevant if you use the TH $(derive)
04:28:05 <quicksilver> AIUI
04:30:40 <ac> huh. so I assume it generates the put function such that things are serialized in the order they appear in the source
04:31:55 <quicksilver> I believe so, yes
04:32:15 <quicksilver> although as a general rule if you depend on the exact format produced, generated Binary instances may not be for you.
04:32:28 <quicksilver> because you can't be sure a later Binary revision won't change something
04:32:38 <quicksilver> it doesn't have any built-in file versioning tricks
04:32:41 <ac> ooh, that's a killer
04:32:51 <ac> because that's exactly what I'd be doing
04:33:07 <ac> it's pretty cool though
04:33:16 <quicksilver> I thinkt he general rule is that if you need exact control over the file format, you better define it yourself :)
04:33:22 <quicksilver> You can still use Binary's Get and Put monads though
04:33:30 <quicksilver> and the helpful getWord32 etc. primitives
04:33:53 <ac> at least I got a dabbling in TH
04:34:59 <ac> there are also a few bytes that I want to just add that have no corresponding parts in the data structure
04:35:31 <ac> of course they could be added, but that would be a little hackish
04:35:54 <quicksilver> nod
04:36:01 <quicksilver> Yes, definitely a case for custom use of Get and Put IMO
04:36:15 <quicksilver> I've written file formats using raw hPut and ByteString actually
04:36:25 <quicksilver> but that's partly because I started before Data.Binary was released
04:36:29 <quicksilver> and I couldn't be bothered to change
04:36:32 <quicksilver> you don't quite win enough.
04:36:48 <quicksilver> but if you're starting from scratch, it's useful having the get/put utility functons.
04:37:14 <ac> yeah, I have nested structures here, so it seems like they'd be useful
04:38:22 <ac> how do you define a function in terms of other functions in a type class, so it doesn't have to be implemented in each instance?
04:38:42 <mauke> like liftM?
04:38:43 <ac> can you put function definitions as well as types in the class definition?
04:39:02 <ac> like (>) and (<), which are implemented in terms of compare (I think)
04:39:11 <opqdonut> yes
04:39:13 <mauke> @src Ord
04:39:13 <lambdabot> class  (Eq a) => Ord a  where
04:39:14 <lambdabot>     compare      :: a -> a -> Ordering
04:39:14 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:39:14 <lambdabot>     max, min         :: a -> a -> a
04:39:29 <ac> @src (<)
04:39:29 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
04:39:33 <mauke> @src compare
04:39:33 <lambdabot> compare x y | x == y    = EQ
04:39:33 <lambdabot>             | x <= y    = LT
04:39:33 <lambdabot>             | otherwise = GT
04:39:46 <mauke> @src (<=)
04:39:46 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
04:39:50 <mauke> thought so
04:40:09 <ac> they're all implemented in terms of each other!
04:40:13 <opqdonut> yep
04:40:28 <ac> so the compiler just picks one, depending on which ones you've implemented in your instance
04:40:32 <opqdonut> yep
04:40:39 <mauke> on the other hand,
04:40:41 <mauke> @src liftM
04:40:42 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:41:04 <mauke> liftM is implemented in terms of >>= and return, and that's what every instance has to provide
04:42:01 <ac> but of course the definition of liftM could go anywhere
04:42:20 <mauke> yes
04:42:31 <ac> SO different from Java ;-P
04:43:08 <mauke> @src print
04:43:09 <lambdabot> print x = putStrLn (show x)
04:43:23 <mauke> it kind of uses Show and IO but is completely independent
04:43:59 <ac> that's duck typing in action I guess
04:44:19 <mauke> no, just standard static typing :-)
04:44:40 <opqdonut> well you can kinda think of it as limited duck typing
04:44:47 <opqdonut> if you think of typeclasses as capabilities
04:45:19 <ac> mauke: a lot of languages would insist that you put print in a special place, like the Show class for example
04:45:26 <quicksilver> surely it's only duck typing if
04:45:34 <quicksilver> you think of typeclasses as species of ducks/
04:45:48 <ac> that's exactly how I think of it
04:45:48 <quicksilver> "It looks like a mallard and quacks like a mallard... I can call 'show' on it!"
04:45:52 <mauke> class Print { static void print(Showable x) { System.out.write(x.show()); } }
04:46:14 <mauke> make that Show.show(x)
04:46:35 <opqdonut> :D
04:46:38 <opqdonut> indeed
04:46:43 * ac goes away
04:52:44 <matveev> cannot grasp the type signature of the differential operator:    d :: Num a => (forall s. Bundle s a -> Bundle s a) -> a -> a    from http://thread.gmane.org/gmane.comp.lang.haskell.cafe/22308/
04:52:45 <lambdabot> Title: Gmane Loom
04:53:31 <matveev> the second have says (d f) will give you a "duck" that you can call a function over numbers, but the first half?
04:53:55 <matveev> s/have/half/
04:56:21 <doserj> f::(forall s. Bundle s a -> Bundle s a) means that the f in (d f) must be a function that works for all s, not just one particular
04:56:23 <matveev> the f in (d f) is apparently a function over "dressed" numbers, with "s" being what?
04:56:35 <mauke> s is a dummy type
05:00:31 <matveev> why the usual "dressing" that extends vlaues of numbers by their "speed of change"  x -> (x,x') is inferior to this artificial decoration with "s" ?
05:06:18 <doserj> the *values* here are dressed with their speed of change as usual
05:06:32 <doserj> but in addition, the *types* are dressed with s
05:06:59 <sizur> :t liftM fmap
05:07:02 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a -> f b)
05:09:38 <ac> I do not understand the type of "get" in "class Binary t where put :: t -> Put; get :: Get t"
05:09:42 <ac> how can get not take any arguments?
05:10:10 <matveev> doserj: how does that not allow  x and y  in   \x -> y + x    to add their "speeds" in  d (\x -> x + y) ?
05:10:21 <ac> last time I tried to write a method for a type class that didn't take an argument, I got a compile error
05:13:00 <doserj> matveev: the y in \x -> x+y has some (particular) type y::Bundle s a. fo \x -> x+y has type Bundle s a -> Bundle s a for *some* s and a
05:16:09 <sizur> ac: it polymorphs into the expected t.
05:18:48 <ac> this would be oh so much easier if I didn't do it the Haskell way
05:19:35 <earthy> ?
05:19:36 <mauke> ac: it's fine as long as the type of get mentions t somewhere
05:19:51 <mauke> if you try to write a method whose type doesn't mention t, you'll get an error
05:20:03 <matveev> do not get completely. The author claims the presense of the phantom type "s" forces him to manually promote all "extyernal parameters" in \x -> expression(x,y,z,...) to "constants" by wrapping them into Bundle with zero speed of change. Dont see how.
05:21:06 <ac> mauke: yeah, I understand there's a distinction there, I just don't understand how you can reference the type variable without using an argument!
05:21:22 <mauke> ac: by including it in the return type
05:21:35 <mauke> :t pi
05:21:37 <lambdabot> forall a. (Floating a) => a
05:21:41 <mauke> @src Floating
05:21:41 <lambdabot> class  (Fractional a) => Floating a  where
05:21:41 <lambdabot>     pi                                                      :: a
05:21:41 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
05:21:41 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
05:21:41 <lambdabot>     (**), logBase                                           :: a -> a -> a
05:21:50 <mauke> see the "pi :: a" part?
05:21:54 <quicksilver> lambdabot: that was a bit spammy, don't you know about hpaste?
05:22:37 <Lycurgus> @version
05:22:37 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
05:22:37 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:22:43 <doserj> matveev: it is not so much the presence of "s" alone, but the quantification over s in the type of d
05:22:55 <quicksilver> ac: you don't have to go as far as 'pi'
05:23:01 <quicksilver> ac: have you ever looked at the type of '0' ?
05:23:05 <quicksilver> :t 0
05:23:07 <lambdabot> forall t. (Num t) => t
05:23:09 <mux> :t []
05:23:09 <lambdabot> forall a. [a]
05:23:19 <quicksilver> ac: that's much like the 'get' thing
05:23:40 <quicksilver> not quite the same, of course
05:23:47 <mauke> :t read
05:23:48 <lambdabot> forall a. (Read a) => String -> a
05:23:57 <mauke> :t return
05:23:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:24:15 <ac> @src Show
05:24:16 <lambdabot> class  Show a  where
05:24:16 <lambdabot>     showsPrec :: Int -> a -> ShowS
05:24:16 <lambdabot>     show      :: a   -> String
05:24:16 <lambdabot>     showList  :: [a] -> ShowS
05:24:24 <ac> @src Read
05:24:24 <lambdabot> class Read a where
05:24:24 <lambdabot>   readsPrec    :: Int -> ReadS a
05:24:24 <lambdabot>   readList     :: ReadS [a]
05:24:24 <lambdabot>   readPrec     :: ReadPrec a
05:24:24 <lambdabot>   readListPrec :: ReadPrec [a]
05:24:42 <quicksilver> ac: if you're looking for another method which doesn't take parameters, try 'mzero'
05:25:04 <mux> or sizeOf
05:25:06 <mauke> :t mempty
05:25:07 <lambdabot> forall a. (Monoid a) => a
05:25:16 <mux> sizeOf is creepy at first :)
05:25:20 <quicksilver> sizeOf is not much like get, though
05:25:27 <mux> yeah
05:25:32 <quicksilver> sizeOf does take a parameter :)
05:25:59 <mux> oh?
05:26:02 <mux> ah yes, my bad
05:26:10 <mux> it's just that we pass it undefined all the time
05:26:14 <mux> because it doesn't do anything with it
05:26:20 <mux> @src Storable
05:26:20 <lambdabot> Source not found. My mind is going. I can feel it.
05:26:26 <mux> that's a bit weird by the way
05:26:28 <Deewiant> @src Foreign.sizeOf
05:26:29 <lambdabot> Source not found.
05:26:43 <mux> > sizeOf (undefined :: CInt)
05:26:43 <lambdabot>   Not in scope: type constructor or class `CInt'
05:26:48 <quicksilver> ac: I'm interesting why you think that "this" (presumably your file format stuff) would be easier if you didn't do it the haskell way?
05:26:52 <mux> > sizeOf (undefined :: Foreign.C.Types.CInt)
05:26:53 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CInt'
05:27:56 <ac> quicksilver: because I wouldn't have to understand as much, specifically how to implement an instance of Binary
05:28:16 <sizur> > sizeOf (undefined::String)
05:28:16 <lambdabot>   Not in scope: `sizeOf'
05:28:27 <quicksilver> ;)
05:28:29 <mux> String isn't in the Storable class anyways
05:28:30 <ac> and this Get and Put type
05:28:31 <mux> CString would
05:28:33 <ari> @index sizeOf
05:28:33 <lambdabot> Foreign.Storable, Foreign
05:28:48 <Deewiant> > Foreign.sizeOf (undefined::String)
05:28:49 <lambdabot>   Not in scope: `Foreign.sizeOf'
05:28:51 <quicksilver> you don't have to understand Get and Put if you don't want
05:28:56 <quicksilver> you can just use ByteStrings like I do
05:29:00 <quicksilver> they're not that bad though
05:29:07 <quicksilver> just very simple monads for reading/writing bytestrings
05:29:16 <ac> quicksilver: I like the way the code in the docs for Data.Binary looks ;)
05:29:50 <ac> "... case tag of 0 -> liftM  IntE get; 1 -> liftM3 OpE get get get"
05:30:48 <ac> I think later I'll appreciate it even more, because I have large chunks in my format that can be repeated
05:31:02 <quicksilver> actually I think that's horrible
05:31:05 <quicksilver> I'd write
05:31:22 <quicksilver> case tag of 0 -> IntE <$> get; 1 -> OpE <$> get <*> get <*> get
05:31:32 <quicksilver> ;0
05:33:29 <EvilTerran> i'd at least've made getting, getting2, getting3 etc rather than having to write out all those gets
05:34:07 <mauke> then write liftM (uncurry3 OpE) get3?
05:34:12 <quicksilver> EvilTerran: you'd have to make them tuples, though
05:34:19 <EvilTerran> ?
05:34:22 <quicksilver> and uncurry as mauke says
05:34:27 <quicksilver> well how can you "get 3 things"
05:34:31 <EvilTerran> getting3 f = f <$> get <*> get <*> get
05:34:33 <quicksilver> haskell functions can't return 3 things
05:34:42 <quicksilver> oh,
05:34:45 <quicksilver> nah
05:34:48 <EvilTerran> or done something fancy with overlapping instances, seeing as i imagine you can't get/put functions
05:34:49 <quicksilver>  f <$> get <*> get <*> get
05:34:52 <quicksilver> reads better to me :)
05:35:10 <quicksilver> the point is it scales better to when you have some arguments which don't come from the stream
05:35:35 <quicksilver> ConstructFoo <$> get <*> pure 0 <*> get <*> pure 1024
05:35:53 <EvilTerran> i find the lack of a <...> taking a pure parameter notable
05:35:53 <quicksilver> and it looks most like the non-monadic case
05:36:27 <matthew_-> has anyone written a haskell binding to the wiimote apis yet?
05:36:37 <EvilTerran> (<%>) :: Applicative f => f (a -> b) -> a -> f b -- kinda thing
05:37:31 <mauke> :t liftA ($ ?x)
05:37:32 <EvilTerran> i guess <$> is tied closely to the meaning of Functor, and <*> to the meaning of Applicative, and that <%> isn't really tied to the meaning of anything
05:37:33 <lambdabot> forall a b (f :: * -> *). (?x::a, Applicative f) => f (a -> b) -> f b
05:37:52 <opqdonut> :t ((<*>),(<$>))
05:37:53 <lambdabot> forall (f :: * -> *) a b a1 b1 (f1 :: * -> *). (Applicative f, Functor f1) => (f (a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
05:38:00 <dcoutts> ndm: do you have a text search trie data structure available as a reusable module?
05:38:12 <EvilTerran> anyway
05:38:19 <quicksilver> EvilTerran: Just a question of frequency of use and ease of reading, I suspect
05:38:32 <ac> @index Chunk
05:38:33 <lambdabot> bzzt
05:38:34 <quicksilver> EvilTerran: if I did loads and loads of code like that maybe I'd define it too
05:38:58 <EvilTerran> seeing as i thought the point of <$><*> was to make interspersing monadic and pure parameters easier, it seems odd
05:39:17 * quicksilver nods
05:39:27 <ndm> dcoutts: no
05:39:35 * EvilTerran wanders off
05:39:40 <ndm> dcoutts: mine reads the Trie off disk as needed
05:40:01 <mauke> :t \f -> (`liftA` f) . flip id
05:40:01 <dcoutts> ndm: mmm, I might want that too
05:40:02 <lambdabot> forall (f :: * -> *) a c. (Applicative f) => f (a -> c) -> a -> f c
05:40:05 <ndm> dcoutts: is this for cabal?
05:40:21 <dcoutts> ndm: yes, for cabal search within package names & descriptions
05:40:53 <ndm> dcoutts: so you want a String -> (File, Word) thingy
05:40:54 <dcoutts> ndm: that or we should just be using hoogle for it directly
05:41:15 <dcoutts> ndm: it'd be String -> [PkgInfo] I think
05:41:19 <ndm> dcoutts: just use hoogle directly, but i might pull out the trie if that will be useful to you, library it up, and you can use that until hoogle comes on line
05:41:35 <dcoutts> ndm: the [PkgInfo] do not need to be kept in the index, just some reference to them
05:41:37 <ndm> dcoutts: that should be trivial, although i recommend
05:41:51 <ndm> dcoutts: String -> [(Int,PkgInfo)]
05:42:03 <ndm> where Int says where in the description it is, so you can display context
05:42:10 <ndm> or perhaps that is just way too much work - likely it is
05:42:34 <dcoutts> ndm: having narrowed it down to one or two PkgInfo's we can just do a linear search
05:42:52 <ndm> dcoutts: neato, when would you like Data.Trie.Lazy for?
05:43:17 <ndm> I think its all done, and making it separate probably benefits me too, as more modular
05:43:27 <ndm> it depends on lazybinary, btw
05:43:29 <quicksilver> hmm. That yi editor tutorial on the cafe was nice reading
05:43:34 <dcoutts> ndm: ideally cabal would keep a hoogle index up to date, both of the package meta-data and also of all the installed (or maybe even uninstalled) packages, their documentation and function names types etc
05:44:08 <dcoutts> ndm: will hoogle 4 index the haddock documentation too?
05:44:08 <ndm> dcoutts: yes, i'll make sure its easy to do all that - but i'll give you a quick and simple trie to play with for now
05:44:14 <ndm> dcoutts: yes
05:44:31 <dcoutts> ndm: it can wait a bit I think, we already do name substring search
05:44:44 <ndm> dcoutts: or hoogle 4.1 will at least, i may just work on bringing Hoogle 4 up to life, then adding the extra bling
05:44:46 <dcoutts> ndm: it's only extending that to description and other meta-data that'd be nice
05:45:03 <ndm> dcoutts: is `elem` words too slow?
05:45:06 <dcoutts> ndm: sure, well make sure it's usable as a library so we can use it on hackage
05:45:13 <sizur> is yi buildable?
05:45:15 <ndm> i.e. have you profiled doing it the naieve way
05:45:24 <dcoutts> ndm: parsing all 350 .cabal files is too slow
05:45:39 <dcoutts> ndm: if we want to do searching of package meta data we need an index
05:46:00 <dcoutts> and then generate that index when we update from hackage
05:46:52 <dcoutts> ndm: we originally had a regex search over the package descriptions, but it was far too slow, all down to parsing
05:47:22 <dcoutts> ndm: so now 'cabal list foo' just does substring search on the package names
05:47:43 <dcoutts> it's a linear search but that's still sufficiently quick
05:49:25 <ac> when should I use binary-strict vs binary?
05:50:08 <ac> I mean should I be using lazy ByteStrings or not for encoding a file?
05:50:20 <ndm> dcoutts: fair enough, my plan is to seriously smash hoogle into shape after i submit my phd, so perhaps 3-4 months
05:50:31 <ndm> and i'm pretty sure you have 3-4 months of other hackage work to do first :)
05:50:41 <dcoutts> ndm: yeah, certainly :-)
05:50:46 <ndm> neat :)
05:50:57 <ndm> definately want to get hoogle 4 finished, and ideally write a paper on it
05:51:10 <dcoutts> aye, it's pretty cool
05:51:46 <dcoutts> ndm: and if done right could be the web UI to hackage
05:51:52 <dcoutts> like google is to the web
05:52:05 <ndm> dcoutts: it will be done right ;)
05:52:09 <ndm> yeah, sounds like a plan
05:52:10 <dcoutts> @arr!
05:52:10 <lambdabot> Arrr!
05:52:27 <ac> seems like lazy byte strings would be better than strict to me
05:52:50 <dcoutts> ac: I agree, the main difference with binary-strict is the encoding, not the underlying medium
05:53:00 <pejo> ndm, and sell advertisments too!
05:53:27 <dcoutts> ndm: heh, take bribes for pushing one package up the rankings over another :-)
05:54:04 <dcoutts> start a consultancy for hoogle search "optimisation"
05:54:46 <ac> is there an easy way to make ghci show bytestrings as "[10,20,255,0,1]" instead of "\FOO\BAR\NULL\STX\SOH"?
05:54:53 <ndm> my plan, should i find myself without a job, is to add a line at the top of the hoogle page "The author of Hoogle would like a Haskell related job, click here to employ him!"
05:55:02 <mauke> map ord str
05:55:34 <quicksilver> ndm: what if two people click at the same time?
05:55:44 <ndm> quicksilver: bidding war :D
05:55:49 <matthew_-> quicksilver: don't worry, I'm sure STM will be employed somewhere
05:55:50 <mauke> optimistic evaluation
05:55:51 <quicksilver> "ndm: what do you do these days? <ndm> well, it's a bit of a race condition..."
05:56:07 <quicksilver> ac: unpack
05:56:24 <ndm> > show '\STX'
05:56:27 <lambdabot>  "'\\STX'"
05:56:45 <mauke> > fix show
05:56:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
05:56:47 <ndm> > length $ show '\STX'
05:56:48 <lambdabot>  6
05:57:05 <matthew_-> ndm: if you'd just be so good as to rob a bank, you could then set up a #haskell benevolant fund, offering handouts to countless unemployable ex-PhD students
05:57:23 <ndm> matthew-_: my bank robbery experience is limited
05:57:36 <matthew_-> they could staff #haskell, helping others on their way to enlightenment and bankruptcy
05:57:52 <matthew_-> ndm: well, so long as you quickcheck your plan, you should be fine ;)
05:57:56 <dcoutts> ac: (show . Data.ByteString.unpack)
05:58:06 <matthew_-> ndm: well, so long as you quickcheck your plan, you should be fine ;)
05:58:09 <quicksilver> dcoutts: just unpack is enough, in ghci
05:58:17 <quicksilver> dcoutts: in the sense that show is automatic :)
05:58:31 <dcoutts> if you pick the non-Char8.unpack
05:58:38 <quicksilver> yeah
05:58:40 <ndm> matthew-_: i will statically check it with catch and reach
05:58:47 <quicksilver> well that's the version I think he's using.
05:58:47 <jedbrown> matthew_-: The quickcheck is easy, it's getting 100% coverage that is hard ;)
05:59:22 <matthew_-> I think we're onto a winner here. The most successful bank robbery in history. Made possible only through Haskell's type system and associated tools
05:59:28 <matthew_-> MSR, we thank you.
05:59:59 <quicksilver> unsafeYouWereOnlySupposedToBlowTheBloodyDoorsOff#
06:00:46 <ricky_clarkson> quicksilver: heh
06:04:06 <sizur> matthew_-: a very minor side effect would be life imprisonment.
06:04:40 <matthew_-> sizur: but think of the opportunities for teaching haskell inside
06:04:48 <matthew_-> sizur: you could fashion an entire army
06:05:17 <matthew_-> they would march with such functional elegance
06:05:51 <sizur> hehe, a functional correction institute
06:06:02 <matthew_-> it'd make a change ;)
06:06:45 <quicksilver> ;)
06:06:59 <ricky_clarkson> They'd still be misfits on the outside.
06:07:05 <sizur> a monoorphism: Criminal -> MathTeacher
06:07:30 <Syzygy-> o.O
06:07:38 <ricky_clarkson> "Crime doesn't pay, and here's the proof."
06:08:11 <matthew_-> ricky_clarkson: yeah, socially they'd be all over the place, unable to make eye contact and preferring to communicate with each other via IRC rather than turning around and talking to the other person who's in the room
06:08:25 <ricky_clarkson> matthew_-: She uses PHP.
06:08:33 <sizur> matthew_-: sonunds to me like you have a calling, and the bank robery is a nesessary stepping stone. just make sure you give me all the money before taking all the responsibility.
06:09:07 <ricky_clarkson> matthew_-: It's not as bad as killing kittens, but the intent's there.
06:09:13 <matthew_-> sizur: type Calling = Procrastination PhD
06:11:53 <ricky_clarkson> How does simplification of test data work in QuickCheck?
06:12:23 <ricky_clarkson> Does it ask the Arbitrary to simplify, then run the test again, etc.?
06:17:32 <ndm> ricky_clarkson: the one that has it has a simplify :: a -> [a] method, which it uses
06:18:07 <ricky_clarkson> So there's a list of simplifications.
06:18:28 <ricky_clarkson> Does it stop when it hits one that the property fails on?
06:18:38 <ricky_clarkson> (then maybe call simplify on that)
06:20:57 <byorgey> ricky_clarkson: yes, I think it tries to recursively find the simplest possible case for which the property fails.
06:22:23 <ricky_clarkson> I'm wondering how to implement that for the arbitrary.
06:22:32 <ricky_clarkson> For some things it seems obvious.  I'll give my case.
06:23:00 <ricky_clarkson> I write a network simulator; I have an arbitrary that gives a list of arbitrary networks.
06:23:42 <ndm> ricky_clarkson: the idea is that it should be one step simpler, so if there are no simplifications, just leave it as []
06:23:53 <ndm> but i don't think the publically available smallcheck supports simplify
06:23:54 <ricky_clarkson> Simplifying a network seems tricky - just deleting things at random could work, except for one silly thing.
06:24:22 <ricky_clarkson> Yeah, I see, but in my case I want to simplify, I'm just thinking about how to do it.
06:24:25 <ndm> ricky_clarkson: why not just delete one at random? the idea is that it will then recheck the property, so as long as you don't delete correctness invariants, you should be fine
06:24:40 <ndm> or rather, make a list, where each element is one node deleted
06:24:41 <ricky_clarkson> The silly thing is that this is not in Haskell, and deleting the network is hard to undo.
06:24:55 <ndm> you mean you don't have referential transparency?
06:25:03 <ricky_clarkson> For that type, right.
06:25:12 <ndm> you are probably screwed then...
06:25:14 <ricky_clarkson> Sorry, deleting *parts* of the network is hard to undo.
06:25:25 <ndm> data Network = ...
06:25:32 <ndm> delete :: Int -> Network -> Network
06:25:43 <ndm> does that change the original netnwork? delete should clone a network
06:26:24 <ricky_clarkson> I've steadily made a lot of the parts of the network immutable; haven't done that for the network itself thus far.
06:26:36 <byorgey> ricky_clarkson: you mean you're using some sort of FFI?  or you're trying to implement quickcheck in some other language?
06:26:44 <ricky_clarkson> Ok, I know what I need to do now, thanks.
06:26:55 <ricky_clarkson> byorgey: I have a ridiculously simple version in Java.
06:27:56 <ricky_clarkson> return generator.data(randomNumberGenerator).take(10000).all(property)
06:28:20 <byorgey> ricky_clarkson: got it.  I guess you need a way to clone a network.  good luck getting any kind of reasonable sharing... =)
06:28:56 <ndm> if this is for only _after_ a quickcheck property has failed, being "efficient" shouldn't be important at all
06:29:01 <matthew_-> meh, just implement .clone sod the memory requirement...
06:29:03 <ndm> and a deep copy in java is fairly trivial
06:29:28 <ricky_clarkson> Right, the only issue is the parts of the program that depend on mutation.
06:30:18 * ndm remembers why Haskell is so great
06:30:23 <ndm> if you can take a shortcut, you will
06:30:28 <ndm> if you do, you will regret it
06:30:45 <ricky_clarkson> I designed those parts before I knew what FP was.
06:31:20 <ndm> as yoda said: mutability leads to impurity, impurity leads to hacks, hacks lead to bugs
06:31:44 <vincenz> bugs lead to unit tests
06:31:55 <osfameron> unit tests lead to reliability and maintainability
06:31:57 <osfameron> oops
06:31:57 <ricky_clarkson> Yes.  1 in 2000 times, a bug is revealed.  I can live with the bug until I've made Network immutable so that QC works properly on it.
06:32:16 <ricky_clarkson> osfameron: Unit tests measure fragility.
06:32:36 <osfameron> ricky_clarkson: mm?
06:32:53 <ricky_clarkson> You change your code, the tests fail, you see how fragile your codebase is.
06:33:15 <ndm> unit tests lead to coverage, coverage leads to reliability - but maintainability never comes if you have impurity
06:33:46 <osfameron> ricky_clarkson: I'm not sure how a non-fragile codebase would break test any less if you make broken changes to bits of it
06:34:13 <ricky_clarkson> It would fail to typecheck, ideally.
06:34:22 <ricky_clarkson> Unit tests lead to rambling. :)
06:36:16 <osfameron> there was a recently posted cartoon about the TDD encouraging the opposite.. can't find the link
06:36:42 <osfameron> how *do* you represent a network in FP by the way?  Clone every time you make a change?
06:37:11 <czakey> @src cycle
06:37:11 <lambdabot> cycle [] = undefined
06:37:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:37:34 <ricky_clarkson> Yes.  Well, actually the Network type consists of a non-empty list of NetworkContexts.
06:37:51 <czakey> > cycle "oO"
06:37:53 <lambdabot>  "oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo...
06:37:55 <ricky_clarkson> ..because I need to separate parts of the network for the user.
06:38:58 <ricky_clarkson> A NetworkContext has a [Component] and a Map Component PositionData (that's how the tree is stored, possibly a bit indirect)
06:39:18 <kpreid> .cycle ".oOo"
06:39:22 <kpreid> > cycle ".oOo"
06:39:23 <lambdabot>  ".oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oO...
06:39:25 <hpaste>  Riccardo Cagnas pasted "JavaStubGenerator" at http://hpaste.org/5042
06:39:29 <ndm> osfameron: i don't know, FP sucks for graphs  in general at the moment, although things have be done sligthly close to it
06:39:32 <moonlite> > zipWith ($) [negate, (+1)] [2,3]
06:39:32 <lambdabot>  [-2,4]
06:40:55 <osfameron> ndm: but despite the fact that graphs are trivial to express with mutation and presumably harder to express immutably, you'd say the latter is more maintainable?
06:42:06 <quicksilver> osfameron: Yes.
06:42:14 <ricky_clarkson> Actually mine is a tree, not a graph.
06:42:19 <quicksilver> osfameron: I take your comment out of context, and still say yes :)
06:42:26 <osfameron> :-)
06:42:34 <ndm> osfameron: yes, its hard to express the low level operations on a graph, but you build upu to something beautiful
06:42:40 <quicksilver> you don't really clone every time you make a change
06:42:44 <quicksilver> that's an imperative viewpoint
06:42:47 <quicksilver> clones are "mostly free"
06:42:51 <quicksilver> due to underlying sharing
06:42:58 <quicksilver> you just describe new values in terms of old values
06:43:06 <sizur> well, it's trivial to express graphs immutably, it's hard to make operations on it optimaly.
06:43:12 <quicksilver> yes
06:43:24 <quicksilver> but (IMO) it's fairly hard to express graph operations in any setting.
06:43:33 <quicksilver> Or, rather, once you've chosen a particular implementation style
06:43:39 <quicksilver> some operations are quite easy and others are really hard
06:43:44 <quicksilver> depending on the implementation you chose
06:43:55 <quicksilver> adjacency sets, edge lists, etc
06:46:06 <ndm> i usually use a specific graph programming language
06:46:14 <ndm> in that, its trivial to express almost any graph property
06:46:22 <ndm> GP is a research project at York
06:46:32 <ndm> a graph programming language, whose compiler is written in Haskell :)
06:46:45 <osfameron> oh, is cloning still free?  If it's acyclic yes (but then it's a tree)
06:46:47 <vincenz> ndm: what's wrong with ghc libs?
06:47:01 <ricky_clarkson> I work at Salford, where nothing interesting happens.
06:47:01 <ndm> vincenz: do not match my mental model
06:47:35 <quicksilver> osfameron: depends on data rep.
06:47:43 <ndm> ricky_clarkson: you are in a position to change that
06:47:55 <quicksilver> osfameron: you can normally make most simple modifications O(1)
06:48:10 <osfameron> quicksilver: using zippers?
06:48:13 <ricky_clarkson> ndm: Yes, I can leave. :)
06:48:16 <quicksilver> that kind of technique, yes
06:48:36 <matveev> hi, what is behind this syntax:  class Term t a | t -> a where
06:48:38 <osfameron> zippers rock.  well, in concept.  in practise I just get confused and my code doesn't work.
06:48:42 <ricky_clarkson> ndm: I find that the staff and students are actively afraid of programming.
06:48:46 <mauke> matveev: functional dependencies
06:49:02 <ricky_clarkson> ndm: I've changed that for courses I've taught, but it has little effect overall.
06:49:07 <quicksilver> matveev: "Term" is a class which relates two types, "t" and "a"
06:49:22 <quicksilver> matveev: however, for each possible type "t" there is at most one "a" such that Term t a
06:49:30 <quicksilver> (that second part is the fundep)
06:50:16 <ndm> ricky_clarkson: you can drag it up on your own :)
06:50:33 <quicksilver> ricky_clarkson: do you know someone called Richard Bell?
06:50:41 <ricky_clarkson> quicksilver: No.
06:50:59 <matveev> mauke, quicksilver: thanks
06:51:16 <quicksilver> oh, he's in the business school
06:51:23 <quicksilver> I thought he was computing
06:51:25 <quicksilver> maybe he used to be
06:51:33 <ricky_clarkson> His face doesn't look familiar.
06:51:57 <ricky_clarkson> (I've worked in the business school before, as a very crap sysadmin)
06:52:17 <pejo> ndm, what kind of output do you get from the GP compiler?
06:52:35 <ndm> pejo: .dot file, graph XML file
06:55:22 <pejo> ndm, so it's not very useful for say .. writing a compiler backend?
07:00:54 <ac> how would I implement get so that it simply eats N bytes? Or even better, fails if the next N bytes != a constant list
07:03:26 <ndm> pejo: not nearly fast enough for that, either
07:03:26 <mauke> get = replicateM n getWord8
07:04:21 <ac> mauke: wouldn't I want something like replicateM_?
07:04:43 <mauke> if you want to throw the results away, yes
07:05:37 <quicksilver> but you said you wanted to check them
07:05:38 <ac> get = if (replicateM 3 getWord8) == [1,2,3] then get :: NextExpectedThing else error ...
07:05:54 <quicksilver> well not quite
07:06:07 <mauke> get = do { [1,2,3] <- replicateM 3 getWord8; ... }
07:06:08 <ac> yeah I need to conditionally chain those together somehow
07:06:18 <quicksilver> get = do foo <- replicateM 3 getWord8; if foo == [1,2,3] then...
07:06:21 <ac> ah cool
07:06:39 <ac> right. The former method was cool though
07:07:14 <mauke> it is :-)
07:07:21 <ac> and it looks like Get implements fail
07:07:27 <mauke> all monads do
07:07:35 <mauke> most of them just fall back to error
07:07:40 <Saizan> get implements it with error
07:08:26 <ac> looks like it concatenates the error together with what originally caused the error
07:08:31 <ac> there's a "failDesc" function
07:09:24 <ac> so real simple, but better than nothing, parse errors
07:10:47 <ac> ooo Firefox is smart with its mime types... somehow it knows to open .hs files with gvim
07:11:28 <ac> it's probably not Firefox itself, but some MIME library
07:16:33 <ndm> ac: firefox can configure what to do with each file, including passing it through to the open handler
07:16:43 <ndm> on windows, firefox tends to suck with .hs files though :(
07:16:53 <ndm> fortunately, i use opera, which does good things
07:18:59 <ac> what do distributions typically call the "open handler"?
07:20:38 <quicksilver> 'view' I think
07:20:53 <quicksilver> at least, that's one of the generic mime handlers
07:27:46 <ketil> Anybody with experience using large Maps (or similar structures?)
07:28:07 <Lemmih> Define large.
07:28:12 <ketil> I wonder if GC is killing performance - a major GC means traversing all the live heap, no?
07:28:27 <ketil> Lemmih, 50-90% of available memory - 1Gb+
07:28:51 <ndm> ketil: check with +RTS -Sstderr on the binary
07:29:03 <ndm> ketil: gives GC% time
07:29:27 <ketil> ndm: right.  I've often seen 30-60%, but don't know what is considered "normal".
07:29:46 <quicksilver> I don't thnk there is any inherent reasons why having a 90% available memory data structure is worse than anything else
07:29:58 <quicksilver> whether or not GC is painful depends what you're doing
07:30:02 <ndm> ketil: over 30% is abnormal
07:30:11 <quicksilver> if you're already using 90% and you keep trying to use another 50%
07:30:11 <jedbrown> You need about 3 times the amount of active memory anyway, given the way GC works.
07:30:17 <quicksilver> you're going to get a lot of GCs...
07:30:24 <ndm> quicksilver: typically a GC requires walking the whole heap, which screws up cache and paging
07:30:29 <quicksilver> yes
07:30:37 * ndm got that yesterday
07:30:39 <quicksilver> but it's not really the large data structure itself at fault
07:30:45 <quicksilver> just, using lots of memory at fault
07:30:52 <quicksilver> I mean, I'm not sure the Map is really to blame.
07:31:18 <ndm> a program which only worked at 2% CPU, since it spent nearly all the time paging in stuff from disk, and doing a trivially small amount of operating between GC
07:31:37 <ndm> so GC time was ~60%, but in reality was more like 99% including the time to page in the memory
07:32:07 <ndm> i just ran it on the dept server with plenty of memory, lots of processor and not playing my music
07:32:16 <ketil> I wonder if I'm building the Map in a suboptimal way - from a sorted list, perhaps.  Should it matter?
07:32:28 <quicksilver> there is always fromAscList
07:32:37 <quicksilver> which will save you a bit of time
07:32:45 <quicksilver> if it really is sorted
07:32:46 <ketil> any idea how much?
07:32:55 <ketil> I'll have to check, but I think it is.
07:32:57 <quicksilver> O(n) instead of O(log n)
07:32:58 <quicksilver> I think
07:33:00 <quicksilver> erm
07:33:08 <ketil> O(1) per insert?
07:33:11 <quicksilver> (n) instead of (n log n)
07:33:12 <quicksilver> yes
07:33:53 <ketil> That would probably be worth it, I guess.
07:33:56 <ndm> ketil: yes, if its sorted use fromAscList, if its not, do fromList and it will sort as it goes
07:34:03 <pejo> ndm, doens't the gc walk the live memory, which might be considerably smaller than the heap?
07:34:06 <ndm> that won't change your memory consumption though, but is a better thing
07:34:18 <quicksilver> I think if you're messing with data structures in the region of (All my memory) you might want to consider algorithms which work straight from disk
07:34:32 <quicksilver> ndm: I imagine it generates a lot less garbage
07:34:36 <ndm> pejo: i once got told that the *best* way to screw a modern processor is to allocate a large array just over the size of physical memory and randomly access it
07:34:55 <ndm> pejo: you screw the cache, the paging, pretty much everything - you loose 10,000x's in speed
07:34:56 <quicksilver> ndm: I bet the balancing algo generates plenty of garbage as you build huge Maps from unsorted data.
07:35:16 <ketil> ndm: using fromList now.  does fromAscList *check* the sorting? :-)
07:35:24 <quicksilver> no
07:35:28 <ndm> pejo: and GC does just walk the live memory, which is probably randomly scattered
07:35:30 <quicksilver> don't think so
07:35:38 <ndm> it doesn't
07:35:48 <ac> why doesn't this work: put = do mapM put someList; put somethingPuttable; mapM put anotherList -- ? It works without the last mapM.
07:35:59 <jedbrown> ketil: You can use Map.valid afterwards.
07:36:03 <quicksilver> ac: mapM_
07:36:10 <dmead> haskellers!!!!!!!!!!!1
07:36:14 <quicksilver> ac: mapM put has type Put [()]
07:36:18 <quicksilver> ac: you want type Put ()
07:36:19 <ac> quicksilver: ah thanks
07:36:21 <quicksilver> ac: so mapM_ ;)
07:36:24 <dmead> you guys can lambda my ultimate, anytime
07:36:26 <ac> makes perfect sense
07:36:34 <ndm> plus mapM_ is much more efficient than mapM
07:36:36 * quicksilver hands dmead a cup a strong lambda.
07:36:44 <ndm> its tail recursive, typically, where the other one is not
07:36:48 <ac> dmead: lol
07:36:49 <dmead> :P
07:37:03 <ketil> There's also the -c (compacting gc) option to try out.
07:37:12 <ketil> jedbrown, okay.
07:38:19 <jedbrown> ketil: I made that mistake a while back when I changed the Ord instance, but not some code that relied on it.  All sorts of funny behavior until someone mentioned valid.
07:38:28 <ac> this is good fun. I can't wait 'til I finish this so I can upload it and hear all the ways I can improve it from y'all
07:39:35 <roconnor> does return . join === id?
07:40:09 <quicksilver> :t return . join
07:40:17 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
07:40:33 <quicksilver> roconnor: yes, that's one of the monad laws.
07:40:41 <quicksilver> roconnor: (assuming m = m1 in that type, obviously)
07:40:44 <roconnor> quicksilver: one of the laws is join . return === id
07:40:59 <quicksilver> return . join is another of the laws
07:41:04 <roconnor> really?
07:41:06 <quicksilver> it's another path through the same commuting diagram
07:41:13 <quicksilver> as generally drawn by categorists
07:41:18 <quicksilver> I believe...
07:41:27 <quicksilver> oh
07:41:30 <quicksilver> hang on
07:41:34 <quicksilver> no, it's not true at all
07:41:37 <quicksilver> I'm ralking rubbish
07:41:39 * quicksilver apologies
07:41:47 <roconnor> ok
07:41:52 <quicksilver> > return . join $ [[1,2],[3,4]]
07:41:52 <lambdabot>   add an instance declaration for (Show (m [a]))
07:41:55 <ketil> On my small test case: fromAscList decreases the time from 1:31.11 to 1:30.86... :-)
07:41:58 <quicksilver> > return . join $ [[1,2],[3,4]] :: [Int]
07:41:59 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
07:42:06 <quicksilver> > (return . join $ [[1,2],[3,4]]) :: [Int]
07:42:06 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
07:42:13 <roconnor> > return . join $ [[1,2],[3,4]] :: [[Int]]
07:42:13 <doserj> > return $ join [[1,2],[3,4]] ::[[Int]]
07:42:14 <lambdabot>  [[1,2,3,4]]
07:42:14 <lambdabot>  [[1,2,3,4]]
07:42:18 <quicksilver> thank you :P
07:42:20 <roconnor> not the same
07:42:26 <quicksilver> as you can see, not the same :)
07:42:34 <roconnor> interesting
07:42:39 <roconnor> my monad has this law.
07:42:52 <roconnor> which is why I guess people thing my monad is boring :)
07:43:06 <quicksilver> I think that means your monad is only '1-slot'
07:43:09 <quicksilver> like Maybe
07:43:35 <quicksilver> > (return . join $ Just (Just 1)) :: Maybe (Maybe Int)
07:43:36 <roconnor> is Reader 1-slot?
07:43:36 <lambdabot>  Just (Just 1)
07:43:39 <quicksilver> yup
07:43:44 <roconnor> okay
07:43:45 <quicksilver> so's state.
07:43:49 <roconnor> wow
07:43:50 <quicksilver> and writer
07:43:56 <roconnor> so lots have this extra property
07:44:03 <quicksilver> I just made up that terminology, by the way
07:44:09 <quicksilver> I don't know if there is a better name for it
07:44:10 <roconnor> understood
07:45:01 <quicksilver> actually maybe it depends on what you mean by ==
07:45:08 <doserj> > return . join $ Nothing :: Maybe (Maybe Int)
07:45:08 <lambdabot>  Just Nothing
07:45:14 <quicksilver> with state, return . join != id
07:45:22 <roconnor> ah
07:45:28 <roconnor> so my monad is special.
07:45:28 <quicksilver> but, return . join would be 'observationally equivalent' to id
07:45:32 <quicksilver> I think
07:45:38 <roconnor> hmm
07:45:43 <quicksilver> even in IO, I think return . join is 'observationally equivalent' to id
07:45:52 <roconnor> right
07:46:01 <quicksilver> possibly excluding IO exceptions
07:46:03 <masterD> hi @ all
07:46:17 <babyborn> eii wer kennt mich?
07:46:19 <roconnor> you think?
07:46:37 <vincenz> roconnor: yep
07:46:41 <masterD> eyyy
07:46:43 <Wollyhood> any gay here?
07:46:51 <masterD> is anybody playing wow?
07:46:56 <WoW> yes masterD
07:47:02 <vincenz> wrong place
07:47:04 --- mode: ChanServ set +o vincenz
07:47:06 <masterD> ok..
07:47:13 <WoW> anybody gay?
07:47:16 <masterD> nope
07:47:17 <vincenz> WoW: please leave this channel
07:47:20 <Wollyhood> yeah i wow
07:47:23 <araujo> hello
07:47:29 <babyborn> eiii shwulis =)
07:47:30 <Wollyhood> haha wow is my boyfreind
07:47:32 <Wollyhood> i love him
07:47:35 <WoW> i'd like to play wow on you vinc
07:47:44 <Wollyhood> dont flirt please voncez
07:48:04 <ari> :t return . join
07:48:06 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
07:48:11 --- mode: vincenz set +b *!*@62-167-236-67.static.adslpremium.ch
07:48:15 --- kick: Chef_ was kicked by vincenz (vincenz)
07:48:17 --- kick: WoW was kicked by vincenz (vincenz)
07:48:19 --- kick: barbiegirl was kicked by vincenz (vincenz)
07:48:24 --- kick: masterD was kicked by vincenz (vincenz)
07:48:30 --- kick: Wollyhood was kicked by vincenz (vincenz)
07:48:35 <Valodim_> haha
07:48:48 --- mode: vincenz set -o vincenz
07:48:49 <vincenz> There we go
07:49:00 <osfameron> that was fun
07:49:06 <vincenz> quick n easy
07:49:57 <roconnor> well, now I have to prove this law for my Monad.
07:51:16 * vincenz wonders what motivates people
07:51:37 <roconnor> I guess there are just lots of people.
07:51:47 <roconnor> and it only takes 1
07:54:15 <taruti> Is there a way to mark some expressions "evaluated" to hpc? like typeOf (undefined :: Foo)
07:55:13 <byorgey> vincenz: mind doing that in #haskell-blah too?
07:55:24 <vincenz> byorgey: don't got ops there
07:55:44 <ndm> taruti: nope, alas - me and dons requested it a few days ago
07:58:03 <taruti> ok
07:58:04 <ac> is something like "bigBlock <- replicateM someBigNumber getWord8" handled efficiently?
07:58:28 <ndm> andyjgill: taruti was just asking to mark typeOf (undefined :: Foo) as evaluated in hpc
07:58:33 <ac> or is it O(someBigNumber)?
07:58:44 <ndm> taruti: andyjgill is the hpc person :)
07:59:03 <taruti> ok, I'll bug him if I encounter more issues :)
07:59:17 <mauke> ac: how can it not be O(someBigNumber)?
07:59:51 <ac> mauke: because the byte strings are immutable, bigBlock could just be a pointer
08:00:09 <mauke> :t replicateM
08:00:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:00:15 <mauke> no, it couldn't
08:00:37 <ac> I have no clue how things are optimized behind the scenes
08:00:39 <jedbrown> ac: You're making a list (different data structure).
08:01:50 <ac> isn't take more efficient with ByteStrings than with lists?
08:01:54 <matthew_-> say I've got a set of MVars and I want to read whichever gets filled first. Is there a better way than just spinning on them all with endless tryTakeMVar ? Is there a select or poll somewhere?
08:02:21 <mauke> matthew_-: use TVars instead
08:02:37 <jedbrown> matthew_-: Maybe Chan is appropriate?
08:02:46 <ToRA> matthew_-: they all of the same type?
08:02:46 <matthew_-> no, Chan is not appropriate
08:02:58 <matthew_-> ToRA: um, for the thyme being
08:03:18 <matthew_-> mauke: feel free to elaborate
08:03:28 <taruti> matthew_-: ch <- newChan; sequence_ [ forkIO (writeChan ch =<< takeMVar mv) | mv <- listOfMVars ]; readChan ch
08:03:52 <ndm> vincenz: can you ask the admin king of haskell-blah and haskell-overflow and ghc to promote all haskell admins to admin all of them?
08:04:28 <Tac-Tics> besides MVars blocking if the bucket is full, what is the difference between MVars and Chans?
08:04:44 <matthew_-> Chans are made of MVars. MVars are not made of Chans
08:04:56 <matthew_-> taruti: ahh, yes, good idea - I assume that was also what jedbrown was getting at
08:05:02 <vincenz> ndm: who is admin king?
08:05:27 <ricky_clarkson> shapr
08:05:31 <vincenz> shapr?
08:05:50 <matthew_-> taruti: whilst that'd work, I can't see it being particularly efficient.
08:05:56 <vincenz> @tell shapr < ndm> vincenz: can you ask the admin king of haskell-blah and haskell-overflow and ghc to promote all haskell admins to admin all of them?
08:05:56 <lambdabot> Consider it noted.
08:06:33 <matthew_-> taruti: in fact, given I only care about one answer, that Chan could well be an MVar itself
08:08:45 <mauke> matthew_-: with TVars or TMVars you could `orElse` the reads
08:09:03 <quicksilver> matthew_-: can you explain a little further why Chan is not appropriate?
08:09:12 <matthew_-> taruti: actually, the behaviour of yours is different to select as yours risks reading all the results
08:09:22 <quicksilver> why are your writers all writing to different MVars?
08:09:28 <quicksilver> why are they not all writing to the same Mvar?
08:10:20 <matthew_-> quicksilver: each MVar is actually sorta like a heterogeneous MVar List
08:10:45 <matthew_-> quicksilver: think process algebra channels which statically record the types that shall be communicated over the channel
08:11:02 <matthew_-> so I've got a set of channels and I just want to read from which ever is ready first
08:11:09 <quicksilver> one solution would be to have the writers write first to the channel
08:11:14 <quicksilver> and then to a syncrhonisation MVar
08:11:18 <quicksilver> which says "I've just written"
08:11:26 <quicksilver> (and tells you who "I" is)
08:11:38 <quicksilver> then your reader waits on this synchronisation MVar
08:11:49 <quicksilver> and when it reads something, that value somehow tells it which MVar to go read.
08:12:15 <vincenz> erm
08:12:19 <vincenz> quicksilver: that's a poor way of doing it
08:12:23 <vincenz> there's better ways of making queues
08:12:28 <vincenz> that do not block as long as there's something in them
08:12:34 <matthew_-> res <- newEmptyMVar; sequence_ [ forkIO (takeMVar mv >>= \v -> tryPutMVar res v >>= \s -> if s then return () else putMVar mv v) | mv <- listOfMVars ]; takeMVar res
08:12:55 <quicksilver> vincenz: this isn't a queue?
08:13:13 * vincenz just randomly popped in and shuts up
08:13:23 <matthew_-> no, this isn't a queue, and the writers are unaware that they are writing into a multi-read/select thingy
08:13:33 <quicksilver> why should they be?
08:13:37 <sizur> @hoogle Category
08:13:37 <lambdabot> Control.Category :: module
08:13:37 <lambdabot> Control.Category.Category :: class Category cat
08:13:37 <lambdabot> Distribution.InstalledPackageInfo.category :: InstalledPackageInfo_ m -> String
08:13:39 <quicksilver> I mean, obviously they should
08:13:44 <quicksilver> but they can write into something abstract
08:13:49 <quicksilver> which does this itself
08:13:52 <quicksilver> without them "knowing"
08:14:33 <matthew_-> yeah. But also it's fully async so writers can be miles off in the distance
08:14:43 <sizur> @src Control.Category.Category
08:14:43 <lambdabot> Source not found. :(
08:16:05 <sizur> what is morphism in the Hask category?
08:16:05 <quicksilver> matthew_-: then replace "synchronisation MVar" with "syncrhonisation Chan"
08:16:20 <quicksilver> and it's non-blocking from the writer end
08:16:29 <quicksilver> sizur: a function
08:16:43 <vincenz> quicksilver: I wonder if it's possbile to make it non blocking on reader and writer end
08:16:59 <matthew_-> quicksilver: right, but the set of "channels" can dynamically change
08:16:59 <quicksilver> I find that a poor goal
08:17:05 <mauke> why isn't STM a MonadPlus?
08:17:11 <quicksilver> normally my goal is to make things blocking, not non-blocking
08:17:17 <sizur> so i can have a functor mapping a function to a morphism in another category?
08:17:32 <quicksilver> sizur: you can have a functor, but not a Functor
08:17:35 <vincenz> quicksilver: if you have a bunch of consumers and producers, blockinig is a loss
08:17:38 <quicksilver> sizur: Functors are alwas Hask -> Hask
08:17:52 <matthew_-> hmm. orElse is really pretty similar to msum
08:17:53 <sizur> why are they called liek that then?
08:18:07 <quicksilver> vincenz: it's always good for a consumer to block when there is nothing to do
08:18:09 <quicksilver> that's what I meant
08:18:13 <vincenz> quicksilver: oh right, yes
08:18:18 <vincenz> quicksilver: but let's say the queue is full enough
08:18:20 <quicksilver> so the goal of the system is to block (rather than, say, spinwait)
08:18:23 <vincenz> quicksilver: then having readers block is bad
08:18:27 <quicksilver> right
08:18:37 <quicksilver> sizur: because they are functors. They are functors from Hask -> Hask.
08:18:47 <quicksilver> sizur: All Functors are functors, but not all functors are Functors.
08:18:47 <vincenz> the thing you have to give up is determinism on order of taking
08:19:43 * vincenz wonders if that's encodable
08:20:30 <matthew_-> actually, I like your idea quicksilver: all you need is an MVar which contains a mask of everything that is ready, so you read that and if it doesn't contain anything you care about then you replace it with something that ... err. stuck.
08:20:47 <quicksilver> yes, something like that :)
08:20:58 <quicksilver> there are various variations
08:21:06 <matthew_-> inevitably ;)
08:21:10 <quicksilver> depending on the type discipline between producers and consumers and stuff
08:21:20 <mux> can someone dig out that link about typing printf in functional languages with higher-order functions?
08:21:41 <quicksilver> if some messages are obviously only right for certain consumers, maybe you can save wasted time scannign over inappropraite messages
08:21:49 <quicksilver> if "every" message is appropriate it's really not very had
08:21:51 <quicksilver> hard
08:22:02 <quicksilver> and a Chan sounds like the simplest solution.
08:22:10 <mux> I meant that paper
08:22:11 <quicksilver> I find MVars and Chans surprisingly expressive.
08:22:13 <mux> at least I think it exists
08:22:23 <vincenz> quicksilver: sort of like restaurants in switzerland?
08:24:12 <taruti> matthew_-: are you trying to have a single channel where you can send multiple types of values?
08:24:31 <byorgey> mux: http://citeseer.ist.psu.edu/danvy98functional.html
08:24:31 <taruti> which have different handlers.
08:24:34 <byorgey> mux: is that it?
08:24:37 <lambdabot> Title: Functional Unparsing (ResearchIndex)
08:25:35 <sizur> quicksilver: but doesn't that beat the purpose of a functor if it stays in the same category? how is then a functor different from a function?
08:25:59 <mux> byorgey: sounds pretty much to the point, though I remember a different name, thanks!
08:26:11 <sizur> unless Hask is a large category
08:26:12 <matthew_-> taruti: err no. much worse than that. multiple linearly-heterogeneous and bidirectional channels
08:26:30 <quicksilver> sizur: totally different.
08:26:42 <quicksilver> sizur: functors act on objects (in this case, haskell types)
08:26:51 <quicksilver> sizur: functions are a haskell concept, not a CT concept
08:26:54 <quicksilver> they act on value.
08:26:55 <quicksilver> s
08:27:47 <sizur> but if a function is a value, and set of values is a type, then functors are functions, no?
08:28:17 <vincenz> sizur: at the type level
08:28:33 <vincenz> and with some restrictions
08:30:49 <taruti> matthew_-: oh ok. (just had some code lying around which implements polymorphic channels for message passing, but won't probably be relevant to you)
08:31:09 <quicksilver> sizur: NO.
08:31:16 <quicksilver> sizur: a functor is not a function.
08:31:25 <quicksilver> sizur: a functor is a mapping on objects *and* morphisms.
08:31:28 <quicksilver> that's the key point.
08:31:38 <quicksilver> functors have much more structure than functions.
08:31:56 <vincenz> quicksilver: oh, good point
08:32:11 <quicksilver> (a mapping on objects and morphisms, which preserves categorical composition, indeed)
08:32:58 <sizur> aha, so in Hask, a functor maps types and functions, while functions map only types
08:33:15 <quicksilver> no, functions map only values
08:33:24 <quicksilver> a functor maps types and functions, a function maps values
08:33:35 <quicksilver> they are "on different levels"
08:33:42 <sizur> functions are morphisms, morphisms map objects, and objects are types in Hask?
08:33:56 <vincenz> objects belong to types
08:34:02 <vincenz> well 'values'
08:34:21 <quicksilver> morphisms don't map objects
08:34:22 <vincenz> but 'a is a morphism' and 'b is a morphism' does not mean 'a is b'
08:34:31 <quicksilver> morphisms in general don't do anything, they just are
08:34:40 <byorgey> dons: ping
08:34:46 <glen_quagmire> haddock: no GHC lib dir specified    how do I fix it?
08:34:47 <quicksilver> (in specific categories, morphisms normally do something of interest)
08:34:50 <vincenz> quicksilver: I think I'm confusing things more, I'll shut up
08:34:56 <quicksilver> but in general, a morphism has no structure.
08:35:00 <quicksilver> it's just something which can compose.
08:35:14 <quicksilver> in the category Hask, a morphism is a function.
08:35:17 <quicksilver> and functions map values.
08:35:34 <quicksilver> that's a particular characteristic of Hask rather than a general characteristic of categories though
08:36:11 <glen_quagmire> haddock -B C:\ghc\ghc-6.8.2  Shape.hs   --worked
08:36:25 <byorgey> e.g. in the categorical view of a group (a single-object category), the morphisms are group elements, which don't "do" anything, they can just be composed.
08:36:36 <sizur> "a morphism is an abstraction of a structure-preserving mapping between two mathematical structures" -wikipedia
08:37:05 <Tac-Tics> and mapping is just another (slightly more general) term for a function, right?
08:37:09 <EvilTerran> "an abstraction" - it's more general than that
08:37:15 <EvilTerran> (i think)
08:37:44 <quicksilver> sizur: "an abstraction"
08:37:51 <quicksilver> it is much more than that
08:38:01 <quicksilver> it's just that in many commmon categories, a morphism is a function
08:38:08 <quicksilver> those are the most boring categories you can imagine
08:38:17 <quicksilver> in most interesting categories, a morphism is not that
08:38:26 <quicksilver> and the 'false intuition' that morphisms must be functions
08:38:29 <quicksilver> is a real hindrance :)
08:38:48 <quicksilver> Tac-Tics: in the sentence that sizur quoted, they probably just mean "function"
08:39:01 <quicksilver> Tac-Tics: although sometimes mapping is taken to mean something more like "relation"
08:39:11 <quicksilver> Tac-Tics: so you can have one-to-many mappings, etc.
08:39:19 <sizur> i'm trying to understand why a function (being a value) is a morphism that acts on values, while objects are types.
08:39:28 <sizur> in Hask
08:39:38 <sizur> jsut by definition?
08:39:41 <quicksilver> yes
08:39:49 <quicksilver> and you're mixing levels of abstraction a bit.
08:39:58 <quicksilver> The following part has nothing to do with category theory:
08:40:04 <quicksilver> haskell has values, arranged into types.
08:40:10 <quicksilver> A haskell function maps values to values.
08:40:24 <quicksilver> Haskell functions always go from a fixed type A to a fixed type B.
08:40:32 <quicksilver> That's all just (one way) of describing haskell.
08:40:40 <quicksilver> Then, you can observe that haskell looks a bit like a category:
08:40:50 <sizur> what category has values as objects?
08:40:53 <Tac-Tics> Maybe a category looks like a big haskell
08:41:00 <quicksilver> Consider the category Hask, where objects are haskell types, and morphisms are haskell functions.
08:41:10 <quicksilver> sizur: no interesting category.
08:41:25 <quicksilver> well no obviously interesting one.
08:41:33 <quicksilver> A partial ordering on a type would be a category.
08:41:36 <quicksilver> In a fairly dull way.
08:41:43 <Codex_> values are usually 1->A morphisms.
08:42:18 <sizur> yeah you can see values as constant functions
08:42:34 <sizur> in Hask
08:42:49 <sizur> that helps
08:43:42 <sizur> so in Hask, objects 'consist' of morphisms then?
08:44:01 <Codex_> the main feature of 1->A morphism is that you can only use it to find "one" object of type A. No more.
08:44:02 <sizur> it's their structure
08:44:09 <byorgey> no, objects are types, which are collections of values
08:44:35 <sizur> byorgey: consider a value to be a constant function therefore a morphism
08:47:41 <sizur> and since objects are types, and types are sets of values, then objects are sets of values, and objects are sets of morphisms (sinse a value is a constant function, and a function is a morphism).
08:47:52 <sizur> or what am i mixing here again?
08:48:28 <fadec> is there a way to define num instances of f and g so that f + g == f x + g x, assuming f and g are of type Num a => t -> a  ?
08:48:52 <mauke> fadec: yes
08:48:55 <fadec> I tried (instance Num (Double -> Double))
08:49:28 <vincenz> instance (Num a) => (Num (a -> a)) where ...
08:49:34 <fadec> is -XFlexibleInstances the way to do this?
08:49:48 <mauke> fadec: http://mauke.ath.cx/stuff/haskell/fun.hs
08:49:58 <mauke> (does that url work?)
08:49:59 <sizur> i guess i cannot consider a value to be a constant function, they are two different things
08:50:31 <Codex_> sizur: Values are specific kind of morphisms, not any arbitrary morphism.
08:50:54 <fadec> mauke: thanks!
08:51:45 <Codex_> sizur: also, you have to think objects as if they were abstract.
08:52:23 <Codex_> sizur: so you cannot assign any structure to objects.
08:52:35 <mauke> fadec: this has the side effect of making "1 2 3" compile and run
08:52:50 <sizur> Codex_: even if we talk about a specific category?
08:53:02 <litb> i have one more question about monads
08:53:45 <litb> so far, i have understood that do { x; a } is translated to x >> \_ -> a
08:54:20 <ibid> >>=, actually
08:54:27 <litb> and do { x <- q; z} is translated to q >>= \x -> z
08:54:34 <litb> ibid: oh sorry. yes that was a typo
08:54:50 <Codex_> sizur: well, you never talk about specific category. You either talk about all categories, or its not a category at all. :)
08:55:01 <sizur> do { x; a } is translated to x >> \_ -> a
08:55:03 <ibid> (the actual translation is a bit more complex, but that's the main idea)
08:55:07 <sizur> eh problem with emacs
08:55:28 <sizur> do { x; a } = x >> a
08:55:34 <litb> but now, i have seen code that does things like do { x<-q; y<-r; return (x, y) }
08:56:39 <jedbrown> litb: which translates to:  liftM2 (,) q r
08:56:43 <jedbrown> litb: clearer now?
08:56:54 <byorgey> litb: right, that's q >>= \x -> (r >>= \y -> return (x,y))
08:56:59 <jedbrown> litb: q >>= \x -> r >>= \y -> return (x,y)
08:57:10 <ibid> litb: so, what's the problem?
08:57:13 <mauke> @undo do { x<-q; y<-r;  return (x, y) }
08:57:14 <lambdabot> q >>= \ x -> r >>= \ y -> return (x, y)
08:57:56 <litb> byorgey: ah, they are nested. i see
08:58:20 <byorgey> in fact, do { x <- q ; Z } is translated to q >>= \x -> do Z  where Z could be a sequence of semicolon-separated things.  so the desugaring proceeds recursively.
08:58:30 <byorgey> litb: right.
08:59:16 <byorgey> er, do { Z }
08:59:31 <quicksilver> Codex_: That's a little strong.
08:59:42 <quicksilver> Codex_: You sometimes speak of 'Foo' categories, for some Foo
08:59:48 <litb> now i only have to decipher how that yields to all the pairwise combinations when used with a list Monad and then i think i will have understood how Monads are used in haskell :)
08:59:49 <quicksilver> Codex_: like, containing all finite limits
09:00:02 <fadec> mauke: I'm fiddling with your code now. All I want to do is write things like f = sin; g t = sin (t * 2); h = f + g; ... without explixitly passing around the t ... btw that is a neat side effect (3 2 1) == 3
09:00:48 <mauke> fadec: you can do that; I just tried it in ghci :-)
09:00:57 <mauke> h is monomorphed to Double -> Double, though
09:01:13 <litb> > do { a<-[1, 2]; a<-[3, 4]; return (b, a) }
09:01:15 <lambdabot>   Not in scope: `b'
09:01:20 <litb> oh
09:01:25 <litb> > do { a<-[1, 2]; b<-[3, 4]; return (b, a) }
09:01:27 <lambdabot>  [(3,1),(4,1),(3,2),(4,2)]
09:01:38 <litb> yeah
09:01:49 <mauke> each <- introduces a nested for loop
09:02:24 <sizur> but theoretically speaking i can have a functor from Hask to C++ which is the formal compiler definition that compiles haskell to c++, right?
09:02:40 <quicksilver> sizur: good luck making C++ into a category :)
09:02:50 <sizur> well, theoretically
09:03:02 <quicksilver> hask "is" a category because of purity
09:03:06 <mauke> fadec: -fno-monomorphism-restriction and h gets the type h :: (Floating a) => a -> a
09:03:11 <litb> mauke: ah, that's the reason why the return still "sees" the a and b?
09:03:37 <quicksilver> although it fails to be a category because of seq
09:03:49 <mauke> litb: your code is equivalent to concatMap (\a -> concatMap (\b -> [(b, a)]) [3, 4]) [1, 2]
09:04:03 <mauke> (>>=) = flip concatMap
09:04:05 <quicksilver> and even ignoring the seq problem it lacks all kinds of nice properties because of _|_
09:04:13 <Codex_> quicksilver: but then it still works with all categories that have finite limits -- like there's a boolean flag defined for each category whether it has equalizers, products etc. But you have similar boolean for every kind of category.
09:04:14 <litb> mauke: nice, that is what i was looking for :) i will now see how that can make sense in my head
09:04:28 <byorgey> litb: the return still "sees" the a and b because it takes place inside the body of lambda expressions with a and b as arguments.
09:04:53 <quicksilver> Codex_: yes. And sometimes there is "essentially" only one category that meets all the requirements
09:04:54 <litb> byorgey: yeah, i finally get into all this monadic stuff
09:05:02 <quicksilver> Codex_: in which case you might as well be talking about a specific one :)
09:05:08 <byorgey> litb: =)
09:05:31 <sizur> :i seq
09:05:39 <fadec> mauke: the Double -> Double is what I would expect. That's sweet.
09:05:47 <Codex_> quicksilver: it's just difficult to define the requirements in detailed enough way that only one category meets them.
09:05:52 <sizur> quicksilver: what's the problem with seq?
09:06:37 <quicksilver> I don't remember.
09:06:44 <quicksilver> Maybe I'm conflating it with something else.
09:07:00 <quicksilver> It's all tied up in what you consider equality on functions to mean.
09:07:06 <sizur> > seq undefined 'a'
09:07:07 <lambdabot>  Undefined
09:07:16 <sizur> seq () 'a'
09:07:27 <quicksilver> To make sense of categorical theorems you need to know what it means for two functions to be equal.
09:07:27 <sizur> > seq () 'a'
09:07:28 <lambdabot>  'a'
09:07:31 <quicksilver> morphisms.
09:07:59 <sizur> flip const () 'a'
09:08:05 <quicksilver> and you get into questions like is _|_ teh same as \_ -> _|_
09:08:06 <sizur> > flip const () 'a'
09:08:06 <lambdabot>  'a'
09:08:14 <mauke> > const id () 'a'
09:08:15 <lambdabot>  'a'
09:08:36 <quicksilver> and only seq makes the difference observable
09:08:44 <quicksilver> which informs how you answer that question...
09:08:50 <phlpp> @index Pirme
09:08:50 <lambdabot> bzzt
09:08:51 <phlpp> @index Prime
09:08:52 <lambdabot> bzzt
09:09:03 <litb> now, in ghci console i can do "a<-getLine" without writing do, and the a is even still visible after that statement
09:09:28 <quicksilver> litb: yes, that's a ghci hack
09:09:29 <litb> how is that? does it insert a "invisible" "do" after i press return?
09:09:36 <litb> oh i see
09:09:38 <quicksilver> litb: ghci lies to you
09:09:42 <allbery_b> ghci command loop is effectively one big "do"
09:09:42 <quicksilver> it's not really a haskell interpreter
09:09:43 <sizur> quicksilver: seq == const id? const and id are perfectly pure math functions
09:09:44 <litb> it confused me
09:09:53 <quicksilver> it's a bit of clever magic
09:10:18 <quicksilver> sizur: seq is not const id
09:10:20 <mauke> litb: ghci also lets you say 'let x = 2+2'
09:10:42 <quicksilver> litb: it's very handy to think of the command loop as one big do though
09:11:04 <byorgey> litb: think of everything you type in ghci as being in a do block of type IO (), with the added convenience that if you enter something not of type IO (), it gets wrapped in a call to 'print'
09:11:13 <litb> i don't know how let in a do expression translates to "pure" haskell
09:11:36 <allbery_b> @undo do { let {a = 5}; print a }
09:11:36 <lambdabot> let { a = 5} in print a
09:11:43 <byorgey> do { let x = y; Z }  --> let x = y in do { Z }, essentially
09:11:49 <mauke> litb: do { let v = E; ...} becomes let v = E in do { ... }
09:12:25 <kpreid> litb: you can use @undo here to see the transformation
09:12:26 <litb> ah i see
09:12:49 <litb> > do { print a; let a = 2 }
09:12:49 <lambdabot>  Parse error at "}" (column 25)
09:12:56 <litb> hm
09:12:57 * sizur goes home.
09:13:11 <byorgey> > do { let (x:xs) = [] ; f <- x ; return f } :: Maybe Int
09:13:11 <lambdabot>  Parse error at "<-" (column 26)
09:13:19 <litb> i thought that this would be possible then, since the let is "before" the do in the translated one
09:13:27 <roconnor> @seen mattam
09:13:28 <lambdabot> mattam is in ##logic and #haskell. I don't know when mattam last spoke.
09:13:29 <mauke> litb: no, it isn't
09:13:32 <quicksilver> litb: if you've got actions before the let
09:13:32 <kpreid> litb: let and <- can't be the last thing in a do block
09:13:34 <glen_quagmire> I did runhaskell Setup.hs install && cd .. && rm -rf SomePackage . How can I uninstall SomePackage from GHC ?
09:13:39 <litb> oh yeah i remember
09:13:41 <quicksilver> litb: then you get nested dos and lets and dos and lets
09:13:45 <mauke> litb: it becomes print a >> let a = 2 in do {}
09:13:45 <litb> each one after a ; is a seperate do
09:13:58 <quicksilver> @undo do { print b ; let {a = 5}; print a }
09:13:58 <lambdabot> print b >> let { a = 5} in print a
09:14:05 <quicksilver> nested dos and lets
09:14:09 <litb> damn that is tricky :)
09:14:09 <quicksilver> well that's one way of looking at it :)
09:14:10 <phlpp> byorgey: you said yesterday, that if 2^n - 1 is prime then n has to be prime.. but how to proof that?
09:14:34 <roconnor> phlpp: look at the binary representation of 2^n - 1
09:14:36 <phlpp> i mean by looking at different exmaples it's like 2^n - 1 is only prime if n is prime, too, but i couldn't figure out how to proof that
09:14:54 <byorgey> phlpp: easy: if n = pq is not prime, then 2^n - 1 can be factored
09:15:36 <quicksilver> (x^n - 1) is factorisable (as a polynomail) for all n >= 2
09:15:43 <quicksilver> it "obviously" has a factor of (x-1)
09:15:45 <byorgey> phlpp: 2^(pq) - 1 = (2^p - 1)(2^(p-1)q + 2^(p-2)q + ... + 2^q + 1)
09:16:19 <roconnor> the binary represenation of 2^n - 1 is a string of n 1's
09:16:26 <roconnor> if n can be factored
09:16:37 <roconnor> then the string of n can be grouped into p groups of q
09:16:51 <roconnor> that means 2^q - 1 is a factor
09:16:56 <litb> ok, i'm off again. thanks for monading me into the changing world
09:17:13 <phlpp> ah, cool. thanks byorgey and roconnor
09:17:16 <roconnor> along with a number like 1000001000001000001000001
09:18:10 <roconnor> which is byorgey's factorization
09:19:06 <byorgey> quicksilver: yes, but when x = 2 that's not very useful =)
09:22:31 <quicksilver> byorgey: eh?
09:22:43 <quicksilver> byorgey: x isn't 2
09:22:49 <quicksilver> byorgey: x is 2^p
09:22:58 <quicksilver> byorgey: (or 2^q, depending which way you split it)
09:24:32 <mattam> roconnor: i'm around
09:24:54 <mattam> roconnor: I'm on the other side of the atlantic thouh :)
09:25:56 <roconnor> oh
09:26:10 <roconnor> I want to talk to you about your mail
09:26:20 <mattam> ok
09:26:21 <roconnor> but not right now since I have to make dinner
09:26:42 <roconnor> Perhaps in a few hours, but in anycase don't let me forget about it.
09:26:53 <mattam> understood
09:31:15 <byorgey> quicksilver: ah, right =)
09:50:55 <BMeph> srid: ping
09:55:30 <radetsky> dons: you there?
09:56:13 <Adis> Has anyone ever tried using CACTUS?
09:57:24 <faxathisia> heheheh - Concrete to Abstract syntax Conversion Tool with User-friendly Syntax
09:57:53 <Adis> yeah, although the feeling is similar to trying to handle a real cactus
09:58:05 <Adis> I can't get the damn thing to work
09:59:08 * BMeph thinks Adis should "discuss" what *user-friendly* means with someone...
09:59:37 <Adis> tried that aswell, can't get to the guy :(
10:00:38 <faxathisia> Adis, if your open to alteratives I'd recommend Parsec
10:00:48 <faxathisia> you're*
10:00:57 <Adis> what is Parsec?
10:01:34 <jstanley> Parsec is full of fantastic.
10:01:56 <faxathisia> Another way to turn concrete into abstract syntax
10:02:18 <jstanley> Adis: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
10:02:24 <radetsky> Adis: Parsec is proof that computers love us and want us to be happy
10:02:37 <Adis> I certanly hope so
10:02:42 <BMeph> redetsky: Heh. ;)
10:02:47 * ddarius is still amazed by just -how much- people love Parsec.
10:02:48 <jstanley> radetsky: Not tbe confused with 'happy', though =)
10:02:52 <Adis> I've spent hours and days on this project and I'm still on square one
10:02:56 <BMeph> I prefer the original quote, thank you.
10:02:56 * ddarius is not amazed that people do though.
10:03:52 <cpst> it's one of the few parser combinator libraries with any consideration of performance ;-)
10:04:03 <sioraiocht> cpst: which lib is that?
10:04:08 <cpst> Parsec
10:04:18 <sioraiocht> ah, didn't know it had performance benefits
10:05:01 <faxathisia> Parsec does everything except run backwards
10:05:36 <Adis> ahh
10:05:41 <radetsky> does anybody know anything about the relatively low-level operation of keyboards?
10:05:58 <Adis> My problem is, I don't need the tool, I need the grammar
10:06:13 <Adis> I need to perform syntax analisys of Haskell in YACC
10:06:24 <radetsky> in particular, what Ctrl-x vs. x does at a key-code level
10:06:29 <cpst> sioraiocht: I would be pretty shocked if it had a performance benefit over any well-written parser in the usual style
10:06:40 <Adis> or, Happy as I see it's more fit
10:06:50 <cpst> sioraiocht: parser combinators are generally pretty slow
10:06:58 <dmwit> radetsky: C-x also has the Ctrl bit set, I think.
10:07:19 <Adis> So I'm trying to find something to feed to YACC or happy, preferably ready-to-go
10:07:39 <Adis> Does anyone have such grammars or know where I can find them?
10:07:57 <radetsky> dmwit: so it's like two ints, a bitmask and a letter code, or something like that?
10:08:29 <radetsky> (I'm trying to track down a bug in hmp3)
10:09:38 <mauke> I doubt hmp3 goes down to the keycode level
10:10:20 <twanvl> Adis: You want to parse haskell? The Language.Haskell library does that for you.
10:10:21 <radetsky> it doesn't, but I've noticed a correlation between certain modifier keys and this bug
10:10:45 <Adis> twanvl: yes, but I'm not allowed to use shortcuts :(
10:10:47 <mauke> what's the bug?
10:11:05 <radetsky> hmp3 randomly stops playing music without crashing or dieing
10:11:11 <mauke> hmm
10:11:21 <faxathisia> Adis: who is making you do this?
10:11:34 <radetsky> I've mentioned this to dons. I'm going to send him a report, but I want to check it out some more first
10:12:06 <mauke> there are 33 "control" characters in ascii
10:12:25 <mauke> ^@ .. ^_ and ^?
10:12:30 <Adis> faxathisia: my professor at colledge
10:13:00 <Adis> faxathisia: it's a student project, except some people got away easy with C, Java or languages such as those
10:13:16 <radetsky> mauke: I don't think any of them corresponds to Ctrl though
10:13:21 <mauke> if you press ctrl-x in a terminal, the program will see one of those
10:13:40 <mauke> ctrl by itself doesn't generate input
10:13:42 <radetsky> oh, right, I see what you mean
10:13:47 <radetsky> look at this:
10:13:49 <radetsky>     ,(p "Refresh the display",
10:13:50 <radetsky>         ['\^L'], UI.resetui)
10:14:08 <radetsky> this probably means that Ctrl-L calls reset display, right?
10:14:12 <mauke> right
10:14:16 <radetsky> ok
10:14:20 <mauke> (it's a very common key binding)
10:14:45 <radetsky> I wonder if the keygrabber works like Parsec's <|>
10:15:37 <radetsky> actually, nm, that wouldn't explain this
10:15:52 <Tac-Tics> Is it possible in a *.cabal configuration to require something like build-depends pkg1 or pkg2?
10:17:26 <Adis> If anyone happens to have a grammar I can use for happy or YACC, please query me and I'll give you a free yoghurt, I'm going away to fix other peoples programs
10:22:37 <radetsky> does `name` means "use f'n name as an infix op"?
10:23:00 <faxathisia> Yes
10:23:01 <Tac-Tics> yes
10:23:08 <Tac-Tics> > 1 `elem` [1,2,3]
10:23:10 <lambdabot>  True
10:23:16 <radetsky> thanks
10:23:17 <Tac-Tics> > 4 `elem` [1,2,3]
10:23:17 <lambdabot>  False
10:24:08 <Tac-Tics> Similarly, you can use parenthesis to "un-infix" operators
10:24:11 <Tac-Tics> > (+) 1 2
10:24:12 <lambdabot>  3
10:24:17 <Tac-Tics> > (:) 'a' "pples"
10:24:18 <lambdabot>  "apples"
10:24:27 <quicksilver> but sadly not a mixture
10:24:35 <quicksilver> `(`(`(`elem`)`)`)`
10:24:42 <Tac-Tics> hah
10:24:42 <quicksilver> looks pretty but doesn't work :)
10:25:06 <Tac-Tics> quicksilver: there's enough pretty haskell to fill a large garden
10:25:15 <quicksilver> join the campagin for `( arbitrary infix expressions )`
10:25:29 <osfameron> eeek!
10:25:40 <quicksilver> just `(sign your name)` here
10:25:45 * faxathisia would like that
10:25:49 <osfameron> what's a use case for that
10:25:50 <faxathisia> haha
10:25:51 <osfameron> ?
10:25:52 <bos31337> i've wished that would work for a while.
10:26:02 <quicksilver> osfameron: all the same times you want to use ``
10:26:09 <quicksilver> osfameron: but when it's not a single named function
10:26:12 <byorgey> osfameron: [1,2,3] `zipWith (+)` [4,5,6] perhaps?
10:26:38 * byorgey doesn't particularly see a compelling argument for it, though
10:26:50 <mauke> `liftM2 (+)`
10:27:31 <osfameron> some_combinator [1,2,3] (zipWith (+)) [4,5,6]    ?
10:28:14 <quicksilver> yeah, zipWith is a very comon one. and liftM2.
10:28:26 <quicksilver> it's not really compelling
10:28:27 <quicksilver> you can always name it in a where clause
10:28:37 <quicksilver> it's just slightly odd for the expression syntax to be non-compositional.
10:29:04 <quicksilver> most areas of haskell expression syntax permit any expression, IYSWIM.
10:29:40 <balodja> > [1,2,3] `zipWith (+)` [4,5,6]
10:29:40 <lambdabot>  Parse error at "(+)`" (column 18)
10:30:07 <faxathisia> > (\a x b -> x a b) [1,2,3] (zipWith (+)) [4,5,6]
10:30:08 <lambdabot>  [5,7,9]
10:30:43 <twanvl> what is the fixity of `zipWith (+)`?
10:30:56 <balodja> @pl \a x b -> x a b
10:30:57 <lambdabot> flip id
10:31:03 <mauke> none, it's a lexical error
10:31:11 <balodja> Hm, that's easy! :)
10:31:18 <twanvl> I know, I mean, what would it be
10:31:55 <mauke> same as `foo`
10:32:02 <mauke> which is what, infix 9?
10:32:15 <Deewiant> > let f = zipWith (+) in [1,2,3] `f` [4,5,6]
10:32:16 <lambdabot>  [5,7,9]
10:32:27 <byorgey> but then would you be allowed to say infixl 6 `zipWith (+)`?
10:32:31 <mauke> no
10:32:31 <faxathisia> > (\a x b -> a `f` b) [1,2,3] (zipWith (+)) [4,5,6]
10:32:32 <lambdabot>   Not in scope: `f'
10:32:36 <byorgey> seems ugly
10:32:38 <faxathisia> > (\a x b -> a `x` b) [1,2,3] (zipWith (+)) [4,5,6]
10:32:38 <lambdabot>  [5,7,9]
10:34:12 <quicksilver> I don't see that as a big problem, twanvl . I'd be happy with a default, like "very low fixipreceprecedence"
10:34:35 <faxathisia> I stole this from #haskell
10:34:40 <faxathisia> infixr 2 <|; x <| f = f x; infixl 1 |>; f |> x = f x     -- [1,2,3] <| zipWith (+) |> [4,5,6]
10:35:07 <idnar> oh man
10:35:19 <balodja> quantum operators :)
10:35:20 <quicksilver> yeah, that's pretty cool.
10:35:39 <quicksilver> I was here last time that was mentioned but had forgotten about it
10:36:22 <desegnis> now, if ASCII had sub- and superscripts, and if those could be functions in Haskell... :)
10:36:35 <cjb> unicode does..
10:37:36 <desegnis> oh, does it?
10:37:57 <sioraiocht> oh now, not this discussion again
10:38:01 <desegnis> hehe
10:38:10 <phobes> faxathisia:  Or introduce a typeclass defining <| and |> so that you're not allowed to use just one
10:38:17 <twanvl> only certain characters, like 
10:38:44 <mauke> @quote :-
10:38:45 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
10:38:52 <desegnis> twanvl, ah ok, so not in the fancy sense
10:39:15 <radetsky> ED IS THE STANDARD EDITOR HURRR!!!!
10:39:32 <CosmicRay> it would appear I have stepped in at a bad time
10:39:47 <twanvl> no, maybe you could convince your editor to render x_y as subscript, I am sure emacs can do that.
10:39:49 <quicksilver> ;)
10:40:05 <CosmicRay> I'm sure it can, too.  I'm also sure that I don't want it to.
10:40:13 <CosmicRay> unless I'm running it in maxima mode, of course.
10:40:54 <balodja> twanvl: subscripts and superscripts are postfix. do haskell compilers support postfix operators?
10:42:22 <allbery_b> ghc does
10:42:59 <CosmicRay> really?  does anybody use them?
10:43:12 <twanvl> > let (!) x = product [1..x] in (5!)
10:43:13 <lambdabot>  120
10:43:56 <balodja> > let () x = x*x in (4)
10:43:56 <lambdabot>  Illegal character ''\178''
10:43:56 <lambdabot>  at ")" (column 7)
10:44:20 <opqdonut> no unicode support in lambdabot
10:46:47 <quicksilver> it wouldn't be too hard to imagine various ways you could have 2D notation using editor support
10:47:01 * balodja has some unicode patches for lambdabot, but they use iconv :(
10:47:13 <twanvl> why do you need iconv?
10:48:26 <balodja> because they were wrote with aim to support recoding features in irc
10:51:01 <quicksilver>   I quite like the idea of \hat{..} for liftM2
10:51:36 <quicksilver> perhaps \eft< blah \right > for ``
10:52:19 <radetsky> bisy backson
10:54:40 <byorgey> twanvl: regarding rendering x_y as subscript, emacs 22 *does* do that, in fact.  I find it quite nice when editing LaTeX =)
11:17:49 <Sizur> if i have 1gb data, and upgrading my memory is not an option, how can i process it with haskell?
11:17:50 <desegnis> quicksilver, <...> is used for lists in some books, though
11:18:25 <mxc> anyone use haskell on windows?  im curious about any limitations as opposed to running on *nix
11:18:25 <desegnis> Sizur, for example, from the beginning to the end, with lazy byte strings
11:18:55 <desegnis> Sizur, or even with usual Strings
11:19:54 <Sizur> desegnis: wont the parser read the whole thing anyway before i will start to process the data?
11:20:24 <desegnis> Sizur, depends on the parser :)
11:20:34 <CosmicRay> mxc: well, some of the lead developers of ghc are employed by Microsoft, if that means anything
11:20:40 <CosmicRay> mxc: System.Posix is not available.
11:20:44 <CosmicRay> that's about all I'm aware of.
11:21:07 <mxc> so, haskell in windows is basically viable
11:21:12 <CosmicRay> quite
11:21:14 <twanvl> I use windows
11:21:24 <CosmicRay> I think one of the Simons even wrote visual studio plugins
11:21:31 <Sizur> desegnis: i think i get you, just parse a structure at a time and fold them
11:21:35 <mxc> cool
11:21:58 <Sizur> where the folding function is the process
11:22:02 <CosmicRay> mxc: as someone who last used Windows in the 3.11 days, I would say that the usefulness of Haskell on that platform is limited only by the usefulness of the underlying platform ;-)
11:22:18 <allbery_b> haskell is viable on windows.  a grea many haskell/hackage packages aren't (but patches usually accepted)
11:22:41 <Sizur> :t liftM3 foldl
11:22:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b -> a) -> m a -> m [b] -> m a
11:22:52 <mxc> cosmicray - i would like nothing more than to get FC8 or ubuntu on this laptop
11:22:58 <mxc> looking into dual booting now
11:23:16 <mxc> but, i dont have a winxp backup CD, so i:m afraid of bricking it
11:23:23 <mxc> have a valid license, but no cd
11:24:12 <Sizur> :t many
11:24:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
11:24:23 <Sizur> @hoogle many
11:24:24 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
11:24:24 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
11:24:24 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
11:24:39 <Sizur> :t Text.ParserCombinators.Parsec.Prim.many
11:24:40 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
11:24:55 <Sizur> is many lazy?
11:24:56 <mxc> still a super newbie to haskell
11:25:20 <desegnis> Sizur, I think most things in Parsec are lazy (as are most things in Haskell)
11:25:25 <mxc> coming from ocaml background, still sort of weighing the two in my head
11:25:41 <desegnis> Sizur, and that would include many
11:25:45 <CosmicRay> mxc: I used ocaml myself for about a year before going to haskell
11:25:47 <Sizur> would be a good convention to use prime for all strict functions
11:25:56 <CosmicRay> ocaml was a brief stop between python and haskell
11:26:08 <CosmicRay> I realized Haskell was what I wanted ocaml to be:-)
11:26:50 <twanvl> ?hoogle parse
11:26:51 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
11:26:51 <lambdabot> Data.Version.parseVersion :: ReadP Version
11:26:51 <lambdabot> Distribution.Version.parseVersionRange :: ReadP r VersionRange
11:27:26 <twanvl> parsec can't be lazy, because it returns an Either, it has to know if there are any errors
11:27:26 <litb> hm, so, how does the source of the IO Monad instance definition look like?
11:27:31 <mxc> cosmicray - ocaml seems to dominate speed wise.  and for some problems, it seems like mutable values make for much much faster execution
11:27:49 <allbery_b> @src IO
11:27:49 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:27:57 <allbery_b> @src Monad IO
11:27:57 <lambdabot> Source not found. Sorry.
11:27:59 <CosmicRay> mxc: it is true that ocaml used to be outlandishly fast compared to others, but I don't think this is the case anymore
11:27:59 <allbery_b> hm
11:28:28 <CosmicRay> mxc: also don't discount the ability of ghc to optimize your algorithms.  you may have mutable values internally even if you haven't written your algorithm to use them.
11:28:48 <mauke> also, you can just use IORefs
11:28:55 <desegnis> litb, the easiest way is to think of IO's implementation as entirely compiler-internal
11:29:29 <CosmicRay> mxc: it is a testament to ghc that haskell manages to yield respectable times on the language shootout, despite the algorithms mandated in the shootout having a very strong bias towards non-lazy languages.  the code required to implement some of those algorithms literally in ghc is rather pathological.
11:29:31 <litb> hm, could a expert code it completely in haskell code without compiler support?
11:30:02 <mxc> cosmicray so say i need a lookup table of about 100k key,value pairs that is costnatly being updated.  it seems that if i use a map and it recreates the whole data structure each time i updateit, seems likeit would be very veyr inefficient
11:30:09 <desegnis> litb, another way is to think of  return  and (>>=) as ultimate data constructors (like, you're only constructing larger and larger IO actions, without calculating anything)
11:30:16 <mauke> mxc: why would it recreate the whole structure?
11:30:19 <CosmicRay> mxc: don't assume that it recreates the data structure each time
11:30:31 <mauke> it can just reuse the unchanged parts
11:30:54 <mauke> all values are immutable => you can share everything
11:31:02 <mxc> mauke, good point
11:31:04 <desegnis> litb, if you think of actions as data, then you could implement them in Haskell; but the actual input and output cannot be expressed directly in haskell
11:31:15 <monochrom> It is well-known that only logarithmically many nodes in a binary search tree need replaced.
11:31:18 <mauke> mxc: just like h :: t doesn't make a copy of t
11:31:24 <Sizur> , so is parsec.many lazy or not?
11:31:25 <mxc> well, from the ocaml owrld, the immutable, functional Map gets crushed by using mutable hashtbl:s in such cases
11:31:43 <mxc> hashtbl's
11:31:51 <mxc> stupid japanese keyboard, has a colon where the quote should be
11:32:00 <CosmicRay> mxc: but you've got totally different languages and implementations going on here
11:32:08 <mauke> we have Data.HashTable but I don't know how fast it is
11:32:10 <mxc> (by the way, as a complete newbie, i:m not trying to be arugmentative, just very very curious about haskell)
11:32:13 <CosmicRay> mxc: and compilers capable of various different optimizations
11:32:21 <Sizur> i guess within Parsec it is, while outside of the parse call, it's strict
11:32:21 <CosmicRay> mxc: these are not surprising questions
11:32:22 <desegnis> litb, which is because of functions not being conscious of the real world. (That's where the RealWorld abstraction above comes from)
11:32:48 <mxc> 'welcome neo, to the real world'
11:32:57 <CosmicRay> mxc: think of it like this.  Say you have a list with elements [1, 2, 3] in it.  You want to add an element 0 to the beginning of the list.
11:32:58 <desegnis> Sizur, how could it behave differently inside and outside of Parsec?
11:33:02 <lispy> so i have this setup something like, foo :: MyType p => MyType2 p x -> MyType2 p y -> (forall z. MyType2 p z -> MyType3 p z x -> MyType3 p z y -> a) -> a; and inside it's definition I have another function defined, f :: MyType4 p x y -> a; and GHC says that it can't make the p's match up between the top level function and f.  Any ideas?
11:33:04 <CosmicRay> mxc: you might have let list1 = [1, 2, 3]
11:33:08 <mfp> CosmicRay: I believed that the haskell entries in the shootout were very non-idiomatic for performance reasons; are you saying that more readable ones would fare better?
11:33:11 <CosmicRay> and let list2 = 0 : list1
11:33:41 <CosmicRay> now, list2 doesn't have to make an in-memory copy of list1 just to do its thing.  in fact, if nothing past the first element of list2 is ever used, list1 could be garbage collected immediately
11:33:47 <litb> >let a = 1 : a
11:34:10 <litb> that would print [1, 2, 3, 4...] if evaluated, or?
11:34:19 <mauke> > let a = 1 : a in a
11:34:19 <CosmicRay> mfp: performance was part of it, but when you are mandated by the shootout to use an algorithm that has a loop with a mutable counter, you can never write an idiomatic Haskell solution to it
11:34:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:34:31 <lispy> my problem happens when the function f calls the function passed to the top level function.
11:34:33 <Sizur> desegnis: many returns a list, while parse returns an either. so while i'm parsing the many, it's lazy, but the whole parse will return the already evaluated many (it will construct the whole list even before it's needed)
11:35:00 <mfp> mxc: OCaml's Map is fairly inefficient, it can be easily made much faster
11:35:00 <litb> desegnis: thanks for these insights
11:35:15 <mauke> litb: if you know C, struct node a = { 1, &a };
11:35:27 <CosmicRay> mxc: I know little about the internals of either OCaml's Map or Haskell's.  I do know that Haskell's internals were completely rewritten abou 2 years ago for performance reasons mainly
11:35:39 <monochrom> Haskell's Map and Set are fast enough for me.
11:36:16 <CosmicRay> mxc: also, if we can accept that in theory, adding elements to a list doesn't require making a full copy of the list in RAM -- or necessarily even accessing it all at once -- then we can accept that there could be a Map that has the same properties, I'd think
11:36:17 <litb> mauke: ah, i see. tentative madness
11:36:19 <monochrom> Haskell's Hashtable is slower than could be. But I don't miss it.
11:36:45 <litb> i don't care if haskell is slow
11:36:46 <Sizur> hm, i guess many cannot be lazy at all
11:36:47 <oerjan> @src IO (>>=)
11:36:47 <lambdabot> m >>= k     = bindIO m k
11:36:57 <litb> ah, great
11:37:08 <litb> @src bindIO
11:37:08 <lambdabot> bindIO (IO m) k = IO ( \ s ->
11:37:09 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
11:37:11 <CosmicRay> mxc: I would say that, in general, Haskell performs faster than Python, Java, or Perl.  In other words, so fast that I don't notice a problem.
11:37:26 <mxc> cosmicray - well thats relieving
11:37:42 <CosmicRay> mxc: I would also say that Haskell requires a mindshift from other languages, and that newbies can easily write slow programs because their brain hasn't adjusted yet.  I know I did ;-)
11:37:48 <lispy> I would say that when I use haskell for performance constraints (say at work) I spend less time developing, but more time optimizing.
11:37:56 <desegnis> Sizur, if you're lucky then the list should not be constructed in its entirety, given that you have a good producer and a good consumer (as always when you're dealing with very long lists). Of course, the decision whether the parse is successful (the Either thing) can only be made once you know that the data parses; this may be what's worrying you...
11:38:08 <CosmicRay> also ghc 6.8 is supposed to have this funky new auto-parallelization stuff that I haven't tried yet
11:38:22 <lispy> I would also say, the faster you can get something which works, the better.
11:38:23 <CosmicRay> where it can automatically make your algorithms use SMP where available
11:38:47 <litb> someone wants to check whether my program has such newbe-slow-madnes because i think wrong?
11:38:50 <CosmicRay> lispy: exactly.  By the time you reach at least the performance of Java (a low bar, I know), you're probably to the point where developer time is more important than runtime
11:39:03 <CosmicRay> heh, where's your program?
11:40:20 <hpaste>  litb pasted "my performance lacks" at http://hpaste.org/5044
11:40:27 <litb> o.O
11:40:28 <lispy> CosmicRay: sometimes.  But, where I work data sets can be very large.  Sometimes runtime continues to be more important than developer time.
11:40:55 <lispy> CosmicRay: But, then sometimes, C++ still isn't efficient enough.
11:40:56 <desegnis> litb, hey, that should be a topic for #haskell.de :)
11:41:12 <CosmicRay> lispy: sure, I grok that
11:41:33 <CosmicRay> lispy: what do you use then?  hexedit? ;-)
11:41:53 <lispy> CosmicRay: actually, at that point we work with the client to reduce the data set to managable chunks :)
11:42:00 <CosmicRay> ah
11:42:08 <litb> desegnis: yeah
11:42:36 <monochrom> map (2^) [0..]  should only happen in toy prototypes. :)
11:42:40 * CosmicRay looks at litb's program
11:42:55 <CosmicRay> litb: this is not the sort of program I'm going to be able to help you with, I'm afraid
11:43:04 <CosmicRay> litb: and I don't say that because the comments are in German ;-)
11:43:08 <byorgey> > map (2^) [0..]
11:43:09 <lispy> what is wrong with map (2^) [0..]
11:43:11 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:43:19 <oerjan> > scanl (*) 1 (repeat 2)
11:43:20 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:43:22 <lispy> I admit, I prefer to use show for that
11:43:24 <byorgey> > iterate (*2) 1
11:43:25 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:43:31 <lispy> > fix $ show
11:43:32 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
11:43:32 <monochrom> Yes, use scanl (*) 1 (repeat 2)
11:43:33 <oerjan> or that
11:43:42 <monochrom> or iterate (*2) 1
11:43:47 <faxathisia> lispy, nice :D
11:43:55 <Sizur> desegnis: so as long as do the whole process inside the EIther monad, i should be good, right?
11:44:18 <byorgey> > fix ((1:) . (map (*2)))
11:44:19 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:44:29 <gbacon> botsnack
11:44:32 <gbacon> @botsnack
11:44:33 <lambdabot> :)
11:44:33 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
11:44:38 <lambdabot> Terminated
11:44:40 <lispy> doh!
11:44:46 <lispy> that used to generate the powers of 2
11:44:53 <faxathisia> oh my..
11:44:56 <gbacon> lispysnack
11:44:57 <desegnis> Sizur, it should be good as long as you don't introduce a function that is unnecessarily strict
11:44:57 <byorgey> hehe
11:44:57 <pejo> lispy, been able to extract any useful smaller programs that show the performance problems? GHC HQ would love them, I'm sure of!
11:45:20 <lispy> > take 10 $ init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
11:45:21 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
11:45:54 <litb> what is wrong with the list comprehension i used?
11:46:01 <bos> dons: interesting mail
11:46:03 <Sizur> desegnis: what i mean is if i parse an ADT list using 'parse', and then process it, then i will have the whole list already in the memory assuming no parse failure
11:46:03 <litb> or bad?
11:46:30 <lispy> > take 100 . map length . group . fix $ show
11:46:33 <balodja> litb: oh, now i see. brainf**k code is really simple
11:46:34 <lambdabot> Terminated
11:46:37 <oerjan> Sizur: parsec is not good for this
11:46:38 <lispy> > take 10 . map length . group . fix $ show
11:46:38 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
11:46:59 <lispy> that's the basic idea, unfortunately, massaging that into powers of 2 is painful
11:46:59 <CosmicRay> litb: it's not really idiomatic in the sense that usualy people don't generate IO actions in comprehensions, but I don't think it should cause a performance issue.  I might write mapM_ putStrLn [ (show y ++ .... ]
11:47:19 <lispy> and note that mapM_ is very important for efficiency
11:47:29 <Sizur> oerjan: is there a better option?
11:47:52 <mauke> @src mapM_
11:47:52 <lambdabot> mapM_ f as = sequence_ (map f as)
11:48:13 <litb> oh i see
11:48:22 <byorgey> wow, CosmicRay's been busy!
11:48:26 <byorgey> CosmicRay++
11:48:44 <lispy> balodja: lambdabot can do a subset of brainf**k
11:48:49 <lispy> ?bf ++++
11:48:49 <oerjan> Sizur: don't know, if it is too complicated to write by hand
11:48:49 <lambdabot>  fd:19: hClose: resource vanished (Broken pipe)
11:48:55 <lispy> hmmm
11:48:56 <balodja> :)
11:48:58 <lispy> when she's not broken
11:49:03 <faxathisia> @let bf = ...
11:49:03 <lambdabot>  Parse error
11:49:08 <CosmicRay> byorgey: thanks.  yes I have ;-)
11:49:16 <faxathisia> I lost my interp though :(
11:49:16 <balodja> Only if her host has a 'bf' utility :)
11:49:16 <litb> i mean, what is wrong with the  map (2^) [0..] ?
11:49:33 <monochrom> Redundant calculations.
11:49:36 <litb> i suppose the performance?
11:49:38 <lispy> balodja: i wrote lambdabot's bf (optimizing) interpreter
11:49:41 <litb> ah, i see it now
11:49:46 <desegnis> @source (^)
11:49:46 <lambdabot> (^) not available
11:49:47 <lispy> balodja: so she should have one :)
11:49:49 <oerjan> litb: only that it recalculates everything at each item
11:49:52 <monochrom> You have 2^10 and then you start all the way from scratch for 2^11? :)
11:50:00 <byorgey> litb: each additional element takes O(lg n) time to compute, as opposed to O(1)
11:50:05 <litb> hehe, you are right. i see my mistake now
11:50:23 <balodja> lispy: oh, I have an old version than
11:50:30 <CosmicRay> litb: the zipWith algorithms applied to the fibonacci sequence may prove interesting
11:50:49 <litb> @src fix
11:50:50 <lambdabot> fix f = let x = f x in x
11:52:00 <lispy> > fix $ \n -> 2*n
11:52:01 <lambdabot>  Exception: <<loop>>
11:52:11 <gbacon> whee!
11:52:14 <litb> oh, stereotypes in haskell
11:52:32 <lispy> > fix $ \n -> 1 : 2*n
11:52:33 <lambdabot>   add an instance declaration for (Num [t])
11:52:41 <CosmicRay> http://en.literateprograms.org/Fibonacci_numbers_(Haskell)
11:52:48 <lispy> > fix $ \pows -> 1 : 2* head pows
11:52:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
11:52:48 <lambdabot>       Expected...
11:52:53 <lispy> grrr
11:53:07 <lispy> there should be an efficent way to defined that with fix, but i'm out to lunch on it :)
11:53:11 <lispy> something like the fibs
11:53:25 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
11:53:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:53:40 <mauke> > fix $ \x -> 1 : map (2 *) x
11:53:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:53:56 <mauke> > fix ((1 :) . map (2 *))
11:53:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:54:16 <lispy> so that should use more space, but less recomputation, correct?
11:54:43 <litb> CosmicRay: hm, that page doesn't load here :/
11:54:48 <monochrom> Not more space.
11:54:50 <CosmicRay> http://209.85.207.104/search?q=cache:jsYaOoxig3kJ:en.literateprograms.org/Fibonacci_numbers_(Haskell)+haskell+zipwith&hl=en&client=iceweasel-a&gl=us&strip=1
11:54:51 <lambdabot> http://tinyurl.com/2g94z2
11:55:13 <CosmicRay> also, unfoldr may be interesting
11:56:53 <CosmicRay> > take 10 powers where powers = 1 : 2 : zipWith (*) (repeat 2) (tail powers)
11:56:53 <lambdabot>  Parse error at "where" (column 16)
11:56:58 <CosmicRay> bah
11:57:09 <oskarM> > unfoldr (\n -> Just (n,n+n)) 1
11:57:10 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:57:12 <CosmicRay> that works in hugs
11:57:19 <faxathisia> ooh
11:57:23 <CosmicRay> oskarM: exactly
11:57:29 <CosmicRay> 1 : 2 : zipWith (*) (repeat 2) (tail powers)
11:57:35 <CosmicRay> > 1 : 2 : zipWith (*) (repeat 2) (tail powers)
11:57:35 <lambdabot>   Not in scope: `powers'
11:57:36 <oskarM> :)
11:57:37 <faxathisia> @pointless (\n -> Just (n,n+n))
11:57:37 <lambdabot> Just . ap (,) (join (+))
11:57:38 <CosmicRay> bah
11:57:54 <mightybyte> @hoogle deriveNewData
11:57:59 <lambdabot> No matches found
11:58:58 <roconnor> blah
11:59:32 <CosmicRay> litb: do these give you some ideas?
11:59:44 <CosmicRay> the unfoldr is certainly the most elegant
11:59:58 <litb> i'm still reading all the messages here
12:00:59 <CosmicRay> litb: let powers x = unfoldr (\n -> Just (n, n * x)) 1
12:01:06 <CosmicRay> > let powers x = unfoldr (\n -> Just (n, n * x)) 1 in powers 2
12:01:09 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:01:25 <twanvl> > iterate (*2) 1
12:01:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:01:53 <CosmicRay> twanvl: ah, rats.  I forgot about iterate.
12:01:54 <CosmicRay> good call.
12:02:10 <mauke> > iterate (join (+)) 1
12:02:11 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:02:13 <faxathisia> > iterate (join (+)) 1
12:02:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:02:27 <lispy> if you use forall on one type variable you have to use it on all of them?
12:02:35 <lispy> Is there a good  place to learn about forall?
12:02:53 <CosmicRay> lispy: the haskell-cafe mailing list or this channel has been my experience
12:03:10 <twanvl> the ghc manual?
12:03:24 <litb> lol, youre going crazy :D
12:03:33 <stepcut> Is the thread RTS enabled by default in ghc 6.8.x and/or is there a way to specific in cabal that when using my library you must use the threaded RTS ?
12:03:46 <litb> anyway, i'm starring at this fix function, but there is no light for me
12:03:54 <Sizur> @pl \s1 s2->s1:s2: unfoldr (\(n,m) -> Just (n+m,((n+m),n))) (s1,s2)
12:03:55 <lambdabot> liftM2 (.) (:) (ap (:) . (unfoldr (uncurry ((Just .) . ap (ap . ((,) .) . (+)) (flip =<< ((,) .) . (+)))) .) . (,))
12:04:38 <litb> how the hell does fix work? it took a function taking one parameter (the map (2*)) , and then defines x as f x , then evaluates x??
12:05:03 <faxathisia> :t fix
12:05:04 <lambdabot> forall a. (a -> a) -> a
12:05:06 <CosmicRay> stepcut: Options-GHC: -threaded perhaps?
12:05:15 <allbery_b> haskell's let is recursuve
12:05:15 <qebab> :t const
12:05:16 <lambdabot> forall a b. a -> b -> a
12:05:19 <faxathisia> y f = f (y f)
12:05:19 <byorgey> litb: think of it this way: 'fix f' finds a value x such that f x = x.  but it only works for functions f that are 'lazy enough'.
12:05:46 <byorgey> > fix (1:)
12:05:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:05:52 <stepcut> CosmicRay: do those get passed through to the final linkage stage ? (I assume that is when the decision to use threaded RTS is actually made?)
12:06:05 <CosmicRay> stepcut: I believe so
12:06:08 <byorgey> that gives an infinite list of 1's, since applying (1:) to an infinite list of 1's gives you the same thing you started with.
12:06:09 <faxathisia> y f = f (y f) = f (f (y f)) = f (f (f (y f))) = ...
12:06:15 <stepcut> CosmicRay: ok, I will experiment. thanks.
12:06:35 <faxathisia> > 1 : 1 : 1 : 1 : 1 : (repeat 1)
12:06:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:06:56 <byorgey> > fix ( (1:) . map (1+) )
12:06:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:07:05 <radetsky> > haltandcatchfire
12:07:05 <lambdabot>   Not in scope: `haltandcatchfire'
12:07:08 <radetsky> dammit
12:07:14 <faxathisia> > let y f = f (y f) in     y (1 :)
12:07:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:07:22 <byorgey> radetsky: that's in System.IO.Unsafe
12:07:27 <oerjan> radetsky: probably in IO ;)
12:07:42 <stepcut> CosmicRay: did you ever resolve the issues with your unix pipes library and the threaded/non-threaded RTS ?
12:07:51 * stepcut is very vague on the details now
12:08:34 <Sizur> @index Monad ((->)a)
12:08:34 <lambdabot> bzzt
12:08:43 <radetsky> stepcut: there are issues with the unix pipes library?
12:09:00 <Saizan> Sizur: Control.Monad.Instances
12:09:05 <idnar> litb: it's basically calculating f (f (f (f (f (f (f (f (f (f ...)))))))))
12:09:21 <Sizur> Saizan: thanks
12:09:40 <CosmicRay> stepcut: hrm, I am too.
12:09:52 <stepcut> CosmicRay: ha!
12:09:54 <CosmicRay> stepcut: I don't recall having an issue with my own library.  I do recall one with System.Process
12:09:59 <CosmicRay> stepcut: but I may be mistaken
12:10:15 <Sizur> > let fibs = liftM2 (.) (:) (ap (:) . (unfoldr (uncurry ((Just .) . ap (ap . ((,) .) . (+)) (flip =<< ((,) .) . (+)))) .) . (,)) in fibs 1 1 -- some scary functions there
12:10:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:10:22 <CosmicRay> the Sytem.Process issue was probably not directly related to threaded vs. non-threaded RTS, but instead to poor handling of closing pipe FDs
12:10:29 <roconnor> @seen mattam
12:10:30 <lambdabot> mattam is in ##logic and #haskell. I last heard mattam speak 2h 43m 36s ago.
12:10:30 <idnar> Sizur: wow, that's pretty obfuscated
12:10:37 <CosmicRay> and afaik it is still unfixed in ghc 6.8 but I haven't tested
12:10:45 <byorgey> > let fac f n = if n == 0 then 1 else n * f (n - 1) in fix fac 3
12:10:45 <lambdabot>  6
12:10:46 <idnar> hooray for point-free coed ;)
12:10:52 <radetsky> I ask because I'm trying to track down a bug in hmp3 that I think is related to IPC
12:11:18 <stepcut> CosmicRay: ah. That makes sense.
12:11:49 <roconnor> @unpl liftM2 (.) (:) (ap (:) . (unfoldr (uncurry ((Just .) . ap (ap . ((,) .) . (+)) (flip =<< ((,) .) . (+)))) .) . (,))
12:11:50 <lambdabot> ((:) >>= \ b -> (\ r -> (:) >>= \ t -> (\ bc -> unfoldr (uncurry (\ ad bf -> (Just) (((\ am as -> (\ bi -> ((,)) (am + bi)) >>= \ ao -> as >>= \ an -> return (ao an)) >>= \ af -> (\ az -> ((\ n bo ->
12:11:50 <lambdabot>  ((,)) (n bo)) >>= \ k l m -> k m l) ((+) az)) >>= \ ae -> return (af ae)) ad bf))) (((,)) r bc)) >>= \ s -> return (t s)) >>= \ a -> return (\ h -> b (a h)))
12:11:53 <stepcut> CosmicRay: I believe I have been having problems when using System.Process without using the threaded RTS -- but only on (some?) multicore machines...
12:11:59 <roconnor> that cleared it up
12:12:33 <stepcut> CosmicRay: hence my interested in forcing threaded RTS :)
12:12:37 * oerjan wants to quote roconnor on that but cannot see a reasonable way to do it
12:12:52 <radetsky> CosmicRay: what do you know about this issue so far, and can you let me know if you learn more?
12:13:04 <stepcut> radetsky: there is a very long thread on haskell-cafe
12:13:17 <radetsky> stepcut: thanks
12:13:17 <CosmicRay> radetsky: this one that stepcut is mentioning?  I could dig up a link to the list archives
12:14:17 <radetsky> if you know the specific thread offhand, that'd be great, but otherwise I can just look it up myself
12:15:54 <CosmicRay> http://www.haskell.org/pipermail/glasgow-haskell-users/2007-February/012050.html
12:15:56 <lambdabot> Title: ghci and ghc -threaded broken with pipes & forking, http://tinyurl.com/26w2oh
12:16:07 <CosmicRay> continues at http://www.haskell.org/pipermail/glasgow-haskell-users/2007-March/012062.html
12:16:08 <lambdabot> Title: ghci and ghc -threaded broken with pipes & forking, http://tinyurl.com/2gnyds
12:16:12 <CosmicRay> because it spanned the month boundary
12:16:34 <CosmicRay> so it appears that the *non*-threaded RTS worked better
12:16:51 <CosmicRay> but actually I seem to recall that my ultimate conclusion was that it didn't work well either place, but I'm not 100% positive of that
12:17:11 <CosmicRay> the gmane article thread finder links are broken right now or else I'd give you a nice link there
12:17:11 <lispy> the GHC manual says, forall a. Eq a => Int is an illegal type
12:17:27 <lispy> but thier explanation is hard to follow
12:18:02 <Saizan> lispy: essentially, you can't have a type variable in the context that doesn't appear in the rest of the type
12:18:15 <lispy> okay, I think I get that.
12:18:21 <Sizur> roconnor: i use this: fibs s1 s2 = unfoldr (\(n,m) -> Just (n+m,((n+m),n))) (s1,s2)
12:18:25 <lispy> so, don't put in extra type variables
12:18:37 <Sizur> roconnor: before the pointless rewrite
12:19:04 <mauke> @pl unfoldr (\(n,m) -> Just (n+m,((n+m),n)))
12:19:05 <lambdabot> unfoldr (uncurry ((Just .) . ap (ap . ((,) .) . (+)) (flip =<< ((,) .) . (+))))
12:19:44 <stepcut> CosmicRay: ah, it appears that my probem is different. I am just using runInteractiveProcess and forkIO.
12:20:48 <lispy> they say, forall a. C a b => burble is okay because C a b mentions the universally quantified type variable b.  But, shouldn't b be listed in the forall?
12:21:35 <litb> ah, ok
12:21:44 <EvilTerran> if you don't give an explicit forall, there's one implicitly added around the whole type sig
12:21:49 <sjanssen> lispy: it's implicit
12:21:53 <litb> but, how can it begin computing, when it doesn't know the value of the inner-most function?
12:22:07 <EvilTerran> :: a -> a  ~~  :: forall a. a -> a
12:22:17 <sjanssen> well, unless that fragment is nested in a deeper type signature
12:22:17 <litb> i mean, isn't the argument of the outher-most function undefined then?
12:22:34 <lispy> interesting, I had example, where I added a forall but only mentioned one type variable and GHC complained that the unmentioned type variables were not in scope.
12:22:43 <gwern> I've been wondering. what is a 'fingertree'? is it related to splay trees?
12:23:03 <sjanssen> gwern: no
12:23:08 <oerjan> @go finger-tree simple general
12:23:11 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
12:23:11 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
12:23:19 <radetsk1> I think I missed the response to my question
12:23:48 <radetsk1> if there was one
12:24:00 <radetsk1> 1sec
12:24:01 <gwern> fooey. means Wikipedia has no article on finger trees
12:24:04 <faxathisia> radetsk1: http://tunes.org/~nef/logs/haskell/
12:24:06 <lambdabot> Title: Index of /~nef/logs/haskell
12:24:18 <byorgey> litb: you're talking about fix?
12:24:32 <litb> byorgey: yes
12:24:34 <byorgey> litb: that's why the function passed to fix has to be 'lazy enough'.
12:24:39 <byorgey> litb: for example:
12:24:46 <byorgey> > fix ((:1) . map (+1))
12:24:47 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:24:47 <lambdabot>       Expected...
12:24:48 <litb> in f (f (f (f (....) ) ) )
12:24:57 <byorgey> > fix ((1:) . map (+1))
12:24:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:24:59 <byorgey> oops =)
12:25:21 <byorgey> notice that function can output a 1 : ... before it actually examines its argument
12:25:22 <litb> and it continues that way infinitely and it never gets the value of the last call, how does it know the argument to the first call then?
12:25:27 <idnar> litb: lazy evaluation
12:25:32 <faxathisia> litb, did you see what I wrote above about y?
12:25:43 <idnar> litb: the first call needs to return something that you can start evaluating without evaluating the whole thing
12:25:44 <faxathisia> litb, y is fix
12:26:07 <idnar> to use a simpler example
12:26:10 <idnar> > fix (1:)
12:26:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:26:29 <Sizur> > take 1 (((1:) . map (+1)) undefined)
12:26:30 <lambdabot>  [1]
12:26:38 <idnar> you have 1 : 1 : 1 : 1 : 1 : ...
12:26:52 <Sizur> > take 2 (((1:) . map (+1)) undefined)
12:26:53 <lambdabot>  Undefined
12:26:57 <idnar> you don't need to fully evaluate the ... in order to get at those first few members of the list
12:27:45 <Sizur> one can get an answer before the question. quantum mechanics in action lol
12:28:09 <litb> idnar: ah, it knows by having the first argument that it must return at least 1:<something> , so it puts it to the list?
12:28:24 <Japsu> In Quantum Mechanics the answer is questioned !!
12:28:35 <balodja> Sizur: "one can get an answer before the question". quantum mechanics? O_o
12:28:47 <Japsu> <insert better soviet russia joke here>
12:29:05 <Time`s_Witness> hey.. i have a problem.. could someone help me please..? here.. http://hpaste.org/5045
12:29:16 <Time`s_Witness> problemB "CBACBACBACBACBA" <--- i want it to return ["AAAAABC","BBBBC","CCC"] (keeps adding each character to the first list of characters which first character in it is greater than the character being added (alphabetically)). i am not familiar with "map" function but i think it doesnt fit for the case, because one of the entries would be a list of lists of characters, and it always returns a list of (type of var, meaning, list of list of li
12:29:16 <Time`s_Witness> *** Type : (a -> a -> b) -> [a] -> [b]
12:29:16 <Time`s_Witness> *** Does not match : (a -> a -> b) -> [a] -> [a -> b]
12:29:16 <Time`s_Witness> *** Because : unification would give infinite type
12:29:22 <thetallguy> conal: connection problems?
12:29:23 <litb> faxathisia: no, i didn't see what you wrote
12:29:24 <Sizur> balodja: there is no causality in the quantum foam
12:29:29 <EvilTerran> litb, the formal definition of the fixed point of a function, f, in some contexts is the limit of the series _|_, f _|_, f (f _|_), f (f (f _|_)), ...
12:29:30 <balodja> As I know, there is no physical theory where question is answered before the answer.
12:30:29 <EvilTerran> litb, you can think of the way (fix f) is evaluated as being like that
12:30:40 <litb> ok, unfoldr is the most beautiful solution, but fix is the most confusing solution =)
12:30:49 <EvilTerran> except with "unevaluated thunk" instead of _|_
12:31:08 <balodja> *where answer is stated before question :)
12:31:26 <EvilTerran> litb, the thing is, that series can only have a non-_|_ limit if (f _|_) /= _|_
12:31:28 <EvilTerran> (i think)
12:31:34 <faxathisia> litb, it might help your confusion
12:31:44 <EvilTerran> so fix only works in the cases where (f undefined) is non-_|_
12:31:54 <Sizur> balodja: you have to tell this to the experiments
12:32:01 <EvilTerran> litb, does that make sense?
12:32:18 <litb> moment, i have to look up _|_ in wikipedia
12:32:24 <EvilTerran> hehe
12:32:30 <EvilTerran> sorry, _|_ is pronounced "bottom"
12:32:36 <CosmicRay> heh
12:32:51 <CosmicRay> I can see I really must turn off highlighting in gajim for this thannel
12:32:55 <CosmicRay> err channel
12:32:59 <CosmicRay> wow, I type with a lisp.
12:33:18 <idnar> you should type with a scheme instead
12:33:26 <EvilTerran> litb, and it means "a computation about whose value nothing can be determined"
12:33:36 <CosmicRay> idnar: I was waiting for the jokes :-)
12:33:42 <EvilTerran> litb, in practice, this means it either throws an error or runs forever
12:34:15 <EvilTerran> undefined is _|_, as is (let oops = oops in oops)
12:35:08 <litb> ah, finally i know what undefined is about :)
12:35:19 <litb> afk..
12:35:51 <EvilTerran> litb, in my analogy between the "limit of f^n(_|_) as n->Inf" idea and the evaluation order of haskell, i was saying that, in evaluation terms, it's not that it represents "a computation about whose value nothing *can* be determined", more that it represents "a computation about whose value nothing *has been* determined *yet*"
12:36:21 <EvilTerran> and, in lazy-evaluation terms, that means "an unevaluated thunk"
12:38:17 <litb> ah now i understand
12:40:08 <EvilTerran> so (fix f) is only non-_|_ if something can be determined about the value of (f x) without looking at the value of x
12:40:16 <Time`s_Witness> could anyone check what's wrong with my syntax in mapCountainers function in http://hpaste.org/5045 please? :x
12:40:17 <EvilTerran> ie if (f x /= _|_)
12:41:13 <faxathisia> Time`s_Witness, Nothing
12:41:31 <Time`s_Witness> but i get this compile error :
12:41:31 <Time`s_Witness> *** Type           : (a -> a -> b) -> [a] -> [b]
12:41:31 <Time`s_Witness> *** Does not match : (a -> a -> b) -> [a] -> [a -> b]
12:41:31 <Time`s_Witness> *** Because        : unification would give infinite type
12:41:36 <Time`s_Witness> :s
12:41:43 <faxathisia> Time`s_Witness, |xs == [] = [] -- is wrong
12:41:45 <EvilTerran> that's not a syntax error
12:41:52 <faxathisia> or is it....
12:42:00 <litb> EvilTerran: thanks for spending your time :)
12:42:04 <Time`s_Witness> well, no, but it's  commented
12:42:06 <EvilTerran> also, if you've got several lines to show us, please add them via the "annotate" link on the paste
12:42:12 <Time`s_Witness> so it should not try to compile it :|
12:42:17 <EvilTerran> rather than shoving them straight in the channel
12:42:45 <EvilTerran> litb, no problem, helping people is a wonderful excuse for me to procrastinate ;)
12:43:26 <balodja> Sizur: Could you give some links? And I hope that there would be no mention of EPR-effects
12:45:22 <byorgey> Time`s_Witness: why is mapCountainers _ [] = [] commented out?
12:45:38 <byorgey> Time`s_Witness: with no base case, that will cause an infinite loop
12:45:49 <Time`s_Witness> I just changed my function then, having conditions (using '|')  :  if null xs = f x, otherwise = mapCountainers (f x) xs. and now i get
12:45:53 <Time`s_Witness> *** Type           : [b]
12:45:53 <Time`s_Witness> *** Does not match : a -> b
12:46:09 <Time`s_Witness> hmm.. on "otherwise" line
12:46:22 <EvilTerran> Time`s_Witness, what's this supposed to be doing, exactly?
12:46:28 <byorgey> Time`s_Witness: oh, wait. mapCountainers takes a function as its first argument, but (f x) is not a function.  it is a value of type b.
12:46:41 <Time`s_Witness> yes.. it is..
12:47:01 <byorgey> Time`s_Witness: do you know about the 'map' function in the standard prelude?
12:47:05 <byorgey> @type map
12:47:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:47:19 <Time`s_Witness> yea but that one doesnt fit for me.. it creates a list of lists of lists
12:47:25 <Time`s_Witness> being each char in a mini-mini list
12:47:28 <Time`s_Witness> thats not what i want
12:47:28 <Time`s_Witness> :X
12:47:37 <faxathisia> concat . map
12:47:40 <faxathisia> concatMap
12:47:52 <faxathisia> how about those?
12:47:54 <gwern> can anyone name any applications besides yi making use of finger trees?
12:47:58 <byorgey> Time`s_Witness: but your version mapCountainers has the exact same type.
12:48:12 <Time`s_Witness> the function is suppose to, given a string, creates a list of strings in which each character of the given string keeps adding to one in it, ordering aphabetically all strings
12:48:43 <BMeph> gwern: It's not an app, but I believe Data.Set uses them.
12:48:44 <Time`s_Witness> so:
12:48:45 <byorgey> Time`s_Witness: like "foo" -> ["", "f", "fo", "foo"]?
12:49:05 <Time`s_Witness> no.. it wont repeat letters.. like:
12:49:05 <oskarM> > inits "foo"
12:49:06 <lambdabot>  ["","f","fo","foo"]
12:49:17 <Time`s_Witness> problemB "CBACBACBACBACBA" <--- i want it to return ["AAAAABC","BBBBC","CCC"]
12:49:24 <gwern> BMeph: well, it's in the haskell core libraries, then, which I'd count
12:49:47 <Time`s_Witness> it adds first letter in a sub-string. then it adds second letter to same string IF the letter is first in alphabet than the first letter of that string
12:49:51 <Time`s_Witness> if not, new string created
12:50:38 <byorgey> I'm not sure that I understand.
12:50:48 <byorgey> what should it return if you give it "ABC"?
12:50:53 <Time`s_Witness> my function checkPlaceOnStacks works well, given the list of strings plus the next char to add, i just cant make it happen for all letters (map function) :S
12:51:07 <Time`s_Witness> ["A","B","C"]
12:52:15 <Time`s_Witness> A is added: ["A"]. second: checks if head "A" > that letter. if so, creates new "B" ["A","B"]. if not, adds to same list : ["BA"]
12:52:34 <Time`s_Witness> as B > A alphabetically, creates : ["A","B"]
12:52:39 <Time`s_Witness> and so on
12:52:46 <byorgey> oh, I see
12:52:55 <gwern> hm, but who invented finger trees?
12:53:18 <byorgey> Time`s_Witness: sounds like you want some sort of fold, not map
12:53:32 <Time`s_Witness> :s i dont know what fold does :x
12:53:33 <idnar> an unfold, even?
12:53:52 <Time`s_Witness> gwern, was that question directed at me? if so, i dont know what finger trees are :x
12:53:53 <mauke> this problem is scary
12:54:06 <gwern> Time`s_Witness: it was directed at whoever knew
12:54:13 <Time`s_Witness> ah xD k :x
12:54:45 <gwern> did Data.Set used to be named Data.Sequence?
12:55:01 <mauke> gwern: unlikely
12:55:12 <BMeph> gwern: My bad, it's Data.Sequence, not Data.Set.
12:55:33 <gwern> BMeph: ok then :)
12:55:34 <byorgey> @type foldl
12:55:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:57:22 <hpaste>  byorgey annotated "mapCountainer... infinite loop?" with "with foldl" at http://hpaste.org/5045#a1
12:57:39 <byorgey> Time`s_Witness: how's that? =)
12:59:00 <Time`s_Witness> *** Type           : [Char] -> [[Char]]
12:59:00 <Time`s_Witness> *** Does not match : String -> [[String]]
12:59:01 <Time`s_Witness> :S
12:59:17 <Time`s_Witness> my function needs 2 parameters
12:59:21 <Time`s_Witness> does fold do.. that? :X
12:59:26 <dons> [[String]] /= [String]
12:59:47 <byorgey> oh, oops, sorry, should be [String] not [[String]]
13:00:08 <dons> (might also be a good idea to use ghci, you get better type error messages, and faster code, and a better experience, and more libraries)
13:00:08 <hpaste>  byorgey annotated "mapCountainer... infinite loop?" with "[String] not [[String]]" at http://hpaste.org/5045#a2
13:00:12 <Time`s_Witness> ah :x
13:01:01 <Time`s_Witness> yea.. that does teh work :D however, i'm not supposed to use functions i dont know about xD im going to research how foldl works
13:01:08 <Time`s_Witness> thanks byorgey :D
13:01:18 <byorgey> yw =)
13:01:37 <byorgey> Time`s_Witness: foldl is not too hard to write yourself.
13:01:55 <Time`s_Witness> yea but for that , i need to understand what does it do :) heh
13:02:01 <byorgey> @type foldl
13:02:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:02:06 <BMeph> gwern: So, I guess the answer to the second question is "Leo Guibas" -- who invented finger trees
13:02:14 <radetsky> I couldn't find that cafe thread on the pipe issue. Does anyone have a link?
13:02:14 <byorgey> Time`s_Witness: see if you can figure it out by looking at its type =)
13:02:24 <Sizur> balodja: http://www.physorg.com/news11087.html  -- not a reverse causality, yet causality paradox nontheless.
13:02:24 <lambdabot> Title: Quantum computer solves problem, without running
13:02:28 <BMeph> ?src foldl
13:02:28 <lambdabot> foldl f z xs = lgo z xs
13:02:28 <lambdabot>     where lgo z []     =  z
13:02:28 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:02:54 <Time`s_Witness> byorgey, i am not that expert to just by looking at type.. in the same moment.. understand.. besides, i dont understand (a -> b -> a) parameter.. i suppose its a function with.. 2 parameters and 1 returned value of the same type of the first though
13:02:54 <byorgey> Time`s_Witness: that source above is not particularly helpful.  ignore it =)
13:03:08 <byorgey> Time`s_Witness: that's right!
13:03:14 * BMeph sighs at some of LB's "helper function"-defined definitions.
13:03:27 <byorgey> Time`s_Witness: I didn't say you should *instantly* understand it by looking at the type.  you will probably have to think hard. =)
13:03:38 <Time`s_Witness> lol. ;P yea
13:03:47 <Time`s_Witness> i'll look at that source, still
13:04:07 <radetsky> dons: what was the issue you had with ^L?
13:04:40 <dons> hmm? ^L just generates the SIGWINCH signal, which refreshs the terminal
13:04:40 <BMeph> foldl f z [] = z;
13:05:09 <BMeph> foldl f z (x:xs) = foldl f (f z x) xs
13:05:21 <radetsky> line 141 of UI.hs:
13:05:25 <radetsky> -- XXX ^L doesn't work
13:05:27 <Time`s_Witness> does "lgo" stand for anything in special?
13:05:34 <dons> wow, the ruby guys sure now how to do a web page for an open source release. http://treetop.rubyforge.org/
13:05:51 <dons> logos, glitzy fonts, snappy text, "revolutionary" , "he gets it."
13:06:06 <radetsky> dons: now if they could just make a fast interpreter...
13:06:15 <Time`s_Witness> hmm i think i got foldl.. testing it abit.. =)
13:06:24 <dons> i think with enough polish on their websites, they figure that won't matter :)
13:06:27 <Sizur> balodja: http://cosmiclog.msnbc.msn.com/archive/2007/07/17/274531.aspx
13:06:27 <lambdabot> Title: Backward research goes forward - Cosmic Log - msnbc.com
13:07:12 <radetsky> CosmicRay: you there?
13:07:17 <CosmicRay> yes
13:07:30 <radetsky> do you know the name of that thread on the pipe issue?
13:08:05 <CosmicRay> <CosmicRay> http://www.haskell.org/pipermail/glasgow-haskell-users/2007-February/012050.html
13:08:05 <CosmicRay> <lambdabot> Title: ghci and ghc -threaded broken with pipes & forking, http://tinyurl.com/26w2oh
13:08:05 <CosmicRay> balodja has left (Remote closed the connection (n=noname@62.117.85.97))
13:08:05 <CosmicRay> <CosmicRay> continues at http://www.haskell.org/pipermail/glasgow-haskell-users/2007-March/012062.html
13:08:06 <lambdabot> Title: ghci and ghc -threaded broken with pipes & forking, http://tinyurl.com/26w2oh
13:08:06 <lambdabot> Title: ghci and ghc -threaded broken with pipes & forking, http://tinyurl.com/2gnyds
13:08:09 <bos> dons: that's amusing
13:08:20 <CosmicRay> I think that's the one, though there may have been others
13:08:53 <bos> i looked at the current PDF build of the book this morning. it's already 374 pages long! holy whatchamacallits!
13:09:00 <BMeph> Time`s_Witness: foldr is defined with a helper function called "go." So, they defined foldl in a way to remind you of foldr's def.
13:10:15 <radetsky> CosmicRay: I thought you said it was in cafe. Was there one there too?
13:10:40 <CosmicRay> if I said that, I may have been mistaken, or there may be another thread there that I'm not remembering right now
13:10:47 <radetsky> ok, np
13:10:50 <litb> hm, i like [ f q | q <- e ] better than map
13:10:51 <CosmicRay> it's quite possible there were multiple threads I was involved in regarding issues in System.Process
13:11:07 <litb> is there any reason i shouldn't use it instead of map?
13:11:38 <radetsky> dons: my current belief is that the issues I was having with hmp3 are due to IPC
13:11:41 <dons> bos, crikey!
13:11:48 <radetsky> I'll send you a report on everything I know soon
13:11:51 <Time`s_Witness> omg.. the first argument is so obvious that it needed to be composed by 3 arguments.. my function has 2 arguments.. :|
13:11:54 <dons> we *will* be able to use it as a weapon.
13:12:02 <dons> radetsky: ok. thanks!
13:12:09 <dons> any theory why I don't see any problems?
13:12:21 <radetsky> dons: no idea
13:12:34 <gbacon> dons: get back to work on the book!! :-)
13:12:46 <dejones_> Can someone point me to a good, detailed resource that compares functional and imperative programming langauges?  I would like to learn more about the advantages/disadvantages of functional langauges, such as Haskel.
13:13:04 <dons> would being longer than war and peace be a bad thing? :)
13:13:06 <dejones_> * Haskell.  :)
13:13:23 <faxathisia> dejones_, Write lots of code in both
13:13:49 <dons> dejones_: hmm. http://www.math.chalmers.se/~rjmh/Papers/whyfp.html is the classic from the FP side
13:13:50 <lambdabot> Title: Why Functional Programming Matters
13:14:24 <dejones_> faxathisia: is that so I can learn the advantages/disadvantages for myself?  ;)
13:14:33 <dons> dejones_: but experience with the language will make it pretty clear
13:14:48 <dons> once you notice that your programs don't seem to have bugs after they compile :)
13:15:09 <dmead> rawr
13:15:16 <Taejo> who made foldr.com and foldl.com?
13:15:26 <byorgey> Time`s_Witness: hm?
13:15:29 <faxathisia> dejones_, Often these sorts of comparisons are a bit biased
13:15:34 <dejones_> So, with this benefit, why do you think Functional Languages are not as popular?  Simply because they are not as commonly taught?
13:15:43 <dmead> hah
13:15:44 <dejones_> faxathisia: heh, yah. the world is a biased place.
13:16:01 <byorgey> litb: [ f q | q <- e ] is less composable, but there's nothing wrong with it.
13:16:01 <dejones_> but, I appreciate the info.
13:16:33 <Time`s_Witness> byorgey, my function "checkPlaceOnStacks" has 2 arguments + 1 returned  value. therefore, it was obvious that the first argument of mapCountainer should have been (a->b->a) or at most (a->b->c), but i couldnt see it, i let it as (a->b) :x
13:17:08 <byorgey> litb: my guess is that as you become more experienced with Haskell, you'll come to prefer 'map' instead of the list comprehension syntax.
13:17:23 <byorgey> Time`s_Witness: ah, I see =)
13:17:42 <dejones_> (sorry, that was meant as a reply to you, but others can respond) dons: So, with this benefit, why do you think Functional Languages are not as popular?  Simply because they are not as commonly taught?
13:18:13 <idnar> I would probably tend to use list comprehensions instead of map with a lambda
13:18:46 <dejones_> oh yah, I'm kaiser by the way.  :)  I decided to change my nick.
13:18:47 <BMeph> litb: And my guess is that with more experience with zipWith, you, too, will think of "map" as just a shorter way of typing "zipWith1"... ;)
13:18:52 <radetsky> dons: actually, if you could send me info on your setup, that might help me generate theories and/or identify where the problem is coming from
13:19:03 <gbacon> > let { f "a" = ("a", 1); f "b" = ("b", 2) } in map f ["a","b","b"]
13:19:05 <lambdabot>  [("a",1),("b",2),("b",2)]
13:19:43 <radetsky> anything you think is relevant
13:20:25 <gbacon> can I cleverly thread thunks to get the map to count b's?
13:21:14 <mauke> > sum . map (fromEnum . ('b' ==)) $ "abb"
13:21:15 <lambdabot>  2
13:21:52 <gbacon> mauke: I'm looking for a result of [("a",1),("b",1),("b",2)]
13:22:14 <litb> actually, i will stay with my sequence_ [..... ] thing, as this is is a presentation of this program, and i think this shows nicely that stuff like print and putStrLn are just monads that return monadic types.
13:22:20 <gbacon> mauke: or [("a",1),("b",1),("b",2),("b",3)] for ["a","b","b","b"]
13:22:35 <byorgey> gbacon: how about for ["a", "b", "a", "b"]?
13:22:42 <mauke> 1,1,2,2
13:22:48 <gbacon> 1, 1, 1, 1
13:22:52 <mauke> :(
13:22:59 <gwern> BMeph: I think you're right: 'Finger trees were originally dened by reversing certain pointers in a search tree to accelerate operations in the vicinity of distinguished positions in the tree, known as ngers (Guibas et al., 1977). The original versions used various forms of B-...'
13:23:13 <byorgey> gbacon: why do you have to use 'map'?
13:23:41 <BMeph> gwern: Yeah, that paper is one of about eight things I'm in the middle of reading. ;)
13:23:56 <mauke> > map (zip [1 ..]) . group $ "abb"
13:23:56 <lambdabot>  [[(1,'a')],[(1,'b'),(2,'b')]]
13:24:13 <mauke> > map (flip zip [1 ..]) . group $ "abbaaaaabb"
13:24:14 <lambdabot>  [[('a',1)],[('b',1),('b',2)],[('a',1),('a',2),('a',3),('a',4),('a',5)],[('b'...
13:24:29 <byorgey> make that concatMap and you're set.
13:24:40 <mauke> > concatMap (flip zip [1 ..]) . group $ "abbaaaaabb"
13:24:41 <lambdabot>  [('a',1),('b',1),('b',2),('a',1),('a',2),('a',3),('a',4),('a',5),('b',1),('b...
13:25:11 <byorgey> yay!  a real use for 'flip zip'! =D
13:25:20 <faxathisia> > (flip zip [1 ..]) . group =<< "abbaaaaabb"
13:25:20 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
13:25:27 <faxathisia> huh
13:25:37 <Taejo> byorgey: are uses of flip zip uncommon?
13:25:46 <byorgey> faxathisia: that's concatMap ((flip zip [1..]) . group)
13:26:06 <mauke> > (`zip`[1..])=<<group"abbaaabb"
13:26:07 <lambdabot>  [('a',1),('b',1),('b',2),('a',1),('a',2),('a',3),('b',1),('b',2)]
13:26:14 <byorgey> Taejo: I dunno, it doesn't come up all that often.  but it rhymes =)
13:26:55 <litb> ah, =<< ?
13:27:02 <byorgey> don't think it's going to get much shorter than that.
13:27:02 <Taejo> I used it the other day somewhere
13:27:04 <gbacon> byorgey: I asked about using map because I've already implemented the code with map and discovered afterward that the input has errors
13:27:27 <mauke> @src (=<<)
13:27:27 <lambdabot> f =<< x = x >>= f
13:27:39 <litb> oh, hehe nice
13:27:54 <faxathisia> @src (>>=)
13:27:55 <lambdabot> Source not found. Sorry.
13:28:06 <faxathisia> x >>= f = f =<< x
13:28:24 <gbacon> how do you ask lambdabot for the source of, say, >>= in a particular monad?
13:28:29 <litb> @src (>>=) []
13:28:29 <lambdabot> Source not found. You speak an infinite deal of nothing
13:28:30 <mauke> @src [] >>=
13:28:31 <lambdabot> Source not found. My brain just exploded
13:28:31 <litb> hm
13:28:35 <mauke> @src [] (>>=)
13:28:36 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:28:44 <byorgey> @src Maybe (>>=)
13:28:44 <lambdabot> (Just x) >>= k      = k x
13:28:44 <lambdabot> Nothing  >>= _      = Nothing
13:29:09 <BMeph> ?src Either (>>=)
13:29:09 <lambdabot> Left  l >>= _ = Left l
13:29:09 <lambdabot> Right r >>= k = k r
13:29:41 <mauke> @src -> (>>=)
13:29:41 <lambdabot> Source not found. I am sorry.
13:29:55 <mauke> @src (->) (>>=)
13:29:56 <lambdabot> f >>= k = \ r -> k (f r) r
13:30:20 <byorgey> that one's sort of odd, since the monad isn't actually (->) but rather ((->) r)
13:30:48 <litb> @src Left
13:30:49 <lambdabot> Source not found. :(
13:30:50 <byorgey> well, I guess Either isn't actually a monad either
13:31:07 <byorgey> @src Either
13:31:07 <lambdabot> Source not found. Take a stress pill and think things over.
13:31:20 <byorgey> litb: data Either a b = Left a | Right b
13:32:11 <litb> ah, funny
13:32:40 <byorgey> litb: it's commonly used as the result type of a computation which may fail, and provide some extra information about the failure.
13:32:44 <litb> i think about changing my program and adding some type classes and such
13:32:54 <byorgey> by convention, Left x represents failure with 'x' the information about the failure
13:32:59 <litb> like Integratable and such
13:33:04 <byorgey> and Right y represents a successful computation with result y
13:33:41 <litb> byorgey: ah, i see. then Right could be used for the non-failure thing because of the double meaning :)
13:34:01 <byorgey> litb: yes, that's why the convention is to do it that way around =)
13:34:39 <byorgey> Either a b can also be used as the type of a 'multiplexed channel' which can carry values of types a and b
13:35:05 <faxathisia> a :+: b
13:35:25 <litb> uh, much stuff to learn for me to become a haskell master
13:35:41 <faxathisia> That's impossible as a name?
13:36:29 <byorgey> faxathisia: that should work.
13:36:56 <faxathisia> data a :+: b = L a | R b
13:37:00 <faxathisia> Cool
13:37:17 <litb> oh, we can have infix types too?
13:37:35 <byorgey> litb: yes, but they have to start with :
13:38:12 <byorgey> you can even have infix multiparameter type classes =)
13:39:03 <litb> what is the position of type classes in haskell? is it considered bad style to not use them and code "procedural"? like it is in OOP languages?
13:39:20 <smack_> litb: hm?
13:39:29 <shachaf> litb: Type classses are quite different from OO classes.
13:40:19 <smack_> ah.  type classes are a bit more like interfaces than classes, if anything
13:40:32 <shachaf> litb: Some examples are Eq, Show, Read, Monad, Ord.
13:40:49 <Cale> class Eq a where
13:40:55 <Cale>   (==) :: a -> a -> Bool
13:41:02 <Cale>   (/=) :: a -> a -> Bool
13:41:05 <shachaf> litb: You "use" a type class every time you use (==) or (+).
13:41:54 <Cale>   -- then some default implementations which define (==) in terms of (/=) and vice versa
13:45:49 <byorgey> dons: you around?
13:48:17 <ndm> @seen kowey
13:48:17 <lambdabot> I haven't seen kowey.
13:48:21 <litb_> sorry guys
13:48:40 <litb_> i accidentially switched off the power with my feet o.O
13:48:48 <litb_> damn ... now i moved it away
13:49:09 <faxathisia> litb_: http://tunes.org/~nef/logs/haskell/
13:49:12 <lambdabot> Title: Index of /~nef/logs/haskell
13:49:13 <ndm> @seen dcoutts
13:49:13 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 6h 4m 8s ago.
13:49:15 <BMeph> litb_: Really? I didn't notice a thing. ;p
13:49:25 <dons> http://programming.reddit.com/info/65oya/comments/ "Monads and the meaning of imperative languages (alpheccar.org)"
13:49:34 <dons> byorgey: yo. barely.
13:49:41 <ndm> @tell dcoutts_ https://www.blogger.com/comment.g?blogID=7094652&postID=8018445893950772941 - this comment on my blog from kowey might help you slightly
13:49:42 <lambdabot> Consider it noted.
13:49:58 <byorgey> dons: just wondering what would be necessary to add ogg support to hmp3.
13:50:05 <byorgey> dons: we can talk about it later if you don't have time.
13:50:21 <BMeph> Nice! I'll have to name my monad tutorial "Monads and the Art of FP Maintenance" ;)
13:50:35 <dons> byorgey: so if you can identify a general purpose decoder/playback library, we could use that instead.
13:50:46 <dons> the ui should be far far more decoupled from the backend
13:50:53 <byorgey> dons: oh, I see, just replace mpg321
13:51:05 <ndm> dons: i've seen the same topic given in a talk by Peter Moses, although he wasn't advocating FP, he was more into the semantics
13:51:47 <dons> byorgey: yeah, with a general library binding
13:52:20 <byorgey> dons: ok, I'll look into it.  I'm interested since hmp3 looks nice, but my music is all .oggs.
13:53:49 <radetsky> dons: you didn't respond before. can you send me info on your setup?
13:53:59 <litb_> 22:38 < Cale> class Eq a where
13:54:04 <litb_> was the last thing i got
13:54:06 <kosmikus> what's the status of quickcheck 2?
13:54:07 <dons> radetsky: what kind of info?
13:54:19 <radetsky> anything you think is relevant
13:54:21 <dons> kosmikus: on darcs.haskell.org, but not being worked on. some people are using it (e.g darcs)
13:54:28 <hpaste>  (anonymous) annotated "mapCountainer... infinite loop?" with "(no title)" at http://hpaste.org/5045#a3
13:54:36 <radetsky> at the very least, your package versions and what sort of machine you're using
13:54:37 <dons> kosmikus: code.haskell.org, actually
13:54:41 <dons> radetsky: ok.
13:54:43 <Cale> litb_: ah
13:54:48 <Cale> class Eq a where
13:54:50 <faxathisia> litb_: http://tunes.org/~nef/logs/haskell/
13:54:51 <lambdabot> Title: Index of /~nef/logs/haskell
13:54:53 <Cale>   (==) :: a -> a -> Bool
13:55:01 <Cale> (/=) :: a -> a -> Bool
13:55:04 <Cale> whoops :)
13:55:12 <kosmikus> dons: it's not in hackage afaics. any plans to put it there?
13:55:20 <Cale>   -- then some default implementations:
13:55:21 <Time`s_Witness> http://hpaste.org/5045#a3 - i'm still trying to implement foldl.. but.. <.< "infinite loop".. could anyone check what is wrong in my sintax? "mapCountainers" should be .. foldl.. i believe.. but .. implemented by me :|
13:55:26 <Cale>   x == y = not (x /= y)
13:55:30 <dons> kosmikus: its unclear who the maintainer is
13:55:32 <Cale>   x /= y = not (x == y)
13:55:40 <kosmikus> dons: I see.
13:55:51 <Cale> and then in an instance, you fill in at least one of (==) or (/=) for your specific type
13:55:52 <dons> kosmikus: we need Koen to say: "please, yes, upload the damn thing"
13:55:56 <kosmikus> dons: are you aware of any actual disadvantages compared to 1.1?
13:56:02 <Cale> instance Eq Bool where
13:56:03 <litb> Cale: the default implementations, they are just put into the global namespace?
13:56:04 <dons> no. only advantages
13:56:12 <dons> more refined types, and shrinking, for example
13:56:13 <kosmikus> dons: it has the shrinking, right?
13:56:15 <kosmikus> yes
13:56:19 <Cale> litb: Well, the module namespace.
13:56:24 <litb> ah, i see
13:56:24 <dons> NonNegative Int, for example
13:56:27 * Nafai bangs his head against NPEs
13:56:32 <dons> it would be used if it was on hackage :)
13:56:46 <Cale>   True == x = x
13:56:47 <byorgey> Time`s_Witness: first of all, problemB should have type String -> [String], not String -> [[String]]
13:56:48 <kosmikus> I'll use it in my "Advanced FP" course then ...
13:56:53 <kosmikus> thanks for the info, dons
13:57:00 <Cale>   False == x = not x
13:57:10 <byorgey> @vera NPE
13:57:11 <lambdabot> No match for "NPE".
13:57:19 <Time`s_Witness> yea byorgey.. you're right :s
13:57:45 <dons> kosmikus: yeah, that should be fine. and more useful
13:57:51 <byorgey> Time`s_Witness: and your foldl function should have type (a -> b -> a) -> b -> [a] -> b
13:57:54 <Cale> litb: Basically a typeclass is a predicate on types, together with an interface of functions which are available when that predicate is true
13:57:56 <byorgey> @type foldl
13:57:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:58:05 <byorgey> uh, sorry
13:58:20 <byorgey> what lambdabot said =)
13:58:20 <Cale> litb: So for any type t, either we have Eq t, or not. If we do, then we're allowed to use (==) :: t -> t -> Bool
13:58:36 <kib> Cale : Just wanted to thank you for the HR doc last night.
13:58:38 <byorgey> Nafai: what's an NPE?
13:58:44 <dons> Cale, did you see this weird stuff about equality in python, http://programming.reddit.com/info/65mm7/comments/c02ws7j
13:58:44 <Cale> So that's why the type of (==) looks like  (Eq t) => t -> t -> Bool
13:58:52 <Cale> kib: no problem :)
13:59:00 <kib> it's an easy reading for me as I'm a maths teacher
13:59:20 <bos> dons: that's well known
14:00:01 <Cale> kib: ah, cool :)
14:00:03 <faxathisia> What HR doc?
14:00:07 <Nafai> byorgey: NullPointerException in Java
14:00:18 <byorgey> Nafai: oh.  yeah, those suck.
14:00:25 <byorgey> NullPointerException--
14:00:26 <Cale> faxathisia: The full text of Haskell Road is secretly online
14:00:37 <faxathisia> oh right
14:01:23 <Time`s_Witness> byorgey, i need one of the arguments of "mapCountainers" to be a Char to add it with "addCountainer". according to addCountainer, type a->b->a, a= [String], b=Char. so the type i need for a char is b which is not in any of the order arguments
14:01:48 <Cale> kib: Yeah, I found it kind of strange, in that it doesn't really cover as much Haskell as you'd want for a pure Haskell course, and not really enough mathematics for a course purely about mathematics. This actually probably means it's right where it wants to be.
14:01:48 <Time`s_Witness> so as the next argument: a string. not a list of strings.. a string to feed the function char by char
14:02:08 <bos> dons: if you think that == vs "is" is nasty, you should see eq, eql, equal, and equalp in common lisp!
14:02:08 <byorgey> Time`s_Witness: note String = [Char]
14:02:36 <Cale> dons: strange :)
14:02:43 <Time`s_Witness> byorgey, ok then we have [b] = [Char].. which has the string to feed the function with.. but i still dont have the Char as argument
14:02:46 <litb> ah, now i see
14:02:48 <Time`s_Witness> 'a' is still [String]
14:02:54 <litb> those channel logs are really useful
14:03:17 <kib> Cale : in fact I've just read one chapter last night, about primer numbers. But I suppose I need a better Haskell 'only' book.
14:03:30 <Time`s_Witness> byorgey, so i guess it should be: (a -> b -> a) -> b -> [b] -> a   ;  being a = [String], b = Char
14:03:56 <Time`s_Witness> dont you agree? :x
14:04:31 <hexpuem> has anyone here built ghc with GhcBuildDylibs=YES or SplitObjs=YES on x86?
14:04:34 <Saizan> Time`s_Witness: 'a' :: Char, "a" :: String
14:04:34 <byorgey> Time`s_Witness: no, (a -> b -> a) -> a -> [b] -> a, where a = [String] and b = Char.
14:04:37 <mightybyte> @hoogle split
14:04:38 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
14:04:38 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
14:04:38 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
14:04:42 <faxathisia> kib, Or just write a bigish program?
14:04:59 <faxathisia> kib, learn by experimenting
14:05:02 <mightybyte> Does haskell have a function like strtok?
14:05:06 <byorgey> Time`s_Witness: the first argument will be addCountainer.  the second argument is what you get if the next argument is an empty list.
14:05:07 <bos> hexpuem: yeah, splitobjs works fine
14:05:23 <bos> hexpuem: the dylib support probably doesn't work on most platforms.
14:05:27 <kib> Today, I've found a blog post really interesting [giving Haskell ] : http://blog.ianbicking.org/2008/01/15/documents-vs-objects/ . The guy how wrotes the article is a Pythonist, but puts Haskell on top :)
14:05:27 <hexpuem> yea it built fine for me but diddnt seem like it actually did anything
14:05:28 <lambdabot> Title: Ian Bicking: a blog :: Documents vs. Objects
14:05:30 <ndm> mightybyte: what does that function do?
14:05:44 <hexpuem> test app was same size with and without splitobjs
14:05:44 <byorgey> mightybyte: read
14:05:45 <mightybyte> ndm: It's similar to Java's String.split()
14:05:52 <byorgey> oh, never mind =)
14:05:58 <mightybyte> byorgey: :)
14:06:02 <byorgey> I was thinking of atoi
14:06:06 <mauke> mightybyte: no
14:06:11 <hexpuem> whats roughly the size of hello-world with split objs enabled?
14:06:23 <mightybyte> Haskell has words, bu that only splits on a space
14:06:40 <ndm> mightybyte: no, haskell lacks that, which is deeply unfortunate...
14:06:43 <mauke> @src words
14:06:44 <lambdabot> words s = case dropWhile isSpace s of
14:06:44 <lambdabot>     "" -> []
14:06:44 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:06:50 <mightybyte> ndm: Agreed
14:06:58 <mauke> mightybyte: copy that, change isSpace to what you want
14:07:04 <mauke> or make it a parameter
14:07:05 <Time`s_Witness> byorgey, but i have to get addCountainer of addCountainer of ... of.. of last letter.. so i have to keep feeding letters.. the last time it changes the [String] should be doing the last addCountainer, with the last letter.. i mean, keeping that on mind, it makes no sense for me to use the second argument as "something to se when list = null". i woul rather check if "null (tail __))", then returns addCountainer (head __) , the last addCountain
14:07:25 <kib> faxathisia : you're right, I must practice now.
14:07:25 <mightybyte> mauke: I already did, but I just wanted to check to see if I had missed it somewhere.
14:09:06 <BMeph> Time`s_Witness: Remember - your function has TWO arguments, not just one. You need to give your "helper" function two arguments when you use it, unless you're trying to make a partial function application.
14:09:17 <byorgey> Time`s_Witness: you know, actually, maybe it would be easier if you don't try to implement a general foldl.
14:09:42 <byorgey> Time`s_Witness: you could just implement problemB directly using recursion.
14:10:36 <byorgey> Time`s_Witness: (by the way, 'container' is spelled without a 'u'  ;)
14:10:45 <Time`s_Witness> lol
14:11:01 <Time`s_Witness> shame on me for not even noticing from the problem context which is written in english =|
14:12:28 * osfameron looks at http://www.alpheccar.org/en/posts/show/90
14:12:30 <lambdabot> Title: Monads and the meaning of imperative languages
14:12:56 <litb> however, iterate (*2) 1 is far less descriptive than map (2^) [1..]
14:13:41 <faxathisia> litb, I disagree
14:14:51 <mightybyte> So what would be the procedure to get the more general split method included in the prelude?
14:14:52 <BMeph> litb: It depends on what you mean by "descriptive." Frankly, "iterate (*2) 1" it all but a plain-language (in English, anyway,) description of what you're doing.
14:15:24 <Saizan> mightybyte: propose it on libraries@haskell.org ?
14:15:48 <mightybyte> Saizan: Ok.  I'm surprised it hasn't come up before.  Or has it?
14:15:49 <BMeph> mightybyte: I'd say, file a ticket on the GHC Trac. Or is that "in" the Trac...
14:16:12 <bos> mightybyte: getting new functions into the Prelude is a big deal.
14:16:49 <dobblego> can one not use group for splitting anyway?
14:16:50 <mightybyte> bos: Yeah, I figured.  Since it appears to have been 5 years since it was last published.
14:17:16 <mightybyte> dobblego: Where is group defined?
14:17:26 <mightybyte> @hoogle group
14:17:26 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
14:17:26 <lambdabot> Data.ByteString.group :: ByteString -> [ByteString]
14:17:26 <lambdabot> Data.ByteString.Char8.group :: ByteString -> [ByteString]
14:18:38 <mightybyte> @pl splitStr :: Char -> String -> [String]
14:18:38 <lambdabot> (line 1, column 18):
14:18:38 <lambdabot> unexpected ">" or "-"
14:18:38 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
14:19:13 <mightybyte> @hoogle Char -> String -> [String]
14:19:14 <lambdabot> No matches, try a more general search
14:19:28 <Time`s_Witness> byorgey, ok i got the idea of second argument being to return if empty... that will be also the first argument .. hmm.. however im getting another error <.< http://hpaste.org/5045#a4
14:19:41 <Time`s_Witness> *** Term           : addsCountainer strl (head xs)
14:19:41 <Time`s_Witness> *** Type           : [String]
14:19:41 <Time`s_Witness> *** Does not match : [String] -> Char -> [String]
14:19:59 <BMeph> mightybyte: If you're going to go that far, why not make it REALLY general: split :: Eq a => a -> [a] -> [[a]]
14:20:10 <Time`s_Witness> well, the function does return [String] but.. how can i make it be argument of type [String] -> Char -> [String] ?
14:20:28 <Ihatetoregister> can someone help me with a interpreter problem?
14:20:40 <bos> mightybyte: your split idea comes up quite frequently, and in fact there was traffic about it on some list as recently as last week.
14:20:44 <mightybyte> BMeph: True, trying to figure out how to make lambdabot search for type definitions
14:20:55 <mightybyte> bos: Ahh, I figured it would have.
14:21:09 <byorgey> Time`s_Witness: why do you have (addsCountainer strl (head xs)) twice?
14:21:32 <byorgey> Time`s_Witness: and you should think about what sort of things mapCountainers is expecting as arguments there.
14:22:05 <BMeph> Ihatetoregister: I likely won't know an answer, but I'm willing to listen. :)
14:22:45 <Time`s_Witness> byorgey, well, second argument should return last value so last value is last [String] created by addCountainers.. which i keep passing as argument there in that same place... and the function.. well.. first argument..  hmm... <.< yea.. not logic .. to receive that
14:22:53 <byorgey> Time`s_Witness: also, you seem to be ignoring f.  I really think you should just implement problemB directly rather than trying to create this semi-general mapContainers function.
14:23:13 <bos> mightybyte: if you google a bit for the discussions, you might find it illuminating regarding why there isn't a split function in Prelude or Data.List
14:23:38 <byorgey> Time`s_Witness: what I mean is, if you're going to be implementing the functionality of foldl yourself, then you should just do it directly in problemB
14:23:47 <Time`s_Witness> :s i see
14:23:53 <byorgey> Time`s_Witness: creating this separate mapContainers function is just an unnecessary level of indirection.
14:24:23 <Time`s_Witness> yea, the point is that i want to learn it.. even though that keeping asking here about errors is not a good way to learn, however, i feel i can :)
14:25:28 <Ihatetoregister> great! im about to create a interpreter for a simple language that has the types bool and integer. I need help to write a data type for the expressions. Below is what I got now. How to extend it too booleans? data Expr a = ...?
14:25:30 <Ihatetoregister> data IntExpr = IntOperand Integer | Add IntExpr IntExpr | Sub IntExpr IntExpr | Mul IntExpr IntExpr | Div IntExpr IntExpr
14:25:49 <byorgey> Time`s_Witness: well, if you want to learn about foldl, that's fine
14:26:14 <byorgey> Time`s_Witness: but in that case it should not contain any explicit references to String or Char or addContainers, it's a very general-purpose function
14:26:39 <faxathisia> data Expr = BoolOperand Bool | IntOperand Integer | Add Expr Expr | Sub Expr Expr | Mul Expr Expr | Div Expr Expr
14:27:02 <Time`s_Witness> yea, however if i cant even make it work for particular vars.. heh.. we should always start by simple cases :P
14:27:13 <faxathisia> hmm?
14:27:37 * byorgey --> home
14:28:14 <wagle> Japsu, thanks for reminding me..  8)
14:32:34 <Ihatetoregister> faxathisia: ah, but how do I do Bool/Int special ops with that in a "evaluate" function like this:
14:32:35 <Ihatetoregister> evaluate (Add e1 e2) = (evaluate e1) + (evaluate e2)?
14:32:37 <Ihatetoregister> evaluate (Or e1 e2) = (evaluate e1) || (evaluate e2)?
14:32:50 <faxathisia> hmmm
14:33:18 <Japsu> wagle: pardon?
14:33:22 <Japsu> oh
14:33:23 <Japsu> #git
14:33:25 <Japsu> right
14:33:27 <Japsu> >_>
14:35:06 <BMeph> Ihatetoregister: I'd first want to ask whether you want to mix Int and Bool expressions in the same expression, or if you want to evaluate Int expressions, or Bool expressions, but not both of them mixed up into the same expression.
14:36:01 <wagle> Japsu, heh
14:36:20 <taruti> GADTs work for such things
14:36:29 <faxathisia> Great.
14:36:41 <faxathisia> Ihatetoregister: http://okmij.org/ftp/papers/tagless-final-APLAS.pdf
14:36:42 <Ihatetoregister> they should be separated, but it would be nice with a polymorphic function "evaluate" that takes both :)
14:37:38 <faxathisia> Ihatetoregister: + http://okmij.org/ftp/packages/tagless-final.tar.gz
14:38:35 <Ihatetoregister> faxathisia: thanx, just read it, but that was a bit off my understanding :) thanx anyway
14:39:36 <BMeph> Ihatetoregister: Right, but I think you could get that effect with dependent types.
14:40:03 <Ihatetoregister> ok, what is that?
14:40:30 <BMeph> Heh, heh... ;)
14:40:53 <Ihatetoregister> me lerning haskell :)
14:42:14 <Saizan> haskell doesn't have dependant types
14:42:37 * sclv_ w/r/t the earlier discussion on split reiterates his "unintercalate" proposal.
14:43:47 <olsner_> extracalate?
14:43:50 <Time`s_Witness> for which reasons could i have "Syntax error in input (unexpected `=')" this error, in this line "addsAllContainers strl (x:xs) = addsAllContainers (f strl x) xs" O_o a function returns a value... isnt that... well, usual ? :|
14:44:33 <Ihatetoregister> how do I do then? maybe a separate eval function for bool and int?
14:44:51 <litb> hm, in one file i see .||.
14:45:38 <Saizan> Ihatetoregister: you coudl have a data Value = I Int | B Bool and use that
14:45:39 <litb> it looks like it is a || which accepts (a -> Bool) as its operands
14:46:00 <sjanssen> Time`s_Witness: the error is probably on the previous line
14:46:11 <sjanssen> Time`s_Witness: look for unclosed parens
14:46:35 <Ihatetoregister> Saizan: i see, thanx
14:46:46 <olsner_> perhaps it's liftM2 (||)
14:47:00 <Saizan> Ihatetoregister: this blog post shows some possibilities http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
14:47:01 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
14:47:34 <Ihatetoregister> Saizan: how do I do in the eval function to se if bool then... ||, if int then + etc?
14:47:49 <Ihatetoregister> Saizan: checking
14:48:25 <Time`s_Witness> sjanssen, it was.. i had one more tabulation than i should :| heh :\ thanks:)
14:48:48 <TomMD> @where cufp
14:48:48 <lambdabot> www.galois.com/cufp
14:49:00 <Ihatetoregister> Saizan: yeah, that one. Didnt get the lift functions on that example...
14:49:03 <TomMD> ... but that is still for 2007
14:49:36 <TomMD> Anyone know anything about CUFP for 2008?
14:51:09 <pejo> TomMD, it's usually co-located with ICFP
14:51:39 <TomMD> pejo: Sorry, I should say: "Does anyone know anything about submission deadlines for CUFP 2008?"
14:52:25 <Ihatetoregister> Saizan: sorry, though it was this one: http://meta-meta.blogspot.com/2007/10/simple-infix-calculator-in-haskell.html, will read it better now :P
14:52:26 <lambdabot> Title: Meta-Meta: A simple infix calculator in Haskell, http://tinyurl.com/288j77
14:53:22 <Saizan> Ihatetoregister: ah, didn't see a lift function there:)
14:54:56 <Ihatetoregister> Saizan: that page seem perfect now when I read it :)
14:55:26 <Ihatetoregister> thanx everyone else for the help!
14:57:31 <Saizan> Ihatetoregister: no problem :)
15:05:03 <Time`s_Witness> what is the signature like when i want to have 2 general types of variables? for one, i have for example: "Ord a => a -> a" for 2, i would say something like "Ord a,b => a -> b" but .. hmm.. it seems like not :p
15:05:39 <bos> mightybyte: in fact, someone just submitted an official "split" proposal just now!
15:06:02 <bos> Time`s_Witness: (Ord a, Ord b) => a -> b -> whatever
15:06:13 <Time`s_Witness> thanks bos :)
15:06:15 <idnar> yeah, you need to repeat "Ord"
15:07:11 <Time`s_Witness> i tried like that but without the parentheses
15:07:22 <Time`s_Witness> and tried Ord a => Ord b => a -> b -> ... aswell
15:07:25 <Time`s_Witness> xD
15:08:18 <vincenz> (Ord a, Ord b) => a -> b -> whatever
15:14:09 <mauke> you can only have one => so you need to use tuple syntax
15:17:14 <Time`s_Witness> yea, i see
15:28:18 <ddarius> @users
15:28:18 <lambdabot> Maximum users seen in #haskell: 454, currently: 424 (93.4%), active: 8 (1.9%)
15:35:59 <gwern> yeesh. this is an interesting problem. so this FingerString.hs imports ByteString qualied as B to get, among other things, its 'length'; it then defines a 'length' on its new type FingerString and exports it; however, one of the functions needs the Prelude's length (prelude was previously imported hiding length and a couple others), so I do another import of Prelude, import Prelude as P (length), and use P.length in the function - but now it gets confused
15:36:26 <hpaste>  gwern pasted "length problems" at http://hpaste.org/5048
15:36:59 <hpaste>  gwern annotated "length problems" with "+error message" at http://hpaste.org/5048#a1
15:38:50 <gwern> I suppose the easy way out would be to rename the exported length and update the calling modules...
15:39:44 <olsner_> gwern: don't you mean import qualified Prelude as P?
15:40:20 <gwern> olsner_: guess so, but doesn't seem to matter
15:40:30 <mauke> what's the error message?
15:40:40 * gwern points at hpaste
15:40:54 * mauke does, too
15:41:03 <gwern> ...did it truncate it?
15:41:23 <gwern> yes, it did. bad hpaste
15:41:39 <hpaste>  gwern annotated "length problems" with "thwack. no steak for you tonite" at http://hpaste.org/5048#a2
15:42:13 <mauke> the line numbers are off
15:42:41 <gwern> not surprising. I dropped the copyright headers
15:43:09 <olsner_> @type Data.List.length
15:43:11 <lambdabot> forall a. [a] -> Int
15:43:40 * gwern already fixed that one. it still gets confused
15:43:53 <gwern> the error just becomes 'did you mean Finger.length or P.length?'
15:45:41 <sjanssen> gwern: import qualified Prelude as P (length)
15:46:31 <gwern> sjanssen: I have that
15:46:43 <sjanssen> the paste is missing qualified
15:47:01 <olsner_> hmm, and length isn't listed in import Prelude hiding (...)
15:47:06 <gwern> yes. I changed that and the Data.List imports
15:47:28 <hpaste>  gwern annotated "length problems" with "update" at http://hpaste.org/5048#a3
15:47:51 <gwern> olsner_: wouldn't that conflict with the next import from Prelude?
15:48:20 <sjanssen> gwern: no
15:49:22 <gwern> bleh. so it was importing length from prelude, but because of the qualified it was importing *again* as P.length?
15:49:42 <sjanssen> I think you're making this overly difficult -- hide list from the Prelude import, skip the qualified Prelude import, and use L.length instead
15:50:02 <sjanssen> gwern: no, I think you're just confused on how the import system works
15:50:03 <gwern> :t Data.List.Length
15:50:04 <lambdabot>     Not in scope: data constructor `Data.List.Length'
15:50:12 <TomMD> sjanssen: Hows classes going?
15:50:15 <gwern> :t Data.List.length
15:50:15 <lambdabot> forall a. [a] -> Int
15:51:02 <sjanssen> the name is made available by *every* possible import, and each import is considered separately
15:51:15 <sjanssen> TomMD: fine
15:51:23 <gwern> :t length
15:51:24 <lambdabot> forall a. [a] -> Int
15:51:31 <TomMD> sjanssen: And job hunting?  Want to send over a resume?
15:51:37 <gwern> sjanssen: as usual, you are right
15:52:21 <gwern> :t Data.List.head
15:52:22 <lambdabot> forall a. [a] -> a
15:52:24 <dons> sjanssen: you know where *else* to send your resume...
15:52:37 <TomMD> grrr
15:52:50 <sjanssen> TomMD: for various reasons, it looks I'll be stuck in Lincoln for quite some time
15:53:14 <sjanssen> TomMD: but thanks for the offer (and sorry for leaving you hanging about it)
15:53:52 <TomMD> sjanssen: Thats fine.  I won't pry, but if things change and you start looking again feel free to message me.
15:54:12 <sjanssen> dons: :)
15:54:21 <gwern> and people say there are no haskell jobs :)
15:54:34 <TomMD> I'd try to recruit you too, dons, but I know I would fail.
15:55:31 <dons> let me know if you can't find someone, though, TomMD. i might know possibles
15:55:47 <ricky_clarkson> TomMD: I'm underqualified, etc., just take this as idle curiosity, but what kind of work is it?
15:55:51 <TomMD> I'm open to recommendations.  Recruiting is hard.
15:56:00 <glguy> let's go shopping!
15:56:54 <TomMD> ricky_clarkson: mostly system design and Haskell programming.  You'd have to be very self directed, direction comes from the bottom and goes up.
15:57:10 <dons> TomMD: well, there are definitely people looking for jobs. and galois and CS can't hire them all. TomMD, did you see jobs-in-fp.org recently?
15:57:19 <TomMD> glguy: I'd try to recruit you too, but being able to beat dons regularly isn't a perk I can offer over your current position.
15:57:47 <smack_> what's CS?
15:57:56 <olsner_> credit suisse?
15:58:05 <smack_> ah
15:58:17 <TomMD> dons: I did see j-i-fp, but wasn't in a position to go :-(.   I'm being a bit selective on who I talk to simply because of bad apples I've seen in the past.
15:58:32 <gwern> cs probably equals computer science
15:58:36 <dons> yep, definitely wise. there's enough people that such a strategy should work.
15:58:49 <glguy> gwern: see olsner_'s answer
15:59:22 <TomMD> Well shoot, time to eat.  I'll talk to you guys a bit later tonight hopfully.
15:59:24 <gwern> glguy: olsner_ asked a question, no one confirmed his guess
15:59:38 <dons> ciao TomMD
15:59:54 <glguy> gwern: ok, well, I confirmed it for you :)
16:00:00 <SyntaxNinja> no recruiting glguy
16:00:06 <glguy> hey!
16:00:20 <glguy> what if it was some really good offer?
16:00:20 <SyntaxNinja> dibs!
16:00:20 <ddarius> computer science doesn't usually hire people
16:00:22 <glguy> You'd just hold me on your project selfishly?
16:00:37 <SyntaxNinja> glguy: even better.  I make you want my projects ;)
16:00:44 <dons> hah
16:01:07 <glguy> Anyway, shouldn't you be working?
16:01:18 <ddarius> "It's up to you what you really want to do / spend some time in America"
16:01:40 * SyntaxNinja works
16:06:21 <olsner_> funny: http://graverobbers.blogspot.com/2007/04/two-cores-walk-into-bar.html
16:06:22 <lambdabot> Title: Grave Robbers From Outer Space: two cores walk into a bar, http://tinyurl.com/ypoeue
16:07:33 <LoganCapaldo> "Its amazing how really, terminally, completely broken shit can run for a damn long time..." truer words have never been spoken
16:07:42 <faxathisia> Yes
16:08:15 <EvilTerran> <insert topical politics comment>
16:08:45 <olsner_> <express amusement>
16:08:57 <gwern> plan 9 is still around? I thought even its own researchers had abandoned it
16:09:06 <monochrom> <attack unfavourite programming languages and methods>
16:09:10 <faxathisia> <<next type of response>>
16:09:19 <nelhage> There are still a few people who swear by it
16:09:23 <glguy> <ban>
16:09:31 <Valodim_> haha
16:09:38 <nelhage> I know one dude who did a lot of dev work for Plan 9 who still uses it for a lot of stuff
16:09:44 <monochrom> {- Shouldn't we be using {- -} though? -}
16:09:50 <Valodim_> meta-humor. great.
16:10:24 <glguy> monochrom: I think that it is in the spirit of:
16:10:27 * EvilTerran sees what monochrom did there
16:10:29 <glguy> putStrLn "this"
16:10:33 <glguy> > putStrLn "this"
16:10:36 <lambdabot>  <IO ()>
16:10:36 <olsner_>  /* or ironically use /* non-nesting comments */
16:10:40 <gwern> anyone want to clean up my finger tree article? :) it's at https://secure.wikimedia.org/wikipedia/en/wiki/Finger_tree
16:11:06 <glguy> unevaluated actions being printed to channel
16:11:28 <dons> gwern: so some main things i'd mention: the Coq proof of the finger tree api
16:11:38 <EvilTerran>  <IO SmartAssery>
16:11:51 <Valodim_> Considering first-order humor, I wonder what curried humor would look like...
16:11:54 <gwern> dons: oh? where's that?
16:12:02 <dons> let me find you the paper
16:12:07 <gwern> Valodim_: it'd be all chopped up
16:12:17 <Valodim_> and pointless
16:12:17 <gwern> '[PDF]
16:12:17 <gwern> Program-ing Finger Trees In Coq or How To Morph Endo Using Type Theory
16:12:18 <gwern> ?
16:12:25 <Valodim_> erh, free
16:12:27 <dons> gwern: http://www.lri.fr/~sozeau/research/russell/fingertrees.en.html
16:12:28 <lambdabot> Title: Matthieu Sozeau :: Dependent Finger Trees in Coq
16:12:58 <gwern> dons: will look
16:13:21 * gwern winces whenever Coq is mentioned tho
16:13:26 <dons> gwern: also, there are implementations in ocaml. (you could have an 'implementations' section)
16:13:32 <faxathisia> Why?
16:14:09 * olsner_ leaves the wonderful world of #haskell to get a wee bit of sleep
16:14:26 <faxathisia> gwern
16:14:35 <EvilTerran> @tell mads- formatting codes in your /quit message make baby jesus cry
16:14:35 <lambdabot> Consider it noted.
16:14:58 <gwern> dons: 'k
16:15:02 <d0rt> i'm just getting started and i'm following http://haskell.org/haskellwiki/Haskell_in_5_steps -- i get a syntax error in hugs when entering     let fac n = if n == 0 then 1 else n * fac (n-1)      which i think is supposed to define a factorial function
16:15:11 <gwern> faxathisia: think about it. what if you ask someone for some Coq?
16:15:44 <glguy> d0rt: hugs doesn't allow you to define top level functions
16:15:52 <faxathisia> gwern, non-technical reasons then?
16:15:55 <glguy> d0rt: you'll want to either put them in a file, or use them straight-away:
16:15:57 <d0rt> ty glguy
16:15:59 <glguy> let f x = 1 in f 3
16:16:32 <dons> d0rt: yeah, you'll want ghci. (i think the article mentions this isn't supported in the older hugs implementation)
16:16:33 <vincenz> deadlock, not just an abstract problem: http://img209.imageshack.us/img209/5781/deadlocknajkcomafarialibh3.jpg
16:16:34 <lambdabot> http://tinyurl.com/2k433j
16:16:52 <gwern> faxathisia: yes! the name is just too horrible
16:16:59 <glguy> vincenz: did someone just send you that link?
16:17:08 <dons> glguy: its on reddit
16:17:16 <glguy> ahh
16:17:17 * EvilTerran pronounces it "cee oh cue" when around people who aren't familiar with it
16:17:28 <dons> > let fac n = if n == 0 then 1 else n * fac (n-1)       in fac 7 -- d0rt
16:17:30 <lambdabot>  5040
16:17:30 <glguy> EvilTerran: does that confuse the people who are?
16:17:41 <vincenz> glguy: why/
16:17:49 <vincenz> dons: thanks for my undergrad compliment :)
16:17:51 * faxathisia dosen't see it as a big deal.. oh well
16:18:04 <EvilTerran> i think they can usually work it out. it takes longer to say, tho.
16:18:09 <dons> vincenz: :) well, i did teach an undergrad course, where that would have been a A+ submission :)
16:18:12 <d0rt> thx very much for that dons
16:18:17 <glguy> vincenz: dons just sent a link in a different channel, wondered where you both saw it
16:18:21 <dons> vincenz: though it was for MinHs, not MinML
16:18:30 <monochrom> Yeah, saying out load "cock" in front of people who don't know you mean "coq" is a bad idea. :)
16:18:31 <d0rt> i will go continue slogging through the introductory material now :-]
16:18:35 <vincenz> dons: well I'm glad I can get an A+ on an undergrad course :D
16:18:42 <dons> d0rt: got ghci/ghc installed?
16:18:52 <dons> vincenz: sure. good work like that deserves a good mark
16:18:55 <d0rt> yeah, but my lappy is dual boot
16:19:01 <vincenz> dons: btw, I'm getting a contract
16:19:05 <dons> oh, you've winhugs on windows, d0rt ?
16:19:10 <d0rt> and i have that installed/setup on linux (which i'musually booted to)
16:19:11 <dons> vincenz: a contract to do what?
16:19:14 <dons> d0rt: ah cool
16:19:18 <d0rt> but i'm in windoze at the moment
16:19:25 <vincenz> dons: job
16:19:26 <dons> fair enough. hugs is easy to set up on windows
16:19:30 <dons> vincenz: awesome. doing what?
16:19:38 * vincenz is going to be a GoOgLer
16:19:40 <d0rt> that it was
16:19:46 <dons> ah right, yes, you mentioned.
16:19:50 <vincenz> I did?
16:19:53 <dons> vincenz: working with tibbe in zurich? :)
16:19:56 * vincenz kept that pretty quiet afaicr
16:20:04 <vincenz> dons: yep ;)
16:20:10 <dons> really?
16:20:16 <vincenz> Erm...yes
16:20:25 <dons> cool. then we have *2* on the inside over in zurich
16:20:28 <vincenz> \p/
16:20:36 <vincenz> Yes, I want to push Haskell :)
16:20:57 <dons> good! :)
16:21:01 <vincenz> hmm \p/ looks like an ocaml guy
16:21:08 <LoganCapaldo> hoogle at google?
16:21:10 <vincenz> (camel head)
16:21:13 * EvilTerran knows a guy at google dublin, too
16:21:25 <dons> i think mnislaith applied there, didn't he?
16:21:36 <dons> or he gave a talk to the dublin guys, anyway
16:21:44 <vincenz> @seen tibbe
16:21:44 <lambdabot> I saw tibbe leaving #darcs, #xmonad, #ghc and #haskell 6h 59m 4s ago, and .
16:22:28 <LoganCapaldo> hoogle style searching (by  type) would be hawt integrated into google's code search
16:22:41 <dons> vincenz: ah, you've a lot of C++ experience, iirc?
16:23:32 <vincenz> dons: yep
16:23:35 <dons> cool, ohloh has added a ticket for haskell support, http://labs.ohloh.net/ohcount/ticket/205
16:23:36 <lambdabot> Title: #205 (Add support for Haskell) - ohloh_labs - Trac
16:23:40 <vincenz> dons: haskell fusion on c++
16:23:45 <vincenz> :D
16:23:45 <dons> yep.
16:23:57 * vincenz gave a presentation on that in Utrecht
16:24:01 <vincenz> At swierstra's group
16:24:06 <vincenz> It was rather well received, I think
16:24:54 <dons> oh, cool
16:25:01 <vincenz> then I got to meet roconnor at the dutch fp day :)
16:25:14 <dons> i've not seen any write up about fp dag yet?
16:25:30 <vincenz> hmm
16:25:45 <vincenz> I could try one, but I'm only an outsider, my understanding is limited, and my memory is worse :|
16:39:25 <vincenz> invasion of the d[0-9]rt's?
16:40:22 <glguy> crisis averted
16:41:04 <faxathisia> What does it mean to lift a (lambda) term by a type?
16:44:02 <ddarius> faxathisia: Whatever it is defined to mean.  There is a widely used term "lambda lifting" but not usually in conjunction with "by a type"
16:44:02 <dons> faxathisia: do you have the context for that sentence?
16:44:14 <dons> the "by a type" part is confusing.
16:44:26 <dons> ddarius: how's the parsec3 code? got a repo url?
16:45:08 <faxathisia> from that link on finger trees theres this: http://www.lri.fr/~sozeau/repos/coq/misc/nbe/nbe-doc.pdf
16:45:23 <faxathisia> It says, "Lifting a term by a type U is just a fold."
16:45:56 <ddarius> dons: I was considering getting a code/darcs.haskell.org one.
16:46:09 <dons> ddarius: good idea.
16:50:26 <dons> byorgey: wow. http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source :)
16:50:26 <lambdabot> http://tinyurl.com/22vxvh
16:50:29 <dons> byorgey++
16:51:35 * ddarius has never got back into tracking wiki recent changes.
16:51:47 <byorgey> dons: I've been sitting on that for a while, so I decided to post what I had to the wiki to force myself to finish it =)
16:52:22 <dons> ddarius: we need an rss feed
16:52:46 <byorgey> dons: edits and additions welcome of course =)
16:52:59 <dons> certainly.
16:53:59 <kilimanjaro> > elemIndex 1 $ map (\x -> x*25 `mod` 27) [2..26]
16:54:02 <lambdabot>  Just 11
16:57:56 <sjanssen> dons: there is an RSS feed
16:58:19 <dons> of the recent changes?
16:58:28 <sjanssen> yeah
16:58:43 <dons> i can haz url plz?
16:59:27 * LoganCapaldo gives dons url
16:59:58 <dons> (i know wikipedia has feeds of various things, but i thought our mediawiki was too old)
17:00:18 <sjanssen> dons: it's embedded in the recent changes HTML page
17:00:21 <sjanssen> but no explicit link
17:00:32 <dons> ah!
17:01:23 <sjanssen> does your RSS client support sniffing feeds from HTML?  It's an invaluable feature
17:01:36 <dons> http://haskell.org/haskellwiki/?title=Special:Recentchanges&feed=rss
17:01:36 <lambdabot> http://tinyurl.com/2oetxe
17:02:43 <dons> well, firefox spots it -- i was just ignoring firefox, it seems :)
17:03:32 <psnively> Hi guys. Is there a good known idiom for getting all of the class names in a module?
17:03:52 <dcoutts_> aaarg! hackage has such a high rate of uploads I cannot keep up!
17:03:52 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
17:04:04 <dcoutts_> 14 today!?!!
17:04:14 <ddarius> byorgey: Nice use of the word "limpid"
17:04:36 <radetsky> dons: you never explained the meaning of that comment about ^L
17:04:37 * ddarius tends to ignore firefox.
17:04:49 <dons> radetsky: what do you want to know about ^L ?
17:04:55 <ddarius> psnively: sed?
17:05:07 <psnively> Sorry, wrong room. :-)
17:05:07 <dcoutts_> dons: you're our graph expert, we need a graph of rate of uploads over time (assuming we actually log that persistently)
17:05:50 <radetsky> the comment in UI.hs where is says that ^L doesn't work
17:06:10 <radetsky> I don't think this has anything to do with my bug, but it could
17:06:50 <byorgey> ddarius: heh, thanks =)
17:13:18 <radetsky> oh, wait, I understand now
17:14:31 <EvilTerran> psnively, :browse ?
17:14:47 <psnively> Yeah.
17:15:09 <EvilTerran> | grep ^class
17:15:31 * EvilTerran notices "<psnively> Sorry, wrong room. :-)"
17:16:05 <EvilTerran> that's what i get for not reading the scrollback in reverse order ;)
17:17:11 <ddarius> EvilTerran: You read in the proper order, you just have to wait until you get current.
17:17:34 <EvilTerran> when i can be bothered, i usually work backwards from the newest stuff
17:17:41 <EvilTerran> (but that's probably just me)
17:18:17 <EvilTerran> but just now i just scanned the last screenful for anything interesting
17:28:02 <jaredj> question. i'm reading the hitchhiker's tutorial, and it says "arbitrary = ... where {gen_size = ...; gen_name = ...}
17:28:15 <jaredj> and it says "Find a way to check types of gen_size and gen_name"
17:28:49 <jaredj> how do i refer to them?
17:29:11 <kmcallister> jaredj, you can include typesigs in a where block, same as at top level
17:29:32 <ddarius> Chameleon Type Debugger!
17:29:35 <jaredj> but i don't want to assert that they have a type, i want to :t them
17:29:43 <kmcallister> oh
17:29:50 <kmcallister> i don't think ghci can do that
17:30:03 <jaredj> ok, i feel a little better about that
17:30:04 <EvilTerran> does the value of "arbitrary" matter?
17:30:08 <LoganCapaldo> where { gen_size :: ObviouslyWrongType ; gen_size = ... }
17:30:11 <EvilTerran> (i'm guessing so)
17:30:15 <LoganCapaldo> the error will tell you
17:30:27 * LoganCapaldo hax
17:30:30 <jaredj> :)
17:30:36 <Time`s_Witness> btw, byorgey, my main problem was to be unable to understand that a function could be passed as argument. i was seeing that, however i thought it was an execution of the function, like, the argument (Int->Int) would be for example, squares x, and not squares :x  it's a new concept/idea for me :)
17:31:25 <EvilTerran> jaredj, you could just move them out of the where{}...
17:31:27 <jaredj> EvilTerran: yes. i think. arbitrary = liftM2 Dir gen_foo gen_bar, lifting into a random monad
17:31:31 <jaredj> myeh
17:31:38 <kmcallister> EvilTerran, not if they have free variables
17:31:40 <jaredj> that was the first thing i thought
17:31:44 <EvilTerran> (unless their definitions depend on parameters to "arbitrary", say)
17:31:44 <ddarius> Hmm, it seems JSON allows -0 and 1e+3 but not +1.
17:32:06 <vincenz> bastards!
17:32:19 <jaredj> that's fine then, i just thought there might be some syntax for talking about the things in the where clause that i didn't know
17:32:31 <jaredj> woohoo, beer!
17:32:47 <EvilTerran> @remember jaredj woohoo, beer!
17:32:47 <lambdabot> It is forever etched in my memory.
17:32:48 <vincenz> Time`s_Witness: higher order functions and first class functions are a (the?) great aspect of functional programming.
17:32:54 <jaredj> crap lol
17:33:06 <vincenz> Time`s_Witness: You can have a unction that applies a function give to it on each element for a list, instead of writing custom functions each time you want to do something with a list
17:33:16 * EvilTerran is tempted to @remember jaredj crap lol, too
17:33:20 <EvilTerran> @yow
17:33:20 <lambdabot> We place two copies of PEOPLE magazine in a DARK, HUMID mobile home.
17:33:20 <lambdabot> 45 minutes later CYNDI LAUPER emerges wearing a BIRD CAGE on her head!
17:33:25 <kmcallister> jaredj, i thought of another hack
17:33:29 <jaredj> crap crap lol lol
17:33:54 <EvilTerran> > fix $ ("crap "++) . (++" lol")
17:33:57 <lambdabot>  "crap crap crap crap crap crap crap crap crap crap crap crap crap crap crap ...
17:34:07 <jaredj> metacrap
17:34:18 <jaredj> kmcallister: yes?
17:34:19 <Time`s_Witness> vincenz yea, i figured it out.. O_O
17:34:25 <kmcallister> class GiveTypeOf a where giveTypeOf :: a -> (); arbitrary = foo where { gen_size = bar; test = giveTypeOf gen_size }
17:34:27 <vincenz> > fix ("metacrap " ++)
17:34:27 <lambdabot>  "metacrap metacrap metacrap metacrap metacrap metacrap metacrap metacrap met...
17:34:41 <kmcallister> should tell you that you need an instance of GiveTypeOf
17:35:09 <vincenz> Time`s_Witness: congrats :)
17:35:41 <jaredj> hmmm
17:35:44 <LoganCapaldo> kmcallister: isn't that he same thing as my suggestion of :: ObviouslyWrongType, but more typing? :)
17:35:57 <jaredj> ha ha snerk
17:36:00 <kmcallister> LoganCapaldo, i'm not sure
17:36:06 <kmcallister> i think this may give more full types under some situations
17:36:11 <dons> mvanier's monad tutorial, http://mvanier.livejournal.com/1205.html
17:36:12 <lambdabot> Title: mvanier: How not to explain Haskell monads
17:36:15 <kmcallister> won't a mismatch only print the type up to the first constructor that differs
17:36:16 <dons> through another one on the pile
17:36:31 <Time`s_Witness> just need to.. get more used with that concept.. i should research about them.. understand them..train them :D
17:36:50 <vincenz> train teh fonktions!
17:37:06 <EvilTerran> you could also replace "arbitrary = .... where" with "(arbitrary, gen_size', gen_name') = (..., gen_size, gen_name) where..."
17:37:13 <kmcallister> clever
17:37:19 <EvilTerran> (maybe)
17:37:27 <EvilTerran> and look at the types that way
17:38:09 * gwern feels happy as I send my patches/ implemented reverse isearch in Yi t'day
17:38:19 <kmcallister> querying values inside where blocks would be a nice ghci feature
17:38:21 <vincenz> glguy: Yi compiles?
17:38:28 <kmcallister> i'm not sure what the syntax would look like
17:38:40 <LoganCapaldo> kmcallister:  Prelude> let a = map (*2) in a :: () ; gives inferred type `[a] -> [a]' so if your method throws in the Num constraint it would be better
17:39:22 <vincenz> @hoogle typeO
17:39:22 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
17:39:22 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
17:39:22 <lambdabot> Data.Typeable.typeOf2 :: Typeable2 t => t a b -> TypeRep
17:39:26 <vincenz> what about that?
17:39:29 <gwern> kmcallister: no kidding. I sometimes hoist a where clause to the top level just to check the type is what I think it is (or to find out)
17:39:30 <ddarius> "How to write a monad tutorial: Don't."
17:39:33 <gwern> vincenz: was that directed at me?
17:39:39 <vincenz> gwern: yes
17:39:45 <vincenz> but not the typeO bit, that was to LoganCapaldo
17:39:56 * vincenz needs a new laptop with a better keyboard
17:39:59 <kmcallister> we don't actually care about having the type at runtime, though
17:40:14 <vincenz> kmcallister: putStr . show . typeOf $ type
17:40:16 <gwern> vincenz: yes, yi seems to compile
17:40:25 <LoganCapaldo> we just wnat :t for a binding in a where clause :)
17:40:25 <dons> http://programming.reddit.com/info/65pme/details "How not to explain monads (mvanier.livejournal.com)"
17:40:42 <jaredj> forget that, i've got beer
17:41:00 <EvilTerran> :browse lowerCaseIdentifier to look at the binding site (including where{} clause(s)) of lowerCaseIdentifier would work
17:41:27 <EvilTerran> (well, except in the degenerate case of a binding where the pattern binds no actual variables)
17:41:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5050
17:41:39 <jaredj> so here's another thing: i'm doing this hitchhiker thing except i'm not using du, i'm writing it
17:41:49 <jaredj> i want to cache getFileStatus results
17:42:00 <jaredj> i think i need a Map in some sort of State thing
17:42:07 <jaredj> all during some IO
17:42:17 <gwern> it's funny, but when going through packages lately, I saw a ton of quickcheck properties. you know how the authors were enforcing input types? by using 'where
17:42:21 <gwern> s!
17:42:32 <EvilTerran> jaredj, IORef (Map FilePath FileStatusDoodad) --?
17:42:42 <jaredj> mmk
17:43:17 <kmcallister> is there something like "IOMap" or "STMap"
17:43:24 <kmcallister> i.e. Data.Map with in-place update
17:43:24 <jaredj> gwern: foo a b = blabla where { a :: type1; b :: type2 }?
17:43:58 <LoganCapaldo> Map FilePath (IORef FileStatusDoodad) ?
17:44:04 <gwern> jaredj: something like that, yeah
17:44:35 <jaredj> hmh, funky
17:44:37 <gwern> jaredj: and if they had two args, where type = (a + b) :: Int, and so on
17:44:37 <gwern> you can see how silly that is
17:44:44 <EvilTerran> kmcallister, there's not really a need for it; i don't think it could have better O()s than Data.Map with only Ord on the key (like Data.Map)
17:44:54 <jaredj> (a + b) :: Int?? gorsh
17:45:20 <jaredj> i guess that would work, but only fortuitously
17:45:22 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5051
17:45:42 <gwern> jaredj: it coered the inferred type, iirc
17:45:44 <gwern> *coerced
17:45:47 <jaredj> yes
17:46:32 <jaredj> so [...] where { a ++ b :: String }
17:46:48 <EvilTerran> that seems unlikely to work
17:46:54 <vincenz> @hoogle asType
17:46:54 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:46:58 <vincenz> :)
17:47:04 <EvilTerran> seeing as it'd be giving a type to a new binding of (++) scoped to the where{} clause
17:47:09 <vincenz> foo `asType` (undefined :: YourType)
17:47:20 <vincenz> foo `asTypeOf` (undefined :: YourType)
17:47:29 <vincenz> That's how I'd do it :)
17:47:36 <jaredj> EvilTerran: but (a + b) :: Int would?
17:48:02 <EvilTerran> jaredj, i wouldn't count on it. those parentheses may make a difference.
17:48:04 <vincenz> @src asTypeOf
17:48:04 <lambdabot> asTypeOf = const
17:48:07 <jaredj> yeh
17:48:30 <EvilTerran> > let a=1; b=2; (a+b)::Float in (a,b)
17:48:30 <lambdabot>  Parse error at "::Flo..." (column 20)
17:48:32 <jaredj> anyway. so I could make an IORef Map. could i also use some sort of State thingy?
17:48:37 <EvilTerran> > let a=1; b=2; a+b::Float in (a,b)
17:48:37 <lambdabot>  Parse error at "::Flo..." (column 18)
17:48:38 <LoganCapaldo> @type let asTypeOf a b = [a, b] !! 0 in asTypeOf -- look ma no type annotations
17:48:40 <lambdabot> forall a. a -> a -> a
17:48:57 <vincenz> LoganCapaldo: neat
17:49:06 <EvilTerran> jaredj, sure, you could use, say, the StateT (Map FilePath Doodad) IO monad
17:49:07 <LoganCapaldo> head [a, b] is pobbaly smarter
17:49:11 * vincenz nods
17:49:14 <vincenz> was gonna say that
17:49:21 <vincenz> but then again "look ma, no head"
17:49:36 <jaredj> i dunno, i think Logan came out a head
17:49:47 <jaredj> *groan*
17:49:48 <dons> oh, there's an HStringTemplate blog/tut http://programming.reddit.com/info/65pnk/comments/
17:50:23 <EvilTerran> jaredj, but it'd be far simpler to just use an IORef, if you're in IO already
17:50:42 <vincenz> StateT Map is much cleaner
17:51:15 <EvilTerran> vincenz, maybe in theory, but in practice, if everything's already IO-y...
17:52:00 <vincenz> EvilTerran: in practice it means you can layer it on top of an Identity monad and run it in a pure function
17:52:08 <vincenz> EvilTerran: look at my latest blog entry, no IO :)
17:52:24 <EvilTerran> er. jaredj's populating his map with results from getFileStatus.
17:52:29 <vincenz> eh
17:52:34 <vincenz> yes, you can do that purely
17:52:44 <vincenz> foo <- sequence $ map getFileStatus ..
17:52:52 <LoganCapaldo> @type let asTypeOf a b = case [a, b] of [a, b] -> a in asTypeOf
17:52:52 <lambdabot> forall t. t -> t -> t
17:52:59 <jaredj> EvilTerran: check
17:52:59 <vincenz> let m = use foo to make mape with state
17:53:05 <EvilTerran> i think he wants to do it on the fly
17:53:11 <vincenz> it will be on the fly
17:53:11 <jaredj> er, 'ack,' whatever
17:53:15 <vincenz> how do you think getcontents works
17:53:16 <glguy> ?index asTypeOf
17:53:16 <lambdabot> Prelude
17:53:27 <EvilTerran> unsafeInterleaveIO?
17:53:33 * ddarius uses liftMN all the time.
17:53:45 * vincenz shrugs
17:53:51 <dons> asTypeOf was how we did type annotations before type annotations were so well supported
17:53:55 <vincenz> Well t was a suggestion, I think IO should be a little shell around your pure code
17:54:09 <vincenz> keep IO out of haskell code as much as possible
17:54:12 * ddarius should probably consider using Applicative
17:54:23 <EvilTerran> i agree, in principle at least
17:55:11 <dons> vincenz: yeah, i think that's a general strategy to apply to haskell development. the less IO, the more we take advantage of haskell's strengths
17:55:26 <EvilTerran> it might be possible to do something with (modifyIORef execState) or whatever to duck back and forth between the IORef and the State fairly neatly
17:55:34 * vincenz nods at dons
17:55:42 <vincenz> dons: besides, it makes your code more composable with other code
17:56:00 <dons> yep. and easier to test, and easier to start enforcing type properties, and safer to modify/reuse. etc etc.
17:56:09 <vincenz> yep :)
17:56:26 <LoganCapaldo> @type let { asTypeOf a b = let { g = undefined ; q = g a ; y = g b } in a } in asTypeOf
17:56:26 <lambdabot> forall t t1. t -> t1 -> t
17:56:32 <LoganCapaldo> blast
17:56:36 <vincenz> seems like const :)
17:56:38 <LoganCapaldo> I thought the MR would do it
17:56:40 <dons> we give away the advantage by doing more than necessary in IO.
17:57:00 <vincenz> Then you might as well write c-code *cough*
17:57:17 <LoganCapaldo> @type let { asTypeOf a b = let { g = \x -> undefined ; q = g a ; y = g b } in a } in asTypeOf
17:57:18 <lambdabot> forall t t1. t -> t1 -> t
17:57:32 <hexpuem> is "class" in haskell simialr to "interface" in c++ etc?
17:57:38 <hexpuem> similar*
17:57:38 <vincenz> LoganCapaldo: afaik, there is no MR on let-bound identifiers
17:57:52 <ddarius> C++ doesn't have interfaces.  Perhaps you meant Java and the answer is no.
17:58:15 <vincenz> ddarius: very vaguely it is, as an intuitive feeling
17:58:24 <LoganCapaldo> @type let { asTypeOf a b = let { z f = (f a, f b) } in a
17:58:25 <lambdabot> parse error (possibly incorrect indentation)
17:58:38 <Cale> Hmm, according to wikipedia, there's no method to systematically rewrite regular expressions into a normal form. I'm not sure that I believe this statement. Does anyone know where to get a proof that any such function is uncomputable?
17:58:40 <ddarius> vincenz: Very very vaguely.  It's probably best not to make any kind of identification from the get-go.
17:58:41 <LoganCapaldo> @type let { asTypeOf a b = let { z f = (f a, f b) } in a } in asTypeOf
17:58:41 <lambdabot> forall t. t -> t -> t
17:58:44 <LoganCapaldo> woot
17:59:13 <LoganCapaldo> I enjoy this game
17:59:26 <glguy> LoganCapaldo: the goal was to do it without a Haskell 98 type declaration?
17:59:41 <LoganCapaldo> yeah
17:59:52 <glguy> how about:
17:59:57 <LoganCapaldo> I head head [a, b] before but that seems like too much work :)
18:00:05 <glguy> :t let ato a b = if True then a else b in ato
18:00:05 <lambdabot> forall t. t -> t -> t
18:00:07 <vincenz> LoganCapaldo: yeah, this is -way- simpler :D
18:00:20 <vincenz> glguy: nice
18:00:21 <LoganCapaldo> glguy: well played
18:01:06 <EvilTerran> :t let ato a b = a; ato a b = b in ato
18:01:07 <lambdabot> forall t. t -> t -> t
18:01:08 <glguy> :t let ato a b = case () of () -> a; _ -> b
18:01:08 <lambdabot> <command line>:
18:01:08 <lambdabot>     Could not find module `L':
18:01:08 <lambdabot>       Use -v to see a list of the files searched for.
18:01:12 <EvilTerran> :D
18:01:19 <glguy> :t let ato a b = case () of () -> a; _ -> b in ato
18:01:20 <lambdabot> forall t. t -> t -> t
18:01:28 <glguy> (just trying to reduce characters)
18:01:36 <Cale> after all, couldn't you just take an arbitrary total ordering on regular expressions (which is monotone in the structural size of the expression), and then pick the least regular expression which is equivalent to the given one?
18:03:44 <sjanssen> :t \a b -> maybe b id $ Just a
18:03:45 <lambdabot> forall a. a -> a -> a
18:03:46 <twanvl> Only if regular expression equivalence decidable
18:03:52 <sjanssen> @pl \a b -> maybe b id $ Just a
18:03:52 <Cale> and it is.
18:03:52 <lambdabot> flip (flip maybe id) . Just
18:04:12 <vincenz> i disagree
18:04:32 <Cale> vincenz: With what?
18:04:43 <vincenz> that there's an obvious equivalence
18:04:46 <faxathisia> How do you decide?
18:05:12 <faxathisia> Sowething to do with XOR..
18:05:55 <vincenz> Cale: besides the very simple one that is (every regexp is only equal to itself)
18:05:58 <vincenz> but
18:06:00 * vincenz heads off
18:06:15 <Cale> uh, no, two regular expressions are equal if the languages they match are equal
18:07:00 <faxathisia> Has anyone implemented such a desicion procedure in Haskell
18:07:15 <faxathisia> decision*
18:07:26 <EvilTerran> Cale, but the languages are potentially infinite - how do you compare them for equality?
18:07:49 <Cale> EvilTerran: There appear to be papers describing this.
18:08:03 <EvilTerran> ok. have fun with that, i'm going to bed. :P
18:08:11 <kpreid> :t (fromJust .) . Just
18:08:11 <lambdabot>     Couldn't match expected type `a1 -> Maybe a'
18:08:11 <lambdabot>            against inferred type `Maybe a2'
18:08:11 <lambdabot>     In the second argument of `(.)', namely `Just'
18:08:14 <Cale> I'll get one from the ACM portal and put it up :)
18:08:22 * faxathisia is interested
18:08:31 <kpreid> @pl \a b -> fromMaybe a (Just b)
18:08:32 <lambdabot> (. Just) . fromMaybe
18:08:43 <kpreid> @type (. Just) . fromMaybe
18:08:44 <lambdabot> forall a. a -> a -> a
18:08:57 <kpreid> @pl \b a -> fromMaybe a (Just b)
18:08:57 <lambdabot> flip fromMaybe . Just
18:09:08 <Cale> In fact, it's even possible to test when one regular expression is less than another, in the sense that the language it matches is a subset of the other's language.
18:09:45 * Cale uses his friend's university library account to h4x0r the ACM. ;)
18:14:05 <Cale> http://cale.yi.org/autoshare/p355-ginzburg.pdf
18:14:17 <dons> Cale, did you ever think of packaging up those fun new monads as a mtl-new or something on hackage?
18:14:37 <dons> (btw, played with monadLib -- there's some nice rearranging of things in there)
18:14:40 <Cale> dons: It hadn't occurred to me, but yeah, that seems like a good idea ;)
18:15:34 <faxathisia> derivatives of regular ex-pressions o_o
18:15:45 <jaredj> my box won't run windows. no games for me ;_;
18:15:47 <Cale> faxathisia: yes
18:16:57 * faxathisia is always confused at people finding derivatives of discrete objects
18:17:10 <Cale> faxathisia: basically the derivative of a regular expression with respect to the symbol x is the regular expression which matches w exactly when the original expression would match xw
18:17:16 <kmcallister> faxathisia, in combinatorics we discussed how to count the number of strings matching a regular expression using generating functions
18:17:52 <kmcallister> probably not what you're doing but it was cool and involved derivatives
18:17:59 <gwern> man, I'm glad Goerzen uploaded all thoose packages today. fixed a lot of stuff on hackage
18:17:59 <Cale> You can probably think of an obvious way to compute that, but if you can't it so happens I put some Haskell code for it on hpaste a little while ago.
18:18:14 <Cale> http://hpaste.org/5049
18:18:46 <jaredj> cool how lambdabot didn't title that
18:19:11 <dons> Cale, can you write an Arbitrary instance for me, for that?
18:19:13 <kmcallister> nullable <=> empty string is in the language?
18:19:21 <dons> then i'll add a suite of QC tests to pcre-light
18:19:37 <dons> :)
18:19:38 <ddarius> @google "Behavioural Derivative"
18:19:39 <lambdabot> http://starsapphire.wordpress.com/2007/05/18/the-first-beatitude/
18:19:39 <lambdabot> Title: The first beatitude  In His Footsteps
18:19:41 <Cale> I suppose I could :)
18:19:46 <ddarius> @google "Behavioral Derivative"
18:19:46 <Cale> kmcallister: yes
18:19:48 <lambdabot> http://links.jstor.org/sici?sici=0012-9682(198611)54:6%3C1461:CEOSC%3E2.0.CO;2-3
18:20:33 <kmcallister> what's the meaning of lf and (*>)?
18:20:52 <gwern> dons: you get my frag patches alright?
18:21:02 <ddarius> faxathisia: http://homepages.cwi.nl/~janr/papers/
18:21:03 <lambdabot> Title: Publications of Jan Rutten since 1995
18:21:36 <Cale> lf r  is a list of pairs consisting of a possible initial symbol matched by r, together with a regular expression essentially representing the continuation.
18:21:37 <faxathisia> thank you
18:21:51 <ddarius> kmcallister: Those two applications are almost certainly intimately related (re derivatives of REs)
18:22:07 <dons> gwern: yeah, it might do that now, actually. thanks for reminding me :)
18:22:11 <Cale> *> is a sort of concatenation
18:22:15 <dons> gwern: so are you looking to do any new projects of your own?
18:22:44 <kmcallister> ddarius, i'm not sure, i have no idea what RE derivs of the sort w \in r' \iff xw \in r are used for
18:23:01 <gwern> dons: a shell keeps gestating, but I haven't hit on the right conceptual structure. I keep hoping something like the zipper will hit me - like lightning
18:23:44 <ddarius> kmcallister: You may also find the link I gave faxathisia interesting.
18:25:07 <Cale> (rs *> t) is essentially a simplification of  map (second (:*: t)) rs
18:25:23 <gwern> (whoever wrote frag must've originally been a lisper - so many nested parens)
18:25:36 <kmcallister> ddarius, looks cool
18:25:37 <Cale> Once you remove pairs whose continuation is Zero
18:25:52 <dons> gwern: no, just a haskell beginner (and amazing) programmer (definitely no lisp though)
18:26:00 <Cale> (given that insight, I'd probably write it differently now :)
18:26:29 <gwern> dons: you sure he didn't do any lisp before haskell?
18:26:59 <Cale> er, hmm, [(x,Zero)] *> t = [(x, Zero)]... I wonder if I got that right :)
18:27:05 <hpaste>  gwern pasted "example of what I'm talking 'bout" at http://hpaste.org/5052
18:27:25 <gwern> look at the last line - ' msges)))])})))
18:27:40 <gwern> tell me again he wasn't a lisper :)
18:28:15 <dons> definitely not. no lisp at unsw (or anywhere in on the .au eastern seaboard ;), and he was an undergrad at the time.
18:28:29 <jaredj> what's frag
18:28:40 <dons> 3d game in haskell
18:28:41 <Cale> jaredj: It's a first person shooter written in Haskell
18:28:44 <jaredj> oo
18:28:52 <dons> 10 weeks, 1 programmer.
18:29:03 <dons> makes me feel unproductive just thinking about what Mun achieved.
18:29:12 <gwern> jaredj: it's pretty good. I've been tweaking some of it to ultimately get on hackage
18:29:17 <gwern> dons: what has he done since?
18:29:38 <gwern> 10 weeks? wow
18:29:41 <dons> well, he did his undergrad degree, then frag as his honours project, then went off to do some commercial programming
18:30:07 <jaredj> @hoogle IORef
18:30:08 <lambdabot> Data.IORef :: module
18:30:09 <lambdabot> Data.IORef.IORef :: data IORef a
18:30:09 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
18:30:53 <gwern> aw. that's too bad. he could've been a real asset
18:31:30 <dons> heya nostrademons
18:31:34 <kmcallister> how many people (rough order of magnitude) in the world get paid full-time to program in haskell?
18:31:59 <Igloo> Non-academics, presumably?
18:32:00 <ddarius> kmcallister: They aren't required to register themselves.
18:32:15 <kmcallister> yeah but i imagine someone here might have a rough guess
18:32:35 <Korollary> Does the exact figure matter?
18:32:37 <jaredj> ddarius: they should at least register their order of magnitude
18:32:41 <kmcallister> no i'm just curious
18:32:50 <jaredj> "i'm about 10"
18:32:50 <Korollary> It's less than a thousand for sure.
18:32:58 <dons> maybe 100
18:33:05 <Igloo> I think we know of O(100) or O(1000), depending on what exactly you mean by Haskell
18:33:06 <kmcallister> excluding academics?
18:33:30 <kmcallister> Igloo, in what way does it matter what i mean by Haskell?
18:33:38 <dons> there's about a dozen places with between 1-50 haskell programmers, mostly < 10.
18:33:41 <Igloo> It's higher if you count people programming in a Haskell-based EDSL
18:33:44 <gwern> kmcallister: BlueSpec, for instance
18:33:48 <kmcallister> ah, good point
18:33:50 <dons> then, if you take all the unis and phds, there's 1000s
18:34:03 <gwern> they have their own language for VHDL, which is haskellish/in-haskell
18:34:12 <ddarius> Hmm... linking is taking more effort than it should.
18:34:23 <Korollary> I wouldn't count EDSL users.
18:34:39 <dons> Korollary: jdh counts edsl users when counting ocaml users :)
18:34:54 <Korollary> dons: jdh counts a lot of things in interesting ways :)
18:35:09 <dons> if your app depends on a lib that in turn used the FFTW or some thing used in mathematica, and you use mathematica, then you're an ocaml user :)
18:35:20 <Korollary> That's how he gets 300x speed-up over butt-clenching assembly!
18:35:34 <dons> -Obuttclench ?
18:35:46 <Korollary> -Ofacewrinkle
18:36:02 <gwern> -Ofrown
18:36:48 <jfredett> -Oconfused
18:36:56 <jaredj> +1confused
18:37:02 <BMeph> -ORLY?!?!?
18:37:26 <jfredett> lol
18:37:43 <arke> YA RLY!
18:38:16 * ddarius forgot the main case of this function ...
18:39:23 <Korollary> dons: I got an argument for you from physics in your 'provocative' posts: http://en.wikipedia.org/wiki/Landauer_Principle
18:40:12 <dons> :)
18:40:43 <dons> i prefer 'agitating for change' :)
18:41:15 <Korollary> Council of Concerned Programmers ?
18:41:31 <gwern> and does dons the agitprop so well!
18:41:35 <gwern> er. *dons does
18:42:48 <wagle> sounds a lot like the thought experiment showing that maxwell's daemon couldn't decrease entropy,,  he deletes info
18:43:51 <wagle> but i thought the central lemma to that was newer than 1961
18:45:14 <Korollary> wagle: Yeah. I read it first in http://www.theory.caltech.edu/~preskill/ph229/
18:45:14 <lambdabot> Title: Physics 219 Course Information
18:46:06 <Modius> I have the utmost respect for Haskell, and do not claim to have replicated it.  But I've put together a Lisp lazy-list/functional library that allows a few goodies taken from haskell (self-referencing lists), and a bit of control over the degree to which the lazy traversal takes place - intertwined with idiomatic lisp code.  http://cl-heresy.sourceforge.net/Heresy.htm
18:46:07 <lambdabot> Title: Heresy
18:46:22 <Korollary> It says Bennett reconciled the demon with the second law in 1982 with this.
18:46:24 <Modius> (The link is to the doc file)
18:47:53 <Korollary> Modius: Cool
18:48:04 <ddarius> Modius: Such libraries have existed for decades.
18:49:11 <dons> Modius: lazy lists are a super useful structure. good work.
18:49:49 <Modius> dons:  Thanks.  Semi-worried about discussing it here (may be taken as language trolling); but this is where I'd find people most familiar with the material.
18:50:07 <dons> Modius: btw, seen http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR44
18:50:11 <lambdabot> Title: TR44: CONS should not Evaluate its Arguments, http://tinyurl.com/2j7t9h
18:50:12 <dons> "CONS should not Evaluate its Arguments" :)
18:50:29 <wagle> 1976
18:50:44 <dons> Modius: oh no, we're happy to see haskell concepts move around.
18:50:46 <Modius> Learned a lot about lazy-evaluation doing self-referencing list and things like fibonacci - it has to be both memoized AND relinquish the link to the head of the whole link so as to not bloat up on ram when trying to get the 10,000,000th and such.
18:51:26 <wagle> hmm..  was it april 1976?
18:51:30 * wagle checks
18:51:39 <dons> i think it was earlier. hmm
18:51:56 <jfredett> lazy lists for lisp? what?
18:52:01 <jfredett> sweet deal.
18:52:07 <jfredett> *reads backlogs
18:52:08 <Modius> Problem is, you can't mix PURE lazy in with idiomatic lisp, essentially, this was written to coexist with "strict" solutions.  There are horriffic situations (that I'm sure you know better than I do) that can get cancelled out in static analysis that destroy RAM and CPU performance the way I'm running my functions.
18:52:30 <ddarius> Also, SICP developed a stream library.
18:52:36 <dons> ah no, 1976 is right
18:52:59 <wagle> yeah, but january 1976..  8/
18:52:59 <dons> Modius: yeah, if you want laziness, better to have it on by default, than off by default
18:53:01 <Modius> Look at the "Control over laziness:" section in my doc (near the top, in examples)
18:53:03 <nelhage> SICP's streams are strict in their CAR, though, so no lazy trees :)
18:53:18 <dons> otherwise you lose the compositionality of code, when the strict stuff gets in the way breaking everything
18:53:34 <ddarius> nelhage: Hence being called streams and it's not like it doesn't make it clear how you could go about making it strict in both args.
18:53:41 <Modius> The Tail function highlights the 2 different evaluation contexts I have when expressing the desired functions.  (eager and (lazy
18:54:02 <Modius> I use dynamic scope to mark sections of code - eager is the default (eager still means lazy-list is created; but that traversal happens instantly instead of delayed like with (lazy  ))
18:54:33 <Modius> dons:  Don't know if you remember me; but I'm wondering if you're missing Samboys with Flavour-bombs by now.
18:55:55 <Korollary> dons: Do we have that compositionality argument written up somewhere?
18:56:28 <Modius> I'm interested though - is there a way, with the haskell self-referencing list, to find the Nth (with N being really really high_) without bloating up ram while finding it?
18:57:02 <Modius> Sorry, I mean, with a problem like the stereotyped fibonacci
18:57:43 <sjanssen> Modius: sure, it's possible
18:58:01 <ricky_clarkson> I realise you're all going to hate me, but I use lazy lists in Java.
18:58:02 <Modius> Just interested in whatever instructions/tags are used so I can look them up sometime - at least learn the terminology.
18:58:12 <Modius> I use lazy-lists in C#
18:58:14 <ddarius> ricky_clarkson: I've used them in C#
18:58:20 <Modius> (Although I have limited coroutines to use to write the functional constructs)
18:58:24 <ricky_clarkson> Do delegates help there?
18:58:28 <Modius> IEnumerable in C# pushes you that way
18:58:31 <Modius> Yes they REALLY help there
18:58:34 <dons> Modius: sure, i remember. missing coopers (and .au beer in general) :)
18:58:44 <ricky_clarkson> Good, because anonymous classes facilitate it but don't help, in Java.
18:58:50 <Modius> My god, Map, Filter, etc. must be a horror wihtout anon delegates/closures.
18:59:06 <dons> > (cycle 'x') !! 10000000
18:59:08 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
18:59:22 <Modius> dons:  Okay.  One day I'll come around mooching some Aussie solidarity/a haskell job :)
18:59:29 <dons> > (cycle "maybe") !! 10000000
18:59:30 <lambdabot>  'm'
18:59:30 <ricky_clarkson> Modius: you need to be careful with the word "closure".  Java technically has it, just not how you usually want it to look.
18:59:37 <dons> hehe
18:59:41 <dons> > (cycle "maybe") !! 1000000000000
18:59:41 <lambdabot>  Exception: Prelude.(!!): negative index
18:59:53 <dons> > (cycle "maybe") `genericIndex` 1000000000000
18:59:59 <lambdabot> Terminated
19:00:01 <dons> > (cycle "maybe") `genericIndex` 1000000000
19:00:08 <lambdabot> Terminated
19:00:09 <Modius> Is that a monad solution?
19:00:13 <wagle> haha..  i was ready to wait for the universe to end
19:00:19 <Modius> 'I know you could do it with iterate and tuples; but I mean the self-ref
19:00:27 <dons> > cycle "maybe"
19:00:27 <lambdabot>  "maybemaybemaybemaybemaybemaybemaybemaybemaybemaybemaybemaybemaybemaybemaybe...
19:00:29 <ricky_clarkson> wagle: How would you observe that?
19:00:39 <dons> it just sets up a little loop structure in memory
19:00:41 <wagle> from the restaurant
19:00:45 <gwern> not very smart, it seems. ghc could've rewritten that to use mod
19:01:01 <dons> that would be an interesting rewrite rule
19:01:08 <faxathisia> That would ruin it
19:01:10 <ddarius> GHC doesn't know algebra (and for good reason)
19:01:19 <faxathisia> !! is O(n)
19:01:29 <gwern> > "maybe" !! (1000000000 `mod` 5) -- ?
19:01:29 <lambdabot>  'm'
19:01:41 <faxathisia> Why do want to change that?
19:01:45 <Modius> Remember - you still need the memoization - but you need it between 2 adjacent elements, NOT to the head.
19:01:52 <gwern> > "maybe" !! (1000000000000 `mod` 5) -- ?
19:01:52 <lambdabot>  'y'
19:01:53 <wagle> n for cycle "maybe" is infinity?
19:02:15 <gwern> > "maybe" `genericIndex` (1000000000000 `mod` 5)
19:02:16 <lambdabot>  'm'
19:02:26 <Modius> This is over my head.  I need to learn the language properly at some point rather than just cargo-culting it (make no mistake, though, my library has proven useful in its own right mixed iwth CL code)
19:02:58 <dons> forall x. (cycle x) !! n => x !! (n `mod` length x) -- gwern?
19:03:08 <gwern> > "maybe" `genericIndex` (10^12 `mod` 5)  -- how high can we go?
19:03:08 <lambdabot>  'm'
19:03:25 <gwern> > "maybe" `genericIndex` (10^20 `mod` 5)  -- how high can we go?
19:03:25 <lambdabot>  'm'
19:03:28 <faxathisia> > "" !! 0
19:03:29 <lambdabot>  Exception: Prelude.(!!): index too large
19:03:38 <faxathisia> > "" !! (0 `mod` 0)
19:03:39 <lambdabot>  Exception: divide by zero
19:03:48 <LoganCapaldo> > "" !! (-1)
19:03:48 <lambdabot>  Exception: Prelude.(!!): negative index
19:03:52 <LoganCapaldo> oh
19:04:05 <gwern> dons: that could work with appropriate constraints, I think
19:04:05 <dons> ?check \x n -> let _=x::[Int];_=n::Int in  cycle x `genericIndex` n == x !! (n `mod` length x)
19:04:06 <wagle> > (cycle "")
19:04:06 <lambdabot>  Exception: Prelude.cycle: empty list
19:04:07 <lambdabot>  Exception: Prelude.cycle: empty list
19:04:18 <LoganCapaldo> I wanted a Exception: Prelude.(!!): index too small
19:04:23 <dons> ?check \x n -> not (null x) ==> let _=x::[Int];_=n::Int in  cycle x `genericIndex` n == x !! (n `mod` length x)
19:04:25 <lambdabot>  Exception: List.genericIndex: negative argument.
19:04:30 <gwern> dons: you'd need x, at the very least, to be strict, right?
19:04:33 <dons> ?check \x n -> n >= 0 && not (null x) ==> let _=x::[Int];_=n::Int in  cycle x `genericIndex` n == x !! (n `mod` length x)
19:04:34 <lambdabot>  OK, passed 500 tests.
19:04:41 <ddarius> Lazy lists: the number one control structure of Haskell
19:04:59 <hpaste>  sjanssen pasted "self-referencing fib in constant memory" at http://hpaste.org/5053
19:05:46 <sjanssen> Modius: there are two key things: the first is to make sure that the list isn't a top-level constant (because GHC will insist on keeping it in memory)
19:06:28 <sjanssen> Modius: also, you've got to force the elements of the list in sequence, to avoid building up a giant thunk of +'s in each list cell
19:07:01 <ddarius> Use head-strict lists.
19:07:22 <sjanssen> yeah, that would work too
19:07:55 <sjanssen> my 'sequencify' function is easy enough
19:08:52 <ddarius> A cons strict in its first argument would be the third possibility for dealing with this problem.
19:09:12 <dons> i think that would be a useful structure
19:09:39 <sjanssen> it would be, if somebody also cloned Data.List for it
19:10:01 <Modius> You're talking about solutions that would let me get the 10,000,000,000th without a pulse in RAM usage, right?
19:10:26 <sjanssen> Modius: see my paste, it does that
19:12:18 <Modius> sjanssen:  (Excuse my potentially dumb question) - so you solve it by defining the list, named, in terms of a folding up of itself?
19:13:03 <sjanssen> well, let's compare to the usual version: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:13:05 <Modius> sjanssen:  Never mind, I don't have the skill to understand this now (even though it seems pretty simple haskell, I'm quite weak in the language) ; but will gratefully take it off and study it. BTW - at what spot in this would I type the 1,000,000?
19:13:37 <ddarius> There are three approaches to dealing with this issue: use a head-strict list (or generally a data structure strict in the elements), use a strict traversal, force the elements as the data structure is produced.
19:13:42 <sjanssen> Modius: fib 0 1 !! i -- will work
19:14:04 <ddarius> Incidentally, Clean has language support for head-strict lists.
19:14:05 <dons> sjanssen: that's a cute one. can you stick it on the fibonacci page on the haskell wiki?
19:14:17 <Modius> What does head-strict mean?
19:14:41 <ddarius> All the elements are forced.  (i.e the head of each (sub)list)
19:14:58 <Modius> ddarius:  What stops the computer storing them all at  once then?
19:15:10 <ddarius> The tails aren't forced.
19:15:33 * LoganCapaldo just got what sequenceify does
19:15:46 <gwern> @pl writeIndices indcs (pos,content) = writeArray indcs pos content
19:15:46 <lambdabot> writeIndices = (`ap` snd) . (. fst) . writeArray
19:16:00 <gwern> (ick)
19:24:46 <gwern> dons: we may have a problem distributing frag via hackage
19:24:58 <gwern> does hackage have any sort of license requirement?
19:25:36 <gwern> 'All textures in this level remain property of their respective owners. You may NOT use this level as a base to build additional levels without explicit permission of the author! You may distribute this BSP in any electronic format (BBS, Internet, CD, etc) but you may NOT by any means use it to gain money.'
19:25:59 <gwern> so it violates 2 of the 4 freedoms...
19:28:18 <dons> well, its a custom license for some ifles
19:28:42 <dons> not source files though
19:28:50 <dons> all the src is bsd, (i think)
19:29:02 <gwern> it may not be all bad tho. I think quake III was open-sourced, so presumably there should be some bsd or gpl levels floating around
19:29:25 <LoganCapaldo> How may freedoms have you violated today?
19:29:29 <LoganCapaldo> *many
19:29:47 <gwern> LoganCapaldo: the freedom of conscience, the freedom of religion, the freedom from religion...
19:30:18 <gwern> dons: if I were to rip out the egyptian level completely and replace it with a Free level, would you accept those patches?
19:31:58 <sjanssen> gwern: I don't see why those terms are a problem
19:32:22 <sjanssen> as long as you clearly note the terms of those files
19:32:55 <gwern> sjanssen: you don't? they don't allow modification of the files, they don't allow commercial redistribution and so on. the license is proprietary, and so viral. it's bad enough that they were ever distributed together
19:33:12 <gwern> so I can't fix the attempts to load non-existent files, and so on
19:33:39 <gwern> besides, a more recent level from something like OpenArena would probably look nicer anyway
19:33:56 <dons> well, if you find some nicer levels, that are free, that's good
19:34:10 <dons> gwern: you're thinking of not so much hackage, but debian packages and so on?
19:34:14 <sjanssen> I don't see how distribution on hackage breaks any of those terms
19:34:25 <gwern> and who knows what other licenses come into play - 'All textures in this level remain property of their respective owners.'...
19:34:32 <dons> no, hackage would be fine.
19:34:53 <gwern> dons: ultimately. how could gentoo for example switch to just adding scripts to cabal install stuff if Hackage allows contaminated files into its packages?
19:35:20 <LoganCapaldo> is that hackage's problem or gentoos?
19:35:28 <sjanssen> gwern: it is Gentoo's responsbility to verify the licenses
19:35:42 <gwern> LoganCapaldo: it's hackages if it cares about people actually using its stuff...
19:35:55 <LoganCapaldo> can't use something that's not there
19:35:58 <sjanssen> gwern: AFAICT, hackage has absolutely no restrictions on licenses
19:36:00 <gwern> sjanssen: the commercial terms are what bother me. I don't think ads are shown anywhere on haskell.org, so that particular avenue should be safe, but I dunno about the hosting - isn't it done by galois or someone?
19:36:03 <sjanssen> I can stick anything up there
19:36:10 <Modius> sjanssen:  1.  Does hudak cover enough material to understand your fib example?  2.  Will this example end up on haskell.org or should I take my own copy of it?
19:36:12 <dons> sjanssen: supposedly stuff not for redistribution shouldn't be there.
19:36:24 <gwern> sjanssen: that should probably be fixed at some point
19:36:32 <dons> http://haskell.org/haskellwiki/The_Fibonacci_sequence
19:36:53 * gwern puts that on the todo list - make being Free mandatory
19:37:15 <sjanssen> Modius: you should probably keep your own copy, and I've never read that book
19:39:33 <glen_quagmire> I downloaded SOE source code. How can I compile MDL.lhs ? it requires Haskore but haskore source is ../haskore/src
19:42:24 <Modius> Just out of interest, which editor is best to deal with haskell source - emacs, yi or something else?
19:42:32 <glen_quagmire> Modius: i use vim
19:43:08 <LoganCapaldo> don't match the editor to the language match the editor to the programmer
19:43:12 <glen_quagmire> but vim can't do tab completion. Haskore.<tab> I want list of exports
19:43:21 <LoganCapaldo> iow, use whatever it is you usually use :)
19:43:26 <Modius> Okay, just making sure that there's good support in all of them.
19:43:42 <Modius> I'd lose status on this channel if I said what I normally use, so I won't say it.
19:43:49 <Modius> Needless to say I won't be haskelling in it.
19:44:03 <faxathisia> Modius: What's that?
19:44:08 <Modius> DevStudio
19:44:11 <Modius> Microsoft DevStudio.
19:44:13 <wagle> Modius, i use xemacs, but sometimes the indenter gets confused and doesnt work right (repeatedly pressing tab cycles through the possibilities)  when it works, its nice..  dunno about vim
19:44:23 <BMeph> Rainbow Lambda!
19:44:25 <glen_quagmire> which editor/ide can do Haskore.|list of exports| ?
19:44:42 <glen_quagmire> ModuleName.|list of exports|
19:44:46 <wagle> several haskell people at microsoft, not surprising
19:44:55 <faxathisia> Modius: If it can syntax color haskell it's probably as good as most
19:44:59 <glen_quagmire> ghci on windows isn't compiled with readline
19:45:11 <ddarius> glen_quagmire: There is a vim mode that will do that.
19:45:41 <glen_quagmire> ddarius: oh. do I hve to generate tags files?
19:45:59 <ddarius> I think it uses GHCi, but I have no idea, I don't use it.
19:46:46 <glen_quagmire> i'll try eclipse plugin someday
19:47:04 <ddarius> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
19:47:06 <lambdabot> Title: Haskell mode for Vim
19:47:42 <bos> wagle: the indenter is supposed to cycle like that.
19:48:54 <wagle> bos..  it just doesnt always work
19:49:22 <bos> "doesn't work"?
19:49:47 <bos> what does it do that you don't expect?
19:49:55 * ddarius considers going to sleep at a sane time tonight.
19:50:15 <LoganCapaldo> you know what would be interesting
19:50:21 <wagle> nothing
19:50:27 <ddarius> everything
19:50:29 <LoganCapaldo> an editor with "inviisble" { ; }
19:50:47 <gwern> ddarius: you can sleep when you're dead
19:50:55 <LoganCapaldo> you'd type as though you were using explicit layout and the eidtor would translate to indentation
19:51:33 * LoganCapaldo wonders how hard that would be to prototype in yi
19:51:34 <glen_quagmire> ddarius: i'll eventually try that too when i'm tired of typing everything
19:51:44 <ddarius> LoganCapaldo: Why not just highlight the {;} the background color and do the normal indenting just about any editor does.
19:52:26 <LoganCapaldo> that could work too
19:52:39 <LoganCapaldo> and be less complicated :)
19:52:52 <LoganCapaldo> on the other hand it leaves { and ; in your source :)
19:53:08 <ddarius> Which would be preferable.
19:53:51 <LoganCapaldo> yeah i guess my favorite part about layout is how it looks
19:54:00 <LoganCapaldo> hilighting them the background color does that
19:54:15 <LoganCapaldo> clearly you've thought about this more than i have
20:02:08 <clanehin> is it just me, or since 6.8 did ghci start keeping empty lines in its input buffer?  Irritating.
20:11:43 <faxathisia> iterateProgress f x = let y = f x in if x == y then x else iterateProgress f y
20:12:05 <faxathisia> Does anyone know a better way to write that?
20:13:01 <nelhage> @hoogle (a -> a) -> a -> a
20:13:02 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
20:13:02 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
20:13:02 <lambdabot> Control.Monad.Writer.Class.censor :: MonadWriter w m => (w -> w) -> m a -> m a
20:13:41 <faxathisia> > let   iterateProgress f x = let y = f x in if x == y then x else iterateProgress f y   in iterateProgress (`div` 2) 4654
20:13:43 <lambdabot>  0
20:15:25 * gwern tries a particular openarena level in frag. My god, it's full of stars
20:16:06 <wagle> clanehin, blank lines dont show up in 6.6.1
20:17:21 <wagle> clanehin, might be the version of getline
20:17:33 <LoganCapaldo> @type let iterateProgress f x =fst . head . filter (uncurry (==)) $ iterate (\(x, y) -> (y, f y)) (x, f x) in iterateProgress -- this some how doesn't seem better
20:17:33 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
20:17:38 <clanehin> wagle: I thought so.  I use blank lines so I don't scroll too far reading error messages.
20:17:44 <sarehu> darnit.  I want {-# LANGUAGE #-} aliases
20:17:45 <ddarius> :t \f -> fst . until (uncurry (==)) (f . fst &&& fst) . (,) undefined
20:17:46 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
20:18:14 <ddarius> :t \f -> fst . until (uncurry (==)) (f . fst &&& fst) . flip (,) undefined
20:18:15 <lambdabot> forall b. (Eq b) => (b -> b) -> b -> b
20:19:47 <wagle> clanehin, takes me about 12 hours to compile ghc, so i cant really test it myself in a timely manner
20:20:54 <clanehin> I can test it.
20:21:54 <ddarius> wagle: It shouldn't take you 12 hours to compile GHC.
20:22:24 <clanehin> Yeah it's definitely ghci6.8
20:22:46 * clanehin wonders off to report a bug
20:30:55 <wagle> ddarius, puny ibook with 512M ram...  ok, maybe 8 hours, didnt time it, but it was a long time
20:31:48 * ddarius has built older GHCs (newer GHCs are supposed to build much faster) on a AMD K-6 200 with 64MB running Win2k.
20:32:12 <Nafai> ddarius: I bet that took forever!
20:33:50 <wagle> so i'm gonna try in on my dual core, 64 bit, 4 gig RAM machine..  whats ghc-6.8.2-src-extralibs.tar.bz2?
20:33:52 <ddarius> It took less than 24 hours.  I'm pretty sure it took around 12 or less even then.
20:34:13 <radetsky> has anybody on linux tested dons's new hmp3?
20:35:21 <ddarius> 'unexpected "\"" expecting "\""'
20:35:40 <Korollary> I built ghc 6.8.2 on an amd xp1700 with 512MB ram in about an hour (make -j 2)
20:36:14 <Korollary> with extralibs
20:36:48 <radetsky> no?
20:38:35 <wagle> bah: configure: error: GHC is required unless bootstrapping from .hc files.
20:39:59 <wagle> "look ma!  i'm levitating!"
20:41:03 <radetsky> if anybody's bored and wants to try, it'd be a big help
20:42:21 <timbod> Hi... Is there a technical term for a data definition that takes a higher order type as a parameter?
20:42:45 <timbod> eg something like : data X m = X (m Int)
20:42:48 <clanehin> radetsky: trying . . .
20:42:56 <radetsky> clanehin: thanks
20:43:03 <kmcallister> timbod, we would say that m has kind * -> *
20:43:13 <kmcallister> and thus X has kind (* -> *) -> *
20:43:27 <goalieca> hmm tanenbaum seems to think vliw is great.
20:43:34 <kmcallister> don't know what the term for "something with kind not *" is
20:43:35 * goalieca marvels at this textbook
20:43:44 <kmcallister> (higher-order type might be right)
20:44:42 <kmcallister> goalieca, so did intel ;)
20:46:18 <goalieca> i actually ran code on a 64-cpu ia64. it works fast. but not the best number cruncher
20:46:24 <kmcallister> wow
20:46:25 <goalieca> not the best anything
20:46:38 <kmcallister> i hear they're really awesome for specific number crunching loads with specific intel compilers
20:46:39 <ddarius> higher kinded
20:46:55 <goalieca> maybe.. depends on the branch prediction
20:46:57 <kmcallister> but i guess it turns out that a lot of info about parallelization is not available at compile time
20:47:10 <goalieca> monte carlo is tricky stuff..
20:47:12 <timbod> kmcallister: thanks for that
20:47:19 <kmcallister> ah, it was monte carlo sim?
20:47:27 <goalieca> monte carlo, and pde stuff
20:47:40 <goalieca> the core2duo kicked its ass in terms of run time
20:47:48 <goalieca> of course it was newer
20:47:49 <goalieca> but simple
20:48:02 <dons> kmcallister: i had some great results with monte carlo specialised, and compiled with icc
20:48:05 <dons> 2-3x gcc
20:48:14 * ddarius thinks parsec3 has a bug in many.
20:48:29 <goalieca> icc is certainly fast
20:49:01 <bos> it would probably still have been 2-3x regular gcc if compiled with gcc.  icc isn't *that* much faster.
20:49:25 <goalieca> no. for everything i've seen it is roughly < 30%
20:49:47 <bos> yeah, usually in the 15% to 20% range, in my experience.
20:50:03 <goalieca> yeh, 15 sounds about average
20:50:07 <dons> the code compiled by icc was simply better - the compiler knows all the instruction timings, and does fancy branch prediction (but this was a super optimised program, so each instruction in the inner loop counted for a lot)
20:50:39 <bos> oh sure, there's no argument there. i've worked on a compiler that competed successfully with icc :)
20:50:45 <goalieca> well... since i'm doing grad research i don't have that kind of time. i just want it to work
20:51:11 <goalieca> i'll profile a bit.. but i try to keep it simple
20:51:23 <radetsky> dons: if this exciting conversation is getting to be too much for you, I have something I bet you're sick of hearing about to bring you down
20:52:42 * ddarius 's hopes of just throwing parsec3 on Hackage and saying "Enjoy" are diminishing.
20:53:10 <dons> radetsky: well, i just replied to your mail.
20:53:47 <dons> radetsky: if there are multiple mpg321's running, that can result from mpg321 crashing for some reason, hmp3 will fork another. then things might get weird. see the mail for more info
20:53:48 <clanehin> radetsky: pcre-light doesn't compile for me: Base.hsc:103:18:  error: pcre.h: No such file or directory
20:53:59 <dons> clanehin: you don't have libpcre installed
20:54:00 <wagle> intel c compiler?
20:54:06 <dons> sounds like i should look at bundling that with pcre-light
20:54:06 <wagle> (icc)
20:54:23 <kmcallister> wagle, yes
20:54:24 <radetsky> dons: yeah, I thought you shouldn't let the configure complete if it wasn't there
20:54:24 <dons> clanehin: you can get libpcre from your nearest package system
20:54:29 <radetsky> I don't know how to do that tho
20:54:51 <dons> oh, its easy enough. a bit of autoconf
20:55:09 <radetsky> ok
20:55:17 <ddarius> @seen Philippa
20:55:18 <lambdabot> Philippa is in #scannedinavian, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 8h 46m 3s ago.
20:55:19 <radetsky> I'll do the test you wanted in a litle while
20:55:28 <radetsky> but I'm at my bus stop ;)
20:55:32 <dons> ok :)
20:55:34 <clanehin> dons, radetsky: or at least a readme :)
20:55:55 <sjanssen> dons: maybe you can use pkg-config instead of autoconf?
20:56:09 * ddarius remember pkg-config fondly.
20:56:11 <dons> libpcre is a bit too old school for pkg-config
20:56:26 <wagle> kmcallister, thanks
20:56:26 <dons> easier to just try to link a test program
20:58:03 <clanehin> hmmmm.  I accidentally ran runhaskell Setup.hs install as root (using sudo) for one package, doing a --prefix=$HOME install, and now subsequent packages can't update package.conf
20:58:35 <clanehin> I can work around, but it might be a bug
20:59:21 <dons> --user is probably what you want
20:59:24 <dons> not sudo
21:00:02 <clanehin> accidentally :)
21:00:54 <clanehin> it's certainly not specific to the package(s) in question, but I assume to cabal
21:01:20 <bos> no, it's not a bug, you made a mistake.
21:01:58 <bos> as root, chown your package.conf file back to yourself, and you'll be fine.
21:03:08 <clanehin> it's something cabal could be robust against.  It it's not a bug consider it a wish.
21:05:20 <nburlett> ahoy!
21:05:54 <nburlett> how do I make cabal sdist include my tests directory?
21:05:58 <clanehin> dons, radetsky: works debian i386
21:07:08 <sjanssen> nburlett: with the extra-source-files field
21:07:19 <nburlett> sjanssen: I'll give it a try
21:09:23 <ddarius> Yay! Bug fixed.
21:10:17 <gwern> @pl (\x -> "tga/" ++ x ++ ".tga
21:10:17 <lambdabot> (line 1, column 23):
21:10:17 <lambdabot> unexpected "\""
21:10:17 <lambdabot> expecting space or simple term
21:10:18 * ddarius changes some of his (application) code back to see if his mistrust of the library code wasn't especially well-founded.
21:10:21 <gwern> @pl (\x -> "tga/" ++ x ++ ".tga")
21:10:21 <lambdabot> ("tga/" ++) . (++ ".tga")
21:11:20 <nburlett> sjanssen: woo! thanks
21:11:42 <ddarius> Good.  My understanding was right.
21:11:54 * ddarius dislikes not being able to trust infrastructure.
21:12:19 <clanehin> hmm, hmp3 locks up easily for me
21:15:04 <dons> wow. i wonder why this is happening now.
21:15:08 <dons> clanehin: mpg321 or mpg123?
21:15:28 <Cale> Aha, so that's the trick.
21:15:30 <clanehin> I installed both, not sure which it uses by default
21:15:38 <dons> hmm.
21:15:55 <dons> that's interesting then, two reports. though i can't reproduce it :(
21:16:27 <clanehin> ohh, thread blocked indefinitely
21:17:17 <Cale> It's possible to compare the derivatives of a regular expression more easily than it is to compare arbitrary regular expressons, using finite automata. The derivative of a regular expression R with respect to a given word can be assigned an automaton which is the same as that for R, but has a different set of initial states.
21:17:37 <Cale> (or, if you have a DFA, just a different initial state)
21:18:37 <shapr> @yow !
21:18:37 <lambdabot> What PROGRAM are they watching?
21:18:51 * clanehin can't repeat it either, but I had to kill hmp3 twice when I first started using it
21:19:08 <dons> clanehin: its possible there's an issue with mpg321 dying, but not getting cleaned up
21:20:11 <dons> shapr, i meant to ask you, you think haskell open source is a punk ideology of coding? :)
21:21:04 <dons> shapr, we're an anti-establishment diy collective :)
21:22:05 <clanehin> hey, two instances of hmp3 are now using 100% of one of my cpus
21:22:25 <dons> ah right. so if one dies, things go nuts as hmp3 reforks stuff
21:22:26 <smack_> clanehin: sounds like you're doing it wrong
21:22:41 <dons> clanehin: and hmp3 is a bit hard to kill
21:22:58 <dons> clanehin: make sure no more than one instance of hmp3 is running -- its kind of amateurish in its error handling, actually
21:24:45 <clanehin> yeah, I had to sigkill it.
21:25:04 <clanehin> The first time I killed it, it was just by closing the terminal window, so I don't know if they kept running, or what happened.
21:25:11 <dons> hmm
21:25:35 <clanehin> When I said I had to kill it twice, I mean the first two times I ran it, I ended up closing the window.
21:31:34 <ddarius> dons: I should have some good news about parsec3 by the weekend.
21:36:34 <gwern> one of these days I hope to see someone begin a program announcement with 'Many Bothans died to bring us this release'
21:37:12 <shapr> dons: I dunno if it's punk, but it is funk!
21:37:13 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
21:37:17 <nelhage> I feel like I've seen that somewhere
21:37:40 <nelhage> google finds http://www.battleclinic.com/forum/index.php/topic,5720.0.html
21:37:41 <lambdabot> Title: BattleClinic.com - Your online community for EVE Online, Freelancer, Starfleet C ...
21:37:44 <goalieca> whoah. the CM-2 did 1-bit processing.. but with 2^16 of those for some massive simd.
21:38:00 * goalieca loves reading old texts
21:38:23 <shapr> dons: I think #haskell integrates the best of the establishment without picking up much cruft, is that punk?
21:38:35 <gwern> nelhage: gott ver dammt!
21:38:39 <glguy> shapr: How's code?
21:38:49 <shapr> glguy: imperative
21:39:02 <dmwit> "The Glasgow Haskell Compiler compiles to native code on a number of different architecturesas well as to ANSI Cusing C-- as an intermediate language."
21:39:05 <gwern> fscking 'battleclinic'
21:39:05 <shapr> Actually, C# isn't that bad since I have lambdas, map, laziness, etc.
21:39:10 <dmwit> Is there really a C-- phase?
21:39:23 * gwern doesn't care I'll still use it in my next release announcement
21:39:28 <gwern> dmwit: isn't that what -fvia-c uses?
21:39:43 <dmwit> gwern: I thought that used C.
21:40:18 <gwern> dmwit: my understanding was that C-- was an ANSI compliant restricted C
21:40:46 * dmwit goes to look more carefully
21:40:46 <sjanssen> gwern: it isn't
21:40:48 <bos> gwern: it is not
21:41:48 * gwern shrugs. back to hacking on frag
21:41:55 <dmwit> (I ask for two reasons: to make sure Wikipedia has correct information, and because I would be interested in emitting C-- code from Haskell source.)
21:42:25 * shapr goes to sleep, must be up early...
21:42:26 <bos> dmwit: you could also look at the llvm bindings
21:42:26 * shapr &
21:42:27 <dons> shapr: and that our aims are to overthrow the established standards for code quality :) correctness, proofs, types!
21:42:27 <sjanssen> dmwit: I don't think that's incrediably accurate
21:42:43 <dons> C-- isn't a C subset.
21:43:08 <dons> its an FP-friendly C-like language.
21:43:10 <sjanssen> dmwit: GHC has an internal phase called "Cmm" which is similar to C--, lacking some features and adding some others
21:43:26 <dmwit> ah
21:43:58 <sjanssen> and the Cmm phase is used in both the native code generator and the C generator
21:44:22 <dons> there's a fairly trivial translation from Cmm to C.
21:44:26 <dons> (just a pretty printer pass)
21:44:56 <dmwit> bos: Ah, that's interesting, thanks for the pointer.
21:58:39 <gwern> @pl getTagpos u = (tagPos u, rotation u)
21:58:40 <lambdabot> getTagpos = liftM2 (,) tagPos rotation
22:09:08 <scook0> @hoogle null
22:09:09 <lambdabot> Prelude.null :: [a] -> Bool
22:09:09 <lambdabot> Data.List.null :: [a] -> Bool
22:09:09 <lambdabot> Data.ByteString.null :: ByteString -> Bool
22:09:12 <scook0> @hoogle nullptr
22:09:12 <lambdabot> Foreign.Ptr.nullPtr :: Ptr a
22:46:33 <sjanssen> did the cafe thread "Why purely in haskell?" have anything of interest, or should I skip it?
22:48:01 <sarehu> sjanssen: I think you can skip it
22:49:44 <sarehu> Some side-thread with people saying (==) should recognize cyclic structures or something,
22:50:38 <sarehu> But generally, blah blah blah.  The only thing I found interesting was:
22:50:57 <sarehu> > let x = 0/0 in (compare x (0/0), x > 0/0)
22:51:00 <lambdabot>  (GT,False)
22:55:13 <sjanssen> sarehu: yeah, good 'ole IEEE semantics
23:02:40 <glguy> sjanssen: What does IEEE have to say about that?
23:02:52 <glguy> when using compare, return GT otherwise if using > return False?
23:03:12 <sarehu> glguy:
23:03:15 <sarehu> > 0/0 == 0/0
23:03:18 <lambdabot>  False
23:03:19 <sarehu> > 0/0 /= 0/0
23:03:20 <lambdabot>  True
23:03:31 <sarehu> > (0/0 < 0/0, 0/0 > 0/0, 0/0 <= 0/0, 0/0 >= 0/0)
23:03:36 <lambdabot>  (False,False,False,False)
23:04:00 <glguy> then float just shouldn't be an instance of Ord...
23:04:02 <sarehu> you'll find that @src compare gives  | otherwise = GT
23:04:27 <ibid> or Ord should allow for Unordered :)
23:04:33 <ibid> (ie. partial orders)
23:04:46 <glguy> that would just be a new typeclass
23:05:41 <ibid> yeah, but floats are a convincing case why that typeclass should have priority on the (<) etc operators :)
23:10:08 <bos> > (1/0 < 2/0, 2/0 < 1/0) -- more entertaining
23:10:10 <lambdabot>  (False,False)
23:18:57 <oklopol> > (1/0)
23:19:00 <lambdabot>  Infinity
23:19:06 <oklopol> > (1/0)-5
23:19:06 <lambdabot>  Infinity
23:19:12 <oklopol> > (1/0)-(1/0)
23:19:13 <lambdabot>  0.0
23:19:37 <oklopol> awesome
23:21:47 <sarehu> > (2/0)-(1/0)
23:21:48 <lambdabot>  NaN
23:22:07 <sarehu> > (1/0)*2-(2/0)
23:22:08 <lambdabot>  NaN
23:22:21 <sarehu> > (1/(2*0))-(1/0)
23:22:23 <lambdabot>  0.0
23:27:51 <Cale> Okay, I completely understand how regular expressions can be compared for equality now, in case anyone wants to know. :)
23:28:07 <Korollary> Get a blog
23:28:53 <Cale> heh
23:32:26 <smack_> Cale: i'm a bit curious.  are they each rewritten to a normal form?
23:32:35 <Cale> smack_: not quite
23:32:59 <glguy> comparing the DFA?
23:33:30 <Cale> Essentially using the DFA (or NFA) to easily represent the derivatives of the regular expression.
23:33:53 <Cale> It's always possible to write down an equation:
23:34:13 <Cale> R = delta(R) + sum over x in A of x D_x R
23:34:31 <Cale> where delta(R) = 1 if the empty string is matched by R, and 0 otherwise
23:34:42 <Cale> and A is the alphabet
23:34:49 <Cale> D_x the derivative with respect to x
23:35:52 <Cale> Now, the derivative with respect to x of a regular expression R represented as a DFA is easy. It's simply the DFA obtained by changing the initial state to the one obtained after matching x
23:36:38 <Cale> So you can represent the derivatives of R efficiently, and compare them for (a slightly weakened, but good enough) equality
23:37:42 <Cale> Now, you can do this repeatedly, building up a list of equations which the derivatives of R satisfy.
23:38:18 <Cale> and you can stop when you don't get any new equations from differentiating the derivatives that already occur in your equations.
23:38:45 <Cale> The resulting set of differential equations on R characterise R uniquely.
23:39:10 <sarehu> > let ns = repeat 1 in ((ns!!0)/0 - (ns!!0)/0, (1/0 - 1/0)) -- le sigh
23:39:13 <Cale> Now, for equality comparison, you can do the same trick, but with pairs of regular expressions, (R,S)
23:39:14 <lambdabot>  (NaN,0.0)
23:39:28 <Cale> (and just map everything over the pairs pointwise)
23:40:06 <Cale> The only place where this can potentially result in a difference is in the deltas
23:40:06 <smack_> Cale: interesting, but i'll probably need to meditate on it later to completely follow
23:40:16 <glguy> :t let ns = repeat 1 in ((ns!!0)/0 - (ns!!0)/0, (1/0 - 1/0))
23:40:17 <lambdabot> forall t t1. (Fractional t, Fractional t1) => (t, t1)
23:40:40 <glguy> > let ns = repeat 1 in ((ns!!0)/0 - (ns!!0)/0, (1/0 - 1/0)) :: (Float,Float)
23:40:41 <lambdabot>  (NaN,0.0)
23:40:46 <Cale> If delta(R') = delta(S') for each pair (R',S') for which you have an equation, then the regular expressions are equal
23:41:12 <Cale> (essentially because they satisfy the same set of differential equations)
23:41:29 <Cale> (and those sets are complete enough to have a unique solution)
23:41:53 <Cale> But if delta(R') /= delta(S') at some point, then the languages recognised by each must have been different.
23:42:43 * glguy doesn't really understand the concept of the derivative of a graph
23:42:53 <Cale> glguy: In this context?
23:42:58 <glguy> yeah
23:43:37 <Cale> glguy: The derivative of a DFA/NFA with respect to a word x is the DFA/NFA whose initial state/set of states is the state after reading x.
23:44:14 <smack_> Cale: i saw that, but don't see the relation to mathematical derivatives...
23:44:14 <Cale> This corresponds to the derivative of a regular expression, which is defined by:
23:44:16 <Cale> D(0) = 0
23:44:18 <Cale> D(1) = 0
23:44:27 <Cale> D_x(x) = 1
23:44:32 <Cale> D_x(y) = 0
23:44:46 <Cale> D_x(P*) = D(P) P*
23:44:54 <Cale> D_x(P+Q) = D(P) + D(Q)
23:45:05 <Cale> D_x(PQ) = D(P) Q + P D(Q)
23:45:22 <Cale> er, I left off some subscripts there
23:45:28 <Cale> But they're all with respect to x
23:46:05 <Cale> The resulting differentiated regular expression matches w if the original regular expression matched xw
23:46:48 <Cale> You can see how:
23:47:04 <Cale> D_x(PQ) = D_x(P) Q + P D_x(Q) -- this is just the product rule for derivatives
23:47:56 <smack_> yep
23:47:56 <Cale> If you're a combinatorialist, this is an unsurprising result. Differentiation usually corresponds to removal of some substructure.
23:49:41 <Cale> (just like, differentiating a datatype (D t) with respect to t leaves you with a datatype that's similar to the original, but where one of the pieces of data of type t held by each of the values has been replaced by a 'hole'
23:49:53 <Cale> which you'll have seen if you've read up on zippers)
23:50:08 <glguy> That use of derivatives I've seen
23:50:22 * smack_ apparently hasn't read up enough on zippers
23:51:38 <quicksilver> "The derivative of a type is the type of its one-hole contexts"
23:51:47 <quicksilver> but just wait until you read about logarithms of types :P
23:51:52 <Cale> So here, rather than removing a piece of data, leaving a 'hole', we've removed a character from the start of the words in the regular language (and deleted those words not starting with that letter entirely)
23:57:00 <Cale> er, actually, that's not quite right
23:57:20 <Cale> D(PQ) = D(P) Q + delta(P) D(Q)
23:57:47 <Cale> (which kind of spoils the correspondence with the usual derivative a bit, but it's still fairly similar)
