00:00:50 <Trinithis> night
00:02:22 <hpaste>  blbrown pasted "Modify state help" at http://hpaste.org/5259
00:04:07 <BMeph> Cale: Or is it that when you get GHC processing 88 thunks a second, the cascade from the flux capacitor sends your program to get compiled by machines in the future? ;)
00:04:22 <Cale> blbrown: I'd probably start out just implementing it with parameter passing in a purely functional way.
00:04:23 <blbrown> http://hpaste.org/5259  anybody see what I am doing here
00:04:51 <Tac-Tics> the where clause looks to be misplaced in your main
00:05:11 <Cale> also, your main doesn't appear to be an IO action
00:05:30 * BMeph feels anzious when people mix "where" and "let" in the same line...
00:05:35 <Tac-Tics> wait, you have two mains
00:05:36 <Tac-Tics> hehe
00:05:39 <BMeph> s/anzious/anxious/
00:05:45 <blbrown> I was doing pseudo code, I think
00:06:15 <Tac-Tics> what are you trying to do, overall?
00:07:28 <dons> ?users
00:07:28 <lambdabot> Maximum users seen in #haskell: 449, currently: 390 (86.9%), active: 13 (3.3%)
00:07:47 <Tac-Tics> what is the point of the ?users command?
00:07:58 <Cale> Reader is really better for things like implementing lexical variable scoping, where you only locally change the environment.
00:07:59 <Tac-Tics> I see people use it all the time, but I can't figure out what information they're getting from it
00:08:19 <Cale> Tac-Tics: Information about how many users there are in the channel
00:08:24 <Cale> and how many are active
00:09:10 <oerjan> and how many there have been maximum, if lambdabot didn't suffer from amnesia.
00:09:34 <Tac-Tics> even though there's so many people, it never gets too crazy in the channel
00:09:38 <Tac-Tics> which is nice
00:09:45 <Tac-Tics> Everyone gets to know each other
00:09:56 <ddarius> Tac-Tics: Mainly I suspect people do it to see the maximum users.
00:10:06 <Cale> Wow! Frank Zappa is posthumously visiting our IRC channel!
00:10:15 <Cale> :)
00:10:35 <blbrown> Tac-Tics, I think I got it, I dont reall need the reader monad
00:10:42 <ddarius> I personally completely ignore the active part and I don't need lambdabot to tell me the number of current users.
00:11:40 <dons> its strange how we've made it to 450 without losing control
00:11:59 <Tac-Tics> losing control?
00:12:05 <ddarius> 454 at least, lambdabot is amnesiac.
00:12:47 <Cale> Could have something to do with so many of our users being idlers :)
00:13:17 <Tac-Tics> they're not idle, they're just in awe of the spectacle which is this channel
00:13:19 <mrd> idle? never!
00:13:25 <mrd> what, me idle?
00:13:30 <dons> hey blbrown !
00:13:42 <blbrown> dons: hello
00:13:43 <dons> been following your blog updates. nice work!
00:14:02 <blbrown> dons: lalalalalala, I have no idea what I doing, lalalala
00:14:04 <dons> http://berlinbrowndev.blogspot.com/2008/01/haskell-is-very-expressive-language.html :)
00:14:05 <lambdabot> Title: Berlin Brown and Development: Haskell is a very expressive language, http://tinyurl.com/2lrtx4
00:14:10 <ddarius> Cale: Most say something some time.
00:14:25 <dons> blbrown: you made the HWN quotes of the week with that one :)
00:14:34 * ddarius should make a blog and a blog post with the title: "Haskell is a very inexpressive language"
00:15:10 <blbrown> dons: I have some AMQP code which I sent to the haskell-cafe list, but I stopped working on it
00:15:34 <dons> yep, i replied to that just now
00:15:34 <Cale> ddarius: yes! It will throw some people off!
00:15:45 <dons> i propose we box it up and put it on hackage.haskell.org blbrown
00:15:59 <dons> then it can be found if people want to extend it
00:16:11 <blbrown> dons: will have to be a 0.0 release
00:16:22 <dons> sure
00:16:27 <dons> better than losing the code :)
00:16:41 <ddarius> Cale: It's true, though.  Adding any side-effect to Haskell would (in a particular and fairly reasonable respect) make Haskell a more expressive language.
00:16:48 <dons> Cale: how did haskell get so many comments in the 'C is like red meat and rum' thread?
00:17:00 <ddarius> I blame you dons.
00:17:06 <Cale> dons: I have no idea ;)
00:17:23 <dons> ddarius: twasn't me. and no one mentioned my vegetarianism metaphor :)
00:17:39 <ddarius> It wasn't you -directly- perhaps.
00:17:44 * ddarius hasn't seen this thread.
00:17:53 <dons> http://reddit.com/r/programming/info/66paw/comments/
00:17:59 <Tac-Tics> Whoa, reddit bullet pointed my list of hallucinations
00:18:11 <yoshi> thank you to all who helped me but it seems as though \" renders &quot; which is different from a quotation mark in the text/css portion of the html. When I compare the rendered html with my own (where I substituted &quot; for ")  there is a substantial difference. ..I'm so bummed... I spent about 4 hours today on writing css for my web page and I can't even use it =[
00:18:43 <BMeph> On the record, even as goofy as the statements I make in-channel, I have erased more lines than I've sent through. ;p
00:20:17 <dons> ddarius: but yeah, maybe we have some mindshare we didn't have 24 months ago
00:20:42 <dons> and now scheme is getting immutability and a type system. :)
00:21:27 <Tac-Tics> immutability ftw
00:21:46 <blbrown> are they putting that in the R specs
00:21:48 <ddarius> dons: That reminds me.
00:21:57 <Tac-Tics> languages with mutable string objects, in particular, scare me
00:22:58 <BMeph> Tac-Tics: Heh-heh. I was at the Univ. of Arizona when the Griswolds came up with Icon. ;)
00:23:57 <Tac-Tics> dynamic weak programming languages for the big lose
00:24:25 * Tac-Tics needs to find a job not in PHP....
00:25:44 <dons> we need more managers clued in to what they can do with some serious tools
00:26:22 <Tac-Tics> dons: what kinds of serious tools are you thinking of?
00:26:43 <dons> ghc :)
00:26:53 <Tac-Tics> of course that's what you meant =-P
00:27:20 <BMeph> Heh-heh, nice one, Cale: "What happened to "avoid success at all costs"? "
00:27:27 <Tac-Tics> Unfortunately, my boss doesn't quite understand the usefulness of testing our code before it gets released.... or giving us specs or any of that jazz
00:27:37 <dons> testing? crikey.
00:27:50 <Cale> BMeph: hehe :)
00:27:54 <Tac-Tics> I work at this small company, and my boss is a saleswoman
00:28:06 <ddarius> Tac-Tics: Exactly how does she know when you've actually met requirements?
00:28:09 <Tac-Tics> she doesn't have a fricken clue, and doesn't mind shipping shit to our dumb-as-bricks customers
00:28:28 <Tac-Tics> ddarius: if it doesn't break after 5 minutes of her fooling around with it, it's all good
00:29:01 <BMeph> Tac-Tics: You need a SalesT transformer - remind her about how happy customers are repeat customers. ;)
00:29:48 <Tac-Tics> well, she's making money, even though her only coders are two freshouttaschool 22-year-olds stuck with a pile of the world's worst software
00:30:49 <Tac-Tics> but I'm stuck their until I can find another (better) job, where at least I can lead a pointless existence using C# instead ;-)
00:31:05 <ddarius> C# > PHP
00:31:17 <Tac-Tics> It's very true
00:31:36 <int-e> > "C#" > "PHP"
00:31:39 <lambdabot>  False
00:32:04 <halides> > "PHP" > "C#"
00:32:07 <lambdabot>  True
00:32:10 * Tac-Tics has no idea how to look for a new job
00:32:24 * Tac-Tics just wants to sit around all day hacking Haskell
00:32:30 <oerjan> > "PHP" > "Haskell" -- oh noes!
00:32:32 <lambdabot>  True
00:33:19 <ddarius> Tac-Tics: Presumably then, you used a job counselor at your college to find this one?
00:34:06 <Tac-Tics> no, my school caters only to two companies, and neither of them are up by my home
00:34:20 <ddarius> Tac-Tics: Well then how did you find this job?
00:34:21 <Tac-Tics> I got lucky, and found this one on monster.com
00:35:00 * BMeph scratches monster.com off his "send resumes to these:" list
00:35:43 <Tac-Tics> but the company is so small, I have no connections anywhere else
00:36:42 <ddarius> What about friends from college?
00:36:50 <halides> well if the paycheck is decent just hang in there
00:37:05 <Tac-Tics> most of them are younger than me, but I'll ask around at the end of this year
00:37:31 <halides> sooner or later you'll find a better position
00:37:48 <Tac-Tics> halides: I got sold so short, it being my first job out of college, I had no idea what I'm worth. (but now I do, and it's more than what I'm getting)
00:37:50 <Tac-Tics> yeah
00:38:09 <Tac-Tics> web programming was surely an invention of Satan
00:38:24 <Tac-Tics> but I think he had help from Microsoft
00:38:28 <halides> when you have 5+ years of experience your off to greener pastures. i have the same problem :-)
00:39:06 <blbrown> Tac-Tics: high 5.  I have been doing some form of web development (hobby and work) for 10 years and I still think it is silly
00:41:45 <halides> i like doing stuff for the web for now. i get to touch lots of different languages and fool around with the operating system also
00:42:38 <Twey> Web programming can be interesting, but most of it's just slog work, I find
00:43:07 <Twey> I get over that boredom by finding new and interesting ways of doing it, but it's essentially still the same task.
00:43:07 <Tac-Tics> It's just frustrating, because I am smarter and more motivated than most of my peers in school, and I'm making 10 grand less than some of my lovable, but dumb-as-dirt friends
00:43:20 <Twey> Heh
00:44:12 <Tac-Tics> The thing that really gets me is how there's no "good" solutions to work work. The frameworks for web development are usually insanely complicated, and other than maybe Rails, there is no "good" way to do it
00:44:45 <Tac-Tics> and SQL pisses me off =-P
00:45:20 <Cale> http://reddit.com/r/programming/info/66qbl/comments/c030ax7 -- hehe
00:45:29 <dons> fastcgi ftw! :)
00:45:34 <ddarius> So spend your time entertaining yourself making a better infrastructure for yourself.
00:45:52 <dons> get a blog, Cale :)
00:46:13 <dons> Cale needs an audience asking questions to be motivated
00:46:14 <Cale> dons: I have one, it's called the reddit comment system.
00:46:31 <Tac-Tics> ddarius: doing it without breaking some ancient custom-hack job in the process is pretty hard
00:46:49 <Tac-Tics> Cale: lawls
00:47:48 <Cale> You think I'm kidding. http://reddit.com/r/programming/info/2wjai/comments/c2womz
00:48:03 <Tac-Tics> not at all, I know you're not, because I've seen it
00:48:13 <Cale> hehe :)
00:48:37 <dons> http://pinderkent.blogsavy.com/archives/151
00:48:38 <lambdabot> Title: It&#8217;s time for Haskell in the Web browser.
00:48:54 <dons> a good response to the question at the end "java .. it does have a good security model. What does Haskell offer in terms of a security model?
00:48:56 <ddarius> That would be sweet.
00:48:58 <dons> "
00:49:00 <kaol> foldM > sequence. It's just like a generalisation of a loop but it gives you a break statement, too.
00:49:09 <dons> would be needed.
00:49:23 <Twey> Tac-Tics: Rails is really not a "good" way to do it
00:49:38 <Twey> Tac-Tics: And that's what ORMs are for :-P
00:50:02 <Tac-Tics> Rails is cool in principal, but it does something just really grossly from what I've seen
00:50:28 <Tac-Tics> also, there's too much hype for it to be honest and true
00:50:34 <Twey> Not just "something," it does many things really grossly
00:50:46 <ddarius> dons: Wait, for "in the browser" what is java_scripts_ answer to that question?
00:50:49 <Twey> Abstracting away the client/server divide, for example.
00:51:23 <Twey> ddarius, JS is a nice language, but its security model (if you can even call it that) is messed up.
00:51:31 <Twey> Tac-Tics: Plus, it's in Ruby.
00:51:48 <Tac-Tics> JS has a security model?
00:52:53 <slarba_> forkIO's with privilege attributes would be a good start
00:53:02 <Tac-Tics> Cale Gibbard's Blog: http://reddit.com/user/cgibbard/
00:53:09 <Cale> heh
00:53:26 <dons> interesting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/value-supply-0.1
00:53:27 <lambdabot> http://tinyurl.com/2e8bpn
00:53:28 <ddarius> @where+ calesblog http://reddit.com/user/cgibbard
00:53:28 <lambdabot> Nice!
00:53:32 <Twey> Tac-Tics: It's completely non-standardised, and most features differ between browsers.
00:53:44 <Cale> The funny thing is that most of the posts are replies and don't make total sense out of context.
00:53:44 <Tac-Tics> yeah
00:54:09 <ddarius> That paper is hard to find.
00:54:09 <dons> looks like hackage is generating haddocks again
00:54:29 <Tac-Tics> Twey: the Canvas element preview on Reddit earlier today looked really kickass though
00:54:35 <Tac-Tics> doesn't work in IE yet
00:54:44 <dons> and we've new 'Built on     ghc-6.8' fields on hackage
00:55:54 <oerjan> Cale: it's a co-blog?
00:56:07 <Cale> oerjan: I could almost live with that term :)
00:56:16 <Twey> Tac-Tics, yeah
00:56:19 <BMeph> Haskel is the perfect web programming language, because its security model is based on abstract math theory that makes ECC look like concrete pouring.
00:56:19 <Cale> (I really hate the word "blog")
00:56:26 <slarba_> btw is there a library that provides Control.Concurrent.Chan functionality with erlang-style link robustness?
00:56:41 <slarba_> BMeph: umm...
00:56:42 <dons> what kind of robustness would you add to Chan?
00:56:50 <Twey> Tac-Tics: Firefox is also planning to create a 3D canvas -- basically an OpenGL context and bindings for JS
00:56:54 <dons> you want watchdog processes?
00:56:58 <Tac-Tics> oh neat!
00:57:02 <BMeph> Plus, it's made of win and awesome! ;p
00:57:08 <slarba_> dons: when the target thread dies, it would be a good idea to get notification that peer is lost
00:57:15 <dons> (the haskell approach is more to ensure the code works first time, rather than ensure it is easy to restart when it fails)
00:57:18 <Twey> Tac-Tics: Well, it would wipe the floor with Flash.
00:57:22 <dons> ok. so you'd do that with exceptions
00:57:29 <dons> threads shouldn't die though :)
00:57:47 <Tac-Tics> If only the web were designed like the from the start
00:57:54 <dons> be interesting to know of a case where you need this behaviour -- we may need new libs for watchdog processes
00:57:56 <Tac-Tics> like how java was supposed to be
00:58:13 <dons> (i.e. have threads update mvars, and have a thread watch them)
00:58:23 <Tac-Tics> with a language-agnostic client-side API, and less focus on XML and HTML
00:58:58 <Tac-Tics> and one of those language bindings would be Haskell
00:59:01 <Tac-Tics> and we would rule the world
00:59:10 <Tac-Tics> with our superior powers are parsing and reason
00:59:14 <Twey> Hehe
00:59:57 <Twey> You could actually use Haskell with Microsoft's Silverlight, I think... it has a compiler for CIL, right?
01:00:16 * Tac-Tics knows not of such tech
01:00:55 <slarba_> dons: there are certainly situations where threads have nothing else to do than to die
01:01:12 <slarba_> dons: like failed connection attempt, dns query etc...
01:01:42 <slarba_> but if exceptions work elegantly there, no prob then
01:02:32 <Twey> Tac-Tics, I don't know much about it either, except that it's an embeddable web platform designed to compete with Flash and Java, and it ties in with .NET
01:02:34 <slarba_> and... experience shows that if a program does I/O and interprets the "alien" data, there's room for error. no matter how it is programmed, if the task is nontrivial
01:03:00 <sjanssen> even disregarding exceptions, I think such a construct would be really handy
01:03:29 <slarba_> dons: are you familiar with erlang process chains and how the link breakup propagates through the process network?
01:03:30 <ddarius> I think it has proved its worth in Erlang.
01:03:44 <sjanssen> I often feel the need for "closable" Chans -- tying this to exiting threads seems natural
01:03:51 <slarba_> sjanssen: yeah
01:04:11 <slarba_> and... how about network transparent "forkIO"'s
01:04:33 <slarba_> you could pass a ThreadId to another process running on another machine, pointing to process elsewhere
01:04:34 <ddarius> Distribution should not be transparent.
01:04:43 <sjanssen> slarba_: distribution is significantly more difficult
01:04:53 <slarba_> I'm sure it is :)
01:05:19 <slarba_> just expressing wild ideas
01:06:22 <Tac-Tics> what do you mean by network transparent?
01:06:40 <Tac-Tics> as in, it's handled for you without worrying about the details?
01:06:45 <ddarius> It should be possible to implement something along the lines of Erlang's links on top of Haskell.
01:06:59 <sjanssen> ddarius: including distribution?
01:07:05 <ddarius> sjanssen: No.
01:07:15 <sjanssen> ddarius: agreed, then
01:08:09 <slarba_> gotta go, laters ->
01:11:51 * Twey shakes his head.
01:12:02 <Twey> I've been doing too much dynamically-typed programming
01:12:10 <Twey> Types are making my head spin :-\
01:12:41 * pwned dynamic_cast<SuperString>(string);
01:12:52 <Tac-Tics> > 1 < 'a'
01:12:54 <lambdabot>   add an instance declaration for (Num Char)
01:13:16 <Tac-Tics> > ['a', 1, "heterogeneousness"]
01:13:16 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
01:13:16 <dons> Cale: interesting thread in here about parallel fibonacci's and C..
01:13:33 <Cale> dons: heh :)
01:13:35 <Twey> > ('a' :: Int)
01:13:35 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
01:13:43 <Twey> Hm
01:13:50 <Twey> > ord 'a'
01:13:52 <lambdabot>  97
01:13:56 <Cale> dons: It's been slowly going on for days, in fact.
01:14:34 <Cale> dons: More generally about the benefits to optimisation of programs that higher level languages can provide.
01:17:08 <dons> ah yes, i see in the logs
01:17:31 <Tac-Tics> is there a functionality to search hpaste?
01:17:42 <ddarius> Google
01:17:57 <dons> had an interesting talk about cryptol at work the other day. it's like a dream parallel haskell
01:18:07 <Tac-Tics> I meant besides Google, but I found what I was looking for (....on Google....)
01:18:09 <dons> Tac-Tics: no, unfortunately
01:18:24 <Tac-Tics> how does hpaste do its syntax hilighting?
01:18:26 <Tac-Tics> it's very pretty
01:18:36 <Tac-Tics> with the purple and teal =-)
01:18:37 <ddarius> As long as Google is indexing the pages, I see little reason for hpaste to provide an inferior search.
01:18:57 <dons> i love bulat's historical ramblings
01:18:59 <dons> "studied at Moscow University in 89-91 and department of computer
01:18:59 <dons> languages still studied Lisp at those times (!). a few months ago i
01:18:59 <dons> have a conversation with today student and they still learn Lisp (!!!)."
01:19:26 <BMeph> Good night, all. :)
01:19:55 <dons> ?time
01:19:58 <lambdabot> Local time for dons is Sun Jan 27 01:19:55 2008
01:19:59 <dons> yeah, good idea. night all.
01:20:14 <Tac-Tics> night
01:20:18 <Twey> Heh, 'night
01:20:35 <Tac-Tics> I slept all day, so I'm still full of spirit and energy
01:21:07 <Tac-Tics> and my late nights this weekend will assure that monday will suck ever more =-)
01:21:45 <Twey> Haha
01:21:58 * Twey has nothing to get up for any more.
01:25:56 * Tac-Tics would get up early if his job let him use monads 
01:26:04 <Tac-Tics> actually, I've thought about doing that
01:26:12 <Tac-Tics> since my boss doesn't do checks at all with what we're doing
01:26:19 <Tac-Tics> I could totally write a module for our system entirely in haskell
01:27:18 <Twey> Haha, do it
01:27:40 <Twey> Or write a code generator in Haskell and have it do the work for you
01:27:43 <pwned> ten years later they will call you back to explain wtf that is.
01:27:48 <halides> yeah, i've been going there too. "do this in php!" "h'kay *fastcgi ftw*"
01:27:48 <Twey> Heheh
01:27:58 <Twey> Heh
01:28:02 <blbrown> pwned, but then haskell will be mainstream
01:28:08 <Twey> Tac-Tics, http://lukeplant.me.uk/blog.php?id=1107301645
01:28:09 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
01:28:11 <Tac-Tics> I actually tried to write a Lisp interpreter in PHP
01:28:17 <Twey> *wince*
01:28:18 <opqdonut> *shudder*
01:28:19 <Tac-Tics> but it was PHP4, and it totally fucked up
01:28:22 <blbrown> Tac-Tics, woa
01:28:29 <Twey> I think it would do the same in PHP5
01:28:32 <Tac-Tics> PHP4 = references? hah
01:28:58 <Tac-Tics> blbrown: issooootrue
01:29:07 <Tac-Tics> PHP4 was a shithole of a language
01:29:15 <Tac-Tics> and we're still partially using it at my job
01:29:17 <Twey> PHP5 still is
01:29:29 <Twey> Hah, I tried to do OOP with PHP4
01:29:33 <Tac-Tics> Language Shitholeism is a partial ordering
01:29:35 <blbrown> http://norvig.com/jscheme.html  ...dont know if he changed his code, but Norvig wrote this interpreter in java w/o creating objects, used all static code
01:29:35 <lambdabot> Title: JScheme: Scheme implemented in Java
01:29:36 <Twey> *shakes head sadly*
01:29:52 <Twey> PHP lures us in
01:29:56 <Tac-Tics> Our entire object system is OOPfrom4
01:29:58 <Twey> With its promises of OO
01:30:09 <Tac-Tics> I actually have no clue how PHP does OOP in 5
01:30:15 <blbrown> http://norvig.com/jscheme/Primitive.java
01:30:20 <Twey> And then by the time you've realised its OO is actually shit, it's too late to rewrite
01:30:23 <Tac-Tics> It's all just a hack anyway
01:30:33 <Twey> Tac-Tics, it's pretty much the same, but it does a few things better
01:30:35 <ddarius> Twey: PHP is alluring? and by promising OO no less?
01:30:43 <Twey> ddarius: It *does* promise OO!
01:30:48 <Twey> It just fails to deliver.
01:31:08 <Twey> There are whole articles on how to write OO code in PHP.
01:31:20 <Tac-Tics> "Hey look at PHP! It has new OOP in version 5! It could well be a sane language to use now! Let's check it out~"
01:31:26 <ddarius> Even if it delivered that's not all that alluring.  Even ignoring the fact that OO isn't all it was cracked up to be, you can get OO anywhere.
01:31:28 <Tac-Tics> (followed by tons of fail)
01:31:53 <ddarius> Oh, are you saying PHP5 is alluring to PHP4 developers by promising OO?
01:31:53 <Twey> ddarius, OO is pretty handy in an imperative language.
01:32:09 <Tac-Tics> I mean, we have 5k line files with not a single function declaration
01:32:18 * Twey winces.
01:32:26 <Tac-Tics> It's spaghetti code in just about the most literal sense in a language without goto
01:32:37 <Tac-Tics> an if statement would open, 500 lines later, it would close
01:32:44 <Twey> Argh
01:32:46 <Twey> Indented?
01:32:51 <Tac-Tics> between that, intersperced HTML and PHP
01:32:58 <Tac-Tics> thank god it's indented!
01:33:00 <Twey> Inconsistently, then.
01:33:08 <Twey> :-\
01:33:21 <blbrown> I always think; java is one step above objected oriented C code
01:33:35 <Twey> blbrown: Better than C++ then?
01:33:44 <Cale> abject-oriented programming
01:34:25 <Tac-Tics> Our central database table, Tickets, has over 120 fields
01:34:48 <Tac-Tics> but only 20 or so are used somewhat consistently across our system
01:35:02 <wy> Does anyone know what's a legal character in the path name of a URL?
01:35:44 <Tac-Tics> you mean, the set of legal characters?
01:36:06 <Twey> wy: Letters, numbers, '_', '-', '.'... there's never any harm in escaping though.
01:36:45 * Tac-Tics wonders who actually reads through RFCs to learn this stuff
01:36:50 <wy> but there are also ? & ... Maybe I should ask which ones are illegal
01:36:52 * Twey did, once.
01:37:32 <Twey> wy: ?, &, ;, space, %, anything outside ASCII, +, =
01:37:38 <Tac-Tics> http://www.ietf.org/rfc/rfc3986.txt has a grammar quite near the bottom
01:37:40 <Twey> #
01:38:22 <wy> but ? & are legal
01:38:34 <Twey> wy, no they aren't
01:38:42 <Tac-Tics> reverved chars appear to be    :/?#[]@!$&'()*+,;= at the very least
01:38:45 <Twey> wy: ? denotes the start of the query parameters
01:38:57 <Twey> wy: & seperates them (; too)
01:39:19 <ddarius> Tac-Tics: I always do when I wonder such thing.s
01:39:29 <wy> I didn't mean that. I mean... what's a legal char after the (DNS|IP):PORT part
01:39:41 <Vq^> Twey: is that really URL specific?
01:40:12 <Vq^> Twey: isn't that just how it's usually used with HTTP?
01:40:56 <Twey> Vq^, no, those characters are always reserved for that usage, even if the specific URI scheme doesn't implement them (IIRC)
01:42:27 <Vq^> Twey: yeah, they are always reserved, but it doesn't matter if you use & for showing the start of the parameters and @ to separate them, right?
01:43:23 <Twey> Vq^, semantically, yes
01:43:37 <wy> If the name contains query, is it a URL any more?
01:43:52 <Vq^> wy: sure
01:44:26 <wy> Must queries be after pathname?
01:44:36 <Twey> "The query component is indicated by the first question mark ("?") character and terminated by a number sign ("#") character or by the end of the URI."
01:44:44 <Twey> Section 3.4
01:44:50 <Twey> wy, yes
01:45:25 <wy> got it. thanks. enough to finish the homework ;-)
01:45:40 <Twey> Haha
01:45:52 <ddarius> Read the frickin' RFC.  They aren't long.
01:45:58 <Twey> Aye
01:46:09 <Twey> 60 pages
01:46:57 <Tac-Tics> 3K isn't that long? Depends on the scope of what you're doing
01:47:11 <Tac-Tics> If it's a lame homework assignment or a single-day project, it's probably not worth it
01:50:11 * Tac-Tics learns that using :force on large lists of words is painful to GHCi
01:50:31 <Cale> "For the purposes of this assignment, I assume that a URI is a sequence of zero or more alphabetic characters. By the way, you can visit my new website at httpcolonslashslashwwwdotridiculoushyphenassumptionsdotorg."
01:52:09 <Tac-Tics> I think I pissed off the debugger. It's not respecting my breakpoints any more
01:54:33 <Cale> "Screw him and his stupid breakpoints. I ain't waitin' around here all microsecond. Doesn't he know I have expressions to reduce?"
01:55:08 <Tac-Tics> I don't know where you're getting these quotes, Cale, but keep'em coming
01:55:23 <Cale> Off the top of my head.
01:56:11 <Tac-Tics> the haskell debugger is a little hard to use, I'm noticing
01:56:30 <Tac-Tics> but I'm sure it's a godsend once you know how to use it
01:56:40 <vincenz> Cale: whre does ths come from?
01:58:17 <Tac-Tics> it'd be nice to see which expression it's currently evaluating as you step through it w/o having to type :list every time, but you'd need to find a nice way to handle really long (and usually monadic) expressions so it doesn't flood the user's window
01:58:18 <Cale> The Hush Sound is an indie quartet originating in Chicago, Illinois.
02:00:40 <Cale> Mostly it just coms from "time to go to bed".
02:00:56 <Tac-Tics> what's the fun in that?
02:03:03 <ddarius> Tac-Tics: I'm not sure anyone has used it enough to know.
02:04:15 <Tac-Tics> the only real hard to find errors I've gotten before are when I screw up with a letrec
02:22:54 <bRoseph_Stalin> can you guys help http://en.naughtyholiday.com/?id=ccd96c2a9da025e729843fc43b9bfec8
02:22:55 <lambdabot> Title: GEILER URLAUB mit FICKPARTY
02:23:39 <benny> only if I combine this with my v1agr4 spam
02:28:35 --- mode: ChanServ set +o vincenz
02:28:41 <ddarius> Mark Twain (as always) is excellent
02:28:46 --- mode: vincenz set -o vincenz
02:37:53 <DanHerg> Cool Dating Club site ===> new-datingclub.eu
02:38:18 --- mode: ChanServ set +o vincenz
02:38:22 --- kick: DanHerg was kicked by vincenz (vincenz)
02:38:32 <vincenz> DanHerg: Please leave
02:38:39 <DanHerg> ok!
02:39:21 --- mode: vincenz set -o vincenz
02:39:21 <Twey> Heh
02:39:33 <TNorthover> Quick reactions.
02:39:40 <Tac-Tics> what is with the spam today?
02:40:06 <Twey> I assumed it was common
02:40:16 <Twey> I've been seeing it since I joined here
02:40:26 <Tac-Tics> really? I guess I must not stay up late enough?
02:40:43 <Twey> @localtime Tac-Tics
02:40:48 <Twey> Dang.
02:41:01 <Tac-Tics> Oh yeah, well watch this
02:41:05 <Tac-Tics> @localtime Twey
02:41:06 <lambdabot> Local time for Twey is Sun Jan 27 10:47:10 2008
02:41:20 <Tac-Tics> where are you located Twey?
02:41:23 <TNorthover> Snap.
02:41:32 <TNorthover> (well, bar I amke it 10:41)
02:41:44 <Twey> Tac-Tics, England
02:41:55 <Tac-Tics> ah
02:42:03 <Twey> TNorthover, your clock is slow
02:42:08 <Twey> It's :47 :-)
02:42:16 <Tac-Tics> yeah, considering Haskell's popularity in England, I'm surprised it's always so busy during the day here in Americaville
02:42:27 <Twey> Haskell's popular here?
02:42:30 <Twey> :-\
02:43:06 * Twey never knew this.
02:43:23 <Tac-Tics> I thought it was
02:43:46 <Tac-Tics> Maybe I just thought that because I've seen so many videos of SPJ with his british accent
02:44:33 <Tac-Tics> yeah, he worked in England, so that counts as making it popular there =-P
02:46:29 <ddarius> It is pretty popular in the UK.
02:49:10 <Twey> Haha
02:49:17 <Twey> Hm, OK.
02:50:58 * Tac-Tics has stayed up so late he's hungry for breakfast
02:51:20 <Twey> Heh
02:52:45 <pejo> Tac-Tics, you have Galois, Portland State university and Yale in the US though, and lots of smaller places.
02:52:48 <jonaskoelker> quickie question for a haskell n00b: I have a list of strings; how do I print each string on a line by itself?
02:53:02 <ddarius> mapM_ putStrLn
02:53:03 <Zao> :t mapM_
02:53:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:53:31 <jonaskoelker> ty
02:53:57 <Tac-Tics> pejo: I'm nowhere near either of those =-)
02:54:24 <blbrown> :t average
02:54:25 <lambdabot> Not in scope: `average'
02:54:30 <blbrown> :t avg
02:54:31 <lambdabot> Not in scope: `avg'
02:54:39 <blbrown> :t mean
02:54:39 <lambdabot> Not in scope: `mean'
02:56:02 <Tac-Tics> haskell's number system is really confusing
02:56:36 <Tac-Tics> avg should be as easy as avg xs = sum xs / length xs, but it's not
02:56:54 <blbrown> great, that is what I was thinking; if you have sum and minimum, why no avg
02:57:44 <ddarius> :t sum ?xs / length ?xs
02:57:44 <lambdabot>     No instance for (Fractional Int)
02:57:44 <lambdabot>       arising from use of `/' at <interactive>:1:0-19
02:57:44 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
02:58:12 <ddarius> :t (/)
02:58:12 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:58:22 <qebab> :t sum ?xs `div` length ?xs
02:58:23 <lambdabot> (?xs::[Int]) => Int
02:58:24 <qebab> :x
02:58:27 <qebab> oh
02:58:36 <Tac-Tics> div's gonna truncate
02:58:40 <qebab> yeah
02:59:01 <ddarius> So Int isn't Fractional (obviously) and you need to pass in a Fractional to (/), so convert an Int to a Fractional type.
02:59:02 <Tac-Tics> what you need to do is convert the sum and the length to floating point numbers.... of some kind... I think.... somehow
02:59:13 <Zao> :t \x -> (foldr1 (+) x) / (fromIntegral $ length x)
02:59:14 <lambdabot> forall b. (Fractional b) => [b] -> b
02:59:15 <ddarius> There is a generic conversion function for all integral types.
02:59:24 <ddarius> :t fromIntegral
02:59:25 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:59:36 <ddarius> So avg xs = sum xs / fromIntegral (length xs)
02:59:42 <ddarius> In fact,
02:59:49 <ddarius> :t sum ?xs / genericLength ?xs
02:59:50 <lambdabot> forall a. (Fractional a, ?xs::[a]) => a
02:59:55 <Tac-Tics> @let avg xs = sum xs / fromIntegral (length xs)
02:59:58 <lambdabot> Defined.
03:00:03 <Tac-Tics> > avg [1..100]
03:00:06 <lambdabot>  50.5
03:00:10 <blbrown> hehe
03:00:16 <Tac-Tics> sounds right to me =-)
03:00:16 <jonaskoelker> nice bot :)
03:00:20 <blbrown> hehe
03:00:21 <Tac-Tics> > avg [0..100]
03:00:22 <lambdabot>  50.0
03:00:46 <jonaskoelker> anyone ever said something about applying system to rm -rf /? ;)
03:00:47 <blbrown> avg [0, 100.1]
03:00:57 <blbrown> > avg [0, 100.1]
03:00:58 <lambdabot>  50.05
03:02:15 <ddarius> > system "rm -rf /"
03:02:15 <lambdabot>   Not in scope: `system'
03:03:35 <Tac-Tics> > print
03:03:36 <lambdabot>  <Integer -> IO ()>
03:03:43 <Tac-Tics> > print "Death to all humans"
03:03:43 <lambdabot>  <IO ()>
03:03:58 <Tac-Tics> (why did it default to integer... weird choice)
03:05:18 <ddarius> Tac-Tics: There's a ridiculous ad-hoc system called defaulting that leads to it doing exactly that.
03:05:25 <ddarius> The default default is Integer.
03:05:39 <Tac-Tics> I actually just read about it in the ghc docs
03:06:27 <slarba_> heh... Haskell Avenue
03:06:37 <slarba_> that was in L.A. I got amused
03:06:49 <ddarius> I live not far from Haskell, TX.
03:06:58 <slarba_> :)
03:08:22 <blbrown> ddarius, you in dallas?
03:09:21 <Tac-Tics> what's an "unboxed tuple"?
03:09:35 <ddarius> blbrown: No.
03:10:09 <Tac-Tics> is that where fst (x, _|_) == _|_?
03:11:35 <sjanssen> Tac-Tics: no
03:12:24 <sjanssen> there's a special calling convention when they're used as function arguments, or something
03:12:48 <sjanssen> @kind (# , #)
03:12:49 <lambdabot> parse error on input `,'
03:13:03 <Tac-Tics> technical ffi type stuff?
03:13:31 <sjanssen> technical yes, ffi no
03:13:43 <sjanssen> technical GHC internals stuff
03:13:47 <Tac-Tics> good enough for me to hold off trying to grok it then =-)
03:14:05 <ddarius> Tac-Tics: You don't really need to know about them for most purposes.
03:14:24 <Tac-Tics> ddarius: I think most interesting things in life are like that
03:17:24 <Tac-Tics> 5am- it's time to go to bed
03:17:27 <Tac-Tics> night all
03:21:58 <therp> just an idea that came up this morning reading a script about type systems, assuming that types are propositions about the semantic behaviour of programs (in that 'expression foo returns a result of type bar'), also assuming that these proposition could be generalized to expression in first-order logic maybe in hoore calculus style, also assuming that we could generalize type inference to infer these most general assumptions, woul
03:21:59 <therp> dn't it be possible to solve the semantic equivalence problem on functions quite efficiently? comparing the pre/post conditions of functions. this would make bubble sort equal to quicksort maybe
03:24:20 <therp> (except that comparing equational statements -- aka the word problem -- isn't in general decidable)
03:32:43 <DanHerg> Cool Dating Club site ===> new-datingclub eu
03:34:14 <czakey> DanHerg: someone already told you to leave us...
03:34:16 <Zao> Short attention span on that one, I say.
03:34:53 <DanHerg> Cool Dating Club site ===> new-datingclub eu
03:46:27 <cnwdup> Hey. My program has to watch to descriptors (stdin and if X has sent an event), but I don't want to fork a new thread for that. In C I would use select() I guess. Is there a good way to do the same in Haskell? I only find solutions that invoke a new thread.
03:46:39 <cnwdup> *two descriptors
03:47:36 <Lemmih> cnwdup: Threads are very cheap in Haskell.
03:47:49 <EvilTerran> cnwdup, well, haskell's "threads" are managed by ghc, not by the os, so they're very fast
03:48:11 <cnwdup> Okay. I didn't knew that. Seems I have to get used to the idea using a thread.
03:49:04 <sjanssen> cnwdup: be very careful with X and threads
03:49:37 <cnwdup> sjanssen: I was about to copy your solution from the haskell Wiki. O: What should I be aware of using threads and X?
03:50:06 <sjanssen> cnwdup: which solution?
03:50:16 <cnwdup> http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell#A_new_nextEvent_with_asynchronous_exceptions
03:50:19 <sjanssen> cnwdup: I don't have any specific advice -- just be careful :)
03:50:21 <lambdabot> Title: X window programming in Haskell - HaskellWiki, http://tinyurl.com/2bpml8
03:50:48 <sjanssen> cnwdup: try to do all the X calls from one thread only
03:51:18 <cnwdup> sjanssen: Ok. I'll try.
03:51:47 <cnwdup> Is there a way to check if I there's data available to be read from stdin?
03:52:35 <sjanssen> the usual strategy is to just request what you need and let it block
03:53:32 <cnwdup> Well, I would like to block the main program with getLine but I want to interupt it if a certain X event is received.
03:53:53 <cnwdup> But as I handle those interupts with catch, I can't block the main program, can I?
03:54:41 <sjanssen> what is it you want to do?  Maybe we can come up with a nice factoring into threads
03:55:34 <cnwdup> Ok. I have a program that watches stdin and just prints what it gets from there to an X window. But off course I have to react to events such as "redraw your window" from the X server and those should have higher priority.
03:56:02 <sjanssen> dzen in Haskell, essentially
03:56:09 <sjanssen> cnwdup: you do know about xmobar, right?
03:56:18 <cnwdup> Yep, I am about to write a dzen clone just for the learning process.
03:56:24 <cnwdup> I heard of it.
03:56:35 <EvilTerran> seems to me one thread waiting on an MVar while one other blocks for each event, with the first to get an event pushing a value into the MVar
03:56:48 <EvilTerran> would work. dunno, tho, i'm not that familiar with threads/blocking/mess/etc
03:57:37 <EvilTerran> actually, never mind that, that's an ugly hack of a solution
03:57:55 <sjanssen> cnwdup: so I'd suggest the reverse of what you were planning
03:58:00 <jedbrown> I think an MVar (Either String XEvent) would work fine.
03:58:14 <EvilTerran> are you sure it's getting input on stdin? i'd've thought it'd've got input in the form of X events
03:58:35 <EvilTerran> if you mean keyboard input
03:58:37 <sjanssen> jedbrown: it is a bit more complicated, because you can't poll for XEvents at the same time you're redrawing the window
03:58:39 <cnwdup> No. It gets input from stdin.
03:59:10 <EvilTerran> weird. okay. i clearly don't know what you're trying to do here, so i'll let you get on with it
03:59:22 <jedbrown> sjanssen: Ah, but you can pass the ready-to-poll back in another MVar.
03:59:25 <sjanssen> cnwdup: so have one thread that continuously reads from stdin, writes the new text to a shared variable, then sends an exception to the X thread
03:59:57 <cnwdup> sjanssen: And with an exception I can interupt the X event polling?
04:00:10 <jedbrown> sjanssen: Oh, that's nicer.
04:00:21 <sjanssen> cnwdup: right (assuming you use the modified XNextEvent from the wiki page)
04:00:31 <cnwdup> sjanssen: That seems nice. Thanks. (-:
04:00:56 <sjanssen> cnwdup: so when nextEvent either terminates normally, or an exception is received, redraw the window and loop
04:01:13 <sjanssen> jedbrown: I've written this particular event loop before :)
04:01:15 <cnwdup> sjanssen: Ok. (-:
04:02:13 <cnwdup> xmobar seems pretty nice, btw. Don't remember why I've used dzen over it.
04:02:50 <sjanssen> dzen has fancier rendering options, but xmobar has a nice plugin system
04:03:12 <cnwdup> Does xmobar support xft fonts?
04:03:18 <sjanssen> and it can handle multiple asynchronous event sources out of the box
04:03:20 <sjanssen> no, it doesn't
04:03:32 <cnwdup> That's a pitty. Both (dzen and xmobar) don't.
04:03:51 <sjanssen> there is a dzen branch that does
04:04:06 <sjanssen> and xft patches for xmobar would certainly be welcome
04:04:10 <cnwdup> sjanssen: I know. But the last time I checked it, it wasn't finished and unusable.
04:04:39 <cnwdup> sjanssen: Mh, maybe I look into that. Using xft for font drawing isn't hard to implement. At least I was able to do so in my dzen clone.
04:06:15 <cnwdup> But I am somehow confused by code of advanced projects as I am really new to haskell. Think I have to do much more learning before. (-:
04:48:14 <larmeh> hi there
04:49:40 <byorgey> hi larmeh
04:50:09 <RayNbow> good "morning", #haskell :)
04:50:23 * RayNbow woke up at 1:40 PM :X
04:51:09 <hpaste>  larmeh pasted "entering "empty" in ghci produces the error "No instance for (Show (Dictionary a -> Dictionary a))"." at http://hpaste.org/5260
04:52:52 <RayNbow> larmeh, Dictionary a -> Dictionary a is a function
04:52:54 <therp> larmeh: because that's a function, functions can be printed
04:53:00 <therp> s/can/can't/
04:53:01 <byorgey> "good" "morning", "RayNbow" =)
04:54:02 <RayNbow> :)
04:54:20 <RayNbow> http://reddit.com/r/programming/info/66qsu/comments/ "What language do you recommend for building scanners and parsers? (programming)"
04:54:20 <larmeh> therp: but how can i print the empty list resulting from "Dictionary []"?
04:55:43 <dcoutts_> byorgey: thanks :-)
04:56:04 * RayNbow read a part of chapter 5 (Lambda Calculus) of Types and Programming Languages (B. Pierce) last night in bed...
04:56:16 <RayNbow> I was amazed I understood the Church numerals
04:56:28 <EvilTerran> TaPL is a great book :)
04:56:32 <doserj> larmeh: why did you define empty as a function?
04:56:36 <mux> TAPL++
04:56:37 <RayNbow> I have read Lambda calculus papers/tutorials before...
04:56:42 <EvilTerran> @karma tapl
04:56:42 <lambdabot> tapl has a karma of 1
04:56:43 <RayNbow> but suddenly I saw the light
04:56:50 <RayNbow> TAPL++
04:57:00 <byorgey> dcoutts_: for what?
04:57:54 <larmeh> doserj: because i need to have a function returning an empty dictionary...
04:58:39 <byorgey> TAPL++
04:59:01 <doserj> larmeh: what's wrong with "empty = Dictionary []"?
05:00:53 <byorgey> dcoutts_: well, whatever you're thanking me for in particular, you're welcome =)
05:01:14 <byorgey> dcoutts_: I also have a question for you if you've got a minute
05:01:24 <larmeh> doserj: probably nothing but its explicitly said that "empty" must be a function with the signature "empty :: Dictionary a -> Dictionary a"
05:03:03 <doserj> well, then you have to apply empty to something, in order to get something. like "empty undefined".
05:05:28 <anX> ZOMG im on teh #haskell
05:05:41 <anX> u ppls have like phds
05:05:42 <anX> omg
05:06:16 <therp> larmeh: btw "empty = const (Dictionary [])", but I doubt that you really need such a function
05:06:36 <therp> larmeh: this also gives you a function with a more general type than the one you specified
05:07:59 <roconnor> What is the theorem that says that every sequence in a compact set has a convergent subsequence.
05:08:03 <roconnor> er ?
05:08:14 <dcoutts_> byorgey: yes?
05:08:28 <dcoutts_> byorgey: I was thanking you for the cabal patches of course :-)
05:08:33 <larmeh> therp: hm but that function wouldnt have the signature "empty :: Dictionary a -> Dictionary a", right?
05:08:44 <byorgey> dcoutts_: oh, ok =)
05:09:02 <therp> larmeh: no, "a -> Dictionary b"
05:09:07 <byorgey> dcoutts_: near the sanity-checking code, there's a comment that says "-- FIX: add a sanity check for missing haskell files? that's why it's in the IO monad"
05:09:21 <dcoutts_> byorgey: ah yes
05:09:32 <byorgey> dcoutts_: am I correct in interpreting this to mean checking for files corresponding to exposed-modules?
05:09:38 <byorgey> dcoutts_: or is it something else?
05:09:53 <byorgey> dcoutts_: whatever it means it should be easy enough for me to add.
05:09:58 <larmeh> doserj: typing "empty undefined" results in a type error in ghci
05:10:00 <dcoutts_> byorgey: I think that's probably what it means, however it's not at all trivial when one considers preprocessors
05:10:07 <byorgey> aha
05:10:16 <byorgey> dcoutts_: I wondered if there was a catch.
05:10:36 <dcoutts_> byorgey: I've got an alternative one that's probably more useful...
05:10:38 <byorgey> dcoutts_: right, I see, those files might get generated after the configure stage.
05:10:54 <dcoutts_> byorgey: during build, we only run pre-processors during the build
05:11:05 <byorgey> dcoutts_: right, ok.
05:11:12 <byorgey> dcoutts_: ok, what's the alternative?
05:11:32 <dcoutts_> byorgey: so, you see the goodCabal test, to check if the package specifies a version of cabal corresponding to our own version
05:11:47 <byorgey> dcoutts_: right
05:12:07 <dcoutts_> byorgey: that check does not work very well because by the time we get round to it, we've probably already failed with a parse error :-)
05:12:09 <doserj> larmeh: it doesn't give a type error. but the pattern matching makes empty too strict.
05:12:18 <byorgey> dcoutts_: hehe =)
05:12:32 <dcoutts_> byorgey: eg consider a new minor version of cabal that introduces more named language extensions
05:12:46 <doserj> larmeh: empty _ = (Dictionary []) should work
05:12:49 <byorgey> dcoutts_: right, I follow.
05:13:13 <dcoutts_> byorgey: a package that uses them will not even parse with an old version, and even if it says cabal-version: > 1.2.4 that gets checked too late to give a sensible error message
05:13:31 <byorgey> dcoutts_: right.
05:13:40 <dcoutts_> byorgey: fortunately, we do use a two-level parser, we do the outline structure, then apply parsers to each of the named fields
05:13:48 <larmeh> doserj: a friend of mine just told it was ok to user "empty = Dictionary []"... thanks for your help
05:13:55 <larmeh> s/user/use/
05:13:57 <jedbrown> roconnor: I don't believe that has a standard name.  It is just sequential compactness implies compactness (this proof is straightforward).  The converse is true in a metric space.
05:14:01 <dcoutts_> byorgey: so there is the opportunity to do the check before parsing all the other fields
05:14:13 <byorgey> dcoutts_: oh, right.  I see.
05:14:42 <dcoutts_> byorgey: a closely related one, would be
05:14:42 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/210
05:14:43 <lambdabot> Title: #210 (Enable access to the x- extension fields, as simple [(String, String)] nam ...
05:14:45 <jedbrown> roconnor: Rather compactness => seq. compact.  (equivalent in a metric space).
05:15:35 <byorgey> dcoutts_: so 'parsePackageDescription' does both parse stages?  or just one of them?
05:15:49 <dcoutts_> byorgey: it does both
05:15:54 <byorgey> dcoutts_: ok, that's what I thought.
05:16:09 <LordMetroid> Wow, this network's #haskell is far superior to EFNet's!
05:16:17 <roconnor> jedbrown: how do I prove compactness => seq. compactness?
05:16:27 <dcoutts_> byorgey: readFields is the first parse
05:16:29 <byorgey> oh, I see, yes.  'readFields' is the first phase, and then there's a separate 'parseFields'.
05:17:18 <byorgey> dcoutts_: ok, I'm on it.  Although I probably won't have time to work on it until tomorrow.
05:17:27 <dcoutts_> byorgey: right
05:17:31 <dcoutts_> byorgey: np :-)
05:18:24 <dcoutts_> byorgey: the x- extensions field one would involve extending the PackageDescription data type with the extra [(String, String)]
05:19:01 <byorgey> dcoutts_: makes sense.  and then making sure they get parsed and populated into that structure, right?
05:19:07 <dcoutts_> byorgey: right
05:19:27 <dcoutts_> parsed as free form fields, like copyright etc
05:19:36 <dcoutts_> @seen bos
05:19:36 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 13h 56m 35s ago.
05:19:58 <byorgey> dcoutts_: right.  and they must start with "x-" ?  or should any unrecognized fields be shoved in there?
05:20:22 <dcoutts_> byorgey: you'll find we warn on unrecognised fields and ignore x-prefixed fields
05:20:35 <byorgey> dcoutts_: ok, yeah, that makes more sense.
05:20:52 <dcoutts_> so we now want to collect the x- fields rather than ignoring them
05:21:00 <dcoutts_> @tell bos bytestringparser-0.2.2's haddock docs do not build :-(
05:21:00 <lambdabot> Consider it noted.
05:21:06 <byorgey> dcoutts_: got it.
05:22:05 <byorgey> dcoutts_: is there a ticket for the version-checking thing?
05:22:23 <dcoutts_> byorgey: no, feel free to file one and assign it
05:22:30 <byorgey> dcoutts_: ok.
05:23:06 <jedbrown> roconnor: I'm sorry.  That's not actually true.  You need to be in a first-countable space.  Then compact => countably compact <==> sequentially compact.
05:26:10 <roconnor> jedbrown: rumour has it you don't need separability to get from compact to sequentially compact.
05:26:57 <roconnor> not that I have found a proof of compact ==> seq. compact on planet math yet.
05:27:52 <jedbrown> roconnor: That's because it's not true.  It does need to be first countable.
05:28:36 <roconnor> oh I see
05:28:48 <roconnor> seq. compact ==> compact doesn't need separability.
05:28:53 <roconnor> crap!
05:29:37 <roconnor> no wait
05:29:42 <roconnor> http://planetmath.org/?op=getmsg&id=1344
05:29:43 <lambdabot> Title: PlanetMath:
05:29:46 <roconnor> is what I'm reading
05:30:16 <roconnor> So the assumption that $X$ is separable is not necessarily to show that sequential compactness implies compactness.
05:30:27 <roconnor> then he says ``The proof that compactness implies sequential compactness does not use separability.
05:30:36 <roconnor> which I now think is a mistake on his part.
05:30:58 * jedbrown pulls Munkres off the shelf.
05:31:04 <roconnor> :)
05:31:23 <roconnor> *sigh*
05:32:30 <roconnor> this is all more complicated than I had realized.
05:34:12 <jedbrown> roconnor: Yeah, he's not using separability, but he is using first-countability.  The general method would be to let {B_n} to be a (countable) neighborhood base at x.
05:34:28 <roconnor> :/
05:34:31 <roconnor> okay
05:35:05 <jedbrown> Theorem 28.1 shows that compactness => limit point compactness (in general).
05:35:15 <roconnor> My brain is melting.
05:35:32 <roconnor> The problem is that I've sort of made up my own definition of compact
05:35:38 <roconnor> and I'm using constructive logic.
05:36:05 <roconnor> I'm trying to come up with a version of the image of a compact set under a continuous function is compact.
05:36:28 * RayNbow mounts a Liquid Nitrogen Cooling System on roconnor's brain
05:36:40 <roconnor> ahhhh
05:37:49 <jedbrown> What exactly are you trying to show?
05:38:29 <roconnor> jedbrown: It starts with my definition of compact.
05:39:04 <roconnor> I define a compact set to be roughly a cauchy sequence of finite sets under the Hausdorff metric.
05:39:39 <roconnor> where the finite sets are drawn from a complete metric space.
05:40:24 <roconnor> then the image of a compact set under a continuous function just maps the function over all the finite sets in the cauchy sequence.
05:40:41 <roconnor> and the result is a cauchy sequence, hence the result is a compact set.
05:40:46 <roconnor> so that is good.
05:41:32 <roconnor> but now I want to show that y in f"S imples that there is some x such that y = f(x) and x in S.
05:42:53 <roconnor> x in S mean that forall e, exists N , forall n > N, exist x0 in S(n) | x - x0 | < e.
05:43:31 <roconnor> ie x gets arbirarily close to points in the tail of S.
05:46:22 <roconnor> So the obvious way to proceed would be to look at all the points that y is close to.
05:46:43 <roconnor> those points come from some collection of x0 ...
05:46:55 <roconnor> and then find a convergent sequence from that collection.
05:47:05 <roconnor> then the limit would be such an x.
05:47:14 <roconnor> but that requires me to find a convergent subsequence.
05:47:25 <roconnor> and so here I am.
05:48:23 <jedbrown> Why not redefine S_n to be (union_1^n S_k).  Then your definition is B(x,e) intersects S_n for sufficiently large n.
05:49:26 <roconnor> jedbrown: it is somewhat important for me to allow points to be in the cauchy sequence that don't end up in the final compact set.
05:49:48 <jedbrown> Why?
05:50:05 <roconnor> jedbrown: this is because I want to be able to restrict the cauchy sequence to say, rational numbers, or points on a raster.
05:50:24 <roconnor> jedbrown: because ultimately I am going to draw these rasters on the screen.
05:50:47 <roconnor> (at this point this discussion starts becoming somewhat relevent to Haskell)
05:51:20 <jedbrown> That seems different.  You want the compact set to not include the rational or something?
05:51:35 <roconnor> so a cauchy sequence of finite sets of rational coordinates can represent any compact set in R^2, for example.
05:52:05 <roconnor> and then use user can draw the compact set on the screen at any resolution.
05:52:11 <jedbrown> Why is that a problem.  The rationals are dense in R^2.
05:52:46 <jedbrown> Why can't all the points in the sets of the Cauchy sequence be in the "compact set"?
05:52:47 <roconnor> But if the compact set has no rational points in it, then then no point in the cauchy sequence will ever belong to the compact set.
05:53:28 <roconnor> but we can still draw approximations to such a compact set.
05:53:40 <jedbrown> Oh, I see.  You care about the discrete case.
05:53:54 <roconnor> right; cause computers are discrete.
05:55:21 <roconnor> what's the difference between sepearable and first countable?
05:56:12 <hpaste>  larmeh pasted "Line 16: Couldn't match expected type `Maybe a' against inferred type `a' (a rigid variable)" at http://hpaste.org/5261
05:56:33 <larmeh> i'm sorry i have to bother you again
05:56:47 <larmeh> but this error really seems strange to me
05:58:05 <jedbrown> I beleive your set S = { x | x is a limit point of (union S_n)}
05:58:22 <wolverian> do you really mean 'snd snd h'?
05:58:43 <jedbrown> Separable meens that the space has a countable dense subset.  First countable means that every point has a countable neighborhood base.
05:59:07 <jedbrown> roconnor: Combined, it is the definition of second countable.
05:59:15 <larmeh> wolverian: well its the second part of the secondn tuple, isnt it?
05:59:30 <larmeh> s/secondn/second/
05:59:32 <tuukkah> larmeh, you see you've defined the Trie to take a Maybe a
05:59:59 <roconnor> jedbrown: that seems to be the correct interpretation of my compact set.
06:00:42 <roconnor> jedbrown: first countable means that every point is the intersection of a countable number of open sets?
06:00:45 <tuukkah> larmeh, and on the error line you give it an a which is of type a
06:01:27 <larmeh> tuukkah: yes, but how can i make `a' a `Maybe a'?
06:01:42 <doserj> @djinn a -> Maybe a
06:01:43 <lambdabot> f = Just
06:02:05 <wolverian> @type snd snd
06:02:07 <lambdabot>     Couldn't match expected type `(a, b)'
06:02:07 <lambdabot>            against inferred type `(a1, b1) -> b1'
06:02:07 <lambdabot>     In the first argument of `snd', namely `snd'
06:02:09 <int-e> @pl Just
06:02:09 <lambdabot> Just
06:02:23 <wolverian> larmeh, you're passing to snd the arguments snd and h
06:02:26 <int-e> (I half expected the result to be 'return')
06:02:28 <jedbrown> roconnor: Normally it is stated that for every x, there is {B_n} such that every open set A which contains x also contains some B_n.
06:03:11 <roconnor> jedbrown: this seems true for every metric space.
06:03:32 <jedbrown> roconnor: Yes, but metric spaces are stronger.
06:03:46 <roconnor> jedbrown: I'm in a metric space \o/
06:05:04 <roconnor> jedbrown: that means I can find my converget subsequence.
06:05:18 <larmeh> wolverian: so should i write "snd (snd h)" instead?
06:05:36 <jedbrown> roconnor: Then that part was easy.  The converse (seq. compactness => compactness) requires separability too, I believe.
06:05:55 <roconnor> I don't think I need that direction :)
06:06:04 <wolverian> larmeh, yes
06:06:29 <wolverian> larmeh, or snd $ snd h, or (snd . snd) h :)
06:06:40 <roconnor> jedbrown: I still don't see how to prove seq. compactness from compatness (in a metric space).
06:07:11 <roconnor> roconnor: all the proofs I recall are in R^n
06:07:15 <roconnor> er
06:07:16 <jedbrown> roconnor: Are you familiar with limit point compactness?
06:07:29 <larmeh> hm, but i still dont understand how `a' to be of type `Maybe a'...
06:07:30 <roconnor> jedbrown: not relly.
06:07:54 <larmeh> *how i get
06:08:06 <scook0> @type Just
06:08:07 <lambdabot> forall a. a -> Maybe a
06:08:16 <scook0> is that what you're after?
06:08:17 <jedbrown> roconnor: A space X is limit point compact if every infinite set has a limit point.
06:08:34 <roconnor> right.
06:08:36 <wolverian> larmeh, you have to construct a Maybe type. Just does this.
06:08:54 <wolverian> larmeh, (consider: data Maybe = Just a | Nothing.)
06:09:21 <roconnor> jedbrown: sounds very similar to seq. compact.
06:10:13 <jedbrown> roconnor: Similar.  Hang on and I'll prove the first bit.
06:11:26 <jedbrown> roconnor: Suppose A is a subset of X and has no limit point.  Then A contains all its limit points, so A is closed.  If a <- A then a has a neighborhood U_a such that {a} = (U_a intersect a).
06:13:19 <jedbrown> roconnor: The space X is covered by the open set (X \ A) and the open sets {U_a | a <- A}.  It can be covered by finitely many of these.  But they are all needed in order to cover X, so A must be finit.
06:13:58 <roconnor> thanks
06:14:33 <jedbrown> roconnor: (That was the contrapositive.)  So now we can show that limit point compact => sequentially compact (in a metric space).
06:15:02 <roconnor> I expect lp compact -> seq. compact to be easier :)
06:15:45 <jedbrown> roconnor: Let {x_n} be a sequence in the compact space X.  Then it has a limit point x.  Let B_n = B(x,1/n).
06:20:00 <roconnor> jedbrown: thanks for your help.  A source of confusion for me is that I thought seq. compact required a metric space to be defined.
06:20:21 <jedbrown> roconnor: Now we define a subsequence converging to x.  First choose x_{n_1} in B_1.  Now, given n_{i-1}, choose n_i > n_{i-1} so that x_{n_i} <- B_n.  This is possible because there are infinitely many {x_n} inside B_n.
06:20:24 <roconnor> jedbrown: but now I can see that limits only require open sets to be defined.
06:20:51 <jedbrown> roconnor: Glad to help.
06:23:20 <jedbrown> roconnor: What are you studying, by the way?
06:25:50 <roconnor> jedbrown: I'm doing constructive mathematics / functional programming PhD in the Netherlands.
06:26:33 <roconnor> jedbrown: I'm working on turning my work on compact sets into a low-resolution ``graphing calculator'' for Coq.
06:26:44 <roconnor> provably correct, of course.
06:28:30 <jedbrown> roconnor: Interesting.  Analysis doesn't get very far without AoC, so I'm fairly ignorant of constructive math.
06:28:35 <RayNbow> roconnor: how's the cold Netherlands? :)
06:29:20 <roconnor> RayNbow: much warmer than in Winnipeg.
06:29:56 <jethr0> finalizerPtr: "Indeed, there is no guarantee that the finalizer is executed at all; a program may exit with finalizers outstanding."
06:29:59 <roconnor> jedbrown: :) By constructive math I mean math ``without proof by contradiction''.
06:30:01 <jethr0> how unhelpful is that?
06:30:31 <RayNbow> roconnor: at which university you're doing that PhD btw?
06:30:45 <roconnor> RayNbow: Radboud University in Nijmegen.
06:30:55 <RayNbow> ah, the Clean university
06:31:02 <roconnor> RayNbow: formally Katholic University Nijmegen.
06:31:13 <roconnor> RayNbow: right, but I've never used Clean.
06:31:17 <jedbrown> roconnor: That's quite a strong restriction.  Although constructive proofs are often more practically useful.
06:31:19 <RayNbow> me neither
06:31:59 <roconnor> jedbrown: constructive proof allow me to actually compute images that approximate (constructively) compact sets.
06:32:01 <phobes> Can you do non-constructive proofs in coq?
06:32:52 <roconnor> phobes: yes, there are two ways of doing that.  The way I do it is by using the classical existential (~forall~) and the classical disjuction ~(~A/\~B).
06:32:53 <phobes> Someone here was telling me to stick to the "non-constructive" fragment of coq if I wanted that, which didn't make sense to me at the time
06:33:22 <phobes> ok, I think that's what was meant
06:33:39 <roconnor> phobes: in fact I am going to use the classical exists to allow me to do jedbrown proof by contradition version of compact ==> seq. compact.
06:33:59 <roconnor> phobes: I'm probably the one who told you that :P
06:34:11 <phobes> probably... I puzzled over it :)
06:34:29 <phobes> I figured it had something to do with ~~A being a tautology iff A is a classical tautology
06:35:00 <phobes> So you basically just squint your eyes and interpret ~forall~ as exists?
06:35:10 <phobes> oh wait, what's the second way?
06:35:16 <roconnor> phobes: I define existsC to be that.
06:35:18 <phobes> Add an axiom?
06:35:22 <phobes> ok
06:35:29 <roconnor> adding an axiom is the second way :(
06:35:48 <phobes> Everything is still consistent if you do?
06:35:59 <roconnor> yes, but you cannot execute the axioms.
06:36:11 <phobes> ya, but that doesn't bother me
06:36:18 <roconnor> so you end up with non-canonical terms.
06:36:40 <roconnor> phobes: if all you want to do is philosophy, then you can add the axioms.
06:36:40 <phobes> well, maybe it bothers me... I might not understand all of the consequences
06:36:48 <roconnor> phobes: if you want to apply math, then it is a bad idea.
06:37:15 <phobes> roconnor:  I'm not interested in program extraction - is it still a bad idea?
06:37:25 <roconnor> phobes: like IO is haskell, it is much better to relegate classical mathematics to the not-not monad.
06:37:36 <phobes> hmm
06:37:36 <roconnor> IO in haskell ...
06:38:21 <roconnor> phobes: It affects a bit more than program extraction.  It restricts proof by reflection.
06:38:28 <roconnor> to a certain degree.
06:38:31 <phobes> What's that?
06:38:59 <phobes> You prove you can build a proof without actually building one?
06:39:10 <roconnor> proof by reflection is when you write a program to solve a proof for you.
06:39:55 <roconnor> you write a function that (for example) returns a bool if some finite problem is true.
06:40:18 <EvilTerran> "prove this program is correct" "what if i write a program that proves that program is correct, and prove *that* program correct?"
06:40:30 <roconnor> then you write a proof that if the function returns true, then whatever lemma you want (parameterized by the same arguements the function has) is true.
06:40:47 <roconnor> and then you can solve your lemmas by executing this function.
06:41:13 <phobes> ok
06:41:47 <roconnor> of course assuming axioms isn't necessarly the end of proof by reflection.
06:42:00 <phobes> existsC -> exists, right?
06:42:01 <roconnor> so long as your function and parameters don't rely on the axiom.
06:42:13 <roconnor> phobes: nope, the other way.
06:42:15 <phobes> no, I guess not
06:42:17 <phobes> right
06:43:02 <phobes> ok interesting, thanks
06:43:06 <roconnor> but (~~P -> P) -> (exists -> P) -> (existsC -> P).
06:43:19 <roconnor> which is what I regularly use when dealing with existsC.
06:43:31 <roconnor> (or a version of that).
06:43:55 <phobes> So then you shuttle the hypothesis (~~P -> P) around anywhere you need classical reasoning?
06:44:26 <roconnor> well, it means you can turn a existsC into an exists when you are trying to prove some P such that ~~P -> P.
06:44:37 <phobes> oh right
06:44:38 <roconnor> and often your goal is such that ~~P -> P.
06:45:01 <phobes> So when people talk about "constructive set theory" are they talking about using this trick?
06:45:11 <roconnor> phobes: nope.
06:45:18 <phobes> err
06:45:42 <phobes> sorry, I knew that... I mean can you embed more or less real set theory in coq with this trick?
06:46:15 <roconnor> that is a good question, there is more to classical mathematics than just the logic.
06:46:42 <roconnor> there is the axiom of choice, and quotients, and extenstionallity for functions.
06:46:45 <phobes> I assume axiom of choice still needs an axiom
06:47:01 <phobes> Quotients are hard?
06:47:03 <HelgeS> I'm trying a library used in a book  by Paul Hudak. The library is Graphics.SOE, a.k.a. SOEGraphics. Where can I learn more about that library, how to use it, etc.?
06:47:03 <roconnor> phobes: it depends on how you phrase it.
06:47:15 <roconnor> phobes: Quotients are hard.
06:47:58 <phobes> Quotients and extensionality are probably related, yes?
06:48:37 <roconnor> phobes: extensionality can be implemented as a quotient, so they are related.
06:48:43 <phobes> ya
06:49:07 <roconnor> extensionality is somewhat easier.
07:01:26 <pejo> Does anyone remember seeing someone having trouble with building ghc 6.8 with ghc 6.4, and having  some patches for it?
07:02:18 <Lemmih> What's the problem?
07:03:02 <pejo> I'm interested in those patches, but google doesn't really give me any hint on where they might be.
07:03:28 <Lemmih> What patches? GHC-6.8 should build just fine with ghc-6.4.
07:03:35 <Heffalump> you've checked glasgow-haskell-users archives?
07:05:00 <Lemmih> You could go 6.4 -> 6.6 -> 6.8. Or you could download a binary distribution.
07:06:00 <hpaste>  larmeh pasted "Exception: Test.hs:(13,0)-(23,65): Non-exhaustive patterns in function plus" at http://hpaste.org/5262
07:06:14 <larmeh> any ideas what this exception means?
07:07:23 <RayNbow> just wondering... why all the if-then-elses?
07:07:25 <larmeh> its kinda weird, isnt it? there seem to be no syntactical errors since ghci doesnt complain when interpreting the module Test at all
07:07:30 <Lemmih> larmeh: What happens when 'str' is non-empty and the dictionary is empty?
07:07:32 <RayNbow> guards are nicer to read :p
07:08:13 <Lemmih> larmeh: Try with -Wall.
07:09:45 <larmeh> hmmm
07:10:07 <int-e> larmeh: plus (_:_, _) (Dictionary [])  isn't covered by your patterns
07:10:30 <pejo> Heffalump, ah, Gregory Wright. It was hidden deep in some other thread, and from early december.
07:11:27 <pejo> Lemmih, the packages are often for a very recent version of the OS.
07:15:14 <larmeh> int-e: what does that mean? do i have to define `plus' differently?
07:18:35 <jtootf> hi everybody
07:18:54 <jtootf> got a question regarding IORef and IO monad
07:19:41 <jtootf> how should I use them correctly ? I want to get value from some IORef variable and then print it out
07:20:01 <jtootf> it seemed very easy, but I'm getting this error by ghc :
07:20:13 <jtootf>     Couldn't match `IORef a' against `IO (IORef MessageLevel)'
07:20:25 <jtootf>       Expected type: IORef a
07:20:30 <roconnor> @paste
07:20:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:20:38 <jtootf>      Inferred type: IO (IORef MessageLevel)
07:20:58 <jtootf> how should I get IORef out of IO (IORef a) ?
07:20:59 <Lemmih> jtootf: do ref <- newIORef; writeIORef ref val; val' <- readIORef ref; print val'
07:21:00 <Saizan> jtootf: domething like do v <- readIORef ioref; print v;
07:21:42 <Lemmih> jtootf: Note that you can't get a top-level IORef.
07:22:46 <jtootf> log = do level <- readIORef logLevel; putStrLn $ show level -- this produces an error I pasted before
07:23:11 <int-e> larmeh: it means that there is no equation to handle, say, plus ("xyzzy", 42) (Dictionary []) -- you need to handle adding a non-empty key to an empty dictionary somewhere.
07:23:12 <jtootf> Lemmih : top-level IORef ? why I cannot get it's value ?..
07:23:33 <Lemmih> jtootf: 'logLevel = newIORef' ?
07:24:03 <dejones> how can I create a list that has local scope to a function and initialized to [] ??
07:24:04 <roconnor> jtootf: there are no global IORefs in Haskell (without using unsafePerformIO)
07:24:09 <jtootf> Lemmih : it is done out of this function code. I think this IORef _is_ top-level
07:24:26 <Lemmih> jtootf: What's the definition of logLevel?
07:24:52 <Lemmih> dejones: Say again?
07:24:55 <roconnor> jtootf: newIORef isn't a new IORef itself, rather it is an IORef generator.
07:24:58 <jtootf> data MessageLevel = Low | High
07:25:05 <jtootf> {-# NOINLINE logLevel #-}\
07:25:13 <jtootf> logLevel = newIORef High
07:25:15 <dejones> how can I create a list that has local scope to a function and initialized to [], but I want to be able to append elements to list in some of my recursive calls...
07:25:46 <Saizan> dejones: lists are not mutable, but you can just pass a modified list to the recursive calls
07:26:12 <Lemmih> jtootf: unsafePerformIO (newIORef High).
07:26:16 <Saizan> dejones: appending is O(n), though
07:26:53 <dejones> Saizan: well, the order in the list doesn't matter, so a insert would be fine too.
07:27:14 <dejones> thanks for the O(n) appending note.
07:28:04 <dejones> Saizan: any way to do it without adding an additional argument for the list to the function?
07:28:05 <roconnor> jtootf: you may wish to read http://haskell.org/haskellwiki/Top_level_mutable_state
07:28:39 <roconnor> jtootf: oh, maybe that isn't a good as I thought.
07:28:54 <jtootf> Lemmih : maybe I'm going the wrong way ? I just need to implement logging function with a state, that's it - to print out all types of message when logLevel is set to High, and to print out only errors when logLevel is set to Low; so I have to associate somehow logLevel variable with my log function...
07:29:49 <Lemmih> jtootf: You can either pass the ioref along by hand or you can use 'unsafePerformIO'.
07:30:20 <Lemmih> jtootf: Monads can make the former a little less inconvenient.
07:30:27 <jtootf> roconnor : thank you, I will read this now
07:31:54 <jtootf> Lemmih : how monads can help me in this task ?
07:32:23 <dejones> haskell's modulus?  not % ?
07:32:42 <roconnor> > 19 `mod` 10
07:32:45 <lambdabot>  9
07:32:45 <Lemmih> jtootf: The State monad can hide the ioref. However, it may be uglier than without it.
07:32:49 <roconnor> > mod 19 10
07:32:50 <lambdabot>  9
07:33:03 <jtootf> Lemmih : well, I don't like the idea of using unsafe IO. if it is possible to get around with some monadic magic, it would be nice
07:33:14 <jtootf> Lemmih : I see...
07:33:17 <olsner> > 19 % 10 -- creates fractions
07:33:17 <lambdabot>  19%10
07:33:45 <dejones> thank you roconnor and olsner.
07:34:20 <jethr0> wouldn't it be also possible to use a writer monad and use output lazyness to print that "later on"?
07:35:03 <roconnor> that's right.  Typically we use the writer monad for logging.
07:35:38 <roconnor> and we use a filter on the log level to filter out the messages we ant
07:35:43 <EvilTerran> ?index (%)
07:35:43 <lambdabot> Data.Ratio
07:35:46 <roconnor> ... we want
07:36:00 <roconnor> and because of laziness, the messages we don't want are never computed.
07:36:33 <dejones> hey EvilTerran.  :)
07:36:50 <EvilTerran> ... hello? :)
07:37:06 <dejones> just saying hi.
07:37:16 <dejones> you helped me before with some code.
07:37:23 <dejones> when it was like 3am for you.  ;)
07:37:52 <dejones> EvilTerran: it was the split function.
07:38:15 <EvilTerran> oh, yeah. i do that. :)
07:39:07 <dejones> hehe
07:39:12 <dejones> have a good day everyone, I gotta go now
07:39:16 <dejones> later EvilTerran, thanks again for the help before.
07:39:16 <dejones> cya
07:40:04 <EvilTerran> :)
07:55:50 * Twey grumbles at monads.
07:56:20 <Twey> I get them right up until they start getting complicated (State).  Then I fail.  :-(
07:57:00 <Botje> state isn't hard
07:57:24 <EvilTerran> what bit of State confuses you? the implementation, or how to use it?
07:58:10 <dcoutts_> Twey: wait for the list or continuation monad, now they're hard :-)
07:58:29 <Botje> > let advance = do { (line, col, (c:cs)) <- get; put (line,col+1,cs); return c } in runState (advance) "foobar"
07:58:31 <lambdabot>  Couldn't match expected type `(t, t1, [t2])'
07:58:38 <Botje> > let advance = do { (line, col, (c:cs)) <- get; put (line,col+1,cs); return c } in runState (advance) (1,0,"foobar")
07:58:39 <lambdabot>  ('f',(1,1,"oobar"))
07:58:43 <dcoutts_> twanvl: they're also fairly easy to ignore for most tasks, so don't worry :-)
07:58:49 <Botje> > let advance = do { (line, col, (c:cs)) <- get; put (line,col+1,cs); return c } in runState (advance>>advance>>advance) (1,0,"foobar")
07:58:49 <lambdabot>  ('o',(1,3,"bar"))
07:59:41 <Twey> EvilTerran, the implementation
07:59:59 <EvilTerran> aha!
08:00:11 <EvilTerran> ... someone has pictures somewhere
08:00:16 <EvilTerran> ?src State
08:00:17 <lambdabot> Source not found. You speak an infinite deal of nothing
08:00:21 <EvilTerran> gr
08:00:23 <Twey> Heh
08:01:01 <EvilTerran> newtype State s a = State { runState :: (s -> (a, s)) }
08:01:41 <EvilTerran> so a State s a is like a function :: s -> (a, s)
08:01:54 <EvilTerran> just wrapped up so it can be made into a monad
08:02:18 <Twey> Hmmm
08:02:32 <Twey> What does State { runState :: (s -> (a, s)) } mean?
08:02:35 <EvilTerran> and a State "action" of type a, with state of type s, is a function that takes the old state, and returns the action's value and the new state
08:02:46 <EvilTerran> oh,that's record syntax
08:02:59 <EvilTerran> it's like saying newtype State s a = State (s -> (a, s))
08:03:06 <EvilTerran> and then runState (State s) = s
08:03:23 <Twey> Right, OK
08:03:46 <Twey> Is it the same as using 'where'?
08:03:54 <EvilTerran> the "function from old state to value + new state" is the important bit
08:03:59 <EvilTerran> ... no. nothing to do with where.
08:04:46 <EvilTerran> not sure what you mean by that, actually. can you elaborate?
08:05:46 <Twey> OK, doesn't matter, I was just thinking of classes: class Foo where...
08:06:27 <EvilTerran> well, data Foo a b = Foo { bar :: a, baz :: b }
08:06:59 <EvilTerran> is almost exactly the same as data Foo a b = Foo a b; bar (Foo x _) = x; baz (Foo _ x) = x
08:07:17 <Twey> So, you pass e.g. bar a Foo, and it has access to that Foo's properties?
08:07:23 <Twey> Mmkay, that makes sense
08:07:28 <EvilTerran> except you can also construct a new Foo by saying Foo{ bar = ..., baz = ... }
08:07:43 <EvilTerran> in addition to just accessing it normally
08:07:48 <Twey> o.@
08:08:00 <Twey> Oh
08:08:03 <EvilTerran> and you can modify an existing (foo :: Foo) by saying foo{baz = ...}
08:08:14 <Twey> So I can't do unmatchable things in there?
08:08:21 <EvilTerran> (this returns a new value, based on foo but modified at baz)
08:08:26 <EvilTerran> unmatchable things?
08:08:56 <Twey> data Foo a b = Foo { bar :: putStrLn a } for example
08:09:10 <Twey> Er
08:09:17 <Twey> Wait, that doesn't make sense anyway, does it.
08:09:24 <kpreid> Twey: record syntax doesn't add any important new behavior, it's just a convenience
08:10:02 <EvilTerran> anyway, going back to State
08:10:05 <bos> dcoutts_: ugh
08:10:05 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
08:10:12 <EvilTerran> newtype State s a = State (s -> (a, s))
08:10:27 <EvilTerran> runState (State f) = f
08:11:06 <Twey> Right
08:11:13 <EvilTerran> a value of type (State s a) is an action returning an (a) in the State monad, with state of type (s) threaded through
08:11:14 <bos> @seen dcoutts_
08:11:15 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 12m 31s ago.
08:11:34 <bos> @msg dcoutts_ yeah, haddock is printing a mystifying error message.
08:11:35 <lambdabot> Not enough privileges
08:11:46 <bos> @tell dcoutts_ yeah, haddock is printing a mystifying error message.
08:11:46 <lambdabot> Consider it noted.
08:12:07 <EvilTerran> state is "threaded through" a computation by adding a new parameter and return value to the computation; the state beforehand, and the state afterwards
08:12:15 <Twey> Rrrright
08:12:50 <EvilTerran> (return) just gives back a value, without modifying the state
08:13:07 <Twey> Aye
08:13:13 <EvilTerran> ignoring the newtyping for a moment,
08:13:24 <EvilTerran> return x state = (x, state)
08:13:52 <Twey> Yes
08:14:02 <EvilTerran> (get) is an action that returns the state, but doesn't modify it; get state = (state, state)
08:14:22 <Twey> Ah
08:14:31 <EvilTerran> (put x) is an action that sets the state to x, regardless of its previous value; put x state = (x,x)
08:15:05 <Twey> The first item of the pair is the old value, the second the new state?
08:15:20 <EvilTerran> the first item of the pair is the "value of the monadic action"
08:15:27 <EvilTerran> it's the "a" in "m a"
08:15:32 <Twey> Yeah
08:15:33 <fasta> Suppose someone presses C-c C-c in a Haskell program and that the most important state is hold in an STArray... now how can this state be saved in such an event?
08:15:54 <Twey> So why is it set to (state, state) in get?
08:16:03 <Twey> Oh wait
08:16:20 <Twey> No, silly question, because it gets the state
08:16:21 <EvilTerran> the first item is state because get's value is the state. the second item is state because it doesn't modify the state. :)
08:16:30 <Twey> OK, that makes sense.
08:16:45 <EvilTerran> (m >>= f), now; given an initial state, it threads it through m, and then through f, also giving f the value of m as a parameter
08:17:30 <EvilTerran> (m >>= f) state = f x state' where (x,state') = m state
08:17:47 <Twey> OK
08:17:53 <EvilTerran> and that's it!
08:17:57 <Twey> Oh
08:18:06 <Twey> I... I understand monads?  o.@  xD
08:18:20 <EvilTerran> the only difference in the *real* State monad is that you need to unwrap an action with runState before you can pass it its "state" parameter
08:18:21 <Twey> Haha, thanks!
08:18:24 <jedbrown> fasta: Maybe you want delimited continuations, or unsafePerformIO.
08:18:43 <fasta> jedbrown: a practical application for delimited continuations? I am all ears.
08:18:43 <EvilTerran> and wrap it with the State constructor again to turn it back into a monadic action
08:18:43 <kpreid> fasta: how about stToIO
08:18:51 <EvilTerran> Twey, np. :)
08:19:09 <bos> @tell dcoutts_ ah, it was the bang patterns
08:19:09 <lambdabot> Consider it noted.
08:19:12 <fasta> kpreid: I considered that option and it might work, but I would like to see something nicer.
08:19:51 <EvilTerran> bos, it was the bang patterns... in the source repository... with the shotgun operator!
08:19:56 <jedbrown> fasta: Have you read the zipperfs paper?
08:20:07 <EvilTerran> :D
08:20:22 <fasta> jedbrown: yes
08:21:20 <EvilTerran> (does anyone else call !! 'shotgun'? seeing as it goes "bang bang"...)
08:21:41 <olsner> hehe "The Type that Should Not Be"
08:21:46 <olsner> @seen sigfpe
08:21:46 <lambdabot> I haven't seen sigfpe.
08:22:00 <dcoutts_> bos: ah right
08:22:00 <lambdabot> dcoutts_: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:22:09 <bos> dcoutts_: i pushed a fix
08:22:19 <johnnowak> EvilTerran: i've been calling it ricky martin
08:22:22 <bos> (in darcs for now)
08:22:30 <EvilTerran> hehe
08:22:50 <fasta> jedbrown: how would delimited continuations work in this case?
08:23:35 <jedbrown> fasta: I'm certainly not an expert, but it seems that a similar approach would work.  The signal handler can set an MVar, when the continuation would resume until the delimiter at which point it can read the MVar, write its state, and exit.
08:23:47 <bos> dcoutts_: ok, 0.3 on hackage now
08:24:09 <fasta> jedbrown: I don't see where ST enters your story.
08:25:35 <jedbrown> fasta: Well ST isn't delimited.
08:27:08 <sizur> @users
08:27:08 <lambdabot> Maximum users seen in #haskell: 449, currently: 421 (93.8%), active: 12 (2.9%)
08:27:11 <jedbrown> fasta: (You would have to write your own instance for MArray.)
08:28:02 <fasta> jedbrown: I don't really see how your complete solution looks like.
08:28:02 <dcoutts_> bos: great
08:30:28 <jedbrown> fasta: I don't know the details either, but I think the approach is workable.
08:31:43 <Saizan> fasta: with the lazy ST you could use a WriterT to log snapshots of the array created with unsafeFreeze, maybe?
08:32:34 <fasta> Saizan: heh, that's a theoretical solution. I am allergic to WriterT.
08:32:48 <jedbrown> Saizan: How would the signal handler get the last snapshot?
08:32:53 <fasta> Saizan: it slows down computations a lot.
08:33:02 <fasta> Saizan: at least, in my experiences.
08:33:12 <Saizan> jedbrown: by running the writerT
08:33:58 <Saizan> jedbrown: uhm, last is bad defined in this context, isee
08:34:08 <Tac-Tics> sequence_ [putStr "Good ", putStr "Morning ", putStr " #haskell!"]
08:34:12 <jedbrown> Saizan: But the computation hasn't finished when the signal handler is called.  So you have a list of continuation frames, but don't know which one is last.
08:35:02 <Saizan> fasta: i think writer can be much faster if CPSed
08:35:35 <fasta> Saizan: isn't that how it's implemented?
08:35:42 <shapr> radix: Hey, when do we have dinner again?
08:35:48 <fasta> Saizan: well, I can imagine such a compiler pass is being done.
08:36:11 <the_ez> Hi all; I just installed GHC 6.8.2 and some libraries seem to be missing (I'm noticing Test.HUnit and Test.QuickCheck). Do I need to download them separately?
08:36:24 <Saizan> fasta: not in the same way as using (forall r. ContT r Writer)
08:36:53 <monochrom> the_ez: Likely. Depends on how you installed.
08:37:16 <the_ez> monochrom: i built from source.
08:37:16 <Twey> If I call length on a list in its own definition, does that cause the whole list to be evaluated?
08:37:42 <fasta> Saizan: can you elaborate a bit?
08:37:45 <the_ez> monochrom: searching the web, I see source for QuickCheck but not a "package" as such... should I expect one?
08:37:51 <fasta> the_ez: no
08:37:56 <fasta> Twey: no
08:37:56 <Twey> (i.e. infinite recursion)
08:38:00 <mauke> the_ez: does Control.Monad.Reader work?
08:38:11 <Twey> fasta, it will return the length up to that point?
08:38:18 <Saizan> fasta: the compiler transform the pattern match on the tuple, while here you avoid the pattern match completely outside of tell
08:38:18 <fasta> Twey: no
08:38:18 <monochrom> You could build libraries separately. Or you could go back and get the source of "extralibs" then clean and build again.
08:38:31 <fasta> Twey: I thought you meant whether the contents of the list would be evaluated.
08:38:42 <fasta> Twey: length [1..] never returns
08:38:45 <monochrom> hackage.haskell.org has all libraries.
08:38:52 <tumdum> Twey: list will be evaluated but not the elements on the list
08:39:01 <the_ez> mauke: Control.Monad.Reader works, yes
08:39:04 <fasta> Twey: the spine will be evaluated.
08:39:08 <fasta> Twey: that's all.
08:39:20 <fasta> Twey: but that's not the case you meant, I think.
08:39:36 <mauke> > let x = [undefined, length x, length x, undefined] in x !! 2
08:39:38 <lambdabot>  4
08:39:42 <Twey> fasta: I'm trying to think up a definition for factorials
08:39:56 <mauke> > scanl (*) 1 [1 ..]
08:39:57 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
08:39:58 <Twey> fac  = 0 : 1 : [x * (length fac) | x <- fac] -- this doesn't cut it, right?
08:40:03 <the_ez> I have a bunch of things in /usr/local/lib/ghc-6.8.2/lib, but QuickCheck is not one.
08:40:21 <Twey> I'm not even entirely sure if it's logically correct, actually.  *frown*
08:40:25 <fasta> Twey: no, that isn't going to work.
08:40:26 <Tac-Tics> @let fac = 0 : 1  : [x * (length fac) | x <- fac]
08:40:30 <Tac-Tics> I'll bottom out
08:40:31 <lambdabot> Defined.
08:40:33 <Tac-Tics> > fac
08:40:36 <lambdabot> Terminated
08:40:39 <Tac-Tics> see?
08:40:42 <mauke> > take 1 fac
08:40:43 <lambdabot>  [0]
08:40:46 <Twey> Hmm, I see
08:40:51 <Twey> fac !! 3
08:40:52 <Tac-Tics> >take 3 fac
08:40:59 <Twey> Mmm.
08:41:02 <Twey> Death.
08:41:03 <Tac-Tics> we fail
08:41:04 <Tac-Tics> hehe
08:41:05 <Twey> Heh
08:41:07 <Tac-Tics> > take 3 fac
08:41:10 <lambdabot> Terminated
08:41:10 <Tac-Tics> > fac !! 3
08:41:15 <lambdabot> Terminated
08:41:15 <Twey> It's not going to do it
08:41:21 <Twey> Hmmm
08:41:27 <Twey> Then how *ponder*
08:41:30 <Tac-Tics> fac is indeed infinitely long in that case, so the length is bottom
08:41:30 <Deewiant> it tries to evaluate the whole list with the (length fac)
08:41:36 <fasta> Twey: there is a way you can something similar though.
08:41:44 <fasta> Twey: you can zip the indices to it.
08:41:45 <jedbrown> the_ez: install cabal-install from hackage, then you'll be able to get your packages easily.  BTW, did you use the extralibs tarball as well?
08:41:50 <Tac-Tics> you can zip fac with [1..] to get something similar
08:42:00 <fasta> Tac-Tics: heh
08:42:04 <mauke> Twey: you can just keep a running accumulator and multiply with increasing numbers
08:42:32 <the_ez> jedbrown: ah, so cabal is the secret. I'll chase that down, thanks. I didn't use the extralibs tarball, no--what is it?
08:42:35 <Tac-Tics> but it's not factorial
08:42:40 <Twey> Hmm?
08:42:59 <mauke> the_ez: http://haskell.org/ghc/download_ghc_682.html
08:43:04 <mauke> ghc-6.8.2-src-extralibs.tar.bz2  (1.9 MB).
08:43:16 <jedbrown> the_ez: What platform are you on?  extralibs has lots of common libraries, most of which you want.
08:43:42 <the_ez> mauke, jedbrown: I see, cool. I'm on OS X for this installation.
08:43:48 <Krekk> hi, I'm trying the quicksort example from http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying , if I copy/paste it, it runs well, but if I try to indent it myself (with tabs or spaces) I always get an indentation error. Where can I find a manual to learn how to indent haskell code properly?
08:43:50 <RayNbow> > sum [1/(2^a)| a <- [1..]]
08:43:56 <lambdabot> Terminated
08:44:04 <Tac-Tics> @let fac = 1  : [x * i | (i, x) <- zip [2..] fac]
08:44:05 <lambdabot> <local>:5:0:     Multiple declarations of `L.fac'     Declared at: <local>:4:...
08:44:10 <mauke> @undefine
08:44:11 <lambdabot> Undefined.
08:44:15 <Tac-Tics> @let fac = 1  : [x * i | (i, x) <- zip [2..] fac]
08:44:15 <lambdabot> Defined.
08:44:18 <Tac-Tics> > take 12 fac
08:44:19 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600]
08:44:33 <Tac-Tics> (missing the first 1 in there, of course)
08:44:54 <mauke> Krekk: the trick is: always start a new line after "where", "do" and "of"
08:44:54 <Tac-Tics> wait, I'm dumb,
08:45:09 <Tac-Tics> @undefine
08:45:09 <Tac-Tics> @let fac = 1  : [x * i | (i, x) <- zip [1..] fac]
08:45:09 <lambdabot> Undefined.
08:45:10 <lambdabot> Defined.
08:45:14 <Tac-Tics> there =-)
08:45:40 <mauke> > scanl (*) 1 [1 ..]
08:45:41 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
08:45:50 <Tac-Tics> @let fac' = 1 : zipWith (*) [1..] fac' -- is another way w/o the comprehension
08:45:51 <lambdabot> Defined.
08:46:25 <Tac-Tics> I don't get how weird foldish prelude functions work (scan, accumulate, and friends)
08:46:31 <Krekk> thanks mauke , it worked
08:47:44 <mauke> Krekk: http://haskell.org/onlinereport/lexemes.html#lexemes-layout
08:48:05 <Philippa> Tac-Tics: IIRC some of them can be seen as equivalent to particular monadic folds
08:48:21 <Cin> is this good code or bad code? any advice on making it neater or better? http://hpaste.org/5263
08:48:32 <Tac-Tics> :t scanl
08:48:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:48:55 <Tac-Tics> @src scanl
08:48:55 <lambdabot> scanl f q ls = q : case ls of
08:48:55 <lambdabot>     []   -> []
08:48:55 <lambdabot>     x:xs -> scanl f (f q x) xs
08:49:13 <mauke> q is the accumulator
08:49:15 <Twey> Ahhh
08:49:23 <Twey> I get it.
08:49:25 <Twey> Kind of.
08:49:55 <mauke> for each list element x, the accumulator q is set to f q x
08:50:07 <mauke> scanl returns a list of all intermediate accumulator values
08:50:43 <fasta> I cannot profile all non-terminating programs, can I (with GHC)?
08:51:24 <LoganCapaldo> Can you profile non-teminating programs at all?
08:51:33 <fasta> Of course.
08:52:04 <Twey> mauke, can scanl be expressed using foldl?
08:52:13 <monochrom> You can watch the space usage vary over time. After some time you interrupt the program.
08:52:32 <mauke> Twey: unlikely. foldr, maybe
08:52:33 <monochrom> Of course I mean you can watch the space usage vary over time afterwards.
08:52:34 <fasta> monochrom: yes, I did that before, but now that doesn't work.
08:52:44 <Twey> Hm, OK
08:52:46 <Twey> Thanks
08:53:01 <fasta> monochrom: I also did it at run-time a few time.
08:53:04 <fasta> monochrom: +s
08:53:13 * LoganCapaldo thinks interupting counts as "termination", but whatever
08:53:15 <Tac-Tics> it seems like the other way around would be easy: expression foldl as scanl
08:53:41 <Deewiant> foldl = last . scanl?
08:53:43 <Tac-Tics> > last . take 5 $ foldl (*) 1 [1..]
08:53:44 <lambdabot>   add an instance declaration for (Num [a])
08:53:44 <lambdabot>     In the expression: 1
08:53:53 <monochrom> I did it successfully a long time ago with older ghc's. I haven't tried it recently.
08:54:11 <Tac-Tics> oh yeah
08:54:12 <Tac-Tics> heh
08:54:15 <Tac-Tics> foldl
08:54:22 <Saizan> Tac-Tics: you can write scanl with foldr
08:54:36 <Tac-Tics> > last . take 5 $ (*) 1 [1..]
08:54:36 <lambdabot>   add an instance declaration for (Num [a])
08:54:37 <fasta> I'd have expected it to work for all programs, but it seems it doesn't.
08:55:13 <Tac-Tics> bah
08:55:17 <fasta> I guess I didn't wait long enough. I now get my run-time profile.
08:55:24 * monochrom 's kung-fu of predicting space usage, actually designing space usage, has improved significantly, no pressure to profile yet.
08:55:34 <Deewiant> > last $ take 5 $ foldl (*) 1 [1..]
08:55:34 <lambdabot>   add an instance declaration for (Num [a])
08:55:34 <lambdabot>     In the expression: 1
08:56:14 <Tac-Tics> err, I think I may have the dumb
08:56:16 <fasta> monochrom: there is no space-leak, I just want to see what's taking the most time.
08:56:30 <monochrom> Time is my next frontier. :)
08:56:30 <Tac-Tics> > last . take 5 $ scanr (*) 1 [1..]
08:56:32 <lambdabot>  Exception: stack overflow
08:56:33 <Deewiant> > last $ take 5 $ scanl (*) 1 [1..]
08:56:34 <lambdabot>  24
08:56:50 <EvilTerran> last . take 5 = (!!4)
08:57:09 <Deewiant> interesting, both $ and . work there
08:57:18 <Tac-Tics> EvilTerran: spoil our fun and optimize us why don'tcha
08:57:28 <EvilTerran> :)
08:58:11 <Saizan> Deewiant: f $ g $ h $ x === f . g . h $ x
08:58:19 <fasta> Most of the time is spent on foo = liftST(readArray <details>). I wonder whether this means it has been inlined or not.
08:58:34 <fasta> It's just a simple read that should be inlined.
08:58:48 <mauke> Deewiant: that's because f (g x) == (f . g) x
08:58:53 <Tac-Tics> some day (maybe latter today), I'm going to sit down and study those diagrams Cale made of foldl and friends
08:59:06 <Deewiant> yeah, never really thought about it before
08:59:35 <Deewiant> for me it's been "use either . or $, whichever works" ;-)
09:00:11 <Tac-Tics> It's a nice pretty convention to use .'s leading up to a single $. Plus it makes you feel smarter because you're using function composition
09:00:25 <Deewiant> heh
09:01:29 <desegnis> you still have alternatives like  (f . g . h) x,  y x where y = f . g . h
09:01:51 <litb> hello all
09:01:55 <litb> someone got a haskell cheet sheet?
09:02:04 <litb> errm, a cheat sheet?
09:02:10 <davidL> @docs
09:02:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:02:16 <Tac-Tics> what kind of cheatsheet?
09:02:28 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is my favourite cheat sheet.
09:02:30 <litb> i would like to make it my new desktop wallpaper
09:02:30 <desegnis> The description of the Prelude in the report, maybe?
09:02:38 <litb> where some useful stuff is on
09:03:43 <litb> or some other nice haskell/fp wallpaper?
09:05:25 <monochrom> You could play a haskell lecture video as the wallpaper.
09:06:47 <monochrom> Or screen saver. XD
09:07:19 <czakey> I have better idea
09:07:30 <czakey> set GHCi as your defaul shell
09:07:31 <czakey> :P
09:08:33 <pwned> you can see your wallpaper ?
09:09:00 <litb> lolz
09:09:04 <litb> yeah, no tiling here
09:17:35 <litb> hm, could you please show me a good example of filterM ?
09:17:43 <litb> i don't seem to see where it is good for
09:17:59 <shachaf> > filterM (const [True,False]) [1,2,3] -- :-)
09:17:59 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:18:20 <Tac-Tics> that was the function that got me hooked on haskell
09:18:58 <litb> oups, that is amazing
09:19:03 <Tac-Tics> > filterM (\x -> [Nothing, Just x, Just $ x+1]) [1,2,3]
09:19:04 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Maybe a'
09:19:07 <Tac-Tics> bah
09:19:22 <Tac-Tics> > filterM (\x -> [Nothing, Just False, Just True) [1,2,3]
09:19:22 <lambdabot>  Parse error at ")" (column 47)
09:19:29 <davidL> powerset :)
09:19:30 <Tac-Tics> screw you syntax bot
09:19:57 <ehird> what's the 'force evaluation of this' thing again?
09:19:59 <shachaf> litb: How about something like (filterM directoryExists directoryList), in IO?
09:20:02 <litb> now i just need to see how that worked =)
09:20:02 <shachaf> ehird: seq?
09:20:07 <kpreid> litb: filterM fileExists...what shachaf said
09:20:08 <shachaf> @src filterM
09:20:08 <lambdabot> Source not found. Do you think like you type?
09:20:13 <ehird> oh duh of course
09:20:33 <litb> i've the source of it, don't worry
09:21:14 <litb> you returned a list  [True, False] . this satisfies m Bool indeed .
09:22:09 <kpreid> the 'filterM (const [True,False])' is degenerate, in that it just expresses all possible filterings, rather than depending on the input in any way
09:22:15 <shachaf> You could consider it cheating because it doesn't use return.
09:22:30 <shachaf> Yes, that's because of the const. :-)
09:22:46 <shachaf> > [1,2,3] >>= (\x -> [x,0])
09:22:46 <lambdabot>  [1,0,2,0,3,0]
09:22:48 <litb> then, it concatMaps those values to (b -> (filterM p xs) >>= (\ys -> return (if b then (x : ys) else ys)))
09:22:53 <cnwdup> Sorry for the dumb question, but I can't find out googeling. How can I convert the type Dimension to Position or Integer?
09:22:53 <mauke> > filterM (return [True, False]) [1,2,3]  -- now with return :-)
09:22:54 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:23:33 <monochrom> Who is Dimension?
09:23:35 <mauke> shachaf: better?
09:23:41 <shachaf> fromIntegral
09:23:55 <shachaf> cnwdup: type Dimension = GHC.Word.Word32
09:24:13 <shachaf> mauke: That's... Not what I meant.
09:24:30 <cnwdup> shachaf: Thanks, I'll try.
09:24:35 * shachaf could see someone really being confused by that.
09:25:39 <litb> and calls that for b = True and False afai see it.
09:26:05 <kpreid> > filterM (return (return True `mplus` return False)) [1,2,3]
09:26:05 <lambdabot>   add an instance declaration for (Show (m [a]))
09:26:15 <kpreid> whoops, underspecified!
09:26:19 <LoganCapaldo> > [True, False] >>= \b -> [1,2,3] >>= \x -> guard b >> (return x)
09:26:20 <lambdabot>  [1,2,3]
09:26:21 <kpreid> > filterM (return (return True `mplus` return False)) [1,2,3] :: [[Int]]
09:26:22 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:26:39 <litb> so that means, one time the item is, and another time the item is not in the list. i think that then generates the powerset, because that is just the definition of it?
09:26:40 <Deewiant> > filterM (return (return True `mplus` return False)) [1,2,3] :: Maybe [Int]
09:26:41 <lambdabot>  Just [1,2,3]
09:27:14 <LoganCapaldo> > [1,2,3] >>= \x -> [True, False] >>= \b -> guard b >> (return x)
09:27:15 <lambdabot>  [1,2,3]
09:27:26 * LoganCapaldo fails at the list monad
09:27:43 <Tac-Tics> it's an easy monad to fail
09:27:45 <kpreid> LoganCapaldo: I think the input has to be [[1,2,3]]
09:27:46 <litb> this page is quite nice: http://members.chello.nl/hjgtuyl/tourdemonad.html
09:27:48 <lambdabot> Title: A tour of the Haskell monad functions
09:28:13 <LoganCapaldo> > [[1,2,3]] >>= \x -> [True, False] >>= \b -> guard b >> (return x)
09:28:14 <lambdabot>  [[1,2,3]]
09:28:56 <kpreid> hmm...oh, of course
09:29:25 <LoganCapaldo> i think I know why it's wrong now
09:29:25 <kpreid> your first one has two choices: 1, 2, or 3, and succeed or fail
09:29:28 <Saizan> 3what do you want to do?
09:29:36 <kpreid> the fails all fail, so it just produces all of 1, 2, and 3
09:29:46 <ehird> haskell-unicode is amusing :)
09:30:11 <shachaf> Saizan: Make a powerlist?
09:30:19 <LoganCapaldo> it's ending up like [[1],[],[2],[],[3],[]] just before the concat
09:30:27 <Tac-Tics> > foldM (\a b -> [a + b, a - b]) 0 [1..3]
09:30:27 <lambdabot>  [6,0,2,-4,4,-2,0,-6]
09:30:45 <Tac-Tics> I have no idea what the thing I just typed means
09:31:12 <Tac-Tics> sometimes it feels like if you can get your haskell to compile, you understand it
09:31:26 <Deewiant> and sometimes not :-P
09:31:37 <LoganCapaldo> Tac-Tics: you did a left fold with two functions instead of one
09:31:51 <shachaf> Tac-Tics: If you actually wrote your Haskell. :-)
09:31:55 <Tac-Tics> but where does the 6 come from?
09:32:00 <Tac-Tics> I did write that!
09:32:09 <Tac-Tics> I just plugged in values of the correct type and hit enter
09:32:20 <Tac-Tics> much like a professional PHP programmer
09:32:21 <Deewiant> the 6 is 3 + 3
09:32:27 <litb> lolz Tac-Tics
09:32:29 <Saizan> ?type foldM
09:32:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:32:34 <TNorthover> Isn't 6 = 1+2+3?
09:32:38 <ehird> oh wow
09:32:42 <Deewiant> it would be, wouldn't it
09:32:45 <ehird> inferior-haskell + unicode = awesome
09:32:53 <Deewiant> it's also 2+2+2 among other things ;-)
09:33:15 <Deewiant> but yeah, that makes sense, cause then the -6 is 0-1-2-3
09:33:20 <litb> @src foldM
09:33:21 <jethr0> how do I use constants from a c header in haskell using ffi?
09:33:21 <lambdabot> foldM _ a []     = return a
09:33:21 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
09:33:28 <LoganCapaldo> > foldl (\a b -> a + b) 0  [1..3]
09:33:28 <lambdabot>  6
09:33:30 <Tac-Tics> > foldM (\x y -> [x + y, x*y]) 1 [2..4]
09:33:30 <lambdabot>  [10,24,13,36,9,20,10,24]
09:33:36 <ehird> it works perfectly :D
09:33:42 <mauke> jethr0: you'd use another tool such as hsc2hs
09:33:51 <desegnis> 6 is the result of the fold where the operator is always (+).
09:33:59 <jethr0> mauke: yes, i thought so. but is there no manual way to do it?
09:34:10 <hpaste>  larmeh pasted "Bugfree, but it's certainly poorly written. Suggestions?" at http://hpaste.org/5264
09:34:27 <mauke> jethr0: short of pasting the numbers into your source file, no
09:34:38 <jethr0> hmm ;(
09:34:51 <jethr0> k, i'll fetch hsc2hs then
09:34:58 <mauke> you don't have ghc?
09:35:10 <desegnis> > replicateM 3 ['+', '-']
09:35:11 <lambdabot>  ["+++","++-","+-+","+--","-++","-+-","--+","---"]
09:35:12 <Tac-Tics> so foldM looks like it applies all combinations of the functions in the first argument over the list of b
09:35:13 <larmeh> blasphemy!
09:35:17 <mauke> http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
09:35:26 <Deewiant> > replicateM 3 ["--"]
09:35:27 <lambdabot>  [["--","--","--"]]
09:35:29 <litb> desegnis: that was sexy
09:35:34 <Deewiant> > replicateM 3 "--"
09:35:35 <lambdabot>  ["---","---","---","---","---","---","---","---"]
09:35:35 <desegnis> heh
09:36:05 <ehird> it just doesn't replace enough symbols
09:36:06 <ehird> heh
09:36:09 <jbms> Hello.  I am a rather good programmer, and I've learned SML (though I haven't used it much), but I know little about haskell.  I want to learn haskell as fast as possible.  What is suggested?
09:36:12 <litb> > replicateM 2 [1..2]
09:36:17 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
09:36:23 <mauke> jbms: step 1: get ghc
09:36:24 <Tac-Tics> > mapM (\x -> [(+1), (+2), (+3)]) [1,2,3]
09:36:25 <lambdabot>  [[<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>],[<Integer ...
09:36:30 <TNorthover> Tac-Tics: when applied with a list as the second, yes. Remember it's a general monad function
09:36:31 <jbms> mauke: okay, I have that
09:36:35 <cjb> jbms: http://darcs.haskell.org/yaht/yaht.pdf
09:36:40 <mauke> jbms: play around with stuff in ghci
09:37:00 <Japsu> > sequence ["+-", "ab", "12"]
09:37:03 <lambdabot>  ["+a1","+a2","+b1","+b2","-a1","-a2","-b1","-b2"]
09:37:05 <Tac-Tics> jbms: playing with lambdabot is a good start, too
09:37:36 <Tac-Tics> > "This " ++ "is " ++ "#haskell!"
09:37:37 <lambdabot>  "This is #haskell!"
09:38:00 <litb> > sequence ["you", "are", "pwned"]
09:38:01 <lambdabot>  ["yap","yaw","yan","yae","yad","yrp","yrw","yrn","yre","yrd","yep","yew","ye...
09:38:20 <LoganCapaldo> > evalState (foldM (\a b -> get >>= \op -> put (\x y -> x `op` negate y) >> return (a `op` b)) 0 [1..10]) (+)
09:38:31 <lambdabot>  -5
09:38:38 * Tac-Tics is done abusing the list monad for one day
09:38:38 <larmeh> damn
09:38:40 <larmeh> that took a few secs
09:38:44 <Tac-Tics> (or being abused by it rather)
09:39:00 <jbms> I suppose I'd prefer some sort of reference document rather than having to guess about the syntax
09:39:06 <jbms> I guess haskell.org may have appropriate references already
09:39:10 <LoganCapaldo> > evalState (foldM (\a b -> get >>= \op -> put (\x y -> x `op` negate y) >> return (a `op` b)) 0 [1..100]) (+)
09:39:11 <lambdabot>  -50
09:39:15 <shachaf> jbms: Perhaps the wikibook?
09:39:19 <larmeh> jbms, just ask google
09:39:25 * shachaf doesn't know what state it's in.
09:39:35 <Tac-Tics> jbms: http://en.wikibooks.org/wiki/Haskell
09:39:35 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
09:39:38 <jethr0> mauke, is hsc2hs already in ghc? i didn't know
09:39:44 <sclv> larmeh: why do you have data Trie a = Trie (Char,((Maybe a),[Trie a])) ?
09:39:45 <Tac-Tics> that's the best guide we have, pretty much, for introductory haskell
09:39:51 <shachaf> @@ There's always (@where gentle)
09:39:51 <lambdabot>  There's always http://www.haskell.org/tutorial/
09:39:51 <jethr0> i always get confused with all these packages hs2c, greencard, .....
09:39:54 <mauke> jbms: http://haskell.org/onlinereport/
09:40:01 <sclv> all the nested tuples seem sort of beside the point and gumming up your code.
09:40:22 * shachaf should start filtering all his sentences through lambdabot.
09:40:23 <litb> i've began haskell two weeks ago and have still problems with parsing monadic ops :)
09:40:41 <shachaf> litb: Parsing?
09:40:56 <Tac-Tics> there's also http://www.haskell.org/~pairwise/intro/intro.html
09:40:56 <lambdabot> Title: Haskell for C Programmers
09:41:03 <larmeh> sclv: i thought that, too but i got lots of syntactical errors trying to write it differently
09:41:16 <litb> shachaf: yeah
09:41:16 <thoughtpolice> jethr0: i believe greencard is somewhat dead, hsc2hs comes stock with ghc, and you can also use c2hs
09:41:30 <litb> semantic parsing
09:41:30 <larmeh> i guess replacing the if then elses is a good idea, too isn't it?
09:41:36 <shachaf> @@ jbms: (@go meta-tutorial)
09:41:36 <lambdabot> Plugin `compose' failed with: Unknown command: "go"
09:41:46 <shachaf> @@ jbms: (@google meta-tutorial)
09:41:47 <lambdabot>  jbms:
09:41:47 <lambdabot>  http://www.haskell.org/haskellwiki/Meta-tutorial
09:41:47 <lambdabot>  Title: Meta-tutorial - HaskellWiki
09:41:52 <jethr0> cool. always had problems getting those to run. gonna check out hsc2hs then
09:41:54 <shachaf> Hmm, doesn't work very well.
09:42:30 <sclv> you probably didn't pattern match right: if you have Constr Int Int (Map String Int) and you want to match on it, you need to make sure your parens are all in the right places.
09:42:40 <thoughtpolice> jethr0: c2hs is also definately worth a look. there's a paper over it too which I really suggest reading. i've never used it on any project but it seems to be a really nice wrapper for binding to C
09:42:52 <jedbrown> jethr0: There are a lot of FFI resources, but one place to look would be the new pcre-light package.  It uses hsc2hs and is quite simple.
09:42:53 <RayNbow> http://reddit.com/r/programming/info/66rxx/comments/ <-- :X
09:43:06 <jethr0> yes, looking at pcre-light right now
09:43:33 <jedbrown> jethr0: The advantage of c2hs is when you need to do complex marshalling for a lot of functions.  It has a somewhat cryptic, but powerful syntax for function hooks.
09:43:35 <sclv> first, i'd rewrite so Trie doesn't have tuples in it. you may even want to use record syntax.
09:43:51 <Tac-Tics> hehe "Is a Monad the same as a nomad?" --> (reply) Nomads pack up their things and visit the world.  Monads pack up the world and visit things.
09:43:55 <jethr0> k, i'm just trying things out for now. so the simpler the better
09:43:57 <sclv> next, i'd ask if I really needed a Dictionary type at all, or if it could just be a special case of Trie.
09:44:15 <shachaf> We will use the modern distributed version control system "darcs". "Modern" means that it is written in Haskell, "distributed" means that each working copy is a repository in itself. :-)
09:44:20 <LoganCapaldo> > let ops = cycle [(+), (-)] in evalState (foldM (\a b -> get >>= \(op:ops) -> put ops >> return (a `op` b)) 0 [1..10]) ops
09:44:21 <lambdabot>  -5
09:44:25 <Botje> hehehe
09:44:33 <larmeh> sclv: record syntax? what is that anyway?
09:45:04 <sclv> data Foo = {bar::Int, baz::String}
09:45:11 <shachaf> larmeh: data D = D { a :: A, b :: B }
09:45:12 <Deewiant> s/{/Foo {/
09:45:21 <larmeh> sclv: i need a Dictionary type.
09:46:40 <sclv> er, right. you need the top level constructor for the Foo. Then you can still declare Foo 12 "etc" but you can also declare Foo {bar=12, baz="etc"} and if you have something of type foo you get selector functions for free so you can just say, e.g. "bar foo" and get 12 back out of your foo of type Foo.
09:48:56 <thoughtpolice> hackage builds packages automatically now? :)
09:49:41 <sclv> larmeh: also, on an algorithmic level, why did you decide to have the chars stored in each Trie node instead of associated with them in the node one level higher? it seems it would be more efficient to have something of data Trie a = Trie (Maybe a) (Map Char (Trie a))
09:49:47 * shachaf would be surprised.
09:49:57 <sclv> in which case a dictionary is redundant.
09:49:59 <shachaf> thoughtpolice: cabal-install does, if that's what you mean.
09:50:58 <thoughtpolice> shachaf: ah no (I couldn't get cabal-install to work anyway, something to do with bytestring-0.9.0.4 being installed over 0.9.0.1)
09:51:40 <thoughtpolice> shachaf: but look: http://hackage.haskell.org/packages/archive/xmonad/0.5/logs/failure/ghc-6.8
09:51:41 <lambdabot> http://tinyurl.com/2kcypn
09:51:52 <thoughtpolice> lots of other packages also have build info although not nearly all of them
09:52:19 <larmeh> sclv: i didn't come up with this ... the execise i'm currently working on requires me to do that because it explicitly states the type definitions
09:52:38 <larmeh> s/execise/exercise/
09:52:48 <shachaf> Hmm.
09:52:54 * shachaf doesn't know about that.
09:52:56 <sclv> ah... in any case, i'd still see if i can ditch the tuples.
09:53:27 <thoughtpolice> just go to the pages and look. most of the failures seem to be because of some missing C binding (like the llvm package) or something just didn't add a package explicitly after the base split (i.e. missing array or containers or something)
09:53:48 <thoughtpolice> perhaps code coverage will soon come too? :)
09:54:11 <larmeh> sclv: yes looks like i'll have to do that
09:54:41 <olsner> how should you modify an old .cabal-file for the base split? people with older versions of ghc won't have 'array' or 'containers' installed
09:55:21 <dcoutts_> thoughtpolice: sooner if you help :-) we have lots of ideas to get better hackage qa
09:55:52 <thoughtpolice> dcoutts_: looks like right now it needs some more disk space ;p
09:55:59 <dcoutts_> olsner: there's a link on the cabal home page http://haskell.org/cabal/
09:56:03 <dcoutts_> thoughtpolice: yes, so I see :-)
09:57:50 <dcoutts_> thoughtpolice: so yes, the problem is we cannot really build every package on a server since it'll never have all the C libs installed
09:58:37 <thoughtpolice> that does seem like the main limitation. it is a very good start though. :)
09:58:45 <dcoutts_> thoughtpolice: http://hackage.haskell.org/trac/hackage/ticket/184
09:58:46 <lambdabot> Title: #184 (cabal-install should report build results to hackage server) - Hackage - T ...
09:59:23 <dcoutts_> so rather than having a single stressed server trying and filing to build all packages, get everyone to report success/failure
09:59:30 <dcoutts_> and only collect stats centrally
09:59:49 <thoughtpolice> dcoutts_: good goal. categorize by arch/os combination for example, the way buildbot does for ghc?
10:00:12 <dcoutts_> thoughtpolice: there is quite a bit of info that'd be useful to collect, not just os/arch
10:00:36 <dcoutts_> there are plenty of sub-tasks there if you have a bit of spare hacking time :-)
10:00:49 <dcoutts_> and we need someone who knows a bit of stats
10:01:09 <thoughtpolice> dcoutts_: i'd love to, but like I said, I'm having an issue right now with cabal-install. it doesn't seem to like bytestring-0.9.0.4 (neither does yi, come to think of it)
10:01:54 <dcoutts_> thoughtpolice: that's because you've got some packages using 0.9.0.1 and some using 0.9.0.4
10:01:54 <cjb> wah, I just found out that lists/list comprehensions are monadic.
10:02:04 <cjb> and here was I thinking that the standard library was all pure and clean.
10:02:28 <dcoutts_> thoughtpolice: and then when you try and build something that uses packages built against inconsistent versions then you get a compile failure
10:02:29 <mauke> cjb: ?
10:02:30 <Saizan> monadic -/-> inpue
10:02:34 <Saizan> *inpure
10:02:41 <EvilTerran> impure?
10:02:56 <cjb> ah, I thought that monadic always implied impure
10:03:27 <cjb> maybe someone could explain it?  I'm reading YAHT, it says:
10:03:30 <ibid> only the IO monad is impure
10:03:42 <ibid> the rest just look like they are
10:03:45 <mauke> the monad itself is pure; its effects aren't
10:04:03 <cjb> Thanks.  Okay.  So I should remove the monad -> impure thought I have.
10:04:03 <EvilTerran> ibid, well, and ST and STM
10:04:21 <Botje> cjb: >>= for lists is defined using concatMap, so definitely pure :)
10:04:30 <EvilTerran> ?src [] (>>=)
10:04:30 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:04:34 <EvilTerran> well
10:04:41 <ibid> EvilTerran: aren't they both implementable without impurity? (albeit with bad efficiency)
10:04:56 <Botje> ?src concatMap
10:04:56 <lambdabot> concatMap f = foldr ((++) . f) []
10:04:57 <EvilTerran> ibid, not sure about STM, but you could do ST purely, yeah
10:05:05 <Botje> see? :p
10:05:11 <LoganCapaldo> Doesn't runST mean that ST is pure, (ignoring things like unsafeSTtoIO or what have you)?
10:05:51 <cjb> ok.  so it's not true to say that any function with a monad in its type signature is impure -- can the compiler prove that such a function is pure, given the function?
10:06:00 <EvilTerran> LoganCapaldo, well, it presents a pure interface. but i'm sure there's someone willing to argue the same about IO :P
10:06:06 <cjb> Sorry, I know my questions show a lack of understanding.
10:06:11 <shachaf> Every monad is pure.
10:06:15 <LoganCapaldo> Heck, I could be that someone <g>
10:06:20 <shachaf> Executing some, like IO, may not be. :-)
10:06:21 <Botje> cjb: if it's IO it's impure, else it's pure :)
10:06:22 <ibid> cjb: as i said, anything that's not in IO is pure
10:06:34 <ibid> cjb: and, of course, IO can also be viewed as a pure thing
10:06:44 <ibid> cjb: (though that takes a bit of fiddling:)
10:07:02 <shachaf> cjb: Some nice monads to start with may be Maybe and [].
10:07:14 <shachaf> cjb: And then Reader/State/Writer.
10:07:23 <LoganCapaldo> EvilTerran:  think there's a difference though, the result of getArgs can be different between runs for instance, you don't get that kind of thing with ST
10:07:31 * shachaf would save IO for later... It's somewhat magical.
10:07:32 <cjb> shachaf: Thanks.
10:07:39 <LoganCapaldo> (or do you?)
10:08:06 <cjb> is it somehow worse to write pure monadic code than pure non-monadic code?
10:08:08 <Saizan> we should talk about referential transparency rather than "pureness", maybe
10:08:38 <Botje> cjb: monads generally simplify code.
10:08:43 <EvilTerran> LoganCapaldo, "between runs" is an implementation detail ;)
10:08:44 <cjb> For example, if I write my map/etc code using the list monad/guards/return, does that lose something over a functional definition?
10:08:49 <shapr> cjb: You could say that code in C has an implicit IO signature.
10:08:55 <ibid> Botje: they can also complicate code
10:08:59 <Saizan> cjb: IO can have all the side-effects you want, so it's harder to think about what the code does
10:09:04 <Botje> ibid: hence the generally :)
10:09:10 <thoughtpolice> dcoutts_: ah, thanks for the big tip. :) i'll recompile my all my stuff and cabal-install.
10:09:12 <ibid> Botje: generally means always ;)
10:09:28 <Botje> generally only generally means always :)
10:09:31 <cjb> Botje: This is why I'm confused; it sounds like monads are suddenly a very positive thing, even better to write than non-monadic code, and I'd thought of monads as a last resort for encapsulating state.
10:09:33 <ibid> haha
10:09:49 <Botje> cjb: of course they are
10:09:59 <cjb> of course they are which?
10:10:05 <dcoutts_> thoughtpolice: cabal-install should be enhanced to detect this situation and do the right thing, but we cannot do it until ghc-6.8.3 since we cannot quickly find out what the dependencies of the existing packages are.
10:10:14 <Botje> monads are good for you
10:10:18 <Botje> (and the environment)
10:10:25 <thoughtpolice> dcoutts_: good to know. i've wanted cabal-install for a while anyway.
10:10:28 <dcoutts_> because ghc-pkg describe is far too slow if you have to call it for every package in the db.
10:10:30 <Apok>  http://www.aquabase.org/member/album/picture.php3?pic=89249
10:10:33 <Botje> > let advance = do { (line, col, (c:cs)) <- get; put (line,col+1,cs); return c } in runState (advance>>advance>>advance) (1,0,"foobar")
10:10:33 <lambdabot>  ('o',(1,3,"bar"))
10:10:34 <ibid> cjb: don't use monads unnecessarily, but don't avoid them unnecessarily
10:10:39 <Apok>  HOT GIRL : http://www.aquabase.org/member/album/picture.php3?pic=89249
10:10:41 <ibid> i think that's a good rule of thumb
10:10:47 <Botje> Apok: what's her monad?
10:10:50 <Saizan> cjb: they are positive and help hiding repetitive patterns, but writing in monadic style can oversequenzialize your computation, and it general feels less functional
10:11:05 <dcoutts_> who's an Op here? I always forget
10:11:06 <cjb> ibid: it might a good rule of thumb if it actually told me something, instead of telling me that you know when to use monads and I don't :)
10:11:18 <Apok>  http://www.aquabase.org/member/album/picture.php3?pic=89249
10:11:21 <mauke> @where ops
10:11:22 <lambdabot> shapr cale glguy dons sjanssen
10:11:26 <dcoutts_> ah :-)
10:11:27 <shapr> ooh
10:11:29 <shachaf> sorear, also.
10:11:36 <cjb> Saizan: And is there a non-aesthetic disadvantage to being less functional?
10:11:40 <ibid> cjb: it tells you that i don't regard them as evil, nor as a silver bullet :)
10:11:57 <ibid> cjb: my real rule of thumb is, use what makes the code better
10:11:59 <LoganCapaldo> EvilTerran: I think someone could argue that ST is pure and IO is not, or that ST is not pure and IO is not pure, or that both ST and IO pure.  The one combination I don't think would fly would be ST is not pure and IO is. Not that that's what you were arguing.
10:12:03 <sorear> wait, I'm an op?
10:12:04 --- mode: ChanServ set +o shapr
10:12:09 <shachaf> sorear: Aren't you?
10:12:15 <ibid> cjb: seeing what makes the code better may need writing it both ways and seeing what happens
10:12:28 <EvilTerran> LoganCapaldo, i can work with that, yeah :)
10:12:29 * shachaf remembers sjanssen changing that in Chanserv.
10:12:32 <shachaf> (I think?)
10:12:35 <sorear> Oh, I am.  Wow, I'd forgotten.
10:13:43 <dcoutts_> @where+ ops shapr cale glguy dons sjanssen sorear
10:13:43 <lambdabot> Done.
10:13:47 <dcoutts_> @where ops
10:13:47 <lambdabot> shapr cale glguy dons sjanssen sorear
10:14:02 <shachaf> @where+ ops shapr Cale glguy dons sjanssen sorear
10:14:02 <lambdabot> It is forever etched in my memory.
10:14:20 <sclv> @where wolf
10:14:20 <lambdabot> Aroooooo!
10:14:26 <sclv> never gets old.
10:14:33 * LoganCapaldo wants @where ops to respond with, "Right here!" and for lambdabot to kick the person who asked
10:14:34 <LoganCapaldo> :)
10:14:47 <RayNbow> /cs access #haskell list <-- don't type this unless you want to get spammed by ChanServ :p
10:14:55 -ChanServ(ChanServ@services.)- shapr!i=shae@209-150-60-165.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com ACCESS [#haskell] ADD dcoutts 39
10:15:17 <ibid> oh wow. chanserv announces such changes
10:15:20 <ibid> when did that happen
10:15:21 <shachaf> dcoutts_: Now you'll have to change your nick... :-)
10:15:25 <dcoutts_> heh
10:15:31 <shapr> ibid: It's been that way as long as I can remember.
10:15:32 <Saizan> cjb: one advantage of the functional paradigm is that data dependencies are evident, so it's easier to refactor your code
10:15:38 <Heffalump> presumably it's tied to identification, not to actually current nick
10:15:38 * LoganCapaldo has a twisted sense of humor
10:15:38 <dcoutts_> shapr: I've no idea how to use the power :-)
10:15:42 <shapr> ibid: I turned that on way early.
10:15:46 <Heffalump> you can ask chanserv to op you
10:15:50 <shachaf> dcoutts_: /msg chanserv help
10:15:58 <ibid> shapr: oh, it's a channel-specific setting
10:16:11 <ibid> shapr: i was wondering why i hadn't seen that on those channels that i admin :)
10:16:20 <shapr> ibid: Yeah, channel specific
10:17:06 --- mode: ChanServ set +o dcoutts_
10:17:24 <LoganCapaldo> let the carnage begin!
10:17:25 -ChanServ(ChanServ@services.)- shapr!i=shae@209-150-60-165.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com ACCESS [#haskell] ADD Saizan 39
10:17:26 <LoganCapaldo> bwahahahahaha
10:17:37 <mauke> oh wow
10:17:38 <allbery_b> <Heffalump> presumably it's tied to identification, not to actually current nick
10:17:56 <kaol> I can see your at signs
10:17:58 <shachaf> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan
10:17:58 <lambdabot> I will remember.
10:18:01 <Saizan> uoh
10:18:09 <mauke> yay, more ops
10:18:15 <allbery_b> it is.  confused a few people when I was added and chanserv rewrote it to my primary (for historical reasons) nick
10:18:17 <shapr> Saizan: With great power comes great responsibility.
10:18:20 <shapr> Or something
10:18:20 --- mode: ChanServ set -o dcoutts_
10:19:02 <Saizan> shapr: heh :)
10:19:52 <sorear> this is #haskell, we could op *!*%* and probably nothing bad would happen
10:20:03 <Saizan> it's easy to operate here anyway, just show the trolls the exit
10:20:13 <thoughtpolice> dcoutts_: just thought of this; what about support for searching hackage from cabal-install? i.e. cabal search <pkg>.
10:20:21 <shapr> sorear: Probably so, but htat comes from removing the occasional bad apple.
10:20:32 <thoughtpolice> dcoutts_: thanks btw, just had to rebuild zlib and cabal-install built flawlessly :)
10:20:33 <dcoutts_> thoughtpolice: it's called: cabal list foo
10:20:42 <thoughtpolice> dcoutts_: ah okay. i'm dumb. :)
10:20:49 -ChanServ(ChanServ@services.)- shapr!i=shae@209-150-60-165.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com ACCESS [#haskell] ADD quicksilver 39
10:21:02 <dcoutts_> thoughtpolice: what it doesn't do yet is list local packages :-)
10:21:03 <shachaf> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan eviltwin_b dibblego conal Phillipa bos arjanb psnl lispy xero vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:21:03 <lambdabot> Nice!
10:21:10 <shapr> heh
10:21:10 <hpaste>  travisbrady pasted "GHCi problem with backspace/del key" at http://hpaste.org/5265
10:21:37 <allbery_b> you might avoid confusion there by s/eviltwin_b/allbery_b/ :)
10:21:42 <sclv> zounds
10:21:44 <travisbrady> has anyone seen a problem where after building ghc the backspace key just prints "^?"
10:22:00 <shapr> quicksilver: Are you Julian Seward?
10:22:02 <allbery_b> ghc built without readline, sounds like
10:22:03 <shachaf> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:22:03 <lambdabot> It is forever etched in my memory.
10:22:04 <shapr> @seen quicksilver
10:22:04 <lambdabot> quicksilver is in #ghc and #haskell. I last heard quicksilver speak 1d 3h 32m 44s ago.
10:22:10 <shachaf> shapr: Jules Bean.
10:22:25 <shapr> Ah
10:22:27 <sclv> travisbrandy: what terminal are you using?
10:22:28 <shapr> Thanks
10:22:31 <LoganCapaldo> travisbrady: That smells like a mis-configured terminal
10:22:41 <LoganCapaldo> what if you hit Ctrl-H ? :)
10:22:52 <travisbrady> sclv: i'm running bash on mac os 10.5.1
10:22:59 <radix> does it use readline? I don't know about ghc, but that's a common problem when a program hasn't properly linked or imported readline or whatever.
10:23:14 <allbery_b> ghc / ghci links to -lreadline, yes
10:23:22 <travisbrady> Ctrl-H yields "asdfasdfasdf^H^H^H"
10:23:25 <allbery_b> and readline issues are quite common on leopard
10:23:30 <radix> yeah, and that's *quite* a common problem on mac os
10:23:36 <radix> because of issues with readline on that platform
10:23:50 <radix> (i.e., it doesn't have it :)
10:23:53 <travisbrady> could it be as simple as "--with-readline-include"?
10:23:57 <LoganCapaldo> travisbrady: did you bring your own realdine?
10:23:58 <allbery_b> add some new linker issues on leopard even if you have a real readline
10:24:07 <LoganCapaldo> arg
10:24:10 <LoganCapaldo> I can't type
10:24:12 <allbery_b> travisbrady: the supplied readline is actually BSD editline, and won't work
10:24:41 <allbery_b> you need to install a real GNU readline and then make sure ghc links to it instead of the system "readline"
10:24:55 <sclv> my impression is that the binaries for os x are excellent and folks shouldn't generally need to build their own ghc anyway.
10:25:01 <pejo> allbery, that was patched recently, but probably not in 6.8 branch.
10:25:03 <travisbrady> LoganCapaldo: i have GNUReadline, but i'm not sure if the build knew that
10:25:28 <allbery_b> there's no standard place for it, so if you're building manually you will need to point to it
10:25:41 <travisbrady> sclv: i tried using them but I get tons of "can't load .so/.DLL for: dl (dlopen(libdl.dylib, 10): image not found)" kind of stuff
10:25:42 <LoganCapaldo> what allbery_b said
10:27:18 <travisbrady> do i use --with-readline-includes and -libraries?
10:27:25 <allbery_b> (private builds use /usr/local, macports uses /opt/local, fink uses /sw/local ...)
10:27:28 <allbery_b> yes
10:28:05 <LoganCapaldo> s//sw/local//sw/ fwiw
10:28:17 <LoganCapaldo> masn that was a confusing regexp
10:28:30 <LoganCapaldo> I shoulda used different delimiters
10:28:41 <shachaf> LoganCapaldo: It wasn't even valid.
10:28:58 <shachaf> LoganCapaldo: Either that (preferable), or escape your slashes.
10:29:07 <LoganCapaldo> you guys are good dwim parsers though :)
10:29:22 <allbery_b> er, yeh, not /sw/local.  feh
10:32:43 <quicksilver> shapr: no :)
10:32:56 <quicksilver> shapr: AFAIK my whois tells the truth :)
10:45:22 <Cin> 179  isChan chan = case matchRegex (mkRegex chanRegex) chan of
10:45:22 <Cin> 180                  Just _ -> True
10:45:22 <Cin> 181                  Nothing -> False
10:45:30 <Cin> is there a function which does this for me? :)
10:45:40 <mauke> @hoogle Maybe a -> Bool
10:45:41 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
10:45:41 <lambdabot> Data.Maybe.isNothing :: Maybe a -> Bool
10:45:49 <Cin> awesome. thankyou!
10:45:58 <Cin> i'd totally forgotten about hoogle<3
10:52:16 <hpaste>  Feuerbach pasted "my xmonad.hs" at http://hpaste.org/5266
10:53:16 <Feuerbach> hm.. hpaste should be more intelligent to guess I want announce at #xmonad :)
10:54:15 <litb> if i have "module Funktion where"
10:54:23 <litb> do i have to indent everything after that?
10:54:27 <dmwit> no
10:54:31 <litb> i do not do that, and it doesn't error out
10:54:44 <litb> but what confuses me is that haskell-mode indents it
10:55:09 <dmwit> The "where" is probably confusing it.
10:55:36 <dmwit> (Though I'm a vim guy, so I can't say anything for sure.)
10:56:40 <litb> ok. indenting it is completely optional?
10:56:48 <litb> but that is only the case for module, is it?
10:57:11 <mauke> no
10:57:55 <litb> hm
10:59:21 <dmwit> As I recall, the Report has a tolerable explanation of indentation.
10:59:36 <monochrom> Yes.
11:00:04 <dmwit> http://www.haskell.org/onlinereport/lexemes.html#sect2.7
11:00:05 <lambdabot> Title: Haskell 98 Lexical Structure
11:00:43 <monochrom> I learned indentation from that, plus the gentle introduction, plus folklore.
11:05:03 <litb> hm, looks like module files should have upper-case starting letters
11:05:45 <EvilTerran> yes
11:09:11 <dons> ?users
11:09:11 <lambdabot> Maximum users seen in #haskell: 449, currently: 431 (96.0%), active: 12 (2.8%)
11:11:04 <dmwit> This channel seems to grow pretty quickly.
11:11:44 <litb> yeah, that's nice :)
11:11:53 <litb> haskell will pwn freenode soon
11:12:21 <dmwit> FreeNode?  You set your sights too low! ;-)
11:12:31 <dmwit> Today FreeNode, tomorrow the world!
11:12:41 <litb> lolz
11:13:03 <litb> when we have more users than ##c++ , i think that will be the first milestone :)
11:14:05 <LoganCapaldo> Is ghc the most portable haskell compiler? (and by portable, I'm more interested in "easy to port" and less interested in "happens to be the one that runs on the most platforms", if those criteria happen to not overlap)
11:16:21 <oerjan> LoganCapaldo: more like the least portable, iiuc
11:17:39 <ibid> LoganCapaldo: hugs is probably the most portable, but it's an interpreter
11:17:45 <oerjan> several others are bytecode compilers, which i think is much easier?
11:19:02 <litb> hm, does ghc run on windows?
11:19:03 <Eiler> how do i see the runtime of a program or a function?
11:19:10 <dons> litb: sure.
11:19:15 <dons> its funded by MSR after all.
11:19:35 <dons> Eiler: can you elaborate?
11:20:05 <Eiler> sure, i mean to how long it took to run the program... as to measure its speed
11:20:10 <jorgedbucaran> hi folks
11:20:14 <dons> ah, runtime profiling.
11:20:17 <jorgedbucaran> a quick one
11:20:31 <Eiler> could be
11:20:32 <dons> you want profiling info for all the functions in the program, Eiler ?
11:20:40 <dons> or just manually time an individiual function?
11:20:51 <jorgedbucaran> my_length (x:xs) = 1 + my_length xs
11:20:54 <dons> anyway, for the whole program, ghc -O -prof -auto-all
11:20:58 <dons> will compile in profiling
11:21:03 <dons> then at runtime: ./a.out +RTS -p
11:21:05 <jorgedbucaran> I understand what is going on.
11:21:13 <jorgedbucaran> but that (x:xs)
11:21:15 <dons> will create a *.prof file with timing and allocation info
11:21:15 <Eiler> okay
11:21:19 <jorgedbucaran> why is it between parenthesis?
11:21:26 <oerjan> jorgedbucaran: precedence
11:21:26 <jorgedbucaran> why is it using the cons op?
11:21:29 <dons> look at the section on 'profiling' in the ghc user's guide. its quite sophisticated
11:21:33 <jorgedbucaran> exactly
11:21:36 <shachaf> jorgedbucaran: Otherwise it would be parsed as (my_length x) : xs = 1 + my_length xs
11:21:37 <jorgedbucaran> why in this case?
11:21:45 <dmwit> jorgedbucaran: Otherwise, it would try to match x, (:), and xs as three separate patterns.
11:21:47 <jorgedbucaran> (x:xs) => [x]
11:21:49 <jorgedbucaran> ?
11:21:51 <LoganCapaldo> So is hugs written mostly in C?
11:21:55 <dmwit> jorgedbucaran: no...
11:22:01 <dons> LoganCapaldo: yeah
11:22:03 <jorgedbucaran> please enlight me
11:22:09 <litb> jorgedbucaran: it is patter matching
11:22:11 <shachaf> jorgedbucaran: (Which isn't even valid, but if it was, it would be something like trying to define (:).)
11:22:16 <shachaf> jorgedbucaran: (:) is cons.
11:22:21 <dmwit> (x:xs) => [x] ++ xs
11:22:24 * LoganCapaldo tries to decide if the juice is worth the squeeze
11:22:25 <buc> aha
11:22:33 <shachaf> jwp: (x:xs) means a list whose first element is xs and the rest of whose elements are xs.
11:22:33 <oerjan> > let x:xs = [1,2,3] in "x is: " ++ show x ++ " and xs is: " ++ show xs
11:22:36 <lambdabot>  "x is: 1 and xs is: [2,3]"
11:22:49 <LoganCapaldo> Hugs has support for the FFi right?
11:22:54 <LoganCapaldo> *FFI
11:23:00 <dons> LoganCapaldo: yep
11:23:07 <litb> same as (Just 5)  creates a data of datatype Maybe , (x:xs) creates a list . but myFunc (Just x) = x; gets the data that is wrapped by the Just . the same applies to your function
11:23:07 <jdb> ok folks
11:23:11 <dons> hey jdb
11:23:13 <jdb> x:xs
11:23:17 <jdb> why x and xs?
11:23:25 <jdb> can it be something else? a : as
11:23:26 <dmwit> They're just names.
11:23:28 <dmwit> yeah
11:23:29 <dons> it deconstructs the (:) constructor, and names the parts.
11:23:32 <dons> you can use any names
11:23:36 <jdb> ok
11:23:49 <litb> you have to distinguish between the use of types in pattern matching, and in constructing jdb
11:24:00 <dmwit> It is idiomatic to use "something" and its plural when looking at the head and tail of a list.
11:24:00 <jdb> > foo (x:xs) = foo xs
11:24:00 <lambdabot>  Parse error at "=" (column 12)
11:24:02 <dons> note that 'xs' is plural
11:24:07 <LoganCapaldo> Sorry to keep up with these, but hugs can run quickcheck etc. right?
11:24:10 <dons> since its the rest of the list, while 'x' is the first element
11:24:11 <shachaf> jdb: You can have (xs:x), if you like. :-)
11:24:14 <dons> LoganCapaldo: it can, yep
11:24:21 <jdb> alright
11:24:23 <jdb> is just convention
11:24:30 <dmwit> right
11:24:30 <dons> yep. going back many years
11:24:32 <LoganCapaldo> hmm maybe it is worth it
11:24:34 <jdb> foo x:xs = 1 + foo xs
11:24:37 <jdb> what happens there?
11:24:39 <dons> LoganCapaldo: what are you looking to do?
11:24:39 <jdb> what is the problem there?
11:24:46 <dons> missing parens
11:24:50 <shachaf> jdb: It parses as (foo x):xs = 1 + foo xs
11:24:58 <LoganCapaldo> haskell on VMS as tool for testing some stuff
11:25:00 <jdb> mmmmmm
11:25:01 <shachaf> jorgedbucaran: (Which isn't even valid, but if it was, it would be something like trying to define (:).)
11:25:02 <jdb> thanks shachaf
11:25:03 <dons> > let foo [] = 0 ; foo (x:xs) = 1 + foo xs  in foo "haskell"
11:25:04 <lambdabot>  7
11:25:14 <jdb> huh
11:25:31 <dons> LoganCapaldo: ok. note that hugs is 40x slower than ghc (or more), if that's an issue. its definitely smaller and lighter though
11:25:39 <jdb> the problem is this
11:25:40 <dons> and supports enough modern haskell to be very usable
11:25:43 <jdb> foo arguments
11:25:54 <jdb> I can pass any num of arguments to my foo function right?
11:25:55 <litb> foo 0 = 1; foo x = 4;
11:26:00 <litb> do you understand that, jdb?
11:26:05 <dmwit> jdb: Right, that's exactly the problem.
11:26:06 <jdb> how come in the declaration of the function I can pass the consing of two things?
11:26:07 <shachaf> jdb: Just one in this case.
11:26:09 <jdb> (yes)
11:26:13 <dons> jdb: it takes a single list as an argument
11:26:16 <jdb> oh no
11:26:19 <jdb> yes
11:26:22 <jdb> yes
11:26:22 <shachaf> jdb: It's one data-type that contains two things.
11:26:23 <jdb> haha sorry
11:26:27 <shachaf> jdb: (The head and the tail.)
11:26:31 <jonaskoelker> quick IO question: I have "let foo = ... \n <I wanna print foo here> in frob foo", how do I print foo?
11:26:39 <jdb> mmmm
11:26:43 <shachaf> jonaskoelker: For debugging?
11:26:45 <dons> its cool. haskell lets you take apart structs in the syntax :)
11:26:46 <jonaskoelker> yeah
11:26:46 <litb> @src isJust
11:26:46 <lambdabot> isJust Nothing = False
11:26:46 <lambdabot> isJust _       = True
11:26:50 <litb> see that jdb
11:26:59 <litb> oh, that was a bad example
11:26:59 <shachaf> jonaskoelker: You might want to look at Trace.
11:27:10 <dmwit> jonaskoelker: Well, there's Debug.Trace, but it's unclean... =P
11:27:12 <shachaf> jonaskoelker: (Debug.Trace.)
11:27:12 <litb> @src fromJust
11:27:12 <lambdabot> fromJust Nothing  = undefined
11:27:12 <lambdabot> fromJust (Just x) = x
11:27:15 <litb> that one is better
11:27:18 <davidL> @index asks
11:27:18 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
11:27:21 <LoganCapaldo> dons: I don't expect speed to be an issue. My other choice was to be to write my own language (and I am not a compiler guru)
11:27:26 <shachaf> jonaskoelker: Note that this is only good for debugging.
11:27:36 <jdb> so how do I call foo?
11:27:42 <shachaf> jdb: "foo 5"
11:27:44 <dons> LoganCapaldo: first rule: never write your own language :)
11:27:44 <dmwit> foo [1, 2, 3]
11:27:45 <jdb> in this case: foo (x:xs) = 1 + foo xs
11:27:55 <dons> at a minimum, embed it in one that's had a lot of work done
11:27:56 <dmwit> foo list
11:27:58 <litb> @let foo (x:xs) = xs
11:28:00 <lambdabot> Defined.
11:28:05 <litb> > foo [1, 2, 3, 4]
11:28:06 <lambdabot>  [2,3,4]
11:28:07 <jdb> @let foo (x:xs) = 1 foo xs
11:28:07 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
11:28:09 <dons> anyone had an experience with expat?
11:28:16 <jdb> @let foo (x:xs) = 1+ foo xs
11:28:16 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
11:28:19 <litb> @undefine
11:28:20 <lambdabot> Undefined.
11:28:21 <dons> you'll need to undefine
11:28:29 <jdb> @undefined
11:28:29 <lambdabot> Undefined.
11:28:36 <jdb> @let foo (x:xs) = 1 + foo xs
11:28:36 <lambdabot> Defined.
11:28:42 <jdb> > foo 5
11:28:42 <lambdabot>   add an instance declaration for (Num [t])
11:28:44 <dmwit> ?let foo [] = 0
11:28:44 <lambdabot> Defined.
11:28:53 <jdb> foo [1,2]
11:28:59 <jdb> > foo [1,2]
11:29:00 <dmwit> > foo [1, 2]
11:29:00 <lambdabot>  2
11:29:00 <lambdabot>  2
11:29:11 <jdb> > foo [1]
11:29:12 <lambdabot>  1
11:29:15 <shachaf> jdb: [1,2] is just an abbreviation for (1:(2:[]))
11:29:16 <jdb> > foo []
11:29:16 <lambdabot>  0
11:29:22 <jdb> > foo 5
11:29:23 <lambdabot>   add an instance declaration for (Num [t])
11:29:29 <dmwit> > let list = [1..10] in foo list
11:29:29 <jdb> > foo ""
11:29:30 <lambdabot>  10
11:29:30 <lambdabot>  0
11:29:38 <jdb> > foo ""
11:29:39 <lambdabot>  0
11:29:48 <jdb> > "" == []
11:29:49 <lambdabot>  True
11:29:58 <jdb> @sixen cool!
11:29:58 <lambdabot> how cool?
11:30:04 <litb> no '\n' there :p
11:30:05 <jdb> @sixen big time!
11:30:05 <lambdabot> I've gotta snake, man!
11:30:12 <shachaf> > "" `asTypeOf` []
11:30:13 <lambdabot>  ""
11:30:16 <jdb> cya folks
11:30:16 <dmwit> ?vixen is her real name =)
11:30:16 <lambdabot> eh?
11:30:17 <dons> if you want to experiment, you can also do it in a privmsg session with lambdabot :)
11:30:19 <jdb> thanks
11:30:22 <dons> cool jdb
11:30:25 <dons> glad we could help
11:30:41 <lispy> :t asTypeOf
11:30:43 <lambdabot> forall a. a -> a -> a
11:30:48 <lispy> now that's a function i always forget about
11:30:51 <dmwit> ?sexen is this clase enough?
11:30:51 <lambdabot> I haven't seen is.
11:30:58 <dmwit> lispy: It's const... =P
11:31:17 <lispy> :t asTypeOf 1
11:31:17 <lambdabot> forall t. (Num t) => t -> t
11:31:25 <lispy> hmm
11:31:29 <litb> > asTypeOf 10
11:31:30 <lambdabot>  <Integer -> Integer>
11:31:32 <litb> tarn
11:31:33 <shachaf> @ty (return 1)
11:31:33 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
11:31:39 <litb> > asTypeOf 10 5
11:31:40 <lambdabot>  10
11:31:42 <shachaf> @ty (return 1) `asTypeOf` [1]
11:31:42 <lambdabot> forall t. (Num t) => [t]
11:31:43 <jonaskoelker> shachaf, dwit: so you're saying "let foo = ... \n foobar = (Debug.Trace.trace) (show foo) 0 in foo" should work?  AFAICT, it doesn't
11:31:54 <dons> mm, xmonad looking like fluxbox, http://gorgias.mine.nu/xmonadShots/gimpFloatingAroung.png :)
11:32:05 <shachaf> jonaskoelker: You have to evaluate foo.
11:32:15 <dmwit> jonaskoelker: Only if foobar is evaluated.
11:32:18 <litb> > (fromJust . Just) 8
11:32:19 <lambdabot>  8
11:32:22 <shachaf> jonaskoelker: Remember it's all lazy. :-)
11:32:26 <litb> ah nice. you can also use it with ctors?
11:32:31 <dmwit> jonaskoelker: That's why I said it was unclean.
11:32:34 <cjb_> Hm, I would like to write a Haskell program today.  The problem is always finding something to write :)
11:32:39 <jonaskoelker> so, how do I evaluate it?
11:32:41 <LoganCapaldo> dons: madness! :)
11:32:48 <lispy> litb: ctors are just functions....well functions that don't bind as tight as they should
11:32:54 <dmwit> litb: Sure, constructors are just special functions! =)
11:33:23 <lispy> litb: and GADTs (a GHC extension) allows you to specify your ctors by their type signature
11:33:28 <dmwit> jonaskoelker: Well... I guess you could use seq.
11:33:34 <augustss> cjb_: you could write a compiler, it's usually fun
11:33:51 <litb> so i can change my function in "simpleFunction = flip Function Nothing" i suppose
11:34:06 <lispy> augustss: please create more blog posts in your type checking section, I like them :)
11:34:31 <yoshi> does anyone know of a relevant wiki page for rendering text/css
11:34:34 <litb> (it is data Function = Function (Double->Double) (Maybe Function)
11:34:47 <monochrom> What is needed to be said on type checking?
11:34:47 <jonaskoelker> dmwit: hmm.. where would be the opportune place to do that?  I don't wanna change the return type, so it can't be in the return value; I could put it in a tuple with the return value and only pull out the return value, but that would not lead anywhere, as far as my understanding goes
11:34:53 <vincenz> lispy: link?
11:35:07 <litb> oh no that isn't possible :/
11:35:15 <dmwit> jonaskoelker: ... in foobar `seq` foo
11:35:15 <lispy> vincenz: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
11:35:16 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
11:35:17 <shachaf> jonaskoelker: You just have to use the value sometime.
11:35:41 <litb> ah, it works :)
11:35:43 <vincenz> lispy: http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
11:35:45 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
11:35:47 <vincenz> :)
11:35:54 <augustss> lispy: I have something untyped I've been planning to blog about, but I've been too lazy
11:36:00 <lispy> vincenz: lol, i have that one open also
11:36:27 <magth> possibly silly question, why does ':t tell . (++ "\n")' work in GHCi, but not 'let tellLn = tell . (++ "\n")' ?
11:36:29 <lispy> augustss: well, I haven't finished the link I just pasted, so i guess you have at least that long ;)
11:36:43 <shapr> @yow
11:36:43 <lambdabot> The FALAFEL SANDWICH lands on my HEAD and I become a VEGETARIAN ...
11:36:52 <cjb> wow, it's totally true
11:36:56 <Joreji> Hey, can anyone tell me whether I'm right to believe, that the function type of "g x = if True then \y -> y else \xs -> x:xs" is: "g :: a -> [a] -> [a]" ?
11:37:01 <cjb> falafel sandwiches *are* the coolest thing about being vegetarian
11:37:18 <lispy> Joreji: homework?
11:37:21 <litb> guys, one question:
11:37:22 <Joreji> yes
11:37:32 <dmwit> magth: Maybe because of the monomorphism restriction?
11:37:37 <litb> is it possible to hide one symbol in a module?
11:37:39 <lispy> Joreji: start with the pieces of the 'then' and 'else'
11:37:40 <dmwit> magth: :t tell
11:37:43 <litb> i.e prevent it form being exported?
11:37:46 <litb> *from
11:37:52 <dmwit> litb: hiding (whatever)
11:37:56 <lispy> Joreji: what is the type of \y -> y?
11:38:01 <Joreji> a function
11:38:06 <dmwit> litb: Oh, from being *exported*.
11:38:16 <dmwit> litb: Just don't specify it in the export list.
11:38:22 <lispy> Joreji: there are lots of funtions though, can you be more specific?
11:38:31 <Joreji> an anonymous function
11:38:37 <monochrom> The type of \y -> y is flexible and can be specialized to be compatiable with \xs -> x:xs
11:38:42 <Joreji> with one parameter that can have an arbitrary type
11:38:57 <magth> dmwit, it tells me I need an instance of 'MonadWriter [Char] m', but 'execWriter (tell . (++ "\n") $ "hello")' works just fine
11:38:58 <lispy> Joreji: right, so in haskell syntax how would you write that type?
11:39:05 <litb> dmwit: but then, i have to specify all others
11:39:11 <Joreji> um a -> a
11:39:20 <lispy> Joreji: right
11:39:27 <monochrom> Don't re-use the letter a.  Write b->b.
11:39:28 <dmwit> litb: yes, sorry
11:39:37 <litb> rly no other way?
11:39:54 <Joreji> monochrom: hm okey... but I didn't use a yet... I think
11:39:59 <lispy> Joreji: and, the part \xs -> x : xs, has what type?
11:40:11 <litb> well does this work: FunctionImpl , and in Function import FunctionImpl hiding(something) , and then one can import Function as usual?
11:40:33 <Joreji> lispy: That should be [b] -> [b]
11:41:00 <Joreji> with b being the same type x has
11:41:07 <lispy> Joreji: right
11:41:14 <dmwit> magth: I'm having trouble following you... can you hpaste a transcript of you GHCi session or something?
11:41:26 <magth> dmwit, sure
11:41:47 <lispy> Joreji: now, you said that \y -> y :: a -> a, right?
11:42:14 <Joreji> yes
11:42:18 <lispy> Joreji: and for that function g, to make sense, both parts of the if-expression have to return the same type, right?
11:42:27 <hpaste>  magth pasted "Problems to tell" at http://hpaste.org/5267
11:42:38 <Joreji> hmm... yes
11:42:50 <lispy> Joreji: what is a substitution for a that satisfies the contraint of the if-expression?
11:43:03 <conal> magth: the first use provided IO as m, while the second didn't
11:43:05 <Joreji> that would be [b]
11:43:15 <lispy> Joreji: right, so do you know the type of g, now?
11:43:20 <conal> @type execWriter
11:43:21 <lambdabot> forall w a. Writer w a -> w
11:43:26 <magth> conal, ah, ok
11:43:33 * shapr boings
11:43:49 <magth> conal, due to implicit 'print' I guess
11:43:50 <Joreji> so, just like I said... it's b -> [b] -> [b] ?
11:44:00 <lispy> Joreji: right, but now you see why, right?
11:44:32 <sclv> alternately:
11:44:34 <Joreji> yeah... actually I already did those steps earlier... just wasn't too sure (and the thing about each block of if-expressions returning the same value is new to me)
11:44:42 <Joreji> thanks a lot
11:44:42 <sclv> ?ty \x -> if True then \y -> y else \xs -> x:xs
11:44:43 <dmwit> :t tell
11:44:43 <lambdabot> forall a. a -> [a] -> [a]
11:44:44 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
11:44:56 <lispy> Joreji: you're welcome, sounds like Haskell is making sense to you already :)
11:45:28 <cariaso> all: How can I write a conditional for  if "at least 5 of these 7 tests pass"?
11:45:47 <Lemmih> shapr: How's life?
11:46:22 <byorgey> cariaso: something like \tests -> length (filter id tests) >= 5  ?
11:46:24 <Joreji> lispy: More or less, yeah. Though I still don't see the total benefits of the language :) - But then again, mayble that time will come one day (I'm learning haskell for university)
11:46:32 <sclv> > sum [1 | x <- [True, True, False], x]
11:46:33 <lambdabot>  2
11:46:37 <dmwit> > (>= 5) . length . filter id $ [True, True, True, True, True]
11:46:37 <lambdabot>  True
11:46:49 <litb> (length $ filter hasPassed testList) > 4 ?
11:46:55 <phlpp> > tell 1 [2,3]
11:46:56 <lambdabot>        add an instance declaration for (MonadWriter t ((->) [t1]))
11:46:56 <lambdabot>     In the...
11:47:00 <phlpp> oh :>
11:47:09 <phlpp> missed the second line of the def.
11:47:22 <lispy> Joreji: well, when you first start with haskell the type checker can be obnoxious, then you have to learn monads (really not as confusing as people think) and then you can make use of haskell and that's when you finally see the benefits.
11:47:56 <Joreji> heh, I doubt we're going to see monads here anytime soon :)
11:48:14 <lispy> Joreji: right, at my university monads was the second term of haskell
11:48:17 <Joreji> though I did already read an article on them
11:48:20 <monochrom> Types are elegant and powerful.
11:48:28 <litb> Joreji: if you try hard, you can get to them within one week =)
11:48:33 <lispy> monochrom: so are sets! ;)
11:48:57 <monochrom> Sets get hairy.
11:49:04 <litb> o.O
11:49:19 <idnar> monochrom: I think you get depilatory agents for that
11:49:21 <litb> concat them off :p
11:49:28 <Joreji> litb: I'm sure one can do that :)
11:49:54 <Joreji> But here, already 2/3 didn't pass the first test on java ^^
11:50:02 <dmwit> magth: Not sure, sorry...
11:50:18 <Joreji> I don't think they want to make life on those people any more difficult ^^
11:50:26 <dmwit> ?instances MonadWriter
11:50:27 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
11:50:49 <magth> dmwit, no worries...
11:50:53 <litb> ?confuse
11:50:54 <lambdabot> Unknown command, try @list
11:51:26 <magth> I'll just have to think a bit about Writer to see if I can figure out how to use it
11:51:32 <dmwit> magth: Ah, I see.
11:51:35 <lispy> Joreji: if you really want to get ahead of your class, with respect to haskell, just read the Haskell 98 report :)
11:51:38 <dmwit> magth: Try this:
11:51:49 <lispy> ?where report
11:51:50 <lambdabot> http://www.haskell.org/onlinereport/
11:51:55 <monochrom> I would read the gentle introduction.
11:52:00 <dmwit> let tellLn = tell . (++"\n") :: String -> Writer String ()
11:52:15 <Joreji> lispy: I'll take a look at it, thanks :)
11:52:20 <litb> i read yaht but i must say i like tgi much more
11:52:25 <dmwit> magth: The unspecified type is too general.
11:52:46 <litb> > undefined == undefined
11:52:48 <lambdabot>  Undefined
11:53:30 <litb> @src undefined Eq
11:53:31 <lambdabot> Source not found. Are you on drugs?
11:53:53 <roconnor> @wn INTERCALATE
11:53:53 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
11:53:54 <lambdabot> intercalate
11:53:54 <lambdabot>      v : insert (days) in a calendar
11:54:00 <lispy> Joreji: oh, I was somewhat joking...the report is the language specification...might be very hard to read if you're new to haskell and programming language theory...on the other hand, if you're brave it won't hurt you :)
11:54:06 <shachaf> litb: undefined is a value, not a type.
11:54:14 <shachaf> litb: The type is forall a. a. :-)
11:54:22 <monochrom> I almost though "v : insert (days) in a calendar" was Haskell code.
11:54:26 <litb> oh i see
11:55:00 <magth> dmwit, yeah, just realised got there on my own :)
11:55:17 <flux> @djinn (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
11:55:22 <lambdabot> f a b c d = a b (c d)
11:55:39 <litb> oh that because the report really made me sad
11:55:46 <Joreji> lispy: lol, yeah, I saw already - kinda reminds me of my days trying to learn python through the language specs (which, obviously I didn't do for very long) :)
11:55:53 <Chad> @users
11:55:53 <lambdabot> Maximum users seen in #haskell: 449, currently: 438 (97.6%), active: 29 (6.6%)
11:56:11 <dmwit> I wonder what the %active record is.
11:56:19 <magth> dmwit, I do find Writer and MonadWriter to be somewhat confusing
11:56:47 <lispy> dmwit: it's people who have spoken in the last X minutes
11:56:49 <dmwit> I've never looked at them, so I can't help you.
11:56:55 <lispy> dmwit: I think it's like 4 hours
11:57:00 <litb> i think it was when the channel was funded, 100% , dmwit
11:57:11 <dmwit> lispy: Er, no, I mean, I wonder what the highest percentage ever was?
11:57:15 <monochrom> Haha it can only drop. :)
11:57:23 <dmwit> litb: Fair enough. =P
11:57:39 <litb> i think i meant founded
11:57:43 <litb> :p
11:57:45 <lispy> dmwit: oh, i see, "record" meaning best ever :) not record as in field
11:58:18 <lispy> almost 450 people, that's pretty good
11:58:36 <shachaf> lambdabot wasn't in this channel in the beginning, though.
11:58:47 <monochrom> If we didn't ban spammers and trolls and crazy people, we would get more.
11:58:55 <ibid> lambdabot did not exist in the beginning
11:58:57 <ibid> (i think)
11:59:12 <litb> shachaf just said that :p
11:59:19 <dmwit> ...lambdabot = god?
11:59:38 * LoganCapaldo skims hugs source code
11:59:42 <lispy> monochrom: only more temporarily, over a long run i think that decresease the population
11:59:56 <lispy> ?quote skynet
11:59:56 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
12:00:18 <dmwit> ?quote no
12:00:18 <lambdabot> ndm says: This is what Ada does. I think that's a reason enough to keep things the way they are.
12:00:30 <dmwit> ?quote \<no\>
12:00:31 <lambdabot> ghc says: No constructor has all these fields
12:01:07 <lispy> ?quote god
12:01:08 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
12:02:42 <dons> ?bot
12:02:42 <lambdabot> :)
12:04:51 <ibid> lambdabot: no, shachaf did not say that
12:04:51 <ibid> bah
12:04:55 <ibid> litb: no, shachaf did not say that
12:05:56 <shachaf> ibid: Not being in the channel is the relevant part, though.
12:06:31 <ibid> shachaf: ... and i was just augmenting what you said
12:06:45 <ibid> not repreating it, nor refuting it
12:06:48 <ibid> argh
12:06:48 <monochrom> shachaf did not say what?
12:07:05 <wy> Cale: model theory really seems to have to do with programming languages
12:08:01 <shachaf> < shachaf> lambdabot wasn't in this channel in the beginning, though. < ibid> lambdabot did not exist in the beginning < ibid> (i think) < litb> shachaf just said that :p
12:08:46 <vincenz> lambdabot not in channel != lambdabot does not exist
12:08:57 <monochrom> This requires modal logics to decipher.
12:09:03 <ibid> vincenz: some people evidently disagree :)
12:09:25 <monochrom> It doesn't help that a common modal operator is precisely written like <name here>. :)
12:09:31 <conal> besides, functional programming is about denoting, not creating.  values exist whether or not they've yet been denoted or examined.
12:09:31 <shachaf> vincenz: I know.
12:09:46 <shachaf> vincenz: I was saying that lambdabot's existance wasn't relevant.
12:09:53 <monochrom> IRC is a modal logic. :)
12:09:54 <shachaf> s/ance/ence/
12:10:09 * ibid shuts up before he blows up
12:10:46 <monochrom> Existence is too hard! Let's use modal logics.
12:12:30 <oerjan> monochrom: we might possibly have to do that
12:13:16 <phobes> conal:   Does that apply to 'newtype' as well?
12:13:50 <davidL> @quote 
12:13:51 <lambdabot> monochrom says: people  haskellers = 
12:14:39 <Jiten> Is there a function similar to python's split? "foo:bar:baz".split(':') which returns ["foo","bar","baz"]
12:15:01 <Zao> There's words, but that only does whitespace.
12:15:06 <dons> there's not, but its easy to write. there's some proposals to add one to the base lib
12:15:09 <Jiten> it'd be simple to make myself but I'd rather use one from the standard library if it's hidden somewhere.
12:15:13 <dons> just recursively break
12:15:26 <Jiten> I see
12:15:28 <monochrom> There are a million proposals, and they all do different things.
12:15:33 <idnar> heh
12:15:35 <dons> > break (==':') "foo:bar:baz"
12:15:37 <lambdabot>  ("foo",":bar:baz")
12:15:39 <cariaso> all: can anyone suggest a better place to ask a question about programming in CLIPS? any ex-CLIPS users here?
12:15:51 --- mode: irc.freenode.net set +o ChanServ
12:16:15 <litb> errm, yes
12:16:28 <litb> i'm sorry. apparently i have problems with basic logic
12:16:36 * idnar waves to ChanServ 
12:16:58 <idnar> I never knew ChanServ was a Haskell coder ;)
12:17:26 <dmwit> cariaso: Maybe in ##c?
12:17:29 <glguy> ?seen shapr
12:17:29 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 33m 56s ago.
12:17:40 <dmwit> cariaso: What language is it in?
12:17:43 <lisphaquer> I think ChanServ is a pretty cool guy eh codes haskell and doesn't afraid of anything
12:17:46 <phobes> IRC apps should make the noise of a lightsaber being drawn when someone asserts channel ops
12:17:52 --- mode: ChanServ set +o glguy
12:17:52 <wy> conal: What are values?
12:17:54 --- kick: glguy_ was kicked by glguy (glguy)
12:17:55 <phobes> leave the hum going while they're around
12:17:57 --- mode: glguy set -o glguy
12:18:46 <monochrom> hahaha
12:19:14 <litb> @src break
12:19:14 <lambdabot> break p =  span (not . p)
12:19:20 <monochrom> @remember phobes IRC apps should make the noise of a lightsaber being drawn when someone asserts channel ops. leave the hum going while they're around
12:19:20 <lambdabot> Nice!
12:19:29 <conal> wy: hm.  i don't know how to answer that question without circularity.  for instance, i could say it's the meanings of expressions.  but to me values are more fundamental than expressions.  (besides, expressions are values also.)
12:19:47 <glguy> Colloquy make cool op and kick noises
12:21:13 <dons> glguy: had a look at expat at all?
12:21:31 <glguy> nuh uh
12:21:32 <wy> conal: I'm just wondering if there are values in the world :)
12:21:40 <cariaso> dmit: I'm coding in python. with some CLIPS subprograms. I'm trying to make a conditional which says "if at least 5 of these 7 tests pass" then .... the simpler subtests all look like (genotype (rsnum rs3825776))     (genotype (rsnum rs3825777))
12:21:46 <dons> i'm pondering doing a bytestring expat xml parser binding for this week's commuting project.
12:22:16 <cariaso> dmwit: it looked haskell-ish enough I hoped there might be some overlap, but its to tenuous for me to follow
12:22:21 <glguy> dons: I think we've got some expat bindings already
12:22:24 <dons> yo SyntaxNinja in the house
12:22:25 <glguy> were you intending to port those over?
12:22:33 <dons> glguy: oh hmm. we or 'we' ?
12:22:48 <glguy> /we/
12:22:55 <dons> *we* ?
12:22:59 <glguy> _we_
12:23:09 --- mode: irc.freenode.net set +o ChanServ
12:23:10 <dons> oooh
12:23:27 <SyntaxNinja> y0y0 dons
12:23:28 <wy> conal: It seems that values can be all defined with functions, and functions are values too.
12:23:29 <dons> nothing open though, it seems
12:23:44 <SyntaxNinja> dons: how was Australia day?
12:24:06 <conal> wy: by "functions" do you mean syntax or semantics?
12:24:29 <wy> conal: I mean semantics don't know if this muturally recursive definition is right.
12:25:06 <dons> SyntaxNinja: cold. but we had lamingtons and biscuits :)
12:25:06 <wy> conal: Another thing is the interpretations. I don't know how to classify them.
12:25:17 <SyntaxNinja> dons: sounds fun
12:25:46 <dons> ren made icecream from scratch
12:25:49 <dons> which was kinda amazing
12:26:14 <conal> wy: i think plato suggested that this world is full of hints or approximations of the ideal.  that's how i see code also, both in syntactic and executable form.
12:26:53 <dons> now, where's sjanssen. i want to release xmonad!
12:26:59 <cjb> :)
12:27:10 <dmwit> Oh, hey!
12:27:15 <monochrom> was speaking an hour ago or something.
12:27:20 <wy> conal: I'm curious how those levels of languages go down to the lowest level. Is quantum mechanics where the god failed to make it consistent?
12:27:26 <dmwit> There's something I haven't set up since I formatted my hard drive.
12:28:06 <oerjan> wy: hah, it's consistent, it's just not cartesian closed ;)
12:28:29 <jethr0> is there a nice way to write in IO monad: "if a && b" where b is an IO action and should only be executed if "a" is true?
12:28:38 <oerjan> @src when
12:28:38 <lambdabot> when p s = if p then s else return ()
12:29:22 <oerjan> jethr0: ^
12:29:41 <jethr0> hmm
12:30:04 <jethr0> i want to write "if a && b then c else d"
12:30:28 <wy> conal: maybe there is a way to get to the ideal by infinity ;)
12:30:28 <conal> jethr0: b :: IO Bool  ?
12:30:32 <jethr0> yes
12:30:33 <oerjan> jethr0: does b need to return True as well?
12:30:35 <oerjan> ok
12:30:38 <jethr0> yes
12:30:51 <jonaskoelker> hey, this haskell shit is pretty nice :)
12:31:01 <dons> SyntaxNinja: see this, http://mult.ifario.us/p/haskell-del-icio-us-and-json someone hacking scripts to get at del.icio.us via json
12:31:01 <lambdabot> Title: haskell-del-icio-us-and-json
12:31:13 <dons> web 2.0 programming's kinda hot in haskell atm
12:31:16 <dons> jonaskoelker: hehe
12:31:30 <SyntaxNinja> cool.
12:31:35 <dmwit> jethr0: do { unB <- b; if a && unB then c else d }
12:31:45 <wy> oerjan: Then how does the program of life started? It seems to be another program.
12:31:51 <oerjan> dmwit: b run only if a true
12:31:55 <dmwit> oh
12:32:08 <jethr0> dmwit: hmm, wouldn't that evaluate "b" no matter what a evaluated to?
12:32:15 <jethr0> in IO monad
12:32:37 <jonaskoelker> I solved a toy problem in Haskell; I solved the same problem in ruby by writing a constraint solver and using it; *using* the constraint solver takes 48 lines of ruby; haskell does it in 41 lines, including the constraint solver
12:32:39 <oerjan> jethr0: i cannot think of a very elegant way
12:32:45 <dmwit> yeah, sorry, I wasn't paying attention
12:32:57 <dons> jonaskoelker: i bet we can shrink that down :)
12:33:05 <dons> constraint solver puzzles in haskell beg for the list monad
12:33:11 <dons> and all the short syntax you get for free with that.
12:33:21 <dons> if you hpaste.org the code, i'm sure you'll get some interesting feedback :)
12:33:28 <jethr0> oerjan: me neither. right now i have a lot of nested ifs, but i'll think a little more if there's some liftM magic to be done ;)
12:33:37 <augustss> jonaskoelker: or blog about it
12:33:47 <jonaskoelker> http://rafb.net/p/PrVIqL44.html
12:33:47 <lambdabot> Title: Nopaste - No description
12:34:25 <dons> oh wow. flip map. you hardly ever see that.
12:34:27 <wy> conal: I guess some god created the whole thing. He wants to know if any program can realize the truth that the world it sees is a program.
12:34:28 <jonaskoelker> the problem is "Pandigital Puzzler" -- http://www.geocities.com/bob_kraus_2000/PUZZLES_DIGITAL.html
12:34:29 <lambdabot> Title: PUZZLES_DIGITAL
12:34:49 <dmwit> Yikes, short, undescriptive names...
12:35:07 <jonaskoelker> yeah :\
12:35:20 <dons> Cale: a little constraint solving puzzle. wanna take a look? http://rafb.net/p/PrVIqL44.html
12:35:20 <lambdabot> Title: Nopaste - No description
12:35:26 <jonaskoelker> but "list_after_constraint_1" hurts my fingers
12:35:27 <conal> wy: or did the god denote rather than create?
12:35:32 <augustss> jonaskoelker: bprimes = takeWhile (<= 8+9) primes
12:35:45 <jethr0> man, my haskell is rusty. what's the unequal comparison operator again?
12:35:51 <TomMD> /=
12:35:53 <dons> > "yes" /= "no"
12:35:54 <lambdabot>  True
12:36:11 <dons> ?hoogle Eq a => a -> a -> Bool
12:36:11 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
12:36:11 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
12:36:11 <lambdabot> Data.Eq.(==) :: Eq a => a -> a -> Bool
12:36:13 <jonaskoelker> roger on the takeWhile
12:36:24 <jethr0> thx
12:36:25 <Cale> dons: what is this computing?
12:36:26 <conal> @ty ((.).(.)) not (==)
12:36:26 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:36:27 <wy> conal: What does denote mean?
12:36:56 <dons> Cale: http://www.geocities.com/bob_kraus_2000/PUZZLES_DIGITAL.html "Pandigital Puzzler"
12:36:56 <lambdabot> Title: PUZZLES_DIGITAL
12:37:03 <dons> Cale: its jonaskoelker's code.
12:37:28 <jbms> I'm new to haskell: It seems that by treating strings normally as a list of characters, haskell is inherently inefficient in dealing with strings.  Is there some common way around this?
12:37:41 <wy> conal: He did minimal amount of work and let the program run. That's why the program is so inefficient ;)
12:37:45 <nominolo> jbms: compiler optimizations
12:37:46 <jbms> do haskell programs that deal with strings use some alternative representation typically?
12:37:52 <Cale> jbms: Data.ByteString.*
12:38:01 <jonaskoelker> jbms: my mind jumps to the phrase "template specialization"
12:38:03 <Cale> jbms: If they need to be fast.
12:38:07 <jonaskoelker> (yeah, stone an old C++'er)
12:38:19 <jbms> Cale: Ah, okay
12:38:21 <nominolo> jbms: or (lazy) bytestrings
12:38:29 <jbms> nominolo: does that actually work in practice much?
12:38:38 <Cale> jbms: If you're just doing simple things, lists of characters are incredibly convenient.
12:38:54 <TomMD> jbms: ByteStrings work great - look at all the programs in hackage that depend on ByteString
12:38:56 <nominolo> jbms: it really depends on the kind of program, i.e. if you need to store your strings or just process them
12:39:20 <Cale> But if you need speed, Data.ByteString.Lazy etc. provide not only strings of bytes, but ones where additional algebraic rules are used to apply optimisations to your code.
12:39:40 <jbms> okay, well it is good to know at least that there is a solution to it, so that I don't have to write off haskell :)
12:39:41 <Cale> The end result can often beat naive (library function calling) C code.
12:40:38 <Cale> This is because it essentially gets turned into code which operates on an (approximately) cache-sized block buffer.
12:40:41 <dons> jbms: bytestrings are ridiculously efficient. just byte arrays in the strict case, and cache-sized byte array chunks in the lazy case, with compiler optimisations to specifically improve the code.
12:41:25 <wy> I'm wondering why the compiled code is faster than the source code
12:41:25 <jbms> okay, good to know
12:41:41 <Cale> wy: With bytestrings?
12:41:42 <kib> Hi, does anyone have any idea on how to solve such things : http://www.indigopuzzles.com/ipuz/help.action?helpId=hashi/howToSolve_01
12:41:43 <lambdabot> Title: Indigo Puzzles - Help, http://tinyurl.com/2excvo
12:42:01 <wy> Cale: in general
12:42:10 <dons> wy?
12:42:10 <kib> Cale : yes
12:42:12 <dons> 'source code' ?
12:42:27 <tibbe> where can I find bringerts cgi version of HWS?
12:42:32 <Cale> wy: You mean why compiled code is faster than interpreted code?
12:42:35 <wy> dons: I mean... What is compilation? Is it really only a translation?
12:42:47 <dons> translation to machine code
12:42:57 <Cale> wy: It's not just a translation, but also transformations on the code.
12:43:06 <chessguy> @bot
12:43:06 <lambdabot> :)
12:43:08 <olsner> wy: compilation also applies loads of optimizations that interpreters generally don't do
12:43:30 <wy> Cale: Do we lose some structures? Is it a kind of simplification?
12:43:33 <dons> ultimately, its faster because less instructions are executed on the cpu
12:43:37 <Cale> First, code is parsed and all the syntax sugar is stripped away leaving a very simple, but still functional "core" language.
12:43:55 <dons> wy, nope, interpreters are just inefficient mappings to the underlying hardware you have to run your code on
12:44:04 <Cale> Then a program called the simplifier, consisting of many core -> core transformations is run on this.
12:44:15 <byorgey> kib: you mean, write a program to solve them?
12:44:50 <Cale> and then once that's done, the core language is transformed into C--, which is like a cross platform assembly, and finally that's translated into native machine code.
12:45:06 <byorgey> kib: that's an interesting problem.  some kind of constraint solving.
12:45:07 <kib> byorgey : Yes, it seems really harder than Sudokus.
12:45:08 <jonaskoelker> dons: so, any comments on my code?  Fun things (improvements) one could do?
12:45:11 <Cale> (at least this description roughly approximates the process)
12:45:24 <byorgey> kib: I'm not sure it's any harder than Sudoku.
12:45:28 <wy> Cale: Does ghc use C--?
12:45:28 <dons> jonaskoelker: its a bit too obfuscated to make any high level refactorings without more thinking
12:45:34 <Cale> wy: Yeah.
12:45:47 <kib> byorgey : so you think brute force might solve these puzzles ?
12:45:48 <dons> possibly you could come at it again with list comprehensions and the list monad, but that would be an exercise for interested readers
12:45:49 <wy> Cale: It seems to be cool. I wonder what's inside .NET
12:45:52 <TomMD> Isn't the real question: Is there any other project that uses C--?
12:45:56 <jonaskoelker> dons: well, the obvious thing to do is refactor into a constraint solver and an application of it, right?
12:46:14 <Cale> TomMD: I'm kind of surprised that there aren't more.
12:46:17 <byorgey> kib: well, it depends what you mean by "brute force" =)
12:46:27 <wy> Cale: Is C-- a stack machine or something else?
12:46:43 <TomMD> Cale: Don't get me wrong, I am not taking a shot at cmm, but I haven't seen others (and take it you haven't either).
12:47:16 <Cale> wy: You can think of it as kind of a very-stripped-down version of C with additional low-level constructs. It's not really a stack machine.
12:47:49 <wy> Cale: C?? So it's not that low level
12:47:53 <byorgey> kib: but yes, I think it could be done easily by repeatedly making decisions that are constrained to only one option, and then when you run into more than one possiblity, choosing randomly and backtracking if things don't work out.
12:47:59 <Cale> Well, the problem is C is too high-level
12:48:20 <Lemmih> TomMD: Well, there aren't any good C-- compilers. That kinds holds it back.
12:48:25 <Cale> C is hard to use as a cross platform assembler because it lacks certain access to low-level features.
12:48:26 <byorgey> kib: which is basically the same strategy that makes for a very fast sudoku solver.
12:49:13 <dons> jonaskoelker: yeah, there's some nice ways to do that.
12:49:26 <kib> byorgey : yes, but i don't like that way of doing, that's stupid : no IA inside.
12:49:30 <phobes> Getting gcc to generate code for you when you want to do things like tail calls, garbage collection, continuation passing... is a fun puzzle
12:49:42 <byorgey> kib: what's IA?
12:49:48 <wy> How does C-- compare with LLVM?
12:49:52 <kib> AI soory
12:49:54 <TomMD> Native ASM generation FTW!
12:50:09 <FunctorSalad> gtk2hs noob question :) I'm trying to have a an area where you can place nodes and drag them around, and have arrows between the nodes. I was thinking about making Image/Label widgets for the nodes, putting them in a Fixed and drawing the arrows by hand?
12:50:27 <phobes> Does LLVM use a backend?
12:50:32 <FunctorSalad> (or is there a better way)
12:50:33 <MyCatVerbs> Cale: perhaps it'd be sane to taret gcc's middle end, rather than compiling via C.
12:50:38 <MyCatVerbs> phobes: LLVM *is* a backend.
12:51:04 <phobes> MyCatVerbs:  So it goes straight to asm?
12:51:07 <byorgey> kib: ok, I'll write a solver using my stupid way, and you use 'AI' (whatever that is), and we'll race ;)
12:51:48 <MyCatVerbs> Cale: I mean, if you wedged a C-- frontend on gcc, would it fail to suck?
12:51:55 <monochrom> LLVM's backend is hardware :)
12:52:03 <Cale> MyCatVerbs: I don't really know.
12:52:04 <MyCatVerbs> phobes: think so.
12:52:10 <phobes> How many platforms does LLVM currently target?
12:52:21 <kib> byorgey : that's the problem indeed ! How to find a descent algo ?
12:52:49 <dolio> How do actual people solve sudoku problems? Don't they just do what byorgey said, only slower?
12:53:07 <vincenz> dolio: yes, much slower, they have a slow cpu :)
12:53:11 <byorgey> dolio: yes, and it's the same way they solve the 'bridge' puzzles kib is talking about.
12:53:15 <vincenz> byorgey: Bah, you should use AI
12:53:17 <vincenz> byorgey: AI!
12:53:46 <phobes> vincenz:  Al bundy?  Al Yanokvich?
12:53:49 <monochrom> Sometimes people use "experience", that is, a distorted memory of some past subproblem and subsolution they have met before.
12:54:10 <byorgey> vincenz: the problem is, I have an AI here, but it says it isn't interested in solving sudoku puzzles.  go figure.
12:54:17 <monochrom> The distortion may be for better or worse.
12:54:18 <vincenz> byorgey: That bastard :)
12:54:23 <MyCatVerbs> phobes: I don't know how LLVM works. Have to read up on it.
12:54:40 <phobes> MyCatVerbs:  ya it's in the queue
12:54:57 <dolio> monochrom: I suppose you could mimic that by using some heuristic to choose which branch to take on the random guess.
12:55:03 <dolio> Or, which branch to take first.
12:55:09 <Cale> Actual people solve Sudoku puzzles using a variety of techniques which would be somewhat silly to apply in a computer program, unless you were designing a program to show people how to solve Sudoku puzzles by hand.
12:55:32 <phobes> Sudoku problems aren't very hard, are they?
12:55:43 <MyCatVerbs> Computationally, no.
12:55:46 <Cale> Largely not, but there are some which are rather tricky for humans.
12:55:50 <phobes> I've never seen a Sudoku puzzle that required deep backtracking
12:55:56 <Cale> Oh, those exist :)
12:56:30 <TomMD> Sudoku is best solved with a redirection such as: > /dev/null
12:56:35 <monochrom> There is more. If you recognize the present instance as some distortion of a past instance, you may use cached solutions.
12:56:41 <byorgey> kib: the point is, there's no such thing as 'AI', just algorithms for solving problems.  I'm not sure what you think would make any algorithm more 'AI'-ish than another.
12:56:51 <phobes> Cale:  I'd think it would depend on how powerful your rules were
12:56:59 <jonaskoelker> Hmm.. I try "ghc -o problem +RTS -p -RTS problem.hs", I get "not build for: -prof or parallel"
12:57:00 <Cale> phobes: yeah
12:57:02 <LoganCapaldo> there's gotta be an upper limit on the amount of backracking you can have w/ a sudoku puzzle though, as long as it's required to have a unique soln.
12:57:12 <jonaskoelker> even though I just installed ghc6-prof
12:57:34 <Cale> phobes: and the general goal is developing a list of tactics such that no nondeterminism is needed, but I don't think existing tactics quite do it.
12:57:48 <byorgey> LoganCapaldo: well, it's a finite puzzle, so of course there is =)
12:58:03 <gwern> 'AI is whatever computers can't yet do'
12:58:09 <vincenz> AI = set of solutions that haven't been found yet :)
12:58:12 <vincenz> AI : Algorithm Inexistant
12:58:32 <phobes> Cale:  ya, that's an interesting problem
12:58:39 <byorgey> jonaskoelker: the +RTS stuff is for running the compiled program, not an option to ghc.
12:58:44 <monochrom> I actually become wiser, even cleverer, after I learn algorithms for computers.
12:58:48 <Cale> There was a website where they had a program generating minimal sudoku puzzles with unique solutions.
12:59:34 <byorgey> jonaskoelker: you want to do something like ghc -prof -auto-all -o ...
12:59:50 <Cale> Oh hey! Gordon Royle is/was working on that problem :)
13:00:03 <vincenz> Cale: how did you make your puzzles?
13:00:11 <byorgey> jonaskoelker: and then run the compiled program with +RTS -p -RTS
13:00:11 <Cale> He was the co-author on the textbook for my algebraic graph theory course.
13:00:13 <vincenz> Cale: are they automaticcally generatable?
13:00:13 <Cale> vincenz: by hand
13:00:28 <Cale> Possibly, but they're a bitch to write a program for.
13:00:30 <LoganCapaldo> byorgey: well I just mean yo can't even go all the way to 9 ^ 3 given the rules.
13:00:32 * vincenz nods
13:00:34 <vincenz> Cale: why?
13:00:42 <vincenz> Cale: the circles part, or just finding a puzzle?
13:00:45 <byorgey> LoganCapaldo: well, yes, you're right.
13:00:49 <Cale> vincenz: Because of the need to keep track of topological information.
13:01:15 <vincenz> Cale: you can't encode that as a graph?
13:01:23 <Cale> Sort of...
13:01:50 <Cale> The mapping should be orientation preserving too.
13:02:23 <Cale> So around each vertex, you have to encode the permutation of adjacent faces.
13:02:47 <sclv> sodoku is proven np-complete in the size of n where a puzzle is nxn i read recently.
13:02:53 <Cale> You could represent it as a pair of cleverly-constructed permutations, actually.
13:03:09 <sclv> which is not surprising but i'm glad somebody bothered to work it out.
13:03:16 <phobes> sclv:  I read that somewhere too
13:03:23 <monochrom> Why do people keep inventing NP-complete games? First minesweeper, now this...
13:03:36 <Botje> monochrom: people seem to be solving them just fine :)
13:03:55 <Botje> and isn't sudoku just graph coloring in disguise?
13:04:09 <monochrom> But they fix the size.
13:04:17 <MyCatVerbs> What's the best bound on an NP-complete problem found yet, anyway?
13:04:33 <Cale> Exponential time?
13:04:41 <MyCatVerbs> Cale: singly exponential?
13:04:47 <Cale> yeah
13:04:58 <MyCatVerbs> Danke.
13:05:15 <wy> Is there lexer generators like flex in Haskell?
13:05:22 <MyCatVerbs> wy: Happy.
13:05:25 <Cale> MyCatVerbs: Every NP problem can be solved in singly-exponential time.
13:05:25 <allbery_b> alex
13:05:26 <monochrom> alex
13:05:37 <wy> MyCatVerbs: Is it also a parser?
13:05:39 <allbery_b> happy is a parser generator (like yacc/bison)
13:05:44 <cjb> wy: I haven't used them, but I hear that Haskell is exceedingly good for such generators.
13:05:56 <MyCatVerbs> Cale: spiffy.
13:06:00 <allbery_b> parsec tends to be preferred, at least around here
13:06:10 <allbery_b> (not a generator but a combinator library)
13:06:20 <MyCatVerbs> Cale: is that neccessarily O(2^n), or O(2^f(n)) where f is some polynomial?
13:06:20 <Cale> MyCatVerbs: this is because you can simply simulate a nondeterministic machine solving the problem in polynomial time
13:06:38 <phobes> MyCatVerbs:  I think the second one
13:06:39 <wy> allbery_b: Do we need to eliminate left recursion before use parsec?
13:06:54 <MyCatVerbs> Or heck, O(f(2^g(n))) for some polynomials f and g?
13:06:55 <allbery_b> yes
13:06:55 <monochrom> Yes.
13:06:57 <phobes> MyCatVerbs:  When you translate to the universal NP-complete problem, you get a polynomial in the problem size
13:07:10 <phobes> MyCatVerbs:  No
13:07:17 <MyCatVerbs> phobes: ah, spiffy.
13:07:23 <wy> That doesn't sound very nice and would make the grammar less understandable
13:07:33 <phobes> MyCatVerbs:  or well, ... polynomial in an exponential is just exponential
13:07:43 <oerjan> MyCatVerbs: the reduction of an NP-complete problem to another can blow up the size polynomially, so it would be O(2^f(n))
13:07:48 <sclv> wy: not exactly.
13:08:07 <MyCatVerbs> phobes: that's a big difference in practice, even if not in theory. :)
13:08:12 <monochrom> Use the "chainl" combinator for left recursion.
13:08:15 <phobes> MyCatVerbs:  So O(f(2^g(n))) = O(2^g(n))
13:08:34 <phobes> MyCatVerbs:  ya, the O there hides lots of practicalities :)
13:08:35 <dons> augustss: did you see iavor did a modern implementation of ''On Generating Unique Names'' ,  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/value-supply
13:08:36 <lambdabot> http://tinyurl.com/27ge84
13:08:45 <kib> byorgey : You can solve a Sudoku by using brute force, but that does not dispense you from looking elsewhere for finding a better/smarter solution.
13:09:11 <sclv> from the manual: "However, every left-recursive grammar can be rewritten to a non-left-recursive grammar. The library provides combinators which do this automatically for you (chainl and chainl1)."
13:09:15 <sclv> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
13:09:33 <MyCatVerbs> phobes: "practical" = "painful"?
13:09:35 <monochrom> In fact, between certain left recursion and saying "any number of ___, left-associative", I would prefer the latter.
13:09:47 <gwern> I have a question: why would hackage complain 'This package requires Cabal version: ==1.2.3.0.' when I do a test upload of yi?
13:10:58 <dons> is it just a warning? i suspect that means it won't be able to be tested on hackage
13:11:00 <phobes> MyCatVerbs:  oh and I actually mean O(f(2^g(n))) = O(2^g'(n)) for some g'
13:11:08 <monochrom> Recall that recursions are as hard to reason about as gotos. Some recursions make your intention clear. Some recursions obscure your intention.
13:11:10 <dons> or it overly constrains the versoin, gwern. but yi's special
13:11:23 <MyCatVerbs> phobes: *blinkblinkblink*
13:11:27 <sclv> plus parsec has the nifty buildExpressionParser functionality that lets you handle precedences and associativity automagically.
13:11:29 <monochrom> You should always insist to convey your intention, not to use recursion or goto or combinators or ...
13:11:31 <Cale> Some g' which is a constant multiple of g
13:11:33 <jethr0> when using ForeignPtr, is it always necessary to run ghc with "-fvia-C"?
13:11:34 <MyCatVerbs> phobes: right, makes sense.
13:11:44 <gwern> dons: well, I could try actually uploading, but if it didn't fail, I think some people would be annoyed at me :)
13:11:51 <phobes> MyCatVerbs: Ya what Cale said
13:11:55 <Cale> jethr0: I hope not.
13:11:58 <dons> is jyp involved in yi still, gwern ?
13:12:10 <dons> are you coordinating the release with him?
13:12:11 <phobes> Cale: I actually just meant "some g' in the same class as g'
13:12:15 <phobes> Cale: I actually just meant "some g' in the same class as g"
13:12:23 <jethr0> Cale: i'm using a FunPtr to a c function as free callback and ghc says i need -fvia-C
13:12:40 <MyCatVerbs> dons: how's yi special?
13:12:41 <Cale> huh
13:12:43 <Cale> okay
13:12:55 <Cale> Well, perhaps you do then. That's disappointing.
13:13:04 <dons> MyCatVerbs: it's complex
13:13:39 <bogner> @yow
13:13:40 <lambdabot> Now I'm having INSIPID THOUGHTS about the beatiful, round wives of
13:13:40 <lambdabot> HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS and being approached
13:13:40 <lambdabot> by SMALL BOYS selling FRUIT ...
13:13:57 <bogner> i don't understand @yow. what does it do?
13:14:04 <vincenz> random crap :)
13:14:08 <Cale> It prints a Zippy the Pinhead quote.
13:14:10 <monochrom> lambdabot is the biggest and most beloved troll. :)
13:14:10 <allbery_b> zippy the pinhead quotes
13:14:18 <Cale> @keal
13:14:18 <lambdabot> i aint running that on my puter
13:14:19 <Cale> @keal
13:14:19 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
13:14:20 <bogner> oh, okay.
13:14:22 <Cale> @keal
13:14:22 <lambdabot> what are epsilons?
13:14:27 <vincenz> @palomer
13:14:27 <lambdabot> xml stands for "xtremely mild lullaby"
13:14:27 <Cale> @keal
13:14:28 <lambdabot> ithink has to do with hardcased government failsafe in chip
13:14:32 <vincenz> @palomer
13:14:32 <lambdabot> I have news for you, it's pointless
13:14:38 <sclv> @help quote
13:14:38 <lambdabot> quote <nick>
13:14:38 <lambdabot> remember <nick> <quote>
13:14:38 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:14:43 <sclv> @provides quote
13:14:43 <lambdabot> Unknown command, try @list
13:14:44 <vincenz> Cale: what's the other guy again?
13:14:46 <vincenz> oh yeah
13:14:48 <vincenz> @proton
13:14:48 <lambdabot> hakell is not lisp or ml right?
13:14:51 <allbery_b> @list quote
13:14:51 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
13:14:51 <vincenz> @proton
13:14:51 <lambdabot> what makes haskell more fun than say clisp?
13:14:58 <monochrom> protontorpedo?
13:15:00 <vincenz> @protontorpedo
13:15:00 <lambdabot> its bs dude
13:15:09 <allbery_b> another ex-troll
13:15:09 <sclv> @girl19
13:15:09 <lambdabot> nobody can catch me
13:15:12 <vincenz> @protontorpedo
13:15:12 <lambdabot> Im not a loser
13:15:16 * vincenz chuckles
13:15:22 <sclv> @v
13:15:22 <lambdabot> "\"#$%&'()*+,\""
13:15:22 <Cale> We steal the life-essence of trolls, encode it into a digital form, and embed it into lambdabot.
13:15:27 <vincenz> protontorpedo also went as shemalesomething
13:15:32 <vincenz> @protontorpedo
13:15:32 <lambdabot> why haskell over say clsip or smalltalk?
13:15:52 <sclv> @ghc
13:15:52 <lambdabot> ghc says: Empty record update
13:15:53 <monochrom> Don't be so falsely polite, Cale. We suck the life out of trolls. :)
13:15:53 <byorgey> @yhjulwwiefzojcbxybbruweejw
13:15:53 <lambdabot> Exception: <<loop>>
13:16:21 <Lemmih> ?keal
13:16:21 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
13:16:28 <Twey> @yhjulwwiefzojcbxybbruweejw
13:16:29 <lambdabot> "\""
13:16:34 <Twey> WTH?
13:16:35 <monochrom> We are like Dark Crystal. :)
13:16:39 <Twey> @yhjulwwiefzojcbxybbruweejw
13:16:39 <lambdabot> "\"#$%&'()*+,\""
13:16:40 <byorgey> I've never understood that one.
13:16:43 <Cale> monochrom: :)
13:16:51 <Cale> monochrom: That was an awesome movie :)
13:16:54 <olsner> @yhjulwwiefzojcbxybbruweejw
13:16:54 <lambdabot> Exception: <<loop>>
13:17:01 <olsner> @yhjulwwiefzojcbxybbruweejw
13:17:01 <lambdabot> "\"#$%&'()*+,\""
13:17:03 <czakey> @!
13:17:03 <lambdabot> Maybe you meant: . ? @ v
13:17:09 <czakey> @.
13:17:09 <lambdabot> Not enough arguments to @.
13:17:13 <monochrom> I like this most: "how come you have wings?" "that's a girl thing."
13:17:14 <czakey> @.?
13:17:14 <lambdabot> Maybe you meant: . ?
13:17:15 <allbery_b> that's an ancient lambdabot bug
13:17:24 <allbery_b> @v
13:17:24 <lambdabot> "\"#$%&'()*+,\""
13:17:45 <czakey> @:() { :|: & }; :
13:17:46 <lambdabot> Unknown command, try @list
13:17:48 <czakey> ;P
13:17:53 <idnar> apparently lambdabot used to assign the expression being evaluated to "v"
13:17:56 <allbery_b> that's the original.  LB's @run ("> ") bound v to the result of the expression.  people discovered this and abused it
13:18:18 <allbery_b> so the variable was renamed to yhjulwwiefzojcbxybbruweejw.  people discovered and abused that too
13:18:26 <dons> to write programs that looped
13:18:50 <monochrom> loops are good for business
13:18:50 <olsner> so now the command prints quotes of what you could get from abusing the yhjulwwiefzojcbxybbruweejw variable?
13:19:03 <allbery_b> yep
13:19:17 <byorgey> > description <$> lookupSequence [1,1,2,3,5]  -- does this work now?
13:19:20 <lambdabot>   Not in scope: `lookupSequence'
13:19:22 <byorgey> aww
13:19:37 <allbery_b> hm, the help for those should point to the relevant #haskell logs (which I forget)
13:19:51 <Twey> Haha, nice.
13:20:11 <hpaste>  dmwit pasted "constraint solver... sort of" at http://hpaste.org/5268
13:20:32 <dmwit> jonaskoelker: See that hpaste. =)
13:21:01 <dmwit> Haskell can be both concise *and* readable...
13:22:01 <phobes> Though #haskell is tilted heavily towards "consise"
13:22:10 <phobes> concise*
13:22:23 <n00b> heys guys i am doing algebraic datatypes, i want to define a recursive datatype to model the natural numbers using Peano axioms
13:22:41 <olsner> phobes: if @pl makes it shorter, you're not done yet
13:22:46 <olsner> ;-)
13:22:59 <dmwit> n00b: Great!
13:23:26 * dolio chuckles.
13:23:41 <jonaskoelker> dmwit: so... you're looking at each permutation, checking if it satisfies the constraints, then printing if it does?
13:24:07 <dmwit> jonaskoelker: Right.  Which may be less powerful than your constraint solver, I'm not sure.
13:24:42 <dmwit> (evaluating "answer" took too long, hence "answerWithConstraint1Implicit". =P)
13:25:01 <jonaskoelker> dmwit: I think it's slower than my hand-hack, and less expressive than a full general constraint solver
13:25:55 <litb> hm, another question:
13:26:12 <litb> Monad () , what is that () ? an empty tuple?
13:26:27 <idnar> :t ()
13:26:28 <litb> somewhere else i read it is a "unit type"
13:26:28 <lambdabot> ()
13:26:33 <shachaf> litb: () is an empty tuple, yes.
13:26:36 <litb> what does that mean exactly?
13:26:43 <dmwit> jonaskoelker: Oh, wow, I just ran yours... *much* faster.
13:26:43 <shachaf> litb: "Monad ()" doesn't make much sense.
13:26:46 <n00b> add :: Natural -> Natural -> Natural
13:26:48 <dmwit> jonaskoelker: Never mind me.
13:26:53 <litb> shachaf: yeah i mean some monad with that
13:27:04 <jonaskoelker> dmwit: what does `time' say?
13:27:14 <shachaf> litb: Oh.
13:27:25 <dmwit> litb: () is a type with exactly one (non-bottom) value, namely () itself.
13:27:30 <shachaf> litb: Yes, it's a type with only one value: ().
13:27:31 <idnar> Monad m
13:27:36 <shachaf> litb: (Well, that and _|_.)
13:28:09 <litb> so let a = () ::() is valid?
13:28:21 <litb> looks strange tho.
13:28:28 <dozer> 3214:37 darcs
13:28:31 <dozer> :(
13:28:34 <allbery_b> > let a = () : () in a
13:28:35 <lambdabot>  Couldn't match expected type `[()]' against inferred type `()'
13:28:37 <dozer> applying just 1 patch
13:28:38 <dmwit> jonaskoelker: 1.275 vs 14.798 =P
13:28:38 <wagle> > let a = () :: () in a
13:28:38 <allbery_b> oops
13:28:39 <lambdabot>  ()
13:28:43 <allbery_b> yeh, that
13:28:44 <jonaskoelker> dmwit: :D
13:28:44 <allbery_b> typoed
13:29:03 <dmwit> jonaskoelker: I've now added constraint-solvers to the list of things to look into. =)
13:29:07 <litb> m ()  then m would be the identity monad?
13:29:19 <dmwit> litb: Not necessarily.
13:29:40 <dmwit> litb: It is a monad containing values of type ()... but it may contain multiple copies of ().
13:29:43 <byorgey> litb: no, it just represents a computation that doesn't compute anything.  i.e. it is used only for its side effects.
13:29:45 <litb> i'm looking at guard atm
13:29:51 <dmwit> (If you are thinking of monads as containers.)
13:29:52 <shachaf> litb: m () is a computation that returns a useless value.
13:30:11 <wagle> whats the ziplock monad?
13:30:13 <byorgey> :t guard
13:30:14 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:30:32 <dmwit> wagle: Where'd you hear about it?
13:30:38 <dmwit> wagle: (It's new to me.)
13:30:55 <litb> looks like "return () >>= t == t"
13:31:13 <dmwit> yes
13:31:21 <dmwit> err... no
13:31:29 <dmwit> return () >>= t == t ()
13:31:29 <wagle> if monads are containers...
13:31:34 <jethr0> what happens when i do "withCString "hello" $ \s -> return s"?
13:31:40 <dmwit> wagle: Oh, heh.
13:31:43 <byorgey> wagle: haha =)
13:31:44 <idnar> hahaha
13:31:47 <byorgey> @src guard
13:31:47 <lambdabot> guard True  =  return ()
13:31:47 <lambdabot> guard False =  mzero
13:31:57 <byorgey> litb: there's the source.
13:31:58 <shachaf> wagle: There's a ZipList Applicative... Is that enough?
13:31:59 <oerjan> litb: return x >>= f = f x is one of the monad laws
13:32:12 <BMeph> wagle: you mean ZipList?
13:32:39 <byorgey> litb: mzero is supposed to have the property that mzero >> foo = mzero.
13:32:58 <idnar> :t (>>)
13:32:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:33:01 <jonaskoelker> can I do an implicit `case' in an anonymous function?
13:33:13 <dmwit> implicit?
13:33:20 <idnar> byorgey: not foo >> mzero = mzero?
13:33:21 <dmwit> You can do:
13:33:28 <dmwit> \x -> case x of ...
13:33:29 <byorgey> idnar: that too.
13:33:31 <jonaskoelker> you know, (\0 -> 1 | n -> n*fac(n-1))
13:33:43 <jethr0> @:t withCString
13:33:44 <idnar> > mzero >> [5]
13:33:44 <lambdabot>  There was an error in the type: (line 1, column 4):
13:33:44 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
13:33:44 <lambdabot>  []
13:34:11 <dmwit> jonaskoelker: no
13:34:12 <byorgey> er, sorry, mzero >>= f = mzero
13:34:18 <oerjan> jonaskoelker: no.  there is a proposal to add something similar
13:34:23 <byorgey> and foo >> mzero = mzero.
13:34:29 <wagle> > [5] >> mzero
13:34:29 <lambdabot>  []
13:34:38 <wagle> ugh
13:34:39 <byorgey> > mzero :: [a]
13:34:39 <lambdabot>  []
13:34:51 <byorgey> wagle: ugh?
13:34:54 <litb> ah i see now
13:35:08 <byorgey> and mzero is the identity of mplus.
13:35:13 <wagle> > mzero :: [a] >> [5]
13:35:13 <lambdabot>  Parse error at ">>" (column 14)
13:35:27 <wagle> > (mzero :: [a]) >> [5]
13:35:28 <lambdabot>  []
13:35:33 <byorgey> > mzero >>= (\x -> [x,x+1])
13:35:34 <lambdabot>  []
13:35:40 <dmwit> (>>=) = mtimes
13:35:52 <idnar> :t mplus
13:35:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:36:05 <litb> > mzero `mplus` "id"
13:36:06 <lambdabot>  "id"
13:36:07 <wagle> byorgey, yeah, the type checkers a little weak
13:36:26 <byorgey> wagle: in what sense?
13:36:30 <litb> @src mtimes
13:36:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:36:36 <dmwit> > "b" `mplus` "id"
13:36:37 <lambdabot>  "bid"
13:36:39 <wagle> > [5] >> mzero
13:36:39 <lambdabot>  []
13:37:10 <oerjan> foo >> mzero is a more dubious rule, because it cannot work e.g. for IO
13:37:16 <wagle> > mzero >> [5]
13:37:17 <lambdabot>  []
13:37:36 <dmwit> oerjan: Is IO a MonadPlus?
13:37:36 <byorgey> litb: there's no such thing as 'mtimes' although that's an interesting way to think about (>>=).  dmwit, did you just make that up, or is there some real theory behind that?
13:37:43 <wagle> nm..  i thought it couldnt handle mzero >> [5]
13:37:44 <litb> @type mzero
13:37:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:37:58 <litb> @type (>>)
13:37:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:38:00 <jonaskoelker> is there some clever way of run-length encoding a list?
13:38:03 <litb> ah
13:38:06 <dozer> the mzero closes down the list of parallel computations to zero, so when the next instruction comes along there's nothing to branch it on to
13:38:11 <byorgey> jonaskoelker: of course!
13:38:17 <dmwit> byorgey: I just made it up.
13:38:30 <dmwit> > map length . group $ "aaabbbababbbbba"
13:38:31 <lambdabot>  [3,3,1,1,1,5,1]
13:38:31 <oerjan> @instances MonadPlus
13:38:32 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:38:40 <byorgey> > map (head&&&length) . group $ [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:38:41 <lambdabot>  [(1,2),(2,1),(1,1),(3,2),(4,3),(3,2),(4,1),(2,2)]
13:38:44 <oerjan> dmwit: yep, using catch/throw semantics
13:38:51 <jonaskoelker> dmwit: nice :)
13:38:52 <quicksilver> there are two kinds of MonadPlus
13:38:57 <quicksilver> with two different sets of laws
13:39:01 <quicksilver> there is something on the wiki abou it
13:39:15 <quicksilver> basically the non-determinism sort and then or-else sort.
13:39:29 <joglala> Hello
13:39:36 <dmwit> :t map (head &&& length) . group
13:39:36 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
13:39:42 <byorgey> > concatMap (uncurry (flip replicate)) . map (head&&&length) . group $ [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:39:42 <lambdabot>  [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:39:48 <dmwit> joglala: Hiya!
13:40:08 <byorgey> @check \xs -> (concatMap (uncurry (flip replicate)) . map (head&&&length) . group $ xs) == xs
13:40:08 <lambdabot>  Add a type signature
13:40:16 <ddarius> @google site:haskell.org inurl:haskellwiki MonadOrElse
13:40:17 <lambdabot> No Result Found.
13:40:19 <byorgey> @check \xs -> (concatMap (uncurry (flip replicate)) . map (head&&&length) . group $ (xs :: [Int])) == xs
13:40:19 <lambdabot>  OK, passed 500 tests.
13:40:30 <ddarius> @google MonadOrElse
13:40:36 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
13:42:00 <litb> is there something that (a, b) -> (b, a) ?
13:42:15 <litb> maybe some arrow stuff?
13:42:28 <Lemmih> litb: uncurry (flip (,))
13:42:30 <idnar> @pl \(a, b) -> (b, a)
13:42:30 <byorgey> litb: surprisingly, there isn't!
13:42:30 <lambdabot> uncurry (flip (,))
13:42:35 <idnar> heh, couldn't quite do that in my head
13:42:44 <litb> byorgey: o.O
13:42:44 <oerjan> litb: snd &&& fst too
13:43:02 <litb> oh yeah oerjan nice
13:43:05 <byorgey> litb: you'd think there would be a 'swap' function somewhere, in Data.Tuple for example
13:43:06 <idnar> > (snd &&& fst) (5, 10)
13:43:07 <lambdabot>  (10,5)
13:43:13 <idnar> :t snd &&& fst
13:43:14 <lambdabot> forall a b. (a, b) -> (b, a)
13:43:19 <byorgey> but obviously it's easy enough to roll your own.
13:43:22 <wagle> :t (&&&)
13:43:22 <ddarius> I presume the usual prevalence of pattern matching is why swap wasn't included.
13:43:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:43:31 <ddarius> :t (\(a,b)->(b,a))
13:43:32 <lambdabot> forall t t1. (t, t1) -> (t1, t)
13:44:10 <dmwit> GHC doesn't pick very original type-names.
13:44:23 <BMeph> litb: Yeah, it's a pet peeve of mine. It's defined as a helper function to "second" in Control.Arrow, though.
13:44:39 <dmwit> :t (\(a,b,c,d,e,f,g,h,i,j,k)->(a,b,c,d,e,f,g,h,i,j,k))
13:44:39 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10. (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)
13:44:43 <ddarius> I've rarely needed swap.
13:45:09 <oerjan> dmwit: i think t* is used for all anonymous lambdas which aren't otherwise restricted
13:45:12 <litb> > map (snd&&&fst) . (head&&&length) . group $ [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:45:13 <lambdabot>  Couldn't match expected type `[(a, b)]'
13:45:21 <litb> ugg
13:45:47 <dmwit> litb: Just use (length&&&head) instead in such a case.
13:46:01 <dmwit> > map (length &&& head) . group $ "aaaabbbbabaab"
13:46:03 <lambdabot>  [(4,'a'),(4,'b'),(1,'a'),(1,'b'),(2,'a'),(1,'b')]
13:46:17 <litb> yeah, i wanted to play
13:46:26 <dmwit> yaeh
13:46:27 <litb> but why didn't mine work?
13:46:28 <dmwit> ok
13:46:34 <dmwit> you forgot a map
13:46:38 <gwern> dons: yeah, jyp is still maintaining it. I am sort of coordinating with him, although he's said he'll be a bit busy to handle all the questions and support needs after the release
13:46:44 <dmwit> > map (snd&&&fst) . map (head&&&length) . group $ [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:46:45 <lambdabot>  [(2,1),(1,2),(1,1),(2,3),(3,4),(2,3),(1,4),(2,2)]
13:46:59 <sfultong> @bot
13:46:59 <lambdabot> :)
13:47:08 <litb> oh
13:47:09 <ddarius> Indeed, usually there is no reason to use swap as you can just merge it into something else.
13:47:10 <BMeph> This would also work:
13:47:19 <BMeph> > map ( (snd&&&fst) . (head&&&length) ) . group $ [1,1,2,1,3,3,4,4,4,3,3,4,2,2]
13:47:20 <lambdabot>  [(2,1),(1,2),(1,1),(2,3),(3,4),(2,3),(1,4),(2,2)]
13:47:27 <ddarius> The times I've wanted it is when I'm doing something with a kind of "braided" control pattern.
13:47:34 <litb> BMeph: yeah, i wanted to do that
13:47:40 <litb> i failed in the parens o.O
13:47:42 <dons> gwern: ok. great
13:47:43 <litb> *at
13:49:16 <sfultong> let pairFun a b = a : pairFun b (b . a) in map ($ 0) $ pairFun id (+1)
13:49:19 <sfultong> > let pairFun a b = a : pairFun b (b . a) in map ($ 0) $ pairFun id (+1)
13:49:21 <lambdabot>  Exception: stack overflow
13:49:33 <sfultong> > take 10 . let pairFun a b = a : pairFun b (b . a) in map ($ 0) $ pairFun id (+1)
13:49:33 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:49:42 <sfultong> > let pairFun a b = a : pairFun b (b . a) in take 10 . map ($ 0) $ pairFun id (+1)
13:49:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
13:52:01 <gwern> dons: do you think it'd be a good idea to move Yi to pcre-light?
13:52:38 <litb> i'm looking forward to try Yi
13:52:50 <oerjan> > let pairFun a b = a : pairFun b (b . a) in (!!10) . map ($ "") $ pairFun (' ':) ('*':)
13:52:51 <lambdabot>  "* ** * ** ** * ** * ** ** * ** ** * ** * ** ** * ** * ** ** * ** ** * ** * ...
13:52:51 <dons> gwern: hard to say. it probably can't hurt. (shrinks the dependencies)
13:53:07 <litb> do you think it would be worth to make a haskell binding for Qt and KDE as a bachelor work?
13:53:11 <litb> (just curious)
13:53:38 <gwern> litb: isn't there already a QT binding?
13:53:42 <dolio> Someone recently released a Qt binding.
13:53:44 <litb> orly?
13:53:55 <gwern> qthaskell or sumthing
13:54:14 * litb sees sweet haskell plasmoids coming 
13:55:07 <litb> http://qthaskell.sourceforge.net/images/logo.png <- well that image looks like a cute logo
13:56:27 <sfultong> let pairFun a b = a : pairFun b (b . a) in (!!10) $ pairFun (0:) (1:)
13:56:29 <sfultong> P let pairFun a b = a : pairFun b (b . a) in (!!10) $ pairFun (0:) (1:)
13:56:32 <sfultong> > let pairFun a b = a : pairFun b (b . a) in (!!10) $ pairFun (0:) (1:)
13:56:32 <lambdabot>  <[Integer] -> [Integer]>
13:56:55 <dons> we need the qthaskell bindings on code.haskell.org to get community participation
13:57:04 <dons> anything not on hackage doesn't exist
13:57:04 <sfultong> > let pairFun a b = a : pairFun b (b . a) in (!!10) . map ($ []) $ pairFun (0:) (1:)
13:57:05 <lambdabot>  [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1...
13:57:31 <ddarius> :t either
13:57:32 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:59:07 <vincenz> :t iterate
13:59:08 <lambdabot> forall a. (a -> a) -> a -> [a]
14:00:05 <sfultong> have there been any haskell virtual machines made?
14:00:28 <gwern> dons: GHC and darcs and gtk2hs don't exist? :)
14:00:44 <litb> i've found this nice poster: http://www.info.ucl.ac.be/people/PVR/paradigmsDIAGRAMeng101.jpg
14:00:45 <gwern> sfultong: I remember hearing of someone writing some sort of gameboy emulator in haskell. it never got very fast
14:00:45 <oerjan> > let subst 0 = [1]; subst 1 = [0,1] in fix (1:concatMap subst)
14:00:46 <lambdabot>  Couldn't match expected type `[t]'
14:00:47 <vincenz> > (!!10) map (($[]) . fst) $ iterate (\(a,b) -> (snd a, snd a . fst a)) ((0:),(1:))
14:00:48 <lambdabot>  Couldn't match expected type `[t -> a -> b]'
14:00:54 <vincenz> > (!!10) . map (($[]) . fst) $ iterate (\(a,b) -> (snd a, snd a . fst a)) ((0:),(1:))
14:00:54 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
14:00:54 <lambdabot>       Expec...
14:01:18 <ddarius> sfultong: Virtual machines for Haskell or in Haskell?
14:01:25 <davidL> litb: that's neat
14:01:28 <sfultong> for
14:01:35 <oerjan> > let subst 0 = [1]; subst 1 = [0,1] in fix ((1:).concatMap subst)
14:01:35 <lambdabot>  [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1...
14:01:37 <vincenz> > (!!10) . map (($[]) . fst) $ iterate (\(a,b) -> (b, b . a) ((0:),(1:))
14:01:37 <lambdabot> Unbalanced parentheses
14:01:37 <sfultong> or a bytecode sort of haskell
14:01:41 <vincenz> > (!!10) . map (($[]) . fst) $ iterate (\(a,b) -> (b, b . a)) ((0:),(1:))
14:01:41 <lambdabot>  [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1...
14:01:45 <dons> gwern: there are some special cases. but for new projects, its insane
14:02:00 <vincenz> @pl (\(a,b) -> (b, b . a))
14:02:01 <lambdabot> uncurry (ap (,) . flip (.))
14:02:04 <vincenz> of course!
14:02:19 <ddarius> sfultong: Every implementation (except JHC I think) has some kind of abstract (hugs)/virtual bytecode (nhc, yhc, ghc).
14:02:25 <gwern> to not to, aye
14:03:28 <sfultong> ddarius: so conceivably you could output a program in this bytecode, and write a virtual machine to run it?
14:03:53 <slarba_> it would possibly be a good idea to have a virtual machine with jit compiler for haskell
14:04:06 <slarba_> runtime profiling, recompilation according to the profile etc...
14:04:09 <sfultong> yeah, I was thinking that would be kinda neat
14:04:35 <slarba_> I'm wondering if it could also help implicit parallelization somehow
14:04:41 <sfultong> and then someone could make a hardware implementation, like a lisp machine!
14:04:48 <ddarius> sfultong: For, e.g. NHC, the NHC compile does output a program in the bytecode and includes a virtual machine for it.
14:04:53 <ddarius> Same for all the others.
14:04:58 <sfultong> slarba_: I've also thought of that, too
14:05:00 <slarba_> if you can _measure_ how much time reducing an expression takes, you could find expressions to be reduced in parallel
14:05:00 <ddarius> sfultong: You may be interested in
14:05:06 <ddarius> @google "Lazy Virtual Machine"
14:05:07 <lambdabot> http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
14:05:11 <dmwit> :t find
14:05:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:05:22 <sfultong> ddarius: thanks :)
14:05:37 <dmwit> :t indexOf
14:05:38 <lambdabot> Not in scope: `indexOf'
14:05:59 <dmwit> ?hoogle (Eq a) => a -> [a] -> Maybe Int
14:06:00 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
14:06:09 <oerjan> :t findIndex
14:06:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:06:54 <nominolo> @tell dcoutts you could link this on the gtk2hs site: http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/
14:06:54 <lambdabot> Consider it noted.
14:07:27 <dmwit> :t maybe
14:07:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:08:36 <idnar> @src maybe
14:08:36 <lambdabot> maybe n _ Nothing  = n
14:08:37 <lambdabot> maybe _ f (Just x) = f x
14:08:39 <sfultong> slarba_: you could also cache the results of pure function evaluations between IO ticks
14:08:43 <BMeph> litb: Interesting that Oz and Alice are in every paradigm on that chart... ;)
14:08:47 <idnar> :t (>>=)
14:08:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:09:04 <slarba_> sfultong: hmm...
14:09:12 <BMeph> (That is, in every column, but not in every bow.)
14:09:22 <BMeph> s/bow/box/
14:10:48 <litb> =)
14:11:08 <litb> tho i don't know that languages
14:11:58 <litb> BMeph: are Oz and Alice good langs?
14:12:20 <ddarius> litb: Yes.
14:12:35 <BMeph> I have no idea. I have heard little about them.
14:12:54 <dons> they're cheating on the paradigm stuff :)
14:13:03 <litb> oh Alice looks great (according to its website =))
14:13:12 <sfultong> I think that a lot could be gained from research into hardware implementation of lazy functional evaluation
14:13:55 <slarba_> hmm. btw does the Error monad optimize the unwinding or does it unwind one recursion level at a time until catchError is reached?
14:14:04 <ddarius> @google Reduceron
14:14:06 <lambdabot> http://www.cs.york.ac.uk/~mfn/reduceron/
14:14:06 <lambdabot> Title: The Reduceron
14:14:33 <ddarius> sfultong: Hardware implementation of lazy functional languages was explored near the beginning of the research
14:14:56 <ddarius> The Reduceron is a new example.  I'm not sure what it's motivation is.
14:15:11 <slarba_> or is there a compiler optimization to "jump" right away to the catch?
14:15:12 <ddarius> slarba_: Yes and no.
14:15:17 <litb> hm, what is that "ML" thing?
14:15:21 <litb> is it a kind of standard?
14:15:26 <ddarius> It's a language
14:15:29 <slarba_> ddarius: elaborate... :)
14:15:29 <ddarius> @google sml
14:15:31 <lambdabot> http://www.smlnj.org/
14:15:31 <lambdabot> Title: Standard ML of New Jersey
14:16:31 <litb> thats one where everyone seems to refer to
14:16:34 <sfultong> ddarius: neat!  you are a treasure trove
14:16:57 <oerjan> slarba_: i think it does one at a time, i recall you could make a monad that used failure continuation passing instead which would jump directly
14:16:59 <ddarius> Well, SML/NJ is a particular implementation.  There is a SML page somewhere.
14:17:05 <sfultong> too bad I don't have time to really look into this reduceron right now
14:17:19 <litb> ah, and ML is only a set of standard describing such languages?
14:17:21 <slarba_> oerjan: ok
14:17:26 <litb> like the lambda calculus is one for ML ?
14:17:29 <ddarius> slarba_: Only if you have left associative uses will you need to go through levels and that's rare.
14:17:53 <slarba_> ok
14:18:00 <ddarius> Well, ML is just a catch-all phrase for all the ML-family languages, e.g. SML, O'Caml, Alice ML, etc.
14:18:22 <ddarius> slarba_: As oerjan said, you can avoid even that (and the bigger problem with the Error monad) by using continuations.
14:18:23 <oerjan> litb: iirc ML is the granddaddy of type inferenced functional languages like haskell
14:18:33 <oerjan> **iiuc
14:18:48 <ddarius> slarba_: See section 2 on http://www.haskell.org/haskellwiki/Performance/Monads
14:18:49 <lambdabot> Title: Performance/Monads - HaskellWiki
14:19:04 <ddarius> oerjan: As far as practical implementations go, yes.
14:19:18 <slarba_> ddarius: thanks
14:19:44 <wy> I found it really hard to verify that a regular expression is really expressing what we want. Is there any good ways of thinking about this?
14:22:28 <monochrom> You need a second way to express what you "want".
14:23:31 <monochrom> Some use temporal logics. E.g., "whenever there is x, there is y some time afterwards". "z occurs infinitely often".
14:23:47 <phlpp> so
14:24:14 <monochrom> You can then check that a proposed regular expression satisfies those statements.
14:25:08 <wy> gosh. Even this simple thing will require so much logic
14:25:20 <monochrom> simple? how do you know it's simple?
14:25:36 <Tac-Tics> > print
14:25:39 <lambdabot>  <Integer -> IO ()>
14:25:46 <monochrom> Since the dawn of humankind, "what I want" has never been simple.
14:25:54 <Tac-Tics> > print :: (Show a => a -> IO ())
14:25:54 <lambdabot>  Parse error at "=>" (column 18)
14:25:58 <wy> right
14:26:12 <wy> also "what do I know"
14:26:13 <litb> how can i do regular expressions with haskell?
14:26:28 <dons> litb: with one of the many regex libs on hackage.haskell.org
14:26:37 <litb> i.e something like match :: [a] -> [a] -> Bool
14:26:47 <dons> yep.
14:26:49 <dons> well, for String
14:26:52 <litb> dons: isn't there one in std haskell 98 ?
14:26:54 <dons> not arbitrary 'a'
14:27:13 <litb> well, i did that because a is not so long as Stri..
14:27:13 <dons> not in the base libraries, no. we tend to use parser combinators more often than regexes, for some reason, so they're not in base.
14:27:34 <dons> so anyway, pick one you like on hackage, and try that. the two used widely are pcre-light and regex-{base,posix}
14:27:42 <monochrom> Don't ask for simple. But do ask for clear.
14:27:50 <litb> i see
14:27:56 <litb> dons: parser combinators?
14:28:05 <litb> pardon i'm a beginner on haskell :/
14:28:05 <ddarius> @google Parsec
14:28:12 <lambdabot> http://en.wikipedia.org/wiki/Parsec
14:28:12 <lambdabot> Title: Parsec - Wikipedia, the free encyclopedia
14:28:14 <dons> ah ok. its a library for writing string parsers
14:28:21 <ddarius> Well, that one won't be useful.
14:28:25 <RayNbow> anyone here familiar with fig4tex?
14:28:28 <ddarius> Parsec too, is made of win and awesome.
14:28:44 <dons> it is indeed.
14:28:49 <Tac-Tics> It's pretty much the one thing that Haskell totally kicks ass at in terms of practicality over every other other language
14:28:51 <monochrom> Some regex's are clear in conveying what the author intends. Some regex's aren't. That's why it's nice to have various languages ready.
14:29:05 <litb> ddarius: =)
14:29:39 <slarba_> parsec is incredibly useful
14:29:57 <Tac-Tics> and pretty easy to use too
14:30:02 <slarba_> yeah
14:30:03 <oerjan> @where parsec
14:30:04 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
14:30:35 <Tac-Tics> http://en.wikibooks.org/wiki/Haskell/Practical_monads
14:30:35 <lambdabot> Title: Haskell/Practical monads - Wikibooks, collection of open-content textbooks
14:30:42 <litb> oh nice
14:30:43 <Tac-Tics> (part of a Lisp in 21 hours tutorial, I think)
14:31:13 <ddarius> litb: You can also get cheap Parsec look-alikes in many other languages nowadays.
14:31:54 <litb> is daan a member of here too?
14:32:07 <FunctorSalad> halp :( "The lambda expression `\ event -> (do ...)' has one argument, but its type `Bool' has none"
14:32:12 <litb> ddarius: yeah, boost::spirit =)
14:32:23 <hpaste>  dmwit annotated "constraint solver... sort of" with "real constraint propogation is not as readable, but close" at http://hpaste.org/5268#a1
14:32:31 <FunctorSalad> (what does this mean?)
14:32:56 <oerjan> FunctorSalad: probably you forgot to give the function an argument?
14:33:35 <FunctorSalad> oerjan: I don't want to give the lambda experession an argument, I want to pass it to another function
14:33:49 <oerjan> FunctorSalad: or perhaps the function you are passing it to is missing a Bool argument
14:33:56 <dons> litb: not so much these days. he's busy at microsoft
14:34:13 <dmwit> jonaskoelker: Okay, there's my attempt at doing real constraint propogation, which brings time down to something comparable to your solution.
14:34:43 <FunctorSalad> oerjan: thanks, that's it :)
14:36:03 <FunctorSalad> (the position were I tried to pass the lambda expression should actually be a Bool)
14:36:46 <dmwit> (The point being that you can still give real names to things while keeping it concise.)
14:37:15 <phobes> hmmm, is it really a good idea to hand craft a parser rather than just writing down the rules and letting something sort it out?
14:37:59 <dons> the hand crafted one looks like the rules
14:38:14 <dons> unlike say, regexes, and without needing a preprocessor
14:38:29 <Tac-Tics> handcraft as in writing them out in loops yourself? or having a parser generator do it for you?
14:38:40 <phobes> dons: well you have to choose a parse order
14:38:47 <phobes> dons: in parsec, it looks like
14:39:33 <phobes> dons: As in, "first try to parse this, and if that fails do this,..." etc
14:40:09 <ddarius> phobes: Not exactly and there are other parser combinator libraries that have a more commutative alternation.
14:40:10 <phobes> Tac-Tics:  As in writing down the grammar and having something decide if it's ambiguous, and implement a parser from that
14:40:12 <Tac-Tics> phobes: would you rather they try in parallel or something? What if they both pass?
14:40:47 <Tac-Tics> I don't know much about parsers though, so please don't listen to me =-)
14:41:11 <phobes> Tac-Tics:  I want to write down the rules and have it tell me whether it's ambiguous - not carefully craft the grammar so that it's clearly not ambiguous
14:41:19 <Tac-Tics> Reading through the dragon book is on my eternal TODO list
14:41:35 <Tac-Tics> I see I see
14:41:38 <phobes> ddarius:  What did "not exactly" mean?
14:42:19 <ddarius> You can easily make a commutative <|> with try.  alt p q = try p <|> q
14:42:24 <Philippa> phobes: in general that's undecidable
14:42:26 <phobes> ya
14:42:27 <Tac-Tics> Well by imposing an order, doesn't that imply you can't create ambiguity? (or that the resolution for the ambiguity is deterministic)
14:42:36 <ddarius> That it isn't is a (premature perhaps) optimization.
14:43:07 <conal> phobes: ambiguity testing is probably impossible with monadic parser combinators, but perhaps could be done with applicative or arrow-based parser combinators.
14:43:54 <phobes> Philippa:  yes I know.  This is one of those problems that seems to be practically possible even if not theoretically possible :)
14:44:30 <Philippa> phobes: learn to specify better! What you want is to know if it can be shown unambiguous by the tools you have to hand...
14:44:59 <jonaskoelker> dmwit: ah, that looks really nice :)
14:45:06 <Tac-Tics> http://en.wikipedia.org/wiki/Ambiguous_grammar
14:45:07 <lambdabot> Title: Ambiguous grammar - Wikipedia, the free encyclopedia
14:45:18 <Tac-Tics> "The general question of whether a grammar is ambiguous is undecidable. "
14:45:22 <dmwit> jonaskoelker: And, with a few tweaks, it goes faster than yours. =P
14:45:26 <jonaskoelker> dmwit: I like how you express the constraints
14:45:27 <Tac-Tics> but I don't know if that's for general grammars, or just CFG
14:45:28 --- mode: ChanServ set -o shapr
14:45:31 <jonaskoelker> dmwit: hey! :D
14:45:34 <dmwit> hehe
14:45:41 <dmwit> (See the annotations.)
14:45:54 <Philippa> Tac-Tics: "general grammars" would presumably be a superset of CFGs, no?
14:46:03 <phobes> Philippa:  In the context of interoperable language syntax extensions, I think you really want the system to decide if there's a conflict
14:46:04 <monochrom> Heh.
14:46:04 <litb> is there some good haskell threading tutorial?
14:46:09 <Tac-Tics> Philippa: yeah
14:46:20 <dons> $ cabal install xmonad
14:46:21 <dons> :)
14:46:23 <Tac-Tics> litb: tackling the awkward squad =-)
14:46:25 <dons> (new release)
14:46:25 <monochrom> CFG ambiguity is bad enough, isn't it?
14:46:30 <jonaskoelker> dmwit: how would you handle non-uniform domains?
14:46:31 <Philippa> Tac-Tics: so if it's undecidable for a subset of the problem then it's undecidable in general for that problem
14:46:34 <joelr1> good evening
14:46:40 <Philippa> hi joel
14:46:45 <joelr1> does anyone know a c# parser written in haskell?
14:46:46 <jonaskoelker> dmwit: that is, one variable ranges over [1..5], another over [10..20], and ...
14:46:49 <dmwit> jonaskoelker: It's trickier, yes.
14:47:12 <Tac-Tics> Philippa: yes, the the converse isn't true. It doesn't say CFG on the wiki page, so it might be a degenerate Context-sensitive grammar which makes it undecidable
14:47:16 <monochrom> Anyway, you can ask for a less ambitious goal, such as ambiguity of a restricted grammar class.
14:47:18 <dons> joelr1: never heard of one.
14:47:24 <dmwit> jonaskoelker: What you can do is set up a list of the domains.
14:47:27 <Tac-Tics> (but again, I remind the channel I don't really know what I'm talking about =-)
14:47:33 <joelr1> dons: darn. means i'll have to write it.
14:47:44 <dmwit> jonaskoelker: Then, instead of these versions of extend/extensions, you have to do something a little different.
14:47:55 <dmwit> jonaskoelker: Let me see if I can demonstrate with this problem.
14:47:59 <dons> joelr1: you could possibly start with the C parser in c2hs
14:48:12 <Philippa> Tac-Tics: moving to CSGs just makes things harder, there'll be that many more grammars exhibiting the same issues plus new issues on top
14:48:30 <jonaskoelker> dmwit: for instance, I want > elem (head solution) [1..9]
14:48:39 <oerjan> Tac-Tics: ambiguity is undecidable for CFGs
14:48:40 <joelr1> dons: right. there's also geoff mainland's hs-clang
14:48:54 <wy> Cale: Is there a good way to type math in inkscape?
14:49:00 <Tac-Tics> I really need to go back and re-learn grammars again
14:49:03 <dmwit> jonaskoelker: You would create:
14:49:08 <joelr1> dons: i need it to employ quasiquotations
14:49:13 <dmwit> domains = replicate 9 [1..9]
14:49:17 <Philippa> very few good parsing frameworks actually work with CFGs - either they work with a subset with nicer properties or with a superset
14:49:28 <dons> joelr1: hs-clang? haven't seen thta.
14:49:44 <dmwit> jonaskoelker: Hold on. =P
14:49:47 <joelr1> dons: maybe he hasn't announced it yet
14:49:52 <phobes> oerjan:  But I'd wager that there is a class of unambiguous grammars large enough that if you can decide membership in that class, you make everyone happy
14:50:00 <jonaskoelker> dmwit: not "[1..9] : (replicate 9 [0..9])"?
14:50:17 <Tac-Tics> grammars are sorta creepy and weird
14:50:28 <dmwit> :t foldl'
14:50:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:50:51 <Philippa> phobes: I doubt it. Most people happy, sure
14:50:53 * Tac-Tics doesn't remember if he sold back his theory of computation book
14:51:02 <phobes> Philippa:  Ok, me happy :)
14:51:04 <oerjan> phobes: it's called LR(k)?
14:51:36 <phobes> oerjan:  Perhaps.. LR(1) isn't enough though
14:52:04 <RayNbow> wy: what are creating in Inkscape?
14:52:12 <Tac-Tics> I think the most complicated parser I ever wrote was (READ)
14:52:29 <olsner> Tac-Tics: an implementation of read or a call to read? :P
14:52:29 <Tac-Tics> READ's a nice parser though =-) all those parens
14:52:41 <Tac-Tics> olsner: heh, the implementation
14:52:41 <wy> RayNbow: Just a small DFA diagram
14:52:56 <hpaste>  dmwit annotated "constraint solver... sort of" with "With domains" at http://hpaste.org/5268#a4
14:52:58 <Tac-Tics> I got pretty skilled at writing it too
14:53:04 <dmwit> jonaskoelker: Like that.
14:53:22 <wy> RayNbow: That's not really needed, but I've had many drawings that require math formulas
14:53:24 <Tac-Tics> but I only figured out how to do it after reading Hutton's Monadic Parser Combinators
14:53:40 <dmwit> jonaskoelker: This still doesn't handle all non-uniform domains... i.e. if the domains were [0..9] and ['a'..'z'], we'd be hosed with this method.
14:53:46 <oerjan> phobes: actually even if a language theoretically has a non-ambiguous grammar it can be much more convenient to write it ambiguously and use some default choices
14:53:59 <phobes> oerjan:  I agree
14:54:15 <oerjan> like yacc/bison does with precedence declarations
14:54:56 <RayNbow> wy: were you using those drawings made in Inkscape in a TeX document?
14:55:02 <phobes> oerjan:  I think alot of people are made happy just by defaulting to 'shift' (match larger production if possible)
14:55:05 <jonaskoelker> dmwit: wouldn't it work if you just let domains = [[0..9], ['a'..'z'], [foo, bar, baz], ...]?
14:55:16 <Tac-Tics> Is Parsec suitable for Haskell-style "definable precedence operators"?
14:55:23 <dmwit> jonaskoelker: Also, some of the constraints I wrote depend on the number of domains, so you'd have to change those a bit.
14:55:31 <ddarius> Tac-Tics: Yes.
14:55:31 <dmwit> jonaskoelker: No, that's a type error.
14:55:48 <dmwit> jonaskoelker: You need to use tuples if you want true heterogeneous-ness.
14:55:59 <dmwit> jonaskoelker: That's why it becomes trickier... =P
14:56:03 <jonaskoelker> oh, right
14:56:04 <Tac-Tics> ddarius: what is that technique usually called?
14:56:04 <wy> RayNbow: I tend to make it standalone, and not depend on external fonts
14:56:25 <RayNbow> wy: ah
14:56:26 <Philippa> Tac-Tics: yes, with a little work and bearing in mind that parsing Haskell 98 is probably undecidable
14:56:29 <oerjan> phobes: thus those new parsing expression grammars
14:56:32 <Philippa> (stupid interaction with the layout rule)
14:56:35 <jonaskoelker> so what for domains = [[0..9], [10..20], [36, 1225, 1680]]?
14:56:39 <wy> RayNbow: It seems pstricks of TeX can do it, but that's not convenient
14:56:41 <jonaskoelker> would that work?
14:56:42 <vincenz> Tac-Tics: it's a two step approach
14:56:52 <vincenz> Tac-Tics: you parse expressions as lists of operands and operators
14:57:02 <dmwit> jonaskoelker: It's unlikely, due to how I expressed constraint 3.
14:57:09 <vincenz> Tac-Tics: then you do a second pass over those, using a well-knwon algo, once you know the precedences
14:57:25 <ddarius> Philippa: Luckily, since Parsec is embedded in Haskell it kinda-sorta can parse all parseable grammars (though that's abusing terminology)
14:58:00 <Tac-Tics> Those silly operator precedences, I take it, are something a newb like me shouldn't mess with right away?
14:58:22 <RayNbow> wy: I'm currently using and learning how to use fig4tex ( http://perso.univ-rennes1.fr/yvon.lafranche/fig4tex/firstlook.html ), but I doubt that it will be useful for your situation
14:58:23 <Philippa> Tac-Tics: do, but do it in a small language for learning purposes first
14:58:26 <lambdabot> Title: Fig4TeX A few commented examples, http://tinyurl.com/3b7bvk
14:58:35 <ddarius> Tac-Tics: A two pass approach such as the one vincenz recommended should make it doable.
14:58:43 <Philippa> I've never actually implemented it, I'm just comfortable I know how to. And yeah, do the two-pass thing
14:58:55 <jonaskoelker> dmwit: well, blow a hole in the constraints, I know it's gonna break for this particular problem; but if handed a constraint list from above, promising it won't break on any member of the cartesion product of `domains', would it work?
14:58:58 <Philippa> it's that or trying to kludge up a time-travel equivalent of the two-pass algorithm anyway
14:59:05 <litb> hm, looks like stuff like threadDelay is only available to ghc
14:59:18 <sizur> i just installed haskell-mode. haskell-doc-mode doesnt seem to work... it gives me "function ::" and that's it
14:59:22 <ddarius> Philippa: Unless you require precedence annotations to precede their effect.
14:59:29 <Tac-Tics> I'm pretty sure I don't know enough parsec to begin to try it, but I think in the next few weeks, I'm going to dive into playing around with writing parsers some more
14:59:40 * Tac-Tics can't let Steve Yegge down
14:59:41 <Tac-Tics> X-D
14:59:51 <ddarius> Tac-Tics: Parsec is a joy and pretty straight forward if you are somewhat familiar with parsing.
15:00:16 <Tac-Tics> ddarius: I've used it for a few small toy programs. I tried a lambda calculus parser, and actually got it to work
15:00:23 <dmwit> jonaskoelker: Hmm... what it really promises is that if it doesn't break the constraints on any final subsequence, then it will work.
15:00:27 <sizur> Tac-Tics: i bet you can learn parsec in one day.
15:00:28 <Tac-Tics> and a PHP-style templating system for Haskell, I did once
15:00:44 <Tac-Tics> but it was an uphill battle both times =-)
15:00:53 <dmwit> jonaskoelker: Where "final subsequence" is a term I just made up that is meant to be analogous to "initial subsequence" from maths.
15:00:55 <Tac-Tics> but I won out, and learned a little more about monads while I was at it
15:01:16 <sizur> does anybody know why haskell-doc-mode is broken?
15:01:17 <wy> RayNbow: That looks nice. Actually I used to use MetaPost to draw the pictures, but that's a horrible language
15:01:46 <jonaskoelker> dmwit: "final subsequence" == suffix, yes?
15:01:46 <RayNbow> I have no experience with MetaPost
15:02:00 <dmwit> jonaskoelker: Yes, that's a much nicer way to say it. =)
15:02:02 <LoganCapaldo> Is it just me or is there this common misconception that parsing is the "important" part of a compiler? Like the Yegge post referred to by Tac-Tics, all his example problems were "parsing" problems, not "compiler" problems.
15:02:10 <RayNbow> before I only used to use some drawing packages (like Inkscape) to draw stuff and then import the images in the LaTeX document
15:02:16 <jonaskoelker> dmwit: couldn't you easily defer checking the constraints until you have a whole combination?
15:02:20 <RayNbow> but my 3D drawing skills suck :p
15:02:43 <RayNbow> so I was happy when I found fig4tex
15:03:05 <osfameron> LoganCapaldo: later on in that post, he does mention that the first 1-N problems are soluble with parsing alone (implying that N+1..X aren't)
15:03:06 <Tac-Tics> LoganCapaldo: that's true. But I'm so sick of parens!
15:03:06 <dmwit> jonaskoelker: Well, yes, but then you're back to exhaustive search.  (I think?  Maybe I misunderstand you.)
15:03:44 <Tac-Tics> parsing is also more useful than compilers, and parsec is just the coolest use of monads since IO
15:03:58 <Tac-Tics> err
15:04:01 <jonaskoelker> dmwit: yeah :\
15:04:08 <Tac-Tics> more useful than /just in/ compilers
15:04:21 <osfameron> parsing is a type of compiler, I suppose
15:05:14 <Winterstream> Could someone with a spare moment look at http://nopaste.com/p/aoOP9I8F0? I cannot figure out why I am getting a type error (BTW, it's a problem from TopCoder; I'm using those problems to learn Haskell properly for once).
15:05:49 <sizur> Winterstream: did they finally allowed Haskell into the competition?
15:05:56 <Winterstream> Nope :/
15:06:08 <Winterstream> But I'm solving the problems and then I want to redo them in Haskell
15:06:12 <dmwit> :t unzip
15:06:15 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
15:06:29 <LoganCapaldo> osfameron: Ok, that's was meant more of an example than anything else. Eg, asking this question http://reddit.com/r/programming/info/66qsu/comments/ . Picking a language and/or parser generator to use is pretty easy once you've nailed down your syntax. I could be totally off base, but I feel like there's this perception of parsing as being "hardcore CS".
15:06:37 <ehird> is there a way to check if an operation on an Int would overflow into an Integer?
15:06:54 <sizur> i need some help with haskell-mode, anybody please?
15:07:09 <dmwit> Winterstream: (/) doesn't work on Ints
15:07:11 <monochrom> No, there is no overflow check.
15:07:18 <Winterstream> Ah
15:07:23 <ehird> :(
15:07:34 <sizur> :t div
15:07:34 <lambdabot> forall a. (Integral a) => a -> a -> a
15:07:41 <dmwit> Winterstream: Try div instead, if you want floor semantics.
15:07:47 <Winterstream> thanks dmwit
15:07:52 <osfameron> LoganCapaldo: ah ok.  I'd guess that many non-academic programmers haven't done much parsing, yes.  (I certainly haven't done that much)
15:07:55 <litb> @pl (\x -> (print x) >> threadDelay 10000)
15:07:55 <lambdabot> (>> threadDelay 10000) . print
15:07:57 <monochrom> which brings me to another low-level thing C lacks. the carry bit.
15:08:03 <slarba_> hmm. it would be nice if parsec could return the remaining unparsed portion of the input when parsing ends, without using getInput
15:08:07 <dmwit> :t asAlpha
15:08:07 <lambdabot> Not in scope: `asAlpha'
15:08:13 <dmwit> :t isAlpha
15:08:13 <lambdabot> Char -> Bool
15:08:26 <dmwit> Winterstream: Also, use that.
15:08:28 <dmwit> ;-)
15:08:28 <Tac-Tics> Winterstream: it looks like you have a recursive loop in wordLen and lengths
15:08:33 <Tac-Tics> that bottoms out
15:08:36 <LoganCapaldo> ehird: I guess you could use maxBound and come up some kind of heuristic
15:08:41 <sizur> slarba_: are you using lexemes?
15:08:46 <monochrom> Anyone who illusion that C is close to hardware should be reminded that it doesn't give you the carry bit.
15:08:56 <slarba_> sizur: just plain CharParser
15:08:57 <Winterstream> dmwit, I was looking for such a function. Thanks :)
15:09:15 <monochrom> It's detrimal to an implementor of multi-precision addition.
15:09:29 <monochrom> "Give me back my carry bit!"
15:09:38 <Tac-Tics> winterstream: also, from the look of it, you might want to use the "words" function in the standard prelude
15:09:44 <Tac-Tics> > words "this is a sentence"
15:09:45 <ddarius> monochrom: Damn straight!
15:09:45 <lambdabot>  ["this","is","a","sentence"]
15:09:47 <Philippa> slarba_: not hard to write the HOParser to do it though, and a wrapper function if you really want it that way
15:09:50 <dmwit> Winterstream: Also, "length" works on String just fine, so get rid of wordLen entirely.  (As Tac-Tics said, it's buggy anyway.)
15:10:03 <sizur> slarba_: lexemes take care of 'empty' input after the lexeme, where empty included any comments
15:10:07 <slarba_> sizur: I parse a file header (which is variable length) and then want to get access to the rest of the file. Now I need to do a top-level parser with header <- parseHeader; input <- getInput; return (header,input) and continue from there
15:10:13 <LoganCapaldo> > (maxBound :: Int ) + 1
15:10:14 <lambdabot>  -2147483648
15:10:30 <Winterstream> wordLen is meant to check whether a string ends with "." or ""
15:10:35 <Winterstream> It's part of the problem description
15:10:55 <slarba_> sizur: it works that way, but is a little clumsy :)
15:11:08 <dmwit> Winterstream: Oh, sorry, I meant the local binding in pointVal, not the top-level one.
15:11:11 <Tac-Tics> oh, Winterstream: you have two definitions of wordLen, one is local in pointVal and the other is toplevel
15:11:12 <Tac-Tics> heh
15:11:30 <Winterstream> Tac-Tics, goodness. I see that loop
15:11:31 <Winterstream> thanks
15:11:43 <Winterstream> thanks guys
15:11:44 * dmwit shuts up to let Tac-Tics take over
15:12:12 * Tac-Tics misses T.A.'ing Computer Science
15:12:30 <LoganCapaldo> > let add x y = if signum x == signum y && signum sum == signum x then sum else error "Overflow" where sum = x + y in add (maxBound :: Int) + 1
15:12:30 <slarba_> sizur: I mean if there was a version of parse :: Parser -> Filename -> String -> Either ParseError (a, String) :)
15:12:31 <lambdabot>   add an instance declaration for (Num (Int -> Int))
15:12:31 <lambdabot>     In the expression:
15:12:31 <lambdabot>  ...
15:12:45 <LoganCapaldo> > let add x y = if signum x == signum y && signum sum == signum x then sum else error "Overflow" where sum = x + y in add (maxBound :: Int) 1
15:12:46 <lambdabot>  Exception: Overflow
15:13:09 <LoganCapaldo> > let add x y = if signum x == signum y && signum sum == signum x then sum else error "Overflow" where sum = x + y in add 2 3
15:13:10 <lambdabot>  5
15:13:19 <LoganCapaldo> that's dumb
15:13:24 <LoganCapaldo> and wordy
15:13:38 <LoganCapaldo> and probabl borken
15:13:48 <LoganCapaldo> > let add x y = if signum x == signum y && signum sum == signum x then sum else error "Overflow" where sum = x + y in add maxBound maxBound
15:13:48 <lambdabot>  Add a type signature
15:13:55 <LoganCapaldo> > let add x y = if signum x == signum y && signum sum == signum x then sum else error "Overflow" where sum = x + y in add maxBound maxBound :: Int
15:13:56 <lambdabot>  Exception: Overflow
15:14:07 <Winterstream> For the record, this channel is probably the friendliest programming channel I've ever used. It's so nice not being told indirectly that you're a dumb-ass :)
15:14:17 <oerjan> slarba_: as Philippa said, you can make a generic wrapper function.  wrapInput p = liftM2 (,) p getInput
15:14:23 <ehird> hm
15:14:26 <ehird> :)
15:14:34 <Tac-Tics> Winterstream: I know, isn't #haskell great? It makes up for the language being insurmountably difficult =-D
15:14:49 <slarba_> oerjan: yeah :)
15:14:51 <Philippa> Winterstream: that's the compiler's job :-)
15:14:55 <dmwit> > let add x y = if maxBound - x > y then x + y else error "Overflow" in add 2 3
15:14:55 <lambdabot>  Add a type signature
15:14:58 <ehird> hm
15:14:58 <Winterstream> He he. Aye, but it actually makes people want to come here.
15:14:59 <dmwit> > let add x y = if maxBound - x > y then x + y else error "Overflow" in add 2 3 :: Int
15:15:00 <lambdabot>  5
15:15:08 <Winterstream> Philippa, indeed :)
15:15:11 <dmwit> > let add x y = if maxBound - x > y then x + y else error "Overflow" in add 2 maxBound :: Int
15:15:12 <lambdabot>  Exception: Overflow
15:15:17 <ehird> mutable lists: what's the standard way
15:15:17 <dmwit> > let add x y = if maxBound - x > y then x + y else error "Overflow" in add 0 maxBound :: Int
15:15:18 <lambdabot>  Exception: Overflow
15:15:22 <dmwit> oops
15:15:23 <dmwit> hm
15:15:25 <ehird> this is in an IO monad, if that helps
15:15:59 <LoganCapaldo> ehird: can you just use Integer and avoid this? :)
15:16:18 <Winterstream> Hmm. I'm getting linkage errors when I compile that simple little prog of mine.
15:16:26 <dmwit> --make
15:16:27 <Tac-Tics> GHC: You fool! How could you possibly thing that Int -> Int is an instance of Show? DID YOU? And don't get me started on trying to unify [(a,b)] -> a -> Maybe b with [(a,b)] -> Maybe b!
15:16:37 <Winterstream> Thanks dmwit
15:16:38 <Tac-Tics> --make makes the world easy
15:16:39 <Winterstream> that works
15:16:48 <ehird> LoganCapaldo: Yes.
15:16:53 <ehird> now what about my other question :P
15:17:03 <Tac-Tics> None of that dumb linker nonsense like with gcc
15:17:08 <dmwit> ehird: What's the other question?
15:17:13 <ehird> dmwit: this one
15:17:19 <ehird> mutable lists: what's the standard[preferred] way
15:17:20 <ehird> this is in an IO monad, if that helps
15:17:45 <dmwit> oh, huh
15:17:58 <dmwit> STArray or something?
15:18:07 <LoganCapaldo> well you could have an IORef [a],, or you could have [IORef a]
15:18:12 <ehird> dmwit: is that a list :)
15:18:27 <ehird> LoganCapaldo: the latter doesn't allow deleting, adding elements etc
15:18:32 <ehird> IORef [a] will probably work
15:18:41 <ehird> but will it? won't you just be able to modify the first and rest values?
15:18:45 <ehird> not, say, the third element
15:18:54 <dmwit> But that's hardly any better than just [a]!
15:19:17 <LoganCapaldo> You could even have an IORef [IORef a]
15:19:25 <ehird> dmwit: ?
15:19:34 <ehird> LoganCapaldo: yes, but see what i said...
15:19:49 <dmwit> IORef [a] is not better, performance-wise, than [a]...
15:20:05 <ehird> I'm not looking for performance. :P
15:20:27 <dmwit> Oh, wait, what *are* you looking for, then?
15:20:43 <LoganCapaldo> xs <- readIORef list ; case xs of (first:sceond:third:rest) -> writeIORef list (first:second:newThird:rest)
15:20:44 <dmwit> (i.e. what do you mean by a mutable list?)
15:20:54 <ehird> LoganCapaldo: oh, you are right :)
15:21:01 <ehird> dmwit: exactly "IORef [a]"! :)
15:21:21 <Saizan> data MList' a = Nil | Cons a (IORef (MList' a)), type MList a = IORef (MList' a) ?
15:22:05 * dmwit wonders what would drive you to prefer IORef [a] to just [a].
15:22:39 <dmwit> Maybe... callbacks into some library code?
15:22:40 <ehird> dmwit: Say... mutability?
15:22:44 <oerjan> ehird: also consider making your monad StateT [a] IO
15:22:59 <ehird> oerjan: except that these values are goign to be passed around everywhere and stuff
15:23:07 <oerjan> ok
15:23:14 <twanvl> Saizan: that looks like ListT IORef a (for the fixed ListT) :)
15:23:39 <Saizan> twanvl: that's the concept :)
15:24:21 <oerjan> ehird: and if the performance of deeply modifying lists _does_ become a problem, take a look at Data.Sequence
15:24:31 <ehird> oerjan: it's a linked list by nature
15:24:34 <ehird> (it's a stack)
15:25:33 <Saizan> if it's a stack why you want to append?
15:25:41 <ehird> Saizan: ...?
15:25:52 <dons> Igloo: we need X11 1.4.1 in debian!
15:26:00 <dons> its holding back xmonad adoption. usual tool chain problems here.
15:26:19 <Saizan> in a stack you just have push and pop, both O(1) on [a]
15:26:31 <hpaste>  gwern pasted "XMC problems" at http://hpaste.org/5269
15:28:59 <litb> hm, how is the thing called that you create? (Just 5) for example
15:29:05 <litb> is it called "object of Maybe" ?
15:29:32 <oerjan> litb: a value of type Maybe whatever?
15:30:18 <dons> an opengl haskell blog, http://reddit.com/r/programming/info/66ssk/comments/
15:31:21 <Lemmih> No pictures :'(
15:31:31 <dons> boo
15:31:36 <LoganCapaldo> dons: boo, I was expecting 3D blog software
15:31:57 <dons> that would be fun
15:32:21 <LoganCapaldo> a literal blogosphere!
15:32:25 <sizur> wow, amazing, i can get straight to haddock docs for a specific function from emacs. niiice
15:32:54 <lispy> sizur: really? I can't even get TAGS work all the time :(
15:33:21 <lispy> for some reason, it TAGS doesn't respect case-sensitivity when i use it :(
15:33:27 <sizur> lispy: what tags?
15:33:51 <lispy> sizur: i think generated from haskell-tags and then you use M-. to find the definition of a symbol
15:34:37 <sizur> lispy: i only started with haskell-mode an hour ago, didnt try that yet
15:35:32 <shepheb> sizur: the function type readout in the minibuffer is my best friend
15:35:50 <lispy> shepheb: is that only for prelude functions tho?
15:36:08 <shepheb> prelude and some other core libs (Data.List, for example)
15:36:23 <sizur> lispy: i think if you use turn-on-haskell-decl-scan, and place a imenu-add-menubar-index, you can get to any definition within a file. but i think what you want is inter-file, right?
15:36:30 <shepheb> but it's moving to include your own stuff too
15:36:37 <lispy> shepheb: that is nice, i wish it would generalize and do it for anything in my project though :)
15:36:38 <dmwit> Aha, one place where Vim has Emacs beat for Haskell!  (One of the only places, I think.)
15:36:51 <lispy> sizur: correct, between modules
15:37:01 <shepheb> dmwit: but the emacs indentation is a big one the other way
15:37:06 <sizur> if you do C-c-t it gives you the type of any function, even yours
15:37:20 <shepheb> sizur: oh, sweet
15:37:23 <dmwit> shepheb: Yeah, there's no decent indentation mode for Vim. =/
15:37:35 <lispy> sizur: ah, cool, i haven't tried that, i'll have to test it
15:37:48 <lispy> shepheb: hrm, not working
15:37:53 <lispy> shepheb: it just blinks at me
15:37:55 <shepheb> that's probably the first editor battle that's ever ended included "yeah, good point"
15:37:58 <sizur> C-c C-t
15:38:01 <conal> do reddit comments accept any kind of markup?
15:38:12 <shepheb> #haskell for the win
15:38:21 <lispy> shepheb: yeah, just blinks...maybe i'm not using the same modes as you
15:38:29 <LoganCapaldo> conal: they use markdown I believe
15:38:33 <lispy> shepheb: i'm using LitHaskell
15:38:37 <shepheb> (Haskell Font Ind Doc)
15:38:45 <conal> LoganCapaldo: that's ideal for me.  thx.
15:38:49 <shepheb> lispy: hmmm, I don't, so I don't know how it behave for that
15:39:11 <lispy> what is Font?  I'm not using that one, but I have the other two
15:39:55 <lispy> oh is that font-lock-mode?  I have that one
15:40:07 <sizur> yeah, Font is implied in my config too
15:41:14 <sizur> just do C-c b to see all you can do
15:41:31 <sizur> i mean C-h b
15:41:54 <lispy> heh, C-c b started hugs :)
15:41:58 <lispy> I need to change that to ghc
15:42:59 <lispy> I bet 1) I need to switch it to use GHC 2) maybe i need a newer haskell-mode
15:43:19 <sizur> C-c-d opend haddock docs in browser for me
15:44:41 <hpaste>  gwern pasted "xmonad 0.6 problems" at http://hpaste.org/5270
15:45:07 <lispy> * The new command haskell-hoogle helps you query Hoogle from Emacs.
15:45:10 <lispy> nice
15:45:46 <ehird> do MArrays automatically expand etc?
15:46:01 <ehird> lispy: really we need lambdabot.el :-)
15:46:27 <sizur> djinn would help a lot
15:46:39 <scodil> ehird: no, although the interface allows for it. there is a library called ArrayRef that has expanding arrays but i don't know how well maintained it is
15:46:44 <lispy> http://mult.ifario.us/p/emacs-haskell-mode-unicode-cuteness
15:46:44 <lambdabot> Title: emacs-haskell-mode-unicode-cuteness
15:46:50 <sizur> program with types and let emacs infer the implementation of your whole code hehe
15:47:09 <ehird> scodil: so there's no good solution for a mutable, expanding array?
15:47:18 <ehird> I guess I could use a Map. :-P
15:47:25 <jonaskoelker> is there a smart way to intersect a list of lists?  I'm thinking of doing a filter on the union, but I'm feeling there's a really elegant solution just outside my reach...
15:47:37 <davidL> lispy: awesome link
15:47:59 <mauke> @hoogle intersect
15:47:59 <lambdabot> Data.List.intersect :: Eq a => [a] -> [a] -> [a]
15:47:59 <lambdabot> Data.List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:47:59 <lambdabot> Data.Set.intersection :: Ord a => Set a -> Set a -> Set a
15:48:05 <jonaskoelker> -.-
15:48:06 <ehird> lispy: I have one of them without the lambda glyph but with a prime glyph
15:48:15 <jonaskoelker> fanx, mauke
15:48:16 <scodil> ehird: no and its kind of a bummer. you can look at ArrayRef to see how he does it. You can also put your array behind a mutable reference, but that adds an extra level of indirection to all lookups. If Data.Map is an option for you, though, then that overhead probably won't hurt
15:48:55 <ehird> scodil: It's just for Symbols in my language's interpreter. I need to map the incrementing symbol number to a string for pretty-printing
15:49:23 <scodil> yeah Data.Map is probably fine
15:49:35 <scodil> better yet IntMap
15:49:50 <scodil> or Data.Sequence
15:49:58 <scodil> actually that's the closest to an expandable array
15:50:31 <sizur> how can i reload emacs configuration wihtout restarting emacs?
15:50:33 <ehird> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html # wtf 404
15:50:33 <lambdabot> http://tinyurl.com/yz86s7
15:50:37 <dons> O(log(n)) is O(1) forall n.
15:50:47 <ehird> sizur: C-x C-e on the expressions in .emacs you want to evaluate.
15:50:53 <lispy> sizur: isn't there an M-x reload-... somthing?
15:50:55 <ehird> or you can source the file, but that's a pain
15:50:59 <davidL> eval-buffer ?
15:51:11 <ehird> psht, you're all answering the direct question instead of the implicit one :)
15:51:48 <scodil> ehird: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
15:51:48 <lambdabot> http://tinyurl.com/3arc5q
15:54:10 <oerjan> @docs Data.Sequence
15:54:11 <lambdabot> Data.Sequence not available
15:54:22 <oerjan> hmph
15:54:53 <ehird> any sequence with a O(1) lookup? :|
15:54:56 <ehird> i.e.... an array
15:54:57 <ehird> :P
15:54:59 <ehird> well
15:55:02 <mauke> yes, an array
15:55:05 <ehird> O(1) lookup, Int keys, automatically expanding
15:55:12 <oerjan> ehird: things were rearranged in 6.8, the links from http://www.haskell.org/ghc/docs/latest/html/libraries/index.html are up-to-date
15:55:23 <mauke> ehird: a wrapper around an array
15:55:26 <dons> xmonad 0.6 is released, xmonad fans.
15:55:28 <mauke> expanding will be O(n), though
15:55:37 <vininim> yay
15:55:40 <ehird> mauke: 'a wrapper around an array' helpful :)
15:55:48 <mauke> hmm?
15:55:52 * vininim is darcgeting xmonad right now
15:55:56 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/35731
15:55:57 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:56:13 <vininim> 0.6 is darcs tip?
15:56:42 <dcoutts_> dons: I have to say, I'm rather suspicious of an expat/libxml binding. I don't see how it could give the lazyness we want, and doing lots of ffi with small strings doesn't seem ideal.
15:56:59 <dcoutts_> dons: I worry about the api, though I could certainly be proved wrong
15:57:00 <dons> dcoutts_: i was hoping for sharing
15:57:08 <dons> well, there's ocaml bindings already that are small
15:57:13 <dons> so i figure its pretty cheap to find out
15:57:20 <dons> vininim: yep
15:57:50 <ehird> dcoutts_: that would suck
15:57:54 <ehird> we need a Haskell XML parser
15:58:01 <dons> we've lots :)
15:58:04 <vininim> ^
15:58:06 <dons> and more on the way
15:58:15 <ehird> and hopefully desperately try and discourage actually *producing* XML
15:58:19 <ehird> that horrible thing :-)
16:00:51 <litb> hm, some silly question again
16:01:15 <litb> in a do where i work with IO monads. how can i do "d <- ..." where d yields to [something] ?
16:01:25 <litb> errm
16:01:32 <dons> a list?
16:01:36 <litb> i mean, where ... is a list monad?
16:01:37 <litb> yeah
16:01:47 <dcoutts_> dons: seems to me the most performance sensitive bit is the initial xml lexer
16:01:54 <litb> it says it wants a IO t  and i understand why
16:01:59 <dons> :t do x <- lines `fmap` getContents ; return x
16:02:01 <lambdabot> IO [String]
16:02:01 <litb> but i want to work with the list monad there
16:02:13 <dons> you mean, a list? or the list monad (not the IO monad)
16:02:34 <dons> dcoutts_: yeah, that makes sense. and using non-costly strings
16:02:38 <oerjan> litb: what do you want d to be?
16:02:52 <litb> i have this: main = do ....print...;  x <- map ..; (\y -> ...); ... print;
16:03:02 <dons> litb: maybe hpaste.org your program?
16:03:03 <lispy> > (\x -> do { e <- x; return x } ) [1..3]
16:03:05 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
16:03:08 <litb> oerjan: an element of the list ...
16:03:23 <oerjan> litb: you may use mapM instead
16:03:28 <lispy> > (\x -> do { e <- x; return e } ) [1..3]
16:03:28 <lambdabot>  [1,2,3]
16:03:35 <idnar> litb: can't you just use a nested do?
16:03:35 <dcoutts_> dons: so perhaps we just need a really well coded lazy bytestring xml lexer and the use one of the existing high level libs for the complex bits
16:03:44 <oerjan> or forM
16:03:50 <lispy> > do { x <- [1..3], y <- "abc"; return (x,y) }
16:03:50 <lambdabot>  Parse error at "," (column 17)
16:03:51 <hpaste>  litb pasted "monad fun" at http://hpaste.org/5271
16:03:54 <ehird> Wait! New criterion.
16:03:55 <dons> dcoutts_: yeah, that might work.
16:04:02 <ehird> How can I get a weakref Sequence?
16:04:03 <lispy> > do { x <- [1..3]; y <- "abc"; return (x,y) } -- litb like this?
16:04:04 <dons> its just getting bytestrings in the bottom end that needs to be done well
16:04:04 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
16:04:09 <litb> damn that wasn't it sorry
16:04:26 <dcoutts_> dons: right, what does your xml-light lib do? what approach does it take?
16:04:47 <hpaste>  litb pasted "monad fun" at http://hpaste.org/5272
16:04:52 <litb> that is corrent now
16:05:17 <dons> its a cheap string parser that's been kicking around galois for a few months
16:05:18 <litb> lispy: ah wait i think i see what is wrong
16:05:22 <lispy> litb: looks german :)
16:05:24 <litb> :)
16:05:25 <dons> still waiting on release approval
16:05:27 <ehird> Wait no
16:05:28 <ehird> new idea.
16:05:29 <dcoutts_> dons: [Char]?
16:05:39 <ehird> symTab :: IO (IORef (S.Seq String)) -- how can i make this type non-ugly
16:05:45 <dons> yeah,
16:06:38 <oerjan> litb: er, where in that haystack is the problem? :)
16:06:40 * dcoutts_ has to teach in the morning
16:06:41 <dcoutts_> g'night folks
16:06:42 <hpaste>  litb pasted "monad fun" at http://hpaste.org/5273
16:06:45 <litb> now
16:06:45 <mauke> ehird: symTab :: IORef (S.Seq String)
16:06:49 <litb> i don't get that
16:06:53 <dons> night duncan
16:06:58 <litb> at the bottom in main
16:07:10 <litb> where i do "n <- map (flip (integrateAtLeast (funktionen !! 1) simpson) (0, pi)) eps"
16:07:11 <ehird> mauke: and now i've brought in unsafePerformIO
16:07:12 <ehird> :|
16:07:22 <mauke> ehird: why does it have to be global?
16:07:31 <litb> ehm i have the feeling that i mix do notation and >>=
16:07:40 <ehird> mauke: Because(TM)
16:07:54 <mauke> not a very good reason
16:07:59 <ehird> because i don't want to define "data Interp = Interp ..."
16:08:04 <ehird> because it's a simple language interpreter
16:08:04 <ehird> :P
16:08:15 <oerjan> litb: forM (map ...) $ \n -> do ... ?
16:08:42 <hpaste>  litb pasted "monad fun" at http://hpaste.org/5274
16:08:46 <litb> that is it rly
16:08:49 <litb> :)
16:08:57 <mauke> ehird: newtype Interp a = Interp {runInterp :: ReaderT Env IO a} deriving (Functor, Monad, MonadReader Env, MonadIO)
16:08:59 <litb> i think that sums it up nicely what problem i have
16:09:17 <ehird> mauke: blargle.
16:09:21 <litb> i wanted to do it with the list monad and wondered how that works
16:09:27 <ehird> that'll just complicate my code.
16:09:33 <mauke> in fact, you could use StateT with a plain Seq
16:09:51 <litb> i already succeeded with forM and map and stuff, but i wonder how it is done when i want to do that with the list Monad like i tried
16:09:52 <oerjan> litb: um you have a return in the middle of a do block, that is useless
16:09:57 <mauke> how does it complicate your code (apart from writing symTab <- ask)?
16:10:12 <lispy> litb: a list monad is like working in a list comprehension
16:10:24 <litb> i thought it is replaced with this:
16:11:10 <litb> (map (flip (integrateAtLeast (funktionen !! 1) simpson) (0, pi)) eps) >>= (\n -> return (show n ++ "; " ++ show (2 - (loesung n))))
16:11:23 <litb> i.e list >>= function
16:11:48 <lispy> > [1..3] >>= id
16:11:48 <lambdabot>   add an instance declaration for (Num [b])
16:11:49 <lambdabot>     In the expression: 3
16:11:52 <litb> but it doesn't work because it wants a IO t since i am in a IO do block i suppose
16:12:21 <ehird> mauke: also, what is readerT :P
16:12:25 <litb> > [1..4] >>= const (IO String)
16:12:26 <lispy> :t ([1..3] >>=)
16:12:29 <lambdabot>   Not in scope: data constructor `String'
16:12:29 <lambdabot> forall t b. (Num t, Enum t) => (t -> [b]) -> [b]
16:12:50 <litb> lispy: yes, lispy that is the problem
16:12:52 <mauke> ehird: a monad transformer
16:12:53 <litb> it wants a IO t
16:13:01 <oerjan> litb: you can have return $ do ... where the inner do is a different monad from the outer
16:13:03 <lispy> litb: it takes a function that goes from the list element type to a monad type (in this case, a list)
16:13:11 <litb> oerjan: oh i see
16:13:39 <litb> so i can do a nested do where a different monad rules?
16:13:44 <oerjan> yep
16:15:27 <jonaskoelker> okay, this is just dumb: perl can't be parsed -- http://perlmonks.org/?node_id=663393
16:15:31 <lambdabot> Title: Perl Cannot Be Parsed: A Formal Proof
16:15:40 <ehird> old news
16:15:40 <ehird> :)
16:15:44 <jonaskoelker> I know
16:16:04 <jonaskoelker> presumably there's at least one non-slashdotter in here?
16:16:07 <jql> I have a certain counter-proof
16:16:16 <jonaskoelker> ORLY?
16:16:17 <jql> it's located in /usr/bin/perl
16:16:17 <jql> heh
16:16:21 <jonaskoelker> -.-
16:16:42 <dons> that's not really old news is it?
16:17:00 <dons> its a nice result though :)
16:17:30 <idnar> jql: "For those not familiar with the history of this discussion, the term "parse" here is being used in its strict sense to mean static parsing -- taking a piece of code and determining its structure without executing it. In that strict sense the Perl program does not parse Perl. The Perl program executes Perl code, but does not determine its structure."
16:17:47 <ehird> jql: please read the document
16:17:53 <oerjan> jonaskoelker: haskell 98 cannot be parsed either, i hear
16:17:56 <dons> yeah, they establish you need to modify the parser at runtime
16:18:02 <jonaskoelker> :O
16:18:09 <dons> now oerjan's being silly
16:18:32 <jql> I'm fully aware of the perl parsing requirements, separate from the paper. it's a well-known issue
16:18:37 <jql> and old
16:18:41 <vincenz> http://notvincenz.blogspot.com/2008/01/fractional-type-for-haskell.html
16:18:42 <lambdabot> Title: lambda.oasis: A Fractional Type for Haskell, http://tinyurl.com/22pj3x
16:18:46 <oerjan> no, i think Philippa(?) confirmed it, there are ugly paradoxes hiding in layout + defined precedence
16:18:58 <litb> darn it says "The last statement in a 'do' construct must be an expression"
16:19:10 <Cale> Man, JDH is such an annoying troll.
16:19:21 <Cale> http://reddit.com/r/programming/info/665dh/comments/c02ysc0
16:19:31 <mauke> pfft, halting problem
16:19:34 <lispy> Cale: Harrop?
16:19:37 <Cale> yeah
16:20:01 <dons> he played around with frag a year ago, and it didn't work on his amd64.
16:20:04 <dons> that's since been fixed.
16:20:15 <vincenz> Wow
16:20:19 <vincenz> Cale got frustrated
16:20:25 <vincenz> Cale is usually the image of zen within the haskell domain
16:20:29 <oerjan> litb: is the last line using <- ? you cannot have that
16:20:39 <mauke> BEGIN { *foo = rand() < 0.5 ? sub () { 1 } : sub { 2 } } foo / die; #/;
16:20:49 <oerjan> the do must have a final result
16:20:51 <mauke> it's pretty obvious you can't really "parse" this
16:21:22 <lispy> "unsafe monads"
16:21:22 <litb> > do { p <- (Just 0); return $ do { n <- [1, 2, 3]; return (n, p) } }
16:21:24 <vincenz> anyone feel like correcting http://reddit.com/r/programming/info/665dh/comments/c02yz88  ?
16:21:25 <lambdabot>  Just [(1,0),(2,0),(3,0)]
16:21:25 <lispy> i like that term
16:21:26 <dolio> @quote JonHarrop
16:21:27 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
16:21:33 <litb> hm, lambdabot makes that
16:21:36 <litb> but here that fails
16:21:40 <jql> obviously. however, BEGIN{} is not required for perl anymore than macros are required in lisp. and by that I mean it's useless. :)
16:21:43 <litb> maybe indentation is wrong here
16:21:51 <Cale> vincenz: I didn't even want to dignify that one with a response.
16:22:02 <litb> oerjan: no the last thing is return here, pretty much like above
16:22:11 <dons> vincenz: hardly worth it.
16:22:16 * vincenz did Could you define 'unsafe monads' or do you just throw terms around at random?
16:22:25 <litb> ah, wait i don't have ; but i have { ..} :)
16:22:27 <vincenz> dons: No, but a blog entry on "how to optimize" in general could be interesting
16:22:35 <Cale> vincenz: That's a decent shot.
16:22:44 <dons> vincenz: but fixed anyway.
16:22:45 <litb> yeah it works
16:22:52 <dons> since there's a bloody great chunk on the wiki
16:22:58 * vincenz nods
16:23:03 <vincenz> haven't looked at the wiki as of late
16:23:18 <vincenz> Anywho, back to blogging about Haskell
16:23:22 <litb> i'm starting to love monads =)
16:23:41 <vincenz> Cale: I'm writing aobut CFs
16:23:50 <Cale> vincenz: cool
16:23:59 <Cale> litb: :)
16:24:01 <scodil> in Core there is a pattern matching symbol __DEFAULT which appears to work like an underscore, but it's position-independent, ie you can use it as the first clause. Is there anything like that for regular use outside of Core?
16:24:02 <vincenz> already wrote a leadup post with the fraction type
16:24:17 <conal> vincenz: "CF"?
16:24:21 <vincenz> continued fractions
16:24:27 <conal> thx
16:24:36 <vincenz> conal: I spent last week hacking those to gether
16:24:45 <hpaste>  litb pasted "isn't this neat ? " at http://hpaste.org/5275
16:24:47 <conal> vincenz: any particular motivation?
16:24:48 <vincenz> In the end, they're completely useless, at least in my eye, but it was great hacking
16:24:48 <gwern> maybe an unsafe monad is a monad which calls something using an unsafe* function?
16:24:53 <litb> :)
16:25:01 <vincenz> conal: I saw a presentation on them, and they seemed interesting
16:25:14 <vincenz> that and there's little info on them out there
16:25:17 <dolio> gwern: I don't think he's thought it through that much.
16:25:28 <lispy> does jdh believe is being helpful and useful with his comments?
16:25:36 <vincenz> conal: I was hoping to get exact reals (computable)
16:25:44 <scodil> of course not he's got books to sell
16:25:48 <gwern> dolio: yeah. because then would using NOINLINE make them safe again now that the dastardly laziness can't make it run at odd times?
16:25:51 <vincenz> conal: but reals won't work for a variety of reasons with this implementation, but I know why and I know how to fix it
16:26:14 <conal> vincenz: neat!
16:26:54 <vincenz> conal: btw, neat posts on the futures and streams :)
16:27:07 <dolio> gwern: "Unsafe monads" is clearly redundant, because monads are just a hack to get back all the unsafe stuff impure/imperative languages can do. :)
16:27:31 <ddarius> dolio: In what way is the Maybe monad, say, unsafe?
16:27:32 <Cale> haha
16:27:36 <conal> litb: you could factor all of the IO to the outside
16:27:46 <conal> vincenz: :)
16:27:58 <Cale> dolio: Watch out, or soon enough we'll have an @dolio in lambdabot :)
16:28:23 <litb> conal: hm, to what outside?
16:28:45 <conal> litb: a single putStr around a pure value.
16:29:00 <jmelesky> does anyone know if any magic words must be spoken to get the Debian pkg install of ghc to find its own libraries?
16:29:08 <gwern> dolio: oh, of course. it's just a nasty hack for how FP languages can't do IO and are useless
16:29:27 <lispy> litb: it's often referred to as 'separation of concerns'  One concern is the IO and the other is building the data that needs to be put through the IO action
16:29:28 <dolio> ddarius: Answering that question in character would require a lot more thought than I'm willing to dedicate. :)
16:29:49 <litb> lispy: ah i see
16:30:13 <kpreid> LoganCapaldo: It is a very common misconception that parsing is most of what there is to compilers
16:30:25 <litb> conal: you mean, concatenating all of them, and then putting the resulting string in one go?
16:31:33 <lispy> I thought I had a reddit login, but searching my email finds nothing.
16:32:07 <Cale> http://reddit.com/r/programming/info/66rfa/comments/ -- hey someone posted a link to my comment about programming with monads, but it's not doing so well, help me out and mod it up.
16:32:08 <dolio> lispy: I havea reddit login but no e-mail. I don't think they send one.
16:32:29 <lispy> hrm...i wonder what my username/password are then
16:32:46 <Korollary> I think I have them
16:33:00 <Korollary> been submitting some Ron Paul stories with it
16:33:41 <vincenz> Cale+1
16:34:04 <Cale> yay!
16:34:19 <scook0> ddarius: fromJust, oh noes! ;)
16:34:34 <lispy> Korollary: thanks for keeping my account active :)
16:35:49 <hpaste>  oerjan annotated "isn't this neat ? " with "simplification" at http://hpaste.org/5275#a1
16:36:24 <hpaste>  litb pasted "like this?" at http://hpaste.org/5276
16:37:26 <Cale> $ -> .  :)
16:37:37 <litb> oerjan: oh, nice :)
16:38:04 <oerjan> litb: putStr $ unlines might be better for your simplification
16:38:45 <litb> @src unlines
16:38:46 <oerjan> (dropping the ++ "\n")
16:38:46 <lambdabot> unlines = concatMap (++ "\n")
16:38:58 <litb> ah i see
16:38:59 <litb> sure
16:39:23 <litb> i wonder whether that is better than the map i had before
16:39:52 <LoganCapaldo> > (>>= (++ "\n")) ["a","b","c"]
16:39:55 <lambdabot>  "a\nb\nc\n"
16:41:44 <lispy> :t intercalate
16:41:45 <lambdabot> Not in scope: `intercalate'
16:41:55 <lispy> ?hoogle intercalate
16:41:56 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
16:41:56 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
16:41:56 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
16:42:48 * gwern is still being smacked by it
16:43:06 <shachaf> dons: What was it that was stopping lambdabot from using 6.8 again?
16:43:35 <davidL> shachaf: Cale built it on 6.8, he said how he did it yesterday if you check the logs
16:43:45 <idnar> what is intercalate?
16:43:59 <oerjan> @src intercalate
16:43:59 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
16:44:01 <mauke> (concat .) . intersperse
16:44:05 <adu> > toRational $ exp 1
16:44:06 <lambdabot>  6121026514868073%2251799813685248
16:44:13 <Cale> It was trivial enough that I didn't bother to submit patches... I could do that if people want.
16:44:21 <adu> hmm
16:44:29 <shachaf> Cale: It would be nice.
16:44:31 <Cale> okay
16:44:35 * shachaf has gotten it to build too.
16:44:42 <adu> why does lambda bot have better rational approximation then i do?
16:44:42 <litb> one question:
16:44:47 <shachaf> mbot's been using 6.8 for a while, hasn't it?
16:44:55 <Cale> All you have to do is account for split base, and change one instance of the type IRCError in a deriving clause to 'e'.
16:44:59 <Cale> yes
16:44:59 <litb> why do i need let n = ... and why cannot  i do "n <- ..." ?
16:45:01 <chessguy> @version
16:45:01 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
16:45:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:45:12 <Cale> It's been using 6.8 ever since I fixed hs-plugins to work on 6.8
16:45:22 <Cale> That was the main problem.
16:45:31 <chessguy> did somebody not update the @version message?
16:45:35 <shachaf> Cale: So what's stopping dons?
16:45:44 <shachaf> chessguy: lambdabot is still 6.6.
16:45:44 <Cale> chessguy: lambdabot's still not using 6.8, mbot is
16:45:50 <oerjan> litb: because the part to the right of = is not monadic
16:45:54 <adu> > exp 1
16:45:55 <lambdabot>  2.718281828459045
16:45:56 <Cale> (the version message is autogenerated)
16:45:58 <litb> ah i understand
16:46:20 <chessguy> oh, i can't read
16:46:20 <Cale> adu: -fexcess-precision
16:46:38 <adu> Cale: oh! that makes sense
16:47:14 * ddarius renames fromJust, unsafePerformMaybe
16:47:36 <chessguy> @src fromJust
16:47:36 <lambdabot> fromJust Nothing  = undefined
16:47:36 <lambdabot> fromJust (Just x) = x
16:47:38 <davidL> > fromJust Nothing
16:47:39 <lambdabot>  Exception: Maybe.fromJust: Nothing
16:48:19 <dmwit> unsafeExecMaybe?
16:48:30 <oerjan> dmwit: eval, not exec
16:48:47 <dmwit> oerjan: I was just going to look that up. =P
16:49:17 <chessguy> i can never remember which is which
16:49:17 <Saizan> Cale: do you also have link errors from eval when importing haskell98 modules? (like Char)
16:49:22 <chessguy> @type execState
16:49:23 <lambdabot> forall s a. State s a -> s -> s
16:49:23 <olsner> > fromMaybe undefined Nothing
16:49:24 <lambdabot>  Undefined
16:49:49 <mauke> chessguy: eval gives you the value, exec only the side effects
16:49:51 <oerjan> well, e_val_ gives you a value
16:49:53 <Cale> Saizan: yes, that can easily be fixed
16:50:01 <Cale> Saizan: Just remove the old H98 imports.
16:50:10 <Cale> (all except Numeric)
16:50:33 <Cale> The H98 modules have moved to the haskell98 package.
16:50:34 <Saizan> yeah, but they should work i think?
16:50:46 <Cale> So if you really wanted them, you'd have to specify that package somehow.
16:50:48 * chessguy shrugs....the state is a value too
16:51:03 <mauke> chessguy: but it's not the return value
16:51:13 <Cale> But they all have equivalents in System.* and Data.*
16:51:24 <Cale> (except Numeric, which is still in base)
16:52:50 <Saizan> ah ok, didn't notice everything else imported was in base
16:53:03 <Saizan> +i
16:55:01 <mauke> <GumbyBRAIN> Simcop i know up there except weird sex, curry and drugs.
16:55:09 <mauke> is there anything we should know about currying?
17:08:08 <conal> wow -- we just had a flash flood here.  i live in the woods on a hillside.
17:08:17 <dons> "A number of features in the Perl 6 language now show similarities with Haskell, and Perl 6 has been embraced by the Haskell community as a potential scripting language["
17:08:24 <dons> [citation needed] on wikipedia.
17:08:40 <dons> i'd argue that haskell's been embraced by the haskell community as a potential scripting language :)
17:08:43 <dons> wow, conal
17:09:07 <olsner> by "flash flood" I first thought you meant IRC flood and wondered why I hadn't seen any flooding
17:09:16 <davidL> Have gwern edit it :)
17:09:37 <vincenz> @join #oasis
17:09:50 <EvilTerran> olsner, do you maybe not have the flash plugin installed in your client? that might explain why you didn't see anything.
17:10:02 <davidL> @listchans
17:10:02 <lambdabot> ##logic #curry #darcs #friendly-coders #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #jtiger #oasis #perl6 #scala #scannedinavian #unicycling #xmonad
17:10:08 <davidL> wow, heh
17:10:20 <oerjan> @list listchans
17:10:21 <lambdabot> system provides: echo list listchans listmodules listservers uptime
17:10:49 <oerjan> @listservers
17:10:50 <lambdabot> freenode
17:11:31 <gwern> davidL: where's it from?
17:11:57 <olsner> EvilTerran: har har, that must be it :P
17:12:48 <davidL> http://en.wikipedia.org/wiki/Perl
17:12:49 <lambdabot> Title: Perl - Wikipedia, the free encyclopedia
17:12:54 <EvilTerran> :)
17:13:46 <gwern> hum. I'll see what I can do, once xmonad is working for me again
17:15:26 <dons> have you reverted to the defaults, gwern ?
17:15:35 <dons> or tried not having a xmonad.hs at all?
17:16:16 <gwern> dons: yes, but for some reason it doesn't like my keys, with the odd error message Couldn't match expected type `XMonad.Core.X ()' against inferred type `xmonad-0.6:XMonad.Core.X ()'
17:16:23 <gwern> nor my layouts
17:16:30 <dons> that's a versioning issue
17:16:40 <dons> you've got one thing compiled against xmonad 0.5
17:16:44 <dons> and something else compiled against 0.6
17:16:51 <dons> its probably the root of all your woes
17:17:14 <dons> good idea now to unregister xmonad. grab the tarballs from hackage. build xmonad; build xmonad-contrib; then be on your way
17:17:35 <shachaf> dons: Cabal still can't uninstall packages, can it?
17:17:43 <dons> ghc-pkg unregister --user xmonad
17:17:56 <shachaf> dons: That just unregisters -- the files stay there.
17:19:01 <dons> yep. sure.
17:19:44 <gwern> dons: I can
17:19:49 <gwern> 't install xmc from hackage because of the xft thing
17:20:07 <dons> gwern: download the .tar.gz (not via cabal install)
17:23:29 <shepheb> oh is there a new xmonad pre-release?
17:23:39 <dons> there's a new release!
17:23:42 <mauke> what's a pre-release?
17:23:52 <dons> snapshots for testing
17:23:54 <shepheb> badass. *rushes off to DL*
17:24:03 <dons> http://www.haskell.org/pipermail/haskell-cafe/2008-January/038715.html
17:24:04 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: xmonad 0.6 released, http://tinyurl.com/23993p
17:24:04 <mauke> do we have those?
17:24:13 <shepheb> "pre-release" is synonymous with "don't whine if it doesn't work"
17:24:26 <dons> we do those, yes.
17:24:41 <allbery_b> no, it's "do whine if it doesn't work, we need to get the final bugs out before release"
17:25:08 <dons> yep
17:25:49 <monochrom> I have an idea for a companion for xmonad. It is called xmonadplus. It is a screen saver. It plays an SPJ lecture video or its slides. If you use it at work, it may attract your colleague-passers-by to functional programming.
17:25:56 <shepheb> whine /= submit bug
17:26:24 <allbery_b> submit bug?  nope, it all happened in #xmonad
17:26:30 <allbery_b> :)
17:27:01 <dons> a lot of it did.
17:27:09 <dons> monochrom: oh, nice idea.
17:27:15 <dons> subliminal haskell stuff
17:28:06 <monochrom> It is inspired by someone who asked earlier for a haskell cheat sheat or any FP-related picture or page for use as a desktop wallpaper. :)
17:28:59 <dons> yeah. good idea.
17:29:06 <lispy> monochrom: oh, yeah have the system F_omega type checking rules as a screen saver!
17:29:18 <monochrom> hahahahaha that's scary!
17:29:37 <monochrom> @remember lispy have the system F_omega type checking rules as a screen saver!
17:29:37 <lambdabot> Good to know.
17:30:16 <mauke> @quote
17:30:16 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
17:31:30 <dons> ?quit
17:31:49 <nominolo> @quote omega
17:31:54 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
17:31:59 <mauke> @quote lispy
17:32:00 <lambdabot> sing with me?
17:32:06 <lambdabot> lispy says: lambdabot, changing the way Haskllers think since 2003
17:32:23 <chessguy> @quote gamma
17:32:29 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
17:32:35 <lambdabot> sing with me?
17:32:37 <nominolo> @quote F_omega
17:32:41 <lambdabot> lispy says: have the system F_omega type checking rules as a screen saver!
17:32:48 <monochrom> Does Campbell vegetable soup in Greece use Greek letters? :)
17:32:57 <lispy> heh
17:33:05 <olsner> Geek letters :)
17:33:12 <gwern> whew. glad that finally got cleared up. dunno what did it, the unregistering or the sdist tarball. probably the former
17:33:42 <EvilTerran> Fomegathemouth?
17:33:50 * oerjan realizes sdist only lacks one letter to mean something quite different
17:34:15 <EvilTerran> `man sdist`
17:34:16 <oerjan> no wonder it gives trouble...
17:34:37 <shachaf> EvilTerran: `man sdist`?
17:35:01 <EvilTerran> never you mind :P
17:35:13 <shachaf> Oh, /me was thinking of dist/sdist.
17:35:34 <jbms> is there some equivalent to the SML ref type in haskell?
17:35:45 <mauke> yes, IORef
17:35:45 <Saizan> is there a parser combinator library with a <|> that will merge common matchable prefixes so it's commutative but doesn't backtrack?
17:35:50 <mauke> or maybe STRef
17:35:54 <nominolo> ioref/stref/mvar
17:36:02 <EvilTerran> Saizan, there's ReadP
17:36:17 <lispy> > head $ do { x <- ['a'..'z']; return ("s"++[x]++"dist") }
17:36:18 <lambdabot>  "sadist"
17:36:26 <EvilTerran> that only works on String inputs, but i think at least one person's generalised it
17:36:35 <olsner> maybe a packrat parser would take care of that
17:37:06 <Saizan> string is fine, but i thought ReadP was backtracking
17:37:12 <chessguy> @vera STFW
17:37:12 <lambdabot> No match for "STFW".
17:37:18 <lispy> Did anyone else read that article about not parsing perl?
17:37:25 <nominolo> Saizan: utrecht parsers
17:37:41 <nominolo> Saizan: also, see Koen Claessen's papers
17:37:56 <nominolo> "parallel parsing processes"
17:38:25 <Saizan> nominolo: is there any realesed code for those?
17:38:35 <nominolo> google for Parsek
17:38:43 <nominolo> it should also be in polyparse
17:40:14 <nominolo> Saizan: the utrecht parsers are unfortunately devilishly generalized
17:40:34 <dons> diabolically general!
17:40:43 <dons> its the way of research :)
17:40:53 <nominolo> yeah, it seems ...
17:41:01 <nominolo> it's not even on hackage, either ;)
17:41:16 <dons> then it doesn't exist :)
17:41:59 <EvilTerran> Saizan, the P is for Parallel, so it shouldn't be backtracking
17:42:07 <EvilTerran> altho laziness may do strange things
17:42:40 <lispy> anyway, I don't buy the author's proof.  Not yet.  I don't get why it's important for the parser to know if a subroutine halts before it can assign a type to an expression that follows it.  If the potentially non-halting subroutine happens at parse time, then I don't think it's the parser's job to worry about the case where the subroutine doesn't parse.  In that case, the parse fails. IMO.
17:42:48 * EvilTerran notes that "f <$> g <$> x" should do what one'd expect, but not for the reason one'd initially expect
17:43:21 <nominolo> :t \f g x -> f <$> g <$> x
17:43:22 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
17:43:25 <shachaf> EvilTerran: What do you mean?
17:43:47 <EvilTerran> well, i'm talking to a newbie on another channel who expected that to be f <$> (g <$> x)
17:44:00 <EvilTerran> but it's infixl, so it's actually (f <$> g) <$> x
17:44:06 <olsner> lispy: I think his point is rather that the syntax of perl belongs to some higher class of grammar (possibly an unrestricted grammar, if it really does require execution of arbitrary code to parse later parts of the source)
17:44:10 <EvilTerran> but then i think that first <$> is going to get interpreted as a (.)
17:44:39 <EvilTerran> so it becomes (f . g) <$> x, which is the same as f <$> (g <$> x) by the functor laws
17:44:52 <nominolo> > (+3) <$> (*4) <$> Just 42
17:44:53 <lambdabot>  Just 171
17:45:08 <shachaf> EvilTerran: f <$> (g <$> x) = (fmap f . fmap g) x = fmap (f . g) x = fmap (f <$> g) x = (f <$> g) <$> x
17:45:24 <EvilTerran> shachaf, er, yes. that's what i just said.
17:45:35 <shachaf> EvilTerran: Sorry, I got disconnected for a bit.
17:45:40 * shachaf didn't see your messages.
17:45:42 <EvilTerran> so it does *act* like it's f <$> (g <$> x), but it doesn't do so for the reason you'd expect
17:45:43 <lispy> olsner: so, if you're saying that to parse perl, the parser needs to feed somethings to the evaluator as it goes...then I guess I see you're point.
17:45:57 <lispy> your*
17:46:01 <shachaf> EvilTerran: What reason would you expect?
17:46:07 <EvilTerran> shachaf, that <$> is right-associative
17:46:17 <EvilTerran> (it isn't, but that's what the newbie was expecting)
17:46:24 <shachaf> Oh.
17:46:37 <EvilTerran> it'd be a perfectly good reason for it to act like f <$> (g <$> x), mind :P
17:46:44 <pjd> lispy: that whole thing seems to miss the point that good Perl code should come with declared prototypes
17:47:07 <mauke> pjd: what?!
17:47:09 <EvilTerran> pjd, actually, i thought the general consensus was that you should never use prototypes in perl
17:47:20 <EvilTerran> as they're the only thing that cause that problem in the first place
17:47:53 <ddarius> The <$> obscures things in this case
17:48:08 <EvilTerran> a function doesn't count as "nullary" for parsing purposes unless it's explicitly given the empty parameter prototype
17:48:52 <pjd> doesn't that make the article's point doubly silly?
17:49:03 <larmeh> can i import the regex module by simply stating "import Text.Regex.Posix"?
17:49:07 <EvilTerran> olsner, it does allow such execution; if you wrap some code in a BEGIN{...} block, say, it's run as soon as it's parsed, before the rest of the file is parsed, and it can affect dramatically how the rest of the file is parsed
17:49:28 <gwern> pjd: but that's voluntary. you might as well claim something silly like that 'haskell programs might not terminate' is missing the point that good Haskell code should be total
17:49:36 <lispy> EvilTerran: ah, I wondered what evil BEGIN held...now I know.
17:49:56 <EvilTerran> lispy, more simply, the module-importing construct "use" does the same thing
17:50:14 <lispy> EvilTerran: sorry, I don't know perl.
17:50:22 <mauke> use Some::Module LIST; === BEGIN { require "Some/Module.pm"; Some::Module->import(LIST) }
17:50:26 <gwern> *the point because
17:50:43 <EvilTerran> and "require" runs the source of a file, provided it hasn't been run already
17:51:30 <lispy> So, is the real problem here that you can execute code during the parse phase?
17:51:33 <jql> BEGIN blocks run even before the parse finds the closing } -- it could be missing
17:51:36 <ddarius> pjd: If you are writing a parser for Perl, you can't assume the code is well written.
17:51:41 <EvilTerran> lispy, pretty much, head
17:51:44 <mauke> jql: no
17:51:44 <EvilTerran> er, yeah
17:51:53 <EvilTerran> jql, er... are you *quite* sure?
17:52:02 <mauke> lispy: and that the contents of the symbol table affect the lexer
17:52:21 <pjd> ddarius: sure, but you can assume most code is adequately written, and bail out on the rest
17:52:23 <lispy> mauke: right, but I figured that's true of most languages?
17:52:24 <olsner> hmm, I wonder if the same thing can be proven of C++
17:52:37 <jql> err, of the *surrounding* context. I meant like: perl -le '{ BEGIN { print "Hello World!" }'
17:52:40 <EvilTerran> olsner, what, do something horrific with templates?
17:52:45 <EvilTerran> (or is that redundant?)
17:52:50 <jql> shouldn't have implied of the BEGIN block itself
17:52:52 <mauke> lispy: I think most languages don't expose the symbol table as a program-visible variable
17:52:54 * jql is teh confusing
17:53:01 <pjd> olsner: templates are Turing complete, aren't they?
17:53:07 <lispy> pjd: yes
17:53:08 <EvilTerran> jql, well, yes. that's what we meant by "running as soon as the block is parsed" - it doesn't know what comes after
17:53:14 <idnar> templates aren't executed at parse time, surely?
17:53:14 <olsner> EvilTerran: nah, templates are boring and well-examined at this point... besides, most compilers define a recursion limit on templates
17:53:20 <lispy> pjd: you can pretty easily implement factorial, for example
17:53:23 <ddarius> pjd: The whole point of the exercise is whether it was -necessary- to bail out in some cases or whether it was theoretically possible but just practically very difficult.
17:54:02 <EvilTerran> <ddarius> pjd: If you are writing a parser for Perl, you can't assume the code is well written. <- i'd be happy saying "only good programmers can use my tools"
17:55:08 <mauke> a pure parser will fail on code like: use List::Util; print first { $_ % 13 == 10 } 23 .. 99;
17:56:10 <lispy> mauke: because the operators defined in List::Util are not available to the parse?
17:56:40 <mauke> right
17:56:56 <mauke> well, "operators" -- they're subroutines :-)
17:57:19 <lispy> how is that different than parsing any language that uses modules?
17:57:58 <olsner> idnar: templates affect the parsing of later elements by deciding whether certain names are types or values, IIRC, so they are run at parse time (although there are ways to parse those cases into "don't know" and resolve afterwards)
17:58:03 <mauke> a java module can't mess with the lexer
17:58:23 <idnar> olsner: hmm, I thought you had to explicitly disambiguate in those kinds of cases
17:58:37 <mauke> (new OmgClass()).x().y(); is parseable without additional information
17:58:40 <lispy> mauke: i'm perl-ignorant, what did the List::Util module do to the lexer in your example?
17:59:00 <mauke> lispy: it defined first() as taking a code block as its first argument
17:59:43 <lispy> mauke: so, haskell let's you define operators (and their fixity) does that make it unparsable in this sense?
18:00:06 <mauke> it makes it at least ambiguous
18:00:10 <EvilTerran> lispy, for normal subroutines in perl, you can't do foo{ block; of; code } ...
18:00:18 <mauke> you can still lex it, though
18:00:38 <lispy> mauke: i see your point
18:00:58 <EvilTerran> lispy, but the horrible mistake of "subroutine prototypes" made it possible to allow this for specific functions, thus ruining everything
18:00:58 <lispy> mauke: so how much can the lexer be 'bent' in perl?
18:01:11 <mauke> hah, actually: use X; print f 42; is ambiguous
18:01:22 <lispy> mauke: couldn't you make a sophisticated lexer that takes all the language constructs into account?
18:01:30 <hpaste>  larmeh pasted "Why would this cause an error on line 16?" at http://hpaste.org/5277
18:01:32 <EvilTerran> http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm
18:01:37 <EvilTerran> lispy, that far
18:01:38 <lambdabot> Title: The CPAN Search Site - search.cpan.org, http://tinyurl.com/33tb6
18:01:54 <mauke> lispy: the lexer is context dependent. it has to know whether a term or an operator is expected
18:02:25 <mauke> that's how it distinguishes / (the division operator) and / ... / (the regex match operator)
18:02:47 <oerjan> larmeh: =~ takes a String as first argument, not a Char
18:02:49 <olsner> idnar: hmm, yeah, I think so too, so perhaps I'm just imagining things.. or there's something else beside the type/value ambiguity you would get troubles with.. I have gone too long without template hacking!
18:02:58 <lispy> mauke: okay, because userdefined operators share the same 'lexical space' as user defined functions? (by operator I mean it has different syntax, like the 'first' subroutine)
18:03:04 <larmeh> oerjan: oh right, thanks
18:03:04 <EvilTerran> lispy, although you could argue that so-called "source filters" are cheating; if you rule those out, what mauke's saying becomes relevant
18:03:24 <mauke> lispy: they're the same thing
18:03:28 <jonaskoelker> does haskell have a pipe operator?  I'm thinking "infixl 0 pipe; x pipe f = f x", similar to $, but you get to read your code left-to-right instead of the other way
18:03:36 <jql> there is a perl tokenizer, but it only works if there is a *possible* legal tokenization without reading the module declarations
18:04:01 <Mr_Awesome> jonaskoelker: >>>
18:04:11 <mauke> lispy: perl "prototypes" attach special argument parsing rules to user-defined functions
18:04:12 <pjd> or >>= ?
18:04:12 <EvilTerran> Mr_Awesome, that's flip (.) not flip ($)
18:04:34 <Mr_Awesome> EvilTerran: oh, right
18:04:36 <LoganCapaldo> > 23 (show $)
18:04:37 <lispy> mauke: this is starting to sound like lisp macros (and using them to create special forms like cond)
18:04:37 <lambdabot>        add an instance declaration for (Num ((a -> String) -> a1))
18:04:37 <lambdabot>     In the...
18:04:41 <Mr_Awesome> >>= it is then
18:04:41 <ddarius> jonaskoelker: You can define your own operators.
18:04:45 <mauke> lispy: the set of possible rules is very limited (unlike lisp)
18:04:45 <EvilTerran> >>= would work if the Identity monad didn't need a mess of newtyping
18:04:48 * LoganCapaldo fails
18:04:58 <Mr_Awesome> oh, >>= doesnt work?
18:04:59 <EvilTerran> lispy, did you see that link i pasted?
18:05:08 <lispy> EvilTerran: sorry, no, i'll go find it
18:05:14 <LoganCapaldo> > (23 `show`)
18:05:15 <lambdabot>  "23"
18:05:16 <mauke> lispy: but it's enough to cause confusion with /, which means you don't know whether you're inside a quoted construct (/.../) or not
18:05:20 <LoganCapaldo> there we go
18:05:35 <lispy> EvilTerran: what is it?
18:05:52 <EvilTerran> lispy, it's a perl module. you import it, and then write code that looks like latin
18:05:57 <jonaskoelker> yeah, I can write my own, but it'd be nicer to use the Standard Way of doing things where it exists
18:06:04 <shepheb> LRP is awesome
18:06:12 <larmeh> oerjan: hm, the error remains
18:06:17 <lispy> EvilTerran: ah, i was about to ask if it was in italian
18:06:24 <larmeh> looks like there is an instance declaration missing
18:06:38 <EvilTerran> lispy, it's something called a "source filter"; probably the first thing you'd ban if you wanted to be able to parse perl
18:06:50 <larmeh> but how would an instance declaration look like?
18:07:19 <EvilTerran> lispy, as it allows arbitrary transformations to the source text (written in perl) to be applied, depending on what modules you impr
18:07:22 <EvilTerran> *import
18:07:26 <lispy> EvilTerran: yeah...wow, okay...that's just wrong.  Yet another reason, why Perl scares me.  I mean, programmer control is nice, but... that seems like a bit much.
18:07:51 <pjd> lispy: Perl in a nutshell
18:07:53 <shepheb> but you can write in Latin!
18:07:55 <EvilTerran> lispy, but, if you disallow that sort of thing (many people do), what mauke's saying remains relevant. so go read that. :P
18:09:09 <larmeh> >:mod Text.Regex.Posix
18:09:29 <lispy> "Numeric literals in Perligata are rendered by Roman numerals -- I, II, III, IV...XV...XLII, etc, up to (((((((I)))))))((((((((I))))))))((((((I))))))(((((((I)))))))(((((I)))))((((((I))))))((((I))))(((((I)))))(((I)))((((I))))((I))(((I)))M((I))CMXCIX (that is: 9,999,999,999)"  <-- ugh!
18:09:30 <larmeh> hm, shouldnt lambdabot respond to that?
18:09:40 <lispy> larmeh: missing a space after >
18:09:45 <lispy> > :mod Text.Regex.Posix
18:09:45 <lambdabot>   parse error on input `:'
18:09:46 <larmeh> oops
18:09:54 <lispy> but, I don't think lambdabot knows :mod
18:09:59 <lispy> it's not ghci :(
18:10:02 <mauke> :mod is not valid syntax
18:10:03 <oerjan> :t (Text.Regex.Posix.=~)
18:10:03 <larmeh> :-/
18:10:04 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.Wrap.Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.
18:10:04 <lambdabot> Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption source) => source1 -> source -> target
18:10:09 <oerjan> eek
18:10:29 <lispy> nice type
18:10:35 <larmeh> heh
18:11:16 <larmeh> > "blah" =~ "[a-z]|[A-Z]" :: Bool
18:11:16 <lambdabot>   Not in scope: `=~'
18:11:21 <larmeh> hrm
18:11:32 <oerjan> larmeh: does that work in your ghci?
18:11:40 <lispy> > "blah" Text.Regex.Posix.=~ "[a-z]|[A-Z]" :: Bool
18:11:40 <lambdabot>   Not in scope: `Text.Regex.Posix.=~'
18:12:11 <larmeh> oerjan: if i imported Text.Regex.Posix first, yes
18:12:37 <lispy> and it returns, false, right?
18:12:47 <larmeh> no, True
18:12:49 <oerjan> larmeh: ok then you are not missing an instance i think
18:13:04 <lispy> shouldn't it need a * in there to return true on that?
18:13:11 <oerjan> just a different type error
18:13:15 <larmeh> oerjan: yes but how can i write an instance then?
18:13:26 <oerjan> larmeh: you are _not_ missing an instance
18:13:37 <larmeh> oops :)
18:13:46 <larmeh> erm, so what else could it be?
18:14:00 <larmeh> its not a type error
18:14:03 <oerjan> larmeh: try making the type declaration matchRegEx :: String -> Bool
18:15:29 <oerjan> that will probably give you a type error elsewhere instead
18:15:36 <wy> regex becomes popluar topic these days ;)
18:15:52 <larmeh> oerjan: i don't think i understand what you mean
18:16:16 <oerjan> larmeh: the a in matchRegex must be a String, essentially
18:16:24 <wy> Any idea how to write a DFA that recognizes binary numbers that is multiple of 3?
18:16:36 <oerjan> larmeh: are you really sure you want it to be a Char?
18:16:51 <larmeh> oerjan: well i changed the code to String
18:17:01 <EvilTerran> wy, well, that's determined entirely by the two least significant digits, i think
18:17:10 <larmeh> and it actually _is_ a String now
18:17:13 <oerjan> larmeh: oh.  could you annotate with the new code and error message?
18:17:26 <EvilTerran> no, wait, of course it isn't
18:17:33 <EvilTerran> wy, are you sure that's a regular language?
18:17:42 <larmeh> sorry yes... but the error message stayed the same
18:17:42 <oerjan> EvilTerran: it is
18:17:53 <oerjan> larmeh: have you reloaded the module?
18:17:54 <wy> EvilTerran: I don't know. Your idea reminded me something...
18:18:05 <EvilTerran> oerjan, what, determined by the last two digits, or regular?
18:18:07 <larmeh> oerjan: i even restarted ghci
18:18:18 <EvilTerran> ?type showBin
18:18:19 <lambdabot> Not in scope: `showBin'
18:18:22 <oerjan> EvilTerran: regular
18:18:23 <EvilTerran> ?type showIntAtBase
18:18:24 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
18:18:43 <lispy> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-posix/Text-Regex-Posix-Wrap.html#1  <-- isn't something missing from this page? like maybe a description of what (=~) and (=~~) are supposed to do?
18:18:44 <lambdabot> http://tinyurl.com/34u9qb
18:18:51 <EvilTerran> ?let showBin = showIntAtBase 2 digitToInt
18:18:52 <lambdabot> Couldn't match expected type `Int' against inferred type `Char'
18:18:58 <EvilTerran> ?let showBin = showIntAtBase 2 intToDigit
18:19:00 <lambdabot> Defined.
18:19:01 <hpaste>  larmeh pasted "Still the same error :-/" at http://hpaste.org/5278
18:19:30 <oerjan> wy: make your state the number read so far mod 3
18:20:08 <wy> EvilTerran: I remember that any 3x is equal to 4y+...?
18:20:23 <EvilTerran> > foldr ($) "" . intersperse (',':) . map showBin $ [0,3..]
18:20:24 <lambdabot>  "0,11,110,1001,1100,1111,10010,10101,11000,11011,11110,100001,100100,100111,...
18:21:02 <EvilTerran> well, there seems to always be an even number of 1s :)
18:21:11 <wy> 10101 is not
18:21:35 <EvilTerran> :(
18:22:31 <oerjan> EvilTerran: you must alternately add and subtract, just like the 11 test in base 10
18:22:49 <EvilTerran> it's too complicated for me, i give up :P
18:23:18 <Saizan> you need only 3 states 0,1,2 and at each digit d, you go to the state 2*s + d `mod` 3
18:23:44 <Choko> hvem er ovsen
18:23:51 <Choko> hesiqrewgweijfianecainfcawe
18:23:52 <Choko> fasfasd
18:23:52 <Choko> f
18:23:52 <Choko> as
18:23:53 <Choko> df
18:23:55 <Choko> sa
18:23:57 <Choko> df
18:24:00 <Choko> as
18:24:02 <Choko> df
18:24:03 <lispy> cat on the keyboard?
18:24:05 <Choko> sadf
18:24:05 --- mode: ChanServ set +o vincenz
18:24:07 --- kick: Choko was kicked by vincenz (vincenz)
18:24:07 <oerjan> > let test s = foldl' (\m d -> (2*m+d) `mod` 3) 0 s == 0 in test "10101"
18:24:07 <lambdabot>   add an instance declaration for (Integral Char)
18:24:08 <lambdabot>     In the expression:
18:24:08 <lambdabot>     ...
18:24:14 <lispy> vincenz: thanks
18:24:20 --- mode: vincenz set -o vininim
18:24:21 <oerjan> > let test s = foldl' (\m d -> (2*m+digitToInt d) `mod` 3) 0 s == 0 in test "10101"
18:24:22 <lambdabot>  True
18:24:23 --- mode: vincenz set -o vincenz
18:24:33 <oerjan> wy: ^^ essentially a DFA
18:24:43 <vincenz> Either a cat on the keyboard, or the worst spammer ever
18:25:03 <lispy> vincenz: i think usually you're just supposed to mute them for a while, but honestly i have no clue how to do that
18:25:17 * vincenz mutes lispy 
18:25:18 <ddarius> I'm pretty sure he's taken part in conversation before
18:25:28 <vincenz> I'm sure he'll come back and rejoin
18:25:36 <scodil> i read somewhere, i forget where, that there was some proposal to extended do-notation with a form like f (<- g) (<- h) where f g and h are all monadic. Am I making this up? Does this have a name, or a trac ticket even?
18:25:43 <vincenz> kicking isn't permanent
18:25:47 <EvilTerran> scodil, "monadic subexpressions"
18:25:49 <vincenz> muting requires undo
18:25:52 <scodil> EvilTerran: thanks
18:25:56 <wy> oerjan: uhh... How do you know this?
18:25:59 <mauke> lispy: +b %hostmask
18:26:29 <Cale> I don't really feel all that comfortable with that monadic subexpressions proposal.
18:26:31 <EvilTerran> they can't talk if they're banned, even if they're still in the channel
18:26:37 <ddarius> I dislike it entirely.
18:26:38 <dolio> scodil: Controversial topic.
18:26:42 <oerjan> lispy: i think banning without kicking = muting
18:26:42 <EvilTerran> i'm not that fond of 'em either
18:26:48 <EvilTerran> scodil, just use Control.Applicative :P
18:27:04 <allbery_b> SPJ proposed them on haskell@, many folks thing they're not well thought out
18:27:04 <scodil> EvilTerran: how's that?
18:27:17 <EvilTerran> f <$> g <*> h
18:27:19 <oerjan> wy: m is the state, it will always be 0,1 or 2, so finite.  the rest is modulo 3 arithmetic
18:27:38 <scodil> ah cool
18:27:47 <wy> oerjan: I mean... How do you know what you just said
18:28:04 <scodil> so for 3 or more arguments is it then f <$> g <*> h <*> i ?
18:28:07 <EvilTerran> A wizard did it!
18:28:16 <EvilTerran> scodil, yeah. the docs explain.
18:28:27 <EvilTerran> scodil, also, there's a related proposal called "idiom brackets"
18:29:12 <oerjan> wy: "10101" in binary = (((1*2+0)*2+1)*2+0)*2+1, ok?
18:29:26 <gwern> @seen dons
18:29:26 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 48m 10s ago.
18:29:28 <EvilTerran> @go haskell idiom brackets paper
18:29:29 <lambdabot> http://strictlypositive.org/Idiom-abort.pdf
18:29:30 <dons> gwern: ?
18:29:44 <oerjan> BTW could someone who understands Text.Regex better than i do look at larmeh's paste at http://hpaste.org/5278?
18:30:11 <EvilTerran> hm. not the paper i was looking for
18:30:12 <gwern> dons: you knew frag's author right? would he be particularly receptive if I asked him to license his thesis under the GPL/similar license? it's good documentation
18:30:16 <lispy> oerjan: I was going to try understanding Text.Regex, but someone forgot to put human meaningful documentation in the haddock stuff :)
18:30:17 <wy> oerjan: yes
18:30:22 <gwern> (or would that be going too far?)
18:30:35 <dons> gwern: i don't  think you'll be able to contact him.
18:30:45 <dons> and we wouldn't be able to get the university to hand over copyright.
18:30:59 <lispy> the uni has copyright on the thesis?
18:31:03 <lispy> sad :(
18:31:09 <gwern> oh. the university owns the copyright?
18:31:20 <dons> well, they usually have some right to it :)
18:31:47 <lispy> Yes, academic publications are a mess that way.  Often journals take away your rights as author when you publish :(
18:31:48 <Cale> Is the actual code considered part of the thesis, or is it separate?
18:32:07 <gwern> well, I didn't see any copyright mentioned in the thesis
18:32:09 <dons> its explicitly licensed separately
18:32:16 <EvilTerran> scodil, ah, here's the paper i was after: http://cs.nott.ac.uk/~ctm/IdiomLite.pdf
18:32:48 <monochrom> Yes, usually journals rip your rights. But also usually, universities don't. My university leaves thesis copyrights to me, I just have to permit the university to keep and make copies.
18:32:57 <gwern> Cale: the bits of code in the thesis probably fall under fair use
18:33:12 <lispy> gwern: so maybe you can write about his thesis and cite it heavily.  Thus creating a new document that can have whatever license?
18:33:22 <gwern> monochrom: you give them a reasonable royalty-free license, yeah. that's how I'd expect things to work
18:33:27 <gwern> lispy: too much work!
18:34:13 <wy> oerjan: I can't see the rest
18:34:13 <oerjan> wy: now the point about modulo arithmetic is that you can calculate what a whole integer expression with + - and *, modulo something, is, by taking modulo inside the expression wherever you want.
18:34:17 <lispy> Actually, I think i'll create a new open source license called, 'whatever'.  That way when someone says, "it has whatever license." it will take on a technical meaning :)
18:34:23 <wy> oerjan: oh..
18:34:24 <cjb> Yeah.  My wife edits Wikipedia science articles, and often finds photos on Flickr that would help the articles, and sends mail to the photographers asking if they can relicense under a Wikipedia friendly license, ...
18:34:43 <cjb> and almost always they'll say "I don't want to do that because I might want to use the photo in a paper later"
18:34:43 <dons> oh, that's cool
18:34:59 <cjb> and it's really crappy.  they expect to have to assign copyright on their work to journal publishers.
18:35:06 <dons> ah
18:35:21 <dmwit> lispy: Have you heard of the DWTFYWT license?
18:35:24 <Cale> Whoa, some people have done a remake of KQ3! Moreover, it mostly works inside of wine :)
18:35:28 <oerjan> so ((((1*2+0)*2+1)*2+0)*2+1)) `mod` 3 = ((((1*2+0)`mod` 3 * 2+1) `mod` 3 * 2+0) `mod` 3 * 2+1) `mod` 3
18:35:44 <ddarius> Cale: Wow, I haven't thought of that in a long long time.
18:35:47 <lispy> dmwit: Do whatever the f*** you want with this license?
18:35:51 <cjb> (even if/when they do, the journals don't usually mind you having offered photos online; all they want is for you to be legally able to assign copyright to them when they ask for it; but it takes a lot of convincing to show people of that.)
18:35:53 <ddarius> I was more a SQ person though.
18:35:56 <dmwit> lispy: yep =)
18:35:57 <oerjan> wy: which becomes that foldl' .
18:36:02 <lispy> Cale: KQ3?
18:36:03 <gwern> cjb: it's really crappy because that's not even a good reason. you can do whatever the hell you want with the image once you put it under a Free license, you still own the copyright. there will just be a few copies floating around with a Free license
18:36:07 <Cale> King's Quest
18:36:16 <Cale> There's also an SQ2 remake.
18:36:23 <cjb> gwern: Right.  Academics, in general, do not understand copyright well enough to understand this yet.
18:36:24 <gwern> granting a Free license =/ giving away the copyright
18:36:37 <araujo> mmm...
18:36:42 <Cale> http://www.infamous-adventures.com/index.php?page=projects
18:36:42 <lambdabot> Title: Infamous Adventures
18:36:44 <cjb> I'm also somewhat annoyed at Flickr and Creative Commons
18:36:53 * araujo wonders if he could use the wiki from haskell.org for one of his project
18:36:58 <cjb> both of them don't offer any reason why it might be a good thing to choose permissive licenses
18:36:59 <wy> oerjan: I see it gradually...
18:37:11 <cjb> for example, Flickr could say "if you want Wikipedia to be able to use your photos, they need to allow commercial use"
18:37:27 <gwern> cjb: nobody really understands licenses :( except hard-core folks like Wikipedians and some programmers
18:37:40 <ddarius> Cale: Sweet!
18:37:41 <cjb> and Creative Commons could say "if you're a scientist, some people would say you have an ethical duty to offer your work under licenses that allow it to be used to educate the public" or something.
18:38:03 <cjb> but no-one's willing to make statements about what's right, instead of what's possible.  It's very frustrating.
18:39:13 <gwern> cjb: I blame CC here. the FSF has always been very clear about avoiding -NC stuff, as has Wikimedia. it's CC that unleash that plague on the web
18:39:25 <lispy> cjb: yeah, OT, but kinda like a doctor won't tell you what you should do, but will prescribe pills.  They're afraid they could get sued if the advice doesn't pan out.  *sigh*  Same reasoning behind that one.
18:39:27 <cjb> gwern: Yeah, I've grown to dislike CC because of this.
18:40:02 <gwern> and we have all sorts of trouble with that - there is *so* much whining where people go 'wah wah wah, I want my -NC licenses and you're being mean and deleting my stuff Wikipedia1 I don't like you anymore'
18:40:41 <lispy> hehe, sometimes I think wikipedia deletes more than it keeps.
18:40:50 <cjb> actually, mako sums it up pretty perfectly:  http://mako.cc/writing/toward_a_standard_of_freedom.html
18:40:50 <lambdabot> Title: Towards a Standard of Freedom: Creative Commons and the Free Software Movement
18:41:04 <ddarius> lispy: That probably what it should be doing, so if so, good.
18:41:39 <gwern> lispy: entirely possible. most images bite the dust, and iirc, about half of new pages have to be eventually deleted
18:41:56 <gwern> although the truth will remain unknown to all but the devs (as they are the only ones who know how big the deleted-revisions SQL tables are)
18:44:35 <oerjan> wy: are you familiar with the test of divisibility by 9 by adding the digits?  it works because of the same principle
18:45:11 <lispy> oerjan: and what about 7?  Why is that one so hard to figure out?
18:45:20 <wy> oerjan: I see it now :)
18:45:35 <wy> lispy: Maybe because 7 has too many cases
18:45:47 <monochrom> 10 mod 7 is nasty
18:46:02 <oerjan> lispy: because 10 does not simplify to something easy modulo 7
18:46:12 <lispy> > 10 `mod` 7
18:46:14 <lambdabot>  3
18:46:16 <lispy> but, it's just 3!
18:46:27 <ddarius> > product [1..3]
18:46:28 <lambdabot>  6
18:46:39 <oerjan> lispy: sure, you can use the 3 instead of 7
18:47:06 <monochrom> > map (\x -> (3 ^ x) `mod` 7 ) [1,2,3,4,5,6]
18:47:07 <lambdabot>  [3,2,6,4,5,1]
18:47:15 <oerjan> 49 = 4*10+9 === 4*3+2 === 12+2 = 14 === 0 (mod 7)
18:47:41 <monochrom> 3 is a primitive root mod 7. That means (after much number theory) no short cut.
18:47:55 <oerjan> lispy: it just doesn't give as much simplification as 10 mod 9 == 1 or 10 mod 11 == -1 mod 11
18:48:00 <dmwit> > map (`mod` 7) [1,10,100,1000,10000]
18:48:01 <lambdabot>  [1,3,2,6,4]
18:48:12 <monochrom> Whereas for example 10 mod 3 = 1, 1 is not a primitive root, far from it, so you gain drastic simplification.
18:48:53 <oerjan> er, *3 instead of 10, above
18:48:55 <lispy> it's been quite a while since i studied any numbertheory and i mostly studied the more general objects (rings, groups, etc)
18:49:19 <oerjan> lispy: well this is a ring
18:50:52 <oerjan> afk
19:07:11 <dons> def unfold[T, R](init: T)(f: T => Option[(R, T)]): List[R] = f(init) match { case None => Nil case Some(r, v) => r :: unfold(v)(f)
19:07:15 <dons> }
19:07:24 <ddarius> dons has moved beyond haskell
19:07:27 <mauke> what is that
19:07:27 <dons> heh
19:07:29 <dons> scala
19:07:41 <dons> needs some syntax advice
19:07:52 <dons> ?src unfoldr
19:07:53 <lambdabot> unfoldr f b  = case f b of
19:07:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
19:07:53 <lambdabot>    Nothing        -> []
19:08:19 <dons> I wonder why they went with None/Some instead of Just/Nothing
19:08:23 <ddarius> That's why we have type inference.
19:08:28 <dons> that too
19:08:39 <ddarius> Scala seems to have or more MLy syntax
19:08:57 <dons> mm. was odersky more of an ML-er?
19:09:11 <ddarius> I don't remember.
19:09:46 <dons> why do people feel satisified with such heavy syntax?
19:09:51 <Saizan> a set of parens for each argument in function application? eek
19:09:55 <dons> or is it an issue with helping adoption?
19:10:06 <dons> :: for cons is interesting.
19:10:11 <dons> and MLish
19:10:21 <mauke> let rec unfoldr f b = match f b with Some (a, b') -> a :: unfoldr f b' | None -> [];;  (* ocaml *)
19:10:27 <dons> ah!
19:10:29 <dons> right you are.
19:10:50 <Philippa> dons: :: for cons is because ML has : for type per type theory though
19:11:06 <dons> yep, as per ML.
19:11:22 <Philippa> and yeah, I think a lot of it's historical accidents and ocaml having more mindshare as "pragmatic"
19:11:30 <Philippa> I was hearing about it being fast when I was a C++ kiddie
19:11:58 <dons> interesting that guys like odersky and don syme would follow the syntax though
19:12:15 <dons> does it mean we'll see more haskell influence in 5-10 years?
19:12:35 <dons> (being 5 years behind ocaml)
19:12:55 <ricky_clarkson> dons: Odersky seems quite happy with Haskell talk and with ML talk.
19:13:03 * ddarius heard about Haskell before O'Caml.  I may have heard about ML passingly but not in any meaningful way before then.
19:13:14 <dons> i think the crushing weight of the haskell community will lead to some interesting effects in the next few years
19:13:15 <ricky_clarkson> I'd say he seems happier with Haskell concepts.
19:13:25 <dons> yeah, he wrote a lot of haskell papers in days of yore
19:13:27 <ddarius> dons: We are seeing rising Haskell influence today.
19:13:31 <ricky_clarkson> dons: Functional programming won't change the world.
19:13:40 <dons> ddarius: right, rather quickly, just from the large community
19:14:08 <dons> it's already changed some parts of it :) so i think that's false.
19:14:17 <ricky_clarkson> dons: Just a crappy joke.
19:14:46 <Valodim_> how can haskell change the realworld if it's pure :P
19:15:01 <ricky_clarkson> I'd like to see what effect Wadler's stuff about Dyn can have.
19:15:08 <ddarius> Haskell: Changing The World Through Purity Since 1989
19:16:00 <gwern> nobody said changing the world would be safe!
19:16:17 <Saizan> so the fallen of berlin's wall was because of haskell?
19:16:27 <jsnx> ricky_clarkson: i think it would be weird if we actually got one big language based on that
19:16:27 <lambdabot> jsnx: You have 1 new message. '/msg lambdabot @messages' to read it.
19:16:38 <gwern> Saizan: someone in the soviets forgot to NOINLINE unsafePerformIO
19:16:41 <ddarius> Saizan: You're darn tootin'
19:16:45 <ddarius> !
19:16:57 <ricky_clarkson> jsnx: Or two languages in one.
19:17:20 <jsnx> even 2 is too few ;)
19:17:23 <ricky_clarkson> I'm imagining something like Haskell where the outer layer is not just IO, but is Smalltalky.
19:17:54 <jsnx> it'd be neat if a type description language came out of his work
19:18:28 <jsnx> one that was both well founded, and could be used as a basis for communication among components in C, Haskell, Python, Erlang...
19:18:59 <ricky_clarkson> Do you think that's possible?
19:19:09 <jsnx> ASN.1 is close
19:19:13 <ricky_clarkson> ..is that just the typed lambda calculus?
19:19:43 <jsnx> ricky_clarkson: it's a long way from there to a concrete syntax, compilers, &c.
19:19:57 <ricky_clarkson> Ok.
19:20:34 <ricky_clarkson> I still have a lot of type knowledge to stuff into my head.
19:23:31 <jdb> foo a b c
19:23:50 <jdb> that is a function named foo that takes "a" "b" and "c" as arguments.
19:24:23 <jdb> but if I want to specify that the function takes a function as argument do I need to say (shit:shits)?
19:24:42 <jsnx> jdb: ummmm
19:24:48 <ricky_clarkson> :t \a b c
19:24:48 <dons> hmm?
19:24:50 <lambdabot> parse error (possibly incorrect indentation)
19:24:51 <jsnx> @localtime jdb
19:24:53 <lambdabot> Local time for jdb is Sunday, January 27, 2008 10:54:41 PM
19:25:05 <ricky_clarkson> :t \a b c -> (a,b,c)
19:25:06 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> (t, t1, t2)
19:25:06 <jdb> @localtime jsnx
19:25:08 <lambdabot> Local time for jsnx is Sun Jan 27 19:25:06 2008
19:25:15 <dons> jdb: no special magic is needed to pass a function as an argument
19:25:16 <dons> ?src map
19:25:16 <lambdabot> map _ []     = []
19:25:17 <lambdabot> map f (x:xs) = f x : map f xs
19:25:18 <dons> for example.
19:25:21 <dons> 'f' is a function
19:25:30 <dons> (x:xs) is a list, that is being deconstructed
19:25:34 <vininim> I love how you can't check if a xmonad configuration is sane because it's undecidable =P
19:25:35 <ricky_clarkson> jdb: (t -> t2) -> b -> c -> d
19:25:39 <jsnx> jdb: thought you might be german, due to your use of that word
19:25:46 <dons> vininim: it is?
19:25:56 <jdb> oh nop
19:25:59 <jdb> I am from Venezuela.
19:25:59 <dons> vininim: ghci ~/.xmonad/xmonad.hs  -- good way to check
19:26:05 <jdb> are you german?
19:26:08 <jsnx> jdb: no
19:26:20 <jsnx> jdb: but in german, it's used a lot more casually
19:26:21 <jdb> of course no
19:26:28 <jdb> mmm okay
19:26:34 <jdb> (x:xs)
19:26:40 <jdb> I just don't get it
19:26:43 <jsnx> jdb: people will say it in class, &c.
19:26:51 <jsnx> jdb: but in english, doesn't work ;)
19:26:54 <Valodim_> "that word"?
19:27:05 <ricky_clarkson> el solo es desde reddit y aqu
19:27:06 <vininim> dons: well, since it's a haskell program it's the halt problem
19:27:10 <jdb> (does it still mean shit as in english poo/excrements)
19:27:16 <jsnx> Valodim_: in french, its merde
19:27:20 <jdb> yeap
19:27:22 <jdb> mierda
19:27:25 <jdb> in spanish
19:27:38 <jsnx> in german, scheisse
19:27:42 <ddarius> vininim: What is "sane"/"insane"?
19:27:47 <jdb> I wanted to emphasize that x:xs or shit:shits it's the same
19:28:01 <jsnx> but in english, it's really comparable to 'crap'
19:28:08 <jdb> mmmm
19:28:13 <jsnx> since the alternative is a really harsh word
19:28:15 <jdb> in spanish is getting there.
19:28:16 <Valodim_> not really
19:28:23 <jsnx> in english, it's hardh
19:28:30 <jsnx> s/hardh/harsh/
19:28:30 <ricky_clarkson> jdb: (shit:shits) is a list, not a function.
19:28:37 <jdb> I am sorry
19:28:41 <jdb> haha
19:28:45 <jdb> I meant it that way
19:28:50 <jdb> I had a mind-lagoond
19:28:54 <vininim> ddarius: given all inputs it will work as expected =P
19:29:04 <jdb> lagoon** ( I mean, I black.out for a sec.)
19:29:11 <jdb> by the way
19:29:15 <jdb> f . g param
19:29:21 <jdb> (f . g) param
19:29:22 <jdb> =
19:29:28 <jdb> f ( g ( param ) )
19:29:30 <ricky_clarkson> jdb: ([ShittyBit] a) => a -> b -> c -> d
19:29:44 <jdb> I just understood it. So I wanted to share.
19:29:54 <jdb> > x:xs
19:29:54 <lambdabot>   Not in scope: `xs'
19:30:02 <jdb> > Int
19:30:03 <lambdabot>   Not in scope: data constructor `Int'
19:30:06 <ricky_clarkson> > 3:[4]
19:30:09 <lambdabot>  [3,4]
19:30:10 <jdb> anyway
19:30:15 <dons> vininim: yeah :) your config files can certainly not terminate
19:30:16 <Valodim_> haha, swear words as generic variable names?
19:30:18 <Valodim_> great
19:30:18 <dons> vininim: we give you that power.
19:30:35 <ricky_clarkson> Valodim_: Try not to evaluate them.
19:30:39 <jdb> Valodim_: Exactly!
19:30:52 <gnuvince_> Can anyone explain to me the idea behind seq?  If the goal is to force eager evaluation, why does it need two parameters if it disregards the first completely?
19:31:27 <jdb> what about foo ([Integer]) instead of  foo (x:xs)
19:31:33 <jdb> if I want to use integers that's fine of course,
19:31:36 <ddarius> gnuvince_: The point is that it forces it even though you don't need it.
19:31:44 <jdb> so that means that x:xs is a generic way to say all data types?
19:32:03 <Valodim_> no, x:xs is a generic way to say "a list with at least one element"
19:32:12 <dons> gnuvince_: its a hint that you can drop into pure code that a particular arg should be strict to its outer constructor
19:32:23 <dons> gnuvince_: you can also drop in `par` :)
19:32:30 <vininim> now someone just need to writes an extension that given a list of windows clients will cycle focus giving less eye movements
19:32:33 <Valodim_> par=seq?
19:32:43 <dons> no no. it just is used in a similar way
19:32:49 <Valodim_> hehe
19:32:50 <dons> its a hint that something should be evaluated in paralle
19:33:03 <gnuvince_> dons: I'm not sure I understand what you're saying.
19:33:30 <gnuvince_> but why the first argument
19:33:30 <dons> i'm not sure what you're confused by :)
19:33:40 <dons> :t seq
19:33:41 <lambdabot> forall a t. a -> t -> t
19:33:56 <gnuvince_> @src seq
19:33:56 <lambdabot> Source not found. You type like i drive.
19:33:59 <dons> so,  x `seq` 1 + x
19:34:42 <gnuvince_> That's like (x `seq` 1) + x, which basically means 1 + x, right?
19:35:24 <ddarius> 1+x is a bad example Don
19:35:33 <dons> it is. i'm tired.
19:36:17 <gnuvince_> I'm not trying to put down Haskell, I'm just confused by the function
19:37:04 <dons> sorry, so why does it take 2 arguments, instead of 1?
19:37:27 <gnuvince_> Yeah, that's pretty much the gist of my question.
19:37:54 <dons> i guess its so you can drop strictness hints into code without changing the code's structure
19:37:58 <ddarius> gnuvince_: As I said in different words, it forces the evaluation of the argument and then throws it away and returns the other argument.
19:38:29 <ddarius> gnuvince_: The point is that it's forcing something that isn't necessary for the evaluation of the returned argument.
19:38:41 <monochrom> You will appreciate it if you need to use it like: let x=y*y in seq x (x*x).
19:38:45 <larmeh_>  is it possible to convert a value of type "Maybe a" to String?
19:38:50 <dons> larmeh_: show.
19:38:56 <dons> > show (Just 7)
19:38:57 <lambdabot>  "Just 7"
19:39:04 <larmeh_> oh, cool
19:39:07 <larmeh_> thanks :)
19:39:21 <Valodim_> :t fromMaybe
19:39:22 <lambdabot> forall a. a -> Maybe a -> a
19:39:29 <davidL> > show Nothing
19:39:29 <lambdabot>  "Nothing"
19:39:32 <dons> gnuvince_: so its a general idiom -- magic stuff that changes the evaluation strategy should not mess with the algorithm. so they should look like const functions
19:39:36 <dons> `par` is similar.
19:39:40 <blbrown> :t type
19:39:40 <lambdabot> parse error on input `type'
19:39:43 <monochrom> With two arguments and "discard one of them" you have the flexibility to at least force a subexpression but pass on its parent.
19:40:01 <monochrom> If you had only one argument, you couldn't do it.
19:40:15 <blbrown> ddarius, is there a function to print the type (outside of the interpreter)
19:40:15 <davidL> :t ($!)
19:40:16 <lambdabot> forall a b. (a -> b) -> a -> b
19:40:21 <blbrown> oh
19:40:43 <dons> inside a program, you can use show.typeOf
19:40:43 <ddarius> seq actually has to be binary (at least)
19:40:55 <dons> > show (typeOf "foo")
19:40:56 <lambdabot>  "[Char]"
19:40:59 <blbrown> cool
19:41:00 <dons> i use that in test scripts
19:41:05 <davidL> :t typeOf
19:41:06 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:41:11 <dons> its good to see what type something's been instantiated at
19:41:28 <dons> e.g. for generic unit tests you run at different types
19:42:04 <dons> speed lim ty g  = do
19:42:04 <dons> --  x <-
19:42:04 <dons>      time $ do
19:42:04 <dons>         putStrLn $ "System.Random: " ++ show lim ++ " " ++ show (show $ typeOf ty)
19:42:12 <ddarius> seq must return -something- relevant to the computation for the whole seq expression to be forced (so it must take one argument for that) and then it must take what is to be forced in addition as another argument.
19:43:17 <gnuvince_> Maybe I'm think about this the wrong way, because I'm playing around with GHCi.  In a Haskell program, if I do let x = longComputation 10, it won't be evaluated right away, right?  So when it gets to the point of evaluation, printing it to the screen for instance, it would take a while.  With seq, I can force its evaluation (and present a "Processing..." bar) so that it'll already be available
19:43:25 <gnuvince_> Does that sound right?
19:43:53 <ddarius> Up until the end.
19:44:17 <pwned> dontbelazy let x= longcomputation 10
19:45:20 <ddarius> gnuvince_: You'd either have to display "Processing..." and then start evaluating x, but that's just what would happen normally, or you have to evaluate x and display "Processing..." and then display the result of x, which seems nonsensical but would require seq.
19:45:36 <ddarius> gnuvince_: It sounds like you want those things to happen in parallel which is what the par combinator is for.
19:46:20 <monochrom> I think the "processing bar" part complicates things for now. (Not forever, of course.)
19:46:35 <ddarius> gnuvince_: Also, to clarify, you can't have it so that it prints out a sequence of .'s as it's evaluating (at least not via seq)
19:46:59 <gnuvince_> ok
19:48:09 <ddarius> gnuvince_: A common and representative example of when you'd use seq is for accumulating parameters.  Consider calculating the length of a list: length xs = len xs 0 where len [] acc = acc; len (_:xs) acc = len xs (acc+1)
19:48:15 <monochrom> If you haven't known all ramifications of these evaluation orders, and I seriously mean all, you won't know the right way to put up a "processing" bar.
19:49:20 <gnuvince_> ddarius: with you on the len example...
19:49:49 <ddarius> gnuvince_: If you follow lazy evaluation, this is how length [1,2,3] proceeds: length [1,2,3] -> len [1,2,3] 0 -> len [2,3] (0+1) -> len [3] (0+1+1) -> len [] (0+1+1+1) -> 0+1+1+1 -> 3
19:50:24 <ddarius> We do not need to actually evaluate the acc parameter until the end of the computation, so we build up a large expression (0+1+1+1+...)
19:51:10 <ddarius> gnuvince_: Using seq we can tell it to calculate the acc parameter earlier even though it's not (yet) necessary for the calculation so that we don't build up that large expression, namely
19:52:01 <ddarius> length xs = len xs 0 where len [] acc = acc; len (_:xs) acc = let acc' = acc + 1 in seq acc' (len xs acc')
19:53:29 <ddarius> The evaluation of length [1,2,3] now is: length [1,2,3] -> len [1,2,3] 0 -> let acc' = 0 + 1 in seq acc' (len [2,3] acc') -> len [2,3] 1 -> ... -> len [3] 2 -> ... -> len [] 3 -> 3
19:53:40 <gnuvince_> Gotcha
19:55:11 <geezusfreeek> to actually display an animated progress bar would require a separate forkIOed thread from the computation, wouldn't it?
19:55:35 <geezusfreeek> unless you littered the computation itself with IO
19:56:10 <geezusfreeek> even then the animation wouldn't be able to actually show the true progress of the computation i guess
19:56:33 <bos> darcs2 has a new progress bar thingy. you can see how they implement it yourself.
19:58:13 <ddarius> geezusfreeek: Indeed.
19:58:30 <ddarius> :t Debug.Trace.trace
19:58:32 <lambdabot> forall a. String -> a -> a
19:59:05 <gwern> ''We have used this environment to construct high-level system soft-ware and applications on the new kernel, prior to a real bare-metal implementation existing. We also have a bare-metal implementa-tion in C underway, based on the mature Haskell prototype. A high- performance C implementation, suitable for formal verication, is one of the core deliverables of the project.' <-- glad to see seL4 is still underway
19:59:34 <monochrom> Progress bar is an advanced topic. Projected to be covered in a future book "Beyond Real World Haskell".
20:00:00 <bos> unsafePerformHaskell
20:00:35 <monochrom> But rumours go that it is so advanced, it may need to be postponed until even after that, and into the future future book "Space Age Haskell".
20:01:14 <glguy> ?seen dons
20:01:14 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 19m 10s ago.
20:02:16 <hpaste>  larmeh pasted "Any ideas why this happens?" at http://hpaste.org/5279
20:04:16 <monochrom> w00t, Space Age Haskell is a cool name. I should use it.
20:04:45 <gwern> monochrom: no, it'll definitely be in 'Beyond Real World Haskell Prime, with extended coverage of implementing a Duke Nuk'em Forever clone'
20:04:47 <Cale> larmeh: It's saying that there's not necessarily a way to show values of type a
20:04:55 <allbery_b> larmeh:  the type for the translate function must explicitly include a Show constraint
20:05:06 <allbery_b> otherwise you're not allowed to use show
20:05:44 <Cale> larmeh: So in order to apply show, translate needs to know that it can rely on a way to show values of type a. Just add "(Show a) =>" to the start of its type signature.
20:05:53 <monochrom> I have always dreamed of writing a Haskell book/website/whatever dedicated to understanding, reasoning about, and designing memory and time usage (at least up to O()) in Haskell programming. "Space Age Haskell" is a cool name for that, since it contains "space" and "age". :)
20:05:58 <larmeh> allbery_b: hm not at all? but i use it in line 19 and it doesnt result in an error
20:06:31 <gwern> monochrom: what kind of complexity is O()?
20:06:33 <monochrom> gwern: I now also contribute this name: "Haskell: At World's End". Or even: "Haskell: At Real World's End". :)
20:06:57 <Cale> larmeh: possibly that got treated as the same error.
20:07:08 <monochrom> Perhaps I mean \f -> O(f).
20:07:23 <allbery_b> or ghc choe to check it in an odd order
20:07:26 <allbery_b> chose
20:07:28 <monochrom> I thought if I wrote "up to O" it would be misread.
20:07:31 <allbery_b> I've seen that once or twice
20:07:33 <gwern> monochrom: the third of a trilogy?
20:07:52 <dons> glguy: ?
20:08:05 <gwern> @tell dons There, I'm sending the last of my 82 patches for frag. sdist now works well
20:08:05 <lambdabot> Consider it noted.
20:08:15 <dons> scary
20:08:16 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:08:23 * gwern sees dons is already here. hm.
20:08:36 <FunctorSalad> how can I remove an event handler in gtk2hs?
20:08:47 <dons> set it to return () ?
20:09:14 <FunctorSalad> dons: tried it, but it doesn't seem to do anything, maybe it adds a new additional handler
20:11:18 <allbery_b> FunctorSalad: System.Glib.Signals.signalDisconnect
20:11:35 <allbery_b> pass it the ConnectId returned from the event registering function
20:12:09 <FunctorSalad> thanks
20:12:32 <hpaste>  larmeh pasted "Again, any ideas?" at http://hpaste.org/5280
20:12:49 <allbery_b> (hint for finding this stuff:  click on the return type :)
20:13:39 <dons> could someone please write a paper about arrows, FRP and squiggol with the title "Time flies like an arrow, fruit flies like a banana"
20:14:15 <OceanSpray> what
20:14:28 <dons> arrows, fruit and bananas
20:15:25 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colock-0.2.2 interesting
20:15:29 <larmeh> why is the type variable `a' ambigious?
20:15:31 <lambdabot> http://tinyurl.com/3ysgu5
20:15:56 <allbery_b> larmeh:  I suspect because (show Nothing) is ambiguously typed
20:15:56 <ddarius> How to simplify you AFRP GUIs using catamorphisms.
20:16:09 <allbery_b> (that being line 19 char 31)
20:16:30 <dons> ddarius: right  :)
20:17:30 <larmeh> allbery_b: ambigiously typed? its of type "Maybe a"
20:17:41 <larmeh> i guess...
20:17:51 <hpaste>  allbery_b annotated "Again, any ideas?" with "try this" at http://hpaste.org/5280#a1
20:17:53 <monochrom> @quote fruit
20:17:54 <lambdabot> monochrom says:  Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
20:18:27 <allbery_b> larmeh:  but "Nothing" provides insufficient information for it to determine that, nor does the type of show let it determine that
20:18:37 <gwern> dons: sorry, please disregard my email. for some reason darcs is being weird on me and only offering to send some patches
20:18:41 <allbery_b> (show being Show a => a -> String)
20:19:05 <larmeh> so how do i provide this information?
20:19:44 <allbery_b> see my annotation
20:19:58 <allbery_b> [23:17] <hpaste>  allbery_b annotated "Again, any ideas?" with "try this" at http://hpaste.org/5280#a1
20:20:47 <larmeh> allbery_b: oops, sorry didnt see it... thank you so much
20:21:32 <larmeh> allbery_b: but that won't solve the problem
20:21:44 <larmeh> ghci still says the same thing
20:22:42 <larmeh> perhaps because translateFurther and translate both have "(Show a) =>" in it?
20:22:44 <allbery_b> hm, come ot think of it, I think that may need scoped type vars for the "a" to work.  not sure
20:22:57 <oerjan> allbery_b: my thought too
20:23:08 <allbery_b> you might be better letting translateFurther be auto-typed
20:23:25 <larmeh> i.e. skip the signature?
20:23:33 <allbery_b> try it, yes
20:23:42 <allbery_b> not sure it will help
20:23:50 <larmeh> no it didn't
20:23:52 <larmeh> :-/
20:24:28 <oerjan> larmeh: (show (Nothing :: Maybe a)) == "Nothing", you can use that instead
20:24:30 <allbery_b> Nothing `asTypeOf` (find h b) maybe
20:24:49 <allbery_b> but it's probably easiest to just use the literal "Nothing", yeh
20:25:57 <oerjan> allbery_b: actually do you want that to be triggered when find h b _is_ Nothing?
20:26:26 * gwern wonders if gmail will send a 14mb file
20:26:28 <oerjan> hm wait
20:26:37 <allbery_b> afaik asTypeOf is a type hack
20:26:42 <allbery_b> no runtime effect
20:26:46 <oerjan> the shows cannot be equal unless the contents are identical
20:27:01 <oerjan> ah
20:27:26 <allbery_b> :t asTypeOf
20:27:28 <lambdabot> forall a. a -> a -> a
20:27:53 <allbery_b> @src asTypeOf
20:27:53 <lambdabot> asTypeOf = const
20:28:18 <allbery_b> so the value of the second argument isn't used; only its type
20:28:29 <hpaste>  oerjan annotated "Again, any ideas?" with "thus" at http://hpaste.org/5280#a2
20:29:11 <oerjan> larmeh: ^^
20:29:32 <oerjan> there is no point in applying show before comparing, so just use pattern matching
20:30:15 <oerjan> since show (find h b) will only be "Nothing" if find h b is Nothing
20:32:00 <oerjan> you might also want Just f -> instead of f   ->, assuming the actual prefix "Just" is unneeded
20:34:09 <larmeh> oerjan: thank you but i solved the problem a few seconds before i read your annotation :)
20:34:18 <oerjan> oh
20:34:39 <larmeh> i just changed Nothing to "Nothing"
20:34:52 <larmeh> so "Nothing" is interpreted as String
20:34:56 <oerjan> btw the type of recursion in translateFurther is available as concatMap
20:35:14 <gwern> @tell dons OK, I'm serious that this last email for Frag should be about it! I look forward to a new release...
20:35:14 <lambdabot> Consider it noted.
20:35:15 <allbery_b> larmeh: avoiding show entirely for that comparison is faster
20:36:54 <dons> gwern: 17M patch??
20:36:54 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:37:27 <gwern> dons: well, it is 82 patches, and they *do* do a lot with binary files...
20:37:32 <larmeh> allbery_b: you mean using "Nothing" is faster than using show Nothing? hm, nice
20:37:59 <allbery_b> likely, but pattern matching like oerjan's annotation is faster still
20:38:03 <gwern> dons: remember! it's not the size that counts, but how you use it!
20:38:05 <dons> ok. gwern, so can you summarise?
20:38:08 <allbery_b> because you don't show either
20:38:22 <dons> gwern: does it work? what did you do in those 82 patches?
20:38:26 <dons> or perhaps you can summarise via email
20:38:42 <allbery_b> (and unless you use a let it doesn't combine the two instances of show (find ...)
20:39:38 <gwern> dons: the first batch -Walls basically every .hs; the second batch rips out the old non-free level; the third batch installs a new GPL'd level; then a bunch of msic patches to fix missing data files; the final bunch is moving src files around for a clean top dir, enumerating stuff in the cabal for a working sdist. and interspersed are various LANGUAGE and other cleanups
20:40:23 <gwern> I also changed all the Integer to Ints and did some formatting stuff like turning 'do return's into returns
20:40:49 <Cale> Where are you turning Integers into Ints?
20:41:01 <dons> why change Integer to Int?
20:41:06 <dons> presumably Mun did that for a reason?
20:41:11 <gwern> Cale: places where it defaulted to Integer
20:41:25 <dons> hmm. it could break code. did you audit that?
20:41:29 <dons> and you've confirmed the game is working?
20:41:54 <dons> and do you point to the old level?
20:41:57 <dons> or at least where to find it?
20:42:12 <gwern> the game works and installs for me. about the only problem I've noticed is that I can't seem to figure out how to edit the configuration files to place the AI bots in accessible places
20:42:26 <gwern> (I'm on a x86_64 arch computer if you're interested)
20:42:43 <dons> ok. that's good to know.
20:43:00 <gwern> I put in the right coordinates for the bots, but they wind up not showing, or somehow getting *inside* the walls... I'm a little perplexed
20:43:30 * oerjan imagines hands sticking out of the walls...
20:43:45 <gwern> oerjan: no, it shoots at you through the wall... even worse
20:44:21 <gwern> dons: I know the bots are still there, outside the level, because on some of the quake levels I tested, you could fall off the level and onto the ground where all 15 bots would be wandering around
20:44:25 <gwern> kind of amusing actually
20:45:32 <ods94043> greetings! I'm looking for some help getting c2hs properly hooked into my new package's build system... anybody played with c2hs recently?
20:46:44 <Cale> I'm sure someone here must have some experience with doing that :)
20:46:51 <dons> ods94043: your package's build system?
20:46:54 <dons> you're not using cabal?
20:46:55 <ods94043> cabal
20:47:05 <dons> cabal should just pick up anh .chs files, iirc
20:47:06 <ods94043> nothing too weird I hope
20:47:16 <dons> ods94043: but check with dcoutts__ , he's both cabal and c2hs expert
20:47:17 <ddarius> dons: cabal -is- his package's new build system !
20:47:42 <ods94043> I assume I need to mention the chs file in my cabal file somewhere?
20:49:40 <dons> i think you just need to list the modules in exposd-modules:
20:49:48 <dons> as for .hsc files, http://code.haskell.org/~dons/code/mersenne-random-pure64/mersenne-random-pure64.cabal
20:49:49 <lambdabot> http://tinyurl.com/39342u
20:50:55 <larmeh> is there a way to strip a string generated by "show" of its quotes?
20:51:02 <ods94043> ah! thanks for that link, that should get me a ways further :-)
20:51:42 <oerjan> larmeh: the quotes are not really in the String, they are only added when you apply show to _that_ again
20:52:21 <oerjan> which happens when you print a list of Strings, say
20:52:57 <ddarius> > fix show
20:52:58 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:53:05 <sarehu_> > tail . init . show $ "Hey all\nbah!"
20:53:06 <lambdabot>  "Hey all\\nbah!"
20:53:07 <larmeh> so in your annotation, the quotes shouldn't be there?
20:53:29 <ddarius> fix show is so cute
20:53:38 <dons> ods94043: always good to hunt around on hackage for examples
20:53:48 <oerjan> larmeh: er, my annotation has no quotes in it
20:54:44 <oerjan> larmeh: now if you want to display a String without quotes, use putStr or putStrLn
20:54:44 <gwern> wait, how can 'fix show' be valid? what is it showing?</confuzzled>
20:55:02 <ddarius> :t show
20:55:02 <oerjan> :t show
20:55:03 <lambdabot> forall a. (Show a) => a -> String
20:55:03 <lambdabot> forall a. (Show a) => a -> String
20:55:07 <ddarius> :t fix
20:55:08 <lambdabot> forall a. (a -> a) -> a
20:55:10 <ddarius> :t fix show
20:55:11 <lambdabot> String
20:55:14 <oerjan> gwern: it makes a = String
20:55:21 <jcreigh> gwern: show (show (show (show (show (show (show undefined))))))
20:55:28 <ods94043> dons: agreed, but hoped y'all might be able to point me at one that wasn't too messy :-) Thanks again!
20:55:30 <ddarius> gwern: How do you show a string?
20:55:52 <jcreigh> (except not with a limited "depth")
20:56:05 <oerjan> now the cute thing about show (s :: String) is that the first '"' doesn't require looking at s
20:56:11 <gwern> ddarius: through IO? or would that be id...
20:56:41 <oerjan> and that means show is lazy on Strings, which is enough to get fix going
20:56:47 <ddarius> gwern: I meant how does the show function convert a String to a String representing it.
20:56:53 <dons> ods94043: have you got what you need to make progress?
20:57:10 <gwern> ddarius: I don't know
20:57:22 <sarehu_> gwern: it's "showing" itself.  An action which sounds plausibly erotic, but it's not.
20:57:26 <ddarius> gwern: If I asked you to write an instance of Show for string what would you write?
20:58:01 <oerjan> @src Char showList
20:58:02 <lambdabot> Source not found. That's something I cannot allow to happen.
20:58:18 <oerjan> hmph
20:58:57 <gwern> ddarius: I think I would use id, because show is a -> string, and string -> string is satisfied by id
20:59:15 <ddarius> > "foo'
20:59:15 <lambdabot>  Improperly terminated string at ""foo'" (column 1)
20:59:17 <ddarius> > "foo"
20:59:18 <lambdabot>  "foo"
20:59:20 <ddarius> > show "foo"
20:59:21 <lambdabot>  "\"foo\""
20:59:23 <jcreigh> gwern: well, you want (read . show) to be id
20:59:32 <ddarius> > read (show "foo") :: String
20:59:33 <lambdabot>  "foo"
21:00:57 <gwern> jcreigh: I'm not sure about that. in the outside environment read is reading, foo is a string as surely as "foo", but foo isn't "foo"
21:01:52 <oerjan> gwern: think about the purpose of show.  it usually gives something resembling haskell syntax for the original value
21:02:19 <larmeh> is there some sort of regex "replace" in haskell?
21:03:58 <oerjan> larmeh: subRegex
21:05:09 * oerjan finds '"\\\\" will insert a literal backslash' somewhat disturbing
21:06:31 <larmeh> oerjan: mh, but your annotation still has quotes in the resulting string
21:06:51 <oerjan> larmeh: oh wait
21:07:30 <oerjan> i think i realize what's happening
21:07:59 <hpaste>  oerjan annotated "Again, any ideas?" with "fixed?" at http://hpaste.org/5280#a3
21:08:13 <oerjan> the problem was the show f
21:08:56 <oerjan> because f probably contains a String within the Just, and show puts quotes around it (and also includes Just which you probably don't want)
21:09:27 <oerjan> so instead pattern match to get the actual String as f, and don't apply show to it
21:09:51 <oerjan> hm or wait
21:10:02 <larmeh> hm no this results in a type error
21:10:19 <oerjan> yes. will it be good enough to use Dictionary String ?
21:10:33 <larmeh> now it complains that "a" (which is probably f++...etc) a rigid variable
21:10:48 <oerjan> two places
21:10:53 <larmeh> yep
21:10:57 <larmeh> line 16 an 19
21:11:01 <larmeh> erm 21, sorry
21:11:03 <oerjan> ah, and then you don't need (Show a) =>
21:12:49 <hpaste>  oerjan annotated "Again, any ideas?" with "for just Strings" at http://hpaste.org/5280#a4
21:14:40 <larmeh> oerjan: hm no this still results in the same type error
21:19:03 <oerjan> huh.
21:19:58 <oerjan> can you annotate with the error?
21:20:13 <larmeh> sure, hold on
21:21:11 <hpaste>  (anonymous) annotated "Again, any ideas?" with "(no title)" at http://hpaste.org/5280#a5
21:24:06 <oerjan> um, are you sure you changed the file and reloaded?  there is no a in the new type signature of translateFurther
21:25:42 <larmeh> oerjan: yes i did
21:26:49 <larmeh> oerjan: oops i misread your last sentence, damnit
21:26:56 <larmeh> :)
21:27:01 <larmeh> lets see...
21:30:44 <larmeh> oerjan: it works!! great! thanks so much for your advice
21:31:07 <bos> is there a good way to rename a package on hackage?
21:31:11 <bos> or any way at all?
21:31:18 <oerjan> yay
21:38:15 <bos> wow, i have almost 300 files open in my month-old emacs session. that must be a personal record!
21:42:57 <yuri_> Hi. I am new to haskell and I am trying to figure how to productively use VIM to edit, compile, interactively interact with .hs files
21:43:29 <bos> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
21:43:30 <lambdabot> Title: Haskell mode for Vim
21:43:36 <yuri_> I am looking for answers to simple questions like: how do I indent a haskell file
21:44:04 * ddarius personally just uses the syntax highlighting files that came with vim and autoindent, but then he's a bit of a Luddite.
21:45:00 <shachaf> ddarius: That is also what I do (at least for now).
21:45:08 * oerjan joins the luddites
21:46:32 <yuri_> lambdabot: gr8 setting the vimball and will see how it goes. Thanks
21:57:21 <yuri_> Downloaded, copied .vba to .vim folder, added "au Bufenter *.hs compiler ghc" to my .vimrc but now I am getting "E666: Compiler not supported: ghc" even though I have ghc-6.8 installed
21:57:58 <shachaf> yuri_: You want to do more than copying .vbas to ~/.vim, I think.
21:58:20 <shachaf> yuri_: If you edit it, it should probably have instructions (?).
22:00:46 <yuri_> shachaf: do you mean I should edit the .vba file? Did it but no instructions
22:01:43 <shachaf> yuri_: Try ":so %"?
22:01:45 <yuri_> oh, I had to :so ...
22:01:56 <yuri_> :-
22:01:58 <yuri_> :-)
22:13:45 <yuri_> shachaf: very nice. For some reason :so % added some escape chars after the .vim file names and vim wasnt able to find them. Thanks for your help: will read the docs to figure out what is at hand now.
22:21:08 <ddarius> http://www.math.rutgers.edu/~zeilberg/Opinion79.html
22:21:09 <lambdabot> Title: Doron Zeilberger's 79th Opinion
22:21:16 <Cale> haha
22:21:20 <Cale> Doron is nuts :)
22:24:15 <allbery_b> also stupid since "echad" isn't a "kh" :)
22:24:47 <Cale> Shalosh B. Ekhad is the name of his computer.
22:25:07 <allbery_b> yes.  it's also Hebrew transliterated
22:25:30 <Cale> ah, so he transliterated incorrectly?
22:25:31 <allbery_b> 3 b. (ben?) 1
22:26:31 <allbery_b> there isn't anything using alef-chaf-dalet, only alef-chet-dalet.  (ehad or echad depending on the translit rules you use.  *no* rule gives you "ekhad")
22:29:46 <hpaste>  conal pasted "useful function on Maybe -- comments?" at http://hpaste.org/5281
22:30:13 <shachaf> allbery_b: I use a "ch" in my name.
22:30:27 <allbery_b> noticed. :)
22:30:44 <dons> conal: seems a bit specialised :)
22:30:53 <shachaf> allbery_b: Is that not a "standard" transliteration?
22:30:54 <allbery_b> ch can be used for chaf or chet, kh is never used for chet
22:31:13 <conal> dons: it's a general for efficient updating of a structure when parts may or may not have changed.
22:31:24 <conal> general *technique*
22:31:43 <conal> and i'm struck with its relationship to liftA2
22:31:50 <dons> yeah, that's interesting.
22:31:57 <sjanssen> conal: we do this sort of thing in xmonad in several places
22:32:01 <conal> oh?
22:32:19 <conal> i think i saw the trick in an article on implementation of term rewriting
22:32:40 <ketil> @acronym FTW
22:32:40 <lambdabot> Unknown command, try @list
22:32:42 <sjanssen> conal: yeah, layout algorithms return a 'Maybe s' when handling messages -- to indicate that their state has changed
22:32:44 <conal> i'm using it for residual behaviors after a reaction.  sometimes the behavior can be simplified, and sometimes not.
22:33:03 <conal> sjanssen: and pairs of them combine as in rebuild2?
22:33:04 <ketil> @feature-request acronym - expand acronyms used by dons on the list
22:33:04 <lambdabot> Unknown command, try @list
22:33:20 <ketil> @feature-request feature-request
22:33:20 <lambdabot> Unknown command, try @list
22:33:24 <sjanssen> conal: we never bothered to factor it into a nice combinator -- though the code would probably be improved by it
22:33:40 <conal> i bet the pattern occurs in many places.
22:33:40 <allbery_b> @urban ftw
22:33:40 <lambdabot> Unknown command, try @list
22:33:43 <allbery_b> hm
22:33:47 <shachaf> ketil: That would be @todo-add. :-)
22:33:54 <allbery_b> "for the win"
22:34:09 <conal> also, given the relationship to liftA2, i wonder if the pattern generalizes beyond Maybe to other applicatives
22:34:25 <ketil> shachaf, well, if it's already there, there's no need to todo-add it...?
22:34:30 <ketil> :-)
22:34:33 <ddarius> @vera ftw
22:34:33 <lambdabot> No match for "ftw".
22:34:39 <ketil> What does FTW mean, though?
22:34:47 <allbery_b> <allbery_b> "for the win"
22:34:47 <conal> @help vera
22:34:47 <lambdabot> I perform dictionary lookups via the following 13 commands:
22:34:47 <lambdabot> all-dicts ... Query all databases on dict.org
22:34:50 <lambdabot> devils ...... The Devil's Dictionary
22:34:54 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
22:34:58 <lambdabot> elements .... Elements database
22:35:02 <lambdabot> [9 @more lines]
22:35:03 <ketil> @easton ftw
22:35:06 <lambdabot> No match for "ftw".
22:35:22 <conal> what's the origin of "for the win"?
22:35:32 <conal> is it sports bravado?
22:35:49 <allbery_b> oldest reference anyone's found is use on "Hollywood Squares, believe it or not
22:35:50 <ketil> allbery_b, sorry, I missed it the first time around.
22:36:09 <conal> allbery_b: oh!  sure enough.
22:36:27 <ddarius> Sleep
22:37:43 * allbery_b should do that, sometime
22:38:23 <ketil> sjanssen, I have some list processing code that I suspect would be faster as array-processing code, and somebody pointed me at storablevector.  The docs seem to be a bit sparse, does it do what I think it does?
22:38:47 <ketil> "sparse" in this context meaning I can't really find any... :-)
22:38:50 <conal> so, i wonder: pure and <*> suffice to define liftA, liftA2, liftA3, ....  is there a similar simple (finite) basis for rebuild2, rebuild3, ...?
22:38:52 <ods94043> w00t: got c2hs working :-)
22:39:20 <sandbox> has anyone here worked with hdbus at all?
22:40:35 <dons> ods94043: yay
22:40:49 <sjanssen> ketil: it's ByteString but generalized to all Storable types
22:42:17 <hpaste>  conal annotated "useful function on Maybe -- comments?" with "rebuildAp" at http://hpaste.org/5281#a1
22:42:19 <allbery_b> sandbox: try asking on haskell-cafe@haskell.org
22:42:19 <larmeh> when getting an input file via a do-notated "inputfile <- readFile path" how can i convert inputfile to a regular string?
22:42:24 <sandbox> thanks
22:42:39 <Cale> larmeh: It is a regular string.
22:42:50 <allbery_b> larmeh: you don't.  you apply pure functions to it within the do expression
22:43:07 <Cale> readFile filename :: IO String
22:43:14 <Cale> so  inputfile :: String
22:43:28 <larmeh> oh, i see
22:44:01 <dons> ketil: should be the same api as bytestring, fwiw.
22:44:06 <Cale> If you immediately write:
22:44:10 <Cale> return inputfile
22:44:23 <Cale> then your do-block as a whole has type IO String again
22:44:59 <dons> mm. lego google logo today
22:45:01 <Cale> (and hence has to be run inside another do-block using <- in order to access that string)
22:45:22 <Cale> 50th anniversary of the Lego brick.
22:45:39 <dons> ah ha
22:46:14 <Cale> Incidentally, "logo" was one of my first words.
22:46:22 <sjanssen> ketil: btw, the code is annotated with haddock comments, so you can generate docs yourself
22:46:33 <Cale> I would point at logos and identify them as such. :)
22:47:17 <dons> weird
22:47:30 <shachaf> Cale: Do you remember that personally?
22:48:17 <Cale> shachaf: Not really very well.
22:49:37 <bos> do we have a floating point remainder function?
22:50:12 <larmeh> hm if i have "input <- readFile (show (head args))" can i pass "input" to a function that expects a String as argument?
22:50:14 <bos> something like fmodf in C?
22:50:28 <Cale> larmeh: yep
22:51:06 <shachaf> larmeh: Just remember that the entire do-block has to have an IO type.
22:51:14 <quicksilver> larmeh: that 'show' looks suspicious to me.
22:51:25 <dons> bos, rem and mod should work on Real a's?
22:51:39 <quicksilver> larmeh: if args is a list of strings, then head will be the first string. 'show' will wrap an extra set of "" around it, whic doesn't sound likely to be what you want.
22:51:49 <dons> > 1 `rem` 2.0 :: Double
22:51:50 <lambdabot>   add an instance declaration for (Integral Double)
22:51:50 <lambdabot>     In the expression: 1 ...
22:51:54 <dons> oh, mm
22:52:07 <quicksilver> dons: Data.Fixed defines versions that do.
22:52:11 <quicksilver> dons: called mod', IIRC.
22:52:14 <dons> oh, good point. yes.
22:52:35 <bos> wow, wouldn't have thought to look there.
22:53:17 <bos> oh boy.
22:53:32 <hexpuem> how would i catch list exceptions with something like: getArgs >>= (return . read . head)
22:53:44 <shachaf> hexpuem: You wouldn't, probably.
22:53:57 <shachaf> hexpuem: You'd use something like Maybe instead.
22:53:58 <conal> hexpuem: use fmap/<$> instead
22:54:16 <hexpuem> alright thanks
22:54:36 <bos> the div' in Data.Fixed converts to Rationals. i'd be better off sawing off my leg!
22:54:48 * bos boggles
22:54:54 <conal> (m >>= return . f)  === fmap f m  === f <$> m
22:55:01 <bos> time for an FFI call, alas.
22:55:02 <shachaf> conal: How does that fix hexpuem's problem?
22:55:03 <conal> and is slightly more general
22:55:43 <conal> shachaf: doesn't.  i didn't read the whole question.
22:56:12 * shachaf approves of fmap/(<$>) nevertheless. :-)
22:57:26 <shachaf> There's also readIO, by the way (any particular reason that exists?).
22:57:44 <sjanssen> shachaf: it throws an exception rather than returns bottom
22:57:53 <quicksilver> hexpuem: if you hope to catch 'read' exceptions, it's often best to use reads, or define something which uses reads.
22:58:00 <quicksilver> :t reads
22:58:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:58:14 <sjanssen> bottom and IO exceptions are not unified in Haskell '98, as they are in GHC
22:58:24 <shachaf> sjanssen: Oh.
22:58:43 <larmeh> hm, "input <- readFile (head args) :: String" results in a type error...
22:58:46 <shachaf> hexpuem did talk about list exceptions, though. :-)
22:58:54 <shachaf> larmeh: No need for the :: String.
22:59:08 <quicksilver> :t \x -> case reads x of [(v,"")] -> Just v ; _ -> Nothing
22:59:09 <lambdabot> forall a. (Read a) => String -> Maybe a
22:59:09 <shachaf> larmeh: "readFile (head args)" isn't :: String, it's :: IO String.
22:59:24 <quicksilver> ^^ I find that a more useful type, quite often.
22:59:45 <shachaf> @ty \x -> case reads x of [(v,"")] -> return v; _ -> mzero
22:59:46 <lambdabot> forall a (m :: * -> *). (Read a, MonadPlus m) => String -> m a
23:00:06 <larmeh> shachaf: thats what ghci says too, but i can't apply a function that expects a string as argument to it... in the same do-block
23:00:25 <shachaf> larmeh: Apply the function to input, not to readFile (head args).
23:01:28 <larmeh> shachaf: that doesn't work... it still results in a type error
23:01:45 <shachaf> larmeh: You're probably looking at the wrong spot.
23:01:47 <shachaf> @paste?
23:01:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:03:43 <ketil> sjanssen, dons: sorry for going away.  Seems like SV is just what I need.  Any perf numbers vs list processing?
23:03:52 <hpaste>  larmeh pasted "hrm..." at http://hpaste.org/5282
23:04:26 <Cale> larmeh: the problem is that translate is returning a String
23:04:54 <Cale> larmeh: You have to do something with the String, like print it with putStrLn.
23:05:06 <ketil> *about*.  I'm sorry *about* going away.  And about my linguistic inadequacies, as well.
23:05:17 <larmeh> Cale: oh right... okay hold on
23:05:17 <shachaf> larmeh: Or return it (though that doesn't make much sense in main).
23:05:51 <sjanssen> ketil: well, performance vs. lists is a complicated issue -- the structures are so different
23:06:12 <Cale> ketil: I think 'for' was fine, but perhaps that's only due to my own inadequacies.
23:06:43 <ketil> Cale, oh.  I thought you'd be sorry for someone, but sorry about something.
23:07:16 <ketil> Do allow me to apologize again, this time for gratuitious pedantery.
23:07:19 <ketil> :-)
23:07:24 <sjanssen> ketil: are you familiar with ByteString performance?  storablevector should have analogous performance
23:07:30 <Cale> Hmm, that's a reasonable rule, but it's not quite that straightforward, I suppose.
23:08:17 <ketil> sjanssen, I'm doing mostly sequential processing (heads and tails :-), so - without benchmarking - I'd expect BS-like to do well.
23:08:37 <ketil> (even better if I were doing more random access, of course...)
23:09:09 <Cale> You can feel sorry for doing something. If you said "sorry about James", it would actually be taken as meaning that you were sorry about some circumstance regarding James.
23:09:09 <ketil> but I suppose it may also depend on deforestation/fusion optimizations.
23:09:11 <conal> ketil: sometimes "sorry for" conveys guilt (moral wrongness), while "sorry about" conveys regret.
23:10:07 * ketil flips madly through his copy of "The Elements of Style".
23:10:20 * ketil makes some notes in the margin.
23:10:54 <conal> feeling-wise the "sorry for" might be shame or fear (of reprisal or rejection), while the latter may be regret.
23:13:32 <Cale> But the former could be regret too.
23:14:13 <conal> Cale: yes, "sorry for" could mean regret (feeling), and "sorry about" could mean guilt (thought).
23:14:53 <conal> our language consistently confuses thoughts & feelings
23:16:05 <Cale> This "sorry for"/"sorry about" thing is actually a distinction I don't think I've ever consciously thought about.
23:16:24 <shachaf> Cale: Or is that "thought for"? :-)
23:17:05 <Cale> ...nah :)
23:17:16 <conal> another perspective, maybe clearer, is that apology is an act, while regret is an emotion.
23:18:00 <conal> and apology is sometimes motivated by regret, but i think more often by shame (moralistic thinking) and fear (of banishment from the tribe).
23:18:55 <Cale> I don't really know if there's a difference for me between "I am sorry" and "I feel sorry", if there is, it's pretty subtle.
23:19:16 <elliottt> dons: ping
23:19:42 <conal> Cale: how about "i apologize" and "i regret"?
23:19:46 <masak> seems to me that one can say "I'm sorry" without necessarily feeling sorry. The former is more of a socially expected thing
23:20:06 <conal> masak: exactly: the (speech) act, rather than the feeling.
23:20:12 <masak> yes.
23:20:51 <conal> Cale: the phrase "i am sorry" is especially ambiguous.  could well mean apology or regret.
23:22:26 <Cale> Well, if I'm talking to the person to whom I'm apologising, they seem the same. If I'm talking to someone else, then they're clearly not :)
23:23:10 <Cale> I suppose apology is directed expression of regret.
23:23:49 <conal> Cale: apology is (can be) more than regret.  it's often guilt/wrongness also.
23:23:58 <pwned> I apologize to shut people up.
23:24:00 <conal> as in "i shouldn't have done that"
23:24:15 <conal> pwned: yep.  another common use.  appeasement.  please shut up.
23:24:26 <pwned> I'm sorry.
23:24:41 <visof> what is the difference between .lhs anf .hs files?
23:24:41 <lambdabot> visof: You have 1 new message. '/msg lambdabot @messages' to read it.
23:24:59 <Cale> visof: .lhs is literate Haskell. Everything is a comment by default.
23:25:00 <conal> pwned: i regret and also am amused about my ambiguous "please shut up".
23:25:08 <conal> pwned: but i'm not sorry/guilty
23:25:31 <conal> because -- hell misunderstandings are inevitable and are a normal part of communication.
23:25:32 <kmcallister> visof, there are two styles of literate Haskell; there's the one where all code is prefixed with "> ", and the one where it's enclosed in "\begin{code}...\end{code}"
23:25:43 <kmcallister> in the latter case the surrounding comments are usually in LaTeX
23:25:44 <Cale> Code lines start with > (Bird-style) or lie between \begin{code} and \end{code} (LaTeX style)
23:25:52 <conal> i mean "because -- hell -- misunderstandings ..."
23:26:14 <pwned> I will retort when I learn to express an apology in haskell
23:26:15 <sjanssen> conal: heh
23:26:30 <shachaf> In Hebrew, the same word is used for "I'm sorry" and "Excuse me".
23:27:12 <conal> pwned: without the notion of right/wrong, apology is unnecessary.  and what remains is lovely & useful.
23:27:30 <conal> regret, learning, and affirmation of what one holds dear.
23:27:42 <pwned> I'm skeptical of anything which sounds too good.
23:28:04 <Cale> I heard that in German (at least I think it was German), "open question" is used in a much more casual way.
23:28:31 <Cale> (Whereas in mathematics it tends to mean that nobody knows the answer.)
23:28:56 <sudoubungu> gparted trying to size from 230 gig to 215 and 46 GB used. how long? i waited 35 minutes
23:31:44 <lekro> Cale: yes, in German you can use it like "It's still an open question what we're gonna do tonight". is that what you mean?
23:32:18 <conal> pwned: i encourage your skepticism.  don't take my word for it.  try it on yourself.  experiment with guilt-free regret.
23:32:26 <conal> shachaf: is there a Hebrew word for regret or sad?				      [23:34]
23:32:43 <Cale> lekro: Or whether there's milk in the fridge?
23:32:53 <conal> oh jeepers -- more heavy rain.  i guess we'll have another mudslide come down the hill.
23:33:26 <Cale> lekro: But yeah, that's the sort of thing I mean.
23:35:57 * lispy suspects he is in the same timezone as Conal
23:36:12 <lispy> ?localtime conal
23:36:14 <lambdabot> Local time for conal is Sun Jan 27 23:40:29 2008
23:36:21 <conal> @localtime lispy
23:36:21 <lambdabot> Local time for lispy is Sun Jan 27 23:36:21 2008
23:36:28 <lispy> one of our clocks is off
23:36:55 <conal> sure is.  which one?
23:36:57 <Cale> @localtime Cale
23:36:58 <lambdabot> Local time for Cale is Mon Jan 28 02:36:37
23:37:08 <conal> lispy: you're in oregon, right?
23:37:24 <lispy> conal: correct, BTW, i think it's your clock that is fast
23:37:40 <lispy> well, faster than the time servers i use
23:37:58 <lispy> conal: please send me stock tips from the future, kthx ;)
23:38:06 <conal> lol
23:38:41 <lekro> @localtime lekro
23:38:41 <lambdabot> Local time for lekro is Mon Jan 28 01:38:41
23:38:59 <Cale> It's a little funny how we still use the terms "fast" and "slow" when it seems much more likely these days that the clock was just set incorrectly to begin with.
23:39:21 <lispy> conal: judging by your comment on the rain and timezone, i would guess you're in oregon or washington
23:39:49 <lispy> Cale: well, from what i've read...PC clocks have a nasty tendency to drift
23:40:23 <Cale> Or just completely lose the time altogether. :)
23:40:31 <dmwit> Old ones, especially.  And that doesn't mean they're improving... it just means their batteries die out and people don't know to replace them.
23:40:52 <lispy> Cale: but, I'm no expert, I find clock synch to be a tedious subject :)
23:41:35 <Cale> :)
23:41:45 <lispy> but for some reason, i'm one of those people that gets intruiged by even boring things and will read up on them, often to just forget it later.
23:42:04 <lispy> i still curse the day i learned about wikipedia ;)
23:42:30 <Cale> We should legislate out the measuring of precise times apart for specialised scientific purposes. Clocks would be required to read things like "late afternoon".
23:42:35 <conal> fixed!  i guess time.nist.gov is off.
23:42:39 <conal> cool -- i went back in time.
23:42:41 <conal> lispy: central/northern CA, in the sierra nevada foothills -- the "motherlode"
23:42:59 <lispy> conal: cool
23:43:22 <Cale> Nobody would ever be 5 minutes late again.
23:43:31 <lispy> conal: and thay say you don't get any younger...
23:44:20 <lispy> Cale: I would agree to that if I could get "beer:30" as an official time
23:45:56 <lispy> Cale: but, you bring up a good philosophical point.  Why do we care so much about precise time in our daily lives?  If we didn't care about it, it wouldn't matter.
23:47:34 <Korollary> we don't express how much we don't care, tho.
23:47:49 <Cale> :)
23:48:29 <sudoubungu> how long can you do a boring task that is wasting time etc?
23:48:39 <blbrown> data DocumentInfo = DocumentInfo {
23:48:39 <blbrown>       docName :: String,  if I have this; how would I export that data type when I define my module
23:48:46 <blbrown> eg docName
23:49:03 <kmcallister> module Foo(DocumentInfo(..)) where
23:50:44 <blbrown> kmcallister, module Foo(DocumentInfo(docName, next2, next3), otherFunction) where
23:51:18 <kmcallister> that doesn't work/
23:51:21 <kmcallister> ?
23:52:41 <blbrown> kmcallister, I get this error: attempts to export constructors or class methods that are not visible here
23:53:01 <dmwit> blbrown: module Foo(DocumentInfo(DocumentInfo), docName, next2) where
23:53:06 <sudoubungu> gparted trying to size from 230 gig to 215 and 46 GB used. how long? i waited 37 days
23:53:22 <dmwit> sudoubungu: Ask elsewhere.
23:53:49 <kmcallister> odd, DocumentInfo(DocumentInfo, docName) works for me
23:53:53 <blbrown> dmwit: I did this; module Foo(DocumentInfo, docName) where ... yea
23:54:28 <dmwit> blbrown: If you want to export the constructor (and not just the type), you need to do what I suggested.
23:54:50 <dmwit> data Foo a = Bar a a
23:55:00 <dmwit> module Baz(Foo(Bar)) where ...
23:55:04 <lispy> is sudoubungu actually a person? they said almost that same thing earlier
23:59:05 <zeno> hi! what would you reccomend for creating a GUI in haskell?
23:59:27 <elliottt> gtk2hs is nice, and the only thing I've tried using :)
23:59:50 <conal> zeno: depends on what you want.  elegance, features, user community?  imperative or functional?
