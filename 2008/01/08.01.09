00:11:54 <bparkis> wow
00:12:40 <Korollary> wow
00:12:47 <glguy> ?yow
00:12:48 <lambdabot> Is this an out-take from the "BRADY BUNCH"?
00:12:55 <ADEpt> NO WAI
00:13:54 <u_quark> can anyone tell me what is this---> data AlexPosn = AlexPn !Int !Int !Int ???
00:14:34 <Lemmih> u_quark: Three strict ints.
00:15:57 <C-Keen> <interactive>:1:40: Not in scope: `main' <- this is not very helpful, maybe an indentation error?
00:16:52 <Lemmih> C-Keen: Are you not calling 'main' or do you think 'main' should be in scope?
00:17:16 <C-Keen> Lemmih: it definitely should be in scope as it is there
00:17:56 <psi> i think that has happened to me a few times when i've been running through emacs
00:18:11 <C-Keen> ah a reload solved it
00:18:14 <C-Keen> strange
00:18:56 <psi> then again i'm always running through emacs so...
00:19:10 <u_quark> Lemmih: a tutorial to Strict types?
00:20:02 <litb> return $ map (\x -> let erg = intMitEpsilon sin simpsonQuadratur x 2.0 0 pi  in putStrLn ("Erg: " ++ (show erg) ++ "; Abw.: " ++ (show (2-erg))))
00:20:13 <litb> someList
00:20:19 <litb> why doesn't that output anything ?
00:20:27 <litb> evne though i do putStrLn there?
00:20:28 <Lemmih> u_quark: I don't think it's complex enough to merit a tutorial.
00:21:13 <u_quark> xmmm anyway tnx Lemmih
00:21:40 <Lemmih> litb: That's not enough. You also have to run 'em.
00:21:49 <Lemmih> u_quark: You can safely ignore them.
00:22:30 <litb> Lemmih: doesn't that run it? i thought it runs the putStrLn, and in the returned list, it saves the return of putStrLn then
00:23:09 <litb> basicially, what i want is just iterating through the list and do someaction with each item. maybe i do it all wrong now
00:23:41 <Lemmih> litb: Drop the 'return', use 'mapM_' instead of 'map'.
00:24:05 <Lemmih> litb: Or: forM_ someList $ \x -> let ... in putStrLn ...
00:25:08 <Corun> Good morning. Oh funky functional channel.
00:25:13 <litb> ah, the normal map doesn't allow me to run them, as it would have side effects?
00:25:41 <matthew-_> sheesh, I'm getting old. I can't do the 2am coding sessinos that I once could
00:25:46 <psi> putStrLn itself doesn't have side effects
00:25:58 <psi> you just produced a list of IO actions
00:26:01 <Corun> It's not 2AM, matt :-P
00:26:04 <Korollary> @localtime matthew-_
00:26:04 <lambdabot> Local time for matthew-_ is Wed Jan  9 08:26:06 2008
00:26:09 <matthew-_> mind you, they used to be in Java and you can pretty much write java whilst sleeping
00:26:21 <matthew-_> Korollary: I've just got up again
00:26:31 <Corun> After only 6 hours sleep?
00:26:44 <Lemmih> litb: Mapping over putStrLn creates a list of actions that, when executed, generates output.
00:27:26 <matthew-_> Corun: yeah. things to do. PhD's to avoid...
00:27:31 <Korollary> matthew-_: what are you writing in nowadays?
00:28:11 <litb> Lemmih: oh , i see. putStrLn doesn't output anything itself, but just returns a IO action, which then does the work i suppose
00:28:15 <matthew-_> err, well I've not touched the games for many months now I'm afraid
00:28:29 <Corun> Matt, can't you just make what you want to do in to your PhD somehow?
00:28:30 <matthew-_> I've been donig website stuff for my research group
00:28:33 <u_quark> Lemmih: i ignored them tnx !
00:29:39 <C-Keen> what does this mean? out of stack? *** Exception: Data.ByteString.index: index too large: 188, length = 188
00:29:50 <C-Keen> oh *duh*
00:29:52 <C-Keen> nevermind
00:30:37 <psi> litb: yeah, it's pure :)
00:49:12 <glguy> ?seen dons
00:49:12 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 54m 52s ago.
01:00:42 <jsnx> @src !
01:00:43 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
01:00:59 <litb> hm, maybe i could write a type class to represent one integration method?
01:02:33 <jsnx> i have a weird syntactic requirement -- i'd like a 'reversible map' with a (!) that takes either a key or a value
01:03:04 <jsnx> how do i do that? i don't know much about typeclasses yet.
01:03:23 <matthew-_> (Map k a, Map a k)
01:03:32 <integral> Map (Either key value) (key, value)
01:03:56 <jsnx> i do not understand :(
01:04:00 <matthew-_> now use the type system to enfore that the function represented by the Map is invertible ;)
01:04:25 <jsnx> oh, i sorta see
01:05:42 <Korollary> If keys and values are both integers, how would (!) know whether a given integer is a key or a value?
01:06:12 <jsnx> Korollary: it will diverge in that case
01:06:23 <jsnx> what i really want, is an 'ordered map'
01:06:33 <jsnx> if i look up with a key, i get an integer
01:06:43 <jsnx> if i look up with an integer, i get a key
01:06:52 <jsnx> maybe they should be separate functions
01:07:50 <jsnx> if i want to control how the search for the key is performed -- i.e. with a hash and what not -- do i have to make a new monad?
01:08:00 <Korollary> If this was a database table, your select statements would be different.
01:08:10 <jsnx> Korollary: it is not a database table
01:08:15 <jsnx> it is a column in the table
01:08:49 <jsnx> i use the index to find the stuff in the other columns
01:08:54 <jsnx> to reconstruct the tuple
01:08:58 <jsnx> (this is the idea, anyway)
01:10:03 <jsnx> is that stupid?
01:10:45 <Korollary> Is the key the column name?
01:11:05 <jsnx> Korollary: well...not really
01:11:15 <jsnx> the key should be called the value, really
01:11:38 <jsnx> like if i have a column for, uhm, description
01:12:01 <jsnx> then the column can be queried with a String to see if a particular description is in there
01:12:27 <jsnx> if it is, i get a list of Int
01:12:28 <Korollary> ok
01:12:57 <jsnx> then i take those Ints to index into all the other columns, reconstructing the tuples
01:13:02 <jsnx> then i pass those on
01:14:03 <Korollary> Normally you'd have a map from descriptions to row id's, and once you have the row id, you can retrieve the entire row.
01:15:38 <jsnx> Korollary: well, i don't actually store the row anywhere
01:15:43 <jsnx> i just have these indexes
01:16:03 <jsnx> i'm trying to implement a database (with simple equality lookup)
01:16:10 <jsnx> not make an interface to one
01:16:28 <jsnx> basically, the only thing i want to have copies of are the indices
01:16:53 <jsnx> instead of copying the values at least twice
01:18:43 <C-Keen> hm how do I print the current file postition? I used hGetPosn f >>= \pos -> putStr pos, and this prints {handle: filename}, not quite what I expected
01:19:44 <jsnx> (one copy for each Map key Int, and then again for [(keyA, keyB...)]
01:20:01 <jsnx> unless they aren't actually copied?
01:20:33 <jsnx> hmm, how would i do that...
01:21:06 <jsnx> no, i don't think there's anyway the maps could share values with the list
01:22:04 <jsnx> damn
01:24:43 <jsnx> ah, well -- i've managed to get by without type level programming for too long -- now the weirdness begins!
01:25:25 <Lemmih> C-Keen: hTell, perhaps?
01:25:54 <C-Keen> this is so cool
01:45:11 <sarah> in a type declaration how do you say it returns an instance of a type class?
01:46:58 <Toxaris> sarah: foo :: (MyTypeClass a) => Int -> a
01:47:47 <Toxaris> sarah: this means that foo can return whatever instance of MyTypeClass the caller wants to get
01:47:58 <sarah> thx
01:49:19 <sarah> why int?
01:49:31 <sarah> (my type class has nothing to do with them)
01:51:03 <kmcallister> it's an arbitrary example
01:51:08 <Toxaris> sarah: Int was only an example
01:54:09 <sarah> so for it to return an instance of mytypeclass it would be foo :: someinput -> (MyTypeClass a) => a?
01:54:34 <quicksilver> no, the constraints always go on the far left
01:54:49 <quicksilver> foo :: (MyTypeClass a) => some -> input -> types -> a
01:55:20 <sarah> ah thanks i was confused
01:57:35 <sarah> are using polymorphic datatypes in data definitions illegal?
01:58:02 <quicksilver> you can read it as "For any member of MyTypeClass, let's call it 'a', foo can have the type 'some -> input -> types -> a'
01:58:13 <quicksilver> no, they're not
01:58:20 <quicksilver> but it depends what you mean by polymorphic, I suppose
01:58:28 <quicksilver> data Foo a = Foo [a]
01:58:37 <quicksilver> ^^ data definition using the polymorphic type []
02:00:15 <sarah> ah meant like data Foo = Foo { myVar :: (MyTypeClass a) => a }
02:00:50 <quicksilver> what you probably want is an existential type there
02:00:58 <quicksilver> they are not haskell98, but they're widely supported
02:01:20 <quicksilver> unfortunately you are forced to give via an intermediate data type
02:04:16 <kmcallister> you can also do
02:04:44 <kmcallister> data (MyTypeClass a) => Foo a = Bar a
02:05:14 <kmcallister> which has a different meaning
02:05:14 <glguy> which means something else
02:06:46 <quicksilver> and is a bad idea IMO
02:06:59 <quicksilver> constraints on data types are seldom useful
02:07:14 <quicksilver> constaints on constructors (GHC extension) are slightly more useful in principle
02:07:21 <quicksilver> although I've never needed it myself
02:49:16 * quicksilver answers a #jquery question in haskell. Oops.
03:31:07 <ac> I would imagine people here find Haskell + HaXml to be easier to use than XSLT. Is this true?
03:31:57 <ndm> ac: XSLT is very verbose, and quite painful to use, so I would assume so
03:38:10 <ac> ndm: yeah that's my experience. It's absurd, considering it was supposedly designed to manipulate XML
03:38:46 <quicksilver> Well, would you expect anything designed by the XML guys to be anything other than verbose?
03:39:03 <quicksilver> I don't really think XSL is designed for direct human use
03:39:10 <quicksilver> it's expected you'll use it via some kinds of tools
03:39:15 <ndm> ac, the problem is that it has a syntax described in XML, hence is a bad idea
03:39:17 <EvilTerran> i hear it's turing complete
03:39:22 <opqdonut> it is
03:39:25 <quicksilver> well, I'm sure it is
03:39:31 <opqdonut> a functional programming language practically
03:39:34 <ndm> quicksilver: that only works if you have a solid abstraction, since XSLT implementations all have their own bugs,  you are forced to work at the low level
03:39:37 <EvilTerran> (that's a bad thing)
03:39:50 <ndm> EvilTerran: not necessarily, it can be a good thing
03:39:53 <quicksilver> reasonable transformation description languages more-or-less have to be turing complete
03:39:53 <opqdonut> compiling something higher level into xsl might be useful
03:40:06 <quicksilver> because you need recursive transformations
03:40:08 <EvilTerran> ndm, for glorified stylesheets? i'm suspicious
03:40:16 <quicksilver> (things like transitive closure)
03:40:26 <opqdonut> quicksilver: yep, one quickly reach the level of post systems
03:40:37 <quicksilver> It's quite hard to design a language which admits things like transitive closure without introducing non-termination.
03:40:41 <EvilTerran> sounds like the sort of thing that'd benefit from statically-checkable finite runtime
03:41:03 <quicksilver> once you've introduced non-termination, you might as well go turing complete and just use recursion
03:41:16 <quicksilver> q.v. SQL 3 and its recursive queries
03:41:23 <quicksilver> or whatever that thing is called
03:41:46 <ndm> EvilTerran: depends if you see it as a stylesheet, or a transformation engine for templates, which is how i use it
03:42:01 <quicksilver> it would be an interesting research project to get query languages / transformation languages which admit useful notions like transitive closure without going turing complete
03:42:03 <EvilTerran> eh, i guess. gotta use the right tool for the job, eh. :)
03:42:04 <ndm> EvilTerran: non-termination is not hte biggest flaw in XSLT, there are many many others
03:42:08 <quicksilver> but I can' understnad why they didn't bother.
03:42:16 <EvilTerran> ndm, like the "xml" bit? :P
03:42:26 <quicksilver> some kind of bounded recursion like structural recursion, perhaps.
03:42:34 <ndm> quicksilver: they have recursion
03:42:39 <quicksilver> I know they do.
03:42:45 * EvilTerran wanders off
03:42:48 <quicksilver> I'm talking about what you might do, if you were trying to avoid turing-completeness.
03:42:55 <ac> ndm: if you're actually using XSLT, I assume you're doing it because of browser support. Why not use JavaScript?
03:43:15 <ndm> ac, i preprocess the XSLT and dump out HTML which gets shoved on the web
03:43:34 <ndm> ac, I can also view hte pages in Firefox or IE, but there is more processing overhead, and it doesn't work as reliably
03:43:45 <ndm> ac, Javascript solves a very different problem :)
03:44:12 <ac> ndm: so you are doing it server side. Why not use whatever language you're using to generate the XML to transform it as well? I've never understood why anybody would bother to use XSLT
03:44:50 <ndm> ac, i wanted to try XSLT, i did, i probably wouldn't use it again
03:45:07 <ndm> ac, plus I don't  use any language to write the XML, I hand wrote it
03:45:23 <quicksilver> ndm: since you have aroused our curiousity, what are in your opinion the biggest flaws in xslt?
03:45:37 <ndm> quicksilver: verbose
03:45:47 * quicksilver nods
03:45:50 <quicksilver> definitely
03:45:53 <quicksilver> btu not surprising
03:46:01 <quicksilver> like I say, I think the XML guys expect you to use tools
03:46:10 <quicksilver> most (all?) XML based stuff is verbose
03:46:33 <ndm> quicksilver: i wrote a blog post on it years ago, will try and find it...
03:46:35 <wolverian> xquery is nice
03:46:43 <ac> ndm: yeah, I'm finding myself wanting to do the same thing. Hand write XML and write a Makefile to transform it with probably Haskell I guess
03:46:54 <wolverian> ...because it's not written in xml. of course it has its xml representation, xqueryx, which _is_ verbose.
03:46:59 <osfameron> xpath is lovely and compact
03:47:14 <wolverian> xpath is another nice example of how non-xml tools are not verbose, even if they work on xml. :)
03:47:20 <wolverian> so xml doesn't quite pollute everything it touches...
03:47:42 <ac> wolverian: oh but it does... you mentioned it yourself: xqueryx
03:47:55 <quicksilver> xpath is nice for simple queries
03:48:03 <quicksilver> does it scale well to complex manipulations though?
03:48:10 <wolverian> ac, right. but afaik you can translate between xquery and xqueryx mechanically, so you never need to see xqueryx yourself
03:48:23 <quicksilver> I've used xmlstarlet for some transformations, which uses xpath syntax and was handy
03:48:25 <wolverian> quicksilver, it doesn't manipulate. it's purely a lookup language.
03:48:49 <wolverian> well, I suppose that was too imperative of me
03:49:04 <quicksilver> xmlstarlet sel -T -t -m tv/channel -v @id -o "," -v display-name[1] -o "," -v display-name[2] -n list.channels
03:49:21 <wolverian> no, it doesn't scale like e.g. xquery does. but xquery is a complete functional language.
03:49:21 <quicksilver> but, IIRC the actual transformational behaviour is controlled by that bunch of command line options
03:49:31 <quicksilver> reasonably concise but not excatly readable :)
03:49:47 <wolverian> right. long flags would be nice, at least. :)
03:52:50 <ac> Why are web standards so idiotic? I doubt everybody, or even most people, participating on w3c are idiots...
03:53:12 <mmmdonuts> Nature of committees.
03:53:48 <quicksilver> there are certainly a bunch of smart people at w3c
03:54:03 <quicksilver> I suspect often the problem is that they are aiming for certain goals
03:54:10 <quicksilver> which might not be the goals we're interested in :)
03:54:20 <ndm> quicksilver: http://nmitchell.livejournal.com/28742.html
03:54:21 <lambdabot> Title: nmitchell: Haskell vs XSL
03:54:56 <wolverian> I don't see that much idiocy in web standards, really. it's a very hard job.
03:55:08 <mauke> ndm: what happened to your > signs?
03:55:34 <quicksilver> ndm: yeah :)
03:55:34 <ndm> mauke: i replace them with [ ] so the software in the blog didn't eat them
03:55:37 <wolverian> ndm, now compare HXT and XSL? :)
03:55:49 <ac> wolverian: what about XML? And CSS?
03:55:52 <ndm> wolverian: that is pure computation
03:56:01 <ndm> ac: XML and CSS are totally different from XSLT
03:56:07 <wolverian> hm?
03:56:21 <ac> ndm: yes... I was just providing those two as examples of idiocy
03:56:23 <ndm> wolverian: in that sample there is no transformation of XML
03:56:28 <wolverian> ac, yes, I don't see them as idiotic. this might not be a very popular opinion.
03:56:34 <ndm> ac, i kinda like CSS - much is wrong, but its quite solid
03:56:45 <ndm> ditto XML, a reasonable spec
03:57:03 <ndm> i would probably have not had attributes and gone for tag nesting instead, but XML isn't bad
03:57:08 <mux> CSS, the concept, is great and incredibly useful, too bad that it's hellish in practice because of the numerous browser incompatibilities
03:57:10 <quicksilver> I think CSS is fine as a language.
03:57:15 <quicksilver> I think the box-model is a bit weird :)
03:57:33 <quicksilver> but that's partly because they had to design something which somehow extended/incorporated the old non-standard stuff.
03:58:00 <FalconNL> Does anyone know if it would be technologically possible to determine for which inputs a given function will produce a runtime error? e.g.: errors head == [[]] or errors (/) == [(_,0)] ?
03:58:01 <ac> yeah, I guess I agree CSS could be great if it wasn't backwards compatible
03:58:19 <quicksilver> FalconNL: you should read about ndm's program "catch"
03:58:31 <quicksilver> FalconNL: it is certainly impossible in general, q.v. halting problem
03:58:35 <ndm> @where catch
03:58:35 <ac> FalconNL: isn't that equivalent to the halting problem?
03:58:36 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
03:58:48 <ndm> FalconNL: it is impossible, in general, but i've already got a tool that does it
03:58:59 <ndm> @where+ catch http://www-users.cs.york.ac.uk/~ndm/catch/
03:58:59 <lambdabot> It is forever etched in my memory.
03:59:16 <ndm> lambdabot: liar! i've told you that about 5 times and you keep forgetting!
03:59:20 <FalconNL> ah. Evidently I wasn't the first to come up with the idea of eliminating runtime errors once and for all :)
03:59:23 <quicksilver> ;)
03:59:26 <quicksilver> no, nor the last
03:59:41 <quicksilver> that doesn't reduce the worthiness of the idea, though :)
03:59:44 <quicksilver> quite the contrary.
04:00:03 <ac> FalconNL: as an asside, I believe GHC 6.8 is much nicer for debugging bugs like taking head of an empty list
04:00:40 <ndm> ac, you've tried it, or heard it?
04:00:47 <ndm> i heard it, then tried it, and was rather disappointed
04:00:56 <ac> ndm: unfortunately only read so :-P
04:01:02 <FalconNL> yeah, I heard Simon peyton Jones mention in a lecture that the compiler could catch non-exhaustive guards. Is there some compiler option I have to turn or for that?
04:01:13 <koeien> FalconNL: I believe it'
04:01:16 <koeien> s the default
04:01:28 <mauke> if it needs an option, -Wall
04:01:30 <mux> I know that it's the case at least when using  -Wall
04:01:37 <koeien> aw yes that was it
04:01:47 <FalconNL> ah, thanks, I'll go try it
04:01:48 <koeien> *my* default is using -Wall :)
04:02:32 <ac> koeien: hm. Maybe I should alias ghc to "ghc -Wall"
04:02:48 <ndm> FalconNL: it does catch some, but it gets it wrong, and doesn't eliminate things like head []
04:02:50 <quicksilver> the problem is that there are lots of times when you do in fact want to write code with incomplete pattern matches
04:02:57 <u_quark> there are many project that try to eliminate run-time bug... most extreme approach (that i know of) is implementing a self-proving that caries the proof that it is correct and can be tested by the user!
04:03:01 <quicksilver> that's the point of catch :)
04:03:02 <mauke> I've aliased cc to gcc -std=gnu99 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wdisabled-optimization -O2 -pipe -march=native
04:03:13 <ndm> it basically warns at the definition of an incomplete function, not the use, which would be much more useful!
04:03:24 <mauke> compared to that, ghc -Wall is nothing :-)
04:03:28 * mux is tempted to paste the gcc flags he's using, but that would be spam :)
04:03:31 <opqdonut> -pedantic?
04:03:49 <opqdonut> why not -Werror too :P
04:03:56 <mux> I use -Werror
04:05:23 <opqdonut> i tend not to with large code bases
04:05:50 <mux> we use -Werror for FreeBSD's kernel and a good deal of the userland
04:05:52 <ndm> i find the warnings more annoying, many of those in GHC are a bit pointless
04:05:55 <opqdonut> as there always are some "wanted" errors
04:06:00 <opqdonut> *warnings
04:06:15 <koeien> opqdonut: #pragma ?
04:06:26 <opqdonut> yeh but that's kinda ugly
04:06:42 <opqdonut> as is specifying a million -W flags to catch just the warnings one wants
04:06:55 <koeien> C is ugly :)
04:07:22 <FalconNL> btw, ghc 6.8.2 doesn't detect non-exhaustive patterns by default. It needs a -W* flag
04:08:12 <koeien> is ghc 6.8.2 in debian sid yet? if it is, i'll try out some new features tonight
04:10:36 <koeien> it looks like it is: cool
04:20:44 <quicksilver> I'm beginning to think @quote stereo applies even more to the -cafe than it does to here
04:20:59 <ac> koeien: bleh. Not in ubuntu yet
04:21:09 <quicksilver> that's the price you pay for using ubuntu :P
04:21:14 <ac> waaaah
04:21:25 <Cale> What's not in ubuntu yet? GHC 6.8?
04:21:33 <ac> Cale: yeah, it's still at 6.6-3
04:21:42 <osfameron> otoh you can usually apt-get your deps and compile stuff fairly easily
04:21:43 <Cale> Yeah, I just installed the binary.
04:21:59 <koeien> sure but i like to use the package manager :)
04:22:02 <osfameron> I compiled more recent ghc's without major problems on ubuntu (and I *hate* debugging builds)
04:22:14 <Sizur> opensuse had it for a log time already
04:22:15 <Cale> You can use alien to convert the rpm package for the old readline too.
04:22:17 <shachaf> koeien: That doesn't work for the darcs version anyway. :-)
04:22:27 <ac> osfameron: yeah me too, I'm just lazy
04:22:35 <koeien> yeah but i'm not a dev :)
04:22:46 <resiak> it's faintly possible that the sid packages will install on Ubuntu.  the Ubuntu packages are just pulled straight from Debian anyway
04:22:54 <koeien> yeah, ubuntu == debian sid forked
04:23:39 * osfameron is too stupid and lazy to volunteer to host contributed ubuntu ghc builds as packages
04:23:46 <osfameron> but somebody definitely *should* do it :-)
04:24:24 <jsnx> osfameron: just switch to gentoo :)
04:24:28 <resiak> koeien: well, only universe is mostly still just sid in disguise
04:24:28 <ac> it'd be annoying to be a package mantainer
04:25:25 <jsnx> ac: well, you might feel positive about it, too -- that you were giving something to the other users in your community
04:26:09 <koeien> it's probably not too much work
04:26:11 <osfameron> yeah, I think it would be lovely.  Just I know that I'm not always online and available, and my motivation fluctuates too much to volunteer for something like that
04:30:19 <koeien> but the debian packages are very up-to-date
04:31:19 <quicksilver> one of the GHC core team is a debian developer
04:31:26 <koeien> i suppose so
04:31:33 <quicksilver> Igloo IIRC.
05:03:41 <litb> hello again all
05:03:45 <litb> [ (10 ** fromIntegral x) | x <- reverse [ x | x <- [-12 .. -3], mod x 3 == 0] ]
05:03:55 <litb> is there some better way to do that?
05:05:46 <jedbrown> > map (10**) [-3,(-6)..(-12)]
05:05:48 <lambdabot>  [1.0e-3,1.0e-6,1.0e-9,1.0e-12]
05:06:07 <mauke> > [ 10 ^^ (-x) | x <- [3, 6 .. 12] ]
05:06:08 <lambdabot>  [1.0e-3,1.0e-6,1.0e-9,1.0e-12]
05:06:14 <litb> wow, simply beautiful :)
05:06:47 <sarah> wow didnt know you could do stuff like [3, 6 .. 12]\
05:06:56 <litb> i think i take the one by mauke :)
05:07:08 <mauke> > map ((10 ^^) . negate) . enumFromThenTo 3 6 $ 12
05:07:09 <lambdabot>  [1.0e-3,1.0e-6,1.0e-9,1.0e-12]
05:07:10 <ac> mauke's looks cuter
05:08:08 <mauke> > take 4 $ iterate (/ 1e3) 1e-3
05:08:09 <lambdabot>  [1.0e-3,1.0e-6,9.999999999999999e-10,9.999999999999998e-13]
05:08:31 <mauke> > take 4 $ iterate (* 1e-3) 1e-3
05:08:32 <lambdabot>  [1.0e-3,1.0e-6,1.0e-9,1.0000000000000002e-12]
05:08:46 <litb> something i don't get is, there is x^y , and x^^y . and the former just accepts positive y. why is this?
05:08:53 <quicksilver> because of the types
05:08:59 <quicksilver> a^b will always be another integer
05:09:04 <quicksilver> (since a and b are integral)
05:09:07 <mauke> they are?
05:09:09 <mauke> :t (^)
05:09:10 <quicksilver> and b is positive
05:09:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:09:27 <quicksilver> sorry s/since/if/
05:09:32 <mauke> litb: ^ works on any Num since it only requires multiplication
05:09:39 <quicksilver> if a is integral, result is integral is what I mean
05:09:42 <mauke> ^^ needs recip for negative exponents
05:09:46 <quicksilver> more generally, whatever a is, the result is
05:10:20 <ac> :t (^^)
05:10:22 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
05:10:55 <litb> ahm i see. so 3^^(2.4) should'nt be possible
05:11:20 <litb> :t (**)
05:11:21 <lambdabot> forall a. (Floating a) => a -> a -> a
05:11:27 <litb> nice
05:11:44 <ricky_clarkson> > 3^^2.4
05:11:44 <lambdabot>  Add a type signature
05:11:59 <ricky_clarkson> > (3 :: Integer)^^2.4
05:11:59 <lambdabot>   add an instance declaration for (Fractional Integer)
05:11:59 <lambdabot>     In the expression:...
05:12:13 <ricky_clarkson> > (3 :: Integer)^^24%10
05:12:13 <lambdabot>   add an instance declaration for (Fractional Integer)
05:12:50 <oerjan> > 3^24%10
05:12:51 <lambdabot>  282429536481%10
05:13:39 <ac> @where %
05:13:40 <lambdabot> I know nothing about %.
05:13:45 <mauke> @index (%)
05:13:46 <lambdabot> Data.Ratio
05:13:56 <mauke> @docs Data.Ratio
05:13:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
05:14:43 <ac> so @where is a general purpose index for anything, @index finds something in the standard libs?
05:14:44 <oerjan> ricky_clarkson: ah, you want 3^^(24%10) ? that won't work, ^ and ^^ both require integral exponents
05:14:57 <mauke> ac: yes
05:15:07 <ac> seems like @where and @index should be reversed :P
05:15:11 <oerjan> ac: @where is just what we put in it, really
05:15:16 <quicksilver> @where is user-controlled
05:15:16 <lambdabot> I know nothing about is.
05:15:22 <ricky_clarkson> oerjan: Grr, the type signature confused me.
05:15:25 <ricky_clarkson> :t (^^)
05:15:26 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
05:15:30 <quicksilver> while @index is is based on hoogle indoces, I believe
05:15:32 <oerjan> :t (**)
05:15:32 <lambdabot> forall a. (Floating a) => a -> a -> a
05:15:38 <quicksilver> and @docs is just calculated
05:15:50 <ricky_clarkson> Why would it not be written (Fractional a, Integral b) => a -> b -> a?
05:15:55 <mauke> > (-1) ** 0.5
05:15:58 <lambdabot>  NaN
05:16:05 <mauke> > (-1) ** 0.5 :: Complex Double
05:16:08 <lambdabot>  6.123031769111886e-17 :+ (-1.0)
05:16:14 <oerjan> ricky_clarkson: beats me
05:17:11 <ac> @source Fractional
05:17:12 <lambdabot> Fractional not available
05:17:25 <mauke> @src Fractional
05:17:26 <lambdabot> class  (Num a) => Fractional a  where
05:17:26 <lambdabot>     (/)             :: a -> a -> a
05:17:26 <lambdabot>     recip           :: a -> a
05:17:26 <lambdabot>     fromRational    :: Rational -> a
05:17:46 <ac> @index Infinity
05:17:47 <lambdabot> bzzt
05:17:56 <oerjan> @docs Data.Nonexistent
05:17:56 <lambdabot> Data.Nonexistent not available
05:18:04 <oerjan> quicksilver: not quite calculated
05:18:07 <ac> @hoogle Infinity
05:18:08 <lambdabot> No matches found
05:18:20 <mauke> there is no infinity
05:18:26 <ac> > 1/0
05:18:29 <lambdabot>  Infinity
05:18:36 <oerjan> but @wiki and @hackage are iirc
05:18:42 <litb> hmm
05:18:45 <mauke> @wiki is calculated?
05:18:46 <lambdabot> http://www.haskell.org/haskellwiki/is_calculated?
05:18:49 <litb> i thought 1/0 wasn't defined
05:19:15 <litb> and isn't even. how is it infinity ?
05:19:38 <mauke> because 0 is really small
05:19:47 <oerjan> litb: it's IEEE floating point
05:19:49 <mauke> > 1/0 :: Rational
05:19:50 <lambdabot>  Exception: Ratio.%: zero denominator
05:20:20 <ac> @src Floating
05:20:20 <lambdabot> class  (Fractional a) => Floating a  where
05:20:21 <lambdabot>     pi                                                      :: a
05:20:21 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
05:20:21 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
05:20:21 <lambdabot>     (**), logBase                                           :: a -> a -> a
05:20:35 <oerjan> mauke: i think it is hard for lambdabot to check wiki pages - trying that URL does bring up _something_
05:21:33 <oerjan> > read "1%0" :: Rational -- i recall there was a bug
05:21:42 <lambdabot>  Exception: Ratio.%: zero denominator
05:21:51 <oerjan> hm...
05:22:20 <ndm> oerjan: it brings up an error pages, easy enough to spot!
05:22:22 <oerjan> must have been somewhere else
05:23:18 <ac> how do I test if something's equal to Infinity, other than "a == (1/0)"?
05:23:38 <oerjan> ndm: well it does require wading through the code - the only clue is "(There is currently no text in this page)"
05:23:51 <oerjan> @src RealFloat
05:23:51 <lambdabot> Source not found. I am sorry.
05:23:58 <ac> ah. isInfinite
05:24:01 <oerjan> :t isInfinity
05:24:03 <lambdabot> Not in scope: `isInfinity'
05:24:09 <oerjan> :t isInfinite
05:24:09 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:24:15 <ndm> oerjan: isSubstrOf - half a line of code which executes in absolutely no time
05:24:18 <quicksilver> oerjan: it's only IEEE floating point if the underlying OS is, I believe.
05:24:35 <quicksilver> ndm: isInfixOf, IYTM :)
05:24:36 <oerjan> quicksilver: could be
05:24:48 <quicksilver> that is, the haskell standard doesn't define what 1/0 returns
05:24:58 <quicksilver> but allows implementatiosn to do whatever the 'native system' wants to do.
05:25:19 <ndm> quicksilver: i remember the conversation, and about 5 different names for it, but can never remember what the end result was
05:25:24 <quicksilver> ndm: ;)
05:25:28 <ac> that's kind of smart
05:25:41 <oerjan> > 0/0 == 0/0 -- warping ac's brain
05:25:42 <quicksilver> ndm: isInfixOf was chosen by comparisin with isPrefixOf and isSuffixOf, I have assumed.
05:25:42 <lambdabot>  False
05:26:00 <ac> > (0/0) == (0/0)
05:26:01 <lambdabot>  False
05:26:08 <quicksilver> ndm: it's a typically logical-but-daft kind of thing CS types like :)
05:26:16 <ndm> quicksilver: it was indeed, and it does make logical sense
05:26:31 <ndm> i'll remember it as soon as i start using it, which will be a short while yet
05:27:19 <ac> oerjan: floats are tricky beasts
05:27:53 <litb> for a lambda expression, i cannot have a where clause?
05:28:00 <oerjan> litb: nope
05:28:06 <oerjan> only let
05:28:25 <ac> and top level functions
05:28:39 <quicksilver> you can have a where clause anywhere you can have a declaration
05:28:43 <oerjan> where clauses technically go on declarations, not expressions
05:28:52 <quicksilver> which is, the top level, lets, and other wheres.
05:28:58 <quicksilver> unless I miss something
05:29:00 <oerjan> as well as case matches
05:29:30 <koeien> @src lookup
05:29:30 <lambdabot> lookup _key []          =  Nothing
05:29:30 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
05:29:30 <lambdabot>                         | otherwise = lookup key xys
05:29:46 <quicksilver> oerjan: eh?
05:30:10 <oerjan> > case [1,2,3] of (x:y) -> z:y where z = last y
05:30:16 <lambdabot>  [3,2,3]
05:30:21 <mauke> > case () of { _ -> x where x = "zomg" }
05:30:22 <lambdabot>  "zomg"
05:30:39 <quicksilver> oh, that's odd
05:31:01 <quicksilver> interesting, thanks
05:38:06 <shag> how can i get my code ghc 6.6 compatible when using Data.IntMap.maxViewWithKey?
05:39:13 <kfish> shag, copy the code for that function into your program? :-/
05:39:33 <shag> well, that code uses some internal function of IntMap ...
05:39:52 <kfish> :-(
05:45:51 <litb> case [1,2,3] of (x:y) -> z:y where z = last y <<- it's confusing me . what the hell does it do?
05:45:59 <ddarius> "Encourage and Enforce"?
05:46:18 <koeien> it first binds x to 1 and y to [2,3] and the expression evaluates to z:y
05:46:24 <litb> isn't it saying "if [1, 2, 3] is (x:y) , then let it be z:y ?
05:46:30 <ddarius> > case [1,2,3] of (x:y) -> z:y where z = last y
05:46:31 <faxathisia> > let y = tail [1,2,3] in (last y):y
05:46:33 <lambdabot>  [3,2,3]
05:46:33 <lambdabot>  [3,2,3]
05:46:38 <ac> > case [1,2,3] of { (x:y) -> z:y where z = last y; }
05:46:39 <lambdabot>  [3,2,3]
05:47:03 <ac> litb: the where is for one of the cases, not the whole case statement
05:47:18 <litb> ah, now i understand it
05:47:31 <litb> quite a bit around-the-corner thinking
05:48:03 <quicksilver> it surprised me
05:48:09 <quicksilver> it's there for the benefit of guards I suppose
05:48:12 <ddarius> Wow.  I didn't realize consciously that you could use wheres there (though it makes sense and I'm almost sure I've done it before)
05:48:18 <ddarius> quicksilver: Indeed.
05:48:20 <quicksilver> (cases can have guards)
05:48:37 <koeien> i am almost 100% positive that i've used this before
05:48:43 <koeien> it's quite useful in some cases
05:48:44 <ac> I'd like to see guards on a case
05:48:59 <ddarius> ac: You can use guards with a case
05:49:20 <oerjan> > case 5 of x | even x -> True | otherwise -> False
05:49:21 <lambdabot>  False
05:50:15 <ddarius> > case undefined of x -> 3
05:50:17 <lambdabot>  3
05:50:39 <mux> @src otherwise
05:50:39 <lambdabot> otherwise = True
05:51:05 <ddarius> > case 5 of x | even x -> otherwise | True -> False
05:51:08 <lambdabot>  False
05:51:11 <faxathisia> > case 5 of x | even x -> True ; otherwise -> False
05:51:11 <lambdabot>  False
05:52:16 <ac> > otherwise == true -- funny
05:52:17 <lambdabot>   Not in scope: `true'
05:52:46 <litb> :t _
05:52:48 <lambdabot> Pattern syntax in expression context: _
05:52:59 <litb> i supposed it's the same as otherwise o.O
05:53:06 <faxathisia> no it's not
05:53:15 <ndm> dcoutts, i know i use tests on one of my cabal projects, but can't remember which one...
05:53:16 <faxathisia> _ has no value
05:53:31 <ac> litb: _ is special because you can use it more than once
05:53:33 <ddarius> As the error says, _ isn't even an expression
05:59:40 <koeien> @src span
05:59:40 <lambdabot> Source not found.
05:59:42 <quicksilver> litb: it has similar effect in practice to otherwise, but it's quit different. otherwise is just a shortcut for True.
05:59:46 <quicksilver> > otherwise
05:59:48 <lambdabot>  True
05:59:55 <quicksilver> litb: i.e. it's a boolean guard which matches.
06:00:46 <litb> ah, i see. anyway. if i want to use a fractional number with arbitrary precision, is Rational the right thing to choose ?
06:02:22 <koeien> litb: yes, iirc type Rational = Ratio Integer
06:02:26 <quicksilver> that's the only one in the standard lib, yes
06:02:39 <quicksilver> it lacks transcendental functions, you need something much cleverer for that
06:02:42 <koeien> since Integer has arbitrary precision it is OK
06:02:45 <quicksilver> but it's fine for arithmetic.
06:04:32 <koeien> quicksilver: what do you mean by 'it lacks transcendental functions'
06:04:36 <koeien> quicksilver: like sine, cosine?
06:05:15 <koeien> quicksilver: but they don't necessarily have f (x::Rational) :: Rational ?
06:05:31 <litb> hm, yes. that's bad. i cannot use sin, pi and so on then
06:05:54 <koeien> yes those are not fractions anyway
06:06:02 <litb> (for example, i would have been happy if there was an acos where i can say "up to this precision please")
06:06:13 <ddarius> There are quite a few exact reals implementations on the Applications and Libraries page on Haskell.org
06:06:21 <koeien> there is such a library iirc
06:06:27 <quicksilver> koeien: right. They are not rational, but they are certinaly fractional.
06:06:40 <quicksilver> koeien: and he asked for arbitrary precision, he didn't *ask* for rational :)
06:07:00 <koeien> quicksilver: yes, true
06:07:14 <ddarius> litb: Using rationals, it wouldn't be hard to implement such things via power series (though this would definitely be wheel reinvention, but it is a fun wheel to reinvent)
06:07:16 <koeien> so Integer is "more" than arbitrary precision
06:08:31 <koeien> an arbitrary-precision integer type would be an Int where you can specify a range (possibly at run-time)
06:08:34 <litb> quicksilver: well, i would be happy if there is precision of < inf =)
06:08:37 <koeien> and Integer is more
06:08:50 <koeien> quicksilver: correct?
06:09:21 <ddarius> litb: Don't worry, I assure you that the precisions of Integers is bounded.
06:09:37 <litb> ddarius: you are very right, i will try to wheel it when it's becoming boring again here
06:09:39 <ddarius> (Well, magnitude as precision isn't really the issue here)
06:10:04 <ddarius> @google "Power series, power serious"
06:10:05 <lambdabot> http://www.cs.princeton.edu/courses/archive/fall05/cos318/precepts/pearl.ps
06:10:17 <koeien> cool i'll check it out
06:10:19 <Sizur> :t ((1/)::Int->Rational) undefined
06:10:21 <lambdabot>     Couldn't match expected type `Rational' against inferred type `Int'
06:10:21 <lambdabot>     In the expression: (1 /)
06:10:51 <litb> at least for sin, i know it off of my head =) for pi, i've already implemented in C . so it wouldn't be all that hard i think
06:11:37 <koeien> :t ( ((1/).toRational) :: Int->Rational ) undefined
06:11:38 <lambdabot> Rational
06:12:26 <litb> oh wait, we can say .toRational on every Fractional ?
06:15:03 <doserj> @src Real
06:15:03 <lambdabot> class  (Num a, Ord a) => Real a  where
06:15:03 <lambdabot>     toRational      ::  a -> Rational
06:16:00 <quicksilver> very confusingly named class, that one
06:16:06 <ddarius> > let integrate x0 = (x0:); toFunction f x = scanl (+) 0 (zipWith t f [0..]) where t a n = a*x^n/fromIntegral (product [0..n]); sin = integrate 1 (integrate 0 (map negate sin)) in toFunction sin (pi/4)
06:16:08 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> a1'
06:16:09 <quicksilver> it means "Real not Complex"
06:16:17 <Sizur> ofcourse... undefined always passes the type check
06:16:19 <quicksilver> rather than "Real not necessarily Rational"
06:17:14 <koeien> @pl \p->span (not.p)
06:17:14 <lambdabot> span . (not .)
06:17:50 <Sizur> quicksilver: doesn't math's Real satisfy both statements?
06:18:22 <shachaf> Sizur: Which is why the name is confusing.
06:19:15 <Sizur> well, we cannot really have an irrational number represented... only derived
06:19:33 <Sizur> i'm not defending at all, just thinking outloud
06:20:21 <shachaf> Sizur: Well, you could do some things symbolically.
06:21:02 <quicksilver> you can represent irrational numbers
06:21:09 <quicksilver> sqrt(2) is a representation of an irrational number
06:21:21 <Sizur> not if you evaluate it ;)
06:21:31 <quicksilver> "10134" is a representation of an irrational number, if I decided to tell you that's in base pi
06:21:59 <quicksilver> math's real does satisfy both constraints, yes
06:22:17 <quicksilver> but conventionally in CS, people use "real" as meaning "including irrationals"
06:22:25 <quicksilver> as in the phrase "computable reals" and "real arithmetic"
06:22:31 <shachaf> When I think "real", though, I think of the latter constraint.
06:22:37 <Sizur> hmm, i wonder if irrationality depends on the base
06:23:01 <Sizur> definition of irrationality is not possible to express as a ratio
06:23:03 <shachaf> Sizur: "Irrational" means a number isn't a ratio.
06:23:21 <shachaf> Sizur: Yes, that's independent of base.
06:23:28 <Sizur> then 10134 is rational in base pi but irrational if you convert it to base10
06:24:28 <shachaf> Well, OK, in an irrational base.
06:27:39 <quicksilver> Sizur: no. 10134 (base pi) is an irrational number
06:27:49 <quicksilver> rational/irrational are not relative concepts
06:27:55 <quicksilver> they are absolute
06:27:56 <litb> ddarius: i don't know what that integrate function was supposed to do, but it certainly is smaller than my integrate function done myself o.O
06:28:05 <quicksilver> x is rational == x \in \Q
06:28:36 <quicksilver> I should say, actually, that proving 10134 (base pi) to be irrational may not be entirely trivial, of course :)
06:28:46 <quicksilver> however, it is.
06:30:42 <Sizur> quicksilver: what's the definition of irrationality?
06:31:06 <jedbrown> What does `base pi' mean here?
06:31:10 <koeien> not being in {a/b:a in Z, b in N} ?
06:31:20 <quicksilver> right, koeien typed it faster
06:31:36 <quicksilver> jedbrown: 333 in base pi is 3*pi*pi + 3*pi + 3
06:31:44 <koeien> jedbrown: 1*pi^4 + 0 * pi^3 + 1 * pi^2 + 3 *pi^1 + 4 * pi^0
06:31:53 <quicksilver> this time I tped it faster!
06:31:55 <quicksilver> one all!
06:31:58 <koeien> quicksilver: :)
06:32:36 <Sizur> what's the Z there?
06:32:41 <koeien> integers
06:32:45 <quicksilver> integers (includes negative ones)
06:38:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4879
06:39:39 <jedbrown> I suppose `rational in base pi' is meant to mean in \Q[pi^n | n \in \N].  The definition of rationality has nothing to do with the base, so this discussion seemed odd to me.
06:40:07 <quicksilver> jedbrown: I don't think "rational in base pi" is particularly meaningful
06:40:25 <quicksilver> jedbrown: what you've written is the best bet, but I'd call that 'polynomial in pi' personally.
06:40:46 <quicksilver> jedbrown: the point I'm trying to make to Sizur is that this stuff about computers being unable to represent irrationals is codswallop.
06:40:47 <koeien> yes, is this different from a polynomial in X ?
06:41:25 <quicksilver> computers can represent what I tell them to represent, dammnit :P
06:41:37 <quicksilver> koeien: that is a hard question.
06:41:52 <quicksilver> koeien: the answer depends on whether or not pi satistfies any non-trivial polynomials.
06:41:55 <quicksilver> the answer is no
06:42:01 <quicksilver> (because pi is transcendental)
06:42:03 <quicksilver> but the proof is hard.
06:42:07 <koeien> quicksilver: wouldn't that make it algebraic?
06:42:08 <koeien> ok
06:42:34 <quicksilver> I have a great proof that pi is transcendental but it won't fit in the margin of this IRC channel.
06:42:43 <koeien> :) i've seen it once or twice
06:42:50 <ndm> @src any
06:42:51 <lambdabot> any p =  or . map p
06:43:08 <koeien> i've never seen the other proof in the margin
06:43:21 <ndm> @src or
06:43:22 <lambdabot> or    =  foldr (||) False
06:44:09 <Sizur> ok, point taken, but unless we will have symbolic processors, or a language that does it for is, it will never be easy
06:44:16 <Sizur> for us*
06:44:26 <quicksilver> since we have both of those things, though
06:44:28 <quicksilver> it is easy :)
06:44:42 <Sizur> you shouldnt care of the order of your computation to affect the result
06:45:33 <Sizur> and if you evaluate sin(x) now and then do something with it, the answer will turn out to have a larger error
06:46:13 <litb> hm, i'm unsure about this: [ i y | y <- [1..], abs (ref - i y) <= eps ]
06:46:15 <Sizur> if i have sin(x) here and -sin(x) there, then they should cancel
06:46:23 <litb> can i somehow make it that i y is only evaluated one time?
06:46:24 <jedbrown> It gets hard when you want to represent *all* irrationals.  But if you choose any particular ones, it is still easy.
06:46:40 <koeien> litb: why would it be evaluated more often?
06:47:02 <jedbrown> koeien: Because GHC doesn't do CSE
06:47:17 <litb> hm, i thought because i have it more than one time there
06:47:28 <quicksilver> yes, you can
06:47:32 <koeien> litb: aw i mussed the second i y, sorry :)
06:47:50 <quicksilver> [ iy | y <- [1..], let iy = i y, abs (ref - iy) <= eps ]
06:47:53 <koeien> would a let-binding work?
06:48:25 <litb> wow, that's really a nice piece of code :)
06:50:52 <EvilTerran> ... is someone trying to make a list of all irrationals?
06:50:58 <EvilTerran> that sounds tricky
06:51:05 <koeien> that would be impossible :) "a list"
06:51:06 <EvilTerran> (impossible, for starters)
06:51:28 <EvilTerran> indeed, there's the problem of countability
06:51:40 <jedbrown> Although a well-ordering exists, if you accept the axiom of choice.
06:52:07 <koeien> jedbrown: what implicaties would that have on this particular problem?
06:52:34 <EvilTerran> but then there's the matter of representing *one* irrational in finite space in the general case
06:53:01 <Sizur> rational#1 ;P
06:53:09 <jedbrown> koeien: Probably none, but a well-ordering has some properties of lists.
06:53:28 <jedbrown> koeien: Namely, a next element.
06:53:28 <quicksilver> EvilTerran: depends what you mean by *one*, of course
06:53:37 <quicksilver> EvilTerran: all the numbers you and I can talk about, we can represent.
06:53:43 <EvilTerran> well, yes
06:53:45 <quicksilver> the problem is the ones we can't talk about
06:53:50 <EvilTerran> exactly :)
06:53:51 <quicksilver> (turn out to be a lot of them)
06:53:58 <quicksilver> but, should we care about them ;)
06:54:01 <quicksilver> do they talk about us?
06:54:08 <EvilTerran> "the smallest positive real number we can't talk about" :D
06:54:28 <jedbrown> An irrational to a rational power is irrational.  That makes a lot already.
06:54:47 <jedbrown> Rather, a rational to an irrational power.  Sorry.
06:54:58 <Japsu> rational cat is rational. irrational cat is irrational
06:55:01 * EvilTerran was gonna say... sqrt(2)^2
06:55:02 <koeien> of course, sqrt(2)^2
06:55:08 <EvilTerran> ha
06:55:46 <jedbrown> A nice example: sqrt(2)^sqrt(2)^sqrt(2) is rational.
06:56:13 <mauke> > sqrt(2)**sqrt(2)**sqrt(2)
06:56:17 <lambdabot>  1.7608395558800285
06:56:19 <koeien> with right-associative ^ ?
06:56:30 <idnar> > sqrt(2) ** (sqrt(2) ** sqrt(2))
06:56:31 <lambdabot>  1.7608395558800285
06:56:33 <jedbrown> left-associative
06:56:35 <oerjan> jedbrown: neither irrational to rational nor rational to irrational power is necessarily irrational
06:56:45 <idnar> > (sqrt(2) ** sqrt(2)) ** sqrt(2)
06:56:45 <lambdabot>  2.0000000000000004
06:56:51 <idnar> oh, duh
06:56:58 <idnar> that's sqrt(2) ** 2
06:57:08 <Sizur> there goes the symbolysm
06:57:09 <quicksilver> idnar: u wuz tricked!
06:57:09 <jedbrown> It's stronger.  Rational to an irrational power is transcendental.
06:57:09 <quicksilver> :P
06:57:37 <idnar> > sqrt(2) ** sqrt(2)
06:57:37 <lambdabot>  1.632526919438153
06:58:02 <litb> that's even more interesting than #math here.
06:58:14 <quicksilver> jedbrown: except for 0 and 1.
06:58:15 <oerjan> jedbrown: no.
06:58:22 * EvilTerran is reminded of the non-constructive proof that an irrational to an irrational power can be rational
06:58:29 <oerjan> the power must be algebraic.
06:58:34 <quicksilver> and that :)
06:58:53 <litb> is the power of love rational ?
06:59:01 <jedbrown> oerjan: Gelfond-Schneider Theorem.
06:59:14 <oerjan> jedbrown: i know.
06:59:15 <Sizur> is love rational?
06:59:24 <quicksilver> correct, but the power must be irrational algebraic
06:59:30 <quicksilver> not general "irrational"
06:59:31 <jedbrown> oerjan: Right.
07:00:07 <EvilTerran> is rt2^rt2 rational? if so, we're done. if not, consider (rt2^rt2)^rt2 = rt2^(rt2*rt2) = rt2^2 = 2, in which case rt2^rt2 is irrational (by assumption) and (rt2^rt2)^rt2 is rational, so we're done
07:00:23 * jedbrown kicks himself for mixing things up.
07:00:42 <koeien> EvilTerran: nice proof, saw it on wiki once
07:01:09 <hpaste>  pyx annotated "(no title)" with "(no title)" at http://hpaste.org/4879#a1
07:01:19 <Sizur> > let r = sqrt(2) in (r**r)**r
07:01:20 <lambdabot>  2.0000000000000004
07:02:59 <Sizur> quicksilver: so the easy part you were talking about is simplifying by hand?
07:03:39 <Sizur> i think the compiler should do it
07:03:45 <Sizur> someday
07:06:08 <quicksilver> Sizur: well you were talking about more than one thing
07:06:17 <quicksilver> it's not necessary to simplify, necessairly
07:06:33 <quicksilver> most computable real implementations jsut allow you to calculate up to whatever precision you want
07:06:42 <quicksilver> on the other hand if you *do* want to work symbolically
07:06:47 <quicksilver> there are pretty impresive simplifiers out there
07:06:55 <quicksilver> just look at mathematica and friends
07:07:21 <Sizur> i'm just arguing that symbolic simplification should be part of the compiler
07:08:15 <Sizur> optimized to do the least operations on irrational (already evaluated evaluated) values
07:08:28 <hpaste>  bsdemon annotated "(no title)" with "check it!" at http://hpaste.org/4879#a2
07:08:47 <koeien> http://hpaste.org/4879#a2
07:08:56 <koeien> sorry
07:14:29 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/4879#a3
07:17:28 <Sizur> but it's always easy to say how things should be ;)
07:18:22 <glen_quagmire> hey, if you're bored, give me a one liner that calculates all dates in the form of YYYY-MM-DD which evaluates to 1970.  for example, 2005-11-24 = 1970
07:18:46 <Sizur> you can do same stuff you're doing in haskell with perl. we love haskell because it checks for more errors automatically
07:19:22 <faxathisia> > 2005-11-24 -- uh??
07:19:26 <lambdabot>  1970
07:19:50 <faxathisia> oh... stupid APL evaluation rules confusing me...
07:20:36 <shachaf> glen_quagmire: Is there a particular reason you want those dates? :-)
07:20:51 <glen_quagmire> shachaf: so that i can blog my nerdiness
07:21:12 <glen_quagmire> i found that 1970 + 12 + 31 = 2013. so 2013 is a significant year
07:21:29 <byorgey> > [(y,m,d) | y <- [1970..1970+12+31], m <- [1..12], d <- [1..31], y-m-d == 1970 ]  -- a simple start, but obviously months with less than 31 days screw it up
07:21:33 <lambdabot>  [(1972,1,1),(1973,1,2),(1973,2,1),(1974,1,3),(1974,2,2),(1974,3,1),(1975,1,4...
07:21:39 <Sizur> sorry, why is 2013 significant again?
07:22:10 <glen_quagmire> > 2013-12-31
07:22:11 <lambdabot>  1970
07:22:12 <oerjan> byorgey: you don't need that y list
07:22:16 <Sizur> you can filter based on date validity
07:22:23 <shachaf> glen_quagmire: Why does that make it significant?
07:22:27 <oerjan> just let y = 1970+m+d
07:22:42 <glen_quagmire> because epoch time starts from 1970
07:23:06 <C-Keen> can I use a where clause that is valid for all guards of a function definition?
07:23:07 <shachaf> glen_quagmire: But that's arbitrary.
07:23:13 <quicksilver> let mons = [undefined,31,28,31,30,31,30,31,31,30,31,30,31]
07:23:21 <shachaf> glen_quagmire: And why are you looking at the end of the year?
07:23:32 <quicksilver> then change "d" to "d <- mons !! m"
07:23:33 <faxathisia> C-Keen: I don't think so
07:23:37 <shachaf> C-Keen: I don't think so.
07:23:37 <oerjan> C-Keen: only if there is just one set of argument patterns
07:23:40 <hpaste>  gg annotated "(no title)" with "(no title)" at http://hpaste.org/4879#a4
07:23:51 <glen_quagmire> i'm a pseudo scientist.
07:24:14 <C-Keen> So I have to write this out for each guard? Maybe I should define a little function instead
07:24:21 <quicksilver> not for each guard, no
07:24:24 <oerjan> C-Keen: not for each guard
07:24:30 <quicksilver> but for each equation
07:24:35 <quicksilver> if there is only one equation, it's fine
07:24:49 <quicksilver> otherwise you can pull it into a case
07:24:50 <oerjan> quicksilver: um equation is not the right word
07:24:58 <quicksilver> I believe it is?
07:25:06 <oerjan> the = goes to the right of each guard, remember
07:25:08 <C-Keen> there is just one equation that should use the where but the other one returns nothing
07:25:15 <quicksilver> "f 1 = 0; f 0 = 1" <-- this is a function defined in two equations.
07:25:56 <oerjan> f x | even x = 0 | otherwise = 1 -- two equations, but can share a where
07:26:06 <quicksilver> I think that's one equation, personally
07:26:09 <Sizur> Data.Time.Calendar does not have a data validity function :/
07:26:13 <quicksilver> but I agree it could be confusing ;)
07:26:37 <Sizur> :t fromGregorian
07:26:39 <lambdabot> Not in scope: `fromGregorian'
07:27:10 <Sizur> :t Data.Time.Calendar.fromGregorian
07:27:11 <C-Keen> I have f x | cond1 = Nothing | otherwise Just some stuff x where stuff = something else
07:27:11 <lambdabot> Couldn't find qualified module.
07:28:01 <faxathisia> :t "[Char]"
07:28:02 <lambdabot> [Char]
07:28:13 <oerjan> C-Keen: are you missing = after otherwise?
07:28:42 <oerjan> C-Keen: a where should be fine in that case
07:28:46 <resiak> > fix (\x -> x `asTypeOf` x)
07:28:47 <lambdabot>  Exception: <<loop>>
07:28:48 <resiak> aww.
07:29:00 <C-Keen> oerjan: yes you where right *blush*
07:29:26 <Saizan> > fix id
07:29:27 <lambdabot>  Exception: <<loop>>
07:29:40 <C-Keen> I feel like an idiot in doing things in haskell :\
07:29:52 <Saizan> > fix typeOf
07:29:53 <lambdabot>  TypeRep
07:29:54 <glen_quagmire> > Data.Time.Calendar.fromGregorian 2000 2 (-1)
07:29:55 <lambdabot>   Not in scope: `Data.Time.Calendar.fromGregorian'
07:30:03 <earthy> c-keen: so do I. and I mostly know what I'm doing. :)
07:30:30 <faxathisia> @pl @pl
07:30:30 <faxathisia> :t asTypeOf
07:30:30 <lambdabot> (line 1, column 1):
07:30:30 <lambdabot> unexpected "@"
07:30:30 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
07:30:31 <lambdabot> forall a. a -> a -> a
07:32:44 <idnar> @djinn forall a. a -> a -> a
07:32:44 <lambdabot> f _ a = a
07:32:51 <byorgey> C-Keen: that's ok, it takes a while to get used to.  we were all there at one point. =)
07:32:55 <oerjan> that's the wrong one
07:33:22 <faxathisia> @djinn a -> b
07:33:23 <lambdabot> -- f cannot be realized.
07:33:31 <yrlnry> @djinn (a->a)->a
07:33:32 <lambdabot> -- f cannot be realized.
07:33:36 <yrlnry> @type fix
07:33:37 <lambdabot> forall a. (a -> a) -> a
07:33:58 <yrlnry> Speaking of which, just yesterday I read Turner's paper on guaranteed-to-terminate computation.
07:34:24 <quicksilver> s'a good paper
07:35:47 <faxathisia> What's it about?
07:36:25 <oerjan> guaranteed-to-terminate computation, i'd hazard to guess.
07:37:03 <quicksilver> weaker notions of computation
07:37:08 <quicksilver> like inductive data types
07:37:33 <yrlnry> That you can fix a nuber of glaring problems in the Haskell type system by restricting your notion of computation to only those functions that are guaranteed to terminate.
07:37:41 <yrlnry> Just a minute, I'll hunt up the reference.
07:38:49 <yrlnry> http://portal.acm.org/citation.cfm?id=652567
07:38:50 <lambdabot> Title: Elementary Strong Functional Programming
07:38:53 <yrlnry> Just a sec.
07:39:34 <yrlnry> http://www.google.com/url?sa=t&ct=res&cd=6&url=http%3A%2F%2Fwww.jucs.org%2Fjucs_10_7%2Ftotal_functional_programming%2Fjucs_10_07_0751_0768_turner.pdf&ei=fuqER8_NN4aKesCclFA&usg=AFQjCNHnOZlyo8eLnHqIjs9pglWLSI-m4w&sig2=orcVpNrqKkzw45SaqItavw
07:39:38 <lambdabot> http://tinyurl.com/2p9y9l
07:39:42 <yrlnry> Bah, Google.
07:39:48 <yrlnry> Anyway, that's the PDF.
07:39:52 <faxathisia> cool thank you
07:39:52 <quicksilver> the tinyurl works, anyhow
07:39:58 <quicksilver> despite the longness of the long url :)
07:39:58 <yrlnry> You are very welcome.
07:40:43 <matthew_-> will "\tv -> atomically (readTVar tv)" ever abort?
07:40:50 <matthew_-> s/abort/retry/
07:41:06 <quicksilver> no
07:41:16 <quicksilver> only transactions which write stuff can retry, as I understand it
07:41:21 <matthew_-> ahh
07:41:21 <quicksilver> (which may not be very well)
07:41:38 <quicksilver> unless you retry yourself explicitly, of course!
07:41:40 <mauke> quicksilver: that doesn't sound right
07:41:41 <matthew_-> will "\tvLst -> atomically (mapM readTVar tvLst)" ever retry?
07:42:03 <matthew_-> yeah, you see with that one, surely the idea is that the reads are reading a consistent snapshot of the world
07:42:12 <matthew_-> so they should abort if there are writes mixed in there no?
07:42:19 <mauke> atomically $ liftM2 (,) (readTVar v) (readTVar v)
07:42:19 <quicksilver> ah, perhaps you're right.
07:42:26 <matthew_-> I dunno
07:42:28 <quicksilver> yes, good point.
07:42:35 <yrlnry> I got to the Total Functional Programming paper from here: http://en.wikipedia.org/wiki/Corecursion
07:42:36 <lambdabot> Title: Corecursion - Wikipedia, the free encyclopedia
07:42:37 <Tac-Tics> yeah, if one of those variables in tvLst is changed, it would need to retry
07:42:49 <quicksilver> but reading only one can't retry.
07:42:51 <BMeph> Weird: I cal'd that there are 366 of those == 1970 days.
07:43:11 <matthew_-> actually, I'm really not convinced of my arguement at all
07:43:29 <thoughtpolice> judging from the docs it doesn't look like it will retry
07:44:00 <Tac-Tics> stay pure, and the O(1)ness of assignment will ensure it won't even matter
07:44:06 <BMeph> Whoops, had one that was off; there are 365 of them.
07:44:31 <matthew_-> reading a TVar is by definition consistent as inconsistent values are by definition hidden by the transactions
07:44:45 <matthew_-> so I think it shouldn't retry, as quicksilver originally suggested
07:45:00 <quicksilver> I don't think you're right
07:45:05 <quicksilver> STM is not MVCC
07:45:07 <oerjan> BMeph: that's not immensely surprising ;)
07:45:09 <quicksilver> it's optimistic concurrency
07:45:28 <oerjan> 1970+any day other than february 29
07:45:30 <quicksilver> it doesn't actually maintain "alternative realities"
07:45:46 <oerjan> which happens not to give a leap year
07:46:21 <hpaste>  bhondu pasted "(no title)" at http://hpaste.org/4881
07:46:23 <matthew_-> well, there's the alternative reality where people believe STM is the magic bullet that'll save us all ;)
07:46:35 <BMeph> Yeah - once I threw in the leap year check, it tossed that one out. I found it more impressive as 366.
07:46:36 <quicksilver> ;)
07:46:47 <Apocalisp> quicksilver: "Alternative realities" boil down to sequencing anyway.
07:47:01 <quicksilver> Apocalisp: not quite.
07:47:13 <quicksilver> Apocalisp: they allow long-running read transactions to overlap termporally
07:47:17 <quicksilver> (with write operations)
07:47:28 <quicksilver> instead of having to abort once a conflicting write commits
07:48:21 <matthew_-> you see, if you have a transaction that only reads, then it's never going to change the world, so it can't have any write conflicts. So I think it should just go straight through without any retrys
07:48:22 <Apocalisp> Oh, right. But the client can't tell the difference between that and sequencing.
07:48:44 <quicksilver> Apocalisp: but nonetheless it is this exact point we are dicussing :)
07:48:45 <Apocalisp> :-o It's a monad!
07:48:56 <quicksilver> Apocalisp: whether or not a multiple read can ever retry.
07:49:05 <quicksilver> matthew_-: it has a sort of "return" conflict
07:49:16 <quicksilver> matthew_-: when the transaciton commits, it returns a value to the calling IO code
07:49:29 <matthew_-> the point of the retry is that you're trying to update the world with new values that are based on now out-of-date data
07:49:42 <quicksilver> matthew_-: it's not only out of date you have to worry about
07:49:46 <quicksilver> it's inconsistent
07:49:54 <quicksilver> and that's why your multiple read can, in fact, retry
07:50:04 <quicksilver> it will retry if the data it has read turns out to be inconsistent.
07:51:51 <quicksilver> "When execution returns
07:51:51 <quicksilver> to the AtomicFrame, the log is validated, using STMIsValid, to
07:51:51 <quicksilver> check that it reflects a consistent view of memory. For each log
07:51:51 <quicksilver> entry, validation checks that the old value is pointer-equal to the
07:51:51 <quicksilver> current contents of the TVar.locates new wait-queue entries, held in doubly-linked lists attached
07:51:54 <quicksilver> to the TVars that the transaction has read, using the previously-null
07:51:55 <Apocalisp> So STM has atomicity and isolation, but not consistency?
07:51:57 <quicksilver> field in each TVar. Once this is done, the calling thread is respon-
07:51:57 <Sizur> matthew_-: what if you begin to read and then another transaction modifies the stuff you are about to continue to read?
07:51:59 <quicksilver> sible for blocking itself and re-entering the scheduler.
07:52:07 <quicksilver> Apocalisp: no, it has consistency, in fact :)
07:52:23 <matthew_-> ahh, I see, eg assume x and y are both initially 0; atomically (writeTVar x 1 >> writeTVar y 2); || atomically (readTVar x >>= \xv -> readTVar y >>= \yv -> return [xv, yv]). Here - the values of xv and yv should be [0,0] or [1,2] not any other combination?
07:52:31 <quicksilver> Apocalisp: what I'm trying to convince matthew_- of, is that because it has consistency, multiple reads can retry.
07:52:46 <Apocalisp> ohhh
07:53:08 <quicksilver> matthew_-: yes, exactly what you said.
07:53:17 <quicksilver> this condition is called serializability.
07:53:22 <matthew_-> yep.
07:53:33 <quicksilver> A property which STM has but none of the SQL databases have.
07:53:45 <quicksilver> despite the existence of the poorly named 'transaction isolation serializable'
07:53:46 <Apocalisp> ;-) No, they don't.
07:54:21 <quicksilver> matthew_-: in fact, for implementation reasons, I suspect even a single read transaction might retry
07:54:30 <quicksilver> matthew_-: although it should be very unlikely in practice.
07:54:39 <C-Keen> :t Word8
07:54:41 <lambdabot> Not in scope: data constructor `Word8'
07:54:47 <quicksilver> because the test of consistency which GHC uses is conservative
07:54:56 <quicksilver> they use "equal to the current state" for consistent
07:55:05 <quicksilver> not "equal to any consistent state"
07:55:12 <quicksilver> which is conservative, and feasible.
07:56:03 <matthew_-> gotcha
07:56:48 <quicksilver> so atomically (x <- readTVar foo; do something slow ; return x )
07:56:58 <quicksilver> could retry because foo might change during the slow bit
07:57:09 <oerjan> @index Word8
07:57:10 <lambdabot> Data.Word, Foreign
07:57:15 <quicksilver> but in practice you'd be unlikely to write something like that
07:57:50 <matthew_-> "in pactice" not in "academia"
07:58:45 <quicksilver> ;)
07:58:57 <quicksilver> well you don't normally do slow stuff inside STM
07:59:23 <quicksilver> without STM writes
07:59:31 <quicksilver> because you might as well do it outside
08:00:16 <matthew_-> so, atomically (mapM_ (flip writeTVar 0)) should never retry
08:00:58 <matthew_-> no that's wrong
08:01:13 <matthew_-> ugh, this is vastly trickier than something else
08:01:49 <matthew_-> because you could do two of those in parallel, one with 0 and one with 1 and the same list of tvars and they must not interleave
08:02:25 <quicksilver> exactly
08:02:42 <quicksilver> I wonder if you could get starvation that way
08:02:51 <matthew_-> it wouldn't surprise me
08:03:04 <quicksilver> I thought STM had a progress guarantee
08:03:19 <quicksilver> yes, it does
08:03:24 <quicksilver> one of those would commit first
08:03:26 <quicksilver> of course
08:03:30 <quicksilver> so progress would be made
08:04:46 <matthew_-> hmm. I'm not convinced
08:05:14 <quicksilver> matthew_-: whichever one tries to commit first will succeed
08:05:27 <quicksilver> matthew_-: it will not see the partial results of the other, because the other has not yet committed.
08:05:31 <quicksilver> matthew_-: but then, the other will fail.
08:05:46 <matthew_-> yes yes. of course. Sorry I was entertaining the idea that they would commit in parallel
08:05:51 <quicksilver> in fact, I think the implementation described in that paper is stricter than needed
08:05:58 <quicksilver> I think if you have a write with no preceding read
08:05:58 <matthew_-> which is, I'm sure you'll agree, an entertaining idea
08:06:07 <quicksilver> there would be no need to check that variable
08:06:13 <hpaste>  resiak pasted "Is this a sensible way to optionally serialize access to a global MVar?" at http://hpaste.org/4882
08:06:14 <quicksilver> because it doesn't matter if it's changed or not
08:06:28 <quicksilver> resiak: yes
08:06:42 <resiak> and, is this already done in some library that i should just reuse?
08:06:43 <quicksilver> resiak: that's exactly what MVars are for :)
08:06:45 <quicksilver> no, it's not
08:06:50 <quicksilver> AFAIK>
08:07:00 <resiak> quicksilver: sure, but I meant the MVar -> State "lifting" (is that the right word?)
08:07:11 <quicksilver> not really the right word, but it makes perfect sense
08:07:20 <faxathisia> ?djinn (a->b)->(a->c)->(b->d)->(c->e)->a->(a,b,c,d,e)
08:07:22 <lambdabot> f a b c d e = (e, a e, b e, c (a e), d (b e))
08:07:29 <resiak> I contemplated making all access serialized, but then you'd block reading a huge file even if it doesn't use the global state
08:07:46 <quicksilver> resiak: I went into some detail on how to do that with IORefs to thread state through IO callbacks.
08:07:50 <quicksilver> resiak: in a -cafe post
08:08:00 <quicksilver> resiak: I briefly mentioned there was an obvious generalisation to MVars
08:08:05 <quicksilver> but I didn't bother to write it out :)
08:08:16 <resiak> hah
08:08:23 <resiak> i was in fact reading exactly that post a few hours ago
08:08:56 <resiak> so i'm glad that my implementation meets with its author's approval :)
08:12:25 <resiak> When you just want to read the state, \f -> do { v <- ask; state <- readMVar v; return (f state) } seems like it should have a standardish name; maybe 'askState' ?
08:18:51 <hpaste>  mmorrow pasted "{.c,.hs} -> (gcc,ghc) -> {.s,.s}" at http://hpaste.org/4883
08:20:00 <quicksilver> matthew_-: after some discussions with one of the STM authors, he seems to agree that write-only transactions shouldn't need to check the log.
08:20:06 <quicksilver> matthew_-: but they do, in the current implementation.
08:21:46 <hpaste>  (anonymous) annotated "{.c,.hs} -> (gcc,ghc) -> {.s,.s}" with "the rest" at http://hpaste.org/4883#a1
08:23:38 <evil08> hola atodos
08:25:22 <matthew_-> quicksilver: ahh, interesting.
08:25:36 <matthew_-> who's at glasgow doing STM?
08:25:53 <matthew_-> (or were these non-inperson discussions?)
08:26:28 <quicksilver> I'm in london!
08:26:33 <quicksilver> Simon M is in cambridge.
08:26:40 <quicksilver> But geography is no barrier in this world.
08:26:48 <quicksilver> matthew_-: http://hackage.haskell.org/trac/ghc/ticket/2028
08:26:50 <lambdabot> Title: #2028 (STM slightly conservative on write-only transactions) - GHC - Trac
08:28:50 <pejo> quicksilver, you just say that because you can get anywhere in UK within a couple of hours. ;)
08:29:01 <quicksilver> well, there is that
08:29:07 <ndm> anyone any idea how expensive unsafePerformIO $ readIORef / writeIORef is
08:29:13 <quicksilver> although it took 3 and a half hours to get to sheffield at the weekend.
08:29:17 <ndm> pejo: i spent 9 hours on the train the day i went to oxford
08:29:23 <matthew_-> quicksilver: where are you in london?
08:29:25 <Apocalisp> > join $ map (\x -> map (* x) [0..9]) [0..9]
08:29:28 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,10,12,14,16,18,0,3,6,9,12...
08:29:31 <quicksilver> matthew_-: just by Mansion House tube
08:29:41 <Apocalisp> What's a more general way of doing that?
08:29:41 <pejo> ndm, isn't London somewhat of a hub though?
08:29:47 <matthew_-> ahh, fancy a pint tomorrow?
08:29:58 <ndm> pejo: kinda, its also very expensive to travel to and from
08:30:19 <dcoutts> ndm: unsafePerformIO is not free, read/write on IORefs is pretty cheap
08:30:21 <oerjan> > liftM2 (*) [0..9] [0..9]
08:30:22 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,2,4,6,8,10,12,14,16,18,0,3,6,9,12...
08:30:26 <faxathisia> > join [1,2,3]
08:30:26 <lambdabot>   add an instance declaration for (Num [a])
08:30:26 <lambdabot>     In the expression: 3
08:30:46 <Apocalisp> oerjan: Nice! That's what I was looking for.
08:30:53 <matthew_-> quicksilver: or are you leaving london soon?
08:31:11 <faxathisia> > liftM2 (,) [1,2,3,4,5] [88,55]
08:31:12 <lambdabot>  [(1,88),(1,55),(2,88),(2,55),(3,88),(3,55),(4,88),(4,55),(5,88),(5,55)]
08:31:20 <ndm> mmm, i think i might even be safe with inlinePerformIO here
08:31:30 <faxathisia> @src liftM2
08:31:30 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:31:31 <ndm> dcoutts, are you going to propose inlinePerformIO for System.IO.Unsafe
08:31:35 <yrlnry> How does liftM2 know which monad to lift (,) into?
08:31:46 <faxathisia> I think it is using lists
08:31:53 <faxathisia> since I passed in some
08:31:57 <dcoutts> ndm: probably not, and certainly not under that name
08:32:06 <faxathisia> :t liftM
08:32:06 <faxathisia> :t liftM2
08:32:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:32:07 <yrlnry> Evidently.  But if the later arguments were in some other monad, wouldn't it lift into that monad?
08:32:07 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:32:11 <Sizur> > liftM2 (,) (Just 1) Nothing
08:32:14 <lambdabot>  Nothing
08:32:25 <yrlnry> Huh.  I did not know the Haskell type system was that expressive.
08:32:31 <Sizur> > liftM2 (,) (Just 1) (Just 2)
08:32:32 <lambdabot>  Just (1,2)
08:32:34 <faxathisia> parametric polymorphism ????
08:32:52 <dcoutts> ndm: there is also another form of unsafePerformIO that is intermediate in safety between unsafePerformIO and inlinePerformIO, one might informally call it unlockedPerformIO
08:33:00 <yrlnry> It's the declaration of m as a type of kind "* -> *" that I didn't realize was allowed.  I thought that the * -> * was only metasyntax.
08:33:11 <ndm> dcoutts, then submit them all with plenty of docs!
08:33:19 <oerjan> yrlnry: it's an extension
08:33:32 <dcoutts> ndm: well exactly, I'd have to recall what the safety properties are
08:33:33 <yrlnry> Ahhhh.
08:33:38 <quicksilver> yrlnry: yeah, it's not haskell98, but it's handy in some circumstances.
08:33:39 <oerjan> as is the forall keyword
08:33:56 <quicksilver> matthew_-: not leaving, no. I work here every day :)
08:34:02 <yrlnry> I learned haskell by reading the report :)
08:34:28 * bos reads some java code samples, and his head bursts into flames. "they're all wrong!"
08:34:48 <matthew_-> quicksilver: ok, for some reason I thought you were at glasgow uni
08:34:57 * quicksilver shakes his head
08:35:04 <bos> morons earnestly informing the even more ignorant that "volatile" means almost the same thing as "synchronized". jaypers.,
08:35:10 <matthew_-> ok, I'm delusional then
08:35:12 <quicksilver> once upon a time I was at QM.
08:35:21 <quicksilver> more recently, I'm in a dark pit called 'The City'.
08:35:27 <matthew_-> ahh, with Ross?
08:36:23 <matthew_-> oh, "The" City? Not City Uni?
08:36:28 <quicksilver> "The" City.
08:36:37 <matthew_-> right. With Lennart?
08:36:40 <quicksilver> where the suits live.
08:36:49 <matthew_-> yep. I avoid it well
08:37:10 <matthew_-> good, well I'm glad we got that cleared up...
08:45:50 <Apocalisp> How does liftM2 know to apply f x1 x2 for every x1 in m1 and every x2 in m2?
08:45:58 <idnar> @src liftM2
08:45:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:46:19 <faxathisia> I thinnk thats' becase of th list moand
08:46:21 <faxathisia> monad..
08:46:28 <faxathisia> It would do something else with different monads
08:46:36 <idnar> Apocalisp: it sounds like you're talking about the list monad specifically, in which case the answer is "because that's how the list monad works"
08:46:44 <faxathisia> @src [] Monad
08:46:44 <lambdabot> Source not found. You type like i drive.
08:46:51 <oerjan> another way to write it for lists is with comprehensions:
08:46:52 <faxathisia> @src [] (>>=)
08:46:52 <lambdabot> m >>= k     = foldr ((++) . k) [] m
08:47:01 <idnar> > liftM2 (+) (Just 5) Nothing
08:47:04 <lambdabot>  Nothing
08:47:05 <idnar> > liftM2 (+) (Just 5) (Just 10)
08:47:06 <lambdabot>  Just 15
08:47:08 <oerjan> [f x1 x2 | x1 <- l1, x2 <- l2]
08:47:11 <idnar> > liftM2 (+) [1, 2] [3, 4]
08:47:11 <lambdabot>  [4,5,5,6]
08:47:13 <faxathisia> > [1,2,3,4] >>= id
08:47:14 <lambdabot>   add an instance declaration for (Num [b])
08:47:14 <lambdabot>     In the expression: 4
08:47:24 <Apocalisp> @src [] liftM
08:47:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:47:34 <quicksilver> liftM is uniform
08:47:37 <quicksilver> it's not per-instance
08:47:40 <quicksilver> @src liftM
08:47:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:47:42 <faxathisia> > [1,2,3,4] >>= []
08:47:43 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
08:48:03 <yrlnry> liftM2 (liftM2 (+)) [Just 1, Nothing] [Just 2, Just 4]
08:48:04 <resiak> > [1..4] >>= (:[])
08:48:05 <lambdabot>  [1,2,3,4]
08:48:09 <yrlnry> > liftM2 (liftM2 (+)) [Just 1, Nothing] [Just 2, Just 4]
08:48:10 <lambdabot>  [Just 3,Just 5,Nothing,Nothing]
08:48:13 <oerjan> > [1,2,3,4] >> []
08:48:13 <lambdabot>  []
08:48:14 <yrlnry> Wow.
08:48:52 <resiak> Maybe Data.List should define monster = (:[])
08:48:55 <yrlnry> @ty liftM2
08:49:01 <dons> it's been called 'box' in the past
08:49:04 <faxathisia> > [1,2,3,4] >>= (:[666])
08:49:04 <yrlnry> @t liftM2
08:49:05 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:49:05 <idnar> @pl liftM2 . liftM2
08:49:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:49:10 <lambdabot> liftM2 . liftM2
08:49:10 <lambdabot>  [1,666,2,666,3,666,4,666]
08:49:22 <yrlnry> @type liftM2
08:49:23 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:49:31 <idnar> :t liftM2 . liftM2
08:49:32 <faxathisia> intersperse = butLast . (>>= (:[666]))
08:49:32 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
08:49:34 <yrlnry> @type liftM2 . liftM2
08:49:35 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
08:49:42 <idnar> is there some shortcut for lifting multiple times?
08:49:51 <quicksilver> no
08:49:53 <faxathisia> > (reverse . tail . reverse . (>>= (:[666]))) [1,2,3,4,5]
08:49:54 <lambdabot>  [1,666,2,666,3,666,4,666,5]
08:49:58 <resiak> @pl \f -> (f . f . f)
08:49:58 <lambdabot> ap (.) (join (.))
08:50:01 <resiak> aww
08:50:09 <quicksilver> although sometimes if m is a monad and n is a monad then m n is also a monad
08:50:16 <quicksilver> and then it's liftM2 for the combined monad
08:50:19 <quicksilver> not always, though.
08:50:22 <yrlnry> exponential monads.
08:50:27 <idnar> heh
08:50:32 * Apocalisp is looking for the "every" in in the list monad that tells liftM2 how to do its thing.
08:50:33 <quicksilver> in particular, I don't believe it's true for [] and Maybe, either way around.
08:50:44 <quicksilver> Apocalisp: it's the definition of >>=
08:50:47 <oerjan> @src [] >>=
08:50:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:50:52 <faxathisia> > (reverse . tail . reverse . (>>= (:[666]))) [1,2,3,4,5]
08:50:53 <oerjan> @src [] (>>=)
08:50:53 <lambdabot>  [1,666,2,666,3,666,4,666,5]
08:50:53 <lambdabot> m >>= k     = foldr ((++) . k) [] m
08:50:58 <quicksilver> Apocalisp: which turns out to be concatmap, with args the other way around.
08:50:59 <faxathisia> for example
08:51:17 <faxathisia> (>>=) = flip concatMap??
08:51:18 <faxathisia> :D
08:51:33 <Apocalisp> Oh! It's do notation.
08:52:09 <yrlnry> yeah, list (and monad) comprehensions are syntactic sugar for "do" notation.
08:52:16 <Apocalisp> Alright, sweet. Thanks!
08:52:43 <shapr> @yow !
08:52:44 <lambdabot> Here I am in 53 B.C. and all I want is a dill pickle!!
08:53:02 <faxathisia> @yow
08:53:03 <lambdabot> I was born in a Hostess Cupcake factory before the sexual revolution!
08:53:07 <yrlnry> Me too!
08:53:10 <faxathisia> lol
08:53:17 <faxathisia> hello shapr
08:53:23 <shapr> hiya faxathisia
08:53:29 <shapr> How's code?
08:53:41 <faxathisia> I almost finished something!
08:54:43 <shapr> grr, windows...
08:54:47 <ToRA> random question, that may not even be sensible... if I have a Monad m, and a Monoid x, is it sane/sensible/theoretically ok to try and make a Monoid (m x)?
08:54:53 <shapr> What have you almost finished?
08:55:17 <ToRA> (I have a lot of liftM2s that i want to remove from some hypothetical code i'm writing)
08:55:18 <faxathisia> shapr: an interpreter for Janus, let's you run programs forwards and backwards
08:55:41 <faxathisia> it's a lot of fun, biggest thing I've written in haskell
08:55:58 <Saizan> ToRA: i think so, mempty = return mempty, mappend = liftM2 mappend if that suits your needs
08:56:01 <quicksilver> ToRA: no, not for a general m and x.
08:56:06 <shapr> That's cool, I don't know Janus.
08:56:26 <quicksilver> hmm, oh, I see
08:56:28 <shapr> @users
08:56:28 <lambdabot> Maximum users seen in #haskell: 426, currently: 409 (96.0%), active: 23 (5.6%)
08:56:35 <ToRA> quicksilver: in terms of what haskell typeclasses requre?
08:56:49 <shapr> oh joy, time to reboot windows
08:57:00 <quicksilver> no, what Saizan says is not a monoid
08:57:01 <quicksilver> I don't think.
08:57:02 <ToRA> Saizan: that's what i thought, just dont want to write a load of code for it to trip me up when i have to go and implement the hypothetical monad my code is written to use...
08:57:06 <quicksilver> it won't be associative.
08:57:16 <dons> is anyone working on any fun, new library?
08:57:32 <quicksilver> or..
08:57:50 <Sizur> dons: just done i18n
08:58:05 <ToRA> associative in terms of the "effects" of the monad?
08:58:17 <Sizur> would appreciate help with implementing plural forms
08:58:20 <dons> Sizur: yeah, I saw. i18n is awesome. pity gettext is GPL though
08:58:29 <dons> or i'd be able to use it at work
08:58:34 <resiak> I don't suppose anyone is sitting on bindings for beagle or tracker, are they?
08:58:47 <Sizur> dons: what do you need it to me?
08:58:58 <Sizur> to be
08:59:05 <dons> or BSD-ish would be best.
08:59:31 <dons> that's the default for haskell libs, to enable commercial use (which we want to encourage!)
08:59:39 <Sizur> ok, do they hold a copyright to the .po format?
08:59:53 <dons> for apps, GPL is ok, of course. but for libraries, its harder
09:00:00 <dons> not sure.
09:00:15 <quicksilver> you can't copyright a file format
09:00:24 <faxathisia> @brain
09:00:25 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
09:00:28 <quicksilver> that's fairly nonsensical.
09:00:29 <Sizur> then i will simply change my licence
09:00:34 * resiak .oO(copyright isn't a verb)
09:00:43 <quicksilver> you could copyright a "description" of a file format, I guess.
09:00:57 <resiak> (you mean "hold copyright on"</pedant>)
09:00:59 <dons> Sizur: wonderful!
09:01:00 <quicksilver> ToRA: yes, that's what I meant
09:01:01 <pejo> dons, any idea what netbsd use instead of gettext?
09:01:10 <quicksilver> ToRA: I'm actually not sure if I'm right :)
09:01:19 <dons> pejo: it uses gettext
09:01:20 <Sizur> i want it to be used afterall
09:01:42 <dons> Sizur: that's great. it should fit right in with a suite of haskell web stuff i'm trying to get released.
09:02:01 <Sizur> dons: did you see the implementation?
09:02:08 <dons> i've not had a look at the code yet
09:02:50 <Sizur> it's very simple, but since there was nothing at all yet...
09:03:29 <ToRA> quicksilver: if the Monad is just a reader monad it should be associative?
09:03:50 <Sizur> i will change the license later today, going home now. ttyl all
09:04:50 <quicksilver> ToRA: yes, definitely
09:05:03 <Apocalisp> @type (\f x -> x >>= return . f)
09:05:11 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
09:05:14 <ToRA> quicksilver: cool, cheers
09:05:23 <Apocalisp> @pl (\f x -> x >>= return . f)
09:05:24 <lambdabot> fmap
09:05:26 <Apocalisp> hehe
09:05:36 <faxathisia> :t (>>=) . (return)
09:05:36 <lambdabot> forall (m :: * -> *) b a. (Monad m) => a -> (a -> m b) -> m b
09:05:50 <faxathisia> :t (return) . (>>=)
09:05:50 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => m1 a -> m ((a -> m1 b) -> m1 b)
09:06:06 <Apocalisp> @src fmap
09:06:06 <lambdabot> Source not found.
09:06:12 <Apocalisp> @src [] fmap
09:06:12 <lambdabot> fmap = map
09:06:37 <Apocalisp> har!
09:07:25 <Apocalisp> Why both fmap and liftM ?
09:07:26 <faxathisia> @src ((->)e) fmap
09:07:26 <lambdabot> Source not found. Sorry.
09:07:31 <faxathisia> :L
09:07:43 * BMeph wants to rename "map as "zipWith1"...
09:08:15 <quicksilver> and repeat as zipWith0 ?
09:08:57 <BMeph> Apocalisp: fmap uses a Functor.
09:09:08 <roconnor> Apocalisp: because Haskell's class system is broken :(
09:09:25 <quicksilver> I think in this particular case it's just the prelude that's broken
09:09:50 <faxathisia> Can you write zipWith n ?
09:09:53 <faxathisia> like printf
09:10:17 <quicksilver> yes, you could write it like printf
09:10:26 <quicksilver> applicative is nicer though
09:10:38 <faxathisia> huh ?
09:10:45 <BMeph> faxathasia: It's more fun to use the Applicative version, though.
09:10:48 <faxathisia> I don't see how to use applicative
09:12:10 <BMeph> repeat and (zipWith ($)) are viable definitions for pure (or return if you prefer) and ap.
09:12:43 <quicksilver> not just viable, already defined
09:13:08 <faxathisia> does not understand .. :[
09:13:28 <quicksilver> > getZipList ((+) <$> ZipList [1,2,3] <*> ZipList [4,5,6])
09:13:29 <lambdabot>  [5,7,9]
09:13:35 <BMeph> Which is why I've taken up my campaign to rename map as "zipWith1", since zipWith is actually zipWith2.
09:13:38 <faxathisia> ooooh
09:13:57 <gwern> I forgot, what kind of -morphism is an unfold, does anyone know?
09:13:58 <faxathisia> :t ((+) <$> ZipList [1,2,3] <*> ZipList [4,5,6])
09:13:59 <lambdabot> forall a. (Num a) => ZipList a
09:14:18 <dons> ana-
09:14:19 <BMeph> gwern: Anamorphism.
09:14:36 <gwern> 'k
09:14:37 <dons> catamorphisms are catastrophic, they destroy /fold the data
09:15:24 <Apocalisp> And anamorphisms are... anastrophic?
09:15:27 <cognomore> ...which go to the catacombs
09:15:33 <Apocalisp> anacombs
09:15:33 <mrd> scaredy catamorphism
09:15:35 <gwern> cute mnemonic. i'll have to remember that
09:15:53 <dons> its the only way i ever remember :)
09:16:03 <cognomore> its just playing etymology
09:16:09 <quicksilver> can I play to?
09:16:09 <BMeph> Apocalisp: No, anastatic! ;)
09:16:10 <dons> yep
09:16:12 <quicksilver> what's the prise
09:16:40 <Apocalisp> cataprise
09:17:10 <gwern> 'A paramorphism (from Greek , meaning "close together") is an extension of the concept of catamorphism to deal with a form which eats its argument and keeps it too[1], as exemplified by the factorial function.' <-- what on earth does that mean?
09:17:16 <cognomore> a catalog is a log that has falled down
09:17:34 <gwern> the definition for apomorphism is even worse >.<
09:17:37 <faxathisia> n * f (n-1)
09:17:40 <faxathisia> keep * eat
09:17:44 <faxathisia> I suppse?
09:18:10 <quicksilver> gwern: you apply the function to this level as well as recursing
09:18:17 <quicksilver> gwern: e.g., for lists :
09:18:19 <BMeph> faxathasia: Exactly! :)
09:18:26 <dons> we like giving names to our loops :)
09:18:42 <quicksilver> para f (x:xs) = f (x:xs) x (para xs)
09:18:52 <quicksilver> gwern: it gets the whole list, the head, and the recursive call
09:18:54 <faxathisia> I wonder if there is something like, a quickref for all these types of thing?
09:18:57 <quicksilver> para f (x:xs) = f (x:xs) x (para f xs)
09:18:59 <quicksilver> I should say
09:19:21 <opqdonut> quicksilver: want to define something with para?
09:19:30 <opqdonut> the factorial for example
09:19:37 <opqdonut> (or is that a paramorphism)
09:19:43 <BMeph> hylo f (x:xs) = (f x) : (hylo xs)
09:19:44 <quicksilver> opqdonut: is that a particularly oblique way of saying I got it wrong?
09:19:45 <quicksilver> ;)
09:19:59 <ndm> Uniplate has a para function, and the paper has an example
09:20:00 <gwern> so it's when on the right side you find one of the arguments unaltered as well as an altered form of it?
09:20:02 <opqdonut> no, just wondering :)
09:20:16 <quicksilver> well, for nat, para is:
09:20:26 <quicksilver> para f n = f n (para f (n-1))
09:20:30 <opqdonut> para over nat is primitive recursion right?
09:20:38 <opqdonut> no, not really
09:20:47 <quicksilver> so factorial is almost para (*)
09:20:55 <quicksilver> but you have to be careful about the base case :)
09:21:02 <opqdonut> mhmm
09:21:10 <ddarius> quicksilver you have it right
09:21:10 <quicksilver> a proper para for Nat takes another parameter for "what to do in base case"
09:21:22 <quicksilver> as my example for lists really needs one for "what to do with empty list"
09:21:36 <faxathisia> hmmm
09:21:55 <quicksilver> so para f z n = if n == 0 then z else f n (para f z (n-1))
09:21:58 <faxathisia> Is it necesary the type you have is Unit and Unit -> Unit... e.g. [] and :, or 0 and 1+
09:22:09 <faxathisia> I don't know if there is a name of that kind of data type.?
09:22:10 <quicksilver> and with that second definition, I think factorial = para (*) 1
09:22:12 <idnar> > let para f n = f n (para f (n-1)) in para (*) 5
09:22:20 <ddarius> > let paraNat s z 0 = z; paraNat s z n = s n (paraNat s z (n-1)) in paraNat (*) 1 5
09:22:23 <idnar> oh, oops
09:22:26 <idnar> infinite recursion
09:22:26 <lambdabot>  120
09:22:27 <lambdabot>  Exception: stack overflow
09:22:41 <quicksilver> > let para f z n = if n == 0 then z else f n (para f z (n-1)) in para (*) 1 5
09:22:42 <lambdabot>  120
09:22:45 <quicksilver> yeah
09:22:48 <opqdonut> faxathisia: ??
09:22:52 <quicksilver> I did get it right! \o/
09:23:15 <opqdonut> faxathisia: ah, for catamorphisms
09:23:19 <quicksilver> for lists, including base case:
09:23:21 <faxathisia> opqdonut: The para thing is working on nat (0, 1+) or lists ([], (\x -> (x:)))
09:23:33 <opqdonut> no, i guess you could have for example trees
09:23:38 <opqdonut> but then f would take more arguments
09:23:42 <opqdonut> right?
09:23:58 <quicksilver> para f e [] = e; para f e (x:xs) = f x (x:xs) (para f e xs)
09:23:59 <quicksilver> I think
09:24:14 <opqdonut> something like: para f (Tree l r) = f n (para f l) (para f r)
09:24:14 <quicksilver> opqdonut: yes, as many arguments as tehre are constructors in the type
09:24:18 <opqdonut> yep
09:24:24 <BMeph> quicksilver: You got it. :)
09:24:27 <ddarius> quicksilver: Yes (though the order of the arguments would "usually" be different
09:24:31 <ddarius> (in my opinion)
09:24:34 <dons> can someone who's got unicode working reply to "[Haskell-cafe] Problems with Unicode Symbols as Infix Function Names"
09:24:46 <dons> unicode is a real faq suddenly
09:24:56 <ddarius> In Recursion Schemes from Comonads, a paramorphism is induced from the state-in-context comonad if I remember correctly.
09:27:52 <BMeph> I liked the "Bananas, Envelopes..." explanations, even though I need a few more lessons in maths before tackling CT.
09:29:05 <ddarius> BMeph: There is very little CT used in those and they don't assume prior knowledge.
09:30:11 <BMeph> ddarius: So YOU say! For some reason, though, the triangle for the list structure kept confusing me.
09:31:11 <ToRA> dons: replying in 2 seconds
09:31:36 <quicksilver> BMeph: release your inner (zapf) dingbat! open your mind to the use of nice non-ascii symbols!
09:31:43 <ddarius> BMeph: "triangle for the list structure"?
09:32:08 <faxathisia> unicode is nice but... without mixfix I don't know if it's so great
09:32:16 <quicksilver> BMeph: I often dreamt of publishing a paper which used, for example, a multicoloured SVG christmas tree as a symbol.
09:32:17 <ddarius> BMeph: The upside-down and right-side up triangles used for pairing and sums?
09:32:33 <quicksilver> let <christmas tree> denote a Q-algebra, and...
09:32:46 <faxathisia> lol
09:33:35 <ddarius> @google the dual of substitution is redecoration
09:33:37 <lambdabot> http://citeseer.ist.psu.edu/510658.html
09:33:37 <lambdabot> Title: The Dual of Substitution is Redecoration - Uustalu, Vene (ResearchIndex)
09:33:40 <ddarius> quicksilver: There you go.
09:33:43 <BMeph> ddarius: Yes, that.
09:34:20 <ddarius> BMeph: Yes, this supports my point.  That stuff isn't what categorists normally use, or at least not that syntax.
09:34:36 <ddarius> The syntax of that paper is rather bizarre even beyond the "bananas and barbed wire"
09:34:38 <BMeph> I haven't done any more algebra since what I needed for Vector Calculus...about twenty years ago.
09:36:12 <ddarius> The more common notation for the up and down triangle in that paper is <f,g> and [f,g]
09:36:42 <ddarius> || is almost always x and | +
09:37:29 <quicksilver> sometimes bizarre syntax is chosen to deliberately try to break preconceptions.
09:37:41 <quicksilver> sometimes it's just chosen for fun or bloodymindness though :)
09:38:15 <ddarius> quicksilver: In this case the former is certainly not the case.
09:40:48 <BMeph> Maybe that's what was so confusing. Sometimes they used x and +, and sometimes | and ||.
09:47:19 <fadec> Is there a way to do this? [IO String] -> IO [String]
09:47:28 <dcoutts> @hoogle [IO String] -> IO [String]
09:47:29 <opqdonut> :t sequence
09:47:29 <lambdabot> No matches, try a more general search
09:47:29 <faxathisia> @hoogle [IO String] -> IO [String]
09:47:30 <lambdabot> No matches, try a more general search
09:47:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:47:31 <faxathisia> :t seq
09:47:32 <BMeph> Then again, maybe they don't even use + and X in that one (re-reading it, I haven't seen them yet)...
09:47:32 <lambdabot> forall a t. a -> t -> t
09:47:34 <Botje> yes, sequence
09:47:36 <faxathisia> hm...
09:47:51 <faxathisia> @src seq
09:47:51 <lambdabot> Source not found. You untyped fool!
09:48:04 <BMeph> fadec: Yes, that's the "sequence" function.
09:48:40 <BMeph> fadec: Well, It's "sequence" specifically for the IO monad.
09:48:48 <dcoutts> @tell ndm test case for hoogle 4: [IO String] -> IO [String] should find sequence :: Monad m => [m a] -> m [a]
09:48:49 <lambdabot> Consider it noted.
09:49:01 <desegnis> @hoogle [m a] -> m [a]
09:49:02 <lambdabot> Prelude.head :: [a] -> a
09:49:02 <lambdabot> Prelude.last :: [a] -> a
09:49:02 <lambdabot> Data.List.head :: [a] -> a
09:49:11 <fadec> Makes some sense. I have a list of filenames and I want to read them all intro strings - not IO String. Thanks guys.
09:49:26 <desegnis> Hoogle doesn't like me, never :)
09:49:27 <faxathisia> :t mplus
09:49:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
09:49:34 <faxathisia> :t msum
09:49:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:49:41 <faxathisia> oh .. right
09:49:54 <faxathisia> I think I use msum sometimes when I should use sequence..
09:51:34 <litb> haskell for nice source , ocaml for fast bins
09:51:38 <litb> is that right?
09:52:05 <BMeph> Is OCaml that much faster than Haskell?
09:52:12 <ddarius> litb: The difference in speed between Haskell and O'Caml is not significant.
09:52:29 <Apocalisp> Now... I want the effect of liftM2 (*) a b, but I want them ordered a0, b0, a1, b1 rather than a0, a1... b0, b1
09:52:32 <faxathisia> the same algorithm might be fsater in haskell
09:52:36 <faxathisia> because of lazyness I think ?
09:52:41 <faxathisia> like isInfixOf ?
09:52:59 <faxathisia> You'd have to write it differently in Ocaml wouldn't you
09:53:18 <litb> i read that OCaml is nearly as fast as c++ is
09:53:46 <ddarius> Haskell can be made nearly as fast as C++ too oftentimes
09:54:01 <Apocalisp> ddarius: Faster, sometimes. ;-)
09:54:09 <mrd> C++ can be very slow, when your program terminates with signal 11
09:55:34 <fadec> Check out Clean for speed. It uses uniqueness typing for IO and I think that's the reason for it's speed. Otherwise it's like haskell.
09:55:56 <idnar> Apocalisp: zipWith (*) a b?
09:56:31 <litb> i see.. is ghc considered to be a good choice?
09:56:41 <nelhage> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=ocaml&lang2=ghc
09:56:42 <lambdabot> Title: OCaml benchmarks | Debian : AMD&#8482; Sempron&#8482; Computer Language Benchmar ..., http://tinyurl.com/38wpzd
09:56:49 <faxathisia> litb: I like ghc
09:57:41 <fadec> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=ocaml&lang2=clean
09:57:42 <lambdabot> Title: OCaml benchmarks | Debian : AMD&#8482; Sempron&#8482; Computer Language Benchmar ..., http://tinyurl.com/3a3856
09:57:52 <fadec> ocaml vs clean
10:01:00 <Apocalisp> idnar: I still want the cartesian product, but I want the two lists traversed simultaneously. I.e. [1*1, 1*2, 2*2, 2*3...] instead of [1*1, 1*2, 1*3,... 2*1, 2*2]
10:01:19 <ddarius> fadec: Uniqueness types are part of it, but not because they are used for IO.
10:01:20 <faxathisia> Apocalisp: You want to traverse them diagonally?
10:01:29 <faxathisia> like so that you'd still go though them all i they are infinite length?
10:01:35 <idnar> Apocalisp: where does 2 * 1 come in that list?
10:02:16 <Apocalisp> idnar: Good question. I don't really want it.
10:02:48 <fadec> ddarius: Is it because they are essentially a hand optimization of the GC where with Haskell we depend on GHC to use monadic regions?
10:03:09 <fadec> Just a hunch
10:05:43 <faxathisia> > cycle ['a'..'z']
10:05:45 <lambdabot>  "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw...
10:06:30 <BMeph> I've also heard that Clean's compiler is specialized to a higher degree than GHC's, although it (GHC) is coming along.
10:10:17 <BMeph> Would someone refresh my memory: only type construction operators can start with a ':', correct?
10:10:40 <faxathisia> yes infix constructors
10:10:45 <faxathisia> e.g cons
10:11:42 <litb> sorry, can't answer. i'm going out now. btw, seeing you at ICFP :P
10:12:00 <gio123> may i convert haskell code to prolog?
10:12:15 <BMeph> gio123: Yes, I give you my permission. ;)
10:12:20 <koeien> i want to create a function f, such that, informally, f [f1, f2, ..., fn] = f1. f2 . ... . fn
10:12:31 <gio123> <BMeph>  i need translator ;)
10:12:32 <koeien> of course f = foldr (.) id
10:12:42 <koeien> but i want it more generic, with heteregenous lists
10:13:02 <pejo> gio123, translating between any two languages is difficult, and last time you wanted to make performance comparisons between languages, which isn't really suitable for automatically translated code.
10:13:10 <koeien> would it be possible to create instances like Composable HNil a a  and such?
10:13:58 <gio123> pejo: currently what i want is, i have haskell program and would like to convert it to prolog
10:14:45 <Saizan> koeien: i think that may work, but what's the use case?
10:14:48 <gio123> faxathisia: since u know prolog and haskell both, do u  know is it possible?
10:15:29 <koeien> Saizan: just playing around with the type system, not really anything welse
10:15:35 <koeien> else*
10:16:20 <ohnoes> koeien: maybe use a list of type [forall a b. a->b] as an argument? I could be wrong here
10:16:46 <hpaste>  Apocalisp pasted "Can this be generalized?" at http://hpaste.org/4886
10:16:54 <Saizan> ohnoes: that can only be a list of bottoms
10:16:58 <koeien> ohnoes: how would that work?
10:16:59 <FunctorSalad> ohnoes was me ;)
10:17:13 <FunctorSalad> Saizan: oh right, of course they must be composable
10:17:45 <chadz> Apocalisp: zipWith ?
10:18:09 <Apocalisp> *Main> zipWith (*) [1..9] [1..9]
10:18:09 <Apocalisp> [1,4,9,16,25,36,49,64,81]
10:18:16 <Apocalisp> *Main> myZip (*) [1..9] [1..9]
10:18:16 <Apocalisp> [1,2,4,6,9,12,16,20,25,30,36,42,49,56,64,72,81]
10:18:27 <chadz> oh
10:18:52 <koeien> Apocalisp: isn't myZip' f = flip (myZip (flip f))
10:19:06 <Apocalisp> oh yeah!
10:19:15 <koeien> (didn't check though)
10:19:58 <ptolomy> Is it surprising that when looking at GHC Core, unboxed int arguments seem to be listed as 'L'? (lazy)
10:21:11 <Apocalisp> koeien: You're totally right
10:21:55 <FunctorSalad> koeien: or something like this: data List dom cod = Nil | Cons (a -> cod) (List (dom -> a))
10:22:11 <FunctorSalad> but I'm not sure what is a here :)
10:22:19 <FunctorSalad> would that parse?
10:22:30 <Saizan> you need to add forall a.
10:22:37 <FunctorSalad> yeah, but where?
10:23:07 * ptolomy is getting stack overflows in his virtual machine, which really just recursively pattern matches over a relatively small set of bytecodes, updates a IOUArray Int Int, then calls itself. I've strictified pretty much everything, and still I get overflows. :-/
10:23:08 <Saizan> data List dom cod = forall a. Nil | Cons (a -> cod) (List dom a)
10:23:21 <Saizan> mmh no
10:23:43 <Saizan> data List dom cod = Nil | forall a. Cons (a -> cod) (List dom a) and you need -fglasgow-exts
10:23:59 <roconnor> doesn't strictifying things cause more stack overflows?
10:24:05 <desegnis> FunctorSalad: With GADT syntax it should be easier to figure out where to put the forall
10:24:20 <FunctorSalad> desegnis: good point
10:24:32 <koeien> hmm i'll try that, i'm not that familiar with GADT's, should be a good exercise
10:24:42 <desegnis> and since we're using extensions anyway... ;)
10:24:57 <ptolomy> Well, I'm dealing with a relatively small set of finite data and doing IO in pretty much every op.. I'd think that laziness wouldn't do anything but eat space for me.
10:25:17 <koeien> yes those are probably needed (multiparameter type classes or this forall-stuff)
10:28:20 <desegnis> You may of course question what is the point of writing Cons instead of (.), but the important thing is that it works
10:28:30 <Saizan> i wonder what would be the right type for Nil, i'd say Nil :: List a a, but maybe there's a need for List a b?
10:28:39 <desegnis> yea
10:28:44 <desegnis> or List dom cod
10:29:49 <Saizan> well the name of the variables doesn't matter
10:32:25 <Saizan> however you're quite limited in manipulating these lists
10:32:26 <FunctorSalad> hmm something's still wrong
10:32:57 <FunctorSalad> the domain will always be undefined I think
10:36:03 * ptolomy considers using mallocArray and peek/poke instead of IOUArray
10:37:20 <Saizan> i'm convinced that Nil should have the type of id
10:38:25 <dons> ptolomy: or STUArray?
10:38:52 <dons> ptolomy: the performance should be identical, but i have observed one program, using lots of unboxwed Doubles, that was faster with  FFI arrays
10:39:31 <ptolomy> dons: Hm. Well, I'm dealing with unboxed ints only, so it's probably not worth the danger. Thanks.
10:39:53 <Storm> hello everybody
10:39:58 <dons> i'd go with STUArray, personally
10:40:12 <dons> they're much fun, and you have the option to purify the  result
10:40:23 <Storm> i want to try and build a irc bot but have no clue where to start
10:40:38 <Valodim_> so read a tutorial about it
10:40:43 <dons> Storm: how about one of the Haskell irc bot tutorials?
10:40:45 <ptolomy> dons: well, my inner loop requires IO as it is.. I figured the overhead (conceptual/effort, if not performance) wouldn't be worth it.
10:40:51 <dons> ?go roll your own irc bot
10:40:53 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:40:53 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
10:40:56 <dons> that one is good :)
10:41:02 <Storm> ok thanx
10:41:08 <dons> ptolomy: well, IO/ST are the same for arrays
10:41:22 <dons> but there's no huge difference
10:43:33 <sjanssen> @src IOUArray
10:43:33 <lambdabot> Source not found. Maybe you made a typo?
10:47:45 <ptolomy> dons: Does the bytestring release for GHC 6.8 have the fix for the 'memcmp is called every time we want to compare two bytestrings' thing?
10:48:16 <dcoutts> ptolomy: what problem was that? I'm not familiar with it
10:48:17 <dons> hmm?
10:48:48 <dcoutts> ptolomy: as far as I remember we've used the pointer comparison shortcut for ever
10:48:54 <dons> right
10:49:34 <hpaste>  FunctorSalad pasted "List of composable functions" at http://hpaste.org/4887
10:49:44 <ptolomy> I remember there being talk on the libraries list about how short bytestrings are inefficient because the overhead for calling memcmp outweighs the benefit.
10:49:47 <ptolomy> Or I could be completely delusional.
10:50:08 <dcoutts> ptolomy: oh, that may be the case
10:50:17 <dcoutts> but it'd need careful measurement to confirm
10:50:29 <FunctorSalad> Saizan: it works with (Nil a a), with (Nil a b) the compose function wouldn't work I think
10:50:35 <dons> yes, that's still the case
10:50:47 <dcoutts> since memcmp implements it's own checks for short strings so the overhead is probably only the function call which is pretty minimal
10:50:51 * ptolomy asks because he has more than one program whose speed is pretty much directly proportional to the cost of ByteString Map lookups.
10:50:58 <dons> there's some length threshold (20 chars or so ??) where the ffi call costs is offset by the speed increase
10:51:11 <dcoutts> ptolomy: perhaps you should be hashing
10:51:26 <desegnis> FunctorSalad: Now I'm back from dinner, I see that too
10:51:35 <dcoutts> dons: is there? are there any measurements to confirm that?
10:51:51 <FunctorSalad> desegnis: I agree this look pretty useless though (equivalent to (.))
10:51:51 <dons> we did some numbers last year, i think ChrisK did it
10:52:04 <dons> we'd need to look at it again, (since haskell's faster now)
10:52:52 <dcoutts> dons: it's be an interesting benchmark to add to the bytestring repo, a program we can run to test the current threshold
10:53:01 <ptolomy> I probably should be hashing, but I seem to recall that Data.Hashtable is no speed demon, and it requires IO. Data.Map is just so much nicer. Maybe I'll need to restart my quickly abandoned project to make a fast HashTable that can be used with ST and doesn't require IO for lookups.
10:53:16 <gio123> is somebody familier about: Subtyping among Regular expressions
10:53:22 <dcoutts> ptolomy: I don't mean Data.Hashtable, you could use Data.IntMap
10:53:23 <dons> dcoutts: yeah. i'll put this in the TODO
10:53:35 <ptolomy> dcoutts: Oh. True.
10:53:43 <dcoutts> ptolomy: there's no need for it to be mutable
10:53:52 <dcoutts> an IntMap is pretty quick
10:53:56 * ptolomy goes off to test ByteString hash functions.
10:53:58 <dcoutts> or of course there are Tries
10:54:09 <FunctorSalad> desegnis: well, there is a use. it remembers its component functions, could be used for reflection (but then the functions should prolly be showable or something)
10:54:19 <dcoutts> ptolomy: tries are probably fastest for string maps
10:54:30 <dons> probably a lot faster :)
10:54:55 <dons> the high-perf hashtables in the shootout were all blown away by an (illegal :(  haskell trie version
10:54:57 <desegnis> FunctorSalad: Alas, you don't even know the types of the component functions
10:55:06 <ptolomy> Wasn't there a plan to put Tries in the standard library at some point?
10:55:14 <dcoutts> ptolomy: I'd hope so
10:55:21 <dons> yes. we need a data structure task force
10:55:24 <FunctorSalad> desegnis: not? well, at least ":t" knows them
10:55:39 <FunctorSalad> or wait, I don't have a "head" function
10:55:44 <dons> getting the edison maps and tries into a releasable state should be a 2008 result
10:56:34 <FunctorSalad> I see, "head" would have to return something with unknown domain
10:56:52 <desegnis> FunctorSalad, yeah, you only know the outer type. But you can count the component functions at least :)
10:57:14 <chadz> what's the name of the automatic hackage utility? iirc, one was sortof in development
10:57:23 <dons> which one?
10:57:27 <dons> cabal install ?
10:57:27 <nelhage> cabal-install?
10:57:37 <dons> it'd be cabal-install you're seeking, yeah
10:57:38 <dcoutts> @where cabal-install
10:57:38 <lambdabot> I know nothing about cabal-install.
10:57:41 <dcoutts> bah
10:57:42 <chadz> that one, i suppose. anyone use it?
10:57:44 <dons> yes!
10:57:47 <dcoutts> chadz: yep
10:58:04 <dons> its a becoming a piece of infrastructure at my workplace
10:58:05 <chadz> i get pretty sad when I have update 12 directories for each new xmonad release :)
10:58:09 <dons> right.
10:58:16 <dcoutts> chadz: though the latest and greatest version requires the darcs version of Cabal too
10:58:19 <dons> i've even got instructions for using cabal-install with xmonad
10:58:29 <chadz> dons: on the xmonad page?
10:58:34 <nelhage> I'm running a cabal-install'd xmonad here
10:58:44 <dcoutts> dons: are you using the cabal-install bash command line completion yet? :-)
10:58:54 <dons> http://xmonad.org/intro.html#cabal-install
10:58:55 <lambdabot> Title: xmonad : building and installation
10:59:03 <dons> dcoutts: no, but that sounds awesome
10:59:14 <dcoutts> dons: it's in the cabal-install repo already
10:59:22 <dons> dcoutts: we should think about ICFP/HW papers sometime soon, too. :)
10:59:41 <dcoutts> dons: I'm not sure what the technical contribution is
10:59:45 <chadz> or worry about releasing a windows client :)
10:59:49 <dons> dcoutts: for what?
10:59:55 <dcoutts> chadz: it works on windows too (mostly)
11:00:06 <dcoutts> dons: oh, you mean more generally
11:00:09 <dons> yeah.
11:00:11 <chadz> dcoutts: oh, my fault. I mean for xmonad :D
11:00:17 <dcoutts> dons: right, well jfp first
11:00:26 <dons> chadz: if you follow those xmonad.org instructions, can you let me know if anything goes wrong
11:00:29 <dons> dcoutts: yep.
11:00:54 <chadz> dons: i'll let you know when I do.
11:00:54 <dons> i think it really is time we tried to write up Data.Binary, too
11:01:05 <chadz> is binary still in v3?
11:01:18 <dcoutts> dons: yes, there's that, and there's been plenty more feedback on what people want from a binary lib
11:01:20 <dons> binary-0.4.1
11:01:36 <dons> right. i think we've got some interesting use cases to ponder
11:01:38 <bos> you think binary would be worth writing up?
11:01:52 <dcoutts> bos: if done well, yes.
11:02:03 <dons> bos, yeah, as a 10-year sequel to 'The Bits Between the Lambdas"
11:02:08 <bos> heh.
11:02:10 <dons> or like the erlang bitstream series of papers
11:02:16 <nelhage> Is anyone going around urging everyone who's written a random haskell package that's floating around on the internet to upload it to hackage?
11:02:24 <chadz> my binary-using application was pretty muddy :)
11:02:26 <dons> but faster :) and with rewrite rules and applicative functors
11:02:37 <dons> nelhage: me.
11:02:40 <nelhage> Because it still seems like google is a better way to find haskell bindings for $FOO than hackage for a lot of $FOO
11:02:44 <dcoutts> nelhage: lots of us, yes
11:02:45 <dons> nelhage: hmm. really?
11:02:54 <dons> i never google first anymore
11:03:02 <chadz> well, the sorting for hackage isn't very optimal
11:03:03 <dcoutts> nelhage: I was under the impression most stuff was on hackage now
11:03:05 <chadz> keywords might be nice?
11:03:08 <profmakx> i always look at hackage first
11:03:08 <gwern> @pl (\x -> runStmt ses x SingleStep)
11:03:09 <lambdabot> flip (runStmt ses) SingleStep
11:03:10 <dons> nelhage: are you thinking more like, we should email people ?
11:03:31 <dcoutts> chadz: certainly a better search interface would be good
11:03:41 <dons> i suppose i could set up a script to google for haskell .tar.gz bundles, firing off a 'please upload to hackage' mail to the author, until no more hits match :)
11:03:54 <dcoutts> chadz: cabal list does a search btw :-)
11:04:05 <dcoutts> I typically load the packages page and use the text search in my browser
11:04:08 <nelhage> Possibly. Like, recently I've been looking for haskell libs for e.g. xmpp, and found them on google but not hackage
11:04:11 <dcoutts> or use cabal list
11:04:25 <chadz> dcoutts: oh, how I must play with cabal. typically, I hate it, but that might just turn around.
11:04:36 <nelhage> (http://www.dtek.chalmers.se/~henoch/text/hsxmpp.html)
11:04:44 <lambdabot> Title: XMPP
11:04:45 <chadz> I always have to hack in extra-lib directories due to lack of modern libs on this work machine.
11:04:46 <dcoutts> chadz: remember to file bugs about the bits you hate :-)
11:04:52 <dons> oh, if there at chalmers we can get the big guns out
11:05:00 <dons> chalmers guys have no excuse for not uploading :)
11:05:02 <nelhage> hsgnutls also appears to not be on hackage (http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/)
11:05:08 <lambdabot> Title: hsgnutls
11:05:14 <dons> ok. and musasabi's stuff
11:05:34 <dcoutts> nelhage: but is it still maintained? there are lots of dead projects via google that are not on hackage
11:05:34 <dons> nelhage: feel free to start a wiki page for non-hacakged libs of note
11:05:40 <dons> i'll be happy to chase things up
11:05:40 <dcoutts> we've got one...
11:05:43 * dcoutts finds it
11:05:52 <nelhage> dcoutts: No clue
11:05:53 <dons> the QtHaskell guy really needs to move to hackage too. i'm not sure why he likes sourceforge :/
11:06:03 <chadz> has anyone played with qthaskell?
11:06:11 <dons> yeah, the danger of google is that it finds mostly bitrotted code
11:06:13 <dcoutts> nelhage: http://hackage.haskell.org/trac/hackage/wiki/CabalPackages
11:06:15 <lambdabot> Title: CabalPackages - Hackage - Trac
11:06:17 <gio123> is somebody familier about: Subtyping among Regular expressions
11:06:37 <Sizur> what's up with this: Parse of field 'license' failed:
11:06:43 <dons> gio123: i've not heard of anything in that area. nor type systems for regexes either...
11:06:51 <dons> Sizur: old version of cabal?
11:06:52 <dcoutts> Sizur: it's not one of the Licence enum values
11:07:05 <Valodim_> what is "bitrotten"?
11:07:11 <Valodim_> or bitrotted, whatever
11:07:11 <dons> Valodim_: out of date/broken
11:07:16 <dcoutts> Valodim_: "doesn't work any more"
11:07:16 <Valodim_> ah
11:07:34 <dons> bit rotted is a misnomer. its more that the bits are in stasis
11:07:35 <Sizur> what's this, i cannot use the original BSD?
11:07:41 <roconnor> doesn't work any more even though / because it hasn't changed.
11:07:42 <dons> while the environment around them has evolved
11:07:52 <dons> so they don't really rot, they just become obsolete bits
11:07:58 <dons> :)
11:08:08 <Valodim> ah
11:08:11 <Valodim> makes sense :)
11:08:25 <nelhage> I've always interpreted `bitrot' as intentionally ironic
11:08:54 <dcoutts> Sizur: the old BSD licence is the 4-clause one, so you want BSD4
11:09:08 <dcoutts> the new one without the advertising clause is BSD3
11:09:19 <dcoutts> somewhat confusing I guess, it's not a version number
11:09:55 <Sizur> their template doesn't state the version http://www.opensource.org/licenses/bsd-license.php
11:09:58 <lambdabot> Title: Open Source Initiative OSI - The BSD License:Licensing | Open Source Initiative
11:10:03 <Sizur> i see
11:10:07 <dcoutts> it's not versioned
11:10:13 <Sizur> the number is the number of clauses
11:10:25 <Igloo> dcoutts: I think BSD4 should be removed. I doubt any Haskell code uses it, and it'll just cause confusion
11:10:32 <dcoutts> Sizur: what you see there is the 3 clause version
11:10:41 <dcoutts> Igloo: aye, perhaps
11:10:46 <dcoutts> Igloo: file a bug
11:11:11 <syscrash> if i call an external program using 'system', i get something of type IO ExitCode. how do I get the string containing the command's output? for example, if i do 'let p = system("ls")', and then type 'p', it shows me the output of the command on one line, and ExitSuccess on another line. how do I get the output of the command as a string?
11:12:02 <dcoutts> it's unfortunately not that easy :-( there's code in Cabal to do it
11:12:38 <sjanssen> syscrash: the monads are confusing you
11:13:01 <dons> syscrash: using System.Process or one of its wrappers, not 'system'
11:13:02 <syscrash> certainly, since i don't really know haskell at this point :P
11:13:10 <syscrash> aha, i'll look into that, thanks
11:13:16 <sjanssen> 'let p = system("ls")' means bind 'p' to a *computation* that calls system
11:13:24 <syscrash> ah!
11:13:32 <dons> e.g. http://www.cse.unsw.edu.au/~dons/code/newpopen/System/Process/Run.hs
11:13:34 <lambdabot> http://tinyurl.com/2f7j8l
11:13:39 <syscrash> 'x <- p' would actually carry out the computation??
11:13:40 <dons> which i should really release.
11:13:45 <sjanssen> instead, you want something like "p <- system ..."
11:14:05 <sjanssen> also, you need to use another function because vanilla 'system' doesn't return the output as a string ;)
11:14:41 <monochrom> evaluate (length output) is sad.
11:14:45 <syscrash> dons' thing seems like what i want! thanks
11:14:57 <syscrash> and i'll work on my understanding of monads
11:15:48 <dons> if anyone, sjanssen, bos, dcoutts ... has any feedback on the popen interface, i'd welcome that. i'll probably toss it onto hackage in the next couple of days,
11:15:53 <dons> http://www.cse.unsw.edu.au/~dons/code/newpopen/
11:15:54 <lambdabot> Title: Index of /~dons/code/newpopen
11:15:59 <chadz> isn't there that hsh lib, haskell shell or what not.
11:16:04 <chadz> there's a popen interface now?
11:16:07 <chadz> ahh
11:16:29 <dons> there was an old unix popen one
11:16:40 <dons> and the above is a portable version with a similar interface
11:16:58 <dcoutts> dons: why not return the ExitCode and the String ?
11:17:16 <bos> dons: it's a bit weird that you can get output or exit code, but not both
11:17:18 <tibbe> dons, argh! I want Firefox to display the code inline!
11:17:26 <dons> yeah, bos/dcoutts
11:17:31 <bos> tibbe: it does for me
11:17:31 <Sizur> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/i18n-0.2
11:17:32 <lambdabot> http://tinyurl.com/2pvdee
11:17:34 <monochrom> If you get the String case, it is only because of one known definite exitcode.
11:17:34 <dcoutts> dons: and in Cabal we use a version that throws the ExitCode as an exception if it's non-0 which is very useful most of the time, though we also provide the raw version as that's needed occasionally
11:17:43 <bos> dcoutts++
11:17:44 <Sizur> dons: i would love to hear your critique
11:17:56 <dons> throwing an exception feels maybe wrong.
11:18:07 <tibbe> bos: I guess it depends on the server's mime type, works in this case
11:18:15 <dons> depends how defensive we want to be
11:18:22 <bos> it's often very useful.
11:18:25 <dcoutts> dons: see http://darcs.haskell.org/cabal/Distribution/Simple/Utils.hs
11:18:41 <dcoutts> dons: rawSystemStdout and rawSystemStdout'
11:18:43 <monochrom> The haddock can say something more specific than "returns exitcode or string".
11:18:48 <bos> as in, you have something in the bowels of your code that just has to work, and you don't want to fap with Either just so you can throw an exception yourself.
11:19:51 <dons> i think originally i noticed every use i had for popen was wrapped in catch/handle
11:20:07 <dcoutts> dons: we converted in Cabal to using exceptions as the default since there were far to many cases where ExitCodes were getting ignored
11:20:23 <chadz> woo, cabal works :)
11:20:27 <bos> i like that observation.
11:20:38 <bos> matches my own experience.
11:20:46 <dons> dcoutts: right. so either exceptions, or Left/Right. or are you saying people just match the Right case?
11:20:50 <dcoutts> dons: now we just call stuff and don't worry and catch stuff at the top level and only very occasionally have to use local try
11:20:52 <bos> someone found a bug in code of mine just today that ignored exit codes, in fact.
11:21:15 <dons> yeah, so Left/Right only works if we expect the burden of checking to be light
11:21:25 <dcoutts> dons: I suggest the default should return IO String and provide IO (String, ExitCode) as an alternative
11:21:33 <dons> yeah.
11:21:37 * bos agrees with dcoutts
11:21:38 <monochrom> Instead of bikeshed colouring between IO (Either x y) and IO y + Exception x, an isomorphism between the two should be given. Then any user can convert any side to the other as needed.
11:21:49 <dons> i think both seem reasonable. for different safety cases
11:21:58 <dons> a lot of uses will be scripting jobs
11:22:03 <dons> so IO String seems best there
11:22:12 <bos> monochrom: no, the contention is that the Either case is not actually useful.
11:22:42 <monochrom> Why is it not actually useful? dons just said he found it useful.
11:23:00 <roconnor> monochrom: how do we feel about bottoms in there?
11:23:01 <dcoutts> dons: make it clear in the docs that it runs the process 'til it terninates, so you cannot communicate with it concurrently
11:23:13 <dons> yep
11:23:22 <chadz> dons: hmm, after installing cabal-install, it only appears to like working from within the src directory due to the dist/ directory. otherwise, it yells "cabal: dist/Conftest.c: openFile: does not exist (No such file or directory"
11:23:28 <chadz> this isn't regular, is it?
11:23:44 <monochrom> roconnor: I assumed some strictness.
11:23:48 <bos> monochrom: it falsely separates getting output from getting the exit status.
11:24:14 <dcoutts> chadz: you're using cabal-install from hackage or the latest darcs version?
11:24:21 <FunctorSalad> hope this is on-topic here... what is "haskell-mode-menu" in haskell-mode?
11:24:26 <dcoutts> chadz: the hackage version still has that bug you describe
11:24:27 <sjanssen> shouldn't the return be (ExitCode, String)?
11:24:47 <chadz> dcoutts: yah, hackage. i'm following don's tut per his request.
11:24:50 <monochrom> It truely separates (success /\ output) from (failure /\ reason)
11:25:08 <chadz> cabal-install-0.4.0
11:25:22 <bos> monochrom: the point being that that isn't actually helpful. you often want to capture the output of a failed command.
11:25:35 <monochrom> OK I see. Sorry.
11:25:40 <dcoutts> chadz: ok, well just so you know, that bug and many more are fixed in the darcs version which you can use if you like
11:25:41 <yrlnry> Where "failure" means "non-zero exit status"?
11:25:42 <dons> sjanssen: yeah
11:26:09 <chadz> dcoutts: k
11:26:09 <sjanssen> and what about stderr?
11:26:17 <monochrom> "Instead of bikeshed colouring between IO (Either x y) and IO y + Exception x, an isomorphism between the two should be given. Then any user can convert any side to the other as needed."  <--- I said that not just for Run.hs. It is useful for all IO actions.
11:26:37 <chadz> dons: might want to update your page to include directions for darcs cabal-install :)
11:26:55 <hpaste>  sclv annotated "Can this be generalized?" with "(no title)" at http://hpaste.org/4886#a1
11:26:56 <murr^^> what large haskell programs would you recommend for a newbie to check out? Which ones have the most beautiful, readable code, plenty of documentation? ghc, xmonad, darcs, others?
11:27:00 <dons> chadz: can you send me a diff?
11:27:00 <chadz> @where cabal-install
11:27:00 <lambdabot> I know nothing about cabal-install.
11:27:20 <bos> murr^^: start with xmonad. you really don't want to begin with a large haskell program.
11:27:28 <dcoutts> dons: I feel the name of the function is not right, but I'm not sure what it should be
11:27:43 <dcoutts> dons: it's more like system/rawSystem that runs a process to completion
11:27:47 <bos> i quite like readProcess.
11:28:09 <chadz> dons: of intro.html?
11:28:11 <murr^^> bos: I could just read a file or two of a large program if it's very modularly written. But I suppose I'll start with xmonad..
11:28:48 <bos> murr^^: xmonad is particularly clean, and it's not complicated. darcs and ghc will make your head explode.
11:28:55 <sjanssen> murr^^: xmonad is the only one I'd recommend.  GHC and darcs have far too many "hysterical raisins"
11:28:56 <dcoutts> @where+ cabal-install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
11:28:56 <lambdabot> Nice!
11:29:04 <dcoutts> @where cabal-install
11:29:04 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
11:29:05 <murr^^> OK, thanks
11:29:20 <chadz> i for one would like hackage to provide a darcs link
11:29:35 <chadz> % cabal darcs xmonad   -- would be a nice ability
11:29:47 <dcoutts> chadz: me too, if you can come up with a design for a repo spec in the .cabal file that'd be great
11:29:50 <bos> yeah, that would be nice.
11:30:03 <chadz> dcoutts: I got work too, y'know :)
11:30:17 <dcoutts> chadz: we need to identify the kind of scm (ie darcs, svn etc) the url, the branch and the path to the project within the repo
11:30:40 <dcoutts> chadz: aye, that's why the feature doesn't exist yet :-) we've all got plenty to do
11:30:43 * bos watches darcs crawl up its own behind. sigh.
11:31:06 <chadz> what's hackage running on? database, happs, ... ?
11:31:19 <dcoutts> chadz: apache + cgi + haskell scripts
11:31:44 <tibbe> anyone gotten the latest haskell-mode to work? it hangs when i do C-c C-l
11:32:20 <monochrom> I just saw a similar report on haskell-cafe or something. Involved Windows.
11:32:21 <alexj_> dcoutts: http://searchpath.org/package-info.rnc
11:32:43 <bos> what's a reasonable amount of time to wait for darcs to apply a patch? i have a notion that if it spins for 30 seconds, it's likely to spin for a month.
11:33:03 <alexj_> dcoutts: that is my beginning attempt to come up with a clean format for describing packages.
11:33:33 <dcoutts> alexj_: is this related to my comment on scm repos or just in general?
11:33:52 <alexj_> yes.
11:34:00 <alexj_> there is a line there for repos.
11:34:09 <alexj_> should probably have a tag attribute.
11:34:35 <resiak> Hrm, is Cabal usable for pure C projects?  It deals well enough with mixed Haskell/C projects
11:35:00 <monochrom> Oh well, same person. :)
11:35:07 <alexj_> dcoutts: you were talking about a rebuild of hackage yesterday.  is there a requirements doc?
11:35:45 <dcoutts> alexj_: not written down, just lots of feature requests in the trac and in people's heads
11:36:15 <tibbe> dcoutts: I want pretty pixels! :)
11:36:18 <dcoutts> alexj_: I was thinking that HApps might be a good platform for it but I don't have a great deal of experience with web apps
11:36:33 <alexj_> yeah, I was thinking it might be a good demo app.
11:36:41 <dcoutts> alexj_: it would yes :-)
11:37:10 <alexj_> which trac has the hackage requests?
11:37:28 <dcoutts> alexj_: http://hackage.haskell.org/trac/hackage
11:37:29 <lambdabot> Title: Hackage - Trac
11:38:09 <alexj_> ok will review.
11:38:11 <alexj_> thanks
11:38:13 <dcoutts> alexj_: so that scm stuff has a flavour and a url, but I wonder if that's enough to identify a package, since projects are often not in the root of a repo, and then there are tags/branches etc which are not always part of the repo url
11:38:50 <dcoutts> alexj_: there are more features that are only in our heads, like sending package authors emails, getting build feedback from clients
11:38:57 <alexj_> yeah I think the remaining bit is just to add a branch attribute at  the top.
11:39:16 <alexj_> dcoutts: that last was re scm
11:39:17 <tibbe> dcoutts: maybe my WSGI like web server will be done
11:39:53 <dcoutts> alexj_: the main thing it does is manage the package archive, but it's also got users & authentication for uploads and has a lot of meta-data about packages which we'd like to present in various ways
11:40:17 <alexj_> yeah, I've been thinking through a bunch of these issues for searchpath and package-info.
11:40:50 <dcoutts> alexj_: and caching could be important too, the package archive is supposed to be purely functional so .tar.gz files should never expire so it should be possible to tell a proxy to cache pretty effectively
11:40:55 <chadz> i think flavor/url is enough.
11:41:14 <dcoutts> chadz: it's not enough to rebuild a project from a darcs repo
11:41:31 <dcoutts> chadz: and certainly not enough to identify the exact version that corresponds to a release
11:41:50 <litb> why is darcs so famous in the haskell world?
11:41:50 <chadz> i wasn't expecting cabal to handle buildling of darcs repositories
11:42:06 <alexj_> chadz: searchpath currently handles darcs repos.
11:42:27 <chadz> litb: it's one of the largest industrial applications
11:42:40 <Philippa> it's also a good example of an app that was enabled by the 'haskell mindset'
11:42:44 <dcoutts> chadz: perhaps not, but what do you want the url for? and perhaps there's a need to identify both the latest development branch and also the branch/tag that corresponds to this release
11:43:24 <chadz> dcoutts: (flavor,[url])  :)
11:44:13 <Zao> Philippa: "Theory, in practice"?
11:44:42 <chadz> dcoutts: i figure if one's wanting the darcs version, there's probaly going to be some manual intervention.
11:45:06 <dcoutts> chadz: for hackage we want to get stats from the darcs repo so we need to do it automatically
11:45:22 <chadz> ah
11:45:40 <Philippa> Zao: that's part, but not all, of it
11:45:53 <kib> Hi
11:46:02 <Philippa> typeful programming's a big deal as well
11:47:38 <dcoutts> alexj_: the main reason I was thinking about HApps is that it serialises the requests so it should make presenting a consistent view of the archive easier
11:48:07 <dcoutts> alexj_: that, and it'd be nice to have an easy way for people to deploy their own hackage servers and having just one program to run is nice
11:48:31 <alexj_> dcoutts those are the general arguments for happs for any project (-:
11:48:39 <dcoutts> alexj_: right
11:51:27 <dcoutts> alexj_: then there are ideas like having a hoogle instance that covers all the packages on hackage, for that to be fast we'd probably want to keep the whole index in memory all the time
11:52:20 <alexj_> not sure i understand that feature.  but I think I can put together enough of a base so that people can easily add.
11:52:46 <dcoutts> alexj_: right, you found the existing hackage-script repo?
11:53:04 <alexj_> dcoutts: no haven't looked yet.
11:53:06 <alexj_> where is it?
11:53:18 <dcoutts> darcs.haskell.org/hackage-scripts/
11:54:04 <dcoutts> alexj_: hoogle currently works in a one-shot mode where it reads its indexes out of files, does one search and terminates. For best response times with a large index covering all packages we'd want to keep that index in ram rather than reading it from disk all the time
11:54:43 <dcoutts> alexj_: and then of course as packages are added the hoogle index has to be updated in a consistent way, happs should be great for that
11:55:21 <sjanssen> dcoutts: can't you trust the OS to keep it in cache?
11:55:43 <alexj_> dcoutts: yes then happs-state is what you want.
11:56:20 <dcoutts> sjanssen: perhaps, but that just means it' being kept in memory in a slightly weird and duplicative representation
11:56:43 <dcoutts> alexj_: I presume it's possible for long running stuff to be forkIO'd and to submit extra messages to the incoming queue?
11:57:02 <alexj_> dcoutts: yes that is indeed the design pattern.
11:57:25 <dcoutts> alexj_: ok, good
11:57:59 <alexj_> dcoutts: happs-state is basically type indexed ACID state.  you make query/update it from IO with types that identify the part of state you want.
11:58:01 <tibbe> on-the fly indexing of new packages can be tricky
11:58:46 <dcoutts> alexj_: happs-state is different from ordinary happs in that it keeps the state in memory rather than disk?
11:59:36 <alexj_> happs-state is just the part of happs uses for ACID.  all state updates are written to a log before returned.  the state is also checkpointed so if you reboot, happs-state reads the last checkpoint and replays the log to get back to the current state in memory.
12:00:00 <dcoutts> ah ok, so it's a component rather than a variant
12:00:07 <alexj_> yes.  sorry if that was unclear.
12:00:16 * dcoutts reads the happs.org page
12:00:32 <alexj_> the docs need some improvement.
12:01:14 <dons> dcoutts: you thinking of running some of the fancier hackage ideas in happs?
12:01:27 <dcoutts> dons: it seems like a natural fit
12:01:29 <dons> yeah
12:01:36 <dcoutts> and would be nice for deployment
12:01:43 <dons> should help happs get some more stress testing too
12:01:48 <dcoutts> cabal install hackagedb
12:01:56 <alexj_> dons: exactly what I was thinking.
12:02:16 <dcoutts> yes, the central hackage.haskell.org could see fairly high usage
12:02:51 <dcoutts> dons: you've worked with happs before right? for hpaste.org?
12:03:47 <dons> yep
12:03:52 <dcoutts> alexj_: oh and download logs, that's a bit annoying with apache, we want to present download stats for eahc package and it's a pain to have to go and parse apache logs
12:04:12 <dons> and it was as advertised: easy to deploy, and we got to concentrate on core features, not infrastructure hassle.
12:04:19 <dcoutts> alexj_: I presume that'd be a lot easier with an api in happs than parsing some text log
12:04:23 <dons> though happs kept moving, meaning hpaste was unbuildable for a long time.
12:04:29 <dons> stability is good for frameworks.
12:04:41 <dcoutts> true, though so are features :-)
12:04:42 <alexj_> dons: happs is getting much more stable now.
12:05:11 <dons> yep. it looks like things are heading in the right direction
12:05:35 <dons> i saw the deutsche bank guy also talking about how things are stabilising nicely, for their use
12:06:37 <alexj_> which deutsche bank guy where?
12:08:28 <dcoutts> alexj_: quick, potential customer :-)
12:09:16 <BMeph> Has anyone compiled Haddock 2.0 yet?
12:10:15 <byte-> hello.
12:12:12 <byte-> let's say I have code like this: http://lambda-the-ultimate.org/node/2595#comment-39078
12:12:13 <lambdabot> Title: The Land of the Terminal | Lambda the Ultimate
12:12:36 <byte-> I don't suppose there's a way to get rid of those useless variable bindings, are there?
12:12:40 <byte-> s:are:is:
12:13:05 <byorgey> byte-: sure there is.
12:13:23 <byte-> how?
12:13:33 <monochrom> Are they useless?
12:13:57 <byorgey> byte-: in that case, use liftM3, or even better, Applicative
12:13:59 <byte-> giving them names doesn't contribute to the readability of the function.
12:14:42 <byte-> "applicative"?
12:14:50 <byorgey> oh, wait, I see, they're in a weird order
12:15:08 <byorgey> Control.Applicative
12:15:20 <byte-> ok, thanks.
12:18:03 <byte-> how would I use Control.Applicative in this case?
12:18:07 <monochrom> Hughes's pretty printing paper has a typo. Page 6, section 4.1, "albegra"!
12:18:07 <Saizan> ?. pl undo foo x = do y <- dox x; z <- doy y; blah <- doz z; return $ whatever blah z y x
12:18:08 <lambdabot> foo = liftM2 (>>=) dox (liftM2 (>>=) doy . ((liftM2 (>>=) doz . ((return .) .)) .) . flip (flip . (flip .) . flip (flip . flip whatever)))
12:18:17 <Saizan> aaargh.
12:18:23 <monochrom> haha
12:18:36 <Saizan> ?undo foo x = do y <- dox x; z <- doy y; blah <- doz z; return $ whatever blah z y x
12:18:36 <lambdabot> foo x = dox x >>= \ y -> doy y >>= \ z -> doz z >>= \ blah -> return $ whatever blah z y x
12:18:44 <monochrom> pl is not the best pl engine.
12:19:20 <Saizan> it's still not easy here, because you want to both channel and keep the results
12:20:55 <EvilTerran> ?pl \x y z -> whatever z y x
12:20:56 <lambdabot> flip (flip . flip whatever)
12:21:36 <sclv_> haha yeah -- the big problem is that whatever takes its args in a hideous order.
12:21:55 <EvilTerran> ?unpl liftM3 . flip $ flip . flip whatever
12:21:55 <lambdabot> (liftM3 (\ b c f -> whatever f c b))
12:22:12 <EvilTerran> ?redo liftM3 f x y z
12:22:12 <lambdabot> liftM3 f x y z
12:22:14 <EvilTerran> hm
12:22:26 <Saizan> ?. pl undo foo x = do y <- dox x; z <- doy y; blah <- doz z; return $ whatever x y z blah
12:22:26 <lambdabot> foo = liftM2 (>>=) dox (liftM2 (>>=) doy . ((liftM2 (>>=) doz . ((return .) .)) .) . whatever)
12:22:34 <litb> > flip (1, 2)
12:22:35 <lambdabot>  Couldn't match expected type `a -> b -> c'
12:22:37 <litb> hm
12:22:46 <EvilTerran> ?type flip
12:22:47 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:22:54 <EvilTerran> ?src flip
12:22:54 <lambdabot> flip f x y = f y x
12:23:32 <byte-> ?src liftM3
12:23:33 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
12:23:47 <byte-> interesting.
12:23:57 <byte-> always wondered what those liftM* functions did.
12:23:59 <litb> hmm
12:24:04 <EvilTerran> heh
12:24:16 <byte-> still, a bit too specific for what I was looking for.
12:24:43 <byte-> :t liftM1
12:24:44 <EvilTerran> thing is, i don't think you can reasonably do that example without binding some names
12:24:44 <lambdabot> Not in scope: `liftM1'
12:24:47 <byte-> :t liftM2
12:24:47 <EvilTerran> i guess that's his point
12:24:48 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:24:51 <EvilTerran> :t liftM
12:24:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:24:59 <EvilTerran> and liftM0 = return ;)
12:25:06 <byte-> ah, naming conventions ftl :(
12:25:12 <sclv_> once whatever is in the right order though, some set of applicative combinators should to the trick, no?
12:25:16 <byte-> ?src liftM
12:25:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:25:36 <EvilTerran> sclv_, the problem then is that x is needed to find y, and y to find z
12:25:40 <byte-> holy crap.
12:25:46 <byte-> that is so much nicer looking than =<<
12:25:58 <litb> hm, i don't understand the type of flip
12:26:05 <EvilTerran> litb, look at the src
12:26:09 <roconnor> liftMn f x1 x2 ... xn = return f `ap` x1 `ap` x2 `ap` ... `ap` xn
12:26:39 <kmcallister> ?src flip
12:26:40 <lambdabot> flip f x y = f y x
12:26:51 <litb> it takes a function f, which is (a -> b -> c) but after that, i'm getting confused
12:27:18 <sclv_> EvilTerran -- but you can handle splitting with the reader applicative, no?
12:27:19 <roconnor> litb: it returns a function which is (b -> a -> c)
12:27:20 <byte-> :t flip
12:27:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:27:55 <kmcallister> which is the same as (a -> b -> c) -> (b -> a -> c)
12:27:57 <litb> hm, i thought that would be written as  (a -> b -> c) -> (b -> a -> c) then
12:28:01 <byte-> currying ftw.
12:28:18 <litb> oh, it's the same
12:28:19 <byte-> litb, parens are optional for the last function.
12:28:21 <Saizan> -> is right associative
12:28:25 <EvilTerran> sclv_, yes, but would it be clearer?]
12:28:33 <gio123> somebody knows about algorithm to decide R1<R2 where R1 and R2 is regular types
12:28:46 <kmcallister> a -> b -> c -> d   ==   a -> (b -> (c -> d))
12:28:47 <byte-> that's why you can do things like 'f $ g $ x'
12:28:51 <byte-> when $ = id
12:29:01 <litb> ah, i understand.
12:29:11 <EvilTerran> well, that's because ($) is right-associative
12:29:12 <sclv_> EvilTerran: oh, absolutely not. :-)
12:29:20 <EvilTerran> (which is independent of the associativity of (->)
12:32:02 <gio123> somebody knows about algorithm to decide R1<R2 where R1 and R2 is regular types
12:32:18 <byte-> :t ()
12:32:19 <litb> > flip (-) 3 5 -- should become 2 ? lets see..
12:32:20 <lambdabot> ()
12:32:20 <lambdabot>  2
12:32:28 <litb> yeah, it works :)
12:32:46 <byte-> is () the 'unit' type in haskell?
12:32:53 <byte-> or am I just imagining things?
12:32:53 <kmcallister> yeah
12:32:58 <Saizan> gio123: regular you mean build with product and coproduct?
12:33:05 <kmcallister> it's a type with only one value, also written as ()
12:33:12 <litb> could one write a flip function for arbitrary many arguments too ?
12:33:22 <gio123> Saizan: regular expresions
12:33:39 <kmcallister> litb: for any fixed permutation, yes
12:33:42 <byte-> litb, you can write one for a certain number of arguments.
12:34:00 <litb> meh, no variadic templates here o.O
12:34:03 <kmcallister> if you wanted a function which takes a description of how to permute the arguments as an argument, you'd need to use template haskell or similar
12:34:05 <gio123> Saizan: u have concatinaton and sum
12:34:15 <gio123> Saizan: u have concatinaton and choice
12:34:16 <byte-> you could use template haskell to make a generic version.
12:34:35 <byte-> although it seems like it would be easier to do if haskell was more dynamic.
12:34:43 <Saizan> gio123: no recursion?
12:34:53 <litb> byte-: oh, i see. but that's another language i suppose
12:35:03 <gio123> Saizan: can u pm?
12:35:06 <kmcallister> litb, in TH you use haskell to manipulate haskell source
12:35:21 <kmcallister> (as an abstract syntax tree)
12:35:21 <EvilTerran> you might be able to do something 'orrible using typeclasses and overlapping instances, too
12:35:25 <litb> ah i see. interesting
12:35:33 <kmcallister> and there are splice and quasiquotation operators
12:35:40 <litb> the ast part sounds scary tho
12:35:49 <byte-> I guess you've never used lisp then, have you?
12:35:51 <kmcallister> it's not that bad, haskell is a nice language for manipulating ASTs
12:35:58 <byte-> also, it comes with a free sponge bath.
12:36:02 <EvilTerran> you can do a lot of stuff just using splice $(...) and quasiquote [|...|]
12:36:18 <kmcallister> [| e |] evaluates to the AST for the expression e
12:36:27 <EvilTerran> there's various places you can't splice into, tho
12:36:32 <gio123> Saizan: can u pm?
12:36:33 <kmcallister> and $(e) evaluates e to an AST and inserts it there
12:36:37 <EvilTerran> (types and patterns, for starters, iirc)
12:36:46 <kmcallister> yeah
12:36:53 <byte-> eh?
12:36:55 <byte-> why's that?
12:36:57 <litb> hmm, i'm still drinking the milk of my haskell mother. i suppose the best is to stay as simple as possible for the moment =)
12:37:02 <EvilTerran> gio123, we've told you before: don't repeat yourself
12:37:08 <byte-> it's not like the type checker can run before macro expansion, anyway.
12:37:13 <EvilTerran> gio123, he'll have seen your message. don't be so impatient.
12:37:15 <monochrom> You have a haskell mother? I want one too...
12:37:26 <EvilTerran> byte-, because the implementation's incomplete, i guess
12:37:35 <byte-> I see.
12:37:38 <gio123> EvilTerran: thank u
12:37:49 <EvilTerran> the paper didn't go through specifying everywhere splicing would be allowed, iirc
12:38:03 <EvilTerran> also, there's no pattern quasiquoting
12:38:10 <EvilTerran> (the paper didn't even suggest it)
12:38:24 <byte-> eww, papers.
12:38:26 <byte-> they have cooties.
12:38:59 <byte-> and also, the people that write them know nothing about writing things for _humans_.
12:39:05 <EvilTerran> ([|...|] yields the AST of the enclosed expression, [t|...|] of the enclosed type, and [d|...|] the enclosed decleration(s)
12:39:19 <EvilTerran> ... and I want [p|...|], say, for patterns)
12:39:29 <Toxaris> gio123: my theoretical computer science textbook tells me that: (1) the language defined by a regular expression is regular (surprise)
12:40:16 <Toxaris> gio123: (2) for two regular languages L1 and L2, L1 & L2, L1 | L2 and not L1 are also regular
12:40:32 <gio123> Toxaris: yes
12:40:40 <Toxaris> gio123: and (3) for a regular language L, L = {} is decidable
12:40:42 <byte-> heh.
12:40:45 <byte-> the definition of 'ap' is cute.
12:40:49 <byte-> ?src app
12:40:50 <lambdabot> Source not found. I feel much better now.
12:40:52 <Toxaris> gio123: that said, there should be an algorithm wich does what you want :)
12:40:53 <byte-> ?src ap
12:40:54 <lambdabot> ap = liftM2 id
12:41:11 * EvilTerran didn't think intersection and negation necessarily yielded a regular language
12:41:45 <gio123> Toxaris: yes, there is very unconstructive paper which i didnt undestand so far
12:41:46 <gio123> :)
12:41:50 <EvilTerran> i'm quite possibly mistaken, tho; i may be thinking of the context-free languages
12:42:32 <mrd> intersection and complement are closed for regular languages
12:42:39 <EvilTerran> ok
12:42:44 <monochrom> Using nondet automata, you can prove neg reg is reg.
12:42:51 <gio123> Toxaris: there is a proof, but to take from this proof working algorithm looks quit hard
12:42:51 <monochrom> Also union.
12:42:52 <Toxaris> gio123: my textbook suggests this algorithm: construct a DFA accepting the language, check if their are any paths from start to an accepting node. if none, the language is empty
12:43:08 <monochrom> Then at least you can use de Morgan to also deduce int.
12:43:09 <EvilTerran> i guess it'd be possible to do intersection by DFA, too
12:43:09 <Toxaris> gio123: their -> there are
12:43:21 <EvilTerran> union's pretty easy, anyway
12:43:33 <EvilTerran> union(L(A),L(B)) = L(A|B)
12:43:44 <mrd> with non-det, trivial
12:43:51 <monochrom> However, a direct construction of the intersection automaton is well known.
12:43:52 <gio123> Toxaris: it is one way to convert it to DFA and then check DFA's but it is very expencive
12:44:01 <mrd> yea they can both be directly constructed
12:44:07 <mrd> i have some haskell around for this stuff
12:44:53 <EvilTerran> this is starting to come back to me now; i envisage constructing the cross-product of the node sets of the two DFAs
12:45:04 <EvilTerran> er, cartesian product
12:46:24 <EvilTerran> (to determine the DFA for the intersection, that is)
12:46:34 <pgavin> has anyone been able to ghc 6.9.2 to build on mac os x leopard
12:46:37 <pgavin> ?
12:46:55 <pgavin> sorry, I mean 6.8.2
12:47:25 <monochrom> L1  L2 iff L1  complement L2 = empty.  The RHS is the standard algorithm for answering the LHS.
12:48:38 <monochrom> Yes, intersection involves product.
12:49:47 <EvilTerran> although it seems to me it might also be possible to devise an algorithm for "pushing & through" a regex 'til it's eliminate
12:49:48 <EvilTerran> d
12:50:34 <byte-> any thoughts on this? http://lambda-the-ultimate.org/node/2595#comment-39113
12:50:35 <lambdabot> Title: The Land of the Terminal | Lambda the Ultimate
12:51:07 <__pao__> is correct to say that the sequence of statement in a "do" block represent a composition of functions by >>= operator?
12:51:08 <byte-> the 1, 2, and 3.
12:51:11 <monochrom> Anyway, all homework questions have well-known solutions.
12:51:15 <EvilTerran> (a|b)&c -> (a&c)|(b&c), a&(b|c) -> (a|b)&(a|c), ...
12:51:27 <EvilTerran> ... altho i'm not sure how you'd deal with concatenation
12:51:40 <EvilTerran> or *
12:51:43 <monochrom> That is the hard part.
12:51:53 <bos> __pao__: sort of. it can also involve >> and rewriting of let expressions.
12:52:25 <EvilTerran> you'd probably need to introduce at least one further operator or sth; easier to just make a graph
12:52:29 <__pao__> bos: thanks
12:52:45 <EvilTerran> __pao__, the report explains the desugaring in full
12:52:58 <EvilTerran> @where report
12:52:58 <lambdabot> http://www.haskell.org/onlinereport/
12:53:14 <monochrom> Hudak's book also does.
12:53:27 <__pao__> EvilTerran: is it approchable even with basic mathematics basics? :-)
12:53:30 <monochrom> When learning anything, read at least three books.
12:53:32 <ndm> @seen dcoutts
12:53:32 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 31m 49s ago.
12:53:57 <EvilTerran> @where+ do http://www.haskell.org/onlinereport/exps.html#do-expressions
12:53:57 <lambdabot> It is forever etched in my memory.
12:54:01 <ndm> @slap dcoutts
12:54:01 * lambdabot moulds dcoutts into a delicous cookie, and places it in her oven
12:54:31 <chadz> haha
12:54:43 <chadz> mh must go be graced by ungaro now
12:54:47 <gio123> https://dl.comp.nus.edu.sg/dspace/bitstream/1900.100/1453/3/report.pdf
12:54:50 <lambdabot> http://tinyurl.com/23wdrm
12:54:51 <chadz> oh, wrong channel.
12:54:51 <__pao__> thanks all :-)
12:55:29 <gio123> can somebbody look this paper page 19 and advice me to take constructive algorithme for subtypeing
12:56:08 <byte-> http://www.areallylongnamethatsobviouslyfaketotestsomething.com/3.1415926535897932384/blah
12:56:09 <lambdabot> Title: Com.org - Only the best links ..., http://tinyurl.com/2arz55
12:56:14 <byte-> wtf?
12:56:29 <byte-> that domain's actually registered.
12:56:30 <byte-> wow.
12:56:33 <byte-> I gotta check that out.
12:56:43 <EvilTerran> it's not, tho; i think the bot does something odd about it
12:56:47 <ndm> its official, cabal's syntax sucks
12:56:47 <lambdabot> ndm: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:56:59 <ndm> Foo: Bar is not equal to Foo: \n\t Bar
12:57:03 <ndm> @messages
12:57:03 <lambdabot> dcoutts said 3h 8m 14s ago: test case for hoogle 4: [IO String] -> IO [String] should find sequence :: Monad m => [m a] -> m [a]
12:57:03 <lambdabot> dcoutts asked 2h 31m 4s ago: btw, do you like the improved text on the http://hackage.haskell.org/ home page?
12:57:03 <lambdabot> dcoutts said 2h 28m 14s ago: I assume Ross updated it (it certainly wasn't me)
12:57:04 <byte-> oh.
12:57:16 <byte-> ohh, it looked up com.org, apparently.
12:57:45 <byte-> ndm, shouldn't those be things you should be reading in, uhh, private?
12:58:05 <ndm> byte-: i strongly suspect dcoutts messaged them at me in the public IRC
12:58:19 <byte-> lol
12:58:32 <ndm> and its useful if i need to respond to one of the points in the channel to keep the conversation around
12:58:32 <Toxaris> gio123: from a short scan, that paper seems to do what you want :) but I don't understand a single idea, so I cannot help you there... maybe you can look that Antimorov's algorithm up somewhere else?
12:58:42 <byte-> so nobody has any comments on http://lambda-the-ultimate.org/node/2595#comment-39113?
12:58:43 <lambdabot> Title: The Land of the Terminal | Lambda the Ultimate
12:58:52 <byte-> http://lambda-the-ultimate.org/node/2595#comment-39113 without the question mark
12:58:53 <lambdabot> Title: The Land of the Terminal | Lambda the Ultimate
12:58:55 <byte-> probably should've used a space.
12:59:19 <byte-> I wonder if there's a way to slip urls passed lambdabot so as not to spam the channel twice.
12:59:22 <ndm> @tell dcoutts Hoogle 3 drops anything with Monads (or higher-kinded type classes) on the floor - a well known issue which will be fixed in 4. The hackage web page is substantially improved, much much nicer!
12:59:23 <lambdabot> Consider it noted.
12:59:23 <__pao__> monochrom: you were referring to this, right? http://www.haskell.org/tutorial/
12:59:25 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
12:59:27 <gio123> Toxaris: i have paper about artimirovs algorithm but very hard to take algorithme from there
12:59:43 <EvilTerran> byte-, the convention in general is to use <http://example.com>, i believe
12:59:52 <ndm> @karma+ ross
12:59:52 <lambdabot> ross's karma raised to 2.
12:59:53 <byte-> ah, nice.
13:00:13 <byte-> I was just thinking of dropping the http://
13:00:16 <byte-> but that makes it annoying to click.
13:00:20 <EvilTerran> there's some RFC that suggests <URL:http://example.com>, but that was from the days when people might not recognise something with a :// in it as a URL
13:00:25 <monochrom> No. "the haskell school of expression".
13:00:36 <monochrom> book. I really mean book. three.
13:00:42 <gio123> Toxaris: so, what i need is, in that paper i showed above they dont present complete inference system for subtyping, but they have haskell implemetation of subtyping what i need is to know whether that implemetation give complete inference system
13:00:50 <byte-> monochrom, what's so special about books?
13:00:53 <__pao__> monochrom: thanks
13:01:09 <Toxaris> gio123: so try it out :)
13:01:15 <EvilTerran> __pao__, did you see my link to the description in the report?
13:01:20 <byte-> they're generally poorly written and you can learn faster by idling on IRC.
13:01:26 <monochrom> comprehensive. reviewed and edited. coherent.
13:01:28 <__pao__> yep
13:01:31 <__pao__> EvilTerran: yep
13:01:32 <byte-> monochrom, IRC isn't?
13:01:34 <byte-> ;)
13:01:36 <EvilTerran> 'cos IRC is better written than books, byte- :P
13:01:42 <gio123> Toxaris: what?
13:01:55 <byte-> IRC conversations generally are, actually.
13:01:59 <__pao__> EvilTerran: it explain the formalism of desugaring... I'm really trying to grasp the semantics of monads
13:02:15 <EvilTerran> @go you could have invented monads
13:02:16 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:02:16 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:02:23 <hpaste>  nbarterd pasted "anything I can do to clean up this error checking mess? (nested maybes)" at http://hpaste.org/4888
13:02:30 <EvilTerran> __pao__, i found that one pretty useful
13:02:33 <Toxaris> gio123: well that Haskell source they give in the paper. if it (1) compiles and (2) does something usefull for some made-up examples, you can investigate further :)
13:03:02 <__pao__> EvilTerran: I'm kind of convinced that I can claim to be a real haskell programmer when I'll be able to see the need of designing a custom monad when it'll be needed :-)
13:03:18 <gio123> Toxaris: I am interested whether that implemetation discrabes compete proof system
13:03:51 <byte-> ?src const
13:03:51 <lambdabot> const x _ = x
13:04:31 <EvilTerran> __pao__, it explains nicely why the standard monad instances are what they are, though
13:04:31 <Toxaris> __pao__: learning Haskell is like mountain climbing. when you've learned something, you understand what you will try to learn next. (in my opinion, this is a good thing)
13:04:50 <monochrom> You will never learn category theory by sitting on IRC. I certainly wouldn't have the patience to type it all out on IRC.
13:05:01 <__pao__> Toxaris: it reminds me about windsurfing ;-)
13:05:02 <byte-> why would I need to learn category theory?
13:05:06 <monochrom> But a book author does. That's the job of a book author.
13:05:09 <yrlnry> "Mom, what's an epimorphism?"
13:05:20 <__pao__> EvilTerran: I'll give a look, thx
13:05:24 <byte-> IRC + intarweb = infinite knoweldge!
13:05:26 <byte-> !!!111
13:05:33 <monochrom> It takes hundreds of pages. Impractical to do on IRC.
13:05:39 <sclv_> byte-: the example at the bottom of that new post on ltu looks like applicative would work fine.
13:05:41 <byte-> monochrom, intarweb.
13:05:56 <FunctorSalad> hundreds of pages for basic CT? IMHO that's exaggerated
13:05:57 <monochrom> Category theory is just an example. Replace that by monads, arrows, whatever.
13:06:09 <__pao__> byte-: intarweb?
13:06:15 <FunctorSalad> I for one prefer IRC :)
13:06:25 * Toxaris would buy a book written by monochrom about category theory. are there any?
13:06:29 <byte-> sclv, yeah, I realized that when I learned what 'ap' and liftM* do.
13:06:38 <monochrom> You can prefer what you want.
13:07:11 <byte-> __pao__, means "internet."
13:07:20 <yrlnry> Oh, serious question.  Where do I look to find out what a "final algebra" and a "cofinal algebra" are?
13:07:24 <__pao__> byte-: sorry :-)
13:07:35 <monochrom> The objectively measurable result is, likely but I can't of course be sure, that I learn Haskell from books and I am more fluent, you learn Haskell from the Internet and you are less fluent.
13:07:39 <yrlnry> I have a fair amount of background in logic and in category theory.
13:08:07 <__pao__> monochrom: can you please suggest your ideal reading list?
13:08:12 <byte-> monochrom, I learn everything from the internet.
13:08:24 <__pao__> monochrom: I'm definitely of your same type class ;-)
13:08:26 <byte-> monochrom, but you're ignoring a fairly critical factor.
13:08:33 <byte-> namely, that we're two different people.
13:08:41 <byte-> that apparently prefer to learn using different means.
13:08:46 <monochrom> Jacob Barts has a co-algebra tutorial. http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf
13:09:00 <FunctorSalad> monochrom: I'm not sure whether you mean general "I" and "you" there, but if you weren't - I've been learning for like two weeks
13:09:04 <yrlnry> Thanks.
13:09:10 <byte-> (I use the term "learn" grudgingly. I prefer to discover.)
13:09:42 <EvilTerran> it's surely worth at least having a quick look at a couple of books if you're serious about learning something
13:09:51 <FunctorSalad> and I agree with byte- that it is a bit presumptuous to state as objective fact that your style of learning is better for everyone.
13:09:52 <byte-> lol
13:10:13 <EvilTerran> trying to pick something up over the internet might not be as tedious, but it tends to leave gaps
13:10:16 <monochrom> Did I even state that?
13:10:16 <yrlnry> Learning stuff from chitchat on IRC is going to be bad for anyone.
13:10:36 <sclv_> do_something_maybe x = doxyz <$> x <*> gety x<*> getz x
13:10:46 <byte-> monochrom, you implied it, whether you intended to or not.
13:10:52 <dcoutts_> yrlnry: are you sure you don't mean initial algebra and final co-algebra?
13:11:20 <FunctorSalad> monochrom: yeah... it came across as "you can prefer what you want, but of course I'm right", intended or not
13:11:26 <dcoutts_> yrlnry: is this in relation to the encoding of data types in lambda calculus?
13:11:37 <byte-> ?src <$>
13:11:37 <lambdabot> f <$> a = fmap f a
13:11:42 <byte-> ?src <*>
13:11:43 <lambdabot> Source not found.
13:11:47 <byte-> damn.
13:11:49 <byte-> curse you, lambdabot!
13:12:10 <sclv_> look in Control.Applicative
13:12:24 <byte-> I know it's in there, I'm just too lazy to go there :/
13:12:25 <monochrom> I think you people are imagining the "of course I'm right" part just because you don't like what I said.
13:12:29 <__pao__> monochrom: sorry to get back again... what would be your ideal reading list for haskell (books)? 3 is the perfect number
13:12:43 <yrlnry> dcoutts: Turner's paper on "Total Functional Programming" says:  "    Codata definitions are equations over types that produce final algebras, in-
13:12:43 <yrlnry> stead of the initial algebras we get for data definitions.
13:12:43 <yrlnry> "
13:12:58 <yrlnry> Maybe that answers both of your questions at once.
13:13:02 <EvilTerran> byte-, <*> is instance-dependent, i believe
13:13:03 <byte-> monochrom, I think you're ignoring the "of course I'm right" part because you're being defensive ;)
13:13:06 <EvilTerran> @src Applicative
13:13:07 <lambdabot> class Functor f => Applicative f where
13:13:07 <lambdabot>     pure  :: a -> f a
13:13:07 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:13:13 <monochrom> Bird, Hudak, then either Thomson or Hutton.
13:13:30 <EvilTerran> byte-, monochrom, watch your tone, guys. this isn't reddit. ;)
13:13:34 <byte-> isn't that the same as ap?
13:13:36 <byte-> :t ap
13:13:36 <monochrom> "The objectively measurable result is, likely but I can't of course be sure" is "of course I am right"?
13:13:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:13:41 <EvilTerran> byte-, for monads, yes
13:13:41 <__pao__> monochrom: thx
13:13:51 <EvilTerran> but not all Applicatives are Monads
13:14:04 <byte-> EvilTerran, I guess you missed the ";)" at the end of my sentence ;)
13:14:06 <monochrom> I even allow for "I can't of course be sure".
13:14:07 <EvilTerran> byte-, it'd be more accurate to say "ap is the same as <*> (for Monads)"
13:14:45 <jsnx> monochrom: i'm reticent to hold you responsible for things you didn't actually say
13:14:57 <EvilTerran> byte-, 'twas just a friendly warning, is all. i had a ;), too :)
13:15:22 <byte-> yes, but the ;) was scoped to the last line.
13:15:23 <FunctorSalad> monochrom: saying "You can do what you want" has this implication in general language
13:15:29 <byte-> *last sentence of that line
13:15:29 <EvilTerran> @src [] (<*>)
13:15:30 <lambdabot> (<|>) = (++)
13:15:34 <EvilTerran> what
13:15:39 <byte-> you need to use parenthesis if you meant otherwise ;)
13:15:49 <byte-> you had two sentences there, "watch your tone, guys."
13:15:52 <byte-> and "this isn't reddit ;)"
13:16:10 <EvilTerran> @src Maybe (<*>)
13:16:11 <lambdabot> (<*>) = ap
13:16:28 <jsnx> monochrom: while i agree that IRC is no substitute for books, it's certainly the case that many good books can be found via IRC
13:16:36 <EvilTerran> byte-, i get your point. enough already.
13:16:45 <byte-> lol ;)
13:16:45 <sclv_> jsnx: and papers!!
13:16:50 <yrlnry> This tutorial on final algebras sucks!
13:16:51 <jsnx> some of the links i've gotten off of this cahnnel can't really be found with google
13:16:55 <byte-> I was just answering your question :P
13:17:02 <EvilTerran> that wasn't my question
13:17:06 <yrlnry> Because when I tried to print it, my printer ran out of paper after four pages.
13:17:09 <byte-> oh.
13:17:25 <byte-> I didn't bother remembering the name of whoever I was talking to.
13:17:28 <EvilTerran> my question was "why has lambdabot replied to my request for the source of <*> with the source of <|>"?
13:17:31 <byte-> oh well, that's life.
13:17:39 <byte-> heh, I noticed that, too.
13:18:01 <idnar> @src [] <*>
13:18:01 <lambdabot> Source not found. :(
13:18:04 <idnar> meh
13:18:10 <idnar> that's weird
13:18:15 <monochrom> OK, let me concede and accept that "you can prefer what you want" implies "but I'm right".  What's wrong with that, especially right afterwards I offer a way to verify or falsify my claim?
13:18:46 <jsnx> monochrom: well, hold on
13:18:49 <FunctorSalad> for me, most learning happens by *doing* and actually thinking things through myself. to get so far that I can start doing something, I can either ask on IRC and get a one-line answer that's enough to get me in the right direction, or I can use a book that is mostly filler and explaining stuff I already know
13:18:51 <byte-> monochrom, because I proved you wrong in the general case right after that :P
13:19:07 <byte-> I believe I said "we're different people" or something like that.
13:19:15 <jsnx> byte-: that is actually irrelevant
13:19:23 <byte-> how so?
13:19:24 <Cale> EvilTerran: lambdabot just has a separate text file which holds the definitions for various terms, so it's possible that whoever made up that file made an error when copying and pasting from the libraries.
13:19:30 <jsnx> byte-: that you disprove it afterward does not mean he did anything wrong before
13:19:37 <EvilTerran> Cale, ah.
13:19:43 <monochrom> That is no proof.
13:19:44 <byte-> who's saying he did something "wrong"?
13:19:51 <jsnx> byte-: that's what he asked
13:20:10 <chadz> i think #nobodycares is where stuff like this is usually discussed
13:20:11 <jsnx> byte-: he said, what's wrong with that?
13:20:19 <EvilTerran> suspect "@src [] (<*>)" should yield "(<*>) = ap", anyway, going by the answer to "@src Maybe (<*>)"
13:20:20 <jsnx> chadz: lolz, yes
13:20:28 <EvilTerran> er, I suspect...
13:20:42 <byte-> what he said was wrong.
13:20:44 <byte-> not what he "did."
13:20:47 <Cale> EvilTerran: yes, it should.
13:20:49 <jsnx> byte-: anyway, i urge you to commit sepuku for misunderstanding him
13:20:52 * __pao__ thinks the learning method discussion is becoming a sofism exercise :-)
13:21:00 <jsnx> byte-: it builds character
13:21:04 <FunctorSalad> monochrom: thanks for conceding that... nothing is particularly wrong with it, I just mentioned that in response to something
13:21:13 <EvilTerran> byte- et al, you're all off-topic
13:21:14 <jsnx> pastorn: sophism
13:21:16 <jsnx> oops
13:21:20 <jsnx> __pao__: sophism
13:21:21 <byte-> (in the sense that doing something wrong has different implications than saying something that's wrong.)
13:21:40 <monochrom> If we have one large group of people learn from books, another large group of people learn from IRC, both groups selected fairly, then put them through a programming contest.  That will be solid evidence.
13:21:46 <__pao__> jsnx: thx :-)
13:22:04 <jsnx> __pao__: sophism means "wisdom", haha
13:22:07 <jsnx> literally
13:22:12 <monochrom> Just saying "different people" is old void slogan. I've heard that before.
13:22:22 <Cale> What is this, some kind of argument over whether books are better than IRC or not?
13:22:22 <__pao__> jsnx: :-)
13:22:23 <EvilTerran> (for some reason, the phrase "solid evidence" makes me think "poop". must be too much CSI...)
13:22:23 <jsnx> but the wise behaved so badly, it came to mean legalism
13:22:24 <byte-> monochrom, except it will be evidence that has no use.
13:22:32 <byte-> since people don't just choose a method at random.
13:22:33 <FunctorSalad> monochrom: if 99% of people had blue eyes, should conclude that I have blue eyes too even though I don't?
13:22:35 <byte-> or at least, I don't.
13:22:54 <byte-> I don't read many books because they don't fit the style of how I learn.
13:23:01 <jsnx> FunctorSalad: lolz -- if you had no other evidence, that would be the safe way, wouldn't it?
13:23:19 <jsnx> i don't read because i can't pay attention that long any more
13:23:23 <__pao__> jsnx: "In the modern definition, a sophism is a confusing or illogical argument used for deceiving someone"
13:23:25 <FunctorSalad> jsnx: it will be solid evidence for a randomly chosen coder. but about myself I do have a lot of evidence
13:23:27 <__pao__> :-)
13:23:41 <EvilTerran> __pao__, ah, so it means politics!
13:23:48 <byte-> FunctorSalad, not to mention the fact that it doesn't apply to everybody.
13:23:50 <jsnx> i am trying to relearn reading
13:23:56 <byte-> which is the actual debate at hand.
13:24:07 <jsnx> it's hard
13:24:14 <jsnx> you can't type or anything
13:24:15 <byte-> jsnx, that's sort of like me, except I'm too impatient to do anything for too long.
13:24:19 <jsnx> no NSFW pics
13:24:23 <Cale> I hate that usage of the word "sophism", myself. It's exactly the opposite of what it should mean.
13:24:34 <__pao__> EvilTerran: exactly! I think sophism was one of the first form of philosophy applied to politics ;-)
13:24:44 <jsnx> Cale: well, it's a Hellenic idiom that has survived for this long
13:24:47 <byte-> Cale, solipsism says you have a 50% probability of being wrong.
13:24:48 <byte-> ;)
13:24:54 <FunctorSalad> __pao__, was that directed at me?
13:25:19 <jsnx> Cale: maybe you should hate the sophists instead :)
13:25:22 <EvilTerran> isn't solipsism where you fall asleep spontaneously in the middle of doing something else?
13:25:48 <__pao__> FunctorSalad: sorry, no ++ with my previous message
13:25:58 <chadz> i'm pretty sure that's narcolepsy :)
13:25:58 <FunctorSalad> EvilTerran: no, it is the belief that only you exist
13:26:10 <byte-> EvilTerran, google it.
13:26:11 <jsnx> Cale: what would call it instead, i wonder?
13:26:18 <byte-> EvilTerran, and no, that's epilepsy.
13:26:31 <quicksilver> I thought that was sophistry
13:26:32 <chadz> epilepsy is when you seizure/go comatose.
13:26:36 <byte-> or narcolepsy, whatever the difference is.
13:26:37 <quicksilver> rather than sophism
13:26:39 <EvilTerran> byte-, FunctorSalad, that was a joke. an off-topic one at that. also, byte-, actually it's narcolepsy. seizures != sleep
13:26:40 <FunctorSalad> __pao__: sorry, missed that you had a discussion about sophism
13:26:45 <byte-> chadz, what do you think "sleeping" is?
13:26:47 <byte-> :P
13:26:56 <jsnx> quicksilver: both are used
13:27:07 <Cale> Solipsism is half-right... you don't really exist either.
13:27:23 <byte-> Cale, wrong.
13:27:26 <jsnx> Cale: that is buddhism
13:27:29 <jsnx> lolz
13:27:34 <byte-> you don't _know_ I exist.
13:27:39 <byte-> but you don't know I don't exist.
13:27:43 <chadz> my theory is that anything that ends in ism is pointless to discuss.
13:27:51 <byte-> you don't know anything, by the definition of solipsism :P
13:27:57 <FunctorSalad> solipsism doesn't even make sense
13:27:58 <__pao__> EvilTerran: "the societal roles that the Sophists filled had important ramifications for the Athenian political system at large"
13:27:59 <jsnx> byte-: what he means is, neither the world nor the self exists
13:28:07 <byte-> FunctorSalad, sure it does.
13:28:09 <byte-> FunctorSalad, it's just wrong.
13:28:10 <monochrom> polymorphism?
13:28:11 <jsnx> __pao__: like economists today!
13:28:30 <FunctorSalad> byte-: it's notion of "you" is so broad as to be essentially meaningless, as far as I can see.
13:28:36 <__pao__> jsnx: :-)
13:28:39 <byte-> what notion of "you"?
13:28:39 <jsnx> __pao__: they are our modern sophists -- twisting reason (math) for political purposes
13:28:41 <FunctorSalad> s/it's/its
13:28:54 <__pao__> jsnx: good definition
13:29:03 <FunctorSalad> byte-: solipsism claims that only you exist, without (as far as I know) offering a reasonable definition of "you"
13:29:11 <Tac-Tics> Pondering Haskell too hard has made lowly philosophers of you all!
13:29:13 <byte-> FunctorSalad, your mind.
13:29:24 <byte-> FunctorSalad, whatever you're using to come to that conclusion.
13:29:28 <quicksilver> s/lowly/lowbrow/
13:29:28 <Cale> I usually take the view that truth and falsity are merely labels which we apply to statements, and that there's no absolute notion of truth.
13:29:46 <byte-> by definition, you don't even know if you have a body.
13:29:50 <byte-> all you know is that you're thinking now.
13:29:56 <jsnx> Cale: yeah, but there are implication relationships
13:29:58 <Cale> byte-: How do you know that? :)
13:30:02 <byte-> and even that's probably a stretch.
13:30:19 <__pao__> jsnx: this is logic in its pure form :-)
13:30:19 <Cale> jsnx: Well, we've devised various systems for inferring truth.
13:30:23 <byte-> Cale, nice try, but I pre-empted you :P
13:30:24 <chadz> lets drop the philo talk. it's seriously pointless.
13:30:26 <Cale> jsnx: But those systems are also arbitrary.
13:30:37 <chadz> logic is the only good component of philosophy.
13:30:41 <byte-> chadz, just like haskell!
13:30:46 <byte-> damn, you said something after that.
13:31:03 <byte-> my comment was referring to the line with "pointless" in it.
13:31:10 <Cale> Really, the only measuring stick of truth is success for one purpose or another.
13:31:10 <byte-> get it? pointless? point-less?
13:31:19 <chadz> pointfree is really hard to use in a sentence.
13:31:25 <monochrom> I don't get it.
13:31:29 <jsnx> Cale: no, because success is arbitrary
13:31:32 <byte-> pointless = pf
13:31:38 <Cale> jsnx: Quite.
13:31:44 <jsnx> byte-: "where did this anger come from" : http://www.abuddhistlibrary.com/Buddhism/C%20-%20Zen/Stories/Eleven%20Zen%20Stories/Zen%20Stories%20-%20Seishinkan%20Bujitsu.htm
13:31:44 <lambdabot> Title: Zen Stories - Seishinkan Bujitsu, http://tinyurl.com/ysrahg
13:31:52 <Cale> jsnx: (but I don't see why you'd say "no")
13:32:04 <jsnx> Cale: truth has little to do with success
13:32:08 <Cale> jsnx: My point is that there isn't just one truth.
13:32:13 <FunctorSalad> I tend to agree with Cale re success
13:32:14 <jsnx> Cale: hmmm
13:32:16 <__pao__> Cale: it reminds me of Bayesian inference :-)
13:32:18 <chadz> Cale: which means it's pointless to debate.
13:32:24 <yrlnry> There's a nice story Raymond Smullyan tells about arguing with Bouwsma about whether you can truly know anything.  Smullyan says that he is entirely prepared for the possibility that he might wake up tomorrow morning in a completely different body, say one with three arms.    Bouwsma says "Are you really prepared for that eventuality?"   Smullyan says that yes, he is.  Bouwsma asks "Have you bought another glove?"
13:32:33 <jsnx> Cale: i think rather, it is not possible to relate truth to the world
13:32:37 <__pao__> jsnx: you can define success metrics and mesure it
13:32:47 <jsnx> Cale: we can make true statements, but they do not map onto real things
13:32:51 <jsnx> not exactly
13:32:56 <Tac-Tics> Cale: can't you say there is just one truth, but an infinite set of bases in which to explore it?
13:33:05 <jsnx> truth exists in an imaginary world, like my kills in Halo 3
13:33:11 <sclv_> wtf at this channel right now.
13:33:27 <Cale> A nice example from science is Newtonian mechanics. This is a really successful theory, and it works very well, and it's still very useful, even though it's been superceded in various ways by general relativity and quantum mechanics.
13:33:27 <jsnx> like, take triangles
13:33:33 <byte-> jsnx, that "proof" essentially amounts to "things exist because they do!"
13:33:42 <jsnx> have you ever seen a wild triangle?
13:33:58 <byte-> ah yes.
13:34:00 <byte-> the wild triangle.
13:34:00 <jsnx> we are able to make true statements about triangles...but they do not apply to any actual figure
13:34:06 <Tac-Tics> jsnx: Once, when Donald Duck was exploring MathMagic Land
13:34:09 <jsnx> same for circles
13:34:10 <TSC> I think I saw one on Triangles Gone Wild
13:34:11 <byte-> most magestic of the geometryspecies.
13:34:19 <chadz> ^- this is what happens to a group of males nerds when no female counterparts exist.
13:34:26 <jsnx> lolz
13:34:27 <Tac-Tics> the Wild Circle has been extinct since's Euclid's time
13:34:40 <FunctorSalad> @slap chadz
13:34:40 * lambdabot smashes a lamp on chadz's head
13:34:43 <monochrom> Does _|_ exist?
13:34:43 <Cale> jsnx: Well, triangles in the sense that you mean them are parts of formal systems. We end up applying those formal systems in various ways.
13:34:46 <FunctorSalad> she is female.
13:34:48 <sclv_> @pl \x y z -> (\f g -> [g f]) x y <*> z
13:34:48 <lambdabot> ((<*>) .) . flip flip [] . ((:) .) . flip id
13:34:51 <jsnx> Cale: right
13:35:15 <jsnx> but the link between those formal systems and "success" in the real world is always tenuous
13:35:17 <sclv_> @unpl ((<*>) .) . flip flip [] . ((:) .) . flip id
13:35:17 <lambdabot> (\ o x -> (<*>) (((:)) (x o) []))
13:35:45 <jsnx> Cale: i think einstein said something like, "it is remarkable that mathematical physics even works at all"
13:35:54 <Cale> jsnx: Sure. Also, it seems quite meaningless to talk about whether those systems themselves are "true", as meaningless as asking whether my mug or chair is true.
13:36:01 <jsnx> Cale: well, no
13:36:02 <sclv_> @quote lamprey
13:36:03 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
13:36:05 <monochrom> There is this gap between the denotational "strict, non-strict" and the operational "eager, lazy".
13:36:07 <byte-> Cale, answer: no.
13:36:11 <__pao__> jsnx: can we conclude that we cannot give reality for granted?
13:36:14 <jsnx> Cale: i think true *only* has meaning in those systems
13:36:15 <chadz> @obfuscator = @unpl . @pl
13:36:15 <lambdabot> Unknown command, try @list
13:36:22 <Cale> jsnx: I agree.
13:36:32 <jsnx> __pao__: reality can not be described accurately
13:36:41 <Cale> byte-: Did I ask a question?
13:36:51 <monochrom> Some Haskell leaders are quick to jump in and say "watch out there, strict /= eager, non-strict /= lazy, you can have non-strict and eager too!"
13:36:55 <byte-> Cale, no, I wasn't responding to a question.
13:37:14 <FunctorSalad> jsnx: the word "true" probably originated in more practical activities
13:37:23 <jsnx> FunctorSalad: yes
13:37:24 <monochrom> OK, but that doesn't answer questions about how much time and memory a program uses, even just asymptotically.
13:37:25 <byte-> nuh uh!
13:37:28 <Tac-Tics> monochrom: I never understood why they split hairs like that. lazy just means nonstrict and memorized, right?
13:37:44 <byte-> well, this is getting boring.
13:37:44 <Cale> Tac-Tics: Not quite.
13:37:46 <byte-> bye bye.
13:38:03 <jsnx> FunctorSalad: my point is only, we are most able to "prove" truth when we are least able to use it
13:38:10 <Cale> Tac-Tics: It means outermost first evaluation with sharing of duplicated function parameters.
13:38:14 <EvilTerran> ... so sayeth the guy who couldn't shut up despite direct hints
13:38:16 <monochrom> Hiding behind that denotational faade, you can't even answer yes/no to: does head [1...] take O(1) space.
13:38:26 <Cale> (which is what gives you that memoisation effect)
13:38:36 * __pao__ is going to freshen up some philosophy http://en.wikipedia.org/wiki/Truth
13:38:36 <lambdabot> Title: Truth - Wikipedia, the free encyclopedia
13:38:44 <jsnx> EvilTerran: lolz, he will read the log and come back
13:38:49 <BMeph> EvilTerran: Sorry for jumping back on an old topic, but - you do know that lists have (at least) two different definitions for pure and <*>?
13:39:02 <EvilTerran> BMeph, there's ZipList, yes
13:39:12 <Cale> monochrom: Uh, if it evaluates, of course it does, because it's not a function of any parameter :)
13:39:15 <jsnx> __pao__: truth is surely much better explored through math -- let's leave philosophy in the realm of falsehood...
13:39:35 <Cale> monochrom: So there isn't an n to vary the size of the problem :)
13:39:37 <monochrom> It is very annoying. Every time someone asks an asymptotic complexity question, and someone fairly answers using a laziness assumption, a hair-splitter must jump out and say "watch out there! lazy /= non-strict".
13:39:52 <Cale> monochrom: hehe
13:39:59 <Tac-Tics> well, regardless, when you're explaining lazy evaluation to a beginner, the difference is negligible
13:40:16 <BMeph> EvilTerran: ZipList is a kludge, It's there, because otherwise, lists would have overlapping instances of Applicative.
13:40:18 <Tac-Tics> or at least, something you can save until the second semester of the course
13:40:22 <EvilTerran> BMeph, but if i ask \bot for @src [] pure, she should say pure x = [x], and if i ask her for @src ZipList pure, she should say pure = ZipList
13:40:25 <Cale> Laziness is a particular implementation of non-strict semantics, and it's the one which we generally use anyway.
13:40:30 <monochrom> If a question is asked in the denotational setting, of course don't assume lazy. But for bloody sake, the question is about complexity!
13:40:33 <EvilTerran> BMeph, i know all this
13:40:49 <Cale> What *was* the original question?
13:41:50 <__pao__> jsnx: good advice ... but the risk is to self exclude ourselves from social commitment :-)
13:42:13 <monochrom> It forces me to answer complexity questions with the prefix "using most compilers", just to be politically correct and leave no room for those hair-splitters to harass me. I hate that.
13:42:22 <BMeph> EvilTerran: Okay, I guess I just totally mis-read the gist of your question. Sorry. :)
13:42:54 <Tac-Tics> I wish I knew more about computational complexity
13:42:55 <monochrom> It's like when you do advanced algebra you need to prefix with "assuming AC" all the time.
13:43:02 <BMeph> @src ZipList pure
13:43:03 <lambdabot> Source not found. That's something I cannot allow to happen.
13:43:11 <BMeph> BOOO!!! :(
13:43:22 <EvilTerran> @src [] pure
13:43:22 <lambdabot> pure = return
13:43:30 <Tac-Tics> All they teach you in school is "counting for loops"....
13:43:37 <monochrom> Oh, by complexity questions I mean the beginner kind like "foldl (+) etc why does it blow the stack?"
13:43:58 <Tac-Tics> > foldl (+) [1..100000]
13:44:14 <lambdabot>  thread killed
13:44:16 <Tac-Tics> > foldr (+) [1..100000]
13:44:16 <lambdabot>   add an instance declaration for (Num [t])
13:44:24 <Tac-Tics> oops
13:44:25 <EvilTerran> "but it's tail-recursive!"
13:44:30 <int-e> > foldl (+) 0 [1..100000]
13:44:31 <lambdabot>  5000050000
13:44:32 <Tac-Tics> foldl (+)  0 [1..100000]
13:44:36 <Tac-Tics> damn
13:44:40 * EvilTerran wonders why that first one didn't error out sooner
13:44:41 <Tac-Tics> > foldr (+) 0 [1..100000]
13:44:42 <lambdabot>  5000050000
13:45:15 <Tac-Tics> that was a weird error... thread killed instead of "no instance Num [Int] "
13:45:24 <EvilTerran> lb does that sometimes
13:45:38 <EvilTerran> for stuff other than @run, too
13:48:31 <__pao__> good night everyone :-)
13:48:33 <bluestorm> hello
13:48:43 <miasma> is there some way in haskell to avoid the "redundancy" in the ADT definition (possibly some better way to do this) in this code (http://pastebin.com/m6795b885) -- it's not haskell but clean, but I hope you don't mind :)
13:48:52 <__pao__> ... if the timezone is correct ;-)
13:49:05 <bluestorm> i'm looking for a *simple* example of problems caused by wannabe-monads that don't respect some monad laws
13:49:32 <bluestorm> (by simple, i mean "not too specialized stuff" : CPS isn't simple here)
13:50:17 <bluestorm> i guess you get strange behaviors when using monadic libraries
13:50:31 <__pao__> EvilTerran: sorry... I lost your link on monads...
13:50:34 <bluestorm> do you have some reference about that, or even code samples ?
13:50:36 <sjanssen> bluestorm: that's the major issue
13:50:37 <EvilTerran> @where do
13:50:37 <lambdabot> http://www.haskell.org/onlinereport/exps.html#do-expressions
13:50:45 <sjanssen> bluestorm: also, refactoring can go bad
13:51:13 <__pao__> EvilTerran: haven't you suggested a link on semantics of monads?
13:51:16 <bluestorm> you mean, rewriting by using code-level equalities ?
13:51:24 <sjanssen> yeah
13:51:34 <bluestorm> hm
13:51:35 <EvilTerran> @go you could have invented monads
13:51:36 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:51:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:51:48 <sjanssen> eg. do x <- m; return (f x) should be the same as liftM f m
13:52:00 <__pao__> EvilTerran: that's it! thanks again
13:52:01 <sjanssen> but that might not hold in a tainted monad defn.
13:52:04 <EvilTerran> :)
13:52:07 <ski_> miasma : redundancy ?
13:52:08 <bluestorm> hm
13:52:11 <sjanssen> erm, that's a bad example
13:52:14 <sjanssen> @src liftM
13:52:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:52:19 <bluestorm> :p
13:52:21 <sjanssen> cuz that's the definition of liftM :)
13:52:42 <EvilTerran> return >=> f = f
13:52:49 <bluestorm> sjanssen: could you produce a tainted monad that would obviously fail (not behave as expected) with foldM for example ?
13:52:50 <Tac-Tics> > liftM (+1) (Just 1)
13:52:52 <lambdabot>  Just 2
13:52:54 <EvilTerran> ... = f >=> return --?
13:53:04 <miasma> ski_: i need to create a new type for the pattern matching and only use the type with which it is initialized
13:53:34 <EvilTerran> bluestorm, instance Monad Maybe where return x = Nothing; m >>= f = Nothing; ( -- there you go :P)
13:54:02 <EvilTerran> @src (>=>)
13:54:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:54:11 <ski_> miasma : i don't understand what that means
13:54:21 <miasma> oh :(
13:54:23 <ski_> @src Maybe (>>=)
13:54:24 <lambdabot> (Just x) >>= k      = k x
13:54:24 <lambdabot> Nothing  >>= _      = Nothing
13:54:24 <bluestorm> EvilTerran: hm
13:54:38 <Toxaris> EvilTerran: what's wrong with that Monad definition?
13:54:41 <EvilTerran> at least, i don't *think* that passes the laws
13:54:42 <ski_> oh
13:54:46 <bluestorm> it's not obvious that returning Nothing is an "unexpected behavior" then
13:54:59 <ski_> (f >=> g) x = f x >>= g  -- i presume
13:55:10 <EvilTerran> ski_, yeah, that seems likely
13:55:33 <EvilTerran> bluestorm, well, it fails "f =<< return x = f x"
13:55:39 <EvilTerran> er, actually, it doesn't...
13:55:42 <EvilTerran> hm.
13:55:45 <bluestorm> hm
13:55:49 <bluestorm> even if it did
13:55:50 <EvilTerran> wait, what am i talking about. yes it does.
13:56:01 <bluestorm> i want to show that "if you don't respect monad laws, things can go bad"
13:56:02 <EvilTerran> say f = Just
13:56:17 <bluestorm> i can't say "if you don't respect monad laws... laws equalities are wrong"
13:56:24 <bluestorm> not very impressive, at least
13:56:31 <EvilTerran> fine. take the problem with ListT
13:56:35 <bluestorm> hm
13:59:48 <sclv_> ... please! *rimshot*
14:01:25 <hpaste>  fadec pasted "Is there a catRights?" at http://hpaste.org/4889
14:02:22 <EvilTerran> > foldr (either (const id) (:)) [] [Left 1, Right 2, Right 3, Left 4, Right 5]
14:02:25 <lambdabot>  [2,3,5]
14:02:46 <fadec> evil
14:02:51 <EvilTerran> woo! i rule at pointsfree! :D
14:02:59 <fadec> very good!
14:03:04 <byorgey> sclv_: hehe
14:03:21 * EvilTerran doesn't think that evil at all
14:03:54 <EvilTerran> well, (const id)'s a bit ugly, i guess
14:04:15 <EvilTerran> (flip const) or (curry snd) also work...
14:04:17 <fadec> It's better than my catRights.
14:04:43 <byorgey> @type const id
14:04:44 <lambdabot> forall a b. b -> a -> a
14:04:52 <Toxaris> > [x | Right x <- [Left 1, Right 2, Right 3, Left 4, Right 5]]
14:04:53 <lambdabot>  [2,3,5]
14:04:57 <byorgey> @. djinn type const id
14:04:57 <lambdabot> f _ a = a
14:05:04 <Tac-Tics> @src either
14:05:04 <EvilTerran> Tox wins
14:05:05 <lambdabot> either f _ (Left x)     =  f x
14:05:05 <lambdabot> either _ g (Right y)    =  g y
14:05:14 <nelhage> @pl \a b -> b
14:05:15 <lambdabot> const id
14:05:42 <Toxaris> can we do something with EitherT or ListT?
14:05:57 <EvilTerran> catRights xs = [x | Right x <- xs] is probably what i'd use, actually
14:06:09 <Toxaris> hmm, ok there is no EitherT. too bad :(
14:06:23 <EvilTerran> that'd be ErrorT
14:06:35 <BMeph> can i has catRights? kthxbye
14:06:47 <Cale> There are some glaring omissions in the mtl.
14:06:59 <int-e> @hoogle [Either a b] -> ([a],[b])
14:06:59 <lambdabot> No matches, try a more general search
14:07:16 <fadec> yea, a splitEither would be nice
14:07:22 <Cale> Another thing which bothers me ever so slightly is that State, etc, use  (a,s) rather than (s,a) as a result type.
14:07:26 <fadec> or zipEither
14:07:39 <Tac-Tics> why does that bother you cale?
14:07:42 <Cale> (,) s is a Functor
14:07:59 * EvilTerran agrees there
14:08:13 <jsnx> > (,) 's'
14:08:13 <lambdabot>  Add a type signature
14:08:16 <Toxaris> fadec: how would zipEither work?
14:08:22 <chadz> hey -- if I wanted to use cabal-install, is there a way to specify extra-lib-dirs from the command line?
14:08:25 <Cale> :kind (,) Integer
14:08:35 <Cale> @kind (,) Integer
14:08:35 <lambdabot> * -> *
14:08:45 <jsnx> > (,) 's' :: (,) Char
14:08:45 <lambdabot>      `(,) Char' is not applied to enough type arguments
14:08:45 <lambdabot>     Expected kind `?'...
14:08:55 <fadec> Toxaris: [Either a b] -> [(a, b)]
14:08:59 <EvilTerran> @src catMaybes
14:08:59 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:09:00 <Cale> Hmm, I wonder if that instance is around...
14:09:03 <EvilTerran> heh
14:09:08 <Cale> fmap (*2) ("hello", 5)
14:09:10 <Cale> > fmap (*2) ("hello", 5)
14:09:11 <lambdabot>  ("hello",10)
14:09:14 <Cale> yep :)
14:09:14 <EvilTerran> fadec, yes, but how would it work?
14:09:16 <kib> Hi there, is there anyone under a Linux system how can help me ? [this is related to Haskell]
14:09:24 <Cale> kib: Most of us.
14:09:27 <jsnx> kib: i have linux
14:09:34 <jsnx> kib: it's cool
14:09:59 <kib> Ok, thanks. I'm just starting Haskell and I bough an ebook tonight, but can't read it.
14:10:04 <EvilTerran> kib, don't ask to ask, just ask! some of us are wary of committing to help before we know what your question is ;)
14:10:16 <kib> :)
14:10:19 <jsnx> kib: you need evince
14:10:26 <chadz> no cabal-pros around?
14:10:27 <jsnx> kib: or acroread
14:10:29 <Tac-Tics> > fmap (+1) (1,2)
14:10:30 <lambdabot>  (1,3)
14:10:49 <Tac-Tics> @src (,).fmap
14:10:49 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:10:52 <Cale> kib: Can you be more specific? Is there an error message? What file format?
14:11:13 <kib> no : Adobe Viewer ... I've bought this book : http://www.cs.nott.ac.uk/~gmh/#contact
14:11:14 <lambdabot> Title: Graham Hutton
14:11:17 <chadz> i bet you it's some horrible proprietary format
14:11:32 <EvilTerran> @src (,) fmap
14:11:32 <lambdabot> fmap f (x,y) = (x, f y)
14:12:06 <Toxaris> > (,) 's' :: a -> (,) Char a -- jsnx
14:12:07 <lambdabot>  Add a type signature
14:12:14 <Toxaris> :t (,) 's' :: a -> (,) Char a -- jsnx
14:12:15 <lambdabot> forall a. a -> (Char, a)
14:12:17 <kib> yes, in fact when I downloaded it, it's just and '.etd' file format. When I open it, it's an XML file just 1ko
14:12:22 <jsnx> Toxaris: lolz, i am a tard
14:13:05 <jsnx> kib: wow, you got taken
14:13:06 <Toxaris> why does \bot says "add a type signature" instead of "no Show instance"?
14:13:26 <chadz> haha
14:13:35 <chadz> adobe ebook reader format
14:13:38 <kib> Yes, and the ebook.com site did not say anything about it. http://www.adobe.com/products/digitaleditions/systemreqs/
14:13:43 <chadz> which has no official linux client
14:13:52 <kib> This is what I discovered later...
14:14:02 <Cale> kib: Ugh, the adobe e-book reader only runs on windows. I wonder if it's possible to extract the file as a PDF.
14:14:08 <kib> chadz : true
14:14:12 <jsnx> kib: etd is the "electronic theses and dissertations" format
14:14:25 <fadec> EvilTerran: it wouldn't
14:14:31 <jsnx> there ought to be a way to make a pdf out of it
14:14:51 <EvilTerran> okay :)
14:15:02 <monochrom> why do people invent formats that nobody uses?
14:15:03 <kib> yes, it's horrible, I can just read it online, but cannot copy/patse or whatever.
14:15:22 <chadz> kib: praise drm. it's the future
14:15:37 <kib> In fact, you can but you have some credits to copy
14:16:04 <EvilTerran> Toxaris, I think it's because it needs the value to be monomorphic to be sure there's no instance
14:16:19 <kib> I've written to the author, but got no answer yet.
14:16:33 <EvilTerran> as there might be an instance Show Bool -> (Char,Bool) for all it knows. or something.
14:16:51 <EvilTerran> (er, parenthesise as appropriate)
14:17:02 <Toxaris> EvilTerran: but it does know that there is no such instance.
14:17:18 <Toxaris> EvilTerran: at least, my state-of-the-art ghci knows :)
14:17:20 <EvilTerran> > (,) 's' :: Bool -> (Char,Bool)
14:17:22 <lambdabot>  <Bool -> (Char,Bool)>
14:17:25 <EvilTerran> surprise!
14:17:40 <Toxaris> :(
14:17:40 <Cale> kib: Perhaps you can run the e-book reader under wine? It's worth a shot.
14:17:48 <chadz> kib: find yourself a windows machine ;)
14:17:57 <EvilTerran> \bot has instance (Typeable a, Typeable b) => Show (a -> b), iirc
14:18:02 <jsnx> kib: acrobat reader can make a PDF out of it
14:18:11 <jsnx> or distiller?
14:18:11 <EvilTerran> and Typeable only works for monomorphic types
14:18:23 <Toxaris> is it possible to configure ghci to work exactly like \bot? would it take more then importing some module?
14:18:23 <Cale> What does that etd file contain? Is there perhaps a URL for a PDF inside it?
14:18:30 <Cale> Surely it's not the whole book.
14:18:30 <chadz> it's drm url, i think
14:18:30 <jsnx> there's documentation on the intarnets for it
14:19:11 <EvilTerran> Toxaris, well, you'd need the \bot sources. should be possible to make a file that import+exports everything @run has fairly easily.
14:19:19 <kib> jsnx : no impossible. I just have a 1 Ko xml file...it's the one wich is used by their reader to download the pdf (i suppose so)
14:19:28 <EvilTerran> there's ghci-on-acid, too, but i don't know what state the project's in
14:19:34 <BMeph> :t (,)
14:19:35 <jsnx> kib: oic
14:19:36 <lambdabot> forall a b. a -> b -> (a, b)
14:19:48 <Cale> kib: Anything interesting in that XML?
14:20:28 <kib> wait, I'll paste it somewhere and hide some parts
14:20:32 <chadz> kib: go dvd john on it
14:20:43 <kib> ??
14:20:48 <chadz> dominate the drm.
14:20:53 <chadz> crack the codes
14:20:53 <ehird`> if i have an IORef and I want to extract it's value out of it -- but in a function returning a non-IO value, how could i do that?
14:21:02 <EvilTerran> Toxaris, have a look at <http://www.cse.unsw.edu.au/~dons/lambdabot.html>
14:21:07 <kombinator> Some of you might be interested in TIOBE Programming Community Index for January 2008 that also mentions Haskell: http://www.tiobe.com/tpci.htm (and a story on /. that covers it: http://developers.slashdot.org/article.pl?sid=08/01/09/1819221 )
14:21:09 <lambdabot> Title: TPCI - TIOBE Programming Community Index
14:21:12 <notsmack> ehird`: you shouldn't
14:21:14 <EvilTerran> specifically the bit on GOA
14:21:21 <ehird`> notsmack: :-)
14:21:50 <ehird`> notsmack: so, what *should* i do
14:21:53 <EvilTerran> ehird`, pass the value referenced by the IORef in as a parameter from an impure bit of code (ha ha only serious)
14:22:05 <ehird`> EvilTerran: hah
14:23:00 <kib> http://dpaste.com/30433/
14:23:20 <ehird`> EvilTerran: That's evil, so I guess your name fits :P
14:23:30 <EvilTerran> it's not evil, though; it's the right thing to do
14:24:15 <monochrom> bookfileurl is likely pointing to the book itself
14:24:27 <ehird`> EvilTerran: Did I mention: the function in question is "show"
14:24:28 <ehird`> :-)
14:24:34 <EvilTerran> well, then, don't use show
14:24:38 <monochrom> though you also need those voucher, nounce, etc. to prove that you're a purchaser.
14:24:40 <EvilTerran> call your function something else
14:24:52 <kib> yes, but I've tied and got an error
14:24:58 <EvilTerran> ... what is it with people trying to do IO from Show these last few days?
14:25:02 <kib> 'tried', sorry
14:25:17 <ehird`> EvilTerran: i'm not doing IO from show
14:25:18 <ehird`> :|
14:25:25 <ehird`> (that WOULD be ridiculous)
14:25:29 <EvilTerran> reading an IORef counts as IO
14:25:38 <EvilTerran> hence the IO type
14:25:39 <ehird`> OK, I guess.
14:26:08 * Cale looks around for PDF password cracking tools.
14:26:39 <BMeph> Talk to y'all later...
14:26:49 <lament> #haskell^H^H^H^H^Hckers
14:27:01 <EvilTerran> you could, say, make a class ShowIO a where showIO :: a -> IO String
14:27:15 <EvilTerran> instance Show a => ShowIO a where showIO = return.show
14:27:47 <EvilTerran> well, that'd require overlapping instances, if you wanted to add any more ShowIO instances
14:27:51 <ehird`> i could also rework the thing that requires me to do this in the first place.
14:27:58 <EvilTerran> indeed.
14:28:05 <EvilTerran> but why not generalise?
14:28:07 <EvilTerran> :P
14:28:43 <Cale> kib: I take it you didn't get a password along with the book?
14:29:04 <EvilTerran> class Monad m => ShowM m a where showM :: a -> m String -- even?
14:29:12 <ehird`> EvilTerran: the basic problem is that i have a specific case of a 'data' which has mutable data in. since, for an unchangable, non-reworkable reason the functions acting on these will be IO, I just made them IORefs
14:29:29 <kib> hum...no. Just a username and a password for ebook.com, that's all.
14:29:40 <Cale> kib: Is the file that we're looking at ebx.etd?
14:29:50 <fourbissime> hi people. I can't find back how to avoid the problem of having (-5) being of type Num a => a -> a rather than Num a => a ... can anyone remind me ?
14:29:53 <Cale> kib: Since that URL gives me a bad request error now.
14:29:54 <EvilTerran> newtype WrapShow a = WrapShow { unWrapShow :: a }; instance (Monad m, Show a) => ShowM m (WrapShow a) where showM = return.show.unWrapShow -- and then go crazy with other instances :D
14:30:06 <ehird`> EvilTerran: you are ridiculous
14:30:09 <ehird`> :P
14:30:22 <kib> I don't know, I suppose it is located there.
14:30:27 <EvilTerran> it's the tactic Arrow does, with its Kleisli class...
14:30:31 <Cale> all right
14:30:34 <EvilTerran> er, s/class/newtype/
14:31:19 <EvilTerran> ehird`, why do you have to use show in particular? why not use your own function?
14:31:44 <ehird`> EvilTerran: well, i guess i could: it'd just be nice to be able to play about with them in the prompt
14:32:02 <Toxaris> > negate 5 -- fourbissime
14:32:04 <lambdabot>  -5
14:32:06 <ehird`> EvilTerran: (the reason there's mutable entries in a 'data', and the reason the functions are IO, by the way, is because it's an interpreter for a simple imperative language)
14:33:01 <Toxaris> fourbissime: afaik there is no real solution.
14:33:09 * EvilTerran wonders if it's possible to override which function ghci uses for that with -XNoImplicitPrelude
14:33:25 <EvilTerran> ...hm, seems not
14:33:34 <fourbissime> ok so all I have to do is using a lambda function
14:33:36 <fourbissime> thanks
14:33:42 <EvilTerran> ?type (-1)
14:33:44 <lambdabot> forall a. (Num a) => a
14:33:51 <EvilTerran> ?type subtract 1
14:33:52 <lambdabot> forall t. (Num t) => t -> t
14:33:58 <ehird`> EvilTerran: if you want to suggest another way i could do all that, feel free :-)
14:33:59 <EvilTerran> ?type (-)
14:33:59 <lambdabot> forall a. (Num a) => a -> a -> a
14:34:02 <EvilTerran> ?type negate
14:34:03 <lambdabot> forall a. (Num a) => a -> a
14:34:22 <fourbissime> got to go ... bye
14:34:32 <EvilTerran> ehird`, does your language have to do anything explicitly IO?
14:34:42 <EvilTerran> say, opening filehandles, or using sockets, or whatever?
14:34:52 <EvilTerran> s/have to//
14:34:59 <ehird`> EvilTerran: well, it can have them if i decide to add it later, but it definately DOES have console I/O
14:35:08 <monochrom> Yeah, if you just have variables, no talkie to outside world, you can thread state and be pure.
14:35:27 <EvilTerran> ... and if you've just got one input and one output stream, you can make that look pure too
14:35:36 <EvilTerran> (i think)
14:35:48 <Toxaris> well, IO looks pure, too. isn't that the point of IO?
14:35:54 <EvilTerran> input, it'd just be a case of using getContents or whatever
14:36:05 <monochrom> Actually, if you want talkie to outside world, you can use continuation-passing style, and still be pure. :)  However, you then need a "runtime" to do the talkie.
14:36:40 <EvilTerran> Toxaris, indeed, but we're trying to get out of threading IO around here
14:36:41 <ehird`> EvilTerran: it's pretty likely that i'll end up adding file IO too
14:37:00 <ehird`> monochrom: funny, i'm writing most of it in CPS anyway because the languge has continuations
14:37:14 <gwern> I think we need to do some SEO for hackage... the first hit is <http://hackage.haskell.org/ModHackage/Hackage.hs?action=info&pkg=XmlRpc&pkgVersion=2005.5.5>
14:37:14 <lambdabot> http://hackage.haskell.org/ModHackage/Hackage.hs?action=info&pkg=XmlRpc&pkgVersion=2005.5.5>
14:37:20 <EvilTerran> ehird`, okay, then i guess you're sunk. adding "showIO $ " or whatever to the start of the lines you want to print hopefully won't be *too much* of a hassle
14:37:53 <monochrom> Using the IO monad is still a very easy-to-code way. :)
14:37:54 <EvilTerran> ehird`, although, if you're just using it for debugging purposes...
14:37:55 <ehird`> EvilTerran: should I be using IORefs, anyway?
14:38:12 <EvilTerran> ... and you can guarantee that the values pointed to by the refs won't change in the course of evaluation...
14:38:19 * EvilTerran whispers
14:38:30 <EvilTerran> (...you could use unsafePerformIO)
14:39:04 <EvilTerran> ?hoogle unsafe
14:39:05 <lambdabot> Language.Haskell.TH.unsafe :: Safety
14:39:05 <lambdabot> Language.Haskell.TH.Lib.unsafe :: Safety
14:39:05 <lambdabot> System.IO.Unsafe :: module
14:39:10 <EvilTerran> ?hoogle+
14:39:10 <lambdabot> Data.ByteString.Unsafe :: module
14:39:10 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
14:39:10 <lambdabot> Language.Haskell.TH.Syntax.Unsafe :: Safety
14:39:13 <Toxaris> <ehird`> EvilTerran: (the reason there's mutable entries in a 'data', and the reason the functions are IO, by the way, is because it's an interpreter for a simple imperative language)
14:39:14 <EvilTerran> hm.
14:39:32 <EvilTerran> ehird`, if you're gonna end up in IO anyway, you may as well use IORefs
14:39:59 <ehird`> alright then
14:40:02 <ehird`> one question
14:40:05 <EvilTerran> ST is nice if you're not doing any *real* IO, because it's possible to get values out of ST again as it encapsulates the impurity
14:40:08 <ehird`> is there an io-unwrapper-thing?
14:40:15 <ehird`> there's something like that for StateT, runState or something
14:40:19 <EvilTerran> read up; i just suggested unsafePerformIO
14:40:25 <EvilTerran> ?hoogle unsafePerformIO
14:40:25 <ehird`> i could write ioShow or whatever, then make show unwrap that
14:40:27 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:40:28 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
14:40:36 <ehird`> clever, clever.
14:40:47 <EvilTerran> but be aware that it *is* unsafe!
14:41:06 <monochrom> Gosh, Hughes's pretty printing paper is way more than pretty printing. It is a subject of term-oriented programming.
14:41:18 <EvilTerran> your unsafePerformIO'd actions may be evaluated repeatedly, or not at all...
14:41:38 <ehird`> EvilTerran: ioShow will never actually do any *destructive* IO
14:41:42 * monochrom will have to spend 10x more time than planned to read it, since it is a 10x bigger subject.
14:41:45 <ehird`> the most it'll do is access something from an IORef
14:42:16 <ehird`> and it'll only be used for making ghci usage less hideous
14:42:17 <ehird`> :)
14:42:21 <EvilTerran> if you're only using Show to make using ghci easier (ie only for debugging, basically), there's no real harm in using unsafePerformIO
14:42:35 <EvilTerran> but be aware that it's dodgey; don't use it for anything where sanity matters
14:43:01 <EvilTerran> at least it's better than
14:43:07 <EvilTerran> ?hoogle unsafePointer
14:43:08 <lambdabot> No matches found
14:43:10 <EvilTerran> er
14:43:14 <EvilTerran> ?hoogle unsafePtr
14:43:14 <lambdabot> No matches found
14:43:16 <EvilTerran> grr
14:43:23 <Toxaris> monochrom: yes, pretty printing is just the example used :) I liked that paper very much. (Maybe I should read it again)
14:43:39 <ehird`> actually, another idea:
14:43:47 <ehird`> use the generic "deriving (Show)" so ghci is bearable
14:43:51 <ehird`> and just have my custom-show
14:44:00 <ehird`> but this way is more hacky and therefore fun :)
14:44:07 <EvilTerran> never mind
14:44:34 <EvilTerran> yeah, quite
14:45:11 <monochrom> It is consistent with the whole Haskell learning culture.  "I just want to do a bit of I/O."  Ends up becoming a category theory expert along the way.
14:45:48 <EvilTerran> ehird`, also, maybe have a look at trace
14:45:49 <EvilTerran> ?hoogle trace
14:45:49 <lambdabot> Debug.Trace.trace :: String -> a -> a
14:45:49 <lambdabot> Debug.Trace :: module
14:45:49 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
14:46:16 <monochrom> But that's ok!  "I just want to go to the moon" also ends up advancing many unsuspected fronts.
14:46:20 <EvilTerran> trace "..." foo = foo, but it prints its first parameter on stderr when it's sparked
14:46:37 <Tac-Tics> The problem with the IO monad is that it allows your code to interact with the rest of the world..... something that Haskellers try their hardest to avoid!
14:46:44 <monochrom> Very likely computer hardware and numerical methods got a big boost just by going to the moon.
14:46:46 <EvilTerran> (by way of unsafePerformIO)
14:46:57 <ehird`> monochrom: hehe, yeah... 'I just want mutability'
14:46:58 <ehird`> BOOM
14:47:02 <EvilTerran> ?src trace
14:47:03 <lambdabot> trace string expr = unsafePerformIO $ do
14:47:03 <lambdabot>     hPutStrLn stderr string
14:47:03 <lambdabot>     return expr
14:47:10 <ehird`> (last time i said 'mutable' in #haskell there was a netsplit...)
14:47:30 <EvilTerran> it made the (user)table go micro...
14:47:36 <EvilTerran> (sorry)
14:48:37 <litb> ah, hPutStrLn can print somethin to a given fd?
14:48:57 <monochrom> Hilbert foresaw it. One day there was a party. Someone chatted with him, what would be the most worthwhile project for humankind now? He answered going to the moon, since it would motivate solving many, many problems.
14:49:58 <monochrom> I learned arrow by learning HXT.
14:51:45 <jsnx> say i have a list of lists, and i want to concatenate all this lists -- what is the idiomatic way to do that?
14:51:56 <jsnx> oops, sorry
14:51:58 <Toxaris> ehird`: In a toy project, I once used data Value a = ... | Value a | ... as type of my runtime values
14:52:05 <jsnx> i know how to do that in haskell :)
14:52:13 <ehird`> ToxicFrog: hah
14:52:19 <ehird`> er
14:52:20 <ehird`> toxaris
14:52:20 <Toxaris> ehird`: then I used Value (IORef ImmutableValue) during evaluation
14:52:31 <ehird`> heh
14:52:33 <ehird`> amusing
14:52:55 <Cale> ugh, apparently nobody's cracked this version of Adobe's DRM yet.
14:53:06 <Cale> (EBX_HANDLER)
14:53:42 <Toxaris> ehird`: and a resolveHeap :: Value (IORef ImmutableValue) -> IO (Value ImmutableValue) function to get rid of the IORefs after evaluation
14:54:40 <Cale> (128 bit v.3)
14:54:51 <monochrom> Is it good encryption?
14:55:23 <Cale> Well, it's DRM, so it really shouldn't matter how good the encryption is, since there has to be a way to actually read the document.
14:55:43 <Toxaris> ehird`: but today, I would do something involving a MonadHeap typeclass :)
14:55:48 <monochrom> Oh, right.
14:56:22 <ehird`> Toxaris: my IORefs are OK because all the functions are going to have to be IO anyway
14:56:27 <ehird`> (also continuation-passing style, heh.)
14:56:39 <Toxaris> ehird`: except for show :)
14:56:41 <ddarius> Cale: Print screen
14:56:41 <monochrom> Err, no, not right. Maybe document and decryption key stored separately. Purchasers are given both.
14:56:59 <ddarius> monochrom: And then they can sell/give away the key.
14:57:02 <monochrom> Err nevermind, the assumption is we are purchasers already.
14:57:07 <ehird`> Toxaris: hehe
14:57:15 <Cale> ddarius: The problem is that kib has an e-book copy of Hutton's book which he can't use because he's on a linux machine.
14:57:49 <ehird`> Toxaris: I have "-- mwahahaha!" a line before the unsafePerformIO show definition, so I think i'm covered
14:57:51 <ehird`> ;)
14:57:58 <ddarius> Cale: I wasn't being serious
14:58:19 <Cale> ddarius: Well, it would work -- you could do a bunch of that and make yourself a djvu or something :)
14:58:28 <monochrom> Sadly, print screen is the most practical solution at the moment.
14:59:13 <ddarius> Cale: Yes, it, or obvious variations, is the sledgehammer.
15:01:22 <Kolji[Z]> what schools do teach functional programming?
15:01:26 <ehird`> By the way, a mutable tuple in the language is currently an (IORef (Foo,Foo)) where Foo is my data type
15:01:45 <ehird`> is there a way to get a proper, seperate type without just making a ImmutablePair and then (IORef ImmutablePair)?
15:02:46 <ddarius> ehird`: I don't understand your question.
15:02:59 <ehird`> ddarius: I'm using a haskell (a,b) tuple to represent a pair
15:03:07 <ehird`> whereas i'd rather have TupleThing Foo Foo
15:03:16 <ehird`> but, of course, it needs to be immutable
15:03:18 <ehird`> err
15:03:20 <ehird`> mutable
15:03:20 <ehird`> ok
15:03:21 <ehird`> my wording is crap
15:03:56 <ehird`> if I had immutable tuples, then i'd have "| Tuple Foo Foo" in my Foo definition but since I'm using an IORef I have "| Tuple (IORef (Foo,Foo))"
15:04:13 <Toxaris> data Value = Number | Char | Tuple Ref Ref | ...
15:04:17 <Toxaris> type Ref = IORef Value
15:04:33 <ehird`> Toxaris: hmm, i guess so... but then Ref has to be a valid Value.
15:04:35 <ddarius> Toxaris: That's a bit different.
15:04:37 <ehird`> wait, no...
15:04:39 <ehird`> hmm...maybe
15:04:42 <ehird`> no, i don't think that would work
15:04:48 <ehird`> no, definately not... i don't think
15:05:13 <ehird`> ... maybe though
15:05:20 <Toxaris> ehird`: maybe you should think, it sometimes help :)
15:05:39 <ehird`> actually, i think that will work
15:05:40 <Riastradh> ehird`, let me guess: you are implementing a dynamically typed impure language, and you want to use `show' to display mutable values recursively in your language.  Am I anywhere near what you are doing?
15:05:47 <ddarius> ehird`: That would give you (IORef Foo,IORef Foo) roughly.
15:05:50 <Toxaris> ddarius: I assume ehird` tries to implement some lisp-like language, and the tuples should work like lisp cons cells
15:06:13 <ddarius> Toxaris: Probably, I didn't say your code was bad, just different from what he specified.
15:06:42 <ehird`> ddarius: mm, but what about functions that deal with those tuples?
15:06:49 <ehird`> a bit fiddly
15:07:17 <Toxaris> mutable state is fiddly
15:07:40 <ehird`> :)
15:07:49 <ehird`> Riastradh: the 'show' problem was quite a while back now :)
15:07:50 <Riastradh> ehird`, I ought to have written some explanatory text to go along with it, but it may be enlightening to ponder <http://mumble.net/~campbell/tmp/Scheme.hs> for a while.
15:07:53 <ddarius> What is the problem with Tuple (IORef (Foo,Foo)) ?
15:08:07 <EvilTerran> Riastradh, he just wants to define show so it's easier to experiment with expressions in his language at the ghci prompt
15:08:12 <ehird`> ddarius: nothing, just doesn't 'reflect' my immutable version though
15:08:16 <ehird`> EvilTerran: honestly, that's all over now :P
15:08:42 <EvilTerran> okok :)
15:08:49 <ddarius> You want the values of the Tuple case to represent both mutable and immutable pairs?
15:08:54 <Toxaris> data Value v = ... | Tuple v v | ...
15:09:09 <Toxaris> data Fix t = ...
15:09:21 <Toxaris> type ImmutableValue = Fix Value
15:09:26 <EvilTerran> er
15:09:33 <ehird`> ddarius: no
15:09:36 <Toxaris> type MutableValue = Fix (Value `O` IORef)
15:09:37 <ddarius> newtype Fix f = In (f (Fix f))
15:09:41 <Toxaris> aproximately :)
15:09:49 <ehird`> ddarius: i'm just saying that when i added state my definitions changed quite a bit
15:10:01 <ddarius> ehird`: State has a tendency to do that.
15:10:23 <ehird`> Riastradh: isn't a scheme vector an array whereas you're using a list there? just something i noticed
15:10:35 <Toxaris> ddarius: given this definitions, it's clear for me why it should be (IORef Value, IORef Value) and not IORef (Value, Value)
15:10:42 <Riastradh> ehird`, it is an approximation; that wasn't really the point of the exercise.
15:11:07 <ehird`> Toxaris: I guess you're right.
15:11:19 <ddarius> Toxaris: I agree with you that that is probably the better definition.  All I was saying was that that wasn't what he was asking for earlier.
15:11:20 <ehird`> it stops you doing funky modifyIORef oneliners though :-)
15:11:25 <Riastradh> ehird`, count steps in terms of the number of access commands: then vectorRef runs in constant time.
15:11:46 <Riastradh> ehird`, on the other hand, a hypothetical listRef, in terms of repeated applications of car & cdr, would run in linear time.
15:12:06 <ehird`> Riastradh: true
15:12:08 <Toxaris> ddarius: ok fine :) sorry, you already maked that clear.
15:16:55 <ehird`> hmm, from the looks of it i need a non-IO monad
15:17:29 <ddarius> ehird`: That's doubtful.
15:17:39 <ehird`> ddarius: yeah just thought about it a bit and it is :-)
15:18:16 <ddarius> It will, however, probably be pretty helpful to stack some monad transformers on top of IO.
15:19:31 <gwern> how can you tell what version of cabal is actually being used when you do a 'runhaskell'?
15:19:46 <dons> ghc-pkg list Cabal ?
15:20:41 <Riastradh> ehird`, it may be worth your while to define a general type like Scheme.hs's Command, for any action that is dependent upon the state of the Lisp system.
15:20:45 <gwern> I don't trust it, is the problem
15:20:54 <ddarius> That's far less exciting than my approach of replacing each with a script that deletes all the others and letting them battle it out.
15:20:55 <Riastradh> (or whatever your object-language is)
15:21:24 <gwern> it claims 3 cabals installed for ghc 6.9, but I don't think I'm using  6.9
15:21:49 <gwern> and if I run it sudo, it lists two different cabals, which one is it actually using?
15:22:01 <gwern> (Cabal-1.2.3.0 &  Cabal-1.3.2)
15:27:26 <dcoutts__> gwern: defaults to latest exposed package version
15:29:11 <johnny91> `sup all?
15:31:17 <pastorn> @logs
15:31:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:32:06 <pastorn> not exactly what i was looking for
15:32:09 <pastorn> @log
15:32:09 <lambdabot> Maybe you meant: bug let msg yow
15:32:17 <pastorn> @commands
15:32:17 <lambdabot> Unknown command, try @list
15:32:22 <pastorn> @list
15:32:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:32:36 <BMeph> pastorn: You mean http://tunes.org/~nef/logs/haskell/
15:32:37 <lambdabot> Title: Index of /~nef/logs/haskell
15:41:49 <dufflebu1k> I have a Set and a member of the set, is there an efficient way to find the element just smaller and the element just bigger than the one I have?
15:42:36 <dufflebu1k> It looks like using Set.split might be the best way, but I'm not sure how efficient that is
15:45:03 <Saizan> dufflebu1k: yes split and findMin/findMax, the efficiency is in the documentation O(log n)
15:47:10 <monochrom> Since Set is immutable, I wonder if it is beneficial to expose a cursor.
15:47:26 <Saizan> monochrom: toList?
15:47:54 <Saizan> ah, a cursor that starts from a random point?
15:47:57 <dufflebu1k> Saizan: With toList searches are linear
15:48:26 <chadz> anyone know how to specify extra-lib-dirs for cabal-install on the command line?
15:48:53 <monochrom> split followed by findMin may be redundant work, could be saved by exposing a cursor.
15:49:34 <sw17ch> Do haskell arrays use width*height*sizeof(element) memory or is it different?
15:49:50 <bench1> i have a program that used to work with ghc 6.8.1 but doesnt' work anymore with 6.8.2
15:49:56 <monochrom> Alternatively, an additional version of split giving ([a], [a]) is cool enough.
15:50:05 <bench1> how do i go about finding out the issue/cause?
15:50:28 <monochrom> Then again, probably not a big deal.
15:50:31 <Saizan> bench1: define "doesn't work"
15:50:38 <Cale> sw17ch: Unboxed ones do.
15:51:05 <monochrom> Make sure complete re-build of your programs. Clean out all *.hi and *.o
15:51:25 <sw17ch> I'm trying to find a good way to map out a Cartesian space but would prefer to make it unbounded
15:51:27 <monochrom> If problem persists, then it's a real issue.
15:51:28 <Cale> sw17ch: Boxed arrays use (#elements)*sizeof(pointer) memory, plus the memory for the elements (which might be shared)
15:51:50 <bench1> Saizan, the program tried to fetch a web page via http, but now i'm getting 'connection refused (WSAECONNERFUSED)' error
15:52:09 <bench1> i thought about this being a firewall issue, but policy hasn't changed at all
15:52:39 <sw17ch> Cale: thanks. :)
15:52:45 <monochrom> Do you still have 6.8.1 and can verify program still works?
15:52:49 <dufflebu1k> bench1: I'd probably start with a traffic sniffer and see what's exchanged
15:53:34 <bench1> dufflebulk,which traffic sniffer would you suggest? i haven't used one before
15:53:57 <Cale> sw17ch: Have you considered the possibility of just using functions from points to values?
15:54:32 <Cale> (of course, depending on how you construct the functions, memory and time performance would vary considerably)
15:54:59 <Cale> After all, arrays are just functions which are stored in a particular way :)
15:55:20 <dufflebu1k> bench1: wireshark is what I've used before (although I ised it before they renamed it over a year ago)
15:55:29 <LoganCapaldo> all data are functions ;P
15:56:29 <Cale> Another reasonable option is something like a quadtree.
15:56:36 <sw17ch> Cale: i was thinking about using quadrees
15:56:38 <sw17ch> well, there you go =)
15:56:44 <sw17ch> :P
15:56:49 <bench1> dufflebulk, thanks, i'll give that a try
15:57:08 * monochrom has upgraded from 6.8.1 to 6.8.2 :)
15:57:37 <sw17ch> thanks Cale
15:58:55 <dons> anyone want to knock together a version of this? http://brad.livejournal.com/2354680.html?view=14407416#t14407416 ?
16:00:03 * Nafai looks
16:00:44 <Nafai> Yeah, that could be fun
16:01:35 <conal> sw17ch: see Pan (http://conal.net/Pan) for unbounded, continuous images.
16:01:36 <lambdabot> Title: The Pan Home Page
16:02:18 <conal> i'm working now on a new version of Pan using an infinite data representation.  Still continuous & unbounded.
16:02:29 <cjb> dons: there's already a Haskell version in the comments
16:02:59 <dons> ah ha
16:06:46 <aFlag> are there trigonometric functions that work with degrees instead of radians?
16:07:11 <LoganCapaldo> radians > degrees
16:07:20 <lament> aFlag: you can convert quite easily.
16:07:29 <monochrom> mysin = sin . (* (180/pi))
16:08:05 <monochrom> myasin = (* (180/pi)) . asin
16:08:48 <monochrom> The use of radians follows the IEEE 754 standard.
16:08:52 <LoganCapaldo> @type sin
16:08:55 <lambdabot> forall a. (Floating a) => a -> a
16:09:09 <conal> aFlag: and generalize with defFun f = f . (* (180/pi))
16:09:20 <conal> (i mean degFun)
16:09:22 <aFlag> hm, I see
16:09:44 <conal> arcDegFun f = (* (180/pi)) . f
16:10:37 <LoganCapaldo> [mysin, mycos, mytan] = map degFun [sin, cos, tan] -- is this a valid way to creat top level bindings?
16:10:47 <Saizan> yes
16:10:59 <EvilTerran> you'll get funny looks, but you can
16:11:21 <LoganCapaldo> who would give me a funny look for that?
16:11:36 <LoganCapaldo> it's just the value version of a,b,c :: type :p
16:11:36 <Saizan> hitler
16:11:51 <BMeph> You can Really freak people out, and call it "zipWith1" instead of "map"... ;)
16:12:07 <EvilTerran> people who aren't used to pattern-matching in =s
16:13:02 <EvilTerran> seeing as in most cases patterns only appear as a parameter/in a case-of/in a <- binding
16:13:54 <EvilTerran> [...] = foo as a top-level is a bit funny semantically-speaking, i guess
16:13:54 <EvilTerran> > let [x,y] = [1] in x
16:13:57 <lambdabot>   Irrefutable pattern failed for pattern [x, y]
16:14:14 <EvilTerran> eh. ignore me, have your fun :)
16:14:35 <monochrom> Haskell freaks people out. Basic premise.
16:14:38 <EvilTerran> > let x:~[y] = [1] in x
16:14:39 <lambdabot>   Not in scope: data constructor `:~'
16:14:42 <BMeph> conal: Nice key point, "images are functions." It makes me feel like my idea of "strings are functions" may be useful somewhere.
16:14:42 <EvilTerran> > let x: ~[y] = [1] in x
16:14:43 <lambdabot>  1
16:15:07 <monochrom> Lazy evaluation. IO monad. Strings are Lists.
16:15:14 <EvilTerran> ?src ShowS
16:15:14 <lambdabot> type ShowS = String -> String
16:15:57 <EvilTerran> monochrom, except when they're bytestrings, or otherwise overloaded constants :D
16:15:58 <monochrom> Some people say recursion already freaks them out.
16:16:03 <LoganCapaldo> i like ShowS
16:16:36 <monochrom> top-level [x,y] = [1,2] is nothing compared to recursion.
16:17:36 <monochrom> I don't advocate freaking people out on purpose, but if a programmer doesn't fear the likes of recursion and IO monad then many unusual things are fair game.
16:18:11 <monochrom> Don't underestimate the intelligence of those who have chosen to spend more time on Haskell.
16:19:01 <lament> recursion freaks me out
16:19:13 <lament> it's like, the program is running ITSELF! WTF!
16:19:26 <EvilTerran> me freaking out freaks me out
16:19:28 <monochrom> The program also writes itself.
16:19:36 <ddarius> BMeph: Here's a small exercise.  What is zipWith0?
16:19:58 <monochrom> Ever heard of: Once you get pass recursion, the program almost writes itself ? :)
16:20:02 * EvilTerran thinks he knows
16:20:19 <ac> ddarius: id?
16:20:26 <EvilTerran> ?type zipWith3
16:20:28 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:20:29 <EvilTerran> ?type zipWith
16:20:30 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:20:36 <aFlag> irc freaks me out, like all my characters come all the way from here to anywhere in the world in less than a second!
16:20:39 <byorgey> ?type map
16:20:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:20:40 <EvilTerran> zipWith1 :: (a -> b) -> [a] -> [b]
16:20:42 <Liskni_si> ddarius: repeat?
16:20:42 <ddarius> ac: Nope.
16:20:43 <BMeph> ddarius: "zipWith0" is obviously, the pure function of the ZipList Applicative - repeat. ;)
16:20:47 <EvilTerran> zipWith0 :: a -> [a]
16:20:50 <ddarius> Correct.
16:21:18 <Saizan> it could just be :[]
16:21:43 <EvilTerran> but that wouldn't be consistent
16:21:57 <BMeph> Saizan: That's the list monad's version - that's return .
16:22:14 <EvilTerran> the list has to be the same length as the shortest input list
16:22:17 <aFlag> zipWith1 and map do the same thing?
16:22:27 <EvilTerran> in this case, then, length (zipWith0 ...) = _|_ :P
16:22:38 <LoganCapaldo> zipWith0 isn't iterate?
16:22:39 <ddarius> aFlag: To be consistent they would.
16:22:40 <EvilTerran> aFlag, there's no zipWith1 function really
16:22:45 <ac> @index zipWith1
16:22:46 <lambdabot> bzzt
16:22:52 <BMeph> aFlag: Think of "zipWith" as "zipWith2". Then look at zipWith3.
16:22:58 <ddarius> LoganCapaldo: EvilTerran already demonstrated how the types progress.
16:23:23 <BMeph> Just abstract it to what zipWith1 should do, and it's exactly what map does.
16:23:31 <EvilTerran> zipWithN :: (a1 -> a2 -> ... -> aN -> b) -> [a1] -> [a2] -> ... -> [aN] -> [b]
16:23:59 <aFlag> oh, I see
16:24:04 <hpaste>  (anonymous) pasted "connection" at http://hpaste.org/4890
16:24:44 <BMeph> The point is, that not only do the type signatures match up, but what the function does matches.
16:25:00 <ddarius> Saizan: As BMeph said, (:[]) would be return.  return is liftM0
16:25:07 <bench1> anyone can tell me how to go about finding out the issue?  http://hpaste.org/4890
16:25:28 <bench1> i've tried packet tracing, but it appears that there is no packet being sent
16:25:56 <EvilTerran> is your firewall set to allow your haskell interpreter/compiled program to make outgoing connections?
16:26:50 <conal> BMeph: what's your idea of "strings are functions"?  do you mean functions naturals (indices)?
16:26:57 <Saizan> ddarius: well i'd say that i don't see a real connection with the length of the result list in the N > 0 cases
16:27:07 <bench1> EvilTerran, yes,
16:27:15 <EvilTerran> Saizan, min [] = +Inf
16:27:36 <bench1> in the past, when i tried to run the program, my firewall would prompt me asking if i want that to run
16:28:01 <bench1> but not anymore, and that is consistent with me not seeing any packets from network packet tracing
16:28:04 <LoganCapaldo> max [] = ?
16:28:05 <EvilTerran> er, minimum, even
16:28:12 <EvilTerran> LoganCapaldo, -Inf, clearly :P
16:29:22 <LoganCapaldo> minimum :: (Ord a) => [a] -> Maybe a ;)
16:29:23 <ddarius> Saizan: The length of the lists is the minimum of the length of each list with zipWithN.  The length of the list is the product of the length of each list with liftMN.
16:29:30 <EvilTerran> and length (zipWithN f a1 a2 ... aN) = minimum [length a1, length a2, ..., length aN]
16:29:33 <ddarius> > minimum [] :: Double
16:29:35 <BMeph> conal: Right. Partial functions from \N to a character set.
16:29:36 <lambdabot>  Exception: Prelude.minimum: empty list
16:29:39 <Kolji> guys
16:29:44 <Kolji> I need a small hilfe
16:29:46 <LoganCapaldo> I know it's not really
16:30:00 <LoganCapaldo> but I wonder if it shouldn't be
16:30:10 <ddarius> BMeph: What about f 0 = 'a'; f 1 = undefined; f 2 = 'b' ?
16:30:39 <Kolji> I have a function "(filter.(<)) a [b]" How exactly does it get applied on the perametres?
16:30:40 <conal> BMeph: got it.  and more generally, for lists (streams)
16:31:15 * conal has about a 45 second lag time right now.  hm.
16:31:25 <EvilTerran> LoganCapaldo, maybe instance (Bounded a, Ord a) => Monoid (Min a)?
16:31:45 <EvilTerran> (and likewise Max a, where newtype Min a = Min {getMin :: a}, etc)
16:31:57 <EvilTerran> > maxBound :: Double
16:31:58 <lambdabot>   add an instance declaration for (Bounded Double)
16:31:58 <lambdabot>     In the expression: max...
16:32:00 <EvilTerran> bah
16:32:17 <LoganCapaldo> heh
16:32:21 <Cale> Kolji: well, (filter . (<)) a = filter ((<) a) = filter (a <)
16:32:39 <LoganCapaldo> course -> Maybe a can only save you from [], it can't save you from fix (1:)
16:32:41 <Kolji> ah,
16:32:43 <Kolji> thanks, Cale
16:32:47 <Cale> Kolji: no problem
16:32:51 <Kolji> the logic of Haskell is not logical
16:32:55 <Kolji> or it is
16:33:02 <Kolji> but so ilogically logical
16:33:10 <Cale> heh
16:33:25 <Cale> Kolji: You understand currying, right?
16:33:41 <LoganCapaldo> it's spicy!
16:34:08 <Kolji> Cale, yes, I do
16:34:14 <BMeph> ddarius: Hmm, I guess "partial" isn't quite the property I'm looking for, then.
16:34:36 <EvilTerran> maybe have another typeclass, class Ord a => Lattice a where inf, sup :: a --?
16:35:22 <EvilTerran> {- forall x :: a . inf <= x && x <= sup -}
16:35:44 <Kolji> Cale, in fact...when one bracket is removed, one parameter to the right is taken
16:35:56 <EvilTerran> ?src Bounded
16:35:57 <lambdabot> class  Bounded a  where
16:35:57 <lambdabot>     minBound, maxBound :: a
16:36:21 <Kolji> or not exactly
16:36:22 <Kolji> lol
16:36:24 <Kolji> I get it
16:36:46 <Cale> Kolji: (a <) is actually syntax sugar for (<) a
16:36:57 <Cale> Kolji: It's an operator section.
16:37:04 <Kolji> yes, I do know that
16:37:42 <EvilTerran> then Monoid Min/Max could be done in terms of Lattice
16:38:12 <LoganCapaldo> I know in haskell you can't get minimum [1,1..] == 1 but is that "mathematically valid" to say?
16:39:11 <Kolji> Cale...but when you type (filter.(<)) a [b] it goes -> filter (< a) [b] /* it takes only the first parameter to do with < */ If you type filter.(<) a b, it automatically takes both parameters to do with <
16:39:41 <fadec> EvilTerran: How long have you been hacking Haskell?
16:39:54 <EvilTerran> er... about 18 months
16:40:02 <EvilTerran> non-stop :P
16:40:17 <EvilTerran> why do you ask?
16:40:21 <Cale> filter (a <) [b], but yeah
16:40:33 <ddarius> LoganCapaldo: In this case, yes.
16:40:34 <Cale> Function application has higher precedence than any operator.
16:40:39 <fadec> huh - I was just looking at your pointfree catRights from earlier
16:41:01 <Cale> So if you see  f x *** g y z, you know immediately that this is (f x) *** (g y z)
16:41:17 <fadec> EvilTerran: thought it was neat as hell
16:41:22 <Cale> (no matter which infix operator that is, or what its fixity is set to)
16:41:58 <hpaste>  gnuvince pasted "linking error" at http://hpaste.org/4891
16:42:11 <gnuvince_> Could anyone help me with the linking error paste I made?
16:43:19 <EvilTerran> fadec, heh, thanks :)
16:43:23 <LoganCapaldo> and minimum [1,2..] == 1? I ask because I'm wondering if you could carry around information about how the list was constructed to get information like minimum from (some) infinite lists. I have this feeling someone is gonna tell me it starts breaking down when you do something like minimum ([1,1..] ++ [2,3..])
16:44:09 <Kolji> LoganCapaldo, haskell is lazy, so yeah minimum [1,2..] == 1
16:44:16 <EvilTerran> Logan, nah, i'd say that should still be fine maths-wise
16:44:24 <resiak> > minimum [1,2..]
16:44:33 <lambdabot> Terminated
16:44:37 <resiak> ^^ no, it's not.
16:44:39 <LoganCapaldo> Kolji: it's lazy but not omnipotent ;)
16:44:39 <monochrom> minimum [1,2..] will get you _|_.  This is because information of where the list came from is not used.
16:44:55 <Kolji> hmm, true :D
16:45:12 <LoganCapaldo> monochrom: I know but in the context of my first question
16:45:21 <ddarius> Indeed. The reason minimum [1,1..] == 1 is reasonable mathematically is because we know how [1,1..] is constructed.
16:45:25 <EvilTerran> Logan, if you're looking at (Integer,min) as a monoid, you can use mconcat (xs ++ ys) = mconcat xs `mappend` mconcat ys with impunity, i think
16:45:35 <EvilTerran> (in terms of maths, anyway)
16:45:40 <monochrom> Conventional mathematics says minimum [1,2..] = 1.
16:45:45 <_alf_> dear god don't try to run minimum [1,2..]
16:45:57 <gnuvince_> Can anyone help me out?
16:46:31 <EvilTerran> gnuvince_, try tacking --make onto the ghc parameters?
16:46:35 <EvilTerran> (i'm guessing here)
16:46:44 <FunctorSalad> let f n = if <someprogram halts after n steps> then 0 else 1 in minimum (map f [1..])
16:47:17 <monochrom> "halts after n steps" is solvable in n steps, surprisingly :)
16:47:35 <EvilTerran> it'd probably be possible to do something silly with peano numbers to create a lazy, approximating "minimum" function
16:47:35 <FunctorSalad> sure, but calculating that minimum...
16:47:38 <gnuvince_> EvilTerran: that compiled, thanks.
16:47:42 <EvilTerran> :)
16:47:51 <gnuvince_> Though now I got a stack space overflow :-/
16:48:16 <Kolji> Cale
16:48:19 <monochrom> I calculate that minimum to 1.  There exists a program that halts after 1 step, no?
16:48:21 <Cale> yeah?
16:48:30 <Kolji> f.g x y = f (g x y) right?
16:48:32 <FunctorSalad> monochrom: a fixed program ;))
16:48:33 <monochrom> Err 0.
16:48:56 <ddarius> Simply, minimum (map f [0..])
16:49:09 <monochrom> Goes a long way to show the shortcoming of unabridged English.
16:49:24 <FunctorSalad> monochrom: I thought writing it in one word should solve that
16:49:25 <ddarius> Abridged English is better?
16:49:32 <Kolji> and (f.g) x y = f (g x) y
16:49:34 <Kolji> right Cale
16:49:49 <Cale> Kolji: no, not quite
16:49:57 <monochrom> You abridge English to the point it has all the benefits of a well-designed formal language.
16:50:01 <Cale> f . g x y = f . (g x y)
16:50:22 <Cale> which means that  (f . g x y) z = f ((g x y) z) = f (g x y z)
16:50:25 <monochrom> FunctorSalad: http://www.vex.net/~trebla/allsome.txt is a fun story.
16:50:40 <ddarius> monochrom: And loses all the benefits of a natural language?
16:50:57 <Cale> (f . g) x y = f (g x) y  -- this is right though
16:50:57 <monochrom> Not necessarily.
16:51:16 <monochrom> It's an open question.
16:51:24 <FunctorSalad> monochrom: I find game semantics quite cool for that
16:51:28 <ddarius> monochrom: Agreed, though clearly it loses some benefits.
16:51:33 <monochrom> It's an open question whether the two benefits are mutually exclusive.
16:52:09 <monochrom> You can also abridge in such a way that you can mark up natural parts and formal parts.
16:52:12 <FunctorSalad> your goal is to make the formula false, my goal is to make it true. at a "forall", you choose an element. at a "exists", I choose an element...
16:52:47 <FunctorSalad> (hope I didn't mix that up)
16:53:21 <monochrom> I chose Ange from angel, Demi from demon. Angelic choice, demonic choice.
16:53:38 <Kolji> oooh, thank you very much Cale
16:53:45 <FunctorSalad> didn't get that one
16:54:30 <monochrom> Usually, the student is "one of us", the teacher is the adversary, the "demon", the one who tries to tear apart your homework. :)
16:55:13 <Kolji> monochrom - student?
16:55:36 <FunctorSalad> I see :)
16:55:54 <Kolji> monochrom: what school?
16:56:03 <monochrom> It doesn't hurt that there are two famous actresses, Angelina Jolie and Demi Moore. :)
16:56:34 * monochrom should shoot a movie on a logic school. Starring Ange and Demi.  "Ange vs Demi".... :)
16:56:40 <FunctorSalad> or demiliches
16:57:01 <gio123> <Kolji> japan?
16:57:06 <EvilTerran> peanoMax x Zero = x; peanoMax Zero y = y; peanoMax (Succ x) (Succ y) = Succ (peanoMax x y)
16:57:07 <EvilTerran> peanoMaximum :: Peano -> Peano -> Peano; peanoMaximum = foldr peanoMax Zero
16:57:26 <Kolji> gio123: Slovakia
16:57:33 <Kolji> I mean Czech republic lol
16:57:45 <EvilTerran> toPeano = (iterate Succ Zero !!); fromPeano Zero = 0; fromPeano (Succ x) = 1 + (fromPeano x)
16:57:59 <gio123> <Kolji> bratislava?
16:58:31 <Kolji> cale, I see it now :) When you apply f.a b c d e f ... z, it does f.(a b c d e f g ...z)
16:58:48 <Kolji> and then it needs another parameter
16:59:02 <EvilTerran> given a potentially-infinite list of positive Ints, (peanoMaximum . map toPeano) can give an ever-more-accurate value for the maximum
16:59:28 <Kolji> but when you do (f.g) a b c ... z, it know it has only apply the . to the next parameter, i.e. f (a) b c ... z
16:59:48 <Kolji> gio123: I come from the vincinity of BRatislava, but I study in Czech republic
16:59:51 <EvilTerran> and you can determine such things as "is the maximum at least <x>? at least <y>?"
16:59:58 <EvilTerran> in finite time :)
17:00:37 <EvilTerran> ... it occurs to me that nubBy (>=) could potentially be used to similar effect
17:01:31 <monochrom> You are clever. :)
17:01:44 <FunctorSalad> reminds me... I know why I didn't get that nubBy example the other day. you used a relation that ought to be symmetric in a non-symmetric way...
17:01:54 <EvilTerran> > scanl (*) [0,-1..]
17:01:56 <lambdabot>   add an instance declaration for (Num [t])
17:02:08 <EvilTerran> > scanl1 (*) [-1,-2..]
17:02:09 <lambdabot>  [-1,2,-6,24,-120,720,-5040,40320,-362880,3628800,-39916800,479001600,-622702...
17:02:11 <FunctorSalad> (in the prime sieving)
17:02:17 <EvilTerran> > nubBy (>=) $ scanl1 (*) [-1,-2..]
17:02:19 <lambdabot>  [-1,2,24,720,40320,3628800,479001600,87178291200,20922789888000,640237370572...
17:02:34 <EvilTerran> ah, never mind
17:02:37 <EvilTerran> FunctorSalad, yes?
17:02:50 <FunctorSalad> not sure if it was you. I thought multiple people used it like that
17:02:52 <EvilTerran> > nubBy (\x y -> y `mod` x == 0) [2..] -- this
17:02:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:02:58 <FunctorSalad> yeah
17:03:04 <EvilTerran> it relies on the definition of nubBy in the prelude
17:03:11 <EvilTerran> er, s/prelude/report/
17:03:14 <EvilTerran> @src nubBy
17:03:14 <lambdabot> nubBy eq []             =  []
17:03:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:03:32 <FunctorSalad> confused me that what is supposed to be an equality predicate is actually asymmetric...
17:03:54 <EvilTerran> ignore what nubBy's *meant* to do; just look at how it's defined
17:03:59 <EvilTerran> that'll make more sense ;)
17:04:10 <EvilTerran> the report definition also allows you to do funny stuff like, er...
17:05:07 <EvilTerran> well, the report definition of groupBy means
17:05:09 <EvilTerran> > groupBy (const(/='x')) "xfooxxbarxbazx"
17:05:09 <lambdabot>  ["xfoo","x","xbar","xbaz","x"]
17:05:26 <EvilTerran> works like it does, even though *that* expects an equivalence relation as well
17:05:51 <EvilTerran> ?src groupBy
17:05:51 <lambdabot> groupBy _  []       =  []
17:05:51 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
17:05:51 <lambdabot>     where (ys,zs) = span (eq x) xs
17:06:18 <FunctorSalad> odd
17:06:18 <BMeph> >  nubBy (((>1).).gcd) [2..]
17:06:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:06:54 <EvilTerran> really, the report should've said explicitly "implementations're only required to follow the behaviour of this definition in the cases where the predicate is an equivalence relation", say, if they cared
17:07:24 <FunctorSalad> that's not an equivalence relation either BMeph ;)
17:07:37 <ndm> EvilTerran: but Haskell already defines =='s which are not equivalence relations as standard
17:07:56 <EvilTerran> it does?
17:07:57 <BMeph> FunctorSalad: No, it isn't - but it does give you primes in a tidy package. ;)
17:08:04 <ndm> EvilTerran: it does, guess which type?
17:08:13 <EvilTerran> lists?
17:08:14 <byorgey> hehe, I have a guess =)
17:08:29 <EvilTerran> doubles?
17:08:42 <ndm> yep
17:08:47 <EvilTerran> ... which?
17:08:56 <byorgey> Double, of course
17:08:57 <ndm> the NaN value is not equal to itself for doubles
17:09:04 <byorgey> Double breaks like every rule in existence.
17:09:07 <ndm> lists are good true functional data structures
17:09:36 <byorgey> except lists... of Doubles! mwahaha
17:09:48 <ndm> you can actually crash FiniteMap using NaN's since it relies on the law of tricotomy, which doesn't hold for doubles
17:09:58 <FunctorSalad> :o
17:10:04 <ndm> but Data.Map fixed the problem
17:10:10 <FunctorSalad> :)
17:10:14 <ndm> (Catch automatically detected the problem in FiniteMap)
17:11:18 <monochrom> I think List is a functor and doesn't really care about anything.
17:12:15 <Saizan> "Lists just don't care"
17:12:26 <ddarius> EvilTerran: peanoMaximum can only semi-decide 'is the maximum greater than n?'
17:12:53 --- mode: ChanServ set +b GoMittGo!*@*
17:13:28 <EvilTerran> yeah, "[01:02] <EvilTerran> ah, never mind" was me realising that it wasn't really useful
17:15:45 <hpaste>  lz pasted "firstHalf [ ]" at http://hpaste.org/4892
17:15:48 <davidL> @oeis 4 8 15 16 23 42
17:15:49 <lambdabot> The Lost Numbers.
17:15:49 <lambdabot> [4,8,15,16,23,42,108]
17:15:54 <davidL> heh
17:17:05 <Botje> lz: why do you think you need recursion?
17:17:23 <Botje> and why are you setting z to length of the empty list?
17:17:51 <lz> i am new at this
17:17:59 <BMeph> AND, why does it matter what type the elements of the list are? ;)
17:18:26 <Botje> lz: you already got pretty far with length and div.
17:18:52 <lz> so what u sujest me to do
17:18:54 <Botje> lz: so what should firstHalf l do ?
17:19:01 <Botje> for any given list in l
17:19:35 <lz>  [1,2,3,4,5,6] i will recive only the first half
17:19:45 <lz> [1,2,3]
17:20:05 <Botje> i know that
17:20:10 <Botje> how would you write it?
17:20:31 <Botje> you already know how to take the first n elements of a list, and you know how to take the length of a list
17:21:29 <lz> i dont now :(
17:21:41 <Botje> lz: sure you do, it's in your paste.
17:22:05 <lz> let me see
17:22:07 <byorgey> lz: I think you are trying to make it too complicated.  you do not actually need recursion.
17:22:18 <Botje> say you have a list l, how many elements are in the first half of l?
17:22:55 <lz> 0.5
17:23:10 <lz> and that is impossible
17:23:28 <lz> z = length [] do i need to put somenting inside of []
17:23:38 <Botje> ignore the paste
17:23:40 <sjanssen> > length []
17:23:42 <lambdabot>  0
17:23:54 <lz> ok
17:23:59 <sjanssen> lz: you don't need to put something there, but it's sort of meaningless
17:24:13 <Botje> say you have a list l, how do you get its length?
17:25:27 <lz> ya that is my questino on winhugs i put there lenght[1,2,3,4] and i recive the anwser
17:25:33 <lz> but coding is diferent
17:25:37 <BMeph> lz: You're doing great, keep on. :)
17:26:35 <Botje> lz: firstHalf l = take (div (length l) 2) l
17:26:59 <Botje> slightly nicer: firstHalf l = take ((length l) `div` 2) l
17:27:18 <Botje> do you understand how that works?
17:27:38 <lz> yes
17:27:50 <Botje> good
17:27:59 <Botje> can you write something to get the second half?
17:28:16 <Botje> you can use the function "drop" to drop the first n items from a list
17:29:12 <lz> i am going to try
17:29:21 <lz> thanks for the help
17:31:04 <lz> only one more question how do i define l has a list [...]
17:31:09 <lz> :P
17:31:18 <Botje> what?
17:31:41 <Botje> how do you mean "define l has a list" ?
17:31:56 <Saizan> once you've firstHalf defined you can call it on any list like firstHalf [1,3,5,4]
17:33:25 <kmcallister> the type of firstHalf will be [a] -> [a], meaning it can take a list of items of any type (call it a), and returns another list of items of the same type
17:33:35 <kmcallister> so you can explicitly write
17:33:38 <kmcallister> firstHalf :: [a] -> [a]
17:33:43 <kmcallister> but the compiler can also figure this out on its own
17:35:09 <lz> thanks i am going try
17:38:16 <gnuvince_> How do I get the value in a Maybe monad?  I want to do Map.lookup key myMap and get an integer.
17:38:31 <nelhage> @src fromJust
17:38:32 <lambdabot> fromJust Nothing  = undefined
17:38:32 <lambdabot> fromJust (Just x) = x
17:38:45 <kmcallister> case Map.lookup key myMap of
17:38:48 <kmcallister>  Just x -> x
17:38:50 <nelhage> Alternatively case, or maybe
17:38:52 <kmcallister>  Nothing -> y
17:38:55 <nelhage> @type maybe
17:38:59 <kmcallister> where you'd have to define y
17:38:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:39:18 <BMeph> :t maybe
17:39:29 <kmcallister> @src maybe
17:39:30 <lambdabot> maybe n _ Nothing  = n
17:39:30 <lambdabot> maybe _ f (Just x) = f x
17:39:34 <lambdabot> thread killed
17:40:19 <kmcallister> if you want to propogate failure, you can use monadic style
17:40:51 <kmcallister> (Map.lookup key myMap) >>= (\x -> return (x + 3))
17:41:11 <kmcallister> will produce Nothing if the key is not found, and Just (x + 3) if the value is x
17:41:25 <kmcallister> and the same thing can be accomplished with do notation
17:41:28 <nelhage> alternatively  liftM (+3) (Map.lookup key myMap)
17:43:50 <IvdSangen> Hi, i am trying to combine two IO values IO a and IO b to create an IO (a,b)?
17:43:58 <IvdSangen> is there a function for this?
17:44:11 <kmcallister> liftM2 (,)
17:44:14 <nelhage> :t liftM2 (,)
17:44:18 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:44:43 <IvdSangen> ah, ofcourse
17:44:47 <IvdSangen> thanks
17:45:05 <kmcallister> are operators like (,) in haskell98?
17:45:29 <kmcallister> the tupling ones specifically
17:45:50 <nelhage> I believe so
17:47:53 <monochrom> Yes, (,) is haskell 98.
17:54:28 <Sgeo> Hi all bye all.
17:59:47 * Botje waves
18:18:40 <gwern> what do I do about a warning like 'Warning: Deprecated use of `B.findSubstring' (imported from Data.ByteString.Char8, but defined in Data.ByteString): Do not use. The ByteString searching api is about to be replaced.'? the API docs don't seem to suggest any replacement
18:19:26 <BMeph> ?seen dons
18:19:26 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 45s ago.
18:20:01 <BMeph> gwern: Start at the top... ;)
18:20:25 <dons> well, there's a bytestring-search lib, but we don't have an official replacement yet
18:22:38 <dons> what's this?? http://haskell.hivefire.com/
18:22:39 <lambdabot> Title: - Monad - Haskell Programming
18:22:49 <fadec> Anybody using runhaskell with cgi?   runghc: PATH: getEnv: does not exist (no environment variable)
18:23:34 <dons> i'd not imagine many using cgi via runhaskell.
18:23:39 <dons> wouldn't they compile it? (i always do)
18:26:03 <fadec> dons: come to think of it compiling makes more sense with the static typing
18:27:13 <dons> and all the optimisations are enabled only when compiled to native code
18:27:26 <dons> also, you'll cut the app startup time from 0.6s for the interpreter, to 0.01
18:27:36 <dons> fastcgi + compiled haskell == zippy :)
18:29:15 <dons> dcoutts: haha http://haskell.hivefire.com/entity/profile/duncan-coutts/
18:29:15 <lambdabot> Title: Duncan Coutts - Monad - Haskell Programming
18:29:21 <dons> automated profiling goes awry
18:30:24 <Igloo> dons: You mean you didn't know what Duncan does at weekends?  :-)
18:30:58 <dons> our mild mannered Duncan, full of surprises
18:31:32 <dons> so i've no idea who's behind this site, or why they're stalking duncan
18:31:57 <dons> "HiveFire is an early stage funded start up located in Kendall Square in Cambridge, MA.  HiveFire is in the online news and blog space specializing in technology involving machine learning, natural language processing, information retrieval and human computer interaction. "
18:32:38 <dons> so maybe they're interested in haskell (or using it?) and are demoing their tech by aggregating haskell
18:34:14 <LoganCapaldo> is he really in our lady peace? or is it just the website confusing two duncan coutts?
18:34:25 <Korollary> duncan should retaliate by profiling hivefire wrong.
18:34:42 * allbery_b can imagine what automated aggregation would do with him...
18:34:48 <dons> LoganCapaldo: its confusing some US guy in a band with our own Duncan
18:34:55 <dons> looks like they're taking it from wikipedia
18:34:57 * Botje is a big fan of automated agression
18:34:58 <Korollary> dons: canadian
18:35:05 <Botje> oh wait
18:35:10 <allbery_b> "automated aggravation"
18:35:11 <dons> canadian.
18:35:14 <dons> http://en.wikipedia.org/wiki/Duncan_Coutts
18:35:14 <lambdabot> Title: Duncan Coutts - Wikipedia, the free encyclopedia
18:35:26 <dons> that's not duncan! let's redirect and disambiguate!
18:35:56 <dons> that's duncan, http://web.comlab.ox.ac.uk/oucl/people/duncan.coutts.html
18:35:57 <lambdabot> Title: Duncan Coutts
18:36:29 <LoganCapaldo> this is almost like office space with michael bolton
18:36:40 <LoganCapaldo> but less fictional
18:37:01 <dons> this is also duncan, http://www.unipv.it/webdsps/storiadoc/images/charles1.jpg
18:37:53 <TomMD> Is this common?  Having used cabal before, I find this odd: "cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)"
18:40:26 <dons> that's a bug in older cabals
18:40:31 <dons> update to a newer version
18:45:00 <BMeph> Has anyone else had any trouble compiling the new Haddock?
18:47:06 <LoganCapaldo> i like fish
18:47:54 <ricky_clarkson> You put your whole hand in, your whole hand out..
18:50:45 <TomMD> I see some issues: 1) Many many "cabal-*" packages.  2) The latest hackage cabal-install is version 0.4.0, which is giving me this error 3) There is no '--version' or '-V' command line.  Seeing all this, is there a cabal trac?
18:51:53 <sw17ch> does any one have a favorite HOpenGL tutorial?
18:53:54 <TomMD> * oops - forgot to properly rebuild cabal-install after installing the latest Cabal lib.  Still, my third point could easily be rectified by a flag that reports Cabal and cabal-install versions.
18:57:50 <wolverian> TomMD, I have cabal --version
18:58:04 <wolverian> (cabal-install 0.4.1, library 1.3.2)
18:59:54 <TomMD> I guess cabal-0.4.0 doesn't have it, and .1 does.
19:37:30 <BraWearerSam> any other guys here like to wear bras?
19:37:44 <keseldude> only you
19:37:48 <BraWearerSam> ?
19:37:52 <BraWearerSam> nothing wrong with that
19:38:52 <BraWearerSam> My name is Samuel and I LOVE TO WEAR BRAS.
19:38:55 <BraWearerSam> I am a man who would like to wear a bra. I need no support! Thanks, Ron
19:38:58 <BraWearerSam> My name is Samuel and I LOVE TO WEAR BRAS.
19:39:01 <BraWearerSam> I am a man and wear bras out in public and don't care who sees it!
19:39:05 <BraWearerSam> Victoria's Secret employees help fit me for the right bra every time i shop there even though I am a male
19:39:09 <BraWearerSam> I love when my bra straps project through the back of my shirt.
19:39:10 <BraWearerSam> I own 8 bras from Victoria's Secret even though I am a guy
19:39:13 <BraWearerSam> I wore a bra out in public to the mall today under just a t-shirt
19:39:17 <BraWearerSam> I love when my bra straps project through the back of my shirt.
19:39:19 <BraWearerSam> I am a guy and wear a bra as often as I can and out in public all the time
19:39:22 <BraWearerSam> Even though I am a guy I ask the Victoria's Secret employees if I can try on bras in the fitting rooms and they always say yes
19:39:25 <BraWearerSam> Even though I am a guy, bra wearing is my passion
19:39:28 <BraWearerSam> Check out my bra wearing questions on Yahoo! answers
19:39:31 <BraWearerSam> Every guy should try wearing a bra
19:39:34 <BraWearerSam> My name is Samuel and I LOVE TO WEAR BRAS.
19:39:37 <BraWearerSam> I am a guy and wear a bra as often as I can and out in public all the time
19:39:40 <BraWearerSam> Bra wearing is amazing and I am a guy
19:39:43 <BraWearerSam> My name is Samuel and I LOVE TO WEAR BRAS.
19:39:46 <BraWearerSam> Bra wearing is amazing and I am a guy
19:39:50 <BraWearerSam> I love when my bra straps project through the back of my shirt.
19:39:52 <BraWearerSam> Bra wearing is amazing and I am a guy
19:39:55 <BraWearerSam> Visit your local men wearing bras message board today!
19:39:58 <BraWearerSam> Every guy should try wearing a bra
19:40:01 <BraWearerSam> I am a guy and wear a bra as often as I can and out in public all the time
19:40:04 <BraWearerSam> I am a guy with a huge bra collection that I wear
19:40:07 <BraWearerSam> My name is Samuel and I LOVE TO WEAR BRAS.
19:40:11 <BraWearerSam> Every guy should try wearing a bra
19:40:13 <BraWearerSam> I am a man who would like to wear a bra. I need no support! Thanks, Ron
19:40:16 <BraWearerSam> Every guy should try wearing a bra
19:40:19 <BraWearerSam> Hi, I am a man who likes to wear a bra.
19:40:22 <BraWearerSam> Victoria's Secret employees help fit me for the right bra every time i shop there even though I am a male
19:40:23 --- mode: ChanServ set +o sjanssen
19:40:31 --- mode: sjanssen set +b *!*n=maoiwn@*.dsl.snantx.sbcglobal.net
19:40:31 --- kick: BraWearerSam was kicked by sjanssen (sjanssen)
19:41:48 <ricky_clarkson> He said "I need no support".
19:41:57 <monochrom> Hahahahaha
19:43:05 <Pseudonym> I wear kets.
19:44:10 <ricky_clarkson> @web1912 kets
19:44:10 <lambdabot> No match for "kets".
19:44:26 <kpreid> Pseudonym: heh.
19:45:28 * allbery_b rolls his eyes
19:46:43 <allbery_b> ricky_clarkson: you'd need a math or physics dictionary for that one
19:47:06 <LoganCapaldo> wow
19:47:14 <LoganCapaldo> thata took some work to google
19:47:30 <LoganCapaldo> http://en.wiktionary.org/wiki/ket
19:47:30 <lambdabot> Title: ket - Wiktionary
19:47:35 <nelhage> @go bra-ket notation
19:47:36 <lambdabot> http://en.wikipedia.org/wiki/Bra-ket_notation
19:47:36 <lambdabot> Title: Bra-ket notation - Wikipedia, the free encyclopedia
19:47:41 <liyang> and even then I'm sure the word was coined /after/ 1912.
19:47:53 <LoganCapaldo> "the complex conjugate of a bra"
19:48:40 <davidL> @freshname
19:48:41 <lambdabot> Habd
19:54:34 <_alf_> liyang: it was... dirac coined it in the 30s
19:58:07 <skew> I was reading [#haskell] I was reading
19:58:07 <skew> [#haskell] I was reading
19:58:20 <skew> darn paste
19:58:47 <byorgey> skew: ?
19:58:59 <Korollary> accidental paste
20:00:07 <skew> I was reading http://programming.reddit.com/info/64yka/comments/ where it was suggested running broken code in a stepper can sometimes help students more than type error messages
20:00:37 --- mode: ChanServ set -o sjanssen
20:00:40 <skew> I'm wondering if type errors could be presented in the form of a fake execution trace
20:00:50 <monochrom> Interesting.
20:01:03 <Korollary> they could be presented as a failing typechecking trace
20:01:28 <skew> getting actual concrete inputs could be hard
20:01:34 <sjanssen> how meaningful are those?
20:01:51 <skew> especially for things like \x -> let x2 = x*x in if x2 >= 0 then x2 else "oops"
20:01:58 <nelhage> Has there been any work on implementing a system in the style of http://groups.csail.mit.edu/pag/parg/lerner07searching.pdf for any haskell implementation?
20:02:13 <skew> it's not exactly that they are meaningful, but that they are concrete
20:02:19 <nelhage> (getting better errors by searching for "similar" programs that typecheck)
20:02:42 <monochrom> Type checking and inferring can be explained as a static analysis over code. Static analysis is fake execution.
20:02:50 <skew> rather than saying "let X be an int", stepping to "let Z be X*X", stpeeing to "assume Z<0 gives False"
20:02:54 <skew> monochrom: yeah, that's the other way
20:03:06 <skew> an evaluation where *types* are the things being passed around
20:03:56 <monochrom> However, I think it's harmful to be obsessed with execution.
20:03:59 <skew> broken <Int> => let x2 = <Int>*<Int> in if x >= 0 then x2 else "oops" => if <Bool> then <Int> else "oops"
20:04:59 <monochrom> You can view a program through executional glass. That's a valuable view but not the only valuable view.
20:06:17 <monochrom> The other valuable view, and IMO more relevant, is how to work your way from specification to code. This thought process is often different from the executional view, and sometimes the executional view gets into the way.
20:12:33 <hpaste>  BMeph pasted "Frustrating Haddock compile errors" at http://hpaste.org/4894
20:14:48 <BMeph> So, does anyone have a recommendation for what I'm doing wrong getting Haddock up?
20:15:19 <BMeph> Well, besides "put a partition of Slackware on your machine!" ;p
20:15:31 <monochrom> I'll first try building haddock myself. (I planned to, anyway.)
20:16:00 <monochrom> You're on Windows?
20:16:17 <BMeph> That should help a bunch - thanks, and good luck. ;)
20:16:26 <BMeph> Yes, I am.
20:17:04 <monochrom> Haddock 2.0.0.0?  GHC 6.8.2?
20:17:53 <BMeph> Yes to both.
20:20:11 <monochrom> Build succeeds on Linux. Now I try on Windows.
20:22:37 <BMeph> Well, at least it does compile - so I just need to fix my system, hopefully.
20:31:18 <monochrom> I also build successfully on Windows.
20:31:47 <monochrom> I am a bit suspicious of [5 of 6] Compiling Haddock.InterfaceFile ( src/Haddock/InterfaceFile.hs, dist\build/Haddock/InterfaceFile.o )
20:32:03 <monochrom> Because what I see is [3 of 4] Compiling Haddock.InterfaceFile ( src/Haddock/InterfaceFile.hs, dist/build/Haddock/InterfaceFile.o )
20:33:37 <monochrom> There is another one. It's [11 of 24].
20:33:50 <monochrom> Anyway, I don't see [5 of 6] anywhere.
20:34:57 <BMeph> Hmm, well it's good to know that it's just my problem, now I just have to find out what it is... :|
20:35:42 <monochrom> Cabal-1.2.3.0 here
20:37:36 <BMeph> I jusat ut 1.3.2 on here, but it's been stalling since before then.
20:41:46 <BMeph> Er, that was supposed to be, "I just set up 1.3.2,..."
21:01:58 <MyCatVerbs> instance (Monoid w, Monoid l) => Monoid (Writer w l) -- kekekekek
21:03:12 <conal> which is equivalent to the monoid instance for pairs
21:03:32 <hpaste>  MyCatVerbs pasted "I had cause to write this at 5 o'clock this morning. Make of it what you will." at http://hpaste.org/4895
21:04:14 <conal> MyCatVerbs: i don't see anything.  is that because you were asleep at 5?
21:04:15 <hpaste>  MyCatVerbs pasted "I also had cause to write this, too, at 5 o'clock this morning. Make of it what you will. Also, pry " at http://hpaste.org/4896
21:04:36 <MyCatVerbs> conal: 'tis because I hit enter by mistake.
21:04:42 <MyCatVerbs> conal: wait, there's a mo... dammit.
21:04:53 <conal> MyCatVerbs: oh!  i thought it was a joke.
21:05:07 <ddarius> You just burst his bubble conal.
21:05:22 <conal> ddarius: by bringing up the pair monoid?
21:05:25 <ricky_clarkson> I was wondering what a bubble canal was for a moment then.
21:05:35 <MyCatVerbs> conal: so all I had to to was use runWriter, huh.
21:05:50 <MyCatVerbs> Still. It's fun that the language lets me do this worthless crap. :)
21:06:02 <ddarius> The product monoid is very useful.
21:06:13 <conal> MyCatVerbs: no -- it's a useful instance, and lets you stay in the Writer abstraction if you want.
21:06:28 <MyCatVerbs> conal: well, the difference is between writing, oh...
21:07:10 <MyCatVerbs> (mapM alterW befores) `mappend` (mapM murderW middle) `mappend` (mapM alterW afters)
21:07:50 <ddarius> Wouldn't it just be, mempty = return mempty and mconcat = liftM mconcat sequence or liftM mconcat msum, i.e. couldn't you just make a general instance for all monads.
21:07:53 <MyCatVerbs> and (runWriter $ mapM alterW befores) `mappend` (runWriter $ mapM murderW middle) `mappend` (runWriter $ mapM murderW afters)
21:08:34 <MyCatVerbs> ddarius: oh, good thinking. Better than mine, at any rate.
21:08:39 <conal> MyCatVerbs: exactly.  that's what i meant about staying in the Writer abstraction.
21:08:54 <conal> applicative functors makes it clearer, because you can use pairs *directly* as writers and functions directly as readers.
21:09:28 <ddarius> conal: Can't you do that with monads anyway?
21:10:37 <conal> ddarius: yes, i suppose you could.  i guess the difference i was thinking of is really that with applicative functors, you don't also need transformer versions.
21:10:46 <conal> since AFs compose, while monads don't.
21:11:06 <hpaste>  MyCatVerbs annotated "I also had cause to write this, too, at 5 o'clock this morning. Make of it what you will. Also, pry " with "This is more like it, right? Making use of the pair monoid." at http://hpaste.org/4896#a1
21:11:46 <ddarius> conal: You'd still need to use O though, right?  Otherwise how is it supposed to tell whether you want r -> - or r -> (w, -)
21:12:05 <conal> ddarius: exactly.  O = composition.
21:12:28 <conal> O is what i meant by composing.
21:12:44 <ddarius> I know. That is certainly more convenient, but you no longer have the "direct" use.
21:16:39 * ddarius builds cabal and cabal-install
21:20:30 <conal> ddarius: i agree: it's overstating to say that AFs allow both direct use of pair & function types *and* composability.  really one or the other, in that composition wraps an extra O constructor.
21:23:34 <ddarius> cabal-install built
21:24:26 <ddarius> Oh cool.  cabal-install's "feature list" looks nice
21:24:54 <conal> ddarius: where do you see a feature list?
21:25:06 <ddarius> The commands
21:29:46 <Cale> sudo cabal --global install cabal-install  :)
21:29:49 <gwern> I wonder when cabal-install will get an 'uninstall' feature...
21:31:19 <sjanssen> probably not before Cabal/ghc-pkg have it
21:31:20 <allbery_b> I thought the Cabal cabal were opposed to uninstall because it's scary
21:32:01 <gwern> (I mean, I guess it could call ghc-pkg unregister, but that doesn't actually remove anything)
21:32:11 <mrd> rather than uninstall, how about gc
21:33:10 <sjanssen> you need uninstall functionality before GC anyway
21:33:22 <mrd> we got gc without free()
21:34:11 <sjanssen> that's a faulty analogy, I think
21:34:33 <mrd> like fawlty towers of hanoi
21:34:54 <sjanssen> besides, a GC system does have some internal way to free memory -- the user just doesn't call it directly
21:35:06 <conal> maybe with unregister, uninstall would be just GC
21:35:33 <sjanssen> I don't think Cabal even keeps enough info to uninstall executables and data files
21:35:34 <gwern> (wow, HaXML generates a ton of warnings)
21:35:36 <conal> unregister is removing an entry from a Map.  GC could follow.  theoretically.
21:36:09 <conal> (with re-engineering)
21:38:08 <gwern> mm. I think you'd need an OS like NixOS before you could GC the filesystem
21:38:22 <conal> me too.
21:39:03 <gwern> (one of these days I'm going to download and play around with NixOS)
21:43:40 <conal> does anyone have a simple & cheap way in IO to simply not terminate (block)?  i'm using "newEmptyMVar >>= takeMVar".
21:44:25 <sjanssen> conal: 'atomically retry'?
21:44:43 <ddarius> sjanssen: Can that ever unblock?
21:44:45 <conal> sjanssen: oh -- that'd sure do.
21:45:05 <sjanssen> ddarius: no
21:45:16 <ddarius> sjanssen: It will be GCed by GHC, yes?
21:45:17 <sjanssen> actually, I'm a bit surprised that it works
21:45:22 <sjanssen> ddarius: no
21:46:31 <sjanssen> oh, it does terminate with the non-threaded RTS
21:46:50 <conal> sjanssen: 'atomically retry' terminates?
21:47:01 <sjanssen> and the threaded RTS... hmm
21:47:21 <sjanssen> only runghc/ghci seem to block forever
21:47:29 <sjanssen> conal: thread blocked indefinitely exception
21:47:38 <ddarius> That's reasonable
21:47:53 <ddarius> (For the non-threaded RTS)
21:48:01 <sjanssen> I wonder why ghci is different?
21:48:10 <conal> sjanssen: oh.  i wonder if i get the analogous exception when compiled.  i was surprised when i didn't.
21:48:49 <sjanssen> conal: perhaps "forever $ threadDelay maxBound"?
21:49:20 <sjanssen> "newEmptyMVar >>= takeMVar" will throw an exception
21:50:15 <conal> sjanssen: that's what i expected, but doesn't seem to.  hm.
21:50:33 <sjanssen> conal: it doesn't in ghci, but does in compiled code
21:51:02 <conal> sjanssen: hm.  not for me.  i wonder why.
21:51:07 <conal> sjanssen: with or without -threaded
21:51:24 <sjanssen> conal: either
21:52:56 <conal> sjanssen: okay -- i got that message when main does the newEmptyMVar >>= takeMVar directly.  but somehow, not in my context.  odd.
21:54:16 <conal> sjanssen: i like your "forever $ threadDelay maxBound" alternative.  any idea whether there's non-trivial overhead?
21:57:00 <sjanssen> conal: I'm not sure
21:57:23 <conal> sjanssen: i suppose i could also just catch the exception.
21:57:57 <conal> oh -- but then what would i do.
21:58:06 <sjanssen> conal: but then you're just spinning the thread, which does count as "non-trivial overhead", I think :)
21:58:42 <conal> sjanssen: by "spinning", do you mean starting the thread, or some kind of busy loop?
21:59:08 <sjanssen> conal: busy loop
21:59:52 <sjanssen> (repeatedly catching a blocked indefinitely exception and repeating would be a busy loop)
22:00:10 <conal> sjanssen: a very unbusy busy loop, though isn't it?
22:00:28 <conal> sjanssen: oh -- now i get you.
22:00:40 <conal> exactly.  i don't want to do that.
22:00:51 <sjanssen> yeah, "forever $ threadDelay maxBound" should be the best you can do
22:01:15 <sjanssen> unless GHC had some "blockForever" primitive
22:01:25 <conal> sjanssen: as far as i see also.  or -- what about blocking the exception.  i ran across how to do that recently, though i don't remember where.
22:02:01 <sjanssen> conal: oh, another idea is to takeMVar an MVar that never goes out of scope (via top-level unsafePerformIO)
22:02:07 <ddarius> sjanssen: I was wondering if it should add it.  It should correspond to 0 in the pi-calculus (and various other such things)
22:02:40 <conal> sjanssen: except that i want polymorphic blocking.
22:02:51 <conal> sjanssen: block :: IO a
22:03:06 <sjanssen> conal: the problem is that the thread still has to do something while blocking the exception, so you're at square 1
22:03:19 <sjanssen> conal: takeMVar global >> return undefined?
22:03:40 <conal> sjanssen: i tried something like that.  will try your variant.
22:04:12 <sjanssen> or even forever $ takeMVar global, with the suggested generalized type of forever
22:04:29 <conal> sjanssen: still monomorphic, right?
22:05:01 <sjanssen> conal: I don't see why it is monomorphic
22:05:22 <conal> sjanssen: oh yeah -- newEmptyMVar is polymorphic.
22:05:42 <sjanssen> are we confused?
22:06:18 <sjanssen> I'm saying the type of "forever (takeMVar global)" is IO a
22:06:45 <sjanssen> the type of global should be monomorphic, just to avoid accidentally writing unsafeCoerce#
22:07:39 <conal> sjanssen: oh, i see.  the mvar's type has nothing to do with block's type.
22:10:11 <conal> sjanssen: wow -- i can't get any of these ideas *not* to raise "thread blocked indefinitely".
22:10:38 <sjanssen> conal: even threadDelay?
22:10:39 <conal> sjanssen: except for the threadDelay one, which i haven't tried.
22:11:40 <conal> sjanssen: the threadDelay one works.
22:12:17 <sjanssen> hmm, even the global MVar doesn't work, which is surprising
22:13:06 <conal> sjanssen: to me as well!
22:13:41 <sjanssen> maybe GHC throws this exception if no thread is in the "runnable" queue
22:21:05 <conal> sjanssen: thanks for all the help.  i'm going with "forever $ threadDelay maxBound".  since forever's return type is unnecessarily narrow, i end with a "return undefined".
22:21:28 <conal> funny that simply not terminating is so difficult.
22:21:47 <byorgey> looks like the type of 'forever' will get fixed in the next version of the libraries
22:22:02 <conal> :)
22:22:21 <byorgey> conal: not terminating isn't difficult.  it's not terminating while doing no actual work that's difficult. =)
22:22:22 <sjanssen> conal: I wrote block = threadDelay maxBound >> block
22:22:25 <conal> generalized from IO as well as the return type?
22:22:33 <conal> byorgey: agreed!  :)
22:22:45 <sjanssen> @type forever
22:22:47 <lambdabot> Not in scope: `forever'
22:22:53 <sjanssen> @type Control.Monad.forever
22:22:53 <lambdabot> Not in scope: `Control.Monad.forever'
22:22:57 <sjanssen> bah
22:22:57 <conal> it's now IO a -> IO ()
22:23:05 <conal> could be Monad m => m a -> m a
22:23:07 <sjanssen> IIRC, Monad m => m a -> m ()
22:23:19 <conal> oh -- right.  silly me.
22:23:23 <sjanssen> conal: the fully general type is Monad m => m a -> m b
22:23:42 <conal> sjanssen: yes of course.  thanks.
22:24:02 <byorgey> sjanssen: it's new in 6.8, isn't it?  so \bot doesn't know about it yet.
22:24:09 <conal> which i'd need for "forever $ threadDelay maxBound"
22:24:34 <dons> Monad m :: m a -> m b is the proposal, fwiw
22:24:36 <sjanssen> byorgey: yeah, that's right
22:24:43 <dons> Monad m => m a -> m b , i mean
22:25:43 <conal> dons: great!
22:26:16 <hpaste>  conal pasted "block forever" at http://hpaste.org/4897
22:26:18 <dons> its currently m a -> m ()
22:26:29 <ddarius> Has Data.ByteString.Base moved somewhere else, and if so, where?)
22:26:48 <dons> ddarius: .Internal and .Unsafe , depending on the unsafeness and internalness
22:26:49 <ddarius> conal: Out of curiosity, why do you need a block forever?
22:26:57 <ddarius> dons: Thanks.
22:27:17 <ddarius> dons: I'm working on making parsec3 cabal-installable as a start
22:28:01 <conal> ddarius: for my functional futures, which are part of the Reactive package.  i have a "never :: Future a", which blocks forever when forced.  it's the mempty for the Future monoid.
22:28:49 <dons> ddarius: awesome!
22:29:19 <ddarius> conal: Cool.  Yeah, the need for 'never' should be effectively equivalent to the need for a "block forever" primitive.  (Again, related to 0 in concurrent calculi).
22:29:30 <ddarius> The idea should probably be proposed somewhere.
22:29:38 <conal> ddarius: a non-contrived example is for a reactive behavior that goes constant.  a thread that's updating some output from a gone-constant reactive behavior can just block forever.
22:30:04 <ddarius> @where bytestring
22:30:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:31:29 <conal> Now the RTS goes out its way to generate an exception for a "block forever".
22:31:54 <sjanssen> GHC is exceedingly clever
22:32:24 <conal> if it were cleverer, it'd generate an error for the forever-threadDelay implementation.
22:33:58 <conal> anyway, this stuff is on hackage and described at http://haskell.org/haskellwiki/Reactive .  i'm simplifying the implementation a bit atm.
22:38:29 <ramza3> i heart haskell
22:39:26 <dons> looks very interesting, conal!
22:39:44 <dons> i love it how conversations at conferences turn into code months later
22:40:40 <ddarius> @tell Philippa I've started hacking code and working on getting parsec3 cabal-installable.  While there is some obvious stuff, I could use a reminder for what things Paolo felt needed polishing.
22:40:41 <lambdabot> Consider it noted.
22:41:29 <conal> dons: :)
22:41:43 <ddarius> dons: Yeah, that "Wake-up call for LP" read was very pleasant, I think Tim missed a rather important aspect of the Haskell community.
22:42:12 <ddarius> But maybe I need to check out comp.lang.prolog for a while to be sure.
22:47:25 <ddarius> Well parsec3 at least builds now.  However, I need to go to sleep.
22:47:58 <conal> @localtime ddarius
22:47:58 <lambdabot> Local time for ddarius is Thu Jan 10 00:47:31
22:48:21 <conal> ddarius: where are you?
22:48:28 <ddarius> San Angelo, TX
22:48:50 <conal> ddarius: wow -- why TX?
22:49:11 <ddarius> conal: Because I was stationed there.  It certainly wasn't my choice.
22:49:24 <conal> urg.
22:49:29 <conal> sleep well!
22:52:46 <dons> ddarius: what aspect did Tim miss, wrt. the LP guys?
22:52:55 <dons> collaboration/irc?
22:57:15 <andyjgill> Hi room
22:57:44 <byorgey> hi andyjgill
22:58:09 <ramza3> what is the opposite of lazy, qualified?
22:58:13 <ramza3> eg, lazy byte read
22:58:36 <byorgey> ramza3: the opposite of 'lazy' is 'eager'
22:58:40 <byorgey> ramza3: is that what you mean?
22:58:42 <ramza3> thanks
22:58:44 <ramza3> yea
22:59:21 <byorgey> andyjgill: what's happening?
22:59:24 <dons> hey andyjgill. rainy over on the east side? :)
22:59:58 <andyjgill> its wet, wet, and wet on the east side
23:00:29 <andyjgill> and for the first time in about 3 weeks, I've actully got an hour to hack
23:00:56 <dons> oh, awesome.
23:01:16 <dons> ddarius: so you thinking about bytestring parsec?
23:02:17 <byorgey> I think ddarius went to bed
23:02:54 <dons> ah ok :)
23:22:56 <quicksilver> @remember AntonVanStraaten Oh dear - I'm going to have to rethink the paper I was working on, provisionally titled "In defense of arbitrary untracked effects in high assurance software."
23:22:56 <lambdabot> I will never forget.
23:43:03 <dons> oh, conal wins module name of the 2008 award,   Data.Fun
23:44:23 <conal> dons: dr suess says "If you never did, you should.  These things are fun and fun is good."
23:44:33 <dons> :D
23:44:56 <dons> I want a "Data.Fun" tshirt!
23:45:07 <conal> great idea!
23:45:19 <dons> like pugs slogan, "-Ofun"
23:54:24 <lament> "zero fun"?
23:55:39 <goalieca> clearly he's optimizing away all the fun
23:56:02 <jsnx> -fno-fun
