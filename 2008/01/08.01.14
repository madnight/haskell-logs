00:00:10 <dons> the one for asm, yeah, harpy
00:00:21 <dons> you could spit the asm from a haskell dsl
00:00:44 <Cale> You can also run the code you've generated on the fly, which is pretty cool as well :)
00:01:03 <Cale> (using Harpy)
00:01:20 <dons> andyjgill: i get a badge, http://code.haskell.org/~dons/tests/pcre-light/hpc_index.html :) (also, i linked to it from the hackage page, so maybe we'll start to see some more hpc coverage results on hackage)
00:01:31 <andyjgill> Cool!
00:01:55 <dons> hpc is annoying -- i want to refactor until all dead code is gone! :)
00:02:20 <andyjgill> :-) But was the code better for it?
00:02:33 <dons> definitely, it highlighted a bunch of suspicious things
00:02:46 <C-Keen> hm, I have a `Control.Monad.Error.ErrorT B.ByteString IO' type and want to use this in my main function, whcih expects IO Monads as final statement in its do section, how can I do this?
00:03:08 <nelhage> :t runErrorT
00:03:09 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
00:03:10 <dons> C-Keen: runErrorT
00:03:20 <andyjgill> I sense an open source experience report for ICFP.
00:03:49 <C-Keen> ah..
00:03:59 <dons> maybe ... get a few more of these together, and we'll have quite a good story
00:04:15 <andyjgill> We've got 2.5 months.
00:04:59 <dons> oh, nice, the darcs changes logs shows the changes i made to get 100% coverage
00:05:02 <dons> some interesting things there
00:34:02 <RubberHound> Hey, I'm looking for an svg haskell logo
00:35:36 <sarah__> is there some function that lazily gobbles up a list, as long as a test on the value remains true, returning all eaten?
00:35:57 <roconnor> RubberHound: Fritz Ruehr may have one.
00:35:58 <flux> takeWhile?
00:36:03 <sarah__> thx
00:36:10 <RubberHound> and who's that?
00:36:41 <roconnor> http://www.willamette.edu/~fruehr/
00:36:41 <lambdabot> Title: Fritz Ruehr's home page
00:42:34 <roconnor> apparently Haskell is the new Scalia :/
01:06:42 <Sizur> @users
01:06:43 <lambdabot> Maximum users seen in #haskell: 458, currently: 392 (85.6%), active: 4 (1.0%)
01:07:42 <Sizur> wow, approaching #perl population count.
01:13:58 <C-Keen> hm ok runErrorT unwraps my Error Monad, but how can I use the return value of my monad then? I have a function that 'return's a success value but runErrorT takes it away
01:16:09 <Cale> C-Keen: um
01:16:50 <Cale> :t runErrorT
01:16:52 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
01:18:16 <Cale> runErrorT takes a computation in your ErrorT transformed monad, and produces a computation in the original monad which results in either Left e, where e is the error which occured, or Right x, where x is the successful result.
01:19:45 <C-Keen> Cale: I have the following in my code: do v <- func foo bar;func2 baz v -- I need the value returned first but only if it is a success
01:20:13 <C-Keen> as I understood the do section continues only if the preceding operation was successful
01:21:21 <Cale> Well, that's what the ErrorT transformer does -- it handles propagation of errors.
01:21:55 <C-Keen> Cale: but for the section mentioned above I get a compiler error: Couldn't match expected type `IO t' against inferred type `ErrorT B.ByteString IO B.ByteString'
01:22:16 <Cale> Well, what are the types of func and func2?
01:23:07 <Cale> Since they're in the same do-block, they'd better be typed in the same monad.
01:23:34 <C-Keen> hm they are not
01:23:57 <C-Keen> since func2 is the function the do block is in
01:29:01 <Cale> If you want to lift an IO action to work in your ErrorT transformed IO monad, you can just apply liftIO to it.
01:29:04 <Cale> :t liftIO
01:29:19 <lambdabot> thread killed
01:29:26 <Cale> uhh...
01:29:27 <Cale> :t liftIO
01:29:28 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:30:01 <ac> there's a bitwise xor, but is there a bitwise and and or?
01:30:11 <C-Keen> Cale: I want to feed a monad and feedback the result into it from a loop function
01:30:26 <C-Keen> ac: yes Data.Bits
01:30:47 <ac> ah, .&. and .|.
01:31:07 <Cale> C-Keen: I'm not completely sure what you mean by that.
01:32:32 <Cale> Just to be careful, when you talk about a monad, you're talking about a type constructor, not a value. Usually values of type M a, where M is some monad are called actions, or computations.
01:32:46 <C-Keen> Cale: I have a function that feeds bytes into a function, which return value are the unprocessed bytes. Those have to feed back into the function. Since the processing function needs to do some IO I have used the type above.
01:32:47 <Cale> (or monadically-typed values)
01:33:29 <Cale> okay
01:33:57 <C-Keen> Cale: but the feeding is in a IO do section hence the type error
01:34:05 <C-Keen> I am not sure how to do this right atm
01:34:32 <Japsu> @index shiftL
01:34:33 <xpik1> what's the advantage of this runKleisli (Kleisli (putStrLn)) "hi"?
01:34:34 <lambdabot> Data.Bits, Foreign
01:34:45 <Cale> xpik1: none at all?
01:34:49 <xpik1> :(
01:36:01 <Cale> xpik1: For any monad m, Kleisli turns the functions a -> m b into an Arrow
01:36:17 <Cale> So you can compose them with the Arrow combinators.
01:36:50 <Cale> But if you just apply Kleisli and then apply runKleisli right after, the net effect is the same as not doing anything.
01:37:03 <Cale> that is,  runKleisli . Kleisli = id
01:37:33 <Cale> C-Keen: well, you can use liftIO to turn IO actions into ErrorT e IO actions
01:37:50 <Cale> C-Keen: and you can use runErrorT to turn ErrorT e IO actions into IO actions
01:38:14 <Cale> C-Keen: So you just have to apply those in suitable places to make the types match what they should be.
01:39:44 <C-Keen> Cale: hm...
01:40:12 <Cale> xpik1: The Kleisli datatype probably serves more instructive purpose than anything. It's a little syntactically overweight for real use, for the most part.
01:40:51 <Cale> hmm
01:41:10 <Cale> > \x y -> runKleisli (Kleisli x *** Kleisli y)
01:41:11 <lambdabot>  Add a type signature
01:41:14 <Cale> :t \x y -> runKleisli (Kleisli x *** Kleisli y)
01:41:15 <lambdabot> forall b (m :: * -> *) c b' c'. (Arrow (Kleisli m)) => (b -> m c) -> (b' -> m c') -> (b, b') -> m (c, c')
01:41:36 <Cale> :t \x y -> runKleisli (Kleisli x &&& Kleisli y)
01:41:40 <lambdabot> forall a (m :: * -> *) c c'. (Arrow (Kleisli m)) => (a -> m c) -> (a -> m c') -> a -> m (c, c')
01:42:07 <ac> @pl (\b -> if (b .&. 1) == 1 then 0xEDB88320 `xor` (shiftR b 1) else shiftR b 1)
01:42:08 <lambdabot> ap (if' . (1 ==) . (.&. 1)) ((3988292384 `xor`) . flip shiftR 1) `ap` flip shiftR 1
01:42:34 <ac> not an improvement
01:43:24 <mauke> \b -> (if odd b then (xor 0xEDB88320) else id) (b `shiftR` 1)
01:44:09 <ac> mauke: doh :)
01:44:21 <ac> mauke: Problem was I was thinking in bits
01:44:55 <xpik1> runKleisli ((Kleisli (\x -> getLine >>=  return . (++x))) <<< (Kleisli (\x -> getLine >>=  return . (++x)))) "c"
01:45:00 <xpik1> that works
01:45:58 <Svrog> would that 2nd one potentially have problems with endianness? odd b vs (b .&. 1) == 1
01:45:59 <glguy> ?seen dons
01:46:00 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 33m 6s ago.
01:46:14 <mauke> > showIntAtBase 2 intToDigit 0xEDB88320 ""
01:46:16 <lambdabot>  "11101101101110001000001100100000"
01:46:24 <mauke> Svrog: no
01:46:38 <xpik1> whereas it doesn't work without the kleisli stuff
01:46:43 <Baughn> :t showIntAtBase
01:46:44 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
01:48:18 <mauke> > ""++ printf "%b" 5
01:48:18 <lambdabot>  Exception: Printf.printf: bad formatting char b
01:48:21 <mauke> :(
01:51:10 <sarah__> what does the forall a. mean?
01:51:39 <ac> sarah__: a is all types
01:51:46 <Cale> sarah__: Essentially what it says :)  For any type a which satisfies the given criteria...
01:51:55 <dcoutts_> @seen dons
01:51:55 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 39m 1s ago.
01:52:03 <Cale> :t length
01:52:06 <lambdabot> forall a. [a] -> Int
01:52:20 <Svrog> yeah you're right mauke - and i think i need more coffee...
01:52:22 <Cale> length, for any type a, takes a list of values of type a, and produces an Int
01:52:33 <sarah__> why i was confused is it said (Integral a) => a, so how can a be any type?
01:52:46 <sarah__> why not just a -> (Int -> Char) -> a -> String -> String?
01:52:53 <faxlore> hello
01:53:05 <mauke> sarah__: because it only works for types that implement Integer
01:53:10 <mauke> er, Integral
01:53:22 <dcoutts_> dons: re: package ptoblems, yes I've been worrying about that issue for a while, that one can end up with compilation problems due to adding new versions of packages that others depend on and then finding bytestring-0.9.0.1:Data.ByteString.ByteString /= bytestring-0.9.0.4:Data.ByteString.ByteString
01:53:36 <ac> @src Integral
01:53:36 <lambdabot> class  (Real a, Enum a) => Integral a  where
01:53:36 <lambdabot>     quot, rem, div, mod :: a -> a -> a
01:53:36 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
01:53:36 <lambdabot>     toInteger           :: a -> Integer
01:54:05 <Cale> Well, it's perhaps useful to note that if you don't explicitly put a forall in front of your types, Haskell will do that for you (in fact, forall isn't in Haskell 98, it's always implicit)
01:54:06 <ac> sarah__: so "a" can be either a Real or an Enum
01:54:06 <xpik1> the problem with many haskell functions are you need to know both the practical and theroretical before you understand a function. for example arrows and monad functions.
01:54:23 <Cale> You kind of have to read it like a formal logic statement, with => being "implies"
01:54:27 <ac> (I think)
01:54:31 <dcoutts_> dons: there are two solutions, recompiling already installed packages to use consistent versions of dependencies or a functional approach of installing extra versions of a package compiled against consistent versions
01:54:45 <mauke> ac: no, it means a must be an Integral, and Integral requires a to be both Real and Enum
01:54:54 <Cale> for any number x,  x > 1  =>  x^2 > 1
01:55:38 <sarah__> ac: still dont know why not just (Integral a) => a -> (Int -> Char) -> a -> String -> String :(
01:55:39 <Cale> The implication makes it clear that we're only saying something about values of x greater than 1, even though x is universally quantified.
01:55:50 <mauke> sarah__: that's the same thing
01:55:59 <faxlore> Hi Cale
01:56:01 <dcoutts_> dons: the point is the latter solution never breaks already installed stuff (because nothing is mutated) but it requires a nix-style ability to have several variants of the same version of a package installed (each built against different versions of its dependencies)
01:56:03 <Cale> sarah__: the forall is implicit if you leave it out
01:56:06 <Cale> faxlore: hi
01:56:07 <faxlore> I coded what we talked about before :D
01:56:17 <Cale> faxlore: cool :)
01:56:22 <sarah__> ah! didnt know that
01:56:25 <ac> sarah__: don't listen to me, I know nothing
01:56:27 * faxlore (puts it here http://rafb.net/p/N0PRyU34.txt )
01:56:48 <faxlore> It looks exactly like the Herbrands algorithm for finding an MGU..
01:57:49 <sarah__> Cale: is stuff like forall a. (a > 5) => a actually allowed?
01:57:59 <mauke> no, 5 is not a type
01:58:02 <Cale> sarah__: Not as a Haskell type :)
01:58:14 <sarah__> hehe ok
01:58:21 <ac> sarah__: Haskell does not have type level numbers (those would introduce a can of worms)
01:58:28 <mauke> @go dependent types
01:58:29 <lambdabot> http://en.wikipedia.org/wiki/Dependent_type
01:58:34 * resiak has evil thoughts about writing a library to process (a subset of) Template Toolkit templates 
01:58:49 <Cale> ac: data Zero = Zero; data Succ x = Succ x
01:58:58 <Cale> :)
01:59:10 <sarah__> instance Num 5 where fromInteger x = 5...
01:59:14 <faxlore> I thought I should try adding some data types
01:59:19 <faxlore> e.g. the things you define with data Type = Somethings..
01:59:29 <mauke> forall a. (GT a (Succ (Succ (Succ (Succ (Succ Zero)))))) => a
02:00:08 <Cale> :)
02:00:16 <ac> you could only do a very limited number of operations on type level numbers
02:00:29 <faxlore> does someone know a description of what typing rules are introduced by a 'data' definition?
02:00:31 <Cale> ac: Not with multiparameter typeclasses and functional dependencies.
02:00:31 <ac> actually, not very limited
02:00:46 <mauke> @go type-level logarithm
02:00:47 <lambdabot> http://okmij.org/ftp/Haskell/types.html
02:00:47 <lambdabot> Title: Haskell Programming: Types
02:00:53 <Cale> ac: Or the new type families stuff, which basically lets you write functions on types directly.
02:01:01 <mauke> http://okmij.org/ftp/Haskell/types.html#peano-arithm
02:01:02 <lambdabot> Title: Haskell Programming: Types
02:01:05 <ac> I guess if you wanted to guarantee termination in type checking, you just couldn't have recursive functions
02:01:14 <faxlore> ac some recursion is ok
02:01:18 <Cale> right, various extensions break that
02:01:45 <Cale> You can actually do arbitrary computation in the type system with some GHC extensions.
02:01:57 <Cale> (it's just awkward)
02:02:09 <ac> Cale: I did read the type level instant insanity article in the monad reader
02:02:34 <ac> Cale: that was what actually gave me my first limited understanding of Haskell's type system
02:02:40 <Cale> :t (\x -> (\y -> (\z -> ((((z x) y) x) y))))
02:02:42 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t -> t1 -> t2) -> t2
02:02:57 <Cale> :)
02:03:05 <mauke> @. djinn type (\x -> (\y -> (\z -> ((((z x) y) x) y))))
02:03:06 <lambdabot> f a b c = c a b a b
02:05:26 <faxlore> actually
02:05:27 <Cale> faxlore: Congratulations on that code, btw. :) Type inference is very much the same thing as finding a most general unifier.
02:05:34 <faxlore> thanks
02:05:41 <faxlore> It is also a simple Djinn thing at the end
02:06:02 <faxlore> only for t ::= v | t -> t
02:06:18 <faxlore> and I just realized that.. data = ... doesn't add any new typing rules does it?
02:06:33 <faxlore> simply adds some constants with a type to the context
02:07:14 <Cale> hmm... well, you end up with type constructors...
02:08:01 <Cale> data List a where Nil :: List a; Cons :: a -> List a -> List a
02:09:01 <Cale> (the GADT style makes it clearer what's going on)
02:09:31 <Cale> But yeah, it's basically more of the same :)
02:10:04 <faxlore> Nothing :: Maybe a,  Just :: a -> Maybe a
02:10:36 <faxlore> I think that.. Djinn can solve Maybe problems but not list problems
02:10:41 <Cale> right
02:10:52 <Cale> Djinn won't generate recursive functions
02:11:24 <ac> In C, let's say you have a "char[] foo" and a "unsigned long bar". Does "foo[10] ^ bar" XOR only foo[10] or foo[10,11,12,13]?
02:11:27 <faxlore> if I wanted to [a] -> (a -> b) -> [b]
02:11:42 <mauke> char[] foo is a syntax error
02:11:49 <mauke> only foo[10]
02:12:17 <faxlore> ?djinn ([a] -> (a -> b) -> [b]) -> [a] -> (a -> b) -> [b]
02:12:17 <lambdabot> f a = a
02:12:22 <ac> mauke: thanks
02:12:29 <faxlore> Is this why it doesn't do recursion?
02:13:35 <Cale> ?djinn [a] -> (a -> b) -> [b]
02:13:35 <lambdabot> -- f cannot be realized.
02:13:55 <faxlore> hey shouldn't there some induction principe for lists
02:14:16 <quicksilver> there certainly are induction principles for lists
02:14:20 <faxlore> like P Nil -> (P x -> P (Cons a x)) -> P y
02:14:25 <quicksilver> it's just that djinn doesn't do that kind of logic
02:14:36 <quicksilver> it could be extended to do so
02:14:38 <faxlore> It would be possible to write map, using rules like that?
02:15:02 <Cale> the logical theory which djinn is based on doesn't prove silly things like (a -> a) -> a
02:15:33 <mauke> case b of [] -> []; (c : d) -> [a c]
02:15:36 <Cale> But yeah, it seems quite likely that you could extend it in some ways :)
02:15:42 <quicksilver> Cale: you can have a logical theory which admits wellfounded recursion but not fix, can't you?
02:15:46 <mauke> :t \a b -> case b of [] -> []; (c : d) -> [a c]
02:15:49 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
02:15:55 <quicksilver> my gut says yes, although I haven't thought about the details.
02:16:00 <Cale> hmm
02:16:21 <faxlore> someone said that, if you added it there would be some problems maybe it would take forever to solve
02:16:35 * faxlore is wondering what a type like couuld be
02:17:58 <quicksilver> if you added unrestricted recursion then certainly
02:18:04 <faxlore> mauke ahhh
02:18:12 <quicksilver> that's why I suggested wellfounded
02:18:23 <faxlore> I wasn't understanding that.. yeah, since there is multiple solutions.. it's very possible to derive a rubbish one
02:18:46 <quicksilver> but, I"m not entirely sure I'm making sense
02:19:00 <quicksilver> I haven't had enough coffee yet and my logic has years of rust on it
02:22:36 <resiak> Cale: eh?  why is proving that fix exists silly? :)
02:23:06 <Cale> resiak: think about what (a -> a) -> a means as a logical theorem :)
02:23:18 <Cale> If a implies a, then a
02:23:50 <C-Keen> hm how can I get a out of Either a a ?
02:24:03 <mauke> C-Keen: case
02:24:09 <faxlore> ?djinn Either a a -> a
02:24:09 <lambdabot> f a =
02:24:09 <lambdabot>     case a of
02:24:09 <lambdabot>     Left b -> b
02:24:09 <lambdabot>     Right c -> c
02:24:22 <mauke> :t either id id
02:24:24 <lambdabot> forall b. Either b b -> b
02:24:39 <faxlore> ohh.. you can do theorem proving using combinators
02:24:51 <faxlore> then proving something like fix is not quite so ridiculous?
02:24:58 <resiak> Cale: true.
02:25:07 <resiak> hrm, can djinn prove (not a -> a) -> a
02:25:30 <resiak> (and, how would i express it as a type!)
02:25:39 <C-Keen> hm. but then there should be no problem when I have f::a->a and applying f Either a a ?
02:25:44 <Cale> @djinn-env
02:25:44 <lambdabot> data () = ()
02:25:44 <lambdabot> data Either a b = Left a | Right b
02:25:44 <lambdabot> data Maybe a = Nothing | Just a
02:25:44 <lambdabot> data Bool = False | True
02:25:44 <lambdabot> data Void
02:25:46 <lambdabot> type Not x = x -> Void
02:25:48 <lambdabot> class Eq a where (==) :: a -> a -> Bool
02:25:50 <resiak> oh, nice
02:25:54 <faxlore> :D
02:25:57 <resiak> @djinn (Not a -> a) -> a
02:25:57 <lambdabot> -- f cannot be realized.
02:26:31 <Cale> The logic which djinn is based on is an intuitionistic logic :)
02:26:54 <doserj> @djinn (Not a -> a) -> Not (Not a)
02:26:55 <lambdabot> f a b = void (b (a b))
02:26:56 <Cale> @djinn (Not a -> a) -> Not (Not a)
02:26:56 <lambdabot> f a b = void (b (a b))
02:27:01 <Cale> damn you!
02:27:02 <Cale> hehe
02:27:05 <doserj> :)
02:27:41 <resiak> ah
02:27:52 <sarah__> hmmm what is this djinn?
02:27:57 <resiak> illuminating!
02:28:01 <TheBlueDude> sorry, i know this is just a simple list operation, but is there a function that tells you if a number appears in a list or not?
02:28:09 <profmakx> is it correct to say "a system with finite state" when i want to say that there is a finite set of states?
02:28:13 <faxlore> > elem 7 [1..]
02:28:15 <lambdabot>  True
02:28:17 <mauke> sarah__: takes a type, outputs a function
02:28:22 <TheBlueDude> cool, thanks
02:28:22 <faxlore> TheBlueDude, yes elem
02:28:40 <TheBlueDude> > elem 6 [3,3,4,6,7]
02:28:42 <TheBlueDude> > elem 6 [3,3,4,7]
02:28:44 <faxlore> @hoogle Int -> [Int] -> Bool
02:28:46 <lambdabot> No matches, try a more general search
02:28:48 <lambdabot>  False
02:28:48 <lambdabot>  True
02:28:49 <faxlore> aw....
02:28:53 <faxlore> :t elem
02:28:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:29:11 <sarah__> TheBlueDude: elem
02:29:16 <faxlore> I think @hoogle Int -> [Int] -> Bool should work
02:29:34 <TheBlueDude> > elem 6 [3,3,4,7]
02:29:35 <lambdabot>  False
02:29:40 <TheBlueDude> > elem 6 [3,3,4,6,7]
02:29:40 <lambdabot>  True
02:30:06 <faxlore> :t either
02:30:07 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:30:11 <TheBlueDude> that's funny, lambdabot did one much faster than the other the first time
02:30:13 <sarah__> @djinn (Maybe a) -> Not (Not a)
02:30:18 <lambdabot> -- f cannot be realized.
02:30:25 <TheBlueDude> so it looked like it got them wrong :-)
02:31:02 <faxlore> When you define a data type
02:31:05 <quicksilver> yeah, it runs them in separate processes
02:31:10 <quicksilver> weird things like that can happen :)
02:31:17 <faxlore> you could generate a lot of useful combinators (like either) for it
02:31:26 <faxlore> and perhaps, do theorem proving by composing those combinators
02:31:34 <C-Keen> what does 'Non-exhaustive patterns in foo' mean?
02:31:52 <faxlore> C-Keen, if a datatype has multiple different constructors, and missed out one
02:32:19 <faxlore> (and it actually tried to use one that wasn't there?)
02:32:31 <faxlore> for example Nothing -> .. ; Just (Left x) -> .. ; doesn't have a case for Just (Right x)..
02:33:06 <daf> > case 3 of 4 -> 4
02:33:08 <lambdabot>   Non-exhaustive patterns in case
02:33:42 <C-Keen> an no my error was that I missed a guard
02:33:45 <daf> > case 3 of 4 -> 4; 3 -> 5
02:33:45 <lambdabot>  5
02:33:54 <faxlore> C-Keen, yeah it's not just case..
02:33:56 <C-Keen> which I guess will result in a case statement
02:34:11 <mauke> > let 2 + 2 = 3 in case 2 + 2 of 3 -> 4
02:34:11 <lambdabot>  4
02:34:44 <C-Keen> what I like about haskell is that it makes you think about data structure first, how to do things is then actually trivial
02:34:46 <daf> mauke: !
02:34:51 <mauke> daf: ?
02:36:24 <daf> the "let 2 + 2 = 3"
02:36:28 <quicksilver> C-Keen: yes, that is my experience too
02:37:04 <quicksilver> > let 2 + 2 = 3 in 2 + 3
02:37:07 <lambdabot>   Non-exhaustive patterns in function +
02:37:08 <quicksilver> ;)
02:37:11 <C-Keen> quicksilver: but this is also the major thing that slows me down at the moment, not being used to haskells data structures
02:37:12 <sarah__> > let 2 + 2 = 3
02:37:13 <lambdabot>  Parse error at end of input
02:37:27 <quicksilver> C-Keen: yes, definitely, it slows you down to start with
02:37:35 <quicksilver> C-Keen: but when you get the hang of it, it's a very useful step.
02:38:03 <daf> it doesn't seem to work execpt in pattern matches
02:38:10 <yondalf_> what text editor do you all use to edit haskell code? vim is a bit slow, even with the indent script i downloaded
02:38:14 <daf> > let 2 + 2 = 3 in 2 + 2
02:38:14 <lambdabot>  3
02:38:20 <daf> oh, hmm, it does
02:38:40 <pierric> @pl f1 f g l = filter f (map g l)
02:38:41 <lambdabot> f1 = (. map) . (.) . filter
02:38:57 <quicksilver> daf: what you're doing is redefining +
02:39:20 <daf> quicksilver: oh!
02:39:40 <daf> > let 2 + 2 = 3 in 2 + 3
02:39:40 <quicksilver> but you're only defining the (2,2) case
02:39:41 <lambdabot>   Non-exhaustive patterns in function +
02:39:46 <daf> right, makes sense
02:39:48 <quicksilver> which is what that's non-exhaustive
02:40:07 <quicksilver> let m + n = m * n in 2 + 3
02:40:10 <quicksilver> > let m + n = m * n in 2 + 3
02:40:11 <lambdabot>  6
02:40:14 <quicksilver> or, more simply
02:40:20 <quicksilver> > let (+) = (*) in 2+3
02:40:21 <lambdabot>  6
02:40:27 <resiak> so it seems that if i have a bunch of function-typed fields in a record declaration, haddock gets confused if i try to document the arguments of the functions.  should this be possible?
02:40:46 <quicksilver> it should but I'm not surprised it isn't
02:40:52 <quicksilver> record fields are second-class citizens :(
02:40:59 <quicksilver> it would be a good bug report on haddock though
02:41:33 <pejo> yondalf, slow how?
02:42:20 <quicksilver> people make many criticisms of vim, but "slow" isn't one I hear often.
02:42:31 <quicksilver> I use emacs, fwiw, as do at least some other people here.
02:42:54 <C-Keen> I use acme, which I do not expect anyone to adopt :)
02:42:54 <faxlore> Is there a good haskell interaction for emacs?
02:43:02 <resiak> i'll get my bug hat on
02:43:05 <osfameron> some vim tasks are slow, often depends on the scripts/features you're using though
02:43:05 * resiak wonders how to work around it
02:43:15 <faxlore> something which gives you more info than like I have a terminal open somewhere
02:43:46 <quicksilver> faxlore: better than nothing, yes. Perfect? no.
02:45:04 <C-Keen> yesss it verks! it verks! mhuahahah
02:54:51 <Cale> > let 0 * m = 0; n * m = m + (n-1) * m in 5 * 6
02:54:52 <lambdabot>  30
02:55:28 <faxlore> > let 0 * m = 0; (n+1) * m = m + n * m in 5 * 6
02:55:28 <lambdabot>  Parse error in pattern at "in" (column 38)
02:55:35 <faxlore> huh..
02:55:43 <opqdonut> yondalf_: emacs
02:55:53 <EvilTerran> \bot doesn't have (n+k) patterns
02:56:53 <TheBlueDude> > let 2 = 1 in 2+2
02:56:55 <lambdabot>  4
02:57:09 <quicksilver> let 2 = 1 is a really odd edge case
02:57:19 <quicksilver> I believe it desugars as follows:
02:57:28 <TheBlueDude> > let how many fingers am i holding up = 5 in how many fingers am i holding up
02:57:28 <quicksilver> let x | fromInteger x == 2 = 1
02:57:29 <lambdabot>   Not in scope: `up'
02:57:37 <quicksilver> where 'x' is a fresh variable you can't access
02:57:42 <quicksilver> in other words, it's useless
02:58:00 <TheBlueDude> > let (how many fingers am i holding up) = 5 in how many fingers am i holding up
02:58:00 <quicksilver> btu I'm not really sure
02:58:00 <lambdabot>  Parse error in pattern at "in" (column 44)
02:58:16 <TheBlueDude> > let (how many fingers am i holding up) = 5 in (how many fingers am i holding up)
02:58:17 <lambdabot>  Parse error in pattern at "in" (column 44)
02:59:08 <gio123> <Cale>hi
02:59:25 <Cale> gio123: hi
02:59:33 <TheBlueDude> hmm... lambdabot does not succumb easily to our brainwashing tehniques
02:59:43 <gio123> <Cale> do u get pm?
02:59:54 <Cale> gio123: ah, I hadn't noticed
03:05:23 <TheBlueDude> > [2,3,4,5] - [2,3]
03:05:28 <lambdabot>   add an instance declaration for (Num [t])
03:05:28 <lambdabot>     In the expression: [2, 3, 4, ...
03:05:41 <TheBlueDude> > excl [2,3,4,5] [2,3]
03:05:42 <lambdabot>   Not in scope: `excl'
03:06:40 <TheBlueDude> is there a function to remove the elements of one list from another?
03:07:14 <tibbe_> is there a cabal channel?
03:07:31 <TheBlueDude> is there a god?
03:07:44 <doserj> @src (\\)
03:07:44 <lambdabot> (\\) = foldl (flip delete)
03:07:50 <doserj> @type (\\)
03:07:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:08:13 <TheBlueDude> > [1.. 10] \\ [1,4,5]
03:08:14 <lambdabot>  [2,3,6,7,8,9,10]
03:08:23 <TheBlueDude> cool, thanks
03:08:54 <doserj> > [1,2,1,2] \\ [1] -- be careful, though
03:08:56 <lambdabot>  [2,1,2]
03:09:17 <TheBlueDude> oooh... ok
03:09:24 <roconnor> > filter (`elem` [1]) [1,2,1,2]
03:09:25 <lambdabot>  [1,1]
03:09:29 <faxlore> @src roll
03:09:29 <roconnor> er
03:09:29 <lambdabot> Source not found. You type like i drive.
03:09:33 <roconnor> > filter (`notelem` [1]) [1,2,1,2]
03:09:34 <lambdabot>   Not in scope: `notelem'
03:09:36 <Cale> TheBlueDude: no.
03:09:37 <roconnor> > filter (`notElem` [1]) [1,2,1,2]
03:09:38 <lambdabot>  [2,2]
03:09:57 <Cale> (but there is a function to remove the elements of one list from another)
03:10:21 <doserj> > [1,2,1,2] \\ [1,1]
03:10:22 <lambdabot>  [2,2]
03:10:44 <TheBlueDude> > Universe \\ Everything
03:10:46 <lambdabot>   Not in scope: data constructor `Everything'
03:10:58 <faxlore> > [1,2,3,4,5,1,6,1,2,3,7,4,5,6] \\ (cycle [1,2,3])
03:11:00 <lambdabot> Terminated
03:13:41 <TheBlueDude> > 2+2
03:13:51 <lambdabot>  4
03:14:32 <TheBlueDude> > let 2+2 = 5 in 2+2
03:14:33 <lambdabot>  5
03:15:07 <TheBlueDude> sorry, just showing a friend lambdabot
03:15:09 <C-Keen> > let 2 = 3;3=2 in 2+3
03:15:10 <lambdabot>  5
03:15:33 <Cin> hellooo haskellers
03:15:55 <C-Keen> hm...
03:16:14 <C-Keen> > putStrLn "Hi"
03:16:15 <lambdabot>  <IO ()>
03:16:35 <C-Keen> > "bla"
03:16:36 <lambdabot>  "bla"
03:16:57 <C-Keen> > main = do putStrLn "Hi"
03:16:57 <lambdabot>  Parse error at "=" (column 6)
03:17:07 <faxlore> "blah" is better than putStrLn "blah"
03:17:53 <C-Keen> I was just wondering whether you could get lambdabot to issue a string like "/part bye" and have it work
03:18:16 <faxlore> C-Keen: "/part" isn't part of IRC protocol.. doesn't make much sense
03:18:16 <quicksilver> no, because lambdabot isn't using an IRC client
03:18:22 <quicksilver> what would you expect to be interpreting the /part
03:18:47 <C-Keen> faxlore: yes, whatever is equivalent in the irc protocol
03:19:12 <C-Keen> I knew once, forgot it soon
03:20:32 <TheBlueDude> > length [0,0,0,0,0,0]
03:20:36 <lambdabot>  6
03:21:21 <gvdm> TheBlueDude: you are aware you can pm lambdabot?
03:22:07 <TheBlueDude> sorry
03:22:27 <TheBlueDude> how do i pm? /pm lambdabot?
03:22:40 <gvdm>  /msg
03:22:49 <TheBlueDude> thanks
03:24:34 <faxlore> @dice 4d12
03:24:35 <lambdabot> 4d12 => 18
03:31:58 <Cin> c-keen: it's just PART in the irc protocol
03:32:36 <TheBlueDude> first to roll 48 wins the jackpot!
03:33:30 <faxlore> @dice 48d1
03:33:30 <lambdabot> 48d1 => 48
03:33:32 <faxlore> :P
03:38:36 <TheBlueDude> that's not rolling, that's sliding
03:39:04 <opqdonut> trolling
03:39:17 <opqdonut> :P
03:40:08 <ndm> @seen dcoutts
03:40:08 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 1d 17h 43m 28s ago.
03:40:13 <ndm> @seen dcoutts_
03:40:13 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 15m 29s ago.
03:40:18 <dcoutts_> ndm: yes?
03:40:33 <ndm> dcoutts_: in Cabal, ghc-options, I have -Wall -O
03:40:44 <dcoutts_> ndm: don't use -O
03:40:55 <ndm> dcoutts_: does Cabal currently pass -O's to GHC, and can I say warnings in a more portable way?
03:41:03 <ndm> yeah, i suspected -O was the wrong thing to do
03:41:06 <dcoutts_> cabal uses it automatically and can disable it with --disable-optimisations
03:41:26 <dcoutts_> as for -Wall, no there is nothing more portable, just don't distribute it with -Werror too
03:41:58 <dcoutts_> we're going to make hackage warn about more dodgy combinations of ghc flags soon
03:42:00 <ndm> dcoutts_: i got a patch this morning moving -O to -O2, and adding -Werror :)
03:42:44 <dcoutts_> ndm: -Werror is fine for development, it's guaranteed breakage for distribution, think what happens when ghc-6.10 adds more helpful warnings.
03:43:12 <ndm> dcoutts_: yeah, i realised that it was probably a bad thing - i'm not even convinced all the GHC -Wall options make much sense
03:43:13 <shag> can i somehow put my program on hold to give the garbace collector a chance to work?
03:43:17 <ac> is there a better way to turn a Word8 to a Word32 then: fromIntegral (fromEnum (1::Word8))::Word32
03:43:20 <dcoutts_> ndm: I also think we should make hackage demand performance numbers to justify using -O2 rather than -O :-)
03:43:23 <ndm> i.e. head (x:xs) = x
03:43:40 <ndm> dcoutts_: agreed, its a bit too easy to turn optimisation up even when its useless
03:43:47 <dcoutts_> ndm: yeah, I'd like to be able to say, yes, I know it's partial, keep it that way
03:43:51 <ndm> ac: fromIntegral?
03:44:04 <dcoutts_> ndm: rather than me having to add lots of error cases and think up error messages each time
03:44:07 <ndm> shag: the garbage collector will stop the program on its own
03:44:16 <ac> ndm: indeed
03:44:26 <dcoutts_> ndm: the built-in error message from pattern match failure is reasonably good since it pin points the location
03:44:29 <ndm> dcoutts_: more the fact that xs is "unused", the partiality thing i can deal with
03:44:33 <shag> ndm: hm, ok, thx
03:44:42 <ndm> dcoutts_: plus soon we'll have --catch and we'll not care anyway ;)
03:44:50 <Igloo> ndm: But it /is/ unused!
03:45:10 <dcoutts_> ndm: good good, we'll want that integrated with other Hackage QA measures :-)
03:45:14 <ndm> Igloo: i know, and i don't think that is a bad thing, i think its better style than head (x:_) = x
03:45:18 <Igloo> ndm: That's a great warning for catching cases where you use x twice, when you meant to use x once and y once
03:45:54 <ndm> Igloo: i know its sometimes a bug, but i think warnings should be often bugs, and always fixable without making the code "uglier"
03:45:54 <Igloo> ndm: And you also don't like head (x:_xs) = x?
03:46:15 * Igloo thinks head (x:_) = x is more beautiful, but maybe I'm just strange
03:46:17 <ndm> Igloo: that one is more acceptable, i guess, but I honestly hadn't though of it
03:46:29 <ndm> i use _ like a keyword, not like a prefix
03:47:15 <ndm> dcoutts_: please also warn about missing Build-Type: Simple, if the Setup.hs appears to be a default one
03:47:39 <dcoutts_> ndm: we now warn about missing build-type always, irrespective of Setup.hs
03:48:01 <dcoutts_> it should now always be specified, even/especially if it's custom
03:48:56 <quicksilver> ac: just a single call to fromIntegral would be simpler :P
03:49:02 <quicksilver> ac: I think that's what ndm meant.
03:49:18 <dcoutts_> ndm: unfortunately I'm not sure I can push that change into Cabal-1.2.x branch for ghc-6.8.3 because it's a minor api change
03:49:35 <dcoutts_> ndm: though probably one that'd not break any sensible packages
03:50:27 <ndm> dcoutts_: i'd say keep it out of 1.2, it can be done all in good time
03:50:44 <ndm> dcoutts_: you've just broken every cabal package once, let's try not to get too violent to package authors ;)
03:50:52 <dcoutts_> ndm: we can certainly make hackage reject new packages that have it missing
03:51:04 <dcoutts_> ndm: I didn't break many packages at all, that was ghc
03:51:07 <ndm> dcoutts_: does it warn yet? best to have a warning period
03:51:24 <dcoutts_> ndm: I only broke 10% that used custom Setup.hs scripts
03:51:28 <ndm> dcoutts_: i know, you == GHC == hackage == Cabal, when someone breaks everyone gets blame
03:51:52 <roconnor> @what closure
03:51:52 <lambdabot> I know nothing about closure.
03:52:04 <dcoutts_> ndm: there's no need to make it a warning for hackage uploads, we can simply reject with the instruction
03:52:12 <ndm> dcoutts_: i guess
03:52:33 <Igloo> Oh, ndm, what was that about /c not having a drive and no longer being an absolute path?
03:53:00 <ndm> Igloo: now FilePath treats /c as a non absolute path
03:53:04 <ndm> and c:
03:53:14 <Igloo> On Linux too?
03:53:14 <ndm> of course, on Posix, /c is absolute
03:53:18 <Igloo> Ah, OK
03:53:31 <ndm> i guess the commit message looks more scary in that case ;)
03:53:59 <Igloo> Heh, yeah, I'd have expected \c if you were talking about Windows  :-)
03:54:49 <ndm> hehe, I use / for windows filepaths
04:03:51 <roconnor> > showIntBase 2 digitToInt 300
04:03:54 <lambdabot>   Not in scope: `showIntBase'
04:04:01 <roconnor> > Numeric.showIntBase 2 digitToInt 300
04:04:01 <lambdabot>   Not in scope: `Numeric.showIntBase'
04:04:09 <roconnor> @hoogle IntBase
04:04:10 <lambdabot> No matches found
04:04:13 <roconnor> :/
04:04:25 <doserj> @hoogle IntAtBase
04:04:25 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
04:04:31 <roconnor> > showIntAtBase 2 digitToInt 300
04:04:32 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
04:04:45 <roconnor> > showIntAtBase 2 intToDigit 300
04:04:46 <lambdabot>  <[Char] -> [Char]>
04:04:51 <roconnor> > showIntAtBase 2 intToDigit 300 ""
04:04:52 <lambdabot>  "100101100"
04:19:43 <ac> Is it generally a good idea to give call backs an IO type, just in case IO needs to be done in the call back?
04:20:46 <ac> I guess it would be nice to provide a decoder with a call back, and one without
04:20:52 <ac> (and encoder)
04:21:54 <quicksilver> ac: better to provide both options
04:22:08 <quicksilver> ac: if you can imagine realistic situations for both
04:22:10 <quicksilver> but....
04:22:24 <quicksilver> bear in mind there is surprisingly little you can do with a non-monadic callback
04:22:46 <quicksilver> so what's more interesting (but slightly harder) is to permit a wider class of (not necesarily IO) monads.
04:28:58 <ac> quicksilver: ah. Well, the use I had in mind for the encoder was to display some sort of progress meeter. For the decoder the spec recommends to have a call back for processing unknown chunks
04:30:15 <ac> quicksilver: the unknown chunks could easily be handled by an additional function that supplies them in a list. That's actually simpler
04:30:27 <ac> using a call back is C style
04:31:58 <hpaste>  ac pasted "CRC defined in the PNG spec" at http://hpaste.org/4986
04:32:10 <quicksilver> ac: nod
04:32:30 <quicksilver> ac: the point is, that a callback function normally has to 'accumulate, or store, or display'
04:32:44 <quicksilver> ac: these are not possible in a "pure callback"
04:32:55 <quicksilver> you need a monad
04:33:03 <quicksilver> but not necessarily IO, of course.
04:33:10 <ac> right
04:33:21 <ac> how do you send a message using lambdabot?
04:33:26 <quicksilver> If anyone is really really pedantic, of course you don't need a Monad, an Applicative would do
04:33:36 <quicksilver> @tell ac please pass this on to my good friend ac
04:33:37 <lambdabot> Consider it noted.
04:33:40 <quicksilver> like that, I think
04:33:59 <C-Keen> what's an applicative?
04:34:13 <opqdonut> you probably mean applicative functor
04:34:18 <ac> @tell davidL I could not get the code you hpasted to produce CRCs matching the C code in the spec, so I wrote http://hpaste.org/4986
04:34:18 <lambdabot> Consider it noted.
04:34:21 <opqdonut> @go applicative functor
04:34:23 <lambdabot> http://www.haskell.org/pipermail/haskell/2004-August/014463.html
04:34:23 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
04:34:34 <opqdonut> hmm, that isn't quite it
04:34:35 <quicksilver> C-Keen: it's a slightly weaker thing than a monad
04:34:41 <opqdonut> @wiki applicative functor
04:34:42 <lambdabot> http://www.haskell.org/haskellwiki/applicative_functor
04:34:46 <quicksilver> C-Keen: it allows you to sequence side effects, but not have one action depend on another
04:35:02 <quicksilver> well,
04:35:09 <quicksilver> not have one action depend on another's return value, I should say
04:35:10 <C-Keen> quicksilver: ah, makes sense when side effects are to be ignored anyway
04:35:47 <quicksilver> any "do" expression which doesn't use <- is using an applicative style
04:35:52 <quicksilver> but, more than that,
04:36:09 <quicksilver> any do expression which only uses the results of <- in a pure function at the end is also in applicative style
04:36:26 <quicksilver> like do { a <- x; b <- y; c <- z; return (f a b c) }
04:36:39 <quicksilver> where the important point is that y and z aren't allowed to depend on a,b,c.
04:40:26 <C-Keen> hm is there a nop I can put at an else branch?
04:41:08 <faxlore> WHat does nop mean?
04:41:23 <ac> What kind of data structure should my image encoder take? A list or an array?
04:41:24 <lambdabot> ac: You have 1 new message. '/msg lambdabot @messages' to read it.
04:42:07 <ac> I'm thinking [Word]
04:42:10 <C-Keen> faxlore: a statement that does nothing
04:42:36 * faxlore doesn't understand..
04:42:38 <quicksilver> C-Keen: haskell doesn't have statements
04:42:45 <quicksilver> C-Keen: think more carefully about what you mean :)
04:42:48 <zeloran> hi
04:42:50 <ac> actually, an "Array (Int,Int) Word" would probably make more sense
04:43:00 <quicksilver> let n = if (a>b) then 3 else ....
04:43:09 <quicksilver> C-Keen: how could you miss out the else, in that example?
04:43:11 <C-Keen> well I like to do something if a condition is met but nothing else
04:43:18 <quicksilver> C-Keen: n is suppose to be a number, so...
04:43:19 <zeloran> stupid question, which is the meaning/semantic of the { brace in haskell?
04:43:42 <quicksilver> C-Keen: "do something" sounds like you might be inside a monad
04:43:45 <byorgey> zeloran: it groups things.
04:43:57 <quicksilver> C-Keen: in that context, return () may be an answer
04:43:57 <doserj> @type when
04:43:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:43:59 <ac> zeloran: not a stupid question. It's used in do notation and let statements
04:44:00 <byorgey> zeloran: it's also used as part of record syntax.
04:44:01 <zeloran> just like normal braces?
04:44:14 <quicksilver> zeloran: it has a similar role to {} in perl and C, for grouping certain language contexts
04:44:24 <zeloran> okay
04:44:30 <quicksilver> zeloran: however in haskell, in most of those contexts, it is optional and you can use layout instead
04:44:40 <ac> zeloran: where { foo; bar; } is used for grouping, the syntax can be substituted for indentation with the ";" replaced with new lines
04:44:56 <zeloran> and for records?
04:45:15 <quicksilver> C-Keen: as doserj hints, when is a acutaly a shortcut for if cond then blah else return ()
04:45:19 <zeloran> does is separate the elements?
04:45:20 <ac> zeloran: AFAIK the { } syntax is required for records
04:45:37 <quicksilver> yes, {} is required in records, and they use commas not semicolons
04:45:42 <C-Keen> quicksilver, doserj thanks
04:45:49 <quicksilver> Constructor { a = 1, b = 2}
04:46:54 <ac> zeloran: or a record type: data RecordType = RecordConstructor { a :: Int, b :: Int, c :: String }
04:47:41 <zeloran> thanks, that helps me alot
04:48:14 <zeloran> [1..]
04:48:32 <zeloran> does this hang up lambdabot?
04:49:28 <ac> > [1..]
04:49:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:49:48 <ac> > let inf = inf in inf
04:49:49 <lambdabot>  Exception: <<loop>>
04:50:03 <zeloran> > [1..]
04:50:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:50:07 <C-Keen> this isn't legal haskell is it?
04:50:14 <zeloran> it is
04:50:21 <C-Keen> let a = a in a is?
04:50:26 <ac> C-Keen: it's an infinite loop
04:50:44 <ToRA> > let a = 1 : a in a
04:50:45 <doserj> > let a = a in a
04:50:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:50:45 <lambdabot>  Exception: <<loop>>
04:50:46 <ac> C-Keen: that will crash ghci, but lambabot has some checking
04:50:54 <zeloran> > 1 +1
04:50:55 <lambdabot>  2
04:50:57 <byorgey> zeloran: lambdabot runs code in a special resource-limited environment, so it gets killed after a certain number of seconds, and only prints so much output
04:51:15 <zeloran> lets exploit it :P
04:51:37 <ac> lambdabot is diehard
04:51:46 <quicksilver> I don't think let a = a in a really crashes ghci
04:51:51 <ac> quicksilver: does for me
04:52:06 <quicksilver> no, I don't think it does
04:52:08 <byorgey> I just get a stack overflow
04:52:10 <mux> doesn't for me, it just loops indefinitely
04:52:12 <quicksilver> it sends it into an infinite loop
04:52:14 <quicksilver> that's not a crash
04:52:16 <mux> and it has always done that
04:52:19 <quicksilver> you can stlll C-c
04:52:20 <ac> quicksilver: oh fine
04:52:38 <ac> byorgey: after how long?
04:52:49 <ToRA> doesn't take up memory or cpu though
04:52:50 <dv> it's just idling here, not even using any cpu
04:53:13 <quicksilver> it's a detectable blackhole
04:53:19 <daf> haha
04:53:25 <quicksilver> the thread ends up suspended
04:53:26 <daf> ghci's infinite loops are well optimised
04:53:34 <quicksilver> that's why lambdabot can give an exception
04:53:42 <quicksilver> I guess ghci can't because it has more threads running
04:55:30 <resiak> i thought that the loop-finding optimization only happens in the compiler, not the interpreter
04:56:18 <quicksilver> it's not an optimisation
04:56:26 <quicksilver> it's a side-effect of how evaluation is implemented :)
04:56:48 <quicksilver> it's designed to stop two different threads evaluating the same thunk
04:57:03 <quicksilver> but it naturally catches the case when on thread comes back to the same thunk recursively too
04:57:17 <opqdonut> oh, nice
04:57:52 <resiak> oh, okay.
04:58:02 <resiak> that's quite neat!
04:58:33 <opqdonut> indeed
05:02:05 <quicksilver> along similar lines, it can detect certain kinds of deadlock
05:02:15 <byorgey> ac: less than a second
05:02:20 <quicksilver> if a thread is waiting on an MVar, and the GC notices that no other thread has a reference to that Mvar...
05:02:43 <quicksilver> or, more strongly, that the only other threads with references to that MVar are themselves deadlocked too
05:03:02 <quicksilver> byorgey: odd. It runs forever on mine. which ghci version?
05:03:21 <ac> Is there a type class for n-tupples?
05:03:51 <ac> I want the type "Array (Int,Int) (Word,...)"
05:04:08 <ac> I guess I could simply use a list
05:05:52 <byorgey> quicksilver: 6.8.2.
05:05:55 <doserj> funny, in 5 tries, it gave a stack overflow twice :)
05:06:05 <byorgey> and what's odd, I tried running it again, and this time it ran forever
05:06:08 <quicksilver> ;)
05:06:11 <byorgey> doserj: oh, interesting =)
05:06:24 <quicksilver> ac: probably you should use a list
05:06:34 <quicksilver> ac: you can write a class for n-tuples but it's not clear what it gains you
05:06:41 <quicksilver> there isn't much you can do 'generically' with n-tuples
05:06:48 <ac> quicksilver: hm. I only have a few possibilities
05:07:17 <quicksilver> to be clear, I meant Array (Int,Int) [Word]
05:07:23 <quicksilver> I didn't mean ditch the array completely.
05:08:17 <ac> quicksilver: yeah. It's for various formats of images. Word can be 4,8, or 16, and there can be 1,3, or 4 of them
05:09:22 <ac> guess there is no Word4 :-P
05:11:42 <quicksilver> hmm
05:11:53 <quicksilver> you probably will want a class, at some point
05:12:19 <quicksilver> Pixal a => Array (Int,Int) a
05:12:23 <ac> I'll just call it Pixel. It will be especially useful to have a class if I'm going to be writing image operations too
05:12:23 <quicksilver> something like that
05:12:29 <ac> yeah
05:13:11 <ac> huh. I wonder if I'm going to end up writing a whole image library to go along with this. Haskell doesn't really have many native libraries for this sort of thing
05:13:21 <ac> er, any that I can find
05:13:33 <quicksilver> not really, no
05:13:39 <quicksilver> there are bits and pieces in gtk2hs and opengl
05:13:49 <quicksilver> I've done some pixel-based work in haskell using openGL
05:13:55 <ac> yeah so have I
05:14:09 <ac> but nothing like drawing lines and characters
05:14:28 <ac> a ttf library would be a serious chunk of work I'd imagine
05:14:39 <quicksilver> yes, probably better to bind to a C lib
05:14:45 <quicksilver> than try to write one :)
05:15:11 <ac> yeah it's not too hard to turn a Foreign.Ptr in to an Array
05:15:37 <ac> in fact, with withArray, you don't have to even bother, right?
05:16:12 <quicksilver> that's right
05:16:16 <quicksilver> and indeed, I don't bother
05:16:29 <ac> but, with withArray, you're always dealing with a one dimensional array
05:16:47 <ac> so perhaps I should make my encoder take an "Array Int Pixel" too
05:17:15 <ac> because AFAIK, any sort of "(Array Int a) -> (Array (Int,Int) a)" function is a pain, and slow
05:18:39 <quicksilver> erm
05:18:42 <quicksilver> what?
05:18:55 <quicksilver> withArray doesn't just deal with 1D data
05:19:03 <ac> oh?
05:19:21 <ac> :t withArray
05:19:22 <lambdabot> Not in scope: `withArray'
05:19:28 <ac> @index withArray
05:19:29 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
05:19:44 <ac> :t Foreign.withArray
05:19:45 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
05:19:59 <quicksilver> hmm, that's not the one I was thinking of
05:20:07 <ac> :t Foreign.Marshall.withArray
05:20:08 <lambdabot> Couldn't find qualified module.
05:20:10 * quicksilver checks code
05:20:14 <ac> :t Foreign.Marshal.withArray
05:20:17 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
05:20:55 <jedbrown> ac: I don't know about the format, but perhaps you could use StorableVector which is like a strict bytestring, but for arbitrary (storable) types.  You can get a UArray out of it in O(1).
05:21:08 <quicksilver> hmm
05:21:17 <quicksilver> actually I'm using StoreableArray now
05:21:46 <quicksilver> ac: I think my memory was slightly befuddled. I used to use withArray with a list []
05:22:02 <quicksilver> ac: now I use StorableArray
05:22:14 <quicksilver> and it is a 2D StorableArray
05:22:22 <quicksilver> (contents generated from a list though because that's the functional way)
05:23:57 <ac> jedbrown: so you're saying you can turn a pointer in to a StorableVector, which can be turned in to an Array?
05:24:03 <ac> er, UArray
05:24:30 <ac> @index StorableVector
05:24:31 <lambdabot> bzzt
05:24:44 <jedbrown> ac: StorableVector is just a wrapped ForeignPtr, so yes.
05:25:07 <jedbrown> http://code.haskell.org/~sjanssen/storablevector
05:25:07 <lambdabot> Title: Index of /~sjanssen/storablevector
05:25:55 <ac> jedbrown: the problem is the C ffi to whatever graphics library I'm using would have to return a type of StorableVector in order to easily produce UArrays
05:26:46 <quicksilver> the C FFI is going to give ou a foreignptr
05:26:54 <quicksilver> the storablevector just wraps that
05:26:55 <quicksilver> AIUI
05:26:59 <quicksilver> so nothing would be double copied
05:27:03 <ac> ah ok
05:27:26 <ac> so you wouldn't have to modify the C lib calls
05:30:07 <ac> hmmm. UArrays can only hold single values. They'd have to be 1 dimensional then
05:31:33 <ac> I don't think it really matters that much because this isn't very speed critical
05:32:21 <ac> it's only being done once, and I'm already mapping over every pixel
05:33:10 <ac> It would be easy to provide functions for processing both one dimensional UArrays and multidimensional arrays
05:34:05 <jedbrown> ac: I think I made a mistake claiming that you could make the UArray directly, although in principle, it should be possible.
05:34:38 <jedbrown> ac: But I doubt you really need to go to UArray since Storablevector should have all the operations you need.
05:34:51 <quicksilver> there really isn't much different between 1-d and multi-d arrays
05:34:55 <quicksilver> that's the part I'm not understanding
05:35:04 <quicksilver> AFAIK everything you can do with 1-d arrays you can do with multi-d ones too
05:35:21 <jedbrown> It's just indexing.  Something that C fails miserably with.
05:35:22 <ac> quicksilver: it's a matter of convenienc. With 1-d arrays you have to store extra information (mainly a width)
05:36:03 <ac> if you're doing image operations it's of course slightly nicer to have a 2d array
05:36:24 <jedbrown> ac: That information has to be there anyway because the machine needs it.  You can make a type that encapsulates it.
05:38:50 <ac> I just want someone to tell me what sort of data type(s) would be ideal for representing 1,3, or 4 channels of Word8s or Word16s ;)
05:40:34 <cnwdup> I've a problem building haskell-hscurses. runhaskell Setup.hs build (after configure) exits with the following error: ghc-6.8.1: does not exist: HSCurses/CWString_hsc.c. Does anyone know what I can do now?
05:42:18 <quicksilver> ac: at some stage you seemed to be saying "I would prefer to do this with 2-D arrays, that would be more elegant but I can't, because you can't use *FOO* with 2-D arrays".
05:42:21 <ac> I think I want something like "data Image = Image Int Int Int UArray Word"
05:42:22 <quicksilver> ac: FSOV FOO.
05:42:30 <quicksilver> ac: My assertion is that there is no such foo
05:42:41 <quicksilver> I think all the useful array functions work on 2-D arrays just as well as 1-D
05:42:50 <quicksilver> so, if 2-D is what you want then use it :)
05:43:06 <ac> make that "(UArray Word)"
05:43:38 <quicksilver> (UArray (Int,Int) Word)
05:43:39 <quicksilver> ?
05:44:57 <ac> Well it's either "Int (UArray (Int,Int) Word)" or "Int Int (UArray Int Word)" ;)
05:45:37 <quicksilver> ;)
05:45:45 <quicksilver> I don't see any advantage in the 1D array.
05:45:48 <ac> I think UArrays are good to use, so I need an Int to represent number of channels
05:46:50 <ac> nm
05:47:08 <ac> man I've ran out of brain juice or something
05:48:30 <jedbrown> ac: How is the memory aligned?  That is, do you have [(Word,Word,Word)] or ([Word],[Word],[Word])  ??
05:48:55 <ac> former always
05:52:24 <jedbrown> ac: Then for performance, you want to guarantee that your type is completely unboxed.  Perhaps better would be to use bytestrings directly and write your own indexing function (i.e. 3-byte aligned lookup).
05:53:02 <jedbrown> I'm favoring raw bytestrings for portability.  Unless I'm missing something.
05:53:26 <quicksilver> it's a speed of modification vs speed of loading tradeoff
05:53:31 <ac> jedbrown: isn't a ByteString essentially a list?
05:53:32 <quicksilver> and it depends what you're expecting to do with the file
05:54:00 <quicksilver> you need to outline a bit more the use case of the library to get the right answers
05:54:01 <jedbrown> ac: It's an array based on ForeignPtr.  It supports list-like operation.
05:54:22 <ac> jedbrown: but you can also peek at it in O(1)?
05:54:32 <quicksilver> yes
05:54:37 <jedbrown> ac: I think make a class that supplies the lookup function, then make instances for the various alignments.
05:54:40 <quicksilver> ByteStrings are just chunks of bytes in memory
05:54:53 <quicksilver> they support O(1) lookup and substring
05:55:47 <ac> but like I was saying, I don't think performance is really much of an issue. I just want to use what would be most convenient to transform likely image data structures in to
05:56:07 <Sizur> hmm, i wonder if it'd be useful to port python's multiDim array using ByteStrings
05:56:40 <dcoutts_> ac: lazy ByteStrings are even more list like, they're lazy (and represented by a list of strict ByteString chunks)
05:56:47 <ac> like something from gtk2hs, or something you generated on your own
05:57:14 <quicksilver> ac: most convenient is probably along the lines of an array of Pixels
05:57:19 <quicksilver> ac: where Pixel is a class
05:57:32 <quicksilver> ac: which supports methods like: getRed, getBlue, getGreen
05:57:38 <quicksilver> ac: redBits, blueBits, greenBits
05:57:39 <quicksilver> and so on
05:58:14 <quicksilver> instance Pixel Word32 where { getRed a = a & 0xff000000; getBlue a = a & 0x0000ff00; redBits a = 8 .... }
05:58:31 <quicksilver> you might want to consider going via 'Float'
05:58:43 <Sizur> multiDim array are a good convenience, and an implementation as a library will simplify lives of ppl who do need to index multidimensionally.
05:58:53 <quicksilver> because Float is quite a good general purpose color value model for going in between different bit depths
05:59:53 <ac> hmmm. you mean where values are between 0 and 1?
06:00:06 <quicksilver> yeah
06:00:11 <ac> too many options! ;)
06:00:11 <quicksilver> openGL uses it mostly
06:00:21 <quicksilver> it's a very convenient format for computation
06:00:25 <ac> yeah
06:00:27 <quicksilver> you can multiply
06:00:40 <quicksilver> so you could decide getRed :: a -> Float
06:00:56 <ac> are there 16 bits worth of floats between 0 and 1?
06:01:00 <quicksilver> yup
06:01:08 <quicksilver> more like 26 I think
06:01:15 <quicksilver> Double might be faster though
06:01:16 <ac> then that's definitely a good idea
06:01:52 <ac> I should definitely be looking at this from a "convenience to the user" perspective rather than "easiest or most efficient to implement" perspective
06:02:00 <quicksilver> so, class Pixel a where { getRed :: a -> Double; redBits :: a -> Int; create :: Double -> Double -> Double -> a}
06:02:04 <Sizur> quicksilver: why would Double be faster? i thought the fpp pads floats anyway
06:02:05 <quicksilver> I would use Double then.
06:02:24 <quicksilver> Sizur: why waste all those opcodes padding and rounding?
06:03:18 <Sizur> i assumed it's a parallel pipeline
06:03:39 <ac> yeah usually a CPU can do several floating point operations per cycle
06:03:57 * Sizur not a cpu engineer
06:04:27 * quicksilver shrugs
06:04:30 <quicksilver> I dunno.
06:04:41 <quicksilver> Double is normally faster than Float, Float is normally premature optimisation.
06:04:54 <koeien> well, test it :)
06:05:03 <koeien> if it's important
06:05:06 <quicksilver> GL uses Float extensively because (a) it's very old and (b) some hardware used to use it natively, I think.
06:05:11 <quicksilver> htat's my understanding.
06:05:21 <Sizur> yeah
06:05:33 <Sizur> anyways, Double is better anyway
06:07:16 <ac> what's the opposite of withArray? I want something with like "(Storable a) => Ptr a -> ([a] -> IO b) -> IO b"
06:07:51 <ac> actually "... ([a] -> b) -> b" would be better
06:08:48 <quicksilver> ac: somethng using peekArray, I think
06:09:07 <quicksilver> ac: Ptrs don't know how long they are
06:09:12 <quicksilver> they really are, just pointeres
06:10:57 <dcoutts_> @seen BMeph
06:10:57 <lambdabot> BMeph is in #haskell. I don't know when BMeph last spoke.
06:11:05 <dcoutts_> BMeph: ping
06:11:11 <BMeph> dcoutts_: pong
06:11:26 <dcoutts_> BMeph: ah, you reported that registry issue with cabal-install
06:11:37 <dcoutts_> BMeph: I was wondering if you could test a fix for me
06:11:40 <BMeph> Find something for (other) useful Windows build reports? ;)
06:12:02 <BMeph> I'd love to try it. :)
06:12:05 <dcoutts_> BMeph: I'll push the patch, can you pull, rebuild cabal-install and test it
06:12:08 * dcoutts_ pushes...
06:14:37 <ac> What's the ByteString equiv. of peekArray?
06:14:50 * dcoutts_ grumbles about slowness of ssh push over slow adsl
06:15:02 <dcoutts_> ac: head or index
06:15:21 <dcoutts_> ac: it's got the same api as lists, that's the way to remember
06:15:52 <dcoutts_> (though uses index rather than !! since qualified operators are a tad silly)
06:16:02 <ac> dcoutts_: I mean a function that takes a foreign Ptr and an Int and returns a ByteString
06:16:16 <jedbrown> ac: fromForeignPtr
06:16:19 <dcoutts_> oh, see the .Internal module
06:16:21 <BMeph> dcoutts_: I'm at work, but I use a Windows machine here, too.
06:16:45 <dcoutts_> BMeph: ok, finally finished pushing
06:17:01 <ac> What's the second Int for?
06:17:06 <dcoutts_> ac: offset
06:17:25 <dcoutts_> BMeph: btw, be on the lookout for an error I kept running into which was a failure cleaning up the temp dir after installing something
06:17:50 <dcoutts_> BMeph: if you find out more about when or why that happens please report it in the hackage trac
06:18:09 <BMeph> dcoutts_: Sure. I'll just be happy to see a listing for once. ;)
06:18:22 <dcoutts_> BMeph: it looked like it was deleting a file that was still open, though we'd waited for the process that was using the file to terminate
06:19:13 <dcoutts_> BMeph: ok, so after building, do cabal update
06:19:14 <BMeph> dcoutts_: Wow, I like laziness as much as the next guy, but that sounds a little TOO lazy... ;)
06:19:25 <dcoutts_> BMeph: right :-)
06:19:46 <olsner> > [2..] >>= (\n -> ["Bon!", "Digi!", "Bon!", "Digi!"] ++ replicate n "Bon!" ++ replicate n "Digi!")
06:19:47 <lambdabot>  ["Bon!","Digi!","Bon!","Digi!","Bon!","Bon!","Digi!","Digi!","Bon!","Digi!",...
06:19:57 <jedbrown> dcoutts_: I didn't understand the offset parameter at first.  Then it struck me that if you change the base pointer, the whole chunk would be gc'd.
06:20:17 <olsner> > [2..] >>= (\n -> [["Bon!", "Digi!", "Bon!", "Digi!"] ++ replicate n "Bon!" ++ replicate n "Digi!"])
06:20:19 <lambdabot>  [["Bon!","Digi!","Bon!","Digi!","Bon!","Bon!","Digi!","Digi!"],["Bon!","Digi...
06:20:26 <dcoutts_> BMeph: it is as if the kernel is not closing until a short while after the process terminates, ie being lazy / using GC or something
06:20:51 <ac> ok, well now I'm decided on creating functions for both "[Word]" (for convenience with C libs) and "UArray (Int,Int,Int) Pixel" as quicksilver suggested for the convenience of constructing custom images.
06:20:53 <dcoutts_> jedbrown: erm, I don't think it changes GC at all
06:20:58 * mux notes that while haskell is lazy, it is also eager from the point of view of catching errors - it tries to catch them ASAP instead of being lazy and deferring those at runtime :-)
06:21:08 <olsner> > map (\n -> ["Bon!", "Digi!", "Bon!", "Digi!"] ++ replicate n "Bon!" ++ replicate n "Digi!") [2..]
06:21:09 <lambdabot>  [["Bon!","Digi!","Bon!","Digi!","Bon!","Bon!","Digi!","Digi!"],["Bon!","Digi...
06:21:36 <quicksilver> ac: 3D?
06:21:48 <dcoutts_> jedbrown: the offset + length is how we take substrings of a bytestring, it does not affect when the chunk is GC'ed. Any live substring retains the whole string.
06:21:50 <ac> quicksilver: last dimension is for non greyscale images ;)
06:22:07 <quicksilver> ac: oh colour planes instead of RGB pixels?
06:22:17 <quicksilver> I think that might be less convenient to be honest
06:22:36 <ac> quicksilver: UArray can only hold Words or Numbers, not tupples I think
06:23:02 <quicksilver> Hmm.
06:23:29 <ac> quicksilver: if you're creating custom images and manipulating them in Haskell code, I think UArray is a good choice
06:23:31 <quicksilver> makes me think UArray may not be the right answer.
06:23:39 <quicksilver> maybe just plain Array?
06:23:56 <ac> quicksilver: is it easy to convert between them?
06:23:59 <quicksilver> although certainly for my example of 'instance Pixel Word32'
06:24:11 <quicksilver> a Word32, although it contains R,G,B and A information
06:24:21 <quicksilver> is still UArray-able
06:24:28 <ac> quicksilver: oh right
06:24:34 <quicksilver> yes, conversion between different types is easy
06:24:45 <quicksilver> I think images of more than 32bpp are still fairly rare
06:24:45 <ac> quicksilver: good point. I'd use Word64, so I can 4 channels of 16 bits
06:24:58 <jedbrown> dcoutts_: Hmm.  if tail (PS p o l) = PS (p + 1) o (l - 1); and the initial reference was not kept, would the runtime know that the chunk couldn't be gc'd?
06:24:58 <BMeph> dcoutts_: Building 1.3.3 ...
06:25:33 <dcoutts_> jedbrown: we never ever modify the pointer, only the offset and length
06:25:49 <Philippa> quicksilver: they're starting to crop up on GPUs
06:25:59 <quicksilver> ac: well, you'd make word64 an option, just like word32 is
06:26:03 <Philippa> but that's more for precision while rendering
06:26:06 <quicksilver> ac: they'd both be instances of Pixel.
06:26:11 <jedbrown> dcoutts_: Yes, but isn't that so that the runtime holds onto the block.  If not, you could modify the pointer, right?
06:26:16 <quicksilver> Philippa: *nod* trying to cut down on error accumulation
06:26:45 <BMeph> dcoutts_: Hmm, is there still a unix pkg dependency on cabal-install?
06:26:52 <dcoutts_> jedbrown: yes I guess so
06:26:58 <dcoutts_> BMeph: not on windows
06:27:10 <dcoutts_> BMeph: at least there shouldn't be! :-)
06:27:15 <dcoutts_> BMeph: build problems?
06:27:29 <BMeph> dcoutts_: Okay - there's no note of that in the README file.
06:27:51 <dcoutts_> BMeph: I'm not sure I understand
06:28:05 <dcoutts_> why should we document that there is no unix dep?
06:28:51 <BMeph> dcoutts_: Because unix is listed in the dependencies in the README file, so it would be nice to say that it isn't actually needed on a Windows build.
06:29:00 <dcoutts_> jedbrown: it'd actually only be relevant for foreign blocks since heap allocated blocks have a separate pointer to the beginning of the block
06:29:06 <BMeph> Oops, got a problem on the cabal-install build:
06:29:13 <dcoutts_> BMeph: oh, it's just wrong, lemme fix that
06:29:23 <jedbrown> dcoutts_: Of course having the offset make some operations simpler and things easier to reason about.  But I learned something when I realized that you couldn't implement it by modifying the pointer.
06:29:31 <BMeph> "Hackage/HttpUtils.hs:23:14: Not in scope: `bracket'"
06:30:27 <BMeph> dcoutts_: It doesn't ask for a unix dependency when it's running, so it's lilkely not in the cabal file itself, just left-over in the README, that's all.
06:30:37 <dcoutts_> BMeph: change:
06:30:37 <dcoutts_> -import Control.Exception (try)
06:30:37 <dcoutts_> +import Control.Exception (try, bracket)
06:31:08 <dcoutts_> BMeph: the useage of bracket was inside the #ifdef WIN32 so I missed it
06:31:25 <dcoutts_> BMeph: try patching that and carry on building
06:31:28 <jedbrown> dcoutts_: Oh, maybe I confused something.  Normally the gc knows about the whole block, so any live reference into it means to keep the whole thing?
06:31:28 <BMeph> dcoutts_: Changing...
06:31:53 <dcoutts_> jedbrown: you want to look at the representation of ForeignPtr for heap allocated blocks
06:32:10 <BMeph> dcoutts_: Okay, it linked.
06:32:23 <dcoutts_> BMeph: ok, I'll push a patch for that bug
06:32:30 <dcoutts_> BMeph: try cabal update
06:33:28 <dcoutts_> jedbrown: it uses two pointers, a normal heap pointer to the ByteArr# and also a raw address pointing to the beginning of the data withing the ByteArr#
06:33:28 <mxc> question, if one has to use windows, which is smoother, using the windows pot of ghc or doing everything through cygwin?
06:33:47 <BMeph> WOOT! Cabal update does NOT bomb out! Yay! 8D
06:33:53 <dcoutts_> mxc: ghc does not have a cygwin flavour
06:34:00 <mxc> problem solved
06:34:01 <mxc> ty
06:34:15 <dcoutts_> BMeph: :-)
06:34:31 <dcoutts_> BMeph: ok, so try something simple like cabal install uniplate
06:35:07 * BMeph does a "happy compile" dance
06:35:11 <BMeph> <(  <)      ^(     )^        (>  )>
06:35:52 <dcoutts_> BMeph: thanks for testing that
06:36:19 <BMeph> dcoutts_: Sure.
06:36:38 <jedbrown> dcoutts_: Thanks for the pointer.  I'll check it out when I have more time.  I need to hide irc and get an abstract for EGU submitted.
06:36:58 <BMeph> Good news: uniplate pulls down great (grats, Neil!), but I had a problem with HXT, a funny one:
06:37:00 <BMeph> "C:\>cabal install HXT --> cabal: Unresolved dependencies: HXT -any"
06:39:09 <BMeph> dcoutts_: Hm, just went back and did a "make tests" on cabal:
06:39:11 <BMeph> "tests/ModuleTest.hs:68:17: -->    Could not find module `Distribution.Simple.GHCPackageConfig':"
06:39:59 <dcoutts_> BMeph: those tests are all bitrotted
06:40:31 <hpaste>  BMeph pasted "Distro.Simple listing" at http://hpaste.org/4987
06:41:25 <BMeph> dcoutts_: Oh, NM, then. So, what's up with HXT - incestuous package deps? ;p
06:41:55 <dcoutts_> BMeph: it's case sensitive at the moment
06:42:28 <dcoutts_> BMeph: that's bug #167
06:42:29 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/167
06:42:30 <lambdabot> Title: #167 (cabal-install should treat package names case insenitively in the UI where ...
06:43:05 <dcoutts_> BMeph: currently the cabal list command is case insensitive but the others are case sensitive :-(
06:43:19 <dcoutts_> BMeph: so try cabal list HXT and you'll see it's actually "hxt" you want
06:43:46 <dcoutts_> BMeph: if you want to try fixing that it should be relatively straightforward
06:46:55 <BMeph> Interesting, it seems to give that as a general "I don't see that" response - it did the same thing after I tried to install "hxr" ;)
06:48:03 <invitado31> hola
06:48:35 <invitado31> hola
06:48:38 <invitado31>  chicocs
06:50:58 <dcoutts_> BMeph: there is no hxr package, you said "hxt" first time
06:51:24 <dcoutts_> there is hxt-7.1, 7.3 and 7.4
06:52:16 <quicksilver> dcoutts_: I think BMeph is tryin to say that the error message for "package not found" takes the same form as the error he saw
06:52:37 <dcoutts_> oh ok
06:53:03 <dcoutts_> BMeph: please report your UI gripes on the hackage but tracker
06:53:05 <dcoutts_> but/bug
06:53:23 <dcoutts_> so we don't forget and so we can prioritise
06:56:39 <quicksilver> ooh, HStringTemplate
06:56:40 <quicksilver> nice
06:58:20 <quicksilver> is Sterling Clover known to be an IRCer?
07:01:21 <srid> anybody willing to take an algorithm challenge? - http://nearfar.org/x/regime/
07:01:22 <lambdabot> Title: Regime Challenge
07:02:57 <sclv> quicksilver: hi there.
07:03:06 <quicksilver> hello sclv
07:03:09 <quicksilver> ah
07:03:16 <quicksilver> sterling clover? AICMFP?
07:03:36 <sclv> yes to the former, befuddled by the latter abbreviation.
07:04:06 <quicksilver> http://en.wikipedia.org/wiki/And_I_claim_my_five_pounds
07:04:18 <quicksilver> sclv: nice work on stringtemplate, looks like a nice thing indeed
07:04:19 <sclv> ah. gotcha.
07:04:23 <quicksilver> I must find an excuse to try it
07:04:59 <sclv> I'm planning to hackage it, but want to see it get a bit of use first so that some kinks get worked out first.
07:05:36 <quicksilver> I have spend 15 years (on and off) writing half-assed template systems and using three-quarter-assed ones written by other people
07:05:49 <quicksilver> so the suggestions of the stringtemplate author ring clearly in my ears
07:07:20 <sclv> it's got a few funny corner-cases in java (because it's in java) but the grammar itself that he developed is pretty powerful. really is almost a fancy lambda-calculus. (so i suspect that it is almost turing-complete actually, but not in any way that any sane person could abuse.)
07:10:22 <sclv> quicksilver: have you tried to build it using 6.8 yet?
07:10:50 <quicksilver> no, I haven't taken the 6.8 leap yet.
07:11:05 <quicksilver> actually I haven't tried your code yet. I just read about it on the mailing list and thought it looked cool :)
07:11:20 <sclv> ah, me neither. i wrote the compatibility stuff blind. it should work, but i'm still a bit worried.
07:11:24 <sclv> :-)
07:13:29 <Igloo> Is there a "revert this change" button on the haskell.org wiki?
07:14:03 <gwern> Igloo: you click edit old revision and save :)
07:14:09 <gwern> at least for non-admin users and using this old mediawiki
07:14:52 <Igloo> Aha, thanks!
07:21:11 <ac> @hoogle [Word8] -> IO ()
07:21:12 <lambdabot> No matches, try a more general search
07:21:25 <ac> (looking for a binary print)
07:21:48 <quicksilver> what does a binary print do?
07:21:58 <quicksilver> is it [Word8] -> String you're after?
07:22:14 <quicksilver> or do you want to output some Word8s to a handle?
07:22:15 <profmakx> .oO(prints little black dots onto paper)
07:22:23 <ac> quicksilver: the latter
07:22:34 <quicksilver> the ugly but easy way is to go via string
07:22:40 <quicksilver> map (toEnum.fromIntegral)
07:22:45 <quicksilver> will get you from [Word8] to String
07:22:51 <quicksilver> then you can hPutStr them
07:23:07 <ac> That's what I figured I'd end up doing
07:23:12 <quicksilver> a cleaner-looking way is to go via ByteString
07:23:26 <quicksilver> in which case you're looking for hPut h . pack
07:23:40 <quicksilver> feels cleaner due to avoiding detour via Char ;)
07:24:17 <quicksilver> in some of my code I wrote versions of hPut and hGet which worked better on Word8s and not Chars, felt much cleaner.
07:24:23 <quicksilver> but these days I just use ByteString anyway
07:27:30 <ac> how'd you write a new hPut?
07:30:21 <quicksilver> by using map (toEnum.fromIntegral) behind the scenes :)
07:30:26 <quicksilver> btu at least it was hidden and I didn't feel bad
07:34:01 <ndm> @seen dcoutts
07:34:01 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 1d 21h 37m 22s ago.
07:34:06 <ndm> @seen dcoutts_
07:34:07 <lambdabot> I saw dcoutts_ leaving #gentoo-haskell, #haskell, #ghc and #haskell-overflow 25m 20s ago, and .
07:34:21 <ndm> is there any way i can figure out which packages on hackage depend on tagsoup?
07:34:36 <ndm> i'm about to make a new release, and would love to prod all the users to fix any issues that come up
07:35:54 <quicksilver> that's a good question
07:36:05 <quicksilver> I don't know the answre, I'm afraid, but I'll be interested to hear it.
07:36:12 <quicksilver> maybe we need an HDBC interface to hackage
07:36:40 <quicksilver> SELECT name FROM packages NATURAL JOIN depends WHERE depends_on = 'tagsoup'
07:38:04 <ac> so does putStr produce UTF-8?
07:38:06 <osfameron> NATURAL JOIN ?
07:38:58 <twanvl> ?google tagsoup filetype:cabal
07:38:59 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/tagsoup/tagsoup.cabal
07:40:25 <ndm> twanvl: that one i know about ;)
07:40:47 <ndm> twanvl: but it does work, many thanks :)
07:41:50 <matthew-_> anyone here and awake who knows stuff about openssl headers and stuff?
07:43:27 <pejo> matthew, build problems in general, or trying to create haskell bindings against it?
07:43:50 <ac> nm. that's done with utf8-string
07:44:24 <ac> odd that the Char data type fully supports unicode, but putStr does not
07:45:47 <matthew-_> pejo: specifically, the sha.h header on some platforms (and according to openssl.org) only contains SHA1 functions. However, Debian, Ubuntu and presueably others, have SHA0, SHA224, SHA256, SHA384 and SHA512 in there too and I can't work out where they come from, esp as Debian's source claims it's original openssl
07:46:23 <matthew-_> (and I realise this isn't really haskell related, but I generally have more luck asking here than elsewhere)
07:49:51 <ndm> how can you debug a stack overflow that only happens in Hugs?
07:50:38 <doserj> ndm: there is http://hackage.haskell.org/packages/advancedsearch.html
07:50:39 <lambdabot> Title: HackageDB: advanced search
07:50:56 <doserj> required-by: tagsoup gives hackage2hwn
07:51:19 <doserj> (required-by and depends-on seem to be named unintuitively...)
07:51:22 <MisterZ> Hey everyone. Could anyone please help me debugging this code?
07:51:24 <MisterZ> remNegatives :: [Int] -> [Int]remNegatives [] = []remNegatives (x:xs)  | isNegative x = [] : remNegatives xs  | not(isNegative x) = x : remNegatives xs  where    isNegative :: Int -> Bool    isNegative x      | x<0 = True      | otherwise = False
07:51:43 <MisterZ> Type checkingERROR "practice.hs":33 - Type error in application*** Expression     : [] : remNegatives xs*** Term           : []*** Type           : [a]*** Does not match : Int
07:51:45 <ndm> doserj: thanks
07:51:46 <pejo> matthew, there's a 4500 line long diff for libssl-dev for etch atleast.
07:52:28 <MisterZ> however I think that xs is still a list if ints so I don't understand the error message. I'm a newbie btw...
07:52:41 <twanvl> MisterZ: isNegative x = [] : remNegatives xs  -- what does this do?
07:53:04 <MisterZ> twanvl: It shall remove all the negative Ints from the list
07:53:16 <matthew-_> pejo: yeah I read it
07:53:51 <matthew-_> pejo: I'm now looking at the raw source from openssl.org and the extra SHA functions ARE in there, despite what openssl's SHA manpage says
07:54:12 <twanvl> "[] : something" adds the empty list to the head of another list, so that means something has to be a list of lists
07:54:13 <MisterZ> twanvl: and the line you showed sall exclude the negative number... And I think I need the empyt list
07:54:23 <daf> > [] : [1]
07:54:25 <lambdabot>   add an instance declaration for (Num [a])
07:54:25 <lambdabot>     In the expression: 1
07:54:48 <daf> > [] : [[]]
07:54:49 <lambdabot>  [[],[]]
07:54:53 <daf> > 0 : [1]
07:54:53 <lambdabot>  [0,1]
07:55:11 <MisterZ> Ahh, I see...
07:56:00 <MisterZ> Thanks a lot. ;)
07:58:00 <matthew-_> ok, anyone here using openbsd (other than dons who I presume is asleep)
07:59:01 <BMeph> matthew-_: Maybe peddling in to work, but likely, he's not asleep.
08:01:19 <BMeph> MisterZ: What you're doing is easier expressed as just: remNegatives = filter isNegative
08:01:47 <quicksilver> ac: yes, very very odd isn't it. And strange.
08:02:00 <quicksilver> ac: and ANNOYING :)
08:02:51 <quicksilver> osfameron: natural join uses columns with the same name (and type) as the join condition, as god, codd, date and darwen intended.
08:03:33 <ehird`> is there a vim file for haskell >indentation<?
08:04:10 <quicksilver> I believe their is
08:04:14 <quicksilver> but I couldn't tell you wehre
08:04:41 <ehird`> :P
08:04:45 <quicksilver> google search for 'haskell vim indentation' gives some promising looking results
08:04:53 <ehird`> googled a bit, got a few things but it;ll require more looking
08:07:24 <dcoutts> ndm: not yet, if you'd like to add links to reverse deps then take a look at the hackage-scripts repo
08:07:26 <osfameron> quicksilver: oh, handy
08:09:23 <ndm> dcoutts: desire to hack cabal is low, compared to my todo list :)
08:09:54 <dcoutts> ndm: same for everyone, hence everyone suggests lots of good ideas for hackage and none get implemented
08:10:32 <ndm> dcoutts: i think my todo list is bigger than most!
08:11:23 <dcoutts> ndm: I try and keep my todo list short but not adding things to it :-)
08:12:24 <ibid> dcoutts: gtk2hs is again a teaching tool in my fp course, btw
08:12:40 <dcoutts> ibid: great :-) I used it last term too
08:13:07 * ndm started teaching today
08:13:10 * ibid is, this time, using SOE as a guide for arranging the material
08:13:15 <ndm> @karma- ada
08:13:15 <lambdabot> ada's karma lowered to -1.
08:13:24 * ibid had the third lecture today
08:13:46 * yaxu pollutes planet.haskell further
08:13:56 * quicksilver thinks ndm's *done* list is bigger than most people's.
08:14:02 <quicksilver> and that's much more interesting :)
08:15:21 <ibid> yeah, done lists are generally much more interesting than todo lists
08:15:26 <quicksilver> ndm: have you written anything down about this intruiging parser generator you mentioned/
08:15:29 <quicksilver> ?
08:19:39 <ndm> quicksilver: http://www-users.cs.york.ac.uk/~ndm/parsing/
08:19:40 <lambdabot> Title: Neil Mitchell - Parsing
08:20:15 <ndm> quicksilver: plus ttp://www-users.cs.york.ac.uk/~ndm/helix/ for the algorithmic work required for the claims in parsing to be true
08:20:32 <ndm> maximal munch lexing is not O(n), its O(n^2), so I had to fix that first...
08:21:34 <ndm> dcoutts: you remember that you find intersperse was overly strict? did that get fixed
08:21:40 <ndm> its just bit me in a very nasty way!
08:22:06 <quicksilver> ndm: nice, thanks.
08:22:24 <dcoutts> ndm: you mean the H98 List.intersperse ?
08:22:31 <stefanha> Hi, I have compiled a module using ghc ... -c Vector.hs.  How can I use that module from a separate program elsewhere?  I tried using ghc -i path/to/module/dir but get "Failed to load interface for `Vector': it is not a module in the current program, or in any known package.".
08:22:34 <ndm> dcoutts: yep
08:22:56 <quicksilver> ndm: are we talking about weeks, months or years for your parser, given all the other cool stuff you're doing?
08:23:04 <dcoutts> ndm: it's not fixed, I'm going to put my suggestions to the Haskell-prime people at some point
08:23:19 * Nafai watches Wadler's BayFP talk
08:23:33 <dcoutts> ndm: I was writing about the strictness testing for my thesis just the other day
08:24:15 <ndm> dcoutts: too late, we need it right now, its a clear bug in the Prelude
08:24:22 <dcoutts> ndm: how did it bite you? it's a pretty subtle difference I didn't think anyone would notice
08:24:24 <ndm> quicksilver: likely years :(
08:24:38 <dcoutts> ndm: well you can get our impl if you need it
08:24:39 <quicksilver> ndm: *nod* ;)
08:24:42 <ndm>         show2 xs = "[" ++ concat ( {- intersperse "\n," $ -} map show xs) ++ "\n]"
08:25:10 <ndm> when you are showing [replicate bignumber 'a', something ...
08:25:37 <ndm> dcoutts: you should just report it as an out and out bug, which is what it is, and get it fixed ASAP
08:25:54 <ndm> quicksilver: i did the initial parser work about 4 years ago
08:25:56 <twanvl> > take 5 $ intersperse '_' ("abc"++undefined)
08:25:57 <lambdabot>  Undefined
08:26:00 <dcoutts> ndm: it's a bug in the spec, so H' is the right place to fix that
08:26:08 <twanvl> > let intersperse _ [] = []; intersperse sep (x:xs) = x : is xs where is [] = []; is (y:ys) = sep : y : is ys in take 5 $ intersperse '_' ("abc"++undefined)
08:26:08 <lambdabot>  "a_b_c"
08:26:16 <ndm> dcoutts: its a horrible bug in teh spec, so the right place to fix that is right now
08:26:30 <ndm> dcoutts: i think we changed inits or tails to be slightly more lazy recently
08:26:35 <dcoutts> ndm: I don't see how it's horrible
08:26:46 <twanvl> inits and tails were not changed either
08:26:47 <ndm> dcoutts: it means it isn't as lazy as it could be, so breaks my program!
08:27:06 <dcoutts> ndm: turns non-_|_ into _|_?
08:27:20 <twanvl> the solution for h98 compatability is simple: fix them in Data.List, but not in List
08:27:27 <glen_quagmire> :t (_|_)
08:27:30 <lambdabot> parse error on input `|'
08:27:35 <ndm> intersperse 'x' ('y':_|_) = _|_
08:27:38 <ndm> when it shouldn't do
08:27:51 <ndm> shove a take 2 in front of that, and you've gone from non-_|_ to _|_
08:28:16 <ndm> twanvl: i disagree, lets just fix it at the root cause, the functions were always intended to be "as lazy as possible", this one they made a mistake
08:28:40 <twanvl> yes
08:29:06 <twanvl> I agree they should be fixed right now, but I can understand why some people don't want to yet
08:29:09 <ndm> if your program breaks because intersperse becomes less strict, i'd say your program was already broken, and i'd love to see a real program that does this
08:29:27 <ndm> as it stands, i can't use intersperse, i'll have to use intersperseNotBroken
08:29:29 <ndm> which is just ugly!
08:30:28 <quicksilver> well you can import hiding (intersperse)
08:30:37 <quicksilver> and import NDMFixes(intersperse)
08:30:54 <ndm> that's rude
08:30:55 <quicksilver> but I agree that I can't see how the fix would break anyone's code.
08:30:59 <ToRA> ndm: how do you implement intersperseNotBroken?
08:31:12 <ndm> the great thing about open source is that you can fix the code, rather than patching junk over junky interfaces
08:31:15 * mux notes there weren't much reactions to his tails1/inits1 proposal except bulat going mad, and he wonders what to do with this
08:31:30 <ndm> ToRA: see about 15 lines back for twanvl's implementation
08:31:58 <ndm> mux: i'm still not convinced they are the right name, given foldr1 crashes, and these are more like tails_without_0
08:32:50 <mux> ndm: same here, but couldn't find anything better
08:33:06 <mux> ndm: note however that there are some data types named List1, and designating a non-empty list
08:33:14 <quicksilver> @src intersperse
08:33:15 <lambdabot> intersperse _   []     = []
08:33:15 <lambdabot> intersperse _   [x]    = [x]
08:33:15 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
08:33:31 <ndm> i have just wasted some of my time fixing a bug in code which is well known to be buggy, and i'd rather someone else (perhaps less experienced) didn't have a similar experience in future
08:33:44 <quicksilver> yeah, someone simply didn't think of the problem
08:33:51 <matthew-_> well, just adding a ~ would solve it wouldn't it? (sorry if this has already been asked...)
08:34:05 <quicksilver> don't think so, no
08:34:31 <gwern> is there anyway in darcs to have a preference which says 'send patchs to this address'?
08:35:32 <ndm> gwern: darcs setprefs email, i think....
08:35:43 <ndm> it is definately possible, and it creates a file email with the email address in it
08:36:08 <matthew-_> oh no. ok.
08:36:12 <gwern> hm. email isn't listed as a pref
08:36:41 <gwern> 'Valid preferences are: test predist boringfile binariesfile.'
08:36:49 <ndm> you can definately do it
08:36:54 <matthew-_> ahh, adding the ~ and removing the middle case solves it
08:37:07 <ndm> gwern: http://www.cs.york.ac.uk/fp/darcs/tagsoup/_darcs/prefs/email
08:37:23 <ndm> matthew-_: removing the middle case changes the semantics
08:37:27 <matthew-_> (in addition to twanvl's solution - which is obviously the same thing)
08:37:46 <matthew-_> oh ok, I'll actually try thinking then
08:38:53 * matthew-_ finally "gets" it
08:38:58 <gwern> ndm: what darcs are you using? maybe I have an old version
08:39:06 <Toxaris> is there a name for (foldr (Control.Applicative.<|>) hidden somewhere?
08:39:21 * gwern has 1.1.0pre1
08:40:24 <ndm> gwern: i set that file manually
08:40:46 <ndm> gwern: my darcs doesn't have it as a setpref
08:40:47 <gwern> it seems to ignore _darcs/pref/email even if I manually set it...
08:40:59 <dcoutts> ndm: as far as I am aware you are the first to have noticed in practise that intersperse was too strict, when dons and I discovered it we thought it was of only theoretical interest
08:41:39 <dcoutts> twanvl: or did you find some example before too? since you have the more lazy definition to hand
08:41:59 <twanvl> I just wrote it
08:42:04 <dcoutts> oh ok
08:42:25 <dcoutts> twanvl: it's exactly the same (alpha-renamed) as the one in our stream fusion list lib
08:43:02 <dcoutts> we verified that it's a refinement of the H98 spec using StrictCheck
08:43:24 <dcoutts> prop_intersperse        = Test.intersperse `refines2`   Spec.intersperse
08:44:04 <dcoutts> ndm: in case you care about the others, intercalate is too strict as is unwords
08:44:12 <BMeph> dcoutts_: Sorry about not saying much for the past two hours - compiling HXT all but shut my conputer down (and it's STILL not done).
08:44:32 * Toxaris found Data.Foldable.asum 
08:44:54 <dcoutts> BMeph: oh yeah, that's a nasty one. It's almost as bad as WASH
08:45:43 <BMeph> dcoutts_: Anyhow, it looks like your latest patch fixed it for Windows.
08:45:56 <BMeph> Thanks a Bundle! :)
08:45:59 * doserj cannot even compile simple things like haddock or Cabal on one machine (needs to much RAM during linking)
08:46:05 <BMeph> dcoutts_++
08:46:35 * BMeph feels doserj's pain, since his work computer has 480 MB installed
08:46:47 <BMeph> dcoutts++
08:47:00 * doserj has 192MB on that machine :)
08:47:06 <dcoutts> doserj: you need more recent binutils I think, or don't use split-objs
08:47:26 <matthew-_> how do people use machines with < 2GB RAM? It's cheap people!
08:47:52 <dcoutts> BMeph: great. btw, do file any gripes you find in the hackage trac, don't assume we know all the problems already
08:48:04 <ndm> dcoutts: yes, i ran into it in real life, so it isn't just thoeretical
08:48:10 <roconnor> @quote ubuntu
08:48:11 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
08:48:15 <Deewiant> DDR SDRAM is cheap, but what if your machine wants plain SDRAM or RDRAM :-P
08:48:16 * ndm wears out his trac login...
08:48:33 <matthew-_> Deewiant: then it's probably cheaper to buy a new machine :p
08:48:47 <dcoutts> ndm: you can point to the impl in http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/List/Stream.hs
08:49:35 <dcoutts> ndm: and to the fact that we verified that version refines the H98 spec
08:49:48 <Deewiant> matthew-_: yeah, cheaper than to buy new RAM, but still a lot more expensive than just a DDR RAM stick :-P
08:50:41 * matthew-_ can't really talk seeing as he has a stack of 5 Sun SparcStation 10s, and SGI Indigo 2 and an SGI Indy behind his desk
08:51:03 <Deewiant> heh
08:51:25 <dcoutts> matthew-_: some of those old boxes have a lot of ram though, I'm using a 500Mhz SunBlade but it's got 1G ram
08:54:22 * matthew-_ considers getting ghc to run on his LinkSys NSLU2 with 32MB RAM...
08:55:31 <C-Keen> hm can I run my haskell script 'in the background' while editing parts of it with ghci?
08:56:17 <BMeph> I'd love more RAM on my machine, but since hacking Haskell isn't part of my job description, it'd be tough to justify the request to IT, my boss, my boss' boss... ;)
08:56:20 <byorgey> C-Keen: you can run it, sure, but it won't automagically reflect any changes you make without being restarted.
08:56:40 <tibbe> is it possible to partly reexport a module?
08:57:01 <C-Keen> byorgey: ah ok, well I was wondering wether there is a haskell 'environment' like there is for lisp or erlang
08:57:06 <byorgey> C-Keen: you can, however, be editing it in one window, and have it loaded in ghci in another, then when you make a change, just hit :r in ghci and it will get reloaded
08:57:26 <byorgey> C-Keen: maybe that's the kind of thing you're looking for?
08:57:30 <C-Keen> byorgey: sure I do that :)
08:58:01 <byorgey> tibbe: sure.  in the export list, put something like 'module Foo(blah, blah)'  (I think)
08:58:38 <C-Keen> byorgey: I was thinking about a programme that processes a data stream and I want to change the way it is processed w/o having to interrupt the stream. Think of fault injection
08:59:18 <tibbe> byorgey: great, thanks
08:59:57 <byorgey> C-Keen: sounds like you want something like hs-plugins, perhaps?
09:00:04 <tibbe> byorgey: nope :( only whole modules
09:00:09 <C-Keen> @wiki hs-plugins
09:00:09 <lambdabot> http://www.haskell.org/haskellwiki/hs-plugins
09:00:14 <byorgey> tibbe: oh, boo =(
09:00:43 <byorgey> tibbe: oh, wait, you just list the functions you want to re-export
09:00:53 <tibbe> right
09:01:13 <byorgey> module Foo ( a, b, c) where  import Bar (a,c,d)   b = ...
09:01:55 <byorgey> C-Keen: @wiki = ("http://www.haskell.org/haskellwiki/" ++), not very useful =)
09:01:57 <lambdabot> Title: Haskell - HaskellWiki
09:02:07 <tibbe> byorgey: that did it :)
09:02:14 <byorgey> tibbe: oh good =)
09:02:28 <tibbe> although it's a little bit redundant but I can live with that
09:02:34 <byorgey> yeah
09:02:56 <byorgey> well, you don't have to list the imports explicitly
09:03:18 <C-Keen> byorgey: yes it looks like that's the thing I want
09:05:18 <byorgey> C-Keen: xmonad, Yi, and lambdabot all use this sort of reload-on-the-fly architecture
09:05:40 <byorgey> C-Keen: so it may prove helpful to study how they're written
09:06:00 <quicksilver> matthew-_: it seldoms makes sense to add ~ to a middle case
09:06:09 <C-Keen> byorgey: thanks for answering my next question :)
09:06:14 <quicksilver> matthew-_: since that kills all the cases after that
09:06:24 <C-Keen> byorgey: what's Yi?
09:06:27 <matthew-_> quicksilver: no, I was meaning the bottom case
09:06:36 <byorgey> C-Keen: it's an editor
09:06:37 <matthew-_> quicksilver: but I was utterly wrong anyway
09:06:56 <byorgey> C-Keen: Yi is to Haskell as Emacs is to lisp
09:07:07 <byorgey> i.e. written and extensible in
09:07:53 <puusorsa> except that elisp is among the most braindead lisps, and yi is not very usable as an editor (yet. imho.)
09:08:59 <byorgey> well, I didn't say it was a very good analogy =)
09:09:11 <byorgey> I've never actually used Yi
09:09:11 <Chronosphear> hi, i've just started learning haskell. i'm reading yaht and the function isLower doesn't seem to work in hugs. i get ERROR - Undefined variable "isLower"
09:09:15 <quicksilver> since emacs is, in fact, written in C :)
09:09:23 <byorgey> Chronosphear: welcome!
09:09:26 <Chronosphear> thanks
09:09:28 <ndm> Chronosphear: you need to do "import Char" first
09:09:30 <byorgey> quicksilver: ...oh yeah. =)
09:09:43 <Chronosphear> it doesn't like that either
09:09:52 <Chronosphear> Hugs> import Char
09:09:53 <Chronosphear> ERROR - Syntax error in expression (unexpected keyword "import")
09:09:59 <C-Keen> puusorsa: there are folks rewriting emacs in ansi CL...but I don't know how mature that code is
09:10:00 <dons> :l Char
09:10:02 <ndm> Chronosphear: ":load Char" at the prompt
09:10:03 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:10:11 <quicksilver> or Data.Char ?
09:10:16 * quicksilver tends to use the new names
09:10:21 <Chronosphear> ah, thanks
09:10:24 <puusorsa> C-Keen, yi might be usable before that is done
09:10:30 * ndm does too, but tends to tell newbies Char, since its simpler
09:10:34 <C-Keen> puusorsa: maybe :)
09:10:45 <quicksilver> I'm sure yi will be usable centuries before CL-emacs is usable.
09:10:52 <puusorsa> hooray!
09:11:01 <quicksilver> there have been more projects to port emacs to other scripting languages than I can count
09:11:05 <ndm> plus if the tutorial is so old that it still has isLower in the Prelude, it probably isn't heirarchical module names
09:11:06 <quicksilver> they have all notably failed :P
09:11:12 <Chronosphear> so should it now be Char.isLower?
09:11:24 <quicksilver> no, it should just work now
09:11:28 <quicksilver> since you're loaded the module
09:11:28 <Chronosphear> it doesn't
09:11:29 <ndm> Chronosphear: :load Char puts all the Char functions in scope, so just isLower
09:11:39 <sarehu_> Chronosphear: just curious, which edition of YAHT are you using?  The wikibook or the PDF?
09:11:40 <C-Keen> byorgey: so I have been using hs-plugins all the time w/o knowing it :)
09:11:42 <Philippa> point, I should try yi again now I've got a linux machine I'm using regularly again
09:11:42 <Chronosphear> oh
09:11:47 <Chronosphear> pdf
09:11:54 <gwern> byorgey: I think xmonad uses a different architecture. yi/lambdabot use the GHC API and patch themselves, but xmonad compiles a fresh version and serializes some state for the new binary. or something like that
09:11:57 <Chronosphear> i think i tried to load something else and it kicked out Char
09:12:25 <sarehu_> oh, I'm looking at it now.  Looks like a bug :)
09:12:30 <byorgey> gwern: actually, you're right.
09:12:50 <byorgey> Chronosphear: yes, unfortunately, Hugs can't load more than one module at once =(
09:13:03 <byorgey> Chronosphear: this is the point where I say you might want to use ghci instead =)
09:13:14 <Chronosphear> i think you're right
09:13:27 <gwern> someone needs to write 'Hugs Considered Harmful'
09:13:35 * ndm is using Hugs right now
09:13:48 <ndm> one compiler being the only one for Haskell would be very harmful
09:14:05 <quicksilver> I note that hugs + ghc only makes one compiler :)
09:14:06 <gwern> is hugs a compiler?
09:14:09 <quicksilver> but I know what ndm means
09:14:27 <Chronosphear> there's nmh right?
09:14:27 <quicksilver> multiple haskell implementations is a good thing
09:14:36 <sarehu_> maybe
09:14:51 <quicksilver> it's still reasonable to ask the question 'which interpreter should newbies use?' though
09:14:57 <quicksilver> and these days, ghci feels like a better option to me
09:15:32 <ndm> i still think Hugs is better, the type error messages are much more friendly
09:15:44 <ndm> plus with WinHugs you get a lot more friendly interface
09:15:52 <Chronosphear> if you use windows
09:15:57 <gwern> if you want friendly type errors go use helium
09:16:09 <ndm> quicksilver: compiler is such an outdated term, there is no such thing
09:16:14 <gwern> and ghci isn't that unfriendly with type errors. at least, I never saw any difference
09:16:29 <sarehu_> there is such thing as a compiler
09:17:02 <Philippa> there are few good interpreters for modern hardware that don't have what amounts to a compilation phase internally
09:17:04 <gwern> sarehu_: careful, ndm might start whipping out terms like partial evaluation on you!
09:17:06 <ndm> no, there isn't - there are some many levels of virtual machines etc between code and the electrons that making one more important than the other is a bit silly
09:17:22 <misterZ> hey again, I would need someone's help again. I would need to write an own version of the reverse function found in the prelude. The function shall take a non empty list and then reverse its order. Example: myReverse [1, 2, 3] shall return [3, 2, 1]
09:17:34 <misterZ> Anyone has any idea? Needs to be as simple and basic as it can.
09:17:40 <misterZ> Any hints?
09:17:49 <ndm> i.e. assembly is compiled into a RISC based language in two steps, asm -> microcode -> nanocode, 2 recompilers actually on the chip!
09:17:52 <sarehu_> a compiler is something that translates from one language to another, no?  They exist.
09:17:53 <Philippa> ndm: I disagree with your terminological quibble, but then I've been known to nail people for saying "the Java 'compiler' isn't a proper compiler"
09:18:15 <ndm> Philippa: exactly, when you get things like Java, it gets a lot more ambiguous
09:18:17 <Deewiant> a "compiler" is just something that translates code from one language to another
09:18:25 <ndm> which Hugs does
09:18:27 <quicksilver> ndm: if you think hugs is better, perhaps you can answer the original questioner's question about loading more than one module at once?
09:18:37 <quicksilver> because I certainly can't.
09:18:38 <Philippa> ndm: I don't think it does, I think there's a lot of people who just can't think straight about the definitions
09:18:38 <Deewiant> higher-level to lower-level usually
09:18:46 <blarz> misterZ: look on haskell.org wiki and search for 99 Haskell Problems, theres a solution for it
09:18:59 <dcoutts> ndm: ghci's error messages have been a lot better than hugs's for several years now
09:19:01 <ndm> quicksilver: don't, write a module and import two things
09:19:08 <quicksilver> not to me ;) to him.
09:19:14 <ndm> dcoutts: i disagree, i still find the Hugs ones much more readable
09:19:21 <ndm> quicksilver: its a pain to do, the usual solution is not to bother
09:19:23 <quicksilver> That sounds to me like one reason ghci is better than hugs.
09:19:27 <dcoutts> ndm: they're shorter, but not more comprehensible to students
09:19:43 <misterZ> blarz: cheers
09:19:46 <Philippa> and having more info is often useful if you've got something weird going on, too
09:19:54 <Philippa> which happens a lot more once you step outside H98
09:20:09 <dcoutts> ndm: I've field tested both with students and when they don't understand the hugs one I suggest trying ghci and that's usually a lot better they say
09:20:37 <byorgey> misterZ: is this an assignment?  if so it's probably best to try writing your own version before looking it up on the wiki.
09:21:01 <Philippa> dcoutts: presumably the more info?
09:21:04 <ndm> dcoutts: i've found the reverse :)
09:21:10 <Deewiant> what annoys me about ghci are the "suggest making an instance of Num (Char -> [Char])" type messages :-P
09:21:27 <ndm> dcoutts: although what i've really found is that having two suggestions and perspectives is better than one
09:21:43 <dcoutts> ndm: perhaps you should file some ghc bugs then :-)
09:21:46 <Philippa> I have to admit that I usually ignore suggestions
09:21:54 <dcoutts> ndm: yes, that's probably true
09:22:04 <ndm> dcoutts: my desire is for error messages to be short, and preserve the layout of the original
09:22:18 <ndm> there is no need to repeat my code 4 times at different levels of depth
09:22:50 <Philippa> I've had occasions when doing it at 2 or 3 levels has helped clear up ambiguities
09:23:01 <Philippa> and sometimes it helps tell you where a broken expectation's come from
09:23:06 <dcoutts> ndm: sure sometimes the code snippets are silly but I particularly mean the quality of the human readable message
09:23:24 <Philippa> at least it gives you the smallest snippets first, too
09:23:27 <ndm> dcoutts: "couldn't infer unification context"
09:23:28 <quicksilver> I have the impression I've foudn the multiple level snippets useful
09:23:31 <quicksilver> I can't remember why
09:23:55 <quicksilver> I would strongly suspect that programming style dictates the kind of errors you have to face most often
09:24:02 <dcoutts> ndm: then file a bug and include what hugs says for the same code
09:24:03 <quicksilver> which, in turn, makes this rather subjective
09:24:27 <quicksilver> since each of us write differnet programs, throw up different kinds of error more often, and have developed ways of reading them
09:24:41 <Philippa> it's especially useful for "where did that annotation come from?" - sometimes it would be nice to be able to get an explicitly parenthesised and {;}ed version when you suspect it's a precedence error, too
09:25:30 <Philippa> I do prefer preserving original layout if you're not going to do that though
09:25:31 <desegnis> The main thing I find difficult about ghc error messages is to locate the code that touches the expected and inferred types... probably because ghci cannot guess what I want it to tell me ;)
09:25:48 <Philippa> yep, I've commented before that sometimes I want a dump of the typing to explore
09:26:00 <desegnis> yep
09:26:06 <Chronosphear> sounds like haskell is a pain it the ass to debug
09:26:10 <Chronosphear> in*
09:26:11 <Philippa> (for the non-type-theorists: "typing" = the derivation of the types)
09:26:11 <quicksilver> heh
09:26:23 <quicksilver> Chronosphear: to be fair, we're talking about the worst cases here, not the best :)
09:26:45 <quicksilver> Chronosphear: but certainly newcomers to haskell find debugging a different experience than in other languages.
09:26:48 <Philippa> Chronosphear: there're some fairly solid techniques for catching weird type errors, usually they come from having tried to do something that'd be a complete headfuck in another language
09:26:54 <quicksilver> however, I certainly prefer debugging haskell to debugging perl
09:27:08 <quicksilver> Chronosphear: one difference is that haskell tends to catch errors at compile-time not runtime
09:27:13 <desegnis> in re dump of typing: especially if type classes are involved, when the compiler doesn't know whether the programmer's error is in the handling of the instances, or the application of a function in the context of the given instances.
09:27:18 <quicksilver> that's actually nicer. You waste less time, in the long run.
09:27:18 <Philippa> I should write up the complaint I had about the GHCi debugger and the ST monad...
09:27:36 <ndm> Philippa: what you really want is a visual expression tree with every node annotated with type, which will solve virtually everything, especially if you get folding on the AST
09:27:40 <Philippa> desegnis: right, if you're debugging two layers at once life is harder
09:27:43 <quicksilver> Philippa: there are user interface issues with displaying typings well enough to be readable and concisely enough not to information overload.
09:27:46 <Chronosphear> i doubt the compile time errors can be any worse than c++ STL compile errors
09:27:53 <Philippa> ndm: I need slightly more than that actually, I want to see the dataflow as well
09:27:58 <quicksilver> Philippa: the best solutions I can imagine would be graphical and slightly interactive
09:28:01 <Philippa> at which point you've essentially got a typing
09:28:08 <quicksilver> (in the sense of 'click here to expand this bit')
09:28:10 <Philippa> yep
09:28:24 <Philippa> if I just had typing dumps I'd be loading them up into an app for it pretty quick
09:28:45 <quicksilver> so maybe the soution is (1) make ghc dump typings (2) wait for philippa to write app
09:28:48 <quicksilver> ;)
09:29:06 <Philippa> (2) has a nasty tendency to be non-terminating
09:29:11 <quicksilver> damn
09:29:19 <quicksilver> but you said "pretty quick"! ;)
09:29:41 <Chronosphear> presumably compared to the decay of carbon
09:29:46 <Philippa> sure. But I'd probably rig up some bastard kludge based on an existing app if I could get away with it
09:29:57 <Philippa> because at least I'd get it running fast
09:30:18 <Philippa> this is one of those things that lisp is still generally better at than haskell, unfortunately
09:30:44 <Philippa> in that if you dump out the lisp tree representation then code on the other end doesn't even need a format description in advance
09:31:11 <dons> ?users
09:31:11 <lambdabot> Maximum users seen in #haskell: 458, currently: 433 (94.5%), active: 24 (5.5%)
09:31:21 <quicksilver> dons: have you got graphs of that data?
09:32:01 <byorgey> @yow !
09:32:02 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
09:32:02 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know WHY!!
09:35:44 <Chronosphear> this yaht seems to think let is optional but ghci seems to be insisting on it. is this impl. specific?
09:37:38 <quicksilver> Chronosphear: might be a hugs/ghci difference, I'm not sure
09:37:49 <quicksilver> Chronosphear: I can confirm that in ghci let is definitely not optional :)
09:37:50 <ibid> Chronosphear: in the interpreter context, you mean?
09:37:57 <quicksilver> Chronosphear: in a standalon file you should not put the let, though
09:38:01 <Chronosphear> yeah, i'm using ghci
09:38:04 <quicksilver> files are not quite the same as the interpreter.
09:38:08 <ibid> Chronosphear: i don't know of any haskell interpreter that lets you remove the let
09:38:10 <Chronosphear> oh...
09:38:35 <ibid> Chronosphear: but most code examples are not intended for direct input to the interpreter :)
09:38:35 <Chronosphear> i'm probably meant to be putting this in a file so that explains it
09:38:40 <ibid> yes
09:39:24 <byorgey> introductory books should really be a lot clearer about that.
09:39:49 <byorgey> seems like lots of people get tripped up by typing code intended for a file into the interpreter.
09:40:04 <byorgey> bos, dons, CosmicRay, you reading this? ;)
09:40:19 <quicksilver> yaht is very good but has weaknesses
09:40:26 <quicksilver> along these lines, especially at the beginning
09:40:52 <ibid> my teacher used to say, nothing flawless is human-made
09:42:39 <quicksilver> except for johnny depp
09:43:05 <ibid> but that's alien-made, everybody knows that
09:43:41 <byorgey> johnny depp!?
09:45:44 <desegnis> Has somebody tried to update hs-plugins to work today?
09:46:24 <bos> byorgey: qye?
09:46:29 <bos> oh, right. yes.
09:46:58 <gwern> desegnis: it doesn't compile for you?
09:47:22 <byorgey> bos: =)
09:47:38 <desegnis> gwern, no. hackage version (1.0). I updated the .cabal file, but some APIs must have changed
09:47:59 <gwern> oh. I am fairly sure the hackage version is too outdated
09:48:12 <desegnis> gwern, there is another version?
09:48:28 <gwern> desegnis: yeah. you want to run out of darcs
09:48:39 <desegnis> @where plugins
09:48:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:48:42 <gwern> esp. if you are using a not-ancient GHC, like 6.8.x
09:49:03 <desegnis> Now, that one isn't a darcs repo.
09:49:28 <gwern> desegnis: careful! that page is full of lies, esp. the download section
09:49:33 <quicksilver> lies!
09:49:59 <gwern> ie, it *says* that the darcs is at 'darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins'. but that's a damn dirty lie
09:50:22 <desegnis> Well, so what is the truth?
09:51:15 <gwern> you want the truth? you want the truth? you can't handle the truth!
09:51:25 <gwern> http://code.haskell.org/~dons/code/hs-plugins is just too much for you man
09:51:26 <lambdabot> Title: Index of /~dons/code/hs-plugins
09:51:37 <blarz> hehe
09:52:06 <desegnis> gwern, thanks anyways :)
09:53:19 <dolio> gwern: I'm looking at the cc-delcont patch. Is there a reason you renamed a bunch of variables from, for example, "a" to "b" and "l" to "m"?
09:53:25 <gwern> I keep telling dons to update his darcs links for the projects he's no longer hosting, but he never does. it'd be eaiser if the site itself were in darcs
09:53:42 * desegnis goes updating Cabal in consequence :)
09:54:09 <gwern> dolio: yeah. they were shadowing other variables
09:54:22 <gwern> http://www.cse.unsw.edu.au/~dons/_darcs/ <-- nooo, 'access forbidden'.
09:54:37 <dolio> gwern: Ah, okay. I see now.
09:55:04 <gwern> so it exists, but I can't get at it. fooey
09:55:42 <gwern> dolio: I could've done it mechanically, but I was trying to keep the sets of variables somewhat related and sensible
09:59:27 <WhuutdupNumba2> what is the haskell?
09:59:44 * BMeph thinks dons' unsw site has lies, and damn lies, but not statistics
09:59:58 <WhuutdupNumba2> an SDT perhaps
10:00:10 <kpreid> WhuutdupNumba2: http://www.haskell.org/
10:01:06 <Chronosphear> he meant STD right?
10:01:17 <gwern> the haskell is a lie!
10:01:43 <desegnis> hm... cabal from doesn't go well with plugins from darcs either :(
10:01:56 <ndm> dons: what do you use Text.XML.Light for in hackage2hwn?
10:02:14 <ndm> dons: i've just uploaded tagsoup 0.4, and will have broken your code, but was attempting to fix it for you
10:02:39 <gwern> no, not really. you're really best off avoiding runing cabal from darcs
10:02:43 <dons> ndm, oh that's an unreleased lib. its a lightweight xml parser
10:02:57 <ndm> dons: why do you need an XML parser, and tagsoup?
10:03:05 <ndm> given tagsoup is an XML parser...
10:03:10 <pranith> http://bitwise.iitkgp.ernet.in/ - an online programming contest with huge prize money, registration has started, this is for information purpose only, not spammingl sorry if its otherwise
10:03:22 <dons> ndm, so i parse the rss feed as xml, then use tagsoup for some unstructured html
10:03:41 <ndm> dons: why not parse the rss with tagsoup?
10:03:52 <desegnis> gwern, so what should I use? cabal 1.2.0?
10:04:01 <dons> i didn't know it could do full xml, actually
10:04:13 <dons> do a get a proper document tree, or just lists of tags
10:04:21 <ndm> dons: there is a sample in the recently released one on hackage of it parsing RSS from sequence
10:04:25 <ndm> dons: just a list of tags
10:04:39 <ndm> dons: but rss only have 2 levels of structure anyway :)
10:04:46 <dons> ok. the xml lib should be released soon anyway.
10:05:00 <ndm> dons: just to warn you, i nearly certainly broken it with the new release
10:05:08 <gwern> desegnis: stick with stable. Cabal-1.2.3.0 works well for me though
10:05:39 <ndm> dons: actually, looking over it, doesn't look like i did...
10:06:12 <desegnis> 1.2.0 seems to be the only exisiting tag in the 1.2 line, so...
10:10:03 <desegnis> strangely enough, there is a 1.2.2.0 on my system anyways
10:11:24 <dons> ndm, do you want me to check (tagsoup 0.4 is on hackage now?)
10:11:39 <ndm> dons: you can if you want, should be trivial to fix
10:11:39 <dons> ndm, btw, you've another tagsoup user,
10:11:40 <dons> "http://cmars232.blogspot.com/2008/01/seeqsuq-seeqpod-url-ripper-in-haskell.html"
10:11:43 <dons> "Seeqsuq: A Seeqpod URL Ripper (in Haskell)"
10:12:02 <dons> does tagsoup come with any tests?
10:12:13 <dons> i'm keen to get more test coverage/quality assurance results on hackage.
10:12:38 <dons> you can do this by linking to hpc coverage results from the synopsis, like this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light-0.2.1
10:13:09 <ndm> dons: it does, and i've just been adding some to test more as reported by hpc
10:13:36 <gwern> ndm: I just 'cabal install tagsoup-0.4' successfully. good work
10:13:39 <dons> ndm, awesome. it would be good if you could also then link to the hpc coverage data -- until we get hackage hosting thosse logs automatically
10:13:55 <dons> let me know if you need any help getting hpc sorted
10:14:03 <ndm> dons: its not set up automatically, but i will figure it out - i'm still not sure how to do stuff like get otherwise not to be flagged
10:14:30 <dons> you can filter out things that don't make sense to be tested
10:14:38 <dons> though its usually easier to write a test for them, i've noticed
10:14:42 <ndm> i've not really seen how, sounds like a handy blog post
10:14:46 <ndm> how do you filter out otherwise?
10:15:04 <dons> oh, i don't think you can. we should complain to andyjgill_ that otherwise is a bit annoying
10:15:27 <ndm> i also have lots of other bits
10:15:31 <gwern> ndm: where do you keep the tagsoup tests? I'm not seeing them in my repo
10:15:36 <ndm> i was doing filepath with hpc yesterday, was handy
10:15:40 <gwern> regress?
10:15:41 <ndm> gwern: Example.Regress
10:15:57 <ndm> gwern: if you build with cabal, then run tagsoup regress
10:16:24 <andyjgill_> Filtering in hpc: you can omit modules, or packages, but not specific functions
10:16:34 <gwern> ah, so that's what 'Run the regression tests' means
10:16:41 * gwern has learned a new word
10:16:48 * BMeph wonders if oyster crackers or cornbread goes best with tagsoup
10:17:02 <opqdonut> 2
10:17:03 <dolio> Ritz.
10:17:04 <opqdonut> woops
10:17:07 <gwern> ndm: why don't you have the test be 'runhaskell Main.hs regress'?
10:17:11 <dolio> Everything tastes better with Ritz.
10:17:19 <andyjgill_> You *can* merge two runs from different binaries that share a module.
10:17:28 <andyjgill_> So unit and system tests can be combined.
10:17:38 <ndm> andyjgill_: filepath has half windows only and half posix only, which means i can't combine runs, and can't get high coverage
10:17:51 <dons> ndm, are they in different modules?
10:17:57 <dons> you can filter out modules --exclude=Foo
10:18:14 <dons> or, you can merge a testrun on windows, with a test run on unix (i think)
10:18:18 <ndm> dons: same source, kind of
10:18:26 <ndm> dons: the way its done is with CPP, so i can't
10:18:33 <dons> andyjgill_: btw, 'otherwise' taking away from the final coverage data is pressure not to use 'otherwise', i've noticed :)
10:19:40 <andyjgill_> I don't see why not, dons. Never tried it, though
10:19:40 <dons> andyjgill_: is there a way to disable that, say, --disable=otherwise or something
10:19:40 <andyjgill_> You can use the DSL to omit coverage over otherwise.
10:19:40 <dons> ah right. too hard :)
10:19:40 <andyjgill_> (I'll need to re-read the paper to remember)
10:19:56 <dons> i see someone on -cafe@ is asking for a 'coverage' target for cabal
10:20:02 <andyjgill_> Good feedback, though. I ignore the conditional marks until I've got the yellow marks
10:20:34 <dons> so i actually rewrote a | x == y -> e ; | otherwise = e2 to an if-then-else, to fix up the coverage rresults
10:20:44 <dcoutts> dons: yeah, we should think about how to integrate it with cabal
10:20:55 <dcoutts> dons: why is 'otherwise' a problem?
10:21:28 <ndm> dcoutts: always comes up green, only ever evaluates to True
10:21:56 <dcoutts> ndm: is that a problem?
10:21:56 <andyjgill_> And is often used in a syntactical boolean context
10:22:36 <kpreid> ndm: sounds like the coverage tool ought to know about otherwise
10:22:56 <andyjgill_> The boolean coverage is secondary information, though arguing to emit otherwise is certainly possible.
10:23:06 <ndm> dcoutts: foo | otherwise = ... , otherwise comes up as non-complete coverage
10:23:09 <andyjgill_> ndm: the rule was "no exceptions!"
10:23:17 <dons> dcoutts: yeah, it takes away from complete coverage
10:23:18 <dons> 100% expressions used (190/190)
10:23:18 <dons>  80% boolean coverage (4/5)
10:23:18 <dons>       66% guards (2/3), 1 always True
10:23:18 <andyjgill_> () also gives problems.
10:23:35 <ndm> andyjgill_: otherwise is close enough to being a keyword that being an exception isn't the end of the world
10:23:38 <dons> due to one 'otherwise' . similar for sizeOf (undefined :: X) or ()
10:23:52 <dcoutts> dons: I see
10:23:53 <andyjgill_> Because we often use return (), when we mean return (uninteresting)
10:23:54 <ndm> my friend Mike programed Haskell for 3 years before finding out otherwise wasn't a keyword
10:24:06 <andyjgill_> It is a bit of a hack.
10:24:31 <dons> dcoutts: so the issue with cabal support is that it depends on how you run your tests.
10:24:38 <andyjgill_> Ok, due to popular demand, I'll add a --ignore-otherwise flag.
10:24:51 <dcoutts> dons: exactly, it's all bound up with cabal's poor testsuite support
10:25:24 <ndm> andyjgill_: --ignore otherwise --ignore () - just for ignoring completely matching strings?
10:25:26 <dcoutts> dons: we should aim for a state where most good packages on hackage have testuites that are automatically run and reported with coverage on hackage
10:25:42 <dons> andyjgill_: well, there's a few little things like this (sizeOf (undefined :: X) is another. maybe --ignore-sym ?
10:25:43 <dcoutts> dons: so just running an IO () is no good, we don't get any information back
10:25:46 <dons> right.
10:26:11 <dcoutts> dons: we need some interface for returning structured results from test code, ie from hunit/qc drivers
10:26:23 <dcoutts> dons: and usually tests need to link against the installed lib
10:26:39 <desegnis> Where do I get a packAddress for ByteString so that lambdabot will compile?
10:26:52 <dcoutts> desegnis: Data.ByteString.Internal
10:26:52 <dons> desegnis: use lambdabot darcs with ghc 6.6.1
10:26:59 <dons> its not updated to ghc 6.8.x yet
10:27:58 <dcoutts> dons: so we need to establish some standard interface for tests, like we have for building with cabal
10:28:15 <desegnis> dons, would it be more or less straightforward to port it to 6.8?
10:28:28 <dons> desegnis: not really , there's some attempts to do it (Cale's got it working)
10:28:32 <dons> using the code.haskell.org branch
10:28:41 <dons> dcoutts: hmm
10:28:44 <dcoutts> dons: then bend the existing ad-hoc testsuites for libs into that form, support from the QC + HUnit drivers to use that interface will probably also be needed
10:28:52 <gwern> @pl  sections (~== ("<a>")) tags
10:29:07 <dons> dcoutts: right. so we'd need a common interface. but then it would be fairly smooth.
10:29:08 <desegnis> dons, yeah, that's what I have
10:29:25 <dcoutts> dons: seems like it'd have to be a textual format, since we have to compile the code with coverage and link it against the lib in question
10:29:40 <desegnis> dcoutts, I guess .Internal is not valid for ghc 6.8 anymore or something like that?
10:29:52 <desegnis> I mean, it doesn't contain packAddress here
10:30:02 <dons> dcoutts: yeah, so perhaps a list of excutable targets that dump some Read/Show format
10:30:02 <dcoutts> desegnis: no, it's only valid for ghc-6.8 and later
10:30:17 <dcoutts> dons: and we'd like to support perf tests too, benchmarks
10:30:20 <dons> though for coverage we don't actually need the results, just what programs to run
10:30:44 <dcoutts> dons: yes, but we'd like to show both on hackage, it's no good getting 99% coverage if all the tests fail :-)
10:30:54 <dons> right
10:31:30 <desegnis> dcoutts, strange, it's not there for me in ghc 6.8.1
10:31:41 <dcoutts> desegnis: it's in the bytestring package
10:31:56 <desegnis> dcoutts, the module is there, but there is no function packAddress
10:32:18 <dcoutts> desegnis: oh, sorry it was renamed I think, lemme see...
10:32:32 <dons> ndm, i note you've chosen Text.HTML instead of Text.Html (like xhtml/html packages use)
10:32:43 <dcoutts> desegnis: however like dons said, if you just want it to work then use the darcs version of lambdabot with ghc-6.6
10:33:34 <dcoutts> desegnis: it's unsafePackAddress from Data.ByteString.Unsafe
10:33:35 <byorgey> @botsnack
10:33:47 <dcoutts> desegnis: though you might prefer to use something a tad safer :-)
10:33:58 <davidL> where's lambdabot? :(
10:34:00 <desegnis> yea, but I'd suppose it to be more aesthetic if I work on lambdabot on ghc 6.8.2
10:34:17 <byorgey> taking a lambdanap, apparently
10:34:23 <desegnis> dcoutts, then I must adjust the code, I suppose? it has got a different type
10:34:45 <dcoutts> desegnis: what was packAddress being used for?
10:34:54 <desegnis> let me see
10:35:05 <prb> I'm having some odd issues with seg faults when writing a file with a very simple function.
10:35:14 <hpaste>  prb pasted "causing seg fault?" at http://hpaste.org/4992
10:35:39 <prb> I added the ghetto debug print around the write.
10:35:48 <dcoutts> prb: what is the B module?
10:35:58 <prb> Data structure.
10:36:03 <dons> ah, hpc draft.
10:36:14 <prb> To string just ++'s together a bunch of string fields.
10:36:17 * gwern accidentally discovers a darcs repo for cabal-test. d'oh! why don't people *mention* the darcs repos in the cabal files?
10:36:18 <dcoutts> prb: then look there for the bug, those other functions are totally standard and segfault-free
10:36:43 <dcoutts> prb: unless your whole ghc setup is borked in which case anything could cause a segfault :-)
10:36:51 <prb> dcoutts: Bonus difficulty -- segfault is sporadic.
10:36:57 <prb> dcoutts: :)
10:37:08 <dcoutts> prb: generally you cannot get segfaults except with incorrect FFI code or using some very low level libs
10:37:15 <davidL> Is the happs open proxy working?
10:37:19 <dcoutts> prb: so does that B module use FFI?
10:37:31 <prb> dcoutts: This is writing form field values from a FastCGI form submission.
10:37:48 <prb> dcoutts: Perhaps laziness is hanging onto a pointer to some out of scope data?
10:37:49 <alexj_> davidL I turned off the openPRoxy.  it is now a limited proxy functionality because of the security issues.
10:37:57 <alexj_> davidL: why do you ask?
10:38:04 <desegnis> dcoutts, I may be being fooled by changed types. Is unsafePackAddress supposed to take an Int as a parameter? lambdabot uses unsafePackAddress with an additional Int, while it uses packAddress without such an Int
10:38:20 <dcoutts> prb: could be, but that'd still be a bug in the FFI code in the B module
10:38:42 <prb> dcoutts: B has no FFI.
10:38:47 <dcoutts> desegnis: perhaps it's fromForeignPtr you want? what is the type of the old code?
10:39:17 <davidL> alexj_: I thought it was useful, is it now only limited to *.haskell.org?
10:39:22 <prb> dcoutts: But the fields in the data structure in B could have pointers to data extracted from a FastCGI request.
10:39:41 <prb> dcoutts: I'll go and play around.  Maybe a little strictness while still in the CGI monad is the solution.
10:39:47 <alexj_> davidL: http://happs.org/repos/happs.org/src/Main.hs
10:39:47 <dcoutts> prb: how do you get the data out of the FactCGI?
10:39:50 <desegnis> dcoutts, docAssocs = M.fromList [(packAddress "Control.Arrow"#, base), ......]     vs.        base = P.unsafePackAddress 4 "base"#
10:39:52 <dons> ndm, hackage2hwn, updated, and 100% covered, http://code.haskell.org/~dons/tests/hackage2hwn/hpc_index.html :)
10:40:22 <alexj_> davidL: if you want a full open proxy, you can certainly change the parameters to allow it.
10:40:36 <desegnis> dcoutts, maybe I should consider to abandon the Ints (4 in the example)?
10:40:36 <hpaste>  prb pasted "like so" at http://hpaste.org/4993
10:40:37 <dcoutts> prb: strictness is probably not the problem, the problem is probably C memory management, if the FastCGI data is only valid for a short time then you might need to copy it first
10:41:20 <davidL> alexj_: also why is "Directory index forbidden" on http://happs.org/repos/happs.org
10:41:27 <dcoutts> desegnis: unsafePackAddress :: Addr# -> IO ByteString
10:42:05 * desegnis is sorry to state that I am off for dinner now
10:42:25 <prb> dcoutts: Could be it.  I'll look over the fastcgi module code to see how it handles these things.  (Might be in CGI code as well, but that makes some sense, since the CGI code wouldn't need to bother with longer-lived data.)
10:42:39 <alexj_> davidL because I never wrote the directoryindex code.
10:42:58 <dcoutts> prb: check the fastcgi C docs to see what the lifetime management of the strings are
10:43:03 <dons> ndm, btw, you can do: hpc draft
10:43:11 <alexj_> why do you want directory indexing?
10:43:16 <dons> to print a little overlay of things to exclude to get 100% coverage
10:43:26 <dons> then convert that to a .tix file, and print the combined coverage results
10:43:34 <dons> so that lets you filter out some things
10:43:40 <alexj_> prb: can I ask why you are using fastcgi?
10:44:00 <prb> alexj_: Because CGI would be too slow...
10:44:07 <alexj_> why not happs?
10:44:26 <prb> alexj_: Mostly taste; happs is a bit too heavy and frameworky for me.
10:44:36 <alexj_> prb: ok then how can we lighten the load.
10:44:44 <alexj_> you can use happs-server standalone.
10:44:51 <alexj_> and it is pretty lightweight I htink.
10:44:54 <prb> alexj_: I do follow with interest and hope to help out.
10:45:23 <alexj_> prb: cool.  have you tried the getting started example?
10:45:24 <prb> alexj_: I try to follow a "no criticism without contribution" credo for open source...
10:45:33 <prb> alexj_: Not yet.
10:45:45 <geezusfreeek> my biggest fear with happs (and i hear it is being worked on or has been solved?) is migration between different versions of an app
10:46:10 <prb> alexj_: So far, my little example fastcgi app is <2k LOC, so small.  It's also an experiment to learn about the moving pieces.
10:46:11 <alexj_> prb: try it.  I think you will have a working happs web server in 5 minutes.
10:46:16 <geezusfreeek> and also api instability in general
10:46:26 <prb> alexj_: Cool.
10:46:42 <davidL> alexj_: directory indexing is useful when darcs isn't available, it's not really a big deal
10:46:45 <alexj_> geezusfreek: the api is stabiliizing in a big way.  we have one more change to happs-state and then I will decalre a release.
10:47:10 <geezusfreeek> alexj_: and migrations?
10:47:16 <kaiser> hello everyone.  :)
10:47:35 <dcoutts> alexj_: make sure the release is easy to install via cabal-install :-)
10:47:55 <kaiser> Cale: you here?  :)
10:48:10 <alexj_> geezusfreek: I think we have a better migration story than anything else because the migrations are typesafe.
10:48:34 <geezusfreeek> okay, then as soon as there is a declared release, you can count on me trying it out :)
10:48:35 <alexj_> sorry do you mean different versions of your app of different versions of happs?
10:48:43 <alexj_> geezusfreeek.  ok cool!
10:48:44 <geezusfreeek> alexj_: either
10:48:58 <gwern> so the hackage packages will be updated and working? that's good
10:48:59 <alexj_> ok well I think both will be nicely solved in the next release.
10:49:17 <geezusfreeek> good good good, that was really the only thing i was apprehensive about
10:50:17 <Associat0r> #F# needs people
10:50:34 <dcoutts> alexj_: the last release on hackage is really old looking, HAppS-0.8.4
10:50:42 <kaiser> Associat0r: #F# needs people for what?
10:50:57 <byorgey> hi kaiser
10:50:59 <alexj_> dcoutts:  yeah I know.  when we do the release I will push a bunch of packages to hackage.
10:51:15 <alexj_> we probably should have pushed 0.9.1 to hackage, but that never hapenned.
10:51:27 <kaiser> Hello, I am trying to step through the code for a simple foldr implementation, but I seem to be doing something incorrect in my steps although the code does work, can someone tell me what I've done wrong?  Here is a paste of the code and my steps: http://rafb.net/p/48lWZy20.html
10:51:31 <kaiser> hey byorgey
10:51:46 <dcoutts> alexj_: great, for distros we really need tarballs, darcs urls are no good for distro packages
10:52:00 <alexj_> dcoutts: ok.
10:52:23 <kaol> I'm going to package happs for Debian, once the dependencies get packaged
10:52:25 <gwern> dcoutts: we also need darcs urls in the cabal files, dont forget! so people know where to go for the dev version
10:52:33 <alexj_> dcoutts: once we do the release I'd like to work with you on whats needed for the next round of hacake.
10:52:33 <kaol> for those who care of that
10:52:38 <dcoutts> alexj_: btw, where are the latest tarball releases? I can't find them on happs.org our gentoo packages for happs are pretty old
10:52:53 <dcoutts> alexj_: ok, sure, I'm always happy to brainstorm
10:52:54 <alexj_> dcoutts: there aren't really any tarball releases right now.
10:52:57 <byorgey> kaiser: what's wrong with your steps?  looks pretty good to me
10:53:04 <dcoutts> alexj_: ok
10:53:17 <byorgey> kaiser: you probably want more parentheses around (+) 2 (foldr... though
10:53:43 <byorgey> > (+) 1 (+) 2 0   -- this gives four arguments to the first (+)
10:53:53 <byorgey> oh, lambdabot is napping =(
10:54:04 <dons> ?bot
10:54:10 <dcoutts> gwern: yes, we're just waiting for you to come up with the spec :-)
10:54:44 <gwern> dcoutts: shucks, just put them in as home-page or mention them in the description
10:54:45 <byorgey> @bot
10:54:51 <gwern> doesn't really matter so long as they're there somewhere
10:54:52 <lambdabot> :)
10:54:56 <byorgey> hooray!
10:55:01 <byorgey> as I was saying
10:55:04 <byorgey> > (+) 1 (+) 2 0   -- this gives four arguments to the first (+)
10:55:10 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
10:55:16 <lambdabot>     In the expression: ...
10:55:29 <byorgey> > (+) 1 ((+) 2 0)  -- better!
10:55:36 <lambdabot>  3
10:55:37 <kaiser> byorgey: odd, haskell can evaluate (+) 1 (+) 2 0 ??
10:55:43 <kaiser> lol
10:55:43 <dcoutts> gwern: but we want them on the hackage web pages for each package, so it has to be in a structured format
10:55:59 <kaiser> byorgey: crazy!
10:56:02 <byorgey> kaiser: well, it gives an error, that was the point =)
10:56:12 <Jaak> > (+) 1 $ (+) 2 0
10:56:16 <byorgey> kaiser: it's perfectly valid syntax, though.
10:56:18 <lambdabot>  3
10:56:27 <kaiser> Jaak: what is the $ ?
10:56:35 <Jaak> bling
10:56:39 <kaiser> byorgey: very interesting.
10:56:39 <byorgey> hehe
10:56:42 <thetallguy> ?seen igloo
10:56:43 <lambdabot> igloo is in #haskell, #ghc and #darcs. I don't know when igloo last spoke.
10:56:45 <byorgey> kaiser: f $ x = f x
10:56:53 <kaiser> ahh
10:56:59 <kaiser> why the $ then?
10:56:59 <byorgey> kaiser: it's just function application, but with a low precedence so it helps you avoid parens sometimes.
10:57:08 <kaiser> byorgey: ahh, thanks
10:57:08 <thetallguy> dang bot ain't worth it's weight in bits
10:57:33 <gwern> dcoutts: we do?
10:58:01 <idnar> so how much does the bot weigh, anyhow?
10:58:15 <dcoutts> gwern: sure, we want the info to be readily accessible, not buried within a README within a .tar.gz that you've not downloaded
10:58:28 <kaiser> byorgey: that is so crazy... (+) 1 ((+) 2 (0))  --- actually providing arguments to (+) like a function, haha
10:58:41 <byorgey> kaiser: well, (+) IS a function =)
10:58:43 <kaiser> and doing (+) recursively
10:58:43 <kaiser> lol
10:58:52 <kaiser> byorgey: yeah, just never really think of (+) as a function!
10:58:55 <kaiser> but as an "operator"
10:59:04 <Valodim_> (which is a function)
10:59:12 <byorgey> kaiser: right.  In haskell, there's no difference, except for prefix vs. infix.
10:59:15 <Deewiant> everything is a function!
10:59:17 <kaiser> byorgey: (+) might make my brain explode ;)
10:59:17 <gwern> dcoutts: the grep is my shepherd, I shall not fear, yea though I walk through the directories of death...
10:59:17 <kaiser> hehe
10:59:28 <dcoutts> gwern: :-)
10:59:36 <byorgey> kaiser: you can surround any infix operator by parens to make it into a prefix function.
10:59:53 <kaiser> byorgey: ahh, thanks for the clarification.  :)
10:59:54 <byorgey> > 6 * 3 == (*) 6 3
10:59:56 <lambdabot>  True
11:00:01 <kaiser> nice
11:00:02 <idnar> > let plus x y = x + y in 5 `plus` 10
11:00:03 <lambdabot>  15
11:00:10 <idnar> and you can go the other way too :)
11:00:11 <kaiser> idnar: lol
11:00:14 <Deewiant> > let 1 + 1 = 3 in 1 + 1
11:00:14 <lambdabot>  3
11:00:30 <Valodim_> yeah how does that one work
11:00:32 <idnar> > let x `plus` y = x + y in 5 `plus` 10 -- you can define it in infix style, too
11:00:33 <byorgey> now, let's not confuse poor kaiser ;)
11:00:33 <lambdabot>  15
11:00:34 <Valodim_> does it overload the + operator?
11:00:43 <kaiser> byorgey: they want my head to explode  :P
11:00:44 <byorgey> Valodim_: it defines a new + operator.
11:00:53 <opqdonut> that shadows the old one
11:00:53 <glguy> Valodim: it shadows it
11:01:05 <byorgey> kaiser: you'll get used to it. ;)
11:01:21 <Valodim> > let 1 + 1 = 3 in 1 + 2
11:01:22 <lambdabot>   Non-exhaustive patterns in function +
11:01:24 <kaiser> byorgey: to help me learn haskell better, I've been working re-implementing some of the fundamental list functions to better understand Haskell.
11:01:24 <Valodim> ah
11:01:27 <Valodim> ok got it :)
11:01:28 <opqdonut> :)
11:01:32 <byorgey> kaiser: that's an excellent idea
11:01:35 <kaiser> :)
11:01:46 <Sizur> @users
11:01:46 <lambdabot> Maximum users seen in #haskell: 437, currently: 436 (99.8%), active: 16 (3.7%)
11:01:54 <kaiser> Cale showed me last night that foldr is crazy in the Haskell GHC source ;)
11:01:57 <kaiser> ?src foldr
11:01:57 <lambdabot> foldr k z xs = go xs
11:01:57 <lambdabot>     where go []     = z
11:01:57 <lambdabot>           go (y:ys) = y `k` go ys
11:02:09 <kaiser> it seems some optimizations are done for that foldr?
11:02:12 <byorgey> kaiser: indeed.  not very helpful for understanding it. =)
11:02:17 <kaiser> byorgey: quite true
11:02:27 <byorgey> kaiser: yes, something to do with allowing the compiler to inline it
11:02:33 <byorgey> I'm not clear on it myself
11:02:47 <kaiser> what is the `k` ??
11:02:55 <Deewiant> infix function application
11:03:03 <Deewiant> see `plus`, above
11:03:06 <byorgey> kaiser: like idnar showed above.
11:03:07 <kaiser> ah yes
11:03:19 <kaiser> I didn't see k as an argument to the function...
11:03:23 <kaiser> ;)
11:03:34 <byorgey> ah, right.  that is the folding function.
11:03:52 <Sizur> who knows why it's 'k'. i always assume k to be a constant, and f a function
11:03:54 <kaiser> thanks for the help byorgey, idnar, and everyone else.
11:04:03 <byorgey> kaiser: sure, anytime =)
11:04:03 <kaiser> Sizur: yah, k is confusing
11:04:06 <kaiser> :)
11:04:21 <kaiser> well, back to learning
11:04:26 <kaiser> I'll bother you guys later, I'm sure!  :)
11:04:34 <kaiser> cya
11:04:41 <byorgey> Sizur: sometimes you also see k used for functions of type (a -> m b), k for 'Kleisli'
11:04:44 <dcoutts> kaiser, byorgey: yes it's written in that way because ghc does not inline recursive functions
11:04:46 <byorgey> Sizur: but yes, it seems odd here
11:05:13 <Sizur> ok, Kleisli arrows are understandable
11:05:14 <dcoutts> that optimisation is actually vital for foldr to get decent performance, foldl(') too
11:05:14 <thetallguy> anyone know of a debian package for cabal > 1.1.3?
11:05:28 <thetallguy> source package, that is.
11:05:34 <byorgey> dcoutts: ah, got it.  but won't it just have the same problem with 'go' then?
11:06:13 <Sizur> go is tail recursive
11:06:17 <dcoutts> byorgey: sure, the go cannot be inlined itself, but it's a local definition to the foldr which is inlined
11:06:17 <Sizur> good for inlining
11:06:30 <byorgey> dcoutts: oh, ok, I see now.
11:06:39 <dcoutts> Sizur: no, it's not tail recursive and it cannot be inlined
11:06:43 <Sizur> dcoutts: any local definition is inlined?
11:07:28 <Sizur> oh, duh... `k` is the last thing
11:07:33 <dcoutts> byorgey: the point is we end up with a copy of the recursive go at the call site, and then in that call site we can specialise for the k and z parameters
11:07:59 <dcoutts> Sizur: if the parent definition is inlined and the local definition did not get floated out first, then yes.
11:09:00 <dcoutts> Sizur: distinguish between getting a copy of the local definition at the call site due to inlining the parent function, and inlining of the local definition
11:09:05 <kaiser> dcoutts: is that generally a good optimization to do something similar to go in foldr?
11:09:20 <kaiser> does that help the compiler?
11:09:26 <dcoutts> kaiser: it depends
11:09:58 <dcoutts> kaiser: for foldr it's important because it lifts the k and z parameters out of being args to a recursive function that cannot be inlined
11:10:28 <Deewiant> @src foldl
11:10:29 <lambdabot> foldl f z xs = lgo z xs
11:10:29 <lambdabot>     where lgo z []     =  z
11:10:29 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
11:10:33 <kaiser> dcoutts: interesting.
11:11:12 <Deewiant> now why is the z passed to lgo here, but not to go in foldr
11:11:14 <kaiser> thanks dcoutts
11:11:15 <kaiser> cya
11:11:17 <Lemmih> @seen gwern
11:11:18 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 12m ago.
11:11:37 <hpaste>  prb pasted "lots of deps" at http://hpaste.org/4994
11:11:46 <dcoutts> Deewiant: because foldl uses an accumulating parameter
11:12:11 <Deewiant> duh, the z changes
11:12:17 <Deewiant> cheers
11:13:33 <Lemmih> gwern: You've sent me some darcs patches. What repo are they fore?
11:14:19 <dons> Lemmih: check the mail header
11:14:28 <dons> it has a X-darcs-repo: field
11:14:45 <dons> e.g.
11:14:45 <dons> X-Darcs-Version: 1.1.0pre1 (unknown)
11:14:47 <dons> DarcsURL: http://code.haskell.org/~dons/code/mkcabal
11:14:48 <lambdabot> Title: Index of /~dons/code/mkcabal
11:15:04 <Lemmih> Aha.
11:16:15 <glguy> dons: where you be?
11:17:45 <dons> glguy: sitting in bed coughing :)
11:18:14 <gwern> Lemmih: cabal-test
11:18:37 <dancor> http://hackage.haskell.org/packages/archive/hsql-postgresql/1.7/log
11:18:40 <lambdabot> http://tinyurl.com/27tq7s
11:18:57 <sethk> dons, I've got an awful cold, but I don't think IRC transfers colds so I'm not guilty.  :)
11:19:08 <dons> that's my working theory too
11:19:14 <dcoutts> dancor: if you need hsql, gentoo has patches to make it work with ghc-6.8
11:19:28 <dcoutts> dancor: hsql is otherwise bitrotted
11:19:30 <Adis> has anyone ever tried using yacc to generate a haskell syntax parser?
11:19:44 <ibid> ghc used to use one
11:19:56 <ibid> way back when
11:19:58 <dcoutts> Adis: no, but ghc uses happy for it's haskell parser and happy is pretty similar to yacc
11:20:17 <Adis> does anyone perchance have an input grammar for happy?
11:20:40 <ibid> look in the ghc source?
11:20:53 <dcoutts> Adis: it's in the ghc source tree, or if you're just looking for a reusable haskell parser then use Language.Haskell
11:21:04 <ibid> i believe it doesn't try to resolve precedences in the grammar, though
11:21:29 <Adis> Actually, I have to generate a Haskell syntax parser with yacc for a project on campus
11:21:35 <ibid> (there's an old paper by SPJ and some other, i think, about how to handle them in yacc, though)
11:21:43 <dancor> what db lib is considered kwlest these days
11:21:55 <dancor> that supports postgres
11:22:00 <dcoutts> dancor: I'd suggest hdbc
11:36:41 <dancor> why do you have to actually catch exceptions to get them fully displayed
11:36:56 <dons> or let them exit the program
11:38:08 <dancor> just getting 'Database.HDBC.SqlError' if you don't know what you are doing is no good
11:38:46 <dancor> haskell usage would double after making print err default handler
11:39:08 <dancor> mark my arbitrary statistic
11:39:35 <rmdashrf> I'm having a dreadful time getting an environment up for writing a gtk2hs app.  Can I beg some help?
11:39:51 <dcoutts> rmdashrf: sure
11:39:58 <rmdashrf> I'm on debian 3.1, but I've been hand-installing various components.
11:40:11 <rmdashrf> I'm not sure which versions are needed to work together.  I'm using ghc 6.8.2, ...
11:40:26 <rmdashrf> and I've been playing with different versions of cairo, pango, glib, gtk+
11:40:28 <wolverian> 3.1?! wow.
11:40:44 <dcoutts> rmdashrf: ok, so you're using the gtk2hs-0.9.12.1 tarball
11:40:45 <rmdashrf> If 3.1 is part of hte problem, I can go fix that and come back...
11:40:52 <andyjgill_> dons, neil: I've got a simple example of how to trivially use hpc overlay to remove the otherwise graffiti.
11:40:53 <rmdashrf> dcoutts:  right
11:41:05 <dcoutts> rmdashrf: it should work with new ghc and old gtk+ just fine, so what is the symptom?
11:41:26 <dcoutts> rmdashrf: configure failure or compile failure?
11:41:31 <andyjgill_> I'll blog about it tonight.
11:41:38 <rmdashrf> a few different things, which I'll try to summarize.  I haven't been taking great notes, due to optimism.
11:41:59 <rmdashrf> I've had gtk+ package fail to install b/c glib test program didn't run.
11:42:23 <rmdashrf> At one point about a week ago I got gtk2hs to install but failed at runtime to due a symbol missing from gtk+ lib
11:42:52 <dcoutts> rmdashrf: hmm, that's odd, do you have more than one version of gtk installed perhaps?
11:42:56 <rmdashrf> Just now (brand-new) pango complained about my old glib version (2.8), and that's where I stopped before trying all possible combos.
11:43:25 <dcoutts> rmdashrf: why are you installing new gtk etc? what's wrong with the versions that come with debian 3.1 ?
11:43:29 <rmdashrf> It's possible that I had one come in from 3.1, and installed one by hand.  I'm not sure how to make sure it's cleaned up, but I think I forced the deb package to go away.
11:43:59 <dcoutts> rmdashrf: gtk2hs will work with all versions of gtk+ back to 2.0 so there's no need to upgrade those
11:44:00 <rmdashrf> I was using the debian one when I had the runtime problem with symbol not found.  Thought hand-installing might help.
11:44:38 <dcoutts> rmdashrf: what is the system version of gtk+ ?
11:44:58 <shardz> r3m0t: ;D
11:45:09 <r3m0t> oh hai
11:45:10 <rmdashrf> Not sure... I nuked it along the way.  Something not-brand-new but not very old, IIRC.
11:45:14 <dcoutts> rmdashrf: if I were you I'd remove the ones you hand installed, go back to the reliable system one
11:45:21 <r3m0t> > map (+3) [2,4,5,3,2]
11:45:23 <lambdabot>  [5,7,8,6,5]
11:45:28 <shardz> Excellent!
11:45:36 <shardz> > 1:[]
11:45:36 <lambdabot>  [1]
11:45:38 <shardz> cool.
11:45:48 <r3m0t> it doesn't compare to running it on your own computer
11:45:49 <Bzek> > 1:1
11:45:49 <lambdabot>   add an instance declaration for (Num [t])
11:45:51 <r3m0t> still good though.
11:45:52 <dcoutts> rmdashrf: and make sure you've only got the one installed so there's no possability of building against one version and running using another
11:45:53 <Bzek> ;)
11:45:54 <shardz> Back to my research paper.
11:46:14 <rmdashrf> I'll give that a go again.  Thanks for the helpful words.
11:46:20 <dcoutts> rmdashrf: the main thing you need is the -dev versions of the gtk+ etc packages
11:46:51 <dcoutts> rmdashrf: because those -devel packages include the headers and pkg-config files
11:47:09 <dcoutts> rmdashrf: then pay attention to what ./configure says about which components it's going to build
11:47:25 <rmdashrf> dcoutts: right.  I'll come back with success or a more reliable failure state.
11:47:37 <dcoutts> rmdashrf: by default it does not try to build components that it thinks you don't have the system bits installed for
11:48:18 <rmdashrf> dcoutts:  before I go, which parts are necessary pieces of the etc.?  besides what will get loaded as dependencies, that is.
11:48:36 <dcoutts> rmdashrf: you can force it to look for those or fail saying what it cannot find by using ./configure --enable-$component for the various components
11:49:00 <kaiser> any good libraries for creating images of graphs?  (drawing lines)  HGL the best?
11:49:08 <dcoutts> rmdashrf: well only gtk and it's hard deps are essential but many other bits are nice like cairo, libglade
11:49:27 <dcoutts> kaiser: cairo is nice imho
11:49:49 <dcoutts> kaiser: nice api and high quality output
11:50:27 <kaiser> dcoutts: thanks, I'll check out cairo.
11:51:11 <dcoutts> kaiser: see for example http://dockerz.net/twd/HaskellCharts which uses cairo
11:51:11 <kaiser> dcoutts: -- Duncan Coutts (11 Jan 2006) -- do you work on the cairo project?
11:51:12 <lambdabot> Title: HaskellCharts - twd
11:51:37 <dcoutts> kaiser: xerox wrote the original bindings, I helped him a bit
11:51:43 <kaiser> dcoutts: cool.
11:51:55 <dons> andyjgill_: yeah, i think the draft/overlay stuff seems best for this
11:51:55 <kaiser> thanks to you both, xerox and dcoutts.
11:59:31 <andyjgill_> dons: I'm not against adding a flag, though for the common case
11:59:54 <dons> i worry that there are half a dozen common cases though :)
12:00:08 <dons> so maybe a flag taking a list of common symbols
12:00:21 <andyjgill_> Which is exactly why we had the "no exceptions" rule. This is all useful feedback
12:00:53 <dons> btw, i get another badge, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hackage2hwn-0.2.1  (also 100%)
12:00:55 <lambdabot> http://tinyurl.com/yuysy6
12:01:00 <dons> so that's 3. its like being at the boy scouts
12:01:23 <prb> dcoutts: Problem fixed by copying bytestrings before passing them out of the request handling thread.
12:01:23 <Sizur> Help!!! i'm tempted with Lisp!!!
12:01:39 <dons> prb: ok. so they were being deallocated?
12:01:45 <dons> Sizur: here, have a type check
12:01:51 <dcoutts> prb: that must be a bug in the FastCGI lib
12:01:55 <prb> dons: Apparently so.  unsafeInterleaveIO to get them out of the FastCGI bits.
12:02:16 <dons> hmm. sounds wrong
12:02:18 <prb> dcoutts: Could be considered to be -- yes and no.  Maybe you only want some of the data, so no need to copy it all.
12:02:20 <dons> that needs to be done strictly.
12:02:35 <prb> I can hpaste the relevant chunk of source.
12:02:35 <dons> any crash is a bug. better report it.
12:02:45 <prb> I'll email Bjorn and file a bug.
12:02:49 <gwern> you're like a magpie dons
12:02:56 <dcoutts> prb: if it allows you to lazily get the data it is it's responsibility to manage that safely
12:03:18 <prb> dcoutts: An interesting definition of paragon of laziness, but I like it.
12:03:44 <gwern> ooh cabal shiny! ooh quickcheck shiny! ooh hpc 100% shiny! (although I'm one to talk - ooh -Wall -Werror shiny!)
12:03:47 <gwern> Sizur: breath deeplu and think how you can do it through type hackery!
12:03:47 <gwern> *deeply
12:04:00 <Sizur> gwern: haha
12:04:19 <dcoutts> prb: the point is apis should not silently export unsafe stuff, you should never have to use workaround to avoid segfaults
12:04:24 <dons> ensuring code quality is shiny.
12:04:43 <prb> dcoutts: I agree.  It definitely made me scratch my head.
12:04:44 <gwern> actually, I've been wondering. what's unsafe about unsafePerformIO (excepting stuff like file locking)?
12:04:47 <gwern> er, unsafeInterleaveIO I meant
12:04:59 <andyjgill_> I'll add the --make-shiny option
12:05:01 * gwern knows how unsafePerformIO is unsafe :)
12:05:07 <prb> gwern: In this case, the source bits went away before laziness used 'em.
12:05:25 <dcoutts> dons: yes, so we should get that ghc-options QA checking included in hackage, should be easy and will improve quality
12:05:36 <prb> gwern: And no one was the wiser because an otherwise safe datastructure was passed to another thread that let the unsafe bits slip out of scope.
12:05:46 <gwern> prb: source bits?
12:06:01 <prb> gwern: The hunk of memory that was backing a ByteString in this case.
12:06:10 <prb> gwern: (A lazy bytestring.)
12:06:28 * gwern is confuzzled. wah?
12:06:46 <dcoutts> dons: this would be the easiest one to implement that'd help with hackage QA if you're still looking at the hackage code
12:06:47 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/191
12:06:49 <lambdabot> Title: #191 (Hackage should check for common QA problems in ghc-options) - Hackage - Tr ...
12:06:53 <dons> ok
12:07:10 <dcoutts> dons: and reject packages that do not specify a build-type
12:07:34 <prb> gwern: Web server gets a request; FastCGI passes it to Haskell; Haskell maps a ByteString over some of the struct handed over by FastCGI; bytestring gets put into a data structure; data structure goes to another thread; response goes back; data structure is lazily consumed; seg fault occurs because that memory is no longer owned by the process.
12:07:43 <dcoutts> dons: we should find a way to share that code between the Cabal lib and hackage so cabal-install can give those warnings too
12:08:07 <gwern> ok, lazy bytestrings use unsafeInterleave to delay actually writing to memory, I see, but then it'd work fine when another thread accessed it because it'd get forced by the other thread's operation? no?
12:08:11 <dcoutts> dons: I added a warning for a missing build-type to cabal HEAD the other day, but it's not in a nice form that hackage can use
12:08:41 <prb> gwern: The bytestring was created using unsafeInterleaveIO.  Once the request struct was out of scope, the bytes went away.
12:08:57 <prb> That other thread didn't pick it up right away.
12:09:07 <dons> yes, all evaluation was needed before the struct left scope
12:09:07 <dcoutts> gwern, prb: the point is that holding onto that bytestring chunk should have forced the C backing memory to stay alive but the binding was not written that way, which is a bug.
12:09:51 <dcoutts> if the binding cannot guarantee the lifetime of the memory then it needs to copy
12:09:59 <prb> gwern: I'm perf-testing a FastCGI Haskell app, so I'm purposefully slamming an input form.
12:10:22 <gwern> prb: but threads shared memory I thought, if they don't, they're processes. so how could the memory not be owned?
12:10:59 <prb> gwern: FFI.
12:11:17 <prb> gwern: And, as dcoutts is saying, a bug in the FFI in this case.
12:11:34 <matthew-_> dons: did you get that patch?
12:11:41 <dons> yep
12:11:55 <MisterZ> Hey Again everyone. I would like to ask that how shall I repair this code?
12:11:57 <pythonist> Problem with stack overflow...
12:12:06 <pythonist> Oh my... anyone willing to help?
12:12:14 <MisterZ> fstList :: [(a, b)] -> [a]
12:12:14 <MisterZ> fstList [] = []
12:12:14 <MisterZ> fstList (x:xs) = getFirst x : fstList xs
12:12:14 <MisterZ>   where
12:12:14 <MisterZ>     getFirst :: (a, b) -> a
12:12:15 <MisterZ>     getFirst (a, b) = a
12:12:23 <MisterZ> sndList :: [(a, b)] -> [b]
12:12:23 <MisterZ> sndList [] = []
12:12:23 <MisterZ> sndList (x:xs) = getSecond x : sndList xs
12:12:23 <MisterZ>   where
12:12:25 <MisterZ>     getSecond :: (a, b) -> b
12:12:27 <MisterZ>     getSecond (a, b) = b
12:12:32 <MisterZ> unZip :: [(a, b)] -> ([a], [b])
12:12:32 <MisterZ> unZip [] = ([], [])
12:12:33 <MisterZ> unZip (x:xs) = (fstList(x:xs), sndList(x:xs))
12:12:41 <Sizur> emacs or xemacs?
12:12:54 <MisterZ> Main> unZip []
12:12:54 <MisterZ> ERROR - Cannot find "show" function for:
12:12:54 <MisterZ> *** Expression : unZip []
12:12:54 <MisterZ> *** Of type    : ([a],[b])
12:13:00 <pythonist> MisterZ: why not use hpaste.org?
12:13:08 <matthew-_> dons: did you get a chance to look at your sha.h header - I'm starting to think yours is non-standard
12:13:24 <matthew-_> MisterZ: please use hpaste.org to paste code and avoid flooding here
12:13:25 <MisterZ> this is the error... I have no idea and will have an exam on Saturday
12:13:42 <MisterZ> pythonist, matthew-_ ure right, sorry
12:13:45 <dons> ?paste <--
12:13:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:13:46 * gwern acceptsthat maybe I don't understand enough of the internals to grasp the bug
12:14:11 <hpaste>  MisterZ pasted "(no title)" at http://hpaste.org/4997
12:15:13 <MisterZ> ERROR - Cannot find "show" function for:
12:15:15 <Toxaris> MisterZ: try: unZip [("hello", "world")]
12:15:23 <MisterZ> So what does this mean
12:16:04 <allbery_b> MisterZ: it mnmeans Hugs doesn't know how to display the result
12:16:28 <MisterZ> allbery_b: and how to specify its output for the empty list?
12:16:29 <allbery_b> probably because it's polymorphic
12:16:38 <allbery_b> give the input a type
12:17:11 <allbery_b> unZip ([] :: [(Int,Int)]) -- might work
12:17:20 <desegnis> Seems that Hugs' defaulting is quite different from ghci's... by the way, MisterZ:
12:17:23 <MisterZ> okey-dokey, just coz in the past paper they want polymorphic type.. Didn't ask for it explicitly though
12:17:35 <allbery_b> the function can be polymorphic fine
12:17:41 <Toxaris> MisterZ: you can give any expression a type like this: "unZip [] :: ([Int], [Int])" or this "unZip ([] :: [(Int, Int)])"
12:17:45 <allbery_b> it's just that Hugs has no idea how to display a polymorphic type
12:17:48 <MisterZ> Toxaris: btw the example u agve works
12:18:02 <allbery_b> (and isn't smart enough to relkize it doesn't matter)
12:18:36 <MisterZ> allbery_b: lol
12:18:54 <Toxaris> MisterZ: hehe good for you, so your code is fine! it will never be a problem in a real program, because in real programs, types are clear from the context. but in the interpreter command line, there is not enough context available.
12:19:03 <desegnis> > (map fst &&& map snd) [(1,2),(3,4)]  -- because exercises are always stupid. and yea, there's Prelude.unzip too, but I understand that is really not the point ;)
12:19:06 <lambdabot>  ([1,3],[2,4])
12:19:27 <BMeph> pythonist: Did you get help with your stack problem?
12:19:51 <pythonist> BMeph: nope. I was waiting for MisterZ to finish...
12:19:52 <pythonist> >D
12:19:53 <pythonist> :D
12:20:04 <MisterZ> Toxaris: yeah, we have quite an abstract education in haskell. It is just to give some general idea about functional programming apart from concentrating on imperative techniques generally on the course.
12:20:18 <pythonist> The code overflowing is at http://hpaste.org/4996
12:20:45 <pythonist> Compiling to stack and executing with "stack 100000" works fine,
12:20:48 <dons> why are you using your own fold ?
12:20:54 <dons> also, how are you compiling it?
12:20:58 <pythonist> while using 400000 will trigger the overflow...
12:21:00 <MisterZ> pythonist: sorry if i held u in ur work. I'm going back to my past papers. Thanks a lot everyone and sorry for the flood. I'll never do it again! Bye for now, I'm sure I'll return every now and then in the next couple of days.
12:21:18 <FalconNL> Question: In http://okmij.org/ftp/Haskell/vararg-fn.lhs a function "build" is defined that takes a variable amount of arguments and turns them into a list, i.e. build 1 2 3 == [1,2,3]. Unfortunately this level of Haskell hackery is still a bit beyond me so I'm having some trouble composing the function. Let's say for instance that I want a function sumAll that takes a variable number of arguments and sums them, i.e
12:21:32 <pythonist> dons: it fails with regular foldl' and foldr' as well...
12:21:43 <bos> hey, hpaste.org is 1 year old on the 22nd
12:21:53 <dons> oh true. and a lot of uptime -- go happs!
12:22:02 <pythonist> dons: so I was trying to do some test... you can compile your own version with fold = foldl or whatever...
12:22:24 <alexj_> :-)
12:22:30 <desegnis> FalconNL, I think I have a paste ready there, though I'm really not into this type hackery
12:22:46 <pythonist> I can understand why my code is taking all the stack space if I use foldl' which is supposed to be strict...
12:22:47 <kpreid> FalconNL: summing and building a list are essentially the same, it's just a question of whether the operation is (+) or (:)
12:23:10 <pythonist> s/can/can't of course
12:23:16 <pythonist> Any idea?
12:23:19 <dons> pythonist: i think i know what the problem is.
12:23:32 <desegnis> FalconNL, on this occasion I note sizur has annotated the paste :) http://hpaste.org/4968
12:23:51 <pythonist> dons: please, let me know :D
12:24:01 <dons> oh, did you profile it, btw?
12:24:12 <pythonist> I'm looking at stack.prof right now..
12:24:19 <dons> what's on top of the stack?
12:24:26 <pythonist> dons: but it's my first time looking to any profiling file...
12:24:46 <pythonist> dons: what do you mean?
12:24:52 <FalconNL> thanks, I'll see if I can adapt that to my needs. I need it for a cleaner syntax for making html documents with Text.Xhtml
12:24:58 <pythonist> sorry for my dumbness...
12:25:32 <prb> OK -- potentially stupid question about ByteString; how do I get a string?
12:25:39 <prb> "show" does not appear to be the answer.
12:25:41 <dcoutts> unpack
12:25:47 <hpaste>  pythonist pasted "Profiling" at http://hpaste.org/4998
12:25:56 <pythonist> dons: please have a look at that...
12:26:19 <BMeph> bos: Did you mention that it was Knuth's birthday on Thursday? I don't remember if I was on then or not. :)
12:26:46 <bos> wasn't me.
12:27:06 <bos> although there was a big blogging fapfest over it, so it did not go unremarked.
12:27:10 <byorgey> FalconNL: seems a lot of trouble just for a slightly cleaner syntax...
12:28:02 <Sizur> FalconNL: that was the exact purpose of HSXML. if you want to go that route. the implementation will get very hard to comprehend
12:28:18 <FalconNL> byorgey: Yeah, probably, but I'm a big fan of clean syntax. Heck, it's why I started using Haskell in the first place :)
12:28:41 <BMeph> pythonist: You do know that $! is strict function application, right? :)
12:29:13 <pythonist> BMeph: of course.
12:29:48 <prb> dcoutts: Thanks.
12:30:02 <byorgey> FalconNL: fair enough. =)
12:30:40 <pythonist> mmhh...
12:30:47 <pythonist> I think I did a mistake...
12:31:15 <BMeph> That means you're "forcing" your arguments to be constructed, then applying your function.
12:32:25 <pythonist> BMeph: yes, I was using seq but changed to $! as it seems to be clearer...
12:32:34 <pythonist> BTW,
12:32:35 <dons> i'm not sure that's the issue though
12:32:46 <dons> there's something horribly inefficient in there somewhere
12:33:00 <dons> it just uses a lot of stack
12:33:07 <dons> (of constant size)
12:33:32 <hpaste>  pythonist pasted "Change merge to merge'" at http://hpaste.org/4999
12:33:35 <Sizur> FalconNL: in theory we can write a specialized s-expr parser that we can type check upon parsing.
12:33:59 <pythonist> dons: what's your idea anyway?
12:34:17 <BMeph> Well, that means that it first contsructs your list of Just/Nothing values, and then passes it to your (internal) merge function
12:34:27 <hpaste>  gwern pasted "too complex move-word function" at http://hpaste.org/5000
12:34:46 <gwern> I could use some help finding the best definition here :)
12:34:59 <hpaste>  dons annotated "Change merge to merge'" with "variant" at http://hpaste.org/4999#a1
12:35:14 <gwern> I know there's some better way than primitive recursion
12:35:15 <BMeph> ...or did I read too much into that?
12:35:34 <dons> pythonist: i'm a bit too tired to sort out why it uses such a large stack, but all those replicates are a bit suspicious
12:35:52 <FalconNL> Sizur: I'm trying to see if I can manage with Text.Xhtml and roughly 10 lines of code. The only extra syntax compared with s-exps will be one operator after each element that has children
12:36:01 <pythonist> dons: Wait, I'm compiling it :D
12:36:46 <hpaste>  gwern annotated "too complex move-word function" with "unicode may not work for everyone :)" at http://hpaste.org/5000#a1
12:37:01 <dons> $ ./A 400000  +RTS -K100M certainly runs to completion, so I suspect its your algorithm :)
12:37:33 <Sizur> FalconNL: well, i love xhtml. but with sexprs you can produce things like html, json, js statement sequence to be evaled from client side and mounted on an element, etc
12:37:51 <pythonist> dons: Yes, I tried to raise the stack size too, but my point is another one.
12:38:47 <gwern> @pl dropTail n xs = reverse $ drop n $ reverse xs
12:38:47 <lambdabot> dropTail = (reverse .) . (. reverse) . drop
12:39:20 <pythonist> dons: I expected my program to have constant space requirements...
12:39:45 <gwern> actually, 'take' would be the same thing too...
12:39:45 <gwern> @src take
12:39:46 <lambdabot> take n _      | n <= 0 =  []
12:39:46 <lambdabot> take _ []              =  []
12:39:46 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:40:08 <pythonist> dons: It's a kind of "generate an instance" -> "accumulate" -> "destroy the instance", as the instance is not needed anymore...
12:40:17 <dons> yeah
12:40:19 <pythonist> dons: or at least that was my thought...
12:40:42 <pythonist> dons: ghc seems not to recognize that pattern, of sort of...
12:41:33 <pythonist> dons: I can't understand why so many function calls and stack frames are being put on the stack...
12:42:09 <pythonist> dons: BTW, do you think my fold function is tail-recursive?
12:42:14 <dons> the control flow here from gen/take/zipWith and the fold is a bit complex. something might be hanging on to results that aren't needed
12:42:54 <pythonist> dons: I see...
12:44:12 <pythonist> dons: anyhow it's disappointing... I'm running a small competition with one of my collegues who implemented an algorithm in MS Excel and it worked fine :D
12:44:33 <dons> folding a zipWith is quite unusual
12:44:45 <dons> since you'll be zipping over the accumulator, hanging on to lots of previous values
12:45:01 <dons> if there's an excel impl, perhaps it can be translated more idiomatically?
12:45:03 <pythonist> dons: of course, with Excel you can control more finely what you program does... but I'm frustrated I can't replicate similar performance in ghc...
12:45:29 <dons> ghc compiles to native code, and we do have fine grained control, but here its all lists and higher order foldy things, so a bit hard to untangle.
12:45:47 <pythonist> dons: let me work out that zipWith thingy...
12:46:30 <dons> also, the accumulator is a list , right?
12:46:41 <pythonist> dons: yep.
12:46:42 <dons> so $! only reduces that to weak head normal form (the outermost (:) constructor)
12:47:30 <Sizur> checkout this error page: http://www.sxemacs.org/,
12:47:31 <lambdabot> Title: SXEmacs Website
12:48:37 <EvilTerran> "SXEmacs does not support the Win32 platform and it never will. Yes, we consider this a feature." -- ooh, lookit the smug linux weenies
12:48:38 <Sizur> haha, one could even feed that through comet
12:49:04 <Sizur> yeah, purity get's in the way sometimes
12:49:12 <Sizur> like GPL ;)
12:49:19 <Sizur> like, dare i say?
12:49:36 <Sizur> no, not in this channel ;)
12:49:45 <monochrom> Accumulating a list is suspicious.
12:49:54 <gwern> EvilTerran: there's a fair bit of ugliness in emacs sources because they try to support windows
12:49:56 <Cale> pythonist: Can we look at your program somewhere?
12:50:03 <C-Keen> it's delicious not suspicious :)
12:50:10 <Cale> (I just found the prof paste)
12:50:24 <EvilTerran> gwern, i'm sure, with the right abstraction, it could be supported fairly easily
12:50:31 <dolio> Finally, an editor that will let me use my 32 button mouse!
12:50:32 <EvilTerran> but you'd have to write for cross-platform from the start
12:50:53 <pythonist> Cale: Cale http://hpaste.org/4996
12:50:53 <hpaste>  dons pasted "pythonista's program" at http://hpaste.org/5001
12:51:20 <byorgey> dolio: pah, those are so 2007.  You need to upgrade to 64 buttons!
12:51:22 <dons> that's the same one, cleaned up a little. i'm quite suspicious about the [a] accumulator getting folded
12:51:24 <EvilTerran> and the thing to say would be "clean codebase", not "we use linux and that makes us better than you"
12:52:32 <Cale> So fold = foldl'
12:53:05 <monochrom> What is merge supposed to do?
12:53:08 <jfredet1> what is all this supposed to do?
12:53:26 <monochrom> "Attack the problem, not the solution"? :)
12:53:59 <hpaste>  gwern annotated "too complex move-word function" with "what's wrong with this?" at http://hpaste.org/5000#a2
12:54:02 <pythonist> Cale: yes, I was experimenting, but triend fold = foldl'
12:54:08 <pythonist> s/triend/tried
12:54:19 <dons> the list of Nothings is a bit odd too, isn't it.
12:54:26 <dons> the original problem spec would be useful :)
12:54:32 <dons> since it looks quite cute
12:54:43 <pythonist> monochrom, dons: it's a toy program, a reduced case of a larger program...
12:54:48 <jfredet1> lol, i'd just like to know what I'm looking at, :)
12:55:15 <dons> pythonist: just a description of the goal, so maybe it can be reformulated a bit.
12:55:25 <pythonist> Ok, I'll try.
12:55:31 <dons> lists of nothings in accumulators are something unusual enough to consider a different version
12:55:37 <Cale> merge n = let k = (min (n-1) 39) in replicate k Nothing ++ replicate (40 - k) (Just '*')
12:55:38 <Cale> ?
12:55:54 <pythonist> Suppose you have a vector of k elements.
12:56:16 <pythonist> and suppose you have a list of N vectors of the same legth.
12:56:26 <byorgey> gwern: I think the 'where' doesn't scope over both cases.
12:56:58 <pythonist> Now, you want to element-wise combine these vectors from the list.
12:57:05 <Sizur> EvilTerran: i completely agree. linux is about choices. that includes windows (unfortunately that includes the weenies too)
12:57:07 <gwern> it's clearly a scope problem, yes
12:57:36 <Cale> pythonist: If the vectors are lists, you can start by transposing.
12:57:44 <byorgey> gwern: if you unindent the where some, it will belong to the definition of moveWord rather than the case.
12:57:44 <pythonist> Basically, you want to know where the vectors "agree" element-wise.
12:58:11 <pythonist> You start with a sort of "state" vectors, filling it with Nothing,
12:58:23 <pythonist> Sorry "state" vector... singular...
12:58:37 <pythonist> Then, for every vector in the list, you update the state vectors,
12:58:40 <Cale> That seems like a strange way to handle the algorithm to me.
12:58:56 <pythonist> replacing the elements with the merge function...
12:58:59 <dons> yeah, a bit too mutable-state oriented?
12:59:09 <pythonist> Cale: At first my algorithm used an expression like:
12:59:14 <dons> lots of flipping/updates in list traversals
12:59:31 <Cale> Why do you need that state? Why not just construct a list whose elements consist of whether the list of vectors match in that component? :)
12:59:32 <pythonist> Cale: all equals $ transpose l
12:59:36 <byorgey> sounds like a fold of zips to me.
12:59:41 <pythonist> But it runned out of sapce quite soon...
12:59:50 <Valodim> (ran)
13:00:02 <pythonist> dons: yes, mutable vectors is the coorect definition...
13:00:19 <pythonist> Valodim: yes... I'm writing too quickly...
13:00:37 <Cale> You might try just strictifying that algorithm there.
13:00:57 <Cale> hmm
13:01:06 <Cale> How many of these vectors do you have?
13:01:36 <pythonist> I reformulated my code using this sort of "state" vector, just to see if ghc's is smart enough to detect the "replace" pattern...
13:01:40 <monochrom> Sounds like involving (map fold . transpose), for a suitable fold using a suitable operator.
13:01:49 <pythonist> Cale: it overflow at 400000
13:02:23 <Cale> monochrom: I agree.
13:02:35 <Cale> A strict left fold, perhaps :)
13:02:59 <dons> but note if the accumulator is a list (or list of lists), you'll need to be a bit smarter about how you strictify it
13:03:23 <Cale> yeah, but it shouldn't be -- we should just be accumulating a boolean value.
13:03:32 <dons> pythonist: what do you mean by 'smart enough'? what optimisation are you hpoing for?
13:03:50 <phobes> Cale:  Dont' you need to accumulate the common value too?
13:03:55 <Cale> (though that's kind of sad if we can't use laziness there)
13:04:04 <Cale> phobes: can't we do that separately?
13:04:10 <phobes> yes
13:04:18 <jfredet1> dons: probably an optimization that will make his code work, thats what I'd hope for, :)
13:04:41 <jfredet1> ghc does lots of magical things to my code to make it work. :)
13:04:49 <phobes> Cale:  By that I assume you mean you're going to answer do all n-1 vectors match the 1st vector?
13:04:53 <phobes> (or something)
13:05:12 <Cale> You're just checking whether they match elementwise, for each element.
13:05:26 <phobes> Whether they all match, right?
13:05:30 <Cale> yes
13:05:40 <Cale> So after the transpose, you have n problems which are just checking whether all the elements of the list are equal.
13:05:55 <phobes> Which is equivalent to "do the last n-1 match the first one"
13:06:04 <pythonist> dons: well, after the application, the vector I applied to the state is not need anymore...
13:06:24 <dons> ok, so if its sufficiently lazy (and the results are not required), the GC will remove it
13:06:36 <pythonist> dons: yes, something like that...
13:06:47 <dons> so it needs to produce values incrementally, and be structure in such a way that previous results can be discarded
13:06:50 <Cale> @src and
13:06:51 <lambdabot> and   =  foldr (&&) True
13:06:56 <pythonist> dons: but it seems something is hanging out the on the stack preventing a full strict application...
13:07:52 <phobes> pythonist:  What are the sizes of n and k, roughly?
13:08:12 <pythonist> phobes: n = 400000, k = 40
13:08:18 <Cale> I think that maybe the problem is that all the vectors end up hanging around in memory.
13:08:36 <phobes> oh, I was imagining those numbers roughly reversed
13:08:47 <jfredet1> does the algo work for smaller values of n?
13:08:51 <dons> Cale: right
13:09:00 <dons> jfredet1: sure, it just uses a lot of stack
13:09:13 <Cale> err...
13:09:32 <monochrom> All vectors in memory is no problem. Most likely the input vectors are already in memory in the first place.  Using the wrong recursion is the problem.
13:09:41 <gwern> suppose I have a list [3,7,11,15], and an input number, say 5, and I want to return the next highest number (in this case 7). can this be done with a fold?
13:09:42 <jfredet1> right- but i guess I was wondering if the same stack overflow occurs at lower values, because then it might be that he's got a runaway fold or something
13:09:53 <gwern> or should I go 'head $ filter (> n)'?
13:09:55 <pythonist> monochrom: I think you're right...
13:10:23 <Saizan> gwern: what's wrong with filter?
13:10:41 <phobes> gwern:  Is it sorted?
13:10:42 <hpaste>  pythonist pasted "doesn't overflow" at http://hpaste.org/5002
13:10:48 <Cale> My naive program works with n = 400000, k = 40
13:10:54 <Cale> allEqual xs = and $ zipWith (==) xs (tail xs)
13:10:54 <Cale> componentsSame xss = map allEqual $ transpose xss
13:11:11 <Cale> main = print (componentsSame (replicate 400000 [1..40]))
13:11:11 <pythonist> Cale: have a look at my code... it doesn't crash too...
13:11:33 <gwern> Saizan: I was wondering if there was any shorter way to do it
13:11:33 <pythonist> Cale: of course, I'm throwing away the Maybe stuff...
13:11:39 <dons> oh, that looks better
13:11:41 <gwern> phobes: yes
13:11:50 <pythonist> dons: I know, that was my first attempt...
13:12:10 <Saizan> gwern: shorter than that i can only imagine an ad-hoc function
13:12:15 <dons> ?pl \x -> all (==x) xs
13:12:15 <lambdabot> flip all xs . (==)
13:12:19 <pythonist> dons: but, when fitted in the larger program, it died with something like "Virtual memory exhausted" :D
13:12:21 <Saizan> ?type find
13:12:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:12:35 <pythonist> dons: so, no stack overflow, but memory exhausted...
13:12:36 <Saizan> find (> n) :)
13:13:12 <pythonist> dons: I was trying to be a little more conservative in the "state vector" version... but started having stack problems...
13:14:10 <pythonist> dons, Cale, monochrom: In http://hpaste.org/4996, do you think my version of fold is tail-recursive?
13:14:15 <dons> pythonist: it doesn't run in constant space either though
13:14:17 <dons> its just faster
13:14:32 <Cale> pythonist: It clearly is :)
13:14:38 <pythonist> dons: mmhhh... let me see if I can crash it..
13:14:42 <pythonist> Cale: thanks
13:14:54 <gwern> 'moveWord str l =  head $ filter l $ map snd $ filter (x  (fst x) == ' ') $ zip str [0..]' <-- bwa ha ha
13:15:01 <gwern> sometimes it really pays to just flop on a couch and think a little :)
13:15:13 <Cale> Doing heap profiling, my program appears to run in exactly the amount of space needed to hold all the lists in memory at once.
13:15:33 <ricky_clarkson> :t str
13:15:34 <lambdabot> Not in scope: `str'
13:15:45 <ricky_clarkson> oops
13:15:50 <Cale> (it quickly reaches a plateau and then remains the same for the rest of the program run)
13:16:04 <dons> Cale, yep, that's what I see too.
13:16:19 <monochrom> It's tail recursive. But if "a", "f a x" are complicated things (such as list, tree, ...), they still won't be fully evaluated before next iteration.
13:16:57 <Cale> monochrom: yes, that's an important point to make :)
13:17:01 <pythonist> monochrom: I see.
13:17:26 <Cale> f $! x only evaluates x up to the point where the top-level data constructor can be determined
13:17:27 <pythonist> monochrom: Is there some way to get a clue of what's happening behind the scenes with ghc?
13:17:32 <Cale> (before resulting in f x)
13:17:50 <dons> yes, a deepFold would use 'last a' to force the accumulator
13:17:54 <gwern> > let moveWord str l =  head $ filter l $ map snd $ filter (x  (fst x) == ' ') $ zip str [0..]; nextWord index = moveWord (> index) in nextWord 2 "foo bar baz"
13:17:54 <lambdabot>  Illegal character ''\187''
13:17:54 <lambdabot>  at "x" (column 60)
13:18:03 <byorgey> gwern: nice =)
13:18:18 <pythonist> dons: deepFold!!! I've read of that once but it didn't come tomy mind earlier... googling...
13:18:27 <Cale> Ah, I see what's going on now, your program is doing a strict fold which is accumulating a list. Yes, that's not a good idea ;)
13:18:37 <Cale> deepSeq?
13:19:07 <kmcallister> dons, you said yesterday you started to write a C generation library... do you have any thoughts on what the interface should look like?
13:19:54 <dons> kmcallister: it should be a set of pretty printer combinators for building a C AST, then rendering it.
13:19:56 <pythonist> Cale: Where is DeepSeq?
13:20:02 <dons> similar to xhtml or similar libs
13:20:10 <dons> kmcallister: and it could use the C AST already we have for c2hs
13:20:16 <dons> which includes a parser
13:20:26 <hpaste>  Cale annotated "Stack overflow" with "try this fold" at http://hpaste.org/4996#a1
13:20:26 <dons> so a full C parser, AST, and pretty printer. would be an awesome library
13:20:30 <ricky_clarkson> Cale: Is a lazy fold that accumulates a list ok?
13:20:34 <phobes> What's the rule for deepSeq?  Seems like it would be dangerous / not composable
13:20:47 <Cale> ricky_clarkson: often
13:20:53 <andyjgill_> There is no deepSeq
13:21:02 <kmcallister> dons, i wrote a simplified AST and pretty printer yesterday
13:21:09 <Cale> deepSeq is a folk-function :)
13:21:12 <dons> we use rnf and other Control.PArallel.Strategies stuff now
13:21:16 <pythonist> Cale: folk?!?
13:21:22 <dons> andyjgill_'s responsible for it, iirc
13:21:31 <dons> $!! and friends
13:21:34 <andyjgill_> But I'd love a hseq function in Haskell'.
13:21:34 <kmcallister> simplified meaning the AST admits values which are not syntactically correct C programs, but as a result requires much fewer types than a direct translation from the BNF
13:21:52 <Cale> It's not in the libraries, but most people will know what you mean if you talk about it, and it's been written in various web pages and mailing list messages.
13:22:16 <pythonist> Cale: yes, I've just found one...
13:22:23 <Cale> You can just use rnf from Control.Parallel.Strategies, it mostly does the same thing :)
13:22:23 <Saizan> ?type Control.Parallel.Stategies.rnf
13:22:25 <dons> andyjgill_: rnf in Control.Parallel.Strategies is deepSeq
13:22:28 <lambdabot> Couldn't find qualified module.
13:22:37 <dons> its the method of the NFData class
13:22:43 <Cale> (that's  "reduce to normal form"
13:22:44 <Cale> )
13:22:56 <andyjgill_> Yes, it is. for historical reasons
13:23:02 <dons> but its the classic DeepSeq we used to use in  the olden days
13:23:13 <Cale> I really wish that GHC could derive NFData, and that it had better support across the libraries.
13:23:14 <andyjgill_> but I'd rather a strict :: a -> a function.
13:23:28 <phobes> Cale:  On the other hand in a strict language, deepLazy would be safe and useful
13:23:35 <dons> NFData shouldn't be in the parallel lib really.
13:23:36 <andyjgill_> where, strict a = a `hseq` a
13:23:41 <Cale> phobes: How is deepSeq unsafe?
13:23:43 <dons> evaluation control is a basic haskell functionality
13:24:21 <phobes> Cale:  I'm still hazy on what it does, but I'd think it would break the ability to use values relying on nonstrict evaluation in the expression you're "seq"ing
13:24:33 <Cale> phobes: and how would that be useful? You'd have to hang on to the strict piece of data in order to generate the lazy one anyway, so wouldn't that just be a waste of memory?
13:24:53 <phobes> Cale:  Not if you're going small -> big
13:25:11 <Cale> phobes: But, er, do you know what deepSeq does?
13:25:21 <phobes> Cale:  I'm guessing not :)
13:25:31 <Cale> deepSeq x y  will fully evaluate x before resulting in y
13:25:59 <gwern> byorgey: now I just need to get it to play nice with xmonad, test it, and push it
13:25:59 <phobes> Cale:  hmm oh I see
13:26:05 <Cale> For example, on lists, you have:
13:26:14 <phobes> Cale:  So if it's an infinite stream, you get get divergence
13:26:17 <phobes> (x)
13:26:20 <Cale> deepSeq xs y = foldl seq () xs `seq` y
13:26:27 <Cale> right
13:26:34 <andyjgill_> The deepSeq I want have caching of previous deepSeq's, so you only need to deepSeq unevaluated things
13:26:41 <andyjgill_> have=>has
13:26:59 <Heffalump> so you want to tag things as "fully evaluated"?
13:27:04 <Cale> andyjgill_: caching?
13:27:06 <phobes> Cale:  hmmm, did you want "deepSeq" on the rhs of your definition?
13:27:14 <Cale> andyjgill_: Oh, in that sense.
13:27:24 <Cale> phobes: no
13:27:37 <phobes> so deepSeq is something that just operates on a list?
13:27:43 <Toxaris> Cale: but the members of the list are only seq'ed, not deepSeq'ed
13:27:44 <Heffalump> phobes: no, it's in a type class
13:27:47 <Cale> phobes: No, that's just the list instance.
13:28:02 <Cale> phobes: You have to write it for each datatype separately.
13:28:03 <Toxaris> deepSeq xs y = foldl deepSeq () xs `seq` y -- what I would expect
13:28:06 <Heffalump> and shouldn't that be a foldr, or it's not lazy enough?
13:28:13 <phobes> Yes, I'm agreeing with Toxaris
13:28:19 <phobes> I'd think deep seq should be... deep :)
13:28:24 <Cale> Toxaris: Oh, that's a good point.
13:28:42 <dons> andyjgill_: btw, did you see the 'next big language' predictions, (a strict pure haskell will emerge...), http://lambda-the-ultimate.org/node/2600#comment-39191
13:28:43 <lambdabot> Title: Prediction for 2008 | Lambda the Ultimate
13:28:48 <Cale> There are cases where you'd want either one, but yeah, that's deeper :)
13:29:06 <Cale> bah, I don't know about that :)
13:29:10 <Heffalump> and I still think foldl is wrong
13:29:13 <Cale> The world has enough strict languages.
13:29:22 <Toxaris> Cale: it's phobes' point :)
13:29:24 <phobes> Cale:  Where's the pure strict languages?
13:29:33 <Cale> Heffalump: yes, I meant to use foldl'
13:29:40 <Heffalump> that's still wrong
13:29:43 <andyjgill_> I've been harping on about strict, pure languages for years. There are some technical difficulties, though.
13:29:45 <Cale> Heffalump: how?
13:29:54 <dons> i want a more reliable strictness analyser for haskell, in the long term
13:30:04 <Heffalump> oh, wait, no
13:30:07 <dons> i'm happy with mixed strict/lazy, with lazy as the default
13:30:14 <Heffalump> I was thinking it should stream an infinite list, but that's nonsense.
13:30:30 <phobes> andyjgill: technical difficulties?  do tell
13:30:30 <Cale> dons: me too :)
13:30:47 <Cale> Lazy default is important! More important than people seem to recognise a lot of the time.
13:30:54 <dons> we could do more to explain that
13:31:08 <dons> since it enable programming in the large, with decoupled components
13:31:13 <dons> something hard to show in small examples
13:31:26 <Heffalump> I'm not entirely convinced by that. It's actually quite hard to generate structures lazily.
13:31:38 <andyjgill_> There is no way to directly express recursive structures in a strict, pure language, even though they are conceptually valid
13:31:54 <Heffalump> In simple cases, it just happens, but I don't think that's true of complex cases.
13:32:04 <Cale> andyjgill_: you mean circular structures?
13:32:13 <andyjgill_> yes.
13:32:32 <phobes> dons:  Is the major issue the ability to write code that requires non-strict evaluation to terminate?  or the efficiency of laziness?
13:32:56 <ricky_clarkson> I wish I could get Scala to notice my circular structures instead of giving me NullPointerExceptions when I observe them during construction by accident.
13:33:09 <Heffalump> andyjgill_: presumably you could do it by adding combinators for explicit laziness and then getting the compiler to sort it out in that special case, though.
13:33:11 <ricky_clarkson> notice -> fail to compile or similar.
13:33:17 <phobes> andyjgill:  "directly" here meaning that you might need some sugar to wrap thunking?
13:33:25 <Cale> It would be cool to have something like ST, but which could walk around a datastructure built out of STRefs and purify it thorougly into a knot-tied structure.
13:33:33 <dons> data T a = Nil | T a ~(T a) (~T a) -- :)
13:33:38 <andyjgill_> No. its deeper.
13:33:51 <andyjgill_> You want a pure structure that contains loops.
13:34:03 <andyjgill_> In imperative languages, you use assignment.
13:34:10 <andyjgill_> No thunks involved here.
13:34:23 <phobes> andyjgill
13:34:25 <dons> ?users
13:34:25 <lambdabot> Maximum users seen in #haskell: 454, currently: 450 (99.1%), active: 18 (4.0%)
13:34:49 * jwp becomes active for the sake of being active
13:34:59 <kaol> hey, me too
13:35:05 <Botje> pffrt.
13:35:15 <phobes> andyjgill_:  Example of why you want such a thing?
13:35:16 <Botje> project euler is letting me down with vague problem descriptions :(
13:35:21 <jfredet1> yah
13:35:22 <ricky_clarkson> What's the maximum active count?
13:35:26 <pejo> andyjgill_, do you believe these problems are unsolvable, or is it "just" that nobody has proposed a solution yet?
13:35:29 <phobes> You can certainly do streams
13:35:48 <ikegami--> watching logs is a fun
13:35:52 <pythonist> Well, well, well... thank you folks... my first version of stack now doesn't overflow anymore...
13:36:00 <TSC> Botje: Which one?
13:36:00 <phobes> The thing is that datastructures can be simulated in pure lambda caluclus... so I think this is just a matter of sugar
13:36:03 <andyjgill_> The problem requires some syntactical and semantics support, but it is doable.
13:36:06 <hpaste>  kib pasted "trying to print each element (2-tuple) of a list line by line" at http://hpaste.org/5003
13:36:09 <Botje> TSC: 93.
13:36:13 <kib_> I need some help in printing elements of a given list.
13:36:34 <hpaste>  pythonist pasted "with dons' deepSeq" at http://hpaste.org/5004
13:36:41 <andyjgill_> For example, parsing combinators are actually a *value*, which is defined via loop.
13:36:47 <ricky_clarkson> phobes: You mean a circular data structure can always be converted to a one-way with no loss?
13:36:48 <andyjgill_> loop => loops
13:37:11 <Botje> kib_: what's the problem? besides the obvious syntax error in print reverseCoords
13:37:13 <Cale> kib_: show just produces a string
13:37:24 <Cale> kib_: It doesn't produce an action for printing that string
13:37:25 <Botje> kib_: perhaps you want show instead of print
13:37:29 <Cale> kib_: You want print, yeah
13:37:36 <Botje> uhh
13:37:39 <Botje> DAMMIT >_<
13:37:45 <Cale> print instead of show :)
13:37:51 <Botje> this is why you do not get out of bed before eleven, folks.
13:37:59 <Cale> also, printCoords = mapM_ print
13:38:13 <TSC> Botje: That description is a bit confusing at first
13:38:13 <Cale> Botje: It's okay, I'm half asleep still too.
13:38:17 <kib_> I've tried show((1,2)) in ghci and it works, so why ?
13:38:34 <Cale> kib_: Because ghci automatically applies print to everything which isn't an IO action.
13:38:42 <Toxaris> kib_: ghci is special. it tries to guess what you want.
13:38:44 <phobes> ricky_clarkson:  If you think of everything as having a functional interface - so a value of some data is just it's behavior as a function, then sure, right?  You can simulate everything in LC
13:39:08 <Cale> kib_: also, you don't need the extra parens there :)
13:39:15 <Cale> kib_: show (1,2) will work as well :)
13:39:28 <kib_> oklopol, I was not aware of this, thanks. So where is my syntax error inside reverseCoords ?
13:39:31 <Botje> Cale: did I mention it's 22h here? :)
13:39:47 <TSC> Botje: But I've done that problem, so I could clarify any problems
13:39:52 <Cale> Botje: Here it's 4:30 in the afternoon, and I just woke up :)
13:40:00 <jsnx> is a file a monadic value?
13:40:13 <Cale> jsnx: No, but an action for reading a file is.
13:40:22 <jsnx> hmm
13:40:32 <Cale> (in particular, in the IO monad)
13:40:36 <jsnx> so, what kind of object is a file?
13:40:46 * oklopol is thanked a lot these days
13:40:56 <kmcallister> ?ty Handle
13:40:58 <lambdabot> Not in scope: data constructor `Handle'
13:40:59 <Botje> TSC: I think i'm just not getting the parenthesis right
13:41:00 <jsnx> basically, i am trying to formalize shell semantics
13:41:01 <Cale> It's... not something represented directly in Haskell? Or else a string
13:41:37 <jsnx> Cale: even if it's not represented "directly", neither are monadic values (they are supplied by a library)
13:41:40 <kmcallister> jsnx, an open file would be represented by a value of type Handle
13:41:51 <jsnx> should be representable as something or other...
13:42:01 <Botje> TSC: did you use a list of operators or a real tree to generate the possible statements?
13:42:07 <jsnx> well, i am not being clear, honestly
13:42:10 <Cale> jsnx: Files are part of the "outside world" though.
13:42:19 <jsnx> Cale: right -- but so what?
13:42:43 <Cale> jsnx: There are actions for reading and writing them, but nothing which represents a file in its entirety. You could perhaps construct a type capable of that.
13:42:45 <allbery_b> @src Handle
13:42:45 <lambdabot> Source not found. Wrong!  You cheating scum!
13:42:52 <allbery_b> figured I'd check
13:43:02 <jsnx> Cale: i'm with you there
13:43:18 <jsnx> maybe they are kind of like an STM var?
13:43:22 <TSC> Botje: I used the list monad, which sort of emulates a tree: choose a number, then choose an operator, then a number, then op, etc
13:43:23 <Cale> uh...
13:43:37 <Cale> hmm
13:43:38 <TSC> Botje: Then evaluate strictly left-to-right, ignoring normal precedence
13:43:44 <allbery_b> much of ghc's I/O stuff is in fact written in haskell
13:43:45 <Botje> heh :)
13:44:01 <allbery_b> (aside from the lowest level system library operations)
13:44:06 <Botje> i'll try that, thanks
13:44:13 <jsnx> it would be nice to have a well-founded, typeful "theory of files"
13:44:20 <TSC> Botje: Good luck! (:
13:44:31 <jsnx> though that is beyond my power at the moment
13:44:39 <Botje> the "solution" I found had 43 consecutive integers
13:45:09 <jsnx> anyway, just thought i'd see if anyone was into that sort of thing, or had read about it, &c.
13:45:35 <Cale> http://en.wikipedia.org/wiki/Inode
13:45:35 <lambdabot> Title: inode - Wikipedia, the free encyclopedia
13:45:37 <phobes> jsnx:  what about other programs updating files?
13:46:02 <Cale> On a unix machine, a file datastructure would be basically an inode.
13:46:03 <jsnx> phobes: well, that has to be in the theory
13:46:03 <phobes> jsnx:  or are you not talking about trying to type what's in files?
13:46:16 <gwern> phobes: oh that's easy; it'll use the darcs theory of patches :)
13:46:23 <jsnx> phobes: i'm trying to discern a "semantics of files"
13:46:30 <phobes> "theory of patches"
13:46:37 <jsnx> gwern: yeah, i think that fits well
13:46:58 <gwern> or maybe STM?
13:47:05 <jsnx> Cale: well, i guess i mean a "type class" -- a set of operations -- in addition to an actual data type
13:47:12 <Cale> That is, a device id, a bunch of ownership and permissions information, timestamps, a reference count, and a pointer to the disk blocks which hold that information.
13:47:27 <phobes> I think it's going to be hard to reason about files or networking
13:47:35 <jsnx> well, a file is more than that
13:47:46 <jsnx> it can be executed, for one
13:48:01 <Cale> Perhaps it's also the exact stream of bytes on disk as well :)
13:48:04 <TSC> Botje: You can get higher than 43 consecutive numbers
13:48:08 <phobes> To get very far with it, you basically have to split into two cases - good behavior (everyone is writing to the files according to the protocol I've laid out here) and bad behavior (not)
13:48:12 <Botje> okay
13:48:23 <Botje> then my way of generating operations is very wrong indeed :)
13:48:24 <jsnx> phobes: what is the good behaviour?
13:48:38 <Botje> i'll try and fiddle with it some more tomorrow / tonight
13:49:09 <phobes> jsnx:  Alot of the reasoning you want to do with files is based on the assumption that you know something about the program that wrote to the file (like, e.g. it was a previous run of the same program currently running)
13:49:15 <TSC> If you do it like the way I did it, you need six "operators" instead of four
13:49:38 <phobes> jsnx:  But you also need to make sure your program is robust in the case that there is bad behavior - the user loaded the file in a hex edtior, e.g.
13:50:12 <jsnx> Cale: then a common case -- writing to and then reading from the same file -- just doesn't make any sense
13:50:14 <Cale> Oh, you're trying to write down a semantics for the IO monad?
13:50:26 <jsnx> Cale: well, that's a lot to do...
13:50:39 <jsnx> do you think it reduces to that?
13:50:39 <phobes> Cale:  jsnx is trying to type the contents of files, I think
13:50:41 <Cale> jsnx: yes, that's my thought as well :)
13:50:55 <Cale> uh, well, I'm not sure what your goals are :)
13:50:59 * Botje is also thinking of making a trading game in haskell
13:51:07 <gwern> I think you have have typed filesystems. heck, if you can have typed assembly language...
13:51:11 <Botje> something like Ports of Call, except not as annoying
13:51:25 <Cale> gwern: yes, I would like to see that happen mysel
13:51:26 <Cale> f
13:51:30 <jsnx> phobes: yes, that is right -- i am not trying to type the contents of files
13:51:36 <phobes> Trying to have program types for the contents of files on disk is hard unless you make some assumptions about your program being the only participant in file modification I think
13:51:57 <phobes> jsnx:  So you're just trying to type "file handles" or something?
13:52:02 <phobes> which ones are open or closed
13:52:03 <phobes> e.g.
13:52:04 <phobes> ?
13:52:07 <jsnx> phobes: well, you just have to verify the types all the time -- but that's okay, you have to do it anyway
13:53:07 <jsnx> phobes: well, files admit of a few operations -- exec, mv -- which handles do not
13:53:17 <phobes> jsnx:  If you're just talking about breaking out some typeclasses involving files from the big IO monad, I think that's a good idea in principle (though perhaps not in practice right now)
13:53:55 <jsnx> phobes: yeah, basically
13:54:13 <phobes> jsnx:  well, whether the operation is done on the handle or actually on the file .... that's just definitions to me :)
13:54:14 <jsnx> the shell has what i call "first class files"
13:54:34 <jsnx> phobes: it should be done on the handle, but you can't move one handle to another
13:54:54 <kmcallister> gwern, i know some people who have worked on typed filesystems
13:55:08 <jsnx> also, a handle is not really a file -- it's an input-output pair
13:55:15 <gwern> kmcallister: it go well?
13:55:22 <jsnx> a necessary abstraction, hidden by the shell, most of the time
13:55:29 <kmcallister> the prototype had to invoke ghc for each file open
13:55:31 <kmcallister> which was a bit slow
13:55:48 <phobes> jsnx:  So you actually want first class files?
13:55:53 <jsnx> i think asn.1 could worked for "typed files"
13:56:06 <jsnx> phobes: well, you can't actually have first class files in haskell
13:56:08 <phobes> jsnx:  (I'm not even sure what that means)
13:56:12 <kmcallister> jsnx, i was thinking that the type of a file would be something like an XML schema
13:56:36 <gwern> kmcallister: why would it call ghc for each file? surely the types and safety could've been compiled away with existentials or something
13:56:44 <jsnx> kmcallister: i bet you ASN.1 has richer productions that XML schema :)
13:57:06 <jsnx> kmcallister: also, you can define things like IOUArray in ANS.1
13:57:23 <jsnx> and it will really be an ondisk IOUArray!
13:57:33 <phobes> jsnx:  I guess it depends what you mean by that... A file wouldn't be a haskell value (there is no expression whose value is a file), but files could be bound to free variables in a monad by the runtime
13:57:42 <hpaste>  dons pasted "rnf" at http://hpaste.org/5005
13:57:59 <jsnx> phobes: i wouldn't want first class files in haskell
13:58:08 <jsnx> because it would make value lookup all weird
13:58:20 <kmcallister> ASN.1 looks cool... are there haskell libs?
13:58:27 <jsnx> kmcallister: yes
13:58:29 <phobes> jsnx:  Yes, I'm not sure what it would even mean, since part of the point of files is that they are persistent
13:58:36 <phobes> well, maybe not
13:58:42 <jsnx> and erlang, o'caml, java...
13:58:45 <Corun> Sorry guys, I've had enough with haskell. I'm converting to ASM!!!
13:59:11 <jsnx> phobes: so, in haskell, a value can be a function
13:59:11 <Corun> Look, Sieve of Eratosthenes: http://rafb.net/p/ymzIk064.html
13:59:13 <lambdabot> Title: Nopaste - No description
13:59:13 <Cale> I suppose if you wanted a simulated filesystem, you'd represent it as an IORef (Map String (IORef SomeStructure))
13:59:21 <glen_quagmire> what is maximum value of an Int?
13:59:28 <jsnx> phobes: so we say haskell has first class functions
13:59:29 <Cale> Where SomeStructure would handle file attributes and contents etc.
13:59:37 <gwern> Cale: I like oleg's zipper fs
13:59:40 <Cale> glen_quagmire: depends on the machine
13:59:41 <nelhage> ew, Intel syntax.
13:59:44 <Botje> > maxBound :: Int
13:59:47 <lambdabot>  2147483647
13:59:48 <jsnx> in the shell, any value -- say `cat` -- can be a file or command
13:59:51 <kmcallister> > maximum $ ([0..] :: [Int])
13:59:57 <lambdabot> Terminated
14:00:00 <kmcallister> i like my way better :D
14:00:00 <jsnx> files can undergo the same operations that commands can
14:00:03 <jsnx> and a few more
14:00:07 <Corun> Sorry nelhage. That's what my uni teaches
14:00:10 <glen_quagmire> > length [0 .. (maxBound :: Int)+1]
14:00:11 <lambdabot>  0
14:00:23 <kmcallister> > maxBound :: Integer
14:00:23 <lambdabot>   add an instance declaration for (Bounded Integer)
14:00:24 <lambdabot>     In the expression: ma...
14:00:27 <kmcallister> > maxBound :: Char
14:00:28 <lambdabot>  '\1114111'
14:00:36 <kmcallister> gah, octal
14:00:38 <Cale> But it's at least 2^29 - 1
14:01:01 <nelhage> > fromEnum (maxBound :: Char)
14:01:02 <lambdabot>  1114111
14:01:03 <Corun> (Why on earth is it 2^29 -1 in the haskell spec?)
14:01:03 <phobes> jsnx:  can you give an example of what you want to be able to do?
14:01:09 <Cale> (that's an uncommon bound in practice)
14:01:09 <kmcallister> Corun, tagged representations
14:01:23 <pythonist> dons, Cale, monochrom: thank you folks... you were so helpful... see you next time...
14:01:24 <glen_quagmire> :t length
14:01:26 <lambdabot> forall a. [a] -> Int
14:01:26 <kmcallister> in some implementations one or two low-order bits are reserved for a tag
14:01:26 <Cale> Corun: To allow for extra tag bits on 32 bit machinery, if necessary.
14:01:28 <Heffalump> hehe, I just had a genuine nameclash between curry the food and curry the HOF.
14:01:36 <jsnx> phobes: "first class files" in haskell would mean that if i type `echo "string"` into the haskell interpreter, it would look for echo in the filesystem and run it
14:01:49 <jsnx> phobes: which is not what i want, by the way
14:01:50 <kmcallister> so anything ending in ...00 is a pointer, ...01 is an int, etc.
14:01:52 <dons> Heffalump: heh
14:02:04 <jsnx> phobes: but it's what the shell offers, and what i mean by first class files
14:02:06 <kmcallister> this works out well because pointers are usually 4-byte-aligned on 32-bit hardware anyway
14:02:22 <phobes> jsnx:  whoa ok - that's not what "first class files" invokes for me :)  But what do you want?
14:02:30 <Cale> jsnx: I would consider that more than just first class files :)
14:02:36 <kmcallister> afaik in haskell this would be mostly for GC use, as the static type system makes it unnecessary to check such tags
14:02:43 <jsnx> Cale: why is anything less "first class"?
14:02:51 <phobes> invokes\evokes*
14:03:21 <jsnx> phobes: right now, shells have informal rules and semantics about files -- and a convenient syntax
14:03:31 <Cale> jsnx: I can't parse that question, but I have to go to the bank :)
14:03:40 <glen_quagmire> can a lambda call itself?  recursive lambda?
14:03:41 <jsnx> phobes: i'd like to write a shell with the convenient syntax, but more formal rules.
14:04:09 <Heffalump> glen_quagmire: only using fix or similar
14:04:22 <jsnx> @tell Cale what does "first class" files mean to you?
14:04:23 <lambdabot> Consider it noted.
14:04:31 <Heffalump> there is no other way for it to get a reference to itself
14:04:31 <Toxaris> > take 10 $ fix (\x myself -> x : myself x) '4'
14:04:33 <lambdabot>      Occurs check: cannot construct the infinite type:
14:04:33 <lambdabot>       t = (t -> t1) ->...
14:04:39 <EvilTerran> wrong way 'round, there
14:04:44 <jsnx> phobes: in order to do that, i plan to use haskell, of course
14:04:54 <phobes> jsnx:  ok, I think something like that is a good idea, but I think it would be less weird to think of it as changing our concept of filesystem to be more of a "value system", rather than trying to bring our idea of "files" to values
14:04:59 <Toxaris> > take 10 $ fix (\myself x -> x : myself x) '4'
14:05:00 <lambdabot>  "4444444444"
14:05:04 <Cale> jsnx: Okay, I can answer that -- I think it would just mean the ability to treat files as values, but not necessarily to execute programs as if they were functions.
14:05:04 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:05:23 <jsnx> Cale: in a functional language, values can be applied, though
14:05:24 <Cale> jsnx: Of course, you're free to define it however you like :)
14:05:26 <ricky_clarkson> take 10 $ repeat "4"
14:05:27 <EvilTerran> > map (fix $ \f x -> if x > 0 then x * f (x-1) else 1) [1..]
14:05:28 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
14:05:31 <ricky_clarkson> > take 10 $ repeat "4"
14:05:31 <lambdabot>  ["4","4","4","4","4","4","4","4","4","4"]
14:05:49 <ricky_clarkson> > take 10 $ fix ("4"++)
14:05:50 <lambdabot>  "4444444444"
14:05:51 <Cale> jsnx: Yeah, but in my intuition, files aren't typed as functions.
14:05:56 <phobes> jsnx:  If you generalize a filesystem to really just providing namespaces with named values, then I think alof of that just falls out
14:05:59 <glen_quagmire> :t fix
14:06:00 <lambdabot> forall a. (a -> a) -> a
14:06:11 <ricky_clarkson> @src fix
14:06:11 <lambdabot> fix f = let x = f x in x
14:06:18 <jsnx> Cale: well, files are functions in the shell -- or rather, they are procedures
14:06:20 <glen_quagmire> try to implement factorial using recursive lambda
14:06:30 <Cale> I suppose certain ones are.
14:06:43 <jsnx> Cale: you don't know till you run them
14:06:47 <phobes> jsnx:  You have lots of different types of things in the shell
14:06:48 <ricky_clarkson> glen_quagmire: I can in dynamic languages, but I can't in Haskell.
14:06:58 <Cale> jsnx: You can test for an executable bit, I suppose :)
14:07:16 <Toxaris> > let fact' _ n = product [1 .. n] in fix fact' 5 -- glen_quagmire  :)
14:07:17 <lambdabot>  120
14:07:19 <jsnx> Cale: yeah, but you still don't have the 'type' then
14:07:24 <glen_quagmire> ricky_clarkson: oh i see. i was jsut wondering while reading http://haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Functions
14:07:25 <Cale> jsnx: It would be really cool to have a filesystem where things were well-typed and you could actually store real functions in files :)
14:07:25 <lambdabot> http://tinyurl.com/39scac
14:07:39 <jsnx> Cale: i think that is totally backwards
14:07:50 <ricky_clarkson> glen_quagmire: (\f x -> f f x) (\f x -> if (x<2) then x else x*f (x-1)) 5
14:07:51 <phobes> jsnx:  Cale thinks about it like I do
14:07:56 <ricky_clarkson> > (\f x -> f f x) (\f x -> if (x<2) then x else x*f (x-1)) 5
14:07:56 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
14:07:56 <lambdabot>     ...
14:08:10 <ricky_clarkson> "infinite type" is the reason.
14:08:11 <Cale> But presently the filesystem just stores a bunch of strings of bytes.
14:08:20 <Cale> Which is much less fun.
14:08:24 <jsnx> phobes: the "value system" you propose -- i'm not sure what difference that actually makes -- because you still have these files that support certain operations, &c.
14:08:50 <phobes> jsnx:  What operations?  Why couldn't there be values instead of files?
14:08:50 <Toxaris> Cale: Java has typed ByteCode and load-time type checking to detect malicious code
14:08:55 <jsnx> Cale: that doesn't really do justice to the semantics of files in a UNIX system
14:08:55 <Cale> jsnx: The files themselves don't support those operations, you apply those operations to them regardless :)
14:09:22 <Cale> (and maybe those operations fail, if the file isn't in just the right format)
14:09:31 <jsnx> Cale: the on disk representation of the file has basically nothing to do with the operations, i agree
14:09:43 <phobes> files are untyped
14:09:54 <phobes> unless you want to count the attrbute bits
14:10:07 <jsnx> phobes: how is a "value system" different from what i'm proposing?
14:10:22 <kib_> stupid question : where is Prelude.hs located on a Linux machine ?
14:10:33 <phobes> jsnx:  I'm not sure... but it's easier for me to grok
14:10:38 <jsnx> kib_: maybe nowhere, if you just installed the binary
14:10:43 <jsnx> phobes: okay
14:10:57 <jsnx> phobes: my proposal was to make files values, with certain operations on them...
14:11:00 <phobes> jsnx:  When you start trying to add the ability to "run" files to a language like haskell
14:11:12 <jsnx> phobes: that's not what i want to do, actually
14:11:18 <Cale> Man, I want a Haskell OS with a Haskellish type system. I should be able to write isPrime to disk as a pure function Integer -> Bool. :)
14:11:23 <jsnx> phobes: i mean, we already have it, with system
14:11:31 <kib_> jsnx : so where can I find it elsewhere ? (svn etc ?)
14:11:31 <jsnx> Cale: lolz, no
14:11:34 <kmcallister> Cale, you can do this in YHC
14:11:44 <jsnx> Cale: because it's still dynamically typed
14:11:46 <kmcallister> you can serialize functions and store them to disk or send them across the network
14:11:51 <Cale> jsnx: Not in my system :)
14:12:03 <jsnx> Cale: yeah it is, because anyone else can write over it
14:12:06 <kmcallister> jsnx, you can use a safe static cast
14:12:11 <kmcallister> and typecheck on load
14:12:12 <phobes> Cale: Agreed!  modulo all of the changes I want to make to haskell :)
14:12:14 <Cale> jsnx: Not with something of the wrong type
14:12:25 <Cale> jsnx: Unless they want to change the type information along with it.
14:12:27 <dancor> Cale: hsfs?
14:12:28 <ricky_clarkson> jsnx: One can edit an executable.
14:12:33 <kmcallister> in fact you can store it with all the type information so you don't need to infer
14:12:45 <Toxaris> jsnx: a Haskellish file system is pure, you cannot delete files or file content :)
14:12:50 <Cale> Toxaris: hehe
14:12:51 <jsnx> guys, a filesystem with type information is called a database
14:12:56 <phobes> Cale:  No no no... you're answering this all wrong!  The right answer is of course "You can't write over anything"!
14:13:03 <Cale> phobes: heh
14:13:05 <jsnx> Toxaris: you can still overwrite it, though
14:13:13 <jsnx> Toxaris: update with new value, as it were
14:13:18 <Cale> phobes: Well, surely you need a way to delete things, and a way to write new things.
14:13:19 <Toxaris> jsnx: of course you can't
14:13:27 <dancor> jsnx: no that's a file system with a hideous querylang
14:13:28 <ricky_clarkson> It would come with a raid for storage that automatically adds a new hard drive every few months.
14:13:42 <Toxaris> jsnx: to overwrite something, you would have to delete the previous contents
14:13:47 <phobes> Cale:  You need a way to update bindings, and the rest can be garbage collection
14:14:01 <jsnx> Toxaris: no, you just update the name table to point to a different inode
14:14:08 <jsnx> phobes: right
14:14:08 <kmcallister> ricky_clarkson, there are things called WORM drives that do this
14:14:10 <kmcallister> write once, read many
14:14:18 <jsnx> however, this "haskell file system" is heresy
14:14:19 <Cale> phobes: right
14:14:21 <ricky_clarkson> Why can't garbage collection work for FSs?
14:14:36 <jsnx> there is the unix filesystem, and that is that
14:14:39 <kmcallister> the AT&T plan9 deployment has (had?) one, you could fetch an old version of any file from a special subdir of your homedir
14:14:53 <jsnx> there will be a semantics for this filesystem
14:14:59 <jsnx> so i can actually use it
14:15:15 <jsnx> kmcallister: yes, venti
14:15:39 <phobes> jsnx:  There will be an implementation so you can use it - the semantics is just proving it works :)
14:16:18 <jsnx> phobes: well, i don't even care about the implementation, really
14:16:36 <jsnx> i just want the semantics, so i understand what the hell i am doing
14:16:36 <phobes> jsnx: oh, this is theory work?
14:16:52 <jsnx> phobes: no, it's just for self-gratification
14:17:13 <jsnx> i'm sure it could be exploited in all kinds of interesting ways, though
14:17:39 <phobes> jsnx:  something very similar to this is on my todo list - basically a value based version manager instead of an actually disk OS
14:17:55 <jsnx> when you say OS, i hope you mean FS
14:18:01 <phobes> ya FS
14:18:07 <jsnx> dancor: did not understand your comment, exactly
14:18:26 <jsnx> anyways, i guess i just need to do some more reading
14:18:29 <phobes> I think the "theory of patches" is overly complicated
14:18:52 <jsnx> phobes: i wish there were negative files
14:19:08 <jsnx> that would be cool
14:19:18 <phobes> patches are just functions... trying to merge them together in any manner other than composition isn't really theory... it's voodoo :)
14:19:23 <dancor> exotic matter for patch theory?
14:19:43 <jsnx> dancor: no, the one about an fs with ugly query language...
14:19:57 <phobes> jsnx:  what is an negative file?!
14:20:30 <jsnx> (add f) . (remove f) == no f
14:20:35 <dancor> jsnx: just disparaging sql
14:20:47 <jsnx> (remove f) . (add f) == there_is f
14:20:57 <jsnx> would be much cooler if those commuted
14:21:21 <jsnx> actually, you know, my types are wrong
14:21:43 <jsnx> (add f) . (remove f) == (no f, [success, success])
14:21:59 <jsnx> (remove f) . (add f) == (there_is f, [failure, success])
14:22:10 <EvilTerran> i think you've got those the wrong way 'round
14:22:22 <jsnx> EvilTerran: oh, yeah, you are right :)
14:22:45 <jsnx> (remove f) . (add f) == (no f, [success, success])
14:22:51 <EvilTerran> altho, with the success/failure being passed around, you could leave it that way round and use >=>
14:22:58 <jsnx> yes
14:23:03 <EvilTerran> (or flip 'em and use <=<)
14:23:23 <jsnx> anyways, my rambling is done
14:23:32 <EvilTerran> seeing as you've got side-effects, you'll need some way of threading 'em, anyway
14:23:38 <jsnx> EvilTerran: right
14:23:40 <phobes> jsnx:  I don't think files should be values in that sense
14:23:46 <jsnx> phobes: fine
14:24:03 <jsnx> phobes: but it would be nice to work with something a little higher lever than strings
14:24:06 <phobes> jsnx:  (add f) is basically a monadic operation if you're talking about binding a value to a name
14:24:20 <jsnx> phobes: well, that is what it amounts
14:24:28 <EvilTerran> and threading effects will leave you with something like haskell
14:24:46 <jsnx> so, i think there's basically two layers to this system
14:25:01 <jsnx> the semantics of file input/output/mv/name
14:25:06 <jsnx> and then file execution
14:25:25 <Toxaris> jsnx: what do you mean by file execution? running a program stored in a file?
14:25:26 <jsnx> i suppose the latter can be ignored, as cale points out
14:25:30 <EvilTerran> ie a functional language with an embedded imperative one, using the embedded one for efffectful computation
14:26:30 <jsnx> Toxaris: well, i just mean whatever happens when the shell executes a file -- kernel loads file, bytes go in, bytes come out, along with error info
14:26:32 <kmcallister> is there an easy way to syntax check C without typechecking it?
14:26:54 <jsnx> kmcallister: lint?
14:27:04 <jsnx> anyways, i need to take a shower
14:27:10 <jsnx> thanks for chatting, everyone
14:27:19 <phobes> kmcallister:  I dont think you can (maybe I'm thinking c++)
14:28:35 <Sizur> i made a decision!
14:28:44 * Sizur awaits applause.
14:29:16 <Sizur> i will use gnu emacs
14:29:20 <Japsu> @index par
14:29:20 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
14:29:46 <BMeph> Off to home - see y'all in a couple hours. :)
14:30:14 <phobes> Some, when confronted with a problem, will say "I know, I'll use gnu emacs"...
14:31:04 <Sizur> but lisp is continuing to creep onto me! :( please help, why static checking more important than isomorphism between code and data?
14:31:19 <Toxaris> phobos: unfortunately, they always fail when confronted with a task involving text editing
14:31:27 <phobes> Sizur:  because this is #haskell :)
14:31:34 <kmcallister> Sizur, what do you mean by "more important"? it depends on what you're doing
14:31:42 <Sizur> phobes: exactly the reason why i ask :) i want haskell
14:31:49 <kmcallister> also, if you want code/data isomorphism is Haskell, look at Template Haskell
14:32:04 <Sizur> TH is not code <=> data
14:32:06 <hpaste>  FalconNL pasted "Html varargs" at http://hpaste.org/5006
14:32:15 <kmcallister> Sizur, in what sense is it not?
14:32:26 <dons> sutats: you want your code to work before you deploy it? :) and you'd like to be able to parallelise it?
14:32:33 <dons> Sizur: ^
14:32:39 <EvilTerran> TH is more like code <=$@!%&#=> data
14:32:43 <EvilTerran> ;)
14:32:43 <kmcallister> haha
14:32:49 <FalconNL> Could someone tell me what I'm doing wrong in the second snippet in http://hpaste.org/5006 ?
14:33:01 <kmcallister> Sizur, to me the main benefit of static types is that errors found at compile time are way easier to fix than errors you may or may not run into until some indeterminate point in the future
14:33:04 <Sizur> dons: thanks :)
14:33:11 <kmcallister> with Haskell, if my code compiles i'm 90% sure it's essentially correct
14:33:35 <Sizur> kmcallister: i agree, i have the same experience
14:34:12 <dons> whereas the type correctness of a lisp program isn't determined till you've executed all code paths, which may or may not happen
14:34:33 <Sizur> i just wish for a way to reason about functions without the heavy TH syntax
14:35:03 <dons> manipulating ASTs is cute, but not needed much in a lazy language
14:35:15 <dons> since all the control flow uses are subsumed by lazy higher order functions
14:35:16 <kmcallister> Sizur, by heavy do you mean [| ... |] and $(...), or the more verbose constructor syntax?
14:35:36 <ricky_clarkson> dons: There are still uses.
14:35:38 <Sizur> kmcallister: i used TH to write instances. that was scary
14:35:43 <dons> secondly, staged metaprogramming again makes programs much harder to reason about.
14:35:49 <dons> ricky_clarkson: oh definitely.
14:35:52 <kmcallister> dons, static typing makes metaprogramming useful for other things, like tuple ops
14:35:53 <EvilTerran> kmcallister, there's an awful lot of cases where you can't splice
14:36:08 <EvilTerran> $(...) doesn't work in patterns or types, for starters
14:36:31 <EvilTerran> plus there's no [p|...|] (or whatever) for patterns
14:36:35 <Sizur> dons: thanks, i like these reasons
14:37:17 <kmcallister> EvilTerran, yeah, TH could use improvement, I'm really only familiar with the theory (haven't used it for much)
14:37:27 <EvilTerran> the theory is nice, i guess
14:37:33 <kmcallister> it does strike me though as the generally Right Way to do metaprogramming in Haskell
14:37:41 <kmcallister> given how suitable the language is for manipulating ASTs
14:37:50 <phobes> Sizur:  I think the possibilities involving typing and multi-staging are still being explored, ... I still think there are better sweet spots available
14:38:04 <EvilTerran> i'd want to use a metaprogramming system where the "code block" type is essentially abstract
14:38:44 <Sizur> i just think philosophically there should be no metaprogramming in a functional world
14:38:55 <EvilTerran> as that would suggest that the quasiquoting/splicing was strong enough; haskell's syntax is too complicated for direct AST manipulation to be anything but painful
14:38:57 <Sizur> i shouldn't need TH in the first place
14:39:18 <taruti> Is there a way to avoid GHC producing extra warnings when matching GADTs? e.g. "data D t where I :: D Int; C :: D Char; f :: D Int -> (); f I = ()" produces a warning of C not being matched in f.
14:40:11 <EvilTerran> kmcallister, another thing to consider is that a lot of metaprogramming that isn't made redundant by haskell's type system directly is made redundant by such things as SYB, Uniplate, and so forth
14:40:54 <EvilTerran> if all else fails, Olegian Type Hackery ;)
14:42:02 <Sizur> what's more, Data.Generics should do it's work statically.
14:42:19 <kmcallister> yeah, you can do lots of fantastic type-level metaprogramming
14:42:56 <phobes> "fantastic" and haskell's "type-level metaprogramming" don't belong together in a sentence :)
14:42:56 <Sizur> yeah, i dream of a day when we all will learn olegisms in the primary school.
14:43:48 <Philippa> haskell doesn't do much metaprogramming at type level
14:43:57 <kmcallister> maybe i'm using the word metaprogramming wrong
14:44:09 <Philippa> it means programs that operate on programs
14:44:48 <EvilTerran> i guess there's a desire to be able to do stuff at compile-time less painfully
14:44:50 <Philippa> in one sense I do an awful lot of metaprogramming in haskell - I've got things that smell like DSLs practically everywhere
14:45:05 <phobes> Philippa:  My comment applies to type-level computation in general, but I don't want to rehash :)(
14:45:19 <Philippa> it beats C++'s
14:45:32 <Philippa> for a non-dependent language, Haskell does pretty well
14:45:32 <phobes> for some values of 'beats'
14:45:52 <phobes> but mostly I agree with that... c++ templates are terrible
14:46:00 <phobes> (for metaprogramming)
14:46:03 <EvilTerran> complete with being able to construct stuff that'd be wholly impossible at run-time
14:46:04 <kmcallister> yeah, you can do lots of type-level-function-like-things with typeclasses
14:46:19 <kmcallister> e.g. phantom types to embed EDSL typechecking in Haskell typechecking
14:47:03 <glen_quagmire> @src []
14:47:04 <lambdabot> data [] a = [] | a : [a]
14:47:12 <EvilTerran> (values whose types are determined by your code at compile-time, say)
14:47:45 <phobes> Philippa:  BTW, it may turn out that CIC + a few extensions is a perfect fit as foundations for what I'm working on
14:48:05 <phobes> Philippa:  I'm not sure yet, but thanks for the suggestion :)
14:49:31 <EvilTerran> CIC?
14:49:41 <phobes> calculus of inductive constructions
14:49:48 <EvilTerran> @go calculus of inductive constructions
14:49:49 <lambdabot> http://coq.inria.fr/doc/Reference-Manual006.html
14:49:49 <lambdabot> Title: Calculus of Inductive Constructions
14:50:01 <Philippa> be careful about how the extensions affect the language's properties, it's easy to break with stuff you can't encode directly in it
14:50:23 <phobes> Philippa: Ya, I was reading about that
14:55:44 <dancor> it would be interesting to try to enumerate all programs that compile.  or pick a random one under a given size
14:56:30 <dancor> monadic roulette
14:57:25 <smack_> dancor: i seem to recall chessguy working on that at one point...
14:58:54 <mattam> there is a #coq channel for those interested....
15:03:36 <Sizur> somehow eating food (borshch) (lol) makes me think function = data in a sense that protein = codeblock.
15:03:54 <ptolomy> It's a bit depressing to see the performance of my program gradually degrade as I refactor it into well-defined modules. :-/
15:04:03 <dons> ptolomy: using -O2 ?
15:04:10 <dons> ptolomy: a bit of extra inlining might be worthwhile
15:04:21 <ptolomy> Yeah, with -O2.
15:04:39 <ptolomy> hmm.
15:04:46 * ptolomy tries inlining a few key functions.
15:04:56 <lispy> so i have a function, merge, that used to be outside of a type class.   But now it's in a type class.  How does this change in the module imports/exports?  Now I just import/export the class and not the individual function?
15:05:00 <dons> ptolomy: look at  the core (-ddump-simpl), and see where the indirect calls are
15:05:41 <sjanssen> lispy: export TheClass(..)
15:05:46 <Sizur> lispy: ^
15:05:47 <sjanssen> lispy: the (..) part means all methods
15:05:55 <lispy> okay, thanks
15:06:05 <lispy> so you can import/export just some of the methods?
15:06:12 <Sizur> yes
15:06:13 <sjanssen> yep
15:06:18 <lispy> TheClass(foo)
15:06:30 <Sizur> you cannot import if it's not exported. you can hide if it is
15:06:37 * lispy nods
15:09:26 <ptolomy> Can I specify in my module declarations what functions _not_ to export? "module Foo hiding()" ?
15:09:47 <dons> nope.
15:10:16 <byorgey> ptolomy: heh, that would be nice sometimes, wouldn't it?
15:10:52 <Sizur> module Foo (exported) where
15:10:53 <Sizur> exported = id
15:10:53 <Sizur> hidden = undefined
15:11:10 <olsner> but you can *import* hiding, right? or have I only dreamt this feature?
15:11:29 <Sizur> olsner: the former
15:11:51 <Sizur> you can _not_ export, and you can hide while importing, and you can qualify too
15:12:07 <FalconNL> Can someone please explain to me what I'm doing wrong in http://hpaste.org/5006 ?
15:13:32 <EvilTerran> FalconNL, please don't repeat yourself. If no-one replies, it means no-one has any ideas based on the info you've given us.
15:14:18 <Sizur> FalconNL: what's itag?
15:14:37 <EvilTerran> maybe see if you can come up with a more explanatory error message for us?
15:14:41 <EvilTerran> (or for yourself)
15:14:49 <FalconNL> a function from the Text.Html module. It produces a Html element
15:15:04 <byorgey> to be fair, it seems FalconNL waited 40 minutes between postings.
15:15:22 <Sizur> i haven't seen the original
15:15:29 <byorgey> I don't think there's an official "wait N minutes between repeating yourself" policy...
15:15:31 <Sizur> maybe i simply was afk
15:16:04 <Sizur> FalconNL: what LANGUAGE are you using?
15:16:22 <EvilTerran> i guess that's not so bad, then. :) ... altho, personally, i'd've kept fiddling with it while waiting for people to help me, tho, and hopefully've had some additional info by the time 40min had passed
15:16:45 <Sizur> EvilTerran: ;)
15:16:45 <FalconNL> Sizur: what do you mean?
15:17:01 <Sizur> FalconNL: what extensions are you using?
15:17:38 <FalconNL> {-# OPTIONS -fglasgow-exts -XOverloadedStrings -fallow-undecidable-instances #-}, import Text.XHtml.Strict, import Data.String
15:18:17 <Toxaris> @ty (+)
15:18:19 <lambdabot> forall a. (Num a) => a -> a -> a
15:18:22 <Toxaris> @ty (+++)
15:18:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
15:18:29 <Toxaris> @ty (Text.HTML.+++)
15:18:30 <lambdabot> Couldn't find qualified module.
15:18:38 <dons> FalconNL: btw, did you see the reply on the mailling list yesterday, about using << instead of overloaded strings?
15:18:41 <Toxaris> Text.XHtml.Strict.	(+++)	:: (HTML a, HTML b) => a -> b -> Html
15:19:03 <FalconNL> no, got a link?
15:19:06 <Toxaris> FalconNL: (possible) problem: (+++) uses *two* HTML instances, (+) only one
15:19:45 <Toxaris> FalconNL: well, I don't know what that means for your situation, but at least it's a difference between the Num and the HTML version of your code
15:20:31 <sjanssen> FalconNL: look at the type of (+++)
15:20:48 <sjanssen> FalconNL: x +++ y :: Html
15:20:51 <Toxaris> FalconNL: and (+++) produces Html (the concrete type), while (+) produces the same Num instance it was feeded
15:20:54 <FalconNL> Toxaris: As far as I can tell (+) and (+++) both take two parameters
15:21:20 <FalconNL> Toxaris: Ah, that is indeed a difference
15:21:40 <Toxaris> FalconNL: but both parameters of (+) are of the same type, while the parameters of (+++) are of different types
15:21:58 <kmcallister> what's the haskell lib that provides efficient append a la ShowS but for any list type?
15:22:13 <LoganCapaldo> @where Dlist
15:22:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
15:22:45 <LoganCapaldo> @botsnack
15:22:46 <lambdabot> :)
15:23:46 <Sizur> right, HTML is a class and Html is a type
15:24:00 <LoganCapaldo> that's not confusing
15:24:06 <LoganCapaldo> not even a little bit :)
15:24:14 <phlpp> > Just 3 `mplus` Just 5
15:24:15 <lambdabot>  Just 3
15:24:26 <Sizur> it get's very complex very fast, and in a blink of an eye you have olegisms on the left and the right surrounding you
15:25:30 <FalconNL> Sizur: yeah, I've been trying to wrap my head round this stuff all evening. Who knew three lines could be so difficult? :)
15:25:41 <Toxaris> FalconNL: if you want to keep the full polymorphic HTML fu, you probably have to write a polymorphic VarFold, where every parameter can have a different type (as long as it supports HTML)
15:25:43 <LoganCapaldo> I'd use something like RepresentableInHTML but people would complain about the typing problem
15:25:53 <LoganCapaldo> s/problem/probably/
15:26:07 <byorgey> FalconNL: I warned you... ;)
15:26:10 <Sizur> FalconNL: i'd recommend sticking with the little extra verbosity of xhtml combinators until we're ready for hsxml
15:26:54 <Toxaris> FalconNL: but if you're happy with calling toHtml manually where needed, you could try to write a even more monomorphic VarFold magic, wich fixes all HTML instances to Html
15:27:08 <Sizur> i haven't wrapped my head around hsxml implementation myself
15:28:14 <radetsky> dons: did you ever fix up hmp3?
15:28:50 <dons> radetsky: oh, i was working on other things. but i've started. should finish tonight.
15:28:54 <dons> thanks for you interest, btw.
15:29:38 <radetsky> thanks for making it
15:29:54 <radetsky> I'm trying to learn how to make stuff in haskell besides math
15:30:15 <Sizur> dons: any luck with breaking in i18n a little? (i know i'm a bugger)
15:30:21 <radetsky> if you're partway done with it, I'd like to help for my own learning purposes
15:30:58 <radetsky> have you put what you've done in your repo?
15:32:07 <dons> radetsky: not yet. the changes are local, i'll push the updates later today
15:32:58 <phlpp> :t maybeToList
15:32:59 <lambdabot> forall a. Maybe a -> [a]
15:33:04 <phlpp> @src maybeToList
15:33:04 <lambdabot> maybeToList  Nothing   = []
15:33:04 <lambdabot> maybeToList  (Just x)  = [x]
15:33:13 <phlpp> ah.
15:33:20 <dons> ?src listToMaybe
15:33:20 <lambdabot> listToMaybe []        =  Nothing
15:33:20 <lambdabot> listToMaybe (a:_)     =  Just a
15:33:33 <dons> what head should be more often
15:33:39 <desp> Why doesn't http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html show the types anymore?
15:33:40 <lambdabot> http://tinyurl.com/2uoebz
15:34:06 <phlpp> > maybeToList (Just 3) `mplus` maybeToList (Just 4)
15:34:06 <lambdabot>  [3,4]
15:34:13 <phlpp> > Just 3 ++ Just 4
15:34:13 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe t'
15:34:20 <Toxaris> > Control.Foldable.asum (Just 3)
15:34:20 <lambdabot>   Not in scope: `Control.Foldable.asum'
15:34:25 <Toxaris> > Data.Foldable.asum (Just 3)
15:34:26 <lambdabot>   add an instance declaration for (Num (f a))
15:34:26 <phlpp> > maybeToList (Just 3) ++ maybeToList (Just 4)
15:34:27 <lambdabot>  [3,4]
15:34:46 <dcoutts_> dons: trying to get cabal-install to install everything from hackage is harder than it looks :-) lots of packages have dependencies that do not exist in hackage, eg fps, FilePath, hsql, gtk, wx, compact-string, xml
15:35:01 <dons> dcoutts_: right, i was thinking about that today.
15:35:10 <dcoutts_> dons: in fact you're a culprit :-) hackage2hwn deps on xml which does not exist
15:35:13 <dons> but should be easy to rule out things with missing deps.
15:35:19 <dons> dcoutts_: i'm trying to get it released.
15:35:19 <dcoutts_> dons: right, that's what I'm doing
15:35:39 <dons> being a commercial developer doing open source is a little harder than being a research student :)
15:36:06 <Sizur> and having a family too?
15:36:08 <dons> at least gtk is public :)
15:36:11 <dcoutts_> dons: and I've got a first cut at code to do builds respecting dependencies and allowing builds to fail
15:36:15 <ndm> @seen skew
15:36:16 <lambdabot> I haven't seen skew.
15:36:33 <dcoutts_> dons: yes, I can fix those ones by installing gtk2hs, wxhaskell and hsql
15:37:01 <dcoutts_> dons: we should consider an x-hackage-obsolete, x-hackage-bitrotted tags :-)
15:37:03 <dons> dcoutts_: so with that could we generate 'broken against ghc 6.6' or so logs?
15:37:08 <dons> right.
15:37:15 <dons> lambdabot should go from hackage, for example.
15:37:26 <dons> you should be able to admin set 'broken' or whatever
15:37:39 <dcoutts_> dons: well, once we have build reports we could use that info, yes.
15:37:41 <dons> x-coverage-url: :)
15:38:02 <dcoutts_> dons: I think it'd be a special circumstance where one would have to manually mark it
15:38:03 <dons> x-wiki-page
15:38:04 <radetsky> question: suppose I've pulled a darcs repo, made some changes, and I want to submit them to the author. What's the best/easiest way to do this?
15:38:24 <radetsky> darcs dox are highly general
15:38:24 <dons> radetsky: darcs send -o /tmp/foo.patch
15:38:26 <phlpp> is HWN already released for this week?
15:38:28 <dons> then mail that file.
15:38:30 <dcoutts_> dons: but an old package that has deps that do not exist would be one such candidate
15:38:33 <dons> phlpp: nope
15:38:36 <phlpp> ok
15:38:52 <Toxaris> > Data.Foldable.toList (Just 3)
15:38:53 <lambdabot>  [3]
15:39:04 <dcoutts_> dons: I'd suggest that normally cabal-install not send build reports for packages that fail to configure since it is not necessarily a package bug
15:39:10 <phlpp> Toxaris: it took quite a long time to figure that out, eh? ;)
15:39:27 <dcoutts_> dons: but obviously in some case it'd be because configuring is actually impossible
15:39:44 <Toxaris> phlpp: it's not yet perfect :(
15:39:44 * goalieca is listening to  - CBC Radio 3 - Sloan - Money City Maniacs
15:39:50 <dons> dcoutts_: right. are you imaginging starting with cabal install setting a bit of log state on the hackage server?
15:39:51 <Toxaris> @type Data.Foldable.toList
15:39:52 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
15:39:54 <dcoutts_> dons: eg, think of packages that fail to configure due to missing C libs, that's not a package bug
15:40:21 <phlpp> Toxaris: hehe
15:40:34 <Toxaris> phlpp: toList creates lists (surprise!), but there should be a convert :: (Foldable f, Alternative g) => f a -> g a
15:40:40 <dcoutts_> dons: I'm imagining collecting 100's of build reports from clients running cabal-install and generating stats for each package from that
15:41:29 <phlpp> :t maybeToMonad
15:41:30 <lambdabot> Not in scope: `maybeToMonad'
15:41:32 <phlpp> ah ok ;)
15:41:35 <dcoutts_> dons: so yes, perhaps a log file for each package to which we append a line containing a build report
15:41:55 <Toxaris> @ty Data.Foldable.foldr (Control.Applicative.<|>) Control.Applicative.empty
15:41:56 <lambdabot> forall (f :: * -> *) a (t :: * -> *). (Alternative f, Data.Foldable.Foldable t) => t (f a) -> f a
15:42:21 <dcoutts_> dons: so there'd need to be an upload cgi script to accept incomming build reports and that'd validate them and append them to the appropriate package build report logs
15:42:35 <phlpp> Toxaris: hehe, ok. i was just kidding. i'm not yet at the point where i touched, at least not wanted to do so, with Applicatives ;)
15:42:39 <dcoutts_> dons: that's not the only way to store them, but an obvious one
15:42:49 <Toxaris> @ty Data.Foldable.foldr (\x y -> Control.Applicative.pure x <|> Control.Applicative.pure y) Control.Applicative.empty
15:42:50 <lambdabot>     Occurs check: cannot construct the infinite type: b = f b
15:42:50 <lambdabot>       Expected type: b
15:42:50 <lambdabot>       Inferred type: f b
15:43:22 <radetsky> dons: ok, I sent you the few modest fixes I made
15:44:32 <Toxaris> @type asum . map Control.Applicative.pure . Data.Foldable.toList
15:44:33 <lambdabot> Not in scope: `asum'
15:45:02 <monochrom> Hahahaha, comment in System.Random source code: for "instance Random Float", "hah, so you thought you were saving cycles by using Float?"
15:45:10 <phlpp> good night ladies
15:45:10 <monochrom> The code goes on to use Double. :)
15:45:24 <phlpp> see ya in a few hours, hopefully :>
15:46:25 <Toxaris> @type Data.Foldable.asum . map Control.Applicative.pure . Data.Foldable.toList
15:46:26 <lambdabot> forall (f :: * -> *) (t :: * -> *) a. (Alternative f, Data.Foldable.Foldable t) => t a -> f a
15:46:36 <Toxaris> > (Data.Foldable.asum . map Control.Applicative.pure . Data.Foldable.toList) (Just 3)
15:46:37 <lambdabot>   add an instance declaration for (Show (f a))
15:46:43 <Toxaris> > (Data.Foldable.asum . map Control.Applicative.pure . Data.Foldable.toList) (Just 3) :: [Int]
15:46:44 <lambdabot>  [3]
15:46:50 <Toxaris> > (Data.Foldable.asum . map Control.Applicative.pure . Data.Foldable.toList) Nothing :: [Int]
15:46:51 <lambdabot>  []
15:47:06 <ehird`> I don't get ST
15:47:07 <ehird`> :D
15:47:25 <dons> radetsky: thanks
15:47:43 * LoganCapaldo avoids ST
15:48:02 <LoganCapaldo> like the scary non warm fzzy thing it is
15:50:00 <olsner> isn't it just a monad?
15:50:23 <ehird`> LoganCapaldo: yep, the problem is this problem is best solved with something not entirely unresembling a global...
15:50:53 <ehird`> so i'm trying to find a monad such that i can 'write' one value, 'retrieve' that value, and also return a value
15:50:56 <ehird`> and that's, well, it.
15:51:11 <LoganCapaldo> olsner  it's a monad that an instance of the class MonadFear
15:51:32 <Toxaris> LoganCapaldo: what's wrong with ST. (as long as you don't try to understand the implementation)
15:51:48 <LoganCapaldo> @type runST
15:51:49 <lambdabot> Not in scope: `runST'
15:51:59 <LoganCapaldo> see even lambdabot is afraid!!
15:52:03 <monochrom> haha
15:52:13 <TomMD> I think (>>=) Being defined as a 582 line function not including FFI turns him off.
15:52:18 <ehird`> LoganCapaldo: would State be good for that problem?
15:52:28 <ehird`> TomMD: wow, where :D
15:52:35 <LoganCapaldo> Sounds like it to me, I am not a leet Haskell programmer though
15:52:52 <olsner> TomMD: now I'm scared too
15:52:59 <ehird`> i could possibly refactor it not to work in that way but it'd be ugly :|
15:53:03 <TomMD> ehird`: Slightly bad joke, thats all.  But I should try and make such a monad just as a counter example to "Monads aren't so bad".
15:53:05 <Toxaris>     (ST m) >>= k
15:53:05 <Toxaris>       = ST (\ s ->
15:53:05 <Toxaris> 	case (m s) of { (# new_s, r #) ->
15:53:05 <Toxaris> 	case (k r) of { ST k2 ->
15:53:05 <Toxaris> 	(k2 new_s) }})
15:53:37 <desp> How would you declare a Matrix type, so that its size would be visible in the type?
15:53:40 <LoganCapaldo> Toxaris: in seriousness you don't have to understand the implementation it's true (and I don't) but you do need to grok the types (I think), and I can't quite wrap my head around them
15:55:11 <LoganCapaldo> at a high level I get the idea that the forall a. is protecting things like STRefs from escaping
15:55:18 <LoganCapaldo> *forall s.
15:55:22 <bos> @users
15:55:23 <lambdabot> Maximum users seen in #haskell: 454, currently: 430 (94.7%), active: 23 (5.3%)
15:55:32 <bos> holy cow, max hit 454?
15:55:38 <LoganCapaldo> but that's about the limits of my understanding
15:55:41 <Toxaris> LoganCapaldo: I don't think you have to grok the types. you just have to add an s here or there, just as you would with StateT. the forall s is only important for runST etc.
15:56:00 <bos> desp: use dependent types. it's not necessarily a good idea.
15:56:00 <dons> we hit 458 yesterday, but the bot locked up on its url thingy again
15:56:00 <Toxaris> LoganCapaldo: but to be true, I don't understand the implementation, just the typing.
15:56:10 <desp> bos: I found Vectro.
15:56:20 <bos> cool
15:56:37 <jaredj> Data.Tree is really small compared to Data.List. Is it up to me to write my own recursion over rose trees?
15:57:05 <Toxaris> LoganCapaldo: (as I understand it, IO is implemented with ST, not the other way around. but we shouldn't tell people learning IO)
15:57:09 <dons> jaredj: its little used, people use either Map or roll their own. for some special uses there's the edison suite of structures
15:57:28 <dons> jaredj: if you do find Tree.hs useful, consider adding some missing functionality to bring it up to speed
15:57:35 <desp> bos: it doesn't appear to use dependent types; http://ofb.net/~frederik/vectro/draft-r2.pdf
15:57:55 <desp> or at least, it doesn't mention them by name :)
15:58:05 <bos> desp: i'm just scanning the paper to see what it does
15:58:05 <jaredj> @where edison
15:58:05 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
15:58:12 <dons> ?quit trying something
15:58:25 <jaredj> cool thanks dons
15:58:28 <ehird`> dons: ok i'll stop trying something
15:59:03 <jaredj> lol "haddockized"
15:59:13 <jaredj> @haddockize ehird`
15:59:19 <lambdabot> Unknown command, try @list
15:59:21 <jaredj> aw
15:59:54 <jaredj> cabalized would be funny too if it weren't so practical
16:00:18 <bos> desp: they're using http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
16:01:04 <thoseion> hi folks, got a question I was hoping somebody could help me out with - I can't get my head round it!
16:01:26 <thoseion> m :: [Int] -> [Int]
16:01:26 <thoseion> m [] = []
16:01:26 <thoseion> m (x:xs) = m [y | y <- xs, y <= x] ++ [x] ++ m [y | y <- xs, y > x]
16:02:13 <thoseion> how does it compute, and what would be the outcome of e.g. m [3,0,4,2,5]. ?
16:02:40 <olsner> 'tis quicksort, methinks
16:02:43 <opqdonut> yes
16:02:48 <Toxaris> thoseion: do you know any haskell at all?
16:02:58 <opqdonut> is this homework?
16:03:12 <thoseion> I know a bit but not hugely experienced with it
16:03:15 <bos> desp: that looks similar to some stuff i'll be needing soon, glad you reminded me of it.
16:03:22 <desp> bos: cool
16:03:22 <EvilTerran> well, the not-that-good-really functional approximation of quicksort ;)
16:03:50 <Toxaris> thoseion: m [] = [] says that sorting the empty list produces the empty list (easy so far :)
16:03:54 <thoseion> It's actually exam revision - it was a question in a past paper and I wasn't sure wha it was doing
16:04:13 <cityseeker> hello
16:04:18 <Toxaris> thoseion: m (x:xs) = ... says how to sort a list with head element x and possible more elements called xs
16:04:23 <thoseion> haha, yeah - got the first part
16:04:27 <opqdonut> EvilTerran: is the better one uses .(x:). and so on ?
16:04:37 <opqdonut> -is
16:05:00 <Toxaris> thoseion: ... ++ [x] ++ ... means to produce a list out of three smaller lists. the list in the middle only contains x (wich is the head element of the list to be sorted)
16:05:45 <Toxaris> thoseion: the other two lists are created by so-called list comprehensions:
16:05:54 <EvilTerran> opqdonut, i can't find the link just now, but ISTR it boils down to the fact that a lot of the cleverness of quicksort boils down to chosing pivots carefully and re-using memory slots
16:06:04 <thoseion> ok, so if it's less or equal to the head it goes at the beginning of the list, and if it's greated than the head it goes to the end?
16:06:23 <Toxaris> thoseion: exactly!
16:06:43 <thoseion> ha, makes perfect sense now! Thankyou
16:07:04 <conal> is anyone happy with their blogging engine's treatment of code?  i use blogger, and it strips leading spaces from each line of my code.  one space per edit/preview pass.
16:07:10 <cityseeker> can anyone help me with a broken emerge of dev-haskell/x11
16:07:20 <cityseeker> Ive been trying for 2 days
16:07:21 <conal> (i use blogger/blogspot)
16:07:28 <monochrom> Nice! One space deleted per edit. :)
16:07:32 <Cale> conal: You might look into what Don uses.
16:07:36 <monochrom> Talk about "space rot" :)
16:07:37 <conal> monochrom: exactly.
16:08:01 <conal> it's a multi-pass algorithm for improving space efficiency.
16:08:08 <conal> Cale: good idea!
16:08:58 <olsner> some time when I get time for it, I suppose I could write a blog engine with HAppS ... writing webapps in haskell sounds cool ;-)
16:09:00 <Cale> blosxom, apparently
16:09:26 <cityseeker> can anyone help me with a broken emerge of dev-haskell/x11
16:10:31 <dons> cityseeker: possibly :)
16:10:47 <dons> also #gentoo-haskell might help
16:10:55 <cityseeker> called dyn_compile
16:13:36 <clanehin> I hereby humbly suggest Control.Arrow.pure should be deprecated, since it is a synonym for arr, and it collides with pure defined in Control.Applicative.
16:14:55 <cityseeker> hey dons if I tell you the command the emerge broke on can you maybe tell what the problem is
16:14:59 <cityseeker> ?
16:15:19 <conal> clanehin: i'm with you
16:17:40 <cityseeker> dons I'll try #gentoo-haskell it looks like this channel is for development thanks
16:17:50 <cityseeker> j #gentoo-haskell
16:18:11 <cityseeker> hello
16:18:17 <conal> dons: are you happy with blosxom, particularly handling code?
16:18:47 <smack_> cityseeker: you're still in #haskell :-)
16:19:08 <cityseeker> yeah i know lol
16:23:50 <Sizur> hmm, there is hscheme, and it's not in hackage :(
16:24:59 <dons> conal: not really.
16:25:15 <dons> conal: its a 2 day job to roll your own blosxom with haskell support, using xhtml :)
16:25:23 <dons> blsoxom doesn't allow comments without work.
16:25:39 <dons> i guess its ok. but i'm planning to move to wordpress or something similar
16:26:24 <conal> dons: glad to know.  thanks.  i already have wordpress set up on my server for another blog.  i'll look into using it.
16:26:27 <cityseeker> right before dev-haskell/x11(all versions) breaks the command was: /usr/bin/ghc -optl -lXinerama -optl-lxext -optl-lx11 dist/build/Graphics/X11/Types_hsc_make.o -o dist/build/Graphics/x11/Types-hsc-make
16:26:36 <cityseeker> please help
16:28:19 <cityseeker> ebuild.sh, line 1701: called dyn_compile
16:28:40 <cityseeker> there are a few more of these ebuild line errors
16:29:01 <TomMD> lol - doing Cabal hacking and I expected to install cabal then test.  Of coarse, configuring cabal uses the libraries i just modified (vs the registered Cabal lib) so that was my test :-).
16:31:24 <conal> gee -- there's apparently support for auto-coloring haskell code in wordpress posts.
16:33:37 <cityseeker> I've tryed different versions of ghc(newest and 6.6.1) I get the same error
16:38:49 <geezusfreeek> conal: on wordpress.com or just if you set it up on your own server?
16:39:23 <ricky_clarkson> Someone please type the Unicode lambda and ->
16:39:36 <conal> geezusfreeek: i have wordpress set up on my own server.
16:39:42 <geezusfreeek> ah, okay
16:40:14 <shachaf> ricky_clarkson:   ?
16:40:31 <ricky_clarkson> Thanks.
16:41:28 <conal> i'm okay with wordpress if i don't have to look at the code.  otherwise -- yuck!
16:41:54 <shachaf> conal: What are you using it for?
16:41:57 <nelhage> Wordpress's PHP is blindness-inducing.
16:42:21 <kaol> s/Wordpress\'s//
16:42:33 <nelhage> Wordpress's is especially bad
16:42:53 <shachaf> (Do you need to escape '\''s in regexps?)
16:42:54 <kaol> it uses branding iron for it?
16:43:08 <conal> shachaf: right now, for my nvc (or post-nvc) blog (http://evolve.awakeningcompassion.com).  what i'm looking for is a replacement for blogger for my technical blog (http://conal-elliott.blogspot.com).
16:44:46 <conal> what i do like fairly well is tiddlywiki, which i use for my daily journaling (http://conal.net/Journal).  it's done in javascript, with client-side rendering.
16:45:46 <shachaf> conal: Please don't. :-)
16:45:59 <conal> shachaf: don't use tiddlywiki?
16:46:22 * shachaf would definitely not want all the Javascript.
16:47:07 <shachaf> Is there any advantage to it?
16:48:07 <conal> shachaf: sure.  some nice client-side interaction & animation.  more lively & sort of app-like than a server-based solution.
16:48:43 <shachaf> But it doesn't work at all on a non-javascript browser.
16:48:47 <Sizur> what about comet? or atleast a poll based ajax
16:48:59 <conal> shachaf: not at all
16:49:01 <Sizur> even though there is no need in push
16:49:52 <Sizur> shachaf: is there such thing? lynx, links?
16:50:40 <shachaf> Sizur: For example.
16:50:49 <shachaf> You don't want sorear to read your webpages? :-)
16:51:04 <conal> sorear: uses lynx?
16:51:09 <conal> sorear uses lynx?
16:51:14 <shachaf> conal: elinks.
16:51:18 <sorear> No.  Lynx sucks.
16:51:47 <sorear> Elinks supports tables, which makes all the diffference.
16:51:48 <conal> wow -- text-only browsing.  i wonder why.
16:51:49 <FalconNL> Phew, finally figured it out \o/. If anyone's interested, here's what I consider to be a more elegant syntax for generating html documents with Text.XHtml than the default one: http://hpaste.org/5007. Suggestions for getting rid f the final :: Html appreciated. Tomorrow I'll combine this with Happs so you don't have to save the html file anymore before refreshing the browser.
16:52:24 <shachaf> conal: Why not, if you don't need graphics?
16:53:10 <conal> i'm just surprised that anyone would be content to surf the web without pictures.
16:53:37 <conal> (i.e., besides pictures of words)
16:53:59 <Sizur> i had to today, because of dns problem i had to browse remotely where the server had no X
16:54:16 <clanehin> Makes you look really geeky.  Impresses the ladies.
16:54:33 <Sizur> but that's exception. any selfrespecting browser can speak javascript ;)
16:55:00 <Sizur> FalconNL: that looks very nice indeed
16:55:20 <shachaf> Sizur: But not at TiddlyWiki level, perhaps?
16:55:39 <FalconNL> Sizur: Thanks, but remind me never to use polyvariadic functions again :)
16:56:04 <Sizur> FalconNL: now remove that +++ and polymorth the whole thing into other representations like javascript :P
16:56:23 <Sizur> FalconNL: polyvariadic is fun! :P
16:56:24 <monochrom> polymorph!
16:56:37 <Sizur> monochrom: thanks. 2am here
16:56:39 <FalconNL> Sizur: suggestions are welcome ;)
16:56:42 <monochrom> hehe
16:56:53 <Sizur> shachaf: no i would not use js like that
16:57:46 <Sizur> FalconNL: just for xhtml it looks great already. good job :) i like it
16:58:26 <Sizur> FalconNL: removing ::Html doesn't work? prettyHtml is what type?
16:59:16 <int-e> prettyHtml :: (HTML html) => html -> String
16:59:32 <FalconNL> I get a compile error if I remove it. Like I said, it'd be really nice if someone could figure out a way to get rid of it
17:00:47 <int-e> yoy could define  prettyHtml' :: HTML -> String; prettyHtml' = prettyHtml  and use that. (or even reuse the prettyHtml name and hide it from the Text.XHtml.Strict import)
17:01:15 <int-e> err. Html -> String, not HTML -> String
17:01:48 <Sizur> FalconNL: document :: Html -> String = prettyPrint?
17:03:00 <FalconNL> int-e, Sizur: nope, same compile error
17:04:33 <Sizur> ah right, because htmlDoc cannot be polymorphic
17:05:27 <int-e> FalconNL: or you could replace +++ by +
17:05:31 <Sizur> simply doing htmlDoc::Html before the function declaration will do
17:05:35 <Sizur> and will look better
17:05:59 <Sizur> no
17:06:03 <Sizur> bleh
17:06:04 <int-e> the type signature is just for the right argument of +++ - I misread that at first.
17:06:46 <Sizur> it's the def that needs to have terminating Html
17:06:47 <int-e> and (+++) has type (+++) :: (HTML b, HTML a) => a -> b -> Html
17:07:21 <FalconNL> int-e: You did it :) replacing +++ with + means the :: Html can be removed
17:08:14 <Sizur> why cannot you do def header?
17:09:12 <FalconNL> improved version: http://hpaste.org/5007#a1
17:09:36 <int-e> Sizur: you could but then you'd have to fix some :: Html type signature again.
17:09:55 <Sizur> it's the last one that matters
17:09:58 <int-e> Sizur: (htmlDoc :: Html  is enough then though)
17:10:56 <int-e> @type (+)
17:10:58 <lambdabot> forall a. (Num a) => a -> a -> a
17:11:11 <Sizur> FalconNL: how about adding instances for attributes, then you wont need (!) too
17:11:29 <Sizur> and no arrays too
17:12:38 * EvilTerran blinks at that Num instance
17:12:52 <Sizur> heh
17:12:54 <int-e> yes, the Num instance is nasty.
17:12:58 <EvilTerran> FalconNL, why not just use a new operator?
17:13:18 <Sizur> there is no need in that instance at all, since one can do def header
17:13:22 <EvilTerran> ?hoogle <+>
17:13:23 <lambdabot> Control.Arrow.(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
17:13:23 <lambdabot> Language.Haskell.TH.PprLib.(<+>) :: Doc -> Doc -> Doc
17:13:26 <EvilTerran> hm.
17:13:35 <dons> yeah, that's weird code
17:13:48 <EvilTerran> ?hoogle ?
17:13:49 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<?>) :: GenParser tok st a -> String -> GenParser tok st a
17:13:49 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
17:13:49 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
17:14:07 <dons> i think there are << and similar thing for this, that keep some measure of type separation
17:14:12 <EvilTerran> ? is free, although it may not have the mnemonic value you want
17:14:16 <EvilTerran> ?type &
17:14:17 <lambdabot> parse error on input `&'
17:14:21 <EvilTerran> ?hoogle &
17:14:22 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
17:14:22 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
17:14:22 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
17:14:23 <EvilTerran> even
17:14:32 <EvilTerran> FalconNL, (&) would be pretty good for that, i think
17:14:55 <FalconNL> Hm. 2:15 AM. I have to get to bed. If anyone comes up with any good ideas, feel free to annotate them onto the hpaste page, I'll read them tomorrow
17:17:07 <EvilTerran> hm... i wonder why there's no instance Eq Html by default
17:17:08 <Sizur> FalconNL: no! you code, and i sleep! ;)
17:17:12 <int-e> > let foldl (?) e [] = e; foldl (?) e (x:xs) = foldl (?) (e ? x) xs in foldl (+) 0 [1..100] -- I like to use ? for unknown binary operators.
17:17:12 <lambdabot>  5050
17:20:45 <moonlite_> int-e: nice!
17:21:31 <moonlite_> never thought about that
17:32:26 <kmcallister> man, static types make refactoring so much easier
17:33:08 <monochrom> YES!
17:33:09 <kmcallister> you can change a few things and then chase type errors until it's all good
17:33:40 <monochrom> Glad you like it.
17:33:56 <dons> monochrom worked hard on that feature
17:34:04 <monochrom> No. :)
17:34:06 <LoganCapaldo> chasing type errors is great for your confidence
17:34:20 <LoganCapaldo> but bad for your morale while it's happening :)
17:34:30 <monochrom> I probably did work hard on advocating static typing.
17:34:30 <dons> well, depends on how you look at it.
17:34:32 <LoganCapaldo> (confidence in the correctness of the code)
17:34:39 <dons> its an excuse to switch off a lot of brain modules while coding
17:34:57 <dons> i sometimes change things, then intentionally let the type checker fail, so i know what to fix
17:35:09 <monochrom> "Let the symbols do the work." "Let the types do the work." :)
17:35:11 <LoganCapaldo> totally
17:35:32 <dons> this would not be possibly in a dynamic language -- they'd all be runtime failures
17:35:40 <dons> and you'd not be told. so little appreciated
17:35:54 <BMeph> A college buddy of mine always got folks to hurry up and deal cards with the adage, "Dealing is in itself, a form of shuffling."
17:36:04 <monochrom> The point of machine is to do less work and get more results.
17:36:09 <BMeph> In a way, the same applies to programming with type-checking. ;)
17:37:04 <monochrom> In program derivation, we even let the problem specification suggest solutions and code.
17:37:37 <monochrom> So there is little sin in letting types guide your programming.
17:37:49 <LoganCapaldo> if any
17:38:19 <dons> how we can explain  this model of development to someone unused to types?
17:38:24 <BMeph> Ha-ha, "turning failure into a list of successes," eh? ;)
17:38:35 <dons> by showing an example, and comparing it against a similar untyped program refactor?
17:39:02 <clanehin> I've had it happen at least once, that I wrote only half a function, knowing it was wrong but wanting to test that half, and the type checker rejected it in such a way that the simplest way to get it to compile was to write entire function correctly
17:39:16 <dons> so that the cognitive effort required to find all points to fix is clear, and then also showing how we *know* we're back to where we started
17:39:19 <BMeph> We should make some snooty-sounding institute and advocate "Type-Driven Development"... oh, too late! ;p
17:39:22 <dons> while the untyped guy hopes he didn't forget something
17:39:31 <monochrom> In the program derivation community, we actually observe that very smart people don't need help from our "let the symbols do the work".
17:39:49 <LoganCapaldo> are there people out there who are actually ignorant of static types? Every dynamic tyoing advocate I seem to "run into" as it were seems aware of static typing, and what you can do with it, but prefers dynamic typing
17:40:02 <monochrom> We think that we need help from the symbols because we are not that smart. Smart people can just come up with solutions "by inspection".
17:40:03 <kmcallister> LoganCapaldo, a lot of people think static typing means "int or float"
17:40:17 <int-e> clanehin: hmm, using  undefined  as a placeholder for the missing parts didn't work?
17:40:25 <BMeph> dons: That's weird; I just did the exact thing you talked about this weekend. o.O
17:40:27 <monochrom> We conclude that we will never convince very smart people to do program derivation.
17:40:42 * LoganCapaldo thinks monchrom is on to something there
17:40:47 <LoganCapaldo> *monochrom
17:40:48 <kmcallister> is there a way to define list-like outfix constructors?
17:40:55 <kmcallister> i.e. type [|a|] = DList a
17:40:58 <dons> monochrom: yeah :( smart people can do everything by inspection.
17:41:07 <dons> and everyone's above average in the programming community ;)
17:41:08 <monochrom> Likewise, I think very smart programmers do not need help from typing. You will never convince them.
17:41:20 <EvilTerran> kmcallister, not really
17:41:24 <osfameron> what's program derivation?
17:41:34 <LoganCapaldo> I'm not that smart
17:41:56 <Botje> haskell is smart so I don't have to be!
17:41:58 <dons> btw, i dropped this by reddit , http://programming.reddit.com/info/65hrx/comments/ (Algorithm + Strategy = Parallelism), since i think its worth a reread now we've all got 2 cores
17:42:10 <BMeph> Dynamic typing is the crutch used to compensate for a lack of polymorphism.
17:42:24 <LoganCapaldo> just 2? I'm eyeing one of those new power macs (8 cores! :p)
17:42:31 <dons> what??
17:42:47 <monochrom> Here is the unfortunate consequence. The very smart members are opinion leaders too. Most ordinary people just listen to them.
17:42:59 <dons> monochrom: that's a bit depressing.
17:43:19 <EvilTerran> osfameron, it's starting out with a specification, and using substitutions that "refine" the spec into a mixture of code and spec until there's no spec left, only executable code
17:43:28 <dons> but surely we can appeal to something along the lines of 'be more productive' and 'don't waste time'
17:43:43 <EvilTerran> osfameron, it's very cool, but also very time-consuming
17:43:45 <monochrom> So, if the very smart academics say, "don't listen to those formalists who advocate 'let the symbols do the work'. You can't blindly do math. You have to understand, have insights."  Then everyone believes them.
17:44:09 <clanehin> int-e: it's been a while, but it was just an issue that it would have taken me more effort to get it to not work than it would have taken to get it to work, from where I was in the code-test-code cycle
17:44:22 <monochrom> And if the very smart programmers say, "static types get into my way all day. I use dynamic types." Then everyone just listens to them.
17:44:34 <osfameron> EvilTerran: how does that work with real apps?
17:44:38 <Nafai> monochrom: Well, I've said that before
17:44:45 <dons> program derivation -- deriving efficient programs from inefficient ones by term rewriting (how the term's used in the haskell world)
17:44:51 <Nafai> monochrom: Because I'm used to languages like Java where it does get in the way
17:44:54 <monochrom> Of course static types get into their way all day because they're so damn smart. Also dynamic types are totally safe in their hands.
17:45:04 * clanehin wishes that everyone would listen, just once for a change.
17:45:05 <dons> osfameron: so an awful lot of refactoring falls under that umbrella, actually
17:45:09 <SamB> monochrom: you have to admit, with Java...
17:45:14 <EvilTerran> (you start with a spec like "x,y,z : [PRE,POST]", meaning "from a state satifying PRE, reach a state satisfying POST, but only by changing the variables x,y,z; refinements include making PRE more general, POST less general, and eliminating a variable)
17:45:29 <osfameron> beh, dynamic typing is really convenient up until the point that you can't keep your data structure in your head, and at that point it becomes cumbersome
17:45:34 <dibblego> with Java, its type system does indeed get in the way, but then, I'm not sure I'd even call it a "type system" (no true scotsman?)
17:45:46 <osfameron> that said, it's great for prototyping, and better than having a crappy typesystem like java's
17:45:54 <monochrom> Yes, program derivation is more work if you're smart.
17:46:10 <monochrom> Of course "smart" is relative to the problem to be solved, too.
17:46:13 <EvilTerran> osfameron, the amount that i've learnt kinda falls down in the context of external influences like IO; get back to me after this term, by which time i'll've had twice as many lectures in it as i have now :)
17:46:27 <osfameron> heh
17:46:52 <EvilTerran> as dons says, it's used slightly differently in the haskell community
17:47:18 <EvilTerran> instead of starting with a spec of the form VARS:[PRE,POST], you start with a spec that's an obviously-correct-but-inefficient haskell program
17:47:49 <EvilTerran> but thereafter, it's much the same. and without all the weird mixture-of-code-and-spec floating around confusing people
17:47:52 <Nafai> What I have learned from Java is this: the sooner in the process I can discover errors, the better
17:47:58 <osfameron> oh, so it's more or less what you do anyway, but with more theory
17:48:07 <Nafai> Since my IDE is hooked up to the compiler, I know about syntax errors and right away
17:48:22 <Nafai> I don't even have to press the "compile" button
17:48:59 <monochrom> Suppose you have already learned and understood the cool DP algorithm for "longest increasing subsequence", then my 40-line derivation will look like unnecessary effort. I mean, 40 lines of proof! Sounds long.
17:49:47 <SamB> hmm, where would a link to http://www.exmsft.com/~benrg/if-decompilers/ go...
17:49:52 <monochrom> But suppose you completely haven't heard of the algorithm or can't understand it. Then my 40-line derivation is a god-send. It shows you where you need "innovation" and where it's just letting the symbols do the work.
17:50:21 <EvilTerran> (example of weirdness:  xs : [PRE, POST]  [=  if { P1 -> (x : [PRE && P1, POST]) | P2 -> (x : [PRE && P2, POST]) | ... | PN -> (x : [PRE && PN, POST]) }  , given (P1 || P2 || ... || PN)
17:50:36 <EvilTerran> ([= being pronounced "refines to")
17:50:47 <osfameron> but if you haven't heard of the algorithm or don't understand it, then what you want is a library that encapsulates longest increasing sequence, not a proof.
17:50:54 <monochrom> It also shows you, in its own way, what's going on in the algorithm, why it's doing certain things. In fact, even though I heard the algorithm in English first, I found that the derivation helped me understand more.
17:51:24 <EvilTerran> the if { ... -> ... | ... -> ... | ... } is "executable" code, happily mixed in with non-executable pre-/postconditions and whatnot)
17:52:11 <monochrom> Well, if I don't want to understand it, I can just use a library. If I want to understand it, for whatever reason, even recreational, then I want to understand it.
17:52:12 <osfameron> EvilTerran: that's valid haskell/extension syntax?
17:52:29 <EvilTerran> osfameron, nah, it's what we've been learning in my Formal Program Design lectures
17:52:44 <monochrom> Anyway, as I said, this is also because I'm dumb. You explain it in English, and I easily get lost. You show a derivation, and I can follow it.
17:53:10 <osfameron> ok
17:53:24 <EvilTerran> i believe Hoare coined the notation
17:53:56 <EvilTerran> altho we've been learning from http://amazon.com/dp/0131232746
17:57:22 <dons> anyone notice in the HCAR the line about "A major revision of GpH for GHC 6.8.1 is starting"
17:58:01 <dons> for clusters, in particular
18:00:21 <kaiser> dons: interesting, any more details about the work for clusters?
18:01:41 <dons> well, GpH was a very exciting project in the late 90s, but they've got funding through to 2011. check http://haskell.org/communities/12-2007/html/report.html and search for GpH
18:02:06 <dons> `Our main hardware platform are Intel-based Beowulf clusters'
18:02:31 <dons> could do with more ghc-like open source visibility
18:03:43 <byorgey> funding until 2011!
18:03:46 <byorgey> wowee
18:04:24 <jaredj> question.
18:04:34 <jaredj> i want to do a bunch of file manipulation
18:04:54 <jaredj> most interesting things will involve statting all the files and dirs under the area of interest
18:05:05 <dons> jaredj: ok. so maybe using the unix package?
18:05:13 <dons> and bytestrings for IO
18:05:26 <jaredj> well .. not much i/o
18:05:40 <jaredj> i was too vague. what i want to do is burn dirs full of flacs on dvds
18:06:05 <jaredj> so other than figuring out how big things are, and doing fancy planning to (of course) use the dvds as efficiently as possible
18:06:17 <jaredj> i just need to pass them as params to mkisofs or something
18:06:24 <jaredj> but i want to cache all those stats
18:06:58 <jaredj> :t getFileStatus
18:06:59 <lambdabot> Not in scope: `getFileStatus'
18:07:06 <jaredj> :t System.Posix.Files.getFileStatus
18:07:07 <lambdabot> FilePath -> IO System.Posix.Files.FileStatus
18:07:16 <jaredj> and i'd like to pull them out with a function like that
18:07:23 <jaredj> i.e. hide all the cachedness
18:07:28 <BMeph> Isn't there a tutorial with that very problem?
18:07:33 <jaredj> whot?
18:07:42 <EvilTerran> spider thru the files, bundling the stat data into a Data.Map if you only plan on using them in one instance of the program, or into an SQLite database if you want to keep it between instances?
18:07:58 <BMeph> Well, besides them being mp3's instead of FLAC format.
18:08:09 <jaredj> yeh, no problem there. *google*
18:08:54 <dons> jaredj: so store the stat data, look it up as needed. even serialising the map with Data.Binary would be ok.
18:08:56 <BMeph> Ah, yes - the Hitchhiker's Guide: http://www.google.com/url?sa=t&ct=res&cd=4&url=http%3A%2F%2Fwww.haskell.org%2Fhaskellwiki%2FHitchhikers_guide_to_Haskell&ei=lhWMR7vKHYOSpwT7jKXmDA&usg=AFQjCNGqytuGYB0cBD2a_ysZm1hPDjIzOg&sig2=sJIpn0hxEeVkmEDhU7PsUg
18:08:57 <lambdabot> Title: Hitchhikers guide to Haskell - HaskellWiki, http://tinyurl.com/37a735
18:09:04 <dons> (that's what I use for hmp3's mp3 database)
18:09:09 <dons> sqlite3 is also nice
18:09:47 * BMeph says nasty things about how Google's solution to link spam is to make the links MORE convoluted and longer...
18:09:57 <jaredj> ... parsing du output?
18:10:09 <BMeph> Ratther, try: www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell
18:10:16 <sjanssen> jaredj: it's probably easier to use System.Posix directly
18:10:25 <sjanssen> not to mention faster
18:10:57 * SamB wonders if decompiling Bad Machine is cheating or not...
18:11:17 <jaredj> faster, yes, i expect
18:11:35 <jaredj> i've got a tree of file/dir names
18:12:02 <jaredj> but the stats don't go into the tree, and i've nothing already written with which to traverse it (nod, dons)
18:12:46 <jaredj> that hitchhiker's guide looks quite dense
18:12:54 <jaredj> quite cool
18:14:04 <jaredj> @hoogle Arbitrary
18:14:05 <lambdabot> No matches found
18:14:14 <jaredj> @hoogle Test.QuickCheck.Arbitrary
18:14:14 <lambdabot> No matches, try a more general search
18:15:46 <kaiser> thanks dons, I'll look into GpH.  Some of my master's research is with Beowulf clusters.
18:15:46 <kaiser> :)
18:16:38 <kaiser> Best textbook to learn Haskell?
18:18:20 <TomMD> Real World Haskell
18:18:49 <kaiser> TomMD: why?  :)
18:19:50 <TomMD> Kaiser: Just look at the glossary and the authors.
18:20:05 <kaiser> ok.
18:20:48 <davidL> that book isn't out yet :P
18:21:12 <kaiser> yah... the book is not yet published.
18:21:56 <TomMD> Yes, but it is the book everyone is waiting for :-P
18:23:39 <davidL> exciting, 13 chapters will be up on the site within the next few weeks
18:24:22 <dibblego> is there an announced release date?
18:26:31 <kaiser> dons: Use those extra cores and beat C today! (Parallel Haskell redux), is that your site?
18:26:31 <dibblego> is there a \p -> filter (not . p) function?
18:26:59 <dibblego> ?hoogle (a -> Bool) -> [a] -> [a]
18:27:00 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
18:27:00 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
18:27:00 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
18:27:29 <BMeph> ?src partition
18:27:29 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:27:29 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:27:29 <lambdabot>                               | otherwise = (ts, x:fs)
18:28:03 <kaiser> TomMD: I'm not having any success finding the glossary for Real World Haskell.
18:28:12 <kaiser> any suggestions?
18:28:21 <dons> kaiser: yep
18:28:32 <dons> kaiser: glossary, or table of contents?
18:28:36 <TomMD> kaiser: Sorry, I sent you on a wild goose chase.  I ment to say the table of contents
18:28:39 <BMeph> > snd.partition (<4) [0..8]
18:28:41 <lambdabot>  Couldn't match expected type `a -> (a1, b)'
18:28:52 <kaiser> dons: cool.. I'm very interested in using Haskell for parallel processing.
18:28:59 <BMeph> > (snd.partition) (<4) [0..8]
18:28:59 <taruti> What is the correct way to derive typeable instances by hand - when GHC refuses to derive them? Given a datatype like "data Rec (con :: * -> *) (t :: *) where ..." ?
18:29:00 <lambdabot>  Couldn't match expected type `(a, b)'
18:29:07 <TomMD> kaiser: If you haven't already, then look into STM
18:29:18 <kaiser> dons, TomMD: Table of Contents would be best.
18:29:20 <TomMD> I'm not sure I'd be employed without it.
18:29:41 <BMeph> > snd $ partition (<4) [0..8]
18:29:42 <lambdabot>  [4,5,6,7,8]
18:30:11 <dons> kaiser: http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
18:30:12 <lambdabot> Title: Real World Haskell  Blog Archive  Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
18:30:25 <ray> &#8217; eh
18:30:32 <kaiser> TomMD: thanks.  are you talking about STM for GHC compiler?
18:30:53 <dons> taruti: hmm. there should be some instance Typeables in the ghc base library
18:30:58 <TomMD> Well, yes.  I know there is STM in many languages / implementations, but I use a GHC derivitave and STM to a huge extent.
18:31:13 <dons> TomMD: for commercial projects?
18:31:14 <TomMD> s/derivitave/derivative
18:31:17 <TomMD> dons: bingo
18:31:34 <kaiser> dons: thank you.  Real World Haskell looks awesome.
18:31:36 <dons> TomMD: you should add something to http://haskell.org/haskellwiki/Haskell_in_industry :)
18:31:50 <dons> and maybe think about dropping by CUFP in Vancouver/.ca in September :)
18:32:12 <TomMD> dons: Nope, not gonna do it.  But if _you_ are curious, tap Adam W. on the shoulder some day.
18:32:18 <dons> TomMD: oh..
18:32:29 <dons> ok. interesting :)
18:32:34 <TomMD> But I will be at the ICFP - see you there.
18:32:41 <dons> ok. cool :)
18:33:07 <hpaste>  jaredj pasted "find files (no stat caching)" at http://hpaste.org/5009
18:33:28 <dons> too many secret haskell projects
18:34:03 <jaredj> SETEC ASTRONOMY
18:34:14 <TomMD> Too Many Secrets, Marti.
18:34:40 <LoganCapaldo> why do you think it's called cabal?
18:34:44 <LoganCapaldo> I mean come on
18:34:53 <jaredj> :)
18:35:17 <jaredj> so if i want to sort of memoize my stat calls
18:35:23 <kaiser> dons: Real World Haskell will be available free online and in print?
18:35:26 <taruti> dons: the higher kind seems tricky, is there something like that in base? (didn't find anything quickly, but probably oversight)
18:35:33 <jaredj> do i want to use a State and a Map together with IO?
18:35:43 <kaiser> dons: or chapters are posted during the review process?
18:35:47 <dons> kaiser: we plan to have .pdfs, yep
18:35:54 <kaiser> dons: you are awesome.
18:36:06 <TomMD> ?karma dons
18:36:07 <lambdabot> dons has a karma of 141
18:36:12 <sjanssen> taruti: see Typeable1, 2, etc. for higher-kinded instances
18:36:15 <kaiser> ?karma kaiser
18:36:15 <lambdabot> You have a karma of 0
18:36:17 <kaiser> lol
18:36:17 <TomMD> I think awesome starts at 20.
18:36:18 <jaredj> ?dogma dons
18:36:19 <lambdabot> Unknown command, try @list
18:36:21 <dons> sjanssen: well spotted
18:36:29 <kaiser> how do I gain some karma?  ;)
18:36:42 <dons> answer questions, release stuff, write things
18:36:59 <TomMD> kaiser: People give you karma as they see fit.  So yeah, do what dons recommended.
18:37:02 <kaiser> heh, all in good time... I just started learning Haskell yesterday.
18:37:08 <TomMD> Some day you might be as high as me (I think I am negative right now)
18:37:09 <sjanssen> @karma-all
18:37:13 <lambdabot>  "fglock"              473
18:37:16 <kaiser> haha
18:37:17 <lambdabot>  "Aankhen"             219
18:37:21 <lambdabot>  "avar"                190
18:37:23 <dons> oh, the perl6 guys dominate
18:37:25 <lambdabot> Plugin `karma' failed with: thread killed
18:37:27 <kaiser> whoa, who is fglock?
18:37:28 <sjanssen> yeah, they cheat
18:37:33 <dons> they've a bot that does ++ on commits :)
18:37:41 <kaiser> dons: haha, illegal!
18:37:48 <jaredj> haha
18:37:50 <dons> 18:37 lambdabot>  "cale"                 56
18:37:50 <dons> 18:37 lambdabot>  "sjanssen"             53
18:37:50 <dons> 18:37 lambdabot>  "lambdabot"            52
18:37:59 <TomMD> ?karma TomMD
18:37:59 <lambdabot> You have a karma of 0
18:38:00 <kaiser> how do I give karma?
18:38:01 <dons> sjanssen: did you see that ^ :)
18:38:05 <TomMD> Yay! I'm not neg!
18:38:06 <jaredj> ++kaiser
18:38:10 <kaiser> ++Cale
18:38:14 <dons> other way around
18:38:15 <jaredj> er..
18:38:16 <jaredj> oh
18:38:17 <jaredj> kaiser++
18:38:21 <kaiser> lol
18:38:26 <LoganCapaldo> @karma+ lambdabot
18:38:26 <lambdabot> lambdabot's karma raised to 53.
18:38:32 <jaredj> eh
18:38:32 <taruti> sjanssen: isn't that for things like "t (a :: *) (b :: *)" rather than "t (a :: * -> *) (b :: *)" ?
18:38:32 <kaiser> Cale++
18:38:37 <kaiser> Cale was extremely helpful last night.
18:38:56 <TomMD> Thats why I sent karma his way last night.
18:38:56 <sjanssen> taruti: I think you can re-use the classes (I might be wrong, never tried it myself)
18:39:06 <kaiser> TomMD: haha, I guess I missed that.
18:39:26 <TomMD> Well - tomorrow I expect you to have every IRC line memorized from tonight
18:40:31 <BMeph> TomMD: Why's that - planning on saying something to remember? ;)
18:40:31 <kaiser> TomMD: noo, I have class in the morning :P
18:41:36 <taruti> sjanssen: ok, I'll try to do that. thanks for the hints.
19:05:47 <dons> i find it cute that the 4 core 'core duo' is called 'core duo extreme' :)
19:07:03 <sjanssen> that product name has always been a bit odd
19:07:18 <sjanssen> eg. "core 2 duo", can we cram any more synonyms for 2 in there?
19:11:50 <allbery_b> it's supposed to mean 2 cores each of which has 2 hyperthreading "processors" (but intel ended up disabling those)
19:13:48 * dons clicks "where to buy" for " Intel Itanium Processor 9000 512 core"
19:15:19 <byorgey> 512 cores, eh dons?
19:15:37 <dons> 512 dual core cpus, actually
19:15:54 <dons> that would be a hard machine to wrangle
19:15:56 * byorgey bets that links to a page that says, "call our agent to discuss pricing.  and to arrange details for sending us your firstborn."
19:20:18 <taruti> got the Typeable instance done :)
19:47:54 <dons> interesting photos of GRIP and ALICE, http://www-fp.dcs.st-and.ac.uk/~kh/papers/pasco94/subsubsectionstar3_2_1_1.html#SECTION0002110000000000000
19:47:58 <lambdabot> http://tinyurl.com/2t8nw5
19:48:09 <dons> early hardware parallel haskell machines (to a first approximation)
19:48:56 <Cale> Huh, that html shows up as plaintext in Firefox.
19:49:12 <Cale> Maybe the server is misreporting the content type
19:49:20 <dons> weird. works in my firefox
19:50:12 <Cale> oh, the page didn't fully load, or something
19:50:25 <Cale> shift-refresh seems to have fixed it
19:59:04 <dons> GRIP is our lisp machine
20:02:06 <smack_> weird, plaintext here, too
20:02:16 <smack_> reload fixed it
20:03:57 <dons> "Parallel reduction machines (1982-1992) - The `Lisp machines' of the Haskell world " -- http://programming.reddit.com/info/65i48/details
20:09:11 <Pseudonym> Are there still GRASP copyright notices in GHC?
20:10:16 <dons> there are. and GRIP too, iirc
20:11:12 <dons> alice/grasp
20:11:45 <jaredj> still hanging on are they.
20:12:13 <dons> one of the earliest announcements of ghc mentions that been ported to GRIP
20:15:00 <dons> were there parallel mercury's , Pseudonym ?
20:15:34 <Pseudonym> Well, let me put it this way.
20:15:42 <Pseudonym> drtomc's thesis was entitled "Towards Parallel Mercury".
20:16:07 <Pseudonym> So the short answer is "kinda".
20:16:30 <Pseudonym> http://citeseer.ist.psu.edu/532813.html <- For your reading pleasure.
20:16:31 <lambdabot> Title: Towards Parallel Mercury (ResearchIndex)
20:17:10 <dons> ah heh
20:17:25 <dons> oh, quite recent
20:18:36 <LoganCapaldo> logic languages strike me as being quite amenable to parralization
20:18:37 <clanehin> Mercury was my gateway drug to haskell.  I couldn't understand haskell at first.
20:18:48 <Pseudonym> I went the opposite way.
20:18:52 <dons> heh. clanehin, you guys should form a club
20:19:04 <Pseudonym> But yeah, Tom did much the same.
20:19:09 <LoganCapaldo> Now only if I could spell parrallezation
20:19:26 <dons> and Fergus too?
20:19:29 <Pseudonym> LoganCapaldo: Logic languages are just as amenable as functional languages, and for the same reasons.
20:19:42 <Pseudonym> And Fergus too, I guess.  But Fergus was also a serious C++ nut.
20:19:47 <Pseudonym> Like, on the standards committee.
20:19:55 <dons> `Zoltan Somogyi, Fergus Henderson, Thomas Conway: The Implementation of Mercury,'
20:19:58 <dons> 1994.
20:20:01 <dons> so i guess that counts
20:20:02 * Pseudonym nods
20:20:19 <dons> now he gets to do as much C++ as he likes, i suspect :)
20:20:24 <Pseudonym> :-)
20:20:36 <Pseudonym> Zoltan's PhD thesis was also about a pre-Mercury logic language.
20:20:47 <dons> kfish: yo.
20:20:50 <Pseudonym> LoganCapaldo: However, the details are a bit trickier.
20:20:57 <kfish> hi dons
20:20:59 <Pseudonym> The central problem in logic programming is dataflow.
20:21:12 <Pseudonym> FP has a very simple dataflow.
20:21:18 <Pseudonym> Arguments in, one result out.
20:21:27 <LoganCapaldo> I figured you could try alternatives in parrallel
20:21:41 <Pseudonym> Right, that's "parallel or".
20:21:58 <Pseudonym> The thing is... most of your typical Haskell program isn't in the list or nondet monad.
20:22:11 <LoganCapaldo> well i meant in a parrallel prolog or something
20:22:12 <Pseudonym> That's because most code is deterministic.
20:22:23 <Pseudonym> So what's more useful is "parallel and".
20:22:42 <LoganCapaldo> parallel and you say?
20:23:38 <Pseudonym> There are also a bunch of stuff, even in "parallel or", for which it turns out to be tricky to do the implementation efficiently.
20:23:40 <dons> Pseudonym: i think that's what Manuel says too, from his logic programming days -- most of the time you're faking FP, not LP
20:23:51 * Pseudonym nods
20:23:54 <Pseudonym> Now mind you...
20:24:13 <Pseudonym> It's very, VERY nice to have "procedures" with "output arguments".
20:24:43 <Pseudonym> Wirth-like "var" arguments just aren't the same.
20:25:07 <LoganCapaldo> I agree. var arguments are totally wirth-less
20:25:12 * LoganCapaldo ducks
20:25:23 <Pseudonym> I see that you're calling him by value, again.
20:25:51 <Pseudonym> Really.  These jokes have been done to death.
20:26:24 <LoganCapaldo> this is the only place I get to use 'em though :P
20:26:35 <Pseudonym> Let's start #algol!
20:26:46 <Pseudonym> Hi, I'm Pseudonym, and I'm a recovering algoholic.
20:26:48 <LoganCapaldo> oh man
20:26:58 <LoganCapaldo> start posting algol articles to reddit
20:27:08 <LoganCapaldo> writting blog posts about how algol is the language of the future
20:27:13 <LoganCapaldo> algol web frameworks
20:27:28 <dons> hehe, spj, 1990, GHC "The compiler would port rather easily to a shared-memory multiprocessor, but we don't have access to one at present. "
20:28:08 <LoganCapaldo> writing abotu how much more productive algol makes you
20:28:10 <dons> and they got one in about 2004
20:29:20 <LoganCapaldo> whose with me? It could be the greatest prank in language advocacy ever?
20:29:48 <Pseudonym> Can I start a flamewar over Simula being better?
20:30:12 <LoganCapaldo> that would be ideal
20:30:17 <Pseudonym> Excellent.
20:30:23 <Pseudonym> Now we just need some blog psots.
20:30:24 <dons> well, how about advocating John Backus's FP :)
20:30:35 <Pseudonym> No way!  ISWIM is far superior!
20:30:38 <dons> or ISWIM.
20:30:40 <dons> exactly.
20:30:55 <Pseudonym> Or for serious modern programming, KRC.
20:31:23 <dons> Pseudonym: actually, i created a couple of wikipedia pages for http://en.wikipedia.org/wiki/Lazy_ML http://en.wikipedia.org/wiki/Orwell_%28programming_language%29 http://en.wikipedia.org/wiki/Id_%28programming_language%29
20:31:33 <Pseudonym> Oh, cool.
20:31:34 <dons> but we need some for KRC and a couple of others
20:31:42 <Pseudonym> I used to have some KRC code.
20:31:47 <dons> and details could be filled out by those who know/have examples
20:31:51 <Pseudonym> But I never had access to an implementation.
20:32:04 <dons> a good place to link to them would be from the haskell pages's 'influenced by' list
20:32:22 <dons> oh, and KRC can cite wadler's controversial advocacy against scheme :)
20:32:47 <Pseudonym> :-)
20:32:47 <dons> there's lots of lazy ml still around, in hbc
20:33:22 <dons> and they're all in the history of haskell paper somewhere
20:38:47 <dons> its funny that in that 1990 email saying ghc needs a shared memory machine, its a 15 year wait till 'haskell on a shared-memory multiprocessor' is published
20:39:04 <dons> and almost exact same phrasing is used "absolute wall-clock speedups"
20:39:21 <dons> simon wandered off and did other things in the 90s i guess
20:39:35 <Tac-Tics> @src ap
20:39:35 <lambdabot> ap = liftM2 id
20:39:54 <Tac-Tics> @src liftM2
20:39:55 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:40:25 <sarehu_> :t ap -- more informative imo
20:40:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:41:18 <Tac-Tics> the src is helpful for me. ap takes two things out of their boxes, applies one to the other, then they go back into the box
20:41:52 <sarehu_> I guess
20:42:29 <kaiser_> hello, I am interested in drawing a tree of equations with Haskell, similar in display to a binary tree, any recommendations of drawing toolkits to use?  Would Cairo be appropriate for this
20:42:30 <kaiser_> ?
20:43:02 <Pseudonym> Dammit.
20:43:04 <Pseudonym> OK, the question I wanted to ask was: Does anyone remember Glide?
20:43:09 <dons> gtk2hs/cairo would be ok, yep
20:43:10 * Pseudonym never saw or used that
20:43:53 <kaiser_> dons: "ok" -- does that mean you think there is something else more appropriate to use?
20:44:12 <Korollary> Pseudonym: Glide as in graphics api?
20:44:24 <Pseudonym> No, Glide as in Miranda-alike programming language.
20:44:41 <dons> kaiser: i can't think of anything more appropriate, for drawing in haskell  :)
20:44:56 <kaiser> dons: thanks for the help.
20:51:11 <kaiser> dons++
20:53:11 <kaiser> :D
20:53:11 <LoganCapaldo> oh man Glide!
20:53:11 <LoganCapaldo> I remmeber glide!
20:53:11 <Pseudonym> You do?
20:53:11 <LoganCapaldo> (as a graphics api)
20:53:11 <Pseudonym> Oh.
20:53:11 <LoganCapaldo> my voodoo2 supported glide
20:53:11 <LoganCapaldo> and opengl
20:53:11 <LoganCapaldo> iirc
20:53:11 <LoganCapaldo> i don't think there even was a direct3d yet
20:53:11 <Korollary> there wasnt
20:53:11 <LoganCapaldo> sorry to dissapoint Pseudonym
20:53:11 <clanehin> There's an assembler error when compiling the new haskell-opengl package on debian.  It's been reported, but I'm trying to puzzle through it.
20:53:55 <kaiser> lambdabot didn't give dons karma points....?
20:54:06 <kaiser> dons++
20:54:17 <kaiser> is that the correct syntax for lambdabot karma points?
20:55:39 <Cale> @karma dons
20:55:39 <lambdabot> dons has a karma of 144
20:55:52 <kaiser> Hello Cale, how are you tonight?
20:55:54 <Cale> @karma
20:55:54 <lambdabot> You have a karma of 57
20:55:57 <Cale> I'm well :)
20:56:04 <LoganCapaldo> @karma chameleon
20:56:04 <lambdabot> chameleon has a karma of 2
20:56:08 <kaiser> Cale, I think you'd be proud of me.  I figured out your foldr  ;)
20:56:28 <kaiser> hehe, not that it is an amazing accomplishment, hehe
20:56:33 <Cale> cool, I pointed you at my diagrams right?
20:56:43 <kaiser> nope, no diagrams, you just gave me code...
20:56:58 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
20:56:59 <lambdabot> Title: Fold Diagrams - CaleWiki
20:57:09 <LoganCapaldo> foldr is a map that works on the commas instead of the elements
20:57:33 <Cale> s/commas/conses/ :)
20:57:37 <LoganCapaldo> only if you imagine animated code
20:57:41 <kaiser> Cale: http://hpaste.org/4995?lines=true -- I was showing the computation steps in the comment.
20:57:45 <LoganCapaldo> like I do occasionally
20:57:54 <LoganCapaldo> does anyone else do that?
20:58:25 <LoganCapaldo> especially with fix
20:58:32 <LoganCapaldo> it gets very animated
20:58:35 <kaiser> Cale: wow, cool diagrams.  how did you create those diagrams?
20:58:47 <Cale> Inkscape
21:02:27 <kaiser> ?deriving
21:02:27 <lambdabot> Unknown command, try @list
21:02:31 <kaiser> @list
21:02:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:02:33 <Tac-Tics> @src subtract
21:02:33 <lambdabot> subtract x y = y - x
21:02:41 <Tac-Tics> @src (-)
21:02:42 <lambdabot> x - y = x + negate y
21:02:54 <Tac-Tics> @src negate
21:02:55 <lambdabot> negate x = 0 - x
21:03:04 <lament> heh heh
21:03:26 <LoganCapaldo> @src (+)
21:03:26 <lambdabot> Source not found. I am sorry.
21:03:32 <LoganCapaldo> fail
21:03:34 <lament> not at all infinite recursion, how could that possibly be
21:03:37 <Tac-Tics> @src fail
21:03:37 <lambdabot> fail s      = error s
21:04:00 <LoganCapaldo> x + y = x - negate y
21:04:12 <lament> thanks
21:05:19 <Cale> kaiser: deriving is part of the syntax of data declarations. It's a mechanism whereby the compiler can write instances automatically, but just for certain Prelude classes.
21:14:03 <LoganCapaldo> I <3 algebraic data types
21:15:06 <TSC> Is there any way to kill a thread that's in a foreign call?
21:17:38 <LoganCapaldo> yes
21:17:52 <LoganCapaldo> sneak up silently behind it with a butcher's cleaver
21:18:01 <LoganCapaldo> and when the moment is right... strike!
21:18:28 <TSC> @index cleave
21:18:28 <lambdabot> bzzt
21:18:30 <TSC> ):
21:19:57 <dons> TSC: depends on the call.
21:20:08 <dons> i think its hard in general
21:20:15 <TSC> It does seem a bit hard
21:20:21 <LoganCapaldo> you could snd a signal o yourself
21:20:27 <TSC> I'm trying to call an external program
21:20:32 <LoganCapaldo> that might work
21:20:32 <TSC> But after a while, kill it
21:20:35 <LoganCapaldo> sometimes
21:20:55 <TSC> If I can spawn a new process instead of a mere thread, I can kill (with a signal) the process
21:20:57 <dons> you could send it a signal
21:21:11 <dons> if its a thread waiting on a process, the thread could send the signal
21:21:18 <TSC> How do I do that?
21:21:58 <Tac-Tics> @src zipWith
21:21:58 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:21:58 <lambdabot> zipWith _ _      _      = []
21:23:50 <LoganCapaldo> @type transpose
21:23:53 <lambdabot> forall a. [[a]] -> [[a]]
21:24:02 <LoganCapaldo> @src transpose
21:24:02 <lambdabot> transpose []             = []
21:24:02 <lambdabot> transpose ([]   : xss)   = transpose xss
21:24:02 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
21:24:31 <dons> anyone had a go sprinkling `par`  though ghc's src..
21:25:00 <LoganCapaldo> ah dons you have an N track mind
21:25:09 <sarehu_> TSC: what are you using to call an external program?
21:25:09 <TomMD> dons: I'm more of a task parallel user (forkIO et al).
21:25:37 <TomMD> Are you curious about the potential benefits, or just measuring user base for par?
21:25:41 <clanehin> I was whining about this a few days ago.  SPJ wrote a paper about parallelizing ghc.  He obviously did it, because he ran benchmarks.  But it doesn't go.
21:26:01 <dons> well, there's the ghc version with forkIO's, from the 'haskell multicore' paper
21:26:10 <clanehin> yeah, that
21:26:17 <dons> but now satnam singh's done the stuff with `par` and runtime profiling.
21:26:28 <dons> it might be nice to feed that back into ghc, to find where to sprinkle the `par`s
21:26:54 <TomMD> ahh.  I'll look for good places (places I think are good) and give it a go.
21:26:59 <TomMD> ?type par
21:27:01 <TSC> sarehu_: HSH, but it looks like that won't give me enough information to kill it
21:27:03 <lambdabot> forall a b. a -> b -> b
21:27:32 <LoganCapaldo> so what's the next #channel in my evolution as a programmer?
21:27:43 <clanehin> There seems to be a bug in ghc related to -split-objs, but haskell-opengl uses ffi, so it could be there too.
21:27:48 <conal> does anyone know about how GeSHi knows about some haddock docs and how to extend it?  Is anyone already doing that?
21:28:02 <conal> (GeSHi = Generic Syntax Highlighting)
21:28:35 <conal> for instance, it knows Monad & Functor, but not Monoid & Applicative
21:30:47 <TSC> I think I'll use forkProcess + executeFile; that will give me the process id I need to kill
21:31:07 <eyeris> How do I get a value out of a monad? E.g. (sequence $ repeat getLine) has the type IO [String], how do I get that list of Strings, to pass it to a function that is not in the IO class?
21:31:33 <sarehu_> TSC: yeah.
21:31:39 <LoganCapaldo> @type (>>=)
21:31:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:32:04 <TSC> That's a pain, because I can't use MVars to communicate
21:32:06 <LoganCapaldo> let m = IO
21:32:19 <sarehu_> What?
21:32:24 <sarehu_> What do you mean TSC?
21:32:30 <eyeris> LoganCapaldo so the m in m a does not have to be the same as the m in m b?
21:32:38 <LoganCapaldo> no it does
21:32:41 <dibblego> eyeris, yes it does; you're stuck in IO
21:32:58 <TSC> sarehu_: Oh, maybe I can after all
21:32:59 <conal> eyeris: you can fmap a function over the IO [String]
21:33:22 <sarehu_> TSC: I mean, communicate with what?
21:33:53 <LoganCapaldo> let's say I have a function that adds 1 to a number
21:34:01 <LoganCapaldo> @let addone x = x + 1
21:34:06 <TSC> With the parent: I'm spawing two threads, and as soon as one finishes I want to kill the other
21:34:09 <lambdabot> Defined.
21:34:19 <LoganCapaldo> and then I have a value in the Maybe monad
21:34:22 <sarehu_> ah
21:34:25 <TSC> I use an MVar to tell the "parent" that it's finished
21:34:41 <LoganCapaldo> > addone (Just 2) -- I can't do this
21:34:42 <lambdabot>   add an instance declaration for (Num (Maybe t))
21:34:42 <lambdabot>     In the expression: addo...
21:34:45 <TSC> And depending on the value put in the MVar, it kills the thread that's still going
21:34:47 <LoganCapaldo> but
21:34:50 <sarehu_> TSC: make a forkOS thread, have it wait on the child process and modify an MVar when done.
21:35:16 <LoganCapaldo> >>= applies the function to the value
21:35:20 <TSC> Yeah, that's what I'll do
21:35:51 <TSC> It just has to write the process ID to another MVar before it waits, so that the parent can kill the process (in order to kill the thread)
21:35:52 <LoganCapaldo> now since the type of the second argument has to be a Maybe b we ca't just do the following
21:36:00 <LoganCapaldo> > Just 5 >>= addone
21:36:01 <lambdabot>   add an instance declaration for (Num (Maybe b))
21:36:12 <eyeris> so how does anyone ever actually use input from getLine?
21:36:22 <LoganCapaldo> but we know we can always turn a a to a Maybe a by using return
21:36:27 <LoganCapaldo> @type return
21:36:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:36:34 <LoganCapaldo> so we can do this
21:36:42 <sarehu_> eyeris: Well maybe you just want a line of input
21:36:52 <LoganCapaldo> > Just 5 >> \x -> return (addone x)
21:36:52 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
21:36:52 <lambdabot>     but its type `M...
21:37:02 <LoganCapaldo> > Just 5 >>= \x -> return (addone x) -- typo
21:37:03 <lambdabot>  Just 6
21:37:46 <LoganCapaldo> this pattern of (a -> b) being transformed into (m a -> m b) is handled by the liftM function
21:38:03 <LoganCapaldo> > liftM addone (Just 5)
21:38:04 <lambdabot>  Just 6
21:38:06 <eyeris> All I want to do is to continually get a line of text from the user, store that in a State monad and print it out.
21:38:39 <sjanssen> forever $ getLine >>= putStrLn
21:38:50 <eyeris> sjanssen yes, I can figure that out
21:39:19 <sarehu_> eyeris: 'store that in a State monad' means you're using a StateT something IO?
21:39:25 <sjanssen> if you want to combine IO and State, you'll need to use the StateT "monad transformer"
21:39:59 * LoganCapaldo is convinced the key to understanding monads is type signatures
21:40:44 <TSC> There's no easy way to communicate between processes like MVars for threads, is there?
21:40:57 <eyeris> sjanssen I've figured that out too, I thought, but I can't get the types to match
21:41:00 <LoganCapaldo> fifos?
21:41:06 <sarehu_> TSC: well, you could always set up a pipe
21:41:13 <dons> TSC: pipes, basically. or unix sharedmem, i guess
21:41:16 <LoganCapaldo> not even fiofs just regular pipes
21:41:18 <dons> mmap too gets used for this
21:41:33 <dons> signals. disk files
21:41:39 <dons> there's lots of ways :)
21:41:41 <LoganCapaldo>  oh that would be  a hot lib
21:41:44 <sarehu_> speak no evil dons!
21:41:45 <LoganCapaldo> MMapVar
21:41:46 <sjanssen> TSC: hopefully you can avoid IPC altogether -- what is it you need to do?
21:42:16 <LoganCapaldo> You can pin things w/ ghc's GC for ffi and the like right?
21:42:33 <TSC> I want to run a program (executeFile) in a forked process, and collect its output
21:43:09 <sjanssen> @hoogle executeFile
21:43:10 <lambdabot> No matches found
21:43:17 <sjanssen> is that 'exec' in the posix library?
21:43:31 <LoganCapaldo> newMMapHeap :: FilePath -> IO MMapHeap , newMMapVar :: MMapHeap -> MMapVar a
21:43:36 <TSC> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#v%3AexecuteFile
21:43:37 <lambdabot> http://tinyurl.com/obhpz
21:43:43 <LoganCapaldo> readMMapVar, writeMMapVar, etc.
21:44:04 <LoganCapaldo> Am I making any sense?
21:44:34 <LoganCapaldo> newMMapVar :: MMapHeap -> IO (MMapVar a) I mean
21:44:51 <hpaste>  eyeris pasted "I can't understand how to construct the return " at http://hpaste.org/5013
21:45:01 <sjanssen> TSC: what you want to do is create a pipe in the parent process, then in the child process use dup to copy the output end of the pipe to stdout
21:45:22 <sjanssen> then read from the other end of the pipe in the parent
21:45:47 <TSC> sjanssen: Thanks (and to everyone else)
21:45:56 <TSC> Not quite as nice as MVar, but I should be able to get it to work
21:46:23 <dons> yeah, a haskell-like interface to shared memory programming in unix would be nice (and a bit uppity ;)
21:46:40 <dons> transactional memory in the kernel?
21:46:40 <LoganCapaldo> uppity how?
21:46:45 <conal> eyeris: you don't need a return there.
21:46:53 <dons> LoganCapaldo: oh, haskell teaching unix how to do IPC
21:46:53 <sjanssen> TSC: see spawnPipe in http://code.haskell.org/XMonadContrib/XMonat/Util/Run.hs
21:46:57 <conal> eyeris: since the putStrLn is already an IO
21:46:59 <dons> old dogs, new tricks, and so on
21:47:45 <LoganCapaldo> i think you need a lift there and not a return
21:47:50 <eyeris> conal: removing the return gives another type error
21:48:01 <conal> eyeris: what's that error?
21:48:11 <LoganCapaldo> if you want the type to match your signature anyway
21:48:26 <hpaste>  (anonymous) annotated "I can't understand how to construct the return " with "(no title)" at http://hpaste.org/5013#a1
21:48:40 <hpaste>  LoganCapaldo annotated "I can't understand how to construct the return " with "(no title)" at http://hpaste.org/5013#a2
21:49:04 <TSC> sjanssen: Ah, thanks
21:50:02 <LoganCapaldo> @type lift
21:50:17 <lambdabot> thread killed
21:50:22 <LoganCapaldo> :(
21:50:25 <LoganCapaldo> @type lift
21:50:26 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:50:57 <TSC> sjanssen: spawnPipe is slightly backwards for me; I need a handle to the output, not the input (but that should be an easy change)
21:51:06 <conal> eyeris: yeah -- mixing IO & State.  perhaps "lift (putStrLn ...)"
21:51:11 <conal> @type lift
21:51:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:51:12 <sjanssen> TSC: you'll want to skip the double 'forkProcess' -- we do it to avoid zombie processes
21:51:20 <LoganCapaldo> putStrLn aString :: IO (), lift $ putStrLn aString :: StateT IO ()
21:51:25 <conal> eyeris: yeah -- i bet that'll do it.
21:51:26 <eyeris> Where is lift defined?
21:51:30 <eyeris> it works forme
21:51:36 <TSC> sjanssen: Ok, thanks
21:51:37 <eyeris> but it isn't in the Control.Monad docs
21:51:37 <LoganCapaldo> @index lift
21:51:37 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
21:51:37 <lambdabot> ParserCombinators.ReadPrec, Text.Read
21:52:01 <LoganCapaldo> probably docced in Control.Monad.Trans
21:52:03 <conal> eyeris: check out Control.Monad.Trans and Control.Monad.State
21:52:56 <LoganCapaldo> type signature type signature type signatures! type signatures type signatures type signatures! I LOVE THIS PROGRAMMING LANGUAGE!
21:53:10 <LoganCapaldo> </balmer>
21:53:57 <eyeris> ok, so now how do I use my move function with runStateT?
21:54:13 <LoganCapaldo> @type runStateT
21:54:14 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:55:04 <LoganCapaldo> runStateT initialState -- you'll want to do this in main, either directly or indirectly
21:55:29 <LoganCapaldo> err
21:55:35 <LoganCapaldo> the action comes first
21:55:39 <LoganCapaldo> doh
21:55:46 <eyeris> yeah, I have that so far
21:56:38 <LoganCapaldo> that's all there is to it, runStateT (move "some string") "initial string"
21:57:13 <eyeris> LoganCapaldo I can understand how to use runStateT in that form
21:57:30 <eyeris> I want to pass move a line from getLine
21:58:20 <LoganCapaldo> well this is where >>= comes in
21:58:51 <LoganCapaldo> getLine to the left >>= runStateT to the right here I am, stuck in the middle with you
21:59:12 <TSC> Is this (running in the IO monad) enough to make hGetContents safe?
21:59:13 <TSC>     output <- hGetContents h
21:59:13 <TSC>     return $! length output
22:00:00 <LoganCapaldo> eg getLine >>= \line -> runStateT (move line) "Initial string"
22:00:13 <eyeris> OH!
22:00:17 <eyeris> with a lambda
22:00:23 <sjanssen> TSC: should b
22:00:24 <sjanssen> e
22:00:34 <TSC> Thanks (yet again (: )
22:01:44 <TSC> It compiled first time...
22:01:46 <TSC> Haskell is scary
22:02:09 <eyeris> ok, so now I get it to compile properly but it doesn't work as expected :)
22:02:24 <LoganCapaldo> they never do
22:02:42 <LoganCapaldo> i have to go to sleep so I can wake up bright eyed and bushy tailed for a day C++ coding
22:02:47 <LoganCapaldo> good luck and good night
22:02:54 <eyeris> thanks, cya
22:09:12 <hpaste>  eyeris pasted "Trouble with State" at http://hpaste.org/5015
22:09:18 <kmcallister> @hoogle (Floating a) => a -> Double
22:09:18 <lambdabot> No matches, try a more general search
22:09:25 <kmcallister> @hoogle a -> Double
22:09:25 <lambdabot> No matches, try a more general search
22:09:28 <kmcallister> @hoogle Float -> Double
22:09:28 <lambdabot> No matches, try a more general search
22:09:34 <kmcallister> gah
22:22:14 <ac> is there a better way to turn a string in to a number than "foldl ((+).(*256)) 0 $ map (fromIntegral.ord)"? I do not have to worry about chars with ords over 255
22:22:32 <ac> > foldl ((+).(*256)) 0 $ map (fromIntegral.ord) "IDAT"
22:22:38 <lambdabot>  1229209940
22:24:52 <ac> > fromIntegral $ foldl ((+).(*256)) 0 $ map (fromIntegral.ord) "gAMA" :: Word32
22:24:55 <lambdabot>  1732332865
22:26:48 <sarehu> ac: How about  foldl' (\x y -> x * 256 + fromIntegral (ord y))
22:28:51 <sarehu> ac: the extra  fromIntegral $  youhave out front on the last one is redundant
22:29:31 <TSC> Ahhh, I hate process management
22:29:46 <sarehu> then let them roam free
22:29:47 <TSC> I forgot to close the writing-end of the pipe in the parent after forking
22:29:58 <TSC> So, of course, the reading end never got EOF
22:30:02 <TSC> And it sat there
22:30:59 <Pseudonym> If you love a process, set it free.
22:31:09 <ac> :t foldl'
22:31:16 <Pseudonym> It it dies and becomes a child zombie, you can reap it later.
22:31:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:31:35 <sarehu> ac: foldl' is the same as foldl, except that it evaluates its accumulated values strictly, instead of building up a big expression
22:32:02 <ac> sarehu: I thought (+) and (*) and whatn't wasn't defined for Words
22:32:09 <TSC> On the positive side, it looks like I know have a function that will run some program, and kill it if it takes too long
22:32:36 <TSC> Perfect for running all your experiments for your research papers
22:32:42 <ac> sarehu: apparently they are
22:34:19 <ac> sarehu: I'm only dealing with 4 character strings here though :-P
22:35:08 <sarehu> ac: was going to ask!  Too bad you don't have multi-letter character constants like in some C compilers :)
22:35:16 <sarehu> > 'abc'
22:35:17 <lambdabot>  Improperly terminated character constant at "'abc'" (column 1)
22:35:17 <ac> > foldl (\x y -> x * 256 + fromIntegral (ord y)) "gAMA" :: Word32
22:35:23 <lambdabot>  Couldn't match expected type `Word32'
22:35:41 <ac> > (foldl (\x y -> x * 256 + fromIntegral (ord y)) "gAMA") :: Word32
22:35:42 <lambdabot>  Couldn't match expected type `Word32'
22:35:54 <ac> > fromIntegral $ foldl (\x y -> x * 256 + fromIntegral (ord y)) "gAMA" :: Word32
22:35:55 <lambdabot>   add an instance declaration for (Num [Char])
22:35:55 <lambdabot>     In the expression: (x * 25...
22:36:35 <sarehu> I mean, foldl (\x y -> ...) 0
22:36:43 <ac> > foldl (\x y -> x * 256 + fromIntegral (ord y)) 0 "gAMA" :: Word32
22:36:50 <lambdabot>  1732332865
22:37:15 <ac> there we go
22:37:23 <ac> > "gAMA" :: Word32 -- :-P
22:37:25 <lambdabot>  Couldn't match expected type `Word32'
22:38:25 <sjanssen> sounds like a job for overloaded strings!
22:38:27 <sarehu> ac: instance Num String where ... :P
22:38:48 <sarehu> Or wait.  No.
22:38:49 <sarehu> sorry.
22:39:12 <sjanssen> instance ToString Word32 where ... -- is more evil and more fun!
22:39:25 <sjanssen> s/ToString/IsString
22:39:25 <sarehu> Isn't it IsString?
22:39:30 <ac> eh I'm stupid. This is all going in to a byte string or file handle anyway
22:39:34 <Japsu> newtype NumericString = NumericString Integer; instance Read NumericString where ....
22:39:38 <ac> all I need is map (fromIntegral.ord)
22:40:59 <Japsu> erm
22:41:08 <Japsu> @type Data.ByteString.Lazy.pack
22:41:10 <lambdabot> [Word8] -> Data.ByteString.Lazy.ByteString
22:41:16 <Japsu> @type Data.ByteString.Lazy.Word8.pack
22:41:17 <lambdabot> Couldn't find qualified module.
22:42:55 <dons> oh interesting, commutative monads for parallelism, http://www-fp.dcs.st-and.ac.uk/~kh/papers/pasco94/subsubsectionstar3_3_2_3.html
22:42:57 <lambdabot> Title: Commutative Monads, http://tinyurl.com/2xu8ha
22:43:47 <dons> makes sense -- i wonder why we've not seen that tried recently
22:44:03 <ray> i wonder why that triggers a hilight for me
22:44:26 <ray> oh, 'pasco'
22:46:14 <thetallguy> dons: thank you, I think I have a use for those.
22:47:00 <ac> would it be a simple matter to write a function that takes a file handle, a [Word8], or a ByteString?
22:47:51 <allbery_b> you would need to use a typeclass
22:48:33 <ac> class Stream a where head :: ..., seek :: ...
22:48:41 <allbery_b> and write implementations for all three (presumably all funneling into a central function with the real functionality)
22:50:01 <ac> class Stream a where head :: a -> Word8, seek :: a -> Int -> a, etc
22:50:48 <ac> instance Stream [] where seek l off = drop off l ...
22:50:59 <ac> allbery_b: something like that?
22:51:20 <allbery_b> something like, yes
22:51:58 <sarehu> If you want it to take a file handle you'd have to create some monad for its values to return into
22:52:11 <ac> sarehu: oh right, because they're all IO types
22:52:25 <sarehu> So   class Monad m => Stream m a where...
22:52:27 <ac> can you turn a file handle in to a lazy ByteString easily?
22:53:14 <sarehu> ac: hGetContents?
22:53:17 <ac> hGet
22:53:23 <sarehu> :t Data.ByteString.Lazy.hGetContents
22:53:25 <lambdabot> GHC.IOBase.Handle -> IO Data.ByteString.Lazy.ByteString
22:53:26 <ac> ah yes. I'll just handle [Word8] and ByteString then
22:53:46 <ac> or maybe just ByteString ;)
22:54:21 <ac> it's easy enough to pack a [Word8]
22:57:56 <dons> just more inefficient to via lists if you don't need to
23:01:25 * ac discovers the IOUArray
23:01:57 <sclv> haha i love that name. it sounds like a bad punchline.
23:02:35 <ac> indeed
23:04:25 <dons> STUArray  forever!
23:06:30 <ac> I think Haskell embraces direct memory access more than any other language I've used than C, with all of its types like Foreign.Ptr and IOUArray
23:06:40 <ac> *other than C* I mean
23:07:03 <ac> and ByteString
23:12:19 <ac> So if you write a number of functions that take various "Array Foo Word" types, they can be used with Array, UArray, and StorableArray?
23:13:04 <sarehu> If you use the IArray interface
23:33:56 <dons> sjanssen: did i just catch you recommending overloaded strings :)
23:38:27 <sjanssen> dons: more like poking fun at them :)
23:40:08 <dons> hehe
23:40:37 <dons> let's recommend some instances of (-> a) IsString and friends,  for April Fool's Day. :)
23:40:48 <dons> embedded perl? :)
23:41:01 <dons> oh, inline C!
23:41:13 <dons> calls to gcc, gets back a function pointer from the ffi
23:41:40 <dons> "int f(int i) { return (i * i); }"  7 -- would be valid. !
23:42:07 <dons> ddarius: ^ IsString C code, the end of everything :)
23:42:12 <johnnowak> is there any way to control what happens when something goes horribly wrong with a program compiled with ghc, like a memory allocation failure?
23:42:14 <sclv> inline php, called via unsafePerformIO!
23:42:33 <dons> johnnowak: i think there are C hooks you can compile in.
23:42:45 <sclv> it would be really easy to cook that up actually.
23:42:46 <dons> but if its bad enough, you'll need a monitor process to restart
23:42:52 <dons> sclv: yeah, definitely
23:43:12 <dons> andyjgill's new hpc post, http://programming.reddit.com/info/65ijj/details
23:43:21 <dons> get on the quality assurance for haskell bandwagon, while its in town!
23:43:22 <dons> :)
23:43:33 <johnnowak> thanks
23:44:33 <andyjgill> Its pretty short, but I want to build upto fixing the otherwise graffiti problem.
23:45:26 <dons> andyjgill: btw, that photo of portland is severly misleading :)
23:45:54 <andyjgill> It took forever to find a good one.
23:46:51 <andyjgill> My house in near the top middle, slightly left. I share a pixel with the rest of my street.
23:47:11 <OceanSpray> I heard this place was filled with PhDs
23:47:22 <sarehu> oh my gawd, inline C... sigh.
23:47:23 <OceanSpray> True/False/Qualify?
23:49:33 <mxc2> newbie laziness question - it seems like lazy execution kills the benefits of tail recursion, and should lead to stack overflows left and right.  obviously it doesnt and is workable, why am i wrong/stupid/mean/etc?
23:50:12 <sarehu> mxc2: input sizes are small enough?  At least that's why _I_ don't get stack overflows
23:50:36 <dons> mxc2: strictness analysis recovers most tail recursive loops, tail recursion's also not common in haskell.
23:50:40 <allbery_b> some operations are inherently strict (e.g. addition).
23:50:56 <dons> > foldl (+) 0 [1..1000000] :: [Int]
23:50:57 <ulfdoz> tail recursion needs stack?
23:50:57 <lambdabot>   add an instance declaration for (Num [Int])
23:50:57 <lambdabot>     In the expression: 1000000
23:51:06 <dons> > foldl (+) 0 [1..1000000] :: Int
23:51:09 <lambdabot>  1784293664
23:51:24 <dons> strictness analysis ensure that's a flat loop in the compiled code
23:51:33 <mxc2> ulfdoz - no, correct tail recursion doesnt
23:52:02 <dons> mxc2: so i guess the point to remember is that despite being a lazy-by-default language, haskell compilers annotate for strictness (so they're really mixed strict/lazy), so its not a big deal
23:52:49 <mxc2> btw, i:m coming from a moderately decent ocaml background
23:52:56 <ulfdoz> mxc2: what's your example for stack overflow with tail recursion?
23:52:57 <roconnor> mxc2: I'd say the answer is that we use non tail recursion, and more often then not the recursive call is guarded by a constructor.
23:52:59 <Cale> > foldl (+) 0 [1..1000000] :: Integer
23:53:01 <mxc2> and a complete haskell newbie
23:53:04 <lambdabot>  Exception: stack overflow
23:53:06 <dons> some interesting things aren't tail recursive, but still run in constant space.
23:53:06 <Cale> :)
23:53:09 <Cale> > foldl' (+) 0 [1..1000000] :: Integer
23:53:10 <lambdabot>  500000500000
23:53:16 <dons> Cale: that's due to the enumFromTo instance for Integer.
23:53:29 <dons> (ghc 6.8 gets it right)
23:53:42 <Cale> Why isn't lambdabot using 6.8 yet?
23:54:02 <Cale> Is it on a machine where there are still problems getting hs-plugins to work?
23:54:04 <dons> mxc2: also, there's lots of good loops that aren't tail recursive, but run in constant space due to laziness
23:54:26 <roconnor> dons: rightr, because recursive calls are usually guarded by constructors :)
23:54:26 <dons> unfolds, for example.
23:54:32 <dons> yeah
23:55:09 <mxc2> ok, now i have a question, what was going on with the Int/Integer issue about
23:55:10 <mxc2> above
23:55:12 <roconnor> and so the recursive call is not evaluated until that constructor is consumed by a case analysis.
23:56:08 <mxc2> Int and Intger are different?  will have to make a note of that
23:56:14 <allbery_b> the enumFromTo (desugared [1..1000000]) instance for Integer is wrong in older ghc (such as the version the bot is using)
23:56:19 <Cale> mxc2: It's a bug in the code which generates sequences for Integer in GHC 6.6
23:56:22 <allbery_b> Int is a machine word; Integer is gmp
23:56:32 <mxc2> gmp?
23:56:37 <allbery_b> (so, as large as you can fit into memory)
23:56:47 <mxc2> oh
23:56:49 <mxc2> ok
23:56:56 <allbery_b> gnu math library
23:57:20 <dons> > 2 ^ 10000000
23:57:23 <lambdabot>  9049817306360800301396402667708707356248762388018002675910921592053343748725...
23:57:26 <dons> that Integer type
23:57:27 <roconnor> dons: Actually I never thought about how in our lazy recursive code, the recursive calls are guarded.  That means our recursion is often both recursive and co-recursive.
23:57:32 <mxc2> so arbitrarily large and arbitrarily slow...
23:57:37 <allbery_b> yep
23:57:50 <Cale> mxc2: (but it's actually quite fast)
23:57:59 <dons> Int/Integer. you choose what's appropriate -- speed/correctness. (but it is quite fast)
23:58:08 <allbery_b> gmp is pretty heavily optimized for most common platforms
23:58:08 <dons> as we just saw :)
23:58:09 <mxc2> yeah, lambdabot seemed to come back prett quickly
23:58:26 <dons> > 2 ^ 1000000000
23:58:27 <Cale> I think Int should be moved from the Prelude to Data.Int
23:58:32 <lambdabot> Terminated
23:58:35 <roconnor> :)
23:58:44 <mxc2> heh
23:58:47 <dons> > 2 ^ 1000000000 :: Int
23:58:48 <lambdabot>  0
23:58:52 <mxc2> now, if only it could make macworld come quicker...
23:58:52 <dons> > 2 ^ 100000000 :: Integer
23:58:59 <lambdabot> Terminated
23:59:04 <dons> huh, i picked just the right value first off
23:59:11 <roconnor> Cale: at Functional Programming day, the language Trinity only has Nat by default.
23:59:31 <roconnor> Cale: they said they found this choice particularly good for teaching
23:59:33 <Cale> roconnor: Which representation of Nat?
23:59:54 <roconnor> Cale: because a lot of the example code we have works over the Nat
