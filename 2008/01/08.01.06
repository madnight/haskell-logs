00:00:05 <oerjan> @src filterM
00:00:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:00:27 <hpaste>  dibblego pasted "@src filterM" at http://hpaste.org/4827
00:00:59 <sjanssen> dibblego: yes
00:01:05 <dibblego> ok thanks
00:01:27 <oerjan> it's pretty mechanical to convert
00:01:45 <dons> filterM p xs     = foldr k (return []) xs
00:01:49 <dons> where 'k' is some stuff
00:01:50 <dibblego> you mean a f [] = x; f (a:as) = x is mechanical?
00:01:57 <dons>     k x xs' = do
00:01:57 <dons>       flg <- p x
00:01:57 <dons>       ys  <- xs'
00:01:57 <dons>       return (if flg then x:ys else ys)
00:02:12 <dons> (fusible!)
00:02:13 <dibblego> dons, yeah, got that bit :)
00:02:21 <dibblego> the *easy* bit!
00:02:25 <oerjan> dibblego: as long as as is only used in the form f as
00:03:05 <oerjan> you just replace that by xs' as dons did
00:03:17 <dibblego> I didn't see how that happened
00:03:36 <dibblego> oh wait, I see
00:03:40 <dibblego> thanks
00:06:07 <aFlag> the haskell community is so good, I wish they were all like that.
00:06:32 <dibblego> ?type \f -> foldr (\a b -> f a >>= \flg -> b >>= \ys -> return (if flg then a : ys else ys)) (return [])
00:06:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [a] -> m [a]
00:07:52 <oerjan> ?type \f -> foldr (\a b -> f a >>= \flg -> liftM (if flg then (a:) else id) b) (return [])
00:07:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [a] -> m [a]
00:08:52 <dons> aFlag: oh 'they' == 'other communities' ?
00:09:15 <aFlag> yeah
00:09:29 <dons> did you have a good experience?
00:09:37 <oerjan> ?type \f -> foldr (\a b -> f a >>= \flg -> (liftM $! if flg then (a:) else id) b) (return [])
00:09:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [a] -> m [a]
00:09:42 <aFlag> on other communities? not so much
00:09:48 <aFlag> here yes
00:09:52 <dons> no, with haskell, i mean :) what did we do right?
00:10:03 <dons> maybe we should keep doing it, whatever that is :)
00:10:06 <oerjan> ^^ wouldn't that be less memory leaky?
00:10:12 <aFlag> yeah, here, haskell-cafe, people are helpful and they know what they're talking about
00:10:29 <dons> ah! yes, i forgot sometimes what language channels are like.
00:10:38 <aFlag> lots of other channels here on freenode people will pick on the most unimportant stuff and not know how to answer anything more complicated
00:10:39 <dons> its cool that  the good vibe has become so self-sustaining
00:10:40 <sjanssen> @type \p -> foldr (\x mxs -> do b <- p x; (if b then fmap (x:) else id) mxs) (return []) -- quick, spot the difference
00:10:40 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => (a -> f Bool) -> [a] -> f [a]
00:10:48 <aFlag> althought they'll talk some nonsense about it
00:10:50 <dons> we used to worry that when growing from 100 to 400 people, we'd lose something
00:10:52 <dibblego> s/liftM/fmap
00:11:14 <dons> aFlag: that's useful to remember - we need to keep the experts interested
00:11:19 <sjanssen> oerjan: your last version has a very subtle difference, can you find it?
00:11:28 <dibblego> dons, the Scala community is suffering in last 2 or 3 weeks from exponential growth
00:12:03 <aFlag> yeah, I think maybe the experts from the other languages have gone away from the channels
00:12:57 <oerjan> you only need functor?
00:13:05 <oerjan> er misread
00:13:21 <aFlag> the main reason I push myself into learning haskell is the haskell community being so nice
00:15:57 <oerjan> sjanssen: yours is tail recursive when a is not selected
00:16:38 <oerjan> er x
00:17:30 <sjanssen> oerjan: yes, but there's an observable difference too.  Your last version has the same defect
00:17:40 <sjanssen> (difference from filterM in the standard libraries)
00:18:11 <oerjan> hm?
00:19:39 <sjanssen> I can provide an input that will yield different results for each implementation
00:19:47 <oerjan> oh wait yes
00:19:50 <xpik1> is there a haskell library with fromIntegral wrapped around common number functions?
00:20:12 <oerjan> if the result of f x is bottom
00:20:40 <sjanssen> not quite, return bottom
00:20:51 <oerjan> that's what i mean
00:21:10 <oerjan> the result of the action f x
00:21:11 <sjanssen> I proposed this version of filterM once, but it was shot down due to that difference
00:22:26 <oerjan> hysterical raisins...
00:22:29 <allbery_b> xpik1: not standard.  someone did up a number library which tried to apply perl/python/ruby-style number behavior, but it's not on hackage that I can see and any such approach n haskell is likely to have corner cases where the types get weird
00:22:50 <dons> dibblego: so the book/new year holiday led to a big jump?
00:23:20 <dibblego> dons, yeah, it's getting a lot of attention and the activity has increased dramatically
00:23:31 <dibblego> dons, I'm running my Scala course again next week
00:23:57 <jsnx> you know, all i really wanted was a cool looking lambda...
00:24:01 <dons> cool, dibblego
00:24:02 <jsnx> and i can't have it!
00:24:39 <sjanssen> jsnx: it isn't fair to steal characters from Greek speakers :)
00:24:57 <glguy> -fispeakgreek
00:26:35 <allbery_b> -XIWantMyLambda
00:27:51 <jsnx> sjanssen: it should depend on locale, then
00:28:04 <jsnx> allbery_b: that's the right idea!
00:28:09 <glguy> that'd be a bad precedent to set for source code files
00:28:26 <glguy> you can only compile this file if you are using en-US.UTF-8
00:28:37 <jsnx> can't we just make Haskell english only?
00:28:41 <sjanssen> jsnx: oh, so now the Greeks can't compile my code?
00:28:59 <allbery_b> ghc already does that, though.  (ok, UTF8 or ASCII)
00:29:00 <jsnx> en-SC.UTF-8
00:29:19 <sjanssen> allbery_b: it doesn't inspect the locale, it blindly assumes all input is UTF-8
00:29:19 <allbery_b> that said, it's annoying that Haskell won't let me use Hebrew (because it doesn't have case)
00:29:20 <jsnx> or whatever scotland's code is
00:29:37 <jsnx> right, the case restriction is irritating
00:29:44 <jsnx> because i can't use chinese, either
00:29:51 <Zao> jsnx: en_XX, you mean?
00:30:39 <jsnx> Zao: for scottish?
00:30:56 <Zao> I mean a _ instead of a -.
00:31:04 <jsnx> Zao: oh, yeah
00:31:12 <jsnx> you are right
00:31:44 <jsnx> basically, we've got a system for greek speakers, at the expense of everyone in india and china
00:32:10 <sjanssen> allbery_b, jsnx: a magic upper-case character has been proposed
00:32:29 <sjanssen> jsnx: the case restriction has nothing to do with languages
00:32:31 <jsnx> sjanssen: what is that, exactly?
00:32:52 <jsnx> sjanssen: well, the case restriction has to do with character sets
00:32:55 <sjanssen> the problem is ambiguity between variables and constructors in pattern matches
00:33:39 <jsnx> well, couldn't we use $ like perl ?  :)
00:33:43 <sjanssen> jsnx: my point is that your comment about Greek v. Chinese isn't at all true
00:33:47 <allbery_b> aiee
00:34:11 <jsnx> sjanssen: it's not possible to compile code with variable names in chinese
00:34:17 <sjanssen> jsnx: the idea is similar to ':' for operators, it's treated as an "upper case symbol"
00:34:36 <sjanssen> jsnx: yes, but this decision has nothing to do with Greek and lambda
00:34:43 <jsnx> sjanssen: true
00:35:01 <jsnx> sjanssen: i guess i just felt the whole situation was rather ironic
00:35:08 <dons> ?users
00:35:09 <lambdabot> Maximum users seen in #haskell: 435, currently: 381 (87.6%), active: 11 (2.9%)
00:35:16 <allbery_b> it's a pity unicode doesn't have a separate character for the mathematical lambda
00:35:16 <dons> ?users #scala
00:35:16 <lambdabot> Maximum users seen in #scala: 71, currently: 55 (77.5%), active: 1 (1.8%)
00:35:30 <dons> ?users #xmonad
00:35:31 <lambdabot> Maximum users seen in #xmonad: 106, currently: 85 (80.2%), active: 7 (8.2%)
00:35:33 <sjanssen> allbery_b: yeah, I think that's the solution
00:35:36 <dons> go xmonad! ;)
00:35:58 <dons> also, i want  to see 381 new libraries this time next week.
00:36:13 <dons> I'LL BE CHECKING!
00:36:47 <jsnx> i bet you if we just made 'Î»' a reserved words, the greeks wouldn't care
00:38:04 <allbery_b> bah.  unicode gave APL's lamp and quote-quad their own smbols but we can't have a real lambda?
00:38:46 <jsnx> well, i am morally opposed to a new lambda
00:38:47 <ddarius> "mathematical lambda"?
00:39:02 <jsnx> soon we'll need a mathematical x
00:39:11 <jsnx> mathematical sigma and so forth...
00:39:26 <sjanssen> jsnx: IIRC, math sigma already exists
00:39:35 <allbery_b> at least they didn't give the program abort its own symbol :)
00:39:43 <sjanssen> there is some precedent for this
00:39:53 <allbery_b> yeh, pretty sure there's already custom sigma and pi for math
00:40:13 <allbery_b> (uppercase pi for products, not lowercase)
00:40:44 <aFlag> ?users darcs
00:40:45 <lambdabot> Maximum users seen in darcs: 1, currently: 0 (0.0%), active: 0 (NaN%)
00:40:51 <aFlag> hm
00:40:57 <aFlag> ?users #darcs
00:40:57 <lambdabot> Maximum users seen in #darcs: 42, currently: 33 (78.6%), active: 0 (0.0%)
00:41:04 <allbery_b> @users #darcs
00:41:04 <lambdabot> Maximum users seen in #darcs: 42, currently: 33 (78.6%), active: 0 (0.0%)
00:41:09 <allbery_b> oops
00:41:16 * allbery_b tired
00:41:20 <aFlag> I thought darcs would be one of the biggest
00:41:58 <allbery_b> not that many darcs developers, and for most people darcs Just Works so they don't need to yell for help on IRC :)
00:42:43 <jsnx> damn, i crashed my browser browsing the unicode database...
00:44:17 <aFlag> how good would it be if we could get ready of browsers?
00:44:32 <jsnx> aFlag: get rid of them?
00:44:43 <aFlag> rid
00:44:44 <aFlag> that's it
00:45:10 * allbery_b browses gucharmap instead
00:45:48 <jsnx> aFlag: i think they do too much work, quite frankly -- but they're good at what they do
00:45:57 <allbery_b> (the real solution is to write a browser in haskell, y'know }:> )
00:46:08 <jsnx> why aren't i using, say, `grep` to browse the unicode database?
00:46:33 <jsnx> well, why isn't there an easy way to mount and browse their resources as a file system?
00:47:13 <aFlag> I feel like browsers should just show some formated text, a few pictures and stuff like that. But when you start embedding too much stuff on it things get out of hand.
00:47:42 <jsnx> aFlag: i guess i feel like the problem is really with website providers
00:47:56 <dons> its hard to keep features out of popular open source apps
00:48:01 <jsnx> they should go out of their way to provide filesystem access
00:48:02 <dons> esp. with many contributors
00:48:14 <dons> and when the spec is vague
00:48:22 <jsnx> so that we can have a compact, low bandwidth way to get their data
00:48:42 <jsnx> instead of providing all these turned up to eleven bullshit sites
00:48:52 <jsnx> why does unicode.org even need a web site?
00:49:19 <jsnx> can they just dump a few READMEs and character lists and PDFs in a network share, and let us at it?
00:49:31 <wolverian> my gnome panel doesn't like xmonad, sniff
00:49:38 <jsnx> and then make a stupid little web app for those who are so inclined
00:49:50 <aFlag> yeah, but what I think is that it would be great if there was like firefox for browsing the web, and a separete program, like mplayer to stream the videos, so instead of opening that crappy flash interface on youtube I'd just use mplayer, and so on
00:49:56 <jsnx> the web app can say "learn to use samba, you twat"
00:50:24 <jsnx> aFlag: well even better would be, you mount youTube at ~/youTube
00:50:34 <jsnx> aFlag: and double click on the files to open mplayer
00:50:36 <aFlag> that would be really great
00:50:52 <daco77> !list
00:50:53 <jsnx> but of course, there is no way to hood ad revenue to that...
00:51:00 <jsnx> s/hood/hook/
00:51:15 <aFlag> well, you can have the ads on the video itself
00:51:21 <jsnx> ah, yes
00:51:42 <jsnx> see, and that's where the browser comes in
00:52:01 <jsnx> because html+js is a great ad/pr0n delivery platform
00:52:16 <aFlag> yeah, that makes sense
00:52:28 <jsnx> so, if we want to have a world wide anything, it has to be incentivized properly
00:52:45 <jsnx> and now that the military isn't paying for it, it's got to be pr0n and ads
00:53:05 <aFlag> yeah, that's true
00:53:06 <jsnx> sad, i think, but unavoidable
00:53:30 <jsnx> so, that's my hate on "data that ain't on filesystems"
00:53:39 <jsnx> thank you for listening, all
00:53:46 <aFlag> hehe
00:54:59 <sjanssen> wolverian: there are some extensions you can use for that
00:55:20 <wolverian> according to the page I shouldn't need to do anything but set the gap
00:55:33 <sjanssen> the page is out of date
00:55:41 <wolverian> uh, ok. :)
00:55:43 <sjanssen> see XMonad.Hooks.ManageDocks
00:55:55 <wolverian> thanks
00:58:22 <wolverian> is there a defaultLayout or something?
00:58:39 <wolverian> so that I can say myLayout = avoidStruts defaultLayout
00:58:40 <aFlag> wolverian, I advise you to take a look on dzen, it's actually quite flexible. I used to use gnome-panel as well but with only very small changes on gaim I was able to even display "new message" when a message arrived
00:59:00 <wolverian> aFlag, I have too many applets to really want to do that :)
00:59:24 <jsnx> if we do allow sigma for sum, pi for product (and that number), and also lambda -- we can have -XHellenicLeague
00:59:35 <aFlag> oh, I see
00:59:51 <jsnx> that will make it sound pro greek, even though it discriminates against greek programmers!
01:00:21 <sphynx> hi again
01:00:35 <jsnx> hi
01:01:21 <aFlag> wolverian, I don't think I follow you, you can just add new layouts by adding ||| Newlayout or remove them by deleting their names. Do you want something else?
01:01:39 <wolverian> sjanssen, the example layout line on the .ManageDocks doc gives compile errors on missing "tall" and such.
01:02:45 <wolverian> aFlag, I want to use the default set of layouts with XMonad.Hooks.ManageDocks's avoidStruts function. looking at the haddock documentation, I am supposed to do 'layoutHook = avoidStruts (layouts)'.
01:02:55 <aFlag> oh, you're talking about the layout in the ManageDocks
01:03:01 <aFlag> yeah, I just saw that
01:03:16 <wolverian> now, assuming I just want the default set of layouts...
01:04:05 <wolverian> I don't see how to do that.
01:04:32 <aFlag> I think if you simply add avoidStruts ( ... ) to the layouts in your xmonad.hs it should work
01:04:47 <wolverian> right, but I don't have such a line! I don't want to define the set of layouts myself.
01:04:52 <aFlag> (after compiling and installing the contrib stuff, of course)
01:04:55 <wolverian> I just want the defaults.
01:04:59 <wolverian> (+ avoidStruts)
01:05:02 <sphynx> I have a question about UTF-8. Currently I'm using System.IO.Encoding lib, it seems to work well and satisfies almost all my needs. But there is an issue I'd like to discuss.
01:05:02 <sphynx> This lib provides only function hGetContents :: Encoding e => e -> Handle -> IO String for reading from file. Later it assumes working with ByteString, not simple strings. So, initially I need to do something like content <- IOEnc.hGetContents UTF8 log and then pack it to ByteString. Is there some way of using BS.hGetContents instead of this one?
01:05:02 <sphynx> I've tried the following:
01:05:02 <sphynx>     bs <- BS.hGetContents log
01:05:04 <sphynx>     let ubs = Enc.recode ISO88591 UTF8 bs
01:05:05 <aFlag> wolverian, copy the xmonad in the man direcotry
01:05:06 <sphynx> but it doesn't work..
01:05:23 <aFlag> wolverian, perhaps we should talk about that in #xmonad
01:05:32 <wolverian> aFlag, I'll take a look, thanks. of course, cabal-install doesn't install manpages (yet?)...
01:05:35 <wolverian> aFlag, ah, true.
01:06:33 <sphynx> I've read in documentation that ByteString assumes that file content is in ISO-8859-1, so I don't understand why reading it with BS.hGetContents and recoding then to UTF8 does not work for me. Any ideas?
01:06:57 <sphynx> sorry for too large messages
01:09:54 <sjanssen> wolverian: you can use "layoutHook = avoidStruts $ layoutHook defaultConfig"
01:10:17 <wolverian> thanks.
01:11:57 <aFlag> the defaultConfig is available on xmonad.hs?
01:12:29 <sjanssen> it is exported by XMonad
01:12:35 <wolverian> yes, that is available. I just thought this way would lead to recursion, but it doesn't. :)
01:13:16 <wolverian> I wonder how I should exit my session, as I can't see the gnome menu bar... just killing X seems a bit drastic
01:13:55 <wolverian> ah well, killing
01:15:32 <sjanssen> mod-shift-q
01:15:39 <wolverian> thanks
01:15:58 <wolverian> hm, crap. can't find XMonad.Hooks.ManageDocks. ghc-pkg sees it though. did I manage to mistype it?
01:20:24 <wolverian> weird, now it works. :)
01:24:00 <levi13> hi, I'm having troubles compiling a program using the HTTP package
01:24:14 <levi13> l'm getting link errors. Any ideas?
01:25:02 <Cale> levi13: are you compiling with --make ?
01:25:20 <levi13> no, I'll give that a go
01:25:28 <Cale> --make will fix the most common sources of link errors
01:25:38 <levi13> thanks Cale, that's worked
01:27:44 <Cale> levi13: The basic issue is that the HTTP modules are in a separate package which needs to be selected. The --make flag will try to sort out which packages are needed, but you can also specify them explicitly, like -package http
01:28:10 <Cale> levi13: Or, if you use cabal to build your program, in the dependency list in your .cabal file.
01:30:31 <levi13> thanks, that makes sense
01:40:21 <levi13> Would the HTTP library listed on hackage be considered the 'standard' one?
01:40:53 <matthew-_> levi13: yes, I use that library quite a lot
01:40:56 <matthew-_> it's quite nice
01:41:41 <levi13> I'm playing around with it a bit now
01:41:55 <levi13> Is there an implementation of Stream for Handles?
01:42:17 <levi13> It would be good to be able to use the simple socket methods in Network, rather than the lower level ones in Network.Socket
01:43:38 <matthew-_> yeah. can you not extract the stream from the handle?
01:43:47 <matthew-_> it's not something I've tried to do...
01:46:02 <levi13> I only see an instance of Network.Stream for Socket
01:47:21 <matthew-_> well a Handle contains a Socket so surely you can get the socket out of the handle?
01:48:19 <levi13> oh, ok. I thought Handle was a general type used for lots of things, like File reading/writing as well for example
01:48:53 <matthew-_> it is, I now realise!
01:48:55 <jsnx> levi13: i think so...
01:49:06 <matthew-_> socketToHandle :: Socket -> IOMode -> IO Handle -- is exactly the wrong way round
01:49:43 <levi13> yes, but maybe I'm avoiding a different problem - as my code with the low level sockets isn't working ;)
01:49:47 <jsnx> why would a handle not be able to emulate a socket?
01:50:20 <matthew-_> yeah, wouldn't a handle be a strict superset of a socket
01:50:27 <Zao> What about Windows?
01:50:48 <Zao> Sockets and Handles are rather different things there.
01:50:57 <levi13> yes, I could make Handle an instance of Network.Stream, but it seems like something that would have been done before
01:51:34 <matthew-_> it would require a deal of effort to make it performant too, probably
01:51:47 <levi13> Handle is a good abstraction for sockets (see socketToHandle)
01:52:05 <jsnx> Zao: can you say a little more about that?
01:52:07 <levi13> http://hpaste.org/4829 - that is my non-working code, if anyone has suggestions, I would be grateful
01:52:30 <levi13> It doesn't accept connections - just prints binding, listening, accepting
01:52:48 <Zao> jsnx: I know that the WinSock select isn't like others.
01:53:05 <Zao> Which I assume Network uses somewhere deep inside.
01:53:15 <jsnx> Zao: true
02:20:52 <radetsky> I was trying to build hmp3 and it imported packAddress, which it couldn't find. I found unsafePackAddress in Hoogle. Does this do the same thing?
02:22:18 <radetsky> anybody? dons?
02:24:11 <Cale> radetsky: dons should know, I'm not sure. I'll look into it a bit and let you know if I figure anything out, but I'm going to bed shortly.
02:24:40 <radetsky> ok, thanks
02:27:02 <Cale> I'm somewhat surprised that it would use such a function.
02:27:31 <radetsky> it's used as e.g. packAddress <string>#
02:27:40 <Cale> ah
02:27:46 <radetsky> which is how unsafePackAddress is documented on Hoogle
02:27:59 <Cale> You might just try replacing that with  pack <string>
02:28:20 <Cale> It's only a trivial amount less efficient.
02:28:22 <radetsky> but I found old code which uses unsafePackAddress the way unsafePackAddressLen is doc'd on Hoogle
02:28:59 <radetsky> I'm hesitant to do that because I don't know the API of any of this stuff
02:29:07 <radetsky> but let me check
02:29:23 <radetsky> I'm not terribly concerned about efficiency (yet)
02:30:09 <Cale> Basically, it's constructing the ByteString by pointing directly at the string literal in the code, rather than building a string as a list of characters and packing that.
02:33:39 <radetsky> if I were to do that, wouldn't I have to convert all the Addr#'s to [Word8]'s, i.e. take off all the trailing #'s in the code?
02:34:41 <Cale> Yes, turn the unboxed string literals into ordinary ones.
02:34:56 <radetsky> it's seems like it'd be a lot easier to just s/packAddress/unsafePackAddress/
02:35:05 <radetsky> how important is it for app safety?
02:35:25 <radetsky> referential transparency: serious business?
02:35:32 <Cale> unsafePackAddress should be fine.
02:36:29 <Cale> The unsafety has to do with what happens when you pass it a different Addr#
02:36:38 <Cale> For instance, the location of a mutable variable.
02:37:28 <Cale> You end up with a ByteString which will reflect changes in that variable, which means that its value depends on which side effects have already happened.
02:37:58 <Cale> If you're passing it the location of a literal, that memory's never going to change, so it's safe.
02:38:02 <radetsky> I assume this is what packAddress used to do?
02:38:12 <Cale> Yes, I'm pretty sure that's the case.
02:38:29 <radetsky> ok
02:38:53 <radetsky> i'm super n00b, so I'm trying to think about implementation lazily, so to speak
02:39:37 <Cale> Lots of things in the ByteString library were prefixed with unsafe between the version which hmp3 expects and the present one.
02:40:38 <Cale> hmm, I wonder what createAndTrim did
02:41:02 <radetsky> wait, nm, changing to "pack" was the right thing to do
02:42:06 <radetsky> I fail at reading APIs
02:42:43 <Cale> oh, has the type changed?
02:43:14 <radetsky> yeah
02:43:33 <radetsky> s/ByteString/IO ByteString/
02:43:38 <radetsky> kind of makes sense
02:43:41 <Cale> Yeah, that won't do :)
02:43:47 <Cale> So yeah, use pack.
02:44:13 <Cale> Good luck. There are some more interesting changes to deal with there as well. Apparently nobody's touched hmp3 for a little while.
02:44:52 <radetsky> I figured
02:45:12 <Cale> If dons shows up, he'd know. Also, dcoutts would have a pretty good handle on how the ByteString stuff has changed.
02:45:41 <radetsky> I think I've got it, but thanks. I'll pester them if more stuff goes wrong
02:45:58 <Cale> ah, createAndTrim still exists, it's just moved to Data.ByteString.Internal
02:46:46 <radetsky> yeah, my first move was to replace Data.ByteString.Base with Internal/Unsafe
02:50:31 <Cale> copyCString -> packCString (the safe one copies now)
02:57:32 <radetsky> shit, it looks like nothing takes Addr# -> ByteString
02:57:39 <radetsky> is hoogle reliable?
02:59:47 <radetsky> I guess I could just define packAddress as unsafePackAddress . unsafePerformIO everywhere
03:00:15 <radetsky> somehow this sounds like a bad idea
03:00:39 <radetsky> or other way around
03:05:55 * Corun solves all concurrency problems evar
03:15:15 <blackdog> ah, finished the prototype. now i get to translate 100 lines of haskell into Java. Fun!
03:21:42 <b_jonas> blackdog: ouch
03:22:06 <b_jonas> is the code full of untranslatable "smart" haskellisms?
03:33:00 <aFlag> I want something like lines but I want to set the Char where it has to split, what's the function for that?
03:33:28 <jsnx> aFlag: unfoldr
03:33:37 <jsnx> aFlag: with a little doing
03:34:39 <jsnx> to the best of my knowledge, there is no `split :: a -> [a] -> [[a]]`
03:35:05 <jsnx> i'm trying to remember the last time i wrote such a thing...
03:35:09 <aFlag> hm, I'll just copy lines code and make the change
03:35:33 <jsnx> aFlag: i wonder if it actually has unfoldr in it...
03:35:41 <aFlag> if there was I'd expet lines to use it
03:35:50 <aFlag> no, it uses recursion and break, seems like
03:35:54 <desegnis> @src lines
03:35:54 <lambdabot> Source not found. That's something I cannot allow to happen.
03:37:11 <desegnis> Stupid bot :)
03:38:47 <jsnx> ?botsnack
03:38:47 <lambdabot> :)
03:39:12 <jsnx> it's not its fault, it's the creator's...
03:43:08 <jsnx> :t break
03:43:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:44:58 <jsnx> > unfoldr (\s -> if s /= [] then Just break ':' s else Nothing) "string:like:a:path:string"
03:44:58 <lambdabot>  Couldn't match expected type `Char -> [a1] -> Maybe (a, [a1])'
03:45:14 <jsnx> > unfoldr (\s -> if s /= [] then Just (break ':' s) else Nothing) "string:like:a:path:string"
03:45:14 <lambdabot>  Couldn't match expected type `a -> Bool'
03:45:29 <jsnx> > unfoldr (\s -> if s /= [] then Just (break (== ':') s) else Nothing) "string:like:a:path:string"
03:45:30 <lambdabot>  ["string","","","","","","","","","","","","","","","","","","","","","","",...
03:45:45 <jsnx> > unfoldr (\s -> if s /= "" then Just (break (== ':') s) else Nothing) "string:like:a:path:string"
03:45:45 <lambdabot>  ["string","","","","","","","","","","","","","","","","","","","","","","",...
03:46:15 <jsnx> > break (== ':') "string:like:a:path:string"
03:46:16 <lambdabot>  ("string",":like:a:path:string")
03:46:26 <jsnx> oh, i see
03:50:05 <jsnx> > let { split thingy [] = Nothing ; split thing array = Just (a, drop 1 b) where (a, b) = break (== thingy) array } unfoldr (split ':') "string:like:a:path:string"
03:50:05 <lambdabot>  Parse error at "unfol..." (column 115)
03:50:15 <jsnx> > let { split thingy [] = Nothing ; split thing array = Just (a, drop 1 b) where (a, b) = break (== thingy) array } in unfoldr (split ':') "string:like:a:path:string"
03:50:15 <lambdabot>   Not in scope: `thingy'
03:50:27 <jsnx> > let { split thingy [] = Nothing ; split thingy array = Just (a, drop 1 b) where (a, b) = break (== thingy) array } in unfoldr (split ':') "string:like:a:path:string"
03:50:28 <lambdabot>  ["string","like","a","path","string"]
03:50:52 <jsnx> of course that would look totally different if i put it in a source file
03:50:55 <jsnx> i never use let
03:53:31 <jsnx> i so hate having to use break for that
03:53:47 <jsnx> it would be so nice to have a split somewhere -- i'm sure it's in hackage or something...
03:55:00 <jql> google agrees with you. I see a couple implementations out there
04:00:54 <blackdog> b_jonas: it's not too bad. i'll miss HOFs and list comprehensions like mad, though
04:01:43 <blackdog> still, at least i know how the thing is supposed to work before i pervert it into something ugly.
04:39:49 <dcoutts> Cale: what was the bs api question?
04:57:49 <matthew-_> ok, I want to do (a, m b) -> m (a, b)
04:58:15 <matthew-_> @djinn (a, m b) -> m (a, b)
04:58:16 <lambdabot> -- f cannot be realized.
04:59:40 <mauke> :t \(a, mb) -> do { b <- mb; return (a, b) }
04:59:43 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t, t1 t2) -> t1 (t, t2)
05:00:00 <mauke> @. pl undo \(a, mb) -> do { b <- mb; return (a, b) }
05:00:00 <lambdabot> uncurry (fmap . (,))
05:00:26 <matthew-_> right, I'd got as far as the fmap and (,)
05:00:40 <matthew-_> and then I'd just thought about (&&&)
05:00:55 <Corun> Hey there, Matt
05:01:05 <matthew-_> ahh, hi there Stoodent
05:01:08 <matthew-_> ;)
05:01:12 <Corun> Heh.
05:01:21 <Corun> No more advanced haskell lectures :/
05:01:29 <matthew-_> jooi, was I on the SOLE forms?
05:01:46 <Corun> Oh.. Hmm, I don't think so, now that you mention it
05:02:04 <matthew-_> ok.
05:03:39 <Corun> I read your blog post on shared memory, btw. But, I think there's another problem.
05:03:54 <matthew-_> there are many problems. But Haskell can solve them all ;)
05:05:06 <Corun> Lets say I've got my 64 core processor, and I'm writing some game. I don't see how one would take full advantage of the processor with an actor/message passing paradigm. I mean, I haven't done any erlang, really. But, it seems like it would be difficult to program an application with that many processes.
05:05:54 <matthew-_> different mental model. You just shift how you abstract things
05:06:06 <matthew-_> eg, in breakout, you'd have each block as a separate process
05:06:29 <Corun> And how would you render it?
05:06:37 <matthew-_> in general it's hard, but you just tend to think about every discrete thing that can exist as a separate process and do that
05:06:49 <matthew-_> err, well you just ask each process to render itself
05:07:01 <matthew-_> it's just a simple matter of programming (TM)
05:07:09 <pejo> Corun, there's a limit on how much parallelism you can extract out of a problem as well.
05:07:21 <Corun> Render itself to what?
05:08:09 <Corun> Well, I guess so
05:08:50 <matthew-_> Corun: right, so what you're actually saying is that there are somethings where it doesn't make sense to pretend there are multiple copies of it - eg the screen/gpu
05:09:00 <matthew-_> (slightly ironic given the parallelism in a gpu these days)
05:10:03 <matthew-_> lol
05:10:04 <matthew-_> >  (uncurry (fmap . (,)) . fmap (fmap (+5))) (True, return 3)
05:10:06 <lambdabot>   add an instance declaration for (Show (f (Bool, a)))
05:10:18 <matthew-_> oh bugger off and load the right instances Î»b
05:10:44 <matthew-_> >  ((uncurry (fmap . (,)) . fmap (fmap (+5))) (True, return 3)) :: Maybe (Bool, Int)
05:10:47 <lambdabot>  Just (True,8)
05:10:56 <matthew-_> >  ((uncurry (fmap . (,)) . fmap (fmap (+5))) (True, fail "foo")) :: Maybe (Bool, Int)
05:10:57 <lambdabot>  Nothing
05:11:06 * matthew-_ smiles
05:11:38 <Corun> What's that doing?
05:12:00 <matthew-_> @type (uncurry (fmap . (,)) . fmap (fmap (+5)))
05:12:01 <lambdabot> forall a a1 (f :: * -> *). (Num a1, Functor f) => (a, f a1) -> f (a, a1)
05:12:07 <matthew-_> it's doing that ;)
05:13:17 <ddarius> It's a strength
05:13:28 <matthew-_> which I now realise isn't quite what I need...
05:13:50 <matthew-_> @type (uncurry (fmap . (,)) . fmap (return . (+5)))
05:13:51 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m, Num a1) => (a, a1) -> m (a, a1)
05:13:59 <matthew-_> yes, that's better
05:14:49 <matthew-_> Corun, it basically says, if the function (return . (+5)) doesn't fail, then take the lhs of the tuple and include that in the result
05:15:13 <matthew-_> the return . (+5) is just an example for testing - I have something bigger to go in there...
05:15:37 <hpaste>  matthew-_ pasted "...is what it actually looks like" at http://hpaste.org/4830
05:16:33 <Corun> Why do you have to do that in such a complex way? :-P
05:16:52 <ddarius> @google strong monad
05:16:53 <lambdabot> http://en.wikipedia.org/wiki/Strong_monad
05:16:53 <lambdabot> Title: Strong monad - Wikipedia, the free encyclopedia
05:17:21 <Corun> Oh no. Lots of diagrams 'n' stuff.
05:17:46 <matthew-_> Corun: it's the Haskell way. You get used to it - you tend to just start writing in terms of Monads and Functors
05:18:41 <matthew-_> ddarius: ahh, so I've built the t_A,B transformation then?
05:19:20 <ddarius> matthew-_: With the uncurry (fmap . (,)), yes.
05:19:40 <matthew-_> ok, so mauke did that then ;)
05:20:54 <Corun> Maybe it'd help if I really _got_ Monads. (And if I knew what a Functor was (And if I knew what fmap does (Though, I can guess (Nested brackets...))))
05:21:47 <matthew-_> I gave you a lecture on Monads!
05:21:57 <matthew-_> and you all pretended that you knew what I was going on about!
05:22:41 <matthew-_> s/knew/understood/
05:23:30 <b_jonas> "Instances of both Monad and Functor should additionally satisfy the law: fmap f xs  ==  xs >>= return . f"
05:23:35 <matthew-_> so a Functor, I tend to think of, as a cut down monad where you can lift stuff into in (fmap) but you don't have >>=
05:23:43 <b_jonas> so that's how it works
05:24:24 <Corun> Hmm, I can't remember how well I understood at the time. But I don't fully understand them now. I can only really understand them enough to do basic stuff. Like, I started writing a pong game
05:24:32 <matthew-_> for lists, fmap = map. For Maybe, Either a, etc, fmap is pretty obvious - just apply the function to the value being carried
05:25:25 <b_jonas> matthew-_: yes, I knew that, but I didn't get the connection with monads
05:25:25 <matthew-_> IO is a bad monad really. I like working in Either a (under Control.Monad.Error) and Maybe
05:25:54 <matthew-_> b_jonas: sorry, that was more directed at Corun, not you :)
05:26:07 <ddarius> A bunch of new Catsters stuff.
05:26:26 <Corun> The problem is, I can't really think of how to get experience with monads
05:26:30 <matthew-_> howdy ToRA. We have a stoodent here ;)
05:26:38 <ToRA|home> heyyup
05:26:41 <b_jonas> Corun: the only way is to write code I think
05:26:51 <Corun> Heya Tora
05:27:03 <chatcopitecos> I'm trying to implement Eratostene's sieve, and make it return and infinite list of prime numbers
05:27:17 <chatcopitecos> but I'm not able to do it
05:27:20 <b_jonas> oh...
05:27:25 <chatcopitecos> anyone has the solution?
05:27:26 <ddarius> Indeed, fmap's implementation is pretty mechanical.
05:27:49 <hpaste>  ToRA pasted "mapA (A for Arrow)" at http://hpaste.org/4831
05:28:10 <Corun> I saw your little blog on arrows, tora
05:28:10 <b_jonas> chatcopitecos: that must be like that famous Hamming Numbers thingy
05:28:17 <ToRA|home> could someone who knows stuff about Arrows let me know if that's sane?
05:28:26 <b_jonas> (http://lua-users.org/wiki/HammingNumber and http://lua-users.org/wiki/HammingNumbersVariant that is)
05:28:33 <ToRA|home> Corun: yay
05:28:38 <xerox> chatcopitecos: primes = 2 : 3 : [n | n <- [5,7..], all (\p -> mod n p /= 0) (takeWhile (\p -> p*p <= n) primes)]
05:28:41 <Corun> I don't understand them though :-P
05:28:59 <ToRA|home> Corun: neither do i, which is why I doodle on my whiteboard instead...
05:29:05 <matthew-_> Corun: I wouldn't worry too much about that yet - you have years of Java-brain-rot ahead of you
05:29:08 <b_jonas> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> mod n p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes -- let me try that
05:29:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:29:20 <chatcopitecos> xerox: I'm trying to digest what you wrote
05:30:41 <b_jonas> @undo [n | n <- [5,7..], all (\p -> mod n p /= 0) (takeWhile (\p -> p*p <= n) primes)]
05:30:41 <lambdabot> concatMap (\ n -> if all (\ p -> mod n p /= 0) (takeWhile (\ p -> p * p <= n) primes) then [n] else []) [5, 7 ..]
05:30:52 <b_jonas> @undo [5, 7 ..]
05:30:52 <lambdabot> [5, 7 ..]
05:31:05 <matthew-_> does anyone know if the guitarists in Muse actually play these insane guitar parts or is it all computer?
05:32:15 <jsnx> matthew-_: we're discussing it in #haskell-blah
05:33:59 <DukeDave> \j #f#
05:34:07 <DukeDave> Whoops
05:34:10 * DukeDave ducks
05:34:52 <Corun> Tora, you're the concurrency dude. What do you think the future will be? Hardware STM (I guess that'd be HTM, then...) or Message Passing or something else?
05:35:25 <Kolji[Z]> the future is Orange
05:35:33 <chatcopitecos> xerox: I don't think I agree with your solution
05:35:34 <ToRA|home> Corun: no, no, matthew is the concurrency dude, I'm just a bystander
05:35:50 <matthew-_> @slap Kolji[Z]
05:35:50 * lambdabot moulds Kolji[Z] into a delicous cookie, and places it in her oven
05:36:04 <chatcopitecos> if I understand it correctly, it verifies if each number is prime
05:36:16 <ToRA|home> Corun: i think the future will be a mixture of different paradigms which are appropriate for different situations, much as it is now...
05:36:20 <xerox> Yeah, it is not Erathostene's sieve.
05:36:31 <Corun> Pfft, that's no fun Tora. You've gotta take sides!
05:37:26 <chatcopitecos> but is it possible to implement _the_ Eratostene's sieve and have it return an infinite list?
05:38:11 <Corun> Er. I wouldn't have thought so... Though maybe
05:38:22 <Corun> Because, you've got to sieve each number infinitely
05:38:32 <Corun> In the list.
05:38:48 <xerox> chatcopitecos: http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
05:38:49 <lambdabot> Title: Sieve of Eratosthenes (Haskell - LiteratePrograms
05:38:58 <Corun> Actually, maybe you can.
05:40:05 <Corun> I don't know :-P
05:40:29 <chatcopitecos> xerox: thanks for the link
05:41:40 <Corun> Here's a question. What's the largest haskell program?
05:42:00 <Botje> it's the one you're about to write :)
05:42:19 <Corun> It is?
05:42:28 <matthew-_> Corun: and then if you paste bits of it to #haskell (via hpaste) then it'll suddenly shrink lots
05:42:32 <pejo> Corun, ghc is quite large.
05:42:39 <mux> I guess GHC is the biggest haskell program
05:42:47 <mux> and darcs is probably the 2nd biggest )à
05:42:49 <mux> =) rather
05:43:08 <matthew-_> darcs is really that big? loc?
05:43:09 <__pao__> Hi all :-)
05:43:51 <pejo> Corun, there's closed source stuff written in Haskell that we're probably not aware of as well
05:44:11 <matthew-_> yeah, presumeably galois have some big stuff
05:44:38 <Corun> I suppose more what I'm asking, is what evidence is there that haskell scales well to large complex programs.
05:44:56 <__pao__> sorry to bother...
05:45:10 <__pao__> does haskell (ghc) supports unicode natively?
05:45:10 <matthew-_> Corun: you don't scale *to* a "large complex program"
05:45:31 <matthew-_> Corun: a "large complex program" is what *can* result from a complex problem
05:45:33 <__pao__> is nfc nfd conversion supported?
05:46:48 <Saizan> __pao__: Char is 31 bit, so able to store unicode codepoints, but standard IO operation like getChar or putStr truncates to 8 bits, so we usually convert to/from utf8 on output/input
05:47:03 <astrolabe> Corun: I guess ghc is probably one of the biggest.
05:47:31 <matthew-_> __pao__: there are some libraries on hackage that can cope nicely with utf8 input and output
05:47:55 <Corun> Ok, well, you know what I mean. It's all very well doing the L systems thing in Haskell. What evidence is there that I'd be able to write (say) an MMORPG in Haskell without, er, "problems"?
05:48:00 <__pao__> Saizan: argh! basically then you can only rapresent unicode data but not work on it!
05:48:42 <__pao__> I'm very new to the language but I'm really falling in love
05:48:43 <b_jonas> > let primes = 2 : 3 : filter (\n -> let { s = ceiling (sqrt (0.5 + fromIntegral n)); } in all (\k -> 0 /= mod n k) (takeWhile (< s) primes)) (enumFrom 5) in take 100 primes -- highlight chatcopitecos
05:48:44 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:48:58 <b_jonas> this appears to work
05:49:01 <roconnor> Corun: My theory is that writing large correct programs is intrinsicly hard, and that writing incorrect programs in Haskell is hard; therefore, writing large programs is hard in haskell. :)
05:49:05 <__pao__> but  I really need full blown unicode support
05:49:06 <matthew-_> Corun: frankly, my opinion is that for hard problems, no programming language makes it easy. But a good programming language means that you can build better reusable components
05:49:09 <astrolabe> Corun: One issue I find with complex programs is that some functions have a lot of inputs.  I'm not convinced this is a bad thing though.
05:49:21 <pejo> Corun, what evidence is there that you can write large complex stuff in any language without problems? It's a difficult problem you're tackling.
05:49:22 <b_jonas> roconnor: lol
05:49:48 <roconnor> which seems to be close to what matthew-_  just said
05:49:49 <b_jonas> matthew-_: perl advocates claim the opposite
05:50:07 <matthew-_> perl advocates take a lot of drugs
05:50:19 <b_jonas> oh wait, it's not actually a contradiction
05:50:31 <b_jonas> they're saying "perl makes easy things easy and hard things possible" iirc
05:50:44 <b_jonas> which doesn't exactly contradict to what you were saying
05:50:51 <b_jonas> for it might still not make hard things easy
05:51:35 <matthew-_> b_jonas: ok, so I wouldn't say that you can't write reliable programs in Perl. But I would say that the language doesn't encourage you to do so in the same way that Haskell does
05:51:46 <Saizan> __pao__: you can manipulate it in memory nicely, and just convert on I/O
05:52:28 <__pao__> Saizan: ah ok!
05:52:58 <__pao__> I'm seeing that camomille supports nfc nfd conversion...
05:53:57 <__pao__> found: http://sloompie.reinier.de/unicode-normalization/
05:53:59 <lambdabot> Title: unicode-normalization Haskell package
05:54:16 <__pao__> but it seems a little bit "new" :-)
05:54:26 <__pao__> let's say... untested
05:56:26 <__pao__> Saizan: thanks :-) got to go now
05:57:10 <Corun> Ok, then, Matt, the next question is: What evidence is there that you can build good reusable components in haskell. I mean, after all, objected oriented programming is literally about making independent components.
05:57:35 <pejo> Corun, I think you want to read "Why functional programming matters".
05:58:20 <b_jonas> yeah, I'm not sure the haskell module system really supports large programs well
06:04:53 <jsnx> Corun: there is actually little evidence to support the idea that you can make good reuseable components in OO languages
06:05:23 <jsnx> in fact, reuseable components are not nearly as important as *readable* components
06:05:31 <jsnx> and haskell clearly rocks at that
06:08:15 <Nyoxi> hallo, I have a question about lambdabot, we'd like to disable some of it's features on channel #fi.muni.cz, is it possible to disable modules on the per-channel basis? who am I supposed to bug about it?
06:09:13 <ricky_clarkson> Nyoxi: dons.
06:13:21 <matthew-_> Corun: I do believe that haskell's underlying functional model leads to more reusable and composeable code than OO
06:14:14 <Corun> Why, though?
06:14:16 <ddarius> There is very little controlled evidence supporting any paradigm or methodology.
06:15:04 <matthew-_> Corun: personally, I think much of it is to do with how Haskell does not permit undocumented side-effects
06:16:27 <EvilTerran> except in the IO dumping-ground, anywat
06:16:34 <EvilTerran> and then they're *mostly* documented
06:16:51 <EvilTerran> (being limited to the RealWorld and IORefs and the like)
06:18:21 <vincenz> kosmikus: ping
06:19:14 <Corun> Fair enough, Matthew. So I guess I'll write my next big program in Haskell, then I'll blame you when it all goes wrong ;-)
06:20:09 <b_jonas> Corun: do you already know what that big program shell be?
06:21:07 <Corun> Nope
06:21:25 <matthew-_> Corun: ideally you should write it in several different languages and then compare. Then problem with that is a) time and b) approaches that are sound in one language may not be ideal in another
06:21:45 <Corun> Probably a game, though.
06:21:57 <EvilTerran> make a Z machine!
06:22:02 <EvilTerran> @go z-machine
06:22:03 <lambdabot> http://en.wikipedia.org/wiki/Z_machine
06:22:03 <lambdabot> Title: Z machine - Wikipedia, the free encyclopedia
06:22:18 <EvilTerran> not that one.
06:22:22 <EvilTerran> http://en.wikipedia.org/wiki/Z-machine
06:22:23 <lambdabot> Title: Z-machine (interpreter) - Wikipedia, the free encyclopedia
06:22:42 <b_jonas> is that the advanture thingy?
06:23:01 <ddarius> matthew-_: There is also another difficulty: after writing something the first time you'd have a much better grasp for the second (and third...) implementation.
06:23:01 <Corun> I was thinking of something more graphical...
06:23:02 <b_jonas> uh huh, it is
06:23:03 <Liskni_si> Nyoxi: well, i guess it'd be enough if we told people to privmsg it and possible paste the results if it's for more than themselves
06:23:11 <Liskni_si> *possibly
06:23:31 <b_jonas> Liskni_si: if you ask it in private, it tells you in private
06:23:49 <Nyoxi> Liskni_si: in most cases yes, but it won't help with the tinyurl crap
06:23:59 <EvilTerran> well, ZMs after 6 have rudimentary graphics
06:24:09 <Liskni_si> Nyoxi: well, i was suggesting that he part
06:24:17 <Liskni_si> b_jonas: yes, i know.
06:24:26 <Corun> I didn't say "Graphical" I said "More graphical" :-OP
06:24:54 <ddarius> Nyoxi: Unless something has changed recently, you cannot change modules per-channel.
06:24:55 <EvilTerran> @where frag
06:24:56 <lambdabot> http://www.haskell.org/haskellwiki/Frag
06:25:05 <ddarius> Nyoxi: You could, of course, run your own instance of lambdabot.
06:25:06 <Nyoxi> ddarius: too bad
06:25:07 <EvilTerran> exists at the other end of the spectrum
06:25:31 <ddarius> Nyoxi: Alternatively, you could submit a patch allowing per-channel options.
06:25:32 <Corun> I've seen that, looks cool. Yeah, that's the sort of thing I was thinking of.
06:25:50 <Nyoxi> Liskni_si: then I think it's settled, will send that bitch back to hell (... or wherever it came from) :)
06:26:02 <Liskni_si> Nyoxi: :)
06:26:12 <EvilTerran> for stuff like that, you'll want the OpenGL bindings, and probably gtk2hs to do the cross-platform stuff (windows etc)
06:26:50 <Corun> Well, there are GLUT bindings too
06:26:52 <EvilTerran> you could use OpenGL+GLUT, but GLUT's a dead project, and i don't know about you, but that makes me edgy
06:27:30 <Zao> EvilTerran: Well, there's always freeglut.
06:27:36 <EvilTerran> which is also dead.
06:27:52 <Nyoxi> so can anybody with enough privileges part lambdabot from #fi.muni.cz ?
06:28:01 <EvilTerran> last release was 9 June 2005
06:29:03 <EvilTerran> openglut likewise
06:29:12 <Zao> EvilTerran: There's not that much one can do with such a project.
06:29:19 <Zao> I'd say they're essentially final.
06:29:30 <ToRA|home> you can always do OpenGL + gtk if you're afraid of glut
06:29:33 <EvilTerran> still. makes me suspicious.
06:29:54 <EvilTerran> ToRA, exactly! that's what I said :)
06:30:18 <ToRA|home> :)
06:30:22 <ddarius> Nyoxi: You could always just kick her.
06:30:28 <EvilTerran> also, to be quite honest, from fiddling with the GLUT bindings, either the bindings or GLUT itself aren't terribly good
06:31:14 <EvilTerran> ISTR there's SDL bindings somewhere, too, which'd be another possibility
06:33:05 <Zao> I saw there were GLFW bindings added recently as well.
06:33:28 <EvilTerran> but i'd go for gtk2hs, out of personal bias (dcoutts's taught me stuff =])
06:34:15 <Zao> Does it play along with threads well yet?
06:34:34 <EvilTerran> ~\('.')/~
06:34:47 <Nyoxi> ddarius: won't the bot come back in time?
06:35:04 <EvilTerran> Nyoxi, only if you're using the MonadFix instance of it :P
06:35:25 <EvilTerran> ("back in time"... oh, never mind)
06:35:53 <Liskni_si> EvilTerran: :D
06:36:21 <ddarius> Nyoxi: No.
06:36:45 <ddarius> Unless it's been added to the list of channels it auto-joins which I'm assuming is not the case.
06:37:06 <Nyoxi> ddarius: fair enough
06:39:25 <Nyoxi> have a nice day/night/whatever :)
06:42:06 <roconnor> EvilTerran: we need to replace the Exception :<<loop>> message with Excetpion:<<Temproal Paradox>>
06:45:57 <Brian`> hello
06:49:11 <Brian`> could anyone tell me why I fail to build regex-base package..? I get the following message and it doesn't complete the build...:"Text/Regex/Base.hs:48:3:Warning: The export item `module Text.Regex.Base.Context' exports nothing"
06:49:58 <Brian`> why does it export nothing?
06:49:58 <Saizan> Brian`: try removing -Werror from the .cabal file
06:50:08 <Brian`> Saizan, ok i'll try
06:50:22 <LoganCapaldo> maybe it instantiates a class?
06:50:28 <shag> @pl (\ u t -> lookup u (docToId t))
06:50:28 <lambdabot> (. docToId) . lookup
06:51:33 <Brian`> Saizan, yeah! it worked :) Thanks. By the way, what does -Werror do?
06:51:49 <Saizan> Brian`: transforms warnings in errors
06:52:34 <Saizan> Brian`: without it warnings don't make ghc halt compilation
06:52:47 <Brian`> Saizan, aha i c..
06:53:34 <matthew-_> @pl (\keyPubsA keyPubsB -> compare (length . snd) (length . snd))
06:53:34 <lambdabot> const (const (compare (length . snd) (length . snd)))
06:53:36 <Brian`> Saizan, do you know why it does export nothing? If regex-base package exports nothing, how can one use that package?
06:53:51 <matthew-_> doh
06:54:10 <ToRA|home> matthew-_ heh
06:54:26 <matthew-_> @pl (\keyPubsA keyPubsB -> compare (length . snd $ keyPubsA) (length . snd $ keyPubsB))
06:54:26 <lambdabot> (. (length . snd)) . compare . length . snd
06:54:29 <Saizan> Brian`: it's  Text.Regex.Base.Context inside Text.Regex.Base that exports nothing, not the package or Text.Regex.Base
06:54:53 <matthew-_> hmm, I was thinking there should be some combination of curry, uncurry and arrow ops to make that nicer
06:55:12 <ToRA|home> that's what i'm thinking
06:55:26 <Saizan> ?type comparing (lenght . snd)
06:55:28 <lambdabot> Not in scope: `lenght'
06:55:33 <Saizan> ?type comparing (length . snd)
06:55:34 <lambdabot> forall a a1. (a1, [a]) -> (a1, [a]) -> Ordering
06:55:40 <matthew-_> ahh
06:55:43 <matthew-_> @src comparing
06:55:43 <lambdabot> Source not found. You untyped fool!
06:55:43 <Brian`> Saizan, ah.. i c thanks
06:55:47 <LoganCapaldo> why not \(_, a) (_, b) -> compare (length a) (length b)
06:56:01 <matthew-_> no reason in particular
06:56:11 <matthew-_> less lazy I guess, but it hardly matters here
06:56:43 <matthew-_> @where comparing
06:56:43 <lambdabot> I know nothing about comparing.
06:56:48 <ToRA|home> data.Ord
06:56:51 <matthew-_> to
06:56:51 <matthew-_> ta
06:57:02 <LoganCapaldo> @index comparing
06:57:03 <lambdabot> bzzt
06:57:04 <Saizan> ?type Data.Function.on -- also useful
06:57:05 <lambdabot> Couldn't find qualified module.
06:57:14 <Saizan> in 6.8
06:57:30 <LoganCapaldo> lambdabot: get upgraded you :p
06:57:35 <mux> comparing = compare `on`
06:57:43 <shachaf> @let on f g x y = g x `f` g y
06:57:45 <lambdabot> Defined.
06:57:57 <matthew-_> gotcha
06:59:35 <Saizan> ?seen Cale
06:59:35 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 4h 9m 4s ago.
07:00:26 <mux> > sortBy (comparing fst `mappend` comparing snd) [(2,1),(1,2),(1,1)]
07:00:27 <lambdabot>  [(1,1),(1,2),(2,1)]
07:00:39 <Saizan> ?tell did you also had a problem with ModuleT deriving MonadError IRCError when building lambdabot on 6.8.2?
07:00:39 <lambdabot> Consider it noted.
07:00:47 <Saizan> ?tell Cale did you also had a problem with ModuleT deriving MonadError IRCError when building lambdabot on 6.8.2?
07:00:47 <lambdabot> Consider it noted.
07:00:49 <mux> Saizan: I did
07:00:58 <mux> and he did too since he told me how to "fix" it
07:01:05 <Saizan> ah
07:01:13 <mux> changing MonadError IRCError to MonadError e
07:01:22 <Saizan> uuuh!
07:01:25 <mux> makes little sense to me but it works
07:01:31 <mux> it's probably due to a bug in ghc
07:01:46 <Saizan> i've written the instance by hand
07:01:51 <mux> Saizan: http://mu.org/~mux/lambdabot-ghc-6.8.2.patch
07:02:18 <Saizan> mux, so it's a regression in 6.8?
07:02:23 <mux> I suppose so
07:02:48 <Saizan> we should report it then
07:03:58 <Saizan> ah, and do you know why importing haskell98 modules in L.hs causes linking errors?
07:05:03 <did> @clear-messages
07:05:04 <lambdabot> Messages cleared.
07:05:11 <hrehf> hrrrmmm, "The standard do { .. ; .. } notation combines the actions [...]" - can somebody point me to info on how this is done / works?
07:05:32 <mux> Saizan: not precisely
07:05:34 <hrehf> or maybe just some keywords i might search for
07:05:46 <Saizan> ?undo do { a; b}
07:05:47 <lambdabot> a >> b
07:06:11 <mux> @undo do { x <- a; b x }
07:06:11 <lambdabot> a >>= \ x -> b x
07:06:25 <Saizan> ?google site:haskell.org monad as computation
07:06:25 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
07:06:33 <Saizan> no..
07:06:47 <hrehf> thank you :)
07:06:54 <Saizan> mux: but you had the same problem, irght?
07:07:09 <mux> Saizan: yes, see my patch which removes those modules
07:07:15 <ddarius_> hrehf: The Report has a clear and authoritative explanation of the desugaring of do-notation.
07:07:53 <hrehf> ddarius_ the report?
07:08:13 <hrehf> oh, the hs98 report?
07:09:18 <ddarius_> @where report
07:09:18 <lambdabot> http://www.haskell.org/onlinereport/
07:09:32 * hrehf reads
07:10:22 <shag> @pl (\d ds -> snd (insertWithId d ds))
07:10:22 <lambdabot> (snd .) . insertWithId
07:11:59 <Brian`> @src intersperse
07:11:59 <lambdabot> intersperse _   []     = []
07:11:59 <lambdabot> intersperse _   [x]    = [x]
07:11:59 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:37:33 <vincenz> @src intercalate
07:37:33 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:38:05 <vincenz> > intercalate ", " . words $ "apple banana pie"
07:38:05 <lambdabot>   Not in scope: `intercalate'
07:38:14 <vincenz> > List.intercalate ", " . words $ "apple banana pie"
07:38:14 <lambdabot>   Not in scope: `List.intercalate'
07:38:16 <vincenz> eh
07:38:26 <vincenz> @hoogle intercalate
07:38:26 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
07:38:26 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
07:38:26 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
07:38:31 <vincenz> > Data.List.intercalate ", " . words $ "apple banana pie"
07:38:32 <lambdabot>   Not in scope: `Data.List.intercalate'
07:39:32 <vvv> @pl foo xs xss = concat (intersperse xs xss)
07:39:32 <lambdabot> foo = (join .) . intersperse
07:40:01 <vvv> > ((join .) . intersperse) ", " . words $ "apple banana pie"
07:40:04 <lambdabot>  "apple, banana, pie"
07:41:42 <vincenz> DRMacIver: What language are you building?
07:42:21 <DRMacIver> vincenz: I'm not. I'm writing a Scala library. (Although funnily I have a post upcoming on the subject of "The language I would build if I had the time and inclination" :) )
07:42:22 <vincenz> vvv: or simply
07:42:31 <vincenz> > join . intersperse ", " . words $ "apple banana pie"
07:42:32 <lambdabot>  "apple, banana, pie"
07:42:42 <vincenz> DRMacIver: Aha :)
07:43:16 <Brian`> :k 3
07:43:17 <vincenz> vvv: was just surprised it'd give the src and not have the definitioin
07:43:17 <lambdabot> Only unit numeric type pattern is valid
07:43:18 <DRMacIver> vincenz: I wrote a mini-rant about how I thought Scala's vars were a stupid idea and it should just use first class references instead. This seems to have got me roped into writing a references library for Scalax. :)
07:43:19 <Brian`> :t 3
07:43:20 <lambdabot> forall t. (Num t) => t
07:43:24 <Brian`> :kind 3
07:43:29 <vincenz> DRMacIver: sort of like refs in ML?
07:43:47 <vincenz> DRMacIver: btw, why not "deref ref"
07:43:53 <vincenz> it's better than "ref deref"
07:43:54 <Brian`> hey, how is kind '*" differ from kind '#'?
07:43:55 <vincenz> it's just a plain function
07:44:00 <vincenz> (well in haskell notation)
07:44:08 <vincenz> Brian`: # is unboxed
07:44:31 * LoganCapaldo wonders if unboxedness really belongs in the kind system
07:44:43 <vincenz> LoganCapaldo: when I said it, that thought crossed my mind
07:44:55 <vincenz> That being said, it should be -somewhere- in the type system
07:45:00 <vincenz> and since not all types can be boxed, it's a kind thing
07:45:00 <Brian`> vincenz, what does it mean by unboxed?
07:45:06 <vincenz> Brian`: no dereferencing
07:45:10 <DRMacIver> vincenz: Exactly like refs in ML, yes. And prefix deref needs some trickery to make it work and runs into the mentioned problems with prefix operators and properties.
07:45:24 <vincenz> DRMacIver: well not make it an operator, a plain function, that was a haskell notation
07:45:55 <vvv> vincenz: yep, that's counterintuitive
07:46:20 <vincenz> Brian`: to give you an example
07:46:26 <vincenz> data a = Foo a
07:46:27 <DRMacIver> vincenz: Right, I know. And maybe providing that as a function is a good idea. But it also needs to be a method because individual reference types need to define an implementation. :)
07:46:39 <vincenz> Brian`: Foo contains a pointer to a type of type 'a'
07:46:53 <vincenz> if it were unboxed, you'd have a direct value inside the memory cell o Foo
07:47:07 <Brian`> vincenz, ok
07:47:20 <vincenz> Brian`: which also explains the difference between newtype and data
07:47:23 <vincenz> newtype a = Foo a
07:47:26 <vincenz> is unboxed
07:47:28 <vincenz> which means that
07:47:32 <Brian`> oh.. i c
07:47:37 <vincenz> Foo _|_ == _|_
07:47:44 <vincenz> since a null pointer would be a nullpointer directly to the foo
07:47:48 <vincenz> with data a = Foo a,
07:47:51 <vincenz> you can have Foo _|_
07:47:58 <Brian`> aha!
07:48:04 <vincenz> (a Foo with a null pointer, if you want to think of it in a c-manner)
07:48:11 <doserj> vincenz: you mean "data Foo a = Foo a", surely?
07:48:12 <Brian`> i've been wondering the difference between newtype and data too! and there it is :) thanks
07:48:18 <vincenz> obviously _|_ might not be a real nullpointer, it could be an infinite computation, but it gives you an idea
07:48:21 <vincenz> doserj: yes, typo
07:49:18 <vincenz> Brian`: newtype is like an opaque typedef, you're pointing to the actual data, no extra stuff in memory, but you get a different type so you can have a custom typeclass
07:49:21 <vincenz> ...instance
07:50:03 <vincenz> e.g. : instance Num Int where ....  ; newtype Positive = Positive Int; instance Num Positive wehre ...
07:50:10 <vincenz> no overhead, but separate instances
07:50:19 <vincenz> But you can't have alternates
07:51:18 <vincenz> Anywho, the concept is the same, but the idea is different.  newtype's are strict in their contents, but that is not quite the same as being unboxed. since you can only really store one type, the two ideas get conflated.  However, imagine having an array... an array of unboxed integers would not have pointers
07:51:34 * vincenz hopes he's not confusing it 
07:51:49 <vincenz> I am certain ghc experts like sjanssen or dons can be more precise
07:52:12 <vincenz> (and accurate)
07:52:19 * Brian` try to not get confused :)
07:52:21 <Saizan> well newtype is no more nor less strict than the type you're wrapping
07:52:26 <thoughtpolice> newtypes basically allow you to enforce more at the type level since they're optimized away at compile time.
07:53:16 <vincenz> I think, strictness is about the containing type, while unboxinig is about the contained type. you can only unbox certain types, like integers, cause you know they always have a value
07:53:24 <thoughtpolice> i.e. you can have newtype Str = Str String which is isomorphic to a string, but wrapped in the 'Str' constructor for the newtype. this allows you to create custom instances for things like QuickCheck's arbitrary class, so you can have more control over what exactly might be generated by arbitrary.
07:53:27 <vincenz> and have a specific size
07:53:58 <thoughtpolice> which is actually covered in the manual for quickcheck if you want an example
07:54:19 <vincenz> thoughtpolice: unStr arbitrary :)
07:54:28 <thoughtpolice> but the basic idea is it lets you enforce types a little more, but doesn't actually exist at compile time.
07:54:30 <vincenz> yay type system
07:55:12 <vincenz> @src Integer
07:55:12 <lambdabot> data Integer = S# Int#
07:55:12 <lambdabot>              | J# Int# ByteArray#
07:55:29 <Saizan> @src Int
07:55:30 <lambdabot> data Int = I# Int#
07:55:32 <ddarius> unboxedness has nothing to do with newtype or not.
07:55:48 <vincenz> ddarius: the strictness concept is the same
07:55:57 <thoughtpolice> Brian`: get the basic idea? :)
07:55:58 <vincenz> except one is about the contained type, the other about the containing type
07:56:18 <Brian`> thoughtpolice, I guess so.. i'm just reading it over and over to get the better idea :)
07:56:43 <vincenz> "Sensei, what is Zen?"  "Zen is Zen, grasshopper" "Ah, thank you Sensei!"
07:58:23 * vincenz grrs
07:58:45 * vincenz keeps defining custom collors in open-office impress, and whenever he opens presntations, they're not defined anymore
07:58:53 <thoughtpolice> Brian`: also if you enable generalized newtype deriving, it's really useful since it allows you to derive instances of things like Monad automatically.
07:59:14 <ddarius> DRMacIver: Scala not having lazy function parameters is not something that would be trivial to fix.
07:59:23 <thoughtpolice> for an example you can check out cale's tutorial:
07:59:31 <DRMacIver> ddarius: It already has call by name function parameters, so it is actually.
07:59:33 <thoughtpolice> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
07:59:34 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
08:00:11 <DRMacIver> ddarius: You can encode lazy function parameters with only one line of code overhead, so it damn well should be easy to fix. :)
08:00:59 <ddarius> DRMacIver: Ah, I didn't realize that it did (and I seemingly misread your blogpost earlier).
08:01:23 * Brian` reading Cale's tutorial
08:01:45 <DRMacIver> ddarius: The distinction probably isn't sufficiently clear if you're not familiar with Scala. Sorry about that.
08:02:39 <ddarius> DRMacIver: No, no.  The next sentence makes it clear, whether one is familiar with Scala or not, that it should be trivial.
08:02:53 <DRMacIver> ok.
08:03:06 <EvilTerran> whee, website's running mysql 3.23
08:03:17 <EvilTerran> hoorj~ for shitty cheap webhosts >:[
08:03:38 <ddarius> DRMacIver: I'm not sure what, if anything, I read the first time.
08:10:10 <araujo> morning
08:16:33 <Sizur> does Lennart Augustsson use #haskell?
08:17:02 <matthew-_> yeah, sometimes
08:17:04 <Sizur> @seen lennart
08:17:04 <lambdabot> I haven't seen lennart.
08:17:14 <Heffalump> @seen augustss
08:17:14 <lambdabot> I saw augustss leaving #haskell 2d 8h 46m 52s ago, and .
08:17:27 <Heffalump> that's his usual nickname
08:17:31 <Sizur> thanks
08:18:02 <Sizur> how do i leave a message?
08:18:26 <Heffalump> not sure
08:18:45 <dmhouse> ?help ?tell
08:18:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:18:46 <matthew-_> @tell
08:18:46 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
08:18:49 <dmhouse> ?help tell
08:18:49 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
08:18:50 <kpreid> "@tell augustss foo"
08:19:07 <dmhouse> ?help ask
08:19:08 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
08:19:16 <dmhouse> You can use that one too. It's essentially the same.
08:20:05 <matthew-_> shorter though
08:20:50 <dmhouse> It's implemented by the same function, but ?ask can be more natural when you want to ask a question.
08:21:20 <LoganCapaldo> ?axe
08:21:20 <lambdabot> Maybe you meant: arr ask
08:21:20 <Sizur> @tell augustss i sent you an email regarding printf. this message is just in case the email found your trash folder ;)
08:21:21 <lambdabot> Consider it noted.
08:22:10 <dmhouse> E.g. ?ask dmhouse whether foo > bar.
08:23:08 <LoganCapaldo> ?ask LoganCapaldo if he can tell himself
08:23:08 <lambdabot> You can tell yourself!
08:23:13 <Sizur> lol
08:24:03 <LoganCapaldo2> ?ask LoganCapaldo I think she's pretty smart too
08:24:03 <lambdabot> Consider it noted.
08:24:09 <LoganCapaldo2> ah
08:24:09 <matthew-_> agh, why do I keep writing LaTeX in HTML files?!
08:24:12 <LoganCapaldo2> blast
08:24:18 <LoganCapaldo2> @seen LoganCapaldo
08:24:18 <lambdabot> LoganCapaldo has changed nick to logancapaldo2.
08:24:18 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak just now.
08:24:57 <LoganCapaldo> not consistently smart apparently
08:24:58 <lambdabot> LoganCapaldo: You have 1 new message. '/msg lambdabot @messages' to read it.
08:25:04 <LoganCapaldo> @messages
08:25:05 <lambdabot> LoganCapaldo2 asked 1m 1s ago: I think she's pretty smart too
08:25:13 <hrehf> does "do { x <- getChar; putChar x }" actually get transformed to "getChar >>= \s -> putChar s"? (while "do {putChar 'x'; putChar 'y'}" would become putChar 'x' >> putChar 'y' ?
08:25:28 <LoganCapaldo> yes
08:25:32 <ddarius> hrehf: In all current implementations, yes.
08:25:44 <LoganCapaldo> @undo do { x <- getChar ; putChar x }
08:25:44 <lambdabot> getChar >>= \ x -> putChar x
08:25:54 <hrehf> ah ;)
08:26:22 <ddarius> hrehf: In theory, they only need to behave "as if" they did, but it's not clear what benefit would arise from -not- using the desugaring.
08:27:20 <dmhouse> LoganCapaldo: well, improve it if you like, but it could cause more problems than good.
08:27:43 <LoganCapaldo> I don't seen much call for that feature
08:27:52 <LoganCapaldo> *see
08:28:16 <LoganCapaldo> Only time it would ever get used would be to point out it's existence
08:28:27 <LoganCapaldo> s/it's/its/
08:29:42 <dmhouse> Yes, exactly.
08:37:34 <vincenz> @type <*>
08:37:35 <lambdabot> parse error on input `<*>'
08:37:40 <vincenz> @type (<*>)
08:37:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:40:00 <bos> <*> is ap for Applicative instances
08:40:30 <LoganCapaldo> <o> is darth vader's tie fighter
08:40:56 <loupgaroublond> |o| is a regular tie fighter
08:41:23 <vvv> @help ask
08:41:24 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
08:42:35 <vvv> Vader flies `Tie Advanced', iirc.
08:47:25 <LoganCapaldo> Hmm
08:47:42 <LoganCapaldo> I guess you can't get away with smiley face infix consturctors
08:48:07 <LoganCapaldo> maybe this guy :-$ but I was never quite clear what that was supposed to convey
08:48:48 <Sizur> this mouth is keeping a secret
08:49:23 <aFlag> maybe he has gold teeth
08:49:25 <vvv> "eat worms"? Ron's quote from "Harry Potter".
08:50:07 <Sizur> what's hairy potter?
08:50:36 <earthy> actualy, :->, :-<, :-?, :-!, :-# would all work.
08:51:15 <aFlag> :-< is a headless woman
08:51:17 <aFlag> scary
08:51:35 <Sizur> tiny arms
08:52:03 <Sizur> anorexic
08:52:26 <aFlag> let the girl be
08:52:33 <Sizur> no! feed her!
08:52:40 <aFlag> she already lost her head and arms
09:31:11 <matthew-_> yikes, danger identified if deriving Ord but custom Eq sets a == b where a < b or a > b
09:31:39 <matthew-_> maybe there should be a warning or something if you're deriving an instance which has a superclass which has been custom defined
09:32:51 * EvilTerran ponders methods of attaching algebraic properties to a typeclass such that you get a warning if the system can't prove they hold
09:33:12 <EvilTerran> or an error, although then we might as well be programming in Coq.
09:33:17 <matthew-_> well quite
09:34:04 <EvilTerran> it could at least be used to aid the generation of quickcheck properties
09:34:52 <loupgaroublond> why is wxHaskell considered higher level than gtkhs?
09:35:29 <EvilTerran> it is?
09:36:32 <loupgaroublond> i'm trying to remember where i've seen it, but there was some comment that wxhaskell follows some kind of higher level formalism than gtkhs
09:42:32 <dcoutts> loupgaroublond: it's api is a bit nicer in places but it doesn't follow any formalism
09:44:06 <loupgaroublond> ah
09:55:22 <desegnis> Some blog noise made me wonder whether it would be fun to have a language that is just like Haskell, but allows only structural recursion, and, for that matter, forbids any constructs that may lead to failure (no Â»headÂ« as long as we're not programming with dependant types). But to reinstate Turing-completeness, there would be a monad (or some other structure) that can describe general recursion, just like we have the IO monad which can de
09:55:22 <desegnis> scribe input/output actions.
09:57:02 <EvilTerran> so, as well as being able to tell from the type whether an expression may have side-effects, you'd be able to tell if it may be _|_?
09:57:21 <desegnis> Right.
09:58:31 <EvilTerran> @where Catch seems potentially relevant
09:58:31 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
09:58:49 <EvilTerran> although that just deals with exceptions, not infinite computation
09:59:12 <FunctorSalad> hmm you couldn't catch infinite computations
09:59:29 <FunctorSalad> or were you thinking of a timeout
09:59:42 <EvilTerran> (I'm thinking if this could be implemented as a yea/nay sweep over standard haskell)
10:00:08 <EvilTerran> FunctorSalad, i mean by doing the sort of thing that desegnis suggests
10:00:14 <FunctorSalad> you should allow bounded loops in the safe language though (not sure if that is structural recursion)
10:01:20 <desegnis> Thanks for the link anyway, as it seems that that's something which is actually being used. But yea, FunctorSalad, I'm thinking about infinite computations.
10:01:57 <desegnis> Er, what's a bounded loop?
10:02:13 <EvilTerran> corecursion also might be a relevant concept
10:02:15 <FunctorSalad> the number of iterations is set upon entering the loop
10:02:40 <FunctorSalad> lots of things like iterating over a list of known size are bounded loops...
10:02:47 <FunctorSalad> (not that that is necessary in haskell :D)
10:04:01 <desegnis> hm, we may express a bounded loop by recursion on the natural numbers, I'd guess. Just add a parameter here or there
10:04:30 <FunctorSalad> does that allow the n to be dynamic?
10:05:06 <EvilTerran> as long as it's not fix Succ, you should be okay :P
10:05:06 <FunctorSalad> hmm I guess it does since you can construct more and more natural number types at runtime?
10:05:37 <EvilTerran> (thinking of it as structural recursion over data Nat = Zero | Succ Nat)
10:05:51 <FunctorSalad> yes, thought that
10:05:53 <desegnis> Not sure about what dynamic means here. Hey, I'm only a hobbyist programmer ;)
10:06:16 <oerjan> desegnis: bounded loops are equivalent to primitive recursion, i recall
10:06:30 <FunctorSalad> that n can comehow be computed at runtime and then you enter a loop(n) ...
10:06:46 <FunctorSalad> oerjan: I vaguely seem to remember something like that as well
10:07:01 <EvilTerran> FunctorSalad, as we could fix in the types of this hypothetical language that n is finite, that shouldn't be a problem
10:07:41 <FunctorSalad> EvilTerran: yeah, but I was thinking about doing this with haskells type system
10:07:47 <FunctorSalad> think it should work...
10:09:10 <EvilTerran> you'd need to put in a sweep beforehand to stop the programmer just writing "loop = loop" or whatevre, mind
10:09:33 <EvilTerran> go through and categorise everything as data/codata/other, and bail if there's any "other"
10:09:35 <desegnis> ah right. Yeah, if I'm guaranteeing termination via structural recursion, then I'd have to guarantee finite structures
10:10:36 <EvilTerran> i guess the structure would be quite close to a monad, actually
10:11:22 <desegnis> Is codata just Â»possibly infinite dataÂ«?
10:11:33 <EvilTerran> kinda like Cont; you'd only be able to recurse freely by following the recursive continuation
10:11:52 <EvilTerran> desegnis, kinda; co-recursion's the more interesting one
10:12:27 <EvilTerran> a corecursive function *may* recurse forever, but always produces some information before recursing
10:12:44 <desegnis> ok
10:13:12 <EvilTerran> length [] = Zero; length (x:xs) = Succ (length xs) -- is co-recursive, as every recursive call provides another level of constructor, and so gives more information
10:13:29 <EvilTerran> length [1..] = Succ (length [2..]) -- ok, we know it's at least 1 long
10:13:56 <EvilTerran> = Succ (Succ (length [3..])) -- now we know it's at least 2 long
10:14:00 <EvilTerran> etc
10:14:28 <desegnis> EvilTerran: Wait, length is just plain recursive? Ah, it's recursive wrt the list, but co-recursive wrt the result
10:14:55 <Philippa> no, the result's built by recursion on the list
10:14:55 <EvilTerran> in haskell, length is *not* corecursive, as the return type is strict
10:15:08 <EvilTerran> ?type length
10:15:09 <lambdabot> forall a. [a] -> Int
10:15:15 <EvilTerran> (i hope i'm getting this right)
10:15:22 <EvilTerran> anyway. i have to go have dinner. bbiab.
10:15:47 <desegnis> thanks, EvilTerran. how went this Karma thing again?
10:15:50 <desegnis> EvilTerran++
10:16:12 <RayNbow> :t genericLength
10:16:12 <lambdabot> forall b i. (Num i) => [b] -> i
10:40:33 <jair_> hello, everybody! I was wondering...
10:40:58 <jair_> ...many times, i find useful to iterate trough a list, one pair at a time
10:41:32 <jair_> for example, for the points of a polygon, i would want to iterate through each pair of points that make a side
10:42:31 <koala_man> you have [1,2,3,4] and you want to iterate [(1,2), (3,4)]?
10:42:39 <jair_> nope
10:42:49 <funktio> [[1,2],[2,3],[3,4]] ?
10:42:51 <jair_> (1,2),(2,3),(3,4),(4,1)
10:43:03 <ndm> jair_: do you want to chance the list? or just extract from it?
10:43:13 <jair_> just extract
10:43:27 <ndm> @let pairs x = zip x (tail x ++ [head x])
10:43:29 <lambdabot> Defined.
10:43:33 <ndm> > pairs "neil"
10:43:34 <lambdabot>  [('n','e'),('e','i'),('i','l'),('l','n')]
10:44:15 <jair_> oh, that's true
10:44:20 <jair_> thank you!
10:44:37 <ndm> note: pairs crashes on the empty list
10:44:51 <ndm> @let pairs x = zip x (drop 1 x ++ take 1 x)
10:44:51 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
10:44:59 <ndm> now it doesn't
10:45:03 <ndm> > pairs "neil"
10:45:04 <lambdabot>  [('n','e'),('e','i'),('i','l'),('l','n')]
10:45:07 <ndm> > pairs ""
10:45:08 <lambdabot>  []
10:45:25 <jair_> :)
10:48:04 <vincenz> ndm: much easier
10:48:13 <vincenz> @let pairs2 x = zip x (drop 1 $ cycle x)
10:48:14 <lambdabot> Defined.
10:48:20 <vincenz> > pairs2 "neil"
10:48:20 <lambdabot>  [('n','e'),('e','i'),('i','l'),('l','n')]
10:48:35 <ndm> vincenz: more efficient as well?
10:48:47 <ndm> i guess same efficiency
10:50:05 <jair_> "drop" drops from the beginning of the list, right?
10:50:16 <matthew-_> ja
10:50:34 <ndm> drop 1 == tail, but on empty list gives the emptylist
10:50:41 <ndm> tailSafe in the Safe library
10:50:48 <jair_> oh
10:51:26 <vincenz> > cycle []
10:51:26 <lambdabot>  Exception: Prelude.cycle: empty list
10:52:19 <LoganCapaldo> > let cycle xs = a where a = xs ++ a in cycle []
10:52:19 <lambdabot>  Exception: <<loop>>
10:52:26 <LoganCapaldo> choices
10:52:28 <LoganCapaldo> choices
10:52:35 <desegnis> > let pairs x = zip x (tail x ++ [head x]) in pairs [] -- The first version shouldn't crash on the empty list at all
10:52:36 <lambdabot>  []
10:53:09 <LoganCapaldo> right you are desengnis
10:53:18 <LoganCapaldo> hooray zip
10:53:27 <LoganCapaldo> hooray lazy
10:53:29 <funktio> I'd just say  pairs [] = []  and pairs xs = ...
10:53:36 <desegnis> :)
10:54:21 <fadec> How can this be a constructor in the Parsec lib?   ...  data GenParser tok st a   ... there is no declaration. When I try syntax I get an error saying that (-XEmptyDataDecls permits this). What does an empty data declaration mean?
10:55:16 <fadec> token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
10:55:42 <fadec> so tok looks like a type, sort of
10:57:04 <fadec> Is there a parsec tutorial/example that includes lexing first?
10:57:24 <desegnis> fadec, are you sure that GenParser is declared as empty?
10:57:25 <LoganCapaldo> lex whilst you parse, it's more fun that way
10:58:07 <fadec> desegnis: in the Haddock it shows that.
10:58:14 <LoganCapaldo> :i GenParser claims it to be a newtype
10:58:35 <Philippa> fadec: I haven't seen one. I've done it though - you write an ordinary but simple parser as your lexing stage and then use tokenPrim and the likes to build primitive single-token parsers for the parsing stage proper
10:58:36 <Saizan> fadec: it's just that the constructor is not exported, so haddock doesn't list it
10:58:38 <radetsky> anybody familiar with ByteString changes after base split?
10:58:49 <desegnis> fadec, that means that it is an abstract type. Which means that the constructors are there, but they just aren't exported
10:58:53 <radetsky> I'm trying to figure out what (if anything) replaces packAddress
10:59:09 <Philippa> or you can use something other than parsec for your lexer, of course
10:59:28 <Saizan> radetsky: Data.ByteString.Unsafe.packAddress, but it's in IO now
10:59:44 <fadec> why does the the type of 'token' contain lowercase tok?
10:59:45 <fadec> token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
10:59:47 <hpaste>  LoganCapaldo pasted "fadec: newtype, see?" at http://hpaste.org/4834
10:59:55 <radetsky> Saizan: I saw unsafePackAddress in Unsafe
11:00:02 <desegnis> fadec, that's a type variable just like Â»aÂ« is
11:00:09 <radetsky> but I don't think packAddress exists anymore
11:00:47 <Saizan> radetsky: right, i missremembered, however that's the most close function
11:01:00 <Philippa> fadec: because that's the whole point. It doesn't care what the token type is so long as you're consistent
11:01:19 <LoganCapaldo> istr that were some unsafe functions that didn't have unsafe in the name, perhaps packAddress was one of them?
11:01:21 <Philippa> like desegnis said, it's a type variable - it's polymorphic in the token type
11:01:23 <fadec> I see
11:01:53 <int-e> radetsky: unsafePackAddress exists. However, there's a rule to optimise  pack "foo"  to the equivalent of  packAddress "foo"#
11:01:57 <desegnis> fadec, also note that there's something like  type Parser a = GenParser Char () a
11:03:06 <radetsky> I'm not trying to optimize. I'm just trying to fix hmp3 with minimal changes to the underlying behavior
11:04:07 <Saizan> radetsky: use pack then
11:04:22 <radetsky> to get a type-correct replacement for packAddress, I'd have to do afaik "let packAddress = unsafePerformIO . unsafePackAddress"
11:04:28 <radetsky> is this a bad idea?
11:04:39 <fadec> desegnis: I saw the Parser type. I have been using it but I felt sort of naive since I have some tokens I could grab first. Anyway, that led me here.
11:04:39 <sjanssen> radetsky: packAddress is most likely overkill
11:04:41 <sjanssen> just use pack
11:04:53 <radetsky> Saizan: currently, program is full of Addr# constants
11:05:14 <radetsky> I could change them all, but I'd like to avoid it
11:05:28 <radetsky> pack :: [Word8] -> ByteString
11:05:33 <Saizan> radetsky: if they are literal like "foo"# it's just a matter of search/replace to fix that
11:05:34 <int-e> radetsky: that will probably work, yes
11:05:51 <Saizan> ?type Data.ByteString.Char8.pack
11:05:52 <lambdabot> String -> Data.ByteString.Base.ByteString
11:05:56 <int-e> radetsky: using pack would still be cleaner
11:06:24 <radetsky> Saizan: yes, but I'm also not sure if, e.g., there are functions which emit Addr#, etc
11:06:56 <radetsky> if I was starting out, I'd use pack, and I'm probably going to end up using it, but I'm trying to avoid it
11:07:29 <fadec> LoganCapaldo: A general question, is lexing ever required or is it a performance consideration to reduce backtracking? Is that what you meant by lex as you parse?
11:08:38 <Philippa> it's a performance consideration
11:09:00 <Philippa> there're primitive parsers that work on characters, so you can just feed in a String and work with those
11:09:33 <Philippa> for some tasks you might have a step between lexing and parsing too - I've written parsers for languages with a layout rule similar to Haskell's, for example
11:10:03 <LoganCapaldo> fadec: lsiten to Philippa, I mostly make calculators :p
11:10:05 <radetsky> also, there are comments to the effect that certain parts of the code need Addr#'s
11:10:26 <LoganCapaldo> (and the occasional data file format)
11:10:59 <radetsky> I figured dons wasn't just doing it for the lulz
11:11:21 <LoganCapaldo> lol
11:11:53 <EvilTerran> @seen desegnis
11:11:54 <lambdabot> desegnis is in #darcs, #haskell and #xmonad. I last heard desegnis speak 9m 57s ago.
11:11:59 <LoganCapaldo> seeing <dons> lulz would probably put me into a paroxysm of laughter
11:11:59 <fadec> Thanks folks.
11:12:34 <EvilTerran> desegnis, <http://www.jucs.org/jucs_10_7/total_functional_programming> might interest you. it goes into co/recursion more rigorously than I have.
11:14:42 <desegnis> EvilTerran, I have had a quick glance at that paper already, but will look at it again
11:14:57 <EvilTerran> ok :)
11:18:22 <fadec> Is there a way to make GHCI try and load a file and if it fails just leave things alone?
11:19:06 <fadec> Right now my workflow is to break the program, then undo what I did, save and reload so I can inspect types, then fix.
11:19:48 <fadec> If it would keep my old file loaded I could inspect types without undoing and saving my source. What do you guys do?
11:20:17 <EvilTerran> alternate between two instances of ghci?
11:20:20 <fadec> s/undoing/reverting to a version that would load/
11:21:01 <pejo> fadec, I 'just' fix up the problems and reload, but I can see the use for what you want.
11:21:09 <LoganCapaldo> Is readFile lazy?
11:21:28 <fadec> EvilTerran: Ok. I might as well. I've been using emacs and I think right now I can only run one inferior haskell
11:21:59 <EvilTerran> there's probably some command-line parameter to ghc that means "check to see if this would compile, but don't compile it"
11:22:08 <EvilTerran> you could use that to verify it'll load right before reloading it
11:22:26 <fadec> EvilTerran: good idea. that's a start
11:22:40 <EvilTerran> you could probably even set up emacs to run that every time you save (and jump to the first error, if it exists)
11:22:47 <EvilTerran> or whatever
11:22:59 <fadec> Yup. I think that would work.
11:23:10 <fadec> and kick ass
11:24:32 <oerjan> LoganCapaldo: yes
11:24:42 <LoganCapaldo> oh good
11:24:53 <Saizan> i usually comment out the part that doesn't load, or insert some undefineds
11:25:02 <oerjan> @src readFile
11:25:02 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
11:25:37 * LoganCapaldo was considering switching to hGetContents, but sees that would be redudant
11:30:02 <hrehf> does >> / >>= merely _compose_ , or does it actually _run_ the Monads(?) ?
11:30:16 <Saizan> readFile is strict in the handle and lazy in the content
11:30:28 <Saizan> hrehf: merely compose
11:30:54 <Sizur> is liftIO . putStrLn lazy? i dont get any output with that
11:31:10 <hrehf> Saizon so a main = foo >> bar would ultimately execute a composition of foo and bar as the outmost 'step' ?
11:32:18 <hrehf> (ie. in result, main would be the only 'executing' part of a program that executes a relatively large composition of Monads?
11:32:30 <Korollary> hrehf: Yes, main is everything.
11:32:35 <oerjan> Sizur: certainly not
11:32:51 <oerjan> i suppose with some bad monad it could be
11:32:56 <kpreid> Sizur: perhaps you'd like to hFlush stdout
11:33:08 <hrehf> thank you, guys
11:35:26 * LoganCapaldo just thought of a devious plan to get haskell used at work
11:35:35 <LoganCapaldo> but I so work in the wrong group
11:35:38 <roconnor> compile it to javascript?
11:35:39 <puusorsa> kryptonite
11:36:15 <LoganCapaldo> so even if I pulled it off, I wouldn't get to use it :p
11:36:33 <loupgaroublond> what would it be?
11:37:56 <LoganCapaldo> well basically there's this group that has a ton of parsers for all these different vendors custom data formats, and right nwo they're all written in perl or C++
11:38:39 <Korollary> written by hand?
11:38:45 <LoganCapaldo> I would bring forth parsec and there would be much rejoicing
11:38:48 <LoganCapaldo> yeah
11:39:13 <Korollary> You'd bring Parse::RecDescent or Antrl or Bison and there would be much rejoicing, too.
11:39:37 <LoganCapaldo> yeah but that wouldn't get haskell in there :p
11:39:53 <roconnor> @quote ubuntu
11:39:53 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
11:39:54 <_phobes> Philippa:  So I looked at just using CIC as my foundation... it looks it would be hard to do what I want without sigma types at the type level (which seems to be unsound without much care?)
11:40:14 <LoganCapaldo> evangelism trumps logic and pragmatism everytime :)
11:40:28 <Korollary> In my limited experience people who don't get why hand written parsers are bad don't appreciate languages like Haskell
11:41:14 <roconnor> doesn't CIC have sigma types at every level?
11:41:16 <_phobes> Philippa:  It seems like having types and terms occupy the same universe is very useful for expressivness
11:41:27 <_phobes> roconnor:  Does it?
11:41:41 <roconnor> sure, at least in Coq.
11:41:59 <roconnor> but it is predicative.
11:42:03 <_phobes> ah
11:42:08 <LoganCapaldo> well I'm not in those particular trenches, I understand the vendors have a tendency to unexpectedly change things and also not provide guarantees about the format of their data
11:42:28 <duaneb> waitasec
11:42:33 <duaneb> if haskell is purely functional
11:42:45 <duaneb> can't the compiler evaluate the results during compile?
11:42:45 <LoganCapaldo> i'm sure all the parsers are big balls of edge cases by now
11:42:55 <LoganCapaldo> @where supero
11:42:56 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/supero/
11:43:02 <LoganCapaldo> duaneb: ^
11:43:03 <gvdm> duaneb: everything not involving the IO monad (kinda)
11:43:42 <roconnor> duaneb: it could (moduloish IO and maybe not wanting to reduce general recursion)
11:44:27 <roconnor> duaneb: but we tend to write function, and then evaluate them at the ghci
11:44:50 <duaneb> ahh
11:44:57 <Sizur> if it is possible, under what circumstances can putStrLn not produce output?
11:45:12 <LoganCapaldo> if your screen explodes
11:45:16 <roconnor> > putStrLn undefined
11:45:17 <lambdabot>  <IO ()>
11:45:26 <_phobes> roconnor:  And modulo IO is pretty important :)
11:45:34 <LoganCapaldo> if stdout is closed perhaps
11:45:49 <_phobes> Because how often do you write a program that doesn't take any input?
11:45:49 <Sizur> in liftIO context
11:46:04 <Sizur> @hoogle hFlush
11:46:04 <lambdabot> System.IO.hFlush :: Handle -> IO ()
11:46:14 <roconnor> _phobes: when I'm sloving the xkcd menu problem.
11:46:24 <roconnor> solving
11:46:41 <_phobes> Is that a reference to a strip?
11:47:06 <Sizur> hFlush doesnt help
11:47:20 <roconnor> _phobes:
11:47:23 <roconnor> _phobes: http://programming.reddit.com/info/24p2c/comments/c24pc5
11:48:08 <LoganCapaldo> Sizur: liftIO imlies a monad transformer, are you remmeebrin g to run the outer transformer?
11:48:15 <Sizur> yep
11:48:28 <_phobes> roconnor: ah
11:48:46 <Sizur> it's ReaderT so i'm runReaderT m env
11:49:13 <Sizur> the m contains the liftIO . putStrLn
11:49:25 <LoganCapaldo> Perhaps you should hpaste your code
11:49:50 <Sizur> there are not just a few lines involved though :( but i'll try to abbriviate
11:49:59 <monochrom> Haha, great, Haskell doesn't have segfault, but it has seq's fault. :)
11:50:11 <byte-> hello.
11:50:17 <LoganCapaldo> well if you abbreviate and can or cannot reproduce, at least you've narrowed down the problem somewhat
11:50:20 <loupgaroublond> how can i debug haddock when at its most verbose setting, it only spits out this error: dist/build/tmp/src/HAppS/Crypto/MD5.hs:"src/HAppS/Crypto/MD5.hs": 77:1: Parse error in pattern
11:50:28 <byte-> would anyone mind proofreading my PL allegory?
11:50:36 <byte-> http://y-a-blog.blogspot.com/
11:50:36 <lambdabot> Title: Yet Another Blog
11:50:54 <kpreid> loupgaroublond: well, have you looked at that file?
11:50:56 <byte-> ok, lambdabot is starting to creep me out.
11:50:59 <roconnor> oh no, MD5!
11:51:07 <monochrom> loupgaroublond: last time I saw a similar message, it was because I used bang pattern.
11:51:16 <duaneb> > :t True
11:51:17 <lambdabot>   parse error on input `:'
11:51:22 <duaneb> >:t True
11:51:25 <kpreid> :t True
11:51:26 <lambdabot> Bool
11:51:27 <byte-> :t True
11:51:27 <lambdabot> Bool
11:51:32 <byte-> ugh, beaten.
11:51:35 <roconnor> @vixen stop creeping byte- out
11:51:35 <lambdabot> stop what?
11:51:37 <idnar> heh
11:51:46 <roconnor> @scheck Bool
11:51:47 <lambdabot>  Not in scope: data constructor `Bool'
11:51:50 <roconnor> er
11:51:52 <roconnor> @scheck True
11:51:53 <lambdabot>   Completed 1 test(s) without failure.
11:51:57 <roconnor> \o/
11:52:09 <loupgaroublond> kpreid: monochrom i have, there's no comment on the function at all
11:52:23 <kpreid> what do comments have to do with anything?
11:52:32 <loupgaroublond> what is the bang pattern?
11:52:47 <kpreid> f !x = x + 1
11:52:49 <monochrom> f !x = f (x+1)
11:52:51 <Korollary> wow
11:52:58 <kpreid> like that
11:52:59 <monochrom> @quote fugue
11:52:59 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
11:53:35 <byte-> monochrom, what's that do?
11:53:53 <byte-> f !x = f (x+1) ?
11:53:54 <monochrom> Anyway, Haddocks doesn't know some extensions. And yes, Haddocks does look at your code, not just your comments.
11:53:57 <loupgaroublond> oh, yes, there is a function like that, before that error point
11:54:24 <loupgaroublond> anyway to convince haddock to ignore it?
11:54:39 <loupgaroublond> not that i understand what the bang pattern does, stil....
11:54:51 <LoganCapaldo> byte-: adds 1 to (adds 1 to (adds 1 to ...
11:54:54 <LoganCapaldo> to x
11:55:03 <monochrom> #ifdef HADDOCK or something like that.  Maybe _HADDOCK
11:55:14 <byte-> how is that different from 'f x = f (x+1)'?
11:55:22 <monochrom> Then you invoke haddock with -cpp or something.
11:55:40 <LoganCapaldo> well f x = f 9x+1) builds a giant thunk
11:56:07 <LoganCapaldo> so you'll run out of memory sooner than with !
11:56:36 <LoganCapaldo> unless I'm wrong
11:56:46 <Sizur> ok here it is pasted completely: http://hpaste.org/4835?lines=true
11:56:49 <byte-> oh.
11:56:54 <byte-> so it's just like $! ?
11:57:05 <byte-> s:just like:like:
11:57:07 <Sizur> the problem is detected by the first paste
11:57:28 <loupgaroublond> haddock doesn't seem to like ! at all, is this ever going to get fixed?
11:57:43 <monochrom> loupgaroublond: http://www.haskell.org/haddock/doc/html/invoking.html#cpp  Handy when you want to lie to Haddock.
11:57:44 <lambdabot> Title: Chapter 2. Invoking Haddock
11:58:37 <roconnor> lambdabot: do you have a web interface?
11:58:52 <LoganCapaldo> Sizur: one too many returns
11:58:54 <loupgaroublond> i suppose now i have to look up what literate haskell is :P
11:59:04 <Sizur> LoganCapaldo: explain
11:59:10 <monochrom> Eventually Haddock will share code with GHC and honour all GHC extensions.
11:59:18 <byte-> loupgaroublond, it's the opposite of illiterate haskell...duh ;)
11:59:25 <LoganCapaldo> localize :: L10n -> Locale -> I18n a -> IO a
11:59:40 <LoganCapaldo> so return $ localize ... is IO (IO a)
11:59:40 <monochrom> No, ignore the "literate" part, just focus on the "pre-process" part.
11:59:43 <kpreid> Sizur: line discards the action produced by (localize ...)
11:59:47 <kpreid> line 9
11:59:58 <Sizur> hmm, why did i do that
12:00:12 <kpreid> in a do-block, return is useless except at the end
12:00:16 <Sizur> localize cannot get out of it's own monad
12:00:28 <monochrom> "(this is sometimes handy if you need to any pre-processing conditionals in your source which depend on whether the source is going to be fed to Haddock)"  This is what you want today.
12:00:36 <Sizur> i see, so the one to many returns makes the whole thing lazy?
12:00:39 <kpreid> no.
12:00:44 <kpreid> it makes it discarded
12:01:11 <loupgaroublond> hmm.... now the source won't compile, and the cabal file already has the CPP extension bit set
12:01:14 <kpreid> > (do return 1; return 2) :: [Int]
12:01:14 <lambdabot>  [2]
12:01:18 <kpreid> Sizur: it's like that
12:01:28 <kpreid> @undo do return 1; return 2
12:01:29 <lambdabot> return 1 >> return 2
12:01:38 <kpreid> and of course >> is like >>= \_ ->
12:01:43 <monochrom> Oh, I forgot it has to work with Cabal.
12:02:06 <kpreid> so you're mentioning (localize ...) but not doing anything with it
12:02:18 <loupgaroublond> monochrom: of course it does, how else can i package it?
12:02:20 <kpreid> that it's not computed is irrelevant; primarily you are not *executing* it
12:02:23 <byte-> so did anyone take a look at that post?
12:02:37 <LoganCapaldo> byte-: I did, I'm just not sure of your point
12:02:49 <byte-> as I feared.
12:03:10 <Sizur> ok it works if localize returns IO a
12:03:24 <Sizur> but i dont understand why... it should not be able to
12:03:40 <byte-> the point is supposed to be that using something as simple as text to represent something as complex as a PL is illogical.
12:03:44 <byte-> when editing.
12:04:04 <LoganCapaldo> why do't you just say that?
12:04:16 <LoganCapaldo> that was perfectly clear :)
12:04:17 <byte-> because then it wouldn't be an allegory.
12:04:40 <byte-> mostly I wrote it that way to make it clear _why_ it's illogical.
12:04:49 <lament> byte-: humans don't edit programs by going from one valid program to another
12:05:10 <Sizur> Perfect! it's working
12:05:13 <byte-> oops, "as complex as code"
12:05:19 <Sizur> i18n lib anybody?! :D
12:05:29 <byte-> not "as complex as a PL"
12:05:30 <byte-> my bad.
12:05:32 <monochrom> Only 0.1% of the human race understands allegories. They are called English professors (or Chinese professors, Hebrew professors, ...)
12:05:35 <byte-> lament, I'm not sure what you mean.
12:05:44 <monochrom> If no one understands your allegory, that is normal.
12:05:44 <byte-> monochrom, you don't need to understand them.
12:05:56 <byte-> for them to be effective.
12:05:58 <monochrom> By "understand" I mean "see the point".
12:05:58 <lament> byte-: while you're editing a program, most of the time it's in an invalid state - that is, it's not actually code
12:06:11 <loupgaroublond> maybe we need an allegory about the first allegory to never be understood except by the elite ur-priesthood :P
12:06:20 <byte-> lament, which is illogical, yes, I agree.
12:06:34 <lament> byte-: it's illogical, but extremely convenient
12:06:34 <byte-> monochrom, have you ever read Animal Farm?
12:06:46 <monochrom> No.
12:06:57 <loupgaroublond> src/HAppS/Crypto/MD5.hs:93:2:
12:06:57 <loupgaroublond>     Warning: Defined but not used: `otherwise
12:07:00 <loupgaroublond> buh? :)
12:07:18 <byte-> so it's not that allegories are bad at conveying point-of-views.
12:07:22 <byte-> it's that I suck at writing them ;)
12:07:34 <EvilTerran> byte-, text has its advantages. you don't need specialist software to edit it, for starters.
12:07:35 <roconnor> loupgaroublond: that sounds like an important warning.
12:07:39 <byte-> lament, that issue is largely irrelevant to the issue.
12:07:45 <EvilTerran> you can dump it into an email or a newsgroup post.
12:07:49 <roconnor> loupgaroublond: like otherwise is getting bound as a variable?
12:07:54 <byte-> lament, you can acheive the same thing with a GUI if you want.
12:08:07 <monochrom> I don't think you're using the information that I have not read Animal Farm.
12:08:24 <EvilTerran> you can throw snippets of invalid code around, leaving the rest as an exercise to the reader
12:08:31 <byte-> hmm... is it "points-of-view" instead of "point-of-views"?
12:08:32 <byte-> I think it is.
12:08:37 <Cale> yes
12:08:37 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:08:39 <EvilTerran> (who may be yourself, in a few hours, say)
12:08:49 <monochrom> Bah, bloggers, write-only.
12:08:58 <loupgaroublond> roconnor: i don't know, but i think i'm just going to have to force this module to build sans haddock for now
12:09:12 <Cale> Saizan: yes, briefly I did. Just replace IRCError with e, and it'll work.
12:09:20 <byte-> EvilTerran, it wouldn't be difficult to convert code into text.
12:09:28 <byte-> the benefit being that it wouldn't have to be ugly since it doesn't have to compile.
12:09:37 <EvilTerran> what
12:09:52 <EvilTerran> if your textual code is ugly, you're doing something wrong.
12:09:53 <LoganCapaldo> I disagree that animal farm is effective as an allegory. (if effective means, change someone's opinion on communism)
12:10:15 <EvilTerran> text is also damn convenient to input
12:10:16 <Saizan> Cale: k, did you check if it's intended behaviour or a 6.8 bug? i suppose that module works with 6.6.
12:10:17 <byte-> EvilTerran, the possibilities for rendering code in a 2d environment are immense.
12:10:27 <byte-> if you were to convert that down to a textual format that had to parse, it would be ugly.
12:10:50 <EvilTerran> say i want to have a code snippet in my blog, that people can load up and play with
12:10:57 <Cale> Saizan: I have no idea. It seems like a bug to me.
12:11:05 <EvilTerran> but have it appear in-line
12:11:17 <monochrom> I have read some allegories. For all of them, I needed someone else to tell me how to map them back to what the author meant.
12:11:20 <byte-> EvilTerran, put a text-version of it inline.
12:11:26 <byte-> and provide the actual code as a download.
12:11:43 <monochrom> Either I am a poor allegory reader, or I am among the other 99.9%.
12:11:52 <Sizur> ok, i have a working i18n lib based on gettext. it lacks plural forms but otherwise it's working
12:11:53 <byte-> monochrom, good point.
12:12:00 <monochrom> Err, that last sentence is a tautology.
12:12:09 <Sizur> with context support
12:12:11 <byte-> monochrom, lol
12:12:15 <byte-> monochrom, I figured as much ;)
12:12:43 <monochrom> I am a poor allegory reader, period. The real question is: how many poor allegory readers do you expect out there? 1%? 99%?
12:12:49 <EvilTerran> byte-, if you can come up with a graphical code format that's worth giving up the rough-and-ready convenience of text, let me know.
12:13:14 <LoganCapaldo> and what do the good allegory reads get out of an allegory that they don't get from plainly stating the argument?
12:13:15 <EvilTerran> but, for now, I'm happy with well-formatted haskell with syntax highlighting.
12:13:29 <LoganCapaldo> s/reads/readers
12:13:40 <byte-> EvilTerran, 2d layouts + graphics convey much more information than 1d text.
12:13:40 <EvilTerran> LoganCapaldo, they get the sense of satisfaction that they worked out what the f4 the author was on about ;)
12:13:47 <byte-> EvilTerran, it's not "if," it's "when."
12:14:08 <EvilTerran> byte-, you can assert 'til the cows come home, it's not gonna sway me.
12:14:13 <monochrom> For example, do most readers actually see what Animal Farm means? Or do they know because they also read Coles Notes or gather extra information from hearsay?
12:14:16 <byte-> granted, most people are only familiar with the craptastic GUIs that are present in most applications.
12:14:16 <EvilTerran> if you want converts, you're gonna need results.
12:14:47 <EvilTerran> don't say "look what i'm gonna do", say "look what i've done"!
12:14:54 <byte-> who says I'm going to do anything?
12:14:58 <byte-> do you know how lazy I am?
12:15:02 <EvilTerran> exactly.
12:15:08 <byte-> it took me about as much effort as I could muster to write that damned thing.
12:15:36 <EvilTerran> you just said whether "you can come up with a graphical code format that's worth giving up the rough-and-ready convenience of text" was not a matter of "if" but "when"
12:15:47 <byte-> EvilTerran, in any event, is there something wrong with my logic?
12:15:52 <LoganCapaldo> Well I've used LabVIEW. I'm ttoally not convinced on the code as not text front
12:16:00 <byte-> EvilTerran, not *me* coming up with it.
12:16:03 <byte-> I was talking about it being out there.
12:16:17 <EvilTerran> it's what was said, even if it's not what was meant.
12:16:28 <byte-> well now you know :)
12:16:32 <monochrom> Don't dismiss the virtue of advocating something instead of implementing it. Think of it as an invitation to other people for implementing it. Everyone has a different talent. Some knows what should be implemented, some other knows how to implement it.
12:16:56 <LoganCapaldo> Those who can't, advocate? <g>
12:16:58 <lament> lots of people tried non-textual code before, and it always sucked
12:17:03 <byte-> what about the people that know both but are too lazy to do the latter?
12:17:19 <lament> what does that say? That if non-textual code is at all possible, it must be rather hard to do right
12:17:23 <EvilTerran> any yes, there is something wrong with your logic; you're asserting that something better will come along.
12:17:35 <EvilTerran> that doesn't mean it will.
12:17:58 <byte-> lament, or perhaps it means doing anything well is hard.
12:18:07 <EvilTerran> for now, text is by far the best format for code. I find it unlikely that that's going to change any time soon.
12:18:31 <byte-> I agree.
12:18:36 <byte-> I'm talking purely theoretical here.
12:18:56 <EvilTerran> purely theoretically, the sun could've exploded seven minutes ago.
12:19:03 <monochrom> Text editors are trivial to "get right". Rumour even goes that Microsoft interviews include "write an editor from scratch in C".
12:19:25 <byte-> monochrom, they're trivial to get "right" because they were already designed long ago.
12:19:44 <EvilTerran> monochrom, exactly. OTOH, graphical interfaces are very hard to "get right"
12:19:50 <byte-> writing a decent text editor before the normal design was created probably would've been rather difficult.
12:20:09 <lament> yes, witness the abortions like vi and emacs :)
12:20:10 <LoganCapaldo> text has a long long long long long track record of representing things in general (not just code).
12:20:27 <EvilTerran> computer interfaces are currently highly optimised for text, because that's all there was for a long time
12:20:32 <byte-> because that's all that was usable when that tradition was started.
12:20:38 <LoganCapaldo> lament: not to start an editor war, but if you use something other, what it is?
12:20:39 <EvilTerran> this alone puts graphical interfaces on the back foot
12:20:50 <EvilTerran> mice were an afterthought ;)
12:21:34 <byte-> ok, but ignore all that for a moment.
12:21:37 <EvilTerran> when we have multiple-point touch-screens with handwriting recog as standard, *then* there'll be room for a purely graphical programming system
12:21:45 <byte-> ignore all the "evidence" that says I'm wrong and just look at the theory.
12:21:54 <EvilTerran> being?
12:21:55 <LoganCapaldo> EvilTerran: you forgot cheap
12:22:04 <EvilTerran> LoganCapaldo, i file that under "as standard"
12:22:27 <byte-> 2d layouts and graphics carry much more semantic information than linear text.
12:22:47 <byte-> it's also easier to write editors with them, because you don't have to parse convoluted "syntax."
12:23:03 <monochrom> It is always easy to defend the status quo and attack alternatives.
12:23:05 <byte-> and incremental compilation becomes _a lot_ easier.
12:23:41 <EvilTerran> i disagree on the "ease of writing editors" front
12:24:02 <byte-> we're talking language-aware editors.
12:24:09 <monochrom> "Imperative programming is natural. Everyone knows it. What's with functional programming freaks?" All of you heard that before.
12:24:26 <Sizur> and still hear
12:24:29 <byte-> if you write a language aware editor for a non-textual language, it will be far easier than writing an equivalent text editor.
12:24:36 <byte-> plus, you get a lot more features.
12:24:41 <EvilTerran> why?
12:24:59 <monochrom> Will programming be liberated from the von Neumann style? Will programming be liberated from the Plain Text File?
12:25:05 <EvilTerran> "parsing convoluted syntax" is a pretty minor problem, in light of "designing a GUI that doesn't suck"
12:25:10 <byte-> EvilTerran, was that "why" in reference to what I said?
12:25:18 <Korollary> There are already non-textual programming languages.
12:25:37 <byte-> most non-textual programming languages take on some new paradigm.
12:25:39 <gio123> who knows what is coinduction?
12:25:57 <EvilTerran> yes. you keep saying that writing your graphical editor will be easier than writing a language-aware text editor. i don't agree, so i'm asking why.
12:26:01 <monochrom> coinduction is used to reason about e.g. infinite lists.
12:26:02 <LoganCapaldo> the coset of people who know what induction is
12:26:25 <byte-> rather than the simple approach of just using the usual syntax, but done by the editor rather than embedded in the storage format.
12:26:28 <Sizur> any language can have a textual representation.
12:26:31 <ddarius> coinduction is the proof schema generated from the uniqueness of final coalgebras.
12:26:45 <byte-> EvilTerran, sorry, getting kind of bogged down here.
12:27:17 <gio123> <ddarius> can u give me examples where i can see deference between induction and coinduction
12:27:22 <byte-> EvilTerran, well, let's see.
12:27:41 <dukedave> In my opinion, I think it would be 'good' if visual programming techniques were available as a compliment to the layperson. I got thinking about this after watching this: http://www.youtube.com/watch?v=faJ8N0giqzw Tech Talk ...
12:27:42 <lambdabot> Title: YouTube - Tangible Functional Programming
12:27:54 <byte-> if the editor is in charge of all stylistic issues
12:27:55 <gio123> <ddarius> can u give me examples where i can see deference between induction and coinduction
12:28:01 <gio123> who knows what is coinduction?
12:28:03 <byte-> you can rather easily create a language where constructs can display themselves.
12:28:13 <Korollary> Is this a bot?
12:28:20 <byte-> tree constructors could render themselves as trees.
12:28:21 <byte-> etc.
12:28:22 <EvilTerran> gio123, don't repeat yourself
12:28:23 <Cale> gio123: Please don't ask multiple times :)
12:28:42 <Cale> gio123: People who are here will see your question, and answer if they can. :)
12:28:45 <gio123> <Cale> hey u are here also:)
12:28:46 <byte-> but that is largely language-dependent.
12:28:51 <Cale> yes, of course :)
12:29:08 <gio123> <Cale> u are everywhere?
12:29:11 <monochrom> Gosh, suddenly my apetite is lost.
12:29:13 * duaneb wonders
12:29:14 <duaneb> :quit
12:29:17 <gio123> <Cale> please come in prolog also
12:29:18 <duaneb> >:quit
12:29:18 <gio123> :)
12:29:22 <duaneb> hehe
12:29:35 <EvilTerran> byte-, you could do the same with a human-readable langauge, though
12:29:39 <ddarius> gio123: When you are using coalgebras instead of algebras, e.g. as monochrom said, when you are dealing with (certain types of) infinite structures.
12:29:50 <Cale> http://citeseer.ist.psu.edu/rd/97266641%2C23110%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/2769/http:zSzzSzwww.cs.kun.nlzSz%7EbartzSzPAPERSzSzJR.pdf/jacobs97tutorial.pdf -- you might find this useful.
12:29:51 <lambdabot> http://tinyurl.com/yop3rj
12:30:03 <Cale> (gio123)
12:30:03 <byte-> EvilTerran, true.
12:30:08 <monochrom> onoes, that one!
12:30:11 <byte-> but then you need a specialized text editor.
12:30:14 <EvilTerran> class Render a where render :: a -> Image
12:30:21 <byte-> and you need to start manipulating the text.
12:30:33 <gio123> <Cale>  hard to undestand that paper
12:30:42 <EvilTerran> that'll be an IDE, then
12:30:57 <byte-> replacing code with graphical representations of it.
12:31:05 <gio123> <ddarius> it seems my background is not enought i still cant undestand
12:31:06 <byte-> basically, you're just writing a complicated version of what I'm talking about.
12:31:18 <byte-> but without the benefits of doing that to everything, rather than to custom elements.
12:31:23 <Cale> http://citeseer.ist.psu.edu/rd/0%2C105244%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/1694/http:zSzzSzresearch.microsoft.comzSz%7EadgzSzPublicationszSzfp94.pdf/gordon94tutorial.pdf -- or this one?
12:31:24 <lambdabot> http://tinyurl.com/2e6gtw
12:31:27 <EvilTerran> i'm not sure what'd be gained by departing from text entirely
12:31:40 <byte-> EvilTerran, let's put it this way.
12:31:51 <monochrom> Cale knows the url of all the papers I want to suggest. :)
12:32:05 <byte-> if you had what I was talking about, why would you want to embed the presentation of code with it's structure
12:32:08 <byte-> stick it in a text file
12:32:18 <byte-> use a crappy text editor/IDE to edit it
12:32:19 <Cale> (they're all on citeseer :)
12:32:21 <EvilTerran> sure, architectural plans and whatnot benefit wonderfully from being presented graphically
12:32:22 <duaneb> I'm new to haskell; I have a function (is that the word?) that returnes an array of strings
12:32:39 <byorgey> duaneb: yes, function is the word =)
12:32:45 <ndm> words :)
12:32:46 <EvilTerran> but that's because what they represent is fundamentally two- or three-dimensional
12:32:47 <byte-> plus, you have to deal with syntax errors
12:32:50 <ndm> @type words
12:32:51 <byorgey> duaneb: you mean a list of strings?
12:32:51 <duaneb> how can I loop through the array and print them?
12:32:52 <lambdabot> String -> [String]
12:32:56 <duaneb> err, yes
12:32:57 <dukedave> byte-: I see the use for visual techniques most in higher level "programming with programs" applications, so for example dragging a 'data source' box round part of a web page and connecting it to a filter box and that to a 'pdf output'
12:33:01 <LoganCapaldo> > ["this is a list", "btw"]
12:33:01 <lambdabot>  ["this is a list","btw"]
12:33:08 <ndm> duaneb: instead of thinking array, always think list
12:33:24 <duaneb> I come from C; I automatically think array
12:33:25 <monochrom> mapM_ print (my list)
12:33:29 <duaneb> but I have a list of strings
12:33:30 <LoganCapaldo> (in case you don't really have an array)
12:33:31 <duaneb> ooh
12:33:31 <duaneb> ok
12:33:34 <lament> duaneb: forget all C you know.
12:33:35 <ndm> even better would be:
12:33:39 <monochrom> err, mapM_ putStrLn (my list)
12:33:43 <EvilTerran> maths is still mostly written; words and symbols.
12:33:46 <ndm> putStr (unlines (my list))
12:33:47 <monochrom> Try both.
12:33:49 <duaneb> lament: considering my job is to write c...
12:33:50 <Cale> Well, Haskell has arrays too, but they're not the same thing as lists.
12:33:56 <monochrom> Try everything. :)
12:33:56 <ndm> i.e. build up a pure list, then write it out afterwards
12:34:01 <lament> duaneb: just forget about it while you're learning haskell :)
12:34:03 <byte-> mostly I keep grasping at straws because apparently I'm not conveying the primary reason well enough.
12:34:04 <EvilTerran> imo, algorithms are fundamentally mathematics
12:34:09 <Cale> In fact, Haskell has a cooler array library than most languages do.
12:34:20 <duaneb> list library?
12:34:21 <Cale> Since you can index arrays with lots of different types.
12:34:22 <byte-> storing an AST in a text file and making it "prettier" using syntax is completely illogical.
12:34:32 <Cale> duaneb: That too, but arrays and lists are not the same thing.
12:34:36 <byte-> even if you ignore all of the potential features of having a special editor
12:34:36 <LoganCapaldo> in fact Haskell arrays are in a library, and not part of the language, which is cool <g>
12:34:45 <byte-> it's just easier to do it that way.
12:35:04 <sjanssen> LoganCapaldo: to be fair, they're implemented by primitives
12:35:14 <Cale> LoganCapaldo: Well, they're effectively part of the language, since they can't really be implemented with the same performance characteristics otherwise.
12:35:20 <LoganCapaldo> I don't want to be fair :)
12:35:23 <byte-> 1) you don't have to design and write a grammar for the language
12:35:28 <ddarius> EvilTerran: If anything math has, in it's relatively recent history, been moving towards being rather less "graphical" for better or worse. (Actually, I think very recently that trend has somewhat started shifting back)
12:35:30 <duaneb> ok, easy fix
12:35:47 <byte-> 2) GUI programming is a lot easier than having to read in already formatted code
12:35:49 <duaneb> why does "main = map putStrLn ["foo", "bar"]" not work?
12:35:51 <EvilTerran> oh, no, byte-; you'll still need a grammar
12:35:56 <vvv> @src InstalledPackageInfo
12:35:56 <lambdabot> Source not found. Take a stress pill and think things over.
12:35:59 <Cale> duaneb: mapM_
12:36:02 <ddarius> :t map putStrLn
12:36:02 <lambdabot> [String] -> [IO ()]
12:36:03 <vvv> @hoogle InstalledPackageInfo
12:36:04 <lambdabot> Distribution.InstalledPackageInfo :: module
12:36:04 <lambdabot> Distribution.InstalledPackageInfo.InstalledPackageInfo :: type InstalledPackageInfo
12:36:04 <lambdabot> Distribution.InstalledPackageInfo.InstalledPackageInfo_ :: data InstalledPackageInfo_ m
12:36:04 <ddarius> main :: IO a
12:36:08 <byte-> EvilTerran, yes, but now you're the one that's grasping at straws.
12:36:11 <EvilTerran> it may not describe characters in a row, but it'd still be a description of what's valid and what isn't
12:36:13 <Cale> duaneb: You end up with a list of IO actions, where you want a single one.
12:36:23 <byte-> you can use any data persistance library in existance to get data into your editor/compiler.
12:36:26 <Cale> duaneb: There are functions for turning such lists of actions into a single action
12:36:27 <duaneb> :|
12:36:30 <Cale> :t sequence
12:36:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:36:36 <duaneb> gah
12:36:39 <byte-> which isn't some specialized thing that only applies to that one app that you're writing.
12:36:42 <vvv> :i InstalledPackageInfo
12:36:47 <Cale> (to restrict the type there, it's like [IO a] -> IO [a]
12:36:49 <Cale> )
12:36:49 <EvilTerran> your average grammar describes the syntax tree anyway
12:36:55 <duaneb> I thought that map just called putStrLn on all members of the list...
12:37:00 <LoganCapaldo> it does
12:37:02 <EvilTerran> when you're reasoning about anything but the guts of compilers
12:37:02 <Cale> duaneb: It does.
12:37:15 <byte-> I don't quite understand what you're saying.
12:37:16 <duaneb> ...
12:37:17 <monochrom> Other languages give you slices of arrays. Haskell thinks that is childish. Haskell provides something more general. You can re-map indexes with any function at all. There is no copying. You pay the index re-mapping cost only.
12:37:18 <Cale> duaneb: That produces an action for printing each of the strings.
12:37:22 * LoganCapaldo waits for duaneb's head to explode
12:37:35 <Cale> duaneb: There's too much traffic, let's move to #haskell-overflow
12:37:37 <monochrom> You want an array B such that B[i] = A[i^2]? You've got it.
12:37:57 <monochrom> "array slice" is therefore a trivial special case.
12:38:16 <EvilTerran> byte-, generally, the "grammar" of a programming language describes the language's syntax tree; sure, it also more-or-less describes how it appears as text, but that's only half of it
12:38:26 <sjanssen> monochrom: umm, are you sure there is no copying?
12:39:00 <EvilTerran> byte-, and with your graphical system, the grammar will half describe the AST, and half describe what it looks like on-screen
12:39:00 <sjanssen> we're talking about ixmap, right?
12:39:06 <monochrom> Yes, ixmap.
12:39:12 <byte-> EvilTerran, eh?
12:39:16 <LoganCapaldo> @type ixmap
12:39:16 <monochrom> Perhaps some implementations copy.
12:39:16 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
12:39:20 <byte-> with my graphical system, the code is stored as an AST.
12:39:24 <byte-> you don't need to convert it into one.
12:39:28 <EvilTerran> but you still need to look at it!
12:39:36 <axm> I think I might have discovered a missing part in the unEscapeString of Network.URI, but I am not sure if that is the right place.
12:39:41 <EvilTerran> you need some way of saying "this is valid code. that isn't"
12:39:47 <sjanssen> monochrom: I'm fairly certain that GHC does
12:39:50 <EvilTerran> both of those roles would be covered by a grammar
12:39:51 <byte-> I'm using the fairly specific definition of "grammar"
12:40:01 <byte-> referring to the syntax of something that's to be parsed.
12:40:13 <byte-> the screen isn't going to be parsed by the editor to compile it.
12:40:27 <monochrom> It is unclear copying performs better or worse than re-mapping.
12:40:32 <EvilTerran> well, there's our problem. we're talking about different things.
12:40:49 <axm> i found it used in an application that used it for formatting http cgi params, and so '+' would be a legal encoded character
12:41:12 <byte-> I suppose the main difficulty in talking about this subject
12:41:21 <byorgey> byte-: a grammar describes an AST.  one possible use of it is to parse text into an AST, but that's not what it *is*.
12:41:33 <sjanssen> monochrom: well, it might not "copy" per se, but it does allocate a new array of length N
12:41:34 <byte-> is that everybody has a different view of what a GUI for a code editor would look like.
12:41:35 <ddarius> byte-: I doubt that, though it is a main difficulty in general discourse.
12:41:39 <axm> but that is omitted in unEscapeString. would it be the 'right' place to add it there, or is it a bit abused in that case?
12:41:41 <JohnDoeKyrgyz> Hi can anyone explain why I cannot declare a user defined data type that is a list of another type?
12:41:49 <byorgey> JohnDoeKyrgyz: sure you can.
12:42:04 <monochrom> Hrm! Now that gets interesting.
12:42:11 <sjanssen> monochrom: probably each cell is a thunk that indexes into the old array, this seems the best solution wrt. time.  Space is another matter...
12:42:15 <EvilTerran> what *I* was talking about was the part of the formal specification of the code format that deals primarily with what constitutes a valid AST. secondarily, it usually also describes what any such AST would look like
12:42:16 <ddarius> byte-: EvilTerran's point has very little to do with any particular visualization.
12:42:22 <byorgey> JohnDoeKyrgyz: if you just want a type synonym, you can say:  type MyType = [Foo]
12:42:33 <byte-> ddarius, what I'm describing does, though.
12:42:35 <LoganCapaldo> data User = [Int] <-- bad, type User = [Int] <-- ok
12:42:37 <EvilTerran> you'll need one of these whether you're visualising your AST as text or as a graphical tree
12:43:01 <JohnDoeKyrgyz> Thanks !! That makes sense
12:43:10 <ddarius> byte-: That doesn't mean EvilTerran's point doesn't apply to your case, as his point is general.
12:43:15 <byte-> EvilTerran, of course, that wouldn't at all make sense for what I'm talking about.
12:43:31 <EvilTerran> byte-, and what you're describing is a relatively trivial aspect of making a good code editor
12:43:32 <byte-> since I already mentioned how easy it is to write GUI code--ie your "grammar."
12:43:42 <EvilTerran> it isn't easy!
12:43:45 <EvilTerran> GUIs are hard!
12:43:50 <byorgey> JohnDoeKyrgyz: the problem with data User = [Int] is that data type declarations require constructors: so you'd have to write data User = U [Int] (where U could be whatever you want).
12:43:54 <jtootf> hi everybody
12:43:58 <byte-> EvilTerran, designing them perhaps.
12:44:06 <byorgey> JohnDoeKyrgyz: but it sounds like you probably want to just use 'type' instead of 'data'.
12:44:06 <byte-> but that's just as hard as designing a decent textual syntax.
12:44:20 <byte-> writing a GUI compared to writing a parser is much easier, though.
12:44:27 <byorgey> hi jtootf
12:44:36 <EvilTerran> they're different. i wouldn't say one's any easier than the other.
12:44:52 <EvilTerran> and the design's the difficult bit, in either case
12:45:14 <byte-> except the design of the latter directly translates into difficulties in parsing it.
12:45:14 <jtootf> sorry for a newbie question, but it seems to me that it turns out to be much more serious that I was thinking on it first. what should be the type for the _most generic_ average function in haskell ?
12:45:27 <byte-> I've written a couple parsers before.
12:45:36 <byte-> I've always had to redesign the syntax because of some difficulty in parsing it.
12:45:37 <EvilTerran> likewise.
12:45:44 <jtootf> I mean it should be [a] -> b in general, but what constraints ?..
12:45:44 <LoganCapaldo> a good type for average is so a lost cause.
12:45:44 <drakioned> er.. what's an average function?
12:45:48 <glguy> :t \xs -> sum xs / genericLength xs
12:45:50 <lambdabot> forall a. (Fractional a) => [a] -> a
12:45:58 <byte-> I've never had to redesign a GUI because I couldn't render it.
12:46:06 <EvilTerran> well, there we differ
12:46:16 <byorgey> jtootf: that's a good question =)
12:46:20 <byte-> but that's mostly because I don't write GUIs a lot.
12:46:43 <byte-> I can certainly see it being difficult to extend a GUI in ways it wasn't designed for.
12:46:45 <EvilTerran> and were they *good* GUIs you were left with at the end?
12:46:47 <byorgey> jtootf: what glguy showed above is probably good.
12:46:57 <byte-> but that's not nearly as difficult as writing a parser because your parser generator couldn't handle your syntax.
12:47:08 <LoganCapaldo> oh man
12:47:12 <EvilTerran> were they clean and dynamic and intuitive and efficient to use?
12:47:20 <byte-> EvilTerran, I assume some of them are.
12:47:20 <byorgey> jtootf: but that won't work for Integral types, so one could imagine also something like (Integral a, Fractional b) => [a] -> b
12:47:26 <EvilTerran> if your parser generator can't handle your syntax, you can get a stronger parser generator
12:47:33 <byte-> considering the size of the pool you'd be taking them from.
12:47:40 <LoganCapaldo> i think assuming any graphical programming language's GUI is going to be less complex than a parser is naive
12:47:47 <byte-> ok, this discussion is going nowhere.
12:47:51 <EvilTerran> if your GUI toolkit can't handle your envisaged interface, you can get a stronger toolkit
12:48:01 <byte-> the point is, text-based programming is a kludge.
12:48:03 <byte-> it's inelegant.
12:48:36 <EvilTerran> and my point is, the implementation of any programming language/whatever is a trivial point compared to designing a *good* langauge in the first place
12:48:41 <EvilTerran> be it graphical or textual
12:48:49 <jtootf> byorgey: I see, thank you. I should use generic length for a generic function and Int-length for integral types I think then...
12:49:03 <jtootf> thank you all, this was very helpful :)
12:49:25 <EvilTerran> byte-, and i don't find text-based programming a kludge. i point to maths (a far better established subject than programming) being full of text and relatively sparse on diagrams as evidence that text *works*
12:49:58 <byte-> that's a deceptive comparison.
12:50:16 <EvilTerran> and why?
12:50:19 <axm> hi, anyone listening who has a bit insight in Network.URI?
12:50:37 <byte-> because you can render a formula in a 2d environment
12:50:41 <byte-> the same way it would look as plaintext.
12:50:49 <byte-> the difference is that it's stored differently
12:50:56 <byte-> and that it can be manipulated symbolically.
12:51:14 <byte-> you don't have to worry about putting parenthesis to clarify your intent.
12:51:20 <EvilTerran> how you're storing the thing is an implementation detail
12:51:28 <EvilTerran> parentheses etc can be dealt with by any good IDE
12:51:28 <byte-> or accidentally forgetting parenthesis.
12:51:30 <byte-> EvilTerran, lol.
12:52:00 <byte-> true, but storing it without manipulation (my approach) makes more sense than the alternative.
12:52:16 <byte-> which is flattening it out and adding various characters here and there.
12:52:19 <EvilTerran> but having a a readily-available human-readable format for your code is such a great convenience, in so many ways, that i'm loathe to give it up unless you can give me *very* grand advantages
12:52:31 <byte-> I agree.
12:52:35 <EvilTerran> and why not store it in that format?
12:52:44 <byte-> why not store it as text?
12:53:07 <EvilTerran> forget i asked. it doesn't matter how you store it "by default".
12:53:09 <byte-> because there aren't many reasons to view/edit it as such.
12:53:22 <byte-> I'd be more inclined to provide a converter that can be used when necessary.
12:53:31 <byte-> but using a kludge as the storage format seems a bit extreme.
12:53:39 <lament> i think we should stop using text for human languages
12:53:49 <lament> human conversation isn't "flat"
12:53:49 <byte-> why?
12:53:52 <byte-> the parser's already written.
12:54:05 <byte-> and it's too complicated for us to change.
12:54:11 <byte-> code, OTOH...
12:54:18 <EvilTerran> my point remains that starting with something that *looks* plain-text is very convenient
12:54:18 <lament> oh, the parsers for programming languages are already written, too :)
12:54:32 <EvilTerran> even if it's stored as an AST in your editor
12:54:32 <byte-> lament, but it's possible to change them ;)
12:54:39 <EvilTerran> stored as an AST on disk
12:54:44 <byte-> EvilTerran, than we agree.
12:54:45 <EvilTerran> whatever.
12:54:46 <lament> writing a parser isn't exactly the hardest part of implementing a language
12:54:52 <byte-> *then
12:54:58 <byte-> EvilTerran, that's what I was talking about earlier.
12:55:10 <EvilTerran> being able to treat it like plain-text with zero hassle is vital.
12:55:14 <byte-> all the people professing "visual programming" by using some off-the-wall representation
12:55:22 <byte-> that doesn't even work well.
12:55:25 <ddarius> lament: Human conversation is rather linear (though I won't say entirely so)
12:55:48 <byte-> EvilTerran, the idea is to render everything as it would appear if it were plaintext
12:55:50 <lament> ddarius: in the same that programs are rather linear, yes.
12:56:02 <byte-> except for the areas that lend themselves to being graphical instead of textual.
12:56:07 <byte-> like blocks.
12:56:14 <byte-> (of code)
12:56:19 <ddarius> lament: Actually, I'd say programs are rather less linear than spoken/written natural language.
12:56:44 <lament> ddarius: depends on the style, admittedly haskell programs seem less linear than fortran code
12:56:52 <byte-> ddarius, there are more base elements in code.
12:57:00 <byte-> ddarius, but neither are particularly linear.
12:57:15 <EvilTerran> so it's an IDE that saves your code in a computer-readable representation of the AST rather than a human-readable one, and takes its liberties with presentation in some places. fine, that's an interesting idea.
12:57:18 <byte-> it's just that languages look that way because that's how we always read/write tem.
12:57:20 <byte-> them
12:57:22 <byte-> and think about them.
12:57:27 <lament> EvilTerran: you're talking about LISP, right? :)
12:57:38 <byte-> EvilTerran, well, you could always use xml as the storage format ;)
12:57:41 <byte-> or sexprs.
12:57:59 <monochrom> Human conversation is linear?  "Hey, honey, how was your weekend? Oh! I just remember! It's Cindy's birthday next Wednesday! We should celebarte!"  Human conversation is linear?
12:58:03 <byte-> EvilTerran, thanks for bearing with me.
12:58:13 <byte-> I find having discussions like this helps me clarify what I'm trying to say.
12:58:15 <JohnDoeKyrgyz> Hugs doesn't like 'newtype TicTacToe = [[Token]]'
12:58:19 <JohnDoeKyrgyz> Any ideas
12:58:33 <EvilTerran> i remain unconvinced that "takes its liberties with presentation" has much general use, but i look forward to seeing where that goes in future :)
12:58:45 <monochrom> No Haskell interpreter should like that. It's wrong. Need data constructor.
12:59:11 <byte-> EvilTerran, were you here when I was talking about how kludgy pl programming is in certain circumstances?
12:59:13 <monochrom> newtype TicTacToe = TTT [[Token]].   You can choose almost any name for TTT.
12:59:17 <EvilTerran> when you need the rigor and precision that both maths and programming demand, equations and formulae do an exceptional job
12:59:28 <EvilTerran> can you provide examples?
12:59:30 <byte-> I agree.
12:59:37 <JohnDoeKyrgyz> Thanks again.
12:59:42 <byte-> ((>1).) . gcd
13:00:05 <byte-> you could use the lambda form
13:00:06 <lament> Squeak (a smalltalk environment) has several "styles" for showing you code, which effectively completely change the syntax of smalltalk
13:00:07 <duaneb> ok, another easy question :)
13:00:09 <lament> that's pretty cute
13:00:13 <byte-> \x y -> (gcd x y) > 1
13:00:15 <axm> newtype ~= data, not type JohnDoeKyrgyz
13:00:17 <duaneb> how can I 'cast' an int to a  string?
13:00:18 <EvilTerran> oh, "pl" = "pointless", not "programming languages"?
13:00:23 <ddarius> monochrom: "though I won't say entirely so", that said, I don't take that as a counter-example that's beyond the ranges of non-linearity I admitted.  And indeed, "honey" is likely to respond only to the last part rather than answering the original question.
13:00:28 <duaneb> i.e. get "542" from 542
13:00:31 <monochrom> show 34  does wonder
13:00:41 <byte-> but then you're forced to add kludges on top of what it is you want it to do.
13:01:12 <EvilTerran> byte-, okay, let's see that presented more nicely in a graphical format
13:01:24 <byte-> you keep the usual notation.
13:01:32 <byte-> but optionally provide a way to 'direct' input/output.
13:01:43 <byte-> like piping, but as a graph.
13:01:50 <EvilTerran> what of that very example?
13:01:52 <byte-> you can duplicate return values and send them to different parts of the computation.
13:02:03 <dons> ?users
13:02:03 <lambdabot> Maximum users seen in #haskell: 439, currently: 438 (99.8%), active: 22 (5.0%)
13:02:09 <dons> awesome bananas
13:02:13 <byte-> actually, I just realized that was a bad example.
13:02:27 <byte-> in that case you'd be just as well off using implicit parameters.
13:02:31 <byte-> e.g. (gcd $0 $1) > 1
13:02:48 <byte-> anyway, the graph-based approach basically eliminates temporary variables.
13:02:51 <byte-> like, for example
13:02:56 <EvilTerran> aha. so that's where we're going.
13:03:10 <byte-> let a = f x in g a a
13:03:20 <byte-> would be represented as
13:03:29 <byte-> (in as well as I can draw it in IRC)
13:03:37 <byte->    f x
13:03:40 <byte->   /  \
13:03:44 <byte-> g _  _
13:03:57 <byte-> of course, those are supposed to be arrows.
13:04:26 <byte-> this is also useful for reordering where results are piped, etc.
13:04:37 <EvilTerran> i see what you're getting at, now
13:04:58 <ddarius> byte-: While this is a very common area to point to potential benefits, it's also clear that that also has practical issues with at least some code.
13:04:59 <byte-> in pl haskell you have to define a new operator each time you want to do something like that
13:05:04 <EvilTerran> i'm not especially fond of small-scoped local variables
13:05:11 <byte-> ddarius, it's optional.
13:05:18 <byte-> an extension of the usual approach.
13:05:47 <ddarius> byte-: Well then implement it, get users, and see what happens.
13:05:56 <byte-> incidentally, I wouldn't be surprised if there were other useful notations like that
13:06:10 <byte-> which were skipped over because they couldn't be easily moulded into a linear format.
13:06:23 <byte-> *molded
13:06:27 <byte-> don't know how that u got in there.
13:06:32 <noteventime> I'm having a problem with syntax, but I'm not sure on the terminology. I want to restrict three types to a type class (like foo :: Integral a, b, c =>), is that possible without having to write the typeclass name thrice?
13:06:45 <byte-> EvilTerran, in any event.
13:06:57 <byte-> EvilTerran, now that you know what I'm talking about, any suggestions on how I can make that clearer in my essay?
13:07:16 <byte-> I fear the only way to do that would be to post a mockup or something
13:07:21 <byte-> which would require work :(
13:07:39 <EvilTerran> "local variables are to data flow what goto's are in control flow. let's get rid of the little buggers."
13:07:52 <byte-> EvilTerran, nice.
13:08:05 <byte-> but I wasn't planning on using that as writing material.
13:08:06 <ddarius> EvilTerran: local variables are like labels, not like gotos.
13:08:36 <EvilTerran> ddarius, well, the binding's the label; referring to them's like the goto
13:08:48 <hpaste>  loupgaroublond pasted "syb-with-class won't compile" at http://hpaste.org/4836
13:08:50 <byte-> EvilTerran, that's just something that would be in my ideal language.
13:09:03 <byte-> I'm talking about clarifying the allegory.
13:09:09 <loupgaroublond> can anyone explain why that code won't compile, especially since i got it straight of hackage?
13:09:21 <ddarius> EvilTerran: Correct, but so is referring to anything and not using local variables doesn't immediately make references not like gotos.
13:09:31 <EvilTerran> i'm no good with allegories, i'm afraid. i'm the kind to say what i mean
13:09:31 <byte-> loupgaroublond, make sure some of it didn't quantum tunnel into your neighbor's codebase.
13:09:44 <EvilTerran> ddarius, sure, i'm overstating it a bit
13:10:00 <byte-> is it at least clear that I'm saying text editors are outdated?
13:10:04 <loupgaroublond> byte-: excuse me?
13:10:04 <byte-> at the end?
13:10:12 <byte-> loupgaroublond, lol, it's a joke.
13:10:17 <loupgaroublond> i thought so....
13:10:18 <byte-> a quantum mechanics joke.
13:10:34 <loupgaroublond> i guess i won't be using happs today
13:10:41 <ddarius> EvilTerran: I'm suggesting that you are overstating it rather more than a bit, though it makes a catchy motto and like most is misleading at best.
13:10:50 <byte-> well...try to be less sad and more happY.
13:10:51 <byte-> ;)
13:11:04 <EvilTerran> byte-, yeah, that's clear enough
13:11:08 <loupgaroublond> you're on a roll today... :P
13:11:13 <byte-> actually, I think I might copy that phrase down.
13:11:16 <byte-> if I ever need it.
13:11:26 <EvilTerran> ddarius, it's not local variables as a whole that bother me
13:11:38 <EvilTerran> it's more ones that only appear once, a few lines from where they're bound
13:11:46 <byte-> it's the ones that only hinder your understanding of what it does.
13:11:55 <byte-> *what the code does
13:12:03 <EvilTerran> or that only appear twice, right next to each other
13:12:05 <EvilTerran> or whatever
13:12:18 <EvilTerran> (\xs -> xs ++ xs) vs join (++)
13:12:51 <ddarius> EvilTerran: That's fine, but irrelevant to relating them to gotos (or labels).
13:12:52 <byte-> EvilTerran, that's mostly a case for implicit parameters or currying, though.
13:13:07 <EvilTerran> do { foo <- getMyFoo; bar <- getHisBar; baz <- getYourBaz; eek foo bar baz } vs (baz (<- getMyFoo) (<- getMyBar) (<- getMyBaz))
13:13:18 <byte-> although...
13:13:20 <ddarius> byte-: Neither implicit parameters nor currying really deal with his problem.
13:13:39 <byte-> ddarius, the example he gave.
13:13:43 <byte-> was solved because ++ is curried.
13:13:54 <byte-> in a case like \x y -> (gcd x y) > 1
13:13:58 <EvilTerran> s/(baz/(eek/, but anyway
13:14:06 <byte-> it would be solveable by implicit parameters
13:14:09 <byte-> (gcd $0 $1) > 1
13:14:09 <glguy> EvilTerran: that one is much clearer as: liftM3 eek getMyFoo getHisBar getYourBaz though
13:14:14 <glguy> than any specialextension
13:14:15 <EvilTerran> or (eek <$> getMyFoo <*> getMyBar <*> getMyBaz)
13:14:29 <glguy> iI eek getMyFoo getMyBar getMyBaz Ii
13:14:35 <EvilTerran> glguy, i know. that was just the first syntax that sprang to mind, for whatever reason :P
13:15:38 <EvilTerran> however, in the do{...} format, those extra variables are, imo, a disaster
13:15:48 <byte-> yeah, I was never fond of those.
13:16:00 <byte-> I miss my 'print (readline)'
13:16:02 <EvilTerran> but there's situations in haskell where you end up using local variables like that, because the only way to get around doing so is even messier
13:16:04 <JohnDoeKyrgyz> I have a function 'listify :: Num a => b -> a -> [b]' which produces a list of items b that is a elements long. Is there a standard haskell function like this?
13:16:19 <byte-> EvilTerran, well, to be fair, my solution doesn't solve those.
13:16:19 <glguy> :t replicate
13:16:24 <lambdabot> forall a. Int -> a -> [a]
13:16:25 <byte-> because those aren't really local variables.
13:16:27 <EvilTerran> byte-, putStr =<< readLine?
13:16:31 <byte-> they're needed for sequencing.
13:16:41 <EvilTerran> byte-, except if you don't care about the sequencing
13:16:46 <glguy> > replicate 5 'a'
13:16:47 <lambdabot>  "aaaaa"
13:16:48 <byte-> EvilTerran, well then yeah.
13:16:56 <byte-> EvilTerran, oops, forgot about =<<
13:17:23 <byte-> I suppose I should get back to work on my interpreter after I proofread this essay again.
13:18:02 <EvilTerran> i guess my attitude is to keep thinking up new, cunning ways of laying out text to get rid of as many of these little redundant names as possible
13:18:09 <byte-> actually, I think I'm more fond of readLine >>= putStr
13:18:11 <EvilTerran> while you're more eager to throw graphics at it
13:18:30 <EvilTerran> in the end, we both want the same thing :)
13:19:02 <byte-> well, it's not that I'm prejudiced against linear layouts.
13:19:17 <byte-> it's just that I don't like shoving non-linear information into text and obsfucating it.
13:19:32 <byte-> because that makes it harder to comprehend and to reason about.
13:19:37 <EvilTerran> indeed
13:19:45 <byte-> I suppose that's my HCI background coming through.
13:20:11 <byte-> and by "background" I mean the books and articles I've read on the subject...
13:22:01 <byte-> incidentally.
13:22:15 <byte-> I forgot to mention one of the other niceties of storing code as a tree.
13:22:25 <byte-> you don't have to use variable names as identifiers anymore.
13:22:26 <Sizur> you guys are still about the same stuff? hah
13:22:36 <byte-> so you can use any character you want when naming things.
13:22:38 <sioraiocht> so I want to write a theorem prover in haskell for first order logic, and i'm not sure how to represent logical statements
13:22:47 <sioraiocht> should I just use an ADT?
13:22:54 <ddarius> sioraiocht: Why not?
13:23:00 <ddarius> That would be the obvious thing.
13:23:02 <byte-> and you can instantly rename every single occurance of a variable (assuming you reference variables by ID values instead).
13:23:26 <EvilTerran> > fix (\xs -> 1 : (xs >>= \x -> [1+x, 1/(1+x)])) :: [Rational]
13:23:27 <sioraiocht> ddarius: okay, making sure i wasn't nuts..
13:23:27 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
13:23:39 <EvilTerran> there's something that's hard to phrase nicely in haskell
13:24:10 <sioraiocht> lol
13:24:45 <byte-> I'm not even sure what it does.
13:24:51 <byte-> but then I'm not fond of the list monad.
13:24:54 <ddarius> EvilTerran: I don't regard that as particularly not nice.
13:25:02 <byte-> and by "fond" I mean I never took the time to figure out how it works.
13:25:06 <EvilTerran> > fix $ (1:) . concatMap (\x -> [1+x, 1/(1+x)]) :: [Rational] -- a minor improvement
13:25:07 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
13:25:07 <matthew-_> byte-: I'm not fond of the IO monad ;)
13:25:21 <EvilTerran> byte-, it's a list of all the positive rational numbers
13:25:24 <byte-> EvilTerran, ok, that's better.
13:25:31 <sjanssen> EvilTerran: IMO, let is more clear there
13:25:46 <EvilTerran> sjanssen, let rationals = ... in rationals?
13:25:55 <EvilTerran> it's more self-documenting, i'll give you that
13:26:06 <sjanssen> EvilTerran: or even a top-level binding
13:26:19 <EvilTerran> true
13:26:38 <byte-> sjanssen, that's not really relevant.
13:26:46 <byte-> binding it to a name doesn't improve the clarity of the code itself.
13:26:56 <EvilTerran> well
13:27:20 <byte-> you'll be able to figure out what it's _supposed_ to do more easily.
13:27:23 <byte-> but not what it actually does.
13:27:27 <EvilTerran> rats = 1 : concatMap (\x -> [1+x, 1/(1+x)]) rats -- this is clearer, imo
13:27:43 <LoganCapaldo> > let rationals = 1 : ( [ 1 + x | x <- rationals ] ++ [ 1 / (1 + x) | x <- rationals ]) in rationals -- I don't know this is correct
13:27:44 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
13:27:48 <sjanssen> yes, I think that's perfect
13:27:53 <EvilTerran> but now it's not what I started with
13:28:02 <byte-> EvilTerran, oh, nevermind.
13:28:12 <byte-> I assumed he just meant putting a 'rationals = ' in front of it.
13:28:53 <LoganCapaldo> hmm mine sucks
13:29:17 <byte-> I noticed.
13:29:49 <byte-> that's a pretty complicated way of writing [1..]::[Rational]
13:30:03 <byte-> ;)
13:30:07 <EvilTerran> > let rats = 1 : concat (transpose [map succ rats, map (recip.succ) rats]) in rats :: [Rational]
13:30:09 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
13:30:28 <LoganCapaldo> well no it's a complicaed way of writting [1..] ++ somethingwe'llnevergetto
13:30:37 <EvilTerran> > let rats = 1 : concat (transpose [map (+1) rats, map ((1/).(+1)) rats]) in rats :: [Rational]  -- if you prefer
13:30:38 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
13:31:03 <sjanssen> rats = 1 : [r' | r <- rats, r' <- [1 + r, 1 / (1 + r)]]
13:31:16 <sjanssen> if you want to go list comprehension-crazy
13:31:27 <EvilTerran> the problem here is the desire to make a two-item list, i guess
13:31:49 <LoganCapaldo> I kinda wish you could say [ x,y | x <- ...
13:31:54 <EvilTerran> indeed
13:32:03 <EvilTerran> and you could make it work with monad comprehensions too, iirc
13:32:17 <JohnDoeKyrgyz> I'm trying to write a generic game library for games that can be represented as trees, such as tic tac toe. I want to have a class named Board, and a list of list '[[]]' to be the board for tic tac toe. I want everything that is a Board to be a member of class Show. Is this possible without having the Tic Tac Toe board loose all the capability of being a list?
13:32:21 <sjanssen> concat [[x, y] | ...] -- works
13:32:30 <LoganCapaldo> yeah I know
13:32:42 <EvilTerran> [x0, ..., xN] = msum (map return [x0, ..., xN]), iirc
13:32:51 <EvilTerran> would make a reasonable definition
13:33:36 <byte-> well, this has been fun.
13:33:37 <duaneb> is there a pastebot around here somewhere?
13:33:39 <sjanssen> rats = 1 : concat [[1 + r, 1 / (1 + r)] | r <- rats] -- is this better?
13:33:41 <EvilTerran> then the meaning of [x0...xN | ...] would follow fairly directly by following the usual comprehensions-to-monad transformation
13:33:41 <byte-> but I'm all PL theoried out for the day.
13:33:43 <EvilTerran> !paste
13:33:43 <hpaste> Haskell paste bin: http://hpaste.org/
13:33:46 <byte-> I'm gonna go hop on TF2.
13:33:49 <byte-> see you guys later.
13:34:09 <hpaste>  duaneb pasted "simple prime function" at http://hpaste.org/4837
13:34:10 <LoganCapaldo> sjanssen: I think I liked your first list comp version better
13:34:20 <EvilTerran> strangely, i prefer the second
13:34:24 <duaneb> that's a simple prime-tester...I think
13:34:34 <EvilTerran> the second reads consistently right-to-left all the way across
13:34:35 <duaneb> but it fails miserably in ghci
13:34:40 <duaneb> what's going wrong?
13:34:51 <EvilTerran> your types
13:34:55 <EvilTerran> ?type sqrt
13:34:56 <lambdabot> forall a. (Floating a) => a -> a
13:34:58 <EvilTerran> ?type mod
13:34:59 <lambdabot> forall a. (Integral a) => a -> a -> a
13:35:21 <EvilTerran> you can't sqrt something of an integral type, and can't take the mod of something of a floating type
13:35:22 <duaneb> I see
13:35:57 <LoganCapaldo> > let rats = 1 : [ r' | r' <- [ 1 + r , 1 / (1 + r) ], r <- rats ] :: [Rational] -- will now discover if order matters
13:35:57 <lambdabot>  Parse error at end of input
13:36:09 <LoganCapaldo> oops
13:36:14 <EvilTerran> duaneb, i would suggest x <- takeWhile (\i -> i^2 <= n) [2..]
13:36:26 <LoganCapaldo> > let rats = 1 : [ r' | r' <- [ 1 + r , 1 / (1 + r) ], r <- rats ] in rats :: [Rational] -- will now discover if order matters
13:36:27 <lambdabot>   Not in scope: `r'
13:36:43 <LoganCapaldo> it does
13:36:51 <EvilTerran> or, if you prefer, x <- takeWhile ((<=n).(^2))
13:36:57 <LoganCapaldo> do what I mean, not what I say
13:37:04 <duaneb> EvilTerran: yes, that might work better, but I want to see if my way works
13:37:05 <EvilTerran> er, don't forget the [2..] on the end there :P
13:37:10 <duaneb> is there an integer sqrt?
13:37:27 <EvilTerran> not in the standard libraries
13:37:40 <duaneb> or a method to cast between floating and integer?
13:37:51 <EvilTerran> it's fairly easy to write a O(log n) isqrt, iirc
13:37:54 <nornagon> 'round'
13:38:00 <EvilTerran> you can cast, but it'll be imprecise
13:38:08 <duaneb> EvilTerran: well with primes
13:38:17 <duaneb> you don't need to be precise
13:38:30 <EvilTerran> using floats when your entire problem is in integers makes baby jesus cry
13:39:00 <LoganCapaldo> floor . sqrt . fromIntegral $ ?
13:39:25 <FunctorSalad> "loops are weary, unneccessary when map will do just as well" :)
13:39:25 <int-e> EvilTerran: can you say "complex DFT based integer multiplication"? *ducks*
13:39:42 <noteventime> Is it not possible to declare type class instances for functions?
13:39:54 <nornagon> LoganCapaldo: horrible floating point doomery :)
13:39:56 <EvilTerran> > [(x,y) | x <- [0..], let y = floor . sqrt . fromIntegral $ x, x /= y]
13:39:56 <lambdabot>  [(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(12,3),(13,3)...
13:40:06 <EvilTerran> er, waitaminute
13:40:09 <EvilTerran> > [(x,y) | x <- [0..], let y = floor . sqrt . fromIntegral $ x^2, x /= y]
13:40:16 <lambdabot> Terminated
13:40:16 <FunctorSalad> int-e: hmm given the FFT and how FT plays with convolution, I think it's not that hard
13:40:21 <EvilTerran> of, fine :P
13:40:25 <LoganCapaldo> nornagon: isn't this just to get the "stopping" point though right?
13:40:34 <EvilTerran> int-e, i'd rather not, thanks
13:40:35 <FunctorSalad> int-e: sorry, misunderstood context
13:40:39 * LoganCapaldo hasn't actually looked at the paste
13:40:46 <duaneb> my brain just imploded
13:41:09 <EvilTerran> > [(x,y) | x <- [0..], let y = floor . sqrt . fromIntegral $ x^2]
13:41:10 <lambdabot>  [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11)...
13:41:12 <FunctorSalad> int-e: in that case, yeah I agree it's pretty amazing that floats are used for an int problem
13:41:45 <EvilTerran> that's working remarkably well. i'd've expected it to've got several of 'em one-too-low
13:42:15 <FunctorSalad> EvilTerran: I add an epsilon for safety
13:42:46 <noteventime> Could someone explain what "All instance types must be of the form (T a1 ... an) where a1 ... an are distinct type *variables*" means?
13:42:47 <duaneb> <[2..]
13:42:50 <duaneb> < [2..]
13:42:57 <duaneb> > [2..]
13:42:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
13:43:01 <duaneb> nifty
13:43:04 <FunctorSalad> of course, that's "safety-by-hoping-that-the-numbers-will-be-large-compare-to-epsilon" :)
13:43:09 <duaneb> :t True
13:43:09 <lambdabot> Bool
13:43:14 <sioraiocht> hrm i have a problem.... if I have data Statement = Var String | Forall (Var String) Statement
13:43:16 <sioraiocht> that err, doesn't work
13:43:19 <sioraiocht> obviously
13:43:37 <sioraiocht> but how can I get the first arguemnt of Forall to have to be a Variable?
13:44:08 <EvilTerran> just say data Statement = Var String | Forall String Statement
13:44:22 <LoganCapaldo> noteventime: it means you can't do something like instance Class (T X) it has to be instance Class (T a)
13:44:25 <sioraiocht> wow, i've been away from functional programming for too long =p
13:44:31 <sjanssen> noteventime: it means that you can't write "instance C (T X)"
13:44:36 <EvilTerran> you can slap a Var around the parameter to Forall if you want it to be ::Statement somewhere else
13:44:42 <sjanssen> noteventime: but you can write "instance C (T a)"
13:44:44 <ddarius> sioraiocht: A variable is just a String.
13:44:49 <sioraiocht> ddarius: right
13:44:58 <sioraiocht> i think i figured it out now..lol
13:45:29 <monochrom> Yes, apparently you were thinking subclasses.
13:45:41 <noteventime> sjanssen + LoganCapaldo "instance OtherClass a => ThisClass (a -> a -> a)" triggers it :-|
13:45:53 <LoganCapaldo> right
13:46:06 <noteventime> hmm
13:46:09 <LoganCapaldo> That's ThisClass ((->) a ...
13:46:13 <LoganCapaldo> sort of
13:46:31 <LoganCapaldo> a -> a -> a is "too specific"
13:46:58 <noteventime> So how would I declare an instance for a binary function?
13:47:12 <EvilTerran> > let isqrt x = search 0 bound where bound = head $ dropWhile ((<=x).(^2)) [0..]; search lo hi | hi - lo > 1 = if mid^2 > x then search lo mid else search mid hi | otherwise = lo where mid = (hi + lo) `div` 2 in [(x,isqrt x) | x <- [0..]]
13:47:12 <lambdabot>  [(0,0),(1,1),(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(...
13:47:13 <monochrom> (->) a ((->) a a).  Think of it as C a (C a a). Of course not allowed. (C a a) is not another variable.
13:47:46 <noteventime> monochrom: Thanks
13:48:00 <monochrom> Like for example you can have "instance ThisClass (a,b)" but not "instance ThisClass (a, (a, a))". Same reason.
13:48:04 <LoganCapaldo> noteventime: you can use a newtype, newtype BinaryF a = BF (a -> a -> a) instance SomeClass a => Class (BinaryF a)
13:48:16 <FunctorSalad> sqrt in integers:
13:48:19 <FunctorSalad> > let n = 200 in take 10 $ iterate (\k -> (k + n `div`k) `div`2) 1
13:48:20 <lambdabot>  [1,100,51,27,17,14,14,14,14,14]
13:48:22 <noteventime> LoganCapaldo: Good idea, thanks
13:48:44 <FunctorSalad> (not sure whether this algo is actually correct, and of course you have to replace 10 by a termination check)
13:49:12 <int-e> > let n = 15 in take 10 $ iterate (\k -> (k + n `div`k) `div`2) 1 -- be careful :P
13:49:13 <lambdabot>  [1,8,4,3,4,3,4,3,4,3]
13:49:23 * EvilTerran thinks
13:49:33 <FunctorSalad> d'oh :( sorry, was just a naive guess
13:49:38 * FunctorSalad feels stupid now
13:50:03 <monochrom> You probably were inspired by Newton.
13:50:08 <int-e> FunctorSalad: no, it's a perfectly fine idea, it's just a little hard to get the corner cases correct :)
13:50:13 <FunctorSalad> inspired? I just mindlessly translated it ;)
13:50:42 <FunctorSalad> int-e: maybe if we terminate once k^2 \leq n, (k+1)^2 > n?
13:50:54 <monochrom> The jump from continuous reals to discrete ints means not translation.
13:50:55 <FunctorSalad> but I'm not sure whether there can't be larger oscillations
13:51:36 <duaneb> > do let factors n = [x | x <- [2..(floor (sqrt n))], n `mod` x == 0] in factors 4
13:51:37 <lambdabot>  Add a type signature
13:51:56 <duaneb> how can i add a type signature in ghci?
13:51:57 <monochrom> Try to put on your mathematician hat and do a bit of analysis and proof.
13:51:58 <FunctorSalad> monochrom, what do you mean? I'm not saying it was a good translation
13:51:58 <int-e> FunctorSalad: no, there can't be larger oscillations.
13:52:13 <monochrom> Ha ok, not-good translation.
13:52:58 <LoganCapaldo> > let { a :: Int ; a = 3 } in a -- duaneb one way
13:52:58 <lambdabot>  3
13:53:02 <int-e> > let n = 15 in take 10 $ iterate (\k -> (k + 1 + (n-1) `div`k) `div`2) 1
13:53:03 <lambdabot>  [1,8,5,4,4,4,4,4,4,4]
13:53:28 <EvilTerran> > let a = 3 in (a :: Int) -- another way
13:53:28 <lambdabot>  3
13:53:47 <FunctorSalad> monochrom: sorry, too lazy right now to think about nasty rounding issues :)
13:54:15 <duaneb>  do let factors n = [x | x <- [2..(floor (sqrt (fromIntegral n)))], n `mod` x == 0] in factors 18
13:54:19 <monochrom> It's ok :) Just don't rely on intuition. Few people have the right intuition.
13:54:21 <duaneb> > do let factors n = [x | x <- [2..(floor (sqrt (fromIntegral n)))], n `mod` x == 0] in factors 18
13:54:21 <lambdabot>  [2,3]
13:54:25 <duaneb> > do let factors n = [x | x <- [2..(floor (sqrt (fromIntegral n)))], n `mod` x == 0] in factors 72
13:54:26 <lambdabot>  [2,3,4,6,8]
13:54:56 <FunctorSalad> monochrom: well my intuition was uneasy with it and of course I would prove it before using it for anything important
13:55:27 <EvilTerran> duaneb, it's also worth noting that (null xs) is better than (length xs == 0)
13:55:39 <EvilTerran> as it won't require compilation of the length of the list
13:55:43 <duaneb> ok
13:55:49 <EvilTerran> er, s/compilation/calculation/
13:55:54 <EvilTerran> ?src null
13:55:54 <lambdabot> null []     = True
13:55:55 <lambdabot> null (_:_)  = False
13:56:01 <LoganCapaldo> we need a haskell lint for such things
13:56:27 <EvilTerran> it's also better than (xs == []), as that one would impose an Eq constraint on the type of the elements of the list
13:56:29 <Cale> LoganCapaldo: iirc, ndm was working on such a thing
13:57:11 <FunctorSalad> I guess you would simply prove that 1. if k is not the currect result, then the distance to k decreases with each step and 2. the iteration leaves the correct k unchanged...
13:57:17 <FunctorSalad> *correct
13:57:19 <int-e> FunctorSalad: You may find http://int-e.home.tlink.de/tmp/isqrt.pdf interesting. (Probably not original, I wrote the paper for my own amusement.)
13:57:24 <Mitar> how could I read binary PPM file into a Haskell array?
13:57:38 <Mitar> how can read one "byte" from a file (not character)?
13:58:07 <LoganCapaldo> @seen ndm
13:58:07 <lambdabot> I saw ndm leaving #haskell 1h 21m 11s ago, and .
13:58:16 <Cale> Mitar: hmm, I forget how PPM works, isn't it just a text format?
13:58:38 <EvilTerran> Cale, there's a binary version as well
13:58:43 <Cale> Mitar: Data.ByteString can be used to read the raw bytes.
13:58:45 <LoganCapaldo> @ask ndm were you working on a lint for haskell? I'd be interested in attempting to contribute to such a thing.
13:58:45 <lambdabot> Consider it noted.
13:58:48 <Cale> (as Word8 values)
13:58:55 <duaneb> how can I do a multiple declaration let in a do?
13:58:58 <Mitar> it is really simple format, first three ASCII lines descirbing the format
13:58:59 <EvilTerran> but it's basically <magic number><width><height><r><g><b><r><g><b><r><g><b>...
13:59:06 <EvilTerran> or something
13:59:09 <Cale> duaneb: well, with layout, it looks like:
13:59:13 <Cale> let foo = bar
13:59:18 <Mitar> and then a stream of bytes, every three bytes representing the color
13:59:19 <Cale>     quux = quuux
13:59:24 <duaneb> (on one line?)
13:59:25 <Cale> in foo quux
13:59:32 <Cale> on one line, it looks like:
13:59:35 <FunctorSalad> int-e: I see
13:59:46 <Cale> let foo = bar; quux = quuux in foo quux
13:59:50 <Mitar> what happens if I read a binary file into a String?
14:00:05 <EvilTerran> Mitar, each Char gets one byte
14:00:12 <LoganCapaldo> Cows rise from the dead
14:00:13 <EvilTerran> the standard IO functions don't do unicode
14:00:24 <Cale> (However, that might change at some point.)
14:00:25 <EvilTerran> even though the Char type supports it
14:00:27 <Mitar> so ord would give me raw data?
14:00:31 <EvilTerran> yup
14:00:40 <EvilTerran> best make sure you open the file in binary mode, mind
14:00:57 <Cale> The standard IO functions are supposed to do unicode, but they don't, so I wouldn't count on it.
14:00:58 <EvilTerran> ?hoogle binary
14:00:58 <lambdabot> System.IO.withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
14:00:58 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
14:00:58 <lambdabot> System.IO.hSetBinaryMode :: Handle -> Bool -> IO ()
14:01:04 <monochrom> I recommend not relying on getChar etc. reading byte-wise, even though it does now.
14:01:05 <Mitar> so how can I read three lines and then get the rest as a String?
14:01:11 <Cale> It's *much* easier to use Data.ByteString
14:01:29 <EvilTerran> i would hope it'd continue to read byte-wise, if the file was in binary mode
14:01:36 <FunctorSalad> what would one use for unicode then?
14:01:38 <hrehf> Mitar http://netpbm.sourceforge.net/doc/ppm.html
14:01:38 <lambdabot> Title: PPM Format Specification
14:01:44 <monochrom> And yes, Data.ByteString.hGet is much more accessible than System.IO.hGetBuf.
14:02:04 <Cale> FunctorSalad: I think there are some UTF-8 encoding libraries.
14:02:24 <FunctorSalad> ok
14:02:26 <duaneb> > do let factors n = [x | x <- [2..(floor (sqrt (fromIntegral n)))], n `mod` x == 0]; prime n = null (factors n); primes = filter prime [2..] in take 20 primes
14:02:26 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
14:02:37 <duaneb> my first working program :)
14:03:20 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
14:03:21 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:03:26 <monochrom> This is just semantics, but IMO "char" implies non-binary text.
14:03:33 <duaneb> hehe
14:03:44 <monochrom> IOW I'd be happier if getChar were meaningless in binary mode.
14:04:22 <Cale> > nubBy (((> 1) .) . gcd) [2..]
14:04:23 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:04:41 <Cale> (inefficient, but it's short :)
14:04:45 <monochrom> Completely, totally meaningless. Unreliable, unusable. Randomized behaviour when in binary mode. Just to frustrate errant programmers enough to discourage them from using meaningless operations.
14:05:06 <FunctorSalad> some told me how to do lazy unbounded sieve of eratosthenes the other day. that's quite cool
14:05:08 <EvilTerran> > nubBy (((==0).).flip mod) [2..] -- superior
14:05:09 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:05:19 <EvilTerran> @unpl (((==0).).flip mod)
14:05:19 <lambdabot> (\ h k -> (mod k h) == 0)
14:05:25 <FunctorSalad> s/some/someone
14:05:25 <Cale> monochrom: Just throw an exception :)
14:05:45 <Mitar> so how could I easily read the header of the PPM file and then the rest?
14:06:01 <EvilTerran> monochrom, now that's just being mean. just have it invoke error "...", fer crying out loud.
14:06:11 <Mitar> probably I can read the rest with hGetContents on the handler, after I read the header
14:06:33 <Cale> FunctorSalad: Yeah, that's kind of sort of what this is, though when you look closely, it's not as good as the real sieve. There are lazy implementations which are like the real sieve, but they take more characters to type :)
14:06:56 <monochrom> I keep forgetting that exceptions and error exist. I have been programming purely for too long.
14:07:12 <EvilTerran> mine is the real sieve, isn't it?
14:07:27 <Cale> EvilTerran: No, not quite.
14:07:34 <Cale> EvilTerran: The complexity is rather different.
14:07:35 <EvilTerran> i guess you could be even more efficient with your "divides" relation
14:07:47 <monochrom> Eh? If you mod, it is no longer the real sieve. Also how costly is nub? I heard very costly.
14:08:36 <EvilTerran> istr the mod version out-performs the ghc version
14:08:39 <sioraiocht> anyone know the character codes for the logic symbols?
14:08:43 <sioraiocht> or rather, wher ei could find them?
14:08:45 <EvilTerran> s/ghc/gcd/, even
14:08:58 <monochrom> I have a real sieve using STUArray Bool. That is bit vector. Lightning. Split second for the primes below 500,000.
14:08:59 <sioraiocht> nevermind
14:09:02 <sioraiocht> ignore me today
14:09:40 <EvilTerran> monochrom, yeah, but that's practically imperative
14:09:53 <monochrom> It is lightning, but must compile with -O2. In ghci interpreter, pretty slow. :)
14:10:26 <monochrom> I think sieving is one of those tasks better done imperatively.
14:10:36 <EvilTerran> if you're gonna cheat and use ST, i'm gonna cheat and grab my primes off a file on disk :P
14:11:00 <monochrom> Or else, there is a paper on how to sieve functionally.
14:11:39 <EvilTerran> http://www.primegrid.com/torrent.php :D
14:11:40 <lambdabot> Title: Download Prime Lists
14:12:00 <Cale> There was a huge discussion on how to implement a real sieve of Eratosthenes lazily.
14:12:15 <Cale> Er, on the haskell-cafe list, iirc.
14:12:19 <monochrom> There are still two differences between STUArray and file. (1) ST still has a safe functional faÃ§ade. (2) External file adds extra unreliability.
14:12:45 <LoganCapaldo> STUArray is backed by a file?
14:12:47 <EvilTerran> monochrom, they're both irrelevant to the original discussion, tho, which was how to do it in pure haskell
14:13:00 <dons> low level stuff usually has a particular evaluation order sorted out
14:13:05 <dons> so it looks imperative.
14:13:16 <monochrom> Oh, there was an original discussion? :)
14:13:29 <FunctorSalad> for the sieve, you can either first recurse and then filter or the other way around. makes my head explode :(
14:13:30 <EvilTerran> what exactly makes a prime generator a "real sieve", anyway?
14:13:52 <FunctorSalad> > let sieve (x:xs) = x : (sieve (filter (\y -> mod y x /= 0) xs)) in sieve [2..]
14:13:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:14:23 <EvilTerran> that's exactly the same as mine
14:14:26 <monochrom> I now remember half of her name. Melissa. She wrote that paper on functional sieving.
14:14:38 <gio123> Cale are u there
14:14:38 <EvilTerran> > nubBy (((==0).).flip mod) [2..]
14:14:39 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:14:39 <duaneb> > let pyth n = [(a, b, c) | a <- [3..(n-2)], b <- [a+1..(n-1)], c <- [b+1 .. n], (a^2) + (b^2) == (c^2)] in pyth 50
14:14:40 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
14:14:43 <gio123> Cale are u there?
14:14:48 <monochrom> She proposes a criterion for "real sieve". I think I like it.
14:14:52 <duaneb> > let pyth n = [(a, b, c) | a <- [3..(n-2)], b <- [a+1..(n-1)], c <- [b+1 .. n], (a^2) + (b^2) == (c^2)] in pyth 40
14:14:52 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(10,24,26),(12,16,...
14:14:56 <Cale> gio123: Yes, and you don't need to repeat.
14:15:14 <EvilTerran> (((==0).).flip mod) = (\y -> mod y x /= 0)
14:15:17 <gio123> <Cale> http://citeseer.ist.psu.edu/cache/papers/cs/1694/http:zSzzSzresearch.microsoft.comzSz~adgzSzPublicationszSzfp94.pdf/gordon94tutorial.pdf
14:15:18 <lambdabot> http://tinyurl.com/32honu
14:15:22 <gio123> can u go there
14:15:29 <EvilTerran> @src nubBy
14:15:30 <lambdabot> nubBy eq []             =  []
14:15:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:15:48 <EvilTerran> they're the same :)
14:15:53 <monochrom> I'm sure Cale has been There And Back Again. :)
14:16:00 <gio123> Cale coinduction is adual to induction
14:16:02 <FunctorSalad> EvilTerran: didn't get it at first because I didn't know how nubBy decides which argument to keep
14:16:04 <Cale> gio123: yes, I can.
14:16:05 <gio123> what does means?
14:16:23 <Cale> Well, that document makes that intuition clearer.
14:16:33 <duaneb> is there a list of lambdabot's functionality somewhere?
14:16:36 <duaneb> !doc
14:16:38 <duaneb> !help
14:16:43 <duaneb> !paste
14:16:43 <hpaste> Haskell paste bin: http://hpaste.org/
14:16:46 <duaneb> ahah!
14:16:47 <LoganCapaldo> @commands
14:16:47 <lambdabot> Unknown command, try @list
14:16:51 <duaneb> @list
14:16:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:16:52 <LoganCapaldo> @list
14:16:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:16:58 <EvilTerran> @quote stereo
14:16:58 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:17:04 <monochrom> @quote fugue
14:17:04 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
14:17:12 <duaneb> !bf
14:17:14 <monochrom> fugue > stereo
14:17:16 <gio123> <Cale>  it is hard to read ur comments here may i pm u?
14:17:23 <EvilTerran> bf is broken, iirc
14:17:40 <doserj> @quote stereo?
14:17:40 <LoganCapaldo> @bf
14:17:40 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
14:17:40 <lambdabot> Done.
14:17:45 <FunctorSalad> EvilTerran: anyway, I wasn't saying the version I mentioned was better; I gave this as an example of one of the two recursion styles I was thinking of
14:17:54 <EvilTerran> ah, i see
14:17:57 <LoganCapaldo> ! is not the right prefix for lambdabot
14:18:01 <FunctorSalad> the other being recurse first, then filter
14:18:02 <EvilTerran> i still don't see why mine isn't a "real sieve"
14:18:10 <FunctorSalad> I wasn't replying to that
14:18:15 <LoganCapaldo> you can use ? or @
14:18:34 <Cale> EvilTerran: The real sieve doesn't have to compute mod over and over.
14:18:50 <noteventime> Is there a more efficient way to write (Integral a, Integral b, Integral c)?
14:19:12 <monochrom> No.
14:19:15 <gio123> <Cale> do u accept pm?
14:19:30 <duaneb> @bf
14:19:30 <lambdabot> Done.
14:19:30 <noteventime> Too bad :-|
14:19:32 <Cale> gio123: go for it.
14:19:36 <duaneb> @bf +.
14:19:36 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
14:19:39 <monochrom> Err, there is a degenerate way. Don't write any type signature. :) But I don't recommend it.
14:19:40 <EvilTerran> Cale, what does it do instead?
14:19:46 <duaneb> what is bf?
14:19:51 <duaneb> @list
14:19:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:19:51 <monochrom> boyfriend
14:20:00 <monochrom> lambdabot's boyfriend :)
14:20:12 <EvilTerran> @vixen do you have a boyfriend?
14:20:12 <lambdabot> nope, that's why i'm here :)
14:20:24 <monochrom> Where is Melissa's paper so I can point EvilTerran to it? :)
14:20:24 <Cale> EvilTerran: You cross out the multiples of a number, so you're just doing multiplication, rather than mod (which is significantly more expensive than multiplication)
14:20:30 <duaneb> lambdabot hey
14:20:31 <noteventime> monochrom: Lol, GHC liked that even less
14:20:33 <EvilTerran> aha. i see.
14:20:43 <duaneb> !slap duaneb
14:20:47 <EvilTerran> @vixen say hi to duaneb
14:20:48 <lambdabot> hi
14:20:49 <duaneb> @slap duaneb
14:20:49 * lambdabot slaps duaneb
14:20:52 <duaneb> nice
14:21:12 <duaneb> @quote fortune
14:21:13 <lambdabot> No quotes match. Sorry.
14:21:14 <twanvl> you don't even have to do multiplication, just repeated addition
14:21:20 <duaneb> @fortune
14:21:21 <lambdabot> When I say the magic word to all these people, they will vanish forever.
14:21:21 <lambdabot> I will then say the magic words to you, and you, too, will vanish -- never
14:21:21 <lambdabot> to be seen again.
14:21:21 <lambdabot> 		-- Kurt Vonnegut Jr., "Between Time and Timbuktu"
14:21:23 <duaneb> nifty
14:21:35 <duaneb> @index nubBy
14:21:35 <lambdabot> Data.List
14:21:44 <EvilTerran> @src nub
14:21:44 <lambdabot> nub = nubBy (==)
14:21:47 <EvilTerran> ...
14:21:48 * monochrom tries googling "melissa sieve" out of desperation
14:21:49 <EvilTerran> @src nubBy
14:21:49 <lambdabot> nubBy eq []             =  []
14:21:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:22:02 <monochrom> Haha, it works! :)
14:22:03 * EvilTerran expects monochrom will get porn
14:22:09 <EvilTerran> huh. apparently not.
14:22:21 <EvilTerran> @go melissa sieve
14:22:22 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
14:22:23 <lambdabot> Title: [Haskell-cafe] Re: Genuine Eratosthenes sieve [Was: Optimization fun]
14:22:38 <monochrom> Yes, the first hit is right on. :)
14:23:32 <monochrom> Gosh, there exists a person named "Melissa Ann Sieve"...
14:23:48 <FunctorSalad> > take 20 $ intersect [0,2..] [0,3..] -- hmm
14:23:52 <lambdabot> Terminated
14:24:03 <FunctorSalad> oh wait, that can't work
14:24:14 <monochrom> Oleg also has his view in http://okmij.org/ftp/Algorithms.html#Eratosthenes-sieve
14:24:14 <lambdabot> Title: Algorithms and Data Structures
14:24:21 <LoganCapaldo> @type intersect
14:24:22 <monochrom> Err, s/in/at/
14:24:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:24:47 <Mitar> hm, where can i find any documentation on how can I make an IArray of my own type?
14:25:21 <monochrom> I'm afraid there is none.
14:25:36 <Mitar> so how can I make an array of my own type?
14:25:50 <duaneb> how can i get a string version of an Int?
14:25:52 <monochrom> What is "array of my own type"?  Do you really need it?
14:26:13 <Mitar> hmm, I would like to represent an image I am trying to read ...
14:26:21 <Mitar> so I would like to have an array of Color type
14:26:35 <Mitar> with the size of the image ... so every pixel is its own element
14:26:36 <monochrom> UArray of Word8 or something works wonder.
14:26:37 <Sizur> he means array containing Colors
14:26:59 <Mitar> where Color is a triplet of Float
14:27:28 <monochrom> If you don't need performance, ordinary Array works.
14:27:40 <EvilTerran> Array (Int,Int) (Float,Float,Float)?
14:28:32 <monochrom> If you need performance, I would build a layer upon UArray of Float.
14:29:08 <EvilTerran> ?type loop
14:29:09 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
14:29:19 <Mitar> type Image = (Ix a) => Array a Color
14:29:50 <doserj> that doesn't work
14:29:57 <monochrom> Do you already understand how to use arrays in Haskell?
14:30:13 <monochrom> And I seriously mean understand.
14:30:18 <Sizur> i dont
14:31:23 <Mitar> no :-)
14:31:34 <Mitar> i am learning ...
14:31:44 <Mitar> i know how to use lists in any possible way ..
14:31:48 <dons> ?users
14:31:48 <lambdabot> Maximum users seen in #haskell: 439, currently: 433 (98.6%), active: 27 (6.2%)
14:31:53 <Mitar> it is my first time with arrays ..
14:32:23 <Mitar> so please point me to some tutorial on the subjects
14:32:36 <duaneb> NickServ IDENTIFY Phl3tH4Ev0
14:32:45 <duaneb> please say noone sayw that
14:32:50 <duaneb> saw
14:32:52 <Korollary> I didn't see it.
14:32:57 <Sizur> saw what?
14:33:03 <Sizur> i saw no NickServ
14:33:06 <Sizur> ;)
14:33:13 * duaneb whaps limechat
14:33:19 <duaneb> @slap limechat
14:33:20 * lambdabot slaps limechat with a slab of concrete
14:33:39 <EvilTerran> i hope you've changed your password by now
14:34:12 <monochrom> Yikes, I don't know of an array tutorial either. I learned it by just reading the haskell standard library report.
14:34:19 * EvilTerran too
14:34:25 <EvilTerran> actually, i just read the haddock
14:34:33 <LoganCapaldo> arrays are hard. let's go shopping
14:35:14 <monochrom> Of course it was possible because I already knew the rest of Haskell pretty well. E.g., parametric polymorphism was like breathing, don't even need to think about it.
14:35:41 <Sizur> that seems really weird to me that the simplest possible data structure is hard in haskell
14:35:44 <DRMacIver> There are people for whom parametric polymorphism isn't like breathing? :)
14:36:01 <ddarius> There's not anything particularly different about arrays in Haskell as compared to arrays in most languages.
14:36:14 <monochrom> There are people for whom ad hoc polymorphism is like breathing. They will barf on parametric polymorphism.
14:37:15 <monochrom> For example the statement "(f :: forall a. a->a) implies (f=id or f diverges)" holds for one but fails for the other. Therefore some people will be stumbled.
14:38:01 <monochrom> Array is arguably not the simplest data structure.
14:38:12 <duaneb> is there a great haskell vector library?
14:38:13 <DRMacIver> I think you mean subtyping polymorphism rather than ad hoc there?
14:38:19 * FunctorSalad finds the word "forall" confusing for that. isn't "intersection" more accurate?
14:38:23 <Sizur> monochrom: what is then?
14:38:24 <EvilTerran> it's the simplest imperative data structure
14:38:39 <ddarius> DRMacIver: There is no reason for him to mean subtyping.
14:38:43 <EvilTerran> lists're probably the simplest functional data structure
14:38:54 <EvilTerran> ruling out trivial stuff like () and Maybe
14:38:55 <monochrom> Regardless of that, Haskell educational resources treat arrays at a low priority. That is a factor.
14:38:58 <Sizur> a list in haskell is infact a singly linked list. array is simpler
14:39:20 <mattam> a reference is ... simpler ?
14:39:29 <Sizur> it's not a data structure
14:39:35 <__pao___> did anyone give a look to scala? what's the point of view of a purist functional programmer on scala?
14:39:37 <monochrom> You're arguing simplicity by looking at implementations.
14:39:46 <DRMacIver> ddarius: I guess not.
14:39:47 <EvilTerran> Sizur, at the implementation level, yes. however, there's a lot more information to be known about a single Array value than there is of a single list value
14:39:53 * LoganCapaldo thinks (a,b) is the simplest
14:40:17 <EvilTerran> () is simplest!
14:40:24 <oerjan> no, () is simplest :D
14:40:30 <mattam> Well. I'm abusing the term a little
14:40:33 <FunctorSalad> forall a. a->a means â { a->a | a is a type }, doesn't it?
14:40:33 <DRMacIver> ddarius: The reason I was thinking subtyping is that the behaviour he's talking about is less "ad hoc polymorphism" and more "providing specific implementations for specific types given a generally applicable function"
14:40:35 <EvilTerran> data Nil -- even simpler!
14:40:37 <ddarius> monochrom: As far as I can tell there aren't any tutorials specifically on lists either.
14:40:38 <oerjan> EvilTerran: darn not typing fast enough
14:40:46 <DRMacIver> So it's more overriding than overloading.
14:40:57 <monochrom> Semantically, L = nil | cons L is a simpler algebra than indexing by naturals, ints, ...
14:40:57 <LoganCapaldo> EvilTerran: if there are no values can it still be data?
14:41:02 <mattam> Yeah, 0 is the simplest
14:41:32 <sjanssen> () ftw
14:41:34 <EvilTerran> LoganCapaldo, do you mean "data" in the sense of the haskell keyword?
14:41:44 <LoganCapaldo> no
14:41:45 <mattam> is 0 or 1 the simplest number ?
14:41:49 <EvilTerran> or in the sense of "data structure"?
14:41:49 <sjanssen> is there a 0 in Haskell?
14:41:57 <FunctorSalad> "simplest"?
14:42:00 <EvilTerran> sjanssen, any EmptyDataDecl, i guess
14:42:01 <mattam> I think you can define data Void
14:42:01 <LoganCapaldo> in the sense of data structure
14:42:02 <ddarius> sjanssen: Not a categorical one.
14:42:03 <Sizur> monochrom: anytime you add recursion, that's a different level already ;)
14:42:18 <monochrom> I always like my "alternative history" method of recognizing some of our prejudices.  In an alternative history, G-machines are the norm. There, cons lists have far simpler implementations than arrays.
14:42:20 <EvilTerran> LoganCapaldo, well, you've still got the different flavours of bottom
14:42:22 <ddarius> mattam: Define "number"
14:42:39 <LoganCapaldo> EvilTerran: but you can't observe them can you?
14:42:42 <mattam> Again, what's the less structured natural number ?
14:42:46 <EvilTerran> not purely, no
14:42:51 <mattam> That doesn't mean anything :)
14:43:16 <ddarius> monochrom: I think the real thing is that most Haskell educational resources are not geared to people with no programming experience.
14:43:19 * LoganCapaldo notes that (a,b) was motivated by taking data structure to mean "container" of sorts
14:43:32 <LoganCapaldo> that was just my personal interpretation
14:43:35 <EvilTerran> mattam, given the recursive definition of natural numbers, either 0 is simpler or it doesn't exist
14:43:48 <LoganCapaldo> given the intial example of array
14:43:49 <EvilTerran> and we're compscis, so we count from 0
14:43:50 <mattam> Yeah, that would be my point too
14:43:53 <EvilTerran> .'. it's simpler
14:44:09 <FunctorSalad> "simplest" really depends on what you are doing
14:44:09 <duaneb> hmm
14:44:19 <duaneb> haskell vs ocaml vs perl for line noise winner?
14:44:26 <EvilTerran> altho it's rather more complicated for dividing by :P
14:44:30 <EvilTerran> duaneb, APL!
14:44:32 <FunctorSalad> e.g. if you are looking at p-norms, 2 is much simpler than 1 ;)
14:44:36 <duaneb> yea!
14:44:40 <duaneb> let's program in greek!
14:44:51 <DRMacIver> J at least is surprisingly less line noisy than it seems.
14:44:58 <mattam> The simplest data structure would be void accordingly ?
14:45:02 <ddarius> FunctorSalad: Why?
14:46:02 <FunctorSalad> ddarius: for p=2, the space of functions whose 2-norm is finite is a hilbert space and not just a banach space... hilbert spaces are much simpler
14:46:03 <Sizur> so, where do i look to learn Arrays? http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html tells me a lot
14:46:03 <lambdabot> http://tinyurl.com/2uoebz
14:46:14 <monochrom> Yes.
14:46:31 <monochrom> Err no, you're sarcastic.
14:46:52 <monochrom> I learned from http://haskell.org/onlinereport/array.html
14:47:29 <Mitar> can I use Parsec on ByteString?
14:47:34 <Sizur> monochrom: thank you :)
14:47:44 <SyntaxNinja> @seen shapr
14:47:44 <lambdabot> Last time I saw shapr was when I left #darcs, #ghc and #haskell 20d 17h 1m 22s ago, and .
14:49:28 <monochrom> Perhaps I don't know about simpler, but I know about more fundamental.
14:49:53 <Sizur> theoretically speaking you are right
14:50:08 <monochrom> Cons list corresponds to while loop. Array corresponds to for loop. While loop is more fundamental than for loop.
14:50:41 <monochrom> Certainly, what is simpler at one level of abstraction can be more complex at another.
14:51:19 <augustss> yo
14:51:19 <lambdabot> augustss: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:51:31 <duaneb> wait does haskell tuple = c struct?
14:51:58 <TSC> They're similar
14:52:02 <ddarius> duaneb: That's the most obvious way of implementing them in C, yes.
14:52:05 <augustss> duaneb: kind of
14:52:07 <FunctorSalad> so is tail for haskell lists O(n)?
14:52:23 <augustss> FunctorSalad: yes
14:52:24 <ddarius> Haskell records are closer, but the differences between a record and a tuple are fairly superficial.
14:52:25 <FunctorSalad> err, sorry. I mean last
14:52:40 <augustss> FunctorSalad: that's what i guessed :)
14:52:41 <mux> yes, last is O(n)
14:53:06 <dons> yo augustss. happy 2008.
14:53:19 <augustss> hi dons
14:53:30 <augustss> dons: coming to SF this week?
14:53:40 <FunctorSalad> so I should use this mysterious array for last, or even random access?
14:53:47 <oerjan> Mitar: iirc there was a summer-of-code project to add things like that to Parsec, but i don't recall the result was released
14:53:53 <dons> no, unfortunately. though i was there last week!
14:54:12 <augustss> FunctorSalad: if you really need random access, don't use lists
14:54:27 <oerjan> ask xerox, i think he was involved, possibly in charge
14:54:31 <FunctorSalad> augustss: yeah that's pretty clear :)
14:54:49 <augustss> FunctorSalad: you could use Array, or IntMap
14:54:55 <sjanssen> FunctorSalad: you might try Data.Sequence
14:55:05 <FunctorSalad> ok
14:55:16 <FunctorSalad> don't need it right now, was just asking for when it comes up
14:55:21 <BMeph> Dang, I should've just started reading when I got back - I could've pointed you guys to Melissa O'Neill an hour ago. :|
14:55:53 <monochrom> You should read the complete library doc from cover to cover. :)
14:56:03 <Sizur> 20 times
14:56:11 <ddarius> BMeph: They found her quickly enough anyway.
14:56:21 <ddarius> It wouldn't take that long.
14:56:27 <monochrom> We simply googled melissa sieve.
14:56:36 <monochrom> Sadly we didn't get any porn.
14:56:38 <BMeph> ddarius: Yes, because her paper is the first of Oleg's references.
14:56:41 <FunctorSalad> hmm @src is more or less broken, isn't it?
14:56:51 <ddarius> FunctorSalad: ?
14:56:56 <augustss> @src foldr
14:56:57 <lambdabot> foldr k z xs = go xs
14:56:57 <lambdabot>     where go []     = z
14:56:57 <lambdabot>           go (y:ys) = y `k` go ys
14:57:04 <dons> less broken, i guess.
14:57:14 <FunctorSalad> ddarius: often fails for things I'd think it would know
14:57:44 <dons> it doesn't dynamically look up the library src, yep
14:58:10 <ddarius> FunctorSalad: That's not really broken, just "incomplete" perhaps.
14:58:29 <monochrom> src is incomplete or inconsistent? :)
14:58:32 <FunctorSalad> well I'm not complaining about lambda in general dons, I like her ;)
15:01:42 <duaneb> few things are more fun than calculating primes :)
15:02:06 <FunctorSalad> @vixen do you like calculating primes?
15:02:06 <lambdabot> yah, i like you
15:02:10 <Sizur> like changing nicks? ;)
15:02:48 <Sizur> or making up new paswords
15:04:49 <duaneb> why are raytracers so popular in haskell?
15:05:01 <Sizur> augustss: did you get my email?
15:05:03 <ddarius> duaneb: Raytracers are popular period.
15:05:21 <duaneb> I mean, I wrote one for lisp and c
15:05:29 <sior|sleep> duaneb: do you mean why are they so often written in haskell, or why are there so many raytracers for haskell?
15:05:30 <duaneb> but haskell has more than I've ever seen...
15:05:31 <byorgey> also, I think raytracing lends itself particularly well to the functional paradigm.
15:05:37 <duaneb> the latter
15:05:40 <ddarius> duaneb: I've written three: C++, assembly, and C#
15:05:46 <duaneb> assembly :|
15:05:50 <ddarius> byorgey: Indeed it does, and to parallelism.
15:05:53 <sior|sleep> yeah, bummer dude
15:06:17 <duaneb> I've written an assembly program that boots and displays a smiley
15:06:21 <duaneb> but a raytracer o.0
15:06:43 <ddarius> The assembly one was rather simple; I was going for one in 256 bytes.
15:06:54 <augustss> Sizur: yes, but I've not replied yet :)
15:06:58 <ddarius> (i.e. a 256 byte executable)
15:07:15 <EvilTerran> raytracing would be a good demo for DPH
15:07:53 <Mitar> so how can I parse some things from ByteString?
15:08:11 <augustss> Sizur: you can do whatever you like with printf, but it would be nice if we didn't duplicate code
15:11:15 <Saizan> Mitar: if you want a parser combinator library there's a port of ReadP to bytestrings on hackage, iirc
15:11:46 <FunctorSalad> what is the quickest way of popping up the documentation for some identifier?
15:11:53 <Mitar> i would only need some way of getting PPM image header out of BinaryString
15:12:10 <FunctorSalad> (command line tool or something?)
15:12:18 <SyntaxNinja> dcoutts: around?
15:12:25 <LoganCapaldo> lambdabot :)
15:12:35 <LoganCapaldo> or at least used to be
15:12:48 <FunctorSalad> she doesn't do docs as far as I know
15:13:00 <LoganCapaldo> @docs Data.List
15:13:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:13:17 <FunctorSalad> ok, well the url
15:13:20 <LoganCapaldo> it's a 2 step process admittedly, @index then @docs
15:13:28 <duaneb> ok
15:13:36 <duaneb> this is a fairly stupid question
15:13:42 <duaneb> how can I get data out of tuples?
15:13:42 <SyntaxNinja> @seen dcoutts
15:13:42 <lambdabot> dcoutts is in #haskell, #gentoo-haskell and #ghc. I last heard dcoutts speak 5h 30m 24s ago.
15:13:45 <Saizan> Mitar: then just the functions in Data.ByteString might suffice?
15:13:47 <duaneb> with lists it's
15:13:54 <duaneb> > [1, 2, 3, 4] !! 3
15:13:55 <lambdabot>  4
15:14:12 <LoganCapaldo> duaneb: you can pattern match or use fst and snd on 2-tuples
15:14:23 <duaneb> I use 3-tuples
15:14:26 <duaneb> triplets :)
15:14:35 <EvilTerran> @. docs index listArray
15:14:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:14:43 <augustss> duaneb: pattern matching
15:14:45 <EvilTerran> um
15:14:49 <duaneb> ...
15:14:49 <LoganCapaldo> > let f (a, b, c) = a + b + c in f (1,2,3)
15:14:50 <lambdabot>  6
15:14:52 <duaneb> ahh
15:14:57 <duaneb> that's the only way?
15:15:07 <LoganCapaldo> That's the best way!
15:15:08 <EvilTerran> > let (a,b,c) = (1,2,3) in a+b+c
15:15:08 <lambdabot>  6
15:15:13 <augustss> duaneb: unless you define functions to access the components
15:15:42 <EvilTerran> > let { x = a+b+c where (a,b,c) = (1,2,3) } in x
15:15:43 <lambdabot>  6
15:16:02 <BMeph> I faintly remember someone doing a fst3/snd3/trd3 for triples, but I don't remember where I saw it.
15:16:05 <FunctorSalad> augustss: then you could just use a data though I suppose
15:16:15 <EvilTerran> > case (1,2,3) of (a,b,c) -> a+b+c
15:16:15 <lambdabot>  6
15:16:30 <EvilTerran> etcetc
15:16:31 <augustss> FunctorSalad: indeed
15:16:33 <BMeph> It is just easier to write them with pattern-matching. Kind of like swap... ;)
15:17:14 <LoganCapaldo> @type let (a, b) = (b, a) in (a, b)
15:17:14 <lambdabot> forall t. (t, t)
15:17:52 <nurt> @pl f (a:b) = (b,a)
15:17:52 <lambdabot> f = ap (flip (,) . head) tail
15:18:35 <LoganCapaldo> I wish there was a non-recursive foldr sometimes
15:19:08 <FunctorSalad> non-recursive? so it is faster you mean?
15:19:26 <FunctorSalad> or different behaviour
15:19:29 <Saul_> LoganCapaldo: Isn't the point of foldr to abstract away the recursion?
15:19:50 <Saizan> sometimes you want only head and tail
15:19:54 <nurt> is AP the S combinator?
15:19:58 <nurt> in disguise
15:20:15 <Saizan> nurt: yes, ap in the (->) r monad
15:20:22 <BMeph> nurt: For some Applicatives, it's exactly that.
15:20:41 <sphynx> Saizan: where can I read about (->r) monad?
15:20:47 <BMeph> When return/pure is K.
15:20:59 <FunctorSalad> > foldr (***) id [foldr, foldr, foldr]
15:21:00 <lambdabot>      Occurs check: cannot construct the infinite type: b' = (b, b')
15:21:00 <lambdabot>       Exp...
15:21:16 <sphynx> Saizan: standard documentation of Reader doesn't provide much info
15:21:19 <LoganCapaldo> > let nrf [] f a = a ; nrf (x:xs) f _ = f x xs in nrf [1,2,3] (flip (,)) undefined
15:21:19 <nurt> dude, (->) shouldn't be a monad
15:21:20 <lambdabot>  ([2,3],1)
15:21:24 <nurt> *brain hurts*
15:21:30 <Saizan> sphynx: it's (r ->) however if you use a section
15:21:34 <duaneb> @index sum
15:21:34 <lambdabot> Data.List, Prelude
15:21:42 <Saizan> ?google all about monads
15:21:43 <lambdabot> http://www.haskell.org/all_about_monads/
15:21:43 <lambdabot> Title: All About Monads
15:22:27 <sphynx> yeah, I 've seen it
15:22:45 <duaneb> ?google waffle
15:22:45 <lambdabot> http://en.wikipedia.org/wiki/Waffle
15:22:45 <lambdabot> Title: Waffle - Wikipedia, the free encyclopedia
15:22:55 <duaneb> ?google failure
15:22:56 <lambdabot> http://en.wikipedia.org/wiki/Failure
15:22:56 <lambdabot> Title: Failure - Wikipedia, the free encyclopedia
15:23:01 <duaneb> ?google google
15:23:02 <lambdabot> http://www.google.com/
15:23:02 <lambdabot> Title: Google
15:23:28 <sphynx> but I don't understand yet, why join (*) 2 = 4 :)
15:23:41 <Saizan> well
15:23:44 <sphynx> Ð¾r why liftM2 (,) f g = \x -> (f x, g x)
15:23:44 <Saizan> ?type join
15:23:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:24:00 <FunctorSalad> ?type join (*) 2
15:24:00 <lambdabot> forall a. (Num a) => a
15:24:08 <FunctorSalad> what monad is that?
15:24:09 <Saizan> so join :: r -> (r -> a) -> r -> a
15:24:13 <augustss> > join (*) 5
15:24:14 <lambdabot>  25
15:24:34 <augustss> FunctorSalad: it's the (r->) monad
15:24:36 <Saizan> and there's only one way to do that..
15:24:53 <Saizan> you could go via implementation instead
15:24:59 <Saizan> ?src join (->)
15:24:59 <lambdabot> Source not found. :(
15:24:59 <sphynx> how is return and >>= defined?
15:25:02 <oerjan> :t join.($)
15:25:02 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
15:25:05 <EvilTerran> LoganCapaldo, i tend to call your "nrf" there "list"
15:25:17 <BMeph> ?src (->) join
15:25:17 <lambdabot> Source not found. Wrong!  You cheating scum!
15:25:21 <augustss> @djinn (r->r->a) -> r -> a
15:25:21 <lambdabot> f a b = a b b
15:25:23 <EvilTerran> list f e [] = e; list f e (x:xs) = f x xs
15:25:24 <FunctorSalad> augustss: hmm then how is it supposed to apply (*) to a (r->(r->Int)) :)
15:25:26 <oerjan> BMeph: join is not a method
15:25:32 <Saizan> ?djinn a -> r -> a
15:25:32 <lambdabot> f a _ = a
15:25:39 <EvilTerran> as a parallel to the functions "maybe" and "either"
15:25:40 <oerjan> @src join
15:25:40 <lambdabot> join x =  x >>= id
15:25:45 <augustss> FunctorSalad: by instantiating r with Int
15:26:03 <BMeph> oerjan: Just a "feature" then? ;)
15:26:07 <Saizan> ?djinn (r -> a) -> (a ->  r -> b) -> r -> b -- >>=
15:26:07 <lambdabot> Cannot parse command
15:26:11 <Saizan> ?djinn (r -> a) -> (a ->  r -> b) -> r -> b
15:26:11 <lambdabot> f a b c = b (a c) c
15:26:31 <Saizan> sphynx: seen? :)
15:26:46 <byorgey> sphynx: and return = const
15:26:47 <sphynx> Saizan: hm ^)
15:27:01 <augustss> It's a magic monad
15:27:15 <FunctorSalad> nvm, (*) is the thing that is being considered a monadic value and joined, not 2
15:27:16 <sphynx> return for Reader is const
15:27:16 <sphynx> >>= for reader is smth I've seen ) OR must have seen )
15:27:52 <sphynx> f a b c = b (a c) c -- this is the main thing?
15:27:59 <sphynx> in describing of how it works?
15:28:03 <augustss> it's bind
15:28:17 <sphynx> ok
15:28:20 <byorgey> sphynx: f there is >>=
15:28:25 <oerjan> BMeph: in category theory join is considered more fundamental than >>=, but in practical haskell >>= is more useful
15:28:47 <sphynx> (>>=) a b c = b (a c ) c -- correct?
15:28:54 <byorgey> x >>= k = join (fmap k x)
15:28:54 <BMeph> oerjan: That's true. THank you for re-explaining that.
15:29:42 <duaneb> what is this called: '->'?
15:29:46 <byorgey> sphynx: right.
15:29:50 <augustss> The monad laws are really messy when using >>=
15:30:37 <byorgey> duaneb: 'function arrow' perhaps?
15:30:50 <byorgey> duaneb: I'm not sure whether it has an official name.
15:31:21 <byorgey> duaneb: a -> b is the type of a function which takes a value of type a and returns a value of type b.
15:31:26 <BMeph> duaneb, byorgey: Function type, maybe?
15:31:34 <ddarius> @src join
15:31:35 <lambdabot> join x =  x >>= id
15:31:35 <ddarius> EvilTerran: Arguably the "proper" parallel is foldr.
15:31:40 <byorgey> BMeph: function type constructor, perhaps
15:31:56 <BMeph> byorgey: I like it... ;)
15:31:57 <byorgey> BMeph: since '->' isn't actually a 'type' in and of itself
15:32:01 <sphynx> (a >>= b) c = b (a c) c
15:32:02 <sphynx> so, join (*) 2 = ((*) >>= id) 2 = id ((*) 2) 2 = (*) 2 2 = 4
15:32:07 <sphynx> hm, works )
15:32:10 <EvilTerran> ddarius, well, they're different parallels
15:33:02 <oerjan> @free (a1 -> a1 -> a) -> a1 -> a
15:33:02 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:33:04 <Mitar> how can I make a monad from this type:
15:33:04 <Mitar> type Parser a = B.ByteString -> (a, B.ByteString)
15:33:14 <byorgey> sphynx: you can also think of join more directly:  join :: m (m a) -> m a, so for (r->) that's :: (r -> r -> a) -> r -> a
15:33:15 <oerjan> @free f :: (a1 -> a1 -> a) -> a1 -> a
15:33:16 <lambdabot> (forall x. h . k x = p (g x) . g) => h . f k = f p . g
15:33:37 <byorgey> sphynx: so join k r = k r r
15:33:39 <sphynx> byorgey: Ueah, oerjan has shown me that approach
15:33:53 <oerjan> Mitar: State B.ByteString a
15:33:54 <EvilTerran> sure, maybe/either/foldr are the catamorphisms, but maybe/either/list all case-analyse on a single level of constructor, which is also useful
15:34:28 <Mitar> instance Monad Parser where
15:34:31 <Mitar> this does not work
15:34:56 <FunctorSalad> instance Monad Parser a where
15:35:18 <byorgey> FunctorSalad: no, the a should not be included
15:35:22 <sphynx> So, monadic values in (r->) are functions. Joining of these values gives application of these function twice to the same argument
15:35:29 <oerjan> Mitar: it's a type synonym, you need a newtype to be able to give a new instance
15:35:32 <byorgey> FunctorSalad: instances of Monad must have kind (* -> *)
15:35:34 <sphynx> and combining results with another functon
15:35:48 <Mitar> newtype Parser a = Parser (B.ByteString -> (a, B.ByteString))
15:35:49 <FunctorSalad> byorgey: yes, that's actually why I wanted the a there
15:36:07 <FunctorSalad> oh wait, nvm
15:36:12 <byorgey> Mitar: with a newtype it should work
15:36:15 <oerjan> Mitar: also as i mentioned, Parser = State there
15:36:31 <Mitar> why State?
15:36:37 <oerjan> @src State
15:36:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:36:38 <byorgey> Mitar: I think the problem is that instances are not allowed for type synonyms without an extension
15:36:49 <oerjan> damn you @src!
15:37:03 <FunctorSalad> I thought something like "instance Monad [a mapsto Parser a]" :)
15:37:20 <Mitar> i am trying to make a simple parser combinator on ByteString ...
15:37:29 <oerjan> Mitar: because the B.ByteString is threaded through the computations as a simulated state
15:37:31 <byorgey> Mitar: State s a = s -> (a,s)
15:37:43 <byorgey> just like you have with ByteString there
15:37:45 <oerjan> er, i meant Parser = State B.ByteString
15:38:07 <ddarius> EvilTerran: Agreed, but there are two distinct (and in some sense canonical) ways you can identify foldr and either.  One view is as the morphism induced by initiality, the other is corresponding parts of the adjunctions in defining Either and the free monoid.
15:38:17 <Mitar> and then i get monad for free?
15:38:25 <EvilTerran> *wibble*
15:38:51 <EvilTerran> does one of those correspond to the catamorphism and the other to my doodad?
15:39:13 <byorgey> Mitar: yup!
15:39:42 <byorgey> there's a standard instance Monad (State s) in Control.Monad.State
15:39:57 <oerjan> EvilTerran: foldr is the catamorphism
15:40:44 <oerjan> um i guess that's not what you were asking
15:41:09 <EvilTerran> indeed not
15:41:29 * oerjan leaves the heavy CT stuff to ddarius 
15:41:45 <Saizan> well if with both you can identify foldr then neither is doodad
15:42:21 <EvilTerran> hmm
15:42:58 <Mitar> ok, so I have type Parser a = State B.ByteString a
15:43:43 <Mitar> how can I define "parse" function, which would give me from parse :: Parser a -> B.ByteString -> a
15:44:23 <ddarius> EvilTerran: No.  They both roughly correspond to a catamorphism.
15:44:27 <ddarius> EvilTerran: Your "doodad" does correspond to the signature map in the initial algebra approach.
15:44:33 <oerjan> Mitar: that's evalState
15:44:46 <EvilTerran> okay
15:44:55 <byorgey> @type evalState
15:44:55 <lambdabot> forall s a. State s a -> s -> a
15:45:06 <ddarius> Saizan: That was my point.=
15:45:20 <FunctorSalad> sorry, dunno what a catamorphism is, but another view is: let M be some monoid and A a set, then Mor(FreeMonoid(A),M) ~= Mor(A, UnderlyingSet(M)). fold is sort-of the natural iso from right to left (you actually define the monoid M with the argument to fold)
15:45:33 <Mitar> if I import Control.Monad.State I get a lazy version?
15:45:44 <ddarius> FunctorSalad: That's the adjunction case I mentioned.
15:45:51 <oerjan> Mitar: yep i think so
15:46:04 <byorgey> Mitar: yes.  there's a strict version too if you want it.
15:46:08 <Mitar> thanks ..
15:46:10 <Mitar> no need ..
15:46:13 <FunctorSalad> ddarius: I didn't see where Either comes into play
15:46:14 <Mitar> (I hope)
15:46:48 <sphynx> p1r4nh4: hi
15:46:49 <ddarius> FunctorSalad: The fold is the counit of that adjunction.  In the adjunction defining Either, either is it's counit.
15:46:51 <Saizan> one could start asking what's Mor
15:46:56 <p1r4nh4> sphynx: hi :-)
15:47:15 <FunctorSalad> ddarius: ahh, that's what you mean't by "identify" them. see the pattern, not make them equal ;)
15:47:20 <FunctorSalad> *meant
15:48:17 <p1r4nh4> Hello, guys. What do you think about using Haskell program from a Python one? I'm very impressed by Parsecl, though my language of choice and implementation is currently Python, so maybe I have any chances to use Parsec parser from my program without using pipe? :-)
15:48:20 <ddarius> Er, not the counit but the (appropriate) "adjunct" or adjoint transpose.
15:48:40 <p1r4nh4> I'm creating website, so using a pipe would be very slow thing :-)
15:48:42 <ddarius> p1r4nh4: How easy is it to call C from python?
15:48:47 <p1r4nh4> hmmm
15:48:53 <p1r4nh4> It is possible
15:49:01 <Valodim> then that would be your best shot
15:49:03 <FunctorSalad> ddarius: depends on whether you consider [] as constructing free monoids or underlying sets of free monoids, I suppose
15:49:09 <p1r4nh4> I'm not so confident with that, but I know that there are approaches to do this
15:49:18 <Botje> p1r4nh4: parsec has been ported to java and ruby already. perhaps there exists a python port?
15:49:25 <p1r4nh4> nope :-(
15:49:34 <EvilTerran> there are probably better alternatives within python than trying to use haskell and python at once
15:49:39 <p1r4nh4> I seeked for one and saw ports to ruby and python
15:49:40 <p1r4nh4> hehe
15:49:46 <ddarius> You could reimplement it in python pretty easily.
15:49:50 <p1r4nh4> maybe, but I'm really impressed with Parsec :-)
15:49:55 <p1r4nh4> hm? It's easy? :-)
15:49:55 <oerjan> p1r4nh4: i definitely have seen a parser library for python
15:49:58 <ddarius> It's not a very big library.
15:50:01 <FunctorSalad> ddarius: I think I meant the same thing with "natural iso from right to left" as you mean with "adjoint transpose"?
15:50:04 <oerjan> don't recall the name though
15:50:05 <Valodim> http://lukeplant.me.uk/blog.php?id=1107301645
15:50:05 <p1r4nh4> oerjan: there are a lot of libraries
15:50:06 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
15:50:07 <Valodim> ahahaha
15:50:08 <p1r4nh4> :-)
15:50:19 <ddarius> FunctorSalad: Yes.
15:50:22 <p1r4nh4> oerjan: ply, pyparsing, zestyparser and at least 10 names :-)
15:50:27 <Valodim> gotta love how his first point on why it makes you a worse programmer is "demotivation" because you miss the more powerful features :)
15:50:32 <ddarius> p1r4nh4: You just identify lazy lists with generators and then for the most part mindlessly translate the code.
15:50:33 <oerjan> a combinator-based one
15:50:41 <p1r4nh4> pyparsing?
15:51:09 <Botje> google suggests pyparse is a parser combinator lib
15:51:20 <p1r4nh4> it is slighty similar to Parsec, but have something worse syntax and smaller number of features
15:51:27 <p1r4nh4> not pyparse, but pyparsing
15:51:30 <p1r4nh4> different things :-)
15:51:36 <Botje> oh :P
15:52:04 <p1r4nh4> ddarius: hmm... maybe I would like to do that. I really need to see :-)
15:53:30 <p1r4nh4> Thanks, guys, for your answers :-
15:53:32 <p1r4nh4> :-)
15:54:02 <sclv> EvilTerran: curious what benefit you see from defining list the way you do? i.e. decomposing the function to f x xs instead of just f (x:xs) ?
15:54:02 <hpaste>  gwern pasted "bytestring type problem" at http://hpaste.org/4838
15:54:15 <p1r4nh4> ddarius: though I guess your question about C appeared not just from clean interest and it is possible to call Haskell program from C, right? :-)
15:54:18 <Botje> p1r4nh4: please donate a lambda to the hungry functional programmers fund!
15:54:27 <p1r4nh4> :D
15:54:31 <Valodim> http://wiki.python.org/moin/PythonVsHaskell
15:54:31 <Valodim> going from haskell to python looks rather straightforward
15:54:32 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
15:54:42 <gwern> I have what's probably a simple problem here. it says string isn't good when word8 is needed, but I thought strings were word8s!
15:55:16 <monochrom> strings are chars.
15:55:33 <Valodim> (ie, [char])
15:55:38 <p1r4nh4> Valodim: huh, thanks for link
15:55:44 <Botje> :t getArgs
15:55:44 <lambdabot> Not in scope: `getArgs'
15:55:51 <p1r4nh4> I've seen it earlier but forgot eventually :\
15:56:00 <ddarius> p1r4nh4: Haskell has a good FFI allowing it to talk to C and vice versa (among, theoretically other languages).  You can talk to Haskell by exposing the functions with a C interface and using python's ability to talk to C code.  No (or very close to no) actual C code needs to be involved (unless python's C FFI sucks...)
15:56:04 <monochrom> A simple information-theoretic argument shows that a char cannot be a word8.
15:56:04 <thetallguy> ?users
15:56:05 <lambdabot> Maximum users seen in #haskell: 439, currently: 423 (96.4%), active: 25 (5.9%)
15:56:10 <allbery_b> doesn't it need to be mapped over the list of strings?
15:56:12 <Botje> gwern: getArgs is of type IO [String]
15:56:12 <sclv> the best way to integrate python and haskell is probably to write a python compiler in Haskell, ho?
15:56:25 <ddarius> monochrom: Doesn't simply counting work...?
15:56:35 <Botje> so you want liftM (B.pack . head)  getArgs
15:56:40 <sclv> s/ho/no/
15:56:40 <p1r4nh4> sclv: :DD or reverse
15:56:42 <monochrom> Yes, that information-theoretic argument is simple counting. :)
15:57:14 <gwern> Botje: hm. head because presumably I only want the first argument?
15:57:17 <sclv> p1r4nh4: well, the former is easier. you could use parsec to do the parsing for one.
15:57:19 <p1r4nh4> ddarius: I'm not sure does it suck or not... will go look at parsec and at python/C interface
15:57:24 <Botje> gwern: yes? :)
15:57:24 <p1r4nh4> sclv: :-))))
15:57:43 <p1r4nh4> btw... how can you characterize speed of parsec?
15:58:13 <sclv> pretty decent, as I understand it, but subject to time/space leaks in poorly factored grammars?
15:58:14 <ddarius> p1r4nh4: Fast enough.
15:58:15 <gwern> Botje: hm. doesn't compile either
15:58:24 <sclv> @go uuag parser
15:58:25 <lambdabot> http://www.cs.uu.nl/wiki/HUT/WebHome
15:58:30 <p1r4nh4> nice, thanks
15:59:06 <ddarius> Well, you can, as always, write good and bad code.  There is also a new version that needs to be finished up that should lead to it being a lot faster.
15:59:16 <sclv> ^^ another haskell lib, fancier as I understand it. also there's readP which works in parallel.
15:59:30 <gwern> that's the bytestring version of parsec, no?
16:00:22 <sphynx> BTW, parsec moving to ByteStrings was someone's SummerOfCode project, or I am wrong?
16:01:05 <hpaste>  gwern annotated "bytestring type problem" with "update error - GHC.Word.Word8 != Char" at http://hpaste.org/4838#a1
16:02:11 <Botje> argh
16:02:20 <Botje> B.pack wants Word8 instead of Char :/
16:02:20 <monochrom> What is the type of B.pack again?
16:02:29 <Botje> pack :: [GHC.Word.Word8] -> ByteString
16:02:43 <sphynx> Data.ByteString.Char8
16:03:02 <sphynx> you can import this instead of importing simpy DAta.ByteString
16:03:15 <monochrom> Yeah, use Data.ByteString.Char8 instead.
16:03:32 <gwern> hm. importing lazy one from my other program fixs that
16:03:36 <monochrom> Why is type-driven programming so hard on most people? I'm seriously asking.
16:03:40 <gwern> oh. what sphynx said
16:04:03 <Botje> monochrom: in this case, because I want GHC to convert Char to Word8 for me ;)
16:04:18 <gwern> monochrom: too much looseness and punning and other stuff in non-type-driven programming?
16:04:32 <ddarius> monochrom: It's only hard on people who don't understand the type system.
16:04:40 <r3m0t> monochrom: the numbers bother me
16:05:33 <gwern> haskell is hard! let's go shopping
16:05:40 <monochrom> haha
16:05:50 <Botje> i agree!
16:05:59 <jsnx> monochrom: i think it's because it firmly rejects "do what i mean"
16:06:00 <p1r4nh4> only language is harder is python :P
16:06:01 <Botje> except it's 1 o clock so no shops open
16:06:06 <Saizan> bring me a pony!
16:06:37 <monochrom> Shop online, we can.
16:07:29 <gwern> judge me by my wallet size, do you?
16:07:35 <monochrom> Haskell is hard! Le'ts go shopping http://www.amazon.com/s/ref=nb_ss_gw/102-7312214-8052936?url=search-alias%3Daps&field-keywords=haskell+programming&x=17&y=20
16:07:36 <lambdabot> Title: Amazon.com: haskell programming, http://tinyurl.com/2lo44c
16:08:10 <BMeph> p1r4nh4: Python is super-easy! Although it helps to buy Guido lots of beer... ;)
16:08:11 <jsnx> :t getPony :: IO Pony
16:08:11 <lambdabot> Not in scope: `getPony'
16:08:12 <lambdabot> Not in scope: type constructor or class `Pony'
16:08:13 <monochrom> Oh, shopping online only measures your credit card credit limit, not your wallet size. :)
16:08:31 <p1r4nh4> BMeph: :-))
16:08:53 <jsnx> what kind of data structure is a "database table"?
16:09:04 <monochrom> an abstract kind. :)
16:09:08 <jsnx> it's big list of tuples -- with look up on any element in the tuples
16:09:27 <monochrom> I'm serious! A good database implements a table in a very clever, optimized way.
16:09:44 <gwern> oh neat. with my borders gift cards, I can finally go and buy a haskell textbook
16:09:46 <jsnx> yes
16:09:50 <monochrom> Likely split over many files, and in each file there are lots of tricks applied.
16:09:50 * gwern wonders which one to buy
16:10:01 <jsnx> monochrom: but there should be some name for this thing
16:10:05 <r3m0t> gwern: buy mine
16:10:14 <r3m0t> oh wait, I don't have one
16:10:21 <jsnx> a map is what we get when we can look up two tuples by the first key
16:10:22 <r3m0t> buy one for me
16:10:22 <LoganCapaldo> theres not just one thing
16:10:27 <ddarius> gwern: If I were to buy one, it'd probably be Bird's.  It's the only one that sounds interesting to me.
16:10:40 <r3m0t> you mean "an introduction"?
16:10:49 <ddarius> I think so.
16:11:03 <sclv> jsnx: "indexed filesystem" ?
16:11:04 <BMeph> Isn't dons writing one, though?
16:11:05 <gwern> ddarius: I think you already understand this stuff? so I should probably stay away from ones that 'sound interesting'
16:11:28 <r3m0t> the introduction is just that... introductory
16:11:31 <gwern> richard bird sounds familiar though
16:11:41 <sclv> bird tracks!
16:11:44 <monochrom> Still staying at the abstract level, I guess "list of tuples", "collection of tuples", "relation" all work.
16:11:51 <gwern> BMeph: yeah, but I think you can sign up to readf the drafts, and it's not out yet
16:12:07 <ddarius> BMeph: dons, bos, and CosmicRay
16:12:10 <ddarius> @where realworldhaskell
16:12:10 <lambdabot> http://www.realworldhaskell.org/
16:12:13 <jsnx> sclv: well, that's a higher level data structure -- tables + tree
16:12:22 <monochrom> "indexed filesystem" is vague enough to cover all implementation techniques.
16:12:44 <gwern> ddarius: I've read through most of Thompson's 'Craft of' - how does Bird's compare, do you know?
16:12:47 <BMeph> gwern: There ya go - buy an advance on it, and comment on the drafts, to make sure you get your money's worth! ;)
16:12:54 <sclv> jsnx: a fancy database will probably use all that and more.
16:13:10 <gwern> wait, so I should *pay* for it, and then work on it for them for free?
16:13:24 * gwern donates enough time on wikipedia already >.<
16:14:03 <gwern> actually, their last update is from - October? I hope they've been working on it since...
16:14:18 <r3m0t> Bird's notation annoys me
16:14:32 <r3m0t> the book doesn't at all explain how to type anything in
16:14:52 <r3m0t> e.g. "=>", "->", guard expressions...
16:14:57 <ddarius> gwern: I don't know; I haven't read it.
16:15:12 <jsnx> sclv: well, a database rarely allows you to actually walk the tree
16:15:23 <jsnx> sclv: so at the interface, it's missing the filesystem part
16:16:21 <monochrom> jsnx: Still staying at the abstract level, I guess "list of tuples", "collection of tuples", "relation" all work.
16:16:29 <jsnx> but, focusing on operations -- we've got  `lookup :: Column -> Value -> [Records] -> [Records]`
16:16:44 <jsnx> monochrom: well, we haven't defined any operations yet :)
16:17:29 <Mitar> what is the function that takes two monadic actions and if first fails it executes the second one
16:17:30 <Mitar> ?
16:17:43 <jsnx> or rather `lookup :: (Column c, Table t, Value v) => c -> v -> t -> t`
16:17:49 <jsnx> something like that
16:17:50 <monochrom> You need MonadPlus.  mplus
16:17:54 <Mitar> either?
16:18:05 <Mitar> hm, no
16:18:14 <Mitar> and State ins MonadPlus?
16:18:48 <monochrom> Yes. You need MonadPlus. mplus. Monad alone doesn't even allow you to detect failure. You can cause failure but you can't observe it and override it.
16:19:45 <oerjan> Mitar: you may want to change your monad to StateT B.ByteString (Either String) or similar
16:19:46 <Mitar> and how can I combine actions then with MonadPlus? so that if first action succedes it returns that value, otherwise it tries the second one
16:20:00 <monochrom> mplus.
16:20:06 <Mitar> ok
16:20:07 <Mitar> :-)
16:20:10 <oerjan> that gives you MonadPlus, and a way to give error messages
16:20:50 <oerjan> add Control.Monad.Error to imports
16:21:18 <Mitar> I just want to die if there is an error :-)
16:21:32 <oerjan> hm...
16:21:53 <monochrom> ???
16:22:01 <Mitar> what does fail "parsing error" do?
16:22:10 <oerjan> depends on the monad
16:22:36 <oerjan> but with Either String it gives you Left "parsing error"
16:22:49 <monochrom> I thought you said you wanted to try an alternative, implying you don't want to die on error.
16:23:12 <mauke> he may be referring to the Perl die
16:23:31 <monochrom> Well, then, Perl should die die die.
16:23:41 <Mitar> :-)))
16:23:57 <oerjan> well for straightout dying you could use StateT ... IO
16:24:00 <Mitar> hmm, yes, if I use fail without Either then I cannot catch fail?
16:24:06 <oerjan> but that feels a bit impure
16:24:23 <oerjan> Mitar: you can catch errors in IO
16:24:32 <Mitar> no, I am not working in IO anymore
16:24:46 <Mitar> (I am on a pure level now)
16:24:57 <mauke> you can catch Nothing :-)
16:25:05 <Mitar> so if I in State monad fail ...
16:25:16 <mauke> it'll call error
16:25:17 <Mitar> then what evalState do?
16:25:29 <oerjan> you can use Maybe instead of Either String if you don't care about error messages
16:25:41 <wy> Has anyone experience with smalltalk or simula 67 here?
16:25:59 <oerjan> error is an exception.  it throws out to the surrounding IO code
16:26:09 <oerjan> if that doesn't catch it, the program exits.
16:26:42 <oerjan> since evalState is pure, it doesn't get any say in the matter
16:27:51 <Mitar> type Parser a = StateT B.ByteString Maybe a
16:28:04 <Mitar> like so?
16:28:08 <oerjan> yep
16:28:43 <oerjan> then evalStateT will return Just result, or Nothing if the whole parser fails
16:29:02 <Mitar> thanks ..
16:29:12 <Mitar> really ... you help a lot :-)
16:29:19 <Mitar> i will have one simple parser soon :-)
16:29:56 <Mitar> one more thing ... why do I need to specify an error string to fail if that is not used anywhere now?
16:30:10 <mauke> because "fail" is rather inflexible
16:30:11 <Mitar> (because Maybe catches and returns Nothing)
16:30:21 <Mitar> can I use anything else?
16:30:32 <oerjan> mzero
16:30:44 <Mitar> aha
16:37:38 <Mitar> how can I convert Word8 to Char?
16:37:54 <r3m0t> doesn't lambdabot find stuff by type?
16:38:05 <davidL> :t chr
16:38:07 <lambdabot> Int -> Char
16:38:22 <mauke> toEnum . fromEnum :-)
16:38:22 <ricky_clarkson> @hoogle Bool -> Bool -> Bool
16:38:23 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
16:38:23 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
16:38:23 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
16:38:37 <oerjan> @hoogle w2c
16:38:38 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
16:38:43 <Mitar> not in scope?
16:38:49 <ricky_clarkson> @check Prelude.(&&)==Data.Bool.(&&)
16:38:49 <lambdabot>   Not in scope: data constructor `Data.Bool'
16:39:34 <oerjan> @check Prelude.(&&)==(Data.Bool.&&)
16:39:34 <lambdabot>   Not in scope: data constructor `Prelude'
16:39:43 <oerjan> @check (Prelude.&&)==(Data.Bool.&&)
16:39:44 <lambdabot>        add an instance declaration for (Eq (Bool -> Bool -> Bool))     In the...
16:39:56 <Mitar> @hoogle Word8 -> Char
16:39:57 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
16:40:13 <Mitar> should I use something like this?
16:40:15 <Mitar> internal?
16:40:17 <mauke> @scheck \x y -> (x Prelude.&& y) == (x Data.Bool.&& y)
16:40:18 <lambdabot>   Completed 4 test(s) without failure.
16:40:23 <tcleval> @help
16:40:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:40:31 <mauke> Mitar: probably not
16:40:34 <tcleval> @list
16:40:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:40:39 <oerjan> it may not actually be intended to be used
16:40:39 <davidL> Is it possible to remove a plugin/module from lambdabot while it's running?
16:40:54 <oerjan> @index w2c
16:40:54 <lambdabot> bzzt
16:40:57 <oerjan> bah
16:41:01 <wy> Is Philip Wadler still doing Haskell? I see most of his recent work is with Java...
16:41:29 <ricky_clarkson> @check \x y -> x && y==x && y
16:41:30 <lambdabot>  Falsifiable, after 0 tests: True, False
16:41:35 <ricky_clarkson> heh
16:41:53 <ricky_clarkson> wy: Wasn't that a number of years ago, when he helped add generics to Java?
16:42:08 <davidL> @type chr $ fromIntegral (67 :: Word8)
16:42:09 <lambdabot> Char
16:42:21 <ddarius> wy: Currently he is working on a language called Link.
16:42:27 <wy> ricky_clarkson: I just found that on his homepage
16:42:42 <Saul_> wy: I saw a presentation of his a few months ago, he was just done working on something for Java and was using O'Caml. He made a remark about wanting to use Haskell later on
16:42:47 <mauke> > (toEnum . fromEnum) (64 :: Word8) :: Char
16:42:48 <lambdabot>  '@'
16:42:54 <ddarius> wy: That said, Wadler has never left the Haskell community.  He just does other stuff as well, e.g. Java generics and XML stuff.
16:43:41 <ricky_clarkson> He's always teaching Haskell in Edinburgh, isn't he?
16:43:59 <dons> yep
16:44:33 <Saul_> ddarius: Yeah Links is in O'Caml. It's supposed to be a single language for web development, so you don't have to do HTML, CSS, Javascript, server side scripting and SQL for a single website
16:44:59 <Mitar> I get a Char and a Word8 and I would like to know if they are equal ...
16:45:37 <Lemmih> Mitar: Why do you have a Word8?
16:45:47 <Mitar> ByteString
16:45:56 <ricky_clarkson> Saul_: Hop is a similar thing but in Scheme.
16:45:57 <Lemmih> Mitar: Import Data.ByteString.Char8
16:46:10 <ricky_clarkson> I like the idea.  Does Links work well?
16:46:15 <Saul_> ricky_clarkson: Ok, I hadn't heard of that one
16:46:25 <Mitar> but I will read it binary otherwise
16:46:40 <ricky_clarkson> @go hop programming language
16:46:41 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
16:46:45 <ricky_clarkson> meh
16:46:51 <Saul_> ricky_clarkson: I don't know, I never used it. I'm not sure how mature it is yet
16:46:54 <ddarius> ricky_clarkson: Links is still in the design stage.
16:47:19 <BMeph> Mitar: Then import them both... ;)
16:47:23 <Saul_> http://groups.inf.ed.ac.uk/links/
16:47:24 <lambdabot> Title: Links
16:47:30 <oerjan> :t Data.ByteString.w2c
16:47:30 <lambdabot> Not in scope: `Data.ByteString.w2c'
16:47:31 <Saul_> version 0.4 apparently
16:47:38 <Mitar> it is internal
16:47:54 <oerjan> :t Data.ByteString.lines
16:47:55 <lambdabot> Not in scope: `Data.ByteString.lines'
16:48:04 <oerjan> :t Data.ByteString.ByteString
16:48:05 <gwern> uh oh. hm.
16:48:05 <lambdabot>     Not in scope: data constructor `Data.ByteString.ByteString'
16:48:20 <gwern> I take it setCurrentDirectory only affects the program itself and not the shell it's running in?
16:48:23 <oerjan> i was thinking maybe it was exported further...
16:48:48 <oerjan> gwern: sure, i don't think it is possible to affect the shell
16:49:04 <Saul_> I have an exam on complexity theory but I can't seem to concentrate
16:49:11 <newsham> after you fork and exec, the current working dir of the child is independant of the shell
16:49:11 <gwern> that would explain why my program appeared to be doing nothing, yes
16:49:36 <newsham> unless you have some sorta crazy rfork going on
16:49:39 <Saul_> and it's pretty late now and I'm tired, but I'm also hopped up on caffeine so I won't sleep for the next 4 hours
16:49:48 <Lemmih> Mitar: .Char8 is semantically identical to Data.ByteString. It just has a different interface.
16:50:04 <wy> Saul_: That's really a lot of work to bring those stuff together
16:50:26 <Saul_> wy: I reckon so
16:50:31 <monochrom> Yeah, is there any evidence that Data.ByteString.Char8 contradicts the goal of reading raw octets from files?
16:50:43 <Mitar> yes, so how can I convert between types?
16:50:54 <newsham> which types?
16:51:12 <newsham> toEnum.fromEnum?
16:51:39 <monochrom> If you stick to Data.ByteString.Char8 and just completely forget about Data.ByteString, you will never see Word8 anywhere, no?
16:52:05 <gwern> works for me
16:52:26 <Mitar> true
16:53:29 <dons> what's the bytestring issue?
16:54:07 <monochrom> Word8 and Char had a good fight.
16:54:23 <dons> ah ok
16:54:55 <newsham> Char won because all of IO reads Word8 and converts to Char?
16:55:09 <jorik808> in a peer-to-peer protocol (all clients run the same codebase), how can the group of peers agree on a leader ?
16:55:18 <wy> Is there some analysis of the HM type system? I wonder if it's potential is fully used
16:55:21 <dons> have an election, jorik808.
16:55:25 <newsham> ?go election protocol
16:55:26 <lambdabot> http://www.cs.cornell.edu/projects/quicksilver/public_pdfs/Probabilistically%20Correct.pdf
16:55:46 <dons> wy, hmm, about a dozen conferences :)
16:55:47 <ddarius> jorik808: There is quite a bit of research on such things.
16:55:56 <jorik808> hmm
16:56:21 <wy> dons: What are those?
16:56:22 <Saul_> There's a FP-day in Utrecht this Friday, is anyone here going?
16:56:27 <jorik808> i'm looking for a quick n dirty solution really
16:56:33 <monochrom> I took a course on that. Actually two courses. :)  "distributed algorithms".
16:56:38 <newsham> jori: lowest IP address?
16:57:02 <jorik808> haha, that's it !!!
16:57:06 <jorik808> thanks newsham
16:57:36 <gwern> (but then couldn't you spoof 0.0.0.0 and bollix things up?)
16:57:46 <newsham> you had me at "quick'n'dirty"
16:57:55 <glguy> 0.0.0.0 is a broadcast address though, no endpoint has it
16:58:00 <newsham> gwern: if you're in a position to spoof IP addresses
16:58:01 <jorik808> hehe
16:58:06 <jorik808> all clients are trusted
16:58:14 <jorik808> so i don't need to worry about spoofing
16:58:23 <glguy> systems like SAMBA have protocols for determining who should lead
16:58:35 <monochrom> Yes, clients trusted and clients untrusted lead to very different algorithms and very different guarantees.
16:58:52 <newsham> glguy: depends on if you think host all-zeros is broadcast, net all-ones is broadcast, or both.
16:59:10 <newsham> isnt all-zeros a BSD faux pas?
17:01:37 <allbery_b> well, an ancient faux pas
17:04:02 <Saul_> Stupid question probably: You can show that a problem is NP-complete if you can reduce a known NP-complete problem into it (in polynomial time), right?
17:04:38 <glguy> rfc1700 says: 0.0.0.0/0 is "this host on this network" and x.x.x.x/0 is "specified host on "this" network (as a source address)
17:04:47 <FunctorSalad> s/NP-complete/NP-hard, then yes I think Saul_
17:05:06 <glguy> so I suppose I was wrong :)
17:05:20 <byorgey> Saul_: that, and also showing that it is in NP.
17:05:21 <Saul_> FunctorSalad: It actually does say NP-complete
17:05:26 <FunctorSalad> Saul_: the way you said it, we wouldn't know that the prob is in NP
17:05:33 <FunctorSalad> (the first prob)
17:05:53 <Saul_> So I should reduce both ways?
17:06:10 <newsham> glguy: ahh, forgot about the dhcp stuff
17:06:20 <FunctorSalad> Saul_: you can usually show belongance to NP directly (e.g. guess and check algorithm)
17:06:24 <gwern> bleh. so I have 'filter (B.isInfixOf dir) dirs' where dir :: IO B.ByteString & dirs :: IO [B.ByteString]. I tried turning it into a lambda and 'return'ing the passed entry from dirs (which would be a m B.ByteString, I think) but that didn't work
17:06:45 <sarehu> "belongance"
17:07:05 <FunctorSalad> for example, for SAT you simply nondeterministically consider every assignment of variables and check whether it satisfies the formula
17:07:07 <gwern> are you not allowed to go (dir :: IO  B.ByteString) `isInfixOf` (x :: m B.ByteString)?
17:07:08 <FunctorSalad> sarehu: :)
17:07:22 <Saul_> FunctorSalad: But I can make a guess and check algorithm for any polynomial algorithm as well
17:07:24 <gwern> sarehu: a very cromulent word
17:07:48 <sarehu> Saul_: P is a subset of NP
17:08:05 <glguy> gwern: you'd need to lift isInfixOf into IO
17:08:17 <Saul_> sarehu: *feels stupid now*
17:08:33 <wy> I just found that there is a book named "How To Design Classes"
17:08:51 <jorik808> is it any good?
17:08:59 <FunctorSalad> gwern: yes, I must not allow my vocabulary to become ensmallened
17:09:08 <Saizan> liftM2 isInfixOf ~~ \x y -> do x' <- x; y' <- y; return $ isInfixOf x y
17:09:25 <gwern> FunctorSalad: instead. embiggen it! and always twirling, twirling upwards to infinity and beyond!
17:09:46 <FunctorSalad> :)
17:09:55 <wy> I don't know, but it's from the same authors as How To Design Programs
17:10:17 <newsham> put a right arrow over isinfixof
17:10:42 <jorik808> i never read that. i started with sicp and when i got to htdp i was tired of scheme :)
17:11:05 <ddarius> HtDP is more of a prequel to SICP content-wise.
17:11:10 <gwern> Saizan: what is that, and what syntax is '~~'? never seen that before
17:11:29 <glguy> it is IRC syntax for
17:11:38 <glguy> expands to
17:11:48 <Saul_> Ok to recap: If I know a problem is in NP, then I can show that it is NP-complete if I reduce a known NP-complete problem into it in polynomial time (since by extension I can reduce any NP problem into it in polynomial time)
17:12:10 <gwern> oh. I thought we used ~> for expansion
17:12:30 <wy> jorik808: How do you like HTDP? I read sicp and I really like it
17:12:41 <byorgey> Saul_: right.
17:12:50 <FunctorSalad> yeah, sounds right
17:13:06 <oerjan> gwern: liftM2 (filter . isInfixOf), i think
17:13:31 <wy> I guess the essence of object-oriented programming is largely lost and misunderstood
17:13:33 <oerjan> :t liftM2 (filter . isInfixOf)
17:13:33 <lambdabot> forall a (m :: * -> *). (Eq a, Monad m) => m [a] -> m [[a]] -> m [[a]]
17:13:47 <oerjan> (although the list version)
17:13:49 <ddarius> wy: HtDP is slower and more basic than SICP.  It's unlikely to be too interesting if you already have a good handle on programming and Scheme.  It's best as an introduction to programming in general.
17:13:59 <Saul_> ok thanks everybody
17:15:47 <byorgey> wy: I used HtDP as the text for an introductory high school CS class I taught, which should give you an idea of the level
17:16:10 <wy> byorgey: got it
17:17:17 <gwern> oerjan: ah, I see. I was wondering how to use the liftM2 inside the filter, not out
17:17:42 <ddarius> wy: As an alternative, Shriram Krishnamurti's Programming Languages: Applications and Interpertations is a decent read that is somewhat complementary to SICP.
17:18:06 <Mitar> currently I use evalStateT to get the value at the end of the action
17:18:23 <Mitar> there is execStateT to get the state at the end of the action
17:18:27 <Mitar> how can I get both?
17:18:34 <ddarius> :t runStateT
17:18:35 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
17:19:50 <Mitar> thanks
17:20:57 <wy> I want to have a brief look at smalltalk and simula 67, to see if type classes missed something. Maybe static typing and type inference is putting too much restriction on us?
17:21:25 <ddarius> wy: Type classes don't at all correspond to classes in smalltalk/simula.
17:21:39 <oerjan> Mitar: it may be hard to find because it's just a field in the newtype definition.  several other Monads also have their most fundamental run* functions defined that way.
17:22:04 <Mitar> yes ...
17:22:13 <ddarius> Also, the classes in those languages are not essentially different from the classes of C++, Java, C#, etc.  There are OO languages that -are- different.
17:22:20 <oerjan> btw:
17:22:24 <Mitar> I was going over types of all those maps and others ... but it did not look like it
17:22:34 <oerjan> oh right
17:23:02 <wy> ddarius: Have you used smalltalk? I guess it's a little different, since Haskell's type class is learned from smalltalk
17:23:21 <oerjan> o_O
17:23:25 <ddarius> wy: As I just said, Haskell's type classes aren't at all the same as Smalltalk's.
17:24:02 <newsham> ddarius: smalltalk offers duck typing supported by lisp and python but different than c++ and similar to java interfaces, no?
17:24:08 <oerjan> wy: i would like a reference for that claim, thank you :D
17:24:23 <ddarius> newsham: Smalltalk is just dynamically typed.  That's all.
17:24:27 <wy> oerjan: Which one?
17:24:35 <shapr> @yow !
17:24:35 <lambdabot> Half a mind is a terrible thing to waste!
17:24:47 <ddarius> wy: Also, it doesn't even make sense to talk about Haskell type classes in a dynamically typed language.  This is an example of something that would be "missed" by dynamic typing "putting too much restriction on us"
17:24:50 <oerjan> that haskell type classes come from smalltalk in any way
17:25:00 <dons> they do??
17:25:12 <newsham> i think duck typing and dynamic typing are orthogonal.
17:25:16 <newsham> you can have one iwthout the other
17:25:20 * dons looks up 'type classes: exploring the design space' again..
17:25:41 <scook0> newsham: e.g. C++ templates?
17:26:03 <dons> oerjan: do you have a reference for that? i'm almost 100% certain type classes in haskell arose independently
17:26:05 <wy> oerjan: It's actually from Wadler's type class paper "how to make ad-hoc polymorphism less ad hoc"
17:26:14 <newsham> scook0: i dont know the answer to that :)
17:26:15 <TomMD> does yhc have a trac?
17:26:18 <oerjan> dons: wy claimed it
17:26:32 <oerjan> and now gave a reference too..
17:26:37 <ddarius> newsham: They're not orthogonal, but they aren't identical either, I'd agree.
17:27:12 <dons> oerjan: they're from wadler's paper, as a solution to ad hoc polymorphism
17:27:48 <dons> http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps.gz
17:28:10 <oerjan> dons: read what wy said please, i was just doubting it like you
17:28:42 <LoganCapaldo> this is what the smalltalkers want, us arguing among ourselves! be strong brothers!
17:28:46 <jsnx> type classes are sorta like mixins in ruby
17:28:54 <LoganCapaldo> not really
17:28:56 <wy> oerjan: Wait... I doubt that I dreamed that up. I can't find that sentence now...
17:29:01 <newsham> ddarius: ok, i'd buy that
17:29:09 <dons> ah yes, there's no relation. type classes arose in haskell entirely independently of classes in smalltalk and OO
17:29:12 <jsnx> LoganCapaldo: they serve the same purpose
17:29:17 <LoganCapaldo> not really
17:29:28 <jsnx> LoganCapaldo: well, they add new operations to a datatype
17:29:32 <dons> as wadler says , "a generalisation of "eqtype" variables in Standard ML"
17:29:58 <jsnx> LoganCapaldo: i guess you see that as tangential to type classes?
17:30:21 <newsham> jsnx: mix-ins provide implementations.  type classes can optionally provide implementations but dont necessarily
17:30:36 <jsnx> anyways, mixins demonstrate the feasibility of something like type classes -- "ad hoc polymorphism" in a dynamic language
17:31:01 <jsnx> of course, they are not the same...because ruby is "duck typed"
17:31:28 <glguy> isn't that also called "structural subtyping"?
17:31:36 <wy> jsnx: I found that duck typing is wrong
17:31:43 <mrd> the thing about type-classes is that they can be transformed into pure parametric polymorphism -- by transforming a value that has type-class restricted type to a function taking a tuple with the class methods to the original type
17:31:49 <oerjan> wy: i cannot search in the pdf citeseer provides, perhaps you have the same problem?
17:32:13 <jsnx> wy: well, i'm not arguing for it...i'm just saying there is something analogous
17:32:20 <oerjan> it uses that dirty character scrambling :(
17:32:37 <jsnx> and it has been implemented in a dynamic language that's been around for awhile
17:32:42 <wy> oerjan: I found a reference to smalltalk. But I might had bad memory because of 28 hours-day...
17:33:41 <wy> Ah, found it.
17:33:47 <LoganCapaldo> mixins are not like type classes because mixins provide a common implementation, type classes define a common interface
17:34:00 <Cale> I really hate it when people call typeclasses "ad-hoc polymorphism"
17:34:30 <newsham> wasnt that what the seminal paper called them?
17:34:33 <ddarius> At one point it mentions the "obvious" Smalltalk implementation as motivation.
17:34:34 <EvilTerran> am i the only one who saw mixins and thought "that's a really bad idea"?
17:34:34 <Cale> Not quite.
17:34:54 <jsnx> LoganCapaldo: "a common interface" without implementation does not actually make any sense in duck typed language
17:34:54 <newsham> evilt: i've used that "really bad idea" many times to great affect.
17:34:58 <gwern> this is interesting. if I print something with a normal string, it's fine and returns the IO () necessary to finish the do block, but if I want to pass it an IO String/ByteString, I have to put it in a liftM - and then I need a return () and no output appears?
17:35:01 <wy> I misunderstood. "This is exactly the approach used in object-oriented programming [GR83]"
17:35:02 * gwern doesn't understand
17:35:36 <Cale> It did refer to ad-hoc polymorphism, but I don't think it claimed that's what typeclasses were -- in fact, the point was that this was a kind of polymorphism which could accomplish the same goals, but be less ad-hoc.
17:35:37 <LoganCapaldo> jsnx: do you see why they are "not really" alike?
17:35:42 <allbery_b> erm, isn't that xxx >>= print?
17:35:51 <allbery_b> not fmap/liftM?
17:35:52 <jsnx> LoganCapaldo: also, they provide an interface in a back handed way -- because you can override the mixin functions
17:35:58 <wy> Cale: That's named by Strachey 1967
17:36:07 <LoganCapaldo> this isn't find the "least different" language feature, this "are these two things similar?"
17:36:24 <jsnx> LoganCapaldo: i said "sorta like" above -- not exactly alike
17:36:25 <EvilTerran> newsham, well, the same goes for me and perl :P
17:36:28 <gwern> allbery_b: dunno. I'm not really sure how all the monad stuff desugars
17:36:36 <ddarius> wy: The "this" in that sentence, however, isn't referring to type classes or their implementation, but to how another approach deals with these porblems.
17:36:42 <allbery_b> (or maybe join the result, since it would be something like IO (IO ()) if you liftM-ed it)
17:36:42 <wy> Cale: Actually I think it's not ad-hoc at all. It's better than HM system
17:36:48 <LoganCapaldo> well then I guess we just agree to disagree
17:37:00 <jsnx> LoganCapaldo: well, or maybe agree to misunderstand one another
17:37:04 <wy> ddarius: Right. I misunderstood ;-)
17:37:08 * EvilTerran has really gone off dynamic typing recently
17:37:12 <newsham> evilt: touche.
17:37:26 <EvilTerran> :)
17:37:32 <Cale> The major difference between typeclass polymorphism and ad-hoc polymorphism in my mind is that ad-hoc polymorphism fixes the implementation at the call site, based on the type needed, whereas with typeclasses, that's not necessarily the case -- the caller can simply become typeclass-polymorphic.
17:37:38 <newsham> evilt: I'll file that under "I've upped my standards, so 'up yours'"
17:37:49 <EvilTerran> hehe
17:38:37 <wy> Cale: I don't quite understand the notion of call site and caller
17:39:14 <Cale> Okay, so suppose I have some ad-hoc polymorphic function f, and I'm defining another function g
17:39:18 <LoganCapaldo> jsnx: if it makes you feel better I also disagree with the claim that mixins are "sorta like" java style interfaces
17:39:41 <ddarius> Cale: The major difference between type-class polymorphism and ad-hoc polymorphism, is that, in translation, type-classes regain parametricity, ad-hoc polymorphism does not.
17:39:49 <LoganCapaldo> IOW I may be overly anal
17:39:55 <jsnx> LoganCapaldo: i suppose we assign different weights to "sorta like"
17:40:06 <Cale> ddarius: Yes, that's a nice way to put what I'm trying to say :)
17:40:07 <allbery_b> mixins are ad-hoc OO, interfacs are parametric OO.  sorta.
17:40:08 <EvilTerran> I guess I don't think the same way as Matz. what least surprises me is very much unlike what least surprises him
17:40:33 <EvilTerran> <me> "numbers aren't true objects? wtf?"
17:40:39 <wy> ddarius: I wonder if translating to HM system is the best we can do. It seems the HM is restricting the power of type classes to me.
17:40:42 <Cale> So suppose I write g x = ... f x ..., here g is the caller, and the context surrounding f there is the "call site"
17:40:57 <EvilTerran> "... I thought everything was meant to be an object in this thing! ;_;"
17:41:00 <ddarius> wy: Constructor classes aren't even translateable to HM.
17:41:48 <Cale> If I'm using ad-hoc polymorphism, the type at which to apply f has to be determined and be a monomorphic type there.
17:41:52 <LoganCapaldo> EvilTerran: what particular non-true object feature of numbers did you run into?
17:42:02 <wy> ddarius: I mean, the HM system has a rather limited type theory, but type classses is offering finer control. Translating it into HM will reduce the power
17:42:06 <keseldude> !seen davidL
17:42:07 <Cale> If I'm using typeclass polymorphism, we can instead just make g polymorphic.
17:42:33 <jsnx> LoganCapaldo: is there a dynamic language feature that you think is more similar? i think mixins are the closest you can get -- which is not very close
17:42:39 <byorgey> keseldude: use ?seen or @seen
17:42:41 <EvilTerran> LoganCapaldo, well, they behave differently under assignment (as they're value types, not reference types)
17:42:44 <keseldude> ?seen davidL
17:42:44 <lambdabot> davidL is in #xmonad and #haskell. I last heard davidL speak 1h 35s ago.
17:42:50 <keseldude> ok thanks
17:42:50 <keseldude> :)
17:42:57 <byorgey> =)
17:43:06 <keseldude> i'm just starting haskell because of him :P
17:43:10 <LoganCapaldo> EvilTerran, that's unobservable though as their are no number mutating methods
17:43:11 <keseldude> it spreads like the plague
17:43:12 <ddarius> wy: As I said, type classes (specifically constructor classes) already aren't translateable to a Hindley/Damas-Milner type system.  That doesn't matter because the translation isn't part of the language, but an implementation detail.
17:43:15 <gwern> (liftM B.lines) $ join $ liftM (B.readFile . (++ "/.dload-dirs")) home <-- any idea how I could merge the two liftMs separated by a join?
17:43:18 <wy> Cale: Let me think about it for a while
17:43:21 <Cale> So a better term for the kind of polymorphism which typeclasses provide would be 'restricted parametric polymorphism'
17:43:28 <glguy> ghc-6.8.2: panic! (the 'impossible' happened)
17:43:28 <glguy>   (GHC version 6.8.2 for x86_64-unknown-linux):
17:43:28 <glguy> 	Coercion.splitCoercionKindOf
17:43:28 <glguy> ....
17:43:30 <glguy> wee
17:43:34 <EvilTerran> LoganCapaldo, i'm trying to remember what really ticked me off, though...
17:43:45 <LoganCapaldo> jsnx: I just don't think there is a similar feature, or a need for one
17:43:57 <ddarius> wy: Also, type classes are -part- of the type system.  It therefore, doesn't make sense to say that they are limited by it (which is not what you are saying now, but what you were suggesting earlier)
17:44:03 <wy> ddarius: You mean type classes changed since Wadler's first paper?
17:44:07 <jsnx> LoganCapaldo: why do you think there isn't a need for one?
17:44:09 <Cale> The point is that you're doing the same thing as parametric polymorphism, but restricting the set of types which the type variables range over to be just those types which implement a particular interface.
17:44:14 <ddarius> wy: Yes.  We've added constructor classes.
17:44:44 <LoganCapaldo> because all dispatch in ruby is dynamic and based on the "type", so you don't "need" type classes
17:44:45 <byorgey> glguy: nice =)
17:44:52 <ddarius> E.g. the Monad class is not supported by the system described in that paper.
17:44:58 <allbery_b> home is an IO type?
17:45:00 <wy> ddarius: uhh. What's that?
17:45:21 <ddarius> wy: What's what?
17:45:35 <jsnx> LoganCapaldo: okay, sure -- but that's just the same as saying, dynamic languages don't need static types...
17:45:43 <jsnx> LoganCapaldo: which i can agree with
17:45:48 <glguy> man... fundeps make associated type synonyms look terribly difficult
17:45:50 <EvilTerran> LoganCapaldo, also, there was some oddity with numbers not inheriting methods added to the Object class or something. i forget.
17:45:54 <wy> Cale: Got it!
17:46:05 <EvilTerran> (not that you should want to do that terribly often)
17:46:19 <Cale> wy: A good example is 'sort'
17:46:32 <ddarius> LoganCapaldo: There are patterns that are capturable with type classes that aren't with ruby's classes and vice versa.
17:46:33 <wy> :t f x = x + 1
17:46:35 <lambdabot> parse error on input `='
17:46:43 <byorgey> gwern: join (fmap f x) is the same as x >>= f
17:46:51 <wy> Cale: Is this example ok?
17:46:54 <byorgey> gwern: and liftM is the same as fmap
17:46:58 <wy> f :: forall a. (Num a) => a -> a
17:46:58 <oerjan> gwern: join . liftM f x = f =<< x
17:47:05 <oerjan> what the?
17:47:12 <LoganCapaldo> ddarius: sure. This is why I continue to insist that mixins are not like type classes :)
17:47:17 <Cale> wy: yeah
17:47:22 <wy> So f become polymorphic in a
17:47:22 <Cale> wy: If (<) was ad-hoc polymorphic, you could write any kind of sort function using it, but would have to repeat the same code for each type of list that you wanted to sort.
17:47:38 <oerjan> i finally manage to read to the end of my window, long after gwern asked, and byorgey answers in the same moment :(
17:47:40 <ddarius> *sigh* Proving the non-existence of a left adjoint is trickier when the appropriate category has no known colimits...
17:47:48 <Cale> wy: Whereas with typeclass polymorphism, the sort function itself becomes polymorphic automatically.
17:47:50 <byorgey> oerjan: heh =)
17:48:15 * allbery_b was a bit surprised to see him go with join instead of switching to >>=
17:48:21 <wy> Cale: Is Java ad-hoc or ...?
17:48:26 <EvilTerran> LoganCapaldo, i gave up on ruby pretty quickly, TBH. it didn't agree with me.
17:48:41 <Cale> wy: Java uses subtype polymorphism, which is another kettle of fish altogether.
17:48:43 <byorgey> @type \f x -> join (fmap f x)
17:48:44 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
17:48:56 <ddarius> wy: Java has inclusion polymorphism as well as ad-hoc polymorphism (I think)
17:49:03 <oerjan> gwern: i think @pl can help simplify such things
17:49:12 <ddarius> wy: inclusion polymorphism == subtype polymorphism
17:49:20 <oerjan> @pl (liftM B.lines) $ join $ liftM (B.readFile . (++ "/.dload-dirs")) home
17:49:20 <lambdabot> fmap B (lines (B . readFile . (++ "/.dload-dirs") =<< home))
17:49:31 <FunctorSalad> Java also has interfaces... I didn't find them so bad *ducks and runs*
17:49:34 <wy> ddarius: I didn't know that. How can you demonstrate subtype polymorphism?
17:49:46 <LoganCapaldo> EvilTerran: I was just curious, there are non-objecty things about numbers fixnums in particular but I've never found myself going "crap! if only fixnums had singleton classes like every other object!"
17:49:47 <oerjan> oh it misparsed
17:49:56 <oerjan> @pl (liftM lines) $ join $ liftM (readFile . (++ "/.dload-dirs")) home
17:49:56 <lambdabot> fmap lines (readFile . (++ "/.dload-dirs") =<< home)
17:50:10 <ddarius> wy: In the "polymorphism, inheritance, encapsulation" view of object-oriented programming, the polymorphism they are referring to there is subtype polymorphism.
17:50:16 <Cale> wy: I forget, can you define the same function at multiple types in Java without having it be defined as a method, and the definitions be for separate instances?
17:50:26 <oerjan>  @pl doesn't understand module qualifiers? :(
17:50:26 <EvilTerran> LoganCapaldo, ah well. i can't remember the details of what tripped me up, but it was enough to put me off.
17:50:28 <ddarius> Does Java support overloading?  I forget.
17:50:32 <hpaste>  gwern annotated "bytestring type problem" with "final version" at http://hpaste.org/4838#a2
17:50:40 <allbery_b> oerjan: no, it doesn't
17:50:46 <ddarius> C# does (and obviously C++)
17:51:19 <gwern> oerjan: hm. that's interesting. I thought @pl only handled foo x = bar x situations, with an equality
17:51:25 <wy> Cale: but every function is a method in java
17:51:41 <Cale> wy: Yes, but suppose I want to name two methods of the same class the same thing.
17:51:49 <Cale> (but at different types)
17:51:51 <wy> ddarius: You mean a function with different types of arguments?
17:51:52 <Cale> Can I do that?
17:52:06 <hpaste>  vagif pasted "hdbc-odbc setup error" at http://hpaste.org/4839
17:52:10 <wy> Cale: Same name?
17:52:12 <glguy> is there a LANGUAGE pragma for -fallow-undecidable-instances?
17:52:13 <Cale> yes
17:52:19 <wy> Cale: You can
17:52:31 <vagif> Hi, anyone can help me with the error i'm getting ?
17:52:33 <Cale> Like,  Integer f (Integer), and String f (String)
17:52:37 <wy> Cale: But your argument types much be a little different for each of them
17:52:38 <allbery_b> -XUndecideableInstances or something like that
17:52:39 <byorgey> glguy: UndecidableInstances, I think
17:52:43 <Cale> wy: right
17:52:49 <Cale> wy: That's ad-hoc polymorphism.
17:53:08 <glguy> byorgey, do you know where the datatype that enumerates these extensions is?
17:53:08 <allbery_b> @paste -- vagif
17:53:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:53:11 <wy> Cale: Oh. We are talking about different thing.
17:53:13 <EvilTerran> LoganCapaldo, ISTR the .dup method didn't work on numbers
17:53:22 <FunctorSalad> Cale: I think that's just overloading, IIRC it's decided statically which one is used
17:53:32 <Cale> FunctorSalad: yes, it is.
17:53:41 <wy> Cale: ... change. We are talking about the same thing
17:53:45 <vagif> i did paste
17:53:58 <loupgaroublond> is there a container for a list of non homogenous data?
17:53:58 <vagif> http://hpaste.org/4839
17:54:04 <Cale> FunctorSalad: Overloading is the same thing as ad-hoc polymorphism, as far as I'm concerned.
17:54:09 <byorgey> glguy: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
17:54:09 <oerjan> gwern: also, @undo and @redo can help you translating between >>= etc. and do notation
17:54:10 <lambdabot> http://tinyurl.com/2xjyqs
17:54:17 <LoganCapaldo> EvilTerran: right.
17:54:22 <Cale> FunctorSalad: unless you disagree with that?
17:54:23 <TomMD> loupgaroublond: 1) Why would that be useful.  2) You want Existential types.
17:54:29 <wy> I'm convinced that overloading of non-methods doesn't make any sense
17:54:31 <gwern> oerjan: I'll remember those
17:54:42 <Cale> wy: hm?
17:54:46 <FunctorSalad> Cale: sorry, I don't know what ad-hoc polymorphism is :(
17:54:46 <TomMD> @where existential
17:54:46 <lambdabot> I know nothing about existential.
17:54:47 <wy> That's why Java made them all methods ;-)
17:55:02 <ddarius> FunctorSalad: Ad-hoc polymorphism is overloading.
17:55:03 <oerjan> gwern: and of course @unpl when things get too pointless
17:55:10 <loupgaroublond> TomMD: i'm probably still stuck in the mind set other OO systems, but i want a list of objects i can call a certain function on
17:55:14 <EvilTerran> LoganCapaldo, it returns nil or throws an exception or somesuch untoward behaviour, iirc
17:55:20 <LoganCapaldo> yes
17:55:25 <LoganCapaldo> throws an exception
17:55:39 <byorgey> vagif: apparently you're supplying something of type IO ExitConf when an IO () is expected
17:55:40 <wy> Cale: It's not reasonable to use the same name to operate on types in totally different classes
17:55:43 <EvilTerran> this was annoying when i wanted to blindly take a .dup of a parameter to my function without worrying about the type of it
17:55:45 <TomMD> ?remember existential http://haskell.org/haskellwiki/Existential_type
17:55:45 <lambdabot> Nice!
17:55:57 <oerjan> TomMD: er no
17:55:57 <byorgey> vagif: oh, wait, I see, this isn't code you wrote
17:55:58 <ddarius> TomMD: You wanted @where+
17:55:58 <Cale> wy: Like, in C++, you can define a bunch of functions which have the same name, but different types:
17:55:59 <TomMD> loupgaroublond: See above link
17:56:01 <FunctorSalad> and how is the dynamic kind of polymorphism called then? (as with abstract classes or interfaces)
17:56:01 <Cale> int foo (int a)
17:56:03 <hpaste>  glguy pasted "How do I write this using associated type synonyms...?" at http://hpaste.org/4840
17:56:07 <Cale> int foo (int a, char b)
17:56:09 <oerjan> that goes in @quote, not @where
17:56:10 <TomMD> damn it, I always mess that up!
17:56:16 <vagif> byorgey: it is a Setup.hs
17:56:18 <allbery_b> @forget existential http://haskell.org/haskellwiki/Existential_type
17:56:18 <lambdabot> Done.
17:56:26 <allbery_b> @where+ existential http://haskell.org/haskellwiki/Existential_type
17:56:27 <lambdabot> I will never forget.
17:56:29 <loupgaroublond> TomMD: thanks
17:56:30 <wy> Cale: Right. So I think that kind of thing shouldn't be allowed
17:56:33 <byorgey> vagif: right, sorry... don't think I can be of much help
17:56:39 <TomMD> np
17:56:40 <ddarius> wy: Why not?
17:56:43 * TomMD goes afk
17:56:51 <Cale> wy: Yeah, you can use typeclasses to simulate it though. They're actually more powerful.
17:57:09 <Cale> However, we'd usually recognise such uses as abuse of the system.
17:57:12 <ddarius> Cale: They're something else altogether.
17:57:19 <Cale> ddarius: I agree.
17:57:21 <wy> ddarius: Because if you ever want to use the same name operating on different types, you should create a new class
17:57:33 <ddarius> wy: Why?
17:57:54 <Cale> ddarius: But if you define a typeclass with a single method whose type is exactly the parameter of the typeclass, you get a similar effect.
17:58:00 <LoganCapaldo> EvilTerran: That particular practice is one I happen to disagree with (blindly dup ing something) but I can understand how it would leave a bad taste in your mouth
17:58:05 <wy> Because your existing classes can't capture the charateristics of your operation, which you think is common to them
17:58:11 <JohnDoeKyrgyz> Any ideas as to why this won't compile?
17:58:13 <JohnDoeKyrgyz> --A matrix is a list of rows
17:58:13 <JohnDoeKyrgyz> newtype (Show a) => Matrix a = Matrix [[a]]
17:58:13 <JohnDoeKyrgyz> instance Show Matrix where
17:58:13 <JohnDoeKyrgyz>     show (Matrix x) = x intersperse (map (\x -> intersperse x "|") x) "\n-------\n"
17:58:20 <Cale> The instances of that class become much like the multiple definitions of your function.
17:58:26 <glguy> wy, the function "iI" I just pasted accepts an arbitrary number of arguments
17:58:46 <oerjan> JohnDoeKyrgyz: instance Show a => Show (Matrix a) where
17:58:50 <glguy> (if that is related to what you are discussing, I haven't been following closely)
17:59:06 <Cale> JohnDoeKyrgyz: yeah, what oerjan said
17:59:21 <Cale> JohnDoeKyrgyz: Chances are, that restriction on your newtype doesn't mean what you think it does.
17:59:25 <JohnDoeKyrgyz> oerjan Thanks!!
17:59:36 <christine_c> hello people
17:59:39 <Cale> hello!
17:59:44 <oerjan> JohnDoeKyrgyz: and x intersperse does not look right either, may be you want `` around intersperse
17:59:47 <Cale> christine_c: New here?
17:59:51 <ddarius> wy: Why are classes involved at all?  There is nothing that limits overloading to OO languages.
17:59:52 <Mitar> how could I process a list six elementts at the time?
17:59:55 <christine_c> yap
18:00:05 <Mitar> is there any built in function for this?
18:00:18 <allbery_b> no
18:00:19 <christine_c> i just like to ask some opinion or guidance if it is possible here
18:00:19 <Cale> christine_c: Welcome! Feel free to ask any questions you might have about Haskell :)
18:00:27 <wy> ddarius: Why do you want to call them the same name?
18:00:29 <oerjan> JohnDoeKyrgyz: er scratch that
18:00:32 <christine_c> this is not regarding haskell
18:00:39 <oerjan> i think the x should be removed
18:00:42 <Cale> ah, what's it about? :)
18:00:49 <oerjan> and the arguments to intersperse switched
18:01:08 <wy> ddarius: Notice that in all OO languages, you can't have the same name overloaded with different RETURN types
18:01:17 <christine_c> im looking for an application where i can apply KBMS, i choose already Academic Advising, but my professor rejected the idea
18:01:25 <glguy> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..10]
18:01:26 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
18:01:35 <glguy> Mitar, does that relate to your question?
18:01:38 <christine_c> according to him, it is straightforward, RDBMS can do that
18:01:49 <Mitar> yes, it does very :-)
18:02:08 <ddarius> wy: There's nothing that stops a function from being overloaded on return type, though it can lead to ambiguity quite easily.
18:02:22 <christine_c> the only problem is the application or An IS,anyone can suggest, that both I can maximize the feature of KBMS
18:02:29 <ddarius> wy: Also, I think Scala -can- do that.
18:02:32 <glguy> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) [1..10]
18:02:33 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
18:02:56 <hpaste>  TomMD pasted "Heterogenious Lists" at http://hpaste.org/4841
18:03:02 <christine_c> actually the title before is "Development of Academic Advising System using SMS Technology", where a student can ask advise thru text messaging
18:03:06 <TomMD> loupgaroublond: See above link for a stupid simple example.
18:03:09 <wy> ddarius: If you want to use the same name for operations on different types, there must be something in common there
18:03:25 <Cale> christine_c: What's a KBMS? I recognise that RDBMS means a relational database management system.
18:03:29 <christine_c> my professor is comfortable already with SMS and building intelligent system, but my problem is where to apply
18:03:38 <ddarius> wy: No there needn't be.  That's why it is called -ad-hoc- polymorphism.
18:03:43 <Mitar> > iterate (take 3) $ [1..10]
18:03:44 <christine_c> Knowledge based management system
18:03:44 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2...
18:04:03 <glguy> TomMD, If you are storing a list of Show instances, you might as well just make a list of the strings instead of the value and function?
18:04:13 <Cale> christine_c: Okay, and how does that differ from a relational database?
18:04:22 <Mitar> > iterate (drop 3) $ [1..10]
18:04:22 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10],[],[],[],[],[],[],[...
18:04:23 <TomMD> glguy: Don't look at me - while I am doing something like this, I am just answering a question.
18:04:28 <glguy> oh :)
18:04:29 <wy> ddarius: That's why they sucks ;-)
18:04:43 <glguy> TomMD, the channel is moving too fast today for me to read everything and keep working on my stuff
18:05:02 <hpaste>  loupgaroublond pasted "existential" at http://hpaste.org/4842
18:05:11 <christine_c> he said academic can be done by simple IF provided that policy has been clearly defined, no need to implement to any Programming Logic Software
18:05:14 <loupgaroublond> TomMD: thanks again, although why do i get this error here ^ ?
18:05:50 <glguy> loupgaroublond, does LayoutClass have more than one argument?
18:05:52 <christine_c> rdbms, is actually where the data are stored
18:05:55 <oerjan> @users
18:05:55 <lambdabot> Maximum users seen in #haskell: 439, currently: 406 (92.5%), active: 24 (5.9%)
18:06:04 <loupgaroublond> glguy: oh, right, it does
18:06:51 <christine_c> but for processing as for advises, it needs an intelligent programming like lisp, prolog, haskell, but the problem why I should you the later, if i can implement using SIMPLE if
18:06:55 <loupgaroublond> still, i'm getting non homogenity errors, i suppose i better define a bogus useless type
18:06:56 <christine_c> thats there question
18:07:20 <Cale> IF?
18:07:22 <ddarius> wy: That's a rational reason to dislike them, but only if you also dislike them for methods too.
18:07:25 <christine_c> the question why I should use the later
18:07:37 <christine_c> simple IF and then statement
18:07:43 <Cale> oh
18:07:52 <wy> TomMD: I tried to use existentials like that once, but I was told forall. (Show a) => a is not an instance of Show...
18:08:02 <christine_c> i want also to utilize the power of logic programming
18:08:24 <hpaste>  TomMD annotated "existential" with "Fixed multi-parameter" at http://hpaste.org/4842#a1
18:08:31 <Cale> Perhaps something like a scheduling problem?
18:08:33 <christine_c> my study is somewhat expert system or Decision Support System
18:08:45 <wy> ddarius: What do you mean by dislike for "methods"?
18:09:41 <TomMD> wy: I am not familure with your issue.  If you really are having a problem then ask me again or e-mail me (or the haskell-cafe, or comment on my sequence.complete.org blog).  I've got to go.
18:10:00 <christine_c> i also presented that scheduling system, but they discourages it because there are lots of existing scheduling system, outdated according to them
18:10:19 <wy> TomMD: Thanks. See you!
18:10:20 <ddarius> wy: If you dislike overloading functions because it is ad-hoc, you should dislike it just as much for methods.
18:10:36 <FunctorSalad> ddarius: hmm methods are different
18:10:50 <FunctorSalad> ddarius: it is decided at runtime which implementation is called, based on the type of the object
18:10:57 <ddarius> FunctorSalad: -overriding- methods, is different, not overloading them.
18:11:16 <FunctorSalad> ddarius: oh, right
18:11:23 <wy> ddarius: Do you mean by "methods" all overloaded functions?
18:11:47 <christine_c> cale......can you suggest other please?
18:11:57 <wy> ddarius: As for type classes?
18:12:12 <ddarius> wy: No, I mean the normal definition in an OO language like Java.  "member functions of an object" to use C++ terminology.
18:12:32 <FunctorSalad> wy: AFAIK a method in java is just any function belonging to a class
18:12:44 <FunctorSalad> (not neccessarily overloaded or overwritten)
18:12:55 <wy> ddarius: I dislike the notion that "everything is an object", since not everything is an object ;-)
18:13:19 <ddarius> wy:  That's irrelevant to what I'm talking about.
18:13:26 <monochrom> Yeah, some things are morphisms instead of objects. :)
18:13:36 <wy> ddarius: So that includes the methods
18:13:56 <ddarius> wy: Disliking "everything is an object" doesn't mean you dislike objects.
18:13:59 <wy> monochrom: Any others?
18:14:06 <monochrom> Everything is an object, a morphism, or a category. :)
18:14:10 <FunctorSalad> monochrom: in soviet comma category, morphisms are objects
18:14:35 <wy> monochrom: So there are only three kinds of things in the world?
18:16:57 <wy> Any ideas what intersection types are? I found I misnamed union type as intersection types
18:17:14 <ddarius> @google "intersection types"
18:17:16 <lambdabot> http://www.macs.hw.ac.uk/~jbw/itrs/
18:17:16 <lambdabot> Title: Home Page for Intersection Types and Related Systems
18:17:44 <Mitar> is there a version of take with Integer as its type?
18:17:52 <oerjan> Mitar: genericTake
18:17:55 <allbery_b> :t genericTake
18:17:55 <oerjan> :t genericTake
18:17:57 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
18:17:57 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
18:18:16 <FunctorSalad> that's a /lot/ of elements to take
18:18:25 <wy> ddarius: I found that page some time ago, but haven't got any idea from it
18:18:31 <oerjan> wy: f :: T1 /\ T2 if both f :: T1 and f :: T2, as i recall
18:18:33 <Mitar> thanks ..
18:19:08 <wy> :t take
18:19:08 <lambdabot> forall a. Int -> [a] -> [a]
18:19:16 <ddarius> @google FLINT project
18:19:17 <lambdabot> http://flint.cs.yale.edu/
18:19:17 <lambdabot> Title: Yale FLINT Group: Home
18:19:31 <LoganCapaldo> > maxBound :: Int
18:19:32 <lambdabot>  2147483647
18:19:33 <monochrom> An example application of genericTake is you have an infinite list and you want to take 2^200 items.
18:19:49 <LoganCapaldo> > 2^200
18:19:49 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
18:20:08 <wy> oerjan: Isn't that just multiple inheritance?
18:20:31 <monochrom> It's quite possible that the whole program still runs in pretty bounded memory. :)
18:20:32 <oerjan> wy: i saw this in the context of typed lambda calculus, no objects involved
18:20:46 <ddarius> wy: It can be related to subtyping, but it doesn't need to be.
18:21:09 <ddarius> wy: All f : T1 /\ T2 means is that f can be viewed as simultaneously having both types.
18:21:36 <wy> ddarius: So that's exactly type classes are doing?
18:21:39 <FunctorSalad> does remind me of multiple inheritance too. though that would be a subset of the intersection though
18:21:43 <ddarius> wy: No.
18:21:54 <oerjan> apparently if you have intersection types + an omega type that everything is in, you can type every terminating expression (with restrictions on where omega is so this is not trivial)
18:21:56 <wy> ddarius: (Num a, Show a, ...) => Integer a
18:22:05 <ddarius> wy: Num and Show aren't types.
18:22:13 <wy> ddarius: But I think they are
18:22:25 <oerjan> *lambda expression
18:22:31 <ddarius> wy: That you think they are doesn't make them so.
18:22:33 <monochrom> The power of analogy...
18:22:35 <monochrom> is a curse.
18:22:50 <LoganCapaldo> The curse of analogy
18:22:54 <wy> ddarius: I can create another type theory which makes them types ;-)
18:22:59 <LoganCapaldo> by stephen king
18:23:25 <ddarius> wy: That's fine, but that's a different type system and has no bearing on Haskell type classes.
18:23:58 <monochrom> armchair type philosophy?
18:25:12 <LoganCapaldo> i wish my chair had arms
18:25:13 <ddarius> wy: There are at least three ways of getting a value of some intersection type.  1) Assert it, 2) you can have the intersection be the meet in the subtyping lattice, 3) one type can be an instance of another.
18:25:28 <conal> i wish my chair had wings!
18:25:36 <EvilTerran> glguy, i'm getting an incomprehensible error out of trying to convert that into ATSs
18:25:49 <EvilTerran> blowing the stack on the typechecker for no reason i can discern
18:25:54 <monochrom> I wish it has types. :)
18:25:58 <allbery_b> aren't they still buggy?
18:26:12 <glguy> EvilTerran, I managed to get all kinds of errors trying different techniques of translation :)
18:26:17 <ddarius> wy: Reynold's language Forsythe had 1 and 2.  E.g. he asserted that arrays were interesections of records containing a label 'length' and functions on integers.
18:26:31 <EvilTerran> `ic :: {forall (f :: * -> *) a c.
18:26:31 <EvilTerran>         (LiftMN (f a -> c), Applicative (F (f a -> c))) =>
18:26:31 <EvilTerran>         (LiftMN c, Applicative (F c))}'
18:26:31 <EvilTerran>   arising from the type signature for `liftMN'
18:26:31 <EvilTerran>                at AssocTypeSyns.hs:41:1-29
18:26:34 <EvilTerran> over and over again
18:26:39 <sclv> anyone have any good advice on writing quickcheck properties for parsers?
18:26:55 <hpaste>  loupgaroublond pasted "existentials and multiparameter types" at http://hpaste.org/4843
18:27:21 <wy> ddarius: A new view of arrays?
18:27:39 <ddarius> wy: He also had a (fixed) subtyping lattice where, I forget the exact types, but you had situations like, Int <: Rational and Int <: Float so that Rational /\ Float would be Int.
18:27:40 <conal> i think he (Reynolds) also represented (assignable) variables as intersection between getter & setter commands.
18:28:32 <ddarius> wy: Not really.
18:28:58 <wy> ddarius: Seems like a new way of take things apart
18:29:22 <ddarius> wy: It's an unusual way of getting that effect, but not an original view of arrays.
18:29:41 <sclv> i.e. it's hard to think of good properties to use that don't require, in effect, rewriting the parser.
18:29:55 <davidL> @seen lemmih
18:29:55 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 1h 40m 7s ago.
18:29:57 <wy> ddarius: But how do you know that Int only <: Rational and Float?
18:30:03 <Lemmih> davidL: Yo.
18:30:22 <davidL> Lemmih: are you working on conjure?
18:30:40 <Lemmih> davidL: Not really.
18:31:17 <monochrom> loupgaroublond: If you receive a kind error, and it involves importing something from another module, it is because the compiler assumes a wrong kind for the thing imported. (Across module boundaries, it's hard to guess the right kind.) You have to use explicit kind annotation to fix it. I forgot where to put the kind annotation - in the importer or the importee.
18:31:24 <davidL> Lemmih: is the project dead or are other people maintaining it?
18:31:44 <wy> ddarius:  Have you heard of J& ? It seems to have cited Reynolds' paper, so I guess it has something to do with intersection types in java
18:32:04 <BMeph> ?quote EvilTerran "local variables are to data flow what goto's are in control flow. let's get rid of the little buggers."
18:32:04 <lambdabot> No quotes match. :(
18:32:07 <loupgaroublond> monochrom: i'm still not really getting the whole concept :-/, i realized two seconds after i posted that that it was wrong
18:32:15 <BMeph> ?quote+ EvilTerran "local variables are to data flow what goto's are in control flow. let's get rid of the little buggers."
18:32:15 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:32:24 <oerjan> BMeph: @remember
18:32:25 <BMeph> ?remember EvilTerran "local variables are to data flow what goto's are in control flow. let's get rid of the little buggers."
18:32:26 <Lemmih> davidL: It has stagnated. I pick it up from time to time.
18:32:26 <lambdabot> I will remember.
18:32:32 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#kinding  has an example.
18:32:33 <EvilTerran> hehe. :)
18:32:33 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
18:32:53 <ddarius> wy: I've seen it mentioned on LtU, but I don't find user-visible applications of intersection and union types compelling.
18:33:29 <hpaste>  Mitar pasted "PPM reader" at http://hpaste.org/4844
18:33:33 <EvilTerran> is there a generic term for the type parameter to, say, a functor?
18:33:39 <Mitar> this is it, i made it :-)
18:33:43 <Mitar> slow as hell ...
18:33:47 <Mitar> but it works
18:33:55 <wy> ddarius: A problem with intersection types you mentioned is that, how do you know Rational and Float is enough to make an Int?
18:34:12 <monochrom> Yes, of course, maybe N.Named is used wrong, that's all. :)
18:34:17 <davidL> Lemmih: so you are familiar with the bittorrent protocol? I'd like to create a tracker in haskell
18:34:58 <Lemmih> davidL: Yes, I'm quite familiar with the bittorrent protocol.
18:35:03 <ddarius> wy: That's not what that means.  If Int = Rational /\ Float, all we are saying is that Ints are the only values "in common" between Rational and Floats.
18:35:22 <MyCatVerbs> AIEEEEE.
18:35:37 <monochrom> IEEE.
18:35:42 <jsnx> MyCatVerbs: i can has spartaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
18:35:43 <loupgaroublond> monochrom: maybe
18:35:55 <MyCatVerbs> X11 wasn't included in the default libraries set for 6.8.2. What in the name of all that is holey? (Swiss cheese, specifically.)
18:35:56 <EvilTerran> glguy, the 'impossible' happened :(
18:36:02 <loupgaroublond> monochrom: is there a difference between examples than are green vs red in the docs?
18:36:03 <wy> ddarius: Isn't that union types?
18:36:08 * MyCatVerbs wanna wanna xmonad. Damn dependancy chasing.
18:36:11 <glguy> EvilTerran, I found two ways to the impossible :)
18:36:21 <jsnx> wy: no, union types is either a rational or a float...
18:36:33 <Lemmih> davidL: The protocol code from conjure might be of use to you.
18:36:35 <wy> ddarius: I'm really confused about the name. Because there is a duality there
18:36:38 <monochrom> green vs red?
18:36:39 <jsnx> wy: whereas intersection is *both* a rational and a float
18:36:59 <loupgaroublond> monochrom: 8.7.3, the code is green, in 8.7.4 it's red
18:37:12 <glguy> EvilTerran, What do you think it is about this class that makes it so hard to translate?
18:37:19 <glguy> EvilTerran, it's recursive nature?
18:37:28 <glguy> its*
18:37:29 <monochrom> Oh haha, I never noticed that.
18:37:32 <hpaste>  EvilTerran annotated "How do I write this using associated type synonyms...?" with "what i've got so far" at http://hpaste.org/4840#a1
18:37:48 <wy> ddarius: I didn't know they announce that in LtU. It's today?
18:37:50 <loupgaroublond> (it's cause i'm a right brained lefty...)
18:37:54 <ddarius> wy: You can think of it completely analogously to set intersection and union.  By the subtyping constraints we are asserting that Int is a subset of Rational and Int is a subset of Float, so if you intersect them you should get Int (or some superset)
18:37:56 <loupgaroublond> monochrom: this is the source for Named: data Named l a = Named String (l a) deriving ( Read, Show )
18:38:01 <EvilTerran> that compiles and typechecks, but any attempt to use iI...Ii results in explosion
18:38:09 <monochrom> I think the colour has no significance.
18:38:10 <ddarius> http://lambda-the-ultimate.org/node/2591\
18:38:14 <MyCatVerbs> jsnx: something like that.
18:38:17 <davidL> Lemmih: then it wont be too difficult then?
18:38:29 <jsnx> MyCatVerbs: eg, what?
18:38:39 <monochrom> Then N.Named should only receive two parameters.
18:38:46 <MyCatVerbs> jsnx: no X11! Makes me cry. x_x
18:38:50 <Lemmih> davidL: No, trackers are quite simple.
18:39:05 <jsnx> MyCatVerbs: well, uhm, it's easy to get
18:39:10 <ddarius> By not listing other subtyping relationships, I was implicitly assuming there were no other relevant ones and so the intersection would be Int.  However, if we added, e.g. Float <: Rational, then Rational /\ Float would be Float.
18:39:27 <EvilTerran> glguy, ":t iI (,) [1,2,3] [4,5,6] Ii :: [(Int,Int)]" responds in the affirmative, say
18:39:29 <MyCatVerbs> jsnx: I know, but dependancy chasing is painful.
18:39:32 <wy> ddarius: But if I think of the operations that can be used on the types. Int would be able to use operations from both Rational and Float
18:39:32 <sjanssen> MyCatVerbs: we asked them to remove it because X11 is releasing more rapidly than ghc
18:39:42 <MyCatVerbs> sjanssen: ...huh.
18:39:49 <wy> ddarius: That's why I alway confused intersection and union
18:39:58 <jsnx> MyCatVerbs: what system do you have?
18:40:19 <sjanssen> MyCatVerbs: we meaning xmonad/X11 hackers and them meaning GHC HQ :)
18:40:23 <monochrom> Smoke gets in your eyes.
18:40:47 <monochrom> GHC HaQuers
18:40:49 <sjanssen> MyCatVerbs: GHC doesn't allow API changes between minor versions, which just isn't fast enough for the new bindings that xmonad needs
18:40:53 <MyCatVerbs> jsnx: current Ubuntu with self-build 6.8.2
18:40:54 <loupgaroublond> monochrom: if i'm not mistaken, Named wants something that is * -> *, that is l -> a
18:41:02 <MyCatVerbs> sjanssen: why're you adding stuff so quickly?
18:41:21 <jsnx> MyCatVerbs: there is probably a repo with ghc-6.8.2...i use gentoo and we have one for all that stuff
18:41:24 <glguy> EvilTerran, cool, thanks for the paste!
18:41:38 <sjanssen> MyCatVerbs: because the X11 library was missing features that we need
18:41:43 <EvilTerran> (I renamed it to liftAN 'cos i thought it more appropriate)
18:41:47 <jsnx> MyCatVerbs: also, you can always get X11 sources use ./darcs-all --extensions (or something like that)
18:42:09 <monochrom> data Named (l :: * -> *) a = Named String (l a).
18:42:10 <loupgaroublond> sjanssen: if that's the case, can the next version of ghc be designed to configure the libraries as seperate packages to make us distro people's lives easier?
18:42:11 <glguy> EvilTerran, my original intent was to write a liftM implementation
18:42:18 <glguy> EvilTerran, only later did I generalize it
18:42:21 <monochrom> Likely, Named :: (* -> *) -> * -> *
18:42:24 <wy> "Open Multi-Methods for C++"?
18:42:49 <EvilTerran> makes sense
18:42:52 <MyCatVerbs> monochrom: why do you need to explicitly give l's kind there?
18:42:52 <sjanssen> loupgaroublond: this has been possible for a while with most libraries
18:43:05 <sjanssen> loupgaroublond: eg. mtl is a separate package in most distros now
18:43:14 <loupgaroublond> sjanssen: eh? then i'll talk to bos about it at some point
18:43:21 * loupgaroublond shrugs his shoulders
18:43:42 <sjanssen> loupgaroublond: it isn't separate in (guessing here) Fedora?
18:44:01 <jsnx> ouch!
18:44:14 <glguy> mtl isn't separate in Fedora
18:44:31 <loupgaroublond> sjanssen: not quite, but using cabal, aka cabal-rpm doesn't clobber what the main ghc package installs
18:44:33 <monochrom> MyCatVerbs: If Named is to be exported, there is a chance the kind information is lost at the import side, unless there is explicit kind somewhere.
18:44:50 <ddarius> wy: Yes, the more specifically you define something the more you can do with it.
18:45:17 <wy> ddarius: got it.
18:45:25 <wy> Any ideas about this C++ paper?
18:45:28 <loupgaroublond> sjanssen: so i can roll out packages for X11 for example that work perfectly fine, but it's just a bit disorganized and redundant for my tastes
18:45:32 <wy> http://www.research.att.com/~bs/multimethods.pdf
18:46:11 <wy> I would like to see how the problem is solved in haskell, or does it exist at all?
18:48:33 <wy> "Runtime polymorphism is a fundamental concept of object-oriented programming..."?
18:49:20 <Mitar> how can I get from a float a rounded down int?
18:49:24 <wy> Looks like MPTC...
18:49:38 <ricky_clarkson> wy: Sounds like a reasonable interpretation of Alan Kay's stuff about late binding.
18:49:39 <oerjan> :t floor
18:49:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:49:53 <ddarius> wy: Type classes are not run-time polymorphism.
18:49:55 <monochrom> Obession with operational semantics is a fundamental disease of imperative programmers (including imperative OO ones).
18:50:07 <oerjan> > floor pi
18:50:07 <lambdabot>  3
18:50:20 <dibblego> @remember <monochrom> Obession with operational semantics is a fundamental disease of imperative programmers (including imperative OO ones).
18:50:20 <lambdabot> Nice!
18:50:25 <ddarius> wy: The only case in Haskell 98 where you do actually need to have some run-time evidence of a type class is in polymorphic recursion.
18:50:27 <dibblego> I thought so too :)
18:50:57 <ricky_clarkson> @quote monochrom
18:50:58 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
18:50:58 <monochrom> I.e., why insist certain things to be runtime resolved? Yes, certain features are easily implemented as runtime decisions, but you want to specify the feature, not insist on how to implement it.
18:51:10 <ricky_clarkson> dibblego: You don't need the <> in @remember.
18:51:12 <ddarius> wy: Even with extensions, only existentials (or equivalent things) lead to needing run-time evidence, but that's exactly what existentials do, so...
18:51:27 <LoganCapaldo> sigfpe boggles the mind
18:51:28 <oerjan> Mitar: did you see that?
18:52:23 <oerjan> @quote operational.se
18:52:24 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
18:52:27 <oerjan> @quote operational.se
18:52:27 <lambdabot> <monochrom> says: Obession with operational semantics is a fundamental disease of imperative programmers (including imperative OO ones).
18:52:46 <Mitar> thanks
18:53:17 <wy> ddarius: I thought everything is static in Haskell except exceptions
18:53:33 <monochrom> operational sex lust, denotational platonic love? Ha, I like that. :)
18:54:01 <clanehin> there's an STD that causes obsession with operation semantics?
18:54:06 <EvilTerran> wy, existentials involve dictionary passing at runtime, iirc
18:54:08 <oerjan> denotations are all ideals...
18:54:41 <ddarius> wy: ... I have no idea why you think that.  Haskell programs run.  They need to have something to do at run-time.  Maybe you meant type system-wise, but then exceptions have nothing to do with types.
18:55:11 <ricky_clarkson> Dictionary passing is only an implementation, consider that code generation could be used instead (if you dislike cache locality).
18:55:19 <ricky_clarkson> That said, I don't know what existentials are.
18:55:45 <EvilTerran> @where existentials
18:55:45 <lambdabot> I know nothing about existentials.
18:55:47 <EvilTerran> @where existential
18:55:47 <lambdabot> http://haskell.org/haskellwiki/Existential_type
18:55:58 <wy> EvilTerran: Must that be dynamic?
18:56:26 <oerjan> @where+ existentials http://haskell.org/haskellwiki/Existential_type
18:56:26 <lambdabot> It is stored.
18:56:29 <wy> ddarius: I meant the type system thing
18:56:32 <glguy> if (user specified run-time input based conditional) then E "string" else E 55
18:57:23 <wy> ricky_clarkson: But type classes is also dictionary passing
18:57:26 <EvilTerran> glguy: No instance for (Num [Char]) arising from the literal `55' ...
18:57:28 <EvilTerran> :P
18:57:55 <oerjan> EvilTerran: that's exactly what existentials prevent
18:57:58 <loupgaroublond> bah, still not getting these existential types :(
18:57:59 <ricky_clarkson> wy: That is an implementation choice.  Code generation could instead be used.
18:58:16 <oerjan> E being an existential data constructor
18:58:21 <sjanssen> wy: dictionary passing isn't the only way, see JHC
18:58:32 <EvilTerran> oerjan, i know.
18:58:32 <ricky_clarkson> What does JHC do?
18:58:35 <LoganCapaldo> existentials are fun
18:58:42 <LoganCapaldo> black magic
18:58:45 <wy> So can existentials also use code generation?
18:58:50 <EvilTerran> ...
18:58:52 <LoganCapaldo> at least I hope that's what jhc does
18:59:09 <LoganCapaldo> otherwise it's just boring cs
18:59:19 * EvilTerran notices a file in his "haskell experiments directory" that starts with
18:59:19 <EvilTerran> {-TCL} [proc -TCL _ {}]
18:59:50 <wy> Can you confirm to me that multiple-dispatch thing in C++ is just MPTC in dynamic OOP world?
19:00:20 <ricky_clarkson> What multiple dispatch thing in C++?
19:00:23 <Mitar> i have: color (red,green,blue) = map fromIntegral $ [floor red * 255.0, floor green * 255.0, floor blue * 255.0]
19:00:38 <Mitar> and I get an error: Ambiguous type variable `b' in the constraints:
19:00:38 <sjanssen> type error
19:00:38 <Mitar>       `Integral b'
19:00:39 <glguy> and you need [red,green,blue]
19:00:42 <ddarius> wy: Type classes have nothing to do with dynamic dispatch, multiple or otherwise.
19:01:17 <oerjan> Mitar: either put parentheses around red * 255.0 etc., or change 255.0 to 255
19:01:18 <Mitar> how can I convert this floats (red, green, blue) to Ints?
19:01:22 <wy> ricky_clarkson: http://lambda-the-ultimate.org/node/2590
19:01:23 <lambdabot> Title: Open Multi-Methods for C++ | Lambda the Ultimate
19:01:24 <monochrom> 255.0 is an Int?  (Rhetorical question)
19:01:29 <EvilTerran> ... okay. it looks like this file, when run as a haskell script, launches itself as a tcl script, and the two processes communicate via sockets. wow.
19:01:40 <monochrom> How to convert float to int?
19:01:49 <LoganCapaldo> not with fromIntegral
19:01:55 <monochrom> Pick one: floor, ceil, truncate, round.
19:01:56 <glguy> Mitar, floor (red * 255.0) ?
19:01:57 <wy> ddarius: I mean... Essentially the same thing, but in Haskell it's static
19:01:58 * EvilTerran is horrified at his apparent past ingenuity
19:02:07 <ricky_clarkson> wy: Ok.  That happens at runtime.  Haskell's typeclass stuff are decided at compile time.
19:02:10 <scook0> @hoogle floor
19:02:10 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
19:02:13 <scook0> @hoogle round
19:02:13 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
19:02:13 <Mitar> oh, yes ...
19:02:22 <FunctorSalad> he did floor
19:02:26 <monochrom> Why is there no one single "standard" operator to convert float to int?
19:02:26 <wy> ricky_clarkson: good. confirmed the mapping :-)
19:02:29 <Mitar> it was precedence error
19:02:31 <ddarius> wy: They aren't "essentially the same thing".
19:02:42 <scook0> monochrom: which one would you make "standard"?
19:02:49 <ricky_clarkson> wy: C++'s templates are closer to typeclasses than its dispatch mechanisms are.
19:02:51 <oerjan> @src RealFrac
19:02:51 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
19:02:51 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
19:02:51 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
19:02:54 <LoganCapaldo> > toInteger 255.0
19:02:54 <monochrom> Look at floor, ceiling, truncate, round again. There are four standards. Which one would you like to be "the" standard?
19:02:55 <lambdabot>  Add a type signature
19:03:03 <wy> ddarius: I hope so, but maybe there is more mess in the OOP side
19:03:21 <EvilTerran> {-TCL} [proc -TCL _ {}]
19:03:21 <EvilTerran> <tcl code here>
19:03:21 <EvilTerran> exit
19:03:21 <EvilTerran> {HASKELL-}
19:03:21 <EvilTerran> <haskell code here>
19:03:27 <jsnx> monochrom: beccause there is more than one way to do it -- truncate, floor, ceiling...
19:03:31 <EvilTerran> >:)
19:03:46 <wy> haskell would rewrite the history of OOP ;-)
19:03:56 <glguy> hmm, you both forgot unsafeCoerce#
19:04:04 <ddarius> wy: Haskell is completely orthogonal to object-oriented programming.
19:04:26 <scook0> glguy: if you're going down that route, how about const undefined?
19:04:33 <LoganCapaldo> unsafeCoerce# can solve all your problems
19:04:34 <EvilTerran> > fromEnum (1.5 :: Float) -- and this one
19:04:35 <lambdabot>  1
19:04:36 <wy> ddarius: OOP is trying to solve the same problem. It's interesting to see that haskell solved it better
19:04:39 <ricky_clarkson> wy: OOP disappears when you look closely.
19:04:40 <jsnx> but i thought OO was the enemy...
19:04:56 <MyCatVerbs> ddarius: Haskell is entirely orthogonal to a lot of things. :)
19:04:56 <glguy> scook0, you've got the right idea
19:04:57 <scook0> LoganCapaldo: my problem is that my program is too typesafe and doesn't segfault enough!
19:04:58 <ddarius> wy: No Haskell did not.
19:05:16 <LoganCapaldo> scook0: unsafeCoerce# can solve that problem for sure!
19:05:17 <MyCatVerbs> ddarius: hence the saying, "Haskell is my favourite imperative programming language." (It's mine, BTW. ^^)
19:05:17 <monochrom> It doesn't segfault. But doesn't it contain seq's fault? :)
19:05:17 <wy> jsnx: The name is misleading, but having operations depend on types is a good thing
19:05:40 <ricky_clarkson> wy: OO isn't about having operations depend on types.
19:06:04 <wy> ricky_clarkson: I think that's what OO really means
19:06:11 <oerjan> @quote favou?rite.imperative
19:06:12 <lambdabot> No quotes match. I am sorry.
19:06:17 <jsnx> no, oo means the ops belong to the objects
19:06:29 <oerjan> @quote rite.imperative
19:06:29 <lambdabot> No quotes match. Wrong!  You cheating scum!
19:06:31 <ricky_clarkson> jsnx: s/belong to/depend on/
19:06:37 <ricky_clarkson> jsnx: E.g., CLOS
19:06:52 <LoganCapaldo> no oo means message passing, no oo means inheritance, no oo means this, oo means that
19:07:10 <jsnx> ricky_clarkson: right, yes -- it is the instances, and not the types per se, that ultimately drive the operations
19:07:23 <jsnx> LoganCapaldo: yeah
19:07:25 <wy> ricky_clarkson: but they really depends on classes
19:07:29 <ricky_clarkson> Message passing implies behaviour/action, implying a laissez-faire approach to side-effect tracking.
19:07:30 <scook0> while you're at it, you should probably specify what you mean by "type"
19:07:36 <ricky_clarkson> wy: JavaScript does OO without classes.
19:07:49 <Valodim> or class
19:07:55 <LoganCapaldo> rofl
19:07:59 <wy> ricky_clarkson: that's only a mess with the terminologies
19:08:05 <LoganCapaldo> oh man
19:08:10 <glguy> ruby is OO without "classes"
19:08:11 <ricky_clarkson> Not really, no.
19:08:16 <LoganCapaldo> Valodim++
19:08:23 <jsnx> glguy: no
19:08:41 <jsnx> glguy: ruby is OO with classes, modules and 'singleton classes'
19:09:01 <glguy> there isn't much that distinguishes the "classes" from other object instances in ruby
19:09:06 <wy> ricky_clarkson: I still think if there wasn't simula or smalltalk, there wouldn't be type classes
19:09:20 <ricky_clarkson> In any case, the closest to an object in Haskell is probably a bag of functions.
19:09:26 <glguy> and as you can change an objects method's implementations directly ignoring classes
19:09:31 <jsnx> wy: the reason JS is not "class based" is because *every* object can have a new interface if it wants
19:09:37 <glguy> just makes them more like isntances of a prototype factory
19:09:52 <jsnx> glguy: oh, i see what you are saying
19:10:04 <glguy> ruby classes are a convention is what I am suggesting
19:10:13 <LoganCapaldo> you can use ruby like that, it's not done all that often though ime
19:10:14 <ricky_clarkson> glguy: Interesting.
19:10:38 <monochrom> A group of blind people are investigating an elephant for their first time.  "OO! Elephant is like a flap!"  "OO! Elephant is like a hose!"  "OO! Elephant is like a tree trunk!" ...
19:11:04 <wy> quote...
19:11:05 <jsnx> glguy: it's true that you could make little factories that make custom objects without ever defining a class in ruby
19:11:11 <LoganCapaldo> monochrom: didn't you do this with monads like a few months ago? :p
19:11:21 <ricky_clarkson> That was njbartlett_.
19:11:30 <monochrom> Answer: I do this all the time with groups of blind people.
19:11:31 <jsnx> monochrom: then one again smells the elephant's turd....
19:11:51 <wy> monochrom: Sometimes it's better to be blind
19:13:03 <LoganCapaldo> can I come on one of the blind men and elephant expeditions monochrom? I'd like to, if youll pardon the expression, see that :)
19:13:07 <jsnx> ...that man who smells the turd understands the *consequences* of owning an elephant
19:13:09 <monochrom> Of course, not the physiological "blind". The miss-the-forest-for-the-tree, local, narrow-perspective kind.
19:13:49 <wy> Hey. What's jhc? Is it better than ghc?
19:13:50 <monochrom> Is it sometimes better to miss the forest for the tree? To see only one perspective?
19:13:51 <FunctorSalad> metaphors are hard, lets go shopping
19:14:02 <jsnx> > getPony
19:14:03 <lambdabot>   Not in scope: `getPony'
19:14:16 <jsnx> okay, let's go shopping
19:14:31 <jsnx> wy: no, it is not better
19:14:36 <oerjan> > :t gets "Pony"
19:14:36 <lambdabot>   parse error on input `:'
19:14:37 <EvilTerran> shopping is hard, lets ++++ OUT OF CHEESE ERROR ++++
19:14:38 <LoganCapaldo> let's use an allegory instead
19:14:41 <oerjan> :t gets "Pony"
19:14:41 <lambdabot>     Couldn't match expected type `s -> a'
19:14:42 <lambdabot>            against inferred type `[Char]'
19:14:42 <lambdabot>     In the first argument of `gets', namely `"Pony"'
19:14:46 <jsnx> ghc is the *glorious* blah-di-blah...
19:14:47 <ricky_clarkson> The only thing that makes shopping possible is coffee shops.
19:14:49 <oerjan> sheesh
19:15:08 <jsnx> ricky_clarkson: continue
19:15:19 <EvilTerran> :k ContT
19:15:19 <lambdabot> * -> (* -> *) -> * -> *
19:15:24 <LoganCapaldo> is it just me or has this channel gotten extra bizzaro today?
19:15:24 <wy> jsnx: It seems to using some partial evaluation stuff to do global optimization
19:15:53 <jsnx> wy: to tell you the truth, i was just being pugnacious
19:15:54 <LoganCapaldo> I blame the ponies
19:16:03 <oerjan> LoganCapaldo: no, the elephants
19:16:09 <EvilTerran> I AM THE WALRUS
19:16:29 <jsnx> JESUS CHRIST ITS A WALRUS GET IN THE CAR
19:16:41 <jsnx> lolz, we are like bash.org
19:16:44 <EvilTerran> that's no car, it's a bucket
19:16:48 <monochrom> Haskell is hard. Let's g***Exception: <loop>
19:16:54 * allbery_b checks the area for bukkits
19:16:56 <EvilTerran> NOOO, THEY BE STEALIN MAI BUKKIT
19:16:58 <Mitar> @hoogle Int -> Int ->  Float
19:16:58 <lambdabot> No matches, try a more general search
19:17:02 <EvilTerran> (it's a lolhashmap!)
19:17:11 <ricky_clarkson> What this channel needs is a catamorphism.
19:17:17 <oerjan> Mitar: what do you want?
19:17:19 <EvilTerran> (or would that be s/STEALIN/FILLIN/?)
19:17:20 * shapr anamorphs ricky_clarkson 
19:17:33 <Mitar> a divison from two integers to float
19:17:33 <allbery_b> <LoganCapaldo> is it just me or has this channel gotten extra bizzaro today?
19:17:43 <allbery_b> last chance before the return to the normal daily grind?
19:17:46 <FunctorSalad> @slap sanity
19:17:46 <lambdabot> I don't perform such side effects on command!
19:17:52 <Mitar> it is a little bit ugly to write (fromIntegral a) / (fromIntegral b)
19:18:18 <EvilTerran> (/) `on` fromIntegral
19:18:20 <oerjan> :t (realToFrac .) . (%)
19:18:21 <lambdabot> forall b a. (Fractional b, Real (Ratio a), Integral a) => a -> a -> b
19:18:21 <scook0> a common workaround is to define fi = fromIntegral
19:18:30 <ricky_clarkson> :t on
19:18:31 <lambdabot> Not in scope: `on'
19:18:49 <EvilTerran> with my (<|) and (|>), it's even
19:19:00 <EvilTerran> a <|(/) `on` fromIntegral|> b
19:19:20 <allbery_b> LB's too old
19:19:28 <jsnx> > foldr1 (/) . map fromIntegral $ [3,4]
19:19:29 <lambdabot>  0.75
19:19:37 <mrd> catamorphisms chase away the ratamorphisms
19:19:47 <LoganCapaldo> ratamorphism.
19:19:51 <LoganCapaldo> brilliant.
19:19:53 <monochrom> @remember mrd catamorphisms chase away the ratamorphisms
19:19:53 <lambdabot> Done.
19:20:13 <EvilTerran> @vixen awfully rude, isn't he?
19:20:13 <lambdabot> whoa whoa whoa, one question at a time!
19:20:34 <oerjan> interestingly google gives 4 hits on ratamorphism
19:20:56 <LoganCapaldo> @go ratamorphism
19:20:57 <lambdabot> https://lists.cs.columbia.edu/pipermail/ornet/2001-July/001459.html
19:20:57 <oerjan> and suggests correcting to catamorphism
19:21:03 <FunctorSalad> yeah I feel quite original if I come up with a word that doesn't get any hits on google
19:21:15 <mrd> mostly to do with animal testing
19:21:45 <wy> I hope I can mix happy from ghc 6.6.1 with my compiled ghc 6.9
19:21:55 <FunctorSalad> (of course, I mean a word that was not specifically chosen for that purpose)
19:23:05 <BMeph> ?remember ricky_clarkson wy: JavaScript does OO without classes. - Valodim or class
19:23:05 <lambdabot> It is stored.
19:23:21 * EvilTerran blinks
19:23:22 <ddarius> scook0: I don't think that "work-around" is common at all.
19:23:32 * EvilTerran likes his version
19:23:57 <scook0> well, by "common" I mean "I've done it, and I've seen other people do it" :)
19:24:06 <wy> ricky_clarkson: I don't really know JavaScript
19:24:08 <EvilTerran> <|...|> is actually really quite handy... xs <|zipWith (+)|> ys etc
19:24:40 <ricky_clarkson> wy: I don't know it *that* well, but I do know that OO is more about objects than classes/types.
19:24:55 <ricky_clarkson> That's why statically-typed OO languages tend to be full of holes.
19:25:01 <EvilTerran> working round the shortcomings of ``s :P
19:25:07 <scook0> EvilTerran: are (<|) and (|>) just ($) with carefully-chosen precedence/associativity?
19:25:21 <dancor> did .hsc format change from ghc-6.6.1 to ghc-6.8.1, i get "
19:25:24 <EvilTerran> scook0, (<|) = flip ($), but otherwise yes
19:25:36 <scook0> ah, of course
19:25:43 <dancor> Database/HDBC/PostgreSQL/Utils.hsc:91:8:\nparse error on input `import'" trying to build HDBC-postgresql
19:25:56 <EvilTerran> infixr 2 <|; infixl 1 |>;  x <| f = f x; f |> x = f x; -- is how i tend to define 'em
19:26:09 <EvilTerran> although you could just define 'em infixl 1 <|, |>;
19:26:25 <wy> ricky_clarkson: I just feel they don't got the philosophy
19:26:43 <EvilTerran> the only thing you lose is the slightly unintuitive (a <| b <| c) = c b a
19:26:45 <ricky_clarkson> wy: Who?  What philosophy?
19:27:10 <EvilTerran> altho that's a lot less unintuitive than a <| b <| c = c (b a)
19:27:19 <wy> ricky_clarkson: type classes have a philosophy
19:27:31 <ricky_clarkson> Ok.  And who?
19:28:33 <wy> ricky_clarkson: Normal OOP classes would teach you "reuse code" by "inheritance"
19:28:57 <dibblego> and they'd be lying
19:29:23 <wy> dibblego: I think so, because the purpose isn't to reuse code at all
19:29:30 <ricky_clarkson> wy: Even within OO loving circles, inheritance for code reuse isn't ubiquitously popular.
19:29:43 <EvilTerran> fragile base class problem!
19:29:51 <dibblego> wy, I think so, but because the purpose is to reuse code, but the very opposite is achieved
19:30:13 <dancor> ah, just needed -fffi
19:30:26 <ricky_clarkson> Scala or Java+IDEs do a reasonable job at avoiding the fragile base class problem.
19:30:39 <wy> ricky_clarkson: I still haven't figured out the truth different between interface and abstract classes of java
19:30:40 <EvilTerran> -ffffffffffffffffffi?
19:31:06 <dibblego> wy, abstract classes can have concrete methods and constructors
19:31:09 <dancor> repeat 'f' ++ 'i'
19:31:15 <EvilTerran> hehe
19:31:16 <Lemmih> dancor: Or, with Cabal, ForeignFunctionInterface.
19:31:19 <Valodim> a class can implement multiple interfaces, that's the point
19:31:27 * EvilTerran notes that ghc accepts both -ffi and -fffi
19:31:31 <wy> dibblego: But that's not the reason for their existence
19:31:41 <Valodim> yah, what I said is
19:31:53 <dibblego> wy, there is no *reason* in marketing material
19:32:12 <ricky_clarkson> Interfaces exist because OO programmers cannot be trusted to avoid confusing themselves with multiple inheritance, yet multiple inheritance has some uses that cannot easily be discarded in statically-typed OO languages.
19:32:17 <wy> dibblego: That's the answer I'd get from #java
19:32:19 <ricky_clarkson> Yet again because OO is incompatible with static typing.
19:32:39 <dibblego> wy, I doubt it; that's where all the victims hang out
19:32:47 * dancor can't decide which number of f's is optimal and wishes only one had been allowed to spare this agony of choice
19:33:20 <EvilTerran> dancor, -XForeignFunctionInterface :)
19:34:04 <wy> ricky_clarkson: That sounds  right
19:36:06 <ddarius> OO is not incompatible with static typing.
19:36:10 <scook0> ricky_clarkson: "incompatible" seems a bit final
19:36:30 <scook0> you could make a case that no mainstream language has bothered to do it *well*
19:36:48 <ricky_clarkson> scook0: That's my opinion.  You can certainly go some way, but it's quite like polishing a turd.
19:37:20 <ddarius> ricky_clarkson: If you start with the current mainstream languages, and try to fix them, yes.
19:37:53 <scook0> now, it may be the case that good static typing for OO does turn out to be intractable
19:38:05 <scook0> but I don't believe that has been convincingly demonstrated
19:38:23 <ricky_clarkson> Adding static types to OO restricts what you can do with your objects.  Of course that's often a good thing, but eventually you keep adding restrictions and you end up with something OO people won't call OO.
19:38:31 <scook0> (perhaps "impractical" would be a better word)
19:38:33 <ricky_clarkson> Scala is a very good attempt, imo.
19:38:39 <Valodim> it kinda defeats the point of OO
19:38:40 <wy> scook0: I want that answer too
19:39:21 <wy> ricky_clarkson: There is still some restrictions that could be removed from haskell I guess
19:39:50 <ricky_clarkson> wy: I wouldn't suggest that they should be.  Rather, I think OOP is for amateurs.
19:39:51 <scook0> when you send a message to an object, you must have some (static!) expectation that doing so is sensible
19:39:58 <wy> ricky_clarkson: type classes freed use to write the print functions for almost all types. It could do more
19:40:08 <scook0> type systems attempt to make that expectation explicit and testable
19:40:12 <ricky_clarkson> I'm not being condescending there, I mean that OOP is probably a good interface to programming for non-techies.
19:40:17 <wy> ricky_clarkson: It was never possible with ML
19:40:31 <Valodim> ricky_clarkson: most amateurs never really fully grasp OO...
19:40:32 <ddarius> Scala is mildly shackled by the JVM.
19:40:36 <scook0> if the type system isn't powerful enough, too many sensible programs will fail to typecheck
19:41:08 <ricky_clarkson> ddarius: The JVM is one of the reasons I use it instead of Haskell.  Not that I'm overly fond of the JVM, but it's what my project runs on.
19:41:36 <ddarius> ricky_clarkson: I was talking about type system-wise, not useability wise.
19:41:45 <ricky_clarkson> scook0: Too many sensible OO programs are virtually uncheckable.
19:42:17 <ricky_clarkson> It turns out to be a lot easier to typecheck code that was written with the intention of being typechecked.
19:42:20 <hpaste>  (anonymous) annotated "collectRow" with "(no title)" at http://hpaste.org/4845#a1
19:42:24 <ddarius> wy: The "problem" with Haskell is not that it has "removable restrictions", but that it -lacks- certain things.  The most pointed thing being subtyping.
19:42:54 <wy> ddarius: What subtyping, again...
19:44:09 <scook0> if term s has type S, and S is a subtype of T, then s also has type T
19:44:43 <ricky_clarkson> When is subtyping useful?
19:44:50 <ddarius> It's not clear whether we do actually want to have it, but that is where most people have hangups on Haskell.  It usually takes a while before you hit some restriction (given the extensions as well) that aren't there for reasonably compelling purposes.
19:44:56 <ddarius> ricky_clarkson: Everytime OO actually works.
19:44:57 <wy> scook0: How do you define "subtype"?
19:45:09 <ricky_clarkson> ddarius: But it doesn't.
19:45:13 <ddarius> wy: It's information that is given.
19:45:31 <scook0> well, you can define it however you want, so long as it doesn't destroy crucial properties of your typesystem ;)
19:45:36 <shapr> #haskell ... shall I compare thee to ##csharp? I bet you can guess.
19:45:37 <ddarius> ricky_clarkson: Certainly OO gets some things right-ish.
19:45:43 <ricky_clarkson> Every time OO appears to work, you're looking at code that could be written better.
19:46:00 <scook0> a typical example is that in Java, any term of type String also has type Object
19:46:33 <ddarius> ricky_clarkson: Subtyping is perfectly respectable.  Conflating it with implementation inheritance, encapsulation and namespacing is where most mainstream OO languages make it look bad.
19:46:39 <wy> scook0: Can't I do that with type class inheritance?
19:46:40 <ricky_clarkson> scook0: That's not useful.
19:47:08 <ricky_clarkson> ddarius: Sure.  I was asking what use subtyping is though.
19:47:09 <Valodim> why not?
19:47:35 <wy> scook0: class Ojbect a => String a where ...
19:47:37 <scook0> ricky_clarkson: well, I wasn't attempting to answer *your* question
19:47:57 <ricky_clarkson> scook0: Ah.
19:48:30 <ricky_clarkson> If P.Wadler had been involved from the start I doubt Java would have had Object.
19:49:08 <wy> ddarius: We need to prove those restrictions are reasonable, and not because of the limitations of expressive power. Can we?
19:50:00 <ddarius> wy: We can show that "removing" them is fraught with problems.  It's a cost benefit analysis to decide whether they should be removed or not.
19:50:06 <dons> happy 2008 shapr
19:50:15 <ricky_clarkson> Which restrictions in particular?
19:50:31 <wy> ricky_clarkson: There might be. That would be equal to parametric polymorphism
19:50:33 <ddarius> wy: Many of the restrictions people run into today (in fact, including lack of subtyping), have certainly been thought about.
19:50:40 <EvilTerran> wy, the problem with that approach is, if you have some existing type Foo, and you want a subtype of it
19:50:47 <EvilTerran> but Foo's a type, not a typeclass...
19:51:29 <shapr> dons: Happy New Year!
19:51:31 <scook0> you can encode some degree of subtyping in Haskell
19:51:36 <EvilTerran> i guess you could make a new class Fooey f...
19:51:39 <scook0> but the encoding tends to be painful and cumbersome
19:52:00 <EvilTerran> HList records!
19:52:06 <dons> shapr: so any predictions for 2008?
19:52:10 <ddarius> ricky_clarkson: Anyway, to answer you question: if I write a function that operates on a record, there seems to be no reason to not let that function work on any record that contains the same labels and then some.  Similarly for sums, if I write a function that operates on a sum, there seems to be no reason not to let it operate on a "smaller" sum.
19:52:16 <dons> what should we absolutely get done this year?
19:52:18 <shapr> dons: hmmm
19:52:22 <ddarius> ricky_clarkson: That is just a very basic case of (structural) subtyping.
19:52:25 <dons> last year, jan we said 'hackage must be done'
19:52:40 <dons> 12 months later it's humming along
19:52:42 <shapr> And it's done...
19:52:55 <blackdog> hey, is there anyone working for jane st capital here?
19:53:18 <dons> blackdog: not sure, the jane st guys are on -cafe@ though (or one of them anyway)
19:53:28 <ddarius> scook0: You can't encode any subtyping in Haskell.  Subtyping can be viewed as the -implicit- insertion of coercions.  Haskell -never- implicitly inserts coercions.  You can "encode subtyping" only by -explicitly- inserting coercions, i.e. only by missing the whole point.
19:53:53 <ddarius> scook0: What you -can- encode, is various object encodings involving implementation inheritance, method override, information hiding, etc.
19:54:00 <ricky_clarkson> ddarius: I'm not sure that's really subtyping, but I haven't read about structural types that much.
19:54:12 <ricky_clarkson> I'll defer to you and concede.  Here are the keys to my house.
19:54:52 <scook0> perhaps I should have said "fake" instead of "encode"
19:54:55 <ddarius> ricky_clarkson: That -is- -really- structural subtyping.  Whatever you think is subtyping is not it.  The other alternative (which is not exclusive) is nominal subtyping where we simply explicitly name such types.
19:55:13 <ddarius> scook0: You aren't even faking it.  You are losing it's only defining feature.
19:55:21 <EvilTerran> being?
19:55:42 <wy> EvilTerran: Let me think if this encoding is sensible...
19:55:51 <ddarius> [20:53] <ddarius> [...] Subtyping can be viewed as the -implicit- insertion of coercions
19:55:57 <EvilTerran> i see
19:56:38 <wy> blackdog: Yron is on OCaml
19:56:51 <EvilTerran> the type-indexed structure from the HList paper comes fairly close to what you wanted wrt records
19:57:03 <EvilTerran> and it's not *that* ugly
19:58:39 <ddarius> EvilTerran: Yes, you can make the -lack- of subtyping somewhat more palatable, and you can implement sums and products that you can -systematically- coerce, but these aren't what subtyping is.  (They do cover some aspects of OO that are conflated with subtyping.)
19:59:39 <fadec> How can I obtain a composition of functions from a list of them? [a -> a] -> (a -> a)
19:59:44 <sclv> I'm looking at the quickcheck driver in XMonad now. is there a standard version of that, or is the xmonad one pretty much a good default to borrow?
19:59:47 <mrd> subtyping means giving up type reconstruction though
19:59:49 <ddarius> fadec: foldr (.) id
20:00:09 <EvilTerran> fadec, or you could use mconcat in the Endo monoid
20:00:24 <scook0> just make sure you're composing them in the order you intend
20:00:27 <fadec> oh, that's awesome. I was so close
20:00:34 <hpaste>  (anonymous) annotated "collectRow" with "(no title)" at http://hpaste.org/4845#a3
20:00:37 <fadec> yup
20:00:39 <EvilTerran> > mconcat (map Endo [(1:), (2:), (3:)]) []
20:00:40 <lambdabot>  Couldn't match expected type `[a] -> t'
20:00:47 <EvilTerran> er. duh.
20:00:47 <blackdog> wy: the Ocaml channel
20:00:48 <blackdog> ?
20:00:55 <ddarius> mrd: Indeed, there are issues with adding subtyping.  As I said, earlier, even the lack of subtyping which is run into fairly quickly by most have been thought about and so far decided not to be "fixed".
20:00:56 <EvilTerran> ?type mconcat (map Endo [(1:), (2:), (3:)])
20:00:56 <lambdabot> forall t. (Num t) => Endo [t]
20:01:05 <EvilTerran> ?src Endo
20:01:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:01:13 <sjanssen> EvilTerran: try Data.Foldable.foldMap
20:01:18 <fadec> so foldr will run comutations at the head first. Is that correct?
20:01:43 <sjanssen> EvilTerran: eg. foldMap Endo
20:01:45 <ddarius> fadec: No, it will turn [f,g,h] into f . g . h
20:01:54 <fadec> ok
20:01:59 <scook0> if you want to apply functions left-to-right
20:02:07 <fadec> this stuff is so friggin slick
20:02:09 <EvilTerran> > mconcat (map Endo [(1:), (2:), (3:)]) `appEndo` []
20:02:10 <mrd> also, it makes inversion principles more involved =)
20:02:10 <lambdabot>  [1,2,3]
20:02:12 <ddarius> If you want it to go the other way, you can just flip (.)
20:02:15 <wy> blackdog: right. I saw his nick there once
20:02:37 <mrd> the proof, anyway
20:02:56 <wy> I think subtyping is just a small case of a more general problem
20:03:23 <fadec> ddarius: thanks man
20:04:00 <EvilTerran> fadec, in case you were wondering, newtype Endo a = Endo (a -> a), mappend = (.), and appEndo (Endo f) = f
20:04:15 <EvilTerran> it's the monoid of endomorphisms :P
20:05:00 <fadec> EvilTerran: I don't yet know what an endomorphism is. I'll save this conversation and look it up later.
20:05:06 <idnar> :t foldr (.) id
20:05:07 <lambdabot> forall a. [a -> a] -> a -> a
20:05:09 <EvilTerran> do you know what a monoid is?
20:05:12 <EvilTerran> hint: it's not a monad
20:05:25 <mrd> it's not a yonoid
20:05:33 <EvilTerran> in this context, an endomorphism is just a function :: a -> a
20:05:36 <EvilTerran> for some a
20:05:36 <idnar> :t foldl (.) id
20:05:37 <lambdabot> forall a. [a -> a] -> a -> a
20:05:58 <fadec> EvilTerran: It's like, uh, has an identity and a?  Addition over integers is a monoid I think.
20:06:01 <EvilTerran> a monoid is any type with an associative binary operation that has an identity
20:06:20 <oerjan> idnar: they're actually equivalent for finite lists, because . is associative with id as identity
20:06:42 <idnar> oerjan: yeah, just realised that
20:06:54 <EvilTerran> so the endomorphism monoid is described in haskell as "instance Monoid (Endo a) where mempty = id; mappend = (.)"
20:07:06 <oerjan> although foldr is probably better - gets you to the outer function directly
20:07:07 <EvilTerran> and "newtype Endo a = Endo { appEndo :: a -> a }"
20:07:39 <EvilTerran> > foldr (.) id (repeat (1:)) []
20:07:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:07:43 <EvilTerran> > foldl (.) id (repeat (1:)) []
20:07:45 <lambdabot> Terminated
20:08:33 <fadec> Endo is a more general interface to a list of computations?
20:08:35 <ricky_clarkson> id composed with (id composed with (id comp...infinitum))?
20:09:05 <EvilTerran> fadec, no, (Endo a) is just the type of functions from a to a
20:09:07 <oerjan> > (appEndo . getDual) (Data.Foldable.foldMap (Dual . Endo) [(1:),(2:),(3:)]) []
20:09:08 <lambdabot>  [3,2,1]
20:09:11 <oerjan> yay
20:09:36 <EvilTerran> it's only defined so we can have a Monoid instance for it
20:09:52 <dibblego> ricky_clarkson, there is a Monoid on composition in Scalaz
20:10:10 <fadec> EvilTerran: So (+) over integers satisfies this. This id is +0. An Endo, then, is halfway to becomming a monoid ???
20:10:22 <fadec> if associative
20:10:33 <EvilTerran> (Integer,(+),0) is a monoid
20:10:42 <EvilTerran> (Integer,(*),1) is also a monoid
20:10:48 <ricky_clarkson> dibblego: Whatever you just said, great! ;)
20:10:57 <EvilTerran> likewise, (Endo a,(.),id) is a monoid
20:11:38 <mrd> monoid = semigroup + identity, in case that helps
20:11:50 * mrd abuses = and +
20:12:09 <EvilTerran> semigroup = magma + associativity, to continue this notation abuse, iirc
20:12:22 <EvilTerran> magma = set + binary operator on the set
20:12:44 <fadec> EvilTerran: thinking..
20:13:09 <EvilTerran> so monoid = set with associative binary operator with an identity element
20:13:56 * mrd starts a Notationaholics Nonymous chapter
20:14:02 <dibblego> ?hoogle (Monoid b) => (a -> b) -> (a -> b) -> a -> b
20:14:03 <lambdabot> No matches, try a more general search
20:14:19 <dibblego> ?instances Monoid
20:14:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
20:14:22 <monochrom> There is a way to justify the use of +
20:14:36 <mrd> define a semigroup?
20:14:46 <EvilTerran> <EvilTerran> semigroup = magma + associativity
20:14:49 <monochrom> Define the category of theories.
20:15:18 <EvilTerran> i'll pass
20:15:18 <mrd> Categories are "just" a theory!
20:15:31 * EvilTerran winces
20:15:46 <monochrom> Use stratification! The category itself is a meta-theory.
20:15:58 <fadec> EvilTerran: Let try this again. (+1) is an Endo because it has type Num a => a -> a. ((+1), (.), id) then is a monoid ???
20:16:06 <mrd> i'm impredicative and proud
20:16:10 <EvilTerran> fadec, no...
20:16:34 <monochrom> I'm happy.
20:16:37 <EvilTerran> a monoid, in the mathematical sense, is a triple containing a set, a binary operator on the set, and an element od the set
20:16:40 <EvilTerran> *of
20:16:48 <EvilTerran> say, (S, (*), x)
20:17:04 <fadec> Oh - and (+1) is an element in the set and not the set itself
20:17:11 <monochrom> Gosh, this is going to be a silly joke.  "Hi. Let me introduce the two of us. He is Alex. I am Happy."
20:17:16 <EvilTerran> such that forall s in S. x*s = s*x = x
20:17:37 <EvilTerran> and forall s, t, u in S. s*(t*u) = (s*t)*u
20:17:47 <mrd> monochrom: are you two in a relationship?
20:17:59 <EvilTerran> fadec, indeed
20:18:24 <EvilTerran> in haskell, a Monoid is an instance of the Monoid class
20:18:26 <EvilTerran> @src Monoid
20:18:26 <lambdabot> class Monoid a where
20:18:26 <lambdabot>     mempty  :: a
20:18:26 <lambdabot>     mappend :: a -> a -> a
20:18:26 <lambdabot>     mconcat :: [a] -> a
20:18:36 <mrd> sadly, there can only be one instance per type
20:18:54 <EvilTerran> which should hopefully satisfy the equivalent properties
20:18:59 * mrd jeers at the haskell typeclass system
20:20:11 <EvilTerran> ie, (mempty `mappend`) = (`mappend` mempty) = id
20:20:23 <BMeph> mrd: Thus, the ZipList kludge?
20:20:40 <EvilTerran> and forall (x, y, z :: a). (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
20:20:48 <fadec> EvilTerran: This is awesome stuff. Thanks.
20:20:58 <EvilTerran> but also that mconcat = foldr mappend mempty
20:21:17 <mrd> BMeph: in what way
20:21:20 <EvilTerran> (mconcat is included in the typeclass so you can redefine it more efficintly if you want to)
20:23:24 <wy> What's wrong with my configuration. when I try to configure happy. I got the error: Couldn't match expected type `Distribution.Verbosity.Verbosity'
20:23:24 <wy> against inferred type `Distribution.Simple.Setup.Flag
20:23:24 <wy>  Distribution.Verbosity.Verbosity'
20:24:23 <Zao> wy: Too old cabal maybe?
20:25:00 <wy> Zao: I think it's the one with 6.9
20:25:12 <fadec> EvilTerran: the type of mconcat looks like that for join
20:25:27 <EvilTerran> do you mean concat?
20:25:32 <EvilTerran> ?type join
20:25:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:25:35 <EvilTerran> ?type concat
20:25:35 <lambdabot> forall a. [[a]] -> [a]
20:25:39 <fadec> :t join
20:25:39 <wy> ddarius: I think subtyping isn't a problem. Since you can create your set of classes like class (Show a, Num a, Eq a) => MyClass a
20:25:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:25:48 <EvilTerran> ?type msum
20:25:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
20:25:54 <dibblego> ?check \xs -> join xs == concat (xs :: [[Int]])
20:25:56 <lambdabot>  OK, passed 500 tests.
20:26:11 <fadec> :t concat
20:26:12 <lambdabot> forall a. [[a]] -> [a]
20:26:58 <oerjan> :t Data.Foldable.fold
20:26:59 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
20:27:01 <fadec> > join [[1],[2]]
20:27:01 <lambdabot>  [1,2]
20:27:09 <fadec> > concat [[1],[2]]
20:27:10 <lambdabot>  [1,2]
20:27:29 <wy> Zao: Maybe I have a too new Cabal
20:27:43 <oerjan> > Data.Foldable.fold [[1],[2]]
20:27:43 <lambdabot>  [1,2]
20:27:46 <dibblego> fadec, that's what lambdabot did (with 500 different values)
20:27:50 <oerjan> > mconcat [[1],[2]]
20:27:51 <lambdabot>  [1,2]
20:29:06 <fadec> dibblego: missed that. nice.
20:29:47 <dibblego> ?check \xs -> join xs == mconcat xs == Data.Foldable.fold xs == concat (xs :: [[Int]])
20:29:47 <lambdabot>   Not in scope: `Data.Foldable.fold'
20:29:52 <ddarius> wy: Subtyping is orthogonal to that.
20:30:24 <dibblego> ?check \xs -> join xs == mconcat xs == concat (xs :: [[Int]])
20:30:24 <lambdabot>      precedence parsing error         cannot mix `(==)' [infix 4] and `(==)' ...
20:30:41 <dibblego> bleh
20:31:17 <oerjan> ?check \xs -> 1 == (length . nub . sequence) [join, mconcat, Data.Foldable.Fold, concat] (xs :: [[Int]])
20:31:17 <lambdabot>   Not in scope: data constructor `Data.Foldable.Fold'
20:31:25 <oerjan> ?check \xs -> 1 == (length . nub . sequence) [join, mconcat, Data.Foldable.fold, concat] (xs :: [[Int]])
20:31:26 <lambdabot>   Not in scope: `Data.Foldable.fold'
20:31:35 <oerjan> what the?
20:31:53 <oerjan> > Data.Foldable.fold
20:31:54 <lambdabot>  Add a type signature
20:32:00 <oerjan> :t Data.Foldable.fold
20:32:01 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
20:32:18 <wy> ddarius: If your type Foo inherit the classes {A,B,C}, you just make them a set and let type Bar instancing this set?
20:32:26 <oerjan> ?check \xs -> 1 == (length . nub . sequence) [join, mconcat, concat] (xs :: [[Int]])
20:32:27 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Int'
20:32:45 <wy> ddarius: That's not convenient though
20:33:02 <oerjan> ?check \xs -> 1 == (length . nub) (sequence [join, mconcat, concat] (xs :: [[Int]]))
20:33:03 <lambdabot>  OK, passed 500 tests.
20:33:07 <ddarius> wy: Types in Haskell don't inherit classes.  Furthermore, I defined subtyping as the implicit insertion of coercions.  This has absolutely nothing to do with that.
20:33:24 <wy> ddarius: I should use the word "instancing"
20:34:38 <wy> ddarius: Oh. You hit the same problem I'm getting ;-)
20:35:11 <mrd> type subsumption
20:35:18 <wy> ddarius: So the problem isn't really subtyping, but coersion
20:35:43 <ddarius> wy: Subtyping is the implicit insertion of coercions.  Defining the coercions is easy enough.
20:36:04 <wy> ddarius: I don't like coersions
20:36:46 * LoganCapaldo coerces wy to like coercion
20:36:57 <ddarius> wy: The "coercions" are not like casts, they are merely functions.  For example, (A,B) <: A.  The coercion is just projection, not some kind of cast.
20:38:40 <wy> ddarius: I think the problem is inherited from HM system
20:38:56 <ddarius> wy: What problem?
20:38:57 <wy> ddarius: I really want it to be solved!
20:39:17 <wy> ddarius: The problem is that classes are not types
20:39:55 <wy> ddarius: They should take the place of "types" in the system
20:40:44 <wy> ddarius: Have you noticed that classes are only playing a secondary role, although they are so useful?
20:40:48 <ddarius> wy: They shouldn't be types.  The word "classes" in "type classes" is more like how the word "class" is used in set theory.  A type class is (obviously) just a (name for a) collection of types, or equivalently, a predicate on types.
20:42:31 <wy> ddarius: I think in the reversed way. I think a type is just a collection of classes
20:43:00 <ddarius> wy: Again, just because you think differently doesn't make it so.
20:43:56 <wy> ddarius: Types are defined by the operations that operate on them, and classes are collections of those operations. Classes are not collections of types, but a collection of operations
20:44:34 <ddarius> wy: The operations that operate on a type don't need to be in a type class.
20:47:48 <ddarius> (Incidentally, type classes are an extension of the Hindley-Milner type system.)
20:48:20 <BMeph> wy: For example, join isn't in a type class (although it really ought to be in functor, at least).
20:48:31 <Saizan> Functor?
20:48:56 <BMeph> s/functor/Functor -- Yes, thanks, Saizan. :)
20:49:12 <wy> :t join
20:49:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:49:14 <ddarius> join quite definitely should not be in Functor.
20:49:17 <sjanssen> BMeph: no, it shouldn't be in Functor, it should be in Monad
20:49:17 <Saizan> no i meant that join is quite distinctive for monad.
20:49:25 <ddarius> Maybe you meant Monad?
20:49:51 <Saizan> even applicative functors lack join
20:50:34 <Saizan> that's the point of them, afaiu
20:51:28 <BMeph> Mmm, I stand corrected.
20:52:26 <bos> http://programming.reddit.com/info/64qf4/comments/
20:53:13 <bos> since lambdabot seems to be dead, "Phil Wadler to give public talk next week in San Francisco"
20:53:13 <Saizan> ?bot
20:53:14 <lambdabot> :)
20:57:12 <LoganCapaldo> if only i were in san francisco next week
20:58:39 <wy> any good reference to hybrid types and gradual types?
21:00:25 <ddarius> A distribute law in a 2-category C is a monad on the 2-category of monads on C...
21:00:45 <ddarius> s/distribute/distributive
21:02:05 <wy> Is there a video record for his talk?
21:03:12 <bos> wy: we'll record it if we can
21:03:14 <mrd> lambdabot is wisely avoiding reddit
21:03:29 <wy> bos: Thanks!
21:03:49 <MyCatVerbs> mrd: reminds me of the instant productivity booster: sudo echo "programming.reddit.com 127.0.0.1" >> /etc/hosts
21:07:51 <Cale> ddarius: Watching Catsters videos?
21:08:08 <ddarius> Cale: Yes.  There was a whole bunch more when I came back from leave.
21:08:42 <Cale> ddarius: Yeah, I'm really enjoying the recent bunch. The ones on spans and multicategories were especially fun.
21:10:32 <wy> gradual typing is something I'm thinking recently
21:10:40 <wy> what a coincide...
21:12:12 <ddarius> Cale: Haven't gotten to those yet.  Spans will be coming up next.  Does she have the note that a (small) category is a monad in the bicategory of spans of sets?
21:12:57 <Cale> yes
21:13:38 <Cale> and that definition lets you generalise the definition of a category in various interesting ways
21:14:27 <wy> Cale: Where is the video?
21:14:37 <Cale> by changing to monadic spans, where instead of A <- S -> B, you have something like TA <- S -> B, where T is some chosen monad.
21:15:01 <Cale> wy: http://uk.youtube.com/profile_play_list?user=TheCatsters
21:15:01 <lambdabot> Title: YouTube - Broadcast Yourself.
21:15:19 <Cale> (the multicategories playlist, in particular)
21:16:13 <ddarius> Yeah, that's one of the usual ways to arrive at multicategories.
21:16:17 <Cale> When T is the free monoid monad, you get that the monads in the category of T-spans are multicategories.
21:16:57 <ricky_clarkson> Ok, I'll come back later.
21:17:07 <Cale> ricky_clarkson: what's up?
21:17:56 <ricky_clarkson> Nothing, I just popped in and saw your last line, and realised that the only words of it I understood were those like "you", "get" and "that" ;)
21:18:01 <Saizan> so monads are quite a central concept in CT?
21:18:30 <Cale> Saizan: Yeah, they're a fairly key construction, I'd say.
21:18:42 <ddarius> The first name for monads was "standard construction".
21:19:09 <ddarius> Saizan: They aren't so much "central" (though they are rather close to the center) as "basic".
21:20:06 <Saizan> ah, i see
21:20:16 <ddarius> And monads do a good job of capturing and generalizing the notion of "algebraic structure", so a) they are very common (there are lots of algebraic structures) and b) a category is an algebraic structure so they are rather incestuous.
21:22:35 <ddarius> The Yoneda lemma is similar.  It's important, but also so basic that I, personally, use it's corollary tacitly.
21:28:13 <Saizan> so it's like limits in calculus :)
21:30:48 <Cale> I wonder if there's a category D such that for any small category C, there is a fully faithful functor h: C -> D^C.
21:32:21 <Cale> (Yoneda's lemma gives a fully faithful functor h: C^op -> Set^C.)
21:38:17 <ddarius> Well, if we take D = CxC, then we have h = Curry Id : C -> (CxC)^C.  Curry Id is the unit of an adjunction...  I'm not sure if this leads somewhere.
21:39:02 <ddarius> @. djinn type curry id
21:39:03 <lambdabot> f a b = (a, b)
21:58:23 <scook0> @src void
21:58:23 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:59:11 <augustss> sadly there is no Void and no void
21:59:52 <dons> i think it would be an fairly easy proposal to libraries@ though
22:01:00 <augustss> yes
22:01:28 <augustss> I wonder if empty data declarations are gonna be in Haskell'?
22:01:42 <dons> i'd reckon so.
22:01:50 <dons> pretty uncontroversial
22:02:16 <augustss> it wasn't when i suggested it 10 years ago :)
22:02:57 <augustss> but now i use it almost daily
22:03:37 <ddarius> augustss: What was the controversy then?  It seems harmless why avoiding a special case.
22:03:44 <dons> i'll have to dig up the discussions from the 90s. i find it hard now to think it would be controversial!
22:03:50 <augustss> people said it was useless
22:04:00 <dons> i guess type programming was much less accepted
22:04:08 <augustss> yes
22:04:44 <dons> i remember the buzz around type programming in the 2004 HW, so i guess it is a real sea change in thinking
22:05:36 <ddarius> The papers on e.g. "simulating dependent types" and such hadn't been written in the very early 90's.  I think they were written in the late 90's.
22:05:36 <Saizan> when will we get true second-order type classes then?
22:05:47 <dons> and now the language is getting optimised for type programming
22:06:17 <augustss> yes, it's interesting how it has shifted
22:06:21 <dons> Saizan: i think class-associated classes or something like them are proposed for the type families. at least Manuel and Martin S. have talked about them
22:07:02 <ramza3> should I use "Data.Binary" if I need to write shorts and bytes or possibly 64 values to a socket connection or use something more in the core library
22:07:07 <dons> augustss: some community-wide realisation that a key strength is enforcing correctness statically, and the consequences of that are more type power
22:07:16 <Saizan> dons: yes, i saw them, not quite the same afaiu
22:07:32 <dons> i remember SPJ noting that originally the comittee didn't realise how important type annotatoins would be
22:07:41 <dons> and now we have kind annotation proposals :)
22:07:51 <ddarius> Phantom types have a pretty long history.
22:08:00 <dons> ramza3: that would be doable with Data.Binary
22:08:04 <dons> it would be my first choice
22:08:07 <ddarius> Perhaps not so much pre-Haskell 1.0, but certainly early on.
22:08:38 <dons> there's an interesting paper waiting to be written about the history of type-level programming
22:08:41 <ramza3> dons: ok, I would just use "encode" and use it through the socket handle
22:09:01 <dons> ramza3: or just the Put monad directly to build the bytestring to write
22:11:02 <scook0> :t fromIntegral
22:11:03 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:16:26 <Corun> "forever" is in the prelude or Control.Monad? Right?
22:16:31 <Corun> >:t forever
22:17:03 <ricky_clarkson> :t forever
22:17:03 <lambdabot> Not in scope: `forever'
22:17:07 <ricky_clarkson> Do you mean repeat?
22:17:24 <sclv> ?hoogle forever
22:17:25 <Corun> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3Aforever
22:17:25 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
22:17:25 <lambdabot> http://tinyurl.com/y25qsm
22:17:26 <sjanssen> Corun: it is in recent versions of Control.Monad
22:17:33 <Corun> forever :: Monad m => m a -> m ()
22:17:59 <Corun> Oh, is it a recent addition... I guess maybe my ghc is too old then
22:22:49 <dons> it should really be a m a -> m a though :)
22:23:50 <Saizan> m a -> m b then..
22:23:58 <ricky_clarkson> > Control.Monad.forever (Maybe "hello")
22:23:58 <lambdabot>   Not in scope: data constructor `Maybe'
22:24:06 <ricky_clarkson> > Control.Monad.forever (Just "hello")
22:24:06 <lambdabot>   Not in scope: `Control.Monad.forever'
22:25:15 <Saizan> it's _|_ however
22:25:28 <augustss> Yes, m() return type is wrong
22:25:37 <augustss> what is _|_?
22:25:56 <Saizan> forever (Just "hello") ?
22:27:13 <augustss> forever Nothing isn't
22:27:24 <dons> right.
22:27:54 <dons> ?let forever :: Monad m => m a -> m a ; forever a = a >> forever a
22:27:56 <lambdabot> Defined.
22:28:00 <dons> > forever Nothing
22:28:01 <lambdabot>  Nothing
22:28:10 <dons> > forever (Just 'x')
22:28:16 <lambdabot> Terminated
22:28:31 <dons> quite useful, when fail breaks out
22:28:53 <ddarius> :t fix (<<)
22:28:54 <lambdabot> Not in scope: `<<'
22:29:03 <augustss> I've now havled Bryan's LLVM bindings beyond recognition :)
22:29:11 <augustss> hacked even
22:29:26 <dons> yay
22:29:48 <sclv> ?ty fix (flip (>>))
22:29:48 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
22:29:48 <lambdabot>     Probable cause: `flip' is applied to too few arguments
22:29:48 <lambdabot>     In the first argument of `fix', namely `(flip (>>))'
22:29:56 <sclv> ?ty fix (>>)
22:29:57 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
22:29:57 <lambdabot>     Probable cause: `>>' is applied to too few arguments
22:29:57 <lambdabot>     In the first argument of `fix', namely `(>>)'
22:30:17 <Saizan> ?ty \a -> fix (a >>)
22:30:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:30:35 <augustss> LLVM is pretty cool
22:33:50 <dons> oh, do we really want an arbitrary return type?
22:34:09 <ddarius> dons: It doesn't really hurt.
22:34:38 <ddarius> Or does it?
22:34:40 <dons> i just sent a proposal for m a -> m a. but m b fits with with things like 'const' i guess.
22:35:06 <ddarius> :t \a -> fix (a >>)
22:35:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:35:11 <dons> ?undefine
22:35:12 <lambdabot> Undefined.
22:35:15 <ddarius> That's the type it should be.
22:35:18 <sjw> can you construct an example where a =/ b?
22:35:20 <dons> ?let forever :: Monad m => m a -> m b ; forever a = a >> forever a
22:35:20 <lambdabot> Defined.
22:35:43 <dons> > forever (Just 'x')
22:35:50 <lambdabot> Terminated
22:35:56 <Saizan> > forever (Nothing::Maybe Int) :: Maybe Double -- it's not the same Nothing
22:35:57 <lambdabot>  Nothing
22:36:02 <dons> yeah.
22:36:05 <dons> weird..
22:36:08 <sjw> :t \x -> forever (Just x)
22:36:08 <lambdabot> Not in scope: `forever'
22:36:22 <sjw> ?ty \x -> forever (Just x)
22:36:22 <lambdabot> Not in scope: `forever'
22:36:43 <Saizan>  @let-ed functions are not in scoper in ?ty
22:36:46 <dons> if anyone's got a good argument for the 'm b' result, (i.e. a useful program) can they add that to the thread on libraries@ ?
22:37:10 <augustss> My argument would be, why restrict it from the most general type?
22:37:11 <ddarius> What argument is there for a more restrictive type?
22:37:20 <dons> yeah.
22:37:44 <sjanssen> m a -> m b is nicer for backwards compatibility, even
22:37:57 <augustss> I don't see where that () came from at all
22:38:25 <augustss> because it's worse than b.  because it doesn't return a ()
22:39:01 <Saizan> ?type sequence_ . repeat
22:39:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
22:39:08 <dons> that's where it came from.
22:39:10 <Saizan> ?type sequence_ . repeat $ Nothing
22:39:11 <lambdabot> Maybe ()
22:39:14 <ddarius> The free type variables make it clear that the a's are ignored and any "result" is undefined.
22:39:22 <dons> repeatM_
22:39:37 <mrd> forever Nothing -- sounds more like a metaphysical statement than a Haskell program
22:40:42 <augustss> "forever Nothing is Nothing"  quite profound
22:40:55 <dons> good stuff
22:44:42 <dons> so what missing libraries do we need for 2008?
22:45:01 <dons> what could be provided, such that people could then use haskell for some task they've previously avoided
22:45:59 <Nafai> That's a good question!
22:46:23 <BMeph> Has all of Edison been duplicated in libraries, or should that be upgraded to 6.8.x, does anyone know?
22:46:43 <Nafai> What's Edison?
22:46:53 <dons> the faster AVL-based Maps seem like one (fairly) easy task
22:47:16 <BMeph> I'm specifically looking for priority queues, although they don't seem tough to re-do.
22:47:45 <dons> so they're in Edison
22:48:59 <augustss> BMeph: priority queues should be added to Data.Sequence (if it hasn't already happened)
22:49:43 <dons> i think there's a bunch of bytestring based networking and parsing things to be done
22:50:04 <dons> more web stuff
22:50:09 <BMeph> ausustss: "Should be" as in it's planned for later, or as in it would go there were they done later?
22:50:16 <augustss> I'd like to see a library for reading and writing binary data in specific formats
22:50:28 <augustss> where you can specify layout on the bit level
22:50:47 <sarah__> :t Monad
22:50:48 <lambdabot> Not in scope: data constructor `Monad'
22:51:10 <dons> yeah, bit level Data.Binary has been on the backburner since July
22:51:13 <augustss> BMeph: should be, as in it's an oversight that they are not there since the underlying data structure supports it
22:51:18 <dons> we know how to do it, based on the erlang stuff, too
22:51:43 <augustss> dons: and Data.Binary is also a bit of a pain when you want to control endianness
22:51:48 <BMeph> Excellent, augustss, thanks - on to the next project... ;)
22:51:51 <jfredett> :t (\(a,b) c -> (a c, b c))
22:51:52 <lambdabot> forall t t1 t2. (t -> t1, t -> t2) -> t -> (t1, t2)
22:52:02 <jfredett> is that an arrow of some kind?
22:52:07 <jfredett> @pl (\(a,b) c -> (a c, b c))
22:52:07 <lambdabot> uncurry (liftM2 (,))
22:52:29 <dons> augustss: yeah, not sure how best to deal with that, without different instances
22:52:37 <jfredett> well thats cool looking...
22:52:42 <dons> also, there's this strict-binary thing happening, so that might be a usecase we need to consider
22:52:58 <BMeph> Isn't that (&&&)?
22:53:05 <augustss> dons: I did it with new data types, LEWord16, etc
22:53:08 <ddarius> :t uncurry (&&&)
22:53:08 <jfredett> :t (&&&)
22:53:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
22:53:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:53:25 <dons> augustss: yeah. maybe that's useful enough to warrant support
22:53:28 <jfredett> right, and my arrow there is (->), right?
22:53:33 <augustss> dons: but Data.Binary doesn't export enough primitives to allow me to do it
22:53:50 <ddarius> jfredett: Yes.
22:53:50 <BMeph> Uncurried, good eye.
22:54:01 <jfredett> neat-
22:54:03 <dons> augustss: oh?
22:54:12 <dons> it has all the read and write primitives available, afaik
22:54:23 <augustss> dons: bot not exported
22:54:31 <jfredett> the things you run into when you write a graphviz formatter... :)
22:54:54 <dons> bot? "but" ?
22:54:58 <augustss> dons: I just added some exports and all was well
22:55:10 <augustss> s/bot/but/
22:55:12 <dons> oh hmm. oh, they're not re-exported from Data.Binary, only via Get and Put
22:55:17 <sjw> dons: the ELF stuff I did had the endianness in the type class
22:55:23 <sjw> somewhat annoying to deal with tho
22:55:39 <dons> sjw, yeah, it was for that reason we didn't put it in the standard interface
22:55:56 <dons> Endian a => Binary a , or what have you
22:56:38 <augustss> dons: now why you picked big endian is beyond me.  it's so unnatural
22:56:52 <dons> network order
22:57:13 <augustss> yeah, that is a semi-good reason
22:57:16 <dons> heh
22:58:13 <dons> it might be good to do an audit of the users of Data.Binary, to see what's being used for what
22:58:19 <dons> and then polish things up a bit in light of that.
22:58:42 <dons> and go over  the erlang support again
22:58:50 <augustss> yeah
23:01:35 <radetsky> dons: why did you use packAddress in hmp3?
23:03:37 <hpaste>  Corun pasted "(no title)" at http://hpaste.org/4846
23:03:44 <scook0> quick question: is cabal considered suitable as a build system for an in-development project?
23:03:51 <scook0> or is there something else I should be using?
23:04:03 <Corun> I'd just like to ask, is that "The Right Way" to write an echoing server?
23:04:05 <Lemmih> scook0: Yes.
23:04:16 <scook0> cool
23:04:52 <radetsky> does anyone know?
23:05:25 <Lemmih> radetsky: funroll-loops, I think.
23:05:40 <scook0> in that case, is there an easy way to get ghci to use cabal's .o files if they exist, or my regular source files if they don't?
23:08:11 <dons> radetsky: oh, just to play with it :)
23:09:20 <radetsky> dons: ok. I was trying to build it. I'm replacing it with pack/[Word8]'s
23:09:33 <dons> radetsky: are you using the one from hackage?
23:09:42 <dons> it's all updated and buildable. you shouldn't have to fix anything
23:10:12 <radetsky> I just darcs got it
23:10:20 <dons> hmm.
23:10:34 <dons> i updated this a few weeks ago
23:10:42 <dons> hmm. maybe not.
23:10:53 <radetsky> I don't have pre-base-split libraries
23:11:01 <ddarius> Corun: Your code looks fine, though it could be mildly simplified by using some higher order functions.
23:11:21 <dons> so looks like its been updated to 1.3.1
23:11:40 <dons> but hasn't been updated for the changes to bytestring (pack got moved into Data.ByteString.UnsafE)
23:11:41 <Corun> Well, I was going to use "forever", but it appears my GHC is lacking it.
23:11:51 <Corun> What others could I use?
23:11:55 <dons> Corun: its easy to define it locally
23:12:10 <Corun> Well, yeah. It's easy to just recurse, too :-P
23:14:16 <hpaste>  dancor pasted "happs-begin-0.9.1 compile error" at http://hpaste.org/4847
23:22:55 <Corun> So, with forever...: http://hpaste.org/4848
23:23:00 <Corun> Nice'n'short :-)
23:26:21 <hpaste>  dancor pasted "happs-0.9.1: how do i use my state" at http://hpaste.org/4849
23:29:54 <ddarius> Corun: \e -> print e is the same as print
23:30:18 <Corun> Hehe, right you are
23:32:20 <Corun> I guess I probably thought my exception handler was gonna do a bit more than that, originally :-)
23:35:14 <radetsky> can copy . packCString replace copyCString?
23:35:16 <BMeph> Also, shouldn't "forkIO $ handle" just be "forkIO h"?
23:35:32 <radetsky> oh, wait, nm
23:35:46 <radetsky> copy . unsafePerformIO . packCString
23:35:55 <radetsky> that looks bad
23:36:12 <Corun> Oh, heh, that paste doesn't actually work any more. I didn't test it ^_^
23:36:14 * Corun fixes
23:36:48 <Corun> Er, handle is a function in Control.Exception
23:37:02 <aleator> Hey. I need to measure approximate execution time of a function. What is simplest way to do this?
23:37:17 <radetsky> aleator: stopwatch
23:37:35 <aleator> radetsky: How about little less approximate :)
23:37:50 <radetsky> oh, sorry, I don't know
23:37:59 <Corun> If you do it in ghci you can do:   :set +s
23:38:00 <BMeph> I should just try something semi-useful myself first. :)
23:38:14 <Corun> And then anything you do in ghci after that it will time for you
23:38:33 <aleator> Well, that is the problem. It is fast enough to be faster than outputting to the result.
23:39:47 <Korollary> ghc has a profiler
23:42:21 <aleator> Korollary: Yes. but perhaps I should reformulate the question: Is there a general way of forcing a function with little overhead, so that it's execution time can be measured?
23:43:00 <Korollary> aleator: It depends on how strict the function is. seq, deepseq?
23:47:40 <aleator> Korollary: hmm.
23:52:44 <aleator> Also, it seems that I need to jump hoops so that ghc does not optimize repetition away.
23:58:17 <BMeph> Well, thanks for the enlightening coding, and conversation - time to get some sleep before work.
