00:00:08 <faxathisia> @@ @pl @djinn ((a, b) -> c) -> (d -> e -> f) -> ((a -> b -> c),  -> ((e, f) -> g))
00:00:08 <lambdabot>  Cannot parse command
00:00:16 <faxathisia> oops...
00:00:44 <ac> I think it would be quite ammusing to run an entire program through the pointless translator
00:01:10 <jsnx> happy new year, west coast haskellers!
00:01:29 * jsnx smokes a bowl
00:01:33 <EuphoriaSalad> ac: good code obfuscator ;)
00:01:35 <faxathisia> @@ @pl @djinn ((a, b) -> c, x -> y -> z) -> (a -> b -> c, (x, y) -> z)
00:01:35 <lambdabot>  f = ((. (,)) . (.)) *** flip (ap . (. fst)) snd
00:01:39 <ac> EuphoriaSalad: exactly
00:01:47 <faxathisia> damn :(
00:02:02 <jsnx> :t ***
00:02:03 <lambdabot> parse error on input `***'
00:02:04 <faxathisia> I guess pl doens't know about curry and uncurry
00:02:09 <jsnx> :t (***)
00:02:10 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:02:14 <faxathisia> :t curry *** uncurry
00:02:15 <lambdabot> forall a b c a1 b1 c1. ((a, b) -> c, a1 -> b1 -> c1) -> (a -> b -> c, (a1, b1) -> c1)
00:02:28 <EuphoriaSalad> O_o
00:02:38 <ac> jsnx: where on the west coast are you?
00:02:43 <faxathisia> :t (reverse ** tail) ("flasdf", "blorrr")
00:02:44 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(a1, b)'
00:02:44 <lambdabot>     In the first argument of `(reverse ** tail)', namely
00:02:44 <lambdabot>         `("flasdf", "blorrr")'
00:02:48 <jsnx> ac: San Francisco
00:02:57 <ac> jsnx: Seattle :)
00:03:04 <jsnx> ac: if it were SoCal, i guess i'd do E instead
00:03:11 <faxathisia> > (reverse *** tail) ("flasdf", "blorrr")
00:03:12 <lambdabot>  ("fdsalf","lorrr")
00:03:13 <EuphoriaSalad> 9am here :)
00:03:23 <jsnx> EuphoriaSalad: you are in germany, maybe?
00:03:33 <EuphoriaSalad> but OTOH I woke up at noon or so
00:03:35 <EuphoriaSalad> jsnx: yes
00:03:53 <EuphoriaSalad> jsnx: though most of central europe is in the same zone
00:04:08 <jsnx> EuphoriaSalad: well, france is not, right?
00:04:14 <EuphoriaSalad> hmm think it is
00:04:17 <jsnx> EuphoriaSalad: and much of england is an hour before
00:04:22 <EuphoriaSalad> yes
00:04:26 <EuphoriaSalad> GMT is one less
00:04:30 <jsnx> right
00:04:49 <jsnx> i have one clock for PST, one for UTC
00:04:49 <allbery_b> France is CET
00:05:20 * allbery_b uses the awesome power of TZ=... date
00:05:39 <EuphoriaSalad> even spain is CET
00:05:46 <EuphoriaSalad> according to kworldclock
00:06:23 <jsnx> that's interesting
00:06:33 <jsnx> makes sense, honestly
00:06:55 <jsnx> we should just put the whole world on UTC
00:07:07 <jsnx> and talk about how high the sun is
00:07:14 <EuphoriaSalad> probably a bit large, but I guess the advantages outweigh the differences of sunrise/sunset
00:07:26 <EuphoriaSalad> (talking about CET here)
00:07:41 <EuphoriaSalad> jsnx: hmm wouldn't that be equivalent
00:07:46 * allbery_b wonders how long before the EC institutes a single european time zone :)
00:07:48 <jsnx> EuphoriaSalad: well, no
00:07:55 <EuphoriaSalad> you'd have to remember sun shifts instead of time shifts
00:08:06 <jsnx> because you and spain are in the same time zone
00:08:14 <allbery_b> (that'd be really fun for some of the outlying members)
00:08:15 <jsnx> but the sun is in very different places
00:08:38 <EuphoriaSalad> yeah but sun shifts would prolly be put into zones too
00:08:53 <EuphoriaSalad> though they wouldn't be formal
00:09:03 <jsnx> EuphoriaSalad: well, that's a problem
00:09:15 <allbery_b> I'm not sure it matters that much
00:09:18 <EuphoriaSalad> hehe
00:09:43 <allbery_b> heck, I've lived in the US Eastern time zone all my life but in a sane world the places I've lived would be in Central
00:09:46 <jsnx> well, i suppose i shouldn't get all excited
00:10:08 <EuphoriaSalad> 28 hour day is way more important
00:10:09 <ac> </2007><2008>
00:10:15 <allbery_b> "noon" generally has little to do with the sun's position in Pittsburgh or Cleveland :)
00:10:18 <johnnowak> mm, 28 hour day.
00:10:21 <jsnx> i'm just saying, if you want to know whether it's light or dark in another country, the official time doesn't correlate well
00:10:44 <jsnx> whereas sun height, in radians, would
00:10:50 <allbery_b> (and let's not get started on "daylight savings time" that is now around 75% of the year...)
00:11:00 <jsnx> allbery_b: yeah, that is awful
00:11:04 <jsnx> UTC for the win
00:11:05 <EuphoriaSalad> hmm, sun height also depends on latitude
00:11:19 <jsnx> EuphoriaSalad: yes, but it still correlates well with daylight
00:11:24 <EuphoriaSalad> you should use the horizonzal direction of the sun, I think that doesn't depend on lat
00:11:33 <EuphoriaSalad> or does it
00:11:43 <jsnx> if the sun is not in the sky, it's dark
00:11:57 <jsnx> whereas what does it mean that it's 0630 ?
00:11:58 <EuphoriaSalad> allbery_b: as a nightowl that's fine with me
00:12:00 <allbery_b> EuphoriaSalad: it does, but it's not too significant below 60 degrees
00:12:06 <jsnx> in SF, it's still dark at 0630
00:12:17 <allbery_b> above, things get interesting
00:12:26 * EuphoriaSalad is bad at such geometry
00:12:50 <jsnx> anyways, if i am ever the boss of a company, i'm going to put it on UTC
00:12:56 <allbery_b> consider daylight at the poles
00:12:58 <jsnx> schedule all events, everything
00:13:05 <jsnx> in UTC
00:13:13 <allbery_b> your employees will hate you
00:13:28 <jsnx> allbery_b: well, it will be part of the interview
00:13:30 <dibblego> only those that can't add
00:13:40 <jsnx> allbery_b: people who think it's cool will get hired
00:13:40 <dibblego> and they should be filtered first
00:13:55 <jsnx> 'cuz it shows they are true nerds
00:14:07 <EuphoriaSalad> hmm, what's special about the horizontal direction of the sun, at the poles
00:14:10 <dibblego> when I worked for IBM, we had to schedule calls to the US; the daylight savings here and there was annoying as hell
00:14:11 <jsnx> and truly believe in the ISOs
00:14:12 <allbery_b> I can add.  doesn't mean I want to have to translate when fitting company events into my personal scheduling
00:14:44 <EuphoriaSalad> oh duh, it is constant
00:14:46 <allbery_b> as for companies composed only of geeks/nerds, I suspect that's a recipe for going down in flames :)
00:14:49 <EuphoriaSalad> no wait, it isnt
00:15:00 <jsnx> allbery_b: it will be a small company
00:15:13 <dibblego> EuphoriaSalad, it's not there near or it's always there, at the solstices
00:15:18 <allbery_b> what direction is "not visible"?
00:15:43 <EuphoriaSalad> dibblego: yes I know that, but the point was whether the horizontal direction of the sun depends on latitude
00:16:19 <EuphoriaSalad> allbery_b: I was thinking about the projection of the pointing-to-sun vector to the tangent space of the sphere through you
00:16:42 <nachos> @haskell is too smart for me
00:16:43 <lambdabot> Unknown command, try @list
00:16:51 <jsnx> lolz
00:16:51 <EuphoriaSalad> well, tangent plane. not sure how to do this with abstract tangent spaces
00:17:19 <allbery_b> more seriously:  there is shift.  the shift due to latitude per se is small because the other leg of the triangle is some 93 million miles :)
00:17:23 <tehgeekmeister> is there any way to convert a float to an int?
00:17:30 <allbery_b> the one due to the earth's inclination is more significant
00:17:42 <nachos> tehgeekmeister: i would assume so, but losing precision along the way.
00:17:44 <allbery_b> tehgeekneisert:  truncate, ceiling, round
00:17:44 <dibblego> ?hoogle (Fractional a, Integral b) => a -> b
00:17:45 <jsnx> tehgeekmeister: floor, ceiling, truncate
00:17:45 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
00:17:45 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
00:17:45 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
00:18:12 <allbery_b> :t ceiling
00:18:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:18:21 <jsnx> maybe truncate *is* floor...
00:18:29 <faxathisia> @src truncate
00:18:29 <lambdabot> Source not found. :(
00:18:30 <allbery_b> I thinkoed there
00:18:32 <faxathisia> @src floor
00:18:32 <lambdabot> Source not found. You speak an infinite deal of nothing
00:18:34 <allbery_b> celing, truncate, round
00:18:48 <allbery_b> is what I meant to say.  dammit, ought to be in bed, brain is fading
00:18:59 <allbery_b> ceiling, even
00:19:05 <jsnx> lolz
00:19:21 <jsnx> allbery_b: you were right, it was me who had it off
00:19:44 <jsnx> though i guess, strictly speaking, a truncate and a floor do not do the same thing for negative numbers
00:20:21 <jsnx> yeah, they are different
00:20:28 <allbery_b> @hoogle (RealFrac a, Integral b) => a -> b
00:20:28 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
00:20:28 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
00:20:28 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
00:20:34 <mxc> is there a way to see all the members of a module in the ghc toplevel?
00:20:37 <EuphoriaSalad> allbery_b: mine wrapped around already O_o
00:20:38 <jsnx> > truncate (-2.3)
00:20:38 <allbery_b> @hoogle+ (RealFrac a, Integral b) => a -> b
00:20:39 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
00:20:39 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
00:20:39 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
00:20:39 <lambdabot>  -2
00:20:44 <mxc> something like doing module M  = List in ocaml
00:20:47 <allbery_b> weird
00:20:47 <jsnx> > floor (-2.3)
00:20:48 <lambdabot>  -3
00:21:08 <allbery_b> mxc: ghci has :browse
00:21:13 <mxc> ty
00:21:20 <jsnx> so, you see truncate just clips the lower order bits...
00:21:50 <allbery_b> haskell doesn't have introspection, so there's no programmatic way to do it without playing weird games (and maybe not even then, I think someone recently failed to do it with Template Haskell)
00:22:10 <BMeph> mxc: Also, you can use :info
00:23:03 <EuphoriaSalad> Int to Double 4 me plz?
00:23:17 <allbery_b> :t fromIntegral
00:23:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:23:29 <EuphoriaSalad> ah, I only knew fromInteger
00:23:43 <allbery_b> fromInteger is sort of deprecated, I think
00:24:06 <nachos> hai der, can sum1 explain pointers to me?
00:24:26 <allbery_b> haskell doesn't have them.  the end.  :)
00:24:33 <EuphoriaSalad> > sum [1]
00:24:33 <lambdabot>  1
00:25:51 <LunarCrisis> ghc is a beast to compile O_O
00:26:11 <EuphoriaSalad> hmm I guess that since haskell is purely functional, issues like copy a pointer vs. deep copy don't even arise
00:26:27 <EuphoriaSalad> (which is great :))
00:28:03 <allbery_b> well, except that everything behaves rather like a deep copy, which can be an issue for naive code
00:29:36 <EuphoriaSalad> allbery_b: that's why I did this ReaderMonad thingy for my primelist
00:30:19 <EuphoriaSalad> (I hope that leads to efficient passing around of the list)
00:33:22 <jsnx> DiffArray averts a deep copy, at the cost of slow lookups for the older versions of the array
00:33:26 <jsnx> kind of neat, actually
00:33:28 <allbery_b> it should be as efficient as doing it manually, or maybe slightly less so because of the monadic machinery
00:34:10 <allbery_b> the problem arises not when you pass it around but when you change it; if it's static, it doesn't really matter if you pass it explicitly or via Reader or via State, etc.
00:35:40 <allbery_b> (basically:  if you don't change it it's a pointer, if you do it's a deepcopy.  ignoring things like DIffArray which are nice ideas in theory but have problems in practice; DiffArray's actual performance kinda sucks)
00:37:28 <EuphoriaSalad> allbery_b: I meant ReaderMonad as opposed to the /bad/ method of calling the prime list generator function whenever primes are needed :)
00:37:48 <faxathisia> Why is that bad?
00:37:57 <EuphoriaSalad> slow, unless it's cached
00:38:02 <faxathisia> If you have primes = <something which isn't a function>, It should be memoized
00:38:04 <allbery_b> regenerating a new list of primes every time you need it?
00:38:13 <allbery_b> ah
00:38:21 <faxathisia> so you can self reference in there without recalculation
00:38:24 <EuphoriaSalad> faxathisia: but I don't want a global variable because the caller should be able to set the primelimit
00:38:33 <faxathisia> why have a limit?
00:38:39 <EuphoriaSalad> erm ;)
00:39:01 <EuphoriaSalad> sieve of eratosthenes only works with a limit AFAIK
00:39:14 <faxathisia> should work for unbounded
00:39:21 <EuphoriaSalad> how?
00:39:35 <EuphoriaSalad> you iterate until sqrt(n)...
00:39:40 <EuphoriaSalad> where n is set in advance
00:39:51 <allbery_b> there's a fairly big wiki page dedicated to prime generation
00:39:59 <allbery_b> including sieve of eratosthenes
00:40:08 <faxathisia> that is an optimization I don't think is part of seive
00:40:14 <faxathisia> wasn't the sieve just
00:40:21 <faxathisia> cross out every multiple of two, three.. so on
00:40:25 <allbery_b> @gwiki sieve of eratosthenes
00:40:26 <lambdabot> No Result Found.
00:40:29 <allbery_b> hm
00:40:59 <EuphoriaSalad> faxathisia: but it's way more efficient to cross out every multiple on two, then the next remaining number is the next prime, and so on
00:41:03 <thoughtpolice> > let sieve (y:xs) = y : [ x | x <- xs, x `mod` p /= 0] in sieve [2..]
00:41:04 <lambdabot>   Not in scope: `p'
00:41:12 <thoughtpolice> > let sieve (y:xs) = y : [ x | x <- xs, x `mod` y /= 0] in sieve [2..]
00:41:13 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
00:41:37 <allbery_b> @wiki Prime_numbers
00:41:37 <lambdabot> http://www.haskell.org/haskellwiki/Prime_numbers
00:41:46 <jsnx> there is a great paper on this
00:41:51 * jsnx rummages
00:41:52 <allbery_b> except nobody added that long thread from -cafe into that page :(
00:41:55 <EuphoriaSalad> thoughtpolice: wow *trying to parse*
00:41:59 <allbery_b> I thought they were going to
00:42:17 * faxathisia thinks 9 isn't prime
00:42:23 <thoughtpolice> hm yeah
00:42:33 <EuphoriaSalad> 15 neither
00:42:47 <thoughtpolice> oh no wonder
00:42:54 <thoughtpolice> > let sieve (y:xs) = y : sieve [ x | x <- xs, x `mod` y /= 0] in sieve [2..]
00:42:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:42:55 <jsnx> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
00:42:58 <thoughtpolice> there ya go
00:43:18 <BMeph> I like oerjan's generator. It's got to be inefficient, but it's elegant-looking:
00:43:29 <BMeph> > nubBy (((>1).).gcd) [2..]
00:43:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:43:40 <faxathisia> Is it inefficient?
00:44:35 <faxathisia> I have really not much intuition for complexity around lazyness
00:44:35 <allbery_b> nubBy has the same O as nub, doens't it?
00:44:58 <BMeph> Yes, it does - n^2, isn't it?
00:45:01 <EuphoriaSalad> faxathisia: yeah. but thoughtpolice's algo does look like it only crosses out multiple of primes, in that sense it's efficient
00:45:06 <allbery_b> yeh
00:45:17 <faxathisia> EuphoriaSalad: and it's unbounded
00:45:32 <faxathisia> (btw, has anyone implemented quadratic seive?)
00:45:34 <EuphoriaSalad> odd that this works
00:46:03 <EuphoriaSalad> there are two kinds of infinity there
00:46:15 <EuphoriaSalad> I wonder how lazy evaluation goes after them in just the right order...
00:47:29 <EuphoriaSalad> @karma+ thoughtpolice
00:47:29 <lambdabot> thoughtpolice's karma raised to 1.
00:47:45 <faxathisia> > [ x | x <- [3..], x `mod` y /= 0]
00:47:46 <lambdabot>   Not in scope: `y'
00:47:52 <faxathisia> > [ x | x <- [3..], x `mod` [3..] /= 0]
00:47:53 <lambdabot>   add an instance declaration for (Integral [t])
00:47:56 <faxathisia> >:|
00:48:04 <faxathisia> [ x | x <- [3..], x `mod` 2 /= 0]
00:48:07 <faxathisia> > [ x | x <- [3..], x `mod` 2 /= 0]
00:48:08 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
00:49:02 <faxathisia> yeah I'm confused
00:49:03 <EuphoriaSalad> does this only strike out primes up to sqrt(n) in order to generate numbers up to n?
00:49:09 <faxathisia> You start with,
00:49:09 <faxathisia> sieve (y:xs) = y : sieve [ x | x <- xs, x `mod` y /= 0] in sieve [2..]
00:49:19 <faxathisia> sieve _      = ... in 2 : sieve [ x | x <- [3..], x `mod` y /= 0] -- this is the next step right?
00:49:40 <faxathisia> er I should have replaced y with 2
00:49:41 <allbery_b> no, thta doesn't stop at sqt(n).  mainly because there's no n
00:49:47 <EuphoriaSalad> sieve [2..] = 2 : (Z\2Z)
00:49:56 <EuphoriaSalad> allbery_b: the lazy n.
00:50:03 <faxathisia> Do you mean y?
00:50:14 <thoughtpolice> well you need the recursion to pull off the first number since after you strike off all multiples of 2, the first number on the list is a prime. then you strike off all it's multiples, the first left is a prime, etc. etc.
00:50:27 <EuphoriaSalad> as in take 100 $ sieve [2 ..]
00:50:35 <EuphoriaSalad> err, sieve [2..] = 2 : sieve (Z\2Z)
00:51:04 <EuphoriaSalad> thoughtpolice: yeah
00:51:58 <EuphoriaSalad> does that take 100 return the result with the minimum steps possible?
00:52:08 <allbery_b> each iteration adds another filter.  numbers trickle through each filter as needed.  there's no sqrt(n) limit
00:52:32 <faxathisia> starting with sieve [2..]
00:52:32 <jsnx> @let let primes = 2 : [ x | x <- [3,5..], all ((> 0) . (x `mod`)) (takeWhile ((<= x) . (^2)) primes) ]
00:52:32 <lambdabot>  Parse error
00:52:33 <EuphoriaSalad> allbery_b: with the take there is a kind of limit
00:52:35 <faxathisia> -- (y:xs) = [2..] -> y = 2, ys = [ x | x <- [2..], x `mod` 2 /= 0] = not evens
00:52:45 <jsnx> @let primes = 2 : [ x | x <- [3,5..], all ((> 0) . (x `mod`)) (takeWhile ((<= x) . (^2)) primes) ]
00:52:48 <lambdabot> Defined.
00:52:51 <allbery_b> there is, but it doesn't matter to the generation
00:52:53 <faxathisia> so sieve [2..] = 2 : sieve (odds >= 3)
00:52:54 <jsnx> > take 10 primes
00:52:55 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
00:53:21 <EuphoriaSalad> allbery_b: yes, but I was wondering whether the list up to that limit is generated with the minimum number of evals possible
00:53:39 <faxathisia> EuphoriaSalad: I think the minimum possible would be storing the list
00:53:42 <faxathisia> as constant data
00:54:14 * allbery_b isn't good enough at maths to have any idea if that's the optimal way to generate unbounded primes
00:54:19 <EuphoriaSalad> faxathisia: the minimum possible within the algorithm of thoughtpolice. you have a choice what to evaluate next
00:54:31 <EuphoriaSalad> I didn't mean the best algorithm :)
00:54:41 <faxathisia> quadratic seive and General number field sieve are better
00:54:46 <faxathisia> but I don't understand why
00:55:02 <EuphoriaSalad> just that in thoughtpolice's algo, the lazy computation can continue at different points at any given time, right?
00:55:36 <thoughtpolice> if you do the take 100 part, even then those first 100 primes won't be evaluated until you actually need it (by say printing it)
00:56:11 <EuphoriaSalad> the first step turns sieve [2 ..] into 2 : sieve [3,5,7,..]
00:56:33 <EuphoriaSalad> then you have a choice whether to compute a new element of that infinite list or whether to expand the next "sieve"
00:56:49 <EuphoriaSalad> and so on
00:57:01 <faxathisia> @src isInfix
00:57:01 <lambdabot> Source not found. Just try something else.
00:57:05 <faxathisia> @src infix
00:57:05 <lambdabot> Source not found. :(
00:57:29 <EuphoriaSalad> then you have 2:3:sieve[5,7,11, ...]
00:57:43 <faxathisia> I think this is due to sorear, isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
00:57:44 <EuphoriaSalad> ok, think this works pretty fine
00:57:50 <EuphoriaSalad> (performance-wise)
00:57:59 <allbery_b> sieve [2..] --> 2 : sieve (filter (\x -> x `mod` 2 /= 0) $ [2..]) --> 2 : 3 : sieve (filter (\x -> x `mod` 3 /= 0) . filter (\x -> x `mod` 2 /= 0) $ [2..]) ...
00:58:00 <sorear> it's not
00:58:01 <faxathisia> & this is amazing, because isn't that the same efficiency as a dynamic programming version?
00:58:05 <faxathisia> hi :)
00:58:13 <faxathisia> (due to lazyness)
00:59:32 <faxathisia> of course that isInfixOf is ridiculous in a strict language
00:59:36 <allbery_b> hm, not exactly
00:59:39 <faxathisia> but ... I think it's optimal in haskell?
00:59:49 <allbery_b> sieve [2..] --> 2 : sieve (filter (\x -> x `mod` 2 /= 0) $ [3..]) --> 2 : 3 : sieve (filter (\x -> x `mod` 3 /= 0) . filter (\x -> x `mod` 2 /= 0) $ [4..]) ...
01:00:45 <EuphoriaSalad> that's really funny
01:01:10 <EuphoriaSalad> is there some proggy to print out this lazy evaluation?
01:01:38 <allbery_b> hat, maybe
01:01:51 <allbery_b> @where hat
01:01:51 <lambdabot> http://www.haskell.org/hat/
01:02:06 <thoughtpolice> you can use the ghci debugger to do it
01:02:07 <Lemmih> GHCi debugger, perhaps.
01:02:10 <thoughtpolice> it's covered in the user guide
01:02:29 <faxathisia> anyone know about that isInfixOf?
01:02:36 <EuphoriaSalad> thanks allbery_b
01:02:40 <faxathisia> How could you measure it's complexity
01:02:46 <faxathisia> its*
01:02:47 <EuphoriaSalad> I hope you aren't sick yet of all my questions :)
01:03:31 <BMeph> ?src isInfixOf
01:03:31 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
01:04:04 <BMeph> ?src Data.List.isInfixOf
01:04:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:04:20 <jsnx> @undef
01:04:23 <lambdabot> Undefined.
01:04:32 <jsnx> @let primes = 2 : [ x | x <- [3,5..], all ((> 0) . (x `mod`)) (takeWhile (<= floor (sqrt $ (fromIntegral x :: Double))) primes) ]
01:04:33 <lambdabot> Defined.
01:04:46 <jsnx> not going to win any golf matches with that one :)
01:04:50 <faxathisia> > primes !! 444444
01:04:57 <lambdabot> Terminated
01:05:01 <jsnx> ack
01:05:30 <faxathisia> > primes !! 1000
01:05:31 <lambdabot>  7927
01:05:33 <EuphoriaSalad> why this version now?
01:06:09 <jsnx> EuphoriaSalad: it saves on multiplications, at the cost of a square root
01:07:22 <BMeph> jsnx: saves multiplications with respect to what?
01:08:09 <EuphoriaSalad> > primes
01:08:09 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:08:21 <jsnx> BMeph: instead of testing to see whether p*p <= x, i see whether p <= sqrt x
01:08:44 <jsnx> only one square root, instead of an increasing number of multiplications
01:10:00 <EuphoriaSalad> hmm I don't see why you can take the head as the thing you take the sqrt of...
01:10:09 <EuphoriaSalad> oh wait, it's not the head
01:10:21 <EuphoriaSalad> (10:10 am)
01:10:49 <EuphoriaSalad> think I get it now
01:13:24 <jsnx> sometimes, GHCi forgets to return
01:13:39 <jsnx> then i hit it ^C and it finishes
01:13:47 <jsnx> like when i tried primes !! 444444
01:14:15 <EuphoriaSalad> @hoogle gcd
01:14:16 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
01:15:20 <jsnx> or maybe screen is getting in the way
01:15:53 <jsnx> it's 6495121, by the way
01:15:56 <jsnx> after 140 seconds
01:16:17 <jsnx> and 11336295996 bytes
01:18:57 <jsnx> basically, there is no way to calculate the nth prime without calculating all the previous primes...
01:19:31 <EuphoriaSalad> fortunately I need them all anyway
01:19:57 <jsnx> i can improve the memory usage of my algorithm might rely on using a "prime wheel" instead of [3,5..]
01:20:08 <jsnx> that came out a mess
01:20:24 <jsnx> maybe i can improve the memory usage of my algorithm by using a "prime wheel" instead of [3,5..]
01:20:29 <Pseudonym> Yes, you can.
01:21:13 <Pseudonym> FWIW: http://andrew.bromage.org/darcs/numbertheory/
01:21:14 <lambdabot> Title: Index of /darcs/numbertheory
01:21:40 <Pseudonym> Oh, I dumped the prime wheel there.
01:21:42 <Pseudonym> Never mind.
01:25:07 <jsnx> Pseudonym: what does the SPECIALIZE pragma actually do?
01:25:32 <jsnx> have you found it to make a real difference?
01:26:07 <EuphoriaSalad> @check forAll (do i<-choose (0,100); j<- choose(0,100); return (primes !! i,j)) $ \(x,y) -> gcd x y `elem` [1,x]
01:26:07 <lambdabot>  OK, passed 500 tests.
01:26:15 <EuphoriaSalad> that's cool
01:26:58 <Pseudonym> jsnx: Yes.
01:27:11 <Pseudonym> It creates specialised versions of polymorphic functions.
01:27:22 <jsnx> Pseudonym: how much of a difference?
01:27:27 <jsnx> just curious, that's all
01:27:40 <shachaf> EuphoriaSalad: Still awake? :-)
01:27:54 <Pseudonym> To be honest, I have no idea on a modern GHC.
01:28:00 <jsnx> Pseudonym: oh
01:28:25 <jsnx> EuphoriaSalad: pretty soon, you're going to have the first lunch of the new year...
01:30:09 <Pseudonym> jsnx: I suspect it'd be most use in a library, like this, at lower optimisation levels.
01:31:23 <Pseudonym> BRB, need to get kids out of the bath.
01:31:48 <darkness3477> Could any of you do me a simple favor? Change a python function that uses recursion into Haskell.. I'd be able to do it after awhile of learning Haskell, but I just want to see how it looks and the speed difference.
01:32:16 <EuphoriaSalad> shachaf: yeah. getting a bit sick :|
01:32:38 <darkness3477> The function just spits out the Fibonacci sequence.. forgot to write that.
01:32:44 <shachaf> EuphoriaSalad: What happened to your nick, by the way?
01:33:30 <faxathisia> > map fst $ iterate (\(x,y) -> (y,x+y)) $ (0,1)
01:33:32 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:33:38 <faxathisia> there are fibs
01:33:40 <jsnx> darkness3477: okay, sure
01:33:41 <EuphoriaSalad> uhm, it was temporarily changed due to euphoria
01:33:46 <darkness3477> def fib(n):
01:33:47 <darkness3477>     if n == 0 or n == 1:
01:33:47 <darkness3477>         return n
01:33:47 <darkness3477>     else:
01:33:47 <darkness3477>         return fib(n - 1) + fib(n - 2)
01:33:58 <jsnx> darkness3477: please paste appropriately
01:33:58 <faxathisia> darkness google dons blog
01:34:04 <Pseudonym> fib 0 = 0
01:34:07 <Pseudonym> fib 1 = 1
01:34:14 <jsnx> Pseudonym: lolz
01:34:15 <Pseudonym> fib n = fib (n-1) + fib (n-2)
01:34:17 <Pseudonym> Done.
01:34:21 <EuphoriaSalad> argh just do a matrix exponentation with square-and-multiply for fib!
01:34:22 <Pseudonym> Oh, stick on a type signature.
01:34:35 <Pseudonym> If you want to enforce machine words, say.
01:34:50 <Pseudonym> I don't know if Python defaults to arbitrary-length integers, but Haskell does.
01:35:01 <Cale> It appears to do so
01:35:09 <opqdonut> EuphoriaSalad: exactly :)
01:35:14 <EuphoriaSalad> exponential speedup!
01:35:26 <EuphoriaSalad> :)
01:35:55 * faxathisia wants infinite precision Num instance
01:36:01 <faxathisia> > sqrt 2
01:36:02 <lambdabot>  1.4142135623730951
01:36:04 <Pseudonym> EuphoriaSalad: That's unnecessarily complex, BTW.
01:36:07 <faxathisia> shoudl go on forever
01:36:13 <opqdonut> faxathisia: aren't there afew?
01:36:19 <opqdonut> *a few
01:36:20 * Pseudonym points, once again, to http://andrew.bromage.org/darcs/numbertheory/
01:36:21 <lambdabot> Title: Index of /darcs/numbertheory
01:36:30 <EuphoriaSalad> Pseudonym: maybe you're referring to the eigenvalue form. not really simpler, I think
01:36:42 <Pseudonym> I mean you need to only store two numbers, not four.
01:36:46 <darkness3477> Python changes variable types as needed, if that answers your question. Also, thanks! that helps me a load. Now I just need to figure out some things and then check if Haskell really is that much quicker
01:36:55 <opqdonut> well the eigenvalue form is a bit iffy
01:37:04 <faxathisia> darkness google dons blog
01:37:07 <opqdonut> as it throws non-integer values in
01:37:11 <Cale> darkness3477: remember to compile with optimisations :)
01:37:15 <faxathisia> darkness they covered speed comparison
01:37:19 <EuphoriaSalad> Pseudonym: you need to keep the matrices for square-and-multiply
01:37:32 <darkness3477> Done, looks for it now.
01:37:37 <Pseudonym> http://haskell.org/haskellwiki/The_Fibonacci_sequence
01:37:45 <Cale> darkness3477: though if you want to speed this algorithm up without replacing it with another algorithm, probably the simplest thing to do is to parallelise it.
01:37:49 <Pseudonym> EuphoriaSalad: No, you don't.
01:37:57 <darkness3477> If I compile with optimisations, it doesn't really seem fair as I'm not compiling the python code...
01:38:13 <faxathisia> darkness3477: it's not fair to use a different langauge then
01:38:25 <darkness3477> Well, yes, that's true I suppose.
01:38:53 <EuphoriaSalad> Pseudonym, what do you mean?
01:39:42 <Pseudonym> EuphoriaSalad: You can define an algebra that is similar to the "raise the 2x2 matrix to the power of n", only using fewer operations.
01:39:49 <Pseudonym> Using 2x1 objects.
01:40:08 <Pseudonym> Like this:
01:40:11 <Pseudonym> http://haskell.org/haskellwiki/The_Fibonacci_sequence#Another_fast_fib
01:40:11 <lambdabot> http://tinyurl.com/3ynj9f
01:41:07 <darkness3477> Lol, they used the exact same code for there fib function. LOL
01:41:28 <Pseudonym> Yeah, it's a standard example.
01:41:32 <Pseudonym> Oh, one more thing.
01:41:54 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2007-November/034174.html
01:41:55 <lambdabot> Title: [Haskell-cafe] Fibbonachi numbers algorithm work TOO slow., http://tinyurl.com/278hup
01:42:31 <Pseudonym> I don't claim that implementation is fast, but I found it cute.
01:42:37 <EuphoriaSalad> Pseudonym: oh, right, the algebra generated by the [0,1;1,1] matrix is only two-dimensional
01:42:45 <Pseudonym> Yeah.
01:43:29 <faxathisia> thisis way cool
01:43:29 <faxathisia> http://www.csie.ntu.edu.tw/~b94087/RegExp.pdf
01:43:30 <EuphoriaSalad> does 3.1 do square and multiply?
01:44:15 <Pseudonym> Yes.
01:44:18 <Pseudonym> @source (^)
01:44:20 <EuphoriaSalad> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#%5E
01:44:24 <EuphoriaSalad> yes
01:44:29 <faxathisia> why use a matrix?
01:44:40 <faxathisia> Isn't: map fst $ iterate (\(x,y) -> (y,x+y)) $ (0,1) -- moer efficient
01:44:53 <Pseudonym> faxathisia: No, it's not.
01:44:57 <EuphoriaSalad> faxathisia: no, you can calculate A^n in O(log(n))
01:44:58 <faxathisia> oh I guess not, cause you don't actually do iterate (matrixMultiply thing)
01:45:00 <Pseudonym> It's O(n) work to get the nth Fibonacci number.
01:45:02 <faxathisia> you actually diagonalize right?
01:45:05 <faxathisia> so that's a lot faster
01:45:15 <Pseudonym> WHich is fine if you want all of them.
01:45:32 <Pseudonym> But it's only O(log n) to get the nth if you use one of the faster algorithms, like the matrix one.
01:45:55 <EuphoriaSalad> faxathisia: you can diagonalize which yields this http://haskell.org/haskellwiki/The_Fibonacci_sequence#Using_Binet.27s_formula, but you can also just directly square-and-multiply the matrix
01:46:37 <faxathisia> directly square-and-multiply the matrix is less efficient than iterate (\(x,y) -> (y,x+y)) isn't it?
01:46:51 <EuphoriaSalad> no, it's O(log(n)) too
01:46:54 <opqdonut> no, it uses log n exponentiation
01:47:02 <Pseudonym> The haskell-cafe link that I gave, BTW, is Binet's formula implemented in the field extension Q[sqrt 5], so it's integer-only and O(log n).
01:47:03 <EuphoriaSalad> just that every step takes a few more operations
01:47:08 <faxathisia> Oh
01:47:10 <EuphoriaSalad> unless you do it like Pseudonym
01:47:11 <faxathisia>  I see what you're saying
01:47:37 <EuphoriaSalad> but maybe approximately exponentiating the eigenvalue can be done even faster?
01:47:42 <EuphoriaSalad> using some analysis trick
01:47:57 <opqdonut> doubt it
01:48:00 <EuphoriaSalad> yeah me too
01:48:00 <Pseudonym> I suspect that any such method will turn out to be O(log n).
01:48:04 <opqdonut> or at least it won't scale
01:48:09 <EuphoriaSalad> right
01:48:20 <Pseudonym> Because you'll want to avoid floating-point roundoff somehow.
01:48:33 <darkness3477> Well thanks for helping me out. It really was quicker in Haskell. I suppose Haskell optimises recursion a lot better than Python
01:48:37 <EuphoriaSalad> O(log(n)) is minimum because that's how many digits the result will have.
01:48:50 <EuphoriaSalad> darkness3477: Haskell is compiled for one thing :)
01:48:59 <darkness3477> Speed?
01:49:26 <shachaf> darkness3477: You missed a comma.
01:49:43 <shachaf> darkness3477: (Or EuphoriaSalad did.)
01:49:58 <EuphoriaSalad> "Haskell is compiled, for one thing :)"
01:50:07 <opqdonut> :D
01:50:19 <darkness3477> And I thought I was picky :P
01:50:23 <EuphoriaSalad> "for one thing" is proper english, no?
01:50:46 <darkness3477> I think I'll enjoy learning Haskell. It seems like a real eye opener, and hopefully it'll make me a better programmer.
01:50:48 <EuphoriaSalad> meaning "one point is that haskell is compiled"
01:51:01 <shachaf> EuphoriaSalad: I understood it, anyway. :-)
01:51:07 <darkness3477> OHHHH! I understand what you said now.
01:51:31 <shachaf> EuphoriaSalad: But without the comma, darkness3477 "Haskell is compiled for one thing: Speed".
01:51:35 <shachaf> Never mind.
01:51:42 <EuphoriaSalad> shachaf: yes, understood that
01:52:09 <EuphoriaSalad> it is like in "I for one welcome..."
01:52:18 <opqdonut> ... our haskell overlords
01:52:20 <EuphoriaSalad> (my usage, now)
01:52:48 <faxathisia> haha
01:52:56 <Pseudonym> darkness: I think you'll like it too.  Haskell has made my other programming better too.
01:53:12 <Pseudonym> Not that I've learned Python.
01:53:22 <darkness3477> I know more than just Python...
01:53:29 <Pseudonym> Sure.
01:53:37 <darkness3477> But python is nice to play with.
01:54:38 <darkness3477> Ok, so Haskell is similar to Lisp in some ways. Does Haskell have macros?
01:54:51 <shachaf> But also, Python doesn't optimize tail calls.
01:54:58 <shachaf> darkness3477: There's Template Haskell.
01:55:16 <faxathisia> Haskell isnt' really similar to lisp
01:55:22 <shachaf> darkness3477: But not exactly macros in the LISP sense (unless you count Liskell).
01:55:24 <faxathisia> function vs procedural
01:55:26 <Pseudonym> darkness3477: But a lot of places where you'd use macros in other languages, you use other things in Haskell.
01:55:29 <Pseudonym> Like typeclasses.
01:55:30 <wy> weird. my ghc stops to find package. I don't remember did something for that
01:55:37 <Pseudonym> But yes, there's Template Haskell.
01:55:46 <aFlag> I'm learning lisp right now, that macro thing is very wild
01:55:50 <Pseudonym> And some people use the C preprocessor with Haskell.
01:55:55 <Pseudonym> Not that that's a good macro system...
01:56:02 <EuphoriaSalad> I thought there were already enough abstraction mechanisms in Haskell...
01:56:13 <darkness3477> Haskell just seems similar to Lisp... not that I've had much experience with either.
01:56:26 <faxathisia> darkness3477: Why do you think they are similar
01:56:26 <Pseudonym> Well, it's a direct descendent.
01:56:30 <aFlag> I like haskell, but I few that typing sometimes can be a pain. That's why I like python and I'm hoping I can use lisp for small scripts as well.
01:56:37 <wy> aFlag: I've used Common Lisp for a while
01:56:39 <shachaf> EuphoriaSalad: Enough for what?
01:56:44 <EuphoriaSalad> major differences are probably the type system and that haskell is purely functional
01:57:03 <EuphoriaSalad> shachaf: hmm don't know, to do things you would otherwise do with templates
01:57:07 <shachaf> EuphoriaSalad: cpp is used for things like checking whether to use a library.
01:57:11 <EuphoriaSalad> but I'm a newb so I can't comment
01:57:20 <shachaf> @where th
01:57:36 <shachaf> lambdabot?
01:57:39 <wy> Hey anyone can have a look at my problem? ghc just stops to find my module in the same directory
01:57:47 <aFlag> don't you guys get frustrated with strong typing sometimes? Maybe it's just because I'm not used to it, but sometimes I feel my life could be easier if I didn't have to care about them.
01:57:49 <EuphoriaSalad> shachaf: was referring to macros/templates, no c preproc
01:58:03 <darkness3477> Iteration, does it only happen through recursion?
01:58:08 <faxathisia> aFlag: I never do, but I don't write 100% of programs in haskell
01:58:19 <Pseudonym> darkness3477: Yes, but you can hide it convincingly.
01:58:24 <EuphoriaSalad> aFlag: I like it a lot so far. once you get the types right you are half done
01:58:30 <Pseudonym> e.g. list comprehensions
01:58:36 <Pseudonym> Which I understand Python borrowed from Haskell.
01:58:44 <faxathisia> aFlag: I can't think why you'd get frustrated with strong typing though?
01:58:55 <bart416> EuphoriaSalad the only annoying thing about types in haskell is that you can't easilly convert an integer to a float
01:59:06 <faxathisia> fromIntegral is easy..
01:59:12 <aFlag> last time I was frustrated was when I tried to write a program that used eval, it's a function from the plugins module. I feel that could work so much easier with week typing.
01:59:13 <bart416> faxathisia I mean on the fly
01:59:22 <faxathisia> bart416: At runtime?
01:59:26 <EuphoriaSalad> bart416: since Integer is unbounded and Float is bounded I think
01:59:45 <EuphoriaSalad> but Int to Float should be possible
01:59:48 <darkness3477> Meh... everything is an integer.
02:00:19 <bart416> EuphoriaSalad you can't put 16156851658164684631685461568465 in an integer, I doubt you could in a float as well, you'd need a long integer for that
02:00:32 <shachaf> "I'm not an Integer! I'm a free man!"
02:00:40 <EuphoriaSalad> bart416: Integer is arbitrary precision. Int is the small one
02:00:41 <Pseudonym> > 16156851658164684631685461568465 :: Integer
02:00:53 <bart416> mhhh, strange
02:00:55 <faxathisia> > (fromIntegral 16156851658164684631685461568465) :: Float
02:00:57 <aFlag> a friend of mine showed me a program he did which let him write small lisp functions and get them evaluated. The program would show a few inputs and outputs of the function
02:01:25 <aFlag> so I wanted to do it in haskell, it was all very easy and neat until the part I got to using eval
02:01:32 <EuphoriaSalad> long integer... related to long cat?
02:01:39 <shachaf> dons?
02:01:54 <shachaf> Oh, right.
02:02:05 <bart416> A signed Integer can normally only have a value between -32767 and 32767 :S
02:02:10 <shachaf> Are we stuck without a lambdabot, or can someone else restart her?
02:02:19 <shachaf> bart416: That's Int, in Haskell.
02:02:41 <EuphoriaSalad> > minBound :: Int
02:02:48 <darkness3477> Ok... probably my last question before I retire from IRC and clear my head... But, what area is Haskell most often used in?
02:02:58 <bart416> shachaf yeah but haskell still uses compilers and "interpretters" like ghci that are written in C or C++ mainly
02:03:11 <faxathisia> seems like haskell is used for everything now isn't it?
02:03:26 <bart416> I really doubt it uses an unsigned long long O_o
02:03:27 <EuphoriaSalad> what happened to lambda?
02:03:46 <faxathisia> bart416: C doesn't matter
02:04:00 <EuphoriaSalad> shachaf: "a lambdabot"??? there's only one :)
02:04:01 <faxathisia> bart416: It's just a platform that a haskell may or may not be built on
02:04:36 <shachaf> bart416: Isn't it -1073741823 to 1073741823, anyway?
02:04:51 <aFlag> I think I got ignored :(
02:04:54 <shachaf> EuphoriaSalad: mbot is a lambdabot, for one.
02:04:58 <Pseudonym> It's used in a few financial companies, IIRC.
02:05:01 <darkness3477> Well, if it's used everywhere that doesn't help me. Trying to think of a 'goal program' to write when I've finished with my learning materials.
02:05:04 <EuphoriaSalad> shachaf: I meant she is a personality :)
02:05:05 <Pseudonym> And in at least one defence contractor.
02:05:06 <bart416> shachaf the longest you can do in c is an unsigned long long
02:05:12 <bart416> 0 till 18446744073709551615
02:05:25 <faxathisia> aFlag: Lisp are Haskell are totally different..
02:05:32 <shachaf> EuphoriaSalad: lambdabot is a personality and a program.
02:05:36 <bart416> biggest signed is -9223372036854775807 till 9223372036854775807
02:05:42 <EuphoriaSalad> shachaf: yes, I was kidding
02:05:44 <aFlag> yeah, I know that
02:05:49 <shachaf> EuphoriaSalad: I'm talking about the program, which is also running under mbot.
02:06:13 <Pseudonym> darkness3477: In general, it's most common use is for programs that rely on data structure hacking.
02:06:17 <Pseudonym> its
02:06:21 <Pseudonym> Not it's, sorry.
02:06:31 <Pseudonym> So symbolic stuff, like compilers, or diff.
02:06:38 <Pseudonym> As one example.
02:06:52 <bart416> shachaf it would kind a matter if you try to let a C and haskell program work together
02:06:59 <Pseudonym> But it's also gaining ground in applications that require fine-grained concurrency.
02:07:08 <darkness3477> Compilers sound a bit too hard for me, :P Perhaps I might finally try and right a chatter-bot
02:07:18 <darkness3477> write*
02:07:27 <Pseudonym> If I had to summarise, people tend to use Haskell for hard problems, not easy ones.
02:07:33 <EuphoriaSalad> darkness3477: I'm looking for a goal for when I get better too, I thought maybe helping out with one of the existing projects
02:08:03 <bart416> Pseudonym haskell seems to be easy for math related problems
02:08:25 <darkness3477> Pseudonym: A chatterbot wouldn't be easy for me, and it'd be pretty damn cool :D
02:08:30 <EuphoriaSalad> or maybe I will finally write my commutative diagram editor :)
02:09:22 <Pseudonym> It depends on the math.,
02:09:23 <darkness3477> EuphoriaSalad: I'd do that, but even when I get good enough with Haskell to feel comfortable with it, I doubt I'd feel comfortable with releasing code for others to use.
02:09:32 <Pseudonym> Haskell still doesn't do well the sorts of things that Fortran does well.
02:09:47 <faxathisia> darkness3477: There's no point getting comfortable with a language
02:09:56 <faxathisia> darkness3477: Just pick something to program and work on it
02:10:34 <darkness3477> I'm only learning Haskell as I have nothing to do for the time being, not as I have any great need to solve a problem with it.
02:11:19 <jsnx> Pseudonym: does Fortran do them well anymore?
02:11:43 <jsnx> it's my understanding the C++ is just as good, with the right set of templates
02:11:43 <darkness3477> Anyway, it's hot and I'm tired. Thanks for helping me out, everyone! I'm sure I'll come and bug you with some more nubby questions at a later date
02:11:44 <Pseudonym> jsnx: Not since C++ got Modern.
02:11:54 <jsnx> Pseudonym: lolz
02:11:59 <Pseudonym> :-)
02:12:22 <Pseudonym> But that sort of insane-numbers-of-floats processing isn't really what Haskell does well... yet.
02:12:25 <EuphoriaSalad> ah, thought he must be in .au
02:12:32 <EuphoriaSalad> ("it's hot")
02:12:40 <jsnx> Pseudonym: i think we are close :)
02:12:57 <Pseudonym> When we get proper data parallelism, I think it's going to get more interesting on that front.
02:13:01 <EuphoriaSalad> ok enough for me too
02:13:07 <EuphoriaSalad> thanks everyone for all the answers :)
02:13:14 <Pseudonym> Fare well.
02:13:38 <EuphoriaSalad> lying in bed will be fun now
02:13:46 <Pseudonym> I'm sorry that SISAL seems to have died.
02:13:50 <jsnx> yes
02:13:53 <Pseudonym> THat was a damn good Fortran replacement.
02:14:07 <jsnx> i never got around to using it, but it seemed pretty cool
02:14:12 <jsnx> i learned c++ instead
02:14:12 <Pseudonym> Yeah.
02:14:26 <jsnx> templates warp your mind
02:14:39 <jsnx> then you go to dynamic languages for awhile...
02:14:43 <Pseudonym> How deep into type classes are you?
02:14:48 <Philippa> heh
02:14:59 <Philippa> I came to Haskell from C++ having skipped dynamic languages
02:15:00 <jsnx> they are not quite as weird as templates
02:15:06 <Pseudonym> I came to C++ from Haskell.
02:15:14 <Philippa> Ouch
02:15:16 <jsnx> Pseudonym: lolz
02:15:17 <nachos> whats dynamic languages?
02:15:23 * faxathisia has never done anything with stack languages... :[
02:15:29 <Philippa> nachos: lisp, smalltalk and their bastard children
02:15:35 <jsnx> nachos: PHP, Perl, Ruby, Python, Scheme
02:15:44 <jsnx> bourne shell
02:15:45 <nachos> oh :)
02:15:46 <Philippa> occasionally someone reinvents lisp around something other than cons cells, too
02:15:49 <wy> hmmm How can I tell ghc 6.8.2 in windows to find my module in the same directory?
02:15:56 <Pseudonym> Hey, Smalltalk isn't so bad.
02:15:56 <Philippa> (TCL, say)
02:16:07 <Pseudonym> It's no match for Eiffel, or Erlang, but it's not bad.
02:16:12 <jsnx> Pseudonym: you see, typeclasses happen all at once
02:16:14 <thoughtpolice> wy: pass the option "-I." ?
02:16:33 <jsnx> whereas templates depend on include order and all this strangeness
02:16:41 <Pseudonym> Ah, truel
02:16:43 <Pseudonym> true
02:16:44 <wy> thoughtpolice: It used to do this automatically without any switch under linux
02:16:50 <jsnx> thankfully, i have not seen that stuff for over a year
02:17:16 <Pseudonym> BTW, I don't think that templates warp your mind.  I think that Boost warps your mind.
02:17:26 <jsnx> Pseudonym: never tried Boost
02:17:32 <Pseudonym> Templates are damned easy to use.  THey're just very, very hard to write.
02:17:39 <Pseudonym> Using Boost is a breeze.
02:17:43 <jsnx> yes
02:17:45 <Philippa> Pseudonym: there aren't a lot of dynamic, or even dynamically typed, OO languages that wouldn't be better off being Smalltalk, hence the "bastard children" comment
02:17:48 <Pseudonym> Reading the source code is... uh...
02:17:53 <jsnx> but how does it warp your mind?
02:18:01 <Pseudonym> Well, let's not go there.
02:18:12 <Pseudonym> Philippa: Good point.
02:18:21 <jsnx> Pseudonym: what about scheme and bourne shell?
02:18:30 <jsnx> oops, that was for Philippa
02:18:32 <faxathisia> What  do you do after dynamic languages? :)
02:18:40 <Philippa> jsnx: scheme isn't an OO language
02:18:42 <thoughtpolice> wy: it should anyway. :/
02:18:44 <jsnx> faxathisia: *good* languages
02:18:47 <faxathisia> like?
02:18:57 <wy> strange...
02:18:57 <Philippa> being able to build OO in it isn't the same thing
02:19:03 <jsnx> Philippa: oh, you are right -- did not see the qualification
02:19:20 <bart416> keep in mind that being forced to use OO isn't always a good thing
02:19:30 <Pseudonym> Truly.
02:19:32 <fnord123> is it ever a good thing?
02:19:35 <bart416> it often ads a layer of complexity to a simple sollution
02:19:36 <Pseudonym> Being forced to use anything is a bad thing.
02:19:40 <Philippa> scheme's the non-bastard child of lisp that made good, mind
02:19:42 <bart416> fnord123 actually it is sometimes
02:19:50 <fnord123> forced?
02:19:52 <Pseudonym> Any useful language is either domain-specific or multi-paradigm.
02:19:54 <jsnx> Philippa: personally, i like that python has functions as values -- which smalltalk does not, if i remember correctly
02:19:56 <bart416> hiding an entire socket handle behind an object is extremely useful
02:20:05 <Philippa> jsnx: smalltalk has blocks instead
02:20:26 <Philippa> python's not much less bastardised than java though
02:20:26 <jsnx> well, if they are like ruby blocks, i hate them
02:20:31 <fnord123> hiding a socket library in a record structure, or an object hierarchy. which do you mean?
02:20:33 <Pseudonym> bart416: Nobody is disputing that objects are useful.
02:20:49 <bart416> Pseudonym nah that was against fnord123 :P
02:20:51 <Pseudonym> It's no concidence that OO and modern GUIs grew up together.
02:20:54 <Pseudonym> Ah, right.
02:20:55 <fnord123> Pseudonym: I am questioning it. It's helpful to reassess it every once in a while. :)
02:20:58 <faxathisia> yea
02:21:05 <jsnx> Pseudonym: they are equally useless...
02:21:07 <faxathisia> object orientation fits GUIs very well I think
02:21:08 <Philippa> bart416: there's no particular need for that example to use objects rather than just a clean interface
02:21:31 <bart416> Philippa to be honnest with you, I don't really like most of the common GUI libraries their usage of objects
02:21:33 <kolmodin> @yarr!
02:21:41 <bart416> they often add too much layers what makes it hard to debug
02:21:42 <wy> It seems that it only fails to find the module inside emacs
02:21:45 <jsnx> kolmodin: @lolz
02:22:01 <kolmodin> oh
02:22:04 <kolmodin> ?lolz
02:22:06 <fnord123> OO maps onto guis in a low level way, but no one has seemed to abstract out behaviours from the widgets.
02:22:09 <kolmodin> hmm?
02:22:40 <Philippa> fnord123: if you mean what I think you do, that's what dataflow's for
02:22:59 <jsnx> Philippa: basically, python is the only mainstream language that lets me get away with HOFs -- and i appreciate it for that!
02:23:11 <faxathisia> so so so what do you do after learning Haskell!? :p
02:23:15 <fnord123> I only know data flow from an imperative language perspective. what do you mean by it?
02:23:24 <jsnx> faxathisia: learn Datalog, i think...
02:23:25 <faxathisia> I'm supposing Haskell comes after dynamic langauges
02:23:57 <bart416> jsnx you'd be amazed with what php allows you to do sometimes :P
02:24:17 <fnord123> since I meant abstracting things like Entry Float $ {upperbound=100.0 lowerbound=0.0 -> Widget
02:24:29 <fnord123> oops, hit enter instead of }
02:24:29 <jsnx> bart416: really? no wrapper?
02:24:53 <bart416> jsnx, nah I'm talking about behaviour
02:25:01 <bart416> you can get php to do things it wasn't intended for
02:25:07 <jsnx> faxathisia: actually, the first and last thing you learn well is bourne shell
02:25:15 <jsnx> bart416: like, webapps!
02:25:24 <bart416> uhm, php was intended for webapps :P
02:25:38 <bart416> But I mean unexpected behaviour
02:25:41 <jsnx> bart416: teasing
02:25:45 <jsnx> bart416: like what?
02:26:04 <faxathisia> bourne shell can kill ?
02:26:17 <jsnx> faxathisia: bourne shell's first class files are the secret to program composition
02:26:18 <bart416> jsnx, I doubt a lot of languages allow you to rename the standard library functions on runtime to give an example
02:26:38 <jsnx> bart416: well, any functional language lets you do that
02:26:44 <jsnx> python, too
02:26:52 <bart416> jsnx, constantly throughout the execution?
02:27:07 <jsnx> bart416: what do you mean, constantly? like, over and over again?
02:27:14 <bart416> yeah, throughout the program
02:27:25 <bart416> I once used that to compensate for a constantly changing value
02:27:25 <jsnx> bart416: well no, probably not
02:27:54 <jsnx> ph34r
02:28:09 <bart416> it's hard to explain what I mean jsnx
02:28:19 <bart416> I can't exactly come up with an example, it are usually bug exploits
02:28:26 <EvilTerran> being able to change stuff is a terrible language feature
02:28:27 <jsnx> lolz
02:28:41 <EvilTerran> just look at haskell; you can't change anything, and it's great!
02:28:48 <jsnx> i agree
02:28:57 <bart416> or things that shouldn't be possible are possible sometimes :S
02:29:12 <jsnx> we should strive to understand how the designers are right...and they had better be right!
02:29:15 <bart416> EvilTerran too logical :P
02:29:35 <bart416> It's fun to be able to mess things up totally
02:29:44 <EvilTerran> unsafePerformMiracles
02:29:50 <jsnx> i knew a game programmer once, who learned to write web apps
02:29:51 <faxathisia> :D
02:29:57 <EvilTerran> unsafePassThe#
02:29:57 <jsnx> he loved php
02:30:12 <jsnx> he always ran as root, too
02:30:13 <bart416> jsnx, the main thing awesome about php is that you don't have to worry about types but you can enforce them if you need to :)
02:30:24 <jsnx> that is not awesome
02:30:33 <faxathisia> bleh php talk is boring me
02:30:44 <jsnx> and any of ruby, python, &c. let you do that
02:30:53 <bart416> duuuh
02:30:58 <bart416> though ruby is an OO mess
02:31:04 <jsnx> faxathisia: yeah, so, now that i think about it, bourne shell is the ultimate language
02:31:06 <bart416> python forces identing, and C is rather strict
02:31:16 <jsnx> bart416: forcing indenting is good
02:31:18 <faxathisia> jsnx: Dunno..  I like zsh more :p
02:31:26 <jsnx> &c.  ->  etcetera
02:31:30 <faxathisia> forced indentation is not -good-
02:31:41 <jsnx> now if only they banned tabs
02:31:55 <jsnx> faxathisia: zsh is not a programming language
02:31:56 <faxathisia> (although it works great in haskell and Agda2)
02:31:57 <bart416> tabs are awesome to show code structures
02:32:03 <faxathisia> faxathisia, sure it's a shell
02:32:05 <jsnx> faxathisia: nor is ksh, bash, csh
02:32:06 <faxathisia> er :/
02:32:09 <faxathisia> why am I talking to myself
02:32:18 <jsnx> faxathisia: if your program in them, you are evil
02:32:27 <jsnx> sorry -- programming in them is evil
02:32:29 * EvilTerran blinks
02:33:08 <bart416> jsnx you use identing code as well to show structures, the only difference is that you don't get to choose
02:33:24 <bart416> while in a language like C you have the choice to do what you want
02:33:36 <jsnx> bart416: if i am already indenting, i don't want to type all those extra braces
02:33:57 <jsnx> bart416: and i don't want anybody else to have a choice to write poorly indented code
02:34:02 <bart416> heheh, I make the editor put them there for me
02:34:12 <jsnx> bart416: that is hard on your editor
02:34:25 <bart416> actually it isn't :S
02:34:28 <faxathisia> jsnx: How someone indents their code is a lot less important than whether or not it works (to me)
02:34:35 <davidL> @bot
02:34:43 <jsnx> faxathisia: not when you are reading it, though
02:34:52 <davidL> where is lambdabot? :-[
02:34:52 <wy> Isn't GLUT included in HOpenGL?
02:34:53 <bart416> 2 enters after an if, while or for statement will cause a { to appear, I think that's useful enough
02:34:57 <faxathisia> jsnx: No it doesn't matter, I can read code written by other people than me
02:35:19 <jsnx> bart416: if it actually does that, cool
02:35:19 <bart416> the only thing that they should prevent is ultra long inline statements
02:35:28 <faxathisia> jsnx: If everyone wrote code in the same syntactic style as me, it wouldn't make it any easier to understand it
02:35:39 <bart416> jsnx I still have to iron out the bugs
02:35:40 <EvilTerran> wy, don't think so
02:35:40 <jsnx> bart416: yeah, code longer than 78 chars shouldn't parse
02:36:04 <wy> EvilTerran: too bad... I have to build it myself in windows...
02:36:09 <bart416> jsnx that's not totally true :P
02:36:18 <jsnx> faxathisia: well, maybe i am just more dependent on what i see than you
02:36:28 <bart416> ever used an microsoft library?
02:36:33 <EvilTerran> wy, however, GLUT is a dead project, and has been for years. i know that puts *me* off, and, if the same applies for you, i believe you can use gtk2hs to achieve the same thing
02:36:35 <bart416> the long names are terrible
02:36:50 <bart416> java is even worse though
02:36:50 <jsnx> bart416: code that uses microsoft libraries shouldn't parse :)
02:36:58 <bart416> true
02:37:06 <wy> EvilTerran: But I remember to have succeeded in building an empty opengl program with glut a few days ago under windows
02:37:08 <jsnx> lolz, okay
02:37:14 <bart416> Though .NET isn't that bad, certain parts of it should actually be added to the standard C++ library
02:37:17 <faxathisia> jsnx: once you knew operator precidence rules, 1 + 2 * 3 is just as easy to read as 1 + (2 * 3)
02:37:21 <EvilTerran> wy, yeah, i got a binary of it from somewhere
02:37:25 <wy> EvilTerran: Now ghc stops to work
02:37:30 <jsnx> faxathisia: you sound like the developer from hell
02:37:41 <faxathisia> jsnx: Why?
02:37:44 <wy> EvilTerran: I can't even find the module in the same directory. I'm wondering why
02:37:47 <jsnx> faxathisia: that approach does not scale well at all
02:37:48 <faxathisia> (I could well be)
02:37:52 <faxathisia> what lol
02:37:52 <bart416> jsnx, it's only a matter of time before we have something like java .NET, imagine the terror that would spread O_o
02:37:56 <faxathisia> "scale"?
02:37:59 <faxathisia> Which approach
02:38:20 <jsnx> faxathisia: operator precedence
02:38:20 <EvilTerran> i think, when i wanted GLUT, i found a binary package of ghc that had it :P
02:38:25 <faxathisia> uh ... ...
02:38:29 <faxathisia> I have no idea what you mean
02:38:36 <jsnx> faxathisia: in the face of operator overloading, ommitting parens is very confusing
02:38:38 <EvilTerran> bart416, you mean java parrot.net?
02:38:41 <EvilTerran> :P
02:38:49 <faxathisia> I disagree strongly
02:38:58 <faxathisia> there is some code which is written in lisp and some which isn't
02:39:07 <jsnx> faxathisia: eh?
02:39:14 <bart416> Java.System.Windows.Microsoft.NET.System.Windows.NET.String.reverse()
02:39:34 <jsnx> Java.
02:39:37 <bart416> EvilTerran imagine the ultra long function and library names, it's awesome when you think about it :P
02:39:39 <jsnx> System.
02:39:42 <jsnx> ...
02:39:44 <jsnx> and so on
02:39:52 <bart416> Good for the hospitals, more people with carpal tunnel
02:39:57 <jsnx> bart416: shorten those lines, soldier!
02:40:03 <wy> EvilTerran: gtk2hs is nicer, but my tutorial is using glut
02:40:05 <EvilTerran> bart416, I think you missed a Java.
02:40:08 <jsnx> faxathisia: look, it's not important for code to work
02:40:12 <EvilTerran> meh
02:40:16 <faxathisia> jsnx: I disagree
02:40:16 <bart416> yeah probably did EvilTerran :P
02:40:25 <jsnx> faxathisia: it's important for it to be readable, so that when you die, someone can fix it
02:40:38 <jsnx> that's where we disagree, really
02:41:01 <jsnx> i am always thinking about the person who has to read my code later -- and if it takes more time to write it, i'm okay with that
02:41:09 <faxathisia> jsnx: If you can't write readable code it's not worth releasing, if code doesn't work it's not worth releasing
02:41:21 <faxathisia> jsnx: you seem to think that it only matters if code is readable, not what it does
02:41:37 <jsnx> faxathisia: i was exagerating
02:41:52 <jsnx> but i don't stop when it works
02:42:01 <jsnx> i rewrite it till it's clear
02:42:10 <faxathisia> jsnx: If you just express things in the natural way you don't have to worry about scalability or putting brackets all over the place
02:42:14 <bart416> good code is short and easy to read
02:42:22 <jsnx> bart416: yes
02:42:37 <bart416> and should contain a logical structure
02:42:44 <faxathisia> bart416: Not all short and easy to read code is good, not all good code is short
02:43:00 <bart416> faxathisia, with short I mean no useless statements
02:43:04 <jsnx> bart416: and should be *written* in a logical way
02:43:22 <EvilTerran> APL!
02:43:26 <wy> EvilTerran: Do I only need glut for openning a window?
02:43:34 <bart416> like haskell allows you to define things like y = x and define your x later, if you can you should really try to define your x before your y
02:43:44 <jsnx> wy: i think it gets the mouse pointer, too
02:44:05 <jsnx> bart416: well, no
02:44:15 <faxathisia> bart416: I disagree with that, it's far too general and trivial
02:44:22 <bart416> faxathisia it's a simple example
02:44:28 <faxathisia> example of what?
02:44:32 <EvilTerran> wy, pretty much, yeah. i'd go through your tutorial, see if each function it uses is in OpenGL or GLUT, and, if GLUT, go hunting in gtk2hs for an equivalent :)
02:44:46 <EvilTerran> and ask in here if you can't find one :D
02:44:53 <bart416> faxathisia it's quite logical if you first define what you need and than start working with it
02:45:04 <jsnx> bart416: it's logical, but not clear
02:45:15 <faxathisia> bart416: You should write a scheme interpreter
02:45:18 <EvilTerran> wy, there's a few examples of using gtk2hs with openGL that come with gtk2hs, iirc
02:45:26 <bart416> faxathisia no thanks
02:45:33 <EvilTerran> bart416, i'm a top-down kinda guy, i tend to do the opposite
02:45:40 <wy> EvilTerran: Is there a tutorial based on gtk?
02:45:50 <bart416> EvilTerran the main important thing is grouping similar things
02:45:52 <EvilTerran> not sure
02:45:57 <jsnx> bart416: it really helps you to understand Haskell if you work the "Scheme in 48 Hours" tutorial
02:46:05 <faxathisia> bart416: It would hopefully demonstrate that what you said doesn't make any sense in practice
02:46:14 <hpaste>  tehgeekmeister pasted "inexplicable parse error -- the same code runs in ghci with no error." at http://hpaste.org/4746
02:46:16 <faxathisia> jsnx: I'd recommend SICP over scheme in 48
02:46:28 <jsnx> faxathisia: well, then you have to code in scheme
02:46:38 <jsnx> faxathisia: and it takes a lot longer to do that one
02:46:47 <EvilTerran> tehgeekmeister, do you have a trailing newline? that might cause trouble
02:46:55 <EvilTerran> (or rather, the lack of it might)
02:46:58 <bart416> faxathisia, it's really easier to find back things if you group the similar statements
02:47:05 <bart416> from a debugging perspective
02:47:12 <EvilTerran> what's the parse error, anyway?
02:47:17 <jsnx> good code reads like a paper
02:47:22 <tehgeekmeister> "import Data.Char (digitToInt)\n\nsum $ map digitToInt (show (2^1000))\n" <== exact file
02:47:35 <jsnx> you have an introduction that touches on the important points, and you leave the details for the middle
02:47:41 <bart416> jsnx by that definition not a single programming language that only allows OO structures is good :P
02:47:47 <tehgeekmeister> 19.hs:4:0: parse error (possibly incorrect indentation)
02:47:57 <jsnx> bart416: why?
02:48:11 <bart416> you first need to know what each object does
02:48:19 <jsnx> no
02:48:31 <jsnx> you first need to know what the point of the module is
02:48:51 <jsnx> which maybe only one or two functions, supported by a half dozen objects
02:48:52 <tehgeekmeister> EvilTerran: since it's complaining about an error on the fourth line it's likely that last \n, isn't it?
02:48:56 <bart416> jsnx if you don't know what the object does than it's like reading words you don't understand
02:48:59 <wy> I guess my installation is broken...
02:49:17 <EvilTerran> well, the :0 means it's complaining about an error at the start of the fourth line in particular
02:49:31 <jsnx> bart416: well, no
02:49:54 <jsnx> bart416: if you have to understand what all the objects in your module do to understand the module, it is badly written
02:50:11 <EvilTerran> i dunno ~\(-.-)/~
02:50:13 <jsnx> bart416: just like a paper that only mentioned references without suggesting their relevance
02:50:44 <bart416> objects can contain really specific methods that might not immediatly belong there without actually knowing the entire context they're used in
02:50:48 <faxathisia> bart416, jsnx: In practise when does any of this matter at all?
02:51:02 <tehgeekmeister> i tried retyping the file, since it's so small, and now it's complaining about the end of the third line.  time to try a different editor.  i think my emacs is borked.
02:51:02 <jsnx> faxathisia: when reading the stuff
02:51:20 <jsnx> faxathisia: i've experience more than a little poorly written rubbish
02:51:30 <bart416> jsnx try to work your way through the Qt event system without ever reading the documentation
02:51:45 <faxathisia> jsnx: If you're reading someone elses code it's their code, you're going to have to deal with whatevers there, setting up your own rules so you can claim this code is bad whenever you don't understand part of it isn't beneficial
02:51:50 <jsnx> bart416: well, just so long as i don't have to read every object...
02:52:06 <bart416> jsnx I'm not sure what's longer, the documentation or the qt library code
02:52:06 <jsnx> faxathisia: the rules are for me when i write code
02:52:07 <bart416> xD
02:52:30 <jsnx> faxathisia: they are also a courtesy, in general
02:52:39 <tehgeekmeister> nope, tried retyping it in a different editor, even.  this code must not be correct.  both hugs and ghc complain.
02:52:39 <jsnx> faxathisia: so of course i encourage them
02:52:57 <jsnx> and i am certainly happy when a language enforces them -- like indentation :)
02:53:50 <bart416> tehgeekmeister did you use tabs or spaces?
02:54:01 <jsnx> bart416: the length of natural language texts and code are not really comparable when you are gauging difficulty...
02:54:21 <tehgeekmeister> bart416: spaces.
02:54:30 <bart416> okay, that's not the problem in that case :)
02:54:34 <tehgeekmeister> bart416: in both emacs and vim.
02:54:59 <tehgeekmeister> should there be a final newline?
02:55:09 <bart416> I had to ditch ultra edit cause it didn't like haskell to a certain extend :(
02:55:16 <faxathisia> jsnx: Are you the guy doing NLP?
02:55:39 <bart416> jsnx, no but I'm only saying that objects aren't always clear, even if you know what they're suposed to do
02:55:53 <bart416> and even if they're written well structured
02:56:15 <bart416> and completly commented and there is easy to understand documentation
02:57:11 <jsnx> faxathisia: there's a guy doing that?
02:59:29 <fnord123> doesnt ultraedit cost money?
02:59:35 <bart416> yeah
02:59:45 <fnord123> isn't vim free?
02:59:49 <bart416> worth it though in my opinion :S
03:00:22 <jsnx> i think this has all gone too far
03:00:32 <bart416> probably
03:00:32 <jsnx> i apologize for taking things in this direction
03:00:45 * bart416 as well, other subject now?
03:01:17 <bart416> fnord123 ultra edit has a few nice features that most editors don't have
03:01:21 <bart416> well most windows editors don't have it
03:01:44 <jsnx> tehgeekmeister: i get parse error in ghci when i try to run that code
03:02:39 <tehgeekmeister> jsnx: if Data.Char is already imported, i get the answer, and no errors or warnings or anything.
03:02:49 <jsnx> tehgeekmeister: ah, okay
03:02:55 <tehgeekmeister> > sum $ map digitToInt (show (2^1000))
03:02:57 <jsnx> tehgeekmeister: what error do you get, otherwise?
03:03:31 <tehgeekmeister> jsnx: 19.hs:4:0: parse error (possibly incorrect indentation)
03:03:34 <faxathisia> sum $ map Data.Char.digitToInt (show (2^1000))
03:03:36 <faxathisia> works for me
03:04:18 <tehgeekmeister> faxathisia: doesn't fix it here.
03:04:54 <tehgeekmeister> i'm using ghc 6.6.1 from macports, are you all using that or something else?
03:05:15 <tehgeekmeister> (well, same version, not necessarily from macports =] )
03:10:04 <jsnx> tehgeekmeister: dude, that is so last year
03:10:42 <tehgeekmeister> i don't like messing with binary installs unless they're in a package manager.
03:10:50 <fnord123> > sum $ map Data.Char.digitToInt (show (2^1000))
03:12:16 <fnord123> fwiw, it works on my 6.6.1 ghci
03:12:46 <tehgeekmeister> it works in ghci for me too.
03:13:11 <tehgeekmeister> it doesn't work if i put it in a file and then try to compile it/load it in ghci
03:15:03 <fnord123> do you export it?
03:15:24 <sylvan> @paste
03:15:41 <tehgeekmeister> export what?
03:16:17 <tehgeekmeister> oh.  it's not even a function, so ghci might not like it.
03:16:24 <tehgeekmeister> it needs to be in main or be a function definition.
03:16:48 <jsnx> fnord123: he does not need to export it unless he puts it in a module
03:17:07 <tehgeekmeister> just making it into a function solves it.
03:17:07 <jsnx> tehgeekmeister: you can just say `theAnswer = <blah blah blah>`
03:17:16 <tehgeekmeister> yeh, that's what i did.
03:17:23 <jsnx> lolz
03:17:30 <jsnx> none of us could figure it out!
03:17:40 <tehgeekmeister> i forgot i had to do that -- looked at a bunch of ruby and python today, it corrupted my brain.
03:17:51 <tehgeekmeister> that's a really bad error message considering what the problem was.
03:17:59 <jsnx> tehgeekmeister: yes
03:18:13 <sylvan> I get an error trying to install HDBC. The HDBC package worked fine, but when I tried to install HDBC-odbc i get the errors here: http://hpaste.org/4747 Any ideas?
03:20:17 <fnord123> Do you have odbc drivers installed? It looks like it can't find the appropriate C header so it can wrap the functions in the FFI.
03:21:25 <sylvan> Ah no idea actually... I'm trying to install it on a site hosted by nearlyfreespeech.net. It has MySQL and the HDBC website said to use odbc for it...
03:21:52 <sylvan> how can I found out if it supports odbc?
03:22:30 <jsnx> sylvan: one way is to email tech support
03:22:51 <fnord123> that's one way
03:23:00 <sylvan> Right. I figured if there was some odbc utility or something that should be installed if it's supported
03:23:11 <jsnx> sylvan: just a sec
03:23:48 <fnord123> if they do have it installed, you may not have the library paths set up for Setup.hs to find it.
03:25:19 <jsnx> sylvan: http://rafb.net/p/ZjLmPo84.html
03:25:31 <jsnx> sylvan: that's all the files
03:25:38 <sylvan> thanks
03:26:54 <tehgeekmeister> some of these project euler problems, you really have to wonder how they made it in.  they're just way too easy.  summing the digits of numbers?  really?
03:27:03 <jsnx> sylvan: use `locate` or `find`
03:27:33 <jsnx> tehgeekmeister: in haskell, they are much easier than other languages, though
03:27:49 <jsnx> well, i suppose in ruby those problems are even easier
03:27:59 <jsnx> if your program finishes running...
03:28:08 <tehgeekmeister> jsnx: yes, but in any of the reasonably high level languaages these are easy.
03:28:17 <jsnx> tehgeekmeister: even C?
03:28:30 <jsnx> tehgeekmeister: or is that not reasonably high level...
03:28:35 <tehgeekmeister> note i said *reasonably* high level.
03:28:42 <jsnx> tehgeekmeister: Java?
03:28:57 <tehgeekmeister> i've never used it.
03:29:04 <jsnx> somehow, i think a list of list of numbers would be a pain in java
03:29:14 <jsnx> i think that's why they make it in
03:29:28 <tehgeekmeister> you don't need a list of a list of numbers/
03:29:30 <tehgeekmeister> *?
03:29:32 <jsnx> because of the impedance mismatch with common programming languages
03:29:42 <jsnx> tehgeekmeister: sometimes you do
03:29:56 <jsnx> tehgeekmeister: don't tell me which problem
03:30:06 <tehgeekmeister> not for the problems i was mentioning.
03:30:08 <sylvan> crap, doesn't look like it's there. Is there any other way to access MySQL in Haskell?
03:31:17 <jsnx> the target machine has haskell, but not odbc?
03:32:17 <sylvan> yes, appears so
03:33:30 <fnord123> ok I can see sql.h in /us/include/ but Connection.hsc is complaining about not finding it.
03:36:12 <sylvan> fnord123, if you're talkinb agout that list of files that jsnx posted then that's not from the system where I'm trying to install this, it's his system. There's no sql.h in /usr/include here
03:38:21 <fnord123> ah ok. also you can use pkg-config --list-all | grep odbc to see if it's installed
03:39:32 <sylvan> [me@ssylvan /usr/local/include/postgresql]$ pkg-config --list-all | grep odbc
03:39:32 <sylvan> Variable 'datarootdir' not defined in '/usr/local/libdata/pkgconfig/zzipfseeko.p          c'
03:39:48 <sylvan> weird
03:42:10 <sylvan> Doesn't look like ODBC is installed... So does anyone know of any other way to access a MySQL database from Haskell?
03:45:36 <tehgeekmeister> what's a simple way to convert a [Int] into a [(Int,Int)] where the new int is the index of the pair in the list?
03:47:20 <sylvan> tehgeekmeister : zip [0..]
03:47:40 <tehgeekmeister> sylvan: that's beautifully simple.
03:47:43 <tehgeekmeister> thanks.
03:47:46 <sylvan> np
04:04:16 <tehgeekmeister> what's the function for splitting a list/string on a particular value?
04:04:33 <EvilTerran> break/span?
04:04:47 <faxathisia> @docs Data.List
04:04:55 <EvilTerran> > (break . (==)) 'd' "abracadabra"
04:05:05 <EvilTerran> hm
04:05:10 <faxathisia> ("abraca","dabra")
04:05:24 <EvilTerran> ghci> break (=='d') "abracadabra"
04:05:24 <EvilTerran> ("abraca","dabra")
04:05:33 <EvilTerran> drat, beaten to it.
04:05:34 <tehgeekmeister> how about for splitting on all occurrences of the value?
04:05:42 <EvilTerran> parsec ;)
04:05:46 * faxathisia was pretending to be lambdabot
04:05:55 <EvilTerran> faxathisia: @bot
04:05:59 <faxathisia> :)
04:06:03 <EvilTerran> hehe
04:06:26 <tehgeekmeister> EvilTerran: overkill for splitting at newlines, no?
04:06:32 <EvilTerran> oh, newlines? unlines
04:06:37 <EvilTerran> er, lines, rather
04:06:46 <EvilTerran> > lines "foo\nbar\n\nbaz\n"
04:06:51 <EvilTerran> grr
04:06:59 <EvilTerran> ["foo","bar","","baz"]
04:07:19 <faxathisia> unlines
04:07:24 <EvilTerran> but there isn't a general function to do it, because people couldn't agree on functionality
04:07:27 <faxathisia> oh.. ou already said i
04:07:36 <EvilTerran> faxathisia, nah, unlines puts 'em back together. lines is the one.
04:08:38 <tehgeekmeister> hmm.  well, i guess considering all the stuff the prelude does give me, i can overlook that gap.  i'm always surprised how much is already in the prelude.
04:13:57 <EvilTerran> ghci> let splitOn p [] = [[]]; splitOn p (x:xs) = (if p x then ([]:) else id) ((x:s):ss) where s:ss = splitOn p xs
04:13:57 <EvilTerran> ghci> splitOn isDigit "foo1bar23baz4"
04:13:57 <EvilTerran> ["","f","o","o1","b","a","r23","b","a","z4"]
04:14:05 <EvilTerran> is how i tend to do it
04:14:18 <EvilTerran> er, that last line should be ["foo","1bar","2","3baz","4"] -- pasting the wrong stuff here :P
04:15:01 <oerjan> > groupBy (const isDigit) $ "foo1bar23baz4"
04:15:04 <tehgeekmeister> sorry, i've forgotten since it's been so long since i've done this -- what do i need to do to map inside a monad, for example once i've read the file in and converted the lines to a list of lines, and i now want to map over that list -- what monad magic do i need to make that work?
04:15:10 <oerjan> @bot
04:15:17 <oerjan> ayeeh!
04:15:33 <oerjan> tehgeekmeister: mapM
04:15:54 <EvilTerran> ghci> groupBy (const $ not.isDigit) $ "foo1bar23baz4"
04:15:54 <EvilTerran> ["foo","1bar","2","3baz","4"]
04:15:56 <oerjan> assuming your map isn't pure
04:16:20 <oerjan> not? oh right
04:16:31 <EvilTerran> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
04:17:05 <oerjan> but if your map is pure, just use the ordinary map
04:17:11 <tehgeekmeister> it is pure.
04:17:13 <tehgeekmeister> okay.
04:18:21 <tehgeekmeister> that's not working, expected type is [b] and actual type is IO a
04:18:29 * tehgeekmeister hpastes
04:19:04 <kpreid> I bet you want liftM map
04:19:16 <kpreid> rather, liftM (map f)
04:19:26 <oerjan> that's quite likely
04:20:12 <hpaste>  tehgeekmeister pasted "IO monad difficulties." at http://hpaste.org/4748
04:20:31 <oerjan> ah
04:20:33 <tehgeekmeister> it seems like i should need to lift
04:20:35 <oerjan> just need return
04:20:46 <faxathisia> tehgeekmeister: What is inside 13.txt?
04:20:50 <EvilTerran> return . map read . lines $ contents
04:21:11 <oerjan> the liftM way would be:
04:21:35 <oerjan> answer = liftM (map read . lines) (readFile "13.txt")
04:21:43 <EvilTerran> answer = map read . lines `liftM` readFile "13.txt"
04:21:52 <EvilTerran> (or `fmap`, or <$>)
04:21:59 <tehgeekmeister> faxathisia: a list of numbers, which i'll be summing once i get the list of lines into a list of ints.
04:22:07 <faxathisia> tehgeekmeister: Show me?
04:22:40 <oerjan> actually...
04:22:51 <oerjan> > (0$0 `liftM`)
04:22:53 <oerjan> argh
04:23:24 <oerjan> liftM has no defined fixity, so it may not be compatible with .
04:23:44 <oerjan> (default: infixl 9, while . is infixr 9 iirc)
04:23:53 <hpaste>  tehgeekmeister annotated "IO monad difficulties." with "Now including 13.txt" at http://hpaste.org/4748#a1
04:23:54 <EvilTerran> tehgeekmeister, incidentally, i'd recommend using, say, readDec instead of read for that; it copes better with failure, and is faster, as it's specifically for integer types
04:24:47 <oerjan> well readDec = reads isn't it
04:25:13 <EvilTerran> well, yes. only with a more specific type.
04:25:19 <oerjan> oh and readDec chokes on signs
04:25:24 <EvilTerran> mmm
04:25:37 <hpaste>  faxathisia annotated "IO monad difficulties." with "search and replace" at http://hpaste.org/4748#a2
04:25:37 <EvilTerran> it's probably faster than reads, too
04:25:49 <faxathisia> The end got cut off
04:25:51 <faxathisia> you can see what I mean though?
04:25:56 <EvilTerran> it already had been, i think
04:25:59 <faxathisia> then put that in number.hs
04:26:00 <EvilTerran> OTOH, pwn
04:26:17 * EvilTerran has done that for a few project euler problems
04:26:27 <faxathisia> because then you can avoid touching IO
04:26:32 <oerjan> readSigned readDec is the thing
04:26:51 <tehgeekmeister> faxathisia: yea, i thot about doing that, but figured it'd be worth the extra hassle to get some practice with io again.
04:27:14 <faxathisia> That sounds like wrong, but as you please
04:27:49 <EvilTerran> (question 67, with the triangle of numbers, being a notable example)
04:28:15 <oerjan> instance Read Int where readsPrec p = readSigned readDec
04:30:28 <tehgeekmeister> faxathisia: i don't mind doing a bit of extra work sometimes, because i don't get the chance to program very often, i'd like to maximize my exposure to various parts of the language/aspects of programming when i do.
04:30:55 * EvilTerran , while looking through his old PE solutions, comes across an instance Integral a => Num [a] he wrote a while ago
04:31:47 <faxathisia> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/mark.pdf
04:32:57 <tehgeekmeister> faxathisia: i've been meaning to read that lately, perhaps now's the time.
04:33:48 <EvilTerran> (base 10 little-endian numbers, apparently; i'd've thought adding the appropriate constraint and using maxBound would be better, but ah well. it did the job.)
04:45:18 <Taejo> > scanr (+) [1..5]
04:46:25 <oerjan> Type error
04:46:31 <Taejo> yeah
04:46:39 <Taejo> why no error though?
04:46:54 <EvilTerran> lambdabot: @bot
04:46:56 <oerjan> because lambdabot is sleeping, or something
04:47:02 <EvilTerran> she's not feeling well
04:47:23 <Taejo> @src foldr
04:48:21 <EvilTerran> foldr f e [] = e
04:48:34 <EvilTerran> foldr f e (x:xs) = f x (foldr f e xs)
04:48:48 <EvilTerran> that def's nicer than lambdabot's, even :)
04:49:14 <Taejo> EvilTerran: I agree; doesn't \bot's have some funky `go` function?
04:49:28 <EvilTerran> yeah. some optimisation thing, i think
04:49:33 <EvilTerran> go = foldr f
04:49:39 <EvilTerran> er, foldr f e, even
04:56:55 <Taejo> can anybody put this into full pointless form:
04:56:57 <Taejo> (f .:) = ((f .) .)
04:57:12 <Taejo> (I mean, what is (.:) in pointless form?)
04:58:37 <EvilTerran> (f.) = (.) f
04:58:51 <oerjan> (.).(.)
04:58:59 <EvilTerran> so (f .:) = ((f.).) = (.) (f.) = (.) ((.) f) = (.).(.)
04:59:03 <EvilTerran> f
04:59:47 <Taejo> thanks
05:00:09 <Taejo> do others find that a useful combinator too?
05:00:21 <wy> gosh. Why can't I ever make ghc twice?
05:01:17 <oerjan> no one can make the same version of ghc twice.  that's why they keep putting out new versions.
05:02:38 <wy> It seems that's because I used the new ghc to make itself. That doesn't work
05:04:53 <b_jonas> lol
05:05:40 <b_jonas> @pl \f -> ((f .) .)
05:05:43 <wy> So I guess the versions of ghc use quite different internal format
05:10:10 <EvilTerran> Taejo, what, (.:)? yeah, that's a pretty common one
05:16:56 <Taejo> if I have a parameterised data type (say, Tree t), can I limit t to instances of a certain class (say, Eq)
05:17:28 <faxathisia> something like Eq t =>
05:17:44 <oerjan> it will only affect the constructor function though
05:18:00 <Taejo> oerjan: what do you mean?
05:18:05 <Taejo> faxathisia: where?
05:18:21 <oerjan> you still will have to put Eq t on all other declarations
05:18:32 <Taejo> ok
05:19:52 <EvilTerran> the behaviour isn't what you'd expect, mind
05:20:24 <EvilTerran> iirc, the syntax is data Foo a = Eq a => Foo a | Ord a => Bar a | ...
05:20:24 <Taejo> EvilTerran: in what way?
05:20:58 <EvilTerran> there's something funny about how it affects type inference
05:21:22 <faxathisia> What is meant by  higher order type operator?
05:21:43 <oerjan> it _only_ affects the type of the constructor function, iirc
05:22:13 <EvilTerran> not sure exactly of the details... ISTR, instead of the class constraint being used to infer other types in expressions where the constructor is used, it merely complains that those constraints aren't there
05:23:21 <oerjan> it's data Eq a => Foo a | Bar a, btw
05:23:31 <oerjan> er no
05:23:38 <EvilTerran> "data Foo a = Eq a => Foo a" WFM
05:23:39 <oerjan> it's data Eq a => Foo a = Foo a | Bar a, btw
05:24:03 <EvilTerran> altho it may do something else
05:24:58 <oerjan> i don't think that's H98
05:31:37 <Taejo> why doesn't QuickCheck define an Arbitrary instance for Chars?
05:31:59 <oerjan> @check \c -> isAlpha c
05:32:03 <oerjan> argh!!
05:32:09 <oerjan> come back lambdabot!
05:32:37 <oerjan> i mean, i distinctly saw lambdabot using one the other day.  try upgrading.
05:32:41 <Taejo> No instance for (Arbitrary Char)
05:32:49 <Taejo> ah, ok
05:33:53 <Taejo> sadly, no 6.8 in ubuntu repos
05:34:10 <oerjan> lambdabot is not 6.8 yet afaik
05:34:50 <Taejo> well, in 6.6.1, there is no instance
05:35:10 <oerjan> i mean upgrading just QuickCheck
05:35:18 <Taejo> oh, ok
05:36:15 <oerjan> hm wait
05:36:28 <Taejo> why is this illegal? instance (Enum a) => Arbitrary a where
05:36:32 <Taejo> ...
05:36:33 <oerjan> there's no Char instance listed on the docs page either...
05:36:52 <oerjan> that would overlap with every other instance
05:37:09 <oerjan> the context is only checked after lookup
05:38:32 <oerjan> you probably want a Bounded constraint too
05:38:39 <Taejo> true
05:38:43 <visof> how can we represent the complex number in haskell?
05:38:51 <oerjan> visof: Data.Complex
05:39:35 <oerjan> typically the type is Complex Double
05:39:58 <visof> how can i use it?
05:40:16 <Taejo> import the Data.Complex module
05:40:17 <visof> :l Data.Complex?
05:40:33 <Taejo> :m
05:40:44 <visof> ok
05:40:57 <Taejo> the constructor is :+
06:10:13 <faxathisia> anyone read thsi http://citeseer.ist.psu.edu/119954.html ?
06:56:41 * pgavin is back (gone for 10:47.15)
06:56:48 * pgavin is back
06:57:06 <tiglionabbit> hi
06:57:43 <kpreid> hi.
06:58:28 <tiglionabbit> this is part of the source code to yaws, written in erlang: http://rafb.net/p/iwbMKt35.html .  I ask you, is this good code?
07:02:03 <oerjan> um, ask in an erlang channel?
07:02:29 <tiglionabbit> already did.  They seemed to think it was just fine.  I think it's awful :B
07:03:09 <tiglionabbit> the repetition is just ridiculous
07:04:11 <oerjan> it probably could use a map, yes
07:04:24 <tiglionabbit> exactly
07:05:40 <oerjan> although it would probably need reified field names, somehow.
07:06:00 <oerjan> but being dynamic, erlang probably has those
07:06:29 <tiglionabbit> reified?
07:07:04 <oerjan> you want to pass a list of those lookup fields
07:07:19 <oerjan> and then do lookups and assignments in a function
07:07:56 <oerjan> for example, you couldn't do it directly with haskell data record fields
07:08:09 <oerjan> (although a Data.Map should be close enough)
07:08:19 <kpreid> oerjan: for additional context, according to the erlang channel, that particular code was micro-optimized -- this being the most efficient way to implement that.
07:08:24 * kpreid is just a bystander
07:08:37 <oerjan> aha, so it is essentially unrolled
07:08:55 <oerjan> well for that the code is probably better than a list
07:09:20 <oerjan> although a good compiler should be able to produce equivalent code from a list version
07:09:36 <tiglionabbit> what does that mean, micro-optimized?  Is there an original version anywhere?
07:09:45 <Cin> is it possible for one thread to read from a handle and one thread to write to it?
07:09:57 <Cin> simultaneously?
07:10:25 <pgavin> Cin: do you want the reader to get the data that the writer wrote?
07:10:50 <Cin> pgavin: no. it's a socket. i want one thread to read from it, and another to write to it
07:10:56 <Cin> pgavin: is it possible?
07:11:00 <pgavin> Cin: oh, that should be fine
07:11:07 <oerjan> tiglionabbit: i guess it's sort of like the difference between haskell and ghc core - the latter is a greatly optimized and expanded version of the former
07:11:29 <Cin> pgavin: ah, good. i've looked on the docs of System.IO and couldn't fine anything about thread safety!
07:11:38 <Cin> pgavin: with respect to Handle, that is
07:11:55 <pgavin> Cin: I'm not positive about that, but it should be safe
07:11:57 <oerjan> except that in this case the expansion has been done by hand, perhaps
07:12:18 <pgavin> Cin: if your program crashes, you can put the handle in an mvar so only one thread can use it at a time
07:12:51 <tiglionabbit> oerjan: exactly.  personally, I think coding like this should be a crime
07:13:54 <Cin> pgavin: yeah! that's what i've got at the moment to be on the safe side. i guess i could test it without but it may just work out of fluke? heh
07:13:56 <tiglionabbit> but then, I use ruby.  What do I know :B
07:14:13 <Cin> :F
07:14:14 <oerjan> tiglionabbit: a good macro system like scheme/lisp should also help
07:14:23 <tiglionabbit> =]
07:15:49 <pgavin> Cin: maybe check out the source code for the IO library :)
07:16:00 <oerjan> tiglionabbit: this is probably from a library?  even in ghc base you can find things that have been expanded for efficiency
07:16:05 <Cin> pgavin: good idea :P
07:16:30 <tiglionabbit> oerjan: it's from yaws
07:16:32 <tiglionabbit> the server
07:17:02 <oerjan> e.g. the definition of concatMap is explicitly in terms of foldr, rather than combining concat and map like the haskell report does
07:17:02 <tiglionabbit> I'm looking at it because I ran yaws just now and it did some stupid things, and the erlang people were like "fix it yourself"
07:18:17 <Cin> :(
07:19:54 <oerjan> tiglionabbit: if this code is actually compiled/interpreted on the fly, then it makes some more sense to pre-expand it i think, you want it to load fast
07:20:07 <tiglionabbit> it's not
07:20:20 <tiglionabbit> you compile this code
07:20:51 <oerjan> ic
07:26:35 <tiglionabbit> this is something I dragged out of the same file.  http://rafb.net/p/dfZ7h929.html   Huzzah repetetion.  How would you turn this into 3 lines of haskell or scheme?
07:27:34 <oerjan> that one is rather easy
07:28:01 <oerjan> data Month = Jan | Feb | ... | Dec deriving (Show, Read, Enum)
07:28:44 <oerjan> month n = show (toEnum n :: Month)
07:29:11 <oerjan> month_str_to_int ms = fromEnum (read ms)
07:29:48 <oerjan> although in haskell you probably would often want to use Month directly rather than convert to Int
07:29:56 <oerjan> hm wait
07:30:01 <oerjan> off-by-one error
07:30:09 <oerjan> indices start with 0, but easy to fix
07:30:17 <tiglionabbit> just add a bogus month at the start?
07:30:25 <tiglionabbit> or +1
07:30:26 <olsner> month = (months !!) . subtract 1; monthStrToInt = add 1 . fromJust . flip elemIndex months
07:30:32 <oerjan> +1 is cleaner
07:30:49 <biribau> hi, Prolog question have site here? anyone knows, only about basics, principiant programmer
07:31:09 <oerjan> olsner's is another way, if you don't want a datatype
07:32:03 <tiglionabbit> is !!  O(1) ?
07:32:06 <oerjan> no
07:32:14 <oerjan> might want ! and an Array instead
07:32:23 <LoganCapaldo> not even a little bit
07:32:51 <LoganCapaldo> O(n) isn't exactly a nightmare when n is fixed at 12
07:33:18 <LoganCapaldo> might as well be O(1) w/ a "large" constant
07:33:35 <oerjan> anyway, bye
07:34:03 <tiglionabbit> yeah, but I'd like this to be a better solution than month(1) -> "Jan"
07:34:47 <wy__> I found sometimes my ghci will give out this king of prompt. I don't know why. Prelude Main>
07:35:21 <LoganCapaldo> you have the prelude loaded and the main module loaded
07:35:33 <LoganCapaldo> the things to the left of the > are all the loaded modules
07:35:37 <wy__> It used to by Main>
07:35:48 <wy__> I don't know why this happens
07:36:28 <olsner> tiglionabbit: hmm, but what says that a series of pattern matches won't give you a linear search anyway?
07:36:51 <tiglionabbit> oh crap, it probably will!
07:37:09 <tiglionabbit> in fact, that is the way erlang implements it
07:37:29 <wy__> Now it displays *Main> again
07:37:32 <tiglionabbit> that is funny
07:37:52 <LoganCapaldo> it could (not saying it does) but it could do it as a jump table for types with nullary constructors
07:38:35 <LoganCapaldo> also if it's church encoded it's O(1) I guess assuming function pplication is O(1) (that's probably  false assumption though)
07:38:55 <LoganCapaldo> *with only nullary
07:40:30 <olsner> LoganCapaldo: you mean to implement integers 1..12 as a set of functions taking 12 functions?
07:41:56 <LoganCapaldo> yeah
07:52:10 <conal> @botsnack
07:52:20 <conal> is lambdabot down?
07:53:31 <gbacon> @botsnack
07:56:36 <Botje> lambdabot has a tummy-ache from eating too much botsnacks I think.
07:58:01 <Heffalump> or a hangover from NY
07:58:47 <Botje> but she only does point-free drinks! :)
07:59:57 <glen_quagmire> :t join
08:00:29 <allbery_b> bot's dead
08:00:35 * allbery_b thinks it choked on a url
08:00:40 <allbery_b> mine does that
08:00:41 <Botje> just resting.
08:00:45 <glen_quagmire> @reboot
08:00:52 <DuClare> hah
08:01:11 * gbacon thought it had a fairly quick timeout
08:01:45 * conal suspects the y2k+8 bug
08:02:10 <gbacon> dratted side-effects
08:02:17 <glen_quagmire> y2k8 bug can be fixed by reading the 32bit integer as octal
08:03:39 <allbery_b> * gbacon thought it had a fairly quick timeout
08:04:05 <allbery_b> it does, but there's a bug somewhere in the network library (we suspect an incorrectly tagged ffi call)
08:04:33 <glen_quagmire> is there a way to call C function without writing any C code?
08:04:44 <gbacon> dirty, dirty imperative code :-)
08:04:48 <glen_quagmire> let's say I have a compiled C library. in python, there's ctype or something
08:04:58 <allbery_b> c2hs
08:05:11 <allbery_b> hsc2hs, which comes with ghc
08:05:59 <glen_quagmire> gorate
08:32:11 <cached> is there a shell for Haskell (kind of like how there is one for python?) and if so do I need a certain package for it?
08:33:23 <DuClare> what kind of a shell?
08:33:28 <lnxz> ghci?
08:33:41 <DuClare> probably
08:33:54 <olsner> if you install ghc, you also get ghci (ghc interactive)
08:34:19 <cached> alright
08:34:20 <cached> thanks
09:06:07 <conal> would someone please remind me what a final "+" means in unix-like permissions, such as "-rwxr--r--+"
09:07:57 <allbery_b> conal: there are POSIX ACLs
09:08:15 <allbery_b> try running getfacl
09:10:31 <conal> allbery_b: thanks.  i'm suddenly getting some weird behavior with file permissions (under cygwin).  some of my files are coming out r-x for user.
09:10:51 <conal> "getfacl ." says "default:other:r-x" at the end.
09:11:16 <allbery_b> oh, this is cygwin?  all bets are off, then
09:11:25 <conal> but user, group, and mask say rwx.
09:11:27 <conal> yep, cygwin.
09:11:31 * allbery_b assumes that indicates non-unix-like NTFS permissions
09:12:11 <conal> aha! there's a #cygwin.
09:32:39 * pgavin is back (gone for 01:28.36)
09:32:46 * pgavin is back
09:37:12 <loupgaroublond> what does this haddock error mean:  parse error in doc string: [haddock: EOF token
09:38:07 <Igloo> It sounds like you didn't close some doc markup
09:40:35 <loupgaroublond>  -- | q /=? x. if the result of q equals x, return False     <-- the comment
09:40:57 <Igloo> The / at least needs to be escaped (with \)
09:41:20 <loupgaroublond> ah
09:41:23 <loupgaroublond> thanks :)
09:45:14 <LoganCapaldo> mmm I want fish
09:56:53 <EvilTerran> (><||*>) :: Stream a -> ...
09:59:07 <Anon3146> xd
10:16:28 * benny99 greets
10:51:17 * pgavin is back (gone for 00:41.14)
10:58:09 <nolrai> > LiftM2 + $ [1] [2]
10:58:20 <nolrai> > (LiftM2 +) [1] [2]
10:58:32 <nolrai>  > (LiftM2 +) [1] [2]
10:58:40 <nolrai> > (LiftM2 +) [1] [2]
10:58:48 <nolrai> > 1 + 2
10:59:03 <nolrai> @ty 1
11:00:10 <nolrai> is lambdabot working?
11:01:12 <nolrai> > 1 + 2
11:02:00 <nolrai> is my irc client working?
11:02:04 <lakupuu> no
11:02:37 <doserj> it would be "liftM2 (+)", btw...
11:03:01 <nolrai> is it my irc or lambadabot?
11:04:05 <nolrai> that isnt working.
11:04:34 <nolrai> doserj: thanks
11:06:20 <FunctorSalad> the gentle intro says that "(The name main is special only in the module Main; we will have more to say about modules later.)", but this doesn't seem to be the case
11:06:41 <FunctorSalad> that is, how should the main function be called in a different module?
11:08:01 <allbery_b> why would you want to?  different modules would usually be libraries, not main programs
11:08:47 <moosefish> FunctorSalad: I'm not convinced there's an easy way to convince GHC to link an executable unless there's a Main module anyway
11:09:15 <Saizan> -main-is Foo
11:09:20 <moosefish> actually, see http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
11:09:23 <moosefish> yeah, what Saizan just said
11:09:35 <FunctorSalad> I wanted to make my module executable so that I can run it in hat
11:09:36 <moosefish>  (assuming GHC, obviously)
11:11:21 <FunctorSalad> Saizan: thanks, this version of -main-is should work: "An module name A. GHC assumes that the main function is A.main"
11:11:27 <moosefish> Template Haskell doesn't have access to the parse tree, does it?
11:12:13 <Saizan> moosefish: you use quoting brackets for that, $(macro [| code.. |])
11:13:10 <moosefish> Saizan: I mean the existing parse tree. So for example, I could get a list of all existing function names starting with "test_" in the module before the template haskell snippet.
11:13:10 <Saizan> [| |] is for expressions, [d| |] for declarations, and [t| |] for types iirc
11:14:10 <moosefish> (and generate the horribly redundant test running main() function that follows all my *Test.hs files)
11:14:44 <Saizan> then no, i don't think so
11:15:08 <moosefish> Didn't find anything after perusing the papers either.
11:17:16 <Saizan> at this point it's easier with a preprocessing script
11:17:33 <moosefish> yeah, that's what I've got right now, a quick perl wrapper
11:18:35 <FunctorSalad> hmm, I put the main function for testing in a different file, but it still isn't exectuable
11:19:37 <Saizan> so you have module Main where\n main = ...?
11:19:39 <runar> @seen dons
11:20:04 <runar> Is lambdabot angry with me?
11:20:16 <FunctorSalad> Saizan: yes, well I have module Main where\n import ...\n main= ...
11:20:41 <allbery_b> LB doesn't like anyone right now
11:20:49 <allbery_b> possibly drank too much last night :)
11:21:07 <Saizan> FunctorSalad: are you compiling with ghc --make? or it's that an hat error?
11:21:38 <FunctorSalad> ok, with ghc it works. was using hmake
11:21:46 <visof> how can i put lambdabot in my own channel?
11:22:01 <allbery_b> @version
11:22:08 <allbery_b> whoops, duh :)
11:22:30 <allbery_b> <lopbot> lambdabot 4p551, GHC 6.6.1 (Linux i686 3.20GHz)
11:22:30 <allbery_b> <lopbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:22:39 <allbery_b> except I thnk it's on code.haskell.org now
11:22:44 <Saizan> yeah http://code.haskell.org/lambdabot
11:22:56 <phobes> So who is 'Keal'?  A troll?
11:23:04 <allbery_b> unfortunately the instructions aren't quite user-friendly
11:23:09 <allbery_b> yes
11:23:12 <nolrai> whats the terms for functions that are defined as part of a language as opposed to being defined using the language?
11:23:27 <conal> nolrai: "primitive"
11:23:31 <runar> I got lambdabot, but I'm having trouble compiling it.
11:23:35 <nolrai> thanks
11:23:43 <phobes> What was his shtick?
11:23:46 <conal> nolrai: "primitive" vs "defined".  perhaps others.
11:23:47 <allbery_b> he used to cause problems here, these days he's been doing his thing on cognet instead
11:24:35 <allbery_b> @keal
11:24:39 <allbery_b> dug
11:24:43 * allbery_b thwaps himself :)
11:24:48 <conal> lol
11:25:08 <gbacon> neither pugs nor lambdabot want to build for me on Ubuntu
11:25:11 <gbacon> :-(
11:25:12 <allbery_b> <lopbot> i can explain why something is without knowing what the rules decided by man are
11:25:55 <monochrom> Reminds me of a scene in Lord of The Rings. "But I am no man!"
11:26:11 <allbery_b> I haven't been able to build pugs in several months, it's building a wrapper for ghc-pkg which darcs ghc hates
11:27:48 <phobes> monochrom:  I thought that would have been a better scene if her attempt had failed, and he had explained to her as she lie dying that it really meant "man or woman"
11:28:02 <gbacon> the pugs build chokes for me trying to read dist/setup-config
11:28:16 <gbacon> is that a cabal version mismatch problem?
11:28:22 <FunctorSalad> phobes: hehe
11:28:30 <hpaste>  runar pasted "Error compiling dependencies for lambdabot" at http://hpaste.org/4752
11:28:31 <allbery_b> that's a secondary failure
11:28:39 <FunctorSalad> phobes: in a really sober smartass voice suddenly :)
11:28:45 <allbery_b> configure is dying, so setup-config isn't created
11:28:47 <FunctorSalad> (the nazgul I mean)
11:28:58 <phobes> ya :)
11:29:01 <allbery_b> it's the preceding configure failures that are the real problem
11:29:10 <gbacon> oh, missing pugs-hsregex -any, pugs-HsSyck -any
11:29:17 <monochrom> It was a bug in the magic.
11:29:54 <allbery_b> if it's the same problem I've been having, the fghc-pkg-wrapper pugs configure uses omits all the global packagesm so everything dies trying to find package main, etc.
11:32:27 <monochrom> Interesting, only 6 new messages on haskell-cafe today
11:33:12 <Igloo> Aahhh, bliss  :-)
11:39:04 <runar> Do you know what the problem is with plugins? Can I bypass that somehow and compile lambdabot anyway?
11:42:52 <gbacon> runar: you seeing the same problem with PackageAPI.hs?
11:43:08 <runar> yes
11:43:31 <gbacon> are you trying to build from the tarball or darcs repo?
11:43:46 <runar> both
11:43:52 * gbacon frowns
11:43:52 <runar> I get the same error either way
11:45:33 <runar> can you compile it?
11:45:48 <runar> can you compile hs-plugins, that is?
11:45:53 <gbacon> nope
11:45:57 <runar> grr
11:46:22 <allbery_b> hs-plugins won't work with anything newer than ghc 6.6.1
11:46:35 <runar> Drat.
11:46:36 <zeno> is [1|_<-100] the mose sucient way to get a list of 100 1s?
11:46:37 <allbery_b> and may have problems with the new cabal
11:46:42 <sieni> it would be nice if hs-plugins were part of mainline ghc
11:46:52 <allbery_b> zeno: replicate 100 1
11:46:59 <zeno> thx
11:47:08 <markstos> beginner question: How can I cast something to a string, assuming the underlying type supports it?
11:47:13 <allbery_b> show
11:47:30 <allbery_b> show: Show a => a -> String
11:47:41 <allbery_b> read: Show a => String -> a
11:47:49 <gbacon> runar: I wonder if soemone forgot to add a file to the repo
11:48:01 <sylvan> Holy crap. Remember how I came here a few hours ago trying to install HDBC-odbc and coming to the conclusion that my host (nearlyfreespeech) didn't have ODBC installed? Well I posted on the member forum and they installed it right away. Pretty decent service! Even got WASH up and running!
11:48:09 <gbacon> I don't see a definition of InstalledPackageInfo anywhere
11:48:12 <markstos> allbery_b: Thanks!
11:48:56 <runar> import Distribution.InstalledPackageInfo
11:49:10 <runar> It should be coming from Cabal
11:49:11 <allbery_b> that's part of Cabal
11:49:12 <gbacon> allbery_b: I'm running 6.6.1
11:49:47 <runar> So it looks like a Cabal compatibility problem.
11:49:54 <allbery_b> what version of Cabal?  if you updated to get compatibility with the new packages, that'll be breaking things
11:50:12 <runar> Yea, I updated cabal.
11:50:15 * runar flogs himself
11:50:58 <gbacon> I have Cabal-1.1.3, Cabal-1.1.6.2, Cabal-1.3
11:51:10 <gbacon> choose your poison! :-)
11:51:58 <gbacon> so is there a way to bind it to a particular version?
11:52:08 <allbery_b> you could try specifying Cabal-1.1.3 in the dependencies
11:52:12 <allbery_b> in the .cabal file
11:53:04 <gbacon> doesn't like the version number in Build-Depends
11:53:16 <allbery_b> (Cabal = 1.1.3, I think)
11:54:03 <gbacon> still no joy
11:54:41 <runar> no joy as in... you get the same error with cabal 1.1.3?
11:54:51 <gbacon> no, it won't even configure
11:56:05 <gbacon> oh, needed Cabal == 1.1.3
11:56:10 <gbacon> tricksy
11:56:49 <yaxu> HNY all
11:57:00 <gbacon> but the build complains about a bad interface file
11:57:02 <yaxu> http://pragdave.blogs.pragprog.com/pragdave/2007/12/pipelines-using.html # is this lazy evaluation by another name?
11:57:32 <allbery_b> sounds like you need to do a "make clean" somewhere
11:58:09 <gbacon> same problem
11:58:09 <jaa> yaxu: similar to Lua's coroutines rather. you can simulate lazy things but youre emulating it the program level. a la OO in TCL
11:58:16 <Cale> yaxu: yield? Sort of.
11:58:18 <conal> yaxu: looks more-or-less equivalent.  i'd call it co-routines.
11:58:29 <runar> gbacon: What error are you getting?
11:58:47 <conal> Doug McIlroy invented Unix pipes.  He knew that lazy evaluation, co-routines, and pipes were all equivalent.
11:58:55 <gbacon> Bad interface file
11:59:24 <Cale> I basically learned lazy functional programming first using bash :)
11:59:33 <gbacon> requested module  Cabal-1.1.3:... found Cabal:Distribution...
11:59:37 <conal> to my eye, lazy evaluation in a purely functional language is by far the most elegant packaging.
11:59:49 <yoshi> How do I round a Double to, say 5 decimal places?
11:59:52 <gbacon> Cale: xargs seems like an easy way to teach people about sections
11:59:56 <Cale> My original mathbot was written as what was effectively a single very long shell pipeline in bash.
12:00:29 <Cale> (with a fifo to tie the ends together to a fixed point)
12:01:05 <yaxu> shell pipes work remarkably well
12:01:49 <Cale> yoshi: Multiply it by 10^5 and apply round to it, then convert back to a Double with fromIntegral, and divide by 10^5.
12:02:26 <conal> yaxu: i have a closely related google techtalk: http://conal-elliott.blogspot.com/2007/11/tangible-functional-programming-modern.html .
12:02:42 <conal> "Tangible Functional Programming: a modern marriage of usability and composability"
12:03:02 * yaxu watches
12:04:12 <conal> in a way, unix C programs are more composable than haskell programs.  i suggest an approach to do much better than both.
12:04:31 <conal> more usable & more composable.
12:04:54 <conal> eliminating the usual tension between usability & composability
12:05:14 <Cale> Er, you can still write Haskell programs in the unix style of course, using interact.
12:05:57 <gbacon> > let round' x places = let power = 10^places in round (x * power) / power in round' 3.14159
12:06:08 <gbacon> @bot
12:06:14 * gbacon frowns
12:06:30 <yaxu> conal: this is v interesting
12:06:40 <conal> yaxu: :)
12:07:09 <conal> Cale: yes -- but people generally don't.  that style is very limiting.
12:07:14 <conal> as it was in unix.
12:07:18 <Cale> right
12:07:55 <conal> e.g., no GUIs.  also programs must have parsers & unparsers.  so the unix simplicity principle is broken.
12:08:44 <Saizan> which was the hs-plugins repo updated for 6.8?
12:08:57 <yoshi> Cale: Thank you
12:09:26 <phobes> conal:  I can't watch your talk on this machine (though I've saved the think) - would it be easy to summarize in a sentence or two what your approach is?
12:09:33 <phobes> (or do you have a paper somewhere?)
12:10:38 <jaa> Monad Shell from MS, with the composable typed pipes... its all .NET apps?
12:10:47 <jaa> theres been no attempts at that on linux, i take it
12:11:26 <conal> phobes: the talk is a less technical and more motivational version of my ICFP 07 paper & talk.  See http://haskell.org/haskellwiki/Eros and http://haskell.org/haskellwiki/TV.  I'll post my tech-talk slides in a minute.
12:12:33 <conal> "modern marriage" techtalk slides: http://conal.net/misc/tangible-functional-programming-2007-11.pdf
12:13:10 <andyjgill> hi Conal! Happy new year!
12:13:36 <conal> phobes: there's two main aspects.  one is a very simple algebra of interfaces and the idea of pairing interfaces and values, so that they can combined for usability but separable for composability.
12:13:39 <conal> that's TV.
12:13:48 <conal> andyjgill: hi! thx.
12:14:36 <conal> phobes: the other aspect is mapping direct manipulation of GUI'd apps to that algebra, so that end-users can compose/program directly.
12:14:46 <conal> that second part is Eros.
12:15:11 <conal> TV applies to various interface styles, including text streams and GUIs.
12:15:46 <phobes> (thanks, reading the slides now)
12:16:40 <conal> what TV does, in contrast to standard C & Haskell IO programming is to allow the interface (input/output) part to be stripped off of the pure core, automatically tweaked, and rewrapped.
12:19:04 <wolverian> conal, what does 'automatically tweaked' mean? sounds funky in this context :)
12:20:12 <conal> wolverian: e.g., when two apps are composed, the output part of one interface and the input part of the other are stripped, and the remaining pieces are reassembled.
12:20:45 <conal> parallel to what happens to the types.
12:21:05 <wolverian> ah. right. thanks.
12:21:18 <jfredett> if I do a infixr foo 9 and infixr bar 8, which fixes stronger?
12:21:35 <conal> examples in the slides, starting on p 25, showing GUIs and types.
12:21:36 <nolrai> I have a module that defines Leaf, and imports a module that defines Leaf, is there a way to say that L.Leaf is from the imported module but Leaf is from this one without makeing me qualify :^: from the import?
12:22:48 <conal> nolrai: import twice. once qualified and once with partial hiding
12:22:55 <oerjan> jfredett: 9
12:22:58 <nolrai> thanks!
12:23:04 <conal> i do that pretty often.
12:23:06 <jfredett> oerjan: excellent, thanks
12:23:21 <jfredett> thats what I thought, but i wasn't sure
12:23:22 <oerjan> btw infixr 9 is the default
12:23:31 <oerjan> argh, infixl 9
12:23:46 <jfredett> i know- I'm trying to build a Deque datatype
12:24:10 <jfredett> and getting it to fix correctly, so you don't have to parenthesize as you build the things
12:24:20 <oerjan> btw don't use 9 if any of the operands are functions
12:24:25 <jfredett> is a pain in the ass
12:24:27 <jfredett> right
12:24:35 <oerjan> best to let . have that alone
12:24:36 <phobes> conal:  Is it fair to say that TV provides an automatic way to generate interfaces for values, and that it's also useful to generate hand-crafted UIs to display values?
12:24:44 <jfredett> i have the constructors set to 6 and 5
12:24:54 <jfredett> which is similar to the list operations
12:24:59 <jfredett> as defined in prelude
12:26:00 <phobes> (meaning, if you build thigns with TV fusion instead of real functions, you get a function with UIs for free)
12:26:55 <oerjan> @bot
12:27:04 <oerjan> :(
12:27:16 <agocorona> hi
12:27:24 <oerjan> hello agocorona
12:27:30 <conal> phobes: i didn't make the UIs quite automatic from the types, because i wanted to have labels, slider bounds, initial values.
12:27:44 <agocorona> finally the problem with HS-PLIGINS and WINDOWS was solved?
12:27:45 <phobes> ya
12:28:10 <conal> well, actually, there is a type-class for fully-automatic type-based UIs, but often I use the explicit ones.
12:28:23 <conal> fusion, on the other hand, is fully automatic in how it tweaks the UIs.
12:28:46 <conal> what surprised me is that TV is another way to look at MVC.
12:28:55 <phobes> conal:  What's the advantage of this over keeping the functional part separate from the UI part?
12:29:13 <agocorona> I still have a "index out of range" with GHC 6.8 under windos. Im desperate
12:29:25 <conal> phobes: so that pieces of the interfaces can be removed and the remainders stitched together.
12:29:26 <DuClare> sounds like windows
12:29:27 <phobes> conal:  I guess I see some advantages
12:30:00 <conal> it avoids the awful compromises of the unix approach, which prevented unix from really realizing its beautiful vision.
12:30:01 <Heffalump> agocorona: did you try using the debugger?
12:30:17 <DuClare> conal, what are those awful compromises?
12:31:01 <agocorona> DuClare: the debugger can not debug code in a package
12:31:13 <Saizan> Cale: is there an hs-plugins repo with your fixes for 6.8.2?
12:31:17 <agocorona> and hs-plugins is linked as a package
12:31:24 <LoganCapaldo> I guess plan9 didn't realize unix's beautiful vision either?
12:31:29 <Cale> Saizan: yes
12:31:40 <agocorona> where?
12:31:52 <conal> DuClare: described in the talk, but in summary: composition in unix is at odds with graphics, GUIs, multiple data types, multiple arguments, and minimality/consistency.
12:32:02 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
12:32:29 <phobes> conal:  What would be the problem with having unix input/output programs and just put them at the beginning and end of the pipes?
12:32:31 <agocorona> Ill try. thanks a lot
12:32:45 <phobes> conal:  inputA | aToB | bToC | visualizeC
12:33:15 <agocorona> Cale: this hs-plugins is the fixed one?, its cabal-ized?
12:33:21 <conal> phobes: are aToB and bToC executables?  i.e., do they have human interfaces?
12:33:23 <nolrai> does () take up any time or memory ie is "Either () a" less efcient then "Maybe a"?
12:33:34 <Cale> agocorona: yes, of course :)
12:33:49 <Cale> (the usual one is cabalised, so this one is too :)
12:33:49 <phobes> conal:  They have crappy unix style human interfaces
12:33:58 <DuClare> what's crappy about it?
12:34:01 <phobes> conal:  Or if we're talking about haskell, consider them functions
12:34:02 <DuClare> :o
12:34:03 <wolverian> conal, do you have a link handy to your icfp 07 paper & talk?
12:34:49 <conal> wolverian: http://conal.net/papers/Eros/
12:34:59 <wolverian> thanks!
12:35:24 <oerjan> nolrai: Right and Just should be equally efficient i think
12:35:28 <conal> phobes: okay.  the drawbacks include: containing parsers & unparsers, lack of static typing, linearity of composition, limitation to text UI
12:35:31 <agocorona> cale: i meant "darcs-ized"
12:35:36 <agocorona> sorry
12:35:40 <oerjan> they are both constructors with a single field
12:36:22 <phobes> conal:  Ok, but those are unix problems and probably aren't going to be fixed by TVs either, right?
12:36:39 <phobes> conal:  TVs are in haskell land, right?
12:37:23 <conal> phobes: not sure what you're asking.  whether the TV approach could be used in a unix/linux setting?
12:37:24 <oerjan> nolrai: that is, Right doesn't use the () part
12:38:10 <phobes> conal:  I'm just saying that if you tried to have individual executables that provided TVs through the Unix command line, you'd have to have the same issues of parsing / unparsing them, etc
12:39:13 <Saizan> conal: i think it's not clear the advantage over plain functions, since TVs are not at the OS level
12:39:27 <conal> thanks.  now i get it.  i really do want to take this vision and use it on the desktop and command line.  not sure exactly how, but i bet it can be done.
12:39:27 <yaxu> conal: artists should write their own darn filters
12:39:53 <conal> yaxu: i'd like them to be able to.  that was the whole motivation for Eros & TV.
12:40:09 <yaxu> yep just realised that :)
12:40:21 <conal> Saizan: i want to move TVs to the OS level and finally realize the unix vision.
12:40:53 <conal> thetallguy is interested as well.  we've had some discussions.
12:42:18 <conal> i guess the key technical question is how to let separate apps, or something that looks like separate apps, directly exchange typed haskell values, without unparsing & parsing.  for instance, infinite values.
12:42:51 <gbacon> conal: what's the harm with Show and Read?
12:43:21 <conal> gbacon: do you mean assuming you're satisfied with a text-stream interface?
12:43:47 <gbacon> not necessarily.. there has to be some medium of exchange
12:44:11 <EvilTerran> Show and Read are horribly inefficient for that sort of thing, and can't cope with, say, infinite values
12:44:37 <conal> exactly.  and there's a loss of safety/static typing.
12:44:56 <EvilTerran> Data.Binary's a little better, from an efficiency standpoint at least
12:44:57 <conal> but mainly the inefficiency and restriction to finite values.
12:45:01 <LoganCapaldo> exchange stuff as haskell  source code. Probably more inefficient, but an cope with infinite data structures etc.
12:45:10 <gbacon> why must show be strict?
12:45:19 <LoganCapaldo> also the type safety
12:45:32 <gbacon> isn't it correct for show [1..] = "[1..]"
12:45:32 <oerjan> gbacon: show isn't strict, but it has to be ordered
12:45:33 <LoganCapaldo> show doesn't have to be, but your file system generally is
12:45:35 <conal> LoganCapaldo: yes.  or something like haskell source code.
12:46:20 <phobes> if you're exchanging haskell source, you might as well just do your composition (fusion) in main?  and then relink :)
12:46:21 <oerjan> gbacon: for example, show ([1..],[1..]) doesn't work
12:46:40 <EvilTerran> I can envisage some kind of bi-directional communication to do the necessary IPC to deal with laziness
12:46:41 <LoganCapaldo> phobes: I like the way you think.
12:46:51 <conal> or fake separate apps and really have the apps connect to a shared server process and silently die.
12:47:29 <conal> then the "apps" could exchange haskell values directly in a shared heap.
12:47:30 <gbacon> how would two processes exchange closures?
12:47:47 <EvilTerran> "what's value x?" "oh, that's (y,z)" "what's y?" "that's 12" etcetc
12:48:01 <conal> gbacon: proxies are a standard trick.
12:48:18 <kpreid> EvilTerran: the roundtrips kill you, under insufficient cleverness...
12:48:26 <EvilTerran> "what's f?" "Int -> [Int]" "what's f 12?" "x:xs" ...
12:48:58 <EvilTerran> kpreid, indeed.
12:48:59 <conal> there are probably a variety of workable solutions.  i want to learn what distributed haskell implementations do.
12:49:07 <monochrom> The X Window protocol is full of such Q&As.
12:49:24 <conal> though the shared server process approach seems simple enough.
12:49:45 <Saizan> distributed haskell implementations like?
12:49:54 <conal> http://www.macs.hw.ac.uk/~dsg/gdh/
12:50:22 <conal> and Eden
12:50:47 <conal> their requirements are probably more stringent than mine.
12:50:49 <gbacon> conal: with a distributed system, won't you eventually have to bite the wire format bullet?
12:51:25 <conal> gbacon: i'm to ignorant of the possibilities to say for sure.  though i'm not really aiming for distributed yet.
12:51:42 <conal> gbacon: hence the shared server process idea.  on one machine.
12:52:48 <conal> and, in case it wasn't clear, i want to compose GUI'd apps as well as text-style apps.
12:52:59 <gbacon> (I read your slides)
12:53:22 <conal> :)
12:54:04 <gbacon> I'm all for X11 done right :-)
12:54:56 <conal> gbacon: !  i want to replace the X11 protocol with pure functional code.
12:55:19 <conal> like NeWS, but with a much nicer language.
12:55:24 <gbacon> that's why I mean by "done right"!
12:55:29 <conal> :)
12:55:30 <gbacon> s/why/what I/
12:55:55 <conal> ditto for html.  also jpg, mp3, mpg, ...
12:55:55 <thetallguy> quickcheck rules
12:56:14 <conal> thetallguy: indeed!
12:56:28 <thetallguy> digits = map fromIntegral . fst . floatToDigits 10 . fromIntegral
12:56:47 <thetallguy> I thought that was a valid function for splitting an integer into digits
12:57:00 <thetallguy> fromDigits = foldl (\x y -> 10 * x + y) 0
12:57:05 <thetallguy> but then I wrote the inverse
12:57:13 <thetallguy> and made this property:
12:57:21 <thetallguy> prop_digits n = (n > 0) ==> n == fromDigits (digits n)
12:57:39 <thetallguy> quickCheck prop_digits
12:57:39 <thetallguy> Falsifiable, after 51 tests:
12:57:39 <thetallguy> 10
12:57:47 <dcoutts> SyntaxNinja: nice to see the upgrade thing added. I wonder from a UI pov if it's right though. An alternative might be to have a special target or mode for installing.
12:58:07 <thetallguy> > floatToDigits 10 10
12:58:30 <dcoutts> SyntaxNinja: eg, suppose one want to just upgrade package Foo and all it's deps, one might want to say: cabal install foo --something-or-other
12:58:35 <oerjan> ([1],2)
12:58:40 <thetallguy> ([1],2) -- it drops the trailing zeroes
12:58:55 <EvilTerran> map (`mod`10) . takeWhile (/=0) . iterate (`div`10)
12:58:56 <gbacon> oerjan: @botsnack :-)
12:59:09 <oerjan> :)
12:59:49 <dcoutts> SyntaxNinja: and then there could be a special target 'world' or 'everything' that does it for all packages. Eg in gentoo we have flags that modifiy the behaviour to look for updates only, and another to look deep into the dep heirarchy for upgrades.
13:00:31 <oerjan> thetallguy: i think the idea is that 10 = .1e2
13:00:40 <oerjan> my guess anyway
13:00:40 <thetallguy> yes, it makes sense
13:00:45 <dcoutts> SyntaxNinja: I'll put my points in the trac...
13:00:46 <thetallguy> it's just not clear from the docs
13:00:51 <thetallguy> and I wasn't expecting it.
13:01:27 <conal> thetallguy: did you catch the discussion about how one might make composable haskell apps?
13:01:52 <thetallguy> perfectly reasonable, but it just introduced a bug
13:02:04 <thetallguy> conal: I saw a fragment then had to run for the plane
13:02:24 <thetallguy> conal: is there a summary somewhere?
13:02:25 <conal> oh -- i meant just a few minutes ago.  are you in an airport now?
13:02:41 <thetallguy> oh, no
13:02:53 <SyntaxNinja> dcoutts: on the phone, I'll be back in a few.
13:02:56 <thetallguy> I saw you talking about it a couple of weeks ago
13:03:04 <conal> oh
13:03:10 <dcoutts> SyntaxNinja: ok, great, I'd like to discuss this UI issue
13:03:26 <nolrai> is there a Source Monad?
13:03:37 <conal> nolrai: ??
13:03:42 <conal> nolrai: what sense of "Source"?
13:04:25 <conal> dcoutts: does gtk2hs play nicely with ghci?  in other words, can one run & re-run a gtk2hs without having to restart ghci?
13:04:27 <nolrai> a specilization of the state monad, used for geting random numbers or unique names.
13:04:41 <dcoutts> conal: yes
13:04:53 <conal> dcoutts: nice.
13:04:57 <oerjan> nolrai: there's a Random monad somewhere on hackage
13:05:13 <conal> nolrai: oh, okay.  i have another type called "Source", which is a monad too.
13:05:22 <dcoutts> conal: you'd be surprised at how difficult that is to arrange, I think wx cannot do that.
13:05:32 <nolrai> i need it for the unique names.
13:05:40 <dcoutts> because wx does not like being re-initialised I think
13:05:41 <conal> dcoutts: not since wxWindows 2.4.2
13:05:47 <nolrai> conal: realy?
13:05:51 <conal> dcoutts: yeah -- sigh.
13:05:56 <yaxu> conal: this TV idea isn't GUI specific, is it?  I'd like to see a TUI that fused functions together in a similar way...
13:06:04 <conal> nolrai: yep.  in DataDriven and Reactive.
13:06:06 <oerjan> nolrai: you can just use a newtype Source ... = State ... deriving (...) i think
13:06:22 <conal> yaxu: right.  not at all GUI-specific.
13:06:40 <yaxu> conal: i have seen a textual programming interface with the movie camera idea you mentioned in questions
13:06:42 <thetallguy> dcoutts: that seems like a problem with ghci, doesn't it?
13:06:43 <conal> yaxu: the basic building blocks are in DeepArrow.
13:06:49 <thetallguy> I supposed it's necessary
13:06:52 <EvilTerran> nolrai, i think it doesn't exist in the standard libraries, say, because it doesn't correspond to a simple type
13:06:53 <dcoutts> thetallguy: not really
13:06:56 <conal> yaxu: yeah??
13:06:58 <FunctorSalad> why does the quickcheck script try to run "./ghci"? http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
13:07:08 <FunctorSalad> why would you have ghci in the current dir
13:07:10 <EvilTerran> unlike, say, the (r->) and (w,) monad
13:07:11 <EvilTerran> s
13:07:51 <Cin> functor: does it change directory to ghci's?
13:07:53 <conal> yaxu: it's very easy for functions.  just use compositions of first, second, and (.).
13:08:09 <FunctorSalad> Cin: if it tries, it doesn't work :)
13:08:16 <yaxu> conal: yes edits are put on a timeline and you can go back and forth to see how the code is built
13:08:21 <conal> yaxu: i renamed and generalized (.) to "result".
13:08:23 <FunctorSalad> (not sure whether it tries)
13:08:25 <nolrai> ok, i saw it _somewhere_ but it shouldn't be hard to make.
13:08:32 <yaxu> conal: rcs exposed as a slider i guess
13:08:36 <conal> yaxu.  cool!  do you have a reference?
13:08:56 <yaxu> conal: sure one sec
13:09:21 <yaxu> conal: this is in the context of live coding of music, so music can be built up and then easily deconstructed to a previous state
13:09:30 <conal> yaxu: wonderful
13:09:39 <FunctorSalad> I'll try replacing it with just "ghci"
13:10:14 <yaxu> oh dear
13:10:15 <SyntaxNinja> dcoutts: yeah, I was still thinking of having "cabal install foo" which upgrades foo
13:10:27 <SyntaxNinja> dcoutts: an I liked your suggestion of "cabal install foo --deep"
13:10:33 <thetallguy> dcoutts: not really a problem with ghci, or not necessary?
13:10:34 <yaxu> cat just shook rain water off her coat onto my keyboard
13:10:35 <SyntaxNinja> but I'm not sure I understand all the cases yet.
13:10:48 <FunctorSalad> different error now ;)
13:10:50 <dcoutts> SyntaxNinja: I'm just writing a summary in the #197 bug
13:10:58 <dcoutts> thetallguy: not a problem with ghci
13:11:03 <SyntaxNinja> dcoutts: like if someone says "cabal install foo-1.1" well, then if foo-1.1 is already installed, then you don't want to do anything
13:11:10 <dcoutts> SyntaxNinja: I'll ping you in a sec...
13:11:16 <EvilTerran> nolrai, it looks to me like a Source thing might be more of a comonad than a monad
13:11:20 <dcoutts> SyntaxNinja: yes, that's an option.
13:11:24 <EvilTerran> (i may be completely wrong in that regard)
13:11:36 <thetallguy> dcoutts: yeah, i suppose it has to be able to restart stuff.
13:11:37 <conal> yaxu: yow!
13:11:38 <EvilTerran> although a State-based monad would do the job fine
13:11:43 <nolrai> EvilTerran: why?
13:11:52 <SyntaxNinja> dcoutts: actualy, look at my comments in #198
13:11:54 <EvilTerran> just a hunch
13:12:07 <SyntaxNinja> I'd be in favor of leaving 197 closed and just work it out in 198 and 168
13:12:14 <nolrai> what is a comonad again?
13:12:23 <SyntaxNinja> dcoutts: which isn't to say that we can't totally change the UI.
13:12:36 <oerjan> "I'll make State a comonad! BWAHAHAHA!"
13:12:36 <dcoutts> SyntaxNinja: those comments all look sensible
13:12:44 <oerjan> that kind of hunch?
13:12:45 <dcoutts> SyntaxNinja: they're mostly what gentoo does too
13:13:50 <FunctorSalad> I think for zeh comonad you take the liftM - join - return definition of monad and make all these functions go in the other direction.
13:13:50 <SyntaxNinja> dcoutts: I'm wondering about strange cases like when someone asks to install "foo>1.0" if the local version is "foo-1.1" and online is "foo-1.2" should we install the online version, or should we assume that the need is satisfied.
13:15:08 <oerjan> aren't comonads the same as monads on the dual category?
13:15:19 <SyntaxNinja> dcoutts: since "install" is implemented basically as a dependency satisfyer, it took a while to figure out how to implement #198, but I think I have an idea now.
13:15:48 <thetallguy> conal: I saw that there were Qt bindings out there now.  Perhaps they play better with ghci?
13:15:59 <conal> thetallguy: i'm wondering the same thing.
13:16:00 <FunctorSalad> oerjan: sounds right
13:16:08 <SyntaxNinja> dcoutts: btw, lots of package aren't building with ghc 6.8. getting that upgraded on monk should probably be high priority so that people can start uplodaing new packages.
13:16:32 <SyntaxNinja> but I didn't want to much w/ anything on there.
13:16:39 <thetallguy> conal: the Qt license has gotten a lot better
13:16:41 <conal> thetallguy: i'm fine on windows, by using wxWindows 2.4.2, and maybe the same trick works on linux.  don't know.
13:16:48 <dcoutts> SyntaxNinja: yes, I'm not sure if it's just ross who can update that or not, I've never done it either/
13:17:35 <conal> thetallguy: what are you using for gui?
13:17:43 <thetallguy> conal: flash
13:17:46 <conal> thetallguy: oh yeah
13:18:01 <thetallguy> conal: but I would like to be able to create desktop apps
13:18:12 <conal> thetallguy: is flash limited to browser?
13:18:14 <thetallguy> conal: at Linspire we used KDE, so the gtk bindings never helped
13:18:19 <SyntaxNinja> dcoutts: I was thinking of writing a little program to download all the packages and try to build them so we can figure out which ones are broken.
13:18:36 <thetallguy> conal:  it would be good to know which calls in gtk weren't reentrant
13:18:36 <conal> thetallguy: KDE doesn't play with gtk?
13:18:55 <thetallguy> conal: not the same look, so creating gtk apps wasn't on the project plan
13:18:56 <dcoutts> SyntaxNinja: yes, that'd be good, I'd like to see that and automated reporting back to hackage
13:19:06 <thetallguy> conal: plus, the gtk2hs was still raw
13:20:06 <conal> dcoutts: how gtk2hs doing these days on linux, macos, & windows?  are installs going easily all around?
13:20:14 <thetallguy> conal: re: flash and browser, yes, although they've added the flex toolkit which is supposed to be a desktop setup
13:20:15 <SyntaxNinja> dcoutts: we could suck down the maintainer names and email everyone.
13:20:49 <conal> thetallguy: oh yeah.  are you interested in flex for desktop?
13:21:17 <thetallguy> conal: yes, but it's not my primary
13:21:28 <dcoutts> SyntaxNinja: http://hackage.haskell.org/trac/hackage/ticket/197
13:21:50 <conal> thetallguy: suppose we design a foundation and environment for composable apps, as in TV/Eros, what are some appealing options?
13:22:06 <dcoutts> SyntaxNinja: yes, once we have accurate reporting then pinging maintainers and marking bitrotted status on each package info page would be good
13:23:02 <dcoutts> SyntaxNinja: I'd like to have cabal-install report enough info back to hackage website to derive useful info about what platforms the package works on, eg we ought to be able to see which ones work with 6.6, or 6.8, or windows or whatever
13:23:07 <thetallguy> conal: web and desktop, opengl and not
13:23:24 <dcoutts> SyntaxNinja: though it'd need a bit of statistical analysis to get that kind of info out of the raw data
13:24:02 <dcoutts> SyntaxNinja: http://hackage.haskell.org/trac/hackage/ticket/184
13:24:19 <conal> thetallguy: is flash/flex the only web/desktop cross-over?
13:24:24 * SyntaxNinja reads
13:24:46 <conal> thetallguy: of course we could target different GUI back-ends from a high-level interface.
13:24:47 <thetallguy> conal: good question.  Java
13:24:48 <dcoutts> SyntaxNinja: we need to make sure the data is of reasonable quality before pinging maintainers with too many annoying emails or they'll hate us ;-)
13:24:52 <yaxu> conal: i can't find anything written, it was a demo by Julian Rohrhuber at a livecoding conference i organised
13:24:54 <sylvan> Anyone used HDBC-ODBC before and knows how to figure out what the connection string should be? I can connect to the MySQL server using "mysql" but connecting to it in Haskell (using connectODBC) fails. Not sure how the connection string should look...
13:25:11 <conal> yaxu: thanks for looking.
13:25:20 <runar> how would you go about proving that foldl f = foldr f for any associative f?
13:26:01 <FunctorSalad> induction or just say "it's obvious" ;)
13:26:07 <runar> f x y = f y x ... what other properties are there?
13:26:09 <SyntaxNinja> dcoutts: yeah, definitely. I was going to just hand craft one for now, if I get around to it.
13:26:24 <FunctorSalad> runar: that's commutativity
13:26:31 <runar> oh, duh
13:26:31 <conal> thetallguy: of course -- java.  how about that direction?  i have a compiler back-end for java as part of pajama.
13:26:33 <SyntaxNinja> dcoutts: so not sure, after reading #197, what you're proposing for cabal.
13:26:53 <dcoutts> SyntaxNinja: yes, I didn't get to that bit :-) but that's the background
13:26:57 <jbalint> sylvan: try server=x;uid=x;pwd=x;database=x
13:27:14 <dcoutts> SyntaxNinja: so having two modes makes a lot of sense, minimal upgrades and maximal upgrades
13:27:20 <thetallguy> conal: it was worrisome with the VM fragmentation, but I think it's getting better
13:27:28 <thetallguy> conal: flash doesn't support threads
13:27:29 <dcoutts> SyntaxNinja: that's what gentoo's emerge foo vs emerge foo --update --deep does
13:27:35 <SyntaxNinja> dcoutts: as for #184, one thing we coul do instead is just elect a few folks to maintain a build farm. we really only need a few platforms, and some chroot magic
13:28:09 <yaxu> conal: very interesting talk, although i disagree that guis are more modern than tuis, and think computer artists should be programmers
13:28:12 <SyntaxNinja> dcoutts: so do you think we should get rid of upgrade and just have "cabal install --upgrade-all" or something?
13:28:19 <thetallguy> conal: not sure if the sun java vm supports native threads
13:28:28 <sylvan> jbalint, thanks, but that didn't work. I got "*** Exception: (unknown)".. Not very useful
13:28:28 <dcoutts> SyntaxNinja: I'm quite keen on the idea of using all users of hackage as testers, not just a couple build-bots, we get more platform coverage that way and much more usage/popularity data
13:28:30 <conal> thetallguy: are threads important?
13:28:36 <conal> yaxu: thanks.
13:28:36 <SyntaxNinja> dcoutts: true
13:28:49 <thetallguy> conal: as multicore processors come around, yes
13:28:49 <yaxu> text is made out of graphics after all, although i think you made that point somewhere too
13:28:59 <SyntaxNinja> dcoutts: the downside being more complexity and privacy questions
13:29:03 <jbalint> sylvan: hehe , try enabled the odbc trace in odbc.ini Trace = 1, TraceFile = /tmp/log , or something like that. see unixodbc site for the details
13:29:06 <conal> thetallguy: oh, sure.
13:29:07 <dcoutts> SyntaxNinja: I think we should have a flag for doing maximal rather than minimal upgrades, and another for using all packages as the target
13:29:21 <thetallguy> conal: pretty soon, quad core machines will be the norm.  See the CUFP write up on the Intel talk
13:29:30 <SyntaxNinja> dcoutts: so keep "upgrade" and add "install foo --deep"?
13:29:39 <dcoutts> SyntaxNinja: the two ideas are orthogonal, though one usually wants maximal updates if you're specifying all installed packages as the target
13:29:39 <sylvan> jbalint, can I do that? I just have user access
13:29:42 <SyntaxNinja> where upgrade is just the "maximal, all versions" of install?
13:29:55 <jbalint> sylvan: yeah, in your ~/.odbc.ini , create a dsn
13:30:07 <jbalint> sylvan: the driver has been registered in /etc/odbcinst.ini, right?
13:30:23 <sylvan> don't know, they just installed the odbc stuff at my request like a few minutes ago
13:30:25 <jbalint> sylvan: oops, forgot you need the driver name in the string too :)
13:30:34 <jbalint> sylvan: try cat /etc/odbcinst.ini and check the driver is installed
13:30:35 <thetallguy> conal: also, refer back to my points about interactive feedback based on type info, etc.  Need adaptive scheduling of rendering and interaction, and I think ultimately that will need some parallelism to work really wel.
13:30:46 <dcoutts> SyntaxNinja: I'm inclined to have it all under one command since there's often not a lot of difference and install and upgrade would both end up doing both package installs and upgrades, so it could be a tad misleading.
13:31:20 <conal> thetallguy: for the latter, lightweight threads (non-os) may work fine.  but not with current blocking gui toolkits.
13:31:27 <SyntaxNinja> dcoutts: " install world" seems a little magic to me
13:31:35 <conal> thetallguy: for performance, definitely run those mult-cores.
13:31:39 <SyntaxNinja> I guess "install --upgrade-all" wouldn't be bad.
13:31:43 <conal> surely sun must know that also.
13:31:47 <thetallguy> conal: yes, short term
13:31:50 * SyntaxNinja is very used to the apt way of thinking
13:32:23 <sylvan> jbalint, /etc doesn't have any such file :-(
13:32:25 <dcoutts> SyntaxNinja: right, so I'd suggest one flag to indicate all packages, --upgrade-all is ok, and one to indicate maximal upgrades of the specified packages, where --upgrade-all implies that too
13:32:44 <dcoutts> SyntaxNinja: so the point is, it's also allow me to "cabal install --deep happs" or something
13:32:46 <jbalint> sylvan: is there a /usr/lib/libmyodbc* file ? thats the driver
13:33:03 <conal> yaxu: do you have comments about why you want artists to program, and what you mean by that.  i'm guessing you mean a conventional, textual style.
13:33:05 <SyntaxNinja> dcoutts: that's the use case I don't really grok, actually.
13:33:08 <dcoutts> SyntaxNinja: I'm not so bothered by what the flags are called exactly
13:33:33 <SyntaxNinja> dcoutts: I can understand wanting the latest version of a specific package, but if I'm just talking about "happs" why should I care whehter the packages that happs depends on are upgraded, so long as its dependencies are met
13:33:36 <dcoutts> SyntaxNinja: it's the same as --upgrade-all, but for a specific set of packages and their dependencies, rather than all packages
13:33:38 * thetallguy wants to start a long-term design discussion on packaging.
13:33:39 <sylvan> jbalint, yeah, in /usr/local/lib
13:33:54 * thetallguy but is going to go to the store instead.
13:34:24 <dcoutts> SyntaxNinja: right, the default is always for a minimal install/upgrade, but why do you want the latest version of everything? well the same applies to subsets of 'everything'
13:34:44 * thetallguy appreciates all the efforts from dcoutts and SyntaxNinja
13:34:59 <dcoutts> SyntaxNinja: perhaps you only want the latest versions of things you specifically wanted, and do not really care about the boring dependencies of those
13:35:10 <SyntaxNinja> dcoutts: well, I can see wanting the latest version of something specific, and the latest versoin of everything, but not the latest version of just the things that depend on "happs"
13:35:19 <SyntaxNinja> thetallguy: thank dcoutts :)
13:35:26 <dcoutts> SyntaxNinja: eg suppose from a clean system you install happs, then you care about happs but not about it's half dozen deps
13:35:36 <SyntaxNinja> right
13:35:37 <thetallguy> SyntaxNinja: you started it.
13:35:59 <dcoutts> SyntaxNinja: so when you cabal install --upgrade-all do you want to update to the latest version of happs or also the latest versions of the half dozen deps of happs?
13:36:12 <SyntaxNinja> dcoutts: so I don't really get the use for --deep.
13:36:33 <dcoutts> SyntaxNinja: what you've coded is the latter since we currently do not distinguish between packages specificlally requested and those pulled in as a consequence
13:36:42 <SyntaxNinja> for --upgrade-all, it just installs the latest version of all packages. wit hthat, we can start to implement some kind of meta-package release process some day
13:36:46 * thetallguy hates discussions about editing generated  binary structures, feels focusing on source structures is better.
13:36:57 <SyntaxNinja> like "hackage version 6.8" are all the packages that are known to work with ghc 6.8 or something
13:37:15 <dcoutts> SyntaxNinja: deep makes a difference if we distinguish packages specifically requested vs uninteresting deps
13:37:19 * thetallguy needs a bigger budget.
13:37:39 * conal puts 10 cents in the mail to thetallguy 
13:37:40 <thetallguy> conal:  I'll think more about the platform issues and discuss with SeeReason.
13:37:53 <conal> thetallguy: great.
13:38:06 <dcoutts> SyntaxNinja: sometimes packages enable extra features or have bugs fixed if they use later versions of their dependencies
13:38:07 <SyntaxNinja> dcoutts: I'm not sure we're groking each-other. lemmy try again.
13:38:15 <dcoutts> SyntaxNinja: that's one reason for --deep
13:38:21 <conal> thetallguy: our goals are so similar, i hope we can collaborate on realizing them.
13:38:30 <thetallguy> conal: but my cupboard is bare and I"m getting hungry, so off to the store for real now.
13:38:40 <conal> thetallguy: go now!
13:38:52 <FunctorSalad> you got stores on new years?
13:39:01 <SyntaxNinja> I see 3 cases. 1) upgrading a specific package 2) upgrading a subset of packages (ie foo, and everytihng that foo depends on) and 3) upgrading all packages.   They all seem like a good idea, but 2) seems the least useful to me.
13:39:06 <thetallguy> conal: yes.  mailing list?  Chat room?  darcs repository with design docs?  # haskell too noisy for this.
13:39:13 * thetallguy goes.
13:39:41 <dcoutts> SyntaxNinja: 3 comes for free if one implements 2
13:40:13 <dcoutts> SyntaxNinja: and is actually different from 3 if one distinguishes specifically requested packages vs deps that are pulled in
13:40:29 <SyntaxNinja> I could see a case where you somehow know that, if "foo" depends on "bar", that if 'bar" has a bug, you want to upgrade "bar" even though "foo" dependencies don't say you do?
13:40:47 <dcoutts> SyntaxNinja: which btw, might be one way of doing the other thing you wanted, which was to re-install all the packages you wanted when you upgrade ghc
13:41:09 <dcoutts> SyntaxNinja: yes, that is a use case, which admitidly is relatively rare
13:41:34 <dcoutts> SyntaxNinja: but is a fairly easy thing to explain in terms of minimal vs maximal installs
13:41:41 <SyntaxNinja> dcoutts: there is usefulness in distinguishing. especially if you only installed "bar" because of "foo" but now "foo" doesn't depend on "bar" anymore. no reason to keep "bar" around.
13:41:54 <dcoutts> SyntaxNinja: it amounts to prefering hackage packages to installed ones when doing dep resolution
13:42:03 <dcoutts> SyntaxNinja: yes, exactly
13:42:27 <SyntaxNinja> dcoutts: so what about negative dependencies, like "foo<1.1" do we install the largest package < 1.1?
13:42:28 <dcoutts> SyntaxNinja: that's why gentoo records those packages specifically requested as the 'world' meta package
13:42:37 <SyntaxNinja> dcoutts: hmm. interesting.
13:42:39 <dcoutts> SyntaxNinja: in general, yes.
13:42:44 <conal> yaxu: do you know about the Graeme conference in mid-march?
13:42:57 <yaxu> conal: oops sorry, was looking away
13:43:23 <conal> yaxu: also, did you see my question about artists & programming?
13:43:24 <SyntaxNinja> dcoutts: the way I implemented upgrade is much easier than what you propose, i think, since it doesn't require any dependency tracking.
13:43:25 <dcoutts> SyntaxNinja: we pick the highest available package, and the --deep flag would control wether we prefer installed or not
13:43:32 <dcoutts> SyntaxNinja: indeed
13:43:39 <yaxu> conal: yep just thinking about my reply
13:43:47 <conal> yaxu: np.
13:44:25 <dcoutts> SyntaxNinja: but maximal is an easy variation on minimal in dep resolution, at least if we have a decent dep resolution framework like kosmikus was prototyping
13:44:32 <conal> yaxu: btw, the Graeme event is called "Digital Art and Programming".
13:45:29 <dcoutts> SyntaxNinja: the thing that I like about it is that it's easier to explain --update-all in terms of two orthogonal features, maximal installs and using all installed packages as the target
13:45:31 <SyntaxNinja> dcoutts: OK, so is this what you are thinking: "cabal install world --deep" (like upgrade now, basically), "cabal install world" (upgrades only interesting packages), "cabal install foo" (upgrades foo only, and any dependencies it requires) "cabal install foo --deep" (upgrades foo and all its deps)
13:45:46 <dcoutts> SyntaxNinja: yes, exactly.
13:45:49 <yaxu> conal: i want artists to program because i dislike the engineer/artist dichotomy...  that is i prefer artists who paint as opposed to artists who get other people to produce their paintings
13:46:12 <yaxu> conal: and no i didn't know about graeme
13:46:23 <SyntaxNinja> dcoutts: and I guess the big question is whehter we try to introduce "interesting" packages or not - could make things a bit more complex.
13:46:36 <SyntaxNinja> is there any cabal specific package database now? or does everything use GHC's?
13:46:39 <conal> yaxu: so maybe you're not attached to a conventional approach to programming, just the expressiveness.
13:46:46 <dcoutts> SyntaxNinja: I think it's not necessary immediately
13:46:53 <SyntaxNinja> dcoutts: I'll record this in the ticket. actually, do you mind if I consolodate the tickets?
13:47:00 <dcoutts> SyntaxNinja: go ahead
13:47:00 <SyntaxNinja> these 3 tix?
13:47:05 <yaxu> conal: yes -- the deep involvement in the medium
13:47:28 <dcoutts> SyntaxNinja: which 3? #197 #198 and?
13:47:50 <dcoutts> SyntaxNinja: currently we do not keep any cabal-specific installed package list, we just rely on ghc-pkg
13:48:01 <conal> yaxu: cool -- that's what i'm trying to get at also.  and without inflicting a linear, linguistic, sequential strategy for working in the medium.
13:48:12 <yaxu> conal: although on the other hand novels were not superseded by film
13:48:57 <conal> yaxu: no need to supercede.  they can co-exist as choices.
13:49:03 <dcoutts> SyntaxNinja: I think the 'world' thing that distingusishes specifically requested vs other is not currently something we need but I don't think that invalidates the other features that might make distinctions based on it
13:49:08 <SyntaxNinja> dcoutts: 197, 198, 168
13:49:14 <yaxu> conal: yep i think we agree
13:49:17 <conal> yaxu: do you know the book "the alphabet vs the goddess".  it influenced me a lot.
13:49:18 <dcoutts> SyntaxNinja: yes, ok those 3.
13:50:24 <dcoutts> SyntaxNinja: so without a world list then "cabal install world --deep" and "cabal install world" would coincide.
13:50:31 <conal> part of what i wanted to convey in the "modern marriage" talk is that the essence of programming is not about programs.  programs can be very useful, but not to confuse them with the heart of the matter.
13:50:57 <dcoutts> SyntaxNinja: since it'd be the full package list and obviously --deep cannot add anything to the complete list :-)
13:51:01 <SyntaxNinja> dcoutts: riht
13:51:05 <SyntaxNinja> er right
13:51:15 <SyntaxNinja> deep could add something, right? if a package has a new dependency
13:51:17 <dcoutts> but is still makes a difference when we consider subsets of all packages as the targets
13:51:22 <dcoutts> SyntaxNinja: yes
13:51:31 <dcoutts> but --deep would not affect that
13:52:46 <yaxu> conal: i haven't read that, v interesting blurb though!
13:53:34 <SyntaxNinja> dcoutts: it could, though.  If Foo -> Bar -> Baz.  "install foo --deep" could bring in a version of "bar" that now depends on "baz", where the old version didn't
13:53:41 <conal> yaxu: if you read it, you'll see why i want to offer an alternative to the linguistic style of programming, without loss of expressiveness.
13:53:42 <yaxu> conal: and what's the heart of the matter? :)
13:53:43 <SyntaxNinja> but "install foo" wouldn't necessarily install a new version of "bar".
13:54:05 <conal> yaxu: the ideas/meanings denoted by the programs.
13:54:24 <FunctorSalad> lambdabot> omg -- response: "Maybe you meant: bug msg"
13:54:52 <conal> yaxu: meanings which exist whether they're denoted linguistically or not.
13:55:03 <oerjan> @bot
13:55:24 <FunctorSalad> oerjan: local lambdabot
13:55:24 <conal> that's why Eros & TV are about *semantic* composition rather than syntactic composition.
13:57:47 <yaxu> conal: do you have a link for that conference?
13:58:37 <conal> yaxu: just an email, which i can forward you.  (i was asked to speak there.  but i said no thanks.)
14:00:00 <yaxu> yes please (email in privmsg)
14:02:26 <conal> yaxu: i haven't seen a privmsg from you yet.  is your nick registered?
14:04:53 <dcoutts> SyntaxNinja: I don't see it, are we assuming that Foo and Bar are already installed, and that a newer version of Bar deps on Baz?
14:05:26 <dcoutts> SyntaxNinja: if Bar is already installed then it'll be considerd for upgrading, and the new version of Bar will pull in Baz
14:06:24 <SyntaxNinja> dcoutts: right. I thought you were saying that "--deep" couldn't pull in new packages.
14:07:18 <dcoutts> SyntaxNinja: I suppose I really meant it could not pull in any more than without --deep, that for the 'everything' target --deep makes no difference
14:07:41 <dcoutts> SyntaxNinja: the other complication with upgrading, is that for something to end up getting used, then packages higher up the chain have to be re-compiled
14:08:13 <SyntaxNinja> oh yeah, hadn't thought of that.
14:08:16 <dcoutts> SyntaxNinja: eg Foo -> Bar, if we don't need to upgrade Foo but we do need to upgrade Bar then Foo has to be rebuilt against the new Bar
14:08:22 <SyntaxNinja> <--- thinks in terms of binary distributions ;)
14:08:45 <dcoutts> SyntaxNinja: yeah, and you think in terms of shared libs and compatible ABIs :-)
14:08:50 <dcoutts> which we do not have
14:09:09 <SyntaxNinja> dcoutts: well, there's no saying that we need to rebuild Foo. it can just use the old version of Bar.
14:09:11 <roconnor> conal: why does output depend on snk and src?
14:09:43 <dcoutts> SyntaxNinja: true but then it's not really doing what the user wanted, there was no point in updating Bar unless Foo was going to use it
14:10:09 <dcoutts> SyntaxNinja: otherwise we'd have only asked to upgrade Bar ranther than update --deep Foo
14:10:46 <SyntaxNinja> hrm.
14:10:57 <conal> roconnor: because they have different notions of input & output primitives.
14:11:01 <dcoutts> SyntaxNinja: and what's worse, since we can only have one package in each library version slot then we may have to rebuild other things
14:11:35 <dcoutts> SyntaxNinja: since unlike nix, we cannot have Foo-1.0 built against Bar-1.0 and also Foo-1.0 built against Bar-1.1 installed at once
14:12:14 <dcoutts> SyntaxNinja: but if we had things built against Foo already installed then they would need to be rebuilt if we rebuilt Foo to use the upgraded Bar-1.1
14:12:26 <roconnor> conal: shouldn't output only depend on snk?
14:12:44 <dcoutts> SyntaxNinja: since the API and ABI can change when we rebuild Foo from Bar-1.0 to Bar-1.1
14:12:53 <SyntaxNinja> right
14:12:57 <dcoutts> SyntaxNinja: so all dependent packages are affected :-(
14:13:10 <SyntaxNinja> and we might be updating "Bar" not because "foo" was requested, but because some other package that depends on Bar was requested.
14:13:10 <conal> roconnor: one kind of output is lambda, which includes an input
14:13:20 <roconnor> I see
14:13:35 <dcoutts> SyntaxNinja: this would not be the case if we had a purely functional package system, where we can have as many versions of Foo-1.0 installed as necessary, each built against different versions of their deps
14:13:39 <SyntaxNinja> meh. trac is too noisy on the mailing list, IMO
14:13:41 <roconnor> conal: the lack of symetry reminds me of the lack of symetry in constructive logic.
14:13:52 <SyntaxNinja> dcoutts: then we can make the Simons do all the work ;)
14:13:59 <dcoutts> SyntaxNinja: heh :-)
14:14:14 <conal> roconnor: the asymmetry bugs me too.  i think there's also an ilambda waiting to go in there.
14:14:27 <roconnor> ilambda?
14:14:36 <conal> roconnor: and then elimination of the input/output type distinction.
14:14:39 <dcoutts> SyntaxNinja: yes, I worry about that, but I'm not sure how we could make it less noisy without making the trac invisible, I'd never see any trac changes unless they were sent to the list
14:14:48 <SyntaxNinja> yeah
14:15:00 <dcoutts> SyntaxNinja: perhaps we could filter out simple property changes that have no corresponding comment
14:15:14 <conal> roconnor: olambda is how the computer shows the user a function.  ilambda is how the user shows the computer a function.
14:15:17 <dcoutts> SyntaxNinja: eg me just changing milestones or difficulty for example
14:15:29 <roconnor> oh
14:15:55 <roconnor> conal: I still think those lambdas are really arrows (aka Pi)
14:16:29 <conal> roconnor: i started out expecting to use arrows, but they're too restrictive.
14:16:51 <roconnor> oh, interesting
14:17:03 <SyntaxNinja> dcoutts: rebuilding "Foo" becuase of upgrading "Bar" actually could cause an entire upward dependency tree to be rebuilt, right?
14:17:18 <dcoutts> SyntaxNinja: yes :-(
14:18:48 <SyntaxNinja> dcoutts: I tihnk this brings us to the question: Do we really want to build a fully-featured package system?
14:19:07 <SyntaxNinja> (also see that ticket wrt deleting packages) http://hackage.haskell.org/trac/hackage/ticket/198
14:19:27 <dcoutts> SyntaxNinja: yes, I see.
14:20:20 <dcoutts> SyntaxNinja: I don't see any obvious way around it though, are there any package managers we could use that are cross platform etc and we could translate cabal packages into?
14:20:49 <dcoutts> SyntaxNinja: since it also has to be per-user and integrate with our existing package list stuff (ghc-pkg etc)
14:21:39 <conal> roconnor: arrows make the function-like aspect central and ever-present.  i wanted something to address all types of values, including non-functions and curried functions.
14:21:51 <SyntaxNinja> dcoutts: well, cabal could do an OK job and not try to get the niggly bits right, and then could depend on the OS's package manager, Debian or Gentoo to get the details right on that platform.
14:22:05 <yoshi> Does anyone know of a module for a Parser Complex Double?
14:22:23 <oerjan> module?
14:22:31 <Zvpun> what's wrong wiht "(\x y -> x * 4 + y) :: (Num a) => a -> a -> a" ERROR "foo.hs":35 - Syntax error in input (unexpected backslash (lambda))
14:22:33 <conal> roconnor: i think arrows push for the same kind of linearity as unix pipelines, while TV/Eros is much more flexible.
14:22:45 <dcoutts> SyntaxNinja: it doesn't help much for per-user stuff and actually there's much more chance we can get it right in Haskell than with gentoo, it's dep system is too limited to express the stuff we need.
14:23:14 <oerjan> yoshi: there's a Read instance for it
14:23:14 <monochrom> :t (\x y -> x * 4 + y) :: (Num a) => a -> a -> a
14:23:16 <conal> Zvpun: does it work with "forall a." after the "::" ?
14:23:25 <monochrom> @type (\x y -> x * 4 + y) :: (Num a) => a -> a -> a
14:23:32 <dcoutts> SyntaxNinja: apt might be better there but it still doesn't do per-user well as I understand it
14:23:44 <SyntaxNinja> dcoutts: right, it doesn't.
14:24:12 <SyntaxNinja> but strategically speaking, do we have the resources to build a package system that's going to be about as complex as apt or emerge?
14:24:12 <hpaste>  Yoshi pasted "Parser Complex" at http://hpaste.org/4753
14:24:13 <dcoutts> SyntaxNinja: I'm reasonably confident that the framework kosmikus was prototyping could handle all this stuff
14:24:24 <SyntaxNinja> dcoutts: oh yeah? what's that about?
14:24:44 <dcoutts> SyntaxNinja: he also built a version of gentoo's emerge in haskell, and then some extensions
14:24:51 <Zvpun> conal, monochrom: sorry I dont understand I am learning haskell from the haskel to C tutorial.
14:25:06 <conal> Zvpun: worked for me, in ghci.  gives an error about missing Show instance.
14:25:17 <yoshi> oerjan: a Read instance?
14:25:21 <SyntaxNinja> cool.
14:25:37 <dcoutts> SyntaxNinja: I asked him to look at a cut-down prototype for cabal-install, see bug #175
14:25:49 <Zvpun> conal: I use hugs, its taken from Part V of http://www.haskell.org/~pairwise/intro/section3.html
14:26:12 <SyntaxNinja> can you go through #198 and make any corrections, comments, or additions?
14:26:24 * dcoutts carries on reading #198
14:26:52 <oerjan> yoshi: never mind.  perhaps you can use a TokenParser?
14:27:25 <conal> Zvpun: probably a hugs/ghci difference.
14:27:26 <oerjan> or ExpressionParser
14:27:57 <oerjan> that surely should have some floating point at least..
14:28:05 <Zvpun> does anyone know how to make hugs accept this "(\x y -> x * 4 + y) :: (Num a) => a -> a -> a
14:28:15 <Zvpun> the " is not there
14:28:51 <SyntaxNinja> dcoutts: feel free to just change the description. it would be nice to have a summary at the top, rather than just back-and-forth
14:29:00 <dcoutts> SyntaxNinja: sure
14:29:28 <oerjan> yoshi: try the float or naturalFloat parsers
14:29:31 <monochrom> Zvpun: You should show the whole file. Everything is contextual.
14:29:38 <oerjan> *naturalOrFloat
14:32:15 <Zvpun> monochrom: I copied the examples in my foo.hs and did :l "foo.hs" maybe this line was not ment to be evaluated.
14:33:38 <oerjan> Zvpun: that line works in hugs for me
14:33:47 <yoshi> oerjan: Is is possible to go from (2.0::Double) -> (2.0::Complex Double)?
14:33:50 <oerjan> well, the syntax does
14:33:57 <Pseudonym> ?botsnack
14:34:04 <monochrom> The tutorial probably has clear instructions on what to put into a file for experimentation, vs what is just part of the author explaining an idea.
14:34:07 <Pseudonym> Still dead in the water, I see.
14:34:23 <oerjan> yoshi: x :+ 0
14:36:10 <brian`> happy new year~
14:36:58 <brian`> i just installed ghc 6.8.2
14:37:02 <brian`> but when i tried to run it
14:37:09 <dcoutts> SyntaxNinja: if this issue needs a lot of editing we might want to make it a wiki page
14:37:23 <brian`> it says " error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory"
14:37:30 <brian`> what should I do?
14:37:53 <dcoutts> SyntaxNinja: I added definitions of "Minimal upgrade" and "Maximal upgrade"
14:38:04 <SyntaxNinja> cool.
14:38:14 <SyntaxNinja> yeah, maybe a wiki page would be good. it would then be descent documentation
14:43:26 <SyntaxNinja> brian`: what OS do you use?
14:43:37 <SyntaxNinja> brian`: you probably need to install readline, I'd guess
14:46:36 <brian`> SyntaxNinja, I'm using Ubuntu
14:46:45 <brian`> when I checked synaptic pacakge manager
14:46:54 <brian`> it says libreadline is already installed
14:47:06 <Saizan> ubunto comes with readline5, maybe?
14:47:15 <Saizan> ghc is linked to use 4
14:47:27 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD conal 38
14:47:38 <brian`> ah i c
14:48:12 <Saizan> there's an rpm of readline4 on the download page
14:48:16 <Saizan> of ghc
14:48:43 <brian`> what about ubuntu ;
14:49:23 <brian`> i just looked at the package manager
14:49:31 <brian`> nad there is no libreadline4 module...
14:49:46 <brian`> should i just download it from the internet and install it?
14:50:08 <conal> brian`: i recently had the same issue.  (i'm getting started with ubuntu.)  i resolved it by downloading the ghc6 debian package and then building 6.8.2 from source.
14:50:34 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] DEL dobblego
14:50:40 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD dibblego 38
14:51:09 <Saizan> you can use the provided rpm on ubuntu using alien
14:52:02 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] DEL eviltwin_b
14:52:29 -ChanServ(ChanServ@services.)- Pseudonym!n=ajb@lindor.alicorna.net ACCESS [#haskell] ADD allbery_b 38
14:53:40 <Pseudonym> OK, that's enough housekeeping.
15:05:19 <FunctorSalad> :t head -- how can this return an exception if the return type is just plain a and not some error monad around a?
15:05:36 <FunctorSalad> head :: [a] -> a
15:05:58 <oerjan> exceptions are raised, not returned
15:06:08 <dolio> head [] is bottom, semantically.
15:06:13 <FunctorSalad> hmm ok
15:06:36 <FunctorSalad> so the function error never returns?
15:06:41 <SyntaxNinja> I'm using ubuntu and ghc 6.8.2
15:06:43 <oerjan> indeed
15:07:07 <oerjan> @bot
15:07:12 <dolio> Well, it returns, so to speak. It returns _|_
15:07:36 <FunctorSalad> hmm that's its semantics but the control flow never passes back as I understand
15:07:38 <dolio> It just so happens that GHC knows the cause of that particular _|_ and prints out a nice message.
15:08:06 <oerjan> and it can be caught in the IO monad
15:08:12 <oerjan> with some luck
15:08:19 <FunctorSalad> hehe
15:08:36 <FunctorSalad> why doesn't head use something explicit like Maybe a?
15:08:49 <FunctorSalad> too much clutter, I suppose
15:08:52 <oerjan> because that's what listToMaybe does...
15:08:57 <jedai> FunctorSalad: Yep
15:08:59 <FunctorSalad> ok :)
15:09:24 <SyntaxNinja> brian` I just used the binary from the downloads page and don't have libreadline 4 installed.
15:09:43 <jedai> You have a "safe" library on hackage somewhere with plenty of variant on those head, last and other partial functions
15:10:49 <dolio> What's the point of head returning a Maybe?
15:11:08 <glguy> > head []
15:11:17 <dolio> 'case head l of Nothing -> ... ; Just x -> ...' 'case l of [] -> ... ; [x] -> ...'
15:11:25 <oerjan> since the point of head must be to avoid explicit pattern matching, that would be useless
15:12:37 <glguy> hardly..
15:12:46 <FunctorSalad> hmm?
15:13:00 <SyntaxNinja> glguy: y0
15:13:10 <oerjan> unless of course Maybe was what you really wanted eventually
15:13:18 <glguy> yow!
15:13:27 <glguy> wazzup?
15:13:49 <FunctorSalad> oerjan: well you could print an error to the user instead of crashing the whole program
15:13:52 <dolio> Yeah, if you want to use it like a monad. But listToMaybe might be a more obvious specification of that than 'head'.
15:14:07 <FunctorSalad> dolio I don't understand that case ...
15:14:22 <SyntaxNinja> glguy: not much.  I think I'm going to go for a bike ride.
15:14:33 <SyntaxNinja> glguy: what are you up to on your last day of freedom?
15:14:40 <dolio> FunctorSalad: The point is, having 'head' reaturn a Maybe, and then matching on the maybe is more work than just matching on the list in the first place.
15:14:55 <glguy> guitar hero iii and playing with my dog
15:15:38 <FunctorSalad> dolio: didn't see the ' ' in the middle :)
15:16:00 <SyntaxNinja> glguy: maybe the next revolution in video games wlil have to do with pets, rather than dancing, guitar playing, and wii-ing hmm.
15:16:11 <SyntaxNinja> yo ucould write 'fetch' for the wii I guess
15:16:26 <FunctorSalad> (head mylist >>= naiveFunction) would work as long as you handle it in the end, though
15:16:32 <glguy> SyntaxNinja, like nintendogs
15:16:38 <glguy> SyntaxNinja, or tamagotchi?
15:16:54 <FunctorSalad> (but that's what this listToMaybe is for, of course)
15:16:56 <dolio> FunctorSalad: I should have written "(x:_)" instead of "[x]", though. Not sure what I was thinking there.
15:18:14 <SyntaxNinja> glguy: a wii controller with a gps, so you can take it outside and wait for it?
15:18:49 <dolio> FunctorSalad: Anyhow, the real solution is clearly dependent typing, and statically proving that your program never takes the head of an empty list. :)
15:19:06 <FunctorSalad> dolio: if possible, yes
15:19:14 <glguy> is dependent typing still static analysis?
15:19:27 <dolio> Kind of blurs the line, really.
15:20:18 <dolio> You don't need dependent typing to prove list correctness, of course, since you can do it in Haskell's type system. It's just unpleasant looking, last I checked.
15:21:02 <dolio> Type functions may have made it look nicer, though. I've been slacking off of late.
15:21:07 <glguy> I imagine you could have GADT solution... List NonEmpty vs List a
15:21:19 <glguy> to avoid having an actual separate type
15:23:24 <glguy> SyntaxNinja, consider bringing lunch tomorrow for guitar hero Wednesday (or ordering one :) )
15:24:02 <FunctorSalad> let k=50, p=547 in head [x | x <- [0 .. 546], x*k `mod` 547 == 1]
15:24:17 <FunctorSalad> static analysis will have a hard time knowing that this is safe ;)
15:24:34 <FunctorSalad> oh, silly me. didn't use the p
15:24:40 <jimstutt> yaxu: Hi, you might know. Does haskore build with ghc-6.8.2 yet?
15:24:59 <dolio> Can't that be totally evaluated at compile time?
15:25:41 <FunctorSalad> dolio: yes. I meant something like: inv k p = head [x | x <- x*k `mod` p == 1]
15:25:41 <LoganCapaldo> looks like it to moi
15:25:46 <yaxu> hi jimstutt!  i don't know sorry
15:25:51 <dolio> Ah, okay.
15:25:55 <FunctorSalad> with p prime
15:26:07 <FunctorSalad> which you'd have to say statically somehow...
15:26:17 <oerjan> gcd k p == 1
15:26:38 <FunctorSalad> ok, if that is static enough :)
15:26:51 <FunctorSalad> I thought like a type "primeInt"
15:27:00 <SyntaxNinja> glguy: could do.
15:27:01 <SyntaxNinja> hmm
15:27:02 <FunctorSalad> this is getting into theorem proving I suppose
15:27:19 <dolio> Anyhow, head doesn't exist with the same type if you're doing this kind of static analysis directly in your type system.
15:27:26 <jimstutt> yaxu: tnx.
15:27:33 <dolio> It's 'head :: List NonEmpty a -> a'
15:27:36 <dolio> Or something of that sort.
15:28:10 <dolio> So, even if it can't tell statically that the list is nonempty, you'd be forced to handle both cases by doing a test that the list is nonempty.
15:28:16 <FunctorSalad> yeah, the list comprehendor couldn't return a List NonEmpty a
15:28:52 <dolio> Or by ensuring conditions on the other stuff to make sure it's nonempty, although that'd be pretty fancy.
15:29:13 <LoganCapaldo> it could if it was a monad comprehension and List NonEmpty was an instance of Monad
15:29:53 <oerjan> List NonEmpty is not a MonadZero though...
15:30:03 <oerjan> and the filtering uses that
15:30:15 <LoganCapaldo> yes
15:30:19 <LoganCapaldo> that ruins  it
15:30:25 <LoganCapaldo> I knew too
15:30:47 <LoganCapaldo> but I'd rather be wrong and encourage monad comprehensions than right and remain silent :p
15:31:01 <dolio> Heh.
15:31:25 <jsnx> lolz
15:31:32 <jimstutt> yaxu: what was your brilliant youtube vid written in, if you don't mind me asking?
15:32:46 <jsnx> jimstutt: what vid is that?
15:37:46 <hpaste>  izuker pasted "Less Polymorphic Error" at http://hpaste.org/4754
15:38:55 <jimstutt> jsnx: http://www.dailymotion.com/yaxu but maybe he didn't make it or the 2 others on youbutt
15:39:14 <izuker> if someone could help with a typing error:
15:39:18 <izuker> http://hpaste.org/4754
15:40:41 <oerjan> izuker: it may be because total is hit by the monorphism restriction?
15:41:12 <oerjan> add a type declaration for it
15:41:20 <oerjan> *monomorphism
15:42:05 <izuker> ?
15:42:06 <allbery_b> alternately the type a might be defaulted
15:42:10 <hpaste>  mdmkolbe|ubuntu pasted "Any suggestions for name of this function?" at http://hpaste.org/4755
15:42:41 <jsnx> jimstutt: that is quite humerous
15:42:54 <oerjan> izuker: a definition on the form total = ... cannot be polymorphic if it has class restrictions
15:43:08 <oerjan> unless you add a type declaration for it
15:43:44 <hpaste>  dolio annotated "Less Polymorphic Error" with "get rid of total" at http://hpaste.org/4754#a1
15:44:37 <yaxu> jimstutt: the source is here http://doc.gold.ac.uk/~ma503am/alex/vocable-bugfix/
15:44:48 <dibblego> lamdabot, where are thou!?
15:44:54 <dibblego> lambdabot too!
15:45:12 <izuker> hmmm.  i don't quite understand.  *could* i fix the problem by specifying total's type?
15:45:32 <yaxu> jimstutt: it's written in haskell, which is controlling supercollider server using rohan drape's hsc module
15:45:32 <izuker> and if so, what would that type be?
15:45:47 <oerjan> Num a => a
15:45:53 <jsnx> yaxu: that video is great. what is rsi in this context?
15:46:08 <olsner> repetitive strain injury?
15:46:23 <yaxu> olsner: yep :)
15:46:27 <oerjan> btw fromInteger . toInteger = fromIntegral
15:46:38 <izuker> excellent, thanks!
15:46:51 <yaxu> jsnx: thanks :)
15:46:56 <conal> yaxu: is each line in that video a version of the whole program?
15:47:09 <yaxu> conal: yes
15:47:20 <oerjan> izuker: also moving total _inside_ the lambda would probably work as well
15:47:44 <yaxu> each line represents a polymetric rhythm
15:47:46 <oerjan> since then it has a type given by the type of x
15:47:51 <conal> yaxu: what gives it continuity?  is there some kind of time index that's maintained across versions?
15:47:52 <yaxu> each new line replaces the previous one
15:48:28 <conal> yaxu: i have the same question about http://homepage.mac.com/digego/study_in_keith.mov
15:48:41 <yaxu> well each line describes a loop, and it waits until the a loop is finished before playing the next one
15:48:45 <yaxu> if that makes sense
15:48:53 <conal> oh -- yeah.  that's simple.
15:49:20 <yaxu> not exactly sure how impromptu does it in that movie, but there's a nice paper about it
15:49:36 <jimstutt> yaxu: Guessed the haskell bit :). We'll have a look at the details cf some Lua expts. Tnx
15:49:37 <conal> yaxu: url?
15:50:16 <conal> yaxu: by waiting for the loop to finish, you don't need to carry any state across versions, right?
15:50:47 <hpaste>  mmmdonuts annotated "Less Polymorphic Error" with "shifting fromIntegral is another way to fix it" at http://hpaste.org/4754#a2
15:50:51 <dibblego> > 7
15:51:08 <yaxu> conal: that's right
15:51:25 <yaxu> conal: http://impromptu.moso.com.au/extras/aa-cell-icmc07.pdf
15:51:37 <conal> thx!
15:52:43 <oerjan> mdmkolbe|work: it resembles Control.Exception.catchJust a bit, except you use a Bool rather than Maybe
15:52:59 <yaxu> conal: 3.5 describes "temporal recursion"
15:53:42 <conal> yaxu: i've been playing with general approaches to adaptive (data-dependent) computation that can be used in GUIs, animations, and automatic recompilation & execution, and installation.  i think there's a strong connection to livecoding.
15:54:19 <yaxu> conal: it seems a function calls itself when it's done generating (for example) a bar, at which point any replacement function is enacted
15:54:51 <conal> yaxu: oh!  end-of-bar gives some continuity.
15:55:20 <conal> simple solution.
15:55:34 <yaxu> also state may be passed
15:57:27 <thetallguy>  conal: link to Graeme event?  google didn't turn anything up for me
15:58:02 <conal> thetallguy: i couldn't find a link.  i have some email.
15:58:12 <thetallguy> conal: forward?
15:58:28 <thetallguy> conal: public?
16:02:43 <thetallguy> conal: thanks
16:05:01 <dufflebunk> How long does the stuff in hpaste stick around?
16:05:51 <Saizan> indefinitely, modulo failures
16:06:31 <oerjan> http://hpaste.org/1 is 347 days old
16:06:57 <dufflebunk> Yeah, that's why I was wondering.
16:08:13 <mdmkolbe|work> @index catchJust
16:08:34 <oerjan> Control.Exception, i said
16:08:40 <allbery_b> bot go byebye
16:09:17 <mdmkolbe|work> oerjan: heh, just saw that after typing it
16:10:11 <nolrai> is there a binary operator version of msum? (i.e. sum is to add as msum is to ?? )
16:10:29 <mdmkolbe|work> hmm, maybe "catchIf"
16:10:48 <oerjan> nolrai: mplus
16:10:55 <nolrai> doh!
16:11:32 <dibblego> ?type add
16:12:02 * oerjan thinks + was meant
16:12:21 <dibblego> ah right; folding over a monoid?
16:12:31 <oerjan> mconcat/mappend
16:12:46 <oerjan> msum/mplus : MonadPlus
16:18:42 <wolverian> wow, ghc6.8 isn't in debian?
16:19:30 * mdmkolbe|work misses it not being in Ubuntu either
16:20:08 <dolio> Ubuntu is frequently behind in that department.
16:20:27 <wolverian> no, its releases are, but that's inherent in the nature of the release system
16:20:35 <dolio> Yeah.
16:20:35 <wolverian> the head is pretty much up to date with debian
16:20:48 <wolverian> but the problem isn't being stuck on an old ubuntu, here :)
16:21:21 <dolio> I've tried running the head close to a release and that was a disaster, so I'm not too keen on trying it well before. :)
16:22:01 <dolio> And GHC isn't a high priority backport.
16:22:27 <dolio> Although, compiling the latest version into /usr/local isn't hard at all, so it's not a big deal.
16:22:36 <brian`> how do i execute .deb file?
16:23:05 <wolverian> do you mean install?
16:23:10 <brian`> yeah
16:23:14 <wolverian> dpkg -i file.deb
16:23:21 <brian`> does it work on ubuntu as well?
16:23:25 <wolverian> though it's pretty uncommon to download one yourself; generally one uses apt-get .
16:23:38 <brian`> yeah but for installing ghc 6.8
16:23:43 <brian`> i guess i need to use debian package
16:23:49 <wolverian> there is no debian package.
16:24:06 <nolrai> I think you need to install that from source.
16:24:15 <nolrai> (I did)
16:24:21 <brian`> i downloaded the binary file for ghc 6.8
16:24:27 <brian`> and after the installation
16:24:29 <brian`> i ran ghc
16:24:40 <brian`> and it said"/usr/local/lib/ghc-6.8.2/ghc-6.8.2: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory"
16:24:58 <brian`> so i downloaded libreadline.so.4 from rpm downloading webpage
16:25:01 <brian`> and converted it to deb
16:25:10 <brian`> i'm trying to install it now..
16:25:26 <wolverian> why didn't you just install libreadline with apt-get?
16:25:39 <brian`> with apt-get
16:25:46 <brian`> i can only find libreadline.so.5
16:25:52 <brian`> and it's already installed on my comp
16:25:58 <wolverian> ah, that's problematic. you're probably better off compiling ghc yourself.
16:26:04 <dibblego> anyone know if lambdabot is coming home any time soon?
16:26:15 <brian`> wolverian, would that solve the issue im having then?
16:26:29 <brian`> wolverian, then i should do it the compiling myself :)
16:26:39 <wolverian> yes.
16:26:54 <jimstutt> brian: ghc-6.8.2 binary seems to run fine on ubuntu hardy heron 8.04 mod known bugs
16:27:11 <wolverian> how stable is hardy, btw?
16:27:19 <brian`> i'm using 7.10 now
16:27:21 <wolverian> should I chroot or just switch my desktop over?
16:27:30 <wolverian> ...assuming I want to run it
16:28:47 <IvdSangen> is there any work on adding "laws" to type classes, for instance adding "a < b = not $ b < a" to Ord
16:28:55 <brian`> hm.. even compiling ghc 6.8.2 myself
16:28:55 <brian`> it says
16:29:03 <IvdSangen> my idea was to let a programmer supply a proof for the "law"
16:29:04 <brian`> "checking for path to top of build tree... /usr/local/lib/ghc-6.8.2/ghc-6.8.2: error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
16:29:05 <brian`> "
16:29:26 <jimstutt> wolverian: had to bump to hardy Tribe1 or whatever cos gutsy did for my sony notebook X and lots of crashes. Much fewer crashed on hardy so far.
16:29:35 <wolverian> brian`, when? after make install? did you uninstall the previous version?
16:29:35 <conal> brian`: with what compiler?
16:29:45 <wolverian> jimstutt, well, nice. you use it as a desktop?
16:29:49 <brian`> i was doing configure
16:29:58 <brian`> and it gave me that error
16:30:05 <allbery_b> brian`: ghc needs a binary ghc to bootstrap.  as for libreadline, if you have libreadline.so.5, symlink it to libreadline.so.4
16:30:15 <brian`> aha
16:30:18 <wolverian> brian`, it's trying to use the ghc 6.8.2 you've installed that doesn't work for bootstrap.
16:30:19 <brian`> ok i'll try
16:30:23 <wolverian> allbery_b, that's dangerous.
16:30:33 <allbery_b> dangerous but seems to work often enough
16:30:36 <wolverian> brian`, remove the ghc that doesn't work, install ubuntu's 6.6, and use that to compile your own 6.8
16:30:41 <wolverian> allbery_b, until it doesn't.
16:30:41 <brian`> hm.. i guess i need to reinstall 6.6 using apt-get again
16:30:44 <brian`> ueaj
16:30:45 <brian`> yeah*
16:30:53 <allbery_b> there's a real libreadline.so.4 downloadable on the ghc binaries page
16:31:29 <wolverian> I'd rather compile my own ghc than pollute the library path with that :) I'm weird like that.
16:31:50 <jimstutt> wolverian: yep cos something (probably my config and sony) has disabled my keyboard in xmonad.
16:32:06 <wolverian> jimstutt, nice :)
16:32:08 <brian`> wolverian, that's not weird at all lol we're just trying to keep within our control hehe
16:32:32 <wolverian> of course, I ./configure --prefix=$HOME ...
16:32:38 <wolverian> brian`, good to hear. :)
16:33:14 <LoganCapaldo> hpaste: will you come join us in -blah?
16:33:50 <Pseudonym> Actually, I asked this yesterday, but someone might have an answer now.
16:33:58 <Pseudonym> Has anyone packaged GHC 6.8 for Debian yet?
16:34:39 <jimstutt> brian: somehow I'm on libreadline-5.2-3build1 if that's any help
16:36:13 <brian`> i'm so happy that i have a decent new computer now :)
16:36:29 <brian`> i'm gonna use it as development machine
16:36:55 <wolverian> Pseudonym, no.
16:37:05 <Pseudonym> Figured, thanks.
16:37:34 <wolverian> I would love to do it (I have some experience with building debs), but GHC scares me.
16:37:43 <wolverian> it is ... not small.
16:37:47 <LoganCapaldo> eh
16:37:55 <LoganCapaldo> I built ghc on my computer
16:38:04 <LoganCapaldo> it took a while
16:38:05 <Pseudonym> I have the opposite problem.
16:38:08 <LoganCapaldo> but I did it
16:38:19 <Pseudonym> I don't mind GHC, but building debs scares me.
16:38:25 <LoganCapaldo> I don't know nothing about building debs though
16:38:36 <Pseudonym> I don't mind screwing up my own machine, but screwing up others would be bad.
16:38:38 <wolverian> Pseudonym, I didn't say building debs doesn't scare me. :)
16:38:40 <LoganCapaldo> you two should get together
16:39:04 <wolverian> nah, you really want to talk to the debian GHC maintainer
16:39:20 <wolverian> or if you can't reach him, someone who's familiar with the packaging and preferably a debian maint.
16:39:34 <Pseudonym> Yeah.
16:39:39 <kaol> there's http://haskell-unsafe.alioth.debian.org/archive/
16:39:40 <Pseudonym> I knew a debian maintainer IRL once.
16:39:45 <wolverian> kaol, it has 6.6.1
16:39:45 <Pseudonym> He now works for Microsoft.
16:39:48 <Pseudonym> Sad case.
16:40:11 <wolverian> Pseudonym, well, MS's R&D sometimes manages to release nice stuff...
16:40:13 <kaol> try building http://haskell-unsafe.alioth.debian.org/archive/amd64/unstable/g/ghc6/ for i386
16:40:25 <wolverian> ah, there's 6.8.2!
16:40:31 <Pseudonym> Yeah, but he doesn't work for MSR.
16:40:35 <Pseudonym> He works for MS.
16:40:45 <wolverian> kaol, thanks, I'm taking a look at that.
16:40:51 <Pseudonym> Just trust me when I say "sad case".
16:41:16 <kaol> the packages might eat your computer, etc. take care.
16:42:38 <wolverian> eh... come on people, use dpatch or SOMETHING, dammit
16:45:28 * kaol uses quilt himself
16:46:03 * wolverian points to the 20kb .diff
16:52:02 <jimstutt> Errh. darcs hs-plugins plugins-1.1 -> missing dependency ghc >=6.8 but I'm on 6.8.2 ;)
16:52:20 <sarehu> > map (-2)  [2,3,4 :: Int] :: [Int]
16:52:23 <sarehu> [0,1,2]
16:52:35 <Korollary> Pseudonym: I've built a 6.8.2 deb for myself on ubuntu. It works, but I don't know if I did it right by the book, tho.
16:52:50 <Pseudonym> That's the thing, yeah.
16:57:50 <brian`> how long does it usually take to compile ghc 6.8.2?
16:58:01 <brian`> it looks like taking a long time for me ;
16:58:02 <oerjan> sarehu: using weird Num instance?
16:58:08 <mauke> OVER 9000 SECONDS
16:58:13 <brian`> wow ;
16:58:16 <sarehu> oerjan: yep ^_^
17:11:49 <brian`> hey how do I type ^M thing?
17:12:04 <brian`> I copied .vimrc file from dos
17:12:10 <brian`> and it has ^M ...
17:12:14 <brian`> is there an easy way to do so?
17:12:21 <brian`> I was going to use regular expression from gvim
17:12:25 <Lemmih> brian`: dos2unix
17:12:26 <brian`> but i don't know how to type that..
17:12:52 <Saizan> 8
17:12:55 <allbery_b> in vi?  ^V^M
17:13:17 <brian`> aha~
17:13:23 <brian`> do you know what symbol is it called?
17:13:33 <wolverian> I have a few types who I'd like all to have a record field of the same name. i.e. data Foo = Foo { bar :: Bar }; data Baz = Baz { bar :: Bar }; this doesn't work. is there a natural method to do this?
17:13:47 <allbery_b> ^M?  "carriage return" or just "return"
17:13:55 <allbery_b> wolverian: nope
17:14:09 <oerjan> wolverian: a field has to have a unique type
17:14:14 <allbery_b> various ugly ways to simulate it if you don't mind not being able to pattern match on the name
17:14:20 <wolverian> that is rather inconvenient.
17:15:45 <wolverian> allbery_b, how ugly? :)
17:16:16 <allbery_b> the usual trick I've seen is to define a one-off typeclass
17:16:22 <oerjan> i think you can get pattern matching with explicit constructor to work if you use a ghc extension and separate into modules
17:16:53 <allbery_b> yeh, qualified names should work to (even without an extension, I think)
17:17:16 <wolverian> qualified names are just another form of what I'm trying to avoid. (fieldFoo, fieldBar, fieldBaz..)
17:17:17 <allbery_b> as long as they're defined in different modules
17:17:39 <wolverian> I suppose I need a typeclass. thanks. I wonder if TH would make this nice for me.
17:17:42 <oerjan> wolverian: the ghc extension allows you to drop the qualifier when the constructor is explicit
17:17:59 <wolverian> oerjan, explicit?
17:18:24 <oerjan> case ... of Foo { bar = x } -> ...
17:18:43 <oerjan> the Foo needs to be explicit
17:20:21 <wolverian> oh, it can sometimes be implicit? not sure how that works.
17:20:43 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
17:20:56 <oerjan> well not in that case
17:21:12 <oerjan> but in construction as an expression
17:21:26 <oerjan> rec { bar = x }
17:21:58 <wolverian> ah, right.
17:23:26 <oerjan> of course, it is still ugly :)
17:25:19 <todizz> is there a function that can 'rotate' a list of lists so that each first item is in the first list, each second is in the second and so on
17:25:25 <todizz> or would i have to make that myself
17:25:46 <oerjan> todizz: hm, example?
17:26:15 <Lemmih> todizz: transpose?
17:26:15 <oerjan> maybe transpose
17:26:18 <jsnx> todizz: that is a matrix transposition, yes?
17:26:32 <todizz> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2,3],[4,5,6],[7,8,9 -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2,3],[4,5,6],[7,8,9
17:27:03 <todizz> im not sure why that made a hyperlink
17:27:15 <todizz> but yes i think transpose is what i was looking for
17:27:16 <todizz> thanks
17:27:27 <jsnx> todizz: link does not work...
17:27:33 <kpreid> > transpose [[1,2],[3,4]]
17:27:48 <kpreid> todizz: you have something wikipedia-ifying in your irc client
17:28:09 <todizz> it seems so
17:28:10 <kpreid> it evidently assumed that [[...]] was supposed to be a link into wikipedia
17:28:16 <todizz> i didnt know until now
17:28:28 <kpreid> where's lambdabot?
17:28:28 <todizz> its konversation
17:28:45 <oerjan> hm completely gone now
17:29:23 <hpaste>  Yoshi pasted "Help A Beginner =]" at http://hpaste.org/4757
17:29:54 <kpreid> hpaste: the branches of your if don't match
17:30:10 <kpreid> "head n" cannot have the same type as "n"
17:30:20 <kpreid> er, yoshi:
17:30:22 <Lemmih> yoshi: What's it supposed to do?
17:30:28 <kpreid> perhaps you meant "then tail n"
17:31:16 <dibblego> yoshi, you probably should pattern match there
17:32:11 <yoshi> if the first element in the list is the same as the the second then return a list of just the first element, otherwise just the list
17:32:35 <oerjan> yoshi: then [head n]
17:32:53 <dibblego> let foo x@(a:b:_) = if a == b then [a] else x
17:33:04 <todizz> transpose would be in Data.List correct?
17:33:09 <yoshi> i'm such an idiot hahahahah
17:33:10 <oerjan> todizz: yep
17:33:30 <yoshi> oerjan: thanks
17:34:05 <oerjan> yoshi: of course dibblego's version is more haskellish
17:34:13 <dibblego> it's also a different function
17:34:25 <dibblego> the one yoshi seemed to describe
17:35:12 <dibblego> yoshi, you sure you've got the right function there?
17:35:44 <yoshi> yup positive
17:35:54 <dibblego> so "just the list" was wrong?
17:36:48 <yoshi> yeah i was looking at that module for like 20 minutes and i couldn't figure it out lol
17:36:57 <dibblego> ok
17:37:08 <oerjan> dibblego: er what he said matches your version, as well as his after adding brackets
17:37:34 <dibblego> oerjan, right, is that not right?
17:37:42 <BMeph> eah, dibblego's line won't pattern-match on a one-element list.
17:38:02 <dibblego> BMeph, it's undefined, as per the original code (head $ tail n)
17:38:04 <todizz> how would u compare the second item to the first if there is only 1 item
17:38:08 <oerjan> neither will yoshi's version
17:39:47 <BMeph> Right, but you'd likely get some kind of non-exhaustive pattern message from just yours, dibblego.
17:40:10 <dibblego> BMeph, no different to the 'head of empty list' message you'd get on the original
17:40:11 <todizz> only if he passes a list with a single item
17:40:44 <BMeph> yoshi's version will raise an error, though, from trying to get head [].
17:41:02 <wolverian> the template haskell links on hoogle are 404
17:41:08 <wolverian> http://haskell.org/hoogle/?q=reify e.g. these
17:41:20 <dibblego> BMeph, both are _|_
17:41:32 <yoshi> oerjan: dibblego 's verson works the same
17:41:32 <ramza3> is there a "import Data.Binary" module?  for getWord8 the function
17:41:49 <dibblego> yoshi, dibblego's version doesn't work the same as oerjan's version (which do you want?)
17:42:00 <oerjan> sure it does
17:42:16 <yoshi> I just tested it in ghci
17:43:02 <todizz> ramza3: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
17:43:22 <hpaste>  dibblego annotated "Help A Beginner =]" with "it doesn't" at http://hpaste.org/4757#a1
17:45:02 <BMeph> dibblego: Both programs will work the same, they just won't compile the same, that's all I'm saying.
17:45:19 <oerjan> dibblego: sheesh my correction was only for the then branch, not the whole function
17:45:32 <dibblego> you buggers are trying to confuse me!
17:45:57 <oerjan> ooh wait
17:46:18 <oerjan> er no
17:46:32 <dibblego> BMeph, do you often write patterns that simply call error?
17:47:10 <hpaste>  (anonymous) annotated "Help A Beginner =]" with "(no title)" at http://hpaste.org/4757#a2
17:47:18 <dibblego> oerjan, please help, who's doing what around here?
17:47:25 <BMeph> dibblego: not often, but I have done it.
17:47:44 <oerjan> dibblego: our corrections are equivalent as far as i can see.
17:47:55 <dibblego> oerjan, are you (anonymous)?
17:48:01 <oerjan> no
17:48:12 <dibblego> where is your correction
17:48:18 <dibblego> (by the way anonymous, else what?)
17:48:31 <yoshi> http://hpaste.org/4757
17:48:44 <oerjan> dibblego: in the channel
17:48:58 <yoshi> works fine thanks you guys
17:49:00 <oerjan> oerjan> yoshi: then [head n]
17:49:02 <ramza3> todizz, there is no standard binary package with support little/big endian getword
17:49:13 <dibblego> yoshi, on that page, I see one annotation, with two functions that are not equivalent; one of which you want (which?), followed by an annotation with code that does not compile
17:49:20 <todizz> no standard but there is a hackage package
17:49:21 <dibblego> I am completely confuzzled!
17:50:23 <dibblego> oerjan, I honestly do not see it
17:50:49 <todizz> ramza3: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.1
17:50:59 * dibblego looks around expecting to be on candid camera
17:51:12 <oerjan> dibblego: in my client, the line just before your own initial correction
17:51:40 <yoshi> I don't see it either and the code compiles just fine for me
17:51:42 <dibblego> I don't have an initial correction
17:51:46 <oerjan> *suggestion
17:51:50 <oerjan> sheesh!
17:51:54 <dibblego> [head n]
17:52:00 <dibblego> a different function
17:52:02 <todizz> do you mean to put the head n in the then in []
17:52:04 <oerjan> dibblego> let foo x@(a:b:_) = if a == b then [a] else x
17:52:07 <todizz> to make it a string
17:52:32 <dibblego> [head n] is a correction?
17:52:34 <oerjan> dibblego: "then [head n]"! just the "then" branch!
17:52:46 <dibblego> oh
17:52:47 <todizz> so it will return a string
17:52:50 <todizz> rather than a char
17:53:13 <dibblego> cripes, sory
17:54:11 <todizz> doesn't the functions type say it takes a list of strings and returns a list of strings?
17:54:21 <oerjan> todizz: yep
17:54:42 <todizz> then why would head n return a Char
17:55:06 <dibblego> it returns a String
17:55:21 <todizz> the error message said it was inferred as a Char
17:55:42 <oerjan> todizz: when matching the type String against [String], it recurses to matching Char with String
17:55:52 <todizz> o
18:01:29 <LoganCapaldo> > "" :: [a]
18:01:50 <allbery_b> still no bot
18:01:54 <LoganCapaldo> oh
18:01:57 <LoganCapaldo> darn
18:02:01 <LoganCapaldo> i forgot
18:02:09 <allbery_b> where's dons when you need him? :)
18:02:20 <LoganCapaldo> @get-dons
18:02:28 <monochrom> haha
18:02:28 <LoganCapaldo> mmm
18:02:38 <LoganCapaldo> chicken and egg problem
18:02:40 <mauke> @get-lambdabot
18:02:53 <monochrom> "I need to bootstrap dons"
18:02:57 <ricky_clarkson> I believe dons was first.
18:05:00 <Brian`> hi, in hackageDB
18:05:04 * BMeph wonders if a time-travelling lambdabot from the future will soon take over the world...
18:05:04 <Brian`> if it says
18:05:20 <Brian`> base (<3) ... or base (>=3) ...
18:05:27 <Brian`> how do i check if my base is <3 or >=3?
18:05:48 <stepcut> ghc-pkg list
18:06:16 * conal wonders what auto-smiley mode would do to Brian`'s example
18:06:18 <Lemmih> I'm pretty sure it is.
18:07:20 * BMeph wonders if the last part of Brian''s statement would be obscene in auto-smiley mode
18:08:28 <mauke> =( )=
18:10:23 <wolverian> I remember seeing some new stuff being added to the record system to make it easier to use, but this was in HEAD, not 6.8.2, right?
18:10:29 <oerjan> is that two smileys or just one with a really big nose?
18:11:03 <oerjan> wolverian: i saw something on that too
18:11:18 <jimstutt> ghc-pkg
18:12:19 <wolverian> I can't remember which mailing list it was on
18:12:52 <wolverian> is there one for ghc dev?
18:15:28 <oerjan> "There are also new flags -frecord-puns and -frecord-dot-dot for record punninng, but these do not work correctly yet, and so are not supported."
18:15:37 <oerjan> from 6.8.1 release notes
18:16:34 <wolverian> hm. those don't really help me, I suppose. dammit, can't ghc just make a class for me? :) I'm halfway through writing a TH function to do it, but TH's docs suck pretty badly so I'm losing interest..
18:16:47 <wolverian> not that making a class really works in all cases either
18:17:11 <wolverian> I think I'll use -fdisambiguate-record-fields, that's the best approximation right now. thanks, oerjan .
18:19:56 <jimstutt> ghc is not in ghc-pkg list. It was with 6.8.1. Could this be my missing build depend ghc >= 6.8 error?
18:20:24 <EvilTerran> wolverian, how about HList's type-indexed structures? :P
18:21:07 <jimstutt> I get it trying to build hs-plugins, Wish I could get back to syntax.
18:21:24 <EvilTerran> they're the closest we've got to proper extensible-but-statically-checked records
18:21:46 <wolverian> haven't looked at those. thanks, I'll check.
18:22:38 <EvilTerran> OTOH, be aware that they're the highest concentration of Olegs i've seen, by a long way ;)
18:23:21 <Saizan> and there's no polished release of HList
18:23:45 <wolverian> eek. that's scary.
18:31:13 <EvilTerran> :D
18:34:40 * pgavin is back (gone for 07:12.56)
18:34:46 * pgavin is back
18:34:53 * pgavin is back
18:34:56 * pgavin is back
18:35:02 * pgavin is back
18:35:03 <Lemmih> pgavin: We got it.
18:37:00 * BMeph hopes that pgavin puts down the mouse and steps away from the status box, before Lemmih "lays down the law"
18:42:33 <conal> pgavin: was that some kind of auto-message?
18:42:56 <Brian`> hi,
18:42:59 <Brian`> i got a problem..
18:43:02 <Brian`> i installed xmonad
18:43:09 <Brian`> and used it for one session
18:43:09 <conal> is that the problem?
18:43:12 <conal> just kidding
18:43:16 <Brian`> hehe
18:43:22 <Brian`> and i tried to go back to gnome
18:43:25 <Brian`> and it says
18:44:03 <Brian`> "Your session only lasted less than 10 seconds. if you have not logged out yourself, this could mean that there is some installation problem or that you may be out of diskspace (which is not the case for me. Try logging in with one of the failsafe sessions to see if you can fix this problem"
18:45:55 <Brian`> and the details (~/.xsession-errors file) says "(process: 6043) Gtk-Warning**: This process is currently running setuid or setgid. This is not a supported use of GTK+. You must create a helper program instead. For further details, see http://www.gtk.org/setuid.html
18:46:02 <Brian`> Refusing to initialize GTK+ blah blah
18:46:14 <Brian`> has anyone run into the same problem?
18:47:08 <pgavin> sorry about that earlier
18:47:12 <pgavin> not sure why my client started doing that :/
18:47:29 <byorgey> Brian`: I've seen that error before, but I don't think it's the real problem
18:48:16 <byorgey> Brian`: btw, #xmonad would probably be a better place for this
18:50:17 <Brian`> haha :) problem solved
18:50:28 <Brian`> i deleted .xsession file and it worked -_-;
18:50:32 <Brian`> i don't know why hehe
18:50:58 <byorgey> Brian`: ok, cool =)
18:51:16 <Brian`> byorgey, thanks for helping me though :)
18:51:20 <byorgey> Brian`: sure =)
18:58:03 <pgavin> has anyone played with PIC & dynamic libraries in ghc-6.8.2?
18:59:46 <visof> > 2+3
19:00:07 <LoganCapaldo> lambdabot is on vacation
19:00:12 <mauke>  5
19:00:18 <visof> oh
19:00:28 <LoganCapaldo> hehe
19:00:37 <LoganCapaldo> mauke bot rules
19:01:13 <LoganCapaldo> @yow
19:01:56 <conal> remember, mauke: only 3 seconds of compute per request.
19:02:09 <oerjan> WHY do you think my GARAGE is filled with RHUBARB?
19:02:14 <LoganCapaldo> and no IO!
19:02:23 <conal> hurray -- no IO!
19:07:25 <Pseudonym> > readFile "/etc/passwd"
19:08:03 <oerjan> <IO String>
19:08:23 <mdmkolbe|work> @type (1-)
19:08:31 <mdmkolbe|work> @type (-1)
19:08:49 <mauke> (1-) :: (Num t) => t -> t
19:08:52 <mauke> (-1) :: (Num a) => a
19:09:07 <Pseudonym> @vixen So what's up with that?
19:09:36 <mdmkolbe|work> How do I get a (-) slice instead of a negative number?
19:09:46 <oerjan> subtract
19:09:46 <mrd> @type subtract
19:09:57 <EvilTerran> also, the word you are seeking is "section"
19:10:05 <pgavin> subtract :: (Num a) => a -> a -> a
19:10:05 <oerjan> subtract :: (Num t) => t -> t
19:10:07 <LoganCapaldo> use subtract
19:10:14 <oerjan> oops
19:10:21 <oerjan> darn cut and paste :)
19:10:29 <LoganCapaldo> @quote stereo -- this _definitely_ won't work
19:10:29 <pgavin> oerjan: :)
19:12:13 <oerjan> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered? >_>
19:12:46 * LoganCapaldo is starting to believe oerjan really is lambdabot
19:18:46 <mrd> LoganCapaldo: no way, oerjan is much less laggy
19:33:10 <thoughtpolice> while i don't believe quickcheck's arbitrary has a String instance, is there an easy way to generate strings and lists of strings for other arbitrary instances?
19:33:25 <thoughtpolice> i have a data structure I want to randomly generate and several fields are strings or lists of strings.
19:34:33 <Lemmih> Write an Arbitrary instance for Char?
19:37:58 <thoughtpolice> i have one. i'm pretty new to quickcheck though. if I have an instance for char (where arbitrary = choose('\32','\128')), i could generate randomly with vector n :: Gen [Char] right?
19:45:17 <SyntaxNinja> glguy: where's that chart of Equal that I love for php?
19:46:41 <glguy> php.net somewhere (looking)
19:47:19 <glguy> http://www.php.net/manual/en/types.comparisons.php
19:48:18 <EvilTerran> wow.
19:49:20 <SyntaxNinja> glguy: thanks!
19:55:14 <SyntaxNinja> glguy: is there ever a time when a sane person actually wants "==" instead of "===">
19:55:16 <SyntaxNinja> ?
19:55:23 <glguy> sure
19:55:45 <glguy> I mean, I guess you could do a: a === x || a === y || ...
19:55:56 <glguy> but if what you wanted is represented by a == x
19:56:03 <glguy> then no sense in recreating that
19:56:46 * SyntaxNinja nods
19:57:07 <SyntaxNinja> but why do people need to compare "1" == 1
19:57:08 <SyntaxNinja> ?
19:57:26 <glguy> because maybe the user is expected to type a number into a textbox in a form
19:57:35 <glguy> and you want to know if that is > 5
19:57:42 <glguy> or whatever
19:57:59 <glguy> the average PHP user doesn't know there is a difference between "5" and 5
19:58:03 <glguy> so they just coerce
19:59:26 <SyntaxNinja> so then if they type "foo" instead of "5" then it's just not equal and that's fine
20:10:59 <bos> hi SyntaxNinja, bet you're sorry you asked about this now :-)
20:11:20 <SyntaxNinja> asked about equality?
20:11:50 <SyntaxNinja> I already knew how bad it was. I think it's a really good example of the difference between PHP and Haskell.
20:15:34 <SyntaxNinja> bos: how have you been?
20:18:50 <Roberth> hello... im having trouble compiling haskell-x11 on netbsd/i386, the compiler spits out this: Setup.hs: Unrecognised flags: --x-includes=/usr/pkg/include --x-libraries=/usr/pkg/lib how do I solve this?
20:19:30 <bos> SyntaxNinja: busy :-)
20:20:16 <bos> SyntaxNinja: how's the galwegian life?
20:20:40 <SyntaxNinja> bos: going well.  we've had some time off as a year-end bonus, so tomorrow is our first day back at work.
20:20:41 <Pseudonym> "Galwegian" is really a word?
20:20:50 <ricky_clarkson> Glaswegian.
20:21:01 * Pseudonym assumed it meant someone from Galway
20:22:32 <bos> Pseudonym: it's actually from Galloway, in Scotland.
20:22:39 <Pseudonym> Right.
20:23:02 <SyntaxNinja> Galwegian is someone who works for Galois
20:23:05 <SyntaxNinja> :)
20:23:07 * Pseudonym shows his stunning knowledge of British Isles geography
20:23:08 <ricky_clarkson> I was assuming Glasgow would expand, largely due to curry.
20:23:16 <bos> but galois employees punningly refer to themselves as such. i sense andy gill's influence at work!
20:23:25 <SyntaxNinja> it's a play on Glaswegian
20:23:31 <Pseudonym> Yeah.
20:23:43 <SyntaxNinja> maybe it was andy or john ? don't know.
20:23:46 <Pseudonym> The most bizarre variation I've seen is "Taswegian" to refer to a Tasmanian.
20:24:01 <Pseudonym> Or, as some jocularly call it in response, Tasway.
20:24:04 <ricky_clarkson> I used to be a Prestonian dating an Estonian.
20:24:47 * bos puts a bit more spit and polish on the llvm bindings.
20:25:55 <SyntaxNinja> heh
20:28:18 <sjw> any darcs hackers around?
20:28:46 <ricky_clarkson> I believe #darcs has some of those (they're probably here too though).
20:29:45 <sjw> of course (thanks)
20:32:55 <BMeph> Eww! I don't like PHP, it's kind of stupid... :p
20:33:17 <ricky_clarkson> I think that's one of its design goals.
20:34:12 <BMeph> It's the only language I've heard of with a non-transitive equality operator. That's just bone-headed. :(
20:34:40 <SyntaxNinja> BMeph: oh yeah! thanks for reminding me about that
20:34:43 <sjw> BMeph: and the variable scoping is all wrong
20:36:25 <BMeph> sjw: It has a non-transitive equality operator! That's more severe to me than bad variable scoping. Maybe that's just a personal prejudice as a former Math major, though.
20:36:36 <ricky_clarkson> From what I've seen, PHP users seem proud of succeeding despite the language.  I haven't seen them get beyond 'debugging into existence', however.
20:37:49 <lekro> BMeph: what about C++?  char* p = 0; then: p == 0 and 0 == 0.1, but p == 0.1 does not work
20:37:51 <phobes> == isn't transitive in C++ either
20:37:57 <phobes> um ya
20:38:05 <sjw> BMeph: I think I put it out of it's misery before I got to that point :)
20:38:22 <phobes> also, pointers don't necessarily compare transitively
20:38:42 <SyntaxNinja> "-1" == TRUE
20:38:42 <SyntaxNinja> TRUE == "1"
20:38:42 <SyntaxNinja> but "-1" != "1"
20:38:46 <Pseudonym> Where do you get 0 == 0.1?
20:39:58 * SyntaxNinja doesn't get lekro's example either
20:40:04 <SyntaxNinja> where isn't C++ transitive?
20:40:11 <phobes> ya I'm not sure that example works...
20:40:22 <lekro> oh, sorry. I thought 0.1 would be casted to int there
20:40:34 <LoganCapaldo> 0 will get promoted to 0.0
20:40:35 <lekro> (shame on me)
20:40:41 <lekro> I know. I should know :)
20:40:53 <phobes> well if you have class B : A, and class C :A, then you can compare A * and B *, and B * and C *,  but not A* and C*
20:41:11 <Pseudonym> http://www.sgi.com/tech/stl/EqualityComparable.html
20:41:16 <Pseudonym> That's the guarantee that == gives you.
20:41:25 <Pseudonym> That if a and b are the same type, then == is transitive.
20:41:28 <SyntaxNinja> phobes: you mean that the type system won't let you compare them, or it will let you?
20:41:59 <phobes> well, hmm, actually I think it will
20:42:18 <phobes> If you take away the pointers, then you have an example
20:42:20 <Pseudonym> I know that comparing data pointers and code pointers are a nasal demon.
20:42:41 <Pseudonym> Because it should work on Harvard architectures.
20:42:51 <phobes> You may be able to get an example where the type system passes it, but it still isn't transitive
20:43:03 <Pseudonym> Well, you can overload == to be whatever you like.
20:43:08 <phobes> Sure
20:43:10 <phobes> but with built in ==
20:43:16 <Pseudonym> But if it breaks the Equality Comparable concept, you're stupid.
20:43:31 <phobes> I'd suspect in certain cases with multiple inheritance, I think you'd break it
20:43:37 <shachaf> @bot Do we have a lambdabot here?
20:43:46 <Pseudonym> :)
20:43:56 <Pseudonym> Lambdabot isn't here, so we're all picking up the slack.
20:44:12 <shachaf> > 2 ^ 64
20:44:19 <morg> i like muffins.
20:45:05 <morg> fine dont talk 2 me
20:54:32 <phobes> Pseudonym:  Ya, I can't think of an example where a == b, b==c, a!=c, where all three pass the type checker
20:54:43 <phobes> My previous example has an error on a==c
20:59:32 <thetallguy> anyone know what the haskell syntax is for copying a record structure but replacing some values?
20:59:41 <thetallguy> I keep typing the O'Caml syntax
20:59:50 <Lemmih> thetallguy: record{field=newValue}
21:00:24 <thetallguy> Thanks you.
21:00:38 <thetallguy> Heh.
21:00:56 <thetallguy> Thank you, Lemmih.  I kept putting a `with' in there.
21:04:38 <phobes> Is record subtyping going to happen anytime soon?
21:04:56 <Lemmih> phobes: No.
21:06:57 <sjw> phobes: you can fake it with type classes, if you really want it
21:07:47 * EvilTerran mentions <http://homepages.cwi.nl/~ralf/HList> again, for the hell of it
21:18:22 <SyntaxNinja> can anyone think of a better way to write this:
21:18:24 <SyntaxNinja> numEqString' :: Integer -> String -> Bool
21:18:24 <SyntaxNinja> numEqString' n s =
21:18:24 <SyntaxNinja>   case reads s of
21:18:24 <SyntaxNinja>     [] -> False -- parsing failed
21:18:25 <SyntaxNinja>     ((n2, _):_) -> n2 == n -- parsing worked, so safe to compare
21:18:33 <SyntaxNinja> andyjgill: so... who came up with "Galwegian"?
21:19:23 <glguy> successful parsing looks like [(x,y)] | all isSpace y
21:22:05 <SyntaxNinja> Oh I see, because otherwise:
21:22:06 <SyntaxNinja> > numEqString' (-1) "-1 asfd"
21:22:07 <SyntaxNinja> True
21:22:38 <glguy> and the parse shouldn't be ambiguous
21:22:59 <andyjgill> SyntaxNinja: that  would be me.
21:23:48 <SyntaxNinja> andyjgill: very cute :)
21:24:48 <EvilTerran> there'd be a fairly nice definition involving list :: (a -> [a] -> b) -> b -> [a] -> b
21:27:22 <EvilTerran> numEqString' n = list (\(n',rest) [] -> n == n' && all isSpace rest) False . readDec, i guess
21:27:42 <EvilTerran> not *that* much better in this case, really... never mind. :P
21:27:45 <phobes> numEqString n s = s == (show n)  :P
21:28:35 <thetallguy> numEqString'' n s =
21:28:35 <thetallguy>     fmap ((== n) . fst) (reads s) == [True]
21:29:48 <thetallguy> not very pretty.
21:30:38 <SyntaxNinja> thetallguy: that doesn't take into account this case: "1 asdfsafd" right?
21:30:45 <thetallguy> no
21:30:51 <thetallguy> I was just reading that bit.
21:31:01 <thetallguy> I just rephrased your solution
21:31:14 <thetallguy> but I think mine obscures the logic anyway
21:31:26 <thetallguy> were you looking to avoid the use of reads?
21:31:32 <TSC> Doesn't the == [True] handle it?
21:31:44 <TSC> Because it is equal only to a singleton list
21:31:52 <TSC> Oh, never mind
21:31:59 <TSC> It's an unambiguous, but wrong, parse
21:33:10 <phobes> numEqString n s = reads (show n) == reads s
21:33:22 <thetallguy> Oh, I see, you want it to fail on extra characters?
21:33:25 <phobes> a little more robust than my last one :)
21:33:39 <thetallguy> I was assuming that was a feature, although a dubious one.
21:35:19 <thetallguy> numEqString'' n s =  fmap (== (n,"")) (reads s) == [True]
21:36:45 <sarah> how would i fix this? Could not find module `Distribution.GetOpt':it is hidden (in package Cabal-1.1.6.2)
21:37:37 <SyntaxNinja> sarah: where are you getting that error?
21:38:03 <SyntaxNinja> glguy: shouldn't it be "null y"?
21:38:17 <glguy> > read "10     " :: Int
21:38:25 <glguy> ?bot
21:39:00 <SyntaxNinja> yeah, I don't want that to work.
21:39:10 <SyntaxNinja> > numEqString 1 "1   "
21:39:10 <SyntaxNinja> True
21:39:13 <glguy> ok, then match for: [(x,"")]
21:39:15 <glguy> :)
21:40:10 <SyntaxNinja> then I need another case
21:40:17 <glguy> ?
21:40:32 <Lemmih> Isn't it kinda embarrassing to have such an unreliable bot?
21:40:35 <SyntaxNinja> OK:
21:40:37 <SyntaxNinja> numEqString :: Integer -> String -> Bool
21:40:37 <SyntaxNinja> numEqString n s =
21:40:37 <SyntaxNinja>   case reads s of
21:40:37 <SyntaxNinja>     [(n2, "")] -> n2 == n -- parsing worked, so safe to compare
21:40:37 <SyntaxNinja>     _ -> False -- parse failed
21:40:40 <thetallguy> That's what my revised version does, matches for (n,"")
21:41:02 <glguy> SyntaxNinja: are you writing this up as a blog post or something?
21:41:02 <thetallguy> Yes, I think that's right
21:41:20 <SyntaxNinja> glguy: yeah, how could you tell?
21:41:29 <glguy> SyntaxNinja: I'd write a readMaybe that encapsulates the pattern matching
21:41:41 <glguy> and then reuse that for all of your individual implementations
21:42:10 <SyntaxNinja> yeah. there should probably be something like that in Text.Read
21:45:19 <thetallguy> SyntaxNinja: seems like your return type is wrong.  Should be Maybe Bool
21:45:51 <glguy> he's implementing PHP's == as a multiparameter typeclass I imagine
21:45:55 <glguy> so he'd want that type
21:46:39 <thetallguy> numEqString :: Integer -> String -> Maybe Bool
21:46:39 <thetallguy> numEqString n s =
21:46:39 <thetallguy>     case reads s of
21:46:39 <thetallguy>       [(n2, "")] -> Just (n2 == n) -- parsing worked, so safe to compare
21:46:39 <thetallguy>       _ -> Nothing -- parse failed
21:47:06 <thetallguy> Ugh.
21:47:10 <SyntaxNinja> :)
21:47:25 <thetallguy> I'll quit then. ;-)
21:47:46 <SyntaxNinja> glguy: that's a good idea, but that's not what I'm doing.
21:47:49 <SyntaxNinja> you should do that, though ;)
21:48:03 <glguy> I don't blog :-p
21:48:30 <SyntaxNinja> glguy: but you implement MPTCs ;)
21:48:48 <thetallguy> Here's a more fun puzzle: write digits :: Integral a => a -> [a] using unfoldr
21:50:09 <glguy> (\ x -> if x == 0 then Nothing else Just (let (a,b) = divMod x 10 in (b,a)))
21:50:12 <glguy> and a reverse
21:50:27 <glguy> or is it important not to reverse?
21:51:25 <SyntaxNinja> glguy: so my thesis is that Haskell should support convenient comparison between strings and nums.  it's so important that PHP has scrweed up their equality opeprator to make it convenient.
21:51:36 <SyntaxNinja> but in Haskell, it's not only not-built-in, but it's hard.
21:51:46 <SyntaxNinja> you have to be familiar with the parsing libraries to write it correctly.
21:52:36 <thetallguy> I don't see how it could be otherwise
21:52:39 <EvilTerran> you have to be explicit about which functionality you actually want
21:53:05 <EvilTerran> while php tries to do it implicitly, hence that horrible f4ing mess it's made of equality
21:53:08 <TSC> Maybe it would be enough to have a string-to-integer conversion with type "Num a => String -> Maybe a"
21:53:19 <TSC> (make that string-to-Num)
21:54:28 <SyntaxNinja> TSC: yeah, I think that, or a standard function like I've written above would be good.
21:54:46 <TSC> Actually
21:54:51 <SyntaxNinja> I like it better than "1" == 1
21:55:14 <TSC> All you need is a version of "read" that returns a Maybe
21:55:25 <thetallguy> It does seem unreasonable to have read throw an error
21:55:51 <Pseudonym> Yes.  Errors are errors, not exceptions.
21:56:40 <TSC> http://haskell.org/ghc/docs/latest/html/libraries/cgi/src/Network-CGI-Protocol.html#maybeRead
21:57:13 <thetallguy> There you go, that's what I was searching for
21:57:17 <SyntaxNinja> TSC, yeah, I've seen functions like that here & there.
21:57:23 <SyntaxNinja> there's on in Hackage.Utils as well.
21:57:36 <TSC> That seems more useful than "read"
21:57:39 <thetallguy> I started out with fmap thinking I would apply it to a Maybe, but I couldn't find one.
21:58:38 <SyntaxNinja> sarah: where were you getting that error about getOpt?
21:59:08 <sarah> yeah
21:59:27 <SyntaxNinja> sarah: what were you trying to build?
21:59:39 <thetallguy> numEqString :: Integer -> String -> Maybe Bool
21:59:39 <thetallguy> numEqString n s = fmap (== n) (maybeRead s)
22:00:26 <sarah> oh sorry misread you, from http://download.savannah.gnu.org/releases/xadrez-haskell/
22:04:14 <SyntaxNinja> sarah: since that software was written, the way Haskell handles packages has changed a lot.  the author should probably not use GetOpt from Cabal, but rather from System.Console.GetOpt.
22:04:40 <SyntaxNinja> sarah: the source code probably needs to be modified, or compiled with an older GHC.
22:04:43 <sarah> ah thanks
22:04:57 <sarah> also what does putting ' by something do?
22:05:20 <TSC> sarah: as in foldl vs foldl' ?
22:05:34 <sarah> yeah
22:05:51 <TSC> It doesn't have any meaning in the language; ' is just another character in the function's name
22:06:01 <TSC> ... but the convention is that the ' version is stricter
22:06:22 <sarah> ah thanks!
22:06:24 <TSC> In the foldl case, foldl' is strict in the accumulator
22:08:15 <zx]treads> TSC: can you give an example? i don't understand what it means to be strict in the acc
22:08:43 <SyntaxNinja> OK, here's my blog entry: http://www.syntaxpolice.org/index.php/?q=node/419
22:08:54 <SyntaxNinja> comments welcome, and maybe I can make any necessary corrections before it hits planet haskell :)
22:09:16 * humasect curious
22:09:34 <sarah> can you overload stuff like + in haskell?
22:10:41 <shachaf> sarah: You can make your own Num instance, or redefine the operator.
22:13:12 <nornagon> let a + b = 1 in 3 + 4
22:13:17 <nornagon> > let a + b = 1 in 3 + 4
22:13:27 <nornagon> @botslap
22:13:40 <glguy> sarah: + is overloaded in Haskell
22:13:40 <nornagon> oh, she's not even here
22:15:20 <TSC> zx]treads: Have a look at: http://www.haskell.org/haskellwiki/Stack_overflow
22:16:05 <sarah> im confused about types in general too :( how do you make a subtype?
22:16:51 <Pseudonym> Gah.
22:17:00 <Pseudonym> OK, cabal issue.
22:17:05 <zx]treads> TSC: thx.
22:17:13 <thetallguy> SyntaxNinja: only one comment, s/transative/transitive/
22:17:19 <Pseudonym> I have some locally installed packages (i.e. in my home directory).
22:17:25 <Pseudonym> ghc-pkg reports them as registered.
22:17:28 <thetallguy> Otherwise very nice.
22:17:30 <Lemmih> sarah: You don't.
22:17:32 <Pseudonym> But Setup.hs isn't picking them up.
22:17:46 <TSC> Pseudonym: In the configure step?
22:17:47 <shachaf> Pseudonym: Are they installed --user, maybe?
22:17:53 <Pseudonym> In the configure step.
22:17:58 <Pseudonym> shachaf: Almost certainly.
22:18:02 <Pseudonym> Is that a problem?
22:18:18 <shachaf> Pseudonym: Well, it is if Setup.hs is doing things globally.
22:18:40 <Pseudonym> So what's the cure?
22:18:53 <TSC> Pseudonym: Do you have configure --user ?
22:18:58 <shachaf> Pseudonym: Install everything globally or run Setup.hs locally (are you already?).
22:19:15 <Pseudonym> Ah.  I thought I was doing it locally.
22:19:16 <Pseudonym> Guess not.
22:19:19 <Pseudonym> Works now, thanks. :-)
22:20:02 <Cale> sarah: Haskell doesn't have subtypes as such, but if you want polymorphism, there is something called typeclasses.
22:20:33 <Cale> sarah: Do you understand the basic parametric polymorphism provided by type variables already?
22:20:38 <shachaf> Cale!
22:20:40 <SyntaxNinja> thetallguy: thanks!  the spell checker is kinda strange;  it underlines a word at first, but then later stops underlining it if you dont fix it right away.
22:20:44 <shachaf> Cale: Can we have mbot, please? :-)
22:20:49 <Cale> shachaf: sure
22:20:51 <sarah> Cale, not very well ill read up on it more
22:21:02 <Cale> sarah: Well, I can explain
22:21:37 <SyntaxNinja> OK I added some commentary about "maybeRead'
22:21:47 <Cale> sarah: Basically, type variables are (normally at least) allowed to range over any type whatsoever.
22:22:19 <thetallguy> SyntaxNinja: stepcut has a real-life story about the loose == in perl
22:22:53 <thetallguy> Oh, no, it was loose +
22:22:59 <SyntaxNinja> oh yeah?  I should ping him about that.
22:23:01 <thetallguy> He got "22" instead of 4
22:23:02 <Cale> sarah: For instance, the function 'length' for getting the length of a list might have the type:  [t] -> Integer,  because for any type t, it takes a list of values of type t, and produces an Integer
22:23:18 <sarah> ah yeah got that :)
22:23:43 <Cale> As a more complicated example, there's the function  map  which has type  (a -> b) -> [a] -> [b]
22:23:45 <SyntaxNinja> thetallguy: heh. yeah, Haskell is way better here.
22:24:10 <Cale> That is, it takes a function from some type a, to some type b, together with a list of values of type a, and produces a list of values of type
22:24:11 <Cale> b
22:24:35 <sarah> yeah i think i understood it just didnt know what polymorphism and such were
22:24:38 <Cale> These are again unrestricted, it doesn't matter at all which types a and b are.
22:24:48 <Cale> Okay, so let's look at sort
22:25:05 <Cale> That is, a function which takes a list of elements and sorts them.
22:25:22 <Cale> Initially, we might think of a type something along the lines of [t] -> [t]
22:25:39 <Cale> But sort is going to need to compare the elements of the list with (<)
22:26:06 <Cale> So t had better be some type for which an ordering is defined, not just any type at all.
22:26:37 <Cale> So we have a typeclass called Ord. A simplified definition of Ord looks like:
22:26:41 <Cale> class Ord t where
22:26:46 <Cale>    (<) :: t -> t -> Bool
22:27:21 <Cale> (It really is a little more complicated than that, but not much)
22:27:25 <sarah> so what would you put in your type to tell Ord how (<) compares it?>
22:27:31 <Cale> and then we can write the type of sort:
22:27:37 <Cale> sort :: (Ord t) => [t] -> [t]
22:28:16 <Cale> That is, for any type t which has an instance of the typeclass Ord (and hence a definition of (<)), sort will take a list of values of type t, and produce a list of values of type t
22:28:22 <sarah> Cale, so type classes just restrict what types you can pass to a function right?
22:29:00 <sarah> i think i get that  :) how do you make a instance of class Ord?
22:29:09 <Cale> Yeah, restrict the types that type variables range over, and in so doing, guarantee that certain functionality is present.
22:29:17 <Cale> instance Ord MyType where
22:29:22 <Cale>    x < y = ...
22:29:39 <Cale> Of course, you can do all the usual pattern matching.
22:30:02 <Cale> There's also a class called Eq
22:30:14 <Cale> It defines the equality testing operation (==)
22:30:23 <Cale> In reality, it's a superclass of Ord
22:30:28 <Cale> (I simplified that part out)
22:30:33 <Cale> @src Eq
22:30:43 <Cale> meh
22:31:09 <Cale> class  Eq a  where
22:31:09 <Cale>     (==), (/=) :: a -> a -> Bool
22:31:09 <Cale>         -- Minimal complete definition:
22:31:09 <Cale>         --      (==) or (/=)
22:31:09 <Cale>     x /= y     =  not (x == y)
22:31:10 <Cale>     x == y     =  not (x /= y)
22:31:45 <Cale> Note that the class definition provides some default implementations if an instance should fail to define one of (==) or (/=).
22:32:03 <Cale> class  (Eq a) => Ord a  where
22:32:03 <Cale>     compare              :: a -> a -> Ordering
22:32:03 <Cale>     (<), (<=), (>=), (>) :: a -> a -> Bool
22:32:03 <Cale>     max, min             :: a -> a -> a
22:32:26 <Cale>     -- there's also some default method stuff here, but I didn't paste it
22:33:19 <Cale> the (Eq a) => Ord a in the class head there says that in order to be an instance of Ord, a type must also be an instance of Eq
22:34:44 <Cale> This doesn't relieve you of the duty to specify what that instance is -- there's no inheritance. It's just a constraint, and allows you to simplify typeclass constraints in function types
22:35:43 <Cale> For example, if my sort function for some reason also needed to use (==) somewhere (I don't know why), then I would normally have to change the type to something like (Eq a, Ord a) => [a] -> [a], but Eq is a superclass of Ord, so that's not necessary.
22:35:50 <sarah> so to have a type of pairs that can be compared with < i would do instance Ord MyType::(a,b) where{etc}
22:36:22 <Cale> You'd probably need Ord instances for each of the components in order to define the Ord instance for the pair
22:36:31 <Cale> So in order to write that, you'd write:
22:36:41 <Cale> instance (Ord a, Ord b) => Ord (a,b) where
22:36:57 <Cale>    (a,b) < (c,d) = ...
22:37:08 <ricky_clarkson> Doesn't having (Eq a) => Ord a mean that you can have <= and >= without extra boilerplate?
22:37:13 <Cale> right
22:37:33 <sarah> ah i see thanks
22:38:14 <sarah> so what would the instance (Ord a..... be called?
22:38:57 <sarah> compariblePairs::instance (Ord a, Ord b) => Ord (a,b) where....?
22:41:48 <Lemmih> sarah: Tutorials are good at answering such questions.
22:43:14 <Cale> sarah: Instances don't have names.
22:43:27 <Cale> sarah: A type is either an instance of a class, or it isn't.
22:43:57 <dblhelix> happy new year, #haskell
22:44:06 <Cale> (this is sometimes a deficiency, but very often is exactly what you want)
22:44:07 <sarah> Lemmih, sorry i was going to but cale offered to help :\
22:44:16 <Cale> sarah: It's cool :)
22:44:32 <Cale> sarah: (I was just up from the computer for a second getting the cat something to eat.)
22:44:44 <ricky_clarkson> Are instances scoped?
22:45:25 <Cale> ricky_clarkson: Nope. In fact, they have the occasionally annoying property that they're always exported from and imported by modules.
22:45:31 <sarah> Cale, what does 'deriving' mean then? i thought it meant its an  instance of the class, and if so how does it have a name?
22:45:35 <ricky_clarkson> Thanks.
22:45:38 <Cale> (of course, this is usually what you want as well)
22:45:47 <sarah> thx cale
22:46:22 <Cale> sarah: the deriving thing is a mechanism for a few of the Prelude-defined classes in Haskell, which lets the Haskell compiler write some code automatically based on the structure of your type
22:46:33 <Cale> Unfortunately, it's not an extensible system.
22:46:49 <Cale> (You can't add your own mechanisms for deriving instances of classes)
22:46:58 <sarah> ah :\
22:47:16 <Cale> But for the basic Prelude classes, it's still very handy.
22:47:46 <Cale> Instances of Eq and Ord tend to be among the most boring to have to write.
22:48:13 <Cale> It also works for Read and Show, as well as Enum and Bounded
22:48:44 <Cale> http://haskell.org/onlinereport/derived.html  -- this specifies exactly how the derived instances are constructed
22:48:46 <ricky_clarkson> Clever.
22:51:37 <sarah> after i learn about monads ill start programming :) what editer has function list/syntax highlight/autocomplete?
22:52:13 <Cale> sarah: well, quite a few have syntax highlighting, including vim and emacs.
22:52:26 <Cale> (What OS?)
22:52:30 <sarah> ubuntu
22:53:03 <Cale> Basically, any editor which has syntax highlighting, and an option to automatically convert tabs into spaces should be fine.
22:53:03 <sarah> ill try out vim i guess :)
22:53:14 <Cale> You should :set expandtab
22:53:22 <Cale> (I think that's the important one)
22:53:41 <fnord123> also :retab to replace all tabs
22:53:41 <sarah> ah! whats wrong with tabs>
22:54:04 <Cale> They count as aligning to the nearest 8-space boundary to the Haskell compiler.
22:54:22 <Cale> Leaving them in your source files is a great way to confuse and annoy people. :)
22:54:39 <fnord123> They are illegal characters in fortran, so you should set your editor to never use tabs if you ever use fortran...
22:54:56 <sarah> k! so 4 spaces instead? (or 8?)
22:55:04 <Cale> They almost should be illegal in Haskell, due to the annoying problems they have.
22:55:49 <Cale> It doesn't matter how much you indent by, so long as you can keep it consistent throughout a block -- Haskell uses indentation to automatically insert curly braces around things.
22:56:13 <Cale> (and semicolons)
22:57:08 <Cale> The golden rule of indentation is that things which are at the same level syntactically should be indented the exact same amount, and things which are inside other things should be indented more.
22:58:00 <Cale> The first non-whitespace character after the keywords "let", "where", "of" or "do" will set the indentation level for the block.
22:58:18 <Cale> Every subsequent line of the block should be lined up with it.
22:58:51 <lament> a stupid rule, but it does make programs look pretty in textbooks.
22:59:18 <Cale> It's not stupid :)
22:59:48 <fnord123> it was confusing when i started. trying to debug indentation errors was annoying
22:59:54 <Cale> Making programs look pretty is worthwhile, because syntactic noise makes things harder to read.
23:00:35 <Cale> Even though it's not required, another good tip is to indent if-then-else like you would these other blocks:
23:00:37 <Cale> if foo
23:00:40 <Cale>   then bar
23:00:45 <Cale>   else baz
23:00:55 <Pseudonym> Now stop complaining.
23:00:55 <TSC> @botsnack
23:00:55 <pseudobot> :)
23:01:07 <Cale> The 'then' and 'else' are lined up, and indented further than the 'if'
23:01:41 <Pseudonym> Must go now.
23:01:46 <Pseudonym> Don't kill my server please!
23:01:47 <davidL> @version
23:01:47 <pseudobot> lambdabot 4p584, GHC 6.6 (Linux i686 (Mendocino))
23:01:47 <pseudobot> darcs get http://code.haskell.org/lambdabot
23:01:55 <Pseudonym> Oh, and not all commands are going to work.
23:01:58 <Pseudonym> @djinn a -> a
23:01:58 <pseudobot> Plugin `djinn' failed with: Prelude.init: empty list
23:02:12 <Pseudonym> Nytol!
23:02:58 <ikegami--> $B$D$$$?$i<r$G$"$C$?$^$C$F$/$@$5$$(B
23:03:06 <ikegami--> $B$D$$$?$i<r$G$"$C$?$^$C$F$/$@$5$$(B
23:03:24 <ikegami--> oops
23:03:25 <phobes> Has there been any thought on splitting the IO Monad interface into a bunch of type classes?
23:03:27 <ikegami--> sorry
23:03:55 <Cale> phobes: some
23:04:35 <Cale> Not a whole lot, because it's not clear what the best way to do it would be, and most changes would result in quite a bit of irritation.
23:05:07 <phobes> Cale:  Meaning legacy issues?  Or wow-that's-alot-of-typing issues?
23:05:42 <phobes> (with the "quite a bit of irritation")
23:05:46 <Cale> Both.
23:05:53 <phobes> k
23:06:05 <Tac-Tics> It seems like if you want to write an api with restrited IO abilities, it's better to have the api designer instead of the language desginer limit the IO
23:06:50 <phobes> Eh?
23:06:51 <EvilTerran> that would be how it'd go, tho
23:07:34 <phobes> You're saying build private typeclasses for whatever's needed?
23:07:51 <Tac-Tics> yeah
23:07:51 <EvilTerran> foo :: (MonadIOStdIO m, MonadIOHandles m, MonadIORefs m) => m (), say
23:08:08 <Cale> Yeah, or smaller monads which capture subsets of the functionality explicitly.
23:08:22 <EvilTerran> MonadIO_putStrLn :P
23:08:40 <phobes> MonadConsole
23:08:40 <Tac-Tics> You cut the fat out of the IO monad and leave only the healthy parts
23:08:53 <Cale> For instance, that might be an excellent thing to do with OpenGL operations.
23:09:10 <dblhelix> EvilTerran: you see, api design isn't exact science perhaps ;-) I guess we have to find some sweet spots there
23:09:15 <Tac-Tics> or GUI state changes
23:09:43 <EvilTerran> a heirarchy could be built of shorthands
23:09:55 <EvilTerran> starting with the really fine-grained "magic" IO functions
23:10:07 <EvilTerran> putStr, hOpen, newIORef, etc
23:10:34 <dblhelix> class IOMagic sounds cool, that's for sure
23:10:44 <EvilTerran> altho the heirarchy would require undecidable instances
23:11:25 <phobes> why?
23:12:01 <EvilTerran> class (IO_newIORef m, IO_readIORef m, IO_writeIORef m) => IO_Refs m, say
23:12:28 <EvilTerran> would cause an undecidability constraint, as the m on the left is no smaller than the m on the right
23:12:37 <EvilTerran> as it were
23:12:43 <EvilTerran> er, s/constraint/complaint/
23:13:06 * Tac-Tics is still confused by undecidable instances
23:13:13 <phobes> hmm, I thought as long as your inclusion hierarchy was a DAG, it should be ok
23:13:41 <EvilTerran> phobes, i think it'll still work if it's a DAG, but you'll have to allow undecidable instances for it to even try
23:14:56 <EvilTerran> Tac-Tics, consider instance Foo [a] => Foo a; when it's trying to work out if some instance Foo t exists, the typechecker has to work out whether an instance Foo [t] exists, and so an instance Foo [[t]] likewise, Foo [[[t]]], etcetc
23:15:27 <phobes> But that's not happening here?
23:15:42 <EvilTerran> unless one of those instances is explicitly declared (in which case you have overlapping instances, too), the typechecker will run out of stack
23:16:49 <EvilTerran> it's not a problem if you yourself can prove that the typechecker must halt. the coverage condition is a very conservative approach to enforcing decidable types.
23:17:24 <phobes> I think as long as you include every intersection of functionality as its own class, it should halt
23:17:38 <phobes> (and provide inclusion properly to all unions)
23:17:40 <Tac-Tics> so whenever you have class <Supertype> => <type> you have issues?
23:17:48 <EvilTerran> in the case of a heirarchy of classes, it's clearly okay, as the typechecking will only go along the branches in one direction
23:18:06 <Tac-Tics> and undecidable instances are solved with those dependency things everyone hates?
23:18:17 <EvilTerran> er... no, that's something else
23:18:21 <Tac-Tics> ack
23:18:24 <phobes> that's overlapped instances I think
23:18:27 <Tac-Tics> ah
23:18:39 <phobes> solved by rules finding the most specific
23:18:44 <Tac-Tics> that's when there could be more than one definition for a type to be included in a class or something, right?
23:18:45 <phobes> or are you talking about functional dependencies?
23:18:48 <Tac-Tics> yes, those
23:19:01 <EvilTerran> fundeps interact rather badly with overlapping instances, iirc
23:19:04 <phobes> Functional dependencies help avoid trouble in some situations ya
23:19:15 <EvilTerran> fundeps are merely providing more information to the typechecker
23:19:36 <EvilTerran> extra inference rules it can apply between the parameters of the typeclass
23:19:49 <phobes> ya, fun deps let the compiler solve previously underdetermined systems
23:20:15 <EvilTerran> i don't believe they're used for overlapping instance resolution, and i doubt they can influence the decidability of a system
23:21:17 <EvilTerran> but they make it possible for a type parameter of a class that would otherwise be to general to fit to any known instance to be narrowed down until it does fit one
23:21:41 <EvilTerran> er. something unpleasant happened to the grammar there. you get the gist, anyway, i'm sure
23:22:48 <loupgaroublond> bah, fundeps don't actually make bad code decisions work ;)
23:23:23 <EvilTerran> sadly not
23:24:15 <phobes> type-classes are somewhat screwy in the way they are presented
23:24:51 <phobes> The idea that they are just relations on types and that the implementing instances are just "evidence" of that relation...
23:24:57 <phobes> seems like a bad story to me
23:27:15 <Tac-Tics> instances are more of an "assertion" and than "evidence"
23:27:37 <Tac-Tics> I declare that Maybe x is a monad! instance Maybe x!
23:28:04 <phobes> except that "Maybe x is a monad!" isn't what an instance really says
23:28:12 <phobes> it says "here's one mapping that makes Maybe a Monad"
23:29:34 <phobes> (ie the particular mapping is what's important - not merely the presence of some mapping)
23:29:36 <loupgaroublond> it basically lets you overide functions that take N parameters, but can be classified by a type signature
23:30:11 <phobes> I know what it does... I'm just saying the "theory" usually given to explain how it works is poor
23:34:49 <Tac-Tics> Barnes and Noble has just about the worst shopping cart system I've ever used X-(
23:35:06 <Tac-Tics> but I'm finally going to get a book on category theory
23:35:27 <Tac-Tics> so I can at least pretend to keep up with all the functor talk that goes on around here
23:37:35 <loupgaroublond> real men know everything they need to know about math from wikipedia ;)
23:37:49 <phobes> Category Theory is an important tool for translating simple concrete concepts into difficult abstract ones :)
23:38:40 <Tac-Tics> phobes: that much so far is clear
23:38:50 <Philippa> phobes: the theory makes plenty of sense from a Curry-Howard point of view - it's just that we're writing programs rather than proofs so we don't have proof irrelevance
23:39:02 <Tac-Tics> set, group, and function are all common English words
23:39:05 <Philippa> that is, we care what the proof/evidence actually is as well
23:39:30 <Tac-Tics> The only word you'll find in a dictionary pertaining to category theory is the word "category" itself
23:39:52 <phobes> Philippa:  So the theory makes sense, just not for what we're using it for :D
23:40:07 <Philippa> it still makes sense for what we're using it for
23:40:40 <Philippa> it doesn't say "just" evidence, you're adding the "just"
23:41:07 <Philippa> all the values we define are evidence that their types are inhabited
23:41:53 <Tac-Tics> Wikipedia's math articles are kinda all over the place
23:42:01 <Tac-Tics> there's very little consistency with them
23:42:48 <phobes> Philippa:  That typeclasses are relations on types is wrong
23:42:55 <Cale> They're mostly not bad. I'm rather upset with the choice of notation for logarithms ;)
23:43:27 <Philippa> phobes: care to back that assertion up some?
23:43:41 <Cale> phobes: huh?
23:44:08 <Cale> They absolutely are relations on types, together with functionality which is provided when those relations hold.
23:44:36 <Philippa> because as a rule, when you're challenging two decades' worth of theory you're either good enough to provide a solid, detailed argument or you're almost certainly wrong
23:45:24 <phobes> hehe ya..  when I say "wrong" I don't mean "not true" - I mean I think it's the wrong point of view
23:45:45 <Cale> It works really well for the multiparameter case.
23:45:53 <Philippa> how well do you understand constructive logic, phobes?
23:46:09 <phobes> moderately
23:46:29 <phobes> I understand your point about CH
23:47:06 <Philippa> okay. So you understand that if you interpret the type of, for example, show under CH it'll require you to present evidence that the parameter you're passing it is in fact Showable?
23:47:32 <Philippa> and that "under the hood" the type class system works out which instance to present as that evidence?
23:47:52 <phobes> yes, that's what I don't think is useful
23:48:24 <phobes> the fact that "which instance" is a quirky implementation detail
23:48:27 <Philippa> despite the fact it explains things like the way you can use creative instancing to generate new code based on a type?
23:48:40 <phobes> with the rest of the language, we don't leave it up to the compiler to go "find a proof"
23:48:50 <Philippa> that's like calling "which type" a quirky implementation detail any time it's not annotated
23:49:00 <Philippa> no, we let it work out what we're proving instead
23:49:08 <phobes> No, going from proof -> type isn't the same as going from type -> proof
23:49:18 <Philippa> don't forget that the mechanisms by which the compiler's allowed to find a proof are also specified in the language
23:49:24 <phobes> right
23:49:46 <Philippa> we do, incidentally, allow the compiler to find proofs in practice
23:49:54 <Philippa> see, GHC uses an explicitly typed language as an intermediary
23:50:06 <Philippa> that means that every time you do something polymorphic it's got to work out where to put type lambdas
23:50:21 <Philippa> every time you instantiate something polymorphic, it's got to supply a type application
23:50:39 <Philippa> so yes, in practice GHC does build proofs from our partial proofs all the time
23:50:58 <Philippa> just like we supply partial proofs for type classes in the form of instances that may contain type variables
23:51:26 <Philippa> if we didn't do that then the compiler'd just be doing simple lookups in a type dictionary
23:51:52 <phobes> eh?
23:52:56 <Philippa> GHC's intermediate language is a variant on System F.
23:53:11 <phobes> I'm not sure what the intermediate langauge has to do with anything...
23:53:21 <Philippa> you said the compiler doesn't build proofs. It does.
23:53:37 <Philippa> we supply an awful lot of the raw material, sure
23:53:46 <phobes> I was speaking under CH to mean "the compiler doesn't write my programs for me"
23:54:16 <Philippa> yes. But evidence generation for typeclasses doesn't show up until you look at the intermediate language either
23:54:48 <Philippa> you can't actually do the dictionary passing transformation on Haskell 98 and end up with Haskell 98 code, it ends up with rank-2 polymorphism in it
23:57:18 <phobes> Anyway, I'm sure the theory is sound and correct, but I still think it's a somewhat screwy way to look at things
23:57:40 <phobes> and I think there is a simpler way to look at things that more precisely captures what typeclasses seek to capture
23:57:43 <Philippa> I note that you're not offering much of an alternative, and that the theory corresponds directly to what the compilers actually do
23:57:46 <phobes> strike precisely
23:58:11 <Philippa> *shrug* - there's probably a better theory and combination of constructs, yes
23:58:12 <phobes> I guess I just think you can do it more cleanly
23:58:24 <darinm> phobes: how?
23:58:24 <Philippa> but now it's not the theory you're criticising, it's type classes themselves
23:58:44 <Philippa> darinm: one option would be to start with a module system and treat type classes as inferring which modules to use as evidence
23:59:05 <phobes> exactly, something like that should be better
23:59:10 <phobes> and stop calling them evidence :)
23:59:18 <Philippa> no. It's all evidence
23:59:20 <phobes> they are just values
23:59:21 <darinm> Philippa: sure, but I was hoping to get an answer from phobes :)
23:59:25 <Philippa> all values are evidence
23:59:48 <darinm> module systems are nice, but not always clearly superior to type classes
23:59:49 <Philippa> and in this context, I'm using them specifically /as/ evidence
