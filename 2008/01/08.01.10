00:38:17 <quicksilver> -Wfun
00:38:34 <sarah__> Can you have a datatype that has one container that could hold a limited ammount of different types?  ex data Container = Int | String | Mytype
00:38:40 <quicksilver> Warning: You are having too much fun. Go and write some PHP for a bit.
00:38:48 <quicksilver> sarah__: yes
00:39:06 <quicksilver> almost what you wrote, but you have to have a label for each alternative
00:39:33 <quicksilver> data Container = AnInt Int | AString String | AMyType Mytype
00:39:41 <sarah__> thanks :)
00:46:44 <sarah__> i get somehing like "not a constructor AnInt
00:49:33 <chr1s> sarah__: what does your datatype look like?
00:51:32 <sarah__> data Square = piece Piece | Empty deriving Eq
00:51:45 <dmwit> sarah__: Keep in mind that prefix constructors have to start with an upper case letter.
00:52:01 <sarah__> ohhh :) thanks
00:55:42 <C-Keen> Good morning! I'd like to hear your advice on a style/design issue: I want to build a depacketizer that reads from an input source and gets byte chunks out of a stream then handing it to another function that assembles these chunks and hands it to the appropriate handler. How do I do this in functional terms? I can do the first step all right but the assembly needs it's state (the so far accumulated chunks). How can I do this?
00:56:59 <Botje> C-Keen: you could always use the state monad
00:57:20 <Botje> or IO, if you're reading from network anyway
01:03:09 <C-Keen> Botje: I will read up on this
01:03:33 <C-Keen> Botje: I don't understand how I could use IO for this atm
01:03:49 <Botje> C-Keen: look up IORef
01:04:03 <Botje> it's a mutable variable, like any other language has :P
01:04:12 <Botje> *p00f*
01:04:15 <Botje> << train time
01:05:48 <gio123> R1<R2 iff L(R1) \in L(R2)
01:06:03 <gio123> somebody knows decision procedure to decide R1<R2
01:06:04 <gio123> ?
01:07:48 <dmwit> What is L?
01:08:00 <gio123> language
01:08:13 <gio123> R1,R2 reg expressions
01:10:08 <dmwit> Well, do you know the equality decision procedure?
01:10:16 <dmwit> This seems pretty similar.
01:12:26 <Sizur> i cannot use GADTs in LANGUAGE pragma?
01:31:52 <xpika> what's the printf to a string?
01:32:29 <Korollary> you mean the format character?
01:32:34 <Korollary> %s
01:32:43 <xpika> sprintf
01:32:49 <Korollary> ah
01:33:43 <dmwit> printf does that
01:34:01 <dmwit> > printf "%d" 3
01:34:04 <lambdabot>  Add a type signature
01:34:10 <dmwit> > printf "%d" 3 :: String
01:34:12 <lambdabot>  "3"
01:34:30 <koeien> can printf also be IO () then?
01:34:51 <dmwit> yes
01:35:18 <koeien> > printf "%d" 37 :: IO ()
01:35:18 <lambdabot>  <IO ()>
01:35:21 <koeien> cool
01:36:42 <quicksilver> C-Keen: your problem does not sound appropriate for IORefs, I'm not sure what Botje was talking about.
01:37:01 <quicksilver> C-Keen: read your chunks in as ByteStrings (that part is an IO operation) and then assemble/parse them (which is a pure operation)
01:37:35 <quicksilver> Sizur: GADTs should work in 6.8.x, it doesn't in 6.6.x, IIRC
01:37:47 <quicksilver> koeien: cool, or, too much overloading
01:37:48 <quicksilver> you choose :)
01:37:55 * quicksilver is suspicious of overuse of overloading.
01:38:14 <Sizur> quicksilver:  it works, i have 6.8.2, but i cannot put GADTs in LANGUAGE pragma
01:38:18 <koeien> i wouldn't mind if there was a function "format"
01:38:26 <Sizur> i had to put -XGADTs in OPTIONS
01:40:06 <C-Keen> quicksilver: well I already use ByteStrings. My current problem is that I have a chunkreader that searches for sync bytes and hands those chunks to a function which should assemble one packet out of several chunks, I don't know how to store the chunks for an incomplete packtet. Maybe I am thinking too much in the imperative programming way
01:41:44 <dmwit> koeien: But just think, this way, you can write your own instance of PrintfType and get a var-arg function for FREE! X-|
01:41:53 <Sizur> you cannot
01:42:08 <Sizur> the implementation is hidden within module
01:43:12 <quicksilver> C-Keen: "store"
01:43:13 <quicksilver> C-Keen: ?
01:43:18 <Sizur> there are two names that have to be exported to make an instance of PrintfType
01:43:22 <quicksilver> C-Keen: you mean, just while it's waiting for more packets to come in?
01:43:28 <C-Keen> quicksilver: I cann add them in the assemble function but when I get to the point where I need more data I just can't 'wait'. I could return a ByteString and an indicator if the packet is incomplete but that seems pretty awkward
01:44:36 <quicksilver> C-Keen: the assemble function sometimes discovers it needs more data? or the assemble function is only ever called on complete data?
01:44:44 <koeien> C-Keen: Either ByteString ByteString... if it's incomplete return a Left otherwise a Right?
01:45:55 <C-Keen> quicksilver: well the assemble function gets called with chunks and calls another function if the packet is complete, I thought I would build these like filters that pass the right data to the next function
01:46:20 <C-Keen> koeien: Left/Right?
01:46:38 <quicksilver> soundsl ike the assemble function should return either a result (if it had enough packets) or return the unused chunks
01:46:41 <dmwit> C-Keen: Can all these filters be pure?
01:46:45 <quicksilver> possibly AND instead of OR
01:46:55 <quicksilver> the standard pattern of a parse looks like this:
01:46:58 <koeien> C-Keen: Either a b is a datatype that is either a Left a or a Right b
01:47:04 <quicksilver> [Chunk] -> (Result,[Chunk])
01:47:11 <dmwit> C-Keen: If so, you may be able to let laziness take care of your "storage".
01:47:20 <quicksilver> I.e. a parser takes some chunks, returns a result and a list of chunks it hasn't used yet.
01:48:28 <C-Keen> dmwit: that's what I hope for
01:49:30 <dmwit> (I mean, you could look at "concat" as a simple chunk-assembler.)
01:49:32 <C-Keen> quicksilver: ah ok, I will use something like this, then it would be like ByteString -> (ByteString, ByteString) with the fst being emtpy if not complete?
01:49:52 <koeien> C-Keen: more like ByteString -> (Result, ByteString)
01:50:03 <koeien> unless your result is by coincidence also a ByteString
01:50:10 <C-Keen> it is
01:50:14 <koeien> ok, nm then
01:50:41 <koeien> you'll need more if you want parses to be able to fail or return more results
01:51:01 <C-Keen> hm...
01:51:39 <quicksilver> possibly Maybe Result
01:51:42 <quicksilver> (if it's always 0 or 1)
01:51:46 <quicksilver> or [Result]
01:51:48 <quicksilver> if it's many
01:51:50 <koeien> e.g. ByteString -> [(Result, ByteString)]   or ByteString -> Maybe (Result,ByteString)
01:52:11 <quicksilver> koeien: ByteString -> ([Result],ByteString) surely?
01:52:29 <koeien> quicksilver: different parses can have different "rest" values?
01:52:33 * dmwit agrees with koeien
01:52:58 <quicksilver> well they ca
01:53:06 <quicksilver> but I don't think we're talking about non-deterministic parsing here
01:53:18 <quicksilver> we're talking about parsing multiple 'things' in a row
01:53:24 <C-Keen> well either I can comlete one package or not
01:53:26 <quicksilver> or that was my interpretation of C-Keen's problem
01:53:35 <quicksilver> you return multiple packages that all parsed
01:53:38 <koeien> quicksilver: sure yes if your version is enough then it's better
01:53:40 <quicksilver> not multiple (alternative) packages
01:53:40 <C-Keen> quicksilver's right in my case
01:53:58 <koeien> but then it sounds like lazy eval will work
01:54:31 <koeien> right?
01:54:49 <dmwit> C-Keen: I guess it would help a lot if we had a simple example input and its desired output.
01:54:50 <C-Keen> I will try
01:55:13 <quicksilver> if koeien is suggest unsafe lazy IO I shall cry.
01:55:27 <C-Keen> dmwit: I am disecting an mpeg2 transportstream into it's ES packets
01:56:43 <C-Keen> first layer are 188 Bytes with a sync byte at the beginning, then depending on some bits indicating start of a certain packet type you assemble the larger chunk. Forgive me for not pasting something like that :)
01:57:02 <dmwit> yipe! =P
01:57:08 <koeien> C-Keen: sure :)
02:05:07 <sarah__> is it better in general to use : or ++ when concatinating lists
02:05:33 <sarah__> oh nm : adds one unit to it
02:05:53 <koeien> yes it's totally different
02:06:43 <quicksilver> you have a choice when adding only one elt
02:06:49 <quicksilver> x : l or [x] ++ l
02:07:00 <quicksilver> the former is slightly more efficient but it's not likely to be noticeable
02:07:08 <koeien> [x]++l is ugly
02:07:10 <koeien> imo
02:07:11 <glguy> and then the rewrite rules will rewrite [x] ++l as x : l
02:07:11 <glguy>  :)
02:07:18 <quicksilver> koeien: no, it isn't
02:07:23 <quicksilver> it's actually quite attractive
02:07:24 <glguy> koeien: it can be nice for: [x] ++ xs ++ ys
02:07:28 <koeien> ok stylish issue then
02:07:29 <quicksilver> if you want to emphasis the symmetry
02:07:32 <quicksilver> with l ++ [x]
02:07:41 <quicksilver> like [a] ++ l ++ [b]
02:07:42 <quicksilver> or something
02:07:46 <koeien> in a vacuum it's ugly imo
02:08:39 <koeien> in general, i mean, but it's not important
02:12:21 <koeien> but sarah__ said "in general", so "in general" imo (:) is better than (++)
02:15:29 <glguy> she asked for adding appending lists
02:15:37 <glguy> and then noticed that they did different things
02:16:02 <sarah__> yeah sorry im new to haskell so mix up basic stuff alot
02:16:15 <quicksilver> nothign to apologise for
02:16:26 <quicksilver> glguy and I are just bored enough to waste time being pedantic :)
02:16:33 <quicksilver> don't take it personally, it certainly isn't meant so.
02:16:36 * koeien is bored as well
02:16:37 <glguy> I was telling koeien
02:16:52 <glguy> not criticizing your misspeak
02:17:15 <koeien> i consider myself pretty new to haskell as well
02:17:53 <dmwit> Well, I don't know about y'all, but I prefer (>>= id) for all my list appendages.
02:18:27 <glguy> concatenations rather?
02:18:52 <dmwit> Nah, that doesn't make nearly as good a joke. ;-)
02:19:18 <Botje> does GHC have a rewrite rule for [x] ++ l ?
02:19:30 <Botje> or can it unroll that loop manually?
02:19:53 <glguy> The rewrite rule for that is at least defined in stream-fusions's Data.List.Stream
02:20:40 <glguy> (not without, however)
02:20:57 <C-Keen> @paste
02:20:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:21:53 <Cale> > signum (1 :+ 1)
02:21:55 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
02:22:10 <Cale> huh, that's interesting, it's wrong :)
02:22:20 <glguy> > signum (1 :+ 1) * (1 :+ 1)
02:22:21 <lambdabot>  0.0 :+ 1.414213562373095
02:22:30 <glguy> > signum (1 :+ 1) * (0 :+ 1)
02:22:30 <lambdabot>  (-0.7071067811865475) :+ 0.7071067811865475
02:22:44 <sarah__> @src :=
02:22:44 <lambdabot> Source not found. My mind is going. I can feel it.
02:22:49 <glguy> > signum (1 :+ 1) * (sqrt 2 /2 :+ sqrt 2 / 2)
02:22:49 <lambdabot>  0.0 :+ 1.0
02:22:49 <sarah__> @src :+
02:22:49 <lambdabot> Source not found. You type like i drive.
02:22:58 <hpaste>  c-keen pasted "sync reader, maybe inappropriate model" at http://hpaste.org/4898
02:23:11 <C-Keen> this is how I do it atm
02:23:11 <TSC> Cale: what should it be?
02:23:24 <glguy> > sqrt 2 / 2
02:23:25 <lambdabot>  0.7071067811865476
02:23:25 <C-Keen> so when using lazy eval I am not sure how this will ever halt
02:23:26 <Cale> Usually you want x * signum x to be equal to the absolute value of x
02:23:28 <sarah__> @src (:+)
02:23:28 <lambdabot> Source not found. My brain just exploded
02:23:34 <Cale> So it should be the complex conjugate of that.
02:23:55 <sarah__> hmm whats :+
02:24:01 <glguy> complex number
02:24:04 <glguy> constructor
02:24:09 <Cale> a :+ b is a + bi
02:24:09 <koeien> type constructor for complex number
02:24:16 <TSC> Ah, right
02:24:17 <glguy> data constructor, rather
02:24:20 <koeien> ehm yeah
02:24:27 <glguy> :t (:+)
02:24:28 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
02:25:10 <Cale> > conjugate (signum (1 :+ 1)) * (1 :+ 1)
02:25:11 <lambdabot>  1.414213562373095 :+ 0.0
02:25:28 <Cale> > abs (1 :+ 1)
02:25:28 <lambdabot>  1.4142135623730951 :+ 0.0
02:26:06 <quicksilver> Botje, glguy : won't SpecConstr catch [x] ++ l ?
02:26:17 <Botje> IANAGHCH
02:26:22 <quicksilver> ;)
02:26:24 <koeien> :)
02:26:35 <Botje> but I *WANT* to be a pugs hacker
02:26:39 <Botje> except .. it's horrible atm :)
02:27:24 <glguy> Oh, yes, GHC does optimize [x] ++ away
02:27:30 <glguy> on its own
02:27:37 <glguy> (from looking at dump-simpl)
02:27:41 <Botje> cool :)
02:27:44 <koeien> nice
02:27:46 <Cale> Well, I can see how both behaviours are probably desirable :)
02:27:50 <Botje> is it because of rewrite rules or inlining?
02:28:07 <Cale> signum z = z / abs z  is also a pretty nice thing to have
02:28:07 <glguy> maybe
02:29:06 <quicksilver> glguy: specconstr, presumably.
02:29:16 <quicksilver> or is this just plain inlining?
02:29:19 <quicksilver> inline/case reduce
02:29:21 <quicksilver> I'm not sure
02:29:33 <glguy> I'm definitely in need of sleep
02:29:37 <glguy> nytol
02:29:42 <Botje> nn
02:30:00 <quicksilver> @src (++)
02:30:00 <lambdabot> (++) []     ys = ys
02:30:00 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
02:30:11 <quicksilver> on the other hand, that doesn't look inlineable
02:30:16 <quicksilver> hmpf
02:30:59 <pejo> quicksilver, why wouldn't that be inlineable?
02:31:05 <quicksilver> pejo: can't inline recursive functions
02:31:17 <quicksilver> but, fortunately that's not the actual definition used
02:31:18 <quicksilver> there is a rule
02:31:28 <quicksilver> "++"[~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
02:31:33 <pejo> quicksilver, why can't you, assuming you stop sometime?
02:31:45 <EvilTerran> "sometime"
02:32:23 <quicksilver> you can in principle
02:32:25 <quicksilver> GHC doesn't
02:32:27 <quicksilver> that's all I meant :P
02:32:51 <EvilTerran> @where supero
02:32:51 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/supero/
02:32:54 <EvilTerran> that does
02:33:09 <quicksilver> and some GHC functions are rewritten to make them inlinable
02:33:11 <pejo> quicksilver, oh. I'll take your word for that. It's a bit less categorical than "you can't inline recursive functions".
02:33:19 <pejo> EvilTerran, yeah, I'm familiar with supero.
02:33:20 <quicksilver> yes.
02:33:23 <quicksilver> I meant "GHC can't"
02:33:29 <quicksilver> @src foldr
02:33:30 <lambdabot> foldr k z xs = go xs
02:33:30 <lambdabot>     where go []     = z
02:33:30 <lambdabot>           go (y:ys) = y `k` go ys
02:33:34 <quicksilver> ^^ hack to make it inline
02:33:38 <Philippa> you can't in general get away with inlining them. The "in general" being an important statement
02:33:38 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
02:33:56 <EvilTerran> and working out when you can is quite hard
02:34:31 <Philippa> well yeah, it's the canonical not-entirely-solveable problem
02:34:33 <pejo> EvilTerran, which is why we approximate it.
02:34:36 <pejo> Heh.
02:35:02 <pejo> Philippa, I read your mind on that one!
02:35:08 <quicksilver> inductive data types ftw!
02:36:09 <Philippa> yeah. Which reminds me - if Coq'Art doesn't make me do it then I've earmarked proving weak normalisation for the simply-typed lambda calculus as a learning exercise (I may well end up finding it's easier to prove strong at the same time)
02:38:02 <pejo> Philippa, got the book?
02:43:36 <sarah__> @tell quicksilver quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
02:43:37 <lambdabot> Consider it noted.
02:44:56 <sarah__> @list
02:44:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:45:02 <EvilTerran> ...
02:45:16 <sarah__> bored lol
02:46:14 <sarah__> @fact
02:46:14 <lambdabot> I can not handle empty facts.
02:46:36 <Philippa> pejo: yep, got it
02:47:00 <Philippa> only finished the first three chapters so far though, so the only thing I've really learnt about at the moment is the existance of tactics
02:47:09 <dmwit> ?quote is the canonical pasttime of the terminally bored
02:47:10 <lambdabot> No quotes for this person.
02:47:37 <sarah__> ?quote lambdabot
02:47:37 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
02:49:37 <Botje> ?quote
02:49:38 <lambdabot> TimToady says: learning Haskell itself is easy--I've done it several times already
02:51:27 <quicksilver> ?quote dmwit
02:51:27 <lambdabot> dmwit says: Nobody quickcheck'd that @babel de en . @babel en de === id.
02:52:40 <pejo> Philippa, does it seem comprehendible for mere mortals?
02:53:12 <sarah__> which book
02:53:19 <pejo> sarah, Coq'Art.
02:54:02 <Philippa> pejo: yeah
02:54:11 <Sizur> > fail "a" :: Maybe String
02:54:14 <lambdabot>  Nothing
02:54:45 <Philippa> I mean okay, I have to be slightly careful judging that because by a lot of people's standards I'm not a "mere mortal" these days. But I'm fairly confident my dad would get a significant percentage of the material so far and he's still getting to grips with haskell
02:55:19 <Philippa> it might take him a couple of passes and a fair amount of thinking time where I'm just going "yeah yeah, curry-howard, seen it before" and "oh look, stateful interaction with a proof tree" though
02:56:49 <Sizur> why does fail take a String?
02:57:15 <dmwit> To tell the user what went wrong.
02:57:17 <Philippa> because it's just a lifted version of error
02:57:20 <Sizur> it seems weird that an abstraction like Monad is dealing with Strings
02:57:35 <dmwit> yes
02:57:38 <Philippa> yeah, there're strong arguments that fail is a mistake
02:57:51 <Philippa> unfortunately, really fixing it requires making the do translation type-aware
02:58:03 <quicksilver> well even if you fix the fail wart
02:58:03 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
02:58:09 <quicksilver> you still have to ask the question:
02:58:14 <quicksilver> "Should mzero take a string?"
02:58:22 <quicksilver> because, there is no doubt that error messages are useful.
02:58:33 <Philippa> no, it shouldn't. There should be another class for mzero-with-string
02:58:36 <dmwit> Oh, wait, what part of do notation translates to fail?
02:58:42 <quicksilver> dmwit: pattern match failure
02:58:43 <Philippa> dmwit: pattern match failure
02:58:50 <Japsu> @quote stereo
02:58:51 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
02:58:53 <Philippa> @bloodystereoquote
02:58:53 <lambdabot> Unknown command, try @list
02:58:55 <quicksilver> Philippa: well, that's a good answer to the question.
02:59:00 <quicksilver> @quote stereo!
02:59:00 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
02:59:13 <Japsu> hmm
02:59:16 <Japsu> @quote majestic
02:59:16 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
02:59:20 <Japsu> ^_________________^
02:59:25 <Japsu> easier to remember
02:59:33 <EvilTerran> @qoute fugue
02:59:33 <lambdabot> Maybe you meant: quote vote
02:59:37 <EvilTerran> @quote fugue
02:59:38 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
02:59:50 <dmwit> Not bad.
03:00:03 <dmwit> Who is this monochron figure, though? =P
03:00:16 <dmwit> He only exists in one time?
03:00:30 <quicksilver> Philippa: but would you suggest anything should be an instance of MonadZero but not MonadZeroWithString ?
03:00:45 <dmwit> sure
03:00:58 <dmwit> Maybe and [] spring to mind.
03:01:09 <quicksilver> ah, but I don't think you do
03:01:10 <pejo> Philippa, yeah, your longtime exposure to weird fp stuff might affect your mortality. But it seems like the book would be worth a read.
03:01:20 <quicksilver> I think you want Maybe to be an instance, which throws away the string
03:01:41 <quicksilver> because sometimes you have an errorful calculation and you want to run it as a Maybe.
03:01:44 <quicksilver> because you dont care.
03:01:48 <dmwit> quicksilver: Oh, I see what you mean.  But that's no problem, is it?
03:01:55 <koeien> > Just "first" `mplus` Just "second"
03:01:56 <lambdabot>  Just "first"
03:02:06 <koeien> ["first"] `mplus` ["second"]
03:02:13 <koeien> > ["first"] `mplus` ["second"]
03:02:14 <lambdabot>  ["first","second"]
03:02:17 <quicksilver> well if every instance of the one class is also an instance of the other, and vice versa, you do wonder why you have both :P
03:02:21 <EvilTerran> > fail "unnecessary details" `mplus` Just 1
03:02:22 <lambdabot>  Just 1
03:02:44 <koeien> fail = const Nothing for Maybe i presume?
03:02:52 <EvilTerran> @src Maybe fail
03:02:53 <lambdabot> fail _      = Nothing
03:03:00 <Philippa> quicksilver: that's what Either is for :-)
03:03:12 <EvilTerran> @src Either fail
03:03:13 <lambdabot> fail msg      = Left (strMsg msg)
03:03:21 <Philippa> and I think the right answer if I didn't care would be to use a newtyped Maybe rather than Maybe itself
03:03:30 <koeien> @src strMsg
03:03:31 <lambdabot> Source not found. Take a stress pill and think things over.
03:03:36 <doserj> forgetErrorMsg:: (MonadZeroWithString m, MonadZero n) => m a -> n a
03:03:56 <Philippa> more generally, I don't necessarily want the error to be a string
03:04:04 <Sizur> that's my point
03:04:30 <quicksilver> that's certaily true
03:04:33 <Sizur> why not ErrorMessage class
03:04:36 <quicksilver> but that requires MPTCs
03:04:51 <quicksilver> and the most natural implementation requires fundeps
03:04:57 <pejo> quicksilver, we want those anyways!
03:05:04 <quicksilver> I don't want fundeps :P
03:05:10 <pejo> I was commenting on MPTCs, not fundeps.
03:05:13 <Philippa> you want ATs instead?
03:05:24 <quicksilver> any how, there is certainly a case for working out how far you can get without those things and still be sueful.
03:05:27 <pejo> quicksilver, you managed to sneak in the second line there right as I presssed enter.
03:05:30 <quicksilver> which I'm sure is further than we are now.
03:05:38 <quicksilver> Philippa: I think so. But I haven't actually used them so I'm not sure.
03:05:46 <quicksilver> Philippa: I may disagree when I get the chance to actually try ;)
03:06:44 <idnar> ATs?
03:06:54 <Philippa> Associated Types
03:06:57 <idnar> ah
03:10:10 <EvilTerran> quicksilver, as of 6.8.1 they were buggy up the wazoo, but that'll hopefully improve fairly quickly (might even be better in 6.8.2... actually, i might go install that now for th heck of it)
03:11:16 <quicksilver> they weren't even finished in 6.8.1
03:11:17 <quicksilver> AIUI
03:11:26 <quicksilver> at least, ATSes weren't finished
03:11:36 <quicksilver> and it's ATSes you need to do fundep-style stuff AIUI
03:14:29 <pejo> Odd, we always want the next version of the compiler. :-)
03:15:02 <EvilTerran> you can do fundep-style stuff without ATSs, you just won't get (as friendly) error messages if the type family isn't associated
03:15:05 <EvilTerran> iirc
03:15:50 <EvilTerran> "There is the beginnings of support for “associated types” in GHC. However, this is incomplete and not a supported feature." - 6.8.1 changelog
03:16:02 <EvilTerran> they're not mentioned anywhere in the 6.8.2 changelog, AFAICT
03:18:12 <EvilTerran> views (-> in patterns) are only in the HEAD at the moment, aren't they?
03:18:48 <pejo> EvilTerran, doesn't really seem sane from a software engineering perspective to put in "major" features in .2-releases imho.
03:19:38 <EvilTerran> well, seeing as the basic functionality was dropped in in .1, it could've been tightened up a bit in .2 without it constituting a "major addition", i'd've thunk
03:21:44 <quicksilver> pejo: as long as they don't mess with unrelated code it's OK IMO
03:21:59 <quicksilver> pejo: GHC development tends to eschew branching
03:22:08 <quicksilver> this may be due to darcs problems ;)
03:22:22 <Sizur> what happends when i fail within runTransformer?
03:22:29 <quicksilver> but as long as an experimental feature can be fiddled with without hurting core functionality and I don't think it's too bad
03:22:59 <quicksilver> Sizur: depends how that monad defines fail...
03:23:13 <Sizur> Identity
03:23:37 <Sizur> in particular i have one run function of type Integer
03:23:41 <Sizur> how can it fail?
03:24:01 <Sizur> and it does fail with exception in ghci
03:24:46 <quicksilver> well the transformer can over-ride fail if it wants
03:24:54 <Sizur> i mean i have a particular application of runTransformer of tyle Integer
03:24:58 <quicksilver> or the transformer can delegate fail to the inner monad
03:25:05 <quicksilver> it's up to the transformer which it wants to do
03:25:47 <Sizur> hmm, maybe a function monad
03:26:03 <quicksilver> many transformers just pass fail through
03:26:09 <quicksilver> e.g., from the source for StateT:
03:26:13 <Philippa> and the identity monad's fail is error
03:26:14 <quicksilver>     fail str = StateT $ \_ -> fail str
03:26:40 <Sizur> that's nice.
03:27:05 <quicksilver> but on the other hand, ErrorT doesn't, of course
03:27:12 <quicksilver> that being part of the point of ErrorT
03:27:17 <quicksilver>     fail msg = ErrorT $ return (Left (strMsg msg))
03:48:07 <b_jonas> @src liftM
03:48:07 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:49:52 <b_jonas> is liftM basically a special case of fmap ?
03:50:33 <yitz> Sizur: the purpose of fail in a monad is to determine what to do when a pattern match fails in a do expression (or a list comprehension for the list monad). So if a transformer needs a certain behavior for that, it defines fail itself. Otherwise, it just politely delegates to the underlying monad. For a non-transformer monad with no particular behavior defined for pattern match failure, you just leave default of calling error, and hope that it never
03:51:07 <yitz> b_jonas: another name for the same thing
03:52:28 <b_jonas> @src (,) fmap
03:52:28 <lambdabot> fmap f (x,y) = (x, f y)
03:55:44 <resiak> hmm, why not (f x, f y)?
03:56:04 <b_jonas> wrong type, I guess
03:56:12 <b_jonas> @src Functor
03:56:12 <lambdabot> class  Functor f  where
03:56:12 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:56:18 <resiak> ah
03:56:29 <yitz> @src liftM
03:56:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:10:35 <sarah__> how is do { x1 <- m1; return (f x1) } different than do { return (f m1) }?
04:11:45 <koeien> sarah__: see the types :)
04:12:14 <koeien> m1 is a calculation of type IO Int, for example, and f is a function from Int to Int, for example
04:12:31 <koeien> then your first example works, but your second does not (because m1 is a computation and not an Int)
04:12:34 <koeien> do you see why?
04:13:42 <koeien> :t do { x1 <- getLine; return ((++"Hello") x1 }
04:13:44 <lambdabot> parse error on input `}'
04:13:55 <koeien> :t do { x1 <- getLine; return ((++"Hello") x1) }
04:13:56 <lambdabot> IO [Char]
04:14:12 <koeien> :t do { return ((++"Hello") getLine) }
04:14:12 <lambdabot>     Couldn't match expected type `[Char]'
04:14:12 <lambdabot>            against inferred type `IO String'
04:14:12 <lambdabot>     In the first argument of `(++ "Hello")', namely `getLine'
04:14:29 <sarah__> ah i see thx
04:15:30 <koeien> it is arguably nicer to write it as m1 >>= return.f  though
04:15:33 <Sizur> @index Monad
04:15:33 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:16:28 <Sizur> default fail is error?
04:16:39 <Svrog> or better yet liftM f m1
04:18:15 <Sizur> @hoogle catch
04:18:16 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
04:18:16 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
04:18:16 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
04:18:28 <Botje> :t <*>
04:18:30 <lambdabot> parse error on input `<*>'
04:18:35 <Botje> :t (<*>)
04:18:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:18:38 <Botje> pesky operatorses.
04:18:57 <Botje> hmm
04:18:59 <quicksilver> Sizur: yes, default fail is error
04:19:00 <yitz> @src fail
04:19:00 <lambdabot> fail s      = error s
04:19:19 <Botje> so liftM f x = f <*> return x ?
04:19:31 <Botje> :t \f x -> f <*> return x
04:19:31 <lambdabot> forall (f :: * -> *) a b. (Monad f, Applicative f) => f (a -> b) -> a -> f b
04:19:34 <Botje> yay!
04:19:37 <quicksilver> f <*> pure x?
04:19:43 <quicksilver> no
04:19:45 * quicksilver thinks
04:19:49 <quicksilver> pure f <*> x
04:19:51 <quicksilver> of course
04:19:51 <Botje> :t pure
04:19:52 <lambdabot>     Ambiguous occurrence `pure'
04:19:52 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
04:19:52 <lambdabot>                           or `pure', imported from Control.Arrow
04:19:56 <quicksilver> otherwise known as
04:20:00 <quicksilver> f <$> x
04:20:06 <Botje> :t Control.Applicative.pure
04:20:06 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:20:15 <Botje> ah
04:20:17 <quicksilver> @src liftA
04:20:18 <lambdabot> liftA f a = pure f <*> a
04:20:18 <Botje> that's nice :)
04:20:23 <quicksilver> there you go :)
04:20:27 <Botje> thanks!
04:20:40 * Botje sets off to write a <€>
04:22:58 <resiak> Botje: ¥!
04:23:05 <Botje> :)
04:23:16 <Botje> "Y combinator? no no, the Yen combinator"
04:23:41 <resiak> the question is, what would be the Zen combinator?
04:25:19 <quicksilver> succ (Yen) combinator
04:27:40 <b_jonas> Yen is a lousy sign to mean zip, I prefer /\/\/
04:28:07 <Botje> "snake" ?
04:28:30 <osfameron> I thought Yen was quite cute for zip
04:28:46 <osfameron> but I hate unicode operators, due to not being able to a) produce them, or b) read them with any kind of consistency
04:29:03 <osfameron> until the whole world fixes its unicode toolchain properly, there is no point in using it.
04:29:23 <ricky_clarkson> Will I need a piano-sized keyboard for Haskell then?
04:30:15 <osfameron> no, you just either need to a) memorize 100 Alt-numberpad combinations for Windows, or b) work out where the "Compose" key is on *any* keyboard
04:31:18 <audreyt> (Yen is no longer used for zip anyway...)
04:31:22 <Sizur> a graphic keyboard should morrr-orrr-lesss solve it
04:31:34 <resiak> audreyt: aww :(
04:31:39 <audreyt> it's now Z
04:31:39 <Botje> programming would be so much more fun with a drawing tablet
04:31:48 <Botje> you could have images as comments!
04:32:58 <Sizur> then the compiler will be reduced to just making sense of the noise ppl call handwriting
04:33:11 <pejo> osfameron, not that typing is what's limiting the speed of programming, but why would one want to press more keys to convey the same amount of information?
04:33:18 <b_jonas> audreyt: yes, I know
04:33:25 <b_jonas> it was renamed to Y first and then Z
04:33:38 <b_jonas> to me, that seems like THREE renamings,
04:33:58 <b_jonas> because when I've first heared about it, I didn't know it was the yen character, and guessed it was broken bar
04:34:56 <osfameron> pejo: I didn't say I wanted to.  But to generate a Unicode character, I have to configure term+screen+vim, *and* work out how to generate the character in either Windows or nix.  Which I don't want to do, just to convey the same amount of information.
04:34:56 <b_jonas> as yen is 0xA5 in 8859-1 but isn't part of 8859-2
04:35:18 <b_jonas> the guillamot characters (which I see as funny variants of t) are still there
04:35:31 <b_jonas> and no, guillamot isn't spelled like that
04:35:45 <audreyt> clearly the zip operator should be ꊐ
04:35:51 <b_jonas> guillemot actually
04:36:03 <roconnor> I'm supposed to give a talk for Functional Programming day tomorrow.
04:36:08 <roconnor> but I have sliders block
04:36:10 <roconnor> :(
04:36:12 <audreyt> (U+A290 YI SYLLABLE ZIP)
04:36:17 <b_jonas> I can't see that either,
04:36:40 <b_jonas> why not apl comma overstruck with bar then?
04:36:57 <osfameron> unicode also has too many characters that look like other characters.  It's just wrong for a programming language
04:37:42 <C-Keen> usually you don't type those though
04:38:03 <C-Keen> but code obfuscation gets a new flavor then
04:38:06 <b_jonas> osfameron: that's why we should use CP-437, which was DESIGNED for the look of characters, not for the semantics of characters like these 8859-stuff
04:38:28 <b_jonas> which is why it has a cap (intersection sign) but no cup (u is close enough)
04:39:11 <b_jonas> except of course that 0x00 and 0xff look like blanks
04:39:42 <quicksilver> ricky_clarkson: no, an optimus maximus, of course
04:39:54 <quicksilver> the only keyboard you'll ever need, but never be able to afford.
04:40:03 <osfameron> b_jonas: interesting.
04:40:21 <b_jonas> osfameron: I could be wrong in the concrete example of cap thouhg
04:40:26 <b_jonas> but that's the general idea
04:40:49 <b_jonas> CWI is interesting too
04:41:44 <b_jonas> it was a charset used for accented characters after the 646-variants which didn't have all of them, but before CP-852
04:42:22 <b_jonas> the design of CWI was that it had all accented characters, but they were placed to look as good as possible on a CP-437 display
04:42:43 <audreyt> roconnor: in case you have a slider's block, try the takahashi method :)
04:42:47 <audreyt> # http://presentationzen.blogs.com/presentationzen/2005/09/living_large_ta.html
04:42:47 <lambdabot> Title: Presentation Zen: Living large: "Takahashi Method" uses king-sized text as a vis ..., http://tinyurl.com/o6psh
04:42:56 <b_jonas> as on CGA video cards you couldn't change the font, and on later cards too some might not have the software to do it
04:43:25 <roconnor> audreyt: ah right, I read your slides on haskell way back when.
04:43:46 <b_jonas> this sort of repeated at the 8859-2 era where 8859-2 characters are close to 8859-1
04:43:57 <b_jonas> but not as much
04:44:01 <litb> i wonder why this isn't ##haskell
04:45:03 <b_jonas> litb: you mean on #haskell-blah?
04:45:15 <b_jonas> oh, you mean the whole channel?
04:45:44 <osfameron> what are the ## channels?
04:45:49 <litb> b_jonas: i mean, every other programming channel i know starts with ##
04:45:59 <litb> or is this an official chan?
04:46:12 <b_jonas> it's a freenode policy that if there's an official foo body, then #foo is the channel endorsed by them
04:46:20 <b_jonas> but it's not always held
04:46:21 <C-Keen> "every other"? I have never seen this
04:46:43 <b_jonas> not every other: there's ##c, ##c++, ##gcc, but #perl, #ruby-lang, etc
04:46:50 <litb> C-Keen: ##java, ##c++ #haskell is what i know of concerning programming.
04:46:57 <b_jonas> but as I think there's no central haskell body, only a ghc and a hugs
04:46:58 <litb> ah, ##c of course
04:46:59 <pejo> audreyt, isn't that method more suitable for languages like japanese, rather than english?
04:47:08 <b_jonas> I think this is not violating the policy
04:47:48 <C-Keen> b_jonas: so '#foo' is the 'official' channel while '##foo' is something else?
04:47:59 <b_jonas> C-Keen: yes, I think so
04:48:09 <b_jonas> #foo is the channel endorsed by foo developpers
04:48:22 <b_jonas> but as I've said, it's not always held
04:48:55 <C-Keen> so #java is for developers of java VMs, compilers, etc while ##java is for users?
04:49:10 <b_jonas> C-Keen: no, not necessarily
04:49:34 <C-Keen> b_jonas: this is a convention that's new to me. Is this something freenode specific?
04:49:40 <b_jonas> #java is the channel endorsed by Sun,
04:49:53 <Saizan> but #java doesn't exist
04:49:55 <b_jonas> for whatever purpose they think it's more useful
04:49:58 <b_jonas> Saizan: sure
04:50:14 <b_jonas> Saizan: do you know why this is called _free_node?
04:50:32 <earthy> it has to do with freedom ;)
04:50:46 <Saizan> they give free beer?:)
04:50:50 <b_jonas> http://freenode.net/faq.shtml#whatwhy says
04:50:51 <lambdabot> Title: 69a freenode: frequently-asked questions
04:51:10 <b_jonas> "for coordination and support of peer-directed projects, including those relating to free software and open source."
04:52:49 <b_jonas> http://freenode.net/policy.shtml contains the real policy
04:52:50 <lambdabot> Title: 688 freenode: Policies
04:52:57 <b_jonas> it's not exactly what I've said actually
04:53:26 <b_jonas> "Primary channel names, formatted with a single leading hash mark (#), are reserved for participating groups and organizations based on their legal or informal claim to the associated name or name prefix."
04:53:57 <C-Keen> I bet 80% of the users don't know this
04:54:01 <b_jonas> "Topical or reference channels names, formatted with two leading hash marks (##), are allocated on a first-come, first-serve basis to unofficial groups wishing to discuss a project, group or general topic area."
04:54:17 <b_jonas> C-Keen: actually the ordinary users don't count, only the channel operating crowd
04:54:53 <osfameron> so if #haskell has an informal claim on haskell, there's no problem :-)
04:54:55 <b_jonas> C-Keen: there's also a username policy on that page which says I shouldn't use this username
04:55:13 <b_jonas> "b_jonas" that is
04:55:24 <pejo> b_jonas, because of the underscore?
04:55:29 <b_jonas> pejo: yep
04:55:58 <roconnor> ``On the functional program (fp) day meet dutch-language interested in functionally program each other
04:56:14 <koeien> yes that's tomorrow
04:56:16 <koeien> i'll be there
04:56:49 <roconnor> this free translation is horrible
04:57:06 <roconnor> Apparently I was better off trying to read the dutch myself. :)
04:57:31 <b_jonas> roconnor: why, that's perfectly readable
04:57:39 <pejo> roconnor, heh, yeah, people often have horrible translations.
04:57:52 <roconnor> ``After result go there yet a number of men together what eat at an Italian close to the station.
04:57:56 <koeien> @src List (>>=)
04:57:56 <lambdabot> Source not found. My brain just exploded
04:58:05 <koeien> @src [] (>>=)
04:58:05 <lambdabot> m >>= k     = foldr ((++) . k) [] m
04:58:15 <osfameron> roconnor: if that's an automatic "translation", it's actually pretty good
04:58:19 <b_jonas> it seems unlikely that a dutch programming-themed convention doesn't have info in English available
04:58:37 <koeien> unlikely but true
04:58:53 <koeien> it is mostly in dutch
04:58:59 <roconnor> b_jonas: Indeed this is unusual in that respect.
04:58:59 <koeien> (the convention)
04:59:04 <b_jonas> though not as unlikely as if it was in the Netherlands
04:59:18 <roconnor> b_jonas: it is in Utrect
04:59:19 <b_jonas> or norway
04:59:23 <roconnor> (in the Netherlands)
04:59:39 <koeien> 13:58 < lambdabot> m >>= k     = foldr ((++) . k) [] m
04:59:41 <roconnor> koeien: how much do you know about dependent types?
04:59:53 <koeien> almost nothing
05:00:06 <b_jonas> oh sry
05:00:20 <roconnor> koeien: then presumably you also know very little about Curry-Howard(-deBruijn) isomorphism
05:00:48 <koeien> i know what it is, i read an informal explanation
05:00:51 <roconnor> koeien: I'm trying to get a feel for the audience.
05:00:55 <pejo> Is it an academic gathering, or just random hackers?
05:01:02 <koeien> roconnor: i'm a maths/compsci student
05:01:32 <koeien> roconnor: i think there won't be a lot of students, but could be wrong though :/
05:01:34 <roconnor> koeien: ah, my next question was going to be how much math do you know (in particular basical logic)
05:01:45 <roconnor> er
05:01:48 <roconnor> basic logic
05:02:23 <koeien> roconnor: there will be at least a group of 4 students from Eindhoven :) (including myself)
05:02:24 <roconnor> I'd like to blame Dutch for my faultering English skills, but I think I'm just sloppy when writing on IRC.
05:02:50 <pejo> roconnor, don't you have the problem that most people just speak english to you, so you never really get to practice your dutch?
05:03:25 <roconnor> pejo: if you call that a problem, yes.
05:03:33 <koeien> roconnor: what are you going to talk about?
05:03:55 <koeien> i've never been to the fp-day before, so i don't know anything about the audience
05:03:55 <roconnor> my proposed title is ``Mathematics is Functional Programming: Implementing Real Numbers
05:04:25 <roconnor> but now I'm thinking I need to talk more about Math is Functional Programming and less about implementing real numbers.
05:04:44 <koeien> roconnor: aw cool, that would be interesting
05:05:09 <IvdSangen> roconnor: that title awoke my interest in the meeting
05:05:29 <roconnor> IvdSangen: are you coming?
05:05:33 <IvdSangen> (I will also be there)
05:05:47 <roconnor> IvdSangen: how much do you know about dependent types?
05:05:49 <roconnor> :)
05:05:58 <IvdSangen> not much :)
05:05:59 <koeien> :)
05:06:05 <roconnor> ok
05:06:08 <IvdSangen> as in functional dependencies?
05:06:17 <roconnor> IvdSangen: not really ;)
05:06:40 <roconnor> IvdSangen: that's fine.  I just trying to get a feeling for the background of the people there.
05:06:54 <koeien> i'll look it up on wikipedia
05:07:15 <roconnor> koeien: well, I will try and put some details into my talk
05:07:31 <koeien> roconnor: ok thank you :)
05:10:49 <koeien> there may be experienced logicians in the audience, i have no idea
05:43:52 <ndm> i am doing some profiling, and the results make nearly no sense to me
05:44:12 <ndm> i am mainly trying to profile a library, from an executable
05:44:20 <ndm> the library was installed with -p and Cabal
05:44:44 <ndm> but no entires from that library show up in the profile, despite the fact i strongly suspect ~75% of execution time is in that library
05:45:47 <ndm> should i be able to profile within a cabal installed library?
05:46:02 <scook0> perhaps "profiling support" merely means that the library can be linked with a profiled program? (not that I know either way)
05:46:07 <Saizan> does cabal pass -auto-all when compiling with -p?
05:46:10 <ndm> perhaps
05:46:12 <ndm> no idea
05:46:28 <ndm> i am trying again, just -i linking in the code
05:46:41 <Svrog> how is f ~(~(x, y), z) = ((x, z), y) different from f ((x, y), z) = ((x, z), y) ? i cant seem to come up with anything where the first definition would work and the 2nd wouldnt
05:46:44 <scook0> you could add -auto-all to the .cabal file and rebuild
05:47:13 <ndm> try f _|_
05:47:16 <quicksilver> ndm: I believe that scook0 is correct.
05:47:17 <scook0> Svrog: the latter is more strict
05:47:28 <quicksilver> _p libraries are *not* compiled with -auto-all
05:47:35 <quicksilver> because that defeats almost all optimisations
05:47:38 <ndm> Svrog: in the first, you get ((_|_,_|_),_|_), in the second you get _|_
05:47:41 <quicksilver> and makes thins run really slow.
05:47:55 <ndm> quicksilver: but you have two versions, profiling and not - does it matter if profiling runs slow?
05:47:56 <Svrog> oh crap - i missed the the outer ~ - i kept thinking that the z would still be matched heh
05:48:08 <Svrog> thanks
05:48:43 <ndm> hmm, now i can find that Data.Homeomorphic.Internal.$f3 takes 80% of the time
05:48:46 <ndm> any idea where that is?
05:49:20 <ndm> i don't think anything in that module should be taking any real time
05:49:36 <quicksilver> ndm: could do. It could make a feasible problem non feasible.
05:49:45 <quicksilver> ndm: optimisations can often move things entire complexity classes...
05:49:56 <quicksilver> can't answer your more interesting problem though
05:49:58 <quicksilver> I've never heard of it
05:52:36 <pejo> quicksilver, what kind of optimizations does ghc have that change complexity classes?
05:53:49 <ndm> pejo: CSE, let-lifting
05:54:02 <ndm> the odds of well written code getting a chance in complexity class are low
05:54:27 * pjd woos about supercompilation
05:54:28 <pejo> ndm, thought GHC avoided almost all CSE due to fear of space leaks?
05:54:35 <ndm> if it does, you should rewrite the code, since you've done something silly, rather than the compiler doing something clever
05:54:47 <ndm> pejo: almost always, yes, but in a couple of cases it can
05:57:05 <ndm> i think (lightly) that $f3 corresponds to an instance which is automatically generated
05:57:16 <ndm> and i have a slight guess at what it is
05:57:23 <pejo> pjd, you mean supercompilation changes complexity classes of code?
05:57:40 <pjd> pejo: yes
05:58:37 <quicksilver> I think fusion can change complexity class
05:58:43 <quicksilver> certainly space complexity
05:58:45 <pjd> pejo: potentially dramatically so;  one of the benchmarks is compiling the naive string matching algorithm to the optimal one
05:59:00 <ndm> quicksilver: it can't, i'm pretty sure
05:59:23 <pejo> pjd, the typical example is a naive string matcher to a linear one. Whats' the complexity of the naive, n^2?
05:59:36 <quicksilver> ndm: it can make stuff which would otherwise take linear space into constant space
05:59:46 <pjd> pejo: yeah
06:00:06 <ndm> quicksilver: building the list takes O(1), consuming the list takes O(n), the fusion saves one build/consume, but the resulting consume means you get O(n) instead of O(n+n), so no saving
06:00:43 <ndm> quicksilver: not so sure about that either, it may make a particular slice of the program change in complexity, but once you include the consume, you get back to where you started
06:01:04 <quicksilver> I'm talking about space, not time, at the moment
06:01:10 <quicksilver> not all consumes take O(n) space
06:01:26 <ndm> true
06:01:36 <ndm> yes, i guess you can eliminate that
06:01:57 <ndm> but that relies on a good consumer and a good producer, which are actually only O(1) storage
06:02:16 <ndm> i.e. you have a lazy stream which can recycle storage
06:03:02 <ndm> you can change the O of the recycled space, but not the O of the peak space
06:03:08 <ndm> (at a guess)
06:03:16 <pejo> pjd, and n^2 is a different complexity class from n?
06:04:50 <pjd> pejo: yes?
06:04:51 <Sizur> i just read http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
06:04:56 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
06:05:06 <Sizur> do we have any progress in this issue since then?
06:06:11 <ndm> Sizur: no
06:11:47 <pejo> pjd, I would naively have included both in P
06:13:08 <pjd> pejo: oh, *that* kind of complexity class?
06:13:18 <pjd> i wouldn't know :)
06:13:57 <cjb> pejo: we usually distinguish between linear and quadratic complexity.
06:14:10 <EvilTerran> @go complexity class
06:14:12 <lambdabot> http://en.wikipedia.org/wiki/Complexity_class
06:14:12 <lambdabot> Title: Complexity class - Wikipedia, the free encyclopedia
06:16:03 <cjb> or even between constant, logarithmic, linear, quadratic, exponential, and factorial.
06:16:18 <EvilTerran> don't forget n.log n
06:16:30 <cjb> bah :)
06:17:03 <EvilTerran> although some would consider any log to be a constant factor for the purposes of pragmatic complexity analyses ;)
06:18:43 <pejo> cjb, the amount of complexity classes seem to be a bit unwieldy then, but I guess it's fair.
06:19:39 <ndm> pejo: don't you think its weird you differentiate between P and NP (which may be the same), but don't between linear and quadratic (which are definately different)
06:20:04 <ndm> my arguments i was refering to the very fine grained complexity classes of same under big-O
06:21:28 <pejo> ndm, sure, the argument is basically where you draw the line. I thought the use of "complexity classes" was somewhat standard.
06:21:39 <EvilTerran> ndm, i guess lumping everything sub-P into P is fine if you consider everything in P "tractable", and everything outside it "intractable"
06:22:22 <pejo> ndm, and I obviously think that linear or even constant factors matter, otherwise I wouldn't be doing what I'm doing.
06:22:55 <ndm> pejo: under big-O, those go away, so I would consider them equal
06:23:10 <ndm> at copmlexity, obviously very important at real speed!
06:23:32 * EvilTerran pokes the current asymptotically-best matrix multiplication algorithm
06:33:01 <alexj_> is there an official standard name for (.) with arguments in reverse order or some variant involing using a ($) as well?
06:34:01 <Japsu> @src >>>
06:34:02 <lambdabot> Source not found. There are some things that I just don't know.
06:34:09 <Japsu> @src Control.Arrow.>>>
06:34:09 <lambdabot> Source not found. My mind is going. I can feel it.
06:34:13 <Japsu> bah
06:34:32 <Japsu> alexj_: anyway, for functions, f >>> g == g . f
06:35:20 <alexj_> i thought >>> was arrow composition?
06:35:28 <Japsu> alexj_: yes, and functions are arrows ;)
06:35:35 <alexj_> ah ok.
06:35:48 <Japsu> > (tail >>> head) [1,2,3]
06:35:51 <lambdabot>  2
06:35:59 <idnar_> @pl \f `x` g -> g . f
06:35:59 <lambdabot> (line 1, column 4):
06:35:59 <lambdabot> unexpected "`"
06:35:59 <lambdabot> expecting operator, pattern or "->"
06:36:05 <Japsu> > (head . tail) [1,2,3]
06:36:06 <lambdabot>  2
06:36:11 <idnar_> @pl f `x` g = g . f
06:36:11 <lambdabot> (line 1, column 9):
06:36:11 <lambdabot> unexpected "="
06:36:11 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
06:36:25 <idnar_> @pl \f g -> g . f
06:36:26 <lambdabot> flip (.)
06:36:28 <idnar_> bah
06:38:41 <EvilTerran> ?type (>>>)
06:38:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:39:17 <EvilTerran> ?type (>>>) :: (a -> b) -> (b -> c) -> a -> c
06:39:18 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
06:39:59 <idnar> ?type ?f >>> ?g
06:39:59 <lambdabot> forall (a :: * -> * -> *) b c d. (?f::a b c, ?g::a c d, Arrow a) => a b d
06:40:10 <idnar> hmm
06:41:10 <EvilTerran> ?type (<<<) `asTypeOf` (.)
06:41:10 <lambdabot> forall c d b. (c -> d) -> (b -> c) -> b -> d
06:41:31 <quicksilver> :t (>>>) `asTypeOf` (flip (.))
06:41:32 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
06:41:35 <quicksilver> ;)
06:41:47 <idnar> heh
06:42:06 <C-Keen> :t Data.Monad.State
06:42:07 <lambdabot> Couldn't find qualified module.
06:43:12 <Saizan> a good algorithm for distibuted mutual exclusion?
06:43:29 <Sizur> any ideas about how to implement authorization in haskell?
06:43:33 <idnar> @type (?f :: a -> b) >>> ?g
06:43:33 <lambdabot>     No instance for (?f::a -> b)
06:43:33 <lambdabot>       arising from use of implicit parameter `?f' at <interactive>:1:1-2
06:43:33 <lambdabot>     Possible fix:
06:43:43 <idnar> @type (?f :: (a -> b)) >>> ?g
06:43:44 <lambdabot>     No instance for (?f::a -> b)
06:43:44 <lambdabot>       arising from use of implicit parameter `?f' at <interactive>:1:1-2
06:43:44 <lambdabot>     Possible fix:
06:43:48 <Sizur> i was playing around with monadic versions of authorization, nothing seemed natural
06:43:51 <idnar> can I do something like that?
06:45:00 <hpaste>  sizur pasted "authorization" at http://hpaste.org/4900
06:45:05 <Saizan> :t \f g -> (f :: a -> b) >>> g
06:45:10 <lambdabot>     Inferred type is less polymorphic than expected
06:45:10 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
06:45:10 <lambdabot>         f :: a -> b (bound at <interactive>:1:1)
06:45:22 <Sizur> the most natural implementation i cameup with :/
06:45:24 <Saizan> no :)
06:46:15 <idnar> @type id
06:46:16 <lambdabot> forall a. a -> a
06:46:22 <idnar> @type id :: ?x
06:46:23 <lambdabot> parse error (possibly incorrect indentation)
06:47:00 <Saizan> ?type (id . ?f) >>> ?g
06:47:01 <lambdabot> forall b a d. (?f::a -> b, ?g::b -> d) => a -> d
06:47:39 <idnar> haha
06:47:45 <idnar> cheating ;)
06:48:44 <EvilTerran> ?type (?f `asTypeOf` (undefined :: a -> b)) >>> ?g
06:48:45 <lambdabot> forall a b d. (?f::a -> b, ?g::b -> d) => a -> d
06:49:21 <idnar> @type asTypeOf
06:49:22 <lambdabot> forall a. a -> a -> a
06:49:28 <EvilTerran> @src asTypeOf
06:49:28 <lambdabot> asTypeOf = const
06:49:41 <idnar> heh
06:49:53 <idnar> cute
06:50:06 <EvilTerran> ie x `asTypeOf` y = x, but with the constraint that they're the same type
06:50:15 <idnar> yeah
06:50:40 <EvilTerran> handy when you're not running with -XScopedTypedVariables
06:50:45 <EvilTerran> *TypeVar
06:52:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4901
06:52:50 <Saizan> and let's you use type unification rather than type equality
06:59:14 <ari> @quote spb
06:59:14 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
07:00:08 <spb> @quote ari
07:00:09 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell it grues suddenly become benign at, say, the
07:00:09 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
07:05:16 <aFlag> hi, I want to check if a number is a perfect square or not. So I'm checking if it is in this list: zipWith (*) [1..] [1..]. But that's kinda slow, is there a better way?
07:06:11 <quicksilver> yes, program an integer square root
07:06:30 <quicksilver> or, if you don't need to work with particularly large numbers, just use the Double sqrt
07:06:55 <quicksilver> > 121 == round . sqrt $ 121
07:06:57 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
07:07:07 <quicksilver> > 121 == (round . sqrt) 121
07:07:08 <lambdabot>  False
07:07:18 <znutar> or use the sums of the series of odds
07:07:41 <quicksilver> duh
07:07:54 <znutar> but programming an integer sqrt is probably the only sane way
07:07:56 <quicksilver> > 121 == ((round . sqrt) 121) * ((round.sqrt) 121)
07:07:57 <lambdabot>  True
07:08:01 <quicksilver> is what I meant, obviously :)
07:08:35 <aFlag> hm
07:09:05 <aFlag> let me see how to make an integer sqrt
07:18:35 <thorkilnaur> > let newtonRaphson n x = (n`div`x+x)`div`2; sqrtl n = nub $ iterate (newtonRaphson n) n in sqrtl 500
07:18:40 <lambdabot> Terminated
07:19:18 <thorkilnaur> > let newtonRaphson n x = (n`div`x+x)`div`2; sqrtl n = nub $ iterate (newtonRaphson n) n in take 7 $ sqrtl 500
07:19:20 <lambdabot>  [500,250,126,64,35,24,22]
07:19:30 <phlpp> @src nub
07:19:30 <lambdabot> nub = nubBy (==)
07:19:31 <__pao__> do anyone know where I can find a irc log for #haskell?
07:19:35 <thorkilnaur> aFlag, just a start ...
07:19:40 <phlpp> @src nubBy
07:19:40 <lambdabot> nubBy eq []             =  []
07:19:40 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:20:43 <hpaste>  therp pasted "can this be done nicer (prefix matching of strings)?" at http://hpaste.org/4903
07:21:12 <therp> ah there is even a syntax error.. first "->" should be "of"
07:23:15 <doserj> if "prefix" `isPrefixOf` str then ... else ... ?
07:23:39 <quicksilver> using | instead of if, perhaps
07:23:49 <kpreid> __pao__: http://ircbrowse.com/channel/haskell
07:23:54 <lambdabot> Title: Meme Channel haskell by Dates
07:23:56 <quicksilver> case str | "prefix" `isPrefixOf` str =
07:24:12 <__pao__> kpreid: thx
07:24:12 <aFlag> thorkilnaur, thanks
07:24:21 <Sizur> __pao__: http://tunes.org/~nef/logs/haskell/
07:24:22 <lambdabot> Title: Index of /~nef/logs/haskell
07:24:26 <doserj> why case at all?
07:24:31 <Sizur> woops
07:25:08 <quicksilver> doserj: well maybe it's simplified and he needs the case for other stuff
07:25:11 <quicksilver> I dont' know :)
07:25:52 <__pao__> Sizur: thx
07:25:53 <dcoutts> dons: hah, hah hah (re: haskell.hivefire.com)
07:25:54 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
07:28:42 <therp> quicksilver&doserj: but that doesn't give me the substring "rest"
07:29:16 <EvilTerran> ?type let dropPrefix [] cs = Just cs; dropPrefix (p:ps) (c:cs) | p == c = dropPrefix ps cs; dropPrefix _ _ = Nothing in dropPrefix
07:29:18 <lambdabot> forall t. (Eq t) => [t] -> [t] -> Maybe [t]
07:29:18 <therp> I already though of isPrefixOf, but than I have to use "drop n.."
07:29:34 <EvilTerran> ?src isPrefixOf
07:29:35 <lambdabot> isPrefixOf [] _          = True
07:29:35 <lambdabot> isPrefixOf _  []         = False
07:29:35 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
07:30:01 <therp> evilterran: hm that's nice yes.
07:30:25 <quicksilver> therp: yeah, dropPrefix helps
07:30:31 <quicksilver> therp: actually I have some code I used, one moment.
07:31:19 <doserj> case splitAt 6 str of ("prefix",rest) -> ...
07:31:47 <hpaste>  quicksilver annotated "can this be done nicer (prefix matching of strings)?" with "this is how I did it..." at http://hpaste.org/4903#a1
07:31:51 <therp> doserj: ah fine :)
07:32:18 <quicksilver> therp: standard solution to problems with haskell abstraction. Write the code once and then use a list of tuples as if it was a control structure.
07:33:42 <therp> quicksilver: I'd just use it once.
07:34:20 <hpaste>  EvilTerran annotated "can this be done nicer (prefix matching of strings)?" with "the slegehammer approach" at http://hpaste.org/4903#a2
07:34:22 <quicksilver> if just once, then I'd go for splitAt
07:34:26 <quicksilver> indeed, I was using splitAt
07:34:32 <quicksilver> unless I had commands of different lenghts :)
07:34:36 <EvilTerran> er, ignore that i left yours in at the top :P
07:35:38 <EvilTerran> ?type foldM<
07:35:40 <lambdabot> parse error (possibly incorrect indentation)
07:35:41 <EvilTerran> ?type foldM
07:35:41 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:36:09 <ciazzz> hi
07:36:10 <ciazzz> does anyone know a channel where one speaks about ns2 or systemC?
07:37:29 <therp> evilterran: the parsec solution also seems nice, thanks. but the situation I'd use it is within GHC, so I don't want to add a parsec dependency here
07:37:36 <shapr> @users
07:37:36 <lambdabot> Maximum users seen in #haskell: 444, currently: 408 (91.9%), active: 21 (5.1%)
07:37:41 <therp> thanks for the advice everyone
07:37:44 <shapr> Isn't 444 a new high water mark?
07:38:31 * EvilTerran tries desperately to think of a nice fold-based version
07:39:20 <EvilTerran> i'd want a non-truncating zip, unfortunately
07:39:46 <quicksilver> zipWith f (a++repeat Nothing) b
07:39:50 <quicksilver> works in some cases
07:39:53 <quicksilver> depending what you mean
07:39:58 <EvilTerran> well, map Just a...
07:39:59 <quicksilver> and FSOV Nothing
07:40:10 <quicksilver> there might be a natural unit already
07:40:15 <quicksilver> might not have to go via maybe
07:40:18 <quicksilver> that was just illustrative
07:44:03 <EvilTerran> > let dropPrefix ps cs = foldr ($) (Just cs) $ zipWith (\p c -> if p == c then liftM tail else const Nothing) ps cs in map (dropPrefix "foo") (words "food foon foo bar fod")
07:44:04 <lambdabot>  [Just "d",Just "n",Just "",Nothing,Nothing]
07:44:55 <therp> woot.
07:45:18 <sclv_> zomg
07:45:21 <sclv_> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Show/
07:45:21 <lambdabot> Title: There&#x2019;s no type class like Show type class
07:45:47 <sclv_> brilliant.
07:53:13 <Sizur> what's a good paper about applicative?
07:54:49 <quicksilver> AFAIK there is only one
07:54:59 <quicksilver> the one linked to in the docs
07:55:37 <Sizur> k
07:56:21 * C-Keen is starting to understand monads
07:56:40 <quicksilver> beware it's a slippery slope
07:56:50 <quicksilver> before you know it, you'll have written a tutorial on them.
07:56:58 <C-Keen> heh
07:57:54 * EvilTerran has an unpolished idea for "monads as Marble Run"
07:58:01 <C-Keen> quicksilver: for my problem this morning I guess it might be a nice solution to write a custom Maybe Monad with its own "Nothing"
07:58:20 <EvilTerran> what was the problem?
07:58:36 <Sizur> seems a bad idea inventing your own maybies
07:59:14 <C-Keen> Sizur: well what do I use then if I want the result of a computation and something else on failure but I don't want to explicitly pass it around?
07:59:34 <quicksilver> the question is, why do you need a custom one?
07:59:38 <quicksilver> why can't you use the existing one?
08:00:00 <aFlag> I think he only wants to learn how to do
08:00:10 <quicksilver> ah well, that's one good reason.
08:00:17 <C-Keen> aFlag: well no, I truely want to know how to do this right
08:00:31 <quicksilver> C-Keen: what advantage would your custom maybe monad have over the standard one?
08:01:06 <C-Keen> quicksilver: I would be able to use a value for the failure case instead of 'Nothing'?
08:01:21 <IvdSangen> then use Either
08:01:49 <C-Keen> hm...
08:01:51 <quicksilver> Yes, "Either String" is a monad with the failure case decorated by strings.
08:02:06 <quicksilver> if string doesn't suit you then you can use "Either foo"
08:02:18 <quicksilver> for any type foo as long as you provide an Error instance for it.
08:02:25 <C-Keen> quicksilver: Ah, yes then using this will be appropriate
08:02:26 <IvdSangen> yes, you can use an arbitrary type for your error
08:02:32 <Sizur> you can chain computation without explicit control of the error, if there is error, the whole thing will fail
08:03:01 <Sizur> so you wont be passing around things
08:03:23 <C-Keen> Sizur: I understand that this is one of the nice things about monads
08:04:12 <jwprox_> Can you write anything in Haskell that you could write in Python?
08:04:26 <IvdSangen> yes, they are both Turing Complete languages
08:04:30 <C-Keen> as it is turing complete yes
08:04:58 <jwprox_> Ok, Haskell compiles to binaries with the GC stuff built in correct?
08:05:06 * BMeph pulls out a trackball, and starts playing with "Monad Madness"...
08:05:08 <jwprox_> So it doesn't require an interpreter
08:05:20 <IvdSangen> it does not require an interpreter
08:05:28 <CosmicRay> well, IMHO turing-complete misses the point.  You can have a turing-complete language that has no mechanism to bind to the system's socket library, right?
08:05:31 <EvilTerran> yes, ghc compiles standalone executables by default
08:05:37 <CosmicRay> jwprox_: it can be.
08:05:43 <CosmicRay> jwprox_: haskell can be either compiled or interpreted.
08:06:06 <jwprox_> But you can't access memory directly correct? Its not like C
08:06:28 <EvilTerran> you can call any C function you like
08:06:32 <CosmicRay> jwprox_: in pure Haskell, no.  However, you can via the Foreign Function Interface (FFI), which is used to bind to C (or other languages)
08:06:47 <EvilTerran> but, in general, you neither can do that nor do you want to ;)
08:06:48 <CosmicRay> the FFI is normally not used by anyone other than library writers
08:07:03 <IvdSangen> or library users
08:07:19 <jwprox_> Cool guys, thanks for the info.
08:07:21 <Sizur> and a small subset of 'em
08:07:29 <CosmicRay> jwprox_: anything else we can do to help?
08:07:38 <pejo> jwprox, people could probably help you better if you mentioned what you wanted to do. People have written operating systems in Haskell.
08:07:46 <EvilTerran> ... they have?
08:07:53 <Sizur> yes and file system
08:08:08 <IvdSangen> House is an OS written in Haskell
08:08:27 <jwprox_> I've read the general overview of the language on the site, but just wanted to ask some specific questions that I was confused about.
08:08:37 <IvdSangen> go right ahead :)
08:08:39 <Toxaris> EvilTerran: http://haskell.org/haskellwiki/Applications_and_libraries/Operating_system
08:08:40 <lambdabot> http://tinyurl.com/2wcptv
08:09:11 <jwprox_> I've heard good things about functional programming and Haskell ( and Erlang)
08:09:32 <CosmicRay> jwprox_: you will find some things familiar in Haskell, since Python has actually borrowed a number of things from Haskell
08:09:42 <CosmicRay> such as list comprehensions and whitespace-as-syntax
08:09:59 <Sizur> :t let f (a:as) = return (:) `ap` a `ap`f as in f
08:10:03 <CosmicRay> haskell is a lazy, pure, functional language which makes it fairly unique.  and powerful.
08:10:04 <IvdSangen> tuple-packing/unpacking is a little bit like pattern matching
08:10:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:10:19 <jwprox_> CosmicRay: Yeah, the few code examples I have gone through have definitely shown some similarities with python
08:10:43 <EvilTerran> Sizur, isn't that sequence?
08:10:48 <Sizur> yes
08:10:49 <CosmicRay> haskell is going to be a bigger change in mindset than just about anything else.  I have found it to be quite fun and exciting.
08:11:05 <EvilTerran> ?type foldr (liftM2 (:)) (return [])
08:11:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:11:22 <Sizur> EvilTerran: i'm learning applicative
08:11:29 <EvilTerran> ah. okies.
08:11:51 <EvilTerran> ?pl \x xs -> (:) <$> x <*> xs
08:11:51 <lambdabot> (<*>) . ((:) <$>)
08:11:59 <CosmicRay> jwprox_: python has some, well, workarounds for things that Haskell does natively.
08:12:17 <CosmicRay> jwprox_: for instance, the whole python generator/iterator system is a workaround for the fact that python doesn't have lazy lists
08:12:18 <Toxaris> :t let f ((:) a as) = (:) <$> a <*> f as in f -- Sizur so why do you use `ap`?
08:12:19 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
08:12:51 <CosmicRay> jwprox_: http://www.freesoftwaremagazine.com/articles/haskell/ may be of interest
08:12:55 <lambdabot> Title: Haskell
08:12:59 <Sizur> Toxaris: because i am learning from a paper
08:13:28 <Toxaris> Sizur: oh you're at the motivation section. sorry for interrupting:)
08:13:44 <jwprox_> CosmicRay: Thanks, I'm going to dig in a little more and I might come back later for some more insight if you don't mind
08:13:48 <CosmicRay> sure
08:14:16 <Sizur> Toxaris: no sweat, it's always good to get feedback
08:14:36 <Sizur> unless you are the soundman
08:16:15 <Sizur> so the second `ap` works in a list monad?
08:16:59 <Toxaris> Sizur: no, both aps (have to) work in the same monad
08:17:16 <Toxaris> Sizur: the list processing is done by explicit recursion
08:17:25 <Sizur> ah right
08:18:22 <Toxaris> :t let f (x:xs) = x : f xs in f -- compare with this version
08:18:24 <lambdabot> forall t. [t] -> [t]
08:18:42 <Sizur> yeah i forgot there was recursion lol
08:19:37 <Sizur> but both arguments to ap must be in a monad
08:19:49 <Sizur> the (:) is lifter with return, but the "c" is not
08:19:59 <Sizur> lifted*
08:20:09 <Sizur> ah lol
08:20:22 <Sizur> my brain is in limboland, c is already in the monad
08:21:05 <Toxaris> :t sequenceA -- generalized version of sequence wich works over other list-like thingies too
08:21:06 <lambdabot> Not in scope: `sequenceA'
08:21:15 <Toxaris> :t Data.Traversable.sequenceA -- generalized version of sequence wich works over other list-like thingies too
08:21:16 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
08:21:21 <C-Keen> Sizur: limbo :)
08:23:35 <quicksilver> or not so list-like, indeed
08:27:35 <Toxaris> quicksilver: ok, what about: types wich support a list-like interface.
08:28:08 <Sizur> :t pure
08:28:09 <lambdabot>     Ambiguous occurrence `pure'
08:28:09 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
08:28:09 <lambdabot>                           or `pure', imported from Control.Arrow
08:28:18 <Sizur> :t Control.Applicative.pure
08:28:18 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:28:26 <Sizur> :t (<$>)
08:28:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:28:30 <quicksilver> Toxaris: well, it's up to you
08:28:38 <quicksilver> Toxaris: I don't think trees are "list-like" really
08:28:38 <Sizur> :t (<*>)
08:28:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:28:50 <quicksilver> Toxaris: I think Traversable is more like "structure with identifiable slots" or somethiing.
08:31:05 <Sizur> :t let f (a:as) = pure (:) <*> a <*> f as in f
08:31:19 <litb> hello all
08:31:20 <lambdabot> thread killed
08:31:21 <Toxaris> Sizur: Control.Applicative.pure
08:31:24 <litb> i've got a question again
08:31:33 <Sizur> oh yeah...
08:31:46 <litb> if i only want to execute something n times
08:31:55 <Toxaris> @let pureA = Control.Applicative.pure
08:31:55 <lambdabot> <local>:2:8: Not in scope: `Control.Applicative.pure'
08:31:56 <litb> do i really have to do that using map and a dummy list ?
08:32:07 <idnar> :t pure
08:32:08 <lambdabot>     Ambiguous occurrence `pure'
08:32:08 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
08:32:08 <lambdabot>                           or `pure', imported from Control.Arrow
08:32:10 <Saizan> ?type replicate
08:32:11 <lambdabot> forall a. Int -> a -> [a]
08:32:12 <idnar> heh
08:32:13 <Sizur> :t let f (a:as) = Control.Applicative.pure (:) <*> a <*> f as in f
08:32:13 <Syzygy-> The n-category cafe started talking about the Yoneda lemma and continuation passing: http://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html
08:32:14 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
08:32:14 <Saizan> ?type replicateM
08:32:14 <lambdabot> Title: The Continuation Passing Transform and the Yoneda Embedding | The n-Category Caf ..., http://tinyurl.com/yojraz
08:32:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:32:42 <idnar> litb: "execute" in the sense of IO actions or something?
08:33:00 <litb> idnar: just to execute something arbitrary
08:33:05 <litb> idnar: like, a function call
08:33:06 <Toxaris> > replicate 5 "something" -- litb
08:33:07 <lambdabot>  ["something","something","something","something","something"]
08:33:10 <idnar> anyhow, you probably want one of the things Saizan said
08:33:52 <litb> oh, that was for me. i didn't regocnize
08:34:03 <litb> err, i suppose i wracked up that word..
08:35:33 <Sizur> > (id (Just 1), Control.Applicative.pure id <*> (Just 1))
08:35:33 <lambdabot>  (Just 1,Just 1)
08:35:41 <litb> replicateM is to execute an IO action, and replicate is to execute a function ?
08:36:12 <litb> i somehow always say "execute" though function are not executed, but just evaluated as in math
08:36:37 <Saizan> litb: roughly, yes
08:36:41 <Saizan> and:
08:36:45 <Saizan> ?src replicateM
08:36:45 <lambdabot> replicateM n x = sequence (replicate n x)
08:36:59 <Saizan> replicateM is defined in terms of replicate :)
08:37:02 <twanvl> Sizur: pure f <*> x == f <$> x
08:37:10 <Sizur> aha
08:37:23 <Sizur> i remember seing that many times already
08:37:35 <litb> ?src sequence
08:37:35 <lambdabot> sequence ms = foldr k (return []) ms
08:37:35 <lambdabot>     where
08:37:35 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:37:39 <Sizur> i wonder how many times more i have to see it till it'll stay with me
08:38:15 <bringert> when do you want Hac 2008? make your self heard at http://www.haskell.org/haskellwiki/Hac_2008/Dates
08:38:16 <lambdabot> Title: Hac 2008/Dates - HaskellWiki
08:39:12 <Sizur> :t ((<*>) . Control.Applicative.pure)
08:39:28 <lambdabot> thread killed
08:39:42 <litb> and that sequence executes them magically?
08:39:58 <Toxaris> litb: no magic involved, no execution either
08:40:10 <Saizan> in sweden?
08:40:15 <Toxaris> litb: sequence builds a big do-block sequencing all the actions together
08:40:24 <Toxaris> litb: so you get a single action back
08:41:21 <Toxaris> litb: it's still up to you to execute that action (or return it as the main IO action to be executed by the runtime system)
08:41:21 <Sizur> so ((<*>).pure) is same as (<$>) except the first takes an Applicative and the second a Functor
08:41:34 <idnar> :t <$>
08:41:39 <lambdabot> parse error on input `<$>'
08:41:41 <idnar> :t (<$>)
08:41:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:41:51 <idnar> oh
08:42:10 <Toxaris> Sizur: yes I would say so
08:42:12 <quicksilver> litb: replicateM is for any monad, not just IO
08:42:21 <quicksilver> litb: oops, sorry. I was living in the past :P
08:42:24 <oerjan> @src liftA
08:42:25 <lambdabot> liftA f a = pure f <*> a
08:42:25 <resiak> oh, so <$> is just a synonym for fmap?
08:42:30 <quicksilver> yes, it is
08:42:33 <quicksilver> @src <$>
08:42:33 <lambdabot> f <$> a = fmap f a
08:42:34 <resiak> useful knowledge!
08:42:52 <idnar> @instances Functor
08:42:52 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:42:56 <quicksilver> :t replicateM_
08:42:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
08:43:01 <idnar> @instances-importing  Functor Control.Applicative
08:43:01 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
08:43:09 <quicksilver> litb: there is also replicateM_, for when you don't care about the answer.
08:43:13 <idnar> @instances-importing Functor
08:43:13 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:43:41 <idnar> is Applicative a an instance of Functor?
08:43:50 <Saizan> ?src Applicative
08:43:50 <lambdabot> class Functor f => Applicative f where
08:43:50 <lambdabot>     pure  :: a -> f a
08:43:50 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:44:16 * Saizan follows the long tradition of responding via \bot
08:44:32 <Toxaris> idnar: if a is an instance of Applicative, then a is an instance of Functor
08:45:12 <Sizur> hmm, functor is a superclass yet it's only method is defined in terms of it's subclass methods
08:45:37 <Sizur> or can be defined
08:45:58 <Sizur> seems wierd
08:46:03 <idnar> Toxaris: ok
08:46:18 <Toxaris> Sizur: everything is recursive and non-strict
08:46:24 <mattam> can be, but fmap and pure f <*> m are the same
08:46:38 <quicksilver> Sizur: that is often the case
08:46:47 <Toxaris> Sizur: unlike Pascal, we don't need forward; :)
08:46:48 <quicksilver> superclasses methods can often be defined in terms  of subclasses
08:47:00 <quicksilver> this would be true if Monad was a subclass of Functor, too
08:47:02 <idnar> @src Functor
08:47:02 <lambdabot> class  Functor f  where
08:47:02 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:47:10 <quicksilver> and also, if Monad was a subclass of Applicative similarly
08:47:21 <oerjan> idnar: you wouldn't get Applicative up as an instance since it isn't a type.  Also, instances-importing takes the modules first and the class last
08:47:43 <idnar> oerjan: yeah, I guess I was a bit confused
08:47:44 <Sizur> hmm, i'm detecting traces of OO in my brain
08:48:52 * oerjan brings the OO disinfecter
08:49:04 <litb> Toxaris: oh, i have still to discover the world of Monads
08:51:08 <Sizur> > (Just succ) <*> (Just 1)
08:51:10 <lambdabot>  Just 2
08:51:35 <Sizur> > fmap succ (Just 1)
08:51:36 <lambdabot>  Just 2
08:52:04 <Sizur> > Nothing <*> (Just 1)
08:52:04 <lambdabot>  Nothing
08:53:01 <Sizur> i love it so much when you can play around like that is such abstractions
08:53:10 <Toxaris> > succ <$> Just 1 == Just (succ $ 1)
08:53:10 <lambdabot>      precedence parsing error
08:53:10 <lambdabot>         cannot mix `(<$>)' [infixl 4] and `(==)...
08:53:10 <Sizur> with* such
08:53:16 <Toxaris> > (succ <$> Just 1) == Just (succ $ 1)
08:53:17 <lambdabot>  True
08:53:37 <Sizur> is this why they picked the $ in <$>?
08:53:52 <quicksilver> yes
08:54:00 <quicksilver> <$> is "$ inside the functor"
08:54:24 <quicksilver> before the days of <$> I used to use infix `fmap` for similar visual effect
08:54:30 <Toxaris> unfortunately, <*> is "$ inside the functor", too, but in a different way
08:54:34 <Toxaris> @src liftM
08:54:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:54:34 <quicksilver> but <$> looks better
08:54:41 <Toxaris> @src ap
08:54:41 <lambdabot> ap = liftM2 id
08:54:50 <Toxaris> :t liftM2 ($)
08:54:51 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
08:54:55 <Toxaris> :t ap
08:54:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:55:08 <quicksilver> Toxaris: well <*> is "$ inside the applicative"
08:55:12 <quicksilver> Toxaris: that's the hint.
08:55:29 <quicksilver> Toxaris: it's only definable for applicatives, not general functors, so it must be something a bit more sepcial.
08:55:32 <quicksilver> special.
08:56:38 <Toxaris> quicksilver: ? "*" is more special then "$"?
08:56:38 <Sizur> what precedence does $ have?
08:56:55 <dcoutts> infixr 0 $
08:57:21 <quicksilver> Toxaris: no, that's not what I meant.
08:57:28 <quicksilver> Toxaris: <$> really is "very like" $
08:57:34 <quicksilver> Toxaris: functoriality is a very natural concept
08:57:50 <quicksilver> Toxaris: <*> is a bit more subtle, it depends on the mechanics of that applicative
08:58:05 <quicksilver> (compare the behaviours of the two different applicatives on lists, for example)
08:58:26 <dcoutts> quicksilver: two different ones? what are they
08:58:30 <quicksilver> I think <$> deserves the name since it is "most like" <*>
08:58:36 <quicksilver> dcoutts: the standard list monad, plus ZipList.
08:58:43 <quicksilver> damn
08:58:46 <quicksilver> I think <$> deserves the name since it is "most like" $
08:58:49 <quicksilver> is what I was trying to type :)
08:59:00 <quicksilver> brain went to sleep at critical last moment.
08:59:18 <Toxaris> > getZipList $ (,) <$> ZipList [1, 2, 3] <*> ZipList "abc"
08:59:25 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
09:00:32 <Sizur> "any expression built from the Applicative combinators can be transformed to a canonical form in which a single pure function is ‘applied’ to the effectful parts in depth-first order"
09:01:02 <Toxaris> quicksilver: I think I see what you mean. <$> would be a good name for <*>, too, but it's better to use it for <$>, so we need a different one for <*>.
09:01:23 <quicksilver> Toxaris: yes. That is what I am trying to say :)
09:03:15 <Sizur> can you code a whole application in applicative format?
09:03:22 <Toxaris> quicksilver: I would vote for a single-char operator for fmap, and <$> for <*>
09:03:30 <roconnor> @kind A `Either` B
09:03:32 <lambdabot> Not in scope: type constructor or class `A'
09:03:32 <lambdabot> Not in scope: type constructor or class `B'
09:03:56 <Toxaris> main = aPureFunction <$> getArgs <*> getContent
09:04:05 <roconnor> @type (left "" :: String `Either` Bool)
09:04:07 <lambdabot>     Couldn't match expected type `Either b c'
09:04:07 <lambdabot>            against inferred type `[Char]'
09:04:07 <lambdabot>     In the first argument of `left', namely `""'
09:05:03 <roconnor> audreyt: I'm giving the takahashi method a try. :)
09:05:21 <Sizur> i wonder how complex that pure function will have to get
09:06:21 <jorik808> is there a haskell implementation of the R-Tree data structure?
09:06:36 <oerjan> clearly missing a putStr there
09:07:12 <dons> jorik808: i've not heard of one.
09:07:20 <dons> its possible though, check google
09:07:40 <jorik808> i did, rtree is a common name in haskell programs :D
09:07:58 <dons> :)
09:08:10 <dcoutts> probably as common as ltree :-)
09:08:29 <osfameron> is that the relatively indexed binary tree (like a xanadu enfilade) ?
09:10:14 <quicksilver> sizer is gone, but the answer to his question is that you can code your entire app applicatively if you never need to give parameters to one action depending on the result of the last action.
09:10:24 <quicksilver> that's what the IO monad lets you do that the IO applicative does not.
09:10:44 <quicksilver> Applicative = sequenced effects. Monad = threaded results.
09:14:09 <Saizan> is there a way with darcs to push to a repo without making it the default one? (so that successive pulls keep downloading from another)
09:15:00 <sjanssen> Saizan: --no-set-default, IIRC
09:15:07 <dcoutts> yep
09:15:19 <sjanssen> you can also set that in your preferences
09:15:26 <dcoutts> I use that all the time, along with darcs bash completion
09:15:37 <dcoutts> pull via http, push via ssh
09:17:18 <Kolji> ok...functional programming test passed
09:17:32 <Kolji> I mean finished
09:17:34 <roconnor> @go unicode star
09:17:36 <lambdabot> http://www.fileformat.info/info/unicode/char/2605/index.htm
09:17:36 <lambdabot> Title: Unicode Character 'BLACK STAR' (U+2605)
09:17:37 <Kolji> do not know if passed yet
09:17:40 <Kolji> Cale
09:17:49 <Saizan> thanks
09:18:40 <Kolji> ?
09:22:03 <Gwern-away> is there an appropriate field in .cabals for listing the darcs repo address?
09:26:24 <sjanssen> how do OCaml users feel about the "value restriction"?
09:26:46 <quicksilver> sjanssen: it used to piss me off no end
09:26:51 <quicksilver> sjanssen: when writing combinator libraries
09:26:54 <quicksilver> (like parsing combinators)
09:27:13 <quicksilver> sjanssen: trivial though it is, it's one of the things which makes me prefer haskell.
09:27:19 <sjanssen> nearly all Haskell users hate the monomorphism restriction, which is significantly more liberal.  Do people in the OCaml community whine about it like we do?
09:27:23 <jorik808> an rtree is it is (the way i understand it from wikipedia) a way to implement a sparse multidimensional array, so that you can easily select all items within a bounding box
09:27:33 <quicksilver> value restriction, constructors-as-functions, "." as an operator
09:27:44 <jorik808> so it seems perfect for the tile based game im trying to implement
09:27:45 <quicksilver> are the three things that make my day-to-day haskelling nicer than my day-to-day ocamling
09:27:59 <quicksilver> sjanssen: I was never really part of the community, so I can't judge I'm afraid.
09:28:22 <quicksilver> ocaml won't let you say "map Just" :(
09:28:38 <sjanssen> I wonder why that is
09:28:55 <hpaste>  resiak pasted "Should I in fact just be implementing Storable here with pretty much exactly the same function as po" at http://hpaste.org/4904
09:28:58 <quicksilver> well they think constructors are 'somethign differnet'
09:28:59 <Tac-Tics> can't you just wrap map... Just in Ocaml?
09:29:05 <Tac-Tics> =-)
09:31:52 <oerjan> Tac-Tics: sure you can map it but it would still be a nuisance
09:32:11 <oerjan> er, wrap it
09:32:55 <tibbe> anyone got haskell-mode working with ghc 6.8.2?
09:33:10 <oerjan> map (fun x -> Just x) or something like that, it's been a while
09:34:07 <Gwern-away> tibbe: what, in emacs? works fine for me
09:34:23 <tibbe> Gwern-away: aqua emacs to be specific
09:34:41 <Gwern-away> oh. nm then
09:35:43 <tibbe> Gwern-away: 6.8.2, GNU emacs?
09:36:13 <Gwern-away> so far as I know
09:37:14 <Altair^_> is there a way to randomize the order of the elements of the list?
09:37:21 <quicksilver> @go haskell shuffle
09:37:23 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
09:37:27 <quicksilver> that's one way :)
09:37:45 <quicksilver> there isn't a built-in Data.List function for it, no.
09:38:02 <quicksilver> tibbe: aqua emacs = LOSE
09:38:11 <oerjan> @go site:haskell.org/haskellwiki shuffle
09:38:16 <lambdabot> http://haskell.org/haskellwiki/Random_shuffle
09:38:32 <tibbe> quicksilver: well, there is carbon emacs but it looks worse from what I seen, besides it used to work before 6.8.2
09:38:37 <tibbe> doing some triaging
09:39:13 <quicksilver> tibbe: carbon emacs looks much better to me :)
09:39:24 <quicksilver> tibbe: I would use either carbon emacs, or GNU emacs in X11.app.
09:39:28 <tibbe> quicksilver: I might give it a try
09:39:35 <tibbe> ok
09:40:15 <reqamst> quicksilver: carbon emacs? what is it?
09:40:40 <Altair^> quicksilver: thanks :)
09:40:46 <quicksilver> reqamst: a compilation of GNU emacs for OSX which I find greatly preferable to Aquamacs
09:41:04 <pejo> reqamst, http://homepage.mac.com/zenitani/emacs-e.html
09:41:04 <lambdabot> Title: Carbon Emacs Package
09:41:33 <reqamst> quicksilver: uhm... only for OSX
09:41:36 <tibbe> quicksilver: could you enumerate some benefits?
09:41:51 <quicksilver> tibbe: aquamacs tries to be mac like
09:41:55 <quicksilver> breaks the default keybindings
09:41:57 <tibbe> right
09:42:02 <quicksilver> puts dialog boxes in where I don't want them
09:42:13 <tibbe> I think I got rid of most of that behavior
09:42:25 <quicksilver> I have spent 15 years letting my fingers absorb emacs keybindings by a kind of zen osmosis.
09:42:35 <quicksilver> I do not wish that work to have been in vain.
09:42:37 <tibbe> I know what you're talking about
09:42:50 <quicksilver> carbon emacs doesn't try those things
09:42:59 <tibbe> I wish I could reliably resize emacs to fit 2 80 char wide frames on os x
09:42:59 <quicksilver> it jsut gives you an icon, a working clipboard
09:43:34 <quicksilver> working Mac keybaord and mouse support
09:43:37 <quicksilver> and leaves the rest to you
09:43:39 <quicksilver> which is what I want :)
09:44:07 <pejo> tibbe, hm. My windows with carbon emacs are surprisingly close to 80 chars wide.
09:44:19 <tibbe> pejo, If you Do C-x 3?
09:44:24 <tibbe> to get two frames
09:44:45 <quicksilver> ah, failure to communicate
09:44:51 <quicksilver> tibbe: those aren't frames, those are windows.
09:44:58 <quicksilver> C-x 5 2 is what gives you two frames.
09:45:27 <pejo> tibbe, ai! That was nasty!
09:45:39 <tibbe> quicksilver: ay, always mix up the two
09:45:51 <quicksilver> I run with two emacs frames (what ordinary people call windows) both 80 chars wide
09:46:01 <quicksilver> I save that to a register
09:46:08 <quicksilver> and if I move them about or change sizes
09:46:11 <quicksilver> I jump back to the register
09:46:53 <tibbe> I use C-x o to jump between my windows
09:46:58 <tibbe> doesn't work for frames
09:47:11 <quicksilver> that is a reasonable criticism of my approach
09:47:25 <quicksilver> I use Command-~ to switch between frames :)
09:47:32 <quicksilver> although I must admit I mostly use the mouse.
09:48:05 <cjb> yes, that seems like a window manager operation.
09:51:06 <tibbe> quicksilver: same problem with carbon emacs, I blame GHC
09:51:11 <tibbe> trying older GHC now
09:55:03 <Gwern-away> @pl looksOk s = http `B.isPrefixOf` s
09:55:03 <lambdabot> (line 1, column 18):
09:55:03 <lambdabot> unexpected "`"
09:55:03 <lambdabot> expecting variable, "(", operator or end of input
09:55:31 <Gwern-away> @pl http `B.isPrefixOf` s
09:55:31 <lambdabot> (line 1, column 6):
09:55:31 <lambdabot> unexpected "`"
09:55:31 <lambdabot> expecting variable, "(", operator or end of input
09:55:41 <Gwern-away> hm.
09:55:53 <Gwern-away> @pl looksOk s = (B.isPrefixOf) http s
09:55:53 <lambdabot> looksOk = B (isPrefixOf http)
09:55:58 <oerjan> Gwern-away: @pl doesn't do module prefixes
09:56:10 <Gwern-away> @pl looksOk s = (isPrefixOf) http s
09:56:11 <lambdabot> looksOk = isPrefixOf http
09:56:23 <Gwern-away> well, obviously
09:56:39 <Gwern-away> guess you cn't drop redundant variables with infix notation
09:57:12 <Saizan> Gwern-away: you can use sections
09:57:22 <Saizan> http `isPrefixOf`
09:57:34 <Saizan> looksOk = (http `isPrefixOf`)
09:57:42 <oerjan> @pl looksOk s = http `isPrefixOf` s
09:57:42 <lambdabot> looksOk = (http `isPrefixOf`)
09:58:40 <Gwern-away> good point
09:59:33 <Gwern-away> :t io
09:59:48 <lambdabot> Not in scope: `io'
10:01:04 <oerjan> Gwern-away: io is often an abbreviation of liftIO, i think
10:07:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4906
10:09:41 <Gwern-away> what's the command to leave someone a message through lambdabot?
10:09:58 <oerjan> @list tell
10:09:59 <lambdabot> tell provides: tell ask messages messages? clear-messages
10:10:57 <Gwern-away> @tell dons Maybe you could make a .2 release of urlcheck for hackage which works with 6.8.2 per my patches?
10:10:57 <lambdabot> Consider it noted.
10:11:19 <ddarius> @bot
10:11:19 <lambdabot> :)
10:12:34 <glguy> ?hackage urlcheck
10:12:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/urlcheck
10:13:02 <Saizan> ?hackage syb-with-class
10:13:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/syb-with-class
10:13:03 <Gwern-away> (glguy: split-base problems)
10:13:19 * glguy is listening to, and recommends: Still Alive - Jonathan Coulton & GLaDOS from The Orange Box
10:13:30 <glguy> hmm, wrong channel :)
10:14:38 <bos> glguy: it's okay, there'll be cake anyway.
10:14:59 <glguy> :)
10:15:18 <Gwern-away> glguy: look at you, still talking when there's haskell to do!
10:15:42 <glguy> looks like more people have heard of it than I'd anticipated!
10:16:07 <tibbe> quicksilver: so you're on GHC 6.8.2, haskell-mode-2.4 and carbon emacs on tiger/leopard?
10:16:09 <bos> if your weighted companion lambdabot starts giving you advice, please ignore it.
10:16:22 * Gwern-away is making a note: the song is a huge success
10:17:01 * bos scrawls on the wall: the lambda calculus is a lie...
10:17:52 <litb> hmm
10:18:32 <bos> of course, a portal gun is the physical realisation of callCC.
10:18:43 <glguy> dons: I'll submit the patch for urlcheck
10:18:59 <dons> why are people asking about urlcheck, btw?
10:19:05 <dons> i just got a patch from gwern about it
10:19:10 <glguy> oh :(
10:19:15 <dons> ah
10:19:21 <dons> Gwern-away: yes, i'll upload your fixes
10:19:53 <Gwern-away> thnx
10:21:36 <Gwern-away> (one package closer to the day I can cabal install everything...)
10:23:11 <dons> someone needs a bit of haskell help, http://www.daniweb.com/forums/thread104257.html
10:23:40 <dons> i'd also like hugs banned, the error messages are worse than ghc now, and its slow enough to leave a bad taste
10:24:29 <bos> you and ndm can duke it out :-)
10:24:43 <dons> bah, winhugs
10:28:33 <Saizan> > let l :: [a]; l = undefined in l null
10:28:36 <lambdabot>  Couldn't match expected type `([a] -> Bool) -> t'
10:28:48 <dons> null l
10:29:12 <Saizan> yup, i was checking the ghc's error
10:29:22 <dcoutts> my major grumble with hugs is that it is effectively unversioned
10:29:48 <Gwern-away> dons: someone should give that guy a zip!
10:30:05 <dons> or recommend he joins #haskell :)
10:30:26 <Saizan> too bad you've to register to respond
10:30:34 <glguy> yup, or I would have :)
10:30:35 <dcoutts> System.Info> compilerVersion
10:30:36 <dcoutts> Version {versionBranch = [0,0], versionTags = []}
10:30:39 <dcoutts> yay! no version
10:30:43 <dons> mm
10:30:45 <idnar> banned from what?
10:30:48 <dcoutts> and look, no hugs --version flag :-)
10:30:49 <glguy> Who posts Haskell questions to some unknown web forum?
10:30:57 <dcoutts> hence cabal cannot determine the hugs version number
10:31:19 * glguy assumes that that post is bait put out by the forum developers to draw us in
10:31:39 <dons> hugs has been deprecated for almost a decade now, anyway. but its surprisingly resiliant!
10:31:51 <dons> then again, there are universities still teaching in Miranda
10:32:07 <dcoutts> dons: no, seriously?
10:32:45 <dons> seriously. we had one of the better students at such a course here a few months ago, he'd decided haskell was better supported, and was translating to Miranda to submit
10:32:55 <glguy> unlike GHC 6.8.2, Hugs can change mpc + fundeps for soundness :)
10:32:57 <daf> I studied Miranda at University a few years ago
10:33:11 <daf> I think it was the class I did best at through my entire course
10:33:13 * dcoutts is shocked
10:33:20 <daf> (and possibly why I'm using Haskell now)
10:34:02 <daf> Miranda was fun; the Sun machines we were using them on weren't
10:34:34 <roconnor> @type ((),())
10:34:36 <dcoutts> daf: heh, same problem at Oxford, we only junked our Sun machines this year
10:34:37 <lambdabot> ((), ())
10:34:46 <daf> dcoutts: :)
10:34:58 <daf> I mean seriously, Backspace and Delete were switched
10:35:01 <dcoutts> (this academic year)
10:35:10 <dcoutts> daf: aaarg, and readline and vim broken
10:35:18 <daf> vim? luxury!
10:35:43 <Saizan> glguy: hugs has mtpcs and fundeps, it's newtype deriving that makes the mix unsound iirc
10:35:46 <daf> though I think they did have bash installed, so you could escape csh
10:35:56 <dcoutts> a very old borked version, it was just torturing you with its existence since it was totally unusable
10:36:04 <daf> ah, pain
10:36:14 <aFlag> no pain no gain
10:36:28 <dcoutts> daf: I survived by removing solaris and installing gentoo on my sun workstation :-)
10:36:34 <tibbe> my haskell-mode for emacs is broken and I don't understand why :(
10:36:42 <dcoutts> pitty I couldn't do that for the student machines :-)
10:36:56 <tibbe> tried aqua/carbon emacs, haskell-mode-2.3/2.4 and GHC 6.8.1/6.8.2 :(
10:37:15 <tibbe> how am I supposed to write haskell without it?
10:37:17 <dons> 12:48:04 <DangerMouse> chessguy, im new :) + this is miranda code so im not sur
10:37:18 <dons> e if it has the appropriate haskell equivilant
10:37:56 <dons> dcoutts: ^ we were handling miranda questions still in 2007!
10:38:06 * dcoutts sighs
10:38:19 <dcoutts> dons: someone needs to write to the person running that course
10:38:24 <Saizan> os x seems every day more broken wrt haskell
10:38:52 <dons> we should have some recommendations for people wanting to use a Haskell for teaching prominently on the website
10:39:33 <dcoutts> dons: the Programming in Haskell book is a good recommendation for anyone running a course
10:40:14 <tibbe> Saizan: what problems are you having?
10:40:15 <dcoutts> @ask ndm if you have any influence in hugs development, please please please add a --version flag (from Cabal's pov hugs is totally unversioned)
10:40:15 <lambdabot> Consider it noted.
10:40:18 <dons> up to date info on http://haskell.org/haskellwiki/Haskell_in_education with recommendations of which tools/textbooks to use would be a good idea
10:40:55 <dcoutts> @tell ndm and in hugs, System.Info.compilerVersion = Version [0,0] []  :-)
10:40:55 <lambdabot> Consider it noted.
10:41:22 <Saizan> tibbe: i don't have a mac, i'm just referring to complaints on this channel, like the ld bug
10:41:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4907
10:42:19 <tibbe> Saizan: oh, I see
10:48:55 <Cale> dons: What channel is that from?
10:49:19 <Cale> #haskell in 2007? :)
10:49:53 <sjanssen> we had a Clean question a day or two ago
10:53:28 <dons> yeah, Cale.
10:55:14 <dons> sjanssen: the value restriction is a bit scary isn't it. you can see what Wadler was getting at: purity makes for a better teaching/research language, since equational reasoning works.
10:56:43 <sjanssen> dons: I think it's a very interesting point
10:56:52 <dons> yeah.
10:57:04 <sjanssen> many people point to monads and the like as the "cost" of purity in Haskell -- but they don't consider the cost of impurity
10:57:21 <sjanssen> OCaml will probably always be stuck with the value restriction
10:59:30 <idnar> what is the "value restriction"?
10:59:43 <oerjan> well, unlike the monomorphism restriction, removing the value restriction makes an ml unsound...
11:00:07 <sjanssen> oerjan: exactly
11:00:26 <sjanssen> idnar: bindings that "look like constants" must be monomorphic in OCaml
11:01:35 <oerjan> actually that is almost exactly backwards to the explanation i recall :D
11:01:45 <roconnor> @seen swiert
11:01:46 <lambdabot> swiert is in #haskell. I don't know when swiert last spoke.
11:02:08 <oerjan> because ocaml looks at what is to the right of the = sign
11:02:20 <sjanssen> oerjan: all bindings are monomorphic unless they look like functions?
11:02:20 <oerjan> and if it _is_ a constant, the restriction doesn't apply
11:02:50 <oerjan> where lambda expressions are considered constants
11:03:24 <oerjan> i _might_ be confusing with something else
11:03:55 <oerjan> but i vaguely think you can have constructor applications
11:04:04 <roconnor> Anyone know what they would name the function from Bool -> type in Epigram?
11:10:15 <dcoutts> bringert: if you have a mo, could you review the http proxy patch that was submitted for cabal-install
11:10:32 <C-Keen> is there a hash table type in haskell?
11:10:48 <dcoutts> bringert: in particular I wonder if finding what proxy to use could be something that the http library could take care of
11:11:03 <sjanssen> C-Keen: yes, Data.HashTable.  But we almost always use Data.Map instead
11:11:18 <C-Keen> sjanssen: what's the difference?
11:11:30 <markluffel> will the timing/memory results (from :set +s) from running interpreted code in ghci be comparable (in relative magnitude) to running compiled code?
11:11:38 <dons> Data.Map is faster, and a purely functional, persitent data structure
11:11:51 <dons> markluffel: hmm. i wouldn't trust it
11:12:05 <dons> since you don't get a range of optimisations that could change the complexity of the code
11:12:10 <sjanssen> markluffel: in many cases, no
11:12:10 <dcoutts> bringert: eg looking up stuff in the registry on windows, using a env var on unix, perhaps even dealing with the notion of proxy overrides for certain (usually local) addresses
11:12:11 <C-Keen> ah ok thanks
11:12:53 <markluffel> dons: even for simple cases like defining a function with foldr vs foldl?
11:13:19 <dons> many cases will be similar, just an order of magnitude slower when interpreted
11:13:28 <dons> since the same compiled code is used in the library calls
11:13:33 <dcoutts> C-Keen: though changes in asymptotic complexity are fairly rare, the change in constant factors from using -O can vary quite dramatically depending on how the code is structured
11:16:35 <litb> so executing monads in row essentially only means to stream them together with >>= , and give them to return ?
11:17:33 <litb> > return (putStr "1" >>= putStr "2")
11:17:35 <lambdabot>  Couldn't match expected type `() -> IO b'
11:17:42 <litb> hm, damn. that isn't it
11:17:52 <tibbe> litb: IO is not allowed by the bot either
11:17:58 <byorgey> litb: do { m ; n }  -->  m >> n;   do { x <- m ; n }  --> m >>= \x -> n
11:20:45 <dcoutts> litb: so yes, you string the actions together with >>= (or sometimes >>) and return is usually the final action that returns some result
11:21:13 <idnar> > putStr "1" >>= putStr "2"
11:21:14 <lambdabot>  Couldn't match expected type `() -> IO b'
11:21:19 <idnar> er
11:21:21 <idnar> > putStr "1" >> putStr "2"
11:21:24 <lambdabot>  <IO ()>
11:21:36 <dcoutts> litb: so return is not the thing that runs a monadic action, it's usually the final action in a block that returns the interesting result value
11:22:28 <idnar> litb: return creates a value in the monad from a "normal" value
11:22:29 <dcoutts> litb: >>= is for when one action depends on the value produced by a previous action, >> is for when there is no such dependency
11:22:31 <idnar> > return 5 :: Maybe Int
11:22:32 <lambdabot>  Just 5
11:22:42 <idnar> > return 5 :: IO Int
11:22:43 <lambdabot>  <IO Int>
11:22:49 <idnar> > return 5 :: [Int]
11:22:50 <lambdabot>  [5]
11:23:11 <dcoutts> > getChar >>= putChar
11:23:13 <lambdabot>  <IO ()>
11:23:26 <dcoutts> > putChar 'a' >> putChar 'b'
11:23:26 <lambdabot>  <IO ()>
11:23:31 <dcoutts> litb: see?
11:24:13 <litb> mom, just got some food to eat
11:26:31 <roconnor> are types red and terms blue, or the other way around?
11:28:05 <Corun> Goooood evenin'.
11:28:42 <byorgey> hi Corun
11:28:56 <dcoutts> roconnor: according to epigram convention, terms are red, types blue
11:29:08 <dcoutts> roconnor: see eg http://www.e-pig.org/downloads/epigram-notes.pdf
11:29:22 <ToRA> Corun: howdy
11:29:58 <dcoutts> roconnor: but they've also got other crazy colour conventions using green and purple
11:31:02 <byorgey> one type, two type, red type, blue type
11:31:04 <dcoutts> green for defined variable (like defining data types), purple for abstracted variable (eg forall'ed over)
11:31:14 <roconnor> dcoutts: hmm, do you know what green and purple are?
11:31:28 <dcoutts> roconnor: yup, just said :-) see also page 7 of that pdf
11:33:06 <bringert> dcoutts: hmm, yeah, maybe the http package should deal with that
11:33:46 <bringert> dcoutts: is it the patch from Dec 22?
11:34:11 <dcoutts> bringert: probably, jim burton, "http proxy patch needs testing" or similar iirc
11:34:17 <Corun> Yay for nuclear power!
11:34:33 <dcoutts> bringert: I've applied it already but it may still need some attention
11:35:05 <dcoutts> bringert: eg on windows it looks like it does not respect the enabled/disabled status of the proxy and it certainly does not consider proxy overrides for local addresses
11:36:51 <dcoutts> bringert: on gnome systems it's worse since the proxy is set in gconf, though console apps are expected to use the env var I suppose
11:39:18 <bringert> dcoutts: the code looks reasonable
11:39:28 <bringert> dcoutts: it really should be in HTTP as you say
11:39:45 <dcoutts> aye, it'd be silly to duplicate in every app
11:40:18 <bringert> I'm not set up to hack on the windows stuff, but I guess jim burton might want to keep developing it
11:40:50 <dcoutts> aye, he or others could help develop & test
11:40:59 <bringert> dcoutts: feel free to encourage him to submit patches for HTTP
11:41:04 <dcoutts> 'k
11:41:22 <dons> the haskell community has some interesting people,
11:41:24 <dons> "The essence of non-strictness, though, is another kind of story. Like
11:41:24 <dons> a golem plowing half of the country until you remember that you placed
11:41:24 <dons> him a bit absent-mindedly into your backyard and said "plow", that
11:41:24 <dons> still won't plow mountains.
11:41:27 <dons> The essence of strictness is easy, though: get stuck on a stone, fall
11:41:29 <dons> over and continue moving until you break."
11:41:41 <chadz> hey -- anyone know if it's possible to pass a extra-lib-dirs option alongto cabal-install?
11:42:05 <dons> oh, so a package is failing to build, due to incorrect detection of extra-lib-dirs?
11:42:16 <dons> there's no way atm to pass those on the command line, is there, dcoutts ?
11:42:29 <swiert> roconnor: So.
11:43:33 <dcoutts> dons: no, not atm, it's a weak area, we should try and automatically detect at configure time if required C libs are available
11:44:16 <pierre-> hello haskellers
11:44:26 <dons> chadz: also, any build failure in cabal-install like that is an issue for that library's maintainer -- they need a configure script to set buildinfo
11:44:32 <dcoutts> dons: and we should think about how to automatically detect where they might live and only ask the user as a last resort
11:45:00 <dcoutts> dons: or preferably a Setup.hs to do it, ./configure should not be necessary
11:45:00 <dons> dcoutts: iirc, cc-options and ld-options aren't getting propagated from .buildinfo files still?
11:45:12 <dcoutts> dons: I believe they are
11:45:20 <dcoutts> dons: and I think they always have been
11:45:27 <dons> hmm, /me checks
11:45:43 <chadz> dcoutts: potentially a cabal.conf might be nice, where I can attempt to specify cabal optioins that are general for all builds. but i know too little about cabal to know if it's possible
11:45:44 <roconnor> swiert: do you know what epigram calls the function from Bool -> Type?
11:45:49 <dcoutts> dons: you asked me before and you were setting the build info for a lib and not the exes
11:46:00 <swiert> roconnor: So : Bool -> Prop.
11:46:01 <dons> dcoutts: oh right.
11:46:08 <dons> dcoutts: that's it.
11:46:14 <roconnor> oh
11:46:17 <dons> works fine for libs of course.
11:46:24 <swiert> roconnor: at least that's what we tend to call it.
11:46:30 <roconnor> swiert: that's a pretty crappy name
11:46:31 <dons> i noticed it in the libcurl test program, not libcurl itself
11:46:41 <roconnor> :)
11:46:47 <oerjan> roconnor: So True ;)
11:46:51 <swiert> roconnor: Well something is either "So True" or "So False".
11:46:57 <roconnor> swiert: any funky notation for papers, or is it still So
11:47:07 <dcoutts> chadz: what package are you having problems with btw?
11:47:16 <swiert> roconnor: not that I can think of, off the top of my head...
11:47:20 <roconnor> ok
11:47:26 <quicksilver> conor has a weakness for names that form mildly punned phrases
11:47:35 <roconnor> I'm gonna stick with my <True> <False> notation for now.
11:47:45 <chadz> oh, a ton. i have a local install of lgmp, so anything that uses Integers requires me to add my local libdir path.
11:47:50 <quicksilver> I recall that "Oh (So True)" comes up in one of his papers
11:47:52 <roconnor> quicksilver: F me
11:48:12 <dcoutts> chadz: I see, isn't there an env var for LD that does what you want?
11:48:31 <dcoutts> chadz: to extend the default library search path
11:48:33 <chadz> iv'e tried prepending my lib directory, it didn't seem to work.
11:48:51 <chadz> LD_LIBRARY_PATH, right?
11:49:32 <dcoutts> chadz: that's for use by the dynamic linker I think, to look for shared libs
11:49:51 <chadz> which is what libgmp is.
11:49:59 <chadz> however, cabal on my system seems to at least ignore it
11:50:01 <dcoutts> right but that does not help at link time
11:50:22 <dcoutts> chadz: well we call ld and that ignores it because it's not what you want
11:52:27 <chadz> so, when cabal invokes ld, it doesn't use the LD_LIBRARY_PATH search directories?
11:52:49 <chadz> i'm not following, apologies :)
11:54:01 <chadz> if I knew how it was obtaining the current lib directory, I may be able to coax it into looking in the right place.
11:54:16 <dons> right. you can use LDFLAGS to set .buildinfo though
11:55:05 <dcoutts> chadz: I can't find what env var ld uses to decide it's search path
11:55:17 <dons> Ghc-options: -optc@CPPFLAGS@
11:55:19 <dons> Cc-options:  @CPPFLAGS@
11:55:23 <dons> i needed for one lib.
11:55:36 <bringert> dcoutts: LIBRARY_PATH
11:55:37 <dons> cc-options: @CPPFLAGS@
11:55:38 <dons> ld-options: @LDFLAGS@
11:55:51 <quicksilver> LDFLAG = -L/foo/bar/baz
11:55:52 <quicksilver> ?
11:55:54 <quicksilver> +S
11:56:09 <bringert> quicksilver: that's not an env var used by ld, I think
11:56:14 <bringert> use LIBRARY_PATH
11:56:18 <dcoutts> bringert: I can't find that documented anywhere
11:56:35 <litb> hm, how can i display the source of a function, other than in this channel?
11:56:37 <bringert> I can't remember where I found it, but it works on OS X at least
11:56:49 <litb> is there some site with search functionality or even a function in ghc?
11:56:59 <bringert> litb: the source link in the API docs
11:57:00 <chadz> LIBRARY_PATH worked :)
11:57:10 <chadz> bringert: thanks.
11:57:14 <tibbe> bringert: which ghc/emacs/haskell-mode are u using on os x, I'm having some troubles with inferior haskell I'm trying to debug
11:57:28 <mux> ld accepts a -L flag, same as gcc
11:57:58 <bringert> tibbe: I'm using aquamacs and haskell-mode 2.3
11:58:05 <tibbe> ok
11:58:10 <bringert> tibbe: but I don't use ghc from within emacs
11:58:23 <tibbe> ok
12:01:23 <tibbe> this is making me really aggreviated
12:01:54 <tibbe> and I can't install ghc from port either
12:02:01 <tibbe> I thought I use to be able to do that
12:02:15 <shapr> hej bringert!
12:02:20 <bringert> hej shapr
12:02:27 <shapr> How's life?
12:02:32 <bringert> shapr: want to come to gothenburg for the hackathon?
12:02:40 <bringert> shapr: good but busy
12:02:45 <bringert> shapr: you
12:02:49 <bringert> ?
12:02:55 <tibbe> bringert: any preliminary date for the hackathon yet?
12:03:48 <bringert> tibbe: we figured we'd give it a bit more time, but it seem likely to one of the ones that are bad for you
12:03:54 <bringert> +be
12:03:57 <tibbe> ok
12:04:01 <tibbe> that's alright :)
12:04:08 <tibbe> I'll do some hacking on my own ;)
12:04:16 <tibbe> if this !@#Q@#EQEW emacs stuff will work
12:04:18 <MagicDuck> hi, why are ghc executables so large? A simple hello  world program is 2.8M
12:04:30 <bringert> MagicDuck: first step: strip
12:04:38 <sclv_> MagicDuck: the haskell runtime is linked into them.
12:04:45 <byorgey> MagicDuck: to make room for the cupcake, of course!
12:04:48 <MagicDuck> oh, I see
12:04:56 <dcoutts> bringert: 14 sign-ups so far is good :-)
12:04:57 <Corun> An echo server is 450k on OS X...
12:04:58 <tibbe> bringert: how to strip a binary?
12:05:07 <bringert> strip helloWorld
12:05:13 <Corun> (On nix)
12:05:24 <sclv_> i.e. there's a fixed cost, but it doesn't rise with the cost of the program.
12:05:31 <bringert> or -optl-s I think
12:05:34 <sclv_> s/cost of the program/size of the program/
12:06:01 <desegnis> Hello world is 356K, and 245K stripped, on my computer
12:06:05 <MagicDuck> okay, now it's at 1.6M. That's better
12:06:40 <gwern> bringert: I thought -optl-s only works when you go via-c?
12:06:55 <gwern> MagicDuck: if that's too big, you could always use JHC :)
12:06:56 <bringert> gwern: doesn't ghc always use ld to link?
12:07:04 <dcoutts> gwern: linking always goes via gcc
12:07:11 <bringert> gwern: it always needs to link in some c libraries
12:07:14 <dcoutts> and gcc calls ld
12:07:26 <gwern> oh. didn't know that
12:07:26 <MagicDuck> what's jhc?
12:07:48 <dcoutts> MagicDuck: an interesting experimental haskell compiler
12:07:59 <gwern> anyway, what's JHC's hello world these days? 1 gig of ram to compile a hello world of a few k, I heard it said..
12:17:51 <sjanssen> dons: neelk always brings this example up...
12:19:07 <bench0> what does the 'no instance' mean in "No instance for (Text.HTML.TagSoup.TagRep Tag)"?
12:19:15 <bench0> i've imported the module
12:19:22 <sjanssen> bench0: it means there is not an instance for that class and type
12:19:55 <monochrom> Programmer error.
12:20:02 <Cale> > isIEEE (1/0)
12:20:08 <lambdabot>  True
12:20:11 <bench0> sjanssen, the Tag type?
12:20:19 <sjanssen> bench0: Tag type, TagRep class
12:20:22 <monochrom> > isIEEE undefined
12:20:23 <lambdabot>  True
12:20:26 <monochrom> hehe
12:20:29 <Cale> :)
12:20:48 <faxlore> > isIEEE ([],[])
12:20:48 <lambdabot>        add an instance declaration for (RealFloat ([a], [a1]))
12:20:48 <lambdabot>     In the exp...
12:21:15 <monochrom> You likely use the Tag type or TapRep operations wrong.
12:21:41 <bench0> sjanssen, so it means that Tag type isn't an instance of the TagRep class i assume?
12:21:50 <sjanssen> bench0: yes
12:23:39 <tibbe> wow, cabal-install works really nicely here!
12:24:08 <roconnor> > fix signifigand
12:24:09 <lambdabot>   Not in scope: `signifigand'
12:24:16 <roconnor> > fix significand
12:24:17 <lambdabot>  Exception: <<loop>>
12:24:37 <oerjan> :t significand
12:24:38 <lambdabot> forall a. (RealFloat a) => a -> a
12:24:44 <tibbe> we really need to get cabal-install as a debian/etc package
12:24:47 <tibbe> i.e. the binary
12:24:50 <oerjan> > significand pi
12:24:50 <lambdabot>  0.7853981633974483
12:24:57 <bench0> sjanssen, thanks
12:25:08 <litb> hm, why is there a latex section in yaht ?
12:26:26 <bogner> litb: literate programming?
12:27:42 <litb> oh, woot? but is it interpreted by the compiler? (i'm not in latex, but i'm looking forward)
12:29:31 <bogner> litb: i'm not really sure, i think "bird scripts" are the more popular form of literate haskell
12:29:43 <kmcallister> litb: no, the code can be preprocessed into either a haskell program (stripping the latex) or a latex document describing the haskell program (formatting the code using verbatim or a fancier latex environemnt)
12:30:56 <kmcallister> i like the concept but it makes the raw code hard to read, so i don't use it very often
12:31:07 <litb> hm
12:32:02 <litb> i've noticed that functions in haskell are quite often only a few lines heigh, while in c++, they tend to be pages covered only by one function
12:32:08 <kmcallister> yes
12:32:13 <faxlore> litb: :D
12:32:27 <kmcallister> in haskell you will spend 2 hours thinking about a problem, and then write down 1 or 2 lines to solve it
12:32:50 <kmcallister> you really can't make progress if you're not sure what you're doing, unlike in, say, java
12:33:11 <allbery_b> @quote true.haskell.fashion
12:33:11 <lambdabot> No quotes match. Sorry.
12:33:19 <Cale> Hehe, where you can waste lots of time writing all that boilerplate even if you're not sure what it'll contain yet :)
12:33:21 <allbery_b> @quote true.Haskell
12:33:21 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
12:34:05 <shapr> bringert: Nah, I have a new job doing C#, so I'll be busy for quite some time.
12:34:26 <conal> haskell programming ups the ratio of thinking to coding.  so perhaps haskell productivity should be measured in KLOT.
12:34:41 <shapr> Leagues of Thought?
12:34:57 <byorgey> Kilo-Lambdas of Thought?
12:35:12 <monochrom> If you are still unclear what you should do, but you still want to start writing, you can start writing type signatures first.
12:35:20 <litb> Kilo Lines of Thinking :)
12:35:37 <byorgey> but what if you think in circles?
12:35:38 <kmcallister> monochrom, yes, but you usually end up revising them until you know what you're doing
12:35:45 <monochrom> Writing type signatures help you think up the rest.
12:36:00 <kmcallister> i find that figuring out the right set of types to use is most of the work
12:36:01 <faxlore> I sometimes write type signatures and hide the function :|
12:36:15 <litb> byorgey: peoples thinking in circles don't make process.
12:36:15 <faxlore> well only occasionally, but when the type describes it better than the code
12:36:30 <byorgey> litb: hm, true... ok, a helix then =)
12:36:40 <monochrom> Here is another one. You can write the haddock first.
12:37:25 <monochrom> Oooh grahamhutton is here!
12:37:36 <grahamhutton> hi!
12:37:49 <faxlore> Hello
12:37:52 <monochrom> grahamhutton: What happened to Catherine Hope's thesis?
12:38:12 <grahamhutton> final revisions are currently being made now
12:39:01 <dcoutts> grahamhutton: btw, we were noting earlier that the education pages on haskell.org need updating, it looks like the entry about your course needs updating too
12:39:20 <dcoutts> http://haskell.org/haskellwiki/Haskell_in_education
12:39:24 <grahamhutton> indeed --- i think it still has bird/wadler as the recommended text :-)
12:39:31 <dcoutts> quite :-)
12:39:34 <Cale> hehe, also, someone was having problems with the DRM on your e-book the other day. :)
12:39:52 <grahamhutton> yes, i have corresponded with him about that already by email.
12:40:06 <grahamhutton> there's nothing i can do to help, unfortunately.
12:40:26 <dcoutts> that page could do with a link to the haskell books too, for those usable as course texts
12:40:48 <grahamhutton> sounds like a volunteer for updating it to me!
12:41:44 <litb> byorgey: you beat me :)
12:41:49 <dcoutts> grahamhutton: I'll add the link to http://haskell.org/haskellwiki/Books#Textbooks but I don't know enough to update the entry about your course
12:42:14 <grahamhutton> i was just meaning the books part (i'll of course update my own course entry)
12:43:52 <gwern> @src zipWith
12:43:52 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:43:52 <lambdabot> zipWith _ _      _      = []
12:44:21 <gwern> ah! I lost that bet :(
12:44:26 <gwern> I was betting it was defined using zip and uncurry
12:44:34 <faxlore> :t zip
12:44:39 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:44:58 <Saizan> ?src zip
12:44:58 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:44:58 <lambdabot> zip _      _      = []
12:45:01 <faxlore> > let zipWith f = map (uncurry f) in zipWith (+) [1,2,3] [3,4,5]
12:45:03 <lambdabot>  Couldn't match expected type `[t1] -> t'
12:45:11 <faxlore> oops..
12:45:14 <faxlore> > let zipWith f = map (uncurry f) . zip in zipWith (+) [1,2,3] [3,4,5]
12:45:15 <lambdabot>  Couldn't match expected type `[(a, b)]'
12:45:35 <faxlore> gwern how?
12:45:53 <resiak> > let zipWith f xs ys = map (uncurry f) $ zip xs ys in zipWith (+) [1..3] [3..5]
12:45:55 <gwern> ie map (uncurry (+)) $ zip list1 list2
12:46:02 <lambdabot>  [4,6,8]
12:46:03 <idnar> @pl \f as bs -> map (uncurry f) (zip as bs)
12:46:03 <lambdabot> (. zip) . (.) . map . uncurry
12:46:05 <gwern> would be equivalent to zipWith (+) list list2
12:46:05 <gwern> right?
12:46:15 <Saizan> > let zipWith f = (map (uncurry f) .) . zip in zipWith (+) [1,2,3] [3,4,5]
12:46:15 <lambdabot>  [4,6,8]
12:46:16 <idnar> @pl \as bs -> map (uncurry f) (zip as bs)
12:46:17 <lambdabot> zipWith f
12:46:21 <idnar> aww, too clever
12:46:28 <faxlore> let zipWith f left right = map (uncurry f) (zip left right) in zipWith (+) [1,2,3] [3,4,5]
12:46:52 <faxlore> zip = zipWith id
12:47:01 <Saizan> no
12:47:07 <Saizan> zipWith (,)
12:47:38 <gwern> :t sum2lists = zipWith (+)
12:47:39 <lambdabot> parse error on input `='
12:48:25 <dcoutts> bringert, dons: I've committed large refactoring in cabal-install, please be on the look out for regressions
12:49:44 <BMeph> faxlore: map = zipWith1
12:49:46 <BMeph> ;)
12:49:49 <faxlore> haha
12:50:08 <BMeph> With zipWith being zipWith2, that is.
12:50:38 <faxlore> oh can I define a zipWithN whoes type depends on the type of it's first parameter?
12:50:53 <faxlore> e.g. zipWithN id :: [a] -> [a]
12:51:07 <faxlore> zipWithN (,) :: [a] -> [b] -> [(a,b)]
12:51:10 <grahamhutton> @users
12:51:11 <lambdabot> Maximum users seen in #haskell: 444, currently: 435 (98.0%), active: 23 (5.3%)
12:51:36 <idnar> @pl \f xs -> zipWith (f . fst) xs [1..]
12:51:36 <lambdabot> flip flip [1..] . zipWith . (. fst)
12:51:40 <gwern> http://www.daniweb.com/forums/post508050.html#post508050 <-- is this a good response to this problem?
12:51:51 <idnar> @pl \f xs -> zipWith (f . fst) xs (repeat undefined)
12:51:52 <lambdabot> flip flip (repeat undefined) . zipWith . (. fst)
12:51:57 <idnar> heh
12:52:05 <byorgey> faxlore: no
12:52:13 <idnar> hmm wait, that makes no sense
12:52:22 <idnar> @pl \x y -> y
12:52:22 <lambdabot> const id
12:52:42 <twanvl> faxlore: you would also have zipWithN (,) :: [a] -> [b -> (a,b)]
12:53:00 <idnar> @pl \f xs -> zipWith (const id f) (repeat undefined) xs
12:53:00 <lambdabot> flip zipWith (repeat undefined) . const id
12:53:23 <idnar> > let map f xs = zipWith (const id f) (repeat undefined) xs in map (+1) [1..5]
12:53:23 <faxlore> twanvl:  true
12:53:25 <lambdabot>  Undefined
12:53:53 <idnar> :t const id ?f
12:53:55 <lambdabot> forall a. (?f::b) => a -> a
12:54:32 <idnar> @pl \f -> (\a b -> f a)
12:54:32 <lambdabot> (const .)
12:54:34 <idnar> @pl \f -> (\a b -> f b)
12:54:34 <lambdabot> const
12:54:44 <gwern> maybe you could have zipWithN :: [[a] -> (a -> a -> c) -> [c]?
12:54:48 <idnar> > let map f xs = zipWith (const f) (repeat undefined) xs in map (+1) [1..5]
12:54:49 <lambdabot>  [2,3,4,5,6]
12:54:56 <gwern> or, er, function then list of lists
12:55:01 <idnar> @pl \f xs -> zipWith (const f) (repeat undefined) xs
12:55:02 <lambdabot> flip zipWith (repeat undefined) . const
12:59:10 <litb> readList "[1, 2, 3]" , how can i say that the type variable a of it is Int ?
12:59:36 <Saizan> gwern: i'd have mentioned that foo l = head l ... tail l is best written as foo (x:xs) = x ... xs
12:59:50 <byorgey> litb: if it's in a context where the result must be [Int]
12:59:52 <idnar> > readList "[1, 2, 3]" :: [Int]
12:59:53 <lambdabot>  Couldn't match expected type `Int'
12:59:59 <faxlore> > readList "[1, 2, 3]" :: [([Int],String)]
13:00:09 <lambdabot>  [([1,2,3],"")]
13:00:09 <nelhage> :t readList
13:00:10 <idnar> oh, yeah
13:00:11 <lambdabot> forall a. (Read a) => String -> [([a], String)]
13:00:19 <faxlore> > read "[1, 2, 3]" :: [Int]
13:00:20 <lambdabot>  [1,2,3]
13:00:28 <litb> ah, nice. thanks
13:00:39 <litb> haven't thought about that
13:00:48 <faxlore> > [1,2,3]
13:00:49 <lambdabot>  [1,2,3]
13:01:27 <litb> hpwever, i find it quite strange that there is some stuff after the list.
13:01:35 <faxlore> > readList "[1, 2, 3] floggle woggle" :: [([Int],String)]
13:01:36 <lambdabot>  [([1,2,3]," floggle woggle")]
13:01:45 <litb> yeah, that's weird
13:01:48 <faxlore> Why?
13:01:52 <grahamhutton> dcoutts: many thanks for updating the education page; i've updated the notts courses there
13:01:58 <litb> i could easily add it myself with ++
13:02:04 <gwern> Saizan: oh, yeah, I meant to write a pttern-matching version
13:02:04 <gwern> thanks for reminding me
13:02:06 <dcoutts> grahamhutton: np
13:02:07 <faxlore> litb: I don't understand
13:02:11 <byorgey> litb: it's for building simple parsers.
13:02:14 <faxlore> How would you know where to cut it off?
13:02:22 <byorgey> litb: the String part is for whatever's left over after reading a list.
13:03:46 <Saizan> gwern: if you're going to repost don't forget a link to yaht or the wikibook :)
13:04:37 <gwern> > let sum2lists [x:xs] [y:ys] = (x + y) : sum2lists [xs] [ys] in sum2lists [1..10] [1..10]
13:04:38 <lambdabot>   add an instance declaration for (Num [t])
13:04:38 <lambdabot>     In the expression: 10
13:04:55 <faxlore> @hoogle (x -> y -> z -> e) -> (x, y, z) -> e
13:04:56 <lambdabot> No matches, try a more general search
13:05:00 <faxlore> ?djinn (x -> y -> z -> e) -> (x, y, z) -> e
13:05:01 <lambdabot> f a (b, c, d) = a b c d
13:05:07 <monochrom> [x:xs] is very confused
13:05:45 <litb> byorgey: ah, i see now
13:05:55 <monochrom> (Why is it not (x:xs)?)
13:05:57 <MyCatVerbs> @hoogle (a->b) -> (a,c) -> b
13:05:58 <lambdabot> No matches, try a more general search
13:06:05 <MyCatVerbs> @hoogle (a->b) -> (a,c) -> d
13:06:06 <lambdabot> No matches, try a more general search
13:06:11 <faxlore> @hoogle (x -> y -> e) -> (x, y) -> e
13:06:12 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
13:06:12 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
13:06:37 <monochrom> They are the same uncurry.
13:06:38 <twanvl> ?type (.fst)
13:06:46 <lambdabot> forall c a b. (a -> c) -> (a, b) -> c
13:07:09 <kmcallister> ?type (fst.)
13:07:11 <lambdabot> forall a b a1. (a1 -> (a, b)) -> a1 -> a
13:07:22 <MyCatVerbs> @hoogle (a->b) -> (a,c) -> (b,c)
13:07:26 <lambdabot> No matches, try a more general search
13:07:37 <kmcallister> ?type (&&&)
13:07:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:07:46 <faxlore> :t flip . concatMap
13:07:47 <MyCatVerbs> Hrmn. I thought there was a function like mapFst?
13:07:47 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[b1]'
13:07:47 <lambdabot>     In the second argument of `(.)', namely `concatMap'
13:07:51 <kmcallister> ?type first
13:07:52 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:08:04 <faxlore> :t flip concatMap
13:08:04 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
13:08:24 <faxlore> :t (>>=)
13:08:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:09:11 <monochrom> MyCatVerbs: djinn can write the code for (a->b) -> (a,c) -> (b,c)
13:09:34 <faxlore> ?where lambdabot
13:09:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:09:45 <kmcallister> ?djinn (a->b) -> (a,c) -> (b,c)
13:09:46 <lambdabot> f a (b, c) = (a b, c)
13:09:48 <MyCatVerbs> monochrom: this is true.
13:10:02 * faxlore is wondering how djinn works
13:10:19 <monochrom> It does propositional logic proof.
13:10:24 <faxlore> how?
13:10:27 <MyCatVerbs> monochrom: just wondered if it was in the standard libraries somewhere - I don't want to make up a new name for something that already has an agreed-upon name.
13:10:28 <gwern> Saizan: slow connection, didn't see your message
13:10:40 <MyCatVerbs> faxlore: term unification, probably.
13:10:47 <byorgey> MyCatVerbs: maybe you're thinking of 'first'?
13:11:07 <faxlore> heh heh "Djinn has proven to be much fun on #haskell."
13:11:21 <Saizan> i've seen mapFst defined more than once
13:11:22 <byorgey> MyCatVerbs: kmcallister showed its type above
13:11:23 <MyCatVerbs> byorgey: hrmn? I'm just throwing an ([Foo],Sum Integer) into a ([Foo],Integer)
13:11:38 <idnar> @djinn (a->b) -> (a,c) -> d
13:11:41 <lambdabot> -- f cannot be realized.
13:11:57 <monochrom> Pretend (a,b) is "a and b", Either a b is "a or b", a->b is "a implies b".  Disallow recursion.  Then you get propositional logic.  Type sigs are statements, programs are proofs. It is well-known that propositional logic is completely automated, no "intelligence" necessary.
13:12:02 <byorgey> MyCatVerbs: I'm confused.  what's the type of the function you're looking for?
13:12:36 <nelhage> Does @djinn grok Either's?
13:12:37 <monochrom> MyCatVerbs: mapFst not in standard library.
13:12:41 <faxlore> using unification?
13:12:57 <idnar> @djinn Either Int String -> String
13:12:57 <monochrom> @djinn (a,b) -> Either a b
13:12:57 <lambdabot> -- f cannot be realized.
13:12:58 <lambdabot> f (a, _) = Left a
13:13:08 <idnar> er, I guess that made no sense
13:13:25 <nelhage> @djinn Either a b -> Maybe a
13:13:26 <lambdabot> f a =
13:13:26 <lambdabot>     case a of
13:13:26 <lambdabot>     Left b -> Just b
13:13:26 <lambdabot>     Right _ -> Nothing
13:13:38 <MyCatVerbs> byorgey: (a->b) -> (a,c) -> (b,c)
13:13:42 <nelhage> Cool.
13:14:09 <faxlore> ?djinn Either (a->x) (b->y) -> Either b a -> Either x y
13:14:10 <lambdabot> -- f cannot be realized.
13:14:11 <MyCatVerbs> byorgey: I'm just writing (mapSnd getSum) . runWriter $ -- some stuff in the Writer Sum monad.
13:14:21 <byorgey> MyCatVerbs: yes, that is 'first' for the (->) instance of Arrow
13:14:29 <faxlore> ?djinn (Either b a) -> (Either (a -> x) (b -> y)) -> (Either x y)
13:14:30 <idnar> :t first
13:14:30 <lambdabot> -- f cannot be realized.
13:14:31 <byorgey> > first (+1) (4,6)
13:14:32 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:14:32 <lambdabot>  (5,6)
13:14:32 <faxlore> :(
13:14:39 <faxlore> Why can't djinn do that?
13:14:40 <dcoutts> @seen dons
13:14:41 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 19m 1s ago.
13:14:41 <kmcallister> f cannot be realized <=> the type of f corresponds to a false logical statement
13:14:46 <kmcallister> by curry howard
13:14:47 <MyCatVerbs> byorgey: oh, awesome.
13:14:50 <faxlore> (Either b a) -> ((a -> x), (b -> y)) -> (Either x y)
13:14:53 <faxlore> ?djinn (Either b a) -> ((a -> x), (b -> y)) -> (Either x y)
13:14:54 <lambdabot> f a =
13:14:54 <lambdabot>     case a of
13:14:54 <lambdabot>     Left b -> \ (_, c) -> Right (c b)
13:14:54 <lambdabot>     Right d -> \ (e, _) -> Left (e d)
13:15:07 <MyCatVerbs> faxlore: have you ever played with Prolog? :)
13:15:10 <MyCatVerbs> :t first
13:15:11 <faxlore> Yes
13:15:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:15:19 <faxlore> What has Howard done?
13:15:21 <dcoutts> dons: you were talking about testing and hackage, I think it should be fairly easy to extend cabal-install to generate simple build reports for all packages it builds
13:15:41 <dcoutts> hia ndm
13:15:58 <dcoutts> dons: if you're looking at the hackagedb side of things would you like to think about how hackage might accept, store and use the information
13:16:03 <ndm> hi dcoutts
13:16:03 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:16:07 <faxlore> http://en.wikipedia.org/wiki/William_Alvin_Howard
13:16:08 <lambdabot> Title: William Alvin Howard - Wikipedia, the free encyclopedia
13:16:09 <MyCatVerbs> faxlore: oh awesome. The way Prolog (ignoring cuts here) works is an algorithm called unification, jah?
13:16:11 <ndm> @messages
13:16:11 <lambdabot> dcoutts asked 2h 35m 56s ago: if you have any influence in hugs development, please please please add a --version flag (from Cabal's pov hugs is totally unversioned)
13:16:11 <lambdabot> dcoutts said 2h 35m 16s ago: and in hugs, System.Info.compilerVersion = Version [0,0] [] :-)
13:16:26 <MyCatVerbs> faxlore: Haskell's type inference also works by unification. I presume Djinn does, too.
13:16:35 <faxlore> I am looking at djinn code @_@
13:16:46 <ndm> dcoutts: Ross is the one with power over Hugs, but I was going to head back to Hugs development later this week, or early next, to get a Cabal 1.2 Windows binary out
13:16:48 <kmcallister> it's basically a theorem prover, yes?
13:16:50 <MyCatVerbs> Yeah, it's probably scary. Prolog implementations are. :P
13:16:56 <dcoutts> dons: then we could have people turn on reporting in their ~/.cabal/config files and run cabal install --absolutely-everything and get loads of build/platform data
13:16:57 <ndm> since you can't upgrade Cabal with Hugs :(
13:17:00 <ndm> (CPP issues)
13:17:03 <faxlore> it doesn't look like a prolog..
13:17:10 <ndm> dcoutts: does Hugs have any command line flags?
13:17:18 <dcoutts> ndm: a few, like -98
13:17:19 <ndm> dcoutts: you should probably file Hugs bugs about those things
13:17:27 <faxlore> http://www.augustsson.net/Darcs/Djinn/
13:17:28 <lambdabot> Title: Index of /Darcs/Djinn
13:17:29 <dcoutts> does it have a bug tracker?
13:17:31 <ndm> dcoutts: any which cause it to output and stop, rather than continue
13:17:40 <dcoutts> ndm: none that I know of
13:17:42 <ndm> dcoutts: yep, but i should warn you, it uses crap bug tracking software
13:17:44 * monochrom laughs at certain presumptions behind the open-source idea.
13:18:09 <faxlore> Proof monad..
13:18:14 <roconnor> How do you do Void data types?
13:18:17 <roconnor> data Void =
13:18:21 <roconnor> ?
13:18:26 <faxlore> data Void
13:18:32 <ndm> dcoutts: http://hackage.haskell.org/trac/hugs - was actually a lot harder to find that it should have been
13:18:33 <faxlore> and you need a -X flag.. forot which
13:18:33 <lambdabot> Title: Hugs - Trac
13:18:34 <monochrom> A GHC extension allows "data Void".
13:18:36 <kmcallister> and it's not haskell 98
13:18:40 <kmcallister> -fglasgow-exts in GHC
13:18:42 <dcoutts> ndm: some cause it to try to load and then fail, like --help :-)
13:18:54 <ndm> dcoutts: perhaps mark that one as a bug too!
13:18:55 <monochrom> Another GHC extension allows "data Void = (forall a. a)". Just as good.
13:19:17 <faxlore> monochrom, is that not quite a different thing?
13:19:43 <monochrom> Without extensions, you can write "data Void = Whatever" and just try not to use Whatever.
13:19:49 <MyCatVerbs> monochrom: existential types, right?
13:20:06 <ndm> moconnor: or put it in a separate module, and not export it - just as good
13:20:13 <monochrom> Correction. data Void = Void (forall a. a)
13:20:25 <monochrom> Rank-2 type.  Non existential.
13:20:26 <ndm> moconnor: (sorry, meant monochrom)
13:20:31 <moconnor> that's ok
13:20:55 <faxlore> is (forall a. a) equivalent to Void?
13:21:13 <kmcallister> no
13:21:19 <faxlore> What does it mean?
13:21:20 <kmcallister> there are values of type forall a. a
13:21:25 <kmcallister> ?t error "foo"
13:21:26 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:21:30 <kmcallister> :t error "foo"
13:21:32 <lambdabot> forall a. a
13:21:36 <faxlore> ah.. I see
13:21:44 <monochrom> The only value of forall a. a is _|_
13:21:54 <monochrom> The only value of "data Void" is also _|_.
13:21:59 <sjanssen> monochrom: data Void; and data Void = Void (forall a. a) aren't the same
13:22:16 <monochrom> djinn ignores _|_. It has no error, no undefined, no recursion.
13:22:26 <sjanssen> monochrom: there is a non-bottom value in the second, Void _|_
13:22:40 <monochrom> Oh I see what you mean.  newtype Void = Void (forall a. a)
13:22:50 <Saizan> ?djinn Void -> a
13:22:50 <lambdabot> f = void
13:23:15 <monochrom> I honestly had newtype rather than data when I first played with that!
13:23:25 <kmcallister> what about data Void = Void !(forall a. a)
13:23:41 * gwern adds them. OK, I have now spent enough time on that! :)
13:23:41 <gwern> he'd *better* appreciate my reply. or else
13:24:10 <kmcallister> that has only _|_, yes?
13:24:44 <faxlore> MyCatVerbs, Where is the unification?
13:24:54 <faxlore> I cant' understand this code :S
13:27:57 <MyCatVerbs> faxlore: no clue. I was only guessing, on the basis that term unification is the most common way of solving those kinds of problems.
13:28:12 <kmcallister> MyCatVerbs, i think it's more like goal directed search
13:28:20 <kmcallister> without having actually seen the code
13:28:54 <MyCatVerbs> kmcallister: see, that's the problem with randomly guessing. :)
13:28:59 <kmcallister> yeah :)
13:29:09 <ndm> dcoutts: i've just seen your bug report shoot past
13:29:23 <dcoutts> ndm: good good
13:29:34 <faxlore> > let e:es = [1,2,3] in e
13:29:36 <lambdabot>  1
13:29:53 <ndm> dcoutts: i may implement that, if i'm feeling nice
13:30:03 <dcoutts> ndm: ta :-)
13:30:08 <ndm> dcoutts: although if you've ever seen the Hugs code base, you'd realise why i'm slightly reluctant...
13:30:14 <dcoutts> ndm: btw, what should we do about the cabal/cpp stuff?
13:30:39 <dcoutts> ndm: heh heh, this one should be easy though, it's really early in command line parsing
13:31:09 <ndm> dcoutts: no idea! my suggestion would be a new Hugs release, sharpish, so we can use most libraries
13:31:28 <ndm> dcoutts: i seem to remember the command line args get parsed in a way which i'd describe as "bizare"...
13:31:37 <dcoutts> ndm: nice :-)
13:32:01 <MyCatVerbs> ndm: that's a good thing.
13:32:08 <MyCatVerbs> ndm: keep the bastards on their toes.
13:33:21 <faxlore> oh right
13:33:22 <faxlore> Decision procedure for intuitionistic propositional logic
13:33:27 <ndm> MyCatVerbs: my toes have cramp :)
13:33:30 <faxlore> seems Djinn is based on http://www.dcs.st-and.ac.uk/~rd/logic/nonmac/LJT.pl.html
13:33:32 <lambdabot> Title: Intuitionistic Theorem Prover
13:36:01 <MyCatVerbs> ndm: heh.
13:36:08 <MyCatVerbs> Snappy. ^_^
13:37:53 <faxlore> say you have
13:37:58 <faxlore> a -> (a -> b) -> b
13:38:09 <faxlore> What would you unify, to generate a lambda term for thAt?
13:40:24 <dons> http://programming.reddit.com/info/654xq/comments/
13:40:24 <monochrom> I unify a with a->b
13:40:31 <dons> 'Why you should use Haskell for your next domain specific language'
13:40:39 <kmcallister> prove t :: a -> (a -> b) -> b: [assume t1 :: a, prove t2 :: (a -> b) -> b: [assume t3 :: a -> b, prove t4 :: b: apply t1 to t3]]
13:40:57 <kmcallister> err t3 to t1
13:41:17 <roconnor> @go unicode minus
13:41:18 <lambdabot> http://www.fileformat.info/info/unicode/char/2212/index.htm
13:41:18 <lambdabot> Title: Unicode Character 'MINUS SIGN' (U+2212)
13:41:52 <faxlore> kmcallister: Is this agoal directed method?
13:42:01 <MyCatVerbs> @go unicode snowman
13:42:02 <lambdabot> http://www.flickr.com/photos/chucker/73239007/
13:42:02 <lambdabot> Title: Snowman in Unicode on Flickr - Photo Sharing!
13:42:11 <kmcallister> yeah, at least i would call it that
13:42:22 <kmcallister> theorem provers are not my field of experience but i know some basic things
13:42:54 <roconnor> is there a unicode caracter for absolute value bars?
13:43:01 <roconnor> @go unicode absolute-value
13:43:03 <lambdabot> http://everything2.net/index.pl?node_id=482632
13:43:03 <lambdabot> Title: absolute value@Everything2.com
13:43:53 <monochrom> goal-directed proving works well for this problem type.
13:45:25 <faxlore> How can you solve the same problem using unification?
13:47:04 <faxlore> ?djinn (a -> a) -> a
13:47:06 <lambdabot> -- f cannot be realized.
13:47:10 <faxlore> @hoogle (a -> a) -> a
13:47:10 <lambdabot> Data.Function.fix :: (a -> a) -> a
13:47:10 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
13:47:10 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
13:47:14 <monochrom> Actually I don't see how to use unification.
13:49:06 <monochrom> Except the trivial case of unifying something in the goal with one of the antecedent of an axiom, but that's part of doing goal-directed proof.
13:51:57 <Cheery> hmm.. memory is and has always been a scarce resource.. thought that wouldn't be true with infinite memory, right?
13:52:17 <Corun> Damn, I could do with some infinite memory
13:52:28 <monochrom> Is memory a scarce resource?
13:52:59 <Cheery> Corun: I too, you wouldn't need to garbage collect that
13:53:00 <Corun> 229M wired, 1191M active,  597M inactive, 2017M used,   23M free.
13:53:05 <Corun> Guess it's scarce,
13:53:14 <Cheery> also.. you wouldn't need to delete anything
13:53:29 <_alf_> quantum computers have infinite memory
13:53:35 <_alf_> they just forget all but one value upon read
13:54:27 <sarehu`> even with infinite memory, you still want good caching
13:54:30 <monochrom> omega-infinite memory is a scarce resource if you need omega^omega infinite.
13:54:44 <markluffel> _alf_: can we file a bug report for that?
13:55:01 <Cheery> I wonder whether that's possible
13:55:02 <_alf_> someone should
13:55:04 <MyCatVerbs> monochrom: ...what? Are both uncountable infinite sets, only one of which can be injectively mapped to the other or something?
13:55:08 <Cheery> to have infinite memory
13:55:25 <Cheery> _alf_: who would you file a bug report to?
13:55:38 <monochrom> They are both countable. But countable is beside the point. They are ordinals.
13:56:02 <_alf_> "god"... for having reads destroy quantum state
13:56:08 <MyCatVerbs> monochrom: I thought all countable infinities had the same cardinality as the natural numbers? Or have I missed somethin?
13:56:13 <MyCatVerbs> *something
13:56:24 <_alf_> MyCatVerbs: no, {1}, {1, 2} are both countable
13:56:31 <sarehu> 'infinities'
13:56:32 <MyCatVerbs> Cheery: presumably not, since it would involve brutalising the shit out of the laws of thermodynamics.
13:56:33 <_alf_> oh INFINITIES
13:56:35 <_alf_> yes
13:56:50 <monochrom> Ordinals are more appropriate than cardinals because when proving program termination you need well-ordering. That's ordinals.  Cardinals tell you nothing.
13:57:26 <faxlore> you can prove any first order logic theorem with unification?
13:57:35 <monochrom> So much for a "unifying" notion of infinite.
13:57:37 <RogerLike> hey
13:57:37 <MyCatVerbs> faxlore: AFAIK, yes.
13:57:46 <faxlore> how? :D
13:57:49 <faxlore> I want to try and write ths
13:58:29 <MyCatVerbs> faxlore: I mean "yes if I understood what you just said correctly", not "yes I know how". ;)
13:58:45 <litb> the things explained in yaht. how much percent of the language does it coverß
13:58:47 <litb> ?
13:58:55 <Botje> litb: enough to be dangerous
13:58:57 <monochrom> Look for resolution proofs and tableau proofs.
13:59:05 <MyCatVerbs> litb: pretty much all of Haskell98, none of the extensions.
13:59:28 <monochrom> http://www.umsu.de/logik/trees/ shows tableau proofs.
13:59:29 <lambdabot> Title: Tree Proof Generator
13:59:35 <MyCatVerbs> faxlore: easiest way, AFAIK, would be to pick up a copy of "The Art of Prolog", since that book attempts to teach Prolog by first teaching the student how to implement Prolog. :)
13:59:49 <monochrom> The proof engine is in javascript. Runs on your computer, not on the remote server.
13:59:55 <MyCatVerbs> faxlore: I can remember enough of it to use Prolog a little, but unfortunately not enough to implement it. Oh well.
13:59:57 <Cheery> MyCatVerbs: yep, but if there are civilizations far more exceeded than ours, they are highly virtual
14:00:08 <faxlore> Prolog is not a theorem prover
14:00:15 <faxlore> It's just very close
14:00:27 <luqui> how do I import Splittable?
14:00:45 <Cheery> I wonder whether they really just disappear by finding an infinite medium of some sort, or do they begin growing out of bounds in physical reality?
14:02:19 <Cheery> ie. is it even possible that life in one area ever encounters the another?
14:02:33 <MyCatVerbs> faxlore: s'pose so. But that's the quickest stepping stone to getting a working theorem prover that I know of, short of downloading someone else's. ¬_¬
14:02:48 <Cheery> Space travelling seem to be really hard and maybe even nonsense if you'd have space where to extend of your own
14:02:55 <luqui> prolog only proves propositions in Sigma_1
14:02:59 <monochrom> unsafePerformIO is how life in one area encounters another
14:03:11 <faxlore> It's unsound, incomplete and doesn't display proofs
14:03:24 <FunctorSalad> "im in ur #haskell, discussing philosophy" day again? =)
14:04:03 <luqui> my philosophy discussion tolerance has built up since that cafe thread.
14:04:40 <monochrom> Then it's time to start an evolution vs intelligent design thread.
14:04:46 * Cheery is imagining things that actually live in a place like those old MUDS where you could've modified the place without limitations
14:04:54 <Pseudonym> monochrom: What's there to disagree about?
14:04:59 <monochrom> I believe in intelligent design of computer programs. Not evolution.
14:05:07 <Pseudonym> Is the Matrix written in Fortran or Haskell?
14:05:24 * Corun goes to evolve some intelligent design, just to confuse people
14:05:27 <luqui> evolutionary algorithms = unintelligent design of evolution...
14:05:44 <Cheery> :P
14:05:45 <Pseudonym> On the contrary, software development is incremental and evolutionary in the real world.
14:05:47 <FunctorSalad> monochrom: humans couldn't evolve by random chance! (how to tell that I'm kidding without ruining the joke?)
14:05:51 <Pseudonym> Big Design Up Front is rare.
14:06:04 <monochrom> Pseudonym: Now we have a disagreement :)
14:06:06 <Pseudonym> Unless it's something safety-critical, of course.  But that's another story.
14:06:08 <jonafan> probably haskell
14:06:10 <luqui> FunctorSalad, heheh took me a little while
14:06:32 <Korollary> Big design up front may work provided that you rest on days divisible by seven
14:06:33 <luqui> monochrom, *successful* Big Design Up Front is rare?
14:06:45 <jonafan> it seems like a simulation of that nature would require haskell's lazy evaluation
14:06:49 <Pseudonym> luqui: Tht's probably more accurate.
14:06:52 <FunctorSalad> luqui: didn't dare to only say "I'm kidding" a few seconds later.
14:06:57 <monochrom> It's a stupid disagreement because software "evolution" is not biological "evolution".
14:06:59 <MyCatVerbs> monochrom: I take it you've never tried genetic programming? :)
14:07:17 <luqui> so, anyway, i actually do have a haskell question, in spite of this silliness
14:07:24 <luqui> how do I get at Splittable?
14:07:31 <Pseudonym> monochrom: That's true in the sense that mutations to software, while equally random, are indeed performed by semi-intelligent agents.
14:07:33 <jonafan> good question
14:07:36 <jonafan> i bet they would know in #haskell
14:07:46 <Cheery> isn't the ID vs. evolution something that's been verified already for evolution with the today's hardware?
14:07:52 <monochrom> Mutations to software is far from random.
14:08:05 <Pseudonym> monochrom has never tutored first year students, clearly.
14:08:17 <_alf_> i dunno, cosmic ray muons tend to flip bits... especially as ram gets smaller
14:08:58 <monochrom> I have. But I thought you wanted to talk about the real world, not toy students.
14:09:11 <Pseudonym> OK, fair enough.
14:09:15 * luqui has worked in the game industry.  real world = toy students.
14:09:26 <Pseudonym> The mutations are _kind_ of random.
14:09:54 <Pseudonym> Compiler analysis, unit tests and so on are evolutionary pressures to shape the mutations.
14:09:57 <Cheery> anyway, the results with evolving computer programs have shown that in chaos and need to stay within bounds of some conditions, there happens very weird things on those programs
14:09:57 <luqui> excuse me, that was imprecise.  the set of toy students is cofinite in the real world.
14:10:10 <luqui> (of game dev)
14:10:21 <Cheery> that are hard to understand
14:10:42 <Cheery> like. how does a program evolve virus-behavior?
14:11:19 <FunctorSalad> what's a "toy student"?
14:11:36 <FunctorSalad> Cheery: programs that have virus-behavious survive? ;)
14:11:37 <luqui> informally, a programmer who programs by random mutation
14:11:39 <dons> ?users
14:11:39 <lambdabot> Maximum users seen in #haskell: 444, currently: 438 (98.6%), active: 25 (5.7%)
14:11:42 <FunctorSalad> *behaviour
14:11:43 <dons> new high score.
14:11:58 <FunctorSalad> dons: it seemed to be broken the other day
14:12:08 <Cheery> FunctorSalad: that behavior has an another name, it's about benefitting from each other
14:12:12 <random> MyCatVerbs: so, did you do something interesting with genetic programming?
14:12:23 <monochrom> If Microsoft used biological-kind evolution to brew Windows....
14:12:34 <monochrom> We would all be happily using Linux now. :)
14:12:58 <monochrom> Biological-kind evolution is very slow. It works, but it's very slow.
14:12:59 <luqui> therefore... microsoft used biological-kind evolution to brew windows.  no wait, that's a fallacy..
14:13:06 <Cheery> FunctorSalad: thought that's an another even more complex behavior that you can even less explain
14:13:08 <Pseudonym> monochrom: That's only because of the slow turn-around time.
14:13:25 <luqui> (in other words, monochrom, remember what channel you're in)
14:13:36 <Pseudonym> In bacteria, where "generations" can be measured in minutes, evolution can be faster.
14:13:51 <luqui> isn't generations usually measured in naturals?
14:13:54 <FunctorSalad> Cheery: I don't quite get what you are saying. "virus-like behaviour = benefitting from each other"?
14:14:06 <Pseudonym> How often do you invoke your compiler in a given day?
14:14:10 <Cheery> luqui: microsoft has done that only if they have plugged their marketting androids to the source code filesystem
14:14:11 <Pseudonym> Quite a lot, in my case.
14:14:13 <znutar> luqui: not if you get to really rural areas
14:14:25 <FunctorSalad> Pseudonym: it's only because of lack of planning I think
14:14:31 <CosmicRay> Cheery: huh, I thought that has been going on since about 1985
14:14:36 <sjanssen> dons: quite a debate we've started at http://programming.reddit.com/info/653nl/comments :)
14:14:36 <FunctorSalad> local minima and all that
14:14:37 <luqui> znutar, I get the feeling that was funny, but I don't get it
14:14:45 <CosmicRay> Cheery: it's the only plausible explanation for vista
14:14:53 <luqui> znutar, I get it
14:14:54 <sjanssen> btw, does reddit user steveAR hang out here?
14:15:03 <luqui> :-)
14:15:04 <dons> i don't know who that is.
14:15:07 <MyCatVerbs> random: no, but it sounded like a good thing to interject with.
14:15:19 <znutar> :-)
14:15:25 <random> MyCatVerbs: ........
14:15:25 <Pseudonym> FunctorSalad: It's also because I'm an aggressive programmer.
14:15:33 <luqui> third time's a charm.... in which module is Splittable located?
14:15:33 <Pseudonym> In the Weinberg sense.
14:15:36 <Cheery> FunctorSalad: no, benefitting from each other has some another name, but it reminds me sort of from viruses that have interwined
14:15:47 <Cheery> *intertwined
14:15:53 <monochrom> Gosh, Why is everyone interested in my pointfree little note!
14:16:18 <FunctorSalad> Pseudonym: I meant biological evolution is slowed down by lack of planning... tough maybe you were joking now :)
14:16:31 <Pseudonym> Ah. :-)
14:16:33 <Pseudonym> Sorry.
14:16:45 <faxlore> @report
14:16:45 <lambdabot> ()
14:16:48 <Cheery> like. program #1 contains function X, program #2 contains function Y, both X and Y are required to survive, so those programs have co-operation routine
14:16:51 <faxlore> oh thank you!
14:16:59 <Pseudonym> Biological evolution is slowed down mostly by lack of turn-around time, combined with the fact that extinction is always an option.
14:17:10 <Pseudonym> Nature doesn't care.
14:17:12 <FunctorSalad> Cheery: "mutualism"?
14:17:17 <Cheery> yes
14:17:41 <MyCatVerbs> Cheery: symbiosis?
14:17:42 <faxlore> `foo` is left assoc
14:17:45 <Cheery> I guess they can half the code base, therefore evolved
14:18:00 <Cheery> symbiosis is the word I were looking for!
14:18:27 <FunctorSalad> MyCatVerbs: thought it was "symbiosis" too but some page claimed that that is a general term for different kinds of coexistence and that "mutualism" is if both benefit
14:18:51 <Cheery> in reality, microsoft tries some sort of evolutionary programming with customer feedback, with intervals of five years
14:18:53 <MyCatVerbs> FunctorSalad: oh, handy to know. *pokes google*
14:19:38 <znutar> how is evolutionary programming different from just incremental improvement and testing in this case?
14:19:39 <Pseudonym> They define "customer" oddly, though.
14:19:48 <Pseudonym> And not every evolutionary pressure at Microsoft is from "customers".
14:20:06 <FunctorSalad> MyCatVerbs: ah, second paragraph on http://en.wikipedia.org/wiki/Symbiosis explains that the definition is controversial and your usage might be correct too :)
14:20:06 <lambdabot> Title: Symbiosis - Wikipedia, the free encyclopedia
14:20:22 <Cheery> znutar: in that way that the improvement is such that wouldn't be claimed an Improvement in usual terms
14:21:00 <FunctorSalad> MyCatVerbs: in my feeling symbiosis=mutualism sounds right too
14:21:15 <resiak> I'm looking for a whileM :: [m Bool] -> m (); whileM (a:as) = do { res <- a; when res $ whileM as }.  does this already have a name somewhere?
14:21:59 <FunctorSalad> resiak: until?
14:22:05 <FunctorSalad> though it's not exactly what you want
14:22:08 <resiak> @ty until
14:22:12 <znutar> It just doesn't seem like you can characterize a process as "Evolutionary" in the biological sense unless there's a population of alternatives, the way I read it.
14:22:13 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:22:26 <aFlag> I think symbiosis is one kind of mutualism
14:22:29 <dons> sjanssen: the exaggerations and strawmen are a bit annoying in that discussion
14:22:33 <aFlag> not sure, though
14:22:36 <Cheery> it'd be interesting to try that old thing somebody once did, that he made a simulation where he wrote a program (or was that a coroutine?) that copied itself to random location, and failed instructions were ignored
14:22:41 <dons> sjanssen: i assume it touched a raw nerve
14:22:45 <Pseudonym> Core Wars!
14:22:52 <resiak> FunctorSalad: mmm, the type's not quite right
14:23:18 <Cheery> then just make record routines on that, which would be able to show how different things evolves into those programs
14:23:58 <FunctorSalad> resiak: yes. thought it might be useful but didn't see you were doing sth with monads
14:24:09 <Cheery> ie.. sort of evolution history or something, from repeating patterns at each moment :)
14:24:22 <FunctorSalad> @type when
14:24:23 <resiak> aha!  actually, it doesn't matter if I just ignore failure, so sequence_ works.
14:24:25 <faxlore> @hpaste
14:24:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:24:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:24:44 <hpaste>  faxlore pasted "gensym" at http://hpaste.org/4909
14:24:49 <dcoutts> dons: so are you planning on hacking on the hackage-scripts? want to have a go at this build report stuff?
14:24:53 <faxlore> just wondering, is this sort of thing common?
14:24:56 <faxlore> and is it ok?
14:25:04 <znutar> I always liked that paper from siggraph in 1994 where that guy had evolved virtual creatures that tried to move/swim/do whatever in a dynamics simulation
14:25:05 <dons> dcoutts: yeah, probably over the coming weeks.
14:25:11 <znutar> it was so cool to look at
14:25:12 <dons> dcoutts: bit unclear yet what my time available is
14:25:25 <dcoutts> dons: great, ok, well mine too, I've got a thesis to write
14:25:38 <dcoutts> dons: but I figure hackage QA is one of our biggest problems atm
14:25:52 <dcoutts> dons: so that's what I'll be working on when I do have time
14:25:54 <Saizan> resiak: sequence_ will concatenate the effects of all the m Bool, rather than discard all the ones after the first False
14:27:23 <resiak> Saizan: yeah, i initially wanted to stop once one returns false, but it turns out that ignoring failure and carrying on doesn't really matter
14:27:53 <MyCatVerbs> FunctorSalad: to me, it sounds like too fine a distinction for a lay moron (ie me) to worry about.
14:28:14 <dcoutts> dons: so you do the server side and I'll do the client side :-)
14:28:34 <dons> i'd like to start with a hackage i can test locally. currently its a bit hard to set up.
14:28:42 <dcoutts> dons: yes
14:28:44 <luqui> the answer to my question was GHC.Exts
14:28:47 <dons> baked in filepaths and so on
14:29:06 <dcoutts> dons: ah, a good itch to scratch that'll help other people deploy too
14:29:06 <MyCatVerbs> FunctorSalad: at any rate, for the moment I'm sticking with the definition that I was taught first, namely that symbiosis is mutualism.
14:29:42 <dcoutts> dons: an easy one is to add more QA checks like looking for silly ghc flags, I can add that code in Cabal and you can use it in the hackage upload checks
14:30:33 <dcoutts> dons: and then I think we should ban mutating existing packages, ie uploading the same version again with a different tarball
14:30:40 <dons> definitely
14:30:46 <dons> is that still possible?
14:30:52 <dcoutts> yep, I think so
14:30:53 <luqui> actually apparently not anymore...
14:30:54 <dons> i'd also be interested in warning about versioning issues
14:31:01 <dcoutts> dons: it's a hidden feature :-)
14:31:05 <dons> ah
14:31:13 <dcoutts> dons: what kind of versioning issues?
14:31:19 <Cheery> I wonder what sort of results would I get if I would try to evolve a garbage collection scheme..
14:31:22 <resiak> when implementing Storable for a (type corresponding to a) C struct, how should I figure out the alignment requirement of the struct?
14:31:27 <dons> version numbers that don't follow the spec
14:31:45 <dcoutts> dons: well, they have to parse, I don't think I follow
14:31:45 <dons> warn if haddock doesn't run, also
14:31:49 <dons> ah ok.
14:32:06 <dons> so "Feb-08" isn't valid?
14:32:15 <dcoutts> dons: indeed it is not
14:32:18 <FunctorSalad> MyCatVerbs: agreed. didn't mean to sound like a smartdonkey
14:32:35 <dcoutts> dons: that's tricky since running haddock requires running configure and pre-processors which you probably do not want to do on the server
14:32:54 <dons> yep
14:33:20 <dcoutts> dons: I was thinking in the longer term of a system where newly uploaded packages sit in limbo for a bit until there are a couple successful build reports
14:33:59 <dons> mm. we could type check them in a sand box, i guess
14:34:12 <dcoutts> dons: even that requires pre-processors in general
14:34:43 <dcoutts> dons: and when hackage is really successful we'll not want to bog the server down with doing builds as well as serving
14:35:18 <dcoutts> dons: it should still be possible to automate though, since there is an rss feed so build bots could watch that, fire off builds using cabal-install and report back to the hackage server
14:35:49 <dcoutts> dons: so like making hackage do it itself but more distributed and greater testing platform coverage
14:38:11 * faxlore can prove id and const..
14:38:31 <fowlduck> hmm, k, not really a haskell question, but i know functional languages use recursion a lot.  What are the parts of a recursive method?  I'm trying to write one and I can't find a disection of parts.
14:38:38 <luqui> @src cycle
14:38:39 <lambdabot> cycle [] = undefined
14:38:39 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:38:53 <fowlduck> i've heard people talk about a 'base condition'
14:38:56 <faxlore> fowlduck: base case (P(0)) and inductive case (P(n) assuming P(n-1))
14:39:12 <faxlore> fowlduck: It's exactly the same as proof by induction, you can use the same terms to describe it
14:39:45 <fowlduck> uh yeah, no idea what that meant, but you've given me things to google
14:39:46 <fowlduck> thanks
14:40:23 <dmhouse> fowlduck: see http://en.wikibooks.org/wiki/Haskell/Recursion
14:40:24 <lambdabot> Title: Haskell/Recursion - Wikibooks, collection of open-content textbooks
14:40:30 <litb> hmm: do x <- [1, 2, 3]; y <- [5, 6, 7]; return (x, y)
14:40:36 <fowlduck> dmhouse: Thanks
14:41:32 <faxlore> > do x <- [1, 2, 3]; y <- [5, 6, 7]; return (x, y)
14:41:34 <litb> oh, now i see
14:41:40 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
14:41:53 <litb> it is return :: (Monad m) => a -> m a
14:41:55 <faxlore> litb: I found out the other day..
14:42:03 <faxlore> (>>=) = flip concatMap
14:42:03 <faxlore> :D
14:42:05 <Corun> Hey, ToRA, I didn't come to your lecture today because the slides didn't look like anything I didn't know. But Ralf tells me you were saying stuff about 2-3rd years getting exited about Ruby/Python etc. Milen (if you know him) is one of those. What can I say to him to get him to snap out of it? :-D
14:42:10 <faxlore> in the list monad
14:42:10 <monochrom> faxlore: http://www.cs.toronto.edu/~trebla/fp/lecture-02.pdf may help, the pages towards the end.
14:42:14 <Toxaris> > (,) <$> [1, 2, 3] <*> [5, 6, 7] -- litb, faxlore :)
14:42:15 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
14:42:27 <Toxaris> litb, faxlore: funny syntax for the same thing :)
14:42:31 <monochrom> faxlore: sorry, that was for fowlduck.
14:42:38 <Corun> (I'll come next week!)
14:42:40 <monochrom> fowlduck: http://www.cs.toronto.edu/~trebla/fp/lecture-02.pdf may help, the pages towards the end.
14:42:50 <fowlduck> monochrom: thanks ;)
14:42:59 <litb> ugg
14:43:36 <fowlduck> well, i can't read haskell, i just knew that functional languages depended on it
14:43:38 <litb> how is the return of the class Monad (where [Int] is an instance of) does relate to return?
14:43:55 <Toxaris> litb: there is no other return
14:44:08 <litb> since if i do return (x, y) , is the return of the [] instance called then?
14:44:24 <Toxaris> :t do return (x, y)
14:44:25 <litb> since it is a tuple, i can't think it is
14:44:25 <lambdabot> Not in scope: `x'
14:44:25 <lambdabot> Not in scope: `y'
14:44:33 <Toxaris> :t do return (3, 4)
14:44:36 <lambdabot> forall t t1 (t2 :: * -> *). (Num t, Num t1, Monad t2) => t2 (t, t1)
14:44:46 <drgames> does anybode knows a good IDE for haskell?
14:45:07 <faxlore> drgames: I just use a text editor and ghci in a terminal
14:45:10 <Toxaris> litb: return (x, y) can call whatever return wich makes sense in the context
14:45:14 <faxlore> drgames: Not sure what more one would want?
14:45:30 <Toxaris> > return ('a', 'b') :: [Char] -- litb e.g. the list monad
14:45:31 <lambdabot>  Couldn't match expected type `Char' against inferred type `(a, b)'
14:45:41 <Toxaris> > return ('a', 'b') :: [(Char, Char)] -- litb e.g. the list monad
14:45:46 <FunctorSalad> faxlore: documentation in the same window...
14:45:46 <lambdabot>  [('a','b')]
14:46:05 <Toxaris> > return ('a', 'b') :: Just (Char, Char) -- litb or the Maybe monad
14:46:06 <lambdabot>   Not in scope: type constructor or class `Just'
14:46:13 <litb> oh i see
14:46:15 <drgames> syntax highliting, source competion, etc.
14:46:15 <Toxaris> > return ('a', 'b') :: Maybe (Char, Char) -- litb or the Maybe monad
14:46:16 <lambdabot>  Just ('a','b')
14:46:25 <litb> it knows what to call because it knows that x and y are [Int]
14:46:33 <FunctorSalad> drgames: emacs haskell-mode at least has highlighting and does indentation well
14:46:38 <Toxaris> litb: no, x and y are Int in your example
14:46:55 <FunctorSalad> drgames: and it shows you some brief information on the thing were your cursor is
14:47:06 <FunctorSalad> but I would prefer the full docu on keypress... is that possible?
14:47:07 <Toxaris> :t return -- litb that is the type of return
14:47:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:47:16 <litb> i did say x <- [1, 2, 3] i thought that is [Int]
14:47:37 <Saizan> dcoutts: tried a simple cabal install foo with the new cabal-install? it seems that the default verbosity is not set or passed correctly, it dies on fromFlag
14:47:40 <drgames> functorSalad: thx
14:47:42 <Toxaris> litb: [1, 2, 3] is [Int], but x is only Int. that's the "magic" of the "<-"-notation
14:47:52 <litb> oh
14:48:34 <fowlduck> ha, i figured it out
14:48:37 <fowlduck> thanks guys
14:48:44 <Toxaris> litb: look at the type of return's result, m a. a is taken from the parameter of return (in your case: Int). m is choosen from the context, what the caller of the return expects. in your case: []. together, this is [Int]
14:49:26 <Toxaris> litb: (in reality, everything is choosen from the context, and everything is context to everything else, and it sorts out by comparing various types and trying to fill in the gaps)
14:50:27 <Toxaris> litb: sorry, in your case a = (Int, Int) and m a = [(Int, Int)] of course
14:50:32 <pejo> drgames, there's visual haskell if you have visual studio, but it's not updated for the latest ghc/visual studio.
14:51:03 <ricky_clarkson> pejo: What does it do that vim+ghc don't?
14:52:37 <litb> oh, darn. i haven't known that you could write [Int] as []Int too
14:53:23 <pejo> ricky_clarkson, lets all use ed while we're at it!
14:53:41 <ricky_clarkson> pejo: It's a serious question.
14:54:33 <roconnor> @pl \(a,b) -> b a
14:54:34 <lambdabot> uncurry (flip id)
14:55:06 <roconnor> @djinn Not (Not A, Not Not A)
14:56:56 <sjanssen> roconnor: kind error
14:57:06 <sjanssen> @djinn Not (Not a, Not (Not a))
14:57:07 <lambdabot> f (a, b) = void (b a)
14:57:44 <faxlore> :t void
14:57:45 <lambdabot> Not in scope: `void'
14:57:48 <faxlore> o_o
14:57:59 <idnar> @djinn (a, b -> c) -> c
14:58:00 <lambdabot> -- f cannot be realized.
14:58:03 <pejo> ricky_clarkson, I'm not sure what visual haskell gives you exactly, but it's integrated in your ordinary IDE for one.
14:58:07 <idnar> @djinn (a, (b -> c)) -> c
14:58:07 <lambdabot> -- f cannot be realized.
14:58:10 <idnar> aww
14:58:12 <faxlore> ?djinn (a, a -> c) -> c
14:58:13 <lambdabot> f (a, b) = b a
14:58:17 <idnar> oh right, duh
14:58:27 <ricky_clarkson> pejo: Ok, thanks.
14:58:53 <litb> @type <- [1, 2, 3]
14:58:54 <lambdabot> parse error on input `<-'
14:59:00 <litb> o.O
14:59:04 <ddarius> @bot
14:59:04 <lambdabot> :)
15:01:48 <litb> Toxaris: one other question tho. if x is Int, how could it save 1, 2 and 3 ?
15:02:09 <Toxaris> litb: clever question, dumb answer: it cannot
15:02:19 <litb> it's really confusing. maybe i should get a book
15:02:29 <monochrom> The code is run many times.
15:02:41 <monochrom> One time with x bound to 1. One time with x bound to 2. etc.
15:02:44 <Toxaris> litb: but it can hold first 1, later 2 and even later 3
15:02:56 <litb> oh
15:03:24 <dons> sjanssen: the ML guys are super sensitive about this!
15:03:31 <dons> pretty much every ML-er on reddit has replied
15:03:57 <dons> sjanssen: so i think that answers your question. loosing f == \x . f x *is* a sore spot
15:07:51 <jonafan> errrr monomorphic functions bother ml people?
15:07:52 * Cale tries to see what remark of sjanssen's dons was replying to :)
15:08:43 <monochrom> monomorphic anything bothers all people.
15:09:02 <monochrom> but all people also accept it as a necessary evil.
15:09:13 <monochrom> or maybe tolerate
15:09:31 <jonafan> i can't say it really bothers me that much and i don't run into it that often anyway
15:10:07 <monochrom> yeah
15:10:43 <jonafan> if people on reddit are responding, it's probably because of the way the question was framed
15:11:07 <faxlore> @hoogle a -> (a -> b) -> b
15:11:08 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
15:11:08 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
15:11:08 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
15:11:15 <faxlore> I can prove id, const and ($) now :)
15:12:51 <monochrom> What is "prove id"?
15:12:58 <litb> you can prove what?
15:13:02 <faxlore> ?djinn a -> a
15:13:02 <lambdabot> f a = a
15:13:30 <litb> you can reduce it to f ?
15:13:31 <hpaste>  faxlore pasted "silly theorem prover" at http://hpaste.org/4911
15:13:39 <litb> i think it's called eta reduce?
15:13:43 <faxlore> It's silly because it might not terminate
15:13:45 <monochrom> You have it backwards. You have proved a->a, using the proof id. You have not proved id using the proof a->a.
15:13:50 <faxlore> even though it's decidable
15:14:11 <faxlore> withGensyms $ prove [] theorem2   --  Just (LAbs "x" (LAbs "y" (LVar "y" :$: LVar "x")))
15:14:17 <monochrom> It's like saying "nice, I've got the chicken to eat me!"
15:18:34 <Pseudonym> ?djinn (a -> b) -> (a -> b)
15:18:35 <lambdabot> f a = a
15:18:49 <gio123> does somebody know what is deference between regular tree language and regular word language?
15:19:08 <Pseudonym> gio: Yes.  Tree languages aren't associative.
15:19:29 <Pseudonym> In word languages, "concatenation" is associative.
15:20:23 <gio123> thanks
15:20:25 <gio123> only this
15:20:26 <gio123> ?
15:21:21 <Sizur> does deriving only work with Haskell-98 constructors?
15:22:23 <monochrom> I don't understand the question.
15:22:36 <dons> i tried too, but got confused.
15:22:41 <Sizur> i remember i was able to derive a GADT
15:22:41 <dons> you mean, h98 type classes only?
15:22:42 <monochrom> I only understand: "does deriving only work with Haskell-98 classes?" And I answer yes.
15:22:43 <dons> or GADTs.
15:22:51 <dons> ah
15:23:16 <Sizur> data declaration
15:23:52 <Sizur> ghc fails at deriving Show for GADT
15:24:19 <Sizur> i remember it was ok before, maybe 6.8.1
15:24:25 <Cale> cpst: heh, are you around?
15:24:30 <monochrom> Is it because your GADT uses something unshowable?
15:24:40 <Sizur> yeah
15:24:56 <Sizur> i was hoping Show will show just the showable part
15:25:42 <Pseudonym> gio: Pretty much, IIRC.
15:25:43 <Sizur> ah i see, i need to have a Show context for the unshowable part
15:25:58 <Pseudonym> That's the main algebraic difference.
15:25:59 <faxlore> ?djinn (a -> b -> c) -> a -> (a -> b) -> c
15:26:03 <lambdabot> f a b c = a b (c b)
15:26:10 <Pseudonym> Obviously, there are a lot of details which change too.
15:26:35 <Pseudonym> Like, regular tree languages don't support regular expressions as you understand them.
15:26:43 <Pseudonym> But they have an equivalent.
15:27:35 <hpaste>  sizur pasted "what's wrong with this?" at http://hpaste.org/4912
15:28:46 <monochrom> function not showable
15:29:15 <monochrom> err, I need to think again
15:29:18 <Sizur> it's a constructor
15:29:41 <mokus> @djinn Not (a -> a) -> b
15:29:41 <lambdabot> f a = void (a (\ b -> void (a (\ _ -> b))))
15:29:43 <Toxaris> maybe deriving doesn't like existentials?
15:31:49 <monochrom> Yes, the forall changes things.
15:32:07 * Toxaris realizes that "Haskell-98 constructors" is ghc-error-message speech
15:32:24 <monochrom> Imagine translating this back to ordinary data declarations.
15:32:46 <ddarius> Note that the dual is also true to neelk's statement here: http://programming.reddit.com/info/653nl/comments/c02v549  The rules for pairs holds in a pure call-by-name but not in a pure call-by-value language.
15:32:52 <monochrom> It will not look like data Addiction = Addiction a a.
15:32:57 <Sizur> oyu mean instead of GADTs
15:33:41 <Toxaris> monochrom: addiction?
15:33:50 <monochrom> Freudian slip.
15:34:49 <dons> ddarius: f == \x . f x seems more important though (due to the kinds of things it enables). its more ubiquitous, you think?
15:35:20 <monochrom> OK, I don't know it. But it has to do with forall.
15:35:48 <Sizur> how can i translate that to normal declaration?
15:36:29 <ddarius> dons: True.  But f == \x -> f x doesn't hold in Haskell.  The loss of full beta also is a problem and, in fact, both of these are related to CbN languages having pairs while CbV don't.
15:36:44 <qebab> style question: what is the preferred layout for "if foo then bar else baz" where one or more of foo, bar and baz are long or complex expressions? if foo newline then bar newline else baz?
15:36:48 <dons> mm, yes.
15:36:50 <Toxaris> Sizur: data AddAction = forall a . (Num a, Show a) => AddAction a a
15:37:11 <Sizur> yeah, it cannot derive show form that too
15:38:05 <Toxaris> qebab: yes, sounds good. with the then and the else line indented
15:38:15 <qebab> obviously :)
15:38:19 <qebab> thanks
15:38:41 <qebab> I really like indendation as delimiting
15:38:59 <qebab> not really weird, having learnt python as my first language but still
15:39:13 <Toxaris> qebab: some people avoid if-then-else and use other constructs instead (mostly pattern guards)
15:39:36 <qebab> hrm, that'd maybe be nicer
15:39:46 <Sizur> so one cannot derive existentially quantified types?
15:40:07 <ddarius> Toxaris: "pattern guards" means something different from "guards", are you sure that that is what you wanted to say?
15:40:15 <Toxaris> ddarius: no
15:41:12 <qebab> yeah, this definitely looks nicer in my case
15:41:15 <Toxaris> ddarius, qebab: I mean these "| <boolean expression>" things, however they are called. how are they called?
15:41:24 <ddarius> They are called guards.
15:41:28 <monochrom> Crimson Guards.
15:41:34 <qebab> Toxaris: I knew what you meant :) I just didn't know there was a difference
15:41:37 <Toxaris> and what are pattern guards?
15:41:43 <qebab> monochrom: shush, don't read so much fantasy
15:41:49 <monochrom> hehe
15:41:51 <ddarius> However, there is a GHC extension called pattern guards which allow f x | Just y <- x = y
15:41:59 <qebab> monochrom: that's an awesome series by the way
15:42:08 <cpst> Cale: yeah, I'm here
15:42:13 <cpst> Cale: just got back from grand china
15:43:50 <qebab> does anyone know if the haskell-mode for emacs can integrate with ghci somehow?
15:44:31 <Toxaris> ddarius: oh interesting. thanks for the info. is this widely used / used at all? I remember some discussion about it, but don't think i've ever seen it used.
15:50:00 <Saizan> qebab: C-c C-l ?
15:50:56 <qebab> ah, I see. but that errors on me ):
15:51:35 <Saizan> which error?
15:51:40 <FunctorSalad> qebab: "alt-x run-haskell"?
15:52:15 <qebab> no match
15:52:43 <qebab> oh jesus
15:52:48 <qebab> I've got an old version
15:53:06 <Saizan> heh, maybe you haven't load the right module also
15:53:49 <Saizan> i had to add (require 'inf-haskell) in .emacs
15:53:57 <Kolji> Cale
16:09:52 <dmwit> :t all
16:10:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:10:11 <dmwit> :t and
16:10:12 <lambdabot> [Bool] -> Bool
16:12:47 <glguy> :t or
16:12:47 <lambdabot> [Bool] -> Bool
16:12:50 <glguy> :t any
16:12:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:16:20 <hpaste>  faxlore annotated "silly theorem prover" with "less silly" at http://hpaste.org/4911#a1
16:16:32 <faxlore> There is a slightly better one
16:18:52 <faxlore> any suggestions?
16:18:58 <faxlore> (to improve)
16:21:50 <litb> now, i'm working with haskell two days, and knocking on the doors of Monads. i hope i get in some day
16:22:13 <shapr> Have you read Cale's intro, or sigfpe's intro?
16:22:30 <litb> nope. my only source has been yaht
16:23:04 <litb> is Cales intro or 1/0 into good?
16:23:12 <litb> s/into/intro/
16:23:14 <dons> yeah
16:23:29 <ddarius> Just read Wadler's paper(s).
16:23:50 <shapr> I enjoyed http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
16:23:51 <dons> there's lots of good monad papers
16:23:51 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
16:23:54 <shapr> But I already knew monads...
16:24:02 <dons> so maybe shapr already had
16:24:22 <litb> shapr: you already know them?
16:24:28 <litb> *knew
16:24:36 <litb> oh i see
16:24:38 <faxlore> I think I understood what Monads are when I learned what a Vector Space is
16:24:44 <litb> missed your previous line :)
16:24:59 <faxlore> because of seeing it as that kind of mathematical structure
16:29:20 <balodja> Is there any article(or even resource!), that is concentrated on different occurrences of monads in mathematics, physics, computer science etc (may be real world too)?
16:29:54 <litb> o.O i suppose you have to have an IQ of above 140 to understand haskell :D
16:30:07 <litb> anyway, thanks for teaching me. see you tomorrow :)
16:30:08 <LoganCapaldo> i hope not
16:31:10 <faxlore> ?djinn f -> z -> s -> n -> (f -> z) -> ((f -> n) -> (f -> (s -> n))) -> (f -> n)
16:31:10 <lambdabot> f a _ b c _ d e = d (\ _ -> d (\ _ -> c) e b) a b
16:31:33 <dons> litb: shouldn't be necessary, its just another programming language. a good one, but still, its not theorem proving :)
16:31:57 <faxlore> dons I wrote a theorem prover in haskell :D
16:32:02 <faxlore> (really really simple)
16:32:21 <Pseudonym> Cool.
16:32:35 <Pseudonym> Of course, a lot of programs in Haskell are theorem provers in disguise.
16:32:36 <faxlore> I must add some data types to it
16:32:38 <Pseudonym> e.g. the type checker
16:32:54 <ddarius> balodja: Most of them?  John Baez has interesting articles on category theory applied to physics.  Usually categorical ideas are presented as unifying a wide-spread of notions.
16:32:55 <faxlore> oh  I know that a type checker can work by unification
16:33:15 <Pseudonym> Unification is only one kind of theorem proving primitive.
16:33:24 <Pseudonym> The thing is, a type checker "proves" that a program is type correct.
16:33:44 <kmcallister> a type checker without inference is just a proof checker
16:33:47 <Pseudonym> It's a smaller theory than full-on FOPL, but still.
16:34:24 <faxlore> What's the most expressive type system you could still check in finite time?
16:34:36 <faxlore> I guess haskell is not far off?
16:34:38 <ddarius> faxlore: There isn't a single one.
16:34:51 <ddarius> faxlore: You can always make a more expressive type system.
16:35:01 <faxlore> but have it still checkable in finte time?
16:35:05 <balodja> ddarius: That's good. Because I've already get tired with "list, maybe, reader, writer, continuation and state" as monads. I want to understand what monad really is, not just in application to haskell. And without "simple" examples from topology :)
16:35:32 <Pseudonym> Any reasonable proof system has proofs that are _checkable_ in finite time.
16:35:44 <kmcallister> but type inference requires actually generating parts of the proofs
16:35:49 <kmcallister> and thus is often undecidable
16:35:59 <litb>  I want to understand what
16:36:00 <litb>                  monad really is
16:36:11 <litb> lols, that sounds philosophical. anyway, /parting...
16:36:12 <dons> i want to know what numbers really are too
16:36:15 <shapr> aww
16:36:17 <ddarius> balodja: Most of the Haskell examples are -the same- examples as monads in e.g. logic and monads in topology.
16:36:29 <ddarius> (and monads in algebra)
16:36:49 <ddarius> faxlore: Yes.  If you remove that restriction then there is a "most expressive type system"
16:36:53 <shapr> dons: I think the best thing for 2008 would be a Haskell' that encompasses all the extensions what people actually use in GHC.
16:36:59 <dons> monads are the building blocks for effects in programming languages?   programmable semi colons?   apples and nuclear waste in the ocean?
16:37:08 <faxlore> What is it? :D
16:37:17 <ddarius> faxlore: Any Turing complete language.
16:37:19 <EvilTerran> marble run!
16:37:51 <dons> shapr: you think? i can see some benefit from that, but not a lot -- the main benefit from H' might already be that the extensions are all tagged and sorted, and we've consensus on what's good, what's bad, and not to enable everything with -fglasgow-exts
16:38:22 <dons> it might lead to more confidence in the language by outsiders, perhaps
16:38:22 <shapr> dons: I'd love to have naturally parallel Haskell libs for 2008.
16:38:30 <shapr> Yeah, I think we need more outsiders.
16:38:38 <shapr> PROSELYTIZE!
16:38:48 <dons> ASSIMILATE!
16:38:57 <dons> RESISTANCE IS FUTILE!
16:39:02 <dons> YOU WILL BETA REDUCE!
16:39:07 <shapr> Hopefully I'll have enough spare time to start up a Boston HUG. edwardk suggested that I start it up in Somerville so it'd be HUGS.
16:39:11 <balodja> dons: "i want to know what numbers really are too", so we have great number of examples of occurencies of numbers in real life. and what about monads? :)
16:39:12 <dons> awesome.
16:39:35 <kmcallister> balodja, you use the Maybe monad all the time in real life
16:39:36 <dons> balodja: nuclear waste barrels? dreams?
16:39:38 <balodja> Is there something, that could help to understand them more deeply?
16:39:39 <shapr> dons: What do you think would be good for 2008?
16:39:50 <shapr> Maybe more GUI code?
16:39:56 <faxlore> balodja: (>>=) = flip concatMap
16:40:03 <shapr> I'm not sure what the next big goal would be.
16:40:18 <dons> a bytestring network stack, a bytestring parser stack, bitwise serialisation, more hackage improvements,  more parallel stuff
16:40:26 <dons> bytestring xml
16:40:33 <dons> we need to do a survey
16:40:46 <dcoutts_> dons: haxml uses polyparse and polyparse can work on bytestrings I believe
16:41:13 <dcoutts_> dons: a unicode bytestring will be important for xml stuff and is important generally
16:41:17 <LoganCapaldo> @where polyparse
16:41:17 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
16:41:22 <dons> unicode/utf8 yep
16:41:22 <Cale> Heh, "what is a monad?" has become sort of like "what is a tensor?" in that it's a mathematical question which has become almost a philosophical one.
16:41:26 <balodja> dons: What kind of monads do dreams represent?
16:41:33 <balodja> *does
16:41:36 <balodja> *do :)
16:41:48 <dons> balodja: well, dreams are like strange encapsulated monads where different evaluation strategies apply
16:41:59 <dons> and you can run them, but they shouldn't escape into normal life
16:42:04 <dons> aka the Life monad
16:42:07 <shapr> dons: I dunno, I think bytestring stuff might be too specific to improve Haskell as a community.
16:42:17 <luqui> eh, I think dreams are probably closest to Cont
16:42:20 <dons> unsafeSleepWalk is a dangerous op, with a proof obligation
16:42:22 <Cale> hmm, like a FakeRootIO monad :)
16:42:25 <LoganCapaldo> what's a tensor?
16:42:29 <resiak> thoughtpolice: Hey; if you're interested, `ls` now works in BindFS.  However, if you mount BindFS on /foo/bar and then do anything that would stat /foo/bar/foo/bar (such as `ls /foo/bar/foo`), you'll deadlock BindFS and leave yourself with an unkillable BindFS and ls, so don't do that.  :-)
16:42:33 <cpst> there is another sense of monads used in mathematics that is probably more high profile
16:42:36 <LoganCapaldo> is there a space suit analogy for them?
16:42:40 <cpst> Horrocks' monads that come up in ADHM theory
16:42:41 <dons> shapr: possibly.
16:42:52 <dcoutts_> shapr: for community stuff I think we need more hackage work
16:42:52 <dons> for high perf stuff, but maybe people don't care about more speed
16:43:03 <dons> they're happy with ruby and erlang after all
16:43:26 <Cale> cpst: Is that really higher profile? I'm not sure.
16:43:31 <dons> strategy is hard
16:43:37 <luqui> everybody always whines about speed, but they really don't care as much as they say they do
16:44:09 <idnar> I wouldn't exactly call ruby "high performance" :P
16:44:29 <cpst> Cale: 3 of those 4 letters are Fields medalists
16:44:50 <dcoutts_> shapr: so haskell is great for building reusable libraries, so to make full advantage of that we need using other people's libs to be as simple and reliable as possible, hence the importance of hackage
16:45:01 <ddarius> LoganCapaldo: It's the representation of the functor Bilin(U,V; -) which takes a vector space W to the set of bilinear transformations from U and V to W.
16:45:46 <shapr> dcoutts_: Good point
16:45:54 <Cale> cpst: But still, ADHM theory seems more obscure than category theory at this point.
16:45:58 <dcoutts_> shapr: we need to develop ways to make it easy for users to select amongst libs using measurable statistics like usage, test coverage etc
16:46:16 <shapr> Yeah, that would be good.
16:46:39 <cpst> Cale: what I meant is that if you went around to mathematicians and asked them what a monad was, you would probably get more people who heard of it because of ADHM
16:46:42 <dcoutts_> shapr: we can optimise what we can measure, so making more QA stats public automatically should help to improve quality generally
16:46:48 <cpst> Cale: Instanton moduli spaces are a pretty hot topic of research right now
16:46:54 <cpst> Cale: thank string theory for that one
16:47:01 <shapr> dcoutts_: Very much so.
16:47:23 <ndm> dcoutts_: i think you are just setting things up to get rigged, people to get their ego bruised, and likely you are going to get it wrong in some way
16:47:33 <shapr> Attaching notes like "tested with ghc 6.6 6.8, nhc" and that sort of thing would help.
16:47:47 * ddarius poos on string theory.
16:48:14 <dcoutts_> ndm: it doesn't need to be a strict ranking, but for example it'd distinguish a lib with 90% test coverage from one with no tests at all
16:48:15 * shapr poos on character theory
16:49:45 <ndm> dcoutts_: things like works on which platforms, test coverage etc. are good to make available, as well as things like "other people would use this package instead to do a similar thing" - but ranking by use/dependency can go wrong very easily
16:50:20 <Cale> @keal
16:50:20 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
16:50:34 <dcoutts_> ndm: if the stat is divorced from it's meaning then that's quite likely
16:51:00 <dcoutts_> ndm: eg rewarding packages that have high usage with higher and not letting others break in
16:51:32 <gwern> doesn't cabal have a field for 'tested-with'?
16:51:36 <ndm> i would love to see links between packages saying these are alternatives, i.e. tagsoup, haxml, hxt etc should all have links between them
16:51:39 <dcoutts_> gwern: yes
16:51:45 <ndm> ditto uniplate vs syb
16:51:56 <ndm> so people can see what the other options are, and at least casuallly evaluate them
16:52:06 <dcoutts_> ndm: perhaps via keywords/category?
16:52:17 <dcoutts_> ndm: but on the other hand if it's clear what the statistic is then people can make up their mind if they want to go with the herd or try something else
16:52:37 <ndm> dcoutts_: not good enough, i want "if you use this package, you could probably use this package instead"
16:52:58 <ndm> unless the categories are fine grained enough to allow that, but it almost goes against tags and categories, since its too fine grained
16:53:03 <dcoutts_> ndm: currently category is encouraged to be singular rather than a tag where it'd encourage
16:53:23 <ndm> i.e. most packages should be in their own unique group for inter-recommendation
16:53:25 <dcoutts_> ndm: ... where it'd encourage people to put in lots of tags, to use them more like links
16:53:48 <dcoutts_> ndm: there's no reason we could not add extra tags after a package has been uploaded
16:53:55 <dcoutts_> ndm: via the web ui
16:54:19 <dcoutts_> ndm: the .cabal file is kept outside of the .tar.gz partly so we can add/modify the metadata
16:54:42 <ndm> dcoutts_: i  wouldn't want it even to be in the .cabal file, most just a general concensus and grouping thing
16:54:51 <ndm> by hand
16:55:03 <ndm> to be fair, there aren't that many libraries that overlap
16:55:17 <ndm> and where there are, we do a bad job of saying where the overlap is, and what the solution is
16:55:23 <dcoutts_> ndm: right, package authors are not the best people to decide what links should be
16:55:37 <ndm> i.e. you should link between haskellqt, wxHaskell, gtk2hs - and my vote would be gtk2hs
16:55:44 <ndm> dcoutts_: i'd say the worst people :)
16:55:50 <dcoutts_> aye :-)
16:56:12 <ndm> but its almost going to go against the idea of wxhaskell to recommend people might also try gtk2hs
16:56:20 <dcoutts_> ndm: well, it's a good idea as that's one of the things users have to try and evaluate, "which of these packages would fit my needs"
16:56:31 <dcoutts_> so anything we can do to help inform that decision is good
16:56:35 <shapr> It'd be nice to have similar examples for all of the GUI toolkits.
16:56:48 <dcoutts_> we'd need a good design for such a system
16:57:11 <ndm> dcoutts_: yes, but its a rare circumstance - we maybe have 8 sets of libraries where there are many libraries overlapping - we don't need an automated system, we need some humans
16:57:45 <dcoutts_> ndm: right, but how do we present that kind of information, where do we keep the info, how is it structured?
16:57:55 <dcoutts_> how does it evolve as new package version are added etc
16:58:00 <ndm> dcoutts_: a wiki
16:58:17 <dcoutts_> ndm: and is it linked from the hackage pages? how do people know where to look?
16:58:32 <ndm> dcoutts_: i want to use a GUI toolkit that looks quite native on windows and has a strong developer commitment behind it - no statistic will give me that
16:58:44 <ndm> dcoutts_: we can link it in from hackage
16:58:53 <dcoutts_> well, it will a bit
16:58:59 <ndm> not really
16:59:09 <ndm> any statistic that is automatically generated won't reflect reality
16:59:10 <dcoutts_> you can see the project activity in terms of releases and darcs changes
16:59:15 <ndm> that's irrelevant
16:59:20 <dcoutts_> not totally
16:59:27 <dcoutts_> eg compare hsql and hdbc
16:59:29 <ndm> not totally, but not as important as other things
16:59:40 <dcoutts_> hsql: 0 dev activity, hdbc: lots
16:59:47 <ndm> i think the real solution might be real world haskell book to give the answer
17:00:01 <dcoutts_> that'll get out of date before it's published :-)
17:00:03 <ndm> who does hsql? can it be officially abandoned and suggest people move over to hdbc?
17:00:18 <ndm> ideally, we should be funnelling development, and abandoning the old stuff
17:00:29 <dcoutts_> ndm: well exactly, how would we reflect that kind of thing in hackage
17:00:35 <ndm> and where there are genuine alternatives, i.e. XML processing, all the pages should group
17:00:41 <dcoutts_> ndm: at the moment there is no reflection of bitrot on the hackage pages
17:00:47 <MyCatVerbs> ndm: I get the impression that this is what SPJ meant by "avoid success at all costs".
17:00:52 <shapr> I'm considering attending http://stuff.mit.edu/iap/#hackhaskell . Does anyone else want to go with me? :-)
17:00:53 <lambdabot> Title: SIPB IAP 2008 Activities
17:00:58 <shapr> It's free!
17:01:08 <ndm> dcoutts_: the author of hsql could write in the cabal package "For new projects I recommend the use of hdbc"
17:01:22 <dcoutts_> ndm: he'd have to make a new release to do that :-)
17:01:29 <MyCatVerbs> ndm: Haskell has a sufficiently tiny and propellerheaded userbase that it's still currently perfectly acceptable to say, "$library sucks, everyone should switch to $betterlibrary, k?"
17:01:42 <dcoutts_> ndm: see, we need some way of managing packages that does not rely on the package maintainers
17:01:45 <ndm> MyCatVerbs: exactly :)
17:01:58 <ndm> dcoutts_: download, modify the .cabal file, upload - sounds like a few minutes work to me
17:02:06 <dcoutts_> ndm: we need to manage it a bit more like a linux distro where the distro maintainers can do stuff
17:02:17 <Pseudonym> We need a way to program that doesn't involve programmers.
17:02:20 <ndm> dcoutts: we aren't that big yet
17:02:27 <dcoutts_> ndm: but you cannot reasonably make new version number releases of a package you're not maintainer of
17:02:31 <ndm> we don't need policy, we need people to do clever things
17:02:40 <ndm> dcoutts_: then someone should email the maintainer, asking their intentions
17:03:15 <dcoutts_> ndm: my point is rather that we do not have the infrastructure to do this stuff effectively without a lot of manual work from lots of people
17:03:30 <dcoutts_> ndm: I know because I help maintain >100 gentoo haskell packages
17:04:28 <MyCatVerbs> ndm: oh, that and the, "has $problem been bugging you lately? Try $complicated_language_extension_requiring_foreknowledge_of_entirity_of_human_mathematics." And people do. ;)
17:05:19 <kfish> how about reddit-style up/down ratings for hackage packages? ;-)
17:05:38 <ndm> dcoutts: i'm just worried it won't reflect stuff accurately, but if you have the time to give it a try, it could be good
17:05:57 <ndm> MyCatVerbs: i program in H98 + heirarchical modules
17:06:22 <ndm> (plus MPTC in one instance)
17:06:31 <dcoutts_> ndm: I'm of the opinion that maximum automation is necessary to keep any information up to date and minimise ongoing busy work by hackage maintainers/developers
17:08:01 * EvilTerran is happy to use that, too, most of the time
17:08:24 <dcoutts_> kfish: that's ok but rather easy to "ballot stuff", there are probably more objective measures
17:08:29 <EvilTerran> although i occasionally wander into GADTS, fundeps, pattern guards, ...
17:08:29 <MyCatVerbs> ndm: I don't even use all of H98. The higher stuff scares me. :)
17:09:13 <EvilTerran> -XNoMonomorphismRestriction, when i'm feeling lazy ;)
17:09:16 <dcoutts_> kfish: but how about a more general comment/endorsement system where people put their name to a comment on a package, that gives more free-form info and discourages multiple voting
17:09:22 <MyCatVerbs> ndm: (well, verrrrry simple fundeps and multiple parameter type classes are fun. But I don't use those for serious work, instead just when usin Haskell to experiment with interesting random chunks of mathematics).
17:09:34 <BMeph> kfish: s/reddit/Download.com/ ;)
17:09:36 <dcoutts_> kfish: and probably just the comments are enough, no need to make a ranking from that info
17:09:59 <kfish> yay social hackage :-)
17:10:26 <MyCatVerbs> dcoutts_: how about "My name is $foo, I'm working on project $bar (find us at $bar.sourceforge.net/www.cs.$whatever.edu/$bar), we use libraries $baz, $beep and $beedle"?
17:11:06 <dcoutts_> MyCatVerbs: I'm not sure I get what you're suggesting
17:12:00 <MyCatVerbs> dcoutts_: so that for any project you're writing where you use hackage libs, you can go through and tell hackage which you're using, and leave contact details in case the maintainers want to mail-bomb you.
17:12:07 <EvilTerran> "my name is $foo"? "...and here's my son; we call him little Bobby Tables" ;)
17:12:32 <dcoutts_> MyCatVerbs: we can get much of that info from downloads and build reports
17:12:33 <gwern> hm. so I see hs-plugins and yi are using crazy tricks to get the output of 'ghc --print-libdir' and use it to initialize a GHC API session
17:12:45 <EvilTerran> ew
17:12:45 <gwern> is anyone here familiar with that and how to improve it?
17:12:49 <MyCatVerbs> EvilTerran: wanna know a secret? QBASIC has long ago corrupted my brain: I now read (and have since I was about, oh, eight?) the character '$' as "string" instead of "dollar". :)
17:12:54 <dcoutts_> MyCatVerbs: and if the package that they're writing gets uploaded to hackage then we can see the package deps
17:13:12 <EvilTerran> MyCatVerbs, I read it as "scalar" =/
17:13:17 <MyCatVerbs> dcoutts_: then in that case, perhaps it isn't neccessary to use anything other than just that?
17:13:20 <EvilTerran> (roo much perl)
17:13:31 <dcoutts_> MyCatVerbs: right, that was my point
17:13:43 <MyCatVerbs> dcoutts_: but...
17:13:46 <EvilTerran> although I also sometimes read it as "low-precedence application" or "TH splice" :P
17:14:04 <dcoutts_> gwern: you mean how do you capture the output of a program in a nice way?
17:14:09 <gwern> god is Real unless declared Ineger?
17:14:30 <gwern> dcoutts_: well, I figure maybe it should be standardized as a GHC API function or just built into newSession
17:14:32 <EvilTerran> I rely on source highlighting to keep me sane; i can get very confused when looking at unhighlit perl, say...
17:14:37 <gwern> and then --print-libdir could call that new function
17:14:42 <EvilTerran> gwern, i'd say god's really quite complex...
17:14:58 <MyCatVerbs> dcoutts_: in that case, it'd help if everybody was encouraged really really strongly to put all their programs and libraries on hackage.
17:15:01 <gwern> dcoutts_: it's just nuts that hs-plugins, for example, is going 'GHC_LIB_PATH=`$GHC --print-libdir | tr -d '\r'`' to get it
17:15:21 <EvilTerran> although whether he's rational is a matter of some debate ;)
17:15:52 <gwern> dcoutts_: I mean, does anyone *not* want their GHC API session to be started with the libpath of the ghc being called? would that even work? I don't think it does, based on my experiments
17:16:04 <ndm> dcoutts: to make these stats accurate we will need more programs on hackage, as now that doesn't seem to be common
17:16:10 <dcoutts_> gwern: but that information is not actually known
17:16:27 <dcoutts_> gwern: the ghc library does not have the paths baked into it
17:16:55 <gwern> dcoutts_: but it can get it, how else could yi and hs-plugins work?
17:17:22 <dcoutts_> gwern: because ghc knows it, but the ghc api library does not
17:17:45 <dcoutts_> gwern: ghc knows it because the ghc program is actually as script that passes -B${GHC_LIB_DIR}
17:17:55 <MyCatVerbs> dcoutts_: I'm thinking maybe a "Cabal for dumbasses" tutorial or two (I could sure as Hell use one myself), -strong- exhortations in some of the central places that the Haskell community is wrapped around ("a call for apps on hackage" or something on the front page of haskell.org?) and also splitting of hackage into "good" and "crap" sections, since tidying up a library to a sufficient standard that it's not embarassing to upload is a fairly large 
17:18:20 <thoughtpolice> resiak: i'll pull the patches and keep it in mind :)
17:18:27 <MyCatVerbs> (This being, of course, the academic "we". I'm far too lazy to do anything but whine. ;)
17:18:34 <gwern> dcoutts_: hm. so any solution won't be simple
17:19:00 <dcoutts_> ndm: right, dependencies are not good for home grown / in house / one off programs that are not uploaded, so we need something else in that case
17:19:04 <MyCatVerbs> EvilTerran: gotta be irrational.
17:19:25 <dcoutts_> ndm: we can get download stats and if people turn on build reporting in cabal-install then we can get that info too
17:19:32 <MyCatVerbs> EvilTerran: since it's impossible to completely describe a deity using any finite quantity of digits. :)
17:19:54 <dcoutts_> ndm: but yes, that doesn't tell us which libs really end up getting used seriously in programs
17:20:08 <EvilTerran> "0"?
17:20:11 <EvilTerran> *gr+r*
17:20:17 <EvilTerran> er, *gd+r*
17:20:49 <MyCatVerbs> dcoutts_: to me the natural solution is to make a low barrier to entry section of hackage and get everyone to upload everything to it that they possibly can.
17:20:59 <gwern> dcoutts_: where the libdir will be is known as part of the configuration at the compile time of GHC, right?
17:21:39 <dcoutts_> MyCatVerbs: right, then it is essential that we have the infrastructure to distinguish high quality packages from low quality or we'll be overwhelmed by mediocrity
17:21:54 <dcoutts_> gwern: no, at install time of ghc
17:22:31 * gwern doesn't understand. you ./configure --prefix=/foo, and then you 'make'
17:22:56 <dcoutts_> gwern: a binary version of ghc can still be installed anywhere
17:23:06 <dcoutts_> that's why the ghc binary does not bake in the paths
17:23:21 <dcoutts_> it gets passed those paths by a script which is generated at install time
17:23:42 <dcoutts_> (or on windows it uses a win32 api call to find the dir it's running from)
17:23:52 <gwern> gah!
17:24:31 <gwern> a solution to this must be found. it's intolerable to either hardwire in a guess as to the libdir or to do bizarre stuff with cabal or shell commands just to get it
17:24:42 <MyCatVerbs> dcoutts_: I'm tempted to suggest rather naïve community-consensus measurement methods for working that out, since Haskell currently has such a tight-knit community that they'd work, for now.
17:25:00 <gwern> maybe I'll study how yi does it. it somehow goes through cabal and extracts libdir
17:25:42 <dcoutts_> MyCatVerbs: well yes we all have that information in our heads, the question is how to helpfully present that information on the hackage website so newbies can make sensible decisions about which packages to pick
17:25:58 <dcoutts_> gwern: I think it does some custom stuff in Setup.hs
17:26:02 <MyCatVerbs> dcoutts_: oh, I see.
17:26:24 <dcoutts_> gwern: basically calling ghc --print-libdir at configure time
17:26:31 <MyCatVerbs> Perhaps the sane thing to do would be to add a command line argument to ghc that makes it dump the current libdir.
17:26:43 <dcoutts_> $ ghc --print-libdir
17:26:43 <dcoutts_> /usr/lib64/ghc-6.8.2
17:26:45 <MyCatVerbs> Oh hey, it already has that. heheheh.
17:26:48 <gwern> MyCatVerbs: that's what --print-libdir does :)
17:26:49 <dcoutts_> MyCatVerbs: like that ^^ ? :-)
17:27:16 <MyCatVerbs> Sorry, thought that didn't exist, since there seemed to be a problem.
17:27:20 <gwern> MyCatVerbs: my problem is that it drives me nuts that you can only get that info through calling a shell script. I want it compiled in!
17:27:21 <MyCatVerbs> gwern: you can use that, right?
17:28:12 <MyCatVerbs> gwern: chillax. yo. It uses, what, a hundred twenty milliseconds of CPU time to call that shell script?
17:28:16 <gwern> MyCatVerbs: not really. how does a program get to that IO String? I'm starting to think I'll just have to use unsafePerformIO and Template haskell...
17:28:36 <gwern> it complexifies the configuration!
17:29:02 <dcoutts_> gwern: perhaps the best thing would be to call ghc --print-libdir when your program initialises itself
17:29:17 <dcoutts_> ie do it at runtime rather than configure/compile time
17:29:24 <gwern> dcoutts_: but then that might not be the ghc it was compiled against
17:29:36 <gwern> @where cpuperf
17:29:37 <lambdabot> I know nothing about cpuperf.
17:29:47 <dcoutts_> gwern: you'd also want to call --version I suppose to make sure it's the same version
17:30:03 <dcoutts_> gwern: the opposite problem is that someone could move ghc but keep the same version
17:30:26 <gwern> >.<
17:30:27 <dcoutts_> though perhaps that's unlikely and you're prepared to break in that case
17:32:13 <MyCatVerbs> dcoutts_: s/break/break the user's face/
17:32:29 <dcoutts_> heh heh
17:32:53 <dcoutts_> gentoo used to do that btw, have both ghc-bin and ghc installed in different dirs but be the same version
17:33:14 <dcoutts_> and users could and would occasionally switch from one to the other without recompiling other apps/libs
17:33:35 <MyCatVerbs> Jinkies.
17:34:17 <LoganCapaldo>  would you keep ghc in the same place for a scooby snack?
17:34:39 <gwern> (interesting. I didn't know you *could* define main with a type sig besides main :: IO ())
17:34:57 <luqui> gwern, what's this then?
17:35:17 <ddarius> gwern: The obvious most general type is IO a
17:35:37 <gwern> luqui: messing with dons's cpuperf. one file defines 'main', but with the type sig main ∷ IO (Either String a)
17:36:05 <monochrom> hehe
17:36:27 <ddarius> That's mildly obscene, though I can see why it might be done.
17:37:03 <MyCatVerbs> LoganCapaldo: I suspect the scoobie snacks are actually magic brownies.
17:37:21 <MyCatVerbs> LoganCapaldo: it'd certainly explain a lot of the gang's behavoir.
17:38:02 <MyCatVerbs> ddarius: what? No, that's fine. Just have the program always end with exitWith, that's fine. :)
17:39:34 <ddarius> MyCatVerbs: There's no need for exitWith.  The type of main is IO a which suggests that it simply discards whatever is returned.
17:40:09 <MyCatVerbs> ddarius: oh, I see.
17:40:11 <monochrom> You should try main = print whee >> return undefined   some time.
17:40:38 <ddarius> main = print "foo" >> main
17:40:56 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
17:41:20 <monochrom> haha
17:41:33 <faxlore> > putStr s >> print s where s = "> putStr s >> print s where s = "
17:41:33 <lambdabot>  Parse error at "where" (column 21)
17:41:41 <faxlore> awwww
17:42:04 <MyCatVerbs> faxlore: \bot doesn't let you do any IO, for safety's sake. :)
17:42:21 <Saizan> dcoutts_: ping
17:42:28 <dcoutts_> Saizan: pong
17:42:35 <BMeph> There is no IO in the Champagne Room. ;p
17:43:29 <Saizan> dcoutts_: after your refactoring, cabal install and cabal upgrade die with a fromFlag call, presumably because they are used with commandAddActionWithEmptyFlags rather than commandAddAction ?
17:43:45 <Saizan> dcoutts_: the fromFlag call is the one for verbosity
17:43:49 <dcoutts_> Saizan: ah, thanks
17:44:23 <gwern> dons is at dons@galois.com these days, right?
17:55:36 <MyCatVerbs> dcoutts_: oh and you were totally right, using IOUArrays was a huge PITA. ByteStrings much more fun. ^_^
17:55:47 <dcoutts_> :-)
17:57:02 <dons> dcoutts_: here's a fun puzzle (and i have an answer) -- regarding bytestrings..
17:57:15 <dons> so, if i have:  x = pack "abcdef"
17:57:26 <dons> how is the bytestring constructed?
17:57:35 <dons> its a PS addr 0 len, right?
17:58:17 <dons> now, in the case of a compile-time constant string, the length is computed via a strlen call, and a rewrite rule replaces the pack with a literal PS constructor, right?
17:59:19 <dons> so, what happens when we have:  x = pack "abc\0def" :)
17:59:38 <LoganCapaldo> :(
17:59:38 <dcoutts_> hah
17:59:54 <dcoutts_> strlen is very C null terminated string
18:00:02 <dons> dcoutts_: but... something saves us   :)
18:00:03 <dcoutts_> dons: so it breaks and you get "abc"
18:00:07 <dcoutts_> really?
18:00:18 <glguy> utf8!
18:00:26 <dons> yes. so ghc turns string literals into C string literals, right?
18:00:33 <MyCatVerbs> glguy: no, ByteStrings work on word8s, not unicode.
18:00:44 <dons> however, if there's an embedded \0, it *doesn't use a C string literal*
18:00:51 <glguy> dons: what does it use?
18:00:57 <dons> so the rule never fires, since we never see a: pack "foo"#
18:01:02 <dcoutts_> dons: oh, I see
18:01:10 <dons> unpackUTF8String#
18:01:35 <glguy> \o/
18:01:45 <dcoutts_> dons: it should really store constant strings as length prefixed rather than null terminated
18:01:49 <MyCatVerbs> dons: pity. If you do see a compile-time constant string literal in C, can't you hit it over the head with sizeof()?
18:02:17 <dons> dcoutts_: yes, i think we should lobby for strings to turn into CStrLens or something
18:02:27 <dons> so we can get at that length safely in rewrite rules
18:02:45 <MyCatVerbs> "Lobby"? oO
18:02:59 <dons> and the correctness of the packAddress rewrite rule depends on a ghc compilation technique
18:03:07 <dcoutts_> lobby == send patches and/or persuade JaffaCake
18:03:12 <dons> and its utf8 checking (and the special case for \0)
18:04:24 * MyCatVerbs tries it. Yes you can.
18:04:30 <ddarius> In America we usually use mony.
18:04:41 <ddarius> s/mony/money
18:04:54 <gwern> and women. don't forget the dc madam
18:05:03 <MyCatVerbs> dons: it's a compile time constant, so why can't you use C's sizeof() to get its length, rather than relying on strlen()?
18:05:10 <gwern> first you get de office, then you get de money, then you get de women...
18:05:14 <MyCatVerbs> dcoutts_: ahhh, I see.
18:05:19 <faxlore> sizeof is done aat compile time...
18:05:44 <MyCatVerbs> faxlore: jah, and zeez are compile time constants that're under discussion.
18:06:06 <faxlore> oh .. right, I forgot that GHC is generating C code
18:06:11 <MyCatVerbs> Or am I missing some subtlety here?
18:06:19 <faxlore> nah I'm just confused
18:06:29 <MyCatVerbs> faxlore: although it won't be for long, hopefully. :)
18:06:39 <faxlore> what will be the replacement?
18:06:45 <Saizan> it's not the default anymore
18:06:48 <ddarius> MyCatVerbs: It already uses a native code generator by default.
18:07:27 <hpaste>  lz pasted "sum List" at http://hpaste.org/4913
18:07:39 <MyCatVerbs> ddarius: the higher optimization levels still turn -fvia-C on by default though, don't they?
18:08:54 <MyCatVerbs> faxlore: the native code generator should over the course of the next few years get to be faster than -fvia-C has been, assuming that what gets discussed on the mailing lists will come to pass. :)
18:09:11 <LZ_2008> hello ppl can any one help me with this  "sum List" at http://hpaste.org/4913
18:09:16 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
18:09:18 <lambdabot> Title: 5.9. Optimisation (code improvement), http://tinyurl.com/254c66
18:10:05 <LoganCapaldo> LZ_2008: ddi you try it?
18:10:22 <faxlore> MyCatVerbs: I wrote a simple theorem prover!
18:10:23 <LZ_2008> yes but i get error
18:10:25 <faxlore> Really.. simple..
18:10:45 <LoganCapaldo> well your type annotation is incorrect which is probably the soure of the rror
18:11:10 <LoganCapaldo> soma :: [[Int]] -> [Int]
18:11:10 <gwern> can you specify list length in a sig like that?
18:11:14 <LoganCapaldo> no
18:11:15 <MyCatVerbs> faxlore: that puts your count of theorem provers written thus far at least one higher than mine, then. Nice going. :)
18:11:58 <LoganCapaldo> oh wait
18:11:59 <LZ_2008> let me tri that but i dont think it will work
18:12:04 <MyCatVerbs> LZ_2008: perhaps you wanted tuples, not lists?
18:12:04 <LoganCapaldo> that's the wrong type too <g>
18:12:20 <MyCatVerbs> [(Int, Int, Int)] -> (Int, Int, Int) instead.
18:12:31 <LoganCapaldo> @type soma b n m = [ x + c + v | x <- b, c <- n, v <- m ]
18:12:34 <lambdabot> parse error on input `='
18:12:43 <LoganCapaldo> @type let soma b n m = [ x + c + v | x <- b, c <- n, v <- m ] in soma
18:12:44 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t] -> [t]
18:13:08 <LoganCapaldo> als
18:13:10 <LoganCapaldo> *also
18:13:47 <LoganCapaldo> > [ (x,y, x + y ) | x <- [1,2,3], y <- [10, 20, 30] ]
18:13:49 <lambdabot>  [(1,10,11),(1,20,21),(1,30,31),(2,10,12),(2,20,22),(2,30,32),(3,10,13),(3,20...
18:14:22 <LoganCapaldo> > zipWith (\x y -> (x, y, x + y)) [1,2,3] [10,20,30]
18:14:22 <lambdabot>  [(1,10,11),(2,20,22),(3,30,33)]
18:14:59 <MyCatVerbs> LZ_2008: tiny tip to save you some head scratching: haskell uses -- for comments, rather than //. (no idea why, presumably some of the Haskell developers like the idea of using // as an operator)
18:15:38 <LZ_2008> sorry about that
18:16:02 <LZ_2008> [[1,2,3],[4,5,6],[7,8,9]]
18:16:03 <LZ_2008> [12,15,18]
18:16:15 <faxlore> :t (//)
18:16:16 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:16:20 <MyCatVerbs> LZ_2008: what on Earth are you apologising for? :) I'm just trying to save you some time.
18:16:56 <MyCatVerbs> LZ_2008: is the number of elements in each of those lists fixed?
18:16:56 <Pseudonym> Miranda used ||
18:17:01 <ddarius> > let f [[1,2,3],[4,5,6],[7,8,9]] = [12,15,18] in f [[1,2,3],[4,5,6],[7,8,9]]
18:17:01 <lambdabot>  [12,15,18]
18:17:19 <Pseudonym> But || was too useful for "or".
18:17:25 <MyCatVerbs> Pseudonym: well, it's nice to know that nobody's bothered basing what to use on what anyone else uses, then. ;)
18:17:27 <Pseudonym> So -- was the closest equivalent.
18:17:37 <LZ_2008> yes  its fixed
18:17:47 <faxlore> :t (||)
18:17:47 <lambdabot> Bool -> Bool -> Bool
18:17:49 <LZ_2008> but i can do to not fixed if its more easy
18:17:49 <MyCatVerbs> Pseudonym: ahhh. What does ML use, out of curiosity? (If you happen to know offhand.)
18:17:57 <faxlore> (* ... *)
18:17:59 <Pseudonym> Well, Miranda used || because it was close to a certain type of mathematical notation.
18:18:06 <MyCatVerbs> ddarius: that was mean. :)
18:18:33 <MyCatVerbs> faxlore: ahhhh, yes. Oh well.
18:19:36 <MyCatVerbs> faxlore: at least the various functional languages tend to *look* fairly distinctive. No chance of confusing Haskell for OCaML, unlike the near-incestuous similarities between the curly-braces languages (C(++), Java, C#...)
18:19:43 <LoganCapaldo> don't forget about {-- --}
18:19:51 <MyCatVerbs> Pseudonym: hair enough.
18:20:05 <MyCatVerbs> *fair... no, actually, I prefer "hair enough", sounds cooler.
18:20:12 <LoganCapaldo> I dunno, let x = 1 is valid haskell and ocaml :P
18:20:31 * dcoutts_ has hair enough
18:21:32 * MyCatVerbs has hair too much, and should possibly consult a barber.
18:22:00 <aFlag> Pseudonym, miranda used || for comments?
18:22:04 <MyCatVerbs> LoganCapaldo: well, if you're going to be pedantic, that's also valid QBASIC. =D
18:22:26 <aFlag> LoganCapaldo, {- -}, no? you don't need the extra -
18:22:30 <aFlag> I don't think
18:22:40 <ddarius> (* *)
18:22:40 <ddarius> Does it have line comments?  I forget.
18:22:59 <MyCatVerbs> aFlag: you're right, but {--- foo! swear words and to HELL with the world! ---} is prettier.
18:23:09 <aFlag> how come?
18:23:26 * dcoutts_ notes that cabal install can install cabal and indeed cabal-install
18:23:49 <MyCatVerbs> aFlag: they look like stabbing implements.
18:24:07 <Pseudonym> aFlag: IIRC, yes.
18:24:15 <ddarius> Pseudonym: Which?
18:24:29 <aFlag> I like -- for comments. It's kinda how you comment on text -- at least in English and Portuguese.
18:25:06 <Pseudonym> Miranda using || for comments.
18:25:26 <aFlag> || looks weird for comments, I'm too used to || being or
18:25:54 <MyCatVerbs> aFlag: personally, I would prefer nesting versions of // and /* */
18:27:14 <ddarius> Pseudonym: I was wondering which mathematical notation.
18:27:24 <LZ_2008> aFlag do you speak pt?
18:27:32 <MyCatVerbs> aFlag: but only by a tiny margin and, fuck it, syntax is irrelevant by comparison to the importance of semantics. I'd be happy using Scheme syntax, or even Prolog's, for Pete's sake (do you know anyone called Pete? Me neither), in return for nice enough language semantics. :)
18:27:36 <Pseudonym> Oh, right.
18:28:02 <Pseudonym> I think it's rare, but I have seen two vertical lines for a comment-like remark.
18:28:18 <aFlag> LZ_2008, yep
18:28:49 <LZ_2008> br or pt
18:28:51 <aFlag> I don't think prolog syntax is that bad
18:28:51 <aFlag> br
18:29:03 <faxlore> you gotta write in CPS though
18:29:10 <LZ_2008> nice to now im from pt
18:29:14 <gwern> MyCatVerbs: actually, I did know someone named Pete. he was one of my taekwondo instructors until he left to run his own school
18:29:14 <faxlore> unless you have evaluators
18:29:16 <aFlag> cool
18:29:37 <BMeph> Speaking of Portuguese, Lua also uses "--" for one-line comments.
18:29:45 <aFlag> I never tried lua
18:29:47 <allbery_b> sql
18:29:47 <aFlag> seems nice
18:30:22 <aFlag> LZ_2008, where in portugal are you from?
18:30:34 <LZ_2008> algarve
18:32:16 <aFlag> cool, a cousin of mine attended one semester to an university in lisboa
18:32:42 * ddarius thinks we should all switch to Smalltalk style comments
18:32:56 <aFlag> what are those like?
18:33:04 <ddarius> "comment"
18:33:17 <dcoutts_> or basic? :-)
18:33:20 <dcoutts_> REM blah blah
18:33:26 <Saizan> and string literals?
18:33:40 <aFlag> REM what does that mean? short for REMOVE?
18:33:45 <ddarius> 'string'
18:33:46 <jcreigh> REMARK, I think
18:33:47 <ddarius> remark
18:33:52 <LoganCapaldo> 'this is a msall talk string literal'
18:33:55 <MyCatVerbs> BMeph: oh cool. I've never used Lua myself, but I vaguely know a few people who do and none of them seem to hate it.
18:33:57 <LoganCapaldo> *smalltalk
18:34:02 <diltsman> How do I export functions I imported from a different module?
18:34:06 <dcoutts_> and m4 uses:
18:34:06 <dcoutts_> dnl this is a comment
18:34:25 <dcoutts_> so that's things like configure.ac and include.m4 files
18:34:38 <allbery_b> that';s only half the story
18:34:40 <aFlag> I kinda like lisp's comment. The ; is right there, easy to type, only one character, makes C programmers mad...
18:34:43 <diltsman> Not BASIC comments, please.  Anything but those....how about C99 comments?
18:35:00 <faxlore> prolog uses % for one liners
18:35:04 <Saizan> diltsman: put them in the export list
18:35:08 <allbery_b> # is a comment but m4 can expand stuff inside comments, so you need dnl to deleete the result
18:35:12 <ddarius> faxlore: As does postscript
18:35:19 <LoganCapaldo> bf comments are good too
18:35:38 <Saizan> diltsman: you can even put whole modules there, with "module Foo"
18:35:39 <LoganCapaldo> heck that sentecne was one :)
18:36:09 <dcoutts_> allbery_b: yeah, I head it was something like that but from the outside it looks like madness :-)
18:36:37 <allbery_b> most of m4 looks like madness from the outside
18:36:40 <MyCatVerbs> diltsman: those are just stolen (and rightfully so) C++ comments, though.
18:36:54 * allbery_b hacked m4 for years in a previous job
18:37:23 <allbery_b> money quote (from the original m4 manpage) "use of the -e option requires a special state of mind"
18:37:35 <aFlag> allbery_b, what did you use it for?
18:37:35 <runar> Is it possible to parameterize modules?
18:37:42 <MyCatVerbs> allbery_b: oh damn, hilarious and scary at the same time. Hilariously scary?
18:37:51 <diltsman> Saizan: That was what I needed, thanks.
18:38:23 <allbery_b> (m4 -e:  to wrap an interactive shell.  **shudder**)
18:38:42 <MyCatVerbs> Whoaaaaaa
18:38:53 <MyCatVerbs> m4 was originally designed for *RATFOR*!?
18:38:59 <allbery_b> I worked with Unify's Accell 4GL.  which had at least 3 incompatible versions (and partially compatible sub-versions).  some of which I had to support simultaneously
18:39:02 <MyCatVerbs> That's some pedigree. I mean, nice.
18:39:33 <allbery_b> I wrote up some huge m4 macro packages (20K+ lines) to make it possible to write a singel form script which would work with all versions
18:39:37 <diltsman> I'm just lucky, all I have to deal with at work is VC++ 6.0 because they won't upgrade their Fortran compiler.
18:39:52 <hpaste>  travisbrady pasted "Column summer in re to LZ_2008" at http://hpaste.org/4914
18:40:06 <allbery_b> scary stuff.
18:40:29 <allbery_b> m4 is actually quite consistent and logical --- but in a way that human minds don't handle very well.
18:40:44 <aFlag> diltsman, do you program with fortran?
18:40:58 <allbery_b> "requires a special state of mind" applies to much of m4, not just the old -e option
18:41:21 <MyCatVerbs> allbery_b: I can't seem to (easily) find a specification, or any sort of tutorial on m4 through googling.
18:41:44 <runar> For instance, I would like to write a module such that its user can specify for the entire module whether it uses Float or Double.
18:41:50 <aFlag> working with m4 must be real nasty
18:41:54 <allbery_b> I don't think I've ever seen one.
18:41:58 <MyCatVerbs> allbery_b: or, Hell, any links to such from the GNU m4 site. Where'd you pick it up?
18:42:11 <allbery_b> I learned it from volume 2 of the unix programmer's manual, the part that wasn't manpages
18:42:42 <MyCatVerbs> Oh wait, GNU re-did their m4 site. A lot. It's actually useful now. x_x
18:42:49 <allbery_b> mostly academic-style papers (wonder where else I've seen that?) on awk, m4, lexx, yacc, various other programming-related utilities
18:43:01 <gwern> (a lot of hackage is broken. I'm barely through the bs and I already have 5 I should try to fix)
18:43:03 <EvilTerran> runar, you can put the entire module in a typeclass, if you want
18:43:21 <EvilTerran> ?instances RealFrac
18:43:24 <lambdabot> Double, Float
18:43:44 <allbery_b> unfortunately I don't think anyone ships it any more and it's not freely available that I've seen
18:43:44 <EvilTerran> or just have individual functions be appropriately polymorphic
18:43:44 <MyCatVerbs> Hahahaha. "Some people find m4 to be fairly addictive. They first use m4 for simple problems, then take bigger and bigger challenges, learning how to write complex sets of m4 macros along the way. Once really addicted, users pursue writing of sophisticated m4 applications even to solve simple problems, devoting more time debugging their m4 scripts than doing real work. Beware that m4 may be dangerous for the health of compulsive programmers."
18:43:58 <MyCatVerbs> From the GNU m4 manual. XD
18:44:10 <gwern> hee hee, 'cabal install cabal-install'
18:44:18 <gwern> it works :)
18:44:35 <aFlag> allbery_b, did you get addict to it?
18:44:39 <allbery_b> nope
18:45:03 <allbery_b> I came to understand it, but never came to like it
18:45:10 * MyCatVerbs could see himself getting addicted. Weird things that require one to twist one's brain sideways tend to attract him.
18:45:17 <gwern> (hm. cabal-test and cabal-upload don't though)
18:45:21 <allbery_b> (same with sendmail.cf.  yug)
18:45:36 <runar> EvilTerran: What do you mean by "put the entire module in a typeclass"?
18:46:04 <EvilTerran> runar, on reflection, i'm not sure what that was supposed to mean
18:46:12 <runar> :-)
18:46:22 <MyCatVerbs> allbery_b: is sendmail.cf Turing-complete? :)
18:46:31 <runar> I will use RealFrac. Thanks!
18:46:34 <EvilTerran> runar, but type-parameterised modules're made pretty obselete by class-based polymorphism
18:46:55 <allbery_b> MyCatVerbs: thing is, it's not a very interesting form of sideways
18:47:15 <diltsman> aFlag: I don't program Fortran (I can read it), but the guy who started the project 2-3 years ago was a Fortran programmer.  Since some of the stuff doesn't have any way to interface with Fortran, I'm doing the interfacing in C/C++.
18:47:32 <EvilTerran> runar, i guess i meant module MyModule (...) where class MyModule a where { all the functions of the module, as methods with default implementations }
18:47:32 <gwern> MyCatVerbs: http://okmij.org/ftp/Computation/sendmail-as-turing-machine.txt :)
18:47:51 <runar> Oh? What to do if I have several classes, all of which share the same type parameter?
18:47:58 <MyCatVerbs> gwern: heh. I had heard something along those lines.
18:48:15 <EvilTerran> runar, as then you could introduce an instance for any particular type you wanted to work with the module on
18:48:15 <runar> My module contains classes. I didn't think classes could be nested.
18:48:22 <gwern> 'stack overflow: use +RTS -K<size> to increase it' <-- o.0 not sure I ever got that error compiling before
18:48:25 <MyCatVerbs> allbery_b: what, m4 or sendmail.cf? Sendmail.cf is bollocks, yesh. m4, I'm not so sure about.
18:48:26 <EvilTerran> but, that's abusing the typeclass system. don't do it. :P
18:48:35 <gwern> has anyone successfully installed 'cedict-0.1.1'?
18:49:06 <EvilTerran> runar, i just meant that as a demo of a simple type-parameterised-module -> typeclass transformation
18:49:44 <EvilTerran> there's far better ways of achieving the same thing
18:50:51 <runar> EvilTerran: Oh, I see. But say I have a module with several classes which declare functions for manipulating numbers. Any user of the module will want all the functions to manipulate the same type of number.
18:52:10 <EvilTerran> why make the restriction?
18:52:41 <EvilTerran> write all the functions to be independently polymorphic; it's not your business if people want to use it with more than one numeric type
18:53:46 <MyCatVerbs> dcoutts_, dons: y'know how there was a lot of traffic on haskell-cafe about building up a library of programs to be able to test for performance regressions with GHC?
18:53:57 <dcoutts_> MyCatVerbs: yep
18:54:03 <dcoutts_> it's a good idea
18:54:13 <EvilTerran> runar, if you have a *really* good reason to restrict 'em all to one type but let the user of the module choose which type, you can do that with fundeps
18:54:19 <MyCatVerbs> Would it be a sane idea to, as well as all these nicely written and decently optimized things using all the fast APIs (bytestrings, etc)...
18:54:33 <runar> EvilTerran: OK, thanks. I will look at that.
18:54:36 <MyCatVerbs> ...add in, oh, a large fistful of programs written in an extremely naive manner?
18:54:42 <EvilTerran> class Foo a | -> a; foo :: Foo a => a -> a; bar :: Foo a => a -> Int -- etc
18:54:47 <dcoutts_> MyCatVerbs: sure
18:55:03 <EvilTerran> (nb i didn't give the class a where{} clause)
18:55:19 <EvilTerran> runar, but do you *have* a *really* good reason? ;)
18:55:47 <MyCatVerbs> dcoutts_: I ask because I'm quite capable of generating mountains of shite code, but so far useless at fast Haskell programs (I've never tried yet, to be honest). Also, I have some pretty godawful code hanging around on disk that I'm using for courseworks and the like.
18:56:16 <MyCatVerbs> (Godawful from the POV of performance, I mean. It's not *totally* byzantine and crap, just largely so. ;)
18:56:19 <dcoutts_> MyCatVerbs: :-) I think it's useful to have naive code so long as it's short and easily comprehensible
18:56:30 <runar> EvilTerran: It's not really that good. Just wanted a shorthand for saying "use Float throughout and don't bother me"
18:56:58 <EvilTerran> inference should mean you won't need that many type annotations
18:57:01 <MyCatVerbs> dcoutts_: plus, some of what I have kinda works the shit out of Concurrent Haskell, or would if it didn't have a giant block-on-real-world sitting in the middle of one of the feedback loops. :)
18:57:46 <EvilTerran> and you could make all your annotations of a type synonym so you can change 'em all from one place
18:57:47 <MyCatVerbs> dcoutts_: (personally, I find CH to be something of a killer feature for Haskell. Not even Java seems to make concurrency this... easy.)
18:58:01 <EvilTerran> "not even java"?! hah!
18:58:12 <MyCatVerbs> EvilTerran: hey, it's heaven if you're used to C. :)
18:58:26 <EvilTerran> thankfully, i am used to doing threading in neither :D
18:58:26 <faxlore> truth
18:58:45 <dcoutts_> Saizan: try pulling cabal-install again, should be fixed
18:59:06 <runar> MyCatVerbs: Concurrency in Java is not easy.
18:59:15 <MyCatVerbs> runar: chances are you want to use Doubles anyway, though. AFAIK, GHC does a better job of optimizing things when you use Doubles (I think there's a more complete set of rewrite rules in place). Only when you're dealing with large quantities of packed floats (and worried about fitting them inside your CPU's cache) would you want to use Floats.
18:59:30 <EvilTerran> @where+ default http://haskell.org/onlinereport/decls.html#default-decls
18:59:30 <lambdabot> I will remember.
18:59:33 <diltsman> Threading isn't too bad in C++ if you use Boost.Thread
18:59:39 <EvilTerran> runar, that ^^ link might be relevant to your interests
18:59:52 <MyCatVerbs> runar: I haven't found an imperative language in which threading is easier than in Java.
19:00:01 <Valodim> true dat
19:00:02 <diltsman> What is the difference between type and newtype?
19:00:13 <MyCatVerbs> diltsman: tiny tiny semantic difference.
19:00:36 <EvilTerran> MyCatVerbs, actually, that one's pretty big
19:00:37 <diltsman> MyCatVerbs: No doubt, but anybody know where I can find what that is?  (I'm a glutton for punishment)
19:00:41 <MyCatVerbs> diltsman: newtype can only be used where you have exactly one constructor. In many cases, it allows the constructor to be optimized away.
19:00:43 <EvilTerran> you may be thinking of data/newtype
19:00:57 <MyCatVerbs> EvilTerran: oh, whoops.
19:01:04 <runar> MyCatVerbs: I'll agree with that. My not keeping up with Pascal notwithstanding.
19:01:07 <monochrom> Threading isn't too bad in C++ if you use Haskell.
19:01:07 <EvilTerran> diltsman, "type" creates two types that the typechecker can't tell apart
19:01:07 <MyCatVerbs> diltsman: disregard that, I'm talking bullshite.
19:01:16 <diltsman> So, type is like typedef in C, and newtype and data are similar, except newtype only allows for 1 constructor?
19:01:26 <MyCatVerbs> diltsman: yes, right.
19:01:33 <EvilTerran> diltsman, but "newtype" makes the two types distinct, using the constructor you give to disambiguat
19:01:37 <MyCatVerbs> diltsman: *that* is right. What I said was bumf. :)
19:01:50 <MyCatVerbs> monochrom: what do you mean by that?
19:01:56 <EvilTerran> also newtype requires exactly one parameter for the constructor
19:02:08 <Saizan> dcoutts_: yes, nice :)
19:02:10 <monochrom> It means switch to Haskell. :)
19:02:30 <gwern> wow. I'm half through the Es, and I've found 27 broken packages (excluding ones broken because a dependency is broken)
19:02:43 <davidL> @remember monochrom Threading isn't too bad in C++ if you use Haskell.
19:02:43 <lambdabot> Nice!
19:02:44 <MyCatVerbs> monochrom: heh. I thought for a moment you meant "write some stuff in C++, then have Haskell call it through FFI to handle all the multithreading."
19:02:48 <diltsman> monochrom: lol  I just wish I could use Haskell for most things.  I love C++, but I'm finding I like Haskell more.
19:02:53 <gwern> (and EtherBunny is the next to bite the dust...)
19:03:07 <dcoutts_> Saizan: you mean it's working for you now? btw, I also added a warning to try to get people to specify build-type:
19:03:09 <EvilTerran> diltsman, newtype and type are similar in that they create an alias of an existing type
19:03:19 <davidL> gwern: what is up with etherbunny?
19:03:30 <MyCatVerbs> gwern: EtherBunny?
19:03:36 <gwern> davidL: 'cabal install EtherBunny' fails
19:03:37 <EvilTerran> diltsman, but data and newtype are similar in that they create a type that's distinct from any existing types at the type-checking stage
19:03:44 <EvilTerran> (type doesn't)
19:03:47 <gwern> (fenfire is next)
19:03:51 <runar> Is that similar to a VorpalBunny?
19:04:08 <MyCatVerbs> Ohhh, piece of software. Heh. Had me wondering, since I know someone who uses that nickname on IRC. :)
19:04:09 <gwern> no idea
19:04:09 <EvilTerran> diltsman, and data creates a type that can be structurally different from any existing type
19:04:21 <EvilTerran> (unlike type and newtype)
19:04:33 <diltsman> data I had figured out, and type, but newtype what what had me confused.
19:04:40 <davidL> etherbunny is like a packet parser for the ethernet, tcp, and ip protocols
19:04:58 <MyCatVerbs> EvilTerran: newtype's constructor can take more than one parameter though, right?
19:05:06 <Saizan> dcoutts_: yeah it works, and i agree on encouraging build-type, and i've just noted that install is case-sensitive in package names, a bit surprising
19:05:06 <EvilTerran> MyCatVerbs, no; not less than on3
19:05:11 <EvilTerran> er, one
19:05:15 <EvilTerran> also "nor"
19:05:27 <dcoutts_> Saizan: there's a bug open about that if you want a small task :-)
19:05:47 <gwern> dcoutts_: what does build-type do anyway? I use it, but I don't understand why
19:05:49 <MyCatVerbs> EvilTerran: oh, it has to be exactly one? I presume that parameter can be a tuple, though?
19:05:54 <EvilTerran> MyCatVerbs, seeing as it's a wrapper for a single type, it wouldn't really make sense
19:06:03 <dcoutts_> gwern: it means we can avoid using Setup.hs at all in most cases
19:06:16 <gwern> oh. that's good?
19:06:17 <EvilTerran> other than by doing implicit tupling, and, yes, it's more in the spirit of haskell to just tuple explicitly
19:06:17 <LoganCapaldo>   newtype A = A Int Int, what type is Int Int ?
19:06:35 <MyCatVerbs> EvilTerran: yes, it would be silly. But still, fun. :)
19:06:58 <EvilTerran> if you were doing implicit tupling, you might as well go the whole hog and do implicit Either'ing as well, thus defeating the whole point :P
19:07:01 <dcoutts_> gwern: which 1. is faster, 2. is less prone to breakage, 3. good for security of build bots as it means not executing unknown untrusted code
19:07:51 <dcoutts_> gwern: it also means you don't need to supply a Setup.hs file which is a small bonus for developers
19:07:59 <MyCatVerbs> EvilTerran: oooh, good idea.
19:08:35 <MyCatVerbs> EvilTerran: newtype Foo = Fooonst (Either (Int,Int) (Int,Int -> Int)) -- ;)
19:08:44 <gwern> dcoutts_: I do like that, yes. Setup.hs always struck me as redundant...
19:08:45 <sjanssen> dcoutts_: you still need Setup.hs for backwards compat, right?
19:09:03 <sjanssen> for all those people that aren't using the 'cabal' executable
19:09:06 <EvilTerran> ...
19:09:09 <dcoutts_> sjanssen: for the moment, yes.
19:09:12 <EvilTerran> I'm going to bed now.
19:09:24 <MyCatVerbs> Eh? Setup.hs getting replaced? *peeks at the backscroll*
19:09:33 * Saizan still uses cabal-setup
19:10:24 <MyCatVerbs> dcoutts_: I don't see the problem with executing untrusted code in Setup.hs. If you don't trust the person who wrote Setup.hs, how're you going to trust the person who wrote the damn *library* you're compiling? Since they're generally the same person or people...
19:10:45 <faxlore> can't you just open it? :p
19:10:48 <faxlore> and check
19:11:00 <MyCatVerbs> faxlore: no, I'm lazy. :)
19:11:01 <allbery_b> up to a point, yes
19:11:25 <TomMD> Curiously - how does one determine the endianness of the current machine?  I see you can abuse Data.Binary or parse the architecture string from System, but I can't find a preexisting value isBigEndian :: Bool
19:11:31 <allbery_b> but it's easy to miss stuff, even when it's not hyper-obscure (cf. "Reflections on Trusting Trust")
19:11:57 <MyCatVerbs> allbery_b: oh, that was quite an incredible feat of bastardry, heh.
19:12:15 <dcoutts_> MyCatVerbs: I don't generally have to run your code to be able to compile it or to compile the docs
19:12:38 <dcoutts_> MyCatVerbs: there are exceptions, like TemplateHaskell but it's possible to black-list that too
19:12:47 <MyCatVerbs> dcoutts_: this is true.
19:12:55 <gwern> in the Gs, more than 38 broken packages... I'm getting really sick of the 'package hidden' error :)
19:13:15 * gwern wonders what the heck a 'gopherbot' package would be good for
19:13:17 <MyCatVerbs> dcoutts_: I presume the security of buildbots isn't the *only* reason to replace Setup.hs though, right?
19:13:37 <dcoutts_> MyCatVerbs: not the only one
19:15:06 <Saizan> MyCatVerbs: when using cabal or cabal-setup is quite annoying to compile another exec just to do the same work
19:15:46 <MyCatVerbs> Saizan: eh? But one usually uses runghc/runhaskell anyway, not much pain aside from the (irrelevant) speed penalty.
19:16:30 <dons> TomMD: you can use CPP
19:16:39 <Saizan> s/is/it's/
19:16:51 <dons> oh, maybe you can't, actually
19:17:13 <Saizan> MyCatVerbs: "usually" because you've not installed those yet!
19:17:46 <MyCatVerbs> Saizan: when have you not installed runghc? Se cometh with GHC...
19:20:02 <Saizan> MyCatVerbs: by those i meant cabal-install or cabal-setup, sorry
19:20:48 <sjanssen> there is so much FUD about laziness and space usage lately, it is quite sad
19:20:57 <MyCatVerbs> Saizan: I think I'm out of sync with this conversation. :)
19:21:20 <MyCatVerbs> sjanssen: mmmm, I'd say there's something of a point to it.
19:21:36 <sjanssen> MyCatVerbs: yes and no
19:22:01 <allbery_b> wasn't the main problem with Setup.hs that it was either (a) one-liner boilerplate or (b) complex and fragile (and better handled these days in the cabal file)?
19:22:14 <MyCatVerbs> sjanssen: imagine that every single function you write gets transformed by "\x -> unsafePerformIO (putStr ".") >> return x"
19:22:37 <MyCatVerbs> sjanssen: then attempt to work out exactly how many .'s will have been dumped onto stdout by the end of your program run. :)
19:22:40 <sjanssen> what everyone has forgotten, it seems, is that lazy evaluation can also have asymptotically *better* space usage
19:23:06 <sjanssen> MyCatVerbs: why does that matter?  Also, that seems more to be about time than space
19:23:33 <monochrom> Where is the FUD?
19:23:36 <MyCatVerbs> sjanssen: indeed it is. I don't think space is anything like such an issue.
19:24:03 <monochrom> Anyway the whole bloody computer industry is based on FUD.
19:24:27 <sjanssen> monochrom: eg. slava's comment on http://programming.reddit.com/info/654xq/comments/
19:24:33 <dons> sjanssen: 'laziness' 'space leaks' is the single-issue pigeon hole for haskell
19:24:45 <dons> like 'slow' for ruby, or 'parenthesis' for lisp
19:24:47 <MyCatVerbs> sjanssen: personally, I get the impression that it's fine in practice, since (using -Sstderr to look for memory leaks while the program runs) the last interesting program I wrote had no space leakage at all, without me putting any effort into worrying about its' space efficiency at all.
19:25:20 <sjanssen> MyCatVerbs: this is my experience as well.  I can't remember the last time I fixed a space leak in my own code
19:25:40 <dons> yeah. the only space leaks i fix are on -cafe@ :)
19:26:11 <monochrom> @remember dons the only space leaks i fix are on -cafe@ :)
19:26:11 <lambdabot> Good to know.
19:26:11 <MyCatVerbs> sjanssen: (well, except that I did use seq in one place, but that was only to assign unique ID numbers to each of a list of consecutive records).
19:26:46 <dons> sjanssen: slava's used this 2 days in a row, btw
19:26:57 <dons> and then it was raised as a red herring on the ocaml thread today
19:27:21 <dons> talking about equational reasoning, someone throws in the "yeah, but ... space usage!" bomb
19:27:22 <sjanssen> the thing is, there is some truth to this issue -- so I can't just say "you're wrong"
19:27:31 <MyCatVerbs> sjanssen: (and yeah, that would've been an O(n^2) space waste, except that the program would pretty much immediately evaluate most of those thunks as soon as a single client connected to it to do anything useful, anyway. ¬_¬)
19:27:59 <gwern> no, not you too hmp3!
19:28:54 <monochrom> This reminds me of someone's quote. "The problem with fools is they're so sure of themselves. The problem with intelligent people is they're so doubful of themselves."
19:28:58 <MyCatVerbs> dons: well, "slow" is true for Ruby, "parenthesis" is true for Lisp (though I do contend that anyone stupid enough to be incapable of, oh, I dunno, mashing on the % key in vim? Is too stupid to be trusted to write computer programs that actual people will end up having to use to do their jobs)...
19:29:27 <gwern> monochrom: 'the best lack all conviction, while the worst are full of a fiery intensity'?
19:29:38 <sjanssen> MyCatVerbs: I think the analogy is good, because the truth is that those issues aren't as problematic as you might think
19:29:42 <MyCatVerbs> dons: "space leaks" is pretty much irrelevant for Haskell in practice, but "usually uses quite a bit of RAM" is true, what with things like [Char] being the norm.
19:30:03 * MyCatVerbs wonders how Haskell compares to Java for memory usage.
19:30:05 <dons> 5108K sleep/0  poll      0:00  0.05% xmonad
19:30:11 <monochrom> Actually something like "The problem with the world is the fools are so sure of themselves and the intelligent people are so doubtful of themselves."
19:30:13 <dons> 101M sleep/0  poll      1:14  0.00% firefox
19:30:15 <dons> :)
19:30:25 <MyCatVerbs> sjanssen: well... I'd agree with you except for Ruby.
19:30:32 <dons> 7576K sleep/0  select    0:00  0.05% urxvt
19:30:36 <monochrom> It definitely leads to the fools dominating all issues.
19:30:43 <sjanssen> MyCatVerbs: nobody uses Ruby to write speed-intensive code, all lisp users use good editors, laziness only blows up in rare cases, etc.
19:30:50 <MyCatVerbs> sjanssen: the Ruby 'terp is, I am informed, slower than even fucking TCL.
19:31:29 <MyCatVerbs> sjanssen: that is something special, dammit, considering that TCL is built on the "everything is a string" model.
19:31:38 <sjanssen> MyCatVerbs: yes, but the argument is that it is usually fast enough -- and that's true
19:32:29 <dons> at least we dont' hear "haskell's slow" anymore.
19:32:31 <dons> that used to be hte label
19:32:35 <gwern> dunno. the TCL interpreter has had like almost 2 decades now. I'd be surprised if they hadn't added in quite a few optimizations
19:32:37 <MyCatVerbs> sjanssen: dunno, I keep hearing bad things about its interpreter. And I hear, "well, you can always scale it horizontally," more often that I hear, "it's I/O bound anyway" or "it's database-bound anyway". :/
19:32:37 <monochrom> hehehe
19:32:38 <sjanssen> (last time you'll find me defending Ruby, I bet :) )
19:32:44 <dons> guys who only remember the old news (like jdh30) still trot that one out
19:32:47 <MyCatVerbs> gwern: nope, I'm informed.
19:32:48 <dons> but it used to be ubiquitous
19:33:05 <dons> so critics need a different label
19:33:07 <MyCatVerbs> gwern: that flies in the face of their vision for the project, apparently.
19:33:17 <monochrom> They are critics?
19:33:28 <monochrom> Critics are actually rational.
19:33:28 <dons> everyone's a critic
19:33:29 <gwern> MyCatVerbs: really? they've deliberately kept it slow?
19:33:31 <sjanssen> dons: I'm keeping this eta-expansion/pointfree example in my pocket for anti-jdh ammo :P
19:33:46 <dons> heh :)
19:33:56 <MyCatVerbs> gwern: no, they've deliberately not complicated the living shit out of the interpreter. But they have a number of reasonably clever things, like variables are cached.
19:34:12 <monochrom> I'd call them haters.
19:34:40 <MyCatVerbs> gwern: e.g. if you use a string as a number, the interpreter caches the integer conversion, so that you're not constantly re-reading the same string over and over again.
19:34:42 <gwern> MyCatVerbs: I deny that a fast interpreter/compiler has to be complicated - I was impressed by the elegant design of the sausage scheme compiler, for example, which was fairly fast
19:35:04 <MyCatVerbs> gwern: (and also, for obvious reasons, invalidates the cache if you alter it using string manipulation functions)
19:35:56 <MyCatVerbs> gwern: it does if your language semantics revolve around everything being a string, and alterable at run-time using string manipulation functions.
19:36:28 <MyCatVerbs> gwern: it also does require massive complication to make things fast in the face of having eval in the language - which TCL does.
19:37:17 <gwern> scheme has eval
19:37:18 <MyCatVerbs> gwern: e.g. you can concatenate, apply regexes to, paste together and split apart the strings that represent your program in TCL. I have a vague suspicion that that makes it one of few languages actually more expressive than Lisp. ;)
19:37:48 <MyCatVerbs> gwern: yes, and it comes with huge dire warnings about it being blastedly slow.
19:37:55 <gwern> 'setup: The pkg-config package hyperestraier version >=1.4.9 is required but it could not be found.' <-- wow, what on earth does that mean?
19:38:17 <faxlore> you can do that in lisp too
19:38:18 <faxlore> though
19:38:25 <sjanssen> gwern: it means install hyperestraier
19:39:00 <gwern> sjanssen: yeah, but that's what I was doing!
19:39:13 * LoganCapaldo wonders idly if jruby or 1.9 are "faster" than tcl
19:39:14 <MyCatVerbs> faxlore: this is true, but doesn't everybody use macros instead, since they're always faster?
19:39:26 <sjanssen> gwern: the C library called hyperestraier (pkg-config is something like a package manager for C)
19:39:43 <gwern> oh. that makes sense then
19:39:54 <MyCatVerbs> LoganCapaldo: dunno. Perhaps they are.
19:40:17 <MyCatVerbs> LoganCapaldo: but a good dynamic language implementation ought to be able to smoke TCL. AFAIK, Python and Perl both do so easily.
19:41:23 <LoganCapaldo> who says ruby's impl. is good?
19:41:33 <dons> we really need to get haskell running on lego, http://jpbrown.i8.com/cubesolver.html
19:41:33 <lambdabot> Title: JP Brown's Serious LEGO - CubeSolver
19:41:36 <faxlore> I don't like it much
19:41:39 <faxlore> there's a lot of code though..
19:41:43 <LoganCapaldo> yes
19:41:50 <dons> lego haskell seems like a killer app -- clean language, high level algos, low level robot fun
19:41:55 <LoganCapaldo> haskell/lego is essential
19:41:55 <MyCatVerbs> LoganCapaldo: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=tcl&lang2=ruby -- ever so slightly in TCL's favour there, I think. Compare and contrast with http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=tcl&lang2=python -- where Python totally smokes TCL.
19:42:00 <lambdabot> Title: Tcl benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language Ben ..., http://tinyurl.com/3ye9og
19:42:15 <LoganCapaldo> MyCatVerbs: err I ddin't doubt you
19:42:19 <MyCatVerbs> LoganCapaldo: no, it isn't. That precisely the thing. Ruby may be an awesome language but it has a terrible implementation.
19:42:41 <MyCatVerbs> LoganCapaldo: oh, my bad.
19:42:57 <dons> so there's just some C/C++ interface to the lego kit?
19:43:11 * MyCatVerbs is curious...
19:43:25 <MyCatVerbs> Oh wow, Perl and Python are pretty evenly matched there.
19:43:50 <dons> can everyone click on the ruby/ghc comparison, and feel good about the world.
19:43:51 <phobes> lego doesn't qualify as "killer app" until more people rush to program robots :)
19:44:00 <dons> 20 years of research in one graph :)
19:44:56 <skew> Not until the gcc/ghc one looks the same way :)
19:45:55 <monochrom> Let's write an optimizing Ruby compiler in Haskell.
19:45:58 <dons> the hcar this month gave me some hope -- there's serious backend research happening now.
19:46:07 <MyCatVerbs> monochrom: ...why?
19:46:14 <gwern> 'cabal: user error (Unresolved dependencies: ghc >=6.6&&<6.8)' <-- interesting requirement :)
19:46:16 <dons> yeah, i've been saying for 2 years -- if you want to get super famous, just do a simple ruby compiler in haskell, that wipes the floor
19:46:17 <monochrom> Powerful static analyses to eliminate most dynamic dispatch.
19:46:19 <gwern> must be using the GHC API
19:46:20 <MyCatVerbs> monochrom: admittedly it wold be funny.
19:46:36 <MyCatVerbs> monochrom: would a Ruby-to-Haskell compiler count?
19:46:41 <dons> i better translating ruby to haskell, and compiling with ghc, would beat the current ruby interpreter :)
19:46:45 <monochrom> dunno.
19:46:51 <dons> MyCatVerbs: i reckon so. :)
19:46:58 <MyCatVerbs> dons: brilliant idea.
19:47:00 <dons> and you can use unboxed types and so on.
19:47:00 <skew> Translating Python to OCaml doesn't seem to beat CPython
19:47:03 * MyCatVerbs wonders if Ruby has a spec.
19:47:05 <Valodim> how come haskell is losing in most disciplines against most languages in gzip bytes in the shootout?
19:47:27 <dons> Valodim: gzip is a floored benchmark, and the haskell code's not optimised for shortness -- but for speed
19:47:30 <skew> One of Walid Taha's students has something like that, just implementing stuff with classes and so on
19:47:32 <monochrom> Because gzip bytes is unfair IMO.
19:47:36 <gwern> dons: hey, what's this 'fps' dependency for lambdabot?
19:47:38 <MyCatVerbs> Valodim: gzip bytes measures what, the size of the generated executables?
19:47:41 <dons> Valodim: think about it. gzip rewards repetition :)
19:47:46 <Valodim> hah
19:47:47 <dons> gwern: i think you've got old code.
19:47:48 <Valodim> yeah
19:47:51 <Valodim> yeah I just thought of that
19:47:56 <Valodim> more repetition = better compression
19:47:59 <Valodim> sweet
19:48:05 <allbery_b> gwern: fps is what's now called bytestrings
19:48:05 <monochrom> fps = fast packed string.
19:48:06 <gwern> dons: Hackage package
19:48:14 <dons> we could add a page of ;;;;;;;;;;;;;;;;;;;; to the end of every file, with no loss :)
19:48:22 <gwern> ouch. how *old* is the lambdabot package on hackage?
19:48:22 <dons> gwern: out of date by about 3 years.
19:48:32 <dons> it was the first or second package uploaded to the demo version of hackage
19:48:56 * gwern thinks that should be fixed :)
19:49:03 <dons> we'd have to do a release.
19:49:07 <monochrom> gzip hides some boilerplate code.
19:49:08 <dons> and to do that would require some QA on lambdabot
19:49:08 <gwern> the horror
19:49:11 <dons> which i can't do.
19:49:33 <dons> gwern: btw, thanks for fixing all these :)
19:50:01 <gwern> dons: I haven't even started. I'm just in the Ls and my list is 68 items long
19:50:19 <gwern> and that's omitting everything broken by C library depdencies or other Haskell dependencies...
19:50:32 <lambdabot> You're not QAing me, whatever that is.
19:50:33 * gwern adds lhs2tex to that list
19:50:42 <phobes> What's wrong with gzip as a measure?  That it doesn't much reward the common haskeller practice of using single letters and symbols for everything?
19:50:57 <monochrom> It doesn't punish boilerplate code.
19:51:13 <dons> oh man, look what being a commercial haskell developer is doing to me. i'm talking about "QA" all of a sudden
19:51:23 <skew> phobes: that it doesn't punish you for hving to type a long identifier bazillions of tims
19:51:26 <dons> corporate slave!
19:51:31 <gwern> dons: srsly, just clean up some warnings, and release
19:51:39 <dons> that would be ok :)
19:51:45 <gwern> it's not like anyone who uses lambdabot really needs stability
19:52:05 <gwern> or can't handle it
19:52:08 <dons> i'm more concerned that it builds and install :)
19:52:10 <phobes> monochrom, skew:  Ya, that's the point.  You dont want to reward a language like perl that has just as many "identifiers" but chooses obscure symbols for them
19:52:35 <skew> phobes: it's not the lengths of identitifers, but the number of times you have to mention them
19:52:49 <phobes> I agree "protected final static" should earn you two demerits tho
19:53:22 <phobes> skew:  mentioning them repeatedly will hurt your gzip score, though, right?
19:53:23 <monochrom> Imagine a language that has no function call whatsoever.
19:53:29 <skew> phobes: no, not really
19:53:39 <faxlore> 10 PRINT "HELLO WORLD"
19:53:39 <skew> like, 1 byte for the reference to coppy the first occurence
19:53:42 <faxlore> 20 GOTO 10
19:53:46 <faxlore> like this? :d
19:53:50 <skew> so it's like you magically invented a java where you can write
19:53:54 <sarehu> not hard to imagine, BF exists after all
19:54:03 <faxlore> you can do functions in BF
19:54:04 <skew> TypeName x = new _(args)
19:54:09 <faxlore> takes a bit of trickery
19:54:19 <sarehu> faxlore: what??
19:54:37 <dons> has anyone ever attempted a full pointfree translator?
19:54:38 <sarehu> assuming you don't first write an interpreter for another language and then fill memory with that language's code and call that...
19:54:47 <faxlore> [ >[ {func1 code} ] >[ {func2 code} ] >[ {func3 code} ] ... <<<]
19:54:52 <phobes> skew:  If you had named your class with one letter instead of giving it a sensible name, you'd be able to do that
19:55:03 <faxlore> or something along the lines
19:55:23 <dons> ? pl let map _ [] = [] ; map f (x:xs) = f x : map f xs in map
19:55:28 <dons> ?pl let map _ [] = [] ; map f (x:xs) = f x : map f xs in map
19:55:28 <lambdabot> (line 1, column 11):
19:55:28 <lambdabot> unexpected "["
19:55:28 <lambdabot> expecting pattern or "="
19:55:32 <gwern> ok! from A-L inclusive, there are at least 72 packages on Hackage which are broken with GHC 6.8.2 et al
19:55:38 <gwern> this is not good people
19:55:40 <sarehu> faxlore: I don't see the function call there... unless you're just referring to walking the stack
19:55:55 <skew> phobes: yeah, gzip basically compares size of the code as if you had used one character replacements for everything
19:56:00 <dons> ?pl let map _ xs = if xs == [] then else f (head xx) : map f (tail xs) in map
19:56:00 <lambdabot> (line 1, column 33):
19:56:00 <lambdabot> unexpected reserved word "else"
19:56:00 <lambdabot> expecting lambda abstraction or expression
19:56:02 <dons> bah
19:56:45 <phobes> skew:  That seems pretty fair to me... you don't want to punish people for using sensible identifiers
19:57:17 <Valodim> true
19:57:29 <Valodim> but it also works with much repetition otherwise
19:57:46 <monochrom> If you use token count, you will allow people to use good identifier names.
19:57:48 <phobes> Valodim:  Ya, that would be what I'd worry about
19:58:02 <monochrom> If you use gzip, you do a lot more than that.
19:58:02 <phobes> monochrom:  That seems like a better metric, I agree
19:58:12 <MyCatVerbs> ? pl let map f x = if null xs then [] else f (head x) : map f (tail x) in map
19:58:19 <MyCatVerbs> D'oh.
19:58:20 <MyCatVerbs> ?pl let map f x = if null xs then [] else f (head x) : map f (tail x) in map
19:58:21 <lambdabot> fix (((if' (null xs) [] .) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
19:58:23 <monochrom> gzip has side effects (in the medicine sense)
19:58:27 <MyCatVerbs> HOLY SHIT
19:58:32 <skew> phobes: the problem is that it fails to punish people for being forced to repeat the identifier lots of places
19:58:32 * MyCatVerbs runs and hides.
19:58:42 <MyCatVerbs> Can't sleep, @pl will eat me, can't sleep, @pl will eat me...
19:58:55 <monochrom> Imagine a language that allows no loops, no recursion.  Imagine the task of printing "hello" five times.
19:59:00 <LoganCapaldo> and it still needs if' :(
19:59:06 <MyCatVerbs> :t if'
19:59:09 <lambdabot> Not in scope: `if''
19:59:12 <sarehu> hah, MyCat just got 'fixed'
19:59:14 <monochrom> The imagined language forces you to write "print hello" 5 times.
19:59:21 <MyCatVerbs> sarehu: ...dammit. :)
19:59:28 <LoganCapaldo> when are we gonna get bool >
19:59:28 <faxlore> print "hellohellohellohello"
19:59:29 <MyCatVerbs> monochrom: that's not Turing complete, though.
19:59:29 <phobes> skew:  Every time they use it it increases the size of their program, right?  Just not by an amount proportional to its size
19:59:30 <LoganCapaldo> ?
19:59:34 <sarehu> he got his tail flipped too :)
19:59:42 <LoganCapaldo> can I lobby for a bool function?
19:59:45 <skew> phobes: there's also that, gzip can cut out sequences of symbols you can't actually abstract as a programmer
19:59:49 <monochrom> gzip will tell you that's as good as Haskell's "replicateM 5 (print hello)".
19:59:54 <skew> like }else{ => 1 char
20:00:05 <monochrom> That is why gzip is a dumb measure.
20:00:06 <skew> monochrom: better even, cause it's just the same thing,
20:00:12 <LoganCapaldo> that could even be an excuse for a Data.Bool module
20:00:13 <MyCatVerbs> sarehu: the amount of swinging around going on in there, I think I got pulverized against the room's walls, floor and ceiling.
20:00:15 <LoganCapaldo> heh
20:00:58 <phobes> monochrom:  Agreed, but that's also kind of contrived.  It seems plausible to me that gzip would produce fairish results in practice
20:01:02 <skew> monochrom: haskell has a "replicateM 5" and a "print" and a "hello"
20:01:32 <skew> phobes: what might be fair in practice is squishing all identifiers to a single character
20:01:58 <LoganCapaldo> @type let bool True = const ; bool False = flip const in bool
20:02:00 <lambdabot> forall a. Bool -> a -> a -> a
20:02:08 <phobes> skew:  That would be more fair in principle, I'm just wondering if you really have evidence that gzip isn't fair in practice
20:02:50 <phobes> I suspect people aren't submitting many entries that use "copy and paste" looping
20:05:09 <faxlore> ohh
20:05:17 <faxlore> If you had lots and lots of processes you wanted to run at once..
20:05:25 <faxlore> and some of them might never halt
20:05:33 <faxlore> but you still want to get the output frmo those that do
20:05:35 <monochrom> Buy lots and lots of computers.
20:05:42 <glguy> chan
20:05:51 <faxlore> well if you have only got one.. how would you do this?
20:06:04 <monochrom> Write an OS.
20:06:10 <monochrom> I'm just kidding :)
20:06:16 <LoganCapaldo> mmm OS
20:06:20 <faxlore> well someone already wrote an OS :P
20:06:22 <faxlore> I can just use it
20:06:28 <glguy> create a Chan, share it will all threads
20:06:31 <faxlore> so I guess the best thing is, to run lots of GHC process
20:06:35 <glguy> listen on the chan for the results
20:06:37 <faxlore> oh.. ok I will check that out
20:08:06 <ddarius> Define "process"
20:08:30 <phobes> faxlore:  If the processes can be killed and restarted, you can try running through the processes round robin, exponentially increasing the time you give each time you restart a process
20:08:55 <faxlore> ohh nice iea
20:08:56 <faxlore> idea
20:09:01 <faxlore> I can do that, and save the state
20:09:02 <phobes> Running 18 copies of GHC might not produce ideal results :)
20:09:19 <MyCatVerbs> phobes: that doesn't really gain you anything over just -not- killing them round-robin, though.
20:09:28 <phobes> faxlore:  If you use an exponential time increase each time, you don't change the big-O by just restarting each time
20:09:39 <MyCatVerbs> (And letting the preemptive scheduler alternate between them on your behalf.)
20:09:50 <phobes> MyCatVerbs:  Depending how many of them you have, it may be much better
20:10:19 <sarehu> Depends on what they do, too.
20:10:35 <ddarius> Depth first search with iterative deepening v. breadth-first search.
20:10:44 <phobes> ya
20:10:46 <MyCatVerbs> phobes: I could only see that being the case if your scheduler was so incredibly shite that the overhead from task switching massively exceeded the overhead from periodically murdering them part-way through their run.
20:11:01 <phobes> MyCatVerbs:  probably memory and resources are the issue
20:11:40 <MyCatVerbs> phobes: memory, yes, I could see that at first, but not upon further reflection.
20:12:32 <istarex> Is there a function like read in haskell with type String -> Maybe Int (so that it doesn't crash the program if the string doesn't turn into an int)?
20:12:38 <MyCatVerbs> phobes: you'd be better off hacking the scheduler so that each process in turn gets a really huge-ass timeslice (on the order of at least ten minutes), then just use swap space for any processes that spill over from the RAM you have in the machine.
20:12:41 <ddarius> MyCatVerbs: The analogy with breadth first search and depth first search with iterative deepening should be enough to clarify the memory behaviour of each.
20:12:49 <skew> istarex: reads
20:13:45 <phobes> MyCatVerbs:  As ddarius says, this is known as iterative deepening, and it's definitely useful in some cases ... imagine you have 1000 processes to run
20:14:29 <MyCatVerbs> phobes: since modern OSes are pretty good at virtual memory management, the only data that will actually be in core - as opposed to swapped out on the disk - should be the data your current running process is interested in. Pushing the task switching period up really high would then help make the overhead from swapping data for each process out in order to swap data for the next process in negligible.
20:15:20 <Valodim_> nah, there's more than enough ram to have more than the currently running application use it :P
20:15:25 <phobes> MyCatVerbs:  I suppose you may be right ... until you run out of hard drive space :)
20:15:34 <Valodim_> but which ones, that's the question. by cpu activity? by request?
20:15:35 <MyCatVerbs> phobes: indeed. But I can totally afford enough disk space to keep 1000 processes in swap, no problem. And when you're talking about such a large volume of processes, the constants involved start to matter, not just the asymptotic complexity. :P
20:16:37 <ddarius> The constants involved matter less, proportionally, with larger "input sizes"
20:16:51 <MyCatVerbs> phobes: eh, hard disk space is *really* cheap. If I have the budget to run all those thousands of processes in a reasonable period (given how much CPUs cost) then I certainly have more than enough money on hand to buy disk space for all of them, ten times over.
20:16:51 <phobes> MyCatVerbs: Use a multiple of 3x runtime with each iteration and your constant is now erm... 50% overhead I think.  Now subtract the cost of all that caching and it's probably not so bad
20:17:44 <MyCatVerbs> phobes: where does caching come into it?
20:18:03 <phobes> MyCatVerbs:  I mean the cost of caching out to disk
20:18:14 <skew> what's the problem anyway? Usually iterative deepening means something like chess, where each configuration is branching
20:18:45 <phobes> skew:  I think it's applicable anytime you're getting huge numbers of options to explore
20:18:56 <MyCatVerbs> phobes: swapping, you mean. And yes, swapping is expensive, that's why I say hack the OS scheduler for incredibly long timeslices.
20:19:19 <skew> faxlore: what are these processes you want to explore anyway?
20:20:35 <MyCatVerbs> ddarius: I'm not so sure about that. The cost difference between, say, running a slow and a fast regex over a few hundred megabytes of email might make the difference between, oh, one and two pennies, assuming a massively crap CPU and mind-bogglingly expensive electricity.
20:21:19 <phobes> MyCatVerbs:  Well, I'm pretty much agreeing with your analysis... I'm just saying that there is always going to be some problems for which iterative deeping doesn't exhaust your disk supply and parallel exploration does
20:21:23 <MyCatVerbs> ddarius: for obvious reasons, I'm not going to sweat the difference.
20:21:51 <faxlore> skew: check what ever brainfuck program prints out
20:22:04 <faxlore> every*
20:22:18 <MyCatVerbs> ddarius: whereas if you have a data set large enough that some fast algorithm costs, say ten of thousand quid to run, then you're not going to want to use a 10% slower algorithm because that'll cost you eleven grand, instead.
20:22:44 <MyCatVerbs> faxlore: hee, sounds funny. :)
20:24:23 <phobes> MyCatVerbs:  And anyway, the idea still seems reasonable to me for faxlore, who may be more interested in a simple quick & dirty solution than in hacking his OS :)
20:24:24 <skew> for that it's probably worth saving the state, and probably worth trying to detect looping programs after a while too
20:24:48 <faxlore> detecting loops sounds tricky
20:25:01 <MyCatVerbs> phobes: yesh, but if the individual programs take long enough to run that it's actually worth doing any interesting form of scheduling on them rather than just running them sequentially, and assuming that they fit into 4GB of RAM (fair enough, I think, since i386 only lets you address that much and most of the world is still on i386), then you have to spend so much on CPUs anyway that the disk costs are a tiny fraction of what you're spending anywa
20:25:14 <skew> not if you just look for stupid ones, like [] or whatever
20:25:45 <MyCatVerbs> phobes: admittedly hacking the scheduler would be a bit gratituously bastardly. Perhaps a better solution would be to find some language where a program could be frozen in mid-run?
20:25:59 <faxlore> hey maybe can use CallCC?
20:26:07 <skew> faxlore: I've heard that most short programs either break, or just go into stupid loops like that
20:26:16 <faxlore> skew: sounds true
20:26:45 <MyCatVerbs> phobes: heck, I'd say the ideal solution would be to do exactly what you suggest, but instead of murdering processes, you freeze them and then thaw them later. Though, that *is* mathematically identical to what the OS process scheduler does with your programs, heh.~~
20:26:46 <phobes> MyCatVerbs:  A modern processor can fill up 4 GB of RAM in what... 2-3 seconds?    In practice it probably takes more like a minute or two at worst, but still... you can easily fill up a 400GB harddrive in half a day
20:26:52 <skew> you could do something like run for a few hundred thousand cycles, then start recording the state every time you reach the end of a loop and see if you ever get there in the same state
20:28:03 <MyCatVerbs> phobes: the other reason for giving 4GB as a reasonable ceiling is the fact that, eh, putting more than 4GB of RAM in a single box starts to get expensive.
20:28:25 <faxlore> @hoogle [a] -> a -> Int
20:28:26 <lambdabot> No matches, try a more general search
20:28:28 <gwern> dunno. my 4gigs cost me about ~100$
20:28:38 <skew> MyCatVerbs: oh, 8 isn't reasonable yet?
20:28:42 <MyCatVerbs> phobes: 8GB is about the ceiling that any one process can reasonably go up to anyway, since above that you're going to hit the swap file with each *individual* process.
20:29:02 <phobes> MyCatVerbs:  What are we talking about
20:29:03 <phobes> ?
20:29:18 <MyCatVerbs> phobes: I mean if you're building a cluster to run this on...
20:29:19 <MyCatVerbs> skew: 2GB DIMMs are more expensive than 1GB DIMMs. Also, you
20:29:47 <MyCatVerbs> phobes: ...then you're going to want to use consumer hardware, since it's cheap, and the cheaper it is the more of it you can fit in your budget. :)
20:30:07 <skew> MyCatVerbs: I remember they were not absurdly more per byte than 1G at the start of the year, close enough I paid a bit extra for it
20:30:28 <phobes> MyCatVerbs:  I'm not disagreeing with you, but I'm not sure faxlore wanted to build a special system for this?
20:30:31 <skew> hehe, newegg has 512MB DDR2 under $10
20:30:37 <skew> maybe that's what I need to build with :)
20:30:42 <MyCatVerbs> phobes: you *could* buy servers that take, say, 64GB each, but those would rapidly exhaust your budget. It's strongly preferrable to buy many consumer machines instead, as you'll get much more bang for your buck.
20:30:58 <faxlore> eh I am just writing some code
20:31:00 <faxlore> see what happens
20:31:03 <MyCatVerbs> skew: *what*!? Bloody Hell that's cheap.
20:31:08 <faxlore> gonna try using a Chan
20:31:21 <MyCatVerbs> skew: okay, sure, I agree, 8GB would also be a reasonable limit. Probably a better one.
20:31:40 <MyCatVerbs> But either way, 8GB of RAM costs, oh... *checks pricewatch*
20:31:57 <MyCatVerbs> More than triple what 500GB of disk space costs, IIRC.
20:32:30 <faxlore> is there a way to list every library that I have in ghc?
20:32:33 <faxlore> like Data.List etc
20:32:36 <phobes> MyCatVerbs:  My claims are as follows:  1) In theory, for some very large number of processes, you'll be better off using iterative deeping  2) For a quick and dirty solution that doesn't thrash the harddisk, this may be the easiest approach to implement (and it's fairly performant)
20:32:37 <MyCatVerbs> faxlore: ghc-pkg list
20:32:46 <faxlore> ace thanks :D
20:32:49 <allbery_b> that's packages
20:32:55 <MyCatVerbs> faxlore: well, that tells you all the packages you have installed, not what modules each of those packages includes, sorry.
20:32:55 <faxlore> well it shows regex which is what I waned
20:33:05 <allbery_b> if you want the namespace, run a find on the ghc lib directory for .hi files
20:33:31 <phobes> I must run - g'night all
20:33:44 <MyCatVerbs> phobes: sleep well. And yeah, you're right.
20:34:03 <MyCatVerbs> phobes: I'd just find it more fun to go completely overboard than to do things on a small scale. :)
20:34:51 <skew> MyCatVerbs: $35 for 2G module vs. $18 for 1G. Wow
20:35:41 <MyCatVerbs> skew: eh? *re-checks pricewatch*
20:37:16 <hpaste>  gwern pasted "List of broken Hackage packages" at http://hpaste.org/4915
20:37:18 <MyCatVerbs> skew: oh, I have that wrong. 8GB of RAM is merely just under twice as expensive as 500GB of disk space.
20:37:29 <gwern> 105 packages in total
20:37:37 <gwern> that's gonna be a lot of work :(
20:38:09 <runar> How do I allow a module's user to set a "global value"? Like DPI for a drawing module?
20:38:20 <MyCatVerbs> skew: (I'm looking at pricewatch.com, 800MHz DDR2 vs. 500GB sata disks. Where are you looking?)
20:39:10 <runar> That's probably not what I want.
20:39:51 <MyCatVerbs> skew: still, the point remains. If you can swing things cleverly enough that you aren't significantly affected by the cost of shunting data to and from the hard disk, you could happily support your RAM's capacity dozens of times over.
20:41:20 <skew> irssi doesn't paste so well on windows, but newegg, "Desktop Memory"->Capacity="2G
20:43:34 <MyCatVerbs> skew: transcend sticks? k.
20:44:11 <MyCatVerbs> skew: ah, those're 667MHz sticks, rather than 800MHz.
20:44:35 <ddarius> "Why is it that in so many different branches of physics, the introduction of antisymmetric bracket symbols, all with the same abstract algebraic properties, leads to the most succint and powerful methods of calculation?"
20:45:04 <MyCatVerbs> skew: heck, if I check that spec on pricewatch, it comes up with... hrmn, dollar and a half cheaper. :)
20:45:22 <MyCatVerbs> skew: well, no, actually that price is a lie. NVM.
20:45:25 <runar> hmm... are implicit parameters what I want?
20:46:00 <MyCatVerbs> skew: (though I'd tend to buy the faster sticks myself, since modern CPUs are so hungry for memory bandwidth)
20:46:17 <faxlore> @undo do x <- a ; y <- b ; return (x,y)
20:46:18 <lambdabot> a >>= \ x -> b >>= \ y -> return (x, y)
20:50:37 * MyCatVerbs wonders how nasty an expression @pl can be coerced into printing.
20:50:48 <MyCatVerbs> @pl \(a,b) f q -> f (a b) : f (q (a b))
20:50:49 <lambdabot> uncurry (liftM2 ap ((ap . (((.) . (:)) .) . flip id) .) ((flip (.) . flip id) .))
20:51:11 <skew> @pl \a b c -> c b a
20:51:12 <lambdabot> flip (flip . flip id)
20:51:19 <nelhage> "How ugly do you want?"
20:51:22 <skew> @pl \a b c -> c a b a
20:51:24 <lambdabot> flip =<< (flip .) . flip . flip id
20:52:11 <MyCatVerbs> @pl let y f = f (y f) in y (\rec a b c -> [a b,c] ++ (rec b a c))
20:52:12 <lambdabot> fix (ap id) (ap (ap . (liftM2 (++) .) . flip flip return . (((.) . (:)) .)) . flip)
20:52:43 <MyCatVerbs> @pl let rec a b c = [a b,c] ++ (rec b a c)) in rec
20:52:43 <lambdabot> (line 1, column 39):
20:52:43 <lambdabot> unexpected ")"
20:52:43 <lambdabot> expecting variable, "(", operator, ":", "++", ";" or "in"
20:52:49 <MyCatVerbs> @pl let rec a b c = [a b,c] ++ (rec b a c) in rec
20:52:49 <lambdabot> fix (ap (ap . (liftM2 (++) .) . flip flip return . (((.) . (:)) .)) . flip)
20:53:15 <MyCatVerbs> Oh, neato. Those two *ought* to be identical, but they aren't. :D
20:53:34 <MyCatVerbs> :t let rec a b c = [a b,c] ++ (rec b a c) in rec
20:53:35 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> a
20:53:36 <lambdabot>       Expected type: t -> (t -> a) -> a -> [a]
20:53:36 <lambdabot>       Inferred type: (t -> a) -> t -> a -> t1
20:54:13 <MyCatVerbs> Whoa, neat. @pl can interpret code which won't ever typecheck.
20:54:31 <MyCatVerbs> @pl let y f = f (y f) in y (\rec a b c -> [a, b, c] ++ (rec b a c))
20:54:31 <lambdabot> fix (ap id) (ap (ap . (liftM2 (++) .) . (. ((. return) . (:))) . (.) . (:)) . flip)
20:54:38 <nelhage> It's not hard to construct code that has a recursive type
20:54:38 <MyCatVerbs> :t let y f = f (y f) in y (\rec a b c -> [a, b, c] ++ (rec b a c))
20:54:39 <lambdabot> forall a. a -> a -> a -> [a]
20:55:11 <MyCatVerbs> nelhage: yes, but I has assumed that @pl would refuse to touch it. :)
20:55:22 <skew> \a b x -> (a x) (b x)
20:55:25 <skew> @pl \a b x -> (a x) (b x)
20:55:25 <lambdabot> ap
20:56:29 <MyCatVerbs> @pl \a b f p -> p (f a) (f b)
20:56:31 <lambdabot> (. flip id) . ap . ((flip . flip id) .) . flip id
20:56:40 <MyCatVerbs> @pl \a b f -> (f a) == (f b)
20:56:41 <lambdabot> (. flip id) . ap . ((==) .) . flip id
20:56:49 <runar> @pl (\flip -> (. flip id) . ap . ((flip . flip id) .) . flip id)
20:56:50 <lambdabot> ap ((.) . ap ($ (.)) ($ id)) ((ap .) . ap ((.) . (.) . ap (.) ($ id)) ($ id))
20:57:06 <skew> I think turning lambdas to combinators can be exponential
20:57:28 <nelhage> The straightforward transformation is in fact exponential
20:57:39 <faxlore> skew: I think so yeah
20:57:44 <skew> but I'm not sure about what @pl does
20:58:01 <nelhage> And I think it is in general, but I'm not sure.
20:58:28 <nelhage> http://www.madore.org/~david/programs/unlambda/#lambda_elim
20:58:29 <lambdabot> Title: The Unlambda Programming Language
20:58:36 <skew> @pl \a b c d e -> (a (c b a)) (c d e)
20:58:36 <lambdabot> flip flip id . (liftM2 ((.) . (.)) .) . liftM2 (.) (.) (flip (flip . flip id))
20:58:40 <allbery_b> it's often possible to simplify the output of @pl; it has some simplification rules built in, but not many
20:58:56 <nelhage> (that particular section details transforming lambda expressions into the SKI calculus)
20:59:10 <skew> does it have something like B and C?
20:59:46 <runar> OK, I win.
20:59:47 <skew> @pl \f g x -> f (g x)
20:59:47 <lambdabot> (.)
20:59:57 <skew> @pl \f g x -> (f x) g
20:59:57 <lambdabot> flip
20:59:59 <runar> @pl (\x y z -> (x,y,z,y,x))
21:00:00 <lambdabot> flip =<< (flip .) . join . (flip .) . (,,,,)
21:00:13 <MyCatVerbs> skew: unlambda? Well, it was s, k, and call/cc, I think. Not sure if it has i or not. ;)
21:00:35 <nelhage> I believe unlambda does have i
21:00:44 <nelhage> Not that it matters
21:01:11 <skew> pulling out one variable multiplies the length of the spine down to its occurences
21:02:20 <skew> oh, except maybe you can pull it out like f(g(x) -> (f.g) $ x
21:02:25 <runar> @unpl (.)
21:02:25 <lambdabot> (\ a b c -> a (b c))
21:02:29 <MyCatVerbs> :t ((.)$(.))
21:02:34 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
21:02:54 <runar> MyCatVerbs: That's a nice pair.
21:03:33 <runar> @unpl ((.)$(.)
21:03:33 <lambdabot> Unbalanced parentheses
21:03:35 <runar> @unpl ((.)$(.))
21:03:35 <lambdabot> (\ b c e f -> b c (e f))
21:03:36 <MyCatVerbs> runar: saw that one on the haskell wiki, nicknamed the "owl combinator" :)
21:04:26 <nanothief> I've recently upgreaded from ghc 6.6 to ghc 6.8. Now when using ghcii.sh, :b Prelude results in the message "module 'Prelude' is not interpreted". What does that mean?
21:04:33 <MyCatVerbs> @pl \a b -> (gcd a b) /= 1
21:04:33 <lambdabot> flip flip 1 . ((/=) .) . gcd
21:05:29 <skew> nanothief: :b now stands for :breakpoint
21:05:50 <MyCatVerbs> nanothief: you want to type :bro^I out instead. >>
21:05:50 <skew> and the debugger only works on interpreted code
21:06:19 <nanothief> skew, MyCatVerbs, thanks
21:06:39 <nanothief> i didn't even think of testing with :browse
21:08:06 <MyCatVerbs> nanothief: tab completion helps. If it's possibly that you're getting the wrong abbreviation, hit tab a few times to get ghci to give you the full list of commands that what you've typed is a prefix of.
21:08:50 <nanothief> MyCatVerbs: unfortunately tab completion doesn't seem to work for me (I'm using ghcii.sh through mingw bash)
21:09:03 <nanothief> it just inserts a tab character
21:10:19 <MyCatVerbs> nanothief: oh, that sucks.
21:11:22 <nanothief> MyCatVerbs: yeah it is quite annoying. Luckily :br Prelude works too, so its not too much more typing now
21:11:55 <nanothief> (i mean :bro)
21:16:17 <MyCatVerbs> Heehee.
21:16:51 <MyCatVerbs> DOOM3 has to be the most expensive way in the history of human kind to render (in real-time, no less!) a series of black cats in coal cellars. :D
21:24:56 <gwern> MyCatVerbs: I heard in some parts you can actually see things! using a 'flashlight' thingy supposedly
21:25:04 <dons> ?users
21:25:04 <lambdabot> Maximum users seen in #haskell: 444, currently: 390 (87.8%), active: 16 (4.1%)
21:28:02 <MyCatVerbs> gwern: personally I hate dark games.
21:28:28 <MyCatVerbs> gwern: I'm more interested in being able to see stuff and violently blast it into pink mist than in searching for it in corners.
21:29:14 <MyCatVerbs> gwern: I play mostly Operation Flashpoint, Team Fortress Classic, DOOM2.
21:30:09 <MyCatVerbs> gwern: admittedly DOOM 1&2 have dark rooms, but they don't make up a particularly significant proportion of the game and they're reasonably well presented. Even if you do feel the need to chicken out, there's usually nothing stopping you from hanging back by the door and blasting whatever comes out. :)
21:32:27 <MyCatVerbs> gwern: oh and deathmatch variants of CounterStrike, too, though I really can't stand the vanilla game.
21:33:19 <Korollary> I should play some deathmatch CSS then
21:35:11 * kfish prefers deathmatch darcs
21:35:30 <Pseudonym> Unfortunately, that's no fun in a SCCS without commit wars.
21:35:52 <MyCatVerbs> Pseudonym: ehhhhh...
21:36:02 <MyCatVerbs> Pseudonym: you could submit deliberately conflicting patches? :)
21:37:17 <dons> ok. this is scary, http://programming.reddit.com/info/6567d/comments/
21:37:28 <dons> "The Marvels of Monads" (in C#)
21:38:08 <Pseudonym> It's a marvel that you can even do it in C#.
21:38:09 <dons> "> Monads enjoy tremendous success in Haskell, but like an actor who does well in a particular role, monads are now stereotyped in the minds of most programmers as useful only in pure lazy functional languages.  This is unfortunate, because monads are more broadly applicable."
21:38:53 <Pseudonym> OK, that's not an entirely unfair statement.
21:39:06 <dons> sure. i thought it was entirely fair.
21:39:14 <Pseudonym> Sp why is it scary?
21:39:22 <sarah__> how do i put a polymorphic value  into a type? ex: data Node = Node { last_action :: (Action a) => a,  info :: Info } deriving Eq
21:39:35 <dons> Pseudonym: oh, in the last 2 days we've seen posts on pragmatic monads for python, for ruby, and now C#
21:39:45 <dons> that's in the last 48 hours
21:40:04 <Korollary> It's just a toy exercise
21:40:14 <Pseudonym> Ah, right.
21:40:27 <Pseudonym> I question how useful they are in dynamically typed languages.
21:40:28 <ddarius> The "unfairness" comes from the fact that this stereotyping is against what most pure lazy functional programmers say.
21:40:34 <Pseudonym> I imagine they'd be slihgtly more useful in C#.
21:41:03 <MyCatVerbs> sarah__: data Node a = Node { last_action :: a, info :: Into } deriving Eq
21:41:08 <dons> they used LINQ for the syntax
21:41:13 <dons> i.e. comprehension syntax
21:41:14 <sarah__> thx
21:41:35 <dons> from/select. quite weird.
21:41:51 <dons> var r = Bind(Unit(5), x =>
21:41:51 <dons>             Bind(Unit(6), y =>
21:41:52 <dons>                 Unit(x + y)));
21:41:54 <dons> becomes
21:42:04 <dons> var r = from x in 5.ToMaybe() from y in Maybe<int>.Nothing select x + y;
21:42:08 <MyCatVerbs> sarah__: I can't remember how to enfore the "Actor a" type constraint. I think you usually do it by making a class which contains all the interesting functions on Nodes, and an instance Actor a => Nodethingies a where...
21:42:24 <dons> oh, looks like he changed the example, actually
21:42:25 <hpaste>  mmorrow pasted "love ghc's pre-emption (or what a difference a -N2 makes)" at http://hpaste.org/4916
21:42:29 <MyCatVerbs> That's how large quantities of the libraries seem to do it.
21:43:47 <hpaste>  mmorrow annotated "love ghc's pre-emption (or what a difference a -N2 makes)" with "(no title)" at http://hpaste.org/4916#a1
21:45:57 <sjanssen> "bababababa" is a pretty good result!
21:46:15 <kfish> "Adjoint triples are stereotyped as only useful in categories with U-contractible coequalizers, but you can use them to balance your Macy's store card! In Visual Basic!"
21:46:33 <dons> you're so wacky, kfish :)
21:46:52 <Syzygy-> kfish: Hehe
21:47:03 <MyCatVerbs> kfish: was that real, or are you stringing words together at random?
21:47:20 <dons> he's translating from blogspeak
21:47:30 <dons> or too blogspeak, i'm not sure
21:47:31 <MyCatVerbs> The thing I really don't like about category theory is that it takes a minimum of half an hour to ascertain which in any specific instance. x_x
21:47:33 <Syzygy-> kfish: Where are you reading?
21:47:38 <faxlore> Something like this yeah
21:47:40 <faxlore> > let floggle x = if even x then last [1..] else 6 in map floggle [1..]
21:47:44 <lambdabot> Terminated
21:48:04 <faxlore> would you dup a chan infinite times?
21:48:06 <MyCatVerbs> faxlore: last [1..] is never going to terminate :)
21:48:11 <faxlore> Exactly
21:48:16 <faxlore> I have a list with holes in it
21:48:36 <faxlore> I'm not sure I can use chans
21:48:54 <MyCatVerbs> dons: is it possible to put typeclass restrictions on the members of a data structure?
21:49:01 <faxlore> but there is some way to do this? try to compute everything in the list and extract things which did work
21:49:27 <bos> MyCatVerbs: yes, it is.
21:49:30 <kfish> MyCatVerbs, Syzygy-, Toposes, Triples and Theories sec.  3.7, in the edition with "Barbie" annotations
21:49:55 <MyCatVerbs> bos: ah, danke. What's the syntax for that, please?
21:50:16 <MyCatVerbs> data Typeable a => Foo a = Fooconstructor a or something?
21:51:01 <ddarius> When was this phase transition that made Haskell a buzzword in e.g. the C# community? and what caused it?
21:51:12 <MyCatVerbs> ddarius: I have a rough guess.
21:51:28 <bos> MyCatVerbs: yes, or data Foo = Bar a => Beable a
21:51:44 <bos> MyCatVerbs: it's kind of bad for your karma to put type constraints on a constructor, though.
21:51:55 <MyCatVerbs> ddarius: a few months back, I remember seeing an article on using immutable data structures in C# in order to benefit from their handy-dandy safety properties under shared-memory multiprocessing.
21:52:05 <sarah__> if in my type class i have some_method _ = 1 defined, and an instance of it has some_method x:xs = x defined, what would calling the insance with something not matching x:xs do, fail or return 1?
21:52:06 <bos> it severely limits what you can subsequently do with the type.
21:52:23 <bos> it also forces you to splatter type constraints all over the functions that use that type.
21:52:30 <MyCatVerbs> ddarius: I think that was on one of Microsoft's sites, though I'm not sure if it was an MSDN blog or an article published by the company itself or what.
21:52:54 <ddarius> It was more than a few months back, but less than a year.
21:52:59 <MyCatVerbs> ddarius: that did refer to Haskell at one or two points. Plus Microsoft went and implemented F#...
21:53:18 <skew> MyCatVerbs: you might really want GADTs
21:53:24 <MyCatVerbs> ddarius: so perhaps all the FP features that MS have been implementing for themselves and then promoting have started to sink in?
21:53:27 <bos> sarah__: the instance's version completely replaces the typeclass's default, so it will fail.
21:53:30 <sjanssen> sarah__: fail
21:54:24 <sarah__> k
21:54:40 <MyCatVerbs> bos: ah, bummer.
21:55:28 <ddarius> MyCatVerbs: Stuff has been sinking in for a while.  There just seemed to be an abrupt change not too too long ago.  There probably isn't a particular cause.
21:55:50 <MyCatVerbs> ddarius: heh, well, that is the usual characteristic of phase changes, isn't it now? :)
21:56:48 <MyCatVerbs> "Buggery, when did this stuff get solid? It was liquid yestderday, and its temperature has only dropped one measly degree sine then."
21:57:59 <glguy> What was that paper about SICP and how Miranda would have been better for teaching CS?
21:58:06 <glguy> something about scheming and calculating
21:58:14 <Korollary> Wadler's computing is better than scheming
21:58:20 <glguy> thanks
21:58:22 <MyCatVerbs> Browsing the Haskell Hierarchical Libraries source code is fun.
21:58:23 <nelhage> @go computing is better than scheming
21:58:24 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
21:59:09 <BMeph> Whenever I try getting something with Cabal, it says:
21:59:14 <BMeph> "cabal: Data.ByteString.Lazy.index: index too large: 0"
21:59:32 <BMeph> Does someone recognize the problem?
21:59:52 <faxlore> let compute ch [] = writeChan ch 0; compute ch (x:xs) = do writeChan ch x ; compute ch xs in do x <- newChan ; (compute x [3,5,last [1..],8,last [1..],4,6]) ; getChanContents x
22:00:35 <faxlore> in something like this, can you change compute so that it works on the list in any order in parallel
22:01:54 <solrize> hi, anyone know of ghc 6.8.2 causing linking problems?
22:02:58 <MyCatVerbs> solrize: you don't have libraries compiled with ghc 6.6 being linked in to programs being compiled with 6.8 or anything crazy like that, do you? Other that that I couldn't hazard a guess.
22:03:03 <tehgeekmeister> I just got an exception from head about an empty list, but i don't call head directly in any of my code -- how does one go about fixing this sort of a bug?
22:03:22 <solrize> i don't think so.  i had ghc 6.4.something and upgraded to 6.8.2 and now i can't link
22:03:29 <solrize> seems to happen when i import data.map
22:04:28 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4917
22:04:35 <solrize> that was me
22:04:36 <bos> tehgeekmeister: i usually do a dichotomic search using trace expressions.
22:04:37 <faxlore> This is odd, let pr n = putStrLn (show n) in mapM (forkIO . pr) [1..10]
22:04:59 <bos> tehgeekmeister: that's the pure programmer's way of saying "shove some printfs in there"
22:05:07 <MyCatVerbs> tehgeekmeister: there are two ways, depending on your version of GHC. Three, even.
22:05:29 <solrize> by the way is anyone here at POPL?
22:05:33 <MyCatVerbs> tehgeekmeister: one is to use the "trace" function from the Debug.Trace module (which is usually the first thing to go for)
22:05:38 <tehgeekmeister> MyCatVerbs: 6.6.1, sadly the newest available in macports
22:05:44 <bos> solrize: i've popped in and out a few times
22:05:49 <MyCatVerbs> tehgeekmeister: another (if you have ghc 6.8) is to use ghc's debugger.
22:06:04 <MyCatVerbs> tehgeekmeister: the third isn't applicable in your case, I think. :/
22:06:58 <tehgeekmeister> bos: just sprinkle them around in any suspect code?  that'd require bringing IO into the Parsec monad, that scares me, being a noob.
22:07:03 <bos> ghci doesn't have an obvious break-on-error.
22:07:12 <bos> tehgeekmeister: no, use Debug.Trace.trace
22:07:22 <tehgeekmeister> bos: okay.
22:08:30 <bos> tehgeekmeister: also see http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
22:08:32 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
22:08:44 <MyCatVerbs> tehgeekmeister: Debug.Trace.trace uses unsafePerformIO. Which is normally scary, but very handy for printlining.
22:09:13 <tehgeekmeister> MyCatVerbs: i.e.: it allows the side effect of printing without any monadic goodness?
22:09:16 <shachaf> faxlore: What is odd?
22:09:22 <shachaf> faxlore: (And pr = print.)
22:09:45 <shachaf> @src putStrLn
22:09:46 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
22:09:55 <faxlore> well it just works a bit strangly
22:11:17 <tehgeekmeister> bos: that's not available in 6.6.1, it seems.  i've not been daring enough to either manually compile or install a non-macports binary yet.
22:11:19 <MyCatVerbs> tehgeekmeister: yes, unsafePerformIO lets you plant side effects in pure code. This is why it's called 'unsafe' :)
22:11:36 <tehgeekmeister> MyCatVerbs: figured, but i also figured it was good to make sure.
22:11:43 <MyCatVerbs> tehgeekmeister: hrmn? import Debug.Trace
22:12:00 <tehgeekmeister> MyCatVerbs: no, that is.  but the section of the manual he pointed me to isn't.
22:12:20 <MyCatVerbs> tehgeekmeister: I have a copy of 6.6.1 over here, and I can load and use the Debug.Trace module at the ghci prompt just fine.
22:12:39 <MyCatVerbs> tehgeekmeister: oh, right, my bad, I see.
22:15:54 <tehgeekmeister> if i've got a bunch of infix appends, i should convert those to prefix sections that have a trace in them if they're the suspect region, right?  or is there a sane way to use trace on infix operators?
22:16:21 <faxlore> tehgeekmeister what are you tracing?
22:16:26 <shachaf> tehgeekmeister: You could define a (+++) which uses trace.
22:17:27 <roconnor> @unicode minimum
22:17:27 <lambdabot> Unknown command, try @list
22:17:29 <tehgeekmeister> faxlore: parsing of a negative float in Write Yourself a Scheme in 48 Hours
22:17:30 <roconnor> er
22:17:35 <roconnor> @go unicode minimum
22:17:37 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
22:17:38 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
22:17:40 <tehgeekmeister> shachaf: good idea.
22:17:45 <roconnor> @go unicode maximum
22:17:47 <lambdabot> http://www.snort.org/vrt/docs/ruleset_changelogs/2_1/changes-2007-06-19.html
22:17:47 <lambdabot> Title: Snort - the de facto standard for intrusion detection/prevention
22:17:51 <roconnor> @go unicode max
22:17:52 <lambdabot> http://www.snort.org/archive-3-3149.html
22:17:52 <lambdabot> Title: NETBIOS SMB-DS Trans unicode Max Param DOS attempt - Snort Forums Archive
22:17:54 <roconnor> :(
22:18:36 <sjanssen> > maxBound :: Char
22:18:39 <lambdabot>  '\1114111'
22:18:39 <solrize> mycatverbs, any other theories about 6.8.2 lossage?
22:19:53 <shachaf> solrize: How did you install 6.8.2?
22:21:41 <solrize> built from the tarball
22:21:48 <solrize> then "make install"
22:22:22 <shachaf> solrize: Is containers in `ghc-pkg list`?
22:22:47 <solrize>  containers-0.1.0.1,
22:22:48 <solrize> tes
22:22:50 <solrize> yes
22:23:37 <sclv> my simple debugging function for parsec: pTrace s = pt <|> return ()
22:23:38 <sclv>     where pt = try $               do {                 x <- try $ many1 anyChar;                trace (s++": " ++x) $ try $ char 'z';                 fail x;}
22:23:48 <shachaf> solrize: That's odd.
22:23:51 <shachaf> solrize: Which OS?
22:23:58 <solrize> ubuntu 6.10 i think
22:24:34 <goalieca> lol another tanenbaum classic "The RISC revolution in the 1980s was one such breakthrough; another one is in the air now. We will look at one example (the Intel IA-64) in Chap. 5)"
22:24:55 <solrize> haha
22:25:11 <goalieca> i can't wait for my microkernel running on ia64
22:25:38 <MyCatVerbs> solrize: nope. That's my first, last and old guess so far. :)
22:26:05 <dons> "We will look at one example (the nvidia 128 way gpgpu graphics chip) "  :)
22:26:15 <dons> how times change
22:26:39 <tehgeekmeister> right associativity means that it groups like this, correct: a ++ (b ++ (c ++ d)), right?
22:26:46 <ddarius> Yes
22:26:52 <tehgeekmeister> okay
22:26:53 <goalieca> Nvidia 98700.. return of the coprocessor
22:27:04 <goalieca> eventually... i figure
22:27:38 <solrize> the day will come when there will be no more cpu's and no more ram.  just giant fpga's.
22:27:57 <dons> they'll be just 5 fpgas on the planet
22:28:00 <goalieca> you know.. i would love it if every computer had an fpga in it. :-)
22:28:02 <dons> each the size of an office block
22:28:08 <solrize> hehe
22:28:30 <solrize> nobody will need more than 640,000 clb's
22:28:32 <MyCatVerbs> dons: I thought that was really unfair, y'know.
22:28:51 <MyCatVerbs> dons: the IBM guy's quote, I mean, that there will only be a market for five computers on the planet.
22:28:59 <shachaf> solrize: I'd suggest upgrading.
22:29:16 <solrize> upgrading from 6.8.2?  i thought this was the latest
22:29:18 <shachaf> solrize:If you can.
22:29:26 <shachaf> solrize: No, Ubuntu 6.10.
22:29:29 <MyCatVerbs> Sure, he was wrong, but he wasn't saying that only five people would *want* computers, he was saying that it'd only ever be worth building five gigantic computers and then time-sharing them.
22:30:10 <MyCatVerbs> Heck, you could just imagine that now - one in London, one in Beijing, one in San Francisco...
22:30:21 <Cale> I wouldn't put that idea past the DRM people.
22:30:26 <dons> one huge cluster inside google
22:30:37 <goalieca> Ironically... if google gets their "Webapp" ways we're talking the size of a few city blocks... one on each of the 5 continents
22:30:43 <MyCatVerbs> (Except for the fact that, hey, it turns out clustering is the new black.)
22:30:45 <tehgeekmeister> okay, so i've traced it down to the point at which the exception occurs, but now i have absolutely no idea why because neither my code nor the code called at that point uses head.
22:30:50 <solrize> oh.  yeah, i tried upgrading a while back and hit some snags and had to revert, but i should try again.
22:30:58 <tehgeekmeister> where do i go from that?
22:31:14 <MyCatVerbs> dons: I'm not sure whether or not it counts for there to be five *clusters* on the planet, each of which contains thousands of smaller computers. ;)
22:31:34 <MyCatVerbs> dons: I'm pretty certain that's one of the things that the Plan 9 folks would've liked to see, though. ^_^
22:32:15 <shachaf> tehgeekmeister: @paste, if it's small enough?
22:32:27 <shachaf> tehgeekmeister: Try GHC 6.8? :-)
22:33:04 * goalieca wonders when 6.8 will be in language shootout
22:33:18 <goalieca> gentoo is usually fast about this type of thing
22:33:30 <sclv> tehgeekmeister: how many calls do head do you have in the entirety of your code?
22:34:10 <tehgeekmeister> shachaf: i hate to admit my folly, but there was a call to head, i just hadn't considered it because it was beyond where my imperative programming mind thot the execution had gone.
22:34:33 <tehgeekmeister> also, i learned that readFloat doesn't like signs.
22:35:12 <Cale> tehgeekmeister: remember, outermost first :)
22:36:31 * bos went to phil wadler's talk last night in SF, at POPL. the room was packed!
22:36:54 <Cale> bos: What was it about? Was it taped?
22:37:15 <bos> it was "well-typed programs can't be blamed", and yes, it was taped.
22:37:16 <solrize> yeah, i was gonna go to that and forgot about it til it was already on!!  i coulda caught the tail end at best
22:37:19 <bos> excellent talk.
22:37:26 <tehgeekmeister> Cale: this was weirder than that -- the appends which were building up the input to readFloat hadn't finished entirely before it sent an empty list on to head.  lazy evaluation is cool, i must admit, in not doing that unnecessary work, but man it makes you have to think about debugging differently.
22:37:35 <solrize> was it about haskell types, or something fancier?
22:37:43 <bos> solrize: less fancy, actually.
22:38:01 <bos> solrize: it's based on work he's been doing in mixing static and dynamic types.
22:38:17 <ddarius> tehgeekmeister: Indeed you do debug rather differently in Haskell as compared to most languages
22:38:23 <solrize> hmm interesting
22:38:42 <Cale> tehgeekmeister: hmm...
22:39:29 <Cale> tehgeekmeister: I'm not entirely sure I understand what's happening from that description -- surely values are well defined, and the value you're passing to head is either nil or a cons, but it can't be both.
22:40:02 <tehgeekmeister> Cale: head is getting []
22:40:15 <bos> wow, awesome. people are starting to seed web sites with SIPs so that they can send valid google.com URLs out in spam messages. that's COOL.
22:40:21 <tehgeekmeister> Cale: because i'm giving readFloat a signed float ("-1.2" in this case.)
22:40:27 <jcreigh> SIPs?
22:40:47 <bos> statistically improbable phrases.
22:40:55 <Cale> tehgeekmeister: ah, okay, it doesn't seem to handle negative floats
22:40:56 <solrize> hahaha!  googlewhack spam
22:41:02 <solrize> must be possible to hijack those things
22:41:29 <BMeph> Does anyone recognize that error?
22:41:36 <tehgeekmeister> Cale: the confusion was that before the float was completely constructed by the appends of the various parts of the parse, as determined by the traces, readFloat had already been fully evaluated and execution was elsewhere.
22:41:48 <Cale> BMeph: sorry? Which error?
22:42:03 <glguy> > readFloat ""
22:42:05 <lambdabot>  []
22:42:22 <Cale> tehgeekmeister: ah, okay :)
22:42:48 <Cale> tehgeekmeister: Debug.Trace can be confusing if you don't know how evaluation goes (even sometimes if you do)
22:43:07 <BMeph> I downloaded and compiled Cabal 1.2.3, but whenever I try to get something, it just prints:
22:43:10 <BMeph> "cabal: Data.ByteString.Lazy.index: index too large: 0"
22:43:23 <Cale> BMeph: interesting
22:43:47 <BMeph> Isn't it just...;/
22:44:04 <Cale> tehgeekmeister: GHCi in 6.8 has a debugger which you might also like to try for that sort of thing
22:44:49 <Cale> BMeph: 1.2.3.0 is the version which comes with 6.8.2, isn't it?
22:45:14 <tehgeekmeister> Cale: yeah, i really should put out the effort and get 6.8, but i just don't like having anything installed that a package manager isn't taking care of, unless it's a native OSX app.  certainly one thing i miss about linux/bsd.
22:45:29 <BMeph> Yes, it is. I'm tempted to just wipe out 6.8.2 and re-install from scratch. :|
22:46:13 <Cale> tehgeekmeister: I make an exception for GHC, even on Ubuntu.
22:46:37 <Cale> For most other packages, I'm similar in that regard.
22:46:41 <MagicDuck> is it possible to build .so shared libraries with ghc
22:46:53 <tehgeekmeister> Cale: yeah, i probably should myself, because ghc is the program i use most, aside from firefox, but i haven't done it yet nonetheless.
22:47:02 <Cale> MagicDuck: If it is, I'm not aware of how to do it.
22:47:17 * tehgeekmeister looks at options for ghc on osx
22:48:09 <Cale> tehgeekmeister: You can get a binary from the GHC website.
22:50:55 <Cale> MagicDuck: Currently on most platforms, GHC statically links all the Haskell libraries and runtime in. IIRC, there was some support for dynamically linking stuff on OSX, but I haven't used OSX for quite some time now.
22:51:26 <glguy> Fedora has been great about being really up to date on ghc versions
22:51:28 <glguy> (thanks bos)
22:53:18 <solrize> i really like building from sources instead of installing opaque packages, does anyone know if something might be wrong with the 6.8.2 tarball?
22:53:39 <MagicDuck> thanks Cale
22:53:51 * tehgeekmeister is glad that his scheme can handle signed floats now
22:54:08 <bos> glguy: yw :)
22:54:22 <bos> solrize: it's build fine for me
22:54:27 <bos> s/d/t/
22:54:46 <solrize> bos, it built and installed fine for me too, i just can't compile and link with it.
22:55:06 <bos> solrize: wha happen?
22:55:10 <MagicDuck> I am learning hakell in one of my university classes. This channel is very responsive compared to others I have visited. Just try #scons, all dead. I'll be sure to tell other people in the class about this great resource :)
22:55:37 <solrize> bos, http://hpaste.org/4917
22:56:02 <MyCatVerbs> MagicDuck: try #scheme too. Pretty comparable. :)
22:56:04 <tehgeekmeister> MagicDuck: it really is great -- i've noticed a lot of people mentioning that in the past week or two.
22:56:52 <MyCatVerbs> MagicDuck: I've no idea why, but channels saturated with academics seem to be unusually friendly. Compare and contrast with anything gratituously industrial like, oh, C or Java?
22:56:53 <tehgeekmeister> anyone know why readFloat has type String -> [(Float,String)] ?
22:57:05 <bos> solrize: that's your bad, not ghc.
22:57:06 <MagicDuck> yeah, haskell is a whole new world to me, coming from the domain of imperative languages
22:57:12 <MyCatVerbs> tehgeekmeister: yes. It's giving a list of possible parses.
22:57:17 <bos> solrize: use "ghc --make"
22:57:29 <solrize> hmm, ok.  it used to work under 6.4.whatever
22:58:01 <MyCatVerbs> tehgeekmeister: if there's more than one possible way to parse the input string as a float, it will give you a list back with more than one element in it. If the input string can't possibly parse as a float, you'll get an empty list.
22:58:28 <solrize> bos, thanks, that works!
22:58:35 <MyCatVerbs> tehgeekmeister: the String in those (Float,String) pairs is the rest of the string, that is, the bit left over after the bit that was parsed as a float.
22:58:49 <solrize> hmm, ghc -O3 6.8.2 compiled code is slower than 6.4...
22:58:50 <MyCatVerbs> > readFloat "3.14 eats bagels"
22:58:51 <lambdabot>  [(3.14," eats bagels")]
22:59:02 <MyCatVerbs> solrize: use -O2, not -O3.
22:59:25 <MagicDuck> ghc 6.8.2 seems to be a big improvement over 6.6
22:59:31 <MyCatVerbs> solrize: for lots of weird reasons, -O3 is closer to -O0 than -O1 or -O2.
22:59:39 <solrize> O2 is a tiny bit slower than O3
22:59:52 <solrize> both are about 5x slower than python :(
22:59:57 <MyCatVerbs> solrize: oh, try -fvia-C?
23:00:19 <bos> solrize: use -O, not -O2
23:00:25 <solrize> tiny slowdown from -fvia-C
23:01:15 <bos> solrize: if you're manipulating String values, performance will always be bad.
23:01:21 <solrize> -O and -via-C fundamentally don't change much.  i think i'm losing big because i'm processing a big file as a lazy string.  i upgraded to 6.8.2 to use data.bytestring
23:01:24 <solrize> yeah
23:01:28 <MyCatVerbs> Eh? If 6.8.2 compiled code comes out slower than 6.4, that's probably a bug.
23:01:49 <sjanssen> what is the program?
23:01:57 <bos> also, python's string code is all well-tuned C.
23:02:04 <solrize> just a simple word counting program, i can paste it if you want
23:02:15 <roconnor> > 805/256
23:02:17 <lambdabot>  3.14453125
23:02:20 <bos> whereas even ByteString doesn't drop into C for more than a few small things
23:02:37 <sjanssen> solrize: sure
23:02:42 <hpaste>  solrize pasted "(no title)" at http://hpaste.org/4918
23:02:54 <Korollary> There's a haskellwiki page dedicated to word counting and the performance was great iirc
23:03:11 <solrize> this finds the 20 most frequently used words
23:03:13 <dons> but you're using [Char] !
23:03:15 <solrize> an exercise in using data.map
23:03:31 <skew> that's not using ByteString at all
23:03:36 <solrize> dons, yes, i just upgraded ghc in order to use bytestring
23:03:36 <dons> and lazy insertWith
23:03:44 <dons> ah ok.
23:03:49 <solrize> i haven't actually converted it to use bytestring yet
23:04:06 <solrize> should i call insertWith differently?  does this code generally look (stylistically etc.)?
23:04:12 <solrize> <- newbee
23:04:31 <sjanssen> insertWith may be leaking space here
23:04:36 <skew> 5x slower than Python string code is less than I'd expect from [Char]
23:05:22 <solrize> hmm actually more than 10x slower
23:05:25 <bos> solrize: use insertWith' instead
23:06:04 <bos> solrize: you're building up a map full of thunks as values
23:06:13 <bos> that's going to further slow you down
23:06:14 <solrize> insertWith' sped it up by 20% or so
23:06:19 <solrize> bos, i think i understand
23:06:22 <nelhage> Why does http://haskell.org/hoogle/?q=Data.Map not return any of the right hits?
23:06:29 <solrize> i did use foldl' once the thing crashed on a large file :0
23:06:37 <bos> solrize: that's about as good as you'll get without switching representations, then.
23:06:41 <nelhage> (But searching for `Map' does, so clearly it's in the database)
23:06:50 <solrize> right it sounds like data.bytestring is a huge win
23:07:05 <bos> solrize: oh, actually you could use Int instead of Integer, too, and that will further improve speed.
23:07:18 <goalieca> Integer is a "bignum" no?
23:07:22 <bos> yes.
23:07:35 <goalieca> huge difference then
23:07:57 <goalieca> I feel the need to write some haskell code tonight. haven't in a month ::(
23:08:00 <bos> well, it's a clever bignum. but it also behaves pretty weirdly.
23:08:38 <solrize> using int made almost no difference
23:08:52 <solrize> i think it's really spending all its time on String
23:08:54 <sjanssen> in this case, Integer shouldn't behave to badly (no opportunity for unboxing)
23:08:57 <hpaste>  keseldude pasted "lambdabot help" at http://hpaste.org/4920
23:09:01 <keseldude> ^ can somebody help me with that :P
23:09:25 <bos> solrize: yeah.
23:09:45 <goalieca> keseldude, do you need an else statement?
23:09:47 <solrize> if i define a new type as an alias for Int (basically to paramatrize that type) will the compiler do the right thing?
23:09:47 <sjanssen> solrize: switching this program to ByteString should be easy, simply "import qualified Data.ByteString as B" and stick "B." in front of a few function names
23:10:10 <keseldude> maybe? =\
23:10:18 <goalieca> keseldude, you need to return something in all cases
23:10:23 <goalieca> if "maybe" then return Maybe
23:10:29 <keseldude> oh ok
23:10:33 <goalieca> return Just "H" or Nothing
23:10:37 <bos> solrize: type aliases just introduce new names, nothing more.
23:11:02 <dons> how big is your input file, solrize ?
23:11:18 <bos> solrize: so "type Foo = Int" doesn't give you a new type, just a new name. you can pass Foo values to functions of Int.
23:11:29 <hpaste>  keseldude annotated "lambdabot help" with "thanks goalicea" at http://hpaste.org/4920#a1
23:11:32 <solrize> dons, 3M
23:11:38 <dons> oh, easy.
23:11:39 <solrize> about 3 seconds with ghc
23:11:43 <dons> but too big for [Char]
23:11:50 <bos> it will be instantaneous with bytestring.
23:11:52 <Korollary> goalieca: 3-1 baby
23:11:53 <keseldude> damn i spelled your name wrong... sorry :(
23:11:57 <goalieca> keseldude, this is probably what you want: if s == 'h' then 'H' else s
23:12:11 <keseldude> i wrote that ^^
23:12:12 <bos> is goalicea related to boadicea?
23:12:15 <goalieca> Korollary, i sad :( it was a pay-per-view game anyways
23:12:24 <goalieca> bos: goalieca = goalie + canada
23:12:26 <goalieca> so no
23:12:55 <bos> yes, i was just punning on keseldude's misspelling.
23:12:56 <OceanSpray> @hpaste
23:12:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:12:59 <tehgeekmeister> MyCatVerbs: oh, so that means that my just taking the first element by default isn't necessarily correct?
23:13:11 * goalieca didn't read that then
23:13:13 <bos> @users
23:13:13 <lambdabot> Maximum users seen in #haskell: 444, currently: 383 (86.3%), active: 23 (6.0%)
23:13:14 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4921
23:13:19 <bos> quiet night.
23:13:21 <OceanSpray> see this parser.
23:13:37 <dons> what's a good input file?
23:13:39 <OceanSpray> I don't understand why I need the '"2" there at the end.
23:13:43 <MyCatVerbs> tehgeekmeister: usually is, for bloody simple things like floating point numbers.
23:13:52 <OceanSpray> *"- 2"
23:13:55 <tehgeekmeister> MyCatVerbs: well, considering i've already parsed it as a float and constructed it properly before it's fed to readFloat, i suppose it should always be okay.  but i can't be certain...
23:14:07 <MyCatVerbs> tehgeekmeister: those kinds of read functions are very useful for parsing ambiguous grammars, y'see.
23:14:13 <MyCatVerbs> :t readS
23:14:15 <lambdabot> Not in scope: `readS'
23:14:22 <OceanSpray> without it, parsing 0.1 resulted in 0.001
23:14:23 <MyCatVerbs> Wait, no. *pokes the docs*
23:14:48 <MyCatVerbs> Oh right.
23:14:49 <tehgeekmeister> MyCatVerbs: yes, there was a good example of that in all about monads, gave the parses of a string as hexadecimal, binary, and alphabetic word
23:14:50 <solrize> hmm i'm having trouble figuring out how to convert this thing, and also am now regretting putting in all those explicit annotations instead of leaving it up to type inference
23:14:50 <MyCatVerbs> :t reads
23:14:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:15:09 <MyCatVerbs> tehgeekmeister: well, if your grammar doesn't contain any ambiguities, no need to worry, right? :)
23:15:34 <bos> solrize: replace all of your String with B.ByteString, and readFile with B.readFile
23:15:54 <tehgeekmeister> MyCatVerbs: no, not really.  Parsec's gotten rid of any possible ambiguity long before readFloat sees it.
23:17:24 <solrize> hmm, "words" wants a string arg
23:17:43 <goalieca> Bytestring contains all those things
23:17:47 <dons> B.words
23:17:48 <goalieca> B.words probably
23:18:05 <solrize> not there
23:18:07 <hpaste>  dons pasted "bytestring version" at http://hpaste.org/4922
23:18:33 <solrize> wow!
23:18:38 <dons> i'm not entirely happy with it. the word parsing is fine, but it took 4s to parse a 3M beowulf.txt (due to the Map), also, finding the top 20 keys isn't ideal.
23:18:56 <dons> should be a queue or heap of some kind
23:19:22 <dons> ghc -O2 --make
23:20:00 <bos> dons: 4 seconds? ouch!
23:20:19 <solrize> ugh, 5 seconds for me
23:20:23 <solrize> String version was 3 seconds
23:20:23 <dons> so what's going on. hmm
23:20:31 <dons> yeah. something's amiss
23:20:50 <bos> that's deeply wrong. it's about 50 times slower than it should be.
23:22:51 <hpaste>  solrize annotated "(no title)" with "my bytestring version" at http://hpaste.org/4918#a1
23:23:23 <sjanssen> dons: slow ByteString Ord, I bet
23:24:37 <goalieca> ya. if you put it in a map..
23:25:13 <dons> well, it counts the number of words in 0.07s
23:25:19 <dons> so its all in the Map
23:25:30 <bos> that's weird.
23:25:43 <sjanssen> dons: we've seen this issue before
23:25:51 <sjanssen> memcmp FFI call is sloooow
23:26:11 <dons> sjanssen: yep
23:26:17 <bos> especially for small strings.
23:26:33 <sjanssen> dons: you should rip it out :)
23:27:04 <sjanssen> even a dumb "compare x y = compare (unpack x) (unpack y)" is faster in many cases
23:27:17 <dons> i guess compare is mostly done on small strings, not 10G files
23:27:24 <dons> which was what it was optimised for originally :)
23:28:00 <goalieca> memcmp in c is just a few loc.
23:28:06 <goalieca> can probably be translated
23:28:24 <dons> oh, we've got pure haskell versions
23:28:36 <hpaste>  goalieca pasted "memcmp in c" at http://hpaste.org/4923
23:29:05 <bos> goalieca: an efficient memcmp is much more hairy
23:29:14 <skew> why don't you use them, if FFI is so slow?
23:29:23 <skew> or use them on the first 100k?
23:29:40 <goalieca> bos: let the compiler sort it out. too many architectures
23:29:48 <bos> skew: the trick is finding a sensible cutoff point
23:29:52 <solrize> why is FFI so slow, you can use an unsafe call since memcmp doesn't mutate anything right?
23:30:14 <sjanssen> solrize: even unsafe calls have significant overhead
23:30:20 <solrize> hmm
23:30:47 <sjanssen> let's all poke dons till he changes it ;)
23:30:59 <solrize> does harpy use ffi then?
23:31:25 <bos> solrize: it would have to, yes.
23:31:35 <diltsman> What would you guys suggest as the best tutorial to learning everythnig about Mondads?
23:32:00 <sjanssen> solrize: when I say "significant" I mean when compared to the work done by comparing only a few characters
23:32:03 <solrize> diltsman, there are a lot of them, they all use different angles
23:32:26 <ddarius> Read Wadler's papers.
23:32:29 <ddarius> @where wadler
23:32:29 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/
23:32:32 <sarah__> @pl append_act g a = g ++ [Node a (currentPos g)]
23:32:32 <lambdabot> append_act = liftM2 (.) (++) (flip flip [] . ((:) .) . flip Node . currentPos)
23:32:38 <tehgeekmeister> i can't nest a (name <- expr) from a do block inside an if expression, can i?
23:32:41 * ddarius goes to bed like he should have hours ago.
23:32:43 <sarah__> oh wow that didnt make it any easier to read :)
23:32:46 <solrize> yeah, wadler's "monads in functional programming", and i like the haskell wikibook article on category theory
23:33:13 <MyCatVerbs> ddarius: I've hit the point where I interpret dawn as a sign that it's time to go to bed, rather than time to wake up. x_x
23:33:16 <bos> tehgeekmeister: you have to start a new do block.
23:33:25 <solrize> diltsman what languages do you use now?
23:33:26 <tehgeekmeister> bos: thanks
23:33:28 <bos> tehgeekmeister: and the "assignment" won't be visible in the outer one.
23:33:34 <solrize> there's a good one that explains monads in terms of python lists, that helped me a lot
23:33:57 <tehgeekmeister> bos: okay, time for alternate solutions, then.
23:34:18 <hpaste>  dons annotated "bytestring version" with "only marginally faster using a different Ord" at http://hpaste.org/4922#a1
23:34:19 <diltsman> solrize: I'm mostly a C/C++ programmer.  I think I'm at the point where I understand the basics of Monads, but I have some code that works (how I think it should) but I'm not quite certain why.
23:34:37 <solrize> diltsman, yeah i'm in about the same place as you
23:34:38 <sarah__> diltsman: im new too, helped me to think of bind like a unix pipe
23:34:45 <goalieca> diltsman, moi too
23:34:45 <skew> diltsman: I think both of sigfpe's tutorials are good
23:35:57 <diltsman> I guess what is throwing me off the most is when I go from functions in one monad to functions in another monad.  I'm having trouble figuring out the correct way to do that.
23:36:02 <bos> dons: how big is the map when you're done? probably 500k elements?
23:36:36 <sjanssen> dons: what is "marginal"?
23:36:55 <dons> 43319.
23:37:04 <dons> (size)
23:37:04 <goalieca> dons: how good is the balancing...
23:37:35 <Korollary> goalieca: Ovechkin got a 13 year/$124M contract lol.
23:38:04 <dons> sjanssen: 3.267s with OrdString, 5.286 with ByteString (so a good margin)
23:38:05 * tehgeekmeister has epiphany that he can use if expressions to select which function to apply to values, instead of using if expressions to branch to the individual functions applied to the values.
23:38:06 <goalieca> Korollary, putting diPietro to shame
23:38:15 <dons> but String is faster still (i can't work that out)
23:39:01 <goalieca> tehgeekmeister, mean pattern matching?
23:39:05 * kfish works out that Ovechkin is /not/ the name of an elite type-theory consultancy
23:39:08 <dons> 2.047 for String. hmm
23:39:35 <MyCatVerbs> kfish: s/consultancy/conspiracy/
23:40:01 <skew> MyCatVerbs: but Overkin could be!
23:40:09 <tehgeekmeister> > (\a -> if a == "-" then (* (-1)) else (*1)) "-" $ 1
23:40:12 <lambdabot>  -1
23:40:14 <tehgeekmeister> versus
23:40:21 <sjanssen> how long is the average word?  In the range where [Char] is more compact than ByteString?
23:40:49 <MyCatVerbs> skew: that sounds more like a branch of an Overtly Evil Empire than a Shadowy Conspiracy Ruling From The Shadowy Shadows.
23:40:51 <dons> 5-7 letters
23:40:58 <dons> maybe less
23:41:29 <tehgeekmeister> >let f sign n = if sign == "-" then (n * (-1)) else n*1 in f "-" 1
23:41:36 <solrize> is there a way to convert the B.words output to Strings before putting them into Data.Map ?
23:41:44 <dons> count                          Main                  78.3   67.6
23:41:44 <dons> cmp                            Main                  18.5   30.2
23:41:47 <tehgeekmeister> goalieca: get what i mean now?
23:42:21 <dons> solrize: heh. good idea. its faster stlil
23:42:23 <dons> 1.5s
23:42:27 <tehgeekmeister> goalieca: it's more useful if you just return a section instead of using a lambda like i did, but you get the idea, i'm sure.
23:42:30 <goalieca> tehgeekmeister, yeh. functions are first class
23:42:33 <dons> main = do f <- head <$> getArgs x <- S.readFile f let t = foldl' count M.empty (S.words x) print . M.size $ t
23:42:36 <dons> count counts word = M.insertWith' (+) (S.unpack word) 1 counts
23:42:39 <dons> type Table = M.Map String Int
23:42:49 <dons> solrize: see the (S.unpack word), or B.unpack if you import as B
23:43:27 <solrize> ok.  but basically the current situation is there's something broken that hopefully can be patched up somehow?
23:43:28 <Korollary> how many words are there?
23:43:49 <dons> solrize: it looks like comparing is more expensive than it should be. i'm investigating
23:43:52 <tehgeekmeister> goalieca: of course, but the real beauty is that if expressions evaluate to a value -- this is not typical of the programming languages i'm used to, where they would branch flow of control, instead.
23:43:53 <solrize> korollary about 500k maybe
23:44:04 <solrize> dons and i aren't using the same file, and his machine may be faster than mine
23:44:28 <Korollary> solrize: are you comparing against python? Python dicts could be using hashmaps as opposed to maps we're using here.
23:44:30 <solrize> dons, cool
23:44:39 <solrize> korollary, yes, i'm comparing with python defaultdict
23:45:01 <sjanssen> dons: I think that the BS comparison is still slower than [Char] in the case where only the first character is checked
23:45:22 <goalieca> populating a large (balanced) map is not a fast thing to do
23:45:24 <dons> sjanssen: yeah, that sounds plausible
23:45:26 <sjanssen> compare (head x) (head x) is really fast
23:45:31 <dons> right
23:46:01 <sjanssen> BS has to do several dereferences there (deref the offset, length, pointer, then dereference the pointer itself)
23:46:13 <hpaste>  dons annotated "bytestring version" with "String compare" at http://hpaste.org/4922#a2
23:46:25 <dons> solrize: ^ so i think we're narrowing this down
23:46:31 <solrize> dons, thanks
23:47:33 * tehgeekmeister goes to bed -- fixing numeric towers is too complicated past midnight.
23:48:20 <bos> also, doing pointer arithmetic directly might save a bit of work, since ghc's optimiser isn't going to be as clever as a c compiler would be.
23:48:44 <Korollary> Holy cow. Every increment is another tree-insert?
23:49:02 <bos> iow, increment p1 and p2 directly with plusPtr
23:49:09 <sjanssen> Korollary: how else would you do it?
23:49:25 <dons> count . group . sort  ? :)
23:49:54 <sjanssen> quite probably slower
23:49:58 <skew> fromListWith could run in ST
23:50:26 <skew> why oh why didn't we get linear types in the Great Lazy Unification?
23:50:47 <sjanssen> skew: hmm?  quicksort an array or something?
23:51:00 <solrize> Your search - "great lazy unification" - did not match any documents.
23:51:36 <sarah__> is there a version of @pl that leaves some arguments intact?
23:51:37 <dons> sjanssen: yes, slower, but its beautiful :) 8.376s :)
23:52:07 <sjanssen> are we still in the realm of losing to Python?
23:52:14 <bos> sjanssen: absolutely.
23:52:16 <hpaste>  dons annotated "bytestring version" with "pretty sort.group.sort" at http://hpaste.org/4922#a3
23:52:24 <dons> what was python?
23:52:40 <solrize> speed? 0.4 sec
23:52:42 <dons> ok.
23:52:52 <skew> solrize: Haskell was made to unify a whole bunch of lazy research languages, except clean was out for lunch so we didn't get to eat their brains
23:52:55 <dons> so the two issues: Map and compare.
23:53:12 <sarah__> a bunch? wow i thought haskell was the ONLY lazy lang
23:53:16 <skew> sjanssen: I was thinking modifying the values in the nodes inplace, rather than rebuilding the path
23:53:44 <sjanssen> skew: I'm not sure that is a major issue, with the generational GC and all
23:53:47 <hpaste>  solrize annotated "(no title)" with "python" at http://hpaste.org/4918#a2
23:54:34 <skew> sarah__: there were all kinds of little research languages in the early 90s
23:54:47 <bos> you people have to stop dangling these interesting performance baubles in front of dons. he can't resist them.
23:55:10 <bos> it's like watching a cat with a piece of tinsel.
23:55:31 <solrize> i think this is one of those situations where the functional map just inherently loses to the hash table
23:55:34 <glguy> ?remember bos  you people have to stop dangling these interesting performance baubles in front of dons. he can't resist them. it's like watching a cat with a piece of tinsel.
23:55:34 <lambdabot> I will never forget.
23:55:59 <dons> solrize: i think that's part of it (we have HashTables up the sleeve if needed though)
23:56:00 <bos> solrize: probably not, they're often comparable in performance.
23:58:07 <solrize> maybe i'll try a version where the keys are integers generated by some function, instead of words from a file
23:59:38 <dons> oh there was a bad inline.
23:59:39 <dons> down to 1s
23:59:59 <solrize> cool
