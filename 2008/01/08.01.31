00:00:57 <mikmik> sm: can you list what you downloaded and installed for cabal?
00:01:10 <sm> zlib, HTTP, and then cabal-install
00:01:29 <olsner> (although it is slightly confusing that cabal-install installs the "cabal" command... I spent a fair amount of time looking for my "cabal-install" executable after I upgraded ghc)
00:01:33 <sm> after ghc 6.8.2 + extralibs
00:01:52 * wagle_ hopes for fat binaries
00:02:19 <mikmik> which extralibs?
00:02:35 <sm> you know, ghc-6.8.2-src-extralibs
00:02:49 <sm> which I believe are included in the osx binary package I installed
00:02:56 <sm> parsec etc.
00:03:12 <mikmik> ok
00:03:42 <mikmik> zlib and HTTP libs  are not haskell related, right?
00:04:03 <sm> they are compression and HTTP related :)
00:04:31 <wagle_> any news as to when 6.8.3 will be out?
00:04:33 <mikmik> (haskell newbie) provided with cabal?
00:05:02 <sm> mikmik: no, they are general-purpose libraries which cabal-install happens to depend on
00:05:38 <sm> and that's why you have to fetch and build them from hackagedb, before building cabal install
00:05:43 <sm> makes sense ?
00:06:11 <mikmik> y, just this is the first time i heard of the hackagedb
00:06:18 <sm> in other words, a fair amount of manual work to get going, still
00:06:30 <sm> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.2 eg
00:06:32 <lambdabot> http://tinyurl.com/29497c
00:06:45 <mikmik> thnx
00:07:41 <wagle_> it appears that there isnt a binary package for leopard/ppc
00:08:18 <mikmik> 6.8.2?
00:08:25 <wagle_> yeah
00:09:00 <mikmik> there is http://haskell.org/ghc/download_ghc_682.html#macosxintel
00:11:22 <wagle_> yeah, i downloaded that in hopes that its binaries are fat, but  he went out of his way to make it do i386 specific binaries
00:12:18 <sm> er, look above ? http://haskell.org/ghc/download_ghc_682.html#macosxppc
00:12:43 <lispy> no universal?
00:12:43 <sm> oh tiger.. I see
00:12:52 <wagle_> yeah
00:13:47 <wagle_> 6.8.3 is supposed to be bootstrappable..  hence my asking for any news on when thats coming out
00:14:38 <sm> for gtk2hs with 6.8.2, I suppose latest darcs version is best
00:16:14 <wagle_> oic..  6.8.2 get came out dec 12..  oh well
00:16:21 <sm> wagle_: isn't 6.8.2 bootstrappable ? there is a build guide
00:16:21 <wagle_> oic..  6.8.2 just came out dec 12..  oh well
00:17:12 <wagle_> no its not..  there's an open bug saying something about bootstrapping being messed up by the move to cabal (I think)
00:17:51 <wagle_> the milestone is the release to 6.8.3..  supposed to be moderate difficulty to fix, but only 1 day
00:18:36 <wagle_> http://hackage.haskell.org/trac/ghc/ticket/1346
00:18:37 <lambdabot> Title: #1346 (bootstrap from HC files) - GHC - Trac
00:18:49 <sm> ouch
00:20:25 * sm fetches required package with cabal.. so much better!! Thanks cabal 
00:26:34 <wagle_> eh, maybe i'll port it
00:40:27 <C-Keen> hm is anyone using ghc from macports? I tried to instal it yesterday but configure fails
00:45:03 <wagle_> what does it say?
00:47:16 <sm> gtk2hs built and installed!
00:47:25 * sm is on fire
00:56:33 <quicksilver> anyone around familiar with hmp3's source?
00:56:36 <quicksilver> dons: ping?
01:06:47 <mgsloan> http://mgsloan.nfshost.com/darcs/haskroom/
01:06:47 <lambdabot> Title: Index of /darcs/haskroom
01:06:58 <mgsloan> here's my text editor thingie sofar, after 3 days
01:07:17 <mgsloan> doesn't save or open, but it edits text :P
01:08:41 <mgsloan> 201 LOC
01:10:30 <quicksilver> screenshot screenshot!
01:11:22 <mgsloan> lol
01:12:58 <MecSympaTiK> http://www.math-linux.com site dedicated to mathematics and Linux
01:12:59 <lambdabot> Title: math-linux.com
01:13:43 <quicksilver> MecSympaTiK: coming into a channel and posting an advert as the first thing you do is pretty anti-social.
01:14:11 <MecSympaTiK> hi all
01:14:24 <siti> burn the spammer ;)
01:14:33 <MecSympaTiK> i found a very nice site dedicated to math and linux
01:14:37 <ricky_clarkson> Spurn the bammer!
01:14:37 <MecSympaTiK> http://www.math-linux.com site dedicated to mathematics and Linux
01:14:38 <lambdabot> Title: math-linux.com
01:14:46 <quicksilver> MecSympaTiK: I'm pleased for you, but this channel is about haskell.
01:14:50 <MecSympaTiK> happy new year all
01:14:52 <MecSympaTiK> :-)
01:15:11 <siti> irc spam now ?
01:15:18 <quicksilver> what do you mean 'now' ?
01:15:23 <pjd> siti: what do you mean, "now"?
01:15:23 <siti> yeah true
01:15:27 <quicksilver> there has been IRC spam since irc was invented :)
01:15:40 <ricky_clarkson> Ever since the Finns joined.
01:15:50 <quicksilver> XXX visit my cool new newsgroup alt.binaries.strange.but.true !
01:16:05 <quicksilver> however the advent of pay per click affiliation has definitely made it worse :)
01:16:16 <ricky_clarkson> IRC is just an advert for google.
01:16:27 <lispy> is there a function (i'm thinking something like sequence) that takes a list of Maybe a, and returns the first Just a?
01:16:29 <quicksilver> the real world is just an advert for google.
01:16:38 <quicksilver> lispy: head . catMaybes ?
01:16:50 <quicksilver> listToMaybe . catMaybes
01:16:56 <mgsloan> http://mgsloan.nfshost.com/haskroom.png
01:16:59 <quicksilver> (if you want to admit the possibility there may not be one)
01:17:01 <lispy> :t head . catMaybes
01:17:01 <lambdabot> forall a. [Maybe a] -> a
01:17:13 <lispy> :t listToMaybe
01:17:13 <lambdabot> forall a. [a] -> Maybe a
01:17:30 <lispy> quicksilver: okay, I had head . catMaybes but i talked myself out of it...
01:17:32 <quicksilver> mgsloan: looks nice!
01:17:35 <lispy> but yeah, i think it is right
01:17:37 <ricky_clarkson> > head . catMaybes [Nothing,Nothing,Just 5,Just 10]
01:17:37 <lambdabot>  Couldn't match expected type `a -> [a1]'
01:17:38 <mgsloan> thanks
01:17:44 <quicksilver> ricky_clarkson: ( )
01:17:48 <quicksilver> or $ ;)
01:17:49 <ricky_clarkson> > head . catMaybes $ [Nothing,Nothing,Just 5,Just 10]
01:17:50 <lambdabot>  5
01:18:11 <ricky_clarkson> Path of least cursor-movement.
01:18:16 <quicksilver> ;)
01:18:42 <ricky_clarkson> (my home key is a silly Fn combination)
01:18:56 <quicksilver> M-3 M-(
01:19:07 <quicksilver> two keystrokes to add brackets around head . catMaybes :)
01:19:46 <quicksilver> mgsloan: you should use gentle continuous shades of colour to indicate recentness of editing
01:19:49 <ricky_clarkson> ERC?
01:20:03 <quicksilver> mgsloan: most recently edited text is bright red, then it fades out gradually to grey :)
01:20:10 <mgsloan> quicksilver - hah, that'd be cool
01:20:14 <quicksilver> ricky_clarkson: to be honest, no, I don't IRC from within emacs. But if I did :)
01:20:16 <mgsloan> not so easily done
01:21:35 <nominolo> :t (+3) >>= [1..4]
01:21:36 <lambdabot>     Couldn't match expected type `a -> a -> b'
01:21:36 <lambdabot>            against inferred type `[a1]'
01:21:36 <lambdabot>     In the second argument of `(>>=)', namely `[1 .. 4]'
01:22:24 <pjd> > mconcat . map First $ [Nothing, Just 1, Nothing, Just 2]
01:22:24 <lambdabot>   Not in scope: data constructor `First'
01:22:34 <mgsloan> the fun thing, was that once I wrote adequate zipper functions, all the text editing ops just fell into place, zero effort
01:22:42 <pjd> is Data.Monoid.First recent?
01:23:04 <pjd> mgsloan: article! article!
01:23:07 <mgsloan> lol
01:23:12 <ricky_clarkson> mgsloan: Are you responsible for Yi?
01:23:17 <quicksilver> mgsloan: yeah, zippers are very cool
01:23:18 <mgsloan> definitely not!
01:23:31 <quicksilver> mgsloan: I have a couple of programs which incorporate simple readline-style line editing
01:23:41 <quicksilver> mgsloan: with a zipper you can knock up readline bindings in seconds
01:23:45 <mgsloan> Yi is pretty advanced stuff
01:23:46 <mgsloan> yep
01:24:18 <mgsloan> I'm worried about selection, though
01:24:29 <nominolo> mgsloan: can you have concurrent editing with zippers?
01:24:29 <mgsloan> may just go about it the old fashioned way
01:24:47 <mgsloan> subethaedit style?
01:24:48 <quicksilver> you can have concurrent editing with zippers, yes
01:24:58 <nominolo> mgsloan: yep
01:24:59 <quicksilver> there is an Oleg about it
01:25:07 <quicksilver> even concurrent editing with ACID
01:25:08 <quicksilver> IIRC
01:25:20 <nominolo> quicksilver: olegs zipfs needs an explicit commit
01:25:21 <mgsloan> is there an oleg about it? very interesting
01:25:34 <nominolo> mgsloan: google for zipper filesystem
01:25:39 <mgsloan> alright
01:26:05 <nominolo> mgsloan: he uses delimeted continuations (which are essentially zippers)
01:26:18 <nominolo> *delimited
01:26:31 <quicksilver> still, I kind-of agree with mgsloan about old-fashioned way
01:26:43 <quicksilver> if you want concurrent editing, you probably want network-aware concurrent editing
01:26:45 <nominolo> what would that be?
01:26:52 <quicksilver> if it's network-aware, you need an explicit protocol anyway
01:27:06 <quicksilver> once you've got an explicit protocol it's not particularly hard, although it's less "clever"
01:27:34 <mgsloan> it's certainly a hard problem
01:27:49 <nominolo> quicksilver: the problem is that you would have to jump between places a lot
01:28:02 <nominolo> quicksilver: which is bad in a zipper structure
01:28:10 <quicksilver> nominolo: yup. You'd be giving some of the advantages of a zipper.
01:28:18 <mgsloan> it's actually not that bad.  I'm using nested Zippers
01:28:22 <quicksilver> but you have have a zipper with Data.Seqeunces on either side.
01:28:27 <quicksilver> then it's not that expensive.
01:28:30 <mgsloan> the outer Zipper is of line breaks, the inner is paragraphs
01:28:52 <nominolo> hm
01:28:55 <quicksilver> you can have a zipper with two focusses too
01:29:00 <nominolo> never tried nested zippers
01:29:03 <quicksilver> I'm just not sure the extra complexity is worth it
01:29:15 <quicksilver> a zipper with two focusses has rather a lot of constructors
01:29:15 <mgsloan> it mucks things up a little bit, actually
01:29:27 <mgsloan> but it's worth it efficiency wise, I hope
01:29:29 <wagle_> hmm..  cant install ghc from macports without having ghc installed..  i'm going to bed to enumerate this dependency
01:29:35 <quicksilver> if a zipper is the derivative of a data type
01:29:41 <mgsloan> zipper with two focuses might be necessary for selection
01:29:43 <quicksilver> then a two-focus zipper is the derivative of a zipper
01:29:45 <quicksilver> IIRC.
01:29:46 <mgsloan> or at least elegant selection
01:29:55 <nominolo> wagle_: there are binary distros
01:29:55 <mgsloan> yeah, I read the higher order zippers post
01:30:11 <quicksilver> I remember Conor muttering about it
01:30:24 <quicksilver> but even a single zipper causes something of a constructor explosion
01:30:31 <quicksilver> each extra time you differentiate it gets worse
01:30:38 <quicksilver> (not too bad if your basic ADT is simple though)
01:30:53 <wagle_> nominolo, yeah, but the last one i tried ignored my cpu architecture
01:31:19 <nominolo> wagle_: is there a ghc package on fink?
01:31:20 <wagle_> no ghc for macosx 10.5 on a ppc
01:31:35 <nominolo> oh, ppc user
01:33:02 <tumdum> wagle_: use gentoo prefix
01:33:18 <wagle_> people asked about it on the mailing list, but got no answer...  but i'm not done poking around, just very sleepy
01:34:03 <ddvlad> is there any sort of library for generating SVG files?
01:34:27 <mgsloan> you could use cairo and the SVG backend
01:34:33 <mgsloan> (it's part of gtk2hs)
01:35:38 <wagle_> lookit ma!  an excuse to poke around gentoo
01:36:05 <ddvlad> hmm... i'll try that
01:37:47 <quicksilver> as far as I know that's the only option at the moment.
01:37:59 <quicksilver> (svg cairo backend)
01:51:03 <sm> hmm. The gtk2hs cube demo fails with dyld: lazy symbol binding failed: Symbol not found: _glXQueryExtension
01:51:03 <sm>   Referenced from: /opt/local/lib/libgdkglext-x11-1.0.0.dylib
01:51:50 <sm> I wonder if I needed to make clean before re-configuring with opengl
01:52:27 <quicksilver> do you have opengl libs installed?
01:57:54 <lispy> does this define a type level set for naturals?
01:57:54 <lispy> data Zero; class Succ a where; instance Succ Zero where; instance (Succ a) => Succ a where; class Nat n where; instance Nat Zero where; instance (Succ a) => Nat a where;
01:58:32 <lispy> I should really sleep.
02:00:56 <what> is someone using a current wxHaskell on windows?
02:01:08 <int-e> lispy: ITYM  data Zero; data Succ a; class Nat n where; instance Nat Zero where; instance Nat n => Nat (Succ n) where
02:02:31 <lispy> int-e: ah
02:03:20 <lispy> int-e: yeah, that is what i meant
02:03:27 <lispy> tthanks
02:08:52 <sm> Shu-thing and Monadius rock
02:10:11 <ibid> hm, is there a way to ask ghci what type `op` must have in an expression a `op` b where the types of a and b are known?
02:11:11 <ibid> (as well as the type of the whole expression)
02:11:14 <nominolo> > (undefined :: Int) + (undefined :: Int)
02:11:15 <lambdabot>  Undefined
02:11:25 <nominolo> :t (undefined :: Int) + (undefined :: Int)
02:11:26 <lambdabot> Int
02:11:48 <nominolo> :t \x y -> (x :: Int) + (y :: Int)
02:11:49 <lambdabot> Int -> Int -> Int
02:11:57 <ibid> good point :)
02:12:21 <ibid> but doesn't that assume that i already have a definition of (+) in the environment?
02:12:38 <nominolo> you want an undefined operator?
02:12:46 <nominolo> :t \op x y -> (x :: Int) `op` (y :: Int)
02:12:47 <lambdabot> forall t. (Int -> Int -> t) -> Int -> Int -> t
02:12:54 <nominolo> the first one is your op
02:13:28 <ibid> i want to know, given expressions a and b and given a known type for a `op` b, what is a (useful, not just forall a . a) type for `op`
02:13:31 <nominolo> :t \op -> (undefined :: Int) `op` (undefined :: Int)
02:13:31 <lambdabot> forall t. (Int -> Int -> t) -> t
02:13:43 <ibid> mh
02:13:48 <ibid> let's try that
02:15:47 <sandbox> What do you suggest for ffi?  c2hs, hsc2hs, or native ffi?
02:16:12 <quicksilver> depends what you're trying to do
02:16:29 <quicksilver> for binding a simple C library which uses strings and ints, using the FFI directly is pretty convenient.
02:16:47 <quicksilver> if you have structs to marshal, you probably need more help.
02:17:49 <nominolo> what is Twan van Laarhovens nick here?
02:17:54 <quicksilver> twanvl
02:18:07 <nominolo> @karma+ twanvl
02:18:07 <lambdabot> twanvl's karma raised to 8.
02:18:34 <nominolo> nice p.h.o post
02:18:48 <nominolo> especially the final remark "Coming soon to a lambdabot near you."
02:18:49 <sandbox> Thanks.  Also I see the Addr type used, has that been removed in favor of Ptr a?
02:19:12 <quicksilver> sandbox: hmm. Where are you seeing Addr?
02:19:44 <sandbox> an old paper from c2hs
02:20:26 <quicksilver> yeah, I think that's been removed in favour of Ptr
02:20:39 <sandbox> okay, thanks
02:25:10 <jacobian_wrk> Anyone know why the approximation lemma is supposedly better than the take lemma
02:25:41 <jacobian_wrk> it seems to me that it disambiguates an approximation from a complete reconstruction of the list
02:25:58 <jacobian_wrk> but do we really need to use bottom?  Could we not just define a list type with 3 constructors
02:26:35 <jacobian_wrk> AList a = Bot | Nil | Cons a AList
02:43:44 <trontonic> I want to draw the userinterface to a program in SVG and combine it with Haskell. I'm relatively noob at Haskell, what are my chances? :D
02:46:18 <earthy> trontonic: reasonable if you use gtk+ and cairo
02:46:30 <earthy> and gtk2hs
02:46:39 <paolino> ciao, is it any possible to implement a puts , as gets for get  in the State monad ?
02:46:50 <trontonic> earthy: thanks, I'll look into those
02:46:55 <earthy> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.11/Graphics-Rendering-Cairo-SVG.html
02:46:56 <lambdabot> http://tinyurl.com/3bwn8u
02:47:41 <paolino> I tried this with no luck
02:47:44 <paolino> puts f x = get >>= \y -> put y{f=x}
02:48:03 <paolino> f out of scope
02:50:26 <desegnis> paolino, you've hit the problem about record syntax that record updates are not functions
02:51:41 <quicksilver> paolino: it's not, in fact.
02:51:53 <quicksilver> paolino: at least, not without listing the cases
02:52:03 <quicksilver> perhaps by maybe a new data type which makes your labels first class.
02:52:28 <quicksilver> trontonic: if nothing else you'll learn some interesting stuff on the way :)
02:53:09 <paolino> quicksilver: is there a class to implement to get those ?
02:53:12 <trontonic> quicksilver: probably. I wish there was a SVG-gui-designer that combined easily with Haskell, though :) If I learn enough, I'll try to make one ;)
02:53:46 <desegnis> quicksilver, re new data type: which would be a Map or an Array over a custom (small) domain, probably?
02:54:22 <desegnis> sounds irksome though
02:55:39 <quicksilver> desegnis: I just meant an enumerated type.
02:55:52 <quicksilver> data Rec = Rec { x :: Int, y :: Int}
02:55:57 <quicksilver> data Label = X | Y
02:56:06 <quicksilver> get X = x ; get Y = y;
02:56:18 <quicksilver> put X nx = \r -> r { x = nx }
02:56:26 <quicksilver> put Y ny = \r -> r {y = ny}
02:56:28 <quicksilver> you get the idea
02:56:37 <quicksilver> can use Data.Derive / TH to automate it of course,
02:56:44 <desegnis> well then, you still have the biolerplate
02:56:51 <DanHerg> Cool Euro Jobs site ===> new-gen employment eu
02:57:00 <desegnis> oh, you think of automating it
02:57:06 <quicksilver> DanHerg: no advertising thanks
02:58:27 <quicksilver> desegnis: I'd like something along these lines to be built in to haskell but I'm not sure how exactl.
02:59:56 <desegnis> quicksilver, well you probably know the great handful of Haskell'-new-record-system proposals
03:01:40 <quicksilver> desegnis: yeah. I don't know what the right asnwer is though :)
03:01:45 <desegnis> yeah
03:02:36 <dcoutts_> sm: sounds like you don't have the opengl libs available libgdkglext is referencing the gl libs and _glXQueryExtension is definitely a gl function that should be found in the standard gl libs
03:04:31 <sm> thanks dcoutts .. I do have gtkglext installed at least and was able to configure --with-opengl and build the opengl demo..
03:05:17 <dcoutts_> sm: but then it doesn't run, because it cannot find the gl libs?
03:06:35 <sm> right.. just that one
03:06:47 <titusg> I just installed ghc 6.8.2 from binaries and ghc-pkg is still looking at an older version 6.6 -- what do I need to change in my path?
03:07:05 <sm> _glXQueryExtension symbol
03:07:50 * sm tries again after make clean
03:08:36 <hpaste>  sm pasted "full error message" at http://hpaste.org/5360
03:18:42 <sm> no, that wasn't it
03:18:51 <sm> same error
03:20:37 <titusg> hmm, installing 6.8 hadn't touched the old link /usr/bin/ghc-pkg which was to ghc-pkg6.6
03:20:58 <sm> titusg: probably installed to /usr/local ?
03:21:09 <titusg> sm: yes
03:21:49 * sm puts that ahead of /usr/bin in PATH
03:22:28 <sm> well enough progress for today.. g'night all
03:47:54 <RayNbow> @src fmap
03:47:54 <lambdabot> Source not found. That's something I cannot allow to happen.
03:48:27 <RayNbow> @src Control.Monad.fmap
03:48:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:48:47 <RayNbow> oh right...
03:48:47 <quicksilver> RayNbow: fmap is a method
03:48:54 <RayNbow> yeah, I just figured out :p
03:48:57 <quicksilver> RayNbow: so it has a different @src per instance
03:48:59 <quicksilver> @src [] fmap
03:49:00 <lambdabot> fmap = map
03:49:03 <quicksilver> for example
03:49:07 <quicksilver> @src Maybe fmap
03:49:07 <lambdabot> fmap _ Nothing       = Nothing
03:49:07 <lambdabot> fmap f (Just a)      = Just (f a)
03:49:21 <RayNbow> @src Gen fmap
03:49:21 <lambdabot> Source not found. :(
03:49:28 <RayNbow> @src Test.QuickCheck.Gen fmap
03:49:28 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:49:59 <Deewiant> oh cool, you can query method src like that
03:50:15 <Deewiant> I tried adding a type signature, which doesn't work
03:50:40 <RayNbow> @src (Test.QuickCheck.Gen) fmap
03:50:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:50:51 <RayNbow> hmm...
03:51:02 <RayNbow> @src Test.QuickCheck.generate
03:51:03 <lambdabot> Source not found. You type like i drive.
03:51:11 <RayNbow> it doesn't have the source of QC?
03:51:28 <Deewiant> probably not
03:51:55 <kaol> @instance Functor
03:51:56 <lambdabot> Maybe you meant: instances instances-importing
03:52:00 <kaol> @instances Functor
03:52:01 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:52:24 <kaol> @src ((->) r) fmap
03:52:24 <lambdabot> Source not found. :(
03:53:47 <doserj> @src (->) fmap
03:53:48 <lambdabot> fmap = (.)
03:55:43 <quicksilver> RayNbow: @src is a rather small database generated "by hand" in som esense.
04:03:48 <RayNbow> quicksilver: ah
04:06:34 <nominolo> So, Lemmih, how are the working conditions at the L.I.T. ?
04:11:23 <Lemmih> L.I.T. ?
04:11:50 <nominolo> "The Lemminian Institute of Technology "
04:13:08 <Lemmih> Ah, yes. It's one of the better institutes I've been at, I'd say.
04:13:50 <nominolo> good to hear.  funding is ok?
04:15:37 * dcoutts_ wonders if L.I.T. offers summer internships
04:16:09 <idnar> @src (->) return
04:16:09 <lambdabot> return = const
04:16:27 <eu-prleu-peupeu> hello
04:16:29 <Lemmih> The faculty is very limited. Our funding needs can usually be met by the loot collected from under the couch.
04:16:34 <eu-prleu-peupeu> when is a "haskell summer of code" going to appear ?
04:16:41 <dcoutts_> Lemmih: :-)
04:18:20 <nominolo> eu-prleu-peupeu: google is still not sure if the will be a new summer of code
04:19:03 <eu-prleu-peupeu> hmm, but im asking about haskell summer of code
04:19:11 <eu-prleu-peupeu> much like the ocaml summer of code: http://osp2007.janestcapital.com/
04:19:12 <lambdabot> Title: The OCaml Summer Project
04:19:21 <nominolo> eu-prleu-peupeu: there is no separate haskell summer of code
04:19:47 <nominolo> eu-prleu-peupeu: it's haskell.org mentorship for google summer of code
04:20:09 <eu-prleu-peupeu> hmm okey
04:22:33 <hpaste>  resiak pasted "c2hs {#pointer#} and {#fun#} confusion" at http://hpaste.org/5362
04:23:37 <dcoutts_> resiak: you need to use a marshaler, to say how the type should be passed to the foreign code
04:23:51 <dcoutts_> resiak: there are only default marshalers for simple things like CInt etc
04:24:04 <dcoutts_> {# pointer #} does not make any extra default marshaler
04:24:24 <resiak> sure, but I just want it swaddled in the newtype... hrm, so should I just provide the newtype constructor as the marshaller ?
04:24:46 <dcoutts_> resiak: probably
04:26:37 <resiak> dcoutts_: victory!  thanks.
04:27:00 <resiak> Hrm, it'd be handy if {# pointer #} generated   unFoo (Foo ptr) = ptr   marshallers
04:27:03 <dcoutts_> resiak: it's a bit silly I admit, but currently there is no way to extend the default marshalers
04:27:43 <resiak> hrm, perhaps I can use propagateGError as the in marshaller for GErrors!
04:28:35 <resiak> doh, c2hs: c2hs/gen/GenBind.hs:(903,12)-(907,22): Non-exhaustive patterns in case
04:28:38 <resiak> c2hs: c2hs/gen/GenBind.hs:(903,12)-(907,22): Non-exhaustive patterns in case
04:28:40 * resiak growls at irssi.
04:36:07 <eugman|work> This is going to sound wierd but is there a windows installer that doesn't require a gui and such? I'm guessing not.
04:36:16 <eugman|work> installer for ghc that is
04:47:40 <dcoutts_> eugman|work: you can install .msi packages without using the gui
04:47:55 <nominolo_> @hoogle Bool -> a -> a -> a
04:47:56 <lambdabot> No matches, try a more general search
04:47:59 <dcoutts_> eugman|work: check the MS documentation on the MSI installer system
04:50:04 <RayNbow> hmm, still all these Arc submissions @ reddit...
04:59:11 <nominolo_> RayNbow: just downvote
04:59:38 <nominolo_> also, that's just what happens if a bubble bursts ;)
05:08:49 <resiak> dcoutts_: {#fun#} enlightenment has struck --- thanks for the pointers.
05:10:41 <dcoutts_> resiak: np. I usually ignore it and use {# call #} everywhere, that uses less magic
05:11:30 <resiak> oh, really?  I'm doing this precisely to avoid using {# call #} everywhere, because I seem to wind up duplicating all the enum -> CInt marshalling everywhere
05:12:19 <dcoutts_> resiak: we use {# call #} in gtk2hs, but then we're also mostly auto-generating the .chs files
05:12:29 <dcoutts_> so the duplication doesn't matter so much
05:12:45 <resiak> right, so I saw when using it as example code
05:13:07 <jedbrown> dcoutts_: I'm surprised too.  I found {# fun #} really nice once I understood it.  Saves keeping track of lots of withFoo, and alloc nonsense.
05:13:31 <opqdonut> {#fun#}?
05:13:42 <dcoutts_> jedbrown: aye, if only it were possible to declare extra default marshalers
05:13:43 <opqdonut> that isn't a pragma right?
05:13:55 <jedbrown> opqdonut: c2hs magic
05:14:11 <resiak> doh, using propagateGError as the in marshaller for a GError parameter winds up putting it in the wrong place :(
05:14:15 <opqdonut> jedbrown: oh okay
05:14:17 <dcoutts_> jedbrown: and often I want to do custom checks that are not marshalers at all, so having it generate a top level function rather than just an expression is not what I want
05:14:52 <jedbrown> dcoutts_: Yeah, my libraries are much simpler.
05:15:04 <resiak> propagateGError $ \gErrPtr -> do { ptr <- {# call... #} gErrPtr; munge ptr } -- does the wrong thing if ptr is NULL when an error is raised.
05:15:15 <resiak> well, it was a nice honeymoon while it lasted!
05:15:58 <rekso> When I try to compile GHC 6.8.2 from source (using a binary distro of GHC 6.8.2 as the compiler), I get 'ghc-6.8.2: panic! (the 'impossible' happened)'. Should I report it as a bug, as the error message suggests?
05:16:19 <earthy> yes
05:16:32 <earthy> that is: if it's not in the bugdb already
05:16:39 <rekso> Okay, thanks! I thought maybe I was just doing something stupidâ€¦
05:16:52 <earthy> even if you're doing something stupid the impossible should not happen
05:16:59 <rekso> :-)
05:17:02 <pejo> The compiler shouldn't panic from things you throw at it.
05:17:16 <earthy> especially if it is the compiler itself. :)
05:17:26 <pejo> Well - insert the usual stereo quote.
05:17:30 <dcoutts_> resiak: hmm, looking at checkGError it does seem to check if the returned ptr is null
05:17:32 <mauke> I have a reliable way to crash gcc 4 and they won't fix it
05:17:42 <earthy> note, however, that this may well be a sign of faulty memory in your system, rekso
05:17:56 <earthy> probably not, but it may be
05:17:58 <rekso> I hope not, earthy!
05:18:06 <jedbrown> resiak: Cale would tell you that compiling from source is stupid.  It's a pet peeve of his, lately :)
05:18:07 <dcoutts_> resiak: oh, if the result is null but the err is not null?
05:18:07 <spy-> good evening every1
05:18:11 <resiak> dcoutts_: exactly that
05:18:11 <Saizan> rekso: make sure you can reproduce it, though
05:18:16 <spy-> i got a silly question to make...
05:18:20 <earthy> heh, I've once sold a computer as perfectly functioning that I *knew* had flaky memory
05:18:30 <resiak> dcoutts_: lots of functions are guaranteed only to return NULL if they set the GError **
05:18:34 <earthy> however, the flakiness only showed when compiling linux kernels...
05:18:52 <earthy> spy-: shoot
05:18:52 <rekso> Saizan: It's happened twice now. If it happens a third time, after a 'make clean', then I'll report it.
05:19:00 <spy-> i want to use regex in haskell
05:19:05 <spy-> i read the tutorial in http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
05:19:06 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
05:19:19 <spy-> but still can't get the program working
05:19:20 <dcoutts_> resiak: hmm, but if there is an error then they are supposed to set the GError **
05:19:34 <spy-> i can't understand how i will match the string i read from input
05:19:39 <spy-> with the regex
05:20:06 <resiak> dcoutts_: they do
05:20:17 <dcoutts_> resiak: then I don't understand, it should work
05:20:42 <resiak> i'll hpaste an example
05:20:44 <resiak> :w
05:20:48 <spy-> (the string read is a hole file that contains names and e-mail addresses, and i want to get the name and e-mail addr so that i can put them in another file
05:20:49 <Saizan> spy-: can you paste the relevant code and the error? on hpaste.org
05:20:49 <dcoutts_> resiak: checkGError checks if the function set the GError, if it did then we throw the error, otherwise we return the result
05:21:10 <spy-> Saizan: okay...
05:21:51 <hpaste>  spyros pasted "(no title)" at http://hpaste.org/5368
05:22:15 <earthy> spy-:   map (=~ regex) (words file) :: [[String]]   should magically do interesting things
05:22:43 <spy-> so i would create a function, let's say matchname
05:22:57 <spy-> that is matchname s = map (=~ regex) s ?
05:23:06 <earthy> nop
05:23:09 <spy-> sorry
05:23:32 <hpaste>  resiak pasted "propagateGError" at http://hpaste.org/5369
05:23:33 <earthy> basically, what you are doing is applying the regexp just once on the entire file, and hoping that it will return a matched string
05:23:46 <spy-> i do not want that
05:23:52 <spy-> i tried to write a function
05:23:59 <spy-> to use pattern matching
05:24:06 <resiak> dcoutts_: ^^
05:24:07 <earthy> yes. how would you apply that pattern match more than once?
05:24:29 <spy-> i really don't know...
05:24:49 <spy-> somehow i must "reduce" the input string
05:24:53 <earthy> okay, now, given that the file "names" probably has a shitload of lines in it
05:25:06 <spy-> yeah...
05:25:22 <earthy> the function    lines s    will give you a *list* of those lines
05:25:34 <spy-> so i will have a list
05:25:42 <earthy> now, for each of those lines you want to generate a <li>
05:25:46 <spy-> with as many elements as lines that i will have
05:25:50 <spy-> yes
05:25:51 <earthy> spy-: exactly
05:25:58 <spy-> perfect
05:26:01 <spy-> go on please...
05:26:09 <earthy> so you want to write a function that given a line generates the appropriate <li>
05:26:19 <dcoutts_> resiak: ah, yes I see. Yes you have to wrap the call directly without putting other stuff in the body.
05:26:19 <spy-> exactly
05:26:40 <earthy> probably this function applies each regexp match you've defined just once
05:26:55 <earthy> spy-: then you 'map' that function over the lines
05:26:58 <spy-> yes yes, every line contains only one name and e-mail address
05:27:09 <earthy> i.e.   map generateLi (lines s)
05:27:19 <spy-> yes yes
05:27:22 <spy-> okay so far
05:27:29 <spy-> but how do i do the matchig?
05:27:30 <resiak> dcoutts_: right; so propagateGError can't be used as the in marshaller in {#fun#} .  which is fine.  i'll survive :_)
05:27:32 <earthy> now you have a list of  <li> thingies, probably strings
05:27:46 <spy-> excellent
05:27:48 <earthy> spy-: just as you've written
05:28:01 <dcoutts_> resiak: ah, I see, because it doesn't guarantee anything about the marshaler order
05:28:13 <spy-> namematch s = s =~ name ?
05:28:14 <earthy> you may want to be explicit in the type of result you want from your match, but otherwise it's just fine
05:28:30 <earthy> yeah
05:28:36 <earthy> but add    namematch :: String -> String
05:28:44 <spy-> all righty
05:28:52 <spy-> thank you very much earthy. i will try that
05:29:04 <spy-> and if something goes wrong or so, i will be (unfortunately) back
05:29:11 <spy-> thank you so much again
05:29:28 <shag> does someone know when there will be a new cabal version that works with haddock 2.0?
05:30:20 <Saizan> shag: at least the darcs version does, have you done a ./Setup clean after installing 2.0?
05:30:31 <shafty> hi, are there any working binary packages of ghc for solaris 11 x86?
05:30:37 <dcoutts_> @seen ehird
05:30:38 <lambdabot> I saw ehird leaving #haskell 11h 55m 18s ago, and .
05:31:28 <shag> Saizan: yes, i already posted my error here and someone went to fix it, but i have to wait for a new cabal version to be able to generate my docs again
05:31:58 <shag> Saizan: so i just wanted to know if i have to wait two weeks or two months
05:32:10 <dcoutts_> @tell ehird here's a company using gtk+ for their Win/Linux/OSX prog. Seems to be using a native theme on OSX. http://www.synctv.com/blog.html See the screenshots too.
05:32:10 <lambdabot> Consider it noted.
05:35:31 <quicksilver> dcoutts_: there are quite a few places with native OSX Gtk but it's not considered stable yet
05:35:43 <quicksilver> dcoutts_: I think one of the big sound editing programs pushed the development.
05:36:14 <dcoutts_> quicksilver: though I don't think people will take it seriously until they do the last bit and do a native theme
05:36:32 <dcoutts_> that company seems to be using a custom gtk+ theme
05:36:41 * quicksilver nods
05:36:41 <dcoutts_> that looks rather like the OSX metal theme
05:37:10 <dcoutts_> for some reason media players seem to be able to get away with using non-standard themes
05:37:31 <quicksilver> cool programs are allowed to
05:37:35 <quicksilver> I blame Kai's Power Tools
05:37:56 <quicksilver> seriously though UI innovation is much more interesting than UI standardisation.
05:38:11 <mux> well I much prefer media players that use the bare metal widgets
05:38:38 <mux> I don't want one of my application to resemble a breed between a spaceship and a cd player
05:38:53 * dcoutts_ would use hmp3, except that it doesn't do oggs
05:39:00 * dcoutts_ prods dons 
05:39:14 <RayNbow> hmm, if I need to do a lot of swapping of elements... should I use arrays then?
05:39:40 <dcoutts_> RayNbow: or a Data.Sequence if you want it to be purely functional
05:40:01 * mux use mpd with mpc/gmpc these days
05:40:24 <mux> I like to be able to reboot my X11 server without any pause in the audio playback
05:40:34 <jedbrown> cmus is also a good text-only music player
05:41:03 <cnwdup> I have a function of type (XEventPtr -> IO a) -> IO a and I want its first argument to be a function of type XEventPtr -> App () where App () is StateT Conf IO. Is it possible to lift the first function into the StateT monad? Or do I have to write a new functions that's of the type being demanded?
05:42:11 <RayNbow> dcoutts_: ah thx
05:43:10 <quicksilver> dcoutts_: wouldn't you have to call it hoggs then?
05:43:33 <dcoutts_> quicksilver: I want it do to both, since I have a mixed collection
05:43:42 <quicksilver> I wasn't entirely serious :)
05:43:47 <dcoutts_> so no need for a name change, though hoggs is a nice name :-)
05:43:47 <quicksilver> Let loose the hoggs of war!
05:43:56 <dcoutts_> @yarr!
05:43:56 <lambdabot> Yo ho ho, and a bottle of rum!
05:43:57 <quicksilver> cnwdup: interesting question.
05:44:20 <desegnis> cnwdup: Which is the function you're going to change?
05:44:45 <scook0> it might be possible to fetch the state, supply that to runStateT (to get an IO), and then set the outer state to the result state
05:44:49 <scook0> does that make sense?
05:44:51 <quicksilver> cnwdup: if you're free to change the function, you could change the function
05:45:08 <cnwdup> desegnis: Well... I guessed I have to explain my whole situation. I think my general approach isn't right. So here it somes.
05:45:17 <quicksilver> cnwdup: to something like MonadIO m => (XEventPtr -> m a) -> m a
05:45:17 <quicksilver> that would be a good type.
05:45:19 <quicksilver> if you're need free to change the function.
05:45:24 <quicksilver> if you're not, then
05:45:51 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
05:45:52 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
05:46:09 <cnwdup> I am experimentating with Haskell and Xlib and as my application just creates one window I thought it'd be smart to write drawing function which just takes what to draw. Not the display, window parameters, etc. as they're the same for every function call.
05:47:06 <quicksilver> check out this post for a rambling explanation of this problem.
05:47:08 <cnwdup> Now as I have to deal with X event, namely the Expose event, I want to redraw the window. Unfortunately appearently I cannot use my "smart" functions as they're of type App () and allocaXEvent needs a function that is XEventPtr -> IO a and not XEventPtr -> App a.
05:47:20 <quicksilver> and the issues involved with threading monads through callback.
05:47:20 <cnwdup> Thanks, quicksilver. I'll have a look.
05:47:20 <dcoutts_> cnwdup: more fun to use xcb than x11 and integrate cairo drawing :-)
05:48:17 <cnwdup> dcoutts_: Will a have look into xcb, too. Thanks. (:
05:48:26 <dancor> is there a version of System.Cmd.rawSystem that takes an exact path to the executable instead of using PATH
05:51:02 <dcoutts_> dancor: if you specify an ./ or / absolute path then it doesn't use the $PATH
05:51:08 <RayNbow> hmm dcoutts_, there's no elemIndex for Sequence?
05:51:15 <dcoutts_> dancor: and for that there's findExecutable
05:51:24 <desegnis> cnwdup, I see, the bottom of your problem is how to make the state monad and an event-driven system work together
05:51:28 <quicksilver> :t elemIndex
05:51:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
05:51:43 <dcoutts_> RayNbow: there's splitAt
05:52:04 <dcoutts_> RayNbow: and also index, but you want splitAt
05:52:05 <desegnis> cnwdup, no evident elegant solution on the horizon
05:52:15 <quicksilver> RayNbow: try elemIndex . toList
05:52:33 <quicksilver> well, elemIndex e . toList
05:52:36 <dcoutts_> quicksilver: he's using Data.Sequence, not list
05:52:48 <quicksilver> dcoutts_: that's why toList was there
05:52:57 <quicksilver> think of toList as a view, don't be afraid to use it.
05:53:01 <dcoutts_> that's linear, index is log
05:53:09 <quicksilver> elemIndex !
05:53:14 <quicksilver> is what he said he wanted.
05:53:16 <dcoutts_> oh
05:53:20 <quicksilver> that is inevitably linear.
05:53:27 <RayNbow> :p
05:53:49 <RayNbow> but thx, I'll just use toList :)
05:53:53 <quicksilver> lists are the natural structure for linear loops in haskell, so don't be surprised if any linear operations might as well go via toList.
05:54:07 <quicksilver> of course, sublinear ops should be expected not to go via lists, that would be foolish :)
05:54:38 <desegnis> cnwdup, because I guess you'd want some way to thread the state through the various drawing actions chronologically
05:55:08 <quicksilver> desegnis: right, you need a way to thread a monad through the IO callbacks.
05:55:17 <quicksilver> desegnis: the post I linked to explains how you can do that.
05:55:29 <desegnis> ah, fine
05:56:18 <cnwdup> desegnis: I guess so. Mh, think I have to look up an alternative for allocaXEvent.
06:00:39 <spy-> earthy: i tried to do as you instructed
06:00:42 <hpaste>  spyros pasted "(no title)" at http://hpaste.org/5370
06:00:54 <spy-> i uploaded the code into hpaste
06:01:00 <spy-> but i get an error while compiling
06:01:11 <spy-> Couldn't match expected type `Char' against inferred type `[Char]'
06:01:36 <desegnis> cnwdup, if I understand quicksilver's link correctly, the solution to the threading-through is just using an IORef for the state, and some cosmetics around it so you don't have to mess with IORefs directly
06:01:51 <mauke> spy-: sout is a list of strings, not a string
06:02:10 <quicksilver> desegnis: right. Only way to do it, AFAIK.
06:02:15 <spy-> right mauke
06:02:18 <Lemmih> spy-: You might want 'unlines'.
06:02:24 <spy-> thanks Lemmih
06:02:31 <quicksilver> desegnis: IO is an 'almost-universal' monad due to IORef
06:02:42 <quicksilver> desegnis: not completely universal because it doesn't support Cont.
06:02:47 <quicksilver> no backtracking in IO :)
06:02:53 <quicksilver> more's the pity
06:02:59 <cnwdup> desegnis: I am reading the link. But I think I am way to less experienced to achieve this. O:
06:03:00 <quicksilver> if there was, I could build that time machine...
06:03:29 <nominolo_> @instances MonadCont
06:03:30 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
06:03:58 <spy-> perfect, works now:-)
06:04:02 <quicksilver> nominolo_: ContT IO exists, but the continuations are weak w.r.t the IO :)
06:04:21 <quicksilver> nominolo_: point being that effects outermost in a stack don't override the inner ones
06:04:31 <quicksilver> nominolo_: hence the difference between StateT Cont and ContT State
06:04:42 <nominolo_> yeah, there's lots of literature in scheme on those problems
06:04:58 <quicksilver> (StateT Cont can rollback the state)
06:06:43 * desegnis should have a deeper look into Cont and ContT at some point.
06:08:45 <cnwdup> I have another question. I have a bunch of settings I'd like to read and the ReaderT monad would be perfect for this. I too have a very few settings I have to change during program execution. Should I split those two types of settings an put one into ReaderT and the others into StateT and is this possible? Or do I have to use StateT for all settings?
06:09:15 <cnwdup> I mean, there must be a reason to prefer ReaderT over StateT where it's possible. Cause otherwise you could just use StateT for the same operations you do with ReaderT:
06:09:21 <cnwdup> s/:$/./
06:09:59 <hpaste>  spyros pasted "(no title)" at http://hpaste.org/5371
06:10:05 <spy-> guys how about this one?
06:10:12 <spy-> why is "=~" out of scope?
06:10:18 <desegnis> cnwdup, you use ReaderT if you want to make sure you won't accidentally use put where you don't want yourself to use put
06:10:37 <Zao> spy-: Because you haven't imported the right module?
06:10:42 <desegnis> cnwdup, so there's a good reason to consider the split you describe good style.
06:10:57 <spy-> Zao: which is...?
06:11:21 <spy-> import Text.Regex.Posix
06:11:22 <spy-> right?
06:11:31 <nominolo_> cnwdup: yes, use ReaderT ReadOnlySettings (StateT SettableSettings (....),  then 'ask' for readonly stuff and 'get' R/W stuff
06:11:57 <quicksilver> cnwdup: it's not really important, in a sense. But it's definitely good style.
06:12:08 <quicksilver> cnwdup: lets your write precise types for your functions.
06:12:12 <hpaste>  spyros pasted "(no title)" at http://hpaste.org/5372
06:12:22 <spy-> how about this...?
06:12:25 <Zao> spy-: Text.Regex.Posix.Wrap, according to the Fine Hackage Docs.
06:12:29 <quicksilver> I'm also in favour of not including the StateT part in functions which don't access the state.
06:12:37 <Zao> spy-: http://hackage.haskell.org/packages/archive/regex-posix/0.93.1/doc/html/Text-Regex-Posix.html#1
06:12:38 <lambdabot> http://tinyurl.com/39lsxe
06:12:41 <quicksilver> more precise types = better
06:12:54 <quicksilver> although in small projects especially it can feel like too much bookkeeping
06:13:07 <cnwdup> Okay. Thanks, guy. (=
06:13:17 <hpaste>  Japsu pasted "zomg this beats my C++ version in execution time" at http://hpaste.org/5373
06:14:17 <spy-> Zao: ok, got it, imported the correct package. but it cannot match ti correctly
06:14:26 <spy-> because the =~ gives a 4-tuple
06:14:36 <spy-> and i need what is before match
06:14:36 <opqdonut> heh, Japsu
06:14:41 <Japsu> heh, heh
06:14:41 <spy-> and what matches
06:16:13 <desegnis> Japsu: time for a bytestring Parsec to be Â»officiallyÂ« released so parseNick becomes one line
06:16:22 <Japsu> desegnis: hehe
06:18:38 <spy-> any1 got an idea for this: http://hpaste.org/5372 ?
06:21:05 <roconnor> ugh, formal proofs really make sure you get all the corner cases.
06:21:29 <rekso> spy-: I don't think there's any easy way to get what's before the match. It might be easier to change the regex to capture both the things you want.
06:22:44 <spy-> okay
06:22:49 <spy-> and then
06:22:53 <spy-> how do i get the matc?
06:23:22 <spy-> i get an error from the compiler
06:24:48 <spy-> rekso: i just need to understand how to get what matches, and because here i need both name and e-mail address, i'll need 2 things...
06:28:24 <nominolo_> :t rty
06:28:24 <lambdabot> Not in scope: `rty'
06:28:27 <nominolo_> :t try
06:28:27 <lambdabot> Not in scope: `try'
06:31:00 <sclv> ?hoogle try
06:31:01 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
06:31:01 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
06:31:01 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
06:34:01 * spy- kalhspera
06:34:31 <gbacon> so how do I need to modify sources.list to be able to pick up ghc-6.8.2 packages?
06:36:34 <hpaste>  (anonymous) pasted "spy-: have a look at this" at http://hpaste.org/5375
06:37:05 <spy-> thank you very mich
06:37:05 <rekso> You'll need to change the regex to match your data, probably, but it shows how you can get the captured substrings.
06:37:16 <spy-> thank you so much rekso
06:38:22 <spy-> rekso: i get errors while trying to compile the program you pasted..
06:39:30 <rekso> any chance you could say what errors?
06:40:14 <spy-> testme.o: In function `rBU_info':
06:40:14 <spy-> (.text+0xaa): undefined reference to `regexzmcompatzm0zi71_TextziRegex_mkRegex_closure'
06:40:17 <spy-> i get 4 of those
06:41:12 <BMeph> spy-: Try compiling with "--make" option.
06:41:16 <spy-> ok
06:41:17 <rekso> You need --make
06:41:52 <spy-> thanks
06:41:54 <jedbrown> gbacon: It's in sid/unstable now.
06:41:55 <spy-> and another thing:
06:42:03 <spy-> i need to get both the string that matches
06:42:11 <spy-> and the string before that
06:42:23 <spy-> that is, i need both the mail address, AND the name
06:42:32 <spy-> where is the one before match stored?
06:42:43 <rekso> It's possible to get the string before the match, but not easy AFAICT.
06:43:04 <rekso> It would be easier to write your regex so it captures the name *and* the email address, as I tried to do in my example.
06:44:24 <spy-> okay
06:44:39 <gbacon> jedbrown: what's the package name? ghc6 still shows 6.6.1
06:44:46 <spy-> but i have to generate html code for that
06:45:24 <spy-> that sais <li>name, <a href = "mailto:email">email</a></li>
06:45:28 <spy-> how can i do this?
06:46:25 <jedbrown> gbacon: did you specify the unstable repository?  As in aptitude install -t unstable ghc6 ?
06:46:51 <jedbrown> gbacon: If you don't normally track unstable.  It's not in lenny/testing yet.
06:47:09 <Zao> spy-: Since your data is semistructured HTML-ish data, maybe consider using "tagsoup"
06:47:23 <spy-> tagsoup
06:47:25 <spy-> xm.
06:47:29 <spy-> i'll search for that
06:47:33 <gbacon> jedbrown: Unable to find an archive "sid" for the package "ghc6"
06:47:43 <Zao> spy-: It's on hackage.
06:47:57 <spy-> and rekso, how can i modify the program you wrote to put the output in a file named "names.html"?
06:48:02 <spy-> Zao: thanks...
06:48:22 <jedbrown> gbacon: Is sid/unstable in your sources.list?
06:49:01 <gbacon> jedbrown: aha! no!
06:49:21 <spy-> Zao: maybe it's a bit complicated with tagsoup
06:49:30 <kib> Can someone tell me if this tutorial is deprecated : http://www.lisperati.com/haskell/ht1.html ?
06:49:47 <dejones> gbacon: ghc6 installed in debian fine for me.
06:49:55 <jedbrown> gbacon: Which branch do you track?
06:50:12 <gbacon> gutsy
06:50:37 <jedbrown> gbacon: Oh, that's not quite debian :)
06:50:48 <gbacon> jedbrown: no, Kubuntu
06:51:04 <jedbrown> maybe get it here: http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
06:51:05 <lambdabot> Title: Haskell Unsafe
06:51:23 <dejones> gbacon: http://packages.debian.org/etch/ghc6
06:51:24 <lambdabot> Title: Debian -- Details of package ghc6 in etch
06:51:37 <jedbrown> gbacon: Well, that's probably the same as in the debian unstable repo now.
06:52:06 <gbacon> dejones: I have ghc-6.6, but I'm after -6.8
06:52:14 <jedbrown> gbacon: But installing debian packages on ubuntu doesn't always work as expected, so be prepared.
06:52:30 <dejones> gbacon: there are links to the other versions of ghc6 packages in the other debian branches at the top of that page.
06:52:55 <dejones> check if they have the version you want...
06:53:06 <dejones> gbacon: http://packages.debian.org/sid/ghc6
06:53:07 <lambdabot> Title: Debian -- Details of package ghc6 in sid
06:53:21 <gbacon> dejones: got it
06:53:26 <dejones> :)
06:54:05 <jedbrown> gbacon: It's in ubuntu hardy: http://packages.ubuntu.com/hardy/devel/ghc6
06:54:06 <lambdabot> Title: Ubuntu -- ghc6
06:57:55 <dcoutts_> oh, new yi release :-)
06:58:39 <BMeph> dcoutts_: Yay, yi? ;)
06:58:42 <dylan> dear #haskell, how do I explain to someone that functional programming is not just a "geeky idea that is not good for general purpose programming"?
06:59:08 <dcoutts_> BMeph: yippie! yi!
06:59:20 <cjb> dylan: it isn't?
06:59:46 <BMeph> dylan: How do you explain that general purpose programming is generally geeky anyway? ;)
06:59:51 <dcoutts_> dylan: say that the clever people are making serious money and not telling you that they're doing so because it's their secret weapon :-)
07:00:12 <cjb> dylan: You can say things like "Right now, maybe that's true.  But there are things you can do with functional programming -- such as automatic parallelism due to purity -- that are not possible with imperative languages, and that are only going to get more important as we keep adding cores to CPUs."
07:00:26 <ac> erhg. Why isn't "put Nothing" equivalent to "put ()"?
07:00:38 <BMeph> "First you get the lambdas, then you get the money, then you get the women!" ;)
07:00:53 <cjb> I guess I have a parallelism bent at the moment.
07:01:42 <nominolo_> dcoutts_: where?
07:01:47 <scook0> BMeph: and since it's purely functional, you still have the lambdas and the money by the end of it all ;)
07:01:53 <dcoutts_> nominolo_: on hackage yi-0.3
07:01:55 <BMeph> ac: because Nothing and () are completely different types. Especially, if you're dealing with the Maybe () type. ;)
07:02:12 <nominolo_> dcoutts_: yeah, jyp first upload attempt failed
07:02:29 <ac> dylan: explain that the programmers using Haskell are also the programmers who get laid
07:02:42 <BMeph> scook0: If you know of a supply of pure money, please, pass some around! ;)
07:02:45 <nominolo_> ac: not true
07:02:50 <dylan> "If I'm going to perform a task, in code or in life, I'm going to proceed on a step-by-step basis, describing each step in order and using the results from prior steps in executing the following steps."
07:02:59 <scook0> BMeph: unsafeLaunderIO
07:03:16 <dylan> ^^ I need some cheeky way of saying "Oh, so you're in the IO monad?"
07:03:25 <BMeph> scook0: That sounds VERY "impure" to me... ;p
07:03:50 <doserj> dylan: "oh, you're stuck to assembler?"
07:03:51 <gbacon> jedbrown, dejones: thanks
07:03:59 <dejones> gbacon: np
07:04:19 <BMeph> dylan: unsafePerfomIOGreeting? ;)
07:04:58 <litb> hello all :9
07:05:01 <litb> :)
07:05:31 <pastorNC> i have a lot of evaluations being done and i want to see what the output is each step of the way
07:05:39 <jedbrown> dcoutts_: You know darcs cabal-install is broken with bytestring-0.9.0.4?
07:05:43 <ac> BMeph: so... I still think it would be logical for Nothing to encode as, well, nothing.
07:05:43 <pastorNC> what/where is my magical debugging function?
07:06:04 <nominolo_> import Debug.Trace
07:06:11 <nominolo_> or ghci :trace foo
07:06:19 <dcoutts_> jedbrown: I'm not aware of that, are you sure it's just not because you've got some progs built with an old version of bytestring?
07:06:20 <nominolo_> and then :back
07:06:49 <nominolo_> jedbrown: linker problems?
07:06:58 <dcoutts_> jedbrown: does the problem look like: http://hackage.haskell.org/trac/hackage/ticket/220
07:07:00 <lambdabot> Title: #220 (detect inconsistent package dependencies) - Hackage - Trac
07:07:23 <jedbrown> dcoutts_: That could be.  I just set version number in the .cabal, now I'm trying out cabal upgrade.
07:07:32 <BMeph> dylan: I think the easiest way of explaining FP to an IP programmer is to say that it's all that "encapsulation, modularity, and avoiding globals" stuff, just without artificially putting code and data in the same box and forcing them to behave the same way when they aren't. :)
07:08:03 <spy-> guys thank you very much for your help
07:08:10 <spy-> have a very good evening
07:08:11 <spy-> goodbye
07:08:22 <dcoutts_> jedbrown: so I bet the problem is that your zlib is built against bytestring-0.9.0.1 and then you're building cabal-install with that zlib bytestring-0.9.0.4 and you get a type error right?
07:08:37 <hpaste>  jedbrown pasted "darcs-cabal error" at http://hpaste.org/5376
07:11:11 <Saizan> jedbrown: yeah, rebuild zlib against bytestring-0.9.0.4
07:11:44 <BMeph> ac: When you bring up encoding, that suggests some serialization scheme, where an additional problem pops up: How do you tell when you've gotten all the info about some value, and aare now being told about the "next" value?
07:12:02 <Saizan> it's weird how this problems didn't show earlier.. maybe the dependecies were simpler?
07:12:09 <dcoutts_> jedbrown: yes, this is exactly the problem in ticket #220. There's not a lot we can do about it yet, you have to manually resolve the problem by rebuilding things.
07:12:27 <jedbrown> Saizan: Okay, cool.  I just built cabal-install against bytestring-0.9.0.1, so now I'm trying cabal upgrade.
07:12:35 <dcoutts_> Saizan: it's really obvious with the split base libs now that they are upgradable
07:13:00 <jedbrown> dcoutts_: No problem.  It seemed like a strange error after all.
07:13:01 <BMeph> litb: Guten Nachmittag! ;)
07:13:02 <dcoutts_> jedbrown: I have to say, I don't trust cabal upgrade at all :-) I don't think it installs things in the right order
07:13:16 <dcoutts_> jedbrown: so let me know how you get on
07:13:50 <jedbrown> dcoutts_: Yeah, it failed on the new cgi because the new regex libs weren't installed, even though they were scheduled for upgrade.
07:14:06 <litb> BMeph: Guten Morgen :p
07:14:22 <dcoutts_> jedbrown: yeah, it just finds out what's available and builds it without considering order
07:14:22 <jedbrown> dcoutts_: But even if I have to work through that manually, it is easier than otherwise.
07:14:42 <dcoutts_> jedbrown: file a bug
07:14:44 <ac> BMeph: don't understand... I'm using Data.Binary. I just want an easy way to add something to a data structure that may or may not effect the serialized ByteString
07:14:46 <CosmicRay> dcoutts: are you here?
07:14:50 <CosmicRay> ooo, you are
07:14:50 <dcoutts_> CosmicRay: hia
07:15:02 <CosmicRay> how did you get Setup.lhs from Wash to build with ghc 6.8 on gentoo?
07:15:11 <dcoutts_> CosmicRay: lemme check...
07:15:14 <CosmicRay> over here it is crashing because it can't find compilerPath
07:15:14 <BMeph> litb: :)
07:15:20 <CosmicRay> which apparently was removed from cabal
07:15:25 <ac> I bet "Either () Foo" would work
07:15:25 <CosmicRay> yet it looks like you aren't patching Setup.lhs
07:15:33 <dcoutts_> CosmicRay: I bet we just replaced it with the default Setup.hs
07:16:17 <dcoutts_> CosmicRay: yep, that's what cabal-mksetup is doing. It junks the custom Setup.hs and uses the default on.
07:16:30 <CosmicRay> dcoutts: so you're not building the wash2hs program?
07:16:34 <dcoutts_> CosmicRay: clearly the Setup.hs was not doing anything vital
07:16:52 <CosmicRay> err make that washc
07:16:58 <CosmicRay> hum, I guess we're not using that either.
07:17:05 * dcoutts_ checks
07:17:12 <BMeph> ac: Hmm, I was really just commenting on your first outburst - I haven't looked at Data.Binary at all yet.
07:17:44 * byorgey waves
07:18:16 * byorgey wonders what happened to Circle, or whatever the Haskell implementation of Arc was going to be called
07:18:48 <CosmicRay> dcoutts: thanks for the info, I appreciate it
07:18:57 <dcoutts_> CosmicRay: no, seems we're not. That Setup.hs is bogus anyway since it tries to write to /usr/bin
07:19:08 <dcoutts_> CosmicRay: so you'd have to rewrite it anways
07:19:08 <CosmicRay> hah
07:19:24 <CosmicRay> ah we may not have that problem since we build it with a different prefix
07:19:31 <CosmicRay> that is relative to the build dir
07:19:46 <CosmicRay> err, install it that way.
07:20:12 <dcoutts_> CosmicRay: really? you're supposed to set --prefix to the final location and then ./setup copy --destdir=
07:20:26 <CosmicRay> dcoutts: no, you're probably right.
07:20:29 <dcoutts_> otherwise packages will not be able to find their data files at runtime
07:20:31 <CosmicRay> but we don't build as root and it worked with ghc 6.6
07:20:36 <CosmicRay> so I don't know why then
07:20:50 <dcoutts_> sandbox?
07:21:05 <CosmicRay> eh?
07:21:10 <jedbrown> dcoutts_: After the rough start, everything upgraded nicely.
07:21:36 <jedbrown> @karma+ cabal
07:21:36 <lambdabot> cabal's karma raised to 5.
07:22:10 <dcoutts_> jedbrown: could you file a bug to note that upgrade is ignoring package dep order and when one fails it tries to install other packages that depend on the failed one.
07:22:43 <jedbrown> dcoutts_: Sure.
07:22:48 <dcoutts_> jedbrown: I've actually got some code I'm working on to fix that, so that it keeps the dep tree and uses it to work out what it can keep trying and what is a dead loss
07:23:07 <dcoutts_> but it's useful to have the real world reports of the problem
07:38:56 <jedbrown> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/226
07:38:57 <lambdabot> Title: #226 (Cabal install should upgrade in the correct order.) - Hackage - Trac
07:39:07 <dcoutts_> jedbrown: thanks
07:40:40 <jedbrown> dcoutts_: Is there documentation of what can go in .cabal/config?
07:43:02 <dcoutts_> jedbrown: only in the cabal-install source, if you want to improve that see http://hackage.haskell.org/trac/hackage/ticket/223
07:43:03 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
07:43:35 <dcoutts_> which is about imporiving the config file system, eg we should put all fields in but unused ones should be -- commented out
07:43:49 <dcoutts_> then it'd be totally obvious
07:44:05 <jedbrown> dcoutts_: Yeah, that would be great.
07:44:52 <dcoutts_> and config file and configure flags should be broken into categories
07:44:58 <dcoutts_> there are so many of them now
07:45:03 * shepheb reads Project Euler #67 and is stumped. That's going to distract me all day now. No spoilers!
07:45:40 <dcoutts_> Jedai: it'd need improvements to the Command api and something similar for managing reading/writing the info to files
07:45:44 <dcoutts_> opps
07:45:46 * mux pets his euler67.hs file
07:45:48 <byorgey> shepheb: oh, is that the really easy one where you just have to use the Pythagorean Theorem to... oops!
07:45:50 <dcoutts_> jedbrown: not Jedai
07:45:55 <byorgey> ;)
07:46:40 <jedbrown> I noticed that the number of options tripled after upgrading to the darcs version.
07:46:53 <BMeph> Heh-heh, #67 is the only one in the 60's that I've done - not even #69! ;)
07:46:55 <nominolo_> heh
07:48:02 <shapr`> cjb: Do you have the list of addresses for the CHUG?
07:49:08 <dcoutts_> jedbrown: yes, it now has all the same options that runghc Setup.hs configure has
07:50:04 * BMeph starts to look at PE #69
07:50:07 <shapr`> cjb: Gregory Price wants to join, thought I'd either get the list from you or delegate list admin to you, one or the other.
07:53:05 <shepheb> I'm being very linear-minded about it, trying to solve them in numerical order. I've solved <= 66.
07:53:58 <dylan> shapr`: Where do you live these days?
07:54:09 <vincenz> dons:
07:54:18 <vincenz> jdh "I was referring to monads that wrap functionality unsafely. They are used to address performance problems. There are similar things in other functional languages but they are much less commonly used/needed."
07:57:07 <Saizan> vincenz: does it give an example?
07:57:34 <Saizan> hem "he"
07:59:05 <vincenz> Saizan: no
07:59:14 <vincenz> that was in response to my comment on whether he just made terms up
07:59:16 <vincenz> like "unsafe monads"
07:59:30 <vincenz> vincenz: "Could you define 'unsafe monads' or do you just throw terms around at random?"
07:59:40 <vincenz> jdh30: I was referring to monads that wrap functionality unsafely. They are used to address performance problems. There are similar things in other functional languages but they are much less commonly used/needed."
07:59:45 <byorgey> dcoutts_: I'm trying to do 'runhaskell Setup haddock' on a package, and I've got haddock 2.0 and the latest darcs cabal.  It fails with 'unrecognized options --package=foo'.
07:59:46 <vincenz> I think sarcasm is in order
07:59:53 <byorgey> dcoutts_: is this a known problem?  should I log a ticket?
08:00:04 <byorgey> dcoutts_: I'm assuming this is a cabal issue although I'm not 100% sure.
08:00:36 <dylan> @ask shapr` I would to see if we can't get south-eastern haskellers to meet at Dragon*Con this year... What say you?
08:00:36 <lambdabot> Consider it noted.
08:00:41 <dcoutts_> byorgey: ask waern. He does haddock 2.0 and did the support in Cabal for it.
08:00:45 <dcoutts_> @seen waern
08:00:45 <lambdabot> I saw waern leaving #haskell and #ghc 1d 14h 52m 39s ago, and .
08:01:00 <byorgey> dcoutts_: ok, thanks.
08:02:46 <byorgey> @ask waern with haddock 2.0 and the latest darcs cabal, trying to do 'runhaskell Setup haddock' on the xmonad-contrib package (darcs) yields "haddock: unrecognized option `--package=xmonad-contrib-0.6'".  Is this a known problem?  Is the problem with Cabal or darcs?  etc...
08:02:46 <lambdabot> Consider it noted.
08:13:20 <litb> hm, what was that nice statement about haskell programming again?
08:13:34 <litb> @haskell true
08:13:34 <lambdabot> Unknown command, try @list
08:13:36 <litb> or thelike
08:14:26 <byorgey> @faq
08:14:26 <lambdabot> The answer is: Yes! Haskell can do that.
08:14:33 <byorgey> litb: you mean that one? =)
08:14:39 <litb> no there was another one
08:14:51 <litb> like "you think and if you write it down, it is beautiful" or thelike
08:15:05 <byorgey> hm, I'm not familiar with that one.  sounds nice, though.
08:15:27 <litb> @true haskell
08:15:27 <lambdabot> Maybe you meant: free run time type
08:15:53 <byorgey> free run time types?  that doesn't sound very haskellish...
08:16:03 <litb> yeah, was the wrong one
08:16:06 <Saizan> byorgey: have run ./Setup clean after installing 2.0?
08:16:29 <byorgey> Saizan: ah, no, good suggestion.  let me go try that.
08:17:51 <Saizan> byorgey: cabal caches the version in .setup-config, so it continues to use the old flags
08:18:00 <byorgey> Saizan: ah, I see
08:18:57 <byorgey> yup, that was the problem
08:19:00 <byorgey> Saizan++
08:19:23 <byorgey> @tell waern never mind, the problem was just me forgetting to do a clean after upgrading haddock!
08:19:23 <lambdabot> Consider it noted.
08:20:06 <Saizan> however it's not obvious that you need to clean, i think it should be written somewhere..
08:21:12 <shapr`> dylan: I'm in Boston!
08:21:12 <lambdabot> shapr`: You have 1 new message. '/msg lambdabot @messages' to read it.
08:21:32 <byorgey> Saizan: well, agreed, but it's not something that happens very often.  It's not clear where it should be written so that people would see it when it counted.
08:21:44 <RayNbow> hmm... this is the first time I got the following error: Couldn't match expected type `a' against inferred type `a1'
08:21:52 <shapr`> dylan: I'm in Boston for 3+ years in my estimate, so I'm no longer a southeastern Haskeller.
08:21:57 <dylan> shapr`: hrm, that's a bit farther north.
08:22:06 <byorgey> Saizan: maybe part of the solution is better error messages...?
08:22:13 <dylan> I still want to have lambdas vs. dragons, darnit.
08:22:37 <shapr`> On the good side, I got to go to a Hacking in Haskell talk at MIT, and I met a bunch of OLPC XO guys, and I got to visit their office! I have lots of cool cameraphone pix from the OLPC office.
08:23:01 <shapr`> I also met the guy responsible for the xkcd store and website.
08:23:29 <shapr`> And I met some of the #twisted guys the previous week.
08:23:57 <shapr`> We're starting a Cambridge Haskell User Group, w00! Hopefully we'll get enough people to make it interesting.
08:24:20 <dcoutts> byorgey: so the problem is that the 'haddock' program changed between configure and build. That's not easy to detect unless we take the binaries timestamp and require a reconfigure if they change.
08:25:04 <dcoutts> byorgey: though in a dependency framework we could and perhaps should do exactly that.
08:25:35 <dcoutts> it'd be especially relevant for any programs generated and used by the package / build system itself
08:25:54 <byorgey> dcoutts: it seems like a logical thing to check for.  but I understand it might be difficult =)
08:25:57 <shapr`> Would that mean that cabal packages that depend on a rebuilt package would also be rebuilt?
08:26:08 <ac> how about a function to remove leading and trailing white space?
08:26:25 <dcoutts> shapr`: yes, but also tools, not just libs
08:26:26 <radix> hi shapr`
08:26:50 <dcoutts> ac: reverse . dropWhile isSpace . reverse . dropWhile isSpace
08:26:51 <shapr`> hiya radix!
08:26:57 <ac> dcoutts: nice :)
08:27:14 <byorgey> f . f where f = reverse . dropWhile isSpace
08:27:42 <Saizan> join (.) $ reverse . dropWhile isSpace -- :)
08:27:45 <shapr`> radix: coming to part 2 of Hacking in Haskell tonight?
08:27:46 <dcoutts> twice (reverse . dropWhile isSpace) where twice f = f . f
08:27:53 <Fnugh> hi everybody
08:28:00 <byorgey> hi Fnugh!
08:28:20 <shapr`> hi Fnugh!
08:28:21 <byorgey> Saizan: heh, it's so easy to abuse join... =)
08:28:31 <ac> > (join (.) $ reverse . dropWhile isSpace) "  a test  "
08:28:32 <lambdabot>  "a test"
08:29:03 <Fnugh> This is a hell of a channel! I'm not used to channels with more than 20 people online at the same time :)
08:29:09 <byorgey> @users
08:29:10 <EvilTerran> ?users
08:29:10 <lambdabot> Maximum users seen in #haskell: 463, currently: 421 (90.9%), active: 18 (4.3%)
08:29:10 <lambdabot> Maximum users seen in #haskell: 463, currently: 421 (90.9%), active: 19 (4.5%)
08:29:11 <Saizan> byorgey: when types match :)
08:29:13 <radix> shapr`: probably not, I have classwork to do and I'm leaving this weekend for portland
08:29:13 <byorgey> whee!
08:29:17 <shapr`> radix: awww
08:29:18 <EvilTerran> ?quote fugue
08:29:19 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
08:29:39 <shapr`> Fnugh: Are you new to Haskell the language?
08:29:55 <byorgey> shapr`: CHUG sounds like fun!
08:30:01 <shapr`> byorgey: I hope so!
08:30:39 <Fnugh> Shapr, yes, quitey new in fact.
08:31:01 <shapr`> Fnugh: Just today?
08:31:15 <byorgey> Fnugh: welcome!  is there any way we may make your Haskell experience more excellent today? =)
08:31:30 * BMeph discreetly nudges a box full of fluffy lambdas towards shapr`
08:31:40 * shapr` throws fluffy lambdas
08:32:04 <radix> shapr`: But I am looking forward to the first CHUG meeting
08:32:35 <Fnugh> Nah, not just today, in a way I've 'researching' about Haskell for the past week, I even managed to successfully compile a few programs.
08:32:44 <byorgey> radix: whatcha going to Portland for?  (I'm going there in a couple weeks myself)
08:32:55 <shapr`> Fnugh: If you're in Boston you can come to "Hacking in Haskell" tonight at MIT.
08:32:57 <Fnugh> byorgey, why thank you, actually yes, there is )
08:32:57 <radix> byorgey: A sprint with my development team
08:33:17 <radix> byorgey: I work for Canonical on Landscape
08:33:25 <Fnugh> shapr, that was close, I'm in B........ulgaria :)
08:33:33 <byorgey> radix: ah, cool.  sorry, what's Landscape?
08:33:49 <radix> byorgey: A service for managing deployments of Ubuntu machines.
08:33:58 <byorgey> radix: oh, nice.
08:34:01 <nburlett> wow, neat social diagram
08:34:10 * byorgey is a happy Ubuntu user =)
08:34:21 <radix> byorgey: good to hear. :-)
08:34:43 <davidL> shapr`: how many people generally attend?
08:34:44 <Nafai> byorgey: Just don't complain to him about Ubuntu problems.  He'll say "NOTDT"
08:34:46 <shapr`> Fnugh: Ok, not so close..
08:34:55 <radix> Nafai: :-)
08:34:59 <shapr`> davidL: Attend the CHUG? We haven't had one yet.
08:35:08 <byorgey> Fnugh: great, what's that?
08:35:10 <Fnugh> Yeah, thanks for the invite!
08:35:16 <shapr`> davidL: But I'm guessing it'll start small and grow steadily.
08:35:56 <byorgey> @vera NOTDT
08:35:56 <lambdabot> No match for "NOTDT".
08:36:03 <Fnugh> byorgey, I beg you pardon?
08:36:10 <desegnis> Hmm, so ghc-unstable has moved (>>>) from Arrow to Control.Category. Does that mean that we need #ifdef mess for any program that uses the Arrow class?
08:36:16 <Nafai> byorgey: "Not on the distro team" :)
08:36:36 <byorgey> Fnugh: you said there is something we can do to make your Haskell experience more excellent, I was asking what it is.
08:36:42 <byorgey> Nafai: ah. =)
08:37:07 <resiak> desegnis: you could just import all of both modules ? :-)
08:37:09 <davidL> There needs to be a Chicago Haskell User Group.
08:37:15 <nburlett> anyone know why I can't update my haskell overlay on gentoo?
08:37:29 <ac> There needs to be a Seattle Haskell user group
08:37:48 <shapr`> ac: I think there's a Portland group.
08:37:50 <nburlett> Or a Santa Barbara Haskell User Group
08:37:59 <shapr`> You guys could all start these groups :-)
08:38:00 <radix> ac: I suggest calling it the Seattle Haskell Appreciator's Group
08:38:00 <Fnugh> ah, yes, well, basically I'm trying to figure out how to get the sum of squares, I was thinking about something in the lines of 'sum (squares [1..n])'
08:38:00 <desegnis> resiak: The motivation for my program is the TypeCompose package not compiling with ghc 6.9 because it defines an instance for for Arrow that mentions (>>>)
08:38:20 <byorgey> shapr`: heh, there's definitely a Portland group, it's called 'Galois and PSU' =)
08:38:21 <RayNbow> hmm, is there a nice way to go from [Gen a] to Gen [a]?
08:38:27 <nburlett> sum.squares $ [1..n]
08:38:37 <byorgey> RayNbow: sequence
08:38:43 <byorgey> @type sequence
08:38:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:38:57 <shapr`> ac: I think that's an excellent name.
08:39:14 <desegnis> resiak: Now (>>>) Â»is not a (visible) method of class ArrowÂ«
08:39:21 <ac> > sum $ map (^2) [1..5]
08:39:21 <lambdabot>  55
08:39:27 <nburlett> > let squares = map (\x -> x*x) in sum . squares $ [1..5]
08:39:28 <lambdabot>  55
08:39:56 <byorgey> Fnugh: yes, the key is implementing 'squares' as a map over the list
08:40:01 <pejo> byorgey, both Galois and PSU might seem scary for the non-academics.
08:40:01 <nburlett> @pl sq n = sum $ map (^2) [1..n]
08:40:01 <lambdabot> sq = sum . map (^ 2) . enumFromTo 1
08:40:01 <ac> Hmm. Maybe I should start SHAG
08:40:17 <BMeph> > divMod' 10.4 3.5
08:40:18 <lambdabot>  (2,3.4000000000000004)
08:40:33 <byorgey> > let squares = map (^2); sumsq n = sum (squares [1..n])  in sumsq 5
08:40:33 <lambdabot>  55
08:40:43 <BMeph> (A little late, but for all you ocaml-jockeys out there... ;)
08:40:48 <RayNbow> byorgey: ah thx
08:40:49 <byorgey> pejo: well, perhaps =)
08:41:00 <davidL> :t divMod'
08:41:00 <lambdabot> forall a b. (Integral b, Real a) => a -> a -> (b, a)
08:41:14 <pejo> byorgey, reading some paper on deforestation?
08:41:19 <BMeph> ac: Gonna SHAG now, or SHAG later? ;)
08:41:39 <ac> BMeph: SHAG ASAP
08:41:40 <byorgey> pejo: hm?
08:41:45 <BMeph> davidL: I found it while poking through the Data.Fixed module.
08:41:52 <RayNbow> byorgey: I feel pretty stupid though, I've read about sequence before (but apparently I only associated it with the list monad :p)
08:42:11 <byorgey> RayNbow: don't feel stupid, it's called "learning" =)
08:42:30 <shag> who highlights my nick? :)
08:42:33 <byorgey> RayNbow: no one remembers everything they've ever read after only one time
08:42:41 <davidL> BMeph: ah, neat
08:42:44 <ac> shag: where did you come from?
08:42:50 <pejo> byorgey, (sum of squares, I think Wadler uses that one as example of intermediate lists).
08:43:03 <shag> ac: what do you mean?
08:43:45 <byorgey> pejo: oh! perhaps.  So does the paper on stream fusion.  but I was talking about that since Fnugh asked about it.
08:44:17 * shapr` tries to use MbUnit to fake QuickChecking in C#
08:44:50 <byorgey> Fnugh: is all of the above helpful?  the only problem with asking questions in #haskell is usually you get your question answered but end up with three more ;)
08:44:51 <davidL> > showFixed False Pico
08:44:51 <lambdabot>   Not in scope: data constructor `Pico'
08:45:15 <mux> byorgey: or you get an answer such that you don't understand your own question anymore :-)
08:45:38 <byorgey> mux: yes, that happens too =)
08:46:11 <Fnugh> hey guys, many thanks for the responses, I tried a few and the one that gives me least amount errors when I try to compile is what nburlett suggested, in essence this is the idea: http://hpaste.org/5377#a1
08:46:49 <nburlett> Fnugh: you need to convert it to an integer
08:47:05 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5377#a2
08:47:14 <ac> :t readLn
08:47:14 <lambdabot> forall a. (Read a) => IO a
08:47:27 <nburlett> oh, hm
08:47:56 <byorgey> no, the problem is that the else branch has to have the same type as the then branch
08:48:48 <hpaste>  byorgey annotated "(no title)" with "use print" at http://hpaste.org/5377#a3
08:48:54 <ac> Fnugh: don't you need to define "squares"?
08:49:09 <resiak> desegnis: ah, my bad
08:49:42 <desegnis> resiak: s/program/question, even
08:49:42 <nburlett> yes, that too :->
08:49:56 <byorgey> Fnugh: also, note that to play around with things like this, you do not need to write a little program that does I/O like this
08:50:01 <ac> > putStrLn $ sum . (^2) $ [1..5]
08:50:02 <lambdabot>   add an instance declaration for (Num String)
08:50:02 <lambdabot>     In the expression: 5
08:50:14 <byorgey> Fnugh: you can just write some functions that compute things, then play around with them interactively in ghci
08:50:19 <dancor> how do i tell parsec it has to consume all input or it's an error
08:50:35 <ac> > putStrLn $ show $ sum . (^2) $ [1..5]
08:50:35 <lambdabot>   add an instance declaration for (Num [a])
08:50:41 <resiak> dancor: use 'eof'
08:50:45 <dancor> tx
08:51:07 <byorgey> ac: needs a 'map'
08:51:23 <jedbrown> ac: print = putStrLn . show
08:51:32 <ac> bleh
08:52:00 <ac> > print $ sum $ map (^2) [1..5]
08:52:01 <lambdabot>  <IO ()>
08:52:08 <ac> yay
08:53:04 <Fnugh> byorgey, what I'm trying to do is actually have a program that does that sort of I/O.
08:53:08 <dancor> (print . sum . (map (^2))) ([1..5] :: [Int])
08:53:11 <dancor> > (print . sum . (map (^2))) ([1..5] :: [Int])
08:53:12 <lambdabot>  <IO ()>
08:53:20 <byorgey> Fnugh: ok, well, that's fine then =)
08:53:20 <dancor> > (sum . (map (^2))) ([1..5] :: [Int])
08:53:21 <lambdabot>  55
08:53:45 <dancor> > (sum . (map (^2))) [1..5 :: Int]
08:53:46 <lambdabot>  55
08:53:48 <dancor> nice
08:53:52 <Fnugh> ac, as for defining it, is that why I'm getting  Not in scope: `squares'
08:53:52 <Fnugh> ?
08:54:10 <ac> Fnugh: yep. Use a let, or define it above, or use map (^2)
08:54:36 * dancor was always deeply dissatisfied by the need for let in ghci
08:55:11 * ac will be happy when you can paste source in to ghci
08:55:35 <moonlite> is it possible to tell ghci to never use more than a set amount of memory? (so that when you type in something that will consume all available system memory it won't)
08:55:40 <mux> I'd be very happy to just be able to define datatypes in ghci
08:56:28 * dancor is with ac
08:57:18 <nburlett> since when is lambdabot allowed to run things in IO () ?
08:57:27 <mux> nburlett: it isn't
08:57:47 <dancor> > [1 :: Int .. 5]
08:57:48 <lambdabot>  [1,2,3,4,5]
08:58:03 <phlpp> > [1 :: Int .. 5.0]
08:58:03 <lambdabot>   add an instance declaration for (Fractional Int)
08:58:04 <lambdabot>     In the expression: 5.0...
08:59:15 <nburlett> mux: what about the print . sum . (map (^2))) ([1..5] :: [Int]) above?
08:59:16 <litb> is there aopenGL lib for haskell?
08:59:34 <dons> litb: yeah, HOpenGL
08:59:34 <litb> errm, openGL is what i mean
08:59:40 <dons> its rather good, it seems.
08:59:44 <dancor> litb: i've seen some things on http://hackage.haskell.org/packages/archive/pkg-list.html
08:59:45 <dons> > getChar
08:59:45 <lambdabot>  <IO Char>
08:59:49 <mux> nburlett: LB only showed <IO ()>, that is the type of the action, but it didn't run it
09:00:08 <dons> it doesn't run them. it intercepts them, and prints the type instead :)
09:00:14 <nburlett> ahh, that makes more sense
09:00:17 <dons> > [getChar, getChar]
09:00:18 <lambdabot>  [<IO Char>,<IO Char>]
09:00:20 <nburlett> did it used to do that?
09:00:29 <dons> for the last couple of years
09:00:32 <EvilTerran> nburlett, yes; security reasons
09:00:55 <nburlett> EvilTerran: yeah, I get the security concern.. I just thought lambdabot said no when you tried to do it
09:01:50 <EvilTerran> altho it'd make sense if the bot collected and reported what would be written to stdout, imo
09:02:22 <ac> litb: I have some code for building textures, if you're interested
09:02:31 <byorgey> EvilTerran: how could you just collect what's written to stdout without allowing other IO actions?
09:02:59 <EvilTerran> hide those functions as you import?
09:03:36 <EvilTerran> actually, no, that wouldn't work, 'cos it doesn't run anything... never mind, it was just a thought.
09:04:03 <jedbrown> EvilTerran: replace the IO out functions with ones that run in Reader?
09:04:18 <byorgey> EvilTerran: it's an interesting thought, but sounds difficult to do right
09:04:23 <byorgey> jedbrown: you mean Writer?
09:04:29 <jedbrown> byorgey: Yes.
09:04:39 <byorgey> yes, that's an interesting idea.
09:04:40 <EvilTerran> using Writer for output would work, but you'd still need osme way of dealing with other IO actions
09:05:25 <jedbrown> EvilTerran: Do the same as we do now.  What else would you want?
09:05:30 <dcoutts> byorgey: could use swiert's FakeIO lib instead of the normal real IO
09:05:43 <EvilTerran> jedbrown, er, what?
09:05:49 <byorgey> dcoutts: oh, interesting, I didn't know about FakeIO
09:06:01 <byorgey> @go haskell FakeIO
09:06:02 <lambdabot> http://ola-bini.blogspot.com/2008/01/ruby-antipattern-using-eval-without.html
09:06:02 <lambdabot> Title: Ola Bini on Java, Lisp, Ruby and AI: Ruby antipattern: Using eval without positi ...
09:06:04 <dcoutts> byorgey: or perhaps it was called IOSpec I don't remember
09:06:29 <jedbrown> EvilTerran: What would you want to do with other IO actions?  (I didn't know FakeIO existed, but it sounds like what I mean.)
09:06:31 <byorgey> ah, IOSpec it is
09:07:01 <EvilTerran> jedbrown, oh, right; yes, i guess doing what we do now would work, yes. that's indeed what i was thinking.
09:07:08 <byorgey> hm, sequence.complete.org gives a database error
09:07:12 <EvilTerran> the problem, then, is telling when to do which
09:07:33 <byorgey> that's CosmicRay's server, right?
09:12:48 <shag> @pl (\d1 d2 -> deflate $ unionOccurrences (inflate d1) (inflate d2))
09:12:48 <lambdabot> (deflate .) . (. inflate) . unionOccurrences . inflate
09:13:17 <Toxaris> EvilTerran: let's assume a typeclass for the "irc safe" part of IO like IRCIO. If an expression has type (IRCIO m => m a), execute it (binding m to IO). if it has type IO, don't execute it, because it contains non-safe IO actions.
09:14:04 <EvilTerran> mmm
09:14:14 <CosmicRay> byorgey: not anymore
09:14:20 <CosmicRay> byorgey: it's hosted at pdx.edu now
09:14:28 <CosmicRay> I will write them
09:14:32 <byorgey> CosmicRay: oh, ok
09:14:32 <CosmicRay> (Bart Massey and his folks)
09:17:26 <Toxaris> EvilTerran: better, split IO into a lot typeclasses MonadPrint, MonadRead, MonadFileAccess, MonadNetwork, ... and have the concrete type IO instantiate all of them, but the newtype wrapper IRCIO only instantiate the "irc safe" ones. this way, type inference would tell us something about wich parts of IO we use...
09:17:37 <Fnugh> OMG, IT'S WORKING!1 (yes, i'm slow)
09:17:50 <Fnugh> Gosh, thanks for all the help guys!! :D :D
09:17:58 <EvilTerran> Toxaris, indeed. i've been fiddling with such a thing myself
09:18:25 <Toxaris> EvilTerran: and we could have fun stuff like   newtype PrintOverWriter   wich converts MonadWriter into MonadPrint
09:18:25 <byorgey> Fnugh: =D
09:18:41 <EvilTerran> Toxaris, and this, with rank2types, would allow easily restricted passing around of restricted IO actions
09:18:58 <Toxaris> EvilTerran: consider quickcheckable IO actions
09:19:01 <EvilTerran> foo :: (forall m. MonadStdOut m, MonadIORefs m => m ()) -> ...
09:19:03 <byorgey> Toxaris: yes, I've thought of splitting up IO in such a way before.  I think it would be great.
09:19:17 <Toxaris> consider ListT working over some parts of IO
09:19:22 <Fnugh> ok, I'm going to take shower now and then head off to the pub :)
09:19:34 <byorgey> Fnugh: ok, have fun =)
09:20:17 <Toxaris> byorgey, EvilTerran: so if this is a nice idea, why isn't it implemented yet? should be possible as a drop-in replacement for Prelude, shouldn't it?
09:20:49 <EvilTerran> the problem, i think, is deciding how to chunk up the IO functionality
09:20:52 <Fnugh> Thanks, you too and take care!
09:21:15 <EvilTerran> also, you can't have a heirarchy of classes without either newtype hell or -XUndecidableInstances
09:21:39 <litb> ac: oh yeah
09:21:53 <litb> is it below the limit of hpaste.org ?
09:22:00 <litb> i'm very interested :)
09:23:06 <Toxaris> EvilTerran: "newtype hell" :)
09:24:01 <Toxaris> EvilTerran: why do you need a hierarchy of classes? to allow smaller and bigger "chunks" of IO at the same time?
09:24:14 <EvilTerran> well, terseness
09:24:53 <twanvl> this is another one of those things that needs class aliases
09:25:01 <EvilTerran> (MonadStdIn m, MonadStdOut m, MonadHandleIn m, MonadHandleOut m) => MonadAllInOut m or something
09:30:16 <Toxaris> EvilTerran: I see. but other libs (consider mtl) tend to ignore this problem and people live with it. for some use cases it just doesn't matter (like using the same MyRestrictedIO newtype in a whole project), for others, there's type inference :)
09:30:37 <EvilTerran> yeah
09:34:06 <Toxaris> EvilTerran: well, it's supper time so I'll be away for some time :) but i like this idea, because i'm interested in library design, but not so much in library implementation. and this is a kind of design-only job, since IO is already there :)
09:34:24 <EvilTerran> hehe, ok
09:34:42 <dcoutts> byorgey, EvilTerran: if you could make lambdabot's eval run in linux's seccomp mode then it could use IO, so long as that was only reading and writing to stdin/out/err
09:37:01 <RayNbow> anyone interested in (gently? :p) criticising my code?
09:37:08 <dcoutts> though working in seccomp mode seems hard, if you use any syscall other than read,write,exit then the process gets killed
09:37:19 <dcoutts> not even select it'd seem
09:38:11 <Mr_Awesome> RayNbow: sure, post it
09:39:36 <EvilTerran> dcoutts, altho that would add an extra layer of security, i think a "fake" IO monad would probably be easier and more flexible
09:40:12 <hpaste>  RayNbow pasted "Simple Genetic Algorithm framework" at http://hpaste.org/5379
09:40:32 <RayNbow> crap
09:40:37 * RayNbow made a typo in the comments :p
09:41:23 <RayNbow> ("bare" should be "bear", sigh... :p)
09:42:51 <shepheb> "bare with me" has to be a contender for the most suggestive typo
09:43:11 <EvilTerran> i'm guessing you don't read bash.org, then
09:43:45 <RayNbow> bash.org can be used as a typopedia
09:44:45 <Mr_Awesome> looks pretty good to me
09:44:53 <Mr_Awesome> it works, right?
09:45:04 <RayNbow> it compiles? :p
09:45:31 <Mr_Awesome> oh, you havent tested it yet?
09:45:46 <RayNbow> I have no concrete selection, mutation, termination, etc. functions
09:46:02 <RayNbow> I still have to write those :p
09:50:54 <Mr_Awesome> RayNbow: right. but what you have so far looks solid to me
09:51:30 <dancor> does parsec have something like intercalate built in
09:51:48 <ddarius> You mean the opposite of that?
09:51:52 <dancor> yes..
09:52:02 <twanvl> sepBy
09:52:07 <dancor> tx
09:52:20 <RayNbow> Mr_Awesome: I might need to do some renaming though
09:52:57 <RayNbow> performGA doesn't do much in reality... (not until you feed it to Test.QuickCheck.generate)
09:55:23 <byorgey> is a.d.clark@ed.ac.uk here?
09:56:29 <byorgey> whoever it is, I want to give them a ++ for adding some documentation on rebinding keys in Yi =)
09:59:06 <resiak> @ty withArray0
09:59:07 <lambdabot> Not in scope: `withArray0'
09:59:18 <resiak> @ty Foreign.Marshall.Array.withArray0
09:59:18 <lambdabot> Couldn't find qualified module.
09:59:50 <faxathisia> :t flip
09:59:50 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:00:20 * resiak answers his own question
10:10:28 <dancor> how can i distinguish in parsec between strings that are not recognised vs and strings that are not even prefixes of some recognized string
10:10:52 <dancor> i can do this with try and eof but i'm not sure how to do it and preserve error messages
10:11:21 <dancor> one way is to hackily look for "unexpected end of input" in the error message
10:12:23 <dancor> if there is some way to grab the error message after some 'try' does 'fail' that would work..
10:12:38 <EvilTerran> I believe there is...
10:14:56 <EvilTerran> hm. seems not.
10:14:58 <dons> ?users
10:14:58 <lambdabot> Maximum users seen in #haskell: 463, currently: 424 (91.6%), active: 18 (4.2%)
10:15:11 <dancor> hm.  maybe inspecting the error isn't _so_ terrible
10:15:29 <EvilTerran> dancor, maybe devise your parser so one of those classes of errors is treated by parsec as a successful parse?
10:16:19 <dancor> EvilTerran: yeah i'm just not sure how to be successful and return the detailed information the error gives
10:16:43 <EvilTerran> hmm
10:18:28 <spy-> good evening again guys
10:18:36 <spy-> could some1 tell me what does the "!!" do in Haskell?
10:19:05 <benny99> @t !!
10:19:05 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:19:06 <dons> it indexes a list
10:19:10 <dons> ?hoogle (!!)
10:19:11 <lambdabot> Did you mean: (!!)
10:19:11 <lambdabot> Prelude.undefined :: a
10:19:11 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
10:19:13 <dons> ?hoogle !!
10:19:14 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
10:19:14 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
10:19:18 <dons> > "haskell" !! 3
10:19:19 <lambdabot>  'k'
10:19:31 <spy-> thanks dons
10:19:34 <dons> its not often used, since lists are typically not treated as random access structures
10:19:37 <dons> but it does exist :)
10:19:55 <spy-> thank you guys
10:20:47 <benny99> wow, somebody using texlive and pstricks ?
10:22:34 * dcoutts notes that Sun donated a $4,200 server to kde.org and we should try and do the same
10:22:43 <dcoutts> http://dot.kde.org/1201744216/
10:22:43 <lambdabot> Title: Sun and Frontline Support KDE with Donation of Server
10:23:22 <dons> http://reddit.com/r/programming/info/6799v/comments/ "Yi 0.3 released! Your favourite purely functional text editor (article.gmane.org)"
10:23:26 <dons> dcoutts: oh, awesome.
10:23:46 <dons> dcoutts: we could get SPJ and SimonM on board.. and RL.
10:23:52 <dcoutts> dons: aye, I'm waiting for the chap to get back to me
10:24:00 <dons> or your oxford associates.
10:24:04 <dons> with impressive titles
10:24:14 <dcoutts> dons: I was angling for one of their multi-core Sparc boxes
10:24:29 <dons> yep. sounds good.
10:24:31 <cjb> Sun do seem to be pretty fast and loose with the free servers.  Often they mandate that you run OpenSolaris on them, though.
10:24:36 * BMeph thinks that kde.org doesn't need another server...
10:24:37 <dons> get a dedicated ghc build machine
10:25:09 <dcoutts> dons: for haskell.org community machine, and to do a SoC(?) project to get ghc's sparc ncg working again
10:25:15 <pejo> cjb, not just any Solaris, but *open*?
10:25:24 <cjb> one of my coworkers got given a 32-way/16G RAM Niagara server, because he wrote a book about Linux servers or something.
10:25:42 <cjb> pejo: well, normal Solaris is probably fine if you want to pay for that.
10:25:42 <dcoutts> dons: and then yes, to use it as a community box for hosting and builds
10:26:09 <dcoutts> and it can do virtualiseaion, Solaris and/or Linux
10:26:22 <cjb> that sounds like you'd spent a lot of time fighting with the sparc tools instead of getting builds done.  :)
10:26:23 <pejo> cjb, oh right, they charge for the OS if you have more than k CPU's, where k is something like 8 or 16?
10:26:38 <cjb> pejo: I have no idea, actually.
10:26:59 <cjb> I know that Sun donated several servers to the Xorg folks
10:27:04 <dcoutts> cjb: I'm sitting here in front of a Sparc Linux desktop, tool chain seems to work fine :-)
10:27:09 <cjb> and they aren't being used, because Sun wants Solaris to be run on them
10:27:20 <cjb> and anyone who might admin the servers is all "Solaris?  Eww, no thanks."
10:27:26 <dcoutts> we could happily run both Solaris and Linux imho
10:27:28 <cjb> dcoutts: Ah, fair enough.  :)
10:27:47 <cjb> dcoutts: Assuming Sun would be okay with that.  They weren't in the case of Xorg.
10:27:51 <cjb> anyway.  speculation.
10:29:59 <cjb> is there some kind of Haskell Foundation that could collect some money to run a server with?  That's what most groups of this size (gnome, kde, xorg) do.
10:30:26 <cjb> the money would probably be quickly donated by companies who have a financial interest in good Haskell tools.  Servers are cheap.
10:31:00 <cjb> (more fitting comparisons:  perl, python)
10:31:29 <dons> cjb: yes, Haskell.org
10:31:52 <dons> which is supported by galois, helps set up the SoC server (code.haskell.org), and organise hackathons.
10:31:57 <litb> hello
10:31:58 <dons> its an ad hoc collective
10:32:01 <litb> Haskell-Craft-Functional-Programming
10:32:02 <dons> hey litb. welcome back
10:32:03 <litb> is that a good book?
10:32:09 <dons> its a good one.
10:32:11 <dons> i learnt from it :)
10:32:15 <dons> many moons ago now.
10:32:28 <cjb> cool.  Has anyone tried posting to one of the lists saying "Hi, we at Haskell.org could use a new server to run code.h.o and GHC builds on, would anyone be interested in donating a server or money in exchange for some low-key advertising?"
10:32:36 <dcoutts> litb: yes, though I'd recommend "Programming in Haskell" if you have the choice between the too.
10:32:59 <cjb> dons: Perhaps all you have to do is ask Galois if they might sponsor a(nother) server?
10:33:00 <dons> cjb, we're doing that for the hackathons. but otherwise, not much has been done in this regard.
10:33:01 <dcoutts> cjb: I've emailed a chap at Sun, he was positive and is putting me in touch with someone else
10:33:12 <cjb> dcoutts: Oh, that's good.
10:33:32 <dcoutts> it's not actually clear yet that we need another build machine
10:33:36 <litb> i know that dons has "Craft of Functional Programming"
10:33:51 <dcoutts> since we could do more distributed builds, rather than relying on a central build server
10:34:30 <dcoutts> I'm more interested in the Sparc aspect of getting a sun server, to demo more cool multi-core ghc goodness
10:34:56 <dcoutts> if we just wanted a server we'd ask for a ordinary amd64 one
10:34:57 <cjb> Yes, this 32-way we have at work would be great for testing parallelism.
10:35:03 <cjb> although Niagara cores are individually very slow.
10:35:38 <litb> dcoutts: the one by Graham?
10:36:01 <dcoutts> litb: yes, I wrote a review of it for The Monad.Reader if you want to see more detail
10:36:44 <hpaste>  wli pasted "beginnings of a Fourier-Motzkin solver" at http://hpaste.org/5381
10:37:10 <dcoutts> cjb: yes, so it requires parallelism to get good performance, so fine for web serving and builds and demoing scalability
10:37:16 <litb> dcoutts: ah, it has a chapter "Monad.Reader" and you commented on it?
10:37:20 <litb> yeah, i'm interested
10:37:26 <litb> ohh
10:37:47 <litb> did ac say anything when i left? i remember he wanted to give away some code
10:37:47 <cjb> dcoutts: yup.
10:37:48 <dons> dcoutts: so we'd make it available to simonM for testing the parallel GC, and rl for testing the data parallel libraries
10:37:49 <dcoutts> litb: no, I wrote a book review for The Monad.Reader
10:38:00 <dons> and further improving the support for large parallelism in haskell
10:38:38 <dcoutts> dons: available to the whole community and especially for a project to get the ghc sparc ncg working again, like a student project, perhaps a SoC one
10:39:03 <dons> yep. just thinking on what specific offers we can make to the vendor
10:39:26 <dcoutts> dons: the sparc ncg + demoing scalability results was what I was suggesting
10:39:32 <dons> we've a good case: haskell can drive multicore sales
10:39:35 <dcoutts> dons: as a proposal to sun
10:39:35 <litb> dcoutts: it is a journal?
10:39:46 <dons> yep. so we should be able to lock 'em in
10:39:55 <dcoutts> litb: it's a haskell community journal, not an academic one
10:40:01 <litb> oh i see
10:40:14 <dcoutts> dons: I can forward you the email I sent and the reply thus far
10:40:23 <dons> ok. good
10:40:34 <dons> i'd consider pulling in SPJ and SimonM to get feedback too
10:40:35 <dcoutts> dons: yes, it's particularly the multi-core thing I was trying to sell to them
10:40:50 <dons> Manuel too, knows a lot of the hardware guys
10:40:54 <dons> in the multicore realm
10:41:00 <dons> and knows what to say to make them excited
10:41:23 <litb> dcoutts: i'm just reading it now :)
10:41:32 <fritte> Hey gents, I have a bit of a problem which google wont help me with. Anyone knows what the cause of the following might be? ghc-6.8.2: failed to create OS thread: Cannot allocate memory. The error shows up when I attempt to compile hello world
10:41:35 <dcoutts> dons: I promised to put them in touch with the right people if they wanted to discuss details
10:42:31 <dcoutts> dons: thought I want them to donate to haskell.org, not UNSW ;-)
10:42:49 <Lemmih> fritte: What platform?
10:44:09 <fritte> Running gnu/linux on an x86.
10:44:11 <dons> dcoutts: definitely
10:46:33 <dons> yo shapr in the chan!
10:47:46 <dons> wow. there's a lot of xmonad@ traffic.
10:48:54 <dons> wow, Nicolas Pouillard is everywhere atm. working on yi, xmonad, darcs... :)
10:48:58 <dons> great to see new people coming in
10:49:35 <Nafai> I'd love to hack on Yi sometime to make it a kick-butt Haskell "IDE"
10:49:49 <dons> seems to be getting into a pretty good state
10:49:58 * wli ekes out the beginnings of a Fourier-Motzkin solver.
10:50:00 <dons> 0.3 release out now, http://reddit.com/r/programming/info/6799v/comments/
10:50:36 <dancor> @t (!!)
10:50:36 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:50:42 <dancor> @type (!!)
10:50:44 <lambdabot> forall a. [a] -> Int -> a
10:50:58 <dancor> @type Text.ParserCombinators.Parsec.Error.ParseError
10:50:58 <lambdabot>     Not in scope:
10:50:59 <lambdabot>       data constructor `Text.ParserCombinators.Parsec.Error.ParseError'
10:51:07 <dancor> @type Parsec.ParseError
10:51:08 <lambdabot> Couldn't find qualified module.
10:51:29 <dancor> for some reason i can access e.g. errorPos but not ParseError
10:51:37 <dancor> in my program
10:52:03 <opqdonut> does yi use the haskell ncurses bindings for the vty frontend?
10:52:18 <dons> it uses a haskelll termio
10:52:21 <dons> not ncurses
10:52:27 <dons> formerly it was all curses.
10:52:31 <EvilTerran> dancor, try importing Text.ParserCombinators.Parsec.Error directly?
10:52:41 <shapr`> hiya dons!
10:52:44 <dancor> EvilTerran: yeah still no love
10:53:40 <dancor> mysterio, i even reinstalled the parsec source i was staring at
10:53:47 <dancor> it's clearly exported
10:54:13 <litb> hm, i think i will buy both "Introduction to Functional Programming using Haskell" and "Programming in Haskell"
10:54:22 <litb> or is that a bad idea?
10:54:37 <litb> 'cause i read the one is more mathematically while the other is much more Haskell
10:55:13 <faxathisia> hmm.. I think I have read Programming in Haskell
10:55:17 <litb> or should i get a pure Functional Programming book covering only the math instead of "Introduction to Functional Programming using Haskell" ?
10:55:33 <dancor> litb: i don't know but better to have too much knowledge than too little.  also once you put enough $$ in you'll _have_ to learn hs really well
10:56:12 <dons> well, i'm not sure the math is needed
10:56:17 <dons> depends on your goal
10:56:40 <litb> dancor: :)
10:56:42 <litb> i see
10:56:54 <dons> ?bot
10:56:55 <lambdabot> :)
10:56:55 <monochrom_> "Introduction to Functional Programming using Haskell" covers efficiency and monad transformers.
10:57:03 <yrlnry> I recently discovered that Haskell admits functions  (such as fix) whose types are not valid theorems of logic.  Then I read a paper by David Turner about languages that do not admit partial functions.  Do total languages obey the Curry-Howard isomorphism?
10:57:15 <litb> dons: i don't want to know the high level things when i don't understand the basics
10:57:47 <faxathisia> yrlnry, Just observe a subset of haskell if you like, The curry howard interpretation is valid in many many ways
10:58:06 <yrlnry> faxathisia: I don't understand how that answers my question.
10:58:58 <Tac-Tics> Total or computable functions?
10:59:14 <monochrom_> For example it motivates the need of foldl' and explains how it helps. foldl' is called sfoldl in the book.
10:59:29 <litb> monochrom_: oh i see
10:59:40 <litb> but it doesn't explain not only that but also other things or?
11:00:32 <monochrom_> Yes. I'm just tipping off the tip of the iceburg that is the infinite wisdom contained in the Bird book that everyone considers "mathy".
11:01:05 <monochrom_> IMO it is the most practical book in existence. "mathy" can co-exist with practical, in fact can enhance practical.
11:01:09 <dons> anything by Bird is valuable :)
11:01:12 <faxathisia> yrlnry, Sorry I didn't really answer your question.. Well any language based on a typed lambda calculus can be looked at with curry howard in mind
11:01:46 <faxathisia> yrlnry, I don't suppose every total language is based on some kind of typed lambda calculus are they?
11:01:58 <monochrom_> If you drop the math, you can be somewhat practical but not extremely practical.
11:02:20 <dancor> :t ParseError works on ghci Error.hs, but after install no luck
11:02:20 <lambdabot> parse error on input `,'
11:02:29 <dancor> lambdabot: stay out of this
11:02:33 <Lycurgus> monochrom_: Amen!
11:02:35 <litb> monochrom_: indeed that is what i think too
11:02:41 <litb> so i will buy both of them
11:02:44 <monochrom_> Of course I'm not putting up math as a sufficient condition. You need math and you need other things too.
11:02:51 <litb> the english version of both indeed
11:03:08 <litb> though it would be better if there were good German translations
11:03:17 <yrlnry> faxathisia: No, I guess not.
11:03:23 <Lycurgus> yeah but the Shu Xue is a needful thing
11:03:38 <yrlnry> faxathisia: Does every total function in Haskell obey C-H?
11:04:11 <faxathisia> yrlnry, mmm do you know Prolog?
11:04:15 <yrlnry> no.
11:04:20 <yrlnry> But I can fake it a little.
11:04:27 <litb> i suppose Prolog is more descriptive than Haskell
11:04:46 <litb> i know it a very littl bit
11:05:14 <faxathisia> I'm not so sure how to put thins.. I think that it would be fair to say that curry howard gives you another way to read programs
11:05:38 <litb> is curry howards difficult to understand too?
11:05:58 <litb> i don't know but that reminds me of harry potter :)
11:06:16 <faxathisia> The only thing totality is required for is consistency
11:06:29 <faxathisia> It's not necessary for a logic to be consistent
11:06:57 <faxathisia> You still can observe programs as proofs, even if they don't terminate
11:07:18 <faxathisia> Just don't claim to have proved the goldbach conjecture in haskell.. that's all
11:07:19 <litb> hm so few in #haskell.de
11:07:47 <ricky_clarkson> Presumably because most technical Germans can speak Englisch.
11:08:02 <yrlnry> What I'm specifically asking about is the interpretation of types as theorems.  In languages that correspond to inconsistent logics, this still holds, but trivially so.  I want to know if restricting haskell to total functions retains the property that every program's type is a theorem of logic while at the same time making the logic consistent.
11:08:21 <faxathisia> yrlnry, Yes it does indeed
11:08:31 <faxathisia> yrlnry, That's what I meant by a subset
11:08:47 <faxathisia> yrlnry, One such subsest is that which Djinn looks at
11:09:05 * wli tries to get the rest of Fourier-Motzkin together.
11:10:33 <yrlnry> Okay, thanks.
11:10:58 <yrlnry> @dj a -> a
11:10:58 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver . ? @ bf ft id pl rc v wn
11:11:03 <yrlnry> @djinn a -> a
11:11:03 <lambdabot> f a = a
11:11:10 <yrlnry> @djinn (a -> a) -> a
11:11:11 <lambdabot> -- f cannot be realized.
11:11:16 <yrlnry> @djinn a -> (a -> a)
11:11:16 <lambdabot> f _ a = a
11:11:34 <faxathisia> k :: a -> (a -> a)
11:11:43 <faxathisia> k :: a -> (b -> a) -- more generally
11:11:53 <yrlnry> @djinn b -> (a -> a)
11:11:53 <lambdabot> f _ a = a
11:12:05 <yrlnry> @djinn b -> (b -> a)
11:12:05 <lambdabot> -- f cannot be realized.
11:12:12 <EvilTerran> @. pl djinn a -> b -> a
11:12:12 <lambdabot> f = const
11:12:14 <litb> what does djinn do?
11:12:18 <Tac-Tics> @djinn cause -> (and, effect)
11:12:18 <lambdabot> -- f cannot be realized.
11:12:22 <Tac-Tics> It proves stuff
11:12:23 <EvilTerran> @help djinn
11:12:23 <lambdabot> djinn <type>.
11:12:23 <lambdabot> Generates Haskell code from a type.
11:12:23 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:12:23 <yrlnry> litb: proves theorems.
11:12:23 <Tac-Tics> with types
11:12:27 <litb> finding the most trivial function for the given type or so?
11:12:28 <litb> oh
11:12:32 <faxathisia> It tries to write a function with a given type
11:12:46 <EvilTerran> @djinn Either a b -> (a -> b) -> b
11:12:46 <lambdabot> f a b =
11:12:46 <lambdabot>     case a of
11:12:46 <lambdabot>     Left c -> b c
11:12:46 <lambdabot>     Right d -> d
11:12:46 <yrlnry> litb: both, since types are theorems and programs with those types are proofs of those theorems.
11:13:00 <Tac-Tics> @djinn a -> a -> (b, a) -> (b -> (a,b))
11:13:00 <lambdabot> f _ a _ b = (a, b)
11:13:25 <EvilTerran> if you prefer, programs are "evidence" that their type is realisable
11:13:55 <yrlnry> Unfortunately, Haskell's logic is inconsistent, so everything is a theorem.
11:14:18 <faxathisia> It's not so bad
11:14:25 <yrlnry> I didn't say it was *wholly* unfortunate.
11:14:28 <Tac-Tics> yrlnry: inconsistent is an ugly word. Let's say that Haskell is so __cool__ that everything is a theorem
11:14:30 <ptolomy> Grr.. I'm having troubles with some circular dependencies on stuff I want to break into separate modules. I have a monad that has a state component, and the state component contains maps of functions that are in that monad. Stupid monolithic monad.
11:15:12 <Tac-Tics> @type fix
11:15:13 <lambdabot> forall a. (a -> a) -> a
11:15:13 <dons> maybe use recursive modules?
11:15:26 <Tac-Tics> @djinn (a -> a) -> a
11:15:27 <lambdabot> -- f cannot be realized.
11:15:32 * ptolomy looks into this "recursive modules" thing..
11:15:56 <yrlnry> @djinn a -> Either a b
11:15:56 <lambdabot> f = Left
11:16:20 <yrlnry> @djinn (a,b) - >Either a b
11:16:20 <lambdabot> Cannot parse command
11:16:25 <yrlnry> @djinn (a,b) -> Either a b
11:16:26 <lambdabot> f (a, _) = Left a
11:17:15 <litb> oh i see
11:17:39 <yrlnry> @djinn ((a -> b) -> a) -> a
11:17:40 <lambdabot> -- f cannot be realized.
11:17:44 <yrlnry> Heh.
11:17:55 <litb> b -> (b -> a) then that does also mean that a != b ?
11:18:01 <litb> e.g that they are different types?
11:18:04 <faxathisia> @djinn Void -> a
11:18:04 <lambdabot> f = void
11:18:08 <yrlnry> Not in general.
11:18:08 <litb> but that is not the case in haskell normally, or?
11:18:19 <faxathisia> @djinn Not (Not a) -> a
11:18:19 <lambdabot> -- f cannot be realized.
11:18:26 <faxathisia> @djinn a -> Not (Not a)
11:18:27 <lambdabot> f a b = b a
11:18:45 <Toxaris> litb: it means that a and b *may* different types, so an implementation has to provide for that possibility
11:18:48 <faxathisia> @djinn a -> (Not a) -> x
11:18:48 <lambdabot> f a b = void (b a)
11:19:14 <yrlnry> What is "Not" here, exactly?
11:19:29 <litb> Toxaris: but if they are equal, why can'T we define for type b -> (b -> a) that it is "f a b = a + b" ?
11:19:44 <litb> that fits into the type well, or am i wrong?
11:20:01 <litb> since a and b are Nums, and a is a Num too
11:20:04 <monochrom_> type "Not a" is the same as "a -> Void".  Void is false.
11:20:15 <litb> errm, since b is a Num and a too
11:20:21 <Toxaris> litb: the game is: you choose an implementation, I choose types for a and b, your implementation has to work.
11:20:27 <litb> but djinn says that f is not realizable
11:20:30 <yrlnry> okay.
11:20:37 <faxathisia> :t (==)
11:20:38 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:20:41 <Toxaris> litb: you've choosen f a b = a + b. I choose a = Char and b = (Int -> ()). You loose.
11:20:47 <faxathisia> There is a -> a -> B
11:20:48 <faxathisia> :P
11:21:04 <litb> Toxaris: ah, we can choose arbitrary types. i see
11:21:08 <faxathisia> It's possible in haskell but not the subset Djinn know about..
11:21:29 <litb> maybe i should look into its manual :)
11:21:33 <idnar> :t void
11:21:33 <lambdabot> Not in scope: `void'
11:21:35 <Time`s_Witness> exp 0 = 1; exp 1 = 2.71828182845905 ;  exponencial... huh? I dont get.. what is the second argument ? for an exponential i need the base and the "power", the power usually varies.. and it makes no sense here to... say exp 1 = 1 ^ x , x = variable. :S what does this function do ?
11:22:06 <ricky_clarkson> Time`s_Witness: It calculates the exponent of a number.
11:22:13 <ricky_clarkson> @go wikipedia exponent
11:22:14 <lambdabot> http://en.wikipedia.org/wiki/Exponentiation
11:22:14 <lambdabot> Title: Exponentiation - Wikipedia, the free encyclopedia
11:22:27 <ricky_clarkson> > 3^3
11:22:28 <desegnis> Time`s_Witness: exp uses Euler's number (e) as the base
11:22:28 <lambdabot>  27
11:22:32 <nelhage> > exp 1 -- Should be a familiar number
11:22:33 <lambdabot>  2.718281828459045
11:22:37 <yrlnry> > log 2
11:22:37 <lambdabot>  0.6931471805599453
11:22:48 <yrlnry> > exp (4 * log 3)
11:22:48 <lambdabot>  81.00000000000003
11:23:00 <desegnis> > exp (log 5)
11:23:01 <Time`s_Witness> ahh Euler's number.. ok.. that answered :D
11:23:01 <lambdabot>  4.999999999999999
11:23:04 <ricky_clarkson> Grr, my answer sucked.
11:23:26 <Time`s_Witness> lol
11:23:26 <sebell> I love floating point
11:23:37 <monochrom_> I love sinking point.
11:23:42 <desegnis> we all do, sebell.
11:23:48 <yrlnry> sebell: the extra 0.000000000003 is because of inflation.
11:23:59 <sebell> Shoot! I better sell.
11:24:20 <monochrom_> "Can we say the computer thinks, as much as we can say the computer sinks, or even stinks?"
11:24:23 <litb> lol
11:24:54 <litb> it only stinks if browse to youtube
11:24:58 <Toxaris> monochrom makes me think about "minimal pair analysis" :(
11:25:09 <EvilTerran> Time`s_Witness, you may've wanted (^), (^^), or (**)
11:25:18 <monochrom_> what is minimal pair analysis?
11:26:05 <Time`s_Witness> dont they all do the same, EvilTerran? :s
11:26:14 <sieni> with regard to floating points: http://catb.org/jargon/html/graphics/74-12-25.png
11:26:40 <faxathisia> sieni, hehe .. I like those comics
11:26:46 <Time`s_Witness> hmm probably for different types of numbers.. Int/Double.. from what i can check
11:26:46 <Toxaris> monochrom_: it's from linguistics. if you want to learn wich sounds in a language are meaningfull, you search for minimal pairs of different words wich differ only in one sound, like think and sink. since think /= sink, but ink == ink, we know that th /= s.
11:26:55 <faxathisia> (esp. the APL one)
11:27:52 <byorgey> Time`s_Witness: that's right.  (^) is for positive integer exponents.  (^^) allows negative integral exponents. (**) is general exponentiation.
11:28:16 <byorgey> Time`s_Witness: there are multiple ones both for reasons of types and efficiency.
11:29:07 <Time`s_Witness> I see:) Thanks all!
11:29:12 <Toxaris> monochrom_: every language has different minimum pairs wich show different meaningfull sounds (or "phonemes"), wich is a real problem for foreign language learners. e.g. I'm not good at saying th different from s in english :(
11:29:17 <yrlnry> monochrom_: A counterexample is that in English, the p in "pill" is not considered different than the p in "spill", even though the two are pronounced differently, and in some languages there *are* minimal pairs that differ only in those two kinds of p.
11:29:25 <RayNbow> litb, interested in my opinion on this book? http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/ :)
11:29:25 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
11:29:48 <monochrom_> Thanks.
11:29:53 <yrlnry> monochrom_: such sounds, which are different, but which are interchangeable in the language under consideration, are called "allophones".
11:30:19 <monochrom_> > (0^0, 0**0)
11:30:20 <lambdabot>  (1,1.0)
11:30:41 <yrlnry> > (-1)^(1/2)
11:30:41 <lambdabot>  Add a type signature
11:30:45 <byorgey> > (25^19, 25**19)
11:30:46 <lambdabot>  (363797880709171295166015625,3.637978807091713e26)
11:30:57 <yrlnry> > (-1)::Integer ^(1/2)
11:30:57 <lambdabot>  Parse error at "^(1/2..." (column 15)
11:31:01 <byorgey> > (-1)**(1/2)
11:31:02 <yrlnry> Meh.
11:31:02 <lambdabot>  NaN
11:31:11 * yrlnry sobs
11:31:17 <byorgey> yrlnry: ^ only works for integer exponents.
11:31:34 <byorgey> *positive integer exponents
11:31:42 <desegnis> > logBase 0 1
11:31:43 <lambdabot>  -0.0
11:31:46 <monochrom_> You need to write (expr :: type) with parentheses if there is an outer context.
11:31:54 <yrlnry> I think I was temporarily under the misapprehension that 1/2 was an integer.
11:32:09 <byorgey> yrlnry: um... ;)
11:32:14 * wli mutters something about arbitrary-precision natural number types.
11:32:21 <yrlnry> monochrom_: Thanks.  I read about that in the Haskell report yesterday but hadn't ever tried it out yet.
11:32:31 <monochrom_> 1/2 is an integer in a suitable algebraic field.
11:32:35 <yrlnry> "Haskell sucks because 1/2 is not an integer."
11:33:08 <monochrom_> IIRC something like Q(sqrt(2)) will do.
11:33:12 <gwern> RayNbow: I used that for a while. it's not bad at all
11:33:14 <byorgey> > (-1)^(1 `div` 2)  -- this works ok!
11:33:14 <lambdabot>  1
11:33:32 <RayNbow> gwern: I know, it's a pretty good book
11:33:45 <RayNbow> although I didn't really understand the monads part when I first read it
11:33:57 <desegnis> byorgey, cheater!
11:34:02 <RayNbow> (I actually learnt monads stuff by watching a certain channel9 vid :p)
11:34:23 * byorgey gives desegnis his best angelic "who, me???"
11:34:51 <desegnis> (^^)
11:35:03 <desegnis> (that was the emoticon, not the operator)
11:35:07 <yrlnry> monochrom_: In what sense is 1/2 an "integer" in Q[sqrt(2)]?
11:35:11 <byorgey> desegnis: hehe
11:35:55 <byorgey> an emotorator?
11:36:10 * gwern wonders what the buzz is on the new release of yi
11:36:45 <desegnis> gwern: They need developers ;)
11:36:51 * RayNbow wonders if yi is any good :P
11:37:04 <byorgey> RayNbow: it depends what you mean by "good" =)
11:37:04 <RayNbow> <-- no experience with emacs and vi(m) :p
11:37:22 <opqdonut> wow
11:37:36 <RayNbow> my skills are limited to notepad, edit, nano, pico :p
11:37:38 <byorgey> RayNbow: I'm using yi for some stuff at the moment.  It still has some rough edges, but it's great fun being able to easily extend it with Haskell =)
11:37:40 <opqdonut> that's certainly an achievement
11:37:43 <CosmicRay> what editors are you familiar...
11:37:43 <CosmicRay> ah
11:38:05 <byorgey> I just could never get excited about learning emacs lisp... =P
11:38:08 <monochrom_> There is a generalized definition of "integer" relative to the given field. If the field is Q you still get the familiar -2 -1 0 1 2 integers. But with algebraic field extensions sometimes things like sqrt(2)/2 can also be integers. It has to do with the norm of the field. I can be wrong about 1/2 being an integer in Q(sqrt(2)) but its integers are definitely more than just {m + n sqrt(2) | m, n in Z}.
11:38:09 <CosmicRay> RayNbow: in that case, I doubt you will find room to complain about any modern editor ;-)
11:39:24 <byorgey> monochrom_: "has to do with the norm of the field"  <--- vague, please elaborate!
11:39:36 <monochrom_> I'm rusty on this, so I can't! :)
11:39:42 <byorgey> oh, ok =)
11:39:51 <RayNbow> CosmicRay: I mainly use Eclipse for dev stuff (JDT, CDT)
11:39:54 * byorgey runs off to mathworld
11:39:55 <monochrom_> 10 years ago I could tell you everything about it.
11:40:08 <monochrom_> Look for "algebraic integers".
11:40:17 <RayNbow> I also have this Haskell Eclipse plugin... but it's kinda limited
11:40:48 <cjb> Perhaps someone could set up a TODO for yi, and in particular things like emacs functions that they use that Yi doesn't have yet?
11:40:49 <CosmicRay> RayNbow: that's the one editor I haven't been able to wrap my head around much
11:41:04 <CosmicRay> i dunno, something about having to set up some complex project and import files seems Just Wrong
11:41:05 <gwern> cjb: a monumental task!
11:41:11 <nelhage> What's the easiest way to build yi to play with it?
11:41:23 <dcoutts> cabal install yi
11:41:23 <nelhage> cabal-install fails for me
11:41:27 <dcoutts> I'd hope anyway :-)
11:41:33 <cjb> gwern: It seems to have all the editing functions I use in emacs :)
11:41:41 <CosmicRay> gwern: yes, until yi can solve the towers of hanoi and be a semi-intelligent psychotherapist, it will not be emacs ;-)
11:41:43 <cjb> nelhage: tried it in the last few days, on ghc6.8?
11:41:49 <dcoutts> nelhage: what version of cabal-install btw?
11:41:52 <nelhage> http://paste.husk.org/10818
11:42:13 <gwern> cjb: not that I use - just reverse isearch was an incredible pain to get working
11:42:23 <nelhage> I'm on 6.6, not 6.8. cabal-install doesn't respond to --version or -V or -v, so I'm not sure how to figure out its version :0
11:42:37 <dcoutts> nelhage: ah, it's the really old version :-)
11:42:47 <RayNbow> CosmicRay: I have to admit that importing files in Eclipse isn't quite easy... but setting up a project is just a few clicks
11:43:00 <CosmicRay> but I just want to edit a file, dammit
11:43:05 <gwern> wow. one of my reddit comments dropped overnight from ~73 to 39
11:43:12 <CosmicRay> in my best dr. mccoy voice
11:43:16 <dcoutts> nelhage: also looks from that paste that yi only works with ghc-6.8
11:43:16 <RayNbow> then you don't boot a whole IDE :p
11:43:27 <CosmicRay> RayNbow: oh right, I use emacs :-)
11:43:31 <RayNbow> but Eclipse is nice if you're doing a Java project... I really like JDT's refactor tools :)
11:43:45 <CosmicRay> RayNbow: I *never* do java projects
11:43:50 <RayNbow> :p
11:44:32 <CosmicRay> well, almost never
11:44:33 <nelhage> Urgh, I guess I should shave the yak of installing 6.8 some time.
11:44:57 <cjb> nelhage: step one, switch to Ubunty/hardy.  :)
11:45:04 <monochrom_> I wish I had time to make some nice tools for haskell programming in eclipse.
11:45:13 <cjb> s/ty/tu/
11:45:23 <nelhage> cjb: I'm on feisty, and it works _just fine_, so I have no intention of upgrading :)
11:45:31 <byorgey> monochrom_: ah, any root r of a degree-n polynomial with integer coefficients, and an x^n coefficient of 1, is an algebraic integer of degree n.
11:45:46 <nelhage> For the first time since I moved to Linux, I have near-100% reliability on suspend/resume, and I'm positive that any change will break that :)
11:45:55 <cjb> nelhage: Ah, fair enough.  Well, add timely packaging of ghc to the list of reasons you might want to update.
11:46:44 <gwern> dcoutts: yi is too tied to the GHC api to be anything but 6.8.x. *however*, there's an experimental 'dynamic' flag to turn off the dynamic compilation stuff, which *might* let you build on an older/newer GHC since I think it uses CPP to strip out calls to the API
11:47:06 <dcoutts> gwern: oh I don't mind, just telling nelhage
11:53:09 <Cin> hm
11:53:16 <Cin> this gobby is strange
11:53:25 <Cin> anyone working on arc online?
11:54:45 <Cin> shachaf: i made a tiny change. hehe
11:54:47 <sebell> *tumbleweeds* Arc was so yesterday.
11:55:38 <Cin> sebell: well, the idea was to write an arc implementation in about a day, except people seem to have started and then lost interest or something
11:55:56 <sebell> Yes, that day was yesterday ;)
11:56:38 <monochrom_> hahahaha
11:56:49 <monochrom_> @remember sebell Arc was so yesterday.
11:56:49 <lambdabot> It is stored.
11:57:41 <byorgey> heh, I'd never used gobby until yesterday
11:57:43 <byorgey> it's fun =)
11:58:03 <byorgey> anyone want to hack something else silly via gobby? =D
11:58:07 <shachaf> byorgey: I still want a Gobby server for #haskell.
11:58:18 <shachaf> byorgey: It would make some things much simpler.
11:58:22 <byorgey> shachaf: that's a pretty sweet idea!
11:58:38 <byorgey> shachaf: I wonder if it could be hosted on community.haskell.org or something?
11:59:10 <shachaf> byorgey: It would be nice if it could be somehow integrated  with hpaste.
11:59:53 <stevan> hi, does aliases (@) work in where clauses?
11:59:53 <olsner> this could be the back-end for a new hpaste, so that the new hpaste is just a (read-only) web interface for gobby :P
12:00:02 <byorgey> shachaf: oh, sure.  And a system for auto-compiling and appending the results of the compile at the bottom!
12:00:05 <scodil> is there a way to make IO actions lazy? something like strictToLazyST? Is this what unsafeInterleaveIO does? Or does it just defer the single action on which it's applied? Basically I'd like to be able to do things like mapM, filterM, lazily.
12:00:12 <Cin> shachaf: whose server is the one with arc on it?
12:00:27 <byorgey> stevan: I think so.  are you having a problem?
12:00:35 <shachaf> Cin: "jed", I think?
12:01:00 <cjb> ask and ye shall receive:  gobby -> monad.printf.net is up, I'll leave it running.
12:01:09 <Cin> cjb: yay :D
12:01:12 <shachaf> > let { f x = (a,b) where a@(b:_) = x } in f [1,2]
12:01:13 <lambdabot>  ([1,2],1)
12:01:14 <byorgey> w00t!
12:01:15 <olsner> byorgey: or errors could even appear as in-line comments
12:01:17 <byorgey> cjb++
12:01:31 <byorgey> olsner: oh, sure!  matching up with line numbers is easy
12:01:48 * shachaf has to go in a moment.
12:01:50 <Cin> byorgey: see you on there :P
12:01:59 <shachaf> I'll see if you're still obbying when I'm back. :-)
12:02:00 <desegnis> scodil: unsafeInterleaveIO does indeed defer the single action on which it's applied
12:02:24 * shachaf wonders if .lhs makes more sense for Obby sessions.
12:02:58 <scodil> desegnis: so if i want a lazy version of filterM I have to write it myself using unsafeInterleaveIO?
12:03:11 <resiak> shachaf: oh, using the literate bit as an ad-hoc multi-user chat ?
12:03:27 <olsner> I guess that depends on whether you use the chat for chat with occasional code addition or use the source for chat and occasionally add > for bits of code
12:04:13 <desegnis> scodil, well you could just unsafeInterleave the filter action
12:04:30 <shachaf> resiak: Yes.
12:04:58 <litb> > let { f x = (a,b) where a@(b:_) = x } in f [1,2, 3]
12:04:59 <lambdabot>  ([1,2,3],1)
12:05:02 <shachaf> At least with Gobby's interface, there doesn't seem to be a keybinding to switch to the chat.
12:05:10 <litb> uh that looks brain freeky
12:05:12 <desegnis> scodil, but be careful not to be bitten by nasty lambda crocodiles.
12:05:13 <cjb> now we just need lambdabot inside the gobby chat :)
12:05:26 <scodil> desegnis: what does that mean?
12:05:33 <olsner> inline @pl ;-)
12:05:37 <olsner> in gobby
12:05:40 <desegnis> scodil, the former or the latter?
12:05:48 <scodil> lambda crocodiles.
12:05:52 <Saizan> desegnis: if you unsafeInterleave the single action you still force everything when you pattern match on the first cons
12:05:58 <astrolabe> Is there a standard way to deal with the fact that because readFile is lazy, you can shut the file, or open other ones before you've finished reading it?
12:06:04 <litb> thought of extending lambdabot to show the calls (the thing don did in his blog )
12:06:07 <litb> ?
12:06:58 <hpaste>  stevan pasted "@ in where" at http://hpaste.org/5383
12:07:03 <Saizan> scodil: start writing lazySequence (m:ms) = do x <- m; xs <- unsafeInterleaveIO $ lazySequence ms; return $ x:xs
12:07:24 <litb> oh now i see why they had a perl script in ghc sources
12:07:30 <desegnis> scodil, a not-so-obvious image that says that the Â»unsafeÂ« bit has a meaning, although you sometimes do need it
12:07:35 <litb> because of Pugs being implemented in haskell
12:07:58 <faxathisia> prototyped!
12:08:21 <faxathisia> Perl 6 compilers are done in lots of languages
12:08:53 <Japsu> the perl to end all perls
12:08:57 <resiak> hrm.  I want to build an equivalent of withCString for turning [String] into null-terminated char* arrays; i feel like I shoudl be able to build it out of withCString and withArray0, but can't see how to do so
12:09:12 <Saizan> scodil: but for ST there's Control.Monad.ST.Lazy
12:09:40 <litb> oh
12:10:40 <byorgey> shachaf: hm, I agree re: .lhs in gobby
12:11:18 <cjb> well, both make sense.  if you want to work on existing .hs code, of course that should be fine.  But yeah, new stuff in .lhs makes a lot of sense.
12:11:50 * shachaf has been through some Gobby sessions with probably ~90% of the lines starting with --.
12:12:03 <olsner> I guess first one there calls the shots, but lhs certainly sounds like a good default
12:12:40 <desegnis> Saizan, well you wouldn't force _everything_, only as much as is needed for the first cons
12:12:48 <shachaf> olsner: It doesn't look like Gobby has highlighting for .lhs. :-(
12:13:28 <litb> gobby is an editor
12:13:31 <litb> ?
12:13:50 <cjb> a collaborative editor.  lots of people editing the same document at the same time.
12:13:57 <litb> emacs has basic hilighting for lhs. but what sucks is that either i am in haskell mode or i am in latex mode so it either hilights one or the other
12:14:01 <litb> that really suxx
12:14:12 <doserj> I would guess syntax-highlightinh is done by gtksourceview?
12:14:19 <cjb> doserj: correct.
12:14:19 <desegnis> Saizan, where the filtering action is the IO Bool in filterM :: (a -> IO Bool) -> [a] -> IO [a]
12:14:49 <litb> lol what i see is that everyone writes hilighting another way and everytime it looks strange :
12:14:52 <litb> D
12:16:07 <Saizan> desegnis: since the shape of the list depends on it i think that won't work at all
12:16:09 <scodil> desegnis: but won't filterM force that suspended IO Bool value as soon as it tries to build the list?
12:16:21 <byorgey> hey, someone add the gobby server at monad.printf.net to the topic =)
12:17:47 <desegnis> scodil, that's right: as soon as it builds the list, it has to run those actions. There's no other way to build the list
12:19:24 <scodil> but since the list is built using return, won't the whole list get build whenever the (filterM ...) action is performed? I wan't to do something like (do x <- filterM ... ; return (head x)) and have it only do as much IO as is need to produce the head
12:19:56 <desegnis> Saizan, this Â»worksÂ« for me:  take 2 `fmap` filterM (\x -> unsafeInterleaveIO (print "bla" >> return (x/=0))) [2,0,3,0,4]
12:20:59 <desegnis> scodil, no, Â»returnÂ« is not strict, and it certainly won't traverse the list
12:21:08 <Saizan> desegnis: right
12:22:33 <desegnis> scodil, hm, I'm unsure whether the fact that the list will be built from left to right may mean that it performs more IO than you might want
12:22:40 <magnusth> dons, didn't you give a talk on xmonad, the importance of separating IO and the pure parts and using QuickCheck?
12:24:20 <desegnis> scodil, but in general unsafeInterleaveIO should be exactly what you want
12:24:50 <scodil> desegnis: it looks like your right. yeah i knew it has something to do with unsafeInterleaveIO, i just didn't know if I had to rewrite everything in Control.Monad to get that behavior
12:26:22 <desegnis> scodil, at least for mapM and filterM, you don't need to
12:26:41 <scodil> so in theory you could write an IO action that reads every file in a directory and puts all their contents into a list, and then if you use filterM (\x -> unsafeInterleaveIO (...)) .. on that list, and then take only some of the filtered list, it will only open as many files as it needs to produce the output
12:26:59 <dons> magnusth: indeed i did
12:27:21 <dons> magnusth: http://www.ludd.ltu.se/~pj/hw2007/xmonad.mov
12:27:32 <magnusth> dons, I remember looking at the slides a while back, but can't find them
12:27:37 <magnusth> or did I imagine it?
12:28:48 <Cin> @hoogle init
12:28:49 <lambdabot> Prelude.init :: [a] -> [a]
12:28:49 <lambdabot> Data.List.init :: [a] -> [a]
12:28:49 <lambdabot> Data.ByteString.init :: ByteString -> ByteString
12:28:56 <olsner> > init [1,2,3]
12:28:57 <lambdabot>  [1,2]
12:29:03 <Cin> excellent
12:29:10 <litb> > init [1,2,3, 4, 5, 6]
12:29:11 <lambdabot>  [1,2,3,4,5]
12:29:11 <desegnis> scodil, if you have readEveryFileWithoutAnyUnsafeCommands :: IO Foo, then you cannot break that apart and interleave only some of those parts. you'd need the single actions, one for every file
12:29:18 <litb> hm, is that a std function?
12:29:25 <litb> oh, silly question yes it is
12:29:27 <litb> nice
12:32:03 <litb> well how come they don't show dons?
12:32:56 <scodil> desegnis: ok how about if I have stuff <- lazyReadLotsOfStuff :: IO [Stuff], and I do filterM (\x -> return (x /= y)) stuff... will the filterM force the whole list?
12:33:15 <scodil> do i have to have unsafeInterleaveIO in both the least producer and the list consumer?
12:33:31 <scodil> or is it enough that the producer is lazy?
12:33:37 <resiak> a
12:34:10 <scodil> er, i mean, "  return . head =<< filterM (\x -> ... ) stuff
12:34:11 <Cale> scodil: Well, you'll have to liftM that filterM -- filterM takes a list as its second parameter.
12:34:25 <Cale> oh
12:34:27 <Cale> I see :)
12:34:35 <Cale> (the line was broken awkwardly)
12:34:47 <scodil> right sure. return . head =<< filterM (\x -> ... ) =<< lazyReadLotsOfStuff
12:34:54 <Cale> right.
12:35:02 <Cale> @src filterM
12:35:02 <lambdabot> Source not found. Just try something else.
12:35:35 <Cale> So this is in the IO monad...
12:36:50 <Cale> seems to work
12:37:06 <Cale> That is, it shouldn't evaluate any more of the list than necessary.
12:37:10 <scodil> sweet
12:37:25 <hpaste>  resiak pasted "i feel like it should be possible to build this with withCString" at http://hpaste.org/5384
12:37:48 <cjb> resiak: you should consider using gobby :)
12:38:02 * resiak installinates
12:38:45 <cjb> dons: Could you add "gobby server: monad.printf.net" to the topic, please?
12:40:16 <Cale> resiak: That's an interesting question...
12:40:53 <Cale> resiak: It's possible that we don't already have a combinator which does that sort of thing, but it should be possible to build one.
12:41:30 <resiak> Cale: right.  withCString has the wrong type:  I can't turn the arrayification code into a list of CString -> IO a actions
12:41:45 <resiak> oh, maybe I could do it the other way out
12:42:11 <resiak> I feel like a generalization of this is bound to exist somewhere
12:42:19 <desegnis> scodil, I think you need an extra unsafeInterleaveIO where you have the ...
12:42:38 <desegnis> oh wait
12:43:09 <desegnis> well that depends on whether you want to interleave what's in the dots, too :-P
12:43:27 <scodil> desegnis: i think i have to because i need to do IO to evaluate the predicate
12:43:37 <scodil> otherwise i just could use (return . filter)
12:45:20 <Eelis> could someone with ghc 6.8.2 confirm that ghci records empty input lines in the readline history, before i report it as a bug?
12:45:22 <desegnis> scodil: the filterM won't force the lazily read list itself, though
12:46:16 <desegnis> or will it? I'm confused
12:46:30 <Lemmih> Eelis: Confirmed.
12:46:34 <Eelis> Lemmih: thank you.
12:51:22 <litb> oh yeah, strange
12:51:49 <litb> Eelis: i have ghc 6.8.2 now. should i repeat the test concerning System.Posix.Limits now?
12:52:08 <olsner> @ty maybe
12:52:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:52:16 <hpaste>  Cale annotated "i feel like it should be possible to build this with withCString" with "how about this?" at http://hpaste.org/5384#a1
12:52:21 <litb> errm, how was that module called again?
12:52:27 <Cale> resiak: check that out
12:52:44 <Cale> hmm, I wonder if it's got them in the wrong order there.
12:52:59 <litb> ah, System.Posix.Resource
12:53:02 <Eelis> litb: hm, i'm trying to recall the details of your case. was this on ubuntu? what was the error you got?
12:53:39 <litb> Eelis: it was about the setResourceLimit doesn't updating the hard limit but instead setting it to 0
12:54:11 <Eelis> litb: ah yes, rings a bell. do you remember if i opened up a ticket for that?
12:54:23 <resiak> Cale: very nice!
12:54:25 <BMeph> Has all of the recent yi activity been with the vty end, or has yi-gtk been looked at, too?
12:54:52 <Cin> oh eck
12:54:59 <Cin> my PC crashed. sorry about that. i'm on my laptop now
12:55:03 <Cin> installing gobby
12:55:19 <litb> Eelis: oh darn. i wanted to open some but i guess i had forgotten it
12:55:22 * litb shames a lot
12:55:23 <magnusth> question about using GHC on Windows, can cabal use the compiler installed with VisualStudio (Express) to compile a foreign lib (written in C)?
12:55:48 <Eelis> litb: heh. well, now you'll be able to make a more informed ticket if the problem persists :)
12:56:05 <Eelis> litb: was this on ubuntu?
12:56:11 <litb> it was on archlinux
12:56:15 <Eelis> ah, yes
12:56:47 <resiak> Cale: I'm not sure it's any clearer :-)
12:57:07 <resiak> I wonder where else nestM might come in useful
12:57:25 <litb> Eelis: it was when you tested archlinux on vbox and felt it is bad 'cause it didn'T regognize your net-card as eth0 =)
12:57:50 <Eelis> litb: that i remember most vividly ;)
12:58:37 <Cale> resiak: It's useful wherever you have bracketed access to resources, and you want to have access to a whole bunch of things at once.
12:59:00 <Cale> resiak: I think that nestM might be backward though. Let me check. I have a fixed version in case it is :)
12:59:02 <resiak> oh, it's not specific to marshalling code of course
12:59:17 <resiak> you mean, it builds a backwards list?
12:59:34 <Cale> yes, it's backwards
13:00:02 <hpaste>  Cale annotated "i feel like it should be possible to build this with withCString" with "fixed." at http://hpaste.org/5384#a2
13:00:08 <resiak> i fell into that trap when i tried to figure out how it should look
13:00:29 <Cale> Trick is to build up a function rather than a list directly :)
13:01:30 <hpaste>  povman pasted "(no title)" at http://hpaste.org/5385
13:01:50 <dons> ?users
13:01:50 <lambdabot> Maximum users seen in #haskell: 463, currently: 432 (93.3%), active: 24 (5.6%)
13:02:00 <Cale> In fact, I think that nestM is useful enough that it should be in the libraries somewhere.
13:03:00 <scodil> how much memory does a cons cell use?
13:03:09 * resiak starts a Useful Combinators note and sticks nestM in it
13:03:12 <Cale> scodil: Enough for a tag and two pointers.
13:03:13 <povman> ^ it really feels like testTry could be written do {newNum <- try 2; biggerNum <- try 4; someString <- try2 6; return [show newNum, show biggerNum, someString]}
13:03:24 <scodil> Cale: and a tag is a word?
13:03:27 <Cale> resiak: heh, I just noticed my type for nestM is "wrong"
13:04:03 <Cale> It has nothing to do with monads :)
13:04:10 <Cale> It really has type [(r -> b) -> b] -> ([r] -> b) -> b
13:04:31 <resiak> huh, you're right
13:04:31 <Cale> scodil: I think so, yeah.
13:04:37 * resiak put his curry-howard hat on for a moment
13:05:02 <Cale> I wonder if this realisation would influence the way I wrote it :)
13:06:50 <Cale> There's something rather CPSy about it, isn't there? :)
13:07:11 <phobes> Cale: That's what I was just thinking as I stared at the type trying to figure out what it does :)
13:07:27 <Cale> hmm, is this sequence for Cont?
13:07:36 <Cale> I think it is.
13:07:42 <dons> hmm
13:07:49 <dons> it does look familiar
13:07:58 <dons> :k Cont
13:07:59 <lambdabot> * -> * -> *
13:08:07 <dons> ?unmtl Cont Int Bool
13:08:08 <lambdabot> (Bool -> Int) -> Int
13:08:19 <dons> :t sequence
13:08:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:08:27 <dons> mm
13:08:29 <hpaste>  yaxu pasted "Unforthcoming yi build error" at http://hpaste.org/5386
13:08:51 <resiak> oh, unmtl is neat
13:09:16 <phobes> Hmm, I think the quantifiers are wrong for it to be about continuations?
13:09:33 <yax1> anyone know why yi can't be built on my system?
13:09:54 <Cale> nest :: [(r -> b) -> b] -> ([r] -> b) -> b
13:09:54 <Cale> nest xs = runCont (sequence (map Cont xs))
13:09:56 <Cale> yep
13:09:58 <Cale> it is :)
13:10:38 <Cale> So, that's pretty cool :)
13:10:42 <phobes> ya ok that makes sense
13:10:44 * phobes drifts back to AFK
13:10:56 <yaxu> or how i might get a more detailed error message out of the build process
13:11:38 <Cale> yaxu: vty isn't installable directly on my system -- I'll have to sort out why in a bit
13:11:58 <yaxu> I just get "Setup.hs: Package yi-0.3 can't be built on this system."
13:12:05 <Cale> huh.
13:12:13 <Cale> Which GHC?
13:13:03 <yaxu> 6.8.1 i believe
13:13:06 <Cale> hmm
13:13:07 <yaxu> i'll doublecheck
13:13:23 <Cale> Yeah, the vty package doesn't list bytestring as a dependency.
13:14:11 <yaxu> yep, 6.8.1, i'll try with 6.8.2
13:14:17 <dons> hmm
13:14:41 <Cale> I wonder how vty managed to slip through the cracks if yi was just released.
13:14:50 <Cale> It hasn't been updated for split base at all.
13:14:53 <dons> they only test the gtk frontend?
13:15:26 <yaxu> ah, yi page says to try darcs for a version compatible with newer ghcs
13:15:30 <yaxu> missed that before, sorry
13:15:52 <yaxu> ah no, that's 0.2
13:15:55 <yaxu> ignore me
13:16:19 <Cale> okay, vty needs bytestring and containers, and that's it.
13:16:39 <Cale> err...
13:16:41 <Cale> yi seems to want to install bytestring 0.9.0.1
13:17:01 <Cale> I don't know why...
13:17:05 <byorgey> yes, yi needs bytestring 0.9.0.1
13:17:10 <Cale> and not newer?
13:17:13 <byorgey> nope
13:17:30 <byorgey> and make sure to build vty etc. with the same version of bytestring
13:17:37 <Cale> ouch.
13:17:44 <byorgey> because if not it will break, and cabal can't figure out what's going on yet
13:17:49 <thoughtpolice> it appears so. i rebuilt a lot of stuff against 0.9.0.4 and yi wouldn't compile because of the build differences :(
13:17:55 <Cale> Why doesn't it work with 0.9.0.4?
13:18:03 <byorgey> Cale: I don't know any details.
13:18:09 <Cale> okay, I'll look into it.
13:18:48 <Cale>         build-depends: bytestring ==0.9.0.1
13:18:48 <Cale>                                -- >= 0.9 && < 0.9.0.4
13:18:54 <Cale> (from its .cabal)
13:19:00 <hpaste>  HairyDude pasted "agda compile error" at http://hpaste.org/5387
13:19:19 <dons> it bet it does work with 0.9.0.4
13:19:21 <HairyDude> possibly due to using a different version of cabal?
13:20:21 <rekso> As I suspected, adding a deforestation rule for efdtInt makes my program run twice as fast.
13:20:41 <faxathisia> Why don't you try 2.1.3
13:20:41 <rekso> which is rather cool
13:23:00 <thoughtpolice> from the error I had with yi it was an 0.9.0.4-vs.0.9.0.1 type err inside yi/Yi/UI/VTY.hs
13:23:13 <nelhage> I'm trying to build 6.8.2, and I get: Could not find module `Text.PrettyPrint': it was found in multiple packages: pretty-1.0.0.0 base
13:23:18 <thoughtpolice> i recompiled vty against 0.9.0.4 though. :/
13:23:23 <nelhage> err, ghc 6.8.2
13:24:14 <Cale> oy... ghc-6.8.2: unknown package: bytestring-0.9.0.1 (dependency of ghc-6.8.2)
13:24:41 <ehird`> i should possibly start resisting the urge to name everything *monad
13:24:55 <Cale> Is ghc-6.8.2 really dependent on bytestring-0.9.0.1?
13:25:03 <jfredett> sweet deal, is yi compiling easily now?
13:25:13 <faxathisia> heh ehird`
13:25:16 <Cale> jfredett: It's so not. :)
13:25:19 <jfredett> ...
13:25:23 <jfredett> damn.
13:25:31 <ehird`> faxathisia: it makes everything sound cooler!
13:25:37 <HairyDude> so anyone know about agda? specifically compiling it with ghc 6.8.2?
13:25:38 <phobes> ehird`:  Poor little monad getting beaten up at school?
13:25:44 <Cale> jfredett: It wants an out-of-date version of bytestring.
13:25:45 <ehird`> IRCmonad. Webmonad. Toiletpapermonad.
13:25:50 <jfredett> damn.
13:25:57 <faxathisia> HairyDude: Why don't you try 2.1.3
13:26:26 <thoughtpolice> Cale: if you do ghc-pkg describe ghc, you'll see it's built against bytestring 0.9.0.1
13:26:27 <faxathisia> HairyDude: I compiled it fine
13:26:31 <jfredett> Cale: i guess thats okay, though, it'll give me some time to finish setting up new computer.. :)
13:26:33 <Cale> thoughtpolice: right.
13:26:39 <Cale> thoughtpolice: which is annoying.
13:26:54 <HairyDude> faxathisia: ah, didn't realise you were talking to me earlier :)
13:27:05 <faxathisia> Yeah, sorry
13:27:07 <HairyDude> got the latest tarball, that's 2.1.2...
13:27:10 <thoughtpolice> Cale: I thought so too. i had a recent problem with libs built against 0.9.0.4, but also using ghc as a library which caused rts linker errs.
13:27:16 <faxathisia> Get the darcs or whatever
13:27:27 <thoughtpolice> pretty annoying since it basically broke the dynamic build version of my program, although feasibly it should work just fine. :(
13:27:38 <HairyDude> if there's a more recent tarball it was released since I left the lab less than an hour ago :)
13:27:40 * HairyDude looks
13:27:41 <thoughtpolice> (used hs-plugins)
13:27:54 <faxathisia> Not a tarball...
13:27:56 <Cale> Where does ghc-as-a-library expose bytestrings in its interface, I wonder...
13:28:07 <HairyDude> sigh, agda fails at google rankings
13:28:09 <HairyDude> ?where agda
13:28:09 <lambdabot> http://tinyurl.com/yp6zsr
13:28:13 <faxathisia> You can get a more recent version from the repeo
13:28:16 <faxathisia> repo*
13:28:20 <HairyDude> yeah
13:28:42 <faxathisia> I'm only suggesting that because I managed to compile 2.1.3 with 6.8.2
13:29:03 <HairyDude> ok, seems 2.1.2 is still the latest stable version. will try darcs
13:30:59 <HairyDude> think I tried darcs first, but then tried the tarball because I couldn't find quickcheck 2 at first
13:31:09 <HairyDude> (but I have it now)
13:34:35 <litb> does xmonad work with gkrellm now?
13:34:51 <litb> s/does/is;s/work/working/ o.O
13:36:05 <tibbe> is there any articles about using a fold for traversing a collection to be had on the wiki? I can't find any
13:36:59 <HairyDude> woo, it works
13:37:13 <faxathisia> cool
13:37:17 <HairyDude> thanks
13:37:26 <wli> Okay, I can unwind out the inequalities to the point where what's left to do is backsubstitution.
13:37:49 <faxathisia> So I wish I could hack that mixfix parser out and hook it up with various lambda calcs
13:37:56 <faxathisia> That would be cool eh?
13:38:03 <faxathisia> (The Agda2 one)
13:38:08 <HairyDude> think I will start actually fiddling with it next week, when the lecturer actually starts teaching us some agda :)
13:38:30 <faxathisia> oh.. wow.. you actually have Agda classes? sounds like fun
13:39:19 <povman> Can any CPS-ify this: http://hpaste.org/5385
13:43:28 <Cale> Er, actually, this would work in the non-broken Cont monad.
13:44:02 <litb> oh ghc uses gcc somehow?
13:44:02 <slarba_> hmm. would it be possible to colorise haskell source code according to the allocation % of each expression from the heap profile?
13:44:12 <dons> huh
13:44:15 <dons> slarba_: interesting idea.
13:44:17 <Cale> (i.e. the one which requires higher-kinded quantification)
13:44:20 <dons> slarba_: talk to andyjgill
13:44:29 <dons> he's thought about this kind of thing in hpc
13:44:31 <Cale> Yeah, that, and related ideas are awesome :)
13:44:49 <thetallguy> Does anyone have a favorite naming convention for an @ value referring to a list?  That is,  foo (x:xs) = is common, but what do you put before the @ if you have foo xx@(x:xs) =?
13:45:05 <dons> good question
13:45:11 <dons> i use e@(x:xs)
13:45:17 <faxathisia> (x:xs)
13:45:17 <thetallguy> whey e?
13:45:19 * Japsu uses s@(x:xs)
13:45:22 <dons> expression
13:45:26 <dons> if b then e1 else e2
13:45:29 <gwern> why not 'l'l for lists?
13:45:33 <Japsu> usually it's s for string
13:45:35 <HairyDude> faxathisia: do you know Anton Setzer?
13:45:38 <litb> maybe xss@(x:xs)
13:45:38 <magnusth> l@(x:xs)
13:45:41 <Tac-Tics> list@(x:xs), descriptiveIdentifiersHelpCodeUnderstanding@(x:xs)
13:45:50 <thetallguy> litb: I've used xss before
13:45:56 <Cale> litb: xss is better for when you have something like (x:xs):xss
13:45:57 <faxathisia> No, I don't
13:46:06 <thetallguy> Tac-Tics: lol
13:46:09 <Cale> xxs maybe
13:46:10 <litb> ah i see
13:46:15 <Tac-Tics> what about xxs:(x:xs) (so that you can split xxs into x xs and put a colon in there...   !!)
13:46:15 <thetallguy> xat?
13:46:22 <litb> well, maybe xxx ?
13:46:24 <Tac-Tics> xxx@(sexy:singles)
13:46:24 <Cale> Tac-Tics: yeah
13:46:29 <Cale> heh
13:46:32 <Tac-Tics> =-P
13:46:52 <magnusth> is anyone using GHC on Windows? (besides Neil, maybe)
13:46:53 <thetallguy> so, the answer is, no concensus
13:47:05 <Cale> Name it whatever the heck you want :)
13:47:07 <litb> married@(single:waiters) o.O
13:47:10 <Cale> I like xxs
13:47:12 <HairyDude> he's one of the implementors, he's teaching this course
13:47:19 <faxathisia> cool!
13:47:21 <thetallguy> Cale; well, that's what I always do
13:47:36 <faxathisia> looks like there is interesting stuff on his site
13:47:44 <thetallguy> Cale: and I always ask the question ...
13:48:14 <povman> Cale: heh where do we find that?
13:48:24 <thetallguy> litb: funny.
13:48:27 <Cale> povman: find what?
13:49:48 <povman> Cale: Er, actually, this would work in the non-broken Cont monad.
13:50:18 <Cale> povman: ah... actually I don't know where to find it. Hang on, I'll see if I can :)
13:50:26 <cjb> out of curiosity, how many people here run GHC on Linux vs. OS X?
13:50:32 <povman> osx!
13:50:34 <Cale> (It used to be on the old Haskell wiki, perhaps it was copied over)
13:50:41 <Cale> ubuntu linux
13:50:50 <cjb> yeah, ubuntu here too.
13:50:51 <dons> openbsd!
13:51:03 <cjb> dons: :)
13:51:12 <magnusth> cjb: Debian
13:51:16 <piojo> arch linux here
13:51:22 <desegnis> Ubuntu. But even if everyone gives an answer, who will count them? :)
13:51:31 <davidL> @help poll-create
13:51:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:51:42 <magnusth> cjb: and recently finding a need to use it on Windows, in order to bring some sanity to the system
13:51:54 <davidL> @poll
13:51:54 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
13:52:01 <cjb> magnusth: to which system?  the Windows one?  :)
13:52:05 <hpaste>  wli annotated "beginnings of a Fourier-Motzkin solver" with "next step of Fourier-Motzkin" at http://hpaste.org/5381#a1
13:52:15 <cjb> oh, I didn't realize lambdabot had a poll.
13:52:17 <magnusth> cjb: yes, Debian is already a model of sanity :)
13:52:32 <errrick> huddhhg
13:52:36 <magnusth> cjb: Windows has a way of driving me crazy
13:52:42 <Cale> http://www.haskell.org/haskellwiki/MonadCont_done_right
13:52:43 <lambdabot> Title: MonadCont done right - HaskellWiki
13:53:24 <faxathisia> hehe .. is that a reference to a popular linear algebra book?
13:53:38 <desegnis> @poll-list
13:53:39 <lambdabot> []
13:53:58 <desegnis> A massively used feature.
13:54:04 <czShadoW> @help poll-add
13:54:04 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
13:54:16 <povman> Cale: thanks!
13:54:26 <Cale> Is that linear algebra book actually popular?
13:54:47 <Cale> (I suppose I know about it, so it must be at least somewhat popular.)
13:54:56 <gwern> @pl foo n = (\n -> (+) n)
13:54:56 <lambdabot> foo = const (+)
13:55:15 <wli> Which linear algebra book?
13:55:23 <Cale> Linear Algebra Done Right
13:55:41 * wli has doubts the book lives up to its name.
13:55:42 <Cale> I think it's somewhat of a crime to ignore the determinant though.
13:55:55 <meryrus> LADR is annoying for the reasons Cale mentions.
13:55:56 <frivol> Oh no, my linear algebra books must be done the other way.
13:56:40 <Cale> The author hates the determinant. Personally, I think the determinant is one of the most important functions in all mathematics.
13:56:40 <wli> If it ignores the determinant, it must not do much with Wronskians or McCoy's theorem.
13:57:11 <wli> Or the convergence theory of infinite determinants. ;)
13:57:22 <Cale> (Regardless of whether one really needs it in order to prove some fundamental results in linear algebra.)
13:57:31 <rekso> http://www.math.brown.edu/~treil/papers/LADW/LADW.html
13:57:31 <lambdabot> Title: Linear Algebra Done Wrong
13:58:16 <Cale> hahaha
13:58:39 <wagle_> http://www.axler.net/DwD.html
13:58:40 <lambdabot> Title: Down with Determinants!
13:58:56 <Cale> wagle_: yeah, I totally disagree with him on that.
13:58:59 <magnusth> "Don with Determinants"???
13:59:09 <Cale> magnusth: Down
13:59:24 <rekso> There was an interesting discussion of LADR on the n-category cafÃ©
13:59:43 <hpaste>  dolio annotated "(no title)" with "Cont" at http://hpaste.org/5385#a1
14:02:22 <Cale> oh, it appears that I'm silly :)
14:02:30 <Cale> (regarding the cont issue)
14:02:49 <dolio> Cont done right would be nice for shift/reset.
14:02:51 <tibbe> has any work been done on writing an incremental parsec?
14:02:57 <faxathisia> I have a question about type inference
14:03:05 <faxathisia> I am not sure how to put it,
14:03:30 <faxathisia> It seems like you can't solve type inference with a single unification step
14:03:51 <faxathisia> You have unify several times while traversing the structure of the code
14:04:22 <Cale> You should only have to do one traversal of the code though, I think.
14:04:40 <faxathisia> yeah one traversal, but unifying at each step
14:04:53 <faxathisia> I wrote two type inferers
14:05:25 <Cale> I think you only really have to unify at each let, unless I'm mistaken.
14:05:35 <faxathisia> One unifies while traversing (and can type flip id) the other unifies everything at the end, but can't type flip id
14:06:06 <faxathisia> oh I didn't use let yet
14:06:54 <Cale> What problem do you run into with typing flip id?
14:07:11 <Cale> Do flip and id type individually?
14:07:24 <faxathisia> I just get the type 'a' as an answer, and they do work individually
14:07:41 <phobes> sounds like a bug :)
14:07:52 <faxathisia> It feels like anything you could do in multiple unifications could be done in just one (since it's an MGU), so It's not clear if I have evidence otherwise or what I'm being confused by
14:07:59 <mauke> maybe you need to resolve 'a'
14:08:44 <Cale> I think something's gone wrong with your unifier...
14:09:29 <faxathisia> that's possible, but I've checked it over and over.. it seems ok, and can type fik
14:09:31 <faxathisia> fix*
14:09:33 * HairyDude has tried and failed to grok continuations on numerous occasions.
14:10:24 <Cale> HairyDude: I recently came up with a way of looking at them which works for me.
14:10:36 <Cale> (but it's kind of a strange thing :)
14:10:43 <phobes> faxathisia:  Does everything look right before you do the unification?
14:10:50 <faxathisia> phobes, yeah
14:11:03 <phobes> You should be able to look at the inputs to the unifier and decide "on paper" whether it "should work"
14:11:10 <faxathisia> :(
14:11:16 <phobes> if your inputs are right, and your output is wrong, the bug is in your unifier
14:11:23 <faxathisia> I've worked through it on paper 3 times
14:11:26 <Cale> HairyDude: It's possible to formalise ordinary logic using 4 axioms that only discuss the properties of implication.
14:11:37 <Cale> They are:
14:11:38 <phobes> What do you get as the inputs to the unifier?  It should be pretty simple, right?
14:11:48 <Cale> 1) from P and P -> Q, infer Q
14:11:53 <Cale> 2) P -> (Q -> P)
14:12:07 <rekso> 1 is a rule, not an axiom. :-)
14:12:11 <Cale> 3) (P -> (Q -> R)) -> ((P -> Q) -> (P -> R))
14:12:22 <Cale> 4) ((P -> Q) -> P) -> P
14:12:24 <rekso> I wondered why you said four rather than three!
14:12:31 <Cale> rekso: yes, okay :)
14:12:34 <HairyDude> so 1 should be (P -> Q) -> P -> Q
14:12:43 <phobes> hehe
14:12:47 <Cale> HairyDude: sort of :)
14:12:58 <Cale> 1 corresponds to function application
14:13:00 <faxathisia> 1 should be  flip id :P
14:13:12 <Cale> 2 corresponds to K
14:13:13 <hpaste>  dolio annotated "(no title)" with "delimited continuations" at http://hpaste.org/5385#a2
14:13:18 <Cale> 3 corresponds to S
14:13:25 <HairyDude> you can see them as types with Curry-Howard
14:13:29 <Cale> and 4, interestingly enough, seems like it can't be written.
14:13:42 <Cale> However, let's look at it closer.
14:13:57 <yaxu> ok, yi built now, thanks Cale et al
14:14:07 <Cale> It's saying "if you give me a function of type (P -> Q) -> P, then I will give you a P
14:14:10 <yaxu> it didn't take me that long, i was playing nethack in between
14:14:11 <rekso> 4 isn't even valid, according to my intuitionist friends.
14:14:15 <Cale> rekso: right
14:14:26 <Cale> Now, where could it get a value of type P?
14:14:33 * wli attempts to hammer out backsubstitution for Fourier-Motzkin.
14:14:36 <HairyDude> undefined? :)
14:14:39 <mauke> it has to call the function
14:14:42 <HairyDude> (j/k)
14:14:50 <Cale> Well, it would need something of type P -> Q to call the function it's given.
14:15:11 <Cale> Normally, it wouldn't have something like that...
14:15:31 <Cale> but, we can imagine the *rest of the program* as a function of type P -> Q
14:15:44 <gwern> @pl height w = 60 * ((fromPosReal w)**(1/3))
14:15:44 <lambdabot> height = (60 *) . (** (1 / 3)) . fromPosReal
14:15:50 <Cale> after all, it's going to take that value of type P returned here, and produce a value of some other type Q
14:16:15 <desegnis> @djinn ((p -> q) -> p) -> p
14:16:15 <lambdabot> -- f cannot be realized.
14:16:18 <HairyDude> brb... carry on explaining :)
14:16:40 <Cale> So if this thing (we might call it call/cc) was able to get hold of that, it could work.
14:17:00 <Cale> and indeed this is exactly what call/cc does.
14:17:37 <Cale> It takes the rest of the program, as a function of its own result to some other value, and applies the function it's given to that.
14:17:49 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
14:17:49 <lambdabot> f a b = a (\ c _ -> b c) b
14:18:17 <Cale> Of course, we normally have no way to say "the rest of the program" in Haskell, and so you need a monad to express that.
14:18:24 <rekso> mind you, I became suspicious of my intuitionist friends when they told me they weren't sure how many subsets a singleton set has
14:18:32 <Cale> rekso: haha
14:19:22 <rnorris> man, you guys are hardcore .. is there a channel for struggling beginners? i'm just trying to figure out why instance Monad (Either String) blows up
14:19:36 <dons> this is it! :)
14:19:38 <dons> we love beginners
14:19:48 * desegnis wonders what a monad would look like within propositional logic...
14:19:55 <dons> so the Either String instance should look like the standard one
14:19:57 <dons> for 'Error'
14:20:04 <rnorris> it tells me Illegal instance declaration for `Monad (Either String)'
14:20:04 <rnorris> 	(The instance type must be of form (T a b c)
14:20:04 <rnorris> 	 where T is not a synonym, and a,b,c are distinct type variables)
14:20:04 <rnorris>     In the instance declaration for `Monad (Either String)'
14:20:15 <mauke> rnorris: yeah, that's not valid Haskell98
14:20:19 <byorgey> rnorris: ah, you just need -fglasgow-exts
14:20:39 <Cale> Haskell98 is *really* picky about instance declarations.
14:20:41 <byorgey> FlexibleInstances, perhaps?
14:20:52 <Cale> Yeah -XFlexibleInstances should work, I think
14:21:09 <rekso> desegnis: A logical modality is a *co*monad
14:21:13 <Cale> Or, of course, {-# LANGUAGE FlexibleInstances #-} in your source file.
14:21:43 <rnorris> yep, -fglasgow-exts worked. thanks guys
14:21:54 <yaxu> Is there an official way to pronounce 'Yi' ?
14:21:59 <faxathisia> Does anyone have (or know the existence of) a STLC type inferer which does a single unification?
14:22:00 <dons> like 'we'
14:22:04 <dons> or 'vee'
14:22:14 <rekso> desegnis: So I suppose the dual modality (i.e. diamond rather than box) is a monad.
14:22:15 <Cale> rekso: Are you sure it's always a comonad?
14:22:17 <desegnis> rekso, no use explaining now. it's 23:22 here. well that's not /that/ late, but still...
14:22:30 <Cale> Yeah, there are monadic modalities.
14:24:25 <gbacon> is cabal-install worth the trouble?
14:24:27 <byorgey> dons: really?
14:24:30 <Cale> faxathisia: Remember that when you unify your set of equations, you want the most structured result.
14:24:43 <byorgey> gbacon: what trouble?
14:24:56 <quicksilver> dons: does hmp3 read the id3 tags? or does it ask mpg123 to do that for it? I browsed the source but didn't find the right bit.
14:24:57 <Cale> faxathisia: It might be that you're picking some other type variable which is actually related to others? I don't know.
14:25:01 <gbacon> byorgey: chasing dependencies to get it built
14:25:05 <rekso> Cale: no, I'm not sure. I expect people study modalities that aren't (co)monads, but then what do you expect from philosophers. ;-)
14:25:07 <faxathisia> I'm not sure how that comes into it, There is only a single MGU
14:25:18 <phobes> faxathisia:  If you mean by "one unification" that it accumulates all of the constraints and then solves at the end - sure that should be possible
14:25:25 <byorgey> gbacon: well, think of it this way: those are the last dependencies you'll ever have to chase. =)
14:25:48 <gbacon> byorgey: so it's fairly reliable?
14:25:48 <Cale> rekso: anything satisfying K is a functor
14:25:50 <faxathisia> phobes, I can see no reason for it not being impossible.. It just doesn't work
14:26:12 <byorgey> gbacon: in my experience, yes, although there are still some rough edges of course
14:26:18 <Cale> rekso: and anything satisfying N is pointed (has return)
14:26:41 <phobes> faxathisia:  What are the type variables and constraints you end up with before unification?
14:27:11 <phobes> (on flip id)
14:28:11 <Cale> I guess it's the converse of 4 together with K and N which gives you a monad.
14:28:41 <phobes> :t flip
14:28:42 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:28:44 <phobes> :t id
14:28:44 <lambdabot> forall a. a -> a
14:28:58 <rekso> Cale: I think an S4 modality is a comonad
14:29:16 <rekso> (and the dual is a monad, of course)
14:29:30 <phobes> faxathisia:  When you apply flip to id, you should end up with (renaming the 'a in id to 'd) d = a -> b -> c, right?
14:29:45 <Cale> rekso: it's a little too strong.
14:30:08 <rekso> too strong for what?
14:30:13 <Cale> rekso: you have  a -> m a, which not all comonads have.
14:30:28 <faxathisia> Yeah, I think so
14:30:33 <hpaste>  faxathisia pasted "flip id equations" at http://hpaste.org/5388
14:30:33 <Cale> er...
14:30:43 <Cale> hmm
14:30:44 <rekso> Cale: you do?
14:30:50 <yaxu> hm, Yi isn't reading my ~/.yi/YiConfig.hs .  If I do yi --as=emacs it starts with those keybindings and works but M-x reconfigE gives me "execEditorAction: Not supported"
14:31:01 <faxathisia> ::: means has type and :=: is equality
14:31:12 <Cale> rekso: well, you have N, right?
14:32:16 <rekso> Cale: you mean the rule that if A is a theorem then \box A is a theorem?
14:32:36 <Cale> yeah
14:32:37 <byorgey> yaxu: which version of yi is this?
14:32:47 <yaxu> byorgey: 0.3
14:32:47 <Cale> I suppose that's not the same as A -> [] A
14:32:47 <olsner> is there a strict writer monad?
14:33:16 <byorgey> yaxu: try reconfigEditor
14:33:45 <yaxu> byorgey: same
14:33:57 <byorgey> yaxu: hm, I don't know then =P
14:34:08 <phobes> faxathisia: hmm, why is '(\o -> o)' given two types, t2 and t4?
14:34:24 <byorgey> yaxu: seems like it got compiled without support for something so it can't do the dynamic evaluation stuff (?)
14:35:06 <Cale> But I'm not enough of a logician to fully understand the difference. The rule seems more of a 'meta' thing -- you still might not be able to get a proof of A -> [] A, even though it's actually true.
14:35:29 <rekso> Cale: right; but I think you do need a map 1 -> [] 1
14:35:33 <olsner> I replaced an IO calculation with putStr into tell on a writer monad, and now I have hideous space leaks
14:35:58 <yaxu> byorgey: hm, couldn't see any relevant build warnings
14:35:58 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer-Strict.html
14:35:59 <lambdabot> http://tinyurl.com/2yg2ou
14:36:43 <phobes> faxathisia:  I think your constraint generation might be the problem... at least I don't understand it
14:36:45 <rekso> Cale: well, in terms of the category, a proof of A is a map 1 -> A. So you need a way to turn maps 1 -> A into maps 1 -> [] A. The obvious way is to hit the map with box, and then compose with your 1 -> [] 1
14:37:33 <phobes> faxathisia:  When you generate multiple types for things, is your unifier smart enough to identify (merge) the duplicates?
14:37:37 <Cale> rekso: right
14:37:47 <faxathisia> Yes it is
14:38:39 <faxathisia> I think I should start again and try with LogicT
14:38:41 <phobes> faxathisia:  Why do you do it that way?  (If you don't mind my asking)  I would have expected to see one type variable per term and :=: be the only source of unification
14:39:30 <rekso> Have any of the haskell people read Hyland and Power's paper about why algebraic theories are better than monads, I wonder
14:40:16 <dons> sounds fun
14:40:33 <faxathisia> phobes, I take an AST and annotate each part with types, then extract equations from it (as well as the typing of some terms), and then split the annotated AST into ::: things
14:40:59 <faxathisia> So that way is quite simple to code and I just let unification clear up the mess
14:41:18 * HairyDude reads all this discussion about comonads, and wonders why he thought he was au fait with category theory.
14:41:25 <wagle_> <movement> http://img128.imageshack.us/img128/210/imag0016bwr2.jpg
14:41:42 <Philippa> rekso: "The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads"? Got a free and legal link to it?
14:41:55 <cjb> wagle_: I saw a KDE4 CD with a very similar logo.
14:41:58 <rekso> Philippa: yes and no, in that order
14:42:58 <phobes> Good, that's the right order!
14:43:19 <rekso> Though I'll gladly send a copy to anyone who asks me
14:44:11 * Philippa points out that this chan is logged publically and that people should be careful of offering to commit what are at least in some jurisdictions crimes in here
14:45:02 <phobes> I wonder how much trouble you can get in for conspiracy to commit copyright violation?
14:45:30 * HairyDude wonders how profitable academic journals are.
14:45:31 * rekso shrugs. They can sue me if they like. I very much doubt the authors would object, and I don't mind upsetting Elsevier.
14:45:34 <znutar> They'd probably conspire to give you a stern talking to
14:47:49 <RayNbow> hmm
14:47:55 <RayNbow> that paper is available at acm
14:48:02 <RayNbow> oh, it isn't
14:48:27 <phobes> faxathisia:  I still don't get why you'd issue new typenames for some of the terms.  Annotate each (sub)term with types implies you keep the annoations, right?
14:48:30 <eugman|work> Despite constantly jumping around from idea to idea I've decidedy suggestions about what i sh to do a Text adventure assuming the idea doesn't get rejected.  Any suggestions on what I need to look up in order to be able to do state control? As far as I can tell that's going to be the toughest part. Zippers seemed to be something important.
14:49:01 <eugman|work> Woah, that first sentence got messed up badly.
14:49:06 <faxathisia> Yeah.. I annotate, extract some equations then unfold the thing
14:49:24 <RayNbow> hmmz, ScienceDirect... I wonder if I can access that through VPN...
14:49:30 <thetallguy> docket
14:50:44 <wli> Backsubstitution doesn't work quite the same way in Fourier-Motzkin.
14:52:00 <wli> The system alone isn't enough.
14:52:32 <gbacon> cabal wants to install under $HOME/.ghc, but doesn't it also register by default?
14:52:43 <gbacon> i.e., if I see it in ghc-pkg's output, it's registered, correct?
14:53:36 <RayNbow> yay
14:53:40 <RayNbow> access to the PDF \o/
14:53:45 <gbacon> I've installed hxt with cabal, but Setup configure is saying it can't find hxt
14:54:09 * RayNbow just had to modify his VPN shortcut though... username and password were outdated :p
14:54:56 <RayNbow> anyone interested in a copy?
14:56:57 <povman> yes, please post your username and password.
14:57:25 <ehird`> i hope i never release a monad library
14:57:28 <ehird`> i'd have to call it Monadmonad
14:57:38 <RayNbow> there's no way I'd post my username and password ;)
14:57:43 <wli> Not 100% sure what an answer should look like.
14:57:44 <dolio> How's the Arc clone coming?
14:57:54 <ehird`> dolio: beats me
14:57:54 <Cin> it's not, apparently
14:57:59 <ehird`> haha
14:58:00 <dolio> Heh.
14:58:01 <ehird`> gobby people gave up?
14:58:05 <phobes> faxathisia:  I dunno... good luck
14:58:11 <ehird`> the darcs lives on, though needs extra activity ;)
14:58:13 <Cin> must've lost interest
14:58:59 <Ben`> is it possible to define datatypes directly in GHCi?
14:59:02 <ehird`> see? quick'n'dirty editing = incompletion!
14:59:05 <ehird`> darcs rules the land!
14:59:08 <phobes> faxathisia:  I think you could write this as 'data Constraint = ConstraintEq Int Int | ConstraintFun Int Int Int'
14:59:30 <phobes> faxathisia:  and then have something of sig 'unify :: Term -> (Int, [Constraint])'
14:59:59 <faxathisia> What does an Int mean?
15:00:10 <phobes> faxathisia: Type variable index
15:00:29 <phobes> faxathisia:  On the constraints
15:00:41 <phobes> faxathisia:  On unify, the first of the pair is the number of type variables
15:01:11 <phobes> faxathisia:  And you adopt a convention that the type variable corresponding to the whole term is always the 0th integer (say)
15:01:19 <ehird`> we need PHPmonad! it lets you combine haskell and PHP. it either makes PHP statically typed with type inferrence and monads or the other way around, depending on how evil it's feeling today
15:02:12 <phobes> faxathisia:  bye, good luck
15:02:21 <faxathisia> see you, thanks
15:04:04 <ehird`> hm, possibly stupid question
15:04:22 <ehird`> what should i use where i would use a lisp symbol? that is, a name for something, as a function argument
15:04:27 <ehird`> right now i'm doing strings.
15:05:16 <faxathisia> You can use strings
15:05:31 <TuringTest> ehird`:  what abou an enum ? "data Options = BlueThing | BigArg | Symbol'with'long'name
15:05:31 <faxathisia> Another thing is  data Symbols = Foo | Bar | Baz
15:05:32 <cdsmithus> ehird`: Clarify the context?  Is there a particular set of symbols that you might expect?  How are you using it?
15:05:43 <ehird`> cdsmithus: arbitary
15:05:44 <yaxu> should yi auto complete a list of possible operations when i do M-x <tab> ?
15:05:53 <faxathisia> yeah, you can derive Enum and such with it
15:06:42 <ehird`> faxathisia: arbitary name
15:06:55 <cdsmithus> ehird`: Then yeah, a string might work; or you might newtype something to wrap a String.
15:06:59 <faxathisia> Then I think you intuition was right on
15:07:04 <faxathisia> your*
15:12:46 <Zee> http://bux.to/?r=ZeeYPeeWee <<<--- visit / register . click on the links / and earn a lot of money, you may earn more than 300 USD / month, i did earn more !!! register now
15:12:47 <lambdabot> Title: Bux.to | .view .click .make money
15:13:02 <Valodim> ...anyone?
15:13:29 --- mode: ChanServ set +o dons
15:13:41 --- mode: ChanServ set -o dons
15:14:49 <ddarius> @users
15:14:49 <lambdabot> Maximum users seen in #haskell: 463, currently: 436 (94.2%), active: 20 (4.6%)
15:17:45 <Botje> if you want to fuck that Zee person's account:
15:18:00 <Botje> send a mail to bux.domain@gmail.com
15:18:03 <Botje> and tell them what happened
15:18:20 <Botje> just c/p the log in there and send it
15:18:32 <Botje> fight back at the spammers!
15:22:20 <ehird`> Hmm. Is a Markov chain a monad?
15:23:22 <LoganCapaldo> what's join and what's map and what's unit?
15:23:46 <Valodim> ...ask hoogle?
15:24:04 <ehird`> LoganCapaldo: Good point.
15:24:07 <LoganCapaldo> i don't think @hoogle Markov Chain is gonna work
15:24:24 <Valodim> oh it was an answer. sry didn't see the context
15:24:24 <ehird`> Still, I figured if something as 'intuitively' non-monadic as lists could be monads, maybe a markov chain could be too
15:24:26 <ehird`> :-)
15:24:52 <Valodim> haha, had already been wondering why you asked such a thing :P
15:24:52 <Botje> you need to keep state, so worst case it's a variant of State
15:24:52 <Valodim> everything and its mother is a monad in haskell
15:25:13 <ehird`> Botje: hardly
15:25:24 <ehird`> you need only one state to generate the next
15:25:39 <LoganCapaldo> well wait
15:25:45 <ehird`> i'd say that's pretty stateless, not entirely, but its not as if you're hauling aroudn tons of crap
15:25:56 <ehird`> I mean, I think 'bind' should be pretty simple
15:26:03 <Botje> write it! ;)
15:26:21 <LoganCapaldo> is the question "are markov chains monads" or "can you implement markov chains with a monad inhaskell"?
15:26:27 <ehird`> LoganCapaldo: the former, i guess
15:26:33 <pjd> Valodim: everything and its mother is a monad in other languages too, they just haven't realized it yet
15:26:48 <LoganCapaldo> I mean I don't know the answer :)
15:26:59 <Valodim> they probably never will
15:27:06 <LoganCapaldo> but knowing the exact question affects that
15:27:39 <pjd> well, s/realized/formalized/, anyway
15:28:20 <lament> Are bats bugs?
15:28:22 <LoganCapaldo> if everything and it's mother really was a monad, we wouldn't have Arrow and junk
15:28:45 <augustss> are bats monads?
15:28:51 <LoganCapaldo> i hope so
15:29:21 <lament> Are cascading style sheets monads?
15:29:22 <dons> vampire bats are
15:29:30 <dons> they're the runVampire function
15:29:40 <ehird`> well, this is a productive discussion
15:29:40 <ehird`> ;)
15:29:48 <dons> and once you're a vampire, you can only unsafeStabInHeart to get a normal value out
15:29:49 <LoganCapaldo> runVampire, or run! Vampire!
15:30:07 <dons> zombies are a monad too
15:30:11 <Botje> :)
15:30:15 <Botje> Zombie BRAINS!
15:30:23 <Saizan> from the "Advanced Bash Scripting Guide": "Most short scripts work right the first time, and debugging even the longer ones is straightforward." wtf?
15:30:23 <Botje> that's probably !BRAINS
15:30:24 <Botje> oh well
15:30:26 <LoganCapaldo> unsafeReanimateIO
15:30:45 <LoganCapaldo> Saizan: stop spreading lies
15:31:04 <olsner> @quote debugging
15:31:04 <lambdabot> YHC says: There is currently no debugging system available. Please write correct programs.
15:31:12 <olsner> @quote debugging
15:31:13 <lambdabot> lennart says: the best way of debugging is to understand your code
15:31:21 <olsner> @quote debugging
15:31:21 <lambdabot> lennart says: the best way of debugging is to understand your code
15:31:27 <Philippa> ehird`: big rule about spotting monads - forget about state
15:31:43 <Philippa> well okay, there is one sensible way of looking at them via state, but it's not what you'd expect at all
15:32:29 <ehird`> (question: right now i'm possibly reinventing a standard library. I have a list of [(a,Double)] and want to pick a random a, weighted by the double. is there a standard way to do this?)
15:32:51 <Philippa> ("can I picture a virtual machine for a language that looks suspiciously like a monad's signiature that would use one of these as its state?" - lo and behold, lists = non-determinism)
15:32:58 <shapr> cjb: Doesn't look like I'll make it today.
15:33:27 <Philippa> ehird`: not currently
15:34:01 <cjb> shapr: aww, ok.
15:34:02 <ehird`> Philippa: any relatively concise way to express it?
15:34:36 <Philippa> er. I could draw you a diagram. But you're better off getting someone else to draw it because then you'd actually be able to read it
15:34:55 <Philippa> for "virtual machine" read "runMonad function" though, if that helps
15:35:11 <ehird`> i meant re: not currently
15:35:12 <ehird`> ;)
15:37:06 <ehird`> :)
15:37:16 <Philippa> sorry. My first pass'd go sum the doubles, grab a number from a PRNG and scale appropriately, walk the list summing the doubles 'til you hit the appropriate point to yank the value out. Relevant calls in Data.List, System.Random
15:37:40 <Philippa> if you're going to need to do it a lot with the same list, turn it into a tree instead
15:38:21 <HairyDude> yay, agda2 mode works with viper... or seems to
15:38:40 <Philippa> you could use one of the scan funcs to build a function that returns the list of sums-to-this-point, too
15:39:06 <ehird`> Philippa: actually, i can replace the double with an Integer
15:39:08 <ehird`> where higher=better
15:39:11 <ehird`> does that simplify things?
15:40:15 <olsner> > let transpose xs = if all null xs then [] else map head xs : transpose (map tail xs) in transpose [[1,2,3],[4,5,6]]
15:40:16 <lambdabot>  [[1,4],[2,5],[3,6]]
15:40:35 <Philippa> not unless you've already got it to the point where you're just doing a key,value lookup
15:40:48 <ehird`> Philippa: hmm
15:40:52 <ehird`> i don't quite udnerstand, but i think no
15:41:54 <ehird`> my crappy first idea:
15:42:12 <ehird`> generate a new list, with (a,b) translated to a, b times.
15:42:13 <Philippa> okay. Start with cumulatives l = scanl (+) 0 l ...
15:42:21 <Philippa> yeah, you can do that
15:42:27 <ehird`> then, pick a random number from 0 to the length of the list, minus one of course.
15:42:30 <ehird`> then access that element.
15:42:41 <Philippa> and in the long run, if the space usage is worth it then it might be worthwhile because you can use Data.Map rather than a List
15:42:43 <ehird`> possibly there is already a rand-element-of-list though
15:42:50 <Philippa> nope
15:43:18 <ricky_clarkson> There's a fun way of choosing an element at random from a list without knowing the length of the list in advance.
15:43:28 <ricky_clarkson> No, really, it is fun.
15:43:47 <ehird`> ricky_clarkson: Yes, yes, that one. :P
15:44:04 <ricky_clarkson> There's a wikipedia page on it, but I don't recall the name of the algorithm.
15:44:40 <Philippa> ...oh, wait, cumulatives drops the value
15:45:04 <ehird`> hm making markov chains a monad is probably pretty required
15:45:06 <ehird`> to get random numbers.
15:45:26 <yaxu> after some upgrading, Yi is working nicely
15:45:37 <vincenz> ehird`: how's it going
15:45:45 <ehird`> vincenz: good
15:45:51 <ehird`> i see the arc-alike in gobby died
15:45:54 <ehird`> i prevail again ;)
15:45:56 <vincenz> yeah
15:45:59 <vincenz> ehird`: why is this a competition?
15:46:06 <ehird`> vincenz: it isn't, i'm just being silly :)
15:46:14 <ehird`> AND BECAUSE MY DARCS IS SO MUCH BETTER
15:46:16 <ehird`> i mean, uh.
15:46:46 <sm> steady..
15:46:52 <Philippa> ehird`: write the equivalent of cumulatives for your type, then use Data.List.find
15:47:11 <Philippa> find the first total that's bigger than the result from your PRNG
15:47:17 <Philippa> that do you?
15:48:39 <litb> is Yi working?
15:49:01 <litb> i wonder whether it can already do syntax hilighting
15:49:53 <nelhage> I've built GHC 6.8.2, and now yi still isn't building ... Could not find module `Data.ByteString': it is a member of package bytestring-0.9.0.1, which is hidden
15:49:55 <dolio> litb: http://haskell.org/sitewiki/images/0/0f/Yi-20070409.png
15:50:14 <litb> oh sweet
15:50:21 <litb> does it look much different atm?
15:50:28 <nelhage> That's cabal-install attempting to install vty
15:50:54 <dolio> litb: dons posted that for the 0.3 release, so that's probably pretty current.
15:50:57 <litb> what font is that one using, dolio ?
15:51:08 <litb> looks like consolas
15:51:13 <alexj_> @seen igloo
15:51:13 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 7h 47m 50s ago.
15:51:16 <litb> oh no
15:51:37 <litb> i'm looking forward to try it
15:52:14 <litb> how many percent is haskell, and how many is C?
15:52:21 <litb> (i mean semantically, not LOC)
15:52:57 <dolio> C?
15:53:06 <gwern> litb: yi can do syntax highlighting fine
15:53:39 <dolio> Why would it need C?
15:53:58 <gwern> the code doesn't seem any worse than the emacs highlighting code I've seen, anyway
15:54:34 <ehird`> litb: 0% c
15:54:41 <ehird`> unless you count gtk2hs code :)
15:54:45 <ehird`> or ghc runtime code!
15:55:52 <litb> ah i see
15:56:13 <litb> nice. i suppose there are no major modes other than haskell at the moment?
15:57:31 <gwern> cabal, latex, c++, haskell, and literate haskell
15:57:32 <ricky_clarkson> Is writing code for Yi nicer than writing code for emacs, other than the fact you're not using elisp?
15:57:41 <litb> oh great
15:57:46 <gwern> and a Srmc.x, whatever the heck that does
15:57:46 <ricky_clarkson> ..I mean, is it better-written?
15:57:53 <litb> will it have support for multiple fontlocks in the same buffer?
15:58:11 <litb> so for example in literate haskell to hilight the latex code and the haskell code at the same time?
15:58:12 <eugman|work> Isn't latex just one of the two forms of literate haskell?
15:58:31 <nelhage> Any advice on getting vty to build?
15:59:00 <litb> we should make font-lock a minor mode. and combine font-locking in some natural way
15:59:33 <ehird`> nah
15:59:38 <ehird`> font-locking is pretty primitive stuff
15:59:39 <ricky_clarkson> font-lock combinators!
15:59:43 <ehird`> there's no reasonable way not to have it global
15:59:49 <litb> i mean, font-lock-haskell is a minor mode, and font-lock-latex too. and each font-lock mode has a list of compatible font-lock modes that it can work in pair with
16:00:09 <litb> so if you for example write an xml document, you could have font-lock-xml and font-lock-svg , both at the same time
16:00:18 <ehird`> no point
16:00:26 <ehird`> just have svg-mode extend xml-mode
16:00:57 <litb> oh that is possible? nice indeed
16:00:58 <gwern> nelhage: why bother with vty? it's fairly buggy
16:01:12 <nelhage> gwern: Because cabal seems to want it when I ask it to install yi
16:01:23 <nelhage> Is `cabal install yi' not the incant I want?
16:01:55 <litb> will yi work on non-X too?
16:02:00 <gwern> nelhage: oh. nm, then. shouldn't cabal install track down that dependency for you?
16:02:16 <ehird`> actualyl you'd have xml-mode embedding svg-mode
16:02:19 <litb> i think it will be largely emacs compatible. from the screeny i've seen that looks much the same as the current emacs
16:02:22 <ehird`> with that wondrous mode embedding stuff
16:02:25 <ehird`> 'cause of multiple dtd stuff
16:02:28 <litb> s/as/like/
16:02:41 <ehird`> i really need to get working on my haskell editor sometimes
16:02:49 <ehird`> only... Editormonad sounsd kind of lame
16:02:50 <ehird`> :P
16:03:11 <ricky_clarkson> monedit
16:03:15 <gwern> emonad is better. you can use emonad to hack on xmonad
16:04:13 <Saul_> Monaditor
16:04:24 <Valodim> lambditor
16:04:26 <litb> nah, hmonad . emonad sounds much like emacsmonad =)
16:05:07 <ricky_clarkson> lemonade
16:05:31 <gwern> demonad
16:05:38 <gwern> demonad, she is undoable, eh?
16:05:42 <nelhage> gwern: cabal install yi attempts to build vty, which then fails
16:06:02 <gwern> with?
16:06:21 <nelhage> http://paste.husk.org/10820
16:08:28 <piojo> wanna go eat?
16:08:44 <piojo> oops
16:08:56 <piojo> i'm on gaim, and thought this was my chat window! sorry
16:09:09 <gwern> nelhage: interesting. the hackage one doesn't declare its dependency on bytestring
16:09:11 <Saizan> nelhage: yi is not that simple to build afaik
16:09:39 <Saizan> ?go yi building guide
16:09:43 <lambdabot> http://www.streetdirectory.com/stock_images/travel/preview/11048348073592/61837/yi_guang_factory_building/
16:09:43 <lambdabot> Title: Asia Travel : Singapore Image of Yi Guang Factory Building
16:09:53 <Saizan> not that..
16:09:58 <gwern> ah, vty's hackage release is outdated
16:10:14 <gwern> the patch that adds support for 6.8.x's split-base stuff comes after it was tagged 3.0.0
16:11:00 <gwern> nelhage: either install vty from darcs or edit the tarball and add bytestring to the cabal file
16:11:56 <gwern> or failing that, edit the yi tarball's cabal file and set the vty flag to false
16:13:29 <Daveman> chessguy :)
16:13:37 <chessguy> 'evening
16:13:39 * gwern emails vty's maintainer about this
16:13:49 <nelhage> Thanks.
16:14:00 <nelhage> Editing the tarball fixed it.
16:14:23 <nelhage> new error: setup: alex version >=2.0.1&&<3 is required but it could not be found.
16:14:51 * gwern guesses alex is not installed :)
16:15:01 <nelhage> What _is_ alex? :)
16:15:28 <gwern> dunno. it has to do with parsing, or 'lexing'. cs stuff necessary for the syntax highlighting
16:15:49 <nelhage> Interesting, `cabal install alex' seems to be working. Is yi not declaring that dependency?
16:15:54 <gwern> (it borks my builds and patches to yi pretty often though, so I dislike it even without knowing what it does)
16:16:25 <gwern> nelhage: it's declared as part of the 'build-tools' field. I have no idea whether cabal install follows those dependencies
16:20:42 <vincenz> ehird`: latest changes in repo?
16:21:04 <ehird`> vincenz: beats me, i fscked it up by adding iorefs to some stuff so it needs some rethinking
16:21:06 <ehird`> no big shakes
16:21:41 <sm> are there any good podcasts which cover haskell ?
16:21:45 <vincenz> ehird`: I did say that :)
16:21:50 <ehird`> :D
16:22:35 <vincenz> ehird`: wanna open in gobby and discuss?
16:22:39 <vincenz> ehird`: show you the alternative ?
16:22:43 <vincenz> that we were looking at
16:22:46 <vincenz> discuss pros + cons
16:22:52 <Cale> sm: You mean video or audio files?
16:23:20 <sm> either, audio is a little more practical
16:23:35 * sm is poking around the wiki 
16:23:52 <Cale> http://www.haskell.org/haskellwiki/Video_presentations
16:23:53 <lambdabot> Title: Video presentations - HaskellWiki
16:24:23 <vincenz> ehird`: ?
16:25:19 <Cale> (A Taste of Haskell in particular is a good intro to what Haskell is about, without really getting into details.)
16:25:27 <ehird`> vincenz: I don't have gobby and can't have it.
16:25:35 <ehird`> I am tired of saying that time after time, also.
16:25:51 <vincenz> 'can't have it'?
16:26:00 <vincenz> ehird`: it's hard to discuss something without having the code in front.
16:26:08 * sm browses http://reddit.com/r/programming/info/5ztsd/comments/ 
16:26:10 <ehird`> vincenz: paste it somewhere
16:26:42 <radix> hmm. for some reason I was under the impression that unicode encoding and decoding was standard, but I can't find it. Are functions for decoding and encoding the common encodings included in GHCI?
16:26:44 <radix> err, GHC
16:26:56 * vincenz shrugs
16:27:08 <ddarius> No, but there are libraries for it on hackage
16:27:33 <Cin> ehird`: can i has darcs write access?
16:27:55 <ehird`> Cin: as soon as i get back on my main machine,with actual TOOLS that i can use.. ;)
16:28:15 <Cin> ehird`: oki
16:28:23 <radix> ddarius: ahh. "encoding" looks very promising
16:28:36 <ehird`> Cin: (Which will be..sometime other than today. Well. It's after midnight. So MAYBE today!)
16:28:57 <Cin> ehird`: you're in the UK too? ^_^
16:29:04 <ehird`> Cin: yes
16:29:20 <radix> hah!! and the web page for the encoding package on hackage is hilarious. The author's name is misencoded :P
16:29:39 <ehird`> Cin: heh, you're in #arc. brain melted yet?
16:30:00 <ehird`> i find talking to people who like arc quite the hard task!
16:30:08 <Cin> ehird`: i'm in there with clinical interest
16:30:33 <ehird`> Cin: the most fun thing is that we have to implement #f, () AND nil
16:30:39 <Cin> ehird`: ie to see what the "community" is like, and persons' perceptions of it
16:30:41 <ehird`> and '() -> nil
16:30:42 <Cin> ehird`: haha, yeah
16:30:55 <ehird`> and (is () nil), but not (is () #f)
16:30:56 <Cin> ehird`: what is this nonsense!? *throws down and steps on*
16:30:57 <ehird`> (iirc)
16:30:58 <nelhage> Are they all distinguishable in arc?
16:31:12 <ehird`> nelhage: i don't think youcan distinguish () and '(), but the prettyprinter does
16:31:15 <ehird`> so: quite possibly
16:31:20 <ehird`> i just haven't found a way yet.
16:31:24 <nelhage> urgh
16:31:32 <Cale> The prettyprinter sucks though.
16:31:45 <Cale> Try constructing a cons and then setting its cdr to itself.
16:32:06 <Cale> The prettyprinter chokes hard on that, consuming unlimited amounts of memory without printing anything.
16:32:26 <Cale> The value itself is fine though, and can be used normally.
16:32:42 <ehird`> Cale: it's mzschemes pretty printer
16:32:47 <ehird`> because writing code sucks! ;)
16:32:48 <Cale> No it's not.
16:32:55 <Cale> mzscheme handles it fine.
16:33:03 <ehird`> hm, well it is mzscheme's
16:33:09 <Cin> arc must use PRINTF or something
16:33:21 <Cin> which may be different
16:33:54 <litb> hm, what's the point of showsPrec?
16:34:09 <ehird`> http://arclanguage.org/item?id=336
16:34:10 <lambdabot> Title: Arc Forum | Arc, a Comedy of Errors: Part I
16:35:11 <Cale> litb: printing expressions with the right number of parens
16:36:56 <ehird`> webmonad will be far more awesome than arc's gui lib! ;)
16:37:01 <ehird`> once i get round to actually writing it. that is.
16:37:14 <nelhage> Please do, I really want to write webapps in haskell :)
16:37:26 <nelhage> And I know other people who do. But we're all terrified of HAppS :)
16:37:55 <alexj_> nelhage: just got state basically locked down.
16:38:22 <ehird`> nelhage: indeed
16:38:22 <alexj_> the story is going to get much less terrifying soon
16:38:39 <ehird`> hopefully i'm going to add some continuations-based stuff too
16:38:41 <ehird`> optional, of course.
16:38:51 <ehird`> but i think it can improve interaction and development in many cases.
16:39:09 <nelhage> I'm in favor of continuations in web frameworks in moderation :)
16:39:12 <alexj_> ehird: whats in webmonad?
16:39:26 <Cale> ehird`: Have you seen Shriram's video on continuation based web stuff?
16:39:27 <ehird`> alexj_: a monad called Web
16:39:29 <ehird`> and some other stuff.
16:39:33 <ehird`> Cale: nope. summary?
16:39:36 <vincenz> ehird`: it's pathetic
16:39:44 <ehird`> vincenz: define pathetic
16:39:50 <alexj_> ehird: happs has something similar.  not doing continuations right now.
16:39:57 <Cale> http://www.cs.brown.edu/~sk/Publications/Talks/ProgInterWeb/
16:39:58 <lambdabot> Title: Shriram Krishnamurthi: Talk: Programming the Interactive Web
16:40:06 <vincenz> ehird`: "I've left superficial semantic issues like this, instead I focussed on the syntactical ones"
16:40:07 <ehird`> alexj_: i'm certainly not competing with happs ;)
16:40:16 <LoganCapaldo> Charlotte's Monad
16:40:21 <alexj_> ehird: well I would like happs to take in new ideas wherever.
16:40:21 <ehird`> vincenz: oh, arc
16:40:23 <ehird`> yes indeed
16:40:26 <alexj_> contribute to happs?
16:40:48 <ehird`> alexj_: happs just kind of scares me. :) i just don't think it fits with my general (minimalistic) mental model of the web
16:40:58 <ehird`> you are, of course, welcome to take anything from webmonad once it's released
16:41:02 <LoganCapaldo> I'
16:41:03 <ehird`> [well, depends on your license i guess]
16:41:15 <LoganCapaldo> *I'm pretty sure I just don't "get" HAppS
16:41:27 <LoganCapaldo> someday I will and I'll be like "ooooooooo"
16:41:28 <alexj_> ehird: license is bsd
16:41:50 <alexj_> logancapaldo: lets talk about confusion.  how can I help?
16:41:50 <ehird`> alexj_: then you should be fine taking from my MIT licensed webmonad
16:41:54 <ehird`> hm, might be bsd, depends
16:42:14 <alexj_> not big on understanding licensing.  it all seems very confusing.
16:42:17 <alexj_> mit vs bsd vs whatever.
16:43:09 <ehird`> yes. i think with the mit you just have to stick my LICENSE file in the file where you stole my stuff from.
16:43:25 <alexj_> ok.  seems like a pain.
16:43:31 <ehird`> every license has that
16:43:37 <ehird`> otherwise they wouldn't be particularly useful
16:44:14 <alexj_> ok I know there are obscure differences betweeen bsd3 bsd4 mit and apache, but I don't really understand the differences well enough to have a position other than whatever is easier to use.
16:45:00 * trav1085 has just sent you can IRC email! Type '/server mail' (no quotes!) to see your inbox!
16:45:15 <ehird`> trav1085: because #haskell will fall for that
16:45:22 <ehird`> alexj_: same with all of them i think
16:45:24 <ehird`> well -- apart from bsd4
16:45:27 <ehird`> but nobody uses bsd4
16:45:29 <Botje> /server mail
16:45:35 <trav1085> Whoa
16:45:36 <Botje> trav1085: where's my mail?
16:45:37 <trav1085> Nvm
16:45:40 <trav1085> I know how you did that
16:45:44 <trav1085> /server mail
16:45:47 <tomaw> trav1085: stop.
16:45:48 <trav1085> You just did two //
16:45:51 <Botje> trav1085: I WANT MY MAIL.
16:45:58 <sm> I think leaders of successful community sw projects need to know licenses
16:45:58 <trav1085> Don't tyhpe with two slashes
16:46:15 <ehird`> trav1085: Stop being annoying. We're not idiots.
16:46:15 <trav1085> tomaw: NO U
16:46:16 <tomaw> trav1085: see /msg
16:46:18 <alexj_> would be great if the community converged on just four e.g. closed gpl lgpl open
16:46:21 <sm> this is motivating: http://plone.org/events/conferences/seattle-2006/agenda/watch-eben-moglen-s-plone-conference-keynote-address/
16:46:22 <lambdabot> Title: Watch Eben Moglen's Plone Conference Keynote Address &mdash; Plone CMS: Open Sou ..., http://tinyurl.com/yummez
16:46:24 <esnip> hey people does anyone knows which is the current realase of HaXML?
16:46:25 <trav1085> see /msg
16:46:31 <ehird`> alexj_: well hopefully neither gpl or lgpl would be converged on.
16:46:34 <Botje> \o/
16:46:45 <alexj_> ehird: at least I understand that difference.
16:46:45 <Botje> A LAMBDA SNACK FOR THE PERSON RESPONSIBLE!
16:47:01 <esnip> if u hoogle it, it turns 1.3smth
16:47:34 <Cin> ehird`: at the moment i'm steering towards revised-BSD. i like MIT as well, but BSD has the "don't use my name for endorsment" clause which could be useful (i think that's the _only_ difference, but i could be wrong)
16:47:34 <esnip> but in hackage it's up to 1.19
16:47:58 <pjd> alexj_: licenses don't fit all;  it's not uncommon for projects to specific additions/modifications to those
16:48:19 <pjd> "to have specific", even
16:48:38 <alexj_> pjd: in practice the cost of understanding licensing exceptions vastly exceeds the benefits.
16:49:54 <alexj_> how much do you value another programmers time.  stripulate that all programmer time is equally valuable.  if the exception imposes 10 minutes of time on each programmer that uses your code then you need to calculate how many minutes you benefit from the complexity.
16:50:24 <alexj_> if your code is used by 100 programmers than you have to benefit 1000 minutes for the license complexity to be worthwhile.
16:50:41 <BMeph> alexj_: That stipulation is a vastly overrated imposition. ;)
16:51:19 <alexj_> fine assume your time is worth 100x every other programmer and then do the math.
16:51:53 <alexj_> as soon as you expect your code to be used by any substantial population, your ego has to be really really large to impose license exceptions.
16:52:21 <alexj_> "your mouth is writing checks your body can't cache" ;-)
16:52:32 <alexj_> movie ref for americans of a certain age.
16:52:41 <BMeph> alexj_: Still bad. Look, if I give you something worth $5 to you, I don't have to give you more, just because I give the same thing to someone else, even if it isn't worth $5 to that other person.
16:53:05 <pjd> alexj_: the people that really care about details and exceptions are usually in a position to have project leaders and/or lawyers to worry about that
16:53:29 <alexj_> fine so lets standardize on four licenses for those of us who don't want to pay lawyers.
16:54:18 <pjd> alexj_: a fine position to assume, but you're unlikely to influence any of the people who need specific licenses :)
16:54:22 <alexj_> BMeph: if you give me something worth $5 to me but you can make it worth $10 to me for an additional $1 on your part then perhaps you can rely on me to repay you later.
16:54:24 <BMeph> alexj_: Look at it this way - is it a good thing that Al Gore can run around and claim that he "invented the Internet," just because he was on a committee that allowed money to be spent for the project that developed it?
16:54:46 <bos> BMeph: he never said that
16:54:49 <alexj_> I got into the Internet because of Al Gore actualy.
16:55:20 <alexj_> I was working in the US Sentate in 1990 and read his information super highway bill and decided against a career in politics in favor of the internet.
16:55:21 <BMeph> bos: You mean, he never literally said that he invented the Internet?
16:55:36 <bos> anyway, this is all utterly fascinating, and a great topic for #haskell-blah.
16:55:42 <alexj_> bos: fair
16:56:08 <alexj_> bos: what is the story on epoll stuff?  did anyone pick it up?
16:56:12 <bos> nope
16:56:41 <alexj_> hmm.  ok.  is it posted as a bug somewhere?
16:56:45 <bos> nope
16:56:54 <alexj_> or are you hording the problem because you want it :-/
16:57:06 <bos> i don't really care if someone else does it.
16:57:53 <alexj_> it seems like that plus hspread would allow us to seriously comepte w/ erlang on a lot of scaling fronts.
16:57:56 <mauke> what would be a non-stupid way to solve http://projecteuler.net/index.php?section=problems&id=78 ?
16:57:58 <lambdabot> Title: Problem 78 - Project Euler
16:58:15 <TomMD> @localtime TomMD
16:58:49 <TomMD> @bot
16:58:49 <lambdabot> :)
16:59:10 <BMeph> mauke: Use the formula that "p" represents, and analyze it to see where a million will pop out. ;)
17:01:05 <mauke> http://upload.wikimedia.org/math/1/6/e/16e629087930e59f00873bb0a2c59cbc.png <- this one?
17:01:06 <lambdabot> http://tinyurl.com/39du4g
17:02:00 <gwern> nelhage: I think you're right, cabal install (my version anyway) doesn't follow build-tools:
17:02:08 <BMeph> mauke: More like this one: http://upload.wikimedia.org/math/f/6/6/f667eb0488ccae6fcabb705e39df2eba.png ;)
17:02:08 <lambdabot> http://tinyurl.com/2tchlq
17:07:51 <mauke> :|
17:10:19 <litb> wouldn't log2(n/2) suffice?
17:10:31 <litb> oh, BMeph what does that formula do?
17:10:58 <litb> errm, i mean (n/2)^2 but that is n^(2-1)
17:11:19 <litb> i don't understand BMeph but i believe it is right anyway :D
17:12:35 <gwern> does Cabal-1.2.3.0 come with cabal-install?
17:12:41 <BMeph> litb: It's the partition formula - it counts how many ways you can write _n_ as a sum of positive numbers.
17:12:53 <litb> well, no i meant (n-1)^(2-1)
17:13:06 <litb> i see, i will look it up on wiki
17:13:13 <mauke> ^(2-1) == id
17:13:26 <litb> oh hehe
17:13:31 <BMeph> litb: I found that out because byorgey was kind enough to point out to me that said function was what I was trying to make.
17:14:23 <BMeph> (Well, he named the function, then I went and looked it up to see that it was what I was searching for.)
17:14:23 <litb> darn now i get it right: 2^((n-1)/2) but that function is wrong anyway :)
17:15:05 <cdsmithus> I thought I'd try the new Yi.  After fixing Setup.hs, it's now claiming to need bytestring 0.9.0.1 instead of 0.9.  Anyone know why?
17:15:15 <litb> BMeph: ah, i see that's exactly the same problem here
17:16:17 <BMeph> It's more easily calculater with a "helper function - p'(n, k), the number of ways to write n as a sum of numbers, at least the size of k. Then p(n) is just p'(n, 1).
17:16:20 <litb> well, i just see why my formula would be wrong anyway :)
17:16:44 <gwern> cdsmithus: regexp problems. -_- I've complained about it several times
17:17:00 <gwern> not least because it can cause major problems when building against libraries using different bytestring versions
17:17:51 <cdsmithus> gwern: So I'm getting bytestring from my GHC build.  Would I need to darcs pull and build a new GHC, or is bytestring there too old?
17:18:34 <gwern> cdsmithus: just use a bytestring from hackage. it has 0.1 iirc
17:18:53 <gwern> that was the whole reason for split-base, to allow the libraries to evolve indepdent of GHC
17:19:44 <cdsmithus> gwern: Okay, but I'm still left with the personal goal of not having to independently build and reinstall more libraries than needed each time I rebuild GHC.
17:20:09 <cdsmithus> gwern: I think I'll give up on Yi for now.  Thanks.
17:20:14 <gwern> cdsmithus: aye, I know. as I said, I've complained about yi's idiosyncratic dependencies multiple times...
17:20:20 <dmwit> Whoa, the social network is a confused mess right now.
17:20:23 <BMeph> p' is defined thus:      p'(k, n) | (k > n) = 0 ;p'(k, n) | (k == n) = 1 ; p'(k, n) = p'(k+1, n) + p'(k, n-k)
17:20:34 <gwern> unfortunately I don't know how to fix it, and th other devs don't seem to be in a hurry :(
17:20:51 <BMeph> dmwit: Really? Maybe shapr can give it a fluffy lambda to soothe its nerves. ;)
17:21:00 <gwern> dmwit: over arc still?
17:21:24 <dmwit> gwern: eh?
17:21:41 <dmwit> I mean this: http://files.codersbase.com/haskell/haskell-current.png
17:21:48 <BMeph> litb: Ah, in my definition, I swapped the arguments - p(n) = p'(1, n). :)
17:22:03 <nelhage> dmwit: _wow_
17:22:28 <dmwit> nelhage: Yeah, too many people talking. ;-)
17:22:48 <BMeph> dmwit: Cool. Can you convert that into a multi-dimensional, rotatable view? ;)
17:23:10 <gwern> hey, I'm right in the middle
17:23:19 <nelhage> @users
17:23:19 <lambdabot> Maximum users seen in #haskell: 463, currently: 411 (88.8%), active: 13 (3.2%)
17:23:21 <gwern> does that mean I'm popular, or just unfocused and chatty?
17:23:25 <dmwit> BMeph: Dunno, I've never used PieSpy before, and it's under lispy's control anyway.
17:23:30 <gwern> @karma gwern
17:23:31 <lambdabot> You have a karma of 3
17:23:34 <nelhage> lambdabot doesn't think it's that busy :)
17:23:39 <gwern> :( just chatty, it seems
17:23:45 <BMeph> dmwit: Ah. pity. :)
17:26:33 <BMeph> litb: Check it out in its original form: http://de.wikipedia.org/wiki/Partitionsfunktion (I hope that's a good reference. ;)
17:30:14 <litb> yeah, thanks :)
17:30:40 <litb> it is more complicated than i initially thought  it was :)
17:30:47 <Saizan> gwern: it seems that yi must use that version of bytestring because the ghc package us built against it
17:32:54 <gwern> Saizan: really? hm. if that's true, then it should be possible to use another bytestring by disabling the dynamic flag
17:33:00 * gwern is going to go try that out
17:33:57 <blbrown> haskell is cool
17:34:07 <Cale> :)
17:34:12 <lispy> was someone looking for me?
17:34:20 <blbrown> Cale: every time I work with haskell, that is what I think
17:34:21 <litb> uh one poor sould changed one line on that page to "P(4) = 5 ({1,1,1,1},{1,1,2}, {2,2}, {1,3}, {4})"
17:34:22 <lispy> my channel thing was highlighted, but my scroll back is shorrt
17:34:41 <litb> -d
17:35:52 <litb> BMeph: that's wrong isn't it?
17:36:19 <litb> http://upload.wikimedia.org/math/b/1/7/b174bde75626e314ca7ed06845a32a1b.png and that has to be 4x^4 or?
17:36:23 <litb> i will fix it then
17:36:24 <lambdabot> http://tinyurl.com/3556ss
17:36:31 <BMeph> litb: Hmm, it's much more informative on the English side. :|
17:36:50 <Cale> litb: that's from the page on partitions?
17:37:04 <mauke> litb: what's wrong with it?
17:37:12 <BMeph> Try this one:  http://en.wikipedia.org/wiki/Partition_function
17:37:12 <lambdabot> Title: Partition function - Wikipedia, the free encyclopedia
17:39:19 <litb> mauke: "P(4) = 5 " isn't that wrong ?
17:39:30 <litb> oh wait
17:39:33 <Cale> litb: uh, it should be 5 x^4
17:40:08 <Cale> 1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 3, 2 + 2, 4
17:40:16 <litb> ok, i won't change it then :D
17:40:24 <davidL> the next one is 8x^5?
17:40:28 <Cale> 7 x^5
17:40:34 <Cale> then 11 x^6
17:40:41 <Cale> and 15 x^7
17:40:52 <litb> hmm
17:40:52 <BMeph> litb: no, p(4) is 5, and p(5) is 7.
17:41:10 <Cale> litb: What page is that from?
17:41:18 <Cale> (just out of interest)
17:41:20 <mauke> this function grows too fast/complex for me. I can't bruteforce it
17:41:32 <Cale> mauke: hm?
17:41:43 <BMeph> litb: As a saw, it's more informative on the English side. Maybe you can translate it and add the English info to the German page. ;)
17:41:49 <TomMD> > take 1 [(a,b,c,n) | a <- [3..], b <- [3..], c <- [3..], n <- [3..], a ^n + b^n == c^n]
17:41:56 <lambdabot> Terminated
17:42:13 * BMeph thinks it's odd to see a math page with more information on the English page than the German
17:42:30 <litb> alright i read the "5" as a number to represent P(4) , but in fact that is the amount of possibilities
17:42:32 <BMeph> s/As a/As I/
17:42:35 <litb> Cale: it is from german wiki
17:42:42 <Cale> oh, it's from the *German* page on Partition function, yeah
17:42:54 <mauke> Cale: http://projecteuler.net/index.php?section=problems&id=78
17:42:55 <lambdabot> Title: Problem 78 - Project Euler
17:43:00 <TomMD> > take 1 [(a,b,c,n) | a <- [3..] | b <- [3..] | c <- [3..] | n <- [3..], a ^n + b^n == c^n]
17:43:00 <lambdabot>  Parse error at "|" (column 32)
17:43:01 <BMeph> litb: Correct. After the five, it lists the five different ways.
17:43:02 <litb> Cale: how does that 1, 2, 3, 5, 7, .. continue? looks interesting
17:43:15 <davidL> mauke: have you done problem 104?
17:43:24 <Cale> mauke: Yeah, you probably don't want to brute force that.
17:43:29 <mauke> davidL: no
17:43:37 <litb> BMeph: somehow i thought that they show the "trivial" solution first, and then the rest, but that's not the case :)
17:43:54 <davidL> I'm trying to bruteforce 104 :-\
17:44:15 <litb> that's actually a nice site, that projecteuler
17:45:46 <litb> lol that looks difficult davidL . i'm sure i am out of that game already =)
17:46:02 <BMeph> Great Googly-Moogley! fib!!2749 is the first lead-digit pandigital Fibo num?!? Cool, we have a starting spot to look! ;p
17:46:35 <davidL> I wish they had a donate link or something so they could get a better server so they can get all their old features back.
17:47:48 <BMeph> davidL: Maybe they should talk to Sun... ;)
17:48:20 <litb> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib!!2749
17:48:21 <lambdabot>  2325550020713219717631534041969014652008048425774602597874824957669265690292...
17:48:44 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib!!2749
17:48:45 <lambdabot>  1437268955338791766182964567156433414434763450644891772366329008970222253000...
17:49:19 <davidL> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in sort . take 9 . show . fib $ 2749
17:49:20 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
17:49:24 * sorear mumbles... this whole "maintaining vty" thing is so much more aggravating than writing it was fun
17:49:24 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
17:49:29 <sorear> @messages
17:49:29 <lambdabot> dcoutts said 3d 13h 1m 55s ago: there's a Cabal FAQ http://haskell.org/haskellwiki/Cabal/FAQ feel free to add to it (based on #haskell questions etc)
17:49:30 <litb> oh well, rite =)
17:49:36 <sorear> dcoutts++
17:49:47 <davidL> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in sort . take 9 . show $ fib!!2749
17:49:48 <lambdabot>  "123456789"
17:50:00 <Cale> What if you want 0 in there too?
17:50:18 <nelhage> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in sort . take 10 . show $ fib!!2749
17:50:19 <lambdabot>  "1234556789"
17:50:31 <davidL> "first Fibonacci number for which the first nine digits are 1-9 pandigital."
17:50:42 <litb> Cale hehe
17:51:17 <dmwit> "No instance for (Monad ((->) a))"
17:51:19 <dmwit> What?
17:51:26 <mauke> import Control.Monad.Reader
17:51:35 <gwern> I wonder if there has been enough coverage of project euler to justify a wikipedia article
17:51:45 <dmwit> ugh
17:51:48 <dmwit> mauke: thanxs
17:51:53 <dmwit> s/x/k/
17:52:18 <mauke> main = print . head . filter (panpan . show . snd) . zip [0 ..] $ fibs
17:52:54 <Cale> > let fib = 0 : 1 : zipWith (+) fib (tail fib); p = (== "0123456789") . sort . take 10 . show in filter (p . (fib !!)) [0..]
17:53:00 <lambdabot> Terminated
17:53:07 <Cale> > let fib = 0 : 1 : zipWith (+) fib (tail fib); p = (== "0123456789") . sort . take 10 . show in head $ filter (p . (fib !!)) [0..]
17:53:07 <lambdabot>  3890
17:53:28 <davidL> mauke: you are brute forcing it?
17:53:34 <mauke> obviously :-)
17:54:27 <Cale> > let fib = 0 : 1 : zipWith (+) fib (tail fib); p = (== "0123456789") . sort . take 10 . show in head [n | (n,f) <- [0..] fib, p f]
17:54:27 <lambdabot>  Couldn't match expected type `t1 -> [t]'
17:54:29 <davidL> I can say for certain that k > 180000
17:54:41 <Cale> > let fib = 0 : 1 : zipWith (+) fib (tail fib); p = (== "0123456789") . sort . take 10 . show in head [n | (n,f) <- zip [0..] fib, p f]
17:54:42 <lambdabot>  3890
17:55:11 <litb> i define that 0360 == 360 and have a number F2749 as solution Cale :p
17:56:00 <Cale> [3890,7727,11546,23632,23817,23984,28197,33327,34433,36210,40011,47422,50831..
17:56:10 <litb> hm, maybe there is some way one could combine those two numbers so that we get the wanted one?
17:56:19 <Cale> What wanted one?
17:56:45 <dmwit> Cale: The first 9 and last 9 digits should each be 1-9 pandigital.
17:56:50 <Cale> oh
17:56:52 <dmwit> (It's an Euler problem.)
17:57:03 <davidL> http://projecteuler.net/index.php?section=problems&id=104
17:57:04 <lambdabot> Title: Problem 104 - Project Euler
17:57:06 <idnar> @src sequence
17:57:06 <lambdabot> sequence ms = foldr k (return []) ms
17:57:06 <lambdabot>     where
17:57:06 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:57:11 <Cale> That sounds like you're not likely able to do much but brute force.
17:57:19 <Cale> sequence [] = return []
17:57:26 <EvilTerran> sequence = foldr (liftM2 (:)) (return ())
17:57:30 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:57:50 <litb> wow having haskell proggers at rank4 is quite awesome =)
17:57:51 <Cale> or yes,  sequence = foldr (liftM2 (:)) (return [])
17:57:55 <dmwit> I wonder if there is a (fast) isFib function.
17:58:38 <conal> oh -- sequence is for applicative functors, not just monads.
17:58:40 <mauke> \n -> n == head (dropWhile (< n) fibs)
17:58:50 <idnar> :t sequence
17:58:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:58:55 <idnar> it is?
17:58:56 <EvilTerran> well, with the right datastructure, you can have a O(index) "list" of fibonacci numbers
17:59:01 <EvilTerran> er, O(log index0
17:59:21 <conal> i.e., sequence's given type is unnecessarily restricted to monads
17:59:27 <Cale> conal: right
17:59:29 <EvilTerran> ?hoogle sequence
17:59:30 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
17:59:30 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
17:59:30 <lambdabot> Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:59:32 <idnar> oh, right
17:59:41 <conal> Cale: i hadn't noticed before
17:59:43 <idnar> s/liftM2/liftA2/ I guess
17:59:47 <Cale> yeah
17:59:52 <TomMD> @let isFib x = x `elem` fib where fib = 1 : 1 : zipWith (+) fib (tail fib) --Not good enough for you dmwit?  How large are you thinking of going?
17:59:54 <lambdabot> Defined.
17:59:54 <conal> and s/return/pure
17:59:57 <conal> neat
18:00:01 <idnar> for some reason I keep thinking that liftA2 has something to do with Arrows
18:00:09 <Cale> We really need to straighten all this stuff out.
18:00:09 <dmwit> TomMD: Not good enough, it amounts to brute force.
18:00:22 <mauke> TomMD: that never returns
18:00:24 <litb> maybe devide it by the golden ratio and see whether you get an Integer or not
18:00:25 <dmwit> TomMD: Also, it never terminates.
18:00:28 <litb> hehe
18:00:48 <TomMD> dmwit: Yeah, I just noticed... forgot to use the Ord 'elem' function.
18:00:57 <Cale> I realised earlier today that sequence in the Cont monad is actually quite handy, once unwrapped.
18:01:09 <Cale> nest :: [(r -> b) -> b] -> ([r] -> b) -> b
18:01:09 <Cale> nest xs = runCont (sequence (map Cont xs))
18:01:25 <EvilTerran> throw a trie at at it, the check for containership is O(log i) for fibs!!i <= n < fibs!!(i+1)
18:01:27 <BMeph> Just curious: Does anyone else use a variant of "yes, that is it" for there password? So when the computer asks you (because they ALWAYS ask you) to confirm it... ;)
18:01:55 <Cale> It's useful whenever you have a bunch of functions which handle local allocation of something (like with*) and you want access to a bunch of those things at once.
18:02:08 <EvilTerran> isFib = O(log(Gamma n)) is fast enough for me
18:02:33 <davidL> > let fib' (f, g) p | p = (f*(f+2*g), f^2 + g^2) | otherwise = (f^2+g^2, g*(2*f-g)); fib :: Int->Integer; fib n = snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] in fib (10^6) --found this on hpaste
18:02:34 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
18:06:40 <litb> oh it states that a solution could be found in less than one minute with a good algorithm
18:12:58 <litb> anyway, i'm out. bye :)
18:18:55 <dolio> > isFib 5
18:18:56 <lambdabot>  True
18:19:13 <nelhage> > isFib 6
18:19:20 <lambdabot> Terminated
18:19:39 <dolio> Yeah, you need one that knows it's a sorted list.
18:22:01 <dolio> Or you need to throw an isBottom in there.
18:23:14 <dolio> Detecting fibonacci numbers using a halting oracle.
18:23:27 <mauke> davidL: brute force finished
18:23:56 <davidL> mauke: is k > than 10^6?
18:24:15 <mauke> no
18:24:56 <davidL> I guess I need a better bruteforce, heh
18:32:08 <mauke> the number you want has 68855 digits
18:32:45 <TomMD> What?  You didn't type it out here?  Your lazy, just like your language of choice!
18:33:34 <EvilTerran> *grammar lart*
18:34:03 <mauke> oh sorry, just like you're language of choice
18:34:49 * EvilTerran $ bash (head `on` desk)
18:35:11 <TomMD> be back soon
18:36:22 <mrd> ?pl \ x -> a x coin
18:36:23 <lambdabot> flip a coin
18:42:36 <conal> @pl \ x -> your x lid
18:42:37 <lambdabot> flip your lid
18:42:43 <conal> mrd: fun hack!
18:44:48 <LoganCapaldo> @pl \x -> upside x down
18:44:48 <lambdabot> flip upside down
18:45:32 <liyang> @pl \x -> ping x heck (!)
18:45:33 <lambdabot> flip (flip ping heck) (!)
18:46:05 <chessguy> @yarr
18:46:05 <lambdabot> Drink up, me 'earties
18:46:20 <chessguy> earties?
18:46:26 <ddarius> 'earties
18:46:28 <ddarius> Not earties.
18:46:30 <chessguy> is that what you use if your ears get too long?
18:46:31 <LoganCapaldo> @ \pl \x -> more x pancakes
18:46:40 <LoganCapaldo> @pl \x -> more x pancakes
18:46:40 <lambdabot> flip more pancakes
18:46:43 * ddarius decides to go to sleep.
18:47:18 <liyang> @pl \x -> me x (!) -- this is getting ridiculous.
18:47:18 <lambdabot> flip me (!)
18:48:44 <conal> @pl hands >>= id
18:48:44 <lambdabot> join hands
18:48:45 <dmwit> ?pl \x -> ping heck x (!)
18:48:45 <lambdabot> flip (ping heck) (!)
18:48:59 <conal> dmwit: :)
18:49:15 <liyang> Too much time on your hands &c. &c.
18:49:21 <liyang> I'm off to bed. :p
18:49:25 <mauke> I'm going to write a new operating system entirely in Arc. It will be fully modular and dynamic, the code will be run-time exchangable, and it will be lisp interpreters all the way down.
18:49:29 <mauke> It will only support the ASCII character set, and the WM will use a table layout.
18:49:40 <dmwit> =/
18:49:40 <mauke> I will call it the Arc Computer Operating System, or ArcCOS for short. It will be so great, using any other operating system will be asin. Why, yes, I do think I'm awfully clever.
18:49:47 <mauke> Â© 4chan
18:49:51 <Cin> mauke: /prog/, heh
18:50:30 <liyang> mauke: tell 4chan SmallTalk already did it.
18:50:36 <Cin> mauke: i'm waiting for ehird` to come back to hack on that arc implementation :P
18:51:11 <EvilTerran> four lines of haskell? :D
18:51:48 <Cin> snarky
18:52:16 <EvilTerran> import Control.Monad; import Control.Applicative; import Control.Arrow; main = !"Â£$%%^&*((){}:@~<>/
18:52:39 <EvilTerran> there's four lines :P
18:52:44 <meryrus> lol
18:53:23 <EvilTerran> (for a given value of "!"Â£$%%^&*((){}:@~<>/")
18:53:37 <Cin> valid perl code
18:53:48 <EvilTerran> true story.
18:53:58 <liyang> I don't think Perl recognises British currency.
18:54:18 <EvilTerran> Â£ will have a very important meaning in perl6
18:55:00 <EvilTerran> if you use it instead of $, it makes your programs twice as useful *gd+r*
18:55:00 <Cin> in british sign language, you sign the letter 'L' for lb
18:55:21 <Cin> your daily dose of BSL, brought to you by cin
18:55:38 <liyang> EvilTerran: subject to current exchange rates.
18:56:00 <EvilTerran> well, yes. it'll check 'em via a webservice whenever the program runs.
18:57:59 <BMeph> EvilTerran: Why be so convoluted? Just use C$ instead of $, and your programs get an immediate 2% improvement. ;)
18:58:00 <liyang> Remember, the value of your programs may go up as well as down. Your program may be subject to reposession if you do not keep up repayments.
18:58:48 * BMeph can imagine telling his kids, "I remember the days when US dollars were worth more than Canadian ones..."
18:59:26 <EvilTerran> "how much is that in Ameros, daddy?"
18:59:41 <liyang> Wow. I remember that. I hadn't realise it'd flipped the other way...
19:00:40 <monochrom_> C$ sounds like a string variable in BASIC :)
19:00:50 <dolio> Arrow *and* Applicative?
19:02:02 <dolio> I guess you need Arrow for all the cool tuple futzing functions.
19:02:18 <liyang> dolio: Arrow, Monad *and* Applicative. Throw Functor in too. Collect 'em all.
19:02:22 <HairyDude> (&&&) should be in the Prelude
19:02:45 <dolio> Do we have a Control.Functor now?
19:02:56 <dmwit> HairyDude: Data.List is much higher on my priority list.
19:03:10 <dmwit> As is Control.Monad.
19:03:45 <liyang> dolio: not quite, but we do have flavours of functor, namely Foldable and Traversable.
19:03:58 <dolio> Ah, true.
19:04:31 <dmwit> nanothief is unboxed!
19:04:56 <nanothief> dmwit: i've recently come out the the box, you know
19:05:16 <liyang> oh my.
19:05:20 <dmwit> Thinking outside of the box is the best way to solve hairy problems.
19:06:42 <dolio> And shift paradigms.
19:06:55 <Korollary> and synergize
19:07:10 <liyang> Bingo!
19:07:11 <liyang> I win.
19:07:56 <BMeph> Sorry, liyang, you did not actualize your Bingo potentiality, to its fullest exposure... ;p
19:08:40 <liyang> *yawn*
19:10:24 <liyang> I clearly need to internalise my paradigms and materialise a synergistic strategy for a customer-centric development experience.
19:10:46 <gvdm> liyang: do that and maybe you could be on $75 an hour
19:11:00 <dolio> Maybe you should drill down and pick some low-hanging fruit.
19:11:10 <gvdm> push the envelope?
19:11:12 <paczesiowa> have you seen this: http://dutherenverseauborddelatable.wordpress.com/downloads/exception-monads-for-ocaml/ ? are they talking about Either monad and if so why is it slow?
19:11:13 <lambdabot> Title: Exception Monads for OCaml « Il y a du thÃ© renversÃ© au bord de la table, http://tinyurl.com/2wtsxg
19:11:17 <liyang> no, vertical integration is the way to go.
19:11:22 <gvdm> sorry, I'm real bad at word salads
19:11:25 <gvdm> :/
19:13:25 <dolio> Is Either slow?
19:14:34 <BMeph> For OCaml is it is, apparently.... ;p
19:16:12 <paczesiowa> have someone benchmarked Either vs. regular evil exceptions?
19:19:46 <gwern> @where collections
19:19:47 <lambdabot> I know nothing about collections.
19:20:48 <dolio> @hackage collections
19:20:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/collections
19:22:27 <bigorange> hello
19:22:48 <dmwit> Hiya, bigorange!
19:22:51 <BMeph> hello
19:24:06 <bigorange> I'm looking for a programming language that I could use for trading system, financial analysis or mathematical/scientific analysis in general. I thought about Haskell.
19:24:16 <xpika> where is readline usually on linux?
19:24:38 <Korollary> /usr/lib probably
19:24:55 * gwern has /lib64/libreadline.so
19:25:15 <gwern> bigorange: a reasonable proposition
19:25:43 <chessguy> > let isPalindrome x = show x == reverse (show x); let palindromes = filter isPalindrome [1..2007]; [(a,b,c) | c <- palindromes, b <- [1..(2007-c)], a<-[1..(2007-b)],a*b-c==2007,a+b+c==2007]
19:25:43 <lambdabot>  Parse error at "let" (column 50)
19:26:11 <chessguy> > let isPalindrome x = show x == reverse (show x); palindromes = filter isPalindrome [1..2007] in [(a,b,c) | c <- palindromes, b <- [1..(2007-c)], a<-[1..(2007-b)],a*b-c==2007,a+b+c==2007]
19:26:18 <lambdabot> Terminated
19:26:25 <ulfdoz> gwern: imho, pure functional programming isn't suitable for computations on large datasets.
19:26:27 <chessguy> is there some more efficient way to do this?
19:26:46 <dejones> Hello, can someone recommend a good lexer to be used with Haskell?  Similar to flex for C/C++.
19:27:01 <paczesiowa> dejones: alex
19:27:28 <nelhage> I have this image of some dude named alex sitting in your basement lexing input streams for you.
19:27:34 <dejones> paczesiowa: thanks, it does look pretty similar to flex.  :)
19:27:49 <bigorange> gwern: granted it could be done in any language really. I wanted a language that is somewhat safe (like, inferred typing and no side effects), reasonably fast and that can give a technological advantage. Other candidates: Lisp, Python, C# and Erlang. But I'm trying to figure out if Haskell is the right choice.
19:27:52 <chessguy> @pl \x -> s x == r (s x)
19:27:52 <lambdabot> liftM2 (==) s (r . s)
19:27:56 <Korollary> I'm in ur basement, lexing your input stream.
19:28:06 <dejones> Korollary: noooo
19:28:08 <LoganCapaldo> chessguy: wheres the flip?
19:28:09 <dejones> :P
19:28:13 <dmwit> ?quote the.lisp
19:28:14 <lambdabot> JonHarrop says: As the Lispers always say, it is theoretically possible to do a good job but...
19:28:15 <dolio> chessguy: Knowing any two of a, b or c tells you what the third would have to be, no?
19:28:22 <dmwit> ?quote the.lisp
19:28:22 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
19:28:27 <chessguy> dolio, sure
19:28:39 <chessguy> oh, duh
19:28:41 <gwern> ulfdoz: why not?
19:28:43 <dolio> So, that cuts out a factor of n, probably.
19:28:47 <dmwit> ?quote use.haskell
19:28:47 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
19:28:47 <lambdabot> Haskell
19:29:00 <chessguy> > let isPalindrome x = show x == reverse (show x); palindromes = filter isPalindrome [1..2007] in [(a,b,c) | c <- palindromes, b <- [1..(2007-c)], a<-[2007-a-b],a*b-c==2007,a+b+c==2007]
19:29:01 <lambdabot>   Not in scope: `a'
19:29:10 <chessguy> > let isPalindrome x = show x == reverse (show x); palindromes = filter isPalindrome [1..2007] in [(a,b,c) | c <- palindromes, b <- [1..(2007-c)], a<-[2007-c-b],a*b-c==2007,a+b+c==2007]
19:29:10 <dmwit> bigorange: We have the finest propoganda of any of them. =)
19:29:11 <lambdabot>  [(72,54,1881),(54,72,1881)]
19:29:14 <paczesiowa> dejones: but unless you have to lex/parse real language (with escapes and strings) I wouldn't suggest alex, if you just want to parse smth simple I suggest parsec, it's more powerful and easier to use than alex/happy combo
19:29:20 <Korollary> bigorange: It depends on your definition of technological advantage.
19:29:23 <gwern> bigorange: well obviously, it's hard for anybody here to tell you whether the other candidates would be better if you aren't clear on what you want and your expertise :) right tool for the right person for the right job, etc
19:29:42 <nelhage> Is happy generally preferred to parsec for ``real'' problems?
19:29:45 * gwern curses. damn you fenfire, download!
19:30:00 <ulfdoz> gwern: there is a problem with direct access (array for ips, probably trees for fp) and "mutation" of datastructures. E.g. if you change a node of a tree, you must reconstruct the whole tree, instead of simply changing a value.
19:30:04 <dejones> paczesiowa: I have to lex/parse a mini-C-like language....
19:30:22 <dejones> paczesiowa: thus, alex/happy is the best Haskell lexer/parser combination?
19:30:35 <gwern> ulfdoz: why not use the state monad or one of the other monads like st? that could get you mutation
19:30:49 <dolio> > let isPalindrome x = show x == reverse (show x); palindromes = filter isPalindrome [1..2007] in [(a,b,c) | c <- palindromes, b <- [1..(2007-c)], let a = 2007 - b - c, a*b-c==2007]
19:30:50 <lambdabot>  [(72,54,1881),(54,72,1881)]
19:30:57 <xpika> could someone upload there linux  libreadline.so.5 libncurses.so.5  libm.so.2 and libgmp.so.3?
19:31:25 <paczesiowa> dejones: parsec is really great for parsing  toy languages ( I think it's slower than happy)
19:31:48 <dejones> paczesiowa: happy is better for non-toy languages then?  ;)
19:31:55 <BMeph> xpika: ...done! ;)
19:31:59 <dejones> paczesiowa: can you tell me why happy is better?
19:31:59 <paczesiowa> dejones: and parsec can lex too, but if you have complicated language I'd use alex to lex and then parsec to parse
19:32:09 <xpika> BMeph: ?
19:32:17 <ulfdoz> gwern: Isn't each state in ST a new value, which would mean, that you have to reconstruct any referring identifiers to reflect the change? Dunno, how compiler handles it.
19:32:25 <paczesiowa> dejones: I think it's faster (not sure though)
19:32:29 <nelhage> xpika: Sure. See packages.debian.org ;)
19:32:39 <BMeph> xpika: Are you having trouble finding those files online?
19:32:51 <kmcallister> dejones, parsec is a bit trickier but also much "cleaner" than alex/happy
19:32:51 <lambdabot> kmcallister: You have 1 new message. '/msg lambdabot @messages' to read it.
19:32:55 <gwern> ulfdoz: I always heard GHC played a lot of optimization tricks to get it down to using unsafe-but-proven-safe-for-just-right-here functions
19:33:20 <paczesiowa> dejones: but if you already know yacc-like tools then happy will make you happy:P
19:33:49 <dejones> paczesiowa, kmcallister: I'm not worried about performance, this is for a Compilers course with a mini-C language.  I am more concerned with usability / documentation and not running into something that the lexer / parser can't do...
19:34:06 <kmcallister> dejones, i would try parsec first and see how you like it
19:34:08 <ulfdoz> gwern: That's a deal, but I wouldn't be able to make such proofs.
19:34:12 <nelhage> I'm horribly jealous of anyone who gets to use haskell for a compilers course.
19:34:17 <kmcallister> i've used parsec for fairly "real" languages
19:34:20 <nelhage> I had to do mine in Java.
19:34:27 <nelhage> I cried the entire semester long.
19:34:43 <chessguy> ouch
19:34:44 <sclv> ulfdoz: ST is not State. ST is like everything in IO except the IO itself.
19:34:46 <gwern> nelhage: I heard cutting yourself helps let out the pain
19:34:47 <kmcallister> nelhage, i used Haskell and Python for everything last term, it was great
19:34:55 <gwern> sounds better than using java anyway
19:35:10 <dejones> kmcallister: parsec can work as the lexer and parser?
19:35:12 <kmcallister> sclv, afaik it only has IORefs (and calls them STRefs)
19:35:16 <kmcallister> dejones, yes
19:35:23 * gwern winces. if I wget a darcs repo, is that as good as a darcs get?
19:35:26 <dejones> kmcallister: that's nice of parsec.  :)
19:35:28 <dmwit> I would have used Haskell, except there are no Haskell compilers on the submission machines. =/
19:35:34 <nelhage> Also, our compiler class was basically a class on optimizing fortran.
19:35:44 <kmcallister> dejones, it only builds parsers, but you can build a parser all the way up from single characters
19:35:52 <nelhage> It would have been nice to learn about implementing more advanced language features
19:36:19 <LoganCapaldo> you can also build 2 (or more parsers) and feed the results of the first into the second
19:36:30 <LoganCapaldo> IOW, tokenize with parsec to parse with parsec
19:36:46 <dejones> nelhage: well, I haven't asked permission to use Haskell yet for my Compilers course, but -hopefully- it will be allowed.  I don't see why it would be a problem.... we shall see!  :)
19:36:47 <kmcallister> LoganCapaldo, this is something i should learn how to do, is there a good example somewhere online?
19:36:58 <nelhage> Good luck
19:36:58 <kmcallister> (in particular how to make a parsec parser that takes something other than [Char] as input)
19:37:19 <dejones> nelhage: thanks.  I'll tell my prof that kittens will die if he doesn't let me use Haskell.  ;) haha
19:37:28 <kmcallister> one of the languages courses here uses OCaml, and the other allows you to use any language
19:37:31 <LoganCapaldo> kmcallister: Parser is just a alias for GenParser ... Char ...
19:37:34 <sclv> you also get arrays, and if you want to do anything else you can always use unsafeIOtoST, providing you're confident that you're not doing IO.
19:37:35 <LoganCapaldo> IIRC
19:37:58 <LoganCapaldo> most of the cobinators are parametized on the token type
19:38:06 <LoganCapaldo> *combinators
19:38:08 <paczesiowa> kmcallister: there is pcl for ocaml
19:38:11 <Philippa> dejones: just don't be surprised if he hands you some kleenex and tells you to get on with it
19:38:14 <kmcallister> paczesiowa, pcl?
19:38:22 <paczesiowa> kmcallister: parsec clone
19:38:25 <kmcallister> cool
19:38:39 <kmcallister> we used ocamllexyac
19:38:40 <LoganCapaldo> @hoogle many
19:38:40 <sclv> also, there are other parser combinator libraries if parsec isn't too your speed -- there's a few with bytestrings now (dunno if happy and alex use those yet?)
19:38:41 <nelhage> Be careful, the prof could always be a closet kitten-hater.
19:38:41 <lambdabot> Control.Applicative.many :: Alternative f => f a -> f [a]
19:38:41 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
19:38:41 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
19:38:42 <Philippa> anyway, Haskell's great for compiler and interpreter work
19:38:58 <paczesiowa> kmcallister: but prepare for no do-notation and many problems with value-restricton
19:39:02 <LoganCapaldo> eg  ^
19:39:21 <kmcallister> sclv, so it's safe to do something like unsafeIOtoST $ forkIO ?
19:39:58 <dejones> kmcallister, paczesiowa: are there any downsides to use parsec other than performance?
19:40:11 <kmcallister> dejones, it's trickier to write
19:40:16 <kmcallister> you have to make lookahead explicit in some cases
19:40:18 <kmcallister> :t try
19:40:19 <lambdabot> Not in scope: `try'
19:40:46 <dejones> kmcallister: can you elaborate on that for me?  example case?
19:40:50 <kmcallister> :t Text.ParserCombinators.Parsec.Prim.try
19:40:51 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
19:40:57 <kmcallister> dejones, the parsec docs will do a better job than i can
19:41:02 <kmcallister> i'll try to find a good doc
19:41:03 <paczesiowa> if you don't care about performance you can lookahead all the time (it's easy but slow)
19:41:13 <sclv> kmcallister: ST is supposed to be deterministic, so, hmm...
19:41:16 <paczesiowa> dejones: read parsec's doc, it's a tutorial
19:42:13 <kmcallister> dejones, essentially, if s and t are parsers, then (s <|> t) is supposed to be a parser that accepts either s or t, except that if s consumes some input before failing, that input is lost
19:42:31 <kmcallister> so instead you write (try s <|> t), where (try s) is the same as s except if it fails it rewinds the input
19:42:51 * BMeph hates that (-) is a binary op'r, but (-2) is a Num...
19:43:07 * LoganCapaldo too
19:43:14 <kmcallister> dejones, the power of parsec is that parsers are first-class values, so you have much more freedom than in a fixed BNF-style language
19:43:34 <kmcallister> BMeph, yes
19:43:44 <xpika>  error while loading shared libraries: ./libreadline.so.5: file too short
19:44:02 <LoganCapaldo> error: not bloated nough
19:44:12 <paczesiowa> and parsers are regular haskell so you can do all the stupid hacks if you can't do it the right way
19:44:18 <dejones> kmcallister: hmm, I doubt I am going to have the need for multiple parsers for this mini-C language?
19:44:38 <kmcallister> dejones, what do you mean by "multiple parsers"
19:44:54 <nelhage> I've written a parser for a mini C-like language in parsec before. It was pretty fine
19:44:59 <paczesiowa> dejones: yes you do, there are small parsers for parsing single characters which you combine to bigger parsers
19:45:21 <dejones> paczesiowa: ahh, ok... I see, so I do need multiple parsers kmcallister.
19:45:23 <sm> parsec can give you excellent parse errors.. can alex/happy ?
19:45:30 <dejones> sm: no clue ;)
19:45:32 <kmcallister> dejones, also look at Text.ParserCombinators.Parsec.Language... it will handle some of the lexing for you
19:45:50 <dejones> kmcallister: thank you.  I'll work my way through the tutorial.  :)
19:45:54 <kmcallister> well, Text.ParserCombinators.Parsec.Token... Language gives you some fixed language styles
19:45:56 <gwern> @where HList
19:45:56 <lambdabot> http://homepages.cwi.nl/~ralf/HList
19:46:07 <gwern> @Hackage HList
19:46:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HList
19:46:23 <dejones> thank you paczesiowa, kmcallister.  nelhage, I'll let you know if I get to use Haskell.  ;)
19:46:24 <gwern> that's not right
19:46:31 <kmcallister> dejones, good luck
19:47:09 <dejones> kmcallister: hehe, thanks again.  I'm sure I'll be back to bother you guys for help.  ;)
19:47:13 <dejones> I love this channel.
19:47:17 <dejones> karma+ #haskell
19:47:22 <paczesiowa> we all do:>
19:47:22 <kmcallister> yes
19:48:10 <gwern> hm. if HList is on darcs.haskell.org why is it not also on Hackage?
19:48:41 <sclv> kmcallister: why would you want forkST anyway? I'm probably missing something, but the canonical use of threads for concurrency as opposed to parallelism generally has to do with IO, no?
19:49:03 <kmcallister> sclv, i'm not sure i would, i'm just curious about the statement that you can do anything from IO except IO itself
19:50:27 <gwern> what is a file with .chs as a suffix?
19:50:32 <sclv> hmm.. I guess I can recover the meaning of that statement if we consider forking a form of IO, in that you've introduced nondeterminism as conditioned by the order of execution of the threads, just like getting a random  value is io as well.
19:51:04 <gwern> sclv: no, it's getting the seed that might be IO :)
19:51:36 <sclv> this channel will nickel and dime me into being a more precise speaker. i swear. :-)
19:51:59 <sclv> but if you want to play that game, anything but the seed isn't random at all, but pseudo-random.
19:52:27 <gwern> sclv: go read the xkcd comic. 'int random { return 4; // guaranted random; chosen by roll of fair dice }'
19:52:35 * gwern likes that one
19:52:50 <sclv> there was a dailywtf about that too, from ages before that comic.
19:53:29 <sclv> with random GUID session ids hardcoded at the top of "secure" php pages.
19:53:49 * gwern gives up on fixing up fenfire. if the authors can't be bothered to provide a darcs repo you can actually download from,. I can't be bothered fixing it
19:54:28 <araujo> > (,) 1 2
19:54:28 <lambdabot>  (1,2)
19:55:24 * BMeph thinks secure php is an oxymoron, kind of like fast Ruby, or clean politics
19:55:53 <sclv> a google finds me this about concurrent ST by the way: http://www.informatik.uni-freiburg.de/~thiemann/papers/deno-procsla.ps.gz
19:55:54 <lambdabot> http://tinyurl.com/2vz5pq
19:56:19 <sclv> "Towards a Denotational Semantics for Concurrent State Transformers" -- still not sure why they're better than `par` though.
19:56:22 <xpika> yay with ghc-unknown and debian packages I just installed GHC-8.2 on my webhost
19:58:34 <sclv> 8.2 wow! debian really needs to update their packages. :-)
19:58:56 <brad_larsen> perhaps someone can answer a class/instance/type question for me...
19:59:05 * sclv apologizes for unfunny frivolity
19:59:17 <sandbox> I'm taking a course in number theory and we're proving correctness of algorithms by proving the post-condition of an algorithm holds throughout.  All our apps have loops and we show it holds at each iteration of the loop, how would you do it with recursion?
19:59:25 <sandbox> If it's lengthy could you point me to a paper?
19:59:41 <nelhage> At each entry to the function?
19:59:59 <paczesiowa> it's easier for recursion I think
20:00:10 <brad_larsen> I've defined the following class:
20:00:13 <brad_larsen> class Fringe s where   put     :: s a -> a -> s a   putList :: s a -> [a] -> s a   take    :: s a -> (a, s a)   null    :: s a -> Bool    putList s as = List.foldl' put s as
20:00:13 <sandbox> okay thanks, I wasn't sure if it was that easy
20:00:24 <paczesiowa> that's why it's so easy to prove things about haskell code
20:00:28 <brad_larsen> whoops, that didn't work like i hoped
20:00:38 <sandbox> thanks all
20:00:49 <sclv> brad_larsen: use hpaste.org for big pastes, by the way.
20:01:29 <dons> but not too big
20:02:11 <brad_larsen> ahhh, i'll paste there
20:02:13 <brad_larsen> it's only a few lines
20:02:48 <hpaste>  brad_larsen pasted "class/instance/Ord troubles" at http://hpaste.org/5389
20:02:57 <xpika> how do I block the use of IO functions in haskell?
20:03:07 <xpika> ghc
20:03:07 <brad_larsen> whoa, cool
20:03:16 <xpika> like lambdabot does
20:03:17 <dons> xpika: set the type to be pure?
20:03:25 <dons> ah, there's a thing on the wiki about it.
20:03:26 <paczesiowa> xpika: stay out of IO monad
20:04:02 <dejones> any way I can see what packages are available to ghc?  I can't seem to get ghc -package text to work so I can compile using parsec...
20:04:11 <allbery_b> someone mentioned a fake IO library yesterday
20:04:18 <allbery_b> dejones: ghc-pkg list
20:04:37 <xpika> import Prelude Hiding IO?
20:04:39 <dejones> allbery_b: thanks
20:04:53 <jcreigh> allbery_b: you mean, it has the same semantics as the IO monad, but isn't *actually* writing files and so on? just faking it?
20:04:55 <paczesiowa> dejones: don't use -package, use --make
20:05:13 <dmwit> brad_larsen: What's the problem?
20:05:16 <brad_larsen> my issue in what I pasted is this:  i have a class Fringe that's supposed be some very generic interface to a queue.  I'm using instances of it for a parameterized search algorithm---many searches differ just in queue behavior.  For A*, the queue needs to be sorted.
20:05:27 <brad_larsen> dmwit: thanks, just slow at typing.
20:05:35 <dmwit> sorry =P
20:05:47 <dejones> paczesiowa: hmm, I was following what the tutorial said...
20:05:49 <Saizan> brad_larsen: you simply can't do that, since Set needs an Ord context, buf the typesignatures of Fringe's methods require it to work for any type a
20:06:00 <dejones> paczesiowa: what does --make do?
20:06:04 <allbery_b> jcreigh: I think so; not entirely certain.  and I inadvertently blew away all my scrollback earlier today so can't even check
20:06:12 <brad_larsen> Saizan: there is no way to add a context to the instance?
20:06:18 <paczesiowa> dejones: it pulls all the packages needed
20:06:20 <allbery_b> dejones: automatically follows package dependencies
20:06:36 <paczesiowa> dejones: and works as a automake thingie too
20:06:38 <Saizan> brad_larsen: a solution is to make "a" a parameter of the class e.g. class Fringe s a where ..
20:06:45 <allbery_b> the fact that ghc lets you import a packkage but then fails on link without an explicit -package (or --make) is arguably a bug
20:07:03 <Saizan> brad_larsen: this requires the MultiParamTypeClasses extension
20:07:06 <brad_larsen> Saizan: a multiparameter typeclass, then?
20:07:13 <brad_larsen> Saizan: aha
20:07:18 <dejones> paczesiowa, allbery_b: thanks.  ghci fails although I have the "import Parsec"
20:07:45 <paczesiowa> dejones import Text.Parsercombinators.Parsec
20:07:50 <LoganCapaldo> import Text.ParserCombinators.Parsec
20:08:04 <dejones> paczesiowa, LoganCapaldo: ahhhhh
20:08:06 <brad_larsen> Saizan: can you enlighten me as to how multiparameter typeclasses and undecidable instances are related?
20:08:06 <paczesiowa> that howto is old unfortunetly
20:08:12 <brad_larsen> Saizan: just curious now
20:08:24 <dejones> paczesiowa: yes, the howto is quite out-dated it seems ;)
20:08:34 <sclv> brad_larsen: you can have undecidable instances with only one parameter in your class i think.
20:08:42 <allbery_b> dejones: "import Parsec" would be for Haskell98 compatibility (flat namespace); modern Parsec only does hierarchical namespace
20:09:05 <kmcallister> brad_larsen, instance (Foo a) => Bar a... instance (Bar a) => Foo a
20:09:10 <allbery_b> (the flat namespace gets to crowded and ugly)
20:09:16 <kmcallister> this introduces a cycle when trying to find instances
20:09:23 <brad_larsen> i see
20:09:30 <paczesiowa> allbery_b: so we can't compile old haskell98 code with recent ghc?
20:09:39 <allbery_b> sure you can
20:09:46 <dejones> allbery_b: so ghc6 doesn't meet haskell98 specification?
20:09:51 <allbery_b> it's the Parsec package that has dropped haskell98
20:09:53 <dejones> I'm confused
20:09:55 <dejones> ohh
20:09:56 <allbery_b> sorry, guess I wasn't clear
20:10:10 <brad_larsen> kmcallister: and ghc is smart enough to figure out when an instance is undecidable, hence the option for it?
20:10:14 <kmcallister> brad_larsen, the original H98 restriction to avoid this is that all instances must be instance (some context) => T a b c ... z, where T is a literal type constructor and a..z are type variables
20:10:14 <dejones> allbery_b: thanks again :)
20:10:28 <kmcallister> brad_larsen, no, the option tells GHC that you don't mind if it goes into an infinite loop :)
20:10:29 <dmwit> brad_larsen: It has some heuristics.
20:10:47 <Saizan> brad_larsen: ghc uses some heuristics to ensure temination, but the condition is known to be too strong
20:10:52 <allbery_b> parsec now uses multiple hierarchical names instead of a bunch of names starting with Parsec
20:10:53 <dmwit> brad_larsen: It isn't possible to tell if an instance is undecidable in general... it's the halting problem. =P
20:11:04 <brad_larsen> dmwit: ahhh, of course
20:11:04 <sclv> brad_larsen: there are lots of things that are potentially undecidable, but aren't.
20:11:21 <xpika> dons: can't find the Keeping out of IO page on http://www.haskell.org/haskellwiki/
20:11:22 <lambdabot> Title: Haskell - HaskellWiki
20:11:50 <kmcallister> "undecidable instances" really means "remove the restrictions on the problem of finding the right instance that make it always terminate"
20:11:59 <allbery_b> (which basically meant Parsec owned every possible name starting with "Parsec", which is why the Haskell98 flat namespace is deprecated.  still supported, but you should avoid it in new programs and libraries)
20:12:32 <sclv> http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
20:12:33 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/2orccu
20:12:38 <sclv> xpika ^^
20:13:10 <brad_larsen> hmmmm.   how about FlexibleInstances?
20:13:19 <kmcallister> brad_larsen, actually, i believe it will never go into an infinite loop, but it may quit after hitting the depth set by -fcontext-stack=
20:13:46 <sclv> except it also has a semantics for "deciding" undecidable instances, right? where it picks the first instance it finds sometimes, i think?
20:14:02 <kmcallister> brad_larsen, http://cvs.haskell.org/Hugs/pages/users_guide/class-extensions.html
20:14:03 <lambdabot> http://tinyurl.com/3dw6h4
20:14:11 <brad_larsen> danke
20:14:21 <kmcallister> sclv, that sounds like a heuristic for overlapping instances
20:14:44 <sclv> overlapping it picks the most specific. undecidable also is required if it can't tell which is more specific.
20:15:04 <sclv> e.g. if you have instance [a] and instance Foo a
20:15:19 <kmcallister> brad_larsen, the ghc version is at http://www.haskell.org/ghc/docs/6.6/html/users_guide/type-extensions.html
20:15:19 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/2j7o5z
20:15:31 <sclv> erm, that's not quite right.
20:15:38 <Saizan> sclv: maybe you're thinking of incoherent instances?
20:16:12 <sclv> actually, yeah, i think so.
20:16:25 <sclv> undecidables are where it errors on "Constraint is no smaller than instance head", then.
20:16:46 <allbery_b> overrlapping is e.g. instance Foo [a] vs instance Foo [Int]
20:17:04 <Saizan> or something about the coverage condition if you're using fundeps
20:18:05 <kmcallister> what's an example of incoherent instances, then?
20:18:38 <Cale> There are examples of all the extensions in the GHC User's Guide.
20:18:40 <Saizan> instance Foo a => C a, instance Bar a => C a, iirc
20:18:50 <kmcallister> yeah, that makes sense
20:19:07 <LoganCapaldo> no it doesn't
20:19:10 <LoganCapaldo> it makes no sense
20:19:11 <LoganCapaldo> :P
20:19:14 <kmcallister> hehe
20:19:17 <LoganCapaldo> that's why it's incoherent
20:19:29 <kmcallister> LoganCapaldo, it makes sense if we have a real logic programming language
20:20:03 <LoganCapaldo> Does it?
20:20:13 <conal> kmcallister: and we almost do.
20:20:22 <LoganCapaldo> what happens when you have a type that's an instance of both Foo and Bar?
20:20:23 <conal> we almost have a higher-order logic programming language.
20:20:29 <conal> like Lambda-Prolog
20:20:35 <LoganCapaldo> can your logic programming language handle tht incoherency?
20:20:51 <conal> with higher-order variables, quantification, and implication
20:20:52 <kmcallister> LoganCapaldo, at the level of "is a an instance of C", it's perfectly consistent
20:21:04 <kmcallister> now, how to actually find values for the C typeclass members is another question
20:21:07 <LoganCapaldo> Cthlhu f'thagn!
20:21:18 * LoganCapaldo goes insane
20:21:18 <kmcallister> presumably if you're doing such a thing you shouldn't care which you get
20:21:28 <kmcallister> which is why -fallow-incoherent-instances chooses the first arbitrarily
20:22:06 <jstanley> Is there a floating-point mod function somewhere in the prelude/common lib?
20:22:58 <LoganCapaldo> @hoogle Floating a => a -> (a, a)
20:22:58 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
20:22:59 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
20:22:59 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
20:23:10 <LoganCapaldo> @hoogle frac
20:23:10 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
20:23:10 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
20:23:10 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
20:23:16 <dolio> @type Data.Fixed.mod'
20:23:16 <lambdabot> forall a. (Real a) => a -> a -> a
20:23:19 <LoganCapaldo> erg
20:23:42 <LoganCapaldo> @src Fractional
20:23:42 <lambdabot> class  (Num a) => Fractional a  where
20:23:42 <lambdabot>     (/)             :: a -> a -> a
20:23:42 <lambdabot>     recip           :: a -> a
20:23:42 <lambdabot>     fromRational    :: Rational -> a
20:23:56 <jstanley> thanks ;)
20:23:58 <dolio> > (3*pi) `Data.Fixed.mod'` pi
20:23:59 <lambdabot>  0.0
20:24:23 <LoganCapaldo> I really thought there was a a -> (a,a) or (Integral b) => a -> (b, a) or something for fracctionals
20:24:34 <dolio> @type properFraction
20:24:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
20:24:43 <LoganCapaldo> there it is
20:24:47 <jstanley> Data.Fixed.mod is exactly what I was looking for, thanks gang + lambdabot ;)
20:25:16 <brad_larsen> thanks for the help, guys.  i'm out.
20:29:21 <BMeph> jstanley: Don't forget the apo - it's mod'
20:31:12 <nominolo> @seen dons
20:31:12 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 27m 47s ago.
20:32:17 <bos> beware of Data.Fixed.  it's *really* slow.
20:32:42 <jstanley> Yeah -- this is just for demonstration purposes.
20:34:14 <Cale> bos: Oh? That's sad.
20:34:30 <Cale> bos: I suppose it hasn't seen much use.
20:35:28 <bos> Cale: it's just implemented very straightforwardly.
20:35:44 <nominolo> @localtime dons
20:35:45 <lambdabot> Local time for dons is Thu Jan 31 20:35:44 2008
20:36:39 <Cale> What I'd really like to have is a combined exact-rational / arbitrary precision floating point library.
20:37:07 <bos> Cale: it's specifically the generalised div and mod that are slow, not necessarily the rest of it.  The actual Fixed datatype is simply a newtype wrapper for Integer.
20:37:15 <xpik1> what is the latest version of ghc lambdabot should run on?
20:37:18 <mainland> so wrap mpfr
20:37:22 <Cale> What would be awesome is something which represented numbers as functions of a desired precision.
20:37:50 <mainland> i've been thinking about the same thing :)
20:38:23 <Cale> xpik1: I've got it running on 6.8.2, but it takes a little work. Someone was doing that work on a fresh lambdabot the other day. If they haven't contributed patches, I could grab a copy of lambdabot and fix it up.
20:39:02 <xpik1> does hs-plugins work on 6.8.2?
20:39:25 <Cale> yes, I updated it specifically so that it should work with almost arbitrary GHC versions
20:39:30 <Cale> (It uses the GHC API now.)
20:39:50 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
20:39:50 <lambdabot> Title: Index of /~dons/code/hs-plugins
20:39:57 <gwern> Cale: really? how did you manage that?
20:40:14 <gwern> (I mean newSession alone seems to change type sig every major release)
20:40:42 <xpik1> Cale: Awesome must try it out
20:40:46 <Cale> gwern: Okay, if the API changes too much it won't work -- but only a tiny fraction of it is needed.
20:41:00 <Cale> (Just the .hi parser)
20:42:45 <Cale> At least hs-plugins isn't parsing the .hi files itself now, which is something that basically ensured that it would need work with each release of GHC.
20:43:09 <gwern> hm. guess I should look closer at how hs-plugins then. that doesn't accord with what I thought
20:45:13 <Cale> However, I understand very poorly what it is that I actually did. hs-plugins used to have a .hi parser included, most of which was ripped directly from GHC. I replaced calls to that parser with seemingly-appropriate calls into the GHC API, and used the type system to help let me know when that wasn't straightforward.
20:45:22 <Cale> (and to find appropriate fixes)
20:45:56 <Cale> The tests seemed to work after I was done, so I took that as meaning I was successful :)
20:47:10 <Cale> (and it was enough to get lambdabot working)
20:53:23 <Cin> hrm. hs-plugins could be pretty useful for re-loading message handling and and event handling in my IRCd. it's basically built like that anyway. the main thread which stores the state just asks functions how to modify the state anyway. hrm!
20:53:27 * Cin looks into it
20:54:09 <Cin> (i.e so i can change the server without having to disconnect users)
21:03:20 <bos> @seen dons
21:03:20 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 59m 55s ago.
21:13:00 <monochrom_> @djinn (a->b) -> (Not a -> Not b)
21:13:00 <lambdabot> -- f cannot be realized.
21:13:10 <monochrom_> @djinn (a->b) -> (Not b -> Not a)
21:13:10 <lambdabot> f a b c = b (a c)
21:13:13 <monochrom_> Typo. :)
21:14:21 * Cale sends a little note to haskell-cafe about sequence in Cont :)
21:15:03 <Cale> I think that was the first time Cont has actually been useful to me :)
21:15:24 <dolio> That was pretty cute.
21:16:25 <monochrom_> I'm an early adoptor of Cont or its definition.
21:16:45 <Cale> What have you used Cont for?
21:18:47 <Cale> Heh, given function programming's foundations in intuitionist logic, shouldn't the name of the paper be "Why functional programming doesn't not matter"?
21:18:53 <Cale> functional*
21:19:05 <monochrom_> Understanding control flow. Measuring performance of using Maybe as a control flow.
21:19:58 <Cale> Speaking of performance of using Maybe, there was a question about that on reddit...
21:20:38 <dolio> The one about Either being slow?
21:20:40 <Cale> http://reddit.com/r/programming/info/67amc/comments/
21:21:28 <Cale> I couldn't be bothered to produce an example and go sifting through Core to see what GHC did with it, but if someone here knows :)
21:21:49 <monochrom_> To do the latter, I write a version of code using Maybe, and I write another version using pass-around-escape-functions. Supposedly the latter is the fastest possible. I'm interested in how badly the former performs. If it's not too bad, I want to use Maybe, since it is easier to use.
21:23:22 <monochrom_> Thanks to pointer tagging in 6.8.2, the Maybe version is just 3-6% slower. I'm happy enough. That code is only run for half a minute in production run, so 6% is unnoticeable.
21:23:57 <Cale> nice
21:24:41 <monochrom_> I haven't actually tried 6.6.1. I wouldn't know how slow it could be, or whether pointer tagging helped. I just have faith.
21:25:13 <monochrom_> But if someone says in OCaml it deteriorates badly, my faith is justified. :)
21:31:05 <sm> evening all. I'm studying the code of Shu-thing. I could use a little help understanding the purpose/meaning of this: data Scene = Scene (IO Scene)
21:31:36 <Cale> Interesting that it's a data and not a newtype.
21:32:20 <Cale> sm: Well, a Scene appears to be a wrapper around an IO-thing which you can run and get another Scene.
21:32:49 <Cale> sm: So it's like an IO computation which can decide to stop at some point, handing back some way to resume itself.
21:33:17 <Cale> (but I don't know anything about what this means to Shu-thing)
21:33:53 <sm> hmm. My interpretation was a Scene contains/leads to more Scenes, ad infinitum (all in IO) ?
21:34:04 <sm> thanks, that is food for thought
21:34:07 <Cale> It's something which runs to produce another scene.
21:34:10 <RayNbow> good morning #haskell :)
21:34:22 <Cale> g'morning
21:34:32 <Cale> (hehe, here's just past midnight :)
21:34:36 <monochrom_> The next scene can depend on user input and random generator etc.
21:34:55 <Cale> I'm not sure why you'd call that a Scene...
21:35:18 <Cale> But I suppose it's not an altogether terrible name.
21:35:19 <monochrom_> You can also make some sounds and launch some freedom fries before returning the next scene.
21:35:29 <RayNbow> Cale: it's 6:30 AM here :p
21:36:17 <monochrom_> self-directed adventure book :)
21:36:25 <sm> they have a bunch of procs corresponding to game stages, like openingProc :: IORef [Key] -> IO Scene
21:38:15 <Cale> hehe, newtype ChooseYourOwnAdventure = CYOA (IO ChooseYourOwnAdventure)
21:39:00 <dolio> It might make some sense if they don't export Scene, and instead give you a bunch of primitive Scenes and stuff for combining them or something.
21:39:06 <monochrom_> scene4 = do putStrLn "the room sits Cale, monochrom, and dons. whom do you shoot?"; s <- getLine; case s of "Cale" -> return (Scene scene10); "monochrom" -> return (Scene scene23); "dons" -> return (Scene scene15)
21:39:43 <Cale> hehe, excellent :)
21:40:00 <wli> Well, you don't want pattern match failures if they try to pick someone else.
21:40:15 <monochrom_> But real men don't use IO. Real men use continuations for that.
21:40:29 <monochrom_> It's just a proof-of-concept!
21:40:34 <Korollary> Shoot everybody, and then look. Observation will collapse the possible states into just one victom.
21:43:23 <Cale> _ -> return (Scene selfDeath)
21:43:45 <Cale> Just take any other name to mean that the player wanted to shoot themselves.
21:43:45 <sm> next question.. I see the operator $=, but I can't see where it's imported from.. how would I find out more about it ?
21:43:55 <Cale> sm: That's likely from OpenGL
21:44:12 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
21:44:13 <lambdabot> http://tinyurl.com/24hd3h
21:44:32 <sm> thank you
21:44:41 <Cale> (It's absolutely insane that module is located deep inside the OpenGL libraries.)
21:45:06 <sm> we import from Graphics.UI.GLUT, but all the imports seem to be named in (), I don't see how the $= appears in namespace
21:45:53 <hpaste>  sm pasted "Shu-thing.hs" at http://hpaste.org/5390
21:46:13 <sm> ack, hpaste truncates
21:46:56 <Cale> sm: does it compile?
21:47:26 <Cale> Oh, HasSetter(..)
21:47:30 <Cale> there you are :)
21:47:43 <kpreid> ...you can do that?
21:47:44 <sm> aha, thanks :)
21:47:56 <Cale> kpreid: do what?
21:48:10 <kpreid> import a class's methods by ellipsis
21:48:17 <Cale> yep :)
21:48:20 <kpreid> never seen it before
21:51:44 <omg911> i'm looking for papers/info on writing my own simple scanner and parser for a lisp syntax like language, anyone know any good resources (btw i know there is one for haskell but i was hoping to do it from scratch)
21:52:31 <paczesiowa> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
21:52:32 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
21:52:47 <brad___`> anyone playing with the new yi?
21:52:49 * sm wonders how do these imports from Graphics.UI.GLUT pull in a class from Graphics.Rendering.OpenGL.GL.StateVar
21:53:39 <dolio> http://www.cs.nott.ac.uk/~gmh/pearl.pdf
21:53:55 <omg911> paczesiowa: thx for the link
21:55:07 <paczesiowa> but anyway, parsing lisp should be so easy, that it's not worth being called parsing
21:55:08 <shachaf> Cale: By [(r -> a) -> a] do you mean [(a -> r) -> r]?
21:55:23 <shachaf> Cale: (Not that this doesn't work, but it seems like an odd choice of names.)
21:55:40 <dolio> @arr
21:55:40 <lambdabot> I'll crush ye barnacles!
21:55:53 <paczesiowa> just a few lines of parsec code, unless this is your first time with haskell
21:56:17 <Maddas> Even then it shouldn't be more ;-)
21:56:18 <sm> I see.. because http://www.haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT.html tells me it pulls in module Graphics.Rendering.OpenGL
21:56:19 <lambdabot> http://tinyurl.com/38ggyv
21:56:33 <omg911> lol i worked with it a bit but always wanted to try a scheme clone and now i got some free time
21:56:47 <omg911> i just need to *start* it then i can add stuff as i go
21:57:07 <dolio> Make sure you call the "not" function "no".
21:57:12 <dolio> That's key. :)
21:57:12 * sm moves two characters deeper into Shu-thing.hs
22:14:32 <sm> gwern, I see you cabalised shu-thing and monadius.. thanks
22:16:11 <gwern> sm: you're welcome? I take it you enjoyed'em
22:16:40 <sm> loving them.. played a bit, now studying the code
22:17:12 <sm> did you figure out how they worked, at all ? I'm trying to grok shu-thing's dispProc
22:17:25 <gwern> if I did, I've forgotten
22:17:41 <bos> Cale: ooh, that's pretty!
22:21:38 <gwern> sm: if you have the time though, I'd be interested in whether swapping datas for newtypes helps performance. monadius never ran fast enough to suit me, but profiling didn't reveal anything within my competence to improve
22:22:10 <sm> ah, I did notice it's a bit slow fullscreen
22:23:16 <sm> I'd quite like to master the 400-line Shu-thing before I tackle Monadius
22:23:50 <gwern> the only part of Monadius I truly understood and improved was Demo.hs :)
22:24:23 <gwern> (although I did understand a fair bit of main.hs and the audio files... which I had to rip out)
22:24:38 <sm> yes, I noticed there's a windows version with sound
22:27:06 <gwern> yeah. I can't imagine the sound worked too well though - I think well over half the sound files were corrupt or empty, and to call the sound modules 'a hack' or 'jerry-rigged' insults jerry cans and real hacks
22:31:21 <gwern> well, good night. if anything comes up, you can leave messages courtesy of good ol' lambdabot
22:31:24 <bos> @pl \r c -> r <$ char c
22:31:24 <lambdabot> (. char) . (<$)
22:32:27 <bos> @pl \c r -> r <$ char c
22:32:27 <lambdabot> flip (<$) . char
22:36:09 <bos> hmm, no ($>) in Control.Applicative
22:36:19 <sm> thanks gwern
22:41:22 <sm> I guess I can read IO Scene as "an action returning a Scene"
22:42:03 <sm> a Scene-generating action
22:42:12 <pjd> sm: right
22:42:46 <pjd> sm: fmap and >>= are like chaining callbacks/handlers to the action
22:43:31 <sm> neither are used in this program, as it happens
22:43:44 <BMeph> I have a little problem:
22:43:45 <sm> explicitly, anyway
22:45:00 <BMeph> I have a function with type a -> (b, a), and I want to use it to define two functions that give the separate answers of the pair from the original function.
22:45:38 <BMeph> Do I have to call the original function twice, or is there a clever Arrow-hack I can use?
22:46:38 <kmcallister> BMeph, you want functions of type a -> b and a -> a?
22:46:52 <BMeph> kmcallister: Exactly. :)
22:46:53 <kmcallister> g = fst . f; h = snd . f
22:47:11 <BMeph> ... exactly. :|
22:48:01 <conal> @ty (fst .) &&& (snd .)
22:48:04 <lambdabot> forall a a1 b. (a -> (a1, b)) -> (a -> a1, a -> b)
22:48:23 <BMeph> conal++ : o.O
22:48:27 <conal> :)
22:48:42 <BMeph> YES! Thank you, I'll try that!
22:49:45 <dolio> Is '(g, h) = ((fst .) &&& (snd .)) f' really preferable?
22:49:55 * shachaf thinks this is a bit @pl-y for its own sake. :-)
22:50:37 <dmwit> :t ((fst .) &&& (snd .))
22:50:37 <conal> dolio: doesn't look so hot in that context, but it's nicely composable.
22:50:38 <lambdabot> forall a a1 b. (a -> (a1, b)) -> (a -> a1, a -> b)
22:50:41 <BMeph> It compiles, not I just need to fix the next problem, to test - thanks again, conal! :)
22:51:08 <conal> BMeph: my pleasure.  and thanks for the karma.  now i'm at 3 :)
22:51:40 <sarehu> So I had a phone screen today, and got asked what data structure I'd use for a text editor buffer.
22:51:51 <sarehu> So I was like, "A pair of fingertrees! ^_^"
22:51:55 <sarehu> Sigh.
22:51:59 <dmwit> sarehu: Fog Creek?
22:52:08 <conal> btw, (fst .) looks obscure written that way, but if you think of (.) as unary and a counterpart to first and second, then it's clearer.
22:52:14 <BMeph> dolio: For my purposes, it is - I'm using the results of each individual part of the original function (properFraction, tbp) in an unfold-like function.
22:52:21 <sarehu> dmwit: heh
22:52:34 <dolio> Ah.
22:52:46 <conal> which is why i call unary (.) "result", which is actually a special case for functions of a more general tool.  See DeepArrow.
22:53:10 <shachaf> @ty fmap fst &&& fmap snd -- :-)
22:53:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a, b) -> (f a, f b)
22:53:15 <BMeph> conal: I.e., fst result. See, I am Trainable! ;)
22:53:31 <conal> BMeph: result fst && result snd
22:53:35 <conal> &&&
22:54:19 <BMeph> conal: ...D'Oh! exactly right. QQ
22:54:24 <conal> using . as infix interferes with seeing how wonderfully it can be composed with other .'s and with first, second , and fmap
22:54:32 <conal> BMeph: thanks for trying!
22:54:36 <dmwit> :t \f -> (fst . f, snd . f)
22:54:36 <lambdabot> forall a b a1. (a1 -> (a, b)) -> (a1 -> a, a1 -> b)
22:54:56 <sarehu> dmwit: why did you guess that (correctly)?
22:55:03 <conal> i was stunned to discover the trick with arbitrary compositions of result, first, and second.
22:55:16 <dmwit> sarehu: I probably even know which employee asked that question. =P
22:55:22 <sarehu> ahh
22:55:26 <dmwit> sarehu: I interned there last year.
22:56:35 <conal> shachaf: yes -- fmap is nicer to read.  i also like compositions of fmap with itself and first & second.  though second == fmap also
22:56:35 <Maddas> How was it?
23:00:59 <bos> well, second is fmap because of the seemingly arbitrary functor nature of ((,) a), right?
23:01:24 <conal> bos: yes.
23:01:53 <conal> which is also the writer applicative functor
23:01:59 <kmcallister> anyone here used SDL on ghc 6.8? hackage lists a build error and i get a different one when i try to cabal install SDL
23:02:09 <conal> unfortunately swapped from the writer monad
23:02:12 <bos> i've not seen an explanation why it's the second element that fmap gets applied to.
23:02:21 <bos> always wondered a bit about that.
23:02:39 <conal> bos: it's because of haskell's first-order matching
23:02:50 <conal> because (a,b) == (,) a b
23:02:52 <dolio> If it were the first, it'd have to be the (flip (,) a) functor.
23:02:54 <shachaf> conal: The Writer monad is the one that's unfortunately swapped. :-)
23:02:54 <bos> conal: so not some underlying category theoretic womblitude?
23:03:22 <shachaf> (And State.)
23:03:22 <conal> shachaf: agreed.  i spoke sloppily.  i meant unfortunate that they disagree.
23:03:36 <shachaf> It is.
23:03:41 <conal> bos: no -- just an implementation artifact, afaik
23:04:17 <bos> it can be hard to tell, when the documentation is notes from a summer school someone gave in germany in 1993.
23:04:31 <conal> bos: similarly, (a ->) is a functor but (-> b) isn't a cofunctor
23:04:38 <conal> bos: even though it is.
23:04:57 <conal> (hm.  sleepy sloppy talk)
23:05:17 <dmwit> (-> b) is a mathematical cofunctor, but not a Haskell Cofunctor.
23:05:19 <Cale> It's a cofunctor, but it's not an instance of Cofunctor. :)
23:05:25 <conal> dmwit: zakly
23:05:43 <bos> we don't have handy dandy standard typeclasses for those kinds of dual structures anyway.
23:05:44 <conal> so i put a Flip newtype into TypeCompose for things like that
23:06:09 <conal> bos: too bad.  Cofunctor is really nice for consumers.
23:06:14 <conal> like user interfaces
23:06:24 <conal> in other words for "views"
23:06:42 <conal> controller is a functor and view is a cofunctor.
23:06:54 <bos> i believe it.
23:07:19 <conal> producers are functors and consumers are cofunctors.
23:07:40 <bos> you ought to write something about the practicality of cofunctors. they're almost invisible to google.
23:08:10 <conal> bos: thanks.  good idea.  such a simple idea now that i know consumer/view == cofunctor.
23:08:13 <sclv> i'd flip over that.
23:08:29 <BMeph> So could we make Applicatives in the "right" order by using the Dual class?
23:08:32 <sclv> was also idly pondering if there was a use-case for a coapplicative
23:09:01 <conal> BMeph: what right order?
23:09:16 <conal> sclv: i've wondered also.  haven't found it.
23:09:39 <BMeph> conal: the (flip (,) b) way.
23:09:49 <sclv> well, if you haven't found it, i doubt i could. :-)
23:10:38 <sclv> i'm planning to write something up on how awesome the reader monoid is though, which is also perhaps underappreciated.
23:10:50 <conal> sclv: i love that monoid!
23:11:05 <conal> sclv: there's a very nice use in DataDriven
23:11:06 <sclv> all of hstringtemplate ended up being built around it.
23:11:08 <conal> @wiki DataDriven
23:11:08 <lambdabot> http://www.haskell.org/haskellwiki/DataDriven
23:11:35 <conal> sclv: an event handler has type a -> IO o
23:11:46 <conal> sclv: for a monoid o (typically ())
23:11:50 <sclv> i really need to make the library proposal to get the functor instance of the First and Last monoids.
23:12:06 <conal> sclv: then mappend combines callbacks.
23:12:21 <BMeph> I've assumed that Either a  was a Monad, but I'm wrong. Isn't it more than just a Functor?
23:12:23 <conal> sclv: and mempty is the empty callback.
23:12:35 <Cale> BMeph: it is a monad, but not an instance.
23:12:46 <Cale> BMeph: though it can be made an instance
23:12:47 <sclv> also, i'm not even sure why there's a last since unless i'm tripping (always very possible) then its the dual of first. in which case first could just be the default maybe monoid...
23:12:52 <bos> conal: that's very nice.
23:13:29 <BMeph> Cale: Okay, that's what I thought, but I couldn't find the instance, so I wondered.
23:13:29 <Cale> instance Monad (Either a) where return x = Right x; (Left e) >>= f = Left e; (Right x) >>= f = f x
23:13:33 <conal> bos: isn't it!  :)  the DataDriven representation of events is incredibly simple an general.
23:13:34 <dolio> The instance is in Control.Monad.Error.
23:13:45 <sclv> but that's just for string, no?
23:13:48 <Cale> Yes, but that instance is ever-so-slightly roken.
23:13:51 <Cale> broken*
23:13:58 <dolio> Yeah. A shame, really.
23:14:02 <Cale> It's for instances of Error
23:14:14 <Cale> (Which is really stupid)
23:14:15 <goalieca> what's this yi? does it work like vim
23:14:21 <conal> bos: it started out as code.  i kept discovering instances i could use, and when i was done, no more code.  just a simple type definition.  and much more general than when i started.
23:14:47 <bos> heh heh.  it's a lot of fun when that happens.
23:14:51 <Cale> The reason for requiring an instance of Error is so that fail can be implemented.
23:14:59 <conal> i think that's what Conor means by "types don't just contain data, types explain data"
23:15:14 <BMeph> And the Monoid relationship only applied to the Right side as well?
23:15:23 <dolio> More evils of fail. :)
23:15:31 <conal> building an entire (useful) implementation out of compositions of standard types is too fun!
23:15:59 --- mode: ChanServ set +o Cale
23:16:09 --- mode: Cale set +b AngelinaJolie26!*@*
23:16:17 <conal> Cale++
23:16:22 <conal> thanks, Cale!
23:16:32 <Cale> No problem
23:16:34 --- mode: Cale set -o Cale
23:19:50 <conal> Cale: would you mind telling me what steps you took to kick AngelinaJolie26?  i have the op permission but not the know-how.
23:20:06 <conal> Cale: or maybe point me to a how-to page
23:20:09 <Cale> I did /cs op #haskell
23:20:16 <Cale> which in my IRC client gives me ops
23:20:31 <Cale> (the /cs command is bound to sending chanserv a message)
23:20:54 <shachaf> conal: (/msg chanserv could also work.)
23:21:16 <Cale> and then  /mode #haskell +b AngelinaJolie26
23:21:39 <dblhelix> couldn't it be that she's just interested in Haskell? ;-)
23:21:48 <Cale> That's just a nick ban, so it could change its nick and get back in, but it's unlikely to do that.
23:22:20 <Cale> (seeing as it looks like a crapflooding robot, given the quits due to excess flood)
23:22:37 <jua> nick!ident@host ? is . * is .*
23:22:43 <jua> wouldnt the bot almost surely hcange its name? heh
23:23:11 <Cale> Most bots are not that smart :)
23:23:17 <dblhelix> regarding policy: what about bots written in haskell? shoud we cut those some slack or what? ;-)
23:23:18 <conal> Cale: and to release ops?
23:23:54 <Cale> Well, I usually do that through the menus in my client, but it's /mode #haskell -o Cale
23:24:08 <conal> Cale: thanks.  notes stashed.
23:24:16 <kmcallister> @hoogle glViewport
23:24:16 <lambdabot> No matches found
23:24:25 <kmcallister> @hoogle viewport
23:24:25 <lambdabot> No matches found
23:24:44 <Cale> conal: You can get more information on modes and such from freenode's site.
23:24:49 <b_jonas> what happen? someone's bot got kicked?
23:24:50 <shachaf> Cale: XChat also has /deop bound, by the way.
23:24:56 <Cale> ah, nice
23:25:18 <conal> Cale: i'll poke around on freenode also in my client (erc -- emacs-embedded)
23:25:19 <shachaf> Cale: (And /ban.)
23:26:19 <Cale> shachaf: yeah, it also has menus for banning if you right click on the person's nick, but it doesn't work for people who have left.
23:28:26 <Cale> http://www.codon.org.uk/~mjg59/freezer.png -- heh... I wonder what sort of state of mind the person who made this was in.
23:28:38 <Cale> There's got to be a story there.
23:28:51 <b_jonas> I can call my bot to join if you want to practice :)
23:28:51 <ricky_clarkson> Illinois?
23:28:52 <shachaf> Cale: Frozen? :-)
23:29:13 <kmcallister> Cale, one of the processes is called "[kbonghits]", i think that answers your question
23:29:21 <Cale> heh
23:32:27 <ebroder> I'm trying to compile ghc with readline support. I'm running ./configure with --with-readline=/sw (I have it installed through Fink), but Haskell doesn't seem to be linking against it. What am I missing?
23:32:36 <ricky_clarkson> Cale: That loaded using QuickTime for me, odd.
23:33:00 <Cale> ricky_clarkson: That is odd. It's just an ordinary png.
23:33:04 <ricky_clarkson> ..and now IE won't quit.  I don't really use IE, it's just that my terminal recently forgot my browser preference.
23:33:18 <kmcallister> ricky_clarkson, quicktime takes over PNG in IE because it does/did a better job rendering them
23:33:24 <ricky_clarkson> Ah.
23:35:26 <ricky_clarkson> Another reason not to use IE :)
23:37:16 <b_jonas> was that about back when people despised PNG because the browser didn't handle its alpha (transparency) channel (whereas GIF could only have one-bit alpha instead of gradual, and only 256 colors)
23:37:28 <b_jonas> that thing was riddiculous
23:38:05 <BMeph> Holy Moley, all of my Utility functions work! Yay! :)
23:38:17 <b_jonas> well, looking from years of times it is, at least
23:38:23 <b_jonas> and there was that patent issue as well
23:41:06 <BMeph> Well, I'm off to bed, then - see y'all in 6-and-a-half hours! :)
23:44:47 <conal> i'm off to bed also.  16 minutes until my birthday.
23:45:03 <sclv> cheers!
23:45:14 <kmcallister> conal: happy birthday :)
23:45:34 <conal> :)  thanks  :)
23:46:22 <ebroder> Does ghc's ./configure expect some argument other than --with-readline=/path to set the libreadline location?
23:51:04 <njbartlett> matthew_-: Ping
23:51:15 <njbartlett> matthew-_: Ping
23:56:51 <sm> happy birthday conal
