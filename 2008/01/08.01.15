00:00:02 <thetallguy> > floatToDigits 10 100.00
00:00:15 <lambdabot>  ([1],3)
00:00:16 <roconnor> Cale: and it is a nice excercise for them to implement integers (and they are shocked to find out you can ``implement'' integers).
00:00:22 <Cale> heh
00:00:31 <roconnor> Cale: I don't recall how they defined Nat.
00:00:51 <roconnor> Cale: I sort of assumed it was basically a newTyped Integer
00:01:01 <Cale> "What?! You can *implement* integers? Next you'll be telling us it's possible to implement rational numbers as well!"
00:01:07 <roconnor> Cale: since the interpreter is written in Haskell.
00:01:25 <roconnor> Cale: hey, they are first year students ;)
00:02:58 <Cale> :)
00:14:08 <radetsky> dons: did you ever post those hmp3 changes?
00:15:39 <dons> radetsky: oh not there yet :)
00:15:46 <dons> finishing off a talk for tomorrow about haskell
00:16:27 <dons> i'm comitted to updating it though
00:22:50 <roconnor> dons: you can have my talk about haskell. :)
00:22:56 <roconnor> save you the work. ;)
00:23:33 <andyjgill> night all. Good luck dons, I'm looking forward to your talk.
00:23:38 <Cale> dons: is it going to be recorded?
00:23:39 <Cale> :)
00:23:58 <Cale> http://www.marriedtothesea.com/011508/bring-me-the-drivemaker.gif :)
00:25:23 <dons> i'll probably post the slides (its about multicore programming)
00:27:33 * goalieca taking a class on multicore this semeseter
00:27:59 * goalieca will be interested
00:29:46 <roconnor> back in my day we didn't have ``classes'' on ``multicore''.
00:30:05 <roconnor> ... seriously, we only had one core per cpu.
00:30:07 <ivanm> roconnor: you didn't even have any classes at all? :o
00:30:17 <ivanm> but how many CPUs did you have? ;-)
00:30:23 <goalieca> heh: http://www.cs.sfu.ca/~fedorova/Teaching/CMPT886/Spring2008/syllabus.html
00:30:25 <lambdabot> Title: CMPT 886, http://tinyurl.com/32hypj
00:30:31 <roconnor> ivanm: on per box :(
00:30:35 <roconnor> one per box
00:30:49 <roconnor> even on the SGI octanes
00:31:11 <goalieca> that class has about 25 grad students.. which is as popular as they get
00:31:48 <ivanm> roconnor: did you have grad students back in your day? :p
00:32:02 <goalieca> he studied under plato
00:32:03 <mxc2> back in my day, our CPUs didn:t have 'cores'
00:32:05 <ivanm> heh
00:32:44 <mxc2> a 'CPU' was a room full of undergrads, who would execute machine code by hand
00:32:52 <ivanm> heh
00:32:56 <goalieca> heh. that's called a final exam
00:33:00 * goalieca had one of those
00:33:05 <goalieca> in first year
00:33:19 <mxc2> actually, i:m lying, i graduated in 2004
00:33:35 <goalieca> i graduated in october
00:33:39 <mxc2> the school had almost migrated away from 100% vacuum tube technology when i left
00:33:55 <mxc2> no joke, i went to penn and the main engineering server was ENIAC
00:33:58 <mxc2> and it was dog slow
00:34:44 <goalieca> my engineering school had a next server for vlsi stuff but was finally replaced with sun boxes by the time i got there
00:34:51 <goalieca> *to that class
00:54:48 <radetsky> anybody look at conjure lately?
00:58:53 <dons> `demanding` is cool,
00:58:54 <dons> fib n = (r + l) `demanding` strategy
00:58:54 <dons>   where
00:58:54 <dons>     l = fib (n-1)
00:58:54 <dons>     r = fib (n-2)
00:58:57 <dons>     strategy | n < 35    = () | otherwise = rnf r `par` rnf l
00:59:09 <dons> (parallelisation without mucking around in the innards of the code)
01:22:54 <radetsky> conjure's darcs repository is making me run tests when I try to record changes
01:23:02 <radetsky> anybody know how to make it stop?
01:23:42 <opqdonut> remove the commit-hook?
01:24:23 <doserj> --no-test?
01:24:55 <quicksilver> length considered harmful!
01:25:04 * quicksilver found two quadratic behaviour bugs on the train in.
01:25:12 <quicksilver> both caused by careless use of 'length'
01:25:13 <idnar> yeah, use width instead
01:25:13 <idnar> ;)
01:25:58 <radetsky> nm, figured it out
01:26:07 <radetsky> _darcs/prefs/prefs file
01:26:28 <radetsky> opqdonut: or was that what you meant?
01:32:09 <radetsky> :t ($)
01:32:11 <lambdabot> forall a b. (a -> b) -> a -> b
02:22:58 <blarz> @users
02:22:59 <lambdabot> Maximum users seen in #haskell: 454, currently: 402 (88.5%), active: 3 (0.7%)
02:25:19 <nornagon> wow, unicode has a foreign function interface symbol: ï¬ƒ!
02:27:38 <tibbe> nornagon: haha
02:27:53 <tibbe> probably just a typgraphic symbol
02:27:58 <tibbe> typographic
02:28:09 <tibbe> oh the irony of having a typo in the word typo
02:28:54 <nornagon> it is, yes
02:28:57 <nornagon> it's a ligature
02:54:51 <mux> omg, is Bulat opposed to any change in the haskell libraries?
03:01:51 <GNU\caust1c> jungs
03:02:02 <GNU\caust1c> ich muss euch vorwarnen, bzw um etwas bitten
03:02:13 <GNU\caust1c> uh
03:02:16 <GNU\caust1c> wrong chan :D
03:11:18 <sizur> @users
03:11:18 <lambdabot> Maximum users seen in #haskell: 454, currently: 405 (89.2%), active: 10 (2.5%)
03:12:53 <EvilTerran> ooh, new record
03:13:37 <EvilTerran> ...it'd be cool if @users had a timestamp attached to the "maximum users" number so you could tell when it happened =]
03:14:23 <ZoWiE> /?
03:14:37 <EvilTerran> slashwhat?
03:15:23 * EvilTerran wanders off
03:15:40 <funktio> @pl (\f g x -> f x (g x))
03:15:40 <lambdabot> ap
03:16:13 <funktio> ap?
03:16:22 <mauke> yes, ap
03:16:24 <daf> @source ap
03:16:25 <lambdabot> ap not available
03:16:29 <mauke> @src ap
03:16:30 <lambdabot> ap = liftM2 id
03:16:46 <funktio> ok
03:17:04 <EvilTerran> @pl \x -> all x (ing x)
03:17:04 <lambdabot> ap all ing
03:17:09 <EvilTerran> yeah, i know, it's terrible
03:17:34 <EvilTerran> funktio, here, it's the S combinator
03:17:48 <funktio> EvilTerran: yeah, I usually name it s in my own programs
03:17:49 <daf> EvilTerran: haha
03:17:51 <EvilTerran> it's using the (r->) monad, aka Reader
03:17:58 <EvilTerran> daf, :D
03:18:11 <EvilTerran> anyway. wandering!
03:18:57 <allbery_b> <EvilTerran> yeah, i know, it's terrible
03:19:03 <allbery_b> one might even say appalling...
03:19:19 <sizur> that max users happened two days ago i think
03:20:54 <sizur> :t ing
03:20:55 <lambdabot> Not in scope: `ing'
03:21:12 <mauke> :t ?ing
03:21:13 <sizur> @hoogle ing
03:21:13 <lambdabot> Data.String :: module
03:21:13 <lambdabot> Foreign.C.String :: module
03:21:13 <lambdabot> Data.ByteString :: module
03:21:13 <lambdabot> forall t. (?ing::t) => t
03:21:38 <sizur> eh?
03:21:47 <mauke> hmm?
03:21:54 <moonlite> sizur: it's a joke.
03:22:16 <Saizan> sizur: @pl don't care if a symbol is defined
03:23:24 <mauke> @pl don't care if a symbol is defined
03:23:24 <lambdabot> (line 1, column 12):
03:23:24 <lambdabot> unexpected reserved word "if" or "i"
03:23:24 <lambdabot> expecting variable, "(", operator or end of input
03:23:35 <sizur> lol
03:23:40 <mauke> @pl don't care whether a symbol is defined
03:23:41 <lambdabot> don't care whether a symbol is defined
03:23:51 <mauke> @pl \a -> don't care whether a symbol is defined
03:23:52 <lambdabot> flip (flip (flip (don't care whether) symbol) is) defined
03:24:05 <opqdonut> :D
03:24:13 <sizur> that's lisp!
03:24:30 <sizur> heresy! ;)
03:24:41 <opqdonut> @pl \x y -> flop y x
03:24:41 <lambdabot> flip flop
03:24:50 <sizur> lol
03:25:59 <sizur> @pl \f->(\x->all x (f x))
03:26:00 <lambdabot> ap all
03:27:22 <Deewiant> @unpl ap all
03:27:23 <lambdabot> (\ e -> all >>= \ b -> e >>= \ a -> return (b a))
03:27:44 <opqdonut> :D
03:27:49 <idnar> @unpl ap all ing
03:27:49 <lambdabot> (all >>= \ b -> ing >>= \ a -> return (b a))
03:28:04 <Saizan> @unpl (\ e -> all >>= \ b -> e >>= \ a -> return (b a)
03:28:04 <lambdabot> Unbalanced parentheses
03:28:09 <Saizan> @unpl (\ e -> all >>= \ b -> e >>= \ a -> return (b a))
03:28:09 <lambdabot> (\ e -> all >>= \ b -> e >>= \ a -> return (b a))
03:29:08 <sizur> :t all
03:29:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:29:15 <sizur> :t ap
03:29:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:29:27 <sizur> :t (<*>)
03:29:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:29:40 <sizur> :t ap all
03:29:41 <lambdabot> forall a. ((a -> Bool) -> [a]) -> (a -> Bool) -> Bool
03:29:58 <sizur> :t (all<*>)
03:29:59 <lambdabot> forall a. ((a -> Bool) -> [a]) -> (a -> Bool) -> Bool
03:30:18 <idnar> hey now, you're an all-star
03:34:26 <aleator> Hey. What is Text.HTML.BlockTable?
03:35:17 <sizur> @djiin (a -> Bool) -> [a]
03:35:17 <lambdabot> -- f cannot be realized.
03:40:19 <sizur> :t \f a b = if b then return a else fail "bla"
03:40:21 <lambdabot> parse error on input `='
03:41:11 <sizur> :t \f a b -> if b then return a else fail ""
03:41:11 <lambdabot> forall t a (m :: * -> *). (Monad m) => t -> a -> Bool -> m a
03:41:31 <sizur> is there any use in this function?
03:41:38 <mauke> no
03:41:47 <idnar> :t guard
03:41:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:41:52 <mauke> :t when
03:41:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:42:21 <idnar> :t \a b -> if b then return a else fail ""
03:42:21 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> Bool -> m a
03:42:25 <idnar> sizur: did you mean that function?
03:42:49 <mauke> :t \a b -> guard b >> return a
03:42:50 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => b -> Bool -> m b
03:44:29 <sizur> idnar: i'm trying to understand the intended meaning of "ap all"
03:44:53 <mauke> meaning?
03:46:09 <sizur> i dont understand the question, mauke are you asking what i mean by that, what meaning is, or are you implying there is no meaning at all in that expression?
03:46:59 <mauke> why do you think "ap all" has an intended meaning?
03:48:29 <titusg> out of the gazillion monad tutorials out there, can you recommend one that is good on _writing your own_?
03:48:36 <sizur> lol, i only now got what EvilTerran intended with ap all ing
03:49:12 <idnar> it's spelled wrong ;)
03:49:17 <sizur> titusg: look for monad transformers. let me dig up a paper on that
03:50:24 <sizur> titusg: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
03:51:22 <titusg> sizur, thanks
03:51:32 <sizur> titusg: that is if you already have an idea of what a monad is
03:52:07 <titusg> sizur, I do, but when I think about using my own I have a hard time picturing what return and >>= should be
03:52:43 <mauke> sometimes it's easier to think in terms of liftM and join than (>>=)
03:53:02 <mauke> e.g. for lists liftM = map and join = concat
03:53:09 <sizur> titusg: desugaring a few do's of several monadic functions should help
03:53:41 <titusg> >:t join
03:54:21 <titusg> hmmm, how does lambdabot give types?
03:54:24 <idnar> :t join
03:54:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:54:39 <idnar> :t liftM
03:54:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:54:52 <idnar> :t (>>=)
03:54:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:55:08 <sizur> @unpl join
03:55:08 <lambdabot> (\ b -> b >>= \ a -> a)
03:55:25 <mauke> a.k.a. (>>= id)
04:32:48 <ac> what would you call the following function?
04:32:50 <ac> foo :: (IArray a) => a -> a; foo a = ixmap (bounds a) (\(x,y) -> (y,x)) a
04:33:43 <dcoutts> ac: transpose?
04:33:58 <ac> isn't that already taken?
04:34:02 <ac> :t transpose
04:34:05 <lambdabot> forall a. [[a]] -> [[a]]
04:34:11 <ac> that's a good name though
04:34:17 <dcoutts> ac: you're allowed namespaces :-)
04:34:18 <opqdonut> transposeA?
04:34:25 <opqdonut> :P
04:34:47 <ac> transpose2DA... could that easily be generalized to n dimensions?
04:34:59 <ac> I guess not. The indexes are tupples
04:35:19 <dcoutts> @hoogle transpose
04:35:19 <lambdabot> Data.List.transpose :: [[a]] -> [[a]]
04:35:19 <lambdabot> Data.ByteString.transpose :: [ByteString] -> [ByteString]
04:35:19 <lambdabot> Data.ByteString.Char8.transpose :: [ByteString] -> [ByteString]
04:35:20 <opqdonut> yeah and the permutation to perform on the index tuple is not so easy to decide
04:35:24 <dcoutts> hmm
04:35:32 <dcoutts> @type Data.Graph.transpose
04:35:33 <lambdabot> Not in scope: `Data.Graph.transpose'
04:36:00 <dcoutts> bah
04:36:01 <dcoutts> @type Data.Graph.transposeG
04:36:02 <lambdabot> Graph -> Graph
04:36:18 <dcoutts> they should have called that simply transpose
04:36:37 <dcoutts> ac: Data.Graph.transposeG is basically the same as your function
04:37:34 <dcoutts> transposeG g = buildG (bounds g) (reverseE g)
04:37:34 <dcoutts>   where reverseE g = [ (w, v) | (v, w) <- edges g ]
04:38:37 <ac> dcoutts: maybe they were trying to avoid a name conflict
04:39:20 <dcoutts> ac: right, but there's no need since it should be imported qualified anyway
04:39:26 <ac> looks like nothing else collides, so that one collision would be extra annoying
04:39:48 <ac> is anybody else annoyed at the verbosity of the import qualified syntax?
04:40:36 <dcoutts> it's not very verbose
04:40:39 <ac> why not "import (Data.Graph as G, Data.Blah as B, Data.Array)"
04:41:30 <dcoutts> ac: because it only saves you 2 lines from something that was short to start with :-)
04:41:33 <mux> btw, I've realised the other day that if you have a line import Foo as F _without_ the "qualified" keyword, it seems to import the module in both the qualified and unqualified namespace
04:41:38 <mux> is this a haskell98 feature or just gHC?
04:41:48 <dcoutts> mux: haskell98 feature
04:41:49 <mux> comes in handy
04:41:51 <mux> okay
04:42:05 <dcoutts> you can even do self-imports
04:42:37 <mux> it's very nice since it allows you to use the unambiguous symbols without qualifying them
04:42:43 <dcoutts> right
04:42:53 <mux> ByteString considered nicer than B.ByteString :)
04:43:33 <dcoutts> I usually do:
04:43:37 <dcoutts> import qualified Data.Map as Map
04:43:38 <dcoutts> import Data.Map (Map)
04:43:59 <dcoutts> so I can Map.lookup but also foo :: Map x y
04:44:11 <dcoutts> rather than foo :: Map.Map.x y
04:44:22 <mux> yeah but why not just import Data.Map as Map ?
04:44:43 <dcoutts> because then I have to also qualify all the ordinary list functions
04:44:56 <dcoutts> List.map etc
04:45:04 <mux> oh right
04:45:10 <mux> makes a lot of sense
04:45:35 <dcoutts> the only time this all falls down is with very large libs like gtk, opengl etc which have internal structure
04:45:54 <dcoutts> since you cannot realistically import 100's of modules individually
04:46:03 <dcoutts> you have to re-export and import just one module
04:46:42 <dcoutts> but then you loose any internal structure and so such packages have to use silly naming conventions to mimic module-qualified names
04:51:22 <ac> it would be cool if modules could export qualified modules, so you could say "import qualified Gtk2hs as G" and then "G.foo.bar baz"
04:51:45 <dcoutts> ac: yes indeed, that's what I and others proposed
04:51:50 <ac> er "G.Foo.bar baz" where Foo is the module that Gtk2hs exports
04:51:54 <dcoutts> right
04:52:22 <ac> it wouldn't really require any syntax extensions
04:52:45 <ac> it would just be another thing you could add to your export list (a qualified name)
04:53:18 <mux> so how'd you do that syntactically? module Foo as F where ... ?
04:54:04 <ac> in Gtk2hs you'd have "module Gtk2hs (...., Foo, ...) where import qualified SomeModule as Foo ....
04:54:55 <dcoutts> ac: no, that has a meaning already, it'd have to be something like "module Gtk2hs (...., qualified module Foo, ...)
04:55:11 <ac> dcoutts: what meaning does that have? export everything in Foo?
04:55:27 <dcoutts> ac: yes, though you need to say "module Foo" in the export list
04:56:37 <ac> but what does just "Foo" in the export list do? Is that undefined?
04:59:25 <doserj> "Foo" means a datatype or class
05:02:56 <ac> doserj: I mean in the case that Foo is the qualified name of an imported module
05:06:01 <doserj> i'm not sure. I guess it does nothing
05:06:41 <doserj> (speaking of "module Foo", of course, where import qualified SomeFoo as Foo)
05:07:42 <Toxaris> ac: even if Foo is the qualified name of an imported module, it can still be the name of a type or type class
05:07:51 <Toxaris> ac: (at least I think so...)
05:08:15 <doserj> yes, that's why you have to say "module Foo", if you mean a module
05:08:46 <ac> ah I see. I guess dcoutts was right (not surprisingly) that you need "qualified". That makes it nice and explicit too
05:09:19 <ac> that would be a reasonable addition to the standard to make large scale programming just a little bit friendlier
05:12:31 <doserj> it seems reasonable, yes
05:22:54 <mightybyte> I'm looking at the haskell database libraries.  Can anyone give me some opinions on the pros and cons of the different ones?
05:24:53 <swiert> dcoutts: does cabal-install work when you're behind a http proxy?
05:25:09 <hpaste>  yitz pasted "Simple messageBox, inputBox, and questionBox in GTK2HS" at http://hpaste.org/5017
05:25:21 <dcoutts> swiert: please test, code was added to use a proxy the other day
05:25:33 <dcoutts> swiert: you'll need latest darcs version of cabal and cabal-install
05:25:43 <swiert> dcoutts: ok. I'll give it a whirl.
05:26:36 <Saizan> mightybyte: uhm, HDBC is better maintained, hsql works with mysql directly, haskellDB (which can use either as backend) is an higher-level interface based on the relational algebra
05:27:55 <ndm> Saizan: want to say that in a blog post, perhaps in slightly more detail?
05:28:06 <mightybyte> Saizan: Ok, sounds like a nice concise opinion.  Which of those has better documentation?
05:32:41 <sizur> Feuerbach: privet pioneru
05:33:11 <Saizan> mightybyte: i've used only the first two, they both have haddock docs.. hsql has a very minimal interface, so probably easier to learn
05:33:25 <Saizan> mightybyte: but i've not tried to build it on 6.8 yet
05:33:50 <mightybyte> Saizan: Ok, I think that's what I was looking for.  Thanks.
05:42:06 <swiert> does anyone know if darcs builds with 6.8.2?
05:43:25 <Igloo> swiert: darcs darcs does, I believe
05:43:48 <opqdonut> darcs darcs :D
05:44:14 <swiert> Igloo: hmm. I'm getting complaints during the configure about GHC.Handle.openFd...
05:44:30 <swiert> Google wasn't much help, I'm afraid. Igloo, do you know if it's been fixed?
05:44:40 <Igloo> I could be wrong; I haven't tried it myself
05:44:57 <swiert> Igloo: ok. thanks anyhow.
05:56:04 <swiert> dcoutts: cabal update crashes with "cabal: Maybe.fromJust: Nothing"...
05:56:16 <dcoutts> hmm
05:56:42 <Feuerbach> sizur: hi
05:56:43 <pejo> swiert, did you guys get more helping hands for epigram recently?
05:56:55 <dcoutts> swiert: what proxy url string are you using?
05:57:07 <hpaste>  swiert pasted "Cabal error" at http://hpaste.org/5018
05:57:37 <dcoutts> swiert: see uri2proxy in Hackage/HttpUtils.hs, that's the only use of fromJust in the proxy stuff
05:57:39 <swiert> dcoutts: I've set the "http_proxy" environment var.
05:57:54 <swiert> dcoutts: is there anything else I need to do?
05:58:02 <dcoutts> swiert: I'm not overly familiar with what this code is doing, I didn't write it :-)
05:58:37 <dcoutts> swiert: the reason I ask about the url is because we're using:
05:58:37 <dcoutts> (URIAuth auth' host _) = fromJust $ uriAuthority uri
05:59:09 <dcoutts> swiert: so I was wondering what assumption that is making about the url you use that fails
05:59:20 <dcoutts> swiert: so what url string are you using, so I can test
05:59:44 <dcoutts> I don't need to be able to use the proxy, just parse the string and look at the resulting URI data type
06:00:24 <dcoutts> swiert: so what value did you set the "http_proxy" env var to?
06:00:41 <swiert> dcoutts: "wwwcache.cs.nott.ac.uk:3128"
06:00:49 <swiert> dcoutts: maybe the port number is causing problems?
06:01:00 <dcoutts> swiert: I'll check
06:01:03 <swiert> pejo: not really - why do you ask?
06:02:13 <pejo> swiert, read Nils-Anders Danielssons homepage, it claims he went to Nottingham to do a postdoc, but no information on what he's working on. :-)
06:02:33 <quicksilver> swiert: error, that's not a URL
06:02:52 <quicksilver> swiert: http://wwwcache.cs.nott.ac.uk:3128/
06:02:53 <lambdabot> Title: University of Nottingham Web Caching Service
06:03:00 <swiert> pejo: Oh - he's coming to Nottingham. But he's funded by Graham Hutton's grant about reasoning about exceptions.
06:03:46 <dcoutts> swiert: dunno what the person writing the code was thinking :-) a uri like "foo@wwwcache.cs.nott.ac.uk" contains an authority, ie a username and/or passwd
06:04:00 <dcoutts> swiert: for some reason the code assumed that'd always be there
06:04:14 <dcoutts> swiert: I'll try and fix, I'll ping you when I've pushed a fix
06:04:16 <pejo> swiert, oh, that's nice too.
06:04:42 <swiert> dcoutts: No rush.
06:05:00 <swiert> dcoutts: thanks for looking into this.
06:05:19 <dcoutts> swiert: np
06:06:11 <doserj> dcoutts: doesn't uriAuhtority refer to both the username/password *and* the domain?
06:06:30 <dcoutts> doserj: hmm, I just noticed that, looking at the docs
06:06:38 <dcoutts> doserj: but try it, it gives Nothing
06:07:01 <doserj> what about quicksilver's suggestion?
06:08:11 <dcoutts> doserj: oh, yes "wwwcache.cs.nott.ac.uk:3128" is being parsed as if the host name were like http: or ftp:
06:08:41 <doserj> it parses the scheme as "wwwcache.cs.nott.ac.uk", right?
06:08:52 <dcoutts> yes
06:09:07 <dcoutts> swiert: so actually the code was right, but it's falling over at a mis-parsed url
06:09:16 <dcoutts> swiert: I'll improve the error message
06:11:20 <swiert> dcoutts: ok. ta.
06:13:07 <doserj> dcoutts: is it a bug in Network/URI.hs, that the uri-prser doesn't require "//" following the ":"?
06:13:26 <dcoutts> doserj: dunno if that's required or not
06:13:47 <quicksilver> it's not
06:13:56 <quicksilver> mailto:blah@doserj.com
06:14:01 <quicksilver> is a valid URI
06:14:07 <doserj> ah
06:18:14 <hpaste>  swiert annotated "Cabal error" with "(no title)" at http://hpaste.org/5018#a1
06:18:52 <swiert> cabal still doesn't seem to parse the portnumber of the proxy...
06:21:41 <Micio> Zdravim, je tu nekdo kdo umi cesky?:D
06:23:15 <Micio> please, I need very big help...
06:24:37 <sizur> Micio: what do you need?
06:25:43 <shachaf> quicksilver: Why is the // used anyway?
06:26:39 <quicksilver> shachaf: to indicate "host-part" rather than "path-part"
06:26:46 <quicksilver> this is specific to the http method
06:26:48 <sizur> doserj: no, it's not a bug. mail:bla@bla.com is uri
06:26:51 <quicksilver> not URLs in general.
06:27:22 <shachaf> quicksilver: Why is it used in file:?
06:27:49 <Deewiant> Wikipedia (http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax) just says "The hierarchical part of the URI is intended to hold identification information hierarchical in nature. Usually this part begins with a double forward slash ("//"), followed by an authority part and an optional path."
06:28:01 <sizur> it's a specific of the protocol. file protocol even uses ///
06:28:19 <quicksilver> shachaf: it's not, always. Sometimes it denotes "volume" or "disk" name
06:28:20 <shachaf> sizur: The third / is part of the path. :-)
06:28:28 <quicksilver> in which case /// denotes server name.
06:28:42 <Deewiant> it seems that some use // and some don't and it further seems that it's completely arbitrary
06:28:45 <quicksilver> or /// may be a an empty volume
06:28:54 <quicksilver> it's not arbitrary, but it is messed up
06:29:08 <ndm> on windows you get file:///c:/foo , which is kinda weird :)
06:29:14 <sizur> i'd say double slash is meant to mean global
06:29:36 <Deewiant> it seems arbitrary... telnet uses double slash as well, even though it's telnet://<user>:<password>@<host>:<port>
06:29:56 <Deewiant> OOTH you've got sip:<user>[:<password>]@<host>[:<port>] which doesn't use double slash, for instance
06:30:28 <quicksilver> telnet is the one that is aberrant
06:30:30 <quicksilver> ;)
06:30:31 <sizur> the part before the first ':' dictates
06:30:36 <quicksilver> it was probably designed before someone who didn't understand.
06:30:41 <quicksilver> by
06:31:07 <Deewiant> Tim Berners-Lee? :-P http://tools.ietf.org/html/rfc1738
06:31:12 <lambdabot> Title: RFC 1738 Uniform Resource Locators (URL)
06:31:51 <Deewiant> ahh, I get it
06:31:53 <Deewiant> sip is the aberrant one
06:32:05 <Deewiant> //<user>:<password>@<host>:<port>/<url-path> is the "Common Internet Scheme Syntax"
06:32:11 <Deewiant> and "The scheme specific data start with a double slash "//" to indicate that it complies with the common Internet scheme syntax.
06:32:34 <sizur> the //, /, /// are all protocol specifics.
06:33:03 <Deewiant> sure, but the idea appears to have been that if it starts with // you know that the rest of it is <user>:<password>@<host>:<port>/<url-path>
06:33:03 <quicksilver> Deewiant: by the time TBL wrote that, he was reduced to documenting the idiocies which had preceded it
06:33:19 <quicksilver> Deewiant: doesn't mean he invented everything there ;)
06:33:21 <Deewiant> possibly
06:33:27 <Deewiant> no, probably not :-)
06:35:00 <sizur> user:password...etc, that's a protocol specific too...
06:35:08 <sizur> you can make your own
06:35:54 <tibbe> how do I add a [(String, String)] to a Map without running into memory leak problems?
06:37:05 <tibbe> i.e. I want to do a foldl' correctly
06:37:26 <Saizan> ?type Data.Map.insert
06:37:28 <lambdabot> forall k a. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
06:37:30 <shachaf> tibbe: What's wrong with M.insert?
06:37:35 <sizur> fromList
06:38:03 <sizur> :t Data.Map.fromList
06:38:04 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
06:38:17 <Saizan> sizur: "add"
06:38:27 <tibbe> I remember reading a mailing list thread about problems with doing it correctly
06:38:42 <sizur> i take liberty in interpreting it as "the other add" ;)
06:38:44 <quicksilver> tibbe: how many items in the list you're adding?
06:38:54 <tibbe> maybe 100
06:39:00 <quicksilver> then stop worrying P
06:39:10 <quicksilver> if it's 100,000 then come back and thin about memory leaks
06:39:11 <tibbe> but the bigger point is I want to understand what's happening
06:40:26 <Saizan> map is strict in the structure, so foldl' should be enough to reduce it to normal form
06:41:54 <quicksilver> is fromList + union asymptotically more efficient?
06:42:02 * quicksilver tries to think
06:42:15 <quicksilver> I have a feeling it might be, depending on the sizes of m and n
06:43:18 <Micio> ach jo, tady mi asi fakt nikdo nepomuze. nechce nekdo napsat kratky opravdu kratky program za me? aspon kdyby jste mi rozumneli co vlastne chci
06:44:11 <vincenz> Micio: please speak english here
06:44:11 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
06:45:11 <Micio> vincenz: :D :( :(
06:45:40 <osfameron> yes, of course.  we should all speak czech.  how careless of us
06:45:58 <vincenz> If there is not a czech haskell channel already, I am certain you could start one
06:46:43 <Micio> czech chanell is not...
06:46:56 <vincenz> Well then be a leader and start one :)
06:47:03 <sizur> Micio: try to explain in english what you need
06:53:05 <stevan> i'm a bit puzzled by how this piece of code works: http://cdsmith.wordpress.com/2007/12/09/some-basic-stuff-the-writer-monad/ it seems to me as if only one tuple is passed to diagonal. where does it get the other from?
06:53:07 <lambdabot> Title: Some Basic Stuff: The Writer Monad « Sententia cdsmithus, http://tinyurl.com/3cfkwh
06:53:35 <Micio> I need short programme, where insert some method graph and this programme return how have these graph component... I know, it's for someone long work, but I don't understad this language...:(
06:53:57 <Saizan> ?type any
06:53:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:54:36 <sizur> Micio: what programming language do you know?
06:54:37 <Saizan> stevan: the other is passed by any, which picks it from the list
06:55:31 <Micio> I know C, pascal...
06:56:06 <Micio> and I started C#
06:57:00 <stevan> Saizan: from the first ps?
06:57:06 <sizur> Micio: is this a homework for you?
06:57:18 <Saizan> ?src ps
06:57:19 <lambdabot> Source not found. I feel much better now.
06:57:22 <Saizan> ?src any
06:57:23 <lambdabot> any p =  or . map p
06:58:37 <Micio> +- yes...
06:59:01 <Saizan> stevan: as you see, the first function any takes is applied to every element of the list (ps in this case), and then it checks if there's a True in the resulting list with or
06:59:52 <sizur> Micio: how much will you pay me to do your homework?
07:00:03 <quicksilver> that's a bit harsh
07:00:14 <Saizan> stevan: you know that you can partially apply a function and pass that as an argument?
07:00:17 <quicksilver> he's only asking for help (so far)
07:00:21 <sizur> well, he asked for a solution :(
07:00:31 <sizur> ok, i take that back
07:00:56 <sizur> Micio: sorry
07:01:38 <stevan> Saizan: starting to clear now.
07:01:58 <sizur> tongue can be a very ugly thing
07:03:09 <Saizan> > let equal x y = x == y; predicate = equal 5; in any predicate [1..6]
07:03:12 <lambdabot>  True
07:03:38 <Saizan> but, you can use (equal 5) without giving it a name:
07:03:53 <Saizan> > let equal x y = x == y; in any (equal 5) [1..6]
07:03:55 <lambdabot>  True
07:04:06 <stevan> Saizan: i get it now. thanks!
07:04:58 <sizur> Micio: try to explain your problem a little bit clearer?
07:05:56 <quicksilver> Micio's problem sounds a bit like static analysis
07:06:03 <quicksilver> if I understood him correctl
07:06:09 <quicksilver> something like analyse code to find a call graph
07:06:12 <sizur> Micio: an example will help
07:06:15 <Micio> My problem is this language....
07:06:16 <quicksilver> and spit out the maximal connected components?
07:06:45 <quicksilver> theere are three parts to that : (1) parse code (2) analyze call graph (3) find components.
07:06:49 <hpaste>  basvandijk pasted "time" at http://hpaste.org/5020
07:06:51 <basvandijk> Hello, is the following code on hpaste a good way to measure the time of the evaluation of an expression?
07:07:34 <sizur> what do you mean by components of a call graph?
07:07:56 <sizur> the call nodes?
07:07:58 <Micio> for example, insert square and point => return 2 components
07:08:33 <quicksilver> sizur: well, I was only guessing :)
07:08:34 <sizur> a count of nodes in a graph?
07:08:41 <Saizan> basvandijk: s
07:09:00 <basvandijk> Saizan: s?
07:09:18 <quicksilver> basvandijk: maybe
07:09:28 <Saizan> basvandijk: parts of the elements of the set are probably not completely evaluated
07:09:33 <quicksilver> basvandijk: how well it works depends on the details of the implementation of Set
07:09:43 <quicksilver> and the Ord implementation on strings
07:09:54 <quicksilver> I suspect you probably will force most of it
07:09:56 <BMeph> ?seen srid
07:09:56 <lambdabot> I haven't seen srid.
07:10:30 <sizur> Micro: insert A -> B -> C => 3?
07:11:25 <quicksilver> I'm sure you'll force all the file reading.
07:11:35 <Micio> i need return only number
07:11:35 <quicksilver> the only thing you might well not force is al the lower-casing
07:11:50 <quicksilver> only enough lower-casing to resolve the comparisons
07:12:20 <sizur> Micio: what do you mean by "graph"? is A -> B -> A a graph?
07:12:30 <quicksilver> so if "supercalifragilisticexpialadocious" is in your dictionary
07:12:41 <Tac-Tics> Does anyone have any idea why I would get an error message like this while installing a package from source?
07:12:41 <Tac-Tics> "setup: Package yi-0.3 can't be built on this system."
07:12:46 <quicksilver> and only "superc" is a common prefix of any other word
07:12:54 <quicksilver> then the other chars won't be toLowered
07:13:09 <Tac-Tics> (Setup configure didn't raise any errors, but Setup build throws "cannot be built")
07:14:00 <hpaste>  basvandijk annotated "time" with "(no title)" at http://hpaste.org/5020#a1
07:14:32 <basvandijk> If I do that then I will get complete evaluation right?
07:15:53 <quicksilver> basvandijk: nope. That just checks the length of each string.
07:16:01 <quicksilver> it doesn't do anythign about (C.toLower "a") thunks
07:16:05 <quicksilver> hidden away inside strings.
07:16:34 <basvandijk> quicksilver: oh yes ofcourse, length is polymorhic in the list it takes
07:17:17 <basvandijk> I gues if I 'ord' the chars in the words and sum them I will get complete evaluation
07:17:44 <sizur> @src length
07:17:44 <lambdabot> Source not found. Maybe you made a typo?
07:17:45 <Micio> Graph - is some objekts (point, abscissa, square, ...) well? and I can insert how I want these objekts...
07:18:18 <Micio> then A->B is graph
07:18:46 <quicksilver> basvandijk: at the cost of having done about 3x as much work as was orginally specified :)
07:19:19 <quicksilver> basvandijk: it's often best to just measure what you care about, rather than trying to measure 'complete' evluation.
07:19:25 <sizur> Micio: a two dimensional picture? or abstract symbols?
07:19:32 <basvandijk> well, my question was not really about the Set creation stuff but more about the 'time' function
07:19:38 <quicksilver> understood
07:19:44 <quicksilver> but this liability always applies
07:19:59 <mcproff_11459> Moin Moin ;-)
07:20:01 <quicksilver> that time function is entirely determined by the behaviour of 'seq' on x
07:20:28 <quicksilver> if you really want to time 'complete evaluation' you need either a DeepSeq
07:20:34 <mcproff_11459> is hier jemand der mit in meine bande will ? so mit 9000 punkten ?
07:20:49 <quicksilver> or a serialisation to something very solid like a ByteString.
07:20:49 <mauke> mcproff_11459: wrong channel
07:21:12 <sizur> mcproff_11459: welhe bande, welhe punkten?
07:21:24 <basvandijk> What is the general way of timing Haskell programs / expressions? Just using the linux command 'time'?
07:21:30 <Micio> when these graph insert?
07:21:36 <quicksilver> Hmm. We should have a band. "Dons and the Irrepressible Lambdas?"
07:21:46 <quicksilver> basvandijk: you've almost answered your own question.
07:21:49 <quicksilver> basvandijk: don't time an expression.
07:21:54 <quicksilver> it's nearly meaningless.
07:21:56 <quicksilver> time a program.
07:21:59 <quicksilver> that is meaningful.
07:22:06 <quicksilver> write a program which actually does something and time that.
07:22:13 <quicksilver> there is no problem with that approach :)
07:22:22 <basvandijk> quicksilver: ok thanks
07:24:27 <Japsu> @dice 1d40
07:24:27 <lambdabot> 1d40 => 15
07:25:15 <Micio> how I this question understand, then abstract...
07:25:15 <Japsu> @dice 20d70
07:25:16 <lambdabot> 20d70 => 753
07:25:31 <sizur> Micio: i dont understand. do you need to count subgraphics produced by drawing one graphic on top of another? or you simply need to count number of things in a data structure?
07:28:39 <dcoutts> @seen bringert
07:28:40 <lambdabot> I haven't seen bringert.
07:28:49 <sizur> Micio: number of inserts = answer?
07:30:10 <Micio> pls moment...
07:30:13 <sizur> Micio: A->B = 2;  A->B, A->C = 3;  A->B, B->A = 2?
07:30:25 <jedbrown> Tac-Tics: I had the same problem with `package cannot be built'.  I have a user named `haskell' that I use for building most Haskell stuff, but I was trying to build yi as me.  This problem vanished when I tried building as the `haskell' user, but the build still fails later.
07:31:47 <Tac-Tics> jedbrown: Thanks for the response. I saw that user, and had already changed it. It turned out I just needed to make clean first and it worked
07:32:41 <jedbrown> Tac-Tics: Ah, cool.
07:33:14 * jedbrown wonders when he will be able to quit using Emacs.
07:34:57 <sizur> jedbrown: hey! i just started yesterday!
07:36:13 <BMeph> Say, has anyone here looked at srid's "Regime Challenge"?
07:36:27 <BMeph> http://nearfar.org/x/regime/
07:36:27 <lambdabot> Title: Regime Challenge
07:37:11 <Micio> A, B, C is point or graph for you?
07:37:14 <jedbrown> sizur: Yeah, it mostly works great, but the management of state really annoys me at times.  It would be great to be able to roll back configuration changes.
07:38:42 <sizur> Micio: that's what i am asking ;) (A->B, B->C, C->A) a graph?
07:39:50 <dcoutts> @seen swiert
07:39:50 <lambdabot> I saw swiert leaving #haskell 5m 13s ago, and .
07:40:36 <dcoutts> @tell swiert I've pushed a couple patches for the cabal-install http proxy issue, including port number, could you re-test please?
07:40:36 <lambdabot> Consider it noted.
07:41:07 <Tac-Tics> @src gets
07:41:07 <lambdabot> Source not found. My pet ferret can type better than you!
07:41:54 <Micio> good, A,B,C,D is point, then A->B=1  ;  A->B A->C=1   ; A->B C->D = 2
07:42:54 <sizur> Micio: aha, separate graphs
07:43:13 <sizur> Micio: you need to count separate graphs
07:43:35 <byorgey> connected components
07:43:38 <sizur> Micio: do you have an input format?
07:44:13 <BMeph> dcoutts: You seem to have left out a module where you declare some templates.
07:44:29 <dcoutts> BMeph: hmm?
07:45:08 <sizur> Micio: or you can make any format you want?
07:45:19 <BMeph> dcoutts: I tried re-installing, and I'm getting a lot of 'not in scope: ___Template' messages.
07:45:34 <Micio> any
07:45:59 <BMeph> I figured that if you know where they're declared, you'll know whic one to access, in the meanwhile, I'll keep poking around in the code. ;)
07:46:19 <Micio> english is problem too  :D
07:46:27 <dcoutts> BMeph: re-installing cabal-install? you'd better @paste the message
07:46:33 <sizur> Micio: can you have A->B->A?
07:46:52 <BMeph> On the way...
07:47:12 <Micio> can be....
07:47:30 <hpaste>  BMeph pasted "cabal-install bomb-out" at http://hpaste.org/5021
07:49:14 <matthew-_> is there ever a case where at compile time, the compiler would have to deal with an infinite number of types?
07:50:59 <sizur> matthew-_: i'm pretty sure ghc detects a cycle in a recursive type definition
07:51:13 <matthew-_> yeah, it disallows infinite types
07:51:55 <matthew-_> I'm just wondering whether there's ever a case where in general (i.e. not limited to haskell), an infinite number of types needs to be catered for
07:53:38 <matthew-_> ahh. It occurs to me that were that the case, type checking would become non-terminating
07:53:50 <matthew-_> s/would/could/
07:55:45 <oerjan> matthew-_: i understand polymorphic recursion sometimes involves infinitely many types.  although they of course follow a pattern
07:56:29 <oerjan> in particular, those cases can prevent the compiler from doing all instance lookup statically
07:57:03 <oerjan> making it having to pass explicit dictionaries
07:57:44 <matthew-_> huh. is that not just absence of knowledge of what type you're dealing with, hence the dynamic lookup?
07:58:02 <oerjan> er no
07:58:20 <oerjan> you could have a value (infinite lazy of course) that used all of them
07:58:39 <oerjan> hm wait
07:59:03 * matthew-_ pkill -STOP matthew-_
07:59:05 <oerjan> ok you could pass the type itself, i vaguely recall jhc does something like that?
07:59:29 <oerjan> but isn't that just like passing a catch-all dictionary
07:59:37 <matthew-_> I have no idea. I should do some reading
07:59:38 <dcoutts> BMeph: looks like you're using the old cabal-install from hackage rather than the current darcs version
08:00:24 <BMeph> dcoutts: Ah, yes - Guilty as Charged. Let me try the "Direct Approach" ;)
08:01:02 <oerjan> anyway it would happen with things like data T a = T1 a | T2 (T [a])
08:01:27 <matthew-_> yeah, non-regular recursion in types
08:02:05 <matthew-_> grr, I really should have thought of that sooner given I've written basic arithmetic for types
08:03:32 <sizur> Micio: you need a map between a Node and it's SetId number. each time you insert A->B, you make all elements that have the same SetId of B equal to the SetId of A. if the element is new, you give it a new SetId. then you count unique SetId's in the end.
08:04:21 <sizur> should i implement it for him too?
08:04:41 <ptolomy> Has anybody tried interfacing OCaml code with Haskell? I bet that wouldn't work out well..
08:05:10 <osfameron> hmmm, doing the 'change "mare" to "colt" changing one letter at a time" problem seems much heavier on processing than I imagined
08:05:32 <byorgey> mart, malt, molt?
08:05:37 <osfameron> yeah, that sort of thing
08:05:47 <byorgey> that was pretty easy on my processing ;)
08:06:04 <osfameron> you are obviously a far superior graph single-shortest-path algorithm than I'm using
08:06:12 <byorgey> osfameron: hehe =)
08:06:23 <matthew-_> hence the attraction of slavery ;)
08:06:47 <byorgey> matthew-_: wha...?
08:06:52 <dons> ?users
08:06:52 <lambdabot> Maximum users seen in #haskell: 454, currently: 421 (92.7%), active: 17 (4.0%)
08:07:05 <byorgey> morning dons
08:07:32 <Micio> I dont need the map between a nodes, this just insert and return as text
08:09:08 <sizur> Micio: ok if you say so.
08:09:57 <dons> hey byorgey
08:10:32 <dcoutts> dons: I just updated cabal-install so it reports it's user agent as "cabal-install/0.4.2" or whatever it's current version is
08:10:57 <sizur> Micio: this map is not between nodes. it is to keep track of Node sets.
08:11:08 <dcoutts> dons: so when you're parsing the hackage apache logs we'll be able to find out when we get more than 50% of downloads coming from cabal-install rather than browsers
08:11:32 <dcoutts> dons: I'm defining that as success for cabal-install btw, getting 50% of downloads
08:11:49 <BMeph> dcoutts: I just ran it and the blurb on my screen just says:
08:11:59 <BMeph> "User-Agent: Cabal"
08:12:15 <dcoutts> BMeph: I only pushed the patch 2 seconds ago :-)
08:12:32 <BMeph> Ah.
08:12:39 <sizur> he's simply really fast
08:12:46 <BMeph> So is it still registering itself, or is it in now? ;)
08:12:47 <dcoutts> BMeph: I also toned down the verbosity so you'll only see all those messages with -v3
08:13:19 <Micio> for example> I insert A (A->B A->C) insert B (B->A B->C) insert C (C->B C->D) ..........
08:13:34 <dcoutts> BMeph: hmm? is what still registering itself? I don't follow
08:13:48 <BMeph> Never mind, I see the new patch.
08:15:34 <BMeph> Okay, looks good: "User-Agent: cabal-install/0.4.2"
08:16:07 <Micio> and then evaluated neigbhouring point
08:16:44 <Cin> how does tail recursion work in haskell?
08:17:14 <oerjan> Cin: quite well, but not always how you'd expect
08:17:31 <Cin> seeing as all you can do in haskell is recursion, i'd figure something fancy must be going on
08:17:57 <oerjan> well ghc does lots of fancy things
08:18:16 <Micio> if for next point not neighbour from last points, then there are 2 graph...
08:18:47 <Cin> oerjan: like what?
08:18:57 <dcoutts> Cin: tail recursion works in constant stack space as you'd expect
08:19:06 <Cin> oerjan: is info about this in haskell's docs, btw?
08:19:10 <Cin> oerjan: err ghc's
08:19:50 <oerjan> Cin: i'm sure, i only know about a tiny bit
08:19:58 <dcoutts> Cin: perhaps you should ask a more specific question
08:20:00 <Micio> I when that draw it for vision...
08:20:06 <quicksilver> no, I don't hink it is
08:20:09 <quicksilver> ghc's docs are user docs
08:20:18 <quicksilver> they don't mention the details of the compilation strategy.
08:20:20 <sizur> Micio: did you understand the algoriphm i wrote?
08:20:32 <oerjan> such as the rules pragmas for rewriting functions, and strictness analysis
08:20:45 <sizur> algorithm*
08:21:01 <oerjan> Cin: anyway any haskell compiler worth its salt will have tail call optimization
08:21:27 <matthew-_> what an odd expression that is. I wonder where it came from
08:21:27 <Cin> oerjan: ah, okay
08:21:33 <quicksilver> but it's a bit stranger than you might imagine.
08:21:34 <Micio> I thing yes...
08:21:40 <quicksilver> foo = do { a ; foo }
08:21:44 <Micio> I will must....
08:21:44 <quicksilver> this "works" efficiently
08:21:46 <Cin> mathrick: worth its weight in salt, perhaps? i dunno..
08:21:53 <quicksilver> but that can't be tail call optimization
08:21:57 <quicksilver> because that is not a tail call :P
08:22:15 * oerjan is probably horribly mangling some vaguely recalled metaphor
08:22:21 <matthew-_> right, some more STM questions
08:22:31 <ptolomy> Hey, so, an update. Yesterday I was in here bemoaning the minor loss of performance I was getting from modularizing my code.. but then later, as a result, I saw an optimization that laziness and purity make possible that will make my code clearer, safer, and significantly more efficient. For the bazillionth time, abstraction and good design trounce low level tweaking.
08:22:49 <sizur> Micio: is this what you need? http://en.wikipedia.org/wiki/Disjoint-set_data_structure#Tracking_the_connected_components_of_an_undirected_graph
08:22:53 <matthew-_> if you have two transactions that conflict and the commit "at the same time", you have this progress property which says one will commit and the other won't
08:23:00 <Cin> quicksilver: good point
08:23:13 <matthew-_> so, that suggests that one blocks the other
08:23:19 <quicksilver> matthew-_: nothing happens "At the same time" AIUI
08:23:37 <quicksilver> matthew-_: the commit mechanism is atomic a.k.a serialised a.k.a singlethreaded
08:23:40 <quicksilver> btu I could be wrong.
08:23:52 <matthew-_> quicksilver: from some of the papers I've read, multiple commits that don't involve the same TVars can commit concurrently
08:24:01 <matthew-_> so long as they're disjoint
08:24:26 <matthew-_> but I don't know whether that applies to the GHC implementation
08:24:54 <oerjan> Cin: the building up of thunks for laziness, as well as the laziness of data constructors, interfers with how tail calls work
08:25:12 <matthew-_> in either case, the fact is that before the commit, you have multiple threads running and then at the commit you have serialisation
08:25:45 <matthew-_> so either you have one "master" thread that actually does the work and there's communication with that thread whenever an atomic block ends
08:25:46 <Micio> again english :D Why this pages can't in czech language:D
08:26:02 <Cin> oerjan: hmm
08:26:04 <quicksilver> matthew-_: well in haskell we'd just bracket the actuall commit code witha global MVar
08:26:08 <matthew-_> or the individual threads have to block each other
08:26:21 <oerjan> so you have to look at what actually gets calculated.  the former can mean that what seems like tail calls ends up blowing the stack, a frequent trap with foldl (and the reason it's rarely used any more)
08:26:22 <quicksilver> matthew-_: I don't know for sure but I assumed the GHC impl took the simple way
08:26:56 <matthew-_> quicksilver: hmm. There's a recent paper in ICFP07 IIRC in which Harris et al rewrites the GHC runtime in terms of STM
08:27:05 <oerjan> the latter means that sometimes you don't _want_ tail calls, because you want to get at constructors as soon as possible.  this makes foldr more useful.
08:27:24 <sizur> Micio: if this is what you need, then what i wrote is your solution.
08:28:28 <matthew-_> quicksilver: this one (oops, not Harris) http://research.microsoft.com/~simonpj/papers/lw-conc/index.htm
08:28:28 <lambdabot> Title: Lightweight concurrency primitives for GHC
08:28:36 <oerjan> foldl' is the variant of foldl which tries to ensure thunks are evaluated before recursing, getting back the benefits of tail recursion again
08:28:41 <quicksilver> matthew-_: I was wrong.
08:28:51 <quicksilver> matthew-_: GHC can commit multiple transactions simultaneously.
08:29:05 <oerjan> so to understand tail recursion in haskell, i suggest looking at the folds and how they are used.
08:29:29 <Micio> moment, I must that one translate...
08:29:48 <quicksilver> matthew-_: there is a lock per TVar. Each committing transaction tries to get a lock on each TVar before going ahead.
08:30:09 <matthew-_> quicksilver: right, but to achieve progress, I think it follows that those TVars have to be consistently ordered
08:30:13 <quicksilver> (each TVar affected)
08:30:28 <matthew-_> in order to prevent two commits from knocking each other out
08:30:28 <quicksilver> hmm good point
08:30:41 <matthew-_> so, what I want to know, is is this just ordered by address?
08:31:16 <oerjan> > foldl (+) 0 [1..1000000]
08:31:19 <lambdabot>  Exception: stack overflow
08:31:44 <matthew-_> > (1000000 * 999999) / 2
08:31:45 <lambdabot>  4.999995e11
08:31:45 <oerjan> that _seemed_ tail recursive but actually builds a huge thunk
08:31:54 <oerjan> > foldl' (+) 0 [1..1000000]
08:31:55 <lambdabot>  500000500000
08:32:04 <matthew-_> > (1000000 * 999999) `div` 2
08:32:04 <lambdabot>  499999500000
08:32:11 <matthew-_> oh, it's +1
08:32:17 <matthew-_> > (1000000 * 1000001) `div` 2
08:32:17 <lambdabot>  500000500000
08:33:34 <oerjan> > foldr (\x l -> x:0:l) [] [1..1000000] -- fine because it gets at constructors quickly
08:33:35 <lambdabot>  [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0...
08:34:18 <oerjan> > foldr (+) 0 [1..1000000] -- as bad as foldl, i think
08:34:21 <lambdabot>  Exception: stack overflow
08:34:48 <quicksilver> matthew-_: that's certainly not the only possible interpretation.
08:34:59 <quicksilver> matthew-_: you could order transactions, not TVars
08:35:08 <oerjan> so usually you want either foldl' or foldr, dependent on whether the recursion produces lazy constructors or is strict evaluation
08:35:20 <quicksilver> matthew-_: and force a higher-numbered transactions to cede their locks to lower ones
08:35:47 <matthew-_> quicksilver: ew, that would require serialising the creation of transactions
08:35:57 <quicksilver> not really
08:35:58 <Micio> sizur: yes, I thing
08:36:07 <quicksilver> pointer address of some transaction identifier would do
08:36:18 <Micio> thik
08:36:21 <Micio> think
08:36:25 <matthew-_> of course, yes. you could use the address of the transaction log
08:36:27 <Micio> :D
08:37:36 <matthew-_> that's interesting. that really means that it's serialised anyway as the two mallocs for the new transaction logs can't really be concurrent
08:37:42 <quicksilver> matthew-_: however, I don't know how it really does work, and apparently neither does JaffaCake ;)
08:38:02 <quicksilver> you can have concurrent allocators, they just work from disjoint pools
08:38:09 <quicksilver> so the mallocs could be concurrent
08:38:16 <quicksilver> but there was serialisation at some earlier stage
08:38:19 <quicksilver> when the pools were allocated :)
08:38:20 <matthew-_> exactly.
08:38:33 <matthew-_> but then the same holds for thread creation anyway
08:38:37 <quicksilver> right
08:38:49 <quicksilver> and you might allocate a bit of pool at thread creation time.
08:39:13 <quicksilver> I don't know if GHC has a concurrent allocator but I assume it must,
08:40:12 <ndm> quicksilver: i'd have thought that was expensive...
08:40:23 <matthew-_> well of course the RTS has a fixed number of OS threads
08:40:26 <ndm> quicksilver: you could easily set it up to have separate pools (or regions of one pool) per thread
08:40:50 <sizur> :t maximum
08:40:57 <lambdabot> forall a. (Ord a) => [a] -> a
08:41:03 <sizur> shouldnt that be Maybe a?
08:41:22 <matthew-_> sizur: no. why do you think it should be?
08:41:24 <mux> > maximum []
08:41:25 <lambdabot>  Exception: Prelude.maximum: empty list
08:41:32 <mux> it just throws an exception in that case
08:41:44 <sizur> @src maximum
08:41:44 <lambdabot> maximum [] = undefined
08:41:44 <lambdabot> maximum xs = foldl1 max xs
08:41:51 <sizur> undefined is not an exception
08:42:00 <mux> whatever, you get the point
08:42:12 <mux> no need for a Maybe a if the empty list is handled this way
08:42:15 <sizur> it halts the program
08:42:33 <sizur> there is no way to recover
08:42:47 <mux> yes, yes, this is totally beside the point
08:42:54 <sizur> really?
08:43:01 * Corun got 26 of 28 in the haskell test. 
08:43:08 <matthew-_> is it just me or do others generally dislike the way in which Maybe is used to deal with failure throughout the standard libraries. Would (MonadPlus m) => m a not be better?
08:43:15 <Corun> = A+++++ ^_^
08:43:19 <mux> it doesn't change the fact that if maximum handles empty lists this way, it is expected that it won't return a Maybe a
08:43:30 <matthew-_> Corun: you still got some stuff wrong though ;)
08:43:32 <zipola> sqrt (((x1 - x2) ** 2) + ((y1 - y2) ** 2))   The variables are of type Int. Gives  "No instance for (Floating Int)" error. How to fix?
08:43:38 <Corun> Yes, well :-P
08:44:02 <mux> zipola: fromIntegral
08:44:03 <dons> Corun: well done :)
08:44:17 <Corun> :-)
08:44:20 <eyeris> Could someone take a look at this and let me know where I went wrong? http://hpaste.org/5015
08:44:21 <matthew-_> Corun: any choice quotes from ajf?
08:44:22 <dons> Corun: so you're now hooked on haskell? :)
08:44:22 <mux> > let x = 10 :: Int in x**2
08:44:29 <lambdabot>   add an instance declaration for (Floating Int)
08:44:29 <lambdabot>     In the expression: let x...
08:44:31 <mux> > let x = 10 :: Int in fromIntegral x**2
08:44:32 <lambdabot>  100.0
08:44:36 <mux> zipola: see?
08:44:39 <sizur> mux: say again?
08:44:46 <zipola> mux, thank you.
08:44:51 <Corun> "KA CHING!"
08:45:15 <Corun> "If it does what it say on the tin" (when talking about recursion and stuff)
08:45:24 <mux> zipola: I think I would just use ^2 here though
08:45:29 <matthew-_> lol. I really can't wait until I get to mark hundreds of scripts... how does he stay sane through it all?
08:45:52 <Corun> The only interesting quote he wrote on my test was "(Wow)" because I did one of the functions as awesomely
08:45:52 <zipola> mux, ^ is used with integers more often?
08:45:54 <mux> zipola: that would relieve you from passing all those Int's to fromIntegral, but then you'll still need one for the sqrt call
08:45:57 <mux> zipola: yes
08:46:00 <mux> :t (^)
08:46:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:46:03 <mux> :t (**)
08:46:03 <lambdabot> forall a. (Floating a) => a -> a -> a
08:46:28 <mux> so, in the case of (^), you see the exponent is expected to be an integral, thus you don't need to use fromInttegral
08:46:52 <Corun> We had to write "lookUp". And a precondition was that the thing was always lookupable  so I jsut did fromJust . lookup
08:46:55 <Corun> ^_^
08:47:09 <byorgey> Corun: heh, nice =)
08:47:37 <Corun> Twas pro ^_^
08:47:44 <Corun> Anyway, I must dash.
08:47:47 <Corun> Later everyone.
08:47:56 <hpaste>  Lemmih annotated "Trouble with State" with "State fix." at http://hpaste.org/5015#a1
08:48:17 <mux> > let (x1,x2,y1,y2) = (1,2,3,4) :: (Int,Int,Int,Int) in sqrt (fromIntegral ((x1 - x2) ^ 2 + (y1 - y2) ^ 2)))
08:48:17 <lambdabot> Unbalanced parentheses
08:48:30 <mux> > let (x1,x2,y1,y2) = (1,2,3,4) :: (Int,Int,Int,Int) in sqrt (fromIntegral ((x1 - x2) ^ 2 + (y1 - y2) ^ 2))
08:48:31 <lambdabot>  1.4142135623730951
08:48:39 <mux> zipola: how does that look?
08:48:48 <Lemmih> eyeris: There we go.
08:49:48 <zipola> mux, just what I needed.
08:52:05 <eyeris> Thank you Lemmih
08:52:25 <dons> more distro packages of current ghc will help haskell open source adoption, guys.
08:52:29 <dons> its a recurring theme -- http://khuang.blogspot.com/2008/01/tiling-window-manager.html
08:52:30 <lambdabot> Title: Links, links, links: Tiling Window Manager
08:52:44 <dons> (xmonad == "hard to build") -- due to a toolchain that's not preinstalled :(
08:52:52 <eyeris> Lemmih how is liftIO different from lift?
08:52:59 <dons> we need to get ghc binaries on every machine -- then toolchain resistance will be gone :)
08:53:20 <eyeris> Both work, and the type signatures are essentially the same
08:53:24 <Tac-Tics> eyeris liftIO allows for IO optimization
08:53:26 <Deewiant> eyeris: more optimized specifically for IO, no semantics difference
08:53:31 <eyeris> ok
08:53:32 <Igloo> eyeris: liftIO bubbles a computation all the way up to the IO monad; lift only goes up one level
08:53:54 <Deewiant> cool, didn't know that
08:55:12 <Tac-Tics> > ask 55
08:55:14 <lambdabot>  55
08:55:19 <Tac-Tics> @src ask
08:55:19 <lambdabot> Source not found. Are you on drugs?
08:55:22 <matthew-_> quicksilver: I'm not sure I can see how ordering by anything other than the tvar address would work
08:55:29 <eyeris> so I needed a liftIO inside that do block because it is running inside the StateT monad?
08:55:52 <Tac-Tics> What monadreader monad does "ask 55" make use of?
08:55:57 <matthew-_> reader
08:56:05 <matthew-_> MonadReader
08:56:05 <Deewiant> @hoogle ask
08:56:06 <lambdabot> Control.Monad.Reader.Class.ask :: MonadReader r m => m r
08:56:06 <lambdabot> Control.Monad.Reader.Class.asks :: MonadReader r m => (r -> a) -> m a
08:56:06 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
08:56:21 <matthew-_> quicksilver: based on address of the TVar, it's quite simple - you have what you've already taken and keep going until you've taken everything you need or collide
08:56:59 <quicksilver> matthew-_: I agree that seems the obvious way but JaffaCake seemed to think that's not how it was :)
08:57:06 <quicksilver> it remains possible he is mistaken.
08:57:18 <matthew-_> quicksilver: but if you don't use the TVar address, I can't see how you can believe that you still have what you've taken (if you see what I mean)
08:57:32 <matthew-_> agh, maybe I'm just going to have to read some code
08:57:39 <quicksilver> I think you might :)
08:57:45 <quicksilver> if you do find out how it works, let me know.
08:58:03 <dons> popl highlights, http://programming.reddit.com/info/65jya/details
08:58:10 <matthew-_> given the number of publications on STM, you'd have thought this kinda stuff would be well known
08:58:44 <matthew-_> just shows how academics concentrate more on greek letters than describing what's actually going on
08:58:54 <dons> stupid academics
08:59:01 <dcoutts> oi!
08:59:04 <dcoutts> :-)
08:59:16 * dons laughs from "enterprise land" mwhaha
08:59:25 * JaffaCake throws greek letters at matthew-_
08:59:35 * matthew-_ stabs them with a pointer
08:59:46 <quicksilver> sizur: why do you say there is no way to receover
08:59:53 <quicksilver> sizur: and why do you say this is not an exception?
09:00:00 <quicksilver> sizur: these things you say, they are not true!
09:00:10 <TuringTest> apple keynote starting roughly...now...
09:00:21 <dons> JaffaCake: how heavily has `par` sparking been optimised, do you know?
09:00:24 * quicksilver watches apple's servers fall over from the reloads, 1.. 2.. 3..
09:00:28 <dons> is there room to make `par`s cheaper?
09:00:32 <JaffaCake> dons: it's pretty quick
09:00:48 <JaffaCake> writes into a CPU-local circular buffer
09:00:49 <dons> not if you do O(n^2) sparks :)
09:00:52 <quicksilver> dons: I believe you can get a 33% space saving with "pa = par"
09:00:59 <dons> ok. cool.
09:01:13 <JaffaCake> I'm sure there's room to improve it, but probably not dramatically
09:01:20 <dons> ok, that's what i wanted to know.
09:01:28 <matthew-_> quicksilver: that's the funniest thing I've heard all day
09:01:30 <dons> has anyone had a go at dropping some `par` into ghc itself?
09:01:59 <dcoutts> JaffaCake: how does par differ from forkIO ?
09:02:04 <JaffaCake> dons: no, but ghc has some nasty side effects lurking, and things would probably go wrong
09:02:09 <dons> ah yes.
09:02:34 <JaffaCake> we did parallelise ghc for the haskell workshop paper a couple of years ago, but it wasn't very stable
09:02:46 <dons> right, but that was explicit forkIO, wasn't it?
09:02:52 <quicksilver> matthew-_: happy to be of service, although I fear you must live in a boring place :)
09:02:53 <JaffaCake> dcoutts: par has type a -> b -> b
09:03:02 <gbacon> @karma- side-effects
09:03:03 <lambdabot> side-effects's karma lowered to -1.
09:03:06 <JaffaCake> @type Control.Parallel.par
09:03:08 <lambdabot> forall a b. a -> b -> b
09:03:17 <Cale> @karma- side-effects
09:03:17 <lambdabot> side-effects's karma lowered to -2.
09:03:17 <matthew-_> quicksilver: coming from someone who works in the City?!!
09:03:21 <quicksilver> ;)
09:03:23 <quicksilver> touche
09:03:26 <dcoutts> JaffaCake: I know, I mean underneath in the impl, is it lighter weight than forkIO or share the same machinery
09:03:28 <dons> i'm giving a talk today about the multicore programming in haskell.
09:03:40 <JaffaCake> oh, it's much lighter weight
09:03:42 <dons> `par` is definitely exciting :) i love getting 370% cpu on 4 cores
09:03:49 <JaffaCake> it doesn't create a thread, just saves a pointer to the thunk
09:04:09 <dons> dcoutts: there's a list of thread sparks -- a job list, that get picked up and run if there's free threads, iirc
09:04:13 <matthew-_> right, if we work at it, I'm betting we can get more people to watch dons' talk, that Steve Jobs religous-rant
09:04:21 <matthew-_> s/that/than/
09:04:30 <JaffaCake> dons: I'd love to collect some of your parallel examples, we always need more benchmark examples
09:04:39 <JaffaCake> urk, I have to go
09:04:41 <Cale> matthew-_: Get a video camera on it! :)
09:04:50 <dons> JaffaCake: ah ok. i'd love to push on this stuff some more. (`par` for the shootout prograams , for example)
09:04:55 <dons> i'll see what i can do
09:04:59 <JaffaCake> yeah, great
09:04:59 <dcoutts> JaffaCake: so what does it not need that forkIO needs that makes it so much lighter? it'a always pure so no MVars and blocking etc, no threadid, what's the significant thing?
09:05:14 <JaffaCake> par is just a suggestion
09:05:17 <Micio> sizur: Could you tell me if or when are you going to write the program? I'd be really grateful
09:05:19 <dons> you don't necessarily get a thread, dcoutts
09:05:19 <quicksilver> forkIO definitely starts a lightweight thread
09:05:27 <dcoutts> dons: but if we can get cabal to do make style stuff in parallel and for multiple packages we should get loads of parallelism without needing ghc itself to compile in parallel
09:05:33 <quicksilver> par just pushes a thunk onto a list of "things to maybe do, sometime"
09:05:43 <dons> though we need more thunks then!
09:05:52 <dons> damn this ghc , optimising away all my expensive thunks
09:06:00 <JaffaCake> dcoutts: I'll follow up on this tomorrow, if you haven't sorted it by then
09:06:10 <dons> i've got cores for them now -- but the simplifer wiped them out :)
09:06:16 <quicksilver> it doesn't optimise them away entirely, it stuffs them down the side of the cushions of your sofa
09:06:26 <quicksilver> that's where I always look when I'm missing some small thunks
09:06:36 <dons> oh, that's good advice
09:06:40 * ndm wonders if supercompilation could do parallel stuff
09:07:09 <ndm> i'm pretty sure supercompilation can automatically do unboxing and strictness already, but parallel would be a completely new direction :)
09:07:15 <matthew-_> lol. MVar and IORef both implement Eq. That surely is pointer equality. So if you can do pointer equality, why do they not also implement Ord ?
09:07:50 <matthew-_> actually, don't answer that.
09:07:53 <ndm> matthew-_: if a pointer is moved during GC, its address changes (for Ord), but same values stay the same
09:08:00 <ndm> too late!
09:08:18 <matthew-_> ndm: well, I at least arrived at the same answer as you
09:08:18 <quicksilver> despite ndm's objection, I'd still like an Ord instance for them
09:08:23 <quicksilver> I think there is even a bug report for it
09:08:46 <ndm> quicksilver: but its additional work...
09:08:49 <Cale> matthew-_: That is actually a good point.
09:08:52 <ndm> i.e. expensive
09:09:07 <Cale> matthew-_: It's kind of hard to make a Set of IORefs currently, for instance.
09:09:08 <quicksilver> it is, yes
09:09:10 <dcoutts> quicksilver: how would you order them?
09:09:16 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2004-June/006278.html
09:09:18 <lambdabot> Title: [Haskell-cafe] Ord (IORef a)?, http://tinyurl.com/24ygok
09:09:20 <quicksilver> dcoutts: I don't care :)
09:09:22 <ndm> you'd probably have to add an Id field for IORef, then uniquely add to them in newIORef
09:09:30 <quicksilver> dcoutts: as long as I can put them in a map, that's all I want.
09:09:40 <quicksilver> there are other uses too
09:09:42 <quicksilver> cycle detection
09:09:50 <dcoutts> quicksilver: then you can do that yourself, (Ident, IORef)
09:09:50 <ndm> actually, is trivial to do, and you could do data OrdIORef a = OrdIORef Int (IORef a)
09:09:55 <Cale> quicksilver: Well, you can put them in a Map, you just can't currently index a Map by them.
09:10:02 <quicksilver> Cale: s'what I meant
09:10:12 * ndm wants Eq over functions
09:10:26 <matthew-_> ndm: yeah, I think there's a bug report for that too...
09:10:27 <dcoutts> ndm: heh heh
09:10:40 <matthew-_> I'm just trying to remember basic GC strategies. Is GC really likely to reorder pointers?
09:10:53 <matthew-_> (and I realise "likely" isn't quite the guarantee needed...)
09:10:59 <ndm> matthew-_: a copy collecting one is unlikely to
09:11:10 <dcoutts> ndm: it's fine if domain and co-domain are finite and domain is enumerable
09:11:11 <ndm> even generational copy collecting is unlikely to
09:11:40 <ndm> dcoutts: you mean only for dull functions. if i wanted that property i'd just use a linear-bounded Turing machine ;)
09:12:05 <matthew-_> ndm: it's called your computer - finite memory and all that ;)
09:12:06 <ndm> actually, compacting one could well move them
09:12:16 <Cale> Or more generally if the domain is compact.
09:12:20 <ndm> matthew-_: i have a TM drive attached
09:12:36 <Cale> (Like, if it's infinite sequences of booleans.)
09:12:45 <matthew-_> ndm: but it's what you do with it that counts
09:13:15 <ndm> matthew-_: i spend all day solving the halting problem (well, not anymore, but i used to)
09:13:31 <Cale> I wonder if we should have a Compact class for that purpose.
09:13:34 <pejo> ndm, you're essentially merging functions with supercompilation. Intuitively that gives me the feeling that you're removing parallellism.
09:14:01 <dcoutts> pejo: quite a few optimisations do remove parallelism
09:14:06 <ndm> pejo: i'm wondering if you could do something supercompilation to add them, not the current form of sc, but something related
09:14:11 <matthew-_> Hey, I wonder if this means that you can't implement STM in purely in Haskell
09:14:28 * quicksilver slaps google for re-enabling web history against his specific instructions.
09:14:29 <Cale> (for types t such that if Eq s, then it's possible to decide whether two functions t -> s are equal.
09:14:32 <Cale> )
09:14:48 <dcoutts> pejo: particularly taking advantage of strictness can remove opportunities for parallelism
09:15:01 <pejo> dcoutts, oh, definitely. Strength reduction introduces data dependencies for example.
09:16:01 <matthew-_> TVar is similarly Eq but not Ord
09:16:20 <byorgey> Cale: what methods would a Compact class have?
09:16:23 <quicksilver> matthew-_: it doesn't mean you can't, it just means you'd need to wrap everything up
09:16:53 <matthew-_> quicksilver: ahh I see yes - you'd have to manage the heap of TVars explicitly
09:19:08 <pejo> dcoutts, care to elaborate that last thing? Brain isn't working currently.
09:19:41 * ndm sees dcoutts closing his trac bug, jumps for joy
09:19:53 <dcoutts> ndm: the -v one?
09:19:59 <ndm> dcoutts: yep
09:20:05 <dcoutts> heh heh
09:20:08 <ndm> i don't think i put my name on it
09:20:32 <dcoutts> ndm: btw, you win the "most trivial cabal bug report ever" award
09:21:04 <Philippa> has someone filed one completely empty but for "I don't like it" yet?
09:21:20 <ndm> dcoutts, thanks :) - although is quite a serious issue, since i wanted to report another bug with a -v\inf trace
09:21:53 <dcoutts> pejo: that's what I gathered from a nice paper "Feedback Directed Implicit Parallelism" at ICFP last year
09:22:05 <dcoutts> ndm: what was the other bug?
09:22:06 <ndm> that paper was cool
09:22:09 <dcoutts> yeah
09:22:24 <ndm> dcoutts, i may have given up reporting it when the -v annoyed me...
09:22:36 <ndm> or may have solved it after i got a -v trace, my memory is faded
09:22:45 <dcoutts> heh heh, do you recall what it was about at all?
09:22:49 <ndm> nope
09:23:03 <ndm> oh, it might have been filepath and cpphs and ghc's cpp
09:23:10 <ndm> in some wacky combination that doesn't work
09:23:17 <ndm> but i can't remember which combination
09:23:17 <dcoutts> I'm sure that's true
09:23:28 <dcoutts> ndm: ah well, at least we've removed that barrier for your reporting further bugs :-)
09:23:41 <ndm> one of the CPP things reorders the #include file completely wrongly
09:23:51 <ndm> oh, and only applies to haddock'ing it as well
09:23:57 <ndm> and sometimes disappears if you reconfigure
09:24:07 <dcoutts> ndm: cpp is pretty borked, I'd like to move to exclusively using cpphs for haskell code in cabal
09:24:24 <ndm> dcoutts, do so!
09:24:37 * ndm predicts a GPL argument arising...
09:24:38 <dcoutts> ndm: though it does not help that cpphs is gpl and so ghc folk do not want to distribute it
09:24:42 <dcoutts> right
09:24:54 <ndm> yeah, its much better to violate the LGPL license than follow the GPL
09:25:34 <dcoutts> ndm: and we'll have to call out to cpphs rather than just calling the lib since we cannot very easily mix the lgpl cpphs lib with bsd3 cabal lib
09:25:57 <malcolmw> I don't really understand people's problem with the GPL, especially since they are just using cpphs as an executable, not a library
09:26:08 <dcoutts> which I fear will make things slower than using the gcc cpp
09:26:11 <ndm> dcoutts, really? can you not link into a lgpl library?
09:26:14 <pejo> dcoutts, they 'profile' the program to figure out dependencies between thunks, and 'spark' new computations based on that profiling information?
09:26:16 * ndm thinks thats just not accurate
09:26:22 <ndm> pejo: yep
09:26:42 <ndm> dcoutts, use it as a library in Cabal, and see if malcolmw sues you - my guess is that he won't
09:26:54 <dcoutts> ndm: well, we cannot tell everyone the cabal lib is bsd3 if they are also bound by the lgpl if they link to it
09:26:57 <ndm> if he does, we just knee cap him at the next FITA :)
09:27:06 * matthew-_ wishes all code was under the gpl
09:27:24 <Philippa> dcoutts: you can tell people the source is, no?
09:27:29 <osfameron> artistic license ftw
09:27:29 <ndm> this linking thing is meaningless under Haskell, i think, its a case of ancient technology fighting with lawyers - the best way to restrict progress!
09:27:57 <Philippa> matthew-_: make communism work outside software and sure, fine by me
09:28:27 <matthew-_> Philippa: ok. First I shall need a brief but thorough stint at genocide, followed by a rigourous eugenics program
09:28:41 <matthew-_> so long as we take man out of the equation, it might just work
09:28:56 <osfameron> do goats like free software?
09:29:01 <dcoutts> malcolmw: I don't understand it either, but GHC HQ try to keep far away from GPL code, probably due to their employer
09:29:49 <ndm> dcoutts, but i think the concensus is that with the LGPL and GMP they are violating it
09:29:55 <malcolmw> yes, MS has a pathological dislike of freedom in software :-)
09:30:04 <dcoutts> malcolmw: at the minimum it prevents GHC HQ working on that code, and if it's an important part of the system then that's problematic
09:30:06 <ndm> general concensus, of course, i'm not convinced and I care even less
09:30:17 <ndm> dcoutts: really? can they not even hack on GPL code?
09:30:26 <dcoutts> ndm: on GPL or LGPL
09:30:38 <doserj> ndm: they cannot evel *look* at the code
09:30:42 <cjb> ndm: they aren't allowed to look at it.
09:30:59 <dcoutts> ndm: on windows they might be violating it if it's not possible to relink ghc with a user-updated GMP
09:31:03 <ndm> thats just brain dead
09:31:05 <cjb> malcolmw: and a pathological distrust of their employees.
09:31:10 <dcoutts> ndm: on linux it dynamically links with gmp so it's fine
09:31:34 <ndm> dcoutts, ah, so its fine to violate the GPL as long as its on Windows?
09:31:41 <dcoutts> ndm: nope
09:31:42 <pejo> malcolmw, isn't ghc under bsd3 license? That's hardly a restrictive license.
09:32:04 <dcoutts> it's never fine to violate a licence unless you're the copyright holder in which case you can do whatever you like :-)
09:32:08 <Philippa> pejo: free vs Free
09:32:32 <Philippa> if you're the copyright holder you don't /need/ a license so you can't violate them
09:33:07 <malcolmw> BSD3 is only partially free, GPL guarantees freedom
09:33:18 <dcoutts> Philippa: though it's often polite to follow one's own licences, eg releasing source with binaries you distribute :-)
09:33:21 <blarz> malcolmw: freedom for whom?
09:33:34 <dcoutts> oh, please lets not start this argument
09:33:35 <Philippa> dcoutts: that's more that there's no point in using the GPL if you don't, no?
09:33:36 <cjb> malcolmw: A less incendiary way to say that is "BSD cares about individual freedom, and GPL cares about societal freedom."
09:33:39 <dcoutts> its well trodden
09:34:11 * malcolmw regrets lighting the blue touch paper
09:34:52 <dcoutts> the point here is whether we can use all our favourite software together in one distributable platform
09:35:00 * matthew-_ sprays lighter fluid into the room and shuts the door
09:35:03 <dcoutts> ie ghc+cabal+cpphs+hsclour etc etc
09:35:24 <thetallguy> ndm: you couldn't see the images through PlanetHaskell?
09:35:33 * Mr_Awesome lights a cigarette
09:35:38 <matthew-_> we just need the FSF to poach the GHC HQ from MSR
09:35:50 <thetallguy> ndm: It worked for me.  One more mystery to probe.
09:36:02 <quicksilver> given teh choice between working for SPJ and working for RMS, I know what my decision woudl be.
09:36:09 <quicksilver> And I'm an avowed GPL fan :)
09:36:33 <dcoutts> malcolmw: so we should discuss with JaffaCake if the cpphs license will be a real problem or one that we can live with, it'd be great to replace cpp for .hs code and have cppery be done consistently
09:36:35 <matthew-_> quicksilver: my solution would mean you'd work for both...
09:37:00 <ndm> thetallguy: i couldn't see them even from your blog originally
09:37:15 <malcolmw> GPL protects the rights of the author, BSD protects the rights of code thieves.  Is that incendiary enough? :-)
09:37:22 <dcoutts> malcolmw: eg at the moment the flags we use for cpp is a mess, it's different for different ffi processors and it's different for ghc vs nhc
09:37:47 <malcolmw> dcoutts: I have discussed the license of cpphs with JaffaCake many times before.  MS simply will not wear it.
09:37:55 <cjb> malcolmw: hm?  surely it protects the rights of the users, and denies any privilege to the author.
09:37:56 <Philippa> malcolmw: my usual counterexample is situations where code is "content" - computer games being a good example
09:38:01 <cjb> malcolmw: but apart from that, sure.
09:38:09 <ndm> the important thing is that software licenses between people who actually want to cooperate should not be something driving things apart
09:38:24 <dcoutts> malcolmw: eg since one can use ghc to de-cpp something, ghc applies all the cpp-options and other stuff from the package and many packages rely on that
09:38:31 <cjb> malcolmw: the tactful way to say *that* part is "BSD doesn't give you more freedom, it gives you more *power* over people, and not all power is just."
09:38:32 <cjb> or something.
09:38:45 <thetallguy> ndm: bizarre.  Thanks for the feedback.  I'll try and figure out why
09:38:47 <dcoutts> malcolmw: but that means things like hsc2hs have to use ghc as their cpp and we have to pass -package blah etc etc
09:39:13 <dcoutts> malcolmw: it's a big soupy mess, and we often mix C cpp-options with haskell cpp-options
09:39:50 <ndm> thetallguy: it works from planet here
09:39:56 <dcoutts> malcolmw: the solution imho is to make cabal find all the cpp options and to always use cpphs for haskell and haskell-like code (ie ffi pre-processors)
09:39:57 <ndm> may have been my machine giving issues
09:40:18 <byorgey> thetallguy: was that you with the picture of the sunset + dolphin?
09:40:22 <Philippa> a lot of computer games these days really couldn't exist under a GPL-like IP model. Probably not even if you had a sufficient guaranteed flat-rate income for everyone so those who'd be working on them didn't have to worry about money
09:40:27 <ndm> dcoutts, if cabal depended on the cpphs library, would that be an issue?
09:40:43 <malcolmw> dcoutts: I agree that using cpphs would be a good solution - and there are no technical issues preventing it, only political ones
09:40:44 <ndm> and can MS distribute a library someone else wrote under LPGL?
09:40:45 <dcoutts> ndm: yes because then the Cabal lib would not be BSD3, it'd be LGPL
09:41:04 <ndm> dcoutts, not convinced, can't be it BSD using an LGPL library?
09:41:17 <dcoutts> malcolmw: but this requires nhc, hugs etc to keep package databases, so we can remember what cpp options, include dirs etc to use when compiling dependent code
09:41:33 <byorgey> thetallguy: I couldn't see the pictures either, just little squares... but I right-clicked and chose "view image", and then I could see them fine
09:41:39 <matthew-_> what about if someone at GHC HQ / MSR was on the comittee for a conference and reviewed papers which contained code. That code was later released under the GPL.
09:41:52 <dcoutts> ndm: sure, the Cabal code itself is still BSD3 but anyone who uses the Cabal lib is still bound be the terms of the LGPL, so it's effectively become LGPL
09:41:56 <Philippa> matthew-_: then they're not bound by the GPL
09:42:02 <ndm> dcoutts, how?
09:42:10 <matthew-_> Philippa: simply because there's no license on the paper?
09:42:22 <Philippa> and they thus never agreed to/accepted it, yes
09:42:27 <ndm> matthew-_: you assign copyright on the paper to the conference, usually
09:42:28 <cjb> Philippa: Sure.  So, one argument is that artistic/entertainment works aren't as technically vital and don't need to live to the same standards.  You might be surprised to hear that RMS largely agrees with this.
09:42:52 <matthew-_> ndm: sure. Though I'm not sure eg easychair et al make that totally clear...
09:43:01 <Philippa> cjb: yeah. Thing is, if all the infrastructure they need to live on's GPLed up then what else're they gonna do?
09:43:02 <dcoutts> ndm: if Cabal links to a LGPL lib and you link your code to the Cabal lib then your program contains the LGPL object code and you must be bound by that code's license, you cannot circumvent the licence by adding a wrapper layer.
09:43:11 <sjanssen> I thought GHC wasn't GPL because of the byzantine linking requirements -- do we know for a fact that MSR forbids GPL?
09:43:11 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
09:43:28 <ndm> dcoutts, the license requires you to be able to rebuild Cabal using an alternative implementation of cpphs?
09:43:34 <malcolmw> dcoutts: Cabal can have a BSD licence and link against cpphs which is LGPL, without a problem.  Since ghc distributes sources for these libraries in any case, I don't think the licence is a technical obstacle
09:43:39 <cjb> Philippa: I don't really like the phrase "to live on".  It dramatically overstates the amount of money someone needs to live with.
09:43:57 <dcoutts> ndm: yes and all the other terms of the LGPL
09:44:16 <cjb> Philippa: Besides, even right here we're talking about LGPL, not GPL.  It's hardly the case that the FSF pushes for GPL on absolutely everything.
09:44:17 <Philippa> cjb: read an implicit [in reasonable comfort and health] into it
09:44:17 <malcolmw> dcoutts: anyone can upgrade the cpphs package, independenly of other packages, so the LGPL is satisfied
09:44:25 <ndm> dcoutts, the terms of an LGPL library only apply to that library, and you must be able to replace that library in the thing using it - that is it
09:44:45 <dcoutts> malcolmw: it affects ghc binaries that they distribute
09:44:47 <ndm> i.e. cpphs is bound under LGPL, cabal is bound under the "must be able to replace cpphs" bit only
09:44:52 <Philippa> cjb: no, but I've dealt with "all the game libs should be GPL!" advocates before
09:45:05 <cjb> Philippa: Ah.  I'm not one of those.
09:45:12 <ndm> dcoutts, how? they have the source code publically available
09:45:32 <cjb> sjanssen: I'd be somewhat surprised if it's true.  I worked on an MSR-funded GPL project once.
09:45:33 <Philippa> and I tend to think that BSD's a perfectly reasonable license for things aiming that way
09:45:36 <cjb> sjanssen: MSR != MS in many ways.
09:45:37 <malcolmw> dcoutts: oh, so ghc itself is statically linked against packages is it?  not dynamically?
09:45:57 <thetallguy> ndm: these should work for sure: http://stockwits.com/Photos/DolphinJumping/
09:45:58 <lambdabot> Title: DolphinJumping
09:46:00 <cjb> Philippa: Sure.  Again, as the FSF says, GPL and BSD are both fine free software licenses.  There isn't really a controversy here.
09:46:12 <dcoutts> ndm: look at it this way, I claim my lib is BSD3, then you'd assume that you only need to read and abide by the BSD3, but that's not true, you also have to abide by the LGPL, so effectively my lib is now under the intersection of the two licenses
09:46:16 <sjanssen> cjb: exactly what I figured, thanks
09:46:16 <ndm> thetallguy: i saw them now, when i just went back to plaent - cool photos by the way
09:46:38 <quicksilver> dcoutts: unless of course, what I choose to do with it is excise the lgpl parts and make a derived work from the bsd parts
09:46:42 <ndm> dcoutts, thats not true, you still only have to abide by the BSD, plus you have to leave cpphs replaceable
09:46:54 <dcoutts> malcolmw: ghc statically links against the ghc library, the ghc library uses Cabal and if Cabal used the cpphs library then...
09:46:55 <quicksilver> dcoutts: at that point, I'm bound only by bsd bit (obviously)
09:47:19 <ndm> we could always just fork ghc to gplhc :)
09:47:20 <dcoutts> quicksilver: sure, if you cut out the dep on the LGPL lib then you'd only be bound by the BSD3
09:47:46 <thetallguy> ndm: okay.  I think maybe blogspot has a bug, because I did nothing in the meantime.  Perhaps it's time to switch to that Haskell blogging software with the terrible name
09:48:12 <ndm> thetallguy: may have been my machine as much as anything...
09:48:23 <ndm> thetallguy: or a very temporary hosting server glitch
09:49:01 <Philippa> cjb: except that license conflicts carry on. Sorry, but the FSF's say so isn't the final word
09:49:08 <dcoutts> malcolmw: it's not all that consistent however since there's also readline which is probably statically linked in the windows binaries
09:49:47 <dcoutts> and readline is GPL, not even LGPL
09:49:58 <ndm> thetallguy: works on blogspot now for me as well
09:50:08 <dcoutts> which means ghc already has to be GPL really
09:50:16 <ndm> dcoutts, isn't that a rather blatant violation, even if it just dynamically links in?
09:50:17 <dcoutts> which is interesting :-)
09:50:22 <dcoutts> ndm: yes
09:50:29 <malcolmw> dcoutts: when I point this out, I'm told that ghc HQ wants to reduce deps on GPL code, not increase them
09:50:32 * oerjan thought ghc didn't come with readline on windows
09:51:07 <matthew-_> I suspect there are many MS(R) projects which have similar violations
09:51:13 <pejo> malcolmw, the work on linking against libedit instead of readline points in that direction thoguh.
09:51:26 <osfameron> reverse engineer readline in pure haskell, problem solved
09:51:33 <sjanssen> '/win3
09:51:35 <Philippa> dcoutts: I was under the impression the windows implementation does something else instead
09:51:37 <matthew-_> this is such a complete f***ing waste of manpower
09:51:40 <jwprox> I'm trying to teach myself Haskell and I've come up with a program that basically takes in a list of numbers and returns only even numbers. Does anyone know the most efficient way of doing that? I'd like to compare my results against someone who knows what they're doing and I have a feeling a pro could do it in a one liner.
09:51:44 <malcolmw> personally, I'd love it if ghc were GPL, but the binaries it produces are entirely unencumbered
09:51:45 <cjb> Philippa: Right, but I wanted to make sure we know that the people carrying on conflicts by making things inappropriately GPL'd aren't doing so because the FSF or free software philosophy tell them to.  They're just people making annoying decisions.
09:51:59 <Micio> does anybody have sizur's contact?
09:52:04 <byorgey> > filter even [1..10]
09:52:06 <lambdabot>  [2,4,6,8,10]
09:52:06 <dcoutts> Philippa: oh ok, but I expect the linux binaries still depend on readline
09:52:09 <cjb> malcolmw: same as GCC, right?
09:52:14 <byorgey> jwprox: how about that? =)
09:52:27 <jwprox> byorgey: Good grief there is a built in function!
09:52:31 <cjb> byorgey must be a pro :)
09:52:33 <ndm> if they use readline anywhere, at all, they are GPL - simple
09:52:42 <Philippa> jwprox: interact (show . filter isEven . read), fill in isEven and add a type annotation if necessary?
09:52:50 <byorgey> jwprox: there sure is =)
09:53:01 <dcoutts> ndm: particularly if they distribute binaries that need it to work
09:53:18 <byorgey> Philippa: isEven already exists in the Prelude as 'even'
09:53:19 <Deewiant> > filter ((==0).(`rem` 2)) [1..10]
09:53:20 <lambdabot>  [2,4,6,8,10]
09:53:22 <ndm> dcoutts, even if they use the source
09:53:31 <Philippa> cjb: it's a bad idea to act as if "free software philosophy" is one coherent whole, unfortunately
09:53:33 <BMeph> dcoutts: E.g., lambdabot?
09:53:34 <ndm> dcoutts, i mean even if they distribute the source
09:53:38 <dcoutts> ndm: that's a good deal less clear cut
09:53:50 <Philippa> they do indeed do it due to "free software philosophy", they've just reached different conclusions about it
09:53:52 <ndm> i don't think so
09:54:07 <cjb> Philippa: Fair enough.
09:54:30 <dcoutts> ndm: a ghc tarball that can be compiled and linked to readline probably complies with the terms of the gpl anyway even though it is not under the gpl
09:54:33 <malcolmw> dcoutts: if cpphs were dual licensed - LGPL and BSD, but specifying that any patches submitted must be under the LGPL, would that be a solution?
09:55:03 <dcoutts> malcolmw: that any patches submitted must be under LGPL and BSD, yes.
09:55:39 <dcoutts> malcolmw: that bit is not a license term though btw
09:55:41 <ndm> malcolmw: the way i work hoogle is that all patches must be BSD, but Hoogle is GPL, however i hold all the GPL patches so can relicense that at whim
09:55:44 <malcolmw> or maybe just the "must-be-re-linkable" exception to the LGPL would be sufficient
09:56:24 <ndm> malcolmw: i would have thought that would have been sufficient
09:56:39 <ndm> (legally, but lets face it, we are dealing with politcally)
09:56:58 <dcoutts> malcolmw: from a practical pov it might not matter, for the sake of dependencies we probably have to use cpphs as a program rather than a lib
09:57:31 <Igloo> malcolmw: IANAL etc, but AIUI, BSD | LGPL == BSD
09:57:39 <dcoutts> malcolmw: and ghc hq don't seem to have quite so much of a problem with distributing gpl programs, as opposed to libs that ghc links to
09:57:47 <Igloo> And BSD | GPL == BSD too
09:57:51 <vincenz> Igloo: could you use any more mnemonics?
09:57:53 <ndm> dcoutts, once cabal install has been out for a few years, we can actually forget worrying about dependencies :)
09:58:23 <dcoutts> ndm: you mean we can require cabal-install to install cabal-install ;-)
09:58:28 <phlpp> Setup.hs: Yi/Syntax/Haskell.x: no alex preprocessor available
09:58:29 <malcolmw> ghc hq have always refused to distribute cpphs, whether as program or library.
09:58:33 <ndm> dcoutts, sounds like a plan :)
09:58:42 <dcoutts> malcolmw: ho hum
09:58:46 <phlpp> where the hell is this ominious alex preprocessor hiding?
09:58:49 <phlpp> i mean which library?
09:58:58 <dcoutts> phlpp: it's a program, get it from hackage
09:59:02 <dcoutts> cabal install alex
09:59:05 <malcolmw> http://www.haskell.org/alex
09:59:06 <lambdabot> Title: Alex
09:59:15 <phlpp> ok, because it's not mentioned in the dependencies
09:59:50 <dcoutts> phlpp: we have a relatively new mechanism for specifying deps on build tools, previously they were unspecified
10:00:48 <phlpp> ok
10:00:58 <ndm> dcoutts, will there be a GHC 6.8.3 with cabal install for windows?
10:01:13 <ndm> since cabal install is much more exciting than anything else likely to be in 6.10...
10:01:27 <dcoutts> ndm: no, because cabal-install needs a newer version of the Cabal lib
10:01:28 <jwprox> Are there any recommended text books for learning Haskell. Or are  you just as well off researching online via tutorials?
10:01:34 <bos> aren't views supposed to be in 6.10?
10:01:51 * bos would be excited about views
10:01:52 <ndm> dcoutts, does that mean we only get cabal install in over a year?
10:02:01 <dcoutts> ndm: we can easily distribute cabal-install binaries
10:02:02 <byorgey> jwprox: Graham Hutton's book seems to be highly recommended.
10:02:12 <jwprox> byorgey: Once again, thank you
10:02:16 <dcoutts> ndm: and people can upgrade the Cabal lib if they like
10:02:18 <ndm> dcoutts, that would be fantastic, i did try and install it but there were so many dependencies...
10:02:28 <byorgey> jwprox: it depends on your background and learning style.  I learned just from online stuff, but for some people a textbook would be better.
10:02:32 <dcoutts> ndm: only two, zlib and http
10:02:33 <ndm> upgrading cabal is easy enough, but probably a bad idea for average users
10:02:41 <doserj> dcoutts: and cabal
10:02:44 <phlpp> hey byorgey :>
10:02:45 <ndm> i started dep chasing and gave up quickly...
10:02:47 <phlpp> what's up dude?
10:02:55 <byorgey> hey phlpp =)
10:03:12 <byorgey> jwprox: what is your programming and mathematics background?
10:03:36 <phlpp> yet another haskell tutorial is btw. an excellent tutorial
10:03:44 <phlpp> except for the monad part (that's _my_ opinion)
10:03:58 <thetallguy> ?seen igloo
10:03:58 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 6m 10s ago.
10:04:11 <jwprox> byorgey: I'm a systems engineer / programmer. I've only worked in imperative languages though..
10:04:11 <Valodim_> ?seen lambdabot
10:04:11 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #gentoo-uy, #curry, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #
10:04:11 <lambdabot> haskell, #ghc and #darcs
10:04:33 <Valodim_> scannedinavian?
10:04:47 <Vq^> Valodim_: indeed
10:04:48 <thetallguy> igloo: I don't suppose you've updated the packaging for the cabal package?
10:05:02 <ricky_clarkson> There were 12 lines of Haskell here yesterday, now there are 400,000 lines of Java.  Who the hell is Steve Yegge?
10:05:05 <jwprox> byorgey: My mathematical education topped out at Statistic I
10:05:23 <byorgey> jwprox: ok. well, I'd say it's just your personal preference then.
10:05:34 <thetallguy> SyntaxNinja: same question to you.  I'm going to hack it myself today if not.
10:05:45 <Igloo> thetallguy: It's in the ghc6 package
10:05:55 <byorgey> jwprox: there are many good online resources, so if you like that sort of thing, you can certainly do well without getting a textbook.
10:06:16 <jwprox> byorgey: Yeah, its just a matter of reshaping the grey matter to think differently about programming I think
10:06:23 <byorgey> jwprox: yes, that's the key =)
10:06:30 <Deewiant> jwprox: http://haskell.org/haskellwiki/Tutorials is of course a good place to start
10:06:48 <byorgey> jwprox: and feel free to ask lots of questions here =)
10:06:53 <jwprox> Deewiant: Yup, I've been hitting those up pretty heavily :)
10:06:54 <HairyDude> is there a reasonably standard "mutable" graph library? (by mutable I just mean it supports efficient deletions, not that it's actually mutable)
10:06:56 <Deewiant> and if none look particularly appealing you can have a look at the books at http://haskell.org/haskellwiki/Books
10:07:02 <thetallguy> igloo: ah, I'd missed that switch.  Okay.  I think that gives me a catch 22 but I guess I can fake it.
10:07:23 <jwprox> byorgey: Yeah I'm impressed at the amount of activity here
10:07:41 <jwprox> byorgey: And peoples eagerness to help ;)
10:08:08 <phlpp> yep, this was one of the biggest surprise when i got into haskell (not long ago :D
10:08:15 <byorgey> jwprox: yes, this channel is pretty unique I think =)
10:08:20 <Deewiant> HairyDude: Data.Graph is one, of course, no idea regarding its efficiency though
10:08:25 <phlpp> such a big, helpful and vrey active community, that's just great
10:08:48 <HairyDude> Deewiant: yeah, it doesn't fit, cos to delete edges you have to destroy and rebuild it, which really isn't efficient :)
10:09:04 <Deewiant> :-)
10:10:18 <phlpp> @src cos
10:10:18 <lambdabot> Source not found. Just try something else.
10:10:21 <phlpp> hehe
10:10:25 <phlpp> @index cos
10:10:25 <lambdabot> Prelude
10:10:28 <HairyDude> ah, fgl
10:10:30 <phlpp> eh?
10:10:33 <oerjan> @src Floating
10:10:33 <lambdabot> class  (Fractional a) => Floating a  where
10:10:33 <lambdabot>     pi                                                      :: a
10:10:33 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
10:10:33 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
10:10:33 <lambdabot>     (**), logBase                                           :: a -> a -> a
10:10:36 <phlpp> :t cos
10:10:38 <lambdabot> forall a. (Floating a) => a -> a
10:11:03 <Deewiant> HairyDude: isn't fgl the same as Data.Graph?
10:11:11 <HairyDude> not sure
10:11:33 <Deewiant> ah, no. Data.Graph.Inductive is fgl-5.4.1.1, Data.Graph is containers-0.1.0.1
10:11:40 <Deewiant> or that's what my GHC 6.8.2 docs say :-P
10:12:07 <HairyDude> I was about to say, I don't have the fgl package installed but I still have Data.Graph
10:15:29 <HairyDude> hmm, the haddocks for Data.Graph.Inductive don't give complexity information
10:15:59 <Deewiant> just benchmark it versus Data.Graph, the difference should be pretty obvious if there is one
10:16:51 <SyntaxNinja> thetallguy, Igloo, so should the cabal package go away?
10:19:06 <Igloo> SyntaxNinja: I'd say so, yes
10:19:57 <SyntaxNinja> you're probably right. any other opinions?
10:21:18 <thetallguy> SyntaxNinja: I'll be able to weigh in on that later today
10:22:00 <gbacon> @hoogle [(k, a)] -> Map k [a]
10:22:02 <lambdabot> No matches, try a more general search
10:22:03 <thetallguy> SyntaxNinja: I'm trying to build our autobuilder (written in Haskell) on a new platform and having the cabal package in ghc may make it tough
10:22:07 <gbacon> @hoogle [(k, a)] -> Map k b
10:22:08 <lambdabot> Data.Map.fromDistinctAscList :: [(k, a)] -> Map k a
10:22:30 <byorgey> @type Data.Map.fromList
10:22:31 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
10:22:55 <oerjan> :t Data.Map.fromListWith
10:22:56 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
10:23:00 <gbacon> byorgey: I expect collisions, and I want to keep all the values
10:23:55 <oerjan> :t Data.Map.fromListWith (++) . map (second (:[]))
10:23:56 <lambdabot> forall b d. (Ord d) => [(d, b)] -> Data.Map.Map d [b]
10:23:56 <byorgey> gbacon: ah, use fromListWith (++) on something of type [(k,[a])] perhaps?
10:24:07 <byorgey> what oerjan just typed =)
10:24:15 <SyntaxNinja> thetallguy: OK. let me know what you think.  If I'm not here, please email.  cabal debian package is on my short list of things to fix.
10:24:41 <oerjan> i would check whether that (++) needs a flip...
10:25:04 <thetallguy> SyntaxNinja: will do.
10:25:23 <gbacon> > Data.Map.fromListWith (++) . map (second (:[])) [(1, "hi"), (1, "bye")]
10:25:24 <lambdabot>   Not in scope: `Data.Map.fromListWith'
10:25:27 <byorgey> oerjan: ah, for efficiency, indeed
10:25:35 <gbacon> > fromListWith (++) . map (second (:[])) [(1, "hi"), (1, "bye")]
10:25:36 <lambdabot>   Not in scope: `fromListWith'
10:25:45 * gbacon glares at lambdabot
10:25:48 <byorgey> I think it's imported under 'M'
10:25:48 <HairyDude> Deewiant: I don't want to have to benchmark them myself - it should be up to the maintainer to document how slow an algorithm he provides is, so everyone knows without having to expend the effort to find out
10:26:01 <Igloo> thetallguy: Why might it make it tough?
10:26:13 <Cale> byorgey: Perhaps just:  class Compact a where forall :: (a -> Bool) -> Bool, along with  class Overt a where exists :: (a -> Bool) -> Bool
10:26:13 <byorgey> > M.fromListWith (++) . map (second (:[])) $ [(1, "hi"), (1, "bye")]
10:26:14 <lambdabot>  fromList [(1,["bye","hi"])]
10:26:20 <HairyDude> in fact benchmarking is unnecessary for complexity analysis
10:26:28 <Deewiant> HairyDude: I agree. Data.Graph.Inductive is generally quite poorly documented
10:26:47 <byorgey> Cale: makes sense.
10:27:28 <Cale> (where the required property is that for any totally-defined predicate, it will compute whether the predicate holds for all values of the type, and not produce bottom)
10:27:45 <byorgey> Cale: right.
10:28:43 <thetallguy> igloo: because I want to use the autobuilder to build all of the ghc packages, but I can't build the autobuilder until I've upgraded cabal
10:28:47 <gbacon> byorgey and oerjan: thanks!
10:29:31 <Cale> hmm... I'll have to think about whether that's really the right thing :)
10:30:17 <byorgey> gbacon: yw
10:30:49 <thetallguy> igloo: perhaps the right answer is to back off our source to an older cabal.   Or maybe I just have to build everything twice.
10:31:50 <Igloo> thetallguy: Ah, you want to use the new Cabal with the old GHC?
10:33:00 <thetallguy> igloo: All I really want is for it all to build. ;-) But yes, I had to upgrade haddock and then things got ugly quickly
10:35:03 <faxathisia> ?where GHC
10:35:03 <lambdabot> http://haskell.org/ghc
10:44:16 <dcoutts> thetallguy: new cabal works with old ghc just fine
10:44:51 <dcoutts> thetallguy: we updated cabal in gentoo before updating ghc btw
10:49:36 <hpaste>  gbacon pasted "anagrams" at http://hpaste.org/5022
10:49:52 <thetallguy> dcoutts: I'll get a more accurate diagnosis after I run some errands. Was too bleary-eyed last night to disentangle all the error messages.
10:55:43 <tibbe> dcoutts: when will we see a cabal binary in debian/redhat?
10:56:16 <dcoutts> tibbe: do you mean the cabal lib or the cabal-install command line program?
10:58:54 <tibbe> dcoutts: the latter
10:59:05 <tibbe> so users don't need cabal-install to install cabal install
10:59:20 <dcoutts> tibbe: well, we've not had any real public releases recently
10:59:22 <tibbe> ie when will we have a stable enough version to release it
10:59:24 <tibbe> right
10:59:28 <glen_quagmire> if haskell were to have eval function (eval "a = 1";  eval "print (a + 1)" --prints 2),  what would be its type?
10:59:49 <vincenz> IO
10:59:49 <tibbe> IO UnsafeLaunchMissiles
10:59:50 <vincenz> IO ()
11:00:06 <Deewiant> String -> IO ()... possibly
11:00:20 <glen_quagmire> :t (=)
11:00:28 <Deewiant> but surely that doesn't capture all possibilities
11:00:33 <dcoutts> tibbe: it depends on when we think it's working sufficiently well and since it depends on a development version of the Cabal lib, we'd also have to make a Cabal-1.4.0 release and it's not clear if we're ready to do that
11:00:34 <lambdabot> parse error on input `='
11:00:50 <glen_quagmire> how about type of (=) ?
11:00:52 <dcoutts> tibbe: I worry that at the moment doing a release would actually slow development
11:01:07 <glen_quagmire> Symbol -> Expression -> HaskellSymbolTable ?
11:01:15 <dcoutts> tibbe: since I'm sure we'll keep needing new stuff in the Cabal lib to support new stuff in cabal-install
11:01:19 <Botje> glen_quagmire: you'd have to use the same tricks as HList does
11:01:28 <faxathisia> No
11:01:56 <faxathisia> Its not a haskell function
11:02:05 <glen_quagmire> ?HList
11:02:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:02:09 <dcoutts> tibbe: if we had more people hacking on cabal-install we could move much quicker
11:03:00 <Sizur> :t liftM2 find
11:03:01 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m (Maybe a)
11:03:03 * dcoutts invites everyone in #haskell to get involved with cabal-install hacking
11:03:22 <Sizur> dcoutts how can i help?
11:03:24 <dcoutts> pick a bug, submit a patch
11:03:45 <dcoutts> Sizur: start by building, using it and reporting bugs
11:03:49 <Sizur> that assumes darcs fluency :P
11:04:15 <Sizur> i guess i need to learn it one day
11:04:17 <dcoutts> Sizur: it's pretty easy to use darcs to download it at least
11:04:30 <Sizur> yeah pulling is easy
11:05:16 <Sizur> haven't tried yet the other stuffs
11:05:36 <Botje> Sizur: recording a change is darcs record ; sending it is darcs send
11:05:59 <dcoutts> (though the latter needs working local email)
11:06:07 <Botje> you are now fluent in darcs usage. that'll be EUR 50 :)
11:06:55 <Sizur> dcoutts local email, local to what
11:07:16 <dcoutts> Sizur: /usr/sbin/sendmail needs to work
11:07:29 <Sizur> Botje: oh cool! one even gets paid for learning darcs? nice!
11:07:53 <dcoutts> swiert: I hope I fixed the proxy problem, try it
11:08:12 <Sizur> some servers reject mailsend from dynamic ips. plus how can one send from windows?
11:08:23 <dcoutts> Sizur: eg I use ssmtp as an email relay to send it on to my isp's smtp server
11:08:32 <alexeev1> Sizue: darcs send -o patch.txt works well
11:08:36 <swiert> dcoutts: ok. I'm not in the office atm.
11:08:37 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:53 <alexeev1> s/Sizue/Sizur/
11:09:03 <dcoutts> Sizur: if you cannot set that up then yes you can do what alexeev1 says, though that's more hassle in the long run
11:09:04 <swiert> dcoutts: I'll give it a go tomorrow.
11:09:08 <dcoutts> swiert: ta
11:09:40 <dcoutts> Sizur: don't worry about it, it's a bonus not a necessity
11:10:29 <Sizur> well, i do have plans to switch to distributed vcs form svn
11:11:15 <Sizur> darcs looks lovely (even though i heard reports, ghc project springs to mind, that patching can take days)
11:11:27 * Deewiant likes Mercurial
11:12:44 <HairyDude> it annoys me that you have to have an mta installed to do darcs send... I mean thunderbird (for example) doesn't need an mta just to send mail
11:13:02 <Saizan> mta?
11:13:09 <HairyDude> mail transfer agent (eg sendmail)
11:13:40 <Saizan> i vaguely remember that darcs send opened thunderbird on windows for me
11:14:14 <HairyDude> it should do a similar thing on *nix
11:14:31 <Micio> Sizur: ?
11:14:37 <HairyDude> I guess the big question is how
11:15:10 <dcoutts> HairyDude: you don't need one since you can always do darcs send -o file but it's really convenient to avoid any gui mailer at all
11:15:18 <Sizur> Micio: sorry, i logged out earlier. was going home from work.
11:15:31 <Saizan> n addition, unless you specify the sendmail command with --sendmail-command, darcs sends email using the default email command on your computer. This default command is determined by the configure script. Thus, on some non-Unix-like OSes, --from is likely to not work at all.
11:15:41 <Saizan> http://darcs.net/manual/node7.html#SECTION00764000000000000000
11:15:41 <lambdabot> Title: Darcs commands
11:15:45 <Cale> !paste
11:15:45 <hpaste> Haskell paste bin: http://hpaste.org/
11:15:46 <HairyDude> dcoutts: doesn't have to be a gui, e.g. I use pine
11:16:12 <dcoutts> HairyDude: there are times when you'd want to edit the description in which case using your ordinary email program would be nice, but many times I don't want it to be interactive at all
11:16:20 <dcoutts> just darcs send and get on with the next thing
11:16:39 <HairyDude> well even bsd mail would do then! :)
11:16:39 <dcoutts> especially if one has set up gpg signed auto-apply on the server side
11:16:49 <Micio> Sizur: yes...
11:16:52 <dcoutts> then it's just an async darcs push
11:17:21 <Sizur> Micio: do you want me to give you an example program?
11:17:41 <dcoutts> HairyDude: that's pretty much the same thing
11:18:30 <hpaste>  Cale pasted "equality checking for functions ;)" at http://hpaste.org/5023
11:18:38 <Sizur> :t (find<$>)
11:18:40 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> Bool) -> f ([a] -> Maybe a)
11:19:03 <dcoutts> HairyDude: is it a great deal more common to have a /usr/bin/mail prog that can send to the world than a /usr/sbin/sendmail?
11:19:11 <HairyDude> sigh... how do you encode N + N in N? (where N is the natural numbers and + is disjoint union)
11:19:24 <Cale> HairyDude: even and odd
11:19:43 <vincenz> or odd and even :)
11:19:53 <HairyDude> ah yes... double and add 1, or just double
11:19:58 <Sizur> :t (find<$>[1])
11:20:00 <lambdabot> forall a. (Num (a -> Bool)) => [[a] -> Maybe a]
11:20:04 <HairyDude> I knew there was an obvious way but I couldn't think of it :)
11:20:20 <hpaste>  Cale pasted "Code so far." at http://hpaste.org/5024
11:20:37 <oerjan> Sizur: that Num looks fishy
11:20:41 <Sizur> :t find <$> (==[1])
11:20:42 <lambdabot>     Couldn't match expected type `a -> Bool'
11:20:42 <lambdabot>            against inferred type `Bool'
11:20:42 <lambdabot>     In the second argument of `(<$>)', namely `(== [1])'
11:21:20 <Sizur> :t (find (==[1]) <$>)
11:21:22 <lambdabot> forall t (f :: * -> *). (Num t, Eq [t], Functor f) => f [[t]] -> f (Maybe [t])
11:23:03 <Sizur> :t (find (=="a") <$> (undefined::[[String]])
11:23:04 <lambdabot> parse error (possibly incorrect indentation)
11:23:19 <Sizur> :t find (=="a") <$> (undefined::[[String]])
11:23:19 <lambdabot> [Maybe [Char]]
11:24:25 <oerjan> find (==x) is a bit weird - can only return Just x or Nothing
11:24:34 <oerjan> what about simply elem x ?
11:24:45 <Sizur> :t elem
11:24:46 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:25:04 <Sizur> find suits my purpose
11:25:36 <Micio> Sizur: I'm student, should I was not student, than no problem.... that's why i want help...
11:25:52 <Sizur> just getting the type wrong
11:27:54 <Sizur> :t elem "a" <$> (undefined::[[String]])
11:27:56 <faxathisia> How, Cale?
11:27:56 <lambdabot> [Bool]
11:28:15 <Cale> faxathisia: how is it possible to compare functions like that?
11:28:46 <Sizur> :t filter (elem "a") <$> (undefined::[[String]])
11:28:49 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
11:28:49 <lambdabot>       Expected type: [[[[Char]]]]
11:28:49 <lambdabot>       Inferred type: [[String]]
11:28:57 <faxathisia> Quickcheck cheating ? :l
11:29:20 <Cale> Not at all. Look at the code below the example :)
11:29:27 <Cale> er, oh
11:29:33 <Cale> I didn't paste it as an attachment
11:29:35 <Cale> http://hpaste.org/5024
11:29:37 <Sizur> :t filter (elem "a" <$>) <$> (undefined::[[String]])
11:29:42 <lambdabot>     Couldn't match expected type `Bool' against inferred type `f Bool'
11:29:42 <lambdabot>     In the first argument of `filter', namely `((elem "a") <$>)'
11:29:42 <lambdabot>     In the first argument of `(<$>)', namely
11:30:08 <faxathisia> Ahh cool
11:30:43 <Sizur> :t filter <$> (elem "a" <$>) <*> (undefined::[[String]])
11:30:44 <lambdabot>     Couldn't match expected type `(->) (a -> [[Char]])'
11:30:44 <lambdabot>            against inferred type `[]'
11:30:44 <lambdabot>       Expected type: (a -> [[Char]]) -> [a]
11:30:55 <Sizur> hahah, sorry... i'll stop fludding
11:30:58 <Sizur> flooding
11:31:23 <oerjan> Sizur: what do you want, actually?
11:31:32 <Cale> faxathisia: Note that the predicate must be totally defined, so it's not possible to compare functions which diverge for some inputs.
11:31:44 <faxathisia> Yeah
11:32:12 <Cale> (In particular, these functions can only observe an arbitrary, but finite amount of their input list)
11:32:26 <Sizur> oerjan: i have a list of lists and i want to get the list that contains a list that contains a specific element
11:32:42 <Sizur> eh
11:33:01 <Sizur> i think it's sleepy-time for me
11:33:07 <oerjan> :t find (elem "a")
11:33:08 <lambdabot> [[[Char]]] -> Maybe [[Char]]
11:33:24 <vincenz> :t find
11:33:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:33:47 <oerjan> :t find (elem "a") (undefined :: [[String]])
11:33:48 <lambdabot> Maybe [[Char]]
11:34:34 <Sizur> i dont know try went into applicative forest
11:35:13 <oerjan> not seeing the forest for the trees? :D
11:35:44 <Sizur> yeah, i guess wanted to belong to the cool bunch. hah
11:36:25 <Sizur> Micio: i will help you
11:37:59 <Micio> really?
11:46:40 <swiert> dcoutts: I've been playing around with cabal-install a bit. If I cabal install --prefix=$HOME/local --user X, binaries get installed in ~/.cabal/bin. Is that the expected behaviour?
11:46:53 <swiert> dcoutts: I'd expect them to show up in ~/local/bin...
11:47:25 <dcoutts> swiert: well that's what it does currently, where they should really go is an interesting matter for debate
11:47:33 * dcoutts finds the bug
11:48:02 <swiert> dcoutts: well, I was a bit surprised by that behaviour.
11:48:07 <dcoutts> swiert: oh, we don't have that one recorded, could you add a ticket saying what you think should happen
11:48:20 <swiert> dcoutts: sure. will do.
11:48:39 <dcoutts> swiert: I tend to agree with you, there are people who think that nothing should mess with their ~/bin directory
11:48:56 <dcoutts> swiert: and where it should really go seems to depend a bit on the OS
11:49:19 <swiert> dcoutts: well, if you're asking for things to be put in Y, I'd expect them to show up there.
11:49:25 <dcoutts> swiert: you use mac os? so does every user get a ~/local/bin ?
11:49:42 <swiert> dcoutts: no. I make one myself.
11:49:42 <dcoutts> swiert: eg on other unix it's more common to use ~/bin
11:50:00 <swiert> dcoutts: ~/local/bin is my convention :)
11:50:05 * byorgey uses ~/local/bin too
11:50:14 * desegnis uses ~/.local/bin :)
11:50:19 <dcoutts> swiert: so the question is how do we find it and what do we make the default :-)
11:50:40 <dcoutts> swiert: you can already customise it by putting user-bin: whatever in the ~/.cabal/config file
11:50:43 <desegnis> So the question is whether binaries should obey --prefix
11:50:53 <dcoutts> erm, user-bindir: whatever
11:51:07 <dcoutts> desegnis: yes, since you can override with --bindir
11:51:22 <dcoutts> and cabal-install already allows that to be set in the config file
11:51:30 <dcoutts> the question is what should the default be?
11:52:05 <desegnis> hm... how do GNU ./configure scripts behave? We could mimic their behaviour if we know it
11:52:09 <Lycurgus> so the searchpath package is limited to happs?
11:52:13 <dcoutts> and we should probably make it more obvious that the setting is available in the config file, eg by putting the other settings in commented out, like -- user-bindir:
11:52:44 <dcoutts> desegnis: we follow the same convetion already, that is by default bindir=$prefix/bin
11:52:48 <alexj> Lycurgus: no it works with whatever you put in your map files.
11:53:00 <alexj> if you want packages added to the map file just let me know.
11:53:12 <alexj> or better yet, just send me a patch.
11:53:30 <desegnis> dcoutts, I thought that swiert's confusion was due to cabal not following that convention?
11:53:54 <desegnis> that is, using ~/.cabal/bin regardless of --prefix
11:53:54 <dcoutts> desegnis: no, his confusion was that it did not deviate from that convention :-)
11:54:00 <alexj> or you can use your own mapfile if you don't want to wait on me.  -i /path/to/mypackages.map -i http://url/of/yourfile.map
11:54:01 <lambdabot> Title: url
11:54:12 <desegnis> dcoutts, then it's rather me who's confused :)
11:54:18 <Lycurgus> Acknowledged.
11:54:34 <byorgey> dcoutts: huh? note swiert did say --prefix=$HOME/local, not --prefix=$HOME
11:54:36 <swiert> dcoutts: but I explicitly set --prefix=$HOME, yet the bindir is .cabal/bin
11:54:42 <dcoutts> swiert: oh, wait I misread, you say that you set --prefix=$HOME/local and the binary still ended up in $HOME/.cabal/bin?
11:54:56 <dcoutts> swiert: if so that's a bug not a confusion :-)
11:55:00 <desegnis> I think we have the point now :)
11:55:02 <swiert> dcoutts: oops, I mean $HOME/local
11:55:21 <dcoutts> swiert: hmm, lemme try...
11:55:39 <desegnis> anyway, I once added .cabal/bin to my path, actually
11:57:47 <dcoutts> swiert: can I get you to try this patch to cabal-install's Main.hs:
11:57:49 <dcoutts> hunk ./Main.hs 115
11:57:50 <dcoutts> -  let flags' = flags `mappend`
11:57:50 <dcoutts> -               savedConfigToConfigFlags (Cabal.configPackageDB flags) config
11:57:50 <dcoutts> +  let flags' = savedConfigToConfigFlags (Cabal.configPackageDB flags) config
11:57:50 <dcoutts> +               `mappend` flags
11:57:59 <dcoutts> ie reverse the mappend
11:59:10 <hpaste>  sizur pasted "DisjointSets" at http://hpaste.org/5025
11:59:29 <Sizur> Micio: is this what you need?
11:59:49 <dcoutts> swiert: looks like we were having the setting from the config file override the ones from the command line, rather than the other way around
12:00:05 <swiert> dcoutts: ok, let me have a try.
12:00:24 <Micio> Sizur: but what?
12:00:36 <Sizur> Micio: http://hpaste.org/5025
12:03:26 <lollicide> i am attempting to use lazy evalutation to avoid having to do a second parse when parsing something in parsec.. is there a standard way of doing that? e.g. the user-defined state in parsec is a map, and at some point i want to lookup values in it that won't get filled in until later in the parsing (the values will only be used in the resulting data tree, not to affect choice of parsers or anything like that).. i tried feeding the resu
12:03:34 <lollicide> a second pass even
12:04:26 <Cale> Grr! Why must Enum use Int! It's *so* screwing up the correctness of this code.
12:04:42 <lollicide> e.g. i want to look up identifiers even though they haven't been defined yet.. or i want to do something like haskell's infixl/infixr (where the infixl/r statement can come after the operator is actually used)
12:04:54 <hpaste>  sizur annotated "DisjointSets" with "v.2" at http://hpaste.org/5025#a1
12:04:55 <Feuerbach> Does haskell support arbitrary-precision floating point nubers?
12:05:11 <smack_> Cale: hitting max?
12:05:14 <oerjan> lollicide: your first line cut off after "i tried feeding the resu"
12:05:20 <byorgey> Feuerbach: I think there are modules that do that, but Haskell does not have built-in support for that
12:05:47 <Feuerbach> byorgey: yes, I mean not necessary built-in, but available
12:05:48 <lollicide> oerjan, oh sorry. ... i tried feeding the resulting state back to the parser like "let Right (st,res) = runParser parser (M.union st M.empty) .." but it just causes the parser to hang...(??) (not use any CPU).
12:06:48 <Sizur> Micio: is this what you need?
12:06:53 <byorgey> Feuerbach: http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Real_and_rational_numbers
12:06:54 <lambdabot> http://tinyurl.com/2rt3uv
12:06:59 <oerjan> lollicide: parsec parsers are strict in the Right
12:07:21 <oerjan> you must do the feeding back inside the monad i think
12:07:40 <mightybyte> If I have a function foo :: a -> b -> c -> IO Integer and I want to run that for every element in a list of c's (keeping the first two arguments constant), would mapM be the function to do that?
12:07:51 <lollicide> inside the GenParser monad? how?
12:07:52 <Cale> smack_: I have some code which is correct for testing whether two functions defined on Integer -> a values are equal, when the type a satisfies some conditions, and I'd like to generalise it to Enum b => b -> a
12:07:59 <oerjan> and i don't think threading state is quite the right thing either, not sure
12:08:08 <lollicide> hm
12:08:40 <Cale> smack_: But that will ruin correctness, because the differences could occur beyond the range of Int
12:08:49 <oerjan> lollicide: although if it is, there's a setUserState or something
12:09:21 <Cale> smack_: (and this code would easily work for values out that far)
12:09:32 <oerjan> mightybyte: sounds right
12:09:55 <Micio> Sizur: I can't start up....
12:10:15 <Sizur> Micio: ghci filename
12:10:24 <oerjan> lollicide: setState that is
12:10:27 <Sizur> Micio: or runhaskell filename
12:10:35 <mightybyte> oerjan: But I'm getting a "Possible fix: add an instance declaration" message from the compiler
12:10:44 <Cale> Well, not to mention that various instances of Enum don't really enumerate everything.
12:11:03 <mightybyte> oerjan: When I do "mapM (foo a b) list"
12:11:14 <lollicide> oerjan, yes.. i use getState to get the map for lookups, and setState (M.insert ..) etc. but the problem is that when i getState i get the map as it is then.. but it will change later. and i want to do all lookups on the "final" map.
12:11:27 <Micio> Sizur: I use HUGS
12:11:27 <Sizur> Micio: did you even tried to compile a simple "hello world" in haskell?
12:11:31 <Cale> (but if they did, we could, for instance, compare total functions which take Float -> Bool parameters)
12:11:40 <oerjan> mightybyte: strange
12:11:50 <Sizur> guys, does hugs have runhaskell?
12:12:08 <swiert> dcoutts: yes, that worked.
12:12:12 <Micio> yes...
12:12:18 <swiert> dcoutts: thanks for the tip.
12:12:39 <desegnis> Feuerbach: if it suits your requirements, you may use Rationals. Â»Ratio IntegerÂ« is indeed of arbitrary precision
12:12:44 <mightybyte> oerjan: foo in this case is a function that inserts a row into a database.
12:12:54 <Sizur> Micio: what is the error message?
12:12:56 <oerjan> mightybyte: paste?
12:13:06 <mightybyte> oerjan: Ok, one moment.
12:13:34 <oerjan> lollicide: i think you don't want to thread the state back into _itself_, only to the lookups
12:13:55 <Cale> Maybe I can just define a GoodEnum class, and make lots of instances, but that's really annoying.
12:14:11 <oerjan> hm wait...
12:14:31 <Micio> Unresolved top-level overloading
12:14:31 <oerjan> lollicide: whoops, i think you may need Parsec to be a MonadFix instance for this
12:14:32 <Micio> *** Binding             : sets
12:14:32 <Micio> *** Outstanding context : Eq b
12:14:50 <oerjan> oh wait no...
12:15:25 <lollicide> hehe, well, i'm pretty new to haskell..
12:15:33 <oerjan> lollicide: ah, i just realized.  You can use the Right pattern, but you need a laziness declaration on it.
12:15:53 <lollicide> a laziness declaration?
12:15:58 <oerjan> let Right (~st,res) = ...
12:16:13 <lollicide> oh, hm, i'll try
12:16:20 <Saizan> st is already irrefutable
12:16:36 <oerjan> er yeah
12:16:50 <oerjan> let ~Right (st,res)
12:16:56 <Saizan> also, let bindings are already lazy by default iirc
12:17:03 <oerjan> hm true
12:17:08 <hpaste>  sizur annotated "DisjointSets" with "v3" at http://hpaste.org/5025#a2
12:17:19 <Sizur> Micio: try this ^
12:17:34 <byorgey> let ~Right ~(~st, ~res)  -- just put tildes everywhere!  maybe it will work!
12:17:36 <swiert> dcoutts: would you still like a bug report?
12:18:11 <oerjan> lollicide: ok this is not quite it.  it should already be lazy enough.
12:18:30 <lollicide> i can paste the code to give a better pic of what i want?
12:18:42 <lollicide> it's just a little test program.. i'll add some comments
12:18:46 <oerjan> instead, i think you need to be careful not to pass the final state into the initial one
12:18:54 <Saizan> lollicide: does the "structure" of the result depend on the lookups?
12:19:05 <desegnis> swiert, I'm not dcoutts, but I think that would be good for googling people
12:19:40 <lollicide> Saizan, yes. 'res' depends on the lookup, but not the parsing..
12:20:04 <shapr> @users
12:20:05 <lambdabot> Maximum users seen in #haskell: 454, currently: 446 (98.2%), active: 20 (4.5%)
12:20:10 <shapr> mmm, 454
12:20:46 <oerjan> lollicide: try something like Right (finalState, res) = runParser (parser finalState) M.empty
12:20:48 <Sizur> Micio: i do not know what is the problem. i do not use Hugs.
12:22:36 <hpaste>  mightybyte pasted "Multiple Database Inserts" at http://hpaste.org/5026
12:22:47 <mightybyte> oerjan: Ok, it's there.
12:23:37 <Lemmih> mightybyte: mapM_ ?
12:24:04 <mightybyte> Lemmih: Same problem
12:24:05 <desegnis> mightybyte, try and add a type signature to addAll to hopefully get a clearer error message
12:24:21 <mightybyte> desegnis: Ok
12:24:21 <Lemmih> mightybyte: What error message are you seeing?
12:24:27 <Saizan> mightybyte: you end up using toSql twice on the second argument of addOne
12:24:45 <mightybyte> Lemmih: No instance for (SqlType SqlValue)
12:25:03 <mightybyte> Lemmih: Possible fix: add an instance declaration for (SqlType SqlValue)
12:25:11 <desegnis> ah. Saizan catched it, although it's the third argument
12:25:12 <Lemmih> mightybyte: Sounds like Saizan called it.
12:25:26 <mightybyte> Lemmih: Ahh
12:25:51 <Saizan> yeah third, wasn't counting the db
12:26:02 <Deewiant> Is it smart to name a data field something common like "name", or should one add some sort of disambiguating prefix?
12:26:08 <mightybyte> Saizan: Yeah, that's it.  I know I tried it without the second map.  I must have had a different error then.
12:26:23 <Saizan> also, this way you prepare that query each time
12:26:42 <Saizan> i mean "one time for each value in the list"
12:28:05 <mightybyte> Yes, the second argument to mapM should be "list" instead of the second map.
12:29:33 <godsai> haskell?
12:29:47 <shapr> mmm, haskell
12:29:50 <shapr> I like Haskell!
12:30:33 <Igloo> Mmm, fried lambdas
12:30:44 <godsai> is F# as good as haskell?
12:30:55 <godsai> or do u think its better?
12:31:36 <Sizur> @users
12:31:36 <lambdabot> Maximum users seen in #haskell: 454, currently: 444 (97.8%), active: 21 (4.7%)
12:31:42 <Lemmih> godsai: I think there's a third option.
12:31:45 <olsner> obviously, #haskell thinks more of haskell than of anything else
12:31:46 <oerjan> eek
12:31:51 <faxathisia> godsay, they probably both have strengths and weaknesse
12:31:52 <godsai> which is?
12:32:10 <godsai> why was f# invented when there is haskell
12:32:17 <Sizur> .net
12:32:21 <vincenz> godsai: why have apples when you have oranges?
12:32:25 <Sizur> m$
12:32:36 <Sizur> f# is nice
12:32:40 <godsai> is it?
12:32:44 <Sizur> scheme is the third
12:32:46 <dolio> Ooo. http://tinyurl.com/29k5wv
12:32:47 <Sizur> haskell is the best
12:32:48 <lambdabot> Title: Free, functional, shiny - Bobulate
12:32:48 <godsai> which do u like better sizur
12:32:53 <Cale> f# is more of an ML
12:32:55 <dolio> Haskell bindings for Qt.
12:32:55 <vincenz> I think this is rather OT
12:33:05 <vincenz> Cale: ocaml actually
12:33:09 <vincenz> Cale: it's an ocaml ripoff
12:33:14 <godsai> wait ML is not functional?
12:33:14 <Cale> yes
12:33:19 <Cale> ML is functional as well
12:33:36 <vincenz> ML is impure, strict, functional
12:33:39 <vincenz> ocaml is idem but adds OO
12:33:42 <godsai> hmmm isnt functional just make functions inside of functions?
12:33:47 <Cale> F# is very close to O'Caml which is a member of the ML family of languages
12:33:58 <Cale> godsai: no, it's much more than that
12:34:10 <Sizur> you can have purity in f#
12:34:22 <godsai> really?
12:34:26 <Cale> godsai: The treatment of functions as first class values is the most important point, perhaps.
12:34:30 <godsai> can u have purity in haskell?
12:34:37 <Cale> godsai: Haskell is pure.
12:34:40 <Tac-Tics> godsai: functional means some slightly different things
12:34:41 <Sizur> godsai: haskell is the pure language
12:34:46 <godsai> first class values like int?
12:34:52 <godsai> like primative values u mean
12:34:52 <godsai> ?
12:34:52 <dolio> F# has interesting first-class patterns (or something like that).
12:35:04 <dolio> Even OCaml doesn't do those, no?
12:35:20 <Cale> godsai: sure
12:35:23 <godsai> so is haskell used in industry or no?
12:35:26 <Cale> godsai: yep
12:35:43 <godsai> how is the market for haskell when compared to ssay .net?
12:35:43 <Cale> godsai: dons can tell you more about that, along with several others here
12:36:04 <Cale> .net isn't a language, it's a platform for many languages
12:36:13 <godsai> i mean c#
12:36:14 <Cale> F# runs on .net
12:36:14 <godsai> say
12:36:15 <Sizur> godsai: haskell vs .net = david vs goliath
12:36:21 <Tac-Tics> Haskell doesn't hold a candle to .NET, but what's popular isn't as cool as Haskell
12:36:25 <gour> has dons moved to linux?
12:36:28 <godsai> how bout haskell versus lisp
12:36:35 * vincenz groans
12:36:49 <godsai> i wanna know how big haskell is
12:36:50 <faxathisia> good question...
12:36:51 <vincenz> Please stop feeding the troll
12:36:56 <Cale> godsai: We can answer these questions for you, but it's probably easier to get a real sense of things just by using Haskell :)
12:37:04 <dolio> @protontorpedo
12:37:04 <lambdabot> can I build a sales database with it?
12:37:09 <faxathisia> @quote vs
12:37:09 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
12:37:09 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
12:37:10 <Cale> godsai: Note that there are 444 people in this channel :)
12:37:24 <Sizur> @users
12:37:24 <lambdabot> Maximum users seen in #haskell: 454, currently: 443 (97.6%), active: 27 (6.1%)
12:37:38 <godsai> dang
12:37:41 <Cale> (well, it seems to be changing :)
12:37:45 <godsai> haskell is large on irc
12:37:54 <shapr> It's large off of IRC too.
12:37:54 <godsai> wot about newsgroups?
12:38:06 <godsai> man i wanna get into the haskell clique
12:38:07 <Cale> godsai: yep, there's comp.lang.haskell
12:38:12 <Cale> and mailing lists
12:38:16 <godsai> dang
12:38:17 <shapr> godsai: Learn Haskell, then you're in the clique!
12:38:19 <desegnis> godsai, haskell.org (the wiki) is a good place to understand Haskell infrastructure
12:38:19 <godsai> ok
12:38:22 <Cale> haskell and haskell-cafe are the main ones
12:38:27 <godsai> sweet
12:38:35 <godsai> isnt haskell like real old too?
12:38:37 <dolio> comp.lang.haskell is pretty low traffic, last I checked.
12:38:39 <godsai> like 40 years old
12:38:42 <vincenz> nope
12:38:43 <Cale> no
12:38:46 <shapr> Nah, more like ~15
12:38:48 <Cale> You're thinking of lisp
12:38:58 <godsai> lisp is functional too?
12:39:02 <Cale> sort of
12:39:04 <shapr> Yeah, sort of
12:39:19 <Cale> Some lisps could be called functional languages. Others mistreat functions too much ;)
12:39:40 <godsai> man i dont see why c isnt functional
12:39:42 <Cale> (lisp is actually a whole family of languages with similar core ideas)
12:39:43 <godsai> its got functions
12:39:59 <Sizur> godsai: think of math functions
12:40:00 <Cale> godsai: Because functional programming is hard to do in C.
12:40:03 <godsai> and in c i can put funtions inside functions
12:40:03 <shapr> Functions only return one single output for a given input, yeah?
12:40:13 <godsai> yah
12:40:23 <godsai> functions in haskell can return more than one?
12:40:31 <Cale> godsai: Can you pass functions as parameters to other functions (yes, but it's not something which anyone actually does)
12:40:32 <Cale> ?
12:40:33 <smack_> godsai: no, in C they can
12:40:40 <kib> Wich one will you recommend for a newbie ? Lisp or Haskell ?
12:40:49 <Cale> godsai: Can you return a function as the result of another in C?
12:40:51 <vincenz> kib: wrong axis
12:40:52 <faxathisia> kib, both
12:40:53 <vincenz> kib: scheme or haskell
12:40:56 <godsai> actuallly i put functions inside of parameters all the time
12:40:58 <godsai> in c
12:41:04 <godsai> and c#
12:41:12 <Cale> godsai: Example?
12:41:25 <lollicide> oerjan, hmm.. it hangs when actually does a lookup.. but at least it runs through when it doesn't do any lookups. parsec isn't strict, is it? i mean, i /can/ do stuff like   program v = setState 42 >> char '.' >> return v   where v may be taken from the state that i just set and passed back to the program?
12:41:27 <smack_> godsai: you're passing functions, or the /results/ of functions?
12:41:36 <kib> so why scheme > Lisp ? I want to learn a functionnal language and I'm hesitating a lot...
12:41:49 <oerjan> lollicide: it shouldn't be strict in the result
12:41:54 <Sizur> Cale: a void pointer can polint to a function
12:41:58 <godsai> int function (getnumber(ID));
12:42:01 <godsai> like that
12:42:02 <Cale> Sizur: I'm aware :)
12:42:03 <oerjan> hm it _might_ be strict in the user state
12:42:09 <vincenz> Sizur: no it can't
12:42:10 <Cale> godsai: no, that's not what we mean at all
12:42:13 <Tac-Tics> In C, you can pass around pointers, but the power of Functional programming comes from closures
12:42:14 <smack_> godsai: getnumber isn't actually being passed to the function
12:42:18 <vincenz> Sizur: data and function pointers odn't mix in C
12:42:18 <Sizur> vincenz: explain
12:42:25 <godsai> oh
12:42:31 <godsai> hmmm ok
12:42:33 <Cale> godsai: Let me give you an example of the sort of thing we do with functions in Haskell.
12:42:38 <Sizur> vincenz: a void pointer can point to anything
12:42:44 <Cale> > map (*10) [1..10]
12:42:46 <faxathisia> kib, just learn everything order doesn't matter
12:42:47 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
12:42:53 <resiak> function pointers are stored in void*s all the time
12:43:00 <Cale> godsai: map is a function which takes as parameters a function and a list
12:43:00 <godsai> ok
12:43:07 <vincenz> Sizur: afaik, you can't put functoin pointers in data pointers, but maybe I'm thinking of c++
12:43:16 <Cale> godsai: It applies that function to each of the elements of the input list, to get a new list
12:43:18 <Sizur> vincenz: same with c++
12:43:20 <vincenz> or at least, it's not guarnateed to work
12:43:21 <gwern> suppose I wanted a flag type for passing to a function and it choosing to do something special or not, and I wanted to be extensible (ie not just a Bool); would 'data Flag = Just Transient | Nothing' be a good way to write it?
12:43:27 <vincenz> and I've read stories where it went awry
12:43:29 <kib> Python, Ruby, etc..all have such features.
12:43:30 <Cale> godsai: here, (*10) is the function which multiplies its parameter by 10
12:43:34 <Cale> godsai: so for example:
12:43:38 <Cale> > (*10) 5
12:43:38 <lambdabot>  50
12:43:40 <godsai> cant u do that in a foreach loop?
12:43:43 <godsai> in c#
12:43:46 <godsai> with yeild
12:43:48 <smack_> godsai: sure
12:43:54 <smack_> here you don't need the loop
12:43:55 <Cale> godsai: sure, but that's not an example of what I'm talking about :)
12:44:10 <smack_> because we have the ability to pass the logic of the function itself to 'map'
12:44:12 <Cale> godsai: The point is that map is actually receiving a function as a parameter, and doing something with it.
12:44:21 <oerjan> lollicide: eek.  stateUser is a strict field in Parsec.State
12:44:24 <faxathisia> gwern: type Flag = Maybe Transient?
12:44:26 <Cale> In fact, it's transforming that function into a new function, one which works on lists.
12:44:31 <godsai> oh ok
12:44:42 <godsai> wow
12:44:46 <godsai> thats pretty neat
12:45:04 <glen_quagmire> no it's not. foreach is better
12:45:04 <resiak> hrm, vincenz is right
12:45:10 <Cale> glen_quagmire: haha
12:45:11 <godsai> is it?
12:45:13 <resiak> with -pedantic, gcc emits:
12:45:15 <godsai> yah
12:45:18 <resiak> funptr.c:8: warning: ISO C forbids initialization between function pointer and â€˜void *â€™
12:45:19 <godsai> foreach is simplier
12:45:27 <glen_quagmire> foreach [1 .. 10] call my_functor
12:45:38 <godsai> yah
12:45:39 <Cale> > map reverse ["hello", "this", "is", "a", "list", "of", "strings"]
12:45:39 <lambdabot>  ["olleh","siht","si","a","tsil","fo","sgnirts"]
12:45:42 <godsai> thats easier
12:45:49 <Sizur> it's simpler because you're thinking procedurally at the moment
12:46:03 <vincenz> resiak: thank you
12:46:04 <gwern> faxathisia: hm. how would I extend that if I later wanted, say, Nothing, Transient, and SpecialTransient as flags?
12:46:21 <oerjan> lollicide: you are going to have to work around that
12:46:23 <resiak> vincenz: thanks for the enlightenment!  i've always thought it suspicious behaviour, but had been assured it was kosher
12:46:25 <vincenz> resiak: on some architecturs that will even bork
12:46:28 <glen_quagmire> > foreach [1 .. 0] (+1) where foreach = (map . flip)
12:46:28 <kib> Do you mean ie that http://dpaste.com/31168/ is not a real function (sorry it's Python, but it is understandable by all) ?
12:46:28 <lambdabot>  Parse error at "where" (column 23)
12:46:32 <godsai> yah but doesnt haskell still work in procedure?
12:46:40 <godsai> like it reads from top to bottom right?
12:46:43 <smack_> godsai: nope
12:46:46 <gwern> functions all the way done
12:46:46 <faxathisia> replace it and edit your code
12:46:47 <vincenz> haven't seen it personally but read abot it
12:46:47 <Cale> godsai: um, not really
12:47:01 <gwern> faxathisia: I mean, what would I replace it with?
12:47:05 <godsai> so it reads all the page at one time?
12:47:13 <Cale> godsai: Haskell operates by replacing definitions of functions with function bodies and substituting in the parameters.
12:47:13 <vincenz> resiak: the easiest way to think about it is: think two separate memory spaces for functions and data that might encode addresses differently underhood
12:47:22 <vincenz> and they're both called 'pointers'
12:47:27 <gwern> data Flag = Maybe Transient | Maybe SpecialTransient?
12:47:28 <oerjan> lollicide: one way would be to make the user state a tuple, with the first element the map you are building and the second the final map.
12:47:30 <resiak> vincenz: right, it makes sense that it doesn't work
12:47:33 <Cale> godsai: It does this substitution outermost-first (that's the "lazy" part)
12:47:48 <faxathisia> gwern: You know Either?
12:47:50 <glen_quagmire> > let foreach = (flip map) in foreach [1 .. 10] (+1)   -- now haskell is C#
12:47:51 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:47:53 <byorgey> kib: right, not in the mathematical sense.
12:47:53 <lollicide> oerjan, hm, i actually thought of that, but didn't think it was necessary.. i'll try it..
12:47:58 <vincenz> resiak: obv, on a 32bit architecture, it works and thus only a warning, but you cant' rely on that
12:48:05 <Cale> for example, in a strict language (basically all imperative languages are strict)
12:48:09 <gwern> faxathisia: not really no
12:48:09 <faxathisia> Maybe Either Transient SpecialTransient
12:48:16 <vincenz> Cale: I wonder what a lazy imperativel anguage would be like
12:48:18 <litb> hello all
12:48:22 <godsai> wots the haskell version?
12:48:25 <byorgey> hi litb
12:48:25 <Cale> vincenz: It would be insane :)
12:48:28 <godsai> glen
12:48:38 <litb> what is the best way to get digit N out of a Double?
12:48:40 <oerjan> lollicide: for the map you are _building_, strictness could be an advantage, saves making nested thunks
12:48:51 <kib> ok, a real function must be a sort of black box, that's it ? It has the same 'state' whatever time is ?
12:48:52 <godsai> thunks?
12:48:57 <litb> (if i have 0.x1x2x3x4... , how can i get xi ?)
12:49:02 <phobes> vincenz:  Start programming with unsafeperformio for all of your IO needs :)
12:49:06 <gwern> faxathisia: i think i see. so it goes Maybe first, so it's either a Just foo or Nothing, and then the foo itself could be Transient either SpecialTransient?
12:49:12 <vincenz> phobes: *wince*
12:49:17 <faxathisia> oops!
12:49:17 <Cale> godsai: Don't worry about thunks for now, they're part of the implementation of lazy evaluation.
12:49:29 <Cale> godsai: I can explain lazy evaluation at a high level for you.
12:49:33 <Sizur> > show pi !! 5
12:49:35 <lambdabot>  '5'
12:49:37 <Cale> Suppose we have a function double
12:49:40 <Cale> double x = x + x
12:49:41 <faxathisia> Maybe (Either Transient SpecialTransient) -- this actually
12:49:45 <Sizur> > show pi !! 3
12:49:46 <lambdabot>  '4'
12:49:50 <Cale> It takes a number and doubles it
12:49:56 <oerjan> @src RealFloat
12:49:56 <lambdabot> Source not found. Are you on drugs?
12:50:19 <Cale> In a strict language, that is, one which is evaluated innermost-first, we evaluate an expression like double (double 5) like this:
12:50:23 <Cale> double (double 5)
12:50:26 <Cale> = double (5 + 5)
12:50:28 <Cale> = double 10
12:50:30 <Cale> = 10 + 10
12:50:31 <Cale> = 20
12:50:55 <Cale> With outermost-first evaluation, it instead goes like this:
12:50:59 <Cale> double (double 5)
12:51:00 <faxathisia> gwern, Nothing, Just (Left _), Just (Right _), are the inhabitants
12:51:00 <gwern> faxathisia: ok, I see. and then the code which worked with Maybe 'flag of Nothing -> foo; Just Transient -> bar' would work as well with that
12:51:04 <Cale> = (double 5) + (double 5)
12:51:08 <faxathisia> No
12:51:12 <Cale> = (5 + 5) + (double 5)
12:51:13 <byorgey> kib: I think you have the right idea.  this is called 'referential transparency'.
12:51:15 <godsai> wots lamda calculus?
12:51:16 <Sizur> :t digit n d = read (show n !! d) :: Int -- litb
12:51:16 <Cale> = 10 + double 5
12:51:18 <lambdabot> parse error on input `='
12:51:22 <Cale> = 10 + (5 + 5)
12:51:26 <Cale> = 10 + 10
12:51:28 <Cale> = 20
12:51:40 <kib> ok, thanks.
12:51:55 <byorgey> kib: for example, if you have a = f x, then foo a a should have exactly the same value/behavior as foo (f x) (f x).
12:51:56 <Cale> godsai: Note that we evaluated double 5 twice there, because the parameter x was duplicated in the body of double.
12:52:10 <litb> (show n !! d) ??
12:52:13 <litb> hmm
12:52:19 <Cale> godsai: In order to prevent that, lazy evaluation will share evaluation of things which came from duplicating function parameters.
12:52:46 <godsai> oh
12:52:51 <godsai> so it makes it faster?
12:53:01 <kib> byorgey : yes, I think I understand
12:53:02 <litb> show pi !! 10
12:53:08 <litb> > show pi !! 10
12:53:09 <lambdabot>  '3'
12:53:10 <Sizur> :t \n d -> (read (show n !! d) :: Int)
12:53:10 <hpaste>  gwern pasted "what's wrong with my syntax here?" at http://hpaste.org/5027
12:53:11 <phobes> godsai: http://en.wikipedia.org/wiki/Lambda_calculus
12:53:11 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
12:53:11 <lambdabot>     In the first argument of `read', namely `((show n) !! d)'
12:53:11 <lambdabot>     In the expression: read ((show n) !! d)
12:53:11 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
12:53:15 <litb> Sizur: oh, now i get it. thanks you!
12:53:24 <litb> how easy after all :)
12:53:29 <Sizur> :t \n d -> (read [(show n !! d)] :: Int)
12:53:29 <lambdabot> forall a. (Show a) => a -> Int -> Int
12:53:41 <Cale> Well, it's hard to see with all the channel traffic, but the outermost first evaluation took more steps in the above than the innermost first one. This optimisation saves that and makes them equal in this case.
12:54:00 <oerjan> gwern: that seems messed up
12:54:01 <gwern> godsai: it can be faster, it can be slower. in cases where lazy/nonstrict evaluation is needed just for the program to terminate, it can be infinitely faster :)
12:54:12 <litb> Sizur: thanks you
12:54:15 <litb> one question left
12:54:17 <Cale> for example, here is an infinite list:
12:54:17 <Tac-Tics> Outermost evaluation is cleaner from a theoretical point of view, too
12:54:19 <gwern> oerjan: it's the unicode thing I have for emacs
12:54:21 <Cale> > [1,3..]
12:54:21 * gwern fixes
12:54:22 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:54:30 <Cale> > drop 1000 [1,3..]
12:54:31 <lambdabot>  [2001,2003,2005,2007,2009,2011,2013,2015,2017,2019,2021,2023,2025,2027,2029,...
12:54:32 <godsai> hey how come in revenge of the nerds
12:54:36 <godsai> there are computer dorks
12:54:40 <vincenz> > drop 1000 [1,3..]
12:54:41 <godsai> not biology dorks
12:54:41 <lambdabot>  [2001,2003,2005,2007,2009,2011,2013,2015,2017,2019,2021,2023,2025,2027,2029,...
12:54:44 <vincenz> > drop 1000000 [1,3..]
12:54:44 <lambdabot>  Exception: stack overflow
12:54:49 <hpaste>  gwern annotated "what's wrong with my syntax here?" with "bad unicode, bad!" at http://hpaste.org/5027#a1
12:54:52 * vincenz wrinkles his nose
12:54:53 <glen_quagmire> godsai: map (+1) [1 ..10]  is haskell version i think.  better yet,  [2 .. 11]
12:54:56 <Cale> vincenz: bug in enumFrom :)
12:54:59 <vincenz> Cale: yeah :)
12:55:05 <litb> > 10.1234 !! 3
12:55:07 <vincenz> > drop 1000000 [1,3..1000000000000000000]
12:55:08 <lambdabot>   add an instance declaration for (Fractional [a])
12:55:10 <lambdabot>  [2000001,2000003,2000005,2000007,2000009,2000011,2000013,2000015,2000017,200...
12:55:25 <oerjan> gwern: the other lines are not aligned with the let
12:55:30 <faxathisia> > "10.1234" !! 3
12:55:31 <lambdabot>  '1'
12:55:36 <Cale> vincenz: Thankfully, that's fixed in 6.8 :)
12:55:40 <vincenz> Cale: great \o/
12:55:44 <faxathisia> > "10.1234" !! 3+2+1
12:55:44 <lambdabot>   add an instance declaration for (Num Char)
12:55:44 <lambdabot>     In the expression: (("10.123...
12:55:45 <litb> oh, i remember. !! is used to index an array
12:56:01 <litb> or something like that. it is explained in yaht
12:56:06 <glen_quagmire> > [1 ..] !! 3
12:56:07 <lambdabot>  4
12:56:08 <gwern> index a list
12:56:09 <Micio> Sizur: I'm sorry, could not connected to IRC
12:56:22 <Sizur> Micio: it's ok. was that what you needed?
12:56:24 <glen_quagmire> !! is bang bang in erlang
12:56:26 <Cale> godsai: Here's the infinite list of primes in Haskell:
12:56:26 * shapr boings cheerfully
12:56:30 <Sizur> litb: take care of the '.'
12:56:39 <shapr> Cale: You could go to #haskell-overflow if there's too much traffic.
12:56:55 <litb> ah, thanks you dude. i suppose if i want to get the nth digit after the decimal point, i have to first remove everything before the decimal point?
12:56:58 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
12:56:59 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:57:00 <gwern> oerjan: even if I align, it still has problems
12:57:05 <litb> or do some lg magic...
12:57:08 <Sizur> :t \n d -> (read (filter (/='.') (show n) !! d) :: Int)
12:57:09 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
12:57:09 <lambdabot>     In the first argument of `read', namely
12:57:09 <lambdabot>         `((filter ((/= '.')) (show n)) !! d)'
12:57:12 <hpaste>  gwern annotated "what's wrong with my syntax here?" with "indent" at http://hpaste.org/5027#a2
12:57:17 <Cale> or, to be fancy, but even less efficient:
12:57:40 <Micio> Sizur: I downloaded GHC only 73%, I have slow net...:(
12:57:45 * byorgey throws shapr a lambdarang
12:57:59 * shapr dodges furiously
12:58:03 <Cale> > nubBy (((> 1) .) . gcd) [2..]
12:58:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:58:07 <shapr> Hiya byorgey!
12:58:12 <byorgey> hi shapr!
12:58:17 <Sizur> :t \n d -> (read ((filter (/='.') (show n)) !! d) :: Int)
12:58:18 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
12:58:18 <lambdabot>     In the first argument of `read', namely
12:58:18 <lambdabot>         `((filter ((/= '.')) (show n)) !! d)'
12:59:08 <Cale> godsai: Because Haskell is evaluated outermost first, pieces of data which nothing ever looks at simply won't be computed.
12:59:11 <litb> Sizur: i mean, if i got 300.01234 , i want to get 01234 and then index into that
12:59:18 <byorgey> shapr: how's code? =)
12:59:26 <litb> since the teacher told me something i have to compute up to the accuracy of 10^(x)
12:59:39 <Sizur> litb: yeah split at '.' if you need to index after the point
12:59:41 <Cale> godsai: ...which lets you work effectively with infinite datastructures :)
12:59:47 <byorgey> litb: use dropWhile (/='.') first?
12:59:53 <lollicide> oerjan, heh.. same thing. :/ (when i thread (a,b) as state and only insert on the fst and only lookup on the snd.. (and loop the fst back as the snd when i run the parser)
12:59:54 <litb> so now i want to see how the xth digit after the decimal point changes to see whether it stays or still varies
13:00:06 <litb> Sizur: ah, clever
13:00:11 <Sizur> litb: do you know what's the accuracy of Double?
13:00:27 <litb> Sizur: he put it up to 10^(-12)
13:00:39 <litb> i think that double is good enof for that?
13:01:07 <litb> Sizur: i wonder whether it's still '.' in another locale than C
13:01:39 <Cale> godsai: Another big difference between Haskell and most of the popular languages is the type system. Haskell's typesystem is *really* effective at catching bugs. I spend around 1/10 the time debugging Haskell programs than programs in a dynamically typed or more weakly typed language (like Java or C), simply because the compiler catches so much.
13:01:54 <oerjan> > floatRange (undefined :: Double)
13:01:56 <lambdabot>  (-1021,1024)
13:02:02 <oerjan> lollicide: ouch
13:02:26 <shapr> byorgey: It's imperative.
13:02:31 <oerjan> gwern: i _still_ think that syntax error is indentation
13:02:32 <litb>  > floatRange (undefined :: Double)
13:02:36 <litb> oops
13:02:46 <litb> like random i suppose
13:03:06 <gwern> oerjan: it seems to work if I put the do on its own line
13:03:42 <Sizur> godsai: and you debug the code before it is executed. many times you will find that your program simply works correctly if it compiles
13:03:52 <oerjan> gwern: right.  perhaps the unicode thing is screwing up the width of things that are not first on line
13:04:14 <oerjan> that or tab settings
13:04:23 <gwern> oerjan: unlikely. the unicode is just for display; the actual source file is still fine ascii
13:04:30 <oerjan> oh
13:04:46 <oerjan> well tabs then
13:05:07 * gwern only uses spaces
13:05:25 <oerjan> goblins.  pesky little buggers!
13:05:25 <gwern> now my trouble is 'data Flag = Maybe Transient'. it looks fine, but doesn't compile. transient isn't in scope
13:05:55 <gwern> oerjan: could be worse - gremlines! if there's one thing I learned from bugs bunny, it was to fear gremlins
13:06:05 <faxathisia> gwern, Define a type 'Transient'
13:06:41 <gwern> faxathisia: it's just a flag to represent an option
13:06:54 <oerjan> gwern: i think you want type not data
13:06:56 <faxathisia> ?
13:07:05 <gwern> case flag of Just Transient -> foo; Nothing -> bar
13:07:10 <gwern> oerjan: what is the difference?
13:07:23 <litb> meh, why was !! choosed as the index op? any idea?
13:07:28 <oerjan> data defines a new type, unconnected to the old Maybe
13:07:32 <faxathisia> Transient is a value then
13:07:43 <oerjan> Maybe becomes its constructor
13:07:44 <hpaste>  lollicide pasted "parsing when the resulting data structure depends on the complete parse? (practical parsec problem)" at http://hpaste.org/5028
13:07:53 <faxathisia> gwern :t Transient
13:07:55 <lollicide> if anyone cares to look
13:08:13 <gwern> faxathisia: transient isn't defined anywhere
13:08:58 <faxathisia> data Flags = Transient | ... -- in that case
13:09:21 <Cale> litb: why not?
13:09:22 <faxathisia> type Flag = Maybe Flags
13:09:39 <Cale> litb: is there something more suitable?
13:10:27 <faxathisia> (Although, I would have a Empty flag maybe.)
13:10:39 <litb> !! looks like "now i throw" or "now , lets assert" or similar. it's just too intrusive for my soft eyes
13:10:50 <vincenz> litb: it should be, it is expensive as hell
13:10:57 <litb> oh
13:11:00 <Sizur> litb: because!! index out of bounds
13:11:06 <vincenz> it's O(N)
13:11:26 <litb> then maybe it's not all that good to use it to index digits in a numerical integration tool?
13:11:36 <Sizur> litb: nopes
13:11:46 <Sizur> lits: it was a simply hack ;)
13:12:03 <litb> hm. i think i should use some logarithm hacks then?
13:12:21 <Sizur> eh, 'b' is quite a distance from 's' :s
13:12:34 <Cale> litb: indexing into lists is generally a bad idea. If you can't process a list in a linear fashion, chances are you don't really want a list.
13:13:01 <litb> Cale: hm. then i need a show that converts into an array :)
13:13:13 <Cale> litb: Haskell has a decent Array library, yeah :)
13:14:00 <litb> i wonder how that would be done (placing a double into an array). i think converting it from the list into the array would be nonsense
13:14:09 <Sizur> litb: just multiply and modulate by 10
13:14:20 <litb> since that would also be big-oh-n
13:14:38 <Cale> litb: You can convert from a list to an array in linear time, and then that array can be indexed in constant time.
13:14:47 <kib> Cale : Did you ever thought about writing a book on Haskell ? Each time I'm passing here I'm learning something new :)
13:15:07 <litb> Sizur: ok, i will do that. i think that it cannot be done better. i will do it like that (ignoring possible overflows in this simple homework)
13:15:09 <Cale> kib: I have a few chapters written up. I should really work some more on it.
13:15:36 <byorgey> Cale: wait, really?  what sort of book is it?
13:15:39 <kib> Nice.
13:16:09 <faxathisia> :o
13:16:26 <Sizur> > let decimal n d = mod (n*(10^d)) (10^d) in decimal pi 1
13:16:27 <lambdabot>  Add a type signature
13:16:29 <Cale> byorgey: Well, now that Hutton's book is out, there's less of a need for it, but my plan was to go farther than that.
13:16:34 <faxathisia> Cale, I look forward to it
13:16:54 <Cale> faxathisia: Supposing that it ever gets finished ;)  I haven't touched it in months.
13:16:56 <kib> I think you'll find some readers here.
13:16:59 <byorgey> Cale: cool. and be sure to put lots of math in it. =)
13:17:00 <Sizur> > let decimal n d = mod (n*(10^d)) 10 in decimal (pi::Double) 1
13:17:01 <lambdabot>   add an instance declaration for (Integral Double)
13:17:01 <lambdabot>     In the expression:
13:17:01 <lambdabot>   ...
13:17:11 <byorgey> Cale: you can do whatever you like, of course =)
13:17:30 <Cale> byorgey: There aren't so many books which cover things like STM and so on at the moment.
13:17:35 <kib> Will it be a commercial book ?
13:17:40 <byorgey> Cale: true.
13:17:50 <Cale> kib: I don't have a publisher lined up or anything.
13:17:51 <Sizur> > let decimal n d = mod (fromRational (n*fromIntegral (10^d))) 10 in decimal (pi::Double) 1
13:17:52 <lambdabot>  Couldn't match expected type `Rational'
13:17:54 <dons> ?users
13:17:54 <lambdabot> Maximum users seen in #haskell: 454, currently: 441 (97.1%), active: 26 (5.9%)
13:18:54 <Sizur> > let decimal n d = mod (toInteger (n*fromIntegral (10^d))) 10 in decimal (pi::Double) 1
13:18:55 <lambdabot>   add an instance declaration for (Integral Double)
13:18:55 <lambdabot>     In the expression:
13:18:55 <lambdabot>   ...
13:18:55 <byorgey> Cale: I have a few chapters of a book I mostly haven't touched in months too!  we should start a club =)
13:18:56 <kib> Has anyone read Hutton's book here ?
13:18:56 <Cale> kib: I'd probably want to work out some deal where I could still distribute the book in any fashion I wanted, and they got to print some copies to be put in bookstores, while I could still give away PDFs :)
13:19:32 <gwern> kib: I recently bought it but I just started
13:19:33 <Cale> kib: I've read a few chapters from a not-for-distribution version from 2005. :)
13:19:46 <gwern> byorgey, Cale: you could put the chapters into the Haskell wikibook! :)
13:20:08 <byorgey> gwern: well, mine's not about haskell, but... ;)
13:20:14 <Cale> heh
13:20:15 <kib> ok, thanks. As you may know, I've bought it but can't read it because it was an ebook format.
13:20:32 <gwern> er, a differemt wikibook then?
13:20:40 <gwern> kib: nope. I'd ask for a refund, imo
13:21:06 <Cale> kib: right, Hutton was here the other day, and I mentioned you to him, he said that he'd already communicated with you and that he unfortunately couldn't do anything.
13:21:15 <kib> The ebooks.com site is full of such requests.
13:21:31 <phobes> Cale:  Where's 'here'?
13:21:37 <Cale> phobes: #haskell
13:21:41 <phobes> oh ok
13:21:48 <kib> Cale : yes, you're right, but I understand his point as he's the author.
13:22:25 <kib> But authors must be awrae of such practices.
13:22:32 <Cale> It's kind of sad that he couldn't give you a PDF or something.
13:22:49 <Cale> But he's probably forbidden from doing so by the printing company.
13:23:07 <ndm> kib: why can't you read an e-book
13:23:20 <Cale> ndm: The viewer doesn't run on Linux.
13:23:35 <Cale> (not even under wine)
13:23:37 <ndm> Cale: i thought the e-book security was notoriously easy to crack?
13:23:48 <gwern> so run it in wine
13:23:56 <ndm> some of the old ones were even ROT13 encrypted...
13:23:56 <Cale> ndm: I tried to crack it, but this version of the security is too new.
13:24:16 <ndm> Cale: couldn't a windows user set up screen scraping software, and crack it that way?
13:24:19 <Cale> ndm: It's probably easy, but the tools haven't been extended to handle his case yet.
13:24:32 <Cale> Yes, that would be the brute force approach :)
13:24:40 <kib> In fact I can read it (with glasses *100) online only, with a very weird interface : they must keep it, a great example on how not to do a GUI app :)
13:24:42 <Cale> Maybe make up a djvu of screenshots :)
13:25:06 <kib> Each page is translated from PostScript to gif...a pleasure
13:25:11 <Cale> nice
13:25:17 <gwern> 'type checker: "You fool! \ What you request makes no sense \ rethink your bad code."'
13:25:29 <byorgey> haha!
13:25:31 <byorgey> gwern++
13:25:39 <gwern> er. mischan. I'm trying to invent a new genre of haikus, 'haskus'
13:25:47 * shapr laughs
13:25:50 <shapr> gwern: That's great!
13:26:31 <Micio> Sizur: when I will want insert square, then how?
13:26:40 <gwern> (although if they are all that humorous, I might have to claim descent from senryuus instead :)
13:27:18 <Cale> kib: It's especially annoying as it's nearly as expensive as the paper version, which ought to be a crime.
13:27:28 <kib> If some of you discovering Haskell and coming from OO programming want the pdf version of 'Haskell for C programmers', I've made a pdf from it : http://kib2.free.fr/Haskell/hfcp.pdf
13:27:42 <ndm> Cale: i spotted that, i think it was actually slightly more than the Tesco version...
13:27:48 <Cale> jeez
13:28:02 <Sizur> Micio: [("1","2"),("3","4"),("5","6"),("6","1")]++edges
13:28:08 <kib> Cale : you're right, now I must wait to buy the paper book.
13:28:39 <Cale> Interestingly, the full PDF of Haskell Road is *still* online.
13:28:52 <iddo> is there qsort example with pivot chosen randomly?
13:28:58 <kib> Cale : where ?
13:29:02 <Cale> http://homepages.cwi.nl/~jve/HR/HR.pdf
13:29:03 <gwern> Cale: really? ln pls
13:29:09 <Sizur> Micio: no
13:29:21 <smack_> haskell road is worth buying
13:29:22 <Cale> http://homepages.cwi.nl/~jve/HR/ doesn't link to it anymore, but it's still there.
13:29:22 <lambdabot> Title: The Haskell Road
13:29:49 <Sizur> Micio: [("1","2"),("2","3"),("3","4"),("4","1")]++edges
13:29:52 <kib> thanks, I'll something to read tonight :)
13:29:52 <ndm> iddo: if you have a linked list, that's usually a bad idea
13:30:04 <phobes> Cale:  Doesn't link to it, but if you can guess the URL it's still there?
13:30:24 <Cale> phobes: Or knew what the old link pointed to, or had it bookmarked, yeah.
13:30:35 <gwern> phobes: yep. downloads fine for me
13:30:47 <phobes> Someone have the URL?
13:30:52 <Cale> I just pasted it.
13:31:00 <phobes> ah ha silly me
13:31:18 <iddo> ndm: so is there haskell example of qsort with arrays?
13:31:22 <Sizur> Micio: in ghci you can do: sets $ [("1","2"),("2","3"),("3","4"),("4","1")]++edges -- to see the actual sets
13:32:11 <ndm> iddo: not that i've seen, but quicksort works best with mutable arrays, which are less common in haskell
13:33:06 <Cale> The sort which is used by Data.List is actually a mergesort
13:33:08 <iddo> is it even possible to get random element as pivot with linked list? i just want to try..
13:33:22 <ndm> iddo: yes, but its expensive!
13:33:41 <iddo> how do you get random element?
13:33:44 <Cale> iddo: Yes, though you have to pass a seed for a pseudorandom generator into the sort function.
13:33:58 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
13:33:59 <lambdabot> http://tinyurl.com/3yau3k
13:34:12 <iddo> ok
13:34:23 <Sizur> > let decimal n d = mod (floor (n*fromIntegral (10^(d+1)))) 10 in decimal (pi::Double) 3 -- litb
13:34:25 <lambdabot>  5
13:34:38 <iddo> but how will the pattern matching for the random pivot will work?
13:34:50 <iddo> x:xs pattern is 1st element...
13:34:50 <litb> wow, without logarighm even, Sizur ?
13:34:56 <Cale> iddo: It won't, you'll have to use something like splitAt
13:35:07 <Cale> > splitAt 5 [1..10]
13:35:08 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
13:35:15 <Micio> Sizur, but this program not return number graphs
13:35:22 <iddo> ok thanks
13:35:25 <Cale> > splitAt 5 "Hello, World"
13:35:25 <lambdabot>  ("Hello",", World")
13:35:29 <Sizur> Micio: main
13:35:42 <litb> > let decimal n d = mod (floor (n*fromIntegral (10^(d+1)))) 10 in decimal 33000.123 3 -- litb
13:35:43 <lambdabot>  0
13:35:56 <Sizur> Micio: or length $ sets edges -- in ghci
13:36:49 <Cale> iddo: You'll probably want to write a function  extract :: Int -> [a] -> (a,[a]);  extract n xs = (y, xs ++ ys) where (xs,y:ys) = splitAt n xs
13:36:49 <Sizur> litb: index starts at 0
13:36:59 <Cale> Let me just check...
13:37:04 <Cale> > splitAt 0 [1..10]
13:37:05 <Sizur> litb: modify (d+1) to d if you dont want it to
13:37:07 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
13:37:12 <litb> o.O well. i think i have to add log10(n) to it
13:37:17 <Cale> yeah, that's what you want :)
13:37:21 <litb> ah
13:37:49 <Cale> let extract n xs = (y, xs ++ ys) where (xs,y:ys) = splitAt n xs in extract 5 "Hello, World"
13:37:54 <Cale> > let extract n xs = (y, xs ++ ys) where (xs,y:ys) = splitAt n xs in extract 5 "Hello, World"
13:37:54 <lambdabot>  Exception: <<loop>>
13:38:02 <Cale> err...
13:38:03 <litb> ahare exceptions monads too?
13:38:11 <litb> (as they can fail)?
13:38:17 <litb> i mean, functions in math cannot fail
13:38:34 <Cale> oh, haha
13:38:40 <litb> but exceptions mark something irregular. so, if i have a function that throws, do i need to make it a Monad?
13:38:45 <Cale> duh!
13:38:54 <Cale> > let extract n zs = (y, xs ++ ys) where (xs,y:ys) = splitAt n zs in extract 5 "Hello, World"
13:38:55 <lambdabot>  (',',"Hello World")
13:38:55 <Sizur> litb: exceptions are implemented through monads, yeah
13:39:07 <Cale> (stupid choice of variable names :)
13:39:22 <litb> i see, not completely silly what i thought?
13:39:30 <Sizur> no ;)
13:39:53 <phobes> Cale:  Shouldn't that be a warning?
13:39:53 <Cale> litb: You can just use Maybe (which also happens to be a monad, though you don't have to care)
13:40:06 <Cale> phobes: Not necessarily.
13:40:06 <phobes> Why would one ever want to write "let f x = ... where x = ..."
13:40:22 <Cale> It shadows the parameter binding.
13:40:42 <phobes> ya...
13:40:46 <Cale> But yeah, it would be nice to exclude all possibility of shadowing.
13:41:09 <Cale> You could even make it completely illegal to shadow bindings like that.
13:41:29 <phobes> ya I was wondering if there was a legitimate case for it...
13:42:00 <Cale> Probably not.
13:42:18 <Cale> (other than for people who are too unimaginative to think of a fresh name)
13:42:29 <litb> any log other than ln in haskell?
13:42:36 <Cale> litb: there's logBase
13:42:36 <byorgey> if you use -Wall with ghc 6.8 it warns you about such shadowings.
13:42:43 <Cale> litb: But that's not even really necessary.
13:42:46 <phobes> Cale:  Even then, let f _ = ... is much better
13:42:50 <Cale> litb: log_b x = log x / log b
13:42:52 <litb> ah, nice
13:43:12 <litb> Cale: yeah, i know that such a thing exists. but i would better go for the faster :)
13:43:15 <hpaste>  faxathisia pasted "Who goes there" at http://hpaste.org/5029
13:43:27 <litb> tho, lets see
13:43:33 <litb> @src logBase
13:43:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:43:37 <litb> o.O
13:43:49 <Cale> :t logBase
13:43:50 <lambdabot> forall a. (Floating a) => a -> a -> a
13:43:58 <Cale> @src Floating Double
13:43:58 <lambdabot> Source not found. :(
13:44:03 <Cale> @src Double Floating
13:44:03 <lambdabot> Source not found. Do you think like you type?
13:44:05 <Cale> nope
13:44:08 <koeien> :t 10 `logBase` 10
13:44:09 <lambdabot> forall t. (Floating t) => t
13:44:12 <litb> why doesn't it know logBase ?
13:44:19 <koeien> > 100 `logBase` 10
13:44:20 <lambdabot>  0.5
13:44:32 <Cale> Well, that instance is large and boring, iirc.
13:44:59 <oerjan> Cale: a method goes last, not a class
13:45:40 <Cale> oh
13:45:49 <Cale> @src Double sin
13:45:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:45:52 <Cale> @src Double logBase
13:45:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:46:18 <hpaste>  Cale pasted "Instance" at http://hpaste.org/5030
13:46:24 <oerjan> of course if i had any belief it was actually there, i would have demonstrated instead of saying it :)
13:46:31 <Cale> It actually is implemented as log y / log x :)
13:46:43 <Micio> Sizur: when I insert   sets $ [("1","2"),("3","4")], than should return 2 as two graph   Yes?
13:47:03 <litb> while the x is the base?
13:47:09 <Cale> yes
13:47:10 <litb> i always forget what is what :)
13:47:11 <koeien> yeah
13:47:21 <Cale> log_a x = log_b x / log_b a
13:47:23 <litb> and am too lazy to think about the relations :)
13:47:33 <koeien> think of log 100 / log 10 and you'll remember :)
13:47:39 <faxathisia> ?djinn-env
13:47:39 <lambdabot> data () = ()
13:47:39 <lambdabot> data Either a b = Left a | Right b
13:47:39 <lambdabot> data Maybe a = Nothing | Just a
13:47:39 <lambdabot> data Bool = False | True
13:47:39 <lambdabot> data Void
13:47:40 <Sizur> Micio: length $ sets $ [("1","2"),("3","4")] -- yes
13:47:41 <lambdabot> type Not x = x -> Void
13:47:43 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:48:02 <phobes> Which is greater, 37^log 38 or 38^log 37?
13:48:06 <Cale> If there's only one definition you remember regarding non-natural logs, that would be the one to rememeber.
13:48:25 <Cale> Or even just  log_b x = log x / log b  (where log is, of course, the natural log)
13:48:37 <koeien> or any other log for that matter :)
13:48:59 <Cale> koeien: Right, but that can serve as a definition, from which you prove the more general case. :)
13:49:07 <koeien> yes of course :)
13:49:13 <litb> phobes: well, i suppose the former
13:49:19 <Cale> The natural log is the only one really worth caring about anyway.
13:49:20 <litb> nah, the latter i mean
13:49:26 <koeien> well i never think in "log in another base" anyway
13:49:29 <koeien> all logs are natural
13:49:31 <Cale> (he says in a channel full of CS people)
13:49:40 <phobes> litb:  one more guess :)
13:50:02 <litb> lolz. hmm
13:50:06 <Cale> Well, at least we can agree that the log base 10 is stupid, and doesn't deserve to be called 'log'.
13:50:24 <koeien> why is 2 different from 10 ?
13:50:36 <oerjan> so it should be called 'lol' then?
13:50:36 <koeien> yeah well, of course 2 /= 10 but you know what i mean :)
13:50:43 <phobes> litb:  x^log_b y = b^(log_b x log_b y) = y^log_b x
13:50:46 <litb> i suppose that it isn't that easy to spot that at the first glance, phobes
13:50:56 <litb> oh
13:51:03 <Cale> 2 at least comes up in actual circumstances which aren't contrived.
13:51:10 <litb> i see, now i get it
13:51:30 <Cale> x^y is defined as exp(y log x)
13:51:51 <Cale> (at least, for appropriate values of x)
13:51:55 <koeien> for x >0
13:51:58 <Cale> yes
13:52:11 <litb> i only know that y log x == log (x^y)
13:52:24 <Cale> Or complex nonzero values, taking log there to be some branch of the logarithm.
13:52:40 <koeien> yeah but "branches in the complex plane" are ugly imo :)
13:52:46 <Cale> (typically the canonical one, which is discontinuous along the negative real line)
13:53:06 <BMeph> koeien: There are 10 kinds of people in the world...
13:53:09 <koeien> i just think of log as an isomorphism from R+ with multiplication to R with addition, and all rules follow
13:53:13 <Valodim> don't go there
13:53:18 <phobes> I prefer making the branch cut along y = sin x, x<0
13:53:30 <Cale> phobes: hahaha
13:53:33 <litb> but then e^log erases each other ...
13:54:04 <oerjan> koeien: no it doesn't, you need measurability as well...
13:54:18 <oerjan> axiom of choice ftw
13:54:58 <Micio> Sizur: then this program is super!!!:)
13:55:09 <Micio> *than
13:55:13 <BMeph> ...those who use binary naturally, and those who don't. ;)
13:55:20 <litb> people in ##c++ talk about horsecocks, people in #haskell talk about "branches in the complex plane" . funny
13:55:34 <dons> mm
13:55:40 <Sizur> Micio: and that function is only 7 lines. is not haskell the best?
13:55:47 <Cale> litb: I wonder where they talk about horsecocks in the complex plane?
13:55:55 <koeien> litb: and then they say functional programming is hard... unbelievable :)
13:56:13 <phobes> I heard "C++ for dummies" is the official language reference
13:56:43 * faxathisia snickers
13:59:31 <Micio> Haskell, all language is good, when understand him :)
14:00:02 <dons> using the power of rss :)
14:00:22 <dons> hmm
14:00:29 <dons> e_wrong_chan
14:01:02 <shapr> Haskell RSS!
14:01:03 <faxathisia> *Main> take 6 $ inhabitants (__ :: [Bool])
14:01:04 <faxathisia> ["Nil","Cons (True) (Nil)","Cons (False) (Nil)","Cons (True) (Cons (True) (Nil))","Cons (False) (Cons (True) (Nil))","Cons (True) (Cons (False) (Nil))"]
14:01:16 <faxathisia> this is cool :D
14:04:24 <vincenz> faxathisia: what lib is that
14:04:58 <faxathisia> I define   class Inhabitants a where inhabitants :: a -> [String]
14:05:03 <Cale> log(1/(1-x)) = sum over k >= 1 of x^k/k -- nice way to define log for formal power series. :)
14:05:11 <vincenz> faxathisia: why
14:05:15 <vincenz> faxathisia: I would not go that wa
14:05:19 <vincenz> faxathisia: I would do
14:05:22 <vincenz> inhabitants :: [a]
14:05:24 <vincenz> and then use show
14:05:44 <vincenz> and then > map show (inhabitants :: [Type])
14:06:07 <vincenz> faxathisia: that way you can use it for other stuff, and in fact I think they already exist
14:06:10 <ndm> you can even define many Inhabitants with Enum and Bounded, for free
14:06:10 <vincenz> check out scheck
14:06:21 <ndm> ah yes, scheck :)
14:06:32 <byorgey> scheck out scheck, even =)
14:06:46 <faxathisia> Let me try that
14:09:08 <faxathisia> That works tonnes better :D
14:09:29 <phobes> Cale:  Does that have any properties that would make you want to call it log?   Or just analogy with the integral definition?
14:10:27 <Cale> phobes: It has that if a in C[[x]] (complex power series) is such that a(0) = 1, then log(a) can be defined, and D_x log(a) = a^-1 D_x a
14:10:35 <Cale> Where D_x is formal differentiation.
14:10:45 <Cale> Also, log(exp(x)) = x
14:11:35 <glen_quagmire> can there be an infix function that takes more than 2 parameters?
14:11:39 <Cale> Where exp(x) = sum over k >= 0 of x^k / k!
14:11:44 <Cale> glen_quagmire: sure
14:12:03 <faxathisia> @src on
14:12:03 <lambdabot> (*) `on` f = \x y -> f x * f y
14:12:06 <Cale> glen_quagmire: It's just an infix function which takes two parameters and returns a function of the rest.
14:12:22 <Cale> :t (.)
14:12:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:12:29 <Sizur> > exp 1
14:12:30 <lambdabot>  2.718281828459045
14:12:34 <Cale> (f . g) x = f (g x)
14:12:40 <glen_quagmire> > let f a b c = a + b + c in 1 2 `f` 3
14:12:40 <lambdabot>   add an instance declaration for (Num (t -> a))
14:12:50 <phobes> Cale:  I'm confused... that's the usual def of exp(), right?  How can this new log also be an inverse?
14:13:17 <Micio> Sizur: I've got one more detail...this entry is difficult[(" "," "),(" "," ")], it would be better without commas [( , ),( , )]...would it be possible?
14:13:38 <byorgey> phobes: but it's the same log =)
14:13:47 <Codex_> cale: that's pretty nice, associativity of compostion (.).
14:13:52 <Sizur> Micio: you said input does not matter
14:14:03 <Sizur> Micio: input format.
14:14:06 <phobes> byorgey: oh, I didn't understand the point he was making
14:14:10 <phobes> ok let me think about this
14:14:33 <Sizur> Micio: how do you want to input?
14:14:44 <byorgey> well, I should say, it's the same log for convergent power series, plus a few extra things that it's defined for as well
14:15:08 <phobes> oh ya, i'm being stupid sorry :)
14:15:32 <phobes> I didn't notice the log(1/(1-x)) on the lhs
14:15:39 <Cale> phobes: Well, log itself doesn't quite have a series expansion. But if a is some series with a(0) = 1, we can define log(a) to be log [1/(1 - [1 - 1/a])]
14:16:01 <phobes> I'm with you, you did an expasion about 1
14:16:12 <phobes> ish
14:16:26 <Cale> It's sort of a funny kind of expansion :)
14:16:54 <phobes> ya interesting
14:17:13 <phobes> What do you work on Cale?
14:17:14 <Cale> That inverse actually makes the properties easier to prove.
14:17:31 <olsner> oh, darcs push was really neat
14:17:35 <phobes> You're not at galois are you?
14:18:01 <Cale> phobes: Nope, I'm not-yet-a-grad-student.
14:18:10 <phobes> ah ok
14:18:55 <hpaste>  sizur annotated "DisjointSets" with "v4" at http://hpaste.org/5025#a3
14:19:11 <Sizur> Micio: ^
14:20:10 <Cale> There was a clerical error on my transcript (course with typoed mark implying a fail) which I didn't find out about until much too late for anything to be done about it, and so right now I'm taking a distance ed course to fill the gap. Once that's done, I'll apply to grad schools for pure mathematics. Hopefully something along the lines of algebraic combinatorics.
14:20:55 <Cale> (annoyingly, I'd gotten the error "corrected" before, and thought that all was well, but the corrections were never actually made)
14:21:11 <phobes> Cale:  Your aim is a career in acaemia?
14:21:20 <Cale> phobes: Pretty much, yeah.
14:22:35 <Cale> CS is sort of a hobby of mine. I thought about going to grad school for it, but decided that even being a CS grad student appears to involve too much actual coding.
14:22:44 <BMeph> srid: I sent you an email asking for an explanation on your metric - just a warning. :)
14:22:44 <Philippa> Cale: ouch, there're times I'm really glad to live in a country with reasonable data protection legislation
14:22:47 <Cale> So pure mathematics it is :)
14:23:04 <Cale> Philippa: yeah
14:23:49 <phobes> Cale:  I was in a similar situation ... I was undergrad CS / Math, and thought my CS classes were pretty lame so went into grad math
14:23:55 <phobes> (pure math)
14:24:19 <Cale> Philippa: the prof for that course (a music course with little actual physical evidence) has left the country, and the uni apparently destroys records rather quickly, so I'm out of luck.
14:25:13 <Cale> phobes: What area do you study?
14:26:01 <phobes> My thesis was in minimal surfaces (complex analysis, geometry)
14:26:34 <phobes> I actually wish I'd gone into CS
14:27:00 <phobes> I went into the Math program without having a good idea of what I was going to be researching
14:27:50 <phobes> I recommend finding a program where they're doing research you know you're interested in - thesis is very grueling if you'd rather be doing something else :)
14:27:59 <Cale> yeah
14:28:07 <Philippa> Cale: I guess this is an argument for getting stuff in writing :-(
14:28:13 <Cale> Philippa: right :)
14:29:06 <BMeph> Off for home - talk with y'all soon.
14:33:26 <Micio> Sizur: yes, it's easier...:)
14:35:06 <Micio> Sizur: thank you very much
14:35:06 <Micio> !!!:)
14:35:43 <Sizur> Micio: your welcome. i hope you will study how this code works :)
14:36:15 <HairyDude> Prelude Data.Graph.Inductive> insEdge (1,2,()) empty :: Gr () ()
14:36:15 <HairyDude> *** Exception: Data/Graph/Inductive/Graph.hs:250:26-59: Irrefutable pattern failed for pattern (Data.Maybe.Just (pr, _, la, su), g')
14:36:17 <HairyDude> is that a bug?
14:36:32 <HairyDude> or just a "don't do that" moment?
14:37:21 <Micio> Sizur: certainly...the most important is that I have the code...:)
14:39:27 <Micio> Sizur: and Sorry for my english...:D
14:40:24 <Sizur> Micio: the more you use it, the better it will be. so do not say sorry
14:43:22 <lispy> "Inferred type is less polymorphic than expected"
14:43:26 <lispy> what is GHC trying to tell me?
14:43:40 <phobes> It's disappointed in you
14:43:53 <mauke> > let f :: a -> a; f x = x + 1 in f
14:44:04 <lambdabot>   add (Num a) to the type signature(s) for `f'
14:44:04 <lambdabot>     In the expression: x + 1
14:44:04 <lambdabot>  ...
14:44:35 <sjanssen> > let f :: a -> a; f () = () in f
14:44:35 <lambdabot>   ()
14:44:35 <lambdabot>     In the definition of `f': f () = ()
14:44:35 <lambdabot>     In the expression:
14:44:35 <lambdabot>         l...
14:45:12 <shardz> What would I want to do if I wanted sin() cos() and tan() (as well as sin-1(), cos-1() tan-1()) in haskell?
14:45:30 <mauke> :t [sin, cos, tan]
14:45:32 <lambdabot> forall a. (Floating a) => [a -> a]
14:45:34 <sjanssen> > cos 0
14:45:35 <lambdabot>  1.0
14:45:41 <mauke> > sequence [sin, cos, tan] 42
14:45:42 <lambdabot>  [-0.9165215479156338,-0.39998531498835127,2.2913879924374863]
14:45:56 <shardz> _ex_cellent
14:45:57 <Cale> > atan 1
14:45:58 <lambdabot>  0.7853981633974483
14:46:03 <Cale> > 4 * atan 1
14:46:04 <lambdabot>  3.141592653589793
14:46:17 <Cale> (similarly, acos, asin are defined)
14:46:20 <litb> hm, just to be sure once again..
14:46:45 <shardz> My math skills are weak, atan == tan -1?
14:46:51 <Cale> There's also sinh, cosh, tanh, asinh, acosh, atanh
14:46:52 <shardz> tan^-1
14:47:01 <Cale> shardz: compositional inverse, yeah
14:47:07 <litb> the IO Monad executes its action when the >>= operator is called?
14:47:09 <glen_quagmire> arctan = inverse of tan
14:47:15 <glen_quagmire> :t arctan
14:47:15 <lambdabot> Not in scope: `arctan'
14:47:17 <shardz> atanh?
14:47:23 <koeien> :t atan
14:47:24 <lambdabot> forall a. (Floating a) => a -> a
14:47:24 <shardz> erm, tanh?
14:47:29 <Sizur> > tan**(-1)
14:47:29 <lambdabot>   add an instance declaration for (Floating (a -> a))
14:47:29 <lambdabot>     In the expression: ...
14:47:31 <Cale> Hyperbolic tangent.
14:47:37 <shardz> Thanks.
14:47:40 <Cale> and hyperbolic arctangent
14:47:49 <shardz> You guys are fantastic. I should really go out and buy a haskell book.
14:47:50 <mauke> litb: no
14:47:51 <Sizur> > tan 1**(-1)
14:47:51 <lambdabot>  0.6420926159343306
14:48:08 * RayNbow has never had to use tanh and the other hyperbolic trig functions
14:48:10 <glen_quagmire> > 1 == atan (tan 1)
14:48:11 <lambdabot>  False
14:48:25 <glen_quagmire> > 1.0 == atan (tan 1)
14:48:26 <lambdabot>  False
14:48:32 <glen_quagmire> > atan (tan 1)
14:48:33 <lambdabot>  1.0
14:48:36 <davidL-> > atan 1 == pi
14:48:37 <lambdabot>  False
14:48:42 <mauke> > 1 - atan (tan 1)
14:48:43 <lambdabot>  -1.8106176280507924e-17
14:48:47 <Cale> > atan 1 == pi/4
14:48:47 <lambdabot>  False
14:48:53 <litb> atan (-1) == pi
14:48:54 <Cale> > atan 1 - pi/4 < 0.00001
14:48:55 <lambdabot>  True
14:48:56 <RayNbow> (and if I have to use them, I'll go fetch that huge Calculus book that can be used as a murder weapon from my room :p)
14:48:58 <litb> > atan (-1) == pi
14:48:58 <lambdabot>  False
14:49:01 <litb> hmm
14:49:03 <glen_quagmire> how can I compare floating point numbers reasonablly?
14:49:10 <Cale> > 4 * atan 1
14:49:11 <lambdabot>  3.141592653589793
14:49:13 <glen_quagmire> 0 == (a - b) ?
14:49:18 <litb> > atan (-1)
14:49:18 <sjanssen> glen_quagmire: you can't, really
14:49:18 <lambdabot>  -0.7853981633974483
14:49:22 <litb> oh
14:49:25 <shardz> > 1.0 == atan (tan 1)
14:49:25 <lambdabot>  False
14:49:26 <mauke> glen_quagmire: abs (a - b) < epsilon
14:49:26 <Cale> glen_quagmire: abs (a - b) < eps
14:49:27 <shardz> ...
14:49:32 <czShadoW> > tan (pi / 2)
14:49:32 <lambdabot>  1.6331778728383844e16
14:49:34 <litb> atan party
14:49:35 <shardz> I think lambdabot it broken
14:49:36 <glen_quagmire> > 0 == (1 - atan (tan 1))
14:49:37 <lambdabot>  False
14:49:39 <Sizur> quicksilver:  that's what i'm talking about when i meant we need simplification in compiler
14:49:46 <czShadoW> Hm
14:49:53 <Cale> glen_quagmire: that's due to numerical error
14:50:00 <Sizur> glen_quagmire: please consider to never compare floating numbers for equality
14:50:01 <Cale> > 1 - atan (tan 1)
14:50:01 <glen_quagmire> > 0.005 > (1 - atan (tan 1))
14:50:01 <lambdabot>  -1.8106176280507924e-17
14:50:02 <lambdabot>  True
14:50:04 <shardz> Because ghci evaluates 1.0 == atan (tan 1) is broken
14:50:04 <glen_quagmire> yay!
14:50:08 <RayNbow> hmm,  1 == atan (tan 1) is false according to lambdabot?
14:50:10 <quicksilver> Sizur: I'm not sure, I think it would only mask the problem.
14:50:18 <shardz> > tan 1
14:50:19 <lambdabot>  1.5574077246549023
14:50:27 <shardz> > atan (tan 1)
14:50:28 <glen_quagmire> Haskell doesn't know atan . tan is identity?
14:50:28 <lambdabot>  1.0
14:50:33 <quicksilver> Sizur: because you'd get some identities working, which could be simplified, and others still failing.
14:50:38 <glen_quagmire> > (atan . tan) 1 == 1
14:50:38 <lambdabot>  False
14:50:47 <Cale> RayNbow: because of rounding at various points, it only ends up being very close to 1, not equal to it.
14:50:50 <RayNbow> glen_quagmire: the problem is actually that floating points can be inaccurate
14:50:52 <shardz> > 1.0 == atan (tan 1)
14:50:52 <lambdabot>  False
14:50:53 <quicksilver> glen_quagmire: No. Why would it. It's not a useful identity.
14:50:56 <faxathisia> Why should it?
14:51:02 <quicksilver> glen_quagmire: it doesn't make any interesting programs run faster :)
14:51:02 <RayNbow> Cale: I know, but on my machine it happens to be True
14:51:06 <sjanssen> shardz: it's a difference between rounding modes when certain optimizations are active
14:51:13 <shardz> sjanssen: okay
14:51:15 <quicksilver> RayNbow: -fexcess-precision
14:51:19 <Cale> RayNbow: perhaps your floats are a different size :)
14:51:36 <quicksilver> lambdabot has a slightly non-standard option choice.
14:51:38 <glen_quagmire> > (1.0 :: Float) == (atan (tan 1) :: Float)
14:51:39 <lambdabot>  False
14:51:44 <RayNbow> ah
14:51:47 * RayNbow sets the flag
14:51:57 <Cale> Basically, you can't rely on == for floating point numbers to do anything too reasonable.
14:52:00 <glen_quagmire> > (1.0 :: Int) == atan (tan 1)
14:52:00 <lambdabot>   add an instance declaration for (Floating Int)
14:52:10 <RayNbow> hmm
14:52:17 <RayNbow> quicksilver, :s -fexcess-precision, right?
14:52:42 <Cale> If you want to compare floating point values, it should always be by taking the absolute value of their difference and seeing if that's small enough.
14:53:00 <phobes> > atan(1)*0 == 0
14:53:00 <lambdabot>  True
14:53:12 <mauke> > (1/0 - 1/0) < 0.1
14:53:13 <lambdabot>  True
14:53:24 <quicksilver> RayNbow: you can't simulate it
14:53:32 <quicksilver> RayNbow: lambdabot is compiled, your ghci is interpreting
14:53:40 <quicksilver> RayNbow: so, ghci will never use FPU ops
14:53:43 <sjanssen> @check (\a b -> (a + b :: Float) - a == b)
14:53:43 <lambdabot>  Falsifiable, after 6 tests: 3.6666667, 3.0
14:53:47 <RayNbow> ah
14:54:40 <phobes> >atan(1) == atan(1)
14:54:48 <phobes> > atan(1) == atan(1)
14:54:49 <lambdabot>  True
14:56:04 <shag> @pl (\s -> (length s) > 1)
14:56:04 <lambdabot> (> 1) . length
14:56:45 <HairyDude> well that's rather inconvenient - if g already contains a node n, insNode n e throws an exception
14:56:49 <mauke> not . null . drop 1
14:57:09 <ptolomy> Woo. That modularization that I was complaining gave me a few percent performance lost yesterday made it possible for me to make some optimizations that have given me an over-all performance increase of something like 30%. High level optimization ftw.
14:57:34 <Sizur> > drop 1 []
14:57:36 <lambdabot>  []
14:58:09 <phlpp> @index Pi
14:58:09 <lambdabot> bzzt
14:58:31 <phlpp> > cos(3.141592/3)
14:58:39 <lambdabot>  0.5000001886751096
14:58:40 <sarehu> > cos (pi / 3)
14:58:41 <lambdabot>  0.5000000000000001
14:58:44 <sarehu> :t pi
14:58:45 <phlpp> :>
14:58:47 <lambdabot> forall a. (Floating a) => a
14:58:58 <czShadoW> > 0 / 0
14:59:05 <lambdabot>  NaN
14:59:10 <phlpp> doh, floating point _is_ evil
14:59:47 <Sizur> @src pi
14:59:47 <lambdabot> Source not found. You type like i drive.
14:59:54 <sarehu> phlpp: there's   class .. => Floating a where { ... ; pi :: a ; ... }
14:59:56 <Cale> > let f x = x / x in f 0 == f 0
14:59:56 <lambdabot>  False
15:00:08 <Sizur> @index pi
15:00:09 <lambdabot> Prelude
15:00:11 <mauke> @scheck \x -> x == (x :: Double)
15:00:13 <lambdabot>   Completed 79 test(s) without failure.
15:00:28 <mauke> @scheck \x -> 1/x == (1/x :: Double)
15:00:29 <lambdabot>   Completed 79 test(s) without failure.
15:00:30 <phobes> > NaN == NaN
15:00:30 <lambdabot>   Not in scope: data constructor `NaN'
15:00:32 <phlpp> sarehu: ah ok
15:00:33 <Cale> Smallcheck really should include NaN in its tests.
15:00:37 <phobes> > 0/0 == 0/0
15:00:38 <lambdabot>  False
15:00:46 <mauke> @scheck \x -> x/x == (x/x :: Double)
15:00:48 <lambdabot>   Failed test no. 1. Test values follow.: 0.0
15:01:33 <Cale> > let x = 0/0 in x == x || x /= x
15:01:34 <lambdabot>  True
15:01:51 <Cale> > (0/0) /= (0/0)
15:01:52 <lambdabot>  True
15:01:53 <sjanssen> dons: we should make the 'numbers' library available in lambdabot -- real numbers, automatic diferentiation, symbolic numbers would all be fun toys
15:02:02 <dons> oh, that does sound fun, yes.
15:02:07 <dons> more math stuff for #haskell
15:02:11 <phlpp> :D
15:02:12 <dons> sounds like a job for .. Cale-man!
15:02:12 <phobes> Why does NaN =/= NaN?
15:02:36 <phobes> Shouldnt' == be an equivalence relation...?
15:02:49 <koeien> phobes: floating point computations are the devil
15:02:50 <dons> sigh :)
15:02:53 <Cale> phobes: IEEE doesn't think so
15:02:56 <sjanssen> phobes: it's the semantics recommended by the IEEE standard
15:02:57 <phlpp> are there some papers on 'differentatio-systems' or isn't it that hard to write one on one's own (-> there are no papers)?
15:03:24 <Sizur> NaN = not a number /= infinity
15:04:01 <sjanssen> dons: how does one add modules to lambdabot's scope?
15:04:02 <phobes> I know it's IEEE, but does anyone know the rationalle?
15:04:02 <phlpp> > tan(pi/2)
15:04:07 <lambdabot>  1.6331778728383844e16
15:04:14 <Philippa> phobes: because there are many different things that'll yield NaN
15:04:38 <Philippa> also, I suspect because they didn't have a third option (NaB, maybe)
15:04:41 <phobes> Philippa:  So NaN is supposed to represent a whole bunch of different values?
15:04:52 <phobes> (none of which are equal)
15:04:53 <Sizur> phobes: not a number is not a part of a Num class? how can one assume it is a part of an Eq class (not talking haskell here)
15:04:53 <dons> sjanssen: the easiest way is to add them to scripts/RunPlugs.hs, which contains the list of modules to be in scope
15:04:54 <Philippa> it's supposed to represent that whatever the hell it is, it's not a number
15:05:27 <Philippa> you might as well ask if _|_ == _|_
15:05:43 <phlpp> > 90/360)
15:05:44 <lambdabot> Unbalanced parentheses
15:05:45 <phlpp> > 90/360
15:05:46 <lambdabot>  0.25
15:05:50 <Philippa> only they weren't happy with _|_ as the result
15:06:01 <Sizur> :t (%)
15:06:02 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:06:15 <phlpp> > tan(pi/2-0.00001_
15:06:15 <lambdabot> Unbalanced parentheses
15:06:17 <phlpp> > tan(pi/2-0.00001)
15:06:18 <lambdabot>  99999.9999960541
15:06:21 <sjanssen> dons: okay if I do so?  You'll need to install the 'numbers' package so @run keeps working :)
15:06:43 <phlpp> lambdabot: sure about tan(pi/2) != 0/0? :>
15:06:45 <phlpp> at least divison by zero
15:06:47 <Sizur> :t (^^)
15:06:47 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:06:53 <sarehu> > let x = 0/0 in (compare x (0/0), x > 0/0)
15:06:53 <Sizur> :t (**)
15:06:53 <lambdabot>  (GT,False)
15:06:53 <Cale> btw, it would be nice to have Math.OEIS imported as well :)
15:06:54 <lambdabot> forall a. (Floating a) => a -> a -> a
15:07:09 <Sizur> > (1%2)^^(-2)
15:07:10 <lambdabot>  4%1
15:07:16 <dons> sjanssen: ok.
15:07:30 <litb> hm, i've some real difficult question i think
15:07:36 <sjanssen> dons, Cale: I'll apply the OEIS thing too
15:08:30 <phobes> Philippa:   Infinity isn't "a number" either, but it still equals itself, right?  I suspect there's some actual pragmatic reasoning behind not making it compare equal to itself, ...
15:08:37 <Sizur> @src compare
15:08:37 <lambdabot> compare x y | x == y    = EQ
15:08:37 <lambdabot>             | x <= y    = LT
15:08:37 <lambdabot>             | otherwise = GT
15:09:15 <Sizur> lol, looks like we need a forth line there
15:09:15 <hpaste>  dancor pasted "did cabal change in 6.8" at http://hpaste.org/5031
15:10:01 <sarehu> data Ordering = LT | EQ | GT | FileNotFound
15:10:14 <byorgey>   | otherotherwise = error "floating-point sucks"
15:10:26 <phlpp> !
15:10:33 <phlpp> byorgey got it :D
15:10:58 <phlpp> how's otherotherwise definied? :>
15:11:13 <mauke> otherotherwise = False
15:11:19 <phlpp> "if otherwise fails and the empire of the pure falls?" :>
15:11:47 <Sizur> then we simply selectively forget about what just happened
15:11:58 <byorgey> otherotherwise = if True == False then False else False
15:12:34 <phlpp> what about: if P=NP
15:12:35 <dancor> are there new complications to using hs-source-dirs or some such?
15:12:35 <phlpp> ? :>
15:12:49 <byorgey> phlpp: that works too =)
15:12:52 <phlpp> :D
15:12:57 <sarehu> instance IsString Bool where { fromString = (/= "otherwise") }
15:13:05 <dons> oh noes
15:13:25 <Cale> > 1**(0/0)
15:13:29 <lambdabot>  1.0
15:13:29 <dons> ok. i officially apologise for ever mentioning IsString.
15:13:37 <Cale> Curious :)
15:13:43 <Sizur> laziness
15:13:44 <dons> it had slept peacefully beneath the mountain (of ghc code) for 12 months
15:13:58 <mauke> instance (Read a) => IsString a where fromString = read
15:14:17 * dons slaps mauke 
15:14:25 * mauke cackles
15:14:31 <byorgey> dons: and now, awoken, it has come in wrath to devour innocent villagers ??
15:14:32 <Cale> uwahaha!
15:14:33 <Philippa> phobes: there're arguments for treating infinity as a number, and arithmetics in which you can do exactly that with one or more infinities
15:14:44 <Sizur> can we hack perl together within haskell using IsString?
15:15:04 <dons> still, IsString CString ...
15:15:13 <Cale> instance IsString (Double -> Double) where fromString "cos" = cos; fromString "sin" = sin; ...
15:15:14 <dons> Sizur: yeah, inline language code should be easy :)
15:15:19 <dons> right. exactly.
15:15:25 <dons> and that calls gcc ... :)
15:15:42 <lispy> I kinda think I confused GHC (but not as much as it confused me)
15:15:51 <dons> Cale: i'll take that as a proposal :)
15:16:00 <Cale> lispy: pattern binding involving an existential?
15:16:09 <lispy> inline language code? that's what the Q monad is for, right?
15:16:18 <Cale> dons: haha
15:16:19 <lispy> Cale: um...maybe?
15:16:31 <byorgey> lispy: no, inline language code in OTHER languages ;)
15:16:31 <Cale> lispy: That produces a funny message :)
15:16:32 <mauke> @quote brain
15:16:32 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
15:17:10 <lispy> it's this Inferred type is less polymorphic than expected, but it's complaining about a variable I don't have.
15:17:22 <dons> "int foo(int i) { return (i * i); }" 42
15:17:27 <dons> would be valid
15:17:37 <lispy> it shows me the type of ps2s and gives the line/column, but I don't have that variable there.  I have _ps2s instead
15:17:47 <Cale> Pat.hs:4:0:
15:17:47 <Cale>     My brain just exploded.
15:17:47 <Cale>     I can't handle pattern bindings for existentially-quantified constructors.
15:17:56 <dons> that's simon's brain, btw
15:17:56 <lispy> Cale: not that one
15:17:58 <dons> not ghc's.
15:18:11 <Sizur> wow. i already see perlers making home in haskellland
15:18:45 <lispy> Oh wait, it doesn't mean the variable was created there, just that the type was bound there
15:18:49 <lispy> Hmm...
15:18:49 <lispy> This is confusing!
15:19:41 <Pseudonym> http://arcanux.org/lambdacats/brain.jpg
15:19:57 <lispy> haha
15:22:22 <vincenz> Cale: what file is that
15:22:33 <lispy> ?hpaste
15:22:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:22:34 <Cale> !paste
15:22:34 <hpaste> Haskell paste bin: http://hpaste.org/
15:22:51 <hpaste>  Cale pasted "Pat.hs" at http://hpaste.org/5032
15:22:58 <vincenz> gracias senor Cale
15:23:14 <Cale> What's tebjex?
15:23:59 <hpaste>  lispy pasted "Sometimes Haskell makes my head hurt" at http://hpaste.org/5033
15:24:05 <Cale> http://arcanux.org/ shows a pair of hands with some masonic cipher writing "tebjex" on them.
15:24:05 <lambdabot> Title: Arcanux
15:25:10 <Cale> lispy: Inferred type is less polymorphic than expected means that the code you wrote made assumptions which weren't present in the type you explicitly gave something.
15:25:21 <Cale> That is, your explicit type is more polymorphic than the code you wrote.
15:25:27 <LoganCapaldo> lispy: rremind me never to look at your pastes again
15:25:33 <dcoutts__> @seen swiert
15:25:34 <lambdabot> I saw swiert leaving #haskell 2h 29m 23s ago, and .
15:25:36 <reilly> what's the state of the proposals for records in Haskell' ?
15:25:51 <lispy> Cale: I think I get that in the abstract
15:26:01 <Cale> reilly: There are some good ones, but nobody's agreed on implementing one.
15:26:06 <lispy> like saying foo :: a -> Int; foo x = x + 1
15:26:07 <reilly> I'd really like parameterizable records
15:26:14 <Cale> lispy: right
15:26:15 <nominolo> @seen mnislay
15:26:16 <lambdabot> I haven't seen mnislay.
15:26:18 <nominolo> @seen mnislai
15:26:18 <lambdabot> I haven't seen mnislai.
15:26:43 <dcoutts_> @tell swiert I'll apply the patch, if you want to file a feature request for better handling of ~/bin directories in general, then do feel free
15:26:44 <lambdabot> Consider it noted.
15:26:54 <Cale> reilly: Daan Leijen's system is my favourite (since it lacks lacks predicates, for one), at least in semantics. The syntax he used in the paper sucks though.
15:26:55 <allbery_b> @seen mnislaih
15:26:56 <lambdabot> I haven't seen mnislaih.
15:27:04 <nominolo> allbery_b: ah, thanks
15:27:06 <allbery_b> hm, trying to remember how h spells that
15:27:14 <dcoutts_> hia nominolo, still very busy at the moment? :-)
15:27:27 <nominolo> dcoutts_: whassup?
15:27:33 <dcoutts_> nominolo: I've been hacking on hackage QA and build reporting recently
15:27:37 <dons> dcoutts, kolmodin: Data.Binary.Strict.BitGet ..
15:27:49 <dcoutts_> dons: yes? the bit layer?
15:27:52 <Cale> (We really don't need the period to mean anything more than it already means. Using it as a module path separator was already a bad enough mistake without overloading it some more)
15:27:56 <reilly> Cale: syntax (due to organic feature accretion) is an ongoing problem with haskell
15:28:15 <dons> dcoutts_: just announced by Adam on the mailing list :)
15:28:26 <dcoutts_> dons: oh, right, I'll go look
15:28:30 <nominolo> anyone here applied to MSR before?
15:28:33 <allbery_b> thats the right spelling, it appears; google points me to his haskell wiki entry :)
15:28:35 <Cale> Also, I'm opposed to the idea of referring to record fields with a postfix notation.
15:28:49 <hpaste>  (anonymous) annotated "did cabal change in 6.8" with "(no title)" at http://hpaste.org/5031#a1
15:28:49 <dons> nominolo: ben lippmeijer has (did an internship there)
15:28:57 <dcoutts_> nominolo: bringert knows a little about that, but he'll not be around for a few days
15:28:58 <phlpp> byorgey: although i just read a few posts (especially liked that one on recounting rationals) i've to "admit" that's a really cool blog
15:29:00 <dons> nominolo: oh, and Binkley
15:29:02 <nominolo> dons: know his nick?
15:29:08 <reilly> Cale: you hae a link for that proposal
15:29:10 <nominolo> @seen Binkley
15:29:11 <Cale> sure
15:29:11 <lambdabot> I haven't seen Binkley.
15:29:16 <reilly> Cale: have
15:29:27 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
15:29:27 <lambdabot> http://tinyurl.com/392r4k
15:29:39 <Cale> It's implemented in Morrow.
15:29:51 <Cale> and apparently the Clean people wanted to steal it as well
15:29:53 <nominolo> Cale: i like that sugestion
15:30:04 <Cale> But nobody's yet bothered to implement it in GHC.
15:30:07 <nominolo> Cale: didn't get to the implementation part, yet, though
15:30:17 <phlpp> byorgey: seems to me like a 'math guy' wants people which are not that in math to participate in his world ;)
15:30:22 <nominolo> Cale: I'm going to suggest it for my internship
15:30:43 <nominolo> Cale: among other things ...
15:30:50 <Cale> nominolo: Just make sure that if you do it, you change the syntax from what's used in the paper to something more Haskellish :)
15:30:56 <dcoutts_> Cale: btw, are you at all familiar with Bayesian stuff at all? I think we need some Bayesian stats stuff for presenting information on the hackage website.
15:30:56 <phlpp> byorgey: which is just a great idea :>
15:31:01 <nominolo> Cale: like?
15:31:44 <nominolo> personally, i like postfix record selectors
15:31:51 <Cale> nominolo: Overload function application if you have to, or maybe steal an operator symbol.
15:32:06 <Cale> But not (.)
15:32:10 <nominolo> yeah, overloading "." again, is evil
15:32:17 <dcoutts_> yes
15:32:22 <nominolo> OCaml has "#" i think
15:32:23 <Cale> I'd prefer prefix record selection.
15:32:32 <reilly> Cale: thanks ... gotta go right now ... I'll read that tonight
15:32:34 <Cale> like x#pt
15:32:42 <bos> dcoutts_: bayesian stuff?
15:32:43 <Cale> rather than pt#x
15:32:43 <vincenz> Cale: interesting paper
15:33:10 <nominolo> Cale: x@pt
15:33:12 <bos> we should use "->", like a pointer dereference in C.  obviously nobody will be confused.
15:33:13 <byorgey> phlpp: you're talking about my 'mathlesstraveled' blog?
15:33:18 <dcoutts_> bos: ok, suppose I have 100 build reports for a package (submitted to the hackage server by cabal-install)...
15:33:20 <LoganCapaldo> I've a;ways though @ would be a good symbol for such things. data Point = Pt {  x :: Int, y :: Int } a = Pt 1 2 x@a, y@a
15:33:22 <vincenz> nominolo: bad choice, @ is often used for explicit function application
15:33:30 <LoganCapaldo> but that's already for as patterns in haskell
15:33:34 <phlpp> byorgey: yup
15:33:42 <vincenz> Use # :)
15:33:45 <vincenz> It's not used yet afaik
15:33:50 <byorgey> phlpp: cool, thanks =)
15:33:54 <Cale> Except in lots of code.
15:34:00 <vincenz> Cale: #?
15:34:01 <Cale> But that doesn't matter so much :)
15:34:05 <nominolo> vincenz: well, postfix in GHC internals
15:34:10 <dcoutts_> bos: each build report says if it worked or not and a bit of info about the environment, we want to figure out statistically what aspects of the environment correlate with build success/failure
15:34:18 <nominolo> vincenz: Int#, etc..
15:34:21 <vincenz> oh right
15:34:22 <Cale> # isn't in the libraries, but it's almost the only single-character infix operator which isn't taken
15:34:38 <LoganCapaldo> @type of
15:34:39 <lambdabot> parse error on input `of'
15:34:40 <mauke> ?
15:34:42 <vincenz> Cale: bah, take the ghc approach, break everything at each major release :)
15:34:48 <nominolo> bos: yes, that seems beginner-friendly
15:34:52 <dcoutts_> bos: eg we might have 50 build failures but 49 of those might be on windows, so we might conclude with a high level of confidence that windows => build failure
15:35:00 <LoganCapaldo> oh right of is already a keyword
15:35:12 <LoganCapaldo> I was gonna suggest x of pt y of pt
15:35:14 <litb> hm, how can i partially apply a function where the left out argument is somewhere in the middle?
15:35:33 <Cale> LoganCapaldo: I wonder if that actually *could* be done.
15:35:35 <litb> for example: integrate fnct methode y intervall , i want that y is left out
15:35:37 <LoganCapaldo> \a -> foo 1 a 2
15:35:50 <mauke> @pl \y -> integrate fnct methode y intervall
15:35:50 <lambdabot> flip (integrate fnct methode) intervall
15:35:50 <Cale> LoganCapaldo: it would certainly make parsing a bit stranger, but parsing is already hard
15:35:54 <bos> dcoutts_: sounds like you need a medical statistician,
15:36:07 <dcoutts_> bos: so overall we want to be able to present little tick/crosses for each package on their web pages saying if it works on windows, works with ghc-6.6 etc
15:36:12 <HairyDude> grr, all the functions in Data.Graph.Inductive take their arguments in an inconvenient order
15:36:15 <Cale> case x of pt of 6 -> ...
15:36:26 <Cale> oy...
15:36:35 <nominolo> is backtick used for anything?
15:36:36 <Cale> maybe not :)
15:36:43 <nominolo> point`x
15:36:45 <bos> nominolo: `on`
15:36:50 <nominolo> d'oh
15:36:59 * RayNbow just hacked something ugly in Haskell...
15:37:04 <dcoutts_> bos: I'm under the impression that someone with a knowledge of Bayesian analysis techniques could figure out the calculation to get what we want
15:37:09 <nominolo> let's use Unicode!
15:37:09 <litb> wow
15:37:09 <RayNbow> inspired by the Float discussion :+
15:37:16 <byorgey> RayNbow: congrats =)
15:37:17 <HairyDude> e.g. using a graph as the state in a state monad, you want to be able to do gets (deg v) for some vertex v, but you have to do gets (flip deg v) instead
15:37:21 <Cale> dcoutts_: I don't really know a whole lot about probability theory and statistics.
15:37:22 <litb> what is that @pl ? i would like to have that on my PC
15:37:26 <LoganCapaldo> subscripts!
15:37:27 <dcoutts_> Cale: ok, np
15:37:37 <LoganCapaldo> pt subscript x
15:37:38 <litb> it's awesome
15:37:44 <bos> dcoutts_: probably, yes.  like a medical statistician :-)
15:37:47 <LoganCapaldo> if that could be type easily
15:37:53 <nominolo> pt _ x
15:38:01 <nominolo> pt->x
15:38:10 <dcoutts_> bos: if we record versions of dependencies too and have a high level of confidence we could even automatically adjust the package's build-depends to reflect reality.
15:38:10 <byorgey> litb: there used to be GHCi On Acid, which was ghci + lambdabot
15:38:22 <byorgey> litb: but I don't know if it builds now
15:38:30 * bos is appallingly ignorant of statistics. "i have jaynes's book on bayesian analysis at home, but it's not exactly light reading."
15:38:36 <LoganCapaldo> pt{x}
15:38:38 <hpaste>  RayNbow pasted "Hacking with Maybe Floats" at http://hpaste.org/5034
15:38:45 * RayNbow hides
15:39:01 <Pseudonym> Incidentally, I don't want a package system that works stochastically.
15:39:02 <dcoutts_> bos: I've pretty much always avoided stats :-)
15:39:12 <dcoutts_> bos: and now I find I need it! ugg.
15:39:21 <LoganCapaldo> hmm I think pt{x} has multiple advantages
15:39:41 <LoganCapaldo> it's symettrical with pt { x = foo }
15:39:49 <bos> dcoutts_: happens to me every so often, too.
15:39:54 <Cale> yeah, I suppose I could live with that :)
15:39:55 <dcoutts_> bos: it seems to me to be the best way to solve the hackage QA problem, to use cabal-install to gather build results from 100's of clients, rather than just using a small number of build bots
15:40:07 <LoganCapaldo> and it doesn't as far as I know stomp on any existing keywords or syntax
15:40:12 <Cale> It's postfix, but it's postfix in a way that meshes well with existing syntax.
15:40:45 * RayNbow notices a problem
15:40:50 <Cale> nominolo: So yeah, probably use that :)
15:41:02 <bos> dcoutts_: it's an interesting idea, won't know how well it will work in practice until it's tried, eh?
15:41:25 <Cale> I wonder what happens to record syntax for ADT's when we have proper records as well?
15:41:32 <dcoutts_> bos: I've convinced myself already :-)
15:41:47 <dcoutts_> bos: but yeah, I guess we have to try it to really know
15:42:19 <nominolo> cube{topLeft{x}}
15:42:23 <nominolo> hm :/
15:42:43 <vincenz> Cale: does the scopedlabels thing work with typeclasses?
15:43:06 <Cale> vincenz: It doesn't explicitly discuss them.
15:43:11 <Cale> vincenz: So I don't know.
15:43:18 <vincenz> Cale: I would think not
15:43:24 <LoganCapaldo> nominolo: wouldnt it be cube{topLeft}{x} ?
15:43:25 <nominolo> it says it's orthogonal
15:43:30 <vincenz> since functors and type classes are somewhat mutually exclusive
15:43:30 <Cale> oh
15:43:40 <vincenz> and this system allows for functors
15:43:43 <Cale> yeah, and it actually even talks about polymorphic records
15:43:43 <RayNbow> byorgey: do you like the hack? :p
15:43:49 <nominolo> LoganCapaldo: hm
15:43:52 <LoganCapaldo> this is starting to look like nested hashes in perl :(
15:44:29 <LoganCapaldo> ooo
15:44:32 <byorgey> RayNbow: looks reasonable.  I hardly ever use floating-point though
15:45:04 <LoganCapaldo> {x pt} and also sugar such that {x topLeft pt} desugars to {x {topLeft pt}}
15:45:04 <RayNbow> byorgey: I had some trouble with the instance syntax though... (I rarely ever use it)
15:45:22 <LoganCapaldo> how about that?
15:45:30 <RayNbow> I first tried "instance Num (Maybe Float) where..." but that didn't work :p
15:45:32 <hpaste>  sciolizer pasted "Monomorphism restriction?" at http://hpaste.org/5035
15:45:46 <byorgey> RayNbow: heh, yeah, it takes a little getting used to I suppose
15:45:55 <Philippa> <vincenz> since functors and type classes are somewhat mutually exclusive <- how so?
15:46:11 <Philippa> certain instances can be seen as generating functors, sure
15:46:41 <byorgey> sciolizer: that's definitely not the MR.
15:46:47 <sciolizer> ok, what's the problem?
15:47:12 <LoganCapaldo> actualyl that sugar is probably a bad idea
15:47:12 <phlpp> byorgey: what was the point about perfect numbers? 2^(n-1) * (2^n - 1), where n and 2^n - 1 have to be prme?
15:47:15 <phlpp> *prime*
15:47:34 <sciolizer> How do I get readColumn to return values of different types without making a type class for it?
15:47:44 <byorgey> sciolizer: right, that's the problem.
15:48:05 * RayNbow pets his little, ugly hack...
15:48:06 <RayNbow> *Main> let f x = x/x :: Maybe Float in f 0 == f 0
15:48:06 <RayNbow> True
15:48:17 <sciolizer> byorgey: heh, ok.
15:48:25 <byorgey> phlpp: yes, all even perfect numbers are of that form.  and note that 2^n - 1 prime necessarily implies that n is prime.
15:49:32 <LoganCapaldo> > 0 :: Maybe Float
15:49:36 <lambdabot>   add an instance declaration for (Num (Maybe Float))
15:49:36 <lambdabot>     In the expression: ...
15:49:36 <phlpp> byorgey: hum, is there an odd perfect number?
15:49:41 <byorgey> sciolizer: note the MR only applies when you have bindings like foo = ...
15:49:41 <LoganCapaldo> oh
15:49:48 <byorgey> phlpp: excellent question!  no one knows =)
15:49:49 <LoganCapaldo> that wans't lb
15:49:54 <phlpp> byorgey: :D
15:49:56 <LoganCapaldo> phew
15:49:58 <sciolizer> byorgey: is there a way to do what I want to do, or will I just need to settle for making readColumn a type class function (which regrettable involves passing stmt and columns around explicitly, instead of wrapping them in a partial application or closure).
15:50:44 <byorgey> sciolizer: I'm not sure.  something to do with existential types perhaps...
15:51:06 <phlpp> byorgey: hehe, ok, i'll do some research on this tomorrow (actually i have to say in a few hours, gmt+1, you know)
15:51:20 <byorgey> phlpp: ok, cool =)
15:51:43 <Sizur> i want to install lambdadots into every channel on every irc server. strike team anyone?
15:51:50 <byorgey> hiya chessguy
15:51:55 <sciolizer> byorgey: You can't make types more specific once you've made them existential though, can you? The best you can do is serialize + deserialize I thought.
15:52:06 <chessguy> 'evening
15:52:12 <byorgey> sciolizer: I don't know.
15:52:22 <sciolizer> byorgey: ok. I'll just settle for the more explicit solution. :)
15:52:40 <sciolizer> byorgey: thanks for your help
15:52:49 <byorgey> sciolizer: sure
15:53:51 <LoganCapaldo> well existensionals lets you "mix" values of different type as long as they implement the class(es) of your existentional
15:54:07 <LoganCapaldo> i don't know if that helps
15:54:42 <sciolizer> LoganCapaldo: I need to be able to seperate them after I've mixed them though.
15:55:43 <LoganCapaldo> well you can build a half arsed version of Data.Dynamic w/ type classes + existensionals if you want
15:56:20 <dons> an "interesting" version, i'd argue
15:56:28 <dons> since it'd be statically checked :)
15:56:41 <LoganCapaldo> class Escape where escapeInt :: E -> Maybe Int ; escapeString :: E -> Maybe String ; ... etc ...
15:57:05 <LoganCapaldo> maybe those functions should be named rescueFoo instead of escapeFoo :)
15:57:17 <sciolizer> LoganCapaldo: lol. Too much work, but thanks for the suggestion. I think I can solve the problem by just being more explicit.
15:58:07 <sciolizer> LoganCapaldo: (explicit with code, not with type signatures)
15:58:41 <TomMD> Yay, final cabalized my silly little library and uploaded.
15:59:11 <Sizur> i'm goin' t'nitie-nite. g'nite y'all!
15:59:17 <TomMD> good night
15:59:29 <LoganCapaldo> who needs optional static typing when you've got static typing with optional dynamic typing? :)
16:00:25 <TomMD> LoganCapaldo: I've not seen Haskell dynamic typing made to look easy - do you have a blog or some such?
16:00:57 <LoganCapaldo> i have a blog, nothing about dyanmic typing on it, but it is pretty easy
16:01:06 <dons> TomMD: oh, its really rather simple. introduce a dynamic type with toDyn
16:01:08 <LoganCapaldo> @docs Data.Dynamic
16:01:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
16:01:12 <dons> > toDyn (1 :: Int)
16:01:14 <lambdabot>  <<Int>>
16:01:18 <TomMD> I could have used that today
16:01:23 <dons> that you can then do a typecase on at runtime to take apart
16:01:34 <dons> usually there's an existential you really want to use though
16:01:38 <TomMD> (mind you, I know such a library existed, I just figured it was excessivly complex and alpha)
16:01:41 <dons> since you know what ops are valid on a Dynamic
16:01:44 <dancor> but really, does ghc 6.8.1 cabal work with executable:
16:01:45 <TomMD> s/know/knew/
16:01:49 <hpaste>  sciolizer annotated "Monomorphism restriction?" with "solved by reducing code reusage" at http://hpaste.org/5035#a1
16:01:53 <LoganCapaldo> @type fromDynamic
16:01:54 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
16:02:02 <dancor> i tried not having hs-source-dir and putting everything in top-level too, same error
16:02:03 <LoganCapaldo> @type toDyn
16:02:04 <lambdabot> forall a. (Typeable a) => a -> Dynamic
16:02:06 <dancor> http://hpaste.org/5031
16:02:22 * TomMD brb
16:02:23 <LoganCapaldo> easy as pie
16:02:49 <dons> > let x toDyn "haskell" in case fromDynamic x of Just y -> show (y :: Int) ; Nothing -> "dynamic is agile"
16:02:50 <lambdabot>  Parse error at "in" (column 23)
16:03:13 <dons> well, you get the idea
16:04:31 <LoganCapaldo> > toDyn id -- it has limitations though
16:04:32 <lambdabot>  Add a type signature
16:04:43 <koeien> > toDyn (id::a->a)
16:04:44 <lambdabot>  Add a type signature
16:04:45 <dons> you can't do polymorphic dynamics without more work
16:04:47 <koeien> > toDyn (id::Int->Int)
16:04:49 <lambdabot>  <<Int -> Int>>
16:04:54 <dons> (i.e. existential wrappers, or a complicated fromDyn)
16:05:13 <dons> dynamic typing just isn't very useful when you've got a rich type system
16:05:29 <TomMD> Oh - here is one I ran into recently
16:05:32 <TomMD> ...
16:05:35 <TomMD> @hpaste
16:05:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:06:03 <ddarius> dcoutts_: Read Probability Theory: The Logic of Science http://www-biba.inrialpes.fr/Jaynes/prob.html  The calculations aren't hard.
16:06:07 <lambdabot> Title: Probability Theory: The Logic Of Science
16:06:24 <Pseudonym> There's one situation where dynamic typing is still useful, and that's plugins.
16:06:28 <dcoutts_> ddarius: it's knowing what calculations to do that's the tricky bit :-)
16:06:33 <Pseudonym> You can kinda finesse the problem a bit.
16:06:38 <ddarius> dcoutts_: Read that book.
16:06:45 <Pseudonym> But it's not always the best answer.
16:06:54 <dcoutts_> ddarius: if you know anything about this and have any time and want to help it'd be great
16:06:59 <Pseudonym> Data.Dynamic is still important, in other words.
16:07:07 <dcoutts_> ddarius: it'll take me a while, I have very limited time.
16:07:11 <dons> yep. true runtime extension
16:07:12 <cpst> dynamic typing is great for solving the expression problem ;-)
16:07:20 <dons> if you really really don't know the type till runtime
16:07:22 <bos> the jaynes book is wonderful, but it's huge and assumes a fair amount of background in calculus.
16:07:34 <Pseudonym> Sorry, what's the expression problem?
16:07:37 <ddarius> bos: You can gloss over the calculus and be fine.
16:07:56 <dons> however, even in xmonad, we solve the expression problem without Dynamics :)
16:07:57 <dons> class Typeable a => Message a
16:07:57 <dons> -- |
16:07:57 <dons> -- A wrapped value of some type in the Message class.
16:07:57 <dons> --
16:08:00 <dons> data SomeMessage = forall a. Message a => SomeMessage a
16:08:02 <hpaste>  TomMD pasted "Types of existentials" at http://hpaste.org/5036
16:08:10 <dons> well, i'm cheating slightly. that's *almost* a dynamic
16:08:26 <dons> Pseudonym: extending data variants versus extending functions
16:08:35 <dons> one is easier in OO langs, one is easier in FP.
16:08:45 <dons> gets called the "expression problem"
16:08:53 <bos> ddarius: the other problem is merely one of time.  i figure it takes a few years of practice to become a modestly competent statistician.
16:08:54 <ddarius> Cale: I suggested reading the above mentioned book to you earlier.  Now that I have finished it and read other work by Jaynes, I even more highly recommend it.
16:08:54 <TomMD> So, in that paste I have the problem of serializing a data type (existential) then deserializing.  How do I specify the type of the second component?
16:09:00 <cpst> the actual problem is doing it in a well-typed way
16:09:01 <Pseudonym> Oh, okay.
16:09:04 <dons> adding new fields to data types on the fly is a bit hard in haskell, for example :)
16:09:08 <dons> but adding new functions is easy
16:09:09 <cpst> because it's not a problem without static typing
16:09:11 <TomMD> Is this a problem for Typeable and Data?
16:09:11 <Pseudonym> Incidentally...
16:09:21 <Pseudonym> There's one feature that I think would help with this.
16:09:27 <Pseudonym> That I've kinda wanted for a while.
16:09:30 <Pseudonym> You can _almost_ do it.
16:09:32 <Pseudonym> But not quite.
16:09:42 <dons> TomMD: serialising existentials has a few solutions. dyanmics. hmm, sjanssen, how do we do it in xmonad?
16:09:44 <cpst> the easiest general FP solution is probably polymorphic variants
16:09:45 <Pseudonym> And that's being able to manufacture typeclass instances at run-time.
16:10:00 <ddarius> bos: That's because they do it bassackwards.  I'm pretty sure what dcoutts wants could be done without having a degree in statistics.
16:10:01 <Pseudonym> A typeclass instance is, after all, just a record.
16:10:10 <bos> ddarius: i suspect you're right.
16:10:27 <LoganCapaldo> @hoogle (Typeable a) => TypeRep -> a
16:10:28 <lambdabot> No matches, try a more general search
16:10:35 <LoganCapaldo> i feel like that doesn't work
16:10:39 <LoganCapaldo> mmm
16:10:39 <Pseudonym> As I said, you can _almost_ do it, but it does require some unsafeCast#.
16:10:40 <dons> bassackwards, eh?
16:10:47 <Pseudonym> Which isn't pretty.
16:10:47 <LoganCapaldo> @type typeeOf
16:10:48 <lambdabot> Not in scope: `typeeOf'
16:10:53 <LoganCapaldo> @type typeOf
16:10:54 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:11:03 <cpst> Pseudonym: isn't that just first-class modules, more or less?
16:11:19 <glen_quagmire> type isn't first class in Haskell
16:11:27 <Pseudonym> It might be.
16:11:30 <Pseudonym> I'm not sure.
16:11:45 <Pseudonym> Not having really used first-class modules in anger, I can't say.
16:12:35 <glen_quagmire> isn't type Blah -> Blah -> Blah ? what's the type of that?
16:13:01 <TomMD> @ask sjanssen dons mentions you might know a good solution for serializing / deserializing existentials - could I get you to fill me in or point me to some simple code (perhaps within xmonad)?  Thanks
16:13:01 <lambdabot> Consider it noted.
16:13:07 <sjanssen> types don't have types
16:13:07 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
16:13:12 <TomMD> lol
16:14:15 <sjanssen> TomMD: what you've got to do is explicitly enumerate the types you want to serialize
16:14:24 <dons> ah that's it.
16:14:30 <dons> maintain a lookup table for the methods
16:14:37 <dons> and inspect that when de-serialising
16:14:52 <dons> since you need a way to reflect the data back into a type to dispatch on
16:14:58 <sjanssen> TomMD: in xmonad, we used to have "serialLayouts :: [Layout]", where Layout is an existential wrapper
16:15:24 <sjanssen> you can get the Read instances from each wrapped value and try each parse in turn
16:15:42 <glen_quagmire> if haskell were like lisp, type specification will be like (def f '(a:Int b:Int c:Int) (+ (+ a  b) c))  then type is just a list (Int Int Int)
16:15:57 <sjanssen> (note that we've moved away from existentials because of various pitfalls in the method)
16:16:22 <sjanssen> glen_quagmire: do you know about Typeable?
16:16:28 <TomMD> sjanssen: Thats what I just did, but I really want a heterogenious mapping (Key -> SomeClass0.
16:16:31 <LoganCapaldo> @where liskell
16:16:31 <lambdabot> http://clemens.endorphin.org/liskell
16:16:41 <glen_quagmire> sjanssen: no. me googles
16:17:00 <sjanssen> glen_quagmire: basically, gives you representations of monomorphic types
16:17:02 <dons> sjanssen: we do it all in the type level now?
16:17:24 <sjanssen> dons: yeah, the config is parametric in layout type
16:17:28 <dons> yep
16:17:31 <byorgey> glen_quagmire: in another sense, you could say that kinds are the types of types.  but kinds aren't first-class in Haskell.
16:17:47 <dons> so in the end the possible types are fully spec'd in the type
16:17:51 <Valodim> wow, great
16:17:53 <sjanssen> TomMD: Some*Class* or SomeType
16:17:55 <Valodim> haskell with more parantheses
16:17:57 <dons> we should write that up, some time :)
16:18:03 <dons> sjanssen: xmonad jfp paper.
16:18:07 <TomMD> sjanssen: I am slightly confused.  Are you saying have a mapping of some key to a method that will deserialize to the proper type (thus a heterogenious mapping)?
16:19:26 <sjanssen> TomMD: Read provides backtracking parsing, so we'd take the first witness from the list and attempt to use its Read instance, and fallback to the next witness if it fails, and so on
16:20:39 <sjanssen> TomMD: data Witness = forall a. Read a => Witness a -- this witness packs the Read instance inside so you can use it later
16:21:24 <LoganCapaldo> you could also have something like Map TypeCode (String -> GEither a0 .. an) where data GEither a0 .. an = A a0 | .. An an | Fail
16:21:58 <Saizan> sjanssen: the witnesses are created by the new instance of xmonad basing then on the new hardcoded list of layouts? or?
16:22:19 <LoganCapaldo> (if you wanted to do it more hard codey style)
16:22:31 <sjanssen> Saizan: the witnesses are a top-level value in a "Config" module
16:25:07 <Saizan> sjanssen: and how you decide which types to include?
16:25:40 <dons> the config file specifies all types that are serialised
16:26:34 <sjanssen> Saizan: the user has to add them manually (which is another reason we moved from this system)
16:27:03 <sjanssen> we decided it was better to just punt occasionally on types we don't know how to read than require the user to maintain this list
16:28:24 <Saizan> ah, i was imagining something cleverer :)
16:32:03 * HairyDude grumbles about the nonexistence of Control.Monad.whileM
16:32:37 <LoganCapaldo> i wrote whileM once
16:32:55 <hpaste>  ejelly pasted "filesystem tree" at http://hpaste.org/5037
16:33:20 <explicitjelly> http://hpaste.org/5037
16:33:32 <LoganCapaldo> lol
16:33:35 <explicitjelly> can someone look at that paste and see if there's something I could improve?
16:33:52 <LoganCapaldo> hpaste already told us the link
16:33:52 <explicitjelly> maybe there's a simpler possibility.
16:33:58 <dons> explicitjelly: the filepath library has some nice combinators for gluing filepaths
16:34:04 <LoganCapaldo> before you got here!
16:34:05 <explicitjelly> LoganCapaldo, oh, did I check "announce"? 8)
16:34:08 <faxathisia> I think, use leh
16:34:10 <dons> explicitjelly: but that looks roughly like what I usually do
16:34:12 <faxathisia> let*
16:34:15 <LoganCapaldo> he's psyhic
16:34:18 <dons> (filterM , in particular)
16:34:37 <explicitjelly> faxathisia, where exactly?
16:34:46 <faxathisia> let instead of <- return $
16:34:51 <explicitjelly> faxathisia, I tried that...
16:35:18 <faxathisia> return (files ++ (join otherfiles))
16:35:24 <faxathisia> return $ files ++ join otherfiles
16:35:31 <explicitjelly> faxathisia, it won't "overwrite" the previous value of "files" (yes, I know what I just said is so completely unfunctional and in the sense of haskell monads so untrue that it hurts, but you know what I mean)
16:35:52 <byorgey> explicitjelly: using the same name 'files' for two different things makes me nervous
16:35:57 <explicitjelly> maybe I should put more words into quotes: it won't "overwrite" "previous values" of the "files" "variable"
16:35:58 <dcoutts_> explicitjelly: and it's more fun to do recursive dir listings like that lazily :-)
16:36:00 <explicitjelly> 8)
16:36:35 <LoganCapaldo> let files' = ...
16:36:36 <Saizan> explicitjelly: just use a different name!
16:36:44 <explicitjelly> faxathisia, yes, thought about using $ in the last return (I used it for the other return line), but I was quite happy with how that line looks
16:37:02 <faxathisia> return (files ++ join otherfiles)   -- then?
16:37:18 <explicitjelly> byorgey, Saizan, LoganCapaldo, different name. you're right. it's better.
16:38:01 <explicitjelly> faxathisia, aah. non-operators have higher precedence than operators?
16:38:13 <faxathisia> Yes
16:38:14 <explicitjelly> faxathisia, that's good. i like that.
16:39:49 <faxathisia> also you may know this but for any function f,  ((((f x) y) z) = f x y z
16:39:51 <byorgey> explicitjelly: function application binds tighter than anything else.
16:40:22 <faxathisia> (((f x) y) z) = f x y z *
16:40:28 <dcoutts_> @hpaste
16:40:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:40:36 <kilimanjaro> function application is sort of like the force in star wars
16:40:40 <hpaste>  dcoutts pasted "lazyDirTree" at http://hpaste.org/5038
16:40:47 <dcoutts_> explicitjelly: ^^
16:40:56 <byorgey> kilimanjaro: that's a good way to put it. =)
16:41:25 <byorgey> "Luke! use a higher-order function!"
16:41:40 <explicitjelly> byorgey, than anything else... thanks
16:41:59 <dons> cute, dcoutts_
16:42:40 <dcoutts_> dons: it works nicely if you are trying to compute something over a large dir tree since it doesn't keep everything in memory at once
16:43:08 <dcoutts_> dons: I was using it to see how many bits were necessary to represent a path of a large file system
16:43:42 <dcoutts_> dons: the gtk+ TreeView widget only gives you 96 bits for a TreeIter
16:43:49 <hpaste>  ejelly annotated "filesystem tree" with "(no title)" at http://hpaste.org/5037#a1
16:44:05 <explicitjelly> ok, that incorporates the suggested changes
16:44:15 <dons> dcoutts_: i could use that in hmp3 (has to do a big traversal to populate a mp3 list)
16:44:29 <explicitjelly> oh. and it's wrong, because I continued using files instead of files'
16:44:42 <dcoutts_> dons: aye, if lazy IO is good file files it can be good for dir listing too :-)
16:44:51 <dcoutts_> file/for
16:45:08 <dcoutts_> dons: though make sure you update it to use FilePath
16:45:15 <hpaste>  ejelly annotated "filesystem tree" with "corrected filesystem tree" at http://hpaste.org/5037#a2
16:45:27 <explicitjelly> any more comments?
16:45:42 <dcoutts_> dons: and for what I was using I didn't need the actual paths, you'd need Forrest FilePath
16:45:52 <explicitjelly> map (\x -> path ++ "/" ++ x)... would you use a pointfree expression instead?
16:46:10 <dcoutts_> map (path </>)
16:46:18 <dcoutts_> much nicer :-)
16:46:29 <dcoutts_> and works on windows
16:46:35 <explicitjelly> dcoutts_, what's that? is that one of the path combinators you mentioned?
16:47:04 <LoganCapaldo> "/" works on windows
16:47:06 <dcoutts_> explicitjelly: yes dons suggested you use System.FilePath for manipulating file names/paths
16:47:19 <dcoutts_> LoganCapaldo: sure but it confuses users and some progs
16:47:19 <LoganCapaldo> the real question is, does </> work on VMS?
16:47:22 <explicitjelly> dcoutts_, they seem cool %-)
16:47:29 <dcoutts_> LoganCapaldo: heh heh
16:48:44 <explicitjelly> VMS file systems amaze me %)
16:48:57 <explicitjelly> they have that mainframish smell.
16:49:23 <explicitjelly> ok, I won't annotate that code again. I think it's enough ;)
16:49:43 <explicitjelly> I was rather wondering wether there were any heavy conceptual flaws
16:49:46 <explicitjelly> but it seems okay?
16:51:13 <explicitjelly> using haskell, I often have the expression that the code you could write could be way shorter and more expressive than what I'm actually fabricating 8)
16:51:23 <explicitjelly> ugh. impression, not expression.
16:53:33 <thoughtpolice> explicitjelly: i don't think you are alone on that note.
16:53:57 <glen_quagmire> haskell program can be difficult to read like any other program
16:54:08 <Saizan> explicitjelly: well with files and directory haskell has almost the same interface as other languages, so there's not a big gain :)
16:56:15 <explicitjelly> Saizan, yup...
17:02:21 <dancor> can i print a stack trace from a function that is IO ()
17:02:27 <dancor> does ghc have cool things
17:02:30 <dancor> or should i use hat
17:03:13 <shachaf> dancor: GHCi 6.8 can probably do it.
17:03:48 <explicitjelly> by the way...
17:04:09 <explicitjelly> when haskell errors out with something like "inexhaustive patterns" (or whatever it's called, forgive my sloppy english)
17:04:46 <explicitjelly> can you catch that somehow? would seem a bit strange to me if you really could
17:04:48 <shachaf> explicitjelly: Yes.
17:04:54 <shachaf> -fbreak-on-exception
17:05:54 <explicitjelly> that throws you into the debugger when it happens?
17:06:12 <shachaf> explicitjelly: Yes.
17:06:28 <explicitjelly> nice.
17:06:35 <vincenz> how do I install 6.8.2
17:06:42 <explicitjelly> but that's not what I meant, I was thinking along the lines of surrounding haskell code
17:06:59 <explicitjelly> like you would catch an exception in imperative languages (or with an Error monad)
17:07:32 <explicitjelly> and I think I don't understand how that would fit into the type system.
17:07:34 <shachaf> explicitjelly: Oh, you can do that too.
17:07:40 <shachaf> explicitjelly: It's in IO. :-)
17:07:57 <explicitjelly> yes, within IO or Error I understand that 8) just a property of the Monad
17:08:16 <explicitjelly> oh, wait, can you actually catch the exceptions of non-IO-functions within IO?
17:08:21 <shachaf> @ty IO.catch
17:08:22 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:09:37 <explicitjelly> okay, but that "non-exhaustive pattern" error is not an IO error?
17:09:58 <shachaf> What's an IO error?
17:10:08 <shachaf> (You shouldn't actually use this, probably.)
17:10:11 <shachaf> (But you can.)
17:10:53 <explicitjelly> hmm. don't know if I understand you. suppose I have this:
17:11:02 <explicitjelly> foo [] = "fun"
17:11:04 <explicitjelly> and that's it.
17:11:06 <vincenz> Has anyone installed 6.8.2 on ubuntu?
17:11:09 <explicitjelly> no foo _ or similar.
17:11:14 <explicitjelly> that's non-exhaustive.
17:11:31 <shachaf> vincenz: Yes.
17:11:36 <explicitjelly> and if you try to call it with something else than an empty list, haskell will complain at runtime.
17:11:39 <explicitjelly> can you catch that?
17:11:44 <explicitjelly> that's what I was getting at
17:11:48 <shachaf> vincenz: You can convert the libreadline4 RPM with Alien, some people suggest.
17:12:34 <shachaf> Someone correct me if you can't do this in IO.
17:12:37 * shachaf hasn't.
17:12:55 <kmcallister> > IO.catch (let foo [] = 0 in return $ foo [0]) print
17:12:56 <lambdabot>   Not in scope: `IO.catch'
17:13:17 <explicitjelly> the datatype of foo is something like [a] -> String
17:13:22 <explicitjelly> there's no IO there
17:14:06 <kmcallister> strangely when i do simply "let foo [] = () in return $ foo [0]" in ghci, i get no exception
17:14:06 <explicitjelly> and that's exactly my question. if you *can* catch it somehow, why? it seems to me that it wouldn't fit into the type system
17:14:37 <dancor> program deriving IO
17:14:41 <vincenz> shachaf: I can't just install it?
17:14:51 <shachaf> vincenz: Oh, you mean from a .deb?
17:14:57 <explicitjelly> kmcallister, well, the return value can ONLY be ()...
17:14:57 <vincenz> shachaf: dunno?
17:15:01 <vincenz> shachaf: whatever's easiest
17:15:06 <explicitjelly> kmcallister, haskell seems to know that.
17:15:12 <Saizan> explicitjelly: yes, you can from IO, you've to be sore to evaluate that value
17:15:19 <kmcallister> ah
17:15:21 <shachaf> vincenz: I don't know of any ready-made Ubuntu packages for 6.8.2.
17:15:22 <kmcallister> IO.catch only catches IO errors
17:15:30 <kmcallister> Control.Exception.catch can catch other things
17:15:33 <vincenz> shachaf: what about using the tar.bz2 binary ?
17:15:33 <Saizan> explicitjelly: see Control.Exception.evaluate and Control.Exception.catch
17:15:34 <dancor> i figured out what changed in ghc 6.8, license-file: none is taken literally now
17:15:37 <kmcallister> Prelude IO Control.Exception> Control.Exception.catch (error "foo") (\_ -> return ())
17:15:37 <kmcallister> Prelude IO Control.Exception>
17:15:39 <shachaf> vincenz: But if you apt-get install alien, then you should be able to use those two.
17:15:49 <shachaf> (I think that's what most people do right now.)
17:15:50 <kmcallister> ?t Control.Exception.evaluate
17:15:50 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:15:54 <kmcallister> :t Control.Exception.evaluate
17:15:55 <lambdabot> forall a. a -> IO a
17:16:04 <kmcallister> :t Control.Exception.catch
17:16:05 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
17:16:06 <explicitjelly> oh.
17:16:09 <explicitjelly> that's magic.
17:16:23 <kmcallister> only sort of
17:16:30 <kmcallister> the result is an IO action so it's not totally magical
17:17:15 <explicitjelly> IO is officially magic %-)
17:17:21 <Saizan> well exceptions are compiler magic in every language i know
17:17:24 <explicitjelly> but thanks, clears up a lot
17:17:39 <explicitjelly> Saizan, not with Error monads in Haskell, they aren't?
17:18:28 <vincenz> shachaf: I'll just try the .tar.bz
17:18:37 <LoganCapaldo> I guess it depends on your defn of "compiler magic", but some smalltalks exceptions are arguably not compiler magic.
17:19:19 <Saizan> explicitjelly: well that depends on the specific monad, IO is an instance of MonadError
17:19:55 <explicitjelly> but I think it's really okay if non-functional appearing happens as long as the IO monad comes into play. with the IO monad, you always have that connotation of a constantly modified outside-world-representing state.
17:19:55 <shachaf> vincenz: Yes, but it won't work as-is.
17:19:59 <kmcallister> Saizan, yeah, but that's just an interface issue
17:20:04 <vincenz> shachaf: why not?
17:20:11 <kmcallister> there's also a "pure" Error monad, i.e. one which can be implemented in haskell
17:20:13 <vincenz> shachaf: there's a libreadline.5.so version
17:20:29 <explicitjelly> kmcallister, right. and then it's not magic, it's just mathematics.
17:20:32 <shachaf> Oh, good news! :-)
17:20:32 <kmcallister> hehe
17:20:35 <kmcallister> but math is magic :)
17:20:58 <shachaf> vincenz: Ignore me.
17:21:01 <ricky_clarkson> then magic is good.
17:21:05 <Valodim> magic = math
17:21:05 <Valodim> it's so obvious =)
17:21:38 <Saizan> kmcallister: sure, it's just that there's not a monad named Error :) but i guess you're referring to Either or ErrorT
17:21:39 <LoganCapaldo> any sufficiently advanced magic is indistiguishable from mathematics :
17:21:55 <vincenz> shachaf: with /ignore ? (:
17:22:40 <explicitjelly> any sufficiently accurately proven and formalized gibberish is indistinguishable from mathematics
17:22:52 <kmcallister> Saizan, good point
17:23:15 <HairyDude> No instance for (MonadState (a, b, c) m)
17:23:17 <TomMD> Any proof I consider sufficient _is_ mathematics.
17:23:35 <HairyDude> grr, it should be obvious I want a specific a, b, c and m
17:24:54 <explicitjelly> what's the name of that third haskell compiler or interpreter? nhc?
17:25:14 <Saizan> nhc exists
17:25:18 <kmcallister> explicitjelly, the ones i know of are ghc, hugs, nhc/yhc, and jhc
17:25:24 <explicitjelly> and what's the difference between hugs and ghci anyway?
17:25:41 <LoganCapaldo> about 2 letters
17:26:29 <explicitjelly> LoganCapaldo, don't go sigma-algebrain' me, dude
17:26:38 <TomMD> explicitjelly: ghci supports a lot more languages extensions, but some say it gives confusing error messages.
17:26:54 <Saizan> i find hugs errors worse
17:27:06 <explicitjelly> TomMD, that's funny, because I seem to understand ghci's error messages better than the hugs ones.
17:27:12 <LoganCapaldo> i find hugs not-a-compiler
17:27:15 <TomMD> explicitjelly: I've not had issues with GHC/GHCi error messages except when a 'do' is omitted.
17:27:21 <Valodim> yeah but that's because you're used to it
17:27:38 <TomMD> explicitjelly: Thats my view too.
17:27:42 <kmcallister> LoganCapaldo, true, i meant haskell implementations in general
17:27:46 <explicitjelly> Valodim, no, actually, I was using hugs because I thought it had better error messages. until I discovered that I actually knew what the ghci error messages meant!
17:28:02 <Valodim> haha, ok
17:28:13 <explicitjelly> but that might be just me %)
17:28:19 <explicitjelly> or the particular error messages I've come across
17:28:48 <HairyDude> hugs is also an interpreter, not a compiler
17:29:02 <explicitjelly> and ghci's a compiler?!
17:29:10 <explicitjelly> an on-the-fly-compiler or what?
17:29:12 <TomMD> lol
17:29:13 <TomMD> no
17:29:13 <HairyDude> oh, missed that.
17:30:54 <LoganCapaldo> ghci is a compiler being run in interpreter mode :)
17:31:03 <LoganCapaldo> ghci == ghc --interactive
17:31:42 <Philippa> explicitjelly: good interpreters for functional languages tend to have a compilation phase internally and run from something simpler
17:32:01 <LoganCapaldo> but theres no hugs --batch afaik
17:32:46 <kmcallister> [1 of 1] Compiling Main             ( downloads/bar.hs, interpreted )
17:32:54 <kmcallister> i assume this means GHCi is interpreted, on some level
17:32:58 <kmcallister> bytecode interpreted?
17:33:07 <kmcallister> it certainly can link to full-on ghc-compiled code though
17:34:11 <explicitjelly> seems like nhc's the way to go for debugging and heap profiling purposes...
17:34:20 <explicitjelly> and for small binaries with small heap consumption
17:35:09 * LoganCapaldo wants a haskell w/ region inference based emmory  management
17:35:31 <explicitjelly> emmory management sucks, it'll never catch on.
17:35:41 <HairyDude> untilM (\b -> isEmpty >>= \b' -> return (not b || b')) True $ do
17:35:43 <HairyDude> ewww
17:36:25 <LoganCapaldo> @type liftM (ap (||) not)
17:36:26 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool
17:36:47 <LoganCapaldo> ojhh wait
17:36:51 <LoganCapaldo> b || b'
17:36:56 <LoganCapaldo> ah well
17:37:04 <LoganCapaldo> it was a nice thought while it lasted
17:37:16 <LoganCapaldo> lol
17:37:37 <LoganCapaldo> b || not b is a tautology
17:37:57 <LoganCapaldo> I might as well have done const (return True)
17:38:07 <explicitjelly> :t const
17:38:08 <lambdabot> forall a b. a -> b -> a
17:39:19 <TomMD> @seen dcoutts_
17:39:19 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 51m 50s ago.
17:39:24 <HairyDude> that's still ugly
17:39:25 <dcoutts_> hia TomMD
17:39:42 <HairyDude> better:
17:39:44 <HairyDude>  b |<| mb = mb >>= \b' -> b || b
17:39:46 <explicitjelly> what is #haskell-overflow?
17:39:47 <LoganCapaldo> more importantly it's wrong
17:39:53 <sarehu> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiuypppppppppppzi
17:39:57 <sarehu> er
17:39:59 <TomMD> Hi dcoutts_: I was looking at the warning system for ParseUtils
17:40:02 <HairyDude> cat on keyboard error?
17:40:07 <dcoutts_> TomMD: ah yes
17:40:15 <sarehu> yeah
17:40:31 <TomMD> dcoutts_: It looks like 1) ReadP doesn't collect warnings.  2) runP does 3) runP doesn't have any actual warning code.
17:40:48 <HairyDude> there's a #haskell-overflow now?
17:41:20 <dcoutts_> TomMD: yes, ReadP is pretty poor when it comes to errors
17:41:32 <LoganCapaldo> @pl \b -> isEmpty >>= \b' -> return (not b || b')
17:41:32 <lambdabot> (`fmap` isEmpty) . (||) . not
17:41:41 <dcoutts_> TomMD: and yes I think we don't use the warning feature much or possibly at all
17:41:43 <TomMD> So I was thinking of inserting a case (or a lookup to a map) for each field of interest (just 'version' for now) but that is kind of bloated and could lead to all sorts of other needs (Show a => ReadP a a for example)
17:42:06 <HairyDude> hrm, I'm getting "The last statement in a 'do' construct must be an expression" but I'm pretty sure it is
17:42:21 <kmcallister> HairyDude, that's often caused by indentation errors
17:42:37 <HairyDude> yes, but afaict the indentation is all correct...
17:42:41 <TomMD> dcoutts_: So, I could go down that path with an unknown about of code disrupted as a result, or do you have a better way?
17:42:53 * dcoutts_ looks at the code again
17:44:01 <HairyDude> I have something like
17:44:03 <LoganCapaldo> > do x <- Just 3
17:44:03 <lambdabot>  Parse error at end of input
17:44:18 <HairyDude> x <- if b then foo else
17:44:33 <HairyDude>     untilM (...) True $ do
17:44:39 <HairyDude>         bar
17:44:42 <HairyDude> is that illegal?
17:44:55 <dcoutts_> TomMD: so currently we're using simpleField and that uses ReadP
17:45:07 <HairyDude> s/do/\y -> do/ of course
17:45:16 <HairyDude> oh, no it's ont
17:45:21 <HairyDude> s/ont/not/
17:45:51 <dcoutts_> TomMD: however a FieldDescr uses a ParseResult, and field and thus simpleField use runP to convert a ReadP parser to a ParseResult style one
17:45:56 <HairyDude> ah, I had a misplaced closing paren... :/
17:46:24 <LoganCapaldo> there should be a --show-layout switch or something, he complained
17:46:25 <dcoutts_> TomMD: so perhaps we should have alternatives to simpleField that can also do something in ParseResult
17:47:03 <HairyDude> oh and it should have been
17:47:03 <HairyDude> b |<| mb = mb >>= \b' -> return (b || b)
17:47:17 <HairyDude> b |<| mb = mb >>= \b' -> return (b || b')
17:47:18 <HairyDude> even
17:48:05 <HairyDude> or to short-circuit:
17:48:05 <HairyDude> b |<| mb = if b then return b else mb
17:48:16 <TomMD> dcoutts_: So a simpleField' that also takes a function :: a -> PWarning would be a desirable solution?
17:49:21 <LoganCapaldo> @type ap (liftM (||)) return
17:49:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = m (a -> Bool)
17:49:22 <lambdabot>       Expected type: (a -> Bool) -> a
17:49:22 <lambdabot>       Inferred type: (a -> Bool) -> m (a -> Bool)
17:49:28 <dcoutts_> TomMD: or simpler and more general, a vairant that instead of the (ReadP a a) parameter takes a (LineNo -> String -> a -> ParseResult a) directly
17:49:36 <LoganCapaldo> @type ap (liftM2 (||)) return
17:49:36 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m Bool'
17:49:36 <lambdabot>       Expected type: m Bool -> m Bool
17:49:36 <lambdabot>       Inferred type: m Bool -> m (m Bool)
17:49:42 <LoganCapaldo> doh
17:49:57 <LoganCapaldo> @type (liftM2 (||)) . return
17:49:59 <dcoutts_> TomMD: it's the field function that's converting ReadP to the type of fieldSet in FieldDescr
17:50:13 <lambdabot> thread killed
17:50:25 <HairyDude> is my definition not clear enough for you? :P
17:50:27 * LoganCapaldo is abusing lb apparentl
17:50:34 <explicitjelly> can I ask lambdabot in which module a function is?
17:50:44 <LoganCapaldo> @index findIndex
17:50:44 <lambdabot> Data.List, Data.Map
17:50:51 <explicitjelly> @index split
17:50:51 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
17:50:58 <explicitjelly> thanks
17:50:58 <HairyDude> @index map
17:50:59 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
17:51:03 <HairyDude> interesting
17:51:18 <explicitjelly> obviously, split is not what I'm looking for.
17:51:24 <HairyDude> thought 'map' would be a pretty common name.
17:51:42 <explicitjelly> ok, how about asking it for a function based on its type, like hoogle?
17:52:06 <LoganCapaldo> @hoogle a -> [a] -> Maybe Int
17:52:06 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
17:52:26 <explicitjelly> @hoogle [a] -> a -> [[a]]
17:52:26 <lambdabot> No matches, try a more general search
17:52:32 <explicitjelly> @hoogle a -> [a] -> [[a]]
17:52:33 <lambdabot> No matches, try a more general search
17:52:50 <explicitjelly> huh.
17:52:57 <LoganCapaldo> @hoogle (a -> Bool) -> [a] -> ([a], [a])
17:52:58 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
17:52:58 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
17:52:58 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
17:53:37 <dcoutts_> TomMD: -> #haskell-overflow
17:54:04 <HairyDude> anyone know a convenient way to imitate imperative 'break' in an untilM ?
17:54:17 <sarehu> ContT?
17:54:36 <sarehu> :t untilM
17:54:38 <lambdabot> Not in scope: `untilM'
17:54:47 <sarehu> @index untilM
17:54:47 <lambdabot> bzzt
17:54:49 <HairyDude> urk, that would involve grokking continuations :) but I should try sometime
17:54:53 <sarehu> What is untilM?
17:55:04 <LoganCapaldo> if the M in your untilM is maybe or either you could use fail like break
17:55:05 <HairyDude> the monadic version of 'until'
17:55:13 <sarehu> :t until
17:55:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:55:18 <Saizan> HairyDude: ErrorT would also work
17:55:24 <ddarius> HairyDude: It doesn't require much in this case.  Also, ErrorT is a more specific possibility
17:55:35 <HairyDude> so untilM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a
17:55:41 <explicitjelly> how can I remove a symbol which I created with let in the interactive environment?
17:55:45 <explicitjelly> let a = "foo"
17:55:48 <explicitjelly> how can I remove aÃŸ
17:55:49 <explicitjelly> ?
17:55:53 <dcoutts_> TomMD: still there?
17:55:56 <ddarius> (Except for that ridiculous "Error" constraint.)
17:56:04 <vincenz> @hoogle lift
17:56:05 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
17:56:05 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
17:56:05 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
17:56:06 <HairyDude> explicitjelly: why do you need to?
17:56:08 <ddarius> explicitjelly: You can't.
17:56:24 <explicitjelly> I don't know. because I like my interactive environment nice and tidy? 8)
17:56:30 <LoganCapaldo> explicitjelly: :q, return, ghci
17:56:34 <LoganCapaldo> :p
17:56:40 <kmcallister> doesn't :r wipe bindings?
17:56:41 <explicitjelly> heheh, ok
17:57:07 * HairyDude makes a note to have a look at ErrorT, but goes to cook dinner first.
17:57:39 <explicitjelly> @hoogle a -> [a] -> [a]
17:57:40 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
17:57:40 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
17:57:40 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
17:57:41 <dcoutts_> @hpaste
17:57:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:58:17 <LoganCapaldo> @type (:)
17:58:18 <hpaste>  dcoutts pasted "simpleField' for TomMD" at http://hpaste.org/5039
17:58:20 <lambdabot> forall a. a -> [a] -> [a]
17:59:14 <dcoutts_> TomMD: so the point is, that simpleField' doesn't go via ReadP so we can do the parsing (still using ReadP) but then we can do our extra check and return in the ParseResult monad.
17:59:50 <explicitjelly> filter (/= "") $ lines source
17:59:52 <explicitjelly> suggestions?
18:00:05 <explicitjelly> something like: remove "" $ lines source
18:00:07 <explicitjelly> would be cool.
18:00:20 <LoganCapaldo> @type delete
18:00:31 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
18:01:08 <LoganCapaldo> > delete "" ["a", "", "b", ""]
18:01:09 <explicitjelly> LoganCapaldo, huh, look above, I tried "@hoogle a -> [a] -> [a]" but it didn't return delete
18:01:10 <lambdabot>  ["a","b",""]
18:01:15 <dcoutts_> TomMD: I've gotta go, let me know how you get on
18:01:21 <LoganCapaldo> doesn't do what you want anyway :)
18:02:10 <LoganCapaldo> > ["a", "", "b", ""] // [""]
18:02:10 <lambdabot>  Couldn't match expected type `Array i e'
18:02:22 <LoganCapaldo> > ["a", "", "b", ""] \\ [""]
18:02:23 <lambdabot>  ["a","b",""]
18:02:52 <explicitjelly> I think I can live with filter.
18:03:09 * LoganCapaldo suggest filter (not . null)
18:03:21 <LoganCapaldo> @src null
18:03:21 <Phoozer> LoganCapaldo: Error: "src" is not a valid command.
18:03:21 <lambdabot> null []     = True
18:03:21 <lambdabot> null (_:_)  = False
18:03:36 <LoganCapaldo> Phoozer: who are you?
18:03:36 <Phoozer> LoganCapaldo: Error: "who" is not a valid command.
18:03:50 <vincenz> How do I use language annotations in the {-# stuff?
18:03:52 <explicitjelly> LoganCapaldo, that's good, thanks.
18:04:23 <LoganCapaldo> /= "" is gonna make you run down every string
18:04:47 <LoganCapaldo> although I guess in practice it doesn't realy make a difference
18:09:45 <Cale> LoganCapaldo: hm?
18:10:07 <LoganCapaldo> nothing I was just knee jerking
18:10:30 <Cale> LoganCapaldo: the comparison is done lazily, so it'll just check if the top level constructor is [] or (:), but it does involve an Eq instance.
18:10:34 <LoganCapaldo> (/= "") <- string so you already have Eq anyways
18:10:51 <LoganCapaldo> so it doesn't really matter
18:11:42 <LoganCapaldo> My rote prefer null to == [] training was just kicking in :p
18:12:03 <LoganCapaldo> stupid habits
18:12:07 <LoganCapaldo> :)
18:12:51 <sarehu> interesting, I get the warning about pattern matches overlapping on   foo "" = ... ; foo cs@(c:cs') = ...
18:13:00 <sarehu> But s/""/[]/ and they go away.
18:13:24 <faxathisia> weird...
18:14:18 <vincenz> hot off the press: http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
18:14:19 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
18:14:19 <dmwit> sarehu: You should file a bug.
18:14:38 <dmwit> (Or check if it's already been filed.)
18:14:41 <sarehu> Gah, every time I mention these things, it turns into work :)
18:14:52 <dmwit> heh
18:15:13 <vincenz> feedback, as always, welcome
18:18:06 <explicitjelly> which referende do you use for haskell syntax?
18:18:11 <explicitjelly> things like import, guards etc.
18:20:18 <Saizan> mmh, maybe the report?
18:20:21 <Saizan> ?where report
18:20:21 <lambdabot> http://www.haskell.org/onlinereport/
18:20:47 <explicitjelly> okay
18:22:19 <Cale> explicitjelly: for a quick overview, you might check out http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
18:22:20 <lambdabot> Title: Tour of the Haskell Syntax
18:25:43 <explicitjelly> Cale, I knew that one, but fehlt that it wasn't complete. but thanks
18:26:30 <Cale> Yeah, for more complete details, the Report is the place to go. Also, various extensions get documented in the GHC User's Guide.
18:28:30 <kmcallister> the tour of syntax seems to be missing do notation
18:28:32 <vincenz> Cale: I refer to you in my latest blog-entry
18:28:36 <kmcallister> wonder if that's intentional
18:30:46 <Cale> vincenz: The article on type inference? Nice :)
18:30:51 <explicitjelly> onPair f (a,b) = (f a, f b)
18:30:55 <explicitjelly> or is there already something similar?
18:31:02 <faxathisia> &&&
18:31:23 <faxathisia> > ((+1) &&& (*2)) (5,6)
18:31:27 <lambdabot>   add an instance declaration for (Num (t, t1))
18:31:32 <vincenz> onPair = join (&&&)
18:31:33 <Saizan> f *** f
18:31:42 <vincenz> onPair = join (***)
18:31:57 <faxathisia> > ((+1) *** (*2)) (5,6)
18:31:59 <lambdabot>  (6,12)
18:32:00 <explicitjelly> hmm. so I should take a look at arrows?
18:32:16 <faxathisia> :t (&&&)
18:32:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:32:26 <explicitjelly> :t (***)
18:32:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:32:36 <Cale> explicitjelly: Well, you don't really need to know arrows in general :)
18:32:47 <explicitjelly> Cale, seems like they're useful
18:32:51 <Cale> explicitjelly: just that (f *** g) (x,y) = (f x, g y)
18:32:55 <gwern> d'oh! d'oh! d'oh!
18:33:19 * gwern just realized why isearchNextE and isearchPrevE refused to act differently.
18:33:27 <vincenz> :t join (***)
18:33:27 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:33:28 <gwern> you see, they are defined the same way >.<
18:33:52 <gwern> the only thing stupider than defining them the same way is dicking around with them for hours and never noticing that
18:34:07 <sarehu> Why does (round (0/0 :: Double) :: Integer) evaluate to -2696539702293473861593957786........4494436336205824?
18:34:09 <dons> gwern: is that from hmp3?
18:34:21 <gwern> dons: no, yi
18:34:28 <dons> oh, thought it looked familiar
18:35:00 <gwern> dons: do I have you to blame for them having the same exact definitions as each other? :)
18:35:18 <dons> probably not. they used to work.
18:35:32 <dons> but that was 2004
18:36:28 <TomMD> Why isn't 'Frag' on hackage?  That would be a great thing to be able to cabal install ;-)
18:36:45 <gwern> didn't frag bitrot?
18:36:58 * faxathisia thinks so
18:37:24 <faxathisia> (crashes on startup)
18:37:27 <dons> TomMD: good idea.
18:37:32 <dons> faxathisia: on 64 bits?
18:37:48 <dons> it should be fine on 32 bits, but there's some known 64 bit issues
18:38:02 <faxathisia> ah.. thats ok then
18:38:03 <dons> some of those got fixed recently
18:38:30 <dons> i'm slowing moving my repos from unsw, and frag's one of them. we can move that too.
18:38:34 <gwern> '#  Frag has portability problems. It is known to work on i386 and AMD64, and known not to work on big-endian systems. '
18:38:46 <dons> ok. cool.
18:39:35 <gwern> dons: by that, does it mean 'I should wait a few minutes/hours for dons to move it so I can pull and play' or 'pull and play, dons is only going to move it in weeks/months/years, so no point in waiting'?
18:40:07 <dons> i'll move it within 2 weeks, likely less.
18:40:15 <dons> i.e. this weekend
18:40:20 <dons> patches would help
18:40:24 <dons> you know where to send them :)
18:40:42 <dons> i think it goes in the 'Games' category :)
18:42:03 <sarehu> Prelude> "2 3 + 2 * * 3" 3 :: Double
18:42:05 <sarehu> 30.0
18:42:36 <sarehu> er, s/ 3"/"
18:42:45 <dons> oh, is that what i think it is?
18:44:35 <Nafai> What is it?
18:45:05 <Cale> Looks like a stack language via isString :)
18:45:36 <dmwit> Except... magical.
18:45:47 <Cale> IsString is the magic bit
18:46:05 <dons> looks what we've unleashed
18:46:09 <dmwit> There are more operators than things on the stack, if I'm reading it correctly.
18:46:35 <sarehu> there's a typo, that's "2 3 + 2 * *"
18:46:36 <Cale> dons: Can we hold you personally responsible for turning Haskell into Perl?
18:46:47 <sarehu> Ok folks
18:46:53 <dons> well, i've been arguing we should try this for a while, but i regret it now
18:46:54 <dons> :D
18:47:12 <sarehu> I want $1000 in my bank account by Friday, or I'll release it and advertise it on Reddit :P
18:47:20 <dons> heh
18:47:27 <dons> oh noes!
18:47:28 <dmwit> haha
18:47:59 <dons> still, you should also provide a Num instance
18:48:03 <gwern> sarehu: we're not afraid! do your worst!
18:48:07 <dons> that packs the operators into bits in the integer
18:48:23 <TomMD> gwern NO!  For all you know slashdot will get a hold of it, then were screwed.
18:48:40 <dons> so some magic number :: Integer stands for the opcodes of the "compiled" stack ops
18:48:43 <gwern> TomMD: we don't negotiate with turrists. ever
18:48:43 <TomMD> s/were/we're  s/a hold/ahold/
18:48:43 <sarehu> dons: maybe a num instance that evaluates with no arguments
18:49:05 <dons> (242114::Eval) 2 3    where 242114 is some encoding of the program
18:49:10 <dons> and you pull out the bit patterns
18:49:22 <dons> overloading it teh awesome
18:49:41 <sarehu> hmmm
18:49:44 <dons> a whole new world of obfuscation
18:49:49 <sarehu> I still need an instance that takes more than one argument
18:49:56 <gwern> dons: ooh oog and you can use Godel encoding if you want!
18:50:12 <dons> oh hmm. that would be cute.
18:50:35 * gwern wonders how you would curry on the instance level
18:50:42 <sarehu> "= [3 *] [2 *] ifte" (5,4,3) :: Double
18:50:51 <sarehu> 10.0
18:50:58 <faxathisia> "Djinn" :: ((a, b) -> c) -> a -> b -> c
18:51:00 <sarehu> "= [3 *] [2 *] ifte" (5,4,4) :: Double
18:51:01 <sarehu> 15.0
18:51:04 <dons> mm
18:51:16 <sarehu> Right now the stack only has functions and Doubles as datatypes
18:52:13 <dons> i'm thinking of this:
18:52:13 <dons> instance IsString (Int -> Int -> Int) where
18:52:13 <dons>     fromString s = unsafePerformIO $
18:52:13 <dons>                         o <- gcc s
18:52:16 <dons>                         f <- link o
18:52:18 <dons>                         return (jump f)
18:52:21 <dons> got a bit of code lying around to do it, too. hmm
18:52:28 <gwern> '-.tga' <-- interesting file name
18:52:53 <hpaste>  sarehu pasted "Early version of RPN IsString instance :-> ~*cackle*~" at http://hpaste.org/5040
18:52:55 <dons> so then inline C would work.
18:53:23 <dons> ok. that looks plausible, sarehu :)
18:54:59 <sarehu> oh!  Truncated!  Blast you hpaste!
18:55:17 <mightybyte> Anyone know how to make ghc create an executable?  It doesn't seem to want to link.  Last time I had this problem --make fixed it, but not this time.
18:55:38 <mightybyte> I'm testing with a simple hello world program too.
18:56:02 <HairyDude> mightybyte: what error message are you getting?
18:56:17 <faxathisia> I just go: ghc --make Foo.hs
18:56:18 <mightybyte> HairyDude: No error.  It just doesn't link.
18:56:18 * gwern is compiling frag. thus far fairly simple issues to fix. looking good
18:56:20 <LoganCapaldo> yeah what he said
18:56:44 <dons> $ cat B.hs
18:56:44 <dons> main = print "hello, world"
18:56:45 <mightybyte> faxathisia: That's exactly what I did...for foo.hs
18:56:47 <gwern> turn on verbose, it has to be saying something about why it doesn't link
18:56:47 <dons> $ ghc -O B.hs -o myprog
18:56:51 <dons> $ ./myprog
18:56:51 <dons> "hello, world"
18:56:59 <LoganCapaldo> did you forget the -o part?
18:57:11 <dons> it'll make ./a.out or Main or whatever the module name is.
18:57:13 * LoganCapaldo doesn't think ghc spits out a.out
18:57:13 <HairyDude> mightybyte: sanity check: your source file has a main action, right
18:57:15 <dons> also, do you have a 'main'
18:57:20 <HairyDude> ?
18:57:22 <LoganCapaldo> but I'm wrong
18:57:26 <mightybyte> LoganCapaldo, Yes, but it it should go to a.out
18:57:28 <LoganCapaldo> hooray for being wrong!
18:57:31 <mightybyte> Yes, I do have a main.
18:57:48 <LoganCapaldo> just past the code
18:57:49 <mightybyte> module Foo where
18:57:51 <LoganCapaldo>        *paste
18:57:54 <gwern> just hpaste the whole program, your command, and the results of the compilation command
18:57:57 <mightybyte> main = do putStrLn "Hello world"
18:58:00 <LoganCapaldo> --is-main Foo
18:58:15 <LoganCapaldo> ghc looks for Main.main
18:58:26 <LoganCapaldo> if you don't do --is-main
18:58:39 <mightybyte> Does the file need to be named Foo.hs (with an upper case 'F')?
18:58:41 * HairyDude finally gets his code to type check, yay!
18:58:47 <dons> yeah, just leave off the module line
18:59:02 <dons> or call it: module Main where
19:00:06 <mightybyte> dons: Ahhhh, leaving off the module line did it.
19:00:10 <gwern> oh wow, frag is nice
19:00:23 * LoganCapaldo wonders how hard it would be to add a warning for that
19:00:23 <mightybyte> So what are the rules for creating a binary?
19:00:23 <gwern> dons: so Frag is all Haskell? that's pretty impressive
19:00:35 <LoganCapaldo> main has to be in the module named Main
19:00:48 <LoganCapaldo> it could be my first "hack on ghc" attempt
19:00:49 <mightybyte> LoganCapaldo: Oh, interesting.
19:01:00 <vincenz> anyone know how to have something similar to <pre> but that is inline?
19:01:12 <LoganCapaldo> <tt> ?
19:01:24 <LoganCapaldo> oh wait
19:01:30 <LoganCapaldo> that's not what you are asking
19:01:31 <sarehu> <tt> and s/\s/&nbsp;/g?
19:01:34 <gwern> <code></code>?
19:01:42 <mightybyte> Earlier today I was able to get it to work without the module being called Main.  But at that time I was on a Gentoo box.  Now I'm on Ubuntu.
19:01:48 <HairyDude> not the right channel to ask imo ;)
19:02:04 <vincenz> gwern: thx?
19:02:04 <LoganCapaldo> .foo { display: inline; } <pre class="foo">...
19:02:25 * LoganCapaldo has no idea what effect that will have
19:02:37 <dons> gwern: yep.
19:02:55 <dons> its cool, but we should be able to do stuff like that if we're serious
19:02:59 <LoganCapaldo> if it works on any browser it would be a minor miracle
19:03:14 <mightybyte> So how do you deal with a situation where you want to build several different binaries from the same project?
19:03:38 <LoganCapaldo> mightybyte: you can override that with the --main-is command line option I was refferring to earlier
19:03:46 <dons> mightybyte: you can add multiple executable lines to a .cabal file
19:03:51 <dons> mightybyte: i.e. use a build system
19:03:53 <mightybyte> Ok
19:03:56 <LoganCapaldo> bah
19:04:02 <LoganCapaldo> build systems are for the weak! :)
19:04:10 * LoganCapaldo is kidding
19:04:11 <mightybyte> I was playing with cabal earlier, but I haven't quite gotten it working yet.
19:04:25 <ray> yeah, real men know their compiler options and aren't afraid to type them out
19:04:32 <ray> all of them
19:04:37 <ray> for every file
19:04:40 <faxathisia> lol
19:04:52 <ray> while, presumably, chewing on very tough beef jerky
19:05:14 <mightybyte> Hmmm, 4.5 megs for the hello world binary.  That seems a little excessive.
19:05:18 <gwern> no, broken glass
19:05:19 <LoganCapaldo> _extremely_ tough beef jerky
19:05:24 <gwern> and biting the tops off of beer bottles
19:05:46 <gwern> mightybyte: it is. the ghc RTS alone accounts for like 500k
19:05:49 <mightybyte> ...even in the days of half-terabyte hard drives. :)
19:05:54 <faxathisia> mightybyte: C is good for writing hello worlo
19:06:05 <mightybyte> faxathisia: But haskell is prettier. :)
19:06:21 <gwern> mightybyte: but add some options like strip and it goes down
19:06:26 <dons> mightybyte: sounds like you don't have split objs enabled
19:06:37 <mightybyte> dons: I guess not
19:06:38 <dons> mightybyte: which depends on the arch. hellowold is about 200k in normal conditions
19:06:52 <mightybyte> dons: Ahh, this is Ubuntu AMD64
19:06:55 <dons> but on some distros, the libraries weren't compiled with split objs.
19:07:01 <dons> and 64 bit is also double the size anyway
19:07:08 <mightybyte> Ok
19:07:14 <dons> most of that is dead code. or the symbols
19:07:30 <dons> just linker gunk.
19:07:57 <HairyDude> cannot mix `(.)' [infixr 9] and `liftM' [infixl 9] in the same infix expression
19:07:58 <mightybyte> strip cuts the size in half
19:08:05 * HairyDude curses haskell for only having 9 precedence levels
19:08:45 * sarehu curses haskell for not trying alternate precedence levels when the first set deosn't typecheck :)
19:09:20 * gwern curses haskell for not reading my fscking mind
19:09:51 * LoganCapaldo hugs haskell
19:12:30 <dancor> precedence should be :: Real
19:12:37 <faxathisia> mah
19:12:41 <dancor> i guess i would settle for rational
19:12:48 * dancor is feeling generous
19:12:56 <sarehu> Yeah, a typeclass would be bizarre
19:13:22 <faxathisia> Why not have the level relative to other ops
19:13:22 <Cale> vincenz: one thing you could do regarding the presentation of that code is simply to change the colour for infix operators :)
19:13:58 <gwern> why not go with Integer? unless you always want to be able to intersperse between two given levels...
19:14:17 <LoganCapaldo> well that's the essential thing
19:14:26 <LoganCapaldo> you need to be able to squeeze in there
19:14:35 <LoganCapaldo> more isn't as important
19:14:53 <LoganCapaldo> this is why basic programmers numbered their lines in 10s or 100s after all :)
19:15:22 <faxathisia> so describe levels relative to other ops instead of as a number?
19:15:41 <Cale> Refer to line 10/6, where we define mercury poisoning.
19:15:48 <LoganCapaldo> hehe topological sort to figure out the precedence of a given operator
19:16:04 <dancor> faxathisia: that would be interesting but you couldn't specify a total order
19:16:29 <dancor> which i guess is fine
19:16:31 <dancor> sort of
19:18:59 <dancor> it does seem very unhaskell to have magic numbers of any kind
19:18:59 <vincenz> Cale: oh?
19:19:11 * clanehin has multiple build errors making frag
19:19:17 <byorgey> there would still be opportunity for ambiguity, just as there is now, but you'd always be able to squeeze in more operators.
19:19:23 <byorgey> and no magic numbers.
19:19:33 <Cale> vincenz: The light cyan on the cream coloured background makes them hard to read :)
19:19:34 <byorgey> but it might be a tad more confusing.
19:19:39 <vincenz> Cale: fair enough :)
19:20:08 <vincenz> Cale: color suggestion?
19:20:19 <Cale> navy, perhaps?
19:20:35 <Cale> #330000
19:20:36 <vincenz> purple?
19:20:37 <byorgey> there would have to be some way to get the compiler to tell you how it figured out the relative precedence of two operators, since it could be hard to do topological sort by hand =)
19:20:45 <Cale> Something dark :)
19:21:04 <Cale> er
19:21:14 <Cale> #000033 -- I'm forgetting the order :)
19:21:26 <byorgey> rgb!
19:21:33 <Cale> Indeed
19:22:07 <byorgey> just remember yoRGeyB =)
19:24:00 <Cale> haha
19:24:25 <Cale> ByoRGey?
19:24:57 <dancor> rugby
19:25:28 <vincenz> Cale: what about the same Green as used for instance but then not underlined
19:25:39 <Cale> Sure, that'd be readable as well
19:26:40 <vincenz> crap, whle recompiling hscolour
19:26:40 <vincenz> /usr/bin/ld: cannot find -lgmp
19:26:55 <Cale> That's odd.
19:27:10 <LoganCapaldo> no arbitrary precision arithmetic for you!
19:27:18 <Cale> also, doesn't it generate the HTML with CSS so you can just edit the colours by hand?
19:27:30 <vincenz> Cale: no
19:27:39 <Cale> Though, it looks like it didn't do that in your case...
19:27:40 <vincenz> how come I can't get -lgmp?
19:27:46 <LoganCapaldo> even if it did I doubt it would be human readable
19:27:48 <vincenz> I have libgmp3c2 on my computer
19:27:59 <vincenz> and I installed haskell from the tar.bz2 with libreadline.so.5 suppor
19:28:16 <Cale> LoganCapaldo: It doesn't have to be. You just edit the accompanying CSS file, which is human-specified.
19:28:33 <vincenz> found it
19:28:36 <LoganCapaldo> it does to a point
19:28:59 <LoganCapaldo> eg if it does things like use class anmes like "kg12"
19:29:39 <LoganCapaldo> and the accompanying css file was what I was referring to as not being human readable
19:30:11 <Cale> heh
19:30:14 <LoganCapaldo> but maybe I'm a pessimist and it generates beautiful, sane css
19:30:23 <Cale> It doesn't have to generate CSS.
19:30:39 <Cale> It just has to come with a CSS file that defines a bunch of classes.
19:30:52 <Cale> and then the code it spits out just has to use those.
19:30:52 <gwern> hm. is it possible to make GHC just eat 100% of cpu time compiling a particular module?
19:31:21 <Cale> gwern: I would hope so.
19:31:31 <gwern> (particularly by forgetting an extension flag?)
19:31:39 <Cale> oh, err...
19:31:39 <gwern> Cale: apparently indefinitely I meant :)
19:31:46 <byorgey> hehe
19:32:39 <Cale> That would be a bug, or else you're using extensions which make the typechecking Turing complete and doing something zany with types :)
19:32:43 <LoganCapaldo> Cale: sure if it's sane
19:33:12 <sarehu> so there's a num instance: > 14091254074378 5 :: Double
19:33:13 <LoganCapaldo> I just think sane syntax hilighters are myth like unicorns or strict haskell programs :)
19:33:14 <vincenz> even odder, I rewrite the app to use Green and it still uses Cyan
19:33:15 <sarehu> 25.0
19:34:01 <Cale> sarehu: GÃ¶del-encoded program as Integer?
19:34:22 <sarehu> I don't know what GÃ¶del-encoding is
19:34:39 <ac> sarehu: a way to encode logical statements as integers, I believe
19:34:47 <gwern> Cale: well, I just chucked out the hand-specification of what extensions it uses for -fglasgow-exts, and now it compiles lickety-splt
19:34:55 <sarehu> Well, some encoding, yes.
19:35:02 <Cale> Where you pick some alphabet and encode strings by picking appropriate exponents on primes.
19:35:02 <pjd> sarehu: http://en.wikipedia.org/wiki/G%C3%B6del_number
19:35:03 <lambdabot> Title: GÃ¶del number - Wikipedia, the free encyclopedia
19:35:10 <gwern> sarehu: it's really neat. every number can be uniquely decomposed to a list of primes
19:35:31 <sarehu> disgusting... no, it's just a base-96 translation
19:35:36 <Cale> gwern: interesting.
19:35:44 <gwern> sarehu: so you make each prime correspond to part of a program uniquely, and then multiply them together
19:35:51 <Cale> gwern: Maybe submit a bug report?
19:36:04 <gwern> sarehu: then the recipient can factor the resulting large number and get back the original list
19:36:14 <gwern> sarehu: well, there may've been some exponentiation going on there too, I forget
19:36:22 <gwern> Cale: yeah. I might if I figure out what extension I need to specify
19:36:30 <gwern> sarehu: see https://secure.wikimedia.org/wikipedia/en/wiki/GÃ¶del_number
19:36:50 <vincenz> Cale: better?
19:37:07 <Cale> yeah, that looks reasonable
19:37:42 * gwern will do a binary search over the list in http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html . That should give me the answer
19:37:43 <lambdabot> http://tinyurl.com/2xjyqs
19:37:43 <lispy> are we going to use ROBOT9000 bot here?
19:39:38 <gwern> lispy: that would be interesting
19:40:09 <Pseudonym> lispy: No, because this would be banned:
19:40:10 <Pseudonym> ?faq
19:40:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:40:46 <gwern> Pseudonym: I think that should be banned...
19:40:52 <chessguy> @quote ban
19:40:52 <lambdabot> monochrom says:  Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
19:41:00 <nelhage> You could presumably exclude lambdabot commands if you wanted
19:41:11 <Pseudonym> And lambdabot responses.
19:41:14 <Pseudonym> Excellent!
19:41:32 <Pseudonym> @msg #haskell That means lambdabot admins can get around the moderation!
19:41:32 <lambdabot> That means lambdabot admins can get around the moderation!
19:41:35 <nelhage> lambdabot would definitely have to be excluded, but that's fine
19:41:49 <nelhage> Hopefully we already trust the lambdabot admins :)
19:41:56 <radetsky> I can't build pcre-light. Anybody familiar with it?
19:42:02 <lambdabot> I sure as hell don't.
19:42:02 <LoganCapaldo> dons is!
19:42:14 <gwern> heh.
19:42:25 <pjd> lispy: bad idea
19:42:38 <pjd> consider new users' confusion
19:43:03 <gwern> pjd: so special case them. not a problem
19:43:04 <Cale> I think there's enough interesting new discussion in #haskell already, without the need for enforcement by robots.
19:43:19 <nelhage> ROBOT9000 seems intended more for social channels
19:44:15 <pjd> gwern: you can remotely gauge someone's Haskell and #haskell familiarity over IRC? :)
19:44:56 <gwern> pjd: simply record presence. if nickname foo hasn't appeared in N days, foo is new
19:45:41 <pjd> nicknames don't necessarily correspond to people
19:45:51 <Pseudonym> I agree with Cale, BTW.
19:45:56 <Pseudonym> We run a pretty tight ship here.
19:46:13 <Pseudonym> You must be at least *this* smart (points to place on IQ bell curve) to even bother turning up in #haskell.
19:46:41 <Pseudonym> @keal
19:46:42 <lambdabot> the [nsa] even make light green both ways once
19:46:48 <Pseudonym> If you need proof.
19:46:57 <lispy> ?keal
19:46:57 <lambdabot> will it return [] if map gives fpu infinite list?
19:47:00 <gwern> ...
19:47:04 <lispy> ah, keal
19:47:16 <Cale> keal was the best completely insane troll ever :)
19:47:21 <chessguy> @keal
19:47:22 <lambdabot> all i know is i have experienced my own death unhappening...
19:47:22 * gwern will see your nonsequitur and raise it an ad honimem. you idiot.
19:47:29 <lispy> well, i wasn't serious when i suggested ROBOT9000, but it is interesting to hear how people feel about it
19:47:33 * araujo wonders if dons is around
19:47:34 <LoganCapaldo> I'm so mad I never got to see keal live.
19:47:48 <dons> radetsky: ?
19:47:56 <chessguy> LoganCapaldo, i have. that kid's nuts
19:47:56 <gwern> past tense?
19:48:02 <dons> do you have libpcre installed ?
19:48:13 <radetsky> I don't know
19:48:24 <radetsky> I'll check
19:48:26 <dons> its a C library, would come in your packages system.
19:48:38 <dons> it also lives at http://www.pcre.org/
19:48:40 <lispy> pcre = perl compatible reg. exp. (or something like that)
19:48:41 <lambdabot> Title: PCRE - Perl Compatible Regular Expressions
19:49:24 <gwern> well, I'll be. it was Rank2Types. I was betting it'd be NoMonomorphismRestriction
19:50:06 <LoganCapaldo> pcre lives!
19:50:20 <lispy> i still have a hard time with rank-n types where n > 1
19:50:45 <lispy> my brain has a monomorphism restriction :)
19:50:53 <LoganCapaldo> I'm not even sure I know what rank-n types are
19:51:17 <gwern> Cale: turns out the offending not-specified-extension was Rank2Types
19:51:44 <Cale> NoMonomorphismRestriction is too easy to cause problems
19:52:34 <faxathisia> What is a rank 2 type?
19:53:00 <Cale> (the monomorphism restriction is totally artificially imposed, in an attempt to maintain the illusion that pattern bound variables are not functions, and hence will always be cached)
19:53:23 <LoganCapaldo> nothing is real, everyhting you see is an illusion
19:53:37 <lispy> nevermind the type checker behind the curtain
19:53:37 <gwern> there is no thunk
19:54:08 <Cale> http://uk.youtube.com/watch?v=RZX2Bn9Ya_k :)
19:54:13 <lambdabot> Title: YouTube - Roller Chester 1: Dr. Synthesizer
19:54:22 <gwern> nothing has a different type, every operation is permitted
19:54:53 <LoganCapaldo> nothing is allowed, everything thing is permitted
19:55:33 <gwern> LoganCapaldo: jinx
19:55:47 <LoganCapaldo> it wasn't a jinx
19:55:51 <LoganCapaldo> I was riffing on you
19:56:11 <gwern> hmm. if you say so
19:56:47 <LoganCapaldo> your statement caused minw
19:56:50 <LoganCapaldo> *mine
19:57:01 <LoganCapaldo> it's impossible for that to be a jinx
19:57:49 <gwern> looked to me like they appeared almost simultaneously
19:58:05 <LoganCapaldo> ah
19:58:11 <LoganCapaldo> I blame the internets
19:58:58 * gwern can be a little more specific and blame tor
19:59:36 <ray> you can blame the jerks who don't give free bandwidth to tor, you mean
19:59:41 * ray shakes fist
20:00:10 <gwern> when I could, I gave plenty. but tor can't be a server on my current connection, alas
20:01:06 <radetsky> dons: yeah, that was the problem
20:02:40 <radetsky> the configure script should probably check for that and not succeed if it's missing, but I don't know how to do that
20:03:58 <chessguy> interesting stuff by fincenz: http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
20:03:59 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
20:04:03 <chessguy> uh
20:04:12 <chessguy> s/fincenz/vincenz/
20:04:46 <Pseudonym> Yeah, that was a nice post.
20:04:53 <Cale> fincenz is what vincenz becomes when he accidentally falls into a radioactive tank with sharks
20:05:18 <chessguy> mutated sharks with frickin' lasers on their heads?
20:05:23 <vincenz> chessguy: thx
20:05:34 <vincenz> mbishop put a link on it on reddit
20:05:39 <chessguy> vincenz++
20:05:47 <vincenz> s/on it/to it
20:05:49 <Cale> vincenz: yeah, about 2 seconds before I did, damn him :)
20:05:57 * Pseudonym downloads both volumes of "The theory of parsing, translation and compiling"
20:05:57 <vincenz> :D
20:06:05 <vincenz> 3 downvotes already
20:06:08 * vincenz wonders why
20:06:19 <Cale> Some people just dislike Haskell.
20:06:21 <chessguy> because it contains the word 'haskell' in it
20:06:41 <vincenz> oh right, haskell is  not programming, it's uberleet for pointy-hat type academici
20:06:49 <Cale> We need to get a new link posting thing which doesn't have so much anti-intellectualism now.
20:07:08 <chessguy> academici?
20:07:18 <vincenz> plural of academic?
20:07:30 <chessguy> academics?
20:07:36 <vincenz> dunno, we use academici in our language
20:07:47 <vincenz> I could be mistaken
20:07:53 <vincenz> anywho, potay-toe, potah-toe
20:07:54 <Cale> Programming reddit is now for links about how to set up your wi-fi connection so that your leet hax0r 9 year old neighbour doesn't get in, or when he does, he sees blurry upside down jpegs.
20:08:17 <chessguy> haha, i've seen that article
20:08:33 <Pseudonym> vincenz == Dan Quayle
20:08:51 <vincenz> Pseudonym: eh?
20:09:05 <vincenz> who is dan quayle
20:09:15 <gwern> Cale: come on, that was a pretty cool article
20:09:18 <Pseudonym> Someone who probably won't come up again.
20:13:28 <smack_> Cale: i'd settle for a link-posting system where you can actually see articles people with similar tastes liked
20:14:19 <LoganCapaldo> vincenz++
20:14:26 <vincenz> \o/
20:14:57 <LoganCapaldo> unles notvincenz.blogspot really is not you
20:15:02 <vincenz> well it is me
20:15:12 <LoganCapaldo> ok then you get to keep the karma
20:15:15 <faxathisia> heh
20:15:17 <ddarius> smack_: Make it.
20:15:30 <vincenz> it's notvincenz cause... well it's my nickname, not my real name :)
20:15:36 <Cale> I should create notnotvincenz.blogspot.com
20:15:47 * vincenz smacks Cale upside the head
20:16:25 * vincenz wanted to finish his other article but got bored
20:16:30 <vincenz> seeing how I have to make too many changes
20:16:42 <vincenz> it was a way to take logic and get a karnaugh formulation out of it, courtesy of type classes
20:17:06 <gwern> (stupid frag, not working out because of some perfectly innocnent changes...)
20:17:25 <LoganCapaldo> @type fix (not $)
20:17:27 <lambdabot> Bool
20:17:34 <LoganCapaldo> @type fix (not .)
20:17:35 <lambdabot> forall a. a -> Bool
20:17:49 <LoganCapaldo> hmm
20:17:51 <faxathisia> @type fix (not (.))
20:17:51 <lambdabot>     Couldn't match expected type `Bool'
20:17:51 <lambdabot>            against inferred type `(b -> c) -> (a -> b) -> a -> c'
20:17:51 <lambdabot>     In the first argument of `not', namely `(.)'
20:18:12 <LoganCapaldo> @type foldr (.) id (repeat not)
20:18:12 <lambdabot> Bool -> Bool
20:18:16 <Cale> @type fix ((not .) .)
20:18:17 <lambdabot> forall a a1. a1 -> a -> Bool
20:18:18 <LoganCapaldo> that's what I wanted
20:19:06 <LoganCapaldo> but it's a little too long for a notvincenz variation
20:20:09 <LoganCapaldo> @type  let f x = (not . f) x in f
20:20:10 <lambdabot> forall a. a -> Bool
20:20:14 <LoganCapaldo> gah
20:20:55 <LoganCapaldo> @type  let f x = (not . f) (x :: Boo) in f
20:20:57 <lambdabot> Not in scope: type constructor or class `Boo'
20:21:02 <LoganCapaldo> @type  let f x = (not . f) (x :: Bool) in f
20:21:02 <lambdabot> Bool -> Bool
20:21:45 <LoganCapaldo> @type let f x = f (not x) in f
20:21:46 <lambdabot> forall t. Bool -> t
20:22:51 <LoganCapaldo> @type let f = f . not in f
20:22:57 <lambdabot> forall c. Bool -> c
20:23:07 <LoganCapaldo> :(
20:23:55 <LoganCapaldo> @type let g = g . not ; let f x = g (not x) in f
20:23:55 <lambdabot> parse error (possibly incorrect indentation)
20:24:03 <LoganCapaldo> @type let g = g . not ;  f x = g (not x) in f
20:24:03 <lambdabot> forall c. Bool -> c
20:24:10 <LoganCapaldo> can't write it
20:24:14 <LoganCapaldo> i fail
20:31:59 <Cale> @type let g = not . g . not in g
20:32:00 <lambdabot> Bool -> Bool
20:32:24 <vincenz> :t \vincenz -> not vincenz
20:32:24 <lambdabot> Bool -> Bool
20:32:51 <sjanssen> @pl not . not
20:32:51 <lambdabot> id
20:33:10 <LoganCapaldo> Cale wins the prize!
20:33:22 <sjanssen> pl++
20:33:22 <vincenz> of ?
20:33:24 <vincenz> insanity?
20:33:37 <LoganCapaldo> Of acheiving what I could not
20:33:51 <LoganCapaldo> (without using foldr anyway)
20:34:12 <faxathisia> @pl (not .).(. not)
20:34:12 <lambdabot> (not .) . (. not)
20:34:42 <Cale> faxathisia wins the prize of @pl'ing already points-free code :)
20:35:09 <Cale> :t fix ((not .) . (. not))
20:35:10 <lambdabot> Bool -> Bool
20:36:03 <faxathisia> :t (?f .).(. ?g)
20:36:06 <lambdabot> forall c b c1 a. (?f::c1 -> c, ?g::a -> b) => (b -> c1) -> a -> c
20:36:43 <vincenz> and all this just to beat my blog domain name
20:36:45 * vincenz sighs
20:37:00 <Cale> vincenz: I have no idea :)
20:37:21 <vincenz> wow, 9 downvotes o.O
20:37:27 <vincenz> people must really hate haskell
20:37:35 <vincenz> If it's a problem of not being well written, I told them comments are welcome
20:37:42 <faxathisia> How many upvotes?
20:37:43 <Cale> notnotvincenz at least has that aura of intuitionistic logic
20:37:44 <vincenz> 15
20:37:51 <vincenz> Cale: lem
20:38:14 <vincenz> 10 downvotes o.O
20:38:23 <Cale> vincenz: Yeah, some very good Haskell articles don't even have positive scores, you're doing okay.
20:39:33 <Cale> I should grab the code for hpaste and hack it into something like reddit.
20:39:33 <faxathisia> Maybe type inferrence is a bit confusing for most reddit readers?
20:40:38 <vincenz> I should write flamebaity articles
20:40:53 <vincenz> "supposing W,X,Y,Z,1,2,3,4,5,6,7,8,9,10 we see that A > B"
20:40:58 <vincenz> and then hide the assumptions
20:41:01 <vincenz> and get lots of comments
20:41:15 <faxathisia> hehe
20:41:16 <vincenz> forall A B. (Language A, Language B)
20:54:12 <hexpuem> hmm how do i rebuild the stdlib with split-objs? i added SplitObjs=YES to mk/build.mk but it diddnt seem to do anything
20:59:37 <dons> hexpuem: did you clean the libraries/ dir?
21:00:56 <hexpuem> yea was a clean source tree
21:02:26 * gwern finally finishes up the frag work. -Wall, I trusted you!
21:02:35 <ddarius> > 24*60 `div` 40
21:02:44 <lambdabot>  36
21:03:49 <dons> gwern: did you break it ? :)
21:05:17 <gwern> dons: I removed one harmless variable with a _, and then commented out some code - which turned out to have important side-effects, like making the game, I dunno, visible
21:05:25 <gwern> what a mess it was figuring that out!
21:06:18 <mads-> Does anyone know whether haskell can do opengl?
21:06:35 <hexpuem> yea theres a tutorial linked somewhere from the main site
21:06:57 <mads-> awesome :)
21:07:26 <gwern> mads-: if you're interested in demonstrations, 'cabal install monadius' 'cabal install shu-thing'
21:07:32 <hexpuem> http://haskell.org/~pairwise/HOpenGL/HOpenGL.html
21:07:44 <gwern> dons: the patches went to your unsw address
21:08:13 <mads-> thanks guys...
21:08:18 <mads-> You sure are quick :)
21:08:45 <gwern> mads-: we are underemployed
21:11:08 <mads-> But sure looks interesting :)
21:14:49 <dons> frag was written to use opengl (nice 3d game)
21:15:23 <mads-> frag?
21:15:28 <dons> http://haskell.org/haskellwiki/Frag
21:15:36 <gwern> could be a bit smoother tho
21:16:10 <dons> its entirely unoptimised.
21:16:19 <dons> no one's touched the code since mun finished it.
21:16:21 <Cale> I recall it running at full framerate on my machine though.
21:16:35 <mads-> crazy..
21:16:37 <dons> yep, it was capped at 60 fps or something
21:16:42 <gwern> I was actually thinking of the controls - it seemed to me like a slight mouse movement moved your view around a lot
21:17:18 <hexpuem> haha nice gun model
21:17:23 <Cale> oh, there was probably no smoothing. Also, people who play lots of FPS games tend to like very fast mouse controls :)
21:17:31 <mads-> Did it work better when written in functional language then? The page says something about the purpose of writing the game in functional is to test...
21:17:59 <gwern> mads-: read his thesis and find out!
21:19:14 <Cale> It seemed like he had a nice arrow combinator design.
21:19:26 <dons> it has a nice model for all the agents
21:19:36 <mads-> gwern : aaah, couldn't locate any link for any further info..
21:19:55 <gwern> mads-: it's prominently linked from the wiki page :)
21:20:21 <gwern> :t fmap
21:20:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:21:59 <gwern> hm. is there anyway to get the last member of a list other than something like 'foo !! (length foo)'?
21:22:26 <faxathisia> foo !! length foo
21:22:27 <gwern> or is there any special bytestring way, dons?
21:22:50 <dons> > last "haskelll"
21:22:53 <lambdabot>  'l'
21:23:03 <gwern> @src last
21:23:03 <lambdabot> last [x]    = x
21:23:03 <lambdabot> last (_:xs) = last xs
21:23:03 <lambdabot> last []     = undefined
21:23:05 <Cale> > init "haskelll"
21:23:06 <lambdabot>  "haskell"
21:23:20 <dons> > "haskell" !! (length "haskell") -- btw ;)
21:23:20 <lambdabot>  Exception: Prelude.(!!): index too large
21:24:05 <dons> > last [1..] -- useful for wasting time
21:24:07 <lambdabot> Terminated
21:24:15 <gwern> ok, bytestring has last. that's good
21:25:57 <sarehu> foo !! length foo doesn't work anyway :P
21:27:34 <gwern> true enough
21:32:57 <gwern> night
21:53:24 <gwern> http://www.ohloh.net/projects/6869?p=xmonad <-- ha ha ha! 'Mostly written in C/C++' indeed
21:53:55 <dibblego> gwern, blank page?
21:54:23 <gwern> hm. not blank for me
21:54:31 <clanehin> slow loading
21:54:41 <gwern> you may need to try reload?
21:54:53 <dibblego> reloading renders a blank page immediatel
21:54:53 <dibblego> y
21:55:24 <dibblego> odd, wget doesn't
21:55:51 * gwern shrugs. still amusing that their tags are right about it being in haskell, but their analysis isn't
21:56:31 <clanehin> looks like they use an automated system, probably something similar to sloccout
21:57:04 <Nafai> clanehin: Yes, and I believe their system doesn't understand Haskell yet
21:57:39 <clanehin> I know that sloccount recognizes haskell, so I assume they used something dumber
21:59:07 <clanehin> Well it says the use something called ohcount on their front page.
21:59:14 <clanehin> so there :)
22:02:31 <dons> shapr: you think haskell open source is a punk ideology of coding? :)
22:04:00 <dons> we're an anti-establishment, diy movement!
22:05:45 <gwern> avoiding success/selling-out at all costs
22:05:50 <dons> we do a lot of direct action. (write our own damn kernels and window managers and distribution networks)
22:06:26 <ddarius> We're anti-Establishment?
22:06:31 <Cale> Major code-breaking language changes NOW!
22:06:34 <Cale> hehe :)
22:06:45 <dons> ddarius: to the mainstream of programming
22:07:17 <ddarius> dons: We are?
22:07:44 <dons> ok. well, *i* want to overthrow the establishment :) who's with me?!
22:08:11 * faxathisia isn't busy
22:08:11 <gwern> dons: whaddya rebelling against?
22:08:20 <dons> broken code!
22:08:52 <dons> code that sucks! bugs! a loss of art in programming!
22:08:52 <clanehin> Arr.  I be on the high seas w/ cap'n dons.
22:09:15 <sarehu> careful, speak of this too much and the government will kidnap you and force you to read C/C++/Java forums
22:09:17 <gwern> no no, when someone asks you what are you rebelling against, you're supposed to say, 'what do you got?' a la james dean
22:09:39 <dons> gwern: ah, but see, that was brando, and he was ineffective :)
22:09:47 <dons> (the wild one)
22:09:56 <gwern> or was it brando in the wild one?
22:09:59 <dons> yeah
22:10:00 <gwern> ah, so it was
22:10:39 <gwern> dons: in the larger picture, I'm not sure haskell has been all that effective. it's made life much nicer for some coders, yes, but for the vast masses...
22:10:49 <dons> exactly right.
22:11:12 <dons> we're very much on the fringe, trying to change things. and esp. with open source, now taking more direct measures to get our code into people's heads
22:11:16 <dons> but we could do a lot more :)
22:11:42 <gwern> we need to assassinate some heads of state
22:11:47 <faxathisia> Cale: What changes do you have in mind?
22:11:51 <dons> write come code today == diy ideology of code
22:11:52 <gwern> that got results for the black flaggers before us
22:12:10 <dons> ok, you take guido, i'll take out the ruby guy
22:12:35 <dons> ok, well the 'math faction' of the haskell subculture may be more pacifist
22:12:36 <Cale> faxathisia: Well, the ones which would break things? The changes to the Prelude would do well at that :)
22:12:39 <dons> ddarius and Cale :)
22:13:00 <Cale> faxathisia: A pretty minor one would be to swap the associativity of ($)
22:13:22 <Korollary> dons: They're not pacifists. They're consultants.
22:13:33 <thoughtpolice> matz probably has ninjas. be careful.
22:13:50 <Cale> faxathisia: also, fixing Num to separate off signum and abs, removing Eq, and Show
22:13:57 <gwern> thoughtpolice: no, that's Microsoft (pace xkcd)
22:14:02 <Cale> (from the superclass list)
22:14:09 <dons> so the way to do that is to release a version of base ghc can compile against.
22:14:10 <faxathisia> I see
22:14:17 <gwern> actuallly, we should get xkcd to do our propaganda. he already does some python and lisp, so haskell would be a natural next thing
22:14:28 <dons> gwern: totally. if only he was on freenode.
22:14:41 <dons> there is no language more connected to math and love than pure haskell :)
22:14:46 <gwern> dons: sure he is. he pops into #wikipedia every so often
22:14:54 <Cale> Move Int to a separate library, fix Enum to use Integer, fix the instance of Enum for Float and Double so that it enumerates all values.
22:14:59 <Korollary> dons: Mathematica maybe?
22:14:59 <dons> ah, but there's a whole #xkcd channel
22:15:08 <dons> Korollary: math, maybe.
22:15:12 <Cale> Then there's actual language changes: add a proper record system
22:15:22 <dons> Cale, are these written down on the numeric prelude page?
22:15:26 <Cale> Implement class aliases
22:15:37 <Cale> dons: I don't know :)
22:16:02 <Cale> dons: I was suddenly really annoyed by the Enum using Int thing today.
22:16:49 <Cale> dons: I was playing around with the compactness idea (remember those seemingly impossible programs?) and realised that with a good version of Enum, I could do some rather cool things :)
22:16:50 <dons> there's definitely some annoying legacy things in there.
22:17:01 <dons> oh, i should put up the parallel haskell talk i did today. hmm
22:17:04 * dons hunts for slides
22:17:07 <gwern> Cale: you hit a case where you wanted to enumerate more than Int supported?
22:17:18 <Cale> Like, for example, test if two total functions taking (Float -> Bool) functions as parameters were equal or not.
22:17:22 <dons> ah
22:18:46 <Cale> gwern: I ran into a case where Enum no longer expressed what I needed it to express specifically because the Enum instance for Integer is totally broken.
22:18:55 <HairyDude> any idea how to turn Monad m => StateT Foo (StateT Bar m) Baz into Monad m => StateT Foo m Baz? (I can provide a Bar state)
22:19:37 <Cale> (and there's no way to fix it, because fromEnum :: Integer -> Int, and there's no reasonable way to do that correctly)
22:19:56 <Cale> The composite toEnum . fromEnum should be id, and it's just not, in that case.
22:20:14 <gwern> Cale: you couldn't mod or div over Int's range? (I forget which)
22:20:21 <gwern> that would go Integer -> Int
22:20:34 <Cale> gwern: No, that would destroy correctness.
22:20:36 <dons> parallel haskell - the talk - http://galois.com/~dons/talks/parallel-haskell-jan08.pdf
22:21:02 * gwern wonders again how dons fits it all into a day
22:21:26 <Cale> gwern: Int has only finitely many values, and there's no way to write a function Integer -> Int which is one-to-one.
22:21:27 <HairyDude> hmm, up at the same time as dons. methinks it's time for bed :)
22:21:42 <gwern> Cale: well, if you say so. seems like the only sensible way to go imo
22:21:42 <Cale> (which is really the crucial property I needed)
22:21:44 <dons> HairyDude: i'm in a different place now
22:22:01 <HairyDude> dons: ah, last I checked you were in Oz, where are you now then?
22:22:04 <gwern> (if you're knowingly using a lossy mapping, then you should be able to handle it)
22:22:07 <Cale> gwern: The only sensible way to go is to change the types of fromEnum and toEnum to use Integer rather than Int.
22:22:20 <dons> HairyDude: right, in the US now.
22:22:47 <dons> hey radetsky
22:22:50 <dons> got hmp3 built?
22:22:53 <radetsky> nope
22:22:56 <dons> oh, reminds me, i should announce the release.
22:23:01 <dons> radetsky: oh? what happened in the end?
22:23:14 <dons> it *should* be ready to go. but do you have a bug report?
22:23:18 <radetsky> Tree.hs:188:14:
22:23:18 <dons> yo seafood_
22:23:19 <radetsky>     No instance for (Binary FilePathP)
22:23:29 <seafood_> dons: yo
22:23:34 <Cale> Let's see, what else would I change :)
22:23:35 * HairyDude experiences acute brain explosion syndrome as he tries to work out the time zones.
22:23:39 <dons> radetsky: ah, you need to recompile binary against a new bytestring
22:23:50 * HairyDude calls it a day
22:23:56 <dons> radetsky: binary is linked against an older version of bytestring
22:24:01 <dons> and ghc gives a poor error message
22:24:33 <dons> hmm. maybe its time to write a punk manifesto for open source haskell :)
22:25:33 <Cale> ah, yes, monad comprehensions, let's bring those back
22:25:41 <radetsky> oh, yeah, why does cabal always make Setup.*hs not executable by default?
22:25:51 <Cale> also, drop the MR, it's caused more annoyance than it's ever prevented.
22:26:08 <gwern> dons: first write Hugs Considered Harmful :) then the manifesto
22:26:16 <dons> radetsky: oh, since you can write: runhaskell Setup.hs build
22:26:23 <dons> or use 'cabal-setup'
22:26:26 <gwern> radetsky: I don't think you're supposed to run it directly
22:27:00 <dons> gwern: i've yet to reach a firm view on hugs' role
22:27:10 <dons> it works well as an h98 lint checker
22:27:43 <Cale> Oh, there's some really strange things which I'd like to have, but which are farther out there, and I don't have a really good suggestion as to how they ought to be implemented.
22:27:58 <dons> Cale: maybe monad comprehensions could be a goal for this year.
22:28:00 <Cale> For example, non-evaluating serialisation of arbitrary values.
22:28:05 <dons> we should just do the patch
22:28:26 * dons is collecting '08 todos
22:28:28 <Cale> dons: I should really learn how GHC is put together properly. :)
22:28:58 <Cale> I'm really afraid that at some point there will be too much code to change the Prelude anymore and we'll be stuck with the one we have.
22:29:18 <Cale> Of course, I'll be inviting a language fork at that point :)
22:30:27 <Cale> Haskell' is great, but we should really do a Haskell 2 at some point -- new major version number so people know that it's different :)
22:31:44 <Cale> Oh! And the do-notation translation, and fail in the Monad class, and MonadZero/MonadPlus/MonadOr -- that's got to get fixed. Maybe we could even sneak it in with monad comprehensions somehow :)
22:32:08 <dons> fail/Monad is so annoying.
22:32:26 <dons> i need fail, but i don't want to make something Monad m => when i *only* want a custom fail
22:33:01 <Cale> Yeah, perhaps there should be not only MonadZero, but MonadFail as well.
22:33:17 <ddarius> And by MonadFail you mean Fail
22:33:17 <Cale> (which would define fail and it would have a String parameter)
22:33:48 <Cale> ddarius: Does such a class somehow already exist?
22:34:17 <Cale> Or are you suggesting that the type of fail be more general?
22:34:44 <Cale> Perhaps it would be worth having some extremely polymorphic things.
22:34:48 <Cale> class Zero a where
22:34:55 <Cale>    zero :: a
22:36:11 <Cale> hmmm
22:36:17 <ddarius> Hmm, what's a good resource for Green's function theory?
22:37:45 <Cale> ddarius: I've never touched that stuff myself.
22:38:27 <Cale> Hmm, it would be really nice if we could have multiple base packages.
22:39:04 <Cale> But some of this stuff is tied in a little more deeply than that.
22:39:30 <Cale> I remember some people were actually working toward that, how is that going?
22:40:40 <radetsk1> dons: Either (rescind "GREAT SUCCESS") (iDontKnowHowToUse hmp3)
22:40:57 <dons> radetsk1: ok. so:  hmp3 dir
22:40:57 <radetsk1> it keeps crashing
22:41:04 <dons> you have mpg321 installed?
22:41:05 <radetsk1> right, and it starts out working fine
22:41:07 <dons> and in your path?
22:41:20 <radetsk1> like it plays one song, and then mysteriously stops
22:41:25 <dons> curious
22:41:40 <dons> (btw, i've used this pretty much every day for 4 years i realised today :)
22:42:40 * dons tries $ cabal install hmp3
22:43:11 <dons> awesome :)
22:43:25 <dons> new version of hmp3 out, for those who use it. supports pcre regexes for searching now
22:43:38 <radetsk1> I think the failure is occuring when I try to switch songs
22:43:41 <dons> hmm
22:43:47 <dons> how are you doing that?
22:43:49 <radetsk1> I'm going to let the current song play through and see if it fails at the end
22:43:53 <dons> does 'h' work to show the help screen?
22:44:04 <radetsk1> all of the keys work
22:44:12 <radetsk1> nope, it failed midway through
22:44:22 <dons> does 'd' work to move to the next song?
22:44:41 <radetsk1> it selects the next song, but nothing happens
22:44:48 <dons> are they all .mp3 files?
22:45:08 <radetsk1> yeah
22:45:13 <Cale> http://www.boasas.com/?c=904 :)
22:45:13 <lambdabot> Title: Boy on a Stick and Slither
22:45:44 <ddarius> Slither argues for strict finitism.
22:45:55 <dons> radetsk1: hmm. i'd need more info to debug this.
22:46:01 <dons> mpg321 or mpg123 ?
22:46:03 <radetsk1> at first I thought it had something to do with the key input
22:46:13 <radetsk1> I don't know which one it's using. I have both installed
22:46:25 <radetsk1> but this time it failed without me pressing a single key
22:46:26 <dons> it'll use mpg321 if possible, its more stable
22:46:29 <radetsk1> it's still running, btw
22:46:35 <dons> how is it failing?
22:46:38 <dons> are there error messages?
22:46:49 <radetsk1> no, it's just sitting there and failing to play music
22:47:00 <dons> hmm
22:47:05 <radetsk1> I can bring up the help screen, for instance
22:47:08 <dons> if you press return, does it start?
22:48:03 <radetsk1> no
22:48:07 <radetsk1> space doesn't work either
22:48:19 <radetsk1> I can J to the next track, but it doesn't play
22:48:20 <Cale> Heh, I just found a Haskell comment in a non-programming comment thread :)
22:48:24 <Cale> http://reddit.com/info/65l5e/comments/c02woar
22:48:42 <dons> awesome
22:48:54 <ddarius> dons: Clearly you need to implement your own mp3 decoder.
22:48:55 <dons> procyon is a haskeller though
22:48:59 <dons> ddarius: yeah
22:49:09 <dons> or at least bind to an existing library :)
22:49:16 <Cale> yeah, I'm pretty sure I've seen his name around
22:49:45 <dons> radetsk1: hmm. i'm not sure what's going on, unfortunately. i've not had other reports
22:50:18 <radetsk1> np, I'll look into it
22:50:42 <radetsk1> I suspect it has something to do with the way you're using mpg321
22:50:51 <radetsk1> like the interface to it is unstable, but it happens to work for you
22:50:53 <radetsk1> or something
22:50:55 <radetsk1> or not
22:51:05 <ddarius> He's not the only person that uses hmp3
22:51:13 <dons> ddarius: oh good :)
22:51:19 <ddarius> I don't.
22:51:54 <ddarius> I've considered it, but have so far just stuck with the default application Ubuntu uses.
22:52:01 <dons> its quite good, imo. but there's lots of alternatives these days
22:52:09 <dons> good for tiling/console use -- it resizes well.
22:52:21 * ddarius doesn't use tiling.
22:52:23 <dons> but not enough backends to be successful
22:54:55 <Cale> I use Audacious these days.
22:56:01 <Cale> Really, all I need is something to act as a drop target for directories of music. :)
22:58:30 <radetsk1> dons: might hmp3 communicate with mpg321 if the user didn't do anything?
22:59:10 <radetsk1> or does it just only do a communication for each command, e.g. calling mpg321 filename when the user asked to play filename?
22:59:16 <radetsk1> or whatever
22:59:29 <dons> it takes feedback from mpg321 while songs are playing
23:00:11 <radetsk1> ok
23:00:19 <radetsk1> to set the track position?
23:00:29 <radetsk1> s/set/display/
23:01:52 <radetsk1> I'm wondering if the problem is in popen
23:02:55 <dons> hmm.
23:03:23 <radetsk1> mind you, this is just intuition
23:04:11 <allbery_b> unless you use a pty it could be buffering
23:05:01 <allbery_b> (mpg321 that is; presumably buffering is disabled on hmp3's side)
23:05:13 <radetsk1> allbery_b: I don't understand
23:05:46 <dons> nothing should have changed in the io system. hmm
23:06:01 <dons> you could annotate the input calls, and try to follow the command stream
23:06:32 <dons> i'd like to factor out hmp3's ui as a standalone curses lib, and rewrite the core to be more modern. but it works, so hmm, hard to be motivated to do it :)
23:06:36 <radetsk1> dons: one other thing: my dev environment is composed of some .debs and some stuff I got from hackage
23:06:44 <dons> ok.
23:06:50 <radetsk1> so there might be other improperly linked stuff
23:06:51 <allbery_b> most programs default to block buffering when run over a pipe.  mpg321 might be doing so, since it normally expects a terminal which would be unbuffered
23:07:37 <dons> well, i'd expect to have seen problems in the past if that was the issue
23:08:02 <radetsk1> well, I should probably switch to straight hackage if I want to fix stuff anyway
23:08:22 <radetsk1> I'll be back in a while
23:08:41 <radetsk1> oh, one more thing
23:08:44 <radetsk1> q doesn't work
23:08:51 <radetsk1> I can't quit except with killall -9
23:08:55 <radetsk1> ok, bye
23:11:43 <dons> sounds like something's quite wrong.
23:11:51 <dons> i guess the fork isn't working
23:53:17 <andyjgill> Has anyone use beamer with lhs2Tex to format Haskell code for slides?
