00:00:25 <MyCatVerbs> ddarius: wearing that shirt in public is tantamount to announcing, "I'm so geeky, I shit lambdas."
00:00:45 <MyCatVerbs> ddarius: now I'm wondering if they ship internationally... ;)
00:01:25 <Cin> mycatverb: well i think a lambda on its own will just look like one of those stupid designer logos that you tend to get on cheap shirts. so it's only advertising to people who know what it is, otherwise it's just a shirt with a stupid designer logo on it :P
00:02:01 <dons> the xmonad tshirt is the epitome of awesome
00:02:16 <Cin> hehe
00:02:57 <MyCatVerbs> Cin: the Haskell.org logo would be much more appropriate, aye.
00:04:51 <BMeph> It doesn't look bad: http://www.cafepress.com/haskellnewlogo.7154115
00:05:41 <BMeph> Even better (http://www.cafepress.com/haskellnewlogo.117564257) a mug! :)
00:07:54 <Cin> bmeph: haha. sweet
00:07:55 <MyCatVerbs> BMeph: ooooh!
00:08:31 <MyCatVerbs> Hrmn. Pro: awesome shirt. Con: I think my classmates would actually get up and murder me if I wore that into a lecture.
00:09:06 <MyCatVerbs> Pro: if you don't have anything you feel is worth dying for, how can you be sure that you're really living?
00:10:42 <BMeph> http://www.cafepress.com/haskore  -- 'cause we got the "func! ;)
00:12:00 <Cale> and it has the Eight Laws of Polymorphic Temporal Media on the back :)
00:31:27 * MyCatVerbs pokes Data.HashTable's source.
00:31:53 <MyCatVerbs> There's a distressingly large quantity of unsafeFoo in there where methinks normal, safe, regular Foo would suffice.
00:32:29 <MyCatVerbs> This is setting off alarm bells in my brain. Is it actually that bad, or am I being paranoid?
00:47:40 <faxlore> :t \x -> x
00:47:48 <lambdabot> forall t. t -> t
00:49:18 <MyCatVerbs> :t const []
00:49:19 <lambdabot> forall a b. b -> [a]
00:49:31 <MyCatVerbs> World, meet world's most useless function. :)
00:50:23 <kmcallister> ?djinn b -> [a]
00:50:23 <lambdabot> -- f cannot be realized.
00:50:35 <faxlore> ?djinn b -> Maybe a
00:50:35 <lambdabot> f _ = Nothing
00:50:54 <kmcallister> ?djinn a -> [a] -> [a]
00:50:54 <lambdabot> f _ a = a
01:26:58 <TheBlueDude> hey, i have an error message i don't understand
01:27:08 <TheBlueDude> can anyone please help me?
01:27:26 <ivanm> depends on what the error message is...
01:27:39 <ivanm> bit hard to help you if we don't know what it is :p
01:27:54 <TheBlueDude> dissectionstep :: (Double -> Double) -> [Double] -> [Double]
01:28:09 <TheBlueDude> this is the code, sorry i'm typing this
01:28:11 <ivanm> @hpaste <-- put it here
01:28:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:28:17 <TheBlueDude> can't use paste
01:28:23 <ivanm> why not?
01:28:26 <TheBlueDude> sorry, ok
01:28:36 <TheBlueDude> i mean, can';t use ctrl-v
01:28:53 <TheBlueDude> i'm using a different comp for the internet to the one i'm programming on
01:29:06 <TheBlueDude> sorry, how do i use the paste bin again/
01:29:24 <TheBlueDude> i used it once, long time ago...
01:29:25 <ivanm> the link is above... or else just go to hpaste.org and select a new one
01:31:56 <hpaste>  TheBlueDude pasted "(no title)" at http://hpaste.org/4963
01:32:12 <TheBlueDude> i hope my typing is accurate
01:32:19 <TheBlueDude> i think it's the same
01:32:33 <glguy> TheBlueDude: every if has an else
01:32:53 <TheBlueDude> the error is 'parser error (possible incorrect indentation)'
01:33:07 <TheBlueDude> sorry, every if should have an else?
01:33:12 <MyCatVerbs> TheBlueDude: yep.
01:33:21 <hpaste>  glguy annotated "(no title)" with "using guards" at http://hpaste.org/4963#a1
01:33:32 <TheBlueDude> that's not how i did other programs that worked
01:33:33 <MyCatVerbs> TheBlueDude: "if foo then bar else baz" in Haskell works just like "foo ? bar : baz"
01:33:50 <MyCatVerbs> (er, foo ? bar : baz in C, I mean)
01:34:10 <TheBlueDude> ok
01:34:41 <TheBlueDude> so it should go... blah else if () then () else if () then () else if () then ()?
01:35:36 <ivanm> TheBlueDude: multiple if...then...else statements are to be avoided
01:35:37 <glguy> if you are chaining if statements like that, then you should consider switching to guards like I showed you
01:35:38 <MyCatVerbs> TheBlueDude: yep.
01:35:57 <ivanm> or else a case statement, though guards are nicer
01:36:10 <TheBlueDude> sorry, i see. cool thanks
01:36:23 <MyCatVerbs> TheBlueDude: the problem you have there is that there's no need for the last "if" there, because there's no sane way for a number to fail all three tests. :)
01:36:52 <TheBlueDude> exactly, i tried just an else there but it didn't work either
01:36:58 <TheBlueDude> anyway, i'll try the guards
01:37:25 <hpaste>  MyCatVerbs annotated "(no title)" with "This would also be entirely justifiable" at http://hpaste.org/4963#a2
01:38:06 <ivanm> glguy's sol'n looks much nicer than yours, MyCatVerbs :p
01:38:09 <MyCatVerbs> TheBlueDude: the guards is the best approach. It's a much nicer syntax than running through nested if-then-elses. :)
01:38:15 <MyCatVerbs> ivanm: mine's funnier. XD
01:38:22 <ivanm> true
01:38:23 <ivanm> ;-)
01:38:40 <glguy> actually, both solutions are unacceptable
01:38:42 <glguy> fixing..
01:38:58 <lollicide> should add a  "where mid = (a+b)/2" ..
01:39:03 <ivanm> TheBlueDude: other thing is, what happens if dissectionstep gets a parameter with either more or less than two elements in the list?
01:39:15 <Cale> why a list of Double and not a (Double,Double) pair?
01:39:22 <hpaste>  glguy annotated "(no title)" with "compare!" at http://hpaste.org/4963#a3
01:39:43 <TheBlueDude> there is no universe anyway
01:40:03 <TheBlueDude> or if there is, it is already broken :-)
01:40:30 <MyCatVerbs> TheBlueDude: oh and the pair there in the argument list should be written with round brackets, not square ones, since it's a tuple rather than a list.
01:41:09 <TheBlueDude> but i'm using lists instead of tuples
01:41:18 <TheBlueDude> at least that's how i defined the function
01:41:45 <Cale> If you're only going to accept lists of one particular length, it's probably a good idea to use tuples.
01:41:54 <TheBlueDude> ok
01:42:17 <TheBlueDude> but, what function returns the first/second item of a tuple
01:42:20 <TheBlueDude> ?
01:42:26 <Cale> (that way, the compiler will warn you if you try to pass anything else, rather than you getting some runtime error)
01:42:30 <Cale> fst/snd
01:42:34 <TheBlueDude> cool
01:42:36 <Cale> But usually you just pattern match
01:42:44 <MyCatVerbs> TheBlueDude: you can either use fst and snd, or you can just pattern match against the tuple.
01:43:03 <MyCatVerbs> TheBlueDude: literally, what you have right there right now, but with round brackets instead of square ones, does the trick. :)
01:43:15 <Cale> (and a modified type)
01:43:41 <Cale> [Double] becomes (Double, Double)
01:44:21 <MyCatVerbs> TheBlueDude: sorry, I originally misread (sheer stupidity on my part) your type declaration, somehow (hint: stupidity).
01:44:24 * Cale suddenly wonders if Tim Horton's would be open at 4:42 am :)
01:44:27 <TheBlueDude> yes, i'm trying it out now.....
01:44:36 <MyCatVerbs> TheBlueDude: but if the list's length is fixed, it shouldn't really be a list anyway.
01:44:57 <TheBlueDude> now it's giving a UTF-8 encoding error
01:45:06 <Cale> uhh...
01:45:36 * MyCatVerbs blinks.
01:45:36 <TheBlueDude> decoding, whatever
01:45:38 <MyCatVerbs> That's new.
01:45:54 <Cale> check that there are no strange characters in your source file?
01:46:28 <TheBlueDude> ahhh, i was using ¦ instead of |
01:46:32 <Cale> ah
01:46:47 <TheBlueDude> voila, ca marche
01:47:00 <Cale> glguy's version is the nicest, I think :)
01:47:24 <TheBlueDude> his was the one i used
01:47:35 <TheBlueDude> i'd forgotten the guards thing
01:47:44 <TheBlueDude> i haven't used haskell much
01:47:50 <TheBlueDude> and it was awhile ago
01:49:04 <hpaste>  Cale annotated "(no title)" with "possibly a little cleaner :)" at http://hpaste.org/4963#a5
01:50:54 <TheBlueDude> hehe, i love the way there are so many different ways to do one thing
01:51:16 <TheBlueDude> and it can be simplified so much
01:51:49 <TheBlueDude> thanks, the program is now working
01:52:46 <MyCatVerbs> TheBlueDude: Haskell people are fussy about fugly code. If there's no nice way to write something out tersely then they go off, invent three, then slowly converge on a preferred one of those by watching which one is nicest to use in practice. Then it becomes a permanent language extension and everyone forgets that it ever existed, right up 'til the point they find a use for it. Then it gets a blog post. :)
01:55:57 <TheBlueDude> see y'all
01:58:11 <nornagon> @src (>=>)
01:58:12 <lambdabot> Source not found. My pet ferret can type better than you!
01:58:39 <MyCatVerbs> \bot is kinda bitchy.
01:59:02 <MyCatVerbs> > replicate 40 '.'
01:59:04 <lambdabot>  "........................................"
02:00:03 <Cale> > concat ["^", replicate 40 '_', "^"]
02:00:04 <lambdabot>  "^________________________________________^"
02:00:35 <MyCatVerbs> Cale: amusingly, '_' is a valid smiley in and of itself.
02:00:35 <faxlore> >("^"++).reverse.("^"++)$replicate 40'_'
02:01:06 <Cale> missing space after >
02:04:09 <MyCatVerbs> > (++) "Ke" $ concat . repeat $ "ke"
02:04:10 <lambdabot>  "Kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek...
02:17:55 <czakey> > repeat "yawn"
02:17:56 <lambdabot>  ["yawn","yawn","yawn","yawn","yawn","yawn","yawn","yawn","yawn","yawn","yawn...
02:19:27 <phlpp> repeat "zzZZzzzzZzZzZ"
02:19:45 <czakey> you are snoring!
02:19:53 <phlpp> > replicate 15 "zzZZzzzzZzZzZ"
02:19:53 <lambdabot>  ["zzZZzzzzZzZzZ","zzZZzzzzZzZzZ","zzZZzzzzZzZzZ","zzZZzzzzZzZzZ","zzZZzzzzZz...
02:20:11 <phlpp> hehe
02:20:23 <Cale> > replicateM 5 "zZ"
02:20:23 <lambdabot>  ["zzzzz","zzzzZ","zzzZz","zzzZZ","zzZzz","zzZzZ","zzZZz","zzZZZ","zZzzz","zZ...
02:20:30 <Cale> > concat (replicateM 5 "zZ")
02:20:31 <lambdabot>  "zzzzzzzzzZzzzZzzzzZZzzZzzzzZzZzzZZzzzZZZzZzzzzZzzZzZzZzzZzZZzZZzzzZZzZzZZZz...
02:20:36 <faxlore> > concatMap (\x -> case even x of True -> 'z' ; _ -> 'Z') [1..]
02:20:36 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
02:20:44 <faxlore> >:D
02:20:47 <phlpp> :D
02:20:48 <oerjan> > replicateM 15 "Zz"
02:20:49 <lambdabot>  ["ZZZZZZZZZZZZZZZ","ZZZZZZZZZZZZZZz","ZZZZZZZZZZZZZzZ","ZZZZZZZZZZZZZzz","ZZ...
02:21:04 <faxlore> > map (\x -> case even x of True -> 'z' ; _ -> 'Z') [1..]
02:21:04 <lambdabot>  "ZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZ...
02:21:23 <phlpp> concat ["8", replicate 50 '=', "D"]
02:21:31 <oerjan> > cycle "Zz"
02:21:32 <lambdabot>  "ZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZ...
02:21:32 <phlpp> > concat ["8", replicate 50 '=', "D"]
02:21:32 <lambdabot>  "8==================================================D"
02:22:08 <faxlore> > ("8"++).reverse.("D"++)$replicate 40'='
02:22:09 <lambdabot>  "8========================================D"
02:22:17 <czakey> > replicate 50 ":)"
02:22:18 <lambdabot>  [":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",...
02:22:23 <czakey> hmm
02:22:25 <faxlore> > last [1..]
02:22:27 <lambdabot> Terminated
02:23:04 <czakey> > concat replicate 50 "oO"
02:23:04 <lambdabot>  Couldn't match expected type `[[a]]'
02:23:18 <czakey> > concat (replicateM 50 "oO")
02:23:19 <lambdabot>  "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
02:23:35 <Cale> > concat (replicateM 3 "oO")
02:23:36 <lambdabot>  "oooooOoOooOOOooOoOOOoOOO"
02:23:37 <czakey> why only small?
02:23:41 <phlpp> > cycle "oO"
02:23:41 <lambdabot>  "oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOo...
02:24:01 <czakey> ah
02:24:04 <Cale> because there are 50 small o's followed by 49 more small o's then a big O
02:24:06 <czakey> because concatenation
02:24:11 <Cale> then 48 small o's
02:24:11 <czakey> is first?
02:24:18 <czakey> ok
02:24:33 <faxlore> > concat (replicateM 4 ".oO'")
02:24:33 <lambdabot>  ".......o...O...'..o...oo..oO..o'..O...Oo..OO..O'..'...'o..'O..''.o...o.o.o....
02:24:36 <Cale> > drop 100 (concat (replicateM 50 "oO"))
02:24:36 <lambdabot>  "ooooooooooooooooooooooooooooooooooooooooooooooooOoooooooooooooooooooooooooo...
02:25:12 <Cale> > drop 100000 (concat (replicateM 50 "oO"))
02:25:12 <lambdabot>  "oooooooooooooooooooooooooooooooooooooooOOOOOoOooooooooooooooooooooooooooooo...
02:25:36 <czakey> afrer my first program in haskell (yestureday)
02:25:48 <czakey> now something more complicated ;d
02:26:04 <czakey> someone has any experience
02:26:17 <czakey> in "Haskelling" LDAP
02:26:24 <profmakx> there is a library
02:26:32 <profmakx> LdapHaskell
02:26:32 <czakey> I now that
02:26:35 <profmakx> on hackage
02:26:44 <shag> someone knows a library which provides encoding unicode characters to HTML entities like &#123; and vice-versa?
02:26:48 <czakey> I want to write LDAP password manager
02:26:50 <profmakx> so what do you want to do?
02:27:00 <profmakx> get the lib and do it ;)
02:27:01 <czakey> under Debian
02:27:26 <czakey> it will be good if it will be on web
02:27:59 <czakey> damn I'll be glad if that will not have any ldap-injections :D
02:28:11 <czakey> so -> this is Haskell for, right?
02:28:12 <czakey> :>
02:28:27 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LDAP-0.6.1
02:28:29 <lambdabot> http://tinyurl.com/3xqe2m
02:28:47 <czakey> thx
02:29:06 <Cale> Kind of strange that it defines  type LDAPInt = CInt  rather than doing marshalling.
02:29:31 <daf> Cale: oh!
02:29:41 <daf> Cale: took me a minute that it worked that way because of the list monad
02:31:05 <Cale> daf: Are you the same person as someone else here, or just commenting on the code above?
02:31:19 <daf> just commenting
02:31:35 <daf> I don't understand it 100%
02:31:41 <Cale> okay, I can explain :)
02:31:52 <Cale> First of all, do you know about the function sequence?
02:32:03 <Cale> sequence [] = return []
02:32:07 <daf> yes
02:32:16 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:32:37 <daf> yep, that makes sense
02:32:44 <Cale> It takes a list of actions, and produces an action which runs each in turn, producing a list of results.
02:33:04 <Cale> In the list monad, running an action just means picking a member of the list.
02:33:24 <Cale> This is done in all possible ways, and you get a list of all possible lists of results.
02:33:42 <Cale> Which is just the Cartesian product of the input lists.
02:33:54 <Cale> > sequence [[1,2,3], [4,5], [6,7,8]]
02:33:56 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
02:34:13 <daf> oh, so "done in all possible ways" is a property of the monad, not a property of replicateM
02:34:19 <Cale> right
02:34:21 <daf> I think that's what confused me
02:34:30 <Cale> replicateM n = sequence . replicate n
02:35:11 <Cale> so,  replicateM 5 "zZ" = sequence ["zZ", "zZ", "zZ", "zZ", "zZ"]
02:35:31 <Cale> > replicateM 5 [0,1]
02:35:32 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0,...
02:37:17 <kolmodin> does haddock 2.0.0.0 only build with ghc 6.8.2 ?
02:37:26 <daf> Cale: thanks for the explanation
02:37:49 <Cale> > map (foldl (\n x -> x + 2*n) 0) (replicateM 5 [0,1])
02:37:49 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:37:58 <Cale> :)
02:38:07 <kolmodin> mm. yes
02:38:09 <Cale> daf: No problem :)
02:38:23 <cook63> Un Saluto a Tutte Le Anime!
02:38:27 <cook63> !list
02:38:33 --- mode: ChanServ set +o Cale
02:38:36 <faxlore> cook63: nope..
02:38:46 <Cale> cook63: wrong channel for that :)
02:39:31 <daf> Cale: haha, that last one is nice
02:40:06 <Cale> :)
02:40:13 --- mode: Cale set -o Cale
02:47:35 <sarah__> @src num --hmm doesnt tell me whats the minimum number of methods i need to implement to make it a propper subclass
02:47:35 <lambdabot> Source not found. You untyped fool!
02:48:03 <faxlore> @src Num
02:48:03 <lambdabot> class  (Eq a, Show a) => Num a  where
02:48:03 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:48:03 <lambdabot>     negate, abs, signum     :: a -> a
02:48:03 <lambdabot>     fromInteger             :: Integer -> a
02:48:16 <faxlore> @src (+)
02:48:16 <lambdabot> Source not found. My mind is going. I can feel it.
02:49:10 <sarah__> faxlore: do i need to do ALL of those (i know some in ord are defined in terms of eachother)
02:49:40 <faxlore> @src negate
02:49:41 <lambdabot> negate x = 0 - x
02:49:45 <faxlore> you don't need negate
02:50:20 <faxlore> although you might actually?
02:54:30 <RayNbow> hmm, is there a nice way to benchmark the evaluation of expressions in a Haskell program?
02:54:45 <RayNbow> currently I'm just getting the system time, print the evaluation to screen
02:54:49 <RayNbow> and get the system time again
02:55:40 <RayNbow> (but this benchmarks the time it took to evaluate the expression -and- the printing to the screen)
03:02:51 <Jomyoot> Is Module file to be the same name is Module?
03:02:56 <Jomyoot> Including directory structure?
03:03:04 <axm> hi, i am trying to build lambdabot with plugins and am stuck at the error: "lexical error at character 'i'".
03:03:17 <axm> Jomyoot, i think it has to be in ghc for linking
03:03:34 <axm> so generally no, practically yes
03:04:02 <Jomyoot> thanks
03:04:42 <faxlore> :info :
03:04:53 <czakey> > map (\x -> case (x mod 2 == 0) -> "mul of 2"; _ -> '.') [1..]
03:04:54 <lambdabot>  Parse error at "->" (column 32)
03:05:08 <axm> the long answer is in the ghc docs 3.2.1
03:05:28 <axm> (if you are using that anyway)
03:06:33 <czakey> > map (\x -> case (x `mod` 2 == 0) -> "2 or more" ; _ -> '.') [1..]
03:06:33 <lambdabot>  Parse error at "->" (column 34)
03:09:48 <axm> anyway, i got the fresh lambdabot from darcs, works without plugins, changed to the plugins configuration file, BotPP would not build anymore so I did that manually, and then ended up with the lexical error as above. Anyone a clue, is it just broken at the moment?
03:22:48 <Jomyoot> where is a good reading on String operation like how to concat string, converting int to string and etc.
03:22:59 <glguy> what's the deal with all the me too roman numerals posts hardcoding in the 4s and 9s??
03:23:13 <Botje> Jomyoot: strings are just [Char]
03:23:14 <glguy> why stop there, why not just put a table of values in your source code
03:23:37 <Botje> so appending two strings is s1 ++ s2
03:23:59 <Jomyoot> how about converting int to string
03:24:02 <RayNbow> show
03:24:07 <RayNbow> > show 124
03:24:09 <lambdabot>  "124"
03:24:18 <faxlore> @hoogle [(a,b)] -> ([a],[b])
03:24:19 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
03:24:19 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
03:24:28 <RayNbow> > read "124" :: Int
03:24:29 <lambdabot>  124
03:25:24 <glguy> the romans were way less picky about how they stacked their numerals together
03:25:32 <glguy> IIC would be perfectly fine for 98
03:27:18 <axm> but ICI wouldnt. in fact, would be illegal
03:32:36 <faxlore> Type inferrence is quite a complex algorithm?
03:32:49 <faxlore> like at least O(n^3) in the size of terms?
03:35:17 <Botje> probably
03:36:09 <faxlore> > let f (x:xs) = [(x,y)|y<-xs] ; f [] = [] in concatMap f (tails [1,2,3,4,5])
03:36:11 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
03:36:19 <pejo> faxlore, it's certainly quick enough for most real programs though.
03:36:23 <faxlore> Can you see how to do that better :)
03:37:16 <Botje> > let f l = zip l $ tail l in f [1..5]
03:37:17 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
03:37:27 <Botje> wait, it's too early.
03:37:46 <faxlore> hm, pejo, that just makes me want to find a corner case which takes a really long time to check :D
03:37:56 <therp> faxlore: http://portal.acm.org/citation.cfm?id=96709.96748
03:37:58 <lambdabot> Title: Deciding ML typability is complete for deterministic exponential time
03:38:16 <faxlore> ok cool, thanks
03:38:17 <Botje> > let xs = [1..5] in [(x,y) | x <- xs, y <- ys, x < y]
03:38:17 <lambdabot>   Not in scope: `ys'
03:38:22 <Botje> > let xs = [1..5] in [(x,y) | x <- xs, y <- xs, x < y]
03:38:23 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
03:38:26 <Botje> there we go
03:38:39 <faxlore> Botje, pretty nice
03:38:51 <faxlore> I couldn't define a < on my type though :[
03:39:39 <Botje> faxlore: you could bring the pattern match on (x:xs) inside the list comprehension
03:40:26 <Botje> > let xss = [1..5] in [(x,y) | (x:xs) <- tails xss, y <- xs]
03:40:27 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
03:40:34 <Botje> isn't that nice? :)
03:40:46 <faxlore> ahh nice :D
03:40:52 <faxlore> ok I'm going to use this
03:40:54 <faxlore> thanks
03:41:09 <kuribas> > [(x,y) | x <- [1..5], y <- [x..5]]
03:41:10 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
03:41:55 <faxlore> @let pairs list = [ (x,y) | (x:xs) <- tails list, y <- xs ]
03:41:57 <lambdabot> Defined.
03:42:07 <kuribas> Hm, it's not the same...
03:42:13 <faxlore> > pairs ["jon", "joan", "mary", "fred"]
03:42:14 <lambdabot>  [("jon","joan"),("jon","mary"),("jon","fred"),("joan","mary"),("joan","fred"...
03:42:16 <faxlore> hehe :D
03:43:26 <Botje> hello, MyCatVerbs
03:44:02 <MyCatVerbs> Botje: thanks for the welcome. How are you this fine morning?
03:44:15 <Botje> hung over from too little sleep :)
03:44:25 <EvilTerran> @let xs `c` 0 = [[]]; [] `c` n = []; xs `c` n | n > 0 = [ y:ps | (y:ys) <- tails xs; ps <- ys `c` (n-1) ] in map ([1..5]`c`) [0..]
03:44:25 <lambdabot>  Parse error
03:44:27 <EvilTerran> >let xs `c` 0 = [[]]; [] `c` n = []; xs `c` n | n > 0 = [ y:ps | (y:ys) <- tails xs; ps <- ys `c` (n-1) ] in map ([1..5]`c`) [0..]
03:44:29 <Botje> exam tomorrow and two deadlines due today
03:44:30 <EvilTerran> > let xs `c` 0 = [[]]; [] `c` n = []; xs `c` n | n > 0 = [ y:ps | (y:ys) <- tails xs; ps <- ys `c` (n-1) ] in map ([1..5]`c`) [0..]
03:44:30 <lambdabot>  Parse error at ";" (column 83)
03:44:34 <EvilTerran> hmm
03:45:14 <EvilTerran> > let xs `c` 0 = [[]]; [] `c` n = []; xs `c` n | n > 0 = [ y:ps | (y:ys) <- tails xs, ps <- ys `c` (n-1) ] in map ([1..5]`c`) [0..]
03:45:15 <lambdabot>  [[[]],[[1],[2],[3],[4],[5]],[[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4]...
03:45:35 <MyCatVerbs> > tails $ cycle $ [1..10]
03:45:36 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6...
03:46:00 <MyCatVerbs> > drop 50 $ tails $ [1..10]
03:46:01 <lambdabot>  []
03:46:06 <MyCatVerbs> > drop 50 $ tails $ [1..]
03:46:07 <lambdabot>  [[51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75...
03:50:51 <phlpp> > 'H'+2
03:50:52 <lambdabot>   add an instance declaration for (Num Char)
03:50:52 <lambdabot>     In the expression: 'H' + 2
03:50:52 <lambdabot>  ...
03:51:41 <Botje> > ord $ (chr 'H') + 2
03:51:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
03:51:44 <Botje> bah
03:51:49 <Botje> > chr$ (ord 'H') + 2
03:51:50 <lambdabot>  'J'
03:52:01 <Botje> (or use fromEnum and toEnum)
03:52:02 <phlpp> > ord 'H'
03:52:03 <lambdabot>  72
03:52:07 <phlpp> ah
03:52:50 <phlpp> map (\x -> chr$(ord x)+2) "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g"
03:53:01 <phlpp> > map (\x -> chr$(ord x)+2) "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g"
03:53:02 <lambdabot>  "i\"hope\"you\"didnt\"tr{nsl{te\"it\"|y\"h{nd0\"th{ts\"wh{t\"computers\"{re\...
03:53:09 <phlpp> hehe
03:53:11 <faxlore> haha
03:58:38 <phlpp> > [ chr$(ord x)+2 | x <- "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g", (ord x /= 32 && ord x < 120)
03:58:39 <lambdabot>  Parse error at end of input
03:58:42 <phlpp> > [ chr$(ord x)+2 | x <- "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g", (ord x /= 32 && ord x < 120) ]
03:58:43 <lambdabot>  "ihopeyoudidnttrnslteityhnd0thtswhtcomputersrefor0doingitinyhndi"
03:59:14 <faxlore> Just wondering is this sort of thing:   liftM unzip $ mapM deepen context    ok?
03:59:22 <faxlore> It's not overcomplex is it?
04:01:25 <kuribas> Which editors do most people use?
04:01:43 <ivanm> oh no, not the haskell editor war again...
04:01:46 <ivanm> ;-)
04:02:03 <kuribas> It's just a polite inquiry :)
04:02:06 <faxlore> someone must add an editor to ghci
04:02:07 <axm> emacs, vim, there is also an eclipse plugin, but that is not widely used
04:02:31 <C-Keen> I use acme
04:02:43 <matthew-_> cat and sed should really be sufficient...
04:02:46 <ivanm> faxlore: there's an ability to tell ghci which editor to use IIRC
04:02:50 <ivanm> matthew-_: lol
04:02:54 <ivanm> does anyone actually use yi?
04:03:44 <Corun> > unwords $ map (map (chr . (2+) . ord)) $ words "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g"
04:03:44 <lambdabot>  "i hope you didnt tr{nsl{te it |y h{nd0 th{ts wh{t computers {re for0 doing ...
04:04:45 <kuribas> I am writing an indentation engine for emacs.  Is there any code for stress testing it?
04:04:53 <ivanm> ghc?
04:05:21 <kuribas> ivanm: hm, didn't think of that yet :)
04:05:33 <matthew-_> or darcs or just grab anything out of hackage
04:05:48 <ivanm> kuribas: well, it's the biggest haskell app that I know of...
04:06:10 <faxlore> @src on
04:06:11 <lambdabot> (*) `on` f = \x y -> f x * f y
04:06:34 <kuribas> I am especially interested in exotic constructions.
04:08:02 <matthew-_> kuribas: what do you mean by exotic constructions?
04:08:15 <ivanm> from the far east? :p
04:08:32 <kuribas> Syntax that's not used regularly.
04:08:36 <axm> ok i give up on building lambdabot for now, it apparently is what everybody else with the same error in the irc logs did
04:09:35 <faxlore> kuribas: Lots of interesting variety in the Agda2 implementation
04:09:36 <Corun> > unwords $ map (map (\x -> if x >= 'a' && x <= 'z' then chr $ ord 'a' + ((ord x - ord 'a') + 2) `mod` 26 else x)) $ words "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g"
04:09:37 <lambdabot>  "i hope you didnt translate it by hand. thats what computers are for. doing ...
04:09:47 <Corun> Excellent. :-)
04:10:33 <kuribas> faxlore: ok, thanks.
04:11:22 <glguy> Corun: python challenge, eh?
04:11:30 <matthew-_> Corun: Now use a Vengeir cipher, not a Ceasar shift
04:11:56 <Syzygy-> matthew-_: You mean Vigenère and Caesar, right?
04:12:16 <faxlore> anyone got herband MGU code in haskell?
04:12:17 <Corun> Huh? What challenge? I just saw what phlpp was doing up above
04:12:42 <matthew-_> Syzygy-: obviously ;)
04:12:56 <matthew-_> Syzygy-: I'm surprised I didn't write Vinegar
04:13:08 <Corun> Hehe
04:13:30 <Syzygy-> The vinegar cipher would be something like writing in lemon juice.
04:13:35 <Syzygy-> Right?
04:13:42 <matthew-_> ahh, more stenography then really
04:14:00 <Syzygy-> No.
04:14:14 <Syzygy-> Stenography is shorthand writing. Steganography is embedding information in pictures.
04:14:38 <matthew-_> Oh bugger.
04:14:41 <Corun> (Or sound, or video, or...)
04:14:50 <matthew-_> yeah, anything really.
04:15:18 <Corun> Reminds me of one, a guy embedded a picture in the histogram of the image
04:15:40 <Syzygy-> Corun: Cool.
04:16:06 <Corun> Here it is:
04:16:07 <Corun> http://www.ironicsans.com/2007/09/idea_the_histogram_as_the_imag.html
04:16:07 <lambdabot> Title: Ironic Sans: Idea: The Histogram as the Image, http://tinyurl.com/yoxyfo
04:17:39 <matthew-_> Hmm, I remember something similar from the 1990s BBC series "Bugs"
04:18:00 <matthew-_> which, in general, was less technically accurate than "CSI"
04:18:07 <matthew-_> and that's really quite an achievement
04:18:24 <EvilTerran> > let m = M.fromList (zip <*> drop 2 . cycle $ ['a'..'z']) in map (fromMaybe <*> (`M.lookup` m)) "g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb g"
04:18:25 <lambdabot>  "i hope you didnt translate it by hand. thats what computers are for. doing ...
04:19:19 <matthew-_> EvilTerran: and now all as fmaps ?
04:19:24 <Syzygy-> Corun: That is So Awesome!
04:19:29 <EvilTerran> hmm
04:20:22 <Corun> Cool, init? :-)
04:33:38 <faxlore> Why do we define operator precedence as a number?
04:33:47 <faxlore> instead of relative to other operators..
04:34:38 <lollicide> or why even as an integer and not a float so you can fit something between + and *?
04:36:16 <C-Keen> I need to chop off an element at the _end_ of a list. What function should I use_
04:36:29 <faxlore> C-Keen, reverse.drop.reverse
04:36:32 <faxlore> er
04:36:35 <faxlore> reverse.tail.reverse
04:36:38 <ibid> one possibility is that the old yacc method for handling user-defined precedence requires integer (or equivalent) precedence levels
04:36:39 <xerox> init
04:36:58 <C-Keen> faxlore: oh how is that compared to 'take'?
04:37:08 <faxlore> sorry.. I didn't know init exists, that's much better
04:37:42 <Corun> !bf ++++++++++++++++[->++>++++>++++++>+++++++><<<<<]>>++++.>>-.<+++++.>++++.<<<.>>+++++++.-----------.>------.<+++.---.+.>++.+++++.<<<.>>++.>-----.<<<.>>--.++++.<-----.
04:37:48 <C-Keen> ah init looks nice
04:38:11 <desegnis> C-Keen: »take« is entirely different, since it takes an Int.
04:39:37 <Corun> @bf ++++++++++++++++[->++>++++>++++++>+++++++><<<<<]>>++++.>>-.<+++++.>++++.<<<.>>+++++++.-----------.>------.<+++.--.-.+.>++.+++++.<<<.>>++.>-----.<<<.>>--.++++.<-----.
04:39:37 <lambdabot>  fd:24: hClose: resource vanished (Broken pipe)
04:39:49 <Corun> That's interesting.
04:40:11 <Corun> @bf +++++++++++++++++++[->+++++>++++++><<<]>>++.<++++++.>-.+.
04:40:11 <lambdabot>  fd:24: hClose: resource vanished (Broken pipe)
04:40:20 <Corun> Lambdabot's bf doesn't work :-(
04:41:01 <C-Keen> desegnis: well couldn't you say take (length list -1) list ?
04:41:26 <desegnis> C-Keen: Well you could, but:
04:41:38 <EvilTerran> > zipWith const =<< drop 1 $ [1..10]
04:41:40 <lambdabot>  [2,3,4,5,6,7,8,9,10]
04:41:45 <EvilTerran> > zipWith const <*> drop 1 $ [1..10]
04:41:46 <lambdabot>  [1,2,3,4,5,6,7,8,9]
04:41:48 <EvilTerran> that's the one!
04:42:14 <EvilTerran> @src init
04:42:14 <lambdabot> init [x]    = []
04:42:14 <lambdabot> init (x:xs) = x : init xs
04:42:14 <lambdabot> init []     = undefined
04:42:16 <Corun> :t <*>
04:42:17 <lambdabot> parse error on input `<*>'
04:42:21 <desegnis> »length« must traverse the whole list to compute its length. That is, you would traverse the whole list two times
04:42:24 <faxlore> :t (<*>)
04:42:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:42:26 <EvilTerran> Corun, here it's the S combinator
04:42:45 <EvilTerran> the Applicative instance is (e->)
04:43:03 <desegnis> C-Keen: So it would take two times longer than »init« :)
04:43:11 <EvilTerran> ?type (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
04:43:11 <C-Keen> desegnis: sounds good, init will do just the right thing :) Thanks
04:43:11 <lambdabot> forall e a b. (e -> a -> b) -> (e -> a) -> e -> b
04:43:25 <EvilTerran> desegnis, C-Keen; also, the length version wouldn't work for infinite listds
04:43:39 <EvilTerran> @src (->) (<*>)
04:43:39 <lambdabot> (<*>) f g x = f x (g x)
04:43:50 <desegnis> EvilTerran, point taken
04:45:37 <scook0> @hoogle isRight
04:45:38 <lambdabot> No matches found
04:45:44 <freepenguin> hello
04:47:18 <desegnis> C-Keen, also, the »take (length ...)« version would first compute the length, and would only then be able to give you the first element of the list. So it would be too strict for our tastes. »init« gives you the first element as soon as it knows that the list has at least two elements.
04:48:07 <scook0> @djinn Either a b -> Bool
04:48:08 <lambdabot> f a =
04:48:08 <lambdabot>     case a of
04:48:08 <lambdabot>     Left _ -> False
04:48:08 <lambdabot>     Right _ -> True
04:48:13 <desegnis> freepenguin, feel welcomed
04:48:21 <freepenguin> desegnis, thanx
04:48:27 <desegnis> :-)
04:48:38 <C-Keen> desegnis: the last you mean
04:49:34 <desegnis> C-Keen, no... »init« doesn't give you the last element at all. That's the point of chopping it off
04:49:48 <EvilTerran> > init [1..10]
04:49:49 <lambdabot>  [1,2,3,4,5,6,7,8,9]
04:49:58 <desegnis> > last [1..10]
04:49:59 <lambdabot>  10
04:51:34 <EvilTerran> @check ((==) `ap` liftM2 (++) init (return.last)) . (0:) :: [Int] -> Bool
04:51:35 <lambdabot>  OK, passed 500 tests.
04:53:23 <desegnis> point-free Fu :)
04:54:24 <EvilTerran> @unpl ((==) `ap` liftM2 (++) init (return.last)) . (0:)
04:54:24 <lambdabot> (\ i -> ((==) >>= \ n -> (init >>= \ b -> (\ l -> return (last l)) >>= \ a -> return (b ++ a)) >>= \ m -> return (n m)) (0 : i))
04:54:28 <EvilTerran> eeh
04:55:41 <EvilTerran> @check (\a -> (0:a) == init (0:a) ++ [last (0:a)]) :: [Int] -> Bool
04:55:42 <lambdabot>  OK, passed 500 tests.
04:57:57 <desegnis> It's hard to make a mental connection between »ap« in ((->) r) and »ap« in other monads
04:58:16 <desegnis> But I begin to get used to it
04:58:26 <C-Keen> desegnis: err yes. please ignore that
04:59:17 <faxlore> Does anyone have a name for equations like:
04:59:17 <faxlore> foo(bar, baz) = y
04:59:27 <faxlore> when you really wanted one like y = foo(bar, baz)?
05:01:28 <desegnis> faxlore: »when you really wanted something else« sounds like, mistake
05:09:06 <C-Keen> faxlore: those are equivalent if you talk about equations
05:10:27 <faxlore> yes, it's just that I can write     x = 726 + 78 in haskell
05:10:33 <faxlore> but I cannot write 726 + 78 = x
05:11:00 <desegnis> so what do you want to name?
05:11:15 <Syzygy-> It sounds like you're fishing for lvalues?
05:11:16 <desegnis> it's admittedly surprising that Haskell uses = instead of := for definitions
05:11:28 <faxlore> These kind of equations: "726 + 78 = x"
05:11:40 <EvilTerran> we use '=' because equational reasoning works
05:11:52 <Syzygy-> faxlore: Equations don't come in directions.
05:12:04 <desegnis> EvilTerran, it would still work if we used := ;)
05:12:16 <faxlore> Syzygy-: There is a compound term on the left, and a simple identifier on the right
05:12:29 <EvilTerran> but haskell needs some way of knowing which side is being bound and which side is the value
05:12:46 <EvilTerran> faxlore, "f x y = g y x"; now what?
05:12:52 <Syzygy-> faxlore: Still, if you call it an equation, you've already lost the battle. You need to view it as an assignment.
05:12:56 <Syzygy-> Which -have- direction.
05:13:18 <faxlore> I was implementing (slightly modify) herbrand MGU (again)
05:13:27 <desegnis> Syzygy-, I'd prefer »definition« rather than »assignment«, which sounds imperative-like
05:13:38 <faxlore> They like to put things in a canonical order so as to have termination in a nice setting and such
05:14:06 <Sizur> @users
05:14:07 <lambdabot> Maximum users seen in #haskell: 444, currently: 414 (93.2%), active: 8 (1.9%)
05:14:11 <EvilTerran> also, we use '=' 'cos it's shorter than ':=' ;)
05:14:53 <desegnis> I think that's the actual and obvious explanation
05:15:11 <Syzygy-> desegnis: Sure. Still, it's not an equation.
05:15:32 <desegnis> Syzygy-, why not?
05:15:40 <EvilTerran> in haskell, it's *kinda* an equation
05:16:06 <EvilTerran> unlike in other languages that use = for things that are definitely assignments
05:16:16 <desegnis> Syzygy-, well right, for a definition you have to add the information what in your equation gets defined
05:16:44 <Syzygy-> desegnis: Exactly. Equations -are- symmetric. Definitions aren't, and faxlore's problems stem from this assymetry.
05:16:58 <EvilTerran> desegnis, and you do that in haskell by putting that part on the left
05:17:11 <desegnis> right right
05:17:17 <EvilTerran> no, left ;)
05:17:26 <desegnis> ;)
05:19:47 <Sizur> a simple polyvariadic function example for sum anybody?
05:21:14 <Sizur> that takes a variable number of Integers
05:21:29 <Sizur> and has the final type of Integer
05:24:56 <desegnis> shoud be possible somehow with -XFlexibleInstances, I guess
05:30:33 <EvilTerran> class Sum a where sum :: a; instance Sum Integer where sum = 0; instance Sum a => Sum (Integer -> a) where sum x = x + sum; -- iirc
05:31:00 <EvilTerran> something like that, anyway
05:31:50 <centrinia> I arithmetically encoded the first paragraph of the Declaration of Independence here: http://hpaste.org/4966 :)
05:32:50 <faxlore> centrinia: That's incredible
05:33:03 <faxlore> centrinia: The same algorithm takes pages of C code..
05:33:05 <centrinia> Thanks.
05:34:12 <EvilTerran> ?hoogle inRange
05:34:12 <lambdabot> Data.Ix.inRange :: Ix a => (a, a) -> a -> Bool
05:34:12 <lambdabot> Distribution.Version.withinRange :: Version -> VersionRange -> Bool
05:37:46 <centrinia> Here is the coder: http://hpaste.org/4967
05:37:52 <hpaste>  desegnis pasted "Sum" at http://hpaste.org/4968
05:44:03 <ttfh> morning everyone
05:47:10 <Sizur> morning ttfh
05:49:43 <ttfh> what's the best way to write something(f.ex an Int8) in binary to a file/stdout? I have found "cast" in Data.Typeable, and my thought was to convert my data to chars and print them to a file, am I missing something?
05:50:12 <EvilTerran> you don't want Data.Typeable
05:50:20 <EvilTerran> maybe have a look at Data.Binary?
05:50:52 <ttfh> is Data.Binary in the standard library?
05:51:06 <EvilTerran> it seems not
05:51:27 <ttfh> http://code.haskell.org/binary/
05:51:28 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
05:51:29 <ttfh> that one?
05:52:04 <Sizur> hmm i wonder why we need FlexibleInstances for that
05:52:06 <EvilTerran> looks likely
05:52:17 <EvilTerran> also see Foreign.Storable, for something in the stdlib
05:53:02 <Sizur> anyways FlexibleInstances is a common extension
05:53:21 <ricky_clarkson> @hoogle hex
05:53:21 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
05:53:21 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
05:53:21 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
05:54:07 <desegnis> Sizur: Because (Integer -> a) could collide with (t -> a)
05:54:14 <EvilTerran> ?hoogle readHex
05:54:14 <lambdabot> Numeric.readHex :: Num a => ReadS a
05:54:14 <lambdabot> Text.Read.Lex.readHexP :: Num a => ReadP a
05:55:27 <Sizur> let's see if one can extend Sum to all Nums
05:55:56 <EvilTerran> i think that would need OverlappingInstances as well
05:56:21 <Jomyoot_> After decodeString  why do I still have to use the special putSTR to print it out?
05:56:33 <Jomyoot_> why can't I use regular putStr to print out after decodeString
05:58:15 <ttfh> EvilTerran: it seems that Foreign.Storable could be made to do what I want, but Data.Binary seems to be made for what I want :-)
05:58:28 <roconnor> @seen audreyt
05:58:29 <lambdabot> audreyt is in #haskell and #ghc. I last heard audreyt speak 3d 1h 15m 39s ago.
05:58:32 <EvilTerran> ttfh, indeed :)
05:58:54 <roconnor> @tell audreyt slides from my FP day talk: http://r6.ca/FewDigits/FPdag2008.pdf
05:58:54 <lambdabot> Consider it noted.
06:04:53 <faxlore> just when I thought I started to get the hang of haskell.. I got totally stuck programming somehing :p
06:06:39 <hpaste>  c-keen pasted "Strings are [Chars] aren't they?" at http://hpaste.org/4969
06:06:50 <faxlore> @src Stribng
06:06:50 <lambdabot> Source not found. You speak an infinite deal of nothing
06:06:54 <faxlore> @src String
06:06:54 <lambdabot> type String = [Char]
06:06:56 <faxlore> Yes...
06:07:35 <faxlore> last :: String -> Char .. though
06:07:46 <faxlore> if getGrammar returns a string
06:07:50 <C-Keen> *duh*
06:07:54 <C-Keen> thanks
06:07:55 <faxlore> getLastFromVal should just return the last charcter of it
06:08:06 <centrinia> Infinite deal of nothing: repeat Nothing
06:09:47 <C-Keen> faxlore: sometimes I can't see the wood for the trees
06:10:25 <faxlore> I hope I'm in hte same situation :P
06:11:18 <centrinia> data Wood a = Leaf | Wood a (Wood a) (Wood a)
06:11:28 <centrinia> I can't see the trees for the wood.
06:11:48 <faxlore> that looks illegal
06:12:07 <centrinia> How so?
06:12:20 <faxlore> ey apparently not
06:12:33 <faxlore> oh right. the same name for two things
06:12:43 <faxlore> data Wood a = Leaf | Tree a (Wood a) (Wood a)
06:12:47 <faxlore> would have confused me less :P
06:12:58 <centrinia> But confusion was my point. :)
06:30:09 <Jomyoot_> Can I repeat my unaswered question
06:30:25 <Jomyoot_> After decodeString  why do I still have to use the special putSTR to print it out?
06:30:49 <EvilTerran> where is this putSTR?
06:32:29 <Jomyoot_> System.IO.UTF8
06:32:58 <dcoutts_> @seen dons
06:32:58 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 6h 30m 57s ago.
06:33:19 <dcoutts_> dons: pcre doesn't let us work over chunked data does it? how annoying
06:33:55 <dcoutts_> how do other regex libs work over file input? they can't read the whole thing into one bit memory block can they?
06:34:27 <dcoutts_> the obvious thing is to want to work in 4k chunks or something, though admittedly that does restrict backtracking I suppose
06:35:01 <dcoutts_> what does perl itself do? it surely cannot be strict in the stdin file input just to use regexps?
06:35:17 <scook0> Jomyoot_: System.IO.UTF8.putStr is just IO.putStr . encodeString
06:38:16 <pejo> dcoutts, if you do $a = <filehandle> you get $a to be the contents of the file, and it will read all of it.
06:38:49 <allbery_b> only if you enable slurping; otherwise you get a line\
06:38:52 <dcoutts_> pejo: is there any way of doing it lazily without reading line by line?
06:39:09 <allbery_b> p5 doesn't have a concept of laziness, no
06:39:09 <EvilTerran> perl's line-by-line or everything, i believe
06:39:16 <EvilTerran> although you could hack something up with tie()
06:39:19 <allbery_b> well, there's paragraph mode
06:40:56 <dcoutts_> @seen waern
06:40:56 <lambdabot> I saw waern leaving #ghc and #haskell 1d 14h 43m 23s ago, and .
06:41:32 <EvilTerran> with a bit of fiddling, i think you could have $x = delay { ... } instead of $x = ... as the only noise required for laziness
06:42:19 <EvilTerran> although it might have to be something more like tie $x, Delay => sub {...}, which is a little painful.
06:43:49 <jedbrown> dcoutts_: I heard a rumour that there will be a `cabal update' soon.  Yay!  Is an option to build haddock docs on the horizon too?
06:44:10 <dcoutts_> jedbrown: add a ticket for that so we do not forget
06:44:53 <dcoutts_> jedbrown: it should be possible to set in the config file and override on the command line and similarly for running package tests
06:44:55 <wolverian> dcoutts_, no, perl doesn't have lazy io. it splits the input on $/ (\n by default).
06:45:16 <wolverian> (sidenote: awk can split on an arbitrary regex.)
06:45:37 <dcoutts_> wolverian: ok, do you know what regex lib awk uses?
06:45:58 <allbery_b> awk speaks POSIX EREs
06:45:59 <dcoutts_> jedbrown: hackage trac is here: http://hackage.haskell.org/trac/hackage
06:46:00 <lambdabot> Title: Hackage - Trac
06:46:19 <allbery_b> given that it comes from old Unix, "what regex lib" is classically "its own"" :/
06:46:31 <dcoutts_> I looked a while ago for any C regexp lib that allows working with partial buffers, eg list of 4k chunks
06:46:36 <dcoutts_> and found none :-(
06:46:42 <jedbrown> dcoutts_: Thanks.  Cabal-install is getting quite reliable lately.
06:46:51 <dcoutts_> jedbrown: great
06:47:07 <dcoutts_> jedbrown: still needs a lot of work if you have time to contribute
06:47:11 <wolverian> dcoutts_, that's somewhat.. painful
06:47:13 <allbery_b> answers will differ for nawk (a different "its own", gawk, and mawk
06:47:19 <kib> Hi, if some of you are interested, I've made a book from Eric's 'Haskell for C programmers' site, avaible here : http://kib2.free.fr/Haskell/hfcp.pdf
06:48:02 <dcoutts_> wolverian: aye, seems so, but it's what we'd need for lazy bytestrings
06:51:41 <TomMD> All: Cabal should have a testing framework that will check out all packages in hackage and e-mail the maintainer if they don't work with the latest Cabal.  What do you think?
06:52:20 <dcoutts_> TomMD: I'm currently working on cabal-install build reporting
06:52:20 <allbery_b> hackage is supposed to gain some tinderbox functionality at some point
06:52:46 <TomMD> :-) Yay
06:52:54 <jedbrown> dcoutts_: Wouldn't there need to be some limit to backtracking?  Otherwise you have to keep the whole buffer active so laziness isn't useful.  Did I miss something?
06:53:36 <dcoutts_> the idea is that you'd turn on build reporting in the cabal-install config file and then cabal-install would report back to the hackage server sucess/failure of packages downloaded from that server, along with a little info about the environment, ghc version etc
06:53:38 <fourbissime> hi there. I want to chain functions of type a -> a to go from an initial state to a final state. but for each function, the result may be invalid. so I first thought of using the Maybe monad to have a -> Maybe a. But Rather than having only Nothing as an error, I would like to pass an information. Is there an existing monad for that ?
06:54:02 <mauke> fourbissime: Either String
06:54:44 <allbery_b> more generally, MonadError
06:54:55 <TomMD> dcoutts_: Sounds awesome!  I'm going to have to get into Cabal hacking some time, perhaps some time soon.
06:55:00 <dcoutts_> jedbrown: well, if one writes a regexp that requires backtracking from the beginning then it'd be no worse than doing it strictly, but at least there's the option for most regexes to work lazily
06:55:19 <dcoutts_> TomMD: there are plenty of "easy" tasks for new hackers to try
06:55:29 <dcoutts_> http://hackage.haskell.org/trac/hackage/report/13
06:55:30 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
06:55:40 <TomMD> Thanks!
06:55:47 <dcoutts_> TomMD: it's also linked as "Easy Tickets" from the hackage trac homepage
06:56:53 <fourbissime> mauke allbery_b: thanks !
06:57:20 <dcoutts_> TomMD: with build reporting in place then of course we'd want to go further and include test results in build reports and have an option to just go and try to build every package on hackage
06:57:52 <dcoutts_> TomMD: and a step further than that would be to launch in daemon mode to follow the hackage rss feed and build all new releases
06:58:02 <dcoutts_> ie cheap distributed build-bots
06:58:11 <dcoutts_> cheap/lightweight
06:58:37 <dcoutts_> cabal qabot &
06:58:49 <TomMD> dcoutts_: Absolutely!  Then another step where cabal fixes broken packages automatically (one fix that would help 40% of packages: adding needed depends in the .cabal file)
07:00:37 <TomMD> got to go work for a couple hours - I'll be back and hacking tonight!
07:01:57 <dcoutts_> TomMD: ok, ping me if you need any pointers
07:02:05 <jedbrown> dcoutts_: We need to keep a reference to all old chunks if the Regex does do backtracking.  And since the library doesn't operate on blocks, we would have to reimplement a lot, I think.  But I imagine some people would really appreciate it.
07:03:50 <fourbissime> bye
07:10:33 <dcoutts_> jedbrown: right, to do it properly you'd need the regexp lib to tell you when it's comitted up to a certain point (ie will not need to backtrack back past the point) so you know when it's safe to discard used input
07:10:54 <dcoutts_> or to just use a dfa that does not do backtracking
07:11:10 <dcoutts_> though apparently they're slower generally
07:13:18 <Saizan> why slower?
07:14:29 <dcoutts_> Saizan: I'm not that familiar with regex implementation, try google
07:15:36 <dcoutts_> Saizan: ah, also it cannot capture sub-expressions
07:16:15 <jedbrown> dcoutts_: Is a commitment point something that can be known (without doing something hard)?  Also, the library would have to be block oriented.
07:16:36 <dcoutts_> jedbrown: it will probably only be known dynamically
07:16:47 <dcoutts_> so yes, the lib would have to have that in mind in the design
07:17:02 <dcoutts_> which does explain why most don't :-(
07:18:49 <jedbrown> Time for dons to throw out pcre-light and write yet-another-regex-lib. ;)
07:19:17 <dcoutts_> heh
07:22:00 <faxlore> how do you select something from a list?
07:22:12 <allbery_b> :t (!)
07:22:14 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
07:22:14 <mauke> depends on the criteria
07:22:14 <allbery_b> oops
07:22:17 <allbery_b> :t (!!)
07:22:18 <lambdabot> forall a. [a] -> Int -> a
07:22:19 <faxlore> for example, (element, everythingElse) <- "abcdefg"
07:22:27 <allbery_b> but tere are often better ways
07:22:39 <faxlore> should have ('a', "bcdefg"), ('b', "acdefg"), ('c', "abdefg"), etc
07:23:02 <faxlore> I could have a function genereating a list of all those tuples.. but I wondered if that is usual?
07:30:04 <Saizan> > let pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs) in pick "abcdef"
07:30:08 <lambdabot>  [('a',"bcdef"),('b',"acdef"),('c',"abdef"),('d',"abcef"),('e',"abcdf"),('f',...
07:31:12 <Saizan> faxlore: well, i've seen it needed here at least once in the past :)
07:33:09 <faxlore> ah.. that's neat
07:34:20 <jedbrown> faxlore: Laziness makes it okay to generate the whole list (unless you only need a deep term and know which one it is).
07:39:14 <C-Keen> hm if I get an exception when evaluating a functin in ghci, can I somehow find out where it happened?
07:39:55 <jedbrown> C-Keen: If you have 6.8, there is a debugger.  Check out :trace.
07:40:29 <C-Keen> jedbrown: hrm 6.6.1 here
07:41:23 <jedbrown> It's a good reason to upgrade ;)  A nice blog post on the debugger: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
07:41:24 <lambdabot> Title: Haskell hacking
07:42:45 <C-Keen> jedbrown: ah thanks
07:43:32 <C-Keen> jedbrown: heh I have the same useful error message :)
07:46:33 <jedbrown> C-Keen: heh.  Short of upgrading, you can wrap the offending function.  But it really is worth upgrading.
07:48:53 <wollnyst> hi guys, im new with haskell.... what is wrong on typing ord 'a' into hugs?
07:49:19 <mauke> ord is probably not in scope
07:50:05 <wollnyst> hmm
07:50:40 <jedbrown> wollnyst: Data.Char.ord 'a' -- works in ghci
07:50:50 <Saizan> wollnyst: you need to import Data.Char which is the module that exports it
07:51:13 <mauke> or use fromEnum instead
07:51:42 <wollnyst> ah ok... thanks
07:55:17 <phobes> ?type unfoldr
07:55:19 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:01:53 <IvdSangen> @src unfoldr
08:01:53 <lambdabot> unfoldr f b  = case f b of
08:01:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:01:53 <lambdabot>    Nothing        -> []
08:14:50 <phobes> ?type when
08:14:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:14:57 <faxlore> cool
08:15:21 <hpaste>  faxlore pasted "simple type sythesis" at http://hpaste.org/4971
08:15:35 <faxlore> ah.. rubbish
08:15:37 <faxlore> it got cut off
08:15:53 <hpaste>  faxlore annotated "simple type sythesis" with "last bit" at http://hpaste.org/4971#a1
08:16:32 <faxlore> so this does type inference for subset of haskell
08:17:07 <phobes> ?type if
08:17:08 <lambdabot> parse error (possibly incorrect indentation)
08:17:12 <faxlore> it seems to anyway
08:22:49 * kaol uploaded a new Data.Binary package to Debian
08:23:31 * faxlore wonders if around 200 lines is very short .. long ? for this
08:25:29 <jfredett> xmonad is ~~500 lines
08:26:56 <jfredett> my current  little DAG library is 100, so I think 200 is respectable,
08:27:07 <faxlore> cool
08:27:24 <faxlore> I'm going to try and find the similar code in GHC as well
08:27:39 <jfredett> what is it? (the code)
08:28:35 <faxlore> Cale showed me how haskell does type inferrence, so I tried to that
08:28:43 <jfredett> cool,
08:28:55 <jfredett> a type inferencer in 200 lines?
08:28:58 <pejo> faxlore, "Typing Haskell in Haskell" might be easier to read than the GHC source.
08:29:09 <faxlore> I can type Y combinator so I think it works (is here btw http://hpaste.org/4971 )
08:29:21 <faxlore> pejo, ah thanks!
08:29:29 <faxlore> I have got lost in GHC before :p
08:29:32 <jfredett> ddarius: seems to think that you can do H-M type inference in 5 lines of prolog,
08:29:32 <faxlore> and not found what I wanted
08:30:03 <jfredett> but typing haskell in haskell is pretty cool
08:30:08 <faxlore> maybe.. I think that lots of the code is implementing the unification algorithm (which you wouldn't have to do in prolog0
08:30:15 <faxlore> most of*
08:30:27 <jfredett> right
08:30:47 <jfredett> thats cool, sure beats my little DAG library. :/
08:31:05 <faxlore> in usefulness.. I think not :p
08:31:25 <jfredett> actually, my library is basicly a POS
08:31:28 <jfredett> :)
08:31:33 <faxlore> haha
08:31:35 <hpaste>  kib pasted "newbie_question" at http://hpaste.org/4972
08:31:36 <faxlore> oh well
08:31:55 <faxlore> kib, Do you know what map does?
08:32:11 <jfredett> kib: we like newbie questions, so dont feel bad. :)
08:32:51 <kib> yes, i think so (in python in fact I apply a function to all elements of a list, that's it ?)
08:32:56 <faxlore> yeah
08:33:07 <jfredett> right, and thats basicly what you're doing here-
08:33:16 <jfredett> applying a "reverse pair" function
08:33:16 <faxlore> so if you defined a flipTuple function that turn (x,y) into (y,x).. Then you could write this function using map
08:33:27 <faxlore> something like renv = map flipTuple
08:34:01 <kib> but I'm having difficulties with Haskell syntax. Is there any Quickref anywhere ?
08:34:02 <jfredett> or, if you like the list comprehension style, it could be
08:34:02 <jfredett> renv ls = [(y,x) | (x,y) <- ls]
08:34:21 <jfredett> the wikibook is hardly quick, but it is fairly lucid
08:34:40 <idnar_> @pl \(x, y) -> (y, x)
08:34:40 <lambdabot> uncurry (flip (,))
08:34:40 <jfredett> http://en.wikibooks.org/wiki/Haskell
08:34:44 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
08:35:48 <kib> thanks jfredett, I already made that but when I compile I've got nothing (no executable).
08:36:06 <jfredett> ah, are you running in ghci?
08:36:20 <jfredett> or doing a ghc -make blahblah
08:37:06 <kib> no, not with ghci. In fact I just saw I've forgotten '-make' :)
08:37:18 <jfredett> you should probably just use ghci
08:37:53 <jfredett> you have to write a main function otherwise,which leads to IO monad, which (for most people) leads to trouble.
08:38:05 <jfredett> ghci myModule.hs
08:38:13 <jfredett> will load it up, with a nice repl
08:38:26 <kib> >> ghc-6.6.1: unrecognised flags: -make
08:38:40 <doserj> --make
08:38:58 <jfredett> yah- I don't compile things much, :)
08:39:19 <kib> doserj : thanks, it works now :)
08:39:20 <rabby> hi
08:39:26 <jfredett> rabby: heyo
08:40:26 <rabby> playing a bit with haskell, i wonder if there isn't a list of binding priorities:
08:40:56 <rabby> e.g. whether && is more important than || or mod vs. div and so on...
08:41:04 <jfredett> ah, fixitys.
08:41:21 <jfredett> i'm fairly sure that that info is in the prelude docs, hang on
08:41:47 <RayNbow> @src (.)
08:41:47 <lambdabot> (.) f g x = f (g x)
08:42:06 <RayNbow> hmm, I would have expected an infix definition... :p
08:42:15 <jedbrown> rabby: You can do :info from ghci.  I don't know of a list.
08:42:21 <jfredett> hmm, well
08:42:37 <jfredett> typically functions bind most strongly to the right
08:42:48 <jfredett> so f . g . h = f . (g . h)
08:42:56 <jfredett> (someone stop me if I screw up)
08:43:00 <IvdSangen> and function application binds strongest
08:43:21 <jfredett> then you can manually set fixity of your functions using the syntax:
08:44:05 <jfredett> infix(r|l) # f, where # is some number from 0 to 9, where 9 is "bind most strongly" and 0 is "bind least strongly"
08:44:07 <jfredett> and f is your function
08:44:33 <kib> How can I print my tuples one by one, ie one line at a time ?
08:45:03 <jfredett> you can do sequence putStrLn ls (I think)
08:45:08 <jfredett> :t sequence
08:45:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:45:11 <IvdSangen> you mean the projections of a tuple?
08:45:14 <faxlore> also mapM (putStrLn.show)
08:45:21 <jfredett> thats what I meant,
08:45:23 <faxlore> or mapM_ even
08:45:43 <IvdSangen> that works
08:46:10 <jfredett> putStrLn takes a string to IO (), show takes anything to a string (well, anything that instances the Show class
08:46:36 <kib> thanks, that's what I was looking for.
08:46:36 <jedbrown> print does both
08:46:38 <jfredett> then mapM maps things in a monad.
08:46:50 <jfredett> @src print
08:46:50 <lambdabot> print x = putStrLn (show x)
08:47:04 <jfredett> it is putstrln, I thought it was putstr for some reason.
08:47:36 <IvdSangen> putStr does not print a newline at the end
08:47:52 <IvdSangen> they both are prelude functions
08:47:59 <jfredett> yup
08:50:02 <faxlore> what comes after simply types lambda calc?
08:50:31 <jfredett> not-so-simply-typed lambda calc?
08:50:35 <faxlore> heh
08:50:38 <jfredett> maybe dependently typed?
08:51:14 <IvdSangen> algebraic types?
08:51:22 <jfredett> yah
08:56:28 <LoganCapaldo> faxlore: it took me an inordinately long time to google this but: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
08:56:29 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
08:56:52 <faxlore> ahh cool thanks :D
08:58:18 <jfredett> when augustss says something is "simpler, easier" (granted he was borrowing the name of the paper) I typically assume that the I'll need to wait till _after_ i have a masters to fully understand it, :/
08:59:06 <faxlore> I think that is the same person who wrote djinn
08:59:16 <faxlore> which I could not make any sense of :D
09:00:08 <jfredett> me neither, but it is cool as hell
09:00:21 * faxlore thinks that it was ported across a few languages though.. 
09:00:22 <jfredett> @djinn (a -> b) -> (b -> c) -> (a -> c)
09:00:23 <lambdabot> f a b c = b (a c)
09:01:56 <IvdSangen> what does djinn do? find a definition that fits the type?
09:02:16 <jfredett> it "proves" the type is valid
09:02:34 <IvdSangen> according to Curry-Howard?
09:02:41 <jfredett> afaik, it uses the curry-howard isomorphism
09:02:46 <IvdSangen> okay
09:03:00 <jfredett> it finds a function which fits the type
09:03:19 <faxlore> I wrote a very simple version of Djinn
09:03:35 <jfredett> which means that the type sig, as a theorem, is true
09:03:38 <faxlore> it only does ->'s
09:03:42 <jfredett> or something, mostly, its just cool looking
09:03:58 <faxlore> about 30 lines
09:04:08 <jfredett> thats cool
09:04:13 <faxlore> hey how do you get a list of all the data types Djinn does?
09:04:30 <jfredett> you mean though, that it cant do something like:
09:04:32 <IvdSangen> so when I try to write a function having a type djinn can't "prove", I should stop and rethink?
09:04:46 <faxlore> IvdSanger: nah
09:04:47 <jfredett> @djinn (a,b) -> (a->b)
09:04:47 <IvdSangen> or is djinn incomplete?
09:04:47 <lambdabot> f (_, a) _ = a
09:04:58 <faxlore> :t fix
09:05:00 <lambdabot> forall a. (a -> a) -> a
09:05:06 <faxlore> ?djinn (a -> a) -> a
09:05:07 <lambdabot> -- f cannot be realized.
09:05:18 <jfredett> apparently no, :)
09:05:29 <faxlore> haskell is not a logic is it?
09:05:42 <faxlore> I mean you can have functions which do not terminate.. and return undefined
09:05:55 <IvdSangen> no, it's not, but what useful function has type a -> b for instance?
09:06:07 <faxlore> so no worries if it can't be proven , you may stil be able to code it :D
09:06:20 <jfredett> IvdSangen: I'm fairly sure there isn't one, at least not logically
09:06:21 <faxlore> coerce
09:06:31 <jfredett> coerce is extralogical, isn't it?
09:06:39 <IvdSangen> coerce uses unsafePerormIO, doesn;t it?
09:06:43 <jfredett> (i do agree, haskell /= logic)
09:06:52 <jfredett> IvdSangen: yes, i believe
09:06:55 <jfredett> @src coerc
09:06:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:06:56 <IvdSangen> haskell is isomorphioc to a logic
09:06:57 <jfredett> @src coerce
09:06:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:07:12 <IvdSangen> coerce is a class member, iirc
09:07:21 <faxlore> @let globalRef = unsafePerformIO $ newIORef undefined
09:07:21 <lambdabot> <local>:6:12: Not in scope: `unsafePerformIO'  <local>:6:30: Not in scope: `n...
09:07:25 <faxlore> boo
09:07:30 <jfredett> ick,
09:07:42 <jfredett> IO makes me feel dirty
09:07:52 <faxlore> coerce e = unsafePerformIO $ do writeIORef globalRef e
09:07:52 <faxlore>                                 readIORef globalRef
09:08:05 <jfredett> to much computer in the IO world, not enough math.
09:08:16 <faxlore> it has type a -> b
09:08:37 <IvdSangen> yes, but using unsafePerformIO is 'cheating'
09:08:47 <jfredett> right, but using unsafePerformIO makes it extralogical
09:09:04 * faxlore thinks that.. it is not cheating
09:09:16 <ndm> @seen Igloo
09:09:16 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 21h 21m 20s ago.
09:09:22 <jfredett> unsafePerformIO is _definitely_ cheating,
09:09:22 <IvdSangen> true, the subset of haskell not using unsafePerformIO does not have useful functions of type a -> b
09:10:07 <faxlore> yea haskell is simply typed calculus with some extensions (which?), so a subset of it is a consistent logic
09:10:41 <jfredett> faxlore: correcto
09:11:04 <faxlore> I guess there algebraic types, let polymorphism, typeclasses.. ?
09:11:08 <faxlore> as extentions
09:11:22 <jfredett> although, polymorphism, typeclasses, algebraic types, thats mostly okay
09:11:46 <jfredett> I think things like C bindings, IO monad, etc, is either extralogical or damn close
09:11:47 <Igloo> ndm: Yo yo!
09:12:09 <IvdSangen> does it still correspodn to a (consistent) logic?
09:12:38 <IvdSangen> IO monad shouldn't "screw things up"
09:12:48 <jfredett> as long as you don't use the stuff like a->b, etc (unsafePerformIO, etc.)
09:12:54 <jfredett> then I think its consistent
09:13:07 * Heffalump imagines Igloo and ndm spinning, attached to a long string
09:13:25 <jfredett> I meant that some of the IO functions associated w/ the IO monad are consistency breakers
09:14:17 <ndm> Igloo: am about to do the filepath changes you want - they may be breaking changes for some apps though - should I just blindly ignore that?
09:14:18 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
09:14:21 <ndm> @messages
09:14:21 <lambdabot> TomMD asked 19h 16m 32s ago: Catch on hackage isn't updated to work with the package split and on darcs isn't cabalized. If I were to write a patch 1) which code base should be the base? 2) Would
09:14:21 <lambdabot> you accept it?
09:15:06 <ndm> TomMD: it also isn't updated to work with the latest Yhc file format, so getting catch working would be a bit of a challenge - I've recently cabal'ised Yhc.Core, so will get to Catch soon enough
09:15:09 <Igloo> ndm: I don't think there's anything else you can do
09:15:26 <ndm> TomMD: i'm also cabalising the firstification code, as we speak, so would recommend ignoring catch for a couple of weeks :)
09:16:33 <ndm> Igloo: fair enough, straight into the darcs.haskell.org/packages/filepath repo?
09:18:07 <ndm> TomMD: the darcs one is cabalised, but i have a script that generates the cabal file for me - its somewhere in there
09:18:25 <ndm> TomMD: it does a pull in of all Yhc.Core libraries as well, since it was from before i cabalised that
09:20:04 <dcoutts_> Igloo: why should "." </> "foo" = "foo"? I fully understand normalise "." = "." but not the next one
09:20:33 <dcoutts_> Igloo: I'm not convinced about your principle of preserving normalisation
09:20:45 <dcoutts_> especially for </> itself
09:21:42 <allbery_b> hm?  '.' means "current directory"; "foo" with no prefix means "search starting in current directory", hence "./foo" == "foo"
09:21:46 <Igloo> dcoutts_: For example, if one is writing a Haskell compiler and has an odir and an ofilename, and wants to show the user the path, then one wants to show "Foo.o" rather than "./Foo.o"  :-)
09:21:47 <allbery_b> (assuming POSIX)
09:21:58 <dcoutts_> Igloo: then normalise it
09:22:16 <Igloo> dcoutts_: Why do you think </> shouldn't preserve normalisedness?
09:22:18 <dcoutts_> Igloo: normalise just before calling out to external progs or the user
09:22:45 <ndm> i'm not convinced that </> should preserve normalisation
09:22:54 <ndm> i think it should be as close to ++ "/" ++ as it can be
09:23:03 <ndm> i.e. the user builds up paths, then they get those paths
09:23:05 <dcoutts_> Igloo: doesn't </> preserve it already anyway?
09:23:19 <fourbissime> okay, this maybe a silly question, but ... I'm coding this program - the conception is pretty much done, I know how to solve my problem. But I don't know how to properly organize my sources. My first try is turning to a cycling imports hell. Is there some kind of old wisdom on this source organization matter ?
09:23:33 <Igloo> dcoutts_: Only because it thinks the current directory is ""
09:24:06 <dcoutts_> Igloo: remind me of the definition of normalised
09:24:09 <Igloo> dcoutts_: Which breaks various C functions, and doesn't display how I would expect when shown to the user
09:24:48 <Igloo> dcoutts_: The output of System.FilePath.normalise. I'm not sure exactly what that means OTTOMH
09:25:11 <dcoutts_> Igloo: if we can't define it how can we expect to preserve it ;-)
09:25:33 <dcoutts_> Igloo: ok, so normalise removes "redundant" ../'s and anything else?
09:25:56 <dcoutts_> Igloo: the crucial Q is whether we make things explicitly or implicitly relative to "."
09:26:17 <dcoutts_> ie normalise "./foo" = "foo" or = "./foo"
09:26:21 <Igloo> It removes ./'s too, and "." normalises to ""
09:26:30 <dcoutts_> with the one exception of "." itself which has to remain "."
09:26:46 <dcoutts_> "." normalising to "" must be a bug
09:26:57 <dcoutts_> when is that ever what one wants?
09:27:09 <Igloo> Prelude System.FilePath> map normalise [".", "./foo"]
09:27:09 <Igloo> ["","foo"]
09:27:10 <ndm> dcoutts_: i definately agree that "." -> "" is a bug
09:27:15 <dcoutts_> as far as I can see in this whole thing, that's the only bug
09:27:16 <Igloo> That's the current behaviour
09:27:41 <dcoutts_> Igloo: right, and imho it should be ["." , "foo"]
09:27:47 <Igloo> Right
09:27:55 <monochrom> fourbissime: If you can't re-group the modules, try http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
09:27:55 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
09:27:57 <ndm> agreed, will fix that one right now :)
09:28:00 <dcoutts_> but that means we just have one special case
09:28:15 <Igloo> And IMO    normalise x </> normalise y    should be    normalise (x </> y)
09:28:27 <dcoutts_> Igloo: and I don't agree with the other two changes you propose, or rather I need persuading
09:29:19 <Igloo> dcoutts_: One of those is that splitting off a directory should give "." rather than "", right?
09:29:25 <ndm> i'm not convinced that normalise should distribute
09:29:48 <doserj> I don't think it can, given the edge-case of normalize "." = "."
09:29:50 <ndm> filepaths should be built by users at a  low level, then they can choose to normalise
09:29:52 <dcoutts_> Igloo: you mean split "foo" should give (".", "foo")
09:30:09 <Igloo> dcoutts_: Right. You disagree with that?
09:30:25 <dcoutts_> Igloo: not sure
09:30:34 <ndm> me neither
09:30:48 <dcoutts_> I'm not upset with the current result of ("", "foo")
09:30:48 <ndm> if you can give a very convincing argument?
09:30:50 <Igloo> dcoutts_: If you    doesDirectoryExist    the directory you get, then you get False or an error or something if the result is ""
09:31:09 <dcoutts_> that's a good point
09:33:11 <dcoutts_> Igloo: so then what about  splitDirectories "foo" vs splitDirectories "./foo" ?
09:33:24 <dcoutts_> > System.FilePath.splitDirectories "foo"
09:33:25 <lambdabot>   Not in scope: `System.FilePath.splitDirectories'
09:33:27 <dcoutts_> bah
09:33:39 <dcoutts_> it's ["foo"] vs [".","foo"]
09:33:39 <Igloo> Prelude System.FilePath Directory> splitDirectories "foo"
09:33:39 <Igloo> ["foo"]
09:33:39 <Igloo> Prelude System.FilePath Directory> splitDirectories "./foo"
09:33:39 <Igloo> [".","foo"]
09:33:43 <dcoutts_> right
09:34:02 <dcoutts_> Igloo: if we could define what we mean by normalised it'd help a lot I think :-)
09:34:05 <Igloo> That's fine with me. "./foo" isn't normalised, so I don't mind getting that result
09:34:32 <Igloo> The definition is in the code (modulo the "." bug)
09:35:14 <ndm> i'm pretty sure "." </> "foo" giving "foo" would hurt people
09:35:24 <Igloo> ndm: Can you give an example?
09:35:29 <ndm> i am sure there are places in windows where "./foo" and "foo" give different behaviour
09:35:43 <Igloo> ndm: And if you are right, then those people had better be careful not to normalise their results!
09:35:46 <ndm> Igloo: not off the top of my head, but i'm nearly certain
09:35:57 <ndm> Igloo: indeed, but at least they can make that choice
09:36:05 <ndm> normalise is designed for showing filepath's, nothing more
09:36:09 <dcoutts_> Igloo: why are you asking for "." </> "foo" = "foo" since you agree the input is not normalised?
09:36:30 <Igloo> dcoutts_: I think the input is normalised
09:36:31 <dcoutts_> or because of the special exception that "." is normalised
09:37:07 <hpaste>  sizur annotated "Sum" with "(no title)" at http://hpaste.org/4968#a1
09:37:28 <dcoutts_> ndm: are there? doesn't ./foo and foo refer to the foo in the current dir of the current drive?
09:38:00 <ndm> dcoutts_: yes, they both do, but i am fairly certain i've been in a situation where ./foo worked and foo didn't
09:38:18 * ndm pushes: normalise "." == "."
09:38:20 <allbery_b> only in special cases
09:38:20 <dcoutts_> ndm: with some dodgy windows software or with some MS api?
09:38:41 <ndm> dcoutts_: can't remember, will rack my brains
09:39:01 <ndm> i'm happy enough with split "foo" = (".","foo") - its not the way I would have done it, but it seems a sensible enough choice
09:39:12 <ndm> "." </> "foo" is something i'm  more suspicous about
09:39:21 <dcoutts_> ndm: me too
09:39:23 <allbery_b> many unix shells treat ". foo" differently from ". ./foo"; cpp treats `#include "foo"' differently from `#include "./foo"'
09:39:38 <resiak> surely if you're going to use the path to exec something, "./foo" is distinct from "foo" on posix (when you don't have . in PATH)?
09:40:02 <allbery_b> these are explicit special cases where unanchored names trigger path searches
09:40:07 <dcoutts_> allbery_b: aye, because they are not treating the files relative to the current dir, but relative to a search path
09:40:10 <allbery_b> (likewise resiak's case)
09:40:20 <ndm> ok, well CPP saying that makes me definately think that we can't do automatic normalisatio
09:40:26 <resiak> Igloo: are you arguing that, in that case, you shouldn't be normalizing foo in the first place?
09:40:36 <allbery_b> right, I'm saying they're special cases.  the normal case doesn't do this
09:40:40 <Igloo> ndm: That also means that   case split p of (x, y) -> x </> y    is not the identity
09:40:51 <Igloo> resiak: Yes
09:40:57 <allbery_b> and those special cases do require no normalization
09:41:11 <Igloo> resiak: You aren't really using FilePaths in that case
09:41:25 <resiak> mm
09:42:04 <ndm> i get the sneaking suspicion that normalising will break things and lead to unintuative behaviour, but if you convince everyone else, i'll go along
09:42:14 <dcoutts_> Igloo: so what are the two ghc bugs caused by your filepath complaints, or rather what fixes are required, any more than just normalise "." = "." ?
09:42:32 <ndm> Igloo: i can get over that, its a nice property, but not essential - its more important that normalise (x </> y) == normalise p
09:42:37 <ndm> i.e. equal with respect to normalisation
09:43:38 <Igloo> dcoutts_: If the current directory is now "." then I think the only problems are output, which we /could/ fix by calling normalise
09:44:28 <dcoutts_> Igloo: and those are only "cosmetic" problems right?
09:44:45 <Igloo> dcoutts_: Yup
09:45:21 <ndm> Igloo: i would recommend calling normalise before ever displaying a filepath to the user - the current directory makes that as an assumption
09:45:31 <dcoutts_> Igloo: what do you mean exactly about the current dir now being "."? is there a currentDirectory = "." / "" value somewhere that's changed?
09:46:01 <Igloo> dcoutts_: I mean the directory returned by functions like split "foo"
09:46:09 <dcoutts_> Igloo: ah right
09:46:33 <dcoutts_> so that'd mean changing takeDirectory etc
09:46:50 <Igloo> Right (although that's defined in terms of split anyway, I think)
09:47:03 <dcoutts_> 'k
09:47:08 <ndm> Igloo: the important thing is getting the properties right, the code really writes itself after that :)
09:47:37 <Igloo> ndm: Well, you disagree with all my lovely properties  :-)
09:47:40 <ndm> of course, if anyone ever profiles filepath, and finds it to ever be a bottleneck, i can massively optimise those functions
09:48:17 <ndm> i think moving to your properties is moving up in the abstraction level, from what we currently have
09:48:32 <ndm> whether that is the right thing to do, or not, is still something i'm not sure about
09:48:32 * LoganCapaldo is sitting here quietly having daymares about vms file paths
09:49:31 <ndm> Igloo: what do you want to call splitSearchPath that takes an extra parameter? splitSearchPathWith?
09:49:41 <Igloo> ndm: I think my properties currently hold for currentiDirectory = "", but presumably by accident
09:50:11 <ndm> yep, more a coincidence
09:50:34 <Igloo> ndm: Can you remind me what the extra parameter is? Is it extra values if the last character is a separator?
09:50:44 <ndm> Igloo: yep
09:52:10 <Igloo> I think splitSearchPathSystem would be better, but I don't really mind
09:52:18 <BMeph> dcoutts_: Remind me again, what's the name of the file that cabal uses when you get an update?
09:53:19 <ndm> Igloo: its entirely up to you, in this case :)
09:53:23 <dcoutts_> BMeph: you're on windows, so it'll be under your user profile in a hidden dir for app data
09:53:35 <dcoutts_> BMeph: in that dir it'll be in cabal/packages/hackage.haskell.org/00-index.tar.gz
09:54:10 <BMeph> Yummy - thanks! :)
09:54:24 <dcoutts_> BMeph: did you upgrade to the latest cabal-install?
09:54:48 <dcoutts_> as you recall, the current version on hackage has lots of problems on windows
09:55:55 <BMeph> cabal-install version 0.4.1 / using version 1.3.2 of the Cabal library
09:56:26 <dcoutts_> BMeph: ok
09:57:56 <BMeph> Hm, I found a tar file of size zero. Let's see what happens when it's deleted...
09:58:07 <C-Keen> hm, in the 6.8.x dist directories, there isn't a testsuite tarball anymore. Did the testsuite get moved?
09:58:21 <BMeph> WTHeck?!? Now I have a different error:
09:58:23 <BMeph> "cabal: user error (RegQueryValue: The system cannot find the file specified."
10:01:58 <Igloo> C-Keen: I haven't made one for 6.8.2 yet
10:03:03 <C-Keen> Igloo: oh ok
10:04:31 <C-Keen> Igloo: I will try 6.8.2 w/o
10:10:16 <dcoutts_> BMeph: ah, RegQueryValue eh? so that's looking in the registry for a proxy server setting
10:10:34 <dcoutts_> BMeph: but we should not fail if that key does not exist and just use no proxy.
10:11:10 <dcoutts_> BMeph: actually, would you mind checking if we have the right registry location for proxy server setting on windows
10:12:09 <dcoutts_> BMeph: we currently look in HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\
10:12:37 <dcoutts_> ndm: as a windows dev, any comment on using that key to find "the" http proxy server?
10:13:05 <dcoutts_> it seems to be the one that IE uses, but I dunno if it's sufficiently standard
10:13:54 <Lycurgus> ping: Eden group member
10:15:48 <lightstep> i have some trouble with mixing two different monads
10:16:05 <LoganCapaldo> don't cross the streams!
10:16:29 <lightstep> oh, they're both implemented in existing libraries
10:16:37 <LoganCapaldo> i kid
10:16:41 <lightstep> :)
10:16:42 <ndm> dcoutts_: sounds dangerous.. not sure what the standard is at all
10:16:43 <bench1> is there a haskell module called 'and'?
10:16:54 <LoganCapaldo> there's a function called and
10:16:58 <LoganCapaldo> @type and
10:17:00 <lambdabot> [Bool] -> Bool
10:17:04 <ndm> dcoutts: can't you call out to the windows file access functions?
10:17:33 <lightstep> anyway, my program runs in StateT MyState IO, and i'm trying to render stuff in Draw (the drawing monad of HGL)
10:17:39 <dcoutts_> ndm: file access? what would we want to do that for?
10:18:02 <bench1> i'm getting a complain from Searchpath 'could not find module 'and''
10:18:04 <ndm> dcoutts: i mean something like the download functions, i think there are a few in windows
10:18:13 <lightstep> so, i have a function getPosition :: StateT MyState IO Point, and i want to use the position in the drawing code
10:18:21 <dcoutts_> ndm: oh, using the MS http library you mean?
10:18:26 <ndm> dcoutts_: yep
10:18:40 <dcoutts_> ndm: we have no bindings for those, we use the haskell HTTP package
10:18:48 <lightstep> the drawing code has loops and many complications, so i don't want to extract all the information and pass it there
10:19:02 <ndm> some proxy servers have things like javascript utilities that say where to direct different traffic - that would be awfully hard to replicate
10:19:11 <lightstep> is there some trick? i only need to read the state, not update it or use IO
10:19:36 <dcoutts_> ndm: I'm not sure we can rely on the ms http dll to exist since it's bundled with IE iirc not windows
10:19:55 <ndm> dcoutts: but IE is bundled with Windows and can't be uninstalled, so is fairly safe to use
10:19:57 <dcoutts_> ndm: I remember when working at Sophos we had to use our own http lib not the MS one
10:20:08 <ndm> hmm, perhaps
10:20:15 <dcoutts_> and it seemed to cope with proxies ok
10:20:30 <ndm> but ifi you can't rely on the IE one, using IE's registry keys to set up the proxy server seems more dodgy
10:21:32 <ndm> dcoutts_: and now your opinions as a windows dev ;) - should "c:foo" be a relative or an absolute path?
10:21:54 * SamB thinks that's relative...
10:21:57 <dcoutts_> ndm: it's relative to the current dir of the c drive
10:22:18 <dcoutts_> it's a partially specified relative file
10:22:38 <ndm> dcoutts: i.e. should isRelative return true or false?
10:22:47 <dcoutts_> ndm: it should return True
10:23:22 <LoganCapaldo> lightstep: you can runStateT your getPosition and use ioToDraw maybe
10:23:31 <LoganCapaldo> I've never actually used HGL myself
10:23:50 <LoganCapaldo> but it looks like you've choosen an unfortunate combination to me
10:23:57 <lightstep> it's the closest thing i found to ocaml's Graphics library
10:24:02 * ndm pushes splitSearchPathSystem, for Igloo
10:24:13 <Igloo> ndm: Thanks!
10:24:26 <LoganCapaldo> it would probbaly work better if you can rework it to StateT MyState Draw
10:24:52 <ndm> dcoutts: what about "c:/" </> "c:foo", what should that give?
10:25:34 <dcoutts_> ndm: "c:/foo", the harder Q is what about "c:/" </> "d:foo"
10:25:45 <mauke> headaches
10:26:12 <ndm> dcoutts: i have absolutely no idea!
10:26:24 <ndm> and on the last issue, is "c:" relative?
10:26:28 <SamB> ndm: you can't really interpret "c:foo" relative to a single path, afaict...
10:26:39 <dcoutts_> ndm: I think it's also "c:/foo"
10:26:43 <lightstep> LoganCapaldo, thanks, it works
10:26:55 <LoganCapaldo> oh good :)
10:27:00 <ndm> dcoutts_: i disagree, i'd say its d:foo
10:27:32 <lightstep> actually, it works in my head, but GHC complains of kind errors. i'll probably convince it in a few minutes
10:27:39 <dcoutts_> ndm: no, can't be, "c:/bar/baz/" </> "d:foo" = ??
10:28:05 <ndm> dcoutts_: "d:foo", i can't think of any other sensible interpretation
10:28:12 <dcoutts_> ndm: you're saying it'd be "c:/bar/baz/" </> "d:foo" = "d:foo" ?
10:28:17 <ndm> yep
10:28:25 <ndm> "c:/bar/baz/" </> "d:/foo" = "d:/foo" ?
10:28:49 <ndm> that already holds, so now it seems silly that you can change the drive in one, but not the other
10:28:57 <dcoutts_> ndm: I'm thinking that "c:foo" means an ordinary relative file like "./foo" but with some extra info that it's the current dir on a different drive we're talking about
10:29:01 <SamB> what laws does </> need?
10:29:33 <ndm> dcoutts: what about "foo" </> "d:bar" ?
10:30:06 <SamB> does it need x </> (y </> z) = (x </> y) </> z
10:30:16 <ndm> SamB: it doesn't need any laws
10:30:25 <dcoutts_> ndm: ah, interesting, that'd be "d:foo/bar" :-)
10:31:21 <ndm> dcoutts: for the moment, is "c:" relative or not?
10:31:55 <SamB> it's relative to the working directory for drive C
10:32:16 <Igloo> I think it is, ndm
10:32:20 <dcoutts_> ndm: it's relative
10:32:25 <dcoutts_> ndm: as SamB says
10:32:38 <dcoutts_> it's a more refined version of "."
10:32:46 <Igloo> I think c:<foo> should behave like <foo>, except when composed with something on a different drive
10:32:48 <ndm> yeah, ok
10:33:02 <dcoutts_> ndm: is c:. a valid path on win32? like "" vs "." ?
10:33:03 <ndm> so, we have agreement that "c:", "c:foo" are both relative
10:33:23 <ndm> dcoutts_: there is no chance i am going to open that can of worms! probably in some places, and not in others
10:33:26 <dcoutts_> ndm: c:foo ~= c:./foo isn't it?
10:33:44 <ndm> dcoutts: yes, in most places
10:33:49 <dcoutts_> ndm: ok
10:33:54 <SamB> what do you mean "most places"?
10:34:18 <dcoutts_> ndm: it'd be worth checking what other language/libs say about it, eg java, .net, python
10:35:15 <ndm> SamB: i mean its a bit of a crapshoot in general, one you start using c:foo
10:35:32 <SamB> yeah...
10:35:45 <ndm> what about \\foo
10:35:47 * SamB bets they punt and say "don't use nasty paths like that"
10:35:48 <ndm> is that relative or absolute?
10:35:59 <SamB> \\foo is probably illegal
10:36:01 <mauke> absolute, says File::Spec
10:36:04 <SamB> \\foo\bar is okay though
10:36:30 <dcoutts_> right, \\foo is just a host without any share name
10:38:01 <ndm> my guess is that its absolute, probably
10:38:17 <SamB> \\foo\bar is definately absolute, yes
10:39:09 <mauke> perl -mFile::Spec::Win32 -wnle 'print +("relative", "absolute", "absolute with volume")[File::Spec::Win32->file_name_is_absolute($_)]'  :-)
10:43:35 <hpaste>  ramza3 pasted "Trying to figure own to iterate N times to load data" at http://hpaste.org/4973
10:44:30 <ramza3> http://hpaste.org/4973  ...does anyone see what I am doing here, should I use replicate to build a list, called N times; I couldnt figure out the syntax though
10:46:23 <hpaste>  LoganCapaldo annotated "Trying to figure own to iterate N times to load data" with "(no title)" at http://hpaste.org/4973#a1
10:47:45 <ramza3> LoganCapaldo, would replicate work, or is that just a wrong approach
10:48:02 <LoganCapaldo> replicate would work
10:48:19 <LoganCapaldo> you could something like sequence $ replicate len get
10:48:32 <LoganCapaldo> @type sequence
10:48:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:48:43 <LoganCapaldo> @type replicate
10:48:44 <mauke> :t replicateM
10:48:44 <lambdabot> forall a. Int -> a -> [a]
10:48:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:48:54 <LoganCapaldo> mauke wins :)
10:49:03 <mauke> FATALITY
10:49:21 <LoganCapaldo> replicateM len get for sure! :)
10:50:08 <LoganCapaldo> monads are so hawt
10:53:01 <monochrom> <3 monads
10:55:33 <LoganCapaldo> ramza3: re; replicate working what I wrote was basically just a dumb way of writing replicateM :)
10:55:45 <LoganCapaldo> So you were mor eon top of it than I was
10:55:56 <LoganCapaldo> my imperative was showing <g>
10:56:49 <sarah__> why doess this give parse error? replaceList e l i = [if a == i then e else b !! x | x <- [0..(length l)]]
10:57:15 <ndm> sarah__: i can't see, what is the error message?
10:57:16 <sarah__> oh woups saw used b instead of l :)
10:57:21 <hpaste>  ramza3 annotated "Trying to figure own to iterate N times to load data" with "Wish I were competent" at http://hpaste.org/4973#a2
10:57:32 <ramza3> ah, LoganCapaldo (hehe, not really), another question; how would I change it to call the Get monad against the other type (QueueObject). ... I am kind of slow
10:57:33 <ndm> sarah__: that should be a type error, rather than a parse error
10:57:42 <monochrom> was going to ask who is b...
10:57:52 <allbery_b> if it's a parse error I would guess the if is slurping too much
10:58:17 <allbery_b> [(if a == i then e else l !! x) | x <- [0..length l]]
10:58:25 <sarah__> nope still fails,  parse error on input `replaceList'
10:58:40 <mauke> that indicates problems with the context
10:58:43 <hpaste>  LoganCapaldo annotated "Trying to figure own to iterate N times to load data" with "this wshould work, like you had before" at http://hpaste.org/4973#a3
10:58:56 <allbery_b> ghci?  you need to use let, or put it in a file
10:59:37 <sarah__> mauke: oh i see ty
11:00:04 <ramza3> LoganCapaldo, nice, I am still all imperative, I am working on it though
11:00:18 <mauke> sarah__: also, you want length l - 1
11:00:24 <hpaste>  LoganCapaldo annotated "Trying to figure own to iterate N times to load data" with "this I think is closer in spirit to what you wanted to do (use replicate)" at http://hpaste.org/4973#a4
11:01:18 <ramza3> LoganCapaldo, gracias
11:01:31 <ndm> its a very common function, I tend to call it "l \!! (i,e)"
11:01:49 <ndm> sarah__: plus its much easier to write as a zipWith
11:01:58 <hpaste>  sizur annotated "Sum" with "Num a => Sum a" at http://hpaste.org/4968#a2
11:02:07 <ndm> plus its runs in O(n) rather than O(n^2)
11:02:46 <Sizu1> any ideas on how to get type inference back into the picture?
11:05:11 <LoganCapaldo> Sizu1: you're mad you know? :)
11:06:02 <sarah__> ndm: ah! never used zipWith, how would you do that
11:06:12 <ndm> sarah__: have you used zip?
11:06:17 <ndm> @type zipWith
11:06:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:06:20 <sarah__> not yet
11:06:28 <ndm> zip is easy enough:
11:06:34 <ndm> > zip "neil" "test"
11:06:35 <lambdabot>  [('n','t'),('e','e'),('i','s'),('l','t')]
11:06:43 <sarah__> ah ok
11:06:47 <ndm> > zip "neil" [0..]
11:06:48 <lambdabot>  [('n',0),('e',1),('i',2),('l',3)]
11:06:49 <mauke> > zip "elements" [0 ..]
11:06:50 <lambdabot>  [('e',0),('l',1),('e',2),('m',3),('e',4),('n',5),('t',6),('s',7)]
11:07:09 <ndm> zip uses a tuple to combine things, so by default:
11:07:19 <sarah__> zipWith "elements" [0 ..]
11:07:20 <ndm> > zipWith (\a b -> (a,b)) "neil" [0..]
11:07:21 <lambdabot>  [('n',0),('e',1),('i',2),('l',3)]
11:07:35 <ndm> and that combining function can be an if, to get what you want
11:07:37 <pjd> > zipWith (,) "neil" [0..]
11:07:37 <lambdabot>  [('n',0),('e',1),('i',2),('l',3)]
11:07:41 <mauke> zipWith is map2
11:08:16 <LoganCapaldo> again with the zipWith is map map is zipWith nonsense <g>
11:08:41 <sarah__> ndm: thx
11:09:00 <LoganCapaldo> i swear one day you guys are gonna boil down all of haskell to one function and it's gonna be spelled (.)
11:09:18 <LoganCapaldo> code'll look like braille
11:09:33 <mauke> :t flip zipWith [0 ..] . const
11:09:34 <lambdabot> forall b c. (b -> c) -> [b] -> [c]
11:09:38 <mauke> map!
11:09:46 <sarah__> lol
11:10:10 <Saizan> LoganCapaldo: there's no harm in recognizing connections :)
11:11:15 <gwern> is there any shorter way to write '| ks == xK_Delete || ks == xK_d'? my brain fails me
11:11:32 <mauke> ks `elem` [xK_Delete, xK_d]
11:11:55 <mauke> any (ks ==) [xK_Delete, xK_d]
11:11:56 <TomMD> LoganCapaldo: Lambdabot does still work, it does still tell me that I have no messages at the proper times ;-)
11:12:06 <LoganCapaldo> :)
11:12:13 <ndm> TomMD: thanks for your offer to do catch things
11:12:22 <ndm> TomMD: were you hoping to use Catch on something?
11:12:49 <TomMD> My pleasure.  Yes, I have plans to use Catch to help with some production code - though I am concerned about the effort needed to setup YHC with the proper libraries.
11:13:15 <gwern> mauke: heh. your elem version is like two chars shorter
11:13:32 <ndm> TomMD: me too, which is why i've been writing Multicore, which will allow the use of GHC as a front end
11:13:38 <dons> interesting, http://www.brandonwerner.com/2008/01/13/the-rise-of-functional-programming-fscalahaskell-and-the-fai
11:13:40 <lambdabot> Title: Brandon Werner &#187; Blog Archive  The Rise Of Functional Programming: F#/Scal ..., http://tinyurl.com/35ulpf
11:13:42 <dons> ling-of-lisp/
11:13:52 <LoganCapaldo> it's not importanty that it actually is shorter, just that it reads shorter :)
11:14:12 <TomMD> ndm: Multicore is still in one of your personal repos?
11:14:36 <ndm> TomMD: i have no personal repos :) http://www.cs.york.ac.uk/fp/darcs/multicore
11:14:37 <lambdabot> Title: Index of /fp/darcs/multicore
11:14:59 <ndm> TomMD: but it doesn't work yet, i haven't finished all the translation bits, but once i have, you'll be able to just use GHC and create Yhc.Core that way
11:14:59 <Tac-Tics> I'm trying to build Regex-posix 0.72, and I'm getting an error  "Could not find module `Data.Array': it is a member of package array-0.1.0.0, which is hidden"... but when I go into ghci, I can import data.array just fine. Does anyone have any ideas what I'm doing wrong?
11:15:00 <TomMD> ndm: What is needed to make this a reality?
11:15:05 <gwern> LoganCapaldo: I was trying to avoid reindenting everything so actually being shorter was importanty
11:15:11 <ndm> TomMD: time, its quite close to being done
11:15:13 <dons> ?users
11:15:13 <lambdabot> Maximum users seen in #haskell: 444, currently: 435 (98.0%), active: 17 (3.9%)
11:15:15 <LoganCapaldo> ah
11:15:18 <gwern> Tac-Tics: did you get that from hackage?
11:15:23 <Tac-Tics> yes
11:15:27 <allbery_b> Tac-Tics: edit the cabal file to add the array package as a dependency
11:15:37 <allbery_b> (it was split out in 6.8)
11:15:39 <gwern> gah! I thought the regex packages had been updated >.<
11:15:47 * gwern adds them to the list :(
11:15:49 <ndm> TomMD: i'm redoing the firstification stuff in Catch at the moment, that should be on hackage at some point soon, then i'll just need to finish multicore, and hack Catch for a couple of days, and it should be all good
11:15:59 <LoganCapaldo> hmm
11:16:03 <gwern> Tac-Tics: did regex-base work without any changes?
11:16:27 <sjanssen> Tac-Tics, gwern: try a slightly newer version of regex
11:16:39 <dons> there we go, http://programming.reddit.com/info/65dft/comments/
11:16:47 <Tac-Tics> I've actually tried 0.7.*
11:17:22 <Tac-Tics> so, the problem is Cabal doesn't find packages correctly unless you label them as deps?
11:17:22 <dons> Tac-Tics: do you need regex-posix for something?
11:17:33 <sjanssen> Tac-Tics: you want 0.72.0.1
11:17:36 <dons> there's something broken about the regex-* versions
11:17:44 <TomMD> ndm: So is there something I can do to help? Other than be a cheering squad ;-)
11:17:45 <LoganCapaldo> @type let (<||>) a b = \x -> a == x || b == x in (?xK_Delete <||> ?xK_d) ?ks
11:17:46 <lambdabot> (?xK_Delete::Integer, ?xK_d::Integer, ?ks::Integer) => Bool
11:17:48 <gwern> isn't regex-posix at 0.93.1 right now?
11:17:51 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-posix-0.93.1
11:17:52 <lambdabot> http://tinyurl.com/2moby7
11:17:53 <dons> i've, regex-base-0.72.0.1, regex-compat-0.71, regex-posix-0.72.0.2
11:17:56 <sjanssen> Tac-Tics: all the four component versions work correctly
11:18:01 <dons> but recommend pcre-light :)
11:18:08 <Tac-Tics> four component version?
11:18:17 <sjanssen> w.x.y.z
11:18:21 <Tac-Tics> ah
11:18:35 * dons grumbles about broken regex-* bloatware :(
11:18:53 <LoganCapaldo> regex land in haskell is bizzare
11:19:05 <LoganCapaldo> someone needs to get in there with a scalpel
11:19:06 <ndm> TomMD: not really, but the cheerleading (or prospective user) do help :)
11:19:11 <dons> LoganCapaldo: done!
11:19:19 <LoganCapaldo> really?
11:19:23 <dons> enjoy, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light-0.1
11:19:24 <lambdabot> http://tinyurl.com/3aro3x
11:19:37 <Tac-Tics> I've never used regexes in haskell, what's with them that makes them so hard to install?
11:19:47 <LoganCapaldo> dons: another regex lib?
11:19:55 <LoganCapaldo> is it now the only one :)
11:19:58 <Tac-Tics> It seems like Regexes is something that Haskell should totally blow away
11:20:01 <sjanssen> Tac-Tics: a maintainer that isn't keeping up
11:20:01 <dons> LoganCapaldo: 1 standalone, small binding to pcre. all others are not required now.
11:20:04 <Tac-Tics> ah
11:20:24 <LoganCapaldo> lets convince them to delete all the others from hackage <g>
11:20:24 <dons> also, the regex-* libs (6 of them!) are too big, and use too many extensions
11:20:27 <allbery_b> same thing that makes every package hard to install:  new ghc/new base/new cabal/new packages needed to support it all
11:20:41 <dons> well, the code could be more portable to start with
11:20:51 <dons> but its also too complex an api for a core library
11:21:40 <dons> i'm not going to use the regex-* packages anymore, fwiw.
11:22:50 <Feuerbach> Which haskell tutorial would you recommend for the lecture course?
11:22:58 <TomMD> YAHT
11:24:10 <dons> sjanssen: currently, we have, compile :: S.ByteString -> [PCREOption] -> Either String Regex , but I'm considering having it throw an exception on invalid regexes, since they're so rare.
11:24:16 <dons> what do you think?
11:24:23 <dcoutts_> seems sensible to me
11:24:29 <dons> every time i use it, i have to:   either error id (compile ..)
11:24:31 <dons> which is tedious
11:24:40 <dons> since i know the regex is fine
11:24:54 <dons> and those cases where the regex is possibly invalid, can be catch/handled
11:24:59 <sjanssen> dons: you should at least provide both
11:25:01 <gwern> inferred types always amuse me. Like, what's up with 'Inferred type: bsd3 :: [Char] -> [Char] -> String'?
11:25:04 <ndm> dons: agreed, seems much more sensible
11:25:08 <LoganCapaldo> dons: is there a chance you can keep the either version around? I envision wanting to use user supplied regexs, and catching errors scares me
11:25:24 <ndm> although of course, have the "With" variant or some such
11:25:29 <sjanssen> dons: because it is reasonable for the user to want to catch the exception in pure code
11:25:32 <dons> right
11:25:40 <dons> so what's a good way to provide both?
11:25:57 <judahj> If I'm using a foreign C function that takes a (File *) as input, what's the best way to pass a Handle to it?  I don't see any methods to convert a CFile to an Fd or Handle in the standard libs.
11:26:11 <dons> handleToFd is in the unix lib
11:26:24 <dons> and fdToHandle too, iirc
11:26:58 <judahj> But is an Fd the same as C's (FILE *) ?
11:27:13 <allbery_b> no, you need to call fdopen() on it in C
11:27:24 <allbery_b> (it's a unix file descriptor, an int)
11:27:28 <thetallguy> dons: I don't suppose there's a way to arrange for compile time validation of constant regex's?
11:27:29 <LoganCapaldo> compile and tryCompile where compile = either error id tryCompile ?
11:27:30 <ddarius> tryCompile and compile?
11:27:36 <LoganCapaldo> lol
11:27:45 * LoganCapaldo high fives ddarius 
11:27:54 <ddarius> Obviously tryCompile is the intuitive name.
11:28:21 <allbery_b> compile :: Monad m => S.ByteString -> [PCREOption] -> m Regex, default case use the evil fromJust?
11:28:43 <ndm> dcoutts, Igloo: http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html that says that "a::b" in $PATH should be treated as "a:.:b", i.e. having a blank path anywhere should give current directory as in the path
11:28:45 <lambdabot> Title: Environment Variables, http://tinyurl.com/2mdtbr
11:28:48 <judahj> allbery_b: Hmm...is there any reason why fdopen isn't provided in the standard libraries?
11:29:15 <allbery_b> which?  haskell's?  haskell provides its own I/O system, independent of C's stdio
11:29:18 <ndm> dcoutts, Igloo: that's entire a Posix thing, so i don't have the slightest idea if we should follow that or ignore it
11:29:21 <dcoutts_> ndm: search paths are a strange wart that are somewhat related to filepaths
11:30:11 <dons> thetallguy: seems like a research paper :)
11:31:02 <thetallguy> dons: Yeah, okay
11:31:18 <thetallguy> dons: I'll see if I can't sneak it int an experience report...
11:31:33 <ndm> dcoutts_: if you had to pick one side of the fence, which one would it be?
11:31:56 <thetallguy> dons: seriously, at Linspire it was really valuable to know about silly errors like that at compile time.  Saved  lot of turn-around time.
11:32:12 <dons> i bet.
11:32:21 <dons> did you use your own haskell regex bindings?
11:32:32 <thetallguy> I guess template haskell would handle it.
11:32:44 <TomMD> dcoutts_: Would there be a problem if I just submitted a patch that would make all out of bound verbosities the min or max, as appropriate?  (Ticket 176).
11:32:48 <dons> yeah, you could certainly do the compile call at compile time, with a TH splice
11:32:52 <thetallguy> dons: no, I think we mostly used the ones from 6.6
11:32:58 <TomMD> oh, I am talking about Cabal, BTW.
11:33:05 <judahj> allbery_b: OK, that makes sense.  Thanks.
11:33:26 <thetallguy> dons: though I was always tempted by Harp, but it was too hard to track over the change of compilers
11:35:34 <dcoutts_> TomMD: hmm, in that specific case it's not too bad, but more generally we often need to parse/validate flags and should have some reasonable mechanism for reporting such errors
11:36:12 <dcoutts_> ndm: for what exactly? how the split search path function should work?
11:38:20 <ndm> dcoutts: yep
11:38:55 <dcoutts_> ndm: splitSeachPath "a::b" = ["a", ".", "b"] seems ok to me
11:39:39 <dcoutts_> ndm: at least on posix, there's no obvious harm in following OpenGroup recommendation
11:40:17 <dcoutts_> ndm: on windows do what MS recommends or whatever you feel like
11:41:36 <ndm> dcoutts_: it also recommends ":foo" = [".","foo"] and "foo:" = ["foo","."] - which conflicts with Igloo, i think
11:42:23 <dcoutts_> ndm: does Igloo have any justification for wanting something other than what the OpenGroup specify?
11:43:59 <ndm> @seen Igloo
11:43:59 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 1h 11m 12s ago.
11:44:31 * Igloo can't remember, hang on
11:44:58 <Igloo> In the mean time, does anyone know why "+ ghc --make q.hs -package Win32 -lkernel32" might say "q.o(.text+0x440):fake: undefined reference to `CreateJobObject@8'"?
11:46:43 <Igloo> OK, in GHC it's used for parsing GHC_PACKAGE_PATH, not anything standard like PATH
11:46:44 <ndm> Igloo: W vs A?
11:47:09 <Igloo> Perhaps the best plan is just to leave "" in if there is : at the start or end, or :: in the middle?
11:47:14 <ndm> Igloo: looks like it :)
11:47:34 <ndm> (the W vs A thing)
11:48:04 <Igloo> ndm: So http://msdn2.microsoft.com/en-us/library/ms682409.aspx means I should really call CreateJobObjectA, not CreateJobObject?
11:48:05 <lambdabot> Title: CreateJobObject Function (Windows)
11:48:34 <Igloo> Ah, the perl calls CreateJobObjectW. I hadn't noticed that
11:48:57 <ndm> Igloo: yes, probablyl W version though, the A version is now just compatibility
11:48:59 <Deewiant> CreateJobObject is just a macro, which is then expanded in the C headers to CreateJobObjectA or CreateJobObjectW
11:49:41 <Igloo> OK, grand, thanks!
11:50:34 <dcoutts_> Igloo: why would you want "" rather than "." when the OpenGroup recommends the latter?
11:51:03 <dcoutts_> since it doesn't seems to be that important on the face of it, just go with the standard
11:51:34 <ndm> Igloo: my implementation is as simple as if [pathSeparatorChar] `isSuffixOf` path then normalpath ++ extra
11:51:39 <wolverian> hm, I read the topic said "Engorge"
11:52:40 <Igloo> dcoutts_: I guess I can't argue with that; it's just that when parsing GHC_PACKAGE_PATH we put the system package conf paths in instead
11:53:24 <dcoutts_> Igloo: if you're not using a system search path you can use different code if what you're doing is sufficiently different
11:53:26 <Igloo> ndm: Yeah, maybe the right thing is for GHC to just do that
11:54:25 <dcoutts_> Igloo: so does ghc have an env var for the package path?
11:54:43 <Igloo> Yes, GHC_PACKAGE_PATH
11:55:32 <gwern> don't shout / and wave it about / or the others will want one too!
11:55:48 <ndm> Igloo: so, i should follow the open group recommendation?
11:55:58 <ndm> i.e. adding "." if there are any empty filepaths
11:56:07 <Tac-Tics> @pl flip mapM_
11:56:08 <lambdabot> flip mapM_
11:56:14 <Igloo> ndm: Yeah, OK
11:56:23 <Tac-Tics> @src mapM_
11:56:23 <Tac-Tics> @src forM_
11:56:23 <lambdabot> mapM_ f as = sequence_ (map f as)
11:56:23 <lambdabot> forM_ = flip mapM_
11:56:34 <ndm> Igloo: and remove splitSearchPathSystem ?
11:56:38 <EvilTerran> @src sequence_
11:56:38 <dcoutts_> Igloo: and that gives a path for the package database or for actual .hi files?
11:56:38 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:57:11 <Igloo> package.conf
11:57:13 <dcoutts_> Igloo: is this something cabal should worry about? we usually like to have full control over what package dbs ghc consults
11:58:13 <Igloo> dcoutts_: But you always go through ghc/ghc-pkg don't you? So as long as they are consistent I think you should be OK ignoring it
11:58:20 <ndm> hmm, replaceFileName "\\\\" "foo" under Windows gives "\\\\foo", which looks like a share name... is that right?
11:58:46 <dcoutts_> Igloo: well it could be like looking in a user package db when doing a global install
11:59:48 <dcoutts_> ndm: "\\\\" isn't even a valid dir is it?
11:59:56 <ndm> dcoutts_: no
12:00:04 <dcoutts_> ndm: then just error? :-)
12:00:21 <ndm> dcoutts_: filepaths suck totally!
12:00:42 <dcoutts_> ndm: or return "\\\\" on the basis that there was no file component to replace
12:00:48 <Tac-Tics> @src sequence
12:00:49 <lambdabot> sequence ms = foldr k (return []) ms
12:00:49 <lambdabot>     where
12:00:49 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:01:00 <Igloo> dcoutts_: Hmm, I'm not sure exactly what the semantics are here
12:01:23 <Igloo> I'd assume that these paths are only read from, seeing as user and system paths seem to be indistinguished
12:02:03 <dcoutts_> Igloo: it worries me slightly I have to say, since if there is any inconsistency about what package db we use when we build vs when it's installed and used will cause failures, either subsequent compile errors, or linker or segfault
12:02:53 <dcoutts_> Igloo: we really need to start tracking api/abi accurately in package files and .hi files to catch those kinds of errors
12:03:44 <ramza3> is there an operator, liftSomething :: IO a -> a   ...does that even make sense
12:03:49 <ndm> dcoutts_: i'll just leave it as it is, and specify in the test that it must be valid first
12:03:59 <dv> ramza3: unsafePerformIO
12:04:05 <dcoutts_> ndm: seems ok
12:04:54 <SamB> ramza3: doesn't make sense, no
12:11:09 <allbery_b> ramza3: it exists but shouldn't be used.  lift into IO, not out of it
12:11:42 <allbery_b> (and if you use it without understanding, it ill bite you)
12:18:06 <dcoutts_> BMeph: ping
12:18:12 <dcoutts_> @seen BMeph
12:18:12 <lambdabot> BMeph is in #haskell. I last heard BMeph speak 2h 19m 48s ago.
12:19:45 <Sizu1> @pl f a b = a <$> b
12:19:45 <lambdabot> f = (<$>)
12:20:03 <Sizu1> wow, i have a brain stupor
12:24:32 <sclv>  (\env -> showVal env <$> sequence xs env)
12:24:41 <sclv> @pl  (\env -> showVal env <$> sequence xs env)
12:24:41 <lambdabot> liftM2 (<$>) showVal (sequence xs)
12:24:46 <sclv> ugly pl is ugly.
12:25:09 <sclv> there's got to be some elegant way of saying liftM2 (fmap) that I'm missing.
12:25:21 <sclv> ?ty liftM2 fmap
12:25:23 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
12:26:47 <Tac-Tics> Why does lambda bot specify the kind of f and m in ?ty liftM2 fmap
12:27:01 <Tac-Tics> Aren't the kinds decided by the Functor f and Monad m clauses?
12:27:52 <mauke> you can ignore everything before the .
12:27:58 <mauke> lambdabot just likes to be explicit
12:28:52 <binaryten> ?t liftM3
12:28:53 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:29:12 <binaryten> ?ty liftM2
12:29:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:30:06 <LoganCapaldo> I think the kinds might even be determined by the type m (a -> b) -> m (f a) -> m (f b) even w/o the class constraints. I don't think you can have a type like Either a -> ...
12:31:09 <dons> maybe someone would like to do a haskell binding to the OpenGo framework? http://www.inventivity.com/OpenGo/
12:31:09 <lambdabot> Title: OpenGo - A Go Programming Environment
12:31:16 <dons> i like the idea of hacking game strategies in haskell..
12:31:49 <Tac-Tics> That sounds like fun
12:31:52 <Tac-Tics> Go is a great game
12:31:54 <ndm> dons: wasn't Jaffacake doing a Go implementation in Gtk2hs
12:32:58 <gwern> thought he was doing Shogi?
12:34:09 <ndm> not entirely sure, i don't play Go yet (although am learning on Friday)
12:34:51 <dons> we have aa haskell/go community too, iirc.
12:34:55 <IvdSangen> what Go servers use an open protocol? IGS? KGS?
12:34:58 <LoganCapaldo> @type let { g :: m (a -> b) -> m (f a) -> m (f b) ; g = undefined } in g
12:34:59 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). m (a -> b) -> m (f a) -> m (f b)
12:35:03 <Tac-Tics> Shogi is fun too. Especially if both you and your opponent are no good at the game. You can keep playing for a long long time
12:35:08 <ddarius> LoganCapaldo: In that case, in general not.
12:35:54 <LoganCapaldo> I'm not sure what the "general" case would be?
12:38:45 <ddarius> f g a what's the kind of g?
12:39:33 <LoganCapaldo> Sure, I wasn't suggesting you could always determine the kind
12:39:50 <LoganCapaldo> of an arbitrary binding
12:40:20 <LoganCapaldo> just that here assuming it's a valid type, you didn't need to know the classes to get the kinds
12:40:41 <opqdonut> ?src maximum
12:40:42 <lambdabot> maximum [] = undefined
12:40:42 <lambdabot> maximum xs = foldl1 max xs
12:41:07 <ndm> maximum = foldl1 max
12:41:08 <byorgey> IvdSangen: KGS definitely does, I don't know about IGS.
12:41:35 <LoganCapaldo> (since we know the kind of (->))
12:43:14 <byorgey> dons: that's a great idea.  somehow I'd never heard of OpenGo.
12:43:41 <hpaste>  gwern pasted "bw-word" at http://hpaste.org/4974
12:44:30 <dons> i bet you could get say, 2 or 3 haskell guys together, and do a decent binding in less than a month
12:44:52 <IvdSangen> byorgey: so writing a free software client for KGS is possible, is there one? (I only know cgoban2/3)
12:45:06 <dons> or research other go libs, yeah.
12:45:40 <byorgey> IvdSangen: In principle I suppose it should be.
12:45:52 <doserj> kgs isn't open
12:46:16 <IvdSangen> that's what I thought, I only found a stupid jar-file
12:46:17 * SamB wishes GHC could tell you the types of errors...
12:46:39 <doserj> igs/nngs etc. are
12:46:57 <byorgey> ok, I guess it's only that KGS supports an open protocol for writing go-playing bots
12:47:07 <byorgey> not for writing an actual client.
12:47:26 <IvdSangen> I play on IGS, but I used to play on KGS and noticed that there were more beginners there
12:47:36 <Cale> byorgey: That's how I remember it being last I checked anyway.
12:47:50 <Cale> KGS is really good for beginners and teachers.
12:47:52 <IvdSangen> and you have to use Java, or something that has Java bindings
12:47:59 <Cale> Because the editing tools are so good.
12:48:43 <IvdSangen> IGS doesn't even support handicap games
12:48:45 <Cale> You can build up a whole tree of games, annotate it, play on from a constructed position, mark up the board in various ways, etc.
12:48:58 <byorgey> someone should make a list of haskell people who play go on the wiki. =)
12:49:17 <ddarius> I thought there was one.
12:49:42 <IvdSangen> would it be useful to write a free implementation of a go server like KGS (in haskell)?
12:49:47 <byorgey> oh, maybe there is! =)
12:49:51 * byorgey looks
12:49:52 * gwern would add myself to such a list
12:49:53 <IvdSangen> or is it doomed to be left unpopulated
12:50:12 <czakey> yawn
12:50:40 <czakey> sleepy day
12:50:43 <ndm> byorgey: i believe it was actually one of the questions in the GHC maintainer application form, what is your go ranking
12:51:14 <Cale> IvdSangen: I'm sure we could get lots of Haskell people to play :)
12:51:25 <Cale> IvdSangen: (at least initially :)
12:51:29 <hpaste>  (anonymous) pasted "feeble main attempt" at http://hpaste.org/4975
12:51:40 <gwern> nice. 'To be a GHC maintainer, you must be the kind of smart person who plays Go for fun'
12:51:42 <byorgey> ndm: haha!
12:52:04 <hughperkins> Hi.  Really dumb question.  How do I make a .hs file with a #! at the top that I can just execute? I tried http://hpaste.org/4975 , but told me "line 3: main: command not found"
12:52:10 <gwern> hm. doesn't that sort of main usually use 'runhaskell'?
12:52:14 <Cale> Also, I think there'd be some room for it, since I remember a lot of people wanting KGS itself to be more open.
12:52:41 <hughperkins> gwern: yay! that works :-)
12:52:44 <Cale> hughperkins: #! /usr/bin/env runhaskell
12:52:46 <IvdSangen> if KGS were open, I would be happy to write a client
12:52:58 <gwern> wut Cale sez
12:53:02 <hughperkins> Great thanks :-)
12:53:03 <Cale> (or runghc)
12:53:24 <ddarius> or runhugs or runnhc or runyhc (not sure about the latter two)
12:54:53 <dons> #!/usr/bin/env runhaskell
12:54:53 <dons> main = print "hey"
12:54:56 <dons> for example.
12:55:02 <byorgey> hmm, if there is a page on the wiki listing go-playing haskellites, it is not easy to find.
12:55:15 <doserj> there was one on the old wiki
12:55:17 <ddarius> byorgey: It was almost certainly on the old wiki
12:55:21 <byorgey> oh, I see.
12:56:43 * gwern hopes someone helps this poor Torsten Otto fellow on Haskell-cafe
12:57:22 <gwern> 'FranTk works under hugs98 and ghc-4.04.' <--- ...
12:57:35 <gwern> I guess it hasn't been updated recently
12:57:43 <mauke> ghc-4.04: not found
12:59:15 <gwern> actually, you know what would be nice? if haskell prime was finished this year. then it'd go haskell '98 -> haskell '08... (although we might have problems in a few more decades)
13:00:56 <shachaf> gwern: Well, it would be "Haskell'98" -> "Haskell'" anyway -- just dropping two characters.
13:01:09 <Cale> I kind of hope '98 is the last Haskell to use that silly year-numbering scheme :)
13:01:28 <Cale> Let's have Haskell' = Haskell 1.6
13:01:36 <dons> Haskell 4000
13:01:41 <kaol> isn't that what Java is at?
13:01:43 <Cale> (with '98 = 1.5)
13:01:46 <dons> the 2000 year language.
13:01:50 <fnord123> Hi all, I would like to import a module and use a function in it that has a pretty common name ("velocity"). To avoid name conflicts, I am importing the module, hiding velocity, and then importing the module 'as' something else
13:01:52 <mauke> Haskell 9899:1999
13:01:59 <dons> fnord123: ok.
13:01:59 <fnord123> however, ghc tells me that it doesn't like the word 'as' in my import decl: import qualified MyTrig(velocity) as Trig
13:02:08 <Cale> Then when we move to Haskell 2.0, nobody will be surprised by all the incompatibility ;)
13:02:15 <dons> import qualified M as T (foo)
13:02:21 * fnord123 isn't sure if he sent that to this channel as pidgin is in a weird state
13:02:35 <dons> fnord123: see above, you've the import list in the wrong place
13:02:55 <olsner> mauke: hmm, isn't that name already taken for C99?
13:02:59 <fnord123> i dont see anything above. i rejoined the channel and still only see 1 person in the user list
13:03:04 <gwern> Cale: no, dates are good as it motivates people to update. common lisp didn't use dates, and look at them...
13:03:10 <hughperkins> Yet another newbie question: how can I read environment variables?
13:03:12 <mauke> olsner: only if it has an ISO in it!
13:03:19 <ddarius> :t getEnv
13:03:21 <lambdabot> Not in scope: `getEnv'
13:03:25 <ddarius> @hoogle getEnv
13:03:26 <lambdabot> System.Environment.getEnv :: String -> IO String
13:03:26 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
13:03:38 <Sizu1> @instances Functor
13:03:38 <hughperkins> Great thanks :-)
13:03:38 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:04:25 <Sizu1> @instances Control.Applicative.Applicative
13:05:16 <allbery_b> @instances-importing Control.Applicative Applicative
13:05:17 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:05:29 <Sizu1> why so few?
13:05:39 <Sizu1> hmm Maybe's there, but i get an error
13:05:59 <fnord123> dons, how do you mean i have the import list in the wrong place?
13:06:05 <Sizu1> allbery_b: thanks
13:06:14 <fnord123> oh i see your post. sorry
13:06:24 <FalconNL> @src printf
13:06:25 <lambdabot> Source not found. There are some things that I just don't know.
13:06:49 <dons> fnord123: the syntax is, import qualified M as T (foo)
13:07:09 <ddarius> @src Printf
13:07:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:07:44 <allbery_b> @source Text.Printf
13:07:45 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:07:50 <allbery_b> grrr, still wrong
13:13:36 <FalconNL> Can anyone tell me how to create a function that takes a variable amount of arguments (they can all be the same type), similar to printf? The author of printf decided to hide the implementation PrintfType.
13:13:50 <shachaf> FalconNL: It's not always possible.
13:13:59 <shachaf> FalconNL: If they're all the same type, consider accepting a list.
13:14:16 <shachaf> FalconNL: (printf has an easier time because the format string tells it how many arguments it'll get.)
13:14:23 <Centrinia> There is also a section in the Template Haskell paper about printf.
13:14:29 <Sizu1> FalconNL: http://hpaste.org/4968?lines=true
13:14:44 <FalconNL> Yeah, I know that would be the simplest solution. The reason I ask is for a toy project that would use Haskell as a DSL to spit out html.
13:15:02 <FalconNL> and it would be cleaner not to have a lot of brackets in the code
13:15:14 <ddarius> FalconNL: You use type classes to perform induction on the number of arguments.
13:15:17 <Lycurgus> DSL?
13:15:21 <Sizu1> FalconNL: there are many implementations for that already. HSXML is using polyvariadic functions
13:15:32 <Saizan> FalconNL: read the Text.Printf source :)
13:15:43 <ddarius> @source Text.Printf
13:15:43 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:15:44 <Centrinia> Domain Something Language.
13:15:49 <ddarius> Specif
13:15:51 <ddarius> Specifi9
13:15:54 <ddarius> cripes
13:15:55 <allbery_b> domain-specific
13:15:56 <Lycurgus> ah.
13:17:01 <dons> ?users
13:17:01 <lambdabot> Maximum users seen in #haskell: 444, currently: 443 (99.8%), active: 23 (5.2%)
13:17:04 <dons> bring it on!
13:17:11 <Lycurgus> didn't get that since I normally think of that in an AI or enterprise rules, etc. context rather than front end processing.
13:19:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4976
13:19:11 <roconnor>   kelly: Cannot initialize GUI.
13:19:12 <Lycurgus> but I suppose there could be a horizontal/vertical dichotomy in DSLs
13:19:13 <hughperkins> Yet another newbie question: reading environment works in interactive but not in cgi.  What could I be doing wrong?  http://hpaste.org/4976
13:19:23 <roconnor> how do I fix a Cannot initialize GUI error?
13:19:39 <ddarius> @users
13:19:39 <lambdabot> Maximum users seen in #haskell: 444, currently: 444 (100.0%), active: 25 (5.6%)
13:19:43 <dons> hughperkins: is the environment list empty, is that what you're finding?
13:20:02 <hughperkins> Yeah, it prints nothing in cgi (but about 22 variables in commandline)
13:20:06 <dons> btw, i'd recommend the 'xhtml' package for html generation
13:20:09 <allbery_b> $USER is not set in CGI
13:20:20 <allbery_b> look up your webserver's documentation to find out what is set
13:20:22 <dons> yeah, CGI is a restricted environment - for safety reasons
13:20:24 <ndm> @src quickcheck
13:20:25 <lambdabot> Source not found. stty: unknown mode: doofus
13:20:30 <ndm> @where quickcheck
13:20:30 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
13:20:46 <Sizu1> dons: hsxml looks at me sexier now :P
13:20:54 <dcoutts_> g'afternoon dons
13:20:56 <hughperkins> But normally I should see the querystring etc in the environment variables?
13:21:11 <allbery_b> yes
13:21:13 <dons> hey dcoutts_
13:21:23 <Sizu1> except for errors that run 20 pages long
13:21:24 <dons> we need one more user for the #haskell record
13:22:11 <dcoutts_> roconnor: on linux, macos, windows?
13:22:28 <dcoutts_> roconnor: on X11 systems it means it cannot connect to the X11 server
13:22:33 <dcoutts_> dons: heh!
13:22:36 <dons> hughperkins: yeah, you can query environment variables. but in cgi programming, that's unusual I think
13:22:39 <dons> ?users!
13:22:40 <lambdabot> Maximum users seen in #haskell: 445, currently: 445 (100.0%), active: 28 (6.3%)
13:22:41 <dons> woot!
13:22:44 <dcoutts_> 444
13:22:48 <FalconNL> @where hsxml
13:22:49 <lambdabot> I know nothing about hsxml.
13:22:52 <dons> welcome jeffz, lucky 445th #haskell user :)
13:22:54 <byorgey> congratulations jeffz! =)
13:23:01 <jeffz> heh, just reconnecting :)
13:23:03 <hughperkins> AFAIK, in cgi, you get the query string from the environment variables, and the post from the stdin?
13:23:04 * LoganCapaldo drops balloons from the ceiling
13:23:06 <dcoutts_> dons: oh, my client is off-by-1
13:23:08 <dons> you win an autographed xmonad tshirt, and a copy of the h98 report
13:23:20 <jeffz> awesome.
13:23:26 <Sizu1> FalconNL: http://okmij.org/ftp/Scheme/xml.html#typed-SXML
13:23:27 <lambdabot> Title: XML and Scheme
13:23:30 <dons> hughperkins: from the command line args, I though
13:23:36 <dons> hughperkins: bug the 'cgi' package has wrappers for all this
13:23:40 <FalconNL> thanks
13:23:40 <dons> s/but/
13:23:43 <Saizan> yeah, you get quite a few info from the webserver via environment variables
13:23:48 <ramza3> ?users!
13:23:48 <lambdabot> Maximum users seen in #haskell: 445, currently: 445 (100.0%), active: 30 (6.7%)
13:23:50 <dons> hughperkins: so I'd look at the 'cgi' and 'xhtml' packages
13:23:53 <allbery_b> dons: only because a library usually wraps them.  HTTP_* and QUERY_STRING (? been a lng time)
13:23:57 <dons> they'll remove almost all your boiler plate
13:23:57 <mauke> bbut we're only 444
13:24:02 <mauke> ok, 445 now
13:24:04 <ramza3> where are the newbs?  sound off.
13:24:11 <Centrinia> ?users
13:24:12 <lambdabot> Maximum users seen in #haskell: 446, currently: 446 (100.0%), active: 30 (6.7%)
13:24:19 <dons> oh, is lambdabot off by one?
13:24:21 <allbery_b> I see 445
13:24:22 <allbery_b> yes
13:24:27 <LoganCapaldo> i see 445
13:24:29 <dons> yeah, my client says 445.
13:24:30 <dons> ?users
13:24:30 <lambdabot> Maximum users seen in #haskell: 446, currently: 446 (100.0%), active: 30 (6.7%)
13:24:38 <Centrinia> Does lambdabot count lambdabot?
13:24:40 <dons> maybe she counts ChanServ or something
13:24:41 <Sizu1> 445 here too
13:24:58 <LoganCapaldo> ?users
13:24:59 <lambdabot> Maximum users seen in #haskell: 446, currently: 445 (99.8%), active: 30 (6.7%)
13:25:17 <hughperkins> Here is a simple unix script in cgi: http://rwx.manageddreams.com/haskell/foo.cgi  here is with haskell: http://rwx.manageddreams.com/haskell/test.hs?color=blue   In the simple unix script version, we get tons of environment variables, but not itn hte haskell version?
13:25:17 <roconnor> dcoutts_: Okay, thanks
13:25:33 <Centrinia> ?ver
13:25:34 <lambdabot> Maybe you meant: vera version
13:25:35 <dcoutts_> roconnor: so if you're on macos make sure you've started the X11 server
13:25:38 <Centrinia> ?version
13:25:38 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
13:25:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:25:47 <Centrinia> I'll check the source code. :)
13:26:28 <hughperkins> So the runhaskell is deliberately detecting we are running in cgi and suppressing the environemnt variables?
13:26:29 <Sizu1> FalconNL: warning! hsxml is heavy on olegisms
13:26:50 <allbery_b> hughperkins: check your web server's documentation, it may be detecting an unapproved program and restricting it
13:26:58 <hughperkins> Ah
13:27:02 <allbery_b> runhaskell doesn't know anything
13:27:06 <Sizu1> FalconNL: but if you want to go the route of polyvariadic implementation, then you need it
13:27:07 <FalconNL> Not sure what olegisms are, but I noticed the syntax is quite a bit more verbose than what I was looking for
13:27:14 <roconnor> dcoutts_: I'm trying to help some poor fellow
13:27:22 <dcoutts_> roconnor: ok
13:27:23 <roconnor> dcoutts_: my last email suggested he come here.
13:27:28 <dons> hughperkins: you might be able to compile the .hs to a binary and run that
13:27:28 <allbery_b> the wbeb server is usually paranoid though, to try to avoid people running random stuff via misconfigured servers
13:27:33 <mauke> @where oleg
13:27:34 <lambdabot> http://okmij.org/ftp/
13:27:36 <dons> since currently its accessing this /usr/local/bin/* thing
13:27:41 <dons> which the web server might consider unsafe
13:27:46 <FalconNL> Perhaps I will have to look up a tutorial about writing a parser
13:27:54 <mauke> @quote oleg
13:27:55 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
13:28:14 <hpaste>  ramza3 pasted "first haskell app, binary file format " at http://hpaste.org/4977
13:28:28 <Lycurgus> anybody using Eden under 6.8.2?
13:29:01 <fnord123> anyone have insight into when ubuntu will upgrade to 6.8.x?
13:31:02 <hughperkins> Correct dons: I changed to /usr/bin/runhaskell and it works great :-) http://rwx.manageddreams.com/haskell/test.hs?color=blue
13:31:11 <Sizu1> FalconNL: https://research.microsoft.com/users/daan/download/parsec/parsec-letter.pdf
13:31:17 <lambdabot> http://tinyurl.com/33gupm
13:31:54 <Sizu1> FalconNL: but then you are left with validating the document, not only parsing
13:32:13 <FalconNL> true
13:32:13 <hpaste>  dons pasted "cgi with xhtml" at http://hpaste.org/4978
13:32:14 <Sizu1> FalconNL: hsxml checks for element context
13:32:22 <hughperkins> YANQ : is there a package installer, like say "cabal install cgi"?
13:32:29 <dons> hughperkins: there's a quick example generating html with the 'xhtml' package, http://hpaste.org/4978
13:32:34 <dons> much nicer than manual html :)
13:32:52 <hughperkins> Hmmm, interesting :-)
13:33:34 <dons> it creates this page, http://galois.com/~dons/tmp/test.html
13:33:35 <lambdabot> Title: testing
13:33:53 <hughperkins> Looks good :-)
13:33:55 <FalconNL> dons: better, though I'd prefer getting rid of the toHtml and $'s
13:34:16 <smack_> string overloading?
13:34:18 <dons> yeah, $ helps remove some ()))(()) lisp isms, but toHtml could actually be fixed with an IsString instance!
13:34:40 <Sizu1> hughperkins: check the source of the webpage ;)
13:34:48 <allbery_b> <hughperkins> YANQ : is there a package installer, like say "cabal install cgi"?
13:34:52 <allbery_b> cabal-install
13:34:56 * ddarius mumbles "beginning of the end" again
13:35:20 <hughperkins> allbery_b: Oooo, cool :-)
13:35:34 <LoganCapaldo> IsString, the greatest invention since sliced Num
13:35:40 <FalconNL> ouch. Does the xhtml library always generate all the span tags?
13:35:51 <olsner> @where IsString
13:35:51 <lambdabot> I know nothing about isstring.
13:36:05 <olsner> @docs IsString
13:36:05 <lambdabot> IsString not available
13:36:15 <LoganCapaldo> not that Num is sliced
13:36:28 <Sizu1> FalconNL: what span tags?
13:36:35 <dons> FalconNL: its entirely tunable.
13:36:55 <FalconNL> if you look at the source of the test.html dons posted it's full of span tags
13:37:05 <dons> no there isn't.
13:37:15 <dons> are you looking at the hpaste page?
13:37:16 <Sizu1> FalconNL: youa re looking at the wrong source
13:37:21 <dons> http://galois.com/~dons/tmp/test.html
13:37:22 <lambdabot> Title: testing
13:37:26 <FalconNL> oh, wait. my bad. was looking at the hpaste page
13:37:29 <dons> you're probably looking at the HsColour'd page :)
13:37:35 <smack_> (are there IsString docs anywhere?)
13:38:08 <LoganCapaldo> class IsString a where fromString :: String -> a -- that's it
13:38:12 <Centrinia> Should lambdabot count ChanServ?
13:38:14 <smack_> LoganCapaldo: thanks
13:38:22 <olsner> LoganCapaldo++
13:38:22 <Centrinia> ?seen ChanServ
13:38:23 <lambdabot> ChanServ is in #gentoo-uy, #friendly-coders, #fi.muni.cz, #gentoo-haskell, ##logic, #jtiger and #haskell. I don't know when ChanServ last spoke.
13:38:46 <Centrinia> Yeah, ChanServ is counted.
13:38:48 <smack_> ddarius: seems pretty harmless here
13:38:50 <ddarius> Centrinia: There's little reason not to.
13:39:08 <ddarius> smack_: That's why it is only the beginning.
13:39:10 <allbery_b> the magic being that ghc knows about the class, like it knows about Num and promotes integer literals to Num a => a, it promotes string literals to IsString a => a
13:39:23 <Centrinia> I was just curious. That's why we have 452 users.
13:39:48 <allbery_b> ChanServ counts as a user in my client, I think
13:40:13 <hpaste>  dons annotated "cgi with xhtml" with "and with Html overloaded" at http://hpaste.org/4978#a1
13:40:31 <dons> FalconNL: ^ so that uses string overloading to hide the toHtmls
13:40:33 <hughperkins> YANQ: how do I list currently installed packages?
13:40:37 <dons> ghc-pkg list
13:40:47 <allbery_b> confirmed
13:40:57 <allbery_b> it's not they mystery user #452
13:41:04 <dons> ?users
13:41:05 <lambdabot> Maximum users seen in #haskell: 452, currently: 452 (100.0%), active: 30 (6.6%)
13:41:10 <dons> welcome everyone!
13:41:16 <Vq^> dons: thanks
13:41:18 <LoganCapaldo> thanks doons
13:41:18 <TomMD> Yay!
13:41:23 <LoganCapaldo> aaaa typo :(
13:41:28 <LoganCapaldo> s/doons/dons
13:41:29 <FalconNL> dons: now that's more like it :)
13:41:30 <hughperkins> dons: thanks :-)
13:42:17 <Sizu1> nonsense! olegisms ftw!
13:42:54 <Sizu1> i do think xhtml is great :)
13:43:10 <Sizu1> just looks a little bit ugly
13:43:22 <byorgey> anyone know if Joao Ferreira hangs out here?
13:43:58 <LoganCapaldo> Joao Ferreira knows.
13:44:13 <byorgey> LoganCapaldo: good point =)
13:46:51 <hughperkins> Hmmm, cabal-install is great :-)
13:47:06 <dons> its a key piece of kit for haskell 2008, imo.
13:47:12 <ddarius> There isn't a way to haddock one module and have it look like it's for another is there?
13:47:20 <ddarius> It's pretty cool.
13:47:33 <davidL> does cabal-install work with lambdabot?
13:47:33 <lambdabot> davidL: You have 1 new message. '/msg lambdabot @messages' to read it.
13:47:43 <Sizu1> it's working already?
13:47:44 <ndm> ddarius: CPP
13:47:52 <czakey> ah
13:47:52 * ddarius might just be motivated enough to finally add haddock documentation to Parsec after nine years.
13:47:57 <czakey> before sleep
13:48:09 <czakey> some haskell
13:48:10 <ddarius> ndm: How with CPP?
13:48:22 <czakey> for goodnight ;]
13:48:26 <ndm> ddarius: you can just use hacky CPP with #ifdef HADDOCK
13:48:49 <hughperkins> Hmmm, Haddock failed to link :-/
13:49:09 <thetallguy> ndm: what's the best thing to read to understand -src-exts/HSP?
13:50:24 <LoganCapaldo> probably the mind of someone who hangs out in here
13:50:27 <dons> thetallguy: bringert's papers on the topic
13:50:40 <dons> he wrote one on HSP for the HW in 05, iirc
13:50:42 <dons> or 04.
13:50:50 <ndm> thetallguy: the web page is what i used for -src-exts
13:50:53 <ndm> never used HSP
13:50:56 <dons> oh, not bringert, nibro.
13:50:59 <hughperkins> linking dist/build/haddock/haddock -> "/usr/bin/ld: cannot find -lreadline"    :-/
13:51:17 <dons> hughperkins: readline installed? (or maybe the path is a bit weird)
13:51:30 <ndm> thetallguy: http://www.cs.york.ac.uk/fp/darcs/hoogle/src/Web/HTML.hsx - that should tell you everything you need about hsx
13:51:34 <czakey> byorgey: hello, remember perm from yesterday?
13:51:49 <byorgey> czakey: yes, did you get it to work?
13:51:56 <thetallguy> ndm: you're using the embedded XML?  That's what I'm interested in.
13:52:00 <czakey> unfortunately I haven't time to think about it today
13:52:07 <czakey> to much work
13:52:11 <ndm> thetallguy: yes, its in that file
13:52:17 <czakey> in sunday...
13:52:21 <ddarius> Oh sweet, it does handle this use-case.
13:52:25 <ddarius> Whew.
13:52:45 <Sizu1> oh noes! not another jsp
13:52:45 <czakey> I tought that before sleep is a good moment
13:52:54 <czakey> but
13:53:02 <thetallguy> ndm: I see it, thanks.
13:53:04 <czakey> now I'm looking at it
13:53:05 <gwern> is there an extensions for fixing the error 'Illegal polymorphic or qualified type: forall x.' in datatype in newtype etc.?
13:53:38 <byorgey> czakey: ok
13:53:41 <czakey> and I dont really understand how that perm maybe helpful to that perm
13:53:42 <czakey> :D
13:54:02 <czakey> bach
13:54:06 <Sizu1> gwern: ExistentialQuantification? you cannot have it on newtype
13:54:06 <czakey> I mean
13:54:14 <czakey> how that allInsertions
13:54:18 <Sizu1> -XExistentialQuantifications
13:54:35 <czakey> remember: allInsertions v (x:xs)
13:55:01 <czakey> inserts v into every position in list
13:55:18 <czakey> extends list by 1
13:56:02 <czakey> so yesterday i tought that mayby I need delete
13:56:16 <czakey> to get that list orginal size
13:56:31 <czakey> but you said thats not a good idea
13:56:32 <gwern> confusing. I wonder how that code ever compiled in the first place
13:56:35 <czakey> whats the point?
13:56:51 <LoganCapaldo> > let without = flip delete in [1,2,3,4] `without` 3
13:56:53 <lambdabot>  [1,2,4]
13:57:00 <phlpp> would it work to take some haskell->c compiler, feeding it with ghc 6.8.2 source to get a ghc 6.8.2 in c to compile it on non-c systems?
13:57:01 <LoganCapaldo> I think that's a better name
13:57:02 <atp> in the ST monad, do you need the forall s. in the type?  Is it sufficient to write fooFunc :: Int -> ST s FooType or do I need to put a forall s. in front of the ST?
13:57:07 * LoganCapaldo comments andomly
13:57:25 <shachaf> > [1,2,3,4] \\ [3]
13:57:26 <lambdabot>  [1,2,4]
13:57:52 <mauke> atp: you don't need forall s.
13:57:59 <phlpp> :t (\\)
13:58:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:58:04 <shachaf> @src (\\)
13:58:04 <lambdabot> (\\) = foldl (flip delete)
13:58:17 <ddarius> atp: They are the same, so no, you don't need them.
13:58:23 <hughperkins> (dons: re: is readline installed?  You're right, it's not.  Thanks :-) )
13:58:25 <atp> mauke: that's what i figured.  but i'm getting some interesting type errors (it's my first time using the ST monad), so i'm just checking.
13:58:55 <ddarius> atp: The only time you should get interesting type errors is when using runST or runSTArray
13:58:58 <mauke> atp: is the error near runST?
13:59:19 <roconnor> atp: you are probably doing runST $ do ...
13:59:24 <roconnor> or is that fixed now?
13:59:24 <atp> yeah
13:59:35 <atp> i'm doing runST $ something >> somethingElse
13:59:39 <atp> is that not kosher?
13:59:48 <roconnor> it is broken in some version of GHc
13:59:48 <mauke> no, ($) has the wrong type
13:59:59 <allbery_b> ($) doesn't handle higher order polymorphism
14:00:02 <atp> ahh
14:00:03 <allbery_b> or something like that
14:00:04 <atp> so parens
14:00:04 <roconnor> runST (something >> somethingElse) should work in all cases
14:00:05 <atp> then
14:00:08 <phlpp> anyone got a idea for my ghc idea?
14:00:09 <ddarius> roconnor: It's not breakage.
14:00:10 <atp> thanks, i'll try
14:00:28 <roconnor> ddarius: I thought $ worked in recent versions of GHC.
14:00:43 <atp> ah, that removed the biggest error, thanks guys
14:00:50 <ddarius> roconnor: Haskell's type system is predicative, to allow that would require impredicativity which was experimented with in a recent version of GHC, but I think reverted.
14:00:53 <MarcWeber> ghc-8.2 / cabal stores 4 digitns of version information. Is this a new default used everywhere now?
14:00:57 <allbery_b> phlpp: ghc can produce unregisterised ANSI C code.  it is portable butugly and slow
14:01:10 <phlpp> allbery_b: oh, ok
14:01:12 <ddarius> (or rather a very hacky half-implementation of it was)
14:01:12 <roconnor> ddarius: woah, it's predicative
14:01:15 <mauke> Control.Monad.ST> runST $ return 42
14:01:15 <mauke> 42
14:01:19 <roconnor> I find that surprising
14:01:24 <phlpp> allbery_b: it's just to get a haskell compiler for plan9, you know
14:01:32 <byorgey> czakey: think about it this way.  perms is going to be a recursive function.
14:01:35 <phlpp> at least to maybe someday compile a own, small interpreter
14:01:38 <allbery_b> it's also only useful for porting ghc itself, as you still need a runtime
14:01:49 <Sizu1> > foldl (<*>) (Control.Applicative.pure succ) [[1,2]]
14:01:49 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
14:01:49 <lambdabot>       Expec...
14:01:52 <byorgey> czakey: so if you have a list (x:xs) with first element x and rest xs, you can assume you are going to call perms xs.
14:02:20 <byorgey> czakey: the question is: assuming you actually have all permutations of xs, how can you combine that with x to get all permutations of (x:xs)?
14:02:38 <ddarius> Hmm, it seems Paolo's intent is to move Text.ParserCombinators.Parsec to Text.Parsec.
14:02:47 <byorgey> czakey: that is, perms (x:xs) = do something with x and perms xs
14:02:57 <allbery_b> phlpp: http://hackage.haskell.org/trac/ghc/wiki/Building
14:02:57 <shachaf> @ty (<*>)
14:02:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:02:58 <lambdabot> Title: Building - GHC - Trac
14:03:03 <phlpp> hej byorgey :]
14:03:15 <byorgey> hi phlpp =)
14:03:50 <czakey> ah I see
14:03:54 <BMeph> ?users
14:03:54 <lambdabot> Maximum users seen in #haskell: 458, currently: 456 (99.6%), active: 30 (6.6%)
14:04:00 <ddarius> "The modules should not be mutually recursive, as Haddock don't like swimming in circles."
14:04:01 <phlpp> i think it's about 2 months ago, i mean my last visit in here :>
14:04:03 <czakey> when I have all permutations of xs
14:04:13 <czakey> I only need to insert x
14:04:20 <dons> so now's the time to advertise the '2008 Haskell library challenge'.
14:04:23 <czakey> everywhere
14:04:26 <czakey> into xs
14:04:30 <dons> we've a *lot* of libraries on hackage.haskell.org, but we need more.
14:04:30 <byorgey> czakey: that's right.
14:04:42 <Sizu1> what's the prise?
14:04:45 <czakey> ok :)
14:04:52 <dons> so if you're looking for something to work on, take a look at the base python libs, http://docs.python.org/lib/
14:04:52 <lambdabot> Title: Python Library Reference
14:05:05 <dons> and there's a few there not in haskell yet -- have a go at implementing the ones that are interesting to you
14:05:06 <byorgey> czakey: it's not quite that simple, remember that perms xs actually returns a list of lists, so you will have to insert x in all possible ways into each one
14:05:13 <byorgey> czakey: but that's the idea
14:05:13 <dons> then upload them to hackage in the next month or two
14:05:28 <dcoutts_> or help hack on hackage itself :-)
14:05:38 <czakey> so map will be my friend
14:05:47 <czakey> map ains x xs
14:05:56 <czakey> lest see
14:06:00 <byorgey> czakey: something like that
14:06:21 <dcoutts_> dons: I'm currently hacking on cabal-install, trying to get it to manage installing a very large number of packages at once and recover gracefully from packages failing
14:06:29 <dons> great!
14:06:35 <phlpp> hmm, are there some straightforward (in the sense of use) libraries to just create a window and draw sth.? i'm not interested in something fat like gtk, i just want to have a way to draw lines, polys(takes list of points) and filled polys
14:06:52 <Sizu1> why cannot i fold like this? foldl (<*>) (pure succ) [[1,2]]
14:06:53 <dcoutts_> dons: eg imaging building all of hackage, if one package fails then we don't want to go and build the packages that depend on the one that failed
14:07:06 <dons> right.
14:07:09 <dcoutts_> dons: and we do not want to report those as build failures too, only the one that actually failes
14:07:30 <dons> phlpp: gtk2hs would be a good choice though. however, there are smaller libs (X11, wxHaskell). dcoutts_ would know the options
14:07:32 <dcoutts_> dons: I'm using Data.Graph, which fortunately is in containers so Cabal can use it
14:07:32 <allbery_b> phlpp: SOE but it generally sits on top of something heavier
14:07:38 <Saizan> ?type foldl (<*>)
14:07:39 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:07:39 <lambdabot>       Expected type: f (a -> b) -> f a -> f (a -> b)
14:07:39 <lambdabot>       Inferred type: f (a -> b) -> f a -> f b
14:08:04 <opqdonut> :t <*>
14:08:04 <lambdabot> parse error on input `<*>'
14:08:08 <opqdonut> :t (<*>)
14:08:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:08:15 <dcoutts_> phlpp: yes, there's SOE, and there are versions of that for gtk2hs or a standalone version
14:08:17 <smack_> allbery_b: gtk2hs's SOE is pretty easy to use
14:08:22 <smack_> er, Philippa
14:08:24 <Saizan> Sizu1: becuase you can't unify f (a -> b) -> f a -> f b with a -> b -> a
14:08:24 <smack_> er..
14:08:29 <allbery_b> heh
14:08:31 <dcoutts_> smack_: :-)
14:09:02 <phlpp> hm ok
14:09:07 <Sizu1> @src foldl
14:09:07 <lambdabot> foldl f z xs = lgo z xs
14:09:07 <lambdabot>     where lgo z []     =  z
14:09:07 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:09:09 <phlpp> thanks :>
14:09:28 <MarcWeber> dcoutts_: Is it a new convention that all packages have a version format of x.x.0.0 ?
14:10:20 <allbery_b> yes
14:10:57 <Sizu1> eh, do we have an abstraction of folds already?
14:11:10 <atp> Foldable
14:11:13 <EvilTerran> Data.Foldable?
14:11:14 <dcoutts_> MarcWeber: there's the package version policy
14:11:20 <atp> Foldable is the bomb
14:11:32 <Sizu1> @instances Foldable
14:11:33 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:11:40 <dcoutts_> MarcWeber: http://haskell.org/haskellwiki/Package_versioning_policy
14:11:41 <EvilTerran> i'd've thought a bomb was more Explodable than Foldable
14:11:43 <Sizu1> @instances Data.Foldable.Foldable
14:11:52 <allbery_b> @instances-importing Data.Foldable Foldable
14:11:52 <lambdabot> Maybe, []
14:12:00 <allbery_b> hm
14:12:07 <atp> I think we should just take fold{l,r} out of the Prelude entirely
14:12:15 <EvilTerran> ...
14:12:18 <allbery_b> @instances-importing Data.Foldable Data.Map Foldable
14:12:19 <lambdabot> Map k, Maybe, []
14:12:30 <atp> or rather, have Prelude get them from Data.Foldable
14:12:44 <dcoutts_> MarcWeber: basically it's Major.Major.Minor.Micro, meaning Major for api incompatible changes, minor for api compatible extensions, micro for changes that do not change api at all
14:12:58 <dcoutts_> MarcWeber: that only makes sense for libs though really
14:13:17 <ddarius> Why two majors?  So many API incompatible changes?
14:13:37 <dcoutts_> ddarius: people often attach special significance to the first version number
14:13:47 <MarcWeber> Thanks. @ dcoutts_ :)
14:14:18 <dcoutts_> ddarius: it'd be a bit annoying to have to go from 1.0 to 2.0 just because of some minor api change and people often think of 0.x being special
14:14:38 <EvilTerran> "beta"
14:14:40 <Sizu1> atp: you mean as well making map = fmap = (<*>) . pure?
14:15:01 <EvilTerran> Sizu1, and (.) ;)
14:15:08 <dcoutts_> MarcWeber: also, by including that trailing .0 one can always append .$snapshot without breaking anything
14:15:15 <EvilTerran> although  fmap = (<*>) . pure would be bad, as not all Functors are Applicative
14:15:30 <Sizu1> no?
14:15:37 <Axioplase> 0
14:15:45 <Axioplase> (sorry)
14:15:57 <MarcWeber> dcoutts_: Perhaps we should replace all the text on the wike with those three lines you've written now :) I think it's great this way. Then you konw that a package will work with a newer minor number even if constraints are missing.
14:16:02 <EvilTerran> ?instances Functor
14:16:03 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:16:07 <EvilTerran> ?instances Applicative
14:16:07 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
14:16:15 <EvilTerran> ?instances-importing Control.Applicative Applicative
14:16:16 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
14:16:28 <EvilTerran> hmm
14:16:35 <ddarius> Yay cabal haddock
14:16:50 <EvilTerran> someone give me an example here ;)
14:17:21 <Sizu1> iirc, Functor -> Applicable
14:17:22 <dcoutts_> MarcWeber: feel free to improve the explanation on the wiki, we're also planning to add a syntax to take advantage of those kinds of version numbers, like foo == 1.2.* or something meaning foo >= 1.2 && < 1.3
14:17:29 <ddarius> Sizu1: Other way
14:17:55 <ddarius> EvilTerran: Every one of those Functor instances are monads.
14:17:56 <Sizu1> if Applicable then Functor?
14:18:00 <dcoutts_> MarcWeber: we may also be able to get hackage to check for conformance with the policy, though probably on an opt-in basis
14:18:02 <ddarius> Sizu1: Yes.
14:18:07 <gwern> we have no free will, ghc has proven it - 'Not in scope: `mkchoices''
14:18:08 <shachaf> class (Functor f) => Applicative f
14:18:46 <shachaf> And class (Applicative m) => Monad m, in theory.
14:18:51 <Sizu1> -> in an "implies" sense
14:19:06 <MarcWeber> dcoutts_: Overall great news.
14:19:22 <dcoutts_> MarcWeber: needs someone to implement it though ;-)
14:20:02 <hpaste>  atp pasted "gaussian elimination" at http://hpaste.org/4979
14:20:05 <atp> i'm getting a wacky type error in the ST monad.
14:20:29 <atp> i wrote a program that does simple gaussian elimination on a matrix as a way to play with ST
14:21:04 <dons> its annoying that the Either monad instance isn't in base.
14:21:06 <atp> can anyone help me out?
14:21:18 <ddarius> atp: Not if you don't say what the error is.
14:21:33 <atp> ddarius: i'm worried about flooding the channel?
14:21:43 <shachaf> @paste?
14:21:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:21:58 <atp> ddarius: if you don't mind joining #flood i'll paste it
14:22:03 <atp> ddarius: i'm sure it's something silly
14:22:05 <ddarius> atp: Just annotate your paste
14:22:16 <avm> dcoutts_, do you use the support for package.conf.d in ghc-6.8? It seems that Cabal does not play well with it right now?
14:22:25 <hpaste>  (anonymous) annotated "gaussian elimination" with "(no title)" at http://hpaste.org/4979#a1
14:22:30 <atp> there you go
14:22:45 <dcoutts_> avm: I do not, I've not seen any use of it.
14:23:04 <avm> dcoutts_, I thought you were the one who submitted the initial patch?
14:23:13 <dcoutts_> avm: I did yes
14:24:15 <dcoutts_> avm: as for cabal, currently cabal does not support using a user-specified package database
14:24:36 <dcoutts_> though it sort-of does internally so exposing it in the UI should be straightforward
14:24:47 <dcoutts_> avm: the main advantage is for package managers
14:24:54 <avm> dcoutts_, Cabal only reads the firstFile from ghc-pkg's output
14:25:04 <avm> (when reading --global config)
14:25:25 <dcoutts_> avm: yes, when using --global it looks only in the global db for good reason
14:25:29 <avm> actually, I'm trying to put Haskell packaging into shape for ALT Linux
14:25:29 <atp> ddarius: i'm confused as to why it can't infer that a1 and a are both the same
14:25:36 <ddarius> atp: Because they aren't.
14:25:51 <atp> ddarius: yeah, but where have i gone wrong?
14:25:54 <ddarius> You are saying that matrix works for all a's not the same one in the outer scope.
14:25:58 <dcoutts_> avm: then perhaps you'll help test support in cabal for using specific package dbs
14:26:27 <dcoutts_> avm: so is that what you're tring to do, to use a different package db from the global or user one?
14:26:27 <avm> dcoutts_, yes, I'd love to
14:26:29 <ddarius> atp: The easiest H98 solution is drop the inner type signature(s).  Using the extension of Scoped type variables you can say that they ar ethe saem.
14:26:48 <avm> dcoutts_, I'm trying to put a tiny package DB in every RPM package
14:26:56 <atp> ddarius: you think if i remove all the type signatures it will work?
14:27:14 <atp> ddarius: i normally don't type inside functions, but this was a bit complex and so i wanted to clarify...
14:27:17 <EvilTerran> you may also be able to do something with asTypeOf
14:27:21 <atp> ddarius: (for myself)
14:27:25 <dcoutts_> avm: are you working with the darcs development version of Cabal? If so I can darcs send you a patch to test
14:27:43 <atp> ddarius: out of curiosity, how do scoped type variables work?
14:28:02 <avm> dcoutts_, I can switch to the darcs version
14:28:18 <dcoutts_> avm: of course you can already generate a package file to pass to ghc-pkg, and presumably that's the same format as one drops into a package.conf.d dir, so perhaps you do not need any other specific support?
14:28:46 <dcoutts_> avm: cabal register --gen-pkg-config=foo.pkg
14:28:51 <ddarius> atp: The variables of an outer scope are viewed as bound within the entire body of the function rather than just in the rest of the type.  I believe you need to explicitly use a 'forall' for it to be enabled (as well as enabling the extension)
14:29:19 <dcoutts_> avm: and feature is supported in the version cabal that comes with ghc-6.8.2
14:29:37 <atp> ddarius: you mean the type of solveMatrix needs to be forall a. Fractional a => [[a]] -> [a] ?
14:29:44 <ddarius> atp: Yes.
14:29:51 <phlpp> @src pure
14:29:51 <lambdabot> Source not found. I feel much better now.
14:29:59 <ddarius> That's identical to the current type, just more explicit.
14:30:07 <atp> ddarius: ok, let me try.
14:30:14 <phlpp> seems like i misunderstood sth. ;]
14:30:16 <allbery_b> pure is a method, of both Control.Arrow and Control.Applicative
14:30:21 <avm> dcoutts_, actually it works with my ghc-pkg (it shows lots of package DBs, with corresponding packages inside), but Cabal discards ghc-pkg's output beyond the first DB
14:30:27 <allbery_b> @src Applicative
14:30:27 <lambdabot> class Functor f => Applicative f where
14:30:27 <lambdabot>     pure  :: a -> f a
14:30:27 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:30:30 <avm> dcoutts_, you said it was for a good reason
14:30:41 <phlpp> ah!
14:30:48 <phlpp> so return for functors actually?
14:31:04 <avm> dcoutts_, (I hope I'm not wasting your time too heavily? maybe I should write a letter to cabal-devel or something)
14:31:08 <allbery_b> sort of.  read the applicative paper
14:31:18 <dcoutts_> avm: for example if we were to satisfy dependencies from the user package db then when we registered the package globally then it'd be missing deps that exist in the user but not global db and registration would fail
14:31:30 <phlpp> where to find? haskell.org?
14:31:41 <Cale> phlpp: Applicative is a little more than just return
14:31:41 <dcoutts_> avm: I don't mind talking about it at all :-)
14:31:51 <Cale> phlpp: It's return together with something like ap
14:31:52 <allbery_b> @go applicative programming with effects
14:31:56 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
14:31:56 <lambdabot> Title: Applicative Programming with Effects
14:32:21 <avm> dcoutts_, I build packages in a controlled environment, where the user DB is guaranteed to be empty
14:32:28 <dcoutts_> avm: in ghc 6.9, ghc-pkg --global lists *only* the packages in the global db which is exactly what cabal wants
14:32:48 <gwern> so I've been trying to figure out, how could a declaration ' newtype Monad m => TU a m = MkTU (forall x. Data x => x -> m a)' be legal?
14:33:09 <avm> dcoutts_, I think I'm going to replace firstFile with, er, globalFiles in my build of Cabal
14:33:13 <phlpp> thanks
14:33:32 <dcoutts_> avm: so for example if we wanted to get deps from the global and an additional package db then we'd use ghc-pkg list --simple-output --global --package-conf=foo.package.conf
14:33:54 <dcoutts_> avm: have you tried hacking it just by using --user ?
14:34:13 <atp> ddarius: adding the forall s. didn't work.  i tried commenting out the inner types, and i got a "Inferred type is less polymorphic than expected" erro (i've never seen that before)
14:34:28 <ddarius> forall s?
14:34:51 <ddarius> atp: Post the new code with the new error.
14:34:57 <atp> ddarius: ok.
14:34:59 <phlpp> is there btw. a newer version of programming in haskell planned? ok, i don't know what to add, maybe about ghc extensions?
14:35:27 <dcoutts_> avm: it's not really that we look only in the first section, it's more that we have to do hacky stuff to get the right info out of ghc-pkg list output, since currently it lists packages from all dbs rather than just global or just user or whatever
14:35:44 <LoganCapaldo> maybe real world haskell will include info about ghc extensions
14:36:25 <phlpp> oh, i don't know this book. furher information on it?
14:36:33 <hpaste>  atp annotated "gaussian elimination" with "(no title)" at http://hpaste.org/4979#a2
14:36:34 <dcoutts_> avm: if you use --user then currently it looks in all sections
14:36:48 <LoganCapaldo> @go real world haskell
14:36:50 <lambdabot> http://www.realworldhaskell.org/
14:36:50 <lambdabot> Title: Real World Haskell
14:37:00 <gwern> sems kind of unlikely, no? it has to cover all of haskell '98 and apply it and probably also cover some librarues
14:37:11 <gwern> I don't really see room there for covering extensions too
14:37:27 <dcoutts_> avm: so if your user db is empty and you get ghc-pkg to look at an extra package db too then --user should do the trick
14:37:33 <atp> ddarius: ever seen an error like that before?
14:37:36 <ddarius> atp: I suspect it's the monomorphism restriction.
14:37:37 <ddarius> atp: Sure.
14:38:06 <dcoutts_> avm: though as I said I've been considering adding a configure --package-db= flag to allow using a specific one, there's some support for that internally but it's not exposed in the UI
14:38:25 <avm> dcoutts_, I think I get it, hacky though it is :-]
14:38:33 <ddarius> atp: What error were you getting when you added forall a to solveMatrix.
14:39:04 <dcoutts_> avm: the real problem is that in current version of ghc the ghc-pkg list is very inflexible and doesn't give us the information we want in the format we'd like so we have lots of hacks :-(
14:39:15 <atp> ddarius: i found a bug in sval (i had writeArray r i v instea of r j v) but that didn't fix the problem, just fyi
14:39:16 <dcoutts_> hia bringert
14:39:25 <atp> ddarius: i got a parse error on =>
14:39:36 <bringert> off to bed
14:39:38 <bringert> dcoutts_: good night
14:39:43 <atp> ddarius: so i wrote forall a. (Fractional a => [[a]] -> [a]) instead
14:39:49 <atp> ddarius: but it didn't seem to do anything
14:40:45 <ddarius> :t undefined :: forall a. Fractional a => [[a]] -> [a]
14:40:47 <lambdabot> forall a. (Fractional a) => [[a]] -> [a]
14:41:02 <ddarius> You shouldn't have gotten a parse error.
14:41:09 <atp> ddarius: let me try again.
14:41:17 * gwern thinks I'm going to give up on StrategyLib. too many errors.
14:41:35 <shachaf> Somebody's using yi?
14:42:41 <atp> ddarius: definitely get a parse error: solveMatrix :: forall a. Fractional a => [[a]] -> [a]
14:42:54 <atp> Matrix.hs:15:38: parse error on input `=>'
14:42:54 <atp> Failed, modules loaded: none.
14:43:21 <shachaf> atp: Perhaps the problem is with the forall?
14:44:12 <ddarius> atp: Are you sure you've enabled the extension?
14:44:13 <dons> shachaf: scary
14:44:15 <atp> shachaf: i added it at ddarius' request... i don't know enough about rank n polymorphism to be sure
14:44:22 <avm> dcoutts_, thank you, --user works for me just fine
14:44:24 <atp> ddarius: oh, do i have to do that?
14:44:26 <ddarius> atp: It has nothing to do with rank-n polymorphism.
14:44:36 <ddarius> atp: Yes, just having forall is an extension.
14:44:53 <dcoutts_> avm: ok, so bear in mind it'll only work for ghc-6.8, in 6.9 that hack will break
14:44:55 <atp> ddarius: ah.  i see.  i thought it would tell me if i needed to turn it on, the way it does with multiparameter classes.
14:45:01 <shachaf> dons: Does that mean that it's actually in a semi-usable state?
14:45:12 <ddarius> It's valid code in Haskell 98, forall is just a type variable then.
14:45:30 <atp> ddarius: oh, i see.  how do i enable it?
14:45:41 <shachaf> ddarius: Is the . valid?
14:45:50 <EvilTerran> ISTR (.) is likewise a type variable without the forall extension
14:46:01 <ddarius> atp: Several ways.  I think the LANGUAGE option is ScopedTypeVariables.
14:46:02 <EvilTerran> just an infix one
14:46:11 <shachaf> Don't you need an extension for infix type variables?
14:46:35 <EvilTerran> mm, true. it probably just parse errors on the (.), actually
14:47:05 <dons> shachaf: its been semi-usable for a long time. (i used to use yi 0.1 exclusively for a week or two)
14:47:17 <atp> so i do {-# LANGUAGE ScopedTypeVariables #-} then?
14:47:22 <ddarius> Yes.
14:47:23 * shachaf got so far as running it for a bit, in vi-mode.
14:47:34 <atp> ddarius: ok.  Let me try.
14:47:52 <EvilTerran> ScopedTypeVariables isn't the one for forall, is it?
14:48:02 <shachaf> It didn't work well enough to replace vim. :-)
14:48:03 <EvilTerran> I thought that was ExistentialTypes or sth
14:48:07 <ddarius> EvilTerran: It should enable that as well as you need it too.
14:48:10 <shachaf> EvilTerran: I think a lot of them do.
14:48:11 <ddarius> EvilTerran: That's a different context.
14:48:20 <byorgey> dons: OOC, what is required to make Yi more than semi-usable?  is there still interest?
14:48:26 <atp> ddarius: now i'm getting a lot of  All of the type variables in the constraint `Fractional a' are already in scope
14:48:26 <atp> 	(at least one must be universally quantified here)
14:48:31 <EvilTerran> ExistentialQuantification?
14:48:40 <atp> atp: is that because i have Fractional a => in the inside functions?
14:48:45 <atp> err ddarius rather
14:48:47 <ddarius> atp: Yeah, you probably need to drop the Fractional contexts.  I suspected it since you already have it on a.
14:48:53 <atp> ddarius: ok.
14:48:57 * shachaf thought yi was mostly treated as proof-of-concept.
14:49:42 <atp> ddarius: woohoo it loaded!
14:50:14 <atp> ddarius: the question now is whether it works, but at least i got past the type errors
14:50:26 <atp> ddarius: now, why was i getting that wacky polymorphism error before?
14:50:36 <gwern> yeah, yi can be fun to work with
14:51:13 <ddarius> atp: Which?
14:51:26 <cjb> has anyone made a screencast of Yi?
14:51:31 <cjb> I'd love to see it in action.
14:51:35 <atp> ddarius: Inferred type is less polymorphic than expected
14:51:45 <atp> ddarius: when i removed the inside type restrictinos
14:51:49 <atp> ddarius: restrictions even
14:52:41 <ddarius> atp: Probably because the monomorphism restriction made matrix and the other value monomorphic fixing the s type variable to a single unbound type rather than quantifying over it.
14:52:49 <gwern> 'I've recently started using Yi, the haskell editor.  I found it slightly non-trivial to get started...' <-- hee hee. no kidding
14:53:04 <EvilTerran> it's the Dreaded Monomorphism Restriction!
14:53:07 <gwern> atp: why not put that tutorial on the haskell wiki?
14:53:58 <atp> gwern: which?
14:54:07 <gwern> atp: 'Succum to peer pressure!'?
14:54:16 <gwern> atp: all of'em. they'd work fine as subpages
14:54:21 <atp> gwern: what?
14:54:27 <atp> gwern: you have me confused with someone else
14:54:32 <gwern> or integrated straight into [[Yi]]
14:54:52 <atp> ddarius: hm.
14:55:27 <gwern> atp != andrew birkett?
14:55:52 <atp> gwern: /=, but yeah :)
14:56:33 <Japsu> @let (!=) = (/=)
14:56:34 <lambdabot> <local>:6:7:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
14:56:46 <Japsu> grr
14:56:49 <atp> i like /=
14:57:02 <atp> like return, it helps confuse imperative programmers :)
14:57:11 <atp> bwahahaha
14:57:15 <Valodim> hardly :P
14:57:26 <shachaf> @let (!=) :: (Eq a) => a -> a -> Bool; (!=) = (/=)
14:57:28 <lambdabot> Defined.
14:57:31 <gwern> wow. how bizarre is that? two fellows starting with a talking about yi at the same time
14:57:35 <resiak> is there any other mainstream language using /= ?
14:57:39 <shachaf> > (!=) == (/=)
14:57:39 <lambdabot>   add an instance declaration for (Eq (a -> a -> Bool))
14:57:40 <lambdabot>     In the expression...
14:57:42 <atp> gwern: i didn't actually talk about yi
14:57:47 <atp> gwern: you're really confused :)
14:58:05 <Japsu> resiak: lua IIRC
14:58:24 * gwern will be quiet now until the confusion passes. I just hope my pet doesn't get eaten before enough turns elapse
14:58:46 <nornagon> @scheck (\a b -> (a != b) == (a /= b :: Int))
14:58:47 <lambdabot> Couldn't match expected type `Int' against inferred type `Bool'
14:58:52 <nornagon> @scheck (\a b -> (a != b) == (a /= (b :: Int)))
14:58:53 <lambdabot>   Completed 169 test(s) without failure.
14:58:59 <nornagon> @check (\a b -> (a != b) == (a /= (b :: Int)))
14:59:00 <lambdabot>  OK, passed 500 tests.
14:59:01 <Japsu> resiak: no, I was wrong, lua uses ~=
14:59:06 <resiak> huh
14:59:23 <atp> resiak: it was common in the old days for ~ to be not
14:59:42 <shachaf> gwern: Your pet?
14:59:52 <atp> resiak: C still uses it for bitwise not
15:00:07 <resiak> sure, I use ~ for not all the time; I've just not seen ~= used before
15:00:31 <resiak> and i'm used to seeing =~ in perl for something entirely different :)
15:00:37 <Japsu> resiak: Ada uses /=
15:00:38 <atp> resiak: yes
15:00:49 <atp> resiak: in Haskell too, i think, =~ is for regexs
15:01:01 <Valodim> ~= iirc
15:01:04 <gwern> (shachaf: nethack joke)
15:01:26 <shachaf> gwern: Can your pet get eaten in Nethack?
15:01:28 <atp> Valodim: really?  that's odd.  why reverse it?
15:01:41 <atp> nethack is win
15:01:50 <ddarius> @hoogle (=~)
15:01:51 <lambdabot> Did you mean: (=~)
15:01:51 <lambdabot> Prelude.undefined :: a
15:01:51 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
15:01:52 <Japsu> shachaf: Your pet can be killed in a multitude of cruel and unusual ways in Nethack.
15:01:53 <Valodim> probably me misremembering
15:02:03 <Japsu> Or just be eaten.
15:02:18 <shachaf> Oh, by a purple worm, I guess.
15:02:23 <atp> nethack is probably still one of the most clever and interesting games around
15:02:31 <nornagon> nethack is awesome
15:02:32 <Japsu> Meh, I prefer ADOM.
15:02:35 <atp> i like how when you're floating, and you go over a sink, you sink
15:02:37 <atp> hehe
15:02:38 * shachaf just didn't understand how the reference was relevant.
15:02:43 <gwern> much less something else
15:02:48 <shachaf> gwern: Oh, the corpse.
15:02:49 <atp> shachaf: it wasn't, i don't think
15:02:54 <Japsu> NetHack references are always relevant.
15:03:00 <shachaf> gwern: But it's not your pet anymore by then. :-)
15:03:06 * shachaf likes ≠.
15:03:13 <gwern> life is nethack
15:03:14 <shachaf> And ¬, probably.
15:03:21 <Japsu> nethack is life
15:03:32 <shachaf> gwern: You're not in #nethack because you use nethack-lisp, right?
15:04:22 <gwern> shachaf: when I play nethack, yeah
15:04:34 <gwern> stupid dev team... 20 years and they still can't support the d-pad?
15:04:45 <shachaf> gwern: There's always Interhack.
15:05:58 * gwern discovers why it's a bad idea to remove /bin/bash on gentoo
15:06:40 <fnord123> is there a nethack mud?
15:07:09 <Eidolos> last place I expected an Interhack discussion..
15:07:28 <shachaf> Eidolos: It was originally pointed out to me in #-blah.
15:07:42 <clanehin> fnord123: there's no multiplayer nethack, but there are nethack servers, see google (since no one's on topic atm anyway)
15:08:01 <Eidolos> telnet nethack.alt.org, it's the one all the cool kids play on..
15:08:22 <clanehin> i've noticed nethack conversations here every few months or so, actually
15:09:22 <shachaf> There's a surprisingly large intersection between #nethack and #haskell.
15:10:24 <Valodim> that's because all the cool kids do haskell and nethack
15:10:54 <atp> i think when you're hiring a programmer, a good litmus test in general is to ask them a nethack question
15:11:00 <atp> if they don't know what nethack is,
15:11:01 <atp> next resume
15:11:08 <phlpp> n8
15:11:22 <gwern> heh. what if they're from windows?
15:11:25 <Eidolos> is it bad that I put nethack expert on my resume?
15:11:27 <gwern> then you could hardly fault them for't
15:11:27 <atp> gwern: like i said
15:11:31 <atp> gwern: next resume
15:11:34 <atp> :)
15:11:35 <shachaf> On the other hand, if they know what Nethack is *too* well... :-)
15:11:42 <atp> shachaf: that's a good point
15:11:47 * gwern sees what you did there
15:11:48 <shachaf> Windows people (can) run Nethack.
15:12:01 <atp> yeah i think there's been an NT port for a while now
15:12:07 <shachaf> My first Nethack game was on DOS or Windows.
15:12:10 <atp> i don't think they even need to build it
15:12:29 <atp> i played it on a dos system once i think... many years ago
15:13:16 <mokus> I remember playing rogue for hours on end on DOS
15:13:39 <mokus> by the time nethack was big, I was kinda burned out on that style game
15:13:42 <atp> mokus: rogue was cool.  but nethack is better, i think.  harder, too.
15:14:05 * ddarius vaguely knows what nethack is, but has no desire to find out more.
15:14:05 <atp> the thing about nethack (and i don't play it often at all anymore) is that it is so incredibly detailed it's staggering
15:14:19 * atp takes the hint.
15:14:51 <SamB> why do you want to install it anyway?
15:14:55 <dons> ?users
15:14:55 <lambdabot> Maximum users seen in #haskell: 458, currently: 423 (92.4%), active: 22 (5.2%)
15:14:56 <SamB> just grab putty...
15:14:58 <gwern> phew! good thing I could scp over another shell to my remote system! as that was the only shell installed, I was in a pretty pickle
15:15:02 <Valodim> yeah
15:15:21 <gwern> I find myself wondering, what datastructure fits nethack best?
15:15:45 <gwern> it uses a tangle of globals and many many conditionals, obviously, but what's the right way?
15:17:12 <atp> gwern: a large monad?
15:17:47 <gwern> that doesn't sound very haskelly. does xmonad uses a large monad? nah, it uses nice zippers and stuff
15:17:56 <atp> gwern: it does actually
15:17:57 <Korollary> What's a large monad?
15:17:59 <atp> gwern: a very nice monad
15:18:02 <atp> gwern: X a
15:18:09 <atp> gwern: read XMonad.hs sometime, it's really nice
15:18:18 <vincenz> hey dons :)
15:18:23 * vincenz went to a great fp-day in utrecht
15:18:27 <dons> vincenz: woot!
15:18:36 <dons> i've been waiting since it was announced almost 12 months ago, vincenz
15:18:41 <dons> do we have videos of the talks?
15:18:55 <gwern> yeah, but that's for encapsulating the reader/writer monads, iirc. for the actual windows and stuff, I'm talking about
15:19:23 <dons> yep. the core is pure.
15:20:01 <gwern> right. what would a pure core for a nethack-alike be? it's interesting to consider
15:20:43 <clanehin> I'd certainly love to hear any ideas on that topic.
15:20:59 <nelhage> nethack is interesting in that there are _so many special cases_
15:21:11 <atp> you could probably make a nested zipper for the position or something
15:21:19 <nelhage> Like, virtually every possible interaction between any two pairs of anything is special-cased somehow
15:21:47 <atp> or alternatively, some sort of tree...
15:21:51 <shachaf> nelhage: Which is not always a positive thing.
15:22:01 <gwern> nelhage: I think you could take that out of the code and into data
15:22:07 <nelhage> Well, in terms of the code, it's horrible.
15:22:08 <atp> gwern: i'm not sure
15:22:13 <nelhage> But it's what makes the game so rich
15:22:15 <gwern> that would be better, actually, just from the extensibility standpoint
15:22:22 <atp> gwern: the special cases are many
15:22:27 <atp> gwern: and all different
15:23:14 <nelhage> I don't think you can pull them into pure data. You could probably pull them into some (large) set of ``hooks'' that modules could add code to
15:23:31 <gwern> atp: you could say the same thing about emacs; doesn't stop yi from being interesting and probably better in at least the dynamic respect
15:23:42 <nelhage> But I think it would take a _lot_ of thought to support all the kinds of possibilities the current game supprts
15:24:05 <Eidolos> 20 years worth of thought :)
15:24:10 <atp> gwern: i don't think emacs has many special cases.  it's basically just an e-lisp engine.
15:24:13 <nelhage> Quite possibly :)
15:24:50 * atp sighs -18 C
15:24:51 <gwern> atp: the libraries...
15:24:57 <nelhage> ``Nethackskell''
15:24:58 <dons> atp, wow.
15:25:05 <gwern> nelhage: fortunately, all that thought has already been done? :)
15:25:10 <atp> dons: it was -25 yesterday :/
15:25:20 <atp> dons: at least there is no wind
15:25:38 <gwern> nelhage: well, any haskeller would do it over darcs, so Darkhack? :)
15:25:48 <resiak> nethask?
15:25:53 <atp> ooo
15:25:54 <nelhage> gwern: No, AFAIK the current codebase makes no attempt to be modular or easily extensible, it just relies on people being willing to dig into mounds and mounds of horribly nested C code
15:25:54 <atp> i like that
15:26:16 <atp> nelhage: for all that, it is surprisingly stable... i've never had it crash
15:26:36 <Korollary> in a true haskell game users would submit haskell code as their agents
15:26:43 <gwern> mm. I've had it crash, but I was running it in emacs so it's more complex than your usual terminal
15:26:51 <dons> atp, where are you located?
15:26:55 <gwern> Korollary: Lambda Wars!
15:26:56 <jcreigh> Korollary: so with hpaste, does that make #haskell an RPG? :)
15:26:57 <atp> dons: alaska
15:27:02 <atp> dons: just moved here two weeks ago
15:27:05 <gwern> er, Lambda War, sry. Core War was singular
15:27:29 <Korollary> Battle of the Weak Heads
15:27:32 <ddarius> Core War would be a lot less interesting in a pure language.
15:27:45 <Eidolos> atp: heh, there are very many serious bugs in the current version. like abusing dangling pointers to get infinite wishes
15:27:47 <kosmikus> I was considering having a roguelike programming project in my upcoming AFP course ...
15:27:49 <atp> dons: but because there's not much wind, it's actually not as bad as say, -10 in beijing
15:28:34 <dons> atp, ah :) its a fine, sunny day here in Portland/OR. first time in about 3 months though :)
15:28:35 <atp> it's unbelievably beautiful today though... sunny, the mountains are jagged against the sky
15:28:39 <nelhage> Eidolos: Oh, someone figured out how to turn that into infinite wishes?
15:28:41 <Eidolos> and I had it crash the other day when I left a thousand daggers on a land mine. a dagger hit me which killed me, and the game panicked because it didn't know how to save flying daggers in the bones file. :)
15:28:48 <dons> atp, oh, sunny, but freezing cold?
15:28:50 <nelhage> Last I heard, it was just infinite lifesaving :)
15:28:51 <atp> dons: portland is nice though, even if it is overcast most of the time
15:29:04 <Valodim> ahahaha
15:29:09 <gwern> heh, it could be like The Sims - an offline mmrpg
15:29:12 <Valodim> great
15:29:12 <atp> dons: yeah.  it's generally much warmer when it snows.  the last week or so was pretty much constant dumping and it was generally around -8 or so
15:29:16 <Eidolos> nelhage: you trick nethack into thinking you're wearing the wand, then you can use scroll of enchant armor
15:29:16 <gwern> Eidolos: interesting!
15:29:37 <nelhage> Clever.
15:29:49 <dufflebunk> I recall reading about a spreadsheet in haskell a few weeks ago, it allowed embedding gnuplots... but I can't recall the name. Doesn't anyone know what I'm talking about?
15:29:59 <Eidolos> yeah the guy who finds all these bugs is a good friend of mine.. a genius but he spends most of his time playing snes :/
15:30:09 <atp> that would be nice.  i work in finance for my day job, and if excel allowed haskell instead of vb, i would be in heaven
15:30:33 <ddarius> The SNES was a great system.
15:30:57 <thoughtpolice> street fighter 2 for life.
15:31:04 <Korollary> Shoryuken!
15:31:06 <dons> dufflebunk: i think that was the nyc-fp group's talk.
15:31:19 <dons> atp, you should talk to the Credit Suisse guys -- they embed haskell in their excel..
15:31:28 <thoughtpolice> Hadouken!
15:31:38 <dons> atp, there's papers on it (talk to augustuss or Heffalump)
15:31:47 <Valodim> Shoryuureppaa
15:32:03 <dons> dufflebunk: http://contracts.scheming.org/ ?
15:32:03 <lambdabot> Title: Composing Contracts
15:32:19 <dons> Valodim: do you have a Haskell question?
15:32:34 <Valodim> nope :)
15:33:31 <byorgey> atp: funny, my sister-in-law just moved to AK two weeks ago =)
15:33:44 <dufflebunk> dons: No, this was a GUI application. Perhaps it wasn't haskell. Perhaps I'm just on crack.
15:33:48 <atp> dons: that's awesome
15:34:02 <atp> byorgey: oh yeah?  neat.
15:34:06 <atp> byorgey: where?  i'm in anchorage
15:34:31 <dons> i'm trying to get byorgey to move to portland.
15:34:40 <atp> where is he now?
15:34:46 <byorgey> atp: yes, she moved to anchorage also.
15:34:46 <dons> and then sjanssen, too.
15:34:53 <byorgey> atp: washington, dc
15:34:54 <dons> then we'll have all our xmonad eggs in one basket.
15:34:54 <jfredett> yall should move out to Boston
15:34:55 <jfredett> :P
15:35:01 <dons> jfredett: you and shapr, eh?
15:35:18 <atp> byorgey: portland is nice, actually.  and the weather is more mild than washington
15:35:18 <jfredett> lol, I live in Worcester, but I'm close to Boston
15:35:19 <jfredett> :)
15:36:17 <byorgey> I wouldn't mind moving to portland! =)
15:36:33 <fnord123> Any plans to make fancy effects with XMonad and AIGLX?
15:37:06 <cjb> I think xmonad already has some compositing support?
15:37:09 <byorgey> it kind of depends on what grad schools accept me and so on. =)
15:37:17 <dons> fnord123: compositing, actually, is the future for glitzy
15:37:31 <atp> byorgey: you gonna do the phd?
15:37:45 <byorgey> atp: that's the plan.
15:38:02 <atp> byorgey: in CS?  fp research?  or something else
15:38:02 <byorgey> atp: one of the places I applied is PSU.
15:38:14 <byorgey> atp: yes, and yes (hopefully).
15:38:24 <atp> byorgey: who's at PSU that you want to work with?
15:38:32 <dons> which would be awesome. we need to get a new generation of fp phd's into place
15:38:39 <Korollary> goalieca: why is Luongo not going to the all star game?
15:38:41 <dons> now that the internet boom phds are running out of time to submit
15:38:55 <dons> sjanssen: thinking of graduating soon? :)
15:39:10 <ddarius> > filter isSpace ['\0' .. '\255']
15:39:13 <lambdabot>  "\t\n\v\f\r \160"
15:39:19 <byorgey> atp: Tim Sheard, Mark Jones, Andrew Tolmach, Jim Hook,... others whose names I'm not thinking of at the moment...
15:39:40 <atp> you know who would be cool to do a phd with?  those estonian guys... uustalu and vene
15:39:47 <atp> byorgey: ah
15:39:54 <atp> byorgey: is PSU your first choice?
15:39:54 <byorgey> atp: indeed, that would be cool =)
15:40:04 <atp> yeah, they write awesome papers
15:40:09 <goalieca> Korollary, because his wife is pregnant
15:40:13 <atp> seems like a lot of cool pl research is happening in europe these days
15:40:15 <byorgey> atp: it's pretty high up there, yeah
15:40:24 <atp> byorgey: well, good luck
15:40:28 <byorgey> atp: thanks! =)
15:40:32 <fnord123> dons: glitzy? Any irc log on previous discsussions that might explain the plans in further details?
15:41:02 <dons> there's an open ticket on the bug tracker, with the discussion
15:42:36 <fnord123> For lurkers: http://code.google.com/p/xmonad/issues/detail?id=19
15:42:37 <lambdabot> Title: Issue 19 - xmonad - Google Code
15:43:37 <sjanssen> fnord123: there aren't any concrete plans for compositing
15:57:16 <MarcWeber> dcoutts_: Does cabal support installing source / tags as well today? If not I'd like to start implementing it within the next 2 month (don't know when I'll have time to do it yet)
15:59:28 <dcoutts_> MarcWeber: please go ahead. Start with adding a feature request bug, link it to a wiki page with the design if you think it's sensible
16:00:31 <dcoutts_> MarcWeber: we can already build and install haddock docs linked to colourised html code, that uses hscolour
16:00:51 <dcoutts_> the syntax highlighted code can be built on it's own too, though I've never tried installing it without the docs too so dunno if that works
16:01:09 <dcoutts_> but it'd make sense to also be able to generate tags
16:01:11 <MarcWeber> dcoutts_: There are many cases only code tells me what is happening. Yes. I'll add a ticket.
16:01:30 <dcoutts_> MarcWeber: what tags program would it use?
16:02:09 <MarcWeber> dcoutts_: Good question. One is shipping with ghc (I had to patch it to find some operators) But there are at least 2 different and ghci can generate them as well.
16:02:34 <ddarius> Data.ByteString.Char8.ByteString is a distinct type from Data.ByteString.ByteString yes?
16:02:53 <dcoutts_> ddarius: no, alias, but many of the operations treat it differently
16:02:56 <MarcWeber> dcoutts_: THat's what I've in mind: fire up vim, let vim read the .cabal file, ask the package db which tag files are used .. ande jump to definitions easily..
16:03:08 <ddarius> dcoutts_: Okay.
16:03:37 <dcoutts_> MarcWeber: oh, so you don't mean generating and installing tags?
16:05:02 <MarcWeber> Sure. I'd like to install the lib files, the .hs files and a tag file. Then I'd like to query this information using ghc-pkg.
16:05:53 <dcoutts_> ah ok, the latter is a bit more tricky as you'd have to extend the InstalledPackageInfo structure and changes to that have to by synchronised with all the haskell implementations
16:06:37 <dcoutts_> MarcWeber: it'd be easier initially to rely on a convention for finding the tags and src relative to the haddock docs
16:06:58 <MarcWeber> dcoutts_: I depend on tags :) So there is no other option. And this could be used with nix as well..
16:07:17 <MarcWeber> I'll add a ticket open for discussion. It will be sent to cabal-devel anyway..
16:07:40 <dcoutts_> MarcWeber: well if you want to change InstalledPackageInfo you need to be clear about that and inform everyone, particularly the ghc devs
16:08:16 <MarcWeber> dcoutts_: I will not within the next 7 days.. That's sure. But I'd like to know wether someone has started working on something like this.. Or what other could need as well
16:09:10 <dcoutts_> MarcWeber: ok, well open the bug and sketch your ideas in the bug or a hackage wiki page to other people can see what you're thinking about
16:09:19 <dcoutts_> to/so
16:11:32 <TomMD> @users
16:11:32 <lambdabot> Maximum users seen in #haskell: 458, currently: 424 (92.6%), active: 10 (2.4%)
16:14:52 <ddarius> dons: Do you have suggestions for the interface for a JSON library from your experience?
16:16:18 <dons> yeah, let's see.
16:16:35 <dons>   , encode -- :: JSON a => a -> String
16:16:35 <dons>   , decode -- :: JSON a => String -> Either String a
16:16:38 <dons> something like that :)
16:16:45 <dons> so similar to Data.Binary or Read/Show
16:19:47 <Nafai> Yay!  I'm going to try to follow the new instructions up for getting Yi up and going
16:23:03 <TomMD> dcoutts_: What is it you want done about weird version numbers (ex: 1.04 mapping to 1.4)?  Throw an error?  Or parse it in a smarter way (1.4 < 1.10, 1.04 /= 1.4, 1.04 < 1.1, 1.4 > 1.1, etc)
16:23:49 <dcoutts_> TomMD: we already parse it ok, ie 1.04 -> 1.4, however the suggestion is that if there is such redundancy then we should warn
16:23:59 <TomMD> I see
16:24:10 <dcoutts_> TomMD: so we could check that by seeing if the original is different from parsing then showing
16:24:43 <dcoutts_> eg parse "1.04" = Version [1,4]
16:24:45 <TomMD> dcoutts_: I understand.  Should be simple enough.
16:24:55 <dcoutts_> but then show (Version [1,4]) = "1.4"
16:25:10 <dcoutts_> so then we just compare "1.04" with "1.4" and warn if they're different
16:25:28 <dcoutts_> TomMD: the most tricky bit is knowing where to do the check
16:25:37 <TSC> How can I run a shell command with a timeout, like lambdabot does?
16:25:41 <TSC> (sort of)
16:26:07 <dcoutts_> TomMD: though I think the parse utils have some support for generating warning while parsing I think, which are collected up at the end and displayed
16:26:32 <dcoutts_> TomMD: I don't think we make much use of that feature, but this would be an obvious thing to use it for
16:26:34 <TomMD> dcoutts_: Which is why I'm hunting 'easy' tasks, cause I have no clue where to look - this forces me to pour though a bit of cabal code.
16:26:54 <dcoutts_> TomMD: right :-) well for this one check out Distribution.ParseUtils
16:27:16 <TomMD> Sounds good :-)
16:27:53 <dcoutts_> TomMD: as you've probably noticed, the Distribution.* is mostly just declaring data structures and parsing routines and a few generic utils, all the tricky stuff that's just used for building is under Distribution.Simple.*
16:28:02 <dcoutts_> the so-called "simple" build system
16:28:21 <dcoutts_> simple as in, makes life simple for you, not because it's internally simple :-)
16:28:37 * dcoutts_ -> bed
16:28:40 <dcoutts_> g'night folks
16:28:46 <dcoutts_> TomMD: have fun :-0
16:28:53 <TomMD> Will do, good night.
16:33:57 <MarcWeber> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/207#preview Where is the right place to discuss? Mailinglist (which) or Trac ?
16:33:59 <lambdabot> Title: #207 (Jumping to code every and anywhere: What about installing source files and ...
16:44:16 <ddarius> @src Applicative
16:44:16 <lambdabot> class Functor f => Applicative f where
16:44:16 <lambdabot>     pure  :: a -> f a
16:44:16 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:50:48 <dons> wow, this yi tutorial/collectoin page is awesome.
16:51:02 <LoganCapaldo> linkage
16:51:04 <dons> heaps of stuff -- that i didn't know yi could do.
16:51:04 <dons>   http://nobugs.org/developer/yi/
16:51:05 <lambdabot> Title: Getting started with Yi, the haskell editor
16:51:07 <LoganCapaldo> pleasse
16:52:40 <ddarius> Joy
16:52:41 <LoganCapaldo> and thank you
16:52:43 <Tac-Tics>  Yi is an emacs-like editor written in haskell. It is, as they say, made of awesome.... that's the best explanation for a piece of software ever
16:52:55 * ddarius changed fmap (fmap (fmap (fmap f))) to liftM (fmap (liftM (fmap f)))
16:53:03 <monochrom> hahaha
16:54:08 * conal likes thinking of fmap and first as semantic editor combinators.
16:54:19 <gwern> dons: didn't you help write yi? :)
16:54:21 <BMeph> "The book doesn't spend very much time explaining monads, which are heavily used in Yi. But over the last few years there have been a billion monad tutorials written on the web."
16:54:47 <dons> i like this guy a lot :)
16:54:51 * gwern has been wondering - are there any publications mentioning yi besides "Dynamic Applications From the Ground Up". ?
16:55:17 <dons> gwern: hmm. possibly. look for pubs that reference that paper
16:55:42 <dons> Cited by 4
16:56:04 <LoganCapaldo> wow that site really is a treasure trove
16:56:05 <dons> its cited in "Open data types and open functions ", "Reboots are for Hardware: Challenges and Solutions to Updating an Operating System on the Fly ", "Solving the expression problem in Haskell with true separate compilation",
16:56:11 <LoganCapaldo> I might have to start playing with Yi
16:56:18 * gwern doesn't know how to find papers citing it!
16:56:22 <LoganCapaldo> (again, but I didn't try very hard the first time)
16:56:31 <ddarius> gwern: Citeseer?
16:56:33 <dons> cool, "Plugging Haskell In" is up to 15 cites.
16:56:38 <dons> gwern: scholar.google.com
16:57:43 <gwern> dons: thnz
16:58:25 * gwern eats a strawberry smoothie with wood in it. I accidentaly hit the stirring spoon against the blender blades
16:58:38 <r3m0t> gwern: yuck
16:58:46 <dons> yow
16:59:26 <dons> "Haskell is the new scala, which is the new erlang, which is the new ruby"
16:59:46 <dons> do we know Andrew Birkett?
17:00:07 <allbery_b> ...which is the new perl.  now that's a scary chain
17:00:12 <dons> (he works for Amazon, interesting)
17:00:27 <dons> allbery_b: and epigram will be next, following that logic, i think
17:00:32 <dons> ever increasing type safety
17:00:42 <gwern> r3m0t: well, when I realized what I did, I blended it really really well. the wood pieces is tiny-winy
17:00:50 <Nafai> dons: I'm trying out his instructions for building yi as we speak!
17:00:52 <dons> gwern: that sounds dangerous
17:00:57 <idnar> wait, erlang is the new ruby?
17:00:59 <r3m0t> gwern: like the gold drinks
17:01:00 <gwern> (*are? i is lolcat now?)
17:01:05 <r3m0t> idnar: haskell is the new lisp?
17:01:18 <monochrom> haskell is the new haskell
17:01:18 <r3m0t> C is the new cobol? I could go on
17:01:26 <gwern> 'You still have absurdities like 2^64=0, 7/2=3, simple expressions like x/y and a[x] which the compiler accepts yet aren't actually typesafe in any reasonable definition of the term, arrays have serious typing flaws, and the basic confusion between things and references to things remains.' <-- I think we should no longer use the phrase 'type-safe'. we should just say 'makes sense'
17:01:30 <idnar> I thought Haskell was older than Ruby
17:01:57 <gwern> as in, 'dynamic languages let you write programs that don't make sense'
17:02:24 <r3m0t> you can't assign 0 to 2^64. what do they mean?
17:02:36 <idnar> s/=/==/ probably
17:02:39 <Lycurgus> Haskell is older than Ruby.
17:03:04 <twanvl> > let 2^64=0 in 2^64
17:03:06 <lambdabot>  0
17:03:11 <dons> gwern: where's that from?
17:03:16 <dons> > 2^64
17:03:16 <lambdabot>  18446744073709551616
17:03:31 <resiak> > (2::Int) ^ 64
17:03:31 <IvdSangen> gwern: functional languages do that too, it is a matter in how much they do it
17:03:31 <lambdabot>  0
17:03:39 <r3m0t> ok... wait what
17:04:03 <Lycurgus> (ie Miranda/Haskell is older)
17:04:05 <gwern> r3m0t: I hope the wood will be as chemically inert as the gold, yes. but I'm sure I ate much more dangerous things as a kid...
17:04:09 <gwern> dons: http://lambda-the-ultimate.org/classic/message6475.html#6501
17:04:09 <lambdabot> Title: LtU Classic Archives
17:04:14 <r3m0t> > ((2::Int)^64,(2::Integer)^64,2^64)
17:04:14 <lambdabot>  (0,18446744073709551616,18446744073709551616)
17:04:20 * gwern reflects that justifying something by saying 'it probably isn't worse than something you did as a kid' isn't really a good justification
17:04:40 * IvdSangen would agree with gwern
17:04:50 <resiak> r3m0t: 2^64 is defaulting to Integer
17:05:12 <r3m0t> > ((2::Int)^64,(2::Integer)^64,2^64) where 64=63
17:05:12 <lambdabot>  Parse error at "where" (column 36)
17:05:14 <monochrom> 0=2^n is orthogonal to functional programming
17:05:25 <r3m0t> > let 64=63 in ((2::Int)^64,(2::Integer)^64,2^64)
17:05:26 <lambdabot>  (0,18446744073709551616,18446744073709551616)
17:05:26 <Lycurgus> even Haskell 1.0 was 5 years before Ruby.
17:05:47 <gwern> > (2::Integer)^64
17:05:47 <lambdabot>  18446744073709551616
17:06:13 <monochrom> > case 63 of 64 -> "whee"
17:06:14 <lambdabot>   Non-exhaustive patterns in case
17:07:18 <gwern> 'Also, I think that in twenty years there will no longer be any debate about static vs. dynamic typing, and that instead most languages will instead provide a smooth continuum between the two, as people realize that there is no fundamental dichotomy there. Also languages will have more than one level of types: the types themselves will have types, and so on. But we will be able to treat types in a similar way to the way in which we treat values: we ...
17:07:25 <gwern> ... will be doing computations with them.' <-- dunno gradual typing still isn't solved, and I'm not sure 20 years is enough time for it to be solved, implemented, and also make it to the mainstream
17:07:28 <IvdSangen> let 63=64 in case 63 of 64 -> "whee"
17:07:36 <IvdSangen> > let 63=64 in case 63 of 64 -> "whee"
17:07:37 <lambdabot>   Non-exhaustive patterns in case
17:08:12 <dolio> "let 63 = 64 in" isn't a symbol definition. It's a pattern match of "63" against "64".
17:08:24 <IvdSangen> it redefines =?
17:08:35 <dolio> But it never gets evaluated, because there's no need.
17:09:19 <IvdSangen> > let 63=64 in if 63=64 then "yes" else "no"
17:09:19 <lambdabot>  Parse error at "=64" (column 19)
17:09:55 <idnar> > let 63=64 in if 63==64 then "yes" else "no"
17:09:55 <lambdabot>  "no"
17:10:08 <sjanssen> IvdSangen: = is built-in syntax that can't be overriden
17:10:32 <IvdSangen> okay
17:10:53 <dons> dcoutts_: running hpc report at the end of a test run is really useful
17:11:00 <dons> e.g.
17:11:00 <dons> Cases: 158  Tried: 158  Errors: 0  Failures: 0
17:11:00 <dons> hpc report --decl-list       --exclude=Main Unit
17:11:00 <dons> 100% expressions used (190/190)
17:11:12 <dons> so you get test results and coverage in one swoop
17:11:24 <dons> hpc++
17:11:28 <dolio> > let (h:t) = [] in (1:[])
17:11:29 <lambdabot>  [1]
17:11:38 <dolio> It's like that.
17:12:17 <dolio> That's not a definition of (:), it's a destructuring pattern match defining 'h' and 't'.
17:12:18 <RayNbow> hmm... I was wondering... [] is an instance of the Monad class... would it be useful to make other collection types (for example, Data.Set) also an instance of the Monad class?
17:12:33 <Cale> RayNbow: If it were possible, Set would be an instance of Monad
17:12:39 <dolio> Except in 'let 63 = 64', there's nothing being defined. It's just pattern matching 64 against 63.
17:13:16 <Cale> RayNbow: The problem is that in order to implement bind and/or return, you need an instance of Ord for your element type, which isn't guaranteed by either of those.
17:13:24 <Cale> :t (>>=)
17:13:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:13:48 <RayNbow> why would you need Ord?
17:13:49 <Cale> (nothing here says that a or b will have an instance of Ord)
17:14:16 <Cale> Because in order to build a Data.Set, which is really a binary tree structure, you need to have an ordering on the elements. That's how it gets its efficiency.
17:14:23 <RayNbow> oh right
17:14:43 * RayNbow suddenly sees the light :)
17:14:56 <Cale> One can get around this in a number of ways, but it's been an annoying struggle for some time.
17:15:14 <Cale> Set is really a great example of a monad, it's just not a monad on the full category of Haskell types.
17:16:10 <Cale> There are some changes in the type system in 6.8 which help a bit.
17:16:27 <Cale> Curiously enough, it's now easy to write bind, but hard to write return!
17:20:54 <ddarius> Wow.  There seem to be no minimum requirements for JSON.
17:22:52 <idnar> what sort of minimum requirements?
17:23:10 <ddarius> idnar: The range of integers or characters, the length or level of nesting.
17:23:19 <idnar> ah
17:23:46 <Cale> Shouldn't the assumption be that everything is handled?
17:24:08 <ddarius> Cale: Why would you assume that?  The safe assumption is exactly the opposite.
17:24:14 <Cale> (I suppose that might be a problem with floating point)
17:24:36 <Cale> Well, if it doesn't explicitly say that there's a deepest possible nesting, why assume that there is?
17:25:58 <ddarius> Cale: You have the problem backwards, it gives no minimum to the nesting allowed. I.e. it's perfectly compliant for a JSON implementation to fail because {} is nested to deep or 1 is out of range of the numbers it handles.
17:26:19 <Cale> That's dumb.
17:27:03 <Cale> It should simply require that all possible nestings and integers are handled correctly, up to limitations of memory.
17:27:43 <ddarius> Cale: That, in theory, wouldn't give you any more guarantees.  That said, this isn't a problem in practice.
17:28:03 <idnar> JSON is pretty silly, anyway
17:28:17 <Cale> Why wouldn't it give you any more guarantees?
17:28:38 <Cale> You would at least be able to assume that {} isn't nested too deep.
17:28:45 <ddarius> Cale: I don't know how much memory the machine has.
17:29:08 <Cale> Well, sure. But things are generally allowed to fail if the user hasn't bought enough memory :)
17:29:45 <idnar> to put it another way, it's not as if a JSON implementation can control the amount of memory in the system
17:30:45 <Cale> Provided that there's sufficient free memory for storage, I would expect nestings to be able to go as deeply as you'd like.
17:30:59 <Cale> and integers to be as large as you want
17:32:09 <clanehin> I'm sure ddarius will be right on that new JSON impl . . .
17:33:11 <ricky_clarkson> Pah, use s-expressions.  Those can even be valid Haskell. :)
17:33:33 <twanvl> ?seen Igloo
17:33:33 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 4h 13m 30s ago.
17:36:20 <ddarius> > filter isControl ['\0' .. '\255']
17:36:22 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
17:39:23 <Tac-Tics> > ord '\NUL'
17:39:24 <lambdabot>  0
17:39:55 <Tac-Tics> > map (\x -> (ord x, x)) $ filter isControl ['\0' .. '\255']
17:39:56 <lambdabot>  [(0,'\NUL'),(1,'\SOH'),(2,'\STX'),(3,'\ETX'),(4,'\EOT'),(5,'\ENQ'),(6,'\ACK'...
17:40:43 <Tac-Tics> > show '\0'
17:40:44 <lambdabot>  "'\\NUL'"
17:41:41 <kmcallister> ?type StateT
17:41:41 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
17:42:19 <kmcallister> ?kind StateT
17:42:20 <lambdabot> * -> (* -> *) -> * -> *
17:46:16 <kmcallister> ?type runErrorT
17:46:16 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
17:52:06 <kmcallister> can anyone here explain briefly the advantages of yi and whether it's worth switching from emacs (which i have basic knowledge of but don't do anything advaced with)?
17:52:20 * Lycurgus pulls up a chair
17:52:23 <jaredj> :)
17:52:34 <shachaf> kmcallister: Very few people use it at the moment.
17:52:36 <ddarius> @hoogle readHex
17:52:37 <lambdabot> Numeric.readHex :: Num a => ReadS a
17:52:37 <lambdabot> Text.Read.Lex.readHexP :: Num a => ReadP a
17:53:05 <kmcallister> shachaf, is that because it's not production-ready or just the usual non-technical reasons?
17:53:09 <ddarius> kmcallister: It isn't currently worth switching to emacs, if for no reason that it is not ready yet.
17:53:21 <shachaf> kmcallister: The biggest advantage would be that it's written in Haskell. :-)
17:53:26 <jaredj> you mean _from_ emacs?
17:53:30 <Lycurgus> *from
17:53:33 <jaredj> k
17:53:39 <shachaf> kmcallister: Not production-ready, I would say.
17:53:44 <kmcallister> in what ways?
17:53:52 <Cin> written in haskell? phwoar
17:54:06 * Cin makes like a web user and googles
17:54:08 <jaredj> @google phwoar
17:54:10 <lambdabot> http://www.phwoar.com/
17:54:10 <lambdabot> Title: Phwoar :: The exciting way to date
17:54:11 * Lycurgus bonks Cin.
17:54:12 <jaredj> ?
17:54:13 <ddarius> @where yi
17:54:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:54:28 <jaredj> ah! urbandictionary at #2
17:54:42 <jaredj> @urbandictionary phwoar
17:54:43 <lambdabot> Unknown command, try @list
17:54:58 <ddarius> @where+ yi http://haskell.org/haskellwiki/Yi
17:54:58 <lambdabot> I will never forget.
17:55:04 <Tac-Tics> What would be the most important feature yi would need to be taken more seriously as a useable text editor?
17:56:26 <Lycurgus> anbody used Eden stuffs with any 6.x ghc?
17:57:47 <clanehin> 1343 patches of yi with --partial . . .
17:58:01 <Cin> i currently have mixed feelings about emacs. has lots of editing modes, easy to script for, subprocesses which are good for debugging code... i currently use ERC inside emacs. i tend to have emacs on full screen so i'd never notice someone talking to me with something else
17:58:25 <malar> @where yi
17:58:25 <lambdabot> http://haskell.org/haskellwiki/Yi
17:58:26 <Tac-Tics> The only thing that bugs me about emacs is the tabs
17:58:39 <Tac-Tics> The default tabbing mode is just insane
17:58:41 <Cin> emacs has tabs? do you mean buffers or does some version actuall have tabs?
17:58:53 * jaredj chimes in for vim
17:58:57 <jaredj> vim 7 has tabs!
17:59:02 <jaredj> too!
17:59:07 <BMeph> You mean tabs vs. spaces, right?
17:59:08 <jaredj> fwiw!
17:59:16 <Cin> ohhh
17:59:18 <Tac-Tics> When I hit tab, I just want to insert 4 spaces (or maybe a tab). With programming modes, it's cool, but generally, I don't like my TAB key guessing what I mean
17:59:19 <Cin> editing tabs. right
17:59:28 <Cin> yeah. i've configured my emacs to insert spaces
17:59:44 <jaredj> ohhh
17:59:49 <jaredj> not tabs at the top of the screen
17:59:50 <jaredj> lol
18:00:03 <Cin> i really like emacs buffers
18:00:23 <ddarius> > read "1.4" :: Rational
18:00:24 <Tac-Tics> Other than the damn tab key, my only beef is sometimes it gets confusing when you have several buffers open
18:00:24 <lambdabot>  Exception: Prelude.read: no parse
18:00:35 <Tac-Tics> but that's true of any text editor really
18:00:37 <Cin> using emacs buffers has probably made me more open minded about XMonad's windowing layout stuff. it looks kinda similar
18:00:46 <jaredj> > read "30/84" :: Rational
18:00:46 <lambdabot>  Exception: Prelude.read: no parse
18:00:54 <jaredj> oer.
18:01:06 <shachaf> > read "30%84" :: Rational
18:01:07 <lambdabot>  5%14
18:01:08 <allbery_b> %
18:01:21 <shachaf> > toRational (read "1.4" :: Double)
18:01:22 <lambdabot>  3152519739159347%2251799813685248
18:01:27 <jaredj> !
18:01:31 <ddarius> @src RealFrac
18:01:32 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
18:01:32 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
18:01:32 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
18:01:37 <ddarius> @src Real
18:01:37 <lambdabot> class  (Num a, Ord a) => Real a  where
18:01:37 <lambdabot>     toRational      ::  a -> Rational
18:02:04 <kuribas> I am writing a emacs mode that does a better job of finding indentations.
18:02:27 <kuribas> And doesn't use cycles.
18:02:38 <Tac-Tics> what do you mean by cycles?
18:02:51 <Korollary> indent-cycles as the current haskell mode
18:03:06 <kuribas> Indenting in two directions.
18:03:35 <allbery_b> it cycles through possible indentations based on layout
18:03:56 <allbery_b> (inconsistently, seems to jump back and forth for me)
18:04:19 <kuribas> I want to bind <del> to go to the indentation on the left.
18:04:30 <jaredj> @source @google
18:04:30 <lambdabot>  @google not available
18:04:34 <jaredj> :d
18:05:42 <jaredj> beh, urbandictionary has a soap api
18:06:02 <jaredj> urbandictionary support for lambdabot is left as an exercise for the reader
18:14:25 <BMeph> Has anyone tried compiling yi? I've got an odd misaligned type at the start.
18:14:44 <shachaf> BMeph: Did you see http://nobugs.org/developer/yi/ ?
18:14:45 <lambdabot> Title: Getting started with Yi, the haskell editor
18:15:24 <Cale> Heh, "Haskell is the new Scala"
18:15:41 <BMeph> I'm looking at it now, but I don't see my problem mentioned yet.
18:15:45 <malar> @where yaht
18:15:46 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
18:15:52 <shachaf> BMeph: Which version of GHC?
18:16:04 <eyeris> After watching the Beckman video on channel9, I'm left looking at (>>=) as (.) for monads. Is that at all accurate?
18:16:05 <BMeph> shachaf: 6.8.2
18:16:19 <Cale> eyeris: I understand monads, and that video confused me.
18:16:21 <ddarius> eyeris: (>>=) is like flip ($)
18:16:32 <Korollary> That video is meh
18:16:47 <ddarius> :t ((>>=),flip ($))
18:16:47 <lambdabot> forall (m :: * -> *) a b a1 b1. (Monad m) => (m a -> (a -> m b) -> m b, a1 -> (a1 -> b1) -> b1)
18:16:51 <Cale> actually, I had to stop watching it halfway through since it hurt too much
18:16:53 <jaredj> darcs has --diff-command, hg does not. darcs ftw
18:17:20 <shachaf> jaredj: I'm sure hg can do diffs.
18:17:29 <Cale> eyeris: It's something like a flipped over overloading of application, like ddarius says.
18:17:36 <jaredj> oh yes, it can do them. but i can't look at them with xxdiff
18:17:40 <jaredj> afaict
18:17:45 <shachaf> eyeris: (=<<) is a bit like ($).
18:17:47 <eyeris> ok
18:17:54 <shachaf> (As is (<$>), in a different way.)
18:17:55 <Cale> eyeris: Basically, if x is a computation, and f is a function from possible results of that computation to further computations to be performed
18:18:12 <Cale> then x >>= f is the computation which runs x, passes the result to f, and then runs the result of that
18:18:29 <shachaf> Cale: Runs the result?
18:18:32 <Cale> yes
18:18:38 <eyeris> And the purpose, to laymen like myself, is really just to apply both monadic functions without leaving your monadic shell, right?
18:18:39 <Cale> For example
18:18:43 <Cale> getLine >>= putStrLn
18:18:45 <shachaf> Cale: OK, I guess you could think of it that way.
18:18:51 <Cale> will get a line of text from the user
18:19:00 <shachaf> (I guess that's the sensible way to think about it. :-) )
18:19:02 <eyeris> right, I've been using that one in my experiments :)
18:19:06 <Cale> pass that to putStrLn, which builds an action for printing that line back out
18:19:12 <Cale> then runs that, which prints the line
18:19:20 <jaredj> > getLine
18:19:21 <lambdabot>  <IO [Char]>
18:19:52 <Cale> eyeris: Have I pointed you at my tutorials?
18:19:55 <LoganCapaldo> jaredj: hg diff | xxdiff doesn't work?
18:20:00 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
18:20:06 <Cale> http://haskell.org/haskellwiki/Monads_as_computation
18:20:06 <eyeris> Cale: I read that.
18:20:11 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
18:20:11 <jaredj> LoganCapaldo: it expects two filenames
18:20:12 <eyeris> The first one, anyway
18:20:40 <Cale> Introduction to IO is a good start, but it's mainly just about getting started thinking about IO, rather than monads in general.
18:20:43 <jaredj> LoganCapaldo: | xxdiff - . doesn't work either, "Cannot use stdin as only file with all dirs"
18:20:59 <Cale> If you can understand the IO monad properly though, it's a good start.
18:21:03 <jaredj> admittedly it would be cooler if i had a graphical diff that could just read a patch
18:21:17 <jaredj> then i wouldn't need --diff-command, i could use |
18:23:34 <gwern> dons: I like most of the tutorials, but his installation guide http://nobugs.org/developer/yi/building.html sucks. he should be using cabal and hackage much more
18:23:34 <lambdabot> Title: Building Yi
18:23:47 <bgold> any reason why a case statement might overflow the stack?
18:24:05 <jaredj> merh, i want my source file compiled with -fglasgow-exts. what's the magic word that goes first?
18:24:10 <Cale> bgold: Because it forces the evaluation of a very large expression?
18:24:11 * shachaf thinks yi should get some vi-using developers urgently, before it gets too emacsy.
18:24:16 <jaredj> i.e. {- WORD -fglasgow-exts -}
18:24:16 <shachaf> jaredj: OPTIONS_GHC?
18:24:24 <jaredj> ah thanks. did i get the {- -} right?
18:24:26 <shachaf> jaredj: Don't forget the #.
18:24:29 <jaredj> i'll find out in a moment
18:24:33 <LoganCapaldo> jaredj: you could ull down the two revs into temporary files i suppose but that kinda sucks
18:24:37 <bgold> i dont think the expression is all that large
18:24:39 <shachaf> jaredj: {-# OPTIONS_GHC -fglasgow-exts #-}
18:24:41 <bgold> any way i could see somehow?
18:24:50 <Cale> bgold: Can I see the case expression?
18:24:54 <Cale> !paste
18:24:54 <hpaste> Haskell paste bin: http://hpaste.org/
18:24:54 <jaredj> shachaf: ah. thanks
18:25:04 <jaredj> LoganCapaldo: pretty much
18:25:04 <shachaf> Is there a -X flag for -fglasgow-exts?
18:25:09 <bgold> printEval :: Env -> LispVal -> IO Env
18:25:09 <bgold> printEval env expr =
18:25:09 <bgold>     do let (res, env) = processResult env $ eval expr
18:25:09 <bgold>        case res of
18:25:09 <bgold>          Left err -> putStrLn "error"
18:25:10 <bgold>          otherwise -> putStrLn "blah"
18:25:19 <bgold> processResult :: Env -> EvalM LispVal -> (Either LispError LispVal, Env)
18:25:23 <bgold> type EvalM a = ErrorT LispError (State.State Env) a
18:25:27 <allbery_b> shachaf: -fglasow-exts is the big hammer
18:25:44 <shachaf> allbery_b: Yes, I try to avoid it, usually.
18:25:48 <Cale> bgold: Okay. Does just printing the result of processResult in ghci fail?
18:25:59 <shachaf> @quote glasgow-exts
18:25:59 <lambdabot> dons says: -fglasgow-exts ~= -fhaskell-prime
18:26:13 <bgold> cale: i'm not sure how to do that
18:26:16 <bgold> i dont use ghci
18:26:28 <Cale> bgold: hmm, what are you using?
18:26:30 <Cale> hugs?
18:26:32 <bgold> ghc
18:26:33 <LoganCapaldo> jaredj: the website says "Uses external diff program to compute differences: works with GNU diff, SGI diff and ClearCase's cleardiff, and any other diff whose output is similar to those;" maybe you can turn it upside down heh :)
18:26:37 <bgold> and then running it from command line
18:26:50 <ac> @seen davidL
18:26:50 <lambdabot> davidL is in #xmonad and #haskell. I last heard davidL speak 4h 38m 46s ago.
18:27:06 <davidL> hey ac
18:27:19 <jaredj> LoganCapaldo: for darcs?
18:27:21 <Cale> bgold: Okay, well, ghci is usually pretty critical to debugging. Just load the source file in ghci by passing the .hs file as a parameter on the commandline
18:27:27 <ac> davidL: yeah I am working on PNG bindings
18:27:34 <ac> davidL: though I'm not really liking the libpng API
18:27:35 <Cale> bgold: Then you can type expressions, and ghci will evaluate them and show you the result.
18:27:35 <LoganCapaldo> jaredj: well i meant for mercurial
18:27:42 <LoganCapaldo> since darcs has --diff-command
18:27:46 <shachaf> Someone should make Haskell libyaml bindings.
18:27:48 <davidL> ac: have you made a binding for png_sig_cmp yet?
18:27:59 <ac> no
18:28:03 <LoganCapaldo> sorry that quote was from the xxdiff website
18:28:07 <LoganCapaldo> if that wasn't clear
18:28:13 <jaredj> LoganCapaldo: oic :)
18:28:43 <Cale> bgold: The ghci prompt acts a little bit like the inside of a do-block:
18:28:48 <Cale> To temporarily bind values, you can use  let x = ...,  or to store the results of IO actions, x <- ...
18:28:56 <jaredj> ac: heh kinda stateful, that API
18:29:12 <Cale> (in case you need to read in a file or something)
18:29:15 <ac> jaredj: yes.
18:29:46 <Cale> Once you have appropriate parameters to pass to processResult, you can see what the result of evaluating it is.
18:30:59 <Cale> I suspect if that case-expression is causing a stack overflow, the real stack overflow is being built up inside of processResult. If res is somehow built up without being evaluated for a long time, it might actually be a very large expression by the time the case forces it by pattern matching.
18:31:20 <bgold> Prelude Lisp.Evaluator> p
18:31:20 <bgold> Right (Just (...),"")
18:31:27 <hpaste>  davidL pasted "simple png_sig_cmp binding" at http://hpaste.org/4981
18:31:29 <bgold> how do i grab the data from that without a case, like i'm doing in the actual code
18:31:52 <_keegan_> bgold, is (...) being generated by your show instance for the lisp type?
18:32:07 <Cale> let (Right (Just x, "")) = p
18:32:13 <Cale> will bind the (...) in x to p
18:32:15 <Cale> er
18:32:19 <Cale> will bind the (...) in p to x
18:32:22 <davidL> ac: that was something quick I did last night
18:32:44 <bgold> keegan: yeah it is, that's how i'm displaying lists
18:32:58 <bgold> i thought the stack overflow might be a recursive bug in my showVal function, so i changed lists to just show that for now
18:33:33 <Cale> bgold: It's quite common that stack overflows are caused by tail recursion.
18:33:58 <Cale> (it's sort of the opposite of strict languages)
18:36:06 <Cale> > foldl (+) 0 [1..1000000]
18:36:07 <lambdabot>  Exception: stack overflow
18:36:25 <Cale> This is because:
18:36:34 <Cale> (let me do a smaller example)
18:36:41 <Cale> foldl (+) 0 [1,2,3]
18:36:49 <Cale> = foldl (+) (0 + 1) [2,3]
18:36:54 <Cale> = foldl (+) ((0 + 1) + 2) [3]
18:37:01 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
18:37:06 <Cale> = ((0 + 1) + 2) + 3
18:37:11 <Cale> = (1 + 2) + 3
18:37:14 <Cale> = 3 + 3
18:37:15 <bgold> yeah, i can see how the stack would overflow there
18:37:16 <Cale> = 6
18:37:23 <bgold> i know how the folds work
18:37:36 <Cale> Right, I was just showing the influence of outermost-first evaluation.
18:38:00 <Cale> In a strict language, that large expression won't build up, because things are evaluated innermost-first.
18:38:46 <Cale> This can be fixed by using foldl' which forces the evaluation of the accumulating parameter on each step.
18:38:54 <Cale> > foldl' (+) 0 [1..1000000]
18:38:56 <lambdabot>  500000500000
18:39:52 <ac> davidL: cool. What is png_sig_cmp?
18:39:57 <pi3> @src foldl'
18:39:57 <lambdabot> foldl' f a []     = a
18:39:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:40:03 <Cale> foldl is tail recursive, so it compiles to a tight loop, but unless you're careful, if the list is too long, that tight loop will just build up a large expression which stack overflows when evaluated.
18:40:26 <davidL> ac: just looks at the beginning bytes of a file to see if it is a png image or not
18:40:39 <Cale> case expressions cause evaluation -- at some level, all evaluation is caused by pattern matching with case
18:40:49 <ac> davidL: ah that. OK. I'm still toying with the idea of reimplementing it :-P
18:40:55 <pi3> @src foldl
18:40:55 <lambdabot> foldl f z xs = lgo z xs
18:40:55 <lambdabot>     where lgo z []     =  z
18:40:55 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
18:41:11 <hpaste>  sarynx pasted "recursive file finds" at http://hpaste.org/4982
18:41:11 <Cale> that's a horrible way to write foldl :)
18:41:18 <Cale> foldl f z [] = z
18:41:19 <jaredj> oops. that was me.
18:41:31 <bgold> haha
18:41:34 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
18:41:40 <pi3> Cale: did you write foldl'?
18:41:41 <jaredj> i forgot i'm jaredj. anyway, anyone feel like commenting?
18:41:43 <ac> it would eliminate the possibility of buffer overflows ;-P
18:41:57 <bgold> Prelude Lisp.Evaluator> let (Right (Just p,"")) = Lisp.Parser.parseLisp "(+ 1 2 3)" True
18:41:57 <bgold> Loading package parsec-2.0 ... linking ... done.
18:41:57 <bgold> Loading package mtl-1.0.1 ... linking ... done.
18:41:57 <bgold> Prelude Lisp.Evaluator> let (res, env) = Lisp.Types.processResult initialEnv (eval p)
18:41:57 <bgold> Prelude Lisp.Evaluator> res
18:41:58 <bgold> Right 6
18:42:00 <bgold> Prelude Lisp.Evaluator> env
18:42:00 <Cale> pi3: The implementation of foldl' given by @src is fine.
18:42:02 <bgold> fromList [("&&",<primitive:&&>),("*",<primitive:*>),("+",<primitive:+>),("-",<primitive:->),("/",<primitive:/>),("/=",<primitive:/=>),("<",<primitive:<>),("<=",<primitive:<=>),("=",<primitive:=>),(">",<primitive:>>),(">=",<primitive:>=>),("begin",<special:begin>),("car",<primitive:car>),("cdr",<primitive:cdr>),("cond",<special:cond>),("cons",<primitive:cons>),("define",<special:define>),("defun",<special:defun>),("eq",<primitive:eq>),("eq?",<primit
18:42:08 <bgold> Prelude Lisp.Evaluator>
18:42:10 <bgold> wait that wasnt all of it
18:42:11 <Cale> bgold: oy!
18:42:12 <bgold> Prelude Lisp.Evaluator> let (Right (Just p,"")) = Lisp.Parser.parseLisp "(+ 1 2 3)" True
18:42:14 <bgold> Loading package parsec-2.0 ... linking ... done.
18:42:16 <bgold> Loading package mtl-1.0.1 ... linking ... done.
18:42:17 <Cale> !paste
18:42:17 <hpaste> Haskell paste bin: http://hpaste.org/
18:42:18 <bgold> Prelude Lisp.Evaluator> let (res, env) = Lisp.Types.processResult initialEnv (eval p)
18:42:20 <bgold> Prelude Lisp.Evaluator> res
18:42:22 <bgold> Right 6
18:42:22 <jaredj> pwoar, or something?
18:42:23 <Cale> use hpaste!
18:42:24 <bgold> that came first
18:42:26 <bgold> ah sorry
18:42:35 <jaredj> darnit what was that word
18:42:45 <jaredj> ah, 'phwoar'
18:42:48 <hpaste>  bgold pasted "lisp" at http://hpaste.org/4983
18:43:23 <Cale> bgold: so... that seems to be working?
18:43:33 <bgold> yep
18:43:58 <Cale> bgold: but in your compiled program, it's giving you problems?
18:44:18 <bgold> yep
18:44:22 <jaredj> oh cool
18:44:46 <Cale> bgold: what happens when you just run 'main' from ghci?
18:45:35 <bgold> <interactive>:1:0:
18:45:35 <bgold>     Failed to load interface for `Lisp':
18:45:35 <bgold>       Use -v to see a list of the files searched for.
18:45:39 <Cale> hmm
18:45:54 <Cale> Is that module in the current directory?
18:46:03 <bgold> yes
18:46:09 <Cale> huh...
18:47:35 <shachaf> Is it in the file Lisp.hs?
18:47:58 <bgold> there is no file called Lisp.hs
18:48:00 <Cale> oh, yes, that's important too :)
18:48:12 <Cale> Modules should be in files which are named after the module name.
18:48:36 <Cale> Otherwise, GHC/GHCi won't know where to look to find them.
18:48:37 <ricky_clarkson> Does that affect things or is it a convention?
18:48:42 <bgold> Prelude Lisp.Evaluator> Main.printEval initialEnv p
18:48:42 <bgold> Loading package haskell98 ... linking ... done.
18:48:42 <bgold> Loading package readline-1.0 ... linking ... done.
18:48:42 <bgold> before
18:48:42 <bgold> *** Exception: stack overflow
18:48:42 <ricky_clarkson> Ah. :)
18:49:08 <bgold> all my modules have the right names
18:49:58 <bgold> so, the printEval function is failing on the case
18:50:07 <bgold> and using ghci i see the case is operating on "Right 6"
18:50:22 <Cale> How do you know that it's failing on the case?
18:50:34 <bgold> because i have a putStrLn "before" before the case, and putStrLn "after" after the case
18:51:08 <bgold> all the case does is this
18:51:09 <bgold>        case res of
18:51:09 <bgold>          Left err -> putStrLn "error"
18:51:09 <bgold>          otherwise -> putStrLn "blah"
18:51:31 <Cale> okay
18:51:37 <Cale> I suppose that should work :)
18:51:47 <Cale> though otherwise is a strange name there :)
18:52:00 <bgold> oh
18:52:18 <Cale> (otherwise is a Prelude definition, it's defined to be equal to True -- your case will shadow that definition)
18:52:28 <bgold> it used to be  a Right v
18:52:33 <Cale> (It's meant for use in guards)
18:52:38 <Cale> You could also use _
18:52:41 <bgold> ah
18:52:46 <LoganCapaldo> I kinda like that :)
18:52:48 <Cale> which is a non-binding wildcard pattern
18:52:59 <bgold> makes sense
18:53:07 <LoganCapaldo> good abuse of otherwise! :)
18:53:16 <bgold> haha thanks
18:53:19 <bgold> yeah i see why it wont work now
18:53:27 <Cale> oh?
18:53:36 <bgold> i meant why the otherwise keyword isnt appropriate
18:53:39 <Cale> okay
18:53:41 <bgold> not why my program isnt working
18:53:49 <Cale> It will work, it's just equivalent to using something like  'x' there
18:53:59 <Cale> (it's just odd :)
18:54:25 <bgold> right
18:55:10 <Cale> and you're using the same expression and everything?
18:55:28 <bgold> yeah
18:56:47 <nolrai> is there a function such that example n f x = f aplied n times to x?
18:57:33 <bgold> replicateM_
18:57:34 <bgold> i think
18:57:40 <LoganCapaldo> @type \n f -> foldr (.) id $ replicate n f
18:57:41 <lambdabot> forall a. Int -> (a -> a) -> a -> a
18:57:42 <_keegan_> ?type iterate
18:57:43 <lambdabot> forall a. (a -> a) -> a -> [a]
18:57:54 <nolrai> :t replicateM_
18:57:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
18:57:55 <_keegan_> take 10 $ iterate (+1) 0
18:57:57 <_keegan_> > take 10 $ iterate (+1) 0
18:57:59 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
18:58:28 <LoganCapaldo> > (\n f -> foldr (.) id $ replicate n f) 3 (+1) 4
18:58:28 <lambdabot>  7
18:58:42 <LoganCapaldo> > (\n f -> foldr (.) id $ replicate n f) 0 (+1) 4
18:58:43 <lambdabot>  4
18:59:00 <_keegan_> > let example n f x = (iterate f x) !! n in example 5 (+1) 0
18:59:01 <lambdabot>  5
19:00:06 <_keegan_> > let example n f x = (iterate f x) !! n in example 5 ('x':) []
19:00:07 <lambdabot>  "xxxxx"
19:00:26 <TomMD> > (succ . succ . succ) "TomMD"
19:00:26 <lambdabot>   add an instance declaration for (Enum [Char])
19:00:44 <LoganCapaldo> > let example n f x = (iterate f x) !! n in example 0 ('x':) []
19:00:45 <lambdabot>  ""
19:00:49 <TomMD> > let f = map succ in (f . f . f) "TomMD"
19:00:49 <lambdabot>  "WrpPG"
19:01:45 <bgold> aaahhh i found the bug
19:01:54 <bgold> let (res, env) = processResult env $ eval expr
19:02:00 <bgold> i just had to change the (res, env) to (res, env')
19:02:15 <bgold> i dont see why that would cause the problem though
19:02:34 <allbery_b> let is recursive
19:02:52 <LoganCapaldo> > let (x, y) = (x, y) -- infinite loop
19:02:52 <lambdabot>  Parse error at end of input
19:02:57 <LoganCapaldo> doh
19:03:06 <LoganCapaldo> > let (x, y) = (x, y) in (x, y) -- infinite loop
19:03:07 <lambdabot>  Exception: <<loop>>
19:03:12 <_keegan_> > let (x,y) = (x,y) in ()
19:03:12 <lambdabot>  ()
19:03:36 <TomMD> Yay for lazy
19:03:44 <_keegan_> does lambdabot's evaluator actually have infinite loop detection or does it just break after some amount of time?
19:03:47 <allbery_b> anyway, it tries to repeat the function until the input env is the same as the output.
19:03:54 <LoganCapaldo> it does both
19:04:26 <bgold> hmm
19:04:28 <TomMD> And it whitens your teeth while you sleep (or, thats what they promised me when I started learning Haskell, so I'm passing it on).
19:04:34 <LoganCapaldo> when something takes too long it says "Terminated"
19:04:38 <bgold> let (x,y) = (1,2) in let (x,y)=(x,y) in ()
19:04:41 <_keegan_> allbery_b, i don't think it quite repeats the function as feeds it its own output
19:04:46 <bgold> > let (x,y) = (1,2) in let (x,y)=(x,y) in ()
19:04:46 <lambdabot>  ()
19:04:49 <bgold> how do i get that to run
19:04:51 <bgold> oh ok
19:04:56 <ramza3> fyi: haskell is fun
19:05:15 <bgold> so no infinite loop here, only in my program, nice
19:05:51 <_keegan_> yeah, non-recursive let would be nice in some cases
19:05:59 <_keegan_> it's useful in ML for pseudo-imperative updates
19:06:04 <LoganCapaldo> > let (x,y) = y
19:06:04 <lambdabot>  Parse error at end of input
19:06:07 <_keegan_> let x = f x in let x = g x in ...
19:06:12 <LoganCapaldo> > let (x,y) = y in x
19:06:13 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t1, t)
19:06:13 <lambdabot>       Expe...
19:06:27 <LoganCapaldo> infinite type instead of infinite loop :)
19:06:43 <kaiser> hello, where might I be able to find the implementation for Haskell's ++ appending of lists?
19:06:48 <_keegan_> ?src (++)
19:06:48 <lambdabot> (++) []     ys = ys
19:06:48 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:07:13 <kaiser> I downloaded a debian package for the GHC library source, but I can't seem to find ++ implementation in the Data/List.hs file
19:07:25 <LoganCapaldo> > foldr (:) [3,4,5] [1,2,3]
19:07:25 <lambdabot>  [1,2,3,3,4,5]
19:07:27 <kaiser> thanks
19:07:59 <_keegan_> let (+++) = foldr (:) in [1,2,3] +++ [4,5,6]
19:08:01 <kaiser> ?src (head)
19:08:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:08:02 <_keegan_> > let (+++) = foldr (:) in [1,2,3] +++ [4,5,6]
19:08:03 <lambdabot>  [4,5,6,1,2,3]
19:08:05 <_keegan_> ?src head
19:08:06 <lambdabot> head (x:_) = x
19:08:06 <lambdabot> head []    = undefined
19:08:10 <kaiser> :)
19:08:16 <_keegan_> (the parens are used to turn an infix operator into a prefix function
19:08:18 <_keegan_> )
19:08:32 <kaiser> thanks
19:08:41 <kaiser> I'm brand new to Haskell, my first day using it.
19:08:43 <allbery_b> _keegan_: I should have been more specific, I guess
19:08:51 <LoganCapaldo> > let (+++) = flip (foldr (:)) in [1,2,3] +++ [4,5,6]
19:08:51 <lambdabot>  [1,2,3,4,5,6]
19:09:08 <_keegan_> kaiser, welcome and enjoy :)
19:09:40 <kaiser> _keegan_: thanks, seems like quite an interesting language.  I like the theory so far, just trying to become more acquainted with using it.
19:10:29 <kaiser> I really don't understand why I can't find ++ in List.hs for GHC source?
19:10:56 <dons> its exported from GHC/BAse.hs
19:10:59 <dons> ?src (++)
19:11:00 <lambdabot> (++) []     ys = ys
19:11:00 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:12:13 <kaiser> dons: thanks
19:13:00 <LoganCapaldo>  kaiser if you want to find out where a function (or almost anything really) is coming from you can use :info in ghci
19:13:00 <Cale> You can see from that definition that it'll take O(length xs) steps to completely reduce xs ++ ys
19:13:17 <LoganCapaldo> eg :info (++) tells you it's defined in GHC.Base
19:13:17 <kaiser> LoganCapaldo: ahh, that is very helpful.
19:14:11 <Cale> (which is why you should be wary of writing anything which makes lots of small appends to the end of a list)
19:17:22 <kaiser> thanks for the info Cale.
19:17:43 <atp> what do errors like "Cannot match a monotype with `ReaderT (Matrix a)'" mean?
19:18:05 <kaiser> hmm, can I redefine ++?
19:18:09 <atp> yes
19:18:29 <Cale> kaiser: sure, but if you want it to be convenient, you'll want to import Prelude hiding ((++))
19:18:54 <TomMD> dons: I've got a question for you ('you' being someone who finished a PhD recently that involved lots of reading in the FP arena).
19:19:05 <kaiser> Cale: does the "hiding ((++))" tell the compiler not to give errors about a re-definition?
19:19:25 <Cale> kaiser: It hides the usual definition, so it's not in scope.
19:19:32 <kaiser> well, I guess I should say, it doesn't load (++)
19:19:33 <kaiser> yeah
19:19:54 <atp> Cale: doesn't current file scope always win over imported module scope?
19:19:59 <Cale> kaiser: If you just define (++) again in your module, it'll be okay, but when you go to use it, the compiler will complain that it doesn't know which one you want.
19:20:12 <kaiser> Cale, yah, I got that complaint ;)
19:20:22 <Cale> (and ask you to qualify it, so you'll have to write something like  xs MyModule.++ ys, which is dumb :)
19:20:40 <kaiser> hehe, well I haven't even got to "modules" yet
19:20:46 <_keegan_> ?kind ReaderT (Matrix a)
19:20:48 <lambdabot> Not in scope: type constructor or class `Matrix'
19:20:48 <lambdabot> Not in scope: type variable `a'
19:20:50 <dons> TomMD: shoot
19:21:29 <TomMD> dons: I've been looking at papers re: correctness of Haskell programs.  It seems to me that many of the more recent papers have been about reliability (Ex: Unfailing Haskell by ndm, ESC Haskell by Xu).  Most of the 'correctness' papers I find a slightly older (formulating Haskell, Constructive Type Theory using ADGA, etc).  Is this your view too?  Is the correctness field a bit dull right now?
19:21:33 <Cale> atp: hmm, I don't think I've ever gotten that specific error before, but it sounds like maybe it doesn't like the polymorphism for some reason?
19:22:03 <dons> TomMD: hmm. I think interactive with theorem proving is also pretty hot.
19:22:12 <dons> TomMD: there's a fair bit happening now with Coq or Isabelle
19:22:25 <dons> (projects at sydney, PSU, chalmers, probably elsewhere)
19:22:26 <Cale> oh, ReaderT (Matrix a) isn't a type as well, it's a type constructor
19:22:35 <Cale> @kind ReaderT
19:22:35 <lambdabot> * -> (* -> *) -> * -> *
19:23:04 <Cale> atp: If you show me the code around the line where the compiler is complaining, I might be able to help more :)
19:23:06 <TomMD> dons: Yes, I've seen lots on Coq - though I'm not sure I like the construction.  I haven't seen so much on Isabelle - I suppose I should look for that specifically.
19:23:33 <dons> TomMD: the l4 kernel formalisations have been happening in Isabelle+Haskell (POPL paper last Jan)
19:23:42 <Nafai> Cool, I got the gtk frontend for Yi working!
19:23:44 <dons> and there's a new phd at psu working on similar stuff
19:23:57 <kaiser> oooh, L4 kernel, cool stuff.  :)
19:24:13 <TomMD> dons: Does it bother you that Isabelle/HOL was originally (still?) targeted as a ML proof assistant?  I got annoyed with it having many different types than Haskell and having these affect the correctness of my routines.
19:24:28 <TomMD> Ex: length :: Nat  vs. length :: Int
19:24:39 <dons> it doesn't bother me :)
19:24:46 <dons> hysterical raisins, after all
19:24:58 <TomMD> Yes, I've been happily following the microkernel front - thats some great stuff.
19:25:35 <TomMD> Though there's no news on Osker for a long time now.
19:25:41 <BMeph> m annoyed that Haskell doesn't have a Nat class, frankly.
19:25:52 <BMeph> s/m/I'm/
19:25:58 <TomMD> BMeph - is WordX not ok for you?
19:27:15 <gwern> BMeph: heck, I'd like a positive real class myself while we're wishing for ponies
19:27:16 <jaredj> :t \\
19:27:17 <lambdabot> parse error on input `\\'
19:27:22 <jaredj> :t (\\)
19:27:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:27:37 <jaredj> ngerf! not very hooglable
19:27:39 <BMeph> TomMD, oh, no, it works, it just doesn't feel like that's its intended purpose, that's all. It feels kludgy, which is completely against how using Haskell is normally.
19:28:41 <BMeph> gwern: Tell me about it. I started to work up a description for Gaussian numbers, but stopped because abs doesn't really work for those.
19:29:09 <TomMD> I'm just concerned everyone and their mother will add a new Integer like type to libraries and we'll have fromIntegrals breeding like bunnys.  instance Num Nat, instance Num BMeph, instance Num andygill...
19:29:21 <kaiser> I know this is probably a very simple question, but would someone mind explaining in words the (++) code?
19:29:32 <Cale> kaiser: sure
19:29:36 <kaiser> :)
19:29:39 <Cale> [] ++ ys = ys
19:29:39 <BMeph> ?src (++)
19:29:39 <lambdabot> (++) []     ys = ys
19:29:39 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:29:53 <Cale> Let's rewrite that more naturally, like it ought to be written :)
19:29:56 <phobes> Cale:  First explain it without words!
19:29:59 <kaiser> lol
19:30:16 <kaiser> Cale: sounds good to me.
19:30:17 <Cale> So concatenating the empty list to the list ys gives ys
19:30:41 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
19:31:05 <Cale> Concatenating a nonempty list whose first element is x, and the tail is xs, to the list ys
19:31:13 <Cale> gives the list whose first element is x
19:31:20 <Cale> and whose tail is (xs ++ ys)
19:31:30 <Cale> (the result of concatenating xs and ys)
19:31:43 <Cale> So, for example:
19:31:45 <gwern> BMeph: I have a PosReal class defined, but getting a full numerical type is a lot of work
19:31:51 <Cale> [1,2] ++ [3,4,5]
19:32:01 <Cale> = (1 : [2]) ++ [3,4,5]
19:32:10 <Cale> (just by expansion of the list syntax)
19:32:19 <Cale> = 1 : ([2] ++ [3,4,5])
19:32:25 <Cale> (by the second equation for ++)
19:32:28 <BMeph> gwern: Your type won't work - how are you going to define negate if it's posReal? :)
19:32:52 <Cale> = 1 : ((2 : []) ++ [3,4,5]) -- again just expanding the meaning of the list syntax
19:33:02 <BMeph> Except by trivially declaring negate = id, anyway.
19:33:07 <Cale> = 1 : (2 : ([] ++ [3,4,5]))
19:33:16 <Cale> (by the second equation for ++ again)
19:33:22 <phobes> Cale:  Did you ever think of writing a little facility for lambdabot to do evaluations like this?  Think how much time you'd save :)
19:33:35 <Cale> = 1 : (2 : [3,4,5]), by the first equation for ++
19:33:47 <Cale> = [1,2,3,4,5], collapsing the list notation :)
19:34:01 <kaiser> :)
19:34:11 <nolrai> :t ap
19:34:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:34:16 <Cale> kaiser: So it makes sense how that works now?
19:34:20 <kaiser> Cale: that is cool stuff.
19:34:32 <gwern> BMeph: I call error :)
19:34:40 <kaiser> yep, I gotta get used to the list notation.
19:35:01 <Cale> Yeah, [1,2,3,4,5] really means 1 : (2 : (3 : (4 : (5 : []))))
19:35:16 <Cale> Or, since : is right associative anyway:  1 : 2 : 3 : 4 : 5 : []
19:35:53 <Cale> While we're at it, have you seen foldr?
19:36:02 <kaiser> Cale: nope, not used foldr yet.
19:36:14 <Cale> What foldr f z does is replace each (:) in a list with f, and the [] at the end with z
19:36:21 <Cale> For example:
19:36:27 <BMeph> gwern: Oh, well as long as it's meaningfully defined, I'm happy. ;)
19:36:28 <Cale> > foldr (+) 0 [1,2,3,4,5]
19:36:29 <lambdabot>  15
19:36:40 <Cale> Or:
19:36:49 <Cale> > foldr (:) [3,4,5] [1,2]
19:36:50 <lambdabot>  [1,2,3,4,5]
19:36:53 <kaiser> wow
19:37:02 <Cale> (there's another way to write (++) right there :)
19:37:08 <gwern> (I mean, really, if you try to pass a negative number to a constructor for the type 'Positive Reals', you deserve all the crashs you get)
19:37:14 <Cale> xs ++ ys = foldr (:) ys xs
19:37:36 <Cale> and it makes sense, you're replacing the [] at the end of xs with the list ys
19:37:59 <Cale> (and leaving the (:)'s the same)
19:38:06 <kaiser> xs ++ ys = foldr (:) ys  ?
19:38:15 <BMeph> Cale: That's a very "ys" concept... ;p
19:38:33 <gwern> (I guess it'd be good to somehow have some static guarantees no negatives will be passed although I don't know how you'd do it)
19:38:36 <kaiser> foldr takes 3 arguments?
19:38:42 <jfredett> yah
19:38:43 <Cale> kaiser: yes
19:38:56 <jfredett> @type foldr
19:38:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:39:03 <jaredj> syntax: do { x; y; z } right?
19:39:05 <Cale> kaiser: The thing to replace (:) with, the thing to replace [] with, and the list to do the replacing on.
19:39:20 <jaredj> (actually, it's wrong but i don't know why.)
19:39:20 <kaiser> ?src foldr
19:39:20 <lambdabot> foldr k z xs = go xs
19:39:20 <lambdabot>     where go []     = z
19:39:20 <lambdabot>           go (y:ys) = y `k` go ys
19:39:26 <Cale> ugh
19:39:31 <Cale> foldr f z [] = z
19:39:43 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
19:39:54 <Cale> please ignore the source that lambdabot printed :)
19:39:56 <gwern> dons: I think the darcs location on http://www.cse.unsw.edu.au/~dons/yi.html is a bit outdated :)
19:39:58 <lambdabot> Title: yi text editor
19:40:10 <jaredj> Cale: i think it's nice that that source used `k`
19:40:22 <Cale> c would be better :)
19:40:30 <kaiser> Cale: does the lambdabot source use more complicated Haskell syntax?
19:40:58 <Cale> kaiser: It's using the version in GHC which contains a hack to get GHC to produce slightly better code, because of missing optimisations.
19:41:15 <Cale> I think with some new optimisations that GHC is doing now, it might not be necessary anymore.
19:41:25 <kaiser> ahh
19:41:29 <Tac-Tics> What is the name of the Haskell FFI C header?
19:41:30 <jaredj> wth?
19:41:34 <jaredj> > let t = unfoldTreeM (\dn -> do {x <- getDirectoryContents dn; let y = x \\ [".", ".."]; return (dn, y)}) "/media/disk/rip/everglow"
19:41:35 <lambdabot>  Parse error at "})" (column 103)
19:41:38 <Tac-Tics> is it FFI.h?
19:41:54 <Cale> jaredj: It can't tell where your let ends, I think.
19:42:05 <jaredj> oerh
19:42:28 <jaredj> how do i lift \\ properly so i can >>= it?
19:42:30 <kaiser> Cale: very odd to define parts of the function based upon the arguments data  in the actual definition of the function
19:42:47 <Cale> kaiser: pattern matching you mean?
19:42:58 <kaiser> Cale: foldr f z [] = z --- this translates to, if the third argument is [] then return z?
19:43:03 <Cale> yes
19:43:05 <kaiser> Cale: yah, I guess it is the pattern matching.
19:43:22 <kaiser> Cale: I am definitely not used to the patten matching way of writing code.
19:43:26 <Cale> Each of the left hand sides gets tried from top to bottom
19:43:29 <Cale> and left to right
19:43:38 <Cale> and the first one to finish matching wins
19:43:53 <nolrai> cale: what do you mean left to right?
19:44:07 <Cale> nolrai: I mean that earlier parameters get matched first.
19:44:18 <HairyDude> hmm, I see there's no instance (MonadTrans t, Monad m) => Monad (t m)... is that because there really is no way to define it, or some weakness of Haskell?
19:44:24 <Cale> I suppose that doesn't really matter so much here.
19:44:32 <nolrai> first in what sense?
19:44:41 <phobes> Cale:  How can you detect that?
19:44:50 <Cale> phobes: It's possible that you can't :)
19:44:58 <Cale> I'd have to think about it anyway :)
19:45:02 <phobes> hehe k
19:45:30 <Cale> First in the sense that it compiles to nested cases which only match a single constructor at a time.
19:45:37 <kaiser> Haskell is definitely a challenging language.
19:45:49 <Cale> (well, maybe not anymore)
19:45:52 <kaiser> well, I shouldn't say challenging... parts seem more natural.
19:46:06 <Cale> It's just like learning to program all over again :)
19:46:16 <kaiser> hehe
19:46:27 <Cale> The more you can avoid thinking imperatively, the better :)
19:46:33 <TomMD> Cale++
19:46:34 <_keegan_> yeah, and after you know haskell you will be a better programmer in any language
19:46:50 <kaiser> yah, I took a Programming Languages course, and I really liked Lisp, but I wanted to try a more modern functional programming language.
19:47:07 <HairyDude> Lisp isn't really a functional programming language.
19:47:13 <Cale> A lot of the features in Haskell are formalisations of what lisp people were doing though.
19:47:23 <Cale> HairyDude: Some lisps are.
19:47:23 <_keegan_> HairyDude, Lisp is a functional programming language as well as an imperative and an object-oriented language
19:47:27 <_keegan_> "multiparadigmatic"
19:47:34 <_keegan_> for that matter, Haskell is also great as an imperative language
19:47:43 <Cale> Common lisp is not such a good functional programming language, but scheme is closer :)
19:47:47 <_keegan_> it's the only language i know of where imperative statement sequences are first-class
19:47:57 <_keegan_> which seems like a no-brainer for a true imperative language
19:48:07 <Cale> _keegan_: That's very true.
19:48:08 <kaiser> so, not to start trouble...  but are there certain problems you guys would use Lisp/Scheme for?
19:48:11 <HairyDude> yeah, that's one of my favourite features of Haskell
19:48:32 <_keegan_> kaiser, me personally, no, because my preferred languages span the space of nearly every problem i would want to solve
19:48:36 <_keegan_> and lisp isn't one of those
19:48:40 <Cale> kaiser: Perhaps :) I don't mind scheme. I always miss having the type system.
19:48:53 <_keegan_> scheme is fun though, and i'll always appreciate the minimalism
19:48:59 <Cale> Common lisp, I think I'd probably avoid, personally.
19:49:01 <_keegan_> at Caltech we teach intro CS using scheme
19:49:07 <_keegan_> which has a pretty polarizing effect on the students
19:49:12 <kaiser> _keegan_: yah, minimalism is very nice.  :)
19:49:12 <HairyDude> common lisp is quite bizarre in some ways
19:49:22 <_keegan_> LISP is like scheme without the simplicity, but without the modern features of Haskell or ML either
19:49:23 <Cale> (too many people assume Lisp => Common Lisp)
19:49:53 <Cale> There are a lot of lisps, and many of them are pretty cool :)
19:50:04 <Cale> Qi is also something I should probably have a closer look at :)
19:50:30 <HairyDude> istr that if say foo is a variable with a function value, you can't call it by just doing (foo args...) ... which makes it a tad hard to do higher-order stuff
19:50:38 <kaiser> Thanks for the info everyone.  You have all been quite helpful
19:50:48 <Cale> HairyDude: in CL, yeah
19:50:51 <kaiser> Cale, thank you for taking the time to explain (++) to me.
19:51:05 <kaiser> I'll be back in here soon, I'm sure.  :)
19:51:06 <Cale> kaiser: No problem, be sure to let me know if you need anything else explained :)
19:51:06 <bos> @hoogle readInt
19:51:07 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:51:07 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
19:51:07 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
19:51:10 <_keegan_> kaiser, any time
19:51:13 <HairyDude> Cale: yeah, I was talking about CL. istr it's saner in scheme, but I haven't done much scheme :)
19:51:20 <kaiser> _keegan_: thanks.
19:51:24 <kaiser> have a good night.
19:51:26 <kaiser> cya
19:51:29 <HairyDude> night
19:51:29 <Cale> g'night
19:52:22 <HairyDude> can anyone answer my question?
19:53:40 <Cale> HairyDude: It's because there's no general way to define it.
19:53:55 <HairyDude> ah, that's ok then :)
19:53:58 <Cale> HairyDude: that's something which needs to be handled separately for each monad transformer.
19:55:08 <HairyDude> I'll just have to add an UndecidableInstances pragma then
19:57:07 <Cale> hmm
19:57:28 <HairyDude> irc client for emacs eh
19:57:36 <Cale> Can't you just add a constraint like (Monad (t m)) to your function?
19:57:39 <HairyDude> does it have a kitchen sink yet?
19:57:47 <HairyDude> cale: yeah
19:58:04 <HairyDude> cale: well, it's an instance head actually
20:00:38 <jaredj> i think i need a monad transformer
20:00:40 <HairyDude> interesting that MultiParamTypeClasses implies FlexibleInstances
20:00:45 <jaredj> this is a moment for me
20:00:52 <glguy> HairyDude: are you sure about that?
20:00:59 <glguy> HairyDude: 6.6 or 6.8
20:01:02 <HairyDude> jaredj: yay!
20:01:10 <jaredj> i think
20:01:50 <jaredj> i've gotten as far as this:
20:01:59 <jaredj> Prelude Data.Tree Directory Control.Monad Data.List System.Posix.Files> let t = unfoldTreeM (\dn -> getFileStatus dn >>= \st -> if isRegularFile st then return (dn, []) else getDirectoryContents dn >>= return . (flip (\\) [".", ".."]) >>= \y -> return (dn, y)) "/media/disk/rip/everglow"
20:02:06 <HairyDude> glguy: 6.7 actually... I compiled it myself to get associated type synonyms, and haven't bothered to upgrade yet since 6.8 isn't in the gutsy repos yet
20:02:30 <jaredj> but getFileStatus fails because dn isn't a full pathname
20:02:32 <glguy> HairyDude: in that version then using a LANGUAGE pragma just turns all extensions on
20:02:42 <HairyDude> jaredj: hmm, I have a feeling that will be more readable on multiple lines...
20:02:45 <jaredj> i think that means i need either State or Reader to store the path so far
20:02:48 <jaredj> yes yes, of course :)
20:02:48 <glguy> HairyDude: That was the case in 6.6, and not in 6.8
20:03:30 <jaredj> if this works it will replace like 47 lines of code
20:03:43 <HairyDude> glguy: well FlexibleInstances doesn't imply UndecidableInstances, but I guess you mean it turns on everything that's turned on by -fglasgow-exts
20:03:59 <Tac-Tics> Can someone point me to a good FFI tutorial? I can't for the life of me get anything to compile
20:04:09 <glguy> Flexible instances means you can have more than type-variables below the first type constructor
20:04:16 <glguy> [Maybe a], for example
20:04:30 <glguy> instead of just: (T1 a b c)
20:04:51 <HairyDude> that's why Text.Printf has an IsChar class with exactly one instance :)
20:05:47 <dons> 1151 RuleFired 7 ++ 10 ==#->case 1061 FPS pack/packAddress
20:05:49 <dons> :)
20:06:02 <dons> 1061 rules hit. yaya for rules
20:06:15 <byorgey> \o/
20:06:20 <atp> what are FlexibleInstances ?
20:06:39 * HairyDude appreciates the whooshing sound as things go over his head.
20:06:49 <atp> oh hey, look, people were talking about this
20:06:58 <atp> what a coincidence :)
20:07:01 <HairyDude> heh
20:07:18 <_keegan_> Tac-Tics, http://haskell.org/haskellwiki/GHC/Using_the_FFI
20:07:23 <dons> atp, you can use synonyms in instances, basically. (that is , instances don't need to be of the form (C a b ..), where a , b . are variables
20:07:32 <atp> ah, i see
20:07:34 <glguy> it's more than synonyms though
20:07:35 <dons> so things like [Char] match (i.e. ([] Char))ç
20:07:41 <HairyDude> what glguy said
20:08:00 <dons> or (Array Int a) is another common one
20:08:10 <sarah__> is there a more efficient way to do this? updateList elem list index = zipWith (\a b -> if b == index then elem else a) list [0..(length list)-1]
20:08:13 <atp> i see
20:08:17 <glguy> the problem with instance String where
20:08:22 <glguy> isn't that String is a synonym
20:08:26 <glguy> but that it isn't a [a]
20:08:26 <HairyDude> I guess you can often generalise that to Ix i => Array i a though :)
20:08:29 <glguy> but a [T]
20:08:37 <_keegan_> sarah__, you can change the last list to just [0..]
20:08:39 <sjanssen> sarah__: you can just use [0..], avoiding the 'length' call
20:08:45 <_keegan_> zipWith will stop once it runs out of any list
20:08:46 <sarah__> oh thx
20:08:57 <sarah__> not used to infinite lists still XD
20:09:00 <_keegan_> :D
20:09:07 <_keegan_> haskell: infinite loops made fast
20:09:29 <_keegan_> ?pl \a b -> if b == index then elem else a
20:09:30 <lambdabot> flip (flip if' elem . (index ==))
20:09:41 <HairyDude> glguy: well the instance thing is part of it... I mean if you say type List a = [a] and try to define an instance for List a, it'll complain
20:09:41 <sjanssen> sarah__: you can do it a bit more efficiently, by taking note of the fact that the part of the list after 'index' can be shared
20:10:39 <HairyDude> I sometimes find myself wanting 'type functions' that I can partially apply :)
20:10:55 <_keegan_> HairyDude, you can partially apply type constructors in Haskell
20:11:20 <HairyDude> _keegan_: yes... but that's not what I mean
20:13:11 <dons> for those with cabal-install, could someone confirm this works,
20:13:12 <dons> $ cabal update
20:13:18 <dons> $ cabal install pcre-light
20:13:18 <dons> Downloading 'pcre-light-0.2'...
20:13:18 <dons> Configuring pcre-light-0.2...
20:13:19 <dons> ..
20:13:50 <sarah__> seeing what @pl says is interesting usually, sometimes monkeying with order of argments makes it much simpler
20:14:03 <dons> and to be super useful, run the testsuite,
20:14:05 <dons> $ cd ~/.cabal/packages/hackage.haskell.org/pcre-light
20:14:11 <dons> $ tar xzf pcre-light-0.2.tar.gz
20:14:15 <dons> $ cd pcre-light-0.2/tests
20:14:15 <dons> $ make
20:14:23 <dons> Cases: 563  Tried: 563  Errors: 0  Failures: 0
20:14:48 <dons> sarah__: yeah, sometimes you have to massage things a bit to work around @pl's limitatoins
20:16:29 <TomMD> dons: Failed for me.
20:16:38 <dons> what failed?
20:16:46 <TomMD> dons: Base.hsc: error 'PCRE_CONFIG_'  Millions of them.
20:16:54 <dons> oh you don't have libpcre installed
20:17:06 <dons> (its a C library, get it from your package manager)
20:17:23 <TomMD> know what the apt name is?
20:17:38 * LoganCapaldo guesses libpcre-dev
20:17:52 <_keegan_> on debian testing i see libpcre3 and libpcre3-dev
20:17:53 <dons> looks plausible
20:17:57 <LoganCapaldo> but this is what apt-cache search is for
20:18:22 <gwern> dons: I installed pcre-light 0.1; how I cabal install .2 after a cabal update?
20:18:24 <dons> _keegan_: pcre3? (the dev version is up to pcre7 now)
20:18:31 <dons> gwern: should work.
20:18:39 <dons> or you might need to specify pcre-light-0.2
20:18:39 <_keegan_> *shrug* it's what i see in apt-cache search pcre
20:18:50 <dons> ok. interesting
20:19:21 <TomMD> I installed libpcre3-dev, but the cabal install now says it is missing PCRE_BSR_ANYCRLF, and a bunch of others (though not as many).
20:19:22 <gwern> hm. didn't know cabal install accepted version numbers
20:19:27 <sjanssen> dons: does libpcre work with pkg-config?  If so, Cabal can give you a nice error at configure time when it's missing
20:19:33 <sarah__> is "testing" more recent than "unstable?"
20:19:44 <_keegan_> sarah__, testing is less recent
20:19:50 <_keegan_> stable < testing < unstable < experimental
20:20:00 <sarah__> didnt even know last existed =p
20:20:10 <gwern> dons: the test in .2 fails for me
20:20:14 <_keegan_> you can also install packages from any release into any system, if you have apt configured right
20:20:20 <gwern> 'No instance for (Data.String.IsString S.ByteString),,,'
20:20:23 <_keegan_> i.e. if i apt-get something it comes from testing by default, but i can choose one of the others
20:20:47 <dons> gwern: as you've not got bytestring 0.9.0.4, try updating bytestring first
20:20:59 <dons> TomMD: ok. sounds like an older version of pcre
20:21:05 <dons> i can probably work around that.
20:21:23 <TomMD> dons: I just got the source for 7.5 - I'm working on it, just a sec.
20:21:33 <gwern> dons: ok, I just did that
20:21:47 <gwern> the error changed to: Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString' against inferred type `S.ByteString'
20:22:21 <sjanssen> gwern: you've got a stale library installed
20:22:33 <dons> yep. you'll have to rebuild pcre-light
20:22:43 <dons> its compiled against the old bytestring
20:22:44 <gwern> bah
20:22:45 <TomMD> dons: And everything works with latest libpcre (7.5).  Next stop is the testsuite.
20:23:06 <dons> TomMD: ok. awesome. so there's a backwards compat issue with some symbols. thanks -- i'll add that to my todo list
20:23:36 <gwern> well, that's just great. how do I do that in cabal install? it won't reinstall, and there's no force option I know of
20:23:58 <sjanssen> gwern: you could trick it with ghc-pkg unregister
20:24:20 <dons> ghc-pkg unregister pcre-light
20:24:47 <dons> then cabal install pcre-light again (shouldn't download, but will rebuild)
20:24:53 <gwern> so I take it that functionality is not yet included in cabal install?
20:25:24 * gwern tacks on the --user option
20:25:50 <TomMD> Unit.hs:65:16:
20:25:50 <TomMD>     No instance for (Data.String.IsString S.ByteString)
20:25:50 <TomMD>       arising from the literal `"the quick brown fox"'
20:25:50 <TomMD>                    at Unit.hs:65:16-36
20:25:50 <TomMD> So whats that new fangled bytestring representation -X option again?
20:26:20 <TomMD> Dons: ^^^ what the tests told me at compilation.
20:26:35 <dons> again, that's from needing a newer version of bytestring
20:26:41 <dons> cabal install bytestring-0.9.0.4
20:26:54 <LoganCapaldo> -XOverloadedStrings I think
20:26:54 <gwern> dons: wouldn't 'runhaskell Unit.hs' work even better?
20:26:57 <gwern> incidentally, it passed all the tests
20:27:17 <dons> so you're in the same boat as gwern now. you'll need to unregister pcre-light, update bytestring from cabal, then try again with pcre-light
20:27:22 <dons> gwern: awesome.
20:27:32 <hexpuem> Using the "data List a = Cons a (List a)" list style how do i manually construct a list?
20:27:34 <dons> gwern: there's some bug in ghci. try 'runhaskell Unit.hs' and let me know if it passes
20:27:52 <sjanssen> hexpuem: first, you provide a Nil constructor ;)
20:27:56 <dons>   Cons 'x' (Cons 'y' ... umm, no Nil :)
20:27:56 <gwern> dons: I wouldn't've suggested it if it didn't work for me :)
20:28:17 <dons> ok. it segfaults ghci on my box (i think it must be a ghci Linker.c bug on openbsd)
20:28:23 <gwern> gwern@localhost:1004pcre-light/0.2/pcre-light-0.2/tests>runhaskell Unit.hs                                                          [11:28PM]
20:28:26 <gwern>  Cases: 563  Tried: 563  Errors: 0  Failures: 0
20:28:28 <dons> allocates in the wrong place or something
20:28:30 <dons> yay, great.
20:29:14 <dons> TomMD: so do you know how to proceed?
20:29:29 <dons> (the issue was that the testsuite depends on a newer versoin of bytestring, than the core lib does)
20:30:11 <sarah__> @pl zip (allSquares b) (allPos b)
20:30:12 <lambdabot> zip (allSquares b) (allPos b)
20:30:18 <hexpuem> ah whoops haha
20:30:20 <hexpuem> thanks
20:30:59 <LoganCapaldo> @pl \b -> zip (allSquares b) (allPos b)
20:30:59 <lambdabot> liftM2 zip allSquares allPos
20:31:03 <gwern> hm. yi just broke
20:31:37 <dons> "Unlike Haskell, however, Quack is not purely functional: functions can have side-effects (read from a file or something), but it is your responsibility not to depend on execution or execution order. "
20:31:46 <dons> scary mkcleary
20:32:20 <TomMD> dons: yes, all good now (tests passed).  I think cabal is lacking a 'reinstall' for when one package (libpcre) is built on an old package (bytestring) then the old package gets updated and you want to rebuild.
20:32:36 <TomMD> i.e. I did it manually - don't know if there is a better way.
20:32:42 <dons> ok. useful to know. its interesting seeing problems happen in cabal install live like this.
20:33:16 <gwern> dons: btw, the darcs repo listed on yr yi page <http://www.cse.unsw.edu.au/~dons/yi.html> is kind of outdated now that it runs out of http://code.haskell.org/yi
20:33:22 <dons> ok.
20:33:29 <LoganCapaldo> "Unlike Haskell, in Quack every function is potentially using unsafePerformIO without your knowledge. Good luck." [paraphrase] ;)
20:34:02 <dons> that's scary, because they're parallelising the code -- so either they break optimisations, or they have to be super smart inferring effects
20:34:05 <dons> i guess the former
20:34:20 <TomMD> ye of little faith
20:34:25 <gwern> ...did someone actually name their language Quack?
20:34:36 <TomMD> ...better than brain****
20:35:18 <dons> oh, its not lazy. so not so bad. its just a strict, impure language.
20:35:35 <dons> hmm, but its parallel and "does not depend on execution order,"
20:36:29 <dons> so anyone using pcre-light yet? :)
20:36:42 * dons wants to kill off regex-* from the extralibs
20:37:06 <gwern> dons: if by using, you mean causing my yi build to fail, I think I am
20:37:14 * gwern looks up what modules pcre-light provides
20:37:28 <dons> gwern: i'm not sure yi would touch pcre-light...
20:37:37 * SamB (a) doesn't use regular expressions much anyway and (b) is way behind in GHC/libs updates...
20:37:44 <brad__> dons, i noticed in your .xmonad config files you swap ctrl and capslock, did you know you can set this in your xconfig? Option "XkbOptions"  "ctrl:swapcaps"
20:37:52 <Lycurgus> it appears that the kernel is not going to be formally defined in prime either. Is there an obvious reason for that?
20:38:14 <SamB> Lycurgus: maybe it would be silly?
20:38:22 <SamB> and/or really hard
20:38:36 <brad__> by the way in freebsd at least you can use sysinstall to set the swapping to be for the whole os, console, x or whatever
20:38:38 <dons> brad__: i swap it with xmodmap. actually, i just disable capslock
20:38:51 <gwern> (wait, maybe it's bytestring's fault)
20:39:10 <brad__> openbsd may have something like freebsd's keyboard settings so you can have these swapped out of x too
20:39:21 <Lycurgus> SamB: I'm probably missing something which will become clear later.
20:39:30 <brad__> so glad ghc works on freebsd7 now....
20:40:05 <brad__> looking forward to using pcre-light....thanks for that, it will be helpful
20:40:15 <thetallguy> dons: why? (kill off regex-*,that is)
20:40:28 <gwern> it is bytestring's fault! you dirty dog bytestring-0.9.0.4!
20:40:33 <brad__> i know regexes get slapped around a bit, but i  still lean on them here and there
20:40:49 <dons> thetallguy: various reasons, mostly centering around the size of the binding, its complexity and portability
20:40:52 * gwern shakes fist angrily in its general direction. make me forget I had to install you to test pcre-light!
20:41:16 <thetallguy> dons: thanks.  Just curious.
20:41:33 <brad__> how is real world haskell coming along?
20:41:49 <TomMD> The million dollar question
20:42:05 <dons> lots written! more chapters online in the next few weeks. bos is leading the charge
20:42:16 <brad__> cool! looking forward to it
20:42:16 <bos> yay us!
20:42:28 <dons> expect awesomeness
20:42:41 <dons> and something heavy to hit haskell skeptics on the head with
20:42:42 <bos> brad__: i'm revising an early chapter now, might get to publish the first drafts publicly as soon as tonight
20:43:08 <brad__> awesome bos, this is going to be huge
20:43:09 <bos> although the internal reviewers have given me a severe beating on this chapter, so it's taking a while :-)
20:43:19 <TomMD> dons: If you want a lame quote for the book, use one of my coworkers "But recursion is slow!"
20:43:53 <TomMD> Translation: I'll be taking advantage of that books weight.
20:44:15 <brad__> if the book gets on shelves in 2008 it will be huge for haskell
20:44:44 <brad__> dons and bos - you should start doing state of the onions
20:45:00 <brad__> like larry
20:45:13 <LoganCapaldo> no they need to do church of the onions
20:45:19 <bos> brad__: i'll be writing something up once i publish the first chapters for all to see.
20:45:28 <gwern> brad__: it's big only if it's good; simply being a textbook on haskell isn't enough. there's plenty of those
20:45:39 <rue> Can one curry an onion?
20:45:41 <TomMD> LoganCapaldo: Do we really need to encourage language wars to heat up to the level of religious wars?
20:46:02 <LoganCapaldo> not that church
20:46:13 <TomMD> Oh ;-) I got you!
20:46:31 <brad__> agree gwern, although given the authors, i know the content will be solid...many publishers just unleash hacks on public documentation and get something quick to market...i know dons and bos will have high standards
20:46:31 <LoganCapaldo> i was riffing on the seperation of church and state joke :)
20:47:05 <allbery_b> church of the curry?
20:47:08 <dons> thetallguy: this regex thing is a bit of a syndome in haskell -- research ideas get pushed until they're publishable , leading to huge libraries like haxml, the regex-*, wash, hs-plugins, ... ; then to make them usable, they have to be reimplemented to be small, fast and lean.
20:47:27 <Lycurgus> r
20:47:57 <kmcallister> LoganCapaldo, that joke is a staple of the intro CS course here
20:48:06 <brad__> take care and good night!
20:48:37 <dons> brad works in nyc, and drops in here during work hours to ask quick haskell questions. but i've no idea what he's working on.
20:48:45 <dons> we'll have to set a trap to find out sometime
20:49:07 <dons> since i suspect its something commercial. in some backroom at a bank or something
20:49:48 * gwern files my fifth bug of the night for yi :)
20:49:48 <LoganCapaldo> lol
20:50:09 <allbery_b> yiish
20:51:21 <gwern> I hope to one day replace emacs with yi
20:51:44 <gwern> then all I'll need for my haskell userland would be a web browser and a shell...
20:51:59 <sclv> dons: on the regexp question, i'm curious if pcre-light actually beats the pure haskell dfa implementation.
20:52:05 <TomMD> Just remember we want dons et al to finish Real World Haskell BEFORE yi has to take over the eath
20:52:30 <gwern> TomMD: well dons et al don't really work on yi any more
20:52:44 <TomMD> oh?  I am so behind yi times.
20:52:46 <sclv> I was given to understand that the pure lisp pcre implementation slightly outperforms perl, and i see no reason why a haskell one that does the same sort of compilation to closures, so to speak, wouldn't do the same.
20:53:09 <gwern> TomMD: yeah, he turned it over to bernandy
20:53:29 <gwern> sclv: as I understood it, the lisp one cheated on worst cases
20:53:32 <sclv> if the interface is confusing that's one thing, but if the engine behind it is actually solid and performant it seems like a win for haskell.
20:53:33 <dons> i'm not working on yi :)
20:53:41 <dons> my involvement stopped in about 2005
20:53:43 <sclv> gwern: oh. :-(
20:54:03 <sclv> cheating is way more impure than a ff binding.
20:54:14 <gwern> TomMD: see?
20:54:18 <sclv> metaphysically speaking at least.
20:54:24 <TomMD> lol - that was before I even got onto the Haskell scene.
20:54:24 <gwern> sclv: actually, it was an interesting article, I'll see if I can dig it up
20:54:31 <atp> existential types are sort of tricky
20:54:32 <LoganCapaldo> there's no such thing as cheating as long as you cant get caught
20:54:51 <gwern> sclv: well grep cheats too if that's how you want to think about it
20:55:02 <HairyDude> has anyone defined a class for monads providing nondeterministic choice?
20:55:07 <kmcallister> atp, what are you doing with existential types?
20:55:37 <atp> kmcallister: working with the ST monad
20:55:42 <kmcallister> ah
20:55:48 <atp> kmcallister: actually, i'm mostly failing at this point
20:55:57 <atp> kmcallister: thinking imperatively is hard
20:56:03 <kmcallister> i've done a bit with the ST monad
20:56:07 <kmcallister> heh, yeah
20:56:24 <sclv> Ok so I've got a cabal/haddock question. I have a package Foo and it uses Foo.Internal and Foo.Classes and then rexports them both. How do I get the re-exported functions to show up properly in Foo's documentation?
20:56:59 <sclv> This is with 0.9.
20:57:09 <atp> kmcallister: basically, i have this matrix which is a two dimensional mutable array.  i need to keep a reference to it around so that i can readArray and writeArray, but passing it around everywhere is annoying.  so I decided to stick it in a reader monad.
20:57:51 <kmcallister> atp, the problem is likely that your monad type doesn't contain the typevar s of the ST monad type
20:57:54 <atp> kmcallister: the thing is, if I have something like forall s. ReaderT (STArray ...) (ST s) a
20:58:39 <atp> kmcallister: that's impossible, because STArray needs to be in the ST monad, and without unsafe hackery I can't take it out
20:58:57 <atp> kmcallister: so I end up with ReaderT (ST s STArray ...) (ST s) a
20:59:25 <liyang> newsham: in case you're still wondering about what Hutton's Razor is... (sorry, I was Googling for other usages of the phrase. You mentioned it back in September... http://tunes.org/~nef/logs/haskell/07.09.30 )
20:59:38 <atp> kmcallister: but then when I try to do something like askMatrix = ask >>= lift, the type checker yells at me because it thinks the s's in the two ST monads are different :(
21:00:23 <gwern> sclv: http://swtch.com/~rsc/regexp/regexp1.html <-- not sure if that's it, but worth reading
21:00:23 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
21:00:24 <liyang> newsham: it's the idea that you can model a fair chunk of computing using the language E ::= Z | E + E
21:00:36 <atp> how EZ
21:00:39 <atp> hehe
21:00:54 <kmcallister> atp, i see
21:01:18 <kmcallister> i think what you need is some kind of ST transformer
21:01:24 <liyang> newsham: plus whatever you're interested in of course, be it interrupts, exceptions, nondeterminism or something else.
21:01:50 <atp> kmcallister: does such a thing exist?  I thought ST was like IO.... it needs to be the most inside it can be
21:01:57 <kmcallister> yeah, i don't think it does exist
21:02:02 <kmcallister> i solved a problem like this recently though
21:02:54 <atp> i mean i could always thaw and unsafeFreeze repeatedly, but that would be... how should i put it... evil
21:02:55 <sclv> on my haddock question -- it doesn't seem do-able? the haddock command passed to Setup.lhs seems to only pass it the exported files.
21:02:59 <kmcallister> newtype LispM s a = LispM (ErrorT LispError (ST s) a)
21:03:27 <atp> kmcallister: cute
21:03:33 <kmcallister> return and (>>=) defined the usual way (actually, i probably could have derived them using GHC's newtype derivs)
21:03:43 <liyang> newsham: (It's a simplification of the idea that well, monads are a fairly good model of computation. Monoids are close enough, without getting into the mess of naming and binding. And the integers with addition is a monoid.)
21:04:09 <kmcallister> i guess this is different though, in that LispError doesn't contain any ST stuff
21:04:11 <atp> kmcallister: see, i tried doing that, and GHC complained until i put in a forall s., and then it complained because newtype can't encapsulate existential types
21:04:44 <atp> the problem here isn't haskell, the problem is that i just don't grok existential types well enough
21:05:08 <kmcallister> it may be that what you're doing (pulling stuff out of the inner ST monad and putting it in the outer Reader monad) is not possible
21:05:49 <atp> kmcallister: maybe I need to try to make ST (r -> a) into a monad or something
21:05:57 <atp> kmcallister: that's probably possible
21:06:09 <kmcallister> ah, yeah
21:06:11 <atp> ST s (r -> a) rather
21:06:22 <atp> that's your ST transformer idea
21:06:50 <kmcallister> yeah, that might work
21:07:31 <atp> seems like there ought to be a better ... or rather easier ... way
21:08:08 <atp> whenever i start trying to do something really complicated i try to take a step back and see if there's any easier way
21:08:13 <atp> usually i'm being stupid
21:08:48 <kmcallister> try to write withNewSTRef :: a -> (STRef s a -> ST s b) -> ST s b
21:09:10 <sclv> Should I just expose Foo.internal and expect that foax normally wouldn't call it directly then?
21:09:21 <atp> hm, STRef... that's true, that never even occurred to me
21:09:31 <kmcallister> well STArray and STRef should behave roughly the same
21:10:04 <atp> i don't much like ST & IO
21:10:23 <atp> i started this project because i decided it was time to get over my fear of impurity :)
21:10:46 <liyang> As long as your intentions are pure.
21:10:57 <liyang> It's all good.
21:11:12 <allbery_b> ST is pue, I thought
21:11:14 <allbery_b> pure, even
21:11:31 <liyang> It looks pure from the outside, but it's impure at heart. :3
21:11:57 <liyang> And that's not a bad thing too.
21:12:02 <atp> allbery_b: it's basically encapsulated imperative computation... mutable state, that sort of thing
21:12:20 <atp> it's annoying that you have to deal with the existential types though
21:12:45 * allbery_b hasn't done any ST yet... too painful
21:13:01 <kmcallister> allbery_b, it's implemented the same way as IORefs, but the existential type trick allows you to write runST :: (forall s. ST s a) -> a
21:13:08 <kmcallister> without doing anything "unsafe"
21:13:43 <atp> yeah, everything inside runST is all yucky but from the outside referential transparency is preserved
21:13:57 <atp> it's really pretty cool, actually
21:14:05 <atp> it's just hairy (for me, because i'm not cool enough)
21:14:15 <Tac-Tics> ST is like adding the power of assignment back into Haskell
21:14:20 <Tac-Tics> but keeping it pure
21:14:31 <atp> assignment is really overrated though
21:14:46 <atp> algebraic manipulation of source code for the win!
21:15:17 <Tac-Tics> Assignment and I go way back, so don't be dissin'!
21:15:36 <hpaste>  kmcallister pasted "STRef with ReaderT" at http://hpaste.org/4984
21:15:48 <thetallguy> atp: just out of curiosity, do you know the origin of the phrase "for the win"?
21:15:52 <liyang> (trip-hop is like adding the power of bling to hip-hop, but keepin' it real.)
21:16:00 <kmcallister> atp, this works for me on GHC 6.6, is it something like what you want?
21:16:25 <kmcallister> (presuming it can generalize to STArrays instead of STRefs which i think should be no problem)
21:16:27 <atp> kmcallister: yes, that looks cool
21:18:18 <atp> thetallguy: no, actually, i don't.  what's the origin?
21:19:01 <thetallguy> atp: it's from the game show "Hollywood Squares"
21:19:09 * bos scours the prelude for pure non-polymorphic functions of more than one argument
21:19:20 <thetallguy> atp: I was surprised to read that it's become a new catch phrase
21:19:26 <gwern> I like the origin of 'frog blast the vent core!' better
21:19:33 <atp> thetallguy: not exactly new, but yeah
21:19:38 <thetallguy> gwern: don't know that one.
21:19:40 <bos> hm, can't find any.
21:19:57 <thetallguy> gwern: any relation to "Toad the Wet Sprocket"?
21:20:26 <gwern> don't think so
21:20:31 <thetallguy> Ah, marathon.
21:20:33 <atp> i'm going to bed guys
21:20:40 <thetallguy> I didn't play that much.
21:20:45 <gwern> oh 'tis 'tis a glorious thing to be a pirate king!
21:20:45 <atp> thanks for your help, kmcallister
21:20:50 <sjanssen> bos: (&&)
21:20:53 <kmcallister> no problem, good luck
21:21:06 <gwern> (hurrah hurrah for the pirate king, hurrah hurrah for the pirate king!)
21:21:11 <thetallguy> ?type floatToDigits
21:21:13 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
21:21:24 <bos> sjanssen: i haven't introduced operators-as-functions yet.  i'm operating under a lot of annoying constraints :)
21:21:35 <kmcallister> > floatToDigits 5 3.141
21:21:37 <lambdabot>  ([3,0,3,2,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3],1)
21:21:45 <kmcallister> > floatToDigits 10 3.141
21:21:46 <lambdabot>  ([3,1,4,1],1)
21:21:54 <kmcallister> ah, clever
21:21:56 <kmcallister> what's the last value?
21:22:02 <thetallguy> bos: that's the real trick of any Haskell docs
21:22:13 <thetallguy> bon: disentangling all the features.
21:22:33 <bos> thetallguy: yeah, it's tying the knot for writing :-)
21:23:00 <thetallguy> bos: I always want to use (+ 2) to show off currying and partial application
21:23:25 <thetallguy> bos: but then I have to explain that first...
21:24:20 <kmcallister> > let plus a b = a + b in map (plus 2) [1,2,3]
21:24:23 <lambdabot>  [3,4,5]
21:24:54 <kmcallister> then it's not too far a jump from (plus 2) to (+ 2)
21:25:14 <liyang> > let plus a b = a + b in map (`plus` 2) [1,2,3] -- :)
21:25:15 <lambdabot>  [3,4,5]
21:25:22 <sjanssen> except (plus 2) and (+ 2) aren't the same thing
21:25:23 <kmcallister> (although in this case the argument orders are reversed so that might be misleading, especially to someone coming from scheme)
21:25:23 <kmcallister> yeah
21:25:31 <kmcallister> they are but only because + is commutative
21:25:45 <sjanssen> (or we hope it is)
21:26:20 <kmcallister> well + :: Int -> Int -> Int had better be commutative :)
21:26:41 <kmcallister> is it required that it be commutative for all Num instances?
21:27:02 <scook0> I doubt it
21:27:23 <sjanssen> Haskell can't enforce those sort of rules
21:27:25 <scook0> H98 says very little about typeclass laws
21:27:37 <thetallguy> >floatToDigits 5100
21:27:46 <kmcallister> sjanssen, yeah, i meant required in the sense of it being in the spec
21:31:09 <thetallguy> ?type fromIntegral
21:31:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:31:29 <thetallguy> > floatToDigits 100
21:31:30 <lambdabot>  <Double -> ([Int],Int)>
21:31:58 <thetallguy> >floatToDigits 10 100
21:32:05 <dons> ndm Configuring tagsoup-0.1...
21:32:06 <dons> Warning: No license-file field.
21:33:54 <gwern> hm. tagsoup could use an update then. darcs is at 0.3
21:35:45 <dons> that would be useful
21:36:24 * gwern will send him a patch suggesting that then
21:38:01 <dons> great work gwern. we need to get you as the hackage 'wrangler', chasing up breakages :)
21:40:18 <gwern> I dunno dons. I've been bugging people and sending patches like crazy, but I can only take credit for 4 uploads so far
21:40:25 <Cale> heh, just installing cabal-upload to upload the updates to the Imlib library which gwern sent me, and I get an error in building HTTP :)
21:41:11 <dons> gwern: takes a while for releases to happen -- often a single patch won't trigger a release
21:41:55 <gwern> sure, but a lot of them are just static; all they had to do was bump a minor version and re-release, there being no other changes to merge in
21:42:40 <gwern> (and some of them are positively ancient. I think StrategyLib was last touched just to update it for 6.6.2, and I haven't seen how to fix it for 6.8.x, or take Edison, which goes back to '98 and earlier)
21:44:32 <dons> then in that case, its probably maintainers not interested
21:44:51 <dons> ideally, you'd forward those to the list, and we could get a copy of the repo, and do the relelase ourselves
21:45:22 <gwern> alright. I'll keep a list of the too-hard ones then
21:46:04 <gwern> (edison is somewhat actively maintained, if you were wondering, and I did manage to fix whatever the problem was. but fixing -walls turned out to be a nightmare)
21:46:53 <gwern> and that reminds me dons, you haven't been perfect about making releases under my prodding yourself :)
21:47:58 <dons> right, since i don't necessarily do a release just for -Wall failures :)
21:48:05 <dons> however, i do apply the patches
21:48:56 * gwern considers actually-building a feature worth releasing for ;)
21:49:07 <Cale> gwern: The patches you sent me were backwards, btw. :)
21:49:35 <gwern> Cale: oh. they were?
21:49:47 <Cale> Yeah, they wouldn't apply without -R
21:49:48 <gwern> Cale: you refer to the sdl copy-paste error?
21:50:30 <gwern> I'm a dunce when it comes to manually using diff, sry
21:51:01 <ac> davidL: I wouldn't bother doing a FFI call to determine weather a file is a PNG file. Just check if it starts with "0x5089474e0a0d0a1a"
21:51:11 <Cale> There's one hunk which doesn't seem to apply to Imlib.hs -- not sure why yet.
21:52:40 <davidL> ac: I know png_sig_cmp will compare more than 8 bytes for further confidence, but I agree, it's not the most useful binding
21:54:13 <davidL> > 0x5089474e0a0d0a1a
21:54:16 <lambdabot>  5803247995345242650
21:55:35 <ac> davidL: yeah, I meant "0A 1A 0A 0D 47 4E 50 89". That was the wrong number above
21:57:14 <davidL> > map chr [0x0a,0x1a,0x0a,0x0d,0x47,0x4e,0x50,0x89]
21:57:17 <lambdabot>  "\n\SUB\n\rGNP\137"
21:58:14 <ac> anybody have code to efficiently calculate a CRC check?
21:58:37 <ac> why is the "PNG" backwards?
21:58:42 <jcreigh> http://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
21:58:43 <lambdabot> http://tinyurl.com/23w3pl
21:59:12 <jcreigh> WP says the correct header is 89 50 4E 47 0D 0A 1A 0A
21:59:24 <ac> which is exactly the reverse of what I had for some reason
21:59:29 <jcreigh> yeah
21:59:30 <davidL> hm
21:59:38 <ac> oh, I know, because I used dc to get the hex encoding
21:59:47 <ac> and I used "print stack"
21:59:48 <davidL> > reverse $ map chr [0x0a,0x1a,0x0a,0x0d,0x47,0x4e,0x50,0x89]
21:59:49 <lambdabot>  "\137PNG\r\n\SUB\n"
21:59:53 <davidL> :)
22:00:46 <ac> the damn png spec gives the header in decimal
22:01:02 <pastorn> @type chr
22:01:03 <jcreigh> ac: oh? That doesn't seem very useful.
22:01:04 <lambdabot> Int -> Char
22:01:20 <davidL> RFC 2083 ?
22:01:24 <ac> I shouldn't complain though, as the PNG spec is very straight forward
22:01:36 <ac> http://www.w3.org/TR/PNG/
22:01:37 <lambdabot> Title: Portable Network Graphics (PNG) Specification (Second Edition)
22:02:21 <davidL> > map chr [137,80,78,71,13,10,26,10]
22:02:22 <lambdabot>  "\137PNG\r\n\SUB\n"
22:03:08 <gwern> ergh. enough haskelling for tonight
22:03:14 <davidL> ac: have you decided to create bindings to just rewrite the spec in haskell?
22:03:24 <gwern> night everyone
22:05:23 <ac> davidL: well, considering I've read about half the PNG spec... uhm...
22:05:35 <ac> davidL: I guess I'm leaning towards the latter
22:06:10 <ac> huh. for indexed pallette images, the pallette can only be specified in 8 bit color depth. I wonder why
22:06:21 <sclv> Anyone know how to check with cpp what version of GHC you're using?
22:06:37 <ac> I guess it makes sense. Anything more than that, and you should use non-indexed encodings
22:06:38 <sclv> or should that be done with cabal then defining a flag itself?
22:07:10 <ac> you can always specify the actual colors of the pallette with an ICC profile
22:08:06 <davidL> ac: here is a crc32 implementation: http://www.hcsw.org/haskell/crc32.hs
22:08:15 <ac> davidL: thanks :-)
22:08:29 <ac> obviously I have too much time on my hands
22:08:37 <davidL> :)
22:08:59 <davidL> a haskell png interface would be useful
22:09:24 <ac> davidL: excellent, because I'm going to write one!
22:09:50 <ac> davidL: is that CRC check optimized for a particular polynomial? (note I do not fully understand CRC checkes yet)
22:11:08 <davidL> hm, well PNG uses x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
22:11:16 <ac> yeah
22:13:12 <jcreigh> oh, it's not standard CRC32?
22:13:35 <davidL> no it is, 0x04C11DB7, it's the first one in the crctab
22:14:21 <ac> davidL: so that code will work for PNG's CRC check?
22:14:35 <davidL> it should yes
22:19:05 <ac> cool. That will definitely save me some time
22:32:10 <ac> is it really that useful knowing your image is corrupted?
22:36:41 <Cale> It could be, if the image is important.
22:40:25 <dons> yay, Imlib 0.1.1
22:41:17 <ac> The data types in that code don't look right. Shouldn't it take a ByteString or mabye a [Word8]?
22:47:22 <ac> instead calc_crc32 takes a [Char]
22:52:08 <sjanssen> ac: the code is probably from the old days when Char = Word8
22:54:11 <ac> I will convert it to [Word8]
22:54:54 <ac> (which consists of s/Char/Word8/ ;))
23:02:42 <ac> How do I know if this CRC is producing the right number?
23:21:14 <sclv> Any comments on this: http://fmapfixreturn.wordpress.com/2008/01/14/hstringtemplate-an-elegant-functional-nifty-templating-engine-for-haskell/
23:21:15 <lambdabot> Title: HStringTemplate: An Elegant, Functional, Nifty Templating Engine for Haskell.   ..., http://tinyurl.com/2g42nk
23:21:22 <sclv> I'm about to send the announcement to h-cafe
23:24:17 <ac> sclv: awesome, I'll check it out
23:24:49 <sclv> editing comments welcome too, on how to make the announcement nicer!
23:28:33 <ac> sclv: the text is a little low contrast for me :-P
23:29:47 <sclv> haha yeah, wordpress doesn't give the best template options...
23:31:51 <ac> sclv: so it looks like setAttribute takes a template and returns a new template with that attribute set?
23:32:02 <ac> sclv: I suppose I should just look at the type signatures
23:32:23 <sclv> ac: yep. the haddocks should hopefully be pretty helpful too.
23:32:39 <ac> sclv: do you have a link to the haddocks?
23:33:20 <sclv> http://code.haskell.org/HStringTemplate/dist/doc/html/hstringtemplate/Text-StringTemplate.html
23:33:20 <lambdabot> http://tinyurl.com/3yz8od
23:36:36 <ac> is there anything in the API like this: "foldl (\(k,v) temp -> setAttribute k v temp)"?
23:36:57 <ac> for setting a list of (name, attribute)s?
23:38:08 <ac> sclv: if not, I'd imagine that would be a good thing to add
23:38:10 <sclv> hmm... not yet! that's not a bad idea.
23:38:50 <ac> sclv: or maybe even something that takes an asc. list for extra conciseness
23:39:26 <sclv> an asc list? with default names you mean?
23:39:48 <ac> sclv: asc list as in ["attribet_name_1", value_1, "attribute_name_2", value_2, ...]
23:40:24 <sclv> oh, i guess, but you can set an attribute to anything you want, not just a string.
23:40:32 <sclv> you just need to put the typeclass machinery in place.
23:40:57 <sclv> once i set up an instance for, e.g., HAppS data, and can handle generics nicely, it should really shine.
23:41:16 <sclv> You can, for example pass a map of maps and call $foo.bar.baz$
23:41:32 <ac> sclv: ah I see, than an asc list would be pretty useless
23:41:34 <sclv> and if baz is a list you can call $last(foo.bar.baz)$
23:42:12 <ac> sclv: can you put a template in a template? ;)
23:42:12 <sclv> or if you pass a float, an optional format param lets you choose the precision, etc.
23:42:35 <sclv> ac: yep! the grammar is really awesome -- I need to rewrite all the docs I linked to to show just how awesome.
23:43:10 <sclv> you can use anonymous templates or normal ones, and if you call, say, $foo:bar(),baz()$ and foo is a list, it will alternate applying bar and baz to it
23:43:38 <ac> sclv: cool. I imagine I will be using this code soon
23:44:28 <sclv> ooh, and if you call $foo, bar:{a, b| $a$ $b$}$ it will iteratively apply the anonymous template to each pair from foo, bar, like a parallel list comprehension!
23:45:27 <sclv> ac: glad there's an audience for this. i'll be really interested to see the ways in which people use/break it.
23:46:00 <nelhage> Isn't [(k,v)] usually referred to as an asc list (or alist or association list), and [key,val,key,val...] a plist?
23:54:29 <andyjgill> Does anyone know of a small, clean (and slow?) UM written in Haskell from the ICFP programming contest in 2006?
23:54:48 <dons> Igloo, dcoutts hackage web server down?
23:54:59 <dons> andyjgill: i can find you one....
23:55:15 <andyjgill> The UNSW one?
23:55:16 <dons> andyjgill: i collected them all here, http://www.cse.unsw.edu.au/~dons/um.html
23:55:17 <lambdabot> Title: Haskell UM
23:55:25 <dons> well, ours was certainly slow :)
23:55:41 <andyjgill> Which was cleanest? Was there a functional one?
23:55:54 <dons> i'm not sure how clean they are though. i'm not sure there's even a purely functional one.
23:55:59 <dons> but it would be 2 hours work
23:56:19 <andyjgill> Yes, it would be. I written 3 already :-)
23:56:29 <dons> might be worth asking on -cafe@ , probably there's some functional ones.
23:56:48 <dons> btw, working out why haskell sucks at fast virtual machine implementations, and how to fix that, would be a great paper :)
23:56:51 <andyjgill> I was just hoping for a clean specification style Haskell implementation
23:57:05 <dons> there may have been a more spec-like version written after the contest
23:57:14 <dons> that wouldn't be on that page, but might be found by asking -cafe@
23:57:35 <kmcallister> dons, my favorite way around that is to have Haskell generate C/C++ code implementing the VM program
23:58:11 <andyjgill> Thanks for the pointer.
23:58:23 <dons> yeah, a generational approach is certainly worthwhile
23:59:01 <andyjgill> I tried to have a Haskell program that spat out a larger C switch statement, which was compiled.
23:59:10 <andyjgill> crashed gcc after 2G of VM
23:59:15 <dons> awesome
23:59:22 <kmcallister> it occurs that a Haskell library/EDSL for generating C would be very useful
23:59:26 <kmcallister> does anything like this exist?
23:59:46 <Cale> I wonder how those numbers would look using GHC 6.8.2
23:59:48 <dons> kmcallister: that would be very useful. i developed a stub of one for a monte carlo model generator, but a full lib would be a killer app
23:59:52 <andyjgill> There was a code generator paper in the Haskell workshop?
