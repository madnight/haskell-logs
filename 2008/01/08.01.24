00:00:43 <Cale> jsnx: So does that make some sense?
00:00:54 <Cale> Of course, it's not immediately obvious that this terminates :)
00:01:18 <jsnx> Cale: it does not really make any sense, to tell the truth
00:01:42 <Cale> Maybe it would be a little clearer with lists of booleans, rather than functions :)
00:01:56 <jsnx> i'm sure it would
00:02:01 <Cale> (but for that, you just need to replace # with :
00:02:12 <Cale> )
00:02:25 <jsnx> did not print
00:03:12 <jsnx> oh
00:03:14 <jsnx>  wait
00:03:26 <Cale> I think this just takes a bit of staring :)
00:03:39 <jsnx> Cale: you're saying, replace `#` with `:`
00:03:44 <Cale> yeah
00:03:49 <vincenz> Cale: like my code? :)
00:03:54 <Cale> and correct that typo which int-e pointed out :)
00:03:59 <jsnx> the newline through me
00:04:26 <Cale> exists f = f (find f)
00:04:36 <Cale> find f = if exists (\xs -> f (False : xs))
00:04:42 <Cale>             then False : find (\xs -> f (False : xs))
00:04:49 <Cale>              else True : find (\xs -> f (True : xs))
00:05:29 <Cale> an important point to remember in this is that f is a *total* function on boolean lists
00:05:51 <Cale> So when applied to any defined boolean list, it must terminate.
00:06:02 <jsnx> even infinite ones
00:06:04 <jsnx> ?
00:06:05 <Cale> right
00:07:21 <Cale> For example, the function which decides if the first True in a list occurs at an even position in the list is not total.
00:07:34 <dons> dcoutts: comparing the haskell and ocaml gtk bindings here is quite satisfying, good work :) http://reddit.com/r/programming/info/66e9b/comments/
00:07:38 <Cale> This is because it fails to terminate on (repeat False)
00:08:14 <vincenz> dons: the let _ = ... is silly in ocaml
00:08:33 <jsnx> aye, or anything else that has (repeat false) as an initial segment
00:08:44 <ivanm> the smalltalk one doesn't look to bad either
00:09:02 <ivanm> (not that I've ever really done any GUI programming, GTK or otherwise)
00:09:06 <ivanm> s/to/too/
00:09:11 <Cale> Well, a list having (repeat False) as an initial segment is equal to repeat False
00:09:25 <jsnx> Cale: you know, you're right actually...
00:09:39 <jsnx> ...i suppose that's the only list it will fail to terminate on, then
00:10:03 <Tac-Tic1> @let _ = fmap undefined $ undefined >>= undefined . undefined
00:10:07 <lambdabot> Add a type signature
00:10:12 <Tac-Tic1> aww
00:10:23 <Tac-Tic1> (that was going to be an example of a pointless definition
00:10:42 <jsnx> so, we can determine if these total functions are equal because we can enumerate the possibilities
00:10:43 <ivanm> heh
00:11:00 <vincenz> Cale: ping
00:11:23 <Cale> jsnx: Well, basically because we can use recursion to sneakily "figure out" what the largest index in the list that the function looks at is.
00:12:40 <Cale> vincenz: pong
00:12:45 <vincenz> pm
00:14:17 <jsnx> Cale: i'm going to look this over for a bit
00:14:26 <jsnx> Cale: however, i get it
00:14:32 <Cale> jsnx: cool :)
00:14:56 <Cale> You can read a longer development of the idea here: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
00:14:59 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
00:15:06 <dons> woot, SPJ on podcast! http://reddit.com/r/programming/info/66fx8/comments/
00:15:12 <dons> Simon Peyton Jones on Functional Programming and Haskell :: MP3 (dotnetrocks.com)
00:15:22 <dons> 7minutes 20seconds in they interview SPJ.
00:15:24 <siti> dotnetrocks :p
00:15:32 <dons> yeah! (amazing...)
00:17:04 <olsner> hmm, is ghc-asm perhaps incompatible with perl 5.10? it seems to be failing at removing __DISCARD__ calls
00:17:31 <sizur> microsoft is investing well into FP
00:17:57 <Twey> Is tail recursion important in Haskell?
00:18:05 <Twey> I heard someone say it wasn't optimised
00:18:25 <Tac-Tic1> I'm interested in learning F#
00:18:26 <dons> sure, its a goto
00:18:27 <vegai> Twey: quite the understatement
00:18:28 <sjanssen> Twey: tail recursion is actually used less often in Haskell than other languages
00:18:35 <Tac-Tic1> But I'm not sure I want to dust off the old windows box
00:18:40 <dons> wow, this is fun listening to SPJ explain laziness :)
00:18:46 <dons> to some .NET guys with no idea ... :)
00:18:55 <sjanssen> Twey: but I would not say "it wasn't optimised".  Where did you hear that?
00:18:58 <sizur> Tac-Tic1: F# works perfectly fine on Mono
00:19:01 <siti> if only I got a decent download speed or people were actually on the torrent :(
00:19:21 <siti> sizur: can you compile f# with mono though :p?
00:19:38 <Twey> sjanssen, I don't remember, someone in the Freenode equivalent of a pub discussion :-)
00:19:46 <sizur> siti: you mean compile the compiler?
00:20:00 <sizur> siti: or just f# code
00:20:01 <dons> sizur: the .mp3's worked fine for me.
00:20:04 <siti> f# code
00:20:09 <sizur> sure
00:20:09 <Tac-Tic1> I will have to check it out then
00:20:10 <Tac-Tic1> cool
00:20:13 <Tac-Tic1> I've never really used mono
00:20:43 <sjanssen> siti: I'm getting 400 KB/s
00:20:51 <siti> only 70 here :(
00:21:08 <jsnx> @localtime jsnx
00:21:11 <lambdabot> Local time for jsnx is Thu Jan 24 00:21:08 2008
00:21:21 <dons> go SPJ!
00:21:24 <jsnx> time for bed
00:21:31 <olsner> @localtime olsner
00:21:31 <lambdabot> Local time for olsner is Thu Jan 24 09:21:31
00:21:44 <jsnx> thanks for your time everyone
00:22:20 <dons> yay, the hosts "get laziness" 14minutes in :)
00:22:48 <sizur> laziness is a misnomer. but it's a cool one
00:23:30 <dons> in the internet age, we call it 'on demand computing' :)
00:23:38 <sizur> @users
00:23:38 <lambdabot> Maximum users seen in #haskell: 454, currently: 396 (87.2%), active: 16 (4.0%)
00:23:49 <siti> this channel really is expanding
00:24:33 <sizur> nah, it's a requirement for every haskeller to bring atleast 20 bots with her to the channel
00:24:42 <siti> hehe
00:25:07 <vegai> that dotnetrocks intro is rather painful :/
00:25:19 <dons> vegai: skip in. spj starts 7minutes 20secs
00:25:31 <vegai> aye
00:25:38 <dons> if this is mainstream programming media, i'm scared, fwiw :)
00:26:05 <dons> ok, laziness, 7..18 minutes. purity starts at 18 mins in.
00:27:51 <siti> sounds like it might be a frustrating podcast to listen to, but it's good to see haskell getting featured more
00:28:12 <dons> it gets pretty good about 20 mins in
00:28:17 <siti> ok cool
00:28:23 <dons> spj's talking about parallelism, and they're starting to understand :)
00:28:23 <sizur> one constantly needs to stress the basics
00:28:24 * sm listens
00:29:09 <dons> 21 mins in they "get purity"
00:29:30 <dons> that's a great conversion rate from SPJ :) converting 2 imperative programmers every 20 minutes :)
00:29:36 <opqdonut> :D
00:29:40 <siti> heh
00:29:53 <olsner> heh, 10 minutes per programmer - how long until they're all converted?
00:30:00 <dons> heh
00:30:08 <dons> there can't be that many java programmers, right?
00:30:17 <sizur> it's an exponential function
00:30:19 <Tac-Tic1> heh
00:30:31 <dons> they're sold on the need to program in parallel
00:30:43 <dons> so that's our killer weapon.
00:31:20 <sizur> oh yeah, i agree. parallesism.
00:31:37 <sizur> but we also need to push large scale modularity
00:31:40 <siti> if haskell takes off, it will be because of the need for parallism
00:31:45 <dons> "were there haskell compilers when .NET 1.0 came out? is it that old?"
00:31:52 <sizur> and we even lack that on our own turf
00:32:03 <vegai> agh, I didn't skip in and now I'm listening them snicker at unix
00:32:11 <dons> vegai: oh noes
00:32:25 <vegai> ah, now it begins
00:32:37 <sjanssen> dons: bwahaha
00:32:39 <glguy> url?
00:32:40 <dons> wow, these guys are really focused on .NET and visual studio
00:32:47 <dons> http://reddit.com/r/programming/info/66fx8/details
00:32:53 <sizur> .net is big
00:32:54 <siti> it rocks after all ;)
00:32:57 <dons> ah, now they're excited by F#
00:33:03 <dons> since it runs in .NET and .NET rocks
00:33:05 <sizur> and it's much nicer than java
00:33:12 * olsner runs off to shower before running to work
00:33:18 <Twey> sjanssen: So is it true at all?  Do I have to worry about making my functions tail-recursive?  Or is there some other pattern the compiler optimises?
00:33:51 <dons> Twey: you generally don't worry. if you care for speed, and have an issue, we can walk through how to optimise.
00:33:57 <dons> just compile with : ghc -O
00:33:57 <sizur> Twey: dont do any optimization when you write code. optimize when it's needed
00:34:04 <Twey> Ah, OK, thanks
00:34:07 <sjanssen> Twey: tail recursion will work just the same as any other functional language
00:34:18 <Twey> sjanssen, it is optimised more then?
00:34:32 <glguy> tail recursion is only useful if no partial result can be returned
00:34:42 <sjanssen> Twey: what you do need to be careful about is the accumulating parameter idiom that is usually used with tail recursion
00:34:54 <Twey> sjanssen: Oh?  Why?
00:35:05 <dons> glguy: that's a great canned response we can use for this question!
00:35:25 <sjanssen> Twey: check out http://www.haskell.org/haskellwiki/Stack_overflow
00:35:26 <lambdabot> Title: Stack overflow - HaskellWiki
00:35:27 <Svrog> dons: there are other languages that are pushing the parallelism angle - and to most imperative programers seem less intimidating than haskell
00:35:40 <Twey> dons, heh, in #javascript we have a bot full of those.
00:35:56 <dons> *shrug* i welcome my competitors using impure parallel languages
00:36:33 <sizur> i think i heared a lisper say same about non-lisp using companies
00:36:35 <vladimir_trs> How to convert a string into a number? Like "atoi/atof" functions in C?
00:36:46 <glguy> > read "56" :: Int
00:36:48 <lambdabot>  56
00:36:54 <kmcallister> vladimir_trs, show will convert any value it can to a string
00:36:57 <kmcallister> and read is the inverse
00:37:03 <dons> 29 mins in, SPJ explains why you'll be forced into pure-by-default if we're going to use those cores.
00:37:30 <sizur> > read "56" :: Float
00:37:31 <lambdabot>  56.0
00:37:52 <kmcallister> vladimir_trs, you can probably just use "read" without the type annotation, unless the compiler tells you you need it
00:37:54 <sizur> there is only one purity
00:38:01 <dons> hehe, side effects and parallelism: "at the start you're dead, and you try to resurrect a working program from that" :)
00:38:04 <sizur> and there are many impurities
00:38:11 <dons> (with impure-by-default)
00:38:15 <sjanssen> "just in time computing"
00:38:38 <vladimir_trs> Thank you. I tried > read "123", but without ":: Int", so it gave an error message.
00:38:51 <kmcallister> laziness is more than just an evaluation strategy... it's a way of life
00:39:12 <sizur> vladimir_trs: you need type annotation if you're passing the read expression to a polymorphic function
00:39:32 <sizur> kmcallister: laziness is a way of life?
00:39:36 <Tac-Tic1> I for one welcome our new Monad-bearing Overloads
00:40:02 <kmcallister> sizur, yes, for example it's how i read textbooks
00:40:05 <dons> ah, they get the need for implicit parallelism
00:40:05 <kmcallister> read it when you need to use it
00:40:12 <kmcallister> (aside from things i'm actually interested in)
00:40:22 <sizur> kmcallister: laziness == do not read it at all
00:40:45 <sizur> delayed evaluation == read it when you need it
00:41:01 <dons> yay, its getting quite sophisticated by the end.
00:41:12 <dons> they're even at the point where they want to abstract over evaluation strategies
00:41:38 <dons> bah, F#'s not pure. where'd this meme come from? /me smacks heads.
00:42:00 <dons> SPJ's smacks heads instead
00:42:02 <sizur> but f# is functional ;)
00:42:27 <sizur> you can have purity, it's not forced though
00:42:27 <opqdonut> is F# lazy?
00:42:41 <sizur> opqdonut: you have a construct to make something lazy
00:42:48 <vladimir_trs> I sometimes intimidate my co-workers, who are hardcore adherents of mainstream languages (Java/C++) saying: "You know, there is such a programming concept called "lazyness"....
00:42:51 <opqdonut> oh okay
00:43:01 <dons> vladimir_trs: :)
00:43:08 <kmcallister> in any language with closures you can emulate laziness
00:43:21 <sizur> yeah
00:43:25 <opqdonut> of course
00:43:26 <kmcallister> with some syntactic overhead
00:43:45 <dons> vladimir_trs: represent! get out there and funk them up :)
00:43:46 <opqdonut> sicp has a scheme implementation
00:43:47 <vladimir_trs> You could co that in assembler and binary code.... (not that I know much about the subject, however)
00:43:49 <sjanssen> kmcallister: you can emulate non-strictness, but I'm not so sure about laziness
00:44:13 <sjanssen> kmcallister: laziness has a fairly specific sharing requirement
00:44:29 <sizur> sjanssen: good distinction
00:44:37 <opqdonut> so laziness == graph reduction?
00:44:37 <dons> yay, monads 36 mins in.
00:45:05 <sizur> opqdonut: no, just there is no copying of values going on
00:45:24 <opqdonut> okay
00:45:32 <sizur> i guess a part of that overlaps with graph reduction
00:45:36 <opqdonut> so laziness implies reftransp?
00:46:12 <dons> it encourages it
00:46:20 <dons> since lazy effects are unpredictable effects
00:46:28 <vladimir_trs> And our boss here likes to start every phrase with "Maybe ...." Like "Maybe it's ok." "Maybe we have to do that." etc. So I also said that "There's a language called "Haskell" which is like our boss: it has "Maybe" data type! Like a variable, which is maybe 2 but maybe not..."
00:46:39 <dons> :)
00:47:00 <sizur> Maybe we should write some code today.
00:47:24 <sizur> Maybe the company can start making money. (haha, sorry...)
00:47:27 <vegai> dons: are you gonna port your blog to Haskell soon? :-P
00:47:46 <dons> i'd have to get some spare time :)
00:48:37 --- mode: ChanServ set +o dons
00:48:57 <vladimir_trs> Is there any (good) web forum about Haskell?
00:49:38 <sjanssen> vladimir_trs: I don't know any forums.  I suppose you've heard about the haskell-cafe mailing list?
00:49:41 <vegai> dons: is that your way of saying I shouldn't mention this subject again? :P
00:50:00 <sizur> poor Theron... said she visited Budapest in Turkey
00:50:03 --- topic: set to '["Haskell on the Radio: http://tinyurl.com/3ap2hq", "GHC 6.8 is made of win and awesome", "The Haskell programming language" ,"http://haskell.org " ,"http://www.jobs-in-fp.org/" ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
00:50:18 --- mode: ChanServ set -o dons
00:50:26 <dons> oh, STM 42 mins in.
00:50:45 <vladimir_trs> sjanssen: somehow I feel that mailing lists suck....
00:51:13 <sizur> there are more ppl thinking the same about irc
00:51:18 <vladimir_trs> Not that they are useless... but not too convenient to use.
00:51:26 <dons> but they want to know if there's been any "new developments in STM" -- aka does it magically work in impure languages now :)
00:51:32 <sjanssen> vladimir_trs: don't like the interface?  You can also browse it via gmane or there's a forum-like frontend (nabble IIRC)
00:52:04 <sizur> you can rss feed from mailing lists
00:52:07 <vladimir_trs> This is the first time I use IRC.... :)
00:52:09 <sizur> very nice
00:53:14 <dons> welcome, vladimir_trs !
00:53:49 <sizur> @vixen say hi to vladimir_trs.
00:53:49 <lambdabot> hello there
00:57:15 <Twey> What is @vixen?
00:57:41 <sizur> @vixen how are you doing today?
00:57:41 <lambdabot> very well, you?
00:58:01 <vladimir_trs> @vixen who are you, anyway?
00:58:01 <lambdabot> what do you mean, i'm me!
00:58:12 <vladimir_trs> Cute!
00:58:15 <sizur> it's alpha version of terminator
00:58:19 <Tac-Tic1> ah, a shitty PHP comment system
00:58:23 <Twey> Haha
00:58:34 <Twey> @vien What colour is the sky?
00:58:34 <lambdabot> isn't it obvious?
00:58:38 <Twey> Heh
00:58:57 <Tac-Tic1> http://www.tac-tics.net/
00:58:58 <vladimir_trs> @vixen how much is 2 + 3?
00:58:58 <lambdabot> how? it depends...
00:58:58 <opqdonut> @vixen how about a little turing test, just you and me?
00:58:59 <lambdabot> what about me?
00:59:01 <lambdabot> Title: Tac-Tics.net
00:59:02 <Twey> lambdabot is awesome :-D
00:59:18 <Tac-Tic1> With that hack of an addition to my shitty new site, I can rest =-)
00:59:35 <Twey> Heh
01:00:34 <Twey> Tac-Tic1: http://validator.w3.org/check?uri=http%3a%2f%2fwww.tac-tics.net%2f -- tut tut
01:00:36 <lambdabot> Title: [Invalid] Markup Validation of http://www.tac-tics.net/ - W3C Markup Validator, http://tinyurl.com/2xh2n7
01:01:03 <Tac-Tic1> I feel dirty using short tags, k?
01:01:09 <Twey> Heh
01:01:21 <Twey> Switch to XHTML then, who cares about IE anyway :-P
01:01:23 <glguy> dons: the guys in this broadcast are winners
01:01:24 <Tac-Tic1> besides, if code actually validated, it would never come close to working on ie
01:01:24 <Tac-Tic1> hehe
01:01:25 <Tac-Tic1> yeah
01:01:30 <dons> glguy: they sure are :)
01:01:32 <Tac-Tic1> I haven't actually tested it on IE
01:01:38 <dons> glguy: you can tell. they have an audio blog!
01:01:38 <Tac-Tic1> so I hope it doesn't suck too bad
01:01:52 <Twey> "Such a simple site design, how bad can it be?"
01:01:59 <Twey> (sorry, it's become a tradition)
01:02:01 <Tac-Tic1> What self-respecting Haskell user would use Microsoft software anyway?
01:02:02 <Tac-Tic1> X-D
01:02:14 <Twey> Indeed
01:02:21 <Tac-Tic1> It's simple, because I can't design worth a penny :-(
01:02:32 <vladimir_trs> Linux bigotry again? :)
01:02:33 <Twey> Nah, minimalistic's good
01:02:34 <Tac-Tic1> I'd spice it up if I had any skillz
01:02:50 <Twey> vladimir_trs, yeah, but even for Microsoft software IE takes the biscuit
01:02:56 <Tac-Tic1> I'mtotally going to web2 point oooooh that shit when I have t3h time
01:03:39 <Twey> It actually doesn't break too horribly
01:03:50 <Tac-Tic1> I did a lot of work with Javascript for the first time last week and found out that IE5 had memory leak issues with closures.... someone didn't read their SICP!
01:03:55 <Twey> The hover effect on the top link is a bit borked
01:04:10 <Tac-Tic1> I could probably remove that
01:04:13 <Twey> Nah
01:04:15 <Twey> It's only IE
01:04:16 <Tac-Tic1> (my nav is a bit.... umm yeah)
01:04:20 <dons> if we're going to take over the world. we'll need a .NET bridge.
01:04:27 <vladimir_trs> Here is a place called "LinuxCafe" in the city I'm living in... the last time I was there, it was decorated with Windows Vista advertisements from the roof to the floor....
01:04:34 <dons> vladimir_trs: :(
01:04:39 <Twey> And nobody cares about IE5 (seriously this time)
01:04:47 <Tac-Tic1> yeah, I know
01:04:57 <Twey> I'd support it if it weren't so utterly broken, but...
01:04:59 <Tac-Tic1> but still, closures aren't that hard to do, are they?
01:05:08 <Cale> dons: Why do I find this radio show's description of type inference so humourous?
01:05:09 <Twey> Heh
01:05:24 <dons> Cale: oh no. :)
01:05:26 <Cale> :)
01:05:56 <dons> there's something in here about programmers who don't understand compilers from top to bottom, don't undestand programming
01:06:07 <Tac-Tic1> I wanted to get a site up and running for a long time, but I always spent too much time designing the backend and not enough time just doing a throw away job in PHP =-)
01:06:30 <vladimir_trs> Somebody mentioned haskell-cafe mailing list before, so I wonder if there is much discussions about Java there.... :)
01:06:32 <Tac-Tic1> but I'm happy with how this has turned out
01:06:44 <dons> glguy: spj talks about tailcalls 56 mins in :)
01:06:46 <ivanm> dons: where's this? I don't understand compilers but I like to think I can program at least competently...
01:07:08 <glguy> dons: does it have a *whoosh* associated?
01:07:34 <dons> ivanm: its hard to reason about a whole range of problems unless you can envisage the compilation process from src to asm, and into the runtime. it just comes up again and again and again.
01:08:01 <dons> like using a tool but with only vague knowledge of the effects.
01:08:18 <dons> i encourage everyone to run -ddump-simpl -ddump-cmm for a few days until they dream in core.
01:08:22 <ivanm> hmmmm.... not sure if I fully agree with you there...
01:08:23 <siti> the guys on the podcast are such dotnet fan boys, but spj corrects them ;)
01:08:27 * Tac-Tic1 needs to sit down and actually write a compiler some day....
01:08:34 <ivanm> in terms of optimizing, yes I suppose
01:08:36 <Tac-Tic1> a shitty lisp compiler or something
01:08:55 <dons> ivanm: its a common view. programming is knowing how programs work. which means knowing how compilers work.
01:08:56 <ivanm> Tac-Tic1: I wrote a shitty haskell interpreter in scheme, is that close enough?
01:09:06 <dons> steve yegge wrote a great post about this
01:09:08 <Twey> Haha
01:09:19 * Tac-Tic1 thinks about how compilers work similarly to PHP which writes javascript which writes HTML.... then he feels pain in his heart for comparing the two at all
01:09:20 <ivanm> dons: hmmm... people can use maths without knowing all about abstract algebra, etc.
01:09:24 <dons> hehe, "Is C-- a version of C++? "
01:09:26 <Tac-Tic1> ivanm: That's cool enough
01:09:26 <Cale> dons: I feel kind of bad to say it, but there's something very childish-seeming to me now about programmers who don't really understand how a compiler works. Possibly because they remind me of myself as a child before learning this, and there's some cognitive dissonance there because they're not children anymore.
01:09:45 <ivanm> which steve yegge post (even which blog!) is this?
01:09:58 <EvilRanter> Tac-Tic1, well, that's merely palming the work off onto the browser
01:09:58 <Twey> Cale, I'm sure they all know vaguely how one works, if not in detail.
01:10:09 <dons> http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html
01:10:10 <lambdabot> Title: Stevey's Blog Rants: Rich Programmer Food
01:10:22 <dons> "f you don't know how compilers work, then you don't know how computers work. If you're not 100% sure whether you know how compilers work, then you don't know how they work.
01:10:25 <dons> You have to know you know, you know."
01:10:33 <sizur> are we into "bash the imperative code" today?
01:10:34 <glguy> dons: How old are these guys to be talking about "the old days"
01:10:35 <vladimir_trs> Reading Steve Yegge is exhausting....
01:10:38 <Tac-Tic1> EvilRanter: Yeah, but it's still writing code in code.
01:10:39 <dons> glguy: 2000.
01:10:40 <sizur> coder*
01:10:44 <dons> that's the old days.
01:10:53 <glguy> awesome
01:10:58 <dons> glguy: you head the bit at the start where they asked if haskell compilers existed when .NET 1.0 came out?
01:11:04 <Tac-Tic1> Yegge is awesome and his long posts somehow manage to keep my extremely short attention span
01:11:18 <Cale> If you're a programmer, and you've never written a compiler -- at least a small one -- do it!
01:11:41 <dons> yeah, the most important things you can do are write an interpreter and write a compiler.
01:11:42 <Twey> Cale: Got any good resources?
01:11:44 <quicksilver> I can't quite agree with the extreme of that argument.
01:11:52 <vladimir_trs> Will an interpreter do?
01:11:52 <quicksilver> I don't know how gcc's register allocator works.
01:12:00 <dons> then pretty much all interesting stuff in programming becomes a lot clearer
01:12:01 <Tac-Tic1> What's a good, simple target platform for a first-time compiler?
01:12:11 <quicksilver> Tac-Tic1: a simple VM :)
01:12:20 <glguy> dons: I'm listening, but also playing Call Of Duty 2
01:12:22 <Twey> Heh
01:12:26 <Cale> quicksilver: I don't know how GCC's register allocator works, but I know how a register allocator works in general, and I've written one :)
01:12:27 <glguy> dons: so I don't *think* they said that yet
01:12:32 <Twey> Written using your compiler
01:12:34 <dons> glguy is good at multitasking
01:12:37 <dons> and on irc.
01:12:37 <Tac-Tic1> quicksilver: I've thought about writing my own VM too... but I never know how complicated a VM needs to be
01:12:47 <quicksilver> Cale: right, but I don't accept that you have to write a register allocator to know how computers work :)
01:12:48 <glguy> dons: I need my 18 hours of irc a day
01:12:56 <quicksilver> Tac-Tic1: simpler than you probably think.
01:12:57 <glguy> dons: but I can't get it all serially
01:13:05 <Tac-Tic1> I thought about writing a compiler to a language called the Unlmited Register Machine described in a theory of computation book I have
01:13:07 <quicksilver> Tac-Tic1: number 1 mistake in simple VMs is making them too complicated.
01:13:26 <Tac-Tic1> Or brainf#ck
01:13:29 <Tac-Tic1> Everyone loves that!
01:13:33 <Tac-Tic1> Best VM evar
01:13:42 <ivanm> there's a better lang, IIRC...
01:13:44 <Cale> quicksilver: possibly not. I still think that writing a compiler is one of the best exercises you can do in working toward that, and there are a lot of details which you don't really understand until you've tried it at least once.
01:13:59 <ivanm> can't remember the name for it, but there's only four commands and they don't do much
01:14:05 <ivanm> (i.e. it's not turing complete :p _
01:14:12 <vladimir_trs> I heard some guy boasting that he wrote his development tools... something like he wrote Fort in Assembler, then Lisp in Fort....
01:14:14 <Cale> quicksilver: Like, even if you write a crappy non-optimising compiler, you'll pick up lots of insight into what the issues involved are.
01:14:18 <sizur> Tac-Tic1: whitespace is cleaner language.
01:14:44 <dons> oh no, currying!
01:14:50 <therp> tac-tic1: a really cute lisp compiler is found in http://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521562473
01:14:50 <Tac-Tic1> I'm going to write an extended brainfuck VM, with internal registers for the current input and output files. And primitives for opening and closing files
01:14:52 <Twey> Tac-Tic1: Brainfuck's cheating, you can parse it straight into assembly :-P
01:14:57 <lambdabot> http://tinyurl.com/ypodc8
01:15:01 <dons> yay, schoenfinkel!
01:15:11 <ivanm> does doing the "write a scheme in 24hrs" count as writing a compiler/interpreter?
01:15:16 <Tac-Tic1> isn't that what a VM is? An assembly code?
01:15:32 <Cale> Twey: Well, I'm not entirely sure about a good central resource, because I didn't actually have a text for the course in which I wrote a compiler -- just lectures and course notes.
01:15:49 <quicksilver> Cale: Yes, I agree.
01:15:50 <dons> ivanm, its an interpreter. but working through say, a compiler for MiniML (to bytecode) would be good. maybe SPJs book on compiling haskell even.
01:15:59 <quicksilver> Cale: I just thought the original quote was a little too far.
01:16:02 <C-Keen> :t $
01:16:05 <lambdabot> parse error on input `$'
01:16:15 <Tac-Tic1> therp: I own that book. I don't have the patience yet to sit down and decipher it (it's translation makes for not the most interesting read, sadly, but otherwise is a cool book)
01:16:19 <Cale> quicksilver: Yegge's?
01:16:25 <quicksilver> Cale: yes.
01:16:32 <Cale> quicksilver: Yes, I can agree with that.
01:16:44 <vladimir_trs> How about writing an OS?
01:16:45 <dons> quicksilver: its the internets, gotta be bold :)
01:16:47 <C-Keen> what is the definition of the $ operator and how could I find out myself :)
01:16:49 <Cale> With the qualification that he's not that far off :)
01:17:10 <Cale> @src ($)
01:17:10 <lambdabot> f $ x = f x
01:17:14 <ivanm> but how "deep down" does a compiler/interpreter have to be for you all to consider it to be a "proper" one (i.e. one that you learnt sufficient compiler-y stuff from to be a better programmer)?
01:17:25 <Cale> C-Keen: It's just function application, but it has really low precedence.
01:17:30 <therp> tac-tic1: I found the English translation quite ok.. and hmm -- I can't remember a chapter that was not pure fun to read.. hmm - maybe the chapter about macros, here the taxonomy is unclear to me..
01:17:33 <Twey> Cale: Domn :-\
01:17:34 <ivanm> is a parser + language translator sufficient?
01:17:45 <Cale> C-Keen: which means that it's like whatever's on the left and right of it are wrapped in parens
01:17:50 <Twey> Damn**
01:17:51 <dons> ivanm: the more the better.
01:17:58 <Tac-Tic1> therp: maybe it's just lisp itself then that I have yet to come to grips with =-)
01:18:02 <EvilRanter> C-Keen, you could find out yourself by looking in the prelude documentation
01:18:10 <EvilRanter> @where prelude
01:18:10 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
01:18:14 <Twey> Cale: a $ b = (a b)?
01:18:19 <quicksilver> ivanm: the key lessons are moving from an evaluator (which is just traversing an AST) to something which actually changes the form of the code.
01:18:19 <Cale> C-Keen: a common tactic is to compose a chain of functions on the left with (.), and apply it to something with ($) after.
01:18:20 <Tac-Tic1> I read it about 7 months ago before I really started to understand the whole functional way of life
01:18:23 <Cale> Twey: yep
01:18:28 <ivanm> quicksilver: *nod*
01:18:29 <EvilRanter> er
01:18:32 <EvilRanter> @docs prelude
01:18:33 <lambdabot> prelude not available
01:18:33 <quicksilver> ivanm: such as moving from infinite named variables to finite registers.
01:18:37 <EvilRanter> @docs Prelude
01:18:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
01:18:39 <therp> tac-tic1: ok, that can be tricky :)
01:18:40 <Twey> Int'restin'
01:18:44 <Cale> Twey: well, it's like  ... $ ... = (...) $ (...)
01:18:54 <quicksilver> = (...) (...)
01:19:02 <ivanm> quicksilver: hmmm.... I would probably have no idea where to even start on something like that :s
01:19:04 <Twey> Hm, OK
01:19:07 <Cale> Where each of the ...'s is some longish expression
01:19:13 <dons> "'SLPJ' is the Michael Palin of the functional programming world."
01:19:25 <Tac-Tic1> therp: The one chapter that blew away my mind was the one that showed how continuations work so beautifully together with storage, and the denotational semantics of scheme.... even though I can't stand the notation for the life of me
01:19:28 <Cale> A good example of idiomatic use would be something like this:
01:19:32 <ivanm> dons: what's the L stand for?
01:19:40 <Cale> > map head . group . sort $ "mississippi"
01:19:42 <lambdabot>  "imps"
01:20:17 <Cale> You're building up a chain of composed functions on the left, and then you apply the resulting function to whatever's on the right of the ($)
01:20:22 <quicksilver> Lambda!
01:20:46 <dons> heh
01:20:50 <opqdonut> :D
01:20:54 <opqdonut> that's be cool
01:20:57 <Eelis> and then there are those of us that prefer    map head $ group $ sort $ "mississippi"
01:21:14 <Tac-Tic1> so, for you who suggest writing a compiler, what would you suggest for a source, defined, and target language to begin with?
01:21:22 <Tac-Tic1> Something challenging, but straightforward?
01:21:29 <C-Keen> Thanks Cale
01:21:33 <dons> i think a MiniML to C-- would be pretty good
01:21:35 <therp> tac-tic1: that one takes a while, true. but when I learned how to read the notation it was quite rewarding in terms of "expanding my mental capabilities" to read lambda expressions :)
01:21:40 <dons> (or MiniHaskell)
01:21:41 <Cale> However, I specifically discourage repeating $ in a chain like that.
01:21:43 <sizur> compile English to Japanese
01:21:47 <Eelis> Cale: why?
01:21:52 <dons> yeah, its bad form.
01:21:54 <dons> use (.)
01:22:02 <dons> map head . group . sort $ "foo"
01:22:08 <dons> less pixel noise
01:22:16 <Cale> This is because first of all, you can always replace the first n-1 of the ($)'s with (.), and second, this makes your code easier to refactor.
01:22:18 <Tac-Tics> > eval "Thank you"
01:22:18 <Tac-Tics> ã©ãããããã¨ã
01:22:19 <lambdabot>   Not in scope: `eval'
01:22:32 <Cale> Note that group . sort is a valid function
01:22:32 <Tac-Tics> C-- looked interesting
01:22:38 <Tac-Tics> I need to research it a bit
01:22:38 <Cale> But group $ sort is not.
01:22:48 <opqdonut> (.) is associative, ($) is not
01:22:48 <dons> Tac-Tics: translating to haskell is also a good start.
01:22:51 <vladimir_trs> ã°ãããï¼
01:22:51 <opqdonut> i guess that's the gist
01:23:00 <Eelis> i can't say any of these "arguments" sound anywhere near convincing
01:23:10 <Tac-Tics> _to_ haskell? from an imperative language? or a functional one?
01:23:23 <dons> well, there's more than one way to do it, but those ways are wrong
01:23:27 <Cale> Eelis: another one is that some of us hope to flip the associativity of ($) at some point, which will cause your code to break
01:23:28 <Tac-Tics> ãã£ãããã¡ã
01:23:41 <Cale> Eelis: However, it'll open up lots of new ways to remove parens from code.
01:23:42 <dons> Cale hopes that.
01:23:51 <Cale> I really do :)
01:23:52 <Eelis> Cale: i already use $ to remove lots of parens from code
01:24:03 <Tac-Tics> $ is Haskell's gift to the world
01:24:04 <dons> the same day that monad comprehensions and the numeric prelude are comitted
01:24:08 <vladimir_trs> Should use in Lisp, then...
01:24:10 <Cale> Eelis: try removing the parens from  f (g x) (h y) (k z)
01:24:13 <opqdonut> i'm doing a compiler course right now actually. our project is to expand a simple compiler (the one that comes with the new dragon book) and i'm thinking of adding Hindley-Milner :)
01:24:20 <osfameron> Tac-Tics: heh
01:24:44 <Cale> Eelis: if ($) had the opposite associativity, this would be  f $ g x $ h y $ k z
01:24:45 <Eelis> Cale: what would that look like with the new and improved associativity-flipped $ ?
01:24:45 <sizur> the main reason for me to be pointeless, is composability. you treat the composed function as a computation unit which you can then compose firther
01:24:54 <Eelis> Cale: interesting.
01:24:56 * osfameron doesn't really think $ based code is easier to read than parens though
01:25:32 <Tac-Tics> http://www.google.com/codesearch?hl=en&lr=&q=%22%29%29%29%29%29%29%29%22&btnG=Search
01:25:33 <lambdabot> Title: ")))))))" - Google Code Search, http://tinyurl.com/3349vy
01:25:36 <Cale> and there's essentially no additional benefit to having it the way we presently do, because you can essentially always replace most of your ($)'s with (.)'s without affecting the meaning
01:25:38 <Tac-Tics> :-)
01:25:44 <Cale> (with the way things currently are)
01:26:18 <siti> $ is easier to type than two brackets :)
01:26:25 <siti> I don't care about people reading the code ;)
01:26:25 <ivanm> dons: with that steve yegge blog though, do you agree with his dismissal of typing theorists?
01:26:33 <Cale> and it's easier to keep track of where it ends.
01:26:46 <sizur> siti: wow
01:27:00 <Cale> siti: one day, you might be one of them
01:27:02 <Tac-Tics> I wonder what the limit of the ratio of Complexity of a Lisp Program to Number of Consecutive close Parens in that program is
01:27:22 <opqdonut> :D
01:27:52 <Cale> It's funny how as you add close parens to that google code search, the languages used in the results drift farther and farther toward scheme and lisp :)
01:27:59 <sizur> Tac-Tics: that's quite superficial
01:28:09 <Cale> There's a few java hangers on there, and then it's just all scheme and elisp.
01:28:15 <Tac-Tics> sizur: what is?
01:28:35 <Cale> Oh, and a .cc :)
01:28:49 <Cale> (C++ of course)
01:28:59 <sizur> Tac-Tics: judging lisp by it's nail clipping
01:29:19 <FalconNL> Could someone point me to a better way of instancing Show? Surely there has to be an easier way than http://hpaste.org/5193
01:29:41 <Cale> The C++ code is cheating though, all the close parens are in a string constant.
01:30:01 <doserj> is the C++ code generating Lisp?
01:30:11 <Cale> FalconNL: well, you can write "deriving Show
01:30:13 <Tac-Tics> sizur: I love lisp as much as the next FPer. It's absolutely beautiful... when you're not reading it or trying to find the misplaced paren
01:30:21 <quicksilver> FalconNL: don't do that :)
01:30:25 <Cale> FalconNL: on the end of your data decl.
01:30:29 <quicksilver> FalconNL: that's not what Show is for.
01:30:46 <Cale> quicksilver: hm?
01:30:58 <Tac-Tics> I spent about half an hour yesterday trying to figure out where the last paren was to this one really big function was using 2 call/ccs
01:31:01 <quicksilver> Show is supposed to generate haskell syntax.
01:31:15 <Cale> I suppose that it usually does generate Haskell syntax.
01:31:20 <FalconNL> quicksilver: ok, what would be the right way of achieving roughly the same idea?
01:31:26 <quicksilver> well deriving Show
01:31:27 <EvilRanter> (strange requirement tho that may be)
01:31:32 <quicksilver> would be one answer
01:31:40 <osfameron> Tac-Tics: isn't that what indentation and paren-match-bouncing are for?
01:31:42 <quicksilver> EvilRanter: handy for debugging + test case generation, I find.
01:31:47 <Tac-Tics> Lisp is perfect and divine, but like the bible, it's best left to the experts well versed in the obscure but meaningful
01:32:07 <quicksilver> Tac-Tics: http://xkcd.com/224/
01:32:07 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:32:18 <Cale> Tac-Tics: The bible is meaningful? :)
01:32:24 <Tac-Tics> osfameron: Lisp is defined by R5S5 and the CL Report, not emacs ;-)
01:32:38 <Tac-Tics> that's my favorite strip of that comic!
01:32:41 <EvilRanter> osfameron, indentation?! that gets completely cancelled out by all the lisp programmers insisting on putting their close-parentheses on the line bwfore
01:32:47 <Tac-Tics> Cale: in relative contexts yes
01:32:59 <Cale> Tac-Tics: hehe
01:33:03 <Tac-Tics> Lisp is pretty meaningless even to most veteran programmers
01:33:06 <osfameron> Tac-Tics: well, any sensible editor :-)  (I'd use vim)
01:33:29 <Tac-Tics> eep!
01:33:53 <Cale> nice split
01:34:17 <EvilRanter> sure, if the done thing was to put a newline before a close-paren and line it up vertically with the matching open-paren, indentation would help
01:34:17 <quicksilver> nah, that was a baby by freenode standards.
01:34:41 <Cale> quicksilver: I suppose I've seen worse here :)
01:34:55 <hpaste>  sizur annotated "Surely there has to be a better way?" with "no likee?" at http://hpaste.org/5193#a1
01:35:29 <Tac-Tics> deriving is <3
01:35:44 <quicksilver> deriving is an abstraction leak!
01:35:52 <quicksilver> (just to apparently contradict my earlier stance)
01:36:00 <FalconNL> ok, I suppose I can do without the shorter names. Thanks everyone.
01:36:04 <Tac-Tics> I'll abstract your face if you don't uncontradict yourself!
01:36:12 <vladimir_trs> Steve Yegge has an interesting post about how Haskell has no future because of it's absence of "self-modification" or something...
01:36:13 <quicksilver> people are insufficiently scared of metaprogramming.
01:36:26 <hpaste>  Cale annotated "Surely there has to be a better way?" with "a more literal approach to cleaning this up" at http://hpaste.org/5193#a2
01:36:28 <EvilRanter> and bouncing on the % key (or your editor's equivalent) is far more tedious than being able to tell at-a-glance which parens go with which
01:36:31 <quicksilver> deriving breaks alpha-renaming.
01:36:35 <ivanm> vladimir_trs: which one is this one?
01:36:55 <Cale> FalconNL: you could try my code if you want to keep the shortforms
01:37:03 <Tac-Tics> hey, it does break alpha renaming!
01:37:42 <Cale> quicksilver: uhh...
01:37:43 <FalconNL> Cale: yeah, but it's pretty much as long as the original, which was my main problem with the code
01:38:18 <Cale> FalconNL: I suppose you could define a function  word  which pattern matched out the word
01:38:23 <vladimir_trs> ivanm: don't remember, read it quite ago.... he wrote something about how programs shall evolve on their own modifying themselves, and it will be unethical to turn off a computer, since it would be like a murder, and Haskell has no destructive update -> no state modification....
01:38:35 <ivanm> ummm..... right
01:38:47 <quicksilver> vladimir_trs: just sounds like stupidity to me.
01:38:53 <Cale> FalconNL: Or define the type as a record type where each constructor has a field word (which will define the extractor for you)
01:38:56 <FalconNL> was thinking more along the lines of something like [(Noun, "N"), (Verb, "V"), etc], but deriving Show will do
01:39:00 <quicksilver> vladimir_trs: or failure to understand, at least.
01:39:04 <ivanm> quicksilver: yegge likes dynamic typing, go figure :p
01:39:29 <quicksilver> ivanm: I can totally understand someone liking dynamic languages. It's just a shame they have to misunderstand static languages :)
01:39:30 <sizur> unethical to turn of my computer? is he on drugs?
01:39:38 <Tac-Tics> Dynamic typing is good for getting shit done fast and sometimes even working
01:39:53 <Twey> vladimir_trs, they can still modify themselves if so designed by passing different parameters around.
01:40:01 <Cale> FalconNL: however, that still won't save you from pattern matching, really
01:40:02 <vladimir_trs> Well, but Haskell is listed among his "favorite languages"....
01:40:05 <ivanm> quicksilver: heh, true... though the python vs haskell page on the python wiki says something like "haskell's typing is static typing done right"
01:40:20 <ivanm> vladimir_trs: so he's not going _straight_ to hell then... :p
01:40:24 <Tac-Tics> I've worked so long in dynamic programming languages before I started Haskell..... but it's really a weird feeling to have to compile your code again after so long
01:40:46 <sizur> Tac-Tics: you dont need any programming to get that done. just visit the bathroom
01:40:51 <vladimir_trs> ivanm: maybe it wasn't him, actually.... :)
01:41:11 <sjanssen> anybody notice how the dotnetrocks guy calls prolog an object oriented language not once, but twice?
01:41:13 <quicksilver> FalconNL: occasionally I wish that, for each data type, I had a related type with only the constructors.
01:41:18 <Cale> I really hate dynamic vs. static typing arguments where people use something like Java or C++ as the example for static typing.
01:41:27 <quicksilver> FalconNL: what would kind-of help with what you're doing.
01:41:33 <vincenz> Cale: we should use assembly as the example of dynamic typing :)
01:41:33 <vladimir_trs> I heard there will be optional type annotation in some future Python...
01:41:41 <Tac-Tics> sizur: Yeah, but sometimes it tells you you're wrong and explains why you're wrong, when it'd be faster to just try it and see why it fails instead
01:42:06 <Tac-Tics> vladimir: it's in Python3k's new alpha release, but for now, it's just annotation and reserved for future implementation
01:42:27 <sizur> i'm all for hybrid type system
01:42:31 <Tac-Tics> same here
01:42:52 <vladimir_trs> There is a static typing in PyRex... ;)
01:43:02 <siti> sjanssen: I noticed that too
01:43:23 <monstre> hello
01:43:40 <sizur> monstre: hi
01:43:41 <Cale> Tac-Tics: the indentation of the first do-block on your blog needs a minor touch-up :)
01:44:01 <Tac-Tics> In a hybrid typed system, you can write you code in dynamic, flowing, flurry of sex, and then when things cool off, you settle down, get married, and your wife annotates you with concrete types!
01:44:10 <monstre> Newbie question: is (++[]) linear or constant time?
01:44:33 <sjanssen> @src (++)
01:44:33 <lambdabot> (++) []     ys = ys
01:44:33 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
01:44:38 <Tac-Tics> Cale: ah thanks. I think it just got desynced from the source (at the bottom of the page)
01:44:39 <sjanssen> monstre: linear
01:44:41 <EvilRanter> so... linear
01:44:42 <sizur> Tac-Tics: that's not what hybrid type system is. it's when you have full typing, but some checks are done runtime
01:44:47 <EvilRanter> even if it is the identity ;)
01:44:49 <quicksilver> monstre: if you consume the whole list, it's linear.
01:44:50 <vladimir_trs> I've found that Yegge's post: http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html
01:44:51 <lambdabot> Title: Stevey's Blog Rants: The Pinocchio Problem
01:44:57 <monstre> alright, thank you
01:45:06 <monstre> shouldn't it be constant though?
01:45:13 <EvilRanter> no
01:45:16 <EvilRanter> why?
01:45:28 <monstre> I mean, it could be
01:45:34 <monstre> so why not?
01:45:34 <sizur> optional type annotation will not be used by people. you either use one, or the other.
01:45:34 <sjanssen> monstre: sure
01:45:44 <Tac-Tics> sizur: that's essentially what I meant. Maybe I got caught up in the analogy
01:45:51 <sjanssen> (modulo minor strictness differences)
01:45:56 <vladimir_trs> "It's true that with some effort you can build beautiful, lithe marionettes with Haskell. But they will forever remain little wooden Pinocchio, never to be granted their wish for boyhood by the Good Fairy. Haskell has little or no notion of dynamic code loading or runtime reflection; it's such an alien concept to them that it's difficult even to discuss why they might be useful with a Haskell fan: their world-view ju
01:46:12 <EvilRanter> monstre, sure, the compiler could implement a special-case for it, but that'd be one out of an infinity of special-cases it could implement
01:46:44 <EvilRanter> and that particular one's trivial to resolve by changing your sourcecode slightly
01:46:46 <sjanssen> EvilRanter: technically, it can't because the behavior of xs ++ undefined would change
01:46:56 <Tac-Tics> Thanks a lot Cale: fixed
01:47:10 <sizur> with hybrid type system you can easelt define types that will look like Eiffel tower in static types
01:47:18 <EvilRanter> sjanssen, i mean identifying situations where the right parameter to (++) must be a zero-length list
01:47:19 <Cale> Tac-Tics: :)
01:47:37 <sjanssen> EvilRanter: oh yeah, a rewrite rule could work
01:47:48 <Cale> vladimir_trs: Someone should show whoever wrote that hs-plugins.
01:47:49 * sjanssen doesn't trust those too much :)
01:48:00 <Twey> Hahahaha, he rates Javascript < Windows XP
01:48:04 <Twey> *closes tab*
01:48:24 <Tac-Tics> I was trying to think of something interesting to blog about (since I have never really blogged before), and I remember a few months ago when I realized the isomorphism between List and SQL. I thought it would be a cool, nonthreatening read for PHP and Javateers
01:48:25 <sjanssen> > compare 'a' ()
01:48:26 <lambdabot>  Couldn't match expected type `Char' against inferred type `()'
01:48:53 <EvilRanter> sjanssen, exactly; perhaps it'd also be possible to adapt ndm's Catch to detect such inefficient identities, too
01:48:56 <sjanssen> Twey: Couldn't match expected type `ProgrammingLanguage' against inferred type `OperatingSystem'
01:49:07 <Tac-Tics> I think if Haskell had syntax sugar for Dynamic types, it would be pretty close to a hybrid system
01:49:10 <Twey> sjanssen: *fwap*
01:49:12 <Twey> :-P
01:49:12 <quicksilver> I think rewrite rules solve the wrong problem.
01:49:20 <Cale> Tac-Tics: Yeah, that similarity's been played up by the .NET/LINQ people a whole lot, but we haven't really pointed it out about Haskell a whole lot.
01:49:30 <quicksilver> rewrite rules change things which are statically true
01:49:40 <quicksilver> if it's statically true, you wouldn't write it like that
01:49:48 <quicksilver> no one would actually write "++[]" in a real program.
01:49:55 <Tac-Tics> I just read about LINQ the other day for the first time. But it's not monadic, is it? What have they to brag about! Bwahaha
01:49:59 <quicksilver> the time you *want* to optimise it is when you have
01:50:07 <quicksilver> ++a and 'a' might be empty, and it might not.
01:50:10 <sizur> linq is a monad
01:50:14 <osfameron> Tac-Tics: I've read stuff about LINQ being monadic.
01:50:21 <Tac-Tics> is it?
01:50:22 <sjanssen> quicksilver: that is a very good point
01:50:29 <osfameron> and even if it wasn't who cares, as it appears to be way cool
01:50:36 * Tac-Tics has been away from visual studio for a long time
01:50:40 <quicksilver> sjanssen: this worries me about rewrite rules and fusion.
01:50:44 <sizur> yes, it is a monad with bind and unit
01:50:48 <Cale> quicksilver: What about rules like  map f . map g = map (f . g) ?
01:50:48 * Tac-Tics should probably liftIO his copy of VC++ from work
01:50:51 <quicksilver> sjanssen: they are too static, and there for not composable.
01:50:59 <quicksilver> Cale: what about map f . h . map g
01:51:09 <quicksilver> Cale: can you fuse that if, at runtime, h turns out to be fusible?
01:51:22 <EvilRanter> quicksilver, as i said, a strategy similar to what Catch uses to detect calls to fail could perhaps be used to detect things like static cases of ++[] that aren't immediately obvious
01:51:24 <quicksilver> s/composable/compositional/
01:51:30 <Cale> Well, if you have the right system of rules set up :)
01:51:34 <resiak> Suppose I have data Foo = A ...| B ... | C ...; xs :: [Foo].  Is there a shorter way to write the predicate (\x -> case x of A _ -> True; _ -> False) ?
01:51:35 <quicksilver> EvilRanter: Definitely. I don't know how important that is :)
01:51:48 <EvilRanter> yeah. i imagine those would be pretty rare.
01:51:53 <Cale> er...
01:51:59 <quicksilver> resiak: No.
01:52:25 <quicksilver> resiak: that's another example of why I sometimes want another data type which is only the constructors.
01:52:35 <EvilRanter> resiak, i think Data.Typeable may be able to help you there
01:52:36 <Cale> quicksilver: Okay, I see what you want.
01:52:41 <EvilRanter> (altho it might be Data.Generics)
01:52:48 <resiak> EvilRanter: eh, overkill
01:52:57 <Cale> quicksilver: (the remark that h is something which is plugged in only at runtime is important)
01:52:58 <resiak> quicksilver: fair enough
01:53:04 <sjanssen> quicksilver: is it possible to write a dynamic rules system?
01:53:17 <quicksilver> sjanssen: I don't know.
01:53:41 <sjanssen> quicksilver: all the names you'd like to match will be destroyed by compilation
01:53:42 <quicksilver> sjanssen: I don't know what the solution is. I just raise it as something which makes me uneasy about the emphasis on rules and fusion :)
01:53:51 <Cale> It is, if you're willing to lose most of everything we know about compilation of lazy programs already and go back to graph reduction.
01:54:31 <quicksilver> it becomes possible to write code with good performance (e.g. constant space) and destroy that by a factorisation which ought to be denotationally irrelevant
01:54:36 <Cale> HOPS is a system where you have such dynamically applied rules.
01:54:40 <quicksilver> like moving a single function to another module
01:54:48 <quicksilver> and thus breaking a critical inlining.
01:55:15 <sjanssen> quicksilver: the same thing happens even without rewrite rules
01:55:31 <Cale> quicksilver: So, if you'll work out a way to do arbitrary graph rewriting really efficiently, you'll have solved the problem :)
01:55:44 <quicksilver> well, any optimisation which relies on inlining and static analysis
01:56:00 <sjanssen> right
01:56:09 <quicksilver> sjanssen: but somehow rewrite rules make it "worse" in the sense that we are totally dependent on them to get good performance from some things.
01:56:16 <sjanssen> but really, which functional optimizations *don't* rely on inlining?
01:57:00 * Tac-Tics is time to > runSleep tactics (3 :: Hour)
01:57:31 <Cale> The problem we're trying to solve with rewrite rules is one which is basically arbitrarily hard.
01:57:32 <EvilRanter> can you get a list of all the rewrites ghc is doing to your code?
01:57:44 <Cale> EvilRanter: yep
01:57:56 <EvilRanter> damnit, i've been disconnected again, haven't i
01:57:59 <Cale> I forget the switch though
01:58:16 <Twey> @pl \x -> x + 1
01:58:16 <lambdabot> (1 +)
01:58:33 <quicksilver> Cale: that's true.
01:58:35 <Twey> @pl \x y -> x + y
01:58:35 <lambdabot> (+)
01:58:43 <quicksilver> Cale: and the solution we already have is very impressive.
01:58:44 * Twey shakes his head in amazement.
01:58:56 <quicksilver> Cale: I just wonder if it is compositional enough for large systems.
01:59:01 <sjanssen> Twey: it gets better
01:59:07 * Twey tosses lambdabot a treat for being a Clever Girl.
01:59:07 <EvilTerran> > uncurry (++) . (snd &&& fst) . splitAt 3 $ "ranter"
01:59:08 <lambdabot>  "terran"
01:59:08 <sjanssen> @pl \x -> not (not x)
01:59:08 <lambdabot> id
01:59:09 <Cale> quicksilver: Have you seen the stream fusion stuff?
01:59:11 <quicksilver> Cale: actually I think it is: it's just the system implementor has to be aware of these issues.
01:59:14 <monstre> Another newbie question: is the space complexity of something like 'iterate f x !! n' constant or is it linear in n?
01:59:16 <quicksilver> Cale: yes.
01:59:22 <quicksilver> monstre: linear.
01:59:24 <Cale> monstre: linear in n
01:59:28 <Twey> sjanssen: Haha, gosh.
01:59:34 <Cale> monstre: xs !! n in general is linear in n
01:59:37 <quicksilver> well
01:59:37 <sjanssen> monstre: depends
01:59:40 <quicksilver> for non-trivial 'f'
01:59:49 <quicksilver> I expect the time 'f' takes will outweight hte time !! takes
01:59:53 <EvilTerran> well, in theory, the initial elements could get GC'd after they've been traversed
01:59:56 <quicksilver> but the iteration of 'f' is still linear :)
02:00:06 <quicksilver> ok
02:00:09 <quicksilver> SPACE complexity
02:00:10 <EvilTerran> quicksilver, he said "space complexity"
02:00:10 <quicksilver> duh
02:00:13 <quicksilver> I'm blind.
02:00:14 <EvilTerran> :P
02:00:16 <monstre> yes, space
02:00:16 <quicksilver> monstre: constant.
02:00:18 <Cale> er, oh
02:00:26 <Cale> yeah, duh, I missed that too :)
02:00:43 <monstre> I'm trying to understand the whole laziness thing...
02:00:48 <sjanssen> monstre: it will probably be linear space due to excess thunking
02:00:52 <Cale> monstre: yep it's constant space, since the elements you're not using can immediately be GC'd
02:01:10 <Cale> Oh, I suppose there is that :)
02:01:14 <Cale> oy :)
02:01:31 <monstre> so can I rely on it being constant or is that that more of a maybe?
02:01:33 <EvilTerran> ah, yes. do we need iterate' as well as sum' and product'?
02:01:38 <quicksilver> Cale: we didn't do very well with that quesiton, did we ?
02:01:44 <sjanssen> monstre: maybe/leaning towards no
02:01:49 <Cale> quicksilver: this is true.
02:02:01 <quicksilver> EvilTerran: that wouldn't actually help, since !!n doesn't inspect the earlier elements.
02:02:12 <quicksilver> EvilTerran: so even if the later elements were 'seq'ed with the earlier.
02:02:18 <Cale> monstre: It can be made constant by forcing the evaluation of f as you go.
02:02:18 * sjanssen pulls out sequencify
02:02:26 <EvilTerran> hm.
02:02:26 <quicksilver> they don't get inspected so the thunk stuff still happens.
02:02:45 <sjanssen> sequencify = foldr (\x xs -> seq x (x:xs)) []
02:02:52 <monstre> I'm not sure I understand this thunking business of which you speak
02:02:57 <Twey> @pl \x -> \y -> y + x
02:02:58 <lambdabot> (+)
02:03:05 <EvilTerran> iterate' f x = x `seq` x : iterate' f (f x) -- is what i was thinking of
02:03:05 <Cale> monstre: The only place where you're leaking space here is that you're building up these expressions of the form f (f (f (f ... (f x) ...)))
02:03:18 <Twey> She's smarter than I am.  :-(
02:03:25 <Cale> monstre: and that takes linear space in n to represent
02:03:38 <EvilTerran> which i'd expect would mean that x gets reduced to WHNF before the list is
02:03:42 <quicksilver> EvilTerran: hmm. Maybe that does work.
02:03:45 <quicksilver> EvilTerran: good point.
02:03:51 <EvilTerran> so the act of traversing the list spine'd be enough to force the earlier elements
02:03:52 <EvilTerran> :)
02:03:57 <monstre> so how about '[1..] !! n' then, is that constant space for sure?
02:04:06 <Cale> monstre: Whenever you hear someone say the word 'thunk', it's pretty safe to replace that word with 'expression' :)
02:04:27 <quicksilver> annoyinngly, that depends on the type of '1' I think
02:04:31 <Cale> monstre: if [1..] is implemented in a nonidiotic way, yes
02:04:31 <EvilTerran> monstre, no, not really - just say "n+1" :P
02:04:34 <quicksilver> it's constant space for Int
02:04:46 <quicksilver> but some other types are insufficiently strict in the standard lib
02:04:47 <Cale> quicksilver: this is fixed in newer GHC's I think.
02:04:50 <quicksilver> but this is a bug.
02:04:55 <quicksilver> and may be fixed nw :)
02:05:17 * EvilTerran wheels out the old "time and space complexity are implementation-dependent and not defined in the Report" chestnut
02:05:17 <sjanssen> where newer = darcs, I'm afraid
02:05:27 <Twey> monstre, thunk = an expression that hasn't been evaluated yet
02:05:29 <sizur> monstre: as a general tip, try to avoid (!!)
02:06:00 <EvilTerran> hehe, "Chestnut (Castanea), [1] including chinkapin, is a genus of eight or nine species of deciduous trees and shrubs in the beech family Fagaceae" <- i was checking the spelling, and the first time i read that, i mis-lexed "deciduous" as "delicious" :D
02:06:07 <Cale> yeah, lists are meant to be processed linearly, and if your access pattern is basically anything else, you're probably using the wrong datastructure.
02:06:54 <monstre> I was wondering what happens when you generate a list and then consume it shortly thereafter
02:07:02 <Cale> (at least as far as being efficient is concerned)
02:07:16 <sizur> monstre: better consume as you're generating
02:07:17 <Cale> monstre: You actually consume it as it is generated.
02:07:28 <Cale> monstre: Haskell functions are applied outermost first.
02:07:41 <EvilTerran> well, you generate it as it's consumed ;)
02:07:46 <Cale> and it's the demand for elements of that list which cause it to be constructed
02:08:19 <sizur> i see a parallel with quantum mechanics here again
02:08:21 <Cale> (that is, which cause the expression that generates the list to be evaluated)
02:08:36 <sizur> where the act of observation affects the outcome
02:08:42 <EvilTerran> ... evaluated further, that is
02:09:04 <Cale> sizur: The difference here is that the outcome is actually always the same.
02:09:06 <monstre> I'm having a hard time reconciling that with the fact that my earlier examples are not constant space as I imagined they would be
02:09:07 <EvilTerran> sizur, that'd only be the case if you tried to be lazy in an imperative language
02:09:26 <sizur> Cale: the outcome will always be the same in QM if you always observe ;)
02:09:26 <Cale> monstre: The thing is that they're not constant space in a very subtle way.
02:09:41 <Cale> monstre: which actually is why quicksilver and I were confused at first :)
02:09:43 <EvilTerran> monstre, the problem with the iterate one is that, unless you actually look at the elements, you get:
02:09:45 <monstre> basically, how do you figure out the space complexity of anything at all in haskell?
02:09:49 <Twey> sizur, if the act of observation affected outcome Haskell wouldn't be pure :-)
02:10:02 <EvilTerran> iterate (+1) 0 = [0,0+1,0+1+1,0+1+1+1,0+1+1+1+1,0+1+1+1+1+1,...]
02:10:12 <sizur> Twey: but it does. because if you do not need a value, it's not generated
02:10:14 <EvilTerran> without any of those arithmetic expressions being evaluated
02:10:16 <quicksilver> it does affect it
02:10:19 <quicksilver> depending how you define 'outcome'
02:10:22 <quicksilver> consuming RAM
02:10:24 <quicksilver> and CPU time
02:10:26 <quicksilver> is an 'outcome'
02:10:38 <Twey> sizur: But you don't need it anyway, so the outcome's the same
02:10:46 <EvilTerran> so, if you held on to the head of the list as well as stepping along it, but didn't look at any of the elements, it'd actually be O(n^2)
02:10:53 <Cale> monstre: If you'd like, I can give you my short demo on how lazy evaluation works
02:10:59 <sizur> Twey: here act of observation affects the whole system
02:11:06 <monstre> Cale: please do
02:11:08 <Cale> okay
02:11:15 <EvilTerran> if you look at the elements as you go, but still hold onto the start of the list, it'd be O(n)
02:11:18 <Cale> We'll consider the function:
02:11:23 <Cale> double x = x + x
02:11:33 <Cale> and the expression double (double 5)
02:11:54 <Cale> Under strict, that is, innermost-first, evaluation, which most languages use, it's evaluated like this:
02:11:59 <Cale> double (double 5)
02:12:04 <Cale> -> double (5 + 5)
02:12:06 <EvilTerran> if you don't hold onto the start and don't look at the elements, it'd be O(n), as the leading parts of the list would be GCd as you went, but there'd still be a O(n) load of unevaluated (+)s
02:12:08 <Cale> -> double 10
02:12:09 <Twey> I have a bit of a general question, I'm afraid... In "Haskell for C Programmers," the list of Fibonacci numbers is defined as 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
02:12:12 <Cale> -> 10 + 10
02:12:14 <Cale> -> 20
02:12:20 <monstre> right
02:12:44 <Cale> Now, suppose we evaluate it outermost first, this is also known as normal-order reduction
02:12:45 <Twey> My question is, what would the thought process be that lead to that elegant a definition?  I can't see myself ever thinking up something like that.
02:12:49 <EvilTerran> but if you don't hold onto the start and do look at the elements as you go, all those (+)s will collapse down to a single numeric value each time, making it constant-tike
02:12:52 <Cale> double (double 5)
02:12:58 <Cale> -> (double 5) + (double 5)
02:13:02 <EvilTerran> *constant-space. what a typo.
02:13:04 <Cale> -> (5 + 5) + (double 5)
02:13:08 <Cale> -> 10 + (double 5)
02:13:12 <Cale> -> 10 + (5 + 5)
02:13:15 <Cale> -> 10 + 10
02:13:15 <monstre> I'm actually familiar with normal-order evaluation from reading SICP
02:13:17 <Cale> -> 20
02:13:19 <Cale> okay
02:13:34 <Cale> Note that we evaluated double 5 twice there
02:13:37 <EvilTerran> Twey, well, each element in the fibonacci numbers is the sum of the previous two
02:13:38 <Cale> which is a waste of time
02:13:48 <sizur> Twey: familiarity with Zip leads naturally to that definition. there are other nice definitions too
02:13:52 <Cale> resulting in more steps than the strict evaluation took
02:14:01 <EvilTerran> if you're writing a sequence in haskell where each value only depends on the previous, you can write something like
02:14:16 <EvilTerran> > let xs = 1 : [x+1 | x <- xs]
02:14:16 <lambdabot>  Parse error at end of input
02:14:18 <EvilTerran> > let xs = 1 : [x+1 | x <- xs] in xs
02:14:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:14:30 <Cale> Lazy evaluation modifies this, adding a rule which states that if a parameter to a function occurs multiple times in the function body, its evaluation is shared between the copies.
02:14:42 <EvilTerran> if it depended on the last-but-one element, you could write
02:14:51 <Cale> I'll use let to represent the sharing:
02:14:51 <EvilTerran> > let xs = 1 : 1 : [x+1 | x <- xs] in xs
02:14:52 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
02:14:56 <Cale> double (double 5)
02:15:03 <Cale> -> let x = double 5 in x + x
02:15:10 <Cale> -> let x = 5 + 5 in x + x
02:15:14 <Cale> -> let x = 10 in x + x
02:15:14 <EvilTerran> Twey, and it's just a case of putting those together
02:15:18 <Cale> -> 20
02:15:22 <Twey> Hmmm
02:15:25 <Twey> I see, kind of
02:15:29 <Twey> Thank you, EvilTerran
02:15:32 <EvilTerran> :)
02:15:47 <Cale> monstre: makes sense?
02:15:53 <monstre> so far, yes
02:16:27 <EvilTerran> > fix $ (0:).(1:).(zipWith(+)`ap`tail)
02:16:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:16:41 <Cale> You can imagine the space usage of a program as literally being the number of characters it takes to write the expression that you're evaluating.
02:16:58 <Twey> EvilTerran, I think that's a bit later in the tutorial.  :-P
02:17:06 <monstre> so what would the trace for '[1..] !! n' look like?
02:17:06 <EvilTerran> well, tbh, that should've been
02:17:10 <EvilTerran> > fix $ (0:).(1:).(zipWith(+)<*>tail)
02:17:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:17:17 <EvilTerran> but it's the same thing really :)
02:17:34 <Twey> Heh
02:17:36 <Cale> [1..] !! 3
02:17:55 <Cale> -> (1 : [2..]) !! 3
02:18:04 <EvilTerran> (<*> is a more general version of ap; in the cases where both're defined, they should do the same thing)
02:18:05 <Cale> -> [2..] !! (3-1)
02:18:10 <Cale> -> [2..] !! 2
02:18:21 <Cale> -> (2 : [3..]) !! 2
02:18:43 <Cale> -> [3..] !! (2-1)
02:18:51 <Cale> -> [3..] !! 1
02:18:55 <monstre> right, but doesn't this suggest it should be constant space?
02:18:58 <Cale> yes
02:19:00 <sizur> Cale+++
02:19:04 <Cale> and indeed it will be
02:19:09 <jedbrown> Under what conditions is inlinePerformIO safe?  Same as unsafePerformIO plus no memory allocation?
02:19:33 <Cale> But there's a bug in the implementation of [n..] for Integer in GHC right now.
02:19:54 <Beelsebob> monstre: for getting these traces you don't need Cale (though the explanation is probably useful to you), there's a tool in Hat (hat-anim) that produces exactly this
02:19:55 <monstre> Poor choice of axample I guess
02:19:57 <sjanssen> Cale++ -- corrected :)
02:20:28 <monstre> thanks for the explanation, Cale
02:20:30 <sizur> sjanssen: why are you taking a (+) away from him? he deserved it
02:20:46 <Cale> sizur: because it won't update my karma otherwise
02:20:51 <Beelsebob> in the mean time, the [1..] !! 3 is slightly more complex than that, because it involves the evaluation of the conditional as wel as the body
02:20:51 <Cale> @karma
02:20:51 <lambdabot> You have a karma of 58
02:21:07 <sjanssen> jedbrown: I'd reccommend asking a simon (or at least dons)
02:21:10 <Cale> Yes, I was kind of simplifying things a little there :)
02:21:11 <sjanssen> jedbrown: that stuff is deep magic
02:21:21 <sizur> karma doesn't parse exptended syntax?
02:21:28 <sjanssen> sizur: you are giving karma to some guy named 'Cale+'
02:21:35 <Cale> monstre: Another important point I should make...
02:21:40 <jedbrown> sjanssen: Thanks.
02:21:49 <Cale> monstre: Evaluation is really driven by case expressions.
02:22:18 <Cale> monstre: When a case expression pattern matches on a value, this is where demand to evaluate that value further comes from.
02:22:49 <monstre> so pattern-matching is strict then?
02:23:04 <Cale> It's the source of strictness, yes.
02:23:07 <sjanssen> jedbrown: I got an email from someone that is writing a lazy storablevector.  IIRC, you were interested in that?
02:23:10 <sizur> anyways ;) treasure in heaven has more value than karma on a harddisk ;)
02:23:13 <quicksilver> monstre: in case but not in let.
02:23:16 <Cale> You can make patterns which are lazy
02:23:23 <Cale> But they *always* match.
02:23:32 <Cale> (and generate an error if they didn't really match)
02:23:59 <Cale> (the error only happens when the bound variables end up needing to be evaluated)
02:24:41 <Cale> The way to write a lazy pattern is to put a ~ before it.
02:25:02 <visof> the definition of last function is
02:25:03 <lambdabot> visof: You have 1 new message. '/msg lambdabot @messages' to read it.
02:25:04 <Cale> In pattern bindings (as opposed to function bindings), the compiler automatically puts a ~ for you.
02:25:06 <jedbrown> sjanssen: Oh, cool.  I'm working with array stuff now.  I've got mutable (basically Data.Array.Storable) and immutable CArray now, with extra stuff for higher dimensions.  And FFTW is working, but needs some tuning with the advanced interface.
02:25:10 <monstre> already knew about lazy patterns though
02:25:15 <Cale> okay :)
02:25:20 <visof> last [x]  = x
02:25:29 <monstre> it's the whole evaluation model I'm trying to understand
02:25:33 <visof> last (x:xs) =last xs
02:25:39 <monstre> failing, more like
02:25:53 <visof> can we make last with another definition
02:25:56 <visof> ?
02:26:00 <sizur> let's implement fully SOAP lib for haskell!
02:26:12 <quicksilver> visof: last = head . reverse ?
02:26:14 <sizur> who's in?
02:26:48 <Cale> monstre: Let me give another good example to see :)
02:26:54 <sizur> together with WSDL
02:26:55 <sjanssen> jedbrown: cool
02:26:56 <Cale> foldl (+) 0 [1,2,3]
02:27:08 <Cale> (this is a place where lazy evaluation is bad)
02:27:18 <Cale> recall that:
02:27:20 <koeien> > foldl' (+) 0 [1,2,3]
02:27:21 <lambdabot>  6
02:27:27 <sizur> does anybody find this very important for Haskell's adoption?
02:27:28 <Cale> foldl f z [] = z
02:27:34 <monstre> I think I've heard the punchline on that one already, Cale
02:27:38 <Cale> foldl f z (x:xs) = foldl f z (f z x) xs
02:27:41 <monstre> foldl', right?
02:27:45 <Cale> monstre: yes
02:27:47 <Cale> er
02:27:50 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
02:28:05 <Cale> So let's see what happens when evaluating foldl (+) 0 [1,2,3]
02:28:25 <jedbrown> sjanssen: I spent about an hour trying to find the bug within my unsafePerformIO, only to find that the library was mutating the input array even with the PRESERVE_INPUT flag set ;)
02:28:26 <Cale> foldl (+) 0 (1:2:3:[])
02:28:36 <Cale> -> foldl (+) (0 + 1) (2:3:[])
02:28:45 <Cale> -> foldl (+) ((0 + 1) + 2) (3:[])
02:28:52 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
02:28:53 <jedbrown> sjanssen: But now things are all working.
02:29:00 <Cale> -> ((0 + 1) + 2) + 3
02:29:05 <Cale> -> (1 + 2) + 3
02:29:08 <Cale> -> 3 + 3
02:29:09 <Cale> -> 6
02:29:45 <Cale> As you can see, we build up a big expression which will take lots of stack space when it finally gets evaluated, and takes up memory until then.
02:30:21 <Cale> Even though this is tail recursive, and the tail-call optimisation is performed, you get a tight loop which builds up an expression.
02:30:23 <sizur> hmm, nobody finds soap/wsdl essensial for haskell adoption :(
02:30:59 <Cale> So the trick here is to write a version of foldl which forces the evaluation of its accumulating parameter before making the tail call.
02:31:09 <Cale> foldl' f z [] = z
02:31:25 <doserj> sizur: it would be helpful, but probably most of the people would need a lot of compensation money for doing that
02:31:30 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
02:31:30 <C-Keen> how do I use GHC.Exts functions?
02:31:53 <monstre> say, doesn't the foldl example actually argue against having a lazy language to begin with?
02:31:58 <quicksilver> C-Keen: (a) don't. (b) just like any other funciton. (c) what are you trying to do?
02:32:08 <monstre> seems to me, it would work just fine in a strict language
02:32:23 <koeien> monstre: that is only because (+) is strict
02:32:29 <Cale> monstre: Yes, but there are lots of other arguments for making the language lazy by default.
02:32:50 <monstre> such as?
02:33:12 <Cale> monstre: It's always collapsing operations like this where you want strictness -- ones where you turn "large" things with lots of separately evaluated parts into "small" ones with few separately evaluated parts.
02:33:31 <Cale> In some sense, this is the only case where you want it.
02:33:46 <Cale> In other cases, the two are either roughly equivalent, or laziness is better.
02:34:05 <Cale> What laziness does for you is it gives you new ways to break down problems.
02:34:31 <monstre> Hmmm, I think I've had this conversation before
02:34:33 <Cale> Specifically, you don't worry so much about writing things which produce very large and very general data structures.
02:34:53 <Cale> Because later you can wrap them up in functions which only use the parts you'll need.
02:35:01 <monstre> someone will probably recommend 'why fp matters' right around now
02:35:28 <Cale> In strict languages, you have to worry all the time about whether you're building something you'll later need or not, and this forces you to intermingle code for making those decisions with the generation.
02:35:44 <monstre> I'm still not convinced it's a better default, given the headaches it causes to simpletons like me
02:35:44 <quicksilver> consider this:
02:35:58 <quicksilver> (take 120 . takeWhile (<foo) ) l
02:36:05 <quicksilver> in a string language, that wastes work
02:36:05 <Cale> monstre: The headaches go away after a short time, but the benefits don't.
02:36:17 <quicksilver> you would have to decide if it's likely that more or less than 120 items are <foo
02:36:22 <quicksilver> s/string/strict/
02:36:33 <quicksilver> in a lazy language, you get the most efficient answer
02:36:46 <quicksilver> whether 120 is fewer or <foo matches fewer
02:36:53 <quicksilver> in C you'd have a for loop with a break statement
02:36:57 <Cale> Here's an example which I like, even though it's not the best example, it's simple.
02:36:57 <quicksilver> but this is much simpler.
02:37:12 <quicksilver> I use the above example because I used it in a real program the other week :)
02:37:21 <Cale> Consider the problem of determining if one string is a substring of another.
02:38:15 <Cale> There's a naive algorithm which lots of people use in imperative languages which involves nested loops with early breakouts.
02:38:49 <Cale> In order to have those early breakouts, you can't just generate the list of all tails of the string, and then check if each is a prefix.
02:38:57 <monstre> I think I've seen that one as well, Cale
02:38:59 <Cale> But in a lazy language, you can.
02:39:21 <monstre> it's a fine argument in favour of lazy lists, sure
02:39:25 <vincenz> is it possible where an error comes from?
02:39:51 <Cale> vincenz: "to determine", yes, with ghc 6.8.1 it's even pretty easy :)
02:40:02 <monstre> I'm just not sure I want the entire language to be lazy, as opposed to just lists
02:40:04 <Cale> er or 6.8.2 even :)
02:40:09 <vincenz> Cale: how?
02:40:13 <monstre> so what am I missing?
02:40:25 <Cale> monstre: Well, not just lists are important for laziness -- lazy tree structures of all sorts are also important.
02:40:33 <quicksilver> it's very convenient to be able to have a whole bunch of "lets" up front of a function.
02:40:39 <monstre> well, lazy recursive structures in general
02:40:44 <quicksilver> only some of which are actually used, depending which path the code takes
02:40:51 <jedbrown> vincenz: Read the debugger part of the users manual or check out dons intro: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
02:40:52 <sizur> monstre: you can build an infinite decision tree and work with it for example
02:40:53 <quicksilver> and not worry about which ones are needed when.
02:40:53 <lambdabot> Title: Haskell hacking
02:40:54 <Cale> monstre: Additionally, if you have a strict default, what happens is that people write libraries which are strict.
02:41:07 <vincenz> jedbrown: thanks
02:41:21 <Cale> monstre: Most of the benefit of laziness comes from compositionality, and most of the benefit of compositionality comes from code reuse.
02:41:41 <Cale> monstre: When you have strict libraries, you can't reuse them effectively with lazy code.
02:42:15 <monstre> Cale: if cons is lazy, library code using cons will be lazy where it matters, no?
02:42:32 <Cale> vincenz: sorry about that, I'd have pointed you to the same place :)
02:44:01 <hpaste>  quicksilver pasted "ugly imperative code but.." at http://hpaste.org/5194
02:44:02 <sizur> i suspect that the solution is to be able to work just as easy with strict and lazy evaluations
02:44:21 <aleator> monstre: for dynamic programming lazy arrays are kinda nice as well: fib n = listArray (0,n) (1:1:[r!(x-1)+r!(x-2) | x <- [2..n]]) ! n
02:44:25 <quicksilver> monstre: if you look at that paste you can see what I mean.
02:44:38 <quicksilver> monstre: it's from a piece of a particularly imperative algorithm, writing to a fiddly file format.
02:44:50 <quicksilver> but lazy evaluation is still enormously convenient
02:44:56 <kaol> > (((++ "x") >>> reverse >>> head) "abcde", (head . reverse . (++ "x")) "abcde")
02:44:57 <quicksilver> I don't have to worry about computing things which aren't used in a given code path.
02:44:58 <lambdabot>  ('x','x')
02:46:06 <Cale> monstre: The point is that once you're used to laziness, you actually want your code to be lazy more often than you want it to be strict. Most strict things can also be folded up into general combinators like foldl' (in fact, foldl' captures quite a lot)
02:46:43 <Cale> So introducing laziness explicitly adds syntactic noise over introducing strictness explicitly, if you're fair about it.
02:46:48 <monstre> but writing things in terms of folds and the like can get annoying
02:46:58 <opqdonut> not really
02:46:59 <vincenz> jedbrown: neat, thanks
02:47:06 <vincenz> that works great
02:47:06 <Cale> There are also things like bang patterns, which make parameters strict.
02:47:19 <Cale> f !x = ...
02:47:23 <opqdonut> last time i had a space leak problem, it was the fault of an implicit non-strict fold
02:47:23 <Cale> means the same as
02:47:29 <Cale> f x = x `seq` ...
02:47:47 <opqdonut> writing it as an explicit fold and then changing to foldl' fixed it
02:47:51 <sizur> monstre: actually it's very nice to use folds and the like, and it's not a defensive statement.
02:48:11 <opqdonut> if i had the code originally into a fold i wouldn't have had to search for the problem
02:48:29 <opqdonut> gah, terrible grammar on that last line
02:48:51 <kuribas> quicksilver: I have a new version of my haskell-indent.el, with some important changes.
02:49:10 <quicksilver> kuribas: excellent!
02:49:28 <opqdonut> kuribas: so what's new?
02:49:35 <kuribas> I've pasted it for now: http://paste.lisp.org/display/54741
02:49:39 <Cale> monstre: Of course, beyond a certain point, nothing we could say will be any more convincing. It's one of those things you just have to try getting comfortable with, and see for yourself :)
02:49:57 <kuribas> opqdonut: In my new engine, or in my new version?
02:50:14 <monstre> Alright, here's the new plan: don't worry about space until I get a stack overflow
02:50:15 <opqdonut> new version
02:50:35 <kuribas> opqdonut: I've changed some bad indentations, and I've added support for DEL.
02:50:53 <opqdonut> oh, wait, is your indent.el different from the one for example in the debian haskell-mode package?
02:51:02 <kuribas> opqdonut: yes.
02:51:04 <quicksilver> yes, he's completely rewritten it
02:51:10 <opqdonut> ah
02:51:12 <quicksilver> it's a much more interesting idea
02:51:19 <quicksilver> I think Cale would like it better than the standard one :)
02:51:31 <Cale> :)
02:51:34 <opqdonut> any chance of it being adopted into haskell-mode?
02:51:52 <opqdonut> (the package)
02:52:10 <opqdonut> woops, network lag is killing me
02:52:18 <kuribas> opqdonut: I'll write to the maintainer when I am happy about it (currently you cannot turn of the minor mode).
02:52:20 <opqdonut> (and inserting random characters, it seems? o_O)
02:52:35 <opqdonut> kuribas: ok :)
02:52:37 <quicksilver> opqdonut: your evil twin has gone.
02:52:41 <quicksilver> opqdonut: you will feel better now.
02:53:04 <opqdonut> :P
02:54:13 <opqdonut> i somehow feel safer with a backup shell server :)
03:00:31 <visof> can i define init with another definition ??
03:00:45 <visof> foo [x]  = []
03:01:02 <visof> foo (x:Xs)  = [x] ++ foo xs
03:01:17 <visof> another?
03:01:18 <jedbrown> visof: foo (x:xs) = x : foo xs
03:01:29 <visof> ya i know that aslo
03:01:33 <visof> also*
03:01:39 <visof> another?
03:01:48 <quicksilver> OMG! I'm famous!
03:01:53 * quicksilver got credited on the lolcat.
03:02:50 <kaol> a very fine lolcat that was indeed
03:02:59 <vegai> quicksilver: well, you were discovered almost 3500 years ago
03:03:22 <Cale> visof: I suppose you could write  init = reverse . tail . reverse
03:03:59 <vincenz> Cale: woo, got rid of the non-transitive stuff
03:04:03 <doserj> but that doesn't do the same thing, of course
03:04:22 <Cale> oh,  reverse . drop 1 . reverse   for this one.
03:04:30 <Cale> mm
03:04:35 <Cale> no, it does :)
03:04:54 <quicksilver> > init []
03:04:56 <lambdabot>  Exception: Prelude.init: empty list
03:05:03 <Cale> It takes longer, but it does the same thing as that foo
03:05:16 <araujo> morning
03:05:59 <doserj> > reverse . tail . reverse $ [1..]
03:06:02 <lambdabot> Terminated
03:06:13 <Cale> Oh, right :)
03:06:19 <doserj> a bit longer, yes
03:07:06 <Cale> So  reverse . tail . reverse â init
03:07:30 <EvilTerran> that symbol doesn't appear for me - is it [= (is refined by)?
03:07:35 <Cale> yeah
03:08:35 <visof> it's appear for me
03:23:34 <sizur> i have just discovered HST
03:23:38 <sizur> HXT
03:24:34 <hpaste>  c-keen pasted "Why is the type of the multiplication not Int->Int -> Int?" at http://hpaste.org/5195
03:37:54 <EvilTerran> ?type (**)
03:37:56 <lambdabot> forall a. (Floating a) => a -> a -> a
03:38:11 <EvilTerran> C-Keen, what's (** 2 pot) supposed to mean?
03:38:14 <EvilTerran> 2 isn't a function
03:38:25 <byorgey> @index Word8
03:38:25 <lambdabot> Data.Word, Foreign
03:40:02 <EvilTerran> if it's supposed to be (** (2*pot)), then even with that change, the problem remains of the type of (**), as above
03:40:07 <EvilTerran> ?instances Floating
03:40:10 <lambdabot> Double, Float
03:40:32 <EvilTerran> ?type (^) -- maybe this is what you want
03:40:33 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:41:07 <visof> can i define my own class constraint??
03:41:09 <shag> is it somehow possible to have strings encoded in utf8 and represented internally as [Word8] to save space? or is this idea not really practical?
03:41:36 <C-Keen> EvilTerran: hm..you are right
03:42:24 <EvilTerran> shag, i believe there's a UTF-8 ByteString library in the works, just waiting for someone to implement it ;)
03:42:44 <dcoutts_> heh heh heh
03:43:14 <EvilTerran> (which'd save a lot more space than switching from Char to Word8 would)
03:43:21 <shag> EvilTerran: hmmm. sounds good. do you now if someone is already doing it or how to get involved?
03:43:22 <litb> hello again :)
03:43:23 <byorgey> visof: you want to define your own type class? sure.
03:43:35 <byorgey> hi litb =)
03:43:37 <quicksilver> shag: representing as [Word8] will consume very much more space :)
03:43:41 <litb> i wonder how i should make this work: (Funktion sin) 100
03:43:52 <litb> so, apply something to my datatype in the way i would use a function
03:43:55 <quicksilver> shag: at least, if you ever use any multibyte chars.
03:43:59 <EvilTerran> quicksilver, as compared to [Char]? i'd think it *slightly* smaller
03:44:05 <byorgey> litb: you need an applyFunktion function
03:44:06 <quicksilver> EvilTerran: No.
03:44:07 <opqdonut> litb: fmap ($100) (Funktion sin)
03:44:13 <opqdonut> if Funktion is a functor
03:44:17 <shag> quicksilver: but why? yesterday, someone told me that Char is 64 bit wide on my machine, so i think the space savings will be considerable
03:44:33 <quicksilver> shag: the overhead of hte list is the dominating factor.
03:44:40 <EvilTerran> shag, well, any multi-byte characters would take up several list cells
03:44:49 <byorgey> opqdonut: I don't think it is a functor.
03:44:50 <quicksilver> and if you have a 64 bit machine, then a Word8 also takes up 64 bit.
03:44:53 <quicksilver> plus overhead
03:44:53 <litb> opqdonut: well, i want this so i don't have to type (function (Function sin)) 100
03:44:59 <shag> yes, but most of my text will consist of latin characters ...
03:45:01 <litb> but using fmap is even more writing
03:45:12 <sjanssen> shag, EvilTerran: GHC stores all values (even unboxed Word8s!) at the same size as addresses (ie. 64 bits on a 64 bit machine)
03:45:22 <EvilTerran> sjanssen, um, okay
03:45:28 <shag> and i prefer "a" to consume just one byte instead of eight byte
03:45:30 <opqdonut> litb: well unfortunately that's impossible
03:45:43 <quicksilver> shag: it actually consumes more like 24 bytes.
03:45:52 <byorgey> litb: it isn't possible to do without some sort of 'apply' function.  application syntax isn't user-extensible.
03:45:54 <opqdonut> i mean having ((Funktion sin) 100) do anything
03:45:59 <sizur> litb: make it an instance of Functor, then you can do: (Function sin) <$> 100
03:45:59 <quicksilver> shag: and would still do so with [Word8] as much as [Char].
03:46:01 <shag> hu? why does word8 take up 64 bits?
03:46:07 <sjanssen> EvilTerran: the memory occupied by Word8 and Char is the same, essentially
03:46:09 <quicksilver> because.
03:46:11 <opqdonut> unless you make the constructor weird, at least
03:46:11 <quicksilver> :)
03:46:13 <sizur> oh no
03:46:20 <EvilTerran> sjanssen, i see
03:46:30 <litb> sizur: oh nice
03:46:31 <EvilTerran> sizur, Functor wouldn't work, i don't think
03:46:36 <sizur> no that wont work
03:46:39 <sjanssen> shag: it simplifies GHC's execution model
03:46:40 <EvilTerran> sizur, Applicative, maybe
03:46:55 <byorgey> EvilTerran: no, to be Applicative it has to be a Functor too
03:46:55 <EvilTerran> or Arrow ;)
03:46:57 <sizur> @src (<$>)
03:46:57 <lambdabot> f <$> a = fmap f a
03:47:05 <EvilTerran> byorgey, i know that.
03:47:07 <quicksilver> shag: if you are worry about space consumption you should use ByteString.
03:47:14 <EvilTerran> i was saying that Functor wasn't sufficient
03:47:24 <quicksilver> however, I wouldn't worry unless your strings average at least 20 chars long each.
03:47:27 <sizur> :t fmap
03:47:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:47:28 <byorgey> EvilTerran: oh, well I'm saying Functor isn't possible.
03:47:38 <shag> quicksilver: i tried them, but i have A LOT of small strings, 1-20 characters. and i observerd quite some more memory consumption than using String
03:47:45 <EvilTerran> i haven't seen the type, so i can't say
03:48:10 <byorgey> It's something like data Funktion = Funktion (Double -> Double) (Maybe ... something else)
03:48:17 <byorgey> IIRC
03:48:22 <sizur> litb: you'd have to wrap the argument into a type of that functor too
03:48:37 <sjanssen> I bet dcoutts_ knows this off the top of his head: at what point does [Char] use more memory than ByteString
03:48:46 <sizur> meh bleh i did not wake up yet
03:48:54 <litb> hm
03:49:05 <shag> sjanssen: yes, that would be quite interesting for me :)
03:49:10 <quicksilver> sjanssen: quite low, IIRC. 4 or 5 chars on 64 bit, bit longer on 32 bit.
03:49:17 <quicksilver> sjanssen: but it remains slower, of course...
03:49:45 <quicksilver> shag: if you deal with really huge amounts of small strings you may consider ways of representing them so they are all part of the *same* ByteString
03:49:50 <quicksilver> that is very memory efficient
03:49:53 <litb> darn, so it's the best i stay with (function (Function sin)) 100 i suppose
03:49:58 <quicksilver> but it depends what kind of processing you do.
03:50:05 <sizur> litb: yes
03:50:06 <EvilTerran> litb, what's your datatype?
03:50:06 <quicksilver> litb: I would define a custom application combinator
03:50:08 <dcoutts_> sizeof [Char] = 3*length*wordsize, sizeof ByteString = 7*wordsize+length
03:50:20 <litb> EvilTerran: hold on, i will paste the whole baby
03:50:23 <quicksilver> litb: Function sin $$ 100
03:50:26 <shag> quicksilver: hm, sounds like an idea.
03:50:28 <sjanssen> dcoutts++
03:50:31 <shag> ah, dcoutts, thanks.
03:50:32 <quicksilver> litb: for some choice of '$$' of your preferenec.
03:50:47 <hpaste>  litb pasted "baby knuth" at http://hpaste.org/5196
03:50:50 <sizur> litb: or you can make a class Function with mehtod apply, and have a type Sin
03:50:58 * EvilTerran was about to suggest what quicksilver just suggested, right down to calling it $$
03:50:59 <dcoutts_> oh, wait, that's not right, it's 9*wordsize+length for bytestring
03:51:05 <dcoutts_> 5 for shared
03:51:07 <sizur> then you can do: apply (Sin 100)
03:51:10 <litb> EvilTerran: it is Funktion
03:51:17 <dcoutts_> 4 words can be shared by substrings
03:51:22 <litb> (ableitung meaning derivative)
03:52:03 <EvilTerran> i see
03:52:22 <litb> Function sin $$ 100 <-- this looks good. let me try that
03:52:35 <EvilTerran> you could possibly do something with the Arrow class, but it'd be massive overkill
03:52:37 <sjanssen> dcoutts_: quicksilver just mentioned an interesting idea: ever considered a "string pool" to take advantage of sharing the ForeignPtr?
03:52:52 <EvilTerran> renaming "function" to $$ is a better idea, imo
03:53:03 <litb> ($$) :: Funktion -> a -> Double; a $$ b = (funktion a) b
03:53:03 <dcoutts_> sjanssen: you get it automatically if you take substrings
03:53:07 <litb> i think that does it
03:53:25 <dcoutts_> sjanssen: and if anyone wants to keep a map and intern strings they can do that and then they get faster ==
03:53:25 <EvilTerran> a $$ b = funktion a b
03:53:39 <EvilTerran> a $$ b = a `funktion` b
03:53:44 <EvilTerran> ($$) = funktion ;)
03:53:45 <sjanssen> dcoutts_: right, though one can imagine situations where that isn't enough, or too much
03:53:48 <litb> EvilTerran: ah, i don't need parens ?
03:53:55 <dcoutts_> sjanssen, shag: so [Char] wins for length 0-3, ByteString wins for length 4+
03:54:03 <EvilTerran> indeed not; function application is left-associative
03:54:03 <sjanssen> dcoutts_: yeah, it'd make sense to do interning at the same time
03:54:11 <shag> dcoutts: on 64bit?
03:54:12 <litb> doesn't it think that funktion requires one argument, but i pass 2 if i don't paren it?
03:54:21 <EvilTerran> f g h = (f g) h; that's why currying works
03:54:30 <EvilTerran> (without parentheses)
03:54:31 <hpaste>  kingc4bmoy annotated "Python Y combinator stuff..." with "d3r59pdyt2" at http://hpaste.org/4799#a1
03:54:35 <litb> EvilTerran: ah i see
03:54:41 <dcoutts_> shag: same crossing point, it just scales
03:54:43 <litb> it's quite confusing sometimes for me :)
03:54:49 <shag> k, thanks
03:55:10 <jedbrown> dcoutts_: Can you tell me when inlinePerformIO is safe?
03:55:12 <byorgey> litb: f g h x y = (((f g) h) x) y
03:55:22 <byorgey> litb: i.e. function application is left-associative.
03:55:23 <sjanssen> @tell glguy http://hpaste.org/4799#a1 hpaste spam
03:55:24 <lambdabot> Consider it noted.
03:55:31 <litb> byorgey: ah, alrite, thxx veri much
03:55:51 <EvilTerran> anyway, funktion takes two parameters
03:56:00 <EvilTerran> funktion :: Function -> Double -> Double
03:56:04 <litb> EvilTerran: two?
03:56:10 <litb> oh, yes
03:56:27 <litb> i think of it like "provide a Funktion, and you get the wrapped funktion"
03:56:44 <litb> but i forget to take the argument of the returned funktion into accound :)
03:56:46 <litb> *account
03:57:17 <byorgey> litb: there are two different ways to think of it.  is it Function -> (Double -> Double) or Function -> Double -> Double ?
03:57:24 <byorgey> because of currying, they are the same
03:57:51 <litb> i always seem to think of it like the first one :)
03:57:55 <sjanssen> shag: what sort of program are you writing that uses all these small strings?
03:58:19 <shag> sjanssen: i am writing an indexing/search engine for my masters thesis
03:59:18 <quicksilver> sjanssen: I have a primitive on-disk database which, because of the way bytestrings work, when you pull out records you're effectively using a pool.
03:59:33 <quicksilver> sjanssen: it just reads in a whole block and hands out the substring(s) ou asked for.
04:00:50 <sjanssen> quicksilver: so you name strings as (offset, length) pairs?
04:01:03 <shag> when using inits or tails on bytestrings, does this substring-sharing-thing apply?
04:01:36 <byorgey> right.
04:01:37 <sjanssen> shag: yep
04:01:52 <shag> cool! think this will save my day ;)
04:01:54 <quicksilver> sjanssen: no, ByteString does it all for me
04:03:01 <quicksilver> sjanssen: lalthough behind the scenes that is, of course, what bytestring is doing.
04:03:44 <hpaste>  Cale pasted "simple network application" at http://hpaste.org/5197
04:03:53 <Twey> Why is there no unary plus in Haskell?
04:04:05 <Twey> Or maybe I should say, why is there a unary plus in other languages?
04:04:10 <Cale> Twey: because it'd require another special case
04:04:24 <byorgey> Twey: what you should be asking is why there's a unary minus. =)
04:04:30 <Twey> Heh
04:04:36 <Cale> I like unary minus, personally.
04:04:41 <koeien> i don't
04:04:57 <koeien> Twey: there is a unary plus in Haskell, it's called `id` :)
04:05:02 <Twey> Heh, OK :-P
04:05:04 <Cale> I think their design decisions there struck a reasonably good compromise.
04:05:13 <dcoutts_> jedbrown: http://hpaste.org/4885
04:05:39 <quicksilver> I think it is a disastrous compromise.
04:05:51 <quicksilver> To have a lovely uniformity of operators and break it for one stupid one I never use.
04:06:12 <koeien> yes, i agree
04:06:26 <meryrus> Wait, really?
04:06:32 <dcoutts_> yes, lets add arbitrary user-defined prefix and postfix operators!
04:06:35 <Cale> You never use the unary minus?
04:06:38 <Twey> I agree, actually
04:06:40 <quicksilver> never.
04:06:46 <koeien> i've never used unary minus
04:06:46 <quicksilver> well, hardly ever.
04:06:47 <quicksilver> :)
04:06:49 <Cale> Not even to write things like -x ?
04:06:51 <koeien> i tried it :)
04:06:52 <Twey> I don't use it very often
04:06:54 <dcoutts_> or -1 ?
04:06:55 <quicksilver> I'd be just as happy with negate.
04:06:58 <Twey> (0 - 1) is OK for those cases.
04:06:59 <koeien> negate 1
04:07:02 <koeien> or (0-1)
04:07:06 <Twey> Or (negate 1) I guess
04:07:09 <meryrus> O_o;
04:07:16 <Cale> That would be terrible :)
04:07:18 <koeien> you use it hardly ever
04:07:29 <Cale> Maybe you use it hardly ever.
04:07:30 <sjanssen> I'd like - to be part of the lexical syntax for Num literals
04:07:31 <koeien> => not worth sacrificing uniformity
04:07:32 <meryrus> Using six characters where one has the same meaning would be bad language design, imho.
04:07:33 <Twey> Cale, not really, I have a calculator that does that
04:07:41 <Cale> sjanssen: But then -x wouldn't work.
04:07:46 <sjanssen> Cale: right
04:07:54 <koeien> meryrus: then write n = negate :)
04:07:56 <Twey> meryrus, but then +x should exist for symmetry, really
04:07:56 <jedbrown> dcoutts_: Thanks.  In ByteString.hs, both map and zipWith' use inlinePerformIO *and* do memory allocation inside it.
04:08:09 <jedbrown> dcoutts_: Presumably some extra condition makes that actually okay.
04:08:14 <quicksilver> meryrus: I already have to.
04:08:24 <quicksilver> meryrus: map (subtract 7) [1,2,3,4]
04:08:32 <quicksilver> atually that's 8 character :)
04:08:44 <Twey> Ten including brackets :-)
04:08:48 <koeien> the space :), so 9
04:08:59 <koeien> Twey: you need the () though
04:08:59 <quicksilver> Twey: you need the brackets
04:09:02 <quicksilver> map (-7) [1,2,3,4]
04:09:05 <quicksilver> is what I want to write.
04:09:07 <litb> damn, i can't use ($$') to make that with the derivative the same way
04:09:09 <Twey> Oh, true that.
04:09:16 <Cale> quicksilver: that reads very wrong for me
04:09:35 <Cale> (-7) parses in my head as "negative seven", whether I want it to or not :)
04:09:39 <quicksilver> don't get me wrong, I don't think it's *important*
04:09:39 <koeien> Cale: but why is map (+7) [1,2,3,4] more readable? or do you want to make that impossible as well
04:09:40 <dcoutts_> jedbrown: hmm, it should be ok since the allocation depends on the len of the input
04:09:44 <sarah87> is there a better way to do this? eleminateSame [] = [];eleminateSame x:xs = if elem x xs then xs else x : (eleminateSame xs)?
04:09:47 <quicksilver> I just think it's wrong.
04:09:57 <quicksilver> I find it very annoying although totally trivial.
04:09:59 <doserj> quicksilver: you mean map (- 7) :)
04:10:02 <jedbrown> dcoutts_: Ah, so it can't be floated.
04:10:03 <Cale> koeien: I'm suggesting we keep things as they are in this regard.
04:10:09 <quicksilver> which, funnily enough, is my favourite kind of thing to suggest on IRC>
04:10:13 <Cale> koeien: I like the current syntax.
04:10:16 <koeien> Cale: ok yeah
04:10:33 <aleator> sarah87: function called nub?
04:10:38 <koeien> sarah87: nub
04:10:39 <meryrus> There are moral (read: mathematical) reasons for keeping unary -, but Num is all pear-shaped in that respect anyway.
04:10:40 <dcoutts_> jedbrown: well, now you point it out I'm not sure, if the input is a bytestring of a static length
04:10:42 <sarah87> thx
04:10:44 <Twey> o.@
04:10:48 <koeien> @src nub
04:10:51 <dcoutts_> @seen dons
04:10:55 <quicksilver> sarah87: the only 'better' way is to sort the list first.
04:10:59 <Twey> You *broke* her
04:11:05 <quicksilver> sarah87: which works out cheaper, asymptotically.
04:11:06 <Twey> Oh
04:11:09 <koeien> quicksilver: but then you'll need Ord instead of Eq
04:11:10 <Twey> She's not here anyway.
04:11:22 <koeien> quicksilver: so it's a tradeoff
04:11:24 <quicksilver> this is true
04:11:28 <Cale> * lambdabot has quit (Remote closed the connection)
04:11:34 <litb> any idea what i could use instead $$' ?
04:11:34 <Twey> dons: Your bot has left :-\
04:11:38 <koeien> i want lambdabot :( :(
04:11:49 <Twey> lambdabot has left the building!
04:11:55 <quicksilver> I don't very often work with types which support Eq but not Ord, though.
04:12:00 <byorgey> litb: how about %^**#$. ?
04:12:00 <Cale> @src nub
04:12:00 <mbot> nub = nubBy (==)
04:12:03 <Twey> mbot: You are not the bot we're looking for.
04:12:06 <Cale> @src nubBy
04:12:07 <mbot> nubBy eq []             =  []
04:12:07 <mbot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:12:17 <Twey> But, you'll do.
04:12:26 <litb> byorgey: lolz
04:12:31 <Cale> % Integrate[Sqrt[Cos[x]], x]
04:12:33 <mbot> Cale: 2*EllipticE[x/2, 2]
04:12:35 <Twey> Heh, "nub" and "nubBy"
04:12:53 <Twey> Cale: That's not Haskell, is it?  o.@
04:12:57 <koeien> mbot is the #math both as well?
04:13:01 <Cale> Twey: nope, mathematica :)
04:13:05 <byorgey> % Sum[1/k^2, k, 1, Infinity]
04:13:05 <koeien> Twey: mathematica
04:13:05 <Cale> yeah
04:13:06 <Twey> Ah, OK
04:13:06 <mbot> byorgey:
04:13:06 <mbot> Sum::itform: Argument k at position 2 does not have the correct form for an iterator.
04:13:06 <mbot> Sum[1/k^2, k, 1, Infinity]
04:13:14 <Twey> Looks like m-exprs
04:13:16 <Cale> % Sum[1/k^2, {k, 1, Infinity}]
04:13:18 <mbot> Cale: Pi^2/6
04:13:26 <koeien> you can do haskell in #math? cool
04:13:27 <byorgey> Cale: oh, right, thanks =)
04:14:10 * byorgey uses Mathematica just often enough to be dangerous ;)
04:14:16 <Cale> It's the free-advertising-for-Wolfram-bot
04:15:20 <Twey> Heh
04:15:41 <Cale> % Integrate[x^2/(1+x^4), {x,-Infinity,Infinity}]
04:15:43 <mbot> Cale: Pi/Sqrt[2]
04:15:45 <Twey> I like Wolfram.  Let's give it more free advertising.  :-P
04:15:49 <litb> byorgey: i've chosen $$$ now :)
04:15:50 <quicksilver> let's add some quotes to it about proprietary software sucking?
04:16:22 <Cale> % Integrate[Cos[a x]/(1+x^2), {x,-Infinity,Infinity}]
04:16:26 <byorgey> litb: ok, sounds good.  what was wrong with $$ ?
04:16:26 <mbot> Cale: "Time limit exceeded for computation."
04:17:02 <litb> byorgey: it is already used by applying the funktion
04:17:05 <Cale> Heh, I have some very draconian time and space limits on the mathematica part :)
04:17:21 <byorgey> litb: oh, what is $$$ for then?
04:17:28 <litb> byorgey: i wanted to have a function for applying to the derivative
04:17:30 <visof> > read "x" :: Char
04:17:33 <mbot>  Exception: Prelude.read: no parse
04:17:35 <byorgey> litb: ah, I see.
04:17:46 <visof> > read "x" :: String
04:17:48 <litb> byorgey: so ($$$) = ($$).fromJust.ableitung
04:17:50 <mbot>  Exception: Prelude.read: no parse
04:17:55 <koeien> > read "'x'" :: Char
04:17:58 <visof> > read "3" :: Int
04:18:01 <mbot>  'x'
04:18:02 <mbot>  3
04:18:22 <koeien> > read "\"Hello world\"" :: String
04:18:26 <mbot>  "Hello world"
04:18:35 <koeien> > show "Hello world"
04:18:38 <mbot>  "\"Hello world\""
04:18:47 <sarah87> is using =<< instead of concat $ map in normal functions concidered bad style?
04:18:49 <visof> @src show
04:18:49 <mbot> show x = shows x ""
04:19:04 <byorgey> hmm, oughtn't that lambdacat use foldl1 instead of foldl?
04:19:05 <koeien> sarah87: i would use concatMap
04:19:15 * byorgey  <--- unnecessarily pedantic
04:19:36 <quicksilver> byorgey: you're right, of course.
04:19:39 <quicksilver> byorgey: ah well.
04:19:45 <quicksilver> sarah87: I would use concatMap
04:20:02 <quicksilver> sarah87: it's less self-documenting to use =<<
04:20:22 <Cale> sarah87: I often use >>= or =<< for that when it seems appropriate.
04:21:15 <byorgey> sarah87: it's certainly not considered bad style; but as you can see, opinions vary about which is more readable.
04:21:56 <byorgey> quicksilver: yeah, I don't really care all that much, I think that lambdacat is hilarious =)
04:22:29 <sjanssen> hmm, the restriction with unsafePerformIO and STM is quite annoying
04:24:22 <quicksilver> sjanssen: what's that?
04:24:35 <Japsu> @index notFoundJustWantToSeeSomeErrorMessages;)
04:24:35 <mbot> Unknown command, try @list
04:24:40 <sjanssen> quicksilver: calling atomically inside unsafePerformIO will raise an exception
04:24:42 <Japsu> @src notFoundJustWantToSeeSomeErrorMessages;)
04:24:42 <mbot> Source not found. Sorry about this, I know it's a bit silly.
04:25:48 <visof> what is the type of  second xs = head (tail xs)
04:25:48 <visof> ?
04:25:52 <ski_> @ghc
04:25:53 <mbot> ghc says: Unexpected type splice
04:26:50 <EvilTerran> visof, what's the type of head? of tail?
04:26:51 <zerny> it seems that the tar.gz links for ghc source on darcs.haskell.org are symlinks to bzip archives...
04:27:10 <ski_> visof : if you meant the type of `second', where `second xs = ...' .. then `xs' must be a list, say of type `[a]', then .. what is then the type of `tail xs' ?
04:27:31 <zerny> on purpose or irrelevant maybe... just wondering.
04:27:35 <ski_> (`xs' must be a list, since `tail' only accepts list arguments)
04:28:06 <koeien> yes, xs must be a list, since tail :: [a]->[a]
04:28:36 <koeien> head::[a]->a
04:28:44 <koeien> so what is head (tail xs) ?
04:29:35 <nominolo> 42!
04:29:47 <funktio> @pl \f (a,b) -> (a, f b)
04:29:47 <ski_> nope
04:29:48 <mbot> (`ap` snd) . (. fst) . flip ((.) . (,))
04:30:03 <koeien> > let fact n = product [1..n] in fact 42
04:30:05 <mbot>  1405006117752879898543142606244511569936384000000000
04:30:06 <ski_> > product [1..42]
04:30:07 <mbot>  1405006117752879898543142606244511569936384000000000
04:30:15 <ski_> (: koeien
04:30:26 <koeien> :)
04:31:02 <czShadoW> @src product
04:31:03 <mbot> product = foldl (*) 1
04:31:05 <nominolo>  > let fact n = product [1..n] in fact (-1)
04:31:12 <nominolo> > let fact n = product [1..n] in fact (-1)
04:31:14 <mbot>  1
04:31:25 <czShadoW> Oh, that's cool
04:31:27 <funktio> > let fact = product . flip take [1..] in fact 42
04:31:31 <mbot>  1405006117752879898543142606244511569936384000000000
04:31:35 <koeien> yes, haskell needs a "Natural" type :)
04:31:37 <ski_> > let fact n | n >= 0 = product [1..n] in fact (-1)
04:31:37 <funktio> pointless :)
04:31:41 <mbot>   Non-exhaustive patterns in function fact
04:32:05 <opqdonut> koeien: what do you mean? type-level arithmetic?
04:32:22 <koeien> opqdonut: no, just like Integer, a Natural
04:32:35 <koeien> opqdonut: but then the - operator is partial :(
04:32:36 <nominolo> > let fact n | n >= 0 = product [1..n] in fact (-1); fact _ = error "can't haz negatif numberz"
04:32:36 <mbot>  Parse error at ";" (column 50)
04:32:47 <ski_> in ..
04:32:48 <opqdonut> koeien: yes, that's a problem
04:32:52 <nominolo> > let fact n | n >= 0 = product [1..n] ; fact _ = error "can't haz negatif numberz" in fact (-42)
04:32:54 <mbot>  Exception: can't haz negatif numberz
04:33:16 <funktio> :t ap
04:33:18 <mbot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:34:47 <nominolo> why isn't lambdacats on planet.h.o?
04:38:17 <litb> i wonder whether gtk2hs is good or not good
04:38:41 <dcoutts_> litb: I think it's good, but then since I help maintain it I'm obviously biased
04:38:49 <dcoutts_> but people do make serious stuff with it
04:38:58 <byorgey> litb: the law of excluded middle doesn't apply in the real world =)
04:39:00 <litb> dcoutts_: =)
04:39:17 <koeien> litb: Gtk2Hs is very usable, i've used it for one of my projects
04:39:36 <koeien> litb: however it is very imperative, you have to enjoy writing C in Haskell in order to use it =)
04:40:14 <litb> meh
04:40:26 <koeien> litb: i don't know of a better option atm
04:41:09 <nominolo> litb: it's the best we've got.  it's pretty good
04:41:23 <litb> and wx for hs?
04:41:29 <koeien> litb: ew
04:41:31 <nominolo> buggy and incomplete
04:41:32 <koeien> litb: nah
04:41:41 <nominolo> sadly
04:41:49 <koeien> litb: Gtk2Hs >> wxHaskell
04:42:02 <koeien> imo
04:42:16 <litb> hm
04:42:19 <quicksilver> koeien: but writing C or Java in Haskell is SO MUCH NICER than writing it in C or Java.
04:42:26 <koeien> quicksilver: true, very true!
04:42:29 <quicksilver> koeien: that was one of my most startling revelations about fp.
04:42:38 <quicksilver> I was doing a mixed ML/Java project.
04:42:49 <litb> hmm
04:42:53 <quicksilver> and I quickly observed that even the really imperative bits
04:42:56 <quicksilver> come out nicer in ML
04:42:58 <quicksilver> than they do in Java
04:43:03 <LoganCapaldo> even though it is "imperative", you do get some of the (most of (all of?)) the advantages f Haskell. I've only played with it a little, but I was doing things like treating chucks of dialogs as values, which beats the pants off most of your options for GUI reuse
04:43:07 <litb> if i start using it, do you think i will get the meaning of Monads more quickly?
04:43:11 <quicksilver> just having 'mapM' for starters.
04:43:13 <koeien> quicksilver: it is very nice, the imperative stuff is contained in IO (in haskell), and you have static&strong typing
04:43:23 <quicksilver> litb: yes. Learn by cargo-cult and copying examples.
04:43:24 <koeien> quicksilver: and indeed, higher order functions
04:43:29 <quicksilver> litb: then enlightenment will flow.
04:43:38 <quicksilver> litb: as you see how it all fits together in practice.
04:43:42 <quicksilver> litb: and ask plenty of questions here :)
04:43:43 <koeien> litb: not necessarily. you can use gtk2hs without understanding a whole lot of monads
04:44:12 <quicksilver> for example, you often see java programs which create 6 buttons in 36 lines.
04:44:20 <quicksilver> that's 6 lines per button, repated 6 times
04:44:28 <quicksilver> but they're not *exactly* the same, of courtse, slight differences.
04:44:39 <quicksilver> and in java it's incredibly hard to abstract that out into a loop.
04:44:47 <quicksilver> so hard that most programmers wouldn't bother.
04:45:00 <litb> and in gtk2hs you only need 7 lines?
04:45:03 <quicksilver> in haskell it turns into a nice uniform mapM_ with just the differences abstracted out as paramewters.
04:45:34 <quicksilver> well, something like that.
04:45:40 <litb> Gtk2Hs >> wxHaskell <<- well that could mean that Gtk2Hs is superceded by wxHaskell andx returned to users =)
04:45:50 <quicksilver> say 12 lines: 6 for the 'common code' and 1 for each button's specific bits.
04:45:59 <quicksilver> but there are different ways you can imagine doing it.
04:45:59 <koeien> litb: for example, mapM_ (\str -> createNewWindow dlg str) ["Hello", "Yes", "No"]
04:46:12 <litb> yeah, i see
04:46:12 <koeien> litb: (this is pseudocode)
04:46:26 <koeien> litb: but you can't do that easily in Java
04:46:34 <ski_> (`mapM_` ["Hello", "Yes", "No"]) $ \str -> createNewWindow dlg str
04:46:37 <litb> then eta reduction takes place and blows out any other characters still redundant =)
04:46:43 <quicksilver> ski_: forM_ ?
04:46:47 <ski_> (or, better. `forM_')
04:47:02 <quicksilver> it's more powerful with more than 1 parameter though
04:47:11 <koeien> forM_ = flip mapM_   ?
04:47:15 <mux> yes
04:47:16 <ski_> *nod*
04:47:18 <quicksilver> java can do anoynmous arrays and loops, so that one is just about translatable.
04:47:20 <koeien> lol, i've defined foreachM_ in the past
04:47:30 <quicksilver> but it can't do lists of tuples or multiple lvalues.
04:47:54 * mux sometimes used zipWithM_ to effect an incremented i counter
04:48:05 <quicksilver> [hdiag,yesdiag,nodiag] <- forM ["Hello", "Yes", "No"] (\str -> createNewWindow dlg str)
04:48:13 <ski_> $
04:48:15 <mux> zipWithM_ somelist [1..] $ \(x,i) -> do
04:48:27 <quicksilver> mux: definitely, yes.
04:48:30 <litb> [hdiag,yesdiag,nodiag] <- forM ["Hello", "Yes", "No"] (createNewWindow dlg)
04:48:32 <koeien> mux: yes i've used things like that as well
04:48:34 <quicksilver> mux: only it's \x i ->  do
04:48:39 <mux> err, right :-)
04:48:49 <mux> but GHC would have told me that!
04:48:53 <koeien> :)
04:48:55 <mux> ain't haskell great? =)
04:48:57 <quicksilver> litb: I don't always find eta reduction clearer.
04:49:08 <litb> yeah, that forM_ combined with pattern matching is very nice
04:49:08 <quicksilver> litb: normally there is more than one line in the body
04:49:30 <quicksilver> (\str -> do createButton str; addToParent str parent; listenToEvents str eventhandler )
04:49:33 <quicksilver> something like that.
04:49:37 <litb> oh i see
04:49:52 <quicksilver> maybe something to do with layout and packing
04:49:52 <litb> i don't even want to see how that would look in @pl :)
04:49:58 <quicksilver> depends on the GUI toolkit.
04:50:55 <koeien> litb: there's a reason it's called `pointless' :)
04:51:02 <ski_> @pl (\str -> createButton str >> addToParent str parent >> listenToEvents str eventhandler)
04:51:02 <mbot> ap ((>>) . liftM2 (>>) createButton (flip addToParent parent)) (flip listenToEvents eventhandler)
04:52:29 <litb> lolz
04:52:49 <ski_> @ghc
04:52:49 <mbot> ghc says: Use -fglasgow-exts to allow GADTs
04:53:00 <litb> is there someone on this world who sees what that does within a few seconds?
04:53:33 <ski_> ghc ?
04:54:56 <quicksilver> litb: yes, I understand what it's doing.
04:55:05 <koeien> litb: i see it, but not "in a few seconds"
04:55:18 <ricky_clarkson> Imagine you had a Haskell where functions were all infix/postfix.. e.g., 5 Just instead of Just 5, 5 sqrt, etc.  Would this have any obvious problems?
04:55:19 <koeien> with some experience you can though, i believe
04:55:32 <quicksilver> litb: I'd write it as sequence [createButton, flip addToParent parent, flip listenToEvents eventhandler]
04:55:32 <Cin> i'm wondering how to better express this:
04:55:34 <Cin> bracket (return ()) (\_ -> hClose h) (\_ -> handleLines ip ch h)
04:55:35 <quicksilver> if I was going to.
04:55:43 <quicksilver> but I probably wouldn't write it.
04:55:55 <quicksilver> Cin: Are you sure those \_ aren't supposed to be \h -> ?
04:56:05 <quicksilver> oh, I see.
04:56:06 <Cin> quicksilver: indeed. the handle is created elsewhere
04:56:06 <quicksilver> hmm
04:56:20 <quicksilver> handeLines ip ch h `catch` hClose h
04:56:20 <quicksilver> ?
04:56:32 <quicksilver> actually probably `finally`
04:56:33 <koeien> :t catch
04:56:35 <mbot> forall a. IO a -> (IOError -> IO a) -> IO a
04:56:39 <quicksilver> handeLines ip ch h `finally` hClose h
04:56:40 <koeien> :t finally
04:56:42 <mbot> Not in scope: `finally'
04:56:50 <quicksilver> :t Control.Exception.finally
04:56:51 <mbot> forall a b. IO a -> IO b -> IO a
04:57:04 <Cin> ah. i will look at the docs for that. thanks
04:57:07 <koeien> why isn't the second argument of finally IO () ?
04:57:19 <quicksilver> more general
04:57:26 <EvilTerran> for the same reason the first argument of (>>) isn't?
04:57:30 <quicksilver> if you allow it to return anything, and just ignore it.
04:58:08 <koeien> yes, but it is nicer to make explicit that you aren't going to return something useful
04:58:18 <koeien> by saying return () in the second argument of finally
04:58:34 <koeien> nah, it's not important
04:58:36 <quicksilver> maybe it is, maybe it isn't
04:58:41 <quicksilver> it can be annoying :)
04:58:57 <quicksilver> some "hClose-like" functions do return something, and it's just something you don't care about.
04:59:04 <quicksilver> clearly both types are an optin
04:59:10 <quicksilver> and either can be defined in terms of the other.
04:59:31 <koeien> x `finally'` y = x `finally` (y>>return() )
04:59:40 <quicksilver> right
04:59:48 <quicksilver> and conversely all you need is a type sig :)
04:59:56 <koeien> yes, the other way around is no problem
05:00:03 <quicksilver> many people have suggested that (>> return()) is a useful thing
05:00:09 <quicksilver> call it "void" or "ignore"
05:00:16 <koeien> indeed
05:00:26 <koeien> then you'll have mapM_ = void mapM and such
05:00:38 <koeien> i don't like `void' but `ignore' is nice
05:00:41 <quicksilver> although actually the implementation of mapM_ is slightly more efficient, I think.
05:00:49 * mux hopes so
05:00:50 <quicksilver> it doesn't even consider building a list.
05:00:58 <EvilTerran> also, i've heard call for a variant of (>>) that restricts its first parameter to IO ()
05:01:02 <EvilTerran> ?src mapM_
05:01:02 <mbot> mapM_ f as = sequence_ (map f as)
05:01:09 <koeien> @src sequence_
05:01:10 <mbot> sequence_ ms = foldr (>>) (return ()) ms
05:01:11 <EvilTerran> >src sequence_
05:01:14 <EvilTerran> hah
05:01:24 <EvilTerran> but i tyoped, so that's okay :)
05:01:30 <quicksilver> koeien: I quite like "skip = return ()" too
05:01:39 <EvilTerran> @src sequence
05:01:40 <mbot> sequence ms = foldr k (return []) ms
05:01:40 <mbot>     where
05:01:40 <mbot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
05:01:47 <quicksilver> koeien: makes constructs like "if foo then putStrLn "foo" else skip" look more pleasant.
05:01:53 <koeien> quicksilver: yes
05:01:56 <quicksilver> (OK, you can use 'when' for that, but that isn't the only time)
05:02:03 <Cin> :t const
05:02:05 <mbot> forall a b. a -> b -> a
05:02:05 <koeien> quicksilver: skip can be useful
05:02:13 <koeien> quicksilver: reminds me of dijkstra's GCL :)
05:02:34 <quicksilver> yes
05:02:37 <quicksilver> well that's why I use the name
05:02:45 <Cin> const is like the K combinator in SKI :P
05:02:49 <quicksilver> it's commonly used in academic mini languages.
05:03:05 <quicksilver> Cin: Correct. Can you find 'S' in haskell? :)
05:03:21 <Twey> Cin: Yo :-P
05:03:27 <Cin> hi twey
05:03:40 <quicksilver> koeien: in a similar vein 'tilt = error "Hmm. That wasn't supposed to happen"' ;)
05:03:55 <Cin> quicksilver: i haven't seen it so far ;)
05:04:03 <koeien> quicksilver: :) undefined is good enough for everybody
05:04:57 <koeien> or just spiral into infinity by using "fix id"
05:05:17 <Cin> :t fix
05:05:18 <ski_> ignore :: Functor f => f a -> f ()
05:05:18 <ski_> ignore = fmap (const ())
05:05:19 <mbot> forall a. (a -> a) -> a
05:06:52 <quicksilver> ski_: good point. I didn't think of that.
05:06:58 <koeien> generality ftw
05:07:01 <EvilTerran> Cin, what type would it be?
05:07:09 <nominolo> @pl \x y z -> x z (y z)
05:07:10 <mbot> ap
05:07:13 <nominolo> lol
05:07:33 <quicksilver> ski_: although I'm not sure it's very useful outside of at least Applicative.
05:07:34 <mux> @src (->) ap
05:07:34 <mbot> Source not found. Are you on drugs?
05:07:41 <quicksilver> @src ap
05:07:41 <mbot> ap = liftM2 id
05:07:46 <quicksilver> -- it's not a method
05:07:49 <mux> right
05:07:54 <ski_> quicksilver : could be, yes
05:08:11 <quicksilver> -- btw I hate that particular src.
05:08:11 <ski_> @type [const,return]
05:08:11 <quicksilver> should be liftM2 ($)
05:08:11 <mbot> forall a b. [a -> b -> a]
05:09:03 <koeien> :t return
05:09:05 <mbot> forall a (m :: * -> *). (Monad m) => a -> m a
05:09:08 <koeien> :t [return]
05:09:10 <mbot> forall a (m :: * -> *). (Monad m) => [a -> m a]
05:09:14 <LoganCapaldo> i like ap f a = do { g <- f ; b <- a ; return (g b) } -- sugar sugar doo doo
05:09:15 <koeien> :t [const, return]
05:09:17 <mbot> forall a b. [a -> b -> a]
05:09:24 <ski_> koeien : puzzled ? ;)
05:09:26 <koeien> yes :)
05:09:37 <koeien> ski_: indeed
05:09:52 <koeien> aw i see now
05:09:53 <koeien> :)
05:10:31 * EvilTerran prefers liftM2 (:)
05:10:44 <EvilTerran> likewise, sequence = foldr (liftM2 (:)) (return ())
05:10:49 <ski_> > (do x <- (*2); y <- (+3); return (x*y)) 10
05:10:51 <mbot>  260
05:11:11 <mux> @src [] <*>
05:11:12 <mbot> Source not found. There are some things that I just don't know.
05:11:19 <EvilTerran> er, []
05:11:19 <mux> @src [] (<*>)
05:11:19 <mbot> (<|>) = (++)
05:11:27 <mux> what the
05:11:30 <mux> mbot is high
05:11:34 <mux> or rather, hoogle is high
05:11:38 <mux> err, not
05:11:45 <EvilTerran> or even
05:11:46 <EvilTerran> ?type foldr (liftA2 (:)) (Control.Applicative.pure [])
05:11:48 <mbot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
05:11:49 <ski_> @type (<*>)
05:11:51 <mbot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:12:04 <EvilTerran> ?where lambdabot
05:12:05 <mbot> I know nothing about lambdabot.
05:12:08 <EvilTerran> ?version
05:12:09 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
05:12:09 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:12:25 <shag> is there something like a wait function that just waits x msecs or so?
05:12:32 <koeien> shag: yes there is
05:12:35 <mux> :t threadDelay
05:12:35 <koeien> shag: threadDelay
05:12:36 <mbot> Not in scope: `threadDelay'
05:12:42 <mux> grrr
05:12:42 <shag> ah, thanks
05:12:43 <koeien> :t Control.Concurrent.threadDelay
05:12:45 <mbot> Int -> IO ()
05:13:21 <Cin> evilterran: is this it? (a -> b -> c) -> (a -> b) -> a -> c
05:13:52 <ski_> that's the type of the `S' combinator, yes
05:13:57 <Cin> ski: hurrah.
05:14:38 <EvilTerran> can you think of anything with a similar-looking type?
05:15:14 <Cin> no
05:15:14 <koeien> @djinn (a->b->c)->(a->b)->a->c
05:15:14 <mbot> Unknown command, try @list
05:15:15 * ski_ gave a hint above ..
05:16:19 <EvilTerran> Cin, do you know about Reader?
05:16:25 <Cin> no
05:16:35 <ski_> (Cin : want me to restate the hint ?)
05:16:38 <EvilTerran> ?src Reader
05:16:38 <mbot> Source not found. You type like i drive.
05:16:40 <EvilTerran> hm.
05:16:43 <EvilTerran> it's a monad.
05:17:02 <EvilTerran> specifically, it's the (e ->) monad
05:17:21 <ski_> (the "environment" monad .. sometimes called the "reader" monad)
05:17:41 <EvilTerran> actions in (e ->) are thus of type (e ->) a, ie (e -> a)
05:18:11 <quicksilver> of all the monads we are aware of, the environment monad has the lowest carbon emissions.
05:18:24 <EvilTerran> so a reader "action" is just a function that takes a single value of pre-determined type
05:18:40 <ski_> quicksilver : ?
05:19:03 <ski_> (quicksilver : identity monad ?)
05:19:47 <EvilTerran> composition of two actions (with >>= or whatever) returns another action (so, another function e -> a) -- the only sensible behaviour in this case would be to "fan out" the parameter across both actions
05:21:18 <ricky_clarkson> Does Haskell have a Symbol type, or should I use strings for that?
05:21:25 <ricky_clarkson> ..like 'blah in lisps.
05:21:37 <EvilTerran> so, say, liftM2 (,) f g e = (do x <- f; y <- g; return (x,y)) e = \e -> let x = f e; y = g e in (x,y)
05:21:42 <EvilTerran> Cin, do you follow?
05:22:00 <EvilTerran> (i missed off a trailing "e" at the very end there)
05:22:19 <EvilTerran> (or, alternatively, ignore the \e->
05:22:41 <Cin> no, i don't follow that. i don't understand monads yet.
05:22:57 <mux> the key to understanding monads is to not try to understand them
05:22:58 <mux> or something.
05:23:09 <Cin> mux: that is the approach i have been taking
05:23:35 <quicksilver> ricky_clarkson: No, you should use strings.
05:23:37 <koeien> the key to understand monads is to practice with types and to recreate "standard" monads yourself
05:23:40 <EvilTerran> oh, well, never mind then
05:23:47 <koeien> e.g. State monad
05:23:51 <koeien> or a standard Parser
05:23:57 <ski_> the environment(/reader) monad is for distributing "configurations", i.e. things you don't want to explicitly pass down everywhere, but which could still vary at the toplevel
05:24:06 <mux> I think there's an infinite number of approaches to understanding monads
05:24:06 <koeien> at least, that what made me understand them (in practice)
05:24:16 <EvilTerran> the point is that something in the Reader monad, ie a value of type (Reader e a), is equivalent to a value of type e -> a
05:24:39 <ricky_clarkson> quicksilver: Thanks.
05:24:40 <EvilTerran> so you can use monad functions, reading "m" as "e ->"
05:24:52 <EvilTerran> (likewise Applicative and Functor)
05:24:56 <EvilTerran> so consider
05:24:58 <EvilTerran> ?type ap
05:25:00 <mbot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:25:05 <EvilTerran> ?type (<*>) -- similarly
05:25:06 <mbot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:25:43 <EvilTerran> if m = (e->), then ap :: (e -> a -> b) -> (e -> a) -> (e -> b)
05:25:49 <EvilTerran> ?djinn (e -> a -> b) -> (e -> a) -> (e -> b)
05:25:49 <mbot> Unknown command, try @list
05:25:53 <EvilTerran> bah.
05:26:09 <EvilTerran> there's only one sensible implementation of that, and that's the S combinator
05:26:20 <koeien> :t \f g e -> let a = g e in f e a
05:26:22 <mbot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
05:29:11 <visof> is the type of  " pair x y = (x, y) "   pair :: (a -> b) -> (a,b) ??
05:29:22 <koeien> :t let pair x y in (x,y) in pair
05:29:24 <mbot> parse error on input `in'
05:29:28 <koeien> :t let pair x y = (x,y) in pair
05:29:30 <mbot> forall t t1. t -> t1 -> (t, t1)
05:29:33 <koeien> so yes :)
05:29:36 <koeien> you could also use (,)
05:29:39 <quicksilver> no, it's not
05:29:49 <quicksilver> visof had the () in a different place.
05:29:58 <koeien> aw excuse me
05:30:22 <koeien> visof: a -> b -> (a,b) is equivalent to a -> (b->(a,b))
05:30:28 <koeien> which is different from (a->b) -> (a,b)
05:30:53 <visof> ok
05:31:17 <Cin> are functions usually defined before they appear in use in code, or the other way round, or is there no general practise?
05:31:51 <koeien> Cin: i tend to define "higher" functions before lower ones, but i can imagine either way
05:32:12 <koeien> Cin: ...being used
05:32:54 <visof> what is the type of   reverse xs == xs ??
05:33:08 <quicksilver> Cin: both methods are popular.
05:33:12 <Cin> [a] -> [a]?
05:33:18 <Cin> quicksilver: oh.
05:33:21 <quicksilver> Cin: I have not quite made up my mind.
05:33:26 <koeien> Cin: no definitely not
05:33:28 <jz1078> hello everyone, i'm not good in haskell's type system, is it possible to do this: fromConstrM arbitrary c
05:33:31 <koeien> :t reverse xs == xs
05:33:33 <mbot> Not in scope: `xs'
05:33:33 <mbot> Not in scope: `xs'
05:33:39 <koeien> :t \xs->reverse xs == xs
05:33:41 <mbot> forall a. (Eq a) => [a] -> Bool
05:33:49 <quicksilver> the type of reverse xs == xs is Bool
05:33:53 <ricky_clarkson> I've seen that you can write a Scheme in 48 hours using Haskell.
05:34:07 <quicksilver> and it only type checks under the assumption that xs :: Eq a -> [a]
05:34:08 <ricky_clarkson> Can you do the same for Smalltalk?  Does such a thing already exist?
05:34:14 <dozer> hi all
05:34:23 <ricky_clarkson> @faq
05:34:24 <mbot> The answer is: Yes! Haskell can do that.
05:34:31 <ricky_clarkson> That's my first question answered.
05:34:33 <Cin> oh. i thought he meant what is the type of reverse when it returns its argument unchanged.
05:34:56 <koeien> Cin: ow ok
05:36:13 <dozer> using xpickle from hxt on largish xml files is chewing through vast amounts of memory
05:37:08 <ski_> jz1078 : what is `fromConstrM' ?
05:37:44 <jz1078> ski_: it's from Data.Generics.Basics
05:37:47 <ski_> (s/Eq a ->/Eq a =>/)
05:42:53 <dozer> sorry, computer crashed
05:43:10 <dozer> processing a 32m xml file with hxt/xpickle is chewing through all of my 8G of memory
05:43:53 <vegai> that's rather awful
05:44:02 <dozer> yes, it is making me sad
05:44:10 <jorik808> j #hashkell
05:47:10 <sizur> HAIFA! oh yeah!
05:47:17 <pejo> dozer, malcolmw had some lazy parser combinators somewhere iirc, perhaps that could help?
05:47:52 <dozer> pejo: possibly - although I think it could be the lazyness and backtracking that's killing me
05:50:41 <dozer> I guess I should double-check that it really is xpickle that's the problem and not the xml parsing guts itself
05:56:50 <dozer> ouch - it's taking multple gigs just to parse a 32mb xml file
05:57:11 <dozer> without unpickling anything
05:57:25 <glen_quagmire> dozer: you wrote gecko in haskell
06:11:01 <hpaste>  jedbrown pasted "Constraints with rewrite rules" at http://hpaste.org/5198
06:12:16 <jedbrown> ^^^ I can't find documentation about how to do this.  Data.Array.Base explicitly states all the cases, but they don't have a type class.
06:20:53 <nominolo> @seen syntaxninja
06:20:53 <mbot> Unknown command, try @list
06:21:04 <nominolo> @slap mbot
06:21:04 <mbot> http://www.haskell.org/hawiki/HaskellUserLocations
06:21:24 <nominolo> er.  slap == map ?
06:21:37 <hpaste>  jedbrown annotated "Constraints with rewrite rules" with "a little context" at http://hpaste.org/5198#a1
06:27:16 <zerny> I would like to create a function that is parametrized by a constructor. My use is to have a: Parser a  - that would be able to parse expressions and patterns: Parser Exp and Parser Pat
06:27:42 <zerny> should i pass a function wrapping the data constructor? or are there better ways in haskell?
06:30:20 <priester> Hi! Is there any zipWith-like function that works with lists of different lenghts, i.e. using a default value for the shorter one?
06:30:59 <dcoutts> priester: if you know which one is shorter then its easy, otherwise you get to write your own (which is also easy)
06:31:29 <sizur> zerny: either i misunderstand you, or you can do that with a simple pattern matching
06:31:31 <mux> yeah, if you know which is the small list, you can just append an ifinite list of default values to it
06:31:33 <doserj> zerny: Exp and Pat are data constructors for the same data-type?
06:31:34 <mux> ++ repeat default
06:31:44 <dcoutts> priester: eg, zipWith (+) longer (shorter ++ repeat 0)
06:31:48 <priester> Hm, ok. That is an idead.
06:31:51 <priester> -d
06:31:53 <priester> Thank you.
06:31:54 * mux nods at dcoutts 
06:31:55 <zerny> doserj: no two different types
06:32:28 <zerny> I have ExpInt and PatInt depending on the occurense of the int literal
06:32:44 <sizur> zerny: function (Parser (Exp e)) = ... ; function (Parser (Pat p)) = ...;
06:32:50 <doserj> zerny: so you want sth like Parser (Either Exp Pat)?
06:33:14 <zerny> yes
06:33:56 <zerny> currently i have a parser: intLit :: Parser Exp and that should instead be intLit :: Parser (Either Exp Pat)
06:34:11 <zerny> depending on what I need
06:34:25 <jedbrown> dcoutts: Can one add constraints on a rewrite rule like I'm trying in my paste?
06:34:49 <Saizan> zerny: ah, you want the same parser to give different results depending on the context where it's used?
06:34:54 <zerny> so I have right now made: intLit :: (Integer -> a) -> Parser a
06:35:05 <zerny> Saizan: yes !
06:35:08 <zerny> :)
06:35:26 <Saizan> zerny: ok, the most natural way would be a typeclass
06:35:35 <zerny> Saizan: hmmm, ok
06:35:53 <dcoutts> jedbrown: I'm not sure if you can give class constraints. I rather suspect you cannot because at the stage rules are applied all class dictionaries have been transformed away.
06:35:53 <doserj> zerny: sth like intLit = if ... then Left <$> intLitExp else Right <$> intLitPat ?
06:35:56 <Saizan> class Foo a where constr :: SomeType -> a
06:36:00 <zerny> Saizan: I have not used haskell much so havent tried that yet
06:36:22 <jedbrown> dcoutts: Okay.  Thanks.
06:36:27 <jedbrown> dcoutts++
06:36:42 <Saizan> zerny: you'd need to give me more details for a better answer
06:36:47 <Saizan> :)
06:36:52 <mux> @karma dcoutts
06:36:52 <mbot> dcoutts has a karma of 1
06:37:00 <dcoutts> :-(
06:37:00 <mux> ah, mbot, not lambdabot :)
06:37:05 <dcoutts> oh :-)
06:37:08 * dcoutts grins
06:37:10 <mux> I suppose your karma is much higher on LB :-)
06:37:35 <zerny> Saizan: I can throw the code in a pastbin, 2 sec
06:38:19 <jedbrown> I'll tell lambdabat when she's back.  The inlinePerformIO description was very useful.
06:40:00 <zerny> can one past literal haskell in the pastebin?
06:40:55 <ski_> jedbrown :D
06:41:34 <zerny> http://hpaste.org/5199
06:41:47 <zerny> I am using the parsec lib for it
06:42:16 <zerny> the pasted code is just for parsing up integers and strings in ml
06:42:49 <zerny> I would like if the type of scon could variy by need to
06:42:50 <Saizan> ok, are you going to need other types besides integers and strings?
06:42:58 <dozer> this memory issue with hxt is turning into a bit of a show-stopper
06:43:03 <dozer> anybody got any ideas?
06:43:06 <zerny> Saizan: very likely
06:43:49 <zerny> Saizan: floats for example
06:44:20 <zerny> Saizan: but probably not more then a few
06:44:25 <Saizan> ok, i'll paste 2 ideas, one needs a little language extension
06:44:38 <zerny> Saizan: ok. Thanks a lot :)
06:45:39 <doserj> zerny: I don't think it has to be complicated. first, strCon f = liftM f stringLiteral, and you can do the same for intCon.
06:47:02 <zerny> doserj: ahh, that would get rid of the do {}
06:47:24 <doserj> so scon = ignoreSpace (ExpInt <$> intLiteral <|> ExpStr <$> stringLiteral)
06:47:40 <zerny> doserj: what lib i liftM in?
06:47:54 <doserj> liftM = fmap = <$>
06:48:10 <hpaste>  Saizan annotated "(no title)" with "h98 solution" at http://hpaste.org/5199#a1
06:48:16 <ski_> Control.Monad.liftM
06:48:23 <doserj> liftM is in Control.Monad, <$> is in Control.Applicative, i think
06:48:47 <zerny> doserj: ski_: ok, thanks
06:49:14 <Saizan> doserj: that doesn't give you any genericity
06:49:24 <doserj> yes
06:50:06 <doserj> but when you parse according to some grammar, maybe you know what you can expect :)
06:50:44 <sizur> @users
06:50:44 <mbot> Unknown command, try @list
06:52:22 <zerny> Saizan: thanks. I like that
06:52:38 <hpaste>  Saizan annotated "(no title)" with "with multiparamtypeclasses" at http://hpaste.org/5199#a2
06:52:45 <zerny> Saizan: so I would make an instance for the Exp and Pat data types?
06:52:55 <Saizan> zerny: exactly
06:53:58 <zerny> Saizan: ok. I will try playing around with that :)
06:54:43 <Saizan> doserj: well it's not like using a typeclass like this let you don't know what to expect.. it just let's you decide a bit later :)
06:54:54 <Saizan> s/'s//
06:56:01 <doserj> Saizan: yes. First you have to decide whether you need functions like strCon often enough so that it is worth defining them
06:56:23 <doserj> Saizan: then you can see whether you want to do explicit dictionary passing, or implicit via type-classes
06:59:12 <zerny> doserj: I could probably omit defining strCon. But then again most of the reason is to play with the langage a bit :)
06:59:36 <doserj> sure, having fun is always a good reason
06:59:50 <zerny> doserj: I can definitely see why using liftM in place could save some typing
07:00:25 <Saizan> you can use both solutions :)
07:01:47 <zerny> Saizan: I think i just might do that :)
07:02:46 <Saizan> strCon = fromString <$> stringLiteral
07:03:10 <zerny> Saizan: doserj: well thanks again to both of you
07:03:27 <zerny> Saizan: would `fmap` suffice too?
07:03:44 <Saizan> yes <$> is just another name for fmap
07:04:13 <Saizan> you need to give an explitic type signature to strCon though
07:04:20 <Saizan> because of the monomorphism restriction
07:04:28 <zerny> Saizan: ok
07:04:52 <quicksilver> it's actually illegal to use that phrase in this channel without an adjective
07:05:02 <quicksilver> normally 'dreaded' or 'annoying' or 'stupid'
07:05:08 <Saizan> :D
07:07:31 <osfameron> usually dreaded
07:07:55 <osfameron> I find it comes in, I put an explicit type, then a bit later, I can take the type away and everything works again
07:08:20 <Saizan> the type was monomorphic?
07:08:56 <osfameron> dunno.  still don't understand what it means :-)
07:10:52 <quicksilver> osfameron: it means something without arguments mustn't have a class context, basically.
07:10:54 <byorgey> quicksilver: how about 'evil'?
07:11:01 <quicksilver> byorgey: quite acceptable IMO.
07:11:18 <osfameron> quicksilver: what's a "class context" ?
07:11:50 <quicksilver> osfameron: (Num a) =>
07:12:02 <osfameron> ok
07:12:37 <byorgey> osfameron: the DMR applies when you have a definition of the form  foo = blah blah, i.e. foo is written in pointless form, but foo should be polymorphic.
07:12:39 <osfameron> so how come later down the chain the errors go away? because the compiler can tell from the functions that call it that the function is actually more specific?
07:12:44 <quicksilver> yes
07:12:52 <quicksilver> if it turns out that actually you only use it monomorphically
07:12:57 <quicksilver> then it infers that type
07:12:59 <quicksilver> and that's fine.
07:13:01 <byorgey> osfameron: the DMR says that foo is not allowed to be polymorphic, i.e. it is "retricted" to be "monomorphic"
07:13:13 <quicksilver> the error is only when it can't work out how to restrict it
07:13:21 <osfameron> where "monomorphic" means "operates on only one type"
07:13:23 <quicksilver> foo = 5 -- no error because of defaulting
07:13:25 <byorgey> osfameron: you can get around it by either (a) defining foo with explicit arguments, or (b) adding a polymorphic type signature.
07:13:30 <Saizan> btw, it only has to be typeclass monomoprhic
07:13:36 <byorgey> osfameron: right, monomorphic is the opposite of polymorphic.
07:14:14 <byorgey> osfameron: well, not "operates on only one type", but more like "has exactly one concrete type"
07:14:24 <pjd> or (c) -fno-monomorphism-restriction
07:14:26 <byorgey> i.e. Double -> Int -> Char is monomorphic.
07:14:45 <byorgey> pjd: good point, that too.
07:15:01 * byorgey has that in his .ghci
07:15:59 <byorgey> Saizan: hm, what does 'typeclass monomorphic' mean?
07:16:17 <Saizan> i don't know if it's the proper term
07:16:39 <Saizan> "polymorphic with a typeclass context", however
07:17:03 <Saizan> foo = map don't incur in any restriction
07:17:23 <Saizan> because map is only parametrically polymorphic
07:17:38 <oerjan> > let foo = genericLength in foo
07:17:40 <mbot>   add an instance declaration for (Show ([b] -> i))
07:17:54 <oerjan> er
07:18:01 <mrd> the value restriction arises without type-classes too
07:18:15 <byorgey> Saizan: I don't follow.
07:18:18 <mrd> it's just in place to prevent "unexpected" behavior
07:18:37 <Saizan> ?type map
07:18:38 <mbot> forall a b. (a -> b) -> [a] -> [b]
07:18:43 <quicksilver> mrd: haskell doesn't have a value restriction though.
07:18:48 <mrd> in foo = map, foo :: forall a b. (a -> b) -> [a] -> [b]
07:18:58 <mrd> to get type "forall a b. ..." you need type-lambdas
07:19:01 <quicksilver> mrd: but it does have a monomorphism restrictuion.
07:19:13 <mrd> those are automatically inserted by the type-checker/reconstructor
07:19:48 <Saizan> byorgey: i just meant that the monomorphism restriction applies only to types with a typeclass context
07:19:58 <byorgey> Saizan: oh, really?
07:20:03 <byorgey> huh, I didn't know that
07:20:04 <mrd> so you end up with foo = /\a./\b. map[a][b]
07:21:04 <mrd> in ML this is more dangerous because you could have something like: foo = print "hi"; map
07:21:38 * mux installed mit-scheme for doing experiments while doing SICP
07:21:54 <mux> I really wishes someone would write some book like SICP but with haskell instead
07:22:01 <kpreid> ML seems crazy to me.
07:22:15 <mux> err, s/doing SICP/reading SICP/
07:22:44 <shag> re
07:22:58 <czakey> @src fold
07:22:58 <mbot> Source not found. It can only be attributed to human error.
07:23:10 <czakey> @src foldr
07:23:10 <mbot> foldr k z xs = go xs
07:23:10 <mbot>     where go []     = z
07:23:10 <mbot>           go (y:ys) = y `k` go ys
07:23:12 <mrd> kpreid: that much crazier than haskell?
07:24:10 <johnnowak> mux: what would rewriting SICP in haskell give you?
07:24:13 <kpreid> mrd: yes.
07:24:27 <michael_campbell> johnnowak:  experience in haskell?
07:24:29 <mux> johnnowak: more fun while reading the book, I guess
07:24:32 <mrd> johnnowak: a headache?
07:24:37 <johnnowak> hehe
07:24:44 <mux> heh, I think all those are valid answers
07:24:45 <Saizan> byorgey: because the MR is there to assure CAF can be shared, and they are the only ones that can have different normal forms depending on context
07:25:32 <byorgey> Saizan: ah! that makes sense.
07:25:53 <byorgey> Saizan: I'd give you a ++ but it seems lambdabot is not with us... =(
07:25:55 <Saizan> s/they/the ones with a typeclass context/
07:26:02 <mrd> @botsnack
07:26:02 <mbot> :)
07:26:05 <byorgey> Saizan: right.
07:26:23 <Saizan> heh, no problem :)
07:27:09 <ski_> @botsmack
07:27:09 <mbot> :)
07:27:27 <matthew-_> bully!
07:28:21 <Syzygy-> @botsnack
07:28:21 <mbot> :)
07:28:53 <mrd> don't overfeed the bot
07:29:14 <byorgey> hi there Syzygy- !
07:29:22 <Syzygy-> Eya
07:29:56 <byorgey> congrats on your paper being accepted =)
07:29:56 <mrd> you wouldn't want to see the bot get sick all over the channel
07:30:31 <Twey> @src ord
07:30:32 <mbot> Source not found. Are you on drugs?
07:30:40 <Twey> :-(
07:30:46 <oerjan> mux: i think there are online translations of SICP to several other programming languages
07:30:48 <mrd> the guts of GHC splattered all over, with regurgitated lambdas and bits of arrows
07:30:58 <byorgey> mrd: ick!
07:30:59 <Twey> Oh, that's not even a function.  Heh.
07:31:07 <mux> oerjan: oh, cool, I'll look this up
07:31:12 <byorgey> Twey: yes it is, it's in Data.Char
07:31:35 <Twey> Data.Char.ord?
07:31:39 <byorgey> yep
07:31:44 <ski_> http://lambda-the-ultimate.org/node/1826
07:31:45 <Twey> @src Data.Char.ord
07:31:45 <mbot> Source not found. It can only be attributed to human error.
07:31:56 <ski_> (SICP Translations)
07:32:03 <doserj> ord (C# c#) = I# (ord# c#)
07:32:03 <byorgey> Twey: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#ord
07:32:08 * Twey will get the hang of this.  Some day.
07:32:12 <Twey> byorgey, thanks
07:32:26 <byorgey> Twey: as you can see, ord is sort of low-level which might be why mbot doesn't know about it.
07:32:29 <mux> ski_: cheers!
07:33:24 <sizur> finally found a decent irc client
07:33:25 <Twey> Mmm.
07:33:39 <mux> irssi?
07:33:43 <sizur> xchat
07:33:51 <Twey> irssi > xchat
07:33:52 <Saizan> irssi++
07:33:53 <mux> different tastes :-)
07:33:55 <sizur> i tried it
07:33:59 <mux> irssi is the only one I can bear
07:34:06 <Twey> XChat crashes when I use my IME
07:34:13 <quicksilver> there are different tastes, but there is absolute truth.
07:34:18 <quicksilver> and irssi > xchat is the latter :P
07:34:23 <Twey> Heh
07:34:32 * RayNbow uses mIRC 6.2 or something
07:34:38 <sizur> xchat-gnome is sucky. xchat is good
07:35:01 <osfameron> I quite like xchat-gnome too
07:35:03 <Twey> Let's all point and laugh at RayNbow.
07:35:05 <osfameron> though now I use irssi
07:35:10 <Twey> "Ha ha ha!"
07:35:12 <RayNbow> :p
07:35:27 <Axioplase> hasn't anyone written hirssi yet?
07:35:28 <RayNbow> mIRC has certain annoying bugs and lack of features
07:35:46 <RayNbow> like it cannot deal with unicode paths
07:35:49 <sizur> irssi is good, i just dont want to learn another set of shortcuts and commands
07:35:51 * oerjan actually has a beef with RayNbow's quit message ;)
07:36:03 <sizur> just sending messages is good enough
07:36:11 <RayNbow> oerjan: hmm? :p
07:36:21 <Twey> So, are there any *functional* GUI toolkits for Haskell?
07:36:37 <oerjan> by relativity theory, every point in the universe has equal claim to being the center :)
07:36:42 <ski_> Fudgets
07:36:42 <Twey> I saw wxHaskell, but it's very "where's my assignment"
07:36:43 * RayNbow also hates the fact that mIRC's tab completion replaces all unicode characters in a message with question marks
07:37:34 <Twey> ski_, looks like Motif
07:37:38 <Cin> raynbow: i didn't know mirc had real unicode support
07:37:39 <Twey> Rock and a hard place eh?
07:38:20 <RayNbow> Cin, http://home.shinnonoir.nl/mIRC-UTF8.png
07:38:22 <Cin> twey: assuming by *functional*, you mean doesn't use IO?
07:38:24 <quicksilver> Twey: there are more than you can shake a stick at.
07:38:48 <quicksilver> Twey: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
07:38:58 <byorgey> Twey: hm, I think there's also Grapefruit, and Phooey/TV/whatever conal has been up to recently...
07:39:02 <quicksilver> Twey: everything listed in the subsection 'high-level' is to some extent 'functional'
07:39:14 <Cin> raynbow: last time i tried it, i could see other people's unicode. and i could see it when i typed it in the input area. but when i hit enter the display area showed question marks
07:39:17 <quicksilver> I believe grapefruit is the only one under 'active' development.
07:39:37 <ski_> http://zemljanka.sourceforge.net/cursed/screenshots/xchat-2.png
07:40:01 <Cin> ski: what on earth?
07:40:17 <ski_> 'tis X-Chat, sir
07:40:18 <RayNbow> Cin: hmm, odd...
07:40:37 <Twey> Ooh.
07:40:39 <Cin> ski: black text on black background is for real men, right?
07:40:51 <Twey> byorgey, thanks, I had no idea there was such a profusion
07:41:07 <ski_> Cin : .. oh, i hadn't noticed that
07:41:10 <RayNbow> oerjan: all those points that claim to be the center just have to fight it out ;)
07:41:30 <byorgey> green text on a red background!? my eyes!
07:41:31 <sizur> lol
07:41:47 <sizur> my xchat looks VERY different from that
07:41:54 <Cin> byorgey: programmers are well known for their taste in aesthetics
07:41:59 <Twey> Ooh squishy.
07:42:03 <byorgey> Cin: indeed =)
07:42:15 * RayNbow uses green text on a black background for cmd.exe, ghci and hugs :p
07:42:24 <Twey> On the upside, nice background!
07:42:27 * Tac-Tics just uses pidgin and it makes him happy
07:42:34 * Twey uses white on green for everything.
07:42:48 <sizur> Tac-Tics, i had problems with pidgin
07:43:03 * byorgey prefers mauve on a tan -> orange-green gradient
07:43:23 <Tac-Tics> sizur: really? like what? (I have had mine crash on start sometimes, but I think it's something with GTK, because gimp does the same thing)
07:43:24 <Cin> mine: http://img170.imageshack.us/img170/230/yummyjc1.png
07:43:59 <sizur> Tac-Tics, like i would get silently diconnected and pidging wouldnt even figure that out to reconnect me
07:44:37 <Tac-Tics> that's strange. Pidgin's not really well suited for IRC, though. (but I'm too lazy to download and configure Xchat to my liking)
07:45:15 <quicksilver> wow. Cale gives us a big window
07:45:25 <quicksilver> my screen session is a stubborn 80 chars wide.
07:45:53 <sizur> my xchat is using pango, ts niiice
07:46:11 <Cin> byorgey: aesthetically pleasing, or nay? (full size): http://img251.imageshack.us/img251/7681/yummyxh7.jpg
07:47:03 <sizur> the wallpaper actually looks like a wallpaper heh
07:47:14 <Cin> sizur: that was my intenion :P
07:47:22 <byorgey> Cin: not too bad, though not enough color for my taste =)
07:47:43 <sizur> see, i dont like that nicks are left aligned
07:48:03 <sizur> you have a harder time to figure out where each line starts
07:49:53 <Cin> i use irssi and emacs over screen which are running on my laptop. i love screen
07:50:07 <quicksilver> yes, screen is the key.
07:50:10 <Mr_Awesome> i love lamp
07:50:19 <quicksilver> thanks to screen I can IRC from the train, the bus, the taxi, the airport...
07:50:23 <sizur> i'm looks guy. i love the idea of emacs, but it simply is ugly :(
07:50:49 <sizur> no subpixel rendering
07:50:57 <michael_campbell> sizur: emacs 23 has that, no?
07:51:02 <sizur> yeah?
07:51:03 <quicksilver> sizur: !
07:51:06 <michael_campbell> Think so.
07:51:10 <quicksilver> sizur: my emacs has subpixel rendering.
07:51:13 <ski_> emacs -nw
07:51:18 <sizur> daaang
07:51:25 <byorgey> Cin: since we're sharing screenshots... http://img338.imageshack.us/img338/5333/200801241044411280x800sow5.png  =)
07:51:30 <quicksilver> of course, it doesn't do it itself. It lets hte OS do it.
07:51:33 <quicksilver> Which is right and proper.
07:51:43 <quicksilver> it's a text editor not a compositing wm
07:51:57 <sizur> i just started with emacs a week ago, not much friendly material
07:51:59 <nominolo_> byorgey: ugh
07:52:00 <michael_campbell> sizur: maybe not; maybe it's just antialiased.  =\
07:52:06 <michael_campbell> http://norman.walsh.name/2006/08/17/emacs
07:52:14 <nominolo_> sizur: why?
07:52:30 <byorgey> nominolo_: heh =)
07:52:43 <Cin> byorgey: wow that is a lot of colour :)
07:52:57 <byorgey> Cin: yup, otherwise I can't keep everything straight.
07:52:58 <sizur> nominolo, i dont know why :P like the only subpixel emacs rendering screenie i saw was on mac
07:53:14 <nominolo_> byorgey: way too much contrast - i usually use light grey on dark grey
07:53:37 <quicksilver> why am I bright yellow?
07:53:42 <quicksilver> just random colour assignment.
07:53:50 <quicksilver> sizur: well as it happens I'm using a mac.
07:53:51 <quicksilver> :P
07:53:51 <byorgey> quicksilver: that's the color that your nick happens to hash to =)
07:53:55 <quicksilver> ah
07:53:55 <Cin> nominolo: me too
07:53:58 <Saizan> byorgey: have you resized it or you just use a "low" resolution?
07:53:59 <quicksilver> good stuff
07:54:16 <byorgey> Saizan: no, that's resized
07:54:35 <michael_campbell> Man, I love SPJ, but he goes so fast, my grey cells can't hope to keep up.
07:54:54 <byorgey> nominolo_: actually, hm, you're right, I think I would prefer less contrast too -- I just switched to irssi recently and am still tweaking things =)
07:55:25 <Cin> sizur: emacs can have nice fonts (ignore my terrible code): http://img242.imageshack.us/img242/5915/emacsrv2.jpg
07:55:26 <Twey> http://80.4.194.222/s/imgs/Images/ss/ss.jpg
07:55:30 <nominolo_> damn, i just took a screenshot, but now imageshack doesn't respond
07:55:37 <Cin> twey: huge fonts are huge
07:55:50 <Twey> Cin: Huge?  :-P
07:56:04 <Tac-Tics> so is the download
07:56:06 <Twey> Cin: Big resolution
07:56:27 <Twey> Yessirree, no skimpin' on bandwidth here!
07:56:48 <Tac-Tics> nihongo no hanashi no shiken
07:56:58 <nominolo_> sizur: http://img228.imageshack.us/my.php?image=screenshotzi7.png
07:56:59 <Twey> ãã
07:57:00 <Tac-Tics> Japanese speaking test =-D
07:57:06 <ski_> Cin : hm, nice idea with trailing `where', there
07:57:07 <sizur> Cin, that's nice, how did you do that?
07:57:18 <Cin> sizur: it's just emacs -nw inside gnome-terminal
07:57:37 <Tac-Tics> so much.... empty desktop
07:57:55 <Twey> Isn't it lovely?  ^_^
07:57:59 <Tac-Tics> it's like, you have some IRC client running and then nothing but the cold, green vacuum of space
07:58:01 <sizur> ah, overriding X and letting terminal handle the fonts
07:58:17 <Tac-Tics> Twey, you should at least sublet your desktop to the less fortunate if you're not going to be using it
07:58:24 <Cin> sizur: not so much overriding X, as much as just not using X at all and using curses
07:58:30 <Twey> Tac-Tics: I have a browser on another desktop :-P
07:58:46 <Tac-Tics> ah
07:58:52 * Tac-Tics wishes he was a bigger 'nix nerd 
07:58:53 <sizur> nominolo, how did you do yours?
07:58:56 <Cin> twey: tiling window manager: do you speak it? :P
07:59:03 <Twey> nornagon: Hahaha, emacs
07:59:14 <sizur> nominolo_, how did you do yours?
07:59:21 <Twey> Cin: No -- I get stressed out if my desktop is cluttered :-P
07:59:41 <nominolo_> sizur: emacs snapshot
07:59:46 <Saizan> Cin: which fonts, and do you have a particular antialiasing or such settings? with white on black i get much uglier borders to my letters
07:59:53 <Twey> nominolo_: Hahaha, emacs
08:00:04 <nominolo_> Twey: ?
08:00:15 <sizur> nominolo, oh that's curses too
08:00:43 <Twey> It always makes me laugh when an editor has a REPL and an IRC client :-P
08:00:58 <Cin> saizan: i am using the Monospace font. my antialiasing is whatever the default on Ubuntu Gutsy is, this is a fresh install (i'm just using emacs and irssi over ssh which are running on another computer)
08:01:09 <nominolo_> Twey: it's got so much more
08:01:11 <michael_campbell> emacs isn't an editor with those things, it is a system that happens to edit also.
08:01:12 <Twey> Good style though.
08:01:22 <Twey> nominolo_: I know, which is even funnier :-P
08:01:27 <kuribas> Twey: Emacs doesn't have a repl, it is a repl.
08:01:28 <sizur> i call emacs a thing
08:01:32 <Twey> Haha
08:01:42 <Twey> "It's this... thing... that wants to be your OS."
08:01:47 <Twey> All it lacks is a kernel
08:01:48 <BMeph> @import url(chrome://chatzilla/content/output-base.css);
08:01:48 <mbot> Unknown command, try @list
08:01:50 <michael_campbell> calling emacs an editor is like calling the space shuttle a glider.
08:02:01 <Saizan> Cin: maybe it's my nvidia card, or ubuntu has better rendering defaults than debian
08:02:10 <Tac-Tics> Emacs is a platform, like Java or i386
08:02:13 <Twey> UNIX philosophy?  What's that?  :-P
08:02:22 <C-Keen> a glider has more modern parts than a space shuttle :p
08:02:24 <Cin> saizan: while we're on the subject, i have noticed that Guty's antialiasing appears smoother than Feisty (which my laptop runs)
08:02:31 <jedbrown> sizur: emacs23 has nice fonts.  It's a bummer that didn't make it into emacs22 though.
08:02:40 <nominolo_> Cin: you can customize that
08:02:51 <sizur> jedbrown, i'll check it out. thanks
08:02:52 <byorgey> nominolo_: (re: your screenshot) hm, whatcha working on there?  looks interesting.
08:03:11 <nominolo_> byorgey: an instruction scheduler
08:03:29 <nominolo_> byorgey: for a non-standard architecture
08:03:37 <byorgey> nominolo_: cool.
08:03:37 <Cin> nominolo: i had thought so. I haven't tried it, though. if it's easy to change then i suppose they must have decided that the smoother setting is better?
08:03:39 <nominolo_> byorgey: (my MSc thesis)
08:03:46 <byorgey> nominolo_: ah, got it =)
08:03:47 <jedbrown> nominolo_: subversion isn't cool any more ;)
08:03:58 <nominolo_> Cin: no, i changed it manually, actually
08:04:15 <nominolo_> jedbrown: yeah, legacy sucks
08:04:33 <sizur> jedbrown, yeah, but you can get it free from google :)
08:04:38 <nominolo_> jedbrown: i use darcs mostly and commit once in a while
08:05:01 <zerny> Cin: you probably want subpixel-smoothing in system -> pref -> fonts
08:05:04 <Cin> darcs works fine on sourceforge, for what it's worth (not that anybody uses sourceforge anymore)
08:05:09 <sizur> can you get your own darcs space with code.haskell.org?
08:05:22 <zerny> Cin: that makes font look much better on lcd screens
08:05:27 <davidL> nominolo_: what font is that in your emacs?
08:05:32 <Cin> zerny: i'll give that a go
08:05:35 <nominolo_> Cin: bitstream-vera-sans
08:05:43 <sizur> best font
08:05:46 <mux> nah
08:05:52 <mux> dejavu > bitstream-vera
08:05:56 <sizur> nah
08:05:58 <nominolo_> Monaco on Mac OS X is even nicer
08:06:02 <mux> dejavu is like very but with a lot more scripts supported
08:06:02 * jedbrown agrees with mux
08:06:09 <mux> s/very/vera/
08:06:19 <Cin> nominolo: your low contrast is nice, but the black on grey is kind of hard to read
08:06:26 <Kekcuk> http://lostworlds.lv/go.php?1139657817 It's game!! If you enter this page you will vote for me!!(thanks too all who enter this page)
08:06:34 <RayNbow> hmm, just wondering... any Haskellers here that also play SubSpace?
08:06:42 <nominolo_> Cin: where did you see black?
08:06:45 <RayNbow> *that->who
08:07:01 <Cin> nominolo: on your emacs menu and task bar and such
08:07:26 <nominolo_> Cin: ah, right.  yes.  i think i can't change the text color in that gtk theme
08:07:40 <davidL> nominolo_: do you have a .emacs uploaded somewhere? :)
08:07:49 <Cin> nominolo: i'm guessing, then, that that isn't the ubuntustudio theme? (which, iirc, does have white colours)
08:07:58 <nominolo_> Cin: but using darker themes makes mail readers and such less usable (no i don't use emacs for mail ;))
08:08:21 <zerny> Saizan: in regard to your last proposal, I keep getting errors from ghc about setting extrea compile flags. should I just set them? (-XMultiParamTypeClasses, -XTypeSynonymInstances, -XFlexibleInstances)
08:08:37 <nominolo_> Cin: it's a customized "glossy" theme
08:08:52 <nominolo_> davidL: nope
08:09:08 <nominolo_> davidL: i've been planning to put it on my blog, though
08:09:31 <sizur> i've done the emacs tutorial, but i'm still not confy with it, any recommendations?
08:09:44 * davidL looks forward to it
08:09:51 <nominolo_> sizur: customize the hell out of it ;)
08:10:18 <nominolo_> sizur: there's lots and lots of stuff on the emacs wiki
08:10:34 <quicksilver> you haskell programmers are so naive. This is real programming: http://www.cs.utah.edu/~elb/folklore/mel.html
08:10:36 <pejo> nominolo, do you get a lot of coding done with the visible irc window?
08:10:54 <nominolo_> pejo: hehe, of course not :)
08:11:32 <byorgey> sizur: use it.
08:11:33 <quicksilver> sizur: hang out in the emacs channel, ignore the bad attitudes of some of the participants, and absorb the knowlede.
08:11:42 <nominolo_> i usually use xchat, which blinks if someone pings me and otherwise gets out of my way.  also xchat's logging is easier/better
08:11:43 <quicksilver> sizur: ask me questions, but in that channel not this one :)
08:11:53 * mux wonders if the haskell community is more emacs or more vi
08:12:00 <byorgey> sizur: the only way to get comfy with anything (especially emacs) is to just use it for a while.
08:12:15 <mux> I just can't stand emacs :-)
08:12:19 <nominolo_> mux: i think it's rather well-split
08:12:30 * byorgey slaps duct tape over mux's mouth before THAT conversation starts again
08:12:34 <nominolo_> mux: i see no clear preference
08:12:37 * mux evil grins
08:12:51 <Tac-Tics> mux: It could also be a Visual Studio community, with Haskell's MS tie-ins
08:12:55 <mux> byorgey: I think people in here are mature enough that it doesn't necessarily need to degenerate into a flamewar
08:13:19 <pejo> mux, we had a large flamewar about licenses and freedom the other day.
08:13:23 <byorgey> mux: oh, it won't degenerate into a flamewar, I just think it's a boring conversation =)
08:13:24 <nominolo_> mux: but it'll lead to nothing ...
08:13:42 <sizur> looks*
08:13:42 <sizur> zerny, yeah, put this on top of your file:{-# LANGUAGE MultiParamTypeClasses, Typ... #-}
08:14:09 * mux shrugs
08:14:25 <quicksilver> mux: we don't often have flamewars, but I think I perceive a perceptible bias towards emacs.
08:14:31 <hrehf> gnar, how do i convert a double to an int again?
08:14:34 <Cin> i used to think that emacs's shell mode was great because i could run gcc or ghc/i or whatever below my editor, but with tiling window managers like xmonad and ratpoison i can have the same effect with vim or whatever editor i use
08:14:34 <quicksilver> hrehf: round
08:14:36 <mux> quicksilver: that was my impression too
08:14:38 <quicksilver> hrehf: or ceil or floor
08:14:40 <litb> hello
08:14:42 <oerjan> @src RealFrac
08:14:43 <mbot> class  (Real a, Fractional a) => RealFrac a  where
08:14:43 <mbot>     properFraction                   :: (Integral b) => a -> (b,a)
08:14:43 <mbot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
08:14:46 <litb> anyone using eclipse and outline mode?
08:14:52 <oerjan> hrehf: pick one ^^
08:14:59 <litb> what regexp do you use for the beginning of a heading?
08:15:08 <litb> or do you have any other folding mechanism?
08:15:12 <hrehf> quicksilver oerjan, yay, thank you ;)
08:15:16 <mux> Cin: at any rate, comparing vim & emacs based on features is a dead end
08:15:22 <quicksilver> mux: I'm not very surprised; after all the kinds of things emacs appears to stand for are quite natural to haskell programmers.
08:15:26 <mux> they both have way too muchc of that :-)
08:15:31 <quicksilver> mux: having a consistent internal functional language
08:15:39 <quicksilver> mux: the reality falls short of the ideal, though.
08:15:43 * mux nods
08:15:48 <Cin> quicksilver: hence 'yi'? :)
08:15:52 <quicksilver> hence yi.
08:15:54 <litb> i could use ".+::" but that somehow doesn't look like it would work tho
08:16:02 <mux> I'm just way too used to the look & feel of vi
08:16:09 <sieni> emacs lisp with its braindead devotion to dynamically bound variables hardly counts as functional
08:16:42 <michael_campbell> here we go...
08:16:50 <zerny> sizur_: hmmm, it should work with ghci too, right?
08:17:02 <zerny> sizur_: still keep getting the errors
08:17:06 <mux> I should try yi some time, last time I did I couldn't get it to even build
08:17:18 <Cin> me neither
08:17:22 <mux> does yi allows to be customized with haskell via hs-plugins?
08:17:25 <quicksilver> yes.
08:17:34 <mux> that's definitely a kill feature ;-)
08:17:34 <quicksilver> there was a recent rather good webpage on the subject.
08:17:37 <sizur> is the network having any trouble?
08:17:51 <Cin> sizur: doesn't seem to be
08:18:08 <nominolo_> mux: yes, but GHC seems kinda buggy in that respect
08:18:23 <quicksilver> mux: http://nobugs.org/developer/yi/
08:18:27 <quicksilver> mux: gives the flavour rather well.
08:18:27 <conal> Twey: you were asking about functional GUIs?  looking for any more info?
08:18:31 <mux> quicksilver: thanks
08:18:36 <nominolo_> for example, it seems interpreted-code exceptions don't get through to compiled code
08:18:39 <mux> nominolo_: due to the GHC API changes?
08:18:52 <nominolo_> mux: and too few users/testers
08:18:59 <mux> oh, yi is emacs-like?
08:19:10 <quicksilver> in a loose sense, yes.
08:19:12 <nominolo_> mux: no, it tries to emulate both
08:19:20 <quicksilver> the default keybindings are emacs-inspired
08:19:24 <mux> that's because this web page says that
08:19:27 <quicksilver> and the architecture is much more like emacs than vi
08:19:29 <zerny> should that {-# LANGUAGE .... #-} be different in a .lhs file?
08:19:36 <nominolo_> quicksilver: depends on which config you use
08:19:39 <mux> and I'm not really hot for the escape meta alt control shift madness
08:19:48 <quicksilver> indeed.
08:20:25 <nominolo_> mux: it's intended to be unbiased
08:20:32 <mux> that sounds very good
08:20:38 <oerjan> zerny: probably needs > before it?
08:20:40 <nominolo_> mux: the real problems are somewhere else anywhere
08:20:47 <nominolo_> *anyways
08:21:10 <oerjan> (or \begin{code} if you use that)
08:22:09 <zerny> oerjan: that was it! thanks :)
08:22:40 <oerjan> :)
08:23:04 <nominolo_> the current problem with yi, is how you handle dynamic re-configuration.  XMonad dumps the state and reloads - this seems very hackish
08:23:41 <nominolo_> emacs lisp - due to dynamic typing - allows it on a per-function basis
08:24:05 <flux> I don't think it's strictly due to dynamic typing, but also due to mutability?
08:24:14 <nominolo_> that too, yes
08:24:31 <nominolo_> flux: you could do it like erlang, though
08:24:47 <nominolo_> ie., reboot parts only, not the whole system
08:25:12 <nominolo_> you might still get problems with the typechecker
08:25:28 <nominolo_> so, i'm afraid you'd need some help from the compiler
08:25:32 <quicksilver> nominolo_: hs-plugins supports the ability to dynamically load a module.
08:25:39 <quicksilver> nominolo_: is that not sufficient?
08:25:43 <quicksilver> (I haven't looked closely)
08:25:49 <nominolo_> it's a trade-off, yep
08:25:57 <flux> nominolo_, there is still the problem of hotswapping code
08:25:59 <nominolo_> me neither
08:26:31 <nominolo_> yeah.  it's certainly non-trivial (hence potentially interesting ;) )
08:27:29 <quicksilver> nominolo_: "you need some help from the compiler" <-- but this support is already there
08:27:35 <quicksilver> nominolo_: that is after all how GHCi works.
08:27:48 <quicksilver> nominolo_: and hs-plugins is something like a wrapper around that underlying functionality.
08:28:03 <quicksilver> or am I missing something?
08:28:03 <Saizan> the typing issue is resolved with a fromDyn call
08:28:16 <nominolo_> no, i mean.  if you change a type you have might have to do it atomically across multiple modules.  does hs-plugins support that?
08:28:30 <quicksilver> erm
08:28:31 <sizur> ghci is much slower though
08:28:42 <quicksilver> sizur: ? ghci is very fast, loading compiled code.
08:28:54 <quicksilver> sizur: there is zero overhead, after the initial link.
08:29:01 <quicksilver> nominolo_: Do you ned to support that?
08:29:04 <gwern> yi doesn't use hs-plugins, just ghc api. hence why it's often broken during a new ghc release
08:29:05 <nominolo_> yes, you can choose between compiled or interpreted
08:29:08 <sizur> ah right, if you compile beforehand
08:29:09 <quicksilver> nominolo_: changing of user-defined types.
08:29:17 <nominolo_> quicksilver: not immediately, but probably some day
08:29:21 <quicksilver> nominolo_: I imagine loading user code, but always to fixed types.
08:29:30 <quicksilver> nominolo_: then you have to reload all modules depending on that type.
08:29:43 <quicksilver> nominolo_: can you convince me why that's necessary, though ? :)
08:29:59 <gwern> nominolo_: and you have to admit, xmonad's method is nice and simple and reliable compared to going through the ghc api
08:30:27 <nominolo_> gwern: i think hs-plugins is also broken, atm
08:30:34 <nominolo_> (no maintainer, iirc)
08:31:01 <quicksilver> Cale fixed hs-plugins.
08:31:02 <gwern> nominolo_: no, it was updated
08:31:04 <zerny> hmm, I am a bit lost on an error for the 3 proposal on http://hpaste.org/5199#a2
08:31:12 <nominolo_> oh, good
08:31:16 <zerny> I get: Could not deduce (FromTo a a1) from the context (FromTo Integer a1)
08:31:16 <zerny>       arising from a use of `from'
08:31:16 <quicksilver> and dons is still around even if hs-plugins isn't a focus for him.
08:31:57 <nominolo_> quicksilver: dunno.  it certainly isn't as simple as in Emacs
08:32:17 <nominolo_> quicksilver: though, emacs has quite some hacks.  and emacs lisp is very old-fashioned
08:32:56 <quicksilver> nominolo_: agreed.
08:32:58 <nominolo_> but i'm not entirely convinced that a dynamically typed configuration language wouldn't be more useful
08:33:06 <quicksilver> I am.
08:33:09 <quicksilver> type safety = win.
08:33:32 <quicksilver> even the trivial examples in that blog post are 1 million times nicer than any configuration language for any other editor ever written.
08:33:40 <quicksilver> perhaps 1 million million times nicer.
08:33:52 <nominolo_> nah
08:34:05 <nominolo_> it's just more familiar to you ;)
08:35:03 <doserj> zerny: maybe adding a functional dependency like class FromTo a b | a -> b where ... helps?
08:35:33 <kuribas> nominolo_: I am very familiar with elisp, and it's still uncomfortable to write in it.
08:35:45 <quicksilver> nominolo_: No. It's beautiful that things that modify buffers are represented as exactly that.
08:35:48 <Saizan> zerny: just add a type signature :: Integer to the value you pass to from
08:35:52 <nominolo_> kuribas: yes, but you can use (require 'cl)
08:36:02 <quicksilver> nominolo_: and beautiful that the type system can guarantee that something that only modifies a buffer, only modifies a buffer.
08:36:07 <Saizan> doserj: that fundep doesn't hold
08:36:22 <doserj> true
08:36:25 <quicksilver> and therefore you can happily apply it any buffer without worrying it has buffer names hardcoded
08:36:29 <quicksilver> or some such
08:36:54 <hrehf> gnarf, and another one - how do i convert from an Int to a Double? ;)
08:37:07 <nominolo_> quicksilver: yes, but you have to re-think the whole editor API.  there are many unexplored design decisions to make
08:37:22 <nominolo_> hrehf: fromIntegral
08:37:27 <quicksilver> nominolo_: oh yes. Certainly.
08:37:33 <nominolo_> > fromIntegral 43 :: Double
08:37:34 <quicksilver> nominolo_: it's a big change.
08:37:35 <mbot>  43.0
08:37:41 <hrehf> (btw, why does hoogle not output anything no those search terms: Int -> Double?)
08:37:54 <quicksilver> nominolo_: but the type system there is so attractively natural, that I will surprised if it doesn't turn out well.
08:37:58 <nominolo_> hrehf: probably a bug
08:38:04 <quicksilver> hrehf: because it has a more general type.
08:38:11 <hrehf> hrm
08:38:15 <sizur> :t fromIntegral
08:38:17 <mbot> forall a b. (Num b, Integral a) => a -> b
08:38:18 <hrehf> hard to use it as a noob :(
08:39:06 <sizur> > fromIntegral 5 :: Double
08:39:08 <mbot>  5.0
08:39:22 <zerny> Saizan: yes, that worked. application binds tighter then type annotations?
08:39:39 <nominolo_> quicksilver: well, my stumbling point is that types might get in the way of incremental changes. but i might be wrong
08:39:51 <zerny> Saizan: don't need to answer that ;)
08:39:57 <sizur> it's because ghc does not have backtracking, you need to give type hints sometimes
08:40:00 <oerjan> hrehf: hoogle does not always deal well with type classes.  it is particularly buggy on higher-kinded ones such as monads, i think
08:40:01 <quicksilver> nominolo_: your argument only applies to changes *of types*
08:40:17 <quicksilver> nominolo_: changing a type sounds to me an unusual thing to do.
08:40:18 <mux> zerny: I think function application binds tighter than anything else
08:40:26 <Saizan> zerny: and type annotation works as it binds weaker than anything else
08:40:27 <quicksilver> nominolo_: changing code whilst keeping type constant should be fine, I thnk.
08:40:38 <nominolo_> quicksilver: depends on how specific your types are
08:40:43 <quicksilver> that's true.
08:40:44 <michael_campbell> probably a ridiculous question, but how does "nub" mean "remove dupes from a list"?  I'm having a hard time getting cognitive traction around the term "nub"
08:40:53 <hrehf> oerjan hrrrmm, any other hints on how to rtfm any better than? i just spent ~10minutes+ on BOTH type conversion questions (round/fromIntegral) without finding the answers :(
08:41:07 <hrehf> im refering to hoogle and the wikibooks, mostly, and google, ofc
08:41:09 <cjb``> michael_campbell: apparently it means "essence".
08:41:15 <nominolo_> what happens if you change data X = X Int to X Int String ?
08:41:24 <quicksilver> michael_campbell: nub: n. The essence; the core: the nub of a story.
08:41:26 <sizur> i think nub is named in honor of the generic "noob"
08:41:27 <cjb> michael_campbell: which apparently means removing duplicates :)
08:41:58 <quicksilver> hrehf: google search for "haskell convert numbers"
08:42:00 <michael_campbell> Hrm.  Ok, I'll try that for a bit.  My few remaining grey cells take a while to get moving.  =)  Thanks.
08:42:01 <nominolo_> quicksilver: that breaks code that does pattern matching, but in any case probably needs recompilation of dependent modules
08:42:07 <quicksilver> hrehf: first two hits both look reasonable.
08:42:09 <zerny> Saizan: yes. I was just irritated by the extra parenthesis. starting to look like scheme
08:42:24 <zerny> ;)
08:42:31 <hrehf> quicksilver i was searching for 'haskell type conversion' :(
08:42:37 <quicksilver> nominolo_: right. But I assert that the kind of thing you do when scripting an editor does not often involve exported types.
08:42:56 <quicksilver> nominolo_: a new local type internal to some bit of code you're writing, sure.
08:43:04 <nominolo_> quicksilver: right, but only if the interface is well-designed
08:43:13 <quicksilver> nominolo_: but your typical editor scripting doesn't even involve that.
08:43:18 <Saizan> zerny: the use of (.) and ($) can usually remove some of them, e.g. f (g (h a)) = f . g . h $ a
08:43:25 <quicksilver> nominolo_: just munging buffers or strings or ....
08:43:31 <nominolo_> quicksilver: true
08:43:53 <hpaste>  byorgey pasted "error building Yi, bytestring version problem?" at http://hpaste.org/5200
08:44:01 <doserj> quicksilver: not when you code sth like gnus in your editor
08:44:11 <byorgey> on the offchance that anyone recognizes that error and knows what I need to do to get it to compile...
08:44:17 <nominolo_> byorgey: yeah
08:44:19 <quicksilver> doserj: true.
08:44:30 <oerjan> hrehf: the haskell report is also good to know about
08:44:33 <oerjan> @where report
08:44:34 <mbot> I know nothing about report.
08:44:39 <oerjan> eek
08:44:40 <nominolo_> byorgey: you also need the latest ghc (6.8.2)
08:44:46 <sizur> @where mbot
08:44:46 <mbot> I know nothing about mbot.
08:44:46 <quicksilver> doserj: but the new types yi-gnus defined would be internal to yi-gnus.
08:44:48 <oerjan> @google haskell online report
08:44:49 <byorgey> nominolo_: yup, got it
08:44:49 <mbot> http://www.haskell.org/onlinereport/
08:44:49 <mbot> Title: The Haskell 98 Language Report
08:45:03 <quicksilver> doserj: they wouldn't be exported across the module boundary, so it wouldn't matter particularly.
08:45:10 <nominolo_> byorgey: oh, right.
08:45:17 <quicksilver> nominolo_: you're right that in some cases you're going to have to recompile multiple modules.
08:45:18 <doserj> but then I can't script yi-gnus
08:45:19 <oerjan> hrehf: in your case, the chapter on predefined types and classes
08:45:26 <quicksilver> nominolo_: but that doesn't seem like a big problem (ghci does it!)
08:45:45 <quicksilver> doserj: well, I'm speaking approximately.
08:45:54 <quicksilver> doserj: of course you want those exported so you can script ynus.
08:46:03 <quicksilver> doserj: but the point is, the yi-core won't use them
08:46:15 <quicksilver> doserj: so no need to recompile the main body of yi or the common editing code
08:46:30 <byorgey> nominolo_: any other ideas?  I tried downgrading bytestring, but it seems like vty depends on the latest version.
08:46:35 <quicksilver> nominolo_: so, I agree that you have identified an issue, btu I disagree that it's very worrying.
08:46:41 <nominolo> byorgey: hm, you seem to have a newer bytestring
08:47:14 <byorgey> nominolo: yeah, maybe I should try harder to install an older version
08:47:24 <nominolo> quicksilver: we'll see.  i'd be happy to be proven wrong here
08:47:30 <byorgey> nominolo: oh wait, I didn't recompile vty with the older version, duh
08:47:38 * byorgey goes off to try that
08:47:54 <byorgey> nominolo: what version of bytestring do you have?
08:48:18 <nominolo> 0.9.0.1
08:48:23 <byorgey> ok, good
08:48:43 <Tac-Tics> the haskell report doesn't give rigorous semantics for its type system, does it?
08:48:48 <nominolo> though, the minor number should not lead to problems
08:48:59 <Tac-Tics> (at least, not in the same thoroughness as the Scheme's spec)
08:49:04 <nominolo> byorgey: otherwise the package is incorrectly versioned
08:49:17 <nominolo> Tac-Tics: nope
08:49:23 <byorgey> nominolo: you'd think so, wouldn't you?
08:49:30 <nominolo> Tac-Tics: noone managed to fully formalise it ;)
08:49:40 <nominolo> byorgey: it's a bug if it isn't
08:49:58 <litb> mbot used to be in #math
08:50:01 <litb> is it now here?
08:50:05 <nominolo> byorgey: lemme check if i can build the latest yi version
08:50:16 <nominolo> byorgey: (though i usually use gtk)
08:50:17 * Tac-Tics still has yet to learn HM or Typed LambdaCalc
08:51:13 <nominolo> Tac-Tics: read TAPL
08:51:27 <nominolo> Tac-Tics: it's very good
08:51:28 <oerjan> @seen mbot
08:51:29 <mbot> Unknown command, try @list
08:51:56 <oerjan> litb: it's sometimes brought here when lambdabot is down for some reason
08:52:18 <Tac-Tics> for the price, it doesn't look too bad
08:53:01 <nominolo> Tac-Tics: yeah. it's pricey.
08:53:17 <Tac-Tics> Not much worse than your average Java, PHP, or Rails book though
08:53:38 <Tac-Tics> It's just when you break that $100 mark, you know the author is just trying to fundraise for his lecture classes
08:53:51 <nominolo> heh
08:53:59 <shapr`> byorgey: thanks for the comment, it's enlightening!
08:54:17 <shapr`> I'll have to ask Ed to describe the base mod number system he thought up at that same lunch meeting.
08:54:37 <byorgey> shapr`: excellent!
08:54:56 <Tac-Tics> You have the $100 books on Machine learning which contain the results of 50 years of research in AI and computer science, and the $10 books containing 2000 years worth of mathematical knowledge, same page count, but concentrated to the point it's almost dangerous to your eyes to read it
08:55:28 <byorgey> shapr`: yes, I'm not sure what a "base mod" number system would be, I'm interested
08:55:43 <Tac-Tics> oh fricking sweet! The book has a "chapter dependency chart"!
08:55:46 <Tac-Tics> That's so cool
08:55:59 <shapr`> byorgey: Ed ended up saying it was relatively useless, but I'm in the mood to collect various number systems and figure out what's cool about them.
08:56:28 <byorgey> shapr`: cool, then you should definitely check out the ones I suggested.  I can give you more detail/pointers to more info if you'd like.
08:56:31 <quicksilver> Tac-Tics: not sure I entirely understand your comparison
08:56:54 <quicksilver> Tac-Tics: haskell doesn't give a semantics to the type system, but scheme's spec does, even though scheme doesn't have a type system?
08:56:58 <shapr`> Yeah, Ed mentioned base fib, but I didn't realize it had no consecutive ones.
08:57:53 <shapr`> Tac-Tics: ooh, I want that $20 huge book!
08:58:16 <litb> damn, haskell literate mode (latex) is broken in emacs
08:58:29 <Tac-Tics> quicksilver: the type system is part of the language, and for haskell, probably the most important part. But the report is mostly just discussing the syntax, taking the details of the type system as understood
08:58:33 <sizur> alright, i need to do some integration stuff. xml, xquery, rest, soap, sql, reports. bye bye FPland
08:58:37 <Tac-Tics> which is fine if you have a background in functional languages
08:58:43 <Tac-Tics> (but I don't)
08:58:45 <shapr`> sizur: using Linq?
08:58:45 <byorgey> w00t! Yi is compiling, finally!
08:58:47 <Tac-Tics> shapr` which one?
08:58:49 <hpaste>  litb pasted "lit" at http://hpaste.org/5201
08:58:50 <quicksilver> Tac-Tics: ok, but 'semantics of type system' and 'semantics of langauge' are not the same thing.
08:58:52 <sizur> shapr, i wish
08:58:53 <shapr`> Tac-Tics: You just mentioned it.
08:58:54 <litb> isn't that the right syntax?
08:59:03 <shapr`> sizur: linq is not so bad as FP goes.
08:59:07 <shapr`> I'm using it in C#
08:59:10 <quicksilver> Tac-Tics: 'semantics of a type system' is where you give a denotation to types and prove properties about it.
08:59:32 <sizur> cli is not our platform unfortunately
08:59:43 <sizur> i'd use f# then!
08:59:45 <quicksilver> Tac-Tics: nonetheles the answer is "Nobody has written down the semantics of haskell but that's OK because most people know what it would be, if we did :)"
09:00:10 <quicksilver> Tac-Tics: it has an "obvious" translation to system Fc which does have a formal semantics.
09:00:12 <shapr`> We were talking about a new app yesterday, and my direct boss said "We want to write in such a way that we don't have to call Captain Haskell whenever it breaks." meaning, use C#, not Haskell.
09:00:22 * byorgey does the "Yi works!" happy dance =D
09:00:27 <byorgey> nominolo++
09:00:31 <Tac-Tics> I'm not criticizing it, I'm just frustrated about how hard it is to find accessible literature on HM and STLC =-)
09:00:35 <shapr`> yay yi!
09:00:53 <Tac-Tics> yayi!
09:00:56 <byorgey> "-- This buffer is for notes you don't want to save, and for haskell evaluation"
09:01:01 <byorgey> those words make me so, so happy.
09:01:04 <nominolo> byorgey: nice.
09:01:15 <Tac-Tics> byorgey: I haven't figured out how to get it to eval haskell in that buffer yet
09:01:24 <nominolo> byorgey: but ... does haskell evaluation work?
09:01:29 <Tac-Tics> I don't think the keymap is in place, or at least, it's not C-j like in Emacs
09:01:41 <Tac-Tics> you can use M-x to do straightup eval in the minibuffer though
09:01:55 <Tac-Tics> M-x <RET> gotoLn <RET> 10 <RET>
09:01:58 <benny99> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Least_Fixed_Point <- is anybody able to explain that fix-function to me ?
09:02:05 <byorgey> nominolo: in the end, I had to downgrade bytestring to 0.9.0.1, recompile vty with that version, and unregister a bunch of newer versions of regex-blah that depended on the newer bytestring, so yi could find the older ones.
09:02:14 <shapr`> byorgey: Is that yi with the latest ghc?
09:02:26 <pejo> Tac-Tics, there's plenty of free stuff available on HM. TAPL is well worth its money, and has a chapter on the simply typed lc.
09:02:33 <nominolo> byorgey: oh.  hm.
09:02:33 <dcoutts> byorgey: ah yes, the fun of inconsistent package deps
09:02:37 <byorgey> I also had to make sure I was using Cabal 1.2.3 instead of 1.3.3.
09:02:46 <byorgey> shapr`: yup!
09:02:53 <nominolo> dcoutts: but it was bytestring 0.9.0.4 vs 0.9.0.1
09:02:54 <dcoutts> see http://hackage.haskell.org/trac/hackage/ticket/131
09:02:58 <byorgey> dcoutts: 'fun' is one word for it... ;)
09:03:01 <nominolo> dcoutts: that shouldn't happen
09:03:01 <dcoutts> nominolo: yes, exactly.
09:03:06 <dcoutts> it certainly can
09:03:16 <sm> better Captain Haskell than Baron C#
09:03:25 <benny99> fix f = let x = f x in x <- that's it - and I don't get how to get that factorial function by using it
09:03:32 <nominolo> but a difference of 0.0.0.3 should not lead to problems, can it?
09:03:56 <dcoutts> nominolo, byorgey: see http://hackage.haskell.org/trac/ghc/ticket/1839#comment:7
09:04:12 <dcoutts> nominolo: they're totally different types (though with the same representation)
09:04:14 <Tac-Tics> pejo: "Accessible", in this context, I guess means "the wikipedia page isn't so good for HM and, unlike monads, it doesn't have any layman's tutorials within the blogsphere"
09:04:32 <byorgey> > let facr f n | n <= 1 = 1 | otherwise = n * f (n-1) ; fac = fix facr in fac 6
09:04:34 <mbot>  720
09:04:37 <Tac-Tics> but I'm definitely buying that book
09:05:02 <dcoutts> nominolo: it might as well be foo:Data.ByteString.ByteString and bar:Data.ByteString.ByteString , how do you know that they are the same type?
09:05:12 <benny99> Tac-Tics: what book ?
09:05:16 <nominolo> dcoutts: i see
09:05:55 <dcoutts> nominolo: so, cabal-install should handle this by always buildin (or rebuilding) things so we get consistent package deps.
09:05:56 <Tac-Tics> @where tinyurl
09:05:56 <mbot> I know nothing about tinyurl.
09:05:59 <nominolo> dcoutts: yeah.  so a package is in fact by its version and the versions of all its dependencies it's been linked to
09:06:03 <shapr`> byorgey: awesome!
09:06:06 <dcoutts> it's not a totally trivial problem
09:06:18 <shapr`> @paste
09:06:18 <mbot> Haskell pastebin: http://hpaste.org/new
09:06:21 <Tac-Tics> http://tinyurl.com/375w9r
09:06:23 <Tac-Tics> that book
09:06:31 <shapr`> hmm, hpaste is broken?
09:06:33 <shapr`> !paste
09:06:33 <hpaste> Haskell paste bin: http://hpaste.org/
09:06:36 <shapr`> aha
09:06:42 <shapr`> Don't need to restart that process then.
09:06:57 <nominolo> dcoutts: great.  more karma points to earn by solving it!
09:07:10 <byorgey> shapr`: no, seems to be working fine
09:07:14 <dcoutts> nominolo: right, the nix functional approach would be to install as many copies of a single package version, each with different versions of its deps
09:07:47 <kuribas> Is Either not a member of MonadPlus?
09:07:57 <nominolo> we could re-build, but we need all the sources and it might break
09:07:58 <pejo> Tac-Tics, have you read "Basic Polymorphic Typechecking" by Luca Cardelli?
09:08:47 <dcoutts> byorgey: would you like to report your war story on http://hackage.haskell.org/trac/hackage/ticket/131
09:09:22 <dcoutts> byorgey: before you forget the details. Having a real world example of how easy it is to get into that situation and how confusing it is would be very useful for persuading people it's a real problem.
09:10:04 * nominolo -> bbl
09:10:14 <Tac-Tics> pejo: nope
09:10:14 <dcoutts> nominolo: yes, either multiple versions or rebuild existing versions. We should at least be able to detect the situation.
09:10:16 <oerjan> > Left "maybe" `mplus` Right "or not?"
09:10:19 <mbot>  Right "or not?"
09:10:26 <oerjan> kuribas: seems so
09:10:32 <dcoutts> nominolo: and that requires a ghc-pkg dump feature, which we'll get in ghc-6.8.3
09:10:45 <oerjan> however, the type in Left must have an Error instance
09:10:59 <kuribas> oerjan: I forget it is part of Control.Monad.Error
09:11:07 <pejo> Tac-Tics, or the book by SPJ, http://research.microsoft.com/%7Esimonpj/Papers/slpj-book-1987/slpj-book-1987.pdf
09:11:36 <byorgey> dcoutts: sure.
09:11:43 <dcoutts> byorgey: thanks
09:12:22 <quicksilver> shapr`: captain haskell comment makes me sad.
09:13:01 <byorgey> dcoutts: hmm, I'm not sure if that ticket describes exactly what my problem was.
09:13:12 <byorgey> dcoutts: I had problems *downgrading* things, not upgrading
09:13:16 <dcoutts> byorgey: it's closely related I think
09:13:24 <byorgey> dcoutts: but maybe it should be the same mechanism?
09:13:27 <byorgey> dcoutts: yeah, ok
09:13:27 <dcoutts> byorgey: it's all about inconsistent sets of dependencies
09:13:53 <dcoutts> byorgey: there are various ways of setting up such a situation
09:14:21 <dcoutts> in the end you're building a package that uses two others which have been built against inconsistent versions of a common third
09:14:21 <byorgey> dcoutts: ok, right.
09:14:51 <Tac-Tics> spj's book I have read through the first half or so of it
09:14:57 <Tac-Tics> it was a very interesting read
09:15:22 <Tac-Tics> some day, I'm going to sit down and actually read the whole thing =-)
09:18:58 <pejo> Tac-Tics, look at chapter 8/9.
09:19:27 <Tac-Tics> I read it after only a month of haskell, so near the middle and end, it confused the hell out of me
09:20:11 <Tac-Tics> but the whole enriched lambda calculus was fascinating. Analytical, but since it's SPJ, very clear and readable
09:22:48 <RayNbow> crap, that book is 458 pages?
09:23:17 <Tac-Tics> In FP, is the way to decide if a function is Primitive Recursive through it's type?
09:23:51 <quicksilver> Tac-Tics: no.
09:24:05 <quicksilver> Tac-Tics: it's not easy to decide that type-theoretically.
09:24:12 <byorgey> dcoutts: how's that?
09:24:14 <johnnowak> does haskell offer anything like symbols in scheme? are string literals guaranteed to be interned?
09:24:17 <quicksilver> q.v. dependent types, turing completeness, structural recursion, etc.
09:24:19 <Tac-Tics> how does one decide it in FP then? Just form?
09:24:20 <quicksilver> johnnowak: no. no.
09:24:32 <quicksilver> Tac-Tics: normally one doesn't decide it.
09:24:47 <oerjan> Tac-Tics: no unless you have a very different type system...
09:24:48 <Tac-Tics> johnnowak: Use an Enumerated type
09:24:52 <oerjan> *not
09:24:58 <Tac-Tics> What if you wanted to test for it? How would one do it?
09:25:00 <johnnowak> Tac-Tics: aye, that's what i figured.
09:25:04 <johnnowak> thanks
09:25:07 <quicksilver> I'm not sure if ghc ever interns.
09:25:11 <dcoutts> byorgey: ta
09:25:19 <quicksilver> I think it might guarantee they are shared.
09:25:41 <quicksilver> but I'm sure it doesn't use some alternative more efficient storage.
09:25:52 <johnnowak> right
09:25:59 <oerjan> quicksilver: i think it interns small Chars
09:26:04 <dcoutts> g'evening SyntaxNinja :-)
09:26:06 <oerjan> but not entire Strings
09:26:44 <quicksilver> oerjan: I think all constants end up lifted to the top level and therefore shareable and, in fact, shared.
09:26:47 <quicksilver> oerjan: but I"m not sure.
09:26:53 <dcoutts> SyntaxNinja: you may have noticed a huge flood of cabal ticket changes. I'm planning a Cabal-1.4 release to support a cabal-instal release.
09:27:05 <quicksilver> oerjan: in fact, I have a vague memory that common suffixes are even shared.
09:27:10 <quicksilver> oerjan: [] is shared, certainly.
09:27:13 <quicksilver> ;)
09:28:12 <oerjan> quicksilver: i recall reading somewhere that the first 256 Chars (ISO-8859-1) are interned
09:29:37 <quicksilver> oerjan: *nod* I think you're right there.
09:29:48 <quicksilver> oerjan: I was thinking of the spine too, not just the actual cells.
09:30:04 <quicksilver> easy enough to check with a quick dump-simpl
09:30:25 <quicksilver> just compile foo="foo";afoo="afoo";notherfoo="foo";
09:30:30 <quicksilver> I don't have tiem this second :)
09:31:35 <RayNbow> hmm
09:31:50 <RayNbow> my university's library seems to have the book by SPJ
09:31:51 <ddarius> quicksilver: That wouldn't allow O(1) comparison.
09:32:17 <quicksilver> ddarius: well actualy it would.
09:32:26 <quicksilver> ddarius: but the == instance for String would have to be smart.
09:33:18 <quicksilver> ddarius: I think 'interned' is a slightly ambiguous and could mean different things to different people.
09:33:33 <quicksilver> ddarius: I'm not sure if the == instance for strings is specialised to cheat, but clearly it could.
09:35:43 <quicksilver> ddarius: although I note that O(1) string comparison is overrated
09:35:52 <quicksilver> it only matters if you expect to be comparing a string to itself, a lot.
09:38:48 <ddarius> The Eq instance for String is the Eq instance for lists in general.  It doesn't use pointer equality.
09:38:57 <ddarius> (Not even as a performance hack.)
09:40:15 <dozer> does darcs ever get into a loop? I've been waiting for over 2 hours for a set of patches to apply
09:41:30 <quicksilver> ddarius: but it could.
09:41:32 <quicksilver> ddarius: ghc could choose to hack it.
09:41:33 <johnnowak> dozer: yes... darcs is known for taking absurdly long times on occasion
09:41:44 <dozer> ok, I will go eat tea
09:41:45 <quicksilver> ddarius: god knows GHC includes some other awful SPECIALISE hacks :)
09:42:07 <sm> dozer: you should read the faq.. that tea might be longer than you think
09:42:13 <quicksilver> dozer: darcs is suspected to contain non-termination or super-exponential behaviour.
09:42:18 <quicksilver> although nobody knows for sure.
09:42:25 <quicksilver> and darcs2 might fix it!
09:42:26 <quicksilver> maybe.
09:42:26 <sm> sure, they now
09:42:28 <sm> know
09:42:36 <quicksilver> sm: do they? which is it, then?
09:42:51 <quicksilver> actualy non-termination or just a super-exponential blow up?
09:43:21 <sm> (super)?exponential, I believe I read
09:43:28 <sm> there are good docs
09:44:57 <sm> but I should remember what channel I'm on and say I don't know the answer to your q :)
09:49:13 <RayNbow> if anyone wants to laugh: http://reddit.com/r/programming/info/66h05/comments/ + http://jimbojw.com/wiki/index.php?title=Defending_PHP
09:51:57 * BMeph roots for the other team when folks go defending PHP
09:53:07 <vincenz> RayNbow: I love the comment " I don't like PHP because it's not statically typed (like my beloved Java)
09:53:11 <vincenz> "News flash: static typing sucks - deal."
09:55:19 <ddarius> This is the typical "static typing = Java"
09:55:31 <RayNbow> vincenz: yeah, I rolled my eyes when I read the whole post :p
09:56:03 <RayNbow> http://mindblind.net/2008/01/24/attacking-php/ <-- a reply to the PHP defense post :p
09:56:11 <moonlite> i followed the link to this article: http://www.coderoshi.com/2007/09/5-reasons-static-typing-sucks.html
09:56:16 <moonlite> also pretty bad. :/
09:57:01 <jedbrown> Is the only difference between mallocForeignPtr and mallocPlainForeignPtr that you can't associate a finalizer with the latter?  Is there a performance difference?
09:57:05 <sizur> yeah, i'm pretty pleased with xchat interface.
09:57:45 <Lemmih> Heh, the 'strpos' argument is nice.
09:57:51 <Lemmih> jedbrown: Not really.
09:58:02 <vincenz> RayNbow: HAHA
09:58:05 <RayNbow> moonlite: I haven't read that one yet, but I have several browser windows open at the moment :p
09:58:07 <vincenz> RayNbow: exactly same format
09:58:57 <jedbrown> Lemmih: Thanks, I'll stick with mallocForeignPtr then.
09:59:01 <BMeph> What's a static-type framework, and why does he act as if it's difficult to develop and use one?
09:59:10 <RayNbow> "I am against being forced to statically type everything in a language when it is not always necessary" <-- oh lol... :p
10:00:20 <BMeph> Trying to get the objections to static typing from the followed link: http://www.coderoshi.com/2007/08/curve-is-circle.html
10:00:21 <therp> please don't make fun of PHP programmers. that's just not political correct.
10:01:01 * BMeph goes back to pointing in the bathroom mirror, and saying, "I'm not slow, YOU're slow!"
10:01:34 <sizur> i don't care for political correctness, but nobody should be making fun of anybody. php, imperative, synamic, whatever
10:01:58 <vincenz> BMeph: my god this guy writes a lot of crap
10:02:00 <sizur> a/synamic/dynamic/
10:02:05 <sizur> bah
10:02:18 <RayNbow> therp, I think it should be okay to make fun of PHP programmers... as long as you try to convert them into good Haskellists :p
10:02:21 <BMeph> vincenz: LOL! ;)
10:02:30 <Lemmih> sizur: Sure we should. It's called social incentives.
10:02:55 <sizur> Lemmih, it's incentives to start a vendetta
10:03:00 <vincenz> BMeph: paraphrase "I'm losing an argument, but actually, y'know, I'm not really losing, it's a circle, cause everything's Zen, so I must be winning"
10:03:56 <BMeph> vincenz: It's not that I don't understand your argument, it's, uh, my knowledge on the topic is so great, that I now know nothing about it! ;p
10:04:24 <vincenz> BMeph: :D
10:04:25 <sizur> it's the same position that lispers take
10:04:44 <faxathisia> next on programming.reddit, "Who's as a better coder, Abelson or Sussman?"
10:04:52 <vincenz> BMeph: another quote "Sure, you can declare the importance of your fugly girlfriend's sparkling personality - but who cares if I'm out dating supermodels?"
10:05:00 <vincenz> BMeph: from another article
10:05:04 <Cin> no one can question the sussman's excellence
10:05:08 <Lemmih> sizur: And capitalistic societies ends up with the greedy owning everything?
10:05:17 <vincenz> BMeph: for someone claiming Zen, that's rather superficial
10:05:32 <sizur> Lemmih, where did that come from? :)
10:06:04 <sizur> i'm definitely not 'equal rights' activist
10:06:19 <vincenz> faxathisia: let's have a real argument "What's proper typing, Haskell way or Contracts way"
10:06:20 <Lemmih> sizur: Economic incentives and social incentives are two sides of the same coin.
10:07:13 <sizur> Lemmih, incentive is positive, show them why haskell is good, not why you think they are stupid
10:07:28 <Lemmih> sizur: A fine for drunk driving is pretty much the same as drunk driving being socially unacceptable.
10:08:55 <sizur> Lemmih, there is earth-sky difference betweek Haskell and PHP. Yet PHP has much bigger products than Haskell does. I think they have grounds to laugh at us
10:09:25 <Lemmih> sizur: And so they should.
10:10:13 <sizur> Lemmih, alright, if you take that position, that's ok :)
10:10:31 <sizur> as long as you can take it, not only dish out
10:11:38 <Lemmih> (:
10:18:29 <jedbrown> Lemmih: How is the alignment condition checked?  I can't find any mention of the alignment in the code.
10:19:00 * jedbrown needs to be sure his ForeignPtr arrays are 16-byte aligned.
10:19:12 <Lemmih> jedbrown: I don't know. I think you have to do that yourself.
10:20:55 <dylan> heh, I wonder if this would be useful in explaining lazy evaluation: "The Tao abides in non-action, Yet nothing is left undone."
10:21:14 <jedbrown> When you mallocForeignPtr, I assumed that you get alignment as good as the Storable instance demands, but mallocForeignPtrArray calls mallocForeignPtrBytes which calls newPinnedByteArray# and the alignment information disappears.
10:21:28 <jedbrown> Lemmih: How would I ensure the alignment?
10:21:52 <jedbrown> Lemmih: Use alignPtr and keep that offset around to index off of?
10:22:39 <Lemmih> jedbrown: ptr + ptr `mod` alignment.
10:23:31 <Lemmih> jedbrown: Oh yeah, alignPtr looks good.
10:24:01 <sizur> Lemmih, thing is that there is no functional dependency between conversion rate and intimidation. one can create more resistance (unless that's the goal)
10:25:23 <jedbrown> So malloc a little extra, use alignPtr, then somehow get a new ForeignPtr?
10:28:44 <Lemmih> jedbrown: That would work, I think. Although, it would seem weird if 'mallocArray' didn't already do this.
10:28:45 <sizur> although, after reading the defence, i have a hard time not laughing myself
10:29:35 <dcoutts> jedbrown: newPinnedByteArray# will always align to word size (ie 4 or 8 bytes depending on your arch)
10:31:39 <jedbrown> Lemmih: It looks like mallocArray does not either.  It uses sizeOf to call mallocBytes, but not alignment.
10:32:22 <Lemmih> dcoutts: Where do I get the merged cabal-setup/cabal-install?
10:32:45 <dcoutts> @where cabal-install
10:32:45 <mbot> I know nothing about cabal-install.
10:32:48 <dcoutts> bah
10:32:49 <dcoutts> http://darcs.haskell.org/cabal-install/
10:33:04 <dcoutts> Lemmih: ^^
10:33:07 <Lemmih> Thanks.
10:33:24 <dcoutts> See also http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:33:51 <jedbrown> dcoutts: if it needs to be 16-byte aligned, can I somehow get the new aligned pointer back into a ForeignPtr?
10:33:52 <dcoutts> Lemmih: bug reports and patches gratefully accepted :-)
10:34:26 <dcoutts> jedbrown: just mallocForeignPtr and adjust the Addr#
10:34:47 <dcoutts> @src ForeignPtr
10:34:47 <mbot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
10:35:05 <davidL> @version
10:35:05 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
10:35:05 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:35:31 <davidL> hm, didn't know lambdabot worked with 6.8
10:35:57 <jedbrown> dcoutts: Is that Addr# actually the pointer?
10:36:23 <dcoutts> jedbrown: yes, the ForeignPtrContents is the link to the ByteArray# heap object for the GC.
10:36:50 <dcoutts> jedbrown: so the Addr# can be changed without loosing the reference to the heap object
10:36:57 <jedbrown> dcoutts: Okay cool.  Thanks again.
10:36:58 <Lemmih> jedbrown: I'd call mallocArray and turn it into a ForeignPtr. Messing with #'s can be tricky.
10:37:47 <jedbrown> Lemmih: mallocArray is actually C malloc though.
10:39:07 <Lemmih> jedbrown: Hm, right.
10:39:31 <jedbrown> Lemmih: To used pinned memory, I think I have to adjust the Addr#.
10:46:24 <Cin> is putStrLn threadsafe? or: is there a simple way to do thread-safe printing to stdout?
10:46:31 <litb> is there any paste site for snippets >5k ?
10:48:30 <dcoutts> Cin: do you mean you want it to not interleave with other output?
10:48:37 <Cin> dcoutts: yes
10:48:59 <dcoutts> that's no guaranteed since the [Char] is evaluated lazily
10:49:16 <dcoutts> but you can get around that if it's important
10:49:33 <Cin> dcoutts: well, i don't want my output getting merged together
10:49:45 <dcoutts> basically by evaluating it first and putting in one go
10:50:11 <dcoutts> Cin: eg B.put . B.pack
10:50:26 <r_rehashed> haskell did sink into my head after all. i remember it after having glanced thru it a year ago. :D
10:50:26 <Cin> what is B?
10:50:40 <dcoutts> for a strict ByteString (import qualified Data.ByteString as B)
10:50:46 <Cin> ah
10:51:07 <vincenz> or use an mvar and flush
10:51:35 <vincenz> dcoutts: B.put is atomic?
10:51:40 <dcoutts> Cin: yes, or use a single thread to write to the Handle as vincenz suggests
10:52:04 <Cin> dcoutts: well i considered doing that. but then i'd have to pass something around, wouldn't i? like an mvar or a channel or whatnot
10:52:13 <dcoutts> vincenz: yes, I think so. I think it holds the Handle's lock for the duration.
10:52:16 <vincenz> putStrLnPar s = withMvar (... .)
10:52:26 <vincenz> or some such
10:52:31 <dcoutts> Cin: that's no harder than passing a Handle :-0
10:52:42 <Cin> well, passing anything
10:53:13 <dcoutts> Cin: oh you're writing to stdout so you get to cheat and not pass the 'global' handle
10:53:19 <vincenz> topMVar = unsafePerformIO (createMVar)
10:53:37 <vincenz> {-# noinline topMVar #-}
10:53:43 <vincenz> or whatever the syntax is :)
10:53:46 <vincenz> dcoutts probably knows better
10:54:00 <dcoutts> global vars are evil :-)
10:54:10 <vincenz> dcoutts: what do you call stdout?
10:54:12 * Cin forgets writing to stdout
10:54:17 <dcoutts> vincenz: evil :-)
10:54:21 <vincenz> :D
10:54:43 <dcoutts> it's a process scope variable, that should be explicit.
10:55:31 <vincenz> maybe we need something like
10:55:35 <dcoutts> there is no global, there is always an enclosing scope
10:55:38 <vincenz> globalIOTableAdd ...
10:55:59 <faxathisia> litb, I think rafb can take it
10:56:07 <vincenz> Something like a central registry
10:56:18 <dcoutts> vincenz: so long as that takes the Process value that you're given by main :: Process -> IO (), then that's fine :-)
10:56:53 * vincenz sighs
10:56:58 <vincenz> my latest haskell functon is 136 lines long
10:57:32 <vincenz> with like severe nesting of where's and case () of's
10:59:19 <litb> faxathisia: it doesn't support haskell, too bad. but i've made emacs to export it as html: http://www.johannes-schaub.de/wnm.hs.html
10:59:22 <litb> :D
10:59:47 <faxathisia> Looks nice
10:59:58 * faxathisia tries to understand this
11:02:33 <litb> faxathisia: i'm sorry that it isn't english commented :)
11:03:45 <litb> the three nearly identical lines at the very bottom look ugly, but i don't know how i can cut them down
11:04:01 <faxathisia> seems fine to me
11:04:19 <faxathisia> I don't think reptition is as bad as people claim
11:07:50 <litb> faxathisia: well, i don't like it :)
11:08:11 <shapr`> quicksilver: Most people consider Haskell academic & therefore useless.
11:08:14 <shapr`> sadly
11:08:18 <litb> hmm
11:08:26 <litb> i feel the pain with you
11:08:50 <jedbrown> Lemmih, dcoutts: Thanks a bunch, the aligned memory is working great!
11:08:53 <shapr`> Happily, I did get to do Haskell for a living for more than a year.
11:09:10 <shapr`> And I'll be back to the academic community in some years, once I have enough degrees to start publishing papers.
11:09:36 <shapr`> Or I could just start publishing papers now... edwardk has enough unpublished goodies to keep me busy for years.
11:09:49 * araujo thinks shapr` should instead start his own Lambda Consulting
11:10:09 <litb> o.O
11:10:20 <shapr`> Today at lunch we were talking about Blume's MLPolyR stuff where polymorphic records and polymorphic variants are duals.
11:10:24 <litb> i want to eat all lambdas and become the lambda guru
11:10:39 <shapr`> litb: do it!
11:12:53 <faxathisia> PTSs gotta catch em all :P
11:13:28 <monochrom> I think the tide has turned. Even on reddit, people have to put up a significant effort to argue against Haskell.
11:13:31 * litb takes the fork and eyes shapr` 
11:13:55 <shapr`> litb: There are many lambdas, do it!
11:14:14 * sjanssen thinks lambdas are more of a finger food
11:14:18 <monochrom> Recall that just ten years ago there was nothing to argue over. :)
11:14:39 <ksandstr> doesn't vocal opposition imply success, though?
11:14:49 <monochrom> Yes! I'm saying that.
11:14:52 <Cin> ksandstr: i think that's what monochrom is saying
11:15:12 <ksandstr> ah. I thought it was like, haskell is now on its way to obscurity...
11:15:43 <shapr`> monochrom: even seven years ago...
11:15:46 <litb> when does the next haskell std come out?
11:16:05 <dons> ?bot
11:16:05 <mbot> :)
11:17:09 <dons> ?bot
11:17:09 <mbot> :)
11:17:17 <lambdabot> :)
11:17:32 <dons> mbot: @part #haskell
11:17:43 <monochrom> A shootout between the two bots? "which one runs faster"? :)
11:17:46 <sjanssen> litb: unknown, I think.  Haskell' seems stalled
11:17:52 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
11:17:54 <Lemmih> Why is lambdabot so unstable? Buggy code or buggy hardware?
11:18:12 <cjb> surely code.
11:18:12 <dons> currently it looks like the server kills it off
11:18:24 <dons> so there's new instability created by moving to a virtual host
11:18:34 <dons> that wasn't there when running the same code on a dedicated machine
11:18:49 <dons> lambdabot gets terminated with predjudice when it uses too many resources
11:19:15 <allbery_b> fwiw my (somewhat older) LB seems to have a memory leak
11:19:28 <Lemmih> dons: Will moving it to a dedicated box help?
11:19:29 <allbery_b> I set heap to 50M, it generally lasts around a week for me
11:19:34 <dcoutts> dons: the code.h.o server is not very well speced
11:19:54 <dcoutts> at least not in terms of cpu/memory
11:19:55 <dons> Lemmih: almost certainly
11:20:02 <dcoutts> it's ok for disk and bandwidth
11:20:08 <monochrom> How come it uses too many resources?
11:20:13 <dons> the disappearences of the last few days are to do withit being killed
11:20:28 <dons> its in lots of channels, monochrom
11:20:30 <sizur> poor lambdabot
11:20:35 <nominolo> can't you use two linked processes?
11:20:44 <cjb> to restart it?
11:20:55 <nominolo> would be a nice exercise in fault-tolerant systems :)
11:20:59 <cjb> well, you could just use a cron job to see if it's dead and restart it.
11:21:14 <nominolo> no, you can get a signal when your process dies
11:21:17 <Lemmih> dons: Hand me your public key and I'll give you an account on my dedicated box.
11:21:30 <nominolo> then take over and respawn a new one
11:21:32 <cjb> but yes, there are also linked-process methods.  I think the canonical one is termed "Robin Hood and Friar Tuck".
11:21:35 <sjanssen> @flush
11:21:41 <ksandstr> how does an irc bot run out of resources anyhow? memory leak (in a haskell program, blasphemy)?
11:22:02 <dons> it doesn't run out. but the new server kills things that are a bit big
11:22:08 <nominolo> ksandstr: unix just kills processes arbitrarily
11:22:25 <cjb> unix does no such thing.
11:22:29 <ray> lies!
11:22:36 <ksandstr> nominolo: an OOM killer being triggered is the same as running out of memory, essentially
11:22:37 <dcoutts> dons: have you tried to monitor its resource use? it'd be interesting to know how big it really is
11:22:54 <dons> oh,its over 100M at least
11:23:00 <dons> when in lots of big channels
11:23:08 <dcoutts> ah, and the box is only 512 iirc
11:23:23 <dons> ah
11:23:37 <dcoutts> MemTotal:       524288 kB
11:23:43 <nominolo> ksandstr: it just needs to be more than the virtual system is configured to use
11:24:41 <dcoutts> dons: currently lambdabot is behaving, 1.8% of memory 11Mb virtual and 9Mb resident
11:25:09 <dcoutts> dons: why would it ever grow to 100M? what large state does it accumulate?
11:25:27 <ksandstr> 100 megabytes for an irc bot smells like a memory leak. 20 channels by 400 people by 1 kilobyte each would still be just 8 megs
11:26:16 <monochrom> Perhaps all our @remember killed it. :)
11:26:39 <ptolomy> Anybody know where I can find an example of something that uses cabal userhooks to run tests?
11:27:00 <dcoutts> ptolomy: there are hardly any examples :-(
11:27:26 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/215
11:27:28 <lambdabot> Title: #215 (Overhaul support for package's tests) - Hackage - Trac
11:28:34 <dons> dcoutts: bugs :)
11:28:48 <dcoutts> dons: ah is that all :-)
11:29:09 <dons> its aa large, complicated, ad hoc conglomerate of gravel
11:30:28 <sjanssen> dcoutts: I had an idea about tests recently -- what if Cabal added a test stanza, similar to the executable stanza?
11:30:56 <dcoutts> sjanssen: add your ideas to the ticket above
11:30:57 <shapr`> cjb: Hi! Think you'll have time to meet? Or should I just wait until the Hacking Haskell thing?
11:31:10 <dcoutts> sjanssen: see the ideas about possible requirements
11:31:11 <sizur> > 100*10^6 `div` (60*60*24) -- bytes per second leaked if it reaches 100megs in a day
11:31:13 <lambdabot>  1157
11:31:40 <dcoutts> sjanssen: I'd like to see something that allows automatic collection of test results and HPC
11:32:16 <ksandstr> is there some way to debug memory leaks in haskell? kind of like valgrind tags every allocation by malloc call site.
11:32:16 <sjanssen> dcoutts: checking the exit code isn't good enough?
11:32:41 <dcoutts> sjanssen: no, I want to know from the hackage page if it's got tests and if they pass, and what the test coverage is
11:33:07 <dcoutts> sjanssen: eg, xmonad has 100% coverage, that info should be published automagically on the hackage page
11:33:56 <sjanssen> dcoutts: well, the exit code can answer the simple "if they pass"
11:34:08 <dcoutts> sjanssen: if they all pass, yes.
11:34:35 <dcoutts> sjanssen: how many platforms does ghc's testsuite pass all tests? not many. there's usually one or two failures.
11:34:48 <sjanssen> dcoutts: I think that plus a text buildlog is enough -- anything else seems like overengineering to me
11:35:07 <sjanssen> dcoutts: true.  But how many behemoths like GHC are on hackage? :P
11:35:18 <sjanssen> dcoutts: we should look at what CPAN does
11:35:27 <dcoutts> but it's not enough to get useful info out that can be presented in any form other than just a build log. That's not useful for a hackage summary page or for stats.
11:35:41 <dcoutts> sjanssen: yes, that would be a good reference, or gems or rpm.
11:35:43 <dons> ksandstr: yeah, use the profiling tools built into the compiler
11:36:20 <shapr`> Anyone else going to Hacking Haskell at MIT at the end of January?
11:36:35 <ksandstr> dons: ah, thanks. of course. now that I read the manual it seems so obvious.
11:36:47 <dcoutts> shapr`: Haskell at MIT? I thought they were lisp all the way down?
11:36:49 <dons> shapr`: MIT??
11:36:58 <dons> shapr`: url plz!
11:37:00 <shapr`> http://stuff.mit.edu/iap/#hackhaskell
11:37:00 <lambdabot> Title: SIPB IAP 2008 Activities
11:37:24 <cjb> dons: During January, MIT students take elective courses given by random people on random subjects.
11:37:34 <shapr`> Gregory Price has some connection with Oleg, so it should be interesting.
11:37:35 <dons> shapr`: is it a summer course?
11:37:45 <dons> cjb: ah right. we did the freiburg hackathon as one of these
11:37:46 <cjb> in this case, it's short talks given by a student computing society member
11:37:57 <cjb> dons: it's two hours * two talks.
11:38:10 <cjb> I just finished going to one Haskell course that was one hour * three talks.
11:38:16 <shapr`> Of course, with me and edwardk in the room, some heckling may be involved.
11:39:07 <shapr`> cjb: Should I give up trying to hang out with you before that? :-)
11:39:18 * RayNbow would like to see more cool Haskell lectures in the Netherlands...
11:39:29 <cjb> shapr`: heh, perhaps
11:39:44 <shapr`> It is very near, fortunately.
11:40:17 <cjb> odd, when I do "runhaskell Setup.lhs install" on cabal-install HEAD, I just see:
11:40:19 <cjb> Installing: /usr/local/bin
11:40:20 <cjb> #
11:40:44 <dcoutts> cjb: is that odd?
11:40:56 <cjb> it doesn't seem to have put anything in /usr/local/bin
11:41:03 <cjb> so I suppose it is.  :)
11:41:07 <dcoutts> ok, that is odd then :-)
11:41:11 <dons> cjb: ok. cool
11:41:11 <dcoutts> try -v3
11:41:50 <cjb> Oh, it did work.  I was expecting to have a cabal-install binary.
11:42:12 <cjb> hm.
11:42:14 <cjb> cabal: ghc version >=6.4 is required but it could not be found.
11:42:21 <cjb> pullcord:cjb~/pkg/cabal-install % ghc
11:42:21 <cjb> ghc-6.8.2: no input files
11:42:41 <hpaste> Run-time type error, aborting
11:42:51 <shapr`> yipes
11:43:52 <cjb> Okay!  Getting somewhere now.
11:43:56 * shapr` worries about hpaste
11:43:59 <cjb> I may yet be able to hack on Yi today.  :)
11:44:35 <shapr`> yay yi!
11:44:51 <michael_campbell> newbie here; what's Yi?
11:45:02 <dcoutts> cjb: why couldn't it find ghc?
11:45:16 <cjb> dcoutts: $PATH, my fault.
11:45:22 <dcoutts> cjb: ok
11:45:38 <dcoutts> cjb: if/when you do find bugs in cabal-install, report them in the hackage trac
11:45:45 <dcoutts> http://hackage.haskell.org/trac/hackage
11:45:47 <lambdabot> Title: Hackage - Trac
11:45:50 <jfredett> michael_campbell: its a text editor like emacs or vi, but written in haskell
11:45:56 <jfredett> and more importantly, extensible in haskell
11:46:09 <jfredett> IIRC it has key bindings for both emacs and vi
11:46:15 <dcoutts> cjb: the bug tracker is also linked via the cabal homepage
11:46:19 <michael_campbell> jfredett: Gotcha, should have looked it up before I asked.  FIrst hit on google.  =)  Going to look more closely now.
11:46:23 <cjb> dcoutts: Thanks.
11:46:29 <shapr`> and more like emacs, in that the editor is easy to reach into and customize at run time.
11:46:31 <cjb> dcoutts: Is there a Cabal FAQ?
11:46:47 <jfredett> lol, its pretty neat, i haven't had a great deal of time to mess with it
11:46:47 <dons> hpaste: ?
11:46:49 <cjb> dcoutts: Wondering where I should look to find an answer to:
11:46:51 <jfredett> but it looks cool
11:46:53 <cjb>     Could not find module `Distribution.Setup':
11:46:53 <cjb>       it is a member of package Cabal-1.2.3.0, which is hidden
11:46:56 <dcoutts> cjb: there's a user guide and a dev wiki, no faq
11:46:58 <dons> glguy: "hpaste> Run-time type error, aborting" what the?
11:47:01 <shapr`> I can't figure out if devstudio does anything like that *grumble* I can't even find a hex editor in devstudio!
11:47:16 <dcoutts> cjb: see http://haskell.org/haskellwiki/Upgrading_packages
11:47:17 <dons> shapr`: its cool how yi has progressed since the hemacs days :)
11:47:28 <dcoutts> cjb: yeah, that should be in a FAQ
11:47:29 <shapr`> very much so!
11:47:34 <shapr`> I'll have to try it on win32
11:47:41 <shapr`> Oh wait, does hs-plugins work on win32?
11:48:23 <gwern> does anyone know who 'Thomas JÃ¤ger' is?
11:48:30 <cjb> dcoutts: Huh.  Does this mean that Yi needs to be updated?
11:48:43 <dcoutts> cjb: yes. perhaps we should start a Cabal FAQ on http://haskell.org/haskellwiki/Cabal
11:48:57 <dcoutts> cjb: it's trivial, see the page I linked
11:49:00 <cjb> dcoutts: sounds good, but I'm still flailing around too much to be able to answer many questions :)
11:49:24 <cjb> dcoutts: yes, reading it.  If someone could tell me where Distribution.Setup lives now and when it moved, I could prepare a patch to Yi.
11:49:26 <dcoutts> cjb: the answer in this case was the link I pasted :-)
11:49:44 <dcoutts> cjb: Distribution.Simple.Setup, but the content has changed too
11:50:13 <cjb> Sorry, which link -- Upgrading_Packages or Cabal?
11:50:20 <dcoutts> Upgrading_Packages
11:50:56 <cjb> Thanks.
11:51:30 <dozer> haskell-cafe seems to think that my performance issues with parsing xml with hxt may be due to parsec being slow
11:51:50 <earthy> parsec is not truly slow
11:52:42 <dozer> but can it chew through massive amounts of memory?
11:52:54 <dons> hey earthy.
11:53:00 <faxathisia> bindings to AsmXml :P
11:53:08 <dons> dozer: i bet its to do with [Char] being used strictly :)
11:53:15 <yoshi> how would one test to see if a string contains a character that is not an integer ?
11:53:39 <dozer> yoshi: look up 'any' on hoogle
11:54:00 <dozer> dons: how would I go about checking that?
11:54:03 <vincenz> @hoogle any
11:54:03 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
11:54:03 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
11:54:03 <lambdabot> Data.Foldable.any :: Foldable t => (a -> Bool) -> t a -> Bool
11:54:17 * jfredett points at vincenz, "Like that"
11:54:18 <jfredett> :)
11:54:24 <dons> dozer: see if its processing incrementally. feed it a 10M file and watch if it falls over
11:54:36 <cjb> Bah.  With Yi HEAD:
11:54:37 <jfredett> or going to haskell.org/hoogle
11:54:38 <dozer> dons: it makes my pc fall over with a 30 meg file
11:54:43 <cjb> pullcord:cjb~/pkg/yi % runhaskell Setup.hs configure --prefix=/usr/local
11:54:43 <cjb> Setup.hs:25:35:
11:54:43 <cjb>     Couldn't match expected type `Verbosity'
11:54:43 <cjb>            against inferred type `Flag Verbosity'
11:54:48 <dozer> dons: and I have 8 gigs to play with
11:54:54 <earthy> hiya dons. ;)
11:55:00 <ptolomy> if I have "data Foo !Int String \n makeFoo i = Foo i (show i) \n someFunction i = return $! (makeFoo i)".. will the String field be evaluated? (I'm trying to use laziness as a way of memoizing and encapsulating conversions, but I don't know if I'm accidentally forcing conversions)
11:55:21 <jfredett> ?paste
11:55:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:55:26 <jfredett> past the code there
11:55:27 <sjanssen> ptolomy: no, it won't be
11:55:32 <jfredett> paste*
11:55:33 <jfredett> :)
11:56:20 <ptolomy> Thanks. Ah, just found the relevant wiki page. neato.
11:56:21 <gwern> cjb: unfortunately, yi's build process is a little more than fragile w/r/t cabal, because it needs to pull out information about GHC
11:56:46 <cjb> gwern: Ah.  Got any hints?
11:56:50 <gwern> and cabal changes quickly; which is good, but not so good for apps depending on fiddly details
11:56:58 <gwern> cjb: change cabal versions :)
11:57:07 <cjb> ok.  what to?
11:57:13 <cjb> I'm on HEAD.
11:57:37 <gwern> Cabal-1.2.3.0 works fine for me
11:59:24 <cjb> same error with Cabal-1.2.3.0, looks like.
11:59:43 <gwern> cjb: are you sure you are actually using 1.2.3.0?
12:02:03 <cjb> I just ran make install with 1.2.3.0, but I'm not sure I'm using it.
12:02:33 <dozer> dons: should I look at getting hxt to use ByteString?
12:05:26 <dejones_> Hello, I'm considering eventually doing my Doctorate, possibly in programming language design / compilers, are there any Universities in Europe that you guys would recommend?  Preferably in Switzerland or Germany...
12:05:36 <cjb> gwern: Any idea how I find out which version of Cabal a running ghc/ghci is using?
12:05:49 <cjb> dejones_: Haskell in particular?
12:06:24 <cjb> I'd find a compiler/language that I like and look at which universities are doing research with it, I guess.
12:06:35 <mrd> ITU just put out a call for PhD students
12:06:35 <cjb> most universities are doing a reasonable amount of academic CS.
12:06:43 <cjb> ITU's in Sweden, right?
12:06:57 <cjb> Denmark, sorry.
12:07:14 <cjb> I've actually been there, so it's not grossly insensitive of me to mix them up.  I hope.  :)
12:07:32 <cjb> ITU's CS building is lovely.
12:07:42 <dejones_> cjb: Possibly Haskell, but I am new to Haskell, so I am not certain.
12:07:54 <dejones_> mrd: where is ITU?  what is the full name?
12:08:11 <cjb> http://www1.itu.dk/sw5211.asp
12:08:12 <lambdabot> Title: Front Page - IT University of Copenhagen
12:08:35 <dejones_> cjb: thanks
12:09:03 <dejones_> cjb: Is ITU a good university?  ;)
12:09:11 <pejo> dejones, check the types-announce mailing list for people looking for phd students and similar.
12:09:17 <dejones_> I was looking at ETH Zurich...
12:09:18 <cjb> I dunno about that, but look at the photo, the architecture is awesome :)
12:09:34 <dejones_> cjb: yeah, definitely cool architecture. :)
12:09:35 <pejo> dejones, ETH Zurich is good too. There's lots of good places in europe for the stuff you want to do.
12:09:36 <cjb> there are all these pods coming out at different widths from the wall
12:09:52 <lispy> dejones_: australia has a nice type theory/haskell group...in think in sydney...ask dons (not Europe, but still nice)
12:10:04 <dejones_> lispy: thanks for the info.
12:10:15 <dcoutts> cjb: Distribution.PackageDescription.cabalVersion
12:10:22 <dejones_> I'm trying to stay to bigger cities bc my gf is moving with me and she is a chemical engineer, so she has to be able to find a job in the same city...
12:10:24 <dcoutts> > Distribution.PackageDescription.cabalVersion
12:10:30 <lambdabot>      Not in scope: `Distribution.PackageDescription.cabalVersion'
12:10:32 <dcoutts> bah
12:10:47 <cjb> ah, 1.3.3.
12:11:20 <dcoutts> cjb: or cabal --version
12:11:20 <pejo> dejones, chalmers should put out their "yearly" call for phd students soon too. Some people in this channel from there.
12:11:35 <dejones_> I saw that the Clean language is looking for PhD students, but that is in the Netherlands...
12:11:41 <mrd> http://www1.itu.dk/sw38325.asp
12:11:41 <lambdabot> Title: Application package - IT University of Copenhagen
12:11:53 <cjb> dcoutts: wait, isn't it cabal-install that provides that cabal binary?
12:11:59 <dejones_> pejo: Chalmers?
12:12:01 <yoshi> >any ((<= fromEnum 0)||(>= fromEnum 9)) "1a2b3c"
12:12:05 <pejo> dejones, something wrong with netherlands?
12:12:08 <pejo> dejones, www.chalmers.se
12:12:13 <mrd> http://www.itu.dk/research/pls/wiki/index.php/PhDtopics
12:12:15 <lambdabot> Title: PhDtopics - PLSwiki
12:12:16 <dcoutts> cjb: yes.
12:12:35 <dejones_> pejo: well, I'd like to stick to bigger cities so my gf can find a job, she's a chemical engineer.
12:12:47 <daniel_larsson> Gothenburg is a fairly big city :)
12:13:12 <cjb> dejones_: ITU's in Copenhagen.
12:13:31 <dejones_> cjb: yah, I was talking about where Clean is at in the Netherlands.
12:13:31 <jedbrown> dcoutts++ (Thanks again, big speedups.)
12:13:56 <dejones_> daniel_larsson: which university is in Gothernburg?
12:13:59 <mrd> i would think about applying to ITU but I don't think I qualify.  also I'm waiting on apps here already.
12:14:00 <dejones_> * Gothenburg
12:14:01 <daniel_larsson> chalmers
12:14:07 <dejones_> daniel_larsson: thanks
12:15:42 <davidL> would someone be willing to check to see if I've done problem 124 on projecteuler? I lost my usb key with my passwords :( ...my username is DavidLazar
12:18:01 <vincenz> what's the the typical license for hackage packages
12:18:13 <mrd> probably BSD is most common
12:18:26 <ac> davidL: not a Projecteuler member, but I hope your passwords were encrypted
12:18:28 <mrd> or MIT-X
12:18:40 <mrd> and before someone chimes in, I mean BSD sans advertising clause
12:18:52 <davidL> ac: they were, thankfully
12:19:28 <byorgey> davidL: I'm looking...
12:19:41 <byorgey> hm, it's not easy to find information about other users on PE =P
12:19:53 <davidL> I'm number 471 on top 1000 :-\
12:21:08 <byorgey> ah, ok, that helps...
12:21:22 <dejones_> wow davidL.  I was just starting to work on problem #1 ;)
12:21:27 <eugman|work> I know there's a tutorial for making an irc bot. Are there libraries available for whatever would be require to make a bot that runs on aim? I don't know what's actually needed to work on that protocol.
12:21:31 <dejones_> davidL: how long have you been working on those problems?
12:21:31 <byorgey> hm, there's still no way to see which problems you've solved
12:22:04 <byorgey> dylan: with a manageHook ?
12:22:11 <byorgey> sorry, mischan
12:22:13 <davidL> dejones: I started ~9 months ago, but I'm on and off, haven't done a new problem in around 2 months
12:22:20 <mrd> eugman|work: network library?
12:22:30 <davidL> byorgey: really? you used to be able to
12:22:43 <byorgey> davidL: I know, the interface seems to have changed
12:22:51 <byorgey> it's kind of dumb
12:23:01 <davidL> that's a shame
12:23:12 <eugman|work> mrd, is that all that's needed? I would guess so but I don't know.
12:23:16 <dancor> can searchpath be made to also install to the system the libraries it downloads
12:23:31 <mrd> eugman|work: i'd imagine. do you know the spec?
12:23:35 <cjb> Ah, I didn't know about setup.lhs unregister/register.  that's why I had the older Cabal being searched for.
12:23:43 <davidL> byorgey: what's a fun problem you've recently done?
12:24:08 <dejones_> I wish there was a huge listing of universities and their current research areas....
12:24:21 <dejones_> that would really help me find a university to do my doctorate.
12:24:30 <mrd> most universities do a large amount of things...
12:24:39 <byorgey> davidL: #169 is pretty cool
12:24:51 <dejones_> mrd: well, they could have a huge list... searching would be easy.  :)
12:25:06 <dejones_> I guess the hard part would really be for them to maintain the list.
12:25:09 <cjb> yeah.  most universities do programming language research.
12:25:37 <davidL> byorgey: interesting, thanks
12:25:46 <byorgey> davidL: sure =)
12:25:50 <dejones_> cjb: yeah, I'm trying to find a good combination of larger city, with good quality of life, good university, and programming languages research.
12:26:36 <dejones_> well, and in Europe, so I can travel to the rest of Europe.  :)  Oh yah, grad program in English! haha
12:27:22 <cjb> dejones_: I did my undergrad in Manchester, it's a huge student town.
12:27:24 <byorgey> eugman|work: no, for an aim bot you need to implement the aim protocol (I think it's called oscar)
12:27:45 <cjb> But I wasn't really interested in academic CS at the time.
12:27:47 <dejones_> eugman|work: byorgey is correct, it is called oscar.
12:27:50 <davidL> > [a+b | [a,b] <- replicateM 2 (map (2^) [0..100]) ]
12:27:52 <lambdabot>  [2,3,5,9,17,33,65,129,257,513,1025,2049,4097,8193,16385,32769,65537,131073,2...
12:28:22 <dejones_> cjb: Hmm, I guess I should specify mainland Europe so I travel is easier?  ;)
12:28:24 <eugman|work> YeahI thought I'd have to implement something like that. Anyone know how complex it is?
12:28:50 <dejones_> eugman|work: I think there may be libraries available that you could use, although they are probably written in C.
12:29:58 <eugman|work> Good idea, I'll take a look into it. I was thinking of making an irc bot for a big project and if I can get the same program working  with aim that'd be neat.
12:30:50 <davidL> byorgey: did you do this one in haskell or C?
12:31:35 <lispy> davidL: to answer your darcs question (if you didn't see my answer) there is no published darcs api in haskell
12:31:46 <lispy> davidL: but, it is something pretty much everyone agrees would be nice
12:31:53 <dejones_> eugman|work: I'd check the jabber.org page, they have libraries for AIM to work with jabber.
12:32:20 <lispy> davidL: and I think the current structure is such that it wouldn't be hard to do
12:32:26 <eugman|work> K, thanks
12:32:54 <byorgey> davidL: a few lines of haskell =)
12:32:54 <mrd> dejones_: really you want to find professors that you would like to work with
12:33:03 <eugman|work> Also, does anyone know if there is an interpreter or compiler that works for windows and could be run off a thumbdrive?
12:33:03 <jedbrown> dejones_: I'm at ETH ZÃ¼rich.  I do numeric analysis, so I'm not so familiar with the CS department.
12:33:25 <davidL> lispy: thanks, I saw droundy say in the mailinglist a few years ago he'd work on one if someone had a real need for it and I think I've come up with a real need :)
12:33:41 <dejones_> mrd: yah, just have some other limitations, such as the gf needing to be able to find a chemical engineering job.
12:33:46 <lispy> davidL: cool, what is your need?
12:33:48 <dejones_> jedbrown: how do you like ETH Zurich?
12:34:10 <lispy> davidL: do you have the darcs source handy?
12:34:11 <davidL> lispy: I'd like to make a wiki type thing with a darcs backend
12:34:11 <dejones_> jedbrown: do you like Zurich in general?
12:34:23 <jedbrown> dejones_: quite well.  The train system is great.
12:34:39 <lispy> davidL: ah, that would be cool.  You might be able to cheat and invoke darcs as a subprocess though :)
12:34:48 <dejones_> jedbrown: yah, I've heard that.  I'd love to be able to use the trains to travel throughout Switzerland and Europe.  :)
12:34:50 <jedbrown> dejones_: I'm not really interested in the city itself, but that's just me.
12:35:02 <dejones_> jedbrown: what are you interested in?  ;)
12:35:06 <lispy> davidL: look at the test suite for examples of using darcs in an automated way.  Also, I wrote a program for a class that uses darcs as a subprocess.
12:35:07 <jedbrown> dejones_: Switzerland is tiny compared to Alaska (my home).
12:35:12 <davidL> lispy: I have a tarball handy, but I have no means of compiling it since I'm stuck on a crappy school computer
12:35:25 <davidL> ah neat
12:35:27 <jedbrown> dejones_: Mostly climbing in the mountains.
12:36:08 <lispy> davidL: okay, well if you look in src/Darcs/Commands those basically use the rest of darcs like a library
12:36:19 <dejones_> jedbrown: Ah yes, that would be awesome.  :)
12:36:48 <jedbrown> dejones_: Alaska's are bigger and offer more new routes, but the access is so much better here.
12:36:58 <lispy> davidL: to make a darcs api, you could probably just make it so that each of those commands has an interface that you can compile against
12:37:10 <davidL> lispy: could those simply be pulled out into their own libdarcs package?
12:37:31 <lispy> davidL: I think so, yeah...just be mindful of the makefile
12:38:21 <lispy> davidL: it could be really handy, especiallyif darcs just becomes the cannonical instance of libdarcs
12:38:46 <cjb> gwern: Is there a version of regex-base that both works with Yi and with GHC 6.8?
12:39:04 <sjanssen> davidL: you'll probably want to move darcs over to a cabal system if you want libdarcs
12:39:11 <cjb> You'd think so, but 0.93 is too new and 0.71 doesn't know where Data.ByteString went.
12:39:15 <davidL> right
12:39:34 <lispy> sjanssen: unless cabal is as general as autoconf/make that's going to be painful
12:39:51 <sjanssen> lispy: Cabal can use configure scripts
12:40:07 <lispy> sjanssen: ah, that is good
12:40:10 <sjanssen> lispy: I doubt you use that much from make?
12:40:36 <lispy> sjanssen: quite a bit of string substitution is used to generate various targes
12:40:38 <lispy> targets*
12:40:39 <davidL> thanks again lispy, I'll look into it further when I get home
12:40:48 <lispy> davidL: you're welcome
12:40:54 * sjanssen thinks darcs configure scripts are unholy anyway, but I've argued with droundy about that before :)
12:41:17 <lispy> sjanssen: well, the truth it, it tries to work on many different platforms/setups
12:41:35 <lispy> sjanssen: and, without using an unholy mess, it's hard to target all the different subtleties
12:42:07 <lispy> otoh, as cabal matures, maybe it won't be so bad to use cabal
12:42:35 <sjanssen> lispy: my argument is that version based compatibility (Cabal supports this now) is saner than the "if this code compiles, use it" model that darcs (and all autoconf stuff) uses
12:44:09 <sjanssen> lispy: I also argue that GHC < 6.4 support is useless :)
12:44:15 <lispy> sjanssen: probably the best way to convince droundy is to create a parallel build system and demonstrate the supperiority then
12:44:35 <lispy> iirc, 6.4 is the oldest supported version because of type hackery now used
12:44:44 <pejo> sjanssen, so you're arguing against the entire model that autotools uses - detect features, not versions?
12:44:59 <sjanssen> pejo: yeah, I don't like it too much
12:45:08 <cjb> gwern: finally got past configure, and on build:
12:45:11 <cjb> Setup.hs: Package yi-0.3 can't be built on this system.
12:45:12 <sjanssen> pejo: I know that there are good arguments for it
12:45:49 <cjb> oh, I see in the README
12:46:24 <sjanssen> lispy: we've debated it before -- we just have different opinions
12:46:24 <pejo> sjanssen, what are the arguments for detecting versions instead?
12:46:46 <sjanssen> (functionality tests vs. version tests, as pejo notes)
12:47:58 <sjanssen> pejo: for one, it is very clear which build hack applies to which compiler version
12:48:23 <sjanssen> you can remove the hacks after that version is no longer supported
12:48:30 <litb> i've an idea
12:49:05 <litb> how can i see what type a function F expects? is that something for pattern matching?
12:49:11 <sjanssen> for example, I bet darcs still has GHC 6.2 (and older?) compatibility hacks in the configure scripts even after 6.2 support has been dropped
12:49:28 <sjanssen> litb: you can use :type at ghci
12:49:35 <byorgey> litb: you mean at run time?
12:49:38 <sjanssen> :t head
12:49:43 <lambdabot> forall a. [a] -> a
12:50:01 <litb> an, nvm
12:50:29 <pejo> sjanssen, so the argument is basically about the cost of carrying around legacy code.
12:50:59 <litb> i need to iterate of the elements of a tuple
12:51:01 <sjanssen> pejo: yeah, that's part of it
12:51:15 <lispy> :t zipWith
12:51:16 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:51:25 <lispy> :t unzip
12:51:26 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:51:37 <lispy> litb: those might be of use
12:51:52 <Botje> anybody use unzip much?
12:52:00 <sjanssen> pejo: it also sucks to ship the same 2000 line shell script with every source package
12:52:15 <sjanssen> pejo: and we haven't even mentioned Windows compatibility yet
12:52:37 <litb> i have this: ((bisektionMethode, (0, 2)), (sekantenMethode, (0, 2)), (newtonMethode, 2)) and the idea is that i iterate over all three and call them with some arguments and (snd P) (P is the element) .
12:54:33 <pejo> sjanssen, I don't have any real experience with software maintainance on Windows, so not going to comment there. The shipping of "configure" is essentially free though, it's writing and maintaining configure.ac that carries a cost. As a system administrator I prefer software that uses portable tools I'm familiar with though, even if the tools themselves have a few warts.
12:54:40 <lispy> litb: I think I still don't understand your example
12:54:59 <mfp> litb: this might help if you're looking for a general method
12:55:07 <mfp> http://www.brics.dk/RS/01/10/
12:55:08 <lambdabot> Title: Do we Need Dependent Types?
12:55:33 <sjanssen> pejo: true, I dislike the 'configure' script for purely aesthetic reasons
12:55:36 <litb> thxx
12:55:50 <litb> does anyone successfully use lhs2Tex ?
12:56:26 <sjanssen> pejo: the Windows compat issue is that it simply doesn't ship with /bin/sh
12:56:41 <litb> it seems to be unable to break text if it is too long . it just cuts it off (i generate a pdf with pdftex)
12:57:23 <olsner> "just open ghc.sln and press build" ;-) would be nice for those windows users
12:57:37 <cjb> Hey, is there support for using Unicode symbols in ghc source?  For example, could I use a Unicode lambda symbol instead of typing \?
12:57:54 <sjanssen> pejo: I don't think Cabal adds significantly more baggage for an administrator -- it's been packaged with GHC since 6.4 and maintains compatibility with all platforms GHC runs on
12:58:02 <cjb> I know I could just tell emacs to show me one thing and save another, but I'd rather ghc was awesome about it.
12:58:21 <sjanssen> cjb: you can't use Unicode lambda because it is a lower case Greek character
12:58:53 <cjb> sjanssen: And so it would be unfair to Greek writers to reserve it in GHC, you mean?
12:59:02 <sjanssen> cjb: exactly
12:59:22 <sjanssen> cjb: correction, you can use it, but not as a standin for \
12:59:37 <byorgey> litb: I've used lhs2TeX.
12:59:44 <cjb> sjanssen: Makes sense.
12:59:57 <byorgey> litb: what text is it cutting off?
12:59:58 <pejo> sjanssen, oh, I'd never argue that it is a beautiful solution, I'm merely saying that it can be coerced into working properly. As for Cabal - then perl has CPAN, PHP has whatever the name is, ruby another, and so on. Life quickly gets complicated.
13:00:53 <dylan> well, unlike ruby's package system, cabal plays well with others.
13:00:57 <sjanssen> pejo: isn't this a good thing?
13:01:10 <litb> byorgey: i can put the pdf on my site so that you can look into it
13:01:22 <litb> byorgey: especially, long "strings"
13:01:36 <sjanssen> pejo: it is better to have the build logic in one package than implementing it (incorrectly, probably) in N different projects?
13:01:57 <litb> the problem is, it has large page borders, so the program code starts somewhere at the middle of the page (horizontally) and then the text that is too long is just cut off
13:02:06 <litb> byorgey: i will make a screenshot
13:02:12 <dons> ?users
13:02:12 <lambdabot> Maximum users seen in #haskell: 436, currently: 432 (99.1%), active: 18 (4.2%)
13:02:19 <byorgey> litb: oh, I see, it's the typeset code that gets cut off
13:02:51 <byorgey> litb: line-wrapped code looks ugly
13:03:42 <pejo> sjanssen, so you want to sell Cabal to the perl community? :-)
13:04:13 <sjanssen> pejo: absolutely not.  Perl and Haskell have different needs, so we have different tools
13:04:15 <litb> byorgey: is there a way around that?
13:04:31 <byorgey> litb: make your code shorter.  or use a smaller font.
13:04:39 <litb> byorgey: see this: http://img86.imageshack.us/my.php?image=snapshot48jx6.png
13:05:12 <litb> byorgey: can i also set a smaller border on the left?
13:05:25 <litb> i don't need that huge space left out for nothing
13:05:58 <byorgey> litb: sure, you can adjust margins with the geometry package
13:06:23 <litb> ah, it's a tex thing
13:06:36 <byorgey> litb: do you know LaTeX at all?
13:06:43 <litb> not good
13:07:02 <litb> hardly anything :)
13:07:14 <cjb> yay, yi works.
13:07:27 <litb> i tought i would just do this, tyoe lhs2Tex and it does it fine
13:07:37 <TuringTest> I know LaTeX
13:07:44 <TuringTest> byorgey: What do you need?
13:07:50 <litb> guys, stupid question: what is the tail for tuples?
13:07:52 <byorgey> litb: http://tug.ctan.org/cgi-bin/ctanPackageInformation.py?id=geometry
13:07:53 <lambdabot> Title: CTAN: View package information
13:08:03 <litb> byorgey: thxx you
13:08:05 <dons> cabal is great though -- its the single biggest factor in the explosion of libraries in the last 2 years
13:08:26 <nominolo> litb: snd
13:08:28 <byorgey> litb: you can do something like \usepackage[noheadfoot, margin=1in]{geometry}
13:08:45 <Cin> litb: snd?
13:08:46 <byorgey> litb: that would make all the margins 1 inch, but there are other options for setting the margins independently
13:08:52 <litb> byorgey: can i make it so that it is broken down somehow?
13:08:56 <byorgey> TuringTest: not me, litb =)
13:09:14 <litb> Cin: but it wants a Pair, and i have a n-tuple
13:09:29 <byorgey> litb: yes, I forget the exact option names, but look at the documentation on that page I linked to
13:10:03 <byorgey> litb: also, if you used a language other than German, your text would be shorter ;)
13:10:04 <litb> many thanks dude, i will dig into this
13:10:10 <litb> lolz
13:10:21 <litb> the larger the hotter, you know
13:10:24 <pejo> dons, oh, cabal is most definitely needed, and it seems well designed too.
13:10:24 <byorgey> hehe
13:10:30 <sjanssen> dons: exactly.  I think we only have the explosive success of hackage et al because packages actually build
13:10:30 * byorgey studied German in high school
13:10:49 <sjanssen> dons: this was not the case when everybody manually fiddled with ghc-pkg in their makefiles
13:10:50 * nominolo too
13:11:00 <dons> sjanssen: right. things work. you can find examples to start from. so its a lot lot easier now
13:11:01 <Saizan> litb: there's no thing as a n-tuple, tuples of different sizes are totally distinct types
13:11:02 <nominolo> in first grade that is
13:11:05 <litb> i stutied english in High School
13:11:13 <litb> errm, yeah i only studied it
13:11:16 <dons> whereas only 4 people new how to build a haskell lib when it required a Makefile
13:11:41 <nominolo> dons: but a central repo is important too
13:11:50 <byorgey> litb: well, your english is a lot better than my german... =)
13:11:51 <litb> Saizan: hm, so i cannot write such a function that cuts off the first element of a tuple?
13:11:53 <dons> yes, that's the other part
13:12:13 <dons> centralising everything concentrates the small community's efforts
13:12:22 <dons> so code gets reused, and not wasted
13:12:28 <byorgey> litb: not without some sort of silly type class hackery.
13:12:38 <litb> darn
13:12:43 <pjd> litb: \(a,b,c) -> (b,c)
13:12:48 <dons> and it gives us a chance to show how reusable haskell code is, when its pure and lazy, now that we finally have lots of libs of this sort
13:12:59 <nominolo> litb: maybe just use lists?
13:13:03 <litb> i see, remembers me of boost.pp
13:13:07 <ptolomy> These guys conducting this ".NET Rocks" interview of SPJ are less familiar with language issues than I expected.
13:13:08 <dons> we didnt' see the programming-in-the-large modularity and decoupling till we had a lot of libraaries
13:13:15 <dons> ptolomy: hehe
13:13:27 <dons> ptolomy: CS education sucks for programming language basics
13:13:31 <jorik808> oh yay i finished my homework !!
13:13:48 <byorgey> jorik808: congrats! =)
13:13:53 <nominolo> ptolomy: yeah
13:13:54 <litb> nominolo: i need something heterogeneous
13:14:05 <pjd> litb: are you sure?
13:14:12 <nominolo> litb: ok, HList is too big a step
13:14:18 <dozer> still no joy making hxt work acceptably - trying to track down a ByteString version of parsec
13:14:20 <faxathisia> Why not use lists instead of tuples?
13:14:29 <dons> dozer: ask tibbe or ddarius
13:14:37 <faxathisia> [Left 4, Right "choux"]
13:15:07 <ptolomy> Also, apparently smalltalk and eiffel went away by 2000 because "we didn't need that many object oriented languages"
13:15:13 <dozer> dons: wasn't it a summer of code project?
13:15:23 <cjb> olpc ships smalltalk :)
13:15:26 <jorik808> thanks ! :D i'm kinda extatic, i spent the last three days expanding a simple scheme like language to implement a 'capture()' function which captures the current envirenmont and a env.exp syntax which executes exp "inside" env
13:15:32 <jorik808> aaaah im so happy
13:15:36 <nominolo> ptolomy: and Monads are like a mutex
13:15:47 <jorik808> not gunna code c again for a looooooooong time woohoow
13:16:07 <nominolo> today i also read F# is a descendant of haskell
13:16:51 <byorgey> jorik808: this was in Haskell?
13:17:04 <byorgey> or c ?
13:17:09 <jorik808> no it was written in c
13:17:54 <jorik808> its not really on topic i guess ...
13:17:56 <jorik808> :D
13:18:48 <litb> pjd: i will reconsider all this
13:19:01 <cjb> Yi is fun.  I wonder if there's a TODO somewhere.
13:19:18 <byorgey> jorik808: that's ok, I was just curious =)
13:19:42 <jorik808> :)
13:19:46 <byorgey> cjb: there's a list of open tickets on google code.
13:19:51 * byorgey was just looking at that
13:20:18 <cjb> grr, google code.
13:20:30 <Heffalump> nominolo: more like a descendant of O'Caml, but influenced by Haskell in some ways
13:20:51 <cjb> byorgey: Thanks.
13:21:36 <shapr`> cjb: Any way to still get XOs? Or should I check craigslist?
13:21:47 <cjb> shapr`: ebay, yeah.
13:21:52 <newsham> hey shapr.
13:22:56 <nominolo> Heffalump: at least its developers knew about it, so that might be a valid claim
13:23:21 <Heffalump> I imagine they knew about Java, C++, etc etc, but that doesn't make it a descendant of them..
13:24:08 <shapr`> hiya newsham!
13:24:17 <newsham> whadya gonna do w/ yer xo?
13:24:22 <dozer> I thought F# was more of a bastard child of OCamel and Scheme
13:24:34 <shapr`> cjb: too bad I didn't have money until g1g1 was over :-(
13:25:02 <newsham> looks like they're not so bad on ebay right now, but you missed out on a chance to donate to the cause
13:25:16 <shapr`> Yeah, I wanted to do both.
13:25:56 <byorgey> cjb: what's wrong with google code?
13:26:38 <cjb> byorgey: I have a rant against free software projects storing their bugstate/wikis using proprietary code/hosting that doesn't let you take your data back out.
13:27:17 <byorgey> cjb: ah, a valid rant.
13:27:21 <gwern> cjb: what should haskell projects use then? sourceforge?</spit>
13:27:31 <byorgey> cjb: I didn't know google code doesn't let you get your data back out.
13:27:33 <Saizan> how do you select one of the completions suggested in yi?
13:27:44 <cjb> gwern: You could install Savannah on *.haskell.org.
13:27:58 <cjb> byorgey: I don't see a way to download a tarball of bug contents, for example.  Likewise the wiki.
13:28:21 <gwern> cjb: persuade whoever admins haskell.org to do that...
13:28:54 <cjb> gwern: Yeah.  I haven't been around long enough to be comfortable persuading people to do things yet, but I would propose installing Trac, probably.
13:29:09 <cjb> We use Trac for OLPC; it's a wiki/bug tracker that integrates with source control.
13:29:13 <Heffalump> what's hosted on google code?
13:29:24 <Heffalump> is darcs a properly supported plugin for trac yet?
13:29:33 <cjb> Heffalump: I was about to look into that.
13:30:00 <cjb> Heffalump: Many Haskell projects use Google Code.  xmonad is an example.
13:30:11 <Heffalump> it is? I thought it was hosted on darcs.haskell.org
13:30:20 <cjb> We are talking about different things.
13:30:28 <byorgey> Heffalump: just the bug tracking.
13:30:35 <cjb> it hosts source at darcs.h.o.  It uses the bug tracking at Google Code.
13:30:38 <Heffalump> oh, right
13:30:52 <cjb> I'm complaining about free software projects that use proprietary bug tracking/wikis, because it lessens the freedom of the project as a whole.
13:31:15 <Heffalump> bug tracking info could easily be recovered if you really needed to, though
13:31:22 <Heffalump> since developers will have it in their email
13:31:49 <gwern> I think for small projects it doesn't really matter, but I could see it being really important if you have thousands of bugs with lengthy threads
13:31:50 <newsham> ?seen dons
13:31:50 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 17m 22s ago.
13:31:59 <Heffalump> yeah, true
13:32:27 <Heffalump> It doesn't really seem worth investigating effort to migrate, though. I agree it'd be better to have started out open.
13:33:12 <cjb> Heffalump: If Trac has darcs integration that lets you e.g. close bugs via commit messages that reference them, then that would be a good technical reason.
13:33:29 <jlongster> Bugs Everywhere is a neat bug tracking software.  someone needs to write a darcs plugin for it though
13:33:33 <jlongster> http://weblog.masukomi.org/2008/1/3/distributed-bug-tracking
13:33:34 <lambdabot> Title: weblog.masukomi.org Distributed Bug Tracking
13:33:41 <cjb> jlongster: I wrote a GIT plugin for it.  :)
13:33:52 <Heffalump> cjb: yeah.
13:33:58 <cjb> but upstream didn't reply to my e-mail patch.
13:34:03 <cjb> I think it's abandoned.  Frustrating.
13:34:44 <jlongster> cool, we should pick it up
13:34:57 <sjanssen> cjb: I've heard that the darcs plugin has significant issues
13:35:18 <jlongster> or someone should.  I didn't know it was abandoned, that sucks
13:35:27 <cjb> I like BE because it's the perfect answer to my complaint about using proprietary external bugtrackers; to share the bugs with the code.
13:35:47 <Heffalump> does it follow bugs on branches?
13:35:55 <cjb> and it allows offline working and all that good stuff that a website doesn't.
13:35:59 <jlongster> yup, we've been playing around with it and it looks awesome
13:36:03 <jlongster> Heffalump: yes
13:36:48 <Heffalump> that sounds great
13:37:10 <cjb> there are other distributed bugtrackers too
13:37:36 <cjb> but BE is nice in that it doesn't force a particular dVCS on you, and it has different frontends for console/web/local GUI.
13:37:59 <sclv_> http://www.distract.wellquite.org/
13:38:00 <lambdabot> Title: start [DisTract]
13:38:15 <cjb> There was a long thread on emacs-devel recently about (a) starting to use a bugtracker, (b) picking a distributed one so RMS and others can work offline.
13:38:31 <cjb> I prefer http://www.ditrack.org/ to DisTract.
13:38:32 <lambdabot> Title: DITrack - Distributed Issue Tracker
13:39:00 <sclv_> distract seems pretty stalled out. i just like the fact that it is haskell.
13:39:08 <cjb> (DisTract is web-browser-only, and moreover Firefox-only.)
13:40:48 <jlongster> DITrack doesn't support darcs right?
13:41:01 <cjb> yeah, SVN only
13:41:07 <cjb> so BE is probably the way forward
13:41:44 <jlongster> someone should take over maintenance... :)
13:42:21 <cjb> yeah.  Maybe I'll send a mail.
13:42:50 <jlongster> I could possibly help with a darcs port
13:43:31 <Heffalump> trac is already used a fair bit in the Haskell world, at least
13:43:42 <cjb> and Python/Ruby.
13:44:16 <cjb> there's a very lively community around writing Trac plugins.  People wrote e.g. an e-mail interface while I wasn't paying attention.
13:45:12 <Heffalump> but I had a vague impression they weren't too helpful about getting the darcs integration merged properly, or at least to provide a plugin interface it could use. I could be misremembering, though.
13:45:30 <cjb> Oh, that's annoying.  I'll ask our local Trac committer about it.
13:46:30 <Heffalump> I could be completely mistaken on the subject; it's just a vague memory of a conversation.
13:46:44 <jlongster> Trac is the one that uses a firefox extension?  That's way too limiting for me though
13:46:49 <cjb> jlongster: No.
13:46:59 <jlongster> Ah, ok
13:47:00 <cjb> Trac is like Google Code, but free.
13:47:11 <jlongster> coolness, I'll have to look into it
13:47:21 <litb> byorgey: u know how i can change the font?
13:47:27 * RayNbow opens dotnetrocks_0310_simon_peyton_jones.mp3
13:47:27 <cjb> http://trac.edgewall.org/
13:47:33 <lambdabot> Title: The Trac Project - Trac
13:47:47 <litb> (some symbols are looking weird and for some there are only [] displayed (squares where symbols are not found)
13:48:26 <byorgey> litb: not off the top of my head, sorry.
13:50:12 <cjb> ouch, it looks like Bugs Everywhere's bazaar tree has disappeared from their site
13:50:19 <litb> ugg, then it must be very difficult to do i suppose
13:52:02 <cjb> Ohh, from the webpage:  > We have ceased development of Bugs Everywhere. This page is for reference only.
13:52:02 <cjb>  
13:52:02 <cjb>  
13:52:35 <monochrom> Good. We can start development of Features Everywhere instead. :)
13:52:45 <cjb> heh.
13:53:48 <ricky_clarkson> As sure as code is data, features are bugs.
13:53:52 <cjb> mailed the author.
13:56:34 <dancor> can i suppress non-errors from ghc
13:57:05 <dancor> i was hoping that "[1 of 1].." "linking.." etc went to stdout and it would be easy but alas
13:58:29 <ricky_clarkson> Is there some codebase that reflects what Wadler was talking about wrt Dyn?
13:58:46 <ricky_clarkson> ..in Well-Typed Code Cannot Be Blamed.
14:06:04 <gwern> parsec 3 will use bytestrings right?
14:06:37 <faxathisia> ricky, proof carrying code maybe
14:07:09 <faxathisia> althought I'm not sure that's the best example
14:07:14 <Lemmih> gwern: Instead of tokens?
14:08:02 <gwern> Lemmih: dunno. i heard rumors the original parsec used String, and that the maintainer was porting it to ByteStrings for 3
14:08:24 <ricky_clarkson> faxathisia: Is that a particular paper/project?
14:08:34 <ricky_clarkson> @go proof carrying code haskell
14:08:40 <lambdabot> http://portal.acm.org/citation.cfm?id=1265742
14:08:40 <lambdabot> Title: Type-Safe Code Transformations in Haskell
14:10:54 <Steve|Office> I'm trying to build ghc 6.8.2 on x86_64. The binary package can't be installed for some reason, so I installed 6.6.1 and then configured 6.8.2 to build using that. However, the build fails with: ghc-6.6.1: unknown package: posix. I'm not sure what the problem is.
14:13:15 <lightstep> which library should i use to record raw sound data (from the microphone port) on linux?
14:13:56 <dancor> Steve|Office: i'm not sure but i think that library is supposed to be inside ghc..  i can't find it on http://hackage.haskell.org/packages/archive/pkg-list.html, maybe try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix-2.2.0.0
14:14:17 <dancor> Steve|Office: something could be really wrong but that's what i would try, but i don't really know anything
14:14:31 <Corun> lightstep, is there an OpenAL haskell binding? That does raw sound recording I think.
14:15:02 <dons> lightstep: maybe just read from the Handle?
14:15:15 <dons> or use one of the sounds libraries (see hackage.haskell.org)
14:15:27 <lightstep> ok. many links in "Application and libraries" on that subject are broken, or lead to packages with broken docs
14:15:35 <Corun> :/
14:15:37 <lightstep> dons, which handle?
14:16:01 <Corun> /dev/errraudio?
14:16:49 <dons> the Handle to the device (after you open it up)
14:16:58 <dons> read it as a bytestring, perhaps
14:17:11 <Steve|Office> dancor: Yeah, there is a lib/ghc-6.6.1/imports/System/Posix and lib/ghc-6.6.1/imports/Text/Rexex/Posix in my
14:19:26 <eugman|work> I'm thinking about different projects I can do in Haskell; Can anyone give me an idea of what sort of domain Haskell excels and maybe some types of applications to stay away from?
14:19:50 <dons> hmm.
14:20:16 <dons> eugman|work: its a general purpose language, so the weak points are pretty few these days. what kind of projects are you interested in?
14:20:41 <Corun> I'd say that haskell is better at things which have little IO. But I'm sure I'd get told off for saying that :-)
14:20:46 <dons> something that exploited concurrency or data structures or parsing/translation are the classic strong points
14:20:58 <dons> Corun: darcs and xmonad are the most popular open source haskell apps :)
14:21:04 <dons> they're all IO.
14:21:12 <lightstep> ghc
14:21:30 <lightstep> it's popular, and mostly does computation
14:21:52 <dons> it does lots of IO too
14:21:56 <Corun> Popularity doesn't really mean it was easy to write or that the code was nice or anything like that.
14:21:59 <dons> all those .hi files don't write themselves
14:22:17 <dons> Corun: having first class IO actions makes for some nice code
14:22:25 <eugman|work> Well I'm still figuring out what I'm interested in. I've made games before but haskell doesn't seem a good fit for that. I saw the irc bot tutorial, that look interesting and easily expanded. Maybe, some sort of program as a study aid or to produce html. I haven't actually made many useful programs on purpose.
14:22:55 <dons> html would be good. there's a nice xhtml library, and translating data structures is a classic strength of haskell
14:23:19 <jlongster> eugam|work: funny.  I'm really considering writing an intense 3d graphics engine in haskell right now..
14:23:30 <jlongster> but I can't help much because I haven't come to a conclusion yet :)
14:23:30 <dons> the irc tutorial is a good one. there are a lot of games these days, i've noticed. opengl and gtk ones are popular
14:23:47 <Cin> Frag is groovy
14:23:48 <dons> ?faq btw
14:23:48 <lambdabot> The answer is: Yes! Haskell can do that.
14:24:10 <dons> so just do what you're interested in -- we've enough libs, tools and speed to handle all comers now
14:24:13 <eugman|work> Yeah i know games have been made but a purely functional language seems the antithesis of a game language but i could be rather wrong
14:24:31 <Corun> ?faw Dynamically loaded plugins in a nice way
14:24:31 <lambdabot> The answer is: Yes! Haskell can do that.
14:24:35 <dons> there's a classic purely functional approach to games based on reactive programming
14:24:40 <Cin> eugman: have you seen Frag and accompanying paper?
14:24:47 <dons> Corun: use hs-plugins?
14:25:01 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Games
14:25:05 <eugman|work> Cin, I haven't read the paper, i heard about frag when I was checking out ahskell a few months ago
14:25:08 <dons> there's the games catalogue. some nice ones there.
14:25:10 <jedbrown> nice, gtk2hs tutorial: http://reddit.com/r/programming/info/66hja/comments/
14:25:36 <Corun> I don't think that's necessarily nice, dons.
14:26:06 <eugman|work> So to reiterate, Ok I can do anything in haskell, what factors, areas, designs, or features belonging to a type of program would be a strong fit with haskells features.
14:26:30 <Pseudonym> eugman: Generally speaking, anything too complex to do in C.
14:26:45 <Pseudonym> If you wouldn't attempt it in C because it looks too hard, Haskell is probably a good fit.
14:26:54 <Cin> i'm writing an multithreaded irc server. i'm finding it quite difficult, but mostly because i suck
14:27:03 <eugman|work> Pseudonym, wow that's an extremely useful rule of thumb.
14:27:07 <Corun> That's the spirit, Cin.
14:27:21 <Pseudonym> But you'll finish it, I have faith.  And then you provably won't suck.
14:27:46 <Cin> that's my intention
14:27:49 <Corun> Was... That a typo?
14:29:06 <eugman|work> Well it makes sense as provably
14:29:52 <Cin> hpaste: url
14:29:52 <hpaste> Haskell paste bin: http://hpaste.org/
14:29:53 <oerjan> @remember Pseudonym If you wouldn't attempt it in C because it looks too hard, Haskell is probably a good fit.
14:29:53 <lambdabot> Okay.
14:30:12 <Pseudonym> Generally spaking, that's what I do, BTW.
14:30:28 <Pseudonym> OK, I need to write a program that takes a file path and removes it from the OS buffer cache.  Yup, sounds easy in C.
14:30:41 <Pseudonym> OK, I need to do some combinatorial backtracing search.  Yuck, too hard to do in C...
14:30:56 <hpaste>  Cin pasted "irc server so far... '_'" at http://hpaste.org/5204
14:31:17 <Pseudonym> Conversely, the first program would probably be hard to write in C.
14:31:21 <Pseudonym> Sorry, in Haskell.
14:31:34 <Cin> my functions are nice and short so far, which is pleasing
14:31:35 <eugman|work> I'll probably have a better idea once I start learning haskell too. I wanted a langauge that would make my head explode. Haskell seems overqualified.
14:31:38 <Pseudonym> Low-level brain-dead system hackery is a perfect fit for C.
14:31:44 <lightstep> does ghc 6.8 produce really fast code by default? the shootout entries for 6.6 contained really ugly code
14:32:22 <moonlite> Pseudonym: no need to be patronizing
14:32:28 <Pseudonym> I'm not.
14:32:40 <Pseudonym> Unix is low-level system hackery, though arguably not so brain-dead.
14:32:45 <Pseudonym> And it's written in C.
14:32:50 <moonlite> you called the system hackery brain-dead :)
14:32:54 <Pseudonym> No.
14:33:04 <Pseudonym> Any system hackery which is also brain-dead is a perfect fit for C.
14:33:05 <moonlite> ok then
14:33:05 <dobblego> it is a statement , analyse it for its potential truth
14:33:09 <moonlite> sorry :)
14:33:19 <Pseudonym> Any system hackery which is not brain-dead... well, I'd consider C++.
14:35:17 <olsner> should've started make (ghc-6.8.2) through 'time' this morning... some time tomorrow when it's done I would've wanted to see exactly how much time it took
14:35:52 <lightstep> seems like a task for python
14:35:54 <Steve|Office> Hmm, the i686 build of ghc 6.8.2 I just got working only took about an hour.
14:35:59 <Botje> quick, make clean and do it all over again!
14:36:38 <lightstep> you can read the cpu time off the output of top or ps, do it until the process returns
14:37:01 <Steve|Office> Lovely. When I run ./configure on the x86_64 binary, I get: checking for path to top of build tree... pwd: timer_create: Invalid argument
14:38:02 <litb> hm, can i break up a do with \end{code} ?
14:38:07 <Steve|Office> Ah, but I copied a pwd over from the i686 build which worked and that seems to work.
14:38:32 <litb> i mean, within such a block, can i just break it up with \begin{code} and \end{code} ? i have problems with indentation then
14:39:18 <Steve|Office> In fact, replacing all of utils was the way to go, apparently.
14:39:30 <jlongster> anyone know of any good papers about pure functional programming (especially scene trees and zippers) in games besides Frag?
14:40:50 <lightstep> the openal library has both Setup.hs and configure. which should i run first?
14:42:02 <keseldude> $ runhaskell Setup.hs configure --user [--prefix=$HOME]
14:42:13 <lightstep> ok
14:43:13 <eugman|work> I thought this page about zippers was funny. http://en.wikibooks.org/wiki/Haskell/Zippers
14:43:14 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
14:47:05 <Lemmih> dons: ping.
14:50:51 <Steve|Office> Ugh. I installed the binary package of ghc 6.8.2 and am now trying to run configure in the source package and pwd.hs:5:7 is failing with Could not find module `System.Environment'.
14:53:38 <monochrom> source code of ghc 6.8.2 too?
14:54:00 <Steve|Office> Yeah.
14:54:57 <eugman|work> can i compile on windows a standalone program that uses wxHaskell?
14:58:13 <oerjan> litb: you must have \begin{code} and \end{code} on separate lines, according to http://haskell.org/onlinereport/literate.html#sect9.6
14:58:59 <pchiusano> hi
14:59:10 <pchiusano> :t |>
14:59:12 <lambdabot> parse error on input `|>'
14:59:23 <oerjan> :t (|>)
14:59:24 <lambdabot> Not in scope: `|>'
14:59:31 <oerjan> @hoogle |>
14:59:32 <lambdabot> Data.Sequence.(|>) :: Seq a -> a -> Seq a
14:59:32 <lambdabot> Control.Applicative.(<|>) :: Alternative f => f a -> f a -> f a
14:59:32 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<|>) :: GenParser tok st a -> GenParser tok st a -> GenParser tok st a
14:59:36 <Steve|Office> The part that is failing is /tmp/steve/bootstrap/bin/ghc -v0 --make pwd -o pwd
15:00:05 <pchiusano> is there some operator that is the reverse order of '.'
15:00:11 <pchiusano> i thought it was |>
15:00:12 <dons> Lemmih: yo
15:00:22 <oerjan> pchiusano: >>>
15:00:34 <oerjan> :t (>>>)
15:00:34 <pchiusano> so (a |> b) == (b . a)
15:00:35 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
15:00:41 <Lemmih> dons: GHCi can't compile 'binary' on Darwin.
15:00:48 <oerjan> :t (>>>).($) -- restricting to -> arrow
15:00:49 <reilly> i'm looking for a good discussion of "kinds" ... can anybody point me at a good one?
15:00:49 <lambdabot> forall d a b. (a -> b) -> (b -> d) -> a -> d
15:00:56 <dons> Lemmih: oh!
15:01:01 <dons> send me a log
15:01:32 <Lemmih> dons: Coming up.
15:01:55 <pchiusano> reilly, check:
15:01:59 <faxathisia> reilly, There's not much to it, kinds are to types as types are to values
15:02:58 <pchiusano> http://lambda-the-ultimate.org/node/2579
15:02:59 <lambdabot> Title: Generics of a Higher Kind | Lambda the Ultimate
15:03:10 <reilly> thanks!
15:03:17 <Steve|Office> And of course, there are sorts.
15:03:17 <pchiusano> well, examples are in scala
15:03:43 <pchiusano> but, they explain kinds pretty well
15:04:12 <viv145> taissir: hi
15:05:12 <viv145> 213
15:05:13 <viv145> 123
15:05:16 <viv145> 321
15:05:20 <viv145> 312
15:05:24 <viv145> 132
15:05:27 <viv145> 213
15:05:48 <viv145> 213
15:05:48 <viv145> 	viv145	123
15:05:48 <viv145> 06:36	viv145	321
15:05:48 <viv145> 	viv145	312
15:05:48 <viv145> 	viv145	132
15:05:48 <viv145> 	viv145	213
15:05:51 <viv145> 213
15:05:52 <viv145> 	viv145	123
15:05:54 <viv145> 06:36	viv145	321
15:05:56 <viv145> 	viv145	312
15:05:58 <viv145> 	viv145	132
15:06:00 <viv145> 	viv145	213
15:06:02 <viv145> 213
15:06:04 <viv145> 	viv145	123
15:06:06 <viv145> 06:36	viv145	321
15:06:08 <czShadoW> Hm?
15:06:08 <viv145> 	viv145	312
15:06:10 <viv145> 	viv145	132
15:06:12 <viv145> 	viv145	213
15:06:14 <viv145> 213
15:06:16 <viv145> 	viv145	123
15:06:18 <viv145> 06:36	viv145	321
15:06:20 <viv145> 	viv145	312
15:06:22 <viv145> 	viv145	132
15:06:24 <viv145> 	viv145	213
15:06:26 <viv145> 213
15:06:28 <viv145> 	viv145	123
15:06:30 <viv145> 06:36	viv145	321
15:06:32 <viv145> 	viv145	312
15:06:34 <viv145> 	viv145	132
15:06:34 <lightstep> sound like a cat
15:06:36 <viv145> 	viv145	213
15:06:37 <czShadoW> What's the point?
15:06:38 <viv145> 213
15:06:40 <viv145> 	viv145	123
15:06:42 <viv145> 06:36	viv145	321
15:06:44 <viv145> 	viv145	312
15:06:45 <Pseudonym> viv145, could you stop that please?
15:06:46 <viv145> 	viv145	132
15:06:47 --- mode: ChanServ set +o Pseudonym
15:06:48 <viv145> 	viv145	213
15:06:49 <Steve|Office> There has got to be a better bootstrapping system for ghc. It shouldn't require ghc or an identical system with ghc to produce .hc files. There should be some way to bootstrap from a C compiler alone.
15:06:50 <viv145> 213
15:06:52 <viv145> 	viv145	123
15:06:54 <viv145> 06:36	viv145	321
15:06:55 --- kick: viv145 was kicked by Pseudonym (Pseudonym)
15:07:01 --- mode: ChanServ set -o Pseudonym
15:08:17 <viv145> hi
15:08:24 <Lemmih> dons: http://hpaste.org/5205
15:08:38 <Pseudonym> Hi.
15:09:00 <Pseudonym> Sorry about that, figured you had a misbehaving paste or something.
15:09:39 <Lemmih> dons: Can we fix it with a well placed #ifdef DARWIN?
15:10:37 <dons> Lemmih: you're using an old version of Data.Binary, I think
15:10:46 <dons> that symbol is hs_uncheckedShiftRL64 now
15:10:54 <dons> and was fixed in binary 0.4.1 iirc
15:11:30 <Steve|Office> Hmm: wired-in package base not found. That can't be good.
15:12:52 <mrd> Steve|Office: why a C compiler?
15:13:00 <mrd> what if you're on a system with no C compiler
15:13:13 <mrd> best to bootstrap directly from machine code
15:13:31 <Steve|Office> mrd: I can't recall the last time I used a computer with a C compiler.
15:13:50 <mrd> yea that was so 70s
15:14:04 <dons> scary
15:14:06 <Lemmih> dons: Thanks.
15:14:13 <dons> Lemmih: was that the issue?
15:14:38 <Pseudonym> Windows 95 was, IIRC, the first operating system which didn't ship with a programming language.
15:14:44 <dons> scary
15:14:54 <Steve|Office> mrd: I'm not interested in getting into a language argument with you here. Every computer I own has a C compiler. I can't get the binary ghc package to install on x86_64 so I can't build from source so I can't use haskell.
15:15:13 <monochrom> But it ended with Windows 98 or something.
15:15:20 <Lemmih> dons: Checking. (pretty sure it is)
15:15:21 <mrd> you said you can't recall the last time you used a computer with a C compiler
15:15:33 <Steve|Office> heh, I meant without. Oops.
15:15:37 <monochrom> Every Windows installation is shipped with IE, which accepts javascript.
15:15:38 <dons> Steve|Office: so what's the issue -- what OS are you using?
15:15:59 <viv145> dons	that symbol is hs_uncheckedShiftRL64 now
15:15:59 <viv145> 	dons	and was fixed in binary 0.4.1 iirc
15:15:59 <viv145> 		-> thingwath se ha unido a haskell
15:15:59 <viv145> 06:42	Steve|Office	Hmm: wired-in package base not found. That can't be good.
15:15:59 <viv145> 06:43	mrd	Steve|Office: why a C compiler?
15:15:59 <viv145> 	mrd	what if you're on a system with no C compiler
15:16:01 <viv145> 	mrd	best to bootstrap directly from machine code
15:16:03 <viv145> 06:44		<- QplQyer ha desconectado ("*poef* *roekwolk*")
15:16:05 <viv145> 	Steve|Office	mrd: I can't recall the last time I used a computer with a C compiler.
15:16:07 --- mode: ChanServ set +o Pseudonym
15:16:07 <viv145> 		<- moonlite ha desconectado ("Ex-Chat")
15:16:09 <viv145> 	mrd	yea that was so 70s
15:16:11 <viv145> 	dons	scary
15:16:11 --- kick: viv145 was kicked by Pseudonym (Pseudonym)
15:16:18 <Steve|Office> dons: Well, the binary package's configure didn't work because the utils stuff seemed broken.
15:16:21 <Pseudonym> Should I have banned?
15:16:27 <Pseudonym> Troll, or malfunctioning client?
15:16:28 <dons> Pseudonym: nah
15:16:31 --- mode: ChanServ set -o Pseudonym
15:16:33 <dons> just pasteo i guess
15:16:36 * Pseudonym nods
15:16:36 <Lemmih> What a weird spammer.
15:16:37 <Steve|Office> So I copied the utils from my i686 install so then I was able to install the binary package.
15:16:38 * Pseudonym figured too
15:16:40 <monochrom> It doesn't join again, don't worry.
15:16:56 <Steve|Office> Now running ./configure, I get pwd.hs:5:7 Could not find module `System.Environment'.
15:16:56 <dons> Steve|Office: so you attempted to install the ghc 6.8.2 binary package for which OS?
15:17:14 <Steve|Office> Linux 2.6.9-55.0.2.ELsmp
15:17:25 <dons> oh just linux? using which binary package?
15:17:35 <dons> you can probably get ghc from your distros package system
15:17:57 <Steve|Office> http://www.haskell.org/ghc/dist/6.8.2/ghc-6.8.2-x86_64-unknown-linux.tar.bz2
15:18:00 <lambdabot> http://tinyurl.com/2bmgr5
15:18:08 <Steve|Office> I'm just a lowly user on this computer.
15:18:16 <dons> ghc only needs user privs though
15:18:32 <Steve|Office> I've had to install a number of things to be up to date, including gcc!
15:18:41 <dons> hmm. really?
15:18:46 <dons> what gcc did you have previously?
15:18:58 <Steve|Office> 3.4.6.
15:19:02 <dons> should be fine.
15:19:22 <Steve|Office> Not for me, I needed a later gcc. I'm just saying that the software is old on these machines.
15:19:31 <dons> though this cabal error you're getting is a little strange.
15:19:42 <Steve|Office> Is that a cabal error?
15:19:55 <dons> well, the error is related to a cabal module.
15:20:01 <Steve|Office> Ah.
15:20:25 <dons> i can't diagnose what's wrong though. its failing. check the build log. if you can't work it out, try on the mailing list.
15:20:30 <hpaste>  Steve pasted "configure failure" at http://hpaste.org/5206
15:20:39 <dons> or if possible use a package for your distro
15:20:45 <Steve|Office> That is what configure is running which fails.
15:20:53 <Lemmih> dons: Yes, using the new binary did the trick.
15:21:04 <dons> great.
15:21:51 <Lemmih> dons: Indeed, now I can write prettier code at work (:
15:22:10 <dons> yay
15:22:23 <dons> Lemmih: there's applicative instances for Binary in the darcs version, they're nice too
15:22:24 <Saizan> Steve|Office: in ghci if you digit :m + System.Environment, what does it says?
15:22:34 <dons> if you find you want those, i can release a new version
15:22:45 <Steve|Office> ghci fails.
15:22:56 <vincenz> dons: how do you arbitrary- generate data that has some conditions
15:23:02 <vincenz> dons: e.g. if you want an integer that is not 0
15:23:09 <Steve|Office> Okay, I'm leaving now, but I'll be back later. Thanks for trying to help.
15:23:12 <Saizan> Steve|Office: ok, so you lack the package where System.Environment is
15:24:05 <Saizan> but, it's in base, weird
15:24:21 <dons> vincenz: filter, or use QC2's types for NonNegative Int
15:24:39 <dons> vincenz: but you can ask for an arbitrary x, check if it satisifies P, then recurse if it doesn't
15:24:56 <vincenz> dons: and how do you make coarbitrary?
15:25:03 <vincenz> dons: imagine I have Foo a = Foo a a
15:25:07 <dons> do you need a coarbitrary?
15:25:10 <vincenz> so I have liftm2 arbitrary arbitrary
15:25:15 <vincenz> dons: I don't know, would make it clean
15:25:23 <monochrom> stage 3 booted?!
15:25:32 <dons> coarbitrary = undefined
15:25:51 <vincenz> coarbitrary (Foo x y) = coarbitrary x . coarbitrary ?
15:25:53 <vincenz> coarbitrary (Foo x y) = coarbitrary x . coarbitrary y?
15:28:39 <Saizan> oarbitrary (x,y)?
15:33:54 <Time`s_Witness> can we use getContents and getLine functions in same function ? I am not being able, compiling it with winHugs apparently is allright, however winhugs cannot read files (not that i know of, at least); im interested in running  the script from OS's console
15:34:00 <lightstep> wow, openal is completely unusable without alut
15:34:20 <dons> Time`s_Witness: only if you run getContents last
15:35:04 <Time`s_Witness> hmm.. what if, with getLine, i want to ask information about readen data from getContents ? there's no way to do it, is there?
15:35:18 <oerjan> Time`s_Witness: no
15:35:27 <Time`s_Witness> Thanks :)
15:35:31 <dons> no, use 'lines' to extract lines from getContents , perhaps
15:35:42 <oerjan> once you have used getContents, all other file operations are essentially off limits
15:36:21 <Time`s_Witness> yea i was thinking about it dons, thanks :P
15:36:37 <Time`s_Witness> hmm.. okay oerjan :) Thanks all!
15:45:01 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtlparse-0.0.0.5
15:45:02 <lambdabot> http://tinyurl.com/ypejpv
15:45:10 <dons> interesting, Parse and ParseT monads
15:45:44 <LoganCapaldo> And a monadParse type class?
15:45:53 <LoganCapaldo> *MonadParse
15:46:41 <ddarius> The typical Parser is essentially StateT String [].  Changing to StateT String (ListT m) is not particularly hard.
15:57:57 <Time`s_Witness> http://hpaste.org/5208 <-- here, everything goes OK without the last line. i think it tries to insert the recursivity into the putStr.. i have a type error with that last line, and everything ok without it.. why does it happen ? :S
15:58:44 <lightstep> you forgot a "do"
15:58:56 <lightstep> after the "in"
15:59:20 <Time`s_Witness> why do i need it? Because i have more than one instruction after it?
15:59:25 <Time`s_Witness> :S
15:59:27 <lightstep> yes
15:59:46 <lightstep> there is also alternative syntax for "let" in a "do" scope
16:00:43 <lightstep> i annotated with the other syntax
16:00:48 <Time`s_Witness> im only aware of "let" and "where" for this kind of.. things.. :s from what i have learned, "let" is when working with file
16:00:49 <Saizan> anyone knows where this could have moved? http://www.cse.ogi.edu/~mpj/thih/
16:00:50 <Time`s_Witness> files
16:00:52 <monochrom> If you insist on "let ... in", you need add another "do".
16:01:15 <Time`s_Witness> checking the other syntax :) Thanks lightstep :P
16:01:19 <oerjan> !paste -- alive?
16:01:19 <hpaste> Haskell paste bin: http://hpaste.org/
16:01:40 <lightstep> let and where are completely equivalent
16:02:14 <Time`s_Witness> hmm, but if i want more than one "x = y(z(a))" in "let" or "where", i cant use that syntax can i? or it's just a matter of identation
16:02:31 <monochrom> just a matter of indentation.
16:02:37 <oerjan> Time`s_Witness: just indentation.  let and where both start indentation blocks
16:02:40 <lightstep> you can, with both key words
16:02:56 <Time`s_Witness> ok :)
16:03:50 <oerjan> let, where, do, (case) of
16:04:54 <Time`s_Witness> hmm.. case could be interesting.. checking it out soon :P
16:06:04 <oerjan> those are all the indentation block keywords in H98, there are extensions that add a bit more (mdo, and perhaps proc?)
16:18:38 <shepheb> I had the monad epiphany today. For me, it was reading the category theory origins that did it, though that may have just been the last straw.
16:19:13 <oerjan> hm, actually proc is not an indentation keyword, but the arrow notation does add "rec"
16:31:54 <byorgey> shepheb: congrats! =)
16:32:00 <byorgey> shepheb: that's what did it for me too.
16:32:43 <shepheb> byorgey: haha, thanks. there are as many monad tutorials as there are Haskellers, it sometimes seems. I suppose I have to get going on mine as a rite of passage.
16:33:23 <shepheb> the machinery analogy in the wikibook helper at first, but the core understanding came from the theory, for me.
16:33:30 <shepheb> helped, even
16:48:49 <vincenz> @hpaste
16:48:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:49:04 <hpaste>  vincenz pasted "Fraction" at http://hpaste.org/5209
16:51:21 <xpika> I need a haskell greatest common factor function
16:51:28 <xpika> sorry
16:51:37 <xpika> greatest factor function
16:51:47 <xpika> eg. 15 -> 5 12 -> 4
16:51:47 <vincenz> @src Identity
16:51:48 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:52:12 <Cale> xpika: wait... what?
16:52:19 <LoganCapaldo> 15 -> 15, 12 -> 12 ;)
16:52:23 <bos> is there any way to recover the value constructor used to build a value via Data.Typeable?  i don't see anything.
16:52:33 <Cale> 15 = 5 * 3
16:52:38 <BMeph> xpika: greatest prime factor, right? ;)
16:53:00 <LoganCapaldo> 4 isn't prime
16:53:08 <_alf_> wouldn't be consistent with 12->4
16:53:11 <Cale> Oh! Those were separate transitions!
16:53:17 <xpika> sorry just largest factor
16:53:30 <Cale> xpika: The largest nontrivial factor?
16:53:32 <_alf_> largest factor not equal to itself you mean
16:53:38 <BMeph> Ah, got it.
16:53:39 <_alf_> 15 divides 15
16:53:39 <xpika> yep
16:53:42 <Cale> xpika: Find the smallest prime factor, then divide by it.
16:54:21 <oerjan> bos: i think that's in the Data class, not Typeable
16:54:43 <LoganCapaldo> > maximum $ filter (\x -> 15 `mod` x == 0) [1..14] -- brute force! :p
16:54:45 <lambdabot>  5
16:54:48 <bos> oerjan: the what?
16:54:59 <Cale> bos: Data.Generics
16:55:33 <uccus> anyone interested in reviving hIDE?
16:55:36 <Cale> bos: Specifically toConstr
16:55:38 <bos> ah yes.
16:55:40 <bos> thanks.
16:56:12 <oerjan> :t Data.Generics.toConstr
16:56:14 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr
16:56:14 <LoganCapaldo> > (\n -> maximum $ filter (\x -> n `mod` x == 0) [2..(n - 1)]) 12 -- brute force! :p
16:56:15 <lambdabot>  6
16:56:34 <Cale> > let y = head $ filter (\x -> 15 `mod` x == 0) [2..15] in 15 `div` y
16:56:34 <lambdabot>  5
16:56:35 <wagle> Results 1 - 10 of about 718,000,000 for "hIDE"
16:57:08 <LoganCapaldo> Cale: I find your code interesting and wish to subscribe to your newsletter
16:57:23 <mauke> @where hide
16:57:24 <lambdabot> http://haskell.org/haskellwiki/HIDE
16:57:37 <LoganCapaldo>  @where run
16:57:46 <wagle> point still remains that its hard to find
16:58:04 <mauke> Results 1 - 10 of about 203,000 for haskell hide.
16:58:09 <monochrom> everything is hard to find.
16:58:19 <LoganCapaldo> @google haskell ide
16:58:21 <lambdabot> http://lambda-the-ultimate.org/node/991
16:58:21 <lambdabot> Title: Visual Haskell | Lambda the Ultimate
16:58:22 <monochrom> Finding things is hard. Let's go surfing.
16:58:27 <uccus> I mean, it's been a while and GHC API seems to be popular and Functional Reactive Programming seems to be working fine
16:58:29 * LoganCapaldo fails
16:58:32 <BMeph> Especially things meant to ... hIDE? ;p
16:58:40 <monochrom> hahahahaha
16:58:52 <Cale> I really want something that looks like a mathematica-style notebook interface for GHCi.
16:59:12 * LoganCapaldo has never seen a mathematica notebook style interface
16:59:16 <Cale> One where you could add declarations.
16:59:21 <monochrom> Like using joysticks to scroll the screen?
16:59:27 <Cale> well, no :)
16:59:29 <Saizan> ah
16:59:31 <uccus> well I guess it was Neil who proposed a messenger-like interface for WinHugs :s
16:59:38 * BMeph imagines a Haskell IDE reminiscent of Blender...
16:59:48 * bos wonders why more types don't derive Data.
17:00:09 <Saizan> because Data is scary.
17:00:20 <LoganCapaldo> python people also share Cale's desire apparently (but for python)
17:00:22 <Cale> bos: Because most people don't use Data.Generics all that much, so they don't really think of it.
17:00:25 <monochrom> No, Lore is the scary one.
17:00:44 <LoganCapaldo> monochrom: Oh please tell me there is really a lib named Lore
17:00:52 * uccus has never seen a mathematica notebook style interface and is happy that he's not alone
17:02:06 <Cale> LoganCapaldo: It would fit right in. The basic idea is that your document is a sequence of cells. You can type arbitrary amounts of stuff into a cell, and when you're done, you hit shift-enter, and the cell evaluates. In our case, we'd probably want to distinguish between declaration and expression cells.
17:02:51 <LoganCapaldo> http://library.wolfram.com/infocenter/Conferences/4042/ the irony here is that apaprently the presentation is available for download as some kind of .nb file (I assume is short for notebook). If I could open it, I wouldn't need to
17:02:52 <lambdabot> Title: The Mathematica Notebook Interface -- from Wolfram Library Archive
17:03:06 <Cale> LoganCapaldo: You can get a free mathematica viewer.
17:03:20 <monochrom> Yes, .nb file is mathematica file.
17:03:21 <Cale> http://www.wolfram.com/products/player/
17:03:21 <lambdabot> Title: Wolfram Mathematica Player: Free Interactive Player for Mathematica Notebook Doc ...
17:03:36 <monochrom> Gosh, "Player".
17:03:53 <monochrom> Next time we will tell newbies "ghci is the haskell player"?
17:03:56 <Cale> heh :)
17:04:31 <LoganCapaldo> Well I'm assumign I can't use the player to actually do math
17:04:37 <Cale> right
17:04:54 <Cale> It just displays notebooks and lets you interact with the content that's already in them.
17:06:03 <oerjan> @where pivotal
17:06:04 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal
17:06:14 <LoganCapaldo> I'd like a programmable notebook but one that was primarily notebook, and less so programmable
17:06:17 <Cale> Yeah, pivotal sort of works in that direction.
17:06:24 <Cale> But it's not GHC.
17:06:48 <LoganCapaldo> just as a random aside
17:07:14 <LoganCapaldo> pictures for the equally ignorant as I http://images.google.com/images?client=safari&rls=en&q=mathematica+notebook+interface&ie=UTF-8&oe=UTF-8&um=1&sa=N&tab=wi
17:07:15 <lambdabot> Title: mathematica notebook interface - Google Image Search, http://tinyurl.com/ynrc9b
17:07:23 <Cale> The cool thing about Mathematica 6 is that they have this very FRP-esque way of constructing user interfaces dynamically.
17:07:42 <uccus> thanks LoganCapaldo
17:07:53 <Cale> http://reference.wolfram.com/mathematica/tutorial/HTMLImages/DoingComputationsInNotebooks.en/1.gif -- this is a good example
17:07:53 <lambdabot> http://tinyurl.com/yuxkez
17:08:52 <uccus> Cale, the picture doesn't exactly demonstrate what you are talking about
17:09:16 <Cale> Uh, it demonstrates a plain notebook interface, not the FRP stuff.
17:09:23 <Cale> The bold text (and the comment cells), were entered by the user. After pressing shift-enter in a code cell, the code is sent to the kernel which evaluates it and sends data back to the frontend to be displayed.
17:09:45 <Cale> Graphics are represented as expressions consisting of drawing instructions which the frontend interprets.
17:09:58 <Cale> (but they can still be taken apart with code)
17:10:04 <uccus> you mean the "player" interprets?
17:10:18 <Cale> Well, the player, or the full mathematica frontend.
17:10:51 <Cale> The difference being that the player just takes static data and interprets it just as the frontend would, but is missing a connection to a backend to do any other computations.
17:12:06 <uccus> okay, so if GHCi had a box and you type in it and when you press shift-enter or something like that then the whole thing gets submitted to the interpreter, is that what you want or is it something more that I missed?
17:12:52 <Cale> The results come back and the frontend displays them as something -- depending on the type of result, maybe not directly as text.
17:13:14 <Cale> (though this is the sort of thing you'd add once you had the basics worked out.)
17:13:43 <Cale> For Haskell code, we'd actually want two kinds of code cells, probably automatically distinguished between just by their content: expressions, and declarations.
17:14:00 <Saizan> cells are reditable after shift-enter?
17:14:04 <Cale> yep
17:14:14 <Cale> and hitting Shift-enter will reevaluate them
17:14:14 <uccus> expressions... you give out the answer, declarations, you remember them, and that's it?
17:14:31 <Cale> uccus: Basically, to start with.
17:15:12 <uccus> oh not at all, Saizan asked the question that makes the adventure worthwhile
17:15:13 <Cale> uccus: Later on, you might get results back from the backend which represent user interface elements and dynamically updated values.
17:15:16 <uccus> yay!
17:15:19 <uccus> I'm up for it?
17:15:22 <uccus> !
17:16:05 <Saizan> i wonder about namespaces
17:16:38 <Cale> What would be really cool is if we could detect dependencies automatically.
17:17:10 <Saizan> so you can reevaluate depending expressions?
17:17:22 <Saizan> *dependant
17:17:26 <Cale> So if you update a declaration cell and commit it, the evaluated expression cells which depend on it will get reevaluated, or at least marked, indicating that they're not current.
17:17:33 <uccus> so dependent expressions automatically get reevaluated
17:18:09 <uccus> usually, Cale, USUALLY, a GHCi session is not that complicated
17:18:25 <monochrom> "dependently" "typed" expressions :)
17:18:51 <Saizan> there are a lot of ways a cell can depend on another though
17:19:10 <Cale> uccus: But sometimes you have expressions which would take a long time to evaluate, so it would be nice to have a toggle for the automatic updating stuff.
17:19:43 <Cale> (and sometimes you need to change more than one definition to make the code valid)
17:19:57 <LoganCapaldo> eh update each cell in it's own thread (modluo dependencies)
17:20:00 <LoganCapaldo> :)
17:20:19 <LoganCapaldo> let you keep doing other things
17:20:26 <Saizan> you still have a limited amount of cpus :)
17:20:40 <uccus> Saizan was worried about namespaces
17:20:40 <LoganCapaldo> well you know
17:20:44 <monochrom> Just par them all. Let the computer sort them out.
17:21:36 <Saizan> yeah, and how you'd extract those cells back to haskell modules
17:22:02 <Saizan> since if i have a long complicated session i'd like some code out of it :)
17:22:39 <monochrom> declaration cells go straight to a module if you order "export to module".
17:23:19 <uccus> actually, that would make declaration cells immensely useful
17:23:31 <BMeph> Right-Click drag, man, right-click drag! ;p
17:26:21 <uccus> I found ndm's abandoned plan: http://www.haskell.org/haskellwiki/WinHugs/Future
17:26:21 <lambdabot> Title: WinHugs/Future - HaskellWiki
17:26:51 <Cale> monochrom: Preferably a literate module, possibly including your evaluated expressions as comments :)
17:27:00 <totimkopf> hello all
17:27:09 <uccus> it's a lot simpler than day-dreaming about GHCi 2011 but it's a start
17:28:05 <totimkopf> is it possible to truncate a substring? i just mean for example, "rootword" and i'd like to just grab "root" and discard "word"
17:28:28 <Cale> > take 4 "rootword"
17:28:28 <lambdabot>  "root"
17:28:36 <totimkopf> nice
17:28:36 <Cale> like that?
17:28:38 <totimkopf> yes
17:28:43 <totimkopf> thats very nice :)
17:29:10 <istarex> Here's a question for you all
17:29:23 <oerjan> > drop 4 "rootword"
17:29:24 <lambdabot>  "word"
17:29:29 <istarex> Earlier in th week on haskell-cafe, somebody asked about switching ghc to use bytestrings instead of [Char] by default
17:29:32 <oerjan> > splitAt 4 "rootword"
17:29:33 <lambdabot>  ("root","word")
17:29:42 <istarex> and it was stated that for smaller strings, ByteString was more inefficient
17:29:59 <istarex> I've been thinking about it, and I guess I'm having trouble understanding why
17:30:12 <istarex> is there some kind of minimal buffer size that a ByteString is written into
17:30:18 <istarex> regardless of the # of chars in the String?
17:30:53 <istarex> or is it the inefficiency of working through the FFI?
17:31:22 <newsham> *groan* spj on radio show..   the hosts arent terribly bright.  hard to listen to :)
17:31:50 <monochrom> Yes, ByteString uses something like 64KB buffers.
17:31:56 <mauke> it's all OMG DOT NET!!!
17:32:00 <istarex> oh
17:32:13 <istarex> okay, I think I see why :-)
17:32:21 <newsham> "I think I heard of that before.  it was called 'short circuit evaluation'!"
17:32:24 <newsham> *groan*
17:32:52 <totimkopf> hmm, i lust for haskell source code
17:33:02 <LoganCapaldo> Man 64KB really? Is that at all tunable?
17:33:13 <monochrom> Currently hardcoded.
17:33:33 <newsham> tot: you might find some here http://darcs.haskell.org/
17:33:34 <lambdabot> Title: Index of /
17:33:37 <dons> totimkopf: perhaps look on hackage.haskell.org ?
17:33:42 <dons> or darcs.haskell.org or code.haskell.org
17:33:52 <dons> there's millions of lines
17:34:19 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- or here, there's links to packages
17:34:24 <BMeph> "billions and billions", even. ;)
17:34:30 <dons> well, not billions
17:34:38 <dons> but there are millions of lines of haskell
17:34:39 <uccus> so should I nudge ndm a bit about the mathematica-notebook interface? :s
17:34:42 <Cale> http://haskell.org/onlinereport/standard-prelude.html -- but here's the first piece of code I'd recommend reading
17:36:07 <newsham> omg, its full of stars
17:36:21 <newsham> a thousand points of light
17:36:37 <monochrom> Maybe I'm wrong about ByteString buffer size.
17:37:08 <uccus> dons, do ByteStrings use 64KB buffer?
17:37:41 <Cale> Yay, there's a math reddit now :)
17:37:58 <monochrom> onoes
17:38:15 <BMeph> Heh-heh, mathit. ;)
17:38:38 <Cale> I can start posting all the catsters videos there without having them downmodded into oblivion by all the anti-intellectuals on the programming reddit.
17:39:04 <monochrom> Haha, that's good news.
17:39:45 <Cale> Programming reddit really has jumped the shark though. We might be able to just create a CS reddit, and use that instead.
17:40:04 <Cin> does anyone know if it's possible to see if a thread of a specific id is still running?
17:40:04 <newsham> hmm.. there were sharks in that tank?
17:40:13 <Cin> (in ghc)
17:41:23 <monochrom> defaultChunkSize is 32KB minus small constant, smallChunkSize is 4KB minus small constant. The small constant is there for a reason. See http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/src/Data-ByteString-Lazy-Internal.html
17:41:23 <Cale> Cin: hmm, you could throw it an exception...
17:41:23 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/ywvvz2
17:42:06 <Cin> cale: i actually want to kill the thread. but it doesn't say if killThread cares if the thread exists or not
17:42:28 <Cale> Cin: I doubt it'll care.
17:42:32 <Cin> oh
17:42:40 <Cin> apparently killThread sends an exception anyway
17:42:42 <Cin>  killThread tid = throwTo tid (AsyncException ThreadKilled)
17:42:44 <Cale> right
17:43:24 <Cin> well, that's ok
17:43:24 <monochrom> killThread works fine if the thread doesn't exist.
17:43:37 <Cin> monochrom: good. thanks
17:44:01 <mauke> are thread ids reused?
17:44:18 <Cale> Cin: in fact, if you hang on to a thread id, the thread itself won't be GC'd
17:44:28 <Cale> (you have a pointer to the thread)
17:45:30 <LoganCapaldo> if a haskell process completely daemonizes itself, and closes all IO, will the runtime GC it? <g>
17:46:01 <Cale> LoganCapaldo: Well, if your main thread terminates, the program ends.
17:46:12 <Cin> i have two threads operating on one socket (reading from it and writing to it). so if one fails i want the exception to be caught, the other thread to be closed, and the socket closed. should be able to achieve with catch or somesuch and killThread
17:47:02 <monochrom> Yes. You can even have them kill each other.
17:47:02 <Cale> Normally, you handle that with bracket.
17:47:06 <Cale> But yeah.
17:48:11 <LoganCapaldo> I was mostly kidding. I meant if ghc could proive you did no more IO, so the main thread might as well be terminated :)
17:48:21 <Cin> mauke: good point. wouldn't want it killing a newly spawned thread of the same id
17:48:21 <Cale> LoganCapaldo: yeah. :)
17:49:10 <Cale> Cin: Of course, by what I said just after mauke's comment above, a thread id can't be reused for another thread until the threadid itself is GC'd.
17:49:50 <Cale> (So it reuses ThreadId's but there's no way for you to be able to tell that it does this.)
17:50:34 <Cin> cale: ahhh. so by simply having the threadid you are keeping it from being used elsewhere. so kill the thread, then lose the id
17:50:40 <Cale> right
17:50:45 <Cin> makes sense
17:54:51 <arjuna> does people wait for me?
17:56:20 <LoganCapaldo> monochrom: so theoretically based on the interface provided in that file you could have smaller bytestrings w/o diving into C code
17:59:31 <monochrom> I don't understand that sentence, but don't worry about me.
18:00:01 <LoganCapaldo> heh
18:00:31 <LoganCapaldo> ii mean you can create bytsestrings w/ chunksizes other than the default
18:27:40 <sclv> ?go tryruby
18:27:40 <lambdabot> http://tryruby.hobix.com/
18:27:40 <lambdabot> Title: try ruby! (in your browser)
18:28:02 <sclv> ^^ is the awesomest language tutorial ever. we need something like that for haskell.
18:28:22 <Cin> i wrote something similar for scheme
18:28:39 <Cin> isn't running at the moment, though.
18:29:26 <Cin> http://rtfs.ath.cx/tryscheme/tryscheme.htm
18:29:27 <lambdabot> Title: Try Scheme!
18:29:28 <Cin> etc. >_>
18:30:13 <vincenz> doesn't work
18:30:38 <Cin> i'm not running the scheme server at the moment
18:30:47 <Cin> takes up loads of memory -_-
18:31:22 <vincenz> Cin: how'd you make the repl
18:31:58 <Cin> vincenz: wrote it in javascript. the code is quite horrific but it supports the popular browsers (sans safari)
18:31:59 <cdsmithus> Ack!  I'm having a horrible time trying to do stuff with Data.Graph.
18:32:10 <vincenz> Cin: yoursel?/
18:32:45 <Cin> vincenz: yeah. it connects via "ajax" to the scheme server to a live scheme sandbox (or connected...)
18:32:56 <vincenz> http://rtfs.ath.cx/bloodypencils.jpg
18:33:11 <vincenz> Cin: I've always wondered, what does ajax communicate
18:33:12 <Cin> hey! stop that. -_-
18:33:48 <vincenz> Cin: put an index.html in your root :D
18:35:19 <Cin> vincenz: it is one object in javascript called the xmlHttpRequest object which sends a GET or POST request to a web server and gets the response back via a callback to be called when the response arrives. i.e. myHttpObject.responseText. ajax is just the name for various ways of exploiing this nifty functionality
18:35:47 * vincenz has heard of aja
18:35:53 <vincenz> I always wonder what it uses as communication
18:35:57 <vincenz> xml seems a bit heavy
18:36:31 <Cin> indeed. resonseText is just the plain text that the server responds with. you don't necesarily need to use xml
18:36:48 <EvilTerran> ... not a very well-named function, then
18:37:28 <vincenz> Cin: can you communicate images via ajax?
18:37:28 <Cin> well, it has stuff for doing xml, but you don't have to use XML, is what i am saying
18:37:59 <Cin> vincenz: i haven't heard of that. javascript's support of loading images from urls on the fly would probably be better suited?
18:38:11 <vincenz> oh :)
18:39:20 <vincenz> Cin: I guess you use PLT for that to ensure people can't access files?
18:39:36 <vincenz> (and the assocciatd code it comes with for sandboxes)
18:39:43 <Cin> vincenz: yeah
18:40:00 <Cin> file access, memory and execution time
18:40:52 <geezusfreeek> @users
18:40:53 <lambdabot> Maximum users seen in #haskell: 436, currently: 406 (93.1%), active: 10 (2.5%)
18:41:08 <vincenz> Cin: what's the license on that tryscheme.js
18:42:54 <Cin> vincenz: er, extremely permissive. just don't blame me if it breaks. if i have to pick  a license i'd say the one that the haskell wiki uses
18:43:10 <vincenz> thanks
18:43:42 <Cale> cdsmithus: What are you trying to do?
18:50:45 <EvilTerran> @bot
18:50:45 <lambdabot> :)
18:50:47 <EvilTerran> :)
18:58:40 <sclv> my fav bit of the try ruby tutorial isn't just the repl, but the way it provides a whole managed enviornment.
18:59:14 <sclv> and can keep track of where you're at as you go, hint you to go on, and recognize when you execute commands that should move the tutorial forward.
18:59:39 <newsham> "do you have any venzuelan beaver cheese?" -spj
19:00:24 <dons> i'd like a haskell tut where you win points for getting correct programs
19:00:28 <dons> that unlock new language features
19:00:43 <araujo> newsham, venezuelan?
19:01:00 <newsham> "you now have access to level four control.arrow!"
19:01:05 <newsham> sort of a guitar heros for programming?
19:01:12 <araujo> hah
19:01:17 <mauke> Achievement unlocked!
19:01:32 <newsham> araujo: monty python cheese skit, quoted by spj on the dot-net radio show thing
19:01:40 <newsham> when they say he looks like michael palin
19:01:48 * oerjan doubts control.arrow would be anywhere that low in levels
19:01:58 <araujo> newsham, haha
19:05:02 <totimkopf> how does haskell handle command-line arguements?
19:05:11 <EvilTerran> ?hoogle command
19:05:12 <newsham> ?hoogle getArgs
19:05:15 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
19:05:15 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
19:05:15 <lambdabot> System.Environment.getArgs :: IO [String]
19:05:16 <EvilTerran> hm.
19:05:24 <EvilTerran> yes, newsham's right. ignore me. :P
19:05:40 <totimkopf> ?hoogle getArgs
19:05:41 <lambdabot> System.Environment.getArgs :: IO [String]
19:05:44 <totimkopf> ok
19:05:47 <totimkopf> thanks :)
19:15:11 <dbueno> Does anyone work with large data sets as are often seen in, e.g. machine learning?  I'm trying to come up with a general way of parsing data....
19:15:50 <dbueno> My current data set has both Float and Int attributes, but in general a data set may have some String, some Numeric, etc. attributes ... and I'm trying to think how to parse all this data into a suitable data structure.
19:16:45 <Cale> dbueno: Start by defining a data type consisting of the collection of attributes you're interested in.
19:17:21 <dbueno> Cale: so I have a CSV file... so I'm not sure what you mean.
19:17:26 <Cale> dbueno: If you're parsing this data from a file, pick your favourite parser combinator library (perhaps Parsec, or ReadP), and write a parser which produces a value of that type.
19:17:45 <Cale> Oh, if it's CSV, then you'll likely want a specialised CSV parser.
19:18:00 <dbueno> Right, I can think how to parse *this* data, but I can't think of a way to parse this data *so that parsing the next round of data will be easier*.
19:18:02 <Cale> You can get one from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/csv-0.1.1
19:18:04 <lambdabot> http://tinyurl.com/2yw6hp
19:18:27 <dbueno> Cale, thanks, didn't know about that one.
19:18:46 <dbueno> I googled for csv haskell, but, forgot hackage.
19:19:03 <newsham> http://www.thenewsh.com/%7Enewsham/x/csv.hs
19:19:16 <newsham> oh, already a hackage one?  heh..
19:19:20 <newsham> if i had known yesterday
19:19:47 <Cale> Parsing CSV correctly is actually pretty tricky.
19:20:04 <newsham> I just handled   "quoted strings",and,comma,separated,ones
19:20:10 <newsham> which is what my data provider was giving me
19:20:28 <dbueno> newsham: Thanks.
19:20:36 <newsham> huh, someone made an RFC for CSVs.. heh
19:21:19 <dbueno> The harder problem is the right rep for the data after the CSV is parsed.  Maybe if I make a variant type containing each type of attributes I'm interested in, then have an array of thet variant type.
19:21:55 <newsham> usually columns are fixed, so you can do something like:    let [a,b,c,d] = cvs line in (read a, read b, read c, read d)
19:22:06 <newsham> :: (Int, Float, Float, Int)
19:22:28 <dbueno> newsham: The problem with tuples is I can't do all the nice things over them I can do with arrays/lists.
19:22:37 <newsham> so put them into a record?
19:22:37 <dbueno> map/fold/etc.
19:22:54 <newsham> you can use a list if you have a homogenous field type
19:22:59 <dbueno> newsham: A record?
19:23:02 <newsham> if you dont, then map doesnt really make sense
19:23:22 <newsham> data MyRec = MyRec { foo :: Int, bar :: Float } ...
19:23:23 <dbueno> The homogeneity is at the class, not data type, level.
19:23:40 <newsham> you can map across a list of tuples, dbueno
19:24:00 <newsham> or you can use records, which are a fancy form of a tuple
19:24:13 <newsham> or normal algebraic data type
19:24:17 <dbueno> newsham: Yes, but I want to map across the tuple.
19:24:30 <newsham> dbueno: then you probably want a list, not a tuple
19:24:36 <dbueno> For example, if each tuple is a point in a vector space, and I want to calculate the distance between points,
19:24:39 <newsham> and you want to make sure that the items are all of the same type
19:24:52 <dbueno> but the features making up a point might have heterogenous types.  i.e. some strings and ints.
19:25:01 <dbueno> And the distance function is suitable overloaded for such types (say).
19:25:12 <dbueno> newsham: That's the problem; they aren't of the same type.
19:25:26 <newsham> so you want   data Point = Point (Float,Float,Float) String etc.. ;
19:25:36 <newsham> you're not mapping across the tuples, dbueno
19:25:41 <mauke> @where syb
19:25:42 <lambdabot> http://www.cs.vu.nl/boilerplate
19:25:42 <newsham> you're mapping across a collection of those
19:25:57 <dbueno> newsham: The mapping is the distance calculation between two tuples.
19:26:04 <geezusfreeek> yeah, i was about to link in syb too
19:26:10 <dbueno> Thing of euclidean distance for normal vectors in R^3.
19:26:17 <newsham> dbueno: and if each tuple represents one point, you're not mapping across the elements n that tuple
19:26:26 <newsham> lets say your tuple is   (x,y,z,name)
19:26:32 <newsham> of type (Float, Float, Float, String)
19:26:38 <newsham> what is the map operation you want to do?
19:26:51 <cdsmithus> Cale: Sorry, didn't see your message.  I'm trying to find all cycles in a graph; I think I got it now.
19:27:03 <dbueno> for each element of the respective tuples, calculate the "distance" between those two features; add all the distances together.
19:27:08 <dbueno> That's a map + sum.
19:27:19 <newsham> right, its a map and a sum, but not a map over the tuple
19:27:23 <newsham> its a map over a list of tuples.
19:27:34 <dbueno> We're comparing two tuples.  There's no list, though.
19:27:58 <newsham> dist (x,y,z,name) (x',y',z') = sqrt ((x-x')+(y-y')+(z-z'))
19:28:21 <newsham> err, lets say my args were backwards (oops)
19:28:23 <dbueno> Yes.  I'm aware it can be written that way, every time, for every possible combination of features and lengths.  But I want to write it once.
19:28:29 <newsham> you wan t   map (dist (1,3,5)) mydataset
19:28:44 <newsham> ok, either i am failing to understand you
19:28:49 <newsham> or you are failing to understand me
19:29:01 <dbueno> So, forget the tuples for a moment and imagine lists.
19:29:17 <dbueno> If all my data were Ints (say), and each point is a list of Ints, then the distance function could be:
19:30:02 <dbueno> dist l1 l2 = sqrt (sum (\(i1, i2) -> dist i1 i2) (zip l1 l2))
19:30:30 <dbueno> So I'm doing a sum, but, I mean, it's like a map.  It's defined once for any number of dimensions.
19:30:32 <oerjan> what about simply having a data type with a constructor for each possible type a field could contain?
19:30:42 <geezusfreeek> i'
19:30:47 <newsham> dbueno: and your CSV dataset will come with any number of dimensions?
19:30:50 <oerjan> then you could use a list of those
19:30:56 <dbueno> newsham: I'll be working with many data sets.
19:30:58 <geezusfreeek> *i'm really confused about what exactly is going on here
19:31:10 <newsham> dbueno: so use a list representation for the point coordinates
19:31:39 <newsham> ifyou have other data items that arent point coordinates, they can coexist in a record and/or tuple
19:31:46 <newsham> ie:   (String, [Float])
19:32:16 <dbueno> oerjan: That would work. It requires extra checking at run-time, for each type.  And right now my `dist` function is overloaded via a type class -- I'd have to get rid of that with your approach, and check at runtime, right?
19:33:16 <oerjan> dbueno: the alternative would be some more type class hackery to get mapping/folding over heterogeneous tuples.  isn't that what HList does?
19:33:36 <dbueno> oerjan: I'll check HList out.
19:33:40 <geezusfreeek> a type class is a runtime "check" anyway
19:34:05 <oerjan> geezusfreeek: but not one that can fail
19:34:10 <geezusfreeek> true
19:34:19 <newsham> class Point where  zip :: Point -> Point -> Point; sum :: Point -> Float
19:34:32 <newsham> instance Point (Float,Float) where sum (a,b) = a+b
19:34:51 <newsham> zip f (a,b) (a',b') = (f a a', f b b')
19:35:21 <oerjan> newsham: that class syntax is not right, you want a type variable
19:35:23 <monochrom> Be careful with using the names zip and sum.
19:35:23 <dbueno> newsham: Requires an instance for each point type, right?  My data sets may have hundreds of attributes per point, unfortunately.
19:35:39 <newsham> dist :: Point -> Float    dist p1 p2 = sqrt $ sum $zip subtract p1 p2
19:35:50 <newsham> dbueno: then lists sound preferable :)
19:35:56 <LoganCapaldo> instance (Floating a) => Point (a, a) perhaps?
19:36:07 <geezusfreeek> based one what i have read, i still think syb would be best for something this crazy
19:36:25 <EvilTerran> instance Point Float where sum = id; zip = id; instance Point a => Point (Float,a) where sum (x,xs) = x + sum xs; zip f (x,xs) (y,ys) = (f x y, zip f xs ys)
19:36:38 <EvilTerran> being a Q&D version of HList
19:36:58 <newsham> evily delicious
19:37:09 <LoganCapaldo> now with more crunchy bits
19:37:18 <newsham> I often wish (a,b,c) === (a,(b,c))
19:37:39 <EvilTerran> newsham, yeah, aside from it breaking the type system ,that would be quite handy
19:38:02 <newsham> why does it break the type system?  Isabelle has a type system much like Haskell's and uses that convention.
19:38:17 <newsham> (a,b,c) is just syntactic sugar
19:38:28 <LoganCapaldo> (a,b,c) === (a, (b,c)) but what about (a, undefined) vs. (a, (undefined, undefined))
19:38:33 <monochrom> Isabelle's type system is more powerful.
19:39:08 <newsham> LC: how is that diff from   (b,c) === undefined?
19:39:10 <EvilTerran> what if the second parameter of a tuple's also a tuple?
19:39:17 <EvilTerran> my brain would get confused, to say the least
19:39:20 <monochrom> For example a type class in Isabelle comes with axioms.
19:39:34 <newsham> evil: it always is ;-)
19:39:46 <monochrom> To get a type into a type class, you have to write a proof of satisfaction of the axioms, and the computer checks it.
19:39:51 <EvilTerran> actually, i think what i was thinking of was the problem with having generic "get the nth element" functions in such a system
19:39:51 <LoganCapaldo> because you can case foo of (a, (_, _)) in the later but not the former
19:40:15 <geezusfreeek> monochrom: so that would mean things like the monad laws can be statically checked?
19:40:20 <LoganCapaldo> or rather case foo of (a, _, _)
19:40:23 <monochrom> Yes.
19:40:29 <dbueno> newsham, oerjan: Thanks for your help; I'm checking out HList now.
19:40:38 <newsham> ET: you can't write a generic "get-nth" except using type-level computations
19:40:38 <EvilTerran> dbueno, did you see my suggestion?
19:40:59 <dbueno> EvilTerran, yes, then I saw that it was a quick-n-dirty HList, so I thought, I'll just use that. =]
19:41:08 <dbueno> Was that misguided?
19:41:16 <EvilTerran> HList is massive overkill for most purposes
19:41:26 <EvilTerran> you don't even *want* heterogeneous collections
19:41:47 <EvilTerran> only homogeneous ones of fixed-but-implicit length that're mappable
19:41:48 <monochrom> Heterogeneous collections are overrated. IMO anyway.
19:42:10 <monochrom> My premise is that downcast is evil and forbidden.
19:42:30 <dbueno> So you encode the heterogeneity in a variant type?
19:42:33 <Cale> monochrom: good premise :)
19:42:44 <jsnx> downcast?
19:42:59 <newsham> db: you could use a normal list.
19:43:08 <monochrom> Without downcast, what's good with a heterogeneous collection? You retrieve an item, if you don't downcast, you can't do anything with the item.
19:43:11 <Cale> jsnx: In languages with subtyping, where you take something of a more general type and interpret it as something of a more specific type.
19:43:16 <jsnx> oic
19:43:22 <jsnx> yes, i agree
19:43:23 <newsham> db:  type MyPoint = [Float]
19:43:26 <jsnx> forbidden
19:43:38 <newsham> dist :: MyPoint -> MyPoint -> Float
19:43:42 <monochrom> downcast means e.g., in C, you take a "void *" and then you say "it's actually vertex3f***"
19:43:47 <newsham> not sure whats unappealing about that
19:43:59 <jsnx> newsham: not checkable at compile time
19:44:11 <newsham> right but for each data set, the number of points will be fixed
19:44:14 <monochrom> C proves that heterogeneous collections are either unsafe or useless.
19:44:18 <dbueno> newsham: I don't just have Floats.  If I did, it would be easy, as you suggest.
19:44:29 <newsham> err number of coordinate dimesnions
19:44:37 <newsham> dbueno: what else do you have?
19:44:57 <dbueno> newsham: Let's say floats, arbitrary-precision ints, strings.
19:45:01 <jsnx> could vertex3f*** be a vertex2f**** ?
19:45:12 <monochrom> God knows.
19:45:19 <faxathisia> 3 star programmer!
19:45:21 <monochrom> Some programmers think they know as much as God does.
19:45:30 <newsham> dbueno: and your points... those will always be n-dimensional floating point numbers?
19:45:43 <mauke> uniplate!
19:45:44 <dbueno> The points are vectors in a vector space.
19:45:51 <LoganCapaldo> OTOH in C++ (assuming RTTI is on dynamic_cast<Foo *> is safer than struct { int tag; union { Foo *f; Bar *b; } }; so yes downcasting is evil, ut sometimes it beats the avaiable alternatives
19:46:16 <newsham> ok, so not arbitrary precision ints or strings
19:46:22 <dbueno> newsham: Each point is n-dimensional, and each of the n dimensions may be either an int, or a float, or a string, or something.  There will then be a bunch of points.
19:46:47 <dbueno> newsham: By vector, I mean list of n things.
19:46:56 <jsnx> wo
19:46:57 <geezusfreeek> sounds like a job for dependent types
19:47:08 <monochrom> My premise is fallible and falsifiable, of course. (That's why I state it honestly as a premise.) (Too many people are dishonest when they debate.)
19:47:10 <newsham> dbueno: and you want a generic  distance :: Point a -> a
19:47:12 <jsnx> dbueno: you could make a union type
19:47:18 <dbueno> newsham: For a given data set, the ith dimension has one type, for every point in the space.  So attribute 3 is always an int, in a given data set, say.
19:47:23 <vincenz> dbueno: sounds like a tuple, not  vector
19:47:29 <newsham> what is   distance ("foo", "bar", "baz") ("FOO", "BAR", "BAZ") ?
19:47:32 <hpaste>  cdsmithus pasted "Can you improve this code? (Data.Graph)" at http://hpaste.org/5210
19:47:56 <dbueno> vincenz: But there may be hundrends of dimensions, so, tuples aren't so convenient.
19:48:08 <dbueno> newsham: It doesn't matter, so long as it's well-defined.
19:48:32 <vincenz> dbueno: use template haskell
19:48:44 <newsham> sounds like you're trying to make this as comlicated as possible :)
19:48:47 <geezusfreeek> this is only going to be compiler checkable using dependent types, which i don't recommend using too heavily in haskell just because it's pretty ugly and cumbersome
19:48:48 <EvilTerran> dbueno, ah, i thought you wanted the same type all the way across
19:48:52 <EvilTerran> yeah, that sounds like HList
19:49:03 <newsham> good luck.
19:49:10 <dbueno> newsham: It's the bread and butter of machine learning.  An *extremely* typical task.
19:49:28 <monochrom> Perhaps you can use Data.Typeable plus existential type when you want to upcast and downcast, in those cases where it gets the job done well.
19:49:53 <dbueno> geezusfreeek: That's not true; I know the types for each data sets.  But I don't want to have to write the code to calculate the distance between 2 113-element tuples.
19:50:09 <dbueno> EvilTerran: Thanks, I'm looking at it now.
19:50:12 <geezusfreeek> dbueno: template haskell then... i wasn't aware that you do actually know the types in advance
19:50:20 <conal> anyone know if antti-juhani is reading is email?  are there alternatives for getting a blog added to planet.haskell.org ?
19:50:27 <conal> (is -> his)
19:50:30 <dbueno> geezusfreeek: Ah, all right.  That's the second thing I'll look it. =]
19:50:31 <Cale> cdsmithus: this use of the writer monad confuses me.
19:50:46 <cdsmithus> Cale: It seemed to get very ugly otherwise
19:50:53 <Cale> cdsmithus: hmm...
19:51:07 <dbueno> jsnx: Sorry I missed your comment; someone earlier said the same thing, and I responded.
19:51:34 <dbueno> jsnx: oerjan suggested that, in case you can scroll up to see.
19:51:58 <cdsmithus> Cale: Maybe I was just thinking about it wrong.  Now it looks easy to remove Writer.  Huh.
19:52:21 <newsham> data Dimension = Float | String | Integer;
19:52:30 <newsham> type Point = [Dimension]
19:52:57 <newsham> dimdist :: Dimension -> Dimension -> Float    -- or some metic type
19:53:10 <monochrom> Remember to "deriving (Typeable, Data)"!
19:53:10 <newsham> dist :: Point -> Point -> Float -- or some metric type
19:53:23 <EvilTerran> newsham, er, that doesn't look quite right...
19:53:29 <newsham> dist ps qs = sqrt $ sum $ zipWith dimdist ps qs
19:53:37 <dbueno> newsham: Yes, that will work -- but it's essentially re-implementing dynamic typing.  If I can get more checking from the compiler, I will (via HList).
19:53:38 <EvilTerran> data Dimension = F Float | S String | I Integer, maybe?
19:53:52 <newsham> db: but its a more restricted dynamic typing
19:53:52 * EvilTerran agrees with dbueno, actually
19:53:53 <dbueno> EvilTerran: I see what he's trying to say, though.
19:54:09 <newsham> dimdist (F f) (F f') = f - f'
19:54:17 <newsham> dimdist (I i) (I i') = i - i'
19:54:21 <EvilTerran> dbueno, there really isn't much more to the "hereogeneous lists" bit of HList than what i suggested, actually
19:54:29 <newsham> dimdst _ _ = error "incompatible types in the same column"
19:54:31 <dbueno> dbueno: Restricted or not, it subverts the compiler in some measure.  Like I said, I may do that, but only after determining that there aren't other, safer options.
19:54:41 <EvilTerran> oleg uses his own datatype instead of pairs, but otherwise it's the same idea
19:55:12 <dbueno> EvilTerran: But the boilerplate lets my types be "more checkable" somehow, right?  (I haven't gotten past the abstract in the paper, yet.)
19:55:17 <EvilTerran> most of the paper's looking at other, similar tricks, like type-indexed hlists (being a nice approximation of extensible records)
19:56:06 <newsham> alternately TH, as mentioned before, can generate your dist functions for arbitrary problem statements (column types)
19:56:25 <newsham> which would give you full type checking
19:56:47 <dbueno> newsham: Right.  I'm exploring that if HList doesn't pan out.
19:57:00 <visof> @src halv
19:57:00 <lambdabot> Source not found. Where did you learn to type?
19:57:00 <hpaste>  cdsmithus annotated "Can you improve this code? (Data.Graph)" with "Next attempt" at http://hpaste.org/5210#a1
19:57:18 <newsham> if you dont like a dynamically checked dimensions type you're not going to like hlists any more
19:57:50 <oerjan> visof: what's that supposed to be?
19:57:53 <dbueno> newsham: It's not the dimension that I want to check; I want the compiler to know that in location 42 of a bunch of points, there lies in Int.
19:57:59 <dbueno> But in location 50, there is a String.
19:58:06 <EvilTerran> newsham, i disagree there; you can zip HLists with a static check that the elements at each index are of matching type
19:58:08 <dbueno> I'm willing to type out all the types at least once.
19:58:09 <EvilTerran> say
19:58:22 <newsham> dbueno: *nod* and thats not going to be known by hlists any more than its known by [Dimension] above
19:58:35 <newsham> oh, ok, ET says I'm wrong.
19:58:36 <newsham> I'm prob wrong
19:58:39 <dbueno> newsham: Section 3 of the paper looks a bit different than what you say....
19:58:58 <Ooziz> #universal is Freenodes Newest Off-Topic Channel. (This message is approved by IRCOps on Freenode.) Join #universal for chats on ALL subjects.
19:58:58 <hpaste>  cdsmithus annotated "Can you improve this code? (Data.Graph)" with "Oops, line got truncated.  Here it is." at http://hpaste.org/5210#a2
19:59:09 <EvilTerran> newsham, the "standard hlist", as it were, is basically isomorphic to the type (a0, (a1, ... (aN, ())...))
20:00:02 <dbueno> Is there a way to generate documentation if you have the cabal Setup.hs file? (Trying to generate docs for HList.)
20:00:11 <EvilTerran> haddock?
20:00:21 <dobblego> ./Setup.hs haddock
20:00:27 <dbueno> EvilTerran: Right, but do you invoke through Setup.hs? -- ahh.
20:00:31 <EvilTerran> newsham, the mind-altering type hackery comes down to trying to do meaningful things with such a type without drowning in type signatures
20:01:00 <dbueno> Type aliases to the rescue!
20:01:08 <dbueno> dobblego: Thanks, that worked.
20:01:14 <dobblego> dbueno, np
20:01:31 <LoganCapaldo> alias fish=./Setup.hs haddock
20:01:34 <monochrom> Does #universal satisfy a universal property?
20:01:39 <EvilTerran> (eg, statically enforcing that each type can only appear once and that a certain type must appear, and then having a class method to pull out the element of that particular type)
20:01:53 <dbueno> LoganCapaldo: O.o 'fish'?
20:02:09 <oerjan> monochrom: for every topic t, t is on-topic in #universal
20:02:10 <EvilTerran> (or any other type, depending on the type enforced on the method by its context)
20:02:45 <monochrom> I mean as in category theory, commuting diagrams and all.
20:02:56 <LoganCapaldo> dbueno: http://images.google.com/images?client=safari&rls=en&q=mathematica+notebook+interface&ie=UTF-8&oe=UTF-8&um=1&sa=N&tab=wi
20:02:58 <lambdabot> Title: mathematica notebook interface - Google Image Search, http://tinyurl.com/ynrc9b
20:03:02 <LoganCapaldo> thats not the right link
20:03:10 <LoganCapaldo> http://en.wikipedia.org/wiki/Haddock
20:03:11 <lambdabot> Title: Haddock - Wikipedia, the free encyclopedia
20:03:22 <LoganCapaldo> clipboard, you've failed me for the last time!
20:03:28 <dbueno> LoganCapaldo: Duh, of course.
20:03:45 * LoganCapaldo takes out a hit on his clipboard
20:04:31 <scook0> @hoogle elem
20:04:32 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:04:32 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
20:04:32 <lambdabot> Data.Foldable.elem :: (Foldable t, Eq a) => a -> t a -> Bool
20:04:56 <dbueno> Looks like haddock barfed on this line: "type e :*: l = HCons e l"
20:05:08 <scook0> :t all
20:05:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:05:15 <LoganCapaldo> wait wait
20:05:19 <dbueno> Sorry, I should probably be googling for such an error.
20:05:26 <LoganCapaldo> you can have infix type _aliases_
20:05:30 <LoganCapaldo> !?
20:05:31 <oerjan> dbueno: aye, infix type constructor
20:05:36 <EvilTerran> dbueno, that's not surprising; haddock uses a haskell parser that can only to H98, i think
20:05:39 <EvilTerran> so no infix types
20:05:44 <EvilTerran> *only do
20:05:47 <LoganCapaldo> I knew you could have infix type ctors
20:05:54 <LoganCapaldo> but aliases?
20:05:59 <LoganCapaldo> Madness!
20:06:06 <dbueno> Does that mean I can't generate documentation?  Is there another way?
20:06:07 <EvilTerran> you can have infix classes, too :D
20:06:19 <arjuna> oi we will kill you pussy off
20:06:40 <dbueno> Ooh, I guess upgrade haddock. http://www.haskell.org/haddock/CHANGES.txt
20:06:47 <EvilTerran> dbueno, if you modify that line to type (:*:) e l = HCons e l, that might work
20:06:56 <EvilTerran> or do that, yeah :)
20:07:06 <EvilTerran> are you using GHC 6.8.2?
20:07:07 <dbueno> But to upgrade I have to subvert macports.
20:07:10 * dbueno pouts
20:07:13 <dbueno> EvilTerran Yes.
20:07:18 <EvilTerran> gdgd
20:07:34 <LoganCapaldo> bring on the infix type con vars! (Arrow (:~>)) => a :~> b
20:08:00 <faxathisia> I like those
20:08:04 <EvilTerran> class a :<: b
20:08:07 <EvilTerran> :D
20:08:11 <dbueno> How can I query my Cabal version?
20:08:47 <EvilTerran> unfortunately, infix classes don't seem to work in instance headers, but they work fine in class headers and contexts
20:08:55 <cjb> dbueno: > Distribution.PackageDescription.cabalVersion
20:09:25 <dbueno> cjb: Dang; thanks.
20:09:38 <EvilTerran> this foiled my plan to have a class (:=:) and do snazzy, natural-looking type-level arithmetic
20:09:58 <cjb> dbueno: You're welcome.  I think this is possibly the first time I've ever answered a Haskell question; I asked the same one earlier today :)
20:10:13 <EvilTerran> (instance a :+: Zero :=: a; instance (a :+: b :=: c) => a :+: Succ b :=: Succ c)
20:10:39 * dbueno can't parse what EvilTerran wrote.
20:10:49 <LoganCapaldo> EvilTerran: You're really earning that nickname of yours
20:11:03 <EvilTerran> dbueno, it involves having an infix, two-parameter type class called :=:
20:11:12 <EvilTerran> and a two-parameter type called :+:
20:11:31 <EvilTerran> data a :+: b -- phantom type, no constructors
20:11:45 <EvilTerran> data Zero; data Succ a -- likewise
20:11:57 <EvilTerran> LoganCapaldo, ty. i try. :)
20:12:01 <dbueno> I'd have to stare at that for a bit.
20:12:11 <EvilTerran> it'd be like saying
20:12:44 <EvilTerran> instance Equal (Add a Zero) a; instance Equal (Add a b) c => Equal (Add a (Succ b)) (Succ c)
20:12:44 <faxathisia> I use :=: sometimes
20:12:59 <faxathisia> And ::: for type level ::
20:13:01 <EvilTerran> it's just the type-level peano numbers
20:13:13 <EvilTerran> faxathisia, type-level ::? whoa
20:13:29 <dbueno> EvilTerran: Oh, I think I see.  The conversion-to-prefix was my problem.
20:14:19 <EvilTerran> fax, what goes on the RHS of :::? another phantom type?
20:14:53 <faxathisia> If you have a term language where types are terms
20:15:58 <faxathisia> I might have misused the term 'type level'
20:15:59 <arjuna> how to rat on someone or tell on someone? is it the same thing? :D thank you
20:16:09 <dbueno> What might cause haddock to report no error but still generate no documentation?
20:16:23 <oerjan> strange low-volume spammer...
20:16:37 <faxathisia> oerjan, Who?
20:16:39 <joed> A thinker?
20:16:44 <oerjan> faxathisia: arjuna
20:16:58 <EvilTerran> dbueno, the impossible happening, maybe?
20:17:04 <faxathisia> oh, becuase Ooziz just got klined
20:17:54 <oerjan> faxathisia: or possibly just a markov bot
20:18:20 <arjuna> <oerjan> yes?
20:18:23 <dbueno> EvilTerran: Not sure; I upgraded haddock and it reports the right version (2), and it runs without the error I had before; but there are no new HTML files afterward.
20:18:45 <oerjan> arjuna: can you prove you are human?
20:19:05 <dbueno> Ah, a clean and configure and build and re-haddock, and I get something different.  Ignore me.
20:19:34 <arjuna> oerjan>  fuck off. omg what a racist bitch
20:19:40 <faxathisia> o_o
20:19:51 <joed> o.0
20:19:55 <dbueno> =O
20:19:59 --- mode: ChanServ set +o vincenz
20:20:08 --- kick: arjuna was kicked by vincenz (Thank you, goodbye)
20:20:11 --- mode: vincenz set -o vincenz
20:20:16 --- mode: ChanServ set +o vincenz
20:20:24 <vincenz> arjuna: second time is permanent
20:20:25 <arjuna> vincenz fuckjing fuck fuck fuck fuck fuck
20:20:47 <EvilTerran> aaand there we go.
20:20:49 --- mode: vincenz set +b *!*@CPE00012e15cab1-CM00194757ed42.cpe.net.cable.rogers.com
20:20:52 --- kick: arjuna was kicked by vincenz (Thank you, goodbye)
20:20:53 <joed> wow..
20:21:08 <EvilTerran> i'm sure i've seen those very lines before, too
20:21:17 <EvilTerran> so either a bot or an established troll
20:21:26 <shepheb> it made a typo so my money's on human.
20:21:30 <dbueno> Now haddock barfs on "-- * -> *"
20:21:44 <dbueno> (The latest stable haddock -- 2.0.0.0 -- is that a bug?)
20:21:54 <EvilTerran> shepheb, i take it you've not encountered any forum spam recently then?
20:22:23 <nelhage> Smells like a bot here, but it's unclear.
20:23:05 <shepheb> EvilTerran: well, I guess it could be a typo in the bot's code. Even if it were a nominal human, it would be debatable.
20:23:54 <shepheb> final "it" there being "the humanity of the intruder"
20:23:55 <nelhage> Either of a typo. Or a intentional effort to make it more human-like. Or whatever.
20:23:55 <EvilTerran> shepheb, exactly; forum span seems to suffer from incredibly poor grammar
20:24:55 <shepheb> but so do human trolls, so again, an impasse.
20:24:55 <EvilTerran> i'd be inclined to never ascribe to malice that which can be adequately explained by incompetence, and conclude that whoever set up the spambots is a moron
20:24:55 <monochrom> Haskell has static type checking.  Spam detection has static grammar checking. :)
20:24:55 <nelhage> Fair enough. I'll buy that.
20:25:12 <monochrom> Anyway, both spammers and incoherent people should be banned. No need to distinguish.
20:25:28 <vincenz> monochrom: you're right
20:25:30 <vincenz> monochrom: Good bye :)
20:25:34 <monochrom> ...
20:25:36 <vincenz> ./kick monochrom
20:25:40 --- mode: vincenz set -o vincenz
20:25:41 <vincenz> :P
20:25:52 <EvilTerran> monochrom wins - it's a moot point, really
20:26:03 <EvilTerran> {-# CHANNEL AllowIncoherentPeople #-}
20:26:17 * monochrom loves the notion of observational equivalence.
20:27:01 <monochrom> In fact Haskell semantics is best defined in terms of observational equivalence, since we have infinite lists etc.
20:27:46 <cjb> I like that this is one of the IRC channels I'm in where I usually have no idea what people are saying.
20:27:58 <shepheb> actually, out of curiousity, is there a set of rules for language etc. on #haskell? I don't want to get into trouble.
20:28:15 <oerjan> @where policy
20:28:15 <lambdabot> I know nothing about policy.
20:29:05 <oerjan> shepheb: i know just one specific rule: it's forbidden to insult newbies
20:29:16 <pjd> shepheb: "be nice"?
20:29:29 <monochrom> Only ban cases I've ever seen are: spam, troll, being acidic.
20:29:34 <EvilTerran> shepheb, golden rule, mostly
20:29:46 * shepheb doesn't hate himself enough to be harsh to newbies.
20:29:52 <shepheb> alright, that works for me. thanks.
20:29:56 <joed> This is one of the friendliest channels you can find actually.
20:30:10 <EvilTerran> http://haskell.org/haskellwiki/IRC_channel#Principles
20:30:19 <Cale> Heh, all the elements of an infinite list are in its first half. The second half consists of an infinite loop.
20:30:32 <oerjan> @where+ policy http://haskell.org/haskellwiki/IRC_channel#Principles
20:30:33 <lambdabot> Done.
20:30:42 <EvilTerran> altho that is, in part, because we're not afraid to ban the abrasive sorts
20:31:04 <shepheb> joed: I've noticed, and I appreciate it. Haskell is intimidating enough to newbies without intimidating people too.
20:31:19 <Cale> We'll keep trolls around for a while if they're amusing, and eventually incorporate them into the bot though.
20:31:25 <Cale> @keal
20:31:25 <lambdabot> T seems to be haskell, except with a decent interface at this point
20:31:37 <shepheb> well, there are intimidating people in Haskell, but they're intellectually intimidating and friendly, a good combination
20:31:49 <joed> Nah, I think the discussions / noise / participation does more for that. Join another language channel and you see more repeat n00b I'm doing this in school and I'm lazy, hence more abuse.
20:31:50 <monochrom> Regarding infinite loop, I just found out very belatedly that Apple's campus names its street "Infinite Loop". Thus its street address is "1 Infinite Loop".
20:32:47 <EvilTerran> do they have 2 infinite loop as well?
20:32:53 <Cale> !paste
20:32:53 <hpaste> Haskell paste bin: http://hpaste.org/
20:33:00 <EvilTerran> (hey, it could work, with lazy evaluation and/or parallelism)
20:33:41 * shepheb struggles on with PE 60
20:34:03 <hpaste>  Cale pasted "lazy halves of a list" at http://hpaste.org/5211
21:19:09 <piojo> for debugging purposes, do people turn pure functions into IO monadic functions?
21:19:49 <int-e> piojo: there's Debug.Trace
21:20:26 <mauke> ghci-6.8 has an integrated debugger
21:20:49 <piojo> well, it's really for a homework assignment that needs (is required to) print some status info
21:21:04 <piojo> will Debug.Trace allow me to print from a pure function?
21:21:39 <andyjgill> yes, it will
21:21:39 <int-e> piojo: then Debug.Trace is wrong, because it provides no guarantees of printing anything, or the order in which messages are printed.
21:21:55 <andyjgill> for function foo x y z = ...
21:22:00 <piojo> int-e: that's probably fine
21:22:11 <andyjgill> you can use foo x y z | trace ("foo",x,y,z) False = undefined
21:22:16 <andyjgill> at the top of the function foo
21:22:30 <mauke> +show
21:22:48 <int-e> @type Debug.Trace.trace
21:22:51 <lambdabot> forall a. String -> a -> a
21:23:49 <piojo> int-e: you said it's not guaranteed to be called. will it be called if the function is called? (i.e., if the result of the function is calculated)
21:23:58 <int-e> piojo: yes
21:24:19 <piojo> thank you. this helps ;)
21:25:14 <gwern> huh. well, I'll be: http://packages.debian.org/sid/ghc6 <- I didn't think GHC would run on GNU Hurd
21:25:20 <lambdabot> Title: Debian -- Details of package ghc6 in sid
21:29:54 <wy> Taking a compiler class. Learning the horrible NFA, DFA, ... Is there really a need to use them? How do they compare with a simple lexer in Haskell?
21:31:58 <lucca> these are the fundamentals of computer science!  learn them well
21:32:30 <ddarius> A simple lexer in Haskell -is- a NFA or DFA.
21:33:24 <wy> I'm stuck at the part of coverting NFA to DFA
21:35:10 <wy> ddarius: I guess the simple lexer might be an NFA? It seems the states are not simplified
21:36:25 <Cale> heh, that ad in the middle of the radio show with Simon was jarring.
21:36:43 <mauke> DOT NET!!!
21:37:46 <ddarius> Typically you'd have a DFA.  A simple way to write a lexer is to write a set of mutually recursive functions that look like: f ('a':cs) = g cs; f ('b':cs) = h cs.  Here f, g, h roughly correspond to states and the first case to an 'a' labelled arc between f and g and the second to a 'b' labelled arc between f and h.
21:37:52 <Cale> It's like, Simon is talking about purity and monads at one point, he finishes his sentence, and the host of the show replies to him with an ad.
21:39:50 <ddarius> An NFA would require modelling non-determinism which is easy enough.  A logic language though would let you map an NFA immediately to code.
21:40:43 <ddarius> E.g. in Prolog f(['a'|Cs]) :- g(Cs). f(['a'|Cs]) :- h(Cs).
21:41:20 <wy> I still guess it's an NFA, because if you have branches, normally all the states reachable is kept
21:42:20 <wy> So at each input character, you have to update each possible tail string in the list
21:42:45 <ddarius> What are you talking about?  Guess that what is an NFA?
21:45:06 <wy> I guess the lexer in the report prelude is NFA
21:46:19 <ddarius> The one for layout?
21:46:31 <ddarius> Or the Read stuff?
21:46:41 <oerjan> :t lex
21:46:42 <lambdabot> String -> [(String, String)]
21:47:18 <wy> I got this paper: http://swtch.com/~rsc/regexp/regexp1.html. As if NFA could be faster
21:47:19 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
21:50:38 <wy> The article is pretty interesting
22:12:34 <Cale> Heh, this guy keeps referring to Prolog as an OO language :)
22:13:01 <geezusfreeek> that .NET rocks thing?
22:13:05 <Cale> yeah
22:13:06 <geezusfreeek> i noticed that too
22:13:59 <shapr`> @yow !
22:13:59 <lambdabot> I joined scientology at a garage sale!!
22:13:59 <wy> Cale: who?
22:14:04 <shapr`> mmm code
22:14:15 <Cale> wy: The host of the .NET rocks radio show.
22:14:26 <Cale> wy: On which SPJ was interviewed.
22:14:29 <geezusfreeek> alright, the sad thing is not that i just rewrote my homework in haskell and it's prettier and shorter. the sad thing is that it's opengl in haskell and it's prettier and shorter
22:14:43 <Cale> :)
22:15:00 <Cale> Haskell is the world's finest imperative programming language :)
22:15:08 <wy> There is Objective Prolog I guess
22:15:54 <Cale> wy: yeah, I'm sure there have been object layers for Prolog, but "object oriented" aren't the first words which come to mind when one thinks of Prolog.
22:16:22 <wy> Cale: right... Simon said that?
22:16:34 <geezusfreeek> no it was the host
22:17:05 <wy> Cale: Can Prolog be considered "bidirectional programming" using the words of Benjamin Pierce?
22:17:54 <Cale> Well, I don't know exactly which sense that would be, not having read Pierce's work, but those words could certainly apply to it.
22:19:19 <Cale> wy: You don't have functions, but instead predicates on values. Functions Y = f(X) are represented as predicates f(X,Y)
22:19:21 <wy> Is prolog early or ML?
22:19:52 <Cale> (such that for a given X, there is exactly one Y which satisfies the predicate)
22:20:02 <geezusfreeek> the only problem with using ghc for open gl stuff is this: Main.o 21K, linked_executable 5.7M
22:20:03 <Cale> But in general, such predicates can be used both ways.
22:20:06 <wy> Interesting. I should really learn some prolog
22:20:17 <ddarius> Yes you should.  And then never ever program in it.
22:20:31 <wy> ddarius: why not? hehe
22:20:33 <geezusfreeek> prolog is definitely a good learn
22:20:36 <allbery_b> if you thought haskell was brain-explodey...
22:20:57 <geezusfreeek> eh i never thought it was any weirder than haskell
22:21:05 <geezusfreeek> not as useful though, in my opinion
22:21:18 <Cale> Programming in Prolog feels somewhat like programming sideways relative to the usual functional model.
22:21:26 <faxathisia> There is object oriented Prologs
22:21:33 <geezusfreeek> makes me wish more databases were Datalog
22:21:34 <faxathisia> I recommend agaist it though
22:21:36 * allbery_b recalls prototyping a constraint-based pricing system in prolog (then the prototype going into production for several months before someone finally realized it was slower than molasses)
22:21:50 <ddarius> wy: Learn it and you'll find out.  Some other logic languages, though, are very nice.
22:22:03 <geezusfreeek> Datalog > SQL
22:22:20 <faxathisia> In Prolog you can certainly white bidirectional code
22:22:25 <Cale> One thing which I really felt Prolog lacked was any equivalent to the abstraction which higher-order functions provide in functional languages.
22:22:37 <faxathisia> Not everything need be though
22:22:53 <allbery_b> didn't someone do map and foldl/r in prolog?
22:22:56 <faxathisia> Cale, I don't find that
22:23:00 <wy> Cale: Is it possible in logic programming?
22:23:01 <allbery_b> (rather ugly of course)
22:23:10 <Cale> It's possible to do, but not easy.
22:23:22 <faxathisia> Sure, You can implement lambda... but it's not particularly useful
22:23:23 <wy> What about other logic languages?
22:23:51 <Cale> There are functional-logic languages like Mercury which might be more comfortable in that regard.
22:24:01 <faxathisia> wy, Reasoned Schemer presents a great logic language with lots of improvement over Prolog
22:24:09 * glguy enjoyed that book
22:24:37 <faxathisia> It's also interesting to read LogicT
22:24:49 <Cale> Oh, and Curry too
22:24:59 <Cale> http://www.informatik.uni-kiel.de/~curry/
22:25:00 <lambdabot> Title: The Functional Logic Language Curry
22:25:16 <faxathisia> Yeah some of the Curry examples are extremly elegant
22:25:23 <wy> Cale: Which on do you like most?
22:25:30 <faxathisia> I couldn't compile the damn thing though
22:25:33 <ddarius> Most logic languages are quite an improvement over Prolog.
22:25:41 <Cale> I haven't used them enough to really make that judgement.
22:27:00 <wy> faxathisia: Reasoned or Seasoned?
22:27:45 <faxathisia> There is also Lambda-Prolog, Which is based on higher order unification (undecideable) and has haskell-like syntax
22:28:15 <faxathisia> I don't know how it is to use though, Has anyone written something considerable with it?
22:29:02 <faxathisia> wy, Seasoned Schemer is a good introduction to scheme, Reasoned has all the logic programming stuff though
22:29:44 <faxathisia> It's the same research that led to that book and LogicT being written (as well as a minikanren impl. in haskell)
22:30:07 <faxathisia> (LogicT being http://okmij.org/ftp/Computation/monads.html )
22:30:08 <lambdabot> Title: Monads
22:30:12 <wy> wow. lots of stuff
22:30:33 <wy> How does databases compare with datatypes of functional languages?
22:34:32 <lispy> well, i'm no expert
22:34:48 <lispy> but i think they both have ints
22:35:10 <lispy> and haskell and SQL both have record selection syntax
22:35:33 <lispy> and haskell and databases both support functional dependencies
22:37:36 <Cale> SQL has very few datatypes in comparison with those available in most typed functional languages.
22:38:40 <lispy> Cale: well, SQL isn't really database.  I don't think a datamodeller would consider the primitive and tuple types of SQL to represent the types of a database
22:39:22 <lispy> Cale: iirc, a table in a database represent an object relational mapping, ie, it's a 'class' or 'struct'
22:39:31 <faxathisia> http://rafb.net/p/3HKr4L22.html
22:39:31 <lambdabot> Title: Nopaste - No description
22:39:42 <Cale> lispy: A product type, essentially.
22:39:50 <faxathisia> matrix multiplication in SQL :p
22:39:51 <Cale> (with no functions in it)
22:40:37 <lispy> Cale: well, some database engines define some weird column types...perhaps in some databases you can store procedures in a table
22:40:58 <lispy> Cale: some databases do support stored procedures, I just don't know where they live
22:41:08 <geezusfreeek> they live in tables
22:41:10 <Cale> You can't very well represent sum types though
22:41:32 <lispy> Cale: I was working with GIS extensions in one database, that was fun to store maps in the tables
22:41:40 <Cale> (which was an important design decision of course, but it is somewhat restrictive)
22:41:40 <faxathisia> ddarius, Why do you dislike Prolog so much?
22:42:12 <lispy> Cale: what is a sum type?  something like Maybe a?
22:42:19 <mauke> lispy: |
22:42:32 <Cale> lispy: yeah, Either is a better example
22:42:57 <Cale> Either a b is sometimes referred to as the sum of a and b
22:43:03 <Cale> (or the disjoint union)
22:43:11 <lispy> and a product type is like data Product = P Int Int String Double
22:43:15 <Cale> yeah
22:43:19 <mauke> (,)
22:43:20 <Cale> (a,b)
22:43:23 <geezusfreeek> sum == Either, product == (,)
22:43:40 <mauke> you can build all types out of Either, (,) and recursion
22:43:42 <faxathisia> (42, "choux") : Int * String
22:44:02 <lispy> so what is, data Product = P1 Int Product | P2 Int
22:44:16 <Cale> Usually this problem is tackled by simply keeping the different cases in completely separate tables, but that makes it awkward to write certain kinds of computation.
22:44:30 <lispy> (ie, what do you call it when you ad reculsion, what do you call it when yu have a sum of products?)
22:44:46 <Cale> lispy: I suppose a polynomial type
22:45:03 <lispy> reculsion should have been recursion, lol
22:45:43 <Cale> Note that up to isomorphism, we have distributivity, which is what makes the names sum and product appropriate:
22:45:56 <Cale> Either (a,b) (a,c) is the same as (a,Either b c)
22:46:05 <Cale> (up to iso.)
22:46:24 <Cale> Which is rather like saying  ab + ac = a(b+c)
22:46:39 <mauke> @djinn Either (a,b) (a,c) -> (a,Either b c)
22:46:39 <lambdabot> f a =
22:46:39 <lambdabot>     case a of
22:46:39 <lambdabot>     Left (b, c) -> (b, Left c)
22:46:39 <lambdabot>     Right (d, e) -> (d, Right e)
22:47:19 <Cale> @djinn (a,Either b c) -> Either (a,b) (a,c)
22:47:19 <lambdabot> f (a, b) =
22:47:19 <lambdabot>     case b of
22:47:19 <lambdabot>     Left c -> Left (a, c)
22:47:19 <lambdabot>     Right d -> Right (a, d)
22:48:38 <Cale> lispy: Oh, heh, I forgot the more common name there -- these are called algebraic datatypes.
22:49:37 <lispy> yeah, I know that one, I was just hopping for something specific to their 'restrictions' from ADT
22:50:04 <Cale> yeah, I suppose ADTs allow for recursions as well, as opposed to just sums of products
22:50:14 <lispy> data Product = P Product | Nil, there must be a good name for that
22:50:16 <Cale> So perhaps polynomial type is the right name.
22:50:31 <mauke> [()]
22:50:44 <Cale> oh, you're specifically referring to the recursion?
22:51:11 <Cale> There's a whole taxonomy of different kinds of recursive datatypes.
22:51:11 <faxathisia> P (P (P (P Nil))) :: Product --?
22:51:17 <lispy> I mean, that's the simplest terminating recursive type you can have right( well, properly recursive..obviously, data Product = P , terminates, but the recursion is silly)
22:51:27 <dons> this guy needs to drop by #haskell, Cale, http://blog.whoop.as/?p=1673
22:51:28 <lambdabot> Title: Why learning Haskell was so damn hard for me » Ignorance is Underrated
22:52:22 <wy> Sum types are actually "object-oriented" I think
22:52:23 <lispy> dons: with a url like "whoop.as" he sounds like kind of an idiot...
22:52:51 <faxathisia> lispy, He also doesn't use a spell checker :P
22:53:04 <dons> lispy: heh
22:54:08 <lispy> dons: yeah, so, getting him to understand the mechanics of lambda calc and type inference would be what he needs, not machine models
22:54:32 <ddarius> faxathisia: I'm one of the people here who most often recommends learning Prolog, but Prolog takes a pretty thing and makes it ugly.  There are better logic languages than Prolog but not with anywhere near the "support"
22:54:37 <Cale> dons: I'll write a comment :)
22:54:46 <sjanssen> I dunno, I find insights about the low-level compilation of Haskell to be useful
22:55:16 <allbery_b> enh,prolog is kinda neat.  just don't try to do real world stuff in it
22:57:11 <dons> Cale: thanks :) maybe point at the STG paper?
22:57:20 <dons> he's got to learn about closures at some point
22:57:46 <faxathisia> ddarius, What is the pretty thing, FOL or unification or ?
22:57:54 <dons> sjanssen: yeah, i think its crucial to become expert in the language. you have to be able to read core and then C--
22:58:22 <ddarius> faxathisia: Logic programming.
22:58:36 * dons notes this will be his 10th year of haskell hacking. that's a bit scary. 
22:58:37 <Cale> dons: I'm offering a personalised demonstration of how Haskell expressions are evaluated if he comes to the IRC channel, but yeah, I'll point him at that paper. I wish there was a paper describing things at a somewhat higher level than that.
22:58:41 <faxathisia> hmm..
22:58:58 <dons> Cale: hmm.
22:59:01 <Cale> dons: It's possible to do Haskell evaluation entirely by transformation of expressions.
22:59:11 <dons> a beginners guide to compiled graph reduction
22:59:20 <dons> yeah, that might be the 'magic' he talks about
22:59:25 <lispy> dons: with this guy i would take the approach of teaching him the rules of lambda calc evaluation, then teaching him how to translate haskell into lambda calc.  Then he should be able to figure it out.
22:59:33 <Cale> and that's something which once you know how to do it, it's easy to see how it would be implemented (at least naively) in an imperative language
22:59:42 <dons> yeah, term rewriting. then he can think about how to compile it down
23:00:07 <lispy> right
23:00:36 <lispy> who knows, maybe we'll have a jhc2
23:00:54 <lispy> as this guy trys to figure out the translations from scratch :)
23:00:56 <Cale> I'd like something which takes a high level view of Haskell expressions. Don't even translate them down to lambda calculus or core or anything. It makes the rules more complicated, but it's more useful when you're actually thinking about how an algorithm will run.
23:01:05 <yoshi> >any ((<= fromEnum 0) || (>= fromEnum 9)) "1a2b3c"
23:01:12 <Cale> lispy: hehe
23:01:20 <Cale> > any ((<= fromEnum 0) || (>= fromEnum 9)) "1a2b3c"
23:01:22 <lambdabot>      The section `(<= (fromEnum 0))' takes one argument,
23:01:22 <lambdabot>     but its type `Bo...
23:01:23 <lispy> yoshi: you're missing a space
23:01:26 <faxathisia> ddarius, Which are better, or what is the reason it's ugly?
23:01:49 <Cale> wrong level of ||
23:01:58 <Cale> > any (liftM2 (||) (<= fromEnum 0) (>= fromEnum 9)) "1a2b3c"
23:01:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
23:02:02 <Cale> err...
23:02:11 <faxathisia> (because I don't notice that personallf)
23:02:18 <ddarius> faxathisia: SLD resolution, cut, assert/retract.  These destroy the model and make you have to understand how Prolog works rather than be able to program declaratively.
23:02:19 <Cale> > any (liftM2 (||) (<= 0) (>= 9)) "1a2b3c"
23:02:20 <lambdabot>   add an instance declaration for (Num Char)
23:02:24 <Cale> > any (liftM2 (||) (<= '0') (>= '9')) "1a2b3c"
23:02:25 <lambdabot>  True
23:02:30 <Cale> heh
23:02:36 <yoshi> ah hah!
23:02:39 <yoshi> thanks =]
23:03:02 <Cale> > any (\x -> x <= '0' || x >= '9') "1a2b3c"
23:03:03 <lambdabot>  True
23:03:12 <Cale> That's possibly clearer
23:03:24 <Cale> > any (not . isDigit) "1a2b3c"
23:03:25 <lambdabot>  True
23:03:33 <lispy> yeah, I was just typing that :)
23:03:34 <Cale> This is probably clearer still :)
23:05:27 <lispy> does ghc 6.8 support associated types?
23:05:46 * faxathisia should try to code a logic language in haskell
23:05:54 <ddarius> faxathisia: It's easy as pie.
23:06:12 <faxathisia> I coded a Prolog parser before.. but I lost the src :(
23:06:29 <lispy> OMG HPC is in 6.8!!
23:06:41 <ddarius> lispy isn't the quickest
23:06:48 <glguy> welcome to the future
23:07:11 <lispy> sorry, I really haven't been in a place where I could keep up since about mid Agugust
23:07:14 <lispy> August*
23:07:32 <lispy> oh AT is incomplete :(
23:07:51 <ddarius> faxathisia: I implemented a core Prolog before.  The first cut was about 80 lines.  The "latest" version was ~300 (lines of any type, including some Prolog programs in comments).
23:08:12 <faxathisia> cool
23:08:13 <ddarius> @google Typed Logical Variables in Haskell
23:08:14 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
23:08:14 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
23:08:40 <faxathisia> I did the Herbrand MGU algo in about 20 or something
23:08:49 <faxathisia> I guess that takes the most space?
23:10:05 <ddarius> Unification takes like 6 lines.
23:10:46 <ddarius> The parser was by far the plurality of the code.
23:12:31 <lispy> I'd like to someday sit down with the haskell98 report and make an interpreter from scratch
23:12:36 <lispy> it would be a fun learning experience
23:12:41 <lispy> but, when will i have the time...
23:13:16 <wy> Haha. This article really exemplifies the claim that "any good non-trivial C program contains a lisp interpreter". http://swtch.com/~rsc/regexp/regexp1.html
23:13:16 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
23:13:28 <lispy> i'd also like to make a C compiler capable of compiling anything ghc outputs -fvia-C
23:13:45 <ddarius> lispy: GHC uses GCC extensions.
23:13:57 <lispy> ddarius: i would have guessed
23:14:32 <lispy> ddarius: but, the fun part of it, is making a C compiler in haskell that helps to bootstrap the compiler that compiles it :)
23:15:58 * ddarius needs to sleep.
23:16:56 <Cale> wy: It also points out something rather surprising about perl's performance at matching regular expressions.
23:17:31 <wy> yes. and for many other languages.
23:17:47 <lispy> Cale: what is that, time vs n in the graph?
23:17:53 <Cale> lispy: yeah
23:18:01 <Cale> lispy: note the log scale
23:19:06 <lispy> yeah, i always knew gnu grep was fast
23:19:07 <Korollary> It's just one particular regexp pattern
23:20:04 <lispy> Korollary: yeah, they need to use quickcheck
23:20:20 <Korollary> ?
23:21:00 <lispy> Korollary: bad joke...if they used quickcheck to generate the patterns they wolud test more...
23:21:23 <wy> Still feel the code is little masochism
23:21:25 <Korollary> Maybe they do test it and don't care.
23:21:28 <Cale> Korollary: yes, but it shouldn't take exponential time to check if a regular expression matches a string or not, should it?
23:21:56 <Korollary> perl
23:22:04 <Korollary> perl's regular expressions are not regular expressions
23:22:12 <wy> That's worst case
23:22:12 <Korollary> so I don't know what they value
23:22:24 <Cale> Yes, but for the subset of them which are, you'd think it could be just as efficient.
23:22:46 <wy> The example case is a normal one
23:23:00 <Cale> Surely it's possible to detect if a perl regular expression is actually a regular expression or not :)
23:23:12 <wy> only backreferences cause exponential algorithm
23:24:24 <wy> good night all!
23:33:55 <Taejo> @djinn (a -> a) -> a
23:33:55 <lambdabot> -- f cannot be realized.
