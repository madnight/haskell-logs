00:00:06 <yuri_>  I came accross HXT
00:00:28 <siti> ool I segfaulted my ghc binary that's no good :(
00:00:34 <siti> maybe it was the threading stuff
00:01:24 <yuri_> ok, thanks for the insights. Have to crash now...
00:01:29 <sclv> yuri_: you should browse hackage a bit. my understanding is that HaXml is the standard xml package that foax use. i forget which db bindings are generally considered the most supported and production-ready, though my understanding is that takusen (not hackaged! sigh.) is the coolest.
00:01:46 <wagle_> having been mercilessly razzed for once being a scheme person, i must poke fun at ghc for segfaulting
00:01:57 <siti> lol
00:02:09 <Cale> yuri_: HXT is rather good. It has a complicated interface (which is not so good), but you tend to just use bits and pieces of it, and once you get started, it's not hard at all.
00:03:11 <sclv> hxt is considered pretty nice though too. the generic-xml library that alexj rolled for use with HaPPS also seems like it would be a good fit for lots of other uses (its built on HaXml).
00:03:20 <yuri_> sclv: that is great info for noob like me. I am a little lost on the available frameworks... I will take a look at HaXml instead of HXT
00:04:17 <yuri_> and takusen
00:05:02 <Cale> iirc, HXT is actually based in part on HaXml
00:06:12 <yuri_> so HaXml is a better start then?
00:06:26 <Cale> I don't know :)
00:06:36 <Cale> Try them and see which one you like, I suppose. :)
00:07:43 <sclv> the entries about a web spider on this blog give a nice account of one user's experiences with both, and also some sample code of how he used them: http://kevin.scaldeferri.com/blog/tech/index.html
00:07:43 <lambdabot> Title: Kevin's Weblog
00:08:51 <yuri_> sclv: thanks again.
00:09:21 <sclv> no prob. foax on #haskell tend to fall over one another being helpful.
00:10:09 <yuri_> I just downloaded the HaXml, untared it, executed runhaskell Setup.hs configure, then build, then install. Is this the general workflow for getting a package installed in my machine?
00:10:41 <siti> yep
00:11:32 <quicksilver> one of the exciting things about haskell libraries is also one of the frustrating things. Authors of haskell libraries are often keen to experiment with new interface ideas... so some of them feel pretty unfamiliar if you are expecting something like a simple binding to a C library.
00:11:49 <yuri_> how do I know what packages do I have installed and what "main"s I do have available?
00:11:57 <sclv> ghc-pkg list
00:12:16 <yuri_> gr8
00:12:45 <yuri_> QuickCheck is another amazing thing: so simple, but so powerful
00:13:03 <sclv> you can also browse installed packages in ghci like so: ":browse Data.Map" to see what they provide.
00:13:17 <wagle_> siti, there's a number of hits on google for: waitForProcess timeout
00:13:24 <sizur> quicksilver, completely agreed. and the worst thing about this freedom is that it hampers module integration as there is less consistency.
00:15:08 <sclv> I have the standard library haddocks bookmarked as well: http://haskell.org/ghc/docs/latest/html/libraries/. As it turns out, on my machine though, under /usr/local/share/doc/ there are haddocks for everything i've installed with cabal!
00:15:11 <sizur> i feel like i'm beginning to accept Haskell's goal of avoiding success as it seems the easiest way to grow a language
00:15:51 <wagle_> "avoiding success"?
00:16:06 <yuri_> nice
00:16:18 <siti> wagle_: cheers...
00:16:35 <sizur> wagle_, yep ;)
00:16:53 <sclv> i think you need to rughc Setup.lhs haddock to get them though...
00:19:12 <wagle_> i've been surrounded by people who were sure that haskell was poised to take over the world..  first i've heard that haskell was avoiding success..  how you mean?
00:20:04 <kaol> avoiding success == not being a slight modification of C
00:20:15 <quicksilver> wagle_: "avoid success at all costs" was an unofficial motto
00:20:23 <quicksilver> @go haskell retrospective wearing the hair shirt
00:20:25 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
00:20:25 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
00:20:33 <quicksilver> It's mentioned in there ^^
00:20:39 <wagle_> hahaha
00:21:19 <quicksilver> wagle_: the point is, that success gives you customers who start making demands on you to make compromises inthe name of practicality
00:21:24 <quicksilver> at least, I thnk that was the point
00:22:33 <sizur> and having to support a lot of ppl forces you to be backward compatible, even if a new research shows a much better way.
00:23:15 <sizur> i think we already have some of that
00:23:38 <quicksilver> we do
00:23:47 <quicksilver> the motto has not been stuck to perfectly
00:23:55 <quicksilver> despite best efforts :)
00:25:57 <wagle_> thanks..
00:29:17 <sizur> > 1+1
00:29:20 <lambdabot>  2
00:30:37 <wagle_> now, prove it
00:31:04 <sizur> @vixen prove it please, would you?
00:31:04 <lambdabot> how can i prove it to you?
00:32:54 <sizur> > unforlr (\(a,b)->Just(a,(b,a+b))) (1,1)
00:32:55 <lambdabot>   Not in scope: `unforlr'
00:33:09 <sizur> > unfoldr (\(a,b)->Just(a,(b,a+b))) (1,1)
00:33:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:37:06 * wagle_ googles for someone who's recreated whitehead and russell's proof that 1 + 1 = 2 in a theorem prover
00:42:44 <ketil> 1+1=2 follows from the definitions of '1', '2', and '+'.
00:44:43 <sizur> > unfoldr(\(n,ps)->if any(\m->rem n m==0)ps then Just(Nothing,(succ n,ps)) else Just((Just n),(succ n,n:ps))) (2,[])
00:44:46 <lambdabot>  [Just 2,Just 3,Nothing,Just 5,Nothing,Just 7,Nothing,Nothing,Nothing,Just 11...
00:45:37 <sizur> @hoogle [Maybe a] -> [a]
00:45:37 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
00:45:45 <wagle_> apparently, whitehead and russell spent quite a number of pages proving 1 + 1 = 2 using the peano axioms (in principia mathematica)
00:46:13 <sizur> > catMaybes $ unfoldr(\(n,ps)->if any(\m->rem n m==0)ps then Just(Nothing,(succ n,ps)) else Just((Just n),(succ n,n:ps))) (2,[])
00:46:15 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:46:28 <wagle_> the HOL people seem to have thought about it, but i'm not finding a proof
00:46:57 <sizur> wagle_, better prove that 1+1=2
00:47:21 <sizur> maths cannot be complete
00:47:53 <wagle_> iirc, peano axioms without induction is complete
00:48:14 <mgsloa1> with gtk2hs, is there a better way to do an interactive application than IOReffing your state?
00:48:15 <sizur> axioms = not complete
00:48:18 <ketil> data N = Zero | Succ N ;  1+1 = Succ Z + Succ Z = (Succ (Succ Z)) + Z = Succ (Succ Z) = 2  ?
00:49:03 <wagle_> i never read principia mathematica..  i dont know what the difficulty is
00:49:46 <sizur> one simply has faith that 1+1 will always be 2
00:49:51 <sizur> and build on that
00:50:11 <wagle_> but i have the impression that once whitehead and russell did it in its great glorious detail, no-one wanted to do it again
00:50:45 <balodja> ketil: And how to prove that 1 - 2 = -1? :)
00:51:42 <visof> what are the basics that should learn in Haskell before i start learning GUI in Haskell ??
00:52:17 <Mr_Awesome> visof: youll definitely need to understand monads
00:52:38 <Mr_Awesome> well, it would be a good idea at least
00:53:23 <sizur> visof, it depends what kind of gui you want to be working with. the benefits of FP in GUI appear when you start coding with arrows, and that's pretty advanced
00:54:23 <visof> so should learn monads
00:54:37 <jeffz> visof: html, javascript
00:54:49 <visof> what?
00:55:00 <sizur> visof, to be doing something useful with Haskell, you have to learn monads, yes :)
00:55:07 <jeffz> visof: you can create a gui by turning your user interface into a webpage.
00:55:54 <visof> i know some html and some javascript too
00:56:02 <sizur> visof, but fear not the scary 'monad' word
00:57:22 <siti> grr at ghc crashing, I will try and get a bt ;)
00:58:41 <Mr_Awesome> sizur: fp ftw! :)
00:58:55 <sizur> oh yeah!
00:59:02 <C-Keen> stupid question: how do I address parts of a data type: data Foo = Foo {a::Int, b::Int, c::Int} ? I think I have read somewhere that using a '.' notation is the way but my compiler thinks otherwise
00:59:22 <Cale> apply them like functions
00:59:24 <Cale> (they are)
01:00:30 <xpika> how do I show the available modules without pressing tab in ghci
01:01:33 <dmwit> I'm not sure there is a nicer way.
01:02:19 <sclv> C-Keen: to expand a bit if you have a (foo::Foo) then "a foo" gives you the a, "b foo" gives you the c, etc.
01:02:24 <sclv> s/c/b/
01:02:45 <xpika> what about a ghci api function?
01:03:22 <sclv> and to update it you can write a function like \(x:Foo) -> x {a=12} or if you want to increment a, you write {a = a x + 1}, etc.
01:04:37 <sclv> xpika: i assume you're working with a .hs file you have loaded, no? just look at what it imports.
01:05:20 <dmwit> sclv: I think he may be asking how to know what is available to :m +.
01:05:31 <xpika> sclv: that information can be accesd via :show modules
01:07:26 <C-Keen> sclv: a foo seems a bit awkward to me, but you are right of course. It just looks strange
01:07:56 <sclv> ooh. i see. !ghc-pkg list and !ghc-pkg describe then?
01:08:30 <dmwit> C-Keen: Nine out of ten doctors agree: record syntax is awkward.
01:09:18 <C-Keen> dmwit: heh
01:10:11 <sclv> C-Keen: you could of course name your variables so they look more useful to your purposes, e.g. newtype State s a = State { runState :: (s -> (a,s)) }
01:10:51 <sclv> s/variables/record labels/
01:12:05 <C-Keen> sclv: of course. I am not using letters, ancient cities or hebrew chars for this (I have seen enough code like this)
01:12:44 <dmwit> ...ancient cities
01:13:15 <C-Keen> dmwit: well imagine you see troy assigned some number from carthago....
01:13:34 <C-Keen> dmwit: after a while it just hurts once you stop laughing
01:14:37 <sclv> what i meant, i suppose, is that runState s looks really natural. so you can write names that look natural for your purposes. Location {countryOf::String}; countryOf milan;
01:15:53 <wagle_> easier than searching the source for the destructor functions
01:16:48 <dmwit> That's easy, they're in Khan.hs.
01:18:51 <sclv> Control.Sack
01:19:22 <wagle_> the last minute of the leopard install is by far the longest..  its taken 10 minutes so far..  time dilation?
01:19:37 <wagle_> @hoogle Khan.hs
01:19:38 <lambdabot> No matches, try a more general search
01:20:30 <dmwit> sclv: hahaha
01:20:39 <sclv> > 'k':'h':repeat 25 'a':'n':[]
01:20:40 <lambdabot>  Couldn't match expected type `Char -> Char'
01:20:59 <sclv> > 'k':'h':repeat 25 'a'++'n':[]
01:21:00 <lambdabot>  Couldn't match expected type `Char -> [Char]'
01:21:19 <dmwit> > "kh" ++ replicate 25 'a' ++ "n"
01:21:21 <lambdabot>  "khaaaaaaaaaaaaaaaaaaaaaaaaan"
01:21:27 <wagle_> :t repeat
01:21:28 <lambdabot> forall a. a -> [a]
01:21:35 <dmwit> Wrong Khan, though. =)
01:22:17 <sclv> ah. there we go.
01:22:30 <wagle_> "kh" ++ repeat 'a' ++ "n"
01:22:49 <wagle_> (poor lambdabot)
01:23:09 <mgsloa1> > "kh" ++ repeat 'a' ++ "n"
01:23:13 <lambdabot>  "khaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
01:23:14 <ketil> what's an orphan instance?
01:23:18 <wagle_> oops
01:23:19 <mgsloa1> :)
01:23:19 <sclv> > "kh" ++ fix ('a':) -- fixed ur code.
01:23:31 <quicksilver> ketil: an instance defined neither in the same place as the type, nor the same place as the class.
01:23:32 <lambdabot>  "khaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
01:23:57 <dcoutts_> mgsloa1: you can use a thread rather than an IORef, or you use a state monad with a wrapper that restores and later saves the state in an IORef
01:24:01 <ketil> quicksilver, ah.  OK.
01:24:20 <quicksilver> was that a khan extension?
01:24:25 <dcoutts_> mgsloa1: or use some higher level layer on top of gtk2hs, like grapefruit
01:24:30 <mgsloa1> dcoutts_ - hmm, I suppose those are possibilities
01:24:58 <wagle_> khar, khdr, and khan
01:25:12 <quicksilver> mgsloa1: rule 1 is never use an IORef
01:25:22 <sclv> ?go khar khdr khan
01:25:27 <lambdabot> http://links.jstor.org/sici?sici=0041-977X(1952)14%3A3%3C627%3AAAOPAS%3E2.0.CO%3B2-3
01:25:31 <dmwit> rule 2 is don't talk about IORef?
01:25:34 <mgsloa1> quicksilver - why's that?
01:25:34 <quicksilver> mgsloa1: rule 2 is OK, but only if you absolutely have to, and don't let it pollute your code.
01:25:40 <mgsloa1> yeah, it won't
01:25:49 <quicksilver> mgsloa1: so, use the IORef "just around the callback" because you have to.
01:25:55 <mgsloa1> yep
01:25:57 <quicksilver> but keep the rest of the code using proper State types
01:26:03 <mgsloa1> so that I can get the input events going
01:26:04 <mgsloa1> right
01:26:14 <quicksilver> alternatively, use a neat typeclass to hide the IORef entirely
01:26:23 <quicksilver> MonadInterleavableIO!
01:26:26 <dcoutts_> @seen kmcallister
01:26:27 <lambdabot> kmcallister is in #haskell-blah, #xmonad and #haskell. I last heard kmcallister speak 2h 35m 28s ago.
01:26:47 <mgsloa1> dcoutts_ - grapefruit looks neat.  does it handle keyboard input well?
01:27:02 <dcoutts_> mgsloa1: I've not tried it yet, so I don't know
01:27:26 <dcoutts_> kmcallister: that calculator sounds nice, we're always looking for screenshots of apps to stick on the gtk2hs website...
01:43:19 <blbrown> @src reverse
01:43:19 <lambdabot> reverse = foldl (flip (:)) []
01:53:55 <blbrown> @src flip
01:53:55 <lambdabot> flip f x y = f y x
01:58:00 <pwned> > do it
01:58:02 <lambdabot>   Not in scope: `it'
01:58:40 <dmwit> Sneaky.
01:59:00 <pwned> it escaped
01:59:02 <dmwit> (But I don't think \bot evaluates things in GHCi... it actually compiles them.)
02:02:22 <wagle_> > Just do { it }
02:02:23 <lambdabot>  Parse error at "do" (column 6)
02:02:30 <wagle_> > Just $ do { it }
02:02:31 <lambdabot>   Not in scope: `it'
02:05:13 <jedbrown> > Just (do it)
02:05:14 <lambdabot>  Just "Just do it! Just do it! Just do it! Just do it! Just do it! Just do it...
02:08:42 <wagle_> > (do it)
02:08:43 <lambdabot>  "Just do it! Just do it! Just do it! Just do it! Just do it! Just do it! Jus...
02:08:58 <EvilTerran> > fix $ Just.("do it!"++).show
02:09:00 <lambdabot>  Just "do it!Just \"do it!Just \\\"do it!Just \\\\\\\"do it!Just \\\\\\\\\\\\...
02:10:53 <nanothief> what is going on with Just (do it)?
02:11:13 <pwned> Nike
02:12:13 <EvilTerran> > it
02:12:15 <lambdabot>   Not in scope: `it'
02:12:18 <EvilTerran> ...
02:12:37 <EvilTerran> someone must've defined "it" in privmsg, and undefined it again by now
02:12:49 <wagle_> :t it
02:12:50 <lambdabot> Not in scope: `it'
02:12:52 <EvilTerran> and, by someone, i mean jedbrown
02:13:03 <jedbrown> > what happened
02:13:04 <lambdabot>  "I guess Simon was not amused ^^^."
02:13:19 <nanothief> EvilTerran: haha ok that had me totally confused
02:13:20 <nanothief> :P
02:13:27 <nanothief> jedbrown :@
02:14:02 <wagle_> @pl do
02:14:02 <lambdabot> do
02:14:11 * jedbrown giggles
02:14:14 <wagle_> @pl do it
02:14:14 <lambdabot> do it
02:17:17 <wagle_> hmm
02:17:26 <wagle_> > do it
02:17:27 <lambdabot>  "jedbrown is guilty, Guilty, GUILTY!"
02:17:33 <wagle_> o.O
02:18:17 <mux> > it
02:18:17 <lambdabot>  "jedbrown is guilty, Guilty, GUILTY!"
02:19:18 <jedbrown> What does this sort of indirection through \bot mean for the network graph?
02:21:47 <jedbrown> To find the interpolated value at x(j) where i_m <= j <= i_m' we need the index
02:21:47 <jedbrown> J such that X(J) <= x(j) <= X(J+1).  Now, X(I) = A + H * I, so
02:22:05 <jedbrown> Damn paste buffer!
02:36:52 <mgsloa1> woohoo, a few hundred lines later my text editor has a cursor and displays the shiez
02:37:18 <mgsloa1> and uses hierarchical Zippers :)
02:38:55 <mgsloa1> One thing is puzzling, though.  I reference kRight / kLeft on the left side of -> matches.  these are just functions that eval to consts.  they apparently overlap unless I replace with actual consts
02:40:19 <tibbe> :)
02:40:49 <jedbrown> mgsloa1: functions are not generally injective, and it's not decidable at compile time that they are.
02:41:02 <mgsloa1> hrmm, well, constants would be nice then
02:41:28 <mgsloa1> ideally one would use enums, but in this case I'm interfacing with external stuff
02:41:40 <jedbrown> mgsloa1: But constructors are injective, which is why pattern-matching with constructors is good.
02:41:52 <mgsloa1> ah, interesting
02:42:35 <jedbrown> mgsloa1: Is there a small finite set of constants, so you can represent it as an alternative?
02:43:02 <jedbrown> mgsloa1: By external, did you mean FFI, or just someone else's code?
02:43:08 <mgsloa1> FFI
02:43:12 <mgsloa1> nah, it'
02:43:18 <mgsloa1> it's a huge finite set :P
02:43:41 <mgsloa1> I'll just use the hex vals, they aren't too bad
02:43:48 <quicksilver> mgsloa1: if you use a variable of the left of a ->
02:43:54 <quicksilver> mgsloa1: you are introducing a new one :)
02:44:01 <quicksilver> mgsloa1: you are not referring to a value.
02:44:10 <quicksilver> let n = 5 in case m of n -> ....
02:44:11 <jedbrown> mgsloa1: So you could write your own storable instance.  Oh, are you using hsc2hs enum hooks?
02:44:18 <quicksilver> ^^ this is not checking if m is 5
02:44:29 <mgsloa1> I'm using gtk2hs
02:44:30 <quicksilver> it is binding a fresh name 'n' to the value of m.
02:45:09 <mgsloan> that's rather scary
02:45:20 <mgsloan> tricky, anyway
02:45:33 <quicksilver> that's what case does though :)
02:45:38 <quicksilver> case l of (x:xs) ->
02:45:45 <quicksilver> ^^ this is how you break down a list
02:45:47 <quicksilver> x and xs are fresh
02:45:53 <quicksilver> they are bound to the parts of l.
02:45:57 <mgsloan> yep yep
02:46:04 <mgsloan> just like pattern matching anywhere else
02:46:09 <quicksilver> exactly
02:46:17 <quicksilver> that's the syntactic reason you can't do case n of kRight
02:46:19 * mgsloan isn't new just hasn't been around in ages :P
02:46:26 <quicksilver> the semantic reason is as jedbrown says
02:46:38 <quicksilver> semantically, you'd need to know they were injective
02:46:44 <mgsloan> well, actually it let me syntactically do it
02:46:47 <quicksilver> yes
02:46:52 <quicksilver> but it wasn't the kRight you thought it was
02:46:54 <quicksilver> that's my point
02:46:57 <mgsloan> but, as you said that's binding
02:46:57 <quicksilver> it was a fresh kRight
02:47:00 <mgsloan> ah
02:47:15 <mgsloan> yeah, that matches anything
02:47:16 <quicksilver> "these are not the kRights you are looking for"
02:47:20 <mgsloan> lol
02:47:37 <quicksilver> so if you wanted to extend haskell to permit this
02:47:42 <quicksilver> (and it has been discussed many times)
02:47:50 <quicksilver> you'd need some syntactical way to distinguish it
02:47:56 <quicksilver> from the 'bind fresh name' meaning.
02:48:09 <quicksilver> I suspect it would end up being a mess.
02:49:05 <mgsloan> or at least patch a little thing on ghc giving a proper warning
02:49:32 <mgsloan> when you introduce a freshname in a casematch that matches a name already in the environment
02:49:51 <doserj> -fwarn-name-shadowing ?
02:49:52 <quicksilver> is there not a warning?
02:50:01 <quicksilver> should be caught by existing shadowing warnings I'd think.
02:50:09 <mgsloan> apparently you have to enable it
02:50:58 <mgsloan> it wasn't caught. i have ghc 6.6, though
02:52:09 <quicksilver> ghc -Wall
02:52:10 <quicksilver>  :)
02:52:13 <hpaste>  tibbe annotated "Diff test" with "Diff test 2" at http://hpaste.org/5313#a1
02:52:20 <quicksilver> just like in gcc, most warnings are off by default.
02:52:27 <mgsloan> oh, huh
02:52:41 <quicksilver> cute, tibbe
02:52:50 <quicksilver> although you don't seem to be here, according to tab-complete :P
03:04:45 <hpaste>  povman pasted "(no title)" at http://hpaste.org/5314
03:04:52 <nominolo> > \m -> (maybe (Just m) (Just . (m:)))
03:04:53 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:04:54 <lambdabot>       Expected...
03:05:28 <nominolo> > \m -> (maybe (Just [m]) (Just . (m:)))
03:05:29 <lambdabot>  Add a type signature
03:05:45 <povman> ^ is there any way of making that structure without a mkEntity?
03:05:47 <dmwit> povman: Entity is a constructor; the type is Element.
03:06:05 <povman> i only ever want parent to be an Entity
03:06:28 <dmwit> Then you need a different definition... two separate data types or something.
03:06:48 <povman> hm - but then how do i do the two Elements in Relationship?
03:06:58 <dmwit> Using Either, maybe?
03:06:58 <povman> they can be either Entity or Relationship
03:07:04 <povman> hey
03:07:14 <povman> good idea :D
03:07:21 <povman> ta
03:08:16 <dmwit> :t maybe
03:08:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:08:26 <quicksilver> sometimes it would be nice if an 'alternative' of a type was also a type in its own right.
03:08:34 <quicksilver> the book-keeping can get a bit frustrating.
03:08:42 <dmwit> yeah
03:09:46 <EvilTerran> i can easily envisage a type system where products and coproducts are managed wholly independently
03:10:15 <EvilTerran> not sure how solid it'd be, but i can think of plausible ways of doing it
03:12:09 <povman> it would be nice
03:13:09 <ricky_clarkson> Is Coq good for trying stuff like that out?
03:13:57 * EvilTerran realises he has three different pointing devices connected to his computer ATM
03:14:02 <EvilTerran> (sorry, random thought for you there)
03:15:05 <ricky_clarkson> Can you rig them up so you have three pointers on your screen?
03:15:15 <povman> hahaa
03:15:34 <povman> gogo gadget multitouch
03:15:38 <EvilTerran> i wish =/
03:16:10 <EvilTerran> seriously, tho, being able to use my trackpoint as a joystick, and my mouse seperately, would be really quite handy for computer games
03:16:27 <EvilTerran> trackpoint could be reserved for panning or something in RTSs
03:16:32 <ricky_clarkson> If this were #lisp I'd suggest making one mouse dedicated to typing ( and ), and use your foot for that.
03:16:33 <quicksilver> EvilTerran: I think it's quite plausible, the type system you describe.
03:16:43 <ricky_clarkson> using*
03:16:47 <quicksilver> EvilTerran: however I think it might be syntaxtically inconvenient
03:16:54 <nominolo> @seen syntaxninja
03:16:54 <lambdabot> I saw syntaxninja leaving #haskell-blah and #haskell 6h 2m 18s ago, and .
03:17:00 <quicksilver> EvilTerran: that is, you'd need syntax to distinguish and it would be inconvenient
03:17:22 <EvilTerran> mmm
03:17:23 <ricky_clarkson> > \f x -> f f x
03:17:24 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
03:17:24 <lambdabot>     ...
03:17:33 <EvilTerran> actually, i got to thinking when reading the HList paper...
03:17:52 <ricky_clarkson> I know about fix already.. how could I actually rewrite the above function in Haskell?
03:17:56 <ricky_clarkson> Say, via a Dyn type.
03:18:15 <EvilTerran> type ::= tag type | type "|" type | type "," type
03:18:48 <EvilTerran> kinda thing; require the sides of "|" to be disjoint types (you can do this by wrapping both in different "tags"
03:19:24 <EvilTerran> a tag'd just be a Ucid, like a haskell tycon
03:19:56 <EvilTerran> there'd be a mess of equivalence laws and things to think about; the kinding system would put haskell's to shame ;)
03:21:37 <EvilTerran> ricky_clarkson, "data Fn a = Fn { (?) :: Fn a -> Fn a } | Val a" may be relevant to your interests
03:22:01 <EvilTerran> i = Fn$ id; k = Fn$ \a -> Fn$ \b -> a; etc
03:22:31 <EvilTerran> and everything's of type Fn a :D
03:22:39 <ricky_clarkson> Ok, but I don't understand that :)
03:22:57 <EvilTerran> okay, "data Fn a = Fn (Fn a -> Fn a) | Val a"
03:23:08 <EvilTerran> Fn f ? x = f x
03:23:11 <ricky_clarkson> Give me a paper to read.  And it may not start using random Greek letters on the 3rd page after an approachable introduction.
03:23:22 <ricky_clarkson> (lambda is ok though)
03:23:35 <EvilTerran> I'm afraid i don't have a paper, i'm afraid. i made this up myself, altho it's almost certainly been done elsewhere
03:23:39 <quicksilver> ricky_clarkson: short version: You need to embed a suitably stupid type into the haskell type system.
03:23:46 * EvilTerran deletes one of the "i'm afraid"s
03:23:51 <quicksilver> otherwise you can't type that expression.
03:23:52 <EvilTerran> yeah, what quicksilver said. :P
03:24:01 <ricky_clarkson> Ok, I think I get the last one.
03:24:06 <quicksilver> EvilTerran's type is essentially the untyped lambda calculus
03:24:10 <ricky_clarkson> I tried it in Scala and found a compiler bug..
03:24:12 <quicksilver> the least fixed point of T = T -> T
03:24:28 <EvilTerran> quicksilver, well, not the *least* fixedpoint, as i introduced other values too
03:24:37 <quicksilver> yes, "essentially"
03:24:43 <quicksilver> it's actually T = T -> T + a
03:24:46 <EvilTerran> it's a different fixed point
03:24:48 <EvilTerran> :P
03:24:48 <quicksilver> but that doesn't matter much.
03:24:49 <EvilTerran> (i think)
03:25:14 <EvilTerran> ?bot
03:25:15 <lambdabot> :)
03:25:46 <EvilTerran> ?type (\f x -> f f x) :: (forall a b. a -> b) -> c -> d
03:25:47 <lambdabot> forall c d. (forall a b. a -> b) -> c -> d
03:25:49 <EvilTerran> ftw.
03:27:56 <rekso> Morning everyone. Can anyone enlighten me about http://p.caboo.se/144786 ?
03:27:57 <lambdabot> Title: #144786 - Pastie
03:28:55 <rekso> (The bit I don't understand is line 23: "This overflows the stack. Why?")
03:32:10 <doserj> rekso: I guess the (1+) is the problem. try to make that strict
03:34:15 <Corun> Mmm, ircing from a lecture.
03:34:37 <povman> how come ghc doesn't evaluate the stToIO (calculateAnswer (10^7)) during compilation?
03:34:53 <sizur> Corun, i'm tellin' on y'all
03:34:57 <povman> i mean, it _should_ be able to because there's no missing info
03:36:02 <twanvl> povman: GHC is not smart enough to know that this is safe to do. And in general calculating things at compile time is not always an improvement.
03:36:04 <jedbrown> rekso: Why are you using an MArray anyway?  The computation can be done nicely with IArray since the array is not being mutated.
03:36:45 <rekso> jedbrown: Right, but the population of the array will involve mutating it
03:37:05 <povman> is it at least possible to tell ghc to evaluate it?
03:37:09 <rekso> jedbrown: I'd still get the stack overflow problem with an IArray, wouldn't I?
03:37:19 <jedbrown> rekso: So populate it, then freeze it and do pure work.
03:37:46 <rekso> jedbrown: Would that help?
03:38:06 <jedbrown> rekso: I doubt it.  You would be doing a foldl, so you would need to make sure it was strict, but that's easy.
03:38:28 <jedbrown> rekso: It would be better style, cleaner, and easier to reason about.
03:38:50 <rekso> Yes, it's a good idea. Thanks.
03:39:15 <rekso> Out of interest though, is there any simple way I could make the present approach work?
03:39:32 <jedbrown> rekso: Also, I don't know how you are populating the array, but perhaps you can use array or listArray to build it.
03:39:57 <jedbrown> rekso: The lists will be compiled into a loop.
03:40:12 <doserj> rekso: readSTRef total >>= \x -> x `seq` writeSTRef ... works for me
03:40:49 <quicksilver> rekso: yes, you need to evaluate before writing to teh STRef
03:41:12 <quicksilver> povman, twanvl : I'm not sure it's fair to say GHC isn't smart enough to know that compile time evaluation is safe.
03:41:19 <quicksilver> Actually it is pretty smart at that.
03:41:26 <quicksilver> it chooses not to do compile time evaluation
03:41:33 <quicksilver> because it's very hard to decide whether that's good or not.
03:41:35 <jedbrown> rekso: So unless your population function has back-references or something similar, you shouldn't need ST at all.
03:41:54 <quicksilver> it's an interesting problem, of course
03:42:05 <povman> quicksilver: a user could add some kind of pragma
03:42:48 <quicksilver> there is one of those
03:42:51 <quicksilver> it's called 'use TH' :)
03:43:01 <povman> heh.
03:43:16 <quicksilver> TH is capable of compile time evaluation of haskell expressions as a tiny subset of its awesome capabilities.
03:43:32 <povman> oh awesome
03:43:33 <rekso> Well, in case you're wondering what on earth I'm doing, I've been solving the problems at projecteuler.org using Haskell, as a way of getting some Haskell practice.
03:43:46 <quicksilver> rekso: you're not the first :)
03:43:51 <povman> let's win the programming language shootout
03:44:02 <quicksilver> we do, sometimes
03:44:13 <quicksilver> then they change the rules to say "you can't use this algorithm because if you do, haskell wins"
03:44:13 <rekso> Most of them are pretty easy, but one of them (number 179) I couldn't solve efficiently in Haskell, though I could in C.
03:44:14 <povman> by doing all evaluation at compile time
03:44:57 <rekso> The array needs to be populated so that element i contains the number of positive divisors of i.
03:46:41 <rekso> The best imperative algorithm for that seems to be (pseudocode): for i in [1..MAX] { add 1 to a[i], a[2i], a[3i], etc. }
03:47:14 <rekso> To implement that algorithm, at least, seems to require a mutable array.
03:47:34 <quicksilver> you could just fold that up
03:47:47 <quicksilver> dunno if it would be efficient enough
03:47:54 <quicksilver> how big is the array?
03:48:01 <rekso> MAX is 10^7
03:48:14 <quicksilver> probably not then
03:48:21 <quicksilver> 10^7 length lists probably not wise.
03:48:21 <povman> rekso: Name Error: The domain name does not exist for http://www.projecteuler.org/
03:48:40 <rekso> I could not get a pure approach to run in a reasonable amount of time, which is why I turned to mutable unboxed arrays.
03:48:45 <rekso> povman: is it .net?
03:48:48 <doserj> http://projecteuler.net/
03:48:49 <lambdabot> Title: Project Euler
03:48:57 <povman> rekso: yes
03:49:02 <rekso> Ah, sorry
03:50:01 <rekso> Anyway, thanks everyone for the seq tip.
03:50:13 <quicksilver> rekso: there are easier ways to count the number of divisors :)
03:50:19 <quicksilver> rekso: than just to count them.
03:51:06 <rekso> quicksilver: depending on what you mean, I might know that.
03:51:07 <mux> euler totient? :-)
03:51:37 <quicksilver> rekso: a lists of primes up to sqrt(10^7) should be a sufficient tool
03:51:44 <quicksilver> and that's easily small enough to keep in a haskell list.
03:51:47 <Beelsebob> yeh, that's what I was thinking
03:51:51 <rekso> But if you want the number of divisors of all integers 1 .. n, the algorithm I outlined is probably as efficient as you can get, isn't it? It's asymptotically O(n log n)
03:51:54 <Beelsebob> filter out primes
03:51:58 <quicksilver> (and you'll have loads of lists of primes hanging around from solving earlier problems)
03:51:58 <Beelsebob> then filter out singletons
03:52:04 <Beelsebob> then you've probably got a small enough problem
03:52:19 <quicksilver> many of the euler problems build on some earleir ones
03:54:48 <rekso> I did try several approaches of that sort, and I couldn't get anything to run at all fast with 10^7 numbers. If you can do it, I'd love to see the code!
03:55:22 <mux> what is the question you're trying to solve?
03:55:29 <Beelsebob> 179
03:55:34 <mux> adding the number of divisors of all numbers up to 10^7?
03:56:10 <rekso> mux: How many n <- [1..10^7-1] are there such that n and (n+1) have the same number of divisors?
03:56:33 <mux> mmmm.
03:57:01 <mux> do you have the exercise number handy?
03:57:41 <Beelsebob> 179
03:58:18 <mux> oh, sorry, didn't realize you answered that before :-)
03:58:31 <rekso> If you can find an elegant, efficient Haskell solution, I think you'll be the first. Someone posted an INelegant, efficient Haskell solutionâ€¦
03:58:50 <mux> I didn't solve that one
03:59:01 * mux got pretty much bored with project euler at some point
04:00:07 <rekso> It does get a bit repetitive. :-)
04:00:15 <povman> does anyone else think http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html is pointlessly slow
04:00:15 <lambdabot> http://tinyurl.com/2rgl8s
04:03:57 <jedbrown> povman: this is faster: file:///home/haskell/share/doc/ghc/libraries/doc-index.html
04:04:29 <povman> that's not a real solution
04:05:06 <jedbrown> povman: In what way is in not real?
04:05:19 <povman> it requires me to get a copy
04:07:07 <jedbrown> povman: just set HADDOCK_DOCS = YES in mk/build.mk.  Or did you not build ghc?
04:07:15 <povman> i got a binary
04:07:37 <povman> also, a real solution to any problem involving javascript must include removal of the javascript
04:07:56 <jedbrown> povman: It's also just a huge page.
04:08:10 <jedbrown> povman: Hoogle?
04:09:29 <sizur> povman, strange, because i thought one of the goals of Ajax was to reduce response time.
04:09:47 <povman> it's chuggy on my laptop
04:10:05 <mux> firefox's javascript engine is unbelievably slow
04:10:47 <povman> also its search feature works perfectly
04:11:21 <mux> I'm hoping the tamarin project will be successful in the end (this is Adobe giving away his ActionScript VM)
04:11:27 <mux> ActionScript being ECMAScript as well...
04:13:26 <fbuilesv> Hello, I'm reading a bit about Haskell on wikibooks and I'd like to know what's the difference if there's one between "_" and "undefined.
04:13:48 <kaol> _ matches anything in pattern matching
04:13:49 <vincenz> fbuilesv: _ is like the unnamed variable
04:13:50 <jedbrown> povman: If you want a local copy: http://59A2.org/ghc-docs.tar.gz
04:13:53 <vincenz> fbuilesv: it is a pattern
04:14:16 <povman> jedbrown: thanks
04:14:34 <mux> _ is a LHS term, and undefined a RHS term
04:14:43 <kaol> > 1 + undefined -- trying to evaluate undefined...
04:14:46 <lambdabot>  Undefined
04:14:51 <sizur> > let undefined = 1 in undefined
04:14:52 <lambdabot>  1
04:15:05 <kaol> > length [undefined, undefined]
04:15:06 <lambdabot>  2
04:15:23 * mux is being told that 'Haskell' is an anagram of 'Ask Hell'
04:15:25 <vincenz> > let special [_, _] = 2 in special [1,2]
04:15:25 <kaol> but it's ok to pass them around if you don't evaluate them
04:15:26 <lambdabot>  2
04:15:34 <vincenz> > let special [_, _] = 2 in special [undefined,undefined]
04:15:35 <lambdabot>  2
04:15:48 <jedbrown> povman: np.  I don't know why it's not available somewhere (or I don't know where).
04:15:48 <vincenz> fbuilesv: basically you use _ as a pattern variable when you don't care about its value
04:15:59 <fbuilesv> yes, that's what I'm seeing
04:16:05 <kaol> > let special [_] = 2 in special [1,2]
04:16:06 <lambdabot>   Non-exhaustive patterns in function special
04:16:13 <kaol> > let special _ = 2 in special [1,2]
04:16:14 <lambdabot>  2
04:16:19 <vincenz> undefined is just a variable name, and if not redefined, it stands for _|_
04:16:34 <vincenz> @src undefined
04:16:34 <lambdabot> undefined =  error "Prelude.undefined"
04:16:53 <fbuilesv> perfect, thanks for your help guys :)
04:17:47 <sizur> haskell's doomed to fail it's goal
04:18:13 <sizur> we're only taking a last stand ;)
04:21:18 * povman ponders the relationship between natural language and lambda calculus
04:21:44 <meryrus> povman, abandon hope, all ye who enter there :)
04:26:04 <povman> meryrus: it's been tried?
04:34:13 <earthy> povman: WoLLIC
04:34:36 <earthy> and iirc chung chie-shan has some papers on it
04:47:53 <nominolo> :t concatMap
04:47:55 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:48:07 <nominolo> :t liftM concat (mapM f xs)
04:48:08 <lambdabot> Not in scope: `f'
04:48:08 <lambdabot> Not in scope: `xs'
04:48:20 <nominolo> :t \f xs -> liftM concat (mapM f xs)
04:48:22 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
04:49:26 <vincenz_> :t concatMapM
04:49:27 <lambdabot> Not in scope: `concatMapM'
04:49:53 <opqdonut> :t liftM concatMap
04:49:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> [b]) -> m ([a] -> [b])
04:49:57 <quicksilver> :t concat `fmap` mapM
04:49:58 <litb> hello all
04:49:58 <lambdabot>     Couldn't match expected type `[[a]]'
04:49:59 <lambdabot>            against inferred type `[a1] -> m [b]'
04:49:59 <lambdabot>     Probable cause: `mapM' is applied to too few arguments
04:50:06 <opqdonut> ah, quicksilver has it
04:50:09 <litb> i've been looking for a symbolic integration library
04:50:15 <quicksilver> :t \f -> concat `fmap` mapM d
04:50:16 <lambdabot> Not in scope: `d'
04:50:17 <quicksilver> :t \f -> concat `fmap` mapM f
04:50:18 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:50:23 <nominolo> @check \f xs -> concatMap f xs = runIdentity $ concatMapM (liftM ) (Identity xs)
04:50:23 <lambdabot>  Parse error at "=" (column 25)
04:50:34 <nominolo> @check \f xs -> concatMap f xs == runIdentity $ concatMapM (liftM f) (Identity xs)
04:50:40 <lambdabot>   Not in scope: data constructor `Identity'
04:51:27 <nominolo> :t \f xs -> concat <$> mapM f xs
04:51:28 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
04:52:07 <nominolo> > length "concat <$> mapM" - length "concatMapM"
04:52:08 <lambdabot>  5
04:52:16 <litb> are there some libraries for this?
04:52:34 <nominolo> litb: what does hackage say?
04:54:14 <litb> ah i will look for it
04:57:47 <litb> nominolo: hm, there isn't one
05:00:04 <nominolo> > (+4) `fmap` (*5) $ 42
05:00:05 <lambdabot>  214
05:04:50 <ehird> i am about to upgrade ghc, from source.
05:05:03 <ehird> wish me luck, this might take a few hours \o/
05:05:11 <ehird> oh damn.
05:05:15 <ehird> they don't have 6.8 yet
05:05:17 <ehird> just 6.6.1
05:05:36 <sizur> ehird, if you're doing it from the source, why not get it from the source then?
05:05:47 <sizur> haskell.org/ghc
05:05:49 <ehird> sizur: this is a good point but my darcs is installed through macports too :I
05:06:03 <sizur> ehird, you dont need darcs
05:06:43 <ehird> sizur: yes i do need darcs ;)
05:06:48 <ehird> and darcs is compiled with ghc, etc...
05:06:52 <ehird> i like having my software managed
05:06:59 <ehird> so i can't 'just' have ghc manually installed
05:07:02 <ehird> all my haskell software would be too
05:07:31 <sizur> ok :) time to contribute to macports then i guess?
05:08:17 <ehird> yeppers
05:09:04 <ehird> oh, and this is beautiful: http://darcs.haskell.org/ghc/driver/mangler/ghc-asm.lprl
05:09:17 <ehird> (For a start, it's Literate Perl)
05:10:08 <sizur> is it through a source filter? i've never seen a real literate perl
05:10:50 <sizur> or you have to strip away latex with a preprocessor manually?
05:10:58 <quicksilver> I presume you preprocess it
05:11:44 <osfameron> is it really literate perl?  as in mangle/woven or whatever it is that real literate programming is supposed to do
05:11:52 <sizur> i wonder how those long lines look like after latex2pdf
05:12:12 <quicksilver> osfameron: it's not web, but I don't htink even Knuth would say web was the only literate programing system...
05:12:14 <sizur> osfameron, not really
05:12:48 <osfameron> sure, but isn't the idea of literate programming that you write it in whatever order it makes sense to read it in
05:13:01 <quicksilver> yes.
05:13:04 <osfameron> and the compiler worries about pieceing it together the way the computer can read it
05:13:04 <sizur> that's the exact purpose
05:13:13 <osfameron> otherwise you might as well say perl's POD was literate programming
05:13:13 <quicksilver> however you can almost do that just by using subs in perl or definitions in haskell
05:13:16 <quicksilver> ;)
05:13:27 <osfameron> well sure, haskell more or less does that
05:13:30 <osfameron> apart from imports
05:13:39 <sizur> you still need some prose :P
05:13:41 <ehird> hooray for clever compilers
05:13:46 <ehird> :)
05:13:49 <osfameron> and the fact that you can't define multiple cases for a function in different places
05:14:20 <quicksilver> web also added a kind of macro abstraction to pascal
05:14:24 <osfameron> but Perl doens't really do that, apart from the obvious subroutine abstraction
05:14:28 <quicksilver> making a strictly more powerful language
05:14:38 <quicksilver> (in the loose sense of expressiveness)
05:14:50 <sizur> oh my. elsif's look scary
05:14:55 <what-> can someone explain how this works: [1,2,3] >>= replicate 2
05:14:58 <sizur> but i've seen worse
05:15:11 <quicksilver> what-: it's down to the behaviour of the list monad
05:15:30 <quicksilver> > [1,2,3] >>= replicate 2
05:15:31 <lambdabot>  [1,1,2,2,3,3]
05:15:32 <what-> i suppose :-)
05:15:37 <quicksilver> > concatMap (replicate 2) [1,2,3]
05:15:38 <lambdabot>  [1,1,2,2,3,3]
05:15:44 <quicksilver> that's what >>= means, for lists.
05:15:46 <quicksilver> concatMap
05:15:53 <what-> thx
05:16:06 <quicksilver> with the arguments swapped, as you can see.
05:16:57 <ToRA> @src [] (>>=)
05:16:57 <lambdabot> m >>= k     = foldr ((++) . k) [] m
05:17:01 <ToRA> @src concatMap
05:17:01 <lambdabot> concatMap f = foldr ((++) . f) []
05:18:58 <ehird> actually why isn't the mangler in Haskell or C or something
05:19:00 <ehird> perl is an odd choice :-)
05:19:14 <ehird> i mean - heck, a sed or awk script
05:19:24 <ehird> but i wouldn't expect a haskell compilation system to acknowledge perl ;)
05:19:56 <sizur> ehird, wow
05:20:08 <jedbrown> ehird: Your patch is certainly welcome :)
05:20:12 <sizur> ehird, a java coder?
05:20:22 <ehird> sizur: ?
05:20:25 <ehird> jedbrown: :)
05:20:28 <ehird> (!)
05:20:55 <ehird> okay, all i've done is changed the version number. let's hope this works!
05:20:56 <ehird> hm
05:21:02 <ehird> better do a clean uninstall/reinstall
05:21:10 <ehird> ghc being epic and all.
05:21:28 <sizur> ehird, why wouldn't you expect haskell to acknowledge perl?
05:21:41 <ehird> sizur: 'cause, it's perl ;)
05:21:43 <sizur> the world is dirty
05:21:54 <ehird> you can see they were strained when writing it, they just HAD to have literate style
05:22:42 <sizur> why again? i fail to see the reason
05:22:42 <quicksilver> ehird: your answer is here : http://xkcd.com/224/
05:22:43 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:22:57 <quicksilver> sizur: because perl is a disastrous language.
05:23:03 <quicksilver> and I say that as a fulltime perl programmer
05:23:05 <ehird> sizur: programmer stereo types! :P
05:23:08 <ehird> and also what quicksilver said.
05:23:31 <sizur> quicksilver, how can you continue to code it then? i cannot code something i hate
05:23:33 <ehird> yes -- stereo types. perl coders are ghettoblasters.
05:23:43 <ehird> sizur: Just a guess.. Money?
05:23:45 <quicksilver> the idea of a compiler for an advanced semantically pure language depending on a program, written in perl, which directly mangles the asm output of GCC
05:23:53 <ehird> quicksilver: ... is awesome
05:23:53 <quicksilver> is one of the most beautiful ironies I've seen :)
05:23:59 <sizur> ehird, there ar ebigger money elsewhere
05:24:07 <quicksilver> sizur: I didn't say I hated it.
05:24:11 <quicksilver> I said it was a disaster.
05:24:18 <quicksilver> it's a disaster I'm rather fond of.
05:24:22 <sizur> heh
05:24:23 <ehird> quicksilver: Well, to be honest it was ironic as soon as it added an impure backend...
05:24:37 <ehird> Haskell is only pure, advanced, and semantically clean when you talk about it in a paper :-)
05:24:43 <sizur> ehird, purity is an imagination
05:24:59 <sizur> we like to think pure
05:25:04 <ehird> sizur: exactly
05:25:10 <ehird> even without an IO backend, you need memory allocation
05:25:13 <sizur> but you have to get dirty
05:25:25 <ehird> but i have to say i don't think a pure universe would be particularly exciting
05:25:31 <ehird> Error: Checksum (md5) mismatch for ghc-6.8.2-src.tar.bz2
05:25:31 <ehird> Error: Checksum (md5) mismatch for ghc-6.8.2-src-extralibs.tar.bz2
05:25:31 <ehird> Error: Target org.macports.checksum returned: Unable to verify file checksums
05:25:33 <ehird> goddamn
05:25:33 <ehird> ;)
05:25:45 <ehird> hm, does the ghc site have checksums?
05:26:07 <daniel_larsson> There's probably a file containing 6.6.1 checksums. Run md5 on your downloaded tarball and update accordingly )
05:26:24 <ehird> daniel_larsson: I can't verify MY tarball is okay, though. :-P
05:26:40 <daniel_larsson> Then hope ghc have uploaded checksums )
05:26:54 <ehird> i don't think they do glancing at the site
05:26:58 * ehird ftp's
05:27:04 * ehird wonders why people still use ftp..
05:27:31 <mux> I've been asking myself this question for the last ten years
05:27:56 <ehird> mux: Indeed.
05:28:08 <ehird> It might be faster than HTTP, but jeez, that's totally not a reason to use FTP
05:28:17 <ehird> Best solution: offer HTTP and BitTorrent.
05:28:40 <ehird> If someone comes up with a non-sucky FTP replacement (i.e. 'fast public data access' protocol), offer that too.
05:29:21 <ehird> http://lml.ls.fi.upm.es/ftp/lenguajes/haskell/ghc/ Yow. That's old!
05:29:21 <lambdabot> Title: Index of /ftp/lenguajes/haskell/ghc
05:29:46 <mux> I'd be happy with any FTP replacement that doesn't leak transport protocol information into the application protocol layer
05:30:42 <ehird> mux: And that didn't reverse the client and server when it feels like it..
05:30:56 <mux> ehird: this stems from the flaw I just mentioned
05:30:57 <Zao> Can anyone recommend any image saving library bindings that isn't Imlib?
05:31:16 <Zao> Imlib seems to be do things horribly wrong on non-square images.
05:31:56 <ehird> http://www.haskell.org/ghc/dist/6.8.2/ no md5! wtf, haskell.org
05:31:56 <lambdabot> Title: Index of /ghc/dist/6.8.2
05:34:23 <ehird> well, it's on to extracting
05:34:23 <yondalf> does anyone do pdf generation with haskell? what libraries do you use?
05:34:28 <ehird> i hope this works
05:35:08 <quicksilver> yondalf: I think hpdf is the mos tmature
05:35:15 <quicksilver> yondalf: eg http://www.alpheccar.org/en/posts/show/82
05:35:16 <lambdabot> Title: HPDF 1.1 : Introducing typesetting
05:35:33 <jedbrown> @where pandoc
05:35:34 <lambdabot> http://johnmacfarlane.net/pandoc/
05:35:40 <yondalf> quicksilver: not much documentation on that though right
05:35:45 <jedbrown> yondalf: ^^^ That library looks interesting.
05:36:49 <ehird> @hpaste
05:36:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:36:50 <yondalf> jedbrown: pandoc can't write pdf and anyway i think it's more of a markup to markup converter
05:37:14 <hpaste>  ehird pasted "this patch fails. Does anyone know: 1. is it still needed? 2. if so, where should it be patching ins" at http://hpaste.org/5316
05:37:19 <ehird> ..tead
05:37:34 <yondalf> am i better off getting a c library (e.g. libharu) and writing my own haskell bindings to it?
05:37:37 <quicksilver> well it can write latex which can be urned into pdf
05:37:55 <jedbrown> yondalf: Yes, it uses pdflatex.
05:38:08 <quicksilver> yondalf: there already is a binding to libharu
05:38:11 <Zao> yondalf: There's bindings for haru already.
05:38:18 <quicksilver> yondalf: surely it cannot be that you didn't check hackage before asking? :)
05:38:33 <yondalf> according to hackage, it apparently fails on ghc 8.2 if i understand the log
05:38:49 <yondalf> and there's no documentation, not even a list of functions
05:38:54 <yondalf> yes, i checked :-)
05:39:10 <quicksilver> audreyt: Oi.
05:39:22 <quicksilver> audreyt: does hsharupdf work and why doesn't it have haddock?
05:40:15 <yondalf> i currently generate my pdfs using a lua script (historical reasons...lua was never meant to do such text manipulation and it shows) to generate tex with some complicated hacks to get vertical text justification
05:40:15 <quicksilver> looks like it might have got broken by the new haddock.
05:40:34 <quicksilver> its build error is a haddock error
05:41:08 <sizur> #perl
05:41:18 <ehird> :|
05:42:02 <yondalf> sizur: i never liked perl though :-)
05:42:45 <sizur> yondalf, oh that wasnt meant for you. i wanted to join perl channel to check how perlbot evaluates expressions
05:43:19 <ehird> badly?
05:46:14 <ehird> anyone? :)
05:49:08 <quicksilver> ehird: try dcoutts
05:49:29 <dcoutts> hello?
05:49:32 <ehird> heh
05:49:49 <quicksilver> dcoutts: http://hpaste.org/5316
05:50:39 <Igloo> You could fix your packaging system instead  :-)
05:50:56 <ehird> Igloo: well, that's not exactly my duty ;)
05:51:07 <dcoutts> ehird: I don't think cabal creates empty directories any more
05:51:10 <ehird> i use macports, i patch a portfile when i want an upgrade... sometimes it goes wrong :D
05:51:18 <ehird> dcoutts: OK. I'll just remove that patch then
05:51:29 <ehird> the portfiles are tcl code
05:51:31 <ehird> which is.. fun
05:51:40 <dcoutts> ehird: if you find it still does, please submit a cabal bug report
05:51:44 <ehird> they have a DSL that makes it look all trivial but then you get the complex ones
05:53:15 <ehird> the only thing worse is fink... which has a horrible ported apt-get which they wrap around and aaaaa
05:54:56 <ehird> libraries/X11/package.conf.in disappeared..
05:55:15 <ehird> macports tries to patch it by adding  /usr/X11R6/lib to its library-dirs
05:55:21 <ehird> is it actually gone or just renamed?
06:09:12 <matthew-_> @smack ToRA
06:09:13 <lambdabot> Unknown command, try @list
06:09:18 <matthew-_> @slap ToRA
06:09:18 * lambdabot clobbers ToRA with an untyped language
06:09:22 <matthew-_> better.
06:11:29 <ehird> like Forth!
06:11:36 <ehird> wait, no, that can't be right, i like worth
06:11:39 <ehird> ..forth
06:15:44 <opqdonut> forth is cute
06:15:52 <opqdonut> tho False might be even cuter
06:19:24 * sizur listening to Nemesis the Warlock
06:19:27 <sizur> anybody remembers that?
06:19:38 <osfameron> listening?
06:19:47 <sizur> yeah, the music
06:19:52 <osfameron> I remmeber the comic
06:20:03 <sizur> it was a C64 game
06:20:31 <sizur> http://81.186.251.7:8000 -- just some random spam
06:20:44 <osfameron> ah
06:30:11 <ehird> opqdonut: False is kind of cute, but not as much so
06:30:15 <ehird> 1. it's probably not turing complete, for one
06:30:26 <ehird> 2. it doesn't have the general 'feel' of forth systems, it feels like a modern system just happening to use a stack
06:30:36 <ehird> Personally, for weird concatentative languages I like Joy.
06:30:47 <ehird> The C code is _weird_.
06:31:04 <ehird> The guy who made it is evidently insane, the language's site is in a /philosophy/ directory :P
06:31:46 <opqdonut> ehird: huh? not turing complete? of course it is
06:31:59 <ehird> opqdonut: no, sorry.
06:32:02 <ehird> see the esolang wiki.
06:32:05 <ehird> (esolangs.org/wiki/FALSE)
06:32:28 <ehird> so it *might* be
06:32:35 <opqdonut> http://wouter.fov120.com/false/ ?
06:32:36 <lambdabot> Title: Wouter's False page
06:32:50 <ehird> http://esolangs.org/wiki/Talk:FALSE suggests it might be, though
06:32:50 <lambdabot> Title: Talk:FALSE - Esolang
06:32:51 <ehird> opqdonut: yes
06:33:06 <ehird> ah
06:33:10 <ehird> no, it isn't, technically
06:33:10 <opqdonut> well of course it is, there's plenty of code examples on the site
06:33:12 <ehird> see the talk page
06:33:15 <ehird> opqdonut: ...
06:33:20 <ehird> you don't need TCness to have code examples.
06:33:25 <ehird> don't be silly.
06:34:30 <opqdonut> gah, the discussion page is only talkin about the 2^31 stack size limit
06:34:34 <ehird> if you join #esoteric, as soon as anyone wakes up who knows FALSE they might be happy to argue with you :-)
06:34:51 <ehird> opqdonut: ...that limit on values is defined by the spec
06:34:57 <ehird> and it MIGHT be TC without it
06:35:01 <ehird> but still unsure
06:35:21 <opqdonut> well i'd look on it more as part of the implementation spec and not the language spec :)
06:35:43 <opqdonut> well i think w/o the limit turing-completeness is pretty clear as the discussion page has a bf interpreter in false?
06:36:00 <ehird> not quite, no
06:36:48 <opqdonut> well okay, not an interpreter but an embedding
06:49:36 <jonaskoelker> @hoogle Int -> String
06:49:37 <lambdabot> No matches, try a more general search
06:50:19 <mux> > show 42
06:50:23 <lambdabot>  "42"
06:50:34 <jonaskoelker> bah, wrong way around
06:50:36 <jonaskoelker> @hoogle String -> Int
06:50:37 <lambdabot> No matches, try a more general search
06:50:44 <mux> > read "42"
06:50:45 <lambdabot>  42
06:50:49 <jonaskoelker> ty
06:50:53 <mux> yw
06:51:01 <jonaskoelker> what's argv called?
06:51:20 <mux> there is no globally available variable for argv, you use that instead:
06:51:23 <mux> :t getArgs
06:51:28 <lambdabot> Not in scope: `getArgs'
06:51:36 <jonaskoelker> System.getArgs, right?
06:51:41 <jonaskoelker> :t System.getArgs
06:51:42 <lambdabot> IO [String]
06:52:08 <mux> right
06:53:10 <byorgey> :t System.Environment.getArgs
06:53:11 <lambdabot> IO [String]
06:53:22 <byorgey> I think System.Environment is the "canonical" import for getArgs
06:53:30 <byorgey> System is just included for backwards compatibility
06:53:32 <mux> if canonical means "non haskell98"
06:53:56 <byorgey> oh, erm... never mind then =)
06:54:28 <byorgey> I guess it doesn't really matter too much in practice =)
06:55:29 <quicksilver> yes, canonical does mean non-haskell98
06:55:39 <quicksilver> that is the correct interpretation :)
06:55:49 <quicksilver> canonical means the new hierarchical libraries, which are preferred.
06:56:00 <mux> heh
06:56:14 * mux prefers them too
06:57:57 <jonaskoelker> how do I write negative numbers?
06:58:07 <jonaskoelker> I've tried -1, and 0-1 looks ugly -.-
06:58:27 <ddvlad> jonaskoelker: try (-1)
06:58:35 <byorgey> jonaskoelker: ah, you've found the dirty secret ;)
06:58:46 <what-> where can I find recent wxhaskell binaries for Windows?
07:04:04 <shapr> lispy: could you run the social network on the last few weeks of log files?
07:04:48 <glen_quagmire> shapr shapr shapr  /me tries to be connected to shapr in the graph
07:04:59 * shapr looks at glen_quagmire
07:05:07 <ddvlad> what social network? :-/
07:05:14 * ddvlad is disorieted
07:05:32 <shapr> ddvlad: It's in the topic.
07:05:55 <ddvlad> oops, i should remember that things like topic change
07:05:59 <ddvlad> thanks :-)
07:08:12 <shapr> CosmicRay: changing nick?
07:08:22 <CosmicRay> nah just some irc client confusion
07:08:26 <CosmicRay> am I showing up as CosmicRay again?
07:08:38 <byorgey> CosmicRay: no ;)
07:08:41 <shapr> yup
07:08:43 <shapr> oops
07:08:43 <CosmicRay> I'm IRCing from a Jabber client using a jabber-to-IRC gateway
07:08:45 <CosmicRay> heh
07:08:52 <shapr> I'm using pidgin.
07:08:59 <CosmicRay> byorgey: your nick complete betrays you
07:09:29 <CosmicRay> and jabber lets you have a different nick in each "chat room", but IRC doesn't.  one of my chat bookmarks had the wrong nick, which changed all of them
07:09:32 <byorgey> betrays me?
07:09:54 <CosmicRay> byorgey: well, if you were trying to convince me I wasn't CosmicRay, it may have worked better to not start your comment with "CosmicRay: " ;-)
07:10:31 <byorgey> oh, so it's YOUR nick that betrays me. indeed. =)
07:13:30 <resiak> @hoogle CInt -> Int
07:13:31 <lambdabot> No matches, try a more general search
07:14:10 <Saizan> resiak: fromIntegral could work
07:14:11 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
07:15:29 <resiak> yeah; shame that because I have to deal with GErrors I can't just use c2hs's {#fun#}
07:16:26 <jedbrown> resiak: What is GError?
07:17:12 <resiak> jedbrown: The GLib exception mechanism
07:17:15 <jedbrown> resiak: There is recently added support for a return value that is checked (in IO), but not returned.
07:17:43 <resiak> jedbrown: int foo(int x, int y, GError **foo); // if foo is non-NULL when this returns, an exception was thrown
07:17:52 <resiak> erm, that should be GError **err, obviously
07:18:41 <jedbrown> resiak: So you want to check it and throw an exception if it is non-NULL?
07:19:57 <resiak> well, System.Glib.GError has a helper for this, propagateGError
07:20:21 <jedbrown> resiak: The new feature is the *- output specifier (which I requested).
07:20:24 <hpaste>  resiak pasted "propagating the GError" at http://hpaste.org/5318
07:21:12 <resiak> jedbrown: could i implement that ^^ more concisely using {#fun#} and this *- specifier?
07:21:40 <jedbrown> resiak: MPI has similar functionality.  It returns an integer, which if non-null represents an error.
07:21:58 <jedbrown> resiak: There is another function I can call which turns the error number into a string.
07:22:22 <resiak> i'd like to avoid having to marshall every CInt to an Int manually, but can't get my head around how the {#fun#} hook should look
07:26:06 <jedbrown> resiak: {# fun foo as ^ { `Int' -, `Int' -, `GError' propErr*- } -> - `Int' #}
07:26:16 <jedbrown> resiak: I think something like that would work.
07:26:56 <jedbrown> resiak: Well, probably with alloca- as the inmarshaller for GError.
07:27:04 <resiak> so I can just use regular functions as marshallers?
07:28:05 <jedbrown> resiak: There is a distinction between monadic and non-monadic.  The * says it is monadic.
07:29:02 <resiak> No, I mean, propErr there is just an arbitrary Haskell function with the right (potentially IO-adic) type signature ?
07:30:19 <jedbrown> resiak: Yes, something like  propErr :: GError -> IO ()
07:30:49 <glen_quagmire> http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project  is this up to date?  is it really recommended to have proj/src directory? i've seen some projects like proj/ModuleName/
07:30:49 <lambdabot> Title: Structure of a Haskell project - HaskellWiki
07:32:11 <daniel_larsson> glen_quagmire: With hierarchical names, I guess it makes sense to skip the src directory for library projects
07:33:28 <glen_quagmire> hrm i'll use src just in case
07:33:36 <Saizan> i find having a src/ tidier and it's useful when you've to grep
07:36:31 <resiak> jedbrown: cool!
07:36:43 <jedbrown> resiak: It's working?
07:37:00 <resiak> jedbrown: i was AFK; i'm trying now
07:43:27 <ricky_clarkson> resiak: Ah, you've found a decent language!
07:44:39 <hpaste>  resiak pasted "I'm unclear what type the TrackerClient in marshaller should have" at http://hpaste.org/5319
07:44:50 <resiak> ricky_clarkson: hmm?
07:47:15 <RayNbow> hmm, is it a good idea to re-use the type Gen (from QuickCheck) if I want to write an application that needs to create random data?
07:52:08 <shag> does a QuickCheck generator for strings exist?
07:53:26 <shag> oh. just found one in the wiki ... never mind
07:53:32 <int-e> @check \a -> "" == a
07:53:32 <lambdabot>  Falsifiable, after 0 tests: "\228307"
07:54:26 <byorgey> RayNbow: sure, why not?
07:56:08 <jedbrown> @check ((\f x -> f x == f x) :: (Float -> Int) -> Float -> Bool) -- Works with QC-2
07:56:11 <lambdabot> Terminated
07:56:27 <RayNbow> byorgey: well... I read something in the source file... lemme look it up
07:57:05 <RayNbow> "-- This file represents work in progress, and might change at a later date.
07:57:56 <RayNbow> ( http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/src/Test-QuickCheck.html )
07:57:59 <lambdabot> http://tinyurl.com/385qcl
07:59:21 <Saizan> RayNbow: if it changes you can still depend on this version of the package, rather than the latest
07:59:38 <byorgey> phlpp: does it happen with other windows?  or just urxvt?
07:59:47 <byorgey> sorry, mischan
08:01:38 <litb> hello all =)
08:01:58 <litb> @records
08:01:58 <lambdabot> Unknown command, try @list
08:02:10 <litb> meh how was that called?
08:02:23 <Saizan> @users
08:02:23 <lambdabot> Maximum users seen in #haskell: 463, currently: 432 (93.3%), active: 16 (3.7%)
08:03:00 <quicksilver> @check \a -> ( reverse . reverse ) a == a
08:03:01 <lambdabot>  Add a type signature
08:03:01 <litb> thxx :)
08:03:12 <quicksilver> @check \a -> ( reverse . reverse ) a == (a :: String)
08:03:12 <lambdabot>  OK, passed 500 tests.
08:06:05 <RayNbow> hmm, when will #haskell reach 500 users? :p
08:07:22 <earthy> soonish
08:07:23 <balodja> A few days ago there were more than 600 users.
08:07:30 <earthy> there were?
08:07:59 <balodja> @losers
08:07:59 <lambdabot> Maximum users seen in #haskell: 463, currently: 433 (93.5%), active: 19 (4.4%)
08:08:07 <balodja> Hm :)
08:09:20 <quicksilver> I find that surprising
08:09:25 <quicksilver> I don't think it's been up near 600
08:09:36 <quicksilver> it's been fairly slow steady grwoth for the last year or so
08:10:52 <resiak> practically every function in this C API (apart from connect and disconnect) takes a TrackerClient* as its first argument.  Should I bind them as MonadIO m => ReaderT TrackerClient m a (for appropriate a) and provide a TrackerM m a type synonym, as ReaderT TrackerClient IO a, or just stop overcomplicating matters and make them TrackerClient -> ... -> IO a? :-)
08:11:24 <resiak> for "should", read "is it worth" (with appropriate gramattical changes).  (I should stop accidentally hitting ^M.)
08:11:32 <earthy> resiak: first do the trivial binding
08:11:38 <resiak> fair point :-)
08:11:42 <earthy> then add a monadic layer
08:11:54 <earthy> (or a nicer one, if you can devise one)
08:12:28 <earthy> there is some chance that the trivial binding will change, and keeping it trivial localizes the changes to the haskell-world only abstractions
08:12:57 <resiak> mmm.   every function foo has a foo_async version with callback parameters; but maybe I should just ignore them and let people do threading in the Haskell world
08:13:27 * earthy nods
08:13:37 <jedbrown> c2hs might be guilty of making it seem possible to write the Haskell API in one step.
08:13:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5322
08:14:02 <jedbrown> But that is likely to make the interface rather C-like.
08:14:23 <earthy> jedbrown: this is not a bad thing per se
08:14:34 <earthy> as the API *is* rather C-like
08:15:02 <earthy> pulling that into the Haskell world and *then* abstracting is much nicer than first abstracting and then pulling it into the haskell world...
08:15:19 <jedbrown> earthy: Indeed, but not when a pure interface to the functionality is possible.
08:15:30 * jedbrown likes c2hs a lot
08:15:56 <resiak> there's really no obvious pure interface to an auto-updating metadata intex :)
08:16:34 <earthy> jedbrown: um, even in that case you're going to have to cross the boundary to C at one point or another. you may not want to expose the raw bindings to others...
08:17:05 <jedbrown> earthy: I was referring to writing the haskell-world in one shot.  With raw FFI, it is clear that you need another level to live in the Haskell world.
08:18:33 <earthy> jedbrown: usually you're better off not writing the haskell-world in one shot
08:18:46 <jedbrown> resiak: Not obvious, but conal might argue there is.
08:19:18 <jedbrown> earthy: I agree, I was just noting that c2hs makes it look possible, even when it's not desireable.  Of course it saves a ton of time either way.
08:19:30 <hpaste>  (anonymous) pasted "hashed_inventory snippet" at http://hpaste.org/5323
08:19:43 <quicksilver> resiak: be aware that the synchronous version will block the whole haskell world unless people compile with -threaded and run with -N2
08:19:44 <resiak> jedbrown: feh
08:20:47 <balodja> Are there anywhere logs of #haskell on-line?
08:20:49 <resiak> quicksilver: happily, i'm going to use this in a fuse filesystem compiled with -threaded and run with -N2 :-)
08:20:58 * balodja wants to pick up some statistics :)
08:21:13 <jedbrown> balodja: Read the channel topic.
08:21:28 <balodja> Yep. I see.
08:30:59 <MyCatVerbs> quicksilver: doesn't using forkOS instead of forkIO for the blocking parts get rid of that problem anyway?
08:31:57 <quicksilver> MyCatVerbs: only if you compile wth -threaded and run with -N2
08:32:00 <quicksilver> MyCatVerbs: which is what I said :)
08:32:07 <MyCatVerbs> quicksilver: oO
08:32:11 <quicksilver> MyCatVerbs: forkOS actually solves a different problem.
08:32:16 <quicksilver> forkOS is about making bound threads.
08:32:29 <MyCatVerbs> quicksilver: you sure? I have code right here that calls accept() blockingly in a forkOS'd action.
08:32:43 <MyCatVerbs> quicksilver: works fine - compiled with -threaded, but with without -N2.
08:32:50 <quicksilver> you'll find it works with forkIO()
08:34:27 <MyCatVerbs> quicksilver: the docs say "Just to clarify, forkOS is only necessary if you need to associate a Haskell thread with a particular OS thread. It is not necessary if you only need to make non-blocking foreign calls (see Control.Concurrent#osthreads)."
08:35:01 <MyCatVerbs> quicksilver: they're not completely explicit on the point, but I read that to mean that you -do- need to use forkOS if you intend to use blocking foreign calls without blocking the rest of the program too.
08:35:23 <Cin> :t (:[])
08:35:24 <lambdabot> forall a. a -> [a]
08:35:35 <Cin> @hoogle forall a. a -> [a]
08:35:35 <lambdabot> Did you mean: Forall A. a -> [a]
08:35:36 <lambdabot> Prelude.repeat :: a -> [a]
08:35:36 <lambdabot> Data.List.repeat :: a -> [a]
08:35:42 <jedbrown> quicksilver: forkIO () doesn't type-check
08:38:28 <jedbrown> MyCatVerbs: My understanding is that the forkOS is only needed when the foreign library has thread-local storage.
08:40:31 <pjd> MyCatVerbs: the foreign call just needs to be marked "safe" to not block Haskell threads, i think
08:41:01 <jedbrown> MyCatVerbs: The threaded runtime keeps a pool of threads so forkIO'd threads can be blocked in foreign calls without blocking everything.
08:41:36 <JaffaCake> MyCatVerbs: the docs are right, you don't need to use forkOS to get non-blocking calls
08:42:08 <JaffaCake> it's a source of much confusion, and I can see that updating the docs hasn't helped, people just think the docs are wrong :)
08:43:48 <MyCatVerbs> JaffaCake: I'm not even saying the docs are wrong.
08:44:15 <MyCatVerbs> JaffaCake: but the docs say "not necessary if you only need to make non-blocking foreign calls"
08:44:59 <MyCatVerbs> JaffaCake: which makes it sound like forkOS is necessary for blocking foreign calls. :/
08:45:16 <Philippa> people do tend to read if as iff
08:45:33 <Philippa> for working out worst cases if nothing else
08:45:33 <JaffaCake> oh blimey, I never intended that
08:45:35 <MyCatVerbs> Philippa: my mistake exactly.
08:45:50 <JaffaCake> any suggestions for wording?
08:46:00 <jedbrown> Perhaps `if you only need to make blocking foreign calls without blocking other threads'
08:46:23 <JaffaCake> it's the use of the word "blocking" that's confusing, as usual
08:46:30 <quicksilver> MyCatVerbs: the docs mean to say "if you want to make blocking foreign calls without blocking your other haskell threads"
08:46:38 <JaffaCake> the docs are using non-blocking in the sense of not blocking other threads
08:46:40 <phobes> mom:  "You can go to the movies if you clean your first".   child, upon returning from the movies: "oh, did you mean I couldn't go if I didn't clean my room?"
08:47:00 <pjd> "non-blocking calls" -> "blocking calls, without blocking other Haskell threads"
08:47:09 <quicksilver> MyCatVerbs: forkOS is only needed to certainly very specific foreign libraries wich do funky thinks with specific OS-level threads.
08:47:25 <quicksilver> with apologies for that dire typing
08:48:38 <JaffaCake> perhaps forkOS should be called forkBoundThread
08:48:49 <quicksilver> forkBound might suffice
08:48:57 <phobes> forkOS sounds really expensive!
08:48:59 <quicksilver> or forkBoundIO
08:49:09 <quicksilver> (since it *is* a version of forkIO)
08:49:10 <JaffaCake> quicksilver: right
08:49:23 <quicksilver> forkOS sound like it definitely spawns a fresh OS thread
08:49:30 <quicksilver> which is kind of the opposite of what it does :)
08:49:42 <JaffaCake> well, it does spawn a fresh OS thread
08:49:50 <JaffaCake> and a fresh Haskell thread
08:50:19 <def> hello, I've a newbie question: how come Data.Bits.shiftL takes an Int
08:50:35 <def> when the doc precises that the argument must be non-negative?
08:50:50 <quicksilver> ah yes
08:50:54 <matthew-_> because Haskell often uses imprecise types
08:50:56 <matthew-_> annoyingly
08:51:02 <matthew-_> @type sqrt
08:51:04 <lambdabot> forall a. (Floating a) => a -> a
08:51:20 <matthew-_> > sqrt (-9)
08:51:22 <lambdabot>  NaN
08:52:02 <doserj> > sqrt (-9::Complex Double)
08:52:02 <lambdabot>  -0.0 :+ 3.0
08:52:05 <def> ok, thanks matthew, I thought that I had missed something
08:52:25 <quicksilver> I think one possible answer is 'for efficienty'
08:52:30 <quicksilver> Int is an efficient type
08:52:39 <quicksilver> the Word types aren't necessarily
08:52:44 <matthew-_> doserj: ok, that shut me up ;)
08:53:05 <quicksilver> also, there isn't a Word type guaranteed to be the same length as Int
08:53:25 <JaffaCake> quicksilver: well, there's Word
08:53:27 <Deewiant> Int is like C's int in that it's a "platform-specific fast integer" or whatever, then?
08:53:57 <quicksilver> is there?
08:54:00 <quicksilver> :k Word
08:54:00 <lambdabot> *
08:54:06 <matthew-_> why doesn't shiftL with a negative number just call shiftR ?
08:54:06 <JaffaCake> :k Data.Word.Word
08:54:07 <lambdabot> *
08:54:14 <quicksilver> JaffaCake: Odd. I never knew that.
08:54:19 <quicksilver> live and learn.
08:54:25 <JaffaCake> it's not well publicised
08:54:39 <def> quit
08:54:49 <quicksilver> I knew about Word8 and Word16 and Word32 etc :)
08:54:53 <quicksilver> but for some reason not Word.
08:55:06 <JaffaCake> I think it went away and then came back at some stage
08:55:14 <codemac_> how do I do a modulus in haskell?  I just want x % 5 == 0
08:55:16 <Deewiant> @index Word
08:55:17 <lambdabot> Data.Word, Foreign, GHC.Exts
08:55:24 <matthew-_> codemac_: mod
08:55:28 <codemac_> awesome
08:55:30 <codemac_> ha
08:55:33 <Deewiant> x `mod` 5 == 0
08:56:26 <mux> :t (== 0) . (`mod` 5)
08:56:27 <lambdabot> forall a. (Integral a) => a -> Bool
08:58:34 <matthew-_> mux: you're quite sure you don't want to drop the infix and use flip there?
08:58:38 <matthew-_> ;)
08:59:01 <mux> mmm, quite :)
08:59:52 <quicksilver> I always prefer a section to flip
09:00:18 <quicksilver> (`isInfixOf` "foobar")  is nicer than (flip isInfixOf "foobar")
09:00:19 <quicksilver> IMO>
09:00:23 <mux> yeah, I find it's prettier and more intuitive too
09:00:44 <Deewiant> I think "foo = flip bar" is nicer than "foo = `bar`"
09:01:00 <Cin> @hoogle a -> [a -> b] -> [b]
09:01:01 <lambdabot> No matches, try a more general search
09:01:06 <jedbrown> If only we could section (,) ...
09:01:10 <matthew-_> backticks remind me of deprecated bash syntax
09:01:21 <quicksilver> Deewiant: as well as being correct :)
09:01:44 <Cin> is there a function like this? \e fs = map (\f -> f e) fs
09:01:49 <Deewiant> quicksilver: I wasn't sure if foo = `bar` would work to be honest. :-P
09:02:00 <Deewiant> @pl \e fs = map (\f -> f e) fs
09:02:00 <lambdabot> (line 1, column 7):
09:02:00 <lambdabot> unexpected "="
09:02:00 <lambdabot> expecting pattern or "->"
09:02:07 <Deewiant> @pl \e fs -> map (\f -> f e) fs
09:02:07 <lambdabot> map . flip id
09:02:17 <quicksilver> Cin: map ($e)
09:02:27 <Cin> quicksilver: what does that mean?
09:02:31 <Deewiant> map . `id` ? :-P
09:02:37 <quicksilver> ($e) means 'apply to e'
09:02:53 <quicksilver> > ($4) sqrt
09:02:54 <lambdabot>  2.0
09:03:05 <Cin> ahh, i see
09:03:12 <quicksilver> > map ($4) [sqrt,(+1),(*2)]
09:03:12 <lambdabot>  [2.0,5.0,8.0]
09:03:33 <quicksilver> Cin: that's actually a faq
09:03:40 <quicksilver> Cin: people ask this almost once a week
09:03:40 <Cin> thanks
09:03:42 <quicksilver> I wonder why
09:03:48 <FunctorSalad> hmm, what could be the reason build complains that some package is hidden, when it isn't?
09:03:48 <Cin> quicksilver: heh.
09:03:56 <quicksilver> just seems to be a popular thought once you get using maps
09:03:59 <quicksilver> FunctorSalad: it is...
09:04:02 <quicksilver> FunctorSalad: (by the .cabal)
09:04:18 <quicksilver> FunctorSalad: add teh package to the .cabal depends.
09:04:18 <desegnis> FunctorSalad: cabal will hide any package not mentioned in the .cabal file
09:04:26 <quicksilver> that's how it "keeps you honest"
09:04:35 <FunctorSalad> ok, thanks :)
09:04:39 <quicksilver> it only lets you compile against the packages you declare
09:04:43 <quicksilver> dependencies on
09:04:55 <Cin> quicksilver: well, my code is: anyEmpty = any (=="") $ map ($client) [clientNick,clientHost,clientUser]
09:05:13 <FunctorSalad> why didn't the author notice it though? (not complaining, just wondering)
09:05:28 <Cin> quicksilver: better ways to do it?
09:05:35 <MyCatVerbs> quicksilver: perhaps I have a misapprehension here about the meaning of "blocking" used in the docs?
09:05:39 <FunctorSalad> I mean, why would it compile properly for him
09:06:03 <desegnis> FunctorSalad: Versioning subtleties with new ghc?
09:06:05 <Deewiant> Cin: '(=="")' could be replaced by 'null'
09:06:15 <Deewiant> > null []
09:06:17 <lambdabot>  True
09:06:20 <Cin> Deewiant: ah thanks :D
09:06:32 <desegnis> FunctorSalad, some things have been moved into seperate libraries
09:06:36 * Cin systematically replaces lots of occurances in his code...
09:06:42 <Deewiant> :-)
09:06:54 <Pastorn__> @pl \a b c d -> ( (a,b) , (c,d) )
09:06:54 <MyCatVerbs> quicksilver: is there a distinction between what I'd consider (in C) a blocking call (say, calling raw read(2) or accept(2) or gethostbyname(3)) and what's considered a "blocking call" in GHC's threading implementation? (The details of whose guts I know very little about.)#
09:06:54 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
09:06:57 <Pastorn__> yay
09:07:03 <desegnis> FunctorSalad, like collections, process, and others
09:07:29 <quicksilver> MyCatVerbs: ghc doesn't try to be clever and detect if calls are going to block.
09:07:36 <quicksilver> MyCatVerbs: the issue is simply this:
09:07:38 <FunctorSalad> desegnis: I see
09:07:43 <quicksilver> the RTS has 'm' real OS-level threads
09:07:43 <visof> hello
09:07:46 <quicksilver> and 'n' haskell threads
09:07:50 <quicksilver> typically n > m
09:07:50 <FunctorSalad> (FWIW it's "array" and "random")
09:08:04 <quicksilver> if m is 1, then a single blocking OS call blocks your whole haskell world.
09:08:08 <desegnis> yea
09:08:12 <quicksilver> if you don't compile with -threaded, m is always 1
09:08:14 <visof> can anyone help me with an exercise in Yaht ?
09:08:23 <quicksilver> if you don't do RTS -N2, m is always 1
09:08:29 <visof> can i put the problem here?
09:08:35 <quicksilver> if m is in fact > 1, then you don't have to worry about a blocking OS call :)
09:08:37 <Cin> hpaste: url
09:08:38 <hpaste> Haskell paste bin: http://hpaste.org/
09:08:50 <FunctorSalad> @karma+ quicksilver
09:08:50 <lambdabot> quicksilver's karma raised to 11.
09:08:50 <quicksilver> but if two different threads block at once, and you only have m==2
09:08:53 <FunctorSalad> @karma+ desegnis
09:08:53 <lambdabot> desegnis's karma raised to 3.
09:08:56 <quicksilver> you're back in the same situation
09:08:58 <FunctorSalad> compiles now :)
09:09:07 <quicksilver> GHC side-steps all of this for standard IO
09:09:17 <quicksilver> by implementing its own non-blocking IO subsystem
09:09:26 <quicksilver> which blocks haskell threads but never real threads
09:09:32 <quicksilver> MyCatVerbs: does that clear it up?
09:09:33 <desegnis> hey, I'm already quarter a quicksilver
09:09:43 <FunctorSalad> I mean, I get a different error ;)
09:09:54 <quicksilver> I had a little more karma before the great karma wipe
09:09:58 <quicksilver> but I'm not really counting :)
09:09:58 <FunctorSalad> (kinda like progressing in adventure games)
09:09:59 <hpaste>  visof pasted "(no title)" at http://hpaste.org/5325
09:10:19 <quicksilver> visof: I can read yaht too :)
09:10:22 <MyCatVerbs> quicksilver: actually, no.
09:10:30 <quicksilver> visof: I could also answer the question, but presumably you wouldn't gain much from that
09:10:33 <desegnis> FunctorSalad, ;)
09:10:34 <quicksilver> visof: how far did you get?
09:10:38 <quicksilver> where did you get stuck?
09:10:49 <quicksilver> MyCatVerbs: ok, which bit isn't clar?
09:10:58 <MyCatVerbs> quicksilver: because I'm sitting here with one thread calling accept(2) from a forkIO'd thread, and others still doing various stuff with process control. Compiled with -threaded, yes, but run *without* -Nfoo.
09:11:44 <quicksilver> MyCatVerbs: did you FFI accept yourself?
09:12:22 <MyCatVerbs> quicksilver: no, called accept in System.Network. Also am using waitForProcess in System.Process.
09:12:42 <MyCatVerbs> quicksilver: explicitly running with +RTS -N1 -RTS *also* fails to make my program break.
09:13:09 <quicksilver> MyCatVerbs: but accept in System.Network isn't accept(2) :)
09:13:11 <visof> quicksilver   map  x   "aBCde"   if  x  upper then False else True
09:13:19 <quicksilver> MyCatVerbs: you lied to me ;)
09:13:31 <visof> quicksilver that's my idea
09:13:36 <quicksilver> MyCatVerbs: "GHC side-steps all of this for standard IO by implementing its own non-blocking IO subsystem"
09:13:38 <Deewiant> > map isUpper "aBCde"
09:13:38 <lambdabot>  [False,True,True,False,False]
09:13:40 <MyCatVerbs> quicksilver: guh. And waitForProcess in System.Process isn't wait4(2)?
09:13:41 <quicksilver> visof: that's very very close
09:13:41 <visof> is it wrong?
09:13:46 <MyCatVerbs> quicksilver: whaaaaat.
09:13:49 <quicksilver> visof: you just need syntax
09:14:01 <MyCatVerbs> quicksilver: I thought that only applied to the basic IO primitives.
09:14:07 <quicksilver> > map (if isUpper x then False else True) "aBCde"
09:14:09 <lambdabot>   Not in scope: `x'
09:14:13 <MyCatVerbs> quicksilver: plus, wait4?
09:14:15 <quicksilver> > map (\x -> if isUpper x then False else True) "aBCde"
09:14:15 <lambdabot>  [True,False,False,True,True]
09:14:21 <jedbrown> quicksilver: The documentation says that you must compile with -threaded for it to work.  Besides, it must actually call accept(2) underneath?
09:14:29 <Deewiant> > map isLower "aBCde"
09:14:29 <lambdabot>  [True,False,False,True,True]
09:14:30 <quicksilver> visof: that's the most literal transaction if what you wrote
09:14:30 <BMeph> FunctorSalad: You are in a room of twisty little monads, all alike. There is a lambda here.
09:14:36 <quicksilver> jedbrown: it calls select()
09:15:02 <FunctorSalad> :)
09:15:39 <quicksilver> MyCatVerbs: most of the standard IO stuff, if it could sensibly be made non-blocking, is non-blocking.
09:15:51 <MyCatVerbs> quicksilver: and waitForProcess is implemented similarly, by having the Haskell thread that calls it yield and then waking it up again later on catching SIGCHILD?
09:15:55 <visof> @src isLower
09:15:55 <quicksilver> MyCatVerbs: so you can run with a single OS thread but lots of lightweight haskell threads
09:15:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:16:05 <quicksilver> MyCatVerbs: I'm actually not sure about waitForProcess.
09:16:13 <quicksilver> MyCatVerbs: but I am sure about accept :)
09:16:22 <quicksilver> I would guess that you're right though.
09:16:41 <quicksilver> jedbrown: yes, you need -threaded
09:16:44 <MyCatVerbs> quicksilver: damn. Didn't realise people had actually gone and did all the hard work for this.
09:16:48 <quicksilver> jedbrown: without -threaded tere are no threads at all.
09:17:07 <MyCatVerbs> Indeed, without -threaded my program promptly locks up. ^_^
09:17:07 <quicksilver> hmm that's not true.
09:17:08 * quicksilver ponders
09:17:24 <quicksilver> damn, I've forgotten the issue here.
09:17:27 <jedbrown> quicksilver: huh?  You can have lots of threads, just one executing at a time.
09:17:34 <quicksilver> JaffaCake: help ;)
09:17:41 <MyCatVerbs> quicksilver: methinks without -threaded it doesn't use the preemptive scheduler, and doesn't ever spawn multiple OS threads.
09:18:01 <quicksilver> that's true
09:18:14 <quicksilver> but you don't need multiple OS threads to do a non-blocking accept()
09:18:20 <quicksilver> you just need to use select()...
09:19:45 <jedbrown> quicksilver: Browsing the source, it looks like it really is calling accept.
09:20:39 <quicksilver> jedbrown: but on an O_NONBLOCK socket, I would think?
09:22:04 <quicksilver> JaffaCake: I've confused myself about the boundaries between -threaded and normal non-blocking IO
09:22:25 <quicksilver> JaffaCake: I thought normal Handle + Socket stuff didn't require -threaded because the RTS handles it in a nonblocking way?
09:22:45 <dcoutts> quicksilver: that is correct, because it puts all file handles into non-blocking mode
09:22:56 <quicksilver> right.
09:23:14 <quicksilver> you only need -threaded if you actually want more than one real OS thread, right?
09:23:38 <dcoutts> if you want smp parallelism or non-blocking foreign calls
09:24:17 <quicksilver> right
09:24:39 <quicksilver> MyCatVerbs: your code calls not only accept but also waitForProcess?
09:24:41 <jedbrown> Is it correct that the -N parameter only controlls how many threads the runtime will schedule to run, not how many it actually has?
09:25:00 <MyCatVerbs> quicksilver: indeed. In seperate threads, no less.
09:25:08 <quicksilver> MyCatVerbs: OK, I think I understand.
09:25:16 <quicksilver> MyCatVerbs: if it was just accept, you wouldn't need -threaded
09:25:22 <MyCatVerbs> quicksilver: and also does network IO on an arbitrary quantity of (already accept()ed) network sockets.
09:25:25 <quicksilver> MyCatVerbs: ghc implements accept as nonlocking.
09:25:37 <quicksilver> but waitForProcess is implemented as blocking
09:25:37 <MyCatVerbs> quicksilver: oh cool, I didn't know that.
09:25:43 <quicksilver> so you *do* need -threaded for that
09:25:50 <quicksilver> if you want other threads to continue to make progress.
09:25:53 <quicksilver> I think that's right.
09:26:07 <jedbrown> quicksilver: The docs for accept say it will block.
09:26:27 <jedbrown> quicksilver: (unless the socket is non-blocking)
09:26:44 <quicksilver> jedbrown: you mean the OS's manual page for it?
09:26:50 <MyCatVerbs> Other thing. The function that calls waitForProcess, rather than being forkOS'd off, I just call it at the end of main (it never terminates under normal conditions, y'see).
09:26:59 <jedbrown> quicksilver: No, Network.Socket
09:27:12 <MyCatVerbs> (That is, it gets run at the end of main after all other threads have been forkIO'd off, config files read, etc.)
09:27:38 <MyCatVerbs> The main thread is always bound though, the docs say.
09:28:03 <ehird> I wonder, is there any Haskell art? Or haskell poetry? ;)
09:28:08 <quicksilver> jedbrown: I don't see that, in the docs I'm reading
09:28:11 <MyCatVerbs> I presume if I switched things around so that some completely different thread was run at the end of main, and the process handler was forkIO'd, things would stop working?
09:28:12 <ehird> (Note: must consist of entirely valid haskell code only.)
09:28:38 <jedbrown> quicksilver: I'm reading Network/Socket.hs
09:28:50 <MyCatVerbs> ehird: abusing CPS and the ability to define infix operators, I could see that happening.
09:29:13 <quicksilver> jedbrown: that's just a copy-paste of the libc docs
09:29:15 <quicksilver> jedbrown: or similar
09:29:19 <quicksilver> jedbrown: pasted there for reference
09:29:29 <quicksilver> jedbrown: in the GHC case, the socket is always marked as non-blocking.
09:29:33 <quicksilver> cos that's what GHC does.
09:29:37 <quicksilver> (the RTS, I mean)
09:30:32 <jedbrown> quicksilver: You're saying that you will never get a socket placed in blocking mode?
09:30:51 <quicksilver> jedbrown: not if you use the Network library which comes with ghc, no.
09:31:18 <quicksilver> the ghc RTS / ghc IO library co-operate to ensure all network + file IO is non-blocking
09:31:33 <quicksilver> of course, if you used the lower level API to override it, that's your lookout
09:31:49 <jedbrown> quicksilver: Because once you call accept, the RTS isn't involved.  It just makes the foreign call.
09:31:57 <jedbrown> quicksilver: Then why do you need -threaded?
09:31:58 <quicksilver> right.
09:32:01 <quicksilver> jedbrown: you don't.
09:32:08 <quicksilver> jedbrown: you need -threaded for waitForProcess :)
09:32:10 <quicksilver> but not for accept.
09:32:17 <ac> It would be cool if vim had a "move to inter-word boundary", meaning the next differently cased letter, under score, digit, or end of word
09:32:39 <ehird> MyCatVerbs: Doesn't have to be readable in English.
09:32:49 <osfameron> ac: you cuold probably hack one.  But yes, I've wanted that
09:32:59 <visof> quicksilver can you help me in the second example
09:33:00 <visof> ?
09:33:10 <osfameron> ac: also for cases when you want keywordchars to include some delimeter for the case of keyword matching, but not for movement
09:33:16 * ddarius usually uses f<letter>
09:33:20 <osfameron> (like package delimiters etc.)
09:33:25 <MyCatVerbs> ac: add one to yi. ;)
09:33:38 <osfameron> is yi usable under vi-mode yet?
09:33:43 <quicksilver> visof: which?
09:33:51 * ac is a ways from hacking on yi
09:34:16 <visof> i tried with it
09:34:17 <ehird> i want to write a text editor in haskell but i feel like i shouldn't because it's all yi these days :P
09:34:23 <visof> but i failed
09:34:31 <ac> ehird: yi isn't stopping you
09:34:49 <ehird> ac: yeah, but nobody will pay attention to my widdle ol' editor! ;)
09:35:01 <ddarius> No one's paying attention to yi
09:35:10 <quicksilver> text editor is a good project because
09:35:13 <quicksilver> writing a text editor is easy
09:35:17 <quicksilver> but writing a good one is hard
09:35:18 <quicksilver> :)
09:35:23 <byorgey> ehird: well, why do you want to write a text editor?
09:35:23 <quicksilver> this puts it in the zone for profitable hackery
09:35:37 <quicksilver> since it's pretty easy to get something basically workable
09:35:47 <byorgey> 1. write text editor  2. make it Totally Sweet  3. profit
09:35:56 <ac> If you want to write a program so it becomes popular, you better think long and hard, or just accept that it's up to chance -- a very small chance
09:36:12 <ehird> byorgey: because they infuriate me
09:36:23 <ehird> :P
09:36:23 <ehird> ac: never said anything about being popular
09:36:23 <byorgey> ehird: well, then do it!
09:36:23 <ac> ehird: that's an excellent reason :)
09:36:34 <byorgey> ehird: who cares whether people pay attention to it or not?
09:36:48 <ehird> actually, i'd better check out yi first. on the small chance that it doesn't completely suck :P
09:36:55 <ehird> but the odds are not in favour!
09:37:11 <idnar> you could also just fix yi ;)
09:37:13 <byorgey> ehird: I've been playing around with yi recently.  I think it has a lot of potential.
09:37:18 <quicksilver> > filter isLower "abCDe"
09:37:22 <lambdabot>  "abe"
09:37:24 * ac is actually quite happy with vim, at least as happy as I can be with a text editor
09:37:27 <quicksilver> visof: does that help?
09:37:27 <ehird> idnar: but that's no fun ;)
09:37:38 <ac> though there's a fair amount of room for improvement
09:37:42 <quicksilver> visof: exampel I just put through lambdaot
09:37:50 <visof> ya
09:37:52 * osfameron thinks about looking at yi again
09:37:55 <visof> then i use length
09:37:59 * osfameron hopes it builds more easily these days...
09:38:01 <visof> right?
09:38:05 <quicksilver> yes
09:38:10 <quicksilver> exactly
09:38:11 <visof> ok
09:38:23 <glen_quagmire> :t length
09:38:23 <lambdabot> forall a. [a] -> Int
09:38:32 <byorgey> osfameron: it doesn't, but (a) someone posted a good explanation somewhere (I'll find you a link if you want) and (b) I think I could help =)
09:38:57 <osfameron> byorgey: cool.  I think I've seen the link actually (in passing)
09:39:04 <visof> hi byorgey
09:39:10 <ddarius> @google site:nobugs.org yi
09:39:11 <lambdabot> http://www.nobugs.org/developer/yi/
09:39:11 <lambdabot> Title: Getting started with Yi, the haskell editor
09:39:16 <osfameron> byorgey: I'll ping you about it when I get CFT sometime
09:39:18 <byorgey> osfameron: yeah, that's the one
09:39:19 <quicksilver> > foldr ($) 0 . map (\x -> if isLower x then (+1) else (+0)) $ "abCDe"
09:39:20 <lambdabot>  3
09:39:29 <quicksilver> visof: there is a generalisation of your approach
09:39:34 <byorgey> osfameron: cool, feel free
09:39:37 <byorgey> hi visof
09:39:41 <quicksilver> visof: wich you might consider an interesting alternative to the length . filter one
09:39:47 <quicksilver> visof: you produced a list of functions
09:39:57 <quicksilver> visof: I used 'foldr ($) 0' to apply them all to 0
09:40:06 <quicksilver> visof: so 0 +1 +1 +1 is 3 !
09:40:08 <ehird> libraries/X11/package.conf.in disappeared..
09:40:12 <visof> ya
09:40:15 <ehird> macports tries to patch it.
09:40:19 <ehird> is it still existant, just renamed?
09:40:22 <ehird> or is it gonneified
09:40:29 <ehird> [in ghc src]
09:40:41 <visof> quicksilver thank you very much
09:41:51 <Saizan> is ther an haskell-mode for yi? (beside just syntax highlighting)
09:42:45 <quicksilver> there is
09:42:49 <quicksilver> but I don't know how much it suports
09:45:53 <shag> i just started to love quickcheck. but it really really needs some kind of hunit integration
09:46:05 <dons> interesting view into our neighbour's world, http://redromelogic.com/blog/display?id=25 (#lisp in ten easy pieces)
09:46:05 <lambdabot> Title: Red Rome Logic: display
09:46:16 <RayNbow> anyone here familiar with first order (predicate) logic? I'm looking for some English words
09:46:33 <RayNbow> A |= B   <=>   A |- B
09:46:40 <Saizan> "predicative"
09:47:07 <ehird> nobody? :|
09:47:24 <RayNbow> in Dutch, this equivalence relation is called "Correctheid en volledigheid", but I have no idea what it is in English :p
09:47:43 <dons> ehird: perhaps ask on the list?
09:47:51 <Botje> RayNbow: sound and complete.
09:48:00 <RayNbow> Botje: ah thx :)
09:48:51 <ehird> dons: #lisp isn't exactly a happy fun time place
09:48:54 <ehird> dons: perhaps
09:49:00 <ehird> i'll find(1) the tree
09:49:57 <matveev> hello, what does one need to implement a function plus :: (Num a, Num b, Num c) => a -> b -> c that would work for all abc by lifting them approprietely?
09:49:58 <ehird> indeed x11 is gone
09:50:20 <ehird> matveev: i don't think that's impossibel without writing a huge converter
09:50:25 <ehird> *possible
09:50:32 <ehird> i am probably wrong.
09:50:50 <matthew-_> (+) is surely rather magic
09:51:00 <ehird> matthew-_: unfortunately.
09:51:03 <matthew-_> so you're going to have to convert to a common type, I would think
09:51:14 <matveev> I seem to undestand how it works for *constants* 1 + 2.5 and  2 + x. Is it possible for *variables*?
09:51:16 <matthew-_> unless you're going to write out every possible case
09:51:33 <ehird> matthew-_: well, not EVERY case
09:51:40 <ehird> x + y = y + x -- base case :P
09:51:46 <matthew-_> ehird: useful ;P
09:51:54 <matthew-_> that halves it then!
09:51:55 <ddarius> RayNbow: It probably has a name.  Usually that's just called soundness and completeness.
09:51:56 <ehird> Just make sure to add all other non-mirrored Num permutations! ;)
09:52:14 <matthew-_> oh, and x + 0 = x
09:52:20 <matthew-_> that's a useful base case!
09:52:24 <ehird> ddarius: we need a property 'cuddliness'
09:52:31 <MyCatVerbs> osfameron: sort-of, I think.
09:52:31 <ehird> so we can go up to people writing bad code and go:
09:52:43 <ehird> 'YOUR CODE IS NOT CUDDLY. ADD CUDLINESS. YOU LIKE CUDDLES, DON'T YOU?????'
09:52:53 <ehird> that should ensure all haskell code is good.
09:52:54 <MyCatVerbs> ehird: lightbulb!
09:53:12 <matveev> I could live with most cases like that: plus  a b = error "not yest implemented"
09:53:23 <ehird> matveev: but why.
09:53:24 <MyCatVerbs> ehird: you've heard the SPJ quote that Haskell's biggest mistake was calling monads "monads" instead of "warm, fuzzy things", right?
09:53:43 <ehird> MyCatVerbs: haha, no. that's great :)
09:53:53 <jedbrown> quicksilver: I'm reading this: http://www.haskell.org/~simonmar/papers/conc-ffi.pdf
09:53:54 <ehird> bind => hug
09:53:57 <MyCatVerbs> ehird: 'You code is neither warm nor fuzzy! Rewrite your code in Haskell and in the process it will become infused with warm and fuzzy things!'
09:54:00 <ehird> return => cuddle
09:54:08 <matthew-_> matveev: also, don't forget that floats don't actually implement maths
09:54:13 <dons> i'm not sure it was a mistake. its good brand awarenesssssss
09:54:15 <MyCatVerbs> fail => detach
09:54:15 <dolio> So, "plus :: IntPtr -> Complex Double -> Word8" should be an option?
09:54:31 <ehird> MyCatVerbs: NO! fail => spiky
09:54:35 <jedbrown> quicksilver: And in particular, the quote `variable number of so-called worker OS threads'
09:54:38 <MyCatVerbs> ehird: hah, I like it.
09:54:41 <dons> ?users
09:54:41 <lambdabot> Maximum users seen in #haskell: 463, currently: 434 (93.7%), active: 24 (5.5%)
09:54:59 <MyCatVerbs> dons: well, it plays pretty well into "avoid success at all costs" ;)
09:55:01 <ToRA> @type  let (!+) x y = fromInteger (fromIntegral x + fromIntegral y) in (!+)
09:55:02 <lambdabot> forall a a1 a2. (Integral a, Integral a1, Num a2) => a -> a1 -> a2
09:55:19 <jedbrown> quicksilver: So your earlier statement about -Nm meaning there were m OS threads and if you made m blocking foreign calls, then then all of Haskell would block is wrong.
09:55:28 <ehird> MyCatVerbs: mzero = emptybox
09:55:30 <ehird> mplus = addkitten
09:55:45 <jedbrown> quicksilver: Rather, the m refers to the number of threads that the runtime will schedule simultaneously.
09:56:11 <jedbrown> quicksilver: But with -threaded -N1 you can still have a large number of threads blocked on foreign calls.
09:56:27 <matthew-_> msum = firstKittenToEscapeFromTheBox
09:57:22 <ehird> noo, escaping isn't cuddly
09:57:33 <ehird> msum = cuddliestKittenButTheOthersAreStillCuddly
09:57:47 <matthew-_> ehird: surely, that'd require Ord Kitten
09:58:16 <ehird> matthew-_: noo! it is a fuzzy algorithm
09:58:32 <zeno> i want to ditch eclipse, but there is one feature it has i really like: when you save it tries to compile it and if there are any errors it highlights them.  any other editors do that?
09:58:36 <matthew-_> not a fury one then ;)
09:59:15 <matthew-_> zeno: I believe you can set up emacs and ghc to do things like that, though personally I've not bothered
09:59:18 <Saizan> zeno: emacs+haskell-mode that's just C-c C-l
09:59:46 <zeno> thx
10:00:12 <Saizan> well, it loads it in ghci, showing it in a buffer
10:00:55 <matthew-_> Saizan: it fully saves it too - not just writing out via tmp or anything?
10:01:28 <Saizan> matthew-_: no, it saves
10:02:19 <matthew-_> Saizan: what about if you want it to just reload the current ghci session. I.e. not necessarily reload the currently edited module?
10:02:58 <Saizan> matthew-_: well you switch to the ghci buffer and use it normally
10:03:07 <matthew-_> oh right
10:03:27 <matthew-_> a normal C-x C-s doesn't trigger :r ?
10:03:34 <Saizan> no
10:04:43 <Saizan> and you get other things like C-c C-t on an identifier will ask the type to ghci and report it in the minibuffet
10:04:44 <matveev> dolio: that looks weired, but OTOH there was a reason for all of them to belong to (Num a), if I also had an idea for a generic "toNumber :: Num a -> Number " why shouldnt your example be possible?
10:05:02 <matveev> dolio: that looks weired, but OTOH there was a reason for all of them to belong to (Num a), if I also had an idea for a generic "toNumber :: Num a -> Number " why shouldnt your example be possible?
10:05:44 <matthew-_> Saizan: hmm. maybe I'll actually have to look up the documentation or something...
10:07:21 <matthew-_> matveev: that should really be a member of the Num type class.
10:07:37 <matthew-_> matveev: and yes, it could work, but you'll have problems
10:07:43 <visof> map (\x ->  (length . filter) Char.isLower x ) "Abdsd"
10:07:48 <visof> this is wrong
10:07:50 <visof> why?
10:08:52 <Lemmih> visof: map (length . filter Char.isLower) "Abdsd"
10:09:17 <olsner> > map (length . filter Char.isLower) "Abdsd"
10:09:18 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
10:09:31 <olsner> > map (length . filter Char.isLower) ["Abdsd"]
10:09:32 <lambdabot>  [4]
10:09:39 <jedbrown> visof: What do you wan't to do?
10:09:46 <tibbe> a question regarding the package version policy: Am I supposed to release my 0.1 version of my new library as 0.1 or 0.1.0 or 0.1.0.0 etc?
10:10:03 <matthew-_> there's policy?
10:10:06 <ehird> @djinn (a -> b) -> [a] -> [b]
10:10:06 <lambdabot> -- f cannot be realized.
10:10:12 <ehird> foo, yes it can ;)
10:10:13 <matthew-_> I just use today's date
10:10:15 <visof> jedbrown just example
10:10:16 <radix> is there a difference between [Char] and String? I look at :t and see String, but I pass it what are apparently [Char]s
10:10:31 <ehird> it should be changed to
10:10:35 <ehird> 'My feeble brain cannot realise f.'
10:10:41 <ehird> radix: type String = [Char]
10:10:53 <matthew-_> I'd just use 2008.1.29. But I'm not aware of any "policy"
10:10:54 <idnar> :t map
10:10:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:10:57 <radix> ehird: cool. I was just confused because
10:10:59 <radix> :t "foo"
10:10:59 <lambdabot> [Char]
10:11:06 <ehird> yes
10:11:16 <chadz> hey -- i'm once again boned by cabal and my goofy lib custom lib paths. I've set LD_LIBRARY_PATH, and LIBRARY_PATH, yet zlib still can't find gmp.h
10:11:18 <ehird> because ghc doesn't think about aliases or synonyms or blargh
10:11:21 <ehird> it just tells you what the type is
10:11:26 <radix> ok :)
10:11:31 <idnar> :t "foo" :: String
10:11:31 <lambdabot> String
10:11:33 <ehird> String is just defined to be [Char], because it's easier to look at in explicit types
10:11:35 <idnar> hee
10:11:59 <ehird> idnar: (a -> b) -> [a] -> [b] is a perfectly valid type for map though.
10:12:00 <jedbrown> visof: What would you expect to see?  You're example didn't make sense in multiple ways.
10:12:06 <ehird> @djinn forall a b. (a -> b) -> [a] -> [b]
10:12:06 <lambdabot> -- f cannot be realized.
10:12:10 <ehird> djinn only supports h98.
10:12:27 <idnar> the forall is implied anyway
10:12:37 <desegnis> ehird: djinn does not do lists.
10:12:41 <idnar> @djinn (a -> b) -> a -> b
10:12:41 <lambdabot> f a = a
10:12:45 <ehird> ah
10:12:55 <idnar> the lists are the problem, not the type variables
10:13:01 <ehird> well, i'll just have to use lambda-calculus-cons-lists then
10:13:01 <ehird> :D
10:13:14 <chadz> any cabal gurus floating around?
10:13:20 <ehird> @type \x y z. z x y
10:13:20 <lambdabot> parse error on input `.'
10:13:24 <ehird> @type \x y z -> z x y
10:13:24 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t2) -> t2
10:13:36 <ehird> @type \x y -> x
10:13:36 <lambdabot> forall t t1. t -> t1 -> t
10:13:38 <ehird> @type \x y -> y
10:13:39 <lambdabot> forall t t1. t -> t1 -> t1
10:13:42 <ehird> alrighty then!
10:14:01 <ehird> hmm
10:14:04 <idnar> yoinks
10:14:16 <ehird> t -> t -> (t -> t -> t) -> t
10:14:18 <sclv> chadz: the general policy is to just ask. somebody will probably have an answer. and if that fails, paste.
10:14:20 <ehird> @djinn t -> t -> (t -> t -> t) -> t
10:14:23 <lambdabot> f a b c = c b a
10:14:25 <radix> so, I watched SLPJ's intro to haskell video, and he mentioned how haskell can do dispatching based on *return* value (the specific example was fromInteger) -- out of curiosity, is there a way for me to add an implementation of fromInteger for, say, Integer -> String?
10:14:26 <chadz> sclv: i've already asked.
10:14:28 <ehird> tee hee :)
10:15:07 <ehird> @djinn (t -> t -> (t -> t -> t) -> t) -> (t -> t1) -> (t1 -> t1 -> (t1 -> t1 -> t1) -> t1)
10:15:07 <lambdabot> f _ _ a b c = c b a
10:15:08 <dons> :t fromInteger
10:15:10 <lambdabot> forall a. (Num a) => Integer -> a
10:15:18 <chadz> :t read
10:15:19 <lambdabot> forall a. (Read a) => String -> a
10:15:22 <dons> radix: so you could add a Num String instance
10:15:23 <ehird> hmm, damn
10:15:25 <ehird> silly me
10:15:25 <dons> it would be weird though
10:15:34 <sclv> <sclv> "and if that fails, paste."
10:15:45 <ehird> 'tis impossible to get a map out of djinn
10:15:45 <ehird> ;)
10:15:58 <radix> dons: yeah, I do realize it would be weird, it smacks of perl and PHP's implicit casting all of the place, I was just wondering about it because it seems a very fundamental change
10:16:09 <radix> dons: I mean, it's fundamental compared to most languages :)
10:16:15 <tibbe> matthew-_: http://www.haskell.org/haskellwiki/Package_versioning_policy
10:16:15 <lambdabot> Title: Package versioning policy - HaskellWiki
10:16:19 <radix> dons: and it's impressive that haskell allows that
10:16:43 <idnar> radix: the fact that you can always do type inference helps a lot, I think
10:16:45 <ehird> @let data X = X
10:16:45 <lambdabot> Invalid declaration
10:16:47 <ehird> damnit
10:16:48 <ehird> :)
10:17:54 <idnar> radix: eg. I think the main difficulty with doing that in, say, C++, is that you can't tell what type the result is meant to be used as without an explicit declaration, because of all the implicit casting that's possible
10:18:00 <chadz> what are the default methods for defining custom library directories for building under cabal-install
10:18:15 <idnar> although perhaps it's more involved that than
10:19:30 <ehird> i'm on the haskell diagram!
10:19:31 <ehird> sweet ;)
10:20:10 <ehird> (#haskell, that is)
10:20:34 <byorgey> ehird: not only are you on it, you're something of a hub there =)
10:20:55 <ehird> indeed
10:21:31 <matveev> again me: does this get parsed by a skilled eye: class (Num a, Num b) => Num (Plus a b) where ... I mean there must be formal haskell way to address the problem
10:21:52 <dons> if a and b support Num, then Plus a b is a Num too
10:21:58 <ehird> matveev: The problem is in what you're trying to do, I think
10:22:19 <matveev> its that I'd like (Plus a b) also span the standard numbers somehow
10:22:41 <sclv> chadz: http://www.haskell.org/cabal/release/latest/doc/users-guide/x30.html#buildinfo
10:22:41 <MyCatVerbs> ehird: diagram?
10:22:41 <lambdabot> http://tinyurl.com/2hxddg
10:22:52 <byorgey> MyCatVerbs: check the topic =)
10:23:08 <matveev> Plus Int Int === Int
10:23:50 <MyCatVerbs> byorgey: how handy, apparently I'm married to quicksilver.
10:24:01 <byorgey> hehe
10:24:01 <ehird> MyCatVerbs: but i'm fighting for you
10:24:21 <ehird> oh
10:24:22 <ehird> it changed
10:24:22 <MyCatVerbs> Oh hey, it's updated in real time. Niiice.
10:24:23 <ehird> :|
10:24:24 <ehird> just now
10:24:25 <chadz> ahh, it's not the library path which it's not connecting to. it wants gmp.h, not lgmp. how does one specify include paths for cabal-install?
10:24:38 <ehird> MyCatVerbs: Nope, but it just got cron'd
10:24:49 <ehird> I'm rather less of a hub now. :P
10:24:55 <MyCatVerbs> ehird: ahhh, I see. Wonder how often?
10:24:57 <sclv> matveev: You might need a fundep?
10:25:06 <ehird> MyCatVerbs: Presumably, every day/half day
10:25:16 <ehird> it wouldn't be different enough to warrant more
10:25:25 <MyCatVerbs> ehird: I'mmm... not so sure about that.
10:25:30 <byorgey> no, it updates in real time.
10:25:32 <MyCatVerbs> ehird: it changed again the last time I refreshed it.
10:25:38 <MyCatVerbs> byorgey: dankeschÃ¶n.
10:25:39 <sclv> but for each a you can have one and only one b...
10:26:09 <MyCatVerbs> That graph has a worryingly low average outdegree. Apparently we're all forming horrid little cliques. ;)
10:26:28 <ehird> hm indeed
10:26:33 <ehird> it did just update again
10:26:45 <ehird> heyyy
10:26:48 <ehird> i'm connected to EVERYONE!
10:27:10 <sclv> it seems to only make a link when foax address one another by name? guess there's no real way to avoid that.
10:27:12 <byorgey> well, it only includes stuff from the last X hours.
10:27:15 <chadz> i'm still more interested in my question :)
10:27:26 <byorgey> if it included more the graph topology would probably be a lot different.
10:27:32 <ehird> sclv: You're all at the edge :(
10:27:43 <ehird> sclv: I'm going to mention you a few times because I feel sorry for you, not being near the center and all.
10:27:54 <ehird> sclv sclv sclvs sclving sclvs.
10:27:57 <ehird> sclv.
10:28:02 <sclv> awww.... #haskell really is the niceset
10:28:04 <MyCatVerbs> sclv: at least the graph isn't bipartite now.
10:28:11 <ehird> hmm
10:28:15 <ehird> what what what what what
10:28:25 <ehird> hah! that worked
10:28:34 <matveev> sclv: I though of adding numbers with "taylor series" without needing to convert all "constants" to new sereis representation. And still stay in Num class. Do I need fundep for that?
10:28:44 <dcoutts> hia byorgey, was just talking about you :-)
10:29:00 <byorgey> hiya dcoutts, I was just hacking on Cabal =)
10:29:17 * dcoutts is very pleased with the number of new Cabal hackers in recent weeks
10:29:26 <chadz> byorgey: then you should be able to answer my cabal-install question? :)
10:29:35 <byorgey> dcoutts: to whom were you talking about me?
10:29:36 <ehird> dcoutts_ saizan dolio idnar dcoutts.
10:29:42 <ehird> there
10:29:45 <idnar> heh
10:30:03 <byorgey> chadz: heh, nice try =)
10:30:12 <sclv> matveev: if you have a multi-paramater typeclass you generally need fundeps I think? the compiler should tell you if you do though...
10:30:14 <MyCatVerbs> You're just hankering for hubby status.
10:30:14 <byorgey> chadz: I read your question but I have no idea of the answer. =)
10:30:25 <chadz> byorgey: but it's so simple!
10:30:49 <dcoutts> byorgey: to kolmodin, he and I are gentoo developers, maintaining the haskell packages
10:31:02 <dcoutts> chadz: what question?
10:31:16 <MyCatVerbs> sclv: depends. If you have only functions that all mention *all* the types in the typeclass in their signatures, it's fine... assuming those types are also distinct, I think? Argh. Elsewise, multi param classes are a royal pain.
10:31:25 <byorgey> chadz: ok, fine, I'll answer it.  You need to sacrifice a chicken to dcoutts.  Then reformat your hard drive and use the --wibble option to cabal.  easy!
10:31:39 <dcoutts> heh heh heh
10:31:43 <dcoutts> it's true!
10:32:00 <chadz> any restrictions on the chicken?
10:32:01 <dcoutts> though, perhaps not a chicken, I'm a vegie
10:32:10 <wagle_> rubber chicken?
10:32:11 <dcoutts> what's the next best thing I wonder
10:32:16 <chadz> two chickens.
10:32:16 <byorgey> a tofurkey?
10:32:20 <thetallguy> wasabi root?
10:32:27 <chadz> a virgin?
10:32:29 <dcoutts> wagle_: hmmm, they don't roast well I hear
10:32:49 <thetallguy> For roasting, pineapple.
10:33:06 <dcoutts> thetallguy: really? would not have thought of it
10:33:15 <thetallguy> they grill really well.
10:33:37 <byorgey> mmm roasted pineapple!
10:33:56 <thetallguy> But I'd probably say it would be better to sacrifice a pint or a bottle of single malt.
10:34:01 * dcoutts sacrificed a massive turnip on Burns night
10:34:05 <chadz> alright, well i'm going to assume that i'm boned
10:34:17 <chadz> i suppose I could work without xmonad for a few days at work.
10:34:34 <dcoutts> chadz: so what is the problem?
10:34:36 <chadz> while you diligent cabal hackers solve my problem!
10:34:43 <thetallguy> It's hard to do decadent vegetarian food.  Cheese is one way to go, I suppose.
10:34:55 <chadz> zlib wants gmp.h, which is in a local directory
10:34:59 <thetallguy> funny, I was going to say turnip
10:34:59 <dons> thetallguy: chocolate cup cakes with inch thick icing :)
10:35:07 <thetallguy> dcoutts: what is Burns night?
10:35:17 <byorgey> dons: for roasting ??
10:35:17 <thetallguy> dons: ooog
10:35:27 <thetallguy> byorgey: lol
10:35:32 <dons> hehe well, just about being decadent
10:35:49 <dons> since moving the US, i've discovered the wonders of ridiculously decadent vege food
10:36:04 <byorgey> hehe
10:36:31 <thetallguy> dons: my sugar tolerance has declined.  My idea of decadent is more like all the toro you can eat.
10:36:40 <chadz> dcoutts: so, since it can't find gmp.h, it dies. i'm not sure how to provide include paths without hacking the .cabal file, which i'd rather not do if i'm using cabal-install
10:36:58 <thetallguy> dons: yeah, PNW is the place for that.
10:37:08 <dcoutts> thetallguy: Robert Burns, favourite poet of Scotland, there's a night each year where one eats haggis, tatties and neaps and reads Burns's address to a haggis
10:37:10 <chadz> pnw, represent!
10:37:11 <sclv> chadz: you need to hack the cabal file i think. seriously not a big deal.
10:37:30 <chadz> sclv: there's NO point in using cabal-install if i have to hack every other file
10:37:52 <dons> chadz: is this about finding gmp.h ?
10:37:54 <thetallguy> dcoutts: I know Burns, of course, but I didn't know he had inspired a holiday.
10:37:56 <dons> its in /usr/local or something?
10:37:57 <sclv> cabal-install is 0.4, right? so file a bug request or patch it yourself.
10:38:08 <thetallguy> dcoutts: haggis I know, but what are tatties and neaps?
10:38:14 <chadz> dons: correct. no. it's in home directory.
10:38:18 <thetallguy> dcoutts: potatoes?
10:38:24 <thetallguy> dcoutts: greens?
10:38:25 <dcoutts> sclv, chadz: http://hackage.haskell.org/trac/hackage/ticket/221
10:38:26 <lambdabot> Title: #221 (need a way to specify site-specific include and library search paths) - Ha ...
10:38:30 <dons> chadz: you can edit the package.conf entry for the rts
10:38:32 <dons> to find gmp
10:38:38 <dons> then everything will work
10:38:46 <dcoutts> chadz: however until that is implemented you'll have to hack the .cabal file
10:38:54 <dons> vim ~/lib/ghc-6.8.2/package.conf
10:39:02 <chadz> ah. ok
10:39:15 <dons> then add: ldOptions = ["-L/usr/local/lib"
10:39:18 <thetallguy> dcoutts: never mind, found a recipes.
10:39:21 <dons> to theldOptions for rts
10:39:30 <dons> or whatever the path to link your gmp in is
10:39:46 <dons> oh, you might also edit the .h headers to point to the gmp.h
10:39:52 <dcoutts> in this case it's include dirs
10:39:54 <dons> its a ghc build issue more than a cabal issue
10:40:05 <thetallguy> My local store stopped carrying steel cut oats.  Very annoying.
10:40:35 <dons> dcoutts: could you create the frag project on code, btw?
10:40:38 <dons> i want to toss frag up there.
10:40:42 <dcoutts> dons: yeah, ghc should include include dir for gmp into rts package conf
10:40:58 <chadz> @karma+ dons
10:40:59 <lambdabot> dons's karma raised to 146.
10:41:55 <ehird> hm
10:42:11 <thetallguy> So, voiting on inits1 and tails1 currently has it stalled, right?
10:42:32 <thetallguy> s/voiting/voting/
10:42:39 <dcoutts> dons: done.
10:42:41 <dons> seems like a weird thing in base.
10:42:43 <dons> cheers dcoutts
10:42:46 <dons> dcoutts++
10:43:03 <ehird> ghc still doesn't compile
10:43:03 <ehird> :|
10:43:24 <ehird> Oh well
10:43:30 <dons> can you get a binary?
10:43:45 <ehird> dons: Yes. ;)
10:43:54 <ehird> But I won't, for no particular reason
10:43:58 <dons> ok.
10:44:03 <ehird> How long does ghc take to compile these newfangled days?
10:44:22 <dons> 3 mins.
10:44:28 <dons> but that varies with how many cores you have.
10:44:30 <dcoutts> on a 16-core amd64 :-)
10:44:37 <dcoutts> with no optimisation and no libs
10:44:41 <dons> :)
10:44:46 <desegnis> > 3 * 16
10:44:47 <ehird> heh
10:44:48 <dons> your mileage might vary
10:44:54 <lambdabot>  48
10:44:59 <ehird> core 2 duo, ~2ghz
10:45:03 <ehird> only 1gb of ram though.
10:45:06 <ehird> os x tiger.
10:45:15 <ehird> regular sort of compile.
10:45:45 <dons> they're pretty zippy
10:45:49 <chadz> is there a way to force a cabal install ?
10:45:49 <dons> less than 20 mins.
10:45:52 <ehird> dons: really?
10:45:55 <dons> chadz: unregister the package.
10:45:57 <ehird> the first macports install i did
10:45:58 <ehird> took 4 hours
10:45:59 <ehird> :-|
10:46:09 <dcoutts> dons: I wrote to a Sun representative enquiring about cooperation on getting ghc working on new sparc machines, ie having Sun donate one of those 32core boxes and we getting some SoC student or something to get the ghc sparc ncg working again
10:46:18 <RyanT5000> has anyone here used haxe?
10:46:24 <dons> dcoutts: oh, very interesting.
10:46:26 <dcoutts> dons: no reply yet, we'll see
10:46:34 <thetallguy> RyanT5000: a tiny bit
10:46:42 <chadz> dons: ghc-pkg, right?
10:46:49 <ehird> what reason would it have taken 4 hours?
10:47:06 <thetallguy> RyanT5000: but then flex came out and I dropped haxe
10:47:20 <RyanT5000> thetallguy: how is the flex static typing stuff?
10:48:08 <thetallguy> RyanT5000: I can't say really.  I'm using Haskell to generate Flex XML
10:48:16 <RyanT5000> thetallguy: ah, cool
10:48:17 <dons> ehird:  hmm. compiling lots of libs, lots of ways
10:48:42 <thetallguy> RyanT5000: so, I get error messages... but then I tighten up the Haskell so they don't show up again.
10:49:07 <RyanT5000> thetallguy: yeah, that sounds like fun
10:49:13 <thetallguy> RyanT5000: but my partner stepcut will soon be working full time on Haskell -> Flash Bytecode
10:49:28 <thetallguy> RyanT5000: at which point things get much more interesting.
10:49:30 <RyanT5000> thetallguy: nice; i've been wanting that for a while
10:49:55 <ehird> dons: i want extralibs too
10:49:56 <ehird> :|
10:49:59 <ehird> the extralibs pkg thing
10:50:03 <RyanT5000> thetallguy: let me know if you need any more hands on that; i'm not sure if i'll have time, but i'd like to help if i do
10:50:13 <dons> ehird: its easy enough to do extra libs later with cabal install,fwiw
10:50:19 <thetallguy> RyanT5000: He's been tinkering with it for some time, but we're switching to full time.  See  HC&A report, SeeReason Partners for details.
10:50:28 <ehird> dons: mm, but how long does extralibs.tar.bz2 take?
10:50:47 <thetallguy> RyanT5000: thanks, I'll keep that in mind.
10:50:53 <RyanT5000> thetallguy: np
10:52:46 <thetallguy> That reminds me, soft announcement for people interesting in Debian/Ubuntu packaging of Haskell stuff.
10:53:27 <thetallguy> David and Jeremy have fixed the version number generation and we have built all (most?) of the packages with 6.8.2.
10:54:07 <ehird> :/
10:54:11 <thetallguy> If anyone is interested in trying them out, let me know.
10:54:20 <CosmicRay> what packages are you referring to?
10:54:35 <thetallguy> Debian packaging of Haskell compiler/libraries
10:54:58 <thetallguy> They are now bulit for gutsy gibbon.
10:55:05 <CosmicRay> oh.
10:55:12 <thetallguy> etch/lenny will take a bit.
10:55:25 <thetallguy> and we're not sure we're going to do that work.
10:55:30 <CosmicRay> well it's already in sid so migration to lenny will happen whenever
10:55:37 <thetallguy> The sid packages won't work in gutsy.
10:56:06 <thetallguy> CosmicRay: yes, hence our emphasis on the Ubuntu side.
10:56:19 <CosmicRay> who are you?  (trying to parse out "our")
10:56:35 <thetallguy> Of course, they were all built with our autobuilder, which is written in Haskell...
10:57:07 <thetallguy> http://www.haskell.org/communities/12-2007/html/report.html, Section 7.1.6,  I'm Cliff
10:57:07 <lambdabot> Title: Haskell Communities and Activities Report
10:57:21 <thetallguy> Formerly the Linspire OS team...
10:57:48 <CosmicRay> oh interesting.  got it.  I used to talk to Jeremy periodically.  I'm John Goerzen, FWIW
10:58:09 <thetallguy> Ah, right, I'd forgotten that was your handle.
10:58:18 <dons> thetallguy: any thoughts on good reusable code we can pull out of the linspire haskell effort?  like the bytestring parser. anything else good in there?
10:58:32 <thetallguy> dons: src.seereason.com
10:58:49 <CosmicRay> quite a bit of stuff there
10:58:53 <CosmicRay> any particular highlights? ;-)
10:58:56 <dons> oh my.
10:58:57 <thetallguy> The bytestring parser is the most general
10:59:11 <thetallguy> all the Debian stuff is somewhat useful
10:59:15 * CosmicRay notes xtla-quilt in there
10:59:30 <CosmicRay> sounds... hackish... ;-)
10:59:30 <dons> what's 'quilt' ? hacked stuff?
10:59:37 <thetallguy> I need to get Jeremy to export isoluv, which does [Package] -> IO CDImage
10:59:51 <dons> parsers for any unix config formatS?
11:00:04 <thetallguy> dons: correct.  Patches that get applied to source debs pulled from a repository
11:00:05 <CosmicRay> thetallguy: ooo, SWEET
11:00:07 <dons> unixutils looks fun
11:00:18 <dons> haskell-ugly eh?
11:00:25 <thetallguy> dons: so if you want to maintain a particular feature that upstream/debian doesn't agree with...
11:00:28 <CosmicRay> I see findcopies.  there are already a couple of tools to do that in debian (see GNU perforate for one)
11:00:29 <dons> ok. this looks awesome.
11:00:33 <ehird> i need to know before i start this crazy compile
11:00:33 <dons> what's the plan for this stuff?
11:00:33 <ehird> :P
11:00:36 <dons> can we get it up to hackage?
11:00:50 <thetallguy> dons: yes, in time.
11:00:57 <thetallguy> dons: it's all open licensing
11:01:07 <dons> is david maintaining it ?
11:01:11 <CosmicRay> oh indeed, unixutils would be a perfect companion to HSH
11:01:20 <dons> or you, or stepcut?
11:01:31 <thetallguy> dons: and most of it isn't on our new project plan, so we want to put a bow on it and have everyone use/help if they are intested.
11:01:57 <thetallguy> dons: all three, in theory, but most David and Jeremy.
11:02:49 <thetallguy> CosmicRay: our autobuilder doesn't quite work for debian anymore, because of upstart
11:03:11 <BMeph> dcoutts_: So, if you go to school in the PNW, does that mean you're pwned? ;)
11:03:28 <thetallguy> CosmicRay: there's a tool called build-env that looks at a sources.list/Index file, finds all essential packages, installs them into a chroot
11:03:39 <dons> "What's the good of having a haskell-programming computational linguist on
11:03:40 <dons> board if we can't get static compile-time guarantees of grammatical
11:03:40 <dons> correctness?"
11:03:56 <ehird> :/
11:04:16 <thetallguy> CosmicRay: but it's currently busted because some file doesn't appear in /etc, I forget the details.
11:04:20 <CosmicRay> thetallguy: nice.  you guys are working in the same problem domain as I am, in quite a few places.  I've got two process-related frameworks already...  and I see yours too.  I've got some Debian stuff in MissingH and srcinst is written in Haskell
11:04:27 <dcoutts> BMeph: PNW?
11:04:42 <wagle_> dons: easy..  reject all utterances
11:05:04 <thetallguy> CosmicRay: yes, and we'd love to cede all this stuff to you/Debian to include/use
11:05:17 <ehird> anyone compiled extralibs?
11:05:34 <ehird> ah, wait
11:05:36 <ehird> i'll just do it
11:05:37 <thetallguy> CosmicRay: one advantage, ours is a bit more general, because we couldn't assume we were working directly with Debian support/access.
11:05:51 * ehird ponders unimportant things like /usr/local/ghc vs /usr/local/haskell vs /usr/local/haskell/ghc
11:05:54 <thetallguy> Pacific Northwest
11:06:30 <wagle_> /usr/local/bin/ghc
11:06:56 <thetallguy> Jeremy/stepcut wrote some combinators recently to generate man pages
11:07:26 <thetallguy> I haven't seen them, but if you look in src.seereason.com/autobuilder, you should see them in use.
11:07:46 <ehird> wagle_: but that makes removing stuff hell ;)
11:07:54 <resiak> so i notice that ghc is in principle in Debian on armel; has anyone tried using ghc-compiled binaries on a Nokia N8x0 ?
11:08:02 <ehird> /usr/local/ghc/..., /usr/local/haskell/..., /usr/local/haskell/ghc/... are much simpler
11:08:27 <thetallguy> I imagine those will be of general interest
11:08:36 <resiak> (I say in principle because 6.8 hasn't built on arm yet, but 6.6 did, apparently.)
11:09:02 <wagle_> ehird, keep a blank skeleton of /usr/local/. in a tarbar, keep /usr/local/src around, delete /usr/local, unpack tar ball, and reinstall from /usr/local/src
11:09:31 <thetallguy> This isn't darcs'ed yet, but http://src.seereason.org/Table.hs adds simple tables to PrettyPrint
11:10:16 <wagle_> ehird, yeah, but your PATH, MANPATH, LD_LIBRARY_PATH, INFOPATH start getting unwieldy
11:11:11 <wagle_> but yeah, been there, done that
11:12:08 <doserj> ehird: or use stow
11:12:20 <ehird> doserj: > stow
11:12:35 <ehird> wagle_: meh, my PATH is big already
11:12:42 <wagle_> oh yeah, i think the complaint i got was that it took forever to login
11:12:57 <ehird> % echo $PATH|wc -c
11:12:57 <ehird> 541
11:13:26 <doserj> ehird: the idea of stow is to install packageX in /usr/local/stow/packageX, and maintain symlinks from /usr/local
11:13:35 <doserj> http://www.gnu.org/software/stow/
11:13:36 <lambdabot> Title: Stow - GNU Project - Free Software Foundation (FSF)
11:14:10 <oerjan> ehird: did you see GregorR's mention of http://www.nongnu.org/sps/ on #esoteric? it just sounded slightly relevant.
11:14:11 <lambdabot> Title: SPS
11:16:09 <ehird> oerjan: heh, that's amusing
11:16:24 <ehird> doserj: I already have a package manager. Its ghc is just old right now :P
11:16:27 <ehird> I'll go for /usr/local/ghc
11:16:45 <thetallguy> doserj: have you read about NixOS?
11:16:56 <doserj> thetallguy: no?
11:17:45 <thetallguy> doserj: similar idea, but more advanced, purely functional OS structure.  Being developed at Utrecht, I think.
11:18:05 <thetallguy> http://nix.cs.uu.nl/nixos/
11:18:06 <lambdabot> Title: NixOS
11:19:03 <thetallguy> Doatsie said Eelco has a four year grant to develop it.
11:20:11 <thetallguy> Many of the problems I ran into at Linspire, I conceived purely functional solutions to, and then found NixOS and he had done them already, with improvements.
11:21:00 <olsner> @ty \(_:_:x:_:_) -> x
11:21:03 <lambdabot> forall t. [t] -> t
11:21:14 <olsner> caddar ;-)
11:21:23 <ehird> hmm
11:21:25 <ehird> ObjectIO?
11:21:27 <gbacon> @karma+ olsner
11:21:27 <lambdabot> olsner's karma raised to 5.
11:21:33 <ehird> ghc has it.
11:21:34 <ehird> is it any good?
11:22:07 <olsner> wait, that was probably wrong though :(
11:22:39 <Deewiant> caddr?
11:23:26 <olsner> yeah, a caddr that looks at too much of the list
11:23:31 <Deewiant> aye
11:24:02 <sjanssen> @seen dcoutts
11:24:02 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 11m 43s ago.
11:24:03 <olsner> @ty \((_:_:x:_):_) -> x
11:24:04 <lambdabot> forall t. [[t]] -> t
11:24:05 <Deewiant> caddar would be \((_:_:x:_):_) -> x I believe
11:24:10 <sjanssen> dcoutts: ping
11:24:10 <Deewiant> yeh :-)
11:24:10 <dcoutts> hia sjanssen
11:24:19 <Cale> @ty \(_:_:(x:_):_) -> x
11:24:20 <lambdabot> forall t. [[t]] -> t
11:24:30 <Deewiant> @pl \((_:_:x:_):_) -> x
11:24:30 <lambdabot> head . tail . tail . head
11:24:40 <Deewiant> that's caddar alright
11:25:11 <sjanssen> dcoutts: we're looking at using the Paths_foo stuff in Cabal to automatically get xmonad's version number.  Will this be supported in the long term?
11:25:24 <dons> and if it is, can the generated files have more sensible names :)
11:25:26 <dcoutts> sjanssen: yes, no plans to change it
11:25:31 <dons> import Paths_foo is a bit gross
11:25:46 <dcoutts> dons: what do you think it should be?
11:25:59 <sjanssen> well, the grossness does make it pretty clear that it isn't your average module ;)
11:26:07 <dons> import Distribution.Configuration.XMonad  or something :)
11:26:07 <dcoutts> dons: originally it was for paths like data files, but we added version info in there too
11:26:11 <Cale> @ty \(_:_:((_:_:x):_):_) -> x
11:26:11 <lambdabot> forall t. [[[t]]] -> [t]
11:26:26 <dcoutts> dons: and how is cabal supposed to know that that's what the module name should be? :-)
11:26:26 <Deewiant> @pl \(_:_:((_:_:x):_):_) -> x
11:26:27 <lambdabot> tail . tail . head . head . tail . tail
11:26:27 <dons> dcoutts: is this the intended use of these modules, btw?
11:26:37 <dons> that we should be able to import them into application code?
11:26:40 <Deewiant> @. unpl pl \(_:_:((_:_:x):_):_) -> x
11:26:40 <lambdabot> (\ c -> tail (tail (head (head (tail (tail c))))))
11:26:46 <dons> to get version info and other cabal data
11:26:47 <dcoutts> dons: yes, for programs to find their own data files and know their version number.
11:27:02 <ehird> :\
11:27:06 <dons> ok. if its the intended use, then that's cool
11:27:13 <dons> i wasn't sure if it was design or accident
11:27:31 <dcoutts> dons: yep, it's rather nicer than generated #include file like autoconf does
11:27:43 <dons> yep
11:28:00 <dons> some of the other cabal fields would be useful
11:28:09 <dons> version, synopsis, author, homepage..
11:28:39 <dcoutts> dons: yes, depends how they're done, we cannot export the PackageDescription since that'd tie you to the Cabal lib
11:28:51 <dons> yep.
11:28:55 <dcoutts> dons: but we'd accept patches to export simple things like strings etc
11:28:59 <dons> ok
11:29:17 <dcoutts> dons: you already get version
11:29:24 <sjanssen> ooh, was Data.Version in GHC 6.6?
11:29:29 <dons> yeah
11:29:31 <dcoutts> sjanssen: yes
11:29:47 <dcoutts> sjanssen: in 6.4 actually I think
11:31:34 <dons> @seen Igloooo
11:31:34 <lambdabot> I haven't seen Igloooo.
11:31:35 <dons> @seen Igloo
11:31:35 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 2h 1m 34s ago.
11:33:01 <sarah__> @pl posAround b p = concat $ map (squaresAround b) p
11:33:01 <lambdabot> posAround = (join .) . map . squaresAround
11:33:14 <sarah__> @pl posAround b p = concatMap (squaresAround b) p
11:33:14 <lambdabot> posAround = (=<<) . squaresAround
11:33:21 <dons> Igloo: can you give nomeata the ok to upload X11 1.4.1, now that ghc's been updated in debian?
11:33:24 <sarah__> @pl posAround b = concat $ map (squaresAround b)
11:33:24 <lambdabot> posAround = join . map . squaresAround
11:34:08 <sarah__> @src concatMap
11:34:08 <lambdabot> concatMap f = foldr ((++) . f) []
11:34:16 <sarah__> @src map
11:34:16 <lambdabot> map _ []     = []
11:34:16 <lambdabot> map f (x:xs) = f x : map f xs
11:36:28 <ehird> what do i need to bootstrap ghc 8.2?
11:36:32 <ehird> on os x tiger
11:36:35 <Deewiant> a time machine
11:36:47 <tibbe> what's a good way of measuring a programs max memory size under linux?
11:36:48 <Igloo> dons: I'll be doing another batch of Debian stuff soon
11:36:54 <tibbe> I'm sieging my haskell web server :)
11:37:10 <jedbrown> heh, teaching the social network tool that dcoutts = dcoutts_ would dramatically change the topology
11:37:11 <dons> Igloo: ok. xmonad depends on this :)
11:37:23 <dons> we're really really keen to have an up to date tool chain
11:37:26 <dcoutts> jedbrown: heh :-)
11:37:34 <dons> Igloo: nomeata's happy to do X11, if you'd like.
11:37:44 <dons> he's done the xmonad 0.6 package already.
11:37:59 <dons> so you could just toss him an 'ok' and we'd be underway..
11:38:38 <efncs> Any idea why this function works fine in ghci, but not ghc?  a = do x <- randomIO; return $ x < 0.5
11:38:47 <ehird> Deewiant: heh
11:38:58 <dons> type inference, efncs ?
11:39:13 <dcoutts> dons: btw, I was meaning to ask why you'd moved to arch linux when there are other platforms with much better haskell packages :-)
11:39:30 <Cale> efncs: What happens in GHC?
11:39:33 <dons> dcoutts: well, i haven't actually moved yet. but i care not for packages. just for a very simple distro.
11:39:44 <Cale> efncs: Perhaps it's the monomorphism restriction.
11:39:49 <BMeph> returns from lunch
11:39:57 <dolio> Isn't that essentially the same as 'a = randomIO'?
11:40:10 <efncs> Cal: "Ambiguous type variable `a' in the constraints"
11:40:13 <Cale> dolio: no, it's the same as liftM (< 0.5) randomIO
11:40:25 <dcoutts> dons: right, you want to use cabal-install as your package manger ;-)
11:40:29 <dons> yep
11:40:55 <dolio> Cale: But what's the range on randoms for floating point values? 0.0 to 1.0?
11:41:00 <Cale> efncs: okay, so the problem is that it doesn't know what type of random number you want. GHCi has extended defaulting rules.
11:41:11 <Cale> dolio: arbitrary
11:41:20 <dolio> Ah, okay.
11:41:25 <Cale> uh
11:41:33 <Cale> oh, no it's 0 to 1
11:41:39 <Cale> You're right :)
11:41:51 <Deewiant> Is it a guaranteed even distribution?
11:42:04 <Cale> It's supposed to be, but I'm not sure if it is.
11:42:11 <dmwit> It's supposed to be uniform on [0,1[.
11:45:08 <ehird> http://www.haskell.org/ghc/dist/6.8.2/ghc-6.8.2-darwin-i386-leopard-bootstrap.tar.bz2 -- is there one of these for tiger?
11:45:09 <Cale> The code in System/Random.hs looks well thought out.
11:45:09 <lambdabot> http://tinyurl.com/2rovoh
11:45:14 <efncs> Cale: So I've got to say "I want a Fractional"? Is there a way to do this?
11:45:26 <dmwit> Actually, it's probably only uniform up to the granularity of 1/MAX_INT or something.
11:45:56 <Cale> efncs: Either include a type signature, or -XNoMonomorphismRestriction
11:46:28 <Cale> er, no, that still won't work
11:46:41 <Cale> You need to specify  randomIO :: IO Double
11:47:08 <olsner> ehird: I have successfully bootstrapped with the 6.6.1 bootstrap on tiger
11:47:13 <Cale> a = do x <- randomIO :: IO Double; return $ x < 0.5
11:47:29 <Deewiant> > do x <- randomIO :: IO Double; return $ x < 0.5
11:47:33 <Cale> However, that should be roughly equivalent to  a = randomIO :: IO Bool
11:47:33 <lambdabot>  <IO Bool>
11:48:00 <ehird> aha
11:48:01 <ehird> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-darwin-i386-tiger-bootstrap.tar.bz2
11:48:01 <lambdabot> http://tinyurl.com/2m82gp
11:48:15 <desegnis> Would be nice if the bot gave us a StdGen somehow...
11:48:32 <dons> > mkStdGen 42
11:48:32 <desegnis> though that wouldn't help here
11:48:32 <lambdabot>  43 1
11:48:34 <Cale> (since, due to the distribution being uniform, the probability of getting a result in the interval [0,1/2) should be the same as getting one in [1/2,1)
11:48:34 <dmwit> > liftM (< 0.5) randomIO
11:48:35 <lambdabot>  <IO Bool>
11:48:35 <olsner> there's also a 6.6.1 bootstrap, but I wouldn't know the difference
11:48:51 <desegnis> dons, uh, thanks
11:48:55 <Deewiant> > liftM show $ liftM (< 0.5) randomIO
11:48:56 <lambdabot>  <IO [Char]>
11:49:12 <dons> > randomRs (1,6) (mkStdGen 42) :: [Int]
11:49:12 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
11:49:33 <Cale> dmwit: Works in lambdabot, but it's actually ambiguous :)
11:49:36 <dmwit> > randomRs (True, False) (mtStdGen 0)
11:49:36 <lambdabot>   Not in scope: `mtStdGen'
11:49:41 <dmwit> > randomRs (True, False) (mkStdGen 0)
11:49:42 <lambdabot>  [True,True,True,False,False,True,True,True,True,False,True,False,False,False...
11:49:44 <dmwit> hey, neat!
11:49:44 <Deewiant> @ty randomRs
11:49:45 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
11:49:57 <dmwit> Cale: yeah =P
11:49:59 <dons> > randoms (mkStdGen 0) :: [Bool]
11:50:00 <lambdabot>  [True,True,True,False,False,True,True,True,True,False,True,False,False,False...
11:50:19 * dmwit has very weak Random-fu
11:50:23 <efncs> Cale: Thanks, that is what I'm looking for. (The actual funtion is more complex, I just left out anything else.)
11:53:53 <Cale> Aha, -XExtendedDefaultRules  will make the program default types the same way as in GHCi.
11:56:25 <nothingmuch> i'm trying to tinker with yi, and while trying to build HOC on i'm getting a cabal error: Setup.hs: HOC.cabal:43: Parse of field 'extensions' failed:
11:56:41 <dons> you'll need a newer cabal
11:57:24 <nothingmuch> how do i find out what my current version is?
11:57:30 <dons> ghc-pkg list
11:57:33 <dons> then look for Cabal
11:58:07 <Cale> (or grep the output :)
11:59:16 <nominolo> ghc-pkg list Cabal
11:59:24 <nominolo> -> shorter list
11:59:31 <dmwit> Round one: nominolo!
11:59:32 <Cale> ah, interesting
11:59:46 <nothingmuch> ok, works
12:00:13 <nominolo> cabal head doesn't work with yi, btw
12:00:21 <nominolo> you need cabal 1.2.3
12:00:30 <nothingmuch> that's what I installed
12:00:32 <Cale> The result of using --simple-output is a little disappointing. It would be a little more convenient for *nix users if those were separated onto lines.
12:00:36 <nominolo> (bundled with ghc 6.8.2)
12:00:44 <nothingmuch> bah,     binary >=0.2
12:00:51 <nothingmuch> google isn't helpful
12:01:15 <nominolo> oh, HOC is that objective C stuff
12:01:29 <nothingmuch> nevermoose, i think i found it
12:01:46 <nominolo> i think the Cocoa port is very experimental - ie, no guarantee it even builds
12:01:56 <Cale> nothingmuch: Most stuff is on Hackage
12:02:25 <nominolo> nothingmuch: if you don't get it to work, ask on yi-devel
12:02:34 <nothingmuch> okies
12:02:57 <Cale> And if you install the cabal-install package, you can use that to download, compile and install things pretty much automatically
12:03:06 <nothingmuch> ah, cool
12:03:12 <Cale> like:  sudo cabal --global install binary
12:04:06 <nominolo> nothingmuch: but cabal-install needs Cabal head.  a release is in preparation, though
12:04:36 <Cale> what? Really?
12:04:48 <nominolo> for cabal-install, yes
12:04:59 <Cale> I have cabal-install and I'm running 1.2.3.0
12:05:28 <nominolo> Cale: when did you build it?
12:05:49 <Cale> Around when 6.8.2 came out.
12:06:08 <nominolo> ok, at that time 1.2.3 was HEAD ;) (mostly)
12:06:13 <dcoutts> nominolo: why doesn't cabal head work with yi? does yi use a crazy Setup.hs?
12:06:41 <nominolo> dcoutts: no idea.  but yi setup is pretty tricky, yes
12:07:04 <Cale> nominolo: But cabal-install is still the same version
12:07:16 <dcoutts> Cale: you're using an ancient version of cabal-install
12:07:25 <dcoutts> get with the times! :-)
12:07:26 <Cale> I'm using the one that's on Hackage.
12:07:27 <nominolo> "ancient"
12:07:35 <nominolo> whoa
12:07:45 <Cale> If you want me to use a newer one, upload a new one to hackage :)
12:07:47 <nominolo> that's so last year, dudu
12:07:49 <sarah__> @pl allPosTrue f b = filter (posTest f b)
12:07:49 <lambdabot> allPosTrue = (filter .) . posTest
12:07:50 <nominolo> *dude
12:08:03 <sarah__> o sorry meant to msg that to lambdabot
12:08:10 <dcoutts> Cale: that's why we want to make a new release of the Cabal lib, to support a release of cabal-install
12:08:16 <nothingmuch> bah, yi-devel is not an IRC channel ;-)
12:08:29 <nominolo> nothingmuch: it's a google group
12:08:34 <dcoutts> Cale: until then we cannot do a cabal-install release on hackage since it needs the development version of Cabal
12:08:34 <cjb> Something I haven't figured out yet:  why Add :: Integer -> Integer -> Integer instead if Add :: Integer, Integer -> Integer?
12:08:35 <nothingmuch> yeah, i figured ;-)
12:08:52 <nothingmuch> i think i won't pursue this for now, too much other stuff to wrorry about
12:08:55 <Cale> cjb: what's that comma doing there :)
12:09:05 <desegnis> cjb: You may want to look up Currying
12:09:08 <nothingmuch> but for some reason yi can't find the hoc bindings or something, it says it can't be built on this system,
12:09:08 <cjb> Cale: expressing a difference between arguments and returns :)
12:09:20 <Cale> cjb: This is because every function in Haskell really has only one parameter.
12:09:23 <desegnis> cjb: Which means that there really is a reason
12:09:25 <nominolo> cjb: or SchÃ¶nfinkeling
12:09:27 <Zao> > :t (+1)
12:09:27 <lambdabot>   parse error on input `:'
12:09:28 <cjb> desegnis: I was just gonna say I bet it has something to do with currying.  But I don't see how currying gets in the way.
12:09:31 <Zao> :t (+1)
12:09:31 <lambdabot> forall a. (Num a) => a -> a
12:09:45 <cjb> nominolo: I heard the dotnetrocks interview too :)
12:09:54 <Cale> cjb: Functions of more than one parameter just take the first parameter and produce another function.
12:09:57 <roconnor> > map (+1) [0..]
12:09:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:10:00 <Cale> So when you see:
12:10:06 <Cale> Integer -> Integer -> Integer
12:10:08 <Cale> it means:
12:10:11 <Cale> Integer -> (Integer -> Integer)
12:10:15 <cjb> ah, so.
12:10:17 <cjb> Thanks!
12:10:19 <Deewiant> :t (+)
12:10:20 <lambdabot> forall a. (Num a) => a -> a -> a
12:10:21 <Deewiant> :t (+1)
12:10:21 <lambdabot> forall a. (Num a) => a -> a
12:10:22 <nominolo> cjb: I knew that before ;P
12:10:23 <Deewiant> :t (+1) 1
12:10:24 <lambdabot> forall a. (Num a) => a
12:10:26 <Cale> Also, function application associates to the left.
12:10:38 <Cale> So f x y is the same as (f x) y
12:10:50 <desegnis> cjb: You have different kinds of functions: 1) Functions with multiple parameters (they do not exist in Haskell); 2) functions that take a tuple, and so have ultimately multiple parameters; 3) curried functions that have ultimately multiple parameters
12:11:00 <Cale> So there's no need to have any special support for multiparameter functions :)
12:11:20 <Cale> However, we also allow tuples in the language, so you can make functions on those.
12:11:30 <ehird> nominolo: 'It is not called SchÃ¶nfinkeling." | "Thank you, Haskell B. Curry (1900-1982)"
12:11:39 <ehird> Cale: Well -- variadic.
12:11:46 <Cale> (which is sort of the usual way to handle multiparameter functions in mathematics)
12:11:47 <roconnor> -> associates right, and function application associates left.  This difference is because function application is written the wrong way around for historical reasons.
12:11:47 <ehird> Though you can do that.
12:11:50 <ehird> If you do some fun tricks.
12:11:55 <cjb> Thanks, all makes sense.
12:11:58 <ehird> And if you can tell, from the arguments you have, if you need any more
12:12:02 <ehird> (So: printf, basically.)
12:12:08 <ehird> (And if you lack lazy evaluation, nullary functions)
12:13:05 * Cale is in the camp that says if it doesn't have the (->) constructor at the top level in its type, it's not a function.
12:13:28 <gbacon> Cale: stickler :-)
12:13:56 <nominolo> ehird: some people suggested to call uncurrying schÃ¶nfinkeling
12:13:57 <Cale> :)
12:14:26 <ehird> nominolo: That was a The Little Schemer quote.
12:14:45 <jedbrown> Cale: so if no arguments are pushed on the stack or placed in registers before entering the closure, then the closue is not a function.
12:15:03 * jedbrown thinks Cale's definition is perfectly valid too.
12:15:08 <Cale> jedbrown: right.
12:15:44 <Cale> Also, even if you newtype a function type, the values of that type are not functions :)
12:15:51 <Cale> (they
12:16:00 <Cale> (they're whatever the heck you called your newtype :)
12:17:23 <Saizan> roconnor: you mean postfix makes more sense?
12:18:27 <desegnis> newtype Function a b = F (a -> b)
12:20:20 <jedbrown> roconnor: many algebraists do write composition from left to right, though it is becoming less popular
12:21:16 <Cale> jedbrown: Which way is from left to right? :)
12:21:58 <jedbrown> Cale: (f . g . h)(x)  = h(g(f(x)))
12:22:07 <Cale> ah
12:22:21 <Cale> If you're going to do that, you should go the whole hog
12:22:31 <roconnor> Saizan: it makes more sense in as much as reading English left to right makes more sense.
12:22:41 <Cale> x (f . g . h) = ((x f) g) h
12:23:16 <conal> roconnor: maybe not "more sense" but "more customary" (in some cultures)
12:23:25 <jedbrown> Cale: Yes, but it is plenty common that you never talk about x.  For instance when a group action is composition.
12:23:28 <Cale> It's funny though, in a lazily evaluated language, the traditional order makes more sense.
12:23:35 <roconnor> conal: maybe that is better way of saying it.
12:23:41 <Saizan> well usually the function is more important than the argument
12:24:04 <Cale> In the expression (f . g . h) x, f is the first function to be applied (after composition)
12:24:26 <roconnor> Saizan: My programs that are myFunction = (doLastThing . doMiddleStep . doFirstThing) is strange.
12:24:29 <Cale> Of course, it's applied to (g . h) x
12:25:01 <jedbrown> Cale: It took me a while to realize the consequences of that.
12:25:02 <Cale> So things evaluate just as you read them :)
12:25:40 <Saizan> roconnor: yeah, i see that too, but it's more about composition than application imho
12:25:55 <conal> roconnor: if your programs are functional, they're do "do"-anything, are they?
12:26:22 <conal> roconnor: "not *do* anything"
12:26:38 <roconnor> Saizan: right, but I like composition to be compatable with function application so that reasoning is easy.
12:27:04 <conal> roconnor: easier to eyeball derivations for correctness?
12:27:30 <conal> (or s/derivations/calculations/)
12:27:35 <olsner> ooh! x (f . g . h) = cat x | f | g | h
12:27:45 <roconnor> I think, but I could be wrong about the importance of application and composition working well together.
12:28:03 <roconnor> conal: how's it going?
12:28:13 <conal> roconnor: great!  you?
12:28:35 <roconnor> I've been working hard on my research.  Not much time to play with phooey.
12:29:04 <conal> roconnor: how far did you get with phooey and gtk2hs?
12:29:24 <roconnor> conal: I last left it with one widget more or less working.
12:29:31 <roconnor> proof of concept.
12:29:51 <conal> roconnor: sounds like a good start. might be straightforward from there.
12:30:04 <roconnor> althought maybe making an input widget work would make for a better proof of concept.
12:30:33 <conal> roconnor: btw, remember that problem with lack of caching that came up in your example at hac?
12:30:47 <roconnor> yes, you said something about bumping into it yourself.
12:31:33 <conal> yep.  i ran into it again when doing a neat graphics application (in the works).  that's what motivated me to switch from DataDriven to Reactive, which does caching very elegantly and efficiently.
12:32:50 <roconnor> um, can you really switch just like that?
12:33:01 <roconnor> they are vaguely different paradigms
12:33:29 <conal> different paradigms?  how do you mean?
12:33:59 <roconnor> DataDriven is a series of distrect events
12:34:13 <roconnor> while Reactive is more continuous.
12:34:23 <kaol> Future's a monad. what would FutureT look like?
12:35:20 <conal> roconnor: i see.  discrete vs continuous.  Reactive is also discrete.  To get continuous, you can compose Reactive and Fun.
12:35:51 <conal> where Fun is just an optimized representation of functions.  or you could use functions directly
12:36:02 <ehird> ghc is trying to run a compiled haskell tool in its ./configure
12:36:03 <ehird> :-|
12:36:16 <conal> kaol: i don't know.  hadn't thought about it.
12:36:42 <Cale> It's not always trivial to turn monads into monad transformers.
12:36:42 <ehird> how am i meant to ../configure with a bootstrap?
12:36:43 <kaol> me neither, but every time I see a monad I start to think about a monadT
12:36:45 <sebell> ehird: Yes, it does
12:37:05 <ehird> sebell: but that makes no sense
12:38:07 <conal> is there any guiding regularity to monad transformers?
12:38:10 <Cale> ehird: What platform are you trying to bootstrap GHC on?
12:39:01 <ehird> Cale: Well, I'm not, I'm just trying to build it. But to do that I need a ghc. So I downloaded the ghc bootstrap (this is the same route macports takes)
12:39:07 <ehird> So... Yeah. :P
12:39:13 <ehird> (I like building my own stuff, even if it's ghc.)
12:39:15 <Cale> conal: I suppose the two important things are that when applied to the Identity monad, you get back the original (up to isomorphism), and that you always get something which is a monad.
12:39:39 <conal> roconnor: my first reactive behavior system, TBAG, worked that way (composing reactivity with non-reactive time functions), but somehow i hadn't thought to do it for frp before.
12:39:46 <Cale> ehird: If you want my advice, just don't.
12:40:01 <ehird> Cale: I don't want your advice. I've compiled it with macports before but that's an old version
12:40:03 <Cale> ehird: It's a big waste of time unless you're actually going to be hacking on it.
12:40:07 <ehird> So I'm going to do this whether it's happy fun time or not!
12:40:25 <Cale> Why not just grab the binary?
12:40:26 <sebell> ehird: I thought it was a binary GHC that MacPorts installed
12:40:35 <ehird> sebell: I doubt so: it does ./configure and stuffs
12:40:39 <ehird> Also, macports is source only.
12:40:45 <ehird> Cale: Because I like compiling stuff.
12:40:46 <conal> Cale: i wonder if there is or could be a relationship with composition of applicative functors.
12:41:19 <Cale> ehird: I hold you personally responsible for global warming and the eventual heat death of the universe.
12:41:21 <conal> Cale: e.g., every AF is already an AF transformer.
12:41:28 <Cale> :)
12:41:40 <Cale> conal: Yeah, that is interesting.
12:41:43 <roconnor> conal: so is it DataDriven for GUI's and spreadsheets, and FRP for other things?
12:41:58 <ehird> Cale: I use an iMac, I think that was a given anyway
12:42:08 <Cale> conal: With monads, you ordinarily need a distributive law before you can compose monadic functors in a similar way.
12:42:08 <sebell> ehird: Just download the binary from haskell.org, and recompile from source if you want
12:42:39 <conal> roconnor: no.  DataDriven and Reactive are both implementations of FRP.  though i couldn't pull of the purely functional thing in DataDriven.  I fixed that problem as well in Reactive.
12:42:58 <conal> Cale: interesting.  examples?
12:43:01 <ehird> sebell: Well, I do have a binary. The bootstrap binary.
12:43:15 <sebell> ehird: What's the problem then?
12:43:17 <roconnor> conal: is DataDriven is being replaced by Reactive?
12:43:23 <ehird> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-darwin-i386-tiger-bootstrap.tar.bz2
12:43:24 <lambdabot> http://tinyurl.com/2m82gp
12:43:25 <ehird> that one
12:43:31 <ehird> sebell: ./configure is going weird.
12:43:38 <roconnor> distribituive laws for monads are awsome.  I have a whole bunch for my monads.
12:43:43 <conal> roconnor: for me it is.  i don't know if anyone else is using DataDriven.
12:43:44 <sebell> ehird: paste?
12:43:56 <ehird> sebell: OK
12:44:04 <ehird> @hpaste
12:44:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:44:12 <hpaste>  ehird pasted "foo, bar, and quux" at http://hpaste.org/5327
12:44:30 <MyCatVerbs> ehird: you missed baz.
12:44:31 <ehird> hm
12:44:39 <ehird> do i need to give it a binary for --with-ghc
12:44:40 <ehird> MyCatVerbs: :(
12:44:42 <conal> roconnor: and i strongly suspect i'll switch from Reactive to something else that's in the works now.
12:44:51 <ehird> Trying: % ./configure --prefix=/usr/local/ghc --with-ghc
12:44:51 <ehird> =../ghc-bootstrap/bin/ghc
12:44:52 <roconnor> conal: :)
12:45:06 <ehird> Kind of works but not really.
12:45:09 <Cale> conal: Well, if you have monads M and N and something like  distr :: N (M a) -> M (N a)
12:45:10 <roconnor> conal: will you switch from wxHaskell at the same time?
12:45:18 <ehird> @hpaste
12:45:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:45:28 <hpaste>  ehird pasted "baz" at http://hpaste.org/5328
12:45:41 <conal> roconnor: orthogonal
12:45:42 <ehird> hm wait
12:45:44 <ehird> i need an absolute path
12:45:45 <ehird> probably
12:45:56 <Cale> conal: Then in order to make your composition of monads M N, you need to define join :: M (N (M (N a))) -> M (N a)
12:46:06 <roconnor> conal: but surely a convienent time. :)  But perhaps you are satisifed with wxHaskell.
12:46:09 <ehird> d'aww, almost
12:46:10 <Cale> You can use fmap distr to swap the middle N M around
12:46:15 <ehird>     Could not find module `System.Environment':
12:46:19 <ehird> when compiling pwd.hs
12:46:19 <ehird> :(
12:46:31 <Cale> and then fmap join . join
12:46:41 <MyCatVerbs> ehird: :)
12:46:50 <Cale> *Main Control.Monad> :t fmap join . join . fmap distr
12:46:50 <Cale> fmap join . join . fmap distr :: forall a. M (N (M (N a))) -> M (N a)
12:46:52 <ehird> MyCatVerbs: no. :(
12:46:58 <conal> roconnor: i'm waiting to hear that (a) gtk2hs works well and install easily on linux, osx, and windows, and (b) someone experienced with gtk2hs wants to collaborate on a port.
12:47:18 <Cale> Of course, to satisfy the monad laws, there are some laws that distributive law has to satisfy.
12:47:28 <roconnor> conal: wxHaskell it is then. :P
12:47:40 <Cale> I'm not sure what the connection is between this approach and monad transformers though.
12:47:52 <ehird> conal: gtk will never work well on os x
12:48:05 <ehird> even the experimental, highly buggy quartz port will not use the native interface in any form
12:48:13 <conal> Cale: neat.  that makes so much sense.  i didn't know about the distr step.
12:48:18 <roconnor> Cale: yeah, distr seems to depend alot on both monads.
12:48:21 <dcoutts> conal: (a) is pretty much true
12:48:41 <conal> dcoutts: you disagree with ehird?
12:48:55 <conal> ehird: why not on osx?
12:49:03 <ehird> conal: 'because'.
12:49:06 <ehird> conal: it just doesn't
12:49:11 <ehird> it isn't designed for non-x11
12:49:16 <dcoutts> conal: oh, it works, it's just ugly at the moment. That can change with using a native looking theme.
12:49:17 <ehird> it working on windows at all is suprising.
12:49:23 <ehird> but that's because windows is so popular.
12:49:27 <conal> ehird: "doesn't", i understand.  "never" puzzles me.
12:49:29 <ehird> and it'd be a LOT harder to integrate with os x
12:49:36 <ehird> conal: ok, is unlikely to ever
12:49:43 <ehird> dcoutts: native looking themes are not acceptable
12:49:50 <ehird> they never work anything like the real thing, and are often really ugly
12:50:01 <conal> ehird: combo of effort and lack of interest?
12:50:10 <ehird> conal: Pretty much.
12:50:21 <ehird> And the fact that gtk 'doesn't think' like OS X internally.
12:50:26 <dcoutts> ehird: seems to work for win32, where there is no such thing as a native theme, every app does things slightly differently, eg notepad, word, ie, visual studio
12:50:30 <ehird> whereas its X11 model is good enough for windows, with some tweaks
12:50:43 <ehird> dcoutts: Yeah well, mac users tend to have higher standards than windows ones.
12:51:26 <roconnor> in any case we will just put both a wxHaskell and gtk2hs backend on conal's work.
12:51:45 <ehird> wxHaskell will use gtk on linux
12:51:46 <ehird> so :p
12:52:20 <conal> is there another promising route besides gtk and wx?
12:52:34 <conal> for solid cross-platform
12:53:21 <ehird> qt
12:53:25 <ehird> but..gpl3.
12:53:37 <dcoutts> conal: sadly it seems to be a genuinely hard problem, everyone wants the programming api + behaviour to be the same between platforms and also to integrate perfectly into the different platforms
12:53:39 <conal> what's glp3?
12:53:43 <conal> (gpl3)
12:53:48 <ehird> conal: a horrid license.
12:53:51 <Zao> conal: Pure evil.
12:53:59 <ehird> even more so than gpl2
12:54:09 <dcoutts> conal: it's a perfectly reasonable license, it's the GNU GPL, version 3
12:54:16 <ehird> dcoutts: die die die
12:54:16 <conal> let me rephrase: what's the content of glp3, rather than opinions/evaluations about it.
12:54:16 <ehird> ;)
12:54:23 <ehird> conal: glp!
12:54:28 <dcoutts> conal: but it arouses high passions as you can see :-)
12:54:38 <shag> how do i convert a strict ByteString into a lazy ByteString?
12:55:11 <dcoutts> conal: it's really the same spirit as GPL v2, it's quite a readable document. It's basically about contributing changes back to the community.
12:55:16 <Cale> shag: fromChunks, possibly
12:55:29 <dcoutts> shag: fromChunks [theChunk]
12:55:41 <shag> thanks
12:55:48 <conal> what do folks dislike about it?  what are they losing that they want to keep?
12:56:00 <ehird> can I have modules: A, A.B, A.C, ...?
12:56:08 <ehird> and if so, is this the correct structure:
12:56:13 <ehird> A.hs, A/B.hs, A/C.hs, ...
12:56:29 <Cale> conal: It has a bunch of controversial stuff in it regarding DRM.
12:56:29 <dcoutts> conal: if I license my code under the GPL and you use it, then you cannot make your code proprietary, you would have to share the source code to your program with anyone you give your program to
12:56:30 <conal> (looking for a rational answer rather than a religious one)
12:56:32 <Zao> conal: The freedom to not have to reveal all code that touches it.
12:56:49 <Cale> (at least, relative to v2)
12:56:50 <conal> oh.  thanks.
12:57:18 <dcoutts> conal: by contrast, if I use a BSD style licenses then you can use that in a proprietary program
12:57:22 <Cale> Personally, I just usually go with BSD.
12:57:48 <Cale> I'd release my code into the public domain, except then I don't get the nice disclaimer of warranty.
12:57:50 <conal> how is Quote, relative to the cross platform issues?
12:57:54 <oerjan> ehird: yep
12:58:14 <ehird> yay
12:58:21 <ehird> no more A.Core modules
12:58:21 <dcoutts> conal: for example the Linux kernel is GPL v2, so companies that sell products based on Linux have to supply their customers with the source code (or at least a promise to do so)
12:58:22 <Cale> (but I don't release a whole lot of code)
12:59:02 <Cale> ehird: A.Core?
12:59:10 <dons> gwern: $ darcs get http://code.haskell.org/frag
12:59:11 <lambdabot> Title: Index of /frag
12:59:11 <dons> :)
12:59:14 <Cale> oh, I see
12:59:25 <dons> i had to kill the darcs history though, since it was getting kinda unusable
12:59:41 <ehird> Cale: yeah
13:00:08 <jedbrown> conal: But with GPL v2, they don't have to make the machine capable of running your code (like TiVo does).  GPLv3 says that they must.
13:00:26 * Cale wonders why reactive's documentation isn't linked directly from hackage.
13:00:32 <dcoutts> conal: so Qt is a good cross platform gui lib, it's written in C++ which makes it a tad harder to bind in Haskell. The license objection some people have is that they cannot use it to make proprietary applications (at least not without buying a special license).
13:00:38 <Cale> (and various other packages)
13:00:51 <conal> Cale: probably because hackage is still running the old haddock
13:00:56 <Cale> ah, okay
13:01:07 <ehird> dcoutts: uh
13:01:08 <ehird> more like
13:01:13 <ehird> we can't release our apps under the MIT license
13:01:14 <ehird> or BSD3
13:01:17 <dcoutts> conal: oh yes, Ross was having problems with the new haddock, it falls over on some things.
13:01:19 <ehird> or anythiing apart from GPL, when we use Qt
13:01:22 <ehird> and that is *fscked*
13:01:51 <jedbrown> Should bindings have to have the same license as the library?
13:01:54 <dcoutts> ehird: you can release your app under BSD/MIT, but you still have to abide by the terms of Qt's license.
13:02:15 <dcoutts> jedbrown: it's not essential but it's the simplest thing to do
13:03:34 <conal> dcoutts: would it be problematic to put BSD3 or whatever on Qt bindings?
13:03:36 <jedbrown> For instance, if I write bindings to a GPL library and my bindings are GPL, then if somebody buys a different license for the library but still uses my bindings, then they are bound by the GPL.
13:03:48 <miasma> ehird: http://trolltech.com/products/qt/gplexception
13:03:48 <lambdabot> Title: Trolltech GPL Exception version 1.0 &mdash; Trolltech
13:04:05 <jedbrown> But if I release the bindings under BSD, then it doesn't impose an additional layer of restrictions.
13:04:10 <dcoutts> conal: not at all, but it doesn't change much. Users of that binding would still be bound by Qt's license.
13:04:29 <conal> dcoutts: why bound?
13:04:33 <dons> has anyone tried the qtHaskell bindings btw?
13:04:42 <[Miko]> hi @ all
13:04:50 <jedbrown> conal: Because they use the library which is GPL.
13:04:58 <bos> conal: because they'd still be linking with Qt
13:05:04 <dmwit> Hiya, [Miko]!
13:05:05 <dcoutts> conal: because it'd be using it, it'd still be a derived work, so it must follow the license.
13:05:08 <jedbrown> conal: Unless they buy a different license for Qt.
13:05:10 <conal> so linking is enough?
13:05:18 <conal> wow :(
13:05:21 <dcoutts> yes
13:05:22 <bos> conal: by BSD-licensing your bindings, you'd be enabling people to use your bindings if they had a commercial Qt license.
13:05:27 <bos> which is nice.
13:05:32 <Philippa> that's exactly why the LGPL exists
13:05:49 <bos> of course Trolltech's use of the GPL is deliberate.
13:06:07 <[Miko]> i have a problem, i want to learn haskell and have much tutorials to read. But no tutorial really explains how to make a programm with the declarations and definitions. I even dont know how i can use hugs with variables. Can anyone give me a very short introduction?
13:06:38 <[Miko]> *none
13:06:44 <cjb> [Miko]: I'm sure there are much better examples, but here's a set of working programs:  http://stuff.mit.edu/iap/haskell/example.hs
13:06:47 <dmwit> [Miko]: Stick 'em in a file with a .hs extension, then load it in GHCi or Hugs.
13:07:17 <dmwit> [Miko]: I think :load is the fairly universal way to load things into a Haskell interpreter.
13:07:19 <dcoutts> conal: the standard interpretation (which is by no means uncontroversial) is that linking/importing implies a derived work in copyright law
13:07:22 <dons> [Miko]: and perhaps install ghc instead. (its a compiler, and the programs are much much faster than with hugs)
13:07:38 <dons> [Miko]: a basic introduction, http://haskell.org/haskellwiki/Haskell_in_5_steps
13:07:45 <wagle_> :t :load
13:07:46 <[Miko]> dons i have both, hugs and ghc. But a friend told me its easier to begin with the live interpreter of hugs
13:07:47 <lambdabot> parse error on input `:'
13:07:58 <wagle_> 8(
13:08:18 <dmwit> wagle_: It isn't a Haskell function...
13:08:23 <sarah__> can you do something like: case x of {((Just _) || x:xs) -> 2;_ -> 4}
13:08:26 <[Miko]> thx much dons, i doesnt knew the tutorial yet
13:08:26 <dons> [Miko]: ghci is just as easy, and has better error messages
13:08:37 <sarah__> if you have a lot of patterns that produce the same result
13:08:39 <dons> type 'ghci' to start it, and follow that tutorial :)
13:08:42 <bos> sarah__: no
13:08:42 <wagle_> dmwit, why not?  8)
13:08:45 <[Miko]> dmwit all declarations have to be in a .hs file?
13:08:47 <dmwit> sarah__: Those are two different types!
13:09:03 <bos> even if they had the same type, you couldn't.
13:09:09 <dmwit> sarah__: But no, there is no way to combine them.
13:09:11 <[Miko]> dons k, thx i will try ghci instead of hugs
13:09:22 <dmwit> [Miko]: Well, it's a convenient simplification for now.
13:10:21 <nominolo> ghci's error messages are nice than hugs's?
13:10:37 <dons> they've had 10 years more work.
13:10:41 <stepcut> (a bit late in the game here, but), my understanding is that you can not copyright APIs. Therefore, you are free to make bindings to Qt, etc, with whatever license you want -- since someone *could* write a Qt clone, and your bindings would still work fine. However, if you actually make a binary that links against (the real) Qt, then you are subject to those licenses as well
13:10:41 <[Miko]> dmwit thx, first i have to work on a very simple layer. live interpreter normally best for starting learning a language
13:10:51 <dmwit> According to the social network diagram, I only speak to people with weird characters in their names. =P
13:10:52 <jedbrown> Maybe the message "use ghc unless you can't install it on your hardware" should be more prominant.
13:11:14 <dmwit> [Miko]: Right, one thing at a time.
13:11:43 <[Miko]> cant i do my declarations live in the interpreter?
13:11:48 <[Miko]> its much more comfortable
13:11:54 <dons> let x = 1
13:11:55 <dmwit> [Miko]: Okay, use "let" then.
13:11:57 <dons> works fine in ghci.
13:12:03 <[Miko]> dmwit, what is let?
13:12:06 <dmwit> let f x = x + 1
13:12:10 * nominolo no longer is part of the haskell community
13:12:14 <dons> nominolo: oh?
13:12:23 <ehird> Am I still the center of the network?
13:12:24 <Alberto> hi, do you know something about a new version of hs-plugins that works in GHC-Windows-mingw?
13:12:33 <nominolo> it says so on the social network graph ...
13:12:41 <nominolo> dons: so it must be true
13:12:45 <dons> nominolo: where's the graph?
13:12:48 <dmwit> nominolo: Yes, connections seem to have a half-life.
13:12:50 <ehird> nominolo: I'll help. I'm close to the center.
13:12:52 <ehird> dons: In the topic
13:12:53 <Philippa> ah. And here was me thinking the MLers got you
13:12:55 <dcoutts> stepcut: I'm not sure that api thing is so clear cut
13:12:58 <ehird> nominolo: nominolo nominolo nominolo nominolo nominolo nominolo.
13:13:01 <Cale> [Miko]: In this case, it's just special syntax for ghci. GHCi tries to roughly simulate the inside of a do-block (but anything not in the IO monad will be wrapped in a call to 'print')
13:13:05 <ehird> there
13:13:08 <ehird> you're near the center now
13:13:08 <nominolo> dons: http://files.codersbase.com/haskell/haskell-current.png
13:13:15 <dmwit> ehird: It only takes the first mentioned name into account. =P
13:13:17 <ehird> nominolo: refresh ;P
13:13:19 <nominolo> dons: ok, now i'm back in :)
13:13:22 <ehird> dmwit: Does it? Oh well, it was enough.
13:13:23 <bos> nominolo: we can fix that for you
13:13:26 <ehird> nominolo:
13:13:32 <dons> curious
13:13:34 <dcoutts> stepcut: sure, for published specs that are capable of multiple implementations, but for things that are single implementation it's much less clear
13:13:44 <Cale> [Miko]: In general, "let ... in ..." is an expression form which allows you to make some declarations which are local to an expression.
13:13:45 <dons> nominolo: oh, this is based on who people address?
13:13:48 <ehird> I think what the graph shows about me is that I talk far too much
13:13:50 <[Miko]> Cale, thx okay i note it
13:13:52 <nominolo> dons: yep
13:13:54 <Cale> > let x = 5; y = 7 in x^2 + y^2
13:13:57 <lambdabot>  74
13:14:02 <nominolo> even works at the end of sentences, dons
13:14:09 <dmwit> dons: There are also some heuristics for non-addressed messages, but mostly yes.
13:14:11 <dons> can we feed it the full logs??
13:14:12 <yav> dons: you are very popular!
13:14:21 <nominolo> dons: that'd be nice, yep
13:14:23 <dons> i've got the whole 6 years of logs availavle...
13:14:41 <dmwit> But it's time-varying, so that doesn't make a lot of sense...
13:14:48 <dons> fingers in many pies, yav
13:14:48 <yav> should be interesting to see ppl float in and out of the community :-)
13:14:48 <Alberto> Dons: people told me about a new version of hs-plugins that works in GHC-windows. Is it true?
13:14:52 <nominolo> dmwit: we could make a movie
13:14:59 <dons> hm. Alberto not that I know of..
13:15:06 <dmwit> nominolo: Heh, interesting idea!
13:15:12 <[Miko]> dons, thx for tutorial, it seemed to be the first good one for beginners of functional programming
13:15:33 <stepcut> dcoutts: I tend to opt for the most liberal interpretation. After all, the upstream might change their license to be more 'open'  in the future (for example, Qt has gotten more open over the years).
13:15:37 <Philippa> it's not too smart, anyway - it'll only catch when someone explicitly addresses someone else
13:15:57 <unenough> unenough, hi.
13:16:09 <nominolo> Philippa: i think anything else is AI-complete
13:16:10 <dons> who's maintaining this graphy thing?
13:16:22 <dmwit> Philippa: Last night it also noticed the pattern A-B-A, with no addresses.
13:16:32 <dons> here's the full logs to feed it: http://www.cse.unsw.edu.au/~dons/irc/haskell/
13:16:34 <lambdabot> Title: Index of /~dons/irc/haskell
13:16:36 <Philippa> nominolo: you can make a degree of guesses based on proximity, quotation and the like
13:16:46 <dmwit> So I became linked to lambdabot despite neither of us saying the other's name.
13:16:47 <Alberto> Dons:thanks. By the way, in GHC 6.8 Linux, Eval inside a dynamically loaded module does not work: it report "duplicate symbols"
13:16:58 <dons> yeah, that makes sense.
13:17:11 <dcoutts> nominolo: note that kolmodin has bounced cabal bug #155 back to you :-)
13:17:23 <nominolo> Philippa: hm, yes we can certainly come up with something better
13:17:38 <nominolo> dcoutts: that number ain't say me no nothing
13:17:38 <Alberto> bug? limitation?
13:17:48 <dcoutts> nominolo: http://hackage.haskell.org/trac/hackage/ticket/155
13:17:49 <lambdabot> Title: #155 (show . readPackageDescription /= id) - Hackage - Trac
13:18:13 <unenough> Eval(<$,,df.a|421`r_$. <<...__445 . >> eval(ms) Eval(asdffkg)). maybe this will someday raise an error in some script that processes the logs.
13:18:35 <nominolo> dcoutts: ok.  i take a look
13:18:38 <nominolo> tomorrow
13:18:42 <dcoutts> nominolo: oh, also, there was a quick fix you put into the cabal-1.2.x branch where you wanted to do it properly for cabal HEAD, could you file a bug for that so we don't forget? milestone 1.4 probably
13:18:55 <dcoutts> to do with section headers or something
13:18:56 <dons> lispy: do you want to feed it the full logs?
13:19:06 <dons> and then just update daily? i think this is a great tool :)
13:19:29 <nominolo> dcoutts: i think i need to clean up that whole PD file anyways
13:19:38 <dcoutts> nominolo: aye, ho hum.
13:19:44 <nominolo> dcoutts: i'll take a look
13:20:01 <dmwit> unenough: What language would that damage?
13:20:09 <dcoutts> nominolo: yeah, for 2.0 (not 1.4) we should rearrange the package description / generic package description split
13:20:19 <unenough> dmwit, probably none.
13:20:50 <dmwit> Oh, just random tokens, then? =P
13:20:50 <nominolo> dcoutts: do we have a branch for 1.4 already?
13:20:56 <dcoutts> nominolo: it made perfect sense originally to be least disruptive, but eventually it needs to be rationalised
13:21:13 <dcoutts> nominolo: no but HEAD is currently aiming for a 1.4 release
13:21:30 <nominolo> dcoutts: yep, especially if we break the hooks interface (finally)
13:21:31 <dcoutts> nominolo: so we're trying to keep compatibility with existing Setup.hs scripts
13:21:45 <dcoutts> nominolo: when we need to make real breaks we'll have to branch 1.4
13:22:22 <dcoutts> nominolo: for release plans, see http://hackage.haskell.org/trac/hackage/roadmap
13:22:25 <lambdabot> Title: Roadmap - Hackage - Trac
13:22:50 <nominolo> dcoutts: what do you think of introducing a Pretty class?  All those readFoo showFoo functions are ugly
13:23:04 <dcoutts> nominolo: aye, they are rather
13:23:30 <dcoutts> nominolo: it's not the most pressing refactoring though :-)
13:23:38 * gbacon needs to work 'aye' into his everyday conversation
13:23:44 <nominolo> yoah
13:23:45 <dcoutts> not like, making cabal use proper monads for various things
13:23:55 <nominolo> gbacon: arr!!
13:24:01 <litb> hm, are there other preludes ?
13:24:07 <nominolo> @arr!!
13:24:07 <lambdabot> Har de har har!
13:24:12 <Valodim> there is "the" other prelude
13:24:17 * dcoutts says 'aye' and 'arr' quite a bit in rl as several people here can attest
13:24:26 <litb> i mean alternative preludes where we have Ring Group AddGroup Monoid and so on?
13:24:29 <nominolo> litb: there is "FakePrelude" in HList
13:24:47 <gbacon> 'twould be a bit out of place in the southern U.S. :-)
13:25:05 <dcoutts> aye, that it might
13:25:09 <gbacon> aye
13:25:22 <gbacon> actually....
13:25:27 <dcoutts> arr, well I be off home now...
13:25:44 <gbacon> I remember learning a 19th-century song about Alabama with aye in it..
13:25:44 <nominolo> dcoutts: Ahoy!
13:25:55 <gbacon> something like "Alabama, Alabama, we will aye be true to thee"
13:26:26 <dcoutts> gbacon: but that's 'aye' as in me, myself. I mean 'aye' as in 'yes'
13:26:29 * nominolo only knows "Sweet Home Alabama ..."
13:26:39 <gbacon> the official state song, no less! http://www.50states.com/songs/alabama.htm
13:26:39 <lambdabot> Title: Alabama State Song
13:26:43 <nominolo> aye aye cap'n
13:26:49 <dcoutts> @arr!
13:26:49 <lambdabot> Keelhaul the swabs!
13:26:50 <roconnor> > 4*(atan (1/2) + atan (1/3))
13:26:52 <lambdabot>  3.141592653589793
13:26:57 <gbacon> nominolo: the skies are kind of gray today :-/
13:27:18 <unenough> dmwit if that doesn't maybe this will do damage: lØ§Ø¨aadsaalBnÐ‘Ð°Ð¸aeDktEiÎ·Î¬aErokÙÛŒnse×‘HtIií•œivarenæœ¬o k)o nkoitÃªmÐ ÐºlnavÄÐ¡Ðº suSsà¸—rÐ£Ñ—Ðºáº¿Vá»‡ä¸­
13:27:33 <gwern> dons: so you moved frag's repo?
13:27:38 <gwern> hm. there's only the one patch?
13:27:40 <lucca> damage?
13:27:50 <litb> nominolo: is FakePrelude better?
13:28:03 <gbacon> dcoutts: that's reflective usage?
13:28:06 <dons> gwern: i couldn't get darcs to process the huge patch history
13:28:14 <gwern> well, from a GPL standpoint, that's less than ideal, as history isn't very clear, but I suppose if the patches were too unwieldy...
13:28:16 <gbacon> something like "we will ourselves be true to thee"?
13:28:21 <nominolo> litb: no, it's for HList (heterogenous) lists only
13:28:35 <gwern> dons: what, darcs can be slow on big inputs? WHY DID NO ONE TELL ME THIS? :)
13:28:37 <litb> oh, i see :/
13:28:38 <bringert> hmm, maybe it's time for another IOHCC
13:28:59 <gwern> dons: so, what changes did you make?
13:29:00 <litb> well, is it right that haskell automatically converts from double if a type belongs to class Number and implemented fromDouble ?
13:29:16 <dons> gwern: none.
13:29:18 <mauke> haskell never automatically converts
13:29:34 <nominolo> litb: no
13:29:36 <sclv_> ?go Haskell NumericPrelude
13:29:41 <lambdabot> http://vandreev.wordpress.com/2006/12/04/non-standard-analysis-and-automatic-differentiation/
13:29:42 <lambdabot> Title: Non-standard analysis, automatic differentiation, Haskell, and other stories. «  ...
13:29:51 <nominolo> litb: only 1 is short for fromInteger 1
13:29:52 <litb> nominolo: i took that from this:
13:30:02 <litb> http://users.info.unicaen.fr/~karczma/arpap/diffalg.pdf
13:30:03 <bringert> well, haskell doesn't convert automatically, but you may think it does sometimes, e.g. with overloaded literals
13:30:12 <Cale> litb: You can have numbers which are polymorphic, in which case they'll eventually end up as some particular type which isn't specified yet, but there's no automatic conversion.
13:30:45 <Cale> litb: When you write something like 5 in your source file, it actually means fromInteger (5 :: Integer)
13:30:47 <litb> it says that foo 1.0 , with foo :: Funktion -> someThing , with Funktion in class Number implementing fromDouble will work
13:31:00 <Cale> (where the (5 :: Integer) is my notation for a "real" integer 5)
13:31:20 <litb> oh
13:31:25 <litb> is the same true for double?
13:31:32 <mauke> :t 1.0
13:31:33 <lambdabot> forall t. (Fractional t) => t
13:31:58 <mauke> > (1.0, 1.0, 1.0) :: (Float, Double, Rational)
13:31:58 <lambdabot>  (1.0,1.0,1%1)
13:31:59 <Cale> With floating point constants, they're treated as rational values and fromRational is applied.
13:32:01 <litb> it says that on page 9
13:32:09 <Cale> :t fromRational
13:32:09 <lambdabot> forall a. (Fractional a) => Rational -> a
13:32:22 <litb> strange that PDF must be wrong then
13:33:14 <Cale> At the top level of the module, after the rest of typechecking completes, if there are ambiguous numeric types which don't rely on non-prelude classes, they'll be defaulted to Integer, or Double, whichever works first.
13:33:33 <Cale> You can change the list of default numeric types to try using a 'default' declaration.
13:36:39 <litb> ah i see
13:39:11 <ehird> @hpaste
13:39:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:39:17 <hpaste>  ehird pasted "foo" at http://hpaste.org/5330
13:39:31 <ehird> the bootstrap is the 6.6 binary bootstrap for OS X Tiger, from the ghc /dist
13:39:36 <ehird> why does that error happen?
13:39:45 <ehird> does the bootstrap not include that lib? that seems rathe ruseless
13:42:40 <Cale> Then again, so does compiling GHC when there are binaries you could download.
13:42:45 <Cale> ;)
13:43:26 <Cale> You might have better luck compiling 6.8.2 with 6.8.2.
13:44:20 <ehird> Cale: Possibly. but I don't want to download a huge binary
13:44:38 <ehird> 6.6.1 was able to be bootstrapped with this, and i imagine it has pwd.hs too
13:44:39 <Cale> It'd surely be faster than compiling GHC.
13:45:02 <phobes> Is the module level defaulting just a performance thing?
13:45:08 <ehird> Cale: Bah.
13:45:09 <ehird> ;)
13:45:29 <Cale> phobes: It's more of a convenience thing.
13:46:12 <phobes> Cale:  I don't get it - example?
13:46:17 <Cale> phobes: So you don't end up being forced to explicitly provide type signatures all over the place when you just want to use Integer or Double.
13:46:40 <Cale> Well, because of the way numeric literals are interpreted, the types are inherently ambiguous to start with.
13:46:50 <Cale> So if you were to write the program:
13:46:53 <Cale> main = print 5
13:46:56 <Cale> That wouldn't work.
13:47:03 <phobes> ya
13:47:10 <Cale> Because it wouldn't know which type of 5 in order to know which Show instance to use.
13:47:20 <oerjan> that defaulting is not really module-level though
13:47:26 <phobes> But why not do the defaulting at the very end?
13:47:28 <phobes> Post-link
13:47:40 <Cale> Module level is sort of the very end.
13:48:22 <ehird> damn, i even fixed package.conf
13:48:25 <ehird> still no System.Environment
13:48:47 <Cale> It has to know at compile time.
13:48:48 <ehird> yet System.Environment is right there.
13:48:48 <phobes> Cale:  Because of the separate compilation model, you men?
13:48:51 <Cale> yeah
13:49:00 <ehird> Cale: Well, it's being given all the right paths to know.
13:49:05 <phobes> Cale: Ya, I figured that was the issue
13:49:06 <newsham> whoa!  progress on amd64!  horray!
13:49:21 <ehird> AHA
13:49:22 <ehird> importDirs = [],
13:49:24 <ehird> is that wrong?
13:49:29 <Cale> I don't know :)
13:49:32 <ehird> :|
13:50:22 <phobes> Cale:  I think that's a performance issue.  You could export each of those functions polymorphically, and then 'main' could instantiate them with whatever it needed
13:50:22 <sebell> *sigh*
13:50:32 <Cale> phobes: and you can.
13:50:34 <phobes> Cale: But that would probably be dog-slow too much
13:50:34 <bos> @seen CosmicRay
13:50:34 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
13:50:39 <phobes> Cale:  For that to be the default
13:50:57 <Cale> phobes: The problem more has to do with things like:
13:51:00 <Cale> x :: Bool
13:51:02 <CosmicRay> hi bos
13:51:03 <Cale> x = 5 > 7
13:51:09 <bos> oh, you're here!
13:51:15 <Cale> (that's a dumb example, but perhaps you get the idea)
13:51:42 <vincenz_> @seen Saizan
13:51:42 <Cale> There's no type variable there in order to provide an instance later, so you need defaulting to disambiguate.
13:51:42 <lambdabot> Saizan is in #haskell-blah, #haskell-overflow and #haskell. I last heard Saizan speak 1h 26m 2s ago.
13:52:08 <bos> CosmicRay: i just wanted to have a quick chat about database bindings for the book.
13:52:10 <phobes> Cale:   Right, but there's no good reason to decide how to disambiguate that at the module level
13:52:17 <ehird> sorry about that
13:52:21 <oerjan> Cale: that is _not_ module-level defaulting.  those types never reach the module top level at all
13:52:31 <bos> CosmicRay: what if we were to cover HDBC, and show how to apply the Takusen-style fold API on top of it?
13:52:43 <Cale> oerjan: But they're defaulted only after typing the rest of the module, no?
13:53:09 <phobes> Cale:  You should either do it right away (as soon as the type variable is leaving the signature) or you have the whole thing parameterized by a hidden "Bool" module and defer it to final instantiation (main)
13:53:23 <bos> CosmicRay: that way, we'd get something nice and general in terms of showing a traditional API with a more functional layer on top, without consuming much extra space.
13:53:25 <oerjan> Cale: i don't think there is any technical reason why
13:53:36 <vincenz_> Saizan: ci sei?
13:53:59 <phobes> Cale:  "Should" meaning I think those are the cleanest approaches.   The reason not to take those approaches is, I think, performance related
13:54:17 <Cale> I think it's just convenience personally.
13:54:17 <CosmicRay> bos: that sounds interesting.  I know almost nothing about Takusen though, so I may not be the right person to do it
13:54:35 <bos> CosmicRay: the only aspect of it that's interesting is that API detail.
13:55:01 <Cale> The way it presently works is usually what you want.
13:55:04 <Time`s_Witness> where can i check how foldl and foldr are .. the code i mean? I'd like to check them :)
13:55:11 <phobes> Cale:  ok well I have a clearer picture of what's going on now - thanks :)
13:55:12 <Cale> foldl f z [] = z
13:55:14 <CosmicRay> bos: I can't seem to find an API ref to Takusen
13:55:20 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
13:55:27 <Cale> foldr f z [] = z
13:55:34 <bos> CosmicRay: http://darcs.haskell.org/takusen/doc/html/
13:55:40 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
13:55:56 <Time`s_Witness> thanks Cale
13:56:08 <Cale> Time`s_Witness: I have some diagrams of the expressions they produce.
13:56:14 <Saizan> vincenz_: sÃ¬, per poco (how much italian do you know?:)
13:56:15 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
13:56:16 <bos> CosmicRay: you can get the details of the fold by looking at, er, chapter 8?
13:56:18 <vincenz_> Saizan: a lot
13:56:22 <lambdabot> Title: Fold Diagrams - CaleWiki
13:56:26 <vincenz_> Saizan: can I post a corrected version of your code?
13:56:30 <vincenz_> Saizan: with some additions
13:56:34 <oerjan> Time`s_Witness: Cale is actually showing you the haskell report definition.  ghc uses an uglier one for performance.
13:56:41 <oerjan> @src foldl
13:56:42 <lambdabot> foldl f z xs = lgo z xs
13:56:42 <lambdabot>     where lgo z []     =  z
13:56:42 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:56:42 <CosmicRay> bos: you cover Takusen already?
13:56:46 <bos> CosmicRay: sorry, chapter 10.
13:56:54 <bos> CosmicRay: no, i introduce the same fold in a different context.
13:56:58 <Cale> oerjan: Hopefully gone in the next version of GHC, so kind of pointless to bring it up :)
13:57:06 <bos> CosmicRay: i use it for iterating through the filesystem.
13:57:20 <CosmicRay> bos: oh ok.  well let me read chapter 10 then
13:57:21 <oerjan> Time`s_Witness: if it hadn't been for that, Cale would probably have used the @src command too
13:57:22 <Time`s_Witness> yea, oerjan.. i dont need to see the one in prelude.. just trying to figure out how both work.. more to check the difference in fact.. and Thanks again Cale, i'll check diagrams :P that should help!
13:57:28 <CosmicRay> I need to read what you've written anyhow
13:57:29 <Saizan> vincenz_: yes, go ahead :), i @tell-ed to vincenz btw
13:57:30 <vincenz_> Saizan: parlo italiano come un italiano
13:57:33 <vincenz_> odd
13:57:34 <vincenz_> @messages
13:57:34 <lambdabot> You don't have any new messages.
13:57:42 <bos> CosmicRay: okey doke
13:57:54 <dons> dcoutts: does cabal install use -O by default?
13:58:28 <Cale> Time`s_Witness: A really great way to look at functional programming is that expressions are graphs, and evaluation consists of repeatedly transforming those graphs.
13:58:51 <bos> Cale: you left out the spacesuits and the apples.
13:59:01 <Cale> Time`s_Witness: foldr f z is the function which replaces each cons (:) in a list with the function f, and replaces the [] at the end with z
13:59:01 <Saizan> vincenz_: beh immagino che la "_" faccia la differenza..
13:59:07 <Cale> bos: what?
13:59:14 <oerjan> Time`s_Witness: another place to get to sources is from the source links in the hierarchical module documentation:
13:59:17 <oerjan> @where docs
13:59:17 <lambdabot> I know nothing about docs.
13:59:18 <bos> Cale: you know, from the monad tutorials?
13:59:20 <oerjan> @docs
13:59:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:59:41 <Cale> http://haskell.org/onlinereport/standard-prelude.html
13:59:46 <vincenz_> giusto
13:59:51 <vincenz> @messages
13:59:52 <lambdabot> Saizan said 6h 44m 25s ago: not at all, go ahead :)
13:59:53 <vincenz> no wonder
13:59:58 <oerjan> @where sources
13:59:58 <lambdabot> I know nothing about sources.
14:00:01 <Cale> (there's the report prelude, and it's a lot clearer to read than the GHC sources for what it covers)
14:00:16 <vincenz> pensavo che lambdabot era crashed
14:01:04 <ehird> sooooo
14:01:08 <oerjan> @where+ sources H98 report: http://haskell.org/onlinereport/ Hierarchical libraries: http://haskell.org/ghc/docs/latest/html/libraries/index.html lambdabot: the @src command
14:01:08 <lambdabot> It is forever etched in my memory.
14:01:14 <ehird> who has compiled ghc with the 6.6 bootstrap :P
14:01:29 <Time`s_Witness> lol
14:01:43 <oerjan> @where source
14:01:43 <lambdabot> I know nothing about source.
14:01:49 <oerjan> @where+ source H98 report: http://haskell.org/onlinereport/ Hierarchical libraries: http://haskell.org/ghc/docs/latest/html/libraries/index.html lambdabot: the @src command
14:01:50 <lambdabot> Done.
14:02:13 <Time`s_Witness> cant handle so much info at once... saved links, going to read :P
14:02:40 <Cale> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
14:02:42 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
14:02:47 <Cale> > foldl (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
14:02:48 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
14:03:02 <ehird> cute
14:03:43 <ehird> hm
14:03:49 <Cale> Note that in each case, the elements of the list stay in the same left to right order. Some other languages get this wrong :)
14:03:51 <ehird> given a function, can i get either: 1. its name 2. its lambda definition?
14:04:05 <Cale> ehird: No.
14:04:09 <ehird> d'aww
14:04:16 <Cale> ehird: The only thing you can do is to apply it.
14:04:20 <ehird> i was going to make (showFoldl/r f lst)
14:04:21 <Time`s_Witness> that is clearer than ..water.. Thanks Cale :D
14:04:26 <ac> > let f = (+); z = 0 in (f (f (f (f (f z 1) 2) 3) 4) 5)
14:04:27 <ehird> :(
14:04:27 <lambdabot>  15
14:04:36 <wagle_> can you do it in template haskell?
14:04:50 <ehird> wagle_: doesn't really help for lambdabot
14:05:39 <oerjan> @source Data.Map
14:05:39 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
14:06:01 <sclv_> ehird: you can also show its type signature if you import, i think its Data.Function
14:06:20 <sclv_> > map
14:06:21 <lambdabot>  Add a type signature
14:06:27 <oerjan> @where+ source H98 report: http://haskell.org/onlinereport/ Hierarchical libraries: http://haskell.org/ghc/docs/latest/html/libraries/index.html lambdabot: @src and @source (currently somewhat broken)
14:06:27 <lambdabot> Done.
14:06:32 <oerjan> @where+ sources H98 report: http://haskell.org/onlinereport/ Hierarchical libraries: http://haskell.org/ghc/docs/latest/html/libraries/index.html lambdabot: @src and @source (currently somewhat broken)
14:06:32 <lambdabot> Done.
14:06:42 <sclv_> > (+1)
14:06:43 <lambdabot>  <Integer -> Integer>
14:07:01 <ehird> > locOf $ tutorialFor TemplateHaskell
14:07:02 <lambdabot>   Not in scope: data constructor `TemplateHaskell'
14:07:06 <dmwit> ehird: No problem, just create a Show instance for functions. ;-)
14:07:28 <oerjan> sclv_: Data.Typeable i think
14:07:30 <ac> Cale: that's a really cool way to explain fold. I've seen the expansions before (of course), but not defined in terms of foldl and foldr
14:07:41 <Cale> :)
14:07:51 <Cale> > scanr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
14:07:52 <lambdabot>  ["(f 1 (f 2 (f 3 (f 4 (f 5 z)))))","(f 2 (f 3 (f 4 (f 5 z))))","(f 3 (f 4 (f...
14:07:52 <oerjan> and it must be monomorphic
14:07:56 <Cale> > scanl (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
14:07:57 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)","(f (f (f (f z 1) 2) 3)...
14:08:09 <ehird> but yeah template haskell tutorial. :P
14:08:49 <sclv_> Text.Show.Functions it turns out to be.
14:08:52 <ac> didn't even know about scanl and scanr
14:10:46 <ac> > scanr (*) 1 [1..10]
14:10:47 <lambdabot>  [3628800,3628800,1814400,604800,151200,30240,5040,720,90,10,1]
14:11:46 <dmwit> backwards =P
14:11:53 <ac> why isn't there a 2 in there?
14:11:56 <dmwit> > scanl1 (*) [1..10]
14:11:57 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
14:12:11 <ac> that's what I expected to see
14:12:18 <dmwit> ac: Because you got it backwards... first it multiplied by ten, then 9, then 8, ...
14:12:52 <ac> ah I see
14:12:54 <dmwit> > scanr1 (*) [10,9..1]
14:12:54 <lambdabot>  [3628800,362880,40320,5040,720,120,24,6,2,1]
14:14:27 <ac> @src scanr1
14:14:27 <lambdabot> scanr1 f []     = []
14:14:27 <lambdabot> scanr1 f [x]    = [x]
14:14:27 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
14:14:28 <dmwit> > let weird xs = scanl1 (flip drop xs) xs in weird [1,1,1]
14:14:28 <lambdabot>  Couldn't match expected type `Int -> Int'
14:15:06 <dmwit> > iterate (drop 1) [1,1,1] -- better anyway
14:15:07 <lambdabot>  [[1,1,1],[1,1],[1],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
14:15:22 <dmwit> > tails [1, 1, 1] -- even more better
14:15:23 <lambdabot>  [[1,1,1],[1,1],[1],[]]
14:15:56 <dmwit> > tails "[\"[\"\"]\"]"
14:15:57 <lambdabot>  ["[\"[\"\"]\"]","\"[\"\"]\"]","[\"\"]\"]","\"\"]\"]","\"]\"]","]\"]","\"]","...
14:16:12 <ac> ow
14:16:34 <litb> wee now that i understand type classes overloading-haskell-numbers- absolutely makes sense to me. it really rocks
14:16:44 <litb> i always wanted to know how to do something like that
14:16:55 <ac> sure as hell beats Java
14:17:24 <lispy> I think my types are all wrong.
14:17:36 <litb> lol what did you want to do dmwit ?
14:17:50 <litb> or, better, what did you do?
14:18:11 <dmwit> litb: I wanted to write some code with confusing output.  I think it worked
14:18:25 <Pseudonym> Woo!
14:18:38 <Pseudonym> Melbourne Uni functional programmer union is starting up again.
14:18:38 <resiak> @instances-importing Storable
14:18:39 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
14:18:43 * resiak growls at \b
14:18:50 * Pseudonym missed out on the previous incarnation
14:18:52 <oerjan> \b ?
14:18:58 <dmwit> ?instances Storable
14:18:59 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
14:19:04 <bos> Pseudonym: you're in .au?
14:19:05 <dmwit> oerjan: lambdabot
14:19:08 <Pseudonym> Yup.
14:19:12 <oerjan> @instances-importing Data.Storable Storable
14:19:12 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
14:19:14 * Pseudonym is at RMIT
14:19:19 <dmwit> ?instances-importing Numeric Storable
14:19:19 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
14:19:31 <oerjan> @instances-importing Data.Storeable Storeable
14:19:32 <lambdabot> Couldn't find class `Storeable'. Try @instances-importing
14:19:36 <oerjan> hmph
14:19:41 <oerjan> @index Storable
14:19:41 <lambdabot> Foreign.Storable, Foreign
14:19:44 <oerjan> ah
14:19:49 <resiak> oh, you need to pass the list of things to import
14:19:54 <oerjan> @instances-importing Foreign.Storeable Storeable
14:19:54 <lambdabot> Couldn't find class `Storeable'. Try @instances-importing
14:19:55 <dmwit> resiak: yeah
14:19:59 <oerjan> @instances-importing Foreign.Storable Storable
14:20:00 <lambdabot> Bool, Char, Double, Float, Int
14:20:01 <resiak> and, you need to be able to spell :-)
14:20:04 <oerjan> sheesh
14:20:28 <oerjan> resiak: tell that to the people behind Data.Typeable
14:20:37 <resiak> good point
14:20:42 <Cin> blargh. my program is just ending without any exception or anything
14:21:03 <dmwit> Wow.
14:21:13 <dmwit> "Arc only supports Ascii."
14:21:27 <Cin> go team graham
14:21:45 <dmwit> He made a really short-sighted decision, and obviously didn't even research it enough to know that it's ASCII, not Ascii.
14:22:27 <osfameron> huh?
14:22:36 <Botje> unicode is hard, let's add parens.
14:22:46 <osfameron> you've not heard of pronounceable acronyms losing capitalisation?
14:22:47 <resiak> hrm.  is there a NULL-terminated array of char* -> [String] marshalling thing floating around anywhere?
14:22:49 <osfameron> like Tardis etc.
14:23:17 <dmwit> resiak: Probably yes, in Bytestring somewhere.
14:23:19 <Pseudonym> osfameron: Actually, all acronyms are pronouneable.
14:23:25 <AutoForms> anybody here knowledgeable about "GHC as a library"?
14:23:31 <Pseudonym> If they're not, they're not acronyms.  They're abbreviations.
14:23:34 <osfameron> Pseudonym: er... yes indeed
14:23:35 <jedbrown> resiak: Foreign.C.String
14:23:45 <litb> hm, what is the "Data.Number.Symbolic" module?
14:23:47 <litb> i don'T have it
14:23:50 <Pseudonym> Scuba is-a acronym, IBM is-a abbreviation.
14:24:00 <osfameron> oh?  didn't know that about scuba
14:24:11 <Pseudonym> Self-contained underwater breathing apparatus.
14:24:13 <resiak> jedbrown: bzzt
14:24:14 <osfameron> aha
14:24:18 <osfameron> laser also, iirc
14:24:24 <resiak> jedbrown: I want to marshall char*[] to [String]
14:24:29 <Pseudonym> Laser, maser, radar... yup.
14:24:30 <mauke> peekArray0 nullPtr arr >>= mapM peekCString
14:24:40 <ac> I would say ascii, not Ascii
14:24:45 <ac> either ASCII or ascii
14:25:12 <ac> as long as there's an equivalent of a Word32 type, and some reasonable typing system, lack of unicode support isn't sooo bad
14:25:23 <resiak> mauke: i totally didn't see Foreign.C.Array.   Thanks.
14:25:32 <Cin> ac: one word: ÃŽÂ»
14:25:33 <BMeph> I've always been confused by people who say "Unicode" when they specifically mean UTF-16.
14:25:44 <mauke> resiak: Foreign.Marshall.Array
14:25:51 <Cin> ac: er, two words: lack of utf8 setting on my irssi. nevermind
14:26:03 <mauke> er, Marshal
14:26:10 <resiak> Foreign.Marshall.Mathers
14:26:16 <resiak> mauke: yeah, thinko.
14:26:21 <BMeph> I know it's the original incarnation, but I still think of UTF-16 as no more "really" Unicode than UTF-8 - or -32, for that matter.
14:26:35 <dmwit> ac: Word32... what will you do when Unicode doesn't fit in 4 bytes?
14:26:36 <ac> considering it's some sort of lisp like language, I assume you could write a reader macro for unicode characters
14:26:43 <ac> er, for unicode literals
14:26:53 <Pseudonym> Foreign.Marshal.VickieLynn
14:27:15 <Pseudonym> I guess that's Marshall, isn't it.
14:27:17 <phobes> Pseudonym:  From where do your definitions of abbreviation and acronym come?
14:27:36 <Pseudonym> phobes: Well, "abbreviation" is a more general term.
14:27:49 <Pseudonym> But several English style guides point this out.
14:28:03 <Philippa> abbrvn isn't an acronym
14:28:19 <Pseudonym> I _think_ I first read it in Bryson's Dictionary of Troublesome Words.
14:28:24 <dmwit> dict.die.net suggests that neither abbreviations nor acronyms need necessarily be pronounceable.
14:28:49 <ac> right. for exmaple: etc
14:29:03 <phobes> Pseudonym:  A request for google to define acronym produced 1 / ~15 definitions that matched yours
14:29:12 <ac> though I guess that's "pronounceable" as "etsa"
14:29:14 <Pseudonym> @wn acronym
14:29:14 <lambdabot> *** "acronym" wn "WordNet (r) 2.0"
14:29:14 <lambdabot> acronym
14:29:14 <lambdabot>      n : a word formed from the initial letters of a multi-word name
14:29:20 <BMeph> Not authoritative, but still explanatory: http://en.wikipedia.org/wiki/Acronym
14:29:20 <Pseudonym> Note: an acronym is a word.
14:29:20 <lambdabot> Title: Acronym and initialism - Wikipedia, the free encyclopedia
14:29:25 <phobes> 1/16 :)
14:29:40 <dmwit> Pseudonym: oh, sneaky
14:29:49 <Pseudonym> Pretty much every definition I've seen defines an acronym as a word.
14:30:24 <phobes> Pseudonym:  hmmm, but you just said that SCUBA was an acronym
14:30:30 <Pseudonym> Sure.
14:30:33 <Pseudonym> It's a word.
14:30:38 <phobes> lol
14:30:48 <Pseudonym> Formed by taking the initial letters of something else.
14:30:52 <wolverian> hm, I can't build darcs cabal-install: Hackage/Tar.hs:26:9: Couldn't match expected type `ByteString' against inferred type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString'
14:30:55 <BMeph> "Initialism originally described abbreviations formed from initials, without reference to pronunciation. The word acronym was coined during the mid-20th century for abbreviations pronounced as words, such as NATO and AIDS. Of the names, acronym is the most frequently used and known; many use it to describe any abbreviation formed from initial letters."
14:30:56 <Pseudonym> The thing is, you don't pronounce, say, "IBM" as a word.
14:31:14 <wolverian> do I have a too old bytestring, or what?
14:31:41 <ac> wolverian: there are strict ByteStrings and lazy ByteStrings
14:31:49 <BMeph> Right: if you pronounce it as the letters, it's an "initialism, if you pronounce it like a word, it's an acronym.
14:31:54 <resiak> is it Evil Bad and Wrong to use free from F.Marshal.Alloc to free memory allocated in the C library being bound?
14:32:00 <wolverian> ac, right, but this is not my code :)
14:32:18 <Pseudonym> Right, though I'm not sure where the term "initialism" comes from.
14:32:24 <wolverian> perhaps the darcs version is just broken at the moment
14:32:26 <Pseudonym> I suspect it's a word that some pedant coined.
14:32:30 <Pseudonym> It's a good word, though.
14:32:33 <BMeph> Of course, JPEG, messes up that whole accord... ;p
14:32:34 <ac> wolverian: ah right. Can never hurt to get the latest version
14:32:42 <ac> wolverian: that's fixed various build errors for me
14:32:51 <ac> wolverian: but haven't encountered that specific one
14:32:52 <phobes> Pseudonym: So IMHO is an acronym if I start pronouncing it "em-hoe"
14:33:12 <Pseudonym> BMeph: That's right, however "AWOL" is much the same thing as "JPEG", and we usually think of "AWOL" as an acronym.
14:33:12 <wolverian> ac, yar, this is the latest from darcs.
14:33:13 <ehird> Warning: this binary distribution does NOT contain documentation!
14:33:14 <ehird> scary
14:33:26 <mauke> resiak: if the C library uses malloc, no
14:33:31 <Pseudonym> There is a fuzzy boundary, this is true.
14:33:34 <ac> Pseudonym: IMHO is an acronym weather it's pronounceable or not
14:33:37 <Cin> Pseudonym: er from "intials" like someone's initials? initial letters..
14:34:02 <phobes> Pseudonym:  At least with AWOL, the A is functioning a normal role for an A
14:34:04 <Pseudonym> Cin: What I meant is, who coined the term?
14:34:17 <phobes> Pseudonym:  Whereas we never pronounce J as "J"
14:34:22 <Pseudonym> phobes: Oh, it could be an alpha privative!
14:34:27 <Pseudonym> Someone who is awol is not wol.
14:34:28 <resiak> mauke: cool.
14:34:44 <Pseudonym> I propose we take this discussion to haskell-blah.
14:35:03 <vincenz> Saizan: it's coming up
14:35:04 <BMeph> Pseudonym: that's because pronouncing the "A" in AWOL is acceptable English pronunciation.
14:35:08 <vincenz> Saizan: if you disagree with anything, please inform me
14:35:40 <Pseudonym> That's true, but it doesn't fit the "standard" rules.
14:35:47 <dobblego> IMHO is not an acronym, it is an initialism
14:35:54 <dobblego> NATO is an acronym
14:36:06 <Pseudonym> It should be pronounced something more like aww-ol or ow-ol.
14:36:10 <BMeph> Also, Pseudonym: for more info on where the heck "initialism" came from, I'd check
14:36:16 <BMeph> "two well known books on the topic are entitled Acronyms, Initialisms and Abbreviations Dictionary (19th ed., Gale, 1993) and Concise Dictionary of Acronyms and Initialisms (Facts on File, 1988)"
14:36:24 <Pseudonym> Ah, useful.
14:36:28 <vincenz> Saizan: http://notvincenz.blogspot.com/2008/01/using-typechecker-monad-to-type-check.html
14:36:32 * Pseudonym will see if the library has it
14:36:37 <lambdabot> Title: lambda.oasis: Using the TypeChecker Monad to type-check simple typed lambda calc ..., http://tinyurl.com/3ds6be
14:36:52 <ac> pedants
14:37:16 <BMeph> Pseudonym: For example, "AJAX" is an acronym pronounced exactly like the name.
14:37:57 <ADEpt> @where fix
14:37:58 <lambdabot> I know nothing about fix.
14:38:17 <phobes> Pseudonym:  Alpha privative?  You know way too much about the language :)
14:38:57 <ac> I want a function to return either a [Word8] or a [Word16] (specifically, depending on the type of an argument), but I don't want to write two versions of the same function.
14:39:01 <Pseudonym> You can never know too much.
14:39:08 <dobblego> ac, Either
14:39:12 <MyCatVerbs> BMeph: those two are silly.
14:39:20 <Cin> pseudonym: that's just what jesus said, sir
14:39:25 <MyCatVerbs> BMeph: who'd ever made a guide to acronyms that didn't have a pronouncable acronym?
14:40:03 <BMeph> MyCatVerbs: Eh? Say again your last, over. ;)
14:41:00 <MyCatVerbs> BMeph: Acronyms, Initialiasm and Abbreviations Dictionary: AIAD. Crap acronym.
14:41:11 <unenough> err lambdabot needs zlib, but how do i install that? i downloaded the zlib package from http://hackage.haskell.org/packages/archive/zlib/0.4.0.2/zlib-0.4.0.2.tar.gz
14:41:13 <lambdabot> http://tinyurl.com/3x9g5a
14:41:21 <MyCatVerbs> BMeph: Concise Dictionary of Acronyms and Initialisms: CDAI. Also a crap acronym.
14:42:13 <BMeph> Ah, I get you. Maybe you should make a text specifically about acronyms, and give it an acronymic title... or not. ;)
14:42:50 <ac> I almost find it hard to believe there are texts on acronyms and initialisms... how much is there to say really?
14:42:59 <MyCatVerbs> Preferrably a recursive one, too.
14:43:30 <BMeph> ac: Which is to say, dobblego isn't correcting you, he's mentioning the data type - Either - to use. ;)
14:43:36 <unenough> THIS IS NOT AN ACRONYM = This is not an acronym.
14:44:13 <ac> BMeph: yeah, I'm already using Either to represent the type in one place... but the problem is a little more complicated than I explained I guess
14:44:21 <MyCatVerbs> BMeph: heehee, how about "Abbreviate this Guide"? :)
14:45:28 <jonaskoelker> I want to say main = frob.readFile.head (System.Environment.getArgs ++ "/dev/stdin"), but getArgs has type IO [String], not matching [a].  What to do?
14:45:31 <davidL> "Byte" is a fairly far-fetched way of acronymizing "binary digit eight".
14:45:39 <unenough> so how do i build lambdabot?
14:46:13 <BMeph> davidL: Why "eight"?
14:46:31 <jonaskoelker> BMeph: eight bits on a byte...
14:46:52 <BMeph> davidL:Er, rather, how does "eight" fit into the word.
14:47:05 <jonaskoelker> byt_e_, e for eight?
14:47:22 <davidL> yeah :)
14:49:04 <davidL> BinarY digiT Eight
14:50:04 <phobes> If they refer to bytes in a movie set in the past, is that an anachronacronymism?
14:50:22 <mgsloan> I've come up with a funny sort of zipper.. VZip a b = VZip [a] b [a] (a->b) (b->a)
14:51:00 <dolio> V for view?
14:51:09 <mgsloan> yep
14:51:10 <davidL> phobes: why would it be?
14:51:28 <BMeph> Well, "see" y'all later...
14:51:43 <phobes> davidL:  BinarY digiT Eight
14:52:51 <Cin> how does one sleep for a number of milliseconds or seconds?
14:52:59 <mauke> threadDelay
14:53:18 <Cin> mauke: thanks
14:53:36 <mauke> sleep = threadDelay . round . (1e6 *)
14:53:50 <davidL> phobes: I'm not sure what that has to do with the past. Binary digits existed long before computers :)
14:55:04 <ac> It would still be an anachronystic acronym, because the acronym itself only existed later
14:55:41 <phobes> According to wikipedia "The term byte was coined by Dr. Werner Buchholz in July 1956"
14:56:22 <phobes> I will note that wikipedia fails to recognize it as an acronym
14:56:52 <davidL> I don't know if it is, I got that off the OED.
14:56:52 <newsham> "ghc-asm: don't know how to mangle assembly language for: x86_64-unknown-freebsd
14:57:06 <newsham> any ideas what might cause this?  what is assembly mangling?
14:57:25 <ddarius> newsham: It's what the Evil Mangler does.
14:57:46 <newsham> and what is the function of this Evil Mangler?
14:57:48 <Pseudonym> "Byte" definitely wasn't invented as an acronym.
14:58:00 <Pseudonym> There is the term "backronym".
14:58:03 <phobes> I know ;)
14:58:16 <mauke> newsham: mangling the assembler code produced by the c compiler
14:58:25 <ddarius> newsham: It mangles the assembly output of GCC to fix some issues, e.g. I believe some tail recursion things is included.
14:59:02 <newsham> my ghc/ghci seem to be somewhat working, but it crapped out trying to build zlib with this error.
14:59:31 <Pseudonym> If someone feels like editing Wikipedia, I note that it doesn't describe the origin of the word "bit".
14:59:35 <mauke> well, you could use -fasm
15:00:24 <Corun> Arr.
15:00:45 <davidL> "The term "byte" comes from "bite," as in the smallest amount of data a computer could "bite" at once." I still think BinarY digiT Eight is cooler :P
15:01:08 <Pseudonym> it's cooler, but it doesn't make any sense.
15:01:09 <Axioplase> octet is nicer to me.
15:01:14 <newsham> oh, the -fvia-C is causing this
15:03:22 <dolio> Not to mention that not all bytes had 8 bits.
15:03:52 <wagle_> thats why "octet"
15:05:38 <dolio> Man, I've never heard anyone use some of these words on Wikipedia. Playte, chawmp, dynner, gawble...
15:06:46 <ddarius> dolio: That's because you live in the 21st century.
15:06:54 <Corun> (The best century)
15:07:11 <ddarius> Corun: I hear good things about the 39th
15:07:21 <cjb> the best pre-singularity century :)
15:07:30 <Trinithis> is there a way for me to install lambdabot onto my computer?
15:07:33 <Corun> That's the spirit
15:07:44 <Corun> Download it and pray, Trinithis
15:08:00 <slarba_> huh, paul graham published his Arc
15:08:01 <wagle_> @where lambdabot
15:08:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:08:15 <ddarius> Oh no!  The end is nigh!
15:08:15 <Trinithis> aha
15:08:47 <dolio> It's been a good run, but I guess we can all give up Haskell now. :)
15:08:55 <slarba_> looks like yet another scheme, running on top of scheme
15:09:05 <Trinithis> oh no! the link is dead!
15:09:24 <ddarius> slarba_: What -were- you expecting?
15:09:24 <unenough> @verrsion
15:09:25 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:09:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:09:29 <Trinithis> dolio: is that possible?
15:09:31 <ac> slarba_: arc compiles to scheme?
15:09:52 <gbacon> ac: MzScheme
15:09:53 <newsham> ?seen cale
15:09:53 <lambdabot> cale is in #oasis, #haskell-overflow, #haskell and #ghc. I last heard cale speak 1h 1m 57s ago.
15:09:54 <slarba_> ac: yeah. it runs on top of mzscheme, uses mzscheme's reader etc
15:09:57 <Cale> hi
15:10:10 <dolio> Trinithis: Since Arc is The Ultimate Language, of course. :)
15:10:13 <newsham> cale: you built lamdabot on 6.8, yes?
15:10:16 <Cale> yes
15:10:22 <Cale> Having trouble with it?
15:10:32 <newsham> Plugin/Dummy/DocAssocs.hs:5:17: Could not find module `Data.ByteString.Base':
15:10:39 <newsham> not sure what to do about that one
15:10:48 <Cale> newsham: Make sure you have the right version of bytestring installed.
15:10:50 <Trinithis> dolio: a link to an Arc site perhaps?
15:10:52 <slarba_> ddarius: I was expecting more, really :D
15:11:00 <Cale> err...
15:11:00 <Trinithis> dolio: haven;t heard of it
15:11:10 <Cale> No, actually, maybe that's from the old version.
15:11:18 <dolio> Hmm... Let me see...
15:11:19 <Cale> istr you can just delete the .Base
15:11:33 <Cin> is it safe to have one thread read to a socket and one to write to it?
15:11:38 <newsham> ahh, i shoulda tried that first :)
15:11:45 <shachaf> newsham: Are you sure that's the latest version?
15:11:47 <dolio> Trinithis: http://www.paulgraham.com/arc.html
15:11:47 <lambdabot> Title: Arc
15:11:50 * shachaf doesn't have a .Base.
15:11:53 <slarba_> 7 years, and (define x... goes (def x...
15:12:03 <slarba_> and (defmacro goes (mac ...)
15:12:10 <slarba_> I'm baffled.
15:12:12 <mauke> OPTOMIZED
15:12:34 <resiak> bah, GHashTable isn't bound :(
15:12:35 <newsham> cale: it wants packAddress,  do I want unsafePackAddress?
15:12:39 <sclv_> And libraries for HTML with Tables.
15:12:45 <slarba_> it even abandons scheme's hygienic macros, how shame
15:12:46 <dolio> slarba_: Keep in mind, he had to write all those essays in that time, too.
15:12:51 <shachaf> newsham: I think .Base was used when it was still using unsafePackAddress.
15:12:52 <slarba_> dolio: yeah :))
15:12:57 <shachaf> newsham: That's not fixed in darcs?
15:12:59 <sclv_> "the table is the list of the HTML world"
15:13:07 <newsham> i pulled lambdabot darcs 30min ago
15:13:17 <newsham> from code.haskell.org
15:13:19 <sclv_> i.e. you can nest them until your head explodes?
15:13:29 <zooko> Hm.  I wanted to measure how fast Haskell-Crypto's SHA-256 implementation is.
15:13:38 <Cale> newsham: Whoa, I don't remember seeing that problem in lambdabot, but er, I think you just want pack, and replace whatever unboxed string comes after with a normal string.
15:13:39 <shachaf> newsham: Oh, I remember now.
15:13:44 <sclv_> and a religious stance against structured data. "everything is a rose tree"
15:13:56 <ddarius> table (fix td)
15:13:56 <zooko> So I read the README.pdf.  It said to run "./Setup configure".  But when I do, it says: Setup: crypto.cabal:51: 'Executable' stanza starting with field 'executable      symmetrictestmain-is'
15:14:10 <Cin> i've got one thread reading and one writing to a socket, and when the remote host closes the connection, i get this error: server: <socket: 4>: hGetLine: resource vanished (Connection reset by peer), shortly afterwards the other thread tries to write to the same handle and then my program just ends with no message or anything
15:14:18 <shachaf> Somebody gave me a simple patch to fix it (just uses pack instead of unsafePackAddress, approximately).
15:14:21 <newsham> cale: care to share "darcs whatsnew" on your tree?
15:14:53 <zooko> Well, instead prhaps I'll try to learn how to wrap C++ code in Haskell...
15:15:00 <shachaf> @seen mux
15:15:01 <lambdabot> mux is in #haskell-overflow and #haskell. I last heard mux speak 6h 14m 37s ago.
15:15:38 <Cale> newsham: oh, heh, it seems I did do that replacement and forgot about it :)
15:15:42 <nominolo> zooko: can you paste the error message and the .cabal file?
15:15:46 <Cale> -hgl      = P.unsafePackAddress 3 "HGL"#
15:15:46 <Cale> +hgl      = P.pack "HGL"
15:15:50 <Cale> lots of changes like that
15:16:17 <newsham> I have errors for "P.packAddress" and "P.unsafePackAddress" are they all "P.pack" ?
15:16:23 <Cale> yes
15:16:37 <Cale> and remember to remove the sharp from the string.
15:16:54 <shachaf> newsham: unsafePackAddress was from the old Bytestring.
15:16:57 <Cale> (and delete the length integer after, because it's not needed)
15:17:17 <newsham> Couldn't match expected type `[GHC.Word.Word8]' against inferred type `GHC.Prim.Addr#'
15:17:28 <zooko> nominolo: the error message is what I did paste, as far as I can tell.
15:17:38 <Cale> newsham: Make sure it's Data.ByteString.Char8
15:17:49 <Cale> or, Data.ByteString.Lazy.Char8
15:17:59 <nominolo> zooko: are you sure there's no newline missing?
15:18:01 <zooko> nominolo: there is a crypto.cabal file which contains a ...
15:18:13 <nominolo> paste it at hpaste.org
15:18:25 <zooko> nominolo: how can I check.  This is my first attempt to use Haskell since... 1998 or so.
15:18:35 <nominolo> im vee
15:18:52 <newsham> P.pack "Control.Arrow"# ->  P.pack .... ?
15:18:52 <nominolo> it seems like you .cabal file is messed up
15:19:08 <zooko> nominolo: I have no file named ".cabal"
15:19:16 <nominolo> crypto.cabal
15:19:41 <newsham> oh, you got rid of the #, I see above
15:21:20 <Cale> @version
15:21:20 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:21:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:21:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5332
15:21:40 <zooko> nominolo okay, here is crypto.cabal: http://hpaste.org/5332
15:21:48 <ddarius> http://blog.plover.com/misc/census-data.html entertaining
15:21:49 <lambdabot> Title: The Universe of Discourse : The Census Bureau's data file
15:22:23 <newsham> cale: [13:15] < Cale> +hgl      = P.pack "HGL"
15:22:34 <newsham> why does that work?  doesnt P.pack want a [Word8] ?
15:22:36 <dozer> if I have a patch thatt darcs refuses to apply in a timely manner, is it possible to apply it manually?
15:23:06 <Cale> newsham: No, not with Data.ByteString(.Lazy).Char8
15:23:07 <mauke> zooko: what version of cabal are you using?
15:23:40 <newsham> ahh, different import!
15:23:45 <newsham> ok, that worked, thanks cale.
15:23:55 * LoganCapaldo wonders how "manual" dozer is thinking
15:23:56 <newsham> and shachaf
15:24:23 <Cale> newsham: I'll pull a clean copy of the lambdabot sources and fix things up :)
15:24:30 <zooko> dozer: have you tried darsc-2?
15:24:34 <zooko> mauke: how can I tell?
15:24:51 <mauke> ghc-pkg list Cabal
15:25:30 <dozer> zooko: no - you think darcs-2 may make the difference?
15:25:33 <zooko>     Cabal-1.1.
15:25:41 <zooko> dozer: it is possible.
15:25:51 * ddarius prepares himself for the radio interview.
15:25:58 <Cale> ddarius: radio?
15:26:00 <mauke>  Cabal-Version:   >= 1.2
15:26:02 <ddarius> SPJ
15:26:05 <mauke> zooko: you'll have to upgrade
15:26:05 <zooko> dozer: if I were you I would first try the same patch application with darcs-2, and if that doesn't work, then convert a repository to "hashed format" and then try that patch application.
15:26:13 <Cale> ddarius: hehe :)
15:26:18 <zooko> maule: thanks.  How do you suggest that I do that?
15:26:22 <nominolo> zooko: works for me
15:26:36 <zooko> nominolo: I guess I have too old of a Cabal.
15:26:47 <mauke> I did it manually, i.e. from the source tarball
15:26:47 <Cale> ddarius: You mean you're going to listen to the recent radio interview with SPJ, or will you be interviewing him yourself? :)
15:26:50 <nominolo> possible
15:26:59 <ddarius> listen
15:26:59 <nominolo> which ghc do you have?
15:27:02 <newsham> blah, ghc-asm: don't know how to mangle assembly language for: x86_64-unknown-freebsd
15:27:06 <dozer> zooko: ok - I will give that a shot
15:27:11 <dons> dcoutts: around?
15:27:15 <newsham> which trying to comile Plugin.Pl.Common.
15:27:23 <zooko> nominolo: I have ghc 6.6
15:27:30 <Cale> zooko: I'd start by getting GHC 6.8.2, it comes with a newer Cabal.
15:27:35 <nominolo> ok, then your default cabal is too old
15:27:56 <nominolo> zooko: if you want performance tests, GHC 6.8 is also faster
15:28:03 <mauke> (newer cabals work fine with ghc-6.6, though)
15:28:07 <zooko> nominolo: okay I will upgrade ghc.
15:28:17 <zooko> dozer: let me know if it works.
15:28:59 <dons> hey zooko. glad to see you back in darcs land :)
15:29:11 <Cale> It looks like the Haskell Crypto library doesn't even use Data.ByteString though, which means that it could probably use some work in terms of performance.
15:29:23 <dons> yep
15:29:25 <bos> oh, the crypto library is sloooooooow.
15:29:28 <dons> or Data.Binary, Cale.
15:29:35 <zooko> Howdy dons!  I'm hoping that darcs-2 will fix the fatal flaws of darcs.
15:29:35 <Cale> yeah, or that
15:29:40 <bos> it's slow like molasses dipped in liquid nitrogen.
15:29:44 <dons> zooko:  me too
15:30:07 <dons> yeah, the current Crypto will make a good model for QC'ing the real crypto :)
15:30:32 <bos> hands off the source code! back to the writing desk!
15:30:50 <Cale> dons: One (somewhat unrelated) problem I had with Data.Binary is that it seems the default Binary instances for Float and Double use a funky library-specific encoding of floats rather than the IEEE one.
15:31:09 <dons> sigh yes.
15:31:22 <bos> Cale: you're not the first to notice :-)
15:31:24 <dons> work out a way to get at the IEEE format portably and i'm yours forever
15:31:36 <Cale> heh, I ended up using unsafeCoerce#
15:31:40 <dons> the current one uses a funky^h^h^h h98 spec'd version
15:31:49 <dons> that actually works portably.
15:32:14 <zooko> So, I was thinking of making bindings to some of Crypto++ in Haskell, as I've already done for Python.
15:32:15 <Cale> Perhaps we could use Storable?
15:32:26 <Cale> Or a small C module which did a cast?
15:32:34 <zooko> I read that the best chance is to first wrap the relevant bits of Crypto++ in C, and then make Haskell bindings for the C wrappers.
15:32:35 <dons> Cale, and gets the endianess
15:32:39 <zooko> Does that sound right to you guys?
15:32:43 <dons> zooko: yep. that's a good apporach
15:32:44 <zooko> http://groups.google.de/group/fa.haskell/browse_thread/thread/7e2bad6c0cf90e99
15:32:46 <zooko> Thanks.
15:32:48 <dons> once you've got a C interface, its easy
15:32:50 <lambdabot> Title: C++ bindings - fa.haskell | Google Groups, http://tinyurl.com/28l8lf
15:32:50 <Cale> dons: yeah, you'd have to be careful about that.
15:33:05 <NDBurns> hey, can someone help a noob?
15:33:10 <Cale> NDBurns: yep
15:33:24 <NDBurns> eval     "!quit"        			   = write "QUIT" ":ByeBye" >> io (exitWith ExitSuccess)
15:33:34 <NDBurns> how can i make this only listen to me?
15:33:49 <Cale> NDBurns: What code is that from?
15:33:54 <NDBurns> ircbot
15:33:59 <NDBurns> on the wiki
15:34:05 <ac> Arc look decidably boring
15:34:09 <Cale> ah, URL?
15:34:18 <NDBurns> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#A_simple_interpreter
15:34:19 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
15:35:12 <Cale> NDBurns: 'clean' is stripping out the information you need
15:35:43 <NDBurns> ok
15:36:01 <Cale> NDBurns: You'll need to actually parse that information and make it available to eval.
15:36:40 <bos> zooko: stepping into haskell?
15:36:44 <NDBurns> yeah
15:37:01 <NDBurns> i've done limited stuff before
15:37:03 <zooko> bos: dipping my toe.
15:37:18 <zooko> Chance are I'll get sucked back into urgent http://allmydata.org hackery before I really get started.
15:37:24 <lambdabot> Title: Allmydata Tahoe - Trac
15:37:37 <bos> zooko: just beware that interfacing between haskell and C++ is a PITA
15:37:49 <zooko> bos: I think I can keep it tamed by interposing C between the two.
15:38:00 <bos> zooko: yes, it's just a lot of work.
15:38:02 <newsham> cale: the "deriving" class of Lambdabot.hs line 451 -- how'd you fix that?
15:38:10 <Cale> newsham: IRCError -> e
15:38:24 <ddarius> Oh jesus
15:38:43 <Cale> ddarius: heh
15:39:11 <Cale> ddarius: Object oriented languages like Prolog? ;)
15:39:23 <ddarius> No, just when Simon starts talking at all.
15:39:30 <newsham> replace IRCError with e?  where is e bound?
15:39:38 <zooko> Okay, now that I've installed ghc-6.8.2, how do I run its unit tests?
15:39:41 <Cale> newsham: Nowhere, it's a variable.
15:39:41 <newsham> oh
15:39:42 <newsham> nevermind
15:39:51 <bos> zooko: did you build from source?
15:39:56 <zooko> bos: yep.
15:39:59 <idnar> Boost.Haskell? ;)
15:40:33 <Cale> heh, what is with people and building GHC from source? :)
15:40:48 <Cale> zooko: You must have a fast machine.
15:40:53 <MyCatVerbs> Cale: lack of current version on my distro, personally.
15:41:06 <Cale> MyCatVerbs: Are you running linux?
15:41:08 <bos> zooko: it doesn't ship with tests by default afair, you have to download them separately
15:41:12 <MyCatVerbs> Cale: indeed. Ubuntu, even.
15:41:15 <Cale> MyCatVerbs: There's a generic linux binary.
15:41:25 <larmeh> is there a way to implement inter-process communication in haskel? (e.g. for writing a solution to the producer-consumer problem)
15:41:27 <Cale> It works great on Ubuntu, you don't have to compile :)
15:41:36 <zooko> Cale: actually, it hasn't finished building ghc yet.
15:41:37 <bos> zooko: you need to grab teststuie
15:41:42 <zooko> Cale: I always build from source when I can.
15:41:44 <zooko> bos: thanks.
15:41:46 <idnar> I usually find it easier to grab source and download build, than to download random binaries
15:41:48 <mauke> larmeh: sure
15:41:49 <LoganCapaldo> files are ipc
15:41:55 <LoganCapaldo> if nothing else :)
15:42:00 <MyCatVerbs> Cale: perhaps, but it only takes a few hours on this box anyway.
15:42:01 <sclv_> zooko: i'll check in with you tomorrow and see how the build is going.
15:42:07 <idnar> er, delete the first "download"
15:42:12 <Cale> zooko: Probably you should just get the binary. Compiling GHC from source is a massive waste of CPU time unless you're going to hack on it.
15:42:12 <Corun> ToRA, your lecture was interesting until I had to go (you'd just got a shooting ship working).
15:42:22 <idnar> heehee
15:42:34 <MyCatVerbs> Cale: besides which, if you want 6.x series GHC on OpenBSD, you need to build from source.
15:42:44 <MyCatVerbs> Cale: they ship with 5.something. Ohhh, pain. ^_^
15:42:49 <Cale> MyCatVerbs: That's sad.
15:43:02 <idnar> nice
15:43:02 <newsham> also freebsd
15:43:08 <Cale> Nobody's bothered to put up a binary?
15:43:12 <newsham> especially if you need to apply patches from bug trac
15:43:23 <LoganCapaldo> Cale: or laternatively you're impatient. Even though I built ghc myself and it took forevers (exaggeration) I still beat the binary realease for my platform
15:43:40 <Cale> LoganCapaldo: heh.
15:44:00 <newsham> but on the bright side, someone fixed ghci on freebsd/amd64!  joyous day!
15:44:45 <Cale> You people should put up a binary for your platforms and let the GHC guys know where it is, and save everyone else some time :)
15:45:13 <newsham> ?seen dcoutts
15:45:13 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2h 18m 24s ago.
15:46:10 <MyCatVerbs> Cale: step one of that would involve installing OpenBSD for me.
15:46:19 <MyCatVerbs> Cale: possibly not a particularly bad idea, come to think of it. :)
15:53:30 <nuffer> hey, how can I restrict a type to be of kind Type => Type?
15:53:35 <nuffer> in a forall statement that is
15:53:43 <ddarius> ...
15:53:54 <mauke> that's not a kind
15:54:00 <EvilTerran> or valid
15:54:14 <nuffer> well, I'm not sure on the Haskell syntax, that's why I'm asking this
15:54:30 <mauke> maybe you shouldn't use haskell syntax in your question then
15:55:00 <EvilTerran> nuffer, what do you want your type to do? in words.
15:55:11 <EvilTerran> try to avoid jargon you're not familiar with. ;)
15:55:40 <nuffer> I would like it to be restricted to constructors which have exactly one lambda abstraction
15:55:50 <nuffer> like list
15:55:51 <kosmikus> nuffer: there's kind inference
15:55:58 <kosmikus> no need to annotate
15:56:01 <Saizan> ?type return
15:56:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:56:10 <kosmikus> GHC allows it, but that's not Haskell 98
15:56:15 <nuffer> sure, GHC
15:56:29 <nuffer> is the * any kind?
15:56:40 <kosmikus> * is what you write "Type"
15:56:47 <nuffer> oh... okay
15:56:52 <nuffer> thankee
15:57:33 <kosmikus> but if you just write "forall a m. (Monad m) => a -> m a" in the example above, Haskell knows that m has to be of kind * -> *, without any annotation
15:58:01 <nuffer> makes sense
15:58:09 <idnar> :kind (Monad m) => m -> m
15:58:38 <kosmikus> idnar: that's not kind correct
15:58:39 <Saizan> (->) :: * -> *
15:59:02 <kosmikus> nope, (->) :: * -> * -> * (simplified)
15:59:12 <idnar> hmm, yes, I guess that didn't make any sense
15:59:33 <nuffer> is "[] Int" the same as "[Int]"?
15:59:39 <kosmikus> nuffer: yes
15:59:39 <Saizan> yeah, forgot the result :)
15:59:57 <nuffer> excellent... thanks guys
16:00:09 <Saizan> (there's nothing to simplify in h98)
16:00:57 <kosmikus> Saizan: right, I was just saying it because ghc says something else
16:01:18 <idnar> @kind (->)
16:01:19 <lambdabot> ?? -> ? -> *
16:01:21 <idnar> heh
16:03:55 <litb> > let a :? p = (a,p) in 10 :? 6
16:03:56 <lambdabot>   Not in scope: data constructor `:?'
16:04:03 <lispy> :t 1 >>= return . id :: Either String Int
16:04:04 <lambdabot>     No instance for (Num (Either String Int))
16:04:04 <lambdabot>       arising from the literal `1' at <interactive>:1:0
16:04:04 <lambdabot>     Possible fix:
16:04:06 <litb> > let a <<? p = (a,p) in 10 <<? 6
16:04:07 <lambdabot>  (10,6)
16:04:14 <lispy> :t 1 >>= return . id
16:04:14 <lambdabot> forall a (m :: * -> *). (Num (m a), Monad m) => m a
16:04:35 <lispy> if m was either then it applies id to the Right value, right?
16:04:35 <idnar> :t ?a >>= return . id
16:04:35 <lambdabot> forall a (m :: * -> *). (?a::m a, Monad m) => m a
16:04:37 <litb> > 1 >>= return . id
16:04:37 <lambdabot>   add an instance declaration for (Num (m a))
16:04:45 <litb> > 1 >>= return . id :: Maybe
16:04:45 <lambdabot>      `Maybe' is not applied to enough type arguments
16:04:46 <lambdabot>     Expected kind `?', b...
16:04:49 <litb> ugg
16:05:02 <lispy> :t liftM id
16:05:03 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
16:05:27 <litb> > (Just 1) >>= return . id
16:05:28 <lambdabot>  Just 1
16:05:39 <lispy> I think liftM is more clear, but Id on't want to add it to the module
16:05:47 <lispy> > (Right 1) >>= return . id
16:05:47 <lambdabot>  Add a type signature
16:05:51 <idnar> @src liftM
16:05:52 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:05:55 <lispy> > (Right 1) >>= return . id :: Either String Int
16:05:55 <lambdabot>  Right 1
16:05:57 <idnar> @. undo src liftM
16:05:57 <lambdabot> ()
16:06:01 <lispy> > (Right "fail") >>= return . id :: Either String Int
16:06:02 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
16:06:07 <idnar> that... did not do what I wanted
16:06:17 <lispy> > (Left "fail") >>= return . id :: Either String Int
16:06:17 <lambdabot>  Left "fail"
16:06:32 <idnar> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
16:06:33 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
16:06:51 <lispy> right
16:06:53 <lispy> that makes sense
16:07:01 <lispy> which is why it would be more clean, I think
16:07:06 <litb> Either is a monad too?
16:07:10 <lispy> ya!
16:07:12 <ddarius> Either e is
16:07:17 <lispy> fail a = Left a
16:07:27 <lispy> otherwise it's just Maybe
16:07:28 <idnar> lispy: what about fmap?
16:07:36 <idnar> or do you not want to pull that in either?
16:07:50 <lispy> idnar: in monadic sense, think of Either as Maybe, but now you can return something on failure too
16:07:59 <lispy> idnar: i could check for fmap
16:08:06 <lispy> I meant to tell that to litb not idnar  :)
16:08:19 <idnar> > let f = fmap (+5) in f $ Left 5, f $ Right 5
16:08:20 <lambdabot>   parse error on input `,'
16:08:24 <idnar> > let f = fmap (+5) in (f $ Left 5, f $ Right 5)
16:08:24 <lambdabot>  (Left 5,Right 10)
16:08:29 <lispy> oh i have fmap
16:08:30 <lispy> sweet
16:08:33 <lispy> I'll use that
16:09:10 <litb> isn't that a tuple?
16:09:19 <litb> oh i understand
16:09:51 <litb> but what the heck is the difference to liftM ?
16:09:55 <litb> looks exactly the same
16:10:04 <idnar> litb: the only difference is that fmap is on Functor, while liftM is on Monad
16:10:25 <byorgey> since all Monads should be Functors, essentially liftM = fmap
16:10:40 <litb> Functor merely describes the fmap (lift) , and Monad puts the monadic things to it?
16:10:48 <litb> ah i see
16:10:57 <idnar> it's just that the typeclass hierarchy sucks
16:11:17 <idnar> but you should be able to trivially write a Functor instance for any type with a Monad instance, by using liftM
16:11:19 <litb> hmm :/
16:11:24 <idnar> (as far as I can tell)
16:11:39 <litb> but in haskell you can always build your own libs. i love that.
16:11:51 <idnar> anyhow, Either is a functor, so it's definitely not a problem here
16:11:51 <litb> looks like every op is defined in libs
16:12:05 <dobblego> 'Either a' is the Functor iirc
16:12:13 <nuffer> do I need to turn on something special to get ghc to understand this whole business about specifying the kinds?
16:12:17 <unenough> how do you quote a string in haskell?
16:12:30 <dozer> "a string"
16:12:39 <dobblego> > "foo\"bar"
16:12:39 <lambdabot>  "foo\"bar"
16:12:41 <idnar> dobblego: well, I meant that
16:12:42 <litb> > lines "hello\nboy"
16:12:42 <lambdabot>  ["hello","boy"]
16:13:09 <unenough> ok
16:13:10 <unenough> thanks
16:13:14 <idnar> but yeah
16:14:43 <newsham> whoa, ghc has perl in it? :)
16:14:52 <newsham> what will the neighbors think?
16:14:54 <byorgey> newsham: does it still?
16:15:10 <newsham> driver/mangler/ghc-asm.prl
16:15:21 <dozer> newsham: eugh - the thought of that makes me feel dirty
16:15:29 <ddarius> newsham: Yes, that's the Evil Mangler.
16:16:48 <litb> hm
16:17:03 <litb> ##perl would laugh on ghc
16:17:05 <ddarius> Perl and Haskell have a long history.
16:17:14 <LoganCapaldo> .prl
16:17:17 <LoganCapaldo> really?
16:17:29 <LoganCapaldo> I've never seen that extension for a perl script before
16:17:44 <EvilTerran> isn't it usually .pl?
16:17:48 <LoganCapaldo> i wonder what I'm revealing about myself by saying that
16:17:51 <shenlb> I use the irc client first.
16:17:59 <LoganCapaldo> EvilTerran: ime, yes
16:18:00 <newsham> lc: it gets preprocessed to add data in to generate ghc-asm
16:18:22 <LoganCapaldo> newsham: am I lc?
16:18:31 <LoganCapaldo> I'm guessing yes :)
16:18:59 <newsham> that was to you, ys.
16:19:02 <newsham> yes
16:19:29 <vincenz> tab-complete
16:19:32 <LoganCapaldo> so .prl isn't quite perl yet if I'm understanding you
16:19:46 <litb> .prl could be prelude if it wouldn't already be perl
16:21:58 <newsham> prelude to a perl file
16:22:09 <allbery_b> people use .prl as an extension for perl?!
16:22:25 <newsham> its an unpreprocessed source file with a nonstandard file exgtension
16:22:30 <newsham> calm down everyone
16:22:33 <dejones> allbery_b: .pl is perl, I thought
16:22:38 <newsham> no pedants were killed in the making of this file
16:22:41 <allbery_b> exactly
16:23:03 <Saizan> vincenz: you've made some changes to TypeChecker, right? e.g. the class Type and the parameter in PolyType
16:23:10 <allbery_b> (except that officially perl has no extension except .pm for modules; .pl is considered a compatibility shim for windows)
16:23:29 <newsham> cale: System.Eval.Haskell in RunPlugs?
16:24:15 <newsham> oh, thats a hs-plugins thing
16:24:34 <mauke> .pl stands for "perl module"
16:24:45 <mauke> er
16:24:48 <newsham> cale: what did you do about hs-plugins?  that doesnt work with 6.8, right?
16:24:49 <mauke> .pl stands for "perl library"
16:24:53 <wagle_> isnt that .pm?
16:24:55 <mauke> old perl4 libraries use it
16:25:41 <vincenz> Saizan: nope, that's with the typechecker in the monad, as is
16:25:55 <wagle_> i've seen plain old perl executables use .pl, but that might be a use that is in error
16:26:14 <Saizan> vincenz: also, you've pt <- generalize t, in withinScope but you don't use pt, (and i think using pt instead of (TyPoly [] t) would be a bug for STLC which is not polymorphic)
16:26:32 <vincenz> let me check
16:27:02 <vincenz> Saizan: that's correct
16:27:12 <vincenz> monomorphism
16:27:24 <vincenz> you want ot generalize let-bound variables
16:27:27 <vincenz> or you get MR
16:27:52 <Saizan> yeah, so why create pt to discard it?
16:28:13 <vincenz> doh!
16:28:17 <vincenz> right
16:28:23 <vincenz> good catch :)
16:29:05 <Saizan> however in your previous post 'data PolyType =' but in this you've a typesign with (PolyType mt), so i think you've some version mismatch :)
16:29:29 <vincenz> Saizan: fixed
16:29:35 <vincenz> hmmm
16:29:35 <newsham> http://www.thenewsh.com/%7Enewsham/x/lambdabot-on-6.8.2.diff
16:29:37 <vincenz> odd
16:29:50 <vincenz> sorry, your rigt :)
16:29:53 <vincenz> didn't check last version
16:30:00 <vincenz> mt is a remnant from some type-class based types
16:30:42 <vincenz> Saizan: fixed
16:30:43 <vincenz> this works
16:31:00 <dozer> ok, trying the same patch with darcs2 now
16:33:11 <dozer> seems to have got stuck on the same patch :(
16:33:20 <byorgey> newsham: is that what I think it is!?
16:34:22 <ddarius> "expliciticity"
16:34:33 <explisixjelly> yes?
16:34:37 <ehird> if i have multiple state in a StateT
16:34:42 <explisixjelly> ;)
16:34:44 <ehird> should i make a wrapper for them in a data?
16:34:46 <ehird> and then use that as the state?
16:35:01 <byorgey> ehird: probably.
16:35:04 <ehird> okies
16:35:05 <ehird> thanks
16:35:25 <byorgey> ehird: and use record syntax, of course
16:35:41 <byorgey> ehird: the advantage of that is you can later add new fields to the state without breaking everything
16:36:17 <ehird> hm, how do i pattern match on record syntax
16:36:35 <mauke> you can just pretend it's not there
16:36:54 <mauke> or use Constructor{ field = x, etc }
16:37:47 * dolio always feels like it should be { x = field }.
16:37:48 <ehird> basically i'm calling 'modify' and only care about one field
16:37:52 <ehird> is there a simple way to do that?
16:38:09 <wolverian> does or will ghc have support for â†’ instead of ->, etc?
16:38:11 <EvilTerran> existingRecord{ field = newValue }
16:38:27 <EvilTerran> makes a new record, differing from existingRecord only at field
16:38:39 <EvilTerran> sadly, there's no way of making this pointfree
16:38:42 <litb> wolverian: what symbol is that?
16:38:52 <EvilTerran> litb, right-pointing arrow
16:38:52 <wolverian> litb, right arrow
16:38:54 <mauke> U+2192 (e2 86 92): RIGHTWARDS ARROW [â†’]
16:39:16 <litb> uh haven't unicode enabled font here
16:39:27 <dozer> EvilTerran: it is a pitty, isn't it
16:39:50 <Saizan> vincenz: didn't we agree that withinScope should use "nogeneralize", since lambda-bound variables are monomorphic? even if maybe it should just take a PolyType as parameter so it can be reused for let
16:39:50 <litb> but my emacs displays it correctly at least
16:39:52 <shag> does someone know how to generate this "commit per day" graph as seen on http://code.haskell.org/binary/ ?
16:39:52 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
16:40:03 <vincenz> Saizan: lambda-bound variables aren't monomorphic
16:40:08 <ehird> push x = modify (\(Interpreter xs m) -> Interpreter (x:xs) m)
16:40:12 <ehird> that's the current function
16:40:17 <ehird> how can i make that robust with record types?
16:40:57 <EvilTerran> modify (\int@Interpreter{xs = xs} -> int{ xs = x : xs })
16:40:58 <Saizan> vincenz: they are, even in haskell i think, but surely in STLC, e.g. try to typeCheck flip' with the new code
16:41:02 <mauke> push x = modify (\rec -> rec{ stack = x : stack rec })
16:41:15 <oerjan> wow, irssi actually turned rightwards arrow into ->
16:41:16 <vincenz> Saizan: hmm
16:41:27 <vincenz> Saizan: good point, only let
16:41:36 <oerjan> made it rather confusing
16:41:50 <ehird> EvilTerran: wow that's kind of ugly ;)
16:42:04 <EvilTerran> ehird, :P
16:42:10 <EvilTerran> i'm assuming your field's called "xs" there
16:42:10 <idnar> oerjan: that's... weird
16:42:20 <ehird> EvilTerran: nah, stack
16:42:22 <EvilTerran> if it's called "stack", it'd be
16:42:45 <EvilTerran> push x = modify (\rec@Interpreter{stack = xs} -> rec{stack = x:xs })
16:42:48 <EvilTerran> or what mauke said
16:43:49 <vincenz> Saizan: fixed
16:45:01 <ehird> push x = modify (\i -> i{ stack = x:stack i })
16:45:02 <ehird> weird :-)
16:45:35 <oerjan> might want a modifyStack f = modify (\i -> i {stack = f $ stack i})
16:45:41 <newsham> byorg: depends on what you think it is
16:47:06 <ehird>     Possible cause: the monomorphism restriction applied to the following:
16:47:08 <ehird> eek
16:47:09 <ehird> :)
16:47:09 <Saizan> vincenz: k :) now id' :: a -> a as it should :)
16:47:11 <ehird> oerjan: yeah
16:47:52 <ehird> push x = modifyStack (x:)
16:47:57 <ehird> :24:23: Not in scope: `x'
16:47:59 <ehird> wtf :-)
16:48:14 <oerjan> ehird: do you actually have x on the left side?
16:49:05 <ehird> oerjan: hm?
16:49:07 <ehird> yes
16:49:11 <ehird> that's a direct quote from my file
16:49:12 <ehird> ;)
16:49:23 <oerjan> something very weird going on there
16:49:27 <oerjan> hm
16:49:28 <litb> :t modify
16:49:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
16:49:32 <ehird> oh
16:49:35 <ehird> that's a different line
16:49:37 <ehird> XD
16:49:55 <ehird> here i was, all ready to declare the discovery of a ghc bug
16:50:23 <oerjan> ehird: in time, in time
16:53:31 <unenough> do you guys know what Haskell means?
16:53:45 <Valodim> uh... it's a name?
16:53:49 <Botje> it's the first name of Haskell Curry
16:53:50 <wagle_> "Haskell Curry"  logician
16:54:37 <gwern> unenough: it's a name which causes tedious threads on haskell-cafe on the topic of pronunciation
16:55:11 <wagle_> use the welsh pronunciation
16:55:17 <idnar> so what is the correct pronunciation anyway? *duck*
16:55:37 <unenough> because in Hebrew, "haskel" means: learn, gain knowledge, become smart
16:55:51 <pjd> nice
16:55:52 <vincenz> Saizan: :)
16:55:58 <ehird> gwern: Hass kell.
16:56:03 <Botje> in english, "haskell" means: "brain asplosion, win and awesome"
16:56:11 <ehird> Like "Lass kill", except "kill" with an e
16:56:11 <oerjan> unenough: ah, i was trying to look that up
16:56:23 <ehird> Hass kel, I guess.
16:56:28 <oerjan> seen it before somewhere
16:56:49 <wagle_> i'm sure someone involved was aware of the hebrew meaning
16:56:59 * gwern haskell, will travel
16:57:14 <unenough> haskel = enlighten yourself
16:57:22 * oerjan is mainly wondering what syllable has the stress
16:57:35 <idnar> ehird: so not kÉ™l?
16:57:36 <gwern> wagle_: the naming process as I recall it being described in the retrospective was pretty haphazard... we nearly wound up with Curry, iirc
16:58:26 <unenough> if you accept the Hebrew interpretation, the pronounciation stresses the "kel". as in hass-KEL
16:58:35 <Mlok> please, what do this part code     sets = foldl' f []
16:58:35 <Mlok>  where f ss (e1,e2) = case (find (elem e1) ss, find (elem e2) ss) of
16:58:35 <Mlok>                 (Just s1, Nothing) -> (e2:s1) : filter (not . elem e1) ss
16:58:43 <mrd> then we'd have .cry files
16:58:51 <unenough> interpretation*
16:58:55 <oerjan> @quote never.liked
16:58:56 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
16:58:59 <litb> isn't Haskell named after a person?
16:59:12 <wagle_> "Haskell Curry"  logician
16:59:24 <ivanm> oh, I always thought Haskell was pronounced more like "has kell" rather than "hass kell" (i.e. the s sounds a bit more like a z), so it rhymes with Pascal...
16:59:43 <wagle_> good names for things can have multiple sources..  thats what i do, anyway
17:00:07 <unenough> so now you have another one
17:00:27 <litb> o.O
17:00:44 <eugman_> Do haskell curses libraries work with windows?
17:00:51 <wagle_> blurTogether "has" "skill"
17:01:29 <gwern> eugman_: what, ncurses bindings?
17:01:59 <gwern> windows is teh suck. its craptastic terminals probably don't support it...
17:02:05 <bakkdoor> hi
17:02:09 <eugman_> gwern, yes. That may be a dumb question because I'm not even sure ncurses works with windows
17:02:20 <mrd> msys
17:02:39 <newsham> the curses api could definitely be made to work with windows
17:02:49 <newsham> the termcaps api maybe not so much
17:02:58 <gwern> maybe through cygwin... but my general impression of cygwin is that in general the pain of the mismatchs just make it easier to use virtual machines etc
17:03:05 <mrd> newsham: sure, %$&$^&^ windows
17:03:14 <unenough> cygwin is a world of pain riding a world of more pain
17:03:28 <ivanm> unenough: which lot of pain is worse?
17:03:34 <newsham> gwern: if you're doing everything in cygwin, it should work well.. its just the interaction between cygwin and non-cygwin that gets you strangeness
17:03:39 <newsham> ghc builds in cygwin now, no?
17:04:04 <unenough> the windows pain multiplies the cygwin pain
17:04:35 <eugman_> Yeah, Maybe I'd be be better off using a GUI. Then, of course, I'd have to figure out how to compile on a linux server something that runs on a windows computer.
17:06:38 <Saizan> ghc can't
17:06:57 <dmwit> > let representatives xs = representatives' xs []; representatives' [] _ = []; representatives' (x:xs) ys = filter (not . flip elem . concat $ xs ++ ys) x : representatives' xs (x:ys) in representatives ["a", "b"]
17:06:58 <lambdabot>  Couldn't match expected type `Bool'
17:07:42 <newsham> eug: gtk or wx should be good on windows and linux
17:08:15 <oerjan> > let representatives xs = representatives' xs []; representatives' [] _ = []; representatives' (x:xs) ys = filter ((not .) . flip elem . concat $ xs ++ ys) x : representatives' xs (x:ys) in representatives ["a", "b"]
17:08:16 <lambdabot>  ["a","b"]
17:08:34 <ehird> idnar: well, i pronounce it kull
17:08:39 <ehird> Hasskull.
17:08:57 <ehird> Has skull!
17:09:04 <dmwit> oerjan: ah, thx
17:09:15 <dmwit> I have a feeling it can be even better, but...
17:09:18 <gwern> ehird has skull, will bash :)
17:09:31 <ehird> I pronounce Pascal as Pah, skull. Which just about sums up my opinions on Pascal.
17:09:34 <ehird> gwern: did you say bash? aaaaaaaaah
17:09:37 <oerjan> > let representatives xs = representatives' xs []; representatives' [] _ = []; representatives' (x:xs) ys = filter (flip notElem . concat $ xs ++ ys) x : representatives' xs (x:ys) in representatives ["a", "b"]
17:09:38 <lambdabot>  ["a","b"]
17:09:39 <eugman> newsham, yeah I've read about wxhaskell. Does anyone have any infor on compiling for windows? Is there something equivalent to mingw32 but for haskell?
17:10:17 <idnar> ehird: that's probably more like 'É™' than 'u'
17:10:20 <newsham> you should be able to get bins for it I think
17:10:53 <newsham> http://wxhaskell.sourceforge.net/download.html
17:10:53 <lambdabot> Title: wxHaskell - Download
17:11:01 <newsham> ahh, looks like bins for 6.4 an d6.2.2
17:11:06 <dons> ?users
17:11:07 <lambdabot> Maximum users seen in #haskell: 463, currently: 432 (93.3%), active: 25 (5.8%)
17:11:12 <newsham> updated may 8, 2005.
17:11:14 <dmwit> > let representatives xs = representatives' xs []; representatives' [] _ = []; representatives' (x:xs) ys = filter (flip notElem . concat $ xs ++ ys) x : representatives' xs (x:ys) in representatives ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"]
17:11:14 <lambdabot>  ["","mo","","w","h","fi",""]
17:11:17 <newsham> maybe gtk+ is a better choice? :)
17:11:35 <dmwit> Sunday, Tuesday, and Saturday have no unique letters.
17:11:40 <newsham> http://www.haskell.org/gtk2hs/
17:11:41 <lambdabot> Title: Gtk2Hs
17:12:16 <gwern> dons: maybe you should just add a hook to lambdabot where everytime you speak, it pms you a ?users for all its channels
17:12:17 <dcoutts_> ohh, the gtk+ website has been given a facelift
17:12:20 <wagle_> SMTWRFS
17:12:25 <unenough> ?
17:12:30 <dmwit> SMTWRFA
17:12:33 <newsham> > let [a,b] = words "sunday monday" in (nub a, nub (a++b))
17:12:33 <lambdabot>  ("sunday","sundaymo")
17:13:05 <dmwit> gwern: heh
17:13:06 <dons> ?users #xmonad
17:13:06 <lambdabot> Maximum users seen in #xmonad: 116, currently: 97 (83.6%), active: 3 (3.1%)
17:13:07 <dons> :D
17:13:11 <dons> ?users #darcs
17:13:11 <lambdabot> Maximum users seen in #darcs: 50, currently: 40 (80.0%), active: 1 (2.5%)
17:13:14 <dons> xmonad rocks
17:13:28 <newsham> ?remember dons xmonad rocks
17:13:28 <lambdabot> It is forever etched in my memory.
17:13:40 <dons> dcoutts_: awake?
17:13:47 <dcoutts_> dons: aye, just
17:14:14 <eugman> Unfortunately at the moment my only access of the web is through lynx
17:14:15 <ehird> if os x let you replace aqua wms i would so be using xmonad right now
17:14:24 <ehird> but it'd be wmmonad which sounds like woman monad
17:15:07 <newsham> if apple let you replace components, it woulndt be apple
17:15:21 <dmwit> I seem to recall reports of people using xmonad on a Mac.
17:15:23 <ehird> hey, they do let me ;)
17:15:26 <ehird> dmwit: yes, under x11
17:15:37 <dmwit> Ah, that's a bit limited then.
17:15:49 <newsham> like when you install software on an iphone and they brick your phone?
17:15:56 <ehird> newsham: they don't do that.
17:15:59 <ehird> that was for the sim unlock.
17:16:05 <ehird> you can't break an iphone by jailbreaking it
17:19:02 <gwern> somehow, I don't think I'll ever be using Paul Graham's Arc:
17:19:05 <gwern> 'It's not for everyone. In fact, Arc embodies just about every form of political incorrectness possible in a programming language. It doesn't have strong typing, or even type declarations; it uses overlays on hash tables instead of conventional objects; its macros are unhygienic; it doesn't distinguish between falsity and the empty list, or between form and content in web pages; it doesn't have modules or any predefined form of encapsulation except ...
17:19:10 <ehird> @hpaste
17:19:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:19:11 <gwern> ... closures; it doesn't support any character sets except ascii. Such things may have their uses, but there's also a place for a language that skips them, just as there is a place in architecture for markers as well as laser printers.'
17:19:22 <hpaste>  ehird pasted "the first works, the second doesn't. why?" at http://hpaste.org/5334
17:19:30 <ehird> gwern: arc is only 1000 lines of crappy compiler
17:19:32 <ehird> and a crappy stdlib
17:19:39 <ehird> it's smaller than most minimal schemes
17:19:47 <oerjan> > let representatives l = [filter (flip notElem . concat $ xs ++ ys) x | (xs, x:ys) <- zip (inits l, tails l)] in representatives ["a", "b"]
17:19:48 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
17:19:54 <wagle_> s/unhygenic/obsessive-compulsive/g
17:19:58 <oerjan> > let representatives l = [filter (flip notElem . concat $ xs ++ ys) x | (xs, x:ys) <- zip (inits l) (tails l)] in representatives ["a", "b"]
17:19:58 <lambdabot>  ["a","b"]
17:19:59 <nelhage> As far as I can tell, arc is basically perl with more parentheses and fewer features.
17:20:01 <wagle_> s/hygenic/obsessive-compulsive/g
17:20:08 <gwern> ehird: sure, but schemes have had decades
17:20:10 <ehird> nelhage: and macros!
17:20:23 <ehird> gwern: its also ugly in a common lispish way, but lacks features even scheme has
17:20:24 <nelhage> I would say "source-filters", but let's not go there :)
17:20:26 <ehird> it is total crap
17:20:39 <ehird> itd be ok if it wasn't for the GINORMOUS HYPE he put into it for something so tiny and crap
17:20:56 <gwern> it is slightly less total crap than it was yesterday when it was complete vaporware
17:21:03 <ehird> anyway. yeah. my paste.
17:21:27 <nelhage> I'm amused by _how long_ it took to hack together something that's just a crappy half-assed frontend on mzscheme.
17:21:41 <dmwit> ehird: You'd have to use <- instead of = in the second one.
17:21:43 <ehird> the error is:     No instance for (MonadState Interpreter [])
17:21:43 <ehird>       arising from a use of `get'
17:21:44 <dmwit> (And no let.)
17:21:49 <gwern> nelhage: he must've been busy rolling in his cash and funding startups
17:22:02 <ehird> dmwit:     Couldn't match expected type `StateT Interpreter IO t'
17:22:02 <ehird>            against inferred type `Stack'
17:22:18 <ehird> 'stack' is just a record accessor thing that haskell makes for me.
17:22:23 <ehird> stack :: Interpreter -> Stack
17:22:44 <dmwit> oh!
17:23:00 <dmwit> do (x:_) <- fmap stack get
17:23:03 <ehird> okay
17:23:04 <ehird> thanks
17:23:22 <ehird> dmwit: why do i have to do that out of curiosity
17:23:24 <oerjan> ehird: fmap stack get = gets stack
17:23:35 <ehird> alright
17:23:44 <dmwit> ehird: Because stack doesn't return a monadic action.
17:24:06 <ehird> aha, i see
17:24:31 <ehird> and i couldn't do the >>= because it expects a monad-returninger
17:24:36 <dmwit> right
17:25:24 <dmwit> :t (get, gets)
17:25:25 <lambdabot> forall (m :: * -> *) s s1 a (m1 :: * -> *). (MonadState s m, MonadState s1 m1) => (m s, (s1 -> a) -> m1 a)
17:27:35 <lispy> returninger?
17:27:37 <oerjan> dmwit: there's also asks
17:27:59 <dmwit> lispy: It's even more returning than before!
17:28:18 <oerjan> but is it the returningerest?
17:28:54 <lispy> oh heh, I didn't get the joke until oerjan said something
17:29:19 <wagle_> gwern, whats wrong with macros manipulating and creating their own lexical scopes?
17:29:42 <chiefmongoose> hey room... hoping someone can help me in here =) I've got GHCI (6.8.2) running on mac os x. Think I *may* have a readline issue...
17:29:54 <chiefmongoose> anyone reckon they might be able to offer some assitance?
17:29:54 <wagle_> programmers do it all the time
17:30:10 <gwern> wagle_: I dunno. my objection was to most of the rest...
17:31:02 <wagle_> chiefmongoose, ask your question here
17:31:13 <wagle_> maybe someone will know
17:31:29 <chiefmongoose> Cheers... OK. First problem is that when I hit the UP arrow, the history is including blank lines.
17:31:36 <chiefmongoose> Damn annoying, if you're a unix guy
17:31:46 <chiefmongoose> cos this is not standard readline behaviour (as far as I know)..
17:32:13 <chiefmongoose> so i dug into GHC and found ./libraries/readline/dist/build/System/Console/Readline.hs
17:32:27 <chiefmongoose> not sure if it's the readline library on my box, or the readline interface in GHC.
17:32:58 <chiefmongoose> Anyway, in that file, it mentions support for VI-style, rather than EMACs ... (in the actual intpreter), I'm a VI guy, so that would be awesome to have too
17:33:07 <chiefmongoose> but mainly I want to get rid of this annoying "non-history" problem.
17:33:20 <chiefmongoose> Anyone any ideas?
17:33:42 <wagle_> where'd you get the ghc source?
17:33:57 <dmwit> Huh, I don't get blank lines here.
17:34:18 <chiefmongoose> I grabbed a copy from haskell.org ... originally, the binary version
17:34:29 <oerjan> chiefmongoose: isn't the addHistory function called by the main program whenever it wants to add something?  so the problem may be elsewhere than in the Readline module.
17:34:35 <chiefmongoose> and I've been using that copy to build from source (obv. it needs GHC to build itsself)
17:34:45 <oerjan> however, i vaguely recall others having similar problems
17:35:02 <lispy> I hate this error message:
17:35:03 <lispy>     Inferred type is less polymorphic than expected
17:35:03 <lispy>       Quantified type variable `z' escapes
17:35:06 <ddarius> There was recent discussion, I think on the mailinglist, about this behaviour in GHCi.
17:35:13 <chiefmongoose> Oerjan, true... I'm just starting out trying to debug, so you may be correct =)
17:35:13 <ddarius> lispy: Why?
17:35:14 <lispy> I find it to be one of the harder ones to find/fix
17:35:29 <chiefmongoose> dmwit ... yep, I have a version running on Solaris too, and that is fine
17:35:32 <ddarius> lispy: It usually only comes up when you are using higher rank types.
17:35:53 <lispy> ddarius: well, I think I pasted too much, it's just the less polymorphic than expect that i hate
17:35:55 <chiefmongoose> BTW, I am on Intel Mac OS X (in case it makes a difference... ie. readline being screwed on it)
17:36:43 <ddarius> > \f -> (f 'a', f True)
17:36:44 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Char'
17:36:48 <chiefmongoose> oerjan -- do you know anywhere I might be able to get a definitive answer? The web is literred with various messages  indicating readline issues .. you're correct...
17:36:49 <lispy> ddarius: I think in my case I have to give some things in a 'let' a type signature before I'll be able to solve it
17:36:49 <oerjan> chiefmongoose: i have heard of readline problems specific to there - something about MacPorts having a different version - but since you are getting it at all i suspect that isn't it...
17:36:53 <chiefmongoose> so obviously it's occured before.
17:37:04 <chiefmongoose> hmm..
17:37:10 <chiefmongoose> Interesting.
17:37:14 <ddarius> lispy: I'm not sure it comes up if you don't use higher rank types.
17:37:26 <chiefmongoose> I have MacPorts installed, and used that readline build when building GHCI
17:37:32 <chiefmongoose> might be worth be making readline from scratch too.
17:37:33 <lispy> ddarius: ah, well okay.  I am definitely using higher ranks
17:37:39 <lispy> Actually.
17:37:40 <LoganCapaldo> > \(f :: forall a . a ->a) -> (f 'a', f True) -- wonders if this works
17:37:40 <lambdabot>  Parse error at "." (column 17)
17:37:46 <LoganCapaldo> doh
17:37:46 <lispy> I'm not sure if this is really rank-2 or not.
17:37:47 <oerjan> or was it MacPorts?  i don't use Mac so i may be confusing the terminology
17:37:48 <ddarius> LoganCapaldo: It would.
17:38:06 <lispy> ddarius: any use of extistential types qualifies as rank-2?
17:38:11 <ddarius> Yes.
17:38:25 <chiefmongoose> oerjan, I think the macPorts one was screwy in the past... but I grabbed mine elsewhere. But! I built against the readline FROM macports... so maybe that was the issue.
17:38:26 <lispy> okay then, yeah, higher ranked kinds are i
17:38:28 <oerjan> chiefmongoose: hm i vaguely recall there may be a readline package available from the ghc site
17:38:49 <chiefmongoose> Oerjan -- thanks... will go and have a poke around, I have something to go on at least :)
17:39:01 <wagle_> i'm currently beating my macosx 10.5 installation into shape on an iBook G4..  havent gotten around to ghc yet
17:39:10 <EvilTerran> LoganCapaldo, lambdabot's > is strictly haskell98, i believe
17:39:31 <LoganCapaldo> yeah i keep forgetting such things
17:39:32 <lispy> the parser is H98
17:39:43 <lispy> but, sometimes it has modules loaded which required haskell extensions
17:39:45 <chiefmongoose> wagle_ : cool.. I don't know if there were any Leopard-specific issues... I had it running fine on Tiger a while back tho (since got a new box)
17:40:01 <lispy> (required them to be written, but maybe don't require them to use)
17:40:32 <wagle_> i think there have been problems, but its not a show stopper for me
17:40:54 <chiefmongoose> wagle_: yeh.. I normally use HUGS actually
17:41:01 <lispy> ddarius: in my case, I think I need to be more careful about wrapping my values up (to hide the exitenstials)
17:41:10 <chiefmongoose> I just wanted GHC working =) (uni requirement for this project...)
17:41:19 <lispy> ddarius: so this particular instance of "less polymorphic" may not be so bad to find/fix
17:41:29 <wagle_> try macports or fink
17:41:44 <chiefmongoose> OK room - thanks for listening.. gonna head off and see where I can get!
17:41:51 <lispy> chiefmongoose: good luck
17:41:57 <chiefmongoose> =) ttfn!
17:44:40 <LoganCapaldo> Hmm, I wonder about g f = (f 'a', f True) with a type like f "is a method of a class of which both Char and Bool are instances of"
17:45:09 <ddarius> LoganCapaldo: Irrelevant.
17:45:36 <LoganCapaldo> don't call my musings irrevelant! :) I know you can't actually say that
17:46:10 <ddarius> I'm saying you have exactly the same problems whether or not it's restricted to a type class.
17:46:43 <Saizan> i think he'd like to express that type without fixing a specific typeclass
17:46:48 <LoganCapaldo> unless you have some kind of creepy pass by method-name
17:48:29 <EvilTerran> implicit typeclass! :D
17:49:44 <dolio> That's still something like 'g :: (forall a. C a => a -> b) -> (b, b)' no?
17:50:04 <dolio> Probably B instead of b, really.
17:52:13 <EvilTerran> it seems to me that g :: (forall a. f a -> g a) -> (f a, f b) -> (g a, g b) would be more useful
17:52:25 <EvilTerran> eg, f = g = [], and the first parameter's a list transformation
17:52:40 <EvilTerran> but then you end up in newtype hell
17:53:18 <TomMD> ?vixen Why does haddock not parse my file?
17:53:18 <lambdabot> i'll hafta plead the fifth on that one.
17:53:33 <idnar> hehd
17:53:41 <TomMD> Why do we keep her around?
17:53:41 <Saizan> TomMD: use haddock 2.0
17:54:02 <dolio> @vixen What do you think of Haskell programmers?
17:54:03 <lambdabot> Ooh, functional programmers are so hot!
17:54:11 <dolio> That's why. :)
17:54:23 <TomMD> Saizan: Darcs copy ok right now?
17:54:37 <LoganCapaldo> I was thinking something like g :: (class t a where f :: a -> SomeType, a = Char or a = Bool) =>  somesyntax f -> (SomeType, SomeType)
17:54:49 <wagle_> uh..  what does "hot" stand for?
17:54:57 <LoganCapaldo> sorry that or should be an "and"
17:55:03 <TomMD> wagle_: Can get jobs
17:55:25 <wagle_> at where?  5 places on the planet?  8/
17:55:26 <LoganCapaldo> although since it's imaginary syntax for some bizzare useless, un thought out type extension I guess it doesn't matter much
17:56:05 <Saizan> TomMD: i think so, but there was an annouce not long ago, maybe there's a tarball somewhere
17:56:08 <LoganCapaldo> maybe expressed better with (class t a where f :: a -> SomeType, t Char, t Bool) => ...
17:57:04 <LoganCapaldo> I'm absolutely bonkers
17:57:11 <LoganCapaldo> who would even use that?
17:57:55 <hpaste>  mgsloan pasted "Yay Zippers!" at http://hpaste.org/5335
17:58:05 <hpaste>  (anonymous) annotated "Yay Zippers!" with "(no title)" at http://hpaste.org/5335#a1
17:58:11 <mgsloan> oops
17:58:55 <dolio> Looks vaguely like something someone would do with dependent typing.
18:00:34 <Saizan> LoganCapaldo: it actually looks nice. and may not be difficult to implement
18:00:42 <newsham> does hs-plugins support 6.8?
18:00:59 <EvilTerran> LoganCapaldo, anonymous classes?
18:01:20 <Saizan> newsham: the darcs version on code.haskell.org does
18:01:23 <LoganCapaldo> well class vars
18:01:28 <EvilTerran> careful, your java is showing ;)
18:01:34 <newsham> danke
18:01:44 <LoganCapaldo> they're not anonymous
18:02:07 <LoganCapaldo> an anonymous class would be really silly
18:02:12 <newsham> hmm.. I dont see it on code.haskell.org
18:02:13 <EvilTerran> they don't seem particularly variable, either
18:02:34 <LoganCapaldo> well in the sense that :: a -> b a and be are type vars
18:02:35 <EvilTerran> aside from being a lcid instead of a ucid
18:02:43 <ddarius> "Here's a class with no name and no instances ! ! !"
18:03:11 <EvilTerran> @yow
18:03:11 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
18:03:14 <wagle_> so add names and instances to it
18:03:29 <TomMD> OK, so this is annoying.  Neither haddock (2.0) or whatever haddock is on hackage can parse my file.  It even compiles and I don't use any intelligent haddock notations (just -- | and -- *)
18:03:51 <EvilTerran> TomMD, O.o ... what extensions are you using?
18:03:59 <TomMD> ... about all of them ...
18:04:00 <newsham> saizan: know darcs url?
18:04:02 <LoganCapaldo> i don't actually have any java to show
18:04:20 <EvilTerran> TWAJS
18:04:51 <LoganCapaldo> so maybe it's _your_ java that is showing sir!
18:04:58 <TomMD> EvilTerran: More precisely: -XBangPatterns -XUnboxedTuples
18:05:00 <Saizan> newsham: http://code.haskell.org/~dons/code/hs-plugins
18:05:00 <lambdabot> Title: Index of /~dons/code/hs-plugins
18:05:00 <LoganCapaldo> have at hee
18:05:08 <newsham> tysir
18:05:12 <TomMD> EvilTerran: And a BUNCH of ghc-options in .cabal
18:05:43 <EvilTerran> LoganCapaldo, why, what's he done?
18:06:23 <EvilTerran> TomMD, well, i'd expect it to be able to cope with bang patterns; dunno about unboxed tuples
18:06:25 <LoganCapaldo> May I remind you I am vnced in on a laptop to a computer that is sitting next to me and spontaneusly switching keyboards?
18:06:43 <LoganCapaldo> that's probably a more of an inform than a remind
18:06:43 <Saizan> TomMD: have you done a clean? and are you sure cabal sees haddock 2.0?
18:06:46 <EvilTerran> no, you can't remind me of something i hadn't already been made aware of
18:06:51 <EvilTerran> but okay
18:07:10 <TomMD> EvilTerran: I've taken those out now and same deal.
18:08:02 <scook0> anyone know if there's a binding to fdopen(3) in any of the Posix or Foreign modules?
18:08:21 <oerjan> @hoogle fdopen
18:08:22 <lambdabot> No matches found
18:08:33 <oerjan> @hoogle open
18:08:34 <lambdabot> System.IO.openFile :: FilePath -> IOMode -> IO Handle
18:08:34 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
18:08:34 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
18:08:43 <TomMD> EvilTerran: I hadn't cleaned since the haddock upgrade (didn't think it would matter), but yay, I'm up and running (wonder what was up with the copy I sent to hackage... not worth my time I guess).
18:08:48 <TomMD> So, thank you.
18:08:53 <scook0> I already have a foreign binding of my own, but it would be nice if I could use an existing one
18:08:58 <scook0> oh well
18:09:01 <EvilTerran> TomMD, er, blame Saizan
18:09:08 <yondalf> scook0: i think the author of the bz2 binding made his own fdopen
18:09:12 <TomMD> ahh, oops, Saizan, thanks!
18:09:27 <yondalf> scook0: that was in a very old edition of the monad reader
18:09:41 <Saizan> TomMD: cabal caches such informations in the .setup-config, that's why
18:10:06 <Cin> i'm using the socketToHandle function and i'm writing to the handle every so often, except when the socket is closed using hPutStrLn crashes my program instead of throwing an exception. how can i avoid this?
18:11:35 <Saizan> Cin: even with Control.Exception.catch?
18:11:40 <Cin> afaik using send() returns -1 when the socket is closed, so i could use that
18:11:46 <Cin> saizan: no exception is thrown at all, it just bails out
18:11:59 <Cale> Don't close the handle until you're done writing?
18:12:01 <newsham> scook0: you mean like System.Posix.IO.fdToHandle?
18:12:10 <Cin> cale: well it's not me doing it, it's the remote host
18:12:18 <newsham> convert a filedescriptor (number) to a handle you can do IO on
18:12:23 <scook0> @hoogle fdToHandle
18:12:23 <lambdabot> No matches found
18:12:28 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html
18:12:29 <lambdabot> http://tinyurl.com/ypw9v7
18:12:41 <Saizan> Cin: sounds like a bug
18:13:12 <scook0> newsham: not quite what I want ... I need a Ptr CFile so that I can pass it to another foreign library
18:13:29 <Cin> saizan: well i thought that but i'm finding it difficult to reproduce in a small sample program. in a sample program it threw an exception
18:13:33 <newsham> I doubt you're gonna find one of those.
18:13:33 <Cale> Yeah, that does sound like a bug. You should just get an EOF if it's closed on the other end.
18:14:23 <scook0> yeah, well as I said, I already have one -- I'd just rather not have to tack it on to my own library
18:14:26 <Cin> saizan: but two things that may be causing it could either be that i'm reading to it in one thread and writing to it in another, and the reader thread tends to fail first WITH an exception, and then the writer thread just completely bails
18:14:28 <scook0> but it's not a big deal
18:14:30 <newsham> *nod*
18:15:02 <Cin> saizan: it's as if the hGetLine function says "oh no the resource has gone", throws an error, but then _frees_ the socket resource or something (i have no idea)
18:15:17 * scook0 is using pseudo-terminals to open ncurses in a new window :)
18:15:17 <Cin> saizan: if you follow me
18:15:35 <Cale> Cin: why are you using the low-level socket interface, btw?
18:15:45 <scook0> (which has the nice side-effect that you can mess around with curses via GHCi)
18:15:59 <Cin> cale: well i'm just using a Handle at the moment. what do you mean by low-level? socketToHandle?
18:16:07 <Cale> yeah
18:16:19 <jsnx> Cale: is a group a category of two categories, G and G^op ?
18:16:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html -- this is the high level interface
18:16:23 <lambdabot> http://tinyurl.com/2znny8
18:16:44 <Cale> jsnx: A group is a one-object category where every arrow is an isomorphism.
18:16:55 <Cin> cale: well i use the socket number (which is a CInt) as a way to uniquely identify the connection
18:17:01 <jsnx> Cale: oic
18:17:13 <Cin> cale: ie "user Dave on connection 4"
18:17:48 <jsnx> i thought the presence of inverses allowed us to create the opposite category -- but i see that you are correct, now that i think about it
18:17:48 <Cale> Cin: Handles are also directly comparable for equality, or you can use the (Handle, HostName, PortNumber) triple returned by accept
18:18:11 <Cin> cale: ah, then i'll use that
18:18:28 <Cin> cale: but i don't think that should cause this error i'm experiencing?
18:18:32 <ddarius> jsnx: You can always create the opposite category.  It's a formal operation.
18:18:34 <Cale> jsnx: If you generalise to multiple object categories where every arrow is an iso, then you get what's called a groupoid (in the newer sense of that word)
18:19:04 <jsnx> ddarius: aye
18:19:23 <jsnx> Cale: oic
18:19:26 <jsnx> thanks all
18:19:36 <Cin> cale: do you think it would?
18:19:52 <Cale> Cin: I think you've found a bug.
18:20:09 <Cin> cale: well i will try to make a short program to reproduce it then
18:20:14 <Cale> Cin: But it might just be easier to use the high level interface. You still probably want to report it if you can get a testcase.
18:21:59 <Cin> cale: i'm quite certain the fact i use socketToHandle instead of `accept' which returns a Handle won't effect it, but i will try what you say anyway, just to eliminate that possibility
18:22:34 <Cin> i'll do the testcase first
18:23:10 <Cale> Well, I suppose that accept calls socketToHandle internally anyway, but I've used accept successfully. It might have something to do with the details though.
18:23:16 <hpaste>  newsham pasted "cale: when lambdabots go wrong?" at http://hpaste.org/5336
18:23:25 <newsham> did you see that one?
18:24:14 <Cale> Data.Number.Symbolic?
18:24:19 <Cale> What is that?
18:24:24 <newsham> *shrug*
18:24:32 <newsham> I just tried out an eval :)
18:24:33 <Cin> cale: do you know if it is perfectly safe for one thread to read to a socket and one to write to it simultaneously? i don't see any mention of thread-safety on the ghc documentation page
18:24:49 <Cin> cale: er, not socket, a Handle
18:24:57 <Cale> I suppose you could look inside the L.hs and RunPlugs.hs to make sure they're not loading that module.
18:26:05 <newsham> ahh, runPlugs.hs has Symbolic
18:26:22 <Cale> (Or go out and look for the package it's in and install that)
18:27:00 <newsham> I dont see any Data.Number in haskell.org ghc docs
18:27:24 <newsham> I guess those are just the pre-included libs that the eval module loads up?
18:27:25 <Cale> It's not a standard module.
18:27:33 <Cin> cale: hello? D:
18:27:54 <Cale> Cin: Hmm... I don't actually know.
18:28:04 <Cale> Cin: er...
18:28:13 <Cin> cale: okay
18:28:29 <Cale> I think I've only written programs where a single thread handled each Handle.
18:28:57 <Cale> (Usually you write an accept loop which forks new threads, passing them the triple from accept)
18:29:08 <Cin> that's what i am doing
18:29:51 <Saizan> i've one where i concurrently read and write on the same handle and didn't had problems
18:29:59 <Cin> cale: except i spawn two threads, one to read from the socket, and one that reads from a channel and then puts that onto the socket
18:30:28 <Cin> saizan: ah, hm. i'm sort of disturbed that there is no mention of it in the docs, though :/
18:30:35 <newsham> ahh, its on hackage..  didnt think they'd be loading nonstd libs
18:30:46 <Saizan> Cin: yeah, i was too
18:33:19 <Cale> If you're having trouble with it, I suppose you could create two chans and handle all the real I/O in one thread.
18:34:14 <shepheb> what's the maturity of any Haskell/AJAX efforts? a little googling turns up some JSON examples. is there any project sufficiently advanced for e.g. a turn-based (30-second turns, not 2-hour turns) web game?
18:34:15 <newsham> cale: does your runplugs work?
18:34:31 <Cale> newsham: yes
18:34:35 <hpaste>  newsham pasted "runplugs error" at http://hpaste.org/5337
18:34:58 <Cale> newsham: ah, remove the haskell98 libraries from runplugs
18:35:36 <Cale> They've been separated from base (except Numeric, which you should keep), but they're included elsewhere under Data.* and System.*
18:35:43 <Cale> (and already should be imported anyway)
18:36:18 <newsham> I dont see the string "98" in runplugs
18:36:31 <newsham> I see it in a few comments of other .hs files, but nothing that looks substantial
18:37:26 <newsham> or do you mean "prehier" ?
18:38:09 <Cale> Like, "Char", "Array" etc.
18:38:18 <newsham> gotcha
18:39:03 <Cale> @version
18:39:03 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
18:39:04 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:41:56 <newsham> working now.  thanks.
18:48:07 <lispy> maybe push_patch indep_patch . commuteRL . (:> p)
18:48:15 <lispy> in that code, push_patch is the first parameter to maybe?
18:48:24 <lispy> and (indep_patch . commuteRL . (:> p)) is the second?
18:48:53 <oerjan> no, indep_patch is the second
18:49:18 <oerjan> commuteRL . (:> p)) may get applied to make the third
18:49:27 <lispy> so it's, (maybe push_patch indep_patch) . commuteRL . (:> p) ?
18:49:39 <oerjan> right
18:49:46 <lispy> :t maybe
18:49:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:50:20 <sjanssen> @unpl maybe push_patch indep_patch . commuteRL . (:> p)
18:50:20 <lambdabot> (\ d -> maybe push_patch indep_patch (commuteRL (d :> p)))
18:50:39 <lispy> sjanssen: good idea
18:50:55 <lispy> I find this code very hard to read
18:51:17 <TomMD> How does hackage decide to generate Haddock documentation for packages or not?  I see some packages with haddock comments don't get it generated on hackage.
18:52:28 <TomMD> I retract that.  It looks manual for now according to the wiki.
18:52:51 <Cin> PortID vs ThreadId -- decide on a naming convention? :P
18:53:20 <sjanssen> TomMD: it generates docs if the package can be configured (if all deps can be built)
18:53:22 <lispy> Cin: you object to ID vs. Id or something else?
18:55:29 <Cin> lispy: yes. ID vs. Id, sometimes i get confused >_>
18:55:56 <lispy> Cin: I can relate to objects about conventions, but I have to admit, ID vs Id is relatively minor :)
18:56:07 <lispy> er lack of conventions
18:56:44 <LoganCapaldo> what about iD?
18:56:50 <LoganCapaldo> :p
18:58:47 <EvilTerran> they made quake - what of 'em?
18:58:56 <Cin> lispy: indeed it is minor :P
18:58:59 <lispy> EvilTerran: what?
18:59:08 <lispy> oh iD software
18:59:14 * lispy slapself
18:59:26 * lispy was thinking of Frag
18:59:26 <EvilTerran> yeah. they're the only place i've seen that particular odd capitalisation with any frequency
18:59:48 <lispy> to them iD means id as in ego ala frued
19:00:02 <lispy> well, id, ego and superego
19:11:03 <BMeph> Wasn't that Freud, or is that just how you say it? ;)
19:11:40 <lispy> :t liftM2 (+)
19:11:41 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
19:11:54 <lispy> BMeph: I'm terrible with spelling
19:12:41 <lispy> ?hoogle liftM2
19:12:41 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:25:45 <JakeP> I have a stupid question, why doesn't this code work (I just started playing around with Haskell today)
19:25:46 <JakeP> main = do
19:25:46 <JakeP>    n <- getLine
19:25:46 <JakeP>    putStr "Number Plus one: " ++ show ( 1 + read n )
19:26:05 <gwern> @hoogle [a] -> (a,a)
19:26:05 <lambdabot> No matches, try a more general search
19:26:09 <oerjan> JakeP: it parses as (putStr "Number Plus one: ") ++ show ( 1 + read n )
19:26:28 <oerjan> try putStr $ "Number Plus one: " ++ show ( 1 + read n )
19:26:39 <gwern> phooey. any builtins to take a list and turn the first two entries into a 2-tuple?
19:27:04 <JakeP> oerjan, Thanks, put pahrens around it and it works,
19:27:08 <JakeP> what does $ do?
19:27:15 <oerjan> JakeP: saves parentheses
19:27:23 <Cale> JakeP: f $ x = f x, but $ has really low operator precedence
19:27:39 <nelhage> $ is in fix application. It is roughly a '(' that is closed by end-of-line or enclosing expression.
19:28:10 <JakeP> cool, I will keep that in mind
19:28:12 <Cale> Another common usage is when you're composing a bunch of functions in a chain, and then applying it to a value, like:
19:28:26 <JakeP> The Wikibook should mention that or something a  little bit sooner
19:28:31 <nelhage> s/in fix/infix/
19:28:33 <Cale> > read . reverse . show $ 57 :: Integer
19:28:35 <lambdabot>  75
19:28:51 <oerjan> gwern: doubt it
19:29:00 <oerjan> :t head &&& head . tail
19:29:01 <lambdabot> forall a. [a] -> (a, a)
19:29:09 <Cin> hrm! i think i have found more clues, cale: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html#hPutBuf (scroll up a few lines to the comments above the function)
19:29:10 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2vwfwr
19:29:12 <oerjan> but try that
19:29:34 <Cale> Cin: ah!
19:29:38 <gwern> oerjan: looks a hell of a lot nicer than my (\x -> (x !! 0, x !! 1) ,,,
19:29:58 <gwern> I keep meaning to learn arrows. they seem very handy
19:30:03 <oerjan> gwern: hm, maybe head && (!!1) is even better
19:30:09 <Cin> cale: i'm getting ResourceVanished on the hGetLine
19:30:12 <oerjan> * &&&
19:30:18 <Cin> cale: soon after, when i try to write to that Handle, my program ends
19:30:23 <Cale> gwern: You don't even have to properly learn arrows for that, just the (->) arrow :)
19:30:23 <Cin> so, hm
19:31:08 <Cin> ( server: <socket: 4>: hGetLine: resource vanished (Connection reset by peer) )
19:31:14 <gwern> oerjan: seems to work as well
19:31:14 <Cale> Cin: so maybe you have to tell it you want to ignore the sigpipe?
19:31:25 <Cale> oh
19:31:30 <Cale> That looks like a proper exception.
19:31:37 <Cale> You sure you can't catch that?
19:32:15 <gwern> (ok, so now my stdin is massaged into a list of tuples. I must ruminate on how to implement the actual nubbing logic)
19:32:28 <Cin> cale: well, i think i may be able to. but what if my sender thread tries to write at precisely the same time?
19:32:37 <gwern> :t nubBy
19:32:38 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
19:32:41 <byorgey> gwern: what are you trying to nub?
19:33:00 <oerjan> gwern: mind you if you can do with a list rather than a tuple, take 2 also works
19:33:43 <Cin> cale: i'm looking for an 'isResourceVanished'-like function similar to isEOFError but i have a feeling it may not be exported (seeing as SIGPIPE is sent and the program is supposed to end)
19:33:50 <gwern> byorgey: I am deleting thousands of duplicate emails, and I'm defining 'duplicate' by if they have the same file size, but I want to leave one. so my though is I will nub by file size, creating a new list, and diff it agains tthe original list
19:33:51 <Cin> s/function/value
19:34:15 <sclv> ?ty (\(x:y:xs)->(x,y))
19:34:16 <lambdabot> forall t. [t] -> (t, t)
19:34:16 <gwern> and I will use the final value for output to 'rm'
19:34:52 * gwern is not yet sure what set operator I need; union?
19:35:10 <oerjan> :t (\\)
19:35:10 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:35:30 <byorgey> gwern: wouldn't it be better to use some sort of hash of the contents instead of file size?
19:35:42 <byorgey> gwern: seems likely that you'd get collisions with two emails of the same size
19:35:46 <gwern> byorgey: sure, but I don't know how to easily do hashing in haskell
19:35:59 <gwern> byorgey: well, I'm limiting it to emails which are multiple megabytes in size
19:36:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5338
19:36:07 <byorgey> gwern: oh, fair enough =)
19:36:15 <Cale> Cin: It might just throw that exception in your other thread too.
19:36:26 <gwern> at that end of the size spectrum, having the same exact byte count starts to become kind of unlikely, y'know?
19:36:44 <gwern> (besides, if I delete the wrong stuff, I still have gmail search to fall back on)
19:36:49 <codetoad> http://hpaste.org/5338 so, i know this is wrong, but how do i use conditionals inside a do block?
19:36:57 <oerjan> @hoogle hashString
19:36:59 <lambdabot> Data.HashTable.hashString :: String -> Int32
19:37:13 <gwern> codetoad: indent the else a little?
19:37:33 <oerjan> gwern: ^^ it's a simple hash though
19:37:41 <gwern> (yes, adding another space seems to work)
19:37:56 <davidL> gwern: OUTF=rem-duplicates.sh; echo "#! /bin/sh" > $OUTF; find "$@" -type f -print0 | xargs -0 -n1 md5sum | sort --key=1,32 | uniq -w 32 -d --all-repeated=separate | sed -r 's/^[0-9a-f]*( )*//;s/([^a-zA-Z0-9./_-])/\\\1/g;s/(.+)/#rm \1/' >> $OUTF; chmod a+x $OUTF; ls -l $OUTF
19:38:11 <gwern> oerjan: besides, currently this is string -> string on the high level, but reading contents and stuff would involve all sorts of IO...
19:38:26 <Cale> Cin: installHandler sigPIPE Ignore Nothing
19:38:36 <codetoad> gwern: i get an error about the last statement in a do block needing to be an expression
19:38:47 <gwern> davidL: how does that script scale to dozens of thousands of files?
19:39:01 <oerjan> codetoad: indent the else a bit
19:39:18 <Cin> cale: ah, yes. i can catch it. in fact i am catching it. when i catch it and use hClose on the Handle then my program does not close and instead an exception is thrown when my other thread tries to write to it, which is a Good Thing
19:39:36 <oerjan> in a do block, everything indented the same as the first statement starts a new one
19:39:37 <Cin> cale: but what bothers me is what if my thread doesn't catch it and close it in time?
19:39:40 <Cale> Good, so you can catch it there as well.
19:40:01 <Cale> What happens if you just try writing to it? Program dies unexpectedly?
19:40:03 <Cin> cale: ie what if the sender thread gets there first?
19:40:03 <gwern> davidL: specifically, app 600K files in all :)
19:40:07 <Cale> yeah
19:40:10 <Cin> cale:right
19:40:14 <davidL> gwern: what it does is it creates a new shell script with rm lines commented out so you can choose which file to delete, but you can easily modify that to rm one of the files on the spot
19:40:39 <Cale> Cin: that might be the sigPIPE -- what happens if you trap that signal with the line I typed above?
19:40:52 <Cin> cale: i'll try it
19:41:05 <Cin> cale: do i just put this at the start of my `main'?
19:41:10 <Cale> yeah
19:41:12 <Cin> oki
19:41:26 <Cale> also, import System.Posix.Signals
19:41:58 <gwern> davidL: I appreciate the thought, but I really do want to do this in haskell more or less by my self
19:42:18 <Cin> cale: ah, thanks
19:43:00 <glguy> ?seen EvilTerran
19:43:00 <lambdabot> EvilTerran is in #haskell. I last heard EvilTerran speak 43m 34s ago.
19:43:32 <glguy> @tell EvilTerran I think that that is a HsColor bug with unicode rather than an exploit attempt
19:43:32 <lambdabot> Consider it noted.
19:43:35 <davidL> a haskell version would be neat to replace this alias, it would probably run faster also
19:43:41 <codetoad> oerjan: indenting works - what's the reason this works outside monads but must have this indentation here?
19:44:39 <oerjan> codetoad: it's because a do block is the only indented sort of block where the lines can start with an expression such as 'if'
19:45:04 <Cin> cale: i get the following: server: <socket: 4>: hPutChar: resource vanished (Broken pipe)
19:45:11 <gwern> davidL: probably. if I were writing that in sh, I'd probably avoid xargs, for example, and use find's -exec stuff. on 600k files, spawning can be problematic performance-wise
19:45:13 <oerjan> so it's the only place where the precise indentation of parts of if-then-else matters
19:45:17 <codetoad> oerjan: thanks
19:45:24 <Cale> Cin: that looks catchable
19:45:36 <Cin> cale: indeed i think it is. so what have we done here?
19:45:44 <gwern> I mean, jeez, just stating a directory with so many files takes an eon
19:46:01 <Cin> cale: sigpipe is usually sent to make the program end when a socket has disconnected? i don't understand why that would be sent?
19:46:06 <Cale> Cin: We've stopped the OS from killing your program after it performs invalid operations on closed pipes, and caught the exceptions instead.
19:46:32 <Cin> cale: ah, hm. that sounds good
19:46:58 <Cin> cale: presumably Windows would not have this issue?
19:47:27 <Cin> cale: would the program would work the same transparently?
19:47:29 <Cale> I'm not sure. It's been a long time since I've used a windows machine, but if it does, the solution will look different.
19:47:39 <Cin> ah, okay
19:47:48 <Cale> I don't know how well the Posix operations are supported on Windows.
19:48:29 <Cale> But I'm pretty sure Windows doesn't use the same signals as unix.
19:49:14 <Cin> cale: i've never had to set this sigpipe ignoring stuff when writing sockets in c. have you? i thought send() or similar would just return an error
19:49:40 <davidL> gwern: there's also md5 hashing in the crypto library and in nano-md5 on hackage
19:49:48 <Cale> Were the programs you wrote multithreaded?
19:49:53 <Cin> no >_>
19:50:56 <Cin> cale: well, i think we've found a pretty acceptable solution, don't you?
19:51:01 <Cale> Yeah.
19:51:05 <Cale> This seems reasonable.
19:51:27 <Cin> good stuff. thanks a lot, cale, i'd been really struggling trying to figure this one out
19:51:49 <Cale> If you end up worrying about cross-platform stuff later, it'd always be possible to refactor things so each socket gets a main I/O thread where all the real I/O on that socket gets done.
19:52:23 <Cale> Then you have two Chans which other threads could use for reading and writing on that socket.
19:52:44 <Cin> ah, that's what i have at the moment. except only for writing to it
19:53:19 <Cin> cale: how would you send _and_ receive in the same thread? all the send/receive operations seem to be blocking
19:53:54 <Cale> For what? Chan?
19:54:00 <Cin> a socket
19:54:12 <Cin> well, the Handle that represents a socket
19:55:00 <Cale> Well, hReady will tell you if there's anything to read.
19:55:11 <Cale> Does writing block indefinitely in any case?
19:55:19 <Cin> cale: ohhh.
19:55:22 <Cin> cale: no it should not
19:55:40 <Cin> cale: it's just an irc server, messages are short and sweet
19:56:35 <gwern> intersection of two sets is only ones which are in both sets, right? and union is the two sets added together? and difference is only the ones not in both?
19:56:40 <Cin> i will have a look at hReady
19:56:42 <Cale> You could probably come up with an abstraction which constructs such a process and pair of chans in general, given a Handle as input.
19:57:10 <Cale> gwern: that last would be symmetric difference
19:57:33 <Cale> gwern: The usual set difference, A\B is the set of elements of A which are not in B.
19:57:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5339
19:57:41 <gwern> hm. I see
19:58:11 <codetoad> do i need to change my indentation with something like this as well? http://hpaste.org/5339
19:58:24 <hpaste>  Cale annotated "(no title)" with "fixed" at http://hpaste.org/5339#a1
19:58:39 <Cin> cale: i'll give it a go and tell you how it goes :)
19:58:42 <oerjan> codetoad: you are missing then, and you need an inner do
19:58:54 <Cale> (see my annotation)
19:59:01 <oerjan> codetoad: ones you have that, you probably need to indent the else a bit _less_
19:59:01 <Cale> Cin: great :)
19:59:07 <oerjan> *once
19:59:11 <jfoutz> > 53 - 7
19:59:13 <lambdabot>  46
19:59:27 <jfoutz> Cale: you have an amazing response time.
19:59:43 * codetoad is from pythonlandia
19:59:59 <oerjan> argh, i didn't see Cale's response until too late :D
20:02:05 <hpaste>  gwern pasted "bwa ha ha" at http://hpaste.org/5340
20:02:22 <gwern> now I just need to format the print out, and it's good to go :)
20:02:49 <jfoutz> The HAppS state example code is terrifying.
20:03:34 <glguy> gwern: liftM f m >>= n  often looks nicer as:  n . f =<< m
20:03:40 <glguy> (if you were wondering ;) )
20:04:07 <gwern> jfoutz: happs is terrifying period
20:04:21 <gwern> glguy: yes, there's a lot that could be done to clean it up
20:05:11 <markluffel> are there any untyped haskells? is that absurd?
20:05:16 <Cale> gwern: The idea is to print the set of lines which are not the first line having any particular first word in the document?
20:05:32 <jfoutz> markluffel: scheme?
20:05:41 <Cale> markluffel: Somewhat absurd, in that things like typeclasses are central to the way we program.
20:05:47 <Korollary> markluffel: plt scheme has a lazy eval dialect
20:05:50 <markluffel> jfoutz: how lazy is scheme?
20:05:53 <markluffel> oh
20:06:15 <Maddas> Lambda calculus?
20:06:34 <markluffel> typeclasses do runtime dispatching though, right? (by untyped, i guess i mean dynamically typed)
20:06:43 <jfoutz> is clean typed?
20:06:47 <gwern> Cale: if by word you mean the whitespace definition 'words' goes by, I think so
20:07:06 <gwern> jfoutz: I hear some people dictate down their clean programs through voice recognition programs
20:07:15 <Cale> markluffel: They do runtime dispatching, but using static type information as a guide to which code is applied.
20:07:53 <oerjan> jfoutz: it has its own uniqueness type system
20:08:04 <jfoutz> oh.
20:08:05 <Cale> markluffel: That is, when you apply a typeclass-polymorphic function or value at a particular monomorphic type, a dictionary containing an implementation of the methods of that typeclass is silently passed in.
20:09:42 <gwern> Cale: oh, actually - on printing the set of lines which are not...  it should only print the second word (the file name)
20:10:02 <gwern> the first word, the size, can be thrown away once the nub and set stuff is done
20:10:42 <Cale> ah
20:14:15 <hpaste>  gwern annotated "bwa ha ha" with "print out suitable rm commands" at http://hpaste.org/5340#a1
20:15:11 <gwern> and.. a little more work and I add in ''s for the odder characters
20:16:28 <gwern> (now to see how much space I saved)
20:17:58 <pjd> @remember gwern <jfoutz> is clean typed? <gwern> I hear some people dictate down their clean programs through voice recognition programs
20:17:59 <lambdabot> It is forever etched in my memory.
20:18:35 <LoganCapaldo> who wants to live forever anyway?
20:18:40 * jfoutz blushes
20:18:59 <gwern> LoganCapaldo: I think I do. But as the expression goes, ask me again in a thousand years
20:19:37 <pjd> Cale: you can avoid dictionary-passing like jhc does, though, right?
20:19:43 <Cale> yeah
20:19:55 <Cale> It's just a useful model for what typeclasses mean.
20:19:56 <glguy> How does jhc avoid it?
20:20:05 <Cale> Whole-program compilation.
20:20:19 <ricky_clarkson> Lots of code generation?
20:21:00 <LoganCapaldo> does it also do wpo while it does wpc?
20:21:07 <Cale> I think that's basically it.
20:21:09 <Cale> LoganCapaldo: yeah
20:21:11 <pjd> glguy: basically, it figures out which instances the function gets called with, and then inlines them with an appropriated dispatch
20:21:19 <pjd> (at least, that's what i understand)
20:21:28 <pjd> "appropriate", even
20:22:01 <LoganCapaldo> so does it like beat the pants off ghc speedwise, or not really?
20:22:04 <glguy> What does it do for typeclasses that aren't known at compile time?
20:22:10 <glguy> (say existentials)
20:22:14 <pjd> glguy: http://repetae.net/computer/jhc/jhc.html
20:22:15 <lambdabot> Title: Jhc
20:22:28 <pjd> the "Type Classes" section
20:22:29 <Cale> I don't know if it supports existentials.
20:22:36 <LoganCapaldo> existensionals are an extension arne't they?
20:23:12 <LoganCapaldo> zomg
20:23:18 <LoganCapaldo> region inference
20:23:21 <LoganCapaldo> awesome
20:23:58 <LoganCapaldo> it must support existensionals
20:24:04 <LoganCapaldo> since it apparently uses them
20:25:02 <pjd> glguy: a nifty thing about that approach is that the type dispatch can resolve multiple type classes at once
20:25:48 <LoganCapaldo> reading the type classes section it's not as magically as i was imagining
20:25:53 <LoganCapaldo> *magical
20:26:17 <pjd> what magic were you anticipating? :)
20:29:32 <LoganCapaldo> I was kinda expecting it to totally remove the indirection all together
20:30:16 <LoganCapaldo> totally altogether. that's pretty redudant
20:30:36 <pjd> LoganCapaldo: well, it does, when it can
20:30:39 <pjd> AFAIUI
20:30:41 <dons> ?users
20:30:41 <lambdabot> Maximum users seen in #haskell: 463, currently: 411 (88.8%), active: 17 (4.1%)
20:31:13 <LoganCapaldo> is jhc actively developed?
20:32:10 <LoganCapaldo> ah
20:32:25 <LoganCapaldo> maybe it doesn't support existensionals and still uses them in the implementation
20:32:38 <LoganCapaldo> looks like you need ghc to build it
20:32:45 <pjd> LoganCapaldo: the RSS feed says 2007-09-26
20:33:39 <jfoutz> ?go scrap your boilerplate
20:33:42 <lambdabot> http://www.cs.vu.nl/boilerplate/
20:33:42 <lambdabot> Title: Scrap your boilerplate ... in Haskell
20:36:19 <dons> lispy: around?
20:36:48 <LoganCapaldo> dons: he recently stepped out (maybe)
20:36:57 <dons> ok, cheers
20:37:15 <wagle_> @seen lispy
20:37:15 <lambdabot> lispy is in #haskell-blah, #oasis, ##logic, #haskell-soc, #haskell, #ghc and #darcs. I last heard lispy speak 16m 10s ago.
20:51:10 <lispy> dons: ping
20:52:34 <sciolizer> It seems the ever contentious Euler problems on the Haskell wiki have been wiped again. :)
20:52:49 <Cale> wiped?
20:53:06 <sciolizer> Almost all of the solutions have been replaced with the text "Do them on your own!"
20:53:29 <Cale> I'll just revert.
20:53:55 <LoganCapaldo> and the battle continues
20:54:01 <sciolizer> heh
20:54:03 <LoganCapaldo> Should sell tickets
20:54:35 <jfoutz> you should make a special captua that is the solution to the problem
20:54:42 * wagle_ starts popping popcorn
20:55:12 <jfoutz> that way, people who want to erase them, morally, have to solve them
20:55:18 <Cale> I wonder if I should mark the change as minor, so it doesn't show up in RecentChanges :)
20:55:34 <Maddas> jfoutz: That's no problem, they can take the solution from the wiki page they want to erase it from.
20:55:44 <LoganCapaldo> fork the wiki
20:55:54 * Maddas makes a mental note not to visit the haskell wiki before attempting to solve the euler problems :-)
20:56:07 <LoganCapaldo> Spoilerz
20:56:11 <wagle_> make a honeypot wiki
20:56:38 <dons> lispy are you running piespy?
20:56:44 <lispy> dons: yes i am
20:56:54 <dons> do you know if it can suck up logs?
20:57:01 <dons> or does it only process live data?
20:57:07 <lispy> dons: good question
20:57:17 <lispy> dons: it's open source, so yes it can process logs :)
20:57:20 <lispy> it's in java tho
20:57:23 <dons> well, java :)
20:57:33 <dons> does it even provide the src? (or just .jar?)
20:57:39 <lispy> does the log have time stamps? I know one part of the algo is to look at time between responses
20:57:58 <lispy> i think the source is available, let me check, http://www.jibble.org/piespy/
20:57:58 <lambdabot> Title: PieSpy - Inferring and Visualizing Social Network on IRC
20:57:59 <dons> yeah, the logs look like the live channel messages
20:58:23 <dons> here's our logs, http://www.cse.unsw.edu.au/~dons/irc/haskell/
20:58:24 <lispy> PieSpy-0.4.0.zip (Full Java implementation with source-code)
20:58:25 <lambdabot> Title: Index of /~dons/irc/haskell
20:58:30 <dons> it'd be interresting to get month-by-month snapshots
20:58:45 <lispy> well, the settings i'm using have a decay
20:58:52 <lispy> so they're really only good live
20:58:59 <lispy> connections decay kinda fast
20:58:59 <dons> yep
20:59:12 <lispy> so how would you tweak it to give a good monthly snap-shot?
21:00:02 <lispy> It may even be easier for us haskell geeks if we read their paper + source and reimplemented in Haskell and did our output via cairo or something
21:00:11 * ddarius would be most interested in full term results with, perhaps, people who haven't logged in for a (long) time trimmed.
21:00:29 <lispy> ddarius: so, no decay?
21:01:17 <Cale> done.
21:01:35 <lispy> Cale: solved the halting problem?
21:01:39 <Cale> lispy: yes.
21:01:58 <Cale> Well, really I just reverted all the recent vandalism to the Haskell wiki.
21:02:53 <shachaf> Cale: Now, making them stop, *that's* a proper halting problem. :-)
21:03:00 <lispy> dons: how about this, I'll run it for a while without decay and we can see if it produces gibbrish
21:03:40 <ddarius> lispy: Essentially.
21:04:02 <ddarius> Really multiple scales would be interesting.
21:06:29 <lispy> I just set temporaldecay to 0, so I think that will make connections perament
21:07:21 <LoganCapaldo> Stopping time!
21:07:24 <LoganCapaldo> gasp
21:07:28 <ac> say you want to modify one field baz in record bar, which is inside record foo. Is there a better way than: foo { bar = (bar foo) { baz = x } } --?
21:08:05 <LoganCapaldo> record syntax is my favorite part of haskell
21:08:08 <lispy> ac: just update one field? there is way
21:08:24 <lispy> ac: and that's not it :)
21:08:52 <LoganCapaldo> bar foo { baz = x } -- does this work?
21:09:13 <oerjan> ac: i doubt it
21:09:15 <LoganCapaldo> not the way he wants probably
21:09:17 <ac> LoganCapaldo: that returns the inner record
21:09:27 <ac> I want the outer record
21:09:29 <LoganCapaldo> -XDWIM
21:09:33 <ac> lol
21:09:59 <lispy> oh, i see
21:10:02 <mgsloan> pointfree records would be fun
21:10:02 <lispy> the problem is the nesting
21:10:13 <lispy> ac: I misread your original question, sorry
21:10:27 <dons> lispy, yeah, i'd be interested in seeing hubs of longer term activity, (i.e. monthly, weekly). though the current system is great for seeing who's talking to who atm
21:10:40 <ac> mgsloan: indeed
21:11:09 <lispy> dons: their parameters are hard to tweak (ie, their model could be more transparanet)
21:12:18 <LoganCapaldo> foo.bar.baz = x --win! :p
21:12:40 <ac> @hoogle [a -> a] -> a
21:12:41 <lambdabot> No matches, try a more general search
21:12:58 <Cale> :t foldr (.) id
21:13:00 <lambdabot> forall a. [a -> a] -> a -> a
21:13:04 <LoganCapaldo> @type head . map fix
21:13:04 <lambdabot> forall a. [a -> a] -> a
21:13:21 <ac> Cale: I was just thinking I wanted foldr id
21:13:27 <lispy> ?djinn [a -> a] -> a -> a
21:13:27 <lambdabot> f _ a = a
21:13:37 <ac> er, compose
21:14:04 <ac> lispy: ha
21:14:19 <Cale> :t fix . foldr (.) id
21:14:19 <LoganCapaldo> @type appEndo . mconcat . map Endo
21:14:19 <lambdabot> forall a. [a -> a] -> a
21:14:20 <lambdabot> forall a. [a -> a] -> a -> a
21:15:16 <dolio> @type sequence :: [a -> a] -> a -> a
21:15:17 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
21:15:17 <lambdabot>            against inferred type `[a]'
21:15:17 <lambdabot>       `a' is bound by the polymorphic type `forall a. [a -> a] -> a -> a'
21:15:27 <ac> so "foldr (.) id" isn't predefined anywhere? What's a good name for that?
21:15:33 <Cale> compose
21:15:40 <Cale> Or perhaps  composition
21:15:45 <Cale> (to go with product and sum
21:15:46 <Cale> )
21:15:46 <ac> I would call it sequence, but that's already taken
21:16:00 <Cale> sequence does something else :)
21:16:02 <lispy> Cale: composition or composite?
21:16:05 <ddarius> A new djinn?
21:16:06 <sciolizer> pipe?
21:16:13 <LoganCapaldo> chain
21:16:17 <ac> I like chain
21:16:20 <wagle_> compose1?
21:16:26 <LoganCapaldo> composel
21:16:36 <ac> composel is also nice ;)
21:16:38 <Cale> There's no difference between l and r,
21:16:39 <wagle_> its composing first args
21:16:46 <Cale> since composition is associative
21:16:47 <LoganCapaldo> l = list
21:16:51 <Cale> ah
21:16:51 <LoganCapaldo> not left
21:17:00 <Cale> composeL perhaps in that case :)
21:17:06 <Cale> hehe
21:17:14 <oerjan> ah but then compose should be on Foldables ...
21:17:15 <Cale> (Don't ask me why that makes more sense to me)
21:17:26 <LoganCapaldo> m_pszCppProgrammer
21:17:37 <Cale> I think composition is slightly better than compose, but it's also longer.
21:17:46 <LoganCapaldo> composing
21:17:48 <Cale> no
21:17:51 <Cale> not composing :)
21:17:56 <LoganCapaldo> decomposing
21:18:03 <LoganCapaldo> mozart
21:18:11 <oerjan> LoganCapaldo: i was _trying_ not to say that
21:18:19 <LoganCapaldo> they dug him up, and he was erasing all his music
21:18:29 <Cale> 'composition' goes well with the names 'sum' and 'product'
21:19:18 <ddarius> mconcat
21:19:37 <LoganCapaldo> ddarius: totally with you on that one
21:19:50 <lispy> ?type foldl . id
21:19:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:20:01 <Cale> ddarius: Except you need to wrap with Endo
21:20:01 <LoganCapaldo> appEnd . mconcat . map Endo is clearly too much typing
21:20:13 <LoganCapaldo> *appEndo
21:20:14 <lispy> ?type foldl (.) id
21:20:15 <lambdabot> forall a. [a -> a] -> a -> a
21:20:20 <oerjan> :t Data.Foldable.foldr (.) id
21:20:20 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
21:20:29 <lispy> Cale: wouldn't foldl1 be more efficient if the left vs. right doesn't matter?
21:20:32 <Cale> You definitely want it composed to the right.
21:20:38 <lispy> i meant fold`
21:20:41 <lispy> er, fold'
21:20:44 <Cale> foldr is better
21:20:53 <Cale> Because the functions will be applied outermost first.
21:21:05 <Cale> > foldr (.) id $ repeat (1:)
21:21:06 <lambdabot>  <[Integer] -> [Integer]>
21:21:14 <Cale> > (foldr (.) id $ repeat (1:)) []
21:21:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:21:28 <Cale> > (foldl' (.) id $ repeat (1:)) []
21:21:31 <lambdabot> Terminated
21:21:45 <LoganCapaldo> Come with me if you want to live
21:21:54 <Cale> heh
21:21:57 <lispy> same for lazy foldl i guess
21:22:00 <jfoutz> it's weird that simple recursion is the right answer.
21:22:05 <lispy> > (foldl (.) id $ repeat (1:)) []
21:22:08 <lambdabot> Terminated
21:22:08 <Cale> lispy: right, tail recursion is bad :)
21:22:11 <jfoutz> i'm so used to building an accumulator
21:22:19 <ddarius> jfoutz: Stop being used to it.
21:22:20 <Cale> jfoutz: Outermost first evaluation changes that :)
21:22:29 * jfoutz nods
21:22:37 <lispy> Cale: so, maybe we want composition and composition', the latter for efficient finite cases
21:22:43 <wagle_> :t foldr (,) id [(+),(+),(+)]
21:22:44 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
21:22:44 <lambdabot>       Expected type: a -> b -> b
21:22:44 <lambdabot>       Inferred type: a -> b -> (a, b)
21:22:44 <ddarius> jfoutz: People complain about lazy languages having space leaks.  Strict languages have dual ones.
21:22:46 <Cale> lispy: It won't be any faster.
21:23:02 <wagle_> :t foldr (.) id [(+),(+),(+)]
21:23:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:23:03 <lambdabot>     Probable cause: `+' is applied to too few arguments
21:23:03 <lambdabot>     In the expression: (+)
21:23:13 <Cale> er...
21:23:13 <jfoutz> ddarius: i've never thought of it that way... neat.
21:23:15 <LoganCapaldo> @type (.)
21:23:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:23:19 <oerjan> to make it faster it would have to foldl' (flip id)
21:23:19 <lispy> Cale: well, i know foldl' is faster is some cases, so why not here?
21:23:20 <Cale> lispy: hmm, perhaps
21:23:22 <LoganCapaldo> @type (+)
21:23:22 <lambdabot> forall a. (Num a) => a -> a -> a
21:23:37 <Cale> lispy: If it forced the application of the functions to the eventual argument too
21:23:39 <LoganCapaldo> a -> a -> a /= a -> a
21:23:40 <wagle_> :t (+) . (+)
21:23:40 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
21:23:57 <Cale> lispy: then it could be better in many finite cases
21:24:06 <oerjan> oh wait
21:24:17 <oerjan> :t foldl' (flip id)
21:24:17 <lambdabot> forall c. c -> [c -> c] -> c
21:24:28 <Cale> It can't just be foldl' (.) id though.
21:24:32 <wagle_> :t foldr
21:24:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:24:36 <Cale> That's just building up a function strictly.
21:24:55 <LoganCapaldo> :t flip (foldl' (flp id))
21:24:56 <lambdabot> Not in scope: `flp'
21:25:02 <oerjan> > foldl' (flip id) 3 . map (+) $ [1..10]
21:25:03 <lambdabot>  58
21:25:38 <LoganCapaldo> :t flip $ foldl' $ flip id
21:25:39 <lambdabot> forall c. [c -> c] -> c -> c
21:25:41 <oerjan> :t foldr id
21:25:42 <lambdabot> forall b. b -> [b -> b] -> b
21:25:57 <LoganCapaldo> neato
21:26:39 <lispy> flip has some interesting properties as i recall
21:26:43 <lispy> :t flip flip flip
21:26:44 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
21:26:45 <lispy> :t flip flip flip flip
21:26:46 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
21:26:46 <kmcallister> @pl \i -> (i,i)
21:26:46 <lambdabot> join (,)
21:26:55 <Cale> @let composeRev' fs x = foldl' (\y f -> f y) x fs
21:26:56 <lambdabot> Defined.
21:27:01 <wagle_> :t foldr (.) id [(+),(+),(+)]
21:27:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:27:02 <lambdabot>     Probable cause: `+' is applied to too few arguments
21:27:02 <lambdabot>     In the expression: (+)
21:27:03 <kmcallister> :t join
21:27:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:27:10 <oerjan> @check \l x -> foldr (.) id l (x::Int) == foldr id x l
21:27:11 <lambdabot>  OK, passed 500 tests.
21:27:14 <oerjan> yay
21:27:16 <wagle_> :t (+)
21:27:16 <lispy> :t (flip, flip flip, flip flip flip, flip flip flip flip, flip flip flip flip flip)
21:27:17 <lambdabot> forall a. (Num a) => a -> a -> a
21:27:17 <lambdabot> forall a b c a1 b1 c1 a2 c2 a3 b2 c3 a4 b3 c4 a5 c5 a6 b4 c6 a7 c7. ((a -> b -> c) -> b -> a -> c, b1 -> (a1 -> b1 -> c1) -> a1 -> c1, (a2 -> ((a3 -> b2 -> c3) -> b2 -> a3 -> c3) -> c2) -> a2 -> c2,
21:27:17 <lambdabot> (a5 -> ((a4 -> b3 -> c4) -> b3 -> a4 -> c4) -> c5) -> a5 -> c5, (a7 -> ((a6 -> b4 -> c6) -> b4 -> a6 -> c6) -> c7) -> a7 -> c7)
21:27:24 <ddarius> flip is the isomorphism is for a self-adjoint functor
21:27:27 <Cale> > composeRev' [(1:), (2:), (3:)] []
21:27:28 <lambdabot>  [3,2,1]
21:27:41 <wagle_> :t foldl (.) id [(+),(+),(+)]
21:27:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:27:42 <lambdabot>     Probable cause: `+' is applied to too few arguments
21:27:42 <lambdabot>     In the expression: (+)
21:27:50 <lispy> putting all in one tuple was a bad idea, but you kinda get the point
21:27:50 <Cale> > composeRev' [(n+) | n <- [1..10000]] 0
21:27:51 <lambdabot>  50005000
21:27:53 <LoganCapaldo> @type let (.) f g = flip (foldr id) [f, g] in (.)
21:27:54 <lambdabot> forall a. (a -> a) -> (a -> a) -> a -> a
21:27:54 <Cale> > composeRev' [(n+) | n <- [1..10000000]] 0
21:27:58 <lambdabot> Terminated
21:27:59 <lispy> it repeats after a while
21:28:00 <Cale> oops
21:28:02 <LoganCapaldo> oh drat
21:28:02 <Cale> > composeRev' [(n+) | n <- [1..1000000]] 0
21:28:03 <pjd> wagle_: foldr (.) id :: [a -> a] -> a -> a
21:28:04 <lambdabot>  500000500000
21:28:06 <LoganCapaldo> stupid (:)
21:28:27 <pjd> wagle_: it must be a list of (a -> a), the same type to the same type
21:28:39 <pjd> wagle_: (+) is a -> (a -> a)
21:28:51 <Cale> @let compose = foldr (.) id
21:28:51 <lambdabot> Defined.
21:28:55 <Cale> > compose [(n+) | n <- [1..1000000]] 0
21:28:57 <lambdabot>  Exception: stack overflow
21:29:23 <pjd> wagle_: that is, the input (a) is not the same as the output (a -> a)
21:29:24 <ddarius> The monad for the adjunction that flip gives rise to is the continuation monad.
21:29:24 <Cale> (but composeRev' is backwards, and that's not so easy to fix efficiently)
21:29:35 <LoganCapaldo> > sum [1..1000000]
21:29:36 <lambdabot>  500000500000
21:29:55 <pjd> wagle_: if you think about it, foldl (.) id [(+),(+),(+)] would have to change type depending on the length of the list
21:30:17 * LoganCapaldo is being :: (a -> b -> c) -> b -> a -> c
21:30:29 <lispy> dons: coming up with a log parser wouldn't be too hard, I think you could actually use regular expressions (which java support now)
21:30:48 <ddarius> lispy: Supports in what way?
21:30:52 <pjd> ddarius: good heavens
21:30:54 <lispy> ddarius: as a library
21:31:16 <pjd> ddarius: where can one find a reasonably patient explanation of that?
21:31:42 <lispy> ddarius: the piespy bot is in java and dons suggesting having it infer from the logs instead of from real-time so we could do daily, weekly and monthly, yearly compilations of social networks
21:31:48 <kmcallister> @pl \x -> [x,x]
21:31:48 <lambdabot> ap (:) return
21:32:06 <ddarius> lispy: Surely there was a regex library for Java many years ago.
21:32:20 <lispy> ddarius: i think it was released with 1.4 or 1.5 actually
21:32:33 <LoganCapaldo> @type repeat 2
21:32:33 <lambdabot> forall t. (Num t) => [t]
21:32:47 <lispy> instead of, say, 1.0 or 1.1, or even the first version that really made java popular 1.2
21:32:53 <LoganCapaldo> @type replicate 2
21:32:53 <lambdabot> forall a. a -> [a]
21:33:13 <LoganCapaldo> > replicate 2 "x"
21:33:14 <lambdabot>  ["x","x"]
21:33:35 <LoganCapaldo> why do I always confuse replicate and repeat?
21:33:50 <jcreigh> because they're similar?
21:33:53 <oerjan> LoganCapaldo: you are repeatedly confused
21:34:00 <lispy> but, you could easily look at all lines that start with "dd:dd:dd <" and ignore everything else, compute the difference (in seconds) between the two lines and hopefully feed the resulting data set to their engine
21:34:03 <wagle_> pjd: i've seen multi-argument functions composed with other functions (but find it confusing)
21:34:20 <pjd> wagle_: sure, but those are in static contexts
21:34:38 <lispy> wagle_: yeah, i think pointfree monads are confusing often, and that's with just 1 chain of parameters
21:35:06 <LoganCapaldo> @djinn Either a b -> Maybe b
21:35:07 <lambdabot> f a =
21:35:07 <lambdabot>     case a of
21:35:07 <lambdabot>     Left _ -> Nothing
21:35:07 <lambdabot>     Right b -> Just b
21:35:45 <LoganCapaldo> @djinn a -> Maybe b -> Either a b
21:35:45 <lambdabot> f a b =
21:35:46 <lambdabot>     case b of
21:35:46 <lambdabot>     Nothing -> Left a
21:35:46 <lambdabot>     Just c -> Right c
21:35:50 <oerjan> :t either (const Nothing) Just
21:35:50 <lambdabot> forall a b. Either a b -> Maybe b
21:36:05 <lispy> hehe, this is definitely java code: BinarySequenceInferenceHeuristic.java, IndirectAddressingInferenceHeuristic.java
21:36:09 <lispy> I love those names
21:36:31 <LoganCapaldo> @type f a b = Left a
21:36:32 <lambdabot> parse error on input `='
21:36:41 <lispy> dons: $ cat *.java | wc -l
21:36:41 <lispy> 1568
21:36:44 <BMeph> wagle: I've found that it helps to use a clever trick I think came from conal (but might have come from Oleg AFAIRK).
21:36:52 <LoganCapaldo> @type \a b -> Left a
21:36:53 <lambdabot> forall t a b. a -> t -> Either a b
21:36:54 <lispy> dons: not even that much code here in java, this shouldn't be that hard to convert or even port
21:37:40 <conal> BMeph: what trick?
21:37:46 <pjd> lispy: ...FactoryFactory?
21:37:47 * lispy waits for the trick too
21:37:53 <LoganCapaldo> I wonder how djinn decides not to be lazy? Is there a rule that says if you can use a parameter, you must?
21:38:02 <LoganCapaldo> and what counts as using anyway?
21:38:02 <lispy> pjd: I have seen those in the past, but I don't see any here :)
21:38:03 <BMeph> wagle: Use the definition result = (.), you get multi-argument functions to composed with repeated "result" apps.
21:38:24 <lispy> LoganCapaldo: well, appearing in the body of the function
21:38:28 <conal> BMeph: yep.  that's one of mine.  and mixing with first and second.
21:38:50 <conal> you can synthesize the composition chains right from the type.
21:38:58 <ddarius> pjd: Hayo Thielecke's PhD thesis might be interesting reading and the adjunction and monad are important to various applications, but I'm not aware of a paper/intro that points out the third simple adjunction that cartesian closed categories always have (at least assuming a reasonable bit of naturality).
21:39:06 <LoganCapaldo> @type \a b -> case b of { Just _ -> Left a ; Nothing -> Left a }
21:39:07 <lambdabot> forall t a b. a -> Maybe t -> Either a b
21:39:13 <lispy> could you give an example and explain a bit more? I don't follow from "definiton result = (.)"
21:39:14 <ddarius> pjd: It's probably best just to work through it yourself.
21:39:32 <LoganCapaldo> now b "appears", sort of
21:39:55 <pjd> ddarius: that could take some doing :)
21:39:58 <pjd> ddarius: thanks for the pointers
21:39:59 <LoganCapaldo> I just find it interesting that it managers to do so well sometimes
21:40:29 <ddarius> pjd: Are you somewhat comfortable with adjunction and cartesian closure?
21:40:33 <oerjan> LoganCapaldo: i vaguely recall someone mentioning something about it using linear types
21:40:39 <LoganCapaldo> and other times it just sorta goes f a _ _ = a
21:40:45 <pjd> ddarius: not yet, no
21:40:58 <conal> lispy: suppose you want \ a b -> foo (bar a b c) .  That is, you want to apply foo to the result of the result of bar.  so you say (result.result) foo bar .
21:41:11 <ddarius> (Actually, this expands to symmetric monoidal category.  In fact, moving from a monoidal category to a symmetric monoidal category adds exactly this adjunction.)
21:41:33 <ddarius> (Er [symmetric] monoidally closed category)
21:41:49 <conal> lispy: oops.  drop the c.
21:41:49 <LoganCapaldo> night
21:42:02 <lispy> conal: oh, right
21:42:15 <lispy> conal: I think I see now.
21:42:27 <pjd> ddarius: "Categorical Structure of Continuation Passing Style"?
21:42:33 <ddarius> pjd: Yes.
21:42:43 <conal> lispy: or if bar :: a -> b -> (c,d), foo :: c -> e, do (result.result.first) foo bar
21:43:19 <conal> lispy: or if bar :: a -> b -> (c,d -> e), foo :: e -> f, do (result.result.second.result) foo bar
21:43:49 <lispy> dons: and the good news is that I think they had a good design and separated the bot from the inference engine...
21:43:51 <conal> the combinator sequence is the path in the type.
21:44:15 <conal> more examples at http://darcs.haskell.org/packages/DeepArrow/doc/html/Control-Arrow-DeepArrow-Examples.html
21:44:17 <lambdabot> http://tinyurl.com/24aunc
21:44:53 <lispy> :t result
21:44:53 <lambdabot> Not in scope: `result'
21:45:25 <conal> lispy: result is a method on DeepArrow.  For (->), result = (.)
21:45:38 <lispy> is ~> a haddock-ism?
21:45:40 <conal> these combinator chains are the key to Eros (http://conal.net/papers/Eros)
21:45:41 <lambdabot> Title: Tangible Functional Programming
21:46:00 <conal> lispy: it's just an infix type constructor variable.
21:46:19 <lispy> for which type? arrow?
21:46:47 <conal> lispy: for all binary type constructors in DeepArrow.  DeepArrow is a subclass of Arrow.
21:47:41 <conal> lispy: for instance, (->, pairs of deep arrows, and "interface" transformations (see http://haskell.org/haskellwiki/TV).
21:47:55 <conal> s/(->/(->)
21:48:44 <conal> using those combinators, you can transform not only functions, but also user interfaces for those functions.
21:48:50 <lispy> that's more information than i can process :)
21:49:03 <conal> okay.
21:49:16 <kmcallister> in GHCi how do i execute an IO action and bind its value to a variable without printing it?
21:49:19 <lispy> It looks like good stuff, but I don't have a grasp on arrows yet :(
21:49:51 <lispy> kmcallister: that was the default in older ghci
21:49:52 <conal> lispy.  if you play around with "first" on functions, you'll get a feel.
21:50:10 <conal> "first", "second", and "result" (aka (.)) are "editor combinators"
21:50:11 <kmcallister> i'm using 6.6.1
21:50:53 <lispy> kmcallister: yeah, 6.4 didn't have this behavior...I think someone recommended something for this, but I can't recall...I think, you do the binding and then >> ()
21:51:31 <pjd> kmcallister: x <- getLine
21:51:33 <pjd> or similar
21:51:39 <conal> :type (.)
21:51:46 <pjd> err, oh, without printing it
21:51:46 <kmcallister> pjd, that prints the result
21:51:47 <conal> @type (.)
21:51:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:52:24 <conal> or: (b -> c) -> ((a -> b) -> (a -> c)),  which is very similar to the types of first and second, on functions.
21:52:52 <lispy> kmcallister: actually jsut testing it on 6.6 here, let x = return [1..50] :: IO [Int], produced no output for me
21:52:57 <conal> first :: (b -> c) -> ((a,b) -> (a,c))
21:53:11 <conal> oops:  first :: (b -> c) -> ((b,a) -> (c,a))
21:53:21 <conal> second :: (b -> c) -> ((a,b) -> (a,c))
21:53:27 <kmcallister> lispy, sure, but that's not the same as binding an action into the GHCi implicit do block
21:53:41 <lispy> kmcallister: what is the syntax for what you're doing?
21:53:53 <kmcallister> to actually use the value of x i'd have to do something like y <- x, which will have the same effect as y <- return [1..50] and will print the value
21:54:51 <kmcallister> lispy, x <- m
21:55:01 <lispy> okay, i'm trying some things now
21:56:16 <lispy> kmcallister: hmm...yeah, I think there was a work around for this though
21:56:26 <wagle_> anyone tried to recover a macosx file system thats had a blank filesystem written over the top of it?
21:56:57 <lispy> wagle_: no, but gnu parted is probably where i would start looking, or sysrescuecd
21:57:05 <Cale> I'm really going to have to actually try out conal's awesome libraries at some point. :) Reactive looks really neat.
21:57:12 <lispy> sysrescue cd is pretty handy
21:57:34 <lispy> Cale: do you know the answer to kmcallister's question?
21:57:49 <Cale> oh, yes
21:58:07 <Cale> :set -fno-print-bind-result
21:58:15 <Cale> (you can add that to your ghci)
21:58:16 <kmcallister> Cale, thanks
21:58:20 <Cale> er, .ghci
21:58:23 <kmcallister> nah, i just want it for this one monster computation
21:58:35 <lispy> thanks cale
21:58:43 <Cale> I got really annoyed with it printing the results of my IO actions.
21:58:47 <kmcallister> it would be nice if there were something like -fno-print-bind-result-if-line-ends-in-semicolon
21:58:58 <Cale> Heh, a mathematica user?
21:59:12 <kmcallister> Cale, occasionally (and unfortunately)
21:59:26 <Cale> er, actually, it seems that doesn't work for me anymore on 6.8.2
21:59:37 <kmcallister> it works on 6.6.1
21:59:38 <Cale> I wonder why...
21:59:44 <Cale> Yeah, it used to work.
22:00:23 <Cale> I wish GHCi would just not print the results automatically. If I wanted to do that, I'd have bound the computation to print.
22:00:38 <Cale> But there's no way to divide by print :)
22:01:35 <conal> Cale: please let me know if you do. :)
22:02:13 <Cale> conal: I wonder how much work it would be to build something like a mathematica frontend for GHC.
22:02:34 <shachaf> Cale: Mathematica frontend in what way?
22:02:36 <conal> Cale: mma notebooks?
22:02:43 <Cale> Yeah, similar to that.
22:02:46 <shachaf> Cale: There's Sage, which has Haskell support, if that's what you mean.
22:02:53 <conal> Cale: or their new FRPy stuff, maybe?
22:02:57 <Cale> yeah
22:03:05 <conal> shachaf: what's that?
22:03:10 <Cale> (well, both, starting with a notebook-like interface)
22:04:35 <kmcallister> is there any module which provides a function \k -> sortBy (\a b -> compare (k a) (k b)) ?
22:04:50 <kmcallister> @hoogle (Ord b) => (a -> b) -> [a] -> [a]
22:04:51 <lambdabot> No matches, try a more general search
22:04:56 <kmcallister> @hoogle (a -> b) -> [a] -> [a]
22:04:56 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
22:04:56 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
22:04:56 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
22:04:59 <shachaf> kmcallister: Is sortBy (compare `on` k) close enough?
22:05:04 <kmcallister> :t on
22:05:11 <Cale> kmcallister: comparing
22:05:14 <lambdabot> Not in scope: `on'
22:05:19 <Cale> In Data.Ord
22:05:26 <Cale> sortBy (comparing f)
22:05:39 <kmcallister> Cale, thanks
22:05:51 <kmcallister> shachaf, where does "on" come from?
22:05:54 <shachaf> comparing = compare `on` with GHC >6.6.
22:05:59 <shachaf> kmcallister: Data.Function.
22:06:08 <shachaf> on (*) f = \x y -> f x * f y
22:06:41 <wagle_> the tools i'm finding will find the files, but not the directories..  so all i get is a big pile of nameless files, sorted by type
22:06:56 <kmcallister> on :: (a -> a -> c) -> (a -> b) -> b -> b -> c ?
22:07:23 <Cale> on :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:09:22 <BMeph> Smooth - so comparing is on compare, then. :)
22:10:28 <Cale> BMeph: yeah, but on is intended as an infix operator, so you'd write (compare `on`)
22:11:00 <Cale> The other major case is ((==) `on`)
22:12:05 <Cale> @pl \x y -> f x * f y
22:12:05 <lambdabot> (. f) . (*) . f
22:12:24 <Cale> @pl \f x y -> f x * f y
22:12:24 <lambdabot> flip =<< (((.) . (*)) .)
22:12:36 <BMeph> Aww, that's just sad, lambdabot... :|
22:12:38 <shachaf> Cale: on is used in various other cases (((+) `on`), for example).
22:12:56 <shachaf> on++
22:12:57 <Cale> shachaf: You've seen a use like that?
22:13:17 <shachaf> Cale: Well... Maybe not in real code. :-)
22:13:42 <shachaf> You think that'd be that rare?
22:13:52 <Cale> Somewhat, at least :)
22:14:23 <BMeph> Seems kind of interesting to use that with if'...
22:15:00 <lispy> i would say this is some of the most intelligently written java code i've ever looked at
22:16:41 <ricky_clarkson> I found that the best was javac's.. which turned out to be written by Scala's creator :)
22:16:57 <lispy> ricky_clarkson: nice
22:17:51 <shapr> Yay, I got to visit OLPC central!
22:17:56 <cjb> :)
22:17:58 <shapr> Just after the Hacking in Haskell talk.
22:18:01 <lispy> shapr: cool
22:18:05 <shapr> cjb: Thanks for showing me your office!
22:18:12 <cjb> welcome :)
22:18:17 <shapr> cjb: That was soo much fun!
22:18:25 <shapr> I've never seen a beowulf cluster of OLPCs.
22:19:17 <shapr> Too bad I'm too tired to upload all my OLPC pix.
22:20:19 * BMeph tosses fluffy lambdas at shapr
22:20:40 * shapr wraps the fluffy lambdas around himself to keep from freezing in Boston.
22:21:17 <shapr> Anyone in Boston shoud come to part two of Hacking in Haskell on Thursday evening!
22:21:19 <Riastradh> Freezing?  Surely it's not that cold in Boston right now.
22:21:33 <shapr> Riastradh: Whoa, long time no see. What's up with you?
22:21:37 <Riastradh> Hi.
22:21:43 <shapr> Wait, are you in Boston?
22:21:51 <BMeph> That'd be a nice marketing item for CafePress - fluffy lambdas, that is.
22:21:55 <Riastradh> I'm certainly not freezing, and I'm in a colder region than Boston, but near enough that freezing temperatures in Boston would surprise me.
22:22:04 <shapr> Riastradh: Are you near Boston?
22:23:09 <Riastradh> Near enough for the temperature to be close.
22:23:18 <shapr> Riastradh: Coming to part two of Hacking in Haskell @ MIT? http://stuff.mit.edu/iap/#hackhaskell
22:23:19 <lambdabot> Title: SIPB IAP 2008 Activities
22:24:02 <Riastradh> Not in the same state at the moment, though.
22:24:11 <shapr> Aww
22:24:16 <shapr> Will you be back in MA soon?
22:24:35 <Riastradh> Maybe, but only for brief and busy durations.
22:24:49 <shapr> You could be busy meeting me...
22:25:43 <Riastradh> I'm afraid I shall have no time to think of any such business for several months at least.
22:25:51 <shapr> Aw... ok.
22:26:18 <bos> shapr: haskell at MIT?
22:27:08 <cjb> bos: just a few talks, yeah.
22:27:11 <Riastradh> A brief Haskell seminar run by students, not part of the curriculum there.  MIT's curriculum, to the chagrin of many who have no say in it, is turning entirely toward Java and Python.
22:27:30 <cjb> bos: we'll see if we have enough people interested in starting a user group.  there were many (~20) at the talk tonight.
22:27:44 <bos> cjb: nice
22:27:57 <shapr> Riastradh: I think this guy got heckled a bit much by the audience. Primarily Ed and Michael
22:28:01 <cjb> To be honest, I haven't found a programmer who knows Haskell and knows Python and is particularly upset that Python's the teaching language.
22:28:03 <bos> did everyone fall around laughing over the release of arc?
22:28:21 <cjb> (Including myself.)
22:28:31 <shapr> Yeah, Python's not bad.
22:28:42 <cjb> If you want lazy lists, use generators.  If you want map/filter/(crippled) lambda, they're already there.  There's a quickcheck port.  Etc.
22:28:42 <meryrus> Python is a good language.
22:28:43 <Riastradh> shapr, which Ed and which Michael?
22:28:55 <shapr> Riastradh: Um, Edward Kmett and Michael Stone.
22:29:00 <bos> it would be hard to hold much ill will against python. the main people who don't like it are java and ruby programmers.
22:29:07 <Riastradh> OK.
22:29:42 <mgsloan> good thing I didn't even bother applying to MIT, then..
22:29:42 <shapr> I hadn't met Michael Stone in person. Nor had I met Chris Ball, Mad (...?) and several others.
22:30:03 <shapr> mgsloan: Hey, you'd get to hang out with lots of cool people.
22:30:08 <cjb> shapr: Mad Ball, innit.  :)
22:30:17 <mgsloan> true :P and get very very stressed
22:30:20 <davidL> mgsloan: you are applying to colleges too?
22:30:26 <shapr> cjb: Didn't know how the names worked out there. Ed's wife kept hers, for example.
22:30:30 <mgsloan> I've talked to ex-MITers.  both my uncles are :P
22:30:34 <mgsloan> davidL: aye
22:30:37 <dons> bos, the arc release was a bit odd
22:30:41 <mgsloan> probably going to University of Washington
22:30:42 <shapr> dons!
22:30:53 <cjb> Ah, yeah.  Nominally "Madeleine Price Ball"; her mom did the same thing, moving maiden name into middle name.
22:30:53 <dons> i don't understand the ... the whole deal actually
22:30:56 <shapr> dons: You got mentioned at least twice tonight :-)
22:31:01 <davidL> mgsloan: I'm waiting to hear back from UT Austin and University of Waterloo
22:31:10 <mgsloan> ah, cool
22:31:20 <dons> shapr: i did? oh, did you hold the boston hacker meeting?
22:31:28 <shapr> dons: I got a picture of xmond running on cjb's monster monitor!
22:31:33 <dons> hehe awesome.
22:31:36 <shapr> dang keyboard...
22:31:37 <mgsloan> other possibility is Portland State
22:31:43 <davidL> mgsloan: are you working on a writeroom clone? I thought I saw you mention that yesterday
22:31:56 <mgsloan> yep
22:32:01 <mgsloan> just started work yesterday
22:32:12 <mgsloan> hell just thought of doing it yesterday :P
22:32:14 <shapr> I don't know if we'll get enough folks for a Cambridge Haskell User Group, but we may hold regular meetings over beer.
22:32:30 <mgsloan> got it displaying text, and have a decent, Zipper based buffer rep so far
22:32:34 <shapr> In any case, it was lots of fun!
22:32:39 * shapr cheers!
22:32:54 <shapr> And I have lots of pix from the OLPC lab to upload.
22:32:57 <meryrus> zipper based buffers ftw!
22:33:03 <shapr> yay!
22:33:10 <mgsloan> anyone gotten xmonad working on their XO?
22:33:18 <shapr> mgsloan: cjb did!
22:33:20 <mgsloan> I guess I should compile externally
22:33:27 <davidL> yup, there's a screenshot on the site
22:33:30 <mgsloan> yeah, I saw that pic months ago
22:33:31 <mgsloan> yeah
22:33:36 <mgsloan> before G1G1 even
22:33:55 <vegai> hmm, would xmonad on N810 make any sense...
22:33:58 <cjb> yeah, long time ago.  six months or more.
22:34:05 <piojo> hello. does anybody know whether haskell allows me to define a class with a method that does not rigorously define the types of its arguments? for example,
22:34:05 <piojo> class State st where { succs :: st -> (st, a) }
22:34:08 <BMeph> Heh-heh, UWash. Sounds squeaky clean... ;)
22:34:09 <shapr> vegai: Worth trying!
22:34:27 <vegai> shapr: yeah :) I think I'll try that tonight
22:34:31 <mgsloan> cjb - I went to the seattle user group meeting a few days ago.  Was pretty cool, around 20 or 30 people.  Isforinsects was there
22:34:33 <Riastradh> piojo, what could that possibly mean?  (Hint: No.)
22:34:36 <vegai> has anyone packaged ghc for it yet?
22:34:37 <shapr> vegai: Go for it! I want to hear how it goes.
22:34:48 <cjb> mgsloan: oh, neat
22:34:55 <piojo> Riastradh: then i think i have some design problems...
22:35:20 <mgsloan> yeah, actually used the mesh, saw the acoustical ruler work, and that sort of thing :)
22:35:35 <vegai> shapr: ok, I'll let you know how it went
22:35:40 <shapr> vegai: Spiffy.
22:35:42 <Riastradh> piojo, that may be -- perhaps you would be served better by explaining your design than by searching along a dead end path for a nonsensical mechanism.
22:35:44 * shapr falls over asleep.
22:35:54 <vegai> if it is so that I need to build ghc myself, it'll take a while. My build box isn't snappy
22:36:03 <piojo> Riastradh: i'll try, thanks
22:36:23 <kmcallister> vegai, that's a cool idea
22:36:43 <Heffalump> piojo/Riastradh: that's fine, succs is just universally quantified over a
22:36:49 <Heffalump> it's like return :: a -> m a
22:36:50 * Heffalump disappears
22:36:59 <Riastradh> Heffalump, notice that `a' does not occur on the left-hand side of the arrow.
22:37:04 <kmcallister> personally i'm fine with hildon but if i ever decide to drop it, it'll be for something like xmonad
22:37:06 <Heffalump> so?
22:37:07 <mgsloan> davidL - anyway, my idea for a text editor is actually a mishmash of features from various text editors and systems I like
22:37:10 <piojo> Heffalump: the compiler doesn't seem to let me treat it that way
22:37:12 <Heffalump> succs might be hard to implement well
22:37:23 <Heffalump> but if a was in a type class it'd be perfectly reasonable
22:37:26 <Heffalump> anyway, I really have to go
22:37:39 <piojo> okay, thanks anyway
22:38:02 <cjb> mgsloan: the acoustic ruler guy was at our haskell meetup too :)
22:38:19 <cjb> he's a computational physicist, was interested in getting to write fortran code less often
22:39:00 <kmcallister> on a related note, does anyone know if Gtk2Hs code works on hildon?
22:39:06 <Stinger> accoustic ruler guy?
22:39:29 <piojo> i'm trying to write a blind tree search (minimax, actually). i want a "State" class (each state is a node) so that i can write the algorithm to work with multiple problem domains
22:39:33 <mgsloan> cjb - ahah, sweet :)  yeah, isforinsects (seth _) mentioned that he was a cool guy
22:39:55 <cjb> Stinger: There is an OLPC activity that calculates the distance between two XOs by syncing over the network and comparing sent vs. received time for an audio pulse
22:39:55 <Riastradh> piojo, what is `a' supposed to mean here?
22:40:07 <piojo> Riastradh: an arbitrary type
22:40:07 <cjb> (extrapolating to the speed of sound, and on to distance)
22:40:13 <mgsloan> seemed to actually work pretty well
22:40:13 <Riastradh> piojo, for what purpose?
22:40:20 <piojo> i would actually rather it be a class, but that didn't work for me
22:40:25 <cjb> it's accurate within 5% for distances <5m.
22:40:28 <mgsloan> I would have guessed you could get it updating faster
22:40:29 <mgsloan> yeah
22:40:32 <Stinger> oh, hmm
22:40:36 <mgsloan> pretty amazing really
22:41:50 <piojo> Riastradh: the function that is implemented for every member of the class is "successors", and for a (State st), it returns [(st,a)] where "a" is some additional information, like history, or how to get to that state from the starting state
22:42:01 <piojo> at least, that's what i think i want
22:42:06 <piojo> i'm new to haskell
22:42:35 <Riastradh> piojo, is there meant to be one `a' for each instance of the class?
22:42:47 <scook0> @type poke
22:42:48 <lambdabot> Not in scope: `poke'
22:42:53 <scook0> @hoogle poke
22:42:54 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
22:42:54 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
22:42:54 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
22:43:03 <piojo> Riastradh: yes
22:43:25 <piojo> Riastradh: i tried making this happen by specifying the class of "a", but I couldn't make that work
22:43:26 <Riastradh> piojo, if that is so, then what you probably want is multiparameter type classes:  class State st a where { successors :: st -> [(st, a)] }
22:43:55 <Riastradh> Alas, this is a non-standard feature, so its use will limit you to GHC (or whatever other implementations support them; I don't remember which ones do).
22:44:17 <piojo> Riastradh: i can make GHC do it with a command line argument. but is this bad design?
22:46:12 <Riastradh> It can be bad design or it can be good design; that depends on the problem you are trying to solve.  In this case it seems appropriate enough to me.
22:47:32 <kmcallister> piojo, MPTC are considered a pretty essential feature in modern haskell
22:48:00 <piojo> kmcallister: so ghc is just being really conservative by default?
22:48:06 <kmcallister> piojo, yeah
22:48:29 <kmcallister> it sticks to haskell 98 by default, except for a few small things (e.g. hierarchical modules)
22:48:33 <Stinger> (current) standards conforming by default
22:48:58 <kmcallister> you may also need/want a functional dependency, which is written like class State st a | st -> a where ..., and is a promise from you to the type inference system that no two instances with the same "st" will have different "a"
22:49:31 <kmcallister> (i'm not sure if this is appropriate to what you're doing)
22:50:00 <piojo> i think i get it, and it does seem appropriate
22:50:27 <kmcallister> basically a multi-param typeclass is a relation on types, and a fundep specifies that some part of the relation acts like a function
22:51:07 <kmcallister> if it knows this while inferring, it can use the type st to determine the type a, which will greatly reduce the number of annotations you need to write
22:51:18 <piojo> i see
22:52:33 <piojo> i think i will do both of those, then. they seem appropriate.
22:53:09 <piojo> Riastradh and kmcallister, thank you both.
22:53:27 <kmcallister> the general syntax of fundeps is class Foo a b c | a b -> c, b -> a, meaning "a and b together determine c, and b determines a"
22:53:39 <kmcallister> no prob
22:54:44 <kmcallister> (of course that reduces to b -> a, b -> c... i'm not sure if they're equivalent in the compiler though)
22:54:52 <piojo> okay
23:03:25 <mgsloan> though actually I think fundeps will be deprecated in favor of the type family stuff
23:03:54 <kmcallister> mgsloan, do you mean associated types or some other feature?
23:03:54 <mgsloan> it's useful in the meantime.  I used it for my Zipper class today, actually..
23:03:56 <mgsloan> yeah
23:04:11 <mgsloan> the whole boatload of type related stuff presented along with type familes
23:04:48 <mgsloan> yeah, associated type synonym families
23:28:06 <paczesiowa> what do you think about python-like comparisions 1 < x < 3 ?
23:29:05 <vegai> rather nice
23:29:21 <vegai> haskell might be too rigorous to let anything like that in
23:29:28 <allbery_b> neat idea, kinda hard to do sanely in haskell's type system
23:29:39 <Riastradh> How would you generalize that syntactic construction to any operator?
23:29:50 <smack_> maybe something more like "sorted [1,x,3]"
23:29:57 <kaol> what's the semantics of that thing?
23:30:02 <dons> so its folding (<) ?
23:30:12 <Riastradh> Would you have another infix declaration like infixl and infixr, for explaining how to expand a sequence of such operators?
23:30:34 <paczesiowa> I was thinking about type classes magic
23:30:37 <Cale> Possibly...
23:30:42 <wagle_> [1,2,3,4,5] ~~> [1,2,3] , [3,4,5]
23:30:58 <nelhage> I seem to recall that python desugars that to (1 < x) and (x < 3), and it has some weird side-effects.
23:31:05 <conal> what would a /= b /= c  mean?
23:31:07 <allbery_b> kaol: it either produces a value recognized as false (0) or the right hand value (presumably nonzero hence true).  which of course has a problem right at the outset
23:31:13 <nelhage> In [3]: True == 2 < 3 Out[3]: False
23:31:24 <allbery_b> well, depending on how implemented
23:31:27 <paczesiowa> but I tried to implement them and I think it's stupid. e.g. (python) 1==1==2==2 --> False, but 1==1==(2==2) --> True
23:31:32 * allbery_b doesn't do python
23:31:36 <wagle_> conal a /= b & b /= c?
23:32:10 <wagle_> &&
23:32:10 <paczesiowa> not only value depends on "parsing" but also type depends on it
23:32:21 <conal> wagle_: that's probably the most compelling def
23:32:53 <conal> oh -- then the language's semantics is no longer compositional.
23:32:58 <wagle_> i had the feeling it was tried in the 60's or 70's and they thought better of it
23:33:33 <conal> also, those expressions already have meaning for some types.
23:33:43 <kmcallister> > let between o xs = zipWith o xs $ tail xs in all $ between (<) [1,2,3,4]
23:33:44 <allbery_b> the languages where it works have out of band true/false.  (snobol, icon; perl6)
23:33:45 <lambdabot>  Couldn't match expected type `a -> Bool'
23:33:52 <paczesiowa> so if it should be implemented, the only useful version is 1<=x<=3
23:34:20 <conal> paczesiowa: which no longer has compositional semantics.
23:34:53 <paczesiowa> perhaps new operator, not (<=)
23:35:00 <conal> binary?
23:35:27 <wagle_> example of non-compositional?
23:35:27 <kmcallister> > let between o xs = zipWith o xs $ tail xs in all id $ between (<) [1,2,3,4]
23:35:28 <lambdabot>  True
23:35:47 <paczesiowa> yes, but single 1<=2 would result in some wierd type (not useful besides another call to itself)
23:35:58 <kmcallister> > let between o xs = zipWith o xs $ tail xs; cmpAll o xs = all id $ between o xs in cmpAll (<) [1,2,3,4]
23:35:59 <lambdabot>  True
23:36:15 <conal> wagle_: a < b < c isn't semantically compositional, because its meaning isn't a function of the meanings of its sub-expressions.
23:36:16 <wagle_> i dont think 1<=2 is a subexpression of 1<=2<=3
23:36:34 <kmcallister> in python i believe a < b < c is a trinary operator
23:36:48 <kmcallister> it would be sort of nice to have n-ary operators in haskell, although i'm sure they'd get abused
23:36:50 <conal> wagle_: oh -- so a whole new variety of syntactic construct then.  sure.
23:37:12 <conal> perhaps the same kind of construct as the commas in (1,2,3,4)
23:37:30 <wagle_> i guess..  i seem to automatically reject the non-compositionality without thinking
23:37:40 <kmcallister> the operator could be called something silly like (,<,<,)
23:37:47 <conal> yep
23:37:52 <kmcallister> could we section it?
23:38:05 <kmcallister> (a < b < < c)
23:38:13 <kmcallister> this could get ugly
23:38:14 <wagle_> haha.  cool
23:38:26 <conal> btw, i think when i first learned ML, its "," was a binary operator.  ditto for the type "*" operator.  which is pretty elegant.
23:38:41 <kmcallister> yeah
23:39:02 <kmcallister> although i'm not sure it quite holds for "*", because iirc (a * b) * c != a * b * c != a * (b * c)
23:39:16 <kmcallister> in that the first and third are pairs-containing-pairs and the second is a triple
23:39:20 <conal> kmcallister: not sure what holds?
23:39:24 <kmcallister> that * is a binary operator
23:39:33 <kmcallister> type * in ML i mean
23:39:41 <conal> kmcallister: it used to be.  not any more.
23:39:48 <kmcallister> ah
23:39:56 <kmcallister> so all tuples were pairs at some point?
23:40:03 <conal> as i recall
23:40:32 <kmcallister> that's nice from a type theory perspective, but annoying to code with, and i think any attempt to add nice sugar for it would be inferior to just having n-tuples (and i guess they decided the same thing)
23:41:25 <wagle_> <, =, etc arent associative
23:41:26 <conal> kmcallister: maybe.  or it might be just fine to code with, as you can still write (a,b,c,d) in expressions and in patterns.
23:41:57 <conal> maybe the change was just for efficiency, when compilers weren't as smart.
23:42:00 <kmcallister> ah
23:43:19 <conal> having tuples beyond pairs leads to lots of awkwardnesses in haskell.
23:43:36 <conal> e.g., we have fst & snd and first & second.
23:43:44 <conal> but nothing similar for triples
23:43:55 <prb> conal: You can always define trd = \(_,_,s) -> s
23:44:02 <conal> and who can remember which tuple types have Show instances and which don't.
23:44:04 <allbery_b> and if there were thd/thord it couldn't work with fst and snd
23:44:08 <kmcallister> the general solution here is TH
23:44:32 <kmcallister> $(tpl 1 4) => \(_,x,_,_) -> x
23:44:36 <conal> prb: exactly.  you can define it.  it's not standard, so it's not supported with lots of reusuable tools in libraries.
23:44:40 * osfameron thinks tuples are a little inelegant for that reason
23:44:57 <conal> osfameron: because they lack standard lib support?
23:45:04 <wagle_> if you use the < operator on the three numbers 1,2,3, when do you do 1<2, 2<3, when do you do 1<2, 2<3, 3<1, and when do you do 1<2, 2<3, 1<3, and when do you do etc etc etc
23:45:21 <osfameron> conal: because of having  to define functions like fst, snd, trd for every different size tuple you need them for
23:45:28 <kmcallister> wagle_, this is why i'd support syntax more like cmpAll (<) [1,2,3]
23:45:37 <conal> osfameron: got it.  agreed.
23:45:38 <kmcallister> you can define cmpAll, cmpCycle, etc.
23:45:43 <osfameron> then again, if you really want indexable arrays, you could use those..
23:45:47 <kaol> lists, tuples and function parameters are all the same thing, in a sense
23:45:47 <prb> conal: It's never really bothered me; too much stuff in the standard API, and you'll end up with Ruby's String object. :)
23:46:04 <kmcallister> kaol, in most senses they're not though
23:46:16 <kmcallister> especially implementation
23:46:23 <allbery_b> wagle_: snobol/icon/perl6 would do effectively 1<2 & 2<3 (snobol/icon through &fail being a resident of every type, per6 through type shadowing)
23:46:24 <conal> prb: exactly.  and if we used nested pairs instead of tuples, we'd have a small and complete library.
23:46:34 <conal> instead of small *or* complete.
23:47:02 <wagle_> the type of cmp might depend on the kind of ord properties the elements have
23:47:06 * kaol thinks of lisp
23:47:16 <allbery_b> HList?
23:50:25 <paczesiowa> @src (==)
23:50:25 <lambdabot> x == y = not (x /= y)
23:50:36 <paczesiowa> @src (/=)
23:50:36 <lambdabot> x /= y = not (x == y)
23:50:43 <kmcallister> you can also argue that we shouldn't have tuples at all, because if you want n things together you should define an app-specific algebraic type
23:51:04 <wagle_> > pairwise [1,2,3]
23:51:06 <lambdabot>   Not in scope: `pairwise'
23:51:06 <conal> kmcallister: including n==2
23:51:08 <Cale> Pairs are important. Triples, a little less important.
23:51:14 <kmcallister> yeah
23:51:20 <Cale> Quadruples, I've basically never used.
23:51:22 * osfameron sets the rdf dogs loose on Cale
23:51:35 <conal> kmcallister: where do you get the "should"?
23:51:46 <osfameron> nothing wrong with exploratory programming
23:52:05 <osfameron> you might know you need "about n things" and then determine the "proper" type for it later
23:52:47 <kmcallister> conal, i don't necessarily agree with the statement, but more types => typechecker can find more errors
23:53:12 <paczesiowa> osfameron: you have to use lists (with typed lengths) for sufficiently big n
23:53:14 <conal> kmcallister: okay.  i get it.
23:53:34 <kmcallister> sort of like the argument for newtype over type
23:53:59 <kmcallister> ?src (,,)
23:53:59 <lambdabot> Source not found. stty: unknown mode: doofus
23:54:53 <kmcallister> is this essentially correct: data (,,) a b c = (,,) a b c
23:55:12 <conal> yep
