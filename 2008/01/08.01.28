00:00:17 <zeno> functional, elegance, stable, cross platform (probably too hard to get all tho XD)
00:00:56 <conal> the functional GUI libs i know of are phooey, tv, and grapefruit.  all described on the wiki.  e.g.,
00:01:01 <conal> @wiki TV
00:01:01 <lambdabot> http://www.haskell.org/haskellwiki/TV
00:01:46 <conal> zeno: all are cross-platform in theory.  some depend on gtk2hs and some on wxHaskell.
00:02:18 <zeno> ah thanks
00:06:02 <bos> @src (^)
00:06:03 <lambdabot> Source not found. That's something I cannot allow to happen.
00:06:07 <bos> @src (**)
00:06:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:06:10 <bos> hmph
00:06:13 <dmwit> ?src Num
00:06:13 <lambdabot> class  (Eq a, Show a) => Num a  where
00:06:13 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:06:13 <lambdabot>     negate, abs, signum     :: a -> a
00:06:13 <lambdabot>     fromInteger             :: Integer -> a
00:06:30 <dmwit> er?
00:06:36 <dmwit> :t (^)
00:06:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:07:04 <zeno> @src **
00:07:04 <lambdabot> Source not found. My mind is going. I can feel it.
00:07:21 <jeffz> zeno: the other option is to do a web frontend
00:07:33 <dmwit> Well, (^) uses some clever repeated-squaring kind of thing, and (**) is nice and low-level.
00:07:44 <bos> right;.
00:07:59 <bos> i was trying to remember which was which.
00:08:19 <dmwit> Oh, here we go:
00:08:22 <dmwit> ?src Floating
00:08:23 <lambdabot> class  (Fractional a) => Floating a  where
00:08:23 <lambdabot>     pi                                                      :: a
00:08:23 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
00:08:23 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
00:08:23 <lambdabot>     (**), logBase                                           :: a -> a -> a
00:08:27 <sjanssen> oh, and don't forget (^^)
00:08:43 <dmwit> ?src Double (**)
00:08:44 <lambdabot> Source not found. Take a stress pill and think things over.
00:08:47 <bos> you can never have too many exponentiation operators.
00:10:08 <dmwit> (^^) must just be (product .) . replicate or something.
00:10:41 <dmwit> :t (product .) . flip replicate
00:10:42 <lambdabot> forall a. (Num a) => a -> Int -> a
00:11:01 <dmwit> Okay, not quite. =P
00:11:16 <Cale> (^^) accounts for negative exponents
00:11:30 <Cale> (but requires a fractional base)
00:11:49 <Cale> (^) only allows nonnegative exponents, but works with any numeric base
00:14:02 <opqdonut> (product .) . flip genericReplicate
00:14:05 <opqdonut> :t (product .) . flip genericReplicate
00:14:06 <lambdabot> forall a a1. (Num a1, Integral a) => a1 -> a -> a1
00:14:11 <opqdonut> that should do it
00:15:36 <Cale> That'll be (^)
00:17:39 <sudoubungu> FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK I AM HURT I AM HURT I AM HURT
00:17:46 <Cale> what?
00:18:52 <Cale> sudoubungu: If that's as bad as it sounds, you probably shouldn't be bothering to type it on IRC.
00:20:37 <sudoubungu> <iarwain1> i felt something awful feeling and pain in my chest omg what was that. i am too lazy to go to hospital
00:22:11 <Cale> sudoubungu: any Haskell questions?
00:22:28 <jeffz> sudoubungu: chest pains usually indicate heart attack.
00:22:37 <jeffz> however, they are offtopic here...
00:22:49 --- mode: ChanServ set +o bos
00:23:04 <sudoubungu> jeffz> am i going to die soon?
00:23:13 --- mode: bos set +b *!*@99.242.25.*
00:23:14 --- kick: sudoubungu was kicked by bos (bos)
00:23:14 <jeffz> sudoubungu: ask a medical professional.
00:23:20 <bos> troll.
00:23:27 <jeffz> dying troll?
00:23:35 <bos> quiet one, anyway.
00:23:49 --- mode: bos set -o bos
00:28:17 <siti> has anyone got hsplugins going on ghc 6.8.2?
00:28:33 <Cale> I do.
00:28:39 <siti> how?
00:28:59 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
00:29:00 <lambdabot> Title: Index of /~dons/code/hs-plugins
00:31:27 <vegai> EdisonAPI and EdisonCore libraries' cabal files say "License: OtherLicense"
00:31:34 <vegai> anyone know which other?
00:31:48 <siti> Cale: sweet cheers :)
00:33:22 <vegai> looks a bit like public domain
00:34:02 <vegai> ah, most of it is MIT. One file is BSD
00:35:02 <blbrown> @src foldl
00:35:03 <lambdabot> foldl f z xs = lgo z xs
00:35:03 <lambdabot>     where lgo z []     =  z
00:35:03 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:41:24 * Cale grumbles at the bad @src
00:41:34 <vegai> hmm, isn't the fingertree that yi-darcs uses in EdisonCore?
00:41:42 <blbrown> do let expressions delay when the actual operations are invoked?  silly question.
00:42:08 <Cale> blbrown: They just define things.
00:42:23 <Cale> Evaluation of those things happens only when they're needed.
00:42:39 <Cale> (and thus happens no sooner or later than it would have been)
00:43:18 <blbrown> so let z = func 4 .... at this point, func 4 is not called; only when z is used
00:43:26 <Cale> right
00:43:58 <blbrown> I had some code that ran amazingly fast and then I called one particular function and it took 1-2 minutes
00:44:00 <Cale> (specifically, when z is pattern-matched against)
00:44:09 <slarba_> blbrown: and z might not be completely evaluated, for example if it is a list
00:44:28 <blbrown> so that is the lazy evaluation
00:44:29 <slarba_> unless you need the whole list
00:44:54 <Cale> But one thing to remember is that pattern-bound variables in let (and at the top-level), if they're not typeclass polymorphic, will only be evaluated once.
00:45:03 <Cale> Even if they're used multiple times.
00:46:34 <blbrown> good to know, like in my case; program run time increase 400%...but that was because I wasn't testing a particular aspect of the code
00:52:38 <vegai> anyone know if a yi-0.3 release is anywhere near?
00:53:00 <vegai> it seems to have moved quite a lot since the previous release
00:53:27 <lispy> 400% looks bigger than 4x
00:53:37 <lispy> but i guess they are the same
00:54:10 <vegai> 312 changes in darcs this year alone...
00:58:27 <nominolo> vegai: it's being worked on, yes
00:59:11 <nominolo> vegai: but the goal is to have the build be rather easy in order to avoid too much traffic on the mailing list (and frustration of testers)
00:59:33 <nominolo> vegai: it has to be said, though.  it's still not ready for serious use
01:01:59 <nominolo> vegai: it's basically notepad with incremental search and some syntax highlighting ;)
01:07:22 <masklinn> is it me or http://happs.org/ is in a fairly bizarre state?
01:08:36 <dmwit> masklinn: Seems reasonable to me, anything in particular that seems odd to you?
01:11:27 <masklinn> dmwit, I get part of the source code and none of the design
01:11:50 <masklinn> "), urlName = "repos/"+name; url="/proxy/happs.org/"+urlName $.ajax({type: "GET", url: url+"/package-info.xml", dataType: "xml", success: function(xml) { name=$("package-info",xml).attr("name") synopsis=$("package-info > synopsis",xml).text() description=$("package-info > description",xml).text() ver=$("package-info",xml).attr("version") partialTag = "-"+"-partial -"+"-tag="+ver+" "; repo="
01:11:50 <masklinn> darcs get "+ partialTag+ "http://happs.org/"+urlName+" etc...
01:14:05 * dmwit shrugs
01:14:09 <dmwit> WFM
01:27:58 <vegai> nominolo: seems to work basically, though. Screen updates are a bit slow on the GTK frontend
01:28:06 <vegai> nominolo: is that known or should I file a report?
01:28:19 <nominolo> vegai: no idea
01:29:22 <quicksilver> nominolo: I think that's slightly harsh. It's a scriptable notepad.
01:29:37 <quicksilver> nominolo: you can do some slightly interesting things with .hs scripts already.
01:30:14 <quicksilver> Ooh. Who's piespying us?
01:30:21 <quicksilver> I quite like piespys, they're cool.
01:30:23 <quicksilver> I demand to see it!
01:30:32 <lispy> I am
01:30:37 <quicksilver> \o/
01:30:39 <quicksilver> url?
01:30:40 <lispy> but, this is the first run
01:30:47 <lispy> i haven't set any of that jazz up yet :)
01:30:51 <quicksilver> :(
01:30:55 <lispy> working on, i will def. post it
01:31:20 <nominolo> nominolo: don't get me wrong, i'm happy about it's progress and there are some areas where it i'd like to contribute, but it certainly isn't ready for primetime yet (just don't want people to get too high expectations)
01:31:28 <quicksilver> ;)
01:31:33 <quicksilver> nominolo: talking to yourself again?
01:31:37 <nominolo> oops, that was re quicksilver
01:31:46 <Twey> Haha, PieSpy looks interesting
01:32:02 <Twey> I wonder if we can confuse it by saying random things to random people
01:32:29 <dmwit> Yeah, I hope I'm around when the visualization link goes public.
01:32:32 <Twey> quicksilver: But I love you!
01:32:53 <nominolo> hm, so i will be reflexive on that graph ....
01:33:01 <Twey> Heh
01:33:27 <dmwit> I wonder what it will make of \bot.
01:33:57 <nominolo> it'll be the centre of all action
01:34:19 <quicksilver> well people often don't talk to it directly
01:34:27 <nominolo> like, the god of lb, the central authority
01:34:27 <quicksilver> and it generaly doesn't address its responses.
01:34:39 <quicksilver> although piespy has some heuristics to guess who you're talking to
01:34:45 <quicksilver> it's mostly based on mentioning names.
01:36:23 <nominolo> can't that simply be analyzed from the logs?
01:36:44 <nominolo> i mean, they go back 4 years
01:36:52 <tibbe> @src catch
01:36:52 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
01:40:07 <lispy> http://files.codersbase.com/haskell/haskell-current.png
01:40:22 <lispy> http://files.codersbase.com/haskell
01:40:23 <lambdabot> Title: Index of /haskell
01:40:33 <nominolo> lispy: lol
01:40:59 <nominolo> @users
01:40:59 <lambdabot> Maximum users seen in #haskell: 451, currently: 409 (90.7%), active: 8 (2.0%)
01:41:12 <nominolo> i want 409 nodes! ;)
01:41:27 <mauke> monologue
01:41:30 <quicksilver> ;)
01:41:31 <lispy> ?list
01:41:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:41:47 <quicksilver> nominolo: testing...
01:41:52 * quicksilver dances
01:42:00 <quicksilver> nominolo is the centre of the world!
01:42:00 <Twey> Is it possible to do Prolog-esque constraint-based programming in Haskell?
01:42:08 <nominolo> quicksilver: no, you
01:42:09 <Twey> Yay nominolo!
01:42:17 <quicksilver> Twey: ehem. Well. Fundeps are a bit like that.
01:42:24 <quicksilver> Twey: But I don't really recommend programming in fundeps.
01:42:35 <lispy> ?topic-snoc Find yourself in the #haskell social network: http://files.codersbase.com/haskell/haskell-current.png
01:42:36 <lambdabot> I do not know the channel Find
01:42:36 <quicksilver> That's 500 mOleg and above...
01:42:41 <tibbe> @src finally
01:42:41 <lambdabot> a `finally` sequel = block $ do
01:42:41 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
01:42:41 <lambdabot>     sequel
01:42:41 <lambdabot>     return r
01:42:49 <lispy> ?topic-snoc #haskell Find yourself in the #haskell social network: http://files.codersbase.com/haskell/haskell-current.png
01:42:54 <nominolo> oh, it gets updated
01:42:55 <tibbe> @source finally
01:42:56 <lambdabot> finally not available
01:43:03 <Twey> quicksilver: Why so?
01:43:09 <tibbe> @source Exception.finally
01:43:09 <lambdabot> Exception.finally not available
01:43:19 <lispy> nominolo: yeah, which also means it doesn't always load...i just tried a relaod a second ago and it wasn't a fully written file :)
01:43:36 <quicksilver> Twey: because fundeps were not designed as a general purpose programming language :)
01:43:46 <nominolo> Twey: in principle, yes.  but you probably better try Curry
01:43:49 <quicksilver> Twey: it would be like programming in templates in C++
01:44:02 <lispy> anyone with topic priviledges want to add that link to the end of the topic for me?
01:44:39 <Twey> quicksilver: Heh, OK, thanks
01:44:40 <lispy> I fully expect lambdabot to be in the center with dons and Cale around it
01:44:47 <Twey> Probably
01:45:08 <nominolo> Twey: ie, you could write a DSL in Haskell.  SparseCheck uses one, but they were dissed quite a bit at ICFP for not using Curry in the first place ;)
01:45:20 <quicksilver> I talk more than dons!
01:45:23 <quicksilver> ;)
01:45:28 <quicksilver> There are graphs somewhere.
01:45:40 <nominolo> quicksilver: that should tell you something ;P
01:46:00 <quicksilver> lispy: topic looks quite full to me. What shall we lose?
01:46:03 <Twey> Heh... #curry is highly busy
01:46:06 <lispy> oh boy...i may need to tweak the config...this is creating sooo many pngs
01:46:08 <nominolo> wow, just speaking of dons adds him to the social network
01:46:19 <Twey> [@lambdabot] [ Twey]
01:46:25 <quicksilver> lispy: you can always set up a cron to prune old ones
01:46:34 <quicksilver> lispy: although, it's quite fun to uset hem to generate movies :)
01:46:50 <lispy> quicksilver: which software generates movies from pngs?
01:46:57 <quicksilver> good question.
01:46:58 <nominolo> that's called APNG, now
01:47:02 <quicksilver> I bet mencoder can do so.
01:47:06 <lispy> > 20*1024*1000
01:47:10 <quicksilver> ffmpeg might be able to.
01:47:10 <lambdabot>  20480000
01:47:26 <quicksilver> nominolo: I was thinking of mpeg-compressed rather than APNG though.
01:47:34 <quicksilver> more widely viewable and probably much smaller.
01:47:34 <mux> http://perlmonks.org/?node_id=663393
01:47:36 <lambdabot> Title: Perl Cannot Be Parsed: A Formal Proof
01:47:48 <nominolo> quicksilver: flash would be even smaller for this one
01:47:54 <nominolo> (if done right)
01:48:17 <quicksilver> true. But I don't know how to do that.
01:48:22 <lispy> it's generating a png file for every comment in this channel (i think)
01:48:27 <lispy> that's waaay too many :)
01:49:23 <quicksilver> Ah I was wrong. dons does talk more than me :(
01:49:48 <glguy> dons has been the chattiest for some time now
01:50:08 <quicksilver> no, cale is the chattiest
01:50:13 <mux> heh, everytime I enjoy a link from programming.reddit.com, it turns out that dons is the one who posted it
01:50:20 <quicksilver> almost 25% ahead of dons
01:50:31 <glguy> lambdabot, Cale, and dons are typically in the top 3 though, no?
01:50:57 <glguy> or has that changed
01:51:04 * nominolo so likes flyspell-prog-mode
01:51:15 <mux> yay, I'm on that haskellsocialnet png heh
01:51:19 <glguy> nominolo: What is that?
01:52:19 <lispy> there we go, I can't create movies but at least my disk won't fill up now
01:52:21 <nominolo> glguy: it checks spelling in comments and strings
01:52:26 <glguy> quicksilver: when I got added as +o here I was #3 on the activity list
01:52:31 <quicksilver> glguy: yes, lambdabot clear top of course.
01:52:31 <glguy> nominolo: emacs?
01:52:32 * Twey admires Haskell.
01:52:34 * lispy has this fear that if he leaves the archiving on then when he gets up in the morning the drive will be full :)
01:52:35 <nominolo> glguy: yep
01:52:41 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
01:52:42 <lambdabot> Title: #haskell @ freenode.org stats by dons
01:52:56 <glguy> quicksilver: yeah, that page makes me sad now
01:53:02 <quicksilver> glguy: I have been carefully keeping myself in the top 5 for about 18 months and finally got my +o at the weekend :)
01:53:07 <glguy> quicksilver: I've gone from the top to the honorable mentions
01:53:09 <quicksilver> all that talking wasn't for nothing!
01:54:05 <lispy> quicksilver: I don't think anything needs to be removed from the topic.  I think adding the social network link at the end makes sense, down by the link to the logs.
01:54:06 <nominolo> :t (`evalStateT` ())
01:54:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => StateT () m a -> m a
01:54:28 <lispy> quicksilver: hence, why i was trying to topic-snoc
01:55:12 <glguy> Isn't the jobs-in-fp past?
01:55:40 * nominolo is at least on that page
01:55:51 <glguy> (weechat makes it easy to edit the topic in-place, I just discovered)
01:56:10 <lispy> weechat?  or do you mean wiichat?
01:56:18 <glguy> the former
01:56:45 <quicksilver> lispy: I thought we might be close to the 255 char limit
01:56:49 <quicksilver> lispy: but I didn't count
01:56:53 <quicksilver> or whatever the limit is.
01:57:10 <lispy> oh, i had no idea irc put a limit on topics, but yeah it probably does
01:57:31 <glguy> yeah, jobs-in-jp was Dec 14
01:57:33 <lispy> Well, I should be asleep.
01:57:41 <lispy> g'night all!
01:57:59 <nominolo> glguy: but there are pictures now
01:58:15 <quicksilver> 251 chars
01:58:40 <glguy> I guess... just seems like something that's had its time in the spotlight ;)
01:59:01 <quicksilver> removing that doesn't give me enough chars for the piespiy though
01:59:04 <quicksilver> unless I tinyurl it
01:59:10 <quicksilver> but then people woudln't know what it was...
01:59:18 --- mode: ChanServ set +o glguy
01:59:43 --- topic: set to '["Haskell on the Radio: http://tinyurl.com/3ap2hq", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by glguy
01:59:47 <glguy> There you go, now it fits
02:00:35 --- mode: glguy set +o quicksilver
02:00:37 --- mode: glguy set -o glguy
02:02:08 <quicksilver> ;)
02:02:12 * quicksilver cheers
02:03:59 --- topic: set to '["Haskell on the Radio: http://tinyurl.com/3ap2hq", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/", "piespy! http://files.codersbase.com/haskell/haskell-current.png"]' by quicksilver
02:04:03 <quicksilver> There you go.
02:04:53 <nominolo> quicksilver: you could use tinyurl for piespy too
02:05:13 <nominolo> also, there's an extra space after hpaste.org :)
02:05:27 <glguy> How'd I get on that list?
02:05:31 <quicksilver> that's a good idea
02:05:34 <glguy> just by referring to a nick?
02:05:36 <quicksilver> glguy: say something to me :)
02:05:46 <glguy> quicksilver: we're already connected ;)
02:05:47 <quicksilver> ah, you did say something
02:05:48 <quicksilver> yes.
02:05:51 <glguy> hpaste, url
02:05:52 <hpaste> Haskell paste bin: http://hpaste.org/
02:05:54 <quicksilver> it guessed we were talking to me
02:05:59 <glguy> wow, it's fast
02:06:06 <mux> is the file regenerated in real time?
02:06:08 <quicksilver> it rebuilds the png after each comment
02:06:14 <glguy> mux: yes
02:06:21 <quicksilver> mauke: shortly after we first met, I told you perl couldn't be parsed and you disagreed.
02:06:26 <glguy> this can only end in tears
02:06:28 <mux> quite neat
02:06:29 <quicksilver> mauke: mux just posted a link to a proof ;)
02:06:40 <mauke> I disagreed?
02:06:45 <quicksilver> you did, yes.
02:07:07 <funktio> "only perl can parse Perl" :)
02:07:07 <hpaste> lambdabot: get linked!
02:07:07 <mauke> hmm. what was I thinking?
02:07:11 <quicksilver> or that's my memory of the conversation. I could be misrepresenting you. This was about 18 months ago :)
02:07:20 <nominolo> hm, duncan should really be number 6 on the irc stats
02:07:25 <quicksilver> funktio: but even perl doesn't parse Perl. At least not as a separate step.
02:07:36 <quicksilver> funktio: it executes perl, parsing as it goes.
02:07:50 --- mode: ChanServ set -o quicksilver
02:07:50 <quicksilver> nominolo: yeah, he has split his nick.
02:07:55 <quicksilver> nominolo: very foolish if you're aiming for a highscore!
02:08:05 <nominolo> @ho -> Map a b -> Set a -> Set b
02:08:05 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
02:08:11 <nominolo> @hoogle Map a b -> Set a -> Set b
02:08:11 <lambdabot> No matches, try a more general search
02:09:57 <glguy> Can anyone beat "Registered: 3 years 42 weeks 5 days (17h 43m 4s) ago" for /msg nickserv info ______
02:10:09 <glguy> (of those listening)
02:10:23 --- mode: ChanServ set +o quicksilver
02:10:32 --- topic: set to '["Haskell on the Radio: http://tinyurl.com/3ap2hq", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/", "visualise #haskell's social network : http://tinyurl.com/ytzeab"]' by quicksilver
02:10:42 <quicksilver> tinyurl let me give more explanation
02:10:43 <quicksilver> better, IMO
02:10:54 <osfameron> 2 years 36 weeks 6 days (14h 43m 13s)
02:10:56 <osfameron> glguy: I win on seconds!
02:11:07 <osfameron> and days
02:11:46 <glguy> osfameron: /msg hands osfameron a lollipop
02:11:49 --- mode: quicksilver set -o quicksilver
02:12:20 <osfameron> aha, jibbler's irc graphs
02:13:22 <glguy> heh, my mind was wandering when I typed that last one in
02:14:54 <mux> so, is the code generating this "social" graph written in Haskell?
02:15:36 <quicksilver> no
02:15:54 <quicksilver> believe it or not, it's in java
02:16:05 <quicksilver> http://www.jibble.org/piespy/
02:16:05 <lambdabot> Title: PieSpy - Inferring and Visualizing Social Network on IRC
02:18:45 <nominolo> @index (<*>)
02:18:45 <lambdabot> bzzt
02:20:19 <glguy> nominolo: Control.Applicative
02:20:59 <nominolo> yeah.  i wasn't sure, but then realized that i got it confused with the Arrow refactorings
02:21:17 <nominolo> Category and friends
02:24:43 <Cale> What are the edges in this graph?
02:24:54 <shag> is there something that combines parMap and mapM?
02:25:13 <quicksilver> :t parMap
02:25:13 <nominolo> Cale: strength
02:25:15 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
02:25:21 <Cale> shag: Not that I know of -- which generalisation in particular are you looking for?
02:25:26 <Cale> nominolo: of?
02:25:31 <quicksilver> wel the edges are dialog
02:25:34 <nominolo> relationship
02:25:36 <quicksilver> the shortness/boldness is strength
02:25:47 <shag> i just want to perform an IO action on a list of values in parallel
02:25:52 <nominolo> Cale: it's in the gray text
02:25:57 <quicksilver> Cale: edges are either directed conversation, or something piespie guesses to be parallel.
02:26:06 <quicksilver> shag: you should proabbly using forkIO for that.
02:26:10 <mux> shag: I think that in that case you want forkIO
02:26:15 <quicksilver> the par stuff is lightweight thunk-based parallelism
02:26:20 * mux kicks quicksilver for being faster
02:26:21 <Cale> Yes, I see that, but I was asking what "strength of relationship" actually means :)
02:26:22 <quicksilver> forkIO is better for IO action parallelism.
02:26:25 <shag> ok
02:26:27 <shag> thanks
02:26:28 <quicksilver> Cale: number of times you talk, I think.
02:26:31 <nominolo> shag: or unsafePerformIO, if you know that there will be no interaction
02:26:58 <nominolo> shag: but IO usually means, that that order matters
02:27:28 <shag> nominolo: but isnt't that considered "dirty"?
02:27:39 <Cale> Yes it is.
02:27:46 <nominolo> shag: sure it is :)
02:27:47 <Cale> (don't use unsafePerformIO)
02:27:57 <shag> well, i want to send out requests over the network to a bunch of machines which perform some computations
02:28:04 <shag> so the order doesnt really matter
02:28:12 <Cale> Just forkIO the actions.
02:28:13 <nominolo> shag: you have to really make sure it won't violate any assumptions
02:28:28 <shag> i'll have a look on forkIO
02:28:43 <nominolo> yeah, in that case forkIO is way more appropriate
02:28:54 <Cale> There's no point in cheating here with parMap, that's needless and possibly threatening to the correctness of your program.
02:29:21 <nominolo> shag: and it's overhead won't play a role here, since network is much much slower
02:29:32 <shag> ok
02:29:32 <nominolo> *its
02:29:39 <Cale> forkIO doesn't have all that much overhead anyway
02:30:29 <Cale> You'll be up around hundreds of thousands of threads before you start to feel the overhead.
02:30:56 <shag> i think i'll never get my hands onto hundreds of machines ;)
02:31:14 <nominolo> Cale: well, for small computations forking might be noticeable
02:31:44 <Cale> forkIO is for concurrency, not necessarily parallelism, though if you use the threaded runtime, it'll run threads in parallel
02:31:56 <Cale> (On SMP machines)
02:32:49 <quicksilver> only if you ask it to
02:33:03 <quicksilver> but it will suspend IO-blocked thread
02:33:36 <quicksilver> and run others
02:33:49 <quicksilver> so you get decent parallelism of IO-bound threads
02:34:08 <quicksilver> you only need the SMP stuff if you have CPU-bound threads, clearly.
02:35:39 <sjanssen> not so fast
02:35:58 * quicksilver patiently awaits correction.
02:36:01 <sjanssen> SMP will decrease latency, even if you're mostly IO bound
02:36:17 <mux> the social graph is starting to resemble a web
02:36:18 <quicksilver> why's that?
02:36:39 <sjanssen> quicksilver: imagine what happens when two input sources are suddenly ready
02:36:46 * quicksilver nods
02:36:54 <quicksilver> yes, I suppose it depends "how" IO bound you are.
02:37:01 <glguy> if you are trying to make network calls in parallel without -threaded
02:37:02 <osfameron> quicksilver: and you are the spider, apparently
02:37:13 <quicksilver> that is, it depends how much CPU work there is to todo per wakeup
02:37:14 <glguy> wouldn't the forkIO'd threads potentially block
02:37:24 <glguy> as each one performed network IO?
02:37:30 <quicksilver> If you assume the CPU is always less than 20ms
02:37:37 <quicksilver> (which is the ghc rts's default timeslice)
02:37:45 <quicksilver> then you're essentially fine.
02:37:51 <sjanssen> glguy: I think the network library avoids blocking foreign calls
02:37:57 <glguy> ah, ok
02:38:07 <quicksilver> glguy: the default (no-threaded) RTS goes to some lengths
02:38:08 <sjanssen> (do not quote me on that)
02:38:13 <mauke> glguy: IIRC file descriptors are automatically set to nonblocking
02:38:19 <quicksilver> to behave sensibly w.r.t. file descriptor IO
02:38:24 <quicksilver> (which includes sockets)
02:38:25 <Cale> Apparently hpaste and lambdabot are friends with each other but not with anyone else.
02:38:29 <quicksilver> it uses select() behind the scenes.
02:38:36 <Cale> Oh, heh, that connected me to hpaste.
02:38:41 <mux> lambdabot: hi!
02:38:44 <quicksilver> and knows which threads are blocking on which fds.
02:38:51 <Cale> @vixen hello!
02:38:51 <lambdabot> hello there
02:39:06 <quicksilver> hmm. I am the spider.
02:39:14 <mauke> I am the walrus
02:39:23 <osfameron> goo goo gjoob
02:39:24 <Cale> Goo goo ga joob!
02:39:29 <hpaste> glguy sjanssen lambdabot osfameron mauke mux
02:39:35 <mauke> hpaste: cheater
02:39:39 <osfameron> hehe
02:39:52 <glguy> each message only counts for one person
02:39:59 <hpaste> sjanssen
02:40:02 <hpaste> lambdabot
02:40:06 <hpaste> osfameron
02:40:09 <hpaste> mauke
02:40:11 <hpaste> mux
02:40:30 <Cale> hpaste!
02:40:32 <lambdabot> Cale quicksilver mux glguy hpaste osfameron mux
02:40:33 <osfameron> why are we faking the social network?
02:40:43 <glguy> osfameron: curiousity?
02:40:44 <osfameron> shouldn't it just spontaneously arise?
02:40:48 <osfameron> oh
02:40:49 <glguy> (it reset rather quickly)
02:40:53 <osfameron> fair enough :-)
02:41:00 <glguy> resets*
02:41:13 <osfameron> now glguy is the spider
02:41:15 <sjanssen> @seen
02:41:26 <Cale> osfameron
02:41:29 <Cale> glguy
02:41:30 <glguy> sjanssen: each message only links you to at most one other person
02:41:41 <sjanssen> glguy: ah, too bad
02:41:49 <glguy> ChanServ: you rock
02:41:53 <Cale> Heh, we could try to form various platonic solids.
02:42:30 <glguy> set the channel +m so that the whole thing goes blank
02:42:39 <glguy> and then voice people for specific purposes
02:42:47 <ToRA> morning #haskell
02:42:55 <Cale> morning ToRA
02:43:09 <glguy> Cale: you are just trying to link to ToRA!
02:43:17 <Cale> We're playing around with http://files.codersbase.com/haskell/haskell-current.png
02:43:21 <ToRA> yeah i noticed
02:43:25 <ToRA> looks fun
02:43:28 <glguy> malcolmw: hello
02:43:48 <sjanssen> #haskell suddenly becomes a friendlier place
02:43:53 <osfameron> does it only count lines addressed to other people?
02:44:04 <osfameron> or does it also look at lines made in proximity to someone else?
02:44:10 <Cale> I think it's also joining people up when they talk at the same time.
02:44:16 <osfameron> cool
02:44:22 <ToRA> is there a nice data stream available that's backing that image?
02:44:28 <osfameron> that's what I vaguely remembered the last time I looked at jibbler's slides on it
02:45:20 <int-e> ChanServ? Heh, who talks to him :P
02:45:28 <glguy> int-e: I did!
02:45:53 <Cale> What kind of graph drawing algorithm does it use? This looks like possibly a spring model of some kind?
02:45:57 <glguy> hmm, I didn't get credit for talking to int-e
02:46:21 <int-e> funny
02:46:23 <glguy> I wonder if the - in your nick makes it impossible to address you
02:46:23 <sjanssen> glguy: the algorithm is tired of your attention whoring
02:46:39 <glguy> sjanssen: that didn't take long
02:46:58 <mauke> int-e: link
02:47:00 <sjanssen> int-e: can has link please?
02:47:05 <Cale> What didn't take long?
02:47:13 <glguy> for it to get tired of me :(
02:47:23 <int-e> heh, maybe the - character is spoiling that :)
02:47:27 <mauke> looks like you have to do your own linking
02:47:38 <int-e> and you're being linked to somebody called 'int' -- who isn't here.
02:47:48 <int-e> lambdabot: eval 1+1
02:48:14 <Cale> Nice pentagons :)
02:48:18 <int-e> hmm. I still need a command prefix to make that work?
02:48:26 <mauke> @help eval
02:48:26 <lambdabot> eval. Do nothing (perversely)
02:48:32 <sjanssen> ChanServ: I hates pentagons
02:48:54 <int-e> lambdabot: run 1+1
02:48:56 <sjanssen> lambdabot: I still hates them
02:49:02 <int-e> @run 1+1
02:49:03 <lambdabot>  2
02:49:14 <Cale> lambdabot: @run "Hello Cale"
02:49:15 <lambdabot>  "Hello Cale"
02:49:22 <Cale> heh
02:49:46 <int-e> shag could form another pentagon by joining with me :)
02:50:04 <shag> why is that?
02:50:09 <sjanssen> we need to form a complete graph!
02:50:28 <int-e> shag: I don't know, but it worked out nicely.
02:50:29 <Cale> quicksilver and glguy still have a really strong connection
02:50:35 <quicksilver> pentagons may be dull, but a complete pentagon is a pentagram
02:50:44 <quicksilver> and pentagrams are awesome
02:50:47 <shag> i'm afraid i didn't follow this graph-discussion ;)
02:50:52 <Cale> K_5 ftw!
02:50:53 <mux> dcoutts_: I want your name in that graph.
02:50:53 <quicksilver> inside a pentagram, unsafePerformIO is safe!
02:51:14 <sjanssen> shag: all nodes connected to all other nodes
02:51:27 <quicksilver> int-e is linked now.
02:51:30 <quicksilver> odd.
02:51:31 <mux> int-e: hi!
02:51:35 <quicksilver> it must have worked him out.
02:51:35 <mauke> shag: cross link
02:51:48 <sjanssen> mux: what if dcoutts__ isn't awake?  You're ruining my complete dream!
02:51:49 <Cale> int-e gets linked by talking to other people
02:51:52 <mux> heh
02:51:58 <int-e> quicksilver: only to people that I talked to. I really think it's breaking 'int-e' into two words.
02:52:12 <shag> aeh, someone has an url for me to understand this?
02:52:16 <sjanssen> lispy: this graph is fun
02:52:17 <pwned> great, yet another bot to tell me that I am anti-social.
02:52:20 <Cale> http://files.codersbase.com/haskell/haskell-current.png
02:52:37 <sjanssen> mauke: (insert conversation excuse)
02:52:43 <shag> when are links created`
02:52:44 <shag> ?
02:52:45 <int-e> pwned: don't worry, there's room for more people there *g*
02:52:50 <Cale> shag: Apparently people get connected up when they talk to one another.
02:53:01 <shag> ah, i see!
02:53:01 <sjanssen> hpaste: i ate my paste
02:53:10 <shag> now i understand!
02:53:11 <pwned> argh!
02:53:14 <shag> thats really funny
02:53:25 <quicksilver> it's in the topic too
02:53:26 <quicksilver> fwiw
02:53:28 <Cale> pwned: You're being pwned.
02:53:34 <int-e> @paste
02:53:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:53:41 <quicksilver> was my first operator actio, I feel so proud.
02:53:49 <int-e> hehe. that linked lambdabot and hpaste.
02:53:57 <sjanssen> dcoutts_: come back to the fold
02:53:59 <Cale> :)
02:53:59 <shag> someone definitly has got too much time here ...
02:54:00 <osfameron> is there a haskell-daily, haskell-monthly etc .png too?
02:54:11 * mux notes he's losing links fast
02:54:14 <sjanssen> malcolmw: we're losing you
02:54:22 <Cale> ChanServ: I choose you!
02:54:26 <sjanssen> osfameron: hang on buddy
02:54:27 <mux> haha.
02:54:42 <Cale> sjanssen: glom!
02:54:49 <osfameron> phew!  I was hanging onto glguy for dear life
02:54:49 <Cale> hehe
02:54:49 * malcolmw is confused
02:54:51 <osfameron> but sjanssen saved me
02:55:13 <Cale> malcolmw: look at http://files.codersbase.com/haskell/haskell-current.png -- edges strengthen when people talk to each other
02:55:14 <sjanssen> quicksilver: yep
02:55:14 * mux notes that's a fine way to pass the day
02:55:22 <nominolo> @unpl ((->) Win) :. IO :. (,) Layout
02:55:22 <lambdabot>  Parse error at "->)" (column 3)
02:55:46 <sjanssen> we've pwned this graph
02:55:46 <int-e> > "glguy"
02:55:48 <lambdabot>  "glguy"
02:56:06 <mux> > "hiya mux!"
02:56:06 <lambdabot>  "hiya mux!"
02:56:09 <int-e> ok, I've had enough :)
02:56:26 <czakey> > cyce ":)"
02:56:26 <lambdabot>   Not in scope: `cyce'
02:56:30 <czakey> > cycle ":)"
02:56:34 <lambdabot>  ":):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):...
02:56:37 <Cale> Heh, we can induce edges between anyone and lambdabot at will.
02:56:38 <sjanssen> nominolo: @unpl's parser isn't very smart
02:56:42 <nominolo> int-e: lambdabot sjanssen osfameron Cale - hi all! ;)
02:57:10 <nominolo> sjanssen: can anyone decipher that type?
02:57:22 <sjanssen> nominolo: what is :. ?
02:57:31 <nominolo> i suppose :. is meant as "type compose"
02:57:33 <nominolo> oh wait ...
02:57:43 <nominolo> there's a package called "TypeCompose"
02:57:48 <nominolo> maybe i should look there
02:58:00 <sjanssen> > reverse "vreSnahC"
02:58:01 <lambdabot>  "ChanServ"
02:58:10 <mauke> Win -> IO (Layout, a)
02:58:55 <nominolo> @seen conal
02:58:55 <lambdabot> I saw conal leaving #haskell and #ghc 2h 34m 1s ago, and .
02:59:00 <bringert> Register http://haskell.org/haskellwiki/Hac4 !
02:59:03 <bringert> for
02:59:05 <Cale> The advantage of using :. is that you get Functor and Applicative instances for free.
02:59:06 <nominolo> mauke: wow.  that's so much more readable
02:59:12 <osfameron> > "lambdabot: hello"
02:59:15 <lambdabot>  "lambdabot: hello"
02:59:17 <nominolo> Cale: uhuh
03:00:25 <nominolo> Cale: well, it's really not readable, though
03:00:35 <Cale> It's not *so* bad
03:00:46 <Cale> Once you know how it works :)
03:01:38 <nominolo> but having to manually @unpl is hindering readability
03:02:01 <nominolo> much of conal's code actually is very abstract :/
03:02:12 <roconnor> yep
03:02:46 <Cale> I guess the way to think about it is that you're stacking up applicative functors.
03:02:59 <zerny> anybody know if there exists a haskell-qt4 library?
03:03:02 <Cale> and try not to worry about the concrete type
03:03:23 <Cale> zerny: I'm pretty sure that wouldn't exist yet.
03:03:45 <zerny> Cale: for older qt versions maybe?
03:03:52 <Cale> I heard some noise about a QT binding though
03:04:10 <nominolo> zerny: gtk2hs is stable
03:04:21 <Cale> zerny: Let me just check the mailing list...
03:04:47 <nominolo> Cale: ok, that stacking idea helped
03:05:17 <Cale> zerny: http://qthaskell.sourceforge.net/
03:05:18 <lambdabot> Title: qtHaskell
03:05:21 <zerny> nominolo: yes. I might end up using that.
03:05:48 <Cale> I'm not really sure that Theta tau is an appropriate approximation of Qt.
03:06:00 <zerny> Cale: thanks
03:07:21 <nominolo> zerny: does Qt 4 have native widgets on MacOSX?
03:08:31 <quicksilver> I believe nokia just bought Qt
03:08:39 <quicksilver> I don't know if that's good or bad thing, but I'm guessing good.
03:08:54 <resiak> it's a perplexing thing, since they already use two non-Qt toolkits on Maemo :)
03:09:01 <Twey> *Bought* Qt?
03:09:03 <pwned> maybe they will make a C++ wrapper for Qt :)
03:09:06 <resiak> They bought Trolltech
03:09:15 <Cale> Heh, would be pretty strange to buy Trolltech just to try to kill the project.
03:09:20 <Twey> Are they likely to close the source?
03:09:21 <resiak> http://www.nokia.com/A4136001?newsid=1185531
03:09:22 <lambdabot> Title: Nokia - ShowPressRelease
03:09:27 <Twey> Cale, stranger things have happened
03:10:28 <quicksilver> killing open source projects is notoriously hard
03:10:36 <quicksilver> if it is widely used, it will survive.
03:11:03 <nominolo> hm, has anyone continued working on the bytestring http library?
03:11:27 <Twey> Qt's dual-licensed though, I'm a bit wary of predicting anything legal about it
03:12:50 <resiak> there's some bizarro covenant with Qt and KDE
03:13:15 <resiak> http://www.kde.org/whatiskde/kdefreeqtfoundation.php
03:13:16 <lambdabot> Title: K Desktop Environment - KDE Free Qt Foundation
03:13:45 <Twey> Aha
03:13:52 <Twey> That's good
03:13:57 <litb> hello all :)
03:14:16 <Twey> Hi litb
03:14:16 <ricky_clarkson> Moin litb
03:16:42 <int-e> Ok, I've confirmed my theory about PieSpy - its 'direct addressing' heuristic takes the first word of the message (if it's a nick), and - is not considered to be a word constituent.
03:17:16 <mauke> that's pretty fail
03:17:18 <int-e> (and it's written in Java, eek :) )
03:17:58 <quicksilver> it also notices nicks which occur later in messages, int-e .
03:18:25 <quicksilver> I haven't checked the source, but I know this to be true. If I mention resiak as an aside, like this, I should get a connectino to him.
03:19:21 <nominolo> @seen dcoutts_
03:19:21 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
03:19:41 <int-e> quicksilver: oh right. its "indirect" addressing heuristic does that. But it uses the same notion of words.
03:20:17 * quicksilver nods
03:20:34 <quicksilver> well, if anyone wants to rewrite it in haskell that's fine by me :)
03:20:50 <quicksilver> the graph-drawing heuristics are probably harder than the addressing ones though
03:21:16 <mauke> .oO( foreign import java "..." )
03:21:18 <int-e> there's also a heuristic that picks the immediately preceding message, and one for dialogues (two people talking in 5 consecutive messages).
03:24:28 <FunctorSalad> hmm UI programming seems hard without state...
03:24:50 <FunctorSalad> for example, how would I go about storing a current selection of widgets?
03:24:57 <quicksilver> you would use state.
03:24:59 <quicksilver> just not mutable state.
03:25:01 <quicksilver> ;)
03:25:07 <quicksilver> there is no problem modelling state in haskell.
03:25:13 <quicksilver> you just don't use mutable variables to do it.
03:25:18 <FunctorSalad> hmm, I see
03:25:24 <int-e> quicksilver: hmm, it's simpler than you might think - the code implements a physical model for that - nodes repulse each other, while edges contract nodes. nodes also have a current position, it seems.
03:25:40 <quicksilver> int-e: yeah, I'm pretty sure a physical model is the best way to go
03:25:54 <quicksilver> int-e: physical model with gradually increasing damping to guarantee a stable state is reached in finite time?
03:25:57 <quicksilver> int-e: something like that.
03:26:11 <quicksilver> int-e: would actually be a nice thing to model in haskell, easy to play with alternative algs
03:26:21 <int-e> quicksilver: it just goes through a fixed number of iterations every time it generates the image, it seems.
03:26:35 <FunctorSalad> not sure about the context of your discussion but for graph layout, using dot would seem like an option
03:30:35 <quicksilver> I imagine you mean graphviz
03:30:43 <quicksilver> I have a slight prejudice against that since it's non-free
03:30:44 <FunctorSalad> right
03:30:53 <FunctorSalad> oh
03:30:56 <quicksilver> also, piespy graphs are much more attractive than graphviz ones
03:34:05 <smtms> quicksilver, what do you mean when you say graphviz is non-free?
03:34:45 <quicksilver> smtms: I mean, it fails to meet the debian free software guidelines
03:34:56 <quicksilver> =~= the open source definition
03:35:27 <smtms> quicksilver, have you read its license?
03:35:59 <resiak> http://packages.debian.org/graphviz would tend to disagree ?
03:35:59 <lambdabot> Title: Debian -- Package Search Results -- graphviz
03:36:35 <wolverian> quicksilver, that changed in, uh, 2005, I think
03:37:08 <smtms> it seems it's Common Public License now
03:37:15 <quicksilver> yay
03:37:17 <quicksilver> good news
03:37:18 * quicksilver dance
03:37:25 <quicksilver> I see old prejudices die hard
03:37:48 * quicksilver mentally moves 'graphviz' from the 'neat but evil' box to the 'cool and froody' box in the attic of his brain.
03:37:55 <smtms> quicksilver, you should flush your caches more often :-)
03:38:42 <quicksilver> ;)
03:39:09 <mauke> slowly the graph untangles itself
03:59:28 <swi> !topic
04:00:35 <nominolo> quicksilver: you brain has an attic?
04:08:10 <quicksilver> nominolo: sure. It's much to crowded otherwise.
04:09:38 <Twey> Is it possible to compare two infinite lists?
04:09:55 <mauke> > [0 ..] == [1 ..]
04:09:56 <dcoutts__> Twey: you can compare finite prefixes of them in finite time
04:09:58 <lambdabot>  False
04:10:16 <dcoutts__> nominolo: pong
04:10:19 <Twey> I see
04:10:28 <nominolo> dcoutts__: hi there
04:10:29 <mauke> > [0 ..] == [0 ..]
04:10:39 <dcoutts> @arr!
04:10:39 <lambdabot> Keelhaul the swabs!
04:10:39 <lambdabot> Terminated
04:10:51 <Twey> So rather than: 1 : [fac * i | (i, fac) <- zip [1..] facs] == scanl (*) 1 [1..]
04:10:52 <nominolo> i only pinged you for social purposes -> http://files.codersbase.com/haskell/haskell-current.png
04:10:53 <nominolo> ;)
04:11:03 <Twey> I should take x of each and compare those?
04:11:19 <dcoutts> nominolo: heh heh
04:11:19 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:11:30 <faxathisia> Twey, What do you want to compare them for?
04:11:37 <nominolo> dcoutts: i was wondering why you were appearing on that graph although you hadn't spoken yet.  until i realized, that someone just mentioned your name
04:11:43 <dcoutts> nominolo: btw, I have not heard about the bytestring http lib recently either
04:11:53 <mauke> I have become unlinked from the net
04:12:07 <Twey> faxathisia, equality.  The two definitions above are equivalent.
04:12:14 <nominolo> dcoutts: i got a mail from someone mentioning it is being to strict
04:12:14 <quicksilver> mauke: you are a pariah
04:12:17 <quicksilver> an outcast.
04:12:20 <dcoutts> I see, it changes constantly
04:12:20 * mux notes going to eat was enough time to find himself not on the graph anymore
04:12:31 <Twey> (one of which is much too neat to be mine and is therefore obviously mauke's)
04:12:31 <faxathisia> If you know there are equiv you needn't compare them
04:12:46 <Twey> faxathisia, it was a hypothetical situation
04:12:58 <nominolo> dcoutts: so i would have liked to direct him to some newer versions
04:13:02 <nominolo> @seen tibbe
04:13:02 <lambdabot> tibbe is in #darcs, #xmonad, #ghc and #haskell. I last heard tibbe speak 2h 29m 54s ago.
04:13:10 <dcoutts> nominolo: there can be many reasons for that, could be that some lazy bytestring function is too strict, or just the http parser is being too strict
04:13:53 <nominolo> dcoutts: the latter shouldn't affect the laziness for the payload, though
04:14:15 <dcoutts> it would be nice to have a well tested bytestring http lib
04:16:19 <nominolo> stupid linux wifi drivers
04:16:27 * nominolo should switch back to macos
04:16:42 <slarba_> leopard is not better ;)
04:17:00 <nominolo> i have tiger
04:17:16 <nominolo> and i don't intend to upgrade for now
04:17:17 <slarba_> sometimes the wifi misbehaves... connection drops etc crap
04:17:25 <nominolo> slarba_: oh
04:17:29 <slarba_> waiting for 10.5.2 update...
04:18:03 <slarba_> it seems to have something to do with automatic channel selection and amount of overlapping networks
04:18:27 <slarba_> not sure though. but it's more frequent in environments with large number of networks
04:18:51 <nominolo> yes.  unfortunately for our university network that means you have to manually re-login via a web interface
04:19:04 <nominolo> slarba_: same here on linux, yes
04:19:38 <nominolo> slarba_: though, using switching to WICD rather than the ubuntu default helped a lot
04:20:35 <slarba_> I'm too lazy (virtue of a haskell programmer?) to to use linux anymore
04:20:59 <hexpuem> with "lookup :: (Monad m, Ord k) => k -> Map k a -> m a" how do i call lookup using the Maybe monad?
04:21:13 <slarba_> hexpuem: just call it in the Maybe monad ;)
04:21:15 <mauke> lookup key map
04:21:23 <mauke> it Just Works(tm)
04:21:34 <faxathisia> hex, If you just act like it's in the maybe mond, type inferrence fills it in
04:22:03 <hexpuem> lookup key map calls the default error handler for it
04:22:13 <slarba_> the power of type inference
04:22:13 <mauke> there is no default error handler
04:22:21 <mux> hexpuem: just expect lookup to return a Maybe type, and due to type inference, it will
04:22:32 <hexpuem> hmm ok haha
04:22:33 <hexpuem> thanks
04:22:35 <slarba_> mauke: in Maybe monad? fail = Nothing
04:22:35 <mux> hexpuem: for instance, pass the result of the lookup call to maybe or fromMaybe
04:22:44 <pierre-> hello
04:23:00 <nominolo> pierre-:!!!
04:23:07 <nominolo> er, hello you too
04:23:26 <pierre-> how could i load State monad code in ghc api? unfortunately, State is not Typeable
04:24:20 <nominolo> that's because it's a function
04:24:42 <pierre-> i though that i can load functions in ghc api
04:25:03 <pierre-> i even saw an example in hint package
04:25:03 <nominolo> if you need to load code you need to use, e.g, hs-plugins
04:25:25 <nominolo> i think that's easier to use than the raw ghc api
04:28:07 <pierre-> nominolo: i think that hs-plugins is bad choice for me, because i do not need particular plugin api
04:28:22 <slarba_> hmm. I'm quite impressed with the ghc6.8.2 performance... the huffman compression utility example I wrote for my haskell intro is only 30% slower than C version (that took me several painful hours to write and debug)
04:28:35 <pierre-> and i need also to wrap function depending on its type
04:30:04 <shag> what is the easiest way to send a ByteString over the network and get a ByteString back?
04:30:44 <slarba_> shag: Data.ByteString has IO actions that work on ByteStrings
04:30:52 <dcoutts> shag: convert a socket to a Handle and then use ordinary bytestring IO
04:31:25 <bringert> tibbe was working on bytestring sockets iirc
04:31:45 <shag> hm. sounds good.
04:32:12 <dcoutts> I still don't understand bytestring sockets, and why you'd want one as opposed to an ordinary Handle
04:33:45 <quicksilver> you might want a way to directly send a bytestring datagram to a UDP desitnation
04:33:49 <quicksilver> saving any recoding
04:33:58 <quicksilver> (should be able to directly use the foreignptr inside)
04:34:30 <dcoutts> quicksilver: can't one use a Handle with a UDP socket?
04:34:32 <quicksilver> shag: but I agree with dcoutts . Just use Handles.
04:34:37 <quicksilver> dcoutts: No, UDP is connectionless.
04:35:01 <dcoutts> true, but doesn't that just mean each write and read is a udp packet?
04:35:34 <quicksilver> I didn't think so.
04:35:46 <quicksilver> I don't think UDP involves unix file descriptors at all.
04:35:51 <dcoutts> hmm
04:36:05 <shag> quicksilver, dcoutts: ok, i'll do that
04:37:09 <quicksilver> dcoutts: I'm wrong.
04:37:23 * dcoutts was just reading man socket
04:37:30 <quicksilver> dcoutts: unix does permit you to create a kind of 'lightweight' fd which represents a UDP desitniatin.
04:37:42 <quicksilver> dcoutts: even though it doesn't imply a connection.
04:37:57 <dcoutts> quicksilver: though it seems that recvfrom is preferable for udp sockets
04:38:20 <quicksilver> looks like i
04:42:08 <tibbe> dcoutts: cause the normal socket have the wrong type! :)
04:42:09 <what-> hi all
04:42:10 <tibbe> dcoutts: it's like asking why you have sockets in the first place ;)
04:42:42 <dcoutts> tibbe: right, I guess that is what I was wondering, why we do have sockets
04:43:05 <what-> How can I fix this error :   print ("Average diameter: " ++ show ((sum ds) / (length ds :: Double)))
04:43:07 <tibbe> dcoutts: right
04:43:11 <tibbe> dcoutts: dunno
04:43:15 <dcoutts> tibbe: and looking at man socket it seems there's much more detail than I would care to understand :-)
04:43:22 <what-> gives me: Couldn't match expected type `Double' against inferred type `Int'
04:43:57 <Cale> what-: unfortunately, the Haskell 98 committee decided to make the result type of length be Int
04:44:08 <Cale> (which I know, is completely ridiculous)
04:44:30 <what-> cale: clear, but how to convert it, fromInt says "Not in scope"
04:44:35 <Cale> what-: So you'll need to either apply fromIntegral to the result of length, or use Data.List.genericLength
04:44:40 <quicksilver> what-: fromIntegral
04:45:17 <what-> works, thx
04:45:41 <Cale> What's *far more* ridiculous however, is the source code to this image viewing program which someone for some reason decided to post on programming reddit.
04:46:03 <Cale> It's a single file consisting of 11202 lines of python code.
04:46:12 <Cale> Very very repetitive python code.
04:46:24 <Cale> http://reddit.com/r/programming/info/66ue3/comments/c030ki1
04:46:33 <dcoutts> @seen sorear
04:46:34 <lambdabot> I saw sorear leaving #xmonad, #haskell and #ghc 4h 54m 9s ago, and .
04:47:34 <dcoutts> @tell sorear there's a Cabal FAQ http://haskell.org/haskellwiki/Cabal/FAQ feel free to add to it (based on #haskell questions etc)
04:47:34 <lambdabot> Consider it noted.
04:49:38 <what-> cale: probably auto-generated or the developer likes copy-paste (seen A LOT of these)
04:49:47 <quicksilver> Cale: whilst its a weakness of java that a certain amount of repitiion arise, it isn't (particularly) of python.
04:49:56 <quicksilver> Cale: but loads of people program by copy-paste.
04:52:16 <what-> sometimes refactoring means breaking the original and then buiding it in a new way (compatible), some people dont like the risk of breaking the working part so they copy it and hack at the copy
04:53:56 <quicksilver> what-: turning that copy-paste intoa  for loop wouldn't be too hard though :)
04:54:37 <Cale> and that third example of repetitiveness I gave actually repeats itself wholesale with a couple of variables changed 3 or 4 times.
04:55:27 <quicksilver> Cale: interesting, to clear up messes like that requires eitehr a very weak type system or a very strong one
04:55:43 <quicksilver> Cale: python can do it using its dynamic facilities, and haskell can do it using its very expressive type system.
04:55:49 <quicksilver> Cale: java is stuck in the middle with neither
04:56:11 <quicksilver> ~/closures to the left of me, tuples to the right, stuck in the middle with you/~
04:56:29 <Cale> heh
04:56:58 <pwned> just use Prolog.
04:58:20 <faxathisia> Why?
04:59:51 <quicksilver> because it sounds good.
05:00:10 <pwned> it is a logical choice.
05:00:30 <faxathisia> Prolog doesn't stop copy and paste programming
05:01:07 <faxathisia> (You can avoid it in various ways.. but it's sometimes a useful technique)
05:03:07 <FunctorSalad> hmm... in gtk2hs, I can properly write a certain attribute (layoutChildX), but getting it always returns 0?
05:03:25 <dcoutts> hmm
05:06:08 <dcoutts> FunctorSalad: so you are positioning child widgets inside a Layout container?
05:06:36 <FunctorSalad> dcoutts: yes. I know absolute layout is usually stupid, but I'm making a diagramming widget ;)
05:07:06 <dcoutts> FunctorSalad: so does setting them actually affect the child widget position? it's just getting the value back is always 0?
05:07:14 <FunctorSalad> yes, setting works
05:07:32 <FunctorSalad> and getting returns 0; the get and set are both in the same function
05:10:13 <dcoutts> FunctorSalad: it's a bug! :-)
05:10:22 <dcoutts> FunctorSalad: containerChildGetPropertyInternal is calling container_child_set_property
05:10:23 <dcoutts> doh!
05:10:30 * dcoutts fixes
05:10:36 <dcoutts> FunctorSalad: you'll need the darcs version
05:10:51 <FunctorSalad> hehe. was just going to say that moving the get to after the set makes the set fail too :)
05:10:58 <FunctorSalad> @karma+ dcoutts
05:10:58 <lambdabot> dcoutts's karma raised to 49.
05:11:01 <FunctorSalad> thanks :)
05:11:44 <dcoutts> FunctorSalad: can you use the darcs version? can you test it if I push a fix?
05:12:07 <FunctorSalad> dcoutts: yes
05:13:23 <dcoutts> FunctorSalad: you can configure --with-hcflags=-O0 --disable-split-objs for a 5min rather than 25min build time
05:14:13 <FunctorSalad> this one? http://darcs.haskell.org/gtk2hs/
05:14:13 * dcoutts checks that it still builds ok
05:14:14 <lambdabot> Title: Index of /gtk2hs
05:14:18 <dcoutts> FunctorSalad: yep
05:14:59 <dcoutts> FunctorSalad: if you want to test the fix quickly before I've pushed, edit:
05:14:59 <dcoutts> ./gtk/Graphics/UI/Gtk/Abstract/ContainerChildProperties.chs
05:15:14 <dcoutts> line 86, switch set for get
05:15:17 <FunctorSalad> :)
05:15:19 <dcoutts> -  {# call container_child_set_property #}
05:15:19 <dcoutts> +  {# call container_child_get_property #}
05:15:47 <dcoutts> I'll check that doesn't break the build before pushing a patch...
05:15:58 <FunctorSalad> ok
05:16:38 <quicksilver> people think the clever bit about lisp is the dotted pair
05:16:41 <FunctorSalad> I'll tell you the results when I have downloaded, hunted down the dependencies, etc. ;)
05:16:42 <quicksilver> but I'm not entirely sure it is
05:16:48 <quicksilver> I think it might be the symbol type.
05:18:10 <nominolo> @karma
05:18:10 <lambdabot> You have a karma of 1
05:18:59 <swiert> nominolo++
05:19:04 <swiert> (writing something for TMR)
05:19:13 <nominolo> swiert++
05:19:18 <nominolo> (editing TMR)
05:19:20 <masklinn> "
05:19:30 <swiert> :)
05:20:28 <joelr1> good day! does anyone know how to make alex (lexer generator) lexing to be case-insensitive?
05:20:50 <what-> @karma
05:20:50 <lambdabot> You have a karma of 0
05:21:57 <nominolo> joelr1: what's wrong with expressing this in your grammar?
05:24:14 <joelr1> nominolo: how exactly?
05:24:25 <joelr1> nominolo: with regexps?
05:26:20 <nominolo> joelr1: something like:  $alpha+   { Ident . map toUpper }
05:26:35 <nominolo> for parsing an identifier
05:33:27 <shapr`> @yow !
05:33:27 <lambdabot> Oh, I get it!!  "The BEACH goes on", huh, SONNY??
05:33:49 <mauke> @b51
05:33:50 <lambdabot> Maybe you meant: b52s bf bug
05:34:07 <_piranha_> hi all... I'm trying to compile yi on ubuntu and my current trouble is that I have regex-base and regex-posix 0.93, while yi wants 0.73. Is there any way to get rid of this? I guess there are changes in the API, so yi will not compile after simple change of prerequisites?
05:34:46 <Saizan> _piranha_: install 0.73 from hackage
05:34:53 <what-> @list
05:34:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:35:17 <nominolo> _piranha_: yi needs regex-base, not regex-posix
05:35:33 <_piranha_> nominolo: it says about both
05:35:36 <what-> @free#
05:35:37 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
05:35:40 <what-> @free
05:35:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
05:35:42 <_piranha_> regex-base, regex-compat, regex-posix
05:35:51 <Saizan> @free map
05:35:53 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
05:36:06 <_piranha_> Saizan: ehh... I though about that... Ok, will go this way
05:37:57 <ToRA> matthew-_: ping
05:38:15 <matthew_-> ToRA: pong
05:38:44 <Spark> matthew_-: pong
05:39:25 <ToRA> Spark: ?
05:39:31 <matthew_-> Spark: shuuush
05:39:58 <matthew_-> I'm so glad the rest of you can't hear the bizarre conversation going on in this office
05:40:03 <matthew_-> "look, we have a triangel"
05:40:04 <matthew_-> etc
05:40:10 <Spark> can i has triangles
05:41:38 <slarba_> what would be a good "haskellish" approach to the following problem: I have a tree with certain node types. For each node, there's a mutator that mutates the node. Now what I want is a list of trees with all combinations of the mutations
05:42:29 <ToRA> slarba_: I think there's a combinator in Data.Generics that can help do something like that
05:43:05 <matthew_-> zipper?
05:43:15 <slarba_> hmm!
05:43:24 <_piranha_> Setup.hs: Package yi-0.3 can't be built on this system.
05:43:26 <_piranha_> o_O
05:43:34 <_piranha_> what does this mean? o_O
05:45:37 <slarba_> so with a zipper I can "pause" at the node to be mutated, run that in a state monad and for each mutation, traverse back to the root and append it to tree list, right?
05:46:16 <Saizan> slarba_: or you could use the Writer monad maybe?
05:46:21 <joelr1> @tell nominolo thanks!
05:46:21 <lambdabot> Consider it noted.
05:46:42 <slarba_> yeah true, I don't need reading of the state
05:47:45 <Saizan> slarba_: Writer is not really state-like, but if you need to accumulate a "log" while doing a computation it's perfect
05:48:02 <slarba_> yes that's what I need
05:48:07 <slarba_> it's a kind of log
05:49:59 <shapr`> @yow !
05:50:00 <lambdabot> It don't mean a THING if you ain't got that SWING!!
05:50:09 <RayNbow> > sin (pi / 6)
05:50:12 <lambdabot>  0.49999999999999994
05:50:28 <RayNbow> gotta love floats :)
05:50:51 <mauke> > toRational $ sin (pi/6)
05:50:52 <lambdabot>  9007199254740991%18014398509481984
05:51:04 <mauke> > sin (pi/6) :: Float
05:51:05 <lambdabot>  0.5
05:51:15 <RayNbow> hmm
05:51:25 <RayNbow> ah
05:51:28 <Deewiant> > sin (pi/6) :: Double
05:51:29 <lambdabot>  0.49999999999999994
05:51:39 <pwned> Kids these days are lucky. During Pentium 75 days it was more like 0.49983745837235
05:51:40 * RayNbow just figured that out :p
05:51:56 <idnar> bwaha
05:52:02 <Twey> pwned, heh
05:52:16 <mux> > 4 * atan 1
05:52:17 <lambdabot>  3.141592653589793
05:52:37 <idnar> 23846264338327950288419716
05:53:17 <hpaste>  ToRA pasted "mutating nodes?" at http://hpaste.org/5283
05:53:47 <ToRA> slarba_: could just use list monad if it is stateless
05:54:10 <ToRA> (assuming i understood what you want to do...)
05:57:36 <FunctorSalad> dcoutts: it works. thanks again =)
05:57:54 <dcoutts> FunctorSalad: great, I'll push the patch later.
05:59:00 <RayNbow> yo prototype- :p
06:00:06 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5284
06:00:33 <ecksit> hello i am confused about the program I just pasted in
06:00:46 <bringert> how do I cyeck through the command history in a ghci emacs buffer? up arrow moves the cursor
06:00:58 <bringert> s/cyeck/cycle/ wtf?
06:01:12 <ecksit> The return type of getTime is supposed to be String, but the Interpeter keeps saying that its IO String
06:01:33 <jedbrown> bringert: M-p and M-n
06:01:34 <bringert> ah, M-p
06:01:42 <bringert> jedbrown: thanks
06:01:51 <ecksit> since CalendarTimeToString returns String type
06:02:00 <int-e> ecksit: well it's an IO action that returns a String value.
06:02:06 <bringert> now I just need to bind something sensible to M
06:02:08 <vincenz> augustss_: ping
06:02:10 <int-e> @type return
06:02:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:02:32 <Lemmih> ecksit: 'return' is a function, not a keyword.
06:02:32 <int-e> ecksit: the 'return' puts that value into a monad, which is IO in your case.
06:02:58 <int-e> ecksit: and you have to work in IO because getClockTime
06:03:02 <liyang> (and no, you can't have your value back. It's stuck in IO now. ;)
06:03:09 <int-e> ecksit: because you use getClockTime, which is in IO
06:03:15 <int-e> @type Time.getClockTime
06:03:16 <lambdabot> IO System.Time.ClockTime
06:03:54 <ecksit> int-e: i thought time <- getClockTime strips out the IO part from the String
06:04:15 <slarba_> ToRA: thanks :)
06:04:24 <int-e> @undo do time <- getClockTime; return (calendarTimeToString (toUTCTime time))
06:04:25 <lambdabot> getClockTime >>= \ time -> return (calendarTimeToString (toUTCTime time))
06:04:51 <ToRA> slarba_: np, hope it's useful...
06:05:32 <int-e> ecksit: It does, but it does that *within the IO monad* - as the undo output showed, the magic is really done by the '>>=' operator ('bind')
06:05:37 <int-e> @type (>>=)
06:05:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:06:11 <Japsu> @. pl undo do time <- getClockTime; return (calendarTimeToString (toUTCTime time))
06:06:12 <lambdabot> (calendarTimeToString . toUTCTime) `fmap` getClockTime
06:06:13 <liyang> ecksit: bind (<-) gives you just the pure value to work with, but only while you work with it within IO.
06:06:15 <_piranha_> guys? any ideas about yi?
06:06:44 <Japsu> waagh, where'd that fmap come from
06:06:52 <int-e> ecksit: which takes a monad action returning a value (of type IO ClockTime here) and a function that takes that value and produces another monadic action (of type  ClockTime -> IO String  in your case) and sort of pastes them together.
06:06:55 <ecksit> so then time is in a sense string, but only within the getTime function, and when I use return on the output, it converts it back into an IO String
06:07:14 <Japsu> @pl \ time -> return (calendarTimeToString (toUTCTime time))
06:07:14 <lambdabot> return . calendarTimeToString . toUTCTime
06:07:34 <ToRA> _piranha_ : have a read of the readme .. http://code.haskell.org/yi/README
06:07:54 <int-e> ecksit: the result is another monadic action (IO String for your case) which runs the first action, passes that to the function, and then runs the second action. But in any case, the whole action works in the same monad (IO here) as the two parts.
06:07:57 <ToRA> _piranha_ : about half way down it explains what that error probably means
06:08:06 <_piranha_> ghc 6.8.2 - installed, alex - installed, gtk2hs - installed
06:08:22 <_piranha_> hmm... he says I don't have any UI package
06:08:27 <_piranha_> but I have gtk2hs...
06:08:41 <_piranha_> ah! I guess gtk2hs is not registered in cabal database, right?
06:08:45 <ecksit> int-e: so is there any way to get out of the monadic action and return only the string?
06:08:52 <int-e> ecksit: no.
06:09:11 <ToRA> _piranha_ : what does ghc-pkg list report?
06:09:14 <int-e> ecksit: not for IO at least.
06:09:51 <ecksit> ok, damn, how could I be able to get a String of the current Time so that I may manipulate it?
06:10:05 <_piranha_> ToRA: ghc-pkg list? No gtk2hs :-( I've installed it via configure --prefix=$HOME && make all && make install
06:10:11 <int-e> ecksit: but you can still run it - because  main  has type  IO a, i.e. main is an IO action.
06:10:21 <int-e> ecksit: the same way that you run  getClockTime
06:10:28 <_piranha_> ahhh right there are option for configure
06:10:35 <_piranha_> ToRA: thanks for pointing in right direction
06:10:48 <int-e> ecksit: say, main = do time <- getTime; putStrLn time
06:11:07 <ecksit> particularly, i want to display in dzen the local time, but it's input is a string not an IO String
06:11:09 <ToRA> _piranha_ :)
06:11:13 <int-e> (equivalently,  main = time >>= \time -> putStrLn time  or  main = time >>= putStrLn)
06:11:32 <liyang> ecksit: you write the majority of your code in a pure functional way, then build a thin IO shell around it which does the dirty I/O work, calling the pure code to do most of the computation. There's some slides on xmonad which puts the point across rather well.
06:12:02 <_piranha_> ToRA: hehe, now it is present in ghc-pkg list :-)
06:12:14 <liyang> main :: IO () is the outermost bit of the dirty IO `shell'.
06:13:06 <_piranha_> ToRA: thanks! compiled! :D
06:13:08 <ecksit> int-e: i dont really want to output it to stdin though
06:13:35 <ToRA> _piranha_ np
06:14:30 <ecksit> how can u get out of the IO shell so that you may use it in a pure functional way?
06:14:54 <EvilTerran> you don't take values out of IO to work with them. instead, you have to get into the IO shell yourself to work with them
06:15:22 <EvilTerran> what's the type of the function you want to pass the string to>
06:15:23 <EvilTerran> ?
06:15:53 <hpaste>  int-e annotated "(no title)" with "hmm" at http://hpaste.org/5284#a1
06:16:07 <int-e> ecksit: maybe this is closer to what you really want to do?
06:17:11 <int-e> ecksit: in this example,  processTime  is a pure function, which does the hard work of your  getTime  function.
06:18:17 <int-e> ecksit: in any case it demonstrates a good way to get out of IO: gather the required information within an IO action, and then hand it off to pure functions for the actual processing. finally, do something with the result.
06:19:35 <ASderer> http://DIANA-MEINE-EX.gotdns.com/?id=5420b8f7
06:19:35 <ASderer> http://DIANA-MEINE-EX.gotdns.com/?id=5420b8f7
06:19:37 <ASderer> http://DIANA-MEINE-EX.gotdns.com/?id=5420b8f7
06:19:44 <shapr`> irritating.
06:19:53 <resiak> yet another monad tutorial? oh, wait...
06:20:16 <EvilTerran> would it be productive to have the bot mute anyone who uses the exact same line twice in quick succession?
06:20:34 <EvilTerran> it'd silence the spammers *and* the annoying newbies who won't shut up ;)
06:20:36 <shapr`> Yeah, you want to write that plugin?
06:20:59 <Spark> make it 3 times
06:21:06 <vincenz> How do you 'mute'?
06:21:10 --- mode: ChanServ set +o shapr
06:21:11 <Spark> +q isn't it
06:21:18 <mauke> set a ban starting with %
06:21:29 <Spark> not heard of that one before
06:21:32 <EvilTerran> in general, +b stops someone saying anything, even if you don't kick them
06:21:34 <mauke> that's what +q does
06:21:39 <Spark> ah right
06:22:13 <kaol> the server should already intercept and k-line any users who send a URL as their first message to a channel
06:22:14 <shapr> Wait, what are you suggesting?
06:22:21 <shapr> kaol: good point
06:22:39 <shapr> Though hpaste-bot would get killed on a regular basis ;-)
06:22:58 <EvilTerran> i was gonna say, we'd want a whitelist. hpaste, haskell.org, probably the big search engines and whatnot
06:23:00 <oerjan> as would many people who use it
06:23:16 <ecksit> int-e: im mostly looking at this function: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-Dzen.html#v%3Adzen
06:23:16 <lambdabot> http://tinyurl.com/279wkd
06:23:24 <vincenz> I wouldn't have the bot auto-kick,mute or ban
06:23:28 <vincenz> We have enough ops around
06:23:42 <shapr> Yeah, but I don't have a butt stomping script for pidgin :-(
06:23:44 <EvilTerran> yeah, i was just being passive-agressive. it wasn't really a serious suggestion. :)
06:24:14 <ecksit> its types are String -> Int -> X()
06:24:17 <EvilTerran> altho i note #xkcd has a bot which mutes people if you repeat a line that has been said before by anyone at any time in the life of the channel
06:24:31 <vincenz> EvilTerran: ouch
06:24:36 <shapr> hah
06:24:47 <EvilTerran> but that starts feeling like a rule out of the Chairman's game fairly quickly, i imagine
06:24:54 <phobes> Can you have the bot generate a short ban script to make it eaiser for an op to ban them?
06:25:01 <vincenz> Why?
06:25:08 <vincenz> It's not that hard for me :)
06:25:11 <int-e> ecksit: ah. you can use  liftIO  to get IO actions into the X monad, I believe.
06:25:16 <shapr> something like @ban *asd* ?
06:25:35 <mauke> how is that easier than /ban *asd*?
06:25:53 <phobes> Dont 'you have to give yourself ops first?
06:26:03 <vincenz> I use ./opme
06:26:05 --- mode: ChanServ set +o vincenz
06:26:07 --- mode: vincenz set -o visof
06:26:09 --- mode: vincenz set -o vincenz
06:26:10 --- mode: ChanServ set +o vincenz
06:26:13 --- mode: vincenz set -o vincenz
06:26:14 <dcoutts> _piranha_: so why was it that gtk2hs was not registered?
06:26:20 <mauke> looks like you need a better /deop :-)
06:26:25 <vincenz> tab-complete
06:26:33 <vincenz> opme is tab free
06:26:44 <vincenz> ./alias opme /msg ChanServ op $C $N
06:26:49 <int-e> ecksit: but you can't get out of IO, it's just that the X monad itself is built upon the IO monad.
06:29:11 <shapr> vincenz: I dunno if I can script pidgin, makes it harder to do timely bans.
06:29:53 <ecksit> int-e: can u give me an example of how liftIO is used?
06:30:01 <ecksit> :t liftIO
06:30:08 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:30:34 <int-e> @type liftIO Time.getClockTime
06:30:36 <resiak> if you use irssi, auto_bleh.pl is your friend
06:30:36 <lambdabot> forall (m :: * -> *). (MonadIO m) => m System.Time.ClockTime
06:31:08 <resiak> (as magic auto-opping and -banning scripts go)
06:31:28 <int-e> ecksit: read 'X' for 'm'. X is an instance of MonadIO (even though Haddock doesn't mention that.)
06:35:35 * mux notes the social network now has 3 disjoint graphs
06:36:12 <ecksit> int-e: so it replaces IO with m in my case
06:36:25 <ecksit> int-e: what is m?
06:36:52 <shapr> mux: someone on ##csharp was just talking to me about you :-)
06:37:26 <int-e> ecksit: m is a variable, it can be any MonadIO instance. The one that you probably want is m = X.
06:38:13 <mux> shapr: oh really?! I really wonder why would someone talk about me in ##csharp *scratches head*
06:39:53 <shachaf> ecksit: If this is xmonad, you can also use "io" instead of "liftIO".
06:41:33 <nominolo> > ("this "++) . ("is a "++) . ("precedence test."++) $ ""
06:41:35 <lambdabot>  "this is a precedence test."
06:41:35 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:18 <oerjan> nominolo: . is highest possible, $ lowest possible
06:42:35 <nominolo> oerjan: i see. thanks
06:43:12 <EvilTerran> well,  is higher ;)
06:43:27 <mauke> {} is highest
06:44:01 <EvilTerran> mauke, i think we're saying the same thing with different notation
06:44:09 <Kekcuk> http://lostworlds.lv/go.php?1139657817 Please Come And Vote For Me!!! (When you enter page, you auto... vote for me) (Thanks to all who voted!!)
06:44:10 <oerjan> no, {- -} is even higher :)
06:44:18 <mauke> EvilTerran: f x {y = 42}
06:44:25 <EvilTerran>  = {} = zero-length operator?
06:44:32 <EvilTerran> ah, i see. {} is syntax, not meta-syntax.
06:47:20 <shapr> mux: pandzilla said that you try to make him write Haskell.
06:49:04 <mux> hah, didn't know pandzi was there :-)
06:54:07 <funktio> @pl \i j -> (i, xs!j)
06:54:07 <lambdabot> (. (xs !)) . (,)
06:55:09 <mauke> :t curry (second (xs !))
06:55:11 <lambdabot> Not in scope: `xs'
06:55:18 <mauke> :t curry (second (?xs !))
06:55:19 <lambdabot> forall b e a. (?xs::Array b e, Ix b) => a -> b -> (a, e)
06:56:03 <funktio> where is second defined?
06:56:11 <shachaf> @index second
06:56:11 <lambdabot> Control.Arrow
06:56:22 <funktio> thanks
06:56:35 <shachaf> Someone should teach lambdabot about Control.Arrow...
06:58:10 <oerjan> @pl \(x, y) -> (x, y+1)
06:58:10 <lambdabot> second (1 +)
06:58:29 <ski_> @type \x y -> ?f x y
06:58:30 <ski_> @type \x y -> x `?f` y
06:58:30 <lambdabot> forall t t1 t2. (?f::t -> t1 -> t2) => t -> t1 -> t2
06:58:31 <lambdabot> parse error on input `?f'
06:58:42 <oerjan> it's just not trying things in the right order...
07:00:10 <oerjan> :t \x y -> x ?`f` y
07:00:11 <lambdabot> parse error on input ``'
07:00:16 <oerjan> bah
07:09:03 <quicksilver> oerjan: odd.
07:09:09 <quicksilver> oerjan: mind you @pl is slightly hackish
07:10:24 <int-e> @pl \x -> x x
07:10:24 <lambdabot> join id
07:10:29 <int-e> @type join id
07:10:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
07:10:30 <lambdabot>     Probable cause: `id' is applied to too many arguments
07:10:30 <lambdabot>     In the first argument of `join', namely `id'
07:12:12 <Jiten> My friend made a split implementation. This is starting to look like it might be the simplest possible implementation to me. What do you think? http://pastebin.com/m3f2da094
07:15:50 <oerjan> Jiten: actually the last line can be improved to split' (h, _:t) = h : split t
07:16:10 <mux> I would change s/drop 1/tail/
07:17:09 <ToRA> > tail []
07:17:11 <lambdabot>  Exception: Prelude.tail: empty list
07:17:13 <ToRA> > drop 1 []
07:17:14 <lambdabot>  []
07:17:16 <ToRA> ?
07:17:22 <mux> ah, makes sense
07:17:27 <mux> nevermind then
07:17:34 <shachaf> ToRA: Look at the line above.
07:17:34 <Cale> In this case, it's safe though.
07:17:40 <mux> haha!
07:17:45 <Cale> Because t isn't the empty list.
07:18:03 <glen_quagmire> > drop (error "Prelude.drop: empty list") []
07:18:04 <Cale> However, it's better handled by pattern matching directly.
07:18:05 <lambdabot>  Exception: Prelude.drop: empty list
07:18:21 <Cale> glen_quagmire: haha
07:18:33 <Cale> > drop (error "some other error") []
07:18:34 <lambdabot>  Exception: some other error
07:19:20 <kaol> > drop 1 []
07:19:21 <lambdabot>  []
07:19:39 <kaol> > head []
07:19:40 <lambdabot>  Exception: Prelude.head: empty list
07:19:47 <ToRA> > take 1 []
07:19:48 <lambdabot>  []
07:19:49 <Cale> > init []
07:19:50 <lambdabot>  Exception: Prelude.init: empty list
07:19:52 <ToRA> \o/
07:20:18 <mauke> I feel a little boogie coming on
07:20:29 <Tac-Work> > undefined []
07:20:29 <lambdabot>  Undefined
07:20:40 <Cale> > undefined undefined
07:20:41 <lambdabot>  Undefined
07:20:50 <mauke> *Main> drop 1 0
07:20:50 <mauke> []
07:20:57 <kaol> > undefined + undefined
07:20:59 <lambdabot>  Undefined
07:21:01 <Tac-Work> > sequence . repeat $ return undefined
07:21:02 <glen_quagmire> :t drop
07:21:05 <lambdabot>   add an instance declaration for (Show (m [a]))
07:21:06 <lambdabot> forall a. Int -> [a] -> [a]
07:21:22 <Tac-Work> > drop 3 [undefined, undefined, undefined]
07:21:23 <lambdabot>  []
07:21:26 <Tac-Work> =-)
07:22:24 <shapr> C# type system is WAY less powerful and flexible than the Haskell typesystem. It makes me sad :-(
07:22:43 <shachaf> Jiten: Another way to improve the function: Add a "p" after the split call in the last line. :-)
07:23:13 <Jiten> shachaf: right, it doesn't work as it is now :)
07:23:49 <Tac-Work> shapr, you should join me in my PHP work. The type system is soo flexible and sane.... not crazy language design choices anywhere to be seen
07:24:45 <kaol> PHP was designed?
07:24:55 <mauke> no, why?
07:25:01 <Tac-Work> yeah, I think by some guy on crack
07:25:07 <int-e> it's modern art. the bad kind.
07:25:21 <Tac-Work> No one is making claims of "Intelligent" design with regards to PHP
07:25:51 <glen_quagmire> php is very succint
07:25:58 <int-e> php, the language that made equality comparison so flexible that they had to introduce a new one to get out of that mess.
07:26:20 <oerjan> Tac-Work: possibly very little natural selection too?
07:27:09 <Tac-Work> oerjan: It's about competition and preditors.
07:27:24 <Tac-Work> No one's seriously picking on PHP
07:27:46 <Tac-Work> It's the dumb-and-easy internet make-it-go web 1.0 language
07:28:22 <mauke> PHP: training wheels without the bike
07:28:43 <Tac-Work> You just stick the files on your apt-gotten apache server, and you have thar intern-wubs programming working
07:29:00 <Tac-Work> no messing with fastcgi or having to learn OOP like ruby
07:29:00 <ToRA> is there a version of the 'index' page of the Haskell Hierarchical Libraries that's like the old behaviour?  The current one is melting my browser [tho it is quite cool]
07:29:02 <BMeph> But...but...you make it sound as if a non-transitive equality is a Bad Thing! ;)
07:29:34 <mauke> PHP: separating logic and programming
07:29:38 <quicksilver> mauke++
07:29:50 <moobax> hi all. what's the best way to make static libs? I'm currently doing
07:29:50 <moobax> ghc -c -Wall -prof -auto-all --make Libfs
07:29:50 <moobax> ar -rcs libfs.a *.o
07:29:50 <moobax> but when I try to link against this library (using ghc as a proxy to gcc) I get loads of link errors, e.g. "bytestringzm0zi9zi0zi1_DataziByteStringziLazzyziChar8_unpack_closure"
07:29:51 <shapr> PHP: separate programming from, um.. something else.
07:30:01 * shapr throws lambdas at PHP
07:30:10 <Cale> @pl f xs = let ys = map ($ ys) xs in ys
07:30:10 <lambdabot> f = fix . flip (map . flip id)
07:30:24 <mauke> create_function, anyone?
07:30:33 <Tac-Work> I think PHP's == operator answers an important question in mathematics though. If arithmetic really IS inconsistent and we find an infallible logical paradox..... we just have to suck it up and accept it
07:30:33 <mauke> "Creates an anonymous function from the parameters passed, and returns a unique name for it."
07:30:54 <resiak> it returns a .. name ?!
07:30:57 <Cale> moobax: that link error looks like the bytestring package isn't loaded
07:31:07 <Cale> moobax: -package bytestring might help
07:31:11 <Cale> moobax: Or try --make
07:31:12 <Tac-Work> resiak: PHP is all string based, so yes, it returns a name
07:31:24 <moobax> yeah, sure, but is there any way to get ghc to do that for me?
07:31:25 <Cale> er, oh, you are using --make
07:31:35 <Tac-Work> you can call strings and string-valued variables as if they were functions
07:31:35 <resiak> :'(
07:31:38 <huamn> mauke, afaik, the anonymous function will a) be always in global scope and b) memory it reserves can not be released... i think there are some other problems also...
07:31:41 <BMeph> It returns a name to an anonymous function? That...just doesn't make sense.
07:32:05 <moobax> cale: that make is not the important one, though, that's just for making my own .o files in libfs
07:32:08 <huamn> so it's not really a usable construct in most cases
07:32:11 <mauke> huamn: yeah, php has no local fcuntions
07:32:19 <quicksilver> BMeph: well it's statically anonymous.
07:32:21 <Cale> moobax: okay, try running with --make
07:32:25 <quicksilver> BMeph: at runtime, it has a name.
07:33:02 * BMeph finds some spiky lambdas for shapr to throw
07:33:20 <Tac-Work> quicksilver is defending PHP! Shun the NONBELIEVER!
07:33:23 <mauke> the name it returns is 100% predictable
07:33:38 <mauke> it's "\0lambda_" ++ counter
07:33:38 <Cale> @let loeb xs = let ys = fmap ($ ys) xs in ys
07:33:41 <lambdabot> Defined.
07:34:02 <Cale> > loeb [const 1, (!!0), liftM2 (+) (!!1) (!!0)]
07:34:03 <lambdabot>  [1,1,2]
07:34:27 <ToRA> Cale: my head just exploded
07:35:05 <shachaf> Jiten: split might be nicer written as an unfold, by the way.
07:35:25 <Cale> > loeb (const 0 : const 1 : [liftM2 (+) (!!n) (!!(n+1)) | n <- [0..]])
07:35:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:35:45 <Cale> heh
07:35:49 <Jiten> shachaf: unfold ... let's see.
07:35:56 <werto> hi you all :)
07:36:00 <Cale> hello
07:36:02 <shachaf> werto: Hello.
07:36:04 <earthy> howdy werto. how's code?
07:36:23 <werto> hi Cale, shachaf and earthy :) what a kind welcome ^__^
07:36:36 <werto> (sorry for my bad spaghetti english :))
07:36:56 <earthy> it's-a not-a too bad-a
07:36:58 <Cale> :) Seems okay so far
07:37:13 <werto> i discovered Haskell yesterday thank you do glade and i liked it's way so much
07:37:28 * oerjan wonders what insanity loeb can do with other Functors
07:37:42 <werto> so i started learning with tutorials :) but unfortunately tutorials are not focused on gtk
07:37:44 * earthy looks at oerjan weird
07:37:46 <Cale> oerjan: It generically ties knots in things. :)
07:37:51 * shapr throws spiky lambdas around the channel
07:37:55 <Tac-Work> (define again 'void) (call/cc (lambda (k) (set! again k))) "Good" "Morning" "#Haskell!" (k '())
07:38:04 <oerjan> earthy: Cale defined it with fmap
07:38:07 * Syzygy- wraps a few of those lambdas
07:38:19 <mauke> *Main> take 20 $ loeb (0 : 1 : [(!!n) + (!!(n+1)) | n <- [0..]])
07:38:19 <mauke> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
07:38:25 <exe_> Ouch.
07:38:28 <mauke> looks better if you autolift numbers
07:38:33 <earthy> you could theoretically use it to close the loop on a comonadic formulation of an attribute grammar
07:38:33 <werto> so i was searching on google if there's a haskell focused-on-gtk tutorial :) because i want to make a very simple word processor
07:38:35 <Twey> Tac-Work: Wassat?  Scheme?
07:38:40 <Tac-Work> yesm
07:38:44 <Cale> mauke: heh
07:38:52 * BMeph takes the box of spiky lambdas from shapr, and nudges the sticky lambdas his way instead
07:38:54 <earthy> werto: there is a gtk tutorial for haskell...
07:39:06 <Twey> werto, http://en.wikibooks.org/wiki/Haskell/GUI
07:39:39 <Cale> http://www.haskell.org/gtk2hs/docs/tutorial/glade/
07:39:40 <lambdabot> Title: Gtk2Hs  Documentation  Glade Tutorial
07:39:41 <Twey> Egh, uses wxHaskell?  :-(
07:39:42 <werto> earthy, yes, i saw it.. but it's not so much for me.. i should need more.. i tryied helping myself with the API but nothing good happened :)
07:39:42 <dozer> @paste
07:39:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:39:43 <shachaf> werto: A word processor may possibly not be the best way to start with Haskell, though.
07:39:45 * Twey is disappointed.
07:39:50 <Cale> http://j-van-thiel.speedlinq.nl/gtk2hs/
07:39:51 <lambdabot> Title: Gtk2Hs Tutorial
07:40:02 <Deewiant> http://reddit.com/r/programming/info/66e9b/comments/c02z7si
07:40:22 <hpaste>  Louis pasted "form.xml" at http://hpaste.org/5286
07:40:28 <earthy> oerjan: that formulation is loeb x = fmap (\z -> a (loeb x)) x  right?
07:40:35 <earthy> (as in sigfpe's blogpost?)
07:40:41 <werto> shachaf, i know that's not a good way, but it's the point where i should arrive, so i was starting focusing on I/O
07:40:43 <earthy> err.... \a ofcourse
07:40:43 <Cale> Twey: wxHaskell isn't so bad. It apparently has new maintainers, but for some reason there hasn't been a new formal release.
07:41:04 <earthy> wxhaskell is held back by relying on ewxc
07:41:13 <earthy> which hasn't been maintained in a while
07:41:14 <hpaste>  louis pasted "data.xml" at http://hpaste.org/5287
07:41:17 <werto> and i found that the only tutorial focused on gtk was the one on the official Haskell home
07:41:25 * shapr throws sticky lambdas at lambdabot
07:41:27 * shachaf thinks focusing on IO too much would make Haskell more difficult.
07:41:31 <oerjan> Cale> @let loeb xs = let ys = fmap ($ ys) xs in ys
07:41:45 <werto> but i'm very happy that this channel is full of life :)
07:42:17 <Cale> oerjan: yeah?
07:42:34 <hpaste>  Joreji pasted "Haskell outermost leftmost evaluation" at http://hpaste.org/5288
07:42:35 <earthy> that's a nice formulation as well
07:42:40 <Joreji> woo
07:42:44 <Joreji> what a nice bot ^^
07:43:15 <mauke> the graph has changed its shape again
07:43:26 <earthy> Joreji: Haskell does not define an evaluation order.
07:43:26 <werto> shachaf, so you think that i should lose lot of time doing nothing?
07:43:27 <Cale> Joreji: it's the latter.
07:43:37 <Joreji> hm thanks
07:43:47 <shachaf> werto: Nothing? No.
07:43:48 <Cale> Joreji: (in lazy evaluation, which is what every implementation actually uses)
07:43:51 <shachaf> Just Haskell. :-)
07:44:06 <oerjan> Cale: i was quoting you for earthy
07:44:19 <werto> shachaf, :-) Haskell without making a little word processor? :)
07:44:26 <Joreji> Cale: okey, just what I was fearing... guess I'll have to tell everybody about it ^^. Thanks alot
07:44:27 <Cale> Joreji: Evaluation is done outermost-first, and pattern matches force things to evaluate just enough to tell if they match.
07:44:35 <Cale> Joreji: fearing?
07:44:38 <Twey> Egh
07:44:47 <Cale> Joreji: What's there to fear? :)
07:44:55 <Joreji> Cale: Yeah, pretty much everyone has it like (a)
07:45:04 <Twey> Gtk2Hs seems just as "where's-my-assignment" as wxHaskell
07:45:07 <Cale> Joreji: Oh, is this for a course?
07:45:07 <Joreji> "Everyone" being the guys from my classes ^^
07:45:11 <Cale> ah
07:45:38 <Joreji> I couldn't really find a nice paper on how pattern matches act in those cases, so I just had to ask :/
07:45:45 <dcoutts> Twey: both are fairly imperative, yes
07:46:03 <Cale> Joreji: That's all right, let us know if you need anything else.
07:46:17 <Joreji> thanks :)
07:46:36 <shachaf> Are there any other working GUI libraries?
07:47:12 <earthy> Joreji: for completeness: both evaluation orders are permitted, but only (b) guarantees the non-strictness properties that Haskell implementations should provide
07:47:22 <shapr> Yes, but I'm suggest using either gtk2hs or wxhaskell.
07:47:26 <shapr> er, "I'd"
07:47:35 <Cale> Joreji: You can derive the fact that it's (b) from the specification that evaluation is outermost first.
07:47:52 <Joreji> hmm
07:48:06 <Joreji> Yeah, I think I pretty much get it now :)
07:48:11 <Cale> Joreji: Up until you have sumFirst2 (16 : 9 : squares 2), the outermost redex is the application of squares
07:48:21 <Cale> but at that point, it becomes sumFirst2
07:48:30 <dcoutts> shachaf: almost all the others are small or unsupported
07:48:45 <conal> shachaf: i think i missed the first part of the GUI conversation.  are you looking for info on GUI libs?
07:48:50 <Twey> shapr, why?
07:48:52 <oerjan> Joreji: outermost first evaluation is always safe but the ghc compiler spends a lot of work finding out when it can reorder for efficiency
07:49:07 <Joreji> Hm I see.
07:49:13 <Cale> earthy: At the top of the paste, it specifically says "outermost leftmost evaluation"
07:49:14 <shachaf> conal: Just curious.
07:49:17 <Joreji> So there is hardly a "definite" answer
07:49:30 <shachaf> conal: werto asked about it originally.
07:49:54 <Cale> Joreji: If you're talking about Haskell. If you're talking about outermost-leftmost evaluation, then the order is completely specified.
07:50:17 <njbartlett> Wow. I know Haskell is an exceptionally friendly community and I shouldn't expect the same elsewhere.... but you should see what just happened on ##java
07:50:24 <Cale> Joreji: The Haskell standard only specifies the semantics (that is the end results of evaluation) of Haskell programs, not the evaluation mechanism.
07:50:43 <Joreji> Cale: Hmm
07:51:11 <werto> i keep searching, i wish a day to make a little tutorial giving peoples like me a good way to learn about other features of Haskell+Glade
07:51:15 <Cale> Joreji: So implementations are free to evaluate things a little more strictly if they want to do so in some circumstances, so long as they can ensure they won't go into nontermination because of it.
07:51:23 <Joreji> Cale: Now I don't really understand. So given that example... there is no definite answer as to how haskell would evaluate it?
07:51:32 * shachaf has been thinking of writing a GUI program, actually.
07:51:45 <conal> shachaf: thx.  i see werto's question now.  looks like interest in gtk specifically.
07:51:56 <phobes> njbartlett: ?
07:52:01 <Cale> Joreji: As to how Haskell-as-specified would. But the implementations generally use lazy evaluation, which is outermost-leftmost first, and so you get the second result.
07:52:36 <werto> conal, yes :) but the hardest thing is to search for an example
07:52:45 <shachaf> conal: My question is separate now. :-) Do you have any suggestions?
07:52:48 <Joreji> Cale: I didn't really want the example to be restricted to leftmost outermost evaluation mechanism. I rather wanted to know how haskell would evaluate it. Leftmost outermost is simply what our teacher told us was the way haskell would evaluate it.
07:52:54 <njbartlett> phobes: Newbie comes on. Asks a silly question, but not outrageous or rude. Operator kicks him. Another user says operator shouldn't have kicked the noob, he gets kicked as well.
07:53:04 <werto> conal, i followed the original one in the Haskell home, but it's not enaugh for me to know
07:53:09 <Cale> okay, then that's what you should assume. It's a safe bet anyway, since all the implementations use that.
07:53:25 <conal> shachaf: it depends on what you value: e.g., functional or imperative.
07:53:40 <Cale> (It's just that technically, if they can work out another way to do it such that you can't tell the difference, they may do so.
07:53:41 <Cale> )
07:53:59 <Joreji> alright
07:54:03 <shachaf> conal: I value: Functional and working (not necessarily in that order). :-)
07:54:10 <shachaf> (And probably portable.)
07:54:10 <Joreji> This settles it then - thanks again :)
07:54:17 <phobes> Joerji:  Note, this is different from langauges where changing the order of evaluation of parameters can change results
07:54:19 <Cale> No problem :)
07:54:55 <phobes> njbartlett:  lol
07:55:20 <Cale> Right, the end result of evaluation, including termination behaviour, is required to be the same as outermost leftmost first evaluation anyway.
07:55:25 <conal> shachaf: some folks have trouble installing gtk2hs and some trouble with wxhaskell.  one of those two is probably a requirement as a basis if not used directly.
07:55:26 <njbartlett> phobes: So I told the operator he was a dickhead and left the room before I could get kicked. Good riddance :-)
07:55:37 <shapr> Comment on ##csharp just now "It's only a 40 line function"
07:55:39 * shapr laughs
07:55:44 <shachaf> conal: I've managed to install both in the past.
07:55:55 <Cale> shapr: hehehe :)
07:56:09 <werto> brb
07:56:15 <shapr> 40 lines of Haskell could take all day to figure out.
07:56:28 <faxathisia> *lol*
07:56:42 <Cale> shapr: I had a look at this python program earlier today which was all in one file, and over 11000 lines long.
07:56:42 <mauke> s/day/week/
07:56:54 <conal> shachaf: then if you want functional, check out TV, phooey, & grapefruit. if imperative, then gtk2hs for user community or wxhaskell for elegance.
07:56:58 <Joreji> Cale, phobes: I'll keep that in mind. Though I have yet to dwell into the "complexity" of operators and their umm... priority (or w/e it was called).
07:57:02 * mux wonders how long would tcp_input() be in Haskell (referring to FreeBSD's kernel tcp_input())
07:57:12 <Cale> (the guy who wrote it had apparently not done so much programming before)
07:57:26 <mux> which is more than 2000 lines long
07:57:26 <Saizan> Joreji: precedence?
07:57:26 <shapr> Cale: Yow! How long did it take to read/understand/refactor?
07:57:29 <Cale> Joreji: precedence?
07:57:42 <Cale> shapr: I didn't bother, but it would take a while.
07:57:46 <Saizan> Joreji: what do you mean by complexity?
07:57:54 <Joreji> errm, yes
07:58:04 <phobes> I'd rather work on a project with a few 10000 files than on one with nested folders five levels deep containing lots of files with like 5-10 lines each
07:58:13 <Joreji> "complexity" as in: so complex I don't really understand it yet :/
07:58:29 <shachaf> conal: Are TV/Phoeey/Grapefruit actually usable for "real programs"?
07:58:33 <Cale> shapr: here's a post with some snippets I picked from it :) http://reddit.com/r/programming/info/66ue3/comments/c030kmk
07:58:50 <shapr> Hm, what's the Traversable equivalent for C# ?
07:59:03 <conal> shachaf: what do you want to do?
07:59:33 <Cin> does anyone understand the BNF representation of IRC messages on RFC2812?
07:59:40 <shachaf> conal: Assume I'm not sure yet. :-)
07:59:55 <Cin> i can't figure out if it's saying that a colon is always necessary or just necessary when there is a space in your parameter
07:59:59 <quicksilver> shapr: assume there isn't one? ;)
08:00:03 <Cale> shapr: Maybe that's what IEnumerable is?
08:00:08 <oerjan> Cin: iirc only if you have a space
08:00:20 <Twey> shapr, why do you suggest using gtk2hs or wxHaskell over the other options?
08:00:24 <shapr> Cale: That python code does look like it could be refactored.
08:00:26 <oerjan> and only the last parameter can have a colon
08:00:30 <Cin> oerjan: my irc clients are able to parse it, but it bothers me that i can't understand the BNF
08:00:40 <shapr> Twey: They have the most forward moment of the graphics libs I know.
08:00:44 <shapr> momentum*
08:00:46 <Cale> shapr: It looks like it was generated by a bunch of macros to me :)
08:00:50 <shapr> heh, that too
08:00:53 <Twey> Ah
08:00:54 <Cale> shapr: But apparently it wasn't.
08:00:55 <Twey> Haha
08:01:14 <Cin> oerjan: do you think you could point out where it says about it only being necesary if you have a space? http://www.faqs.org/rfcs/rfc2812.html
08:01:14 <lambdabot> Title: RFC 2812 (rfc2812) - Internet Relay Chat: Client Protocol
08:01:15 <Twey> I don't know, I feel dirty writing such imperative-looking code in Haskell :-\
08:01:23 <ac> when is it better to use a record as opposed to a tupple?
08:01:23 <shapr> Twey: Thing is, if you don't like what gtk2hs or wkhaskell are doing, you can fix it, and get feedback.
08:01:24 <njbartlett> shapr: Phooey builds on wxHaskell doesn't it?
08:01:31 <Cin> oerjan: if you're not busy, that is
08:01:32 * mux loves "writing C in Haskell"
08:01:39 <shapr> njbartlett: Oh, I don't know.
08:01:46 <shapr> njbartlett: Does it?
08:01:47 <conal> shachaf: i think the usual functional-vs-imperative trade-offs apply.  if you're more used to thinking about GUIs imperatively, then an imperative lib will be more comfortable, while a functional lib will more clarify your thinking.
08:01:56 <shapr> Mr Phooey is probably nearby...
08:02:07 <conal> njbartlett: yes, Phooey is on wxHaskell.
08:02:11 * shapr grins
08:02:12 <Cale> ac: Whenever you have more than a few components, or when your types aren't generic, or when you want to name the components.
08:02:24 <njbartlett> Unfortunately I have a problem with wxHaskell, it doesn't work on Mac OS 10.5
08:02:26 <Twey> shapr, one of the stated ideologies of wxHaskell at least is that they don't care about making it functional right now
08:02:26 <shapr> Is Phooey more 'functional' than wxhaskell alone?
08:02:33 <oerjan> Cin: hm, i may have looked at a much older version
08:02:36 <conal> Phooey and TV (still higher level) could be ported to wxhaskell.
08:02:40 <Cale> I would hope so :)
08:02:44 <shapr> Twey: You could always write a layer on top that looks more functional.
08:02:45 <ac> you can do deconstructive assignment with records, as with tupples I assume
08:02:45 <mauke> Cin: trailing is optional. middle can't contain spaces. trailing can.
08:02:48 <conal> shapr: very much so.  Phooey is functional.  wxhaskell is imperative.
08:02:53 <njbartlett> GTK works on Mac OS, but looks horrible.
08:02:57 <Twey> shapr: And reimplement Phooey?  :-P
08:03:08 <njbartlett> QtHaskell is quite nice, if you don't mind the GPL license.
08:03:10 <mauke> Cin: hmm, it also says you don't need the colon if you already have 14 parameters
08:03:24 <shapr> Cale: Oh, I think that is traversable!
08:03:26 <ac> er, destructuring assignment I meant, as in: do { { field1 = var1, field2 = var2 } <- getRecord ...
08:03:52 <Cale> shapr: It's close, perhaps. Traversable has the neat property of working with any monad at all.
08:03:53 <Cin> mauke: ah, so 14 is the limit, then
08:04:23 <shapr> Yeah, I want to generically traverse a tree for filling into a treeview... can't yet tell if IEnumerable is 1D only.
08:04:28 <mauke> a command can have at most 15 parameters
08:04:35 <mauke> only the last one can contain spaces
08:04:35 <ac> That needs a record type in front: do { FooRecord { field1 = var1, field2 = var2 } <- getRecord; }
08:04:40 <Cin> ah, i see
08:04:47 <Cale> shapr: Unless the LINQ guys were lying, they have some way to do that with LINQ :)
08:04:50 <Cin> after looking at the older spec, i understand its BNF better
08:04:54 <shapr> Ah, that would be best.
08:04:55 <Cin> thanks mauke, oerjan
08:05:06 <shapr> Cale: Any keywords I can throw into google?
08:05:41 <Cale> shapr: I don't know... I'm remembering this from a video that had Erik Meijer in it on some MSDN web show.
08:06:01 <Cale> But it was quite a while ago.
08:06:03 <shapr> Cool, I'll search around for that video.
08:06:32 <Cale> er, hmm...
08:06:56 <Cale> http://channel9.msdn.com/showpost.aspx?postid=114680 -- I wonder if it could have been this one with Anders Hejlsberg
08:06:57 <lambdabot> Title: Anders Hejlsberg - LINQ
08:07:33 <shapr> I'll try it, thanks.
08:09:25 <davidL> Which has better complexity for (!) Map or IntMap (O(log(n)) vs. O(min(n,W)), respectively)?
08:09:55 <Cale> davidL: IntMap, I would bet.
08:10:12 <Cale> Are you sure that's the same n?
08:10:33 <davidL> No, I think that's the problem.
08:11:02 <EvilTerran> i think IntMap has better constants
08:11:05 <conal> i guess my point about functional vs imperative GUI libs is that GUIs are like other things.  imperative is just a mental habit, and it takes effort to shift paradigms.  functional is more elegant and compositional and has clear, tractable semantics to support rigorous reasoning.  in the end it's simpler.
08:11:35 <Cale> davidL: In any event, W is the number of bits in an Int, so you're bounded rather tight :)
08:11:39 <Cin> oerjan: i'm using the Network.IRC library from hackage (instead of writing my own parser). it wasn't suffixing a colon for all messages so i was wondering if it needed to. glad that it is correct, hurrah!
08:11:51 <shapr> I wonder if I have a slightly more generic brother named shapl
08:11:58 <Cale> davidL: Plus, the interfaces are pretty much identical, so you can swap them and see :)
08:12:00 <davidL> Cale: ah ok, thanks :)
08:12:12 <quicksilver> shapr: I believe you have a strict uncle called shapl'
08:12:21 <davidL> Also, why's size for IntMap O(n) and not O(1)?
08:12:23 <shapr> Heh, I know who he is too :-)
08:12:33 <shachaf> conal: Which of the functional libraries would you recommend looking at (first)?
08:13:19 <conal> shachaf: the simplest and most elegant imo is TV/GuiTV .  It's also the most different from previous functional GUI approaches.  TV is compositional MVC.
08:13:22 <Cale> size :: IntMap a -> Int
08:13:22 <Cale> size t = case t of
08:13:22 <Cale>       Bin p m l r -> size l + size r
08:13:22 <Cale>       Tip k x -> 1
08:13:22 <Cale>       Nil     -> 0
08:14:15 <vincenz> why have case?
08:14:21 <davidL> is there a reason IntMap can't keep track of the size like Map does?
08:14:34 <conal> shachaf: TV is the most elegant but also the least flexible.  From there, you might try GUI, either in Monad (but not imperative) form or Applicative form.  grapefruit is very arrow-oriented.
08:15:10 <Cale> davidL: hmm... it would probably increase constants in a bunch of places
08:15:47 <davidL> that's interesting
08:15:52 <Cale> davidL: I actually haven't studied the algorithm really closely, but the source code is there.
08:16:07 <Cale> (click the source link at the top of the page)
08:16:17 <davidL> yeah I'm looking at that now
08:16:19 <conal> shachaf: with a functional GUI, as with functional programming (not IO programming in haskell), you have to think more clearly about what you mean.  i like clear thinking even when difficult, but it's not everyone's think.
08:17:00 <Cale> I think it's just that the structure doesn't naturally keep track of the element count, so they didn't go out of their way to make it track that.
08:17:33 <davidL> Cale: thanks, I'll just assume that the GHC devs knew what they were doing :)
08:19:35 <quicksilver> that's not necessarily wise with the data structures
08:19:41 <quicksilver> I meant, they're reasonable but not necessarily optimal
08:19:51 <quicksilver> I think the emphasis has been on correctness over performance
08:19:54 <quicksilver> which is not unreasonable :)
08:22:33 <davidL> quicksilver: do people tend to create their own data structures rather than use the ones provided by GHC, that is, when they are concerned about performance?
08:23:35 <quicksilver> davidL: I think if people manage to pin down a performance problem to a data structure, they do so.
08:23:39 <jedbrown> dons mentioned that custom lightweight tries have much better performance than some of the usual data structures, and especially HashTable (which is required for one of the shootout entries).
08:23:54 <quicksilver> davidL: it's a relatively unusual class of problem which bottlenecks around a data structure
08:24:06 <quicksilver> and it tends to be in a very specific, rather than general-purpose, fashion :)
08:24:10 <jedbrown> The implication was that it was better than IntMap, but I don't actually know.
08:24:31 <davidL> quicksilver: my application is for a tagging system (like del.icio.us)
08:24:47 <quicksilver> I would start with something easy like Data.Map and get your system running.
08:24:47 <glen_quagmire> let's write a haskell wrapper for facebook api
08:24:58 <davidL> ie. IntMap TagID (IntSet EntryID)
08:25:01 <quicksilver> If you find the CPU requirements don't suit you
08:25:09 <Saizan> glen_quagmire: there's something inside happs
08:25:11 <davidL> glen_quagmire: there is one that is a part of HAppS
08:25:12 <quicksilver> then improve it
08:25:20 <glen_quagmire> w00t
08:28:25 <dons> ?users
08:28:25 <lambdabot> Maximum users seen in #haskell: 451, currently: 434 (96.2%), active: 24 (5.5%)
08:32:23 <jedbrown> dons: How was IntMap performance compared to the custom trie that beats all the hashtable solutions in the shootout?  Do you think IntMap can be made much faster without losing generality?
08:32:24 <sclv> if you don't mind lots of external deps, there are the collections and edison packages as well on hackage, as well as a few other custom data structures.
08:32:27 <shapr> Is 451 the current high water mark?
08:32:39 * shapr thinks fahrenheit 451
08:33:22 <jedbrown> shapr: At least 454 has been seen, but lambdabot has amnesia.
08:33:24 <shachaf> > (451 - 32) * (5/9)
08:33:25 <lambdabot>  232.7777777777778
08:34:55 <swiert>  /quit ()
08:36:01 * oerjan wonders which monad swiert left in
08:36:28 <dons> 456 shachaf
08:36:31 <dons> 456 shapr
08:37:36 <dcoutts> dons, jedbrown: what kind of trie was used in the shootout? we need a decent default Data.Trie for Ord a => [a] keys
08:38:15 <pwned> > 451.0 :: Double
08:38:16 <lambdabot>  451.0
08:38:25 <pwned> > 451.0/ 1 :: Double
08:38:26 <lambdabot>  451.0
08:38:42 <quicksilver> pwned: with the . it will default to double anyway
08:39:01 <pwned> > 451.
08:39:01 <lambdabot>   parse error on input `}'
08:39:02 <shachaf> Or with the (/).
08:39:06 <shachaf> > 451/1
08:39:07 <lambdabot>  451.0
08:39:15 <Tac-Work> > repeat ()
08:39:16 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
08:39:43 <quicksilver> > 3.14 :: Rational
08:39:44 <lambdabot>  157%50
08:39:45 <shachaf> Tac-Work: That looks more like an Applicative than a Monad.
08:39:53 <pwned> wow
08:40:00 <what-> > pi :: Rational
08:40:01 <lambdabot>   add an instance declaration for (Floating Rational)
08:40:01 <lambdabot>     In the expression: ...
08:40:15 <shachaf> > toRational pi
08:40:16 <lambdabot>  884279719003555%281474976710656
08:40:24 <Tac-Work> shachaf, that wasn't supposed to be either. Just me being a bit bored
08:40:40 <shachaf> @src ZipList pure
08:40:40 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:41:07 <dons> http://haskell.org/haskellwiki/Shootout/Knucleotide#.28FASTEST.29_Generalized_Trie_with_Assoc_List_.232
08:41:08 <lambdabot> http://tinyurl.com/2ecfpc
08:41:10 <oerjan> shachaf: same as for lists
08:41:14 <dons> that's the fastest trie we used
08:41:15 <oerjan> er wait
08:41:16 <jedbrown> dcoutts: data TValue = TV {tc :: Int, tm :: TMap}; type TMap = [(Char,TValue)];
08:41:18 <Tac-Work> > pure (+) <*> zipList [1,2,3] <*> zipList [1,2,3]
08:41:19 <lambdabot>   Not in scope: `zipList'
08:41:21 <oerjan> rubbish, it's repeat
08:42:22 <dcoutts> jedbrown: are the assco lists short? otherwise you could go faster with an IntMap
08:42:40 <shachaf> oerjan: Yes, that's what I meant. :-)
08:42:46 <jedbrown> dcoutts: For this case, yes.
08:42:53 <Tac-Work> > pure (+) <*> ZipList [1,2,3] <*> ZipList [1,2,3]
08:42:53 <lambdabot> Terminated
08:43:00 <Tac-Work> /sad
08:43:12 <oerjan> pure is ambiguous
08:43:30 <oerjan> > Control.Applicative.pure (+) <*> ZipList [1,2,3] <*> ZipList [1,2,3]
08:43:31 <lambdabot>   add an instance declaration for (Show (ZipList a))
08:43:41 <shachaf> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6,7]
08:43:42 <lambdabot>  [5,7,9]
08:43:46 <Tac-Work> what other pures are there?
08:43:53 <oerjan> Control.Arrow
08:43:54 <jedbrown> dcoutts: For the general case, I'm not sure what is best.  It certainly depends on the maximum length of the alist.
08:43:59 <Tac-Work> ah
08:44:19 <Tac-Work> Haskell has so many name clashes between modules it's not funny
08:44:20 <shachaf> (Why does Control.Arrow use the name "pure"?)
08:44:44 <Tac-Work> but at least it makes it obvious what everything does
08:44:59 <Tac-Work> pure probably arrowfies a function, because that's what the applicative version does
08:45:15 <jedbrown> dcoutts: Well, the typical length.  And with only Ord, you need Map (instead of IntMap).
08:45:16 <shachaf> Isn't "arr" enough?
08:45:24 <oerjan> pure = arr, so it would be reasonable to import Control.Arrow hiding (pure)
08:45:29 * Tac-Work doesn't know Arrows, he's just guessing
08:45:38 <dcoutts> jedbrown: no, I mean a trie with an IntMap instead of the assoc list
08:45:46 <monochrom> name clash is the result of meaningful naming.
08:46:47 <oerjan> :t Control.Arrow.pure -- good guess
08:46:48 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
08:47:04 <Tac-Work> :t arr
08:47:05 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
08:47:19 <Tac-Work> huh... same types
08:47:23 <Tac-Work> (clearly they are the same!)
08:47:36 <jedbrown> dcoutts: If you want Ord a => Trie [a].  Then the nodes can't have an IntMap since that requires an Int.
08:48:31 <dcoutts> jedbrown: a Char is almost an Int
08:48:33 <oerjan> Tac-Work: at least for a = (->) they would have to be, barring bottom
08:49:09 <oerjan> @free (b -> c) -> (b -> c)
08:49:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
08:49:18 <oerjan> @free pure :: (b -> c) -> (b -> c)
08:49:18 <lambdabot> g . h = k . f => g . pure h = pure k . f
08:49:22 <jedbrown> dcoutts: That was specialized for the problem.  I think the Char had only 4 possible values.
08:49:55 <jedbrown> dcoutts: But if you want for Ord a, IntMap isn't an option.
08:50:12 <nomeata> Igloo: Hi. Im going to package xmonad 0.6 now. Any chance that youll upload haskell-x11 now? Or can you at least tell me what is holding you back?
08:50:34 <dcoutts> jedbrown: yes, I was only referring there to the special Char case
08:50:39 <dons> nomeata: maybe you can just do haskell-x11
08:50:44 <dons> i'm sure Igloo won't mind.
08:51:10 <nomeata> dons: when I asked him three weeks ago, he did mind (but that was when I had to use the backported cabal file)
08:51:19 <oerjan> g = const (k x), h = whatever, f = const x proves pure k = k
08:51:30 <dons> ah but now you don't need to , since we have 6.8.x
08:52:15 <jedbrown> dcoutts: Okay, it was the nucleotide problem, so the only possible characters were A,C,G,T.
08:52:57 <dcoutts> jedbrown: ok, so use an even more special trie node
08:53:20 <jedbrown> dcoutts: I think that would be better, but I don't think it was implemented.
08:53:31 <dcoutts>  data TValue = TV {tc :: Int, tm :: TMap}; data TMap = TMap (Maybe TValue) (Maybe TValue) ... 4 times
08:53:54 <jedbrown> dcoutts: Yeah.
08:54:47 <jedbrown> dcoutts: But the shootout mandates that we must use a hashtable, so making a better specialized trie is pointless.
08:55:02 <dcoutts> jedbrown: ugg, that's horrible
08:55:14 <fourbissime> hello there. I have a question about equality testing. I have a type with a list of constructors. Some of those constructors have a few more informations. What I would like to do is to test equality based only on the constructors rather than the constructor + the content, as the default implementation seems to do. I'm not sure to see how I can do that ...
08:55:19 <dcoutts> jedbrown: so what do you use for a hastable? an IntMap?
08:55:32 <nomeata> dons: its still quite against Debian customs to upload that. Im currently discussing it on #debian-devel, and options diverge
08:55:34 <shachaf> fourbissime: Write your own Eq instance, probably.
08:56:03 <jedbrown> dcoutts: That's a trie so we can't use that.  Also, you would need a hash to get an Int.
08:56:19 <shachaf> fourbissime: instance Eq MyType where C == C = True; D _ == D _ = True; _ == _ = False -- Something like that, perhaps?
08:56:30 <dcoutts> jedbrown: sure, hash the string to an int and use the intmap with buckets
08:56:40 <fourbissime> shachaf: well yeah, it seems to be the solution, but I have something like 40+ constructors ...
08:56:52 <shachaf> fourbissime: Oh.
08:57:00 <oerjan> fourbissime: ouch.
08:57:06 <oerjan> @hoogle toConstr
08:57:06 <lambdabot> Data.Generics.Basics.toConstr :: Data a => a -> Constr
08:57:08 <jedbrown> dcoutts: But it's not a hash.  The entry uses a hand-rolled hash table translated from C.
08:57:13 <fourbissime> maybe it is bad design from the begining ...
08:57:18 <shachaf> That's a lot. :-)
08:57:23 <oerjan> fourbissime: then you might want that.
08:57:30 <dons> nomeata: we just haven't seen Igloo around, have we?
08:57:33 <shachaf> But yes, toConstr should work.
08:58:15 <dcoutts> jedbrown: they absolutely want a hash based on arrays, and make no allowance for languages with persistence?
08:58:15 <nomeata> dons: no, havent heard from him for three weeks.
08:58:19 <nomeata> @seen Igloo
08:58:19 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I don't know when Igloo last spoke.
08:58:35 <jedbrown> dcoutts: That problem is a lost cause.
08:58:37 <dons> hmm
08:58:42 <dons> dcoutts: seen Igloo around?
08:58:50 <dcoutts> dons: not today
08:59:20 <jedbrown> dcoutts: define a procedure/function to update a hashtable of k-nucleotide keys and count values, for a particular reading-frame  even though we'll combine k-nucleotide counts for all reading-frames (grow the hashtable from a small default size)
08:59:44 <jedbrown> dcoutts: It's pretty explicit.
09:00:50 <dolio> Is it definite that they're not using "hashtable" as a synonym for "map" as many people do?
09:01:18 <jedbrown> dolio: The trie-based entry was disqualified.
09:01:29 <dolio> Ah. That's a yes, then, I suppose. :)
09:01:39 <dcoutts> jedbrown: the ocaml one cheats and use a large initial hash size :-)
09:01:48 <dcoutts> of 40,000
09:01:55 <idnar> speaking of Debian haskell packages, darcs build-deps seem to be broken
09:02:07 <jedbrown> dcoutts: heh
09:02:18 <idnar> well, libghc6-regex-compat-dev specifically
09:02:44 <ac> Is there a way to add methods to a type class? The obvious solution is to just make an additional class with the extra methods, but then for every type I want an instance I need to write two instance declarations
09:03:15 <shachaf> ac: class (OldClass a) => NewClass a where ...
09:03:28 <jedbrown> dcoutts: 0x40000 = 262144
09:03:40 <dcoutts> jedbrown: oh yes :-)
09:03:44 <lispy> now the social network is looking cool
09:03:45 <shachaf> ac: Then (NewClass a) => will imply OldClass.
09:03:51 <lispy> http://files.codersbase.com/haskell/haskell-current.png
09:03:51 <ac> shachaf: but then I have to give new names for all the methods in OldClass for NewClass
09:04:02 <nomeata> idnar: thats in the NEW-queue, AFAIK
09:04:07 <quicksilver> ac: no you dont?
09:04:16 <ac> shachaf: or for every instance say: instance OldClass foo where ....; instance NewClass foo where ....
09:04:27 <quicksilver> ah yes
09:04:28 <nomeata> idnar: http://ftp-master.debian.org/new.html
09:04:28 <lambdabot> Title: Debian NEW and BYHAND Packages
09:04:30 <quicksilver> you do need to do that :)
09:05:10 <shachaf> ac: That's just for the instances, though.
09:05:24 <shachaf> ac: Is that necessarily a bad thing?
09:05:47 <quicksilver> it's only four extra words.
09:05:50 <ac> heh
09:06:00 <quicksilver> The annoying thin is when you want to always define OldClass methods in terms of NewClass methods.
09:06:07 <quicksilver> then you need some version of the class alias propoasl.
09:06:12 <idnar> nomeata: huh, what's the new binary?
09:06:36 <idnar> oh, the doc package got renamed
09:06:41 <hpaste>  sebjoh pasted "vimrc" at http://hpaste.org/5289
09:06:42 <nomeata> idnar: not in the archive yet... you can write the maintainer if he has uploaded anywhere yet
09:07:02 <idnar> nomeata: well, I was wondering why it landed up in NEW; but I see the doc package was renamed
09:07:33 <eugman|work> I think I've got an idea for a project. Using haskell and wxhaskell I could make a program that allows me to type up notes, automatically ask questions and export the notes into a few different formats for printing or putting up online. Any thoughts?
09:07:53 <nomeata> idnar: ok, I see know about the Debian package ways :-)
09:08:36 <idnar> nomeata: http://qa.debian.org/developer.php?login=mithrandi@mithrandi.za.net :) (still in NM, though...)
09:08:39 <lambdabot> Title: Debian Quality Assurance -- Debian Developer's Packages Overview, http://tinyurl.com/2tsmek
09:08:55 <lispy> eugman|work: sounds challenging and useful
09:09:30 <dons> http://reddit.com/r/programming/info/66vkr/comments/ "xmonad 0.6 released: your favourite purely functional window manager "   :)
09:09:33 <byorgey> eugman|work: sounds interesting. what do you mean by "automatically ask questions"?
09:09:44 <byorgey> dons: =)
09:11:18 <eugman|work> byorgey, Well it wouldn't be fully automatic but the idea is when you add int he notes you can add additional information so it can make questions absed on that. Say other options for multiple choice or which part goes where for a fill in the blank.
09:11:49 <byorgey> eugman|work: oh, I see, so you're talking about lecture notes.
09:12:17 <eugman|work> Right, as a way to practice besides jsut reading.
09:12:26 <byorgey> ok, right.
09:12:44 <eugman|work> Would xml be good for storing small marked information? A database seems excessive for my idea.
09:13:11 <dons> if its small, read/show format might be ok
09:13:13 <byorgey> eugman|work: don't bother with xml, just use a simple flat file format.
09:13:16 <dons> or Data.Binary
09:13:59 <shachaf> Or YAML. :-)
09:13:59 <byorgey> xml is only useful as a standard for communicating between different pieces of software.
09:14:09 <desegnis> wait, marked information as in text markup?
09:14:25 <jonafan> does haskell have proper thread support so it can run on multiple cores?
09:14:35 <byorgey> @faq thread support
09:14:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:14:39 <jonafan> haha
09:14:45 <jonafan> okay cool
09:14:50 <Philippa> @faq your mom
09:14:50 <lambdabot> The answer is: Yes! Haskell can do that.
09:14:55 <Philippa> (sorry, had to be said)
09:14:58 <byorgey> jonafan: dons wrote some good blog posts about that recently.
09:14:58 <Philippa> but yes, it can
09:15:02 <desegnis> jonafan: ghc -threaded is required iirc
09:15:08 <eugman|work> desegnis, well maybe I didn't know a better way to put it. it doesn't ahve to be marked up but some information has relationships to other information and i'm not sure of what ways to do that.
09:15:22 <jonafan> that's one disappointing thing about ocaml
09:15:32 <eugman|work> @faq fight crime
09:15:33 <lambdabot> The answer is: Yes! Haskell can do that.
09:15:37 <shachaf> @faq Make a problem so hard, even Haskell can't solve it?
09:15:37 <lambdabot> The answer is: Yes! Haskell can do that.
09:15:40 <byorgey> jonafan: it turns out that doing multithreaded stuff in Haskell is actually really, really nice.
09:16:04 <byorgey> shachaf: yes, that's known as the halting problem =)
09:16:10 <jonafan> yeah, i'm starting to understand how awesome functional programming is for multithreading
09:16:18 <shachaf> @faq Solve the halting problem.
09:16:18 <lambdabot> The answer is: Yes! Haskell can do that.
09:16:39 <cjb> jonafan: http://www.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking / http://www.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core
09:16:41 <lambdabot> Title: Haskell hacking
09:16:46 <byorgey> jonafan: it's not so much functional programming per se, but purity which is great for multithreading, which is where Haskell really shines.
09:17:40 <moobax> I've just built a DLL (using GHC -shared) but I'm getting link errors when I try to build another project with it: multiple definition of hs_init and hs_exit. They are in both the .dll.a and libHSrts_p.a. any ideas?
09:18:04 <desegnis> eugman|work: I guess you'll know best yourself, given that it's you who understands, or knows, your requirements ;)
09:18:21 <dcoutts> moobax: the dll is for exporting to foreign code, not for building with other haskell packages
09:18:58 <dcoutts> moobax: so it's like a main function, it's the top level of a set of packages
09:19:33 * desegnis finally bought a new mouse and keyboard and still has to accustom to the new feel
09:19:39 <moobax> yeah I was just using ghc as a proxy for gcc as I was lazy. think it will work with gcc directly?
09:19:44 <dcoutts> moobax: or perhaps I misunderstnad what you're doing
09:20:26 <dcoutts> moobax: btw, the libHSrts_p.a is the profiling version, do you really mean to be using that?
09:20:46 <moobax> kind of
09:21:02 <dcoutts> moobax: I think you need to say what it is you are trying to do
09:21:53 <moobax> ok... I'm trying to use the FFI where all my haskell code is nicely wrapped up in a DLL
09:22:24 <dcoutts> moobax: as I understand it, the dll you've built is really like a statically linked final program, except that it exports a bunch of entry points rather than just main
09:22:39 <dcoutts> so it contains a full copy of the ghc runtime system
09:22:45 <dcoutts> just like any final exe would
09:22:58 <dcoutts> so it's fine to link into an external C/C++ program
09:23:08 <dcoutts> but not to go and link with yet more haskell code
09:23:48 <araujo> hello
09:24:01 <byorgey> dcoutts: I keep seeing "Setup.lhs: fd:13: hGetContents: illegal operation (handle is closed)" when running Setup configure with darcs cabal (but everything still works correctly).
09:24:12 <byorgey> dcoutts: any idea what might cause that?  a spurious 'hClose' maybe?
09:24:12 <ehird> how do i get a lazy string of all of stdin?
09:24:18 <ddarius> getContents
09:24:33 <dcoutts> byorgey: yes that was my fault, I think JaffaCake has pushed a patch already
09:24:43 <byorgey> dcoutts: ah, ok, no worries then =)
09:24:46 <dcoutts> byorgey: ah, yes, he did push it
09:25:05 <byorgey> dcoutts: ok, I'll go do a pull.
09:25:34 <byorgey> dcoutts: I should have a patch for the x- fields thing, although it wasn't as straightforward as I thought it would be
09:25:37 <moobax> dcoutts: is there any way to suppress that link when using ghc as a c compiler? The thing is, I don't have gcc installed separately, just the ghc version, so if I can use that, it'll save me installing cygwin
09:25:51 <dcoutts> byorgey: oh good, so what was the complicating factor?
09:26:22 <dcoutts> moobax: ah, I see. I'm not sure there is, linking using ghc always links in the rts.
09:26:27 <byorgey> dcoutts: well, the whole field-parsing framework is based on matching field names with FieldDescr thingys
09:26:35 <moobax> dcoutts: damn.
09:26:42 <byorgey> dcoutts: but in this case we want to process fields that *don't* match
09:26:43 <dcoutts> moobax: ghc comes with a copy of gcc of course, but I'm not sure how easy it is to use without going via ghc
09:26:57 <dcoutts> byorgey: right yes
09:27:06 <byorgey> dcoutts: and at the point where we discover there's an x- field, it's polymorphic in the structure being parsed into
09:27:22 <dcoutts> byorgey: right, it just doesn't have that in mind
09:27:47 <byorgey> dcoutts: so I added an extra parameter to the parseField and parseFields functions, which is a function of type (String,String) -> a -> Maybe a
09:28:05 <byorgey> dcoutts: to which any non-matching fields are passed, and it can decide whether it wants to do anything with it
09:28:17 <dcoutts> byorgey: btw, as you hack that stuff if you see any obvious simplifications, don't hesitate :-) or if they're harder, leave TODO notes
09:28:24 <byorgey> dcoutts: does that sound like a good solution to you?
09:28:29 <byorgey> dcoutts: ok, sure =)
09:29:20 <dcoutts> byorgey: seems reasonable, yes it's like we have a default FieldDescr or something
09:29:57 <byorgey> dcoutts: yes, but it's a bit more general than that
09:30:33 <byorgey> dcoutts: well, assuming testing goes ok I should send it to the list in a little bit, and you can look at it in more detail
09:30:44 <dcoutts> byorgey: ok, great
09:30:57 <moobax> dcoutts: I'd like to use a static lib instead of the RTS, to be honest. is there any way to get the RTS statically included in an archive?
09:31:17 <moobax> oops
09:31:23 <moobax> i mean, instead of a DLL
09:31:32 <dcoutts> moobax: the rts *is* included in the dll
09:31:51 <dcoutts> you get a single dll that includes all the haskell code and the rts
09:32:10 <moobax> sorry, let me explain. If I want to make a static lib instead of a DLL, how do I get make the static lib so that the RTS is inside it?
09:32:58 <dcoutts> moobax: I'm not so sure about that, typically it's not necessary since you can just link with the rts which is another static lib
09:33:34 <dcoutts> moobax: ie build your package normally and then link everything together using ghc at the end, C code and all
09:33:40 <eugman|work> Does haskell have any support for ouptutting to a word processor file like rtf or odt?
09:34:07 <quicksilver> eugman|work: that would be a library issue not a language one.
09:34:22 <moobax> ok, thanks :)
09:34:37 <dcoutts> eugman|work: you check hackage, but I've not heard of anything, except for raw xml libs
09:34:37 <quicksilver> eugman|work: I've not seen an RTF binding. Maybe gtk2hs has something built in to some of its widgets?
09:34:46 <dcoutts> quicksilver: nope
09:34:49 * quicksilver nods
09:34:53 <Saizan> http://johnmacfarlane.net/pandoc/ <-- this handles rtf
09:34:55 <quicksilver> RTF's not a great format anyway :)
09:35:06 <quicksilver> Saizan: nice
09:35:42 <quicksilver> if that's not mentioned somewhere on the wiki, it should be.
09:35:47 <eugman|work> quicksilver, yeah I guess I knew that. How should I phrase a question like that to make that clear? "Are there any libraries for..."?
09:36:12 <dcoutts> eugman|work: and always the first place to look it hackage :-)
09:36:14 <dcoutts> @where hackage
09:36:14 <lambdabot> http://hackage.haskell.org/
09:37:39 <eugman|work> Ah-k
09:39:00 <shachaf> augustss_: xmonad is 1308 lines right now, using the line-counting program in tests/.
09:41:29 <quicksilver> eugman|work: I was being slightly unfairly pedantic. YOu asked it OK.
09:41:34 <quicksilver> I just wanted to be clear :)
09:50:45 <dcoutts> @seen ndm
09:50:45 <lambdabot> I haven't seen ndm.
10:05:32 <hpaste>  mmorrow pasted "line count of mmapped file" at http://hpaste.org/5290
10:10:27 * byorgey sings the compiling song
10:10:36 <mauke> ZZ Top - Gimme All Your Lovin'
10:11:50 * dcoutts discovers hasktags + vim and is much pleased
10:12:24 <dcoutts> has everyone else always been using tags and I'm just that slow to catch on?
10:12:58 <dcoutts> and if so, do you use hasktags or something else and how do you automate it?
10:13:00 <shag> is there a way to make my haskell programm detach itself and go to the background?
10:13:15 <dcoutts> shag: on unix CTL-Z
10:13:22 <shag> yea, i know
10:13:30 <shag> but can i make my program do that by itself
10:13:37 <dcoutts> ah, check System.Posix
10:13:45 <shag> k, thanks
10:15:36 <joglala> Hello
10:15:42 <jbms> shag: that sort of thing is typically done by fork
10:15:51 <dons> welcome joglala
10:16:19 <mauke> shag: it would be easier to write a detaching wrapper around your program
10:16:20 <proq> dcoutts: emacs has built-in key commands to handle tags, although I don't use tags.
10:16:36 <joglala> :)
10:16:37 <shapr> lispy: That is cool!
10:16:42 <shag> mauke: ok, thats what i initially thought about
10:16:56 <shapr> dcoutts: I've been using tags for years. It's better than grep.
10:17:13 <dcoutts> shapr: indeed, so what do you use for haskell tags?
10:17:15 <shag> jbms: do you have one or two more hints on how to detach by using fork?
10:17:20 <shapr> dcoutts: Only automation I have is hasktags **/*hs~_darcs
10:17:39 <dcoutts> shapr: someone should include it in cabal :-)
10:17:40 <shapr> dcoutts: That picks up lhs and hs files, and doesn't mean you end up breaking darcs repos.
10:18:22 * byorgey is intrigued.
10:18:33 <shapr> dcoutts: There is some way to reference other tags files from one file, but I haven't found a way to filter a tags file to a particular set of libs.
10:18:33 <byorgey> what is this 'hasktags' thing, and where can I learn about it?
10:18:39 <dcoutts> there's a ticket for it actually I think
10:19:06 <dcoutts> byorgey: it's a program that comes with ghc to generate c/etags format that vim and emacs understand
10:19:19 <dcoutts> byorgey: but ghci can also generate tags, and probably more accurately
10:19:34 <byorgey> dcoutts: oh.  what are c/etags for?
10:19:55 <dcoutts> eg in vim, put the cursor over a function name, and press ctl-]
10:20:00 <dcoutts> it jumps to definition
10:20:07 <byorgey> !
10:20:14 <dcoutts> then ctl-t to jump back (it's a stack)
10:20:19 <shapr> byorgey: Roughly it's a list of function names and file/line number locations.
10:20:25 <byorgey> why didn't I know about this before?!
10:20:34 <byorgey> that's awesome
10:20:40 <shapr> In emacs it's M-. and M-* to jump to a definition and back to previous location.
10:20:43 <dcoutts> byorgey: I was just asking the same myself
10:20:44 <dons> very useful for jumping into the ghc source tree
10:20:48 <shapr> Yup
10:20:58 <dons> i've been using it for 5 years or so, fwiw dcoutts :)
10:20:59 <shachaf> dcoutts: Which is recommended, hasktags or ghci?
10:21:04 <dcoutts> dons: so what do you use, and where do the tags files live?
10:21:08 * byorgey has just spent way too much time incremental-searching around the cabal source
10:21:15 <shapr> byorgey: ouch!
10:21:15 <dons> hasktags. and i put the in a ~/.tags file
10:21:21 <dons> and import those into vim
10:21:25 <byorgey> shapr: yeah, tell me about it =)
10:21:42 <dcoutts> dons: does vim look at that file automagically? it seems to look at tags in the current dir
10:21:58 <dons> :set tags=/home/dons/.fptools-tags
10:22:07 <shachaf> (Does either work on a file with cpp in it?)
10:22:08 <dons> in my .vimrc
10:22:09 <shapr> If you do it the 'right' way, tags files live in the directory that holds the actual source files, and then you have other tags files in the directory above that reference the tags files lower down the dir tree.
10:22:09 <dcoutts> dons: what would be the right thing for cabal to do, presumably we'd want a tags file per package
10:22:12 <proq> do you pronounce the ell in haskell like "Al" or like "fell"?
10:22:22 <dons> like 'skull'
10:22:30 <dons> :)
10:22:32 <shapr> If you do it the quick hackish way you just slurp all the source files into a single tags file. That's what I do.
10:22:34 <proq> ah  :)
10:22:42 <byorgey> shapr: do you use vim or emacs?
10:22:49 <shapr> emacs mostly.
10:23:24 <byorgey> shapr: would you mind spelling out in a bit more detail how you have things set up to use tags?
10:23:34 <byorgey> I didn't even know about this feature until two minutes ago. =)
10:24:19 <dcoutts> byorgey: http://hackage.haskell.org/trac/hackage/ticket/207
10:24:21 <lambdabot> Title: #207 (Jumping to code every and anywhere: What about installing source files and ...
10:25:16 <Deewiant> I've known about tags for a long time, never felt the need myself though
10:25:40 <shapr> byorgey: Let's say you have Foo.hs that imports Bar.hs, both in ~/src/haskell/   first you run hasktags *hs, then you open Foo.hs in emacs. Let's say that Bar.baz is called in Foo.hs. You hit M-. on top of the word baz, and emacs should ask you if the TAGS file is in the current dir, ask if you want to load that file, then jump to the definition of baz in Foo.hs
10:26:00 <shapr> byorgey: Was that helpful?
10:26:06 <byorgey> shapr: yes, very, thanks
10:26:10 <shapr> Cool
10:26:19 <byorgey> shapr: and do you have anything set up to automate it in any way?
10:26:38 <dcoutts> shapr: so how would you organise it with cabal? supposing you want to be able to jump to definition for any installed lib
10:26:52 <byorgey> dcoutts: that would be hot
10:27:07 <dcoutts> shapr: cabal could install the pre-processed source and the per-package tags file
10:27:08 <shapr> dcoutts: I don't. Always wanted to though.
10:27:16 <shapr> dcoutts: That would be very handy.
10:27:30 <dcoutts> shapr: I know you don't yet, I'm asking where should cabal put these things for it to work
10:27:48 <shapr> Oh, um...
10:27:52 <dcoutts> how would we tell vim where to look?
10:28:14 <shachaf> dcoutts: :se tags+=some_tag_file
10:28:22 <shachaf> dcoutts: Or do you want it per-package?
10:28:28 <dcoutts> shachaf: right, but if I've got 100 packages installed...
10:28:47 <shapr> I think a tags file can reference another file, so there could be a single file somewhere that gets a new reference when new source is installed.
10:28:57 <dcoutts> shachaf: yes, unless we automagically merge into one massive tags file whenever we install a new package
10:29:11 <shapr> If it's just a list of references to other files, it won't be too large.
10:29:24 <shapr> But I'm not sure if it's referencing or actual inclusion of contents.
10:29:32 <dcoutts> shapr: ah, so perhaps cabal could just maintain $HOME/.cabal/tags which would include the tags files for all the other packages?
10:29:41 <shachaf> dcoutts: Also keep conflicting names in mind.
10:29:49 <dcoutts> shachaf: true true
10:30:07 <dcoutts> tags are not module sensitive of course
10:30:19 <dcoutts> vim doesn't know which module a name was imported from
10:30:23 * shachaf would like to be able to ^] into Prelude functions.
10:30:37 <dcoutts> shachaf: I see no reason why not
10:31:03 <dcoutts> though bear in mind that the nice definition is not always the same as the real one
10:32:08 * byorgey does the 'TAGS are hot!!' dance
10:32:16 <byorgey> shapr++
10:32:56 <shapr> dcoutts: This ten year old ctags format description implies that everything must be included, dunno if etags is any different: http://ctags.sourceforge.net/FORMAT
10:33:48 * olsner does the 'tags are lukewarm' nod
10:34:20 * oerjan does the 'tags are freezing cold' shake
10:35:22 * shachaf seems to remember that generating tags didn't support cpp.
10:36:20 <olsner> C++? C Preprocessor?
10:36:51 <shachaf> olsner: C preprocessor.
10:36:55 <shachaf> olsner: (In Haskell.)
10:37:53 <olsner> oh, okay
10:40:26 <dcoutts> would you not cpp before generating tags?
10:41:22 <shachaf> dcoutts: Then the line numbers would be all wrong.
10:41:48 <dcoutts> shachaf: not if the tags program groked line pragmas, like ghci's tags does
10:42:08 <dcoutts> then it works for arbitrary pre-processors
10:43:52 <dcoutts> ghci  :ctags or :etags
10:44:09 <shachaf> Hmm, OK.
10:48:43 <skorpan> hey
10:49:04 <ski_> hej
10:49:12 <skorpan> is there any function in haskell which takes a string and returns a datatype? i.e. "MyDataType" -> MyDataType
10:49:27 <dons> an 'eval' function?
10:49:28 <skorpan> lol tja ski_ hur mr remote1?
10:49:34 <faxathisia> read maybe does it?
10:49:35 <ski_> @type read
10:49:37 <ski_> ?
10:49:37 <lambdabot> forall a. (Read a) => String -> a
10:49:42 <dons> or just 'read' / 'decode'
10:49:57 <ski_> skorpan : min screen dog tidigare idag :(
10:50:04 <skorpan> ski_: det suger ju
10:50:25 <desegnis> How to let ghci :ctags tag multiple modules at once?
10:50:32 <ski_> skorpan : hade bara vart igng nn mnad eller nt ..
10:50:49 <skorpan> ski_: lser du avancerad funktionell mnne?
10:50:58 <ski_> skorpan : har lst :)
10:51:00 <byorgey> dcoutts: how do I run the HUnit tests in PackageDescription.hs?
10:51:04 <skorpan> mkay mkay, lser det nu
10:51:15 <ski_> skorpan : Koen ? Hughes ?
10:51:19 <desegnis> And how to have hasktags give sorted output?
10:51:24 <skorpan> ski_: nn satans "ulf" tyvrr
10:51:31 <Tobsan> :o
10:51:33 <ski_> skorpan : Norell ?
10:51:33 <skorpan> lol Tobsan
10:51:35 <Tobsan> ulf norell heter han
10:51:36 <Tobsan> tja skorpan
10:51:37 <dons> dcoutts: i wonder if john hughes' company would like to co-sponsor the hackathon
10:51:37 <skorpan> ski_: s ja
10:51:39 <Tobsan> skorpan: mm han
10:51:46 <desegnis> And what is the difference between hasktags and ghci tags?
10:51:50 * ski_ har bara namnet hrt
10:51:54 <desegnis> Questions over questions.
10:51:58 <skorpan> han r inget vidare :/
10:52:07 <dcoutts> byorgey: honestly, I've never done it. There's a target in the Makefile to do it. I expect it do be fairly bitrotted. There's an open ticket on it.
10:52:09 <Tobsan> skorpan: han r ju ball iofs
10:52:11 <dcoutts> dons: mmm
10:52:16 <skorpan> Tobsan: r du helt vck eller
10:52:21 <Tobsan> snackaru om
10:52:22 <skorpan> han str bara dr framme och frsker imponera p alla
10:52:25 <Tobsan> vrsta nrden
10:52:25 <Tobsan> ja
10:52:26 <dcoutts> dons: co-? who else is sponsoring it?
10:52:26 <Tobsan> lol
10:52:27 <byorgey> dcoutts: ah, I see =)
10:52:33 <skorpan> och dricker sitt kaffe hela tiden, sjukt irriterande
10:52:35 <Tobsan> xD
10:52:36 <skorpan> och viftar med armarna
10:52:41 <Tobsan> ahahahaha
10:52:50 <ski_> lter roligt :)
10:52:56 <skorpan> knner personligen ingen som fattade dagens frelsning
10:53:00 <dcoutts> byorgey: last time we made major changes to the parser our testsuite was to parse every single .cabal file from hackage.
10:53:10 <ski_> skorpan : om ?
10:53:19 <olsner> wtf, har vi bytt till svenska pltsligt?
10:53:20 <Syzygy-> ?go 30000 usd in eur
10:53:20 <lambdabot> 30,000 U.S. dollars = 20,370.7476 Euros
10:53:23 <byorgey> dcoutts: makes sense.
10:53:43 <shapr> jag har ingen aning vad du sager, men har ar kanin med pannkaka pa huvudet.
10:53:46 <ski_> olsner : japp, svenska r p vg att bli vrldssprk
10:53:47 <desegnis> Hej, that Swedish stuff is not fair. I cannot practically call my cousin just to understand what's going on on #haskell.
10:53:54 <oerjan> :D
10:53:58 <Deewiant> shapr: LOL.
10:54:11 <Deewiant> oh yeah, that's a meme. never mind.
10:54:21 <Deewiant> I thought you just came up with that. :-P
10:54:29 <shapr> It is something that I like to say.
10:54:30 <olsner> desegnis: think proactively - call your cousin, learn swedish, and join us for all eternity
10:54:45 <skorpan> ski_: monader
10:54:49 <shapr> I have a picture of a rabbit with a pancake on its head, entertains me to no end.
10:54:55 <shapr> funktionella sprak!
10:54:59 * Japsu just had a Swedish exam today
10:55:03 <faxathisia> lambda rabbit!
10:55:03 <skorpan> ski_: monader r jag inte helt frmmande fr men det han gjorde var att han kodade sjukt mycket och sen sa han "this is a monad!!"
10:55:06 <ski_> skorpan : monader r koola !
10:55:07 <dons> ?users
10:55:07 <lambdabot> Maximum users seen in #haskell: 451, currently: 439 (97.3%), active: 18 (4.1%)
10:55:07 <desegnis> olsner, :)
10:55:10 <shapr> I can't figure out how to type swedish letters on windows :-(
10:55:23 <ski_> skorpan : parsning ?
10:55:23 <Deewiant> having a scandinavian keyboard layout helps
10:55:24 <Tobsan> skorpan: mm fattade inget
10:55:31 <skorpan> ski_: n han hittade p nt annat
10:55:35 <shapr> I need to find some people in Boston who speak Swedish, I'm forgetting lots :-(
10:55:40 <skorpan> mste labba lite nu, bbl!
10:55:41 <ski_> skorpan : lnk ?
10:55:46 <ski_> s///
10:56:28 <Japsu> hmm, finns det ngon bra programmingordlista p ntet
10:56:56 <desegnis> shapr: Go buy a compose key
10:56:58 <skorpan> ski_: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures.html
10:56:59 <lambdabot> Title: Advanced Functional Programming
10:57:13 <bos> har du kramat din varg idag?
10:58:04 <ski_> (shapr : annars kan du s//ao/,s//ae/,s//oe/ (eller s//a"/,s//o"/), det gr jag ibland)
10:58:31 <skorpan> fan kr erc i emacs och en massa abbreviations
10:59:01 <skorpan> Tobsan: har du lyckats implementera frger i animeringen?
10:59:10 <Tobsan> skorpan: lol nej
10:59:12 <Tobsan> har ej provat ens
10:59:13 <skorpan> ok
11:00:01 <litb> guys, i have a question
11:00:08 <litb> x*x or x**2 , what is better?
11:00:15 <oerjan> litb: x*x
11:00:30 <litb> even thogh the intention is not so clear with that?
11:00:39 <desegnis> :t (**)
11:00:40 <lambdabot> forall a. (Floating a) => a -> a -> a
11:00:45 <desegnis> :t (^)
11:00:46 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:00:53 <oerjan> ghc doesn't quite optimize exponentials last i heard
11:00:59 <skorpan> doesn't ghc optimize that?
11:01:00 <skorpan> oh
11:01:05 <oerjan> (this goes for ^ too)
11:01:36 <litb> hmm
11:01:40 <desegnis> litb: ** is floating-point, and noone wants floating-point if possible ;)
11:01:50 <litb> i see
11:01:54 <Trinithis> what does the forall keyword do?
11:01:59 <skorpan> :t forall
11:02:02 <lambdabot> Not in scope: `forall'
11:02:04 <skorpan> :(
11:02:06 <litb> Trinithis: it means a and b are arbitrary types
11:02:07 <ski_> skorpan : hmm .. det ser vl rtt s strijt-frruard ut
11:02:13 <Trinithis> isnt that implied?
11:02:18 <skorpan> ski_: jopp, borde inte vara verdrivet svrt
11:02:27 <ski_> skorpan : lecture 3, allts
11:02:34 <litb> Trinithis: i don't understand that too :)
11:02:36 <skorpan> jaha
11:02:43 <skorpan> ski_: ltt att sga efter att ha tagit kursen :)
11:03:08 <litb> Trinithis: it is automatically prepended if you don't write it explicitely
11:03:33 <ski_> skorpan : nej men jag kunde redan en del av dom monad-sakerna p den lecturen innan :P ..
11:03:59 <ski_> skorpan : vilken del tyckte du var svrfrsterlig ?
11:04:01 <Trinithis> litb: strange. I wonder if you can take off the forall somehow
11:04:09 <skorpan> ski_: typ allt
11:04:30 <desegnis> Trinithis: the forall keyword is an extension which is not needed in Haskell 98
11:04:37 <Trinithis> o
11:04:39 <ski_> skorpan : men ni har gtt igenom shallow vs. deep innan ?
11:04:57 <desegnis> Trinithis: so it is indeed implied
11:05:01 <skorpan> ski_: i lecture 2 gick vi igenom shallow och deep
11:05:12 <Trinithis> @quote oerjan
11:05:13 <lambdabot> oerjan says: hotsmack
11:05:13 <litb> desegnis: but why is it there?
11:05:26 <litb> @quote litb
11:05:26 <lambdabot> No quotes match. Wrong!  You cheating scum!
11:05:27 * ski_ kan aldrig komma ihg vilken som r vilken av shallow och deep ..
11:05:43 <litb> i read for a moment "You cheating cum"
11:05:44 <skorpan> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/Shape/Shallow.hs.html
11:05:45 <lambdabot> http://tinyurl.com/38axyt
11:05:47 <skorpan> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/Shape/Deep.hs.html
11:05:48 <lambdabot> http://tinyurl.com/2sugof
11:05:49 * oerjan doesn't recall saying just that
11:05:59 <Trinithis> @quote oerjan
11:05:59 <lambdabot> oerjan says: hotsmack
11:06:01 <Trinithis> @quote oerjan
11:06:01 <lambdabot> oerjan says: surprisingly, Cale is not a lambdabot command.  afaik he may even be human.
11:06:04 <ski_> (.. det kan ha ngonting att gra med att frsta gmgen jag gick kursen s lrde lraren ut tvrtom)
11:06:10 <Trinithis> lol
11:06:10 <skorpan> hehe
11:06:12 <litb> lol
11:06:30 <monochrom> @Cale help me with monads!
11:06:30 <lambdabot> Unknown command, try @list
11:06:47 <olsner> heh, undrar om det gamla eller det nya sttet r det som r rtt d
11:06:54 <Trinithis> @Cale make self command
11:06:55 <lambdabot> Unknown command, try @list
11:06:57 <desegnis> litb: apart from looking cute to some, it allows for 1) scoped type variables, 2) rank-2 polymorphism (both ghc extensions)
11:07:18 <ski_> tror Koen sa att han hade missuppfattat/blandat samman det
11:07:20 <litb> meh, i better don't look into it further
11:07:27 <litb> i have better things todo today ^^
11:09:10 <kolmodin> ?tell bringert jag har varit bortrest frra veckan, drav min inaktivitet
11:09:10 <lambdabot> Consider it noted.
11:09:18 <dcoutts> hia kolmodin
11:09:27 * oerjan defers to the logs
11:09:29 <kolmodin> hia dcoutts!
11:09:32 <olsner> men shallow vs deep r allts typ som skillnaden mellan ast+interpretator och funktioner kompilerade av ast:n?
11:10:14 <litb> lol what does that ?tell do?
11:10:21 <ski_> olsner : ja, men problemet r att komma ihg vilken som var vad ;)
11:10:35 <ski_> @help tell
11:10:35 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:10:43 * olsner hatar lustiga frsk att gra komplicerade termer av enkla koncept
11:10:50 <bringert> hm, doesn't seem to work
11:10:50 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:11:04 <litb> ok, i don't want to get it from teh stack =)
11:11:07 <dons> bringert is known as litb??
11:11:21 * dcoutts is confused too
11:11:23 <dons> now i'm confused
11:11:40 <litb> dons: nah he were litb before
11:11:53 <ski_> litb and bringert have been unified !
11:12:03 * dons is more confused
11:12:04 <litb> hehe
11:12:21 <oerjan> does this mean you can steal people's nicks and get their messages?
11:12:34 <litb> lolz, i discovered a security hole
11:12:51 <dons> oh, bringert's not idented?
11:13:04 <vincenz> except that you can't /msg lit
11:13:06 <vincenz> ..litb
11:13:17 <faxathisia> hmm.. you should not use someone elses nick
11:13:22 <dons> yeah, that was really confusing
11:13:23 <oerjan> but i think you can do public @messages
11:13:25 <ski_> olsner : eller, den ena r att definiera en datatyp dr konstruktionerna och operationerna r konstruktorer, medan "run"-funktionerna ("egenskaperna") r interpretatorer
11:13:49 <kuribas> What do people have against floating point?
11:13:51 <oerjan> also, lambdabot tries to accept /msg's from unidentified nicks, doesn't she?
11:13:54 <Trinithis> :t and
11:13:55 <lambdabot> [Bool] -> Bool
11:13:56 <litb> yeah, i'm very sorry about that. i thought it wouldn't fall into that o.O
11:14:11 <Jiten> I've got a list with a polymorphic type, I'm passing it onwards to another function which pattern matches the first element away. Is there a way to prepend an element to the list, even if it's empty?
11:14:14 <bringert> @messages
11:14:14 <lambdabot> kolmodin said 5m 4s ago: jag har varit bortrest frra veckan, drav min inaktivitet
11:14:20 <vincenz> Yeah
11:14:30 <faxathisia> Jiten, cons (:)
11:14:48 <faxathisia> I think? Maybe that's not what you meant?
11:14:57 <ski_> olsner : medan den andra r att definiera en typ-synonym (eller `newtype') dr konstruktionerna har "varsin bit av motsvarande interpretator" i det andra fallet, och "run"-funktionerna r mer eller mindre `id'
11:14:59 <Jiten> faxathisia: the problem is, how do I get an element of the correct type there?
11:15:06 * litb unConfuse $ zip (repeat "person") [1..]
11:15:08 <faxathisia> undefined
11:15:11 <oerjan> kolmodin: you may have to repeat that @tell :/
11:15:26 <ski_> olsner : vet inte om det klargjorde nt ..
11:15:26 <Jiten> ah, I can just throw undefined there.
11:15:27 <faxathisia> > undefined : [1,2,3]
11:15:28 <lambdabot>  Undefined
11:15:31 <kolmodin> oerjan: mo
11:15:33 <kolmodin> err...
11:15:37 <faxathisia> > tail $ undefined : [1,2,3]
11:15:37 <kolmodin> oerjan: how so?
11:15:38 <lambdabot>  [1,2,3]
11:15:44 <kolmodin> oh
11:15:48 <olsner> ski_: ah, jag frstr typ
11:15:55 <Jiten> ok, that works. It's just a bit verbose :/
11:16:04 <faxathisia> __ = __
11:16:11 <dons> dcoutts: expat looks quite good for lazy bytestrings
11:16:13 <dons> "An application that uses Expat must open an XML
11:16:13 <dons> file or stream and read its blocks into memory. The application should pass
11:16:13 <dons> these blocks to Expat, indicating the block size and if it is the last block
11:16:14 <dons> of the document."
11:16:20 <faxathisia> let clog = (__ :)
11:16:32 <litb> > zip (repeat "person") [1..]
11:16:39 <lambdabot>  [("person",1),("person",2),("person",3),("person",4),("person",5),("person",...
11:16:39 <olsner> expat is very nicely minimal too
11:16:43 <dcoutts> dons: what about the api on the other side?
11:17:07 <Trinithis> :t undefined
11:17:08 <lambdabot> forall a. a
11:17:19 <faxathisia> :t let __ = __ in __
11:17:20 <lambdabot> forall t. t
11:17:28 <ski_> olsner : om varje "run-funktion" r en "rad" i en kaka, medan varje konstruktion/operation r en kolumn, s motsvarar de tv olika stten att skra kakan p lngden eller p tvren (*vldigt* ungefrligt)
11:17:40 <Trinithis> undefined : [1..3]
11:17:45 <Trinithis> > undefined : [1..3]
11:17:46 <lambdabot>  Undefined
11:17:57 <Trinithis> > 1:undefined : [1..3]
11:17:58 <lambdabot>  Undefined
11:18:10 <olsner> ski_: jag frstr mindre nu n vad jag gjorde innan du drog upp kakor :P
11:18:14 <faxathisia> > let __ = __ ; clog = (__ :) in tail $ clog [1..3]
11:18:15 <lambdabot>  [1,2,3]
11:18:24 * ski_ undrar varfr han tnkte p kakor .. troligen fr att han r hungrig
11:18:31 <ski_> olsner :)
11:18:41 <wolverian> aagh what is this non-utf8 mess :(
11:18:51 <litb> > lol
11:18:52 <lambdabot>   Not in scope: `lol'
11:19:24 <olsner> heh, #haskell going codepage 850
11:19:25 <litb> oups
11:19:38 <Trinithis> @let lol = "lol"
11:19:42 <lambdabot> Defined.
11:19:44 <litb> better going codepage 101 :)
11:19:59 <kolmodin> ski_: kakor!
11:20:11 <ski_> kaka kaka kaka !
11:20:18 <olsner> (:[]) cookie
11:20:29 <dcoutts> dons: so it calls you back in traditional sax style, and somehow we have to invert the control flow again
11:20:42 <monochrom> There is non-utf8?
11:20:47 <kolmodin> kakmonster!
11:20:47 <oerjan> kolmodin: vincenz tested above whether you could get someone else's messages by stealing their nick, apparently you can, and your message to bringert was the test
11:20:52 <dcoutts> dons: eg by turning it back into a lazy list of tags or something
11:21:09 <dons> yeah hmm
11:21:14 <kolmodin> oerjan: yeah, I noticed... :/
11:21:24 <monochrom> There is non-English spoken here but it's all transmitted in utf-8 alright.
11:21:27 <litb> oerjan: well, don't blame vincenz , please blame me
11:21:44 <oerjan> monochrom: nah, ISO-8859-1
11:22:18 <monochrom>  is in utf-8.
11:22:21 <oerjan> ok
11:22:25 <oerjan> @slap litb
11:22:25 * litb sees that his zip failed hard
11:22:25 * lambdabot secretly deletes litb's source code
11:22:40 <oerjan> monochrom: yes but that's not the encoding used here
11:22:43 <litb> mean!
11:23:02 <litb> well, the characters are displayed correctly here
11:23:53 <dcoutts> dons: it's a push model where you push blocks in and it calls the callbacks, that's the opposite of our standard model
11:24:01 <FunctorSalad> is there a standard name for (flip $) ?
11:24:04 <dons> yeah, call backs aren't so great
11:24:15 <Deewiant> @pl (flip $)
11:24:15 <lambdabot> flip
11:24:16 <dcoutts> dons: it's possible to invert them again, but it's a pain
11:24:33 <monochrom> If you receive one octet 0xe5 that's iso-8859-1. If you receive two octets 0xc3 0xa5 that's utf-8.
11:24:38 <dcoutts> dons: by using continuations and/or unsafeInterleaveIO
11:24:56 <oerjan> FunctorSalad: maybe you mean flip ($) ?
11:25:01 <Deewiant> @pl flip ($)
11:25:01 <lambdabot> flip id
11:25:12 <ski_> @type flip ($)
11:25:13 <lambdabot> forall a b. a -> (a -> b) -> b
11:25:14 <FunctorSalad> oops, yes, (flip ($))
11:25:15 <oerjan> (but no)
11:25:36 * ski_ has called it `(>$)', at times
11:25:43 <FunctorSalad> didn't even expect (flip $) to parse :)
11:26:03 <olsner> :t flip (:[])
11:26:04 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
11:26:04 <lambdabot>     In the first argument of `flip', namely `(: [])'
11:26:09 <oerjan> FunctorSalad: it's a section, just not a very useful one
11:26:18 <Deewiant> :t (:[])
11:26:19 <lambdabot> forall a. a -> [a]
11:26:23 <olsner> can't flip burgers :)
11:26:29 <dcoutts> dons: I said it the other day, but seems to me we want a fast bytestring version of something like tagsoup (but possibly stricter)
11:26:30 <Deewiant> :-D
11:26:30 <ski_> @type ([]:)
11:26:31 <FunctorSalad> oerjan: left to right apllication seems a bit more intuitive :)
11:26:31 <lambdabot> forall a. [[a]] -> [[a]]
11:26:46 <pchiusano_> :t foldl
11:26:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:26:50 <FunctorSalad> oerjan: especially in things like x (flip ($)) f >>> g >>> h
11:27:10 <FunctorSalad> oerjan: oh, misunderstood you
11:27:19 <dcoutts> dons: and that that's the right basis on which to either build a generic dom tree or a custom type
11:27:57 * ski_ thinks `(x :: a) (f :: a -> b)' fits better with the right-pointing function-arrow
11:28:13 <FunctorSalad> yeah
11:28:29 <FunctorSalad> well, it is >>= with the identity monad ;)
11:28:40 <FunctorSalad> > 2 >>= sqrt
11:28:42 <lambdabot>   add an instance declaration for (Floating (m b))
11:29:11 <oerjan> alas identity needs a newtype wrapper
11:29:31 <ski_> (one trouble though, then, is that arguments of curried functions will come in the "wrong" order)
11:29:49 <ski_> (wrt order in the type)
11:30:02 <FunctorSalad> uncurried functions seem to be more readable IMHO when using heavy function composition
11:30:23 <FunctorSalad> if the two arguments play similar roles, at least
11:31:13 <FunctorSalad> but maybe I just did something wrong
11:32:41 <ski_> (but if i'm not mistaken, in ordered logic `x : A , Gamma |- e : B' implying `Gamma |- \x. e : A -> B' is the sensible choice)
11:34:59 <litb> hmm..
11:36:31 <BSP_> hey, can anyone please help me out with type classes? whats the type of a list containing values that certainly have an instance for Show, but which you know nothing about. [forall a. Show a] doesnt seem to work.. :)
11:36:42 <BSP_> is what i'm trying to do possible?
11:37:03 <jedbrown> BSP_: (Show a) => [a]
11:37:13 <mauke> BSP_: not in Haskell98
11:37:47 <BSP_> so theres a flag i can flip to make it work in ghc?
11:37:56 <Jiten> ok, so I made one unfold based split too. Any comments on either one? http://pastebin.com/m606fd6c2
11:38:53 <dolio> Sounds like an existential type.
11:38:57 <FunctorSalad> hmm, "0.99999994" seems less accurate than it should be for the norm of a normed vector. am I missing something?
11:39:22 <ski_> BSP_ : you want `[exists a. Show a *> a]', which must be expressed with an auxiliary datatype as `[SomeShow]'
11:39:41 <FunctorSalad> oh, maybe I should use Double
11:39:43 <ski_>   data SomeShow = forall a. Show a => MkSS a
11:39:44 <ski_> or
11:39:52 <byorgey> dcoutts: where should x- fields be allowed in a .cabal file?
11:40:13 <ski_>   data SomeShow :: *
11:40:16 <ski_>     where
11:40:16 <ski_>     MkSS :: Show a => a -> SomeShow
11:40:55 <ski_> BSP_ : you can try `-fglasgow-exts' to begin with, though that turns on many extensions (there are more specific ones for what you want, yes)
11:41:07 <BSP_> ski: thanks a lot, i'll play with that and see if i can get something going
11:41:24 <ski_> (oh, and as dolio says, this is called an existential type)
11:41:25 <dcoutts> byorgey: good point, anywhere I guess, so that'd imply that we can get them not just in the top level PackageDescription but also in the BuildInfo.
11:41:37 <byorgey> dcoutts: yes, my thinking exactly.
11:41:44 <dcoutts> byorgey: I'd not thought of it before :-)
11:42:08 <oerjan> BSP_: btw for Show it may be simpler to simply put show x values in the list
11:42:31 <BSP_> oerjan: :) indeed, but i'm actually using something else, that was just an accessible example
11:42:37 <oerjan> ok
11:42:41 <litb> flip ($)
11:42:53 <litb> why isn't the type of that "(a -> b) -> a -> b" ?
11:43:08 <oerjan> litb: that's the type of ($) itself
11:43:11 <litb> because the type of ($) is "(a -> b) -> a -> b" i would have thought that
11:43:11 <faxathisia> :t ($)
11:43:12 <lambdabot> forall a b. (a -> b) -> a -> b
11:43:15 <mauke> because that's the type of ($)
11:43:17 <byorgey> dcoutts: just making sure =)
11:43:17 <litb> since its arguments are swapped
11:43:23 <mauke> litb: huh?
11:43:26 <litb> and both of them have the same type
11:43:27 <dcoutts> byorgey: sure
11:43:36 <mauke> if you swap the arguments, you get a -> (a -> b) -> b
11:43:38 <faxathisia> (a -> b) -> (a) -> b, a -> (a -> b) -> b
11:43:45 <oerjan> litb: no, the final -> b is the result, not the argument
11:43:46 <Jiten> shachaf: since it was you who suggested unfold, do you think this can be simplified more? http://pastebin.com/m606fd6c2
11:43:56 <vincenz> > flip ($)
11:43:56 <lambdabot>  Add a type signature
11:43:59 <vincenz> :t flip ($)
11:44:00 <lambdabot> forall a b. a -> (a -> b) -> b
11:44:01 <vincenz> :t flip id
11:44:01 <lambdabot> forall b c. b -> (b -> c) -> c
11:44:16 <litb> oh ah yeah i see it now
11:44:48 <dcoutts> byorgey: I guess the next hackathon is rather a long way away for you :-( shame since we'll be doing a lot of cabal hacking
11:45:10 <byorgey> dcoutts: yeah, it is a shame, I would really like to come.
11:45:23 <byorgey> dcoutts: donations welcome ;)
11:45:31 <vincenz> idem :)
11:45:37 <dcoutts> byorgey: heh heh :-)
11:46:13 <BSP_> ski_: excellent, thanks to your help i got it going! cheers!
11:46:22 <BSP_> how did anyone live before GADTS? :D
11:46:27 <litb> errm, i'm sorry
11:46:30 <dons> dcoutts: oleg did some interesting background, http://okmij.org/ftp/Scheme/SSAX-benchmark-1.html
11:46:32 <lambdabot> Title: SSAX vs. Expat
11:46:39 <litb> how can one pass id to flip ?
11:46:40 <faxathisia> BSP, What did you do with GADTs?
11:46:46 <dcoutts> dons: oh, interesting
11:46:46 <faxathisia> :t id
11:46:47 <lambdabot> forall a. a -> a
11:46:48 * dcoutts reads
11:46:54 <faxathisia> a = b -> c
11:47:05 <dons> including interesting discussions of purity
11:47:09 <litb> i is "a -> a" but i cannot see how it inferences with flips type
11:47:09 <dcoutts> byorgey: we do have a fund for transporting starving hackers, but I dunno if it'd stretch to transatlantic flights :-)
11:47:14 <dons> and why python's expat bindings suck (copying on every call)
11:47:15 <faxathisia> litb, a = b -> c
11:47:29 <faxathisia> :t id :: (b -> c) -> (b -> c)
11:47:31 <byorgey> dcoutts: heh, probably not
11:47:31 <lambdabot> forall b c. (b -> c) -> b -> c
11:47:31 <dcoutts> dons: sounds good, I'm taking a look
11:47:44 <ski_> BSP_ : np
11:47:49 <faxathisia> :t flip (id :: (b -> c) -> (b -> c))
11:47:50 <lambdabot> forall b c. b -> (b -> c) -> c
11:47:54 <faxathisia> :t flip id
11:47:55 <lambdabot> forall b c. b -> (b -> c) -> c
11:48:02 <litb> :t flip
11:48:03 <byorgey> dcoutts: but I just might scrounge around and see if I can find any really cheap flights.
11:48:03 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:48:13 <faxathisia> type inference :D
11:48:18 <byorgey> dcoutts: I imagine that if I could get myself there I could find a place to stay.
11:48:18 <ski_> faxathisia : existentials, afaik
11:48:19 <ehird> why is Maybe a monad but not Either?
11:48:28 <litb> but it starts with "a -> b -> c -> b" how can we pass id with "b -> c" over that?
11:48:32 <dolio> Either is a monad.
11:48:35 <dcoutts> byorgey: we have plenty of local contacts who can give advice on that
11:48:38 <ski_> `Either e' is a monad, for any type `e'
11:48:39 <litb> i'm very confused :/
11:48:47 <faxathisia> litb, id :: a -> a
11:48:50 <mauke> ski_: for any error type e
11:48:52 <ski_> (it's an exception monad)
11:48:59 <faxathisia> litb, flip :: (a -> b -> c) -> ...
11:48:59 <ski_> mauke : yes, that is very sad
11:49:09 <faxathisia> a -> a = a -> b -> c
11:49:14 <ehird> i'm just trying to find out what 'fail' does in Either
11:49:15 <ehird> :)
11:49:16 <byorgey> dcoutts: will there also be a dedicated IRC channel, so I could participate remotely?  it's not at all the same, of course, but better than nothing
11:49:25 <faxathisia> => a = a -> b, a = c
11:49:37 <faxathisia> Do you see how this works?
11:49:40 <mauke> > fail "o hi" :: Either String ()
11:49:40 <ski_> ehird : probably something evil
11:49:41 <lambdabot>  Left "o hi"
11:49:45 <mauke> > fail "o hi" :: Either Int ()
11:49:45 <lambdabot>   add an instance declaration for (Error Int)
11:49:45 <lambdabot>     In the expression: fail "o ...
11:49:50 <faxathisia> It is like unifying the terms
11:49:55 <dcoutts> byorgey: I don't remember if we used #haskell or something else last time
11:50:14 <ski_> (ehird : like calling a function to convert the error string to the errpr type `e' and wrapping with `Left')
11:50:56 <litb> faxathisia: oh i see
11:51:02 <mauke> fake ``quotes
11:51:11 <litb> faxathisia: it does not continue after the ) ?
11:51:18 <litb> but it stays partially matched?
11:51:26 <faxathisia> litb, Sorry which )?
11:51:26 <oerjan> @src Either fail
11:51:27 <lambdabot> fail msg      = Left (strMsg msg)
11:51:34 <oerjan> @src Error
11:51:34 <lambdabot> class Error a where
11:51:34 <lambdabot>     noMsg  :: a
11:51:34 <lambdabot>     strMsg :: String -> a
11:51:35 <litb> :t flip
11:51:36 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:51:43 <litb> that one on c)
11:51:45 <ski_> @index strMsg
11:51:46 <lambdabot> Control.Monad.Error
11:51:53 <faxathisia> litb, Let me set it out clearer, I think what I said was a little confusing
11:51:55 <ski_> @type Control.Monad.Error.strMsg
11:51:56 <lambdabot> forall a. (Error a) => String -> a
11:51:58 <faxathisia> I'll hpaste
11:52:03 <litb> faxathisia: ah wait
11:52:18 <litb> yeah i see now. it *has* to have one type left out since it needs to return something
11:52:35 <BMeph> faxathisia: Wouoldn't iit be more like a -> a = a -> b -> c, thus a = b -> c?
11:53:09 <BMeph> s/Wouoldn't iit/Wouldn't it/
11:53:32 <oerjan> BMeph: you should start by renaming the variables so the types have none in common
11:53:38 <oerjan> although the result is as you say
11:54:03 <litb> BMeph: i don't think
11:54:19 <litb> BMeph: since then a = a and a = b->c
11:54:20 <byorgey> dcoutts: oh, the web page says #haskell-hac4.
11:54:28 <litb> or do i fail totally now?
11:54:29 <dcoutts> byorgey: oh ok :-)
11:54:42 <dcoutts> dons: ooh, they're very unfair on expat by giving it 1 byte input buffers
11:54:57 <oerjan> litb: a = a is not inconsistent with a = b -> c
11:54:58 <MyCatVerbs> @pl mapM_ (uncurry (Data.HashTable.insert table)) (mapMaybe lparse $ lines l)
11:54:58 <lambdabot> mapM_ (uncurry (Data . HashTable . insert table)) (mapMaybe lparse (lines l))
11:54:59 <litb> ah wait, but that's not contrary...
11:55:04 <litb> yeah i see
11:55:23 <MyCatVerbs> @pl \l -> mapM_ (uncurry (insert table)) (mapMaybe lparse $ lines l)
11:55:23 <lambdabot> mapM_ (uncurry (insert table)) . mapMaybe lparse . lines
11:55:45 <BMeph> oerjan: So, x -> x = a -> b -> c, and by currying, x = b -> c (which also makes x = a)?
11:55:49 <hpaste>  faxathisia pasted "flip id" at http://hpaste.org/5292
11:55:56 <oerjan> BMeph: yep
11:56:07 <faxathisia> BMeph, Yeah I slipped up, That's right
11:56:31 <faxathisia> @src flip
11:56:31 <lambdabot> flip f x y = f y x
11:56:48 <faxathisia> ?djinn (a -> b -> c) -> b -> a -> c
11:56:48 <lambdabot> f a b c = a c b
11:56:58 <BMeph> oerjan: Which is why it writes out flip id's type as b -> (b->c) -> c ?
11:56:59 <shachaf> litb: id :: a -> a; a = b -> c; id :: (b -> c) -> b -> c; flip :: (d -> e -> f) -> e -> d -> f; d = b -> c; e = b; f = c; flip :: ((b -> c) -> b -> c) -> b -> (b -> c) -> c
11:57:43 <oerjan> BMeph: possibly, ghc uses the letters from the original type declarations if possible
11:57:55 <oerjan> :t flip
11:57:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:57:59 <oerjan> :t id
11:58:00 <lambdabot> forall a. a -> a
11:58:10 <shachaf> @ty flip ($)
11:58:11 <lambdabot> forall a b. a -> (a -> b) -> b
11:58:13 <shachaf> @ty flip id
11:58:14 <lambdabot> forall b c. b -> (b -> c) -> c
11:58:51 <BMeph> oerjan: Right. It just looks like it's using flip's type letters, since it's dropped type 'a' completely.
11:59:00 <oerjan> yeah
11:59:05 <Tac-Work> @pl \op f -> \x y -> f $ x `op` y
11:59:06 <lambdabot> flip ((.) . (.))
11:59:47 <shachaf> Jiten: I thik that (undefined:) looks a bit ugly.
12:01:29 <dcoutts> dons: so the problem with ssax really is that it is a factor of 7 too slow because it's working over [Char] rather than [ByteString] as expat does.
12:01:43 <Saizan> dcoutts: won't a parser with an interface like an iterator (i.e. lazy list) be easier to wrap rather than one where you register callbacks? (a left fold)
12:02:02 <dcoutts> dons: we could get the nice qualities of the ssax api (lazy etc) with the speed
12:02:19 <dcoutts> Saizan: yes, probably
12:02:50 <MyCatVerbs> @hoogle Eq a => a -> [a] -> ([a],[a])
12:02:51 <lambdabot> No matches, try a more general search
12:03:02 <BMeph> Has anyone here heard of XML Screamer?
12:03:14 * monochrom screams
12:03:16 <shachaf> @ty break
12:03:17 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:03:26 <monochrom> @ty
12:03:26 <shachaf> MyCatVerbs: Is that close enough?
12:03:27 <lambdabot> <command line>:
12:03:27 <lambdabot>     Could not find module `L':
12:03:27 <lambdabot>       Use -v to see a list of the files searched for.
12:03:56 <bauchus> stupid question: what is the name of ocaml's mod_float in haskell?
12:04:07 <Jiten> shachaf: I agree. but I couldn't figure out how else to do it without adding even more unneeded crap.
12:04:12 <mauke> what's mod_float?
12:04:16 <monochrom> > 10.4 `mod` 2.3
12:04:17 <lambdabot>  Add a type signature
12:04:22 <monochrom> > 10.4 `mod` 2.3 :: Double
12:04:23 <lambdabot>   add an instance declaration for (Integral Double)
12:04:23 <lambdabot>     In the expression: 10...
12:04:27 <oerjan> bauchus: iirc that's missing
12:04:30 <monochrom> Ooops, guess none.
12:04:34 <vincenz> > 10.4 `mod` 2.3 :: Rational
12:04:35 <lambdabot>   add an instance declaration for (Integral Rational)
12:04:35 <lambdabot>     In the expression: ...
12:04:41 <bauchus> i see, thanks!
12:04:43 <oerjan> the closest you get is properFraction
12:05:03 <MyCatVerbs> shachaf: certainly, I'm using break now, just wondered if there was something more specific.
12:05:11 <oerjan> bauchus: er that mod doesn't work with floats
12:05:15 <kpreid> @hoogle fmod
12:05:15 <lambdabot> No matches found
12:05:22 <MyCatVerbs> @ty \a l -> break (==a) l
12:05:22 <kpreid> @hoogle mod
12:05:22 <dcoutts> dons: the counter argument to "Is the benchmark fair to Expat?" is only half right. We can work with pipes/sockets with lazy bytestrings using lazy io and get exactly the qualities that are required.
12:05:23 <lambdabot> forall a. (Eq a) => a -> [a] -> ([a], [a])
12:05:23 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
12:05:23 <lambdabot> Data.Fixed.mod' :: Real a => a -> a -> a
12:05:23 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
12:05:34 <kpreid> hum...
12:05:48 <oerjan> kpreid: it's been asked before, it does not exist.
12:05:54 <shachaf> > 10.4 `mod'` 2.3 :: Rational
12:05:55 <lambdabot>  6%5
12:06:00 <oerjan> the closest is properFraction.
12:06:04 <oerjan> :t properFraction
12:06:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
12:06:12 <kpreid> >  10.4 `Data.Fixed.mod'` 2.3
12:06:14 <lambdabot>  1.200000000000001
12:06:19 <monochrom> Someone raised it in haskell-cafe. No satisfactory answer. There is a formula but the asker wanted a faster one.
12:06:22 <oerjan> (gives you mod 1.0)
12:07:10 <litb> shachaf: uhh i hope i will get better with that type inferencing
12:07:13 <kpreid> monochrom: so what's wrong with Data.Fixed.mod' ?
12:07:17 <FunctorSalad> heh "f <$> x" is better than "(return.f) =<< x", isn't it? =)
12:07:32 <monochrom> It is not designed for Double.
12:07:35 <litb> shachaf: now the only problem is how i can see how these pieces of types interact with each other =)
12:07:39 <mauke> `>>= return . is liftM
12:07:51 <shachaf> litb: It makes it look confusing when you type it out.
12:07:54 <monochrom> Err, is it?
12:08:25 <sjanssen> @src liftM
12:08:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:08:41 <dolio> > 10 `Data.Fixed.mod'` pi :: Double
12:08:42 <lambdabot>  0.5752220392306207
12:08:43 <shachaf> litb: It might be simpler if you paid attention to the implcit foralls: id :: forall a. a -> a, so a can also be (b -> c).
12:08:57 <oerjan> eek
12:09:02 <oerjan> @version
12:09:02 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
12:09:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:09:12 <shachaf> litb: But the a,b,c in flip's type are also bound by foralls.
12:09:27 <FunctorSalad> mauke: yes, but "f <$> x" even looks nicer than "(liftM f) x" :)
12:09:30 <monochrom> Hrm, how come it was not brought up in that haskell-cafe thread?
12:10:05 <mauke> FunctorSalad: you just joined two parts of the graph
12:10:11 <litb> shachaf: ah i see
12:10:23 <oerjan> @src mod'
12:10:23 <lambdabot> Source not found. Sorry.
12:10:28 <litb> shachaf: well but i usually do ":t .." in ghci then i see them
12:10:33 <oerjan> mod' n d = n - (fromInteger f) * d where f = div' n d
12:10:36 <sjanssen> heh, we're still playing games with the graph?
12:10:36 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
12:10:53 <oerjan> monochrom: possibly because it's doing it inefficiently?
12:10:55 <shachaf> @karma+ <$>
12:10:55 <lambdabot> <$>'s karma raised to 1.
12:11:14 <ac> so, I have this function "chunk n = map (take n) . takeWhile (not.null) . iterate (drop n)". It would be nice if I didn't have to write another copy for ByteStrings, but I have to, right?
12:11:30 <shachaf> FunctorSalad: Wouldn't "f . x" look even nicer? :-)
12:11:33 <shachaf> (Maybe not.)
12:11:43 <ac> I just prepend "B." to all the list functions
12:12:13 <FunctorSalad> shachaf: yes, but is it uniquely determined whether to lift f or not?
12:12:18 <dolio> How long has Data.Fixed been around?
12:12:42 <shachaf> FunctorSalad: Lift?
12:12:48 <shachaf> FunctorSalad: I meant with (.) = fmap.
12:12:57 <Saizan> mauke: which graph?
12:13:07 <mauke> Saizan: http://files.codersbase.com/haskell/haskell-current.png
12:13:26 <mauke> hmm, disconnected again
12:13:37 <FunctorSalad> shachaf: oh, I thought you meant ghc should figure out whether to fmap f automatically
12:14:13 <litb> oh yeah i like that graph
12:14:47 <Toxaris> FunctorSalad: (.) is a special case of fmap already.
12:15:09 <Toxaris> > (+ 3) `fmap` (* 2) $ 4
12:15:10 <lambdabot>  11
12:15:11 <litb> olsner: join!
12:15:24 <litb> :)
12:15:30 <mauke> wow
12:15:56 <mauke> it's much tidier now
12:16:08 <shachaf> That graph measures how much people talk to each other?
12:16:13 <ac> there should be a list type class. Then I wouldn't have to have two copies of a function that operates on ByteStrings and regular lists
12:16:14 <litb> be belong together (tm)
12:16:31 <sjanssen> @keal
12:16:31 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
12:16:44 <FunctorSalad> hmm ($) and `fmap` are the same apparently ;)
12:16:50 <FunctorSalad> err <$>
12:16:56 <byorgey> that graph is just using data from today, I presume?
12:16:57 <shachaf> It should mark lines starting with '@' as lambdabot:.
12:17:06 <byorgey> FunctorSalad: yes =)
12:17:08 <mauke> byorgey: it's updated in real time
12:17:15 <byorgey> mauke: oh, cool =)
12:17:18 <shachaf> @src (<$>)
12:17:18 <lambdabot> f <$> a = fmap f a
12:17:46 <litb> what time-out does it have on one edge?
12:17:49 <ac> mauke: In real time? There now should be an edge between you and me then
12:17:58 <litb> is it logarithmic on the thickness on it?
12:17:58 <ac> cool. there is
12:18:05 <olsner> litb: join what? where?
12:18:15 <FunctorSalad> I defined this thing "f <<$>> a = fmap (fmap f) a" - would it be possible to automatically do arbitrary many fmaps? ;) (well, I don't think it is uniquely determined, is it?)
12:18:21 <shachaf> lambdabot: @vixen We are connected now.
12:18:21 <lambdabot> now now now...so demanding
12:18:22 <litb> olsner: on the picture
12:18:39 <RayNbow> http://www.parleys.com/display/PARLEYS/An+update+on+Java+Closures (1 hour and 17 minutes)
12:18:40 <lambdabot> Title: An update on Java Closures - Parleys - Parleys.com - a Belgian Java User Group i ...
12:18:47 <monochrom> I like to talk to myself. Under an irrelevant definition anyway.
12:18:55 <litb> olsner: i won't let you fall down mate :)
12:19:11 <cjb> hm, someone on Reddit says there was an ICFP 07 paper about using profiling to work out when to annotate for parallelism (in Haskell, presumably?).  Anyone able to help track it down?
12:19:34 * byorgey wonders how it does graph layout
12:19:34 <dcoutts> cjb: yes there was, see the icfp 07 website
12:19:34 <ac> there must be a good reason why there isn't a list class
12:19:44 <litb> ah, i've teh idea. can one use parallelism on a list that is being sum'ed?
12:19:44 <Saizan> FunctorSalad: you can write deepFmap
12:19:49 <cjb> dcoutts: am looking at it now, not seeing any links to paper collections though.
12:20:00 * byorgey could fly to Gothenburg for USD $766
12:20:06 <dcoutts> cjb: google for the paper name
12:20:17 <cjb> I don't know the paper name :)
12:20:32 <Saizan> FunctorSalad: http://okmij.org/ftp/Haskell/deepest-functor.lhs
12:20:33 <dcoutts> cjb: yes, but the icfp 07 has the list of paper names
12:20:49 <FunctorSalad> Saizan: wouldn't we need some theorem like "for every types a and c, there is at most one sequence of functors such that c = f1 f2 f3 .... fn a"?
12:21:33 <mauke> Feedback Directed Implicit Parallelism
12:21:44 <shachaf> cjb: "Feedback directed implicit parallelism"
12:21:48 <shachaf> Oh. :-(
12:21:51 <Saizan> FunctorSalad: the type of the fmapped function fixes some things i'd say
12:21:53 <mauke> Timothy Harris, Satnam Singh
12:21:53 <cjb> just found it :)
12:21:55 <cjb> thanks all!
12:21:56 <olsner> ac: just playing with the social network thingy - you're almost on the opposite side of the graph from me
12:22:22 <olsner> not anymore, heh ;-)
12:22:35 <ac> it's no longer a planar graph
12:22:51 <oerjan> dons: come a little closer on the graph
12:22:59 <shachaf> Cale: You talk to a lot of people, don't you>
12:23:03 <shachaf> s/.$/?/
12:23:04 <litb> how do you know, ac ?
12:23:16 <sjanssen> we're gonna kill lispy's bandwidth :)
12:23:25 <monochrom> ac has done a planarity test.
12:23:36 <shachaf> dons: Vegetarian network!
12:24:04 <mauke> I'm trapped
12:24:07 <sjanssen> have we realized by goal of a complete graph yet?
12:24:12 <hpaste>  jedbrown pasted "General Trie" at http://hpaste.org/5293
12:24:15 <ac> litb: it's just my best guess. I've played gplanarity enough to have an idea of when a graph is planar or not
12:24:15 <jedbrown> dcoutts: I got back to thinking about general tries and made up this sketch.  Do you think there is any value in this approach, or should we settle for one TMap?
12:24:23 <olsner> sjanssen: working on it ;-)
12:24:28 <monochrom> If there is a K3-3 minor or K5 minor, the graph is non-planar. This search takes only polynomial time.
12:24:40 <litb> ac: =) is that a game where you have to say planar or not?
12:24:44 <oerjan> sjanssen: getting close
12:24:47 <litb> how nerdy, i must have that game
12:25:10 <ac> litb: you rearange a planar graph until there're no crosses between edges. There's a flash version online somewhere
12:25:19 <sjanssen> jedbrown: have you looked at associated types yet?  That would make this code look very nice
12:25:25 <ac> the version I played eventually progressed to non planor graphs, and you just had to minimize the edge crossings
12:25:40 <jedbrown> sjanssen: I don't know about them.
12:25:49 <sjanssen> jedbrown: the implementation in GHC is still a bit buggy, however
12:25:56 <olsner> seems I'm the swedish connection
12:26:01 <sjanssen> @google generalized tree type family
12:26:03 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S1571065306000813
12:26:03 <lambdabot> Title: ScienceDirect - Electronic Notes in Discrete Mathematics : Generalized clique fa ...
12:26:14 <sjanssen> @google generalized tree associated type
12:26:15 <lambdabot> http://www.lisp.org/HyperSpec/Body/glo_t.html
12:26:15 <lambdabot> Title: CLHS: Glossary-Section T
12:26:19 <monochrom> I know people who patiently planarize graphs with 100 nodes.
12:26:19 <ac> litb: there's a debian package called gplanarity, or you can just google "planarity" for the flash version
12:26:29 <litb> yeah, i do thx
12:26:34 <ac> monochrom: it's not that hard
12:26:40 * monochrom prefers minesweeper
12:26:53 <FunctorSalad> well the flash version I played got monotone after a while
12:27:06 <ac> yeah
12:27:16 <FunctorSalad> I think it only generated pretty simple (in some sense) graphs. you could always do the same thing
12:27:20 <slbkbs> shachaf: We should have the strongest link.
12:27:28 <shachaf> slbkbs: I agree.
12:27:34 <BMeph> jedbrown: I'd buy it for a dollar. ;)
12:28:16 <jedbrown> BMeph: that would ruin my amateur status ;)
12:28:17 <BMeph> olsner: So, if you're the Swedish connection, does that make vincenz... the French Connection? ;)
12:28:31 <BMeph> jedbrown: :)
12:28:35 <sjanssen> @haskellwiki GHC/Type_families
12:28:35 <lambdabot> Unknown command, try @list
12:28:40 <sjanssen> @wiki GHC/Type_families
12:28:40 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
12:28:44 <sjanssen> jedbrown: see section 4
12:28:58 <joglala> I have some haskell homework and are not sure if i did it right
12:29:00 <shachaf> Does it count if the nick is anywhere in the message, (if I say slbkbs here, for example)?
12:29:02 <byorgey> monochrom: let's totally change the graph layout by connecting opposite sides!
12:29:13 <byorgey> muahaha
12:29:19 <monochrom> I refuse to talk to an individual.
12:29:27 <joglala> Its about the evaluation strategy of haskell
12:29:28 <olsner> BMeph: he isn't even in the graph, so I doubt that counts ;-) I'm more refering to the whole subgraph starting with ski that is totally disconnected from the rest of the graph except through me
12:29:31 <slbkbs> shachaf: Perhaps this graph would've been better in #-blah...
12:29:44 <davidL> Is there a big difference in efficiency between the Seq in Data.Sequence and the Seq in Data.Edison?
12:30:22 <byorgey> joglala: ok, what's the exercise?
12:30:37 <BMeph> olsner: Yes, I know. It's a joke based on the 70's book/movie, "The French Connection". ;)
12:30:44 <jedbrown> sjanssen: Oh, that does look cool.
12:30:57 <joglala> One moment
12:31:01 <olsner> BMeph: hmm... that's before my time :P
12:31:36 <ac> so why is there no list type class?
12:32:19 <gbacon> anyone successfully running SearchPath on cygwin?
12:32:23 <joglala> http://jogla.net/EvaluationStrategy1.jpg
12:32:26 <byorgey> ac: I think such a thing does exist in a library somewhere.  but it's a fair question.
12:32:27 <joglala> Thats my solution
12:32:29 <BMeph> ac: I think part of the reason why there isn't a list class, is because most of Bytestring's functionality comes from its particular implementation, although that might be a fun project making Bytestrings work with other types .
12:32:30 <smack_> ac: foldable, maybe?
12:32:32 <oerjan> monochrom: we are all individuals!
12:32:41 <joglala> Im especially not sure about b)
12:32:43 <mauke> class List a c | c -> a where unlist :: c -> b -> (a -> c -> b) -> b
12:33:08 <joglala> I thought maybe 4*4 must be evaluated much earlyer
12:33:21 <joglala> earlier
12:33:22 <FunctorSalad> Saizan: thanks for that deep fmap thing :) couldn't parse it yet though
12:33:28 <ac> BMeph: Ah that makes sense. Things like !! need to have separate implementations
12:33:34 <BMeph> olsner: That's okay, I think Swedish is just as much beyond my time. Love the people and the culture; totally boggled by the language. ;)
12:33:43 <jedbrown> BMeph, ac: sjanssen did that for Storable. It's called StorableVector
12:33:52 <ac> from the users perspective it makes perfect sense for there to be a list class, but not from the compiler's perspective
12:33:53 <joglala> http://verify.rwth-aachen.de/programmierungWS07/uebungen/blaetter/Uebung11.pdf
12:33:55 <lambdabot> http://tinyurl.com/ytbm7d
12:34:05 <joglala> Thats the exercise, but i think its not needed
12:34:27 <byorgey> joglala: that looks good to me.  4*4 definitely does not get evaluated earlier than that.
12:34:31 <Saizan> FunctorSalad: i suggest the HList paper if you like oleg's type hackery :)
12:34:35 <joglala> :)
12:34:42 <olsner> BMeph: bah, english is the new swedish :P
12:34:52 <byorgey> joglala: although you seem to be missing some parentheses, some of what you wrote would not parse correctly.
12:35:12 <byorgey> joglala: for example, take 2 (squares 4) instead of take 2 squares 4
12:35:16 <shachaf> Cale: Why are you still not connected to me?
12:35:16 <davidL> also, take 1 == head :)
12:35:19 <jedbrown> ac: Isn't the user's perspective what matters.  The compiler's job is to resolve the types.
12:35:29 <BMeph> Saizan: Even when it goes off into the scary unknown, who Doesn't like Oleg's typw hackery? ;)
12:35:31 <slbkbs> shachaf: Maybe you have to talk to each other.
12:35:37 <oerjan> shachaf: he keeps slipping out
12:35:37 <kaol> > (head [], take 1 [])
12:35:38 <byorgey> davidL: that's not the point, it's the definition of take
12:35:40 <lambdabot>  Exception: Prelude.head: empty list
12:36:04 <davidL> byorgey: oh, I'm not really sure what the exercise is
12:36:06 <ac> jedbrown: yeah, that's why I was saying my chunk function should just work for ByteStrings. All the functions it uses are defined in the ByteString module
12:36:07 <joglala> Ohh, i added some parentheses
12:36:13 <bauchus> i have another question: how can i convert from Double to Float?
12:36:27 <mauke> :t fromRational . toRational
12:36:28 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
12:36:37 <shachaf> slbkbs: Pretty soon we'll be connected like dcoutts and byorgey. :-)
12:37:05 <jedbrown> ac: I suspect the lack of a list type class is mostly historical.
12:37:11 <joglala> byorgey: But 4*4 : take 1 (squares3) for example does not need further paranthensis?
12:37:23 <oerjan> bauchus: realToFrac
12:37:26 <byorgey> joglala: yup, that looks ok
12:37:30 <oerjan> :t realToFrac
12:37:30 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:37:31 <joglala> Thank you :)
12:37:52 <byorgey> joglala: the important thing to remember is that function application has higher precedence than anything else.
12:37:56 <ac> BMeph: the problem of having very different underlying implementations could be solved by just adding more methods to the list class
12:38:24 <ac> BMeph: even though you could define most of them in terms of others, you don't have to do that
12:38:29 <joglala> :)
12:39:00 <jedbrown> ac: Since the different implementations have very different complexity, general algorithms would implicitly be optimizing for some implementation.
12:39:01 <cjb> Is it normal to publish code alongside results in FP papers?
12:39:16 <joglala> Does take 1 3*3:sqares(2) need further paranthesis?
12:39:18 <litb> ac: what level have you reached so far?
12:39:23 <vincenz> @join oasis
12:39:27 <vincenz> @join #oasis
12:39:28 <cjb> e.g. with this FDIP paper, they've clearly heavily modified GHC.  Might a patch be available, or is publishing code not seen as a requirement for publishing a paper?
12:39:43 <jedbrown> ac: Like cons is expensive for ByteString, but not for lists.
12:39:43 <ac> litb: I played it a while ago, but I got up to 10 or 15 I think
12:39:45 <byorgey> shachaf: heh, yeah, that's when dcoutts and I were discussing some Cabal hacking earlier. =)
12:39:45 <FunctorSalad> I'm not an expert on this, but why use cons lists over ArrayLists anyway? you get occasional (rare) resizing but there are less operations that take O(n) time
12:40:01 <ac> jedbrown: ah interesting point
12:40:11 <oerjan> joglala: everything after 1 needs a parenthesis or $
12:40:18 <bauchus> oerjan: thanks
12:40:19 <dolio> (take 1 3) * (3) : (sqares(2))
12:40:32 <mauke> take 1 (3 * 3 : squares 2)
12:40:35 <oerjan> dolio: what the?
12:40:39 <sjanssen> FunctorSalad: cons lists are lazy
12:40:41 <BMeph> ac: Which would give more incentive to having types automatically come up with their class-defining methods.
12:40:50 <davidL> = 9
12:40:56 <dolio> That's how the original will parse.
12:41:04 <oerjan> oh noes, the graph crashed
12:41:12 <joglala> And even in this case functions have the highest priority? So haskell would do "take 1 3"?
12:41:41 <ac> jedbrown: but weren't you just saying it's the compilers job to deal with all that?
12:42:07 <ac> jedbrown: the compiler could take in to account the different instances while optimizing
12:42:09 <byorgey> joglala: yes, take 1 3*3 : squares 2   would be parsed as (take 1 3) * 3 : squares 2  which would give a type error.
12:42:41 <jedbrown> ac: Well, to sort out the concrete types, but it isn't going to do deep changes to the algorithm.
12:43:11 <joglala> And do i have to write (3*3):take, or is 3*3:take enought?
12:43:23 <shachaf> > 3 * 3 : []
12:43:24 <lambdabot>  [9]
12:43:26 <Toxaris> FunctorSalad: even in strict languages, linked lists have their place and arrays are not always to way to go. in lazy languages, everything is different, anyway. a lazy list can be seen as a loop, a lazy array as a memoization table, and so on.
12:43:28 <jedbrown> ac: And laziness complicates it further since an algorithm which relies on laziness will not be able to use a stricter list implementation.
12:43:55 <shachaf> joglala: : is infixr 5, * is infixl 7.
12:44:15 <byorgey> joglala: looks like * has higher precedence than :, so 3*3 : foo  is ok.  although parentheses for clarity don't hurt, even if they're not strictly necessary.
12:44:25 <nominolo> :t (&)
12:44:26 <lambdabot> Not in scope: `&'
12:44:30 <joglala> Ahh, thank you
12:44:57 <FunctorSalad> I see
12:45:23 <faxathisia> How does haskell type flip id actually?
12:45:33 <shachaf> faxathisia: Like flip ($).
12:45:43 <nominolo> :t flip id
12:45:44 <lambdabot> forall b c. b -> (b -> c) -> c
12:46:06 <ac> I don't understand how you can flip a one argument function
12:46:13 <shachaf> ac: a = b -> c
12:46:22 <faxathisia> I mean.. what exact process does it go through to derive that type?
12:46:24 <shachaf> ac: So id :: (b -> c) -> b -> c
12:46:30 <BMeph> ac: Because id is not your average one-argument function. ;)
12:46:48 <nominolo> faxathisia: just try it for yourself with the source
12:46:52 <faxathisia> It's quite clear intuitively.. but I wrote a typechecker and it can't do flip id
12:46:53 <nominolo> @src flip
12:46:53 <lambdabot> flip f x y = f y x
12:47:05 <shachaf> Cale: Disconnected again? Come back!
12:47:06 <nominolo> faxathisia: oh, heh
12:47:06 <ac> shachaf: ah I get it ;)
12:47:15 <faxathisia> I don't really see how I could type the y combinator but not flip id..
12:47:26 <faxathisia> flip id seems infact, more simple
12:47:42 <shachaf> faxathisia: The Y combinator? Defined how?
12:47:50 * BMeph tosses a sticky lambda at shapr
12:47:53 <ac> I thought the Y combinator was untypeable
12:48:01 <shachaf> @ty fix
12:48:03 <lambdabot> forall a. (a -> a) -> a
12:48:12 <ac> @seen shapr
12:48:13 <lambdabot> I saw shapr leaving #ghc and #haskell 1h 3m 43s ago, and .
12:48:27 <faxathisia> y f = f (y f)
12:48:34 <nominolo> ac: in pure LC, it is
12:48:39 <faxathisia> It types because you have an equation
12:48:40 <shachaf> Oh, defined recursively.
12:48:43 <nominolo> ac: but haskell has recursive let
12:48:52 <Jiten> why does ghc gives me "test.hs:15:7: Empty 'do' construct" for this http://pastebin.com/d11732301
12:48:52 <faxathisia> So that's why wrote this :p
12:48:55 * BMeph watches his tossed sticky lambda go sailing off into Deepest Cyberspace...
12:49:00 <faxathisia> but now I'm confused
12:49:00 <slbkbs> slbkbs: I'd better quit; this is probably getting annoying.
12:49:30 <faxathisia> (to understand it)
12:49:41 <mauke> Jiten: look at the colors
12:49:41 <nominolo> Jiten: data is a reserved word
12:50:06 <Jiten> right ... quite baffling error message.
12:50:38 <Jiten> I guess I should consider switching to editor that can do syntax highlighting for haskell.
12:50:47 <shachaf> Jiten: Like vim!
12:50:48 <faxathisia> I thought that in haskell, It just basically uses the two rules: (\x -> s) :: a -> b  => {x :: a, s :: b}, (u v) :: b => {u :: a -> b, v :: a}
12:50:49 <BMeph> faxathasia: Does your type checker type Y correctly, or was that just an example you were using.
12:50:58 <oerjan> Jiten: it's due to the parse-error rule for ending blocks
12:51:21 <faxathisia> BMeph, It does, It's confusing that it could do Y but not flip id
12:51:27 <litb> wow gplanarity rocks
12:51:51 <faxathisia> so I thought you just take those rules and unify types until you're done
12:51:53 <oerjan> whenever there is a parse error it tries closing the blocks before proceeding.  so it closes the do before rechecking, and gives an error message for the do instead of the data
12:52:00 <faxathisia> but.. it seems there is something more to it
12:52:25 <ac> erg, why doesn't thisk type check: bchunk n = B.map (B.take n) . B.takeWhile (not.null) . iterate (B.drop n)
12:52:48 <BMeph> faxathasia: It looks like you need a rule to do currying, or to account for it somehow.
12:53:01 <byorgey> ac: should that be B.null ?
12:53:02 <ac> "can't match Word8 to ByteString"
12:53:06 <ac> ah doh
12:53:18 <dolio> @type iterate
12:53:19 <lambdabot> forall a. (a -> a) -> a -> [a]
12:53:40 <faxathisia> :t ((\f -> (\x -> (\y -> ((f y) x)))) (\o -> o))
12:53:41 <lambdabot> forall t t1. t -> (t -> t1) -> t1
12:54:14 <dcoutts_> jedbrown: hi, just looking at that trie hpaste...
12:54:14 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:15 <faxathisia> so, I define all lambdas as 1 arg
12:54:29 <ac> I need a pack in there too
12:54:29 <jedbrown> dcoutts_: What do you think?
12:54:52 <Saizan> faxathisia: you've to forall variables on let, and take in account kinds and typeclasses
12:54:58 <dcoutts_> jedbrown: just waiting for it to load...
12:55:38 <faxathisia> Saizan, Just for flip id though, I thought only those two rules mattered?
12:55:50 <BMeph> Hmm, the whole "all functions are one argument" idea makes flip into a wildly powerful  function.
12:56:31 <olsner> @t flip flip
12:56:31 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:56:37 <olsner> @ty flip flip
12:56:38 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:56:59 <faxathisia> I'm stuck
12:57:37 <dcoutts_> jedbrown: that looks pretty sensible, though you may need to specialise a bit to get good performance
12:57:43 <jedbrown> dcoutts_: So my idea was that we could specialize to the strict 4-bucket case by making a new instance of TMap.
12:57:53 <dcoutts_> jedbrown: right
12:58:05 <jedbrown> dcoutts_: As in RULES ?
12:58:39 <dcoutts_> jedbrown: probably just INLINE and SPECIALISE, but check the core before using hammers like that
12:59:24 <dcoutts_> jedbrown: just something to be aware of when you're concerned with performance and you're using highly parametrised code
12:59:36 <jedbrown> dcoutts_: Is SPECIALISE depracated?  I have seen conflicting information.
12:59:49 <dcoutts_> jedbrown: don't think so
13:00:06 <jedbrown> dcoutts_: Yes, of course.
13:02:47 <unenough> is there a reason why lambdabot won't answer mathematica questions?
13:02:53 <jedbrown> dcoutts_: I'm curious if one of the choices is generally better.  It would be fun to benchmark.
13:03:08 <jedbrown> unenough: Um, because it's not a mathematica bot.
13:03:12 <phlpp> :t flip
13:03:13 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:03:25 <phlpp> :t (flip.flip) map
13:03:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:03:34 <unenough> jedbrown, well it works normally, if I do % something, it answers
13:03:43 <dcoutts_> jedbrown: do you need the 'b' parameter to the type class?
13:03:44 <EvilTerran> are you quite sure?
13:03:48 <shachaf> unenough: Are you thinking of mbot?
13:04:04 <unenough> shachaf, no, lambdabot also respects that
13:04:13 <shachaf> % 1
13:04:14 <dcoutts_> jedbrown: aren't all the instances polymorphic in b?
13:04:14 <EvilTerran> % 1 + 2
13:04:21 <shachaf> unenough: Not that I know of.
13:04:21 <unenough> only NOW it doesn't
13:04:22 <EvilTerran> unenough, no it doesn't. sorry.
13:04:22 <jedbrown> unenough: That would be Cale's mbot.  It sometimes comes here when lambdabot is away.
13:04:24 <dcoutts_> jedbrown: indeed isn't that essential?
13:04:24 <phlpp> :t (%)
13:04:25 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:04:31 <shachaf> unenough: It never did, I'm pretty sure.
13:04:31 <phlpp> > 5 % 3
13:04:33 <lambdabot>  5%3
13:04:33 <jedbrown> dcoutts_: Yes.
13:04:36 <phlpp> > 5` %` 3
13:04:36 <lambdabot>  Parse error at "%`" (column 4)
13:04:37 <EvilTerran> unenough, it's not done it once since i've been here
13:04:39 <shachaf> Cale?
13:04:47 <phlpp> > 8 % 4
13:04:47 <EvilTerran> being over a year
13:04:48 <lambdabot>  2%1
13:04:54 <phlpp> ah, ok
13:04:55 <unenough> well, maybe i'm dreaming but i've tried it and it worked
13:05:01 <shachaf> unenough: Did you see that in #math, perhaps?
13:05:14 <unenough> no i tried it myself
13:05:25 <unenough> maybe lambdabot redirects stuff to mbot...
13:05:37 <shachaf> unenough: You're sure you're not thinking of mbot? mbot is a modified lambdabot.
13:05:47 <faxathisia> Does anyone have an STLC type checker which can type flip id?
13:05:55 <unenough> shachaf, i know, but i seem to have imagined that also lambdabot did it
13:05:56 <mauke> > 8 / 4 :: Rational
13:05:57 <lambdabot>  2%1
13:06:02 <faxathisia> sythesze the type for*
13:06:11 <phlpp> @src Rational
13:06:11 <lambdabot> type Rational = Ratio Integer
13:06:52 <phlpp> hmm, is it possible to take the divisor/numerator out of an rational?
13:07:12 <Valodim> "take out"?
13:07:15 <faxathisia> denominator
13:07:16 <phlpp> get
13:07:17 <phlpp> ;)
13:07:18 <phlpp> sorry
13:07:19 <faxathisia> numerator
13:07:19 <mauke> > numerator (8 / 4)
13:07:20 <lambdabot>  2
13:07:21 <joglala> Can you tell me what \x means instead of x+
13:07:23 <joglala> *x?
13:07:31 <phlpp> faxathisia: ah ok
13:07:36 <jedbrown> dcoutts_: Would it be possible to unbox that field for some types, via RULE?
13:07:46 <phlpp> > denominator (8 / 4)
13:07:47 <lambdabot>  1
13:07:50 <shachaf> joglala: It's a function that gets an x.
13:07:53 <dcoutts_> jedbrown: sadly not
13:08:05 <EvilTerran> ?hoogle Ratio a -> (a,a)
13:08:05 <lambdabot> No matches, try a more general search
13:08:11 <dcoutts_> jedbrown: hmm, actually not sure
13:08:11 <shachaf> joglala: (\ looks like the letter lambda, .)
13:08:37 <joglala> Does that mean i can write x instead of \x at any time/
13:08:42 <phlpp> > filter ((==) 1  denominator) [1..10]
13:08:43 <lambdabot>  Couldn't match expected type `a -> Bool'
13:08:55 <phlpp> ah, what the heck.. hit return a bit too early
13:09:01 <mauke> > (\x -> x * 2) 21
13:09:02 <lambdabot>  42
13:09:05 <shachaf> > filter ((== 1) . denominator) [1..10]
13:09:06 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1]
13:09:06 <jethr0> anyone have any experience with ForeignPtrs?
13:09:26 <EvilTerran> @quote pcrs
13:09:26 <lambdabot> pcrs says: Premature carriage ret
13:09:37 <jedbrown> dcoutts_: If it's not possible now, it would be a cool feature.  I suspect it would be useful in other cases as well.
13:09:39 <faxathisia> :t gcd
13:09:40 <lambdabot> forall a. (Integral a) => a -> a -> a
13:09:43 <shachaf> joglala: No, they're quite different.
13:10:04 <dcoutts_> jedbrown: oh certainly, I've often wanted it
13:10:09 <EvilTerran> joglala, have you read any haskell tutorials?
13:10:13 <ac> @pl \b -> concatMap foo . bar b
13:10:13 <lambdabot> ((foo =<<) .) . bar
13:10:32 <joglala> I have lectures, but there a very bad
13:10:40 <shachaf> joglala: Saying "f x = x + 1" is the same as saying "f = \x -> x + 1".
13:10:56 <joglala> I tried to find this \ in some tutorials but did not know where to look for it
13:10:59 <jedbrown> dcoutts_: highly polymorphic, general code that optimises well = nirvana :)
13:11:00 <ac> for some reason I'm tempted to paste that in to my code, but I will resist the temptation
13:11:04 <joglala> Thank you
13:11:29 <faxathisia> > filter (\r -> numerator r `gcd` denominator r == 1) $ concatMap (\n -> map (\i -> i/n-i) [0..n]) [0..]
13:11:31 <lambdabot>  Exception: Ratio.%: zero denominator
13:11:42 <faxathisia> > filter (\r -> numerator r `gcd` denominator r == 1) $ concatMap (\n -> map (\i -> i/n-i) [1..n-1]) [1..]
13:11:43 <jedbrown> jethr0: What's your question?
13:11:43 <lambdabot>  [(-1)%2,(-2)%3,(-4)%3,(-3)%4,(-3)%2,(-9)%4,(-4)%5,(-8)%5,(-12)%5,(-16)%5,(-5...
13:11:55 <faxathisia> > filter (\r -> numerator r `gcd` denominator r == 1) $ concatMap (\n -> map (\i -> i/(n-i)) [1..n-1]) [1..]
13:11:57 <lambdabot>  [1%1,1%2,2%1,1%3,1%1,3%1,1%4,2%3,3%2,4%1,1%5,1%2,1%1,2%1,5%1,1%6,2%5,3%4,4%3...
13:12:07 <jethr0> jedbrown: i'm trying to work with foreignptrs for an image library binding i'm writing
13:12:13 <oerjan> faxathisia: gcd is always 1, the % simplifies
13:12:20 <phlpp> > P=NP
13:12:20 <lambdabot>  Parse error at "=NP" (column 2)
13:12:25 <faxathisia> > concatMap (\n -> map (\i -> i/(n-i)) [1..n-1]) [1..]
13:12:26 <hpaste>  dcoutts annotated "General Trie" with "TMap instance for DNA" at http://hpaste.org/5293#a1
13:12:27 <lambdabot>  [1.0,0.5,2.0,0.3333333333333333,1.0,3.0,0.25,0.6666666666666666,1.5,4.0,0.2,...
13:12:27 <phlpp> buuuhu
13:12:29 <jethr0> jedbrown: and ghc tells me that i need to use -fvia-C to get a function pointer from FFI
13:12:36 <jethr0> have you worked with foreignptrs before
13:12:56 <dcoutts_> jedbrown: I pasted one representation for a specialised dna trie node mapping
13:13:31 <wagle> > P==NP
13:13:31 <dcoutts_> jedbrown: not type checked :-) oops and I left the class defn in
13:13:31 <lambdabot>   Not in scope: data constructor `NP'
13:13:45 <jedbrown> jethr0: Yes, a bit.  It sounds like you're not using cabal.  Cabal will save you a lot of time and you won't have to worry about compiler flags.
13:13:51 <oerjan> > (numerator &&& denominator) (4 % 12)
13:13:52 <lambdabot>  (1,3)
13:14:01 <oerjan> > 4 % 12
13:14:02 <lambdabot>  1%3
13:14:15 <phlpp> > (\n -> (1 + 1/n)^n) 500
13:14:16 <lambdabot>  Add a type signature
13:14:32 <jethr0> hmm, yes i want to use cabal. is there some good documentation about how to set up a cabal project?
13:14:34 <jedbrown> dcoutts_: Cool.  We should try it at some point.
13:14:49 <jedbrown> jethr0: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
13:14:50 <lambdabot> Title: How to write a Haskell program - HaskellWiki
13:15:06 <oerjan> > (\n -> (1 + 1/fromIntegral n)^n) 500
13:15:07 <lambdabot>  2.715568520651698
13:15:11 <jethr0> jedbrown: the reason i'm asking is that i'm using ghci quite heavily in development and foreignptrs don't seem to work in ghci
13:15:15 <shachaf> > sum [1 / product [1..k] | k <- [0..500]]
13:15:16 <lambdabot>  2.7182818284590455
13:15:22 <phlpp> cheat!
13:15:23 <phlpp> ;)
13:15:35 <dcoutts_> jedbrown: it generalises to other small dense key spaces, using an array
13:15:37 <jedbrown> jethr0: mkcabal is a nice utility for getting a fresh repository up to speed.  pcre-light is a nice simple FFI code to look at as an example
13:16:00 <jethr0> yes, i've had a look at pcre-light.
13:16:33 <jedbrown> dcoutts_: Of course.  Judy Tries are a super complicated base-256 version.
13:16:59 <jedbrown> dcoutts_: Optimized for cache and what-not, but their performance is questionable for lots of data because the nodes are so big.
13:17:14 <dcoutts_> jedbrown: right, 256 is fairly large
13:17:26 <dcoutts_> jedbrown: if the key space is sparse
13:17:53 <phlpp> @pl flip.flip
13:17:53 <lambdabot> id
13:17:57 <phlpp> hehe
13:18:11 <shachaf> @pl \x -> x x
13:18:12 <lambdabot> join id
13:18:12 <dcoutts_> jedbrown: though I see the attraction, it's 32bytes which is half a cache line
13:18:13 <faxathisia> > (flip.flip) 3
13:18:14 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
13:18:28 <dcoutts_> erm, what am I talking about
13:18:31 <phlpp> :t (\x -> x x)
13:18:32 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:18:32 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:18:32 <lambdabot>     In the expression: x x
13:18:32 <faxathisia> I am so confused now :P
13:18:42 <jedbrown> dcoutts_: What's 32 bytes?
13:18:54 <dcoutts_> jedbrown: sorry, 32 words which is 8 cache lines
13:19:17 <oerjan> :t flip.flip
13:19:18 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
13:19:44 <BMeph> :t flip (flip 3)
13:19:45 <lambdabot> forall b a c. (Num (b -> a -> c)) => b -> a -> c
13:19:50 <jedbrown> dcoutts_: have you seen this: http://www.pvk.ca/Blog/Lisp/sparse_array.html
13:19:50 <lambdabot> Title: Paul Khuong mostly on Lisp
13:19:51 <oerjan> faxathisia: @pl doesn't distinguish between id, ($), and further type restrictions
13:19:55 <dcoutts_> jedbrown: an alternative for sparse nodes is a 256 bitmap which is 32bytes, and using that to index a variable size array.
13:19:59 <jedbrown> dcoutts_: recently discussed in #oasis.
13:20:08 <shachaf>  @pl doesn't know about types at all.
13:20:25 <phlpp> :t (+)
13:20:26 <lambdabot> forall a. (Num a) => a -> a -> a
13:20:26 <jedbrown> dcoutts_: And the base-256 means it is one character of the input string, so indexing into the array is natural.
13:20:30 <faxathisia> nah not about @pl
13:20:35 <dcoutts_> jedbrown: yes
13:20:40 <faxathisia> how haskell types
13:20:46 <BMeph> :t join id
13:20:47 <shachaf> @pl (\x -> x x) (\x -> x x)
13:20:50 <lambdabot> ap id id (ap id id)
13:20:50 <lambdabot> optimization suspended, use @pl-resume to continue.
13:20:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
13:20:50 <lambdabot>     Probable cause: `id' is applied to too many arguments
13:20:50 <lambdabot>     In the first argument of `join', namely `id'
13:20:57 <phlpp> > (flip.flip.(+)) 5 3
13:20:58 <lambdabot>   add an instance declaration for (Num (b -> c))
13:21:00 <shachaf> @pl-resume
13:21:06 <lambdabot> ap id id (ap id id)
13:21:07 <lambdabot> optimization suspended, use @pl-resume to continue.
13:21:45 <phlpp> :t (\x -> flip.flip.(+))
13:21:47 <lambdabot> forall t b c. (Num (b -> c)) => t -> (b -> c) -> (b -> c) -> b -> c
13:22:10 <seydar> if i have data X a b = Y {test :: a, test2 :: b}, how do I acess test and test2?
13:22:12 <phlpp> ah ..
13:22:27 <shachaf> seydar: test valueOfTypeX
13:22:30 <faxathisia> seydar, by names test and test2
13:22:44 <jedbrown> dcoutts_: Hmm, the bitmap/variable size array is an interesting approach.  Might be tricky to get tuned right, but should be better on the cache.
13:22:44 <seydar> oh! so they're dynamic functions?
13:22:46 <phlpp> :t flip.(+)
13:22:47 <lambdabot> forall b c. (Num (b -> c)) => (b -> c) -> b -> (b -> c) -> c
13:22:53 <faxathisia> Not dynamic..
13:23:02 <phlpp> :t (+)
13:23:02 <shachaf> Or by pattern-matching; let Y { test = ... } = v in ...
13:23:03 <lambdabot> forall a. (Num a) => a -> a -> a
13:23:04 <oerjan> phlpp: you probably want (flip.flip $ (+))
13:23:11 <litb> hm, ++ binds better than $ ?
13:23:17 <dcoutts_> jedbrown: uses some tricky bit stuff to do the indexing, eg finding the length of the array is a bit population count
13:23:37 <faxathisia> > reverse $ "foo" ++ "bar"
13:23:38 <lambdabot>  "raboof"
13:23:43 <oerjan> litb: everything binds better than $
13:23:48 <jedbrown> dcoutts_: There are some bitwise tricks for that sort of stuff.  It's not super cheap, but manageable.
13:23:55 <BMeph> litb: Everything binds better than ($).
13:24:18 <dcoutts_> jedbrown: bit twiddling is cheaper than cache misses by orders of magnitude
13:24:38 <seydar> and If I have the whole data thing, how do I set a value for it?
13:24:39 <jedbrown> dcoutts_: true.
13:24:42 <seydar> wait...
13:24:44 <seydar> nevermind
13:24:48 <faxathisia> Is there anywhere, Typing rules for (the abstraction and application bit of) haskell?
13:25:04 <phlpp> :t (flip.flip $ (+))
13:25:05 <lambdabot> forall a. (Num a) => a -> a -> a
13:25:10 <jedbrown> dcoutts_: Trouble is that it's quite a bit of work to write and optimise in the case that it's not actually better.
13:25:16 <EvilTerran> fax, doesn't the report cover it?
13:25:39 <phlpp> :t liftM2
13:25:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:26:09 <phlpp> :t liftM
13:26:09 <oerjan> @go typing haskell in haskell
13:26:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:26:10 <lambdabot> http://citeseer.ist.psu.edu/424440.html
13:26:10 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
13:26:17 <jedbrown> dcoutts_: There was a simple hashtable vs. Judy Tree benchmark that showed they were comparable for lots of data sets.
13:26:33 <jedbrown> dcoutts_: Indicating that the complexity was mostly a waste.
13:26:43 <dcoutts_> hmmm
13:26:59 <faxathisia> thanks
13:27:18 <phlpp> > liftM return (Just 5)
13:27:19 <lambdabot>   add an instance declaration for (Show (m a1))
13:27:30 <phlpp> whoops.
13:28:09 <jedbrown> dcoutts_: http://www.nothings.org/computer/judy/
13:28:09 <lambdabot> Title: A performance comparison of Judy to hash tables
13:28:21 <oerjan> :t liftM return (Just 5) -- two monads
13:28:22 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => Maybe (m a1)
13:30:11 <phlpp> :t liftM (:[]) ([5])
13:30:12 <lambdabot> forall a1. (Num a1) => [[a1]]
13:30:29 <seydar> in my data AAA a b =  {test :: a, test2 :: b}, what do I do if want to create a new AAA object and set test2 to something completely different?
13:30:35 <jedbrown> dcoutts_: (pkhuong's approach seems fairly similar to the Judy Tree)
13:30:56 <oerjan> seydar: yourOldObject { test2 = whatever }
13:30:57 <phlpp> :t liftM (:[]) 5
13:30:58 <lambdabot> forall a1 (m :: * -> *). (Num (m a1), Monad m) => m [a1]
13:31:06 <phlpp> oh
13:31:11 <seydar> oerjan: nice. didn't know I could do that!
13:31:37 <seydar> oerjan: and does that return a new object or the old one?
13:31:45 <oerjan> seydar: you can also pattern match.  a new one.
13:31:59 <oerjan> the old one is immutable, after all
13:32:08 <seydar> oh right
13:32:09 <seydar> thank you!
13:32:23 <hpaste>  varl pasted "conif" at http://hpaste.org/5294
13:33:11 <jethr0> > liftM return (Just [1])
13:33:11 <lambdabot>   add an instance declaration for (Show (m [t]))
13:33:12 <phlpp> :t isPrime
13:33:13 <lambdabot> Not in scope: `isPrime'
13:33:56 <phlpp> :t (>>=)
13:33:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:34:15 <phlpp> :t flip . (>>=)
13:34:16 <lambdabot> forall b a b1. (b -> a) -> b -> (a -> b -> b1) -> b1
13:34:23 <jedbrown> > return =<< Just [1] -- jethr0
13:34:24 <lambdabot>  Just [1]
13:34:25 <oerjan> phlpp: usually the first function argument to liftM is non-monadic
13:34:29 <hpaste>  varl annotated "conif" with "asd" at http://hpaste.org/5294#a1
13:34:32 <phlpp> oerjan: jep
13:34:34 <phlpp> oerjan: i see ;)
13:36:56 <jethr0>   /msg lambdabot > 4
13:37:01 <jethr0>   /msg lambdabot > 4
13:37:10 <phlpp> hmm, is it possible to have a list of functions?
13:37:17 <faxathisia> phlpp, Yes
13:37:28 <phlpp> without monads?
13:37:36 <jethr0> > liftM return (Just 4) :: Maybe [Int]
13:37:37 <lambdabot>  Just [4]
13:37:38 <phlpp> or is this done with monads
13:37:40 <faxathisia> [] is a Monad
13:37:41 <dons> phlpp: sure.
13:37:42 <shachaf> oerjan: (a -> b) is non-monadic? :-)
13:37:46 <phlpp> ah, right
13:37:47 <oerjan> > map ($ 1) [sin, cos, tan]
13:37:48 <lambdabot>  [0.8414709848078965,0.5403023058681398,1.5574077246549023]
13:37:51 <Cin> :hoogle (m a) -> a
13:37:55 <Cin> @hoogle (m a) -> a
13:37:56 <lambdabot> Prelude.id :: a -> a
13:37:56 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
13:37:56 <lambdabot> Data.Function.id :: a -> a
13:37:57 <oerjan> shachaf: in spirit
13:38:02 <shachaf> Cin: Not for monads.
13:38:06 <jethr0> > map ($4) [(4+), (4*)]
13:38:07 <lambdabot>  [8,16]
13:39:08 <oerjan> Cin: @hoogle is buggy with monad functions
13:39:34 <oerjan> also, such a function does not generally exist
13:39:45 <phlpp> :t map ($1) [sin,cos,tan]
13:39:46 <lambdabot> forall a. (Floating a) => [a]
13:40:12 <oerjan> :t [sin,cos,tan]
13:40:13 <lambdabot> forall a. (Floating a) => [a -> a]
13:40:22 <phlpp> ah
13:40:39 <faxathisia> > [$,id]
13:40:40 <lambdabot>  Parse error at "$,id]" (column 2)
13:40:43 <faxathisia> > [($),id]
13:40:49 <lambdabot>  Add a type signature
13:40:57 <phlpp> :t [(flip.flip), id]
13:40:58 <lambdabot> forall a b c. [(a -> b -> c) -> a -> b -> c]
13:41:40 <phlpp> :t [(flip.flip), sin]
13:41:41 <lambdabot> forall a b c. (Floating (a -> b -> c)) => [(a -> b -> c) -> a -> b -> c]
13:42:26 <phlpp> list elements have to be of the same type, haven't they?
13:42:30 <oerjan> yes
13:42:44 <phlpp> i don't get why that is working.. because type is "function"?
13:42:52 <phlpp> :t sin
13:42:53 <lambdabot> forall a. (Floating a) => a -> a
13:42:58 <phlpp> :t flip
13:42:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:43:00 <byorgey> Cin: there are functions of that type, but it's different for each particular monad.  some monads don't have one.
13:43:03 <oerjan> because you can define numeric instances for weird types
13:43:09 <shachaf> phlpp: sin works for any Floating.
13:43:12 <Cin> i tried to express "when a file exist send all its lines somewhere", without having to use do with intermediate values, but it was quite ugly
13:43:24 <Cin> doesFileExist motdFile >>= (`when` (readFile motdFile >>= mapM_ sendL . lines))
13:43:32 <shachaf> phlpp: If you define instance Floating (a -> b -> c), you'll get weird results.
13:43:50 <byorgey> :t whenM
13:43:51 <lambdabot> Not in scope: `whenM'
13:44:00 <Cin> @hoogle whenM
13:44:00 <lambdabot> No matches found
13:44:04 <phlpp> :t when
13:44:05 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:44:23 <byorgey> Cin: if I were you I'd make a helper function  whenM :: (Monad m) => m Bool -> m () -> m ()
13:44:36 <Cin> byorgey: in
13:44:42 <Cin> er, indeed*
13:44:46 * Cin slaps his terminal
13:45:29 <phlpp> byorgey: looking forward to get my first real life go match :-)
13:45:32 <phlpp> this week
13:45:37 <Cin> :t flip
13:45:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:45:40 <byorgey> phlpp: oh, exciting! =)
13:46:40 <phlpp> :t (flip.(-)) 5 3
13:46:41 <lambdabot> forall b c. (Num (b -> c), Num b) => (b -> c) -> c
13:46:44 <byorgey> Cin: of course then you could write   whenM (doesFileExist foo) $ readFile foo >>= mapM_ bar
13:46:56 <Cin> byorgey: indeed, that is quite nice
13:47:17 <oerjan> :t (flip (-)) 5 3
13:47:18 <lambdabot> forall a. (Num a) => a
13:47:27 <phlpp> argh
13:47:35 <phlpp> yeah, damn point
13:48:03 <phlpp> > (flip (-)) 5 3
13:48:04 <lambdabot>  -2
13:48:56 <EvilTerran> flip (-) = subtract
13:49:08 <phlpp> yeo
13:49:10 <phlpp> *yep*
13:49:22 <shachaf> > let from = id in subtract 5 `from` 3
13:49:23 <lambdabot>  -2
13:49:46 <phlpp> hehe
13:50:34 <phlpp> > let times = id in (*) 3 `times` 2
13:50:35 <lambdabot>  6
13:50:59 <EvilTerran> really now
13:51:43 <shachaf> "now"?
13:51:45 <shachaf> > (subtract 5 `from` 3 `now`)
13:51:46 <lambdabot>  -2
13:51:53 <phlpp> :D
13:51:57 <phlpp> :t `now`
13:51:58 <lambdabot> parse error on input ``'
13:52:01 <phlpp> :t (now)
13:52:02 <lambdabot> Not in scope: `now'
13:52:08 <faxathisia> :t now
13:52:09 <lambdabot> Not in scope: `now'
13:52:13 <phlpp> eh?
13:52:25 <faxathisia> > now
13:52:26 <lambdabot>   Not in scope: `now'
13:52:35 * byorgey is confused
13:52:52 <faxathisia> > (subtract 5 `from` 3 `nthpnhthtnoeoudhteou`)
13:52:52 <lambdabot>   Not in scope: `nthpnhthtnoeoudhteou'
13:53:07 <phlpp> > (subtract 1 `from` 1 `now`
13:53:07 <lambdabot> Unbalanced parentheses
13:53:08 <phlpp> > (subtract 1 `from` 1 `now`)
13:53:09 <lambdabot>   Not in scope: `now'
13:53:15 <phlpp> eh?
13:53:17 <byorgey> shachaf is a lambdabot magician!
13:53:22 <phlpp> yeah, he is
13:53:22 <phlpp> :D
13:54:02 <EvilTerran> @let please = id
13:54:03 <lambdabot> <local>:3:0:     Multiple declarations of `L.please'     Declared at: <local>...
13:54:03 <glguy> ?seen cale
13:54:04 <lambdabot> cale is in #oasis, #haskell-overflow, #haskell and #ghc. I last heard cale speak 5h 37m 3s ago.
13:54:21 <EvilTerran> > (subtract 1 `from` 1 `please`) --?
13:54:21 <lambdabot>   parse error on input `}'
13:54:30 <byorgey> > now $ "I know how he did it"
13:54:30 <lambdabot>  "I know how he did it"
13:54:32 <EvilTerran> > (subtract 1 `from` 1 `please`) -- ?
13:54:33 <lambdabot>   Not in scope: `please'
13:54:38 <EvilTerran> huh.
13:54:43 <glguy> anyone know the mbot command to find the reduced row echelon form of a matrix?
13:55:07 <shachaf> > (add 5 `to` 3 `please`)
13:55:08 <lambdabot>  8
13:55:08 <phlpp> > let foo = bar = id in bar.foo map
13:55:09 <lambdabot>  Parse error at "=" (column 15)
13:55:31 <phlpp> > let foo = id; bar = id in bar.foo map
13:55:31 <lambdabot>  Add a type signature
13:55:38 <faxathisia> > `please` do not `comeFrom` 30
13:55:38 <lambdabot>   parse error on input ``'
13:55:54 <byorgey> glguy: % RowReduce[m] ?
13:56:00 <shachaf> glguy: mbot is down right now.
13:56:20 <shachaf> glguy: (Unless you're using Mathematica?)
13:56:48 <byorgey> glguy: I have Mathematica, if you want me to run a calculation for you =)
13:57:00 <phlpp> > let please,WouldYouBeSoKindAndCalculate = id; plus = (+) in (please,WouldYouBeSoKindAndCalculate) 5 `plus` 3
13:57:00 <lambdabot>  Parse error at "Would..." (column 12)
13:57:07 * oerjan highly suspects someone is playing with private @let and @undefine messages
13:57:10 <phlpp> > let pleaseWouldYouBeSoKindAndCalculate = id; plus = (+) in (pleaseWouldYouBeSoKindAndCalculate) 5 `plus` 3
13:57:12 <lambdabot>  8
13:57:34 * byorgey expresses shock that oerjan would even make such a heinous accusation!!
13:57:35 <phlpp> enough's enough :>
13:58:05 <phlpp> > now $ "foobar"
13:58:05 <lambdabot>   Not in scope: `now'
13:58:08 <phlpp> eh?
13:58:50 <byorgey> phlpp: I guess lambdabot just doesn't like you ;)
13:58:58 <phlpp> probably :>
13:59:18 <byorgey> phlpp: (see oerjan's statement above... ;)
13:59:29 <phlpp> yeah
13:59:30 <phlpp> ;)
14:00:31 * shachaf is shocked as well.
14:01:55 * gwern is shocked, shocked to find programming here! Captain Renault, round up the usual suspects
14:02:52 * shachaf is shocked at all the energy wasted on shocking people.
14:03:38 <byorgey> gwern: =)
14:03:50 <gwern> shachaf: it doesn't take much effort to link to goatse or tub girl
14:03:55 <Saizan> faxathisia: using vincenz's TyperMonad i've a STLC checker that typechecks flip id, do you still want to see one?
14:04:05 <faxathisia> Yes!
14:04:57 <vincenz> stlc?
14:05:38 <faxathisia> That should be (\x -> s) :: a -> b  => {x :: a, s :: b}, (u v) :: b => {u :: a -> b, v :: a}
14:05:41 <hpaste>  Saizan pasted "STLC type checker" at http://hpaste.org/5295
14:05:42 <faxathisia> Isn't it?
14:06:13 <Saizan> vincenz: simply typed lambda calculus
14:07:39 <newsham> http://www.whatsmyip.org/
14:07:49 <EvilTerran> newsham, ?
14:07:51 <newsham> ?bot
14:07:51 <lambdabot> :)
14:07:58 <newsham> wanted to see if the bot prints the <title> for that
14:08:06 <Saizan> the TyPoly wrapping is just to follow the instance
14:08:32 <EvilTerran> newsham, judging by the text on the page, it probably has a prohibitive robots.txt, which \bot may respect
14:09:46 <newsham> http://www.cmyip.com/
14:09:46 <lambdabot> Title: My IP is 72.249.126.23 - CMyIP.com
14:10:47 <gwern> what's a simply typed lc? a lisp?
14:10:58 <Tac-Work> it's a calculus
14:11:00 <faxathisia> subset of haskell
14:11:11 <faxathisia> lisps are usually untyp.ed
14:11:15 <newsham> wouldnt lisp be untyped lc? (a little)
14:11:26 <gwern> faxathisia: I though haskell was the polymorphic calculus?
14:11:30 <faxathisia> subset of haskell
14:12:55 <seydar> how do I get a function call to continue on multiple lines in ghci?
14:12:55 <gwern> er... you mean simply typed lc = polymorphic lc?
14:13:02 <Saizan> haskell type system without typeclasses can be seen as simply typed lc
14:13:10 <kmcallister> Saizan, STLC has no polymorphism
14:13:10 <gwern> (wikipedia's [[lambda cube]] isn't being very helpful here)
14:13:17 <shachaf> seydar: Semicolons.
14:13:23 <seydar> gotcha
14:13:26 <kmcallister> gwern, in STLC every type is either a base type or t1 -> t2
14:13:31 <Saizan> kmcallister: exactly
14:13:43 <Saizan> like our kind system :)
14:13:53 <seydar> shachaf: didn't like that.
14:14:06 <kmcallister> but you have to remove more than typeclasses from haskell to get there
14:14:25 <kosmikus> indeed
14:14:35 <gwern> kmcallister: ok... and that doesn't encompass type class constraints, and type classes are how you get polymorphism, so I am wrong in thinking that STLC is a polymorphic l calculus?
14:14:37 <shachaf> seydar: GHCi can't do much better than that.
14:14:48 <kmcallister> gwern, you can do polymorphism without typeclasses, e.g.:
14:14:50 <kmcallister> :t id
14:14:52 <lambdabot> forall a. a -> a
14:14:53 <Saizan> kmcallister: i mean that our "type system" is a form of symply typed lamda calculus, not that haskell - typeclasses has the same type system of STLC
14:15:05 <seydar> shachaf: what do you do to write a function on multiple lines?
14:15:05 <kmcallister> Saizan, it's a form of polymorphically typed lambda calculus
14:15:14 <kmcallister> which is one "step" away in the lambda cube
14:15:25 <shachaf> > let f 0 = 1; f 1 = 2 in f 3
14:15:27 <lambdabot>   Non-exhaustive patterns in function f
14:15:27 <Saizan> kmcallister: how is it polymorphic?
14:15:40 <EvilTerran> seydar, just write it across multiple lines
14:15:47 <EvilTerran> make sure later ones are indented more than the first
14:15:48 <seydar> shachaf: nononono. I want ONE FUNCTION CALL to be across multiple lines
14:15:59 <seydar> it is indented more
14:16:00 <kmcallister> Saizan, it has type variables
14:16:02 <shachaf> seydar: You can't, in ghci.
14:16:05 <kosmikus> Saizan: the STLC doesn't have parametric polymorphism, nor does it have kinds
14:16:13 <EvilTerran> seydar, is this in a file, or in GHCi?
14:16:14 <seydar> shachaf: ah
14:16:14 <hpaste>  varl annotated "conif" with "s" at http://hpaste.org/5294#a3
14:16:17 <seydar> ghci
14:16:35 <kmcallister> it also doesn't have sum or product types
14:16:36 <EvilTerran> ghci doesn't do anything, but your shell might offer something
14:16:42 <kmcallister> although i think that's less fundamental
14:16:46 <EvilTerran> try finishing non-final lines with a \
14:16:53 <Saizan> kosmikus: i'm seeing our type system as the calculus, and the kind system as its type system..
14:16:55 <seydar> i did. it puked
14:16:55 <kosmikus> kmcallister: right, but neither does F-omega in its pure form ...
14:17:28 <Saizan> kosmikus: so type constructors are functions etc..
14:17:30 <kmcallister> i guess with the usual encoding of pairs, a * b becomes (a -> b -> c) -> c
14:17:34 <vincenz> Saizan: neat :)
14:17:57 <kmcallister> and a + b becomes (a -> c) -> (b -> c) -> c
14:18:01 <vincenz> Saizan: was it easy to use?
14:18:02 <EvilTerran> seydar, actually, if you're on 6.8, you can do multi-line stuff by typing :{ to start, and :} to close
14:18:10 <kosmikus> Saizan: oh, ok. yes, then it's more like the STLC, only that it doesn't support lambda everywhere
14:18:15 <EvilTerran> (on lines on their own)
14:18:28 <kosmikus> Saizan: sorry, I completely misunderstood you there ...
14:18:28 <seydar> ok
14:18:33 <kmcallister> Saizan, me too
14:18:36 <EvilTerran> Prelude> :{
14:18:36 <EvilTerran> Prelude| let foo = 1
14:18:36 <EvilTerran> Prelude|     in foo
14:18:36 <EvilTerran> Prelude| :}
14:18:36 <EvilTerran> 1
14:19:04 <kmcallister> although ? and ?? are polymorphic kinds, as i understand
14:19:27 * faxathisia is not sure they get this code
14:19:35 <kosmikus> not in the "parametrically polymorphic" sense though
14:19:56 <faxathisia> I guess that the difference between this and mine is that unify is called multiple times
14:19:57 <kosmikus> ? and ?? are placeholders for either # or * or something like that
14:20:09 <kosmikus> it's some minor form of subkinding
14:20:12 <faxathisia> but I tried to do all the unification at once at the end
14:20:19 <kmcallister> yeah, i suppose they're not variables because they don't bind
14:20:28 <faxathisia> I'm not sure how that could make a difference though
14:20:37 <Saizan> vincenz: a lot! i thought that handling vars would be tricky but MonadScope just does everything :)
14:20:55 <ski_> `MonadScope' ?
14:21:24 <SimonRC> hmm....
14:21:32 <SimonRC> That is odd...
14:22:14 <Saizan> faxathisia: so you accumulate the equations in some abstract form and solve them at once in the end?
14:22:21 <faxathisia> Yes
14:22:50 <SimonRC> Is there a way to express that a function is a member of the intersection of (a -> a2) and (b -> b2)?
14:23:00 <vincenz> Saizan: great :)
14:23:04 <Saizan> ski_: http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
14:23:05 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
14:23:16 <EvilTerran> SimonRC, well, "the intersection" doesn't really make sense, seeing as we don't have subtypes...
14:23:19 <SimonRC> I think it can be done with typeclasses, but that seems a bit silly here
14:23:28 <SimonRC> the problem is this:
14:23:53 <SimonRC> map2 f (x,y) = (f x, f y)
14:24:00 <SimonRC> and x and y can be different types
14:24:12 <kmcallister> SimonRC, then f is not well typed
14:24:16 <kmcallister> or is polymorphic
14:24:24 <Saizan> faxathisia: maybe you're not composing the resulting substitutions correctly?
14:24:25 <SimonRC> f is indeed polymorphic
14:24:26 <kmcallister> :t \f (x,y) -> (f x, f y)
14:24:28 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
14:24:36 <kmcallister> that's the most general type you can give that
14:24:43 <SimonRC> in that case it is (foldr (++) [])
14:24:45 <faxathisia> Saizan, I'm not sure how that could be
14:25:09 <EvilTerran> SimonRC, it's possible to do something cunning with explicit forall.s, but you need to know something about the type of x and y for that to be useful
14:25:31 <EvilTerran> :t \f (x,y) -> ((f :: forall a b. a -> b) x, f y)
14:25:33 <lambdabot>     Inferred type is less polymorphic than expected
14:25:33 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
14:25:33 <lambdabot>         f :: a -> b (bound at <interactive>:1:1)
14:25:33 <SimonRC> clearly, x and y can be lists of different list types and that *should* be allowed to work
14:25:38 <faxathisia> The unification algorithm works
14:25:38 <EvilTerran> humph
14:25:48 <faxathisia> I'm quite sure of that
14:25:55 <mux> > let map2 = join (***) in map2 (+1) (3,4)
14:25:57 <lambdabot>  (4,5)
14:26:02 <ski_> @type \(f :: forall a. [] a -> Maybe a) (x,y) -> (f x,f y)
14:26:03 <lambdabot> forall a a1. (forall a2. [a2] -> Maybe a2) -> ([a], [a1]) -> (Maybe a, Maybe a1)
14:26:07 <EvilTerran> :t \f (x,y) -> (f x, f y) :: (forall a b. a -> b) -> (a,b) -> (c,d)
14:26:08 <lambdabot>     Couldn't match expected type `(forall a1 b1. a1 -> b1)
14:26:08 <lambdabot>                                   -> (a, b)
14:26:08 <lambdabot>                                   -> (c, d)'
14:26:18 <Saizan> faxathisia: and the result is a substitution, right?
14:26:23 <EvilTerran> i give up \-.-/
14:26:31 <shachaf> @let map2 f s = everywhere (mkT f) s
14:26:34 <lambdabot> Defined.
14:26:44 <shachaf> > map2 (+1) (1::Int,2::Float)
14:26:46 <lambdabot>  (1,2.0)
14:26:50 <ski_> @type \(f :: forall a. f a -> g a) (x,y) -> (f x,f y)
14:26:51 <lambdabot>     A pattern type signature cannot bind scoped type variables `f', `g'
14:26:51 <lambdabot>       unless the pattern has a rigid type context
14:26:51 <lambdabot>     In the pattern: f :: forall a. f a -> g a
14:27:00 <SimonRC> shachaf: aha!
14:27:07 <faxathisia> hmm.. no.. actually it's not
14:27:19 <EvilTerran> > map2 (+1) (1 :: Int, 2 :: Float, 3 :: Rational)
14:27:20 <lambdabot>  (1,2.0,3%1)
14:27:23 <shachaf> SimonRC: You do need Data for that.
14:27:30 <EvilTerran> SimonRC, everywhere and mkT are deep magic
14:27:32 <faxathisia> I put a list of terms & types or an equation between types
14:27:32 <wagle> :t map2
14:27:33 <lambdabot> Not in scope: `map2'
14:27:42 <shachaf> It's really cheating, of course. :-)
14:27:48 <EvilTerran> ?type everywhere
14:27:48 <ski_> @type let foo :: (forall x. f x -> g x) -> (f a,f b) -> (g a,g b); foo f (x,y) = (f x,f y) in f
14:27:49 <lambdabot> Not in scope: `everywhere'
14:27:50 <lambdabot> Not in scope: `f'
14:27:54 <EvilTerran> ?type Data.Generics.everywhere
14:27:55 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
14:27:56 <faxathisia> unify them until the terms are typed as fully as possible
14:28:00 <wagle> ?type map2
14:28:00 <lambdabot> Not in scope: `map2'
14:28:04 <ski_> @type let foo :: (forall x. f x -> g x) -> (f a,f b) -> (g a,g b); foo f (x,y) = (f x,f y) in foo
14:28:05 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (forall x. f x -> g x) -> (f a, f b) -> (g a, g b)
14:28:16 <faxathisia> seems a bit backwards thinking about it... although it did type Y
14:28:27 <EvilTerran> wagle, things defined in ?let aren't visible to ?type (or :t, it's the same thing). implementation restriction.
14:28:45 <wagle> yeah
14:29:19 <EvilTerran> > (\f (x,y) -> (f x, f y)) id (True,'a')
14:29:20 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Char'
14:29:27 <EvilTerran> > (\f (x,y) -> (f x, f y)) (id :: forall a. a -> a) (True,'a')
14:29:27 <lambdabot>  Parse error at "." (column 41)
14:29:30 <EvilTerran> ?type (\f (x,y) -> (f x, f y)) (id :: forall a. a -> a) (True,'a')
14:29:31 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
14:29:31 <lambdabot>     In the expression: 'a'
14:29:31 <lambdabot>     In the second argument of `(\ f (x, y) -> (f x, f y))', namely
14:29:55 <Saizan> faxathisia: oh, a quite different approach then, i don't know much on unification..
14:29:55 <EvilTerran> ?type (\(f :: forall a. a -> a) (x,y) -> (f x, f y)) id (True,'a')
14:29:56 <lambdabot> (Bool, Char)
14:29:59 <EvilTerran> ?type (\(f :: forall a. a -> a) (x,y) -> (f x, f y))
14:30:00 <lambdabot> forall t t1. (forall a. a -> a) -> (t, t1) -> (t, t1)
14:30:10 <EvilTerran> SimonRC, *that*'s what I was talking about
14:30:15 <SimonRC> argh this is going to fast to follow
14:30:22 <faxathisia> I just followed herbrands algorithm from the ISO prolog std
14:30:34 <EvilTerran> SimonRC, when i mentioned forall.s before
14:30:44 <SimonRC> EvilTerran: not what applies in this case
14:30:49 <EvilTerran> SimonRC, er, what?
14:30:54 <gwern> is there any particular page or article explaining why haskell avoids dependent types? I've seen more than a few people wanting it
14:31:04 <SimonRC> here, the call is: map2 (foldr (++) []) (unzip x)
14:31:06 <EvilTerran> gwern, decidability of type checking?
14:31:06 <olsner> oh noes, I've fallen out of the #haskell map
14:31:08 <faxathisia> I'm going to try to rewrite this, I think I will get it right next time
14:31:15 <faxathisia> Thanks very much
14:31:28 <gwern> EvilTerran: is that it?
14:31:38 <masklinn> "
14:32:04 <kmcallister> that said typechecking haskell with GHC extensions is not decidable anyway
14:32:04 <ddarius> gwern: At the time Haskell's type system was pretty advanced.  Now, dependent types are just not the direction Haskell is going to go.
14:32:14 <shachaf> olsner: Let me reconnect you.
14:32:27 <gwern> ddarius: I realize that, but that's kind of vague. why is it just not &etc.
14:32:41 <olsner> shachaf: saved! thanks ;-)
14:32:47 <faxathisia> If you added dependant types to haskell you'd have something else
14:32:49 <ddarius> gwern: Further, dependent types haven't yet "proven" themselves yet.  It would be too big a leap to add them to Haskell.
14:32:50 <faxathisia> like Cayenne
14:32:54 <vincenz> Saizan: be nice if we could bundle your code with the typechecker as illustration
14:33:07 <ddarius> Yes, Haskell+dependent types is no longer Haskell.  Too much would need to change.
14:33:13 <gwern> faxathisia: like haskell these days is still haskell98?
14:33:25 * faxathisia shrugs
14:33:28 <ac> are there any drawbacks to -XTypeSynonymInstances?
14:33:40 <ddarius> gwern: It's still related to it.  The extensions are nearly as dramatic a change as dependent types would be.
14:33:41 <EvilTerran> ?type let map2 :: (forall a. [[a]] -> [a]) -> ([[a]],[[b]]) -> ([a],[b]); map2 f (x,y) = (f x, f y) in map2 (foldr (++) []) (unzip [("Foo",[True,False]),("Bar",[False,True])])
14:33:41 <roconnor> ddarius: dependent types may not have proved themselves, but they prove lots of other things too. :D
14:33:42 <lambdabot> ([Char], [Bool])
14:33:53 <EvilTerran> SimonRC, incidentally, foldr (++) [] = concat
14:33:53 <faxathisia> lol
14:33:59 <SimonRC> heh
14:34:29 <SimonRC> map2 :: (c :: * -> *, d :: * -> *) => (forall x. c x -> d x) -> (c a, c b) -> (d a, d b)
14:34:35 <SimonRC> ^^ that would be nice
14:34:45 <ac> I mean, why isn't -XTypeSynonymInstances enabled by default?
14:34:54 <SimonRC> where c and d are arbitrary functions on types
14:34:56 <SimonRC> oops...
14:35:03 <SimonRC> that is undecideable
14:35:13 <ddarius> No extension should be enabled by default
14:35:26 <sarehu> they need extension aliases
14:35:41 <SimonRC> except, you can check if the function's type does indeed have that property.
14:35:42 <SimonRC> hmm
14:35:45 <ddarius> -XSarehusExtensions
14:35:57 <EvilTerran> ?type let map2 :: (forall a. f a -> g a) -> (f a, f b) -> (g a, g b); map2 f (x,y) = (f x, f y) in map2
14:35:58 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (forall a1. f a1 -> g a1) -> (f a, f b) -> (g a, g b)
14:36:04 <EvilTerran> SimonRC, ta-dah!
14:36:12 * SimonRC reads
14:36:54 <EvilTerran> SimonRC, it's pretty much just what you said. the big restriction for pulling this sort of funk is that the typechecker can't work out these higher-rank types, so you have to give them explicitly
14:37:06 <kmcallister> ah, that's a very clever way to type map2
14:37:18 <SimonRC> > let map2 :: (forall a. f a -> g a) -> (f a, f b) -> (g a, g b); map2 f (x,y) = (f x, f y) in map2 sum ([1,2],[1.0,2.0])
14:37:19 <lambdabot>  Parse error at "." (column 22)
14:37:27 <SimonRC> huh?
14:37:41 <EvilTerran> lambdabot can only run haskell98
14:37:46 <SimonRC> bah
14:37:54 <EvilTerran> even though it can typecheck other things. go try it in ghci. :P
14:38:01 <ac> ddarius: wha? That's not an extension
14:38:13 <EvilTerran> SimonRC, you'll need -XRankNTypes
14:38:38 <kmcallister> :t unzip
14:38:39 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:40:39 <glguy> where time becomes a loop
14:40:55 <EvilTerran> -XDWIM
14:41:10 <dons> oh man . he's still doing it
14:41:20 <EvilTerran> doing what?
14:41:23 <EvilTerran> who?
14:41:28 <dons> glguy's gone insane
14:41:30 <hpaste> where time becomes a loop
14:41:44 <Pseudonym> glguy's gone insane?
14:41:48 * Pseudonym sets up a popcorn stand
14:41:48 <SimonRC> EvilTerran: unrecognised flags: -XRankNTypes
14:41:49 <EvilTerran> hpaste's gone insane?
14:42:01 <glguy> dons' gone insane?
14:42:23 <hpaste> EvilTerran's gone insane?
14:42:24 <nominolo> > 256 :: Word8
14:42:25 <lambdabot>  0
14:42:25 <bos> a twist in the fabric of space.
14:42:26 <EvilTerran> SimonRC, it works for me. what version are you using?
14:42:31 <SimonRC> 6.6
14:42:35 <bos> glguy: are you quoting spock, or orbital?
14:42:41 <dons> orbital, i think
14:42:48 <Pseudonym> We've all gone insane!  These prices on lambdas are CRAZY!
14:42:51 <glguy> bos: listening to Orbital, did they listen to Spock?
14:42:52 <Smirnov> are there any static proof checkers using haskell
14:42:58 <dons> Smirnov: Agda
14:43:08 <bos> glguy: that snippet is lifted from a really old star trek episode.
14:43:10 <dons> Smirnov: and lots of others (check haskell.org)
14:43:28 <EvilTerran> someone who knows the quirks of the command-line flags, what should this man be writing instead of -XRankNTypes?
14:43:28 <Smirnov> does that do proofs on the program itself?
14:43:53 <dons> -fglasgow-exts
14:44:01 <quicksilver> on 6.6 that is spelt -fglasgow-exts
14:44:33 <EvilTerran> SimonRC, there you go. -fglasgow-exts it is
14:44:40 <SimonRC> yes
14:44:59 <SimonRC> but, that type isn't right either
14:45:09 <EvilTerran> no?
14:45:30 <SimonRC> it can match f a to [a] but can't match g a to a
14:45:43 <SimonRC> I want g to be the identity type constructor
14:45:52 <EvilTerran> newtype Id a = Id a :P
14:46:00 <Smirnov> dons: hmm ill just browse the haskell.org thx
14:46:06 <glguy> where Id becomes a loop
14:46:11 <EvilTerran> SimonRC, you'll have to wrap/unwrap manually
14:46:14 <kmcallister> SimonRC, i think you'll have to wrap it in Identity
14:46:17 <kmcallister> yeah
14:46:31 <EvilTerran> haskell Just Doesn't Work Like That
14:46:39 <kmcallister> we have type constructors but no type functions
14:46:42 <SimonRC> it seems so simple when you look at it
14:46:52 <SimonRC> let f t = [t]; g t = t in map2 :: (forall a. f a -> g a) -> (f a, f b) -> (g a, g b)   ;-)
14:47:13 <SimonRC> I really thought that our type system would have the oompf, but it doesn't
14:47:17 <EvilTerran> SimonRC, the problem is, if you allowed such things, it'd be deeply ambiguous
14:47:36 <SimonRC> syntax-wise or more generally
14:47:45 <EvilTerran> behaviour-wise
14:48:00 <kmcallister> if you allow arbitrary functions at type level, typechecking becomes undecidable
14:48:04 <EvilTerran> map2 concat ([], [[1,2,3],[4,5,6]]) -- is g the identity, or []?
14:48:39 <SimonRC> ouch
14:48:51 <EvilTerran> so it needs some way to tell
14:49:22 <SimonRC> in some cases, it is quite easy to *check* if you already know the type of the first argument...
14:49:28 * EvilTerran isn't sure if that example was quite right, but you get the idea
14:49:41 <kib> Why do I get an error inside Hugs when I ask for the type 'Maybe' ?
14:49:45 <SimonRC> but type inference can't help as much as usual
14:49:51 <EvilTerran> SimonRC, there's something you can do called Overlapping Instances which allows you to hack something like that
14:49:56 <EvilTerran> but it's messy and bad
14:49:57 <SimonRC> kib:  what error?
14:50:05 <EvilTerran> kib, because types don't have types, and Maybe is a type
14:50:11 <EvilTerran> ?type Just -- is this what you wanted?
14:50:13 <lambdabot> forall a. a -> Maybe a
14:50:18 <EvilTerran> ?kind Maybe -- or this?
14:50:19 <lambdabot> * -> *
14:50:20 <kib> ERROR - Undefined data constructor "Maybe"
14:50:35 <SimonRC> you probably want "Just" then
14:50:41 <SimonRC> I keep doing that too
14:51:05 <SimonRC> it just seems so silly that something so damn obvious to humans is not explainable to the compiler
14:51:08 <SimonRC> hmm...
14:51:20 <EvilTerran> SimonRC, look at my example, though; it's *not* obvious to humans
14:51:28 <kib> EvilTerran : thanks, but it works with Just, Nothing,etc.
14:51:39 <EvilTerran> kib, yes. that's because Just and Nothing are values.
14:51:54 <EvilTerran> and, being values, they have types.
14:52:04 <EvilTerran> Maybe, being a type, doesn't have a type. but it does have a kind.
14:52:13 <EvilTerran> kinds don't have anything, they just are. :)
14:52:15 <kib> that's clearer now
14:52:16 <SimonRC> indeed Just :: a -> Maybe a, and Nothing :: Maybe a
14:52:35 <Mr_Awesome> kinds have meta-kinds ;)
14:52:41 <kmcallister> which in haskell are all *
14:52:45 <kib> SimonRC, yes that's what I've saw
14:52:56 <EvilTerran> kmcallister, well, * or k1 -> k2
14:53:34 <kmcallister> EvilTerran, all the meta-kinds are * i mean
14:54:04 <kib> In fact that was not so clear inside YAHT book, because the first time you encounter Maybe is within types.
14:54:14 <ddarius> What is a "static" proof checker?
14:54:30 <kmcallister> or... i guess kind level (->) has meta-kind * -> *...
14:54:32 <kmcallister> whatever
14:54:32 <EvilTerran> SimonRC, okay, here's an example which does work: map2 (const ()) (True, [1,2,3]) -- should this be ((), ()), or ((), [(),(),()])?
14:54:41 <EvilTerran> kmcallister, ah, i see
14:55:09 <faxathisia> kmcallister, I don't understand that..
14:55:16 <ddarius> 
14:55:32 <ddarius> Does that box not have a dot in it for anyone?
14:55:38 <SimonRC> EvilTerran: well, that could be resolved with a type annotation on map2
14:55:47 <EvilTerran> SimonRC, it should be the first, because g = id... but wait! it should be the second, because g = []!
14:55:47 <SimonRC> but thanks for a good illustration of the problem
14:55:51 <kmcallister> er i guess it would be * -> * -> *
14:56:03 <ddarius> kmcallister: Yeah
14:56:05 <kmcallister> SimonRC / EvilTerran, are there cases where explicit type annotation doesn't resolve the ambiguity?
14:56:14 <EvilTerran> okay, cool. you might be able to do something with typeclasses and overlapping instances, if you don't mind giving explicit types.
14:56:19 <EvilTerran> i'm not sure.
14:56:26 <asdf> hi there..
14:56:28 * SimonRC fiddles..
14:56:37 <faxathisia> I don't see why -> would have any meta*kind?
14:56:52 <kmcallister> well it's a kind constructor
14:57:03 <kmcallister> of arity 2
14:57:06 <kmcallister> (there's also a type constructor with the same name)
14:57:18 <RayNbow> <ddarius>  <-- box with a dot here
14:57:21 <ddarius> :k Maybe :: * *
14:57:22 <lambdabot> parse error on input `::'
14:57:41 <ddarius> :t Nothing :: (Maybe Int :: * *)
14:57:42 <lambdabot> parse error on input `*'
14:57:50 <ddarius> :t fmap
14:57:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:57:58 <faxathisia> I thought Maybe and (:) are type constructors
14:58:11 <ddarius> :t forall (f :: * *) a. f a
14:58:12 <lambdabot> parse error on input `*'
14:58:18 <Tac-Work> :t (:)
14:58:19 <kmcallister> Maybe is a type constructor
14:58:20 <lambdabot> forall a. a -> [a] -> [a]
14:58:22 <EvilTerran> Maybe's a type constructor; (:)'s a value constructor
14:58:25 <Tac-Work> :t Maybe
14:58:27 <lambdabot> Not in scope: data constructor `Maybe'
14:58:33 <Tac-Work> :t Just
14:58:34 <lambdabot> forall a. a -> Maybe a
14:58:37 <ddarius> :k Maybe
14:58:38 <lambdabot> * -> *
14:58:47 <Tac-Work> :k [a]
14:58:48 <lambdabot> Not in scope: type variable `a'
14:58:50 <kmcallister> ddarius, you'll never be able to write v :: (t :: k) for k other than * or #
14:58:55 <Tac-Work> :k forall a. [a]
14:58:55 <lambdabot> *
14:58:57 <Tac-Work> :k []
14:58:58 <lambdabot> * -> *
14:59:09 <kmcallister> because every value has a fully-applied type
14:59:16 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5298
14:59:18 <Tac-Work> :k [] Int
14:59:19 <lambdabot> *
14:59:22 <asdf> have a question: we have to define a datastructure to represent a priority queue and a function to delete a given task.... my solution is this but it doesnt work out, why not? some help pls (:   http://hpaste.org/5298
14:59:22 <SimonRC> EvilTerran: waitamo, the answer should obviously be ((), ()), because (const ()) dosen't descend into lists
14:59:28 <Tac-Work> > [1,2,3] :: [] Integer
14:59:30 <lambdabot>  [1,2,3]
14:59:34 <Tac-Work> =-D
14:59:41 <EvilTerran> SimonRC, er... yes. my brain is confused.
15:00:00 <SimonRC> hmm
15:00:00 <kmcallister> asdf, can you be more specific about how/why it doesn't work/
15:00:07 <ddarius> kmcallister: As is well known, the kind level is so trivial that it does not need a "meta-kind" system to support correctness.  * * is not even syntactically legal.
15:00:12 <EvilTerran> map2 (map (const ())) ([], [[1,2],[3,4]])
15:00:20 <kmcallister> ddarius, yeah, this is what i suspected
15:00:26 <EvilTerran> no, wait, that doesn't work either... does it?
15:00:28 <SimonRC> EvilTerran: looks more liekly...
15:00:28 <ac> Say I want a method  in a type class that gives me a different constant for each instance. Is there any better way than just making it a single argument function that ignores its argument?
15:00:31 <kmcallister> is there no type system which gives rise to a kind system rich enough to need another layer?
15:00:32 <EvilTerran> I just don't know any more :(
15:00:41 <EvilTerran> kmcallister, we don't really need it...
15:00:46 <EvilTerran> maybe dependent types
15:01:09 <EvilTerran> SimonRC, let's take a simpler function
15:01:17 <mainland> i'm pretty sure i saw a pointer recently to work that discusses the consequences of adding ref types to Haskell, but I can't track it down. Does this sound familiar to anyone?
15:01:18 <asdf> kmcallister, Main> deleteTasks "tilten" (Store 5 "tilten" (Store 1 "donken" EmptyQueue))
15:01:18 <asdf> Program error: pattern match failure: deleteTasks "tilten" (PriorityQueue_Store (Num_fromInt instNum_v30 5) "tilten" (PriorityQueue_Store (Num_fromInt instNum_v30 1) "donken" PriorityQueue_EmptyQueue))
15:01:18 <asdf> Main>
15:01:36 <kmcallister> ac, if the instance type depends on the constant type, you can write it directly
15:01:42 <kmcallister> class Foo a where foo :: a
15:01:50 <EvilTerran> SimonRC, actually, never mind, my "simpler function" ends up trivial
15:02:09 <ehird> parsec question
15:02:10 <ac> kmcallister: the problem is the constant is not of type "a"
15:02:11 <Cin> is there an option to compile your program with ghc so that it shows some form of backtrace when an exception is thrown?
15:02:21 <kmcallister> ac, is it of a type depending on a
15:02:23 <ehird> i have a parser which one element parses (...)
15:02:25 <ehird> this is all good
15:02:34 <ac> kmcallister: I want: class Foo a where foo :: Int
15:02:37 <ehird> but when I have (..., i.e. an unbalanced (, i want it to report the error at the position of the (
15:02:40 <ehird> not the position of EOF
15:02:46 <kmcallister> ac, then you have to introduce a dummy a somewhere
15:02:46 <ehird> I was thinking I could do some magic with 'try' to make this happen>
15:02:58 <EvilTerran> ehird, a "try" for everything after the ( should do it
15:02:59 <ehird> so -- can I? how? :)
15:03:08 <ehird> EvilTerran: and that's it?
15:03:12 <ac> I thought so. I wonder if the compiler strips out that dummy variable in the process of compilation (idle curiosity)
15:03:21 <ehird> although... i can't do that entirely
15:03:22 <ac> I guess it has to
15:03:28 <EvilTerran> char '('; try (do res <- stuffInside; char ')'; return res)
15:03:30 <ehird> since it's expr := blah / blah / '('expr')'
15:03:34 <ehird> oh
15:03:35 <mainland> Cin: yes, look at the -xc RTS option. you'll need to compile with profiling enabled
15:03:37 <ehird> that's cool then
15:03:37 <ehird> :)
15:03:40 <EvilTerran> i think
15:03:42 <kmcallister> you could also newtype IntT a = Int; class Foo a where foo :: IntT a
15:03:57 <EvilTerran> ehird, also, look at "between"
15:04:04 <Cin> mainland: thanks
15:04:04 <EvilTerran> ?hoogle between
15:04:05 <lambdabot> Text.ParserCombinators.ReadP.between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
15:04:07 <kmcallister> err newtype IntT a = IntT Int
15:04:13 <lambdabot> Text.ParserCombinators.Parsec.Combinator.between :: GenParser tok st open -> GenParser tok st close -> GenParser tok st a -> GenParser tok st a
15:04:13 <lambdabot> Distribution.Version.betweenVersionsInclusive :: Version -> Version -> VersionRange
15:04:15 <ehird> EvilTerran: would that report it at the right place?
15:04:16 <EvilTerran> er, ReadP? well, Parsec has the same thing...
15:04:22 <EvilTerran> ehird, i don't know. try it! :)
15:04:26 <ehird> hehe :)
15:04:28 <ac> kmcallister: ah right. But then I'd have to deconstruct it whenever I called foo. Not a big deal though
15:04:36 <Cale> Cin: also, you can load up your program in ghci 6.8.2 and :set -fbreak-on-exception then :trace main
15:04:51 <kmcallister> ac, you can derive the Int typeclasses for IntT
15:04:59 <EvilTerran> ehird, if not, try (between ...) should move the error to immediately before the '('
15:04:59 <kmcallister> and just use it isomorphically
15:05:00 <Cin> cale: i will try that
15:05:07 <ac> kmcallister: ah good idea :)
15:05:10 <EvilTerran> sorry, "try (between ...)"
15:05:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5299
15:05:38 <Cale> Cin: When an exception is thrown, you'll be able to type :list to see the code around the current location and :back to pop a frame off the stack (which you'll most likely have to do at least once to see anything).
15:06:41 <EvilTerran> SimonRC, another problem with our map2 :: (forall a. f a -> g a) -> ..., is that you can't say f a = [[a]] and g a = [a]
15:07:02 <asdf> anyone a idea? http://hpaste.org/5299
15:07:04 <EvilTerran> SimonRC, as you can't say "g = [].[]" or whatever at the type level
15:07:25 <faxathisia> :k [] (,)
15:07:26 <lambdabot>     `(,)' is not applied to enough type arguments
15:07:26 <lambdabot>     Expected kind `*', but `(,)' has kind `* -> * -> *'
15:07:29 <ehird> EvilTerran: the crazy thing about this parser is that it needs to retain the strings it parses!!
15:07:33 <ehird> the language is an odd esolang :)
15:07:53 <faxathisia> :k [(,)] [] []
15:07:53 <EvilTerran> ehird, er... so you need to keep the ()s as well?
15:07:59 <Trinithis> ehird: which lang is an esolang?
15:08:03 <ehird> EvilTerran: yes, but i can handle all that :)
15:08:08 <ehird> Trinithis: it's Underload
15:08:27 <Cin> cale: i am trying it now
15:08:40 <ehird> http://esolangs.org/wiki/Underload I'm writing a compiler for it -- something which at first glance seems impossible. It'll also do some optimization, but the important thing is languages that look self-modifying aren't always.
15:08:42 <lambdabot>     `(,)' is not applied to enough type arguments
15:08:42 <lambdabot>     Expected kind `*', but `(,)' has kind `* -> * -> *'
15:08:42 <lambdabot> Title: Underload - Esolang
15:08:52 <EvilTerran> in general, taking a try around (do ... <- char '('; ... <- whatever; ... <- char ')') or whatever should, as i said, move the error to immediately before the '('
15:08:57 <ehird> The compiler is to serve both as a demonstration of that and a basis for other compilers like that
15:09:15 <Trinithis> ehird: a compiler or an interpreter?
15:09:19 <ehird> Trinithis: Compiler.
15:09:34 <ehird> Read the command set to see why at first this seems impossible.
15:09:46 <ehird> But there's a hacky version I wrote in Scheme that works, I'm just making it a nice haskell program :-)
15:10:14 <Trinithis> ehird: reminded me of befunge. what language are you making the compiler in?
15:10:28 <EvilTerran> SimonRC, are you still there?
15:10:32 <SimonRC> yes
15:10:33 <ehird> Trinithis: ... what do you think?
15:10:45 <Trinithis> ehird: oh you just answered LD
15:10:50 <kmcallister> asdf, you're using Hugs?
15:10:55 <EvilTerran> okay. i was just thinking, i think the trick to do this would be to use a multi-parameter typeclass
15:10:58 <ehird> Trinithis: this is #haskell.
15:11:08 <SimonRC> I was thinking that too
15:11:13 <SimonRC> but ... yuk
15:11:21 <EvilTerran> class Contains a fa where {- i dunno -}
15:11:24 <hastesaver> When trying to install cabal-install, I get a bunch of "Hackage/Config.hs:208:69: Not in scope: `docDirTemplate'" (etc.) errors. What is wrong?
15:11:35 <SimonRC> EvilTerran: yup
15:11:39 <ehird> hmm
15:11:46 <ehird> is there a parsec way to ask: 'am i the toplevel parser?'
15:11:54 <ehird> 'or have i been called by something else'
15:11:59 <ehird> i guess not
15:12:00 <monochrom> No.
15:12:23 <SimonRC> EvilTerran: so (ignoring the typeclass option) one ends up with 1000 specialisations of map2, each with textually identical implementation, but the typesystem doesn't allow one to make them all into one function
15:12:27 <EvilTerran> then map2 :: (Contains a fa, Contains a ga, Contains b fb, Contains b gb) => (forall a fa ga. (Contains a fa, Contains a ga) => fa -> ga) -> (fa,fb) -> (ga,gb)
15:12:45 <SimonRC> yes
15:12:46 <SimonRC> ouch
15:13:14 <SimonRC> at this point, all the dynamic language programmers point and laugh
15:13:34 <EvilTerran> let's back up a bit - what exactly are you trying to achieve?
15:13:51 <SimonRC> go to #haskell-overflow
15:13:59 <kmcallister> it seems like the Haskell way to do things would be to homogenize the pair, possibly using an existential type
15:14:58 <EvilTerran> kmcallister, we've been trying to do that for quite some time ;)
15:14:58 <ac> kmcallister: ok, so if I use the newtype option, how do I retrieve the constant for a particular instance of Foo, given a variable of that instance?
15:15:25 <asdf> kmcallister, yes
15:15:28 <ac> kmcallister: before I'd just say "foo a" but now foo takes no arguments
15:15:58 <ac> kmcallister: I could say "foo :: IntT FooInstance", but I'm writing a generic function, so I don't know "FooInstance"
15:17:05 <kmcallister> ac, you might have it as some type variable
15:17:08 <ddarius> kmcallister: You can have languages with arbitrarily high levels of "kinds" ("sort" is the more generic word).
15:17:11 <kmcallister> bound in some signature
15:17:34 <ac> kmcallister: I do, but you can't use type variables in the body of a function
15:18:04 <MyCatVerbs> ddarius: types are 0-sorts, kinds are 1-sorts, kinds of kinds are 2-sorts?
15:18:14 <kmcallister> ac, in ghc you can if you explicitly quantify them
15:18:21 <ehird> is there a parsec haddock docs anywhere?
15:18:30 <ac> kmcallister: oh really? What's the syntax for "explicit quantification"?
15:18:38 <kmcallister> forall a. t
15:18:49 <ac> oh cool
15:18:51 <ddarius> MyCatVerbs: Yes and no.  Sorts don't need to form a linear ordering.  They don't even need to form an ordering.
15:18:58 <ddarius> ehird: Almost.
15:19:03 <ehird> ddarius: :(
15:19:09 <ehird> the official docs are unreadable
15:19:10 <ddarius> ehird: I haddocked a new version of Parsec, but I haven't released it yet.
15:19:16 <ehird> bah
15:19:39 <ddarius> That said, the haddock comments are pretty much just the reference guide section of the Parsec letter.
15:20:06 <ehird> its the formatting of the page i don't like
15:20:37 <kmcallister> asdf, you could try GHCi instead
15:20:42 <kmcallister> ghci -Wall
15:20:49 <MyCatVerbs> ddarius: oh, that hurts my head.
15:20:52 <kmcallister> will give you warnings about incomplete patterns
15:21:00 <kmcallister> non-exhaustive i mean
15:21:11 <kmcallister> i don't immediately see where the problem is, though
15:21:16 <dozer> I have a question about programming with the state monad
15:21:20 <MyCatVerbs> Hrmn.
15:21:40 <Cale> dozer: shoot
15:21:50 <kmcallister> oh, spelling error
15:21:54 <kmcallister> deleteTasts
15:22:22 <kmcallister> i hate those.. i once turned in an assignment 7 weeks late because of a single missing ' in 2000+ lines of haskell
15:22:25 <dozer> Cale: say I'm processing data through a pipeline - the stateless one would look like (h . g . f)
15:22:45 <Cale> dozer: sure.
15:22:53 <dozer> Cale: now, let's say that instead of h, g, f being pure functions, they are each stateful computations, with their own independent type of state
15:23:11 <dozer> Cale: say, a map, an int counter and a random number generator
15:23:22 <Cale> oh, you'll want to runState each of them, and compose them however you can after that point.
15:23:37 <Cale> The State monad only works with one kind of state at a time.
15:23:52 <Cale> However, that state can be any type you like.
15:24:07 <dozer> Cale: I really want a state-aware (.) operator that hides all the mess for me :)
15:24:18 <asdf> kmcallister, well hugs is okay for me... it is a problem of my code not of hugs isnt it?
15:24:25 <kmcallister> yeah
15:24:34 <kmcallister> it's just that GHCi gave me an error that instantly located the problem
15:24:41 <asdf> ah okay i just read your lines after the highlight line ;9
15:24:58 <kmcallister> dozer, usually with State you'll choose the state type such that it holds all state you'll need anywhere within the computation
15:25:05 <Cale> Well, here's the design issue -- when you go from working in one state monad to working in a different one, what happens to the final state of the first computation, and what is the initial state of the next?
15:25:47 <Cale> If you can figure out what it is that you want those to be, then you can simply write it down and define yourself a nice operator :)
15:25:48 <asdf> oh lol thx dumb misstake
15:25:55 <asdf> but now i even cant load this file
15:26:26 <nolrai> is there somthing like read that returns Maybe a instead of giving exceptions?
15:26:36 <Cale> reads
15:26:38 <kmcallister> dozer, when working with such records the function gets is useful:
15:26:39 <kmcallister> :t gets
15:26:40 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
15:26:45 <Cale> :t reads
15:26:46 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:26:46 <phlpp> :t reads
15:26:47 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:27:01 <asdf> ah okay
15:27:02 <kmcallister> :t listToMaybe
15:27:03 <lambdabot> forall a. [a] -> Maybe a
15:27:05 <nolrai> thanks
15:27:06 <asdf> thx seems to work now
15:27:26 <kmcallister> :t fst . listToMaybe . reads
15:27:27 <lambdabot>     Couldn't match expected type `(a, b)'
15:27:27 <lambdabot>            against inferred type `Maybe (a1, String)'
15:27:27 <lambdabot>     In the second argument of `(.)', namely `listToMaybe . reads'
15:27:33 <kmcallister> :t liftM fst . listToMaybe . reads
15:27:34 <lambdabot> forall a. (Read a) => String -> Maybe a
15:27:44 <dozer> Cale: right - so I guess something like: (a -> State s2 b) (.) (State s1 a) :: State (s2, s1) b
15:27:52 <ac> kmcallister: hum, I'm not getting the syntax right. Could you write out the function that takes an istance of Foo and returns the Int associated with it?
15:28:09 <kmcallister> ac, sec
15:28:38 <MyCatVerbs> Anyone know offhand if there have been any reports of problems building darcs with GHC 6.8.2?
15:29:15 <Cale> dozer: Perhaps (b -> State s2 c) -> (a -> State s1 b) -> (a -> State (s1,s2) c)
15:29:26 <dozer> Cale: that looks more sane
15:30:51 <ac> can lambdabot take definitions for new data types?
15:30:56 <Cale> Now, there's an intermediate step here which would be rather handy. We want to express the lifting of some  State s1  computation to the monad  State (s1,s2)
15:31:03 <Cale> ac: Nope.
15:31:05 <hpaste>  kmcallister pasted "typeclass constants for ac" at http://hpaste.org/5301
15:32:22 <sfultong> thanks for the new xmonad dons et al
15:32:28 <Cale> That consists of two things:  a projection  (s1,s2) -> s1, and an "updater"  s1 -> (s1,s2) -> (s1,s2)
15:32:38 <kmcallister> ac, the function f there has the same type as the other (dummy arg) version of foo
15:32:46 <SimonRC> does GHC have that feature that allows you to partly specify types, and tell the compiler to fill in the rest?
15:32:51 <SimonRC> so instead of writing:  (.) (f :: b -> c) (g :: a -> b) = ...   you could write  (.) :: (b -> c) -> (a -> b) -> _ ; (.) = ...
15:32:55 <SimonRC> and what is it called?
15:33:02 <bobowski> >1
15:33:40 <ac> kmcallister: thanks :)
15:33:41 <Cale> SimonRC: nope. I don't know what it's called, but quite a few people have asked for it. One thing you can still do is comment out the type signature and then fire up ghci and ask for the type.
15:33:45 <kmcallister> ac, no problem
15:34:03 <SimonRC> Cale: unless the result is too specific?
15:34:07 <SimonRC> oops
15:34:13 <SimonRC> Cale: unless the result is too general?
15:34:50 <dozer> Cale: yup - just got to ensure that it is not insanely complicated to work with if you stack these five deep
15:35:06 <Pseudonym> SimonRC: Do you have a specific example you have in mind?
15:35:11 <ac> kmcallister: do I need any extensions for that?
15:35:21 <kmcallister> -fglasgow-exts should do it
15:35:43 <kmcallister> forall is an extension, as well as phantom types i believe
15:35:46 <ac> kmcallister: ah, that's why I was getting a syntax error
15:35:52 <kmcallister> yeah
15:35:58 <kmcallister> i should have mentioned that
15:36:08 <SimonRC> Pseudonym: no specific example
15:36:15 <nolrai> > reads "123"
15:36:16 <lambdabot>  [(123,"")]
15:36:18 <ehird> How do I trigger a custom parse error in parsec?
15:36:33 * SimonRC goes
15:36:38 <ehird> Well my question is a bit different actually.
15:36:42 <nolrai> > reads "123 12"
15:36:43 <lambdabot>  [(123," 12")]
15:36:47 <ehird> Garbage data at the end of my parsed stuff is ignored.
15:36:48 <kmcallister> :t fail
15:36:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:37:12 <Japsu> is there a default monad for lambdabot?
15:37:15 <Japsu> > fail "fail"
15:37:16 <lambdabot>   add an instance declaration for (Show (m a))
15:37:21 <ehird> i know fail thanks.
15:37:26 <Botje> > return 5
15:37:26 <lambdabot>   add an instance declaration for (Show (m t))
15:37:32 <Japsu> hmm
15:37:35 <Botje> doesn't look like it
15:38:18 <Cale> dozer: So you'll want a function: (b -> a) -> (a -> b -> b) -> State a t -> State b t that looks like this:
15:38:21 <Cale> liftS :: (b -> a) -> (a -> b -> b) -> State a t -> State b t
15:38:21 <Cale> liftS proj upd x = do u <- fmap proj get
15:38:21 <Cale>                       let v = runState x u
15:38:21 <Cale>                       put (upd v u)
15:38:31 <Cale> er..
15:38:57 <Cale> oh, heh
15:39:04 <nolrai> cale: what does that do?
15:39:13 <Cale> (that has a bug, one sec :)
15:39:29 <Japsu> I MADE U A BUG
15:39:32 <Japsu> BUT I EATED IT
15:39:48 <kmcallister> Cale, it would be nice to augment that with some TH so you get the updaters (and specializations of liftS) for each field in a record
15:40:28 <Japsu> ...the moment I start making lolcat-esque jokes is also the exact moment it turns out I should already be sleeping
15:40:29 <kmcallister> although i find that when i use State, i can usually localize all use of get/put to a few domain-specific monad actions
15:40:39 <ehird> I have a huge choice [a,b,c] parser right now
15:40:49 <ehird> i can't do <|> because I need to use loads of parens to get the precedence right
15:40:51 <ehird> what should i do :|
15:41:44 <Cale> liftS :: (b -> a) -> (a -> b -> b) -> State a t -> State b t
15:41:44 <Cale> liftS proj upd x = do u <- get
15:41:44 <Cale>                       let (r,v) = runState x (proj u)
15:41:44 <Cale>                       put (upd v u)
15:41:44 <Cale>                       return r
15:41:49 <Cale> *there* we go :)
15:42:03 <Cale> (I applied proj too early)
15:42:26 <Cale> Think of b as some "big" state type, and a as one of its components.
15:42:46 <Cale> Given a function b -> a which extracts that component, and a function (a -> b -> b) which alters it
15:43:05 <Cale> It lifts a State computation with state type a to one with state type b
15:43:20 <Cale> (which ignores all the rest of the state, leaving it unchanged)
15:43:32 <Cale> kmcallister: This is true :)
15:43:56 <Cale> kmcallister: This liftS sort of thing is still a handy thing to have in defining those though :)
15:43:57 <ehird> anyway?
15:44:05 <kmcallister> yes
15:44:07 <ac> kmcallister: can you really treat an IntT as an Int?
15:44:17 <kmcallister> ac, not in the code i pasted
15:44:19 <Cale> ehird: hmm
15:44:22 <kmcallister> but you could derive Num, Integral, etc.
15:44:24 <ehird> *anyone
15:44:37 <ac> kmcallister: ah ok. There is no equivalent class for the String type though
15:44:43 <Cale> ehird: Could you hpaste some code for us to look at?
15:44:54 <Cale> ehird: I'm not entirely sure I understand the problem...
15:44:57 <kmcallister> ac, what would it do?
15:45:06 <ehird> Cale: in a parsec thing i have
15:45:14 <ehird> foo = choice [a\n,b\n,c\n...]
15:45:15 <vincenz> Saizan: ping
15:45:21 <ehird> because <|> forces me to put parens all over the place
15:45:25 <ehird> what is the non-ugly solution?
15:45:38 <faxathisia> hmm what like ehird?
15:45:45 <ehird> faxathisia: ?
15:45:49 <ddarius> ehird: It's called a where clause
15:45:57 <faxathisia> I don't remember using a lot of paren with <|>, what does you code look like
15:46:00 <Big_Red> are there any any inbuilt functions for matrix transposes, rotations and reflections?
15:46:15 <Cale> ehird: um, you're using choice instead of <|> already, aren't you?
15:46:16 <ddarius> Big_Red: There isn't an inherent Matrix type.
15:46:29 <kmcallister> ac, you're right though, probably you should write some unwrapping function unIntT :: IntT a -> Int, and then use unIntT (foo :: IntT a)
15:46:29 <Cale> ehird: <|> is an associative operation, you shouldn't need parens.
15:46:38 <jedbrown> Big_Red: check out hmatrix an hackage.
15:46:51 <Cale> ehird: but that's what choice is for -- eliminating chains of <|>
15:46:54 <Jiten> does this mean a bug in ghc or is this something I can fix? http://hpaste.org/5302
15:47:05 <ehird> Cale: hm, why? my <|>s look all nice indented :)
15:47:06 <Cale> Jiten: --make
15:47:23 <Cale> Jiten: also, -O9 is ridiculous. You probably want -O2
15:47:26 <kmcallister> or -package posix
15:47:30 <ehird> hah, -O9
15:47:32 <ehird> -O389457894793485
15:47:38 <phlpp> :t <|>
15:47:39 <lambdabot> parse error on input `<|>'
15:47:40 <Big_Red> jed: hmatrix?
15:47:41 <phlpp> :t (<|>)
15:47:43 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
15:47:55 <ehird> :t Text.ParserCombinators.Parsec.(<|>)
15:47:55 <lambdabot> Couldn't find qualified module.
15:47:59 <ehird> hm.
15:48:06 <ddarius> @hackage hmatrix
15:48:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
15:48:07 <davidL> Does -O9 do anything different than -02?
15:48:07 <Jiten> Cale: does -O9 include risky optimizations?
15:48:15 <ehird> Jiten: it's just nonsense
15:48:19 <jedbrown> Big_Red: It is an interface to much of blas, lapack, and gsl.
15:48:20 <ac> ah cool! I just read about what you can do with existential types: data T = forall a. (Show a) => T a; map (\(T a) -> show a) [T (), T [1,2,3], "foo"]
15:48:23 <ehird> like, in GCC, anything above -O3 is == -O3
15:48:26 <ehird> same with ghc..
15:48:29 <ehird> though maybe the number is different
15:48:29 <hpaste>  monochrom pasted "(forall x. x -> t x) -> (a,b) -> (t a, t b)" at http://hpaste.org/5303
15:48:34 <Cale> Except with 2 instead of 3
15:48:39 <Big_Red> hmm
15:48:46 <jedbrown> Big_Red: It has a Matrix type that should support the operations you are interested in.
15:49:05 <phlpp> > data T = forall a. (Show a) => T a; map (\(T a) -> show a)  [T (), T [1,2,3], "foo"]
15:49:05 <lambdabot>  Parse error at "data" (column 1)
15:49:14 <Big_Red> jed: just making a noughts and crosses program and exploring options
15:49:18 <Cale> monochrom: I like how you named that operation 'whee'
15:49:23 <ehird> by the way... in #esoteric earlier someone was having a problem defining a function that took a function, a tuple, and returned the tuple but with both elements of the tuple passed to the function. 'Simple enough,' you say? Well: The elements of the tuple can be of a different type.
15:49:25 <Big_Red> so not real linear algebra...
15:49:37 <ac> phlpp: lambdabot can't define new data types. Plus I'm missing a "T" before the "foo"
15:49:38 <ehird> simonrc (or oerjan? someone.) said something about the monomorphism restriction
15:49:41 <monochrom> I name all operations "whee". :)
15:49:50 <phlpp> ac: ok ;)
15:49:54 <phlpp> ac: but i think i got the point
15:49:55 <Saizan> vincenz: pong
15:50:02 <jedbrown> Big_Red: In a few days, I should have an alpha of my CArray package that supports arbitrary dimensions, but it won't do tensor algebra.
15:50:05 <ac> phlpp: yeah, you can make heterogenous arrays
15:50:15 <Cale> ehird: It's not so much THE monomorphism restriction here, but it could be called a monomorphism restriction.
15:50:19 <jedbrown> Big_Red: hmatrix should be fine then.
15:50:23 <vincenz> Saizan: be nice if we could bundle your code with the typechecker as illustration
15:50:25 <ac> heterogeneous lists I mean
15:50:57 <ehird> Cale: well, they said that it would be possible to define it
15:50:59 <ehird> using crazy things
15:51:01 <ehird> and i'm intersted :D
15:51:03 <ac> now why are they called "existential"?
15:51:03 <kmcallister> bbl
15:51:03 <Cale> ehird: In the simply typed lambda calculus, and in HM, in the body of a lambda, the bound variable can have only one type.
15:51:33 <ehird> Cale: I see. that doesn't really tell me anything :)
15:51:35 <Big_Red> jed: full blown linear algebra is a bit overkill
15:51:40 <Cale> ehird: However, in fancier type systems, like GHC's, you can express the idea that the function passed to the lambda *must* be polymorphic.
15:51:49 <Big_Red> jed: but what you're saying is that basically i'll have to use something custom
15:51:52 <Saizan> vincenz: uhm, bundle as?
15:51:55 <kmcallister> ac, because a value of type exists a. T a is a pair (a, v) where a is a type and v :: T a
15:51:59 <Big_Red> jed: as opposed to like.. matlab which was written for it
15:52:16 <jedbrown> Big_Red: No, the library supports similar construction to matlab.
15:52:16 <ehird> Cale: So... this magical tuple-mapping function CAN exist?
15:52:17 <kmcallister> well i'm not sure about the word "because" but that's a true statement
15:52:26 <kmcallister> why this is written with forall instead of exists in haskell, i'm not quite sure about
15:52:29 <vincenz> Saizan: n a comment, or a post
15:52:37 <Cale> ehird: If you think about it, the code you want to write is just  foo f (x,y) = (f x, f y), but the type inferred for foo here will be (a -> b) -> (a,a) -> (b,b)
15:52:45 <kmcallister> but it's definitely written with an existential quantifier in the theory literature
15:52:55 <jedbrown> Big_Red: But the same package provides an interface to the math libraries.
15:53:05 <ehird> Cale: Yep, I know that too ;)
15:53:18 <ehird> apparently something using forall would work
15:53:18 <phlpp> :t (\f x y -> (f x, f y))
15:53:19 <lambdabot> forall t t1. (t -> t1) -> t -> t -> (t1, t1)
15:53:21 <Cale> yes.
15:53:25 <ehird> hm
15:53:28 <ehird> something like
15:53:33 <ehird> (forall a. (a -> b))
15:53:35 <ehird> for the function?
15:54:00 <mainland> aka const
15:54:02 <Cale> That could work, except there aren't many functions of that type in general.
15:54:09 <Saizan> vincenz: yeah, i could take the opportunity to finally start a blog :)
15:54:09 <faxathisia> \ f g (x,y) -> (f x, g y)
15:54:11 <Big_Red> jed: so is there simple "transpose" function in the basic libraries...
15:54:13 <ehird> foo :: (forall a. (a -> b)) (forall a. (a,a)) -> (b,b)
15:54:14 <ehird> or..something
15:54:25 <jedbrown> Big_Red: yes
15:54:29 <Big_Red> or should i just poke my own function together
15:54:32 <Big_Red> ah cool :)
15:54:41 <ehird> faxathisia: not a real solution!
15:54:43 <ehird> :)
15:54:45 <jedbrown> Big_Red: it would be a pretty silly library if there wasn't ;)
15:54:59 <Cale> > let foo :: (forall a. a -> b) -> (c,d) -> (b,b); foo f (x,y) = (f x, f y) in foo (const 5) ("Hello", 7)
15:54:59 <lambdabot>  Parse error at "." (column 21)
15:55:06 <Cale> d'oh.
15:55:15 <ac> it has nothing to do with existentialism though ;)
15:55:23 <glguy> for such a function to do anything you'd want to pick a type-class
15:55:27 <Cale> That *would* work.
15:55:34 * faxathisia is happy with such solution :P
15:55:35 <Cale> Right.
15:55:48 <Big_Red> excellent... i think
15:56:35 <glguy> Prelude> let weird :: (Show c, Show d) => (forall a . Show a => a -> String) -> (c,d) -> (String,String) ; weird f (x,y) = (f x , f y)
15:56:37 <glguy> Prelude> weird show (1,"ttest")
15:56:39 <glguy> ("1","\"ttest\"")
15:57:04 <ehird> now without the show restriction :P
15:57:10 <Cale> glguy: That is *exactly* the example I was just about to paste.
15:57:16 <ehird> or the String restriction..
15:57:26 <glguy> ehird: the String is easy to get rid of
15:57:32 <glguy> ehird: but if you want the function to *do* anythign
15:57:33 <Cale> let foo :: (Show c, Show d) => (forall a. Show a => a -> b) -> (c,d) -> (b,b); foo f (x,y) = (f x, f y) in foo (reverse . show) ("Hello", 7)
15:57:43 <glguy> you need to tell it where the overloaded instances come from
15:59:19 <glguy> a function of type (forall a b. a -> b) can't look at its argument, and can't produce an argument that anyone would be able to inspect
15:59:39 <ehird> http://hpaste.org/5304
15:59:59 <ehird> why does that accept garbage?
16:00:00 <ehird> at the end.
16:00:18 <glguy> because you don't manadate that an "eof" is parsed?
16:00:21 <glguy> mandate*
16:00:31 <Trinithis> @ty <?>
16:00:32 <lambdabot> parse error on input `<?>'
16:00:35 <LoganCapaldo> @hoogle eof
16:00:36 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
16:00:36 <lambdabot> Text.Read.EOF :: Lexeme
16:00:36 <lambdabot> Text.Read.Lex.EOF :: Lexeme
16:00:41 <glguy> Trinithis: adds documentation to a parser
16:00:49 <EvilTerran> ehird, what's with that string you're passing around everywhere?
16:00:53 <Trinithis> glguy: what about <|>
16:00:54 <LoganCapaldo> you need one of dem
16:01:04 <EvilTerran> ehird, it seems to me it'd be easier to do the parse without it, then reconstruct it afterwards
16:01:13 <glguy> Trinithis: a <|> b , if a doesn't consume any input, try parsing with b instead
16:01:22 <Trinithis> k
16:01:42 <ehird> EvilTerran: not easily possible
16:01:45 <ehird> this language is WEIRD
16:01:46 <ehird> :)
16:02:03 <ehird> (<<) a b = b >>= \x -> a >> x          -- this silly hack amuses me :-)
16:02:07 <ehird> or:
16:02:13 <EvilTerran> ehird, i see -- it's the return (Push exprs str,"("++str++")") line, isn't it?
16:02:14 <ehird> (<<) a b = do x <- a; b; return x
16:02:27 <ehird> EvilTerran: pretty much yeah. google 'Underload esolang'
16:02:28 <resiak> isn't that called <* in some library?
16:02:29 <ehird> or:
16:02:31 <resiak> @index <*
16:02:31 <lambdabot> bzzt
16:02:33 <ehird> esolangs.org/wiki/Underload
16:02:35 <resiak> @index (<*)
16:02:35 <lambdabot> bzzt
16:02:37 <EvilTerran> resiak, indeed, Control.Applicative
16:02:52 <faxathisia> a << b = b >>= \x -> a >> x -- can be written this way if you like
16:02:57 <resiak> yeah, it's pretty useful
16:03:09 <ehird> faxathisia: should be:
16:03:12 <EvilTerran> (<<) = liftM2 const
16:03:13 <EvilTerran> :)
16:03:14 <ehird> a >>= \x -> b >> x
16:03:21 <ehird> my definition was wrong
16:03:21 <ehird> :P
16:03:24 <EvilTerran> but don't call it <<, that's confusing.
16:03:30 <resiak> @ty ( a >>= \x -> b >> x)
16:03:31 <lambdabot> Not in scope: `a'
16:03:31 <lambdabot> Not in scope: `b'
16:03:38 <resiak> @ty (\ a b -> a >>= \x -> b >> x)
16:03:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m b) -> m a -> m b
16:03:46 <ehird> EvilTerran: well it's >> but... reversed
16:03:47 <ehird> :-P
16:03:54 <Trinithis> @pl (\ a b -> a >>= \x -> b >> x)
16:03:54 <lambdabot> (. (>>)) . (>>=)
16:03:56 <resiak> hmm, i'm misreading
16:03:57 <ehird> Instead of doing a, then b, then returning a:
16:04:04 <ehird> it does a, then b, then returns b -- wait no
16:04:06 <ehird> reverse that.
16:04:33 <EvilTerran> ehird, except it's not... (<<) should be to (>>) what (=<<) is to (>>=), IMO
16:04:57 <Trinithis> EvilTerran: it's not analogous?
16:05:02 <ehird> i guess
16:05:05 <faxathisia> :t (>>= >>=)
16:05:06 <lambdabot> parse error on input `>>='
16:05:12 <faxathisia> :t ((>>=) >>=)
16:05:13 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (((a -> m b) -> m b) -> m a -> b1) -> m a -> b1
16:05:15 <EvilTerran> Trinithis, no, with a =<< b, b is run before a
16:05:22 <EvilTerran> and with a << b, a is run before b
16:05:28 <Trinithis> hmm ok
16:05:40 <Trinithis> @src (<<)
16:05:40 <lambdabot> Source not found. Do you think like you type?
16:05:53 <glguy> << doesn't have a standard definition
16:06:03 <unenough> how do i tell lambdabot to join a channel?
16:06:09 <glguy> you don't
16:06:23 <unenough> ok.
16:06:24 <Cale> unenough: @join #foo
16:06:49 * glguy didn't know unenough was added as a lambdabot admin
16:06:55 <unenough> i wasn't
16:07:10 <Cale> That's how he'd do it if he was though.
16:07:20 <unenough> it was a theoretical question
16:07:26 <asdf> uhm what is != in haskell
16:07:32 <Cale>  /=
16:07:41 <Trinithis> unenough: you can have lambdabot in a private 1 to 1 channel though
16:07:46 <ehird> Hm. Can I have multiple clauses in a lambda expression?
16:07:52 <EvilTerran> glguy, but if it did, i imagine it'd be flip (>>), not liftM2 const
16:07:57 <unenough> yeah ok
16:08:02 <EvilTerran> ehird, no
16:08:06 <ehird> :(
16:08:10 <EvilTerran> use a where{} or something instead
16:08:19 <glguy> ehird: "multiple clauses?
16:08:19 <asdf> th
16:08:20 <asdf> x
16:08:41 <EvilTerran> or wait 'til haskellprime, when you might be able to write "case of Foo | bar -> ... | baz -> ...; Eek -> ...; ..."
16:08:54 <yoshi> does anyone have any good recommendations for a book about how category theory applies to Haskell?
16:08:56 <resiak> under what category should a libtracker (as in the desktop search tool) binding go?  Database ?
16:09:43 <Valodim> no
16:11:15 <hpaste>  LoganCapaldo annotated "(no title)" with "random chnage" at http://hpaste.org/5304#a1
16:11:40 <thoughtpolice> resiak: you could just put 'Desktop' in the cabal file, or perhaps put it in system or something like xmonad.
16:12:25 <Trinithis> does anyone know a small haskell compiler (for a flash drive)?
16:12:53 <ehird> EvilTerran: you suggested 'try' for the paren problem right?
16:12:56 <ehird> well, it doesn't work
16:12:57 <ehird> :-(
16:13:16 <thoughtpolice> Trinithis: nhc?
16:13:19 <resiak> thoughtpolice: good point
16:14:02 <EvilTerran> ehird, oh well
16:14:16 <ehird> EvilTerran: yeah. back to my drawing board!
16:14:30 <Trinithis> thoughtpolice: thx
16:15:53 <vincenz> Saizan: be nice if I ccould refer to your code :)
16:16:09 <vincenz> a nice little combinator
16:16:13 <TomMD> ?localtime hpaste
16:16:31 <vincenz> > let fixpoint f g x = map fst . dropWhile (not . uncurry g) . ap zip tail . iterate f $ x in let within eps x y = abs (x-y) < eps in fixpoint (\a -> 1 + 1/a) (within 0.00001)  1
16:16:33 <lambdabot>  [1.6180371352785146,1.618032786885246,1.618034447821682,1.6180338134001253,1...
16:17:29 <ddarius> TomMD: hpaste doesn't respond to CTCP requests...
16:17:43 <Trinithis> what is monomorphism restriction?
16:17:57 <ehird> > let ffixpoint f = i i where i = (\x -> f (x x)) in ffixpoint (\x -> x)
16:17:58 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
16:17:58 <lambdabot>     Probab...
16:17:59 <EvilTerran> ehird, "try (do char '('; ...; return (Push exprs str,"("++str++")"))" doesn't work?
16:18:01 <hpaste> Hack attempt thwarted!
16:18:03 <ehird> d'awww :)
16:18:05 <monochrom> When you write like "f = \x->x" it is not polymorphic.
16:18:20 <EvilTerran> (not sure if i successfully communicated what i meant before)
16:18:32 <gwern> hack attempt?
16:18:44 <ehird> EvilTerran: woot, it works -- now to deuglify
16:18:56 <EvilTerran> ehird, do you see why it works?
16:18:56 <monochrom> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:18:57 <lambdabot> Title: Monomorphism restriction - HaskellWiki
16:19:02 <ehird> EvilTerran: yep
16:19:10 <Trinithis> will read
16:19:17 <ehird> aha, i can do:
16:19:22 <ehird> quoted = ... foo with ( and ) ...
16:19:25 <ehird> and then just have a:
16:19:27 <ehird> <|> try quoted
16:19:40 <pjd> Trinithis: try let f = (+1); g x = x+1 in ghci
16:19:47 <EvilTerran> if you'd rather, yeah :)
16:19:53 <vincenz> Saizan: may I reproduce and quote?
16:19:53 <pjd> Trinithis: and look at the types
16:20:01 <Trinithis> sec
16:20:04 <Trinithis> loading ghci
16:20:24 <pjd> g has the general type (Num a) => a -> a, but f defaults to Integer -> Integer
16:20:40 <ehird> EvilTerran: oh
16:20:43 <ehird> except
16:20:47 <ehird> it complains that it's an unexpected (
16:20:50 <ehird> rather than an unexpected EOF
16:20:50 <ehird> :)
16:21:06 <Trinithis> pjd: huh. is this intentional?
16:21:22 <pjd> Trinithis: yes, for hysterical raisins
16:21:28 <TomMD> using haddock + cabal, how do I find out exactly what the issue is with a haddock markup? It is complaining about a fairly normal line (-- |Blah blah blah)
16:21:29 <stinger> haha
16:21:31 <EvilTerran> ehird, try (char '(' <?> "unbalanced '('") or something?
16:21:37 <pjd> Trinithis: you can turn it off with -fmonomorphism-restriction
16:21:46 <Trinithis> pjd: does it have practical use nowadays?
16:21:47 <pjd> err
16:21:55 <pjd> -fno-monomorphism-restriction
16:22:05 <ehird> EvilTerran: that's inconcsistent from the error reported by ) though
16:22:17 <ehird> and, well, other things
16:22:18 <pjd> Trinithis: well, it's mainly just an inconvenience
16:22:24 <Trinithis> hah
16:22:32 <EvilTerran> ehird, error messages from parsers is a Hard Problem
16:22:37 <ehird> EvilTerran: yep..
16:22:41 <pjd> Trinithis: you can still explicitly specify the type of f to be the same as you'll get with g
16:22:44 <ehird> i might write my own library ;)
16:22:47 <EvilTerran> ehird, fiddle with it 'til you like it, i don't know what you want
16:22:53 <ehird> ParserThatDoesWhatYouWantWithoutCrazyMunging
16:23:08 <Trinithis> pjd: you mean by something like - f :: (Num a) ...
16:23:16 <pjd> Trinithis: right
16:23:45 <ehird> EvilTerran: also: doesn't work.
16:23:45 <ehird> :)
16:23:52 <EvilTerran> okay then
16:23:56 <EvilTerran> it was just a thought
16:24:29 <pjd> Trinithis: the reasoning behind the restriction is along the lines of that it's unintuitive that f, a constant, takes a "hidden" instance parameter
16:25:03 <Trinithis> k
16:25:33 <pjd> Trinithis: but a fair number of people regard this to be a mistake, i think
16:25:45 <hpaste>  Pseudonym pasted "Enumerating tic-tac-toe" at http://hpaste.org/5305
16:26:08 <pjd> hence -fno-monomorphism-restriction (which you can put in your .ghci :)
16:26:10 <ehird> @src try
16:26:10 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
16:26:15 <Trinithis> pjd: well I like adding type sigs to my stuff anyway. so prolly not a problem for me
16:26:19 <ehird> beh, that's not Paresc's try
16:26:25 <Pseudonym> faxathisia: Want to check that?
16:26:29 <ehird> @src Text.ParserCombinator.Parsec.try
16:26:29 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:26:30 <Pseudonym> I can check your code if you like.
16:26:32 <ehird> @src Text.ParserCombinators.Parsec.try
16:26:32 <lambdabot> Source not found. I am sorry.
16:26:57 <pjd> Trinithis: okay, just be aware of it, if you don't disable it
16:27:28 <pjd> to know when you get overly specific types from ghci
16:27:44 <ehird> =|
16:27:45 <Trinithis> pjd: should a problem occur, is it fairly apparent or is it a subtle bug
16:27:54 <pjd> oh, you'll also sometimes see an error about being unable to determine a default instance
16:28:24 <pjd> Trinithis: dunno, depends
16:28:57 <Pseudonym> OK, my code is buggy.
16:29:23 <ehird> anyone?
16:29:48 <faxathisia> @hoogle try
16:29:48 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
16:29:48 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
16:29:48 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
16:29:58 <faxathisia> @src Text.ParserCombinators.Parsec.Prim.try
16:29:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:30:31 <faxathisia> I don't understand the board repesentation
16:30:35 <ddarius> lambdabot doesn't have Parsec's source
16:31:37 <Pseudonym> faxathisia: The cells are numbered 1 to 9.
16:31:45 <Pseudonym> The representation is two lists.
16:31:53 <Pseudonym> The cells containing xs and the cells containing os.
16:31:55 <faxathisia> ah, That makes sense
16:32:21 <Pseudonym> I fixed the bug and got 205.
16:32:40 <Pseudonym> Probably another bug, then.
16:33:46 <ehird> anyone?
16:33:58 <hpaste>  Pseudonym annotated "Enumerating tic-tac-toe" with "Fixing the draw bug" at http://hpaste.org/5305#a1
16:33:59 <Trinithis> anyone know sites that have haskell practice problems?
16:35:44 <Pseudonym> OK, I think there's another bug.
16:36:00 <MyCatVerbs> Trinithis: Project Euler might be a good idea, if you're of a mathematical bent.
16:36:19 <vincenz> Saizan: ping
16:36:24 <vincenz> @localtime Saizan
16:36:24 <lambdabot> Local time for Saizan is Tue Jan 29 01:37:12 2008
16:36:31 <vincenz> doh
16:36:32 <ehird> bleh
16:36:52 <Trinithis> MyCatVerbs: I'll look at it. To tell you the truth, I've never made a haskell program before 'cept a simple read in read out
16:37:18 <Botje> Trinithis: project euler is great for learning haskell
16:37:22 <Trinithis> ok
16:37:22 <Botje> it's how i got started :)
16:37:45 <Botje> if you're lucky the naive solutions are fast enough in haskell
16:37:47 <Trinithis> ill put a compiler on a flash drive and practice at school
16:37:51 <Botje> and some are _REALLY_ trivial
16:37:58 <Trinithis> cool
16:38:02 <Botje> like "get the last ten digits of (some big factorial)"
16:38:24 <pjd> Trinithis: the Haskell wikibook includes paced exercises
16:39:19 <Trinithis> Botje: pattern match up the wazzoo!
16:39:44 <pjd> Botje: (`mod` 10^10) !
16:39:58 <Pseudonym> OK, I now get 985 (or 1916)
16:40:38 <faxathisia> hmmmm
16:41:04 <Trinithis> @ty (`mod` 10^10) !
16:41:05 <lambdabot> parse error (possibly incorrect indentation)
16:41:16 <hpaste>  Pseudonym annotated "Enumerating tic-tac-toe" with "Debugging choose" at http://hpaste.org/5305#a2
16:41:22 <ehird> @ty "what the hell is @ty"
16:41:22 <lambdabot> [Char]
16:41:26 <ehird> oic
16:41:29 <Trinithis> lol
16:42:04 <Trinithis> :t == @ty, but the former doesnt work in a 1 on 1 with the bot
16:42:05 <lambdabot> parse error on input `=='
16:42:07 <ehird> @ty \x -> product [2..(x `mod` 10^10)]
16:42:08 <lambdabot> forall a. (Integral a) => a -> a
16:43:18 <ehird> So who here has crazy parsec-fu and knows about how to make an error be reported where the first character of a certain block is instead of at the EOF? :P
16:43:38 <Botje> @tie me up and fuck me gently with a chainsaw
16:43:38 <EvilTerran> ehird, well, try did that
16:43:42 <Trinithis> lol
16:43:44 <EvilTerran> Botje, ...
16:43:46 <EvilTerran> ?help tie
16:43:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:43:47 <Botje> boo :p
16:43:54 <ehird> EvilTerran: But... with the wrong error
16:43:55 <ehird> :P
16:43:57 <Botje> I thought it'd at least try to fuzzy-match
16:44:08 <EvilTerran> ehird, you should be able to set the error
16:44:25 <Trinithis> Botje: can you define @tie to \bot
16:44:33 <ehird> > tie me up and fuck my gently with a chainsaw where {chainsaw = 4; ...}
16:44:33 <lambdabot>  Parse error at "where" (column 46)
16:44:34 <Botje> hehe
16:44:42 <ehird> > (tie me up and fuck my gently with a chainsaw) where {chainsaw = 4; ...}
16:44:43 <lambdabot>  Parse error at "where" (column 48)
16:44:48 <ehird> lame
16:44:49 <Laney> Does GHC support cross compilation?
16:44:55 <ehird> EvilTerran: doesn't work properly
16:44:58 <EvilTerran> how about try (...) <|> fail "unmatched ')'" ?
16:45:07 <EvilTerran> er, "unmatched '('"
16:45:31 <Trinithis> well, cya lata
16:46:04 <ehird> EvilTerran: puts it after the error info
16:46:19 <EvilTerran> how do you mean?
16:46:23 <ehird> it goes
16:46:25 <ehird> unexpected "("
16:46:26 <ehird> BLAH BLAH
16:46:28 <ehird> unmatched '('
16:47:00 <EvilTerran> try (...) <?> "unmatched '('", perhaps?
16:47:10 <EvilTerran> or maybe try ((...) <?> "unmatched '('")?
16:48:00 <ehird> doesn't work because when it doesn't see the ) it gives up on the quoted oppertunity and looks for other possibilities
16:48:03 <EvilTerran> no, wait, that'll say "expected unmatched '('" or something silly like that
16:48:09 <ehird> finds none, so  says "LOL I DIDN'T GET THIS CHAR RITE: ("
16:49:50 <MyCatVerbs> Interesting. I add an Ord instance to one of my internal datatypes, use Data.List.sort on the list of incoming records as I read them from file, and suddenly my program's memory use has dropped by about a third.
16:50:10 <gwern> Laney: maybe if you went via gcc you could crssocompile
16:50:20 * MyCatVerbs gets the vague impression he must've just forced a *lot* of thunks at that step. >_>
16:50:36 <ehird> :|
16:51:19 <gwern> needs moar laziness
16:51:39 <ehird> MY PARSER NEEDS MORE LAZINESS in adding to its character count
16:52:33 <gwern> IMMAH FIRING MAH STRICTAHS
16:52:38 <ehird> hah
16:52:39 <geezusfreeek> needs more cowbell
16:52:49 <ehird> gwern: im in ur thunks, evaluating
16:52:54 <gwern> geezusfreeek: ur doing it wrong
16:53:06 <jfoutz> lolfun?
16:53:10 <gwern> ehird: i can has seq-sburger?
16:53:20 <ehird> im in ur lazy values,**Exception: stack overflow
16:53:20 <jfoutz> lolambda?
16:53:22 <geezusfreeek> oopz i not gud lolcat
16:53:29 <gwern> (bonus points for pronouncing seqs-burger mentally as 'sex-burger')
16:53:30 <ehird> i win
16:53:31 <jfoutz> not iz lolcode
16:53:31 <davidL> @where lambdacats
16:53:32 <lambdabot> http://arcanux.org/lambdacats.html
16:54:46 <jfoutz> that, is amazing.
16:54:48 <BMeph> I have a fever, and the only cure is:
16:54:53 <davidL> foldl sleep $ replicate 4 lolkitten
16:54:55 <Jiten> shachaf: unfold version of split seems to be slightly slower too. 8-16% difference. unfold version is pretty constant in speed but the other's performance is quite unstable.
16:54:55 <EvilTerran> ehird, part of the problem here, is we don't have enough of your source code to try things out outselves
16:54:56 <davidL> awesome.
16:55:06 <gwern> davidL: my favorite is the kant haskell one
16:55:06 <ehird> EvilTerran: would a full file be nice
16:55:07 <ehird> :)
16:55:47 <BMeph> More cowbell! ;)
16:55:47 <monochrom> BMeph has crashed due to the fever.
16:55:51 <ehird> @hpaste
16:55:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:55:52 <ehird> d'aww
16:55:53 <ehird> yay
16:55:57 <monochrom> Oh you haven't crashed. Good.
16:56:07 <hpaste>  ehird pasted "LOLPARSE" at http://hpaste.org/5306
16:56:22 <gwern> 'haskell cat has crashed. needs moar coffee!'
16:56:30 <davidL> my favorite is "flip concatMap"
16:56:40 <BMeph> I really DO have a fever, though. I'm still trying to convince my wife that I just need some cowbell... ;p
16:57:03 <gwern> BMeph: or mebbe a sammich. you or your wif :)
16:57:04 <jfoutz> KittehT is pretty awesome.
16:59:39 <ehird> so yeah.
16:59:51 <hpaste>  Pseudonym annotated "Enumerating tic-tac-toe" with "Final program" at http://hpaste.org/5305#a3
17:00:01 <ehird> Sample valid input if you need one:
17:00:02 <ehird> (:::::::):(:((^:()~((:)*~^)a~*^!!()~^))~*()~^^)~(^a(*~^)*a~*()~^!()~^)a~**^!!^S
17:00:31 * BMeph sees is Meredith Vierna will ask Pseudonym: "Is THIS your final answer?" ;p
17:00:44 <BMeph> s/is/if/
17:00:46 <Pseudonym> Who?
17:01:05 <faxathisia> That looks great
17:01:14 <BMeph>  ^^ ++ "Wants to Be a Millionaire"
17:01:32 <Pseudonym> Ah.  In Australia, that would be Eddie.
17:01:51 <Pseudonym> You don't need to qualify it.  Everyone knows who you mean by "Eddie", because he's on pretty much every TV show on the network.
17:02:09 <BMeph> Just "Eddie"? Wow, it must be really popular, then.
17:02:11 <TomMD> Sounds dull.
17:02:15 <Pseudonym> No, not popular.
17:02:20 <Pseudonym> Just common.
17:02:27 <Pseudonym> Over-exposed, you might say.
17:03:04 <Cale> http://en.wikipedia.org/wiki/Eddie_McGuire
17:03:10 <lambdabot> Title: Eddie McGuire - Wikipedia, the free encyclopedia
17:03:16 <stinger> well known != popular
17:03:23 <stinger> wait this is haskell /=
17:03:53 <ddarius> @let (!=) = (/=)
17:03:54 <lambdabot> <local>:2:7:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
17:04:09 <ddarius> Stupid monomorphism restriction.
17:04:10 <Cale> haha, MR
17:04:18 <ddarius> @undefine
17:04:20 <lambdabot> Undefined.
17:04:37 <ehird> monomorphism restriction is amusing
17:04:43 <ehird> @let (!=) x y = x /= y
17:04:44 <lambdabot> Defined.
17:05:00 <ddarius> You can say x != y = x /= y
17:05:02 <ehird> @let ! = not
17:05:02 <lambdabot>  Parse error
17:05:11 <ehird> ddarius: Yeah. But that confuses my eyes with the =s
17:05:18 <stinger> heheh yeah
17:05:19 <ehird> @let ! x = not x
17:05:20 <lambdabot>  Parse error
17:05:22 <ehird> d'aww
17:05:22 <ehird> :)
17:05:26 <stinger> you CAN say that, if you want to break my brain
17:05:27 <ehird> @let (!) x = not x
17:05:29 <lambdabot> Defined.
17:05:32 <ehird> woot
17:05:34 <ehird> > ! True
17:05:34 <lambdabot>   parse error on input `!'
17:05:38 <ehird> > (!) True
17:05:41 <ehird> bah
17:05:42 <mauke> > (True!)
17:05:43 <lambdabot> Terminated
17:05:43 <lambdabot> Terminated
17:05:49 <ehird> what's the symbol for not?
17:05:50 <ehird> unicode
17:05:51 <ehird> :)
17:05:52 <ddarius> :t (!)
17:05:53 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
17:05:57 <EvilTerran> :t not
17:05:58 <mauke> heh
17:05:58 <lambdabot> Bool -> Bool
17:06:10 <ehird> noboody? :(
17:06:19 <EvilTerran> ?src not
17:06:19 <lambdabot> not True   =  False
17:06:19 <lambdabot> not False  =  True
17:06:27 <ehird> ...
17:06:32 <ehird> I meant the symbol for it.
17:06:35 <EvilTerran> 
17:06:35 <pjd> ehird: 
17:06:36 <ddarius> 
17:06:38 <ehird> hah
17:06:44 <ehird> @let ? = not
17:06:44 <lambdabot>  Parse error
17:06:45 <EvilTerran> @vixen 
17:06:46 <lambdabot> eh?
17:06:48 <Cale> 
17:06:49 <ehird> @let ? x = not x
17:06:49 <lambdabot>  Parse error
17:06:52 <ehird> eh phooey
17:06:56 <Cale> _
17:06:57 <ehird> that should so be valid :|
17:06:59 <pjd> ehird: that's showing up as ? here
17:07:00 <mauke> ehird: there are no unary operators
17:07:02 <EvilTerran> ehird, it's appearing as ? here. check your encoding.
17:07:09 <ehird> hm
17:07:12 <ehird> i'm using xchat aqua
17:07:17 * ehird ownders where it stores encoding
17:07:25 <zygen> @let  x = not x
17:07:26 <lambdabot>  Illegal character ''\172''
17:07:36 <pjd> ehird: should be a per-network setting
17:07:40 <Cale> ehird: Network list -> Edit the network
17:07:45 <BMeph> @let () = not
17:07:46 <lambdabot>  Illegal character ''\172''
17:07:47 <ddarius> lambdabot doesn't do Unicode
17:08:06 <monochrom> Sorry, no unary operator support in Haskell other than alphanumeric names.
17:08:07 <ehird> ?
17:08:21 <zygen> well, functions with one argument aren't unary ops
17:09:02 <pjd> 
17:09:12 <monochrom> @let x  y = x && y in True  False
17:09:12 <lambdabot>  Illegal character ''\172''
17:09:16 <monochrom> >let x  y = x && y in True  False
17:09:20 <monochrom> > let x  y = x && y in True  False
17:09:20 <lambdabot>  Illegal character ''\172''
17:09:20 <lambdabot>  at "" (column 8)
17:09:31 <monochrom> Oh haha
17:09:43 <monochrom> > let x  y = x && y in True  False
17:09:43 <lambdabot>  Illegal character ''\136''
17:09:44 <lambdabot>  at "" (column 8)
17:09:47 <ehird> what's the unicode arrow symbol?
17:09:51 <monochrom> OK, I don't know.
17:09:55 <pjd> ehird: there are a bunch
17:10:02 <monochrom> 
17:10:02 <pjd>  ?
17:10:05 <ehird> yes
17:10:09 <ehird> now unicode lambda symbol? :P
17:10:14 <pjd> also 
17:10:19 <monochrom> 
17:10:21 <ehird> ooh:
17:10:27 <ehird> > let () x y = x >> y
17:10:27 <lambdabot>  Illegal character ''\135''
17:10:28 <lambdabot>  at ")" (column 7)
17:10:29 <pjd> 
17:10:30 <ehird> bah
17:10:41 <ehird> ok, now as soon as we find out how to add syntax
17:10:43 <ehird> we can have:
17:10:47 <davidL> what do you type in emacs to get the table of unicode chars? :P
17:10:51 <ehird> x  x+2
17:10:56 <ehird> prettyyyyyyyy
17:11:07 <stepcut> prett
17:11:11 <ehird> i hope haskell2 is like that
17:11:25 <Corun> They need to go up the haskell version numbers faster
17:11:26 <ehird> and we get a haskell2-mode which lets us type in \x -> x+2 and get x  x+2 in the file
17:11:28 <monochrom> -XUnicodeSyntax
17:11:29 <Corun> We need HaskellX
17:11:34 <Jiten> as long as you have some reasonable way of typing all those characters
17:11:42 <ehird> it would be almost as beautiful as apl
17:11:46 <ehird> Jiten: yes, emacs!
17:11:46 <stepcut> ehird: you can already do that second part
17:11:54 <stepcut> ehird: one momment
17:11:56 <ehird> stepcut: yes, but ghc won't like it ;)
17:11:57 <ehird> also
17:12:00 <ehird> i meant actually in the file
17:12:01 <monochrom> -XUnicodeSyntax
17:12:03 <ehird> not just displayed like that
17:12:07 <davidL> http://mult.ifario.us/p/emacs-haskell-mode-unicode-cuteness
17:12:08 <ehird> monochrom: 1. does that actually work
17:12:08 <lambdabot> Title: emacs-haskell-mode-unicode-cuteness
17:12:11 <ehird> 2. it should so be a default
17:12:13 <ehird> :D
17:12:21 <ehird> EVERYBODY should write unicode haskell!
17:12:23 <monochrom> I haven't tried. It's kind of undocumented.
17:12:31 <ehird> > :set -XUnicodeSyntax
17:12:32 <ehird> unrecognised flags: -XUnicodeSyntax
17:12:32 <lambdabot>   parse error on input `:'
17:12:34 <stepcut> ehird: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
17:12:35 <lambdabot> Title: EmacsWiki: Pretty Lambda
17:12:39 <ehird> stepcut: please read what i said
17:13:11 <Jiten> 
17:13:29 <stepcut> ehird: meh
17:13:46 <monochrom> ghci -XUnicodeSyntax  works for me. 6.8.2
17:13:57 <ehird> also, we'd have the best proportional font ever and haskell indentation would be all with a single tab which editors would interpret structurally and alignment ditto so there is no need for fixed with fonts
17:14:01 <ehird> and we'll all dance in happy happy fun land
17:14:12 <monochrom> Inside, I enter :type xx+1  and it also works.
17:14:17 <monochrom> err
17:14:21 <monochrom> Inside, I enter :type \xx+1  and it also works.
17:14:41 <ehird> someone show me some ugly haskell with a lot of symbols
17:14:41 <ehird> :P
17:14:45 <davidL> how do we know which unicode works and which does not work?
17:14:58 <monochrom> Do not expect \ to be replacible by . The latter is emphatically a letter, for identifier names.
17:15:10 * ddarius prefers simple things.
17:15:12 <monochrom> Well that's the problem, it's undocumented.
17:15:14 <ehird> monochrom: what, that sucks ;)
17:15:20 <gwern> ehird: prettylambda is obviated by haskell-mode's unicode-syntax. the latter subsumes the unicode of the former
17:15:31 <gwern> it's only useful for other modes, like lisp
17:15:34 <ehird> ddarius: unicode would be simple if unix wasn't designed under ASCII
17:15:35 <ehird> :)
17:15:41 <ehird> and ditto with editors and monospaced fonts!
17:16:07 <faxathisia> ehird, Look at Agda2 code
17:16:21 <faxathisia> There is heavy use of Unicode, combined with mixfix
17:17:04 <ehird> meh
17:17:05 <ehird> :)
17:17:10 <gwern> 'The second version of Agda, Agda 2, is currently being developed at Chalmers by Ulf Norell. The syntax has completely changed from Agda 1 (though some conversion tools are being developed as well), introducing for instance implicit variables, that can be omitted when deduceable from the context. Agda 2 also makes an intensive use of Unicode as a way to obtain easily-readable proofs.'
17:17:25 <monochrom> In GHC user guide, you will find -XUnicodeSyntax in the Flag Reference master table, but you will not find any section saying more.
17:18:05 <ehird> @hpaste
17:18:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:18:10 * monochrom loves the old days of Undocumented DOS System Calls.
17:18:23 <hpaste>  ehird pasted "pretty unicode haskell" at http://hpaste.org/5307
17:18:26 <ehird> uh
17:18:28 <ehird> hpaste is borked
17:18:29 <ehird> :)
17:18:48 <monochrom> Yeah, hehe.
17:18:49 <ivanm> yes, that doesn't look like unicode at all...
17:18:59 <ehird> http://hpaste.org/5307/0/plain this works
17:18:59 <ehird> :P
17:19:03 <monochrom> Note: If you put it inside comments, it works!
17:19:13 <ehird> wait, let me add <br>s
17:19:15 <ehird> so the plain view works
17:19:15 <ehird> :P
17:19:27 <gwern> I'm always amazed at how firefox can't display it normally, but open up the annotate box...
17:19:32 <hpaste>  ehird annotated "pretty unicode haskell" with "hah" at http://hpaste.org/5307#a1
17:19:39 <ehird> http://hpaste.org/5307/1/plain there you go!!!!
17:19:42 <monochrom> Also try http://hpaste.org/annotate/5307?oldId=0
17:20:22 <davidL> ehird: nice
17:20:23 <ehird> i would love to see haskell like that
17:20:25 <hpaste>  monochrom annotated "pretty unicode haskell" with "heh" at http://hpaste.org/5307#a2
17:20:27 <ivanm> ehird: doesn't look any better to me, just has <pre>'s around it
17:20:30 <ehird> finally, copying and pasting text from papers about haskell would work! ;)
17:20:33 <ehird> ivanm: click 'raw'
17:20:38 <ivanm> ahhh
17:20:55 <monochrom> How you do copy and paste from paper to computer???
17:21:01 <ehird> monochrom: rofl
17:21:03 <mauke> scanner
17:21:10 <kmcallister> glue
17:21:10 <ehird> + unicode OCR!
17:21:17 <ehird> kmcallister: hahahahah
17:21:20 <kmcallister> but then your monitor gets all sticky
17:22:11 <ehird> i might make a silly programming language with insane use of unicode, and an editor that makes writing it easy
17:22:13 <ehird> for no reason
17:22:23 <wagle> apl!
17:22:47 <gwern> I'll go you one better. I'm gonna make my own unicode language, and it'll have beer, and strippers, and blackjack
17:22:54 <gwern> in fact, forget the blackjack!
17:22:56 * faxathisia likes Djkstras language
17:23:05 <ivanm> gwern: heh
17:23:18 * ivanm takes gwern's blackjack
17:23:25 <ehird> wagle: well yeah but...editable
17:23:27 <faxathisia> It uses 2 unicode chars
17:23:56 <ehird> faxathisia: no
17:24:01 <ehird> the entire apl set is in unicode, nowadays
17:24:16 <faxathisia> What
17:24:22 <faxathisia> I'm not talking about APL
17:24:53 <ehird> what then
17:25:00 <gwern> J?
17:25:02 <gwern> K?
17:25:19 <gwern> (who knows, maybe there's an apl spin off L)
17:25:46 <ehird> clearly, Z will be the ultimate array programming language
17:26:06 <ehird> or maybe it'll wrap around to A, but people don't like the look of A so they say 'A programming language' and abbreviate it to APL
17:26:08 <gwern> no, Z is already taken
17:26:17 <ivanm> so is J, is it not?
17:26:23 <lucca> and K
17:26:31 <monochrom> if  x0  x:=1  x0  x:=-1 fi
17:26:52 <faxathisia> yeah, :D
17:26:59 <dejones> faxathisia: what is Dijkstra's language?
17:27:03 <gwern> monochrom: you make the baby Space-us cry :(
17:27:10 <faxathisia> dejones, Right there
17:27:27 <faxathisia> dejones, It's from A Discipline of Programming
17:27:38 <wolverian> monochrom, hm, I see some boxes. one after the 'if'. what character is that?
17:27:44 <faxathisia> It's non deterministic
17:27:47 <ivanm> wolverian: new lines, AFAIK
17:27:53 <wolverian> ah, duh. thanks
17:27:54 <EvilTerran> not newlines, no
17:28:05 <EvilTerran> it's meant to look like an empty box
17:28:07 <EvilTerran> []
17:28:11 <ivanm> ahhh
17:28:18 <wolverian> oh, so I see it correctly. heh.
17:28:28 <ehird> ugly heh ;)
17:28:41 <faxathisia> ehird, No
17:28:43 <monochrom> Perhaps the first box shouldn't be there.
17:28:48 <ivanm> yes
17:28:49 <monochrom> if x0  x:=1  x0  x:=-1 fi
17:28:50 <wolverian> ehird, Z wraps around to AA, not A!
17:28:55 <faxathisia> That's better
17:29:05 <faxathisia> if and fi would be bold
17:29:18 <wolverian> (perl -le'my $x = "z"; print ++$x')
17:29:53 <ddarius> Guarded command language
17:30:06 <wolverian> monochrom, isn't there a character for :=?
17:30:13 <EvilTerran> there is
17:30:20 <EvilTerran> "assign" or something
17:31:06 <EvilTerran> well, "MATHEMATICS NOTATION ASSIGNMENT OPERATOR" or something. the uniconsortium like their long names. ;)
17:31:52 <hpaste>  ehird pasted "test" at http://hpaste.org/5308
17:32:02 <ehird> http://hpaste.org/5308/0/plain
17:32:04 <EvilTerran> wow, that's a mess.
17:32:13 <EvilTerran> but that works
17:32:14 <ehird> what is
17:32:17 <ehird> D
17:32:17 <ehird> :D
17:32:22 <ehird> hm
17:32:23 <gwern> 'Abelson and Sussman (1985 "SICP", pp 242-292), in their wonderful early book on Scheme, have a large section on streams, much of it general and independent of any implementation. But they also give a particular implementation which uses two functions, delay and force. The delay funnction creates a thunk, a parameterless lambda expression, which can be evaluated by the force function. (Folklore has it that the name "thunk" derives from the noise when ...
17:32:24 <ehird> need a <br>
17:32:29 <gwern> ... such a beast is dropped onto the runtime stack.)'
17:32:39 <gwern> cute highlighting
17:32:55 <EvilTerran> ehird, this is surprising, seeing as i'd've expected hpaste.org to yield the raw pastes with a text/plain mimetype
17:32:58 <monochrom> if x0  x1  x0  x-1 fi
17:33:11 <hpaste>  ehird annotated "test" with "update" at http://hpaste.org/5308#a1
17:33:18 <ehird> hm, damn
17:33:22 <ehird> EvilTerran: yep
17:33:26 <EvilTerran> @seen dons
17:33:27 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 49m 33s ago.
17:33:37 <EvilTerran> er, wrong one. sorry dons.
17:33:40 <hpaste>  ehird annotated "test" with "should work" at http://hpaste.org/5308#a2
17:33:42 <EvilTerran> @seen glguy
17:33:42 <lambdabot> I saw glguy leaving #haskell 44m 41s ago, and .
17:33:47 <EvilTerran> hm.
17:33:48 <ehird> http://hpaste.org/5308/2/plain there we go
17:33:55 <EvilTerran> (i mis-remembered who runs hpaste)
17:34:16 <ehird> that's what haskell should look like
17:34:20 <ehird> but with less indent on the case
17:34:23 <EvilTerran> @tell glguy this smells of XSS vulnerability to me: http://hpaste.org/5308
17:34:24 <lambdabot> Consider it noted.
17:34:26 <ehird> or maybe that's fine
17:34:27 <ehird> :P
17:34:46 <ehird> hm
17:34:52 <ehird> with the arrows aligned, though
17:35:07 <ehird> but yeah: nice serif font, unicode symbols, nice highlighting
17:35:22 <EvilTerran> ehird, on you go, then
17:35:26 <monochrom> and a weakest precondition predicate transformer semantics.
17:35:27 <ehird> if only computers had involved simply ;)
17:35:31 <ehird> EvilTerran: ?
17:35:38 <EvilTerran> i'll expect a working prototype by the end of the week.
17:35:43 <ehird> haha
17:35:46 <ehird> well, i'm tempted, sure..
17:35:58 * faxathisia spent a day getting emacs to look like lhs2TeX
17:35:59 <ehird> but i wouldn't build it on top of emacs, 'cause i'm annoying like that
17:36:03 <monochrom> Put in on my desk next Monday morning
17:36:03 <EvilTerran> monochrom, does that even make sense for functional languages?
17:36:13 <ehird> I'd probably do something stupid, like have a 'unihs2hs'
17:36:17 <ehird> which converted it all.
17:36:19 <ivanm> faxathisia: I tried that, started ruining my code :s
17:36:39 <monochrom> functional languages enjoy something simpler.
17:36:39 <EvilTerran> monochrom, eh, i guess it does. WP on the arguments.
17:36:52 <EvilTerran> monochrom, actually, that sounds like what ndm's catch does.
17:39:51 <monochrom> weakest precondition buys you two things. you can draw a line between success and everything else (error, undefined, infinite loop). you can have non-determinism. In fact you can have two-player non-determinism.
17:40:40 <monochrom> functional programming usually eliminates non-determinism, so the second benefit isn't needed. of course, it doesn't hurt either.
17:41:48 <monochrom> But an assumption is each program/function is first-order.
17:42:24 <monochrom> David Naumann knows how to extend it to higher-order programming (e.g., map). But it gets very complicated.
17:44:10 <EvilTerran> @where catch
17:44:10 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
17:44:21 <EvilTerran> (wondering if it detects divergence, or just fail - i forget)
17:44:39 <EvilTerran> *potential divergence
17:49:17 <lispy> ?seen ndm
17:49:18 <lambdabot> I haven't seen ndm.
17:49:23 <lispy> lambdabot: yes you have
17:50:56 <TomMD> yeah, lambdabot has been slipping lately, it didn't even want to tell me unsafeperformio.org when I asked it about Gill.
17:51:56 <ddarius> She's getting senile in her years.
17:52:44 <TomMD> Poor old gal, we'll have to put her down.  How well has she trained Infinity?
17:53:08 <lispy> ?vixen can you hear me?
17:53:09 <lambdabot> i sure can
17:53:17 <lispy> hearing is still good at least :)
17:53:21 <TomMD> ?src unsafePerformIO
17:53:21 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
17:53:50 <TomMD> wow, I can't read that very well.
17:54:39 <TomMD> ?src lazy
17:54:39 <lambdabot> Source not found. My pet ferret can type better than you!
18:04:36 * edwinb tries to work out where unsafeCoerce# is hiding these days
18:05:05 <ddarius> @hoogle unsafeCoerce
18:05:07 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
18:05:15 <edwinb> alas, my ghc is a bit old
18:05:20 <edwinb> I'm on 6.6.1
18:05:43 <ddarius> I think it is in System.Unsafe, but I could easily be wrong
18:05:51 <edwinb> perhaps 2am isn't the time to do hairy things with evil coercions  anyway ;)
18:06:19 <sw17ch> is there a good example of how to use Data.Hashtable?
18:06:27 <sw17ch> err... Data.HashTable
18:06:27 <ddarius> Don't.
18:06:36 <sw17ch> ah,  i was expecting that answer :)
18:06:57 <sw17ch> is there something better to use?
18:07:03 <ddarius> Data.Mapy
18:07:07 <ddarius> -y
18:07:19 <sw17ch> major difference?
18:07:54 <edwinb> aha, GHC.Prim apparently
18:08:01 <ddarius> The constant factors in Data.HashTable are worse than the logarithmic factors in Data.Map so Data.Map is pure, convenient and faster.
18:08:13 <sw17ch> well, excellent
18:08:15 <sw17ch> ty
18:09:04 <sw17ch> ddarius++
18:09:18 <LoganCapaldo> Data.Map :: * -> * -> Pure Win
18:09:39 <ddarius> It's just that Data.HashTable is ridiculous and poorly implemented.
18:09:59 <EvilTerran> @djinn-env
18:10:00 <lambdabot> data () = ()
18:10:00 <lambdabot> data Either a b = Left a | Right b
18:10:00 <lambdabot> data Maybe a = Nothing | Just a
18:10:00 <lambdabot> data Bool = False | True
18:10:00 <lambdabot> data Void
18:10:00 <sw17ch> it didn't seem to be all that great to me either... but i'm still too new to this stuff to critique it
18:10:01 <lambdabot> type Not x = x -> Void
18:10:04 <lambdabot> class Eq a where (==) :: a -> a -> Bool
18:10:35 <cjb> Does GHC, at the time it enters a thunk in a pure function, know what the next thunk it's going to enter is?
18:11:01 <ddarius> Why would it?
18:11:32 <cjb> I'm not sure.  It's not a trick question; I'm trying to get a mental model for how much is known about pure functions ahead of time.
18:11:50 <cjb> I don't mean the contents of the next thunk, by the way, I mean it's allocated address.
18:11:51 <ddarius> The code GHC generates just executes.
18:12:12 <cjb> Oh, that's true.  Sorry, I see I'm fairly confused.
18:12:21 <cjb> Thanks, that clears it up.
18:21:01 * EvilTerran is thinking about djinn
18:21:06 <EvilTerran> damnit, i need a whiteboard
18:21:55 <LoganCapaldo> whiteboards rule
18:22:02 <keseldude> +1
18:22:04 * LoganCapaldo has a whiteboard in his cube
18:22:06 <ddarius> Neither EvilTerran nor LoganCapaldo are mathematicians.
18:22:13 * ddarius has two.
18:22:16 <LoganCapaldo> this is true
18:22:19 <vincenz> EvilTerran: http://www.imaginationcubed.com/LaunchPage
18:22:20 <lambdabot> Title: Imagination Cubed
18:22:23 <lispy> I had a whiteboard at home but i donated to my office at work where I can use it there :)
18:22:37 <EvilTerran> ddarius, indeed not. if anything, i'm a computer scientist
18:22:39 <vincenz> we have a ton of whiteboards at work
18:22:40 <vincenz> even stickon
18:22:58 <EvilTerran> although proto-compsci would be more accurate
18:23:08 <glen_quagmire> i dont have flash plugin
18:23:11 <EvilTerran> pre-compsci? whatever. i dunno.
18:24:30 <ddarius> Lucky you glen_quagmire
18:24:47 <glen_quagmire> i mean, they don't have 64bit flashplayer
18:24:52 <ddarius> Lucky you glen_quagmire
18:24:54 * BMeph goes back to reading Oleg's OS paper
18:27:24 <glen_quagmire> yay lucky me!
18:27:46 <Axioplase> glen_quagmire: I don't have flash on my 32bit FreeBSD, not on my NetBSD macs...
18:27:48 * LoganCapaldo is probbaly a programmer mostly, and only a hobbyist computer scientist
18:27:58 <Axioplase> Luckily, mplayer and xine plays youtbe videos ^^
18:28:38 <glen_quagmire> i am a comedian mostly
18:28:44 <glen_quagmire> on irc i mean
18:29:14 <glen_quagmire> > mplayer "http://youtube.com/?hoaiwfe0aucjaotnvskjho34"
18:29:15 <lambdabot>   Not in scope: `mplayer'
18:31:17 <LoganCapaldo> it woudn't let you run mplayer anyway
18:31:22 <LoganCapaldo> it's certainly in IO
18:34:27 <chessguy> not a valid youtube address anyway
18:44:12 <ddarius> Doron is entertaining
18:45:19 <LoganCapaldo> Doron>
18:45:20 <LoganCapaldo> ?
18:47:21 <ddarius> Doron Zeilberg
18:47:44 <psykotic> zeilberger
18:48:00 <psykotic> he's slightly screwry
18:49:14 <EvilTerran> is there a generally accepted symbol for "is a member of the domain of"?
18:49:46 <dmwit> Usually if you want that, you have named the domain already.
18:49:58 <EvilTerran> eh
18:50:03 <dmwit> i.e. by saying f : A -> B or so.
18:50:59 <dons> ?users
18:51:00 <lambdabot> Maximum users seen in #haskell: 463, currently: 426 (92.0%), active: 17 (4.0%)
18:51:02 <ddarius> 
18:51:05 <dons> oh, new high score :)
18:51:13 <EvilTerran> i mean in terms of partial maps and whatnot
18:51:25 <EvilTerran> maybe i don't mean domain, but you get the idea
18:51:52 <ddarius> I don't know what you are trying to say.
18:52:15 <ddarius> x  dom(f) ?
18:52:42 <EvilTerran> if you've got a partial function, f \subseq A -> B
18:52:49 <ddarius> supp
18:52:50 <ddarius> then
18:52:59 <EvilTerran> and you want to say "f actually maps x to something successfully"
18:53:05 <EvilTerran> supp?
18:53:21 <ddarius> Often the term "support" is used for the subset of the domain that is "total"
18:53:33 <dmwit> x \in f^{-1}(B) might work
18:53:53 <EvilTerran> okay... i'll just make a nice infix operator up, then.
18:54:12 <dmwit> (for a suitable definition of f^{-1})
18:58:15 <ddarius> "In fact, they should only do it in base 2, but again, without using zero."
18:58:44 <dronee> i want to learn
18:59:55 <dmwit> dronee: Do you want some tips on tutorials?
19:00:01 <dronee> yes
19:00:02 <dronee> plz
19:00:05 <dronee> :)
19:00:10 <dmwit> ?where yaht
19:00:11 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:00:15 <dmwit> ?where gentle
19:00:15 <lambdabot> http://www.haskell.org/tutorial/
19:00:47 <dronee> thanks
19:00:51 <dmwit> Although consider yourself forewarned: The Gentle Introduction is not all that gentle for people new to functional programming.
19:00:53 <kmcallister> in computability you sometimes see f(x) \downarrow y for f(x)=y and f(x) \uparrow for x not in f's domain
19:02:03 <ddarius> kmcallister: Indeed.
19:02:15 <ddarius> kmcallister: Still not "standard" though.
19:03:08 <BMeph> I want tutorial tips. ddarius: Got any recommendations for acquiring adjoint functor fu? ;)
19:03:35 <kmcallister> ddarius, yeah, i think there is no standard
19:03:49 <radix> I strongly recommend SLPJ's introduction from OSCON. It's a 3 hour tutorial on video
19:03:52 <ddarius> BMeph: What do you know?
19:04:05 <dronee> is haskell a programation language?
19:04:19 <kmcallister> yes
19:04:32 <kmcallister> unless that means something other than "programming language"
19:04:44 <dronee>  aha
19:05:00 <dronee> and waht can we build with it?
19:05:07 <kmcallister> dronee, anything
19:05:15 <dronee> a short exemple
19:05:17 <dronee> plz
19:05:32 <kmcallister> @where quicksort
19:05:32 <lambdabot> I know nothing about quicksort.
19:05:35 <BMeph> ddarius: Almost nothing. I know that they come in left and right, depending on which side of the object whichever one goes on to be associated with the other...
19:05:40 <kmcallister> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
19:05:42 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/eogyw
19:05:43 <dmwit> GHC, darcs, xmonad...
19:05:47 <BMeph> Like I said, almost nothing. :)
19:06:03 <ddarius> BMeph: I meant, what other math, computer science, category theory do you know?  What is your background?
19:06:03 <dmwit> (@dronee)
19:06:11 <kmcallister> dronee, that gives a 2-line quicksort implementation in haskell
19:06:21 <dronee> ok
19:06:22 <BMeph> ?faq Can Haskell solve the Energy Crisis?
19:06:22 <lambdabot> The answer is: Yes! Haskell can do that.
19:06:24 <dronee> thanks
19:06:32 <davidL> haha
19:06:58 <kmcallister> @where+ quicksort http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
19:06:58 <lambdabot> Nice!
19:07:36 * ddarius wonders what a sort looks like in sortle.
19:08:08 <kmcallister> dronee, i also recommend http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html for learning, scroll down and you will find lecture notes and labs (1-3 are particularly good, 4-5 are okay)
19:08:10 <lambdabot> Title: CS 11: Haskell track, http://tinyurl.com/3y5tud
19:08:13 <wagle> OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I?
19:08:30 <BMeph> ddarius: Stopped formal math training with vector calc and linear algebra - I have a Computer Engineering/Software Engineering background.
19:08:42 <radix> wagle: yes - I always lose the URL that has a link to both parts of the video and the slides
19:09:12 <radix> I guess this works: http://lambda-the-ultimate.org/node/2427
19:09:12 <lambdabot> Title: Simon Peyton-Jones Haskell Video | Lambda the Ultimate
19:12:27 <wagle> kmcallister, oooo  contains macros
19:13:24 <ddarius> BMeph: This is an excellent and applicable introduction geared at computer scientisty sorts: http://www.let.uu.nl/esslli/Courses/barr-wells.html
19:13:27 <lambdabot> Title: Courses: Barr / Wells
19:13:32 <byte-> hello
19:14:00 <dmwit> Hiya, byte-!
19:14:34 <byte-> dmwit, are you always this enthusiastic, or are you just a laggy bot?
19:14:44 * byte- pokes dmwit 
19:14:48 <dmwit> byte-: heh, very funny
19:14:55 * dmwit pukes on byte-
19:15:08 <byte-> anywhoo
19:15:16 <ddarius> byte- hasn't been exposed to the Haskell community before has he
19:15:31 <byte-> ddarius, I usually just shrug it off.
19:15:34 <pjd> kmcallister: that's not a quicksort; it's a deforested tree sort
19:15:39 <byte-> I guess I'm in a curious mood today.
19:16:02 <ddarius> That's no moon ... !
19:16:03 <byte-> so what do you guys think about concatenative PLs?
19:16:17 <dmwit> I approve.
19:16:23 <bparkis> i know what they are but what is their purpose?
19:16:27 <pjd> kmcallister: http://reddit.com/r/programming/info/2h0j2/comments/c2h196
19:16:29 <ddarius> Slava Pestov hangs around here regularly
19:16:35 <byte-> bparkis, for programming?
19:16:46 <bparkis> what is the purpose of a PL being concatenative
19:16:50 <byte-> ddarius, he's the creator of...factor?
19:16:55 <bparkis> it seems at first glance to be a somewhat arbitrary property
19:16:59 <byte-> or was it joy...
19:17:01 <BMeph>  ddarius: Thank you, it looks like a good start. :)  ddarius++
19:17:16 <byte-> bparkis, routines tend to be shorter
19:17:19 <byte-> excluding other factors
19:17:23 <bparkis> why?
19:17:28 <ddarius> byte-: Yes, he is.
19:17:38 <ddarius> factor
19:17:48 <byte-> the main form of storage is on an invisible stack
19:17:56 <byte-> hence, you generally don't see variable references.
19:18:07 <pjd> bparkis: the important property is that you can concatenate any two bits of code to form their composition
19:18:18 <bparkis> yes i knew that pjd
19:18:31 <byte-> it's sort of like PL haskell...but not as confusing
19:18:45 <bparkis> so a concatenative language encourages points free style byte- ?
19:18:47 <ddarius> byte-: Do you know something about Backus' FP?
19:18:55 <byte-> ddarius, nope
19:19:03 <kmcallister> pjd, interesting
19:19:04 <byte-> ddarius, all I know is that I wouldn't want to have been given that name.
19:19:23 <byte-> bparkis, I guess you could say that.
19:19:52 <byte-> except the "encourages" part is generally "requires."
19:20:01 <ddarius> http://www.stanford.edu/class/cs242/readings/backus.pdf
19:20:13 <pjd> kmcallister: the "signature" of quicksort is the traversal from both ends, to find two elements to swap
19:20:23 <byte-> for example, (x^2 + y^2)^0.5 in a concatenative language might look like
19:20:26 <ddarius> byte-: Many concatenative languages do support a variable binding form (Joy is an exception)
19:20:44 <byte-> ddarius, I know, but I don't know of any that let you use named parameters.
19:21:04 <byte-> or, more appropriately, named stack positions.
19:21:31 <dolio> I think Cat does, or at least its creator was thinking of it.
19:21:33 <pjd> kmcallister: that linked article (http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html) demonstrates a "true" quicksort in Haskell
19:21:34 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
19:21:34 <byte-> 2 ^ swap 2 ^ + 0.5 ^
19:21:44 <kmcallister> yeah
19:22:22 <kmcallister> although that's not nearly as pretty as the deforested tree sort
19:22:29 <pjd> byte-: most of them probably do, but it's not generally encouraged
19:22:33 <kmcallister> and not very "haskelly"
19:22:50 <byte-> (also, you can do nifty things like this in stack-based languages: (2 ^) 2i + 0.5 ^
19:22:55 <bparkis> can you simulate variables in a stack-based language with no variable support?
19:23:01 <byte-> not sure if ^ is the 'to the power of' operator in joy, but whatever.
19:23:11 <pjd> kmcallister: yeah, he purposefully wrote it in his "embedded C" dialect
19:23:13 <byte-> that does the same as the other code I listed.
19:23:19 <byte-> s:same:same thing:
19:23:39 <ddarius> pjd: Real C Programmers can write C in ANY language
19:23:50 <kmcallister> and they can write any language in C
19:24:02 <kmcallister> neither of these things is necessarily advisable, though
19:24:23 <pjd> ddarius: but it takes a madman to do it as well as augustss does in Haskell, though :)
19:24:39 <ddarius> augustss is a Real C Programmer
19:26:07 <ddarius> @google "Lennart Augustsson" IOCCC
19:26:09 <lambdabot> http://www.ioccc.org/winners.html
19:26:09 <lambdabot> Title: Winners - about the authors of winning IOCCC entries
19:26:11 <byte-> AFAICT, function application is inferior to stack-based concatenation in every way except for typing.
19:26:17 <byte-> *type checking
19:26:19 <dmwit> ?pl \x y -> (x^2 + y^2)^0.5
19:26:19 <lambdabot> flip flip (0 . 5) . ((^) .) . (. (^ 2)) . (+) . (^ 2)
19:26:29 <dmwit> ...
19:26:32 <dmwit> ?pl 0.5
19:26:32 <lambdabot> 0 . 5
19:26:50 <byte-> ?pl (0.5)
19:26:50 <lambdabot> 0 . 5
19:27:14 <dmwit> ?pl \x y -> sqrt $ x^2 + y^2
19:27:15 <lambdabot> (sqrt .) . (. (^ 2)) . (+) . (^ 2)
19:27:32 <bparkis> byee- but you can do all that stuff with function application as well can't you
19:27:35 <byte-> pretty.
19:27:47 <byte-> bparkis, you can also do all that stuff with assembly ;)
19:28:08 <byte-> it's just that fuction application is usually longer (token-wise).
19:28:23 <dmwit> byte-: I dunno, I find "sqrt $ x^2 + y^2" much more readable than "(2 ^) 2i + 0.5 ^", and it is the exact same number of characters.
19:28:32 <byte-> actually
19:28:59 <byte-> (2 ^) 2i + sqrt is shorter I think
19:29:09 <byte-> it's also not as redudant.
19:29:15 <dmwit> by one character
19:29:22 <byte-> token-wise
19:29:23 <dmwit> That's not very much of a win. =P
19:29:33 <dmwit> Oh, yeah, it's two tokens shorter.
19:29:48 <dmwit> (If 2i is one token.)
19:29:52 <byte-> that's almost 20%
19:30:04 <byte-> seems rather large to me.
19:30:16 <byte-> besides, it's not that hard to read once you get used to it.
19:30:22 <byte-> same as functional programming.
19:30:28 <byte-> so that's not really a valid argument.
19:30:42 <dmwit> agreed
19:31:09 <wagle> whats a good font for xemacs on a mac..  i upgraded my macports xemacs, and its now hard to look at
19:31:10 <mgsloa1> pnorm p = (**(recip $ fromInteger p)) . sum . map (^p)
19:31:14 <mgsloa1> this is better
19:31:30 <mgsloa1> length = pnorm 2
19:31:40 <monochrom> lucida monospace
19:32:02 <ddarius> Times New Roman
19:32:11 <byte-> mgsloa1, is that supposed to be equivalent to sqrt $ x^2 + y^2 ?
19:32:21 <dmwit> yeah
19:32:24 <mgsloa1> no
19:32:32 <dmwit> Only, it's more general.
19:32:39 <byte-> :t **
19:32:40 <lambdabot> parse error on input `**'
19:32:43 <mgsloa1> yeah, it works, but you have to give it [x,y]
19:32:43 <byte-> :t (**)
19:32:44 <lambdabot> forall a. (Floating a) => a -> a -> a
19:32:57 <mgsloa1> rather than just having x and y as vars
19:33:14 <byte-> wouldn't it just be easier to do 'pnorm = sum . product . map (^2)' ?
19:33:19 <mgsloa1> no
19:33:23 <byte-> wait...
19:33:25 <mgsloa1> because this gives you all pnorms
19:33:25 <byte-> screwed that up
19:33:37 <byte-> pnorm = sqrt . sum . map (^2)
19:33:45 <dmwit> nope
19:33:54 <byte-> hmm... I just noticed that 'p'
19:34:02 <dmwit> pnorm p = (p-th root) . sum . map (^p)
19:34:24 <mgsloa1> http://en.wikipedia.org/wiki/Lp_space
19:34:24 <lambdabot> Title: Lp space - Wikipedia, the free encyclopedia
19:34:26 <byte-> ohh
19:34:31 <wagle> need fixed width..  8/
19:34:39 <byte-> I see.
19:34:40 <byte-> nevermind.
19:34:57 <shachaf> > ((sqrt .) . ((+) `on` (^2))) 3 4
19:34:58 <lambdabot>  5.0
19:35:00 <mgsloa1> anyway, seems more reasonable, from a functional perspective, to define length as generally as possible, then use that to create specializations
19:35:07 <dmwit> shachaf: nice
19:35:37 <byte-> mgsloa1, ideally, yeah.
19:35:39 <dmwit> mgsloa1: Except maybe if you wanted speed. =P
19:35:44 <mgsloa1> true
19:35:47 <byte-> but I can think of situations where (2 ^) 2i would come in handy.
19:35:53 <mgsloa1> in my geom lib it specialized 1 and 2, it's true
19:36:11 <ddarius> mgsloa1: Sell out.
19:36:17 <mgsloa1> :P
19:37:19 <ddarius> 1, 2, 
19:37:28 <byte-> so have we pretty much agreed that function application sucks? (again, disregarding typing concerns)
19:37:41 <dmwit> Yeah, \infty is a particularly interesting case.
19:37:51 <mgsloa1> that is true
19:37:59 <mgsloa1> would I be able to pattern match on infty?
19:38:11 <mgsloa1> probably not
19:38:17 <dmwit> ?hoogle isInfinite
19:38:17 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
19:38:28 <mgsloa1> won't work for Integers, i don't think
19:38:34 <dmwit> ...no
19:38:57 <mgsloa1> which is why I have infinityNorm..
19:39:06 <dmwit> ah =)
19:40:50 <byte-> ok, time to go
19:40:55 <byte-> bye guys
19:41:04 <byte-> thanks for the conversation.
19:41:56 <wagle> monochrom, you use macosx?  which version?
19:42:41 <monochrom> I don't use macosx.
19:43:34 <wagle> ah..  8)  that would explain why i cant find lucida monospace..
19:44:33 <monochrom> Sometimes it is called lucida typewriter.
19:44:56 <mgsloa1> anyone here used writeroom? I'm thinking of writing something like it, for kicks.  I haven't actually used it (no mac)
19:45:30 <dmwit> All good editors can do better than writeroom.
19:45:34 <mgsloa1> can't decide whether or not I should steal yi's buffer stuff :P
19:45:59 <ddarius> Steal it.
19:46:04 <ddarius> What are we talking about?
19:46:08 <allbery_b> also "lucida sans typewriter" btw
19:46:25 <allbery_b> as for editors, shoot for the moon:  replace subethaedit :)
19:46:28 <mgsloa1> well, I'm not sure how easy it would be to use.  I guess it does look pretty stealable
19:46:35 <wagle> bleah...  its got the jaggies in 10 and 11 (and too big in 12)
19:46:35 <radix> mgsloa1: I'd like to try it when you finish
19:46:37 <mgsloa1> lol. yeah, that'd be fun
19:46:52 <radix> I just switched over from an emacs window where I'm *supposed* to be writing some stuff.
19:47:07 <mgsloa1> if I do.  Realistically I probably won't but it's a fun project in the mean time
19:47:27 <dmwit> wagle: Wait, no anti-aliasing?
19:47:47 <mgsloa1> I've been using this for a while http://logarithmic.net/pfh/yaedit . it's kinda like gedit but minimal and more interesting
19:47:53 <lambdabot> Title: yaedit: yet another editor
19:48:23 <allbery_b> the lucida fonts that come with X11 are bitmapped, fwiw
19:48:32 <LoganCapaldo> writeroom = $EDITOR + XMonad <g>
19:48:42 <wagle> dmwit, maybe my problem is that it somehow got turned off..  that occurred to me, and i'm currently looking for an aliasing option
19:48:42 <allbery_b> I don't think even apple's x11.app has truetype versions
19:49:04 <dmwit> LoganCapaldo: *nod*
19:49:07 <mgsloa1> LoganCapaldo: yeah, I'd use it within xmonad for sure :)
19:49:46 <mgsloa1> actually, it'd actually be more of a writeroom + yaedit hybrid, with some cairo graphics pizazz
19:49:50 <mgsloa1> but we'll see
19:50:17 <dmwit> +1 for gratuitous Cairo
19:50:42 <mgsloa1> yeah, I <3 cairo
19:51:30 <mgsloa1> ahhh spoonerized richard nixon
19:52:04 <kmcallister> anyone know what version of Gtk2Hs i need to use Glade?
19:52:18 <allbery_b> most of them?
19:53:00 <kmcallister> ah it's a seperate package on debian
19:53:03 <allbery_b> I've been using it with an older version (upgrading will be somewhat painful but I will have to tackle it eventually)
19:56:39 <wagle> my problem is i had a "just fine" font for macports xemacs, i upgraded it, and now the fonts all suck
20:01:03 <allbery_b> @bot
20:01:03 <lambdabot> :)
20:01:06 <allbery_b> hm
20:01:44 <dmwit> \bot just isn't in #h-b.
20:03:29 <allbery_b> yeh
20:03:32 <allbery_b> I thought it was
20:04:32 <bos> @pl \a b -> f a : b
20:04:32 <lambdabot> (:) . f
20:15:51 <bos> do we have convenient ways, other than printf, of printing the likes of hex numbers?
20:16:06 <Cale> :t showHex
20:16:06 <lambdabot> forall a. (Integral a) => a -> String -> String
20:16:15 <ddarius> > showHex 3634 ""
20:16:17 <lambdabot>  "e32"
20:16:27 <bos> @hoogle showHex
20:16:28 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
20:16:33 <bos> ah, thanks.
20:16:34 <LoganCapaldo> > showHex 3634 "what's this for?"
20:16:35 <lambdabot>  "e32what's this for?"
20:16:59 <Cale> LoganCapaldo: It's so you can efficiently show lots of numbers at once by composing functions.
20:17:04 <LoganCapaldo> showHex :: (Integral a) => a -> ShowS ?
20:17:05 <ddarius> > showHex 255 . (' ':) . shows (34,5)
20:17:06 <lambdabot>  <[Char] -> [Char]>
20:17:10 <ddarius> > showHex 255 . (' ':) . shows (34,5) $ ""
20:17:11 <lambdabot>  "ff (34,5)"
20:17:19 <ddarius> LoganCapaldo: Yes.
20:17:21 <ddarius> @src ShowS
20:17:21 <lambdabot> type ShowS = String -> String
20:17:41 <ac> > chr 'a'
20:17:42 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
20:17:52 <LoganCapaldo> Imissed the hoggle output
20:17:59 <LoganCapaldo> :t shoulda had ShowS :)
20:18:00 <lambdabot> parse error on input `)'
20:18:04 <kmcallister> is there a function f :: a -> Bool which returns True if its first argument is already evaluated, and otherwise returns False without forcing it?
20:18:04 <chessguy> > ord 'a'
20:18:05 <lambdabot>  97
20:18:14 <ddarius> @hoogle isBottom
20:18:14 <LoganCapaldo> kmcallister: eek
20:18:14 <lambdabot> No matches found
20:18:16 <Cale> kmcallister: nope
20:18:24 <LoganCapaldo> that sounds like an evil horrible function
20:18:27 <kmcallister> i realize this breaks semantics horribly
20:18:28 <kmcallister> yeah
20:18:44 <ddarius> kmcallister: There's a partial one in some random place, like quickcheck
20:18:47 <ddarius> @index isBottom
20:18:47 <lambdabot> Test.QuickCheck.Batch, Debug.QuickCheck.Batch
20:18:56 <ddarius> There we go.
20:19:05 <Cale> But that evaluates its argument.
20:19:11 <ddarius> Well, not quite
20:19:23 <ddarius> I think HOOD had something like that.
20:19:30 <LoganCapaldo> also it should be f :: a -> IO Bool
20:19:35 <LoganCapaldo> if it existed
20:19:51 <chessguy> yes, anything evil goes in IO
20:20:06 <kmcallister> hmm, this would change the meaning, but it's probably what i'd want anyway
20:20:11 <pjd> kmcallister: (`seq` True)
20:20:17 * pjd ducks
20:20:20 <LoganCapaldo> well i'm just thinking referentially transparent wise f 3 vs. f (2 + 1)
20:20:37 <LoganCapaldo> pjd++
20:20:40 <ac> > ("0x"++) $ concatMap (flip Numeric.showHex "" . fromIntegral . ord) "test"
20:20:41 <lambdabot>  "0x74657374"
20:21:28 <ac> @let chunk n = map (take n) . takeWhile (not.null) . iterate (drop n)
20:21:30 <lambdabot> Defined.
20:22:10 <chessguy> @type \n -> map (take n) . takeWhile (not.null) . iterate (drop n)
20:22:11 <lambdabot> forall a. Int -> [a] -> [[a]]
20:23:12 <chessguy> nice
20:23:16 <ac> > map (chr . fst . head . Numeric.readHex) $ chunk 2 "74657374"
20:23:17 <lambdabot>  "test"
20:23:23 <bos> @seen dons
20:23:24 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 9m 2s ago.
20:23:39 <kmcallister> @where hsplugins
20:23:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:24:16 <stinger> so is anyone working on a haskell scripting plugin for kde 4? :P
20:24:16 <chessguy> ac, you have way too much time on your hands :)
20:24:38 <kmcallister> lambdabot makes a good secret decoder ring
20:24:40 <ac> chessguy: what're you talking about? That took about 2 minutes
20:25:17 <ddarius> Here is an interesting function.  Let t,m,b :: (() -> ()) -> () where t _ = (); m g = g (); and b _ = undefined.  Let f :: ((() -> ()) -> ()) -> Bool be specified by f t = False; f m = True; f b = undefined.  Implement f.
20:25:51 <ac> chessguy: but yeah, I do have way too much time on my hands actually. I'm unemployed more or less
20:26:38 <ac> > map (chr . fst . head . Numeric.readHex) $ chunk 2 $ drop 2 "0x74657374"
20:26:40 <lambdabot>  "test"
20:27:37 * LoganCapaldo seriously considers leaving the room to not have the answer to ddarius's puzzle spoiled
20:27:38 <stinger> @t chunk
20:27:39 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:27:45 <stinger> @ty chunk
20:27:46 <lambdabot> Not in scope: `chunk'
20:28:19 <ac> stinger: Int -> [a] -> [[a]]
20:28:29 <stinger> wheres that from ac?
20:28:33 <stinger> or is it custom
20:28:37 <kmcallister> ddarius, does the answer exist in pure lambda calculus or does it require some more concrete Haskell feature?
20:28:48 <ac> stinger: just a function I have defined in about half my programs
20:29:01 <stinger> heheh  yer ac, been looking for that in a lib somewhere
20:29:05 <wagle> isBottom = (\x . x x) (\x . x x) ?
20:29:08 <stinger> it seems so.. critical to me :P
20:29:13 <stinger> fundamental
20:29:21 <ac> stinger: yeah, you and everybody else wants it in the stdlibs
20:29:40 <stinger> should be in prelude damnit :)
20:29:43 <ddarius> LoganCapaldo: You probably wouldn't like the answer, though it is interesting.
20:30:30 <ddarius> kmcallister: The answer doesn't exist in what is normally viewed as the pure functional languages at all.
20:30:51 <kmcallister> ah, so it's a trick ;0
20:30:55 <ddarius> f is a pure function that can't be written in Haskell without unsafePerformIO.
20:31:00 <kmcallister> i'm still interested
20:31:10 <ddarius> (Alternatively, you could write it in ML but not the pure subset of ML.)
20:31:19 <ddarius> Using exceptions or state, the answer is easy.
20:32:36 <wagle> @hoogle isSuspension
20:32:37 <lambdabot> No matches found
20:33:05 <shachaf> wagle: That doesn't type-check in Haskell.
20:33:16 <Pseudonym> @let t _ = ()
20:33:18 <lambdabot> Defined.
20:33:19 <ac> ddarius: where does 'g' come from?
20:33:20 <Pseudonym> @let m g = g ()
20:33:22 <lambdabot> Defined.
20:33:24 <Pseudonym> @let b _ = undefined
20:33:26 <lambdabot> Defined.
20:33:26 <ac> oh nevermind
20:33:28 <ac> read that incorrectly
20:33:30 <Pseudonym> > fix m
20:33:31 <lambdabot>      Occurs check: cannot construct the infinite type: t = () -> t
20:33:31 <lambdabot>     Probab...
20:33:35 <Pseudonym> Dammit.
20:34:15 <Pseudonym> :t t
20:34:17 <lambdabot> Not in scope: `t'
20:34:21 <Pseudonym> :t L.t
20:34:22 <lambdabot> Couldn't find qualified module.
20:34:59 <wagle> shachaf, all the better
20:35:14 <ddarius> An example solution using made up exceptions: f g = catch (g (throw ()) `seq` False) (\_ -> True)
20:35:40 * shachaf missed the first part of this conversation, sorry.
20:35:41 <ac> if they both return unit, it's not possible to do it using normal purely functional code
20:36:03 <ac> but you already said that
20:36:51 <dons> Cale: 'inconvenient_truth' is an odd character..
20:36:58 <wagle> (a "solution" to the halting problem probably shouldn't typecheck)
20:37:01 <Cale> indeed.
20:37:35 <shachaf> wagle: Why is ((\x -> x x) (\x -> x x)) isBottom?
20:37:48 <wagle> it was a joke
20:38:43 <hpaste>  LoganCapaldo pasted "ddarius: sth. like this, assuming you actually catch the exception?" at http://hpaste.org/5310
20:38:48 <wagle> isbottom computes forever to arrive at the answer after the end of time, or something
20:39:14 <kmcallister> anyone know why i'm getting "Something is amiss; requested module  hi-0.9.10:Language.Hi.Parser differs from name found in the interface file hi:Language.Hi.Parser" when trying to build hs-plugins 0.9.10?
20:39:17 <synthasee> k&r2 is to C what ? is to haskell? (I'm wondering what book on haskell is revered, so that I can buy it)
20:40:00 <ddarius> LoganCapaldo: Yes.
20:40:12 <LoganCapaldo> theres a problem
20:40:14 <LoganCapaldo> though
20:40:20 <jfredett> synthasee: I'd say there really isn't one,
20:40:23 <LoganCapaldo> I get overlapped pattern match warning
20:40:25 <ac> synthasee: there are very few books physically published
20:40:27 <jfredett> though Yet another Haskell Tutorial is good
20:40:33 <jfredett> Gentle intro is good
20:40:40 <jfredett> both are free, just google them
20:40:45 <LoganCapaldo> because of ()
20:40:46 <synthasee> cool, thanks
20:40:47 <jfredett> IRC is really the most popular haskell book
20:40:47 <ac> synthasee: the only one I know of is Haskell School of Expression (which is decent). I think there are 1 or 2 others
20:41:08 <jfredett> Haskell for Maths, Logic, and Programming is interesting, but only tangental to learning haskell
20:41:09 <bos> @hoogle sizeOf
20:41:10 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
20:41:14 <shachaf> synthasee: Programming In Haskell is nice, though it's a bit short.
20:41:16 <ddarius> LoganCapaldo: You don't really need the _ case.
20:41:29 <wagle> how is bird's haskell text?
20:41:29 <ddarius> If fn is b then it will already be undefined.
20:41:33 <jfredett> eventually we'll have real world haskell, which will be nice
20:41:39 <jfredett> and theres the wikibook, which is great
20:41:44 <LoganCapaldo> ddarius: ah yes, right
20:42:18 <ac> I used Yet another Haskell Tutorial, but this looks pretty good too: http://en.wikibooks.org/wiki/Haskell
20:42:18 <ddarius> http://citeseer.ist.psu.edu/longley99when.html
20:42:19 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
20:42:26 <lambdabot> Title: When is a Functional Program Not a Functional Program? - Longley (ResearchIndex)
20:42:34 <jfredett> synthasee: are you coming out of C or somewhere else?
20:43:00 <synthasee> well, I know C well, and have used C++, scheme and java
20:43:16 <synthasee> but I've been interested in learning haskell
20:43:20 <Cale> :)
20:43:22 <jfredett> right, so scheme is going to be as close as you get to haskell, and it'll seem worlds away
20:43:28 <dons> bos, around?
20:43:40 <jfredett> I came out of Scheme/CL and Java, and the transition wasn't to bad
20:43:42 <allbery_b> kmcallister: sounds like something is out of sync.  was the hi package built with the same version of ghc?  (I think versions before 6.6(.1?) didn't store versions in .hi files)
20:43:48 <jfredett> I'd suggest YAHT and the Wikibook
20:43:52 <jfredett> those helped me the most
20:43:54 <synthasee> thanks
20:43:58 <Cale> and asking lots of questions here! :)
20:44:08 <kmcallister> i think the hi package lives in the hs-plugins distribution
20:44:13 <jfredett> Yah, IRC, like I said, is the best Haskell Book around
20:44:13 <chessguy> we like questions!
20:44:14 <jfredett> :)
20:44:19 <allbery_b> hm
20:44:32 <jfredett> Questions rock.
20:44:40 <wagle> thompson's book or hudak's book will both get you started, but I felt i was left holding the bag with respect to understanding monads or the complex tricks advanced haskell people use
20:44:48 <chessguy> at least until RWH comes out :)
20:44:49 <bos> dons: yeah
20:44:55 <jfredett> We're wicked nice, too. unless you're a troll
20:46:27 <ddarius> The only "Haskell" book that I have any kind of interest in getting is Bird's.
20:48:20 <ddarius> This thing is silly: http://files.codersbase.com/haskell/haskell-current.png
20:48:50 <wagle> hey, YAHT's monad section looks substantial
20:49:09 <LoganCapaldo> i'm a leaf!
20:49:14 <wagle> Bird's book might be a bit dated? (1998)
20:49:21 <wagle> LoganCapaldo, blowing in the wind?
20:49:39 <mgsloa1> ddarius: hah
20:49:40 <LoganCapaldo> byorgey and dcoutts are all off floating by themselves
20:49:48 <jfredett> ddarius: thats cool
20:49:57 <mgsloa1> yeah, realtime, sweet
20:50:05 <LoganCapaldo> i wonder what metrics it's using
20:50:19 <LoganCapaldo> lol
20:50:19 <allbery_b> who talks to who, I think
20:50:19 <mgsloa1> it's using when you name people
20:50:21 <mgsloa1> yeah
20:50:24 <mgsloa1> talking to people
20:50:26 <LoganCapaldo> i just attached them by talking about them
20:50:28 <jfredett> it seems that all it does is monitor when one person says someone elses name
20:50:33 <mgsloa1> so when I said "ddarius: blah", it made a link
20:50:36 <pjd> bos: yoink
20:50:37 <Pseudonym> Aha.
20:50:42 <Pseudonym> That's why I don't rate a mention.
20:50:48 <ddarius> The links need to be directional.
20:50:54 <Cin> ratpoison is kick ass. has anyone managed to make xmonad be like it?
20:50:57 <bos> pjd: yah?
20:51:10 <pjd> bos: just making a link, sorry :)
20:51:11 <Pseudonym> Pseudonym idnar sjanssen travisbrady elus Pupeno ivanm
20:51:11 <Pseudonym>            Averell uebayasi swalters seafood_ adu mgregson dolio synthasee Valo
20:51:11 <Pseudonym>            dim_ bos Mr_Awesome NichardRixon arguile Zio conal fridim_ arke
20:51:11 <Pseudonym>            mgsloa1 dejones X-Scale __suri_ bparkis larmeh_ zeno flippo sethk
20:51:11 <Pseudonym>            kfish mattrepl jimwhite dcoutts_ dmwit pxf alatter Hirvinen dfeuer
20:51:11 <Pseudonym>            sarah_ ozone goalieca markb Giraph jfoutz psykotic wagle exe_
20:51:12 <allbery_b> since it linked me to kmcallister, and I just tried to help him (but hs-plugins has moved beyond my comprehension)
20:51:13 <Pseudonym>            raxas__ middayc _alf_ AtnNn nanothief SyntaxNinja cdr Modius_
20:51:15 <Pseudonym> Haha
20:51:18 <kmcallister> so does anyone know about hs-plugins on ghc 6.6? googling indicates it may or may not be possible
20:51:24 <bos> @botsmack pjd
20:51:24 <lambdabot> :)
20:51:29 <wagle> dons, Cale, wanna join our social network?
20:51:33 <Pseudonym> And there I am!
20:51:34 <jfredett> Cin: Xmonad is so cutomizable, you could probably do it in short order on your own
20:51:46 <LoganCapaldo> EvilTerran: get over here!
20:51:46 <mgsloa1> Pseudonym: I think they have to be active
20:51:46 <Pseudonym> dons, Cale, wagle, sure!
20:51:59 <allbery_b> it tends to be fairly version dependent.  I'm no sure what version works with 6.6 any more
20:52:00 <Cin> jfredett: i may look into it then
20:52:01 <Pseudonym> We game the system!
20:52:03 <goalieca> Pseudonym, pokes
20:52:03 <jfredett> yah
20:52:04 <allbery_b> dons might know
20:52:25 <jfredett> Cin: I like xmonad quite alot, and xmobar is pretty sweet too
20:52:31 <allbery_b> Cin: you might want to trop by #xmonad
20:52:31 <mgsloa1> ahah, it only picked up on the first ones of each of your lines
20:52:36 <dmwit> Why are you saying my name?
20:52:44 <dmwit> Also, where is the visualization?
20:52:45 <mattrepl> Pseudonym, getting connected
20:52:57 <LoganCapaldo> jedbrown: come join us
20:52:59 <mgsloa1> dmwit: http://files.codersbase.com/haskell/haskell-current.png
20:53:02 <Pseudonym> For some reason, this reminds me of this:http://www.zefrank.com/social_2.mp3
20:53:05 <jfredett> I use that and slim for display managing, and my startup time is limiting 0 now
20:53:41 <dmwit> interesting
20:53:43 <dons> what's this social network?
20:53:54 <dmwit> dons: Connections on #haskell.
20:54:04 <LoganCapaldo> it's a web of lies is what it is
20:54:08 <allbery_b> who names who on #haskell
20:54:11 <dmwit> yeah
20:54:13 <allbery_b> amusing
20:54:25 <kmcallister> dons, do you know if there's a working hs-plugins for ghc 6.6?
20:54:26 <wagle> god, you here?
20:54:28 * Cin winks at allbery_b and jfredett 
20:54:34 <jfredett> sup?
20:54:40 <dons> kmcallister: sure.
20:54:42 <ddarius> wagle: The benefit of Bird's book are the techniques that generally applicable.
20:54:43 <jfredett> god here, what can I do for you, wagle
20:54:46 <dons> kmcallister: grab the darcs repo
20:54:56 <jfredett> Well, Jake, 4th member of the trinity, but close enough for all purposes
20:55:19 <wagle> god, wanna approximate top for me?
20:55:27 <jfredett> its 42
20:55:27 <Cin> jfredett: can you make my beard grow faster?
20:55:45 * ddarius considers subjecting himself to that radio talk.
20:55:45 <kmcallister> dons, thanks
20:55:47 <pjd> dcoutts_: c'mere!
20:55:52 <jfredett> Cin: done, shaved a day off the usual time
20:55:54 * allbery_b spots haskellsocialnet
20:56:03 <jfredett> anything else, folks?
20:56:09 <allbery_b> heh heh heh
20:56:28 <dmwit> Cin: Yes, just send your razor so I can get a feel for you, and $$$.
20:56:58 <jfredett> nothing?
20:57:03 <jfredett> alrighty, I'll send the bill
20:57:07 <conal> i wonder if there's an interactive springy version of this graph
20:57:21 <dmwit> Cin: Then I will take advantage of confirmation bias to make you think I actually did something. ;-)
20:57:57 <dmwit> Yikes, the byorgey-dcoutts dyad has split off and started their own little colony!
20:58:17 <wagle> also need voronoi diagram
20:58:20 <Cin> jfredett: i'm quite satisfied with ratpoison, especially the way it is like emacs, and when you resize and split frames, they behave predictably. what i don't much like is it doesn't support workspaces outright, and it's kind of an arse to use GIMP
20:58:31 <dmwit> Wait a second... this isn't a graph at all.  Some nodes appear multiple times!
20:58:44 <Cin> jfredett: and then there's the fact it's 18,000 lines of c code
20:58:46 <shachaf> dmwit: Which?
20:58:48 <dmwit> Cin: Have a try at xmonad?
20:58:58 <jfredett> Cin: xmonad is fairly emacsy outright
20:59:03 <Cin> dmwit: i've tried it, well, i've tried its default setup
20:59:07 <dmwit> shachaf: dcoutts appears twice
20:59:09 <shachaf> dmwit: Are you thinking of dcoutts and dcoutts_?
20:59:10 <dons> Cin: there's a huge library of extensions
20:59:11 <jfredett> though you can configure it to be moreso
20:59:14 <ddarius> dmwit: dcoutts_
20:59:19 <dmwit> shachaf: oh
20:59:21 <dons> and some ratpoison emulation. its also 10x smaller than ratpoison
20:59:24 <dons> and 1000 times more fun
20:59:33 <jfredett> everything else seems fairly straight forward from there
20:59:46 <jfredett> Cin: did you get a pre-made package? or from darcs?
20:59:52 <wagle> > "dcoutts_" == "dcoutts"
20:59:54 <lambdabot>  False
21:00:00 <Cin> jfredett: i think i compiled a release
21:00:06 <jfredett> though, this should really be happening in #xmonad
21:00:09 * dmwit shakes fist at wagle
21:00:25 <dmwit> The '_' is obscured by an edge, you rascal!
21:01:09 <ddarius> "* add ratpoison emulation\n+    unsafeCoerce 3 5"
21:01:39 <jfredett> Cin: which one, if you remember?
21:02:03 <jfredett> the more recent ones compiled and ran pretty okay, modulo getting dependencys together, on my arch box
21:03:32 <jfredett> though, I haven't tried 0.6 yet, 0.4 and 0.5 worked beautifully
21:03:58 <brian`> hey, do you guys know if there is a standard haskell function that converts decimal to hex or binary or vice versa?
21:04:21 <wagle> need a lazy programming system..  when you look for a program, it forces some poor student into writing it for you
21:04:23 <dmwit> There sure is!
21:04:30 <dmwit> :t showHex
21:04:33 <lambdabot> forall a. (Integral a) => a -> String -> String
21:04:40 <ddarius> wagle: You need several more years of university for that.
21:04:49 <dmwit> :t showAtBase
21:04:50 <lambdabot> Not in scope: `showAtBase'
21:04:59 <jfredett> :t showBase
21:05:01 <lambdabot> Not in scope: `showBase'
21:05:02 <brian`> :showHex 39
21:05:03 <ddarius> @hoogle showIntAtBase
21:05:05 <jfredett> meh, maybe
21:05:09 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
21:05:15 <brian`> @showHex 39
21:05:15 <lambdabot> Unknown command, try @list
21:05:16 <wagle> ddarius, its prolly called a professor
21:05:21 <dmwit> :t showIntAtBase
21:05:22 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
21:05:25 <dmwit> > showHex 39
21:05:27 <lambdabot>  <[Char] -> [Char]>
21:05:28 <dmwit> > showHex 39 ""
21:05:29 <brian`> >showHex 39
21:05:30 <lambdabot>  "27"
21:05:38 <brian`> yay~
21:05:40 <brian`> thanks guys
21:05:55 <wagle> how do i convert to and from base 13?
21:06:04 <dmwit> Oops, I was too late with showIntAtBase.
21:06:43 <dmwit> > showIntAtBase 13 ("0123456789ABC" !!) 42 ""
21:06:43 <kmcallister> is there an equivalent of make -j for Setup.hs build?
21:06:45 <lambdabot>  "33"
21:06:51 <brian`> hm.. how come I don't have showIntAtBase on my platform..?
21:06:56 <brian`> do i have to import something?
21:07:00 <dmwit> ?index showIntAtBase
21:07:00 <kmcallister> i want to compile in 2 threads
21:07:00 <lambdabot> Numeric
21:07:01 <geezusfreeek> on the GLFW wiki page it says GLFW doesn't work well with GHC thread, forkIO, or threadDelay... does anybody know whether that means that you can't have a multithreaded program use GLFW at all or if it just means you can't use GLFW itself in more than one thread?
21:07:12 <dmwit> brian`: Seems you have to import Numeric.
21:07:16 <wagle> > showIntAtBase 13 ("0123456789ABC" !!) (6 * 9) ""
21:07:17 <lambdabot>  "42"
21:07:26 <jfredett> wagle lol
21:07:38 <brian`> :info showIntAtBase
21:07:49 <dmwit> We don't have an :info-alike.
21:08:34 <brian`> dmwit, ah.. that's right.. i forgot about that
21:10:05 <dons> Cale, i'm not sure i'd continue that discussion.
21:10:12 <dons> its a weird world of FP we're in :)
21:10:15 <Cale> Yeah, I'm about done with it.
21:10:46 <dons> if he'd asked "how to do polymorphic variants in haskell", that would have been interesting
21:11:01 <dons> i bet its something SPJ would love to hack on too ... :)
21:11:02 <allbery_b> geezusfreak: almost(?) every GUI framework for Haskell has to be limited to a single thread
21:11:11 <dons> no. surely not.
21:11:22 <allbery_b> you can do non-GUI stuff in other threads
21:11:34 <geezusfreeek> okay, that's what i was checking, thanks
21:11:40 <geezusfreeek> the wording the threw me
21:11:46 <geezusfreeek> *the workding just threw me
21:11:50 <geezusfreeek> gosh i can't type
21:13:23 <dons> Cale, it seems like none of this persons posts show up in the 'new' page. i wonder if he fell into the ban list(?)
21:13:57 <Cale> hmm...
21:15:14 <idnar> :t showIntAtBase
21:15:15 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
21:16:16 <idnar> > showIntAtBase 16 ("0123456789ABCDEF" !!) (6 * 9) "0x"
21:16:19 <lambdabot>  "360x"
21:16:30 <dmwit> ?let digit = ((['0'..'9'] ++ ['a'..'z']) !!)
21:16:33 <lambdabot> Defined.
21:16:45 <idnar> > showIntAtBase 16 ("0123456789ABCDEF" !!) (6 * 9) ""
21:16:46 <lambdabot>  "36"
21:16:49 <dmwit> > showIntAtBase 32 digit 256 ""
21:16:50 <lambdabot>  "80"
21:16:58 <idnar> what's the last String param for?
21:17:11 <dmwit> idnar: For fast concatenation.
21:17:33 <idnar> ok
21:17:55 <dmwit> :t shows
21:17:56 <lambdabot> forall a. (Show a) => a -> String -> String
21:18:11 <ddarius> @src Show
21:18:11 <lambdabot> class  Show a  where
21:18:11 <lambdabot>     showsPrec :: Int -> a -> ShowS
21:18:11 <lambdabot>     show      :: a   -> String
21:18:11 <lambdabot>     showList  :: [a] -> ShowS
21:18:12 <dmwit> Same deal as there.
21:21:15 <dmwit> ?src (++)
21:21:15 <lambdabot> (++) []     ys = ys
21:21:15 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
21:21:18 <dons> Cale, stop please :)
21:21:47 <ddarius> dons: link to this conversation?
21:22:14 <dons> started here, http://reddit.com/r/programming/info/66xuw/comments/
21:22:22 <ddarius> Thanks
21:22:29 <dons> finished here, http://reddit.com/r/programming/info/66xw9/comments
21:22:44 <dons> we're big enough to have dedicated trolls
21:22:54 <Cin> well i just realised that i'm doing loads of horrible pattern matching all over my code, repeating the same operations when i come define a set of functions to abstract these operations. i guess i got carried away with haskell being alien to me. yay for realisation
21:23:11 <ddarius> @where calesblog
21:23:11 <lambdabot> http://reddit.com/user/cgibbard
21:23:21 <dmwit> heh
21:23:23 <dons> sounds like you need a monad, Cin :)
21:23:25 <dons> (maybe)
21:24:09 <Cin> dons: i chuckled
21:24:30 <dmwit> I think maybe that wasn't a joke
21:24:35 <Cin> so do i :P
21:24:41 * Cin retracts his chucklage
21:24:52 <dons> right. i was serious. programmable semicolon and all that.
21:25:12 <dons> if you're doing the same thing all over the place with a return value, maybe its Maybe a, or something similar
21:27:07 <Cin> it's more the way i'm extracting things from my state values. like, first check it exists in the map, then get it from the map
21:27:19 <Cin> horrible big confusing functions: http://rtfs.ath.cx/haskell/IRCServer/Server.hs
21:27:38 <dmwit> :t Data.Map.lookup
21:27:39 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
21:27:45 <paczesiowa> > let (<+>) = many in 1
21:27:46 <lambdabot>  Add a type signature
21:28:14 <dmwit> Cin: The Maybe monad + functions in Data.Maybe make that particular operation pretty nice.
21:28:25 <paczesiowa> > let (<+>) = many in parseTest (digit <+>) "123"
21:28:26 <lambdabot>   Not in scope: `parseTest'
21:28:31 <dons> > M.lookup "foo" (M.fromList [("haskell",
21:28:31 <lambdabot> Unbalanced parentheses
21:28:35 <dons> > M.lookup "foo" (M.fromList [("haskell", 1)])
21:28:35 <lambdabot>   add an instance declaration for (Show (m t))
21:28:40 <dons> > M.lookup "foo" (M.fromList [("haskell", 1)]) :: Maybe Int
21:28:42 <lambdabot>  Nothing
21:28:45 <paczesiowa> > let (<+>) = many in Text.ParserCombinators.Parsec.parseTest (digit <+>) "123"
21:28:46 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.parseTest'
21:29:04 <ddarius> paczesiowa: That wouldn't help anyway as parseTest :: ... -> IO ()
21:29:05 <dmwit> Cin: Also, did you know about the "deriving" clause of data type declarations?
21:29:24 <paolino> :t parse
21:29:25 <lambdabot> Not in scope: `parse'
21:29:28 <Cin> hmm, those might help. using a case i could extract the values
21:29:32 <ddarius> @hoogle parse
21:29:32 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
21:29:32 <lambdabot> Data.Version.parseVersion :: ReadP Version
21:29:32 <lambdabot> Distribution.Version.parseVersionRange :: ReadP r VersionRange
21:29:34 <paczesiowa> > let (<+>) = many in Text.ParserCombinators.Parsec.parse "" (digit <+>) "123"
21:29:34 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.parse'
21:29:44 <paczesiowa> > let (<+>) = many in Text.ParserCombinators.Parsec.Prim.parse "" (digit <+>) "123"
21:29:45 <lambdabot>      Not in scope: `Text.ParserCombinators.Parsec.Prim.parse'
21:29:52 <Cin> dmwit: i did but i specifically wanted to print those types in a specific way
21:29:59 <shachaf> Cin: It really does look like you might need a monad.
21:30:00 <ddarius>  @run apparently (unsurprisingly) doesn't import Parsec
21:30:03 <dmwit> ok =)
21:30:13 <ddarius> Monads: Not Just For Scaring Away Newbies
21:30:16 <paczesiowa> > "anyway I love postfix operators"
21:30:17 <lambdabot>  "anyway I love postfix operators"
21:31:02 <ddarius> instance Num (Parser a) where (+) = many1; (*) = many ...
21:31:14 <Cale> It really is annoying that the SourcePos type in Parsec doesn't export its constructor even.
21:31:21 <ddarius> Cale: Want it to?
21:31:44 <Cale> ddarius: Well, yes, along with derived instances of Data and Typeable.
21:31:57 <paczesiowa> have any of you seen this http://jparsec.codehaus.org/Tutorial ? it's funny (code at the bottom)
21:31:59 <lambdabot> Title: JParsec - Tutorial
21:32:13 <Cale> I was thinking of doing that momentarily, but I'm not sure what the proper ettiquette is regarding updating other people's packages...
21:32:25 <dmwit> :t maybe
21:32:26 <dons> well, parsec is abandoned.
21:32:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:32:31 <dons> and ddarius is notional maintainer (?)
21:32:36 <Cale> oh, okay
21:32:39 <dons> paczesiowa: oh my
21:32:43 <Cin> shachaf: well i will implement that idiom in my code tomorrow and see how it goes (about to go to bed, just reflecting on what to implement tomorrow ;)
21:32:51 <jbalint> paczesiowa: yeah, ive seen it a while back, its terrible
21:33:28 <paczesiowa> I wonder how many of you (us?) would recognize that as a monadic code:>
21:33:34 <ddarius> @hoogle Data
21:33:34 <lambdabot> Data.Generics.Basics.Data :: class Typeable a => Data a
21:33:35 <lambdabot> Data.Generics.Basics.DataType :: data DataType
21:33:35 <lambdabot> Data.Generics.Basics.DataRep :: data DataRep
21:34:44 <Cin> oh. is the Network.IRC writer/maintainer in here per chance?
21:35:05 <dons> Network.IRC?
21:35:10 <dons> oh, is that elliott?
21:35:14 <Cin> dons: it's a hackage package
21:35:34 <dons> yeah, that's trevor. i think he's not in atm.
21:35:36 <Cin> dons: er, yes. trevor
21:35:38 <dons> but i sit next to him at work.
21:35:39 <Cin> ah, okay
21:35:42 <brian`> :t subString
21:35:43 <lambdabot> Not in scope: `subString'
21:35:45 <Cin> dons: oh, i see :P
21:35:48 <brian`> :t subStr
21:35:49 <lambdabot> Not in scope: `subStr'
21:36:01 <dons> brian`: what you looking for?
21:36:04 <Cin> dons: does he use IRC and if so what's his nickname?
21:36:14 <brian`> function that returns substring? index i to j
21:36:21 <dons> Cin: 'elliott'
21:36:26 <brian`> like subStr "abcdefg" 3 5 would return def
21:36:28 <dons> birkenfeld: drop and take
21:36:34 <brian`> ah..
21:36:46 <dons> ?let substr s a b = take b (drop a s)
21:36:47 <lambdabot> Defined.
21:36:49 <Cin> dons: thanks. i have a slight change to propose on the irc package :]
21:36:52 <dons> > substr "abcdefg"
21:36:53 <lambdabot>  <Int -> Int -> [Char]>
21:36:56 <dons> > substr "abcdefg" 3 5
21:36:58 <lambdabot>  "defg"
21:37:10 <dons> well, modulo off-by-ones :)
21:37:13 <brian`> dons, thanks :)
21:37:18 <ddarius> dons: Once I release it, I'll be maintaining it for a while at least.
21:37:40 <ddarius> And apparently, it isn't going to be as simple as simply deriving Data/Typeable (?)
21:39:06 <ddarius> Ah, I suspect I know what the problem is.
21:39:36 <ddarius> Okay, done Cale.
21:41:30 <siti> :t bracket
21:41:35 <lambdabot> Not in scope: `bracket'
21:41:47 <shachaf> @ty IO.bracket
21:41:48 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:41:58 <siti> cheers :p
21:42:15 <dons> Igloo: X11 package needs to be in debian. can you hand this on to nomeata?
21:46:34 <brian`> hey what was the name of the function like while? I remember seeing a function usage as follows:
21:46:40 <ddarius> until?
21:46:40 <dons> until ?
21:46:42 <brian`> while ( some condition ) repeat take
21:46:45 <brian`> oh.. is it until ?
21:46:46 <brian`> hehe
21:46:47 <brian`> :t until
21:46:48 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
21:46:57 <brian`> yeah i think that's it :)
21:47:16 * brian` forgot everything about Haskell... :(
21:47:40 * ddarius has rarely used until
21:53:26 <dons> Cale, don't reply. disingenuous, anonymous trolls don't need to be fed.
21:54:00 <Cale> I always worry a bit about the other people reading the thread though. I suppose this is long enough that most won't bother now.
21:54:54 <brian`> how can I write this in more elegant way?
21:54:54 <paczesiowa> what trolls are you talking about?
21:54:55 <brian`> split n s = split' n s
21:54:55 <brian`>     where
21:54:55 <brian`>       split' n' "" = ""
21:54:58 <brian`>       split' n' s' = take n' s' ++ " " ++ split n' (drop n' s')
21:55:12 <brian`> > split n s = split' n s
21:55:12 <lambdabot>  Parse error at "=" (column 11)
21:55:40 <brian`> hm.. can I not type that function to lambdabot..?
21:55:51 <shachaf> brian`: You could, but lambdabot isn't ghci.
21:56:01 <shachaf> brian`: You'd need @let and semicolons.
21:56:03 <Cale> ddarius: btw, is the new version on hackage, or are you piling up changes?
21:56:42 <paczesiowa> brian`: how about this http://hpaste.org/annotate/4817?oldId=0 ?
21:56:44 <thoughtpolice> @index Addr
21:56:44 <lambdabot> bzzt
21:56:48 <shachaf> brian`: Do you really want to add the final space, by the way?
21:56:59 <ddarius> Cale: Once I get space on code.haskell.org, I'll put a repo there.  Then I'll have people play with it a while (hopefully), then to hackage and an announce on the mailinglist.
21:57:15 <brian`> shachaf, don't need final space.. how do i get rid of it?
21:57:20 * shachaf would suggest making this work on any a, and adding that spaces, later.
21:57:30 <shachaf> s/s, /s /
21:57:40 <Cale> ddarius: Are there other changes?
21:58:01 <ddarius> Cale: This is Paolo Martini's SoC project.
21:58:01 <jfredett> bon soir, peoples
21:58:08 <Cale> ddarius: Oh! I see :)
21:58:33 <Cale> (I thought you were editing vs. 2.1)
21:59:00 <Cale> But there's little point in that if you're about to release 3.0 :)
21:59:26 <paczesiowa> new parsec?
21:59:30 <Cale> yeah
21:59:39 <Cale> It's a monad transformer now, right?
21:59:47 <ddarius> Yes.
21:59:56 <Cale> cool :)
21:59:56 <paczesiowa> can we have followedBy pls?
22:00:43 <ddarius> As in p >> lookAhead q ?
22:01:24 <ddarius> paczesiowa: I don't understand what you mean.
22:01:29 <shachaf> brian`: split n = unfoldr (\x -> guard (not (null x)) >> return (splitAt n x)) -- I think
22:01:48 <paczesiowa> let p1 `followedBy` p2 = do { x<- p1; p2; return x}
22:02:16 <Cale> paczesiowa: Oh, that's rather different from what I'd have expected it to mean.
22:02:17 <shachaf> brian`: And then use something like (intercalate " ") if you want the spaces.
22:02:31 <sjanssen_> paczesiowa: see Control.Applicative
22:02:32 <ddarius> paczesiowa: I added Applicative instances, so you can use the Applicative combinators
22:02:32 <Cale> paczesiowa: You want the characters eaten by the second parser to really be eaten?
22:03:14 <paczesiowa> there is notFollowedBy so it would be nice to have the opposite of that.
22:04:06 <paczesiowa> Cale: depends, I don't really "need" that and if I do it's easy to write but there are plenty of useful parsers so why not add more
22:05:09 <dons> Cale, stop! no more comments.
22:05:12 <Cale> paczesiowa: But notFollowedBy doesn't consume any additional characters.
22:05:14 <Cale> dons: heh
22:05:14 <dons> trolls live on evil energy
22:05:36 <ddarius> Cale isn't evil.  At least, I don't think he is.
22:05:47 <paczesiowa> what trolls? how can I get one:D
22:06:33 <dons> Cale, note that his next topic also doesn't appear on the 'new' page
22:06:41 <dons> so his IP is blocked somehow
22:06:49 <dons> (maybe similar accounts used for trolling in the past?)
22:06:51 <Cale> Not too evil. I end up starting a holy war that wipes out over 90% of the population on Earth, but, uhh... that's not going to happen for a while, so you needn't worry.
22:07:11 <ddarius> Cale: We could afford to lose a little.
22:07:14 <dons> Cale, did you see http://reddit.com/r/programming/info/66y4q/comments/
22:07:27 <Cale> dons: heh
22:07:28 <dmwit> Cale: Have you also developed psychohistory, to predict that?
22:07:55 <paczesiowa> Cale: it would be nice to say myParser `followedBy` eof (and yes I know what eof really is, but I love parsec for it's "verbosity")
22:07:58 <ddarius> Cale: Yeah, it's not really worth your time.
22:08:06 <Cale> dons: heh, I wish that one had been posted. My reply just makes him look like a dick.
22:08:11 <dons> Cale, it might be 'haskellist' actually. very similar style
22:08:15 <ddarius> myParser <* eof
22:08:27 <dons> Cale, and haskellist stopped trolling about the time this guy started...
22:08:52 <dons> Cale, note the ocaml/haskell obsession, and http://reddit.com/user/haskellist/
22:08:59 <Cale> yes
22:09:10 <Cale> It does seem like haskellist to me.
22:09:28 <dons> i'm glad the name changed.
22:09:36 <paczesiowa> ddarius: is this Control.Applicative thingie? because I've never used that
22:09:49 <Cale> That or JDH really has nothing better to do.
22:10:13 <bos> paczesiowa: yes
22:10:15 <ddarius> paczesiowa: I think it's a combinator defined in that module, or maybe just a common one on top of it.  I don't use Applicative either.
22:10:17 <dons> hmm. no, i don't think its jdh.
22:10:24 <dons> he's in his own weird headspace
22:10:25 <Cale> Yeah, it's not really his style.
22:10:26 <ddarius> @hoogle <*
22:10:26 <lambdabot> Control.Applicative.(<*) :: Applicative f => f a -> f b -> f a
22:10:26 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:10:26 <lambdabot> Control.Applicative.(<**>) :: Applicative f => f a -> f (a -> b) -> f b
22:10:34 <ddarius> Et voila
22:10:45 <bos> <* runs both sides, but only returns the result of the left
22:11:01 <paczesiowa> sounds powerful
22:11:04 <bos> Control.Applicative is a lot of fun.
22:11:20 <bos> you can build up these devilish chains of code with it.
22:11:47 <dons>  byzantine even.
22:12:48 <bos> as in liftM2 (,) (char '(' *> literal <* spaces <* char ',') (spaces *> literal <* spaces <* char ')')
22:13:01 <bos> which parses a tuple and returns a tuple of the parsed elements
22:13:09 <bos> er, liftA2, not liftM2
22:13:17 <ddarius> It should work either way.
22:13:33 <bos> if you're using Parsec, yes.
22:13:52 <bos> but not all applicative functors are also monads.
22:13:57 <ddarius> I know.
22:14:08 <bos> yes, but you know a lot, and i wasn't talking to you.
22:15:21 <bos> by which i mean no disrespect, in case it read that way.
22:15:22 <Cale> dons: heh, then there was the ridiculous discussion on the xmonad article regarding comments.
22:16:33 * ddarius goes to sleep.
22:16:51 <dons> Cale, oh man
22:17:12 <dons> comments are a conspiracy to sneak inscrutable haskell code into small children's brains
22:19:27 <wagle_> @pl {- this code is very strange, think about it thoroughly -}
22:19:27 <lambdabot> (line 1, column 1):
22:19:27 <lambdabot> unexpected "{"
22:19:27 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:19:51 <Cale> @pl -- this code is very strange, think about it thoroughly
22:19:51 <lambdabot> (line 1, column 1):
22:19:52 <lambdabot> unexpected "-"
22:19:52 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:20:06 <Cale> @pl id -- this code is very strange, think about it thoroughly
22:20:06 <lambdabot> id
22:20:18 <shachaf> @pl (:[{- No comment support? -}])
22:20:18 <lambdabot> return
22:20:40 <Cale> It just doesn't like empty expressions.
22:21:00 <Cale> @pl {- testing -} id
22:21:00 <lambdabot> (line 1, column 1):
22:21:00 <lambdabot> unexpected "{"
22:21:00 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:21:03 <shachaf> @pl {- This should work, though -} id
22:21:04 <lambdabot> (line 1, column 1):
22:21:06 <lambdabot> unexpected "{"
22:21:08 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:21:23 <wagle_> @pl swing
22:21:23 <lambdabot> swing
22:21:30 <wagle_> awww
22:23:59 <Cale> dons: heh, he (or someone) appears to have deleted a bunch of his comments.
22:24:48 <phlpp> :t swing
22:24:49 <wvd> hello
22:24:50 <lambdabot> Not in scope: `swing'
22:24:55 <dmwit> Hiya, wvd!
22:25:01 <sjanssen_> damned joelr and his blog :(
22:25:11 <dmwit> Your name is hard to type, and too short for tab-completion.
22:25:21 <wagle_> @let swing = flip . (. flip id)
22:25:25 <lambdabot> Defined.
22:25:29 <wvd> my name?
22:25:34 <dmwit> yes
22:25:34 <shachaf> dmwit: wv\t works for me.
22:25:47 <wagle_> @pl swing swing swing swing swing -- grok THIS, kid
22:25:48 <lambdabot> swing swing swing swing swing
22:25:53 <shachaf> dmwit: (It's just as many keystrokes, of course.)
22:25:54 <wagle_> bah
22:25:56 <dmwit> shachaf: That's a real win...
22:26:01 * sclv hearts swing
22:26:06 <sclv> :t swing swing swing swing
22:26:06 <shachaf> dmwit: (But still possibly easier to type, if you're used to tabbing a lot.
22:26:07 <lambdabot> Not in scope: `swing'
22:26:07 <lambdabot> Not in scope: `swing'
22:26:07 <lambdabot> Not in scope: `swing'
22:26:20 <wvd> terse is good
22:26:31 <sclv> :t let swing = flip . (.flip id) in swing swing swing swing swing
22:26:31 <lambdabot> forall a c b c1 a1 c2. (a1 -> ((((a -> c) -> c) -> b -> c1) -> b -> a -> c1) -> c2) -> a1 -> c2
22:26:38 <wvd> surely as a functional programmer you should agree :P
22:26:41 <sclv> why am i doing this again?
22:26:46 <wagle_> @pl let swing = flip . (. flip id) in swing swing swing swing swing -- grok THIS, kid
22:26:46 <lambdabot> flip flip (flip . (. flip id))
22:27:15 <dmwit> wvd: Nonsense, I give all my variables readable names. =)
22:27:34 <shachaf> dmwit: Like "a" and "b"? :-)
22:27:36 <wagle_> my recollection is that swing swing swing swing swing == swing
22:27:51 <dmwit> shachaf: Now let's be fair... sometimes I use "as".
22:28:42 <raxas__> dmwit: how should we read "dmwit", exactly?
22:28:58 <shachaf> "dmwit Flathead"!
22:29:06 <dmwit> raxas__: "dmwit" is pronounced "your highness"
22:31:57 <shachaf> "Three undertrumps after an opponent discards a Trebled Fromp"!
22:32:01 <wvd> is anyone using haskell for web development?
22:32:03 <shachaf> zork++
22:32:08 <dmwit> Yes!
22:32:11 <dons> wvd, yes!
22:32:16 <dmwit> I highly recommend not using WASH.
22:32:22 <dons> seems like good advice
22:32:32 <dons> fastcgi ftw!
22:32:43 <dmwit> happs comes highly recommended, though I haven't used it my ownself.
22:32:52 <dons> i think recent happs or fastcgi are both known to be good
22:33:17 <dons> http://reddit.com/r/programming/info/66y74/details cale
22:34:22 <Cale> Well, *that's* a strange observation.
22:35:03 <dons> honest to goodness troll
22:35:09 <dons> also mentally ill
22:35:42 <sjanssen> do people seriously still use the term "shareware"?
22:35:45 <Cale> I personally don't fully understand what would possess one to write a shareware application in the first place, but that's just me.
22:36:00 <ivanm> apparently
22:36:22 <Cale> Like, what is this, 1993?
22:36:48 <ivanm> recently someone made up a fake app (i.e. an empty file) and submitted it to multiple "shareware" sites
22:36:53 <ivanm> most of them gave it a good review
22:37:09 <mgsloa1> hah. everything in my text editor is a zipper
22:37:21 <Cale> mgsloa1: That makes sense :)
22:37:28 <mgsloa1> it does, doesn't it? :)
22:37:42 <kmcallister> awesome, i just wrote a graphing calculator in 40 lines of haskell using Gtk2Hs, glade, and hs-plugins
22:37:49 <dons> kmcallister: nice :)
22:38:04 <ivanm> oohhh...
22:38:07 <dons> we had a little calculator using mocha, objective C and hs-plugins in the hs-plugins paper
22:38:11 <kmcallister> dons, you wrote hs-plugins, yes?
22:38:12 <dons> good to see the tradition lives on.
22:38:13 <ivanm> kmcallister: what do you use for the actual graphs?
22:38:15 <dons> kmcallister: yeah
22:38:17 <ivanm> the chart library?
22:38:18 <Pseudonym> Haskell is the choice of discriminating hackers, not wannabe floppy traders.
22:38:28 <dons> let's trade floppies!
22:38:40 <kmcallister> dons, it's a fantastic library... i never would have expected eval to have such simple type
22:38:47 <Pseudonym> Software EXchange!
22:38:57 <ivanm> Pseudonym: you wish :p
22:38:58 <kmcallister> ivanm, just a GTK drawing area
22:39:13 * Pseudonym is old enough to remember that term
22:39:22 <dons> Cale, any idea who consultant_barbie is? :)
22:39:22 <Pseudonym> Major source of viruses.
22:39:25 <ivanm> so custom graphing functions? or is it a GTK method?
22:39:26 * dons looks around #haskell
22:39:30 <Cale> No idea. :)
22:39:45 <kmcallister> ivanm, custom
22:39:46 <dons> awfully clued in about haskell
22:40:03 <kmcallister> used line drawing functions
22:40:15 <dons> Cale, a lot of wisdom, http://reddit.com/user/consultant_barbie/ :)
22:40:30 <kmcallister> it's very minimal... it plots a single function of type Double -> Double as a 2D graph on domain/range [0..1]
22:40:31 <ivanm> kmcallister: didn't want/need/know about the chart library?
22:40:36 <kmcallister> didn't know
22:40:39 <ivanm> ahhh
22:41:06 * ivanm is still waiting for droundy to release his matlab-based extension to it
22:41:12 <wvd> I'm checking out happs, but it looks like another web development framework that comes with a httpd built in, am I forced to use it or can I host my happs app via apache?
22:41:49 <Cale> "Trivial things are hard. Let's go shopping!"
22:41:51 <dons> Cale, haskell shareware, http://easyweb.easynet.co.uk/~mac/
22:41:51 <lambdabot> Title: RhinoSoft Haskell IDE
22:42:07 <Cale> haha!
22:42:50 <dons> oh the memories. shareware on the mac
22:45:48 <Cale> Actually, I used OS X a few years back and was surprised at the amount of trivial stuff which people expected you to pay for.
22:47:25 <Cale> Quick hacks that couldn't have been more than 100 lines of code implementing some feature that should have come with the OS to begin with, and they want money for it. No releasing things just because it'll help people out.
22:47:55 <sjanssen> Cale: yeah, it's a weird culture
22:48:02 <Cale> Then there were the funny people on the quicksilver forums which wanted the QS developers to charge money for it.
22:48:26 <ivanm> hang on, people _wanted_ to pay money for something?
22:48:35 <ivanm> (what is/was quicksilver, anyway?)
22:48:36 <Cale> "Why can't I pay you for this?! Couldn't you at least open a PayPal account?"
22:48:52 <vegai> ivanm: Of course. Why would they choose Mac otherwise?
22:49:28 <Cale> ivanm: It's a UI enhancement where you hit Shift-space (or similar) and type the first few characters of something you're looking for and it pulls it up.
22:49:29 <dejones> Cale and dons, what timezone are you guys in?  You always seem to be up late.  ;)
22:49:35 <ivanm> vegai: because they hate windows enough not to use it, but not to go the next step and use a FLOSS OS?
22:49:44 <Cale> I'm in Eastern time (Canada)
22:49:49 <Cale> It's 1:49 am.
22:50:16 <dejones> Cale: I just switched back to Linux from having a MacBook for the exact reason you just described... I missed all the free packages, especially development tools.
22:50:35 <dejones> Cale: same for me.  (Lexington, Kentucky at Univ. of Kentucky)
22:50:39 <vegai> I would miss my GUI...
22:50:42 <wagle_> i install a lot of linux stuff on my mac
22:50:58 <kmcallister> http://www.finkproject.org/
22:50:59 <lambdabot> Title: Fink - Home
22:51:05 <wagle_> also macports
22:51:13 <ivanm> and Gentoo Prefix ;-)
22:51:23 <Cale> My main problem with OS X was the gui.
22:51:26 <dejones> kmcallister: fink is nice, and so is macports.. but they don't have near the number of packages that debian has, nor the support...
22:51:29 <dejones> but, it is a start.
22:51:37 <dobblego> does python have foldl?
22:51:48 <sclv> python has reduce.
22:52:24 <Cale> Also, the installer mechanism was pretty lame, iirc.
22:52:26 <sclv> vis a vis os x, fink and macports lock you in way too much. the apple developer toolkit and just compiling what you need by hand ftw.
22:52:28 <dons> any englishmen in here?
22:52:29 <dejones> Cale: have you read Dijkstra's "A Discipline of Programming" ?  Or anyone else read it?
22:52:34 <dons> what's a good strong breakfast tea?
22:52:39 <wagle_> has all the packages i want..  (and I have a "big iron" linux machine at home to login to..  (mac is a notebook, and suspend just works, etc)
22:52:48 <Maddas> Cale: You should have tried fixing xmonad on OS X instead of discarding OS X entirely! :-)
22:52:58 <sclv> i got xmonad working on os x fine.
22:53:07 <ivanm> sclv: tried gentoo prefix? that compiles everything... :p
22:53:10 <Maddas> Ooo. Did you have to do anything special?
22:53:18 <dons> there's an faq for osx/xmonad
22:53:22 <sclv> nope. out of the box. this is back with 0.4
22:53:23 <Maddas> Oops, thanks.
22:53:26 <dejones> anyone read Dijkstra's "A Discipline of Programming", comments?
22:53:40 <dons> http://haskell.org/haskellwiki/Xmonad/Using_xmonad_on_Apple_OSX
22:53:41 <Cale> Maddas: I didn't so much discard OS X as just stopped working for the people who owned the Dual G5 PowerMac and 6 G5 Xserves I was using.
22:53:43 <sclv> its just a pain because, obviously, it doesn't play well with any apps on os x that aren't X11
22:53:46 <dons> yeah
22:53:51 <Maddas> The first time I tried xmonad on OS X I hadn't met anyone who was able to help me with compiling it, but that was version 0.2.
22:54:05 <dons> :)
22:54:06 <Cale> (also, xmonad didn't exist back then)
22:54:19 <Maddas> sclv: Right, but the reason to use xmonad is for X11 apps :-)
22:54:29 <Maddas> (Actually, it's the other way around for me, but never mind that :-))
22:54:42 <dons> that's right. though i do sometimes get queries about whether it will run on windows
22:54:44 <sclv> hmm... actually as i recall i had to do some stupid things to make sure it found the X11 libraries
22:54:48 <dons> and why did we make it unnec. unportable
22:54:52 <ivanm> Maddas: you use X11 apps just to run xmonad?
22:54:53 <Cale> I wish one could replace OSX's windowmanager.
22:55:07 <shachaf> ivanm: The other way around, I think.
22:55:09 <Cale> (like, for native windows)
22:55:30 <sclv> you can skin it with, uh, shareware.
22:55:30 <ivanm> shachaf: he did say it's the other way round for him...
22:55:33 <ivanm> heh
22:55:40 <Maddas> ivanm: Yes.
22:56:05 <Maddas> (Just so I have a reason to run xmonad, that is.)
22:56:51 <ivanm> shachaf: see? :p
22:57:17 <hpaste>  mgsloan pasted "Zippa!" at http://hpaste.org/5311
22:58:32 <shachaf> Oh, sorry.
22:58:35 * shachaf misread.
22:58:53 <ivanm> so you should be! :p
23:00:47 <siti> should there be support for ./haskellprogam +RTS -N2 in the latest ghc?
23:00:49 <siti> (6.8.2)
23:00:57 <siti> I don't have the argument available :S
23:01:01 <ivanm> yes, IIRC
23:02:17 <siti> oh oops, yeah I have to compile with the right flag
23:02:19 <siti> silly me
23:03:20 <siti> sweet parallism goodness :)
23:05:57 <Cale> siti: what are you parallelising?
23:06:16 <siti> fuzzing
23:07:35 <Cale> Something like quickcheck?
23:07:47 <siti> nah, for programs
23:14:56 <dons> sit, compile with -threaded
23:15:09 <dons> and you'll need to of course structure your program for parallelism
23:15:14 <dons> (with forkIOs or pars )
23:16:34 <siti> yeah I just forgot -threaded
23:16:45 <siti> it's working fine...
23:16:47 <dons> seeing speedups now?
23:16:59 <siti> yeah, I had a worker thread function already made
23:17:06 <siti> it forks perfectally
23:17:06 <dons> cool
23:26:13 <Trinithis> @src ($)
23:26:13 <lambdabot> f $ x = f x
23:26:31 <xpika> is there a haskell library like this? http://www.deveiate.org/projects/Linguistics/
23:26:32 <lambdabot> Title: Ruby Linguistics - Trac
23:26:56 <Trinithis> is there a built in composition function with the type: (a -> b) -> (d -> c -> a) -> d -> c -> b
23:27:42 <Trinithis> something like: compose f g a b = f $ g a b
23:29:28 <xpika> "box".en.plural # => "boxes" , "sheep".en.plural # => "sheep"
23:31:01 <shachaf> @ty (.) . (.)
23:31:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:31:11 <shachaf> Trinithis: Sometimes called "dot".
23:31:18 <Trinithis> ah
23:31:43 <wagle_> i thought that looked familier
23:32:02 <shachaf> @wiki Pointfree
23:32:02 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
23:32:33 <Trinithis> what does ((.)$(.)) do?
23:32:50 <sclv> ?ty  ((.)$(.))
23:32:52 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
23:33:39 <wagle_> ?ty swing
23:33:40 <lambdabot> forall a c1 b c. (((a -> c1) -> c1) -> b -> c) -> b -> a -> c
23:33:58 <wagle_> ?ty swing swing
23:33:59 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
23:34:08 <sclv> ?ty \f g -> f . (.g)
23:34:09 <lambdabot> forall c b c1 a. ((a -> c1) -> c) -> (a -> b) -> (b -> c1) -> c
23:34:21 <wagle_> ?ty swing swing swing
23:34:23 <lambdabot> forall a c a1 c1 b c11. (a -> ((((a1 -> c1) -> c1) -> b -> c11) -> b -> a1 -> c11) -> c) -> a -> c
23:34:28 <wagle_> ?ty swing swing swing swing
23:34:30 <lambdabot> forall a c1 b c a1 c11 c12. (((a1 -> c11) -> c11) -> ((((a -> c1) -> c1) -> b -> c) -> b -> a -> c) -> c12) -> a1 -> c12
23:34:33 <shachaf> @unpl (.) (.)
23:34:33 <lambdabot> (\ b c e f -> b c (e f))
23:34:35 <wagle_> ?ty swing swing swing swing swing
23:34:36 <lambdabot> forall a c1 b c a1 c11. (a1 -> ((((a -> c1) -> c1) -> b -> c) -> b -> a -> c) -> c11) -> a1 -> c11
23:34:43 <sclv> its the glen miller style of programming.
23:35:22 <wagle_> ?ty swing swing swing swing swing swing
23:35:23 <lambdabot> forall a c1 b c a1 c11 c12. (((a1 -> c11) -> c11) -> ((((a -> c1) -> c1) -> b -> c) -> b -> a -> c) -> c12) -> a1 -> c12
23:35:29 <olsner> what's swing defined as?
23:35:44 <wagle_> hmm..  used to cycle..  the type checker is weak or something
23:36:00 <sclv> swing = flip . (. flip id)
23:36:09 <wagle_> yeah
23:36:12 <olsner> @unpl  flip . (. flip id)
23:36:13 <lambdabot> (\ k b c -> k (\ f -> f c) b)
23:36:19 <sclv> wagle_: i thought it was fmap that cycled.
23:38:13 <sclv> hmm.. there is something goofy about the typechecker.
23:38:24 <sclv> ?ty fmap fmap fmap fmap fmap fmap
23:38:25 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
23:38:47 <sclv> ?ty let buffalo = fmap in buffalo buffalo  buffalo buffalo buffalo buffalo
23:38:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
23:38:49 <lambdabot>     Probable cause: `buffalo' is applied to too few arguments
23:38:49 <lambdabot>     In the fourth argument of `buffalo', namely `buffalo'
23:39:17 <sclv> the dreaded mr?
23:40:16 <sclv> ty let buffalo = fmap; buffalo::(Functor f) => (a -> b) -> f a -> f b in buffalo buffalo  buffalo buffalo buffalo buffalo
23:40:23 <olsner> hurgh, the MR affects type checking?
23:40:25 <sclv> ?ty let buffalo = fmap; buffalo::(Functor f) => (a -> b) -> f a -> f b in buffalo buffalo  buffalo buffalo buffalo buffalo
23:40:27 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
23:40:42 <sclv> apparently so
23:40:57 <yuri_> what do I need to have installed besides GHC to be able to get cabal packages from Hackage?
23:41:00 <wagle_> huh..  neither ghci nor hugs thinks swing cycles..  musta been the lambdabot about two years ago
23:41:52 <wvd> I have a small haskell program that segfaults, is there anywhere I can paste it so I can get some help with it?
23:42:03 <bos> !paste
23:42:03 <hpaste> Haskell paste bin: http://hpaste.org/
23:42:07 <sclv> ?ty let swang = flip . (.flip id); swang::(((a -> c1) -> c1) -> b -> c) -> b -> a -> c in swang swang swang swang swang swang swang swang swang swang
23:42:09 <lambdabot> forall a c1 b c a1 c11 c12. (((a1 -> c11) -> c11) -> ((((a -> c1) -> c1) -> b -> c) -> b -> a -> c) -> c12) -> a1 -> c12
23:42:19 <sclv> ?ty let swang = flip . (.flip id); swang::(((a -> c1) -> c1) -> b -> c) -> b -> a -> c in swang swang swang swang swang swang swang swang swang swang swang swang swang swang swang
23:42:20 <lambdabot> forall a c1 b c a1 c11. (a1 -> ((((a -> c1) -> c1) -> b -> c) -> b -> a -> c) -> c11) -> a1 -> c11
23:42:33 <sclv> type hints ftw.
23:42:43 <wagle_> i did this a while ago: @pl let swing = flip . (. flip id) in swing swing swing swing swing -- grok THIS, kid
23:43:12 <olsner> @pl let swing = flip . (. flip id) in swing swing swing swing swing
23:43:13 <wagle_> oops, i mean this: @let swing = flip . (. flip id)
23:43:13 <lambdabot> flip flip (flip . (. flip id))
23:43:19 <hpaste>  wvd pasted "segfaulting sqrt function" at http://hpaste.org/5312
23:43:52 <sjanssen> wvd: oh my, this segfaults?
23:44:00 <sclv> yuri_: you shouldn't need to. if you want to install them from the command line you need cabal-install. but if you just download the packages it should Just Work.
23:44:20 <Cale> wvd: How did you compile it and which version of GHC are you using?
23:44:30 <Cale> (I don't get the segfault here.)
23:44:42 <olsner> (worksforme)
23:44:53 <wvd> Glasgow Haskell Compiler, Version 6.6.1, for Haskell 98, compiled by GHC version 6.6.1
23:44:58 <wvd> no extra flags
23:45:04 <Cale> hmm
23:45:08 <wvd> just doing ghc -o test ./test.hs
23:45:27 <wvd> on mac os x 10.5.1 I should mention
23:45:32 <Cale> hmm
23:45:37 <sjanssen> wvd: what architecture?
23:45:38 <yuri_> sclv: so for instance I would go to the HApps site, download the package and do what? Should I expand it myself?
23:45:41 <wvd> intel
23:45:42 <sclv> leopard has known issues with ghc installs.
23:45:51 <sclv> HAppS is funny.
23:45:53 <yuri_> sclv: sorry, I am just starting with Haskell
23:45:54 <Cale> I'm on linux, and I'm not getting a segfault with either 6.6.1 or 6.8.2
23:46:15 <wvd> I'll check macports for a newer ghc
23:46:17 <sclv> don't start with haskell with HAppS. but if you do, follow their instructions and use searchpath.
23:46:20 <wagle_> awww..  now you tell me..  i'm right in the middle of installing leopard
23:46:23 <sjanssen> wvd: do simpler programs (like hello world) execute successfully?
23:46:43 <Cale> Um, hang on...
23:46:44 <wvd> checking...
23:46:45 <sclv> the way to use it with leopard as i recall is to download the binary directly from haskell.org/ghc
23:47:13 <Cale> http://www.haskell.org/ghc/dist/6.8.2/chakravarty/ghc-6.8.2-i386-apple-darwin.tar.bz2 -- this is a Leopard binary
23:47:14 <lambdabot> http://tinyurl.com/32u3sr
23:47:20 <sclv> lots of people have it up and running with leopard, it just takes a little doing because they changed how the linker works.
23:47:20 <Trinithis> how do i import a module?
23:47:32 <Cale> http://www.haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-apple-darwin.tar.bz2 -- and this is for Tiger
23:47:33 <lambdabot> http://tinyurl.com/2axl2g
23:47:34 <sjanssen> Trinithis: import SomeModule
23:47:58 <wvd> yep, hello world works find (main = putStrLn "Hello World!")
23:48:05 <wagle_> does it install someplace nice, like /usr/local/...?
23:48:28 <Cale> It should install to /usr/local/
23:48:37 <Cale> uh, but I'm not entirely sure
23:48:38 <sclv> yuri_: seriously. HaPPs is still in development and not for the faint of heart necessarily. even if you learn its innards it doesn't teach you lots about how you should expect haskell code to work normally.
23:49:28 <Cale> Oh, the 10.5 package also says that if you have a GMP.framework installed leftover from 10.4, remove it first.
23:49:31 <wagle_> i'll find out
23:49:46 <olsner> wvd: http://trac.macosforge.org/projects/macports/ticket/13407 if you feel like patching your ghc portfile
23:49:48 <lambdabot> Title: #13407 (RFE: ghc update to 6.8.1) - MacPorts - Trac
23:49:55 <yuri_> sclv: I see. My goal is to use Haskell to develop simple web apps in the near future so I thought I could give a try with HAppS.
23:50:21 <siti> haskell is quite young so the web frameworks are quite immature
23:50:38 <sclv> the binary packages for the mac install everything where it should go. they're just prebuilt.
23:50:51 <sclv> for simple webapps the fastcgi bindings are generally recommended.
23:50:55 <Cale> Well, as a popular language, it's pretty young :)
23:51:08 <siti> that's what I mean ;)
23:51:34 <siti> it's currently making the transition from academic to  real world language :)
23:51:35 <sclv> and as part of putting together a frameworkish package, let me make a little pitch for my HStringTemplate library. :-)
23:53:21 <wagle_> its older than java...  8)
23:54:02 <siti> true...
23:54:05 <sclv> and if a company bigger than sun was supporting it like, say micro... oh. wait.
23:54:32 <siti> heh
23:54:43 <yuri_> my goal is to generate html, xml and json backed by a relational db
23:54:54 <yuri_> standard web stuff
23:55:12 <siti> yeah, bindings to *sql aren't very nice IMO
23:55:22 <yuri_> it is ok for me if the frameworks are immature. As long as they are moving along ..
23:55:23 <siti> I have not played with Happs db solution though
23:55:27 <siti> ok
23:55:36 <sclv> they're not as well supported as they could be, i understand.
23:56:32 <sclv> haskell has awesome xml libs, html is a standard extra-lib and rJSON looks supercool.
23:56:52 <siti> yep
23:57:10 <siti> it would be nice if the html/xhtml modules were fully type checked
23:57:21 <siti> so you create fully type checked and complaint html :D
23:57:56 <yuri_> siti: I thought that that was the case (fully type checked html/xhtml)
23:58:36 <siti> well the modules I have seen use a lot of string
23:58:47 <siti> for the options
23:58:59 <siti> the raw structure is checked though
23:59:47 <lakupuu> /ss
23:59:49 <siti> is there a way to call waitForProcess with a time out?
