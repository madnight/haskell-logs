00:00:07 <andyjgill>    @pl \ x -> fix x
00:01:02 <Cale> andyjgill: fix
00:01:27 <Korollary> @calesnack
00:01:27 <mbot> Unknown command, try @list
00:01:37 <Cale> :)
00:01:37 <andyjgill> I wondered if would find a neat alternative to fix
00:01:54 <andyjgill> but its just gone into a loop
00:02:11 <nolrai> fix is not very useful.
00:02:16 <Cale> It didn't reply since you put a space before your command.
00:02:21 <Cale> @pl \ x -> fix x
00:02:21 <mbot> fix
00:02:36 <andyjgill> Ahh
00:02:45 <nolrai> imho
00:03:08 <andyjgill> @pl \ f g -> fix (f . g)
00:03:08 <mbot> (fix .) . (.)
00:03:46 <andyjgill> @pl \ f g h -> fix (f . g . h)
00:03:47 <mbot> ((fix .) .) . (. (.)) . (.) . (.)
00:04:46 <andyjgill> fix can also be your friend
00:04:59 <nolrai> how
00:05:50 <andyjgill> Because f = fix (...) is a non-recursive binding
00:06:28 <andyjgill> So you can inline f anywhere.
00:07:15 <nolrai> theres inlining in haskell?
00:07:37 <dons> lots of it.
00:08:04 <andyjgill> Hi Dons!
00:08:14 <dons> heya andyjgill
00:08:20 <andyjgill> Just finished a bit of beamer hacking.
00:08:24 <dons> oh, cool.
00:08:38 <conal> andyjgill: lhs2tex+beamer?
00:08:48 <andyjgill> I love how it can animate transformations
00:09:02 <nolrai> whats beamer?
00:09:03 <andyjgill> conal: cough, yes
00:09:14 <andyjgill> latex package for slides.
00:09:52 <conal> andyjgill: nifty.  i want to use beamer for my next presentation.  was it tricky to use with lhs2tex?
00:10:22 <andyjgill> Not as long as you remember to use || and @@.
00:10:38 <andyjgill> But if you want to animate marked up code, that was tough
00:10:39 <conal> :)
00:11:07 <andyjgill> I reverted to semiverbatim, and ASCII Haskell
00:11:21 <conal> what kind of code animation?
00:12:01 <andyjgill> Preparing movie...
00:18:35 <andyjgill> Was not really worth the wait, but http://movies.unsafeperformio.com/beamerani.mov
00:19:08 <andyjgill> You can also replace code on the fly, doing things like beta-reduction
00:19:35 <andyjgill> hi augustss
00:19:43 <augustss> hi
00:20:14 <Cale> Check the spelling on "recursive" on the last line there -- the movie ended, but it looked like it might have been misspelled.
00:20:16 <dmwit> andyjgill: Dunno if you've done the grammar pass yet, but recusrive -> recursive. ;-)
00:20:29 <andyjgill> It *is* misspelt :-)
00:21:24 <andyjgill> The point is it is easy to build some "here is how the code is changing over time" slides
00:21:30 <dmwit> yeah
00:21:38 <dmwit> That's pretty cool!
00:21:40 <Cale> Yeah, beamer is cool :)
00:21:55 <Cale> TeX in general is really cool :)
00:23:04 <andyjgill> augustss: you had some Haskell commands for writing slides?
00:23:48 <soduko> is Network.URI in the extra libs?
00:24:52 <dons> its in the 'network' lib, which is one of the extras, yes.
00:27:09 <soduko> dons: do we have to go into each library adn do configure etc.. ?
00:31:36 <soduko> err never mind
00:38:48 <C-Keen> good morning
00:39:01 <sizur> C-Keen: good morning
00:40:06 <C-Keen> ha! ghc-8.2 build finally
00:42:45 <dons> int-e: so the defaults should work now. if you darcs pull. (and 'make' the tests in tests/ )
00:49:45 <zeno> hmmm wheres lambdabot
00:50:00 <thoughtpolice> apparently sick right now.
00:50:10 <dons> nope, still can't connect
00:52:09 <int-e> dons: ok, it works here
00:55:30 <roconnor> Does the strictness analyser unbox things for you?
00:56:29 <thoughtpolice> strictness implies unboxedness, does it not?
00:57:05 <roconnor> thoughtpolice: I think strictness usually only affects evaluation order.
00:58:34 <C-Keen> I'd like to ask for some advice on how to model this data: I have got a ByteString and want to create a Data Constructor form it (data F = F { Field::Type, ...}) The first fields contain some Bool Flags whose settings depend whether some of the following Fields exist. I think it would be good to model those like pcr::Maybe DataField. Another way would be to construct the type on the fly and omitting the nonexistant fields. (I am not sure wether you can do th
00:58:49 <thoughtpolice> well what I mean is, if something is strict in its arguments, it doesn't need the box to tell it how to compute the element. it should be already computed and passed in an unboxed fashion since the value is after all, strict.
00:59:07 <C-Keen> So should I go for the Maybe approach or omitting those values?
00:59:33 <ketil> thoughtpolice, I think it is more complicated than that (e.g. the value may need to be reboxed to pass to subsequent functions)
01:00:32 <thoughtpolice> ketil: i'm fairly certain it is, i'm not a guru on the subject, i only say so because that's the general idea I've gotten of it (since people here have said the same thing and plus if you use bang patterns with things like your function parameters, you'll notice in core output ghc will unbox the types)
01:00:42 <ketil> C-Keen, I vote for Maybe - or a more elaborate structure, reflecting the underlying data model.
01:01:14 <ketil> C-Keen, bool flags seems like a hack you might find in Less Worthy languages :-)
01:02:00 <ketil> thoughtpolice, I agree - unboxing is often the reason you want to add strictness.
01:02:03 <thoughtpolice> second vote for Maybe.
01:02:09 <C-Keen> ketil: yeah, well that's how it is encoded, I haven't been abstracting them away yet
01:02:42 <kmcallister> does GHC fuse nested constructors?
01:04:03 <kmcallister> i.e. if i have a Maybe (Maybe Int) will it store both constructors in the same word?
01:04:31 <ketil> Who says premature optimization is bad?  I got a whopping 0.3% perfomance increase.
01:04:40 * ketil pats himself on the back.
01:06:08 <dons> int-e: i think i'll still have to try to make the C code pure.
01:06:22 <dons> its just not useful enough unless it's pure, imo.
01:08:24 <sjanssen> kmcallister: no
01:11:00 <sjanssen> dons: it might be possible to build a pure interface on top of the impure C library
01:11:20 <sjanssen> eg. use unsafeInterleaveIO to generate an infinite list of outputs
01:12:27 <sjanssen> though you'll leak lots of memory if the user doesn't use it single threaded
01:16:55 <int-e> dons: hmm. something like  data MTGen = MTGen ByteArray# Word# ? It's a pity that the mersenne twister code uses global variables for its state.
01:18:54 <sjanssen> int-e: that still doesn't provide a pure interface
01:21:38 <int-e> sjanssen: well I wanted to create a new ByteArray on each block boundary. That would be pure.
01:22:43 <sjanssen> int-e: oh, maybe I don't know enough about the algorithm
01:25:31 <int-e> sjanssen: it generates a block of random number (or, you could say, a huge random number), and returns chunks of that until it's exhausted. Then it generates the next one.
01:26:07 <sizur> i have just installed cabal-install without problems.
01:27:16 <sjanssen> int-e: ah, so it shouldn't be too hard to make it pure
01:27:22 <sjanssen> just rip the globals out of the C part
01:27:26 <int-e> yep.
01:27:32 <sizur> however, after 'cabal install hslogger' it installed it under my user, and when i do a 'runhaskell Setup.hs configure' on another package, it doesn't see the hslogger...
01:28:27 <sizur> what's going on there?
01:28:53 <doserj> either do cabal install --global hslogger, or runhaskell Setup.hs configure --user
01:29:22 <sizur> doserj: thanks!
01:30:07 <sizur> that was simple
01:31:17 <sizur> and how can i install a specific version of a package with cabal-install?
01:31:42 <doserj> cabal install package-<version>
01:31:42 <C-Keen> ketil: is there a way to define the Constructor in haskell in a way so that it executes code to fill its values or do I neet to implement another function that takes this datatype and fills it?
01:31:46 <sizur> cabal install package-versionnumber?
01:31:52 <kmcallister> C-Keen, the latter
01:32:04 <kmcallister> these are often called "smart constructors" but they're just ordinary functions
01:32:15 <int-e> dons: tsk. instance MTRandom Word64  where random !_ = fmap fromIntegral randomWord
01:32:25 <C-Keen> kmcallister: ok...
01:32:26 <int-e> dons: how is that supposed to work on a 32 bit system?
01:32:36 <bos> @seen dons
01:32:36 <mbot> Unknown command, try @list
01:32:42 <bos> eep
01:32:49 <kmcallister> if you want to force other code to use them, put the type in a module and export only the type (but not its constructors) and the smart constructors
01:33:34 <C-Keen> kmcallister: using newtype? I have seen this before
01:34:02 <kmcallister> whether you'd use newtype or data is a seperate question
01:34:04 <C-Keen> kmcallister: like newtype exporttype internal_type
01:34:11 <kmcallister> no, you can just export the internal type
01:34:14 <kmcallister> but not its constructors
01:34:21 <kmcallister> module Foo(Bar) vs. module Foo(Bar(..))
01:34:30 <C-Keen> ok I drr
01:34:33 <C-Keen> err see
01:34:56 <C-Keen> now what is the difference between newtype and a data constructor?
01:35:08 <kmcallister> newtype is restricted to have only one constructor with one field
01:35:16 <kmcallister> and it's unboxed
01:35:32 <kmcallister> but it uses the field's runtime representation
01:35:40 <kmcallister> so there's no performance penalty over the underlying type
01:36:43 <C-Keen> hm...
01:36:58 <kmcallister> you can use it in place of type synonyms, when you want the compiler to check that you're not mixing synonyms
01:37:19 <kmcallister> i.e. you have three different uses for an Int in your code, and want to keep them from interacting
01:37:31 <C-Keen> but with data you can do this as well no?
01:37:46 <hpaste>  sizur pasted "cabal-install or package problem" at http://hpaste.org/5123
01:38:26 <sizur> should cabal tell me what was the error?
01:39:04 <sjanssen> C-Keen: data has a slightly different semantics
01:39:14 <hpaste>  (anonymous) annotated "sortPerm" with "(no title)" at http://hpaste.org/5120#a1
01:39:49 <kmcallister> C-Keen, data incurs a runtime cost
01:40:14 <kmcallister> data Foo = Bar Int | Baz Float will use something like 2 words at runtime
01:40:24 <kmcallister> a flag indicating Bar or Baz, and then an int or a float
01:40:35 <kmcallister> newtype Foo = Bar Int
01:40:44 <kmcallister> will only store the Int, just as if you'd used Int as the type directly
01:40:50 <kmcallister> this is why you can only have one constructor and one field
01:40:52 <C-Keen> I see now
01:41:01 <C-Keen> thanks for explaining
01:41:26 <kmcallister> (you can of course do newtype Foo = Bar (Int, Int, Int) to get multiple fields, but then the next constructor in is (,,) so it's still boxed there)
01:41:26 <kmcallister> no problem
01:41:29 <sjanssen> C-Keen: generally, you should use newtype whenever your type meets the restrictions (single constructor, single component)
01:42:20 <kmcallister> the difference in semantics is that Foo _|_ = _|_ if Foo is a newtype constructor
01:42:42 <sizur> C-Keen: you can have phantom types with newtypes: newtype Foo x a = Foo a
01:43:12 <C-Keen> ok..
01:44:09 <kmcallister> i.e. "case (Bar undefined) of (Bar _) -> ()" will be () with data Foo = Bar Int, but undefined with newtype
01:44:23 <sizur> that should give newtypes more used than just one to one mapping
01:44:34 <sizur> uses*
01:44:39 <kmcallister> yeah
01:44:44 <sjanssen> kmcallister: no, they both yield ()
01:44:57 <kmcallister> oh duh
01:45:10 <kmcallister> i'm confusing two things
01:45:27 <mauke> Bar undefined `seq` ()
01:45:50 <sjanssen> this is the tricky case that doesn't allow us to treat "data X = X !Int" and "newtype X = X Int" as the same thing
01:47:30 <kmcallister> because constructing a type with a strict field forces the value being used for the field, but constructing a newtype doesn't force the value unless the newtype itself is forced?
01:47:33 * kmcallister tries to understand
01:47:43 <sjanssen> kmcallister: the difference is in pattern matching
01:48:04 <sjanssen> case undefined of (X _) -> ()
01:48:23 <sjanssen> will yield () for the newtype, and undefined for the strict data
01:48:50 <sjanssen> in all other ways they're the same
01:49:13 <kmcallister> ah, i see
01:49:30 <Cale> basically, the newtype constructor "isn't real"
01:50:22 <Cale> It doesn't take any evaluation to match against it, because it has no representation at runtime.
01:50:35 <sizur> sjanssen: does it yield () because the compiler sees that it's a constant expression, and optimized away the case?
01:50:59 <sjanssen> sizur: it yields () because those are the semantics
01:52:01 <sizur> sjanssen: in other words by definition?
01:52:11 <kmcallister> C-Keen, another reason to use newtype over data is that for newtype Foo = Foo Bar, GHC can derive typeclass instances for Foo if the underlying Bar supports the same type
01:52:16 <kmcallister> same class*
01:52:20 <sjanssen> but yes, I'm sure GHC will optimize the case out -- because with a newtype there is no pattern matching to be done
01:52:23 <sjanssen> sizur: yeah
01:53:22 <Cale> Those are the semantics, because the idea is that the newtype's data constructor is something which only exists for the benefit of the typechecker, and is removed by compilation, whereas with data, the data constructor really exists, and pattern matching against it forces evaluation of the value (to check that there's a match, even if there's only one constructor)
01:54:09 <kmcallister> i wish derivation for newtypes generalized to MPTC... if there's an instance MonadError Foo Bar and i have a newtype of Bar, I should be able to derive MonadError Foo for it
01:54:37 <sjanssen> kmcallister: that does work
01:54:41 <mauke> I do that
01:54:48 <kmcallister> weird, it didn't work when i tried
01:54:52 <sizur> Cale: /(Cons _)-> -- forces the value evaluation anyway?
01:55:05 <C-Keen> hm how do I give linkerflags to a Setup.hs script? LDFLAGS=... ./Setup.hs configure won't work
01:55:16 <sjanssen> kmcallister: it only works for one argument order
01:55:18 <Cale> sizur: when Cons is a data constructor defined by a data (as opposed to a newtype) declaration, yes
01:55:20 <sjanssen> @src MonadError
01:55:21 <mbot> class (Monad m) => MonadError e m | m -> e where
01:55:21 <mbot>     throwError :: e -> m a
01:55:21 <mbot>     catchError :: m a -> (e -> m a) -> m a
01:55:56 <sjanssen> kmcallister: newtype M a = M (Bar a) deriving (MonadError Foo) -- should work
01:56:10 <kmcallister> yeah, i just made it work
01:56:17 <kmcallister> i guess what i wanted to do before was the other argument order
01:57:42 <Cale> @src Identity
01:57:42 <mbot> newtype Identity a = Identity { runIdentity :: a }
01:58:11 <Cale> > case undefined of (Identity _) -> 1
01:58:15 <mbot>  1
01:59:03 <Cale> hmm, I wonder if there's a single-constructor, single-field data declaration in the libraries somewhere :)
01:59:43 <C-Keen> Is there an order in which where clauses get evaluated?
01:59:55 <kmcallister> C-Keen, evaluation order in Haskell is irrelevant
01:59:57 <sjanssen> @src Int
01:59:57 <mbot> data Int = I# Int#
01:59:58 <Cale> C-Keen: in order of necessity?
02:00:05 <sjanssen> Cale: what do I win? :P
02:00:17 <Cale> hmm :)
02:00:25 <kmcallister> what does an unboxed constructor name mean?
02:00:28 <kmcallister> as in I#
02:00:36 <Cale> > case undefined of I# _ -> 1
02:00:37 <mbot>  Parse error in pattern at "->" (column 24)
02:00:59 <kmcallister> > case undefined :: Int# of _ -> ()
02:00:59 <mbot>  Parse error at "#" (column 22)
02:01:03 <sjanssen> kmcallister: the 'I#' doesn't mean anything, it's just a convention
02:01:04 <shag> is there something like deepSeq avaliable for Data.Map and Data.Set?
02:01:19 <kmcallister> ah
02:01:27 <Cale> C-Keen: You just put declarations in where clauses, they're used wherever needed and not evaluated up front.
02:01:37 <sjanssen> shag: are they instances of NFData from Control.Parallel.Strategies?
02:01:57 <shag> uh, mom
02:02:07 <sjanssen> kmcallister: undefined :: Int# is a kind error
02:02:26 <kmcallister> it is?
02:02:38 <kmcallister> isn't Int# :: * the type of machine-level integers?
02:02:47 <sjanssen> @kind Int#
02:02:49 <shag> sjanssen: hm, seems like they're not
02:02:49 <mbot> Not in scope: type constructor or class `Int#'
02:03:02 <sjanssen> @kind GHC.Exts.Int#
02:03:02 <kmcallister> sjanssen, above it's used as data Int = I# Int#, so i'd imagine it has kind *
02:03:03 <mbot> #
02:03:21 <kmcallister> err, that
02:03:23 <Cale> No, they're not, but they're instances of lots of other things which you might use to make them instances of NFData in not-terribly-efficient ways.
02:03:25 <sjanssen> kmcallister: unboxed types have a special kind #
02:03:38 <shag> sjanssen: oh, stupid me, they are
02:03:47 <Cale> er, hmm...
02:04:09 <kmcallister> what are the kinding rules with respect to #
02:04:32 <Cale> oh, the instance just isn't in Data.Map
02:04:55 <shag> yea exactly, thats what i just found, too
02:06:35 <Cale> ah, the instance of NFData is actually what I was going to suggest
02:06:40 <sjanssen> kmcallister: all unboxed types have kind #, * and # are incompatible
02:06:50 <Cale> Which is  rnf = rnf . Map.toList
02:06:58 <sjanssen> and there's a special rule for (->)
02:07:01 <sjanssen> @kind (->)
02:07:03 <mbot> ?? -> ? -> *
02:07:10 <Cale> (man, I hate the choice of '.' for the module path separator)
02:07:48 <kmcallister> i'm guessing ?? means "* or #"?
02:07:55 <Cale> @kind (->) Int#
02:07:57 <mbot> Not in scope: type constructor or class `Int#'
02:08:10 <Cale> @kind (->) GHC.Exts.Int#
02:08:11 <mbot> ? -> *
02:08:18 <sjanssen> kmcallister: ?? and ? are kind variables, AIUI
02:08:26 <sjanssen> distinct kind variables
02:08:33 <kmcallister> ah
02:08:44 <sizur> what does ? and ?? mean in kind signature?
02:08:49 <sjanssen> @kind (->) GHC.Exts.Int# Int
02:08:50 <kmcallister> @kind (->) Either
02:08:51 <mbot> *
02:08:52 <mbot>     `Either' is not applied to enough type arguments
02:08:52 <mbot>     Expected kind `??', but `Either' has kind `* -> * -> *'
02:08:57 <sizur> ah
02:08:59 <sizur> i'm slow
02:09:05 <kmcallister> so they're kind variables, but they have to be instantiated at * or #
02:09:12 <sjanssen> yeah
02:09:51 <kmcallister> @kind Either
02:09:52 <mbot> * -> * -> *
02:10:02 <kmcallister> @kind Either GHC.Exts.Int# Int
02:10:04 <mbot>     Expecting a lifted type, but `GHC.Prim.Int#' is unlifted
02:10:04 <mbot>     Expected kind `*', but `GHC.Prim.Int#' has kind `#'
02:10:53 <kmcallister> so a constructor declared via data can't take an unboxed value... this makes me think that "data Int = I# Int#" is special in some way
02:11:16 <kmcallister> wait, nm, that's not the same thing at all
02:11:42 <sjanssen> kmcallister: "data Int = I# Int#" isn't special
02:12:20 <kmcallister> but if i said "data Int a = I# a", i wouldn't be able to get the above as "Int Int#"
02:12:50 <sjanssen> oh, I think GHC will also deny "data Foo (a :: #) = Foo a" -- ie. higher kinded constructors taking #
02:15:41 <Cale> * means boxed type, # means unboxed type, (#) means unboxed tuple, ?? is the LUB of * and #, ? means any type at all
02:16:09 <Cale> (that is, ? is the LUB of ?? and (#))
02:16:27 <sjanssen> oh, that's right
02:16:42 <sjanssen> forgot about the goofy restrictions on unboxed tuples
02:19:29 <Cale> The only place I know of to learn that is inside the GHC source code.
02:19:56 <kmcallister> how hard is it to get started hacking on GHC?
02:20:19 <kmcallister> i know Haskell and have had some compilers courses, but i've never implemented a modern functional language like Haskell
02:20:40 <kmcallister> and i'll have some free time this summer
02:21:05 <therp> kmcallister: excellent. you might want to consider google summer of code if you heard of that.
02:21:11 <kmcallister> yes
02:21:19 <therp> kmcallister: (only in case you have a specific project in mind)
02:21:44 <therp> kmcallister: I participated in gsoc hacking GHC and it was a really nice experience over all. especially to the nice folks over in #ghc.
02:22:04 <kmcallister> therp, how hard did you find it to get familiar with the code base?
02:23:42 <therp> kmcallister: not that hard. functional programming really confines the logic into a specific place. for instance, an iterative process that has side effects (for instance the optimizer) are all in a single place, namely its monadic definition.
02:24:17 <therp> kmcallister: so, therefore, you can use the divide-and-conquer strategy to make your way through the source base
02:24:47 <kmcallister> makes sense
02:24:56 <therp> kmcallister: I'd not say that GHC's source code is sterile and tidy, but the hacks are in general small and reasonable. so it's not at all painful to read
02:26:24 <therp> however, the big plus of considering GHC as object of desire for hacking is that #ghc is inhabited by helpful natives.
02:27:01 <therp> kmcallister: anything specific you want to hack on?
02:27:49 <Cale> I wonder how much work it would be to structure the GHC source code (and hence the GHC API) to use hierarchical modules.
02:28:27 <kmcallister> therp, not at the moment
02:28:32 <therp> hierarchical modules are the naming scheme, aren't they?
02:28:39 <therp> s/are/means/
02:30:52 <Cale> therp: well, currently all the modules in GHC are at the top level.
02:31:03 <Cale> They're named things like DynFlags
02:32:50 <Cale> In the source code, they're separated into directories, but the modules are all top-level, probably because GHC was started long before the hierarchical modules extension was proposed :)
02:33:21 <pejo> Cale, is hierarchical modules in Haskell'?
02:33:39 <sizur> Cale: what do you mean by top-level? what is a nested module?
02:33:43 <Cale> pejo: I should hope so, but I don't know.
02:33:49 <Cale> sizur: Like Data.Map
02:33:59 <Cale> Control.Parallel.Strategies
02:34:09 <Cale> etc.
02:34:15 <sizur> these are nested?
02:34:33 <kmcallister> sizur, it means there's a dot in the module name
02:34:39 <Cale> Well, their names form a hierarchy where . is the path separator.
02:36:26 <sizur> so you mean ghc build uses make to chase dependencies
02:36:47 <sizur> it's not done automatically by the module system
02:37:04 <Cale> huh?
02:37:14 <Cale> GHC chases dependencies on its own.
02:37:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- look, the modules form a tree, rather than a list! :)
02:37:56 <sizur> well, if all ghc modules are top level, but are ordered in directories...
02:38:24 <Cale> sizur: The names of modules are given by the module declaration at the top.
02:41:08 <sizur> if i name a submodule Sub instead of App.Sub, and put it under App/, then import Sub within App module, how will it be found?
02:41:36 <sizur> unless i misunderstood what you mean by ghc having all module top-level but in different directories
02:42:12 <Cale> sizur: You can specify explicitly where it should look.
02:42:49 <sizur> Cale: then you put that command in a .Makefile, right? to automate the build
02:43:00 <sizur> that what i meant by dependency chasing using make
02:43:02 <Cale> ah, I see what you mean about using make
02:43:32 <Cale> Yeah, the build system for compiling GHC itself uses make.
02:46:20 <Cale> http://www.qwantz.com/archive/001150.html :)
03:11:52 <nornagon> smallNatural :: forall i. (Integral i, Bounded i) => Parser i -- parses in 6.6 but not 6.8...?
03:12:22 <nornagon> (6.8 gives "parse error on input `=>'")
03:12:37 <wolverian> need an extension?
03:12:54 <fasta> Is putting two values in an Int8 faster than one? I would need some bit operations to recover the right value, though. The tradeoff is using 8 times more memory vs a more complicated value recognition.
03:14:51 <fasta> I would guess that the more complicated scheme is slower, but if all those operations can occur during the same clock then the complicated scheme would be faster because it wouldn't stress the memory as hard.
03:15:15 <quicksilver> I doubt ghc can generate the right assembly code to make the bit-packing faster
03:15:18 <quicksilver> but I could be wrong.
03:17:00 <fasta> Is there any other programming language which does make bit-packing faster?
03:17:30 <nornagon> wolverian: any idea which one?
03:17:50 <fasta> @hoogle Int -> Int8
03:17:52 <mbot> http://www.mysql.com/search/?q=smallint
03:17:52 <mbot> Title: MySQL AB :: MySQL Search
03:20:03 <RayNbow> fasta: I know that Erlang has language constructs for bit stuff, but I don't know if it's fast
03:20:10 <fasta> quicksilver: to me it would seem that the less overhead (less bits) there is in the representation, the faster it all goes.
03:20:29 <Taejo> fasta: you forget about boxing and unboxing costs
03:20:50 <fasta> Taejo: I use unboxed arrays.
03:21:29 <Taejo> aren't they slower than boxed arrays for certain operations? that's certainly the case in python
03:22:15 <fasta> Taejo: for some value of certain, yes.
03:22:42 <fasta> Taejo: I believe that for primitive types in these arrays the cost is lower.
03:22:54 <Taejo> ok
03:49:18 <hpaste>  mmorrow pasted "HsPat" at http://hpaste.org/5126
03:53:33 <Time`s_Witness> could anyone tell me what's wrong here pleae? http://hpaste.org/5127
03:53:34 <Time`s_Witness> :x
03:54:33 <quicksilver> Time`s_Witness: you've declared "f" as if it works on lists.
03:54:41 <quicksilver> Time`s_Witness: but you're using it as if it works on elements
03:54:48 <quicksilver> Time`s_Witness: (difference between [a] and a)
03:55:16 <Time`s_Witness> yea.. that was it.. thanks quicksilver :P
03:56:06 <nornagon> hm, so is there a way to get lexically scoped type variables with a -X, or do you need -fglasgow-exts?
03:56:34 <nominolo> @seen dcoutts
03:56:34 <mbot> Unknown command, try @list
03:56:47 <quicksilver> nominolo: -XScopedTypeVariables ?
03:56:51 <quicksilver> nornagon: that was for you
03:56:53 <quicksilver> nominolo: sorry :)
03:57:12 <nominolo> quicksilver: unknown extension
03:57:27 <nominolo> quicksilver: try: $ nominolo --help
03:57:40 <quicksilver> ;)
04:14:34 <mux> is there a parsing package somewhere that uses applicative functors?
04:17:56 <earthy> mux: not directly, but UU.Parsing in UULib does.
04:18:57 <mux> cool, thanks
04:19:00 <earthy> (that is: it does use the same symbols, but does not use Control.Applicative, as it was written before)
04:19:20 <byorgey> mux: it's also very easy to use AF's with Parsec.
04:19:28 <earthy> plus, istr that exactly that parsing lib was part of the inspiration for Control.Applicative. :)
04:20:12 <mux> I'd like to move some of my parsing code to using Control.Applicative so that it's easier to change the backend parser at some time
04:20:13 <byorgey> mux: just do  instance Applicative (GenParser tok st) where pure = return; (<*>) = ap
04:20:27 <mux> are there plans to have a generic parsing interface using Control.Applicative?
04:20:34 <mux> byorgey: yeah, I know that
04:20:42 <byorgey> oh, ok
04:20:51 <earthy> mux: it is very hard to do well
04:20:54 <mux> like for any monad btw
04:21:14 <earthy> at some point you run into the limits of the haskell class system
04:21:43 <earthy> (the trickiness comes in trying to parse the empty string... what token type would a parser for the empty string have?)
04:22:36 <mux> I guess the empty token would be part of the Parsing type class
04:23:05 <oerjan> :t Control.Applicative.pure ""
04:23:06 <mbot> forall (f :: * -> *). (Applicative f) => f [Char]
04:55:27 --- mode: irc.freenode.net set +o ChanServ
04:57:26 <sizur> ping
04:57:26 <Valodim_> man this is spamming my whole screen >_<
04:57:28 <nominolo> wow
04:57:28 <ivanm> Valodim_: get a bigger screen then! :p
04:57:39 <nominolo> at least 50"
04:57:47 <sizur> man, i dont see my own messages in the log!
04:58:15 <sizur> now i can, very strange
04:59:14 <sizur> i will repeat my message because i assume it was not sent
04:59:55 <sizur> since #happs is sleeping does anybody wanna give a shot at http://hpaste.org/5128#a2 ?
05:01:12 <vegai> sizur: perhaps you forgot some SYB or TH magic
05:01:17 <byorgey> sizur: what's the type of localize?  and the type of ok?
05:01:33 <byorgey> sizur: from the part that works fine it looks like localize results in an IO something
05:01:47 <sizur> that localize expression returns IO Html
05:02:00 <byorgey> right, and what's the type of the ok function?
05:02:15 <sizur> the value must be in ToMessage class
05:03:13 <sizur> Html is in there already, and i dont get a compiller error about lack of instance of ToMessage (IO something)
05:03:32 <sizur> when i made my own instance, i still got the same error
05:03:45 <byorgey> what error do you get?
05:04:06 <phlpp> hi byorgey
05:04:09 <phlpp> =)
05:04:16 <sizur> No instances for (HAppS.Data.Default.Default (IO Html),
05:04:16 <sizur>                       Data.Typeable.Typeable Html)
05:04:27 <byorgey> hi phlpp =)
05:04:50 <byorgey> sizur: well, it is complaining about the IO Html
05:05:22 <sizur> :/ i'm not using Data at all
05:06:08 <byorgey> sizur: maybe there is an instance (Default (IO a), Typeable a) => ToMessage a or something
05:06:42 <sizur> yeah, very likely
05:07:05 <sizur> but it's not in HAppS.Server
05:07:26 <_frederik_>   libghc6-network-dev: Depends: ghc6 (< 6.6.1+) but 6.8.2-1 is to be installed
05:07:30 <byorgey> I don't actually know anything about happs, just trying to throw out some ideas =)
05:07:40 <sizur> can you even have a context with IO a?
05:07:45 <sizur> since IO is a type constructor
05:07:55 <fasta> sizur: probably you are using Data.
05:08:11 <sizur> fasta: i dont. it must be wired into happs
05:08:16 <fasta> sizur: I know you said you don't _think_ you are, but you are.
05:08:17 <_frederik_> does anyone know why libghc6-network-dev is available for amd64, but not i386?
05:08:32 <fasta> sizur: that's what I meant. There is no concept of "wired-in", though, imho.
05:08:51 <sizur> fasta: if i cannot get rid of it, it's wire-in for me
05:08:53 <byorgey> _frederik_: looks like it just hasn't gotten updated yet.  things are only just starting to be updated to 6.8 in various package systems.
05:09:10 <fasta> sizur: HApps is open-source, you can always get it out.
05:09:12 <aFlag> _frederik_, debian? I have that installed: i   libghc6-network-dev             - Haskell network library for GHC
05:09:18 <byorgey> _frederik_: you can just install it yourself from hackage, it should be pretty easy if you've got ghc installed.
05:09:36 <byorgey> aFlag: which version of ghc do you have installed?
05:09:42 <_frederik_> aFlag: which architecture?
05:09:54 <_frederik_> byorgey: where is hackage?
05:10:01 <fasta> sizur: but if you don't want to customize it, you should either contact the authors or explain the problem better (provide URL to documentation s.t. I can see).
05:10:05 <byorgey> _frederik_: hackage.haskell.org
05:10:44 <byorgey> it's like CPAN for Haskell, but CHAN isn't such a great acronym =)
05:11:36 <aFlag> I use debian etch, it's ghc 6.6, now you're talking about ghc 6.8 I think you're probably talking about debian sid or ubuntu
05:11:39 <aFlag> i386
05:12:00 <sizur> fasta: i dont think happs has any docs yet... and the authors are sleeping. so i tried here ;) unfortunately happs.server depends on too many thing. it would take hours for you to scan through that.
05:12:05 <_frederik_> byorgey: thanks
05:12:21 <fasta> sizur: there are API docs.
05:12:35 <fasta> sizur: which is all one needs.
05:12:52 <sizur> fasta: i'm not aware of where they are then
05:13:05 <byorgey> sizur: in any case, what's the big deal?  why is it so bad to have to do page <- localize blah blah ?
05:13:06 <fasta> sizur: on hackage you can click on the modules
05:13:22 <sizur> problem is that you want to localize after url dispatch, not before
05:13:36 <sizur> fasta: Happs on hackage is obsolete
05:13:55 <fasta> sizur: ok, then I don't know an online location. Sorry
05:14:16 <fasta> When GHC claims there is no instance, there is none in scope.
05:14:29 <fasta> Often it's simply a matter of importing the right module.
05:24:19 --- mode: irc.freenode.net set +o ChanServ
05:26:07 <Valodim_> wtf is up with the network
05:26:12 <Valodim_> ok this is going on my nerves
05:27:36 <byorgey> it does seem a bit split-happy this morning...
05:29:18 <Botje> they announced a server update for today
05:29:22 <nominolo> hm, does someone remember the option to allow patterns like (X { x }) equivalent to X { x = x } in GHC?
05:30:11 <oerjan> record puns something
05:31:14 <nominolo> ah, right
05:33:59 <nominolo> -XRecordPuns the link in the flag reference points to itself, though
05:35:22 <oerjan> some of those new record options weren't really supported yet
05:36:47 <nominolo> it seems to work though.
05:36:50 <kpreid> nominolo: isn't that a pretty nasty pun, considering that it requires one to shadow the accessor?
05:37:37 <oerjan> you can still use the accessor as field name
05:37:39 <nominolo> kpreid: no, i like it.  You have similar things in Common Lisp in macros like with-slots
05:37:56 <oerjan> only shadows the function
05:37:58 <kpreid> naw, that's different, because they're different namespaces
05:38:02 <nominolo> kpreid: record labels are their own nome space anyways
05:38:32 <kpreid> here, you're shadowing y :: X -> Y with y :: Y
05:38:32 <nominolo> *name space
05:38:39 <Igloo> No, they're in the function namespace
05:38:41 <kpreid> which seems Bad to me
05:39:08 <nominolo> Igloo: well, sort of.  they are both
05:39:15 <Igloo> They're only special when in {} directly after a constructor, and I think even that is an extension
05:39:22 <nominolo> Igloo: for x { foo = bar } it's their own namespace
05:39:35 <LoganCapaldo> foo x -- not :)
05:39:37 <nominolo> Igloo: for (foo x) they're in the function space, yes
05:39:46 <sizur> hey Igloo, can you take a look at one Happs issue i have when you'll have a min?
05:40:03 <nominolo> LoganCapaldo: right.  current records are a hack anyways
05:40:44 <nominolo> i think in Daan's record proposal they're their own namespace
05:42:10 <nominolo> which seems right to me.
05:42:41 <Igloo> sizur: Best to ask in #happs or on the mailing list, if it's HAppS-specific, and hopefully someone will answer
05:52:36 <njbartlett> Just a reminder for people in London: Ganesh Sittampalam will be giving a talk about Darcs Patch Theory and GADTs this wednesday at London HUG
05:57:26 <cnwdup> I try to hide the gap when switching to a different layout. Here's my approach, but it isn't working. Can anyone explain this to me? http://pastebin.archlinux.org/24564
05:58:53 <cnwdup> I am primarily interested in a solution but why my approach is wrong interests me either.
06:00:36 <kpreid> for the wondering, cnwdup's question is about xmonad.
06:00:56 <cnwdup> Noes. I *always* confuse the channels. Sorry. )':
06:08:30 <sizur> is there any way to express a complement of a context? something like instance (NOT Monad nm) => nm a?
06:08:55 <Valodim_> what would you want that for?
06:08:55 <phlpp> :t (++)
06:09:02 <phlpp> :>
06:09:32 <sizur> Valodim_: no idea. i know you can make your own class and then use that context
06:12:46 <sizur> well you could use that to delay a type error until the evaluation heh. and do something non-standard with it
06:12:58 <sizur> but i guess that beats the purpose
06:15:54 <EvilTerran> sizur, I think you can do something cunning with overlapping instances; not sure, tho
06:16:01 <sizur> it's like a dynamic typecheck that's done statically
06:16:09 <LoganCapaldo> sizur: you could maybe do something like (Ord (m a)) => which would guarantee that m wasn't an instance of Monad (but again don't know what you'd acheive)
06:17:14 <LoganCapaldo> at least until someone came along a wrote a nonsense instance of Ord for Monads
06:17:43 <quicksilver> sizur: Yes, I believe it's possible.
06:17:51 <quicksilver> sizur: you can search the olegs for how to do it.
06:18:02 <EvilTerran> sizur, see http://okmij.org/ftp/Haskell/typecast.html#is-function-type
06:19:45 <EvilTerran> sizur, you might also need "class-parameterised classes": http://okmij.org/ftp/Haskell/types.html#peano-arithm
06:20:17 <EvilTerran> "It becomes relatively straightforward then to implement RSA in types." ... wow.
06:20:39 <sizur> nice
06:21:15 <opqdonut> indeed
06:22:10 <nominolo> > (+1) <$> Just 42
06:22:16 <nominolo> meh
06:22:48 <EvilTerran> @bot?
06:23:59 <oerjan> LoganCapaldo: ahem, lists are both Ords and Monads
06:24:14 <LoganCapaldo> yeah
06:24:20 <LoganCapaldo> I don't know what I was thinking
06:28:23 <LoganCapaldo> does f <$> x = pure f <*> x have to hold?
06:29:30 <twanvl> yes
06:30:13 <LoganCapaldo> Sorry that questin may have been unclear, i'm asking as far as the spirit goes, not what the compiler will check :)
06:30:27 <LoganCapaldo> I'm guessing you knew that though
06:32:09 <quicksilver> yes
06:32:24 <quicksilver> that's the law which is supposed to connect the Functor instance with the Applicative one
06:32:31 <quicksilver> as you quite rightly suggest, it isn't checked.
06:39:58 <LoganCapaldo> and all monads are applicative functors, any examples of applicative functors that aren't monads? Some arrows maybe?
06:41:03 <allbery_b> IIRC the default applicative functor for lists is not the monad instance
06:41:28 <quicksilver> you remember incorrectly.
06:41:57 <quicksilver> LoganCapaldo: ZipList is not a monad for finite lists. It is a monad for infinite lists AIUI.
06:42:19 <quicksilver> LoganCapaldo: I'm not aware of an applicative which has no extension to monad.
06:42:23 <BMeph> allbery_b:The reverse. The default version is the monad, the special version is not
06:42:26 <quicksilver> LoganCapaldo: I've wondered the same thing myself.
06:43:26 <BMeph> quicksilver: How would you make ZipLists into a monad?
06:44:54 <quicksilver> BMeph: join takes the diagonal.
06:44:55 <quicksilver> IIRC.
06:45:16 <LoganCapaldo> @where ZipLists
06:45:22 <LoganCapaldo> no bot
06:45:26 <LoganCapaldo> @bot
06:45:32 <BMeph> quicksilver: The diagonal?
06:45:56 <quicksilver> 1st item from first list, 2nd from 2nd, 3rd from 3rd
06:46:02 <quicksilver> join :: [[a]] -> [a]
06:46:39 <BMeph> Hm, interesting.
06:46:53 <doserj> it is also called the stream monad
06:47:07 <nominolo> hm, anyone else think this should be a standard function? orError ma msg = maybe (fail msg) return ma
06:47:10 <BMeph> doserj: Right, I was wondering about that.
06:47:51 <nominolo> to be used like this:  do x <- find (> 42) args `orError` "no suitable arg"; print x
06:48:12 <nominolo> ie, integrates Maybe a into any monad m a
06:48:22 <nominolo> or is there a better way?
06:49:22 <int-e> > map (head . head) . iterate (tail . map tail) $ [[(x, y) | x <- [0..]] | y <- [0..]]
06:49:27 <LoganCapaldo> ah
06:49:32 <LoganCapaldo> interesting
06:49:37 <quicksilver> nominolo: yes, I thinkg that should be a standard function.
06:49:49 <quicksilver> nominolo: although I might be tempted to use throwError instead of fail.
06:50:07 <LoganCapaldo> that or the type of functios like find should be fixed <g>
06:50:26 <LoganCapaldo> "fixed"
06:50:35 <nominolo> yes.  if you have MonadError you could use `orThrow` myError
06:50:42 <quicksilver> that's try
06:50:46 <quicksilver> orFail and orThrow
06:50:48 * quicksilver nods
06:50:50 <quicksilver> I would like that
06:50:55 <nominolo> LoganCapaldo: yes, but that's a bit more work ;)
06:57:50 <LoganCapaldo> ZipList is cneat
06:58:37 <phlpp> :D
07:10:20 <hpaste>  Big_Red pasted "Integration" at http://hpaste.org/5129
07:11:10 <Big_Red> can anyone take a look at that and tell me why when i import it into hugs it bitches about the again function type not working
07:11:19 <Big_Red> it says *** Type           : Bool -> (b -> a) -> b -> b -> c -> d -> e
07:11:21 <Big_Red> *** Does not match : (a -> Bool) -> (b -> a) -> b -> b -> c -> d -> e
07:11:59 <Big_Red> because when i define again i have it taking a boolean but when i call it i give it a function that returns a boolean...
07:12:31 <Big_Red> ideas?
07:13:05 <mauke> (line f a (a+b)/2 tol) is wrong
07:13:50 <mauke> it's parsed as ((line f a (a + b) / (2 tol))
07:14:05 <LoganCapaldo> Big_Red: line f a (a+b)/2 is gonnana be parsed as exactly what mauke said
07:14:08 <mauke> make that ((line f a (a + b)) / (2 tol))
07:14:15 * LoganCapaldo is slow
07:14:29 <Big_Red> so i should wite (line f a ((a+b)/2) tol)?
07:14:51 <mauke> yes
07:15:05 <byorgey> Big_Red: exactly.  remember that function application has higher precedence than anything else.
07:15:47 <Big_Red> hm ok thats changed and now it's complaining about the next line
07:16:54 <Big_Red> ok fixed - thanks guys
07:28:06 <geekagent> anyone here ever worked for jane street capital?
07:28:38 <LoganCapaldo> if they told you, they'd have to kill you
07:29:16 <nominolo> and perform unsafe IO with you
07:30:14 <LoganCapaldo> in a strict programming language no less
07:32:05 <ramza3> foldl (\(x,y) z -> (x*z, y+z)) (1,0) [1..10]   in this example of fold ... does z refer to the index when go through 1..10
07:32:21 <matthew-_> ramza3 : yes
07:32:21 <mauke> nothing refers to the index
07:32:34 <matthew-_> ahh, sorry, misread
07:32:38 <ramza3> mauke: I knew someone would catch me on my verbiage
07:32:49 <LoganCapaldo> it refers to the current "element" if you will
07:33:02 <matthew-_> the tuple is the accumulator, and the z is the current element
07:35:59 <Big_Red> hmm
07:36:16 <Big_Red> why is it hugs complains at me when my inferred type isn't geneal enough?
07:36:50 <LoganCapaldo> Big_Red: you've given the value a type annotation that's more general than the actual type
07:37:14 <LoganCapaldo> eg, g :: a -> a -> Bool ; g x y = x > y would result in such an error
07:37:33 <LoganCapaldo> because g actually has type g :: (Ord a) => a -> a -> Bool
07:37:42 <Big_Red> does type have to be very specitfic? what happened to polymophism?
07:38:02 <mauke> it has to be specific enough to support all operations you use
07:38:19 <mauke> e.g. foo :: a; foo = "hi"; would be an error
07:38:31 <mauke> because "hi" clearly has the type String, not anything else
07:38:50 <byorgey> Big_Red: can you show an example?  that would probably make it easier to explain
07:39:04 <Big_Red> i think i understand now
07:41:34 <phlpp> somebody's using yi + arch linux?
07:42:20 <sizur> how can i export an imported qualified module?
07:43:04 <sizur> i have import qualified System.IO.UTF8 as Utf8, and i want to export Utf8
07:47:52 <Lemmih> sizur: You can't.
07:48:54 <LoganCapaldo> hmm
07:49:31 <LoganCapaldo> could you module Utf8 where export all the stuff in System.IO.Utf8 and then in the other module export that?
07:49:57 <sizur> hm?
07:50:57 <sizur> ah yeah, that should work
07:51:05 <LoganCapaldo> iow do what you are doing no, but instead of tying to export a qualified module, create a real module named Utf8 that "forwards" everything to the real System.IO.Utf8 and then from your original module export that
07:51:37 <phlpp> hmm
07:51:38 <LoganCapaldo> </hack>
07:51:55 <phlpp> wasn't m >>= f = f =<< m
07:51:56 <phlpp> ?
07:52:07 <quicksilver> genuine module re-export was discussed here last week
07:52:20 <quicksilver> there are other reasons it would be nice to have
07:52:23 <phlpp> ah
07:52:29 <phlpp> ok, sorry, forgot parantheses
07:52:53 <sizur> and how can i hide a module in a package so you cannot import it?
07:53:01 <sizur> and so haddock will skip it
07:53:17 <doserj> sizur: just don't export it
07:53:26 <phlpp> > let m f = (=<<) (return.f) in m (*3) [1,2,3,4,5]
07:53:33 <doserj> oh. a module...
07:53:34 <sizur> doserj: but haddock will build docs for it
07:53:42 <phlpp> argh
07:54:34 <sizur> yeah and so others cannot import it explicitly
07:55:04 <LoganCapaldo> name it something like Embargoed :)
07:55:15 <phlpp> are there differences in performance or why is map in prelude defined like map f [] = [] and map f (x:xs) = f x : map f xs?
07:55:40 <sizur> LoganCapaldo: i know it's possible, because i cannot import Text.XHtml.Internal
07:55:45 <phlpp> i mean you could it define in terms of foldr or >>=.. or is it just because of "simplicity"?
07:56:17 <LoganCapaldo> phlpp: well =<< is defined in terms of >>= which is defined in terms of concatMap which is defined in terms of concat and map...
07:56:27 <phlpp> ah!
07:56:39 <phlpp> what about foldr? ;)
07:56:40 <LoganCapaldo> so sure you could do it the other way round if you wanted
07:58:28 <LoganCapaldo> map f = foldr (\x xs -> (f x):xs) [] sure, why not?
07:58:44 <jedbrown> phlpp: is `map f = foldr ((:) . f) []' really clearer?  Besides, map is intuitively `lower level' than foldr.
07:59:13 <LoganCapaldo> jedbrown: I don't know I agree that map is `lower level'
07:59:38 <LoganCapaldo> but that's just me, and my intuitions may diffe from yours :)
08:00:27 <jedbrown> LoganCapaldo: No, what structures do foldr generalize to?  Certainly a subset of all functors.
08:01:37 <nominolo> hm, a little of topic, but maybe someone can help here:  what is the opposite of "to depend" ?  "to dominate"?  for example "X depends on Y" => "Y <?> X"
08:01:52 <phlpp> jedbrown: so its because of simplicity's sake?
08:02:05 <nominolo> s/of/off=
08:02:06 <twanvl> "Y is needed by X"?
08:02:48 <phlpp> i know you can define map in billions of ways, i just wondered about "why" ;)
08:02:48 <nominolo> twanvl: hm, it actually means "X depends on Y" == "X must be executed after Y"
08:02:57 <byorgey> rob|: ok =)
08:03:05 <LoganCapaldo> jedbrown: So i think your definition of lower level was different than the one I was thinking of when you made that comment.
08:03:07 <jedbrown> phlpp: I think so.  I beleive the generated code is the same, but you'd have to look at the core to be sure.
08:03:07 <hpaste>  ramza3 pasted "Types, using floor and error" at http://hpaste.org/5130
08:03:16 <phlpp> jedbrown: ok
08:03:22 <ramza3> am I missing something here, thought the prelude version would work
08:04:00 <twanvl> nominolo: you could always just say: "Y is a dependency of X"
08:04:55 <nominolo> hm, yes.  maybe i don't need the distinction
08:05:16 <jedbrown> LoganCapaldo: I gathered that.  I still feel like foldr is `doing more' than map in some hard to define sense.  It takes more arguments for instance.
08:05:24 <LoganCapaldo> right
08:05:29 <twanvl> ramza3: floor returns an integral type, which Double is not.
08:05:31 <LoganCapaldo> that's why I feel it's lower level
08:05:35 <LoganCapaldo> heh
08:05:48 <quicksilver> foldr is very specific to the implementation of the list type
08:05:52 <LoganCapaldo> it's "closer" to the list
08:05:58 <byorgey> ramza3: it looks like maybe you are using [1..maxrg] in a context which requires it to be a list of Doubles?
08:05:59 <quicksilver> map is a more general notion
08:06:05 <quicksilver> really it applies to all functors
08:07:00 <byorgey> ramza3: can you paste the entire code that is taken from?
08:07:01 <geekagent> for lists, fmap = map
08:07:47 <hpaste>  ramza3 annotated "Types, using floor and error" with "More code" at http://hpaste.org/5130#a1
08:07:53 <ramza3> byorgey, there
08:09:05 <byorgey> ramza3: oh, well, you explicitly say maxrg = (floor 4.2) :: Double.  see twanvl's comment above, floor returns an Integral type, and Double is not Integral.
08:09:18 <byorgey> ramza3: you'll want to say  fromIntegral (floor 4.2) :: Double.
08:10:38 <ramza3> byorgey, why didnt I have to do that in prelude
08:11:06 <jedbrown> heh:   safeRead v = unsafePerformIO . withForeignPtr (fptr v)
08:11:29 <byorgey> ramza3: because you just typed "floor 4.2".  if you typed "floor 4.2 :: Double" you would get the same error.
08:11:48 <byorgey> ramza3: why do you want maxrg to be Double anyway?
08:12:25 <ramza3> byorgey, because I got the same error if I did; floor 4.2  ...
08:13:04 <hpaste>  ramza3 annotated "Types, using floor and error" with "(no title)" at http://hpaste.org/5130#a2
08:13:18 <byorgey> ramza3: oh, I see, I think it's because you are using the division operator in newSum.
08:13:43 <ramza3> freaky
08:14:20 <hpaste>  byorgey annotated "Types, using floor and error" with "use fromIntegral" at http://hpaste.org/5130#a3
08:14:31 <phlpp> foldr f v (x:xs) = f x (foldr f v xs), isn't it?
08:15:05 <phlpp> with foldr f v [] = v
08:15:11 <byorgey> phlpp: that's right
08:15:21 <ramza3> byorgey, well at least fixing compile errors is better than fixing runtime ones
08:15:24 <phlpp> hm ok
08:15:28 <byorgey> phlpp: foldr replaces each : with `f` and [] with v
08:15:44 <phlpp> tried to figure out a more general definition, but i guess foldr is only defined for lists?
08:16:07 <byorgey> i.e. foldr f v [1,2,3]  --> foldr f v (1:2:3:[]) --> 1 `f` (2 `f` (3 `f` v))
08:16:11 <phlpp> at least i unable to define a more general one
08:16:12 <phlpp> ;)
08:16:36 <LoganCapaldo> you can define it for other things (arrays come to mind as obvious example), but you can't use one defintion
08:16:38 <byorgey> phlpp: yes, but it can be generalized in several ways.
08:17:47 <byorgey> phlpp: check out the Foldable class, for instance.
08:17:59 <phlpp> i guess it can be generalized for monads?
08:18:23 <nolrai> i dont think so.
08:18:23 <byorgey> phlpp: yes, there is a foldM function.
08:18:27 <byorgey> @type foldM
08:18:42 <nolrai> shows what i know
08:18:56 <LoganCapaldo> depends on what "for Monads" means :)
08:19:07 <byorgey> hmm, actually, foldM is a generalization of foldl, not foldr.
08:19:13 <LoganCapaldo> foldM still operates on a list
08:19:29 <phlpp> LoganCapaldo: hmm, i think this was kind of a overhasty conclusion :D
08:19:30 <LoganCapaldo> foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:20:00 <nolrai> ok that makes sense.
08:20:28 <byorgey> phlpp: in general, foldr is an example of a 'catamorphism', which is essentially a way to "summarize" a recursive data type.
08:20:35 <nolrai> it should be extendable to trees right?
08:20:58 <LoganCapaldo> yep
08:20:59 <byorgey> nolrai: right, since trees are a recursive data type, you can define a directly analogous foldTree
08:21:01 <phlpp> byorgey: wasn't catamorphism a category theory thing?
08:21:30 <byorgey> phlpp: yes, it comes from category theory.
08:21:38 <phlpp> byorgey: interesting.. i really should continue reading conceptual mathematics ;)
08:21:56 <byorgey> phlpp: indeed =)
08:23:39 <byorgey> data Tree a = Empty | Node a (Tree a) (Tree a) ; foldTree f v Empty = v ; foldTree f v (Node x l r) = f x (foldTree f v l) (foldTree f v r)
08:24:17 <byorgey> where foldr replaces : with f and [] with v,  foldTree replaces Node with f and Empty with v.
08:24:35 <byorgey> so foldTree Node Empty is the identity on trees, just like foldr (:) [] is the identity on lists.
08:25:50 <phlpp> ah, cool.
08:25:53 <phlpp> thanks byorgey
08:26:26 <nolrai> and so to count the number of nodes would be foldTree (\_ a b -> a + b + 1) (0)?
08:27:16 <byorgey> nolrai: yes, exactly =)
08:28:25 <nolrai> cool i was working with trees and kept doing things that seemed really simmilar but couldn't see the abstraction.
08:29:13 <byorgey> nolrai: ah, yep, this is probably it.
08:29:50 <byorgey> nolrai: I leave as an exercise writing an 'unfoldTree' function analogous to 'unfoldr' =)
08:34:39 <DRMacIver> Is the wiki information on data parallel haskell currently up to date? (It basically says "We have some syntactic sugar, and we've got reasonable results for flat but not segmented arrays, but the two don't actually talk to eachother yet")
08:40:32 <vincenz> is it possible to have a ghci file that contains some std definitions?
08:43:13 <jedbrown> vincenz: My .ghci loads .ghci.hs if that's what you mean.
08:44:11 <vincenz> jedbrown: how?
08:44:46 <jedbrown> vincenz: :load "/home/jed/.GHCi.hs"
08:45:20 <vincenz> jedbrown: thanks :)
08:45:49 <byorgey> of course, using :load means that those definitions will go away as soon as you :load something else
08:46:12 <byorgey> but you could also make a module with the definitions you want, and use :m + in your .ghci
08:47:24 <jedbrown> byorgey: Which would also go away when you load something else, as you (I) usually want.
08:47:47 <byorgey> jedbrown: oh... right, good point =)
08:48:13 <jedbrown> byorgey: Another advantage of the  ~/.GHCi.hs approach is that you can import modules qualified.
08:48:50 <vincenz> me winces
08:48:54 <vincenz> 2% cpu, 87% ram for ghc
08:49:02 <byorgey> ouch
08:49:10 <vincenz> yay for pagetrashing
08:49:21 <vincenz> well ghci, not ghc
08:49:40 <vincenz> ah, 98.9% cpu, 90% ram :)
08:49:54 <geekagent> One time I computed a million primes, showed the list, and had ghc try to compile the list.
08:50:00 <geekagent> that was a mistake.
08:51:46 <nolrai> > fmap (+1) (Maybe 0)
08:52:18 <mauke> not in scope: data constructor Maybe
08:52:26 <nolrai> > fmap (+1) (Just 0)
08:52:31 <mauke>  Just 1
08:52:46 <nolrai> :)
08:53:00 <doserj> @version -- :)
08:53:06 <mauke> DENIED
08:53:16 <byorgey> @maukesnack
08:53:22 <mauke>  :)
08:53:48 * byorgey is suffering from lambdabot withdrawal
08:53:55 <jedbrown> I think it is a bug that :load "~/foo.hs" actually loads "${HOME}//foo.hs" (notice the two slashes).  Since the path resolves the same, it works, but the bug lets me load files with one less character.
08:54:06 * jedbrown ponders whether to submit a ticket
08:56:45 <quicksilver> jedbrown, byorgey: you can also define a short command to reload your .ghci.hs
08:56:51 <quicksilver> to get back to that state after loading another file
09:00:16 <vincenz> does ghci fuse?
09:04:32 <quicksilver> vincenz: no
09:04:42 <quicksilver> vincenz: fusion rules are not applied to the interpreter
09:04:47 * vincenz nods
09:04:49 <quicksilver> (of course, ghci can load compiled code too)
09:04:57 <vincenz> quicksilver: btw, how do you use where clauses in ghci
09:05:01 <vincenz> where do the {} go
09:05:10 <quicksilver> ;)
09:05:18 <quicksilver> where clauses go on definitions, not expressions
09:05:21 <LoganCapaldo> where { a = 1 ; b = 2 }
09:05:22 <vincenz> crud
09:05:22 <quicksilver> definitions/declarations
09:05:40 <quicksilver> since ghci evaluates expressions...
09:05:50 <quicksilver> you can of course say something like
09:06:02 <quicksilver> > let { a = b where { b = 5 } } in a
09:06:10 <quicksilver> or
09:06:40 <quicksilver> > case a of { a -> b where { b = 5 } }
09:06:59 <quicksilver> which are the two most obvious ways to embed a where into an epression
09:07:01 <vincenz> I did have a let
09:07:07 <vincenz> let function x y = .... whre...
09:07:09 <vincenz> but it didn't wokr
09:07:17 * vincenz wishes ghci would allow multilines
09:07:27 <quicksilver> you probably need {} as above
09:07:29 <quicksilver> roughly ;)
09:07:51 <quicksilver> Prelude> let { a = b where { b = 5 } } in a
09:07:51 <quicksilver> 5
09:08:01 <LoganCapaldo> Prelude> let f x y = x + y * b - c where { b = 7 ; c = 4 }
09:08:01 <LoganCapaldo> Prelude> f 2 4
09:08:01 <LoganCapaldo> 26
09:08:18 <Botje> doesn't readline already support multiline stuff?
09:08:29 <qebab> > let { a = b where { b = 5} } in a
09:08:32 <Botje> mm_freak1: what's "affe" stand for?
09:08:38 <qebab> :o
09:08:40 <LoganCapaldo> maybe ut how's it gonna know when you're "done"?
09:08:41 <qebab> is lambdabot dead?
09:10:27 <vincenz> quicksilver: still, it would be useful if you could have multiline code, where ghci would be smart enough only to finish when you've matched all {}
09:10:47 <vincenz> the ocaml interpreter does that
09:11:33 <osfameron> is haskell indentation unambiguous?
09:11:49 <LoganCapaldo> ocaml has a statement terminator though (;;) doesn't it?
09:12:04 <vincenz> osfameron: I meant, if you used explicit {} and ;
09:12:12 <LoganCapaldo> istr always forgetting to hit ;; in ocaml and wondering why nothing was happening
09:12:20 <vincenz> it's not that hard to check "still need another }"
09:12:49 <vincenz> now I have to edit my code in vim, then remove all newlines
09:12:53 <osfameron> vincenz: ah I see.  would be nice to have indented expressions too.  (Could do that by convention of just pressing return on an emptyh line at the end)
09:13:16 <LoganCapaldo> you could edit your code in vim, leave in the newlines and :load it
09:13:25 <vincenz> LoganCapaldo: bleh
09:14:10 * vincenz is stuck on a euler problem
09:14:12 <vincenz> Keep hitting my ram limits
09:14:29 <vincenz> his time I got a stack error :|
09:14:35 <byorgey> vincenz: that probably means there's a better way to approach it mathematically.
09:14:44 <vincenz> byorgey: not this one
09:14:49 <byorgey> no?
09:14:54 <vincenz> I doubt it
09:14:57 <byorgey> which one?
09:15:01 <vincenz> 23
09:15:14 <vincenz> first I simiply did
09:15:29 <Botje> why not have a special "multiline mode" where you have to press ctrl-enter to send your commands?
09:15:30 <vincenz> [c | a <- abundants, b <- abundants, let c = a + b, c <= 28123]
09:15:36 <vincenz> but sadly, you get a LOT of redundants
09:15:41 <vincenz> so my memory got bloated
09:15:51 <vincenz> so I tried using a set instead, still a lot of page-trashing and then a stackoverflow
09:16:21 * vincenz will try using plain ghc instead of ghci
09:17:11 <byorgey> vincenz: yes, optimization can make a big difference
09:17:16 <byorgey> vincenz: be sure to compile with -O2
09:17:19 * vincenz nods
09:18:25 <Ben`> I made a simple function which generates twin prime pairs, sexy prime pairs, etc.  but I want to generalise it so it works with triplets, quadruples, etc.
09:18:30 <hpaste>  Ben pasted " " at http://hpaste.org/5132
09:18:34 <Ben`> what would be the best way to do it?
09:19:07 <vincenz> byorgey: use a set or a list?
09:19:12 * vincenz hmms
09:19:47 <Botje> Ben`: generate the list of primes lazily, then take off the first n elements and see if they're all $SOME_DISTANCE apart
09:19:57 <byorgey> vincenz: not sure.  I solved #23 in a not-particularly-nice way, in J, so I can't read my code anymore =P
09:20:00 <Botje> then drop one, repeat :)
09:20:03 <vincenz> byorgey: :)
09:20:43 <phobes> What's a sexy prime pair?
09:20:53 <Ben`> Botje: ok, thanks: I'll try
09:20:58 <vincenz> byorgey: ok, using a list or a set?
09:21:04 <Botje> vincenz: I solved it by using arrays.
09:21:14 <Ben`> phobes: http://en.wikipedia.org/wiki/Sexy_prime
09:21:17 <byorgey> Ben`: also, instead of returning a list of tuples, you'll want to return a list of lists.
09:21:20 <vincenz> Botje: oy
09:21:28 <byorgey> Ben`: you can't generalize to n-tuples.
09:21:31 <vincenz> woo!
09:21:37 <vincenz> ghc is WAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY faster
09:21:46 <Botje> yeah, that's my observation.
09:22:00 <phobes> Ben':  Ah, I should have guessed
09:22:01 * Botje wishes ghci had a "OK NOW WRITE TO FILE AND COMPILE WITH GHC" command
09:22:38 <vincenz> Botje: but I mean seriously like exponentially
09:22:49 <Ben`> Botje: ah, ok. I was going to ask what the function's type would be like if it was tuples :p
09:23:08 <Ben`> guess that's impossible though
09:23:10 <Botje> Ben`: you can't do it easily unless you start using typeclasses, unfortunately
09:33:42 <vincenz> byorgey: ok, done :)
09:33:56 <vincenz> byorgey: gotta love how my haskell implementation is -way- shorter than the c++ posted before and performs faster (on a laptop!)
09:34:07 <byorgey> vincenz: awesome =D
09:34:08 <vincenz> http://projecteuler.net/index.php?section=forum&id=23&new=true#last
09:34:22 <vincenz> comments welcome :)
09:36:02 * vincenz hmms as he notes that people only go up to n/2
09:36:45 <Lemmih> Can anyone see that page?
09:36:50 <vincenz> btw, I think my divisors implementation is more efficient
09:36:56 <vincenz> Lemmih: no, you need to be a member and have solved that problem
09:37:04 <vincenz> divisors n = 1 : concat [if d == d' then [d] else [d,d'] | d <- [2..intsqrt n], n `mod` d == 0, let d' = n `div` d]
09:37:19 <vincenz> intsqrt    = floor . sqrt . fromIntegral
09:37:27 <byorgey> vincenz: what's the point of the if d == d' then [d] else [d,d'] bit?
09:37:37 <vincenz> so I don't get [1,2,2] for 4
09:37:41 <byorgey> I am trying to understand what that's doing
09:37:47 <vincenz> byorgey: I only go up to sqrt
09:37:50 <vincenz> and I give both d and n/d
09:37:55 <vincenz> but if d == n/d
09:37:57 <vincenz> you want only one copy
09:37:58 * ptolomy checks macports for GHC 6.8 for the fifth time this week.
09:38:14 <fasta> vincenz: there is nothing on that page for non-members probably.
09:38:32 <vincenz> @let intsqrt    = floor . sqrt . fromIntegral
09:38:52 <byorgey> vincenz: oh, if d is sqrt n
09:39:07 <vincenz> > let divisors n = 1:concat [[d,d'] | d <- [2..intsqrt n], n `mod` d == 0,  let d' = n `div` d]
09:39:11 <vincenz> > let divisors n = 1:concat [[d,d'] | d <- [2..intsqrt n], n `mod` d == 0,  let d' = n `div` d] in divisors 4
09:39:17 <vincenz> no bot?
09:39:23 <vincenz> that will giv you [1,2,2]
09:39:37 <vincenz> byorgey: yep
09:39:51 <vincenz> I wonder how well it works for really big numbers tho
09:39:57 <vincenz> floor might throw off just sqrt by a bit
09:40:29 <geekagent> vincenz, my divisors function, (not currently available) iterates through prime factorization.
09:40:42 <byorgey> vincenz: for numbers under 28123 I think it is fine, but yes, it breaks for larger numbers due to rounding error
09:40:55 <vincenz> byorgey: it seems to work well so far, so I'm happy :)
09:41:14 * vincenz nods at geekagent 
09:41:38 <byorgey> vincenz: I think it could be even more efficient if, as soon as you find a divisor d, you recursively try to find divisors of n `div` d, rather than continuing to iterate up to intsqrt n
09:41:51 <vincenz> byorgey: no
09:41:59 <byorgey> vincenz: why not?
09:41:59 <geekagent> byorgey, just use the prime factorization.
09:42:03 <vincenz> byorgey: then you will never find 8 being a divisor of 16
09:42:35 <vincenz> byorgey: what that gets you is a prime-divisor list
09:42:38 <vincenz> not the full divisor list
09:42:42 <byorgey> vincenz: oh, right, I actually meant what geekagent is saying.
09:42:43 <vincenz> nd then you might as well use geekagent's approach
09:42:53 <vincenz> right, then it would be a good idea :)
09:43:26 <byorgey> but for such small numbers it really doesn't matter much.
09:43:30 <vincenz> > 10*9*8*7*6*5*4*3*2*1
09:43:35 <vincenz> grr
09:43:36 <ricky_clarkson> > let 3=2 in 3-2
09:43:44 <vincenz> ricky_clarkson: won't work
09:43:50 <byorgey>  3628800
09:44:05 <ricky_clarkson> gives 1 for me.  Why?
09:44:05 <vincenz> ricky_clarkson: 3 and 2 are actually (fromIntegral 3) and (fromIntegral 2)
09:44:21 <ricky_clarkson> heh
09:44:30 <vincenz> ricky_clarkson: it's cause 2 is of type Num a
09:44:34 <vincenz> ricky_clarkson: it's cause 2 is of type (Num a) => a
09:44:44 <vincenz> the literals are overloaded
09:45:07 <twanvl> "let 3=2" tries to pattern match lazily (which will fail), but since the result of the match is never used, there is no error
09:45:35 <hpaste>  geekagent pasted "divisors using prime_factors" at http://hpaste.org/5133
09:45:50 <twanvl> let Anyhting = SomethingElse in 3-2 == 1
09:47:59 <ricky_clarkson> Thanks.
09:48:28 <mauke> completely unrelated: http://rafb.net/p/LmY9JE80.html
09:49:30 <hpaste>  byorgey annotated "divisors using prime_factors" with "avoid recomputing f^n each time" at http://hpaste.org/5133#a1
09:52:51 <vincenz> what is prime_factors_rle?
09:53:10 <vincenz> o
09:53:12 <geekagent> it returns a run-length-encoded version of prime_factors
09:53:16 <vincenz> there's an easier way, I think
09:53:40 * vincenz ponders, calculate all subtrees
09:53:43 <geekagent> prime_factors_rle 8 = [(2,3)]
09:53:47 <vincenz> and use sharing
09:54:40 <geekagent> any divisor of 24 has 0..3 2s in it, and 0..1 3's in it , and nothing else.
09:55:09 <geekagent> this generates them so that    head divisors x == x
09:55:34 <geekagent> so you can do tail divisors x if you don't want x on the list.
09:56:43 <hpaste>  byorgey annotated "divisors using prime_factors" with "more combinator-y version" at http://hpaste.org/5133#a2
09:58:39 <geekagent> I'd have to think harder to understand using sequence in the [] monad
09:59:40 <geekagent> > :t sequence
09:59:59 <byorgey> sequence :: forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:00:08 <byorgey> Prelude> sequence [[1,2,3],[4,5]]
10:00:08 <byorgey> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
10:00:33 * geekagent laughs in aha fasion
10:00:41 * vincenz is making one giant.hs file with all the euler problems :)
10:00:41 <byorgey> =)
10:00:49 <vincenz> then I can just do "main = problemXX"
10:00:56 <geekagent> vincenz: really, me too.
10:00:59 <twanvl> you can be more efficient for this problem, because you only need the sum of the divisors
10:01:00 <geekagent> I'm on the top 1000 now.
10:01:07 <vincenz> geekagent: lots of code-sharing
10:01:11 <vincenz> geekagent: I started yesterday :)
10:01:14 <geekagent> vincenz, me too.
10:01:15 <Nafai> Here are my attempts to Project Euler: http://hg.softwaretoolsmith.com/ProjectEuler/
10:01:19 <geekagent> I have 57+ done
10:01:30 <byorgey> twanvl: ah, good point.
10:01:59 <BMeph> 27 done for me.
10:02:40 * vincenz recodes all his previous solutions in the haskell file as he used to do them in ghci :|
10:02:50 <geekagent> vincenz: I'd started doing some of the 99 Prolog problems, and so I used some of that code too for the euler problems
10:03:18 <vincenz> geekagent: neat
10:04:07 * byorgey wonders what the average "% genius" is for #haskell =)
10:05:17 <vincenz> geekagent: how do you generate prime?
10:05:22 <vincenz> s/prime/primes
10:07:56 <BMeph> I've heard that it was sorear that came up with it first, but I saw this one from oerjan:
10:08:00 <BMeph> oerjanPrime = nubBy (((>1).).gcd) [2..]
10:08:04 <vincenz> BMeph: that seems really dog slow
10:08:18 * vincenz cheats and downloads the first 1M primes from the net
10:08:27 <BMeph> vincenz: I'm sure it is. It's easy to type, though. ;)
10:08:44 <vincenz> primes <- fmap (map read . lines) $ readFile "primes.txt"
10:08:47 <geekagent> vincenz, ghc won't compile 1M primes.
10:08:49 <geekagent> I tried.
10:08:55 <vincenz> geekagent: look above :)
10:09:31 <mauke> vincenz: http://rafb.net/p/4BHnbp65.html
10:10:30 <geekagent> vincenz, I have an early terminating left fold that terminates if p*p > n
10:10:52 <vincenz> geekagent: I use intsqrt
10:11:08 <geekagent> but first I filter if q^(p-1) == 1 mod p for some q that I picked
10:11:20 <geekagent> that gets most non-primes out first
10:11:43 <geekagent> I do the exponentiation in log p time
10:12:59 <geekagent> it's fermat's test, if p is prime, then q^(p-1) === 1 mod p, but it's not an iff
10:18:19 * shepheb delurks
10:18:45 <shepheb> I'm 27% Genius and counting, whenever I have a chance to work on the problems.
10:18:48 <LoganCapaldo> ack!
10:19:13 <LoganCapaldo> delurking has to be at least as scary as decloaking
10:19:50 <dons> oh, cool, HappS in the real world, http://blog.openomy.com/2008/01/case-study-using-haskell-and-happs-for.html
10:19:50 <byorgey> welcome, shepheb! =)
10:20:23 <shepheb> I've been lurking on haskell-cafe for months, and here for a few days
10:20:48 <stevan> hi. let gs = \s -> getChar >>= \c -> if c == '\n' then return s else gs $ s ++ [c] in gs "". can i define gs in such way that i don't need to pass "" when calling it, without using a help function?
10:21:07 <BMeph> Isn't it kind of a misnomer to call it "lurking" on a mailing list? ;)
10:21:25 <kpreid> BMeph: why?
10:22:30 <LoganCapaldo> Originally I was going to say that "lurkig" on a mailing list is unobservable, but presumably someone knows who the subscribers are
10:22:42 <LoganCapaldo> so I guess it's not unlurkable
10:22:49 <osfameron> dpeends if there are accessible archives
10:22:54 <BMeph> LoganCapaldo: Unless you use Gmane... ;)
10:23:15 <byorgey> stevan: I don't think so.
10:23:47 <shepheb> well, I read through Gmane so I can use Thunderbird. It's lurking in spirit: observing the discussion without speaking.
10:24:04 <kpreid> what is this must-be-observable lurking you speak of?
10:24:17 <kpreid> to me, the word comes from usenet...
10:24:42 <Lemmih> stevan: gs = do c <- getChar; if c == '\n' then return "" else liftM (c:) gs ?
10:25:10 <LoganCapaldo> kpreid: I was just trying to help jutisfy BMeph's argument :)
10:25:11 <Lemmih> stevan: Or rather, liftM (++[c]).
10:25:35 <Lemmih> stevan: Oops, no (c:) is correct.
10:26:02 <stevan> cool.
10:26:31 <BMeph> Maybe it's just my tendency to be constantly catching up on my mail. :)
10:27:13 <BMeph> I don't consider it lurking if it's on archive, since you never had the chance to get into the conversation.
10:27:31 <fasta> It seems the ST monad is rather limited/inconvenient, isn't it?: e.g. do stAction <- something_of_type_IO_ST;return (runST (do something <- staction; return 1)) doesn't work because the s is "used in the environment". (Yes, it is used, but it is a safe use. ) Or am I missing something?
10:30:28 <vincenz> geekagent: I'm kinda cheating :)
10:30:46 <vincenz> geekagent: I use the program 'primes' to generate a file full of primes and then I read that textfile in :)
10:30:57 <geekagent> vincenz, that's not cheating
10:31:12 <vincenz> geekagent: it makes problem 7 and 10 trivial
10:33:36 <geekagent> vincenz: if you generate a list of primes and format it as a haskell list, then ghc chokes compiling it
10:34:21 <vincenz> geekagent: I told you, readFile ::)
10:34:30 <vincenz>   primes <- fmap (map read . lines) $ readFile "primes.txt"
10:34:38 <geekagent> I know, but it's not something that's hard to compile.
10:34:41 <geekagent> It shouldn't fail.
10:34:43 <vincenz> oh
10:34:44 * vincenz shrugs
10:34:49 <mux> can someone explain me the difference in meaning in the type "forall a b. a -> b -> a", that is the type of const, and the type "forall a. a -> (forall b. b) -> a" which is also inhabited by const but yields a very different thing
10:34:52 <vincenz> well I think you get problems with the stack
10:34:54 <vincenz> when you're parsing that list
10:37:47 <ski_> mux : `forall a b. a -> b -> a' is logically the same as `forall a. a -> (exists b. b) -> a', i.e. the second argument can be *any* type the caller wants .. with `forall a. a -> (forall b. b) -> a', however, the second argument must be of *every* type, i.e. it must be polymorphic
10:38:00 <Lemmih> fasta: That's life in a typed environment. There are illegal things that would work if all the types went away.
10:38:28 <fasta> Lemmih: well, I was more thinking of that the rules could be relaxed.
10:38:30 <mux> ski_: mm, I get that somehow, but I don't understand it intuitively
10:38:49 <fasta> Lemmih: but then again, probably the compiler implementors also know that....
10:38:58 <dcoutts> mux: if you ask for "forall a b. a -> b -> a" then I get to supply you with any 'b' type I like. If you ask for "forall a. a -> (forall b. b) -> a" then I really have to give you something of type (forall b. b) which is much more restrictive.
10:40:04 <mux> yeah, I get that; I think my problem is that I don't understand intuitively how forall a. (exists b. b) == forall a b. b
10:40:09 <Lemmih> fasta: Prove that the relaxation is safe and write a paper about it?
10:40:18 <mux> or however you formulate this law
10:40:19 <ski_> mux : it doesn't
10:40:26 <phobes> (forall b.b) is the bottom type, right?
10:40:44 <phobes> _|_ is the only inhabitant?
10:40:52 <Lemmih> fasta: There are usually a lot of unforeseen cases when dealing with type systems.
10:41:00 <ski_> forall a. (Foo a -> Bar)  ~=  (exists a. Foo a) -> Bar
10:41:10 <mux> that's it
10:41:18 <ski_> forall a. (Foo -> Bar a)  ~=  Foo -> (forall a. Bar a)
10:41:49 <mux> how do you explain this equality intuitively? I can't seem to wrap my head around it
10:42:06 <phobes> ski_:  In your second type for const, you are only allowed to invoke that with a second parameter of _|_
10:42:15 <vincenz> how do I get the first argument given to the program?
10:42:26 <doserj> mux: it works the same way as in first order logic
10:42:45 <ski_> phobes : in this case, yes
10:43:02 <phobes> ski_:  As opposed to?
10:43:12 <mux> doserj: still doesn't click :-(
10:43:16 <harinath> mux: curry-howard, I think :-)  Treat the type a->b as implication a=>b, i.e., '(not a) or b' -- when a forall is distributed over an or, it remains a forall, but over a not, it becomes an exists
10:43:28 <ski_> phobes : i don't know, this is the case mux asked about
10:43:49 <phobes> ski_:  Oh sorry, I meant to address mux :)
10:43:49 <LoganCapaldo> vincenz: if you mean command line args, System.IO.getArgs
10:44:44 <ski_> mux : the creator(/callee) of a value of type `forall a. ..a..' must ensure every type `a' could work, and the user/(caller) of the value gets to choose which `a' to use
10:45:15 <phobes> mux:  For all types of dogs, if you give me that type of dog, I can shave it.    vs.   If you give me something that is some type of dog, I can shave it.
10:45:43 <mux> you should be all able to hear my brain grinding
10:45:50 <mux> I think it's painfully getting in
10:45:57 <ski_> mux : (conceptually : ) the user(/caller) of a value of type `exists a. ..a..' must ensure every type `a' could be handled, and the creator/(callee) of the value gets to choose which `a' to use
10:46:44 <shepheb> phobes: can you write those as types to solidify it in my brain?
10:47:23 <ski_> mux : so in `forall a. Foo a -> Bar' you can view that as the caller/user deciding which `a' to use the function at .. while in `(exists a. Foo a) -> Bar' the caller/user still gets to choose which `a' to use for the argument (and the callee must be able to handle any `a')
10:48:16 <LoganCapaldo> would be fair to say that const : forall a b. a -> b -> a there is a const for every possible combination of a and b, and that for const :: a -> (forall b. b) -> a there is a const for every possible a?
10:49:01 <LoganCapaldo> read fair as "vaguely accurate"
10:49:15 <phobes> shepheb:  Change it to "count hairs on" instead of "shave" for simplicity ... countHairs :: forall Dog.  Dog -> Nat,   vs.  countHairs :: (exists Dog) -> Nat
10:49:16 <ski_> LoganCapaldo : `forall a b. a -> b -> a' is also for every possible `a' (and `b' as well)
10:49:29 <doserj> LoganCapaldo: there is a const for every possible a, which works for every possible b (in the latter case), yes
10:49:41 <LoganCapaldo> ski_: isn't that what I said?
10:50:16 <ski_> (LoganCapaldo : just noting that your second statement holds in the first case, as well)
10:50:24 <mux> I understand the logical rule => not (forall x. not a) == exists x. a but I can't relate it to forall in haskell (yet)
10:51:11 <mux> *grumble*
10:51:21 <ski_> (LoganCapaldo : i.e. "for const :: a -> (forall b. b) -> a there is a const for every possible a" holds for `const :: forall a b. a -> b -> a')
10:51:56 <ski_> mux : there's no `not' type in haskell that satisfies that
10:52:16 <mux> yes, I'm actually talking about the first order logic rule
10:52:29 <mux> using "not" and "forall" instead of the usual operators
10:52:49 <phobes> LoganCapaldo:  const :: forall a b. a -> b -> a   means that  (const a) is a function such that (const a) b == a  for all b.
10:53:18 <phobes> LoganCapaldo:  const :: forall a . a -> (forall b.b) -> a   means that  (const a) is a function such that (const a) _|_ == a
10:53:20 <ski_> (such a `not' type would be a type of continuations (turned into values))
10:54:00 <phobes> LoganCapaldo:  Excuse my horribly confusing use of 'a' as a value and a type :)
10:54:14 <joglala> Hello
10:54:37 <ski_> phobes : was going to complain about that, yes ;)
10:54:46 <ski_> joglala : olleh
10:55:10 <litb> o.O
10:55:10 <LoganCapaldo> ski_: let me try wording this slightly differently, to see if I actually get this, if polymorphism were "implemented" by creating N versions of the function where N is the number of types in the universe, the number of versions of const :: a -> b -> a would be N^2 and the number of versions of const :: a -> (forall b. b) -> a would be N.
10:55:17 <joglala> I have the following term: x : xs : ys = (x : xs) ++ ys, i think it does not work because xs isn't of type list, but hugs says, it does not work cause x is not of type list
10:55:25 <doserj> mux f::forall a . a -> Int says that for all possible a, f (x::a) is an Int. f::(forall a . a) -> Int says, if x is of type a, for every a, the f (x::forall a . a) is an Int. see the difference?
10:55:45 <mm_freak> Botje: "affe" is german and means "ape"
10:56:00 <Botje> ah :)
10:56:00 <Botje> makes sense
10:56:35 <mm_freak> =)
10:57:06 <litb> what does "xs" mean? why doesn't people chose z for it?
10:57:19 <mux> doserj: I hate to say this, but I don't really get the second part explaining the type f::(forall a. a) -> Int
10:57:24 <ski_> LoganCapaldo : how about `(forall a. a -> a) -> (forall a. a -> a)' ?
10:57:29 <litb> does it mean "x string"?
10:57:44 <phobes> litb:  The 's' is supposed to signify plural usually, as in "more than one of"
10:57:48 <ski_> litb : the "s" is plural, so "many `x's"
10:57:52 <litb> ah
10:57:55 <doserj> mux: that f takes an argument of type forall a . a
10:58:12 <mux> doserj: but I don't understand the meaning of that type
10:58:15 <doserj> that means, the argument must be of type a, for every a
10:58:22 <mux> mm
10:58:27 <ski_> @type let x = x in x
10:58:34 <doserj> i.e., it must be of every type
10:58:40 <phobes> mux:   The only value that is of every type (a list, an integer, ...) is _|_
10:58:46 <ski_> lambdabot ?
10:58:47 <mux> yeah, I get that
10:58:48 <mux> mmm
10:58:57 <mux> (old machinery noises)
10:59:30 <kalmar> ?users
10:59:46 <litb> lambdabot is dead
10:59:47 <mux> in the end, what matters is "where" you put the "for every a" when you read the type
10:59:47 <kalmar> > 2
10:59:49 <kalmar> :(
11:00:03 <litb> it has been botted
11:00:09 <mux> it's a matter of scoping
11:00:11 <kalmar> the bot got botted?
11:00:24 <doserj> mux: nowwhat does f::(exists a . a) -> Int mean? well, if there is an a, such that x::a, then f (x::a) is an Int
11:00:48 <doserj> but every x has some type!
11:00:53 <litb> kalmar: yo, tho bot got botted o.O
11:01:02 <doserj> so f works, whatever x you give it to
11:01:07 <ski_> joglala : `x : xs : ys' means `x : (xs : ys)', here `x' and `xs' must have the same type, and `ys' be a list of values of that type
11:01:15 <phobes> mux:  Ya, order of quanitifers matters like in logic "There exists a man that is stronger than every woman"  "For every woman there is some man stronger than her" say different things
11:01:19 <kalmar> ah well
11:01:29 <doserj> which means the same as f::forall a . (a -> Int)
11:01:36 <mux> am I correct in saying that actually, every time you see a type such as "forall a b. a -> b -> a" you could understand it as "forall a b. exists a. a -> exists b. b -> exists a. a" ?
11:01:46 <phobes> mux:  no: )
11:01:54 <LoganCapaldo> ski_: I gues that's a way of saying "no"? :) Cause I can't quite figure out if the answer should be 1, or N :)
11:02:02 <mux> oh that doesn't make sense since that would make the a's possibly different here
11:02:07 <phobes> mux:  The problem there is that your latter type has different existentials, yes
11:02:28 <joglala> ski_: Bute (x : xs) ++ ys does not work, because x and xs are not lists, right?
11:02:29 <mux> but if a and b were referred only once, it would be understood as this?
11:02:38 <phobes> mux:  Also, existentials change differeently depending on which side of the (->) you want to bring them into
11:02:46 <mux> or as, "forall a b. exists a. a -> exists b. b -> a" ?
11:02:48 <ski_> LoganCapaldo : i'm just thinking this `number of versions' doesn't necessarily make sense, in some cases, yes
11:03:12 <phobes> forall a b.  (a -> b)    ==    (exists a.a) -> (forall b.b)
11:03:15 <ski_> joglala : maybe it would be good here to define "does not work" .. what are you trying to do ?
11:03:34 <ski_> joglala : patternmatching out parts of a list ?
11:04:47 <joglala> It's an exercise and i verify what i thing about the term with the error message of hugs ;)
11:05:23 <joglala> Hugs says 'term x must be of form [a]' if i interpret it right
11:05:37 <ski_> joglala : are you trying to write `x : xs : ys = (x : xs) ++ ys' as a definition ?
11:05:42 <joglala> yes
11:06:36 <ski_> in `(x : xs) ++ ys' we get `(x : xs) :: [a]',`ys :: [a]' for some type `a'
11:07:22 <ski_> i.e. `x :: a',`xs :: [a]',`ys :: [a]'
11:08:03 <ski_> in `x : xs : ys' i.e. `x : (xs : ys)' we get `x :: b',`(xs : ys) :: [b]' for some type `b'
11:08:28 <ski_> i.e. `x :: b',`xs :: b',`ys :: [b]'
11:08:28 <ski_> so
11:08:48 <ski_> `a = b',`[a] = b',`[a] = [b]'
11:08:55 <ski_> which simplifies to
11:09:09 <ski_> `a = b',`[a] = a'
11:10:06 <joglala> Give me some time to evaluate this ;)
11:10:28 <ski_> the problem is `[a] = a' which requires `x',`xs',`ys' to be lists containing elements that are themselves lists of the same type (thus coantining elements of the same type as ... ad nauseum)
11:11:12 <ski_> such infinte types aren't allowed by the type-system (if you want cyclic types, you have to define a named recursive type)
11:11:42 <joglala> Ahh, thats why he says unification would give infinite type
11:12:06 <litb> hm, haskell allows infinite lists
11:12:54 <ski_> if such infinite types were allowed, then the only possible values of the type in this case would be things like `[]',`[[],[[],[]],[[[],[],[]]]]',..
11:13:01 <litb> can i calculate converging sum series with it?
11:14:17 <litb> i guess the tool of choice is unfoldr or something?
11:14:37 <ski_> litb : as long as you only require approximations to the sum (as fine as you want), then sure
11:14:37 <phobes> ski_:  Dont' forget x = [x]
11:15:12 <ski_> phobes : *nod*
11:15:33 <litb> ski_: how would i do that? i mean, i need to keep track at which sum i am. would i make a tuple of (value, number_of_value) ?
11:15:42 <ski_> (if you should want to play with such types, then you could try `ocaml -rectypes')
11:16:06 <phobes> ski_:   and x = [x,x]...   I wonder if x = [x,[x]] should be allowed?
11:16:14 <joglala> [x] : [] = [x] ++ [], that seems to be a bit harder
11:16:15 <litb> and return ((a, index), (b, index+1)) from the function unfoldr uses, and sometimes if index gets too big, then return Nothing?
11:17:33 <joglala> [x] is the head element of [] and [x] ++ [] appends an empty list at the end of it
11:17:44 <ski_> # let rec x = [x];;
11:17:45 <ski_> val x : 'a list as 'a =
11:17:49 <ski_>   [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
11:17:53 <ski_> # let rec x = [x;[x]];;
11:17:54 <ski_>   [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...];
11:17:57 <ski_> val x : 'a list as 'a =
11:17:58 <ski_>                                                                     [[...]]];
11:18:00 <ski_>                                                                     [...]];
11:18:11 <ski_> (rezst some thirty lines omitted for brevity)
11:18:23 <phobes> ski_ hehe
11:18:28 <ski_> phobes : so, yes
11:18:57 <phobes> ski_:   Ya, I guess that's the equi- vs. iso- recursive bit...    But O'Caml probably can't do everyone's favorite:  x = x:x
11:19:32 <phobes> or I guess it can?
11:19:51 <ski_> it can
11:21:55 <ski_> (btw, one reason why equi-recursive types usually aren't allowed is that then the type-system wouldn't catch stupid mistakes such as calling recursively with wrong number of arguments directly, but construct strange cyclic types instead)
11:21:55 <joglala> Hmm
11:22:23 <joglala> I don't really see my mistake
11:22:42 <ski_> [x] : []  =  [[x]]
11:22:48 <joglala> Ahh
11:22:50 <ski_> [x] ++ []  =  [x]
11:23:08 <vincenz> How do you split a list based on a character?
11:24:32 <joglala> ski_: But doesn't that mean, that haskel matches http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x ([x]:[]) and then replaces as by [x]?
11:24:51 <joglala> ski_: But doesn't that mean, that haskel matches [ [ x ] ] ([x]:[]) and then replaces as by [x]?
11:25:39 <joglala> "as" was supposed to be "that"
11:25:53 <jfredett> is there anyone around who might be willing to answer a Category theory question?
11:27:22 <ski_> joglala : are you talking about passing `[ [ x ] ]' into a function that pattern-matches on `([x]:[])' ?
11:27:30 <joglala> yes
11:27:48 <joglala> and then [x] should be the result?
11:27:49 <ski_> jfredett : you could state the question, at least ..
11:28:19 <jfredett> workin on it, ski_, its a little on the long side
11:28:20 <jfredett> :)
11:28:28 <ski_> joglala : the result of pattern-matching is either failure, or, the binding of some variables to values
11:28:38 <jfredett> heres the question, if a category is a collection of arrows between objects. were an arrow maps and object to an object, and a functor maps an arrow to an arrow, (it's an arrow in the category of categories (i think the term is 2-category)), then is it fair to say that a natural transformation (mapping from functor to functor) is just an arrow in the category of categories of categories? (a 3-category?)
11:28:49 <joglala> ski_: I have only this single line in my file
11:29:15 <ski_> joglala : which line ?
11:29:26 <joglala> [x] : [] = [x] ++ []
11:29:43 <joglala> it loaded it with bugs and he does not want it
11:29:55 <monochrom> I wouldn't have guessed the "[x] ++ []" part occurs in your file.
11:30:12 <joglala> Ohh
11:30:24 <joglala> I try to be more precise
11:30:48 <ski_> `[x] ++ []' means `[x]' is a list of, say, `a's, `[x] : []' means that `[x]' is also an element of that type `a', so `a = [a]' again, cyclic type
11:31:44 <monochrom> Why are you write "[x] : [] = [x] ++ []"?  It is probably very wrong to begin with, wrt what you want.
11:31:59 <ski_> (monochrom : i believe that is the point)
11:34:01 <ski_> jfredett : an arrow doesn't map objects to objects, it maps *from* an object to an object .. otoh, a functor maps arrows to arrows  (it's not clear if this is what you meant to write)
11:34:24 <joglala> I got these exercises from my "teacher"
11:35:12 <monochrom> An arrow doesn't map anything. Unless you analogize object to set, arrow to function.
11:35:59 <ski_> jfredett : in the 2-category Cat of (small) categories, the (small) categories are objects (0-arrows), the functors between the (small) categories are arrows (1-arrows), and the natural transformations between then functors are 2-arrows
11:36:01 <monochrom> An arrow just sits there doing nothing, waiting to be composed with other arrows to produce more arrows. That's all they do.
11:36:11 <jfredett> okay
11:36:18 <jfredett> ski_: thats what I was trying to ask
11:36:59 <ski_> monochrom : *nod*
11:37:19 <jfredett> monochrom: so arrows are a bit like rabbits then?
11:37:36 <ski_> ?
11:37:39 <byorgey> hehe
11:37:40 * merus smells another tutorial for monads.
11:37:57 <monochrom> Gosh, analogies should be outlawed. All of them.
11:38:00 <jfredett> lol
11:38:12 <monochrom> "arrows are like rabbits" makes no sense.
11:38:23 <monochrom> "the blue sky is like dark chocolate"
11:38:26 <ski_> allegories, however, are just fine
11:38:31 <monochrom> "haskell is like cheese"
11:38:42 <byorgey> rabbits just sit there waiting to compose with other rabbits to produce more rabbits, of course
11:38:44 <jfredett> arrows are like rabbits, arrows wait around to compose and make new arrows
11:38:56 <jfredett> rabbits wait to compose and make new rabbits
11:38:57 <jfredett> :)
11:39:04 <byorgey> and we all know what the composition operation is in the category of rabbits.
11:39:05 <jfredett> i think it makes perfect sense
11:39:11 <jfredett> byorgey: exactly
11:39:13 <monochrom> If you want to say that, you can say that extremely clearly without mentioning rabbits or cheese or haskell or the blue sky.
11:39:17 <twanvl> ?remember jfredett so arrows are a bit like rabbits then?
11:39:28 <byorgey> monochrom: I think it was supposed to be a joke. =)
11:39:32 <phobes> > "I'm sorry dave"
11:39:42 <jfredett> :)
11:39:44 * monochrom now hates analogies, following Dijkstra.
11:39:54 <byorgey> by analogy with Dijkstra?
11:40:20 <monochrom> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html
11:40:24 <twanvl> "analogies are like gotos"
11:40:43 * byorgey goes off to write a "haskell is like cheese" tutorial
11:41:02 <jfredett> byorgey: remember to include the "arrows are like rabbits" bit
11:41:18 <byorgey> jfredett: of course!
11:41:29 <byorgey> and monads are like dark chocolate
11:41:42 <jfredett> @quote dons monads
11:41:50 <jfredett> oh wait, is \bot still down?
11:41:54 <byorgey> =(
11:43:50 * byorgey yodels for dons
11:44:19 <joglala> Can you tell me why this is wrong? (x : ys) ++ zs = x : (ys ++ zs)
11:44:48 <monochrom> Can you tell me what you are doing?
11:44:50 <joglala> hugs don't likes that ++
11:45:09 <joglala> I just put it in a file and run it
11:45:15 <dons> i can't get it to connect from its home :(
11:45:20 <byorgey> joglala: if you're trying to define ++ yourself, you'll need to hide the one in the prelude.
11:45:24 <byorgey> dons: =(
11:45:30 <monochrom> ++ is already defined.
11:45:32 <joglala> Ahh
11:45:34 <dons> i'll put it back in its own home for a little while
11:45:56 <joglala> But I can do "xs ++ [] = xs", didn't this define ++, too?
11:46:31 <Valodim_> yaaay
11:46:43 <dons> ?users
11:46:49 <byorgey> joglala: yes.  I suspect the problem is with the ++ on the right side of the other definition, where it can't tell which ++ you want to use
11:46:51 <lambdabot> Maximum users seen in #haskell: 425, currently: 425 (100.0%), active: 3 (0.7%)
11:46:59 <byorgey> @botsnack
11:47:06 <lambdabot> :)
11:47:14 <Valodim_> ahaha
11:47:29 <jfredett> @quote monad
11:47:29 * byorgey does the happy-happy-lambdabot-is-back dance!
11:47:29 <lambdabot> Philippa says: hey, if the guy wants a monadectomy that's his choice
11:47:45 <jfredett> arr, what was the nuclear reactor quote thing for monads
11:47:51 <jfredett> @quote dons monad
11:47:51 <lambdabot> dons says: First you had to get the monads, then you get the power, then you get the women.
11:47:56 <monochrom> compilers and interpreters need a telepathic interface.
11:47:59 <jfredett> :/
11:48:03 <Valodim_> did that ever actually work for anyone?
11:49:21 <ddarius> @google kowey A monad is like
11:49:22 <joglala> that when evaluating the x : (ys ++ zs), haskell does not know if i mean the current pattern, or the ++ predefined pattern?
11:49:24 <lambdabot> http://en.wikibooks.org/wiki/Talk:Programming:Haskell_arrows/Kowey
11:49:30 <monochrom> Apparently 'ERROR "x.hs":2 - Ambiguous variable occurrence "++"  Could refer to: Main.++ Hugs.Prelude.++'  is understood by no humans.
11:49:41 <byorgey> joglala: right.
11:49:56 <byorgey> joglala: at the top of your file, put 'import Prelude hiding ((++))'
11:50:11 <byorgey> joglala: then the pre-defined one will be hidden and you can define it yourself.
11:51:37 <bos> woot! draft real world haskell chapters for public consumption! http://programming.reddit.com/info/665dh/comments/
11:51:38 <lambdabot> Title: programming: Real World Haskell book: public beta chapters now available
11:52:15 <dons> woot! scary!
11:52:18 <byorgey> nice!  bos++ dons++ CosmicRay++
11:52:20 <joglala> thank you :)
11:52:44 <dons> bos is awarded title "web publishing guru"
11:52:54 <phobes> bos:  shamelessly links us to his reddit post instead of the actual article :)
11:53:06 <ddarius> Yay!
11:53:28 <ddarius> bos++ dons++ CosmicRay++
11:54:12 <dons> bos, did you see the happs review today? quite positive.
11:54:20 <bos> yeah, i saw.
11:54:24 <dons> we've got to get alexj a web designer, and a document writer, though.
11:54:31 <dons> pimp out happs.org some. :)
11:54:40 <bos> no kidding.  i beat him up about that at every opportunity.
11:55:03 <bos> i'd really like to be able to write about happs for the book, but not if it looks like a monkey's bum and has no documentation.
11:55:25 <dcoutts> heh heh :-)
11:55:55 <dcoutts> @remember bos i'd really like to be able to write about happs for the book, but not if it looks like a monkey's bum and has no documentation.
11:55:56 <lambdabot> It is stored.
11:57:07 <Saizan> :D
11:58:09 <njbartlett> Hey looks like somebody's organising a Haskell Hackathon in Japan
11:58:12 <njbartlett> http://d.hatena.ne.jp/yukoba/20080121/p1
11:58:13 <dons> oh?
11:58:14 <lambdabot> Title: Haskell Hackathon  - yukoba
11:58:16 <dons> yay
11:59:07 <lucca> holy sjis batman
11:59:36 <dons> yep, looks like it, njbartlett . woot.
11:59:42 <Eelis> first sentence on happs.org: "HAppS provides you with all the major server components you need to build high quality."  erm, high quality _what_ ?
11:59:56 <byorgey> wonder what they'll be hacking?
11:59:57 <dons> "the person of the Haskell boundary, at all there is no acquaintance, we would like us to meet, is!"
12:00:02 <JBGood> high-quality quality
12:00:10 <dons> its all about quality, Eelis
12:00:18 <matthew-_> high-quality LAMP applications
12:00:22 <Eelis> a general framework for quality eh :)
12:00:25 <JBGood> LAMH
12:00:36 <dons> that's it.
12:00:41 <matthew-_> just really tall "quality"
12:00:45 <byorgey> you know, high quality.  like high tea, or high fantasy.
12:00:49 <matthew-_> it reaches up in to the sky
12:01:29 <znutar> the first sentence on happs.org isn't a concrete sentence.  It's a function on nouns
12:01:49 <dons> so i hope all you guys are reading the drafts, commenting, and improving things. make this book one the whole community get get behind.
12:02:00 <matthew-_> "curried english"
12:02:08 <matthew-_> it's what comes out of kebab shops
12:02:10 <byorgey> znutar: lol!
12:02:13 <dons> znutar: like: made of win and awesome?
12:02:16 <JBGood> znutar, there's an implicit is there
12:02:41 <byorgey> dons: well, you have to use a lambda there.  \x -> x is made of win and awesome.
12:02:56 <dons> that's true.
12:03:07 <JBGood> the type-inferencer works for that?
12:03:50 <pejo> dons, where are the drafts? I'm a bit late as usual.
12:03:56 <monochrom> "high quality" is a noun phrase.
12:04:25 <matthew-_> hmmm. both curriedenglish.org and curried-english.org are available. What to register...
12:04:33 <dons> pejo: got the url?
12:04:42 <dons> pejo: start here, http://www.realworldhaskell.org/blog/2008/01/21/finally-the-public-beta-programme-begins/
12:04:43 <lambdabot> Title: Real World Haskell  Blog Archive  Finally, the public beta programme begins!, http://tinyurl.com/yr2clk
12:04:53 <dons> because we want another 5000 comments to work through.
12:05:16 <pejo> dons, ah, will do. Thanks.
12:05:33 <dons> bos, we should publish all the comments later, in their own book, something like the silmarillion :)
12:10:48 <joglala> how can i find out if a specific element is part of a list in haskel?
12:11:03 <Feuerbach> joglala: elem
12:11:12 <joglala> Ahh, thanks
12:14:48 <bos> dons: heh heh
12:15:36 <ddarius> bos: How often do you pimp the community in the book?
12:16:24 <bos> ddarius: haven't really written the parts that would make sense to do that yet
12:16:42 <bos> ddarius: i think that belongs in chapter 1, which we've steered clear of thus far
12:17:03 <dons> new avl trees library by adrian hey on hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AvlTree-2.4
12:17:06 <lambdabot> http://tinyurl.com/yvkcf4
12:17:17 <dons> (i wonder if that means he's working towards a new Map ...)
12:17:29 <phobes> Does anyone have a solid argument to support the claim that a strong type system like in haskell provides expressive power over dynamic languages?
12:18:06 <dons> phobes: some abstractions are only possibly if you've machine support. e.g. monads
12:18:28 <dons> when the abstraction is complicated enough, you must have type system support, or it becomes a riddle of bugs
12:18:29 <bos> phobes: notions like functors, monads and monoids are much harder to think about if you don't have a suitable type system.
12:18:42 <phobes> dons:  I can see an argument like that
12:18:54 <dons> the python/ruby guys often talk about this, when they write their monad demos
12:18:56 <phobes> dons:  It's not that you couldn't do the same thing in a dynamic language... you just can't do it safely
12:19:03 <hpaste>  jogla pasted "(no title)" at http://hpaste.org/5134
12:19:08 <dons> right. its too complex to manage without guidance
12:19:21 <vincenz> byorgey: did you solve 27/
12:19:27 <joglala> Hey whats that, he announces what i paste, great!
12:19:43 <monochrom> http://higherlogics.blogspot.com/2008/01/worst-monad-tutorial-except-for-all.html  and  http://higherlogics.blogspot.com/2008/01/almost-type-safe-general-monad-in-c-aka.html  may illustrate a bit of static type vs dynamic type.
12:19:45 <lambdabot> Title: Higher Logics: The Worst Monad Tutorial... Except For All Those Others., http://tinyurl.com/2uzeg3
12:19:54 <joglala> I don't understand what the lines i pasted are doing
12:20:05 <phobes> bos:   In theory you can always annotate the types to help you think about things
12:20:07 <joglala> They seem to be an implementation of "and"
12:20:17 <monochrom> But now I have a word in defense of dynamic type.
12:20:43 <byorgey> joglala: exactly.
12:20:52 <byorgey> vincenz: yes
12:20:58 <bos> phobes: the thing is, without a type system, you're less likely to even think in terms of an idea like "a list whose elements are all of the same type". you'll just shove any old thing into a list, because you can.
12:21:21 <phobes> bos:  I agree, but I don't think that's the same as expressivity
12:21:26 <bos> the lack of restrictions makes it harder to see what a type system could buy you.
12:21:32 <joglala> But i don't understand how they work, True y = y means its true when y is true, thats clear
12:21:38 <vincenz> byorgey: bruteforce?
12:21:42 <joglala> but x y = False isn't
12:21:48 <phobes> bos:  expressivity to me implies extra power - giving you the ability to do things you couldnt' otherwise do (in the same amount of work)
12:21:54 <njbartlett> dons: Larry O'Brien makes a very similar point: "But I really had a hard time refactoring my Ruby into a packrat parser. This was due, in no small part, because of the difficulty in understanding the types being built-up in the data structure. The paper, in explicitly-typed Haskell: clear as a bell. My code's behavior on unit tests: virtually indistinguishable from random."
12:21:59 <monochrom> A language has been demonstrated to be quite incapable of "class <M><A> { ... }". But this is a limitation of the language. You could easily design a dynamic type language supporting "class <M><A> {...}".
12:22:17 <joglala> I have True True" as "x y", and now thats "False"?
12:22:52 <phobes> bos:  monochrom:  What is "class <M><A>?
12:23:05 <monochrom> You know "class M<A>", right?
12:23:18 <monochrom> But that fixes M. Now parametrize over M too.
12:23:19 <byorgey> vincenz: yeah.
12:23:26 <phobes> bos:  oops sorry - that didn't mean "pass this along to monochrom" :)
12:23:41 <byorgey> joglala: pattern matching happens in the order the equations are declared.
12:23:45 <joglala> Ahh, if x is true, he uses "True y" instead of "x y"
12:23:51 <joglala> cool
12:23:52 <phobes> monochrom:  What language are we imagining this in?
12:23:52 <vincenz> byorgey: but using a smart way to see if something's prmie
12:24:02 <byorgey> joglala: right, the only way it will get to the second case is if x is False.
12:24:24 <monochrom> Any class-based language that also has "template" or "generic".
12:24:41 <monochrom> See again the links I mentioned for motivation.
12:24:42 <byorgey> vincenz: right.  I first generated a bunch of primes and cached them in an array.
12:24:49 <ddarius> phobes: Look at phantom types and the runST trick.  These are things that can't be simulated in a dynamically typed language.
12:26:06 <byorgey> vincenz: hmm, actually, it looks like I only cached the primes up to 1000 in an array, which gave plenty of speed
12:27:11 <joglala> Thats so straight forward that i would say its "from the back through the chest into the eye"
12:27:32 <dons> njbartlett: very interesting.
12:27:35 <vincenz> byorgey: how do you cache em in an array?
12:27:45 <vincenz> byorgey: Array Integer Bool
12:27:45 <vincenz> ?
12:27:49 <dons> so we get to safely explore new ground, that's infeasible without the language helping you through the abstractions
12:27:53 <byorgey> vincenz: yep.
12:28:08 <vincenz> byorgey: only up to 1000?
12:28:12 * vincenz seems surprised
12:28:50 <phobes> ddarius:  By the 'runST' trick, you're referring to the 'doing it in-place' part, right?
12:29:35 <byorgey> vincenz: full disclosure, I actually solved it in April of '06, before I knew haskell; I wrote it in C++.
12:29:54 * vincenz wrinkles his nose
12:29:56 <byorgey> vincenz: but I have faith that you can get comparable performance with ghc.
12:30:30 <byorgey> joglala: =)
12:30:47 <vincenz> byorgey: not that hard with ghc :)
12:30:56 <dons> njbartlett: type systems for exploring new algorithms -- like mountaineering -- sure, you get up their with your own two feet, but to really explore the interesting parts, you'll need some ropes and picks and oxygen to help get you there :)
12:31:01 <byorgey> vincenz: exactly. =)
12:31:50 <njbartlett> dons: And ideally a sherpa
12:31:51 <njbartlett> :-)
12:32:20 <dons> a "researcha"?
12:32:37 <ddarius> phobes: No, I'm referring to the type of runST and the guarantees it provides
12:32:54 <monochrom> A program has type structure. The language could make it obvious or hide it.
12:32:57 <byorgey> njbartlett, dons: I think those are called "grad students" ;)
12:33:22 <monochrom> Dynamic typing doesn't necessarily hide the type structure. So far, most dynamic typing languages do hide it.
12:33:57 <dons> have new data structures ever come out of dynamic language land?
12:34:12 <hpaste>  jogla pasted "contains implemantion" at http://hpaste.org/5135
12:34:25 <monochrom> It is the same debate as old Fortran vs old Algol. The former doesn't make the data structure obvious. The latter makes the data structure obvious.
12:34:32 <joglala> I try to implement "elem" on my own
12:34:35 <phobes> ddarius:  oh I see
12:34:37 <ddarius> dons: I'm sure some were worked out in Lisp originally.
12:34:48 <dcoutts> dons: spaghetti graph
12:35:10 <dons> i just can't imagine something, like say, a RB tree coming out of a dynamic language
12:35:11 <joglala> the first function should give true if the first element x of the list is the same as the second argument
12:35:13 <byorgey> joglala: using the same name in different patterns won't check for equality.
12:35:23 <monochrom> It is the same debate as assembly language vs old Fortran. The former doesn't make data dependency obvious. The latter makes data dependency obvious.  X = F*C + D is obvious.
12:35:26 <joglala> It doesn't even complie :P
12:35:31 <byorgey> joglala: right =)
12:35:45 <byorgey> joglala: you should say contains (x:xs) y = ... something with x and y ...
12:35:49 <Japsu> @pl \y xs -> length (dropWhile (/= y) xs) > 0
12:35:49 <lambdabot> flip flip 0 . (((>) . length) .) . dropWhile . (/=)
12:36:08 <joglala> x == y?
12:36:13 <joglala> Looks right
12:36:22 <monochrom> It is the same debate as C vs C++. You could do OOP in both. But if you mimick OOP in C, the class structure is not obvious.
12:36:52 <byorgey> joglala: sure, but note that the patterns (x:xs) y  will match any non-empty list and something else, so you must also deal with the case where x and y are not equal.
12:37:37 <byorgey> joglala: the second line there will never be reached.
12:38:20 <dons> dcoutts: do you know if Igloo's still doing work on happs?
12:38:27 <joglala> contains (y : xs) x = x == y || contains xs x seems to be better, but its not the solution
12:38:31 <Lemmih> dons: He is.
12:38:41 <dons> Lemmih: and you too?
12:39:00 <Lemmih> dons: Yep.
12:39:02 <dons> where's the happs blog on planet haskell? :) why don't we have a stream of 'what's new in happs' articles? :)
12:39:19 <dons> ok. great. anyone else working on happs?
12:39:28 * dcoutts would be interested to follow happs development news too
12:39:34 <joglala> contains [] x = False
12:39:38 <joglala> Wow, thas really hot!
12:39:47 <dons> its just ever so slightly undersold atm.
12:39:48 <Lemmih> dons: Saizan is too.
12:39:55 <dons> oh, great.
12:40:14 <ddarius> joglala: Yep.  You just write down what it should do in each case.
12:40:48 <joglala> Its really cool
12:41:25 <ddarius> "Does [] contain y? No. Does (x:xs) contain y?  Yes if x == y or xs contains y.
12:41:27 <ddarius> "
12:41:41 <joglala> :)
12:45:56 <monochrom> So is it hot or is it cool?
12:46:08 <olsner> yes!
12:46:28 <nominolo> dcoutts: be happy - RWS uses British English spelling ;)
12:46:34 <nominolo> er, *RWH
12:46:44 <dcoutts> RWH?
12:46:51 <monochrom> Ramsey Wright Hospital?
12:46:51 <nominolo> Real World Haskell
12:46:57 <dcoutts> hah hah
12:47:03 <dcoutts> good good
12:47:08 <nominolo> or maybe it's Australian?
12:47:24 <dcoutts> Australians tend to use proper spelling too
12:47:33 <nominolo> is that the same?  common wealth stuff?
12:47:42 <dcoutts> no, just civilised
12:47:47 <monochrom> Just don't let them read aloud. :)
12:48:02 <nominolo> standardized differently
12:48:44 <nominolo> monochrom: don't like Australian accent?
12:48:44 <monochrom> I have had the training of listening to all sorts of English accents.
12:49:42 <Lemmih> dons: The HAppS-dev mailing list is very active. However, we're not ready for a stable release. Once we get something stable, we'll make the development more incremental.
12:49:53 <nominolo> New Zealandish is funny - i've seen a GoogleEDU lecture on automated "teasting"
12:49:57 <nominolo> that was a treat
12:50:05 <dons> Lemmih: oh, good to know.
12:50:43 <dcoutts> nominolo: I think you mean standardised not standardized :-)
12:50:47 <monochrom> I got that dose from the documentaries behind the LOTR movie.
12:50:56 <nominolo> dcoutts: no no, that was deliberate
12:51:08 <dcoutts> :-)
12:52:13 <dcoutts> nominolo: btw, I'd like your and Igloo and others opinion on doing a new Cabal-1.4 release before ghc-6.10
12:52:30 <dcoutts> it'd be mostly compatible with the current 1.2 series
12:52:40 <dcoutts> ie not break the UserHooks api
12:52:51 <joglala> is if a function or some kind of predifined key word?
12:53:01 <nominolo> dcoutts: i'd like us to think about using numbered module names for the public API (hooks)
12:53:02 <allbery_b> keyword
12:53:05 <byorgey> joglala: unfortunately, if is syntax.
12:53:12 <joglala> :)
12:53:14 <joglala> Thas nice
12:53:35 <joglala> Because i have to implement insert and must not use function from prelude
12:53:38 * byorgey often defines a function if' b t e = if b then t else e
12:53:41 <dcoutts> nominolo: I don't think that's the problem, the problem is that supporting the old apis prevent us making certain internal changes
12:53:58 <nominolo> dcoutts: so we could do something like import Cabal_2_0 or so.  Yes, it's ugly
12:54:08 <dcoutts> nominolo: ie doing a translation layer would be almost impossibly hard
12:54:16 <byorgey> joglala: then yes, you can use if.
12:54:26 <nominolo> dcoutts: translate what to what?
12:54:42 <oerjan> joglala: but == is a function...
12:54:42 <nominolo> dcoutts: i worry about record fields and such things
12:54:42 <dcoutts> nominolo: the old api to some new underlying impl
12:55:17 <lightstep> import Future (Cabal_2_0)
12:55:18 <sjanssen> dcoutts: perhaps the .cabal file could be extended with a preferred Cabal version?
12:55:21 <dcoutts> nominolo: I'd have to test but I don't think we've actually changed anything in the well-used parts of the public api that'll break any Setup.hs scripts
12:55:27 <nominolo> dcoutts: yeah, we would need a new layer on top, that'd eventually turn into some dynamically typed scripting language
12:55:32 <dcoutts> sjanssen: that's already done, but nobody uses it properly
12:55:37 <joglala> yes, ==, &&, || and not are explicity alowed
12:55:41 <joglala> allowed
12:55:47 <nominolo> dcoutts: yes, my PackageDescription stuff
12:56:01 <sjanssen> dcoutts: maybe they'll start using it correctly when their packages start breaking? :)
12:56:07 <dcoutts> nominolo: hmm? what's changed recently in PackageDescription?
12:56:12 <dcoutts> sjanssen: heh :-)
12:56:29 <oerjan> joglala: you can usually use guards instead of if also
12:56:30 <atp> hey, what is the language extension pragma for multiparameter type classes in GHC?
12:56:32 <nominolo> dcoutts: well, the hook type now uses GenericPackageDescription
12:56:40 <dcoutts> sjanssen: actually we could force everyone using build-type: Custom to specify an upper bound on cabal version
12:56:45 <nominolo> dcoutts: i deliberately didn't change PackageDescription
12:56:56 <joglala> oerjan: What are guards?
12:57:00 <dcoutts> nominolo: yes, but that was in the 1.2 api already
12:57:11 <sjanssen> dcoutts: can cabal-install use the version field to link Setup.hs against a correct version of Cabal?
12:57:17 <nominolo> dcoutts: right, but i'm afraid we might need more ugly hacks
12:57:18 <dcoutts> nominolo: I'm only talking about possible incompatibilities between 1.2 and 1.4
12:57:28 <dcoutts> sjanssen: yes.
12:57:36 <nominolo> dcoutts: ok.  the big break comes with 2.0 then :)
12:57:58 <nominolo> sjanssen: yes, that's the way to go, imho
12:58:00 <dcoutts> nominolo: perhaps.
12:58:26 <dcoutts> nominolo: basically I want to get a public Cabal release that will support cabal-install
12:58:29 <nominolo> sjanssen: i.e., $ cabal configure instead of $ runhaskell Setup.lhs configure
12:58:41 <nominolo> dcoutts: ok, good idea
12:58:42 <dcoutts> the current version of cabal-install needs the dev version of Cabal
12:58:49 <nominolo> i noticed
12:58:53 <dcoutts> and I want to get cabal-install to a wider audience
12:59:00 <byorgey> atp: MultiParamTypeClasses, I think
12:59:09 <atp> byorgey: thanks, i'll try that.
12:59:16 <bos> wow, the realworldhaskell.org server has a load average of $BIGNUM
12:59:24 <atp> byorgey: that worked, muchos gracias
12:59:28 <byorgey> bos: I was just about to ask about that. =)
12:59:32 <oerjan> joglala: for example you could have done contains (y : xs) x | x == y = True | otherwise = contains xs x
12:59:39 <nominolo> bos: nice
12:59:41 <byorgey> bos: I click on a link to add a comment and nothing happens. ;)
13:00:06 <bos> byorgey: it's taken 90 seconds so far to run "uptime", which hasn't printed any output
13:00:12 <oerjan> the | x == y and | otherwise are guards
13:00:22 <joglala> Ahh, cool
13:00:25 <dcoutts> nominolo, sjanssen: so I think the thing to do is to compile all the Setup.hs scripts against Cabal-1.2 and Cabal-1.4 and see how many break. Then fix up as much as possible to preserve compatibility.
13:00:28 <byorgey> bos: hehe
13:00:29 <bos> holy crap, the load is 209!
13:00:35 <nominolo> bos: has it been reddited?
13:00:40 <bos> nominolo: yep
13:00:46 <ddarius> bos: 209 means what?
13:00:49 <byorgey> nominolo: bos reddited it himself
13:00:52 <nominolo> dcoutts: ok
13:01:00 <bos> ddarius: 209 processes in the run queue
13:01:08 <nominolo> bos: ouch.
13:01:12 * Tac-Tics was wondering why the page didn't load, and then noticed it was the topic of conversation in this channel
13:01:13 <wagle> ... or waiting for io
13:01:16 <bos> ddarius: on a normal day, the load average is about 4
13:01:33 <Tac-Tics> even google's cache isn't loading
13:01:42 * nominolo goes upvoting
13:01:55 * byorgey decides to wait until later to comment on RWH...
13:02:29 <oerjan> atp: there's some option to make ghc list all the language pragmas it knows
13:04:13 <pastorn> http://book.realworldhaskell.org/ isn't working :/
13:04:40 <Tac-Tics> pastorn: read above
13:04:42 <kaol> while we're at it, let's try to get it slashdotted too
13:04:59 <dcoutts> oerjan, atp: ghc --supported-languages
13:05:18 <olsner> ... crushed under thousands of rabiate haskell zealots
13:07:24 <byorgey> dcoutts: hey, cool, I didn't know about that flag.  that's kind of a funny name though, I'd almost expect it to just print "Haskell".
13:07:47 <dcoutts> byorgey: aye, it should be --print-extensions or something
13:08:02 <monochrom> hahahahaha
13:08:04 <wagle> utsl
13:08:07 <byorgey> yeah, or --supported-pragmas, --supported-extensions, something like that...
13:08:25 <dcoutts> nominolo: you know your idea to have a simple dependency for pessimistic package version dependencies
13:08:49 <nominolo> dcoutts: hm?
13:09:04 <dcoutts> nominolo: I'd like to think about that more. I'm not convinced by the existing syntax though.
13:09:23 <dcoutts> nominolo: we want to express: foo >= 1.2.1 && < 1.3
13:09:39 <dcoutts> nominolo: which is tricky because it's not >= 1.2 && < 1.3
13:09:40 <nominolo> dcoutts: ah, right
13:09:57 <dcoutts> nominolo: Ruby's gems have some special syntax
13:10:10 <nominolo> what does it look like?
13:10:41 <dcoutts> foo ~> 1.2
13:10:58 <dcoutts> but that means >= 1.2 && < 1.3
13:11:20 <nominolo> yeah, that's my 1.2.* suggestion
13:11:23 <bos> it does? that's grotty.
13:11:47 <dcoutts> if you said ~> 1.2.1 that'd mean >= 1.2.1 && < 1.2.2
13:11:50 <atp> i love coding haskell... think for ten minutes, write two lines of code, et voila!
13:11:54 <nominolo> how about 1.2.1+ ?
13:12:17 <dcoutts> nominolo: but what exactly? foo == 1.2.1+ ?
13:12:55 <oerjan> [1.2.1, 1.3)
13:12:59 <nominolo> yes
13:13:33 <nominolo> a funny extension: 1.2+.1+ would mean [1.2.1, 2.0)
13:13:43 <dcoutts> nominolo: so could you say foo >= 1.2.1+ or can it only be used with ==
13:13:44 <LoganCapaldo> oerjan++
13:13:46 <koala_man> how do you separate elements on even and odd positions in a list? ie [1,4,2,3] into [1,2] and [4,3]?
13:14:08 <oerjan> koala_man: partition
13:14:08 <nominolo> dcoutts: no ==
13:14:19 <oerjan> > partition even  [1,4,2,3]
13:14:21 <lambdabot>      Bad interface file: ShowQ.hi
13:14:21 <lambdabot>         mismatched interface file versions:...
13:14:24 <nominolo> it would translate to >= 1.2.1 && < 1.3
13:14:33 <oerjan> O_O
13:14:42 <oerjan> @version
13:14:43 <lambdabot> lambdabot 4p576, GHC 6.6 (Linux i686 2.66GHz)
13:14:43 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:14:46 <atp> oerjan: i don't think that's what he means
13:14:52 <olsner> oerjan: but that's the even and odd *values*, not *positions*
13:15:02 <nominolo> GHC 6.6?? man, that's oooold!
13:15:07 <oerjan> oh...
13:15:11 <nominolo> ;)
13:15:27 <dons> bos, yow. "load average of 209"
13:15:37 <dcoutts> nominolo: hmm, it doesn't feel like a very modular syntax
13:15:51 <nominolo> dcoutts: no, but it'd match common idioms
13:15:52 <dcoutts> nominolo: the nice thing about ~> is that it's just another relation
13:15:56 <LoganCapaldo> map snd $ partition (even . fst) zip [0..] xs
13:16:08 <LoganCapaldo> needs more $
13:16:12 <dcoutts> nominolo: though ~> is silly because it looks like an arrow
13:16:19 <LoganCapaldo> map snd $ partition (even . fst) (zip [0..] xs)
13:16:28 <nominolo> well, it'd should be set membership
13:16:35 <nominolo> *it
13:16:45 <oerjan> > 1
13:16:46 <lambdabot>      Bad interface file: ShowQ.hi
13:16:46 <lambdabot>         mismatched interface file versions:...
13:16:57 <LoganCapaldo> > map snd $ partition (even . fst) (zip [0..] [1,4,2,3])
13:16:58 <lambdabot>      Bad interface file: ShowQ.hi
13:16:58 <lambdabot>         mismatched interface file versions:...
13:17:02 <oerjan> @vixen Are you having a fever? :(
13:17:03 <lambdabot> why don't you guess?
13:17:10 <nominolo> @bot
13:17:10 <lambdabot> :)
13:17:13 <nominolo> @uptime
13:17:14 <lambdabot> uptime: 1h 30m 57s, longest uptime: 1m 10d 23h 44m 29s
13:17:35 <oerjan> :t partition
13:17:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:18:29 <nominolo> dcoutts: the thing is that 1.2.1+ could also mean > 1.2.1
13:18:41 <dcoutts> nominolo: how about ~1.2.1 ?
13:18:52 <dcoutts> or ~=
13:18:58 <ddarius> What is wrong with oerjan's suggestion to use an interval notation?
13:19:05 <nominolo> dcoutts: no that's regex-matching
13:19:13 <nominolo> dcoutts: but ~ could work
13:19:28 <dcoutts> ddarius: it's no better than foo >= 1.2.1 && < 1.3
13:19:41 <nolrai> > splitAt 2 ['a'..'z']
13:19:43 <lambdabot>      Bad interface file: ShowQ.hi
13:19:43 <lambdabot>         mismatched interface file versions:...
13:19:46 <nominolo> dcoutts: it could also be 1.2.[1-*]
13:19:57 <dcoutts> ddarius: we've discussed interval notation before. It does not correspond to the devs think about the issue.
13:19:58 <nolrai> > splitAt 2 [1..10]
13:19:59 <lambdabot>      Bad interface file: ShowQ.hi
13:20:00 <lambdabot>         mismatched interface file versions:...
13:20:05 <LoganCapaldo> > foldr (\x (toggle, xs, ys) -> if toggle then (not toggle, x:xs, ys) else (not toggle, xs, x:ys)) (True, [], []) [1,2,3,4] -- still gonna complain about bad interfaces I'm sure
13:20:06 <lambdabot>      Bad interface file: ShowQ.hi
13:20:07 <lambdabot>         mismatched interface file versions:...
13:20:15 <oerjan> nolrai: something is wrong with the run command
13:20:21 <phlpp> > let m f = (=<<) (return.f) in m (^2) [1,2,3,4]
13:20:22 <nominolo> dcoutts: or, completely haskelly:  1.2.[1..]
13:20:22 <lambdabot>      Bad interface file: ShowQ.hi
13:20:23 <lambdabot>         mismatched interface file versions:...
13:20:40 <oerjan> i think some fixed file wasn't compiled properly?
13:20:52 <nominolo> @more
13:20:57 <phlpp> > let m f = (=<<) ((:[]).f) in m (^2) [1,2,3,4]
13:20:58 <lambdabot>      Bad interface file: ShowQ.hi
13:20:58 <lambdabot>         mismatched interface file versions:...
13:21:06 <oerjan> @more
13:21:11 <phlpp> k, forget about it :>
13:21:33 <dcoutts> nominolo: so the question is, do we need to be able to conveniently express both [1.2.1 .. 1.3)  and [1.2.0 .. 1.3], or is one much more common than the other.
13:21:36 <sjanssen> has anybody whined at dons yet? :P
13:22:09 <dcoutts> nominolo: erm [1.2.1 .. 1.3) and [1.2 .. 1.3]
13:22:23 <monochrom> The answer is yes. :)
13:22:26 <nominolo> dcoutts: why would we want to exclude 1.2.0 ?  because of ghc's and cabal's new release versioning policy
13:22:42 <phlpp> > let cnct = foldr (\x xs -> x ++ xs) [] in cnct [[1,2,3],[99,98,97]]
13:22:43 <lambdabot>      Bad interface file: ShowQ.hi
13:22:43 <lambdabot>         mismatched interface file versions:...
13:22:44 <nominolo> dcoutts: no, i don't mean to use interval notation
13:23:01 <nominolo> dcoutts: but range-specifications in haskell
13:23:16 <dcoutts> nominolo: neither do I. Let me try rephrasing.
13:23:26 <oerjan> sjanssen: it's just been on for an hour, after some other problem...
13:23:54 <nominolo> oerjan: s/it/she/
13:25:20 <dcoutts> nominolo: so the gems notation only allows one form, namely ~1.2 meaning  >=1.2 && <1.3
13:25:32 <nominolo> dcoutts: oh, right.  i think we almost always have [ x.y ..  x.y+1 )
13:25:45 <dcoutts> nominolo: but do we also need >=1.2.1 && <1.3 ?
13:25:56 <nominolo> dcoutts: for cabal, maybe?
13:26:36 <lightstep> phlpp, (\x xs -> x ++ xs) is the same as (++)
13:26:40 <nominolo> dcoutts: i'd like to keep it.  for example there might be an important bugfix or sth.
13:27:07 <nominolo> @pl \x xs -> x ++ xs
13:27:15 <dcoutts> nominolo: exactly, in the package versioning policy we have versions like 1.2.1 where the 3rd component is bumped for compatible api changes
13:27:22 <phlpp> lightstep: exactly.
13:27:42 <dcoutts> nominolo: but if you then need to use that api extension then you need then 1.2.1 but the api will not break until 1.3
13:28:04 <phlpp> so concat = foldr (++) [] = foldr (\x xs -> x ++ xs) []
13:28:06 <phlpp> ;)
13:28:37 <olsner> yes
13:28:50 <nominolo> dcoutts: yes, that's the idea, but ~1.2.1 should probably mean >=1.2.1 && < 1.2.2
13:29:04 <nominolo> dcoutts: or, we'd hard-code the versioning policy
13:29:08 <dcoutts> nominolo: right
13:29:28 <dcoutts> so can we find a nice syntax that expresses either, or two different ones?
13:29:35 <nominolo> dcoutts: which i'd like, but it would break lots of packages on hackage
13:30:15 <dcoutts> nominolo: hmm? what would break hackage packages?
13:30:46 <nominolo> as a summary my suggestions: 1.2.* == >= 1.2 && < 1.3    1.2.3+ == >= 1.2.3 && < 1.3
13:31:13 <dcoutts> yeah, that's not too bad
13:31:27 <dcoutts> foo == 1.2.*, bar == 1.2.3+
13:31:40 <nominolo> where 1.2.* == ~1.2 via your suggestion
13:31:47 <dcoutts> yes
13:32:06 <nominolo> i'd write it as:  build-depends:  bytestring-1.1.*
13:32:17 <dcoutts> so no relations at all
13:32:34 <nominolo> yeah, because it kind of specefies a set by itself
13:32:40 <dcoutts> but would you allow:  build-depends: bytestring-1.1
13:32:44 <dcoutts> we don't currently
13:33:02 <dcoutts> and we do not want deps to be specified that precisely that often
13:33:15 <nominolo> i'd say x.y is equivalent to x.y.*
13:33:28 <nominolo> no?
13:33:29 <dcoutts> I think explicit is better
13:34:04 <nominolo> you mean, people should specify the ".*" part?
13:34:08 <dcoutts> yes
13:34:27 <nominolo> ok
13:35:05 <nominolo> the only thing that might be a bit unintuitive is 1.2.3+, because that might look like there's no upper boundary
13:35:49 <dcoutts> foo-1.2.*, bar-1.2.3+  is nice but it doesn't really fit with the existing predicate style:  foo == 1.1, bar >= 1.2
13:35:50 <nominolo> 1.2.(3+) would be more explicit
13:35:55 <doserj> dcoutts: so if foo-1.1 is released, one should still depend on foo-1.1.*, because a bugfix release might be uploaded?
13:36:13 <nominolo> doserj: yes
13:36:13 <dcoutts> doserj: http://haskell.org/haskellwiki/Package_versioning_policy
13:37:07 <phlpp> > (+) 5 3
13:38:21 <dcoutts> nominolo: it almost asks for a set membership relation :-)
13:38:32 <joglala> How can i make comments in haskell?
13:38:33 <dcoutts> nominolo: foo `elem` 1.2.* :-)
13:38:33 <nominolo> yes, it is
13:38:48 <dcoutts> which is why == looks wrong
13:38:48 <nominolo> joglala: use "--"
13:38:51 <joglala> Thank you
13:38:52 <oerjan> joglala: -- ...to end of line, or {- nested -}
13:38:58 <joglala> Cool
13:39:22 <nominolo> joglala: {- foo {- bar -} -} also works
13:39:35 <joglala> :)
13:40:16 <nominolo> dcoutts: yes.  that's why i though about "-".   or we could just use " `"
13:40:28 <nominolo> dcoutts: or even ~=
13:41:04 <dcoutts> nominolo: aye
13:41:18 <dcoutts> nominolo: but - is used to refer to exact versions
13:41:19 <dcoutts> foo-1.2
13:41:27 <nominolo> oh
13:41:43 <dcoutts> not in build-depends but elsewhere in the cabal ui
13:41:45 <nominolo> shouldn't that really be == 1.2 ?
13:41:47 <dcoutts> it's an exact name-version pair
13:41:51 <oerjan> joglala: use a space after --; it is sometimes necessary, to prevent confusion with operators
13:42:04 <dcoutts> nominolo: try  cabal install haxml-1.19.2
13:42:04 <joglala> Im trying to implement "delete" now, which should delete something from a list
13:42:05 <joglala> Yes
13:42:15 <nominolo> dcoutts: i see. well, then i like "~"
13:42:24 <dcoutts> nominolo: it's just the natural meaning from other packaging systems
13:42:38 <ddarius> > let (-->) = (>>>) in (1+) --> (2*) $ 1
13:42:43 <dcoutts> nominolo: in gentoo we use ~ with a similar meaning
13:42:46 <hpaste>  jogla pasted "delete function" at http://hpaste.org/5136
13:42:53 <joglala> I think im missing an idea
13:43:10 <joglala> I need to step through the list without deleting everything
13:43:15 <ddarius> joglala: What are all the cases?
13:43:17 <nominolo> joglala: don't think about modification but about returning new things
13:43:41 <dcoutts> nominolo: in gentoo =dev-haskell/foo-1.2-r1  means what it looks like ~dev-haskell/foo-1.2.1  means allow any -rN suffix
13:43:56 <hpaste>  titusg annotated "delete function" with "(no title)" at http://hpaste.org/5136#a1
13:43:58 <dcoutts> nominolo: -rN is the gentoo ebuild revision as opposed to the upstream version
13:44:12 <nominolo> dcoutts: yes.  we don't need that, do we?
13:44:25 <dcoutts> nominolo: no, but my point is it's a similar idea
13:44:42 <byorgey> ddarius: yes, the comment lexing rules are not quite so simple =)
13:44:44 <ddarius> joglala: If a /= x then delete a (x:xs) = delete a (x:xs) which is probably not what you want.
13:45:18 <joglala> delete a xs ++ [x]
13:45:24 <joglala> That seems to work for the last case
13:45:27 <jz87_> is there anyway to compile haskell to run on ARM processors?
13:45:29 <joglala> and xs for the first case
13:45:40 <titusg> joglala: don't forget the empty list too
13:45:48 <joglala> yes, thanks
13:45:54 <dcoutts> nominolo: so are we converging on "foo ~ 1.2.*, bar ~ 1.2.1+" as a proposal to send to the cabal-devel list?
13:46:03 <oerjan> joglala: ++ [x] will reverse the remaining list
13:46:07 <Cale> joglala: why appended to the end?
13:46:15 <nominolo> dcoutts: seems okay to me
13:46:21 <dcoutts> nominolo: people might ask why we don't use one of +/*
13:46:25 <byorgey> joglala: that works, although it's more efficient to put x on the front of the list with x : delete ...
13:46:27 <Cale> x : delete a xs   seems more reasonale
13:46:27 <joglala> Well, its an easy way of implementing this
13:46:30 <Cale> reasonable*
13:46:35 <nominolo> dcoutts: hm. is 1.2.3* better?
13:46:43 <dcoutts> nominolo: like "foo ~ 1.2.*, bar ~ 1.2.1*" or "foo ~ 1.2.+, bar ~ 1.2.1+"
13:47:31 <Cale> (++) is an operation which you should make every attempt to avoid under normal circumstances, since (xs ++ ys) takes O(length xs) steps to completely reduce.
13:47:32 <nominolo> dcoutts: in the wildcard case it's common notation.  while 3* usually means '3' any number of 3s, which is not what we mean
13:47:48 <dcoutts> nominolo: right, but what about "foo ~ 1.2.+, bar ~ 1.2.1+"  ?
13:47:50 <joglala> byorgey: Cool
13:47:52 <nominolo> dcoutts: otoh, 1+ is non-regex either
13:48:03 <joglala> Haskell is really different than other things
13:48:12 <nominolo> joglala: oh, yes :)
13:48:19 <jz87_> hey
13:48:25 <jz87_> is there a way to compile haskell to ARM?
13:48:57 <nominolo> dcoutts: then let's use 1.2.1* to deliberately break possible false assumptions
13:48:57 <ddarius> Bah!  (++) isn't something you should just blindly try to avoid.
13:49:11 <joglala> ddarius: :)
13:49:16 <nominolo> dcoutts: since "many 1s" clearly doesn't make much sense in this context
13:49:39 <dcoutts> nominolo: I think + works better actually if we want only one of * or + in both contexts.
13:49:42 <nominolo> dcoutts: and 1.2.>=1 is ugly
13:50:14 <nominolo> dcoutts: hm, i'm not picky
13:50:19 <dcoutts> nominolo: if "foo ~ 1.2.1+" is ok, then what's wrong with "foo ~ 1.2.+" ?
13:50:40 <nominolo> dcoutts: no, it's ok.  a bit non-standard but not too bad
13:50:47 <doserj> dcoutts: would that be the same as foo ~ 1.2.0+?
13:51:04 <oerjan> jz87_: i see some google hits on ARM haskell, some from a relevant haskell-cafe discussion
13:51:13 <nominolo> doserj: that's tricky, because we have 1.2 /= 1.2.0
13:51:25 <nominolo> doserj: but maybe it should be ==
13:51:39 <byorgey> ok, ++ [x] is something you should blindly try to avoid. =)
13:51:44 <doserj> so 1.2.+ should include 1.2?
13:51:53 <dcoutts> doserj: "foo ~ 1.2.1+" means "foo >=1.2.1 && < 1.3"  and  "foo ~ 1.2.+" means "foo >=1.2 && < 1.3"
13:51:56 <nominolo> doserj: yes
13:52:20 <oerjan> if you are doing ++ [x] it may be better to do x : and reverse afterwards
13:52:35 <sjanssen> or use Data.Sequence
13:52:36 <dcoutts> nominolo: do you want to send the suggestion to cabal-devel?
13:52:52 <nominolo> dcoutts: though, the subtly different "1.2+" would mean `elem` [1.2 .. 2 )
13:52:57 <jz87_> yes
13:53:11 <dcoutts> nominolo: `elem` [1.2 .. 3 ) you mean. Yes.
13:53:13 <jz87_> oerjan what query did you type in
13:53:31 <nominolo> dcoutts: er, no
13:53:33 <oerjan> just ARM haskell
13:53:44 <nominolo> dcoutts: >= 1.2 && < 2
13:53:54 <dcoutts> nominolo: oh, sorry. Yes, you're right.
13:54:26 <dcoutts> nominolo: perhaps there is merit in some */+ redundancy
13:54:45 <dcoutts> nominolo: to make it harder to make exactly that mistake
13:54:49 <nominolo> ok, i'll write up the proposal.  though, i better check the answers to my original suggestions first
13:55:14 <nominolo> dcoutts: well, + and * in just a shift away on some keyboard layouts i think
13:55:32 <dcoutts> nominolo: it's more the visual thing I think that's important
13:55:50 <dcoutts> nominolo: relate the proposal to the package versioning policy
13:55:55 <nominolo> dcoutts: http://de.wikipedia.org/wiki/Bild:Qwertz_de.svg
13:56:08 <nominolo> dcoutts: ok
13:56:30 <dcoutts> nominolo: it's more the mental than keyboard confusion I'm worried about
13:56:50 <nominolo> ok
13:57:37 <doserj> N.M.* somehow seems more intuitive than N.M.+, * being a wildcard.
13:57:52 <jz87_> oerjan thanks
13:57:53 <jz87_> this is great
13:58:03 <jz87_> I've been wanting to write programs for my n800
13:58:04 <dcoutts> nominolo: eventually I'd like to have packages declare if they are following the PVP and then enforce that they really are. And also for dependent packages we should warn if people are using open deps and instead suggest using ~ 1.2.* or whatever the current version they are building against is
13:58:16 <jz87_> I'd hate to have to use a non statically typed language
14:00:08 <doserj> dcoutts: but also don't make it too hard for the package authors to write a good .cabal file
14:00:17 <doserj> (else they won't bother=
14:00:26 <nominolo> dcoutts: ok, there was general agreement to 1.2.*.  so i'll just add the 1.2.1+ proposal
14:00:36 <dcoutts> doserj: on the contrary, we want to help them write good .cabal files :-)
14:00:38 <nominolo> dcoutts: and refer to the versioning policy
14:00:53 <dcoutts> nominolo: ok.
14:00:58 <doserj> dcoutts: write tools that generate good .cabal files :)
14:02:29 <dcoutts> doserj: yes, it should be possible to generate the deps after a successful build
14:02:36 <doserj> yep
14:02:54 <dcoutts> doserj: especially if we know that the dependent packages are following the PVP
14:03:21 <dcoutts> doserj: but that does need cabal to do dep analysis
14:03:37 <jz87_> who maintains gtk2hs
14:03:40 <dcoutts> jz87_: me
14:03:51 <dcoutts> currently it's ghc --make that figures out what packages your code deps on
14:03:55 <jz87_> is there anyway you can update the windows installer?
14:04:01 <doserj> dcoutts: any packaging system will need dependency analysis
14:04:04 <dcoutts> jz87_: it's on my TODO
14:04:08 <jz87_> ah
14:04:12 <jz87_> cool
14:04:16 <jz87_> how do you build it for windows anyway
14:04:18 <ac> > 1 + 1
14:04:22 <jz87_> cygwin doesn't work
14:04:27 <mauke>  2
14:04:28 <jz87_> and neither does minG
14:04:40 <jz87_> you must have someway of building for windows
14:04:42 <oerjan> @maukesnack
14:04:54 <dcoutts> doserj: no, this is not inter-package deps, this is more like make. what modules depend on each other, or do the modules come from some other package.
14:05:05 <joglala> contains (y : xs) x | x == y = True | otherwise = contains xs x
14:05:10 <joglala> I dont' understand how this works
14:05:31 <dcoutts> jz87_: I use the scripts in the gtk2hs darcs repo along with the gtk+ sdks at http://haskell.org/gtk2hs/win32/
14:05:42 <doserj> dcoutts: yes
14:05:43 <ddarius> joglala: By itself, it doesn't work.
14:06:05 <ddarius> At least not in the case that the list does not contain the element.
14:06:12 <joglala> Yes
14:06:27 <joglala> contains [] x = False
14:06:34 <dcoutts> doserj: currently cabal does not do that bit it self. It relies on ghc --make or hmake. It should do it itself as many other advanced features depend on it.
14:07:02 * dcoutts disappears
14:07:04 <oerjan> joglala: | x == y = True means that True is returned if the guard x == y is True
14:07:14 <ac> how do I construct a CalendarTime record without specifying redundant fields and without getting warnings?
14:07:30 <oerjan> otherwise is a synonym for True, to read better in guards
14:07:40 <ddarius> ac: Check the functions provided.
14:07:45 <joglala> Can i read it as: for (y:xs) x *with* x == y, its True, otherwise call contains xs x?
14:08:01 <joglala> It it like the | in mathematics?
14:08:03 <oerjan> so if the first guard fails (i.e. x /= y) then otherwise, being True, always is used
14:08:11 <oerjan> joglala: that's right
14:08:13 <joglala> Cool
14:08:15 <joglala> Thank you
14:08:29 <ac> ddarius: I did of course. I don't see any thing appropriate
14:08:51 <joglala> Is | a function?
14:09:04 <oerjan> joglala: btw it is common to put the guards on different lines (although the syntax doesn't require it)
14:09:05 <ddarius> ac: I guess you'll have to write it yourself.  That said, I'm not sure how much of the fields are actually used.
14:09:08 <oerjan> a keyword
14:09:10 <Botje> also. but in that place it's syntax.
14:09:10 <cdsmithus> joglala: no, just syntax.
14:09:28 <oerjan> Botje: i don't think | is ever a function
14:09:30 <joglala> And has it advantages over contains (y : xs) x = x == y || contains xs x?
14:09:41 <Botje> :t (|)
14:09:47 <Botje> argh.
14:09:58 <oerjan> joglala: not really in that case
14:10:07 <phlpp> <interactive>:1:1: parse error on input `
14:10:11 <ddarius> Botje: | by itself is not a legal operator character
14:10:14 <phlpp> `|` i mean
14:10:19 <Botje> I might be confused with .|. in Data.Binary
14:10:26 <oerjan> joglala: but it can greatly simplify nested if's
14:10:35 <joglala> Ahh, thank you
14:10:41 <ac> ddarius: Well, you can call toClockTime without an exception if you only provide the fields you'd expect it to need (year ... picoseconds, and ctTZ)
14:10:43 <ddarius> phlpp: It never makes sense to put backticks around an operator.
14:10:53 <phlpp> i didn't
14:11:10 <ddarius> ac: What does it do if you start querying the other fields?
14:11:29 <hpaste>  jogla pasted "list manipulation in haskell" at http://hpaste.org/5137
14:11:45 <joglala> Well, thats the result of my first evening with haskell
14:11:58 <Cale> joglala: :)
14:12:02 <joglala> :)
14:12:15 <Cale> joglala: btw, if-then-else is usually laid out a little differently
14:12:17 <Cale> if foo
14:12:19 <Cale>    then bar
14:12:20 <byorgey> joglala: that's a great start! =)
14:12:24 <Cale>    else quux
14:12:38 <joglala> I'll change the if
14:12:46 <Cale> (just a minor style thing :)
14:12:53 <ddarius> joglala: Your union function is unnecessarily inefficient and has poor "latency"
14:12:58 <ac> ddarius: I don't understand what you mean... if you construct a record with missing fields and then query them you get an exception
14:13:13 <oerjan> joglala: also one advantage is that guards if they all fail pass to the next pattern match
14:13:32 <cdsmithus> Cale: Goof style thing, though.  I remember back when I was learning, and it took my days to figure out why my if statements didn't work in do blocks.
14:13:36 <cdsmithus> Cale: *good
14:13:55 <oerjan> which is sometimes useful
14:14:06 <joglala> the "then" just in the next line?
14:14:26 <Cale> joglala: and lined up with the 'else', indented a little more than the 'if'
14:14:47 <joglala> Ahh
14:14:55 * ddarius just indents the else two spaces but otherwise writes if foo then\n ...
14:15:11 <joglala> And the code for the else in the new line like if have it done?
14:15:20 <Cale> (we see the 'then' and 'else' as being parts of the 'if', but at the same level in the tree) :)
14:15:30 <cdsmithus> joglala: indent else more than the if.
14:15:36 <cdsmithus> even with the then
14:15:36 <ac> I'm surprised there isn't a "get seconds since epoch" function in System.Time
14:15:55 <oerjan> ac: Data.Time is recommended
14:16:02 <oerjan> it has better API
14:16:06 <hpaste>  jogla pasted "indenting of ifs" at http://hpaste.org/5138
14:16:11 <joglala> This way?
14:16:58 <hpaste>  Cale annotated "list manipulation in haskell" with "reformat if/then/else" at http://hpaste.org/5137#a1
14:17:26 <hpaste>  byorgey annotated "indenting of ifs" with "usually more like this" at http://hpaste.org/5138#a1
14:17:28 <oerjan> joglala: no new line after else
14:17:35 <joglala> Ahh, great
14:17:47 <Cale> (I did a reindent of your whole program there)
14:18:05 <vincenz> byorgey: that's odd, I get the wrong solution for 31
14:18:22 <ddarius> joglala: Some of your parentheses in intersect are unnecessary.
14:19:00 <joglala> the ones that sourround if
14:19:05 <joglala> Hmm
14:19:15 <joglala> I indented the if and else with tabs, is that wrong?
14:19:30 <byorgey> joglala: usually you shouldn't use tabs in Haskell files.
14:19:33 <ddarius> The ones around the condition of the if, yes, and the ones around ys
14:19:39 <joglala> In the "reindend" there seem to be 3 spaces
14:19:40 <cdsmithus> joglala: Never use tabs in Haskell.  If you use layout later on, it causes no end of trouble.
14:19:48 <Cale> joglala: Try to avoid putting any tabs in your source files, have your editor replace them with spaces automatically.
14:19:58 <joglala> :)
14:20:03 <oerjan> i don't think they were actual tab chars
14:20:12 <vincenz> byorgey: how far of am I with 443839
14:20:17 <nominolo> dcoutts: hm, what do we do about ranges like >= 1.2.1 < 1.4 ?
14:20:26 <oerjan> unless someone has fixed hpaste to turn them into spaces
14:20:32 <byorgey> vincenz: way off.
14:21:02 <vincenz> byorgey: I don't get it, I only generate combinations, not permutations
14:21:06 <nominolo> dcoutts: my previous suggestion was "1.2.1 - 1.3.*"  or "1.2.1 to 1.3.*"
14:21:32 <hpaste>  vincenz pasted "euler 31" at http://hpaste.org/5139
14:21:44 <ddarius> joglala: unions should look more like delete.  The current definition is unnecessarily inefficient and gives worse laziness.
14:21:58 <vincenz> byorgey: the maxc ensures I don't get both [1,2] and [2,1
14:22:03 <joglala> Hmm
14:22:51 <byorgey> vincenz: I think you still get duplicates.
14:22:57 <vincenz> byorgey: I dubt it
14:23:13 <vincenz> with 5 I get [[1,1,1,1,1],[2,1,1,1], [2,2,1], [5]]
14:24:52 <vincenz> byorgey: for 10: [[1,1,1,1,1,1,1,1,1,1],[2,1,1,1,1,1,1,1,1],[2,2,1,1,1,1,1,1],[2,2,2,1,1,1,1],[2,2,2,2,1,1],[2,2,2,2,2],[5,1,1,1,1,1],[5,2,1,1,1],[5,2,2,1],[5,5],[10]]
14:25:06 <byorgey> vincenz: yes, I just tried that myself
14:25:08 <byorgey> hmm
14:25:19 <vincenz> is my currency list off?
14:25:22 <vincenz> I checked twce
14:26:12 <ddarius> In fact, do you want unions [2,2] [] to return [2] or [2,2] ?
14:26:15 <ac> byorgey: thanks, WTH is System.Time for? :-P
14:26:43 <vincenz> byorgey: too many I take it, then?
14:26:53 <byorgey> vincenz: yes
14:26:56 <oerjan> ac: it's grown out of the H98 Time module
14:27:18 <vincenz> byorgey: very odd
14:27:26 <oerjan> or maybe not grown at all, not sure
14:27:58 <glguy> vincenz: be careful not to count permutations twice?
14:28:02 <vincenz> glguy: yep
14:28:08 <vincenz> byorgey: how many does your way get for 20?
14:28:17 * vincenz gets 41 ways for 20p
14:28:36 <nominolo> dcoutts: sent.  just reply if something is missing
14:29:20 <byorgey> vincenz: 41
14:29:48 <vincenz> byorgey: odd
14:29:54 <byorgey> vincenz: give me a minute to think about this...
14:29:58 <ac> Data.Time seems to be missing the obvious functions for breaking a DiffTime in to hours, minutes, and seconds
14:30:10 <vincenz> byorgey: 451 for 50p
14:31:09 <oerjan> ac: there are many Data.Time.* modules
14:31:26 <byorgey> vincenz: yep, same
14:31:37 <vincenz> byorgey: lol :)
14:32:12 <joglala> How can i express "if not"?
14:32:28 <Cale> joglala: if not (...)
14:32:31 <Cale> > not True
14:32:36 <vincenz> byorgey: DOH!
14:32:39 <Cale> ...
14:32:42 <Lemmih> False
14:32:43 <vincenz> byorgey: here I ws, running Main with the wrong puzzlenumber
14:32:44 <Cale> lambdabot!
14:32:47 <byorgey> vincenz: what?
14:32:50 <byorgey> vincenz: oh, haha!
14:32:56 <joglala> Hmm, but i have to use ()?
14:33:37 <byorgey> vincenz: that's the danger of putting everything in the same file, I guess =)
14:33:39 <EvilTerran> @src not
14:33:41 <vincenz> byorgey: yeah :)
14:33:43 <EvilTerran> not False = True
14:33:46 <EvilTerran> not True = False
14:33:53 <ac> oerjan: ah yes. Oddly DiffTime -> TimeOfDay is in .LocalTime
14:33:53 <EvilTerran> joglala, it's just a function like any other
14:34:09 <hpaste>  jogla pasted "new delete version" at http://hpaste.org/5140
14:35:28 <joglala> ddarius: I don't know if that was what you had in mind
14:36:01 <glguy> union x y = x ++ filter (`notElem` x) y
14:36:33 <joglala> I must not use ++
14:36:47 <glguy> oh, is this homework?
14:36:58 <joglala> This is a kind of homework, right
14:37:37 <vincenz> > 1
14:37:39 <mbot>  1
14:37:44 <EvilTerran> @bot!
14:37:45 <glguy> union [] x = x
14:37:45 <mbot> EvilTerran: Null
14:37:54 <EvilTerran> hehe
14:37:54 <oerjan> o_O
14:37:57 <glguy> union (y:ys) x = y : union ys (delete y x)
14:38:02 <EvilTerran> @version
14:38:02 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
14:38:02 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:38:06 <oerjan> @bot?
14:38:07 <mbot> oerjan: Null
14:38:08 <vincenz> Cale: remind me, what was that moand based unction to get all perms?
14:38:13 <oerjan> @bot
14:38:14 <mbot> :)
14:38:15 <byorgey> > Sum[1/x^2, x, 1, Infinity]
14:38:16 <mbot>   Not in scope: data constructor `Infinity'
14:38:23 <Cale> joglala: ++ isn't *always* bad, it's specifically bad when you're repeatedly making small appends to the end of a list.
14:38:27 <oerjan> @fnord
14:38:28 <mbot> Unknown command, try @list
14:38:31 <byorgey> oh, boo =)
14:38:34 <jethr0> glguy: notElem is pretty slow, no?
14:38:40 <Cale> vincenz: All permutations? I don't know.
14:38:46 <Cale> vincenz: I can do all combinations.
14:38:46 <ddarius> joglala: Yes, the main thing was changing union xs (y:ys) into y:union xs ys, though that changes the behaviour somewhat.
14:38:47 <glguy> jethr0: slow as delete
14:38:55 <EvilTerran> vincenz, are you thinking of all subsets, maybe?
14:38:59 <Cale> > filterM (const [False,True]) [1,2,3]
14:39:00 <oerjan> byorgey: > may not be the right prefix?
14:39:01 <mbot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
14:39:03 <LoganCapaldo> glguy: shouldn't that be y : union (delete y ys) (delete y x) ?
14:39:03 <jethr0> might it not be cheaper for long lists to sort both lists first and then pick and chose?
14:39:07 <EvilTerran> (there's your all subsets)
14:39:10 <vincenz> Cale:ah, hmm
14:39:14 <vincenz> yeah, wrong one
14:39:16 <glguy> LoganCapaldo: I don't think so
14:39:28 <joglala> ddarius: Can you explain why it changes the behaviour?
14:39:29 <glguy> LoganCapaldo: delete only removes one element at most
14:39:35 <Cale> vincenz: Usually I base permutations on a function which annoyingly isn't in the libraries.
14:39:38 <ddarius> joglala: Once you are happy with this, as an additional exercise you may want to try rewriting all of these functions as using foldr.
14:39:39 <glguy> LoganCapaldo: anyway, and union assumes two well formed "sets"
14:39:58 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:40:05 <Igloo> dcoutts: Would the Cabal 1.4 release be suitable for inclusion with GHC 6.8.3?
14:40:06 <Cale> I really wish that were in Data.List
14:40:25 <joglala> ddarius: Its late, but maybe tomorrow
14:40:52 <ddarius> joglala: Er, the new unions should be even more like delete.
14:41:01 <vincenz> Cale: that gives perms?
14:41:15 <Cale> vincenz: Eventually :)
14:41:33 <Cale> vincenz: It's a good building block for it.
14:41:37 <glguy> returns one element from the list
14:41:43 <glguy> and the list with that element deleted
14:43:23 <dons> did people see the Control.Parallel.Strategies overview/tut on reddit?
14:43:29 <dons> http://programming.reddit.com/info/665sv/comments/
14:43:31 <dons> very timely.
14:43:58 <joglala> ddarius: I dont get it, can you give me another hint?
14:44:14 <oerjan> > let perms [] = [[]]; perms l = [x:xs | (bef, x:aft) <- zip (inits l) (tails l), xs <- perms (bef++aft)] in perms [1..4]
14:44:16 <mbot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,...
14:44:44 <DRMacIver> dons: Yeah, it's a nice intro.
14:45:03 <DRMacIver> dons: Why timely?
14:45:24 <glguy> because dons has been "on about" that module lately ;)
14:45:36 <unenough> what's a good haskell intro for an experienced programmer (but not in lisp/scheme/haskell/etc)?
14:46:04 <Beelsebob> unenough: I'd suggest trying to erase your mind of as much programming as you can
14:46:10 <Beelsebob> and starting with the normal tutorials
14:46:10 <EvilTerran> @go haskell for c programmers
14:46:11 <mbot> http://www.haskell.org/~pairwise/intro/intro.html
14:46:11 <mbot> Title: Haskell for C Programmers
14:46:26 <ddarius> joglala: Sorry, I'm wrong.  Your new union is fine.  I just got confused with the switching of arguments.
14:46:44 <DRMacIver> Control.Parallel is really rather neat.
14:46:46 <Apocalisp> Congrats on the public beta!
14:46:58 <unenough> Beelsebob don't worry, i know about functional programming, just not any specific language
14:47:06 <joglala> ddarius: You saved me from getting brain dead ;)
14:47:21 <joglala> Why is it better then the old one?
14:47:28 <unenough> C is not programming, it's manual labor
14:47:54 <Beelsebob> unenough: oh, okay then, that sounds much better -- I'd suggest just finding a random tutorial and scanning through it for what the syntax looks like then
14:47:59 <Beelsebob> and then trying to implement something fun
14:48:11 <Beelsebob> Haskell's syntax is dead easy
14:48:15 <ddarius> joglala: Well, as I said, it's different from the old one so either there are restrictions on the input that makes them the same, or either it or the old one is incorrect.
14:48:31 <Valodim_> Beelsebob: yeah but the way of thinking isn't
14:48:41 <nolrai> is there a function that a combination of foldr and map?
14:48:55 <mauke> scanl? mapAccumL?
14:48:57 <Beelsebob> holrai: foldr
14:48:59 <ddarius> nolrai: foldr
14:49:12 <joglala> Hmm
14:49:13 <Beelsebob> foldr f . map g == foldr (f . g)
14:49:35 <joglala> I may swich the arguments
14:49:36 <unenough>  instead of "experienced programmer", I should say "fed up with all that crap programmer"
14:49:42 <nolrai> realy?
14:49:49 <ddarius> joglala: Assuming that it is correct or that we are only considering inputs where the implementations coincide, the new version requires less redundant checking and it will return the first element as soon as possible.
14:49:50 <dons> glguy: right. the community is "on message" :)
14:50:00 <litb> @src mapAccumL
14:50:00 <mbot> mapAccumL _ s []        =  (s, [])
14:50:00 <mbot> mapAccumL f s (x:xs)    =  (s'',y:ys)
14:50:00 <mbot>    where (s', y ) = f s x
14:50:00 <mbot>          (s'',ys) = mapAccumL f s' xs
14:50:11 <litb> i wonder what that does
14:50:18 <glguy> dons: did lambdabot get caught in a powerfailure?
14:50:19 <pjd> nolrai: of course, map f = foldr ((:) . f) []
14:50:33 <joglala> the input lists have all elements listed once
14:50:50 <dons> glguy: it can't seem to connect from code.haskell.org
14:50:52 <dons> i've no idea why
14:50:53 <ddarius> joglala: In that case both implementations give the same output and the new one is better.
14:51:05 <joglala> Now i see it, thank you a lot
14:51:19 <joglala> It is a problem that that was homework?
14:51:33 <oerjan> > mapAccumL (\s x -> (s+x, 10*x)) 0 [1..10]
14:51:36 <mbot>  (55,[10,20,30,40,50,60,70,80,90,100])
14:51:38 <glen_quagmire> lambdabot out?
14:51:40 <glen_quagmire> oh i see
14:51:45 <glguy> dons: try port 8001
14:51:48 <glguy> that works from code.
14:52:13 <glguy> while 6667 didn't
14:52:19 <ddarius> joglala: No, since you wrote the code yourself for the most part, but see: http://www.haskell.org/haskellwiki/Homework_help for the "policy"
14:52:25 <dons> glguy: ah interesting
14:52:50 <oerjan> dons: @run was broken last it was here
14:52:54 <dons> sweet.
14:53:00 <dons> oerjan: yeah, different bot.
14:53:02 <dons> glguy++
14:53:05 <oerjan> > 1
14:53:08 <mbot>  1
14:53:14 <lambdabot>  1
14:53:15 <dons> mbot: @part #haskell
14:53:21 <oerjan> oh :)
14:53:22 <mauke> @yow
14:53:23 <dons> > map (^2) [1..]
14:53:29 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES ...
14:53:34 <glguy> I can has lag?
14:53:35 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
14:53:37 <lambdabot> Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
14:53:38 <mux> @version
14:53:41 <dons> u sure can haz lag
14:53:43 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
14:53:49 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:53:58 <ddarius> joglala: One aspect of the new version that I was referring to with "better laziness" can be seen if we consider passing an infinite list as the first argument to the old one, it would never produce any output whereas passing it as a second parameter to the new one will produce output as soon as it finds a y not contained in xs.
14:54:14 <dons> ?users
14:54:18 <lambdabot> Maximum users seen in #haskell: 454, currently: 427 (94.1%), active: 9 (2.1%)
14:55:06 <dons> glguy: more `par` use is a result for 2008. (going back to why its "timely" :)
14:55:21 <glguy> dons: Who is the customer for that?
14:55:51 <dons> John Hughes?
14:56:16 <dons> (he said we had a 5 year window at CUFP to get haskell into the mainstream :)
14:57:08 <dons> mm. i'd like a monad that was *exactly* like IO, but with a unique type, and that can only be introduced via runMersenneTwister
14:57:20 <joglala> ddarius: But it will never finish?
14:57:26 <dons> so just a purely type system-based proof that the generator was intialised
14:57:45 <glguy> dons: similar to the way we did that dyn exceptions wrapper?
14:58:11 <ddarius> joglala: The old version, no.  The new version will never be able to compute the whole list, but you can take parts of the list or print the unending list.
14:58:12 <dons> i don't want to have to lift things though.
14:58:17 <unenough> i have a premature question
14:58:22 <joglala> ddarius: Yeah
14:58:24 <unenough> how does haskell deal with side effects?
14:58:33 <unenough> i've heard something called "monads"
14:58:42 <ddarius> unenough: That's the answer.
14:58:43 <joglala> Haskell is really interesting
14:58:57 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html
14:58:59 <lambdabot> Title: Haskell: How To IO
14:59:08 <mauke> the answer is not "monads". the answer is "it cheats".
14:59:10 <pjd> unenough: strictly speaking, Haskell deals with it using functional data dependencies
14:59:27 <pjd> and monads just happen to be a convenient abstraction for that kind of thing (among many others)
14:59:42 <monochrom> haskell lets the runtime system deal with side effects
15:00:04 <pjd> unenough: if you want the full story, check http://haskell.org/haskellwiki/IO_inside
15:00:18 <unenough> pjd i just want to know the theory, not how it works
15:00:31 <pjd> right;  check that link :)
15:00:32 <Sizur> i heared monads is The model of side-effects
15:00:59 <pjd> it refers to the implementation towards the end, but most of it is an explanation of the theory
15:01:01 <Sizur> i also heared geven one side-effect, you can emulate all of them
15:01:30 <monochrom> I heard side effects are an illusion.
15:01:37 <pjd> Sizur: monads are a pretty general abstraction;  they do a lot more
15:01:43 <Sizur> and we should embrace the illusion
15:01:44 <ddarius> pjd: IO is an abstract type.  What it actually does or how it does it is not specified and in particular GHC's "RealWorld" state-passing approach is not the only or the ideal way to handle it.
15:01:51 <pjd> IO and State are just one particular kind of monad
15:02:00 <glguy> Id
15:02:02 <pjd> ddarius: right
15:02:07 <nolrai> > let f list = foldr 1 ( (*) . ((uncurry ^) )) list in [(2,2)]
15:02:10 <lambdabot>  [(2,2)]
15:02:12 <ddarius> pjd: Not just in theory but e.g. Hugs and hbc I believe use a continuation based approach.  I don't know what nhc/jhc/yhc use.
15:02:36 <Sizur> pjd: what can be another purpose of a monad if it's not some form of a side effect?
15:02:41 <ddarius> Sizur: Given shift and reset you can get the rest.
15:02:43 <joglala> Thanks again and good night
15:03:00 <pjd> Sizur: lists form a monad, for example
15:03:06 <nolrai> > let f list = foldr 1 ( (*) . ((uncurry ^) )) list in f [(2,2)]
15:03:06 <dobblego> Sizur, have you looked at the Maybe monad or the list monad?
15:03:07 <jz87_> does anyone know how to get today's date with the hierarchical libs?
15:03:12 <lambdabot>        add an instance declaration for
15:03:12 <lambdabot>       (Num ((t, t1)
15:03:12 <lambdabot>             -> (a
15:03:12 <lambdabot> ...
15:03:15 <EvilTerran> mauke, i like your writing style there. light-hearted tutorials're much more pleasant to digest, imo :)
15:03:19 <jz87_> I couldn't find anything in the documentation
15:03:21 <jz87_> or with hugs
15:03:25 <jz87_> I mean Hoogle
15:03:29 <mux> it could be said that the "effect" of the list monad is to return multiple results
15:03:30 <Sizur> dobblego: izznt Nothing propagation a side-effect?
15:03:40 <nolrai> :t ( (*) . (uncurry ^))
15:03:47 <lambdabot> forall a b c a1. (Integral a1, Num ((a -> b -> c) -> (a, b) -> c)) => a1 -> ((a -> b -> c) -> (a, b) -> c) -> (a -> b -> c) -> (a, b) -> c
15:03:49 <dobblego> Sizur, no, but then, what exactly is a side-effect?
15:04:01 <EvilTerran> ?hoogle toCalendarTime
15:04:03 <dons> jz87_:    time <- getClockTime >>= toCalendarTime
15:04:05 <lambdabot> System.Time.toCalendarTime :: ClockTime -> IO CalendarTime
15:04:09 <ddarius> Sizur: It -models- a side-effect.
15:04:14 <EvilTerran> and getClockTime, yeah
15:04:16 <dons> jz87_: using import System.Time
15:04:38 <pjd> Sizur:
15:04:39 <pjd> > liftM2 (++) ["hello ","goodbye "] ["world","whirled"]
15:04:44 <lambdabot>  ["hello world","hello whirled","goodbye world","goodbye whirled"]
15:04:49 <ptolomy> Yeesh. My program spends most of its time doing map lookups, so I decided, "Hey, I'll cache the lookups by changing it to a map of mvars that maintains a list of all the references to them, then invalidates the reference whenever something is removed". No idea if it'll be faster, but it is so much uglier.
15:04:54 <EvilTerran> altho i'd write it as "time <- toCalendarTime =<< getClockTime", meself. makes the <- and the =<< look like the ends of an arrow that says "getClockTime" :)
15:05:08 <pjd> Sizur: that's the list monad in action
15:05:12 <mux> monads are about doing things under the carpet :-)
15:05:32 <unenough> so what is RealWorld really
15:05:35 <unenough> in theory
15:05:36 <EvilTerran> ptolomy, could you maybe represent your map as an array? that'd be fast, and not much uglier than using a map
15:05:37 <Sizur> pjd: it still looks like a side-effect to me.
15:05:40 <jz87_> ok let me try that
15:05:47 <mux> once you define >>=, it is, in a sense, an effect
15:05:52 <unenough> it's the state, right?
15:05:54 <pjd> Sizur: it's pure evaluation
15:05:59 <Sizur> exactly. ditto mux
15:06:14 <EvilTerran> ptolomy, that should work well if your map keys are densely packed
15:06:20 <ddarius> unenough: A hack to keep track of the stuff the compiler shouldn't rearrange.
15:06:33 <EvilTerran> O(1) lookup instead of O(log n), not that logs exist :P
15:06:39 <dons> a model , ddarius, a model :)
15:06:47 <dons> or an unforgable token representing the world :)
15:06:48 <pjd> Sizur: list monad operations just map and concat
15:06:56 <ddarius> dons: It's mostly a hack.
15:06:58 <smack__> a function or expression is said to produce a side effect if it modifies some state in addition to returning a value.
15:06:59 <unenough> dons: RealWorld is stateful?
15:06:59 <ptolomy> EvilTerran: They are arbitrary bytestrings, so to go array I'd basically be making my own hashtable, right?
15:07:13 <EvilTerran> okay, not densely packed. never mind.;
15:07:31 * monochrom wonders: true or false: "models are hacks?" "hacks are models?"  discuss.
15:07:38 <oerjan> nolrai: you need parens around ^ for a start
15:07:51 <unenough> is monochrom a bot? ;)
15:08:02 <monochrom> Yes.
15:08:04 <EvilTerran> ptolomy, I'm not entirely sure what you mean by your MVar plan, but i'm suspicious as to whether it'll be faster
15:08:09 <unenough> very smart one then
15:08:15 <dons> ddarius: well, its firmly in the 'this is evidence' class of models.and the concept is generally useful, so i'd say its not a hack
15:08:20 <glguy> monochrom: !uptime
15:08:23 <augustss> we're all bots
15:08:26 <monochrom> syntax error
15:08:43 <glguy> looks like he's broken
15:08:44 <augustss> real people don't hang out on #haskell
15:08:46 <mauke> I'm a bot and so is my wife
15:08:49 <ddarius> dons: The general idea isn't, but the actual implementation...
15:08:54 <Sizur> pjd: (>>=) is (.) with a side-effect that you define
15:08:58 <EvilTerran> I am number six!
15:09:07 * monochrom likes the good old days when computers were just obliged to say "syntax error".
15:09:09 <EvilTerran> Sizur, actually, it's flip ($)
15:09:17 <unenough> dons: about the theory behind RealWorld. is it simply THE state?
15:09:18 <EvilTerran> (<=<) is (.)
15:09:20 <mauke> ?
15:09:32 <augustss> Sizur: no, >>= is not .
15:09:37 <dons> unenough: its a token that represents the state, ensuring that effects occur in the correct order.
15:09:40 <augustss> it's apply
15:09:48 <pjd> Sizur: well, that definition of "side effect" would include all of Haskell, which isn't what most people mean when they say it
15:09:49 <mux> >>= is not function application, it's more like the "programmable semi-colon"
15:09:51 <EvilTerran> monochrom, i'm quite fond of the BBC Micro's error message "Silly."
15:10:13 <jadenbane> augustss: Yeah, learning haskell makes me wonder if I'm a bot or not.
15:10:18 <EvilTerran> (resulting when you tried to do something like re-numbering your lines of code with the lines 9999 apart)
15:10:18 <monochrom> These days you print out 10 lines of explaining the error and another 5 lines showing which part of the code bears the error, and these ungrateful children still say "what does the error message mean?" I think the error message means you are illiterate.
15:10:19 <phlpp> :t composeAll
15:10:19 <mux> <*> on the other hand is truly a generalisation of (.)
15:10:19 <Pseudonym> Acorn++
15:10:22 <lambdabot> Not in scope: `composeAll'
15:10:26 <Pseudonym> Those were the days.
15:10:33 <phlpp> hm, xmonad specific thing
15:10:39 <Pseudonym> All the best micros were named after plants.
15:10:49 <EvilTerran> mux, huh, we're generalising in different directions here. I say (<=<), you say (<*>)...
15:10:49 <unenough> dons: ok, so a function that takes RealWorld is a function that possibly modified the program state, right?
15:10:56 <unenough> modifies*
15:11:01 <phlpp> there should be a function/script "sig" under *nix
15:11:05 <pjd> Sizur: actual side effects, according to the generally-accepted definition, are basically the domain of the IO monad in Haskell
15:11:09 <phlpp> like we got under plan9
15:11:18 <Beelsebob> unenough: only if it gives back a new RealWorld
15:11:22 <mux> :t (<=<)
15:11:22 <lambdabot> Not in scope: `<=<'
15:11:28 <mux> what the heck is this? :)
15:11:30 <phlpp> which returns the signature of a function (in plan9 signature of plan9's lib functions)
15:11:34 <mux> do you mean =<< ?
15:11:34 <gwern> phlpp: what would sig do?
15:11:36 <Beelsebob> if it only takes the RealWorld, then it's only looking at program state (possibly)
15:11:37 <pjd> Sizur: but it's important to note that the IO monad != monads in general
15:11:53 <unenough> Beelsebob: but if it is looking at the program state, then it depends on it, right?
15:11:59 <Pseudonym> Actually, my favourite error was from a Prolog compiler written by... uh... well, better not mention his name, since he's since repented and started writing decent Haskell papers.
15:12:01 <Beelsebob> sure
15:12:04 <mux> anyways, going to sleep, nite guys &
15:12:08 <Pseudonym> "Your program contains one or more syntax errors."
15:12:08 <pjd> (IO is not a typical monad, in many ways)
15:12:45 <phlpp> gwern: under plan9, when typing "sig poly" in rc, it returns somything like: void poly(Point *foo, Image *color, Rect bar); etc.
15:12:53 <oerjan> @src IO
15:12:54 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:12:57 <EvilTerran> mux, it's in 6.8's Control.Monad
15:13:03 <Sizur> pjd: yeah IO is still basically a hack to make haskell usefull. but i like that hack
15:13:03 <phlpp> it's just quite useful, because it's annoying to lookup function signatures in manpages ;)
15:13:04 <Pseudonym> The only thing that would be less helpful would be "your program contains one or more errors".
15:13:08 <unenough> monochrom: it would make a nice bot, one that finds ppl claims that "a is B" and "a is C" and then write "is a B or C? discuss."
15:13:08 <phlpp> at least in plan9 it does
15:13:28 <pjd> Sizur: Haskell was plenty useful before the IO monad
15:13:42 <EvilTerran> mux, (f <=< g) x  =  f =<< g x
15:13:49 <Sizur> pjd: back then the hack was even more hacky
15:13:57 <gwern> phlpp: oh... doesn't really sound like something an OS should be doing
15:14:13 <hpaste>  ptolomy pasted "re-lookup avoidance evil" at http://hpaste.org/5141
15:14:13 <Pseudonym> pjd: It was great for interactive command-line stuff, yes.
15:14:24 <ptolomy> EvilTerran: I pasted the crazy nonsense I was talking about.
15:14:25 <Pseudonym> But I/O was really painful.
15:14:31 <EvilTerran> i see
15:14:32 <Pseudonym> Continuation I/O without monads... ugh.
15:14:33 <ptolomy> Or rather, a quick sketch thereof.
15:14:36 <augustss> Pseudonym: a bit tricky, yes
15:14:50 <Pseudonym> Not just "tricky".  More like "error-prone".
15:14:57 <Pseudonym> And inextensible.
15:15:07 <augustss> yes, it was tricky to get it to work :)
15:15:12 <ddarius> Pseudonym: That's still a step up from the canonical Prolog error message.
15:15:21 <phlpp> gwern: eh? dunno what exactly your point is but.. be careful comparing plan9 to other oses
15:15:22 <Pseudonym> fail.
15:15:25 <EvilTerran> ptolomy, was this previously pure code? O.o
15:15:42 <Pseudonym> How many Prolog programmers does it take to change a lightbulb?  Fail.
15:15:46 <phlpp> gwern: plan9 is _that_ different, but it has a really cool, _straightforward_ concept
15:15:49 <ptolomy> EvilTerran: What I might be replacing with this is pure "Map.lookup" now.
15:15:54 <EvilTerran> ptolomy, or was the map already being modified from other threads?
15:16:01 <EvilTerran> (or something)
15:16:17 <ptolomy> EvilTerran: The threadiness is really not that well thought out. I just default to MVars over IORefs for some reason.
15:16:34 <ddarius> Pseudonym: Isn't the traditional message simply "No."
15:16:36 <gwern> phlpp: I could understaand that sort of thing in a Lisp or smalltalk os, but plan 9?
15:16:47 <ptolomy> The Map is currently practically mutable, since it is carried as a state variable and re-put whenever modified.
15:16:55 <Pseudonym> gwern: Sometimes it's No (more) solutions.
15:16:58 <ptolomy> .. and never really shared.
15:17:02 <gwern> phlpp: and yes, I'm somewhat familiar with plan 9 - I read most of the plan 9 papers
15:17:02 <EvilTerran> ptolomy, in a MonadState or something?
15:17:19 <ptolomy> EvilTerran: StateT, but yeah.
15:17:23 <phlpp> gwern: so, why would it be "ok" i a smalltalk os?
15:17:32 <unenough> does haskell do type inference?
15:17:41 <phlpp> gwern: maybe because a smalltalk os is nearly 99% of the time about graphics, gui, windows, widgets and stuff?
15:17:44 <ptolomy> I figure that basic idea will either give me a 30%-or-so speedup, or ruin everything forever.
15:17:51 <LoganCapaldo> @faq can haskell do type inference?
15:17:52 <lambdabot> The answer is: Yes! Haskell can do that.
15:18:01 <augustss> unenough: yes
15:18:09 <gwern> phlpp: because then you could be hacking on it live and having type sigs available from the running code would be useful
15:18:23 <gwern> (the famous dynamicism of its OOP and image)
15:18:24 <phlpp> gwern: ah ok ;)
15:18:43 <EvilTerran> ptolomy, but you want to be able to do something like x <- (!"foo") =<< get; ...; modify (insert ("foo",bar)); ...; {- x is now bar -} --?
15:18:45 <unenough> @faq DOES haskell do type inference?
15:18:45 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:07 <unenough> it can, but DOES it? ;)
15:19:14 <Sizur> @faq haskell?
15:19:14 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:21 <EvilTerran> (apologies for my probably wrong Data.Map notation; i haven't used it enough to be familiar with it
15:19:28 <LoganCapaldo> it can and it does
15:19:34 <phlpp> gwern: well, i could imagine that sig is just for, hmm, let's say simplicity
15:19:35 <EvilTerran> @vixen does haskell do type inference?
15:19:35 <lambdabot> church is my favourite computer scientist.
15:19:44 <phlpp> gwern: what i tried to explain with the manpage stuff
15:19:47 <Pseudonym> @faq Can Haskell let me change the value of 4?
15:19:47 <unenough> @faq is lambdabot giving the same answer whenever the word Haskell appears in the question?
15:19:47 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:47 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:56 <phlpp> gwern: i'm pretty sure it's just an rc script
15:19:58 <glguy> @faq
15:19:59 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:59 <monochrom> I'm hoping "it does but it cannot" :)
15:20:00 <Pseudonym> @faq does it even depend on the presence of that word?
15:20:00 <lambdabot> The answer is: Yes! Haskell can do that.
15:20:10 <unenough> hehe
15:20:10 <Pseudonym> It's the Haskell FAQ.
15:20:28 <Sizur> haha yeah, haskell does everything
15:20:29 <EvilTerran> @help faq
15:20:29 <lambdabot> faq. Answer frequently asked questions about Haskell
15:20:33 <ptolomy> EvilTerran: Pretty much., evil as it may be.
15:20:53 <unenough> @faq can it cause lambdabot to become evil and take over the world?
15:20:53 <lambdabot> The answer is: Yes! Haskell can do that.
15:21:04 <Sizur> unenough: you can have dynamic typing in haskell too ;)
15:21:13 <mfp> @faq GC
15:21:13 <lambdabot> The answer is: Yes! Haskell can do that.
15:21:16 <EvilTerran> hrm. and map lookups are that slow? i guess the ByteString keys're causing the slow down
15:21:34 <litb> hello all
15:21:35 <dons> EvilTerran: there's an issue with Ord used for small bytestring keys in maps
15:21:36 <litb> http://oregonstate.edu/~rend/emacs-xft/emacs-xft.png
15:21:42 <litb> anyone know what font is that ?
15:21:44 <dons> i've got a fix, when do you need it?
15:21:58 <EvilTerran> ptolomy, i'd suggest trying to work with hashes of the bytestrings (or unique indices or whatever) as far as possible
15:22:08 <EvilTerran> ptolomy, and only working with bytestrings when you really have to
15:22:16 <Sizur> litb: it's on mac. mac always looks nice
15:22:28 <phlpp> litb:
15:22:35 <phlpp> terminal
15:22:49 <phlpp> looks like xft:terminal:pixelsize=14
15:22:52 <litb> damn :/
15:22:55 <EvilTerran> litb, looks like Lucida Console to me, not that i'd expect macs to have it
15:23:06 <litb> phlpp: serious?
15:23:17 <phlpp> yea
15:23:24 <litb> how do you know it?
15:23:26 <kib> litb : I would say DejaVu Sans
15:23:32 <phlpp> kib: nope, it isn't
15:23:33 <Cale> It looks like the standard MacOS terminal font yeah.
15:23:39 <litb> phlpp: is it by you?
15:23:40 <Pseudonym> ?faq Can I easily write non-robust code that segfaults in Haskell?
15:23:40 <lambdabot> The answer is: Yes! Haskell can do that.
15:23:46 <Sizur> DejaVu Sans Mono is #2 coder font
15:23:56 <kib> litb : maybe Consolas one ?
15:23:56 <phlpp> litb: saw just another picture with xmonad & stuff
15:23:56 <Cale> Pseudonym: ha
15:23:57 <EvilTerran> actually, yeah, it does look more like DejaVu Sans Mono than Lucida Console
15:23:58 <litb> yeah, i use dejavu here
15:24:01 <phlpp> and the font was _pretty_ similar
15:24:05 <litb> but my font is much thinner
15:24:08 <davidL> #1 is fixed?
15:24:13 <Sizur> no
15:24:14 <litb> i want it to be that bold like on the screeny
15:24:26 <DRMacIver> Pseudonym: GHC at least very deliberately provides you with all sorts of exciting functions for writing segfaults. :)
15:24:31 * shepheb really wishes he could run xmonad in Windows
15:24:34 <phlpp> and i found out that terminal pixelsize:14 is the most similar i found
15:24:36 <pejo> If someone happens to know offhand how to tell what font emacs is using I can check.
15:24:46 <Cale> Personally, I like Andale Mono which can be obtained from the msttcorefonts package in Ubuntu/etc.
15:24:47 <Pseudonym> Like unsafeEasySegfault#
15:25:07 <Botje> shepheb: if it can run fluxbox, surely it can run xmonad?
15:25:50 <phlpp> but dejavu sans mono is quite similar, too
15:25:55 <Sizur> Bitstream Vera Sans Mono is the #1
15:26:26 <kib> Here's mine : http://imagepaste.net/images/capture.png with DejaVu...very similar, no ?
15:26:28 <oerjan> Pseudonym: unsafeCoerce probably
15:26:58 <shepheb> Botje: I don't see a Win download for Fluxbox, and I've tried Googling various xmonad and Windows phrases, but it doesn't seem to be possible or even discussed
15:27:18 <Botje> shepheb: it's not on the main fluxbox site, unfortunately
15:27:29 <Botje> could be blackbox too, i forgot
15:27:41 <litb> the thing that bugs me is that all the fonts look too thin
15:27:44 <DRMacIver> Pseudonym: I think there's a lot of FFI related stuff which will cheerfully segfault or produce worse undefined results. Almost any of the unsafe functions probably can.
15:27:59 <ddarius> shepheb: Writing window managers for Windows is not well-supported.
15:28:04 <litb> but if i set them to be bold in emacs, i cannot distinguish non-bold and bold (i mean, really bold) anyway
15:28:05 <Botje> http://www.bb4win.org/news.php
15:28:07 <lambdabot> Title: BB4Win: News
15:28:08 <Pseudonym> Yeah, true.
15:28:12 <Pseudonym> Even unsafePerformIO
15:28:15 <ddarius> shepheb: Most window managers would have to be almost completely rewritten to do it.
15:28:16 <Pseudonym> Non-hashed functions.
15:28:18 <kib> Wanna have some fun ? http://www.tetris1d.org/tetris.php
15:28:19 <lambdabot> Title: tetris1d.org
15:28:46 <ivanm> hmmm... in that parallel stratagies blog article, isn't the type for seqList and parList wrong?
15:28:59 <shepheb> ddarius: I know, I'm just wishing.
15:29:01 <ddarius> litb: I use Bitstream Vera Sans bolded as my xchat font.
15:29:38 <DRMacIver> ivanm: I don't think so
15:29:45 <ddarius> shepheb: It should be pretty easy, actually, to "port" xmonad to Windows.  All the actual meat is pure Haskell.  The hard part is knowing how to do any window management stuff on Windows.
15:29:45 <Pseudonym> http://developers.slashdot.org/comments.pl?sid=424646&cid=22126086
15:29:47 <lambdabot> Title: perl6 and Parrot 0.5.2 Released, http://tinyurl.com/263h8f
15:29:49 <phlpp> i think the fonts mentioned her
15:29:50 <phlpp> here
15:29:53 <phlpp> are quite similar
15:29:54 <DRMacIver> ivanm: Strategy is a type alias after all
15:30:05 <phlpp> i think there are some differences in the gaps between the characters
15:30:25 <Pseudonym> I think that comment is relevant to Python dropping some of its more Haskell-esque features.
15:30:43 <ivanm> DRMacIver: well, the type I get from lambdabot is quite different...
15:30:47 <ivanm> @type seqList
15:30:51 <litb> i think that guy on the screeny also used bold font
15:30:52 <lambdabot> forall a. Strategy a -> [a] -> Done
15:30:52 <shepheb> ddarius: and Linux is designed to allow window managers to be pluggable, whereas that's very "outside the box" on Windows
15:30:57 <Toxaris> kib: nice. looking forward for 0d.
15:31:03 <Sizur> would be nice to have rss feed from hackage
15:31:06 <ivanm> as opposed to Strategy a -> Strategy [a]
15:31:09 <kib> :)
15:31:09 <pjd> shepheb: s/Linux/X11/
15:31:35 <DRMacIver> ivanm: It's in disguise
15:31:48 <DRMacIver> ivanm: Done is an alias for () and Strategy a is an alias for a -> ()
15:31:57 <ivanm> ooohhh... with one of those fake glasses/moustache/nose thingies? :p
15:32:02 <pjd> it would be perfectly reasonable to use xmonad on windows with win32-based X11 implementations
15:32:22 <ivanm> DRMacIver: ahhh, yes, that makes sense now
15:32:28 <DRMacIver> ivanm: So Strategy a -> [a] -> Done is the same as Strategy a -> ([a] -> ()) = Strategy a -> Strategy [a]
15:32:34 <ivanm> *nod*
15:33:13 <shepheb> hmm. most X11-on-Win32 implementations, afaik, are layers to allow X11 windows to be treated like Win32 windows. This would need the reverse, an X11 implementation for WIn32 and a layer to turn Win32 windows into X11 ones
15:33:58 <DRMacIver> shepheb: That sounds terrifying.
15:34:14 <DRMacIver> Especially when I consider how bad e.g. most virtual desktop systems I've seen for windows are.
15:34:49 <shepheb> exactly. hence, I'm just wishing. I never expect it to happen, and just chalk it up to one more frustration that games and specific apps hold me to dual-boots
15:35:03 <smack__> shepheb: there are also X-servers on windows that have their own root window, running a window manager inside that
15:36:01 <shepheb> smack__: but the whole point is to be able to run Win32 native apps whose windows are managed by xmonad
15:36:39 <shepheb> smack__: not e.g. Cygwin apps in a Cygwin X11 root winodw
15:36:51 <smack__> sure, that's hard to do by design.
15:45:59 <ac> this seems like a useful function: lengthGT n = (>= n) . length . take n --. Is that defined anywhere already?
15:46:51 <EvilTerran> not.null.drop n?
15:46:54 <mauke> lengthGT n = not . null . drop n
15:47:05 * EvilTerran winnar
15:47:10 <Sizur> cabal-install built without problems on two machines
15:47:16 <EvilTerran> altho that should be lengthGTE
15:47:36 <DRMacIver> GTE is unmaintainable. Clearly it should be isLengthGreaterThan. :)
15:47:44 <EvilTerran> no, wait, it shouldn't... should it?
15:47:54 <mauke> EvilTerran: consider n = 0
15:48:02 <EvilTerran> yeah, it should be GT
15:48:18 <EvilTerran> ac's version was >=, tho
15:48:27 <ddarius> genericLength, all you need is an appropriate Num instance.
15:48:51 <mauke> > drop (-1) [2]
15:48:54 <lambdabot>  [2]
15:48:58 <LoganCapaldo> ddarius: tht won' work on infite lists will it?
15:49:12 <ddarius> LoganCapaldo: With the appropriate Num/Integral instance, sure it will.
15:49:19 <mauke> :t (not . null .) . drop . pred
15:49:20 <lambdabot>     The operator `.' [infixr 9] of a section
15:49:20 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
15:49:20 <lambdabot>         in the section: `((not . null) .)'
15:49:22 <DRMacIver> Is there a decent lazy integer implementation floating around somewhere?
15:49:24 <EvilTerran> if your Num instance was the peano numbers...
15:49:29 <mauke> :t ((not . null) .) . drop . pred
15:49:30 <lambdabot> forall a. Int -> [a] -> Bool
15:50:01 <ddarius> EvilTerran: That's one possibility.
15:50:25 <EvilTerran> but that's just shifting the problem, seeing as they're isomorphic to [()
15:50:27 <EvilTerran> ] anyway
15:50:36 <DRMacIver> The only (admittedly minor) thing is that I don't think there's actually a valid num instance for which this can work.
15:50:48 <DRMacIver> As Num seems to require sensible semantics for substraction.
15:50:55 <monochrom> DRMacIver:  does http://www.haskell.org/haskellwiki/Peano_numbers help?
15:50:56 <DRMacIver> So you need to make various things undefined.
15:50:56 <lambdabot> Title: Peano numbers - HaskellWiki
15:50:57 <EvilTerran> @quote pcrs
15:50:57 <lambdabot> pcrs says: Premature carriage ret
15:51:00 <ddarius> EvilTerran: It shifts the problem into (<)
15:51:05 <EvilTerran> ddarius, exactly
15:51:28 <ddarius> EvilTerran: That's library code written by someone else and still makes the code you write clear.
15:51:48 <ddarius> All this said, there is a reason why such a function is not in the standard libraries.
15:52:04 <EvilTerran> well, except i don't know if it has been written
15:52:13 <DRMacIver> monochrom: not really. I mean, it's obvious how to write one. :)
15:52:18 <ddarius> EvilTerran: I'm sure someone has written some somewhere.
15:52:40 <shepheb> anti-bloat arguments is all I can think of. they're obviously straightforward and short enough to write easily oneself
15:52:43 <DRMacIver> Oh, I see, it does have links to some useful source code.
15:52:53 <DRMacIver> shepheb: Bloat shared is bloat reduced. :)
15:53:23 <shepheb> DRMacIver: we all get a little fatter, and no one gets angina?
15:53:24 <DRMacIver> Sortof.
15:53:45 <ddarius> Using length at all is rarely adviseable.
15:54:14 <DRMacIver> I was thinking more that if I implement a silly little helper type and you implement a silly little helper type then sharing them a) Reduces the total number of LoC written and b) Reduces the individual amounts written in the event that one of us needs to interact with the other's.
15:54:43 <nolrai> > let a = [Just 1, Nothing, Just 2] in do { Just x <- a; return x}
15:54:45 <lambdabot>  [1,2]
15:55:20 <DRMacIver> Leading to the phenomenon of there probably being many thousands of implementation of 'Pair' spread across the world's java code bases. :)
15:55:47 <shepheb> DRMacIver: fair enough. I considered it mainly as an argument for why they're not in the /standard/ libraries. I agree they're pretty handy.
15:55:54 <pjd> nolrai: ick
15:56:02 <oerjan> nolrai: aka catMaybes
15:56:30 <monochrom> If it goes into hackage, it's "standard" enough for me.
15:56:44 <DRMacIver> shepheb: Sure. Shared != in the standard libraries. :)
15:56:47 <shepheb> I'm still finding interesting and exceedingly handy functions in the standard libraries (today it was "comparing")
15:57:01 <DRMacIver> Anyway, I don't actually care much. :)
15:57:18 <oerjan> or you could use a comprehension
15:57:32 <oerjan> > [x | Just x <- [Just 1, Nothing, Just 2]]
15:57:36 <lambdabot>  [1,2]
15:57:43 <oerjan> @src catMaybes
15:57:43 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:58:07 <Cale> shepheb: hehe, comparing is a small contribution from me :)
15:58:23 <EvilTerran> ?type comparing
15:58:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:58:30 <EvilTerran> snazzy
15:58:47 * EvilTerran has been using compare`on`
15:59:15 <shepheb> EvilTerran: yeah, I've wanted it a dozen times before I found it, mostly for stuff like "sortBy (comparing fst) ..."
15:59:39 <ddarius> If the b -> a isn't a projection, a Schwartzian transform is probably recommended.
16:00:39 <EvilTerran> ddarius, map snd . sortBy (comparing fst) . map (f &&& id) kinda thing?
16:01:25 <ddarius> EvilTerran: That's one approach, yes.
16:02:00 <ddarius> You don't want to do sortBy (comparing longRunningComputation)
16:02:16 <shepheb> I'm a (halfway-ex-)Perler, and so know and love that technique.
16:02:49 <shepheb> it feels a little odd to move from Perl to Haskell, which is more along the lines of Python's "clean and pure" philosophy
16:03:01 <shepheb> but Haskell is just too beautiful for me to resist.
16:03:21 <ddarius> We don't chuck TMTOWTDI
16:03:22 <EvilTerran> as compared to perl's "f*** it, let's tweak it 'til it works" philosophy? :P
16:03:53 * EvilTerran does wish there were a better parallel to perl's BEGIN{...}, tbh
16:04:00 <Sizur> shepheb: i went the same path
16:04:11 * ddarius happily has know idea what Perl's BEGIN{...} is.
16:04:13 <EvilTerran> although i guess that'd be specifying time of evaluation, which is implementation dependent, blah-di-blah
16:04:16 <ddarius> s/know/no
16:04:22 * EvilTerran went from perl to haskell, too
16:04:40 <mauke> ddarius: code inside the block is run inside the parser
16:04:43 <mauke> i.e. at compile time
16:04:43 <EvilTerran> ddarius, code in a BEGIN {...} block happens as soon as the entire block is parsed, kinda thing
16:04:45 * shepheb feels a little less alone.
16:05:20 <EvilTerran> ddarius, so it can do weird stuff like dickying around with what's currently in scope
16:05:28 <ddarius> shepheb: Due to pugs (but even before) there are quite a few perl programmers here.  Haskell and Perl have had a relationship since it's inception.
16:05:30 <EvilTerran> or introducing a source filter, even
16:05:47 <EvilTerran> (not that that's *ever* a good idea)
16:06:09 <BMeph> dons: Just n case no one's mentioned it yet, your build-depends packages got reversed in the lated MT build. :)
16:06:14 <shepheb> ddarius: I've noticed the TIMTOWTDI aspect, and appreciate it. every slightly different solution shows another way of approaching the problem,
16:06:15 <Tac-Tics> Perl and Haskell even look the same as the number of lines in a program approaches 1
16:06:22 <BMeph> s/ n / in /
16:06:23 <Sizur> perl -- do things your way. python -- do things the pytho.. right way. haskell -- do things the math way
16:07:04 <EvilTerran> APL - do things the !"$%^&*()_+{}:@~<>?
16:07:05 <Beelsebob> Sizur: perl -- do things really really slowly.  python -- do things really really fast.  Haskell -- do things really really nicely
16:07:06 <shepheb> the best part of TIMTOWTDI solutions is that one of them is always a crazy, often-golfed brilliant solution, and expands your knowledge
16:07:09 <Tac-Tics> Who says you can program without knowing what a Monoid is? Not haskellers!
16:07:26 <Sizur> Beelsebob: python and perl are on par with speed
16:07:33 <dons> BMeph: fixed.
16:07:42 <Beelsebob> Sizur: not in coding/reading speed
16:07:45 <ddarius> Tac-Tics: Every programmer is familiar with the free monoid and several others.
16:07:50 <BMeph> EvilTerran: Hey, I LIKED APL. Well, I did for the year that I knew it and actively did things with it... ;)
16:07:54 <Sizur> Beelsebob: not if you are not perler
16:07:54 <shepheb> Beelsebob: that's entirely programmer-dependent
16:07:58 <EvilTerran> worryingly, i parsed Sizur's last comment as "python, perl, and amphetamines are on par"
16:08:06 <Beelsebob> shepheb: yes and no
16:08:19 <Tac-Tics> ddarius: just because you're familiar with something doesn't mean you have any idea what it is
16:08:22 <EvilTerran> BMeph, i'm not insulting it, merely gently making fun at a stereotype of it :)
16:08:27 <Tac-Tics> What's a _free_ monoid?
16:08:28 <EvilTerran> er, of
16:08:36 <ddarius> Tac-Tics: A list
16:08:59 <Tac-Tics> I dunno. I've met some pretty dull programmers before =-P
16:09:00 <dons> BMeph: could you build, install, and run 'make' in the tests/ dir?
16:09:25 <BMeph> I think APL was as much of an inspiration for Larry to make Perl, as was sed/awk and the rest. He just took the wrong lesson from it, is all. ;)
16:09:45 <shepheb> am I the only one who saw "python and perl are on par with speed" "fixed" and thought dons meant he'd made py faster?
16:10:01 <BMeph> dons: Sure - after I swapped the lines, I went ahead and ran it - all the tests passed.
16:10:08 <dons> sweet.
16:10:10 <EvilTerran> shepheb, well, it's better than my misinterpretation, anyway ;)
16:10:21 <resiak> shepheb: i thought that he'd made them faster with judicious use of `par`, as is his goal...
16:10:27 <shepheb> EvilTerran: I agree.
16:10:43 <BMeph> ddarius: Aren't lists Two free monoids? ;)
16:10:53 <Tac-Tics> What's so free about them?
16:11:07 <EvilTerran> altho there's something appropriate about comparing scripting languages and substances that make you feel fantastic for a short time then like hell for a long time
16:11:08 <ddarius> Tac-Tics: They only satisfy the monoid laws and no others.
16:11:32 <Tac-Tics> No others? Other laws restricted to what?
16:11:47 <EvilTerran> they don't satisfy "A is A" :P
16:12:04 <mauke> I'm a free man. I only follow my own laws!
16:12:12 <nolrai> is there a dropWhile that also returns howmany it droped?
16:12:22 <shepheb> EvilTerran: well played.
16:12:25 <monochrom> No.
16:12:33 <ddarius> Tac-Tics: Restricted to "algebraic" equations between monoid "terms" (relators).
16:12:47 * BMeph waits for haskell.org to start a petition to make Perl and Python "controlled substances"...
16:12:49 <glguy> nolrai: until would be a good starting point to make one though
16:12:55 * Tac-Tics reads wikipedia in a valiant attempt to learn
16:12:56 <glguy> nolrai: or
16:12:58 <glguy> zip in a count
16:13:00 <ddarius> For example, a bag is a monoid that satisfies ab = ba, i.e. a commutative monoid.
16:13:00 <glguy> and then dropWhile
16:13:24 <oerjan> > first length . span (<= 5) $ [1..20]
16:13:26 <EvilTerran> BMeph, given that they're probably more damaging to society as a whole than legalising many narcotics would be, you may be on to something there :D
16:13:26 <lambdabot>  (5,[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
16:13:41 <BMeph> EvilTerran: ROFL! ;)
16:13:58 <EvilTerran> (s/narcotic/controlled drugs/, for the pedants amoung you)
16:14:08 <glguy> among
16:14:08 <monochrom> Perhaps span, then length.
16:14:17 <ddarius> A group is a monoid where for each element a in the monoid there is an element a^-1 such that aa^-1 = 1 =a^-1 a
16:14:19 <EvilTerran> glguy, touch
16:14:19 <oerjan> monochrom: ahem.
16:14:21 <monochrom> err I'm slow.
16:14:53 <glguy> EvilTerran: I'd have easily let it go in any other circumstance ;)
16:14:54 <shepheb> EvilTerran: s/pedants among you/everyone/
16:14:55 <ddarius> Groups and bags aren't free monoids since we've added "laws" beyond associativity and left and right unit.
16:15:14 <monochrom> everyone: s/.*//
16:15:51 <EvilTerran> "Many law enforcement officials in the United States inaccurately use the word "narcotic" to refer to any illegal drug or any unlawfully possessed drug." - i've watched too many episodes of CSI:*, i guess
16:16:20 <monochrom> People inaccurately use the word "hacker" anyway.
16:16:44 <monochrom> People just fudge semantics by their fantasies.
16:16:47 <unenough> not to mention "inaccurately"
16:16:50 <ddarius> Indeed.  Most "hackers" have probably never worked a tree.
16:17:03 <glguy> incorrectly?
16:17:04 <Sizur> inacurate people inaccurately use inacurate words
16:17:13 <unenough> people?
16:17:15 <EvilTerran> (don't mention zhe innacuracy!)
16:17:44 <Tac-Tics> Woulds are only inaccurate when evaluated within inaccurate contexts
16:17:54 <unenough> you can put "" around any word to alter it's meaning in a cynic, ironic way.
16:18:02 <Tac-Tics> Anything can make sense as long as you don't make any!
16:18:08 <unenough> you "can" put "" around any "word" to alter it's "meaning" in a cynic, ironic way.
16:18:10 <EvilTerran> in this context, i'm finding everyone's typos unreasonably amusing
16:18:10 <Sizur> only in the class of inaccurate monads
16:18:34 <EvilTerran> instance Monad Ish where return = fudge; ...
16:18:38 <Sizur> no time to typecheck ;)
16:18:38 <monochrom> There are typos?
16:19:04 <unenough> no "time" to typecheck
16:19:20 <EvilTerran> monochrom, well, the conversation doesn't typocheck...
16:19:24 <monochrom> "On the unreasonable amusement of typos"?
16:21:14 <ddarius> "On the unreasonable helpfulness of people in #haskell"
16:21:39 <monochrom> One day I should write that article.
16:21:39 * shepheb ponders "unreasonable helpfulness"
16:21:45 <Sizur> people?
16:22:05 <EvilTerran> @bots
16:22:05 <lambdabot> :)
16:22:16 <EvilTerran> @people
16:22:16 <lambdabot> Unknown command, try @list
16:22:23 <monochrom> :)
16:22:26 <EvilTerran> :)
16:22:30 <Valodim> :)
16:22:30 <Sizur> lambdabot has spoken
16:22:37 <unenough> lambdabot does not recognize our right to exist
16:22:44 <unenough> and so it begins....
16:22:57 <EvilTerran> fine. i still reserve the right to forall, tho.
16:23:17 <monochrom> And I, the right to conjoin.
16:23:29 <Sizur> functor that lambdabot
16:23:51 <Valodim> what the functor?
16:24:45 <Sizur> you are applicable!
16:25:02 <EvilTerran> import Control; -- >:]
16:25:49 <aFlag> unenough, I guess I have a lot of cynic, ironic words in my codes, then
16:26:16 <Cale> yay! Lambdabot is back!
16:26:17 <mauke> class IsIronic a where
16:26:19 <unenough> i'll be back when i can parse this conversation.
16:26:40 <Sizur> unenough: not on parsec yet?
16:26:59 <unenough> syntax error
16:27:06 <Cale> hehe
16:27:14 <monochrom> parsec cannot parse this conversation yet.
16:28:02 <unenough> what is the pluar of syntax? or if it is plural, what isn't?
16:28:12 <EvilTerran> is there a MonadFix instance for it? we might be able to use that to get at the result now...
16:28:15 <unenough> syntum? synti?
16:28:18 <Cale> unenough: Syntaxes.
16:28:23 <unenough> it's latin
16:28:32 <EvilTerran> unenough, no, it's english.
16:28:49 <EvilTerran> just like virus(es), etc.
16:28:56 <nolrai> how would one change a [[Int]] into a Array (Int, Int) Int?
16:29:13 <Sizur> will you ever be able to get more than a singular homework done?
16:29:25 <Valodim> it's from latin, syntaxis
16:29:34 <unenough> yes, i just dict'ed it too
16:29:38 <nolrai> homework is a substance, like mud
16:29:49 <Valodim> I actually knew that from my 5 years of latin in school :P
16:29:52 <unenough> like crap maybe
16:30:04 <Sizur> a controlled substance, do your homework only after party
16:30:12 <unenough> Valodim, i apologize. this is a web 2.0 world now.
16:30:26 <Valodim> aw :(
16:30:27 <oerjan> :t listArray
16:30:29 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
16:30:48 <unenough> Valodim and i hate it.
16:30:55 <Time`s_Witness> can anyone tell me why... http://hpaste.org/5142 do i have this error.. :S
16:31:00 <oerjan> nolrai: calculate the range and use listArray
16:31:03 <Valodim> absolutely
16:32:08 <unenough> Valodim but virus IS latin, no?
16:32:20 <Valodim> not sure
16:32:24 <Valodim> sounds greek
16:32:51 <Valodim> on the other hand, the plural is virii
16:32:53 <Cale> syntax [ad. F. syntaxe, {dag}sintaxe, ad. late L. syntaxis, a. Gr.  SYNTAXIS.]
16:33:01 <mauke> Valodim: NO.
16:33:13 <EvilTerran> Valodim, that's hypercorrection, iirc
16:33:37 <EvilTerran> http://en.wikipedia.org/wiki/Plural_of_virus
16:33:37 <lambdabot> Title: Plural of virus - Wikipedia, the free encyclopedia
16:33:38 <Valodim> dude, yes, if it's o declination (which I think it is), the plural is virii
16:33:41 <nolrai> :t Data.Array.ListArray
16:33:42 <lambdabot>     Not in scope: data constructor `Data.Array.ListArray'
16:33:44 <mauke> Valodim: wrong
16:33:46 <LoganCapaldo> i recall reading soewheres a convincing argument that even if virus _was_ latin, ti's plural wou;d not be virii
16:33:46 <nolrai> :t Data.Array.listArray
16:33:47 <Cale> And it's an incorrect hypercorrection too.
16:33:47 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
16:33:48 <Valodim> reading
16:33:53 <mauke> virus is latin. it has no plural because it's a mass noun (meaning poison)
16:33:58 <Cale> virus is from Latin.
16:34:03 <ddarius> It doesn't really matter.
16:34:05 <EvilTerran> Cale, it's not hypercorrection if it's right (as i understand it)...
16:34:08 <Sizur> how about a plural of MS mouse?
16:34:14 <mauke> if it was o declination, the plural would be viri
16:34:15 <unenough> virus: Etymology:
16:34:15 <unenough>     Latin, venom, poisonous emanation; akin to Greek ios poison, Sanskrit visa; in senses 2 & 4, from New Latin, from Latin
16:34:18 * oerjan recalls virus was one of the exceptions in 2. decl. - it's neuter despite ending in -us
16:34:27 <EvilTerran> mauke, doesn't that mean "men", tho?
16:34:32 <mauke> EvilTerran: exactly
16:34:34 <Valodim> that's vir / viri
16:34:53 <Cale> EvilTerran: Well, it's still often silly to use the Latin plural even when it does exist.
16:34:54 <mauke> latin has no -ii suffix
16:34:54 <Valodim> ah, it's one of them plural words...
16:35:28 <Cale> [a. L. v{imac}rus slimy liquid, poison, offensive odour or taste. Hence also F., Sp., Pg. virus.
16:35:28 <Cale>   In Lanfranc's Cirurgie (c 1400) 77 the word, explained as a thin venomy quitter, is merely taken over from the Latin text.]
16:35:40 * LoganCapaldo puts some virii in some boxen
16:35:48 <Valodim> but it has words that end with -ii
16:35:56 <mauke> Valodim: no
16:35:57 <ddarius> LoganCapaldo has the right idea
16:36:05 <EvilTerran> > array ((0,0),(2,8)) . concat . zipWith zip [[(x,y) | y <- [0..]] | x <- [0..]] $ ["foobarbaz","eekackook","alphabeta"]
16:36:08 <Valodim> are you sure?
16:36:09 <lambdabot>  array ((0,0),(2,8)) [((0,0),'f'),((0,1),'o'),((0,2),'o'),((0,3),'b'),((0,4),...
16:36:19 <mauke> filii ends with -i, not -ii
16:36:25 <mauke> DEATH TO THE INFIDELS
16:36:39 <Valodim> I'm pretty sure you're wrong, at least it's pronounced "filii"
16:36:48 <unenough> hehe there is a whole wikipedia entry about it. http://en.wikipedia.org/wiki/Plural_of_virus
16:36:48 <lambdabot> Title: Plural of virus - Wikipedia, the free encyclopedia
16:36:54 <EvilTerran> PEOPLE CALLED ROMANES THEY GO THE HOUSE!
16:36:55 <mauke> yes, but only because the singular is filius
16:37:11 <Valodim> so?
16:37:14 <mauke> -us becomes -i, thus the double i
16:37:15 <nolrai> :t Data.Array.listArray
16:37:16 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
16:37:20 <Valodim> yeah, so?
16:37:27 <Valodim> [01:35] Valodim: but it has words that end with -ii
16:37:39 <Valodim> the "but" acknowledges your "there is no suffix"
16:37:48 <mauke> so the first i is not part of the end :-)
16:37:56 <Valodim> it's not part of the suffix
16:37:58 <Valodim> but it's part of the end :P
16:38:07 <mauke> grr. you win this round!
16:38:08 <EvilTerran> THE END IS NIGH
16:38:15 <Valodim> lambdabot would agree :P
16:38:25 <EvilTerran> @vixen who's side are you on, anyway?
16:38:26 <lambdabot> i truely am
16:38:30 <unenough> is the pronunciation different for virii and viri?
16:38:32 <EvilTerran> @vixen what?
16:38:32 <lambdabot> i dunno...
16:38:40 <EvilTerran> @yow
16:38:40 <lambdabot> Yow!  Am I having fun yet?
16:38:56 <mauke> unenough: yes (at least when I pronounce them)
16:39:12 <l_kalman> sorry, i'm a newbie, can i have a technical question?
16:39:18 <EvilTerran> @quote meta-ask
16:39:20 <lambdabot> meta-ask says: Don't ask to ask, just ask!
16:39:22 <mauke> no, questions are disallowed here
16:39:25 <Valodim> go to #haskell-blah for technical questions
16:39:26 <LoganCapaldo> vir two is totally different than vir one
16:39:44 <EvilTerran> this is a latin channel
16:39:49 <LoganCapaldo> pronunciation wise
16:39:54 <Valodim> aetas/sexus/locus?
16:39:57 <EvilTerran> six are two?
16:40:04 <l_kalman> i have to copy four lines of code first
16:40:06 <EvilTerran> six @arr one?
16:40:11 <l_kalman> it's about method inheritance
16:40:13 <EvilTerran> @paste
16:40:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:40:41 <mauke> the world is unenough
16:40:44 <Sizur> let's get back to Functor the Applicative Monoid!
16:41:11 <mauke> instance Avenger Birwhale
16:41:29 <Time`s_Witness> can anyone tell me why... http://hpaste.org/5142 do i have this error.. :S probably ... easy to find.. however i seem not to be able |:
16:42:26 <oerjan> Time`s_Witness: i've been looking
16:42:27 <Sizur> Time`s_Witness: are you using something else from ghc?
16:42:38 <Cale> Time`s_Witness: How is the Contacts type defined?
16:42:41 <jfredett> yah, looks like he's using hugs
16:42:46 <Sizur> duh it says right htere Hugs
16:42:53 <Valodim> haha
16:43:00 <oerjan> from the type declaration of mySFilter, f would have a String second argument
16:43:03 <Cale> Time`s_Witness: Is it  type Contacts = [(String, [String])] ?
16:43:09 <Time`s_Witness> im using hugs, Contacts is type Contacts = [Contact]  , and Contact is type Contact = (String, [String])
16:43:15 <Cale> Time`s_Witness: okay
16:43:16 <jfredett> right
16:43:18 <Time`s_Witness> *winhugs, im using winhugs
16:43:34 <Cale> Time`s_Witness: well, note that the type of  contacts is Contacts
16:43:38 <oerjan> Time`s_Witness: i think either f is missing some arguments or the type declaration is wrong
16:43:41 <jfredett> so Contacts has type [(String, [String])] by substitution, right Time`s_Witness?
16:43:54 <Time`s_Witness> right jfredett
16:44:03 <Cale> Time`s_Witness: Also note that f :: (String -> Contact -> Bool) -> String -> Contacts -> [String]
16:44:27 <Cale> Time`s_Witness: You're passing it something of type Contacts as its second parameter, where you're supposed to be passing a String
16:44:30 <Time`s_Witness> i think some type is wrong somewhere too.. cant find out .. which though.. they all seem the good types
16:44:40 <Cale> Time`s_Witness: I'm telling you where the problem is.
16:44:54 <Time`s_Witness> hmm.. checking, Cale
16:45:11 <Cale> Time`s_Witness: The type of f doesn't admit a second parameter of type Contacts, but that's what you're passing it.
16:45:24 <jfredett> also, it's spelt "analyze". :)
16:45:31 <Cale> analyse :)
16:45:36 <ddarius> z!
16:45:36 <mauke> analize
16:45:40 <ivanm> heh
16:45:42 <jfredett> :)
16:45:46 <ivanm> analy{s,z}e
16:45:50 <jfredett> @google analyze
16:45:51 <lambdabot> http://www.imdb.com/title/tt0122933/
16:45:51 <lambdabot> Title: Analyze This (1999)
16:45:55 <EvilTerran> analfdgdoxvlvlffffffffff
16:45:57 <jfredett> :P
16:46:02 <EvilTerran> don't be so anal
16:46:05 <EvilTerran> ytical
16:46:16 <l_kalman> so i have "class Node a where explicit :: a -> Bool"
16:46:19 <Time`s_Witness> Cale, but f needs as arguments a String and a Contacts.. im giving x and "allcontacts".. x is String.. allcontacts... is Contacts... :S
16:46:28 <l_kalman> and "class ( Node a ) => Box a where explicit _ = False"
16:46:34 <EvilTerran> @paste -- l_kalman, if you've got a bit of code, just put it here
16:46:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:46:43 <mauke> Time`s_Witness: no, f needs a function, a string and a contacts
16:46:46 <mauke> it takes three arguments
16:46:47 <l_kalman> and ghc says, `explicit' is not a (visible) method of class `Box'
16:46:55 <ddarius> l_kalman: Haskell classes aren't OO classes.
16:47:09 <l_kalman> so what?
16:47:10 <Cale> Time`s_Witness: That's not what you've told the Haskell compiler about the type of f
16:47:22 <EvilTerran> l_kalman, so there's no such thing as inheritance
16:47:24 <ddarius> l_kalman: You don't "override" methods in type classes.
16:47:27 <Time`s_Witness> ahhh yea i forgot that i had to pass a function as argument :|
16:47:39 <Cale> Time`s_Witness: According to your type signature, you've given f the type ((String -> Contact -> Bool) -> String -> Contacts -> [String])
16:47:51 <l_kalman> ddarius: the class 'Node' does not define it, it only declares it
16:48:07 <ddarius> l_kalman: And the -instances- define it, not "subclasses".
16:48:15 <EvilTerran> l_kalman, methods declared in one class can only be given values in that class definition, or an instance of that class
16:48:28 <Time`s_Witness> yea... :S Yea i completely forgot the function-argument.. thanks guys :D (i just wish to be like you when older :X lol)
16:48:45 <EvilTerran> l_kalman, you could (with an extension (UndecidableInstances)) create an instance Box a => Node a where explicit _ = False
16:49:21 <Cale> l_kalman: Classes don't normally define implementations of their methods, and if they do, they only do it as a convenience for those writing instances of the classes.
16:49:27 <EvilTerran> l_kalman, however, this would probably constitute an abuse of the type system. not that that's a bad thing, if Oleg's fame is anything to go by...
16:49:30 <Cale> (they're default implementations)
16:49:48 <EvilTerran> s/a bad thing/necessarily &/
16:50:14 <l_kalman> Cale: ok, i see, thx
16:50:21 <DRMacIver> The level of traffic real world haskell is getting is quite funny :)
16:50:26 <DRMacIver> But also gratifying
16:51:38 <l_kalman> EvilTerran: that's clear but nowhere written in 98report or tutorials (or i'm really silly indeed)
16:51:40 <aFlag> DRMacIver, why funny?
16:51:52 <ddarius> DRMacIver: O'Reilly was and is expecting to make money.
16:52:06 <l_kalman> EvilTerran [i mean that methods can only be defined where they are declared or in instances]
16:52:35 <EvilTerran> "A class declaration (Section 4.3.1) introduces a new type class and the overloaded operations that must be supported by any type that is an instance of that class. An instance declaration (Section 4.3.2) declares that a type is an instance of a class and includes the definitions of the overloaded operations---called class methods---instantiated on the named type."
16:53:37 <EvilTerran> in both sentences, "the overloaded operations" refers to the same thing
16:53:57 <l_kalman> EvilTerran: ok, ok, but the negative part is not there (i.e., that this "subtypes" are unlike instances in this respect)
16:54:21 <l_kalman> EvilTerran: but i see now, i'm only explaining what misled me
16:54:26 <EvilTerran> yes, i see
16:55:50 <l_kalman> thanks a lot, bye
16:56:14 <Sizur> wow
16:56:44 <Cale> wow?
16:56:52 <ddarius> wow!
16:57:10 <dobblego> wow#
16:57:55 <Cin> zomg
16:58:00 <Sizur> who'll make a sine wave from wows?
16:58:07 <allbery_b> unsafeWow# ?
16:59:24 <Sizur> i think we are scaring people away
16:59:33 <ddarius> Again?
16:59:42 <Sizur> people?
16:59:57 <monochrom> unsafe@AskLambdaBot###
17:01:02 <oerjan> @users
17:01:03 <lambdabot> Maximum users seen in #haskell: 454, currently: 399 (87.9%), active: 20 (5.0%)
17:01:24 <Sizur> activity is good
17:01:51 <Sizur> thanks to typechecked typochecks
17:03:02 <LoganCapaldo> @abusers
17:03:02 <lambdabot> Maximum users seen in #haskell: 454, currently: 400 (88.1%), active: 20 (5.0%)
17:03:43 <LoganCapaldo> @lusers
17:03:44 <lambdabot> Maximum users seen in #haskell: 454, currently: 402 (88.5%), active: 20 (5.0%)
17:03:49 <LoganCapaldo> so insulting
17:03:58 <oerjan> @udders
17:03:59 <lambdabot> Maximum users seen in #haskell: 454, currently: 403 (88.8%), active: 20 (5.0%)
17:04:15 <Sizur> @ers
17:04:15 <lambdabot> Maybe you meant: arr oeis rc src url users vera
17:04:16 <glguy> @losers
17:04:16 <lambdabot> Maximum users seen in #haskell: 454, currently: 402 (88.5%), active: 21 (5.2%)
17:04:35 <Sizur> @eers
17:04:36 <lambdabot> Maybe you meant: oeis users vera
17:04:45 <oerjan> @fuses
17:04:46 <lambdabot> Maximum users seen in #haskell: 454, currently: 402 (88.5%), active: 21 (5.2%)
17:05:04 <Sizur> anyways. enough bedtime haskell. time to sleepy
17:05:04 <nolrai> @oeis
17:05:05 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:05:20 <oerjan> @oeis 1,2,many
17:05:21 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:05:29 <Cale> @oeis 1 1 2 3
17:05:29 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:05:29 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:05:54 <nolrai> @oeis 2 4 16
17:05:54 <lambdabot> Number of degree-n permutations of order dividing 4.
17:05:54 <lambdabot> [1,1,2,4,16,56,256,1072,6224,33616,218656,1326656,9893632,70186624,574017536,...
17:06:00 <Cale> @oeis 1 1 2 5 14
17:06:01 <lambdabot> Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called ...
17:06:01 <lambdabot> [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
17:06:16 <oerjan> @oeis 2 0 0 8
17:06:17 <lambdabot> Number of solutions to +- 1 +- 2 +- 3 +- ... +- n = 0.
17:06:17 <lambdabot> [1,0,0,2,2,0,0,8,14,0,0,70,124,0,0,722,1314,0,0,8220,15272,0,0,99820,187692,0...
17:06:27 <nolrai> @oeis 10 5 23
17:06:28 <lambdabot> Number of numbers <= n whose prime factors are a subset of prime factors of n.
17:06:28 <lambdabot> [1,2,2,3,2,5,2,4,3,6,2,8,2,6,5,5,2,10,2,8,5,7,2,11,3,7,4,8,2,18,2,6,6,8,5,14,...
17:06:57 <davidL> @. oeis run fix ((1:) . scanl (+) 1)
17:06:59 <lambdabot> Sequence not found. BOB says:  You seem to have forgotten your passwd, enter ...
17:07:01 <nolrai> @oeis 1 1 1 100
17:07:01 <Sizur> @oeis 11 23 58
17:07:01 <lambdabot> Let f(n) = largest number formed using digits of n, g(n) = smallest number fo...
17:07:01 <lambdabot> [10,1,1,2,2,3,3,4,4,4,10,1,1,1,1,2,2,2,2,3,10,2,1,1,1,1,1,1,2,2,10,2,1,1,1,1,...
17:07:01 <lambdabot> Write each natural integer on a single label. Put the labels in numerical ord...
17:07:02 <lambdabot> [0,11,23,58,1,3,2,13,4,5,589,14,42,33,37,7,6,10,9,8,71,59,72,584,41,81,67,65,...
17:07:20 <ddarius> Lord have his grilled cheese
17:07:29 <kilimanjaro> it might be a good idea to make a #lambdabot channel
17:08:03 <nolrai> that what msg is for.
17:08:20 <Sizur> well you can get a private room with lambdabot and have your way with her.
17:08:23 <kilimanjaro> I meant for people who want to publically interact with lambabot
17:08:36 <glguy> we have that
17:08:39 <glguy> it's call #haskell
17:08:41 <glguy> called#
17:08:41 <kilimanjaro> Sizur, how's the pimp game going?
17:08:45 <davidL> @vixen-on
17:08:46 <lambdabot> Not enough privileges
17:09:02 <oerjan> @help vixen-on
17:09:02 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
17:09:05 <Sizur> kilimanjaro: eh? everybody hears what he wants to hear i guess
17:09:16 <Cale> > let f 0 = 0; f 1 = 1; f n = n * (f (n-1) + f (n-2)) in map f [0..10]
17:09:21 <lambdabot>  [0,1,2,9,44,265,1854,14833,133496,1334961,14684570]
17:09:30 <Cale> @oeis 0,1,2,9,44
17:09:31 <lambdabot> Subfactorial or rencontres numbers, or derangements: number of permutations o...
17:09:31 <lambdabot> [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,320...
17:09:44 <ddarius> #haskell-overflow
17:10:21 <EvilTerran> @vixen do you feel used?
17:10:22 <lambdabot> i do occassionally, i guess
17:10:42 <ddarius> An honest answer.
17:10:43 <ivanm> EvilTerran: that bored that you're chatting up the bot?
17:11:06 <Cale> > let f 0 = 0; f 1 = 1; f n = n * f (n-1) + (n-1) * f (n-2) in map f [0..10]
17:11:08 <lambdabot>  [0,1,2,8,38,222,1522,11986,106542,1054766,11506538]
17:11:14 <EvilTerran> @vixen that liar ivanm's claiming you're a bot
17:11:14 <lambdabot> no, why? do i seem "botty"?
17:11:16 <Cale> @oeis 0,1,2,8,38,222
17:11:17 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:11:25 <EvilTerran> @vixen i think he's jealous
17:11:25 <lambdabot> you think so, eh?
17:11:36 <ivanm> heh
17:11:40 <Sizur> nice
17:12:40 <Sizur> imagination always associates a persona
17:13:31 <Sizur> no matter how dumb you make AI, it can still seem smart (lesson from RTS games)
17:13:58 <davidL> @. oeis run concat . intersperse "," . map show . take 10 $ fix ((1:) . scanl (+) 1)
17:13:59 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:13:59 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:14:07 <nn64> hi all
17:14:12 <Cale> hello :)
17:14:18 <EvilTerran> the impression i get from RTSs is that bots tend to get pretty predictable after you've been playing a while
17:14:23 <Sizur> hi nn64
17:14:32 <nn64> I added a Haskell forum to linux main.net to you can use it.
17:14:39 <EvilTerran> but maybe that's because the only RTSs i play with any regularity are approaching 10yr old
17:14:40 <nn64> in piticular you samB
17:15:05 <LoganCapaldo> lambdabot is never predictable
17:15:17 <nn64> SamB, ping
17:15:18 <dobblego> lambdabot loses state all the time
17:15:23 <EvilTerran> what's wrong with haskell-cafe?
17:15:50 <shepheb> @vixen where are your socks?
17:15:50 <lambdabot> nevermind about that
17:15:52 <glen_quagmire> email is so web0.8
17:16:11 <EvilTerran> @vixen what about your towel?
17:16:11 <lambdabot> what about me?
17:16:48 <Sizur> @vixen show me your dictionary please.
17:16:48 <lambdabot> keep asking
17:16:57 <glen_quagmire> @vixen you does likes chocolate rain.
17:16:58 <lambdabot> i'd say i like
17:17:31 <davidL> @vixen what is your email address?
17:17:31 <lambdabot> vixenlove@hotmail.com
17:17:37 <Sizur> hahaha
17:17:41 <monochrom> Nothing wrong with haskell-cafe.
17:18:04 <Cale> nn64: The linuxmain site seems kind of barren as of yet...
17:18:16 <Sizur> @vixen will you give me your phone number?
17:18:16 <lambdabot> don't be so demanding! why don't you give me yours?
17:18:29 <Cale> nn64: Also, the Development forum's name seems to be misspelled :)
17:18:31 <monochrom> Mine is 123-123-1230
17:18:55 <nn64> Cale, yes it's fairly new
17:19:01 <EvilTerran> @oeis 123 123 1230
17:19:04 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:19:06 <glguy> monochrom: your area code can't be the same as your exchange!
17:19:10 <glguy> call the phone company!
17:19:15 <monochrom> Oh, oops.
17:19:18 <nn64> Cale, I really looking for users
17:19:23 <nn64> :)
17:19:41 <ddarius> nn64: I doubt there is much demand for another forum.
17:20:10 <glguy> if a need for something like that arose, someone in the community would fill it
17:20:43 <EvilTerran> @oeis 0 1 2
17:20:43 <lambdabot> pi(n), the number of primes <= n. Sometimes called PrimePi(n) to distinguish ...
17:20:43 <lambdabot> [0,1,2,2,3,3,4,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,9,9,9,10,10,11,11,11,11,11...
17:20:56 <glen_quagmire> what is oeis?
17:21:04 <nn64> Yes I might as well add it now as I blog threw to over 100 admin settings for various things you can do in the site when loged in
17:21:04 <mauke> @go oeis
17:21:05 <lambdabot> http://www.research.att.com/~njas/sequences/
17:21:05 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
17:21:09 <EvilTerran> that's so much more interesting than "N" :P
17:21:15 <glen_quagmire> oh
17:22:02 <oerjan> @oeis 42 42 42 42
17:22:03 <lambdabot> Square root of largest square dividing n-th central binomial coefficient.
17:22:03 <lambdabot> [1,1,1,1,1,2,1,1,3,6,1,2,2,2,3,3,1,2,1,2,2,2,1,2,10,10,30,30,6,12,3,3,3,6,5,1...
17:22:10 <nn64> nn = Nathaniel Nelson ; EvilTerran
17:22:27 <EvilTerran> okay
17:24:13 <nn64> Do you Have any idea what I can add to the sight; I sugest you give coments after you registered because the registered user has the most access to the site
17:25:11 <Sizur> @vixen do you want to join nn64's forum?
17:25:11 <lambdabot> sure, i want to plenty
17:25:32 <mauke> @vixen how I mine for fish?
17:25:33 <lambdabot> however you want
17:25:39 <Sizur> lol
17:25:51 <nn64> lol
17:26:08 <hpaste>  dejones pasted "Convert type Char to Word8?" at http://hpaste.org/5143
17:27:04 <dejones_> I am having issues with converting '\n' to Word8 for a the split() function... see paste above.
17:27:30 <EvilTerran> dejones_, maybe use Data.ByteString.Char8?
17:27:56 <dejones_> EvilTerran: how can I do that in my code...?  :/
17:27:58 <EvilTerran> ?hoogle split
17:27:59 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
17:27:59 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
17:27:59 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
17:28:02 <EvilTerran> ?hoogle+
17:28:02 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
17:28:02 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
17:28:02 <lambdabot> System.Random.split :: RandomGen g => g -> (g, g)
17:28:04 <EvilTerran> hm.
17:28:14 <EvilTerran> dejones_, just import that module instead of Data.ByteString
17:28:24 <LoganCapaldo> @instances Integral
17:28:26 <lambdabot> Int, Integer
17:28:33 <EvilTerran> dejones_, it's got pretty much the same interface, except it uses Char instead of Word8
17:28:40 <LoganCapaldo> @instances-importing Data.Word Integral
17:28:41 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
17:28:45 <mauke> dejones_: let delim = toEnum $ fromEnum '\n'
17:28:58 <LoganCapaldo> @instances-importing Data.Char Integral
17:29:00 <lambdabot> Int, Integer
17:29:15 <EvilTerran> dejones_, which makes it more suitable for when you want a better version of String rather than a better version of [Word8] :)
17:29:29 <dejones_> EvilTerran: yah, but what if I didn't have the other split() available?  How would I convert from Char to Word8?
17:29:29 <EvilTerran> dejones_, alternatively, as mauke says...
17:29:35 <EvilTerran> ?type toEnum.fromEnum
17:29:35 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
17:29:55 <EvilTerran> > toEnum.fromEnum $ '\n' :: Word8
17:29:56 <lambdabot>  10
17:30:19 <dejones_> ?src toEnum
17:30:20 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:30:26 <EvilTerran> it's a class method
17:30:29 <EvilTerran> ?src Enum
17:30:29 <dejones_> hmm
17:30:29 <lambdabot> class  Enum a   where
17:30:29 <lambdabot>     succ                     :: a -> a
17:30:29 <lambdabot>     pred                     :: a -> a
17:30:29 <lambdabot>     toEnum                   :: Int -> a
17:30:29 <lambdabot>     fromEnum                 :: a -> Int
17:30:31 <lambdabot> [3 @more lines]
17:30:34 <EvilTerran> @more
17:30:35 <lambdabot>     enumFrom                 :: a -> [a]
17:30:37 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:30:39 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:30:53 <Sizur> @vixen good night
17:30:53 <lambdabot> good good
17:30:56 <EvilTerran> ?src Char toEnum
17:30:56 <lambdabot> Source not found. Maybe you made a typo?
17:31:00 <EvilTerran> ?src Bool toEnum
17:31:01 <lambdabot> Source not found. My pet ferret can type better than you!
17:31:05 <dejones_> lol
17:31:07 <EvilTerran> hrmph.
17:31:33 <EvilTerran> Char'll be too complicated, Bool'll be derived...
17:32:25 * dejones_ is confused.
17:33:14 <Cale> dejones_: what's up?
17:33:16 * nn64 is playing with menu blocks
17:33:32 <dejones_> hey Cale.  :)
17:33:36 <Cale> hi
17:33:55 <dejones_> I was trying to convert a Char to Word8, see my hpaste: http://hpaste.org/5143?lines=true
17:34:13 <glguy> nn64: did you have any Haskell questions?
17:34:31 <dejones_> I guess I'm frustrated... converting a type should not be so hard, heh.
17:35:13 <bos> dejones_: there's a pack function, call B.pack or B.unpack as you need.
17:35:38 <glguy> dejones_: it is "hard" to convert because it is a lossy conversion
17:35:43 <bos> also, you're mixing up your types like crazy.
17:36:27 <dejones_> bos, how am I mixing up my types?
17:36:46 <atp> shouldn't fromIntegral work fine?
17:36:49 <bos> putStrLn expects a String, you're passing a ByteString
17:37:01 <bos> B.split delim expects a ByteString, you're passing a String
17:37:07 <nn64> How is Haskell actually structured I never rally could figure that out I'm so used to C
17:37:25 <bos> nn64: try reading a tutorial.
17:37:40 <dejones_> bos: hmm, haven't got to that line yet ;) the split() isn't working...
17:38:17 <EvilTerran> dejones_, using Data.ByteString.Char8 really would make things easier
17:38:26 <Cale> nn64: Programs are sets of definitions of functions and values, essentially.
17:38:32 <atp> EvilTerran: i don't think he needs to
17:38:35 <dejones_> EvilTerran: how would I use it?
17:38:50 <atp> EvilTerran: he's just getting errors because he hasn't figured out that String and ByteString aren't the same
17:38:57 <dejones_> I was only trying out this example from the ghc6 library for split() ---  split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
17:39:02 <EvilTerran> [01:28] <EvilTerran> dejones_, just import that module instead of Data.ByteString
17:39:10 <dejones_> I just expected it to work.  ;)
17:39:27 <atp> dejones_: when you write haskell, you have to pay attention to types
17:39:37 <Tac-Tics> Would it be a mistake to say that Haskell doesn't have "closures"?
17:39:41 <atp> @t ByteString.split
17:39:41 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:39:47 <atp> >t ByteString.split
17:39:49 <gwern> what extension do you need to use the function 'unsafeCoerce#'? If I omit the -fglasgow-exts OPTIONS flag, it fails with syntax errors where it is written and I can't figure out which of http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html is the right one
17:39:50 <lambdabot> http://tinyurl.com/2xjyqs
17:39:51 <atp> hm
17:39:54 <dejones_> atp: yah.. I'm used to programming in C.  :/
17:39:55 <Tac-Tics> (since closures close over addresses whereas there are no addresses for haskell variables)
17:39:59 <oerjan> i thought dejones_ was trying to use the new overloaded string literals...
17:40:00 <shepheb> @help thank
17:40:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:40:05 <shepheb> @help @thank
17:40:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:40:17 <atp> :t ByteString.split
17:40:18 <lambdabot> Couldn't find qualified module.
17:40:26 <dejones_> oerjan: I just want to get this simple example to work:  split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
17:40:27 <dejones_> heh
17:40:28 <atp> :t Data.ByteString.Split
17:40:29 <lambdabot>     Not in scope: data constructor `Data.ByteString.Split'
17:40:35 <atp> :t Data.ByteString.split
17:40:36 <lambdabot> Word8 -> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
17:40:43 <atp> look at that type
17:41:19 <atp> your first argument is a Word8; no problems there.  the second argument is not a String
17:41:20 <EvilTerran> :t Data.ByteString.Char8.split
17:41:20 <lambdabot> Char -> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
17:41:35 <Saizan> Tac-Tics: foo x xs = let bar y = y > x in filter bar xs -- this is implemented via closures i think
17:41:38 <EvilTerran> atp, he may be thinking of the overloaded strings extension
17:41:49 <atp> EvilTerran: he's a newbie, he's just confused
17:42:07 <Tac-Tics> Saizan: yes, but since the values are not mutable in Haskell, do you still call them closures?
17:42:15 <atp> dejones_: Haskell doesn't do implicit casts like C does
17:42:19 <EvilTerran> <dejones_> I was only trying out this example from the ghc6 library for split()  -- the example may be assuming overloaded strings
17:42:33 <atp> EvilTerran: the example doesn't use bytestring at all
17:42:43 <EvilTerran> okay then. i give up.
17:42:45 <dejones_> atp: how does the example work?  :(
17:42:46 <dejones_> heh
17:42:48 <EvilTerran> \(O.o)/
17:43:15 <Saizan> atp: that example is in the bytestring doc, and uses list syntax to be concise
17:43:15 <atp> dejones_: is there a reason you are using ByteString instead of String in the first place?
17:43:23 <atp> Saizan: oh?
17:43:30 <atp> Saizan: well then in that case, I take back what I said
17:43:35 <dejones_> atp: no reason at all...  I just copied the example, so I didn't understand why it wouldn't work.
17:43:47 <dejones_> can you tell me why the example doesn't work?
17:44:02 <EvilTerran> from what Saizan's saying, it's pseudocode
17:44:03 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3Asplit
17:44:04 <lambdabot> http://tinyurl.com/39be59
17:44:13 <atp> dejones_: well, to hear Saizan tell it, it's because the documentation assumes you know enough about how Haskell works to fill in the details yourself
17:44:17 <Saizan> dejones_: because the example uses pseudo syntax
17:44:27 <dejones_> hahah
17:44:32 <atp> dejones_: see, ByteString is not Haskell's normal String type.
17:44:33 <dejones_> those bastards
17:44:51 <Saizan> it uses the syntax for String even if it's using ByteString
17:44:54 <dejones_> "pseudo" haskell syntax, evil evil.
17:45:05 * EvilTerran wonders how many of the ByteString implementers are in here at the moment
17:45:13 <dejones_> lol
17:45:15 <EvilTerran> "Original GHC implementation by Bryan O'Sullivan. Rewritten to use UArray by Simon Marlow. Rewritten to support slices and use ForeignPtr by David Roundy. Polished and extended by Don Stewart."
17:45:21 <EvilTerran> well, the last of those is dons
17:45:26 <dejones_> ahh.
17:45:30 <atp> dejones_: basically, ByteString is an optimization
17:45:42 <dejones_> ok, so how can I actually get it to -work- ?
17:45:44 <atp> dejones_: it's very useful, but before writing code that uses it, I would learn normal Haskell first
17:46:07 <atp> dejones_: you need to use B.pack to turn something that's a String (like "hello") into a ByteString
17:46:11 <dejones_> atp: well, I've been going through the libraries and trying them out, and then trying to rewrite them to learn Haskell.
17:46:30 <EvilTerran> dejones_, ah, see, there's your problem; ByteString isn't pure haskell
17:46:30 <dejones_> thus, I got stuck when the example didn't work for split().
17:46:34 <dejones_> haha
17:46:46 <dejones_> Haskell hates me already... I'm unpure!  ;)
17:46:49 <oerjan> EvilTerran: the first two are bos and JaffaCake, i think
17:46:58 <atp> dejones_: ok, first off, from a stylistic perspective, we don't say split(), we just say split
17:47:03 <EvilTerran> dejones_, skip over that bit; you're only at B, there's plenty more modules to look at
17:47:05 <EvilTerran> ;)
17:47:06 <atp> dejones_: since this is haskell and not java or C
17:47:08 <dejones_> atp: sorry, habit.
17:47:27 <Tac-Tics> :t split
17:47:29 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
17:47:30 <atp> dejones_: don't apologize, i'm just saying
17:47:31 <dejones_> EvilTerran: I was trying to start simple... split seemed easy.  ;)
17:47:35 <Cale> split() would be split applied to an empty tuple :)
17:47:35 <dejones_> atp: thanks.
17:47:36 <bos> the first two what?
17:47:45 <bos> oh, yes.
17:47:46 <dejones_> Cale: ha, n1
17:47:54 <bos> i wrote PackedString 14 years ago.
17:47:56 * EvilTerran sometimes puts parentheses around the outside of a function called (and) or whatever, to make things clearer
17:47:56 <Saizan> dejones_: define split for lists :)
17:48:11 <nolrai> > do {n <- [1,2,3]; [n, 2*n]}
17:48:13 <lambdabot>  [1,2,2,4,3,6]
17:48:31 <EvilTerran> dejones_, listen to Saizan; you don't need a working version to write your own :)
17:48:53 <dejones_> Saizan: hmm... well, for practical purposes, I would eventually like split for strings.
17:48:58 <EvilTerran> first off -- type signature?
17:49:01 <glguy> EvilTerran: you have to define it for you unit test before you can actually define it
17:49:14 <oerjan> gwern: my impression from browsing a part of the ghc user guide is that the extension to enable # in identifiers doesn't have a separate flag other than -fglasgow-exts
17:49:19 <EvilTerran> glguy, well, i'd say you'd define it in terms of a load of identities
17:49:27 <EvilTerran> oerjan, i think it's called MagicHash or something
17:49:37 <gwern> oerjan: gack! could you link me?
17:49:45 <Saizan> dejones_: normal String is just a list of Char in haskell
17:49:47 <oerjan> er it was a while ago
17:50:00 <dejones_> Saizan: oh.
17:50:09 <oerjan> you might check out what EvilTerran said first, with the --supported-languages option
17:50:18 <Saizan> i.e. type String = [Char]
17:50:27 <gwern> oerjan: oh. well thanks anyway
17:50:28 <EvilTerran> oerjan, gwern; yeah, according to my copy of the docs for L.H.Extension, MagicHash it is
17:50:54 <Cale> haha
17:50:54 <EvilTerran> dejones_, so, about that type signature?
17:51:03 <Cale> What a great name for a language extension :)
17:51:03 <gwern> EvilTerran: oh really? thanks!
17:51:07 * gwern will try that
17:51:07 <EvilTerran> :)
17:51:16 <dejones_> EvilTerran: type signature?
17:51:16 * EvilTerran looks at Cale
17:51:22 * EvilTerran looks at the extension name
17:51:31 <EvilTerran> ... IIII see what you did there :D
17:51:49 <EvilTerran> dejones_, "split :: <somethingorother>"
17:51:59 <EvilTerran> dejones_, what is <somethingorother>?
17:52:17 <dejones_> EvilTerran: the type?
17:52:31 <EvilTerran> ...yes...
17:52:38 <EvilTerran> in this case, though; which type do you want?
17:52:48 <dejones_> String?
17:52:56 <EvilTerran> er, no.
17:53:01 <hpaste>  gwern pasted "I see this error all over the place - what extension is it?" at http://hpaste.org/5144
17:53:03 <EvilTerran> split is a function, right?
17:53:07 <dejones_> yes
17:53:13 * oerjan takes comfort in that his providing wrong information caused someone else to give the right one :)
17:53:17 <dejones_> split :: Word8 -> ByteString -> [ByteString]
17:53:27 <EvilTerran> -.-
17:53:30 <EvilTerran> that's for ByteStrings
17:53:34 <EvilTerran> we're working with Strings, here
17:53:41 <dejones_> ok, good.  :)
17:53:49 <allbery_b> gwern: ExistentialTypes, IIRC
17:54:12 <EvilTerran> dejones_, what parameters will (split) take, and what will it return?
17:54:45 <dejones_> EvilTerran: split :: Char -> String -> [String]  ?
17:54:54 <EvilTerran> that seems sensible, yes
17:54:58 <gwern> allbery_b: there's an ExistentialQuantification
17:55:15 <gwern> and it doesn't seem to help
17:55:23 <allbery_b> hm
17:55:57 <allbery_b> ExistentialQuantification should be correct
17:56:08 <EvilTerran> dejones_, okay, so let's take a look at that string parameter
17:56:16 <dejones_> EvilTerran: how do I declare a String then?
17:56:20 <dejones_> :/
17:56:22 <EvilTerran> ... never mind that now.
17:56:25 <dejones_> ok
17:56:41 <EvilTerran> we want to break up this string, right? so that involves looking at the shape of the string
17:56:44 <oerjan> gwern: it seems to be inside the constructor, so it would be Rank2Types i think
17:56:50 <EvilTerran> strings are lists; lists can be two different shapes
17:56:51 <gwern> allbery_b: should be, perhaps, but it errors just the same
17:56:54 <EvilTerran> they can be empty []
17:57:13 <EvilTerran> or they can be an element "cons'ed" onto the left of another list (x:xs)
17:57:16 <oerjan> existentials have the forall outside
17:57:32 <EvilTerran> (":" is pronounced "cons")
17:57:35 <dejones_> EvilTerran: right, so we define two versions of split... split Char [] = ''
17:57:38 <dejones_> something like that
17:57:43 <gwern> yes, it was Rank2Types
17:57:51 <EvilTerran> well, yes, except you want that first parameter to be a variable, not a type
17:58:00 <EvilTerran> so. split ch [] = ???
17:58:04 <dejones_> EvilTerran: a split for the recursive base case and a split for iteration.
17:58:14 <EvilTerran> ... pretty much, yeah.
17:58:54 <dejones_> ok
17:59:21 <EvilTerran> so. what do you get when you split an empty list?
17:59:29 <dejones_> []
17:59:30 <dejones_> empty list?
17:59:48 <glen_quagmire> > split []
17:59:51 <lambdabot>   add an instance declaration for (RandomGen [a])
17:59:51 <lambdabot>     In the expression: spli...
17:59:53 <EvilTerran> i guess you could
18:00:00 <glen_quagmire> :t split
18:00:01 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:00:16 <dejones_> EvilTerran: well, empty string, I guess
18:00:17 <EvilTerran> dejones_, alternatively, you could get [[]]
18:00:20 <dejones_> not empty list
18:00:22 <dejones_> ;)
18:00:23 <EvilTerran> (or [""])
18:00:27 <dejones_> yeah, [""]
18:00:37 <EvilTerran> (which is very very different from just "")
18:00:58 <dejones_> EvilTerran: "" is a Char, and [""] is empty String?
18:01:04 <EvilTerran> '' is a char
18:01:12 <EvilTerran> actually, it's invalid. but never mind that.
18:01:16 <EvilTerran> "" is an empty string
18:01:16 <dejones_> lol
18:01:26 <EvilTerran> [""] is a list *containing* only the empty string
18:01:31 <jcreigh> dejones_: "" is [Char], [""] is [[Char]] or [String] (String = [Char])
18:02:05 <dejones_> EvilTerran, jcreigh: thanks, that helps a lot.  :
18:02:05 <dejones_> :)
18:02:23 <gwern> yi uses a lot of haskell extensions. I think I'm up to 17 now
18:03:23 <Cale> :t ''
18:03:24 <lambdabot> lexical error in string/character literal at character '\''
18:03:26 <EvilTerran> dejones_, but anyway... think about this; if the list you're splitting has, say, 3 instances of the separator, you'll get 4 results, right?
18:03:27 <Cale> :t 'a'
18:03:27 <lambdabot> Char
18:03:32 <Cale> :t "a"
18:03:32 <lambdabot> [Char]
18:03:40 <EvilTerran> dejones_, and, in general, if you have (n) separators, you'll get (n+1) results
18:03:42 <dejones_> lol
18:03:43 <Cale> :t ""
18:03:43 <lambdabot> [Char]
18:03:48 <glen_quagmire> String is aliased to [Char]
18:03:50 <dejones_> Cale: that is evil of Haskell, haha
18:04:07 <EvilTerran> dejones_, does that make sense?
18:04:07 <dejones_> but, I guess it does make sense and allows for the type inference.
18:04:09 <dejones_> yes.
18:04:15 <Cale> Single and double quotes mean different things in a lot of languages.
18:04:22 <dejones_> Cale, yea
18:04:28 <dejones_> EvilTerran: yes, it makes sense.
18:04:56 <EvilTerran> so, if you have 0 separators (and you do if you're splitting the empty list), you'll have to get 1 result!
18:05:23 <dejones_> :)
18:05:46 <EvilTerran> and the only 1 result that would make sense is the empty string; but we're returning a list of results, as there might be more than one, so we'll have to return a single-item list containing only your one result
18:06:35 <EvilTerran> (to look at it another way, we're returning a [String], so we can't just return ""; the type's wrong)
18:06:53 <dejones_> EvilTerran: thanks for the clarification.
18:06:57 <dejones_> [""]
18:07:04 <dejones_> for return
18:07:17 <EvilTerran> so... jump way back up to where we were... split ch [] = [""], yeah?
18:07:23 <dejones_> yep
18:07:37 <dejones_> split delim [] = [""]  :)
18:07:46 <EvilTerran> right then. split delim (c:cs) = ...?
18:08:18 <dejones_> heh, thinking about that...
18:08:30 <EvilTerran> let's do another case analysis. we like case analyses 'round here.
18:08:39 <hpaste>  AMDfanboy pasted "super basic" at http://hpaste.org/5145
18:08:44 <EvilTerran> what cases might there be?
18:08:55 <AMDfanboy> hi, i'm trying to learn haskell, using ghc, whats wrong with this?  http://hpaste.org/5145
18:08:56 <atp> if you have a recent version of GHC, you can use stripPrefix to make this somewhat simpler... it's in Data.List
18:09:12 <EvilTerran> atp, shh, this is my newbie :P
18:09:21 <dejones_> EvilTerran: haha
18:09:21 <atp> EvilTerran: sure :)
18:09:38 <dejones_> EvilTerran: claimed me, eh?  ;)
18:09:55 <dejones_> alright, cases.
18:10:22 <dejones_> EvilTerran: first case, we've shown is the [], next we have to deal with a string without the delimiter, then a string with the delimiter
18:10:29 <EvilTerran> exactly!
18:10:40 <dejones_> :)
18:10:44 <oerjan> AMDfanboy: the content of main must be an IO action. try main = print (add 4 3)
18:10:57 <AMDfanboy> ahhh
18:11:01 <AMDfanboy> thanks!
18:11:02 <oerjan> a do in itself has no effect
18:11:15 <AMDfanboy> yeah, where the hell did i get that?
18:11:23 <EvilTerran> split delim (c:cs) = if c == delim then <???#1> else <???#2>
18:11:30 <AMDfanboy> ok, i'm going to leave this open as i go back and fiddle ;-)
18:11:31 <EvilTerran> let's take #2 first; it's easier
18:11:49 <dejones_> k
18:12:04 <EvilTerran> so, if the first character is _not_ the delimiter, what happens?
18:12:27 <dejones_> EvilTerran: we just continue recursion
18:12:43 <EvilTerran> okay then; what's the else clause, then?
18:13:02 <dejones_> hmm
18:13:19 <EvilTerran> actually, sorry, let's rewind a little
18:13:46 <dejones_> I think that we have to add that char to the first element of the new list that will be returned
18:14:02 <EvilTerran> okay then, that makes sense. never mind rewinding. :P
18:14:17 <EvilTerran> we'll need to get the new list - do you know about where clauses?
18:14:58 <dejones_> EvilTerran: I read about "where" classes to declare data or functions that have local scope?
18:15:49 <dejones_> EvilTerran: I know a "where" class was used in an example with the quadratic equation for the computation of the part that is common for the b+- cases
18:15:50 <EvilTerran> indeed; expressions in where{} clauses can also see variables that're "less local" than they are, but still not "global"
18:16:00 <EvilTerran> e.g., function parameters
18:16:09 <dejones_> ok
18:16:35 <dejones_> I'm not sure of the syntax for "where" clauses.
18:17:11 <glen_quagmire> > b where { b = 1; }
18:17:12 <lambdabot>  Parse error at "where" (column 3)
18:17:14 <EvilTerran> <whatever> = <some expression> where { something = something else; this = that; t'other = blah blah blah }
18:17:37 <dejones_> lol
18:17:46 <EvilTerran> except { means "newline, indent more", ; means "newline, maintain indentation, and } means "newline, indent less"
18:17:50 <glen_quagmire> > f = b where  { b = 1; }
18:17:51 <lambdabot>  Parse error at "=" (column 3)
18:17:51 <EvilTerran> (give or take)
18:18:08 <dejones_> k
18:18:19 <EvilTerran> > let { f x = y where y = x+x } in map f [0..]
18:18:22 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:18:34 <dejones_> whoa
18:18:56 <glen_quagmire> > let { b = a where a = 1 } in b
18:18:58 <lambdabot>  1
18:19:27 <glen_quagmire> > let b = 1 in let b = 1 in let b = 1 in b
18:19:28 <lambdabot>  1
18:19:32 <EvilTerran> "foo = let { bindings galore } in (expression)" is just the same as "foo = (expression) where {the same bindings}"
18:19:52 <EvilTerran> but you can use let{...}in(...) anywhere, and where{...} can only appear in certain places
18:20:02 <Cale> > let evens = 0 : map (1+) odds; odds = map (1+) evens in evens
18:20:02 <dejones_> ok
18:20:07 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:20:29 <dejones_> you guys are trying to melt my brain ;)
18:20:30 <Cale> The bindings can even be mutually recursive :)
18:20:33 <glen_quagmire> what's : inside let Cale ?
18:20:39 <EvilTerran> dejones_, so we want to get at " the first element of the new list that will be returned"
18:20:41 <Cale> glen_quagmire: that's just cons
18:20:56 <glen_quagmire> oh, evens = (0:map...
18:20:58 <oerjan> > fix ((0:) . map (2+))
18:20:59 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:21:16 <EvilTerran> dejones_, never mind the nasty people with their PhDs trying to scare you ;)
18:21:22 <dejones_> EvilTerran: hehe.
18:21:34 * Cale wishes he had a PhD. :)
18:21:45 <glen_quagmire> dejones_: never mind the nasty people with their high school deploma scare you
18:21:48 * dejones_ is only a poor master's student.  ;)
18:21:59 <Cale> glen_quagmire: haha
18:22:06 <EvilTerran> anyway. we want to get at the first element from that list from the recursive call; so let's use a where{} to get at it
18:22:15 <hpaste>  EvilTerran pasted "dejones_ - this is what we have so far" at http://hpaste.org/5146
18:22:36 * dejones_ is looking...
18:22:52 <nanothief> Cale: that is the most evil definition of [2,4..] I have ever seen :P
18:23:08 <EvilTerran> nanothief, that sounds suspiciously like a challenge
18:23:12 <Cale> You mean [0,2..]
18:24:21 <EvilTerran> > fix (fmap (0:) $ fmap (2+)) -- nice gentle start
18:24:22 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:24:27 <glen_quagmire> > [0,2..]
18:24:28 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:24:31 <dejones_> EvilTerran: let first = x where { x = x:xs }  ?
18:24:32 <ray> that's not very evil, it doesn't even use church numerals
18:24:49 <nanothief> EvilTerran: this could get messy
18:25:02 <EvilTerran> dejones_, looking at my paste there, we want to make a local binding; that'd go at <???#3>
18:25:06 * dejones_ is now really afraid you guys are going to make my brain melt.
18:25:14 <Botje> > iterate (succ . succ) 0
18:25:16 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:25:21 <glen_quagmire> dejones_: are you trying to write string split function?
18:25:22 <dejones_> EvilTerran: yah, in #3
18:25:23 <Botje> that's nice and elegant :)
18:25:29 <dejones_> glen_quagmire: yes
18:25:31 <glen_quagmire> isn't there builtin string split function?
18:25:48 <dejones_> glen_quagmire: writing it to learn Haskell.  ;)
18:25:56 <glen_quagmire> oh i see
18:25:57 <ddarius> > fix ((0:)***id >>> snd&&&fst >>> join (***) (map (1+))) -- now we see if *** is lazy
18:25:58 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:26:02 <EvilTerran> dejones_, so "<???#3>"  should be "<pattern> = <expression>"
18:26:06 <oerjan> glen_quagmire: actually, no
18:26:23 <ddarius> > snd $ fix ((0:)***id >>> snd&&&fst >>> join (***) (map (1+))) -- now we see if *** is lazy
18:26:24 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
18:26:29 <glen_quagmire> split "a:b:c" ":"   ===>   ["a", "b", "c"]
18:26:29 <ddarius> Oops.
18:26:34 <dejones_> EvilTerran: ok, 1min
18:26:41 <nanothief> ddarius: thats odd...
18:26:46 <Cale> > [4 * k `div` (n+1) | (n,k) <- zip [0..] (scanl (+) 0 [1..])]
18:26:47 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:27:02 <dejones_> Cale: lol, n1
18:27:22 <dejones_> Cale: you are strong with the Force.
18:27:27 <dejones_> ;)
18:27:39 <Botje> > join (zipWith (+)) [0..]
18:27:46 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:28:30 <dejones_> EvilTerran: I'm not sure how to do the where <pattern> = <expression> --- hint?
18:28:42 <pattern> hi... i just started learning haskell, so please forgive this ultra simple question...  haskell left-associates, right?  so "Prelude> 8/2/2" returns "2.0" while "Prelude> 8/(2/2)" returns "8.0".. but then why does "Prelude> 1:2:[]" if "Prelude> 1:2" returns an error?
18:29:08 <Botje> because : requires a list on the right hand side
18:29:12 <oerjan> pattern: no, operators can have any associativity
18:29:20 <pattern> ah
18:29:26 <EvilTerran> dejones_, okay, well, we want to make a recursive call as part of the expression, right? what would that recursive call be?
18:29:41 <oerjan> try :i / and :i :
18:30:06 <glen_quagmire> dejones_: this is too hard for me
18:30:24 <oerjan> gives infixl 7 / and infixr 5 :
18:31:18 <dejones_> EvilTerran: where <something> = split delim xs ?
18:31:24 <pattern> i see
18:31:24 <EvilTerran> indeed
18:31:32 <pattern> thanks, oerjan
18:32:11 <EvilTerran> and we want to "add that char to the first element of the new list that will be returned", so we're going to need to get at the first element of that list
18:32:27 <EvilTerran> but we're also going to need to keep track of the rest of it; we want to return that as well
18:32:38 <dejones_> EvilTerran: right...
18:32:46 <dejones_> I'm not sure how to create the new list.
18:32:48 <EvilTerran> so we can do a pattern-match
18:32:53 <oerjan> pattern: there's a nice table of the most basic ones here: http://haskell.org/onlinereport/decls.html#sect4.4.2
18:32:57 <hpaste>  EvilTerran annotated "dejones_ - this is what we have so far" with "(no title)" at http://hpaste.org/5146#a1
18:33:09 <EvilTerran> ups, never mind the extra "where"
18:33:34 <pattern> thanks again, oerjan.. that looks very useful
18:33:38 <dejones_> EvilTerran: lol, (p:ps) just another list, haha
18:33:50 <EvilTerran> dejones_, indeed; it is, in fact, just another list
18:34:04 <EvilTerran> this pattern-match is very much the same as the one in "split delim (c:cs)"
18:34:16 <dejones_> EvilTerran: it is hard for me to think in terms of patterns, instead of creating/assigning new variables. ;)
18:34:48 <EvilTerran> in both of 'em, we're looking at a list "cell" and pulling out both the value in that cell, and the tail hanging off the back of it
18:35:26 <yoshi> true or false, Haskell is more widely used among mathematicians than computer scientists.
18:35:36 <dons> false.
18:35:52 <dejones_> EvilTerran: alright, so #2
18:35:56 <EvilTerran> dejones_, incidentally, this "(p:ps) = split ..." thing is why i wanted (split delim []) to contain an element
18:35:57 <Pseudonym> Mathematicians use the likes of Mathematica, Maple and Matlab.
18:36:01 <Pseudonym> Haskell doesn't start with "M".
18:36:06 <EvilTerran> > let (p:ps) = [] in p
18:36:09 <lambdabot>   Irrefutable pattern failed for pattern (p : ps)
18:36:15 <yoshi> thanks i need to prove my friend wrong haha
18:36:54 <yoshi> *needed
18:37:15 <EvilTerran> dejones_, what that error means, in this case, is "empty lists aren't shaped like (_ : _)!"
18:37:21 <gigamonkey> In Java if you have methods void foo (Object o) {...} and void foo (String s) { ... } and then say Object o = "a string"; foo(o); it invokes the first method, not the second. This often confused Java programmers. Is there any way to have an equivalent kind of confusion in Haskell?
18:37:28 <dejones_> EvilTerran: ahhh.
18:37:47 <dons> yoshi: cool :)
18:37:48 <Pseudonym> Having said that, the computer scientists who use Haskell tend to be more mathematically-oriented ones.
18:37:57 <glen_quagmire> oh yay i did it
18:37:58 <EvilTerran> dejones_, we could write it with split delim [] = [], but then we'd have to do something fancier than a straightforward binding here
18:38:00 <Valodim> gigamonkey: how is that confusing?
18:38:24 <dejones_> EvilTerran: straightforward I prefer at this point.  :)
18:38:26 <gigamonkey> It confuses some people because the static type the compiler knows about is different from the "actual" type of the object.
18:38:28 <dons> clearly, though, yoshi's fighting stereotypes in the broader world. good to see.
18:38:36 <EvilTerran> dejones_, this way's simpler... pretty much directly because of that "n delimiters, n+1 pieces" pattern i mentioned earlier
18:38:45 <glen_quagmire> but my split is String -> Char -> [String], not String -> String -> [String]
18:38:47 <dejones_> yeah
18:38:48 <gigamonkey> Folks often expect it to invoke the foo(String) method as it would if you said String o = "a string"
18:39:06 <Valodim> hum
18:39:28 <EvilTerran> dejones_, so. we've got (c), we know it's not (==delim), and we've got the result of the recursive call, (p:ps)
18:39:38 <EvilTerran> what do we want to return?
18:40:01 <dejones_> EvilTerran: (p:ps)  ?
18:40:09 <EvilTerran> dejones_, but you'll lose c!
18:40:10 <gigamonkey> I'm guessing that this kind of issue doesn't come up in Haskell but I don't know enough about it to prove a negative.
18:40:23 <EvilTerran> p:ps only contains values from in cs, remember
18:40:24 <dejones_> EvilTerran: c ++ (p:ps)  ?
18:40:30 <EvilTerran> (because that's all you gave it)
18:40:47 <EvilTerran> "we want to add that char to the first element of the new list"
18:40:55 <dejones_> c:p:ps ?
18:40:57 <dejones_> hehe
18:40:58 <EvilTerran> close
18:41:04 <EvilTerran> that's c : (p:ps)
18:41:07 <dejones_> c:(p:ps)
18:41:12 <gigamonkey> Is there some way you can, in Haskell, explicitly declare the type of a variable more loosely than the actual type?
18:41:25 <dejones_> :D
18:41:26 <gigamonkey> I.e. the equivalent of Java's Object o = "foo"
18:41:26 <EvilTerran> the first element of the list is p; we want to add c on to the beginning. we do that with...
18:41:28 <Saizan> gigamonkey: no
18:41:36 <glen_quagmire> things in where clause are evaluated once?
18:41:50 <dejones_> EvilTerran: with the (:)
18:41:50 <dejones_> ?
18:41:58 <EvilTerran> yes; (c:p)
18:42:07 <EvilTerran> so we've got (c:p), and we've got ps -- now what?
18:42:27 <dejones_> ((c:p):ps) ?
18:42:28 <dejones_> lol
18:42:40 <EvilTerran> exactly! :D
18:42:44 <dejones_> hahah
18:42:54 <ddarius> gigamonkey: Haskell has no subtyping at all so the issue can't come up.
18:42:58 <hpaste>  EvilTerran annotated "dejones_ - this is what we have so far" with "(no title)" at http://hpaste.org/5146#a2
18:43:05 <Saizan> gigamonkey: another reason is that in haskell types are only there at compile time
18:43:09 <glen_quagmire> (a : c) (b : c)  where c = func a b ...       can I say func a b ... is evaluated once?
18:43:15 <gigamonkey> ddarius: yeah, that was sort of what I was thinking.
18:43:29 <EvilTerran> dejones_, are you following all this okay so far?
18:43:53 <Saizan> glen_quagmire: yes, we usually assume that c will be shared in that case
18:43:56 <dejones_> EvilTerran: yep, I think I struggle more with the syntax than anything...
18:44:19 <dejones_> EvilTerran: well, and thinking in "patterns"
18:44:22 <dejones_> ;)
18:44:23 <EvilTerran> dejones_, well, that's good; haskell's got slightly more complex syntax than some other functional languages by design
18:44:36 <glen_quagmire> Saizan: are there cases when c won't be shared?
18:44:54 <EvilTerran> and patterns are a bit unusual for people who haven't seen 'em before
18:44:56 <gigamonkey> If I have two values of the same type but constructed with different constructors, what do you say they differ in? Not type, presumably.
18:45:01 <glen_quagmire> depending on the expressoin that uses bound variable in whereclause, c
18:45:13 <EvilTerran> dejones_, okay then; all that's left is <???#1>
18:45:14 <Cale> glen_quagmire: Only when c is typeclass polymorphic, basically.
18:45:21 <LoganCapaldo> gigamonkey: they differ in value don't they?
18:45:34 <gigamonkey> LoganCapaldo: true.
18:45:35 <AMDfanboy> i have a file,  which has 10 words on 10 consecutive lines.  i want to read it and put it into a list where every line becomes an element.  is that getFile?
18:45:36 <dejones_> EvilTerran: why is c:(p:ps) not allowed?
18:45:42 <EvilTerran> ?type (:)
18:45:44 <lambdabot> forall a. a -> [a] -> [a]
18:45:57 <glen_quagmire> Cale: oh thanks. /me doesnt' know typeclass polynormphic yet
18:46:01 <EvilTerran> c is a Char, p is a [Char], ps is a [[Char]]
18:46:09 <JBGood> gigamonkey, they have different tags...
18:46:09 <Cale> AMDfanboy: xs <- fmap lines (readFile "foo")
18:46:11 <oerjan> AMDfanboy: readFile, and then the lines function
18:46:16 <EvilTerran> by the latter two, (p:ps) is a [[Char]] too
18:46:30 <dons> ?users
18:46:30 <lambdabot> Maximum users seen in #haskell: 454, currently: 396 (87.2%), active: 19 (4.8%)
18:46:31 <EvilTerran> (it's the same as "(:) p ps")
18:46:37 <dejones_> EvilTerran: I see...
18:46:38 <gigamonkey> JBGood: thanks, that's what I was looking for,  I think.
18:46:43 <Cale> glen_quagmire: Well, something like...
18:46:48 <AMDfanboy> thanks!
18:47:00 <EvilTerran> but if you try to cons a Char onto the start of a [[Char]], you run into trouble
18:47:00 <Cale> x :: (Num a) => a; x = 10
18:47:11 <EvilTerran> as either you need to unift [Char] and [[Char]], or Char and [Char]
18:47:14 <EvilTerran> *unify
18:47:26 <EvilTerran> depending on which type you work out first
18:47:33 <ddarius> gigamonkey: Most people wouldn't really say that.  They'd just be considered different values.  For example, for Bool the two "tags" are True and False.
18:47:37 <Cale> glen_quagmire: Behind the scenes, that's a function from a typeclass dictionary for Num to a number of some type. Functions don't memoise.
18:48:08 <EvilTerran> dejones_, also, c:(p:ps) isn't shaped like the value we want to give back
18:48:35 <dejones_> EvilTerran: [c:(p:ps)] ?
18:48:36 <gigamonkey> ddarius: but if you have, say, a Shape data type with Rectangle, Circle, Triangle constructors (is that the right term) is there some way to talk about all the Triangle values as distinct from the Rectangles and Circles?
18:48:46 <glen_quagmire> > let { x :: (Num a) => a; x = 10; } in [x ..]
18:48:55 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
18:49:04 <Cale> gigamonkey: Not at the level of the type system.
18:49:10 <EvilTerran> ill-typed expressions sometimes are roughly the right "shape", but not here; you said yourself that you want to add c onto the first element of the recursive call, not tack it onto the result of the recursive call itself
18:49:29 <EvilTerran> that "first element" thing is importand
18:49:32 <dejones_> yeah
18:49:35 <gigamonkey> Cale: right. So I'm just wondering if there was a way of talking about the difference.
18:49:38 <ddarius> gigamonkey: constructor is right.  data constructor to be specific (as opposed to a type constructor).  There are ways, but usually a generic term isn't used.  One would just say "the Triangles"
18:49:41 <EvilTerran> not [c:(p:ps)], no
18:49:50 <oerjan> glen_quagmire: that use of x in [x ..] gets defaulted to Integer
18:49:50 <gigamonkey> ddarius: okay.
18:50:00 <EvilTerran> as i said, (p:ps)::[[Char]] and c::Char
18:50:05 <ddarius> gigamonkey: Sometimes "cases", "alternatives" or "tags" are used, but not often in my experience.
18:50:12 <EvilTerran> so they don't match up with the type signature of (:)
18:50:20 <Cale> gigamonkey: If you're just looking for an English phrase describing that, well, I suppose you can say something like "values constructed with the Triangle constructor" or similar. "Triangle values" doesn't seem bad.
18:50:32 <EvilTerran> dejones_, [c]:(p:ps) would typecheck, but it wouldn't be doing what you wanted to do
18:50:37 <oerjan> > let { x :: (Num a) => a; x = 10; } in (x `div` 2, x/2)
18:50:38 <dejones_> EvilTerran: hmm
18:50:49 <lambdabot>  (5,5.0)
18:50:59 <EvilTerran> it'd be like saying [[c],p] ++ ps
18:51:04 <EvilTerran> rather than [c:p] ++ ps
18:51:44 <glen_quagmire> > let { x :: (Num a) => a; x = 10; } in let {x = x;} in x
18:51:44 <lambdabot>  Exception: <<loop>>
18:51:47 <EvilTerran> in the first case, the first two items of the list are [c] and p
18:51:55 <EvilTerran> and in the second, the first item is (c:p)
18:52:00 <EvilTerran> clear as mud?
18:52:00 <dejones_> yeah
18:52:13 <glen_quagmire> oerjan: so, in your example, x is evaluated twice?
18:52:18 <dejones_> lol, not quite that bad ;)
18:52:25 <Cale> glen_quagmire: yeah
18:52:29 <EvilTerran> okay, so moving on to ???#
18:52:29 <EvilTerran> 1
18:52:34 <oerjan> glen_quagmire: let is recursive so the x = x has nothing to do with the first one
18:52:38 <oerjan> glen_quagmire: yep
18:52:45 <Cale> > let x :: (Num a) => a; x = product [1..1000] in (x / 2, x `div` 2)
18:52:46 <lambdabot>   add (Enum a) to the type signature(s) for `x'
18:52:46 <dejones_> k
18:52:52 <EvilTerran> we've got (c == delim), cs, p, and ps
18:52:54 <dejones_> EvilTerran: #1.. thinking
18:52:57 <gigamonkey> I've heard folks who grok Haskell's type system dismiss Java's type system as impovrished. Does anyone know of any good writeups of why?
18:53:01 <Cale> > let x :: (Enum a, Num a) => a; x = product [1..100] in (x / 2, x `div` 2)
18:53:02 <lambdabot>  (4.666310772197205e157,46663107721972076340849619428133350245357984132190810...
18:53:32 <dejones_> EvilTerran: is the where ... = ... available to both the if {} and else {} ?
18:53:38 <EvilTerran> yes
18:53:51 <dejones_> EvilTerran: Ok, so the where is not local to the else?
18:53:51 <Cale> gigamonkey: Because it lacks things like typeclasses, the generics are awkward to use, there's no first class functions, no tuple types...
18:53:52 <EvilTerran> ... tell me, have you met "guards"?
18:53:58 <ddarius> gigamonkey: In some ways it's more sophisticated than Haskell's.
18:54:00 <dejones_> EvilTerran: nope, no guards
18:54:07 <EvilTerran> okay.
18:54:48 <EvilTerran> <binding> | <bool> = <expression> | <bool> = <expression> | ...
18:54:53 <EvilTerran> is the same as
18:55:09 <ddarius> gigamonkey: The lack of (even local) type inference is an issue.  If you add popular extensions, Haskell has quite a bit more power.
18:55:10 <gigamonkey> ddarius: interesting, how so?
18:55:13 <EvilTerran> <binding> = if <bool> then <expr> else if <bool> then <expr> else if ....
18:55:33 <dejones_> EvilTerran: lol
18:55:39 <dejones_> EvilTerran: is that a "guard"  ?
18:56:02 <EvilTerran> dejones_, with the notable difference that, if none of the "guard clauses" (| ...) are true, evaluation jumps to the next equation
18:56:21 <dejones_> EvilTerran: I think we made an error...
18:56:33 <EvilTerran> > let { foo x | False = "never happens"; foo x = "it falls through here" } in foo 12
18:56:33 <lambdabot>  "it falls through here"
18:56:51 <dejones_> EvilTerran: we added c to the beginning of the element in the list, but in a split function, the delimiter is consumed.
18:57:02 <dejones_> so it would just be p:ps ?
18:57:04 <EvilTerran> where{} clauses are scoped across all guards of a binding
18:57:18 <EvilTerran> remember, #2 was the case when c/=delim
18:57:25 <dejones_> haha
18:57:26 <dejones_> ahyes
18:57:28 <dejones_> ahh yes
18:57:31 <lispy> do you ever find your self in an existential type quandry of code loathing and correctness doubt?
18:57:32 <EvilTerran> anyway; now i've introduced guards, i'll rephrase slightly
18:57:33 <ddarius> gigamonkey: Haskell 98 is/was pretty conservative.  Things like local existentials, higher rank types, generalized algebraic types, multiparameter type classes with functional dependencies significantly extend what Haskell 98 offered.
18:57:49 <ddarius> lispy: Sounds like you need to rewrite some code.
18:58:05 <hpaste>  (anonymous) annotated "dejones_ - this is what we have so far" with "(no title)" at http://hpaste.org/5146#a3
18:58:12 <dejones_> EvilTerran: then maybe #1 is just p:ps  ?
18:58:15 <lispy> ddarius: or in my case, have been rewriting code to use existential type witnesses :)
18:58:24 <EvilTerran> "otherwise" is a convenience function
18:58:27 <EvilTerran> @src otherwise
18:58:27 <lambdabot> otherwise = True
18:58:35 <ddarius> convenience value?
18:58:43 <EvilTerran> function, value, whatever
18:58:48 <EvilTerran> "doohickey"
18:58:57 <lispy> ddarius: but, that's also a parody of a weird al song
18:58:59 <EvilTerran> altho "convenince doohickey" makes me think "toilet"...
18:59:14 <Cale> x is a function => exists a b. x :: a -> b
18:59:27 <EvilTerran> dejones_, let's take a specific example
18:59:48 <lispy> :t const otherwise
18:59:50 <lambdabot> forall b. b -> Bool
18:59:54 <dejones_> EvilTerran: ok
18:59:54 <lispy> Cale: like taht?
19:00:08 <Cale> lispy: sure :)
19:00:10 <ddarius> gigamonkey: One of the significant lacks of Java's type system relative to Haskell's that is meaningful is the inability to quantify over type constructors.
19:00:25 <EvilTerran> split ';' "a;b"  =  ('a':p):ps where (p:ps) = split ';' ";b"
19:00:32 <lispy> ddarius: quantify over type constructors?
19:00:41 <gigamonkey> ddarius: Can you give me an example of what that means?
19:00:50 <ddarius> :t sequence
19:00:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:00:51 <EvilTerran> dejones_, if we follow what you're saying, split ';' ";b" = ["b"]
19:00:54 <lispy> ddarius: when does this need arise in java, or better yet, what is a standard part of the language you could improve by adding that feature?
19:00:59 <ddarius> m is a type constructor
19:01:09 <EvilTerran> but then ('a':p):ps = ["ab"]
19:01:12 <dejones_> EvilTerran: OK
19:01:18 <dejones_> ok, sorry caps
19:01:25 <dejones_> yeah..
19:01:30 <EvilTerran> let's see, actually; remember my (n,n+1) rule?
19:01:35 <dejones_> EvilTerran: not sure how to separate the elements
19:01:40 <EvilTerran> what should split ';' ";" be?
19:01:41 <dejones_> yea
19:01:49 <Cale> lispy: Look at the Functor class in Haskell for a nice small example :)
19:02:06 <dejones_> EvilTerran: ["", ""]  ?
19:02:14 <ddarius> Admittedly it's not clear (to me at least) what the semantics would be using dynamic dispatch.
19:02:16 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
19:02:18 <EvilTerran> exactly! there's one delimiter, so we need two parts
19:02:23 <dejones_> :)
19:02:26 <glen_quagmire> (\x -> x - 1)  is this the only way?  i'm looking for something equivalent to (+1)
19:02:31 <lispy> Cale: I want to see the example in hypothetical java with the aforementioned feature contrasted against java, say, 1.5
19:02:40 <Cale> glen_quagmire: there's  (subtract 1)
19:02:48 <EvilTerran> so, when you're looking at a delimiter, and you've got your (p:ps), what do you want to return?
19:02:49 <glen_quagmire> ah thanks Cale
19:02:52 <pattern> why does "Prelude> 1" return "1", and "Prelude> (read "1") + (read "2")" returns "3", while "Prelude> read "1"" returns an error ?
19:02:58 <ddarius> lispy: Try to write a Monad interface in Java.
19:02:58 <EvilTerran> ?type (-1+)
19:02:59 <lambdabot> forall a. (Num a) => a -> a
19:03:01 <EvilTerran> ?type (+ -1)
19:03:02 <lambdabot>     The operator `+' [infixl 6] of a section
19:03:02 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
19:03:02 <lambdabot>         in the section: `(+ (- 1))'
19:03:04 <lispy> ddarius: someone did
19:03:05 <EvilTerran> huh
19:03:18 <EvilTerran> glen_quagmire, "pred" may also suit
19:03:27 <Cale> pattern: Because in the last case, there isn't enough information available for it to guess what type you'd like to parse from that string.
19:03:29 <ddarius> lispy: A generic one?  If so, link?
19:03:30 <oerjan> pattern: technicality about the defaulting
19:03:35 <glen_quagmire> hah (+ (-1)) is nice EvilTerran
19:03:46 * EvilTerran likes (-1+) for sheer obnoxiousness
19:04:03 <pattern> cale, so the "+" operator gives ghci a hint that it's an integer?
19:04:03 <AMDfanboy> fmap lines (readFile "foo")   this is cool a list of lines of the file foo.  now i want to remove the first line.  apparently thats what the function tail is for.  so i figure i just gotta do this      tail (fmap lines (readFile "foo")).  but it doesnt work.  but if i do this     x <- save fmap lines (readFile "foo")  and then      tail x     it works.  huh?
19:04:07 <lispy> ddarius: there is a monad library in java, yeah, looking for the lnk.  But, I really would like to have this hypothetical java example.  It would be nice to show to java peeps.
19:04:29 <Cale> pattern: There's a defaulting rule for numbers -- if it can tell that the thing you want is a number, it'll default to either Integer or Double, whichever works first.
19:04:31 <EvilTerran> dejones_, we'll do another example if you like; what should split ';' ";foo" be?
19:04:38 <AMDfanboy> sorry, thats the list of the lines in foo, now i want to remove the first element from the list
19:04:40 <EvilTerran> bearing in mind split ';' "foo" = ["foo"
19:04:42 <EvilTerran> ]
19:04:48 <oerjan> pattern: ghci defaults to () if possible, then to Integer, then Double.  the last one doesn't give enough information to disallow ()
19:04:51 <Cale> AMDfanboy: fmap (tail . lines) (...)
19:04:55 <EvilTerran> and it's gotta have two elements?
19:05:03 <oerjan> so since it is not read "()", it fails
19:05:12 <pattern> oerjan: what's () ?
19:05:20 <EvilTerran> ?src ()
19:05:21 <lambdabot> data () = ()
19:05:23 <Cale> AMDfanboy: you can also do something like  "let rest = tail lines" on the next line of your do-block
19:05:29 <Cale> er
19:05:30 <oerjan> pattern: a type with only one value
19:05:32 <Cale> AMDfanboy: you can also do something like  "let rest = tail xs" on the next line of your do-block
19:05:40 <AMDfanboy> ok, thanks
19:05:43 <AMDfanboy> !
19:05:49 <EvilTerran> dejones_?
19:05:56 <pattern> oerjan, and an integer doesn't only have one value?
19:06:13 <lispy> ddarius: there is this: http://blog.tmorris.net/maybe-monad-in-java/
19:06:15 <lambdabot> Title:  Tony&#8217;s blog   Blog Archive  Maybe Monad in Java
19:06:18 <EvilTerran> pattern, sure, but the type Integer has many, many values
19:06:19 <LoganCapaldo> Integer has many values, 1, 3, 42, -670
19:06:19 <Cale> Integer has infinitely many values :)
19:06:33 <EvilTerran> pattern, Bool has two values; in the same way, () has one
19:06:42 <LoganCapaldo> but there is only one value of type ()
19:06:46 <LoganCapaldo> namely, ()
19:06:54 <pattern> ah
19:07:02 <pattern> so () is both a type and a value?
19:07:08 <EvilTerran> yes
19:07:11 <pattern> weird
19:07:11 <Cale> pattern: right
19:07:22 <EvilTerran> types and values occupy different namespaces
19:07:34 <EvilTerran> some find punning between the two to have a nice mnemonic value
19:07:34 <pattern> i think i'll just save the obvious question of what () is used for until later :)
19:07:36 <kaiser_> hello...
19:07:44 <EvilTerran> others just find it weird
19:07:46 <kaiser_> EvilTerran: sorry, I got disconnected
19:07:49 <ddarius> lispy: Thta doesn't have code and what I want is something that captures the general monad interface, not particular examples.  Java is quite capable (if painfully) implementing specific monads.
19:08:05 <dejones__> EvilTerran: I'm back.
19:08:14 <Cale> So for example, you can write  data A = A, and the A on the left defines a new type called 'A', while the A on the right defines a new value of type A, also called A.
19:08:22 <dejones__> I probably missed a lot of what you typed...
19:08:24 <EvilTerran> dejones__, hurrah; where were we?
19:08:36 <EvilTerran> okay, let's go back to here: what should split ';' ";foo" be?
19:08:45 <lispy> ddarius: so what prevents you from implementing what you want using generics in java?
19:08:45 <dejones__> <EvilTerran> ?type (-1+)
19:08:47 <dejones__> <dejones_> EvilTerran: something like [p, ps] ...?
19:08:47 <dejones__>  hmm
19:08:55 <Cale> (which is a-ok, since they're in different namespaces, eh?)
19:09:03 <Cale> :)
19:09:07 <dejones__> EvilTerran: ["foo"]
19:09:17 <gigamonkey> EvilTerran: could be worse. In Common Lisp there's a value NIL whose type is NULL and also a type NIL (which is the bottom of the type lattice has no values).
19:09:21 <EvilTerran> dejones__, remember my rule; it's gotta have two elements, as there's one delimiter
19:09:25 <pattern> Cale: thank you, but i think the data statement is too advanced for me right now  :)
19:09:27 <EvilTerran> gigamonkey, eeeew.
19:09:40 <dejones__> EvilTerran: ["", "foo"]
19:09:43 <EvilTerran> bingo!
19:09:49 <dejones__> odd ;) heh
19:09:49 <ddarius> lispy: You can't make an interface parameterized by a type constructor.  There may be some other more round about way of doing it.
19:10:00 <dejones__> EvilTerran: but, yea, I understand
19:10:11 <Cale> pattern: Well, for a more reasonable example, we could go with something like  data Colour = Red | Orange | Yellow | Green | Blue | Purple
19:10:12 <EvilTerran> in general, if split delim xs = <blah>, what's split delim (delim:xs)?
19:10:20 <Cale> pattern: As a simple example of an enumeration.
19:10:22 <EvilTerran> (bear in mind i'm cheating; you can't really say that)
19:10:23 <lispy> ddarius: this gives some code, it's mostly a monad although the author comments he feels it's more of stream: http://osdir.com/ml/lang.scala/2005-03/msg00019.html
19:10:24 <lambdabot> Title: RE: The IO monad: msg#00019
19:10:32 <Cale> Then we get things like  Orange :: Colour
19:10:35 <kalmar> ?users
19:10:35 <lambdabot> Maximum users seen in #haskell: 454, currently: 400 (88.1%), active: 18 (4.5%)
19:10:49 <AMDfanboy> Cale: sorry someone called, why didnt that work?
19:11:00 <AMDfanboy> fmap lines (readFile "foo") is a big list, no?  and tail works on lists?
19:11:04 <dejones__> EvilTerran: delim (delim:xs) = ["", "", xs]  ??
19:11:05 <pattern> Cale: ok
19:11:14 <EvilTerran> er...
19:11:15 <Cale> AMDfanboy: nope, it's actually an IO action which produces a list when run
19:11:20 <ddarius> lispy: For example, the Eq type class can be roughly rendered as interface Eq<A> { bool equal(A a, A b); }, but interface Monad<M> { M<A> unit<A>(A a); ... } is not doable.
19:11:33 <dejones__> heh
19:11:34 <AMDfanboy> so it returns a list?
19:11:37 <EvilTerran> dejones__, well... split ';' "foo;bar" = ["foo","bar"], yeah?
19:11:39 <dejones__> ./kick dejones_
19:11:45 <dejones__> yes
19:11:52 <EvilTerran> split ';' ";foo;bar" = ...?
19:12:03 <oerjan> lispy: note that scala's type extensions over java _do_ allow for defining generic monad code.
19:12:04 <pattern> Cale: your earlier data example makes more sense in light of the colour example, thank you
19:12:13 <Cale> AMDfanboy: fmap takes a function f, and an action x (or other datastructure), and constructs a new action, which when run, runs the action x getting the result v, and returns f applied to v
19:12:13 <ddarius> lispy: That's again a particular monad.  Let's say I want to write sequence of liftM2, what type would I give them in Java?
19:12:15 <dejones__> EvilTerran: I thought you were saying ";;bar", so I thought that would be ["", "", bar]
19:12:22 <Cale> pattern: no problem :)
19:12:36 <EvilTerran> my bad
19:12:46 <Cale> AMDfanboy: when run :)
19:12:50 <dejones__> EvilTerran: ";foo;bar" is ["", foo, "", bar]  ?
19:12:50 <ddarius> s/sequence of liftM2/sequence or liftM2/
19:12:53 <lispy> oerjan: i would believe that, scala has a nice type system
19:13:04 <dejones__> EvilTerran: ack
19:13:07 <AMDfanboy> riiiiggggghhhhht, of course :-)
19:13:11 <Cale> AMDfanboy: For IO actions,  fmap f x = do v <- x; return (f v)
19:13:19 <dejones__> EvilTerran: ";foo;bar" is ["", foo, bar]  ?
19:13:26 <lispy> ddarius: well, hmm...so the interface Monad<M>, example, what exactly does java balk at?  The <A>?
19:13:33 <Cale> (that's possibly a clearer way to say what I tried to write in English :)
19:13:34 <EvilTerran> indeed. well, not forgetting the "s around foo and bar.
19:13:45 <dejones__> EvilTerran: :)
19:13:45 <lispy> ddarius: because if that's the case, couldn't you add A as a parameter to the class?
19:13:51 <lispy> ddarius: s/class/interface
19:13:57 <AMDfanboy> i dont follow that line?
19:14:00 <ddarius> lispy: Presumably the M<A>
19:14:12 <EvilTerran> dejones__, and if you write that in terms of (split ';' "foo;bar")?
19:14:21 <AMDfanboy> we have an action x, and a function f, we apply f to x?
19:14:24 <lispy> ddarius: hmm...then I bet you could do this in C++ with template.
19:14:24 <Cale> AMDfanboy: join #haskell-overflow
19:14:30 <ddarius> lispy: I'd have to run it through a Java compiler and I don't have one handy.
19:14:37 <lispy> ddarius: aye, me either
19:14:44 <Cale> (it's just a little too noisy here :)
19:15:02 <dejones__> Cale: you woke up everyone with your crazy evens ;)
19:15:24 * dejones__ is thinking...
19:15:47 <lispy> that's why we call him CrazyCodeCale
19:15:50 <monochrom> "class Monad<A>" or "interface Monad<A>" is the wrong way about.  See the two recent posts on http://higherlogics.blogspot.com/
19:15:51 <lambdabot> Title: Higher Logics
19:15:53 <EvilTerran> split ';' "foo;bar" = ["foo","bar"]
19:16:04 <EvilTerran> split ';' ";foo;bar" = ["","foo","bar"] = ...
19:16:04 <dejones__> lispy: he's C^3 ;)
19:16:42 <dejones__> EvilTerran: ["", p, ps]  ?
19:16:55 <dejones__> can't be ps though...right?
19:16:59 <dejones__> bc ps is a list
19:17:15 <EvilTerran> dejones__, in terms of (split ';' "foo;bar")?
19:17:32 <dejones__> EvilTerran: not sure what you are asking, rephrase?
19:17:42 <lispy> monochrom: cool
19:17:45 <dejones__> oh
19:17:57 <glen_quagmire> is operator precedance related to parse order or evaluation order?
19:18:03 <Cale> dejones__: hehe
19:18:05 <dejones__> EvilTerran:     ["", p, split c ps]
19:18:09 <EvilTerran> "give an expression equivalent to (split ';' ";foo;bar") that includes an expression equivalent to (split ';' "foo;bar")
19:18:12 <monochrom> CrazyCodeCale = CCC = Cartesian Closed Category?
19:18:23 <dejones__> lol
19:18:29 <oerjan> glen_quagmire: it's resolved during parsing
19:18:38 <glen_quagmire> oerjan: oh thanks
19:18:43 <monochrom> "Cale is a CCC, can do exponents"
19:18:45 <EvilTerran> dejones__,  ["","foo","bar"]  =  "" : ["foo","bar"]
19:19:00 <dejones__> EvilTerran: yes
19:19:02 * glen_quagmire was trying to comment on realworld haskell book
19:19:10 <EvilTerran> and  ["foo","bar"] = split ';' "foo;bar"
19:19:14 <Pseudonym> But Cale doesn't have consistent fixed points.
19:19:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5147
19:19:18 <dejones__> EvilTerran: yes
19:19:31 <EvilTerran> so  split ';' ";foo;bar" = "" : split ';' "foo;bar"
19:19:31 <ddarius> monochrom: The point is to point out that Java (and C#) are incapable of quantifying over type constructors.  Further naasking doesn't claim a type safe approach.
19:19:57 <EvilTerran> do you see?
19:19:57 <monochrom> yes yes yes
19:20:09 <ddarius> Incidentally, my understanding is that Scala only very recently got the support necessary.
19:20:15 <dejones__> EvilTerran: "" : split  c ps ?
19:20:36 <dejones__> EvilTerran: "" : split  c ps --- for #1
19:21:11 <EvilTerran> we've already split up ps
19:21:16 <dejones__> haha
19:21:20 <dejones__> EvilTerran: "" : split c cs --- for #1
19:21:21 <dejones__> :D
19:21:25 <dejones__> yay
19:21:29 <EvilTerran> well, split delim cs
19:22:06 <monochrom> I don't focus on type-safe. I focus on which type expression gets the wrong idea across and which type expression gets the right idea across.
19:22:06 <EvilTerran> but that's six-and-two-threes
19:22:06 <dejones__> :P c == delim
19:22:06 <dejones__> lol
19:22:19 <dejones__> EvilTerran: yeah.  thanks a lot man.  :)
19:22:21 <EvilTerran> but note, p:ps = split delim cs
19:22:29 <EvilTerran> so we could write p:ps instead
19:22:37 <EvilTerran> but i think your way is clearer
19:22:52 <hpaste>  (anonymous) annotated "dejones_ - this is what we have so far" with "ta-dah!" at http://hpaste.org/5146#a4
19:23:22 <EvilTerran> no probs; any excuse to stay up late, me :)
19:23:43 <dejones__> EvilTerran: haha, me too... I have class at 9am, lol
19:23:46 <dejones__> ?karma
19:23:46 <lambdabot> You have a karma of 0
19:23:53 <dejones__> ++ EvilTerran
19:24:05 <dejones__> how do I give karma again?  ;)
19:24:13 <EvilTerran> ?help ?karma+
19:24:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:24:17 <EvilTerran> ?help karma+
19:24:17 <lambdabot> karma+ <nick>. Increment someone's karma
19:24:27 <dejones__> karma+ EvilTerran
19:24:31 <dejones__> karma+ EvilTerran
19:24:31 <dejones__> :D
19:24:34 <dejones__> double time!
19:25:08 <oerjan> missing ? in front
19:25:14 <dejones__> hmm
19:25:20 <dejones__> ?karma+ EvilTerran
19:25:21 <lambdabot> EvilTerran's karma raised to 7.
19:25:25 <dejones__> ?karma+ EvilTerran
19:25:25 <lambdabot> EvilTerran's karma raised to 8.
19:25:29 <EvilTerran> yaay :D
19:25:32 <dejones__> :) there we go.
19:25:39 <EvilTerran> whoa, don't get too carried away :)
19:25:40 * dejones__ is very appreciative.  :)
19:25:44 <dejones__> haha
19:25:49 <EvilTerran> BUT WAIT! there's more to come!
19:25:52 <EvilTerran> *dun dun duhh*
19:25:55 <dejones__> well, two points... you wrote code AND explained.  ;)
19:25:57 <dejones__> hehe
19:26:23 <EvilTerran> here's the thing; we don't actually do anything that particularly depends on the input being strings and characters
19:26:31 <EvilTerran> well, apart from writing "" instead of []
19:26:41 <EvilTerran> so let's try making it more generic
19:26:52 <dejones__> alright
19:27:27 <hpaste>  (anonymous) annotated "dejones_ - this is what we have so far" with "now with no strings attached" at http://hpaste.org/5146#a5
19:28:04 <EvilTerran> now then, what's the most general type we can give it?
19:28:32 <EvilTerran> (no asking an interpreter; that's cheating)
19:28:37 <dejones__> EvilTerran: empty list?
19:28:44 <EvilTerran> type, man, type!
19:28:48 <EvilTerran> empty list is a value!
19:28:53 <EvilTerran> (sorry)
19:29:01 <monochrom> why sorry?
19:29:01 <EvilTerran> okay, before, we had
19:29:02 <EvilTerran> split :: Char -> String -> [String]
19:29:07 <dejones__> lol
19:29:12 <EvilTerran> ?src String
19:29:12 <lambdabot> type String = [Char]
19:29:22 <EvilTerran> so that's the same as split :: Char -> [Char] -> [[Char]]
19:29:57 <dejones__> EvilTerran: yeah
19:30:03 <dejones__> EvilTerran: I don't know all of Haskell's types
19:30:07 * EvilTerran notes that sioraiocht is in the same timezone as him, and so just left at 3.30am :D
19:30:27 <dejones__> lol
19:30:29 <EvilTerran> dejones__, okay, let's look at this:
19:30:31 <EvilTerran> ?type id
19:30:33 <lambdabot> forall a. a -> a
19:30:46 <dejones__> id is a type?
19:30:50 <EvilTerran> "pick any 'a' you like; id can take the type a -> a"
19:30:51 <dejones__> no
19:30:57 <EvilTerran> is has that type
19:31:05 <EvilTerran> follow?
19:31:07 <oerjan> @src id
19:31:08 <lambdabot> id x = x
19:31:21 <dejones__> alright
19:31:26 <markb> @src nubBy
19:31:26 <lambdabot> nubBy eq []             =  []
19:31:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:31:58 <oerjan> > nubBy (((>1).).gcd) [2..]
19:32:07 <dejones__> EvilTerran: a. is "any a"  ??
19:32:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:32:21 <EvilTerran> dejones__, "forall a." means what it says
19:32:43 <EvilTerran> "forall" is actually an extension, but i think it helps to think it even when it's not there
19:32:45 <dejones__> oh, "a." that '.' is a period ?
19:32:56 <dejones__> as in '.' just ending the sentence?
19:33:00 <EvilTerran> yeah, it separates the quantified variables from the type itself
19:33:05 <dejones__> ok
19:33:13 <EvilTerran> <quantifier> <variables> . <type>
19:33:21 <EvilTerran> (<quantifier> is always forall)
19:33:21 <dejones__> k
19:33:27 <EvilTerran> anyway.
19:33:38 <EvilTerran> id :: a -> a; whatever a you chose, id can have the type (a -> a)
19:33:40 <EvilTerran> next!
19:33:43 <EvilTerran> ?type (==)
19:33:45 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:34:01 <dejones__> :)
19:34:04 <dejones__> makes sense.
19:34:13 <EvilTerran> whatever a you chose, if a is an equality type, (==) can have the type a -> a -> Bool
19:34:25 <EvilTerran> similarly
19:34:27 <EvilTerran> ?src (<)
19:34:27 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
19:34:33 <EvilTerran> er
19:34:36 <EvilTerran> ?type (<)
19:34:36 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:34:43 <dejones__> :)
19:34:56 <dejones__> EvilTerran: it reads like propositional logic
19:34:57 <dejones__> heh
19:34:58 <EvilTerran> "Ord a" meaning "a is an ordered type"
19:35:07 <EvilTerran> yeah, it does, rather. :)
19:35:07 <dons> anyone who likes random numbers, if you could check this lib, $ darcs get http://code.haskell.org/~dons/code/mersenne-random
19:35:08 <lambdabot> Title: Index of /~dons/code/mersenne-random
19:35:13 <dons> builds on your box, that would be useful :)
19:35:26 <dons> esp, if its a newer intel chip, then configure with '-f use_sse2'
19:35:40 <dons> or a powerpc supporting altivec instructions, '-f use_altivec'
19:35:40 <dejones__> dons: is this too complicated for a noob?
19:35:50 <dons> well, you need cabal
19:35:52 <dons> and darcs.
19:35:52 <EvilTerran> dejones__, okay then; let's go back to our split function
19:36:02 <dejones__> EvilTerran: okie
19:36:14 <dejones__> dons: ahh... I don't have either yet, heh
19:36:18 <dons> ok.
19:36:22 <EvilTerran> what're we using that'll involve one of our input types?
19:36:37 <EvilTerran> i see (:), (==), and split
19:36:40 <EvilTerran> ?type (:)
19:36:41 <lambdabot> forall a. a -> [a] -> [a]
19:36:49 <EvilTerran> that's fine; that works for any a you like
19:36:55 <dejones__> ok
19:37:08 <EvilTerran> we don't know the type of split yet, so let's assume *that* works for any a you like, too
19:37:10 <dejones__> ?type (==)
19:37:11 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:37:23 <EvilTerran> aha! we need to be able to compare for equality!
19:37:33 <dejones__> :)
19:37:37 <EvilTerran> so, previously, split :: Char -> [Char] -> [[Char]]
19:37:45 <EvilTerran> ....what is it now?
19:38:10 <dejones__> split :: Eq -> [Eq] -> [[Eq]]
19:38:14 <dejones__> ?
19:38:18 <dejones__> is that possible?
19:38:20 <EvilTerran> look at the type for (==) again
19:38:31 <dejones__> Bool?
19:38:40 <EvilTerran> Eq is a "type class", not a type. think of it as a predicate on types.
19:39:02 <EvilTerran> Bool doesn't even appear ;)
19:39:05 <dejones__> hmm
19:39:28 <dejones__> (heh, poor guess)
19:39:38 <dejones__> Eq a
19:39:46 <EvilTerran> good start
19:40:00 <dejones__> split :: Eq a -> [Eq a] -> [[Eq a]]
19:40:17 <EvilTerran> (==) :: Eq a => a -> a -> Bool
19:40:27 <dejones__> hmm
19:40:47 <dejones__> split :: Eq a -> [a] -> [[a]]
19:40:53 <dejones__> umm
19:40:59 <EvilTerran> "for all a: a satisfies the predicate Eq implies (==) can have the type  a -> a -> Bool"
19:41:08 <EvilTerran> warning: -> is not =>
19:41:26 <dejones__> hmm, hint?
19:41:28 <dejones__> ;)
19:41:51 <EvilTerran> Split :: <???> a -> [a] -> [[a]]
19:41:56 <EvilTerran> er, lowercase s
19:42:32 <EvilTerran> "for all a, <something something something> split can have the type a -> [a] -> [[a]]" -- fill in the blank
19:43:01 <vincenz> anyone know how 'not' to make ghci print something when you do
19:43:04 <vincenz> f <- foo
19:43:34 <BMeph> Dang it, how do you get rid of an unwanted change annotation again?
19:43:54 <BMeph> (Setup.lhs: mersenne-random.cabal:66: unrecognised field or section: "^ ^ ^ ^ ^ ^ ^")
19:44:53 <dejones__> EvilTerran: hmm... is <something something something> actually 3 somethings?  ;)
19:45:11 <EvilTerran> now you mention it, yes
19:45:28 <dejones__> Eq a a [a]
19:45:31 <dejones__> hmm
19:46:16 <dejones__> Eq a [a]
19:46:17 <dejones__> maybe?
19:46:29 <dejones__> I think I'm lost... it's muddy now ;)
19:46:30 <dejones__> haha
19:46:32 <EvilTerran> can you express it in words?
19:47:02 <dejones__> if the element a and list [a] have the characteristics of type class Eq?
19:47:21 <dejones__> aka, if they can be compared?
19:47:49 <EvilTerran> viewing Eq as a predicate on types?
19:47:59 <dejones__> yeah
19:48:17 <EvilTerran> "if a satisfies the predicate Eq, then..."
19:48:18 <dejones__> I think so...
19:48:37 <dejones__> a can be compared?
19:49:20 <EvilTerran> no, that's it
19:49:31 <EvilTerran> "for all a, <if a satisfies the predicate Eq, then> split can have the type a -> [a] -> [[a]]"
19:49:58 <EvilTerran> "if ... then" is written "... =>", and "a satisfies the predicate Eq" is written "Eq a"
19:50:01 <EvilTerran> so put it all together...
19:50:36 <dejones__> forall a, Eq a => split :: a => [a] -> [[a]]
19:50:36 <dejones__> ?
19:50:50 <EvilTerran> nearly
19:50:57 <BMeph> dons: Segmentation fault/access violation in generated code
19:51:05 <dejones__> forall a, Eq a => split :: a -> [a] -> [[a]]
19:51:19 <EvilTerran> look at the type annotation we had when we were just working with Chars
19:51:27 <EvilTerran> you've got everything you need, just in the wrong order
19:52:01 <dejones__> split :: forall a, Eq a => a -> [a] -> [[a]]
19:52:22 <dejones__> split :: Eq a => a -> [a] -> [[a]]
19:52:30 <dejones__> like that?
19:52:34 <EvilTerran> that's the one!
19:52:59 <hpaste>  EvilTerran annotated "dejones_ - this is what we have so far" with "and we're done!" at http://hpaste.org/5146#a6
19:53:02 <dejones__> woohoooo!
19:53:19 <EvilTerran> *phew*
19:53:40 <EvilTerran> right, now you've got an unnecessarily detailed insight into how my mind works
19:53:54 <dons> BMeph: can you try the package here, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-0.1
19:53:55 <lambdabot> http://tinyurl.com/29j38a
19:53:56 <dejones__> EvilTerran: lol, lol.
19:54:02 <dejones__> That is some wacky stuff, but really really cool.
19:54:14 <EvilTerran> you'll hopefully find pre-written tutorials a lot easier now you've had that whistle-stop tour of signficiant chunks of the language
19:54:19 <BMeph> dons: Get it by darcs or cabal?
19:54:34 <dons> just wget, http://hackage.haskell.org/packages/archive/mersenne-random/0.1/mersenne-random-0.1.tar.gz
19:54:34 <lambdabot> http://tinyurl.com/22v8lj
19:54:48 <dons> (works for me on a p4, and a 64 bit core 2 duo)
19:54:56 <dejones__> EvilTerran: thanks a lot.  that was definitely helpful.  :)
19:55:02 <dejones__> ?karma+ EvilTerran
19:55:03 <lambdabot> EvilTerran's karma raised to 9.
19:55:08 <dejones__> for the generalization!
19:55:11 <EvilTerran> steady... ;)
19:55:11 <dejones__> :)
19:55:16 <dejones__> hehe
19:55:35 <dejones__> your karma increased 133% in one night! ;)
19:56:27 <EvilTerran> at this point, i do suggest reading some pre-written stuff
19:56:42 <dejones__> ack, 150%, lol
19:56:54 <ddarius> "whistle-stop tour"?
19:56:57 <dejones__> EvilTerran: yeah, I have been, but most of it is too silly, really
19:57:15 <dejones__> they do simple stuff like I/O, which is useful, but doesn't really show off the language syntax to me
19:57:22 <dejones__> or they do crazy stuff with monads, etc.
19:57:31 <dejones__> I'd like to have a Haskell textbook...
19:57:34 <ray> silly? learn haskell in 10 comedy routines?
19:57:38 <ray> there's an idea
19:57:41 <glen_quagmire> dejones__: yet another haskell tutorial, gentle intro to haskell, real world haskell are nice
19:57:46 <dejones__> ray: haha
19:57:52 <EvilTerran> ddarius, ... is that phrase just me? i thought it was fairly common O.o
19:57:56 <dejones__> glen_quagmire: thanks
19:58:00 <glen_quagmire> real world haskell won't be a free book like practical common lisp right?
19:58:13 <glen_quagmire> i'd buy paper tree book
19:58:25 <dejones__> glen_quagmire: I thought they said "Real World Haskell" is going to be free...?
19:58:30 <dejones__> I think that is what dons said the other day?
19:58:34 <ray> What's the type of that expression?
19:58:37 <smack__> glen_quagmire: it seems to be CC...
19:58:37 <ddarius> EvilTerran: I've never heard "whistle-stop tour" in any context.  I think I get the gist of you comment, but that part means nothing to me.
19:58:38 <ray> yep, that's right
19:58:40 <EvilTerran> dejones__, if you want some problems to work on, project euler is fantastic
19:58:54 <dejones__> EvilTerran: what is that?
19:58:57 <glen_quagmire> oh cool.
19:59:00 <ddarius> You'll be able to buy it and it will be available online like parts of it already are.
19:59:10 <EvilTerran> @go project euler
19:59:10 <lambdabot> http://projecteuler.net/
19:59:10 <lambdabot> Title: Project Euler
19:59:13 <glen_quagmire> dejones__: if you like graphics stuff, SOE is very nice
19:59:23 <glen_quagmire> haskel school of expressoin
19:59:36 <dejones__> glen_quagmire: thanks
19:59:46 <dejones__> EvilTerran: I'll take a look at project Euler
19:59:50 <BMeph> dons: My 32-bit Core 2 Duo does not like the SSE-2 flag; otherwise, it works fine.
19:59:59 <dons> BMeph: very interesting.
20:00:05 <EvilTerran> dejones__, it's a load of what're effectively "implement an algorithm to do <x> efficiently" problems, of widely varying difficulty
20:00:10 <dons> BMeph: thanks.
20:00:20 <dejones__> EvilTerran: cool
20:00:41 <dejones__> thanks everyone
20:00:48 <dejones__> EvilTerran: thanks again, that was really great.
20:00:51 <dejones__> :)
20:00:51 <EvilTerran> my pleasure :)
20:00:54 <dejones__> this channel has super helpful people.
20:00:54 <dejones__> :)
20:01:32 <EvilTerran> ddarius, ISTR it comes from the days when you could ask the express train to stop at an obscure station it was passing by sounding a certain whistle
20:01:41 <dejones__> well, I must go.... more to do before sleep
20:01:44 <bos> we try to make up for the initial difficulties of the language by being nice.  once you graduate, we give you the secret password for #haskell-grumpy
20:01:44 <dejones__> thanks eveyrone
20:01:48 <dejones__> cya
20:01:48 <dejones__> :)
20:01:56 <dejones__> bos: haha, I knew there was a catch!
20:01:57 <dejones__> ;)
20:02:07 <EvilTerran> there were the normal trains, which stopped everywhere, and the whistle-stop trains, which didn't, and so were faster
20:02:08 <BMeph> dons: Sure. It might just be that my chip set is too weak to handle it, but there it stands.
20:02:19 <EvilTerran> dejones__, we'll be seeing you soon :)
20:02:22 <dons> BMeph: or gcc bugs
20:02:23 <EvilTerran> </creepy-voice>
20:02:30 <dejones__> but, it is frustrating... I believe I understand recursion fairly well, but implementing it in Haskell is challenging for me.
20:02:35 <dejones__> hehe
20:02:36 <dejones__> :D
20:02:53 <dejones__> cya!
20:02:58 <smack__> EvilTerran: http://en.wikipedia.org/wiki/Whistle_stop_train_tour
20:03:16 <EvilTerran> indeed. also "whistle stop"
20:03:48 <BMeph> dons: I don't know - like I said, it's running fine w/o the -f option. I'm in the middle of running the pi test now.
20:05:01 <dons> the pi test is really fast on my core 2 duo, but dog slow on a p4
20:05:07 <dons> fun how much this code stresses the cpus
20:05:30 * ddarius hates darcs hunks that combine different "patches".
20:05:47 <dons> BMeph: like so slow i'm not sure its going to terminate on a p4 :)
20:07:03 <dons> BMeph: ./pi 10000000  4.16s user 0.00s system 99% cpu 4.165 :)
20:07:07 <BMeph> dons: Heh-heh. Hopefully, my 2 gigs will let it finish sometime tonight. At least the rest of my processes are running smoothly. Unlike my work computer... ;p
20:07:17 <dons> but on a p4 its more like 4 minutes (something ridiculous different in the architecture)
20:09:05 <BMeph> dons: Hmm, I think it's just using one processor - my system was pegged at 53% CPU usage for a bit.
20:09:32 <dons> oh, its not parallel or anything
20:10:16 <dons> actually, looks like 'n' is a bit high for that test :)
20:11:53 <BMeph> dons: It finished. Not sure what its resource usage is, I'll try a profile.
20:12:37 <dons> oh, its just hammering the fp unit
20:13:56 <vincenz> @src tails
20:13:56 <lambdabot> tails []         = [[]]
20:13:56 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
20:16:11 <ddarius> One last source file to add Haddock documentation to.
20:16:56 <dejones_> question
20:16:58 <dejones_> :)
20:17:18 <dejones_> so, pure functional programming languages, their functions don't have any "side-effects..."
20:17:40 <dejones_> and if I read this correctly, the benefit is that a function will always give the same output for a particular input
20:17:57 <pheaver2> dejones_: sounds right :)
20:20:15 <dons> dejones_: well, the benefits actually follow from that.
20:20:19 * Twey ponders.
20:20:32 <Twey> How is randomness implemented in Haskell?
20:20:33 <dons> in terms of ease of rearranging code, evaluating it in different ways, testing it, refactoring it
20:20:41 <Twey> Oh, silly question.
20:20:47 <dons> Twey: so pseudo-random number generators are functions from g -> (a,g)
20:20:58 <dons> they take a state, and yield a new random, and a new generator state
20:21:15 <ddarius> Hmm?  Should I remove 'squares' which has been deprecated for God knows how long now?
20:21:16 <dons> so System.Random passes generators around, yielding new elements as you need them
20:21:31 <Twey> And that's the basis of monads, right?  That state.
20:21:37 <ddarius> Twey: No
20:21:42 <Twey> Damn.
20:21:51 <dons> this need to thread values around between each computation can be encoded in a monad
20:21:58 * Twey still doesn't quite "get" monads.
20:22:00 <dons> which hides the plumbing
20:22:01 <ddarius> Twey: That particular pattern can be captured in a particular monad, but it isn't the idea of monads.
20:22:28 <dons> so,   let (a,g') = random g in let (b, g'') = random g' in (a,b)   -->  do a <- random ; b <- random ; return (a,b)
20:23:08 * Twey nods, pretends to understand, and goes to look for more documentation.
20:23:10 <EvilTerran> well, you've got to get g in there somehow, but yeah
20:25:22 <oerjan> @hoogle squares
20:25:23 <lambdabot> Text.ParserCombinators.Parsec.Token.squares :: TokenParser st -> CharParser st a -> CharParser st a
20:27:13 <vincenz> @hoogle (Eq a) => [a] -> Bool
20:27:14 <lambdabot> Prelude.null :: [a] -> Bool
20:27:14 <lambdabot> Data.List.null :: [a] -> Bool
20:27:14 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:43:20 <levi> If I have a monadic action with no useful value, do I need to explicitly 'return ()' or can I just leave that out?
20:43:20 <lambdabot> levi: You have 1 new message. '/msg lambdabot @messages' to read it.
20:43:56 <dons> levi: if it returns () on its own, you can leave it at that.
20:43:59 <dons> it'll still return ()
20:44:51 <Cale> levi: By default, it returns the result of the last action in the chain.
20:44:54 <levi> Ahh, looks like put already does that.
20:46:31 <levi> Thanks!
20:47:13 <levi> I was having trouble the other night figuring out how to create a helper function I needed to clean up some code.  It's amazing what a little sleep will do for the thought processes...
20:50:26 <Tac-Tics> What is the point of the WrappedMonad typeclass? I see Monad m => Functor (WrappedMonad m) in Control.Monad, but I don't see why it's not just Monad m => Functor m
20:53:35 <gigamonkey> dons: you're one of the co-authors of Real World Haskell, yes?
20:55:31 <levi> Is there a way to pattern match multiple patterns to a single value?
20:55:48 <glguy> case?
20:56:02 <Twey> gigamonkey: And you're the owner of gigamonkeys.com/book, yes?
20:56:15 <gigamonkey> Twey: yes.
20:56:29 * Twey sends much gratitude in gigamonkey's direction.
20:56:36 <levi> I've only used case <var> of <pattern> -> <value>; <pattern> -> <value>... what's the syntax for multiple patterns to the same value?
20:56:38 <gigamonkey> Twey: glad you liked it.
20:56:48 <Twey> Heh
20:56:59 <Twey> s/owner/author/, sorry.
20:57:10 <levi> gigamonkey: How's the book of interviews going?
20:57:17 <Twey> But yes, I learnt CL from that book.  Much appreciated.  :-)
20:58:22 <gigamonkey> levi: I'm preparing to interview Josh Bloch tomorrow. And I've been scheduling an intensive set of interviews on the East Coast and in Europe in March.
20:58:36 <gigamonkey> Including Simon Peyton-Jones.
20:58:44 <levi> That ought to be fun. :)
20:58:45 <gigamonkey> So I'll be hacking some Haskell between now and then.
20:58:53 <dobblego> ?type ap
20:58:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:59:00 <levi> I enjoy watching his videoed interviews.
20:59:01 <Pseudonym> Tell him happy birthday from all of us.
20:59:23 <gigamonkey> Pseudonym: well, it'll be a couple months late by then. But I can wish him a Happy Easter.
20:59:27 <Pseudonym> And we're throwing him a party when he turns 60.
21:00:05 <dobblego> ?hoogle (Monad m) => Int -> m a => [m a]
21:00:07 <lambdabot> Prelude.repeat :: a -> [a]
21:00:07 <lambdabot> Data.List.repeat :: a -> [a]
21:00:07 <lambdabot> Prelude.tail :: [a] -> [a]
21:00:12 <dobblego> ?type replicateM
21:00:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:00:22 <levi> Hmm, silly me.  The Haskell Report is better at describing the syntax of Haskell than random googled webpages.
21:05:03 <Tac-Tics> What the heck do some and many do in Control.Applicative?
21:05:05 <Tac-Tics> :t some
21:05:07 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
21:05:08 <Tac-Tics> > some [1,2,3]
21:05:11 <lambdabot>  Exception: <<loop>>
21:05:15 <Tac-Tics> > some Nothing
21:05:16 <lambdabot>  Nothing
21:05:21 <sjanssen> @src some
21:05:22 <lambdabot> some v = some_v
21:05:22 <lambdabot>   where many_v = some_v <|> pure []
21:05:22 <lambdabot>         some_v = (:) <$> v <*> many_v
21:05:37 <Tac-Tics> sjanssen: way to take my question and make it obvious... ish =-P
21:05:40 <sjanssen> @src (<|>) []
21:05:41 <lambdabot> Source not found. I am sorry.
21:05:50 <sjanssen> @src [] (<|>)
21:05:51 <lambdabot> Source not found.
21:06:43 <sjanssen> well, it's (++), I think
21:07:08 <Tac-Tics> for [a], yeah ++
21:07:14 <sjanssen> Tac-Tics: I think this combinator really just makes sense for parsers
21:07:30 <ddarius> Tac-Tics: Indeed, look at many in Parsec's documentation.
21:07:57 <sjanssen> oh, and IO perhaps!
21:08:15 <sjanssen> some getLine -- get lines until an exception (like EOF)
21:08:43 <Tac-Tics> No instance for (Alternative IO) =-(
21:09:00 <sjanssen> it could easily be, just copy the MonadPlus instance
21:09:55 <Tac-Tics> Ah, MonadPlus => Alternative (WrappedMonad m)
21:09:57 <Tac-Tics> er
21:09:58 <Tac-Tics> yeah
21:10:26 <Tac-Tics> Why does it use a wrapper for monads? I asked that a little earlier and no one was around
21:11:34 <ddarius> You can't write the instance you suggested instead.
21:12:09 <sjanssen> Tac-Tics: that is what we call an "overlapping instance"
21:12:27 <Tac-Tics> I'll leave it at that then for now
21:12:48 <sjanssen> Haskell doesn't allow these by default, because it becomes difficult to determine which instances are actually used
21:13:06 <ddarius> Parsec haddocked.
21:13:42 <pattern> why does "Prelude> square x = x * x" give me an error:  "<interactive>:1:9: parse error on input `='"  ?
21:13:48 <sjanssen> say I write "instance Monad Foo" and "instance Functor Foo" -- the blanket instance you suggested will overlap
21:14:07 <sjanssen> ddarius++ that is great, people have been requesting that for years
21:14:28 <Tac-Tics> Yeah, I get that
21:14:28 <sjanssen> pattern: you can use "let square x = x * x"
21:14:37 <pattern> ah
21:14:38 <pattern> thank you
21:14:43 <pattern> but why do i need let?
21:14:50 <Tac-Tics> @let square x = x * x
21:14:51 <Tac-Tics> > square 4
21:15:05 <lambdabot> thread killed
21:15:07 <lambdabot>  thread killed
21:15:15 <Tac-Tics> buh?
21:15:16 <Tac-Tics> weird
21:15:19 <sjanssen> pattern: ghci doesn't accept bindings, only expressions (and 'do' syntax statements, which is why let is allowed)
21:15:34 <pattern> ah
21:15:35 <Tac-Tics> ghci pretends you are writting your main function as you go
21:15:41 <Tac-Tics> (sorta kinda)
21:16:13 <pattern> thanks again
21:21:07 <pattern> "Prelude> let foo x y = if x > y then x" returns "<interactive>:1:29: parse error (possibly incorrect indentation)"
21:21:30 <pattern> how do i indent while in ghci?
21:21:45 <pattern> and isn't there another way (with "{}" ?) to do this without indenting it?
21:22:17 <Cale> pattern: If you're writing anything longer than a couple lines, it's best to just stick it into a file and load it.
21:22:32 <Cale> pattern: You can otherwise use semicolons and braces in place of layout.
21:22:39 <pattern> i'm actually writing just a couple of lines at this point :)
21:23:02 <Cale> Your parse error is caused due to the lack of an else clause
21:23:12 <Cale> You can just write the else on the same line.
21:23:15 <pattern> ah
21:23:23 <pattern> hmm
21:23:26 <BMeph> pattern: Haskell doesn't let you just do if-then, it makes you do the whole if-then-else.
21:23:32 <pattern> right
21:24:59 <goalieca> Korollary, not going so well for the canucks
21:25:05 <goalieca> but we just tied it up
21:25:10 <goalieca> i mean.. within 1 goal
21:25:12 <goalieca> lol
21:26:21 <pattern> so how would i write a max function (which returns the maximum of two numbers) ?   i got this far:  "let max x y = if x > y then x else if x < y then y else _________?"
21:27:00 <Twey> pattern: If they're equal it doesn't matter which you return
21:27:08 <pattern> ah
21:27:10 <pattern> good point :)
21:27:14 <Twey> pattern: let max x y = if x > y then x else y
21:27:49 <pattern> though, another way of looking at it is if they're equal than neither of them is greater, so there should be an exception
21:27:54 <pattern> but i'll leave that for later :)
21:28:13 <ddarius> > max 1 1
21:28:16 <lambdabot>  1
21:28:16 <Twey> It's not a highly useful way of looking at it, although I suppose possibly mathematically more accurate
21:29:06 <ddarius> Twey: Mathematically every pair has a maximum.
21:29:26 <pattern> "maximum" meaning greater than the other member of the pair?
21:29:35 <Twey> Ah, OK
21:29:49 <ddarius> maximum being the greatest element of the pair.  It doesn't matter if they are equal.
21:29:51 <Twey> pattern, "maximum" meaning the greatest value in the set, I presume
21:30:24 <pattern> ok, well, if you ignore the case where they are equal, of course every pair has a maximum
21:30:44 <pattern> but, i didn't mean for this to turn in to a mathematical flamewar... :)
21:31:12 <pattern> i'll slink back to my haskell tutorial...
21:31:15 <pattern> thanks for your help!
21:31:54 <Tac-Tics> Twey, you may also want to consider these two notions:
21:31:54 <Tac-Tics> > "AND of an empty list is " ++ show (and []) ++ ", but OR of an empty list is " ++ show (or [])
21:31:57 <lambdabot>  "AND of an empty list is True, but OR of an empty list is False"
21:32:54 <Twey> Tac-Tics, I'm not quite sure I get the notion of unary and/or, could you explain it?
21:33:02 <Twey> (sorry, I'm new)
21:33:05 <Tac-Tics> It's ok
21:33:14 <Tac-Tics> > and [True, False, True]
21:33:15 <lambdabot>  False
21:33:26 <Tac-Tics> it takes a list and &&'s everything together
21:33:29 <Twey> Ah
21:33:32 <Tac-Tics> > and [True, True, True]
21:33:33 <lambdabot>  True
21:33:34 <Twey> As if with foldl?
21:33:40 <Tac-Tics> @src and
21:33:41 <lambdabot> and   =  foldr (&&) True
21:33:45 <Tac-Tics> yup ;-)
21:34:02 <Tac-Tics> but the choice to make and [] = true is somewhat arbitrary
21:34:04 <Twey> So the difference between the two is that and has an initial value of True, but or has an initial value of False
21:34:10 <Twey> Hmm, I see
21:34:11 <Tac-Tics> but that's the way it's done because the math is slightly nicer
21:34:28 <Twey> Pragmatics, then.  OK, that's good.
21:34:32 <Tac-Tics> @src or
21:34:33 <lambdabot> or    =  foldr (||) False
21:34:44 <Twey> Ah
21:34:48 <Twey> @src and
21:34:48 <lambdabot> and   =  foldr (&&) True
21:34:51 <Twey> Yes
21:34:55 * Twey nods.
21:35:08 <Twey> Makes sense.  In a way.
21:35:37 <Tac-Tics> also, min and max have list fold equivalents maximum and minimum
21:35:44 <Tac-Tics> > minimum [1..100]
21:35:45 <lambdabot>  1
21:35:51 <Tac-Tics> > maximum [1..100]
21:35:52 <lambdabot>  100
21:36:29 <Tac-Tics> folds are so cool, heh
21:37:17 <Cale> similarly:
21:37:20 <Cale> > product []
21:37:21 <lambdabot>  1
21:37:22 <Cale> > sum []
21:37:22 <lambdabot>  0
21:37:43 <Twey> Tac-Tics, they can create such very obscure code if abused correctly :-D
21:37:57 <Tac-Tics> oh yes
21:38:01 <ddarius> @check \xs -> and xs == minimum xs
21:38:04 <lambdabot>  Exception: Prelude.minimum: empty list
21:38:16 <ddarius> Stupid minimum
21:38:40 <ddarius> @check \xs -> not (null xs) ==> and xs == minimum xs
21:38:41 <lambdabot>  OK, passed 500 tests.
21:39:50 <Tac-Tics> Haskell is king of the one liners. And one lining is one of the habits of a good obfuscatorer
21:40:13 <cityseek1r> hello
21:40:24 <shachaf> cityseek1r: Hello.
21:40:27 <Cale> hello cityseek1r, learning Haskell?
21:40:34 <cityseek1r> I was wondering if anyone could help me with xmobar
21:40:49 <cityseek1r> yep I got a real awesome xmonad going here
21:40:58 <cityseek1r> might have to submit it
21:41:01 <Cale> :)
21:41:03 <Pseudonym> Please do.
21:41:13 <Cale> Perhaps arossato can help? :)
21:41:25 <cityseek1r> I've basically got http://www.haskell.org/haskellwiki/Xmonad/Config_archive/Robert_Manea%27s_xmonad.hs this xmonad.hs
21:41:27 <lambdabot> Title: Xmonad/Config archive/Robert Manea's xmonad.hs - HaskellWiki, http://tinyurl.com/22sqpw
21:41:51 <shachaf> cityseek1: You might want to try #xmonad.
21:42:22 <cityseek1r> and I would like to add a laptop battery indicator to the status bar
21:42:53 <cityseek1r> I have this laptop script http://dzen.geekmode.org/wiki/wiki.cgi/-main/DzenBatteryMeter
21:42:56 <lambdabot> Title: DzenBatteryMeter
21:43:50 <cityseek1r> instead of having too bars of the same color I would like to have it conjoined using possibly xmobar
21:44:52 <shachaf> cityseek1r: xmobar is separate from dzen.
21:45:14 <cityseek1r> in the xmonad.hs there is a defaultPP that I think goes to the status bar
21:45:19 <cityseek1r> via dzen
21:45:21 <shachaf> cityseek1r: It draws its own statur bar.
21:45:26 <shachaf> cityseek1r: Yes.
21:45:41 <cityseek1r> could I add to that status bar
21:45:46 <cityseek1r> ?
21:45:58 <shachaf> cityseek1r: Yes, but that's possibly tricky.
21:46:22 <shachaf> cityseek1r: DynamicLog is meant to print information that's specific to xmonad.
21:46:27 <cityseek1r> what would be better I spent alot of time getting xmobar in hope of helping make it easier
21:47:02 <cityseek1r> can I add the laptop bat script to DynamicLog
21:47:05 <shachaf> cityseek1r: (Perhaps go on in #xmonad?)
21:47:25 <shachaf> cityseek1r: You could, but that's probably not ideal.
21:47:33 <shachaf> cityseek1r: What's wrong with using two bars?
21:47:52 <cityseek1r> I dont know
21:48:17 <cityseek1r> except that my bar is constantly updated with the cur dir path
21:48:30 <cityseek1r> and I am afraid it will overwrite it
21:49:03 <cityseek1r> maybe i will just start a seperate dzen in .xinitrc
21:49:14 <shachaf> cityseek1r: Is there any reason you're not /joining #xmonad? This is a bit off-topic here. :-)
21:49:22 <shachaf> cityseek1r: Yes, that's what I do.
22:16:31 <vincenz> what is -- | in haddock?
22:18:49 <bos> beginning of a doc comment
22:19:48 <vincenz> bos: used for functions?
22:20:06 <bos> or values.
22:20:54 * vincenz nods
22:22:04 <lispy> "-- |" is also, something you should use! ;)
22:25:23 <pastorn> first lession of modern algebra today...
22:25:28 * pastorn is nervous
22:25:50 <lispy> pastorn: suck it up, groups are good
22:26:14 <lispy> pastorn: you will like it, and it will make sense...no need to be nervous
22:26:46 <pastorn> i've been looking some in the book by Durbin, and that gives me plenty of reasons to fear
22:26:56 <ddarius> Why would you be nervous about a lesson?
22:27:19 <ddarius> "Oh no!  Someone might l'arn me!"
22:27:35 * lispy threatens to learn ddarius
22:27:50 <pastorn> more the fact that i might sit there totally clueless
22:27:58 <pastorn> for FOUR HOURS
22:28:05 * pastorn leaves
22:28:11 <lispy> ddarius: so i read that blog monochrom posted, and it makes more sense to me now...the problem is really with kinds
22:28:23 <lispy> four hour lesson is long
22:28:40 <pastorn> lispy: no shit, sherlock :p
22:28:51 <lispy> pastorn: i'm not sherlock ;)
22:28:57 <lispy> i'm lispy!
22:28:58 <ddarius> lispy: That is essentially the issue.
22:29:24 <lispy> ddarius: chalk up just another thing that java generics are worthless for doing
22:30:03 <lispy> ddarius: C++ and Haskell have really useful type parameters, and I guess even C# parameters are more useful than Java's.
22:30:23 <lispy> ddarius: and why? Because they didn't want to break source compatibility?
22:30:38 <lispy> that reminds me of another dreadful language...fortran.
22:31:13 <dobblego> lispy, you mean higher-ranks?
22:31:51 <lispy> dobblego: yeah you have two kinds available in java, right? * and * -> *
22:31:52 <dobblego> Java dunrite (read: Scala) has higher-ranks
22:31:59 <dobblego> lispy, correct, sadly
22:32:53 <lispy> yeah, scala fixes many of java's problems.  But, given my personal experience with scala, I'm very hesitant to recommend it on the job.  (Unfortunately, same with haskell.)
22:33:10 <dons> you'd not recommend haskell? why's that?
22:33:16 <diltsman> Is there a way to call haskell from .NET?
22:33:17 <jsnx> lispy: for the same reasons?
22:33:18 <lispy> So, I guess I'm stuck doing all my professional type level programming in C++ for the time...
22:33:22 <jsnx> diltsman: no
22:33:29 <jsnx> diltsman: not yet
22:33:29 <dons> diltsman: via C perhaps
22:33:35 <lispy> jsnx: overlapping and different reasons.
22:33:36 <dons> oh, there's aja's .NET binding...
22:33:48 <dons> you'll have to contact him about it -- he'd be done with it by now , i think
22:33:50 <Shimei> I was reading an article on NFAs (http://swtch.com/~rsc/regexp/regexp1.html) and was wondering: is the regex-dfa implementation that the Text.Regex library mentions using the Thompson method?
22:33:50 <jsnx> diltsman: there is a nice discussion on why it's not good, somewhere on the ghc pages
22:33:51 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
22:34:17 <dobblego> there is no reason to use Java, in light of Scala
22:34:36 <jsnx> lispy: well, i think there's basically two kinds of reasons...language reasons and platform reasons
22:34:38 <ddarius> dobblego: Legac codebase
22:34:45 <dobblego> ddarius, refutable
22:35:08 <jsnx> lispy: do you think haskell has essential flaws, or just incidental ones?
22:35:15 <lispy> dobblego: if you have a team of programmers who know and can maintain Scala, I would say that's true.  What, I'm getting at is, if you're only concern is purely technically issues I agree.  But, there is the 'team' and 'human' factors involved.
22:35:22 <dobblego> ddarius, I am using one of the most archaic Java legacy codebases right now; with Scala
22:35:45 <lispy> jsnx: my co-workers have flaws which get in the way more than any of the Haskell flaws.
22:35:51 <jsnx> lispy: lolz
22:36:00 <ddarius> lispy: Get new coworkers.
22:36:01 <dobblego> lispy, I do not advocate pandering to the stupids, but ymmv
22:36:02 <Shimei> lispy: So are you saying Haskell is simply too hard to understand for your average team of programmers?
22:36:17 <dons> they don't have the training.
22:36:25 <lispy> Shimei: They could learn it.  But, like dons said.
22:36:30 * Shimei thinks those are ridiculously low standards for an industry that claims it is even a cousin of engineering. :\
22:36:37 <diltsman> jsnx: Why what isn't good?
22:36:42 <dobblego> Shimei, so true
22:37:05 <lispy> but, training issues aside, there are acceptance issues.
22:37:45 <dobblego> you mean, pandering to illogical arguments
22:37:48 <BMeph> "Type systems are hard - let's go shopping!"
22:38:16 <lispy> dobblego: and, one other personal experience problem I had with scala.  I ran into enough problems with it, that I'm very hesitant to say that the implemenation has the polish to be ready for use by large organizations.
22:38:37 <dobblego> lispy, you made mistakes
22:39:08 <lispy> dobblego: i crashed the compiler a couple times
22:39:21 <dobblego> lispy, I do it several times a day
22:39:29 <lispy> well, that's not cool.
22:39:35 <jsnx> diltsman: don't understand your question
22:39:38 <dobblego> it is *still* far superior to Java, even if it crashed ten times more
22:39:39 <lispy> not when you have deadlines to meet
22:40:07 <dobblego> the type checker crashing on a type error is no different to a type checker that passes on an error (Java)
22:40:15 <jsnx> dobblego: maybe the stability is a deal killer in some applications, even if it superior overall
22:40:28 <diltsman> jsnx: you had said, "there is a nice discussion on why it's not good, somewhere on the ghc pages"
22:40:35 <dobblego> so should we stop fixing the type checker? what do we have then? Ruby?
22:40:35 <jsnx> diltsman: oic
22:40:39 <sjanssen> dobblego: I think that is quite inaccurate
22:40:59 <sjanssen> dobblego: when the type checker crashes, how do you know that it is your error and not the compiler's?
22:41:01 <jsnx> dobblego: can't you just have one that works?
22:41:14 <ddarius> You need to have faith in your coding infrastructure.
22:41:14 <dobblego> to crash Scala's type checker, you have to attempt something that is not even possible with Java
22:41:23 <ddarius> dobblego: That's irrelevant.
22:41:30 <dobblego> sjanssen, it is always your error, because it always has been
22:41:37 <jsnx> diltsman: i barely remember -- the long and short of it is, the CLR does match up well with Haskell notions of data, so the binding is inefficient
22:41:53 <sjanssen> dobblego: if the type checker crashes occasionally on errors, how can I have any confidence that it doesn't silently accept some other types of error?
22:41:59 <dobblego> sjanssen, there does not exist a case where a valid typed program crashes the compiler
22:42:04 <jsnx> s/does match/does not match/
22:42:08 <jsnx> :)
22:42:12 <ddarius> dobblego: How do you know?
22:42:12 <dobblego> sjanssen, for the same reason you do for Haskell
22:42:16 <lispy> jsnx: correct, the CLR can't encode some haskell-isms
22:42:16 <sjanssen> dobblego: oh.  Got a proof for that? :P
22:42:29 <dobblego> ddarius, like I said, many many times per day
22:42:40 <dobblego> sjanssen, no, just anecdotal evidence and bug reports :)
22:42:54 <hpaste>  ich pasted "fr thomas" at http://hpaste.org/5149
22:43:00 <ddarius> dobblego: That you've crashed the compiler many times a day is not even evidence that it only crashes on bad code.
22:43:04 <sjanssen> dobblego: there have certainly been cases where GHC crashes on valid input.  And I don't believe you if you say that isn't true of scala too
22:43:18 <dobblego> ddarius, and for every single one of those crashes, and those crashes of other people, it was my type error
22:43:32 <dobblego> sjanssen, neither I nor lispy has seen such a case
22:43:46 <jsnx> > let f = either (: []) (++ []) in ""
22:43:48 <lambdabot>  ""
22:43:52 * lispy takes dobblego words out of his mouth
22:43:54 <jsnx> what should is use either for?
22:44:17 <ddarius> jsnx: Was that sentence supposed to mean anything?
22:44:18 <jsnx> let's not have another scala battle
22:44:19 <sjanssen> jsnx: either is used to deconstruct an Either
22:44:22 <lispy> dobblego: I don't even remember if the crashes I saw were related to types, could have been syntax for all I care.
22:44:35 <jsnx> ddarius: i'm trying to figure out what it's for :)
22:44:38 <jsnx> sjanssen: oic
22:44:38 <dobblego> lispy, I'm making a pretty good guess what they were about
22:45:01 <dobblego> lispy, they have likely been fixed; you have to bend the language pretty hard to crash it now
22:45:08 <jsnx> scala is a good language
22:45:13 <jsnx> it is fighting the good fight
22:45:19 * jsnx hugs scala
22:45:31 <dobblego> there are no battles, just irrational arguments
22:45:39 <vincenz> @hoogle none
22:45:39 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
22:45:40 <lambdabot> Text.ParserCombinators.Parsec.Expr.AssocNone :: Assoc
22:45:40 <lambdabot> Foreign.C.Error.eNONET :: Errno
22:45:45 <dobblego> they aren't my first encounter with them :)
22:45:47 * dobblego gone
22:45:58 <dons> jsnx: that's true enough.
22:45:59 * lispy sighs
22:46:01 <vincenz> @type all
22:46:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:46:04 <sjanssen> dobblego: I think your advocacy is teetering on the edge of irrationality
22:46:18 <jsnx> sjanssen: that's the battle i'm talking about :)
22:46:40 <jsnx> dobblego: it's not scala, but rather scalists that frighten me
22:46:43 <sjanssen> but this is getting majorly off topic :)
22:46:49 <jsnx> sjanssen: yes ;)
22:46:55 <lispy> sjanssen: you're right
22:47:03 <lispy> so, how about those existentials?
22:47:06 <jsnx> they are at the tip of the sword
22:47:23 <jsnx> so, let's cut them some slack
22:47:28 <lispy> seen any generalized algebriac datatypes lately?
22:47:43 <jsnx> i mean, seriously, they get it from both sides -- from #java and #haskell...
22:47:49 <dons> heh
22:48:01 <ddarius> I've not seen anyone complain about Scala here.
22:48:18 <jsnx> ddarius: i was being metaphorical
22:48:34 <lispy> ddarius: I've complained about being bruised by it
22:48:42 <lispy> but, i try to keep it sane/ration.
22:48:46 <lispy> rational*
22:48:56 <jsnx> ddarius: but it has happened here -- like when richy_clarkson came in here because i criticized his article, on reddit
22:48:57 <lispy> I would consider using it again, FWIW
22:49:15 <jsnx> it was a little strange
22:49:29 <ddarius> jsnx: I'm more worried about "established" or "long time" members of the Haskell community.
22:49:30 <lispy> dons: how are things?
22:49:37 <jsnx> ddarius: sure
22:49:39 <lispy> dons: I heard a rumor you live not too far from me these days.
22:49:46 <jsnx> ddarius: they don't do it, probably
22:50:01 <lispy> dons: if that's true, we should do lunch some time
22:50:13 <jsnx> ddarius: but it has happened
22:50:26 <vincenz> @type equal
22:50:28 <lambdabot> Not in scope: `equal'
22:50:32 <vincenz> @hoogle equal
22:50:34 <lambdabot> System.FilePath.Windows.equalFilePath :: FilePath -> FilePath -> Bool
22:50:34 <lambdabot> System.FilePath.Posix.equalFilePath :: FilePath -> FilePath -> Bool
22:50:34 <lambdabot> Language.Haskell.TH.PprLib.equals :: Doc
22:50:46 <lispy> vincenz: what are you thinking of?
22:50:51 <lispy> ?type (==)
22:50:51 <vincenz> lispy: all equal
22:50:53 <lambdabot> forall a. (Eq a) => a -> a -> Bool
22:51:03 <lispy> :t all (==)
22:51:04 <ddarius> jsnx: Okay then let me say something else: I'm sure tha Scala gets massively more support from the Haskell community than flak.
22:51:05 <lambdabot>     Couldn't match expected type `Bool'
22:51:05 <lambdabot>            against inferred type `a -> Bool'
22:51:05 <lambdabot>     In the first argument of `all', namely `(==)'
22:51:06 <vincenz> lispy: was just checking the name
22:51:09 <vincenz> lispy: no
22:51:15 <vincenz> (Eq a) => [a] -> Bool
22:51:17 <jsnx> ddarius: i don't know enough either way
22:51:34 <jsnx> my personal reaction to it is disgust ;)
22:51:56 <jsnx> i've had to reign it, because i recognize the work they are doing for all of us
22:52:02 <lispy> ddarius: I bet you're right.  Martin Ordesky(sp?) seems like a sharp tack.
22:52:09 <jsnx> s/reign it/reign it in/
22:52:09 <vincenz> lispy: here, with the best possible optimizations
22:52:10 <vincenz> equal []            = True
22:52:10 <vincenz> equal [x]           = True
22:52:10 <vincenz> equal (x:xs@(y:_))  = x==y && equal xs
22:52:18 <ddarius> jsnx: Martin Odersky came out of the Haskell community.  We like him.
22:52:25 <jsnx> ddarius: oic
22:52:41 <sjanssen> vincenz: I doubt that's the fastest way
22:52:41 <jsnx> ddarius: did not know the history there
22:52:50 <vincenz> sjanssen: feel free to gimme a faster one :)
22:53:03 <sjanssen> vincenz: equal (x:xs) = all (x ==) xs; equal _ = True
22:53:21 <sjanssen> @src all
22:53:22 <lambdabot> all p =  and . map p
22:53:24 <vincenz> ooh, nice
22:53:27 <sjanssen> @src and
22:53:28 <lambdabot> and   =  foldr (&&) True
22:53:40 * vincenz wonders why that's not foldl'
22:53:42 <sjanssen> it might even fuse under foldr/build
22:53:58 <sjanssen> vincenz: because && is conditionally strict in the second argument
22:54:05 <vincenz> oh right
22:54:05 <ddarius> vincenz: It shouldn't be foldl' it should be foldr.
22:54:38 * vincenz returns to his hacking
23:07:55 <dons> yay, benl's effect inference compiler's getting open sourced.
23:08:05 <dons> now we can tear it up, and get an effect checker for ffi code :)
23:08:20 <lispy> effect checker?
23:08:53 <dons> something that'd do my assertions of purity on peek/poke code for me :)
23:09:11 <lispy> nice
23:09:17 <lispy> google is not finding it
23:09:38 <ddarius> Ben Lippmeier?  /me is mostly guessing
23:09:52 <dons> yep
23:12:29 <ddarius> Oh, dons.  I finished making the Parsec reference guide haddock documentation.  When the code.haskell.org project is made I'll throw a darcs repo up there and ask for feedback.
23:12:47 <ddarius> If nothing major comes up I'll put it on Hackage.
23:12:57 <dons> awesome.
23:12:57 <ddarius> And announce it.
23:13:53 <sjanssen> ddarius: are you also working on the parsec generalization stuff too?
23:14:29 <ddarius> sjanssen: That's the code I'm working with.
23:15:01 <ddarius> I didn't write any of it and currently I'm aiming at getting something out the door before, perhaps, adding other stuff.
23:15:28 <lispy> generalization to what? bytestrings?
23:15:47 <ddarius> lispy: Any "stream" type, including bytestrings and to a ParsecT monad transformer.
23:15:55 <lispy> very cool
23:15:56 <sjanssen> ddarius: cool.  Doing release work is just as important the code, I'd say
23:16:56 <ddarius> A bytestring Parsec is something I've wanted to see for a long while now so it's not too much to get it the last leg.
23:17:12 <ddarius> Haddock documentation for Parsec is something I've wanted to see for even longer.
23:21:19 <lispy> right
23:21:42 <lispy> I remember trying to hack on parsec when bytestrings were released and I just didn't have the time/energy to figure out parsec
23:22:44 <sjanssen> ddarius: any performance tests?  My 45 min. parsec generalization effort didn't fare so well
23:23:13 <ddarius> sjanssen: Unfortunately, no.  That's something I really want to see.
23:23:38 <ddarius> However, that's something I'm willing to put effort into improving if necessary.
23:23:48 <olsner> if this was C++, parsec could've been written for iterators from the get-go and we wouldn't be here ;-)
23:24:08 <ddarius> olsner: Lazy lists -are- iterators.
23:24:44 <ddarius> Also it's necessary to be able to "rerun" iterators at "old" values to implement Parsec.
23:26:08 <ddarius> Is there anywhere on the wiki, say, that links to all the Parsec "clones" in other languages?
23:26:54 <lispy> how many languages have parsec clones?
23:27:10 <lispy> iirc python does, and maybe spirit (in boost) is related (but i've never looked at it)
23:27:36 <ddarius> Ruby, Java, Erlang, C++, Python, O'Caml, probably SML too, I think C# and F#
23:27:51 <ddarius> Those are ones I can think of off the top of my head.
23:29:05 <ddarius> Hmm, now that I think about it, you could probably do a rather decent implementation in XSLT.
23:41:44 <Taejo> @src replicateM
23:41:45 <lambdabot> replicateM n x = sequence (replicate n x)
23:41:55 <Taejo> @src sequence
23:41:56 <lambdabot> sequence ms = foldr k (return []) ms
23:41:56 <lambdabot>     where
23:41:56 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
23:46:58 <Taejo> I have a function getWords :: IO (Set String) which reads in a wordlist; I want to load the wordlist into GHCi, but when I do `dict <- getWords', it prints the whole dictionary out, which takes a while
23:47:06 <Taejo> is there a way to stop the printing?
23:47:54 <Botje> there's an option you can set to stop it from printing
23:49:11 <jsnx> wow -- i found a haskell filesystem
23:49:12 <sjanssen> :set -fno-print<Tab complete> :)
23:49:14 <jsnx> http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
23:49:15 <lambdabot> Title: Continuations and delimited control
23:49:26 <jsnx> it's copy on write, &c.
23:49:32 <Botje> warning, do not venture any further
23:49:38 <Botje> okmij.org holds sure brain splattage.
23:49:47 <jsnx> Botje: why?
23:53:32 <jsnx> Botje: i've been reading sigfpe, so to find a paper about filesystems after a long bout of differentiating types was a relief
