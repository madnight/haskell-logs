00:26:12 <vladimir_trs> Hello?
00:26:38 <Twey> Hi!
00:27:15 <vincenz> how do yu expert everything except for a few thigns?
00:27:40 <Zao> Make an intermediary module that import Blah hiding (omg,wtf,bbq) ?
00:27:48 * vincenz wrinkles his nose
00:28:08 <sjanssen> vincenz: what is wrong with hiding?
00:28:19 <sjanssen> oh, *export* everything
00:28:28 * vincenz ndos
00:28:38 <vincenz> be nice if you could do
00:28:44 <vincenz> module Foo(all hiding ...)
00:28:46 <vincenz> or some such
00:28:48 <Twey> Hahaha
00:29:05 <sjanssen> vincenz: perhaps put all the hidden stuff in a separate module
00:29:40 <vincenz> it's just two stupic small unctions
00:29:47 * vincenz can't type :|
00:40:43 <vladimir_trs> How do you write a function of a type like SomethingSomething -> IO () ?
00:41:01 <vladimir_trs> What's the last statement?
00:44:38 <Lemmih> vladimir_trs: return () ?
00:45:37 <vladimir_trs> Lemmih: cool, thank you :)
00:48:23 <Zao> Just about any IO action can have it's result ignored to produce IO (), can't it?
00:51:17 <doserj> @type (>> (return ()))
00:51:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
00:52:38 <opqdonut> @type fmap (const ()) :: (Monad m) => m a -> m ()
00:52:40 <lambdabot>     Could not deduce (Functor m) from the context (Monad m)
00:52:40 <lambdabot>       arising from use of `fmap' at <interactive>:1:0-14
00:52:40 <lambdabot>     Possible fix: add (Functor m) to the expected type of an expression
00:52:41 <vladimir_trs> That's what I'm trying to do: to write a function which modifies a hash table and returns nothing...
00:52:50 <opqdonut> well, anyways
00:53:07 <opqdonut> that _would_ work with the proposed new class hierarchy
00:55:10 <doserj> opqdonut: but it does sth different
00:55:28 <opqdonut> yeah i was just thinkin
00:55:39 <opqdonut> it misses some of the side-effects right?
00:55:52 <opqdonut> compared to (>> return ())
00:58:07 <doserj> even the return value is different :)
00:58:27 <doserj> (think of the [] monad)
00:59:24 <opqdonut> oh, indeed
00:59:26 <opqdonut> stupid me
01:05:57 <Botje> @tell ndm searching for </> in hoogle doesn't html-escape the function, so you get something like "System.FilePath.Posix () :: ..."
01:05:57 <lambdabot> Consider it noted.
01:06:54 <Botje> > fix ((1:) . scanl (+) 1)
01:06:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:08:01 <Botje> > takeFileName "foo/bar"
01:08:02 <lambdabot>   Not in scope: `takeFileName'
01:09:43 <quicksilver> doserj: eh?
01:09:49 <quicksilver> > [1,2,3] >> return ()
01:09:52 <lambdabot>  [(),(),()]
01:09:55 <quicksilver> > fmap (const ()) [1,2,3]
01:09:55 <lambdabot>  [(),(),()]
01:10:00 <quicksilver> doserj: don't see what's different?
01:13:55 <doserj> ups
01:14:09 <quicksilver> @src liftM
01:14:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:14:32 <opqdonut> yeah isn't fmap for monads usually liftM?
01:14:34 <doserj> stupid me :)
01:14:37 <opqdonut> hehe
01:15:14 <Cale> If they're ever not the same thing, something is very wrong.
01:17:28 <vincenz> @hoogle apply
01:17:29 <lambdabot> Data.Dynamic.dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
01:17:29 <lambdabot> Control.Arrow.ArrowApply :: class Arrow a => ArrowApply a
01:25:10 <quicksilver> gosh some of the comments on the book are daft
01:25:16 <quicksilver> no offence to any of the commentors :P
01:27:09 * quicksilver wants to add a meta-comment "Ignore all comments by FR, they all serve to make the book worse"
01:27:46 <therp> quicksilver: which book?
01:28:02 <Vq^> real world haskell?
01:28:36 <quicksilver> therp: there is only one book :)
01:28:58 <quicksilver> therp: http://www.haskell.org/pipermail/haskell-cafe/2008-January/038430.html
01:29:07 <lambdabot> Title: [Haskell-cafe] Draft chapters of "Real World Haskell" now publicly available, http://tinyurl.com/33gohk
01:29:15 <Vq^> quicksilver: Njals saga? :)
01:34:17 <ivanm> are they going to list more linux distros in "how to install ghc"?
01:34:40 <ivanm> or just assume that the people most likely to have to be shown how to install ghc are those using fedora, debian and their derivatives?
01:34:48 <quicksilver> if you believe they should then make a comment :)
01:40:38 <ivanm> quicksilver: I did! :p
01:44:55 <mux> I'm as far from it as I can possibly behttp://reddit.com/r/programming/info/665dh/comments/
01:44:59 <mux> oups
01:45:01 <mux> http://reddit.com/r/programming/info/665dh/comments/
01:49:57 <tibbe> is unicode escape codes withing strings part of haskell prime?
01:50:25 <quicksilver> unicode strings are haskell98
01:50:51 <tibbe> quicksilver: oh? what's the syntax
01:51:05 <tibbe> quicksilver: I'm reading Real World Haskell and it's not mentioned
01:51:14 <tibbe> i.e. something like \u0058
01:51:37 <quicksilver> > chr 400
01:51:40 <lambdabot>  '\400'
01:51:44 <quicksilver> like that :)
01:51:50 <tibbe> > "\400"
01:51:51 <lambdabot>  "\400"
01:51:59 <tibbe> > length "\400"
01:51:59 <lambdabot>  1
01:52:17 <tibbe> > print "\400"
01:52:17 <lambdabot>  <IO ()>
01:52:30 <tibbe> hmm
01:52:38 <quicksilver> putStr is only 8-bit
01:52:43 <quicksilver> but Strings are unicode
01:52:46 <tibbe> right
01:52:52 <tibbe> so "\0058"
01:52:55 <tibbe> > length "\0058"
01:52:58 <lambdabot>  1
01:53:01 <tibbe> ah goodie
01:53:14 <tibbe> so that would be the 0x58 unicode point?
01:53:25 <sjanssen> @undo [x | x <- xs]
01:53:25 <lambdabot> concatMap (\ x -> [x]) xs
01:53:38 <sjanssen> @. redo undo [x | x <- xs]
01:53:39 <lambdabot> concatMap (\ x -> [x]) xs
01:53:59 <quicksilver> tibbe: no, the 58th unicode point
01:54:05 <quicksilver> tibbe: it's decimal not hex
01:54:14 <nominolo> ugh, Subversion sucks
01:54:20 <quicksilver> > chr 0x58
01:54:21 <lambdabot>  'X'
01:54:26 <Zao> tibbe: \0058 is octal.
01:54:30 <quicksilver> tibbe: I think you want "\88"
01:54:44 <nominolo> i can't figure out how to properly merge without having to manually track down revision numbers :/
01:54:57 <quicksilver> Zao: in what language?
01:55:03 <quicksilver> Zao: in haskell, it's decimal.
01:55:07 <sjanssen> hmm.  What should @undo transform list comprehensions into: >>= or concatMap?
01:55:30 <Zao> quicksilver: Why are you where ##iso-c++ is supposed to be in my IRC client? :)
01:55:37 <quicksilver> ;)
01:57:01 <tibbe> quicksilver: got it
02:09:15 <sjanssen> does >> have a name?
02:09:20 <Cale> 'then'?
02:09:38 <sjanssen> preferably not a Haskell keyword :)
02:09:47 <sjanssen> 'then' does sound good, though
02:09:49 <Cale> thenM
02:09:49 <quicksilver> 'the sequencing operator' ?
02:10:05 <quicksilver> 'thenDo'
02:10:07 <quicksilver> 'andDo'
02:10:11 <quicksilver> 'andThen'
02:10:13 <sjanssen> thenDo, probably
02:10:15 <Cale> I think they used to call it thenM, back before the Monad class
02:10:39 <quicksilver> Cale: although much of the time they were too busy dodging the dinosaurs to program monadically.
02:11:02 <sjanssen> I'm abstracting out the literal use of ">>" in @undo so it can be used for both list comps and do syntax
02:11:04 <Cale> haha
02:22:16 <jedbrown> sjanssen: We need a standard multi-dimensional array format which is binary compatible with C, for using with numerics libraries.  Hmatrix has Data.Packed which has 1D and 2D versions using ForeignPtr, but with extra optimizations/complications for 2D with regards to lazy transpose and vectorization.  Do you think we should use Data.Array.Storable, an extension to StorableVector, or something entirely new?
02:26:22 <sjanssen> jedbrown: mutable arrays?
02:27:36 <jedbrown> sjanssen: No.  There isn't an immutable interface with Data.Array.Storable otherwise it would be the obvious choice.
02:29:05 <sjanssen> data CArray a = CArray !IndexInfo !StorableVector -- would be okay, I think
02:29:28 <sjanssen> hmm, though I suppose you want IndexInfo to be a type argument
02:31:26 <jedbrown> That was pretty much my original idea.  I just wanted to ask around before running off to implement.
02:31:29 <sjanssen> jedbrown: actually, with this format you probably don't care about slicing, yeah?
02:32:08 <jedbrown> It's not important, but can be gotten for free, I think.
02:32:57 <sjanssen> I don't see how it can be if you want to interoperate with C
02:33:59 <mauke> I want to write functions for thread-friendly file locking
02:34:04 <mauke> which module should I put them in?
02:34:15 <jedbrown> Yes, some libraries have a stride parameter (BLAS/LAPACK and netCDF).
02:34:31 <sjanssen> jedbrown: is a Data.Array.IArray compatible interface useful/desirable?
02:35:12 <sjanssen> @src UArray
02:35:12 <lambdabot> Source not found. Sorry.
02:35:20 <jedbrown> sjanssen: Certainly (!) and amap would be.
02:36:08 <sjanssen> so perhaps you go with data CUArray i e = CUArray (i, i) (ForeignPtr e)
02:36:20 <jedbrown> sjanssen: data UArray i e = UArray !i !i !Int ByteArray#
02:36:45 <sjanssen> jedbrown: right, we clone UArray but use ForeignPtr instead of ByteArray#
02:37:27 <jedbrown> sjanssen: Yes, that is pretty much what Data.Packed is, but specialized to 1D and 2D.
02:41:13 <sjanssen> I wonder why it is...
02:42:48 <jedbrown> sjanssen: He really cares about lazy transposes and vectorizing a few cases, so these are handled explicitly.  Some Lapack functions operate on a transposed matrix, so you can save some copying with some effort.
02:43:11 <jedbrown> sjanssen: I think it is very rarely a bottleneck though.
02:44:07 <sjanssen> jedbrown: how do you generally pass the dimension information to C?  Especially for higher dimensions
02:44:58 <jedbrown> sjanssen: (int ndims, int *dims)
02:46:08 <sjanssen> okay.  With a bit of type class kung fu, you can produce a function "i -> [Int]", where i is any tuple containing Ints
02:46:45 <sjanssen> or any Ix type, even
02:47:06 <jedbrown> sjanssen: I don't know this kung-fu, but perhaps it is similar to the var-arg-fu.
02:51:52 <jedbrown> sjanssen: If you can demonstrate (hpaste) this part, I should be able to handle the rest of the implementation.  (I'm also doing FFTW bindings, so those should be available shortly after this array stuff.)
02:53:56 <sjanssen> jedbrown: hacking on it now
02:54:21 <C-Keen> hm is there a way to ByteString -> Word64 ?
02:54:59 <jedbrown> C-Keen: have you checked out Data.Binary ?
03:00:57 <hpaste>  sjanssen pasted "detuple" at http://hpaste.org/5152
03:01:13 <sjanssen> jedbrown: ^^^
03:01:27 <jedbrown> sjanssen: Thanks.
03:01:43 <sjanssen> it can be done more generally if you're willing to put in the work
03:02:35 <sjanssen> if you'd like to have (Int, Char, Word32) indices, for example
03:03:06 <sjanssen> it can also be done more simply if you decide you only care to use Int
03:03:50 <jedbrown> sjanssen: Aha.  Turns out I could have figured that out after all.  I think [Int] indices are fine and practically speaking, we can write instances for as many dimensions as will be needed.
03:05:10 <C-Keen> jedbrown: hm implementing a get w/o the tag stuff should work...
03:05:22 <sjanssen> instances are slightly shorter (and type signatures nicer) with that simplification: class Detuple a where detuple :: a -> [Int]
03:05:46 <sjanssen> C-Keen: binary provides those functions
03:06:10 <jedbrown> sjanssen: Cool, I'll let you know when I've got something usable.
03:06:11 <quicksilver> :t getWord64
03:06:16 <lambdabot> Not in scope: `getWord64'
03:06:21 <quicksilver> @hoogle getWord64
03:06:24 <lambdabot> No matches found
03:06:27 * quicksilver cries
03:06:44 <sjanssen> C-Keen: see Data.Binary.Get
03:09:33 <Botje> grar. parsec's lack of bytestring support is forcing me to read http requests as String :[
03:10:12 <dcoutts_> what happened to xerox's generalised parsec?
03:10:28 <sjanssen> dcoutts_, Botje: ddarius is working on releasing it
03:11:00 <dcoutts_> sjanssen: ah good
03:11:33 <mauke> would System.IO.Lock be an ok name?
03:12:39 <sjanssen> mauke: if you're locking files, I'd consider something under System.Directory
03:12:47 <mauke> whoa. why directory?
03:13:06 <sjanssen> that's where all the other filesystem functions are
03:13:15 <mauke> no, they aren't
03:13:22 <sjanssen> (other than readFile, and the handle opening functions)
03:13:31 <mauke> locking is in System.Posix.IO
03:13:35 <mux> I'd call that module FileLock rather than just Lock
03:13:42 <mux> to make it more explicit
03:13:45 <Botje> but I need it now to kick some C++ butt :)
03:14:14 <mux> mauke: are you intending to write bindings for lockf(), or flock() or fcntl() based locking? :-)
03:14:26 <mux> the duplication in this area is scary
03:15:07 <mauke> probably fcntl, to be compatible with System.Posix.IO
03:15:13 <mux> ok
03:16:29 <mauke> what the module really does is fork a separate process to do the locking
03:16:45 <mauke> that way it won't pause all haskell threads while waiting for the lock
03:18:27 <sjanssen> mauke: does the locking block the whole proces, or just a single OS thread?
03:18:49 <sjanssen> if the latter, this is sort of why -threaded exists :)
03:19:29 <mauke> it seems to block everything (unless I also need +RTS -N2)
03:19:53 <sjanssen> mauke: the FFI imports may be faulty
03:19:59 <sjanssen> are they marked as "unsafe"?
03:20:23 <sjanssen> (+RTS -N2 is a good way to prove that they are faulty)
03:20:37 <mauke> yep, seems to halt everything
03:21:24 <sjanssen> even with +RTS -N2?
03:21:28 <mauke> yes
03:22:13 <mauke> here's the code: http://rafb.net/p/8MVdnP37.html
03:22:14 <lambdabot> Title: Nopaste - No description
03:28:54 <sjanssen> mauke: how should I test this?
03:29:36 <mauke> oh, hello
03:29:37 <mauke> foreign import ccall unsafe "HsBase.h fcntl" c_fcntl_lock  :: CInt -> CInt -> Ptr CFLock -> IO CInt
03:30:29 <mauke> sjanssen: if you want to try it, you also need http://rafb.net/p/7h8zBZ27.html
03:30:30 <lambdabot> Title: Nopaste - No description
03:30:42 <mauke> this program will lock all files given on the command line
03:31:40 <mauke> running the first program on the same file should print 0, 1, 2, locking ...
03:31:42 <mauke> and hang
03:34:17 <sjanssen> mauke: I think +RTS -N2 should sidestep that stray "unsafe"
03:34:24 <sjanssen> but maybe you should test that to be sure
03:35:15 <mauke> ./a.out +RTS -N10 -RTS dummy  still hangs
04:01:53 <Centurio_42357> http://www.pennergame.de/ref.php?refid=7963124
04:01:53 <Centurio_42357> http://www.pennergame.de/ref.php?refid=7963124
04:01:54 <lambdabot> Title: Pennergame
04:01:54 <lambdabot> Title: Pennergame
04:02:05 <Centurio_42357> http://www.pennergame.de/ref.php?refid=7963124
04:02:05 <lambdabot> Title: Pennergame
04:02:08 <Centurio_42357> http://www.pennergame.de/ref.php?refid=7963124
04:02:09 <lambdabot> Title: Pennergame
04:02:10 <Centurio_42357> http://www.pennergame.de/ref.php?refid=7963124
04:02:11 <lambdabot> Title: Pennergame
04:02:26 <ivanm> Centurio_42357: you right there?
04:02:34 <ivanm> spammer?
04:02:46 <C-Keen> yes
04:02:57 --- mode: ChanServ set +o Cale
04:03:22 <Cale> ugh, full banlist, oh well.
04:03:25 --- mode: Cale set -o Cale
04:03:45 <C-Keen> Cale: banning this dynamic ip would not help
04:03:49 <ivanm> what, heaps of people think we're worth spamming?
04:03:56 <mauke> so remove a few bans
04:04:02 <ivanm> that's kind of a compliment, in a backwards kind of way...
04:04:04 <C-Keen> Cale: banning this ip range and you will get out 50% of german dial up users
04:04:30 <C-Keen> ivanm: typically those bots get a channel list and select the ones with the highest user counts
04:04:38 <ivanm> *nod*
04:04:47 <Cale> C-Keen: usually I'll ban an IP anyway, since there's a possibility the same guy might do another sweep
04:04:48 <ivanm> C-Keen: how do you know all this? experience? :p
04:04:56 <cityseeker> hello
04:05:02 <Cale> hi
04:05:11 <C-Keen> ivanm: that's the way I'd do it :p
04:06:21 <cityseeker> does anybody know how to change the size of the status bar in defaultPP
04:06:28 <cityseeker> xmonad.hs
04:06:30 <RayNbow> C-Keen: I usually prevent a channel from appearing in a channel list by setting +s+p
04:06:43 <mux> dons: around?
04:06:47 <ivanm> cityseeker: why don't you ask this in #xmonad?
04:06:49 <C-Keen> RayNbow: ack
04:06:54 <ivanm> seeing as how you're there and all...
04:06:55 <cityseeker> sorry
04:09:03 <sjanssen> mauke: are you going to report his as a bug?
04:09:11 <sjanssen> (or at least ask GHC HQ about it)
04:09:48 <RayNbow> http://www.realworldhaskell.org/blog/2008/01/21/finally-the-public-beta-programme-begins/ <-- cool :)
04:09:49 <lambdabot> Title: Real World Haskell ป Blog Archive ป Finally, the public beta programme begins!, http://tinyurl.com/yr2clk
04:10:09 <mux> @tell dons in the third chapter of the real world haskell book, when the 'Roygbiv' datatype is defined, there is no deriving Enum clause, is this intentional?
04:10:09 <lambdabot> Consider it noted.
04:10:54 <mauke> sjanssen: no, I'll just write my module
04:11:25 <vincenz> dblhelix: did I meet you?
04:11:51 <sjanssen> mauke: that isn't particularly helpful to the next guy
04:12:09 <sjanssen> (that comes across this bug, that is)
04:12:55 <mauke> no one uses this stuff anyway
04:13:04 <dblhelix> vincenz: when you was in utrecht two weeks ago? no, unfortunately not
04:13:16 <dblhelix> vincenz: I was in san francisco that week
04:13:41 <dblhelix> vincenz: but I hear that you gave a great talk!
04:13:53 <vincenz> dblhelix: Thanks :)
04:14:04 * vincenz should put those slides online
04:14:11 <dblhelix> indeed!
04:19:21 <hpaste>  vincenz pasted "continued fractions blowing my stack" at http://hpaste.org/5153
04:22:42 <Taejo> I'd be very much obliged if somebody could check out my "unmonad tutorial": http://squing.blogspot.com/2008/01/unmonad-tutorial-io-in-haskell-for-non.html
04:22:46 <lambdabot> Title: The Most Fuun You Can Have: Unmonad Tutorial: IO in Haskell without monads, http://tinyurl.com/2ctob5
04:31:26 <czakey> Taejo: IO w/o monads :O
04:31:34 <czakey> good one I think
04:31:54 <czakey> maybe because I don't understand monads yet :f
04:32:06 <mux> well this code is actually using monads
04:32:40 <Taejo> mux: well, obviously you're using monads, but you don't have to understand them
04:32:55 <mux> I find that the title is misleading
04:33:00 <RayNbow> when I first learnt Haskell and had to deal with I/O, I just copied the do-template :p
04:33:19 <Taejo> RayNbow: me too, and my point is that that's just fine
04:33:47 <Taejo> mux: should I change the title to "...without understanding monads"
04:33:54 <Taejo> or "Not Understanding Monads"
04:34:45 * RayNbow keeps forgetting that Ctrl+D is EOF in Linux and Ctrl+Z is EOF in Windows...
04:35:15 <RayNbow> (Ctrl+D is EOT in Windows)
04:35:23 <Taejo> EOT?
04:35:25 <RayNbow> and GHCi doesn't like EOT
04:35:32 <RayNbow> End of Text, iirc
04:35:55 <RayNbow> or wait
04:36:04 * RayNbow just looks it up to be sure :p
04:36:15 <RayNbow> End of Transmission
04:36:49 <mux> Taejo: I think it would make more sense, but maybe that's just me
04:37:00 <RayNbow> the Windows version of the Python interpreter accepts both EOF and EOT
04:37:23 <Taejo> mux: I've changed it
04:37:26 <Taejo> I get your point
04:37:56 <Taejo> I'm just trying to get rid of the idea that Haskell makes you learn category theory to do IO
04:38:07 <Taejo> when IO in Haskell is actually pretty easy
04:38:21 <mux> at first I thought your blog post was about some heavy hackery to do IO without monads, god knows how
04:38:26 <mux> uniqueness types or whatever :-)
04:38:39 <doserj> "It loops forever, so returns (), ..." that is not quite right, though
04:38:43 <Vq^> i thought so first as well
04:38:52 <Taejo> doserj: true
04:38:55 <Vq^> passing around theworld state or something...
04:39:07 <mux> RealWorld# !
04:39:55 <Vq^> it's to early to tell whether the world is real... :o)
04:39:58 <Taejo> I've actually been thinking about implementing other IO styles (stream IO, continuation IO, etc) with monadic IO
04:40:12 <doserj> "a, on its own, executes the action a and discards the result." is maybe a bit misleading
04:40:24 <Taejo> doserj: laziness?
04:40:46 <Vq^> doserj: isn't that true in the IO monad?
04:40:52 * mux notes that with all the comments from people in here, Taejo may change his mind and conclude that one actually has to understan monads to do IO ;-)
04:41:15 <Taejo> mux: I'm not heading that way yet
04:41:55 <Taejo> doserj: how about It loops forever, so we give it the return type <code>()</code>, the empty tuple, which is used like <code>void</code> in Haskell.
04:42:02 <doserj> Taejo, Vq^: no. the result just doesn't get bound to a name (yet).
04:42:30 <Taejo> doserj: I don't understand
04:42:38 <Vq^> doserj: how could you retrieve it later?
04:42:40 <Taejo> oh, right
04:42:44 <vincenz> > signum (-1.5)
04:42:47 <lambdabot>  -1.0
04:42:48 <doserj> Taejo: if a is the last statement, for example
04:42:49 <mux> Taejo: saying that "let n = v" is *assigning* v to n is also misleading
04:42:54 <oerjan> :t let loop = print "looping" >> loop in loop
04:42:56 <lambdabot> forall b. IO b
04:42:56 <Taejo> yeah, ok
04:43:07 <Vq^> doserj: ah, yes, thats true
04:43:27 <mux> :t let loop = forever (print "looping")
04:43:27 <lambdabot> <no location info>:
04:43:27 <lambdabot>     not an expression: `let loop = forever (print "looping")'
04:43:28 <Taejo> mux: I guess so... what word is better
04:43:41 <vincenz> > signum 0
04:43:41 <lambdabot>  0
04:43:44 <mux> Taejo: talk about it in terms of name bindings
04:43:51 <Taejo> oerjan: I know we can give it any type, but () is the sensible one
04:43:55 <mux> this binds the name 'n' to the value 'v'
04:44:11 <mux> :t forever (print "looping")
04:44:12 <lambdabot> Not in scope: `forever'
04:44:24 <mux> bah, LB still hasn't been built with GHC 6.8.2
04:44:52 <Taejo> mux: let n = v binds n to the value v.
04:44:59 <mux> sounds good to me
04:45:17 <Taejo> mux: do you really think one has to understand monads to do IO in haskell?
04:45:25 <mux> no, I was only kidding :-)
04:45:26 <mux> though...
04:45:43 <mux> though I wouldn't say that one doesn't need to understand _anything_ about monads to do IO
04:46:02 <mux> otherwise you end up not understanding why each line in a do block must be of type IO a, or other subtleties like this
04:46:14 <Taejo> that's true
04:46:18 <mux> it really helps to understand the do-notation desugaring, at least
04:46:35 <qebab> you definitely don't have to understand monads to do IO, but I'm pretty sure it would help you seperate your IO completely from your actual program
04:46:43 * qebab doesn't understand monads
04:46:44 <qebab> ):
04:46:47 <Vq^> and it will be hard to interpret existing programs that use liftM2 with friends
04:46:54 * mux nods
04:48:24 <Taejo> I started to understand monads when I was using parsec
04:48:26 * mux notes one of the most enlightening papers he read that helped him understand monads is the 'Tackling the Awkward Squad' from Simon Peyton-Jones
04:49:11 <mauke> you can completely understand haskell's IO system without even having heard of "monads"
04:49:14 <Taejo> I thought, there must be a better way than to have `do {a <- foo; b <- bar; return $ f a b}' all over the place
04:49:31 <Taejo> maybe one of the liftM or >>= or something will help
04:49:34 <mux> f <$> a <*> b ? :)
04:49:41 <faxathisia> Better in what way?
04:49:46 <mux> or return f `ap` a `ap` b
04:49:50 <mux> but that's more old-school
04:49:51 <Taejo> faxathisia: less typing
04:50:01 <faxathisia> Use copy and paste :P
04:50:11 <faxathisia> That code looks fine to me
04:50:19 <Botje> liftM2 f a b
04:50:22 <Botje> \o/
04:50:27 <Taejo> faxathisia: I follow Wu's Principle
04:50:39 <Taejo> Write it out once: fine
04:50:39 <Botje> ehh
04:50:44 <Botje> foo and bar instead of a and b
04:50:47 <Botje> but meh :)
04:50:52 <mux> I vote for f `fmap` foo `ap` bar
04:50:54 <Taejo> Copy-paste it once: start thinking of an abstraction
04:51:07 <Taejo> Copy-paste it a second time: don't copy-paste it a second time
04:51:11 <osfameron> is `ap` also Welsh for "son of" ?
04:51:23 <Taejo> osfameron: I believe so
04:51:25 <mux> you son of a bar !
04:51:40 <mux> makes up for interesting insults
04:51:52 <RayNbow> <Taejo> I started to understand monads when I was using parsec <-- I started to understand when I watched a certain channel9 vid :p
04:51:54 <Taejo> @src (<*>)
04:51:54 <lambdabot> Source not found.
04:52:07 <mux> @src (IO a) (<*>)
04:52:07 <lambdabot> Source not found. :(
04:52:10 <mux> dang
04:52:14 <mux> @src IO (<*>)
04:52:15 <lambdabot> (<*>) = ap
04:52:20 <Taejo> @src ap
04:52:20 <lambdabot> ap = liftM2 id
04:52:39 <Taejo> @src liftM2
04:52:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:52:49 <Taejo> A-HA, liftM2 is the primitive
04:53:12 <faxathisia> liftM2 f m1 m2 = f `fmap` m1 `ap` m2โจ
04:53:21 <mux> Taejo: btw, in the same vein as my previous remark, 'n <- a' performs a, and then *binds* n to the result of the action (no assignment here still)
04:53:45 <Taejo> mux: d'oh!
04:53:48 <qebab> @src liftM
04:53:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:54:34 <oerjan> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:54:35 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
04:55:10 <mux> bah, there's nothing more annoing than watching some crappy pseudo-raid SATA card rebuilding an array
04:55:14 * mux yawns
04:55:27 <mux> it's surprisingly slow
04:55:41 * SamB wonders what he did with his 7400 datasheets...
04:57:08 <SamB> oh well. I guess I can remember "5 volts = good, not 5 volts = bad" well enough, and I printed out this sheet with the pinouts of the gate chips...
05:00:52 * Vq^ has a collection
05:03:52 <faxathisia> Does anyone know an algorithm to decide whether or not it's possible to make some combinator as a composition of other combinators?
05:04:18 <faxathisia> I found a slow.. rubbish way, which doesn't terminate if it's impossible
05:04:46 <Taejo> faxathisia: I would guess, in general, that it would fall foul of Rice's Theorem
05:05:04 <Taejo> http://reddit.com/r/programming/info/667yk/comments/
05:10:48 <faxathisia> How does Rice's Theorem apply?
05:12:06 <Taejo> it doesn't directly
05:14:42 <oerjan> i would imagine it falls foul of the halting problem...
05:15:25 <faxathisia> say you have a basis, [S,K], and the input was (\x->x), It could output SKK
05:15:26 <oerjan> for some x, you will never know whether x x gives you anything
05:15:48 <oerjan> er, bad timing
05:15:54 <faxathisia> (or maybe the input being a -> a makes more sense)
05:16:01 <oerjan> my x = general starting combinator
05:18:33 <faxathisia> hmm. I don't understand
05:18:52 <faxathisia> Why does it matter if x x gives something?
05:19:12 <RayNbow> x x?
05:19:21 <oerjan> if you start with basis [x], how do you know if it contains anything other than x?
05:19:25 <RayNbow> somehow that reminds me of a certain lambda expression
05:19:37 <oerjan> it is probably undecidable whether x x = x
05:19:39 <RayNbow> (\x -> x x) (\x -> x x) :p
05:20:08 <mauke> (\x -> (\_ -> x x)) (\x -> (\_ -> x x))
05:21:29 <faxathisia> Well I thought it would be possible from just working with the types of the combinators
05:21:57 <mauke> a@(a -> a)
05:22:06 <oerjan> if you have types you cannot construct Y from S,K
05:24:06 <quicksilver> well if you have higher-ranked types you can do anything
05:24:26 <quicksilver> if you're prepared to instantiate 'a' with a higher ranked type in a -> a, you're fine, I believe.
05:24:26 * mux nods
05:24:34 <mux> you can type fix with System F, but not with PCF
05:25:12 <faxathisia> What is PCF?
05:25:24 <mux> simply-typed lambda calculus
05:25:47 <mux> I actually have no idea what the acronym means
05:26:42 <oerjan> http://en.wikipedia.org/wiki/Programming_language_for_Computable_Functions
05:26:43 <lambdabot> http://tinyurl.com/3y7pzt
05:26:51 <mux> ooooh.
05:26:56 <faxathisia> If I were to use higher ranked types, Then the method would use higher order unification wouldn't it?
05:28:11 <mux> oerjan: so PCF is actually a real programming language, thus simply-typed lambda calculus + some base types?
05:28:28 <mux> I seem to remember that Pierce states that PCF == simply typed lambda calculus in TAPL
05:28:39 <oerjan> i don't know anything about it, i just googled :D
05:28:44 <mux> heh.
05:29:15 * mux notes PCF is also Parti Communiste Francais *giggle*
05:29:52 <mux> that's it: "The language PCF is an extension of simply-typed lambda calculus with booleans, natural numbers, and recursion."
05:30:02 <sarah_> does && short circuit
05:30:10 <mux> so simply typed lambda calculus + some base types + fix
05:30:14 <oerjan> sarah_: yep
05:30:23 <oerjan> @src &&
05:30:23 <lambdabot> True  && x = x
05:30:23 <lambdabot> False && _ = False
05:30:24 <mux> sarah_: would be pretty lame if a lazy language wouldn't be lazy about this one, wouldn't it? :-)
05:30:46 <sarah_> haha yeah
05:31:04 <faxathisia> seems very likely this is undecideable then
05:31:07 <oerjan> sarah_: as you see, the second line never looks at x
05:44:53 <phlpp> > @src not
05:44:54 <lambdabot>  Parse error at "@src" (column 1)
05:44:57 <phlpp> @src not
05:44:57 <lambdabot> not True   =  False
05:44:57 <lambdabot> not False  =  True
05:45:02 <phlpp> :>
05:55:31 <vincenz> Anyone have some clean code on how to use quickcheck?
05:56:58 <Lemmih> vincenz: bytestring, xmonad?
05:57:14 <vincenz> xmonad uses a really custom driver
05:58:32 <mauke> how do I read from a file descriptor into memory?
05:59:04 <vincenz> so does bytestring, grr
06:03:07 <doserj> vincenz: test_Module = runTests "Module.hs" defOpt [run prop1, run prop2, ...]
06:07:16 <vincenz> @hoogle pritn
06:07:16 <lambdabot> No matches found
06:07:18 <vincenz> @hoogle printf
06:07:19 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
06:07:19 <lambdabot> Text.Printf :: module
06:07:19 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
06:07:25 <vincenz> doserj: thx
06:11:00 <cnwdup> I am going through the X window programming in Haskell Tutorial (HaskellWiki), but I experience several examples that aren't working for me. No I am facing the problem that a function returns IO Pixel but the return value is given a function which expects Pixel (without the IO part). How do I "extract" Pixel from IO Pixel?
06:11:32 <Zao> x <- px
06:11:49 <byorgey> cnwdup: you can do what Zao suggests as part of a do block.
06:12:01 <vincenz> doserj: what is coarbitrary for?
06:12:10 <kaol> the trick is to lift functions expecting a Pixel into the IO monad, not the other way around
06:12:10 <byorgey> do { pixel <- getPixel ; something with pixel ... }
06:12:33 <koeien> cnwdup: example, do { pixel <- getpixel; ... pixel ... }
06:13:04 <koeien> i.e. if you want to print a fixel, you can have a function
06:13:12 <oerjan> vincenz: generating functions that take that type as argument
06:13:14 <koeien> cwndup: do { pixel <- getpixel; print pixel }
06:13:29 <cnwdup> Ah, thank you. (-:
06:13:31 <byorgey> cnwdup: you can also use >>= :  getPixel >>= (function of type Pixel -> IO something)
06:13:38 <vincenz> oerjan: any idea on how to define one for Data.Ratio?
06:13:45 <ndm> hi, i can't get to: http://haskell.org/ghc/docs/latest/html/libraries/filepath/System-FilePath-Windows.html
06:13:45 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:13:46 <lambdabot> http://tinyurl.com/yoalut
06:13:48 <ndm> can anyone else?
06:13:57 <vincenz> oerjan: or even to generate arbitrary Ratio's (such that denom /= 0)
06:14:04 <cnwdup> pixel <- initColor (which returns IO Pixel) is working perfectly.
06:14:08 <ndm> http://haskell.org/ghc/docs/latest/html/libraries/filepath/ -that links to the page, suggesting it is there
06:14:10 <ndm> @messages
06:14:10 <lambdabot> Botje said 5h 8m 13s ago: searching for </> in hoogle doesn't html-escape the function, so you get something like "System.FilePath.Posix () :: ..."
06:14:16 <Zao> ndm: Works for me.
06:14:48 <ndm> @tell Botje very good point, will have a hack at that later on today
06:14:48 <lambdabot> Consider it noted.
06:14:49 <byorgey> ndm: works ok for me too.
06:15:14 <Botje> ndm: thanks :)
06:15:15 <lambdabot> Botje: You have 1 new message. '/msg lambdabot @messages' to read it.
06:15:19 <Botje> lambdabot: i know, silly.
06:16:48 <BMeph> What's up, IO Haskell? ;)
06:16:54 <ndm> thanks, smaking the refresh buttong harder works in the end
06:17:20 <oerjan> vincenz: for arbitrary you could just steal the Double instance, which essentially makes a fraction anyway
06:17:39 * vincenz nods at oerjan 
06:17:52 <byorgey> BMeph: return "yo"
06:18:22 <BMeph> byorgey: :)
06:18:34 <oerjan> for coarbitrary i think you could also do something similar...
06:18:40 <BMeph> Maybe I should've said,
06:18:47 <oerjan> Double:   coarbitrary x = coarbitrary (decodeFloat x)
06:18:52 <BMeph> What'sUp :: IO Haskell
06:19:13 <oerjan> which essentially turns the Double into something else, then uses the coarbitrary for that
06:19:22 <oerjan> so i think for Rational:
06:19:48 <oerjan> coarbitrary x = coarbitrary (numerator x, denominator x)
06:19:53 <oerjan> should work
06:20:10 <oerjan> :t numerator
06:20:20 <lambdabot> forall a. (Integral a) => Ratio a -> a
06:27:43 <BMeph> Just wondering, if you have a two-argument function, is there some way to get the system to check that the function's base case converges to the same value based on either partial derivation?
06:28:16 * quicksilver peers at BMeph curiously.
06:28:31 * oerjan adds a "huh?"
06:28:33 <BMeph> quicksilver: Yeah, I bet. ;)
06:28:58 <BMeph> Okay, let me try to explain that more clearly... :)
06:29:33 <ricky_clarkson> @check \x y -> x+y==(flip (+)) y x
06:29:34 <lambdabot>  Add a type signature
06:29:54 <ricky_clarkson> @check \x y -> (x :: Integer)+(y :: Integer)==(flip (+)) y x
06:29:55 <lambdabot>  OK, passed 500 tests.
06:30:06 <pejo> BMeph, I'll take a stab: halting problem in the general case. But please explain.
06:30:13 <ricky_clarkson> Do you mean like that?
06:31:39 <Japsu> @type ?รถ . ?รถ >>> ?รถ $ ?รถ
06:31:41 <lambdabot> parse error on input `?'
06:31:50 <Japsu> @type รถ? . รถ? >>> รถ? $ รถ?
06:31:52 <lambdabot> parse error on input `.'
06:32:05 <Japsu> @type o? . o? >>> o? $ o?
06:32:06 <lambdabot> parse error on input `.'
06:32:17 <Japsu> @type ?a
06:32:19 <lambdabot> forall t. (?a::t) => t
06:32:32 <Japsu> @type ?o . ?o >>> ?o $ ?o
06:32:33 <lambdabot> :(b -> b) -> b,
06:32:33 <lambdabot>         arising from use of implicit parameter `?o' at <interactive>:1:5-6
06:32:43 <Japsu> :o
06:33:43 <oerjan> :t \o -> o . o >>> o $ o
06:33:46 <lambdabot>     Occurs check: cannot construct the infinite type: c = c -> c
06:33:46 <lambdabot>     Probable cause: `o' is applied to too few arguments
06:33:46 <lambdabot>     In the second argument of `($)', namely `o'
06:34:07 <oerjan> > (0$0 >>>)
06:34:08 <lambdabot>      The operator `>>>' [infixr 1] of a section
06:34:08 <lambdabot>         must have lower prece...
06:34:33 <BMeph> Let's say, I'm doing a function that takes two integers, and gives you a list of lists, going from one to the first argument, with the second argument being the  number of sub-lists.
06:34:41 <oerjan> that parses as ((o . o) >>> o) $ o
06:35:47 <Japsu> hmm
06:36:44 <oerjan> @src (->) (>>>)
06:36:44 <lambdabot> f >>> g = g . f
06:37:00 <oerjan> so it's essentially (o . o . o) o
06:37:16 <oerjan> which doesn't type because o o never does
06:37:23 <RayNbow> heh, http://book.realworldhaskell.org/beta/ responds slowly... it takes a considerable amount of time to expand the comments :p
06:37:32 <lambdabot> Title: Real World Haskell
06:37:51 <BMeph> I want to state that funky 0 0 =[], without getting an "Overlapping Instances" warning, but without having to suppress any overlapping instances that might be elsewhere in the module.
06:38:35 <oerjan> BMeph: instances?  there are no classes involved?
06:38:52 <oerjan> patterns for a function are always matched top to bottom
06:39:34 <BMeph> oerjan, no, just the function definition. I think that's the complaint I'm getting, it's been a while since I've worked on this module.
06:39:38 <zeno> how does is IO monad printing NOT a side effect
06:40:58 <oerjan> > let f x = 3; f 1 = 5 in f
06:41:01 <lambdabot>      Warning: Pattern match(es) are overlapped
06:41:01 <lambdabot>              In the definition...
06:41:07 <oerjan> you mean that?
06:41:08 <quicksilver> zeno: obviously printing is a side effect, in a sense. But the point is that the IO monad makes the side-effect explicit.
06:41:28 <quicksilver> zeno: so it's not a side-effect as far as the type system is concerned.
06:41:32 <oerjan> it warns because the second match can never happen
06:41:32 <quicksilver> it's an explicit effect
06:41:39 <quicksilver> Int -> Int is different to Int -> IO Int
06:41:53 <oerjan> since the first always takes precedence
06:43:16 <oerjan> in that case, either the overlapping pattern is redundant, or the order of patterns _really_ matters, i think
06:44:54 <acura> @src null
06:44:55 <lambdabot> null []     = True
06:44:55 <lambdabot> null (_:_)  = False
06:45:55 <BMeph> > let f a b = a* (a+b) in f 0 0
06:45:58 <lambdabot>  0
06:46:00 <RayNbow> hmm, why is the second pattern (_:_) and not just _?
06:46:11 <koeien> RayNbow: that would be equivalent
06:46:12 <quicksilver> some people think it looks nicer
06:46:15 <quicksilver> is more explicit
06:46:19 <quicksilver> no difference, though
06:46:21 <koeien> RayNbow: but it would be overlapping with the first one
06:46:40 <koeien> RayNbow: i.e. [] matches _ but does not match (_:_)
06:46:53 <RayNbow> hmm, true...
06:47:06 * RayNbow is lazy though, so he prefers typing _ :p
06:47:12 <byorgey> there's no problem with overlapping patterns, though.  the first one that matches is picked.
06:47:21 * byorgey would use _ too =)
06:47:22 <koeien> it is a bit nicer imo, since then the order doesn't matter
06:47:29 <koeien> but i'm lazy as well :)
06:47:59 <RayNbow> this channel is full of lazy people :p
06:48:07 <Saizan> with -Wall you'd get a warning using _
06:48:11 <koeien> yeah we've chosen the right programming language :)
06:48:30 <mauke> Saizan: what?
06:48:33 <koeien> Saizan: yes some projects want to compile w/o warnings, in that case you need (_:_)
06:48:46 <Saizan> mauke: am i wrong?
06:48:55 <mauke> I hope so
06:50:50 <koeien> huh? i thought you would get a warning :/ but ghc 6.6.1 doesn't give one
06:51:16 <aFlag> I wouldn't expect a warning either
06:51:23 <byorgey> yup, no warnings
06:51:25 <byorgey> I just tried it
06:51:55 <byorgey> you get a warning if you leave out a case, though.
06:51:57 <koeien> ghc is smarter than i thought :)
06:52:11 <byorgey> then it warns about a non-exhaustive pattern match.
06:52:13 <koeien> yeah or if you have "real" overlap
06:52:17 <koeien> i.e.
06:52:35 <byorgey> ah, true
06:52:48 <byorgey> like if you duplicate the null [] case.
06:52:56 <oerjan> koeien: like my example to BMeph above
06:53:04 <koeien> > let null' (_:_) = False; null' (_:_:_) = False; null' [] = True
06:53:05 <lambdabot>  Parse error at end of input
06:53:11 <oerjan> (overlapping discussion :) )
06:53:20 <koeien> oerjan: yeah, indeed
06:53:29 <aFlag> it's not really about overlaping, but about a definition that will never be reached
06:53:34 <byorgey> warning: discussion(s) are overlapped
06:53:37 <aFlag> whenever that happens
06:53:39 <aFlag> it warns
06:53:39 <koeien> byorgey: lol
06:54:22 <byorgey> aFlag: that's a good way to look at it, I think.
06:54:51 <byorgey> I wonder if there are any cases where a definition actually can't be reached, but ghc can't figure it out.  (excluding guards.)
06:55:12 <oerjan> well the .png looks fine in IE ;)
06:55:18 <oerjan> wrong channel
06:55:57 <koeien> byorgey: i think ghc can compute that? all constructors are known
06:56:18 <thebloggu> can someone help me please?
06:56:35 <byorgey> koeien: yeah, I think you might be right.  on the other hand, using guards it's obviously quite easy to construct such a case.
06:56:40 <thebloggu>  Type found where type variable expected
06:56:44 <thebloggu> i get this error
06:56:47 <thebloggu> in ghc
06:56:53 <koeien> byorgey: indeed
06:56:55 <oerjan> !paste
06:56:55 <hpaste> Haskell paste bin: http://hpaste.org/
06:56:57 <BMeph> ?paste
06:56:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:57:00 <byorgey> thebloggu: can you paste the code that gives this error on hpaste?
06:57:08 <thebloggu> ok
06:58:01 <BMeph> oerjan: I hope you don't get hassled, I've been using your example for generating primes a few times the past few days. :)
06:58:21 <hpaste>  thebloggu pasted "(no title)" at http://hpaste.org/5155
06:58:32 <thebloggu> done
06:58:38 <oerjan> what example?
06:58:48 <BMeph> Well, I saw you use it, so I say it's "yours," whether it originally came from you or not, oerjan. :)
06:58:53 <koeien> thebloggu: you don't need the send BTree definition
06:58:58 <oerjan> if it's the nubBy one i didn't invent it :)
06:59:04 <BMeph> oerjanPrime = nubBy (((>1).).gcd) [2..]
06:59:13 <oerjan> yep
06:59:14 <thebloggu> i thougt i needed
06:59:29 <thebloggu> then i dont need the data btree
06:59:31 <thebloggu> right
06:59:32 <thebloggu> ?
06:59:44 <oerjan> it's just part of our newbie tour :)
06:59:52 <koeien> thebloggu: your first one says, "a BTree a is, for all types a, either a V or a (N a (BTree a) (BTree a))"
07:00:02 <koeien> thebloggu: this is correct
07:00:07 <thebloggu> ok
07:00:18 <koeien> thebloggu: the second one is unnecessary and is implied by the first
07:00:25 <thebloggu> ok
07:00:27 <thebloggu> but then
07:00:31 <thebloggu> i have another error
07:01:03 <koeien> which one?
07:01:13 <thebloggu>  Couldn't match expected type `BTree Int'           against inferred type `Int'    In the second argument of `N', namely `(last (init a))'    In the expression: (N (last a) (last (init a)) (head b))    In the definition of `abin':        abin (a, b) = (N (last a) (last (init a)) (head b))
07:01:22 <thebloggu> wait
07:01:25 <thebloggu> forgot
07:01:30 <thebloggu> to change
07:01:34 <thebloggu> to btree a
07:01:55 <thebloggu>   Couldn't match expected type `a' (a rigid variable)           against inferred type `Int'      `a' is bound by the type signature for `abin'        at estudo_teste.hs:86:31    In the first argument of `N', namely `(last a)'    In the expression: (N (last a) (last (init a)) (head b))    In the definition of `abin':        abin (a, b) = (N (last a) (last (init a)) (head b))
07:01:58 <thebloggu> this one
07:02:13 <byorgey> thebloggu: yup, looks like you need some recursive calls to abin in there somehow?
07:02:28 <thebloggu> like what
07:02:33 <thebloggu> sorry dont understand
07:02:34 <thebloggu> ?
07:02:43 <byorgey> last (init a) is a list, right?
07:02:52 <byorgey> wait, no it isn't.
07:02:54 <koeien> byorgey: no
07:03:03 <thebloggu> yes
07:03:07 <koeien> it's the second last element
07:03:11 <byorgey> sorry.
07:03:11 <BMeph> Right. Calling it newbieTourPrime = ... gets wordy, though. ;)
07:03:11 <thebloggu> a is a list
07:03:28 <koeien> yeah, a is a list, but last (init a) isn't
07:03:29 <thebloggu> then init a
07:03:30 <thebloggu> too
07:03:36 <byorgey> thebloggu: to make a BTree using N, you have to give N something of type a, and two BTrees.
07:03:38 <thebloggu> last returns the last item
07:03:47 <koeien> thebloggu: yes, indeed
07:03:51 <byorgey> thebloggu: but you have N (last a) (last (init a)) (head b).
07:03:57 <thebloggu> yes
07:03:59 <byorgey> last (init a) and head b are not BTrees.
07:04:03 <thebloggu> can't that be a btree
07:04:07 <funktio> @t nubBy
07:04:07 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:04:08 <thebloggu> ?
07:04:10 <thebloggu> ok
07:04:29 <koeien> thebloggu: the data constructor for BTree a says, N a (BTree a) (BTree a)
07:04:38 <koeien> thebloggu: so you need two BTree a's, and one a
07:04:39 <thebloggu> oh
07:04:43 <thebloggu> right
07:04:44 <thebloggu> ok
07:04:44 <oerjan> :t nubBy
07:04:46 <koeien> (in another order)
07:04:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
07:05:09 <funktio> oerjan: thanks :)
07:05:11 <thebloggu> thanks a lot
07:05:13 <thebloggu> ;)
07:05:26 <koeien> thebloggu: np, have fun haskelling something together
07:05:34 <thebloggu> ok
07:05:37 <thebloggu> thanks again
07:06:19 <byorgey> thebloggu: also, you might want to take a look at your bfInorder function, I don't think it is correct. =)
07:06:28 <thebloggu> ok
07:06:31 <thebloggu> thanks
07:07:31 <thebloggu> what's wrong?
07:07:34 <thebloggu> it is working
07:07:35 <thebloggu> i think
07:07:42 <thebloggu> :P
07:07:53 <koeien> thebloggu: i think it's correct as well
07:08:16 <thebloggu> ok
07:08:19 <koeien> thebloggu: i would call it "flatten" though :)
07:08:28 <thebloggu> sorry
07:08:32 <thebloggu> i am a newbie
07:08:40 <thebloggu> what do you mean
07:08:41 <thebloggu> ?
07:09:24 <koeien> thebloggu: it's not important, i am just used to that name
07:09:43 <thebloggu> okok
07:12:45 <vincenz> @hoogle infinity
07:12:45 <lambdabot> No matches found
07:13:53 <oerjan> @hoogle infin
07:13:54 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
07:14:21 <tirpen> Is there any good [n]curses lib for haskell anywhere or should I bother to finally learn the foreign interface?
07:14:33 <oerjan> Infinity is not an actual constructor, just a Read/Show hack
07:15:46 <byorgey> thebloggu: if bfInorder is supposed to give back an inorder traversal of the nodes, it does not give back the nodes in the correct order as it is currently written.
07:16:25 <thebloggu> really?
07:16:29 <thebloggu> i tested
07:18:07 <quicksilver> tirpen: vty
07:18:10 <byorgey> *Main> let t = N 4 (N 2 (N 1 V V) (N 3 V V)) (N 6 (N 5 V V) (N 7 V V))
07:18:10 <byorgey> *Main> bfInorder t
07:18:10 <byorgey> [2,1,3,4,6,5,7]
07:18:18 <byorgey> that should give back [1,2,3,4,5,6,7]
07:18:28 <thebloggu> sorry
07:18:28 <tirpen> Thanks, I'll check it out.
07:18:32 <thebloggu> misunderstood
07:18:35 <quicksilver> tirpen: is a functional interface to curses which some people like.
07:18:51 <thebloggu> it should give the list InOrder
07:18:56 <thebloggu> not an orderes list
07:19:05 <thebloggu> ordered*
07:19:06 <thebloggu> wait
07:19:08 <byorgey> thebloggu: yes, I know
07:19:26 <byorgey> I just happened to make that tree so an inorder traversal happens to be ordered, to make it easier to see what is going on
07:19:35 <thebloggu> ok
07:19:37 <tirpen> That sounds like exactly what I need.
07:20:11 <byorgey> thebloggu: do you see what I'm saying?  Note the leftmost node in that tree is 1 (go left twice).  so that should be first, but the node 2 is first.
07:20:45 <thebloggu> yesyes
07:22:29 <vincenz> regarding hpc, what's the difference between yellow, green and red?
07:22:52 <thebloggu> i used an example
07:22:54 <thebloggu> arv = (Nodo 5 (Nodo 7 (Nodo 3 Vazia Vazia)                                                                                     (Nodo 2 (Nodo 10 Vazia Vazia) Vazia)                                                                             )                                                                             (Nodo 1 (Nodo 12 Vazia Vazia)                                                                                     (Nodo 4 Vaz
07:22:55 <thebloggu>                                                              )
07:22:56 <thebloggu> this one
07:23:15 <thebloggu> should be like this
07:23:52 <mauke> that looks like a syntax error
07:24:41 <thebloggu> preorder arv [5,7,3,2,10,1,12,4,8]
07:24:41 <thebloggu> inorder arv [3,7,10,2,5,12,1,4,8]
07:24:41 <thebloggu> postorder arv [3,10,2,7,12,8,4,1,5]
07:25:05 <thebloggu> and its correct
07:25:49 <smack__> mauke: one of his lines got cut off
07:25:58 <smack__> !paste
07:25:58 <hpaste> Haskell paste bin: http://hpaste.org/
07:27:40 <mauke> what does "undefined reference to `__DISCARD__'" mean?
07:28:03 <byorgey> thebloggu: using the version of bfInorder you pasted on that tree, I do not get [3,7,10,...]
07:28:24 <byorgey> so maybe you pasted the wrong version?
07:28:36 <vincenz> regarding hpc, what's the difference between yellow, green and red?
07:28:40 <vincenz> ack, sorry
07:28:59 <vincenz> yellow = unused, green always true boolean, red always false boolean
07:29:18 <thebloggu> its possible
07:29:22 <thebloggu> i check
07:30:38 <thebloggu> inorder :: ArvBin a -> [a]
07:30:40 <thebloggu> inorder Vazia = []
07:30:53 <thebloggu> inorder (Node x e d) = (inorder e) ++ [x] ++ (inorder d)
07:30:57 <thebloggu> i have this definition
07:31:00 <thebloggu> in my books
07:31:09 <thebloggu> Vazia is V
07:31:21 <byorgey> thebloggu: yes, that one is correct.
07:31:40 <byorgey> thebloggu: the problem with the one you pasted is that you make recursive calls to bf instead of bfInorder.
07:31:52 <thebloggu> lol
07:31:54 <thebloggu> x)
07:31:58 <thebloggu> thanks a lot
07:32:02 <byorgey> sure =)
07:32:20 <thebloggu> i am working too much on haskell
07:32:21 <thebloggu> :p
07:32:42 <byorgey> not possible! ;)
07:32:56 <thebloggu> lol
07:32:57 <thebloggu> ok
07:32:59 <thebloggu> thanks again
07:33:05 <thebloggu> got to go away
07:33:07 <thebloggu> cya
07:33:08 <thebloggu> thanks
07:33:44 <byorgey> bye thebloggu
07:48:59 <yaxu> will a book like "Conceptual Mathematics: A First Introduction to Categories" help me become a better haskell programmer?
07:49:07 <yaxu> and gain deeper understanding of monads and so on
07:49:32 <yaxu> and allow me to gain more from reading CS and FP papers
07:49:49 <mux> I don't know but I'd like you to tell me once you've read it.
07:50:02 <mux> so that I can buy it too if it's good :-)
07:50:08 <yaxu> heh
07:50:15 <ricky_clarkson> I think you need offline access to yor own copy of Cale.
07:50:21 <ricky_clarkson> yoUr..
07:50:37 <mux> yaxu: what I can say is that TAPL (types and programming languages, by b. pierce) helped me a lot
07:50:53 <mux> I'm that kind of guys who need to really understand what's going at the compiler level to feel comfortable with a language
07:51:20 <mux> though of course I'm not pretending to really understand all what's happening in GHC, this book gave me all the basics I needed
07:51:35 <yaxu> mux: and would help with the other things I mentioned?
07:52:24 <fasta> Why can't a function expecting an Int also accept an Int8?
07:52:27 <yaxu> neither in my local university library sadly
07:52:43 <mux> yaxu: sorry? didn't quite get your last question
07:52:47 <smack__> fasta: they're different types
07:53:01 <fasta> smack__: but Int8 is contained in Int.
07:53:27 <yaxu> mux: would TAPL help me gain more from reading CS and FP papers
07:53:28 <mauke> haskell doesn't do subtyping
07:53:44 <smack__> fasta: they're different types.
07:53:48 <fasta> Yes, it doesn't, but is there a reason for it not doing so?
07:53:55 <ricky_clarkson> You might want the function to take an Integral.
07:54:03 <mauke> fasta: yes, it causes implicit type conversions
07:54:14 <doserj> > 127 +1 ::Int8
07:54:14 <lambdabot>  -128
07:54:17 <doserj> > 127 +1 ::Int
07:54:17 <mux> yaxu: TAPL helped me be *able* to read some CS papers
07:54:18 <lambdabot>  128
07:54:30 <mux> yaxu: TAPL introduces the reader to operational semantics
07:54:39 <fasta> mauke: isn't that only of interest when one converts an Int to an Int8, not the other way around?
07:55:00 <smack__> fasta: what if the function was Int -> Int
07:55:12 <smack__> would you also implicitly change the output?
07:55:35 <fasta> The compiler cannot prove that the Int one wants to implicitly convert to Int8 has a proper value at run-time, but the other way around is always safe.
07:55:43 <yaxu> mux: ok thanks, will check it out
07:56:23 <pejo> yaxu, it depends on what kind of papers you want to read. If you want to read type theory papers TAPL is definitely useful. For other cases it might be better to read a book on programming language semantics, or some introduction to lambda calculus.
07:56:53 <doserj> fasta: you can always define a function g = f . fromIntegral
07:56:53 <fasta> smack__: your example makes no sense.
07:56:54 <smack__> fasta: fromIntegral or 'Integral a' exist for this.  magically converting between types isn't good.
07:57:10 <fasta> smack__: "isn't good" is too simplistic.
07:57:14 <quicksilver> fasta: the reason is, that's not haskell's type system.
07:57:22 <quicksilver> fasta: your argumetns are good, and that type system makes sense.
07:57:27 <quicksilver> However, it isn't the one we have.
07:57:30 <fasta> smack__: your example needs to be Int -> Int8 to Int -> Int
07:57:40 <quicksilver> There are certainly problems with inference and contravariance, though.
07:58:02 <quicksilver> I don't believe they're insoluble.
07:58:11 <quicksilver> but they don't give you H-M, or an extension of H-M.
07:58:16 <quicksilver> they give you something with subtyping.
07:58:23 <fasta> quicksilver: what's the etymology of contravariance?
07:59:14 <quicksilver> etymology? latin: contra = against, latin : variantia = difference
07:59:40 <pejo> quicksilver, mmm. Subtyping.
07:59:41 <quicksilver> meaning 'changing (differing) in the opposite direction'
08:01:22 <Taejo> do I need GHC 6.8 to build Yi from Darcs?
08:01:51 <fasta> Taejo: I'd hope the README states that.
08:02:29 <quicksilver> Taejo: I believe you do.
08:02:36 <Taejo> fasta: for some reason less cut off the readme at line 3 last time I tried :)
08:02:49 <Taejo> so yes, it does
08:12:25 <aFlag> freenode acting up again
08:13:43 <Valodim_> this does happen rather often lately
08:15:03 <RayNbow> oh joy, netsplits...
08:18:42 <RayNbow> heh... while I was typing a comment @ the Real World Haskell site... someone else was typing a similar comment (but was faster)
08:20:16 <Cin> :t $!
08:20:18 <lambdabot> parse error on input `$!'
08:20:24 <mux> :t ($!)
08:20:24 <Cin> what is $!?
08:20:27 <lambdabot> forall a b. (a -> b) -> a -> b
08:20:30 <mux> it's like ($) but strict
08:20:36 <Cin> ahh. i see.
08:20:37 <Cin> thanks
08:20:40 <mux> yw
08:20:54 <oerjan> @src $!
08:20:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:20:58 <quicksilver> well, sort of strict
08:20:59 <oerjan> gah
08:21:00 <quicksilver> it's only seq
08:21:12 <oerjan> f $! x = x `seq` f x, iirc
08:21:17 <quicksilver> yes
08:21:32 <mux> @src ($!)
08:21:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:21:33 <oerjan> @src ($!)
08:21:33 <lambdabot> Source not found. Do you think like you type?
08:21:42 <mux> nasty lambdabot, no cookie
08:22:05 <oerjan> i wish @src would ignore parentheses at least
08:22:58 <mux> quicksilver: yeah, seq only forces things to weak head normal form, right?
08:23:15 <oerjan> yep
08:23:49 <oerjan> (sometimes i try four different combinations before concluding that @src doesn't have a method)
08:28:40 <quicksilver> @src ++
08:28:40 <lambdabot> (++) []     ys = ys
08:28:41 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
08:28:44 <quicksilver> @src (++)
08:28:44 <lambdabot> (++) []     ys = ys
08:28:44 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
08:28:51 <oerjan> eek
08:28:54 <quicksilver> oerjan: @src does ignore parens, at least in the simple case
08:29:02 <quicksilver> I'm not sure it does for methods, though
08:29:12 <oerjan> @src -> >>=
08:29:12 <quicksilver> @src (->) (>>=)
08:29:13 <lambdabot> f >>= k = \ r -> k (f r) r
08:29:13 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:29:22 <quicksilver> @src (->) >>=
08:29:23 <lambdabot> Source not found. My pet ferret can type better than you!
08:29:29 <quicksilver> @src -> (>>=)
08:29:30 <lambdabot> Source not found. Wrong!  You cheating scum!
08:29:36 <quicksilver> yeah, it doesn't for methods
08:29:54 <mux> @src ((->) a) (>>=)
08:29:54 <lambdabot> Source not found. Do you think like you type?
08:33:41 <tomppa> is there something magical going on with IORefs or are they just regular haskell constructs?
08:35:00 <Saizan> tomppa: well they're implemented via compiler primitives
08:35:24 <tomppa> ok
08:38:43 <quicksilver> tomppa: in a sense the whole IO monad is implemented magically
08:39:14 <quicksilver> you could imagine a pure way to implement IORef, but I think you need Typeable or something to do it
08:39:18 <quicksilver> you need a way to reify types
08:39:20 <tomppa> i thought that might be the case
08:39:38 <quicksilver> then you could have something like a map Int -> (Type,Value)
08:39:42 <quicksilver> for your IORefs
08:39:48 <tomppa> is IO monad the only "magical" monad in ghc?
08:39:51 <quicksilver> yes
08:39:52 <geezusfreeek> well, there is STRef
08:40:02 <geezusfreeek> which also uses some compiler primitives
08:40:03 <quicksilver> geezusfreeek: STRef is just IORef in sheep's clothing :)
08:40:09 <geezusfreeek> exactly
08:40:17 <quicksilver> tomppa: no, I lied.
08:40:26 <quicksilver> tomppa: IO, ST and STM are all magical.
08:40:34 <quicksilver> you can imagine pure implementations of ST.
08:40:47 <geezusfreeek> there are only as magical as everything else in haskell, imo
08:41:15 <geezusfreeek> if IO is magical, so is the transformation of (+) to the machine add instruction, etc.
08:41:53 <tomppa> geezusfreeek, that is true of course
08:42:39 <quicksilver> you can imagine an implementation of STM over some other thread impl.
08:42:43 <quicksilver> but threads need to be primitive
08:42:50 <quicksilver> geezusfreeek: I disagree.
08:42:58 <quicksilver> geezusfreeek: IO is genuinely more magical than (+)
08:43:11 <geezusfreeek> i'd say it just depends on your definition of magical
08:43:15 <quicksilver> geezusfreeek: (+) could be defined in haskell. It's just more efficient not to.
08:43:19 <quicksilver> IO could not be defined in haskell.
08:43:32 <koeien> (at least without an FFI)
08:43:33 <geezusfreeek> sure it could... it just wouldn't do anything useful :)
08:43:40 <quicksilver> you could define a model of IO, yes
08:43:46 <quicksilver> but that's not the same thing
08:43:52 <quicksilver> you can *actually* define (+).
08:44:03 <quicksilver> (on any finite fragment, or using peano recursion if you prefer)
08:44:13 <litb> hello all
08:44:17 <litb> i've a question
08:44:34 <geezusfreeek> a model is virtually the same though, which is what i consider more important. it's the whole reason that i don't feel that purity is violated by the IO monad
08:45:09 <litb> in a short line, how can i build a datatype from sin to -cos ? (that is, sin, then first deriveration, then second one, and so on, then looping back to sin and looping forever
08:45:21 <koeien> litb: mod 4 ?
08:45:21 <litb> in this way: Funktion sin (Just (Funktion cos Nothing))
08:45:39 <opqdonut> well something "isomorphic" to IO could be defined in pure haskell
08:45:43 <litb> but without having to declare Just (Function cos Nothing) first somewhere to referer to it
08:45:47 <litb> is that possible?
08:45:52 <faxathisia> litb, That doesnt make sense to me
08:45:56 <koeien> litb: what do you want?
08:45:57 <byorgey> litb: let s = Function sin (Just (Function cos s)) in s
08:46:08 <faxathisia> litb, Do you want an infinite type?
08:46:17 <byorgey> litb: that isn't correct of course, but that's the idea -- introduce a name and use it in its own definition.
08:46:26 <litb> say s is sin, and c is cos. i want to build this: s(c(-s(-c(s)))) where each ( means "next deriveration"
08:46:29 <byorgey> litb: this technique is called "tying the knot"
08:46:38 <opqdonut> gah, damn lag
08:47:29 <litb> ah, i would need serveral neste lets, right?
08:47:48 <litb> oh , no i can have more declarations in one let. i forgot that
08:48:12 <litb> "tying the knot" funny name :)
08:48:13 <byorgey> s = Funktion sin (Just (Function cos (Just (negateFunk c))))
08:48:18 <geezusfreeek> let x = s(c(-s(-c(x)))) in x
08:48:33 <byorgey> and then define c in terms of s.
08:48:52 <faxathisia> litb, This is kind of curious.. What's the purpose?
08:48:56 <byorgey> you don't even need a let, mutually recursive definitions are no problem.
08:49:13 <litb> faxathisia: i just want to have the correct deriveration hirachy
08:49:17 <litb> so, from sin back to sin
08:49:27 <litb> byorgey: what?
08:49:27 <koeien> litb: i don't get what you want though
08:49:33 <faxathisia> I'm interested why
08:49:39 <koeien> litb: why no function deriv :: Trig -> Trig
08:49:47 <koeien> litb: and then "iterate deriv sin"
08:50:02 <litb> faxathisia: just because i want to see how i would do that . it has no real life purpose
08:50:15 <geezusfreeek> yeah, having an infinite data structure for it just seems odd to me
08:50:16 <byorgey> litb: sorry, what don't you understand?
08:50:54 <faxathisia> litb, That's cool, What is the   data ... =    part like?
08:51:10 <litb> byorgey: the "mutually recursive definitions are no problem." . what do you mean by that?
08:51:34 <litb> i have a Function datatype that has a "function :: Double -> Double" and "deriveration :: Maybe Function"
08:51:37 <koeien> litb: f 0 = 0; f x = g (x-1); g x = f (x-1)   is allowed
08:51:41 <byorgey> litb: I mean, in a haskell file you can have  two declarations  s = ... something involving c ...  and c = ... something involving s ...
08:51:47 <litb> and now i want to build a list of that datatype
08:52:01 <litb> byorgey: ah i see
08:52:12 <faxathisia> I think that you should do what koeinen said then...
08:52:23 <byorgey> > let xs = 1:ys ; ys = 2:xs in xs
08:52:25 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
08:52:30 <faxathisia> If you don't have a datatype for this..
08:52:33 <benny> what is the difference between "inc = \x -> x + 1" and "inc x = x + 1"
08:52:40 <koeien> benny: there is none
08:52:42 <litb> faxathisia: i have
08:52:49 <faxathisia> :t \x -> x + 1
08:52:50 <lambdabot> forall a. (Num a) => a -> a
08:52:50 <kpreid> benny: the monomorphism restriction
08:53:01 <faxathisia> :t let  inc x = x + 1  in  inc
08:53:02 <lambdabot> forall a. (Num a) => a -> a
08:53:12 <koeien> hmm
08:53:13 <benny> so it's just sugar?
08:53:23 <byorgey> benny: with the monomorphism restriction, the first is not allowed to have a polymorphic type.
08:53:26 <kpreid> except for the monomorphism restriction, yes.
08:53:35 <byorgey> benny: unless you give it an explicit type annotation.
08:53:38 <faxathisia> Why do they have the same type?
08:53:43 <kpreid> well, and functions defined with = can have multiple patterns; lambdas can't
08:53:50 <benny> yeah, the same type doesn't make that restriction clear I think
08:53:50 <kpreid> (though of course you can put a case in a lambda)
08:54:21 <byorgey> :t let inc = \x -> x + 1 in inc
08:54:22 <lambdabot> forall a. (Num a) => a -> a
08:54:45 * byorgey stabs the MR with a C pointer
08:54:58 <tomppa> is there any summary anywhere about all the different array types and their performance characteristics? I'm a bit puzzled about what to use and when.
08:55:34 <byorgey> benny: don't worry about the MR too much, other than that, those two things are exactly the same.
08:56:12 <benny> byorgey: okay, Im just trying to get the pattern matching to work though... inc = \x \y -> should work?
08:56:22 <byorgey> tomppa: there should be.  but as far as I know, there's only the haddock documentation.
08:56:31 <Saizan> thre's a wiki page
08:56:32 <byorgey> benny: no, use \x y ->,  or \x -> \y ->
08:56:42 <koeien> benny: \x y ->
08:56:52 <koeien> what byorgey said
08:57:07 <byorgey> benny: \x y -> is just sugar for \x -> \y ->
08:57:38 <Saizan> tomppa: http://www.haskell.org/haskellwiki/Arrays <-- i'd add that diffarrays are just slow
08:57:39 <lambdabot> Title: Arrays - HaskellWiki
08:58:04 <benny> okay. I'm doing this in ghci and I'm using "let inc = \x y -> x + y" plus "let inc = \x -> x + 1", is that because of a ghci restriction?
08:58:13 <tomppa> Saizan, byorgey, thanks
08:58:20 <benny> (I mean both don't work at the same time)
08:58:34 <quicksilver> tomppa: general rule is don't use them :)
08:58:51 <quicksilver> tomppa: second rule is experiment, there are different trade-offs in different circumstances ;)
08:58:56 <Saizan> benny: defining the second inc you're shadowing the first
08:59:30 <benny> yeah, it would seem so. How do I do _real_ pattern matching?
08:59:48 <byorgey> benny: I'm not sure what you're trying to do anyway.  there's no such thing as "default arguments" in Haskell.
08:59:50 <quicksilver> define them in one line
08:59:55 <litb> just to understand..
09:00:04 <quicksilver> let {f 0 = 0; f n = f (n-1) }
09:00:25 <litb> (-sin) doesn't work because sin is not of Num class. but ((-).sin) doesn't work to because it is understood as the binary minus. but (negate.sin) works
09:00:34 <litb> is there a way i can still use (-) ?
09:00:42 <koeien> probably not
09:00:46 <quicksilver> not for the unary one, no
09:00:50 <kpreid> or let { f = \x -> case x of 0 -> 0; n -> f (n-1) }
09:00:50 <quicksilver> (-) is the binary function
09:00:53 <quicksilver> as you observe
09:01:06 <byorgey> benny: i.e. it looks like what you're trying to do is have "inc 3" add three to its argument, but "inc" with no arguments adds one by default.  that isn't possible.
09:01:10 <kpreid> > (0-).sin pi
09:01:10 <lambdabot>   add an instance declaration for (Floating (a -> t))
09:01:15 <Saizan> (\x -> - x) . sin?
09:01:16 <kpreid> > ((0-).sin) pi
09:01:17 <lambdabot>  -1.2246063538223773e-16
09:01:18 <koeien> unary negation is ugly notation imo
09:01:47 <quicksilver> unary negaton is a blight on haskell
09:01:50 <benny> byorgey: no, what Im trying to do is just: inc with 1 arg, does + 1 to the arg. inc with 2 args just sums them.
09:01:59 <dons> quicksilver: a blight or a wart?
09:01:59 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:02:00 <koeien> not only haskell; in mathematics in general
09:02:03 <dons> or some other kind of parasite?
09:02:07 <byorgey> benny: right, that isn't possible.
09:02:09 <kpreid> benny: that's not really a good idea.
09:02:10 <quicksilver> dons: hard to be sure
09:02:14 <quicksilver> dons: a blight of warts?
09:02:27 <dons> a warty blight?
09:02:40 <RayNbow> hmm, RW Haskell site is dying...
09:02:49 <dons> RayNbow: its getting hammered
09:02:51 <benny> oh. isn't that one of the main selling points for pattern matching?
09:02:56 <RayNbow> dons: I noticed
09:02:56 <dons> we might have to mvoe it to o'reilly actually
09:02:58 <RayNbow> and it's getting worse
09:03:14 <quicksilver> dons: could you not improve the mersenne binder to have the ability to copy the underlying state
09:03:27 <quicksilver> dons: and therefore feel a bit purere?
09:03:31 <byorgey> benny: well, you can't pattern-match on "number of arguments".
09:03:33 <quicksilver> dons: support split and so on
09:03:34 <litb> i wonder whether i should make my function datatype an instance of class Num, so i could easily do -my_function , 2*my_function and so on
09:03:40 <benny> byorgey: okay.
09:03:46 <dons> quicksilver: i did implement this, its a bit hard, but doable -- but then, you copy on every gen_rand call
09:03:52 <dons> so its super expensive.
09:03:53 <byorgey> benny: all functions in haskell are one-argument functions.  some just happen to return other functions, which take another argument, and so on...
09:03:56 <quicksilver> dons: hmms
09:04:08 <dons> you could allow multiple impure generators
09:04:08 <koeien> litb: that seems to be possible, but what do you want to be f * g
09:04:17 <dons> and then, its not clear we can split anyway
09:04:19 <koeien> litb: composition or pointwise multiplication
09:04:22 <byorgey> benny: for example, consider the function  plus a b = a + b.
09:04:27 <dons> it depends on the algo -- i'd need some math guy to write a paper
09:04:32 <quicksilver> dons: is it really that expensive? surely it's just copying 512 bytes of state or something?
09:04:40 <dons> 4k iirc
09:04:45 <quicksilver> oh
09:04:46 <byorgey> benny: the type of plus is (Int -> Int -> Int)  (actually it involves Num, but let's just assume it's Int for now.)
09:05:10 <dons> so if i'm generating 10M ints in a loop
09:05:13 <byorgey> benny: that's really the same thing as Int -> (Int -> Int).  i.e. plus takes an Int, and returns another function which adds that Int to its argument.
09:05:14 <dons> that's a lot of copying
09:05:19 <quicksilver> dons: yeah, that's true.
09:05:41 <benny> byorgey: okay. wouldn't there be a way to emulate multiple arguments by dropping them via case and _?
09:05:49 <quicksilver> dons: hmm.
09:06:00 <quicksilver> dons: it feels like there ought to be something clever you can do
09:06:05 <benny> if I understand _ correctly, that is
09:06:05 <byorgey> benny: I'm not sure what you mean.
09:06:21 <byorgey> benny: _ just means you don't care what that argument is.  _ is the pattern which matches anything.
09:06:23 <koeien> benny: no there is no (simple) way to do this, you probably misunderstand the meaning of _
09:06:33 <quicksilver> benny: the key point to remember is that haskell functions have a specific, single, most general type.
09:06:33 <koeien> benny: _ means "anything, i don't care; don't bind anything"
09:06:56 <quicksilver> benny: among other things this (mostly) limits them to a fixed number of parameters.
09:07:01 <benny> okay. Just curious about that 'wrapper' functionality.
09:07:03 <litb> koeien: i wanted to define it only for an argument of type Num and Function
09:07:08 <quicksilver> but this property of having a principle type is important and useful
09:07:12 <litb> (and want :))
09:07:14 <quicksilver> dons: I'm not sure what, though.
09:07:21 <koeien> litb: but that is not possible, in Num a, there is (*) :: a -> a -> a
09:07:22 <vincenz> \o/ for quickcheck and hpc
09:07:23 <benny> quicksilver: fair enough, just not used to it :-)
09:07:33 <koeien> litb: so you'll have to have two functions f, g and then f * g :: Funktion
09:07:44 <quicksilver> dons: would be nice to have a RNG with decent performance and a clever functional interface
09:07:47 <litb> oh, darn :/
09:07:53 <koeien> litb: if you want "scalar multiplication" you'll have to create another function (.*) or so
09:08:12 <koeien> litb: of type Num a => a -> Funktion -> Funktion
09:08:13 <litb> koeien: could i "overload" it?
09:08:33 <koeien> litb: probably, but you will have to hide the (*) from Prelude and define your own multiplication
09:08:53 <koeien> litb: since the Prelude defines (*) to have type Num a => a->a->a
09:09:02 <hpaste>  litb pasted "hm, that's how i did it" at http://hpaste.org/5156
09:09:14 <litb> i don't see how it can be done in a shorter way
09:09:40 <litb> koeien: oh i see. functions are not overloadable
09:10:18 <koeien> litb: well, with typeclasses you can, but you will have to define your own Num-like typeclass
09:10:19 <litb> koeien: but wouldn't that throw away the whole purpose of classes? i mean, if they can still collide with each other if they provide the same operator?
09:10:20 <quicksilver> it's not generally sensible to define Num instances for things which aren't numbers.
09:10:34 <quicksilver> although it can be educational to try
09:10:36 <litb> koeien: ah, yeah that is whay i was thinking about
09:11:14 <litb> so i could just have said "-dS" and "-dC" there :)
09:17:30 <dons> quicksilver: yeah, i've got a plan
09:17:38 <dons> the old mt1997 has much smaller state.
09:17:47 <dons> its a bit slower, and only generates 32 bits at a time
09:17:52 <dons> but should be easier to purify
09:18:12 <dons> that'd give us something fast and pure. not as fast as simd mt, but close
09:19:25 <dons> oh, actually, there's a 64 bit version too
09:21:51 <quicksilver> dons: I wonder if any of them are reversible.
09:22:01 <quicksilver> dons: then you could mutate agressively behind the scenes.
09:22:13 <quicksilver> but if something did have a'pointer' to an old state, you could reverse...
09:22:16 <quicksilver> bit like diffarray.
09:26:55 <litb> class FunktionKlasse a where n - a :: (Num n) => n -> a -> a
09:27:07 <litb> sorry for all this stupid questions, but what is wrong there?
09:27:58 <vincenz> litb: erm .. first of all, you're reusing -, secondl that's not valid syntax
09:28:11 <vincenz> class Foo  where  (-) :: (Num n) => >n -> a -> a
09:28:20 <vincenz> but like I said, you'll have to pick another symbol
09:28:25 <vincenz> s/Foo/Foo a/
09:29:00 <litb> oh darn i see. that's just the type
09:29:11 * vincenz nods
09:29:29 <litb> vincenz: i thought when i make a new typeclass i can use that symbol too
09:29:43 <vincenz> litb: only if you hide the Num one
09:29:58 <vincenz> litb: functionnames are uniquely bound to classes
09:30:06 <vincenz> erm, methodnames
09:30:11 <vincenz> litb: why not pick another?
09:30:22 <vincenz> (>-)
09:30:46 <vincenz> or simply make it a function-name
09:30:59 <litb> well, i just will pick .- and .+ .
09:31:22 * vincenz tends to use spaceships
09:31:25 <vincenz> <-> <+>
09:31:31 <litb> oh nice too
09:31:35 <vincenz> @hoogle (<->)
09:31:39 <lambdabot> Did you mean: (<->)
09:31:39 <lambdabot> Prelude.undefined :: a
09:31:39 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
09:31:39 <vincenz> @hoogle (<+>)
09:31:40 <lambdabot> Did you mean: (<+>)
09:31:40 <lambdabot> Prelude.undefined :: a
09:31:40 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
09:31:43 <vincenz> hmm
09:31:57 <litb> if i want (-) for a -> n -> a , can i have a second (-) (or <-> doesn't matter now) too?
09:32:16 <litb> (i want to be able to do 10 <-> f and f <-> 10
09:32:18 <vincenz> litb: no
09:32:26 <vincenz> litb: what people typically do is use single-sided ones
09:32:27 <vincenz> like
09:32:35 <vincenz> (-<) and (>-)
09:33:05 <litb> oh i see. that makes me sad o.O but i will live with it
09:33:09 <vincenz> > let (-<) a b = a * b in 1 -< 3
09:33:12 <lambdabot>  3
09:33:26 <vincenz> litb: it's kind of obvious, how will the compiler know which to use when you use the symbol?
09:33:49 <litb> and that arrow points to the number in my case i guess, that's the convention
09:33:59 <vincenz> for instance
09:34:04 <vincenz> btw, make sure not to use <- and ->
09:34:06 <vincenz> those are reserved
09:34:12 <litb> i see
09:34:20 <litb> vincenz: hm, youre rite of course
09:34:35 <vincenz> you `could` say type-inference, if you were new
09:34:36 <vincenz> but then wht of
09:34:40 <vincenz> foo a b = a - b
09:34:47 <vincenz> now what type does foo have? the one or the other?
09:36:14 <litb> vincenz: how would you make a negate symbol?
09:36:37 <vincenz> litb: what are you trying to do?
09:37:00 <vincenz> litb: I'd use Num
09:37:25 <vincenz> instance (Num a) => Foo a where
09:37:37 <vincenz> or simply expect 'a' to bea Num
09:37:43 <vincenz> so you can use 'negate'
09:37:56 <litb> i try to make "-my_function" work, which would make a "Function (negate.(function a)) (someSymbol (deriveration a))
09:37:59 <vincenz> litb: tbh, I'm starting to wonder what you're trying ot achieve, sounds like you're going agaainst the grain
09:38:00 <litb> "
09:38:14 <vincenz> what is a Function?
09:38:34 <vincenz> litb: are you trying to get symbolic math?
09:38:47 <litb> vincenz: a Function is: data Function = { function :: Double -> Double; deriveration :: Maybe Function }
09:39:32 <vincenz> litb: erm
09:39:34 <litb> vincenz: i want to create my functions statically and my deriverations, but want to allow the user to do simple modifications of one functions, for example to negate a functions and so on
09:39:37 <vincenz> litb: you want differentials?
09:39:44 <vincenz> been done :)
09:40:00 <vincenz> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
09:40:02 <lambdabot> Title: Things that amuse me, http://tinyurl.com/ypvsr2
09:40:24 <vincenz> full derivatives
09:40:33 <vincenz> up to the inf^th degree
09:40:53 <litb> ah, thxx
09:41:36 <vincenz> most welcome
09:42:18 <ddarius> Incidentally, deriverations is not an (English) word
09:42:33 <vincenz> ddarius: whatever, I'm tired, haven't slept last night and debugging tricky code, sue me
09:42:56 <ddarius> vincenz: ?  You never said deriverations.  That was directed to litb.
09:43:01 <vincenz> Oh
09:43:14 <vincenz> Well, very tired then :)
09:43:25 <vincenz> thank the lord for hpc and qc
09:43:30 <litb> hm, but i can't use negate since it requires a Num classed return type
09:43:32 <vincenz> (not to mention hmx)
09:43:39 <ddarius> hmx ?
09:43:48 <vincenz> hindley-milner with extensions?
09:43:58 <byorgey> litb: can't you just make a function called neg (for example)?
09:43:59 <vincenz> litb: that's the whole point, your derivative is a number
09:44:09 <ddarius> Ah. HM(X)?
09:44:13 <vincenz> ddarius: *nods*
09:44:36 <byorgey> vincenz: that's not what litb is doing.
09:44:50 <vincenz> byorgey: the question is, why isn't he?
09:45:00 <vincenz> byorgey: this seems a very roundabout way
09:45:18 <vincenz> this can -very- easily be emulated by stacking Dif on top of Sym
09:45:21 <byorgey> vincenz: to learn? for fun? who cares?
09:45:51 <vincenz> byorgey: right, and a haskeller would instantiate Num
09:46:19 <litb> if i really wanted to heat up my head, of course i would choose your funny symbolic math and whatnot
09:46:26 <litb> but i want to keep it as simple as possible
09:46:27 <vincenz> It's not mine :)
09:48:15 <ddarius> And I doubt it's symbolic.
09:48:37 <litb> ah wait i'm starting to understand what you mean vincenz
09:49:04 <litb> you mean i should make a class Foo, and then make a instance of Num for that class Foo
09:49:20 <vincenz> s/class Foo/datatype Foo
09:50:43 <byorgey> litb: I think he means to make your Funktion type an instance of Num.
09:50:51 * vincenz nods
09:50:58 <litb> instance Num Foo where  ...
09:51:21 <byorgey> it's kind of nice but the fromIntegral ends up being weird.
09:51:35 <Time`s_Witness> I'm cmoparing 2 different codes that do  (at the end) the same thing.. to try to find an error in one of them.. i checked every simple and complex case i could remember and i seem not to be able the (logic) error.. i even did a function to return true/false when comparing with strings with thousands of chars.. :S is there any easier way to test if the functions are equivalent? :x
09:51:37 <litb> ok, i get it now. lets see whether i can implement it
09:51:55 <Time`s_Witness> *not to be able to find the (logic) error
09:51:59 <vincenz> byorgey: fromIntegral are constants, zero derivativ
09:52:13 <vincenz> byorgey: then you inject variables with dVal x = D x 1
09:52:16 <litb> yeah. fromIntegral would return a function object. would be kinda weird indeed
09:52:27 <vincenz> oh, in this specific implementation..
09:52:46 <litb> s/object/datatype/ darn
09:54:03 <vincenz> @hoogle notnull
09:54:04 <lambdabot> No matches found
09:54:37 <byorgey> vincenz: yes, ignore me... I was thinking of a Num instance for Num a => (a->a), which means "5 2" is a valid expression.
09:55:07 <byorgey> but a Num instance for a Function data type wouldn't have that problem...
09:55:52 <byorgey> Time`s_Witness: no, the only way to test functions for equality is to compare their output.
09:57:04 <vincenz> if the inputs are instances of Enum and Bounded you could potentially auto-generate equality
09:57:17 <vincenz> just don't try it on a function taking Int :)
09:57:40 <Time`s_Witness> :s thanks byorgey
09:58:14 <byorgey> Time`s_Witness: so, you have two functions that are supposed to be equivalent, but they aren't?
09:58:15 <litb> i understand making a Function an instance of Num . but i wonder whether that is dirty? because after all, it becomes a number, but it is not yet a number
09:58:38 <litb> not before having applied to number as its input
09:58:54 <byorgey> litb: I think it's fine.  Num is for things which "act like" a number.
09:59:05 <byorgey> not just for things which you usually call "number".
09:59:56 <byorgey> if there's anything "dirty" about it, it's the Num typeclass itself, which is sort of a hodgepodge of various not-necessarily-related things.
10:00:23 <Time`s_Witness> byorgey, well, it was an exercise.. you probably remember the one i was in troubles about coding foldl, organising a string into many strings.. we submit the codes to an online checker that returns Accepted/Runtime Error/Wrong Answer/etc, and that software does many tests.. my partner got wrong answer, unlike me (accepted), so.. yea, i was trying to find the difference :s
10:01:05 <byorgey> litb: for example, there really should be a "Ring" typeclass which does not include things like "signum", "abs", "negate", and "fromInteger", but just has addition and multiplication.  and so on.
10:01:20 <byorgey> Time`s_Witness: ah, I see
10:01:33 <byorgey> Time`s_Witness: have you tried QuickCheck?
10:01:51 <Time`s_Witness> no, i have never even heard of it :X
10:02:13 <byorgey> Time`s_Witness: you give it some function which should always be true, and it will check it with a large amount of random input.
10:02:14 <litb> byorgey: do you tink they will fix that in a future haskell version?
10:02:18 <lispy> byorgey: there are many 'theoretical' flaws in the number classes in haskell :(
10:02:23 <byorgey> litb: I hope so.
10:02:30 <byorgey> lispy: yep, I know... =(
10:02:53 <byorgey> litb: there are already "alternate" Preludes which you can use instead of the normal one.
10:03:04 <Time`s_Witness> how can i use that, byorgey? I mean, is it in prelude already?
10:03:20 <lispy> ?where QuickCheck
10:03:20 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
10:03:23 <byorgey> Time`s_Witness: first, import Test.QuickCheck
10:03:43 <byorgey> Time`s_Witness: then define a function which should always return true.  For example:
10:03:45 <lispy> ?commands
10:03:46 <lambdabot> Unknown command, try @list
10:03:49 <lispy> ?list
10:03:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:04:09 <lispy> ?check const True
10:04:11 <lambdabot>  Add a type signature
10:04:17 <byorgey> @let prop_rev xs = xs == reverse (reverse xs)
10:04:20 <lambdabot> Defined.
10:04:21 <lispy> ?check const True :: Int -> Bool
10:04:23 <lambdabot>  OK, passed 500 tests.
10:04:44 <byorgey> Time`s_Witness: then you pass it to the function 'test'.
10:04:50 <byorgey> @check prop_rev
10:04:50 <lambdabot>  Add a type signature
10:04:59 <byorgey> well, you need to give it a type signature too =)
10:05:19 <byorgey> Time`s_Witness: you can read about it at the link lispy showed above.
10:05:32 <Time`s_Witness> i see.. thanks byorgey :D
10:06:15 <byorgey> Time`s_Witness: so you could write a function like foo xs = yourImplementation xs == yourFriendsImplementation xs
10:06:31 <byorgey> Time`s_Witness: then give foo to quickcheck and see if it finds an input for xs that makes the property false.
10:06:42 <Time`s_Witness> yea..
10:09:18 <Time`s_Witness> byorgey, winhugs got a compilation error when loading quickcheck.hs :S (I didnt edit or even open it :X) heh //ERROR file:.\QuickCheck.hs:147 - Undefined variable "chr"
10:09:28 <jedbrown> I want to make an instance for any Ix which is not a tuple in <http://hpaste.org/5152> ?  Like   instance Detuple a a where detuple i = [i].  Is something like this possible?
10:09:34 <byorgey> yikes!
10:10:01 <byorgey> Time`s_Witness: you mean you just added 'import Test.QuickCheck' to your program and then you got that error?
10:10:12 <chessguy> ok #haskellers
10:10:18 <chessguy> i just got the gauntlet thrown down
10:10:43 <byorgey> the gauntlet, eh?
10:10:50 <Time`s_Witness> no, i downloaded quickcheck.hs and loaded it like i would.. any usual script :X heh, ive never used any library before and couldnt find any option for it :S
10:11:00 <Time`s_Witness> so.. normal load :x
10:11:15 <chessguy> i was extolling the virtue of some of the features of http://osteele.com/sources/javascript/functional/
10:11:16 <lambdabot> Title: Functional Javascript
10:11:20 <phobes> jedbrown:  Can you not just make an instance for any type and let overlapping instances sort it out?
10:11:44 <chessguy> and was told that currying doesn't have any usefulness in any non-trivial examples
10:12:03 <byorgey> Time`s_Witness: which link did you click to download that?  the one that says "Module QuickCheck"?
10:12:13 <jedbrown> phobes: I get a `functional dependencies conflict' error.
10:12:49 <jedbrown> phobes: Because I can't match against not-a-tuple.
10:12:49 <byorgey> chessguy: currying makes partial application possible, which is super-useful.
10:13:00 <Time`s_Witness> byorgey no.. but i just clicked in that same one now and.. same error, same line O_o
10:13:03 <chessguy> byorgey, got a good non-trivial example?
10:13:20 <pjd> chessguy: point them at http://www.python.org/dev/peps/pep-0309/
10:13:21 <lambdabot> Title: PEP 309 -- Partial Function Application
10:13:53 <phobes> Note that partial function application can be supported separately from currying
10:14:06 <byorgey> phobes: that's a good point.
10:15:16 <litb> oh, nice. it's now only "let dS = Funktion sin (Just (Funktion cos (Just (neg dS)))) in dS,"
10:15:43 <byorgey> litb: cool =)
10:16:17 <phobes> chessguy:  I don't think there are non-trivial examples of the advantages of currying... in the sense that there will always be a localized change to a non-curried style that achieves the same thing
10:16:26 <litb> in c++, that would need 20+ lines of code :D
10:16:34 <phobes> chessguy:  it's mainly just a style and theoretical thing
10:16:41 <chessguy> boo!
10:17:12 <phobes> chessguy:  An explicit syntax for partial application even has the advantage that you can partially apply values into any function slot, rather than just the first
10:17:43 <litb> hm, i think it'S the best if i make an instance of Num and just implement negate and be happy :)
10:17:50 <phobes> I think someone said scala uses ? as in ... f(?,?, 10, ?)
10:17:51 <byorgey> chessguy: what's the point of arguing with people who say things like that, anyway?
10:18:11 <chessguy> because he has influence in the company, partially :)
10:18:30 <chessguy> and because he's uber-smart, which means any discussion i have with him means that i'll probably learn something
10:19:11 <litb> through that, i could also implement my scalar multiplication by making a "fromScalar n = Funktion (\_ -> n) Nothing" and then i could do "fromScalar 10 * my_func"
10:19:20 <litb> or is that a bad idea?
10:19:30 <paolino> is there a way to simulate getLine , a function String -> IO String ?
10:19:35 <pjd> chessguy: the main argument for currying is probably that it makes formal sense in the context of functional languages like Haskell
10:19:53 <nomeata> Igloo: hi. anything new about the updated haskell-x11 upload?
10:20:18 <opqdonut> paolino: return?
10:20:25 <dons> chase him hard, nomeata :)
10:20:31 <pjd> chessguy: which is not so much of an argument in the context of languages like JavaScript
10:20:54 <chessguy> pjd, why is that?
10:21:10 <phobes> Is ' ' the application operator in Java script?
10:21:13 <dons> ?users
10:21:13 <lambdabot> Maximum users seen in #haskell: 454, currently: 425 (93.6%), active: 15 (3.5%)
10:21:19 <pjd> chessguy: what phobes said :)
10:21:21 <phobes> currying gets ugly if it isn't
10:21:23 <jedbrown> The problem I'm dealing with is handling multi-dimensional arrays sensibly.  If the index is a homogeneous tuple, then we should treat it as multi-dimensional, otherwise we treat it as flat.  The flat case is what the paste doesn't address.  There should be a way to do this.
10:21:30 <chessguy> it's not that ugly
10:21:36 <paolino> opqdonut, yes
10:22:01 <chessguy> check out the example on the right side at the top of the page i gave
10:22:06 <pjd> chessguy: also, JS / dynamic languages tend to rely on things like variable argument lists
10:22:09 <nomeata> dons: I donโt know what else to do :-(
10:22:20 <pjd> which flies against currying
10:22:25 <dons> nomeata: i'll ping him too.
10:22:28 <chessguy> pjd, i'm well aware of the capabilities of JS
10:22:36 <nomeata> Igloo: Would it be ok if I NMU the new version to experimental, that I can upload xmonad at least there?
10:22:46 <chessguy> i'm not sure why that "files against currying"
10:23:00 <chessguy> s/il/li/
10:24:53 <byorgey> litb: that's a fine idea, except the derivative of a constant function is the constant function 0, not Nothing
10:24:59 <pjd> chessguy: well, it isn't currying? :)
10:25:19 <pjd> there's plenty of partial application, though
10:25:34 <phobes> I'm trying to find the currying.. I don't know JS
10:25:37 <chessguy> i guess i don't really understand the difference between currying and partial application
10:25:41 <litb> byorgey: oh i see
10:26:02 <litb> byorgey: i don't worry about the performance impact there, not even sure there is any
10:26:15 <byorgey> litb: performance impact?
10:26:22 <chessguy> phobes, var square2Until = squareUntil.uncurry().flip().curry(2);
10:26:35 <phobes> what does . do there?
10:26:43 <phobes> it's not composition is it?
10:26:45 <pjd> member lookup
10:26:50 <phobes> ya that's what I figured
10:27:00 <chessguy> phobes, no, it's accessing a member function
10:27:21 <pjd> chessguy: that .curry(2) should be .p[artial]apply(2)
10:27:39 <chessguy> pjd, why?
10:27:50 <phobes> I'm trying to figure it out... what are the types involved here?
10:27:52 <pjd> because it doesn't curry, it partially applies :)
10:28:07 <phobes> squareUntil presumbably returns a number...
10:28:20 <chessguy> phobes, this is JS, don't think about types :)
10:28:40 <byorgey> chessguy: currying just refers to the idea of representing multi-argument functions as functions of one argument returning another function.
10:28:42 <phobes> err, it's OO right?  What class does flip() belong to?
10:29:09 <phobes> These are methods on every function?
10:29:09 <chessguy> squareUntil takes a predicate and a number, and returns a number
10:29:11 <byorgey> chessguy: in Haskell that's closely related to the idea of partial application, of course, but it's easy to imagine having partial application without currying.
10:29:25 <chessguy> phobes, it's prototypal ineritance
10:29:25 <pjd> phobes: JS is prototype-based OO, not class-based OO
10:29:40 <chessguy> byorgey, that's what i've been asking, i don't know what the difference is
10:29:43 <phobes> ... ok then... which object did they come from?
10:29:54 <chessguy> phobes, flip is on the function prototype, yes
10:30:24 <chessguy> but it does the same thing haskell's flip does
10:31:29 <phobes> I agree this doesn't look like currying
10:31:44 <chessguy> would somebody please describe the difference?
10:32:03 <phobes> Currying is having a function return a function instead of having a function that takes two parameters
10:32:20 <phobes> ie writing f :: Int -> (Int -> Int) in haskell instead of f :: (Int, Int) -> Int
10:32:38 <phobes> haskell is setup to make currying easy, so we can drop parens and just write f :: Int -> Int -> Int
10:32:59 <phobes> and when we invoke f, we write  f 1 2, instead of (f 1) 2
10:33:13 <chessguy> so that's both partial application and currying
10:33:19 <byorgey> chessguy: here's another way to think about it: it wouldn't make much sense to have currying without partial application, but a language without currying could still support partial application.
10:33:27 <phobes> The definition of f is where the currying occurs
10:33:31 <phobes> (f 1) is partial application
10:33:36 <matthew-_> err, hang on, I thought currying and partial application were technically separate
10:33:43 <pjd> phobes: or just plain application, in Haskell
10:33:48 <doserj> chessguy: currying is one mechanism for enabling partial application
10:33:49 <pjd> matthew-_: they are
10:33:50 <byorgey> matthew-_: they are.
10:33:57 <phobes> pjd:  true, there is no partial application in haskell :)
10:34:09 <matthew-_> I thought currying is the relationship between f a b and f (a, b)
10:34:11 <chessguy> how is partial application more general than currying?
10:34:12 <pjd> phobes: correction!  (`map` [1..])
10:34:22 <pjd> :)
10:34:35 <byorgey> matthew-_: that's right.
10:34:40 <phobes> pjd:  eh?
10:34:48 <matthew-_> sorry, I should have read the scroll back...
10:34:54 <byorgey> chessguy: one isn't more general than the other.  they are different things.
10:35:08 * chessguy sighs
10:35:23 <byorgey> chessguy: as for how you could have partial application without currying, imagine a language that lets you write something like g = f(?,10,?)
10:35:24 <pjd> phobes: that's partially applying the second argument to map
10:35:33 <byorgey> chessguy: then g would be a function of two arguments
10:35:40 <pjd> which, granted, is not fully general partial application, but it's as close as Haskell gets :)
10:35:45 <phobes> pjd:  oh yar :)
10:36:13 <chessguy> so partial application allows you to supply some parameters, currying only allows you to supply the first n parameters?
10:36:16 <phobes> Ya I suppose (+1) can be viewed as partial applcation
10:37:00 <byorgey> chessguy: the idea of 'partial application' in general just means the ability to supply some but not all parameters, yes.  partial application implemented using currying only allows you to supply the first n parameters.
10:37:36 <byorgey> but currying in and of itself doesn't 'allow' you to do anything, it is just a theoretical way of representing multi-argument functions in terms of one-argument functions.
10:38:03 <phobes> Currying is horribly ugly in languages that don't support it
10:38:07 * MyCatVerbs ponders. There's Data.Monoid, but no Data.Group or Data.Ring? No use for them?
10:38:37 <doserj> Data.Ring is called Num ...
10:38:52 <MyCatVerbs> phobes: ehhh. (((lambda (a) (lambda (b) (+ a b)) 3) 4) -- could be worse. ;)
10:38:58 <chessguy> phobes, and partial application isn't ?)
10:38:58 <byorgey> MyCatVerbs: such things exist, but not in the standard libraries.
10:39:18 <pjd> MyCatVerbs: there's a nice currying macro for that
10:39:19 <MyCatVerbs> doserj: I thought Num was a field?
10:39:19 <byorgey> chessguy: that too =)
10:39:20 <phobes> chessguy:  I'd rather just see explicit lambdas for partial applications than currying everywhere
10:39:30 <MyCatVerbs> pjd: oooh, which macro systems?
10:39:34 <doserj> @type (/)
10:39:37 <MyCatVerbs> pjd: scheme or CL?
10:39:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:39:37 <byorgey> MyCatVerbs: nope, nothing about inverses in Num
10:39:40 <pjd> MyCatVerbs: R5RS
10:39:55 <MyCatVerbs> pjd: sounds nice.
10:40:01 <ehird> MyCatVerbs: ahh but what about a generic, multi-arity one, in common lisp? (defun curry (f &rest a) #'(lambda (&rest a2) (apply f (append a a2)))
10:40:03 <vincenz> why can't you hang where-clauses on guarded-statement?
10:40:03 <ehird> should work
10:40:04 <byorgey> MyCatVerbs: Integer is not a field, for example.
10:40:04 <phobes> chessguy:  What does this do?  'n -> i -> i > n'
10:40:11 <pjd> MyCatVerbs: http://paste.lisp.org/display/36324
10:40:12 <MyCatVerbs> byorgey: ahhh. Danke.
10:40:18 <ehird> ahh, with one extra paren
10:40:19 <chessguy> phobes it's a lambda
10:40:28 <chessguy> \n i -> i > n
10:40:29 <phobes> ooh the last one was a >
10:40:32 <phobes> I thought it was another ->
10:40:36 <phobes> it was confusing the heck out of me :)
10:40:42 <ehird> yep:
10:40:42 <ehird> (defun curry (f &rest a) #'(lambda (&rest a2) (apply f (append a a2))))
10:40:51 <byorgey> vincenz: you can't?
10:40:51 <MyCatVerbs> byorgey: yeah, bad maths on my part, forgetting the definitions. So Num is a ring and Fractional is a field? Or only close to?
10:40:54 <vincenz> byorgey: apparently not
10:41:04 <phobes> ok, so that is curried style right there
10:41:06 <vincenz> | foo = bla
10:41:11 <vincenz>    where bla = ...
10:41:16 <vincenz>  | bar = bli
10:41:20 <phobes> 'n -> i -> i > n' is a curried function of two arguments
10:41:20 <vincenz> it complains ono the
10:41:22 <vincenz> on the |
10:41:30 <vincenz> (the second one, obv)
10:41:38 <byorgey> MyCatVerbs: Num is a ring plus some other junk that shouldn't be there, and Fractional is a field, yes.
10:41:59 <Taejo> @djinn [a] -> a
10:41:59 <lambdabot> -- f cannot be realized.
10:42:13 <ehird> djinn isn't very accurate
10:42:13 <byorgey> MyCatVerbs: although note that some of the ring (resp. field) laws are not enforced, e.g. distributivity.
10:42:21 <chessguy> vincenz, where clauses are at the scope of the function, i think
10:42:33 * vincenz grumbles
10:42:40 <Taejo> ehird: is the problem that there are too many functions with this type?
10:42:46 <vincenz> chessguy: can I attach where's to case-clauses
10:42:47 <vincenz> ?
10:42:51 <byorgey> vincenz: yeah, where clauses scope over multiple guards
10:42:58 <ehird> Taejo: nope:
10:43:00 <ehird> @djinn a -> a
10:43:00 <lambdabot> f a = a
10:43:01 <byorgey> vincenz: so you can't stick one in between
10:43:06 <chessguy> vincenz, not sure what you mean
10:43:33 <Taejo> ehird: what other functions have that type?
10:43:39 <ehird> Taejo: hm good point
10:43:40 <ehird> :)
10:43:46 <pjd> MyCatVerbs: that macro is actually a slightly extended curry, to optionally handle more than one parameter at a time
10:43:48 <vincenz> \o/
10:44:13 <vincenz> chessguy: just introduced the = earlier, then case () of ... and then palced _ before each | and replace each = by ->
10:44:14 <ehird> I want 'a -> (b -> a) -> b' :D
10:44:39 <vincenz> ddarius++
10:45:00 <Taejo> ehird: is that type inhabited?
10:45:45 <ehird> Taejo: nonsensical, more like
10:46:46 <Taejo> ehird: what does nonsensical mean, besides uninhabited?
10:47:08 <ehird> Taejo: :)
10:48:13 <BMeph> ehird, Taejo: flip id has that type.
10:48:24 <ehird> 'flip id'...
10:48:54 <Taejo> @type flip id
10:48:54 <lambdabot> forall b c. b -> (b -> c) -> c
10:48:57 <phobes> BMeph:  You can't get a 'b' from an 'a' and a 'b->a'
10:49:55 <BMeph> Ah, NM, you have the single types reversed. Thanks, phobes.
10:49:57 <BMeph> :p
10:50:03 <phobes> :)
10:50:08 <ehird> BMeph: f a b = b a..
10:50:14 <ehird> :)
10:50:51 <doserj> modus ponens only works in one direction ...
10:51:08 <Taejo> doserj:  exactly
10:51:56 <vincenz> lol 'make ghci'
10:52:29 <BMeph> Yeah, it'd have to be a b ->(a->b)->[a]
10:53:04 <BMeph> Er, s/a/of type/
10:53:08 <idnar_> @djinn b -> (a->b) -> [a]
10:53:09 <lambdabot> -- f cannot be realized.
10:53:12 <idnar> ;)
10:53:48 <BMeph> @djinn b -> [(a,b)] -> [a]
10:53:49 <lambdabot> -- f cannot be realized.
10:55:53 <ehird> challenge: using the naming scheme for types a,b,c,d.. (i.e. no a,d) get lambdabot output a function whose body is "b a c h"
10:56:42 <BMeph> byorgey: Were you the one that referred me to Enumerative combinatorics a couple days ago?
10:57:00 <byorgey> BMeph: I think so.
10:57:56 <BMeph> Good - I finally figured out what I was looking for: Stirling numbers. Thank you. :)
10:58:09 <byorgey> BMeph: oh, excellent. =)
10:58:57 <BMeph> byorgey++
10:59:24 <ptolomy> Hm.. I'm running GHC 6.6.1, and I've got an app that I've been regularly profiling, but now I can't seem to get it to do any ticks at all in a profiling session. Any idea what might cause this? Maybe I'm including a library that can't be benchmarked or somethign?
11:03:44 <litb> @pl (\x -> f x * f x)
11:03:45 <lambdabot> liftM2 (*) f f
11:03:49 <ac> how would I iterate getLine or getWord8 indefinitely until I got a certain value? Like some sort of monadic version of: takeWhile (not.(==foo)).iterate
11:04:42 <koeien> repeatUntil p m = m >>= \x -> if p x then x else repeatUntil p m
11:04:59 <koeien> :t let repeatUntil p m = m >>= \x -> if p x then x else repeatUntil p m in repeatUntil
11:05:14 <lambdabot> thread killed
11:05:28 <koeien> what did i do :/
11:06:16 <Saizan> :t let repeatUntil p m = m >>= \x -> if p x then x else repeatUntil p m in repeatUntil
11:06:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => (m b -> Bool) -> m (m b) -> m b
11:06:57 <Saizan> koeien: lambdabot being now on a virtual server has some problems with the scheduler it seems :)
11:07:03 <phobes> 'thread killed' - did lambda bot get an upgrade?
11:07:16 <litb> > x a = x; liftM2 (*) x x 2
11:07:16 <lambdabot>  Parse error at "=" (column 5)
11:07:24 <koeien> :t repeatUntil p m = m >>= \x -> if p x then return x else repeatUntil p m
11:07:26 <ehird> @pl (\x f -> (f x,x f))
11:07:26 <lambdabot> ap =<< ((,) .) . flip id
11:07:29 <ac> think I want a type of: (Monad m) => (b -> bool) -> m b -> m b
11:07:31 <lambdabot> parse error on input `='
11:07:41 <ac> er, -> m [b]
11:07:41 <phobes> > let x = x in x
11:07:43 <lambdabot>  Exception: <<loop>>
11:07:44 <litb> >let x a = a in liftM2 (*) x x 2
11:07:56 <koeien> ac: yeah my type is wrong
11:08:02 <phobes> > let x n = x n+1 in x 1
11:08:03 <lambdabot>  Exception: <<loop>>
11:08:04 <koeien> i forgot the return
11:08:06 <koeien> :t repeatUntil p m = m >>= \x -> if p x then return x else repeatUntil p m
11:08:07 <lambdabot> parse error on input `='
11:08:16 <phobes> > let x n = x n*n+1 in x 1
11:08:17 <koeien> :t let repeatUntil p m = m >>= \x -> if p x then return x else repeatUntil p m in repeatUntil
11:08:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> m a -> m a
11:08:19 <ac> @djinn (Monad m) => (b -> Bool) -> m b -> m [b]
11:08:25 <lambdabot> Terminated
11:08:37 <koeien> ac: that was what you were looking for
11:08:44 <Saizan> ac: djinn doesn't work with monads nor lists :)
11:08:47 <idnar> @hoogle (b -> Bool) -> m b -> m [b]
11:08:52 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
11:09:04 <idnar> heh
11:09:16 <ehird> @djinn (a->b)->(b->a)->(c->c->x)->(x->f)->f->x->a
11:09:16 <lambdabot> -- f cannot be realized.
11:09:18 <Deewiant> is djinn capable of anything useful?
11:09:23 <ehird> Deewiant: No.
11:09:29 <Deewiant> Thought so. :-P
11:09:54 <litb> doh that liftM2 is crazy
11:10:11 <Deewiant> :t liftA2
11:10:12 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:10:22 <ehird> apart from generating b a c h
11:11:35 <idnar> :t liftM
11:11:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:11:41 <idnar> :t liftM2
11:11:42 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:12:12 <Saizan> Deewiant: i've used it to derive some combinators in CPS style, they can be tricky at fisrt
11:12:42 <Deewiant> yikes, CPS
11:13:04 <litb> i'm unsure, i will just continue using the lambda expression until i understand that lift stuff
11:14:33 <Saizan> litb: in your case liftM2 = \f g h x -> (g x) `f` (h x), but yeah using it there is a little obfuscating
11:15:25 <litb> what monad it be lifted too?
11:15:33 <litb> s/too/to/
11:16:22 <Saizan> it's the (r ->) monad
11:16:35 <Saizan> the monad of functions from a fixed type r
11:16:36 <ac> ah. here's what I wanted:
11:16:38 <ac> repeatUntil p m = m >>= \x -> if p x then return [] else liftM (x:) (repeatUntil p m)
11:16:59 <koeien> you wanted all intermediate results appearantly?
11:17:04 <ac> yar
11:17:10 <litb> Saizan: oh, i haven't known that there is such a monad
11:17:37 <ac> I was serious about the " -> m [b]"
11:17:50 <idnar> @type forM
11:17:51 <Saizan> litb: the Reader monad?
11:17:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
11:18:07 <litb> hm, it becomes tedious to handle that Maybe Function in my deriveration field of the Function record. since i always have to take care whether it is Nothing or not to not get an error if i use fromJust
11:18:24 <idnar> hmm
11:18:27 <ac> idnar: that sure is close...
11:18:43 <Saizan> litb: you could take advantage of the fact that Maybe is a monad too?
11:18:47 <idnar> I guess that's really unfoldM or something
11:18:51 <idnar> :t unfoldr
11:18:52 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:19:26 <ac> is there an unfoldrM?
11:19:32 <idnar> @hoogle unfold
11:19:33 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:19:33 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:19:33 <lambdabot> Data.ByteString.unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
11:19:41 <idnar> there's unfoldrN ;)
11:19:51 <litb> i see that in one hour, when i've solved my problem, i will have understood monads finally :D
11:20:09 <litb> since now all those nifty Reader Maybe and so on Monads will fit in
11:21:15 <litb> Saizan: what i need is something that when used with (*) (+) and so on will result in Nothing
11:21:36 <ertai> Is there a standard operator for mappend?
11:22:11 <Tac-Tics> > unfoldr (\x -> if x == 0 then Nothing else Just (1, x - 1)) 5
11:22:14 <lambdabot>  [1,1,1,1,1]
11:22:26 <litb> so, like if i do: (Just (deriveration a) * b + a * (deriveration b)) to build up the new deriveration after i multiplied a and b
11:22:53 <Tac-Tics> @t divMod
11:22:54 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:22:59 <litb> if deriveration a or deriveration b is Nothing, i want the while thing to be Nothing
11:23:00 <Tac-Tics> :t divMod
11:23:00 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
11:23:42 <phobes> What's a deriveration?
11:23:48 <Saizan> litb: that's liftM2
11:23:54 <Tac-Tics> > unfoldr (\x -> if x == 0 then Nothing else Just (divMod x 2)) 16
11:23:55 <lambdabot>  [8]
11:24:06 <Saizan> > liftM2 (+) Nothing Nothing
11:24:10 <lambdabot>  Nothing
11:24:23 <Saizan> > liftM2 (+) (Just 1) (Just 2)
11:24:23 <koeien> yes liftM2 indeed
11:24:24 <lambdabot>  Just 3
11:24:26 <koeien> :t liftM2
11:24:26 <Tac-Tics> > unfoldr (\x -> if x == 0 then Nothing else Just (divMod x 2)) 127
11:24:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:24:27 <lambdabot>  [63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:24:41 <Saizan> > liftM2 (+) (Just 1) (Nothing)
11:24:42 <lambdabot>  Nothing
11:24:46 <Saizan> ?src liftM2
11:24:47 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:24:47 <litb> Saizan: ah now i see
11:25:06 <litb> Saizan: i knew i've used it before but forgot that it can be used like this. thanks you man. i will look into this now
11:25:09 <Tac-Tics> :t liftM
11:25:10 <pjd> @djinn a -> (a -> b -> c -> d) -> b -> (e -> a -> f -> d -> g -> h) -> e -> f -> g -> c -> h
11:25:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:25:10 <lambdabot> f a b c d e f g h = d e a f (b a c h) g
11:25:19 <idnar> haha
11:25:25 <pjd> ehird: -^
11:25:29 <litb> phobes: i mean f' as the deriveration of f
11:25:37 <litb> don't know whether that is correct english tho
11:25:54 <idnar> litb: I think you mean "derivative"
11:26:05 <litb> ah yeah
11:26:10 <vincenz> haskell is super fast
11:26:17 <vincenz> Equality infinity invariant 2: OK, 1000000 tests
11:26:25 <vincenz> 1M infinite equality checks
11:28:33 <ehird> pjd: doesn't count
11:28:40 <pjd> ehird: :P
11:28:41 <ehird> d e a f (b a c h) would get you bonus points though.
11:28:50 <pjd> ehird: i really tried
11:29:04 <vincenz> not that hard
11:29:13 <ehird> d e a f (b e e t h o v e n) -- mega extra points
11:29:14 <pjd> but djinn's assignment is too strict
11:29:22 <vincenz> @djinn a -> (a -> b -> c -> d) -> b -> (e -> a -> f -> d -> h) -> e -> f -> g -> c -> h
11:29:23 <lambdabot> f a b c d e f _ g = d e a f (b a c g)
11:29:29 * vincenz palmslaps
11:29:36 <idnar> heh
11:29:49 <vincenz> djinn is too smart
11:31:02 <litb> liftM2 (+) (liftM (*) (derivative a) (Just (function b))) + (liftM (*) (derivative b) (Just (function a)))
11:31:07 <ehird> 'b a c h' and 'd e a f (b e e t h o v e n)'
11:31:10 <ehird> are the only current challenges
11:31:10 <ehird> :P
11:31:16 <litb> oh, that + is right indeed
11:31:32 <litb> but that's how i have it now. i think that is rite now
11:32:05 <litb> and indeed liftM2 for (*) too..
11:35:03 <RayNbow> dons, the RW Haskell site's getting more responsive :)
11:36:58 <Cale> @djinn a -> (a -> b -> c -> d) -> b -> (e -> a -> f -> d -> h) -> e -> f -> g -> c -> (h,g)
11:36:58 <lambdabot> f a b c d e f g h = (d e a f (b a c h), g)
11:37:21 <Cale> You have to put the unused letters somewhere.
11:37:26 <vincenz> Cale: now let's use boxed types to do it in g-flat
11:37:27 <hexpuem> What can i use for tracking client state in a concurrent network server? mvar, State monad?
11:38:25 <vincenz> hexpuem: ST
11:38:30 <vincenz> state monad is single-threaded
11:38:35 <hexpuem> ok thanks
11:38:38 <vincenz> or is it STM
11:38:39 * vincenz ponders
11:39:01 <Cale> vincenz: Someone should make a programming that's a ripoff of F# and call it Gb
11:39:08 <Cale> programming language *
11:39:20 * Cale takes another slurp of coffee :)
11:39:21 <byorgey> Cale: hehe
11:40:11 <Cale> Heh, or just rename O'Caml to that and you'd be done.
11:40:14 * byorgey prefers Ex
11:40:18 <pattern> i'm running in to problems with this tutorial... http://www.lisperati.com/haskell/ht1.html  the example program is trying to import Text.Regex (and i have the regex-base and regex-compat packages installed) but ghc is complaining that it "Could not find module `Text.Regex'"
11:40:25 <byorgey> but fewer people would get that...
11:40:36 <Cale> byorgey: I like it
11:40:58 <tibbe> @seen dons
11:40:58 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 18m 33s ago.
11:41:01 <dons> tibbe: ?
11:41:03 <byorgey> Cale: =)
11:41:35 <vincenz> Cale: and then start a company about it, french frog-eaters
11:42:07 <vincenz> with lots of interesting books on this ultra-cool and good language and how it is so much better than ANYTHING else out there, inccluding F#
11:42:27 <Cale> heh
11:42:33 <tibbe> dons: http://www.johantibell.com/projects/hyena/docs/Hyena-ByteStringParser.html -- My light version of a ByteString Parsec (have some combinators to add but that's trivial, only added those I needed). Does it look reasonable. In particular is there any potential inefficient things in the interface itself
11:42:35 <lambdabot> http://tinyurl.com/3bnfuy
11:42:43 <pattern> any suggestions on how i might coax ghci to find Text.Regex module ?
11:43:04 <dcoutts> pattern: install the regex-compat package
11:43:08 <pattern> i have
11:43:30 <Cale> cale@zaphod:~$ ghc-pkg list | grep regex-compat
11:43:38 <dons> tibbe: awesome. i'll grab it and have a play
11:43:47 <dons> do we have an example parser ?
11:43:48 <Cale> that commandline is how you can tell if it's installed
11:44:12 <vincenz> tibbe: What was the main complexity w.r.ty parsec?
11:44:35 <pattern> Cale: that command returns nothing... but my package manager tells me that dev-haskell/regex-compat is installed
11:45:01 <pattern> maybe it was installed for an earlier version of ghci...
11:45:06 <tibbe> dons: http://darcs.johantibell.com/hyena -- Not separated from my web server yet
11:45:06 <pattern> i'll try re-installing it
11:45:06 <Cale> Possibly.
11:45:08 <lambdabot> Title: Index of /hyena/
11:45:33 <tibbe> dons: I still need to finish the efficient specializations of bytes, noneOf, oneOf, etc
11:45:40 <tibbe> dons: Trying to get the interface right first
11:45:53 <tibbe> vincenz: what do you mean?
11:46:00 <dcoutts> tibbe: is this for strict or lazy bytestrins or both?
11:46:12 <tibbe> dcoutts: lazy right now
11:46:19 <dcoutts> tibbe: excellent :-)
11:46:30 <tibbe> dcoutts: although I guess a L.toChunks would do it ;)
11:46:38 <dons> tibbe: so what code should i look at?
11:46:42 <tibbe> dcoutts: or fromChunks rather
11:46:47 <dcoutts> tibbe: yes
11:47:00 <dcoutts> to make a single chunk 'lazy' bytestring
11:47:04 <dons> tibbe: the parsec version is in ByteStringParser ?
11:47:20 <tibbe> dons: In Hyena/ByteStringParser.hs mainly, there's a convenience interface in Hyena/ByteStringParser/Char8.hs
11:47:25 <tibbe> dons: yes
11:47:35 <tibbe> dons: dcoutts vincenz : food!
11:47:38 <dons> ok. looks nice.
11:47:43 <dons> data S = S {-# UNPACK #-} !S.ByteString  -- current chunk L.ByteString                  -- rest of the input {-# UNPACK #-} !Int64         -- bytes read
11:47:46 <vincenz> tibbe|away: oh, small suggestion
11:47:47 <dons> :)
11:47:51 <vincenz> tibbe|away: don't use state, use a stricter state
11:48:02 <vincenz> tibbe|away: we noticed a lot of slow-down during icfp with plain old state
11:48:04 <tibbe|away> dons: not optimized at all, had to take out some optimizations because I had bugs, need to fix and put back
11:48:12 <dons> yeah, i bet we can take some ideas from binary
11:48:16 <tibbe|away> vincenz: I use a custom
11:48:16 <dons> the state types are so similar
11:48:16 <vincenz> tibbe|away: not to menton tht you won't get inline accross modules
11:48:21 <tibbe|away> brb
11:48:32 <vincenz> ah ok :)
11:49:29 <pattern> hmm... re-installing regex-compat required regex-base, which complains during the install that:  "Text/Regex/Base/RegexLike.hs:44:17: Could not find module `Data.ByteString': it is a member of package bytestring-0.9.0.1, which is hidden"
11:49:34 <tibbe|away> I'll do a paste so people can comment
11:49:52 <tibbe|away> @paste
11:49:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:50:08 <hpaste>  tibbe pasted "ByteString parser" at http://hpaste.org/5157
11:50:19 <dcoutts> pattern: you're using old versions of regex-* then, the current ones work with ghc-6.8
11:50:19 <tibbe|away> ah shit, over the limit
11:50:43 <pattern> dcoutts: ah... that must be it.. let me see if i can install a newer regex-*
11:50:44 <vincenz> http://rafb.net/paste
11:50:51 <dcoutts> pattern: on hackage, get the 0.7x.0.x versions not the 0.9x versions
11:51:11 <hpaste>  tibbe annotated "ByteString parser" with "ByteString parser #2" at http://hpaste.org/5157#a1
11:51:30 <tibbe|away> dons: I've only done work on satisfy
11:51:43 <pattern> dcoutts: i already have the 0.72 regex-* packages installed... but they don't seem to want to reinstall
11:51:52 <RayNbow> ghci> fromList "durian"
11:51:56 <RayNbow> ^ a durian?
11:51:57 <pattern> i'm going to try installing 0.72.0.1
11:52:08 <RayNbow> that fruit that has an awful smell? :p
11:53:08 <pattern> oh yeah, i read about those fruits
11:53:09 <pattern> haha
11:53:30 <pattern> they supposedly smell like rotting flesh... and some airlines won't allow you to have one on the plane
11:53:57 <phobes> Does anyone else think that 'zipWith' should be named 'zip'?
11:54:11 <Cale> http://www.kibo.com/kibofood/durian_wafer.html
11:54:12 <lambdabot> Title: Kibo: Durian and Durian Wafer Photos
11:54:21 <dcoutts> pattern: the 0.7x.0.x versions not the 0.7x versions, note the extra .0.1 or .0.2
11:54:51 <vincenz> dons: is it possible to combine tix and prof to get a graphical overlay of code-runtime-percentage?
11:54:59 <Cale> "Imagine you were scooping out a pumpkin that smelled 10x stronger, and it was filled with what looked like fluorescent yellow runny scrambled eggs surrounded by fibers and containing several avocado pits. And the outside has spikes which hurt your hands and are covered with a sticky, smelly slime you can't wash off anything. But if you can get past the physical attributes, it just tastes like raw pumpkin goop only mo
11:54:59 <Cale> re so."
11:56:05 <dons> vincenz: oh, cute idea.
11:56:07 <dons> talk to andyjgill_
11:56:45 <hpaste>  litb pasted "darn" at http://hpaste.org/5158
11:57:05 <litb> how can i get rid of those Show and Eq instance declaration, because i don't need them?
11:57:24 <litb> (but haskell errors out at compile time if i don't have them)
11:58:09 <Deewiant> surely you must need them if the compiler errors out when you don't
11:58:21 <Deewiant> +have them
11:58:31 <Saizan> litb: have dummy ones
11:58:41 <Deewiant> litb: anyway, the quick way out here is "deriving (Show, Eq)"
11:59:23 <RayNbow> <pattern> they supposedly smell like rotting flesh... and some airlines won't allow you to have one on the plane <-- the smell is so strong that it would fill the whole cabin :p
11:59:43 <pattern> dcoutts, the 0.72.0.1 versions of regex-base/posix/compat managed to install correctly... and now my program has succeeded in importing Text.Rexex
11:59:45 <pattern> thanks you!
11:59:46 * kaol thought at first that Cale was talking about a monad
11:59:53 <RayNbow> but the fruit has a nice taste though
12:00:04 <dcoutts> pattern: np
12:00:28 <litb> Deewiant: that doesn't work, i already tried that, since it says "No instance for (Eq (Double -> Double))" and so on
12:01:12 <Deewiant> then it's Saizan's suggestion and do something like "(==) _ _ = True"
12:01:36 <pejo> litb, why are you comparing functions?
12:02:00 <litb> pejo: i don't
12:02:08 <thetallguy> kaol: is your hlibrary.mk available from a source code repository?
12:02:38 <litb> pejo: it just gives me that errormessage if i append "deriving (Show, Eq)" after my Function datatype
12:03:07 <kaol> thetallguy: not yet. Though it would take all of 2 minutes to set up one.
12:03:08 <litb> pejo: i think because it tries to compares them, and fails
12:03:34 <Deewiant> litb: you shouldn't need deriving Eq unless you're trying to compare them somewhere
12:03:45 <doserj> he needs it for Num
12:04:04 <thetallguy> kaol: would be nice.  We're trying to finish up our package builder (the one built at Linspire) and publish some package repositories
12:04:22 <litb> yeah, because Num somehow forces me to instantiate it (how does it do that anyway?)
12:04:27 <thetallguy> kaol: so far, we haven't tackled non-debianized cabal packages.
12:04:29 <doserj> @src Num
12:04:29 <lambdabot> class  (Eq a, Show a) => Num a  where
12:04:29 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:04:29 <lambdabot>     negate, abs, signum     :: a -> a
12:04:29 <lambdabot>     fromInteger             :: Integer -> a
12:04:54 <Deewiant> you're making an instance of Num for functions but not one for Eq?
12:04:55 <litb> ah, i see
12:05:08 <litb> Deewiant: yeah
12:05:28 <Cale> Making Num a subclass of Eq and Show was a mistake, I think.
12:05:34 <thetallguy> kaol: does it make sense to put that .mk in a package itself and make it a build dependency?  If it was in a darcs repository, we could pull it automatically
12:05:37 <litb> i was adviced to make one for Num, to be able to make "func1 * func2" or, "fromScalar 10 * func2" and so on
12:06:00 <ehird> Cale: why?
12:06:03 <litb> indeed it was a mistake o.O
12:06:08 <kaol> looks like it would be fairly easy to parse a .cabal file and generate a debian/control file and just stick in my hlibrary.mk and be done with it
12:06:27 <kaol> thetallguy: I was thinking of having it included with haskell-devscripts
12:06:29 <Cale> ehird: Because there are many things which one would consider numbers, but which don't have a computable equality, or any reasonable way to turn them into strings.
12:06:49 <litb> ... like my Function datatype once again
12:07:03 <litb> i'm proud that Cale feels with me
12:07:08 <ehird> Cale: Uh, I guess
12:07:24 <ehird> One would question whether there is much actual point making them Nums, though
12:07:26 <Deewiant> Cale: now I'm intrigued. Example, please :-)
12:07:30 <litb> and i wonder why they did it a subclass of Show, but not of Read then?
12:08:02 <litb> s/did/made/
12:08:16 <Cale> Deewiant: Well, try writing an instance of Eq for say, real numbers represented as Cauchy sequences of rationals.
12:08:27 <Cale> (though there's a sort of reasonable Show there)
12:08:51 <litb> ok, enough of dirty hacks, i will make my own operators now :)
12:09:01 <Cale> Functions whose codomain is any numeric type also behave just like numbers, but we can't necessarily show them or compare them for equality.
12:09:14 <Deewiant> Depending on how you represent the sequences, you can try to reduce to equivalent representations to each other
12:09:28 <Deewiant> s/reduce to/reduce two/
12:10:11 <Deewiant> although I guess you have a point in that it's too tricky if you don't need it
12:10:19 <litb> if i make my <*> wouldn't that collide with many operators of other people, once in a big project?
12:10:38 <Deewiant> @index <*>
12:10:39 <lambdabot> bzzt
12:10:41 <Cale> Deewiant: Two sequences represent the same real number if and only if for any e > 0, there is some natural number n such that zipWith (\x y -> abs (x - y) < e) (drop n xs) (drop n ys) is an infinite list of True values.
12:11:09 <RayNbow> dons, http://book.realworldhaskell.org/admin/comments/comment/2548/
12:11:10 <lambdabot> Title: Log in | Django site admin
12:12:17 <Cale> Deewiant: There are infinitely (indeed, uncountably, if you count the uncomputable ones) many representations of any given real number in this form.
12:12:29 <Deewiant> Cale: my point was that there are ways to prove such things mechanically without having to evaluate such a list fully
12:12:47 <Cale> Yeah, but that's a bad representation for that :)
12:12:58 <Deewiant> True :-)
12:13:29 <Cale> If you wanted to be able to sometimes prove equality, you'd be better off storing real numbers as logical statements together with proofs of existence and uniqueness or something. :)
12:13:29 <Deewiant> And like said, if you don't need it this does get tricky... although one can also question the need of making such a thing an instance of Num :-P
12:14:09 * BMeph hopes no one wakes David Hilbert...
12:14:09 <Cale> But if you could decide equality of reals in general, you could solve the halting problem, as well as just about any mathematical problem at all.
12:14:18 <RayNbow> hmm, I made a typo in a comment and I can't edit the comment... ah well :p
12:14:26 <Deewiant> Cale: :-)
12:14:34 <Baughn> Cale: All you need for that is a negative time-delay element
12:14:39 <byorgey> litb: <*> is used in Control.Applicative.  So if you plan on distributing your code as a library for lots of people to use, you probably shouldn't use <*>.
12:14:47 <byorgey> litb: but otherwise, it's probably just fine.
12:15:04 <Taejo> byorgey: what's wrong with Applicative?
12:15:21 <Deewiant> @index (<*>)
12:15:22 <lambdabot> bzzt
12:15:42 <Deewiant> meh
12:16:02 <byorgey> Taejo: huh?  nothing's wrong with Applicative.  litb was asking about using the operator <*> for something else.  (I think.)
12:16:04 <kombinator> hello, I am looking for an easy way to read integers, and other things, from std input, like by using cin >> x in c++, or scanf in c
12:16:16 <Taejo> byorgey: ok
12:16:17 <kombinator> and I would like to avoid getContents
12:16:33 <Cale> kombinator: readLn ?
12:17:04 <kombinator> Cale: well, I guess that assumes that there is one integer per line
12:17:52 <Cale> kombinator: Well, if there's more than one, use  fmap (map read . words) getLine
12:18:45 <Cale> (but make sure the types aren't ambiguous -- ghci has an annoying way of defaulting things to () sometimes)
12:18:59 <Cale> Prelude> fmap (map read . words) getLine :: IO [Integer]
12:18:59 <Cale> 43 23 54 1
12:18:59 <Cale> [43,23,54,1]
12:19:48 <idnar> > read "foo" :: ()
12:19:49 <kombinator> Cale, still, there is no way to chop one integer off the input
12:20:00 <Cale> kombinator: You just want the first element of that?
12:20:01 <lambdabot>  Exception: Prelude.read: no parse
12:20:11 <phobes> Cale:  he wants to leave the rest of the string on the stream
12:20:11 <Cale> kombinator: Of course there's a way to get the first one :)
12:20:38 <vincenz> do where-bindings create unnecessary performance overhad?
12:20:43 <kombinator> Cale, but all others will be read
12:20:49 <Cale> Well, I suppose you could write a loop with getChar
12:21:03 <Taejo> vincenz: I should hope not
12:21:04 <kombinator> Cale, I'll probably resort to that
12:21:19 <Cale> Why is getContents unacceptable?
12:21:26 <vincenz> Taejo: but they're lazy
12:21:27 <thetallguy> kaol: thanks, that would be fine.
12:21:40 <vincenz> Taejo: sure, minor impact, but I'm talking about a very intensive kernel
12:22:32 <Taejo> vincenz: I was thinking of function definitions; for values, yes, they're equivalent to let, aren't they?
12:22:40 * vincenz shrugs
12:22:47 <byorgey> kombinator: if you know that the input is going to consist of a bunch of integers, it's much easier (and more Haskell-ish) to read them all at once into a list, and then process the list
12:22:51 <litb> yeah, finally it works
12:22:54 <vincenz> > let [a] = [] in 1
12:22:55 <kombinator> Cale, but it is a bit annoying that a simple thing that is used in C++ for all the algorithmic exercises cannot be mimicked in haskell
12:22:56 <lambdabot>  1
12:23:06 <vincenz> Taejo: seems so
12:23:09 <byorgey> kombinator: because of lazy evaluation this approach is perfectly efficient
12:23:29 <kombinator> byorgey: true, but you ignore all i/o errors for instance
12:23:47 <kombinator> byorgey: I wanted to wrap everything in a monad
12:24:08 <Deewiant> byorgey: I guess a problem is where you have another function which wants to do IO and you just want to strip off the first Int from a stream
12:24:34 <byorgey> Deewiant: right, in some cases the approach I described doesn't work.
12:24:49 <byorgey> or when you need to use the first int value to decide what to read next.
12:24:54 <vincenz> kombinator: I'd recommend the C monad :)
12:24:57 <jedbrown> vincenz: From the STG paper, expressions like `f (g x)' become `let gx = g x in f g' in the abstract machine code.  Thus the closure is created at this level, although it can be removed at a lower level.  I think this is still the case.
12:25:03 <Cale> byorgey: It'll work even then.
12:25:17 <kombinator> vincenz, what's that?
12:25:20 <Cale> (In the second case)
12:25:24 <vincenz> jedbrown: thanks
12:25:31 <vincenz> kombinator: poor humor :)
12:25:45 <kombinator> ok :)
12:25:52 <byorgey> Cale: I meant "decide what type to read next".
12:26:11 <Cale> byorgey: But you have a string of the file, so you can parse it in any way you see fit :)
12:26:21 <kombinator> vincenz: the fact is that I wanted to write a haskell version of a c program
12:26:30 <Cale> (even in highly context-sensitive ways :)
12:26:31 <kombinator> vincenz: and ran into it
12:26:41 <byorgey> Cale: oh, reading in a string, of course.  I was referring to my suggestion to "read a bunch of integers into a list, and then process the list".
12:26:48 <Cale> ah, okay
12:26:48 <kombinator> I use getContents in another version
12:26:50 <byorgey> Cale: but you're right, the same basic approach still works
12:28:16 * byorgey goes back to writing about the Calkin-Wilf tree on his blog
12:28:40 * vincenz goes home
12:29:27 <Cale> kombinator: Haskell is a different enough language from C that things don't really translate directly so well. Of course, you can construct that operation, it's just that people tend to prefer getting I/O over with as quickly as possible, rescuing values into the world of pure values.
12:29:58 <litb> i can do this now, and it outputs 49 :)
12:30:01 <Cale> (So much so, that we're even willing to cheat, as with getContents, to do it :)
12:30:01 <litb> putStrLn $ show ((funktion (fromScalar 2 <+> fromScalar 5 <+> (Funktion (\x -> x) (Just (fromScalar 0))))) 42)
12:30:21 <Cale> (\x -> x) = id
12:30:34 <Cale> putStrLn . show = print
12:30:35 <litb> ah, wait, that was an error. the derivative is 1, not 0
12:30:45 <litb> Cale: oh, rite
12:31:14 <kombinator> Cale: Well, I think that C->Haskell translation should be easy, only Haskell->C difficult
12:33:17 <Cale> kombinator: I think it's doable in some small linear scaling of code, but not necessarily easy. Certainly, C programs which use a lot of pointer arithmetic are going to end up looking very different unless you go and use low-level stuff to accomplish the same thing, and that's going to make things very verbose.
12:33:56 <kombinator> Cale: anyway, I feel that scanf-style IO would be useful in Haskell even if it would be used only for exercises in algorithmics
12:34:12 * jbauman wants to see someone run malloc through a C->Haskell translator
12:34:15 <litb> @src Applicative
12:34:15 <lambdabot> class Functor f => Applicative f where
12:34:15 <lambdabot>     pure  :: a -> f a
12:34:15 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:36:14 <Cale> @where oldwiki
12:36:14 <lambdabot> I know nothing about oldwiki.
12:36:37 <Cale> @oldwiki
12:36:37 <lambdabot> http://www.haskell.org/hawiki/
12:36:47 <Cale> Well, it's certainly not there.
12:37:14 <Deewiant> if you're looking for something specific, archive.org has the articles
12:38:00 <pejo> kombinator, the fact that "secure programming"-howtos mention the scanf-family of functions is a hint to ponder why we want it.
12:39:06 <kombinator> pejo: it is possible to create secure versions of them in Haskell
12:39:23 <jedbrown> Is there a simple array testsuite somewhere?  There are no tests in the array library?
12:39:35 <kombinator> pejo: I guess the problem is reading strings that can overflow a buffer
12:40:38 <hpaste>  Cale pasted "Old email from Simon to the mailing list" at http://hpaste.org/5159
12:40:47 <Cale> kombinator: hehe, look at that :)
12:42:08 <byorgey> haha, that thread was hilarious =)
12:43:29 <kombinator> Cale: C->Haskell is perfectly possible :)
12:43:58 <Cale> It's just usually ridiculously awkward to go directly. :)
12:44:03 <nelhage> With FFI, C->haskell is practically trivial, no?
12:44:05 <BMeph> I'd love to just throw the rooted tree generator program in a C-> Haskell translator, but C is too sloppy with the whole "using expressions as statements" thing.
12:44:13 <Cale> nelhage: haha
12:44:15 <nelhage> It's just ... hideous.
12:44:42 <Cale> nelhage: Well, no, doing it that way is just fine, but it's not quite what we're talking about.
12:44:43 <litb> how is the (\x ->) monad called again?
12:44:49 <Cale> (->) e
12:44:54 <Cale> ?
12:44:58 <ertai> Does someone know if there is a standard infix operator for mappend?
12:45:07 <Cale> `mappend`
12:45:48 <ertai> Cale: nice shot... but that's not much shorter
12:46:04 <hexpuem> hmm how do i create an instance of STM.TArray? the data constructor isnt in scope when i import the module
12:46:10 <vincenz> @type (<+>)
12:46:11 <lambdabot>     Ambiguous occurrence `<+>'
12:46:12 <lambdabot>     It could refer to either `<+>', imported from Control.Arrow
12:46:12 <lambdabot>                           or `<+>', imported from Text.PrettyPrint.HughesPJ
12:46:25 <litb> Cale: the one that allows  let a x = x; let b x = x; liftM2 (*) a b 2 -- outputs 4
12:46:26 <Cale> Well, if I had my way, it'd be (++)
12:46:32 <vincenz> let <++> = mappend
12:47:05 <vincenz> Cale: I think we should follow fortress, more bracket-types!
12:47:11 <Cale> litb: yeah, that's the (->) e monad
12:47:17 <Cale> litb: also called the reader monad
12:47:38 <litb> ah, THAT is the reader monad everybody talks about
12:47:54 <Cale> It's actually the unravelled reader monad.
12:48:16 <jedbrown> aka lightweight reader monad
12:49:11 <Cale> The (Reader e) monad in the libraries has a data constructor (also called Reader), and you have to run it using runReader
12:49:46 <Cale> But underneath, it's the same thing.
12:50:00 <byorgey> litb: so called because it has a sort of "state" or "environment" (the value passed as input to all the functions) but it can only read it, not write
12:50:09 <Cale> > join (*) 2
12:50:11 <lambdabot>  4
12:50:28 <litb> join (*) 64
12:50:31 <litb> > join (*) 64
12:50:32 <lambdabot>  4096
12:50:40 <litb> heh, many ways to do the same thing
12:50:48 <Cale> > liftM2 id id 64
12:50:48 <tibbe> that was yummy
12:50:48 <lambdabot>        add an instance declaration for (Num ((a2 -> r) -> a2))
12:50:55 <Cale> oh, nice
12:51:06 <Cale> > liftM2 (*) id id 64
12:51:07 <lambdabot>  4096
12:51:10 <Cale> ah, right :)
12:51:15 <litb> id3 rofl
12:52:32 <Cale> > (do f <- (*); f) 64
12:52:32 <lambdabot>  4096
12:53:14 <Cale> > (do x <- id; y <- id; return (x*y)) 64
12:53:15 <lambdabot>  4096
12:53:21 <byorgey> > ((*) <$> id <*> id) 64
12:53:22 <lambdabot>  4096
12:53:49 <litb> haskell could be goog candidate for the most obscure code obfascation or whatnot
12:54:02 <byorgey> litb: for sure =)
12:54:24 <Japsu> lambdabot needs a good obfuscator function, though @pl does pretty well for the time being
12:54:28 <Japsu> ;)
12:54:29 <Cale> litb: It's the best kind of obfuscation too -- the kind which can only be unravelled with understanding of abstractions :)
12:54:55 <Cale> Not just renaming things in a screwy way.
12:55:16 <Cale> Though we can do that too. (cf. remorse)
12:55:34 <litb> hehe
12:56:03 <phobes> Is one of "@pl @unpl" or "@unpl @pl" identity?
12:56:12 <Japsu> hardly ;)
12:56:18 <Cale> phobes: I'm pretty sure neither is.
12:56:39 <Japsu> @. pl unpl \x y [x+y]
12:56:40 <lambdabot> (line 1, column 14):
12:56:40 <lambdabot> unexpected reserved word "in" or "i"
12:56:40 <lambdabot> expecting variable, "(", operator or end of input
12:56:47 <Japsu> @. pl unpl \x y -> [x+y]
12:56:48 <lambdabot> flip flip [] . ((:) .) . (+)
12:56:48 <Cale> phobes: However, it might be the case that one of  @pl @unpl @pl = @pl  or @unpl @pl @unpl = @unpl
12:57:08 <Japsu> @. unpl pl \x y -> [x+y]
12:57:08 <lambdabot> (\ j f -> ((:)) (j + f) [])
12:57:15 <idnar> awesome
12:57:22 <Cale> hmm, where has remorse gone?
12:57:50 <Cale> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib/remorse-1.0.tar.gz -- used to be here
12:58:37 <Cale> hmm, actually it is there
12:59:14 <Cale> ftp://ftp.cs.york.ac.uk/pub/haskell/contrib lists it as there, but trying to access it in Firefox results in a "failed to change directory"
12:59:49 <doserj> http://www.haskell.org/haskellwiki/Obfuscation
12:59:49 <lambdabot> Title: Obfuscation - HaskellWiki
13:00:49 <pejo> Cale, file permissions are 600 on that particular file, but not the rest.
13:01:11 <Cale> strange
13:02:29 <Cale> anyway, that's a Haskell program which replaces all the identifiers in a Haskell source file with morse code, obfuscating it. Of course, it's been applied to its own source code.
13:02:52 <Cale> It can also reverse the process, iirc.
13:12:36 <litb> i just realize why microsoft called their shell Monad but then changed suddenly to PowerShell
13:16:19 <njbartlett> litb: I understand why the changed, but I don't understand why they called in Monad in the first place
13:16:19 <njbartlett> Oh boy, I can't type today
13:16:47 <Philippa> litb: you mean, because Monad was a codename?
13:17:01 <Philippa> njbartlett: codenames are at their best when they're slightly misleading
13:17:31 <njbartlett> Hmm true. Like OS/2 Warp... seems to suggest it was fast!
13:18:22 <jbauman> njbartlett, it was named after the philosophical term, i think
13:18:27 <jbauman> i can't remember why, though
13:19:22 <njbartlett> Oh well, if you have as many products as MS, thinking of codenames must be a challenge
13:22:25 <Cin> so, what are the read and write properties of channels from Control.Concurrent.Chan?
13:22:34 <Cin> can reading and writing be done by multiple threads?
13:22:36 <dons> yep
13:22:41 <Cin> excellent
13:23:01 <dons> see the broadcast support too,
13:23:06 <Cin> dupChan?
13:23:09 <dons> if you want the same message to go to multiple threads
13:23:10 <dons> yeah
13:23:32 <Cin> ahh, i see. thanks
13:23:39 <jedbrown> dons: Do you know of any array test suite?
13:24:42 <dons> there's tests in the ndp library
13:24:44 <dons> what kind of tests?
13:26:14 <jedbrown> I wrote an immutable array lib similar to StorableArray.  I just want to include a test-suite.  I added some features specific to multi-dimensional arrays, but they are easy to test.
13:26:25 <jedbrown> There isn't anything with the array package.
13:27:11 <dons> i think its probably easier to write your own tests
13:27:16 <dons> that check your lib against the models
13:28:00 <jedbrown> Yes, that would be easy enough.
13:29:02 <jedbrown> (The purpose is to have a standard array format for calling numeric libs with support for multi-dimensional arrays like FFTW.)
13:29:31 <dons> ok. definitely needed.
13:29:44 <dons> my plan was to redo the ndp library base as a bytestring-like array suite
13:29:48 <Gebb> Cale: I'm trying to figure out how this piece of code works: (do f <- (*); f) 64
13:29:48 <Gebb> But I can't. How are bind and return defined for the (->) e monad?
13:30:05 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5160
13:30:07 <dons> ?src (->) return
13:30:08 <lambdabot> return = const
13:30:18 <dons> ?src (->) (>>=)
13:30:18 <lambdabot> f >>= k = \ r -> k (f r) r
13:30:34 <Gebb> dons: Thanks.
13:32:02 <Botje> do { f <- (*); f } desugars do (*) >>= \f -> f or (*) >>= id
13:32:09 <jedbrown> dons: My initial thought was to base it on StorableVector, but I don't think that offers any significant advantage since we can get a zero-copy StorableVector anyway.  So I took Data.Array.Storable and added the immutable interface plus reshaping and dimension stuff.
13:32:14 <oerjan> @. pl undo do f <- (*); f
13:32:14 <lambdabot> join (*)
13:32:26 <Cale> (*) is applied to 64 to get another function, named f
13:32:31 <dons> StorableVector is good in that its likely to be fast
13:32:33 <Cale> which is then applied to 64 to get the result
13:32:43 <dons> but if you can add the extended api to  plain Storable arrays that would be great
13:32:45 <oerjan> which becomes join (*)
13:32:52 <oerjan> @src join
13:32:53 <lambdabot> join x =  x >>= id
13:35:05 <jedbrown> dons: Data.Array.Storable is based on ForeignPtr as well.  StorableVector gives a rich API for flat vectors, but I don't think it offers any advantages for the multi-dimensional case.  So the speed should be the same.  In general, taking submatrices and such requires a copy anyway.
13:35:31 <dons> ohh, yeah, i'd not thought about multidimensional ones
13:35:52 <vincenz> jedbrown: unless you go with sharing
13:36:19 <jedbrown> vincenz: How do you deal with the alignment issue?
13:37:26 <vincenz> jedbrown: ?
13:38:15 <jedbrown> vincenz: Taking a submatrix without a copy generally means that the array is no longer contiguous.
13:38:35 <jedbrown> vincenz: Except for special cases like dropping the first or last row.
13:38:46 <Cale> jedbrown: You could take care of that by precomposing with some index mapping function.
13:39:00 <Cale> jedbrown: But of course, it won't help memory usage.
13:39:06 <fberthold> Greetings all.
13:39:13 <Cale> fberthold: hello
13:39:18 <jedbrown> Cale: Of course, but the primary utility is to be able to make FFI calls.
13:39:20 <vincenz> hmm
13:39:24 <vincenz> jedbrown: what about sparse matrices
13:40:14 <jedbrown> vincenz: The ndp arrays are a pretty good approach to that, although not the most widely used one.
13:40:45 <dons> jedbrown: so you'll need pinned ForeignPtr arrays, no matter what
13:40:57 <dons> its a good constraint on the design-- C has to be able to handle it
13:41:02 <vincenz> jedbrown: I'm very tired so not thinking deeply, but I'm thinking matlab where slicing and such are the typical operations
13:41:12 <jedbrown> dons: Which is what I'm using.
13:41:13 <vincenz> jedbrown: sharing then is definitely a good idea then
13:42:46 <jedbrown> vincenz: Matlab does a copy though.  Python avoids it normally, but that can have surprising effects in an imperative language.  We should be able to share quite well, but that requires a richer representation (which most C libraries won't be able to deal with).
13:43:00 <vincenz> jedbrown: even for sparse ones?
13:43:19 <vincenz> jedbrown: well ideally yu'd have fine-grain COW, but yeah, sounds like a pickly issue
13:43:29 <vincenz> with automatic rebalancing from sparse mode to copymode
13:45:14 <jedbrown> vincenz: Indeed.  Such an approach would be quite handy, but I'm not doing it now.  Copying for these sort of operations is very rarely a speed issue anyway.
13:45:44 * vincenz nods
13:45:46 <vincenz> What is this for?
13:47:04 <jedbrown> vincenz: spectral methods for PDE, hence the need to get FFTW working in Haskell.
13:54:51 <dons> jedbrown: let me know if there's anything i can do to help.
13:55:02 <dons> try to come up with a nice haskelly api
13:59:44 <fasta> I create a structure containing an additional helper array for efficiency reasons. This helper array is part of a tree like structure and exists in every node of this tree. However, after the construction of the tree I have no interest in this value anymore. This can be statically decided. The question is: does GHC do this, should I redesign it or anything else?
14:00:30 <dons> do you remove all references to it?
14:00:52 <fasta> Removing a reference is equivalent to setting it to undefined?
14:00:57 <dons> can you calculate it at compile time in a TH splice?
14:00:59 <dons> yes
14:01:12 <fasta> In Java there is a concept of null, I only recently thought of using undefined.
14:01:15 <dons> replace the node in the structure with undefined or Nothing or some such
14:01:32 <fasta> But still the undefined value used space, doesn't it?
14:01:39 <fasta> uses*
14:01:46 <dons> its one, and its shared among all  uses.
14:02:07 <fasta> What? Constant time overhead for a tree with n nodes?
14:02:16 <fasta> Hmm, that's somewhat impressive.
14:02:19 <fasta> :)
14:04:05 <fasta> dons: I don't like TH, because the documentation is not accessible, the implementation has rough edges and I have not seen a non-trivial use of it that proves that indeed it does work.
14:04:26 <dons> it works.
14:04:28 <kowey> err... can anybody tell me where tomorrow's londonhug is going to be? (room)
14:05:46 <fasta> dons: I assume you say this because you implemented something non-trivial at Galois Inc. with it?
14:06:13 <dons> i've seen non-trivial uses. and have used it personally for small compile-time calculations
14:06:24 <dons> but you're very cautious, so i'm hesitant
14:06:42 <fasta> What's the documentation you use?
14:07:06 <dons> the TH paper, and the src to Language.Haskell.TH
14:07:07 <fasta> I read Bulat's story once, which seemed to be the most helpful.
14:07:31 <dons> anyone know why bulat's not released any haskell code in the last few years?
14:07:37 * dons had an idle thought
14:07:47 <fasta> dons: he also doesn't respond to mail.
14:07:57 <dons> he does to mine :)
14:08:01 <fasta> dons: I sent him a patch for his ArrayRef library.
14:08:07 <dons> ah
14:08:13 <fasta> dons: (to work with 6.8/6.9)
14:08:13 <dons> that's untested code.
14:08:21 <fasta> Untested code?
14:08:29 <dons> there are zero total users of ArrayRef
14:08:34 <fasta> No, there is one.
14:08:42 <fasta> I used it.
14:08:52 <dons> i wouldn't use any lib that's not on hackage, unless i had a very compelling reason
14:09:11 <sjanssen> dons: does he even use version control yet? :)
14:09:34 <fasta> I needed something that was fast and had resizable arrays (I implemented those before, but not as efficient as Bulat did).
14:09:44 <dons> or tests?
14:09:56 <dons> fasta, fair enough.
14:10:03 <dons> i need to get this ndp repackagingout
14:10:15 <fasta> dons: a very non-trivial computation gave the correct answer thousands of times.
14:10:23 <sjanssen> dons: somebody should convince him to make projects on code.haskell.org, and hand commit access out to a few people
14:10:28 <fasta> dons: that seems to suggest that it is correct.
14:10:28 <dons> i tried to use it when writing Data.Binary and it segfaulted
14:10:46 <fasta> dons: odd
14:10:57 <fasta> dons: that is not enough for Galois, though :)
14:10:58 <dons> does it have any tests?
14:11:07 <bos> fasta: we'll probably be writing about TH for the book.
14:11:09 <sjanssen> arrayref has some useful concepts -- I'd be willing to help package that with Cabal and release it
14:11:10 <fasta> dons: yes, it does.
14:11:19 <dons> impure code like that needs serious testing and good arguments for safety
14:11:39 <dons> i need more re-assurance :)
14:12:11 * vincenz thunders from the sky"Re-assurance?!? why boy, you need the brand new, spanking-clean QuickcCheck!"
14:12:13 <fasta> bos: I skimmed the book. I like the layout. No comments on contents that you might be interested in.
14:12:17 <bos> quickcheck: prozac for the anxious hacker
14:12:29 <fasta> quickcheck is too limited imho.
14:12:45 <bos> fasta: thanks
14:12:49 <fasta> It's a proof of concept. Nothing more.
14:12:50 <vincenz> lol
14:13:11 <sjanssen> fasta: you're serious?  I've worked with several projects that get tons of mileage out of quickcheck
14:13:12 <dons> there's nothing between quickcheck and model checking though
14:13:22 <vincenz> scheck?
14:13:23 <fasta> sjanssen: for pure code it's great.
14:13:23 <bos> fasta: it's not all that big. i'm sure you could do better if you wanted to :-)
14:13:32 <dons> bytestring and the stream-fusion lib are fully QuickChecked, despite impurity, fwiw
14:13:41 <vincenz> we need
14:13:47 <vincenz> instance Arbitrary World where
14:13:54 <sjanssen> fasta: right, there's that problem with IO.  QuickCheck 2 is supposedly better for that
14:14:05 <sjanssen> dons: *internal* impurity -- the interface is pure
14:14:09 <dons> right
14:14:10 <fasta> sjanssen: QuickCheck 2 is vapourware in my world.
14:14:18 <dons> code.haskell.org/QuickCheck
14:14:21 * dons slaps fasta 
14:14:26 <fasta> sjanssen: I installed it, but there were some issues with it.
14:14:44 * vincenz slaps fasta 2.
14:14:48 <sjanssen> fasta: just tone down the "proof of concept" accusations and I won't argue :)
14:14:54 <fasta> sjanssen: by "installed" I mean that I did something to it, but there was some reason why it didn't complete.
14:15:04 <fasta> sjanssen: yes, it was a bit too strong.
14:15:05 <kowey> (LondonHUG's in room A204, answering my question, thx neil)
14:15:05 <dons> sometimes i have to manage my expectations that everyone thinks code is awesome and made of win.
14:15:13 <vincenz> I think we're seeing the first true haskell rift
14:15:26 <vincenz> QuickCheck vs ...
14:15:34 <dons> vs undefined? :)
14:15:35 <fasta> We are in a cycle, btw. We had this discussion before.
14:15:38 <vincenz> UML
14:15:48 <dons> the good projects use QuickCheck, the vapourware nonhackage ones use undefiend
14:15:50 <dons> go figure.
14:15:52 <sjanssen> hunit, maybe?  I've never used it
14:16:05 <vincenz> sjanssen: nah, you better use untyped code for unitcheckinig
14:16:11 <vincenz> it allows for a lot more flexibility :)
14:16:38 <vincenz> btw, did you hear Steele slam schceme?
14:16:42 <vincenz> erm
14:16:44 <vincenz> slam Haskell
14:16:46 <dons> sjanssen: i used hunit for pcre-light, because the library had 20k loc of unit tests
14:16:46 <fasta> vincenz: no
14:16:49 <vincenz> In his fortress presentation
14:16:53 <dons> so i mapped those into hunits
14:16:55 <vincenz> it's on infoq
14:17:23 <fasta> vincenz: I just love those things called URLs. You can use them to refer to webpages.
14:17:27 <bells> vincenz: I might watch that tonight, I didn't have time last few days
14:17:35 <vincenz> @hoogle infoq
14:17:36 <lambdabot> Language.Haskell.TH.InfoQ :: type InfoQ
14:17:36 <lambdabot> Language.Haskell.TH.Lib.InfoQ :: type InfoQ
14:17:38 <vincenz> @google infoq
14:17:39 <dons> anyway, if you can't use QuickCheck, and you're writing a haskell library, you're doing something wrong
14:17:41 <lambdabot> http://www.infoq.com/
14:17:41 <lambdabot> Title: InfoQ: Tracking change and innovation in the enterprise software development com ...
14:17:44 <vincenz> there you go
14:17:51 <shachaf> @go infoq fortress steele
14:17:52 <lambdabot> http://www.infoq.com/presentations/fortress-steele
14:17:52 <lambdabot> Title: InfoQ: Fortress - programming for supercomputers
14:18:02 <bos> vincenz: what does he say?
14:18:46 <fasta> vincenz: thank you
14:18:52 <vincenz> bos: been two-three days that I saw it, and I haven't slept last night and my memory is terrible... hmm... well he was slightly bashing on haskell .. regarding... *ponders*...
14:18:57 <vincenz> can't remember :|
14:19:14 <fasta> I doubt he says:"Haskell suxors!"
14:19:40 <fasta> Probably Fortress is more suitable than Haskell, because <insert arbitrary reason>.
14:19:44 <dons> on another topic, i was listening to some vegetarian politics the other night, and they were talking about how it was important not to let you enemies define what you stand for.  in some ways i think this is important for haskell too -- we don't want to let our enemies define haskell as 'category theory' or 'math' or 'academic'. we need to be clear about what we provide, and who's heads are going to get cracked
14:19:46 <fasta> (for super-computing)
14:20:03 <dons> haskell is the vegetarianism of programming languages
14:20:17 <dons> and we're secure high in our fortress of moral superiority ;)
14:20:25 * shachaf is vegetarian.
14:20:29 * dons too
14:20:30 <shachaf> Do I get bonus Haskell points?
14:20:31 <cjb> I'm a vegetarian but I'm no good at Haskell.  It's not fair.
14:20:37 <dons> shachaf: yeah, we can start a club!
14:20:40 <cjb> gosh.  quite an outbreak.
14:20:45 <Nafai> My wife is vegan?
14:20:48 <Nafai> Does that count?
14:20:52 <vincenz> I think it was the type system
14:20:52 <Nafai> :)
14:21:18 <vincenz> dons: what is veganism then?
14:21:18 <cjb> Next thing you know, we'll have even more vegetarians than Go players in here.
14:21:21 <dons> so, when you see a bunch of comments disparaging 'real world'-ness of haskell, i say: crack some heads.
14:21:24 <litb> is there a unmonad commando for lambdabot?
14:21:31 <dons> vincenz: no animal products
14:21:41 <litb> where i can see the steps that liftM2 does ?
14:21:42 <vincenz> dons:  meant... if haskell is egeterianism
14:21:45 <shachaf> dons: I think vincenz means in the context of the analogy. :-)
14:21:49 <vincenz> right
14:21:50 <dons> animal products are like side effects
14:21:57 <dons> we only model them
14:22:00 <dons> (with tofu/monads)
14:22:03 <allbery_b> @src liftM2
14:22:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:22:10 <vincenz> I think food consumption has more side-effects
14:22:10 <litb> i mean, what exactly the liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) } does?
14:22:11 <dons> i see a new monad tutorial: monads as tofu
14:22:14 <vincenz> like bathroom and such
14:22:20 <dons> that's purely functional
14:22:21 <cjb> dons: scary.
14:22:23 <vincenz> but seriously, in your analogy, which PL is veganism?
14:22:24 <litb> @undo liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:22:25 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
14:22:31 <dons> vincenz: isabelle?
14:22:39 <cjb> vincenz: something that is pure to the extent of disallowing side-effects.
14:22:44 <litb> well, now, if i call that function, is there a tool that shows me the calls behind the scene?
14:22:47 <dons> haskell's definitely vegetarian -- you can eat honey etc. (unsafePerformIO)
14:22:56 <shachaf> Haskell disallows side effects.
14:22:58 <cjb> many vegans eat honey :)
14:22:59 <dons> while the theorem prover guys don't even use the value level
14:22:59 <vincenz> dons: and asceticism?
14:23:00 <litb> so i can see how Monad (->) e is used here?
14:23:00 <shachaf> dons: That's not Haskell. :-)
14:23:10 <vincenz> cjb: and?
14:23:32 <shachaf> litb: For which function?
14:23:45 <cjb> vincenz: so it's not the best example.
14:23:48 <shachaf> litb: It's usually easiest to look at the type, substituting (r -> a) for (m a).
14:24:01 <vincenz> oh
14:24:01 <jedbrown> dons: To follow up, one issue I'm not sure how best to resolve is the FFTW plan, then execute API.  The first time you make a plan for a given array size and type of transform, it does some heuristics to generate a fast transform and caches the result.  There is one `fftw_execute(fftw_plan)' which actually does the transform.  The catch is that planning is not thread safe, so we need a global lock.
14:24:02 <litb> shachaf: liftM2 (*) a b , with: a x = x and b x = x
14:24:03 <vincenz> right :)
14:24:13 <shachaf> @ty liftM2
14:24:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:24:35 <jedbrown> dons: An MVar would be natural, but it needs to be threaded around which is far from optimal.
14:24:36 <shachaf> So liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> r -> c
14:24:44 <vincenz> then again, once you got to asceticism, it's all side-effects again, it's like pure sel-flaggelation, like ... C
14:24:53 <shachaf> @ty liftM2 (*)
14:24:54 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
14:25:15 <shachaf> So liftM2 (*) :: (Num a) => (r -> a) -> (r -> a) -> r -> a
14:26:19 <hpaste>  tehgeekmeister pasted "Is there a better way to abstract parsers returning raw values (as opposed to LispVals)?" at http://hpaste.org/5163
14:26:56 <vincenz> tehgeekmeister: easy
14:26:57 <vincenz> fmap
14:27:03 <vincenz> map Float $ parseFloat
14:27:04 <tehgeekmeister> (with the way i'm doing it right now i'll have to end up writing about three functions for each type of value i want to parse.)
14:27:05 <vincenz> fmap Float $ parseFloat
14:27:27 <tehgeekmeister> don't i have to write my own instances of fmap for that?
14:27:49 <shachaf> litb: In this case, it multiplies two functions (like * does automatically, in, say, J).
14:28:41 <shachaf> vincenz: Not Float <$> parseFloat? :-)
14:29:04 <vincenz> that works too
14:29:21 <vincenz> tehgeekmeister: no, it's based on the underlying thing, not the thing on top
14:29:25 <vincenz> in this case Parser a
14:29:25 <shachaf> tehgeekmeister: If you're using Parsec you should have a Functor instance already.
14:29:55 <BMeph> Back to home - 'bye for now.
14:30:51 <Cale> tehgeekmeister: Any instance of Monad is an instance of Functor (at least in theory)
14:31:34 <hpaste>  mmorrow pasted "mapAccumT" at http://hpaste.org/5164
14:31:38 <tehgeekmeister> okay, so i'd just write a Parser LispVal for each of the types i'm parsing, and when i need to use that parser in other types, to get the data inside the lispval i'd just use fmap?
14:32:20 <Cale> oh, it doesn't extract the data -- it applies a function to the eventual result of the parser, giving a new parser
14:32:41 <vincenz> @type fmap
14:32:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:32:43 <vincenz> in this case
14:32:43 <tehgeekmeister> understood, but i think my question's been misunderstood
14:32:47 <Cale> okay
14:32:55 <vincenz> fmap :: (a -> b) -> Parser a -> Parser b
14:32:56 <vincenz> or
14:32:59 <tehgeekmeister> i don't want to run any computations on what's inside the Parser, i want one level deeper
14:33:04 <vincenz> fmap String :: Parser String -> Parser LispVal
14:33:11 <tehgeekmeister> I want to get the value out of the LispVal that's in the Parser
14:33:13 <Cale> for example, you could write  parseFloat = fmap Float parseFloat'  in your code.
14:33:34 <shachaf> @src liftM
14:33:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:33:40 <Cale> Same thing as liftM
14:34:55 <tehgeekmeister> okay, that's cool -- i'd rather be able to just have a parseFloat :: Parser LispVal and then when i need to, grab the value out of that LispVal in the process of parsing more complex things, such as a complex
14:35:08 <tehgeekmeister> (or something analogous to that)
14:35:36 <Cale> oh, you do that with do-notation already, no?
14:35:55 <Cale> Or you can use a more applicative style.
14:35:58 <tehgeekmeister> I can already get to the LispVal
14:36:08 <tehgeekmeister> but i want to get what's IN the LispVal
14:36:18 <tehgeekmeister> whatever that may be.
14:37:04 <tehgeekmeister> it's easy enough to get to the lispval with do notation, as you mentioned.  and the same could be done with fmap, as has been pointed out -- but how do i get to the value inside the LispVal inside the Parser?
14:37:17 <Cale> I suppose you could compose fmap with another function whose job is processing LispVals
14:37:29 <Cale> You pattern match, no?
14:37:46 <Cale> case myLispVal of
14:37:50 <Cale>   Atom s -> ...
14:37:56 <Cale>   List xs -> ...
14:37:58 <Cale>   ...
14:38:07 <tehgeekmeister> oh, i guess i forgot you can do that in a case expression.
14:38:29 <Dybber> how is this achieved: http://www.dcs.gla.ac.uk/~meurig/regexp/ ? He extends case .. of expressions so you can use regular expressions like </[0-9]+/> as patterns (when matching strings). It doesn't look like something you can do with Template Haskell
14:38:29 <lambdabot> Title: Regular Expressions in Haskell
14:38:30 <Cale> That's basically all that case expressions do in Haskell :)
14:38:52 <hpaste>  vincenz annotated "Is there a better way to abstract parsers returning raw values (as opposed to LispVals)?" with "somewhatbetter tehgeekmeister" at http://hpaste.org/5163#a1
14:39:02 <vincenz> tehgeekmeister: ^
14:39:03 <tehgeekmeister> okay, that's true.  still, i don't get the pleasure of hacking haskell very often.
14:39:04 <Cale> Dybber: by a preprocessing frontend
14:39:27 <vincenz> hmm, cut it in two
14:39:39 <Dybber> Cale, so it rewrites the sourcecode before it feeds it to GHC?
14:39:44 <Cale> yeah
14:39:53 <Dybber> ok, thanks :-)
14:40:19 <Cale> Dybber: that's pretty old by the looks of it though, I'm not sure if it's still working.
14:40:21 <vincenz> tehgeekmeister: anywho, that's the parts I change
14:40:49 <Dybber> Cale, yeah I know. But it says Haskell 98 in the latest version.
14:41:14 <Dybber> I just wanted to know how he did it.
14:41:20 <litb> hm, maybe i should make my Function datatype a Monad too. return would take a "a -> a" , and put that into a Function  type. and then invent some nice >>= action :)
14:41:33 <Cale> Yeah, GHC has lots of hooks for plugging in other source code processors.
14:43:07 <tehgeekmeister> vincenz: hmm.  i'm more trying to get to a point where i've only got one function for each part of the parsing -- one function for unsigned floats, one for signs, etcetera.  the problem is that this requires the unboxing i mentioned, unless you want to do all the parseSomething' parsers i've done, which i think is messy.
14:43:20 <Cale> litb: I don't think that type is a monad.
14:43:37 <RayNbow> @pl (\x y -> x : [y])
14:43:37 <lambdabot> (. return) . (:)
14:43:39 <Cale> litb: er...
14:43:48 <RayNbow> @pl (\x y -> [x] ++ [y])
14:43:49 <lambdabot> (. return) . (:)
14:43:56 <tehgeekmeister> vincenz: oh, nevermind, i get what your version did a lot more fully now -- i think that's definitely workable.  thanks!
14:44:14 <Cale> litb: Well, firstly, return must be completely polymorphic in the type of values it accepts.
14:44:18 <Tac-Tics> @pl (\x y -> x : [y ::Int])
14:44:18 <lambdabot> (. (return . (:: Int))) . (:)
14:44:51 <litb> oh i see
14:45:49 <vincenz> tehgeekmeister: sensei says, try to be as generic as possible, but no more
14:46:32 <Tac-Tics> @djinn a -> (b, c) -> Either a (Maybe (b, c))
14:46:33 <lambdabot> f _ (a, b) = Right (Just (a, b))
14:46:42 <Cale> litb: I haven't actually seen what your datatype is, but if it's something like  data Function a = F (a -> a), then you can make that a Monoid, but not a Monad.
14:46:46 <Tac-Tics> @djinn a -> b
14:46:47 <lambdabot> -- f cannot be realized.
14:47:26 <vincenz> :t flip undefined
14:47:27 <lambdabot> forall a b c. b -> a -> c
14:47:34 <vincenz> :t const undefined
14:47:34 <lambdabot> forall a b. b -> a
14:47:40 <vincenz> there :)
14:48:07 <nelhage> :t undefined
14:48:07 <lambdabot> forall a. a
14:48:17 <adekoba> how would I get this function: "interest p r k t = p * (1 + (r/k))^(t * k)" to compile? I think i could convert k to an integral in the exponent. Sorry, I'm a haskell noob, haha.
14:48:48 <olsner> :t fromInteger
14:48:49 <lambdabot> forall a. (Num a) => Integer -> a
14:48:52 <vincenz> :t (^)
14:48:53 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:48:54 <mauke> adekoba: is k supposed to be an integer or a float?
14:48:56 <vincenz> nope
14:49:00 <vincenz> adekoba: use ** instead of ^
14:50:04 <adekoba> mauke: k is an integer, but I can't get it to compile as an integer because it needs to be a fraction for r to be divided by it
14:50:13 <vincenz> adekoba: ah
14:50:14 <vincenz> hm
14:50:19 <vincenz> (r / fromIntegral k)
14:50:21 <mauke> adekoba: r / fromIntegral k
14:50:43 <Cale> adekoba: There are three kinds of exponentiation. ^ is for when you have a positive integral exponent, and works with any kind of Num as the base. ^^ works with negative integral exponents as well, but requires a base of fractional type. ** works when the base and exponent are both the same floating point type.
14:50:48 <adekoba> ah the ** operator seems to have worked
14:50:55 <Cale> (and so allows for fractional exponents)
14:51:02 <vincenz> adekoba: that will force k to be a floating point, not an integer
14:51:14 <vincenz> (using **)
14:52:01 <Cale> These correspond nicely to the three definitions making up exponentiation on numbers in mathematics.
14:52:11 <shachaf> > 0 ^ 0
14:52:11 <lambdabot>  1
14:52:25 <Cale> (imo. this is one of those things which the Haskell standard actually got right, with respect to numbers)
14:52:33 <adekoba> vincenz: yes, it works. thanks
14:52:57 * vincenz thinks "fromIntegral" is a poor name
14:53:12 <vincenz> especcially since we already have fromInteger
14:53:23 <Cale> It's a little long given the typical usage pattern.
14:53:37 <vincenz> Cale: not to mention confusing
14:53:39 <vincenz> :t fromInteger
14:53:40 <lambdabot> forall a. (Num a) => Integer -> a
14:53:44 <vincenz> :t fromIntegral
14:53:45 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:53:45 <unenough> what's in a name?
14:53:47 <Cale> I don't know if it's that confusing.
14:53:55 <Cale> Seems pretty descriptive to me :)
14:53:57 <vincenz> Cale: they're nearly the same
14:54:09 <Cale> And they do nearly the same thing :)
14:54:14 <vincenz> yes 'nearly'
14:54:20 <hpaste>  mmorrow pasted "delimited continuations example: productM" at http://hpaste.org/5165
14:54:20 <vincenz> which can be confusing ot noobs
14:54:41 <olsner> isn't it basically just fromInteger = fromIntegral :: (...)?
14:54:43 <shachaf> vincenz: Who tells people about fromInteger?
14:55:02 <mauke> olsner: fromInteger is more fundamental
14:55:08 <shachaf> vincenz: Until you know the difference between an Integral and an Integer, you should just use fromIntegral, probably.
14:55:09 * vincenz eyes around suspiciously like that suspicious dog in the episode of the simpsons with mel gibson
14:55:10 <mauke> it's a method in Num
14:55:11 <tehgeekmeister> which is the arbitrary precision integer, Int or Integer?
14:55:16 <Cale> Integer
14:55:23 <tehgeekmeister> Cale: thanks
14:55:41 <vincenz> shachaf: you're right, I apologize about being such a newbie
14:55:56 <Cale> heh
14:56:12 <vincenz> Cale: care to help me on the code a bit
14:56:14 <vincenz> still stuck
14:56:16 <shachaf> vincenz: I wasn't talking to you specifically.
14:56:19 <vincenz> :P
14:56:35 <adekoba> man... I get, for the most part, the syntax and the functional paradigm pretty well, but the types in haskell always throw me off.
14:56:36 <shachaf> vincenz: Sorry if that was unclear.
14:56:37 <vincenz> shachaf: they could've called fromIntegral something better
14:56:39 <vincenz> like unround
14:56:48 <shachaf> vincenz: What does it have to do with rounding?
14:57:01 <vincenz> it's the opposite o rounding, you add stuff after the .
14:57:07 <vincenz> (namely 0s)
14:57:08 <Cale> adekoba: Specifically things with numbers are are a little complicated at first.
14:57:17 <Cale> adekoba: But you get used to it :)
14:57:46 <vincenz> hmm, never mind, only for floating and above..
14:57:48 <Cale> adekoba: There's a diagram of the numeric typeclasses in the report which is possibly useful :)
14:57:50 <adekoba> Cale: hopefully! apart from that, I'm really liking it
14:57:53 <shachaf> vincenz: What does it have to do with .?
14:58:04 <adekoba> Cale: cool, i'll look into it
14:58:04 <Cale> http://haskell.org/onlinereport/classes.gif
14:58:05 <vincenz> shachaf: I'm tired and was confused, not all Nums have floatingpoints
14:58:09 <adekoba> oh thanks
14:58:21 <shachaf> > fromIntegral 5 :: Ratio Integer
14:58:21 <lambdabot>  5%1
14:58:22 * vincenz always equats fromIntegral with (injectIntoSomethingThatIsNotAnInteger)
14:58:39 <shachaf> vincenz: s/Integer/Integral/ . :-)
14:58:41 <Cale> adekoba: It doesn't tell the whole story -- those classes each define some operations.
14:58:42 <mauke> > 5 :: Rational
14:58:43 <lambdabot>  5%1
14:59:09 <shachaf> @instances Rational
14:59:10 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
14:59:19 <hpaste>  vincenz pasted "Fraction.hs" at http://hpaste.org/5166
14:59:27 <vincenz> Cale: take a look at that?
14:59:30 <Cale> vincenz: sure
14:59:33 <vincenz> shachaf: fromIntegral too
14:59:36 <shachaf> Oops, not a class.
14:59:41 <vincenz> Cale: that's just Data.Ratio, but I allow (a :-: 0)
14:59:56 <vincenz> since CFs, when calculating their exact value will cycle through infinity
15:00:00 <vincenz> and as such Data.Ratio was breaking
15:00:01 <shachaf> Oh, type Rational = Ratio Integer
15:00:05 <olsner> > 5%0
15:00:07 <lambdabot>  Exception: Ratio.%: zero denominator
15:00:27 <vincenz> it's pretty straiightforward
15:00:31 <vincenz> onyl thing I don't allow is NaNs
15:00:54 <vincenz> Cale: ready for the main meat?
15:00:58 <Cale> okay
15:01:03 <hpaste>  vincenz pasted "CF.hs" at http://hpaste.org/5167
15:01:07 <vincenz> crap
15:01:39 <hpaste>  vincenz annotated "CF.hs" with "remainder" at http://hpaste.org/5167#a1
15:02:10 <hpaste>  vincenz annotated "CF.hs" with "end" at http://hpaste.org/5167#a2
15:02:28 <vincenz> btw, whoever wrote hpaste...how come the button "remember me" doesn't actually work?
15:02:42 <Cale> I've been noticing that too.
15:02:42 <ddarius> You should simply never use fromInteger.
15:02:45 <vincenz> so arithmetic is fully borked atm
15:02:53 <vincenz> right now working on morph
15:02:55 <ddarius> glguy wrote it.
15:02:59 <litb> maybe that has something to do with curry / uncurry . how can i call a function with (a,b) as its arguments, but giving it no tuple, but "a b" (i.e "real args") ?
15:03:04 <vincenz> the main problem with morph is
15:03:13 <vincenz> I need to negate a number twice (the two extra worker calls)
15:03:21 <vincenz> to get any possible negative digits past a_0 out
15:03:23 <vincenz> eg.
15:03:41 <Saizan> remeber me has always worked for me..
15:03:48 <vincenz> not doing that will get you [1,-14]
15:03:58 <vincenz> instead f [0,1,13]
15:04:05 <Cale> It worked for me in the beginning, but suddenly stopped working at some point.
15:04:25 <vincenz> not to mention, morph is really slow
15:04:28 <shachaf> litb: What do you mean?
15:04:36 <Saizan> oh, maybe i've still the cookie from there..
15:04:42 <oerjan> litb: yep, curry / uncurry
15:04:44 <shachaf> > curry (\(a,b) -> a + b) 5 3
15:04:47 <lambdabot>  8
15:04:56 <oerjan> > uncurry (+) (1,2)
15:04:57 <lambdabot>  3
15:05:02 <shachaf> > curry (uncurry (+)) 5 3 -- :-)
15:05:03 <lambdabot>  8
15:06:07 <litb> basicially i have this:
15:06:09 <litb> (liftM2 (<+>) (liftM2 (<*>) (Just a) (ableitung b)) (liftM2 (<*>) (ableitung a) (Just b)))
15:06:10 <vincenz> as for my logic in arithmetic, I'm still a bit rusty on what to do when you're in unlimited mode and you might be hitting infinities
15:06:16 <litb> and wondered how i could simplyfy it
15:06:21 <litb> *simplify
15:06:24 <vincenz> that otherwise bit isn't finished yet
15:06:49 <vincenz> litb: what is Just?
15:06:59 <litb> for example, packing [(Just a, ableitung b), (ableitung a, Just b)]
15:07:13 <litb> ableitung returns Maybe so both are maybe
15:07:14 <EvilTerran> @src Maybe
15:07:15 <lambdabot> data Maybe a = Nothing | Just a
15:07:17 <oerjan> litb: indeed, Just is return
15:07:26 <hpaste>  magnusth pasted "rotonym" at http://hpaste.org/5168
15:07:39 <oerjan> so liftM2 (<*>) (Just a) == liftM (a <*>)
15:08:02 <oerjan> and liftM (<*> b) for the other
15:08:12 <vincenz> anyne else that feels like taking a poke :)
15:08:22 <magnusth> why does my code not eliminate copies on large lists of words? http://hpaste.org/5168
15:08:23 <vincenz> 1st annotation 'morph
15:08:33 <olsner> @pl (liftM2 (<+>) (liftM2 (<*>) (Just a) (ableitung b)) (liftM2 (<*>) (ableitung a) (Just b)))
15:08:33 <lambdabot> liftM2 (<+>) (liftM2 (<*>) (Just a) (ableitung b)) (liftM2 (<*>) (ableitung a) (Just b))
15:08:43 <olsner> helpful ;-)
15:08:48 <vincenz> very :)
15:09:02 <idnar> @pl \a b -> (liftM2 (<+>) (liftM2 (<*>) (Just a) (ableitung b)) (liftM2 (<*>) (ableitung a) (Just b)))
15:09:03 <lambdabot> ap (ap . (liftM2 (<+>) .) . (. ableitung) . liftM2 (<*>) . Just) ((. Just) . liftM2 (<*>) . ableitung)
15:09:07 <idnar> heh
15:09:14 <EvilTerran> let's not
15:09:27 <litb> holy..
15:09:37 <pjd> litb: are those <+> and <*> operators your own thing?
15:09:50 <EvilTerran> liftM2 (??) (return a) = liftM (a ??), surely?
15:09:54 <litb> pjd: yes
15:09:58 <oerjan> EvilTerran: what i said
15:10:07 <EvilTerran> litb, er, completely unrelated to the stdlib <*>?
15:10:09 <litb> pjd: i made them to add functions and multiply functions
15:10:11 <Saizan> litb: do x <- ableitung b; y <- ableitung a; return $ (a <*> x) <+> (y <*> b)
15:10:15 <litb> EvilTerran: yes, sure
15:10:18 <EvilTerran> ?hoogle (<*>)
15:10:19 <lambdabot> Did you mean: (<*>)
15:10:19 <lambdabot> Prelude.undefined :: a
15:10:19 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
15:10:22 <EvilTerran> ?hoogle <*>
15:10:23 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:10:34 <oerjan> @pl (liftM2 (<+>) (liftM2 (<*>) (return a) (ableitung b)) (liftM2 (<*>) (ableitung a) (return b)))
15:10:35 <lambdabot> liftM2 (<+>) ((a <*>) `fmap` ableitung b) (liftM2 (<*>) (ableitung a) (return b))
15:10:41 <litb> i think i confused you. i'm sorry about that :) they are my own
15:10:53 <oerjan> hmph, @pl only catches one of them
15:11:01 <idnar> I'm surprised it does anything at all
15:11:22 <ddarius>  @pl includes some "optimizations"
15:11:24 <EvilTerran> liftM2 (<+>) ((a <*>) `liftM` ableitung b) ((<*> b) `liftM` ableitung a)
15:11:38 <ddarius> @pl \x -> map f (map g x)
15:11:38 <lambdabot> map (f . g)
15:11:48 <vincenz> whomever is curious for explanation regarding the post ap (join #oasis)
15:12:18 <litb> ah, yeah, Just is return
15:12:27 <litb> but why return and not Just ?
15:12:27 <olsner> @pl do { a' <- ableitung a; b' <- ableitung b; return ((a <*> b') <+> (a' <*> b)) }
15:12:28 <lambdabot> (line 1, column 4):
15:12:28 <lambdabot> unexpected "{"
15:12:28 <lambdabot> expecting variable, "(", operator or end of input
15:12:49 <EvilTerran> or we can bust out my funky little <|, |>, <<|, |>> operators
15:13:27 <litb> so, this liftM2 (<*>) (Just a) == liftM (a <*>) isn't true anymore, now that these are my own bred?
15:13:39 <Saizan> it's still true
15:13:44 <EvilTerran> (a <|(<*>)|>> ableitung b) <<|(<+>)|>> (ableitung b <<|(<*>)|> a)
15:13:46 <litb> i see, i'm going to look into it
15:13:47 <oerjan> litb: it recognizes return as monadic, but not Just.  no real reason i guess
15:13:48 <pjd> something like (a <*> (<- ableitung b)) <+> ((<- ableitung a) <*> b)) with monadic subexpressions?
15:13:51 <EvilTerran> (if i've done that right)
15:13:54 <njbartlett> Aaargh, programming.reddit.com is no more!
15:14:01 <ddarius> Yay!
15:14:09 <dmwit> njbartlett: It just moved, right?
15:14:14 <EvilTerran> what? it's only changed address
15:14:16 <Saizan> EvilTerran: they start looking like spaceships!
15:14:22 <nornagon> llvm backend for ghc: possible? [Yn]
15:14:27 <olsner> EvilTerran: what're <<| and |>>? just the same with higher/lower precedence, or something more?
15:14:29 <EvilTerran> x <| f = f |> x = f x
15:14:43 <EvilTerran> x <<| f = f |>> x = f <$> x
15:14:44 <njbartlett> Changed address, but also you can't refresh by clicking on the little alien guy. That takes you to the main reddit.com
15:15:04 <olsner> ah, built-in lift, handy
15:15:52 <oerjan> njbartlett: erm, try your browser's refresh button?
15:15:55 * EvilTerran isn't sure if <<| |>> are the best names for the last two, but they'll do for now
15:16:08 <idnar> your browser's refresh button is probably more heavy-handed than you want
15:16:12 <idnar> I usually just hit enter in the URL bar
15:16:20 <idnar> (which is usually ^L)
15:16:32 <ddarius> F5
15:17:00 <dmwit> r
15:17:02 <idnar> The "next" link at the bottom of programming reddit is broken (goes to page 2 of reddit proper)
15:17:04 * ddarius is going to start naming all his identifiers in morse code ..-.-.--.-
15:17:05 <idnar> heh
15:17:10 <dmwit> vimperator++
15:17:19 <pjd> EvilTerran: that's rather evil genius
15:17:38 <EvilTerran> pjd, why thankyou :)
15:17:41 <njbartlett> oerjan: Browser refresh button refreshes the current page. Clicking the alien refreshes the list and takes you back to the top
15:17:45 <olsner> (a <| (<*>) |*> ableitung b) <*| (<+>) |*> (ableitung a <*| (<*>) |> b) -- how about <*| and |*> for the lifted versions?
15:18:12 <oerjan> njbartlett: ah, try the "hot" button
15:18:13 <EvilTerran> olsner, maybe make <$| and |$> the <$> ones, and use <*| and |*> for ap?
15:18:33 <olsner> ah, that might make less little sense
15:18:42 * EvilTerran just had an even eviller thought
15:18:43 <dmwit> magnusth: I don't see anything egregiously wrong.
15:18:49 <EvilTerran> in the past, i've had 'em that way, and left-associative
15:19:16 <EvilTerran> what about making 'em right-associative, and (f |> x) y = f y x etc?
15:19:29 <EvilTerran> then you could have the <|,|> equivalent of right-sections!
15:19:31 <litb> lol, youre great. it's funny to look how you hack stuff :D
15:19:43 <olsner> ah, the flip-lift-apply operator
15:19:58 <mauke> flifply!
15:21:09 <Saizan> that's why we use lambda calculus instead of SKI, right?
15:21:30 <dmwit> Because it has funnier names?
15:21:31 <olsner> Saizan: no, we only do that to look sane
15:21:54 <olsner> real programmers use single-combinator bases ;-)
15:22:12 <EvilTerran> X calculus!
15:22:24 <Saizan> no! one opcode assembly!
15:22:44 <EvilTerran> er
15:22:48 <mauke> I have a compiler that targets that
15:22:58 <EvilTerran> even X-calc needs two symbols...
15:22:58 <mauke> well, "compiler"
15:23:34 <byorgey> EvilTerran: well, since the number of programs is countable... ;)
15:23:39 <dmwit> EvilTerran: Represent your program as bits on a hard drive, calculate the (enormous) number that it represents, write it in unary.
15:23:43 <EvilTerran> yuck
15:23:45 <EvilTerran> pain
15:23:49 <dmwit> 2. ??? 3. profit
15:24:01 <EvilTerran> i'd argue that's not opcodes in the usual sense
15:24:09 <dmwit> right, me too =)
15:24:46 <znutar> you can have a one opcode turing complete machine
15:24:56 <mauke> the one true opcode is subtract and jump if negative
15:25:55 <ddarius> @google jot iota
15:25:56 <lambdabot> http://en.wikipedia.org/wiki/Iota_and_Jot
15:25:56 <lambdabot> Title: Iota and Jot - Wikipedia, the free encyclopedia
15:31:53 <olsner> EvilTerran: if you let every function application specify its own operator precedence, at least you don't need any parantheses
15:32:15 <EvilTerran> olsner, er... i think i see what you mean
15:33:19 <litb> how does this work? @src (->)e (>>=)
15:33:29 <EvilTerran> @src (->) (>>=)
15:33:29 <lambdabot> f >>= k = \ r -> k (f r) r
15:33:46 <litb> oh really easy, isn't it :) please blame me
15:34:21 <olsner> the alternatives I can think of is parantheses, some kind of tree structure (like unlambda's backticks), or operator precedence
15:34:40 <EvilTerran> olsner, i've seen it done backtick-style
15:34:46 <olsner> could be interesting to play with storing information in the factorization of numbers also
15:35:17 <olsner> something like 2^n*3^m => n $ m
15:40:26 <sw17ch> Is $= specific to HOpenGL, or does it have a wider meaning in haskell?
15:40:43 <liyang> specific#
15:41:03 <sw17ch> do you happen to know what it does off hand? I'm having a hard time finding the HOpenGL docs... the links I find on haskell.org seem to be broken
15:41:17 <liyang> ah. Er, look at its type.
15:41:29 <liyang> @type ($=)
15:41:30 <lambdabot> Not in scope: `$='
15:41:37 <sw17ch> :(
15:41:44 <liyang> lambdabot doesn't know about it. Sorry...
15:41:54 <sw17ch> @type HOpenGL.($=)
15:41:55 <lambdabot> Not in scope: data constructor `HOpenGL'
15:41:55 <lambdabot> Not in scope: `$='
15:42:02 <EvilTerran> @type (HOpenGL.$=)
15:42:03 <lambdabot> Couldn't find qualified module.
15:42:06 <Lemmih> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html#v%3A%24%3D
15:42:07 <lambdabot> http://tinyurl.com/24hd3h
15:43:24 <sw17ch> Lemmih: ah, merci beaucoup
15:43:24 <liyang> Sets a statevar, apparently!
15:44:05 <hpaste>  Yoshi pasted "Learning How To Parse Simple Expressions" at http://hpaste.org/5169
15:44:08 <sw17ch> every time i try do to something non-trivial, i need to go look up something else ad infinitum until i just quit and play video games
15:44:10 <litb> i do not understand this: "f >>= k = \ r -> k (f r) r" (>>=) accepts (a -> m a) as its second argument (k only has one argument), but there, k is given two arguments (f r) and r
15:44:16 <litb> how is that legal code?
15:44:23 <shachaf> liyang: It's part of a class, actually.
15:44:34 <shachaf> liyang: It can also set IORefs, for example.
15:44:43 <liyang> true.
15:44:49 <shachaf> litb: a -> m a?
15:45:11 <shachaf> litb: Anyway, the monad is (r ->)
15:45:13 <liyang> litb: expand m a out fully.
15:45:16 <shachaf> litb: So (m a) is (r -> a).
15:45:21 <EvilTerran> name a function you commonly pass to ap as the first parameter, anyone?
15:45:40 <Cale> Who is Yoshi?
15:45:45 <shachaf> EvilTerran: (==), possibly?
15:45:56 <litb> shachaf: ohh, thanks
15:45:56 <yoshi> I am
15:46:00 <Cale> ah
15:46:01 <litb> now i get that =)
15:46:07 <liyang> Cale: that turtley-dragon dude in the Mario games.
15:46:07 <shachaf> > ap (==) (+0) 5
15:46:08 <lambdabot>  True
15:46:08 <shachaf> > ap (==) (+1) 5
15:46:09 <lambdabot>  False
15:46:18 <Cale> yoshi: You appear to be using two separate parsing libraries at the same time.
15:46:26 <Cale> yoshi: Which isn't going to work at all.
15:46:43 <Cale> yoshi: You either have to stick with Parsec, or stick with ReadPrec, you can't go with both.
15:46:44 <shachaf> > ap(++)show"ap(++)show"
15:46:45 <lambdabot>  "ap(++)show\"ap(++)show\""
15:46:59 <EvilTerran> hmm
15:47:23 <Cale> yoshi: Well, you could, but it would be very awkward and a strange thing to do :)
15:47:35 <litb> erm, i mean a -> m b :)
15:47:43 <yoshi> my problem is that +++ is not defined in Text.ParserCombinators.Parsec
15:48:02 <Cale> yoshi: You can use <|> instead, but it's not quite the same thing.
15:48:08 <Cale> (it's left-biased)
15:48:33 <shachaf> litb: With (r ->), I generally find it easier to look at the types, instead of the implementations.
15:48:47 <shachaf> (Given the types, @djinn can do the implementations for us. :-) )
15:48:47 <yoshi> is there on alternative way for defining +++?
15:48:47 <liyang> EvilTerran: I usually use `ap` where I'd use Control.Applicative.<$> but don't want to import Control.Applicative.
15:48:56 <shachaf> Just remember that the same m has the the same r.
15:48:56 <EvilTerran> do you mean <*>?
15:49:02 <liyang> er, yes.
15:49:06 <shachaf> liyang: You mean (<*>)?
15:49:07 <liyang> and `fmap` for <$>
15:49:08 * shachaf is slow.
15:49:14 <tehgeekmeister> i tried to pattern match against the Int data constructor and it said that the constructor wasn't in scope -- what do i need to do?
15:49:19 <liyang> I'm being slow. Ignore me.
15:49:27 <Cale> yoshi: well, you could perhaps use   x +++ y = try x +++ y
15:49:30 <Cale> er
15:49:31 <shachaf> @src Int
15:49:32 <lambdabot> data Int = I# Int#
15:49:34 <Cale> yoshi: well, you could perhaps use   x +++ y = try x <|> y
15:49:36 <shachaf> tehgeekmeister: That?
15:49:40 <olsner> EvilTerran: here's another style: http://esolangs.org/wiki/1337 (sorry about the name of that, btw)
15:49:41 <lambdabot> Title: 1337 - Esolang
15:50:02 <Cale> yoshi: It would kill efficiency somewhat, but it should work.
15:50:46 <tehgeekmeister> shachaf: I n?
15:50:58 <chessguy> @quote efficien
15:50:59 <lambdabot> JonHarrop says: In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
15:51:02 <shachaf> tehgeekmeister: What?
15:51:16 <chessguy> @bot
15:51:16 <lambdabot> :)
15:51:33 <EvilTerran> @unpl ap (flip f) x
15:51:34 <lambdabot> ((\ b c -> f c b) >>= \ e -> x >>= \ d -> return (e d))
15:51:37 <EvilTerran> eew
15:51:45 <shachaf> Oh, the RWH beta has started?
15:51:48 <EvilTerran> @unpl (\f g x -> f x (g x)) (flip f) x
15:51:49 <lambdabot> (\ x -> f (x x) x)
15:51:56 <tehgeekmeister> shachaf: I is the constructor for Int, that's what i gleaned from that.  Well, it looks like it's I#, but that gives a parse error when I use it.
15:52:02 <EvilTerran> that's not good
15:52:25 * tehgeekmeister thinks what he's doing is hacky and not the best way probably
15:52:31 <Saizan> ?tell sorear if catenova has still the right happs version installed, could you remove your "Remove cookie support (interacted disasterously with HAppS bug)" patch since the bug was fixed at the time?
15:52:31 <lambdabot> Consider it noted.
15:52:56 <sorear> ...catenova?
15:52:57 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:53:00 <shachaf> tehgeekmeister: Why do you want to do that?
15:53:02 <sorear> @clear-messages
15:53:03 <lambdabot> Messages cleared.
15:53:19 <Saizan> sorear: s/catenova/where hpaste is hosted/
15:53:31 <twanvl> tehgeekmeister: You need -fglasgow-exts (or possible some equivalent -X flag) to be able to write names like I#
15:53:35 <glguy> kakapo
15:54:26 <tehgeekmeister> shachaf: in order to parse scheme complex numbers, i need to parse ints, rationals, and reals for each part, which means i have to somehow coerce the types to Float
15:55:05 <sorear> twanvl: MagicHash
15:55:19 <shachaf> tehgeekmeister: fromIntegral?
15:55:37 <tehgeekmeister> shachaf: won't that choke on floats?
15:55:54 <sw17ch> tehgeekmeister: what's the syntax for scheme complex numbers
15:56:11 <sorear> Saizan: ... it's been so long since I touched this. I can try, but I don't guarantee it will be pretty
15:56:17 <EvilTerran> ?type (==) <*> (+1)
15:56:20 <lambdabot> forall a. (Num a) => a -> Bool
15:56:32 <EvilTerran> ?type (((==) <*> (+1)) <*>)
15:56:33 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
15:56:33 <lambdabot>     Probable cause: `==' is applied to too many arguments
15:56:33 <lambdabot>     In the first argument of `(<*>)', namely `(==)'
15:56:34 <ddarius> tehgeekmeister: You don't need to do any "coercing" to do what you want.
15:56:35 <tehgeekmeister> <num>+<num>i where <num> can be a scheme int, rational, or real
15:56:38 <shachaf> tehgeekmeister: Wait, what are you trying to do?
15:56:50 <Saizan> sorear: just reverting the patch should work, if there's still HAppS 0.8.* there
15:56:56 <tehgeekmeister> ddarius: explain please?
15:57:05 <tehgeekmeister> shachaf: parse scheme complex numbers
15:57:24 <sw17ch> tehgeekmeister: i just finished writing an abomination that pretends to parse Common Lisp
15:57:33 <sw17ch> and i'm curious how similar the syntax of the number representations was
15:57:52 <shachaf> tehgeekmeister: Why would you need to patter-match on Int's constructor for that?
15:57:52 <hpaste>  mmorrow annotated "Calling a Haskell library from C" with "dug this up" at http://hpaste.org/5104#a3
15:58:16 <ddarius> tehgeekmeister: Simply recognize whether a string is representing a float or a int or a rational and return the appropriate type (in a disjoint union).
15:58:20 <shachaf> sw17ch: Parse Common Lisp?
15:58:27 <shachaf> sw17ch: With reader macros? :-)
15:58:39 <sw17ch> shachaf: dude, not that complex :) it can make it into a syntax tree
15:58:40 <sw17ch> that's it :)
15:58:46 <tehgeekmeister> shachaf: as i mentioned, it's hacky and not a good way of doing things.
15:58:47 <EvilTerran> hm... i can't get the <*> ones working right
15:58:49 <sw17ch> i mean, this thing is dumb
15:58:55 * Pseudonym shudders... parsing Common Lisp...
15:59:09 <ddarius> tehgeekmeister: Alternatively, with some potential issues, parse it as a float and check if the fractional part is zero and if it is round/truncate/floor/ceil (whichever you want, they should all be the same in that case)
15:59:14 <sorear> you don't parse common lisp, you interpret or compile it
15:59:16 <sw17ch> but as far as i can tell, anything i passed into it is turned into a pretty (no, that's a lie, it's not pretty) AST
15:59:26 <Pseudonym> The only language with a more confusing lexical syntax than Fortran.
15:59:28 <ddarius> Pseudonym: Still probably easier than C++.
15:59:30 <sorear> macros have their virtues, preserving phase distinctions isn't one of them
15:59:57 <Pseudonym> ddarius: Only Lisp can parse Lisp.
16:00:00 <yoshi> Cale: I solved the problem with p +++ q =  p `mplus` q, I still have this second type error: Couldn't match expected type `[Char] -> Either ParseError Int' against inferred type `[a]'. It makes no sense.
16:00:05 <glguy> sw17ch: common lisp is a lot more complicated than loading things into trees separted by (, ) and ' '
16:00:16 <liyang> Pseudonym: bet Chuck Norris can parse Lisp.
16:00:40 <sw17ch> glguy: i learned that over the course of writing this thing
16:00:40 <sw17ch> quasiquotation caught me off guard specifically
16:00:40 <Pseudonym> Actually, PL/I also has a more confusing lexical syntax than Fortran.  I tell a lie.
16:00:40 <tehgeekmeister> ddarius: the problem with that is that my complex type is currently Complex Float Float, because i didn't know how to make my LispVal type be (correct me if this is the wrong word) polymorphic over two type variabes
16:00:41 <tehgeekmeister> *variables
16:00:41 <ddarius> Pseudonym: That's one more languange than can parse C++.
16:00:41 <Cale> yoshi: that's the same as  p <|> q
16:00:46 <Cale> yoshi: but it won't do exactly the same thing
16:00:47 <oerjan> yoshi: for Parsec, mplus = (<|>) iirc
16:00:53 <Pseudonym> ddarius: Precisely.
16:01:20 <litb> functions with arity>2 cannot be used as infix ops?
16:01:22 <ddarius> tehgeekmeister: It doesn't need to be polymorphic at all and that is irrelevant.
16:01:24 <Pseudonym> The GCC guys were sniffing around Mercury about 10 years ago, looking for a good language to implement a C++ parser in.
16:01:35 <hpaste>  mmorrow pasted "(ghc) FFI example (continued...)" at http://hpaste.org/5170
16:01:36 <dmwit> litb: Sure they can.
16:01:39 <sw17ch> Pseudonym: is there one? :)
16:01:40 <Cale> yoshi: parse takes another parameter, apparently
16:01:41 <Pseudonym> Not just Mercury, of course.
16:01:59 <litb> i tried something like (liftM ....) (`liftM2` <+>) (liftM ....)
16:02:05 <litb> and it constantly errored out
16:02:06 <Cale> yoshi:  parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
16:02:06 <Pseudonym> sw17ch: Sure there is.  Haskell!
16:02:08 <sw17ch> at some point, i'd like to make a C parser in Parsec
16:02:14 <dmwit> litb: (<+>)
16:02:17 <tehgeekmeister> ddarius: i am lost entirely, then.
16:02:17 <sw17ch> Pseudonym: i was hoping you'd say that!
16:02:18 <ddarius> sw17ch: C is easy.
16:02:20 <litb> even had (<+>) iirc
16:02:24 <Pseudonym> ?faq Can Haskell parse C++?
16:02:24 <lambdabot> The answer is: Yes! Haskell can do that.
16:02:29 <Cale> yoshi: You left out the SourceName parameter. You can pass "" for that if you want.
16:02:30 <Pseudonym> ddarius: Except that C is LR(2).
16:02:32 <ddarius> tehgeekmeister: You seem to be creating problems that don't exist.
16:02:38 <sw17ch> ddarius: is there a good example?
16:02:42 <Pseudonym> Unless you include the lexical feedback hack.
16:02:43 <Cale> yoshi: But there's another problem.
16:02:46 * olsner is working on a C++ parser in haskell ;-)
16:02:57 <Pseudonym> olsner++
16:02:59 <sw17ch> olsner: how's it coming/what's it for?
16:03:00 <Cale> yoshi: You seem to be expecting a list of results, and that's not what parsec will give you.
16:03:01 <ddarius> sw17ch: There are several at least partial (but fairly complete) C parsers written in Haskell.
16:03:22 <sw17ch> ddarius: so why is the internet (or me) so bad at finding these things
16:03:29 <sw17ch> i must have searched for a week with no luck at all
16:03:29 <Pseudonym> C isn't actually as wasy to parse in a theoretical sense as people thing.
16:03:29 <Cale> yoshi: It'll either give you Left e where e is some error message (which you can 'show' or 'print')
16:03:30 <olsner> sw17ch: not coming very far just yet, it can parse some basic declarations from lists of tokens
16:03:41 <ddarius> sw17ch: They are mostly parts of other things.
16:03:42 <Pseudonym> The thing is, things like lexical feedback hacks are second nature to C programmers.
16:03:42 <dmwit> > let f = (`map` [1,2,3]) in f (+1) -- for litb
16:03:42 <Cale> yoshi: Or Right x, where x is the first result given by your parser.
16:03:45 <ddarius> E.g. c2hs
16:03:47 <lambdabot>  [2,3,4]
16:03:49 <sw17ch> olsner: make it to typedefs and stuff yet?
16:04:12 <sw17ch> that's where i quit and tried to learn parsec with something simpler
16:04:15 <sw17ch> like (hah!) CL
16:04:21 <dmwit> litb: Bit, I would probably prefer to just use "flip" for that.
16:04:23 <olsner> ... and then I got stuck somewhere in between "ouch, this is so much work" and "what do I *really* need a C++ parser for anyway?"
16:04:35 <Pseudonym> olsner: I can think of a few uses.
16:04:41 <litb> dmwit: hm, but that map has 2 arity. but i mean >2
16:04:42 <Pseudonym> s/Doxygen/Haddock/
16:04:45 <Pseudonym> :-)
16:04:56 * ddarius liked doxygen
16:04:58 <dmwit> ?hoogle a -> b -> c
16:05:00 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
16:05:00 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
16:05:00 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
16:05:00 <sw17ch> olsner: i have a fantastic idea for a C++/C parser.. but i do'nt have the knowhow to make it all
16:05:02 * Pseudonym did too
16:05:03 <litb> i don't see how i can pass the first one when it accepts three at all
16:05:10 <Pseudonym> Though there's one thing I didn't like about it.
16:05:14 <Pseudonym> It was hard to extend.
16:05:16 <litb>     Couldn't match expected type `t -> Maybe Funktion'
16:05:16 <litb> 	   against inferred type `Funktion'
16:05:22 <litb> that is what it says then
16:05:26 <Pseudonym> C++ makes embedding DSLs not as painful as some other languages.
16:05:52 <Pseudonym> But it'd be nice to be able to define documentation abstractions at the DSL level, rather than the C++ level.
16:05:58 <dmwit> > let f = (`curry` 3) in f (uncurry (+)) 4 -- works just fine
16:06:01 <lambdabot>  7
16:06:14 <ddarius> Pseudonym: I never considered trying to extend it.
16:06:14 <litb> hmm
16:06:52 <dmwit> litb: Note that "3" is the *second* argument to curry here.
16:06:53 <sw17ch> @type uncurry
16:06:54 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:07:09 <sw17ch> ...woa
16:07:23 <shachaf> "But its coverage of mathematical constants is not great, as we can quickly see. Let's see if Euler's number, e, is available." -- there's always (exp 1).
16:07:28 <shachaf> Oops.
16:07:32 <shachaf> Never mind. :-)
16:07:34 <ddarius> @. djinn type uncurry
16:07:34 <lambdabot> f a (b, c) = a b c
16:07:40 <dmwit> shachaf: It says so one line later. =)
16:07:51 <shachaf> dmwit: Yes, I see.
16:08:07 <litb> dmwit: yeah
16:08:08 <Pseudonym> Anyone want to make #real-world-haskell?
16:08:13 <ddarius> You have a whole countable infinity of mathematical constants and people want more.
16:08:18 <oerjan> litb: it seemed like you wanted to use liftM2 (<+>) infix?  you might want the <| |> hack.
16:08:25 <Pseudonym> Or #haskell-book?
16:08:37 <ddarius> Dammit!  Where's my Euler-Mascheroni constant?
16:08:43 <oerjan> alas an infix operator cannot be a compound expression
16:08:49 <litb> oerjan: i don't know that hack :D i will google it
16:08:53 <unenough> i am bored.
16:08:57 <unenough> > 1.79769313486231575e308 * 1.0000000000000001
16:08:58 <litb> oerjan: oh i see
16:09:07 <shachaf> Pseudonym: Isn't there already a #haskell-books?
16:09:12 <lambdabot>  thread killed
16:09:15 <oerjan> litb: might be hard to google that
16:09:27 <Pseudonym> @let harmonic n = sum [ 1%k | k <- [1..n] ]
16:09:27 <oerjan> but iirc
16:09:30 <lambdabot> Defined.
16:09:30 <ddarius> @google haskell infix expressions
16:09:31 <shachaf> Hmm, maybe not.
16:09:32 <lambdabot> http://www.haskell.org/haskellwiki/Infix_expressions
16:09:32 <lambdabot> Title: Infix expressions - HaskellWiki
16:09:35 <Pseudonym> > harmonic 10
16:09:35 <lambdabot>  7381%2520
16:09:44 <hpaste>  tehgeekmeister pasted "Perhaps seeing how I've implemented my complex parser will be of use?" at http://hpaste.org/5171
16:10:18 <Pseudonym> @let gammaApprox n = fromRational (harmonic (2^n)) - n * log 2
16:10:19 <lambdabot> Defined.
16:10:23 <Pseudonym> > gammaApprox 100
16:10:24 <lambdabot>  Add a type signature
16:10:27 <Pseudonym> > gammaApprox 100 :: Double
16:10:28 <lambdabot>   add an instance declaration for (Integral Double)
16:10:28 <lambdabot>     In the expression: ga...
16:10:37 <Beelsebob_> tehgeekmeister: I tend to find that happy is the best approach to even a vaguely complex parser
16:10:42 <Pseudonym> @let gammaApprox n' = fromRational (harmonic (2^n)) - fromIntegral n * log 2
16:10:43 <lambdabot> <local>:12:43: Not in scope: `n'  <local>:12:62: Not in scope: `n'
16:10:49 <Pseudonym> Grrr.
16:10:52 <unenough> > 1.79769313486231575e308 * 1.0000000000000001
16:10:53 <lambdabot>  1.7976931348623157e308
16:10:55 <unenough> > 1.79769313486231575e308 * 1.000000000000001
16:10:56 <lambdabot>  Infinity
16:11:06 <Beelsebob_> lol
16:11:08 <ddarius> tehgeekmeister: Use choice [liftM Float parseFloat, lift Integer parseInt, etc.] then do a case analysis.
16:11:15 <Beelsebob_> yay for floating point accuracy
16:11:19 <tehgeekmeister> Beelsebob_: I would've considered other parser libraries, but I'm doing this as part of Write Yourself a Scheme in 48 Hours
16:11:23 <magnusth> I've managed to create a Set that isn't valid (Data.Set.valid returns false on the resulting set), and indeed there are duplicates of elements in the set... how do I massage my Set into a valid one?
16:11:29 <oerjan> litb: a <| f = f a; g |> b = g b; infixl 0 <|; infixl 0 |>
16:11:47 <Cale> magnusth: Construct it differently.
16:11:49 <oerjan> there are some variations on the fixities possible i think
16:11:51 <litb> nice, thanks :)
16:12:08 <unenough> noob question: is it possible to construct sets using a logical rule? e.g. s = {x | x < a} ?
16:12:14 <litb> i will look into that tomorrow
16:12:20 <litb> have a hot night. bye all
16:12:29 <magnusth> Cale, currently I construct it from a list, do I have to make sure that there are no duplicates in the list before turning it into a Set?
16:12:43 <Cale> magnusth: the only way that could have happened is applying fromAscList with a non-ascending list, or using mapMonotonic with a non-monotonic function.
16:12:52 <tehgeekmeister> ddarius: okay, that works.
16:13:02 <Cale> Don't use fromAscList if you can't be *absolutely* certain the list will be ascending.
16:13:27 <Cale> You can use fromList as a drop in replacement, and it only costs a log factor more.
16:13:29 <magnusth> Cale, I'm using fromList (not asc), so are you saying that I shouldn't be able to end up with an invalid Set this way?
16:13:46 <Cale> Unless perhaps your Ord instance is bad?
16:13:58 <sw17ch> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y]
16:13:59 <lambdabot>  [(1,1),(2,1),(3,1),(3,2),(4,1)]
16:14:04 <Cale> Are you using mapMonotonic at all?
16:14:07 <dmwit> The Ord instance is odd, but seems correct.
16:14:11 <hpaste>  EvilTerran pasted "infix madness" at http://hpaste.org/5172
16:14:12 <dmwit> Cale: See hpaste.
16:14:27 <magnusth> Cale, yes, that might be
16:14:37 <sw17ch> unenough: you almost had it, replace your {} with []
16:14:40 <Cale> what hpaste?
16:14:55 <dmwit> http://hpaste.org/5168
16:15:01 <sw17ch> unenough: i may have missunderstood you
16:15:06 <Cale> magnusth: The instance for Ord must define a total ordering on your type in order to be usable with Set.
16:15:20 <hpaste>  EvilTerran annotated "infix madness" with "an alternative; didn't quite work, but you can hopefully get the gist of it" at http://hpaste.org/5172#a1
16:15:32 <Cale> dmwit: This is the code which constructs bad Sets?
16:15:47 <unenough> sw17ch what do you mean. i asked if haskell supports storing sets according to a logical rule
16:15:47 <Cale> ah, I see
16:15:48 <dmwit> Cale: I think so, but magnusth would know for sure.
16:16:06 <Cale> magnusth: You're only comparing the w's in compare.
16:16:12 <sw17ch> similar to this?
16:16:13 <sw17ch> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y]
16:16:14 <lambdabot>  [(1,1),(2,1),(3,1),(3,2),(4,1)]
16:16:17 <Cale> That'll result in the Ord instance not being a total order.
16:16:22 <EvilTerran> that second version was supposed to allow an approximation of sections
16:16:24 <sw17ch> or just "all integers less than 5"
16:16:37 <dmwit> Cale: r2 = rot13 w2
16:16:40 <Cale> Some things will compare equal which aren't equal, which breaks the assumptions made by Data.Set
16:16:46 <dmwit> (same for r1)
16:16:57 <EvilTerran> (x |$> y) z = x z <$> y
16:16:59 <unenough> sw17ch all integers
16:17:10 <EvilTerran> (x <$| y) z = (x <$> y) z
16:17:12 <Cale> errr
16:17:14 <EvilTerran> or something
16:17:14 <Cale> no, actually
16:17:15 <dmwit> ohhhh
16:17:18 <EvilTerran> but it didn't work :(
16:17:19 <Cale> Something stranger still
16:17:28 <dmwit> Some things will compare < when they are >.
16:17:29 <sw17ch> unenough, I'm not sure how you'd start working with that list :)
16:17:29 <dmwit> =P
16:17:32 <Pseudonym> @let pdef alpha a b = let rab = rdef a b in sum [ alpha ^ (2*(b-i)) * rab `div` (2*i+1) | i <- [a+1..b] ]
16:17:32 <lambdabot> <local>:12:27: Not in scope: `rdef'
16:17:33 <Cale> They'll compare EQ only when they're equal
16:17:41 <unenough> sw17ch store only the rule
16:17:47 <Pseudonym> @let rdef a b = product [2*a+3,2*a+5..2*b+1]
16:17:49 <lambdabot> Defined.
16:17:51 <Pseudonym> @let pdef alpha a b = let rab = rdef a b in sum [ alpha ^ (2*(b-i)) * rab `div` (2*i+1) | i <- [a+1..b] ]
16:17:52 <lambdabot> Defined.
16:17:55 <dmwit> It isn't possible to tell whether they ought to be (<) or (>), is it?
16:17:57 <sw17ch> unenough, that's beyond my knowledge
16:18:09 <Pseudonym> @let qdef alpha a b = rdef a b * alpha^(2*(b-a))
16:18:10 <Cale> and LT if w1 < w2, but if w1 == w2, and rn1 < rn2, then it'll be marked as GT
16:18:10 <lambdabot> Defined.
16:18:12 <chessguy> > 4 > 3.99
16:18:13 <lambdabot>  True
16:18:16 <chessguy> hrmm
16:18:20 <chessguy> @type (>)
16:18:21 <dmwit> magnusth: Try something like compare = compare (min w1 r1) (min w2 r2).
16:18:22 <lambdabot> forall a. (Ord a) => a -> a -> Bool
16:18:29 <unenough> well i guess symbolic math systems support something like that
16:18:30 <oerjan> unenough: perhaps you might want to use an Integer -> Bool function?
16:18:48 <Cale> Why not just use the derived instance for ord?
16:19:07 <Cale> errr
16:19:15 <unenough> oerjan in a way that could do it - but will it be possible to do union/intersection on the logical rule that defines the function?
16:19:16 <Cale> Oh, I see.
16:19:42 <dmwit> From an architectural standpoint, this is bad design, I think.
16:20:05 <oerjan> unenough: sure, use && and ||
16:20:06 <Pseudonym> @let arctanPQR alpha a b = if (b-a)<4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = pqr alpha a m
16:20:07 <lambdabot>  Parse error
16:20:08 <dmwit> The two pieces of data are "too related", sort of.
16:20:10 <Cale> Ah, so what you want is   compare (Rotonym w1 r1) (Rotonym w2 r2) = compare (sort [w1,r1]) (sort [w2,r2])
16:20:13 <Cale> most likely
16:20:33 <dmwit> Cale: Yeah, or just comparing `on` min or so.
16:20:34 <Pseudonym> @let arctanPQR alpha a b = if (b-a)<4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = pqr alpha a m; (pmb,qmb,rmb) = pqr alpha m b } in (qmb*pam+ram*pmb,qam*qmb,ram*rmb)
16:20:36 <lambdabot> <local>:15:127: Not in scope: `pqr'  <local>:15:158: Not in scope: `pqr'
16:20:43 <Cale> dmwit: No, that doesn't work.
16:20:50 <olsner> well, if anyone comes up with a use for my barely started c++ parser, let me know and motivate me to complete it! time to sleep ;-)
16:20:50 <Pseudonym> @let arctanPQR alpha a b = if (b-a)<4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = arctanPQR alpha a m; (pmb,qmb,rmb) = arctanPQR alpha m b } in (qmb*pam+ram*pmb,qam*qmb,ram*rmb)
16:20:52 <lambdabot> Defined.
16:20:54 <Cale> dmwit: Because if the mins are equal, you want to compare the other things.
16:20:55 <dmwit> err... really?
16:21:40 <dmwit> Cale: okay... yes.  But I think the thing he's trying to express is that the one part of the data completely determines the other part.
16:21:50 <ptolomy> Anyone have an idea what the performance cost of IORefs are relative to other common operations? Or is there a way to say? It seems that pretty much any time I've rewritten a pure function with IORefs and updates, the IORef solution comes out slower.
16:21:53 <Pseudonym> @let arctanApprox alpha n = let (p,q,r) = arctanPQR alpha 0 n in (q+p)%(p*alpha)
16:21:54 <lambdabot> Defined.
16:22:00 <Pseudonym> > arctanApprox 26 100
16:22:02 <lambdabot>  8110389130504397030963300508625260085901510946068090415907414752611446842907...
16:22:02 <unenough> oerjan: interesting...so i could define a func. s and say x belongs to s iff s(x) = true, (to define "belongs") and define intersection of s1 and s2 as s1(x) && s2(x)
16:22:10 <Pseudonym> > fromRational $ arctanApprox 26 100
16:22:10 <lambdabot>  77.96921905610098
16:22:15 <Pseudonym> > arctan (1/26)
16:22:15 <lambdabot>   Not in scope: `arctan'
16:22:20 <Pseudonym> > atan (1/26)
16:22:20 <lambdabot>  3.844259002118799e-2
16:22:22 <oerjan> unenough: yep
16:22:34 <magnusth> dmwit, yes, you are right... I think in the general case Cale has a point, but in this case comparing min is enough
16:22:41 <shachaf> Hmm, wasn't there a #haskell-books channel?
16:23:16 <oerjan> unenough: basically both sets and functions -> Bool form Boolean algebras
16:23:33 <dmwit> magnusth: But, surely Set has an intersect function... wouldn't that make this a lot shorter and easier?
16:24:07 <unenough> oerjan: yes, now recalling boolean algebra is almost like set algebra :)
16:24:18 <magnusth> dmwit, now I don't follow... intersecting what?
16:24:50 <dmwit> magnusth: Construct the set of words, and the set of rot13'd words.  The intersection of these sets is the set of rotonyms.
16:25:16 <magnusth> dmwit, ah, yes, good point
16:25:35 <Pseudonym> @let atht z = 1 % ((2*k+1) * z^(2*k+1))
16:25:36 <lambdabot> <local>:17:17: Not in scope: `k'  <local>:17:29: Not in scope: `k'
16:25:59 <magnusth> that's more insight than the author of the python code had as well :)
16:26:25 <Pseudonym> @let arctanTerm k = let atht z = 1 % ((2*k+1) * z^(2*k+1)) in 18 * atht 26 - 2 * atht 3801 + 8 * atht 8749
16:26:28 <lambdabot> Defined.
16:27:03 <Pseudonym> @let log2Rat n = sum [ arctanTerm k | k <- [1..n] ]
16:27:05 <lambdabot> Defined.
16:27:15 <Pseudonym> > fromRational $ log2Rat 100
16:27:16 <lambdabot>  3.416779093046448e-4
16:27:17 <Pseudonym> > log 2
16:27:19 <lambdabot>  0.6931471805599453
16:27:23 <unenough> oerjan: question is, if s Integer -> Bool, s = if (0<x && x<5) then true else false , how haskell would know that only 1,2,3,4 are in the set
16:27:28 <Pseudonym> @forget
16:27:28 <lambdabot> Incorrect arguments to quote
16:27:32 <Pseudonym> @undefine
16:27:33 <lambdabot> Undefined.
16:27:38 <dobblego> override def getArbitrary = arbitrary[Int].map(fromInt _ compose Math.abs _)
16:27:40 <dobblego> oops
16:27:44 <chessguy> > [1%2..10%3]
16:27:45 <lambdabot>  [1%2,3%2,5%2,7%2]
16:27:55 <Pseudonym> @let arctanTerm k = let atht z = 1 % ((2*k+1) * z^(2*k+1)) in 18 * atht 26 - 2 * atht 4801 + 8 * atht 8749
16:27:57 <lambdabot> Defined.
16:28:01 <Pseudonym> @let log2Rat n = sum [ arctanTerm k | k <- [1..n] ]
16:28:02 <lambdabot> Defined.
16:28:08 <Pseudonym> > fromRational $ log2Rat 100
16:28:09 <lambdabot>  3.4167791542014824e-4
16:28:14 <unenough> oerjan: or for any other arbitrary rule
16:29:12 <oerjan> unenough: well s 1 would return True
16:29:20 <Pseudonym> @undefine
16:29:21 <lambdabot> Undefined.
16:29:31 <Pseudonym> @let arctanTerm k = let atht z = (-1)^k % ((2*k+1) * z^(2*k+1)) in 18 * atht 26 - 2 * atht 4801 + 8 * atht 8749
16:29:32 <lambdabot> Defined.
16:29:36 <oerjan> and s of anything not in 1..4 would return False
16:29:40 <Pseudonym> @let log2Rat n = sum [ arctanTerm k | k <- [1..n] ]
16:29:41 <lambdabot> Defined.
16:29:44 <Pseudonym> > fromRational $ log2Rat 100
16:29:46 <lambdabot>  -3.410719242661602e-4
16:29:56 <Pseudonym> @forget
16:29:56 <lambdabot> Incorrect arguments to quote
16:29:58 <Pseudonym> @let arctanTerm k = let atht z = (-1)^k % ((2*k+1) * z^(2*k+1)) in 18 * atht 26 - 2 * atht 4801 + 8 * atht 8749
16:29:59 <lambdabot> <local>:3:0:     Multiple declarations of `L.arctanTerm'     Declared at: <lo...
16:30:06 <Pseudonym> @let log2Rat n = sum [ arctanTerm k | k <- [0..n] ]
16:30:07 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
16:30:11 <oerjan> unenough: however, this implementation does have the disadvantage it is hard to list all the True elements efficiently
16:30:11 <Pseudonym> > fromRational $ log2Rat 100
16:30:12 <lambdabot>  -3.410719242661602e-4
16:30:18 <hpaste>  dmwit annotated "rotonym" with "another possibility" at http://hpaste.org/5168#a1
16:31:21 <dmwit> Ah, well, s/findRotamers/findRotanyms/g, but you get the idea.
16:31:30 <unenough> oerjan: yes. ok, i guess that's an inherent limitation in some sense
16:32:34 <oerjan> unenough: for complicated rules that may be inherent, say if you intersect all even numbers with all odd numbers divisible by 3
16:33:13 <oerjan> it's impossible to know in general that it's empty
16:35:16 <oerjan> for finite sets there is Data.Set which does such things more efficiently
16:35:47 <Pseudonym> @let log2Approx n = sum [log2Term k | k <- [0..n] ]
16:35:48 <lambdabot> Defined.
16:35:55 <Pseudonym> > fromRational . log2Approx $ 1000
16:35:57 <Pseudonym> > log 2
16:35:58 <lambdabot>  0.6931471805599453
16:36:02 <lambdabot> Terminated
16:36:04 <Pseudonym> > log 2
16:36:05 <lambdabot>  0.6931471805599453
16:36:07 <Pseudonym> OK
16:36:09 <Pseudonym> > fromRational . log2Approx $ 1000
16:36:15 <lambdabot> Terminated
16:36:19 <Pseudonym> > fromRational . log2Approx $ 100
16:36:19 <lambdabot>  0.692464430720259
16:36:24 <Pseudonym> Hrm.
16:36:40 <dobblego> ?check \n o p -> let f = (+) in n + 0 == (n :: Int) && 0 `f` n == n && n `f` (o :: Int) == o `f` n && (n `f` o) `f` (p :: Int) == n `f` (o `f` p) -- is there any value for f besides + that will satisfy the given properties?
16:36:41 <lambdabot>  OK, passed 500 tests.
16:36:49 <Pseudonym> @undefine
16:36:50 <lambdabot> Undefined.
16:38:20 <unenough> i'm interested in learning about program that prove properties about other programs
16:38:59 <unenough> e.g. this function is never 0
16:39:04 <oerjan> unenough: Coq is often mentioned here
16:39:22 <oerjan> it's a proof assistant
16:41:01 <oerjan> dobblego: lots, what you have is a commutative monoid
16:41:16 <dobblego> oerjan, sure, but what else can replace +?
16:41:21 <shachaf> oerjan: But any specifically for Int?
16:41:52 <dobblego> oerjan, I could replace + with * and 0 with 1, but what about replacing only + ?
16:42:15 <chessguy> wow, lots of great comments on the rwh content already. i'm impressed!
16:42:37 <dmwit> It hit proggit. =)
16:42:39 <oerjan> dobblego: let g :: Int -> Int be any bijection fixing o, g' its inverse.  then \x y -> g' (g x + g y) is one such
16:43:14 <oerjan> and that's just the ones isomorphic to +
16:44:20 <oerjan> for a completely different one: xor
16:44:27 <magnusth> dmwit, what 'intersect' are you referring to in your rotonyms code?
16:44:39 <dmwit> Data.List.intersect
16:44:52 <dmwit> But I'm sure there's something similar for Data.Set.
16:45:08 <magnusth> dmwit, ah, didn't know there was one for List actually :)
16:45:41 <oerjan> dmwit: in fact, .|. and .&. too
16:45:54 <oerjan> er, dobblego ^^
16:46:00 <dobblego> oerjan, thanks
16:46:03 <unenough> coq looks impressive....
16:46:07 <shachaf> > (5 .&. 0) :: Integer
16:46:08 <lambdabot>  0
16:47:35 <oerjan> one more: \x y -> (x+1)*(y+1)-1
16:47:56 <magnusth> dmwit, sweet code, and it does work :)  only problem is the grouping of the word and its rotonym
16:47:59 <ddarius> dobblego: Incidentally, you can bind operators.
16:48:07 <dobblego> ddarius, what do you mean?
16:48:19 <dmwit> magnusth: What do you mean by grouping?
16:48:41 <ddarius> Something blatantly obvious and I'm now wondering why I said it other than the fact that it would have made you @check code clearer.
16:48:51 <oerjan> (which is just applying the g trick to * to move the unit to 0)
16:49:01 <shachaf> let (+) = somethingElse in ...?
16:49:19 <dmwit> magnusth: Oh, you want the word and its rot13 encoding at once?
16:49:28 <magnusth> dmwit, well, "jura" and "when" should be printed together, since they are each other's rotonyms
16:49:44 <Pseudonym> @let rdef a b = product [2*a+3,2*a+5..2*b+1]
16:49:45 <Pseudonym> @let qdef alpha a b = rdef a b * alpha^(2*(b-a))
16:49:45 <Pseudonym> @let pdef alpha a b = let rab = rdef a b in sum [ alpha^(2*(b-i)) * rab `div` (2*i+1) | i <- [a+1..b] ]
16:49:46 <magnusth> dmwit, also, that solution is painfully slow :(
16:49:46 <lambdabot> Defined.
16:49:47 <lambdabot> Defined.
16:49:47 <lambdabot> Defined.
16:49:56 <Pseudonym> @let log2pqr alpha a b = if b-a < 4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = pqr alpha a m; (pmb,qmb,rmb) = pqr alpha m b } in (qmb * pam + ram * pmb, qam*qmb, ram*rmb)
16:49:56 <oerjan> dobblego: anyway, there are a plethora of commutative monoids on any set
16:49:56 <lambdabot> <local>:4:125: Not in scope: `pqr'  <local>:4:156: Not in scope: `pqr'
16:50:04 <Pseudonym> @let log2pqr alpha a b = if b-a < 4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = pqr alpha a m; (pmb,qmb,rmb) = log2pqr alpha m b } in (qmb * pam + ram * pmb, qam*qmb, ram*rmb)
16:50:04 <lambdabot> <local>:4:125: Not in scope: `pqr'
16:50:14 <Pseudonym> @let log2pqr alpha a b = if b-a < 4 then (pdef alpha a b, qdef alpha a b, rdef a b) else let { m = (a+b) `div` 2; (pam,qam,ram) = log2pqr alpha a m; (pmb,qmb,rmb) = log2pqr alpha m b } in (qmb * pam + ram * pmb, qam*qmb, ram*rmb)
16:50:14 <dmwit> magnusth: Yeah, it's reeeeally slow.  Data.Set would be easy to use and much faster, with the same algorithm.
16:50:15 <ddarius> Pseudonym: Do I have my Euler-Mascheroni constant yet?  I haven't been paying attention.
16:50:15 <lambdabot> Defined.
16:50:19 <Pseudonym> ddarius: Almost.
16:50:36 <Pseudonym> @let l2frac alpha n = let (p,q,r) = log2pqr alpha 0 n in (1 + p%q) * (1%alpha)
16:50:37 <lambdabot> Defined.
16:50:41 <Pseudonym> I just need log 2 first.
16:51:19 <magnusth> dmwit, yes, I'll have to look into it :) thanks
16:51:32 <Pseudonym> @let log2 n = 18 * l2frac 26 - 2 * l2frac 4801 + 8 * l2frac 8749
16:51:33 <lambdabot> Defined.
16:51:38 <Pseudonym> > log2 100
16:51:39 <lambdabot>        add an instance declaration for (Num (t1 -> Ratio t1))
16:51:39 <lambdabot>     In the expr...
16:51:57 <ddarius> See, this is why such constants must be included in any complete standard library.
16:52:01 <Pseudonym> @let log2approx n = 18 * l2frac 26 n - 2 * l2frac 4801 n + 8 * l2frac 8749 n
16:52:02 <lambdabot> Defined.
16:52:07 <Pseudonym> > log2approx 100
16:52:08 <lambdabot>  6181250480699888841606167170161799816670436915471632139879902218223826075359...
16:52:12 <Pseudonym> > fromRational $ log2approx 100
16:52:13 <lambdabot>  0.6931471805599453
16:52:15 <Pseudonym> > log 2
16:52:15 <lambdabot>  0.6931471805599453
16:52:16 <Pseudonym> OK
16:52:20 <Pseudonym> So far, so good.
16:52:22 <chessguy> "Haskell's combination of strong and static typing makes it impossible for type errors to occur at runtime."....hmm, is it really completely impossible?
16:52:36 <ddarius> chessguy: Type errors.
16:52:42 <Pseudonym> To get a good approximation for log 2, you need a good approximation for arctanh, you see.
16:52:47 <dmwit> Type errors, yes.
16:53:39 <chessguy> i know, i am talking about type errors
16:53:48 <chessguy> i swear i had an example once where there was a run-time type error
16:54:04 <chessguy> some silly typeclass thing
16:54:07 <mightybyte> Does Cabal have a way to automatically retrieve package dependancies?
16:54:18 <oerjan> chessguy: Data.Dynamic?
16:54:20 <dmwit> chessguy: Maybe with Dynamic?
16:54:25 <chessguy> no, nothing that fancy
16:54:33 * chessguy scratches his head
16:54:36 <dmwit> hm
16:54:47 <dmwit> :t printf
16:54:47 <chessguy> i remember writing it on the back of a piece of paper because it hit me out of the blue
16:54:49 <lambdabot> forall r. (PrintfType r) => String -> r
16:55:12 <chessguy> and i asked in here and soemone said "yeah, that'll type correctly at compile time, but blow up if you use it wrong at run time"
16:55:27 <dmwit> unsafe*?
16:55:33 <chessguy> no no, nothing like that
16:55:43 <dmwit> ok, ok, just checking =)
16:55:52 <oerjan> incoherent instances?
16:55:55 <shachaf> mightybyte: cabal-install?
16:56:01 * chessguy thinks for a bit
16:56:12 <bos> @pl \s cont -> unParse m s (cont . f)
16:56:12 <lambdabot> (. (. f)) . unParse m
16:56:17 <mightybyte> shachaf: I don't know, I guess that sounds promising.
16:56:21 * oerjan doesn't know if that actually breaks type safety
16:56:27 <dons> ?users
16:56:27 <lambdabot> Maximum users seen in #haskell: 454, currently: 405 (89.2%), active: 15 (3.7%)
16:56:35 <chessguy> it had something to do with two type classes or two instances of the same type class
16:56:38 <bos> @pl \f m -> Parse (\s cont -> unParse m s (cont . f))
16:56:38 <lambdabot> (Parse .) . flip (flip . ((.) .) . unParse) . flip (.)
16:57:05 <Pseudonym> @let exppdef a b = sum [ product [k..b] | k <- [a+3..b+1] ]
16:57:08 <lambdabot> Defined.
16:57:17 <Pseudonym> @let expqdef a b = product [a+1..b]
16:57:18 <lambdabot> Defined.
16:58:22 <Pseudonym> @let exppq a b = if (b-a)<4 then (exppdef a b,expqdef a b) else let { m = (a+b)`div`2; (pam,qam) = exppq a m; (pmb,qmb) = exppq m b } in (pam*qmb+pmb,qam*qmb)
16:58:24 <lambdabot> Defined.
16:58:49 <Pseudonym> @let expseries n = let (p,q) = exppq 0 n in p%q+2
16:58:52 <lambdabot> Defined.
16:58:54 <Pseudonym> > expseries 100
16:58:56 <lambdabot>  6092190741720224664332466324720699332740050582992274813663612124339748084408...
16:59:01 <Pseudonym> > fromRational $ expseries 100
16:59:02 <lambdabot>  2.676416473360135
16:59:11 <Pseudonym> Dammit.
16:59:27 <Pseudonym> > exp 1 - fromRational (expseries 100)
16:59:33 <lambdabot>  4.186535509890987e-2
16:59:35 <Pseudonym> > 1 / (exp 1 - fromRational (expseries 100))
16:59:36 <lambdabot>  23.88609860438133
16:59:38 <Pseudonym> ...
17:00:59 * shachaf thinks Ch. 2 of RWH, at least, is a bit odd.
17:01:36 <shachaf> As if you're just throwing a lot of independent information at the reader, with nothing in particular linking bits of it together.
17:02:15 <Pseudonym> @let exppdef' a b = sum [ product [k..b] | k <- [a+1..b+1] ]
17:02:20 <lambdabot> Defined.
17:02:22 <Pseudonym> @let expqdef' a b = product [a+1..b]
17:02:23 <lambdabot> Defined.
17:02:37 <hpaste>  Yoshi annotated "Learning How To Parse Simple Expressions" with "Thanks Cale" at http://hpaste.org/5169#a1
17:02:43 <shachaf> It seems that if I was reading it, I would think "Why are they telling me all this?".
17:02:53 <Pseudonym> @let exppq' a b = if (b-a)<4 then (exppdef' a b,expqdef' a b) else let { m = (a+b)`div`2; (pam,qam) = exppq' a m; (pmb,qmb) = exppq' m b } in (pam*qmb+pmb,qam*qmb)
17:02:55 <lambdabot> Defined.
17:02:57 <Pseudonym> > exppq' 0 1000
17:02:58 <lambdabot>  (116430070534355344355013557072258363062750982776533405868224396029006964381...
17:03:10 <Pseudonym> > let (p,q) = exppq' 0 1000 in fromRational (p%q)
17:03:11 <lambdabot>  2.893483022102847
17:03:24 <Pseudonym> > let (p,q) = exppq' 0 1 in fromRational (p%q)
17:03:25 <lambdabot>  2.0
17:03:27 <Pseudonym> > let (p,q) = exppq' 0 2 in fromRational (p%q)
17:03:28 <lambdabot>  2.5
17:03:30 <Pseudonym> > let (p,q) = exppq' 0 3 in fromRational (p%q)
17:03:31 <lambdabot>  2.6666666666666665
17:03:33 <Pseudonym> > let (p,q) = exppq' 0 4 in fromRational (p%q)
17:03:34 <lambdabot>  3.2083333333333335
17:03:37 <shachaf> (Things like "Commas are separators, not terminators" and "Beware ranges of floating point numbers" especially, for example.)
17:03:41 <Pseudonym> Right.
17:03:47 * shachaf is probably a bit off-topic here. :-)
17:04:35 <hpaste>  chessguy pasted "breaking type safety?" at http://hpaste.org/5173
17:04:42 <chessguy> i think this is something like what i had
17:05:22 <dmwit> add doesn't type check, does it?
17:05:41 <chessguy> shouldn't it?
17:05:58 * chessguy doesn't have ghci handy
17:06:00 <dmwit> No, you don't return a (Foo c => [c]).
17:06:14 <chessguy> eh?
17:06:16 <shachaf> chessguy: It returns a specific Foo instance.
17:06:19 <chessguy> Int is an instance of Foo
17:06:27 <shachaf> chessguy: Rather than something that will work for any Foo instance I like.
17:06:42 <shachaf> > (1 :: (Num a => a)) :: Int
17:06:42 <lambdabot>  Parse error at "=>" (column 14)
17:06:48 <chessguy> hrmm. no, my example was even more disturbing. sigh.
17:07:13 <chessguy> this _will_ drive me nuts until i remember it
17:07:43 <Pseudonym> @let exppd a b = sum [ product [k..b] | k <- [a+2..b+1] ]
17:07:43 <Pseudonym> @let expqd a b = product [a+1..b]
17:07:44 <Pseudonym> @let expRat a b = if b-a<4 then (exppd a b, expqd a b) else let { m = (a+b) `div` 2; (pam,qam) = expRat a m; (pmb,qmb) = expRat m b } in (pam*qmb+pmb,qam*qmb)
17:07:46 <lambdabot> Defined.
17:07:48 <lambdabot> Defined.
17:07:51 <lambdabot> Defined.
17:08:02 <Pseudonym> > let (p,q) = expRat 0 100 in fromRational (p%q+1)
17:08:03 <lambdabot>  2.718281828459045
17:08:05 <Pseudonym> yay.
17:08:22 <dmwit> Whoa, it *does* typecheck!
17:08:23 <Pseudonym> @let expApprox n = let (p,q) = expRat 0 n in p%q+1
17:08:26 <lambdabot> Defined.
17:09:06 <Pseudonym> @let eulerApprox n = expApprox (2^n) - fromRational n * log2Approx n
17:09:07 <lambdabot> <local>:19:51: Not in scope: `log2Approx'
17:09:22 <dmwit> (With an additional "Num c" constraint.)
17:09:34 <Pseudonym> @let eulerApprox n = expApprox (2^n) - fromRational n * log2approx n
17:09:40 <lambdabot> <local>:19:27:     No instance for (Integral Rational)       arising from use...
17:09:48 <Pseudonym> @let eulerApprox n = expApprox (2^n) - fromIntegral n * log2approx n
17:09:54 <lambdabot> Defined.
17:10:03 <Pseudonym> > map fromRational [ eulerApprox n | n <- [1..] ]
17:10:12 <lambdabot> Terminated
17:10:18 <Pseudonym> > eulerApprox 1
17:10:21 <lambdabot>  535615590083451598150091%296435600291925236317396
17:10:28 <Pseudonym> > fromRational $ eulerApprox 1
17:10:29 <dmwit> Oh, that additional Num constraint makes a big difference.
17:10:34 <lambdabot>  1.8068531227557876
17:10:36 <Pseudonym> > fromRational $ eulerApprox 2
17:10:37 <lambdabot>  1.3220389728544915
17:10:39 <Pseudonym> > fromRational $ eulerApprox 3
17:10:40 <shachaf> > map (fromRational . eulerApprox) [1..10]
17:10:40 <lambdabot>  0.6388372281625403
17:10:41 <lambdabot>  [1.8068531227557876,1.3220389728544915,0.6388372281625403,-5.430689378073719...
17:10:54 <Pseudonym> > fromRational $ eulerApprox 4
17:10:57 <lambdabot>  -5.430689378073719e-2
17:11:00 <Pseudonym> Hrm.
17:11:40 <Pseudonym> @let eulerApprox2 n = let n2 = 2^n in expApprox n2 - fromIntegral n * log2approx n2
17:11:44 <lambdabot> Defined.
17:11:52 <Pseudonym> > map (fromRational . eulerApprox2) [1..4]
17:11:53 <lambdabot>  [1.806852819760579,1.3220389722134436,0.638837228161434,-5.4306893780738975e-2]
17:13:12 <Pseudonym> > sum [1%k | k <- [1..16] ]
17:13:17 <lambdabot>  2436559%720720
17:13:28 <Pseudonym> > expApprox 16
17:13:29 <lambdabot>  56874039553217%20922789888000
17:13:46 <Pseudonym> > exppd 16
17:13:46 <lambdabot>  <Integer -> Integer>
17:13:50 <Pseudonym> > exppd 0 16
17:13:51 <lambdabot>  35951249665217
17:13:56 <Pseudonym> > expqd 0 16
17:13:56 <lambdabot>  20922789888000
17:14:08 <Pseudonym> > 35951249665217%20922789888000 + 1
17:14:12 <lambdabot>  56874039553217%20922789888000
17:14:18 <bos> @pl \x y -> y x x
17:14:18 <lambdabot> flip =<< flip id
17:14:28 <Pseudonym> > fromRational (expApprox 16)
17:14:29 <lambdabot>  2.7182818284590424
17:14:42 <dmwit> Some kind of strange, exp-crazed bot has taken on a Pseudonym. =P
17:14:54 <Pseudonym> exp!  exp!  More exp!
17:15:14 <dmwit> Oh, yeah, baby!  Talk nerdy to me!
17:15:17 <shachaf> @ty flip join `asTypeOf` (\x y -> y x x)
17:15:18 <lambdabot> forall a b. b -> (b -> b -> a) -> a
17:15:40 <Pseudonym> > expApprox 4
17:15:41 <lambdabot>  65%24
17:15:47 <Pseudonym> > log2approx 4
17:15:48 <lambdabot>  7583432542865740774713490155519750511701928442582089936636609022774706517%10...
17:15:50 <shachaf> Pseudonym: You know about /msg, right? :-)
17:16:03 <Pseudonym> I also know about local GHCi instances.
17:16:07 <Pseudonym> But aren't you interested?
17:16:24 <oerjan> @pl \y x -> y x x
17:16:25 <lambdabot> join
17:16:30 <mightybyte> How long does it normally take to build ghc 6.8.2 on a decent machine?
17:16:49 <shachaf> Pseudonym: Perhaps #haskell-overflow is better for this?
17:16:53 <shachaf> (Never mind, sorry.)
17:16:56 <Pseudonym> Oh!
17:16:56 <oerjan> flip join
17:16:59 <Pseudonym> Duh.
17:17:12 <Pseudonym> > map (fromRational . (+1) . eulerApprox2) [1..4]
17:17:13 <lambdabot>  [2.806852819760579,2.3220389722134436,1.6388372281614338,0.9456931062192611]
17:17:16 <Pseudonym> > map (fromRational . (+1) . eulerApprox2) [1..10]
17:17:17 <lambdabot>  [2.806852819760579,2.3220389722134436,1.6388372281614338,0.9456931062192611,...
17:17:27 <Pseudonym> > map (fromRational . (+1) . eulerApprox2) [5..10]
17:17:28 <lambdabot>  [0.2525459256593187,-0.4406012549006266,-1.133748435460572,-1.82689561602051...
17:17:34 <Pseudonym> OK, maybe not.
17:17:56 * Pseudonym takes it to overflow, good idea
17:17:57 <dmwit> mightybyte: A few hours, probably.
17:18:22 <mightybyte> dmwit: Ok, I guess I won't sit around waiting.
17:18:45 <dmwit> yeah =)
17:22:14 <chessguy> geez, this is annoying1
17:22:16 <chessguy> !
17:25:24 <idnar> @kind ()
17:25:25 <lambdabot> *
17:25:30 <Cale> chessguy: what's annoying?
17:25:35 <idnar> @kind (,)
17:25:36 <lambdabot> * -> * -> *
17:25:42 <Cale> @kind Maybe
17:25:42 <lambdabot> * -> *
17:25:52 <Cale> @kind Control.Monad.RWS.RWST
17:25:53 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
17:26:06 <LoganCapaldo> @kind Cruel
17:26:07 <dmwit> ?kind (,,)
17:26:07 <lambdabot> Not in scope: type constructor or class `Cruel'
17:26:08 <lambdabot> * -> * -> * -> *
17:26:12 <chessguy> hmm, now i have a program that typechecks, but gives me an "Ambiguous type variable..." error on some inputs
17:26:46 <dmwit> That's called "not typechecking". ;-)
17:26:46 <chessguy> Cale, trying to decide if i agree with this statement: "Haskell's combination of strong and static typing makes it impossible for type errors to occur at runtime."
17:27:02 <chessguy> dmwit, it's called a runtime error
17:27:03 <pjd> > head []
17:27:10 <lambdabot>  Exception: Prelude.head: empty list
17:27:15 <Cale> chessguy: Um, are you using hs-plugins?
17:27:22 <dmwit> chessguy: Doesn't it happen at compile time?  Or am I misunderstanding?
17:27:26 <Cale> chessguy: I don't see how you could get that error at runtime.
17:27:30 <Cale> It's not a runtime error.
17:27:34 <chessguy> dmwit, no, i can :r the module
17:27:39 <chessguy> and it loads successfully
17:27:47 <Cale> chessguy: Compile it with GHC.
17:27:57 <dmwit> chessguy: Oh, most of ghci is compile-time stuff, still.
17:28:14 <Cale> chessguy: The problem is with your input on the GHCi commandline not being specific enough.
17:28:35 <Cale> chessguy: Remember, it still has to compile the expression which you type in.
17:28:51 <Cale> (so there's a little compile-time which happens after each line)
17:29:14 <chessguy> [1 of 1] Compiling Test             ( test.hs, test.o )
17:29:14 <chessguy> C:\Documents and Settings\Andrew\Desktop>
17:29:22 <chessguy> it compiled it
17:29:44 <LoganCapaldo> right
17:29:54 <dmwit> Cool, do you still get that line when you run it?
17:30:00 <LoganCapaldo> now put the same line in a file that imports your module
17:30:08 <LoganCapaldo> and compile that
17:30:17 <dmwit> exactly =)
17:31:02 <ricky_clarkson> chessguy: wrt your previous quote, it depends what you call a type error.
17:31:12 <chessguy> hmm
17:31:14 <ricky_clarkson> Arguably, head of an empty list is a type error.
17:31:17 <mightybyte> dmwit: Hmmm, the ghc compile took me 19 minutes and 3 seconds. :)
17:31:17 <ricky_clarkson> > head []
17:31:19 <lambdabot>  Exception: Prelude.head: empty list
17:31:28 <dmwit> mightybyte: Wow, great!
17:31:32 <chessguy> ricky_clarkson, true
17:31:48 <dmwit> mightybyte: You must have a fast machine, or I must be thinking of a really old version of GHC, or both.
17:32:02 <chessguy> anyway, Cale, to answer your question, i used to have a much better counter-example for this, and i can't remember it now
17:32:09 <mightybyte> dmwit: I have dual quad core xeons.
17:32:21 <mightybyte> dmwit: It used 38 minutes of CPU time.
17:32:59 <dmwit> No wonder you don't mind Haskell's performance hit. =P
17:33:13 <mightybyte> dmwit: Yep
17:33:20 <Cale> chessguy: But the compilation isn't finished there!
17:33:20 <shachaf> "decent machine"? :-)
17:33:32 <chessguy> Cale, yes, that was pointed out
17:34:16 <fberthold> Greetings all.
17:34:31 <shachaf> fberthold: Hello.
17:35:53 <bos> @seen dons
17:35:53 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 39m 27s ago.
17:41:14 <shapr> @seen shapr
17:41:14 <lambdabot> You are in #scannedinavian, #haskell-blah and #haskell. I last heard you speak just now.
17:41:18 <shapr> @seen edwardk
17:41:19 <lambdabot> I haven't seen edwardk.
17:56:14 <chessguy> @get-slap
17:56:15 <lambdabot> shapr!!
17:56:32 <chessguy> haskell's if/then/else construct can't actually be defined in haskell, right?
17:57:09 <Chad> not syntactically, but semantically it can
17:57:42 <Chad> ifte True x _ = x
17:57:42 <Chad> ifte _ _ y = y
17:57:48 <ricky_clarkson> > let iffy c t e=if c then t else e in iffy 3==5 "hoo" "haa"
17:57:50 <lambdabot>        add an instance declaration for
17:57:50 <lambdabot>       (Num ([Char] -> [Char] -> t -> t...
17:58:12 <ricky_clarkson> > let iffy c t e=if c then t else e in iffy (3==5) "hoo" "haa"
17:58:21 <lambdabot>  "haa"
18:00:53 <fberthold> I'm having some issues with extracting class based values from types that are defined using GADTs.  Jeeze that felt buzzword heavy.
18:00:57 <hpaste>  fberthold pasted "GADT's class extraction" at http://hpaste.org/5174
18:01:24 <fberthold> Could I con someone into taking a glance at it and telling me what I'm doing wrong?
18:04:58 <LoganCapaldo> I don't think it can prove that the attr inside Object is the same attr in the type sig of getAttr
18:05:18 <scook0> @hoogle sort
18:05:20 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
18:05:20 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
18:05:20 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
18:05:43 <oerjan> fberthold: getAttr's type implies that for any Object, it should be able to return _any_ attr that is an instance of OAttr
18:05:59 <dcoutts_> @seen TomMD
18:06:00 <lambdabot> TomMD is in #haskell, #xmonad and #ghc. I don't know when TomMD last spoke.
18:06:03 <TomMD> hi
18:06:15 <dcoutts_> TomMD: hi
18:06:19 <dcoutts_> TomMD: btw, we've decided it's probably easier to ban the dodgy version numbers than warn about them
18:06:42 <oerjan> fberthold: you may need some existential wrapping for OAttr's
18:06:48 <dcoutts_> TomMD: see comments on http://hackage.haskell.org/trac/hackage/ticket/194
18:06:50 <lambdabot> Title: #194 (add sanity checking to version numbers) - Hackage - Trac
18:06:51 <TomMD> Ok.  I've been out of town and haven't looked at it for a bit anyway - but I enjoyed learning the parser.
18:06:58 <TomMD> looking
18:07:08 <fberthold> oerjan: I'm not sure I understand.
18:07:32 <fberthold> oerjan: Can you point me to an article that might clear it up (if it isn't a couple of line response)?
18:07:51 <scook0> @pl \(x, y) -> (y, x)
18:07:52 <lambdabot> uncurry (flip (,))
18:07:54 <oerjan> er...
18:08:36 <oerjan> scook0: snd &&& fst, too
18:09:11 <oerjan> fberthold: don't know any article
18:09:14 <LoganCapaldo> fberthold: the object value (may have) has one value of some type that's an instance of attr, the type of getAttr says that for an Object you can get out a value for any type that's an instance of OAttr
18:09:16 <scook0> nice, but doesn't really buy me anything
18:09:22 <scook0> I'll stick with pointwise
18:09:31 <jfredett> &&& is the greatest thing ever. :)
18:09:45 <scook0> seconded!
18:10:05 <oerjan> but basically, the attr type is not permitted to escape from the Object into the type of getAttr
18:10:25 <oerjan> because it is dynamically determined by the actual Object value
18:11:09 <fberthold> oerjan: So, so long as I continue to keep it wrapped in an Object, it can remain ambiguous, but once it leaves it I have to be specific about which data type I'm talking about?
18:11:26 <jfredett> &&& and ap are awesome, :) palindrome detector in three functions: ((==) `ap` reverse)
18:11:37 <LoganCapaldo> it's more like as long as you keep it wrapped in object it is some _specific_ type that you can't know
18:11:38 <jfredett> I forget who came up with that, I think it was Cale
18:11:39 <oerjan> yep, unless you create another existential wrapper for OAttr's
18:11:53 <Saizan> fberthold: once you've wrapped it in object you can't get it out and fix it to a specific type, you only know that it belongs to the OAttr class
18:12:39 <oerjan> fberthold: or for the case of OAttr, you could return objName attr instead
18:12:39 <fberthold> Saizan: Does that mean that I can pass it through any OAttr class function?
18:12:48 <Saizan> fberthold: yes
18:12:49 <fberthold> oerjan: Can you give me an example.
18:12:58 <Philippa> I have a seriously WTFy type error
18:13:05 <dcoutts_> TomMD: the .cabal file parser still needs a lot of love, so it's not at all a waste of time to look at it
18:13:07 <oerjan> getAttr (CAttribute _ attr) = Just (objName attr)
18:13:24 <Philippa> an occurs check failing while attempting to generalise a type that matches the signature type it's looking for
18:13:25 <oerjan> that would be OK, since the type doesn't escape out, only a String
18:13:50 <TomMD> dcoutts_: I won't give up on hacking Cabal that easy!
18:13:52 <dcoutts_> TomMD: the current error messages are fairly terrible, the performance is poor and it falls over on too many things which is bad for forwards compatibility
18:14:05 <dcoutts_> TomMD: good to hear :-)
18:14:08 <fberthold> oerjan: Ok, I think I can work with that.
18:14:17 <oerjan> and as currently defined, OAttr is little more than an attached String value anyhow
18:15:08 <fberthold> oerjan: The main reason for it's existance is to act as a superclass for other classes so that I can define default behavior.
18:15:34 <dcoutts_> TomMD: in particular we often find that the parser falls over on something like the extensions field before it can parse the cabal-version: field which would tell us that this version of cabal might not be enough to work, which would allow a better error message
18:15:52 <fberthold> orejan: I'm working on a framework for writing text adventure games and I want someone to beable to define a "Window" without defining "NotWindow" for every object.
18:15:57 <Philippa> fixed it. I have a false expectation about polymorphism that I need to beat out of myself
18:16:09 <Saizan> fberthold: in general you could define data AnyOAttr where AnyOAttr :: OAttr attr => attr -> AnyOAttr, and have (CAttribute _ attr) = Just (AnyOAttr attr)
18:16:14 <Philippa> ("if I can build a value of the appropriate type by desconstructing and reconstructing, I can just use the original value")
18:16:50 <scook0> heh, I've fallen for that one
18:17:12 <dcoutts_> TomMD: as you'll have noticed, we have a two level parser, the overall fields structure as one phase and then little parsers for each field. So in principle we could go and look at some fields (like cabal-version) before trying to parse the rest of it.
18:17:45 <LoganCapaldo> Philippa: is that like the difference between f Nothing = Nothing and f x = x ?
18:17:48 <fberthold> Saizan: That might solve the problem of extracting the information sufficiently to work with what I'm doing, I'll have to play with it some to be sure.
18:18:03 <fberthold> oerjan++
18:18:20 <BMeph> jfredett: It was LoganCapaldo that brought it up <LoganCapaldo>	@type ap (==) reverse
18:18:32 <chessguy> @djinn a -> a
18:18:33 <lambdabot> f a = a
18:18:47 <chessguy> is id the only function of type a -> a?
18:18:58 <LoganCapaldo> BMeph: I've only copied from other people
18:19:15 <LoganCapaldo> @type undefined :: a -> a
18:19:16 <lambdabot> forall a. a -> a
18:19:24 <LoganCapaldo> almost
18:19:24 <scook0> chessguy: modulo undefined, and special stuff like (partially-applied) seq
18:19:26 <BMeph> Hmm, people keep saying that... ;)
18:19:37 <scook0> and unsafePerformIO, of course
18:19:40 <TomMD> dcoutts_: So are you thinking of a two pass solution verify config >> read config?
18:19:51 <kmcallister> @type seq ()
18:19:52 <lambdabot> forall t. t -> t
18:20:02 <oerjan> BMeph: but who was first? :D
18:20:21 <LoganCapaldo> probably pl <g>
18:20:28 <BMeph> oerjan: LOL! ;p
18:20:31 <LoganCapaldo> @pl \x -> x == reverse x
18:20:31 <TomMD> dcoutts_: It seems that the new functions I was looking at are still needed (functions providing a basic way to use the PWarn [String] field).
18:20:31 <lambdabot> ap (==) reverse
18:20:40 <dcoutts_> TomMD: right, we already have a two pass parser but we do not yet take advantage to extract crucial info after the first stage and before going on to possibly fail in the second
18:20:55 <oerjan> well a partially applied seq is either id or const undefined
18:21:12 <dcoutts_> TomMD: eg, try setting cabal-version: >= 2.0 and also adding in a library section, extensions: FooBar
18:21:27 <jfredett> thats bmeph
18:21:27 <fberthold> LoganCapaldo++
18:21:29 <jfredett> LoganCapaldo++
18:21:32 <fberthold> Saizan++
18:21:41 <dcoutts_> TomMD: that's like the situation we have with the cabal that comes with ghc-6.8.1 vs .2
18:21:45 <fberthold> Thanks for taking the time guys.
18:22:22 <dcoutts_> TomMD: ghc-6.8 supports a bunch of new extensions, which we added in time for cabal in 6.8.2
18:23:25 <dcoutts_> TomMD: but that means if you're using 6.8.2 and you use a package that someone made that uses the new extension, then it all falls over, even if the person added cabal-version: >= 1.2.3
18:23:36 <dcoutts_> TomMD: (that being the cabal version that comes with 6.8.2, 6.8.2 came with 1.2.1 iirc)
18:23:50 <dcoutts_> er 6.8.1 came with caba l1.2.1
18:24:21 <TomMD> dcoutts_: Got it.
18:24:56 <dcoutts_> TomMD: so the point is it gives a terrible error message rather than something friendly saying that this old version of cabal cannot build the package and you have to upgrade to at least x.y
18:25:17 <dcoutts_> and if we took advantage of the two level parser then we could do exactly that
18:25:58 <TomMD> dcoutts_: Yes, I see.  (looking at code now)
18:26:06 <ac> do you pronounce the 'l' in "Milner"?
18:26:12 <ac> or is it pronounced "miner"?
18:26:48 <LoganCapaldo> I do, but I have no authority in the matter
18:29:39 <BMeph> ac: It's "Milner," but his first name is pronounced "Rowan" ;p
18:30:04 <ac> BMeph: uh, that doesn't answer my question
18:30:24 <ac> er, I guess you must be saying you do pronounce the 'l'
18:30:38 <BMeph> ac: I know - I was just funning with you anyway. :)
18:31:00 <jfredett> in milner?
18:31:19 <ac> erhg, nothing fits in to the Binary class
18:32:10 <jfredett> i pronounce the i in milner the same way as I pronounce the i in winner or finland.
18:33:31 <ac> my my windows Vista is sick. Not only are the title bars semi-transparent, they use some sort of bluring convolution filter
18:34:58 <oerjan> it's just psychedelic subconscious messages.  nothing to worry about.
18:36:06 <ac> so I have a ByteString and in various portions there is a string that indicates what type to expect next
18:36:35 <vladimir_trs> How to write a function to chane all values in a list to values from a HashTable?
18:37:07 <ac> Instead of having a big if statement that compares the label and branches to "get" that type, is there a more elegant way?
18:37:46 <ac> like if label = "foo" then record { fooBlock = get :: FooBlock } else ...
18:38:11 <ac> obviously that's not the precise code, but you get the idea
18:39:03 <ac> basically I want a mapping between strings and types
18:40:23 <oerjan> vladimir_trs: you could use liftM fromJust . mapM (lookup t)
18:40:40 <oerjan> although usually we use Data.Map rather than HashTable
18:40:41 <_alf_> could someone define => for me
18:41:23 <chessguy> _alf_, "implies"
18:41:28 <oerjan> _alf_: it's a keyword that separates class contexts from the rest of a type
18:41:32 <ac> I guess you can't get better than case
18:42:36 <oerjan> vladimir_trs: in which case the function would simply be map (tb !)
18:43:04 <_alf_> thanks oerjan
18:43:26 <_alf_> chessguy - i meant in haskell
18:43:30 <_alf_> but thank you too
18:43:32 <chessguy> _alf_, so did i
18:43:59 <_alf_> => is a language construct that means implies?
18:44:21 <Philippa> in a very restricted sense, yes
18:44:36 <Philippa> the constraints on the LHS imply that the type on the RHS is valid
18:44:42 <chessguy> i read something like foo :: (Foo a) => a -> Int as "foo's type is, for any a, a being an instance of Foo implies a to Int"
18:45:02 <chessguy> it sounds awkward to write it out, but that's how i think of it
18:45:13 <dmwit> ac: You could use guards, they're pretty nice.
18:45:22 <Philippa> as in forall a.Pred a => ...
18:45:44 * LoganCapaldo thinks of it as foo is a function from a to Int where a is an instance of Foo
18:45:50 * LoganCapaldo is backwards
18:45:53 <dmwit> There's no really nice guard preamble, though, you have to do something ugly like "case () of _ | ..."
18:46:09 * chessguy shakes his head at odlapaCnagoL
18:46:29 * chessguy almost tried to tab-complete that
18:46:46 <Twey> Haha
18:46:52 <LoganCapaldo> I wouldn't min if the syntax looked like foo :: a -> Int | Foo a
18:47:44 <yoshi> How would I check to see if a list of characters contains a period?
18:47:45 <LoganCapaldo> it also serves as a reminder of how things like instance (Eq a) => Eq [a] work
18:47:57 <chessguy> :type isInfixOf
18:47:58 <oerjan> yoshi: '.' `elem` list
18:48:02 <_alf_> i see philippa
18:48:12 <chessguy> @type isInfixOf
18:48:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:48:18 <_alf_> thanks all
18:48:23 <chessguy> oh, that too
18:48:33 <Philippa> for now, "it's a keyword" is good enough. For the most part it's just vaguely mnemonic
18:49:20 <Philippa> dammit. I ran into something wonky in the typechecker (GHC.Prim.Any showing up where it shouldn't) and playing around to find how to build a minimal example led to losing whatever was causing it
18:49:27 <Philippa> no bug report there, then
18:49:41 <LoganCapaldo> heisen type bugs!
18:49:56 <LoganCapaldo> I look forward to heisen kind bugs
18:50:41 <Philippa> it's not a true heisenbug unless it happens without changing the source
18:50:49 <oerjan> LoganCapaldo: probably has to wait for polymorphic kinds
18:51:47 <LoganCapaldo> polymorphic inds you ay?
18:51:50 <LoganCapaldo> how do those work?
18:52:40 <LoganCapaldo> s/inds/kinds/ s/ay/say/
18:53:15 <Twey> Sticky keyboard?
18:53:15 <oerjan> well let's say you wanted a type constructor to flip the order of arguments of another one
18:53:31 <Philippa> with a kind lambda, presumably
18:53:34 <oerjan> newtype Flip t x y = Flip t y x
18:53:54 <Philippa> IOW, exactly the same as polymorphic types
18:54:09 <LoganCapaldo> Philippa: I knew someone was gonan say that
18:54:18 <BMeph> Schroedinger's Cat doesn't hold a candle to Schroedinger bugs?
18:54:20 <oerjan> now you might want to use it for different kinds of x y t
18:54:38 <LoganCapaldo> oerjan: ah
18:55:00 <oerjan> but haskell currently does not allow that
18:55:56 <oerjan> i shall leave kind constructor classes as an exercise for the student ;)
18:56:57 <Pseudonym> Is it just me or does most of the FP optimisation research from the 90s seem to have as its central goal optimising naive reverse into the accumulator version?
18:56:59 <newsham> > read "+2.35" :: Float -- whats a good API for this?
18:57:03 <lambdabot>  Exception: Prelude.read: no parse
19:03:36 <Saizan> newsham: "this" being?
19:05:09 <newsham> parsing "+2.35" as a float
19:07:14 <Saizan> i'd compose reads with a parser for the sign
19:13:05 <glguy> ?seen chessguy
19:13:05 <lambdabot> I saw chessguy leaving #haskell 6m 31s ago, and .
19:13:50 <Twey> and .?
19:15:50 <Korollary> It used to say something like ".. and I missed 10 hours since then."
19:19:59 <sw17ch> newsham: I'm surprised read can't do that... works fine for -
19:20:13 <sw17ch> Prelude> (read "+2.35") :: Float
19:20:13 <sw17ch> *** Exception: Prelude.read: no parse
19:20:13 <sw17ch> Prelude> (read "-2.35") :: Float
19:20:13 <sw17ch> -2.35
19:20:15 <Saizan> are higher-kinded type variables interesting without typeclasses?
19:21:48 <oerjan> > readDec "2.35" :: Float
19:21:50 <lambdabot>  Couldn't match expected type `Float'
19:22:06 <oerjan> > readDec "2.35" :: [(Float,String)]
19:22:08 <lambdabot>  [(2.0,".35")]
19:22:14 <oerjan> > readDec "-2.35" :: [(Float,String)]
19:22:16 <lambdabot>  []
19:22:21 <oerjan> er
19:22:35 <paczesiowa> do we have "value restriction" in haskell?
19:22:35 <oerjan> > readFloat "2.35" :: [(Float,String)]
19:22:38 <lambdabot>  [(2.35,"")]
19:22:48 <dmwit> paczesiowa: Meaning what?
19:22:50 <oerjan> paczesiowa: monomorphism restriction is slightly similar
19:22:59 <oerjan> but more liberal
19:23:14 <oerjan> > readFloat "-2.35" :: [(Float,String)]
19:23:15 <lambdabot>  []
19:24:37 <oerjan> paczesiowa: although the reason for it is completely different, since haskell has no side effects of mutability in pure code
19:24:43 <oerjan> *or
19:25:44 <paczesiowa> oerjan: so amount of freedom can be chosen in typechecking? I'm translating parsec's parser to ocaml ( I know, but I have to:/) and some things don't want to type because of that value restriction
19:25:55 <LoganCapaldo> could you sau the thing the MR is designed to rpevent is a sort of "side effect"?
19:26:25 <oerjan> paczesiowa: mostly you can remove it in haskell with explicit type annotation
19:26:39 <oerjan> and ghc has a flag to remove it completel
19:26:41 <oerjan> *y
19:27:21 <oerjan> LoganCapaldo: are you aware of the unsafePerformIO hack to do unsafe coercions?
19:28:19 <oerjan> it arises because unsafePerformIO allows you to do mutation in the same way as ML, and is exactly the sort of thing the value restriction prevents there
19:29:43 <LoganCapaldo> sure, but I was under the impression that the MR was designed to make bindings that "looked" like they should be evaluated once, were evaluated once
19:29:52 <oerjan> yeah
19:29:58 <oerjan> my impression too
19:30:15 <LoganCapaldo> So multiple evaluation is sort of a "side effect', if a pretty benign one
19:30:28 <LoganCapaldo> is I guess what I was saying
19:30:28 <glguy> :-/
19:30:38 <dmwit> Calling that a side effect is an interesting idea.  I want to argue with you, but I can't come up with a really good counter.
19:30:57 <glguy> it isn't a side effect in the typical way that side effect is used in this channel
19:31:03 <glguy> it "has the effect" of being slower
19:31:07 <LoganCapaldo> dmwit: I'm not sure I've convinced myself :)
19:31:17 <LoganCapaldo> which is why i keep using quotes
19:32:36 <kpreid> it's not a side effect, because if it was you'd have to say an optimizing compiler removes side effects :)
19:33:58 <BMeph> kpreid: You mean they don't? ;)
19:36:56 <LoganCapaldo> it's a side effect if your goal is to find the most ways to relate it to the value restriction <g>
19:38:21 <monochrom> It seems that "side effect" is a moving target.
19:38:47 <oerjan> as if it keeps mutating...
19:38:55 <dmwit> In Soviet Russia, moving targets are a side effect!
19:39:13 <monochrom> haha
19:39:23 <dmwit> ?src (=<<)
19:39:23 <lambdabot> f =<< x = x >>= f
19:39:36 <dmwit> That is beautifully palindromic.
19:39:57 <monochrom> Even more so if it were v =<< x = x >>= v
19:40:21 <dmwit> huh
19:40:28 <monochrom> Under a suitable font it would be geometrically palindromic, not just alphabetically.
19:40:42 <kpreid> this font!
19:40:48 <monochrom> You see the mirror image of f is not f.
19:41:12 <dmwit> Please, type the mirror image of f. ;-)
19:41:32 <BMeph> Heh-heh, p =<<q = b>>=d
19:42:02 <dmwit> Too bad that's not a valid definition...
19:42:10 <oerjan> a rotating palindrome!
19:42:20 <dmwit> It would be really fun to make an animated gif of that spinning endlessly...
19:42:25 <oerjan> could one make a rotating palindromic quine?
19:43:01 <dmwit> (+) =<< x = x >>= (+)
19:43:49 <kpreid> dmwit, สก and ส are near misses
19:44:18 <dmwit> Is that a sickle-and-hammer?
19:44:35 <kpreid> no, it's a GLOTTAL STOP WITH STROKE
19:44:47 <BMeph> (*)=<<o=o>>=(*)
19:45:11 <kpreid> ah, here we go: ษฟฬต
19:45:19 <kpreid> probably won't render right in anyone's irc client :)
19:45:29 <BMeph> Hmm, that looks like a Star Wars land-speeder.
19:45:30 <nelhage> Nah, lots of IRC clients grok unicode fine
19:45:33 <dmwit> Clearly, xchat is not doing it right.
19:45:35 <paczesiowa> if we create IORef [] in ghci than it's useless right, so we don't have that value restriction problem, right?
19:45:41 <kpreid> nelhage: not so much combining characters
19:45:59 <nelhage> (Mine doesn't, so I'm not sure.)
19:45:59 <kpreid> anyway, that was U+027F U+0335
19:46:17 <oerjan> paczesiowa: <- bindings are monomorphic anyway
19:47:06 <dmwit> BMeph: heh, yeah, it does, I could see that popping up on some ASCII art page or so
19:47:08 <paczesiowa> oerjan: and what is that type GHC.Prim.Any ?
19:47:25 <oerjan> paczesiowa: not sure
19:48:12 * BMeph frowns at the voice telling him "You don't need to see our identification"...
19:48:22 <LoganCapaldo> Anything after GHC. is invisible as far as I am concerned
19:48:30 <LoganCapaldo> pay no attention to the man behind the curtain
19:48:46 <monochrom> Some software will render U+027F U+0335 as two characters; some other will recognize the second as a "combining diacritical mark" and merge them into one.
19:48:54 <paczesiowa> LoganCapaldo: x <- newIORef [] && :t x
19:49:09 <monochrom> In fact even within the same software, one textbox could make them two, another textbox could make them one.
19:49:29 <hpaste>  (anonymous) annotated "(no title)" with "depth first search error" at http://hpaste.org/5175#a1
19:50:13 <oerjan> paczesiowa: oh? i suppose it uses it to default types to.
19:50:27 <oerjan> except i thought it used ()
19:51:28 <LoganCapaldo> paczesiowa: can't type x <- newIORef [] in hugs :)
19:52:06 <paczesiowa> why do you use hugs?
19:52:54 <LoganCapaldo> for the express purpose of demonstrating the difference between an implementation detail, and haskell the language, and by extension, why GHC. is invisible to me
19:54:01 <piojo> Hi. would anybody be willing to look at my (only 12 lines long) depth first search algorithm and try to tell me why it says "Occurs: cannot construct infinite type...."? The text is pasted at http://hpaste.org/5176 . Thanks in advence
19:55:37 <dmwit> piojo: What type does the map return in the last line?
19:55:55 <piojo> it should be [Maybe a]
19:56:02 <dmwit> piojo: Compare that to what type the function firstMatch expects in that position. ;-)
19:56:09 <piojo> oh, no...
19:56:38 <piojo> thanks ;). i didn't give it all the arguments it needs, i was confused
19:58:06 <dmwit> piojo: Also, notice that this algorithm does bad things with cycles.  (That isn't necessarily a mistake, just something to be careful of.)
19:59:23 <dmwit> piojo: Even if you supply all the arguments, you will probably still get an occurs check error.
19:59:55 <piojo> dmwit: i suspected that would happen (i think i had it right before)
20:00:32 <piojo> i don't really know what you mean with "does bad things with cycles". is there something i'm doing wrong?
20:00:34 <dmwit> You've got too many layers of Maybe (or not enough, depending on how you look at it =) in that last line.
20:01:01 <dmwit> piojo: Imagine if children 1 = [2] and children 2 = [1]. ;-)
20:01:04 <hpaste>  LoganCapaldo pasted "paczesiowa: what happens when you don't do something mean like ask for a type in the "middle" of wri" at http://hpaste.org/5177
20:01:37 <dmwit> :t mapMaybe
20:01:39 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
20:02:16 <dmwit> That should help with the type error, but not the cycles issue.
20:02:20 <piojo> dmwit: in this case, it's not a mistake--the algorithm just isn't finished
20:02:29 <dmwit> right, ok
20:02:30 <piojo> thanks for that, i'll look up and play with mapMaybe
20:02:53 <piojo> there are infinite cycles, but i haven't added the "depth" and "maxdepth" arguments
20:03:31 <paczesiowa> LoganCapaldo: I don't get that message. besides you were supposed to ask for type after binding to x not defining x
20:04:23 <LoganCapaldo> paczesiowa: right but you are doing something that's effectively "impossible" in batch mode
20:05:07 <LoganCapaldo> you've written the equivalent of newIORef >>= \x -> <nothing>
20:05:35 <LoganCapaldo> so of course it can't give you anything but an implementation specific response (or an error alternatively) for the type of x
20:05:59 <paczesiowa> I know that's stupid, I was just curious
20:07:59 <LoganCapaldo> i'm just sayng I'm willfully ignorant of ghc.prim.any :)
20:08:32 <LoganCapaldo> or petty much anything following GHC.
20:09:49 <Eiler> is haskell the craft of functional programming 2ed any good or is it to old?
20:13:12 <ac> can I make one class an instance of another?
20:14:46 <paczesiowa> yes, instance (Foo a) => Bar a where...
20:14:50 <ac> as in: instance (Foo a) => ...
20:14:53 <ac> yeah
20:16:27 <Cale> Eiler: It's probably usable, there may be some minor variations to figure out.
20:17:12 <ac> What exactly is a type class?
20:17:20 <Eiler> ok
20:17:51 <Cale> A typeclass is a predicate on types together with some additional functionality which is present when that predicate is true.
20:18:17 <ac> Cale: thanks for the concise definition. That's what I was looking for
20:18:56 <ac> are dependent types just a more powerful system for specifying a predicate?
20:19:47 <Cale> I suppose -- they give you the ability to say that the type of something depends on its value in a stronger sense than we usually mean in Haskell.
20:20:14 <ac> Interesting. I will figure those out later
20:20:15 <Cale> (In a sense which makes typechecking essentially equivalent to theorem proving.)
20:20:44 <ac> the Haskell type system is brutally simple once you understand it
20:20:53 <Eiler> Is there any estimate when the haskell prime will be done? And what kind of projects are haskell most suitable to do, (maybe scientific and math ones)?
20:20:57 <Cale> Typeclasses let you control polymorphism. Normally in parametric polymorphism, when you have a type variable t, it ranges over all types.
20:20:57 <ac> I mean what it can do, not the implementation of it
20:21:23 <Cale> Typeclasses let you restrict the types over which a type variable ranges.
20:21:39 <ac> right
20:22:04 <Cale> Eiler: I'm not sure when Haskell' will be done, but it's not all that exciting from a language user perspective, since it intends to standardise already-implemented features only.
20:22:16 <paczesiowa> haskell is most suitable to do interesting things
20:22:22 <Cale> (The implementations are generally way ahead of the standard)
20:22:53 <Eiler> aha
20:23:08 <Cale> Haskell's a general purpose language, but it's good for programs which really must not screw up (there are companies writing high-assurance code in Haskell)
20:23:10 <Eiler> in some languages it is the other way around
20:23:20 <sjanssen> Eiler: Haskell' seems a bit stalled
20:23:58 <Eiler> Cale: like stuff sent to mars? ;)
20:24:38 <Eiler> or are we talking bank software or something
20:24:40 <Cale> Eiler: :)
20:25:13 <byorgey> Eiler: both!
20:25:14 <Cale> Eiler: Well, bank software, yes. I suspect there have been some military applications, but I don't really know who the clients of these companies are.
20:25:42 <ac> Eiler: since I've gotten in to Haskell (which wasn't that long ago), I aspire to write everything in it
20:25:44 <Cale> It's got quite a following among quantitative analysis people.
20:25:57 * byorgey would like to see a probe to Uranus, programmed in Haskell =)
20:25:58 <ac> Perhaps my Haskell enthusiam will wear off in a while, but it hasn't yet
20:26:17 <Cale> (Since its semantics make it sort of like a spreadsheet on steroids.)
20:26:17 <ac> *enthusiasm
20:26:18 <byorgey> ac: unlikely
20:26:36 <ac> byorgey: yeah that's what I'm thinking. It's the only language I've learned that I don't have some personal issue with :-P
20:26:49 * BMeph wants to open an account at the Syrtis Valley ban
20:26:52 <Eiler> well, i prefer c++ but im not geeked into a corner.. i like to discover the possibilites of using a language like haskell for some purposes where it has its strengths
20:27:09 <BMeph> k
20:27:48 <ac> heh: "geeked in to a corner". I like that
20:28:07 <Cale> Eiler: I believe the C++ people have started to steal features almost directly from Haskell now.
20:28:33 <Cale> Specifically, "concepts" are based directly on typeclasses, at least from what I've heard.
20:28:35 <ac> Eiler: Haskell's type system can do a lot of things C++ templates can, and it's much, much prettier :)
20:28:54 <Cale> Ah, let's give some examples of that :)
20:29:06 <dons> like they say, C++ accidentally stumbled on type level programming, in Haskell, it was planned.
20:29:15 <Cale> Starting simple, the length function for lists has the type [a] -> Integer
20:29:21 <monochrom> See? Evolution vs Intelligent Design.
20:29:24 <dons> :)
20:29:35 <Cale> Which means that for any type a, it takes a list of values of type a, and produces an Integer
20:29:41 <kmcallister> dons, is that really true given that MPTC and fundeps aren't in h98?
20:30:06 <dons> kmcallister: it's true of the language in the last 10 years.
20:30:12 <Cale> Now, map, which is a function that takes a function, and a list, and applies the values to each element of the list, has the type:
20:30:17 <dons> in particular, type families are soley to make type level programming easy
20:30:17 <Cale> (a -> b) -> [a] -> [b]
20:30:20 <Eiler> well c++ is open minded to try new stuff and expand what can benefit it, dont see anything wrong in that. Same as i see haskell people trying to compare and say its equally good or close to equal in this and that.. subjects
20:31:10 <Cale> That is, for any types a and b, it takes a function from values of type a, to values of type b, and a list of values of type a, and produces a list of values of type b.
20:31:32 <Cale> This type is automatically inferred from the code for map, by the compiler.
20:31:45 <Cale> map f [] = []
20:31:51 <Cale> map f (x:xs) = f x : map f xs
20:32:34 <Cale> However, if you put the type signature in explicitly, the compiler will verify that the code really does have that type, so for example, if instead I wrote the second line as:
20:32:41 <Cale> map f (x:xs) = x : map f xs
20:33:00 <Cale> Forgetting to apply the function to the first element of the list, it would catch that as a compile time error.
20:33:36 <Cale> (This is assuming that the programmer has written   map :: (a -> b) -> [a] -> [b]  in the source file.)
20:34:19 <Cale> So it's rather nice, if you put in type signatures, you get extra safety, and if you leave them out, the compiler will infer them and still check that everything is consistent.
20:34:58 <Cale> We also have typeclasses which restrict what type variables range over, so, for example:
20:35:04 <Cale> sort :: (Ord a) => [a] -> [a]
20:35:27 <Cale> The "(Ord a) =>" means that the type a must have (<=), etc defined on it.
20:35:46 <Cale> That is, ordering comparisons.
20:36:11 <Cale> Eiler: any/all of that make sense? :)
20:38:41 <Cale> Eiler: still here, or did I scare you off? :)
20:40:29 <Eiler> Cale: oh i started reading the assumed you were talking with the dude asking about types. I kind of followed the data structures briefly but i'm not comfortable with the haskell syntax yet
20:41:06 <Cale> All right, it's not so important that you understand this in detail yet, I'm just trying to give some sense of what the Haskell type system is like.
20:42:18 <Eiler> the thing that confuses me when i start to look at the language is the abstraction, "write this and that happens"... that may be good but i got no idea what happens under the hood.. memory wise so to speak
20:42:27 <Cale> mm, okay
20:43:01 <Cale> I can give you some sense of how things happen without really getting too much into low level details
20:43:15 <Eiler> okay
20:43:20 <sjanssen> Eiler: this is one way that Haskell is quite different from C++ -- we don't expose or worry about that stuff very often :)
20:43:21 <Cale> Basically, the main difference between how Haskell is evaluated from most other languages is that things are evaluated outermost first
20:43:41 <Cale> In C or C++, when you write something like f(g(x))
20:44:08 <Cale> It passes x to g, computing a result, which it then passes to f
20:44:35 <Cale> In Haskell, g(x) is literally substituted into the body of f, and only evaluated if necessary.
20:44:45 <Cale> Let me give a small demonstration.
20:44:56 <Cale> Suppose we have the function:
20:44:56 <Eiler> im all ears :)
20:44:59 <Cale> double x = x + x
20:45:10 <Cale> It takes a parameter x, and adds it to itself
20:45:22 <Cale> Under strict evaluation (like C, C++, most languages)
20:45:25 <Cale> double (double 5)
20:45:29 <Cale> -> double (5 + 5)
20:45:33 <Cale> -> double 10
20:45:35 <Cale> -> 10 + 10
20:45:37 <Cale> -> 20
20:45:48 <Cale> The expression is reduced innermost-first.
20:46:07 <Cale> Under naive outermost-first evaluation, we instead have:
20:46:10 <Cale> double (double 5)
20:46:17 <Cale> -> (double 5) + (double 5)
20:46:22 <Cale> -> (5 + 5) + (double 5)
20:46:30 <Cale> -> 10 + (double 5)
20:46:35 <Cale> -> 10 + (5 + 5)
20:46:37 <Cale> -> 10 + 10
20:46:38 <Cale> -> 20
20:46:57 <Cale> Same result, but you can see a subtle problem: we evaluated double 5 twice!
20:47:26 <Eiler> yes
20:47:28 <Cale> So lazy evaluation makes a small modification to this. It shares the result of computing any parameter which is duplicated in the function body.
20:47:46 <Cale> (usually by having multiple pointers point to the same thing)
20:48:03 <Eiler> haskell got pointers? kickass!
20:48:05 <Cale> So under lazy evaluation, using 'let' to denote this sharing:
20:48:15 <Cale> Under the covers it does.
20:48:17 <cjb> Eiler: I think they're called "thunks", in this case.
20:48:28 <cjb> Where a thunk is a pointer to a piece of computation that may or may not be required.
20:48:32 <Cale> There's also explicit pointers used for FFI
20:48:38 <Cale> (you can call C code from Haskell)
20:48:38 <kmcallister> Eiler, there are lots of pointers behind the scenes, but you usually don't think of them as such
20:48:48 <cjb> But because we're all functional and stuff, (double 5) twice is the same thunk behind the scenes.
20:48:51 <Cale> Okay, so let's look at this:
20:48:55 <kmcallister> since there are no side effects or mutation, you don't have to care if two identical values are stored in the same place
20:48:55 <Cale> double (double 5)
20:49:00 <cjb> I think.  I am new to this.  Back to Cale.
20:49:01 <Cale> -> let x = double 5 in x + x
20:49:10 <Cale> -> let x = 5 + 5 in x + x
20:49:15 <Cale> -> let x = 10 in x + x
20:49:19 <Cale> -> 20
20:50:03 <Cale> (I'm using let here to express what would be expressed at the implementation level by multiple pointers in the expression pointing to the same thing.)
20:50:28 <Cale> Now we're back down to the same number of steps as the strict evaluation of this expression.
20:50:59 <Cale> This isn't always the case -- for some expressions, strict will take longer, and for some expressions, lazy will take longer.
20:51:05 <cjb> So, I don't usually care how many steps are involved, but I care about execution speed.  Is it easy to get an intuition about which of those would execute faster?
20:51:18 <cjb> Oh, I think you just answered that :)
20:51:49 <Cale> However, lazy evaluation has one big advantage: if there's *any* order of evaluation at all under which computation will terminate successfully, lazy evaluation will terminate successfully and produce the same result.
20:52:03 <paczesiowa> so is there a difference between f x = g x and f = g? is g evaluated multiple times in the latter case?
20:52:15 <Cale> However, this isn't true of strict evaluation -- sometimes strict evaluation will go into an infinite loop where a lazy program would finish.
20:52:35 <sjanssen> paczesiowa: there is a very tiny difference, due to the presence of seq
20:52:56 <Eiler> Cale: mm yep, that much ive understood
20:53:34 <paczesiowa> sjanssen: what difference?
20:53:35 <Cale> This fact lets you decompose problems in new ways that you can't in a strict language.
20:53:42 <sjanssen> paczesiowa: if you'd like some background, that transformation is called "eta conversion"
20:54:07 <sjanssen> paczesiowa: say g = undefined -- (\x -> g x) `seq` () yields ()
20:54:18 <sjanssen> paczesiowa: but g `seq` () yields undefined
20:54:22 <Eiler> is haskell based on lambda calculus?
20:54:38 <kmcallister> Eiler, yes
20:54:53 <Cale> For example, lazy functional programmers don't mind writing general code which produces extremely large or even infinite data structures, since they can later apply a function which prunes those structures depending on the application at hand.
20:54:56 <sjanssen> Eiler: yeah, lambda calculus is part of Haskell's heritage
20:55:03 <kmcallister> the syntax for a lambda expression is (\x -> e)
20:55:22 <kmcallister> although you don't need them nearly as much as in, say, lisp... for example you can write (\x -> 2 + x) as simply (2 +)
20:55:23 <dons> hence the lambda we use as a logo
20:55:36 <Cale> Whereas with strict programming, you generally have to write code such that it simply won't generate things you won't need from the outset, which mixes up what should be separate concerns.
20:55:52 <monochrom> > let { f x = g x; g = undefined } in f `seq` ()
20:55:54 <znutar> I thought that was a tip of the hat to "revenge of the nerds"
20:55:55 <lambdabot>  ()
20:56:31 <paczesiowa> > let { f x = g x; g = undefined } in g `seq` ()
20:56:32 <lambdabot>  Undefined
20:56:36 <Cale> znutar: Did lambda even make an appearance in that video?
20:56:42 <pastorn> @info ()
20:56:43 <lambdabot> ()
20:56:58 <Cale> pastorn: () is an empty tuple
20:57:06 <ddarius> That lazy evaluation is the order that always terminates if possible is also not true in the presence of side effect.
20:57:07 <znutar> Cale: their frat was lambda lambda lambda
20:57:21 <Cale> znutar: Probably the other way around then :)
20:57:32 <kmcallister> () is the only value of type (), and is sometimes pronounced "unit"
20:57:39 <kmcallister> and used in ways similar to C's void
20:57:41 <Cale> znutar: (That was probably a reference to the lambda calculus)
20:57:50 <Eiler> Cale: about the lazy thing.. i understand that it can reduce something it has allready evaluated, like "5+5"=10, so if we get "5+5" again it just prints/points to the same answer, but how does it decide if a part of an expression is redundant, that is the answer aint dependent to evaluate a part?
20:57:58 <monochrom> Or eigenvalues.
20:58:21 <Cale> Eiler: it specifically only shares expressions which came from duplicating the parameter to a function in its body
20:58:25 <Cale> That is, we had:
20:58:28 <Cale> double x = x + x
20:58:55 <Cale> When x gets evaluated, the two copies of it on the RHS of that equation share the result.
20:59:13 <Eiler> ok
20:59:37 <Cale> Otherwise, it generally won't common things up on you. It also doesn't automatically memoise function calls.
20:59:44 <Cale> (apart from this sharing)
21:00:02 <Eiler> but say we got: answer = 4+(5-2.5*2) would it even evaluate the parenthesis?
21:00:23 <EvilTerran> it'd have to, to know that the result is zero
21:00:24 <glguy> I watched some talk given by a Perl guy to Perl people where he told them that Haskell automatically memoizes
21:00:27 <Cale> Yes, it would, if answer was being evaluated.
21:00:32 <glguy> "Kicked in the Monads"
21:00:36 <EvilTerran> however, that might get inlined and happen at compile time
21:00:48 <znutar> I still think making an opcode in hardware for pure function evaluation would be spiffy, and memoize in hardware
21:00:51 <Cale> glguy: It seems to be a common misconception.
21:01:01 <glguy> I was going *no no no no no*
21:01:02 <Eiler> thats what i meant, it will still have to evaluate some stuff that wont make a difference to the answer
21:01:07 <EvilTerran> Eiler, in the case, however, of 0 * (...), it's possible the bracket wouldn't be evaluated
21:01:10 <glguy> ugh, now these people will come to the ML and channel and ask!
21:01:14 <glguy> and write about it on reddit
21:01:15 <Cale> The problem with automatically memoising everything is that memory is still too expensive to do that.
21:01:19 <EvilTerran> because it can tell the result without even touching the bracket
21:01:29 <EvilTerran> (depending on which number representation you're using)
21:01:50 <Cale> Eiler: right. You can still waste time :)
21:02:02 <sjanssen> glguy: were you watching it in person?
21:02:24 <glguy> nope
21:02:25 <Cale> Eiler: The whole trick to lazy evaluation is exactly what I've told you: reduce the outermost expression that you can first.
21:02:27 <glguy> I'd have objected
21:02:31 <glguy> google video
21:02:37 <Cale> (together with that sharing optimisation)
21:02:43 <sjanssen> glguy: I do agree, by the way -- this is a massively popular misconception
21:02:55 <Eiler> Cale: ah i see, thats how we can eliminate what needs to be evaluated and whats not
21:03:02 <Cale> Eiler: right
21:03:16 <EvilTerran> @src const
21:03:17 <lambdabot> const x _ = x
21:03:22 <Cale> Eiler: because if it's not needed, it will simply sit there as an unevaluated expression until it's garbage collected.
21:03:36 <EvilTerran> in the evaluation of const x y, y doesn't need to be evaluated at all to know the result...
21:03:38 <Eiler> mm, that is pretty smart
21:03:39 <EvilTerran> ... so it isn't :D
21:04:13 <znutar> Is there anything that prevents a haskell implementation from memoizing everything and anything it feels like?
21:04:21 <kmcallister> Eiler, this also means that you can define things like if, short-circuting && and ||, and cond as ordinary functions
21:04:30 <kmcallister> @src (&&)
21:04:31 <lambdabot> True  && x = x
21:04:31 <EvilTerran> znutar, apart from exponential memory use? no
21:04:31 <lambdabot> False && _ = False
21:04:32 <sjanssen> znutar: nope, the standard is quite flexible that way
21:04:51 <sjanssen> EvilTerran: why exponential?
21:04:54 <cjb> znutar: there are hints you can give to the compiler for memoization, that's probably good enough.
21:05:08 <EvilTerran> sjanssen, ok, i'm probably being a bit slack with terminology
21:05:12 <EvilTerran> "massive and excessive"
21:05:20 <znutar> Yeah, I'm just wondering how the misconception that memoization's happening all over came around
21:05:25 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:05:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:05:36 <Eiler> Cale: will that result in a small overhead(lazy being slower than strict) on a general bases, but at the benefit that when it can eleminate parts of an expression it can gets faster? or will it be equally fast to a strict evaluation on a "general" basis
21:05:55 <znutar> Seems like it'd just be someone saying "and the compiler can do X everywhere" getting promoted to "and haskell does X everywhere"
21:06:01 <Cale> Eiler: well, initially there's a hit, but compilers are getting better rapidly
21:06:12 <kmcallister> znutar, i think it's that we stress that functions are pure
21:06:17 <Eiler> hit= slower
21:06:20 <Eiler> ?
21:06:22 <Cale> yes
21:06:24 <Eiler> okay
21:06:26 <Cale> Eiler: There's generally an extra level of indirection added to the implementation of values.
21:06:42 <sjanssen> znutar: probably confusion between memoizing top-level CAFs (which most compilers do) and functions
21:06:47 <Cale> Roughly, values become pointers to either code or raw data.
21:06:56 <Eiler> Cale: yeah it was something like that i was thinking of
21:07:09 <znutar> that'd add to the confusion a good deal, I bet
21:08:01 <ddarius> If Haskell implementations memoized everything, they wouldn't need garbage collectors.
21:08:11 <sjanssen> that is a plus
21:08:54 <sjanssen> if I wrote such an implementation, I'd call it "Elephant Haskell", cuz' elephants never forget :)
21:09:32 <ddarius> @google elephant programming language
21:09:33 <sjanssen> that and it would use approximately one elephants weight in sticks of RAM for typical programs
21:09:34 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:09:55 <znutar> how about specualtively executing functions in advance, just in case they get called with the args in question
21:09:57 <Cale> Eiler: I suppose the next major difference is that since things are evaluated in this slightly unusual order, we don't handle I/O and other side effects during evaluation of functions -- functions are only evaluated in order to produce their result, and for the same parameters, the result they give is always the same.
21:10:06 <ddarius> sjanssen: I can probably find programs that do that now if I use the proper sticks of RAM.
21:10:39 <Eiler> "multiplication is often denoted using juxtaposition or space." what is juxtaposition?
21:10:40 <Cale> Eiler: Instead, we build values that describe things to be done (sort of as if we were manipulating C source code with a nice high-level API)
21:10:54 <paczesiowa> MR is better than value restriction because we can polymorphically type reverse [], am I right?
21:10:56 <Cale> Eiler: juxtaposition is putting things next to one another
21:11:03 <Eiler> oh ok
21:11:17 <znutar> On a more serious note: is there anyone working nowadays on compiling haskell to run on GPUs for nicely parallel stuff?
21:11:21 <dons> yeah
21:11:25 <Cale> Eiler: eventually the "main" of our program is just a value which describes a list of things to be done.
21:11:29 <dons> www.cse.unsw.edu.au/~pls znutar
21:11:39 <dons> seanl's doing a phd on it. ghc spits out cuda code for array ops
21:12:01 <sjanssen> paczesiowa: I'd say the MR and value restriction are very different
21:12:07 <Cale> Eiler: A nice advantage of this representation is that we can write our own control structures. If there wasn't already a for-each loop in the libraries, we could write one :)
21:12:10 <geezusfreeek> ghc is getting very close to ocaml in terms of performance nowadays
21:12:17 <sjanssen> paczesiowa: the value restriction is required for soundness, MR is just a performance hack
21:12:20 <geezusfreeek> at least on the shootout benchmarks
21:12:30 <Eiler> Cale: i understand what you say, but i dont really follow, to me it compiles to binary code like anything else and gets executed from start to end ;)
21:12:38 <znutar> dons: cool, thanks.
21:12:58 <cjb> geezusfreeek: isn't it above ocaml on the shootout now?
21:13:15 <Cale> Eiler: well, that's true -- there are two levels of thinking about things though: "how is this implemented in GHC?", and "how do I best think of this at a high level?"
21:13:27 <Cale> And usually those two questions have quite different answers :)
21:13:27 <geezusfreeek> Eiler: what actually happens is the thunks are just machine code which, when evaluated, replace themselves in memory with code that simply returns their values on all future invocations
21:13:30 <Eiler> Cale: i assume its the functional aspect we are looking at or something
21:14:00 <geezusfreeek> cjb: i don't think so... ocaml seems to still have a slight edge in just over half of the benchmarks
21:14:05 <Eiler> ok :)
21:14:09 <Cale> Eiler: well, not just the functional aspect, but the way in which we segregate side effects from everything else and represent them explicitly as values.
21:14:21 <cjb> geezusfreeek: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all has GHC ahead.
21:14:22 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
21:14:23 <geezusfreeek> ah, but haskell does rank above it overall, i see
21:14:29 <Cale> geezusfreeek: It's catching up quickly :)
21:14:39 <kmcallister> Eiler, in Haskell getChar is not a function
21:14:43 <sjanssen> geezusfreeek: but then Haskell turns around and crushes OCaml in benchmarks like thread-ring :)
21:14:44 <Cale> geezusfreeek: GHC finally has some smart people working on the code generator :)
21:14:44 <geezusfreeek> i was looking at the ghc vs. ocaml page specifically, which seems to favor ocaml in the chart
21:14:47 <kmcallister> in C or ML it would be a function of zero arguments
21:14:52 <cjb> oh, ocaml is ahead on AMD processors, not Intel
21:15:05 <kmcallister> but in Haskell it's simply a value of type IO Char, meaning "an input/output action which produces a character"
21:15:05 <cjb> that's quite odd.
21:15:10 <geezusfreeek> i'm looking at intel and it's winning
21:15:12 <geezusfreeek> overall anyway
21:15:20 <Cale> Eiler: Yeah, that's a good example:  getChar is just a value which represents the action of getting a character.
21:15:21 <kmcallister> (rather, in C it's a function of zero arguments and in ML it's a function of one argument whose value is trivial)
21:15:23 <cjb> the url I gave is Intel.
21:15:31 <sjanssen> cjb: the AMD machine is probably still on GHC 6.6
21:15:34 <dons> the intel machine is way behind -- half the haskell programs aren't updated, geezusfreeek
21:15:38 <Eiler> mm not bad at all, still quite abit up to c++ though, but that might not be where its intended to compete
21:15:46 <dons> sorry, other way around
21:15:46 <cjb> ah, ok
21:15:53 <dons> gp4/gentoo is the up to date one.
21:15:57 <geezusfreeek> dons: still winning... oh, yeah, okay, nevermind
21:16:08 <ddarius> Eiler: Give it two years.
21:16:10 <kmcallister> likewise, writting something like putStr "foo" doesn't actually put any strs anywhere, it just produces a value of type IO (), meaning "i/o action producing no useful value"
21:16:34 <geezusfreeek> Eiler: i very much expect ghc to surpass everything else in the great shootout :)
21:16:43 <geezusfreeek> eventually, i mean
21:16:58 <kmcallister> to make the str output happen, you have to combine this with any other IO you want to do (which can be done with syntax very close to standard imperative programming), and call the overall IO action that does everything "main"
21:17:20 <sjanssen> dons: we should convince an OCaml hacker to submit a solution for chameneos-redux.  Judging from thread-ring, it should make OCaml drop quite a bit :)
21:17:33 <Cale> ahaha
21:17:37 <geezusfreeek> maybe that's why there is no ocaml implementation :)
21:17:47 <ddarius> Is there a ruby implementation?
21:17:55 <sclv> Eiler: since haskell naturally tends to introduce another level of introduction with thunks, even though loads of these can be optimized away by smart compilers, the general notion at the moment is that a reasonable haskell solution should be able to come within 2ish times the speed of a careful c or c++ one.
21:17:57 <Cale> sjanssen: Or just submit one yourself :)
21:18:00 <geezusfreeek> nope
21:18:35 <geezusfreeek> sclv: 2 times the speed or 2 times the time?
21:18:44 <Eiler> geezusfreeek: i doubt that, as cale said, haskell might ass an extra level for evaluations to benefit for elimating parts of expressions. the shootoutproblems are small and when you specialice on them that extra level probably wont help but the other way arround. The more you abstract stuff, the harder it gets to optimize also
21:18:51 <piojo> kmcallister: is it that basically, every function that prints something must be of type IO a, and every function that calls such a function must type IO b (where b could == a)?
21:19:04 <Cale> Eiler: it also gets easier to optimise in another way
21:19:17 <Eiler> Cale: not on small/specific problems
21:19:19 <sclv> well, assuming we're not using a multiprocessor, they're sort of the same, no? if we are, haskell should pretty much smoke c.
21:19:22 <kmcallister> piojo, more generally the types will be something like a -> b -> ... -> IO z
21:19:25 <Cale> Even on pretty small problems
21:19:30 <geezusfreeek> Eiler: the shootout problems are also rigged against haskell, and yet ghc is still doing pretty good
21:19:41 <kmcallister> but this is the interaction of two orthogonal features, namely ordinary pure functions and IO actions which aren't functions
21:19:53 <kmcallister> in that you can think of an IO action which takes arguments as a pure function from the arguments to the IO action
21:20:06 <kmcallister> haskell is the best imperative language because imperative sequences are first-class ;0
21:20:19 <Cale> Eiler: For instance, the Data.ByteString library written by dons and others uses algebraic rules about the operations on bytestrings to rewrite your program into a more efficient form. If the operations were lower-level, it wouldn't be as successful as it is.
21:20:26 <sclv> if the shootout counted loc instead of gzipped code size, the shootout figures would also look much better for haskell in that dept.
21:20:41 <piojo> kmcallister: thanks
21:21:07 <Eiler> geezusfreeek: you get me wrong, i didnt say it does bad. but i see no reason why it would be able to solve these problems faster than low level languages. If someone would bother... even though its kind of platform specific assembly would probably kick ass out of many of those problems also
21:21:14 <Cale> Eiler: Currently, this results in some simple Haskell programs (like adding up numbers in a file) where in a C program, you'd have to do block-buffered IO to compete with the naive-looking Haskell code.
21:21:18 <sjanssen> sclv: of course Haskell has a bias towards long lines
21:21:56 <sjanssen> sclv: I think the only fair comparison is token count, but this takes too much work
21:22:04 <sclv> sjanssen: but they're such readable long lines compared to the competition!
21:22:11 <Cale> Eiler: Let me give another example -- suppose you have a high level language which knows about matrices. An inlining might produce matrix multiplications of the form AA^(-1)
21:22:25 <geezusfreeek> Eiler: see http://haskell.org/pipermail/haskell/2006-June/018127.html
21:22:33 <Cale> In a high level language which knows things about matrices, it can optimise that away to the identity matrix.
21:22:34 <Eiler> Cale: yeah that one i know of
21:22:54 <Cale> Whereas in a low level language, that multiplication and inverse is a bunch of loops.
21:23:08 <Cale> It's just impossible to see the optimisation then.
21:23:13 <geezusfreeek> i think gzip is fair because instead of measuring density it measures noise
21:23:52 <geezusfreeek> and noise is what can more often hinder readability
21:24:27 <sclv> in that case, whitespace is the clearest programming language there is!
21:24:29 <Cale> geezusfreeek: I really dislike having to type lots of repetitive nonsense though, and gzip tends to compress that out.
21:24:55 <sclv> noise^H^H^H^H^H information.
21:25:01 <geezusfreeek> Cale: true, but that kind of boilerplate still isn't the sort of noise that hinders readability most of the time
21:25:12 <geezusfreeek> most programming is not typing anyway
21:25:27 <sclv> what hinders readability most is lack of referential transparency.
21:25:40 <geezusfreeek> sclv: i agree, but we don't have a metric for that :)
21:26:11 <geezusfreeek> besides Haskell: 1, Other: 0
21:26:11 <sclv> well, we do, but nobody else will agree.
21:26:12 <Cale> Well, sure, but one of the nice experiences I had while working on Haskell code is that I could get up from my chair and still be programming in a real sense, because the code would fit in the small amount of visual working memory I have. :)
21:26:54 <sclv> Cale: completely. i've written functions in my head while riding the train.
21:27:01 <siti> lol
21:27:03 <geezusfreeek> Cale: so true... i actually solved a programming problem while dreaming once IN CODE... then i just woke up and typed it up
21:27:09 <Eiler> geezusfreeek: i didnt see anything in that mail that says haskell is going to be faster than c
21:27:19 <Eiler> at the shootouts
21:27:26 <geezusfreeek> Eiler: that was supposed to show that the shootout is rigged against ghc
21:28:11 <sclv> ghc 12 will solve your problems in the first compiler pass using only the type system.
21:28:14 <Cale> Eiler: They've had to change the problems quite a few times because GHC was too smart :)
21:28:35 <Cale> (and, admittedly, their problem was too dumb)
21:28:35 <geezusfreeek> i don't think it's unfair to rig it that way, they have just had to
21:28:37 <Eiler> and shootout is rigged against g++, g++ probably aint even the best compiler at producing fast code, most big companies uses cl.exe for example
21:28:57 <geezusfreeek> in much larger problems, the performace of ghc vs C is probably even better because of GHC's smart optimizations
21:29:12 <Eiler> but that is win specific so
21:29:13 <Cale> What we really need is a shootout which compares languages on actual tasks, not specific algorithms.
21:29:15 <allbery_b> you mean the oen where they forgot to specify that it output a result so ghc optimized the calculation away?
21:29:29 <Cale> allbery_b: for instance :)
21:29:35 <geezusfreeek> Cale: and with the criteria that the solution be idiomatic
21:29:35 <allbery_b> (rather, lazily didn't bother to compute it)
21:29:54 <siti> I think ghc will really start beating c when the shootout has quad core machines or better ;)
21:30:03 <Cale> Oh, that's true as well :)
21:30:15 <siti> ghc gets really nice performance on multicore machines if you set a min heap
21:30:21 <siti> maybe like 8MB or something
21:30:26 <siti> that way it's not always GCing
21:30:32 <geezusfreeek> siti: the rules will just have to be changed to restrict programs to one processor
21:30:34 <Cale> It will be fun watching imperative programmers try to write code for 128 core machines :)
21:30:46 <siti> yep
21:30:50 <Eiler> i doubt that, c(c++) dont have threads... yet, it will probably get it in c++0x but thats platform specific now
21:31:04 <geezusfreeek> Eiler: they have libraries for that though
21:31:07 <geezusfreeek> just not standard
21:31:37 <sorear> Cale: they'll do it the same way they do it now, by implementing half of haskell in a slow, bug ridden, and informally specified way
21:31:45 <Cale> sorear: :)
21:31:52 <geezusfreeek> sorear: you stole that
21:31:53 <Eiler> yep, not standard.. yet
21:31:54 <geezusfreeek> :P
21:31:56 <Cale> Eiler: A nice thing about the way in which Haskell separates side effects is that we can simply annotate code a bit to say how it should be parallelised, and this actually works in a lot of cases. :)
21:32:11 <siti> yep
21:32:15 <Cale> There's a primitive called par
21:32:25 <siti> and even if you have to use forkIO it's so much easier than most languages
21:32:27 <geezusfreeek> it's even better than that if you use Strategies
21:32:27 <ddarius> Eiler: Simply adding threads to standard C++ won't make C++ rock hard-core on multicore machines.
21:32:33 <siti> because you don't have as many races
21:32:34 <Eiler> Cale: mm yes that is nice, using threads can be really tricky
21:32:44 <Cale> Evaluating  par x y  will cause x to be put in a queue of things to possibly do on other processors, and result in y.
21:32:53 <geezusfreeek> par makes me happy, and i only have two cores
21:33:10 <Eiler> ddarius: noone said that, wont render it useless either
21:33:33 <Cale> If x never gets evaluated on another processor in time, that's okay, it will just get evaluated sequentially.
21:33:35 <monochrom> When you have four cores, par (par x y) (par a b) makes you happy. :)
21:33:47 <Cale> monochrom: hehe
21:34:06 <geezusfreeek> it's still fundamentally harder to do with C/++ because there are no guarantees that memory locations aren't modified all over the place
21:34:07 <monochrom> @pl \x y a b -> par (par x y) (par a b)
21:34:07 <lambdabot> flip flip par . (((.) . (.) . par) .) . par
21:34:18 <geezusfreeek> haskell just makes it easy by not allowing it at all!
21:34:26 <Cale> Eiler: You can use par to build more sophisticated tools for parallelising things, like "evaluate all the elements of this list on all available processors"
21:34:29 <siti> well you can do low level haskell
21:34:33 <siti> but it's not pretty :p
21:34:41 <Eiler> Cale: par?
21:34:43 <siti> it's like well type checked verbose c code
21:34:51 <Cale> Eiler: yeah, I described it just above
21:35:06 <Eiler> ah ok
21:35:29 <geezusfreeek> haskell needs its own MapReduce
21:35:56 <Cale> Yeah, we still don't have much of an answer for distributed computation.
21:36:12 <siti> it's very easy to do sockets in haskell
21:36:14 <Cale> But the newer nested-data-parallelism stuff looks like it might be good for that.
21:36:19 <siti> it would be nice to have a generic framework
21:36:24 <geezusfreeek> or somebody should make par and seq equivalents for distributed computation :D
21:36:58 <geezusfreeek> i can't wait for some stability in NDP
21:37:11 <geezusfreeek> but it's still not distributed, is it?
21:37:17 <Cale> Eiler: There's something the GHC guys are working on at the moment called nested data parallelism, which essentially introduces a new array type, called the parallel array. Computations on such arrays get automatically parallelised and load balanced across processors.
21:37:17 <ddarius> It seems widely accepted that you'd want significantly more control in a distributed setting.
21:37:21 <geezusfreeek> i was never under any such impression
21:37:48 <Cale> (In an extremely clever way)
21:38:06 <Eiler> neat
21:38:40 <geezusfreeek> and let's not forget STM!
21:39:06 <geezusfreeek> elegant transactions
21:39:12 <Eiler> Cale: is it hard to write a parser(math operators and math functions)?
21:39:40 <ddarius> Cale can probably write one in 30 minutes.
21:39:48 <sclv> Eiler: parsers and compilers happen to one of haskell's major strengths.
21:39:53 <geezusfreeek> ddarius: probably much less time than that
21:40:15 <sclv> google up "write a scheme compiler in 48 hours" i believe its called for a great tutorial.
21:40:51 <Eiler> 48? well i got school in 5h so this got to be fast ;)
21:40:53 <ddarius> geezusfreeek: Depends on the extent.
21:40:58 <kmcallister> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
21:40:59 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
21:41:01 <geezusfreeek> a simple one
21:41:01 <kmcallister> it's not a compiler
21:41:07 <geezusfreeek> interpreter
21:41:08 <paczesiowa> Eiler: check parsec libarary documentation, there is math calculator code
21:41:41 <Cale> Eiler: I recommend the parsec documentation :)
21:41:51 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
21:42:00 <Cale> It's written in a fairly tutorial style.
21:42:26 <Eiler> okay
21:42:37 <Cale> Basically Parsec is a library which lets you build parsers directly as values in Haskell.
21:42:48 <geezusfreeek> parsec is a little bit monad-heavy for a beginner, in my opinion
21:43:08 <Cale> Well, perhaps, but skimming it should give some idea :)
21:43:19 <Cale> (and they're reasonably efficient and have nice error messages automatically)
21:43:53 <sclv> well it doesn't give a strong sense of haskell style, but working inside the parsec monad is almost clearer than working in the io monad i think.
21:44:10 <Eiler> how come haskell has choosen to denote functions as i.e. "f x y" instead of "f(x, y)"?
21:44:16 <shachaf> geezusfreeek: Monad-heavy?
21:44:20 <kmcallister> Eiler, it's prettier :)
21:44:24 <shachaf> Eiler: Why not?
21:44:25 <sorear> Eiler: Regularity.
21:44:25 <ddarius> Eiler: So you can say f 3
21:44:26 <Cale> Eiler: because all functions in Haskell really have only one parameter
21:44:27 <paczesiowa> geezusfreeek: I learned parsec before I learned haskell. I thought that return was haskell's keyword
21:44:33 <shachaf> Eiler: Function application is a pretty basic thing.
21:44:36 <kmcallister> and it's conventional in the FP community
21:44:44 <kmcallister> and it allows (x,y) for tuples
21:44:45 <geezusfreeek> huh, wow, then maybe parsec wouldn't be a bad way to learn
21:44:46 <Cale> Eiler: A function of two parameters is a function which takes the first one, and produces another function.
21:44:48 <shachaf> Eiler: It's a functional language, after all. :-)
21:45:01 <Eiler> Cale: im thinking since it seems so much based on math... that it doesnt adopt common math notation in that way
21:45:06 <sclv> ?ty map
21:45:07 <sorear> Eiler: Haskell eschews multi-parameter functions, greatly simplifying the language
21:45:10 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:45:15 <paczesiowa> Eiler: f x y = (f x) y
21:45:19 <sclv> ?ty (map (+1))
21:45:20 <lambdabot> forall a. (Num a) => [a] -> [a]
21:45:26 <sorear> Eiler: and if all functions take one parameter, why bother with commas?
21:45:33 <sclv> ?ty (map (+1) [1,2,3])
21:45:34 <lambdabot> forall a. (Num a) => [a]
21:45:36 <Cale> Eiler: Yeah, this turns out a little nicer than mathematics' notation. (and I'm a mathematics person :)
21:45:45 <sclv> ?ty id
21:45:45 <lambdabot> forall a. a -> a
21:45:51 <sclv> ?ty id id id id id id
21:45:52 <lambdabot> forall a. a -> a
21:45:54 <Tac-Tics> Math notation has always been a little too whimsical for my stomach
21:45:59 <Tac-Tics> Haskell notation is very nice ^^
21:46:01 <paczesiowa> f x y = (f x) y = f x (y) = (f x) (y)
21:46:04 <sclv> Eiler: don't know if that helps at all...
21:46:10 <Eiler> paczesiowa: thats not what Graham Hutton writes in his book at least
21:46:11 <kmcallister> Eiler, math notation is very ad-hoc and inconsistent, despite the best efforts of many people
21:46:11 <Cale> Eiler: Mathematicians would probably start using this notation (and have to some small extent) if there weren't so much history there.
21:46:21 <Cale> kmcallister: I don't know about that.
21:46:30 <kmcallister> yeah, papers in type theory often use Haskell notation
21:46:38 <geezusfreeek> Eiler: the two most important ways to use functions in haskell, in my opinion, is application and composition, therefore they have the lightest visual representations (" " and ".")
21:46:56 <kmcallister> well, it's better than a similar system constructed by non-mathematicians would be
21:46:57 <sorear> Don't forget, haskell was designed.  And being designed, a lot of things got made common.
21:46:59 <Cale> One place it's really common is applying linear operators to vectors. You'll often see Tx rather than T(x)
21:47:26 <Tac-Tics> sorear: designed as opposed to what?
21:47:26 <kmcallister> Cale, there's a math prof here who writes all maps on the right for some reason
21:47:36 <Eiler> well yes but generally T(x) is way more used
21:47:39 * sorear always thought that was an issue of multiplication
21:47:39 <Cale> kmcallister: yes, actually that may be nicer than Haskell's way :)
21:47:40 <paczesiowa> Eiler: what do you mean?
21:47:43 <Tac-Tics> (as opposed to how PHP or CL came to be?
21:47:43 <sorear> Tac-Tics: Evolving.
21:47:51 <Cale> kmcallister: the reason for that is then the types line up really nicely.
21:48:14 <Tac-Tics> Haskell evolves just like any other language, though
21:48:20 <Tac-Tics> It's just got a much shorter history
21:48:21 <Eiler> paczesiowa: he writes: math f(x,y) is Haskell f x y
21:48:26 <Tac-Tics> and has learned from other, lesser languages
21:48:33 <sorear> Haskell is a design by committee, and if you look hard enough this is obvious in every detail.
21:48:54 <kmcallister> it's a design by committee consisting of people who'd used languages like what Haskell became on a regular basis
21:48:54 <geezusfreeek> Eiler: would you prefer foldr(+)(0)([1,2,3,4]) to foldr (+) 0 [1,2,3,4]?
21:49:07 <kmcallister> thus a lot of annoyances from e.g. ML got fixed
21:49:10 <Cale> kmcallister: Specifically, if f: A -> B, and g: B -> C are functions, and x is in A, then (x f) g will be defined.
21:49:26 <geezusfreeek> Eiler: because foldr((+), 0, [1,2,3,4]) wouldn't fit the semantics of Haskell
21:49:42 <paczesiowa> Eiler: that's right, I don't think I said smth opposite
21:49:58 <Eiler> paczesiowa: ok
21:50:03 <Cale> kmcallister: and thus (f . g) lines up in the right way :)
21:50:12 <kmcallister> yeah
21:50:18 <ddarius> Seems easier to flip (.)
21:50:19 <paczesiowa> > let f x y = x+y in (f x y, (f x) y, f x (y), (f x) (y))
21:50:22 <lambdabot>   Not in scope: `y'
21:50:39 * ddarius usually uses diagrammatic order composition when doing CT.
21:50:42 <paczesiowa> > let f x y = x+y in (f 1 2, (f 1) 2, f 1 (2), (f 1) (2))
21:50:46 <lambdabot>  (3,3,3,3)
21:51:13 <monochrom> I'm tempted to write "f ; g" instead of "g . f" too.
21:51:25 <ddarius> monochrom: That's what I do.
21:51:35 <Cale> I don't really understand the desire to use semicolon for it :)
21:51:45 <Tac-Tics> @let (..) = flip (.)
21:51:45 <Cale> (but I've seen that)
21:51:46 <lambdabot>  Parse error
21:51:52 <paczesiowa> f;g it's easier to type than g.f
21:52:03 <ddarius> Not for me.
21:52:11 <kmcallister> g.f is easier on dvorak ;0
21:52:13 <kmcallister> ;)*
21:52:25 <monochrom> I understand every desire.
21:52:26 <Cale> paczesiowa: It doesn't really explain the usage of shunken special semicolons in papers typeset with TeX.
21:52:53 <ddarius> Cale: A full size semicolon is overbearing.
21:52:53 <geezusfreeek> doesn't the (->) monad basically do (flip (.)) for its join operation? i can't really recall off the top of my head
21:53:08 <kmcallister> if you're using TeX can't you denote composition by the standard circle?
21:53:12 <Cale> ddarius: right, but certainly no easier to type than \circ
21:53:25 <geezusfreeek> i'm mixing my types up, actually
21:53:29 <paczesiowa> I mean, I think in kinda imperative way, first apply f and than g, but I have to type g and than f
21:53:37 <monochrom> Bird uses "g . f" but note how he writes "g : C <- B, f : B <- A"
21:53:40 <Cale> I'm saying I've seen people using semicolons for composition in TeX documents.
21:53:44 <ddarius> Cale: It's called a macro.  I have one in some LaTeX file somewhere.
21:53:46 <Eiler> why does list argument often have an "s" suffix on their name?
21:54:00 <ddarius> I think I use \semi for it.
21:54:03 <geezusfreeek> Eiler: to indicate plurality
21:54:07 <shachaf> Eiler: Because it's plural?
21:54:14 <Cale> ddarius: Of course, I'm just saying that "ease of typing" can't be the reason there.
21:54:20 <geezusfreeek> for example (x:xs) is a singular x and multiple xs
21:54:36 <monochrom> It is ease of reconciling diagram and formula, at least for most people.
21:54:38 <Tac-Tics> and xss (with two s's) is usually a list of lists :: [[a]]
21:54:42 <Eiler> oh, i dont see much plural with [1] or []
21:54:42 <ddarius> Cale: It clearly comes from the same place ; for sequential composition comes from.
21:54:51 <shachaf> Eiler: It could be plural.
21:54:54 <Cale> ddarius: hmm
21:55:08 <geezusfreeek> Eiler: but if it is unevaluated it might as well be plural
21:55:37 <kmcallister> Eiler, usually in a case where you know the list is empty or has only one element, you match it with a more specific pattern
21:55:55 <Cale> Eiler: an undetermined number of things is usually plural in English.
21:56:16 <kmcallister> also 0 is plural
21:56:25 <Tac-Tics> two cows, one cow, no cows
21:56:26 <Tac-Tics> hehe
21:56:37 <geezusfreeek> it's a matter of base case versus inductive step... the inductive step of a recursive function usually assumes that the tail of a list has multiple elements since it doesn't effect the code anyway
21:56:37 <Tac-Tics> > m : cycle 'o'
21:56:38 <lambdabot>   Not in scope: `m'
21:56:43 <shachaf> Perhaps it should be called x, xM, xMM, etc., in different monads.
21:56:45 <sclv> kine ftw.
21:56:46 <Tac-Tics> > 'm' : cycle 'o'
21:56:46 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
21:56:51 <ddarius> What would the land of programming look like if Russian was the language of choice.
21:57:02 <Eiler> Cale: ok, so "s" is just ... "'s" could maybe have been for sequence or something?
21:57:03 <Tac-Tics> > 'm' : repeat 'o'
21:57:04 <lambdabot>  "moooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
21:57:05 <sorear> Tac-Tics: itym repeat
21:57:09 <Tac-Tics> =-)
21:57:11 * sclv is going to replace all his x:xs patterns with cow:kine
21:57:12 <shachaf> > ('m':) . fix . (:) $ 'o'
21:57:16 <lambdabot>  "moooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
21:57:51 <Cale> Eiler: Just the usual plural s, yeah. You could imagine it's for sequence as well, I suppose :)
21:57:52 <sorear> > let a = 'm' : b; b = 'o' : b; in a
21:57:52 <lambdabot>  "moooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
21:58:20 <ddarius> map f (sheep:sheep)  ... Oh noes!
21:58:35 <Cale> map f (sheep:sheeple)
21:58:48 <geezusfreeek> > ['o','o'..]
21:58:49 <lambdabot>  "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
21:58:53 <Tac-Tics> > let oooo = 'o' : os in m:oooo
21:58:54 <lambdabot>   Not in scope: `m'
21:58:54 <geezusfreeek> dang forgot the m
21:59:04 <Tac-Tics> > let oooo = 'o' : os in 'm':oooo
21:59:07 <lambdabot>   Not in scope: `os'
21:59:09 <sclv> > map ('m':) . iterate ('o':) $ []
21:59:10 <lambdabot>  ["m","mo","moo","mooo","moooo","mooooo","moooooo","mooooooo","moooooooo","mo...
21:59:19 <Tac-Tics> damn, I am fail at lambdabot again tonight
21:59:26 <Tac-Tics> > let oooo = 'o' : oooo in 'm':oooo
21:59:28 <lambdabot>  "moooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
21:59:52 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
21:59:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:59:59 <bilbo> Does anyone have an example of using the MonadWriter class?  Specifically the listen and pass functions?
22:00:13 <Tac-Tics> :t pass
22:00:15 <Cale> bilbo: listen and pass are sort of uncommon
22:00:20 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
22:00:29 <Cale> bilbo: tell is by far the most useful operation :)
22:00:45 <geezusfreeek> :t nubBy
22:00:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
22:00:49 <Tac-Tics> :t local
22:00:50 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:01:03 <bilbo> tell is easy to to understand, but I don't even see how to use pass or listen
22:01:35 <geezusfreeek> jeez, nubBy could have saved me a lot of time a few weeks ago
22:01:42 <Tac-Tics> @src pass
22:01:43 <lambdabot> Source not found. stty: unknown mode: doofus
22:01:45 <sclv> bilbo: i assume you've seen http://www.haskell.org/all_about_monads/html/writermonad.html
22:01:47 <lambdabot> Title: The Writer monad
22:02:03 <Cale> bilbo: What listen does is it lets you see exactly what the computation it's given 'tell'ed.
22:02:04 * shachaf thinks the tuple in Writer should be reversed.
22:02:21 <bilbo> sclv: Yup, I've seen it, but the examples on that page only show tell.
22:02:24 <Cale> shachaf: Me too.
22:02:33 <Cale> shachaf: Same with State.
22:03:03 <shachaf> Cale: Well, it'd be even worse if they didn't have the same ordering.
22:03:15 <Cale> shachaf: right :)
22:03:18 <Tac-Tics> pass looks like it probably just extracts the whole monoid of things previously told?
22:03:33 <bilbo> Cale: but how would one use it?  listen expects a Writer monad as input, but you don't have access to that inside the monad.
22:03:43 <shachaf> bilbo: Looking at the source should be simplest.
22:03:53 <Cale> bilbo: It expects a Writer monad computation
22:03:55 <shachaf> For Writer: listen m = Writer $ let (a, w) = runWriter m in ((a, w), w)
22:04:11 <Tac-Tics> > runWriter (listen (do tell [3]; tell [3,4]))
22:04:12 <lambdabot>  (((),[3,3,4]),[3,3,4])
22:04:20 <Cale> bilbo: You usually build monad computations by chaining together other monad computations in a sequence.
22:04:48 <Cale> bilbo: This lets you locally get access to the stuff which an action you're running writes.
22:04:53 <sclv> bilbo: the censor function helps make pass make a great deal more sense.
22:05:13 <Cale> censor f m = pass $ do a <- m; return (a,f)
22:05:45 <bilbo> Thanks, that makes sense.  Thanks for the example Tic-Tacs
22:05:46 <Tac-Tics> what monoid is more suitable for writter? This page makes the warning that list has an inefficient mappend
22:06:02 <shachaf> Tac-Tics: Perhaps DList?
22:06:04 <ddarius> Endo
22:06:05 <Tac-Tics> does bytestring do constant append?
22:06:30 <siti> I think a lazy bytestring will
22:06:33 <Cale> actually list append is usually fine
22:06:44 <Cale> Because it's only inefficient when associated the wrong way
22:07:00 <ddarius> Writer associates it exactly the wrong way.
22:07:03 <Cale> and writer normally creates the right order of association (since you tell short lists)
22:07:11 <Cale> Hm?
22:07:21 <ddarius> @src Writer (>>=)
22:07:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:07:34 <monochrom> @src Writer tell
22:07:35 <lambdabot> Source not found. Just try something else.
22:08:05 <Tac-Tics> So you should be consing to the front instead of ++'ing to the end?
22:08:16 <Tac-Tics> wait
22:08:17 <bilbo> You can see the source in the All About Monads page reference earlier.
22:08:19 <Tac-Tics> you can't do that tho
22:08:27 <ddarius> Cale: tell appends to the end of the list.  So tell "ab"; tell "cd"; tell "ef" is ("ab"++"cd")++"ef"
22:08:48 <shachaf> > runWriter (forever (tell "!"))
22:08:51 <lambdabot> Terminated
22:09:10 <Cale> > let loop n = tell [n] >> loop (n+1) in snd $ runWriter (loop 0)
22:09:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:09:22 <Cale> Are you sure?
22:09:29 <Tac-Tics> > take 100 $ runWriter (forever (tell "!"))
22:09:30 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, w)'
22:09:37 <shachaf> Right, snd.
22:09:39 <adu> > [1,2,3]
22:09:40 <lambdabot>  [1,2,3]
22:09:48 <Tac-Tics> :t runWriter
22:09:49 <adu> yey! I know haskell!
22:09:49 <lambdabot> forall w a. Writer w a -> (a, w)
22:09:58 <ddarius> :t execWriter
22:09:59 <Tac-Tics> bah
22:09:59 <lambdabot> forall w a. Writer w a -> w
22:10:16 <Tac-Tics> > take 100 $ execWriter (forever (tell "!"))
22:10:17 <shachaf> > execWriter (forever (tell "!"))
22:10:23 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
22:10:25 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
22:10:28 <Cale> If it was associating things the wrong way, wouldn't that be _|_ ?
22:10:46 <geezusfreeek> Cale: laziness wouldn't do that though would it?
22:10:47 <Tac-Tics> > take 5 $ execWriter (forever (tell "!"))
22:10:48 <lambdabot>  "!!!!!"
22:11:20 <Cale> Laziness won't change the associativity of expressions automatically.
22:11:20 <geezusfreeek> just like foldr can still actually be evaluated from the left
22:11:24 <ddarius> It shouldn't, so I am probably wrong.
22:11:28 <shachaf> geezusfreeek: Well, if laziness does it, then it's the right order. :-)
22:11:31 <shachaf> geezusfreeek: It can?
22:11:49 <Cale> > foldl (++) [] (repeat "!")
22:11:53 <lambdabot> Terminated
22:11:56 <Cale> > foldr (++) [] (repeat "!")
22:11:57 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
22:12:02 <Cale> big difference :)
22:12:12 <Tac-Tics> @src foldr
22:12:13 <lambdabot> foldr k z xs = go xs
22:12:13 <lambdabot>     where go []     = z
22:12:13 <lambdabot>           go (y:ys) = y `k` go ys
22:12:17 <Cale> ugh
22:12:24 <Cale> foldr c n [] = n
22:12:24 <qebab> O.o
22:12:36 <Cale> foldr c n (x:xs) = c x (foldr c n xs)
22:12:43 <Cale> foldl c n [] = n
22:12:55 <Cale> foldl c n (x:xs) = foldl c (c n x) xs
22:13:00 <qebab> @src fold
22:13:01 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:13:05 <qebab> @src foldl
22:13:05 <lambdabot> foldl f z xs = lgo z xs
22:13:05 <lambdabot>     where lgo z []     =  z
22:13:05 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
22:13:11 <kmcallister> hmm, is the version using "where" more efficient?
22:13:15 <qebab> why do it that way?
22:13:20 <qebab> I can't imagine so
22:13:24 <sorear> it is
22:13:25 <kmcallister> it seems like it might share the free variable environment
22:13:28 <qebab> really?
22:13:31 <geezusfreeek> qebab: for inlining
22:13:37 <Cale> kmcallister: GHC was missing an optimisation so yeah.
22:13:50 <kmcallister> which optimization?
22:14:16 <Cale> I don't remember, but iirc, sorear knows :)
22:14:29 <sorear> static argument transform
22:15:15 <Cale> sorear: Which version of GHC will this be fixed in? Do you know?
22:15:21 <sorear> inlining in functional languages can be leveraged to do partial evaluation.  this happens in the where-version but not the direct recursive one
22:15:40 <sorear> Cale: I haven't been following this closely, it could already be in for all I know
22:19:19 <Cale> I still don't think that having the hacky version of foldr and foldl in the @src database is a good idea.
22:20:14 <Tac-Tics> I have seen you correct that function's source about 7 times since I started learning Haskell, Cale
22:20:19 <Tac-Tics> You really hate it ;-)
22:20:20 <Cale> heh
22:21:34 <geezusfreeek> the ticket is still open
22:21:37 <Cale> Well, the people using @src are usually either beginners interested in seeing how the function is defined, or people teaching beginners showing them how it's defined. Having a confusing version of the function there does nobody any good.
22:21:48 <Tac-Tics> I totally agree
22:22:14 <Tac-Tics> Lambdabot is have pedagogybot and half boredom abusebot
22:22:29 <shachaf> They should have probably have report functions, where possible.
22:23:43 <shachaf> $ grep '<Cale> foldr . . \[] = .' * | wc -l
22:23:43 <shachaf> 28
22:23:50 * shachaf just ruined it, of course...
22:23:58 <Tac-Tics> Is time for me to enter the Sleep monad
22:24:00 <Tac-Tics> night guys
22:24:18 <Cale> shachaf: how about  double x = x + x ? :)
22:24:25 <geezusfreeek> i've been thinking about poking into the ghc source... maybe this would be an interesting thing to try looking into myself...
22:25:38 <shachaf> Cale: It's always 5, you know...
22:25:43 <Cale> yep :)
22:26:31 <Cale> I'm sharing my own computation of double (double 5) amongst the copies of that discussion. :)
22:33:50 <siti> mean bot
22:34:05 <Cale> Mean bot?
22:34:25 <siti> sorry I was saying to to a way above statement and did not realise the conversation had moved on
22:34:27 <Cale> Are you referring to the messages it gives when you ask it for the source of functions it doesn't know?
22:34:32 <siti> it called someone a brocolli brain
22:34:42 <Cale> hehe, yeah
22:37:01 <Cale> @src notexist
22:37:01 <lambdabot> Source not found. It can only be attributed to human error.
22:37:04 <Cale> @src notexist
22:37:04 <lambdabot> Source not found. Take a stress pill and think things over.
22:37:05 <Cale> @src notexist
22:37:05 <lambdabot> Source not found. I feel much better now.
22:37:08 <Cale> @src notexist
22:37:08 <lambdabot> Source not found. Take a stress pill and think things over.
22:37:09 <Cale> @src notexist
22:37:09 <lambdabot> Source not found. My brain just exploded
22:37:11 <Cale> @src notexist
22:37:11 <lambdabot> Source not found. Where did you learn to type?
22:39:58 <sjanssen> @src brocolli
22:39:58 <lambdabot> Source not found. Where did you learn to type?
22:40:01 <sjanssen> @src brocolli
22:40:01 <lambdabot> Source not found. You speak an infinite deal of nothing
22:40:02 <sjanssen> @src brocolli
22:40:02 <lambdabot> Source not found. My pet ferret can type better than you!
22:40:04 <sjanssen> @src brocolli
22:40:04 <lambdabot> Source not found. It can only be attributed to human error.
22:40:06 <sjanssen> @src brocolli
22:40:06 <lambdabot> Source not found. :(
22:40:40 <wagle> @src
22:40:40 <lambdabot> src <id>. Display the implementation of a standard function
22:41:06 <wagle> @src ;
22:41:06 <lambdabot> Source not found. It can only be attributed to human error.
22:41:42 <wagle> @src sjanssen
22:41:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:43:19 <wagle> @src lambdabot
22:43:19 <lambdabot> Source not found.
22:43:39 <wagle> @binary lambdabot
22:43:39 <lambdabot> Unknown command, try @list
22:44:15 <wagle> @gpl lambdabot
22:44:16 <lambdabot> lambdabot
22:44:31 <wagle> neato, a fixpoint
22:45:44 <hpaste>  pastorn pasted "getString by using getChar" at http://hpaste.org/5178
22:45:47 <shachaf> wagle: Fixpoint?
22:46:26 <pastorn> could someone please look at my paste and give me some pointers? (but not the solution)
22:46:47 <shachaf> pastorn: Look at return.
22:46:50 <shachaf> @ty return
22:46:52 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:47:16 <shachaf> pastorn: And look at the type of getString, compared to the way you use it.
22:47:32 <omg911> anyone know if a decision tree and a regression tree are the same thing?
22:47:38 <sjanssen> @type ('c':)
22:47:39 <lambdabot> [Char] -> [Char]
22:47:42 <sjanssen> @type getLine
22:47:43 <lambdabot> IO String
22:48:06 <omg911> @help
22:48:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:48:34 <omg911> @help gpl
22:48:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:48:44 <shachaf> (Also possibly look at fmap.)
22:49:10 <omg911> @help src
22:49:11 <lambdabot> src <id>. Display the implementation of a standard function
22:49:19 <pastorn> shachaf: i was thinking of maybe a helper function so that the return statement would be "top level"
22:49:33 <shachaf> pastorn: You don't really need a helper function.
22:49:42 <shachaf> pastorn: What do you mean by "top level"?
22:51:00 <pastorn> shachaf: nevermind that... what i could use is maybe some way of having [IO Char] -> IO [Char]
22:51:35 <kmcallister> @hoogle [m a] -> m [a]
22:51:36 <lambdabot> Prelude.head :: [a] -> a
22:51:36 <lambdabot> Prelude.last :: [a] -> a
22:51:36 <lambdabot> Data.List.head :: [a] -> a
22:51:49 <kmcallister> @hoogle (Monad m) => [m a] -> m [a]
22:51:50 <lambdabot> Prelude.head :: [a] -> a
22:51:50 <lambdabot> Prelude.last :: [a] -> a
22:51:50 <lambdabot> Data.List.head :: [a] -> a
22:51:52 <shachaf> pastorn: That would be sequence... But it's probably not what you want.
22:51:54 <kmcallister> err...
22:52:13 <pastorn> @type sequence
22:52:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:52:39 <pastorn> @src sequence
22:52:39 <lambdabot> sequence ms = foldr k (return []) ms
22:52:39 <lambdabot>     where
22:52:39 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:52:40 <shachaf> pastorn: But try it that way and see. :-)
22:53:24 <pastorn> @type foldr
22:53:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:54:21 <shachaf> pastorn: sequence = foldr (liftM2 (:)) (return [])
22:56:12 <pastorn> shachaf: since i don't really know how liftM2 should work i'll stick with folding for now
22:56:30 <shachaf> @src liftM2
22:56:30 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:56:41 <shachaf> pastorn: You approach in the paste is pretty close.
22:57:02 <shachaf> pastorn: You just need an extra return and an fmap (or (>>=)/return).
22:58:17 <pastorn> gah!!
22:58:21 * pastorn takes a rest
22:59:48 <shachaf> pastorn: Perhaps you should start with a monad other than IO.
22:59:55 <shachaf> pastorn: Which other ones have you looked at?
23:01:16 <kmcallister> pastorn, the Maybe monad is the simplest imho
23:01:28 <kmcallister> @src Maybe
23:01:29 <lambdabot> data Maybe a = Nothing | Just a
23:01:31 <kmcallister> @src Maybe (>>=)
23:01:32 <lambdabot> (Just x) >>= k      = k x
23:01:32 <lambdabot> Nothing  >>= _      = Nothing
23:01:48 <shachaf> kmcallister: Identity is simpler. :-)
23:01:56 <kmcallister> hehe
23:02:09 <kmcallister> simplest nontrivial, then ;)
23:02:42 <shachaf> What counts as "trivial"?
23:03:55 <kmcallister> @src Identity (>>=)
23:03:56 <lambdabot> m >>= k  = k (runIdentity m)
23:04:30 <kmcallister> i think that's (up to isomorphism) the only possible definition for a datatype isomorphic to Identity
23:05:25 <kmcallister> disregarding undefined and error and such
23:06:08 <shachaf> data Null a = Null is a monad, right?
23:06:18 <kmcallister> oh, point
23:06:23 <kmcallister> but that's even more trivial ;)
23:06:57 <kmcallister> better yet, data NullT m a = Null
23:07:18 <geezusfreeek> talk about useless
23:07:27 <dons> ?users
23:07:27 <lambdabot> Maximum users seen in #haskell: 454, currently: 388 (85.5%), active: 11 (2.8%)
23:14:47 <sorear> there exists a category of monads.  Null is the terminal monad, Identity is the initial monad
23:24:20 <olsner> "... in the early 1980s the US General Accounting Office estimated that the poor design of OS JCL was costing the US economy about $1 billion per year in wasted labor and computer processing costs."
23:27:21 <dmwit> True or false: fix f = undefined for any strict function f.
23:27:39 <kmcallister> @src fix
23:27:39 <lambdabot> fix f = let x = f x in x
23:30:49 <dons> > fix Nothing
23:30:51 <lambdabot>  Couldn't match expected type `a -> a'
23:30:56 <dons> > fix (const Nothing)
23:30:57 <lambdabot>  Nothing
23:31:11 <dons> > fix (\x -> x `seq` Nothing)
23:31:12 <lambdabot>  Exception: <<loop>>
23:31:18 <dons> :)
23:31:32 <dmwit> GHC really is pretty smart, huh?
23:31:39 <dons> dmwit: fundamental lack of expressivity in strict languages :)
23:32:14 <dmwit> =)
23:32:32 <piojo> Is there any way to implement multiple namespaces or use modules within one file?
23:32:48 <dmwit> import Data.Set qualified
23:33:04 <dmwit> Or, import Data.Set qualified as SomethingElse
23:33:13 <piojo> no, I mean, to create multiple modules. it's for a homework assignment, so I know it would normally be bad design
23:33:20 <dmwit> (in fact, importing qualified and importing as are orthogonal.)
23:33:35 <dmwit> Oh, not that I know of.
23:33:50 <dmwit> If you need multiple modules, you have to use multiple files.
23:33:53 <piojo> all right, thanks. then i'll assume I can't. (I've tried, but thought there might be a trick)
23:34:00 <dmwit> (One module per file.)
23:34:02 <piojo> oh, i misread you.. thanks
23:34:39 <sjanssen> dmwit: regarding your earlier question: True, I think
23:35:26 <dmwit> sjanssen: Thanks.  I thought it would be, but figured I should ask in case there was something subtle (and therefore interesting! =).
23:35:37 <sjanssen> for single argument f, at least
23:37:48 <sjanssen> > fix (\f n -> f `seq` if n == 0 then 1 else n * f (n-1)) 6
23:37:49 <lambdabot>  720
23:38:07 <sjanssen> that is strict in both arguments, but isn't _|_
23:38:16 <dmwit> oh
23:38:19 <dmwit> huh
23:38:40 <pastorn> @src GHC.IOBase.(>>=)
23:38:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:38:45 <pastorn> @src GHC.IOBase.>>=
23:38:45 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:38:46 <sjanssen> dmwit: so it isn't true
23:39:01 <dmwit> right, weird
23:39:13 * dmwit has to think a bit more
23:39:28 <pastorn> @src getLine
23:39:28 <lambdabot> getLine = hGetLine stdin
23:39:35 <dmwit> ?src (GHC.IOBase.>>=)
23:39:36 <lambdabot> Source not found. You speak an infinite deal of nothing
23:39:53 <dmwit> ?src Monad
23:39:54 <lambdabot> class  Monad m  where
23:39:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
23:39:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
23:39:54 <lambdabot>     return      :: a -> m a
23:39:54 <lambdabot>     fail        :: String -> m a
23:39:59 <dmwit> There it is. =)
23:40:21 <dmwit> (You have to give a specific Monad to get the implementation of (>>=).)
23:40:47 <kmcallister> ?src IO (>>=)
23:40:47 <lambdabot> m >>= k     = bindIO m k
23:41:30 <kmcallister> ?src IO
23:41:30 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:42:20 <dmwit> '#' is short for "wizardry"
23:42:41 <kmcallister> yes
23:43:02 <dons> well, of strict kind -- no bottom inhabitants allowed
23:43:17 <dons> simplifies the proofs (you can't slip 'undefined' in as your world)
23:43:32 <dons> and makes the optimiser much happier
23:59:32 <EvilTerran> ?src bindIO
23:59:33 <lambdabot> bindIO (IO m) k = IO ( \ s ->
23:59:33 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
23:59:41 <EvilTerran> ?src unIO
23:59:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:59:58 <geezusfreeek> wow, that newtype definition of IO reads exactly the way i imagine pseudocode for it would in a beginner's monad tutorial
