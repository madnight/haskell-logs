00:12:27 <EvanR> failed to successfully use phantom types, this time
00:32:04 <pharaun> how the heck do i write an instance of MonadError for ST ?
00:34:34 <augur> edwardk!
00:34:55 <pharaun> so i should be paging this guy? :p
00:35:03 <augur> pharaun: no, im paging him :P
00:35:14 <augur> edwardk: i saw that version of FixF you wrote about that handles non-regular types
00:35:16 <pharaun> lol
00:35:19 <pharaun> augur: boo :)
00:35:27 <augur> edwardk: its horrible :(
00:35:32 <augur> well, non-regular types are horrible
00:35:56 <augur> i havent read the hinze paper in full detail, but does it have a nice categorical interpretation, or is it just a haskell hack?
00:36:31 <augur> (i say, as tho i havent spent hours arguing that categorical interpretations are silly >_>)
00:43:12 <pharaun> wow i'm really stuck with this MonadError instance
00:44:04 <augur> pharaun: you want a monaderror for just ST?
00:44:21 <augur> should that even be possible? ST is just some better kind of state, no?
00:44:32 <augur> error is like a classy Either
00:44:35 <pharaun> http://lpaste.net/104274
00:45:34 <pharaun> Basically I replaced IORefs with ST because I wanted to be able to run multiple computation in independent ST but for the repl loop i did stToIO so i could persist the ST between repl loop
00:45:50 <augur> im not sure you can make ST into a monad error
00:45:52 <pharaun> and i followed the types and i got something that type checks but I'm stuck with this MonadError and ST :\
00:46:06 <pharaun> I don't know any other way of doing this
00:46:20 <augur> what is "this"?
00:46:23 <pharaun> the original code was IORefs + Errors
00:46:40 <augur> perhaps you should be lifting something more than just ST
00:46:49 <pharaun> and i'm wanting to remove the dependency on IORefs so that i can run multiple instances in separate ... state context
00:46:51 <augur> maybe somthing like ST (Error e a) instead!
00:47:23 <pharaun> augur: ST s (Error e a) ?
00:47:32 <augur> something like that
00:48:29 <augur> ST doesnt look like a MonadError
00:48:47 <pharaun> well yeah but i've kinda coded myself into a corner XD
00:48:48 <augur> so probably you want something else besides just ST
00:49:01 <augur> pharaun: well code yourself out!
00:49:04 <pharaun> ha
00:49:29 <augur> fwiw
00:49:43 <augur> MonadError e m => MonadError e (StateT s m)
00:49:56 <pharaun> i'm doing a scheme interpreter
00:50:00 <augur> ok
00:50:01 <pharaun> so i'll need to do closures and etc
00:50:17 <pharaun> and I tried the StateT approach and that exploded in complicatedness
00:50:34 <pharaun> the IORefs approach worked great but well its IORefs :\
00:51:40 <pharaun> augur: sorry, i guess i just am kinda really confusing myself and this is confusing the hell out of me
00:52:17 <pharaun> hm let me back up, so um
00:52:40 <pharaun> ugh
00:53:22 <augur> i think you should make it work with State first
00:53:26 <augur> then try shifting to ST
00:53:33 <pharaun> i had it working with IORefs :\
00:54:23 <augur> it sounds like what you want is something like
00:54:34 <augur> ST Env (Error String a)
00:54:55 <pharaun> yeah
00:55:06 <pharaun> I'm just not sure how to switch it around atm looking at the types
00:55:11 <pharaun> i've really coded myself in a corner
00:56:11 <pharaun> a sec
00:56:24 <augur> perhaps ideally you should define   newtype SchemeState a = SchemeState { runSchemeState :: ST Env (Error String a) }
00:56:51 <augur> concentrate all the important stuff in the instances
00:57:07 <pharaun> http://lpaste.net/104275
00:57:10 <pharaun> core types here ^
00:57:14 <pharaun> and yeah
00:57:43 <pharaun> i think what really wedged me was the IOFunc
00:57:53 <augur> why is LispVal parameterized?
00:58:07 <pharaun> IOFunc (MonadError (error) (st))
00:58:16 <pharaun> :\ so i think if i can fix/get rid of that
00:58:31 <augur> what a strange thing to have
00:58:32 <pharaun> then i can remove the parameterized LispVal then remove the paramterized LispError
00:58:43 <augur> well, what do i know, im not a hardcore haskeller
00:58:58 <pharaun> augur: seriously thanks for your help, you've pointed me in the right direction
00:59:06 <pharaun> i think i need to fix up my lispVal AST
00:59:06 <augur> maybe!
00:59:11 <pharaun> then the rest should fall out hopefully
00:59:26 <augur> i think all you really need is for your envs to be stateful tho
00:59:34 <augur> im not sure you really need anything else to have state
00:59:38 <pharaun> agreed!
00:59:57 <pharaun> I think I just need to figure out a way to enchance my LispEnv to handle what i had in the IOFunc and pull it out
01:00:15 <augur> oh well no actually thats not true is it
01:00:20 <pharaun> oh?
01:00:24 <augur> no you need your cons pairs to be stateful too
01:00:41 <augur> because you want to have set-car and set-cdr
01:00:54 <pharaun> yeah
01:01:05 <pharaun> that would be Func -> closure
01:01:10 <augur> no no
01:01:16 <augur> i would just do something more like
01:01:48 <augur> data LispVal = ... | ConsPair (STRef ??? LispVal) (STRef ??? LispVal)
01:04:17 <pharaun> hm
01:05:10 <pharaun> i wonder what about pulling the STRef out of the AST into the eval core
01:05:19 <pharaun> then i would be able to completely get that stuff out of the AST ?
01:05:39 <augur> i think you need stateful ASTs
01:05:49 <augur> its crucial that your cons pairs have stateful elements
01:09:11 <pharaun> husk-scheme does has state in its AST
01:09:31 <pharaun> but if i end up with the state in the A
01:09:51 <pharaun> sorry, ast i'm stuck parameterizing LispVal and then i get stuck with error handling
01:10:35 <pharaun> i guess you're right I need to instead of (ST s (LispVal s)) i should probably pull it out to be like (ST s (Either (Error ???) (LispVal ???))
01:10:46 <augur> no no
01:10:49 <augur> Either ~ Error
01:11:09 <pharaun> sorry i'm tired, but yes you're right
01:11:24 <pharaun> S/Error ???/LispError/
01:11:35 <pharaun> which is the adt of error conditions
01:11:41 <startling> it might be neat to parametrize your AST by the reference type.
01:11:49 <augur> i think you just want ST s (LispError a)
01:12:06 <pharaun> augur: oh how come?
01:12:13 <pharaun> startling: i'm not sure i get you?
01:12:13 <startling> Then a stateless AST is a Fix LispVal
01:12:36 <pharaun> oh free monad?
01:12:51 <startling> pharaun, something like "data LispVal ref = ... | Cons ref ref"
01:13:16 <startling> I don't think that's a Monad, much less a free monad. :P
01:13:41 <pharaun> sorry i just last time i saw a Fix was in a free monad article, trying to find it now
01:13:44 <pharaun> (Fix)
01:14:00 <startling> newtype Fix f = Fix (f (Fix f))
01:15:25 <startling> so a Fix LispVal would be a LispVal where "references" are other LispVals, whose "references" are other LispVals etc
01:15:31 <pharaun> ahh
01:16:06 <startling> hm, that might make things complicated
01:16:08 * startling shrugs
01:17:56 <pharaun> ok thanks startling and augur
01:18:43 <din_> hi
01:18:58 <din_> i just started learning haskell
01:19:29 <din_> i need help
01:22:26 <din_> hello anybody there??
01:23:15 <michi7x7> din_: nope
01:23:29 <shelf> din_: please post specifics to get help. use http://lpaste.net/new/haskell
01:27:46 <din_> i just downloaded haskell platform on windows. and i am working on [http://learnyouahaskell.com/starting-out]. In that i created a baby.hs file and defined a function [doubleMe x = x + x  ] in it. loaded in ghci and it executed correctly.
01:28:57 <Iceland_jack>  hey din_
01:30:25 <din_> i tryed to define another funtion and append in it and reloaded with :r and executed using :l baby.hs. this time the second function is not working
01:30:55 <Iceland_jack> ':l' does not execute, if you use ':r' that should be enough
01:30:58 <Iceland_jack> paste your code here
01:31:00 <Iceland_jack> @where lpaste
01:31:00 <lambdabot> http://lpaste.net/new/haskell
01:32:32 <pharaun> startling: oh neat the Fix thing will work for a stateless AST for error reporting
01:32:45 <pharaun> so that lets me clean up a few little corners of this codebase
01:33:05 <din_> first time in my file baby.hs only one fuction [doubleMe x = x + x ]. after appending my baby.hs file contains [doubleMe x = x + x  doubleSmallNumber x  = x*2]. after :r the function doubleSmallNumber is not working
01:33:52 <Iceland_jack> din_: If you have a newline between those two functions it should work, if it already has a newline you should upload it on lpaste as previously suggested
01:33:56 <din_> <Iceland_jack> here is my code . first time in my file baby.hs only one fuction [doubleMe x = x + x ]. after appending my baby.hs file contains [doubleMe x = x + x  doubleSmallNumber x  = x*2]. after :r the function doubleSmallNumber is not working
01:34:56 <nadirs> din_: hello, can you paste the whole source on lpaste so we can see the exact formatting (an IRC chat message isn't often the best medium for showing source code directly)
01:35:37 <din_> i dont no lpaste. what should i do
01:35:44 <Iceland_jack> @where lpaste
01:35:44 <lambdabot> http://lpaste.net/new/haskell
01:35:53 <Iceland_jack> din_: Open that link
01:36:41 <din_> ok i  pasted here i the link http://lpaste.net/104276
01:37:46 <Iceland_jack> din_: that works just fine
01:38:06 <Iceland_jack>     $ curl -s -o baby.hs http://lpaste.net/raw/104276
01:38:06 <Iceland_jack>     $ ghci baby.hs
01:38:06 <Iceland_jack>     ghci> doubleSmallNumber 4
01:38:06 <Iceland_jack>     8
01:38:43 <din_> <Iceland_jack> for me it says "Not in scope 'doubleSmallNumber'"
01:39:22 <Iceland_jack> din_: But 'doubleMe' works?
01:39:28 <michi7x7> din_: http://lpaste.net/4539932830196563968
01:39:36 <michi7x7> I don't see your problem
01:39:47 <coppro> din_: can you paste your entire interaction?
01:39:48 <nadirs> din_: maybe a stupid question but did you save the file after the second edit?
01:39:51 <Iceland_jack> din_: As you could see both I and michi7x7 could take your _exact_ code and it worked
01:39:53 <din_> <Iceland_jack> ya doubleMe works
01:40:06 <Iceland_jack> din_: Make sure you've saved your file propr
01:40:08 <Iceland_jack> *proper
01:40:18 <Iceland_jack> and load it using :l baby.hs
01:40:38 <zacts> may I ask a cabal question here?
01:40:42 <michi7x7> din_: you can also use ":e" to fire up your editor
01:41:34 <pavonia> @hoogle [a] -> (a -> b) -> [b]
01:41:37 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:41:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:41:38 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:41:42 <zacts> specifically a question about why I'm not seeing ~/.cabal/bin on Ubuntu.
01:41:57 <pavonia> Wasn't there a for?
01:42:19 <din_> <Iceland_jack><michi7*7> see this http://lpaste.net/104277
01:42:20 <Iceland_jack> @ty T.for
01:42:21 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
01:42:48 <pavonia> Hhm, that's different
01:42:48 <nadirs> zacts: you're not seeing it? Do you mean it doesn't exist or it's not in your $PATH?
01:43:02 <Iceland_jack> pavonia: yes it is
01:43:06 <Iceland_jack> there is also forM
01:43:07 <Iceland_jack> @ty forM
01:43:08 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
01:43:09 <louisjb> hi, I'm trying to set up vim for haskell, I've got the main bits installed, ghcmod, syntastic, tagbar, exuberant ctags etc. But what I was expecting was a panel for results of compilation and running the main. Is that possible?
01:43:11 <zacts> I don't see it when I do ls ~/.cabal/
01:43:18 <Iceland_jack> or
01:43:18 <Iceland_jack> @ty flip map
01:43:19 <lambdabot> [a] -> (a -> b) -> [b]
01:43:23 <michi7x7> din_: try typing ":browse" in ghci
01:43:28 <zacts> I also have export PATH="~/.cabal/bin:$PATH"
01:43:42 <zacts> I'm trying to install shelly
01:43:59 <zacts> I'm also reading -> http://www.haskell.org/haskellwiki/Cabal-Install
01:44:09 <zacts> maybe it tried to install my packages globally
01:44:29 <michi7x7> zacts: did you run it with superuser rights?
01:44:43 <din_> <michi7x7> ya i typed i got doubleMe :: Num a => a -> a
01:44:52 <din_> output
01:44:56 <zacts> michi7x7: nope
01:45:13 <zacts> I did as a normal user: bash-$ cabal install shelly
01:46:10 <zacts> michi7x7: actually this is how I bootstrapped cabal in the first place. I added the ppa Ubuntu haskell repo. installed cabal-1.20 and the latest ghc that way.
01:46:32 <zacts> then I did as normal user: bash-$ cabal update \n bash-$ cabal install cabal
01:47:05 <zacts> at this point I added ~/.cabal/bin to my $PATH. I don't see ~/.cabal/bin when I do ls ~/.cabal/
01:47:57 <michi7x7> zacts: sorry, I'm not using Ubuntu but you may try to locate the installed file. That's usually what I do
01:48:25 <din_> <Iceland_jack><michi7x7> Thank you very much for your help it got executed correctly. I edited using ":e" option and it worked.
01:48:28 <zacts> ok
01:52:22 <louisjb> actually :make is working and taking me to an error, so that means haskellmode-vim is working I presume. How do I launch the main in the file in the current buffer?
01:58:22 <jophish> What's a nice way to have 'Lazy IO values'. For example if I need to have some memory allocated with malloc available throughout my program, is there a tidy way I can call malloc the first time this is used and cache that pointer, and use that forever onwards?
01:58:56 <zacts> I think I've figured it out
01:58:56 <jophish> the type of 'getPointer' would be :: IO (Ptr whatever)
01:59:39 <jophish> I can think of a couple of ways of doing this, but I'm not sure which is best
02:00:23 <michi7x7> jophish: I guess since everything in Haskell is per default lazy I don't think you have to handle this explicitly
02:01:33 <jophish> michi7x7: that would be fine if it were a pure value, but because the creation of the pointer has side effects I'd like to guarantee that these effects only happen once
02:01:35 <din__> Is there any good resource so that i can learn haskell in depth very fast?
02:02:08 <michi7x7> din__: lern you a haskell is really good. Just go ahead
02:02:09 <jophish> din__: I don't think that resources like that exists for any topic.
02:02:29 <jophish> LYAH is a very good starting guide though.
02:02:58 <vandenoever> i'm looking for a nice and simple example of a http proxy in haskell
02:03:00 <din__> <michi7x7> <jophish> ok
02:04:42 <pavonia> jophish: If you need to make sure it's only evaluated once, you could use an IORef/MVar, for making it lazy there's unsafeInterleaveIO
02:05:14 <Iceland_jack> din__: LYAH is a very good place to start
02:06:03 <din__> <Iceland_jack> ok
02:06:59 <Iceland_jack> Note that you can query lambdabot with some commands
02:07:10 <Iceland_jack> like evaluating expressions by prefixing them with '> '
02:07:12 <Iceland_jack> > 5 + 10
02:07:13 <lambdabot>  15
02:07:45 <jophish> pavonia: So at the start of my program I create an IORef filled with Nothing, on the first call to getPointer, if it's Nothing then allocate the memory, if it's Just p then return p
02:08:43 <pavonia> jophish: yup
02:08:48 <nadirs> din__: the second sentence in this gist: https://gist.github.com/bitemyapp/8739525 (also the whole thing a good list of learning resource)
02:09:03 <nadirs> *resources
02:09:15 <louisjb> ctrl-] in vim with haskellmode-vim reports tag not found for all tags ,did I miss something?
02:09:21 <jophish> I was hoping that there was a way to do this without creating the IORef and passing it around, i.e. have everything contained in getPointer
02:10:07 <jophish> I'm not sure if this is at all possible though
02:11:16 <jophish> Unless theres something really clever which can be done this would require a global variable, (local static in C)
02:11:42 <din__> <nadirs> Thanks
02:12:06 <nadirs> din__: no problem
02:14:40 <jophish> Looking at the netwire 1.10 docs there is executeOnce :: MonadControlIO m => Wire m (m a) a
02:14:50 <jophish> this seems to be exactly what I want
02:24:30 <pharaun> i'm surprised by the lack of doc on ST/STRef
02:24:40 <pharaun> feels like no one uses it
02:32:51 <darthdeus> guys when using domain sockets, should I use Text or ByteString?
02:33:03 * hackagebot binary 0.7.2.1 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.2.1 (LennartKolmodin)
02:35:53 <darthdeus> ah nvm the api uses ByteString
02:36:53 <darthdeus> but what's a general rule of thumb if i'm deciding what string type should I use?
02:47:11 <jtcwang> Text if you're doing lots of things with it (and need unicode support)
02:47:18 <jtcwang> string is just [Char]
02:47:26 <jtcwang> which is pretty much ASCII
02:47:53 <jtcwang> ByteString is normally for file IO etc
02:50:25 <crazydave> jtcwang: following on from that.  If I wanted to do file IO is there a more efficient way to build the ByteString than e.g. (BS.pack . show)
03:10:04 <ReinH> > maxBound :: Char
03:10:05 <lambdabot>  '\1114111'
03:10:12 <ReinH> Is not ASCII.
03:11:24 <ampharmex> What is the best site for Haskell freelancing?
03:11:31 <ReinH> crazydave: build what bytestring?
03:12:06 <ReinH> A good rule of thumb is "don't use String"
03:13:47 <jtcwang> crazydave, depends on what your input is
03:14:01 <crazydave> ReinH: If I want to display an Int how do I do it without using String. show's type is :: Showable a => a -> String
03:14:05 <jtcwang> i think Text can directly translate to bytestring
03:14:10 <jtcwang> by just using pack
03:14:12 <jtcwang> iirc
03:14:36 <ReinH> It's ok to use String for trivial things.
03:14:42 <crazydave> what if my input isn't Text (or ByteString)?
03:15:52 <crazydave> sure, but what if it is the worst performing part of my program ... or is it impossible to get around it?
03:16:31 <crazydave> doesn't this make text (lowercase not Text) based protocols slow because you have to build up a String
03:16:38 <jtcwang> crazydave, unless you're doing heavy text manipulation, i doubt it'll be the slowest part of your program
03:16:45 <crazydave> and if the answer is "use Text" or "use ByteString"
03:16:55 <crazydave> jtcwang: profiling! It is.
03:17:28 <jtcwang> well in that case yeah you'll probably want to use bytestring
03:17:38 <jtcwang> you're talking about network protocol right?
03:17:44 <crazydave> if the answer is use one of the others then that doesn't work because how do I convert Int -> Text | ByteString without using pack . show
03:17:45 <jtcwang> dealing with bytes?
03:18:25 <ReinH> You can use Data.Text.Lazy.Builder
03:18:38 <davean> rrr
03:19:56 <crazydave> I have a data type that I want to output ....
03:20:30 <crazydave> the fact that I end up printing it out is irrelevant (IMHO) because it _could_ be used as a message type to pass across a network
03:20:39 <crazydave> or to pipe to another program
03:20:54 <crazydave> and the slow part is building the String to output
03:21:19 <jtcwang> i haven't dealt with Text yet
03:21:29 <ReinH> Text and ByteString both have builders for this
03:21:35 <jtcwang> but it sounds like it'll be good for your usecase
03:21:37 <crazydave> ahhhh
03:22:48 <jtcwang> say you have an Int
03:22:59 <crazydave> finally I have an answer to my SO question.  I'll read up on builders and see if I can work out how to use it
03:23:09 <jtcwang> you can do (singleton . fromIntegral)
03:23:16 <jtcwang> to turn it into a ByteString
03:23:20 <wojtekM_> I have a question about GHC heap representation. Will lambdabot let me use GHC.HeapView?
03:23:22 <jtcwang> no need for show
03:23:47 <crazydave> okay! great .. I don't have to go via String
03:23:59 <jtcwang> yeah
03:24:11 <jtcwang> Word8 is just like Int
03:24:18 <jtcwang> you can convert between them using fromIntegral
03:24:44 <crazydave> ummm ... no ... that's not what I want to do though
03:24:54 <crazydave> I want to DISPLAY an Int
03:24:59 <wojtekM_> >let i1 = (1 :: Integer) in GHC.HeapView.getClosureRaw i1
03:24:59 <wojtekM_>  
03:25:10 <crazydave> not convert it to its character encoding
03:25:31 <crazydave> i.e 0::Int should output 0 not '\0'
03:26:05 <ReinH> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Builder.html#g:12
03:27:12 <jtcwang> crazydave, right
03:27:18 <jtcwang> import Data.Char
03:27:37 <ReinH> :t intDec
03:27:39 <lambdabot> Not in scope: ‘intDec’
03:27:56 <jtcwang> import Data.Text
03:28:03 <wojtekM_> >2+1
03:28:27 <wojtekM_> hmm
03:29:20 <jtcwang> (singleton . intToDigit) 1
03:29:25 <jtcwang> crazydave, that should do
03:29:47 <jtcwang> that should be close to bare metal speed
03:29:58 <crazydave> ok, I'll try
03:29:59 <jtcwang> since I think String is slow cuz it's a linked list of Chars
03:30:15 <crazydave> yeah linked list of Char is horrible
03:30:37 <ReinH> wojtekM_: you need a space after >
03:31:48 <ReinH> singleton isn't what you want
03:31:56 <ReinH> You want the builder stuff I linked.
03:31:59 <crazydave> hmmm intToDigit outputs a char ... i.e. it works on Ints between 0 and 15
03:32:03 <crazydave> that's not enough
03:32:13 <ReinH> crazydave: ^
03:32:20 <crazydave> yeah I'm reading through that .... not groking it yet ...
03:32:25 <crazydave> I'm sure I'll get there
03:32:29 <ReinH> intDec
03:33:11 <ReinH> toLazyByteString . intDec
03:33:14 <crazydave> ah, excellent ....
03:33:31 <ReinH> The docs have nice examples at the top
03:33:51 <crazydave> yeah, it was long ... I have to read through it and understand it
03:34:10 <crazydave> hadn't finished when jtc was suggesting a 'simpler' way
03:34:22 <ReinH> Builder is designed for fast concatenation for building up encodings, etc.
03:34:22 <jtcwang> sry :/
03:34:37 <crazydave> simpler in the way I can improve performance of all programs ... as long as it doesn't have to be correct :)
03:34:54 <crazydave> no wories jtc ... you learned something too!
03:34:56 <ReinH> Which is why it must be converted into an actual bytestring. It's a different representation.
03:35:24 <crazydave> okay cool
03:35:36 <ReinH> There is an equivalent for Text as well
03:36:05 <crazydave> I'll probably use BS as I'm using that already in my program
03:36:10 <ReinH> Sure
03:36:14 <wojtekM_> > let i1 = (1 :: Integer) in GHC.HeapView.getClosureRaw i1 >>= print >> GHC.HeapView.getClosureData i1 >>= print
03:36:15 <lambdabot>  Not in scope: ‘GHC.HeapView.getClosureRaw’Not in scope: ‘GHC.HeapView.getClo...
03:36:45 <wojtekM_> Well, let me just paste the output
03:37:04 <wojtekM_> (0x0000000041456ed8,[1095069416,1],[])
03:37:04 <wojtekM_> ConsClosure {info = StgInfoTable {ptrs = 0, nptrs = 1, tipe = CONSTR_0_1, srtlen = 0}, ptrArgs = [], dataArgs = [1], pkg = "integer-gmp", modl = "GHC.Integer.Type", name = "S#"}
03:39:15 <wojtekM_> Now, what is this 1095069416 (first word on the heap)?
03:53:10 * hackagebot apiary-cookie 0.4.3.3 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.3.3 (HirotomoMoriwaki)
03:53:12 * hackagebot apiary-websockets 0.4.3.3 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.4.3.3 (HirotomoMoriwaki)
04:00:49 <michi7x7> In real Haskell applications, do you guys use the ReaderT/WriterT Transformer to ensure read/write-only access, or do you carry a global State around where some variables are only read and others are only written?
04:05:35 <jtcwang> michi7x7, I'd say if you need both Reader and Writer, then u might as well just use StateT
04:06:00 <jtcwang> but ReaderT, WriterT does make it more obvious what's read-only and write-only
04:10:19 <michi7x7> jtcwang: I just wonder, because every other language is so proud about their data-hiding/access-restricting constructs. Haskell is really different in that regard.
04:13:06 <pejo> michi7x7, my experience is that a lot of code can live without monads.
04:14:44 <jtcwang> michi7x7, haskell is about making side effects explicit
04:18:13 <kotopies> Hi! Is there any way to use fields labels with strict flags in type declaration?
04:33:57 <danbst> Hello. I've written Collatz length calculator (http://lpaste.net/104279). It works, except for number 113382. How can I debug it?
04:34:15 <danbst> and any suggestions to speed up it?
04:37:31 <michi7x7> danbst: you can use ghci to debug (try :h)
04:38:11 <michi7x7> and profiling Haskell is quite easy actually: http://book.realworldhaskell.org/read/profiling-and-optimization.html
04:40:31 <danbst> michi7x7, yep. I've found that is due to int overflow
04:41:22 <danbst> michi7x7, Debug.Trace must be in Prelude
04:41:38 <hexagoxel> > take 10 $ zipWith (,) [4..] [4..]
04:41:40 <lambdabot>  [(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,12),(13,13)]
04:42:02 <hexagoxel> danbst: that zipWith seems unnecessary ^
04:42:22 <michi7x7> > take 10 [(a, a) | a < [4...]
04:42:24 <lambdabot>  <hint>:1:29:
04:42:24 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:42:34 <michi7x7> > take 10 [(a, a) | a < [4...] ]
04:42:36 <lambdabot>  A section must be enclosed in parentheses thus: (4 ...)
04:42:46 <michi7x7> goddammit XD
04:44:22 <danbst> hexagoxel: is `map (\x -> go x x) [4..]` better then zipWith version?
04:44:33 <hpc> take 10 [(a, a) | a <- [4 ..]]
04:44:36 <hpc> > take 10 [(a, a) | a <- [4 ..]]
04:44:37 <lambdabot>  [(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,12),(13,13)]
04:45:02 <michi7x7> @hoogle a -> (a,a)
04:45:04 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
04:45:04 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
04:45:04 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
04:46:00 <danbst> oh, it is really better - [go x x | x <- [4..]]
04:46:21 <michi7x7> :t go
04:46:22 <lambdabot>     Not in scope: ‘go’
04:46:22 <lambdabot>     Perhaps you meant one of these:
04:46:22 <lambdabot>       ‘g’ (imported from Debug.SimpleReflect),
04:53:06 <hexagoxel> danbst: to be honest i wrongly assumed you never used go with different parameters (my bad), but i guess having only one list allows for better optimization :D
04:59:27 <zacts> cool! I actually understand a line of one of your pastes! I feel cool now.
04:59:49 <danbst> hexagoxel, even now it is not fast http://lpaste.net/104279
05:00:14 <danbst> I mean, it is not faster, though correct
05:01:22 <michi7x7> danbst: try to profile it
05:02:53 <danbst> michi7x7, it's a pity that I have to use profiling techics for such small amount of code...
05:04:52 <michi7x7> danbst: I don't think so 10% code, 90% runtime costs. Profiling is always necessary
05:07:44 <epta> why does @netwire 5.0.0 has a dependency on itself?
05:08:18 * hackagebot apiary 0.5.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.5.0.0 (HirotomoMoriwaki)
05:13:14 <michi7x7> danbst: well, profiling shows 99% of time is spent in go, but only 5% of allocations are done there. which essentially means it doesn't produce anything while still taking a long time
05:13:43 <michi7x7> But well, that's because of the recursion which you need to get rid of
05:14:02 <danbst> michi7x7, do you mean make tail recursion?
05:15:39 <michi7x7> danbst: I mean you have to do some sort of caching to avoid walking the whole sequence over and over
05:16:30 <michi7x7> danbst: http://www.haskell.org/haskellwiki/Memoization
05:16:30 <danbst> michi7x7, but I've already done that. When conjection length is already computed - it is taken directly
05:17:03 <hexagoxel> danbst: but only if n<m
05:17:14 <hexagoxel> just memoize everything :D
05:17:33 <danbst> hexagoxel, ah
05:26:04 <danbst> michi7x7, memoisation is cool, but ugly (for Collatz). I'll better watch some TV or drink coffee while GHCi computes my project euler 14 :D
05:27:43 <exicer> Is it possible to use aeson with stuff like data Unit = Kg | Lbs ?
05:27:51 <calsaverini> hi there
05:30:22 <zacts> how can I link a C library with a haskell program?
05:30:34 <zacts> I want to implement a minix3 hello driver in haskell
05:30:47 <zacts> I'm almost 1/2 way through LYAH
05:31:07 <zacts> perhaps I'm getting to far ahead of myself..
05:31:22 <calsaverini> Is it possible to update a package with cabal after it was installed in the system via apt-get (via the haskell-platform debian package) ??
05:33:15 <calsaverini> I ended up removing haskell-platform and all extra packages and keeping only GHC and cabal-install. I'll try to manually install everything I need with cabal only. Is it enough?
05:33:58 <exicer> calsaverini: With newer version of cabal, you can use cabal sandboxes.. not sure if this really solves your problem though.
05:34:13 <exicer> They are kidna like virtual-envs from python, if you are familiar with those.
05:34:59 <calsaverini> exicer: it seems nice. If they can bypass completely whatever packages are installed in the system, this can help!
05:35:38 <calsaverini> exicer: I'll read about it, thanks.
05:38:24 <calsaverini> Actually what I'm trying to do is to experiment with a web framework in haskell. What framework do you recommend? Yesod?
05:39:22 <exicer> calsaverini: I tried yesod when I was just learning, and found it way too complicated. You could easily be smarted than I am though :p
05:39:52 <exicer> Scotty is a really minimalistic.. well I guess it isn't even a framework, its kinda like flask in python.
05:40:10 <exicer> Very easy to use as a beginner though, but I doubt you would use it for a 'real' site.
05:40:20 <exicer> Snap seems to be a nice balance between the two.
05:42:41 <din> Can we use haskell to develop a web application??
05:43:23 <rcharles> din: yes you can. Checkout Yesod.
05:43:44 <din> <rcharles> Ok
05:44:24 <romildo> Installing encoding-0.7 on my gentoo linux systems fails with the error:
05:44:25 <romildo> Data/Static.hs:39:28: Couldn't match expected type ‘Bool’ with actual type ‘Int#’
05:44:25 <romildo> The complete log is here: https://gist.github.com/anonymous/053d60f2cddef4bbd06a
05:44:28 <romildo> Any clues?
05:44:30 <calsaverini> exicer: I LOVE Flask!
05:44:56 <calsaverini> exicer: I really like micro frameworks. I like Flask so much better than Django.
05:45:03 <calsaverini> exicer: I'll take a look at Scotty.
05:45:10 <calsaverini> exicer: and Snap
05:49:39 <din> Can we setup yesod on windows?
05:49:58 <danbst> din, use Scotty
05:50:14 <danbst> din, it has some middleware bindings to Yesod
05:50:28 <danbst> and it works under Windows, yes
05:50:41 <din> <danbst> Ok
05:52:49 <din> <danbst> how to install it. Is there is good source available
05:52:58 <din> ?
05:56:10 <danbst> din, cabal install scotty
05:57:03 <danbst> din, http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
05:58:14 <Jefffrey> Hello
05:59:07 <Jefffrey> If I do "import X (D)" with "D" being a data type, does it automatically export all D's class instances defined in X?
05:59:11 <din> <danbst> there it says it uses cabal sandbox ? whats that? Cant i install directly in widows?
05:59:34 <din> I like to use it windows environment
05:59:44 <Jefffrey> din: It's `cabal sandbox`
06:00:06 <Jefffrey> A "submodule" of cabal, that is available only in the lasts few versions.
06:00:53 <Jefffrey> See here: http://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
06:01:15 <din> <Jefffrey> ok ill check it
06:03:22 * hackagebot network-simple 0.4 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4 (RenzoCarbonara)
06:08:22 * hackagebot threepenny-gui 0.4.2.0 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.4.2.0 (HeinrichApfelmus)
06:38:25 * hackagebot cabalg 0.2.2 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.2 (DmitryMalikov)
06:40:57 <hexagoxel> @tell danbst collatz memoization gives speedup factor 10, roughly, in my testcases (ping me if you want to see the code, it's not that ugly :)
06:40:58 <lambdabot> Consider it noted.
06:42:52 <skuggi> Jefffrey: class instances are always imported
06:43:35 <Jefffrey> skuggi: Not always. If I do "import X()", no class instances are imported from X.
06:45:23 <bennofs> Jefffrey: no, they are even the imported
06:46:12 <Jefffrey> bennofs: s/the/then/ ?
06:46:14 <hexagoxel> Jefffrey: afaik "import X()" is supposed to express "import just the instances"
06:46:22 <Jefffrey> Oh.
06:46:24 <Jefffrey> I see.
06:46:28 <rhaps0dy> hexagoxel: can you explicitly do memoization in haskell ?
06:46:29 <Jefffrey> Thanks.
06:47:33 <hpc> rhaps0dy: how do you mean explicitly?
06:47:42 <hexagoxel> rhaps0dy: explicitly.. sure :D
06:48:19 <rhaps0dy> hpc: I thought the generated code was too different from Haskell to be explicitly done
06:48:31 <rhaps0dy> hexagoxel: mind showing me your code, pretty please?
06:48:58 <skuggi> Jefffrey: you even get instances from modules imported by the modules you import
06:49:07 <hexagoxel> mom
06:49:59 <rhaps0dy> hexagoxel: thank you
06:52:21 <Jefffrey> Makes sense.
06:53:32 <hexagoxel> rhaps0dy: http://lpaste.net/104282
06:54:49 <rhaps0dy> Thank youu
06:56:58 <hexagoxel> rhaps0dy: i updated the paste, had copy-paste mistakes :D
06:58:44 <rhaps0dy> You can update the same paste?
07:00:07 <rhaps0dy> interesting
07:06:26 <hexagoxel> rhaps0dy: it even shows the revisions :)
07:10:54 <rhaps0dy> hexagoxel: oh
07:11:03 <rhaps0dy> and if you don't put your name it says 'anonymous coward'
07:11:28 <hexagoxel> yep, i messed up once. that field should be cached :D
07:23:28 * hackagebot pipes-network 0.6.3 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.3 (RenzoCarbonara)
07:28:10 <jmcarthur> would be nice to add some features like this to criterion. https://blogs.janestreet.com/core_bench-micro-benchmarking-for-ocaml/
07:29:49 <heatsink> How's the upgrade to OS X Mavericks?  The new GHC doesn't work on snow leopard.
07:32:27 <agreif> what is the best practice e to use different data types which have same properties? Here is a sample: data Book = Book {width :: Int} and data Page = Page {width :: Int}. These are in the same hs file and the compiler says Multiple declarations of 'width'
07:32:48 <heatsink> Use different field names.
07:33:03 <heatsink> If you want overloaded access to width, you can define a type class for that
07:33:32 <agreif> They have no relation to each other, just the name shoud mean the same
07:33:54 <heatsink> You can call them bookWidth and pageWidth
07:34:08 <agreif> and having field names like bookWidth and pageWidth seems to be redundant naming
07:34:35 <agreif> yes sure, this wiuel be the safest for the compiler :)
07:34:43 <Algebr> So a CString is just giving me pack some hex number, how can I get a human readable string out of it?
07:34:56 <heatsink> They're in the global namespace, so think of it as how you would name a global function
07:35:20 <Cale> :t Foreign.C.String.withCString
07:35:21 <lambdabot> String -> (Foreign.C.String.CString -> IO a) -> IO a
07:35:28 <Cale> oh, right, that's the opposite way :)
07:35:36 <Cale> :t Foreign.C.String.peekCString
07:35:37 <lambdabot> Foreign.C.String.CString -> IO String
07:35:53 <agreif> ok, I understand.. Would it make a difference if I put them in separate modules? Then I would have to qualify the imports, wouldn't I?
07:36:31 <Cale> Algebr: see also everything under here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
07:36:44 <heatsink> If you put them in different modules, then you can import them qualified and use names like B.width and P.width
07:36:51 <Algebr> Cale: Nice! That worked, thanks!
07:39:06 <ReinH> Cale: hi!
07:39:51 <agreif> heatsink: thanks a lot!
07:39:59 <heatsink> np
07:45:57 <Algebr> Anyone here have experience with SDL?
07:48:31 * hackagebot happstack-server 7.3.6 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.6 (JeremyShaw)
07:55:13 <Polarina> Algebr, how can we help?
07:56:43 <Jefffrey> Hmm.
07:58:12 <Algebr> Cale: Is there like peekCInt?
07:58:21 <heatsink> It's just called peek
07:59:28 <Algebr> heatsink: I don't see any standalone peek, all have string in their name
07:59:36 <heatsink> It's in Foreign.Storable
08:01:29 <heatsink> The members of the Storable class are data types that are just a fixed-size collection of bytes, like primitive integers and floats
08:02:06 <Algebr> =/ , peek expects a Ptr, but I have a CInt
08:02:08 <deweyvm> is there a nice way to write \f -> f x y
08:02:12 <heatsink> It's possible to read them from memory at an address (peek) and write them to memory at an address (peek).
08:02:25 <Algebr> and CInt is a newtype, not something that is an instance of Ptr, it seems
08:02:42 <geekosaur> somewhere you are doing something wrong, then
08:02:47 <heatsink> Yes.  The peek* functions are for reading from a pointer
08:02:55 <Algebr> so what is poke?
08:03:01 <heatsink> Poke is for writing to a pointer
08:03:16 <heatsink> If you have a CInt, then you don't need peek.  What do you want?
08:03:19 <geekosaur> the second "(peek)" above should have been "(poke)"
08:03:21 <Algebr> I want to know what the Int is
08:03:30 <geekosaur> uh
08:03:30 <heatsink> Use fromIntegral
08:03:43 <heatsink> It converts between different integral types
08:04:03 <Algebr> heatsink: CInts count as integrals?
08:04:08 <heatsink> yes
08:04:47 <Algebr> Oh, i'm a dumbass, the newtype says GHC.Int.Int32 for CInt
08:05:51 <scarves> Heyho :)
08:06:21 <Polarina> Hello, scarves.
08:06:36 <scarves> I have a quite CPU-intensive one-liner running in ghci... How can i make it run on more than one core?
08:08:50 <scarves> Question: I have a quite CPU-intensive one-liner running in ghci... How can i make it run on more than one core?
08:09:24 <hpc> scarves: take a look at par and pseq for making pure code more parallel
08:09:25 <Iceland_jack> scarves: Long answer: http://chimera.labs.oreilly.com/books/1230000000929
08:09:38 <Iceland_jack> if it's pure you can use Par or what hpc said
08:09:45 <heatsink> Yes, that book probably contains the answer :)
08:09:47 <hpc> there's many ways to do it
08:10:16 <heatsink> First you need to find parts of the work that can run independently
08:10:46 <heatsink> and that take at least 500 microseconds to compute
08:13:41 <Algebr> how can I pass just unit for when's last argument?
08:14:05 <heatsink> Why would you want to do that?
08:14:30 <Iceland_jack> Just unit? You can always do
08:14:31 <Iceland_jack>     when cond (return ())
08:14:31 <Iceland_jack> but that's pointless
08:14:31 <heatsink> in one case, do nothing; otherwise, do nothing?
08:14:36 <Algebr> because I don't want anything to happen depending on the boolean condition
08:15:13 <Algebr> when (something isn't 0) (do something) (else don't do anything)
08:15:30 <Iceland_jack> Are you maybe looking for 'unless'?
08:15:32 <Iceland_jack> @ty unless
08:15:34 <lambdabot> Monad m => Bool -> m () -> m ()
08:15:42 <Iceland_jack> @src unless
08:15:42 <lambdabot> unless p s = if p then return () else s
08:15:48 <Algebr> ah, will try that.
08:16:08 <Iceland_jack> Compare the definition of 'when'
08:16:08 <Iceland_jack> @src when
08:16:08 <lambdabot> when p s = if p then s else return ()
08:16:15 <heatsink> unless just reverses the sense of the boolean condition
08:18:09 <hvr> anyone here experienced with the paper "Dependently Typed Programming with Singletons"?
08:18:41 <Polarina> Is there a typeclass similar to Enum, but only deals with conversion to and from integers?
08:19:01 <agreif> Is it possible to pattern match on a field in a data record? Eg. if I have a data Gender = Female | Male and a data Person = Person { gender ::  Gender } so that a function foo :: Person has separate definitions for the Female and Male gender cases?
08:19:36 <Cale> agreif: f (Person { gender = Male }) = ...
08:19:45 <Cale> Or simply  f (Person Male) = ...
08:19:59 <benzrf> jjjjjjjjjjjjjjj
08:20:01 <benzrf> crud
08:20:14 <agreif> Cale: ok, I will try it, thanks
08:21:06 <benzrf> agreif: "Foo {t :: T, t' :: T'}" is 100% identical to "Foo T T'" except for defining t and t' and allowing record syntax
08:21:17 <benzrf> agreif: that is to say, you can do anything with the former that you can with the latter
08:21:49 <scarves> To continue/extend my question: i have the following one-liner running in ghci: head $ dropWhile (\x -> snd x < 501) $ map (\x -> (x, length [d | d <- [1..x], mod x d == 0])) $ map (\x -> div (x*(x+1)) 2) [1..] \n How can i make it run on more than one core?
08:22:51 <Iceland_jack> scarves: You need to find parts of it that can run independently like heatsink said
08:23:19 <heatsink> scarves: You can parallelize some of the list traversal functions.  However, it looks like you can make it faster by simplifying the algorithm.
08:24:04 <heatsink> [d | d <- [1..x], mod x d == 0] generates and skips a lot of numbers
08:24:20 <heatsink> There should be a way to make it generate only the numbers you want
08:24:21 <scarves> heatsink: That sounds like work :( :D Btw.> I'm trying to solve http://projecteuler.net/problem=12
08:24:30 <benzrf> i always forget that list comps exist
08:25:22 <heatsink> scarves, keep in mind that Project Euler questions are designed so that the brute-force solution is too slow
08:25:30 <Algebr> Are list comp really monads?
08:25:34 <Algebr> since they are lists.
08:25:37 <heatsink> so that you need to consider how to design the algorithm
08:25:53 <Iceland_jack> Algebr: Lists are monads, list comprehensions are a specialized version of monad comprehensions
08:25:56 <c_wraith> Algebr: list comprehensions are syntax.  syntax does not have the right kind to be monads.
08:26:39 <scarves> That sounds like thinking :D :( I'll give it a go again later... Now it's time for beer (hanging out at university :P) Thanks to you all nontheless :)
08:26:42 <Iceland_jack> ghci> :set -XMonadComprehensions
08:26:42 <Iceland_jack> ghci> [ x + y | x <- Just 5, y <- Just 10 ]
08:26:42 <Iceland_jack> Just 15
08:26:56 <Iceland_jack> So many emoticons :)
08:27:26 <Iceland_jack> yes making something with a parallel structure isn't too painful in Haskell
08:27:49 <jophish> What could be good symbols for 'input' and 'output'? : (>::) and (::>)
08:27:50 <Iceland_jack> but regardless of the language you need to restructure your algorithm if it has dependencies
08:29:02 <c_wraith> jophish: that isn't a good pairing of symbols, because : counts as capitol.  One starting with : and one not, eww
08:29:51 <jophish> c_wraith: would that matter?
08:29:53 <Iceland_jack> jophish: What's the context? Please don't introduce new operators without a good reason
08:30:08 <Iceland_jack> jophish: It would matter, identifiers starting with : are constructors
08:30:12 <c_wraith> jophish: it means they're not the same syntactically
08:30:37 <jophish> This is a type constructor of kind Nat -> * -> *
08:30:57 <Iceland_jack> So you're working on some kind of a shell/scripting dsl
08:31:05 <c_wraith> if it's a constructor, it needs to start with :
08:31:24 <jophish> Iceland_jack: not exactly, inputs and outputs for graphics shaders
08:31:44 <jophish> c_wraith: ah, I did not know that
08:31:45 <heatsink> (:↣:) (:↢:)
08:32:15 <Iceland_jack> Huh, it seems very similar to
08:32:15 <Iceland_jack>     n< and n>
08:32:15 <Iceland_jack> for some n ∶ FileDescriptor
08:32:40 <jophish> Iceland_jack: yeah, It's not too different
08:32:41 <Iceland_jack> I would probably advise against it though
08:33:09 <jophish> for a shader there are inputs and outputs on different channels (identified with a natural number)
08:33:13 <jophish> also uniforms
08:33:14 <heatsink> You can define the operator as a type synonym, then it doesn't have to start with colon
08:34:06 <jophish> I was hoping to have some symmetric looking pair for input/output, and something in the middle for uniforms
08:42:12 <Algebr> How can I check for a null pointer? I have an object which is a GHC.Ptr.Ptr, but doing nullPtr <myObject's Type> doesn't work, nullPtr being from Foreign.Ptr
08:42:23 <heatsink> :t nullPtr
08:42:25 <lambdabot> Not in scope: ‘nullPtr’
08:42:37 <heatsink> I think nullPtr is a pointer
08:42:50 <heatsink> yes
08:42:59 <c_wraith> should (== nullPtr) work?
08:43:02 <heatsink> yes
08:43:59 <Algebr> yay, that worked
08:45:46 <Algebr> Does C's NULL always point at the same memory location? Is that just by convention?
08:45:53 <heatsink> yes
08:46:18 <Algebr> what spot is that? something like 0x00000?
08:46:25 <heatsink> The convention is that integer 0 can be converted to NULL
08:47:24 <davd> Algebr: no, it doesn't point to a well-defined location since dereferencing is undefined.
08:47:41 <Algebr> So then what is NULL anyway?
08:47:42 <davd> (I'm talking about c+11 nullptr and NULL)
08:47:50 <heatsink> NULL is a distinguished pointer value
08:48:04 <heatsink> C is designed to allow different implementations of pointers and integers
08:48:13 <Algebr> but where does NULL point to?
08:48:14 <heatsink> so it doesn't prescribe a specific value
08:48:16 <Algebr> ph
08:48:17 <Algebr> oh
08:48:33 <q66> <Algebr> So then what is NULL anyway? << in C, it's (void*)0, in C++ it's just 0
08:48:34 <heatsink> In all the implementations I know about, NULL is zero
08:48:35 * hackagebot clckwrks-plugin-media 0.6.8 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.8 (JeremyShaw)
08:48:37 * hackagebot clckwrks-plugin-bugs 0.7.3 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.3 (JeremyShaw)
08:48:42 <davd> it compares equal to itself, that's about it
08:49:10 <Algebr> so then what does ghc look for when asking for the null pointer? Whatever gcc would look at?
08:49:46 <calsaverini> I'm trying to install cabal-install-1.20 after installing haskell platform in a fresh ubuntu install and I'm having some problems. Does anyone knows why Cabal fails to compile in this situation? It gives me an: "ghc: out of memory (requested 2097152 bytes)
08:49:46 <calsaverini> Failed to install Cabal-1.20.0.0
08:49:47 <calsaverini> cabal: Error: some packages failed to install:
08:49:47 <calsaverini> Cabal-1.20.0.0 failed during the building phase. The exception was:
08:49:47 <calsaverini> ExitFailure 1
08:49:49 <calsaverini> "
08:50:11 <calsaverini> does anyone knows what's happening?
08:50:20 <calsaverini> the cabal version installed in the machine is 1.16
08:51:09 <heatsink> calsaverini: To get more information try building the package using cabal unpack Cabal; cd Cabal*; cabal configure; cabal build
08:52:55 <heatsink> Algebr, Libraries are built against a specific C ABI.  Implementation-specific details would be determined when the library is compiled.
08:53:11 <heatsink> That includes the representation of pointers.
08:53:13 <Algebr> heatsink: What is ABI?
08:53:19 <heatsink> Application binary interface
08:53:36 <heatsink> It's the specification of how object code behaves
08:55:08 <patrek_> is it possible to override the tuple syntax, for example by using RebindableSyntax extension?
08:56:12 <awestroke> patrek_: that sounds horrific
08:56:55 <Iceland_jack> patrek_: You would be better of creating a type class for syntactic sugar over it
08:57:32 <patrek_> awestroke: why? if you are embedding a language with products, it seems natural to override the tuple syntax. List syntax is overridable these days
08:57:42 <Iceland_jack> patrek_: http://www.cse.chalmers.se/~josefs/publications/TFP12.pdf
08:57:57 <Iceland_jack> If you're embedding a language that seems like what you want
08:59:33 <jophish> heatsink: I think that (:>:) and (:<:) are pretty nice (modulo unicode shenanigans)
08:59:44 <jophish> Is it clear which is "Input" and which is "Output"
09:00:29 <jophish> (:>-:) and (:->:) may be better
09:00:33 <heatsink> To me they look analogous to >>= and =<<
09:00:48 <heatsink> that is, data flows right or left
09:01:05 <Algebr> What is the pipe symbol in C++ do?
09:01:08 <Algebr> does*
09:01:14 <jophish> Algebr: bitwise OR
09:01:15 <heatsink> bitwise or
09:01:30 <Algebr> ah, thanks
09:01:31 <jophish> I was hoping to use them like Vinyl
09:01:51 * heatsink knowsn't Vinyl
09:01:56 <jophish> myInput = Input :: 5 :>: Float
09:02:10 <jophish> so myInput is an input of type float on channel 5
09:03:10 <jophish> myOutput = Output :: 0 :<: V4 Float, and myUniform = Uniform :: "uniformName" ::: Bool
09:03:49 <heatsink> okay
09:03:50 <Athas> Anyone up for painting a bikeshed?  Should my new module be named "Optimise", "Optimiser", or "Optimisation"?
09:03:59 <hpc> Athas: what's the module?
09:04:12 <davd> Athas: Optimize
09:04:14 <Athas> hpc: an umbrella module for various optimisations.
09:04:14 <davd> :)
09:04:22 <hpc> optimizations for what?
09:04:44 <heatsink> @dice 1d3
09:04:44 <lambdabot> heatsink: 1
09:04:45 <Athas> A functional-languge compiler eventually targeting GPGPU.
09:04:55 <Athas> So... traditional stuff.  Fusion, strength reduction, tiling...
09:05:05 <hpc> i think i would have Optimization, then
09:05:16 <heatsink> That wasn't one of his options, hpc
09:05:19 <hpc> if your structure is going to be Optimization.Fusion, Optimization.Tesselation, etc
09:05:24 <hpc> heatsink: :P
09:05:41 <Athas> hpc: yes, I do think that would read the best.
09:05:45 <hpc> or Optimize if you are going to put it under the individual modules
09:05:54 <hpc> Tesselation.Optimize, Fusion.Optimize, etc
09:06:03 <hpc> but i like the first better
09:06:22 <Athas> I don't call the parser module "Parse", though, so it would be inconsistent.
09:06:35 <Athas> I wonder what GHC does.
09:07:09 <Athas> Verbs, apparently.  (So "Optimise".)
09:07:29 <Athas> I will do that as well, then.
09:08:07 <heatsink> GHC has a flat module namespace tho
09:09:04 <calsaverini> heatsink: strange, I'm able to build Cabal-1.20 using your instructions but when I just issue a "cabal install Cabal", it fails mid compilation with that "out of memory" error
09:09:45 <heatsink> That is strange
09:09:58 <Athas> heatsink: yeah, but it's directories are verbs.
09:10:01 <heatsink> I don't know what to do about that, hopefully someone else here knows
09:10:30 <heatsink> Athas: GHC has directories called 'parser', 'profiling', and 'specialise'
09:10:35 <heatsink> not consistent
09:10:43 <ReinH> Athas: it should be named any of those with s/s/z :D
09:11:21 <ReinH> calsaverini: have you tried turning it off and back on again? ;)
09:11:26 <ReinH> darn
09:11:27 <EvanR> module Introspectively
09:11:28 <heatsink> calsaverini: You could also ask at #haskell-infrastructure since it's cabal related
09:11:36 <c_wraith> calsaverini: how much memory does your system have?  ld is not good at linking ghc-generated object files
09:11:45 <ReinH> (he left)
09:11:58 <Athas> heatsink: and deSugar, codeGen, vectorise...
09:11:59 <c_wraith> no wonder tab complete wasn't working
09:12:06 <Athas> The verbs seem to have a plurality.
09:12:22 <Athas> ReinH: have no fear, my advisor uses American English, so we will no doubt end up with both!
09:12:30 <ReinH> Athas: :D
09:13:34 <heatsink> I see
09:16:07 <Taneb> Does Chris Taylor (who did the algebraic data types talk) ever come in here?
09:27:32 <EvanR> heh
09:27:47 <EvanR> if i have a value of type forall a. A a
09:28:19 <EvanR> i can get a value of type A (), or A B, or whatever just put putting an explicit type annotation
09:28:30 <EvanR> just by*
09:29:33 <vanila> EvanR, that's right, type application is implicit
09:30:44 <EvanR> i just read about type application
09:30:49 <EvanR> head explode
09:33:30 <davd> ReinH: any updates on haskellcast? :)
09:33:42 <ReinH> davd: guess what we literally just finished recording :D
09:34:02 <davd> aaaaawww yes! I'm super happy!
09:34:16 <ReinH> me too!
09:39:20 <ditzy> hi there ^_^. I was hoping someone could help me with some problems I'm having with the 'persistent' package. I'm following the Yesod book (http://www.yesodweb.com/book/persistent) but when I try to build I get an error. My source and error are here: http://lpaste.net/104286
09:40:01 <ditzy> this is my first foray into a lot of different Haskell things all at the same time, so I have no idea what could be going wrong, but I copied that code directly out of the book
09:40:15 <jophish> jonsterling: What's the smallest list of extensions one could implement Vinyl with. Could it be done without GADTs and RankNTypes?
09:40:51 <jonsterling> It might be possible to do it with a finally tagless approach?
09:40:58 <atohs> is there a way to create a tuple using prefix notation?
09:40:59 <ditzy> I'm wondering if maybe it could be a misuse of cabal, since this is both my first time using a cabal file and a cabal sandbox. But all I've done is run `cabal init` and entered in the defaults for most things
09:41:15 <barrucadu> ditzy: What is the error you get?
09:41:17 <jmcarthur> atohs: (,)
09:41:17 <glguy> Ditzy try adding a space to line 11 so it is indented a bit
09:41:56 <ditzy> barrucadu: it's an indentation error at the bottom of the paste
09:42:06 <barrucadu> Oh, sorry, missed that
09:42:19 <Iceland_jack> > (,) False ()
09:42:20 <ditzy> glguy: the error changes to "parse error on input `deriving'"
09:42:20 <lambdabot>  (False,())
09:42:23 <jophish> jonsterling: what do you mean by 'finally tagless'?
09:42:41 <jophish> DataKinds are no problem, so the fields could still be tagged
09:42:45 <atohs> ha! nice
09:43:00 <atohs> thanks
09:43:01 <jophish> likewise for syntactic things like TypeOperators
09:43:23 <glguy> Ditzy that is progress, then
09:43:34 <jonsterling> I believe there is a paper with that term in the title. Maybe by ccshan?
09:43:40 * hackagebot aivika 1.2 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-1.2 (DavidSorokin)
09:44:17 <jophish> I'll give that a look, Thanks
09:44:28 <ditzy> glguy: one thing that worries me is that it's a literal copy/paste from the book. The whole file is, except for "module Main where"
09:45:01 <atohs> lesson learned: when one is doing a lot of work to accomplish something hard, he is probably doing it wrong :)
09:45:03 <awestroke> http://lpaste.net/4101844340643463168 what?
09:46:50 <Algebr> Why are CString tagged as IO? Is anything that is outside of the haskell code running considered automatically IO?
09:46:53 <jonsterling> jophish: Here's the paper: https://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf
09:47:08 <jonsterling> Shows how to get the power of GADTs without GADTs.
09:47:32 <ditzy> one thought I had is that it's a version problem. I think the book may be using persistent-0.6, but the current version is 1.3.1.1, which is what I'm using. But I guess if that's the problem then I'm kind of stuck for now because I wouldn't know how to figure out the new syntax
09:47:51 <awestroke> nvm
09:47:58 <Jefffrey> Evening
09:48:18 <heatsink> Algebr: Foreign data is generally mutable, so it requires IO for ordering
09:48:56 <Maior> ditzy: I've missed context, but if you're talking about RWH, some of the libraries used are known-old
09:49:12 <Algebr> heatsink: What's the connection with ordering?
09:49:15 <heatsink> Algebr: Also, CString memory management is explicit so it requires IO to control when it's freed
09:49:32 <EvanR> reading this paper about singletons, i think its funny they used to phrase "singletons design patterns"
09:49:40 <heatsink> Algebr: When you read mutable data, you want to see the value that was written most recently
09:49:51 <heatsink> That requires putting all the reads and writes in a specific order
09:49:52 <EvanR> maybe in an effort to stamp out the original usage ;)
09:50:01 <glguy_> Maior: He's talking about the Yesod book afaict
09:50:02 <jophish> jonsterling: thanks for the link. I'll put it on the reading queue
09:50:05 <Algebr> heatsink: So ghc's garbage collector will take care of free the memory for the C objects?
09:50:14 <ditzy> Maior: not sure what RWH is, but I'm talking about the 'persistent' libraries for database abstraction. I'm trying to follow the Yesod book and can't compile the examples
09:50:15 <heatsink> No
09:50:36 <heatsink> You use functions like freeCString or withCString to free memory
09:51:02 <Algebr> heatsink: Why can't ghc do it for me? Technical limitation?
09:51:29 <EvanR> C code cant be precisely garbage collected
09:51:40 <heatsink> Algebr: CString is for strings that are shared with foreign code.  GHC doesn't know what the foreign code is doing, so it can't manage it by garbage collection
09:53:04 <Algebr> Can't ghc do some kind of reference counting? So when I'm making a CString, its not like its actually in haskell land, its outside of haskell land and I'm just getting a handle on it? Does that mean that there's like a separate heap just for foreign data?
09:53:49 <heatsink> That's what StablePtr is for
09:53:59 <heatsink> I mean ForeignPtr
09:54:06 <EvanR> Algebr: yes
09:55:45 <Algebr> So presumably when the haskell program ends, its the rts's responsiblity to close out that separate C heap?
09:56:45 <heatsink> When you use the Foreign.C library for memory allocation, it goes through the C functions malloc and free.
09:57:45 <heatsink> That heap is shared with C.  You can't distinguish those objects by which language allocated them.
09:58:12 <awestroke> what does this mean? https://gist.github.com/awestroke/69456643fef238743aa8
09:58:32 <monochrom> actually not all of Foreign.C does. but the ones called "mallocXXX" certainly do.
09:58:44 <ditzy> I have to go, but thanks for the help. I'll try to poke around at some stuff a bit more later, and maybe I can ask some more questions then too. Thanks again ^_^
09:59:29 <jmcarthur> Algebr: There's no additional responsibility for the RTS to clear out the C heap upon exit. The OS does it anyway.
09:59:32 <monochrom> the ones called "allocaXXX" and "withXXX", it makes no different where the block of memory comes from, therefore GHC takes liberty to not ask C.
09:59:47 <EvanR> jmcarthur: except for shm, i was just thinking ;)
09:59:52 <heatsink> Huh, I didn't know that
09:59:52 <jmcarthur> Algebr: the C heap is not really some separate object in memory, but just stuff that isn't in the managed heap
09:59:57 <monochrom> why not ask C. because C is SLOW! XD
10:00:12 <jmcarthur> EvanR: well, you wouldn't have created that with FFI malloc anyway
10:00:19 <EvanR> no
10:01:07 <EvanR> but i was thinking, is it true that "if the process ends, all the memory it was using is collected by the OS whether or not any explicit cleanup occurred.." not really a haskell issue though
10:01:48 <heatsink> awestroke, It says that the MonadState methods aren't implemented for StateT
10:02:01 <heatsink> Oh wait
10:03:23 <heatsink> yes, that's right
10:04:20 <heatsink> awestroke: You need to import a different package if you want to use MonadState methods with StateT
10:04:37 <heatsink> Link with a different package, rather
10:05:19 <monochrom> version numbers showing up in a type error implies possessing multiple versions to confuse GHC
10:05:46 <monochrom> the solution is kill all non-original versions.
10:15:07 <mcbears> question, how does GHC implement records? (namely, what are the running times for lookup and modification)
10:15:08 <Deewiant> (For the record, a probable solution to ditzy's problem would have been to put the LANGUAGE pragmas before the module declaration.)
10:15:18 <mcbears> I figure it's either an array thing or a nested tuple thing
10:16:34 <coppro> records are just syntactic sugar
10:16:35 <monochrom> it is an immutable array thing.
10:16:53 <mcbears> alrighty thanks
10:17:42 <mcbears> i guess by records I just meant products
10:19:22 <c_wraith> yeah, GHC allocates a short array of thunks for each argument to the constructor.
10:19:40 <c_wraith> Technically, they're mutable, as they're thunks.
10:19:59 <c_wraith> But not in a way that's observable to GHC-generated code, unless it's using unsafe operations.
10:20:14 <EvanR> they are mutable only once ;)
10:20:20 <c_wraith> That's not actually true.
10:20:22 <EvanR> oh
10:20:31 <mcbears> oh my
10:20:38 <c_wraith> There is a short window for multiple evaluation of a thunk in the case of concurrency
10:20:46 <EvanR> ah right
10:20:55 <EvanR> scary
10:20:56 <c_wraith> But because of purity, that just means duplicated work, not inconsistent results.
10:21:12 <c_wraith> ...  Unless your code was impure, then things get scary.
10:21:29 <monochrom> unsafe things are, of course, scary :)
10:21:40 <c_wraith> This is why you need to know what you're doing when you use unsafe functions!
10:21:58 <monochrom> and also what GHC is doing
10:22:06 <c_wraith> yes, that too
10:22:54 <monochrom> the Dunning-Kruger effect implies that the whole thing is hopeless. people who don't know will think that they know.
10:23:54 <c_wraith> Fortunately, users of the hackage ecosystem are usually pretty good at saying "this is broken, fix it" or "this is broken, don't use it", depending on the audience.
10:26:31 <halvorg> Hey, using parsec I have this sub function that parses a string of length L. I want to do this until the parse fails (end of a list), how do I do that?
10:27:43 <c_wraith> halvorg: look at the parsers with names like many*
10:28:03 <monochrom> what is the type of your sub function?
10:28:26 <monochrom> nevermind, it's parsec, what c_wraith says.
10:28:58 <halvorg> I've been using many, but it crashes when it cant parse any more
10:29:03 <halvorg> I'll try some other many* funcs.
10:29:34 <c_wraith> If it fails to parse, it implies that what you parse after the many doesn't match
10:29:34 <monochrom> it doesn't crash on me. what is "crash" anyway?
10:30:15 <c_wraith> Or it might imply a failure with lookahead committing.
10:30:20 <halvorg> manyTill works. thanks
10:30:22 <MagneticDuck> anybody here use syntastic + hdevtools?
10:30:33 <halvorg> well crash as in parse failure, but it works now : )
10:31:14 <MagneticDuck> for some reason I can't figure out how to get the hdevtools syntax checker definition file (generally in ~/.vim/<bundle if using pathogen>/syntastic/syntax_checkers/hdevtools.vim)
10:31:21 <EvanR> heh, Nothing value is a crash now
10:31:22 <EvanR> i wish
10:31:26 <MagneticDuck> perhaps somebody could send it here? x|
10:32:07 * MagneticDuck checks syntastic git repo to make sure he didn't delete it locally or something
10:32:40 <MagneticDuck> never mind, problem solved
10:37:50 <MagneticDuck> note: it seems that the latest hdevtools from hackage does not compile
10:37:57 <MagneticDuck> can somebody confirm? I updated everything
10:39:50 <MagneticDuck> idea: does hackage automatically check uploaded packages for compile feasibility or act in function of whether a package is broken?
10:40:19 <heatsink> Hackage compiles uploaded packages and creates a build report
10:40:42 <MagneticDuck> kk
10:40:44 <MagneticDuck> cool
10:40:52 <heatsink> Here's how to see the build report http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
10:41:23 <MagneticDuck> also, it seems that hdevtools... hangs when I ask it to check a source file?
10:41:32 <MagneticDuck> strange, never did that in the past
10:43:34 <suppi>  zeal
10:48:16 <EvanR> in lieu of dependent types, maybe a saner way to ensure correctness is to reduce the scope of what correct is for a given app
10:48:45 * hackagebot chell 0.4 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.4 (JohnMillikin)
10:48:47 * hackagebot chell-quickcheck 0.2.4 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2.4 (JohnMillikin)
10:48:49 * hackagebot chell-hunit 0.2.1 - HUnit support for the Chell testing library  http://hackage.haskell.org/package/chell-hunit-0.2.1 (JohnMillikin)
10:53:46 * hackagebot dbus 0.10.8 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.8 (JohnMillikin)
11:03:10 <romildo> In order to compile encoding-0.7 with ghc-7.8.2 I have applied the patch https://gist.github.com/anonymous/861e989b405b8082cdb8
11:03:38 <romildo> But compilation fails with the error:
11:03:39 <romildo> Data/Static.hs:39:0:
11:03:40 <romildo>      error: missing binary operator before token "("
11:03:40 <romildo>      #if MIN_VERSION_base(4,7,0)
11:03:40 <romildo>      ^
11:04:04 <romildo> Why the preprocessing directive is not being accepted?
11:04:13 <heatsink> Is the CPP extension enabled?
11:04:34 <romildo> Yes, it is enabled in the encoding.cabal file
11:05:09 <romildo> http://code.haskell.org/encoding/encoding.cabal
11:05:37 <romildo> which contains the line:
11:05:39 <romildo> Extensions: CPP
11:05:45 <EvanR> haha ghci says "<interactive>:3:6: My brain just exploded"
11:06:12 <heatsink> Maybe MIN_VERSION_base isn't a 3-parameter macro
11:07:18 <heatsink> Do you know where it's defined?
11:08:20 <romildo> no
11:08:51 <heatsink> Oh, it's created by Cabal
11:09:59 <dwcook> Where can I read a description of the algorithm used to derive a Functor instance with the DeriveFunctor extension?
11:10:26 <heatsink> It goes into an autogenerated header file, so check the definition of the macro in dist/build/autogen
11:11:00 <dwcook> Never mind, found http://www.haskell.org/pipermail/haskell-prime/2007-March/002137.html right after posting that.
11:18:48 * hackagebot apiary 0.5.1.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.5.1.0 (HirotomoMoriwaki)
11:21:39 <EvanR> existential only works with data, not newtype?
11:23:49 * hackagebot apiary-cookie 0.5.1.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.5.1.0 (HirotomoMoriwaki)
11:38:50 * hackagebot numeric-qq 0.1.1 - Quasi-quoters for numbers of different bases  http://hackage.haskell.org/package/numeric-qq-0.1.1 (NikitaVolkov)
11:43:21 <monochrom> romildo: is this on Mac OS X?
11:44:55 <romildo> monochrom, no, it is on gentoo Linux.
11:45:06 <effy_> i've been looking on coursera edx and udacity without any luck so far, is there a mooc using haskell somewhere out there ?
11:45:23 <saml_> mooc?
11:45:35 <heatsink> massively online cource
11:45:47 <effy_> online class with like video material, and weekly exercises
11:45:54 <saml_> massively much fun
11:46:06 <monochrom> FPComplete may have one
11:46:11 <heatsink> There was a Scala MOOC
11:46:15 <saml_> i bet there are haskell courses with syllabus online
11:46:23 * bennofs thinks --max-backjumps=-1 shuld be a cabal default
11:46:25 <effy_> heatsink: yeah i did it :)
11:46:26 <`Jake`> Does isAlpha contain greek letters?
11:46:30 <bennofs> Why is that not the default?
11:47:15 <hpc> `Jake`: it uses whatever unicode defines a character as
11:47:19 <hpc> (so yes)
11:47:23 <`Jake`> hpc: thanks
11:50:43 <effy_> monochrom: fpcomplete seems to have only textual blog posts kind of material
11:51:08 <effy_> i'd like something more structured, more like attending a class at the university if that's possible
11:55:41 <monochrom> Yorgey has a course at http://www.seas.upenn.edu/~cis194/lectures.html . there is no video.
11:56:12 <perebor> is it possible to use zipWith with tuples? or is that something you wouldn't want to do
11:56:18 * monochrom finds today's video interface to be unnavigatible, therefore impedes agile learning anyway
12:02:35 <bvad> Evening, I'm in need of a reality check: I've been learning Haskell and FP in general over the last 6 months or so, and I was wondering if it's completely insane to start doing a sort of 2D platformer in Haskell and SDL as a learning experience? It doesn't necessarly has to ever get finished, I'd just like to actually put something on the screen for once!
12:03:20 <vanila> i think that's a good idea
12:03:26 <Polarina> bvad, it's not an insane idea. Just start small.
12:04:02 <Polarina> There's always the urge of setting oneself more ambitious plans than can be realistically achieved.
12:05:54 <benzap> bvad: from personal experience, i've found that Project Euler provided the best way to introduce my self to functional programming
12:05:55 <bvad> Sounds good, I'll start out with something really basic of course :) I really don't find "yet another TODO web app" to be that interesting.
12:05:59 <mzarella> Monads give you something effects won't, what is it? Names and a way to step through the computation?
12:06:07 <benzap> https://projecteuler.net/
12:06:10 <bvad> benzap: I'm actually doing Project Euler as we speak :)
12:06:15 <benzap> oh nice
12:06:42 <bvad> benzap: But I'd like to also do a more complete application, not just small programs
12:07:35 <benzap> yeah, that's where I am right now :)
12:07:43 <brisbin> i just found myself writing eitherToMaybe for the second time, does something (perhaps more generic) exist to do that?
12:08:26 <DogeHayashi> ISTR there might be something in Lens for converting Either () x to Maybe x, but that's probably overkill
12:08:29 <effy_> john carmack gave a talk about how he was poking at haskell (and fp in general) and how it would allow him to make game engines that would scale to multiple cpu
12:08:34 <vanila> :t either (const Nothing) Just
12:08:36 <lambdabot> Either a a1 -> Maybe a1
12:08:42 <brisbin> yes, that is what i've written
12:08:57 <benzap> effy_: I heard differently, was this a more recent talk?
12:08:59 <bennofs> @ty Data.Foldable.head
12:08:59 <bvad> effy_: I actually watched that talk when it got posted to youtube, very interesting
12:09:00 <lambdabot>     Not in scope: ‘Data.Foldable.head’
12:09:00 <lambdabot>     Perhaps you meant ‘Data.Foldable.fold’ (imported from Data.Foldable)
12:09:02 <bennofs> :|
12:09:32 <effy_> benzap: oh, would i have miss-understood? what was his point in your opinion?
12:09:49 <bvad> benzap: I think he did another talk later on where he talked about some of the drawbacks he discovered later on
12:09:50 <benzap> I watched some quakecon talk where he said bad things about functional programming
12:10:01 <benzap> yeah bvad
12:10:07 <bvad> benzap: That's the newer one yeah
12:10:18 <effy_> so i guess i saw only the old one
12:10:28 <Polarina> What were the drawbacks?
12:10:29 <effy_> gonna go watch the newer one then if i can put my hands on it
12:10:42 <benzap> i think it was the '13 talk
12:10:45 <benzap> I don't remembner
12:10:46 <bennofs> msg:t headOf _Just
12:10:49 <bvad> Polarina: I can't quite remember, but I'll see if I can find the video for you
12:10:53 <bennofs> :t preview _Right
12:10:54 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
12:11:05 <bennofs> the lens way :)
12:11:11 <Polarina> bvad, much appreciated.
12:11:23 <brisbin> bennofs: ah interesting, thank you
12:11:55 <bvad> Polarina: https://www.youtube.com/watch?v=1PhArSujR_A I think this is the first one, looking for the second one now
12:12:22 <bennofs> or if you like infix, you can also write it nas
12:12:25 <benzap> I recall him saying, it was difficult to correct a type
12:12:30 <bennofs> :t (^? _Right)
12:12:33 <lambdabot> Either c b -> Maybe b
12:12:34 <aoeu> Is there such a thing as a web/REST ORM?
12:12:46 <mzarella> Monads give you something effects won't, what is it? Names and a way to step through the computation?
12:12:46 <DogeHayashi> a WORM
12:12:48 <DogeHayashi> if there isn't
12:12:50 <effy_> bvad: yeah that's the one i saw, he seemd totally positive about fp in this one
12:12:50 <DogeHayashi> someone should make it
12:12:55 <DogeHayashi> just because that acronym is awesome
12:13:32 <bvad> I can't seem to find the other one..
12:14:09 <vanila> mzarella, effects is just one type of monad - you can have nondeterminism monads too
12:16:04 <brisbin> The module is suitably generic, but may not be widely useful.
12:16:11 <brisbin> sorry, paste fail
12:17:35 <Philonous> mzarella, "Monad" is just an interface to work with certain data types. Many of those types can be interpreted as some sort of typed effect.
12:22:35 <Philonous> mzarella, The operand phrase is "interpreted as". There is nothing inherently effectful about monads. But the Monad interface fosters a style the is reminiscent of imperative programming.
12:22:45 <benzrf> sup haskell people
12:23:00 <zzing> Is the Hutton book still relevant for learning?
12:23:15 <`Jake`> I just came across my first occurence where   f C = C   compiles but    f c@C = c doesn't. I didn't know that was possible before, but it does make sense.
12:23:24 <bvad> benzrf: Writing a report on a Scala application, having to pretend I don't prefer Haskell.. Sup with you?
12:23:30 <`Jake`> Maybe it wasn't the first occurence, and I just never noticed it before
12:23:51 <benzrf> bvad: tryna understand why Setting in lens uses Profunctor instead of just ->
12:23:54 <benzrf> :t over
12:23:56 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:24:21 <hpc> `Jake`: fmap on Maybe is a place where that's true
12:24:27 <Philonous> `Jake`, I often have that problem with something like «f (Left e) = Left (text.Pack e); f r = r»
12:24:31 <`Jake`> hpc: Yeah, it's similar to that
12:24:31 <hpc> fmap _ f@Nothing = f -- invalid
12:26:38 <romildo> Is it possible to have both MagicHash and CPP extensions working for a module?
12:27:24 <Algebr> feeling dumb. I have something that is of type: Ptr <someObject> but can't s\
12:27:25 <Algebr>     eem to find a way to tag my object with Ptr.
12:28:36 <dwcook> Algebr: what do you mean by "tag" here?
12:29:09 <Algebr> have a type signature that expects Ptr Foo, but I just have Foo
12:29:23 <geekosaur> Algebr: somehow the way you said that makes me think you don't quite understand what's going on here
12:29:25 <dwcook> So in other words you want to obtain a Ptr Foo once you haev a Foo.
12:29:33 <Algebr> yes
12:29:41 <EvanR> &Foo
12:29:52 <Algebr> geekosaur: that's surely possible, or I'm sloppy in my wording.
12:30:03 <geekosaur> it's not a "tag", there's a lot more involved
12:30:24 <geekosaur> in particular, a Haskell value can be moved by garbage collection, so it does not have a pointer you can make use of in e.g. the FFI
12:30:50 <geekosaur> if you need such a fixed pointer, you need to do something to copy the value to pinned storage, which will give you a Ptr
12:31:14 <geekosaur> it's not just a "tag", it indicates the storage is completely different
12:31:43 <Algebr> so I need to make such a pointer and then cast it to my desired datatype?
12:32:39 <geekosaur> um, no. for one, your "desired datatype" probably is a Haskell one but you need to use a C one if you're working with the FFI (and if you're not, why are you trying to use Ptr-s?)
12:32:43 <Philonous> Algebr, It really depends on what exactly it is you are trying to do.
12:32:49 <geekosaur> it would help to know exactly what you're trying to do, yes
12:33:50 <Algebr> I'm working with SDL, one of the functions, is looking for a Ptr Rect, I can make the Rect
12:33:55 * hackagebot numeric-qq 0.1.2 - Quasi-quoters for numbers of different bases  http://hackage.haskell.org/package/numeric-qq-0.1.2 (NikitaVolkov)
12:34:15 <Philonous> Algebr, Which function?
12:34:31 <Algebr> function is renderCopy
12:34:40 <Polarina> Algebr, here's a little smoke test that I use: http://lpaste.net/104288
12:34:45 <dwcook> Rect has a Storable instance which seems relevant
12:34:49 <Polarina> Algebr, should give you an idea how to work with the Ptr's.
12:34:53 <Algebr>   :: Renderer -> Texture -> Ptr Rect -> Ptr Rect -> IO CInt
12:34:59 <Algebr> k, will look now
12:35:23 <EvanR> uhg sdl...
12:35:33 <EvanR> doesnt even work on my mac anymore
12:35:43 <ReinH> EvanR: nice job breaking it... ;)
12:36:42 <EvanR> im using glfw-b and its good, but drawing combinators produces less than desirable image quality with a lot of affine space mess
12:37:20 <EvanR> im guessing cairo would give me like 9 fps ;)
12:37:55 <Polarina> Algebr, I'm also working on making a more user-friendly API for the sdl2 library, so no one has to see any pointers ever again.
12:38:19 <EvanR> Polarina: audio?
12:38:41 <Polarina> EvanR, there's FFI for all parts of sdl2, except threads (who uses those anyway?).
12:39:02 <EvanR> no body, but i noticed a distinct lack of audio bindings to sdl 1.2
12:39:30 <Algebr> Polarina: I don't see where the pointers are in your code sample.
12:40:03 <Polarina> Algebr, you use 'alloca' then 'poke' your Rect into the Ptr Rect.
12:40:24 <Philonous> Algebr, Please note that (Ptr Rext) does not mean that there is a Rect-value stored at the address at that location. Rather, it means that the address is _somehow_ associated with Foo. "Rect" is really just a tag. However, the value can often be retrieved via it's Storable instance. You may want to read the documentation of Foreign.Storable and Foreign.Marshal.Alloc
12:41:11 <Philonous> (Ptr Rect) even
12:41:32 <Philonous> And it's associated with Rect, not Foo, of course
12:42:32 <Polarina> EvanR, I have not specifically tested the audio API myself, but if you see anything that I've missed in the bindings, let me know and I'll add them as soon as humanly possible.
12:42:42 <EvanR> nice
12:45:09 <hughfdjackson> heyhey :) simple Q - what's the defacto standard testing library - akin to the xUnits of other languages, i guess
12:45:28 <EvanR> the type system
12:45:29 <hughfdjackson> i.e. i'm looking to generate specific test cases - not so much something like quickcheck :)
12:45:38 <hughfdjackson> EvanR: i plan on using that too ;)
12:45:44 <EvanR> hunit ?
12:45:54 <Philonous> hughfdjackson, tasty / hspec
12:47:06 <hughfdjackson> Philonous: hah - hspec looks like .. pretty much what i'd use in scala or javascript :)
12:47:07 <ReinH> What's the least crappy regexp engine in Haskell atm?
12:47:22 <Philonous> hughfdjackson, You can import test cases from one into the other. So the choice doesn't really matter too much.
12:47:23 <hughfdjackson> i'll feel right at home there for the meantime - thanks a lot
12:47:23 <ReinH> Only need the regular parts if that helps
12:48:38 <epta> How to visualize dependencies tree of a particular cabal project?
12:49:40 <brrrrrrrrian> Why does a mutable vector have to be encapsulated in either IO/ST monad?
12:50:27 <EvanR> the effect has to be visible to actions that come after it
12:50:38 <EvanR> the effect of mutating the vector
12:51:31 <brrrrrrrrian> so... why not the State monad?
12:52:07 <EvanR> you can use State with the immutable arrays
12:52:27 <geekosaur> State isn't actually mutable state, it just pretends to be
12:52:47 <dwcook> State s a is as good as s -> (a, s)
12:53:08 <EvanR> the only difference is performance right
12:53:09 <dwcook> But of course the instances make it more convenient
12:53:23 <brrrrrrrrian> I have this data where I store a bunch of fields, and I have it inside State monad so I can write monadic style code.  I want to add a vector to the data record... but I don't want to have to deal with IO
12:53:32 <Algebr> Polarina: I'm still confused because Rect doesn't says its an instance of Storable,
12:53:55 <dwcook> Algebr: yes it does, the docs say so
12:54:07 <halvorg> Any quick way to print a number with atleast a number of digits? like 1 -> "01"
12:54:09 <Algebr> dwcook: but ghci doesn't when i do :i Rect
12:54:21 <dwcook> Algebr: which package are you using?
12:54:24 <Algebr> SDL2
12:54:41 <dwcook> Ah, sorry, I was looking at SDL.
12:55:14 <brrrrrrrrian> I see a stackoverflow thread where someone suggests to just use an immutable array association list style and just mutate it like you would every other field of the data inside your State monad...
12:55:44 <brrrrrrrrian> EvanR: I think that is what you said above
12:56:03 <EvanR> you probably want to do something more sane to get higher performance
12:56:25 <brrrrrrrrian> so.. what should i look out for if I am considering... IOVector versus State monad + immutable array
12:56:35 <Polarina> Algebr, it sure is an instance of Storable: http://hackage.haskell.org/package/sdl2-1.1.0/docs/Graphics-UI-SDL-Types.html#t:Rect
12:56:46 <dwcook> Algebr: http://hackage.haskell.org/package/sdl2-1.1.0/docs/Graphics-UI-SDL-Types.html#t:Rect
12:56:48 <brrrrrrrrian> EvanR: what do you mean?
12:56:54 <dwcook> Woop, beaten to the punch
12:56:59 <EvanR> brrrrrrrrian: are you reading the whole file in, or reading it incrementally and doing something with each bit
12:57:20 <brrrrrrrrian> EvanR: I am trying to simulate RAM
12:57:31 <EvanR> like an emulator?
12:57:47 <brrrrrrrrian> EvanR: I have a "Machine" data and operate on it within State monad
12:57:59 <Algebr> Polarina: That's so strange, ghci just shows Eq and Show
12:58:23 <dwcook> Algebr: what version are you using?
12:58:38 <brrrrrrrrian> EvanR: So, I want to add an array/vector to the Machine and be able to read/write to it as I operate within the State monad
12:58:42 <Polarina> Algebr, import Foreign.Storable first.
12:58:45 <EvanR> brrrrrrrrian: if you dont care about performance, you can use Map or IntMap to store address -> value of the memory
12:58:54 <Polarina> Algebr, ghci only shows instances if the class is in scope.
12:58:55 <EvanR> which would be better than a giant immutable array
12:59:20 <brrrrrrrrian> EvanR: that is what I am currently doing :) but I want to try an do better
12:59:44 <Algebr> Polarina: Yep, that worked, I never knew that about ghci, that's crappy behavior.
13:00:10 <EvanR> brrrrrrrrian: well if you use a real mutable vector in IO, itll be just like ram ;)
13:00:35 <EvanR> is that better?
13:00:46 <brrrrrrrrian> I was hoping to avoid IO
13:00:53 <EvanR> theres ST
13:01:21 <brrrrrrrrian> * to avoid IO/ST
13:01:26 <EvanR> heh
13:01:30 <EvanR> the stick with what you got
13:01:32 <EvanR> then
13:01:59 <brrrrrrrrian> why would you advise against using immutable arrays?
13:02:11 <EvanR> because it sounds like you want to mutate them
13:02:21 <mcbears> any change to an immutable array has to copy the whoole thing
13:02:27 <brrrrrrrrian> oh
13:02:41 <brrrrrrrrian> part of the reason for why Vector exists?
13:02:47 <brrrrrrrrian> but then it requires IO/ST....
13:02:53 <EvanR> immutable vector is the same way
13:03:36 <mcbears> if you want real O(1) read and update, you mostly need IO/ST
13:03:58 <brrrrrrrrian> Why doesn't Map require IO/ST ?
13:04:09 <Philonous> brrrrrrrrian, It's immutable
13:04:14 <mcbears> map is an immutable tree
13:04:27 <mcbears> so it only has to copy a logarithmic number of nodes in an update
13:04:48 <mcbears> you can use HashMap from unordered-containers, which gives log-time operations with a large base (16 or 32, I think)
13:05:05 <brrrrrrrrian> so it's lest costly than an array...?
13:05:14 <mcbears> Less for writes, more for reads
13:05:51 <brrrrrrrrian> damn
13:06:06 <mcbears> an immutable array is O(1) for indexing but O(n) for updating since it has to copy everything, while Map is O(log(n)) for both
13:06:22 <brrrrrrrrian> I am loving haskell.. but right now I just want a chunk of bits to mutate without IO/ST :)
13:06:32 <Cale> brrrrrrrrian: That doesn't make sense
13:06:35 <Cale> :)
13:06:35 <brrrrrrrrian> mcbears: I see
13:06:36 <mcbears> well haskell's pure, so there's no such thing :p
13:06:44 <silasm> brrrrrrrrian: ST still has some really nice properties.
13:06:57 <Cale> brrrrrrrrian: How big of a chunk of bits are we talking about?
13:07:10 <brrrrrrrrian> 4k bits
13:07:13 <silasm> it doesn't concede nearly as much as IO
13:07:31 <brrrrrrrrian> sorry, 4k Word16
13:07:45 <Cale> brrrrrrrrian: I'd just use Set/IntSet
13:07:47 <brrrrrrrrian> right now I am just using HashMap
13:08:07 <Cale> Is there a specific performance issue with it?
13:08:11 <brrrrrrrrian> but I am now learning that I can't really do better without dealing with IO/ST via Vector...
13:08:15 <silasm> (also, if you want to design it using State and then move to ST, that change is pretty painless in my experience)
13:08:45 <Cale> I also wouldn't start off with hashing.
13:08:46 <brrrrrrrrian> Cale: no
13:08:48 <EvanR> brrrrrrrrian: is there are reason you dont like IO, or ST, or Map, or IntMap
13:09:27 <Cale> There are costs associated with computing hash functions which really make it a toss-up whether or not you'll do better with hashed structures.
13:09:48 <Cale> Often doing the order comparisons required for plain Map/Set end up doing better.
13:09:58 <brrrrrrrrian> Yeah... I am making a lot of base-less assumptions here.
13:09:58 <Cale> ends up being faster, I should say
13:10:18 * silasm is just going to leave this here since it's mildly related http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
13:11:28 <brrrrrrrrian> 1. I don't have a performance problem, I just assume I could do better than HashMap. 2. I assume perf(HashMap) > perf(IntMap).
13:11:43 <brrrrrrrrian> 3. the C programmer in me just wants some bits
13:13:17 <Cale> brrrrrrrrian: Well, if you want a set of bits, that's more like an IntSet than an IntMap, isn't it?
13:13:39 <brrrrrrrrian> 4k Word16s
13:14:09 <Cale> So it's not a mapping from 4k Word16s to something else, it's just a set of them, right?
13:15:06 <Cale> Or do you mean that you would otherwise have a contiguous chunk of memory consisting of 4k Word16 values?
13:16:04 <brrrrrrrrian> I would like a contigous chunk of 4k Word16 values
13:16:47 <brrrrrrrrian> that would be addressable/indexable from 0 - 4k-1
13:16:58 <brrrrrrrrian> and be relatively cheap to "update/modify"
13:17:31 <Philonous> brrrrrrrrian, And why do you not like ST?
13:18:24 <brrrrrrrrian> I am not very strong with Monads, so the simpler the better
13:18:44 <brrrrrrrrian> i think I would stay with some sort of Map before trying to bring in more monads for performance
13:18:52 <brrrrrrrrian> which i cant even quantify yet
13:18:55 <silasm> brrrrrrrrian: use state for now, then, and then switch to ST. State's a decent Monad to learn with.
13:19:03 <Cale> Yeah, just try using Data.IntMap
13:19:19 <nisstyre> IntMap is pretty performant IME
13:19:53 <nisstyre> the underlying implementation is interesting too
13:20:01 <Algebr> Is the FFI language pragma still needed in ghc 7.6+? No, right?
13:20:18 <Polarina> Algebr, it is built into Haskell 2010, so no.
13:20:41 <Algebr> k, (taking a detour in rwh on FFI)
13:20:56 <Polarina> :)
13:21:17 <silasm> Algebr: rwh has a lot of things that are out of date by now from what I hear.
13:21:26 <Algebr> Polarina: Do you have any more code examples on SDL2?
13:21:40 <Algebr> silasm: yes, would be nice if it was updated.
13:22:21 <Polarina> Algebr, not at hand, no. The bindings map pretty much exactly to the C API. Examples on the sdl wiki and on the Internet should thus be useful.
13:22:49 <Algebr> Polarina: yea, that's what I've been doing, going through C/C++ examples.
13:23:19 <Algebr> Polarina: So you basically just wrote the code for the SDL2 package?
13:23:43 <Polarina> Algebr, I wrote the bindings, yes.
13:24:00 <pzel> Quick terminology question: If head is the inverse of cons than tail is the ____ of cons. What is the proper term?
13:24:59 <Algebr> I'm a little bit unclear about the use-case of SDL, it is supposed to be like a nice layer above opengl? Can you make an entire app, a game, in just SDL? or do you need to wrap your SDL in something like GTK
13:25:25 <barrucadu> You can do an entire game in DSL
13:25:26 <barrucadu> *SDL
13:25:42 <barrucadu> It has functions to open new windows, etc
13:26:09 <Polarina> Algebr, think of it as an abstraction over platform-specific APIs that deal with window management, user input and related things.
13:26:40 <WraithM> Has anybody used groundhog-postgresql?
13:26:48 <Polarina> Algebr, sdl2 has some interfaces to do simple 2d rendering without resorting to OpenGL.
13:26:54 <mcbears> you can probably use a nice DSL for SDL
13:27:02 <silasm> pzel: where is this coming from? I wouldn't call head the inverse of cons; cons takes the head and the tail; head only gives back the head.
13:27:13 <Algebr> barrucadu: so presumably those functions that open new windows are the same things that gtk asks of the OS? Polarina: But I can call opengl if need be from SDL?
13:27:37 <silasm> pzel: it's more like head and tail together form the inverse of cons; you need both.
13:28:38 <pzel> silasm: I see your point now -- thanks for clarifying
13:28:39 <Polarina> Algebr, you can. You set up an OpenGL context then start calling OpenGL functions. Look at the OpenGL or OpenGLRaw packages for bindings.
13:29:00 * hackagebot lensref 0.2 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.2 (PeterDivianszky)
13:30:16 <brrrrrrrrian> If I have an IntMap where the values are also Ints, and I expect the map to never grow beyond 4k Ints, how would I determine whether to use the Lazy or Strict variant.  The data access would be mostly reads with mostly spacial locality...
13:30:42 <pzel> silasm: but this doesn't really solve my linguistic problem of naming the relationship of being `part of` the inverse ...
13:30:46 <Algebr> What is the point of having Word and Int? Word is just a subset of Int, correct?
13:30:47 <brrrrrrrrian> spacial locality in terms of indexing into the map...
13:31:38 <pzel> silasm: i.e head is A to cons, and tail is B to cons, where relationship A =/= relationship B
13:32:30 <Polarina> Algebr, Word doesn't have negative numbers, so can represent twice as large numbers in the positive than Int can.
13:34:00 * hackagebot lgtk 0.8.0.4 - Lens GUI Toolkit  http://hackage.haskell.org/package/lgtk-0.8.0.4 (PeterDivianszky)
13:34:14 <silasm> pzel: You could say something like head is a partial deconstruction and tail is its complement, but I'm not really using any kind of mathematical terms here afaik, I'm just kind of making this up from semantics.
13:35:11 <silasm> because tail deconstructs the list and gives you back exactly the part of the list that head doesn't give you back.
13:35:37 <mcbears> additionally, the WordX types are guaranteed to (appear to) have X bits, while Int is only required to have at least 30
13:36:20 <silasm> I don't think I can help you find a word for this, and I'm not honestly sure why you're looking for one. Can I have the context in which you want a term for this (for my own curiosity if nothing else)
13:37:26 <pzel> silasm: sure -- I'm implementing Data.List in erlang and testing my implementation via properties (ala QuickCheck)
13:37:47 <pzel> silasm: so, I have to name the property that myhead(x:xs)  == x
13:38:10 <pzel> silasm: .. and the other property, that mytail(x:xs) == xs
13:38:11 <silasm> ah, okay. I was afraid I was leading you to really strange terms in a tutorial or something.
13:39:02 <pzel> silasm: no no -- I was hoping there was some obvious category theoretical term for this
13:39:05 <Philonous> mcbears, There's also Int{8, 16, 32, 64} with the respective number of bits
13:39:18 <pzel> silasm: but I appreciate your help!
13:39:22 <silasm> pzel: if there is, I don't know it, sorry. I've only recently started learning CT.
13:40:27 <hiptobecubic> pzel, there's #categorytheory
13:40:34 <hiptobecubic> maybe with two ##, I don't recall
13:40:42 <simukis_> I have a directory which contains some package and cabal (1.20) sandbox inside. Now inside that directory I also placed `another-package` directory which contains sources of cabalised package I want to install into the sandbox. `cd`ing into `another-package` and `cabal install` installs to user-wide repository and not sandbox. How can I install package inside `another-package` directory into the sandbox?
13:42:03 <Philonous> simukis_, cabal install <path/to/package>  for one-shot installation or cabal sandbox add-source <path/to/package> to have it re-installed automatically when you change the source
13:42:04 <pzel> hiptobecubic: cool, I'll try there
13:42:07 <srhb> simukis_: One way is to install it from inside the sandbox using add+source
13:42:47 <Philonous> simukis_, Both from within the directory of the sandbox where you want to install the other package into
13:42:48 <simukis_> Philonous: thanks!
13:46:15 <JakeE> Are there any exact real airthmetic packages in haskell? I wanted to play around with it some. I looked here: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics but none seem to actully support true exact real airthmetic
13:47:01 <WraithM> JakeE: I'm not aware of any in Haskell, but I believe there was some work done on that in Coq.
13:47:33 <joelteon> anyone familiar with nix here know why this might be happening? https://gist.github.com/joelteon/cfca7061f76108a45a9a
13:47:39 <joelteon> I also asked in #nixos, but it's not very active
13:47:44 <JakeE> Is dynamic precission the same as exact? It seems to be after reading the discription. If so then I think there are many packages
13:48:11 <WraithM> I don't believe so.
13:48:51 <WraithM> But I don't really know
13:49:43 <Cale> JakeE: CReal here has computable reals http://hackage.haskell.org/package/numbers
13:49:56 <Cale> JakeE: The performance is terrible in most cases
13:50:16 <joelteon> it's because it's using haddock 0.14.0, it turns out
13:50:22 <joelteon> probably a nix issue.
13:50:43 <Cale> there's also http://hackage.haskell.org/package/constructible-0.1.0.1/docs/Data-Real-Constructible.html
13:53:36 <JakeE> Cale: thanks. this gives me more to go off of. I'll play around with CReal some for now I think. Constructable isn't quite what I wanted
14:05:45 <epta> what to do when hlint failed to parse lambda-case?
14:06:22 <athan> epta: Can I see the code?
14:06:54 <epta> athan: \case { '@':x -> Just x; _ -> Nothing } $ dropWhile (/= '@') urlAndMaybeRevision
14:06:54 <athan> epta: My gut tells me either there's a syntax error, or that there's something cool going on haha
14:07:47 <athan> epta: I think you're better :P
14:08:25 <athan> Can it differentiate the guard/condition from the pattern match?
14:09:33 <athan> oh wait, where is your lexical scope? Is 'case' a special keyword?
14:10:28 <quchen> athan: He's using the LambdaCase extension. \case ≡ \x -> case x of
14:11:36 <kakos> Is there a good way to print out the type of a variable at runtime for debugging purposes?
14:11:51 <athan> ahh okay, wouldn't it be a pattern matching / condition fault then?
14:12:10 <quchen> HLint just can't handle \case as far as I know.
14:12:16 <athan> > let foo ('a':xs) = xs
14:12:17 <lambdabot>  not an expression: ‘let foo ('a':xs) = xs’
14:12:31 <athan> ahh. Hmm.
14:13:10 <quchen> kakos: Why would you want that? Are you implementing dynamic types? As far as I know, GHC doesn't even have types at runtime
14:14:16 <quchen> If you want the type of something deep inside something else, use "`asTypeOf` _"
14:14:25 <quchen> (Assuming you're on GHC 7.8)
14:15:13 <quchen> > [1::Int,2, 3 `asTypeOf` _, 4,5,6] -- Aha, that 3 has type Int.
14:15:15 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Int
14:16:47 <benzrf> :t asTypeOf
14:16:50 <lambdabot> a -> a -> a
14:16:53 <benzrf> man i just dont get type ranks
14:16:54 <benzrf> ;-;
14:17:07 <benzrf> @src asTypeOf
14:17:07 <lambdabot> asTypeOf = const
14:17:10 <benzrf> ofc
14:17:17 <benzrf> @src asAppliedTo
14:17:17 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:17:19 <benzrf> o=
14:17:23 <benzrf> @src asAppliedTo
14:17:24 <lambdabot> Source not found. There are some things that I just don't know.
14:17:26 <benzrf> :t asAppliedTo
14:17:31 <lambdabot> (a -> b) -> a -> a -> b
14:17:32 <benzrf> oki
14:18:00 <quchen> asAppliedTo = const :: (a -> b) -> a -> (a -> b)
14:18:35 <awestroke> My cabal insists of breaking everything: https://gist.github.com/awestroke/25a1e7cee46d3ebaccaa
14:18:48 <awestroke> the .cabal/config is default
14:19:24 <awestroke> +
14:19:54 <Philonous> awestroke, try --reorder-goals
14:20:09 <quchen> awestroke: Or --constraint=mtl>=2.1.2
14:20:44 <awestroke> thanks
14:21:01 <awestroke> why would it install a duplicate package without warning in the first place?
14:22:05 <Philonous> awestroke, It's a known bug
14:26:18 <mzarella> How important is testing?
14:26:59 <Philonous> vitally.
14:27:46 <ReinH> Haskell regex libraries are sort of hilariously bad.
14:28:14 <ReinH> If reading a function's type makes you more confused then something is wrong...
14:28:41 <awestroke> ReinH: what about lens types
14:29:02 <ReinH> lens types are at least based on pretty nice, principled lattice structure
14:29:47 <ReinH> Text.Regex is killing me though
14:31:11 <mzero> yeah - we've all spilled blood over it!
14:33:42 <quchen> ReinH: On the other hand, imagine we had awesome Regex libs and people would start using regexes.
14:36:20 <Philonous> quchen, Uh, why? Would that be bad? Should I abandon my attempt at writing a regexp-based XML parser?
14:40:46 <Maior> Philonous: Poe's law :(
14:41:46 <mzero> oh my - yes - you can't parse XML with regex
14:42:15 <hpc> i am sure someone has written a full xml parser in perl regexes, though
14:42:23 <Philonous> Maior, It's more like Philonou's law. The more confident I am (at the time of writing) that what I say is funny, the more likely it is that I end up annoying someone.
14:42:28 <hpc> (which can be done, you can backreference and other dirty things)
14:42:46 <mzero> hpc - I'm sure that parser had bugs
14:43:01 <hpc> it has no obvious bugs, that means it is TDD-complete!
14:43:11 <mzero> \o/
14:44:27 <barrucadu> TDD-complete is one of the hardest problem classes
14:44:33 <monochrom> I saw a regex with backref that matches exactly prime numbers in decimal
14:45:39 <hpc> some people, when they encounter a problem, think "i know, i will use TDD"
14:45:44 <hpc> now they are 99% correct
14:46:58 <Kaidelong> I like TDD
14:47:08 <Kaidelong> I don't know what all the hate is about
14:47:15 <benzrf> jjjjjjjj
14:47:19 <Kaidelong> it seems to be that TDD is awful when its done cargo cult style
14:47:26 <Kaidelong> but you don't have to do it that way
14:47:35 <benzrf> tdd could be interesting in some cases
14:47:41 * mzero is sitting here listening to Conal Elliot show us how to write things that are correct by construction...
14:47:44 <hpc> Kaidelong: yeah, i am just being silly
14:47:45 <benzrf> but it seems entirely irrelevent a lot of the time
14:47:51 * mzero ....no TDD in this presentation!
14:47:58 <monochrom> eh? I don't mock TDD. actually I welcome it. it's an improvement over the previous state. note that tests are finite approximations to specifications. since people will refuse SDD for the next 20 years, TDD is the next best thing.
14:48:28 <companion_cube> SDD ?
14:48:36 <monochrom> specification-driven development
14:48:56 <companion_cube> oh. I'm not sure I see what it is in languages that are not Eiffel
14:49:12 <hpc> when TDD is taught, unis will use terrible example tests that make the whole exercise look silly
14:49:22 <bms1> Type-driven development!
14:49:35 <mzero> bms1: +1
14:49:45 <barrucadu> This is an inevitable consequence of unis being terrible at software engineering
14:50:40 <hpc> i made the mistake of taking a databases class
14:50:41 <monochrom> I do not know Eiffel
14:50:49 <hpc> last week i actually found need of one thing that was taught
14:50:50 <hiptobecubic> hpc, hah
14:50:58 <hpc> just to write a particularly delicate join
14:51:01 <barrucadu> I did a database class once. The relational algebra was interesting, but the SQL...
14:51:12 <hpc> turns out, that type of query doesn't use indices the way you normally do
14:51:15 <hpc> and it nearly brought down the box
14:51:25 <hpc> building a really big temporary table
14:51:32 <monochrom> you can read how Bird does SDD to functional programming in "Algebra of Programming", and how Hehner does to imperative programming in "a Practical Theory of Programming"
14:52:38 <monochrom> actually Bird's "Pearls of Functional Algorithm Design" is more buyable
14:53:06 <monochrom> forget Eiffel. it clearly has type system unsoundness issues
14:53:11 <hpc> i like nasa's approach to software engineering
14:53:26 <benzap> barrucadu: my roomate is a masters who TAs software engineering classes
14:53:30 <mzero> "Ted Codd was not a Developer"
14:53:33 <benzap> he says that none of them should be allowed to pass
14:53:39 <benzap> they're all going to be software engineers soon
14:53:41 <Eduard_Munteanu> hpc: what would that be?
14:53:59 <mzero> (or rather, how our whole industry could have been happy with Monads if Ted Cobb had only not picked relational algebra..."
14:54:05 <ReinH> quchen: that's a fair point. Unfortunately I actually want regex here.
14:54:21 <hpc> Eduard_Munteanu: there's a lot to it, but the basic philosophy is that the further a bug gets before being caught, the worse the process is
14:54:38 <hpc> Eduard_Munteanu: and the only thing a programmer can get in trouble for is not following the process
14:54:41 <barrucadu> benzap: Sounds reasonable
14:54:56 <spott> is there anything special that needs to be done to import something from a folder?
14:55:22 <hpc> and they do pretty much whatever they can to automate verification of code
14:55:44 <monochrom> yes. you need to tell ghc "-ifolder". no space between -i and the folder.
14:56:10 <silasm> benzap: as an SE student, I agree
14:56:17 <benzrf> oh no another benz here
14:59:45 <Eduard_Munteanu> Heh, you should see the Dans in here.
15:00:18 * Eduard_Munteanu wonders about other Eds, aside from the obvious one.
15:04:08 * hackagebot system-filepath 0.4.11 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.11 (JohnMillikin)
15:07:01 <pharaun> i'm curious how often this happens to other folks? I find myself just following the types and implementing it when i sometime have no idea how its supposed to work
15:07:13 <pharaun> and then lo and beyond a working code >.>
15:07:33 <pharaun> either that or i did something horribly wrong
15:15:29 <dwcook> It's certainly possible to get it wrong, especially when there are many candidates for a type available (e.g., IO ()), but often you can get away with it.
15:15:49 <dwcook> s/candidates for/values of/
15:16:20 <pharaun> yeah i got it wrong last night :) ended up with MonadError (LispError s) (ST s)
15:16:24 <pharaun> i think this approach is... correct i hope
15:16:34 <pharaun> ST s (either err val)
15:29:14 * hackagebot cabalg 0.2.3 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.3 (DmitryMalikov)
15:38:24 <proxfox> I'm using HXT, I'm wondering if there's a way to keep the text between <td></td> together. It is the case when <br\> is inbetween "td" that the words are split into unique nodes and that's not what I want... I've tried removing the <br> before doing anything else, I've noticed that the tree is devoid of "br" after removal but the partition of the string between "td" was done during the tree construction...
15:38:26 <pharaun> omfg
15:38:27 <pharaun> it works
15:39:03 <pharaun> augur: omg it works :D you two did point me in the right direction
15:41:33 <ditzy> hi again. Would anyone mind helping me with the 'persistent' package? I'm following the Yesod book (http://www.yesodweb.com/book/persistent) and can't get their example to compile. Here's the source and compile error http://lpaste.net/104286
15:41:39 <proxfox> found it out... (deep getText >. concat)
15:42:19 <epta> cabal: Multiple cabal files found. <-- what is this error about? Reproducing only in cabal-1.20
15:42:45 <ditzy> I've tried indenting "Person" a bit, and then the error changes to "parse error on input `deriving'". And if I comment out the deriving line then I get an indentation error on the closing bracket |]
15:48:57 <jophish> Has anyone got a handy link to a motivating example of using Haskell over C
15:49:59 <Philonous> ditzy, Language Pragmas have to come before the module declaration
15:50:00 <Eduard_Munteanu> jophish: https://cve.mitre.org/ ? :)
15:51:10 <jophish> Eduard_Munteanu: heh! that's actually a terrible example of what I'm looking for! I'm actually looking for a comparison between Haskell and GLSL for a thesis
15:51:38 <jophish> I've never heard of any security exploits using GLSL
15:51:41 <jophish> :)
15:51:43 <Philonous> ditzy, Parse errors often mean that something went wrong somewhere _before_ the point where the error occurs.
15:52:14 <ditzy> Phillemann: wooooooooooooooow I feel dumb. Thank you! Pragmas are new for me and since the book didn't show the module declaration I presumed it was just up there somewhere
15:53:24 <ditzy> and now it compiles. Ugghhhh! Thank you Philonous! ^_^
15:53:43 <ditzy> quoted the wrong person up there, my bad. I tab-completed wrong
15:55:02 <ditzy> it works!!!!!! Yay!!!!!
15:56:07 <ditzy> Philonous: thanks again!
15:56:34 <Philonous> No sweat
15:58:33 <Algebr> Writing a compiler for C++ must be the hardest language to write for, fair to say?
15:58:55 <quchen> Algebr: Check out Befunge
15:59:27 <Algebr> nuts
15:59:44 <banister_> Algebr apparently ruby is pretty crazy too
16:01:14 <hpc> perl, definitely
16:01:39 <hpc> each file can have a begin block, which is a piece of perl code that runs before the rest of the module is compiled
16:01:53 <hpc> parsing the rest of the code depends on the result of that begin block, which can conditionally define things
16:02:17 <hpc> notably, transforming a regular expression into a division operation
16:03:06 <Algebr> Does the cpp have a name or do we all just call it the cpp?
16:03:23 <kloplop321> C-Pre-Processor
16:05:49 * hackagebot system-filepath 0.4.11 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.11 (JohnMillikin)
16:05:49 * hackagebot cabalg 0.2.3 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.3 (DmitryMalikov)
16:09:17 <Eduard_Munteanu> Any idea if process-conduit can link handles when "piping" output from one process to another, or does it go through Haskell?
16:09:25 <Eduard_Munteanu> I suspect it's the latter.
16:30:39 <hiptobecubic> hpc, isn't that just another intermediate step?
16:31:04 <hiptobecubic> you start with perl0, run the begin block and you have perl1, then you use your 'normal' perl compiler
16:31:23 <hiptobecubic> i think just figuring out what any given expression *should actually do* would be harder than that
16:31:46 <hiptobecubic> since that's only barely understood at write time
16:31:48 <hiptobecubic> let alone runtime
16:31:51 <hpc> hiptobecubic: what about imports in the begin block?
16:31:58 <hpc> (hint: imports in perl aren't simple)
16:34:44 <hiptobecubic> you could just output random bytecode
16:35:01 <hiptobecubic> It's still more likely work correctly after a year
16:36:20 <hiptobecubic> well not quite, but only just!
16:59:58 <pakaran> Hi, I'm a computer science grad student looking to learn haskell as a summer project.
17:00:12 <pakaran> Any suggestions for tutorials, etc?  I'm a complexity theorist, so I understand the math, basic set theory, etc.
17:01:09 <mayski> pakaran: I'm basically doing the same and I'm reading "learn you a haskell for great good" and "real world haskell", both good so far
17:01:17 <pakaran> mayski, cool, thanks
17:01:17 <sipa> @where lyah
17:01:18 <lambdabot> http://www.learnyouahaskell.com/
17:01:36 <pakaran> I assume my linux distro will have everything I need?
17:01:47 <pakaran> in terms of compilers and such, I mean?
17:01:55 <rhaps0dy> yes
17:02:00 <rhaps0dy> well it depends
17:02:06 <rhaps0dy> but mostly yes
17:02:09 <mayski> you might need to install stuff with cabal maybe
17:02:38 <mayski> but yeah for just playing around at first then you're probably good to go
17:02:40 <pakaran> but bottom line, foss stuff exists, and can be gotten without editing makefiles etc?
17:03:18 <mayski> yes
17:03:32 <pakaran> thanks
17:06:00 <ion> pakaran: If you find out your distro happens to have a older version of GHC than you'd like, this is an option: https://gist.github.com/ion1/2815423
17:06:12 <pakaran> ion, thanks
17:06:25 <augur> pharaun: :)
17:08:11 <augur> pharaun: what was the type of your envs?
17:08:37 <pakaran> augur let me aptitude install ghc and see what version it has
17:09:07 <augur> well, either way, it ought to be something like
17:09:28 <ion> apt-cache policy ghc
17:09:39 <pakaran> I'll likely need it for lyah 7.6.3-10 how is that?
17:10:07 <pakaran> that's also the version in sid (I mostly run jessie)
17:10:17 <augur> type Env = [(Name, STRef ? LispTerm)]
17:10:32 <augur> @hoogle stref
17:10:34 <lambdabot> Data.STRef module Data.STRef
17:10:34 <lambdabot> Data.STRef data STRef s a
17:10:34 <lambdabot> Data.STRef.Lazy data STRef s a
17:10:53 <augur> why is STRef parameterized on s? is that to catch ST's s for world state?
17:10:54 <augur> hmm
17:10:57 <ion> It's okay. GHC 7.8.2 has some very nice improvements but perhaps the package has been updated by the time you're advanced enough to want them.
17:11:12 <pakaran> hmm, i'll install it by hand in my home directory then, thanks
17:11:50 <augur> pakaran: i think you misinterpreted who i was talking too :)
17:12:24 <pakaran> augur, I was replying to ion
17:12:33 <augur> pakaran: well you addressed me!
17:12:44 <glguy> augur: The 's' parameter ensures that the mutable elements don't escape their "thread"
17:12:58 <augur> glguy: hm. whatever that means!
17:13:10 <pharaun> augur: i basically pulled the exception out and switched to ST s Either error val and then my closures were still "LispEnv s"
17:13:10 <glguy> which is why it is safe to hide that mutation under a pure run function
17:13:28 <ion> For instance, type holes are very convenient. Use _ as an expression anywhere and the compiler will tell you what the type of that expression ought to be and what values in scope might be useful for filling in the expression.
17:13:34 <pharaun> and i took advantage of the Fix trick and used that to force the LispVal to be "pure tree" with no state when i embed it into my error
17:13:46 <quchen> (Type*d* holes)
17:13:50 <augur> pharaun: what do you mean "pulled the exception out?
17:13:53 <pharaun> so i didn't have to deal with it either in the error reporting so that worked and then i finally got it to run the whole way through
17:13:54 <glguy> augur: Read this http://www.haskell.org/haskellwiki/Monad/ST and the associated paper at the bottom if you want to know more
17:14:16 <augur> pharaun: hmm.. im not entirely sure what you did. but: i would say, the lisp ASTs should be stateful, but not exceptional
17:14:28 <pharaun> augur: MonadException (LispError s) (ST s) to ST s (Either (LispError) (LispVal s))
17:14:48 <pharaun> augur: yeah the lisp ast is stateful, but sometime i included part of the AST in the LispError for error reporting
17:14:53 <augur> pharaun: aha ok. i dont know what the fix part is tho
17:15:01 <pharaun> newtype Fix f = Fix (f (Fix f))
17:15:05 <augur> pharaun: no i know the definition
17:15:08 <pharaun> ahh
17:15:09 <augur> i dont know what you're doing with it tho
17:15:14 <pharaun> oh
17:15:18 <pharaun> data LispError = NumArgs Integer [Fix LispVal]
17:15:27 <augur> why?
17:15:33 <pharaun> instead of [LispVal s] its [Fix LispVal] so i remove the state
17:15:42 <augur> you need state in it tho
17:15:54 <pharaun> I flatten it
17:15:57 <pharaun> into a tree
17:16:07 <augur> eh.. you risk producing infinite trees that way
17:16:10 <pharaun> well its running now
17:16:16 <pharaun> but I can probably improve part of it
17:16:30 <pharaun> augur: yah, right now the flattening out part terminates early after a few loop
17:16:51 <augur> you should have some way to indicate you've stopped
17:17:00 <pharaun> I'll add that, good idea
17:17:02 <augur> it ought to be possible to error on a cyclic list, for instance
17:17:08 <augur> so you need something like..
17:17:24 <augur> data LispVal a = ... | Cycle
17:17:31 <pharaun> ooh
17:17:34 <pharaun> didn't think of that
17:17:36 <pharaun> >_<
17:17:43 <augur> and then Fix LispVal will put Cycle in place of the cyclic references
17:17:51 <augur> but you have to traverse the tree left-to-right
17:17:54 <pharaun> in the flatter i just terminated it with (String "<Terminated>")
17:17:56 <augur> because not all refs are cyclic
17:18:18 <augur> sometimes you have weird cross-references which arent obviously cyclic but which do lead to cyclicity
17:18:25 <pharaun> ahh i see
17:18:32 <pharaun> well i got it to run at least
17:18:39 <pharaun> but i'm pretty sure like you said there's lots of improvements
17:18:57 <pharaun> i'll add those to my todo, didn't think of adding a | Cycle
17:19:40 <augur> consider for instance a list analogous to this in haskell:   let xs = (a, ys) ; ys = (b, xs) in (xs,ys)
17:20:13 <augur> its cyclic, but in a weird way -- the references go sideways, not obviously vertically
17:20:29 <albeit> I have a concurrent application that uses Unix domain sockets to send/receive messages, and a Concurrent.Chan as a message queue (multi-producer, single consumer). Should I be probably be using conduits or pipes? What are the advantages I get from them?
17:20:50 * hackagebot ihaskell 0.4.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.4.0.0 (gibiansky)
17:20:52 <augur> tho you could treat it like its just cyclic, you could also just block at the top ys
17:21:03 <augur> it depends on how much repetition you want, really, pharaun
17:21:13 <benzrf> :t _Left
17:21:14 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Either a c) (f (Either b c))
17:21:22 <benzrf> w-what is Choice
17:21:36 <pharaun> augur: yeah right now i just terminate after a few step but yeah
17:21:38 <augur> pharaun: if you just treat it cyclically, you should print   ((a,(b,...)),(b,(a,...)))
17:21:47 <pharaun> that would be much better
17:21:49 <augur> but you could also just print   ((a,(b,...)),...)
17:22:10 <augur> pharaun: if you're really clever, you might even want to print something like
17:22:36 <augur> ( loop0: (a,(b,loop0)), loop1: (b,(a,loop1)) )
17:22:45 <benzrf> > over _Left (++"test") (Left "foo")
17:22:47 <lambdabot>  Left "footest"
17:22:53 <pharaun> augur: ooh nice
17:22:54 <benzrf> > over _Left (++"test") (Right "foo")
17:22:56 <lambdabot>  Right "foo"
17:22:59 <benzrf> neat
17:23:03 <augur> pharaun: that wouldnt be too hard, i dont think
17:23:23 <pharaun> my first time i've done anything like this so yeah lots things i didn't think of
17:23:29 <pharaun> shouldn't in theory
17:23:30 <benzrf> > view _Left (Left 3)
17:23:31 <lambdabot>  No instance for (GHC.Show.Show a0)
17:23:31 <lambdabot>    arising from a use of ‘M889318885609476782332600.show_M8893188856094767823...
17:23:31 <lambdabot>  The type variable ‘a0’ is ambiguous
17:23:31 <lambdabot>  Note: there are several potential instances:
17:23:31 <lambdabot>    instance [safe] GHC.Show.Show
17:23:38 <benzrf> > view _Left (Left "foo")
17:23:40 <lambdabot>  "foo"
17:23:43 <benzrf> > view _Left (Right "foo")
17:23:45 <lambdabot>  ()
17:23:47 <benzrf> h-how
17:23:54 <benzrf> :t view _Left (Right "foo")
17:23:55 <lambdabot> Monoid a => a
17:23:57 <albeit> Anyone familiar with pipes or conduits?
17:23:59 <benzrf> ah
17:24:00 <augur> pharaun: you'd have to do something like have an aux function that returns not just the printed val, but a list of refs that it cut short due to looping, and then as you receive the returned list, you check if its the current ref, and if so you mark it
17:24:08 <benzrf> albeit: i know a bit of pipes
17:24:10 <benzrf> not much
17:24:18 <pharaun> same here albeit i know some of pipes and conduit
17:24:21 <pharaun> but i'm not an expert
17:24:47 <albeit> benzrf: pharaun: Trying to figure out if I need them. What advantages do they offer exactly?
17:24:53 <augur> pharaun: this might be a good reason to have a custom type for flattened trees
17:25:02 <albeit> I've read the documentation, but don't quite get when I would want them.
17:25:17 <augur> pharaun: something like LispVal but recursive, and with extra constructors for cycle handling
17:25:34 <benzrf> albeit: seems like when you want lazy, effectful, composable code
17:25:38 <augur> pharaun: then you can write a function flatten :: LispVal s -> FlatVal
17:25:47 <benzrf> pharaun: are you writing a lisp o=
17:25:57 <pharaun> augur: that seems like it would make sense and would help me differ between a LispVal and a flattened tree
17:26:19 <augur> pharaun: in general its good practice to use data types to express intention :)
17:26:21 <pharaun> benzrf: yeah, scheme really
17:26:24 <albeit> benzrf: Well... ya. But how would the code not be that if I didn't use pipes?
17:26:25 <pharaun> augur: agreed
17:26:36 <benzrf> albeit: well
17:26:42 <pharaun> augur: i tried to do that with Fix LispVal but having a separate data structure would be better
17:27:03 <benzrf> albeit: effectful code in the base libraries is usually either strict or difficult to compose well
17:27:10 <augur> honestly i dont think you should parameterize LispVal at all
17:27:11 <augur> but
17:27:27 <pharaun> augur: don't i need to because of ST, cuz of LispEnv ?
17:27:58 <augur> im not sure really. the purpose of the param is to sneak in the param of ST/STRef
17:28:05 <albeit> benzrf: What do you mean by difficult to compose well?
17:28:45 <augur> pharaun: you might just be able to do LispVal s = ... | STRef s (LispVal s)
17:29:00 <benzrf> albeit: i dunno, i'm just parroting their advertising
17:29:02 <benzrf> d:
17:29:37 <albeit> Ha, yeah I've read their advertising, I just don't understand what it means exactly, and why its a good idea to use pipes/conduits....
17:33:20 <mcbears> albeit: this SO question might help http://stackoverflow.com/questions/22742001/what-is-pipes-conduit-trying-to-solve
17:33:58 <albeit> mcbears: Wow that is perfect, I even search stack overflow for "haskell pipes conduits" and couldn't find that somehow... thanks!
17:36:09 <mcbears> noo problem :^)
17:36:14 <pharaun> augur: thanks again! :) i'm mainly happy i got it to run but yeah i'll look into doing those suggestion to improve it further
17:38:44 <augur> np pharaun
17:39:01 <libmn> Watch out LAMP...    UMPH = Unix Mighty Postgresql Haskell  :P
17:53:32 <shachaf> (==#) :: Int# -> Int# -> Int# now?
17:54:01 <alevy> I'm getting a strange bytestring error now that i've upgraded to 7.8 that I'm having a hard time tracking down:
17:54:15 <alevy> "Oops!  Entered absent arg a_sI5p{v} [lid] bytestring-0.10.4.0:Data.ByteString.Internal.ByteString{tc r2Y}"
17:54:18 <shachaf> Are you supposed to pattern-match on its result now?
17:54:23 <alevy> anybody have any clues?
17:54:45 <alevy> (this is ghc 7.8, to clarify)
18:01:45 <smiller2> How should one convert between Double and Float in Haskell?
18:02:26 <pavonia> :t realToFrac
18:02:29 <lambdabot> (Real a, Fractional b) => a -> b
18:03:07 <pavonia> smiller2: see also http://www.haskell.org/haskellwiki/Converting_numbers
18:04:30 <smiller2> pavonia: Thanks, but I get the impression that realToFrac's definition of "fromRational . toRational" to be suboptimal, since it converts to and from a Rational, which I imagine to be slower than whatever C does in its casts.  Is there a better way?
18:04:56 <pavonia> please see the wiki page
18:05:09 <alevy> :t double2Float
18:05:11 <lambdabot> Not in scope: ‘double2Float’
18:05:21 <alevy> urgh... it's in GHC.Float i think
18:11:22 <shachaf> OK, I see now.
18:12:13 <shachaf> I was compiling without optimizations.
18:12:19 <shachaf> I guess the real (==) uses tagToEnum#
18:20:56 * hackagebot pointless-haskell 0.0.9 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.9 (HugoPacheco)
18:34:11 <pharaun> lol
18:36:07 <augur> pharaun: 0.0
18:37:44 <pharaun> ?
18:37:54 <augur> pharaun: you lolled out of nowhere!
18:38:01 <pharaun> oh i just had a good chuckle at the library name :)
18:38:12 <augur> oh yes
18:38:21 <augur> pointless is a joke people love to use
18:38:23 <pharaun> i mean i'm aware that its an valid name but it still gives me a chuckle never the less
18:38:42 <pharaun> and indeed
18:39:03 <augur> and arguably, its a good joke
18:39:10 <augur> because tacit style is rather pointless
18:40:04 <tb01110100> that sounds like it should be a library for awesome wm
18:40:20 <tb01110100> there's obvious, vicious, wicked, beautiful...
18:40:27 <tb01110100> now all we need is "pointless"
18:41:58 <augur> ugh
18:42:09 <augur> good pizza is so hard to come by, and so wonderful once you do
19:01:46 <jle`> is there a more -Wall than -Wall ?
19:06:13 <joelteon> -Werror?
19:06:21 <joelteon> what are you looking for?
19:07:59 <jle`> are there any warnings that ghc can output that aren't included in -Wall?
19:08:14 <joelteon> no
19:11:28 <dolio> Huh? Yes there are.
19:13:09 <joelteon> really?
19:13:12 <dolio> Yes.
19:13:22 <joelteon> jle`: see above
19:13:27 <dolio> But you have to enable them individually.
19:13:59 <dolio> Actually the documentation on -Wall lists the warnings that it doesn't turn on.
19:14:50 <joelteon> "-Wall: enable almost all warnings (details in )"
19:15:54 <dolio> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
19:16:19 <joelteon> Huh. No kidding.
19:16:33 <joelteon> I can see why some of those are disabled even with -Wall
19:16:39 <dolio> Yeah.
19:16:46 <frontend1oader> annoying cat spilled water On it
19:18:29 <alorente> Are there cool strategies for dealing with dependency conflicts? Specifically a newly snap-init-ed project is failing to build itself https://gist.github.com/AndrewLorente/7642036530b126ab96ae
19:23:38 <alorente> also how do I submit typo-fix patches to that options-sanity.html page?
19:24:10 <pakaran> Hey I'm trying to follow the instructions from https://gist.github.com/ion1/2815423 but I'm getting this error:
19:24:24 <pakaran> Downloading Cabal-1.21.0.0...
19:24:33 <pakaran> curl: (22) The requested URL returned error: 404 Not Found
19:25:42 <pakaran> nm figured out what i was doing
19:25:54 <pakaran> (using git rather than the cabal-install tarball version of cabal)
19:26:44 <pakaran> thanks anyhow :)
19:32:40 <enthropy> is there a way to make cabal stop complaining about You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.18.1.3, now Cabal-1.20.0.0).?
19:35:11 <pavonia> enthropy: Do you get this even if your cabal file hasn't changed?
19:36:07 <enthropy> yes. I think it's because I'm using a cabal install that is built with a Cabal-1.20.0.0, but this particular ghc only has Cabal-1.18.1.3
19:36:30 <joelteon> did you cabal configure?
19:38:16 <enthropy> I 'cabal install' then I 'cabal test' (which needs to 'cabal configure')
19:42:50 <carter> did you try the help command?
19:48:44 <XrXr> Hi! I don't fully understand why do a <- [1..50]; [1,2,3]; return a returns a list of [1..50] replicated 3 times. What is going on?
19:49:13 <joelteon> does it really?
19:49:32 <joelteon> for me, that returns 50 repetitions of [1,2,3]
19:49:36 <joelteon> XrXr: sample code?
19:49:46 <dolio> You missed the 'return a'.
19:50:14 <joelteon> *that* returns 3 1s, 3 2s, 3 3s, etc. up to 50
19:50:20 <joelteon> the story doesn't check out
19:50:27 <XrXr> yea thats what I meant
19:50:32 <jmcarthur> XrXr: read as "for each a in 1..50 { for each _ in 1, 2, and 3 { return a } }"
19:51:06 <XrXr> jmcarthur: ah.. that makes far more sense
19:51:20 <XrXr> thanks :D
19:57:53 <enthropy> carter: me?
19:58:20 <enthropy> I'm just confused why cabal needs me to reconfigure all the time
19:58:45 <enthropy> it ought to just use Cabal-1.20.0.0 all the time
19:59:23 <jtcwang> while building project?
19:59:41 <jtcwang> that's probably u've changed stuff in your project's .cabal file
20:04:16 <user`> I try to run a test program, from the lyh and it supposed to ask hello what'a your name, but it doesnt, I press enter, then it output it and the rest
20:05:05 <EvanR> user`: sounds like a buffering issue
20:05:21 <EvanR> you can set the buffering mode on IO handles
20:05:57 <user`> how?
20:06:01 <EvanR> you are getting line buffering but you want no buffering
20:06:43 <EvanR> its on here http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html
20:07:15 <EvanR> hSetBuffering, alternatively, use hFlush after writing the message to the user
20:07:52 <user`> it is stdin
20:08:28 <EvanR> :t stdin
20:08:30 <lambdabot> Not in scope: ‘stdin’
20:08:37 <EvanR> stdin :: Handle
20:08:46 <EvanR> er, the message is shown on stdout
20:09:05 <mcbears> :t System.IO.stdout
20:09:05 <lambdabot> GHC.IO.Handle.Types.Handle
20:10:34 <qwebirc5710> Can someone tell me if it's an awful idea to structure a simple linear algebra library like this: pastebin.com/iZxGj6N8 ? I am hardcoding the size of the matrices since I should only require 2x2, 3x3, and 4x4. But it seems that, maybe, my use of type classes is egregious?
20:11:53 <EvanR> just 2 3 and 4 would be fine for personal use, if only that were easy to manually implement
20:12:00 <EvanR> im guessing it isnt
20:12:07 <EvanR> probably want to use an existing library
20:12:19 <qwebirc5710> EvanR: What do you mean by manually?
20:12:26 <EvanR> writing the code yourself
20:12:38 <qwebirc5710> EvanR: Isn't that what I have?
20:13:06 <EvanR> you only have 2x2
20:13:27 <qwebirc5710> EvanR: Right, but the 3x3 and 4x4 will look (mostly) the same.. I think
20:14:15 <EvanR> heh
20:15:45 <flebron> Question. SPJ in one of his talks is saying f is "troublesome" to find a most general type for, why? http://lpaste.net/104299 Why could f have any other type than T a -> Bool -> Bool?
20:16:02 <EvanR> as far as ideas go, maybe look at some existing linear algebra packages, i dont know which ones are good though
20:16:17 <qwebirc5710> EvanR: The only thing that's going to get a bit bigger are the determinants, transpose, and EvanR inverse...
20:16:47 <qwebirc5710> Just the inverse, not the EvanR inverse
20:16:49 <EvanR> it will work fine, just a lot of typing
20:16:59 <EvanR> and if thats all you need good
20:17:20 <Cale> flebron: It could be  T a -> a -> a
20:17:49 <qwebirc5710> EvanR: Ah, I see, thanks
20:17:58 <flebron> Oh because it could be getting that Bool from the T1 ctor of T?
20:18:31 <Cale> flebron: Yeah, in the T1 case, a = Bool, so it's okay to produce a Bool as a value of type a there
20:18:35 * flebron is a bad type unifier -_-
20:18:58 <flebron> Would it be still troublesome if it was T1 z -> 42?
20:20:28 <Cale> well...
20:22:01 <Cale> flebron: If 42 is known to be, say, Integer, then it's not a problem
20:22:37 <Cale> But 42 *might* be a Bool, and it's bad to rely on nonexistence of instances when trying to decide how to unify types
20:22:45 <Cale> (because any future module might define them)
20:22:47 <flebron> O.o????
20:22:53 <flebron> 42 might be a Bool?
20:23:09 * flebron checks he is not in #c++
20:23:09 <Cale> :t 42
20:23:11 <lambdabot> Num a => a
20:23:21 <bms1> flebron: instance Num Bool where fromInteger i = i `mod` 2 == 0 ...
20:23:27 <flebron> Oh no :(
20:24:20 <flebron> Well, thanks. :)
20:26:12 <roconnor> ocharles: Do you have a clever way of making version numbers in your .cabal file and default.nix file in sync?
20:28:44 <XrXr> list as monads are confusing.. XD
20:31:03 <dwcook> XrXr: what do you find confusing about it?
20:32:03 <dwcook> If it helps, (>>=) is just concatMap with the parameters flipped.
20:32:34 <dwcook> @type (>>=) `asAppliedTo` []
20:32:36 <lambdabot> [a] -> (a -> [b]) -> [b]
20:32:37 <dwcook> @type concatMap
20:32:38 <lambdabot> (a -> [b]) -> [a] -> [b]
20:32:54 <XrXr> >> makes less sense to me
20:33:04 <dwcook> @type (>>) `asAppliedTo` []
20:33:05 <lambdabot> [a] -> [b] -> [b]
20:33:20 <dwcook> So here it just means that for every element of a, we repeat [b] in its entirety.
20:33:31 <dwcook> > [1, 2, 3] >> ['a', 'b', 'c']
20:33:33 <lambdabot>  "abcabcabc"
20:33:49 <dwcook> (If a is the first parameter)
20:33:54 <flebron> [] is the "nondeterminism" monad. When you say [ ... | a <- x, b <- y], it's as if x and y are nondeterministic, and you'll try out every possible value x and y have.
20:34:07 <dwcook> In other words we care about the structure (the length) but not the actual values.
20:34:41 <XrXr> hm.. what happens when you do binding? is the binding just each element of the list?
20:34:43 <flebron> So if dice = [1..6], then do { d1 <- dice; d2 <- dice; return (d1 + d2); } returns all possible results of throwing two dice.
20:34:52 <solirc> I'm puzzled if it would be desirable to have something like
20:34:54 <solirc> catchOnly :: (Eq e, Exception e) => IO a -> e -> IO a -> IO a
20:35:04 <dwcook> XrXr: yes, the right side of (>>=) receives every element individually, then concatenates all the results.
20:35:06 <solirc> in Control.Exception?
20:35:18 <dwcook> s/concatenates/it concatenates/
20:35:26 <flebron> (You can also think of it as a probability thing, where dice has each of 1 .. 6 with 1/6th probability, and that sum will have a value x with probability p if the probability of getting x when you throw two dice is p.)
20:36:11 <XrXr> sometimes you do care about what is in the list though
20:36:13 <pavonia> solirc: How would that be different to catch?
20:36:16 <XrXr> but that really helped :)
20:36:18 <dwcook> Yes, and in those cases you don't use (>>).
20:36:29 <flebron> That "do" expression above desugars to [d1 + d2 | d1 <- dice, d2 <- dice].
20:36:34 <dwcook> I was explaining (>>) when I said that, not (>>=).
20:36:45 <solirc> pavonia: (action `catchOnly` e) handler = catchJust (guard . (== e)) action $ \() -> handler
20:36:56 <mcbears> If you want to think about how list's >>= works, it's just concatMap with the arguments flipped
20:37:10 <dwcook> We touched on that already :)
20:37:18 <mcbears> ah sorry >.<
20:37:21 <dwcook> No worries
20:37:35 <solirc> hmm, I guess not
20:37:52 <XrXr> do is just things >> together right?
20:37:58 <solirc> It does not allow you to look at the exception value
20:38:10 <dwcook> XrXr: not just.
20:38:12 <solirc> so probably it's not generic/useful enough...
20:38:33 <dwcook> do { x' <- x ; rest } = x >>= \x' -> rest
20:38:41 <dwcook> Errr
20:38:46 <dwcook> do { x' <- x ; rest } = x >>= \x' -> do { rest }
20:38:50 <dwcook> Where rest is a bunch of statements
20:39:12 <dwcook> The desugaring is recursive once you have all the rules. Here, let me find them in the report.
20:39:53 <dwcook> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14 Read the translation box.
20:40:50 <dwcook> Oh, I stated that rule wrong. What I said only approximates the truth. It happens to work if x' is a catch-all pattern.
20:41:19 <dwcook> I wouldn't worry too much about the distinction just now though.
20:41:38 <hiptobecubic> Would Pearls of Functional Algorithm Design come before or after Okasaki?
20:43:49 <dwcook> XrXr: if you have a particular do expression you'd like help working through then feel free to post it (use a paste site if it's many lines)
20:44:20 <XrXr> I don't understand how the do block can be a function
20:44:33 <XrXr> in e >>= ok
20:44:57 <dwcook> I'm not sure what you're asking.
20:45:12 <dwcook> Oh, those aren't literally definitions in the Haskell language.
20:45:24 <dwcook> They're just translations that you are allowed to make.
20:45:56 <XrXr> what does that mean?
20:45:58 <dwcook> "do {e} = e" is descriptive, it isn't Haskell code.
20:46:23 <XrXr> hm.
20:46:24 <dwcook> The thing on the left and the thing on the right by themselves are Haskell expressions, but the equation is not valid Haskell.
20:47:07 <dwcook> However Haskell admits use of equational reasoning, so we often write things using = that aren't strictly definitions in the language.
20:47:23 <dwcook> For example, the functor laws such as "fmap id = id"
20:47:25 <mcbears> so "do { a <- [1,2,3]; [2,5]; return a }" is just syntactic sugar for "[1,2,3] >>= (\a -> [2,5] >> return a)"
20:48:08 <XrXr> oh
20:48:25 <XrXr> the lambda part is what I was confused about
20:48:44 <XrXr> because feeding a list into a list doesn't make sense
20:49:38 <dwcook> It sounds like you've developed an intuition for Monad that doesn't serve you for lists.
20:49:54 <dwcook> You're referring to "a >> b" as feeding a into b?
20:50:05 <XrXr> no >>=
20:50:16 <dwcook> Well, the thing on the right side of (>>=) is a function.
20:50:26 <dwcook> As a reminder,
20:50:28 <dwcook> @type (>>=)
20:50:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:50:35 <XrXr> it makes more sense now :)
20:50:38 <dwcook> or in the case of lists
20:50:44 <dwcook> @type (>>=) `asAppliedTo` []
20:50:45 <lambdabot> [a] -> (a -> [b]) -> [b]
20:51:12 <nisstyre> XrXr: well [1,2,3] >>= (return . (+1)) doesn't really feed the list [1,2,3] into the function
20:51:30 <XrXr> it feeds elemnts of [1,2,3]
20:51:32 <nisstyre> it does what the monad instance defines for >>= for lists
20:52:01 <nisstyre> yeah it is (at least here) equivalent to map (+1) [1,2,3]
20:52:30 <dwcook> It might be instructive to trace the evaluation.
20:54:04 <dwcook> Starting with [1, 2, 3] >>= (return . (+1)), we apply the definition of (>>=) for lists to get concatMap (return . (+1)) [1, 2, 3], and of concatMap to get concat (map (return . (+1)) [1, 2, 3]).
20:55:16 <dwcook> Skipping a few obvious steps (which we can go over if they're not obvious), map (return . (+1)) [1, 2, 3] evaluates to [return (1 + 1), return (2 + 1), return (3 + 1)]
20:55:55 <dwcook> So we use the definition of return for lists (return x = [x]) to get [[1 + 1], [2 + 1], [3 + 1]]
20:56:18 <dwcook> So we're left with concat [[1 + 1], [2 + 1], [3 + 1]], which becomes [1 + 1, 2 + 1, 3 + 1]
20:56:31 <dwcook> And then we can just force all the elements and we get [2, 3, 4]
20:57:05 <XrXr> yea.
20:57:10 <dwcook> XrXr: try doing that with some other expression yourself. Use paper or a text editor if necessary.
20:57:39 <dwcook> Start with something in terms of (>>=), (>>), and/or return, and once you know you can do that, attempt to apply the translation rules for do expressions.
20:57:54 <dwcook> So the step after that would be to translate a do expression to those functions.
20:59:40 <albeit> I'm just observing/learning, but this is some good stuff dwcook, thanks
20:59:59 <dwcook> I'm glad you find it useful
21:00:23 <XrXr> do a <- [1..20]; guard (a `mod 2 == 0); return a    is [1..20] >>= (\a -> guard (a `mod 2 == 0) >> return a)
21:01:05 <XrXr> it becomes something like [[]>>1, [()]>>2, []>>3, [()]>>4]
21:01:12 <dwcook> Yep. I'm guessing you mean `mod` but other than that it looks fine.
21:01:31 <XrXr> when it gets concated its just [2,4....]
21:01:47 <XrXr> makes much more sense now
21:01:57 <XrXr> Thanks :D
21:02:13 <dwcook> You skipped several steps in there, but if it makes sense to you, then good
21:02:41 <XrXr> what did I skip?
21:03:00 <dwcook> Mostly to do with guard
21:03:14 <XrXr> ah.
21:03:31 <dwcook> Do you know the definition of guard?
21:04:00 <dwcook> It involves yet another typeclass method, mzero of MonadPlus
21:04:20 <dwcook> But if you know the general principle of substituting a typeclass method for its specific instantiation then you're fine
21:05:14 <XrXr> its just when expression is true it returns a [()] when its not it returns mempty which its []
21:05:48 <dwcook> mzero you mean. But yeah, mzero = [] for lists.
21:06:20 <dwcook> And return () is where you get [()] from.
21:06:59 <XrXr> Thank you so much :D learning Haskell would be 10 times more frustrating without people in this IRC
21:07:08 <dwcook> It can be handy knowing the general implementations of functions like this so you automatically know how to apply them to other instances.
21:07:13 <dwcook> No problem.
21:07:51 <dwcook> Well, I should probably hit the sack. Have fun.
21:09:50 <begriffs> When I run "hoogle data" from the command line, does anyone know where it stores the database it builds?
21:13:19 <mcbears> I know on windows at least it goes to AppData\Roaming\cabal\hoogle\databases
21:14:34 <mcbears> (or at least p. sure)
21:15:38 <begriffs> Hm, I'm on a mac. It looks like it may be influenced by ~/.cabal/config
21:17:09 <benzrf> hmmm, what is the kind AnyK
21:17:54 <roconnor> Where is the monad instance for (->) ?
21:18:58 <bergmark> roconnor: GHC.Base says ghci :i
21:20:01 <benzrf> @src ((->) r) (>>=)
21:20:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:20:05 <benzrf> lame
21:20:20 <johnw> what operator were you expecting (->) to be?
21:20:40 <benzrf> johnw: huh?
21:20:41 <johnw> oh, I see
21:20:42 <johnw> n/m
21:20:45 <benzrf> haha
21:20:52 <benzrf> @src Maybe (>>=)
21:20:52 <lambdabot> (Just x) >>= k      = k x
21:20:52 <lambdabot> Nothing  >>= _      = Nothing
21:22:49 <dolio> @src (->) (>>=)
21:22:50 <lambdabot> f >>= k = \ r -> k (f r) r
21:23:05 <benzrf> oh
21:23:07 <benzrf> huh
21:24:00 <benzrf> (r -> a) -> (a -> r -> b) -> (r -> b)
21:24:05 <benzrf> :d
21:25:15 <jle`> yeah it's weird, but @src is basically an ad-hoc text file living on the lambdabot server
21:25:17 <benzrf> is there a class that defines something functionally identical to fmap but takes a type of kind * -> * -> *
21:25:50 <jle`> what would the type of fmap be
21:25:59 <benzrf> class HKFunctor h where hkFmap :: (a -> b) -> h v a -> h v b
21:26:04 <benzrf> ^is this a thing
21:26:13 <johnw> Profunctor might fix that description, but then you also have to provide lmap
21:26:19 <benzrf> johnw: yeah
21:26:30 <johnw> why not just instance Functor (h v)?
21:26:40 <tesserhact> Anyone wanna help a poor noob out with some Hashcat syntax? :'3
21:26:42 <jle`> your thing is identical to just a Functor
21:26:58 <jle`> but that function also fits Bifunctor too with out left
21:27:15 <jle`> tesserhact: just post it :)
21:27:26 <jle`> you will get a better answer than way
21:27:53 <jle`> if nobody wants to help you, you won't get an answer... if somebody does, you will :)
21:28:00 <jle`> avoid boolean blindness!
21:28:11 <jle`> demand a proof with your test
21:28:20 <tesserhact> What do I need to append to make sure the bruteforce is only going through 0-9 A-F and at a length of 10
21:28:49 <tesserhact> Wanna see how long out default WPA keys will last :p
21:29:25 <jle`> well you can enumerate all strings of length n
21:29:29 <tesserhact> hashcat.net is down and that was the only helpful forum :c
21:32:12 <jle`> > replicateM 4 (['0'...'9'] ++ ['A'...'F'])
21:32:19 <lambdabot>  Couldn't match type ‘GHC.Types.Char’
21:32:19 <lambdabot>                with ‘(c0 -> f c0) -> s -> f t’
21:32:19 <lambdabot>  Expected type: Control.Lens.Type.LensLike f s t c0 c0
21:32:19 <lambdabot>    Actual type: GHC.Types.CharCouldn't match type ‘GHC.Types.Char’ with ‘p a ...
21:32:19 <lambdabot>  Expected type: Control.Lens.Type.Over p f c0 c0 a b
21:32:29 <jle`> oh
21:32:39 <jle`> > replicateM 4 (['0'..'9'] ++ ['A'..'F'])
21:32:40 <lambdabot>  ["0000","0001","0002","0003","0004","0005","0006","0007","0008","0009","000A...
21:33:09 <jle`> will enumerate through all 4 character combinations of the given characters
21:33:34 <pavonia> > length $ replicateM 4 (['0'..'9'] ++ ['A'..'F'])
21:33:36 <lambdabot>  65536
21:34:25 <m09> > 16 ^ 4
21:34:27 <lambdabot>  65536
21:34:33 <m09> > 16 ^ 10
21:34:34 <lambdabot>  1099511627776
21:34:38 <NinjaPenguin> In that case where you get the length, will it somehow calculate the length or will it go through all combinations and get the length?
21:35:18 <m09> length will go through the list and just evaluate constructors, not the inner thunks
21:35:23 <jle`> it doesn't compute the contents of every element
21:36:02 <jle`> but it generates the empty cells, so to speak
21:36:21 <jle`> hm.
21:36:22 <m09> NinjaPenguin: you can try it out in ghci
21:36:24 <m09> let a = map (+1) [1..10]
21:36:32 <m09> :sprint a
21:36:35 <m09> length a
21:36:38 <m09> :sprint a
21:36:47 <jle`> @src length
21:36:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:37:48 <NinjaPenguin> m09: Ah, thanks, that does clarify it. So, when something isn't needed, it doesn't bother 'constructing' it?
21:37:58 <m09> yup that's lazy evaluation
21:38:33 <jle`> you can see it in action yourself if you try evaluating length by hand
21:38:47 <NinjaPenguin> Ah, thanks. I have read about lazy evaluation, I just didn't know how it works. :p
21:38:49 <jle`> by writing your own sensible length function
21:39:54 <jle`> length [] = 0; length (_:xs) = 1 + length xs
21:39:57 <jle`> for example
21:40:49 <jle`> try evaluating length [long computation, undefined, 7] by hand
21:41:02 <jle`> assuming you explode if you attempt to evaluate long computation
21:43:10 <sinelaw> my code is using errorName
21:43:15 <sinelaw> I can't seem to find where it's coming from
21:43:18 <sinelaw> @where errorName
21:43:18 <lambdabot> I know nothing about errorname.
21:46:30 <jle`> sinelaw: try hoogle or hayoo?
21:48:18 <sinelaw> no luck
21:48:48 <sinelaw> oh got it. it's from ForeignPtrWrap. hayoo!
21:48:52 <sinelaw> thanks
21:49:55 <sinelaw> what's the idea of newForeignPtr, if there's no guarantee it will ever run the finalizer?
21:51:11 <sinelaw> actually it says it will run before the program exits. the no guarantee is for the variant in Foreign.Concurrent
22:03:02 <hunt> guys im in a situation
22:03:11 <bergmark> is this good or bad
22:03:12 <hunt> im trying to work with opengl, and all my graphics code is turning out alright
22:03:14 <hunt> this is bad
22:03:16 <hunt> but
22:03:29 <hunt> i need to be able to render stuff while i wait for the user to write something into stdin
22:03:30 <hunt> and i cant
22:03:42 <hunt> i have no clue what to do
22:03:56 <hunt> i feel in my bones that i should use concurrency but i dont want to if i dont have to
22:04:08 <jle`> why not?
22:04:12 <bergmark> (warning: i have no clue about opengl) Are you reading from stdin in a separate thread?
22:04:49 <hunt> jle` because i ahve no idea how to
22:05:01 <hunt> bergmark: im not and i feel like i should but i dont really know anything about concurrency
22:05:08 <hunt> i dont know if concurrency would make this possible or not
22:05:19 <bergmark> it's really easy in haskell :-)
22:05:27 <hunt> got a tut?
22:05:35 <hunt> or something
22:05:46 <bergmark> @google marlow concurrent
22:05:47 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
22:05:47 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
22:06:01 <boboman13> hi guys, noob here
22:06:03 <boboman13> had a quick question
22:06:11 <hunt> bergmark: should i read all of that
22:06:16 * hackagebot shared-buffer 0.1.0.7 - A circular buffer built on shared memory  http://hackage.haskell.org/package/shared-buffer-0.1.0.7 (JohnLato)
22:06:18 <bergmark> hunt: if you want to know all of that :-o
22:06:21 <boboman13> is haskell a full programming language? or is it more aimed towards a smaller niche of programs?
22:06:28 <boboman13> for example, a graphics language
22:06:31 <hunt> bergmark: eventually... what would my issue be called?
22:06:42 <hunt> boboman13: its a general purpose language
22:06:51 <bergmark> hunt: basically you need forkIO and some MVars/TVars to communicate between threads
22:06:59 <hunt> boboman13: you can write all programs you would want
22:07:07 <boboman13> ah i see, thank you
22:07:18 <boboman13> and what about speed, what other languages is it comparable to?
22:07:27 <ReinH> boboman13: It's comparable to C.
22:07:32 <hunt> boboman13 it actually gets pretty close to C regularly
22:07:42 <boboman13> impressive *whistles*
22:07:52 <boboman13> and it compiles into a binary, right?
22:07:56 <hunt> yup
22:07:57 <ReinH> Yes, it's a compiled language.
22:08:08 <bergmark> it's all you ever wanted, and more
22:08:18 <shachaf> It's comparable to C in that you can compare it to C and find out that it's slower.
22:08:21 <hunt> bergmark: alright, thanks. question 2 is can i do this tonight
22:08:33 <hunt> shachaf: but not by too much
22:08:35 <ReinH> shachaf: thanks for that correction
22:09:10 <boboman13> shacaf: xD
22:09:14 <boboman13> wow, thanks a lot guys
22:09:16 <boboman13> me gusta already
22:09:32 <boboman13> now i just need to like the syntax and i'll be off to the races
22:09:49 <hunt> boboman13: have you looked at it yet?
22:10:02 <bergmark> hunt: i think you could, the basics are simple
22:10:20 <boboman13> hunt: a little bit, i really like the array handling with map and the.. (1,"chris") thing is cool, just forget the name
22:10:38 <bergmark> tuples
22:10:44 <boboman13> but i've come to know that you only really know a language's syntax (and library) after you write your first program
22:10:53 <shachaf> I like Haskell and I think it has enough nice things that you don't need to make up new ones.
22:11:07 <ReinH> I'd say that a language with Haskell's features that can run slightly slower than C is rather impressive
22:11:19 <ReinH> but if you want to reduce that down to "it's slower" then yes I suppose you can
22:12:16 <boboman13> next on the list, are there any extremely useful tools that you wish haskell had?
22:12:26 <boboman13> for example, I tried C out... then realized there were no string concatenation operators
22:12:52 <hunt> boboman13 a bigger community
22:13:14 <hunt> but dont listen to me
22:13:17 <hunt> i barely know haskell
22:13:37 <boboman13> haha
22:14:15 <boboman13> all a language needs is an epic program to be written in it to fully explode into popularity
22:14:30 * boboman13 slowly looks at ruby on rails, slowly looks back
22:15:03 <ReinH> Ah yes the framework that launched a thousand failed startups ;)
22:15:03 <LordBrain> no shortage of operators here...
22:15:23 <ReinH> We like string concatenation so much we provide you with more than one operator for it! ;)
22:15:36 <boboman13> xD more than one?
22:15:53 <ReinH> (++) and (<>) for starters
22:16:04 <LordBrain> > "Hello " <> "World!"
22:16:06 <lambdabot>  "Hello World!"
22:16:11 <bergmark> boboman13: there's room for improvement in the non-programming area, maintaining packages and such, it's gotten a lot better in the last year though
22:16:14 <LordBrain> > "Hello " ++ "World!"
22:16:15 <lambdabot>  "Hello World!"
22:16:21 <ReinH> And if you want me to get pedantic, you can define a pretty large number of extra ones yourself if you want to ;)
22:16:36 <boboman13> what about integer plus string?
22:16:40 <boboman13> > "Hello" ++ 1
22:16:41 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
22:16:41 <lambdabot>    arising from the literal ‘1’
22:16:58 <LordBrain> > "Hello " ++ (show 1)
22:16:59 <lambdabot>  "Hello 1"
22:17:01 <ReinH> boboman13: Not being able to do that is a feature.
22:17:15 <boboman13> feature because of speed?
22:17:18 <bergmark> that's one of the worse error messages you get from ghc by the way, when you see "no instance for" it usually means "wrong type"
22:17:25 <ReinH> boboman13: because of safety
22:17:36 <boboman13> how does it make it safer?
22:18:00 <ReinH> It prevents an entire class of errors that arise from accidentally trying to add strings to numbers
22:18:05 <ReinH> which doesn't really make sense when you think about it
22:18:07 <boboman13> ah
22:18:18 <LordBrain> <> is actually a general operator that works for any monoid, its kind of useful for string concat because before they invented IsString, ++ only worked on a certain kind of string... i think that is fixed now tho.
22:18:24 <bluebelle> how do you create a function that do IO continuously until EOF and return a list in the end? I always get type mismatch between [] and IO
22:18:42 <ReinH> bluebelle: what type do you want this function to have?
22:18:55 <bluebelle> IO String -> [Person]
22:19:33 <boboman13> oh and right, is there any sort of compability guarantee, or is it out of active and groundbreaking development?
22:19:44 <ReinH> boboman13: "compatibility guarantee"?
22:20:32 <ReinH> bluebelle: Is it possible to write a function `IO a -> b'? for any a, b?
22:20:44 <boboman13> like, go 1 has a "compatibility guarantee" to guarantee that all programs written with go 1 won't break with any sub release until go 2
22:20:49 <boboman13> is there any danger of breaking with haskell?
22:21:53 <ReinH> boboman13: For a while now a philosophy of Haskell has been "avoid success at all costs", and the community has tolerated perhaps a bit more such breakage than some other communities because we appreciate being able to move the state of the art forward.
22:21:55 <LordBrain> there's effort to keep backward compatibility, but in all honesty, haskell hasn't had much of a long stretch between breaking changes, relative to other languages. there is the standard you could stick to, etc.
22:22:03 <bergmark> boboman13: there are breaking changes, but if it's something major it goes through a deprecation step
22:22:09 <ReinH> boboman13: although Haskell is becoming more mature and some people are parsing that as "avoid (success at all costs)" now ;)
22:22:32 <boboman13> i see
22:22:48 <boboman13> the site says it went through 20 years of development... or something along those lines, is this true? since 1994?
22:22:56 <ReinH> Haskell does have a versioning plan for libraries that attempts to do something similar
22:23:03 <hunt> why isnt fix included automatically?
22:23:05 <ReinH> boboman13: That's about right.
22:23:15 <ReinH> hunt: which "fix" and included in what?
22:23:25 <bergmark> hunt: probably because it's not used commonly enough
22:23:37 <hunt> the fix that calls a function on itself infinitely
22:23:55 <hunt> is there a naturally included function that can create loops like this easily
22:24:08 <boboman13> why wouldn't the language be stabilized by now then if its been in development for 20 years?
22:24:13 <bluebelle> Oh I just realized that you can't do that in Haskell. Thanks.
22:24:16 <boboman13> "stabilized"
22:24:55 <ReinH> bluebelle: if you want to "do" IO and return a [Person], you probably want a value of type IO [Person]
22:25:10 <LordBrain> there are two standards, haskell 98, and haskell 2010... 98 is so old that people dont use it, and 2010 is new enough that its not yet clear how valuable it will be.. more over new features have been released since the standard that are just too good for a lot of developers
22:25:26 <bergmark> hunt: if you want fix just import it? :-)
22:25:32 <bergmark> it's in base so it's always available
22:25:46 <boboman13> muy bueno
22:25:47 <boboman13> gratzi
22:25:50 <boboman13> OH
22:25:51 <boboman13> more questions
22:25:52 <boboman13> yay
22:26:01 <ReinH> boboman13: we like questions :)
22:26:21 <boboman13> what about dependency management, how easy is using a library from github lets say and popping it into my own application?
22:26:47 <bergmark> boboman13: most packages are on hackage, which makes it easier to use them
22:26:48 <m09> with cabal it's extremely simple
22:26:59 <hunt> guys i made an infinite loop in ghci how do i stop it
22:27:03 <ReinH> boboman13: we have a packaging system called cabal, which is frankly somewhat of a weak point in the ecosystem
22:27:06 <m09> ctrl c
22:27:10 <hunt> doesnt work
22:27:18 <m09> close your terminal
22:27:19 <LordBrain> bobobo1618, cabal install library, put it in your .cabal file, and get to work...
22:27:19 <boboman13> are you on mac?
22:27:20 <ReinH> boboman13: which is to say that it's the one of the worst packaging systems... aside from all the other packaging systems.
22:27:33 <hunt> m09 it crashed anyways so i didnt need to
22:27:51 <hunt> boboman13: me?
22:27:52 <boboman13> if its so bad, why hasn't anyone made a replacement?
22:27:55 <ReinH> It's been sufficient to manage dependencies in large Haskell libraries and applications
22:27:59 <boboman13> hunt: yus
22:28:02 <ReinH> boboman13: because it's a hard problem :)
22:28:21 <hunt> boboman13: ubuntu, ive been on mac for most of my work with haskell though, just switched over like 3 days ago for unrelated reasons
22:28:36 <boboman13> hunt: are you new to haskell?
22:28:48 <hunt> boboman13: like 2-3 months in
22:28:54 <boboman13> okay then, what about file / code relations
22:29:12 <boboman13> is there any sort of package system? (not package dependency, sort of like java package com.test.net etc)
22:29:13 <bergmark> boboman13: what does that mean?
22:29:25 <boboman13> like, uh... its hard to explain
22:29:30 <hunt> like import?
22:29:33 <bergmark> module hierarchy?
22:29:33 <m09> yup there are modules
22:29:39 <boboman13> module hierarchy, yeah
22:29:41 <boboman13> importing modules
22:29:49 <boboman13> how is a module defined?
22:29:58 <LordBrain> in modern haskell there is, its not in the older standard 98
22:29:59 <boboman13> is it one module per directory, and each directory can have a few files?
22:29:59 <m09> module foo () where ...
22:29:59 <bergmark> each file is its own module
22:30:05 <tesserhact> What do I need to append to make sure the bruteforce is only going through 0-9 A-F and at a length of 10 in Hashcat?
22:30:15 <boboman13> mmm, each file is its own module
22:30:18 <boboman13> that reminds me of rust
22:30:19 <boboman13> i hated rust
22:30:20 <hunt> boboman13: http://learnyouahaskell.com/modules
22:30:38 <hunt> boboman13: thats a red flag, rust is reallly similar to haskell syntactically
22:30:40 <ReinH> tesserhact: what do you mean?
22:30:44 <m09> hating rust is sad, it's a pretty good language
22:30:54 <ReinH> it's an amazing language
22:31:05 <boboman13> i hated rust for some of the syntax and the module system...
22:31:08 <boboman13> thats not good
22:31:30 <hunt> boboman13: what was so bad about the syntax?
22:31:31 <ReinH> the sigils can be a bit much, but the real power of a language is in its runtime and abstractions, not its syntax
22:31:41 <hunt> a lot of the power comes from the weirdness of the syntax boboman13
22:32:01 <hunt> er, elegance
22:32:06 <ReinH> hunt: iirc some of the sigils are being replaced with actual identifiers though?
22:32:09 <ReinH> which seems fine to me
22:32:11 <tesserhact> Trying to get Hashcat to bruteforce a wpa hash using only 0123456789ABCDEF and is 10 characters long only
22:32:16 <boboman13> hunt: i got very confused at the lack of just simple returned values (i take it back, it wasn't all syntax) and the little backtick things
22:32:40 <hunt> Reinh: i have no clue what sigils/identifiers are :P
22:32:58 <boboman13> i mean, some of the functions looked very usable, but would then return this odd object that would require another 2-3 lines of code just to get the one value that is *actually* returned
22:33:16 <hunt> boboman13: ah ok, just dont start with IO and by the time you get there it wont be weird anymore
22:33:30 <boboman13> okey
22:33:32 <hunt> boboman13: (for haskell), and i think if you have the right learning resources you can get around that problem
22:33:41 <hunt> boboman13: @lyah
22:33:44 <hunt> @lyah
22:33:45 <lambdabot> Unknown command, try @list
22:33:50 <hunt> am i doing it wrong?
22:34:11 <hunt> @list
22:34:12 <lambdabot> What module?  Try @listmodules for some ideas.
22:34:12 <boboman13> i despised the module system though, so hopefully it'll turn out better than rust :) thanks for the help guys
22:34:17 <boboman13> @listmodules
22:34:17 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
22:34:34 <hunt> how do i link him to learn you a haskell guys
22:34:37 <tesserhact> eg cudaHashcat64 -m 2500 -a 3 (characters to use) (length) -o output.txt hash.hccap
22:34:45 <m09> @where lyah
22:34:45 <lambdabot> http://www.learnyouahaskell.com/
22:34:49 <hunt> ah
22:34:59 <tesserhact> but I don't know how to tell Hashcat to use those characters
22:35:00 <hunt> good place to learn boboman13 ^
22:35:03 <tesserhact> or the length
22:35:14 <boboman13> hunt: thanks
22:35:47 <LordBrain> what is Hashcat?
22:35:55 <tesserhact> Hash cracking
22:36:04 <LordBrain> oh
22:36:17 <tesserhact> like aircrack-ng
22:36:35 <tesserhact> only it uses CUDA and is more efficient
22:36:43 <LordBrain> cool
22:36:52 <LordBrain> is it written in haskell?
22:37:01 <tesserhact> ...
22:38:04 <LordBrain> i ask because you're showing the command line, not the code
22:38:22 <tesserhact> That would be a fair assumption
22:38:33 <tesserhact> I made a bad assumption in what this channel was for xD
22:48:38 <excarna> is it possible to run IO actions in a Spec?
22:49:25 <LordBrain> @hoogle Spec
22:49:27 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification module Graphics.Rendering.OpenGL.GL.Texturing.Specification
22:49:27 <lambdabot> GHC.Exts data SpecConstrAnnotation
22:49:27 <lambdabot> Language.Haskell.Syntax Special :: HsSpecialCon -> HsQName
22:49:49 <LordBrain> What's a Spec?
22:51:05 <ReinH> I'm not sure, but the answer is almost certainly "No".
22:51:18 <ReinH> Well that's not true, Spec could be a monad transformer
22:52:26 <excarna> ah sorry
22:52:30 <excarna> it's from Hspec
22:52:59 <excarna> in any case it doesn't look like a MonadIO
22:53:16 <excarna> @hoogle SpecM
22:53:18 <lambdabot> No results found
22:53:27 <excarna> hm
22:53:56 <LordBrain> @hoogle hspec
22:53:56 <lambdabot> package hspec
22:53:56 <lambdabot> package hspec-discover
22:53:56 <lambdabot> package hspec-expectations
22:54:04 <LordBrain> @type hspec
22:54:06 <lambdabot> Not in scope: ‘hspec’
22:55:08 <c_wraith> excarna: definitely can't run IO inside a spec.
22:55:16 <excarna> c_wraith: damn. thanks
22:56:18 <avenge> Can a GHC expert help me understand the following runtime error?
22:56:18 <avenge> test: Oops!  Entered absent arg a_sZ3g{v} [lid] bytestring-0.10.4.0:Data.ByteString.Internal.ByteString{tc r4x}
22:56:18 <c_wraith> excarna: check out http://hackage.haskell.org/package/hspec-expectations-lifted though
22:56:30 <c_wraith> excarna: that package *might* be able to do what you want
22:56:54 <c_wraith> excarna: oh, nevermind.  It does something different.
22:57:13 <solirc> excarna: You still can run IO around every spec item
22:57:27 <excarna> solirc: can I run it around a specific one?
22:57:31 <solirc> and hspec2 will have better support for that
22:57:34 <excarna> it looks like a tree of specs
22:57:47 <solirc> type Spec = SpecM ()
22:57:59 <drupzky> is there an easy way (maybe per ghci) to find all superclasses for a class? (I need all superclasses of RealFrac)
22:58:03 <solirc> SpecM is just a writer monad for a spec tree
22:58:16 <solirc> or rather a forest
22:58:22 <excarna> so I can "around" a leaf node?
22:58:24 <c_wraith> avenge: it looks to me like something was doing unsafe bytestring operations and corrupted memory
22:59:13 <solirc> excarna: yes
22:59:23 <excarna> solirc: nice, thanks
22:59:33 <solirc> but if it is just one node, you could also do it inside the spec item
23:00:04 <avenge> c_wraith: Hmm... thanks.  Can you explain in a bit more detail so I can track down.  The annoying thing is it only happens in out-of-directory cabal sandboxes, not when I run it within the same directory (and hence package).
23:00:56 <c_wraith> avenge: hmm.  do you have multiple versions of bytestring installed in those sandboxes?
23:01:29 <avenge> No, just 0.10.4.0.
23:02:10 <avenge> Do you know what entered absent arg means?
23:04:41 <c_wraith> It has to do with the memory representation for thunks
23:04:47 <LordBrain> actually, the docs use the before to run an io action
23:04:50 <LordBrain> in a Spec
23:04:51 <c_wraith> "enter" means it tried to evaluate something
23:05:22 <LordBrain> http://hspec.github.io/writing-specs.html <-- see 'before' at the bottom of the page
23:05:22 <c_wraith> so "entered absent arg" would imply it tried to evaluate something it could tell wasn't a thunk based on its memory contents
23:06:27 <sloopjohnb> so ok, im trying to write a makefile which will run some commands if files compile successfully, but && doesnt work with ghc afaik, any tips?
23:06:31 <avenge> c_wraith: Okay, thanks, that helps.  Probably some kind of blaze-builder buffer overrun or something.  I will investigate.
23:08:29 <sloopjohnb> is there any equivalent to && or any flag for ghc that will allow it to prevent further commands form being executed if it fails?
23:09:56 <bergmark> sloopjohnb: are you sure about this?
23:12:00 <LordBrain> the old ghc supports &&
23:12:09 <LordBrain> what version are you using sloopjohnb ?
23:12:28 <sloopjohnb> LordBrain: 7.8.2
23:13:09 <sloopjohnb> bergmark: yea i think so, its still running the remainder of the line irregardless of whether or not it compiled :(
23:14:34 <LordBrain> ghc-7.4.1 works at the bash prompt
23:16:29 <bergmark> sloopjohnb: i just tried on 7.8.2 and it has the correct exit code
23:18:25 <LordBrain> works in 7.6.3 as well
23:21:03 <LordBrain> sloopjohnb, maybe post your makefile
23:21:26 <LordBrain> i'll look at it
23:25:12 <avenge> c_wraith: I tracked the problem down to the use of NOINLINE in a two-line function, which itself is inlined.
23:25:41 <avenge> Is there a reason this error could happen with NOINLINE?
23:25:50 <c_wraith> I have no idea, there.
23:26:08 <c_wraith> That's worth asking people who know more about ghc than me
23:26:08 <avenge> The code looks like this:
23:26:08 <avenge> dbSelect c dbs = map lookupRow <$> query_ c q
23:26:09 <avenge>   where q = renderDBSelect dbs; {-# NOINLINE q #-}
23:26:22 * hackagebot Elm 0.12.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.2 (EvanCzaplicki)
23:26:24 * hackagebot elm-get 0.1.2 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.2 (EvanCzaplicki)
23:26:49 <avenge> Since this has to do with thunks, I wonder if somehow NOINLINing something that might have been a CAF anyway can cause issues.
23:27:01 <c_wraith> What version of GHC is this on?
23:27:15 <avenge> 7.8.2.  Works fine with 7.6.x.
23:27:31 <c_wraith> Sounds like something worth reporting to GHC trac
23:27:57 <avenge> c_wraith: Okay, thanks for your help.
23:27:58 <c_wraith> As that sounds like a bug in the new codegen, which is (iirc) the default in 7.8, but not in 7.6
23:36:54 <Cutegirl1990> Check out my blog, 100% legit. http://www.nattstad.se/sofi.carlsson.9 :)
23:39:11 * sloopjohnb is ashamed of cutegirl1990
23:44:16 <jle`> well...sounds legit.
23:44:26 <jle`> Fuuzetsu: is that one of your creations? :P
23:48:47 <sloopjohnb> i got it working LordBrain
23:56:25 * hackagebot transformers-compat 0.3.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.2 (EdwardKmett)
23:59:02 <osa1> how can I learn more about how LambdaCase syntax is desugared? I'm searched for it in GHC source but couldn't find anything using "lambdacase" as keyword...
