00:01:48 <jle`> woo hoo
00:07:57 * hackagebot kmeans-par 1.4.2 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.4.2 (vi)
00:07:57 * hackagebot snap-loader-dynamic 0.10.0.2 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.2 (DougBeardsley)
00:14:31 <tdammers> peeps, quick thought here:
00:14:45 <tdammers> I'd like to inject build timestamps into my program
00:15:08 <tdammers> was wondering if it would be feasible to do this with TH/QQ
00:15:31 <tdammers> idk, something like `putStrLn $(buildTimestamp)`
00:15:34 <johnw> you could do it pretty easily with pgmF
00:15:44 <johnw> or TH
00:16:08 <tdammers> let me hoogle that
00:16:18 <johnw> pgmF sets the "program formatter"
00:16:23 <remib> Hi.
00:16:30 <johnw> you could write a simple one to substitute __TIME__ for the build time, for example
00:18:01 <tdammers> or I could just use CPP :o
00:18:29 <remib> I'm wondering: with the guarantee that a function is deterministic on its arguments, does haskell, for instance when running fibonacci, automatically memoize/cache functions call so that even if the algorithm looks exponential to us, it is effectively run in poly time ?
00:19:03 <tdammers> I would have to force recompilation though to make sure the build timestamp is accurate
00:22:16 <dmwit> remib: No.
00:22:28 <dmwit> remib: It's too hard to analyze when the memory tradeoff is worth the CPU advantage.
00:23:08 <adas> but i think memoization can be explicitly done
00:23:15 <dmwit> Yes, explicit memoization is easy.
00:23:20 <dmwit> Let and where bindings introduce sharing.
00:23:59 <remib> mmh, ok
00:24:00 <dmwit> There's slews of information about this on the web.
00:24:27 <adas> but isn't there a monad for memoization that implicitly takes the 'a' in 'm a' and memoizes it?
00:24:50 <remib> but with today's memory capacity, isn't the tradeoff often worth ?
00:25:03 <dmwit> Often, yes.
00:25:08 <dmwit> When it is worth it, you may ask for it.
00:25:27 <tdammers> it's not really about total memory capacity, more about cache performance
00:25:47 <dmwit> The question is not, "is it worth it for Fibonacci?", the question is, "can I write a program which evaluates other programs and tells when the tradeoff is worthwhile?".
00:25:47 <tdammers> you can have a TB of RAM and still be memory-bound simply because you're producing cache misses all over the place
00:26:14 <dmwit> The answer to the latter question is "heck no" because you don't know all the things the programmer does about how much memory will be available on the target machine and how painful CPU costs are.
00:26:30 <remib> Yeah, semms right. Thanks!
00:37:46 <pavonia> It works, finally! I made this stupid error of peeking a Ptr after the DLL had already been unloaded :/
00:42:52 <pingu> Anyone know how to call sync() on a posix system?
00:43:00 <pingu> It's a little tricky to google for
00:43:53 <pavonia> pingu: Is that a C lib function?
00:43:58 <pingu> pavonia: yes
00:44:08 <pingu> it's in #unistd.h
00:44:24 <pavonia> You need the FFI for this, here's a nice introduction http://en.wikibooks.org/wiki/Haskell/FFI
00:44:45 <pingu> pavonia: okay, guess I'll FFI it. Thank.s
00:45:13 <frank___> Hey guys, how impossible is build a compiler using Haskell??
00:46:00 <pavonia> very little impossible
00:46:04 <pingu> not much impossible
00:46:06 <erikd> frank___: few languages are better for writing compilers. GHC is written mostly in haskell (C for the runtime)
00:46:32 <erikd> there are a number of compilers written in haskell
00:47:37 <jle`> frank___: haskell is actually known for being one of the best languages for writing compilers
00:47:44 <jle`> so..funny you shold mention that
00:48:09 <frank___> where i can find the source code of GHC??
00:48:50 <erikd> @google ghc source code
00:48:51 <lambdabot> https://github.com/ghc/ghc
00:49:05 <Heather> Hi is there something for data graphs visualization on haskell? or should I better use something compiled to js for it?
00:49:30 <frank___> Ty guys
00:51:26 <Walther> Is there a nice beginner tutorial somewhere for IO in haskell? I've looked at the IO Monad, State monad, Writer and the like and it all seems very complicated and there aren't that many concrete examples
00:51:58 <m09> Walther: what's complicated about them?
00:52:56 <jle`> Walther: your problem might be that State, Writer, IO, etc. have very little in common
00:53:09 <jle`> that being said, i always liked monochrom 's io tutorial
00:54:55 <remib> Walther: http://www.haskell.org/haskellwiki/IO_inside#IO_actions_as_values was useful in my case
00:55:26 <remib> (without the #...)
00:55:26 <Walther> I know one should separate pure and io, but there are cases where you e.g. want to log server responses and occasionally respond based on algo that might utilize current last three log entries or the like. And passing the whole bunch through the main loop as an argument wouldn't really be fun at all
00:56:00 <jle`> remib: that tutorial looks harmful, upon a glance
00:56:09 <johnw> Walther: that oftens requires the use of something like StateT over IO
00:57:15 <remib> jle` : why ?
00:57:47 <jle`> well, it uses the IO a ~ RealWorld -> (a, RealWorld) model
00:57:47 <Walther> Mmh. I really like haskell with pure things - have done a bunch of project euler with it, for example - but with "real world stuff" Haskell seems to have a bit ...special learning curve :)
00:57:56 <jle`> which is generally considered harmful
00:58:21 <Walther> Well, s/real world stuff/IO/
00:58:28 <johnw> Walther: you can often cordone off the IO activities in your program, so that they rely on non-IO functions to do most of the computations needed
00:58:48 <johnw> every program's "spine" is in IO, since it must execute from main
00:58:53 <johnw> the question is how much of the meat is in IO too
00:59:12 <remib> jle`: could you elaborate ?
01:00:51 <jle`> remib: these days it is more in vogue to think about IO as some sort of ADT instruction graph, or sort of a metaprogramming/language building tool
01:00:57 <jle`> program building tool
01:01:27 <jle`> as in, IO a is a noun, not a verb (like world -> (a, world) implies)
01:01:54 <johnw> I think of a -> IO b as a pure function that evaluates to an IO action
01:02:22 <jle`> an IO String is some sort of data structure (noun) representing instructions to compute a String
01:02:52 <jle`> sort of like /bin/ls contains instructions to compute a list of filepaths
01:03:01 <jle`> ls :: IO [FilePath]
01:03:05 <shachaf> Is there any function in this worldview that isn't pure?
01:03:16 <conal> the world -> (a,world) story is inaccurate, as that model can't describe concurrency (especially the non-deterministic kind) or interaction, both of which Haskell's IO has.
01:03:22 <jle`> the place where world -> (a, world) falls apart the mos is concurrency, i think
01:03:25 <jle`> oh conal beat me
01:03:27 <jle`> darn
01:03:38 <johnw> shachaf: the function that executes the result of calling main isn't pure
01:03:56 <shachaf> There's no such function as far as I know.
01:03:56 <conal> and it gives people the impression that we understand something that we really don't.
01:04:02 <johnw> shachaf: ?
01:04:16 <johnw> are you meaning that it isn't a "function"?
01:04:53 <shachaf> That what isn't a function?
01:05:07 <jle`> world -> (a, world) falls apart when trying to understand concurrency, whereas the 'object representing an io computation' excels pretty handily
01:05:09 <shachaf> conal: It's also unhelpful pedagogically (even if you just want to understand IO as much as you understand, say, C) and also not particularly related to GHC's actual implementation (which uses an unfortunate choice of names).
01:05:47 <jle`> forkIO, for example, is an IO object transformer
01:06:32 <remib> jle`: that's sad, I liked the "world" interpretation/explanation
01:06:45 <jle`> or at least it makes sense to pass an "object representing io actions" to forkIO, which then takes that object and executes it in parallel
01:07:14 <shachaf> @quote monochrom students
01:07:14 <lambdabot> monochrom says: <monochrom> 90% of the students do that. you cannot explain it by "they don't know better". if they don't know better, you should be seeing fair coin flips. <monochrom> you must accept that they know --- they know worse.
01:07:29 <conal> remib: it's a fine story as long as no one believes it.
01:08:11 <jle`> remib: i think the instruction object is actually a more fascinating interpretation if you give it enough thought
01:08:32 <jle`> in this way you can design your own little "IO monads"
01:08:53 <jle`> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
01:08:54 <Qfwfq> I'm doing OverloadedLists wrong. How? http://lpaste.net/4318118969316737024
01:09:00 <Qfwfq> Use seems consistent with http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/type-class-extensions.html.
01:09:33 <jle`> his IO object/monad is literally just data IO a = Return a | Put String (IO a) | Get (String -> IO a) ... literally just a normal data type
01:09:35 <remib> jle`: this article explain your idea ?
01:09:46 <jle`> this article explains why the idea is more interesting :)
01:09:55 <remib> Nice, thank you!
01:10:23 <jle`> np!
01:10:36 <jle`> actually i first came upon the world -> (a, world) explanation too when i was learning haskell
01:10:42 <Qfwfq> Oh, I don't think the vector package instances the FromList typeclass?
01:10:46 <jle`> i think it was none other than shachaf who convinced me otherwise, about a year ago
01:10:51 <jle`> i wonder why it is so prevalent
01:10:52 <shachaf> Qfwfq: From the error message it looks like Vector doesn't define an instance.
01:11:13 <Qfwfq> That's it. I thought `vector` was in `base` for some reason.
01:11:33 <Qfwfq> I'll open a pull request.
01:11:36 <johnw> jle`: how are exceptions represented in that model?
01:11:58 <jle`> the world -> (a, world), or IO as data?
01:13:33 <jle`> remib: be aware that the more trendy way to implement what that article suggests is using free monads, as of late.  free monads are at their peak hype right now
01:13:49 <johnw> world->(a,world)
01:13:52 <remib> jle`, I personnaly liked it because: If you say IO is just data, why can't you write a function that simply returns an IO without parameter ? But with the world->a,world view, it is clear that the output must depend on some input.
01:14:24 <shachaf> remib: I don't understand the question.
01:14:44 <shachaf> What is a function that simply returns an IO without parameter?
01:14:49 <jle`> i think the question is why you can't have an IO a -> a
01:15:05 <jle`> but this is a guess with very vast assumptions based on content of the article he posted earlier
01:15:38 <remib> Yeah, I think my question doesn't make sense.
01:17:06 <jle`> one reason why you can think that IO a -> a doesn't make sense is because, if IO a represents instructions that a cpu/computer can take to compute an a, then the only way you can get that a is for a computer to literally execute it...shift those registers, read that IO...whereas in Haskell, you can't really "execute" anything, you can only "evaluate" them, like math equations.
01:17:40 <jle`> for an IO a -> a to make sense, you'd need to somehow fully simulate a CPU in pure code, simulating all the IO, etc.  then you could conceivably have one.  but that's pretty impractical, because if you have IO a, you probably want real IO, not simulated pure IO.
01:17:41 <shachaf> I think it might be valuable to make sense of the question, because I suspect this IO-as-data-type thing doesn't work the way you imagine.
01:17:41 <remib> I'll read the article jle` gave and shut up until then :)
01:17:58 * hackagebot tasty-hspec 0.1.0.1 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-0.1.0.1 (RomanCheplyaka)
01:18:04 <shachaf> Which article?
01:18:18 <remib> https://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
01:18:34 <jle`> if you can get a hold of monochrom's io tutorial, it is probably my fav.
01:19:02 <shachaf> I wrote this answer once which is probably the kind of path I'd like sort of thing should be explained along: http://stackoverflow.com/a/13538351/712548
01:21:11 <remib> shachaf: thanks, I'll read it
01:29:56 <AshyIsMe> hmm, has anyone used the hedis package before?
01:30:18 <AshyIsMe> im getting stack space overflows trying to use it to make a fairly large set in redis
01:37:15 <pavonia> Say I have "foo <- (#peek StructType, field)" where filed is of type Foo[], how do you get the next element in that array?
01:37:33 <pavonia> Or alternatively, how do you peek an array of a given size?
01:38:35 <AshyIsMe> can you just use head?
01:38:45 <AshyIsMe> > head [1,2,3]
01:38:47 <lambdabot>  1
01:40:03 <AshyIsMe> if it's in a tuple:
01:40:03 <pavonia> Uh, no, I'm asking about reading foreign data via the FFI
01:40:11 <AshyIsMe> oh, ignore me than haha
01:40:34 <bartavelle> pavonia, I would say it's something like that, except you have to add the offset on your own
01:40:42 <merijn> pavonia: Take a look at Foreign.Util.Array
01:41:18 <merijn> Eh, Foreign.Marshal.Array
01:41:21 <bartavelle> Foreign.Marshal.Array
01:41:25 <bartavelle> ah
01:41:40 <pavonia> Ah, thanks
01:42:59 <nilg> How to use cabal to install a package for all users?
01:43:37 <pavonia> Hhm, but how do I get the Ptr to that specific field?
01:43:41 <lfairy> nilg: use sudo
01:44:23 <nilg> cool thx
01:44:28 <lfairy> nilg: I won't recommend it though, since it may clash with system packages
01:44:51 <nilg> hmmm, I'll take the risk
01:45:31 <lfairy> what's your use case?
01:47:19 <tdammers> I was wondering the same thing
01:47:29 <tdammers> you only need those packages for compiling, not for running
01:47:40 <tdammers> better compile as regular user, then install as root
01:47:41 <pavonia> Answering myself: use the #ptr function
01:48:47 <lfairy> tdammers: better yet, compile in a sandbox
01:53:00 <nilg> lfairy: I work some haskell "script" at work relying on runhaskell, the embarrassing thing is that I'm not suppose to use it at work because "it's too obscure", I was hoping my script would only need runhaskell but it needs extra dependencies. It has to work on multiple machines, for multiple users. I can silently ask the admin to install that for all users, if I start asking all users to install all dependencies it's gonna get
01:53:01 <nilg> ears of the boss... (why does the fucking doesn't understand how awesome haskell is, why do you have to hide to use it, crap...)
01:53:17 <tdammers> lfairy: yeah, that's actually what I meant, pretty much
01:53:40 <tdammers> nilg: if your boss says don't use Haskell, then don't use Haskell
01:54:03 <dEPy> hi
01:54:13 <luite> can you compile it to javascript? node.js isn't too obscure is it? ;)
01:54:29 <tdammers> nilg: you're working in a team. The code is not yours, it's the team's. Using a language that nobody on the team can read except yourself is ruthless, even if it is the best possible language for the job.
01:54:29 <AshyIsMe> is the haskell platform way behind?
01:54:37 <AshyIsMe> why is there no 2014 release yet?
01:54:43 <dEPy> how do I do this:  read number from input, based on the number read that many more numbers, store them in list, process them, print the results
01:54:47 <alpounet> AshyIsMe: right now it is, but a new one is in the works
01:55:01 <alpounet> there isn't a planned release date AFAIK, but it's in the works
01:55:07 <lfairy> nilg: can't you just compile the script? ghc statically links by default
01:55:11 <dEPy> I dont know how to read N numbers after reading N, somehow I can't do it recursively
01:55:53 <nilg> you're write guys, but nobody is ever gonna edit that script except me (well one should never say "never", I know)
01:56:08 <AshyIsMe> alpounet: ok  fair enough
01:56:39 <alpounet> AshyIsMe: there's a mailing list for the platform, if you want to follow that more closely
01:56:51 <drupzky> is there a way to jump to the definition of a function (even when in an other module/file) with emacs?
01:56:54 <tdammers> nilg: doesn't matter. It's not yours.
01:57:51 <tdammers> nilg: Either you convince boss why Haskell is better, or bite the bullet and use something that has a chance of being maintained by whoever follows in your footsteps when you leave.
01:59:17 <dEPy> this is what I got so far: https://gist.github.com/depy/cad4bc1139a6d952f0a4   any ideas?
01:59:26 <mietek> Do package locations added to a Cabal sandbox take precendence over Hackage?
02:02:42 <merijn> dEPy: The type of line 4 is wrong
02:03:04 <dEPy> merijn: you mean line 5? the IO Int ?
02:03:21 <merijn> Line 5 is empty
02:03:26 <dEPy> ah sry
02:03:46 <merijn> dEPy: Question: What is the type of pn?
02:03:51 <dEPy> so, I am passing IO Int into pn instead of regular number?
02:03:53 <statusbot> Status bot enabled for #haskell
02:04:11 <merijn> dEPy: No, that's not the problem
02:04:17 <thoughtpolice> (in case anyone was wondering, that was me)
02:04:46 <dEPy> pn should be   a -> [a]
02:04:51 <dEPy> and a should be Num
02:04:58 <merijn> dEPy: Oh?
02:05:23 <dEPy> merijn: I wanted to read N numbers from input and save them as list kinda
02:05:25 <merijn> dEPy: Line 2 starts a do-block, which monad is this block in?
02:06:24 <dEPy> merijn: I don't quite understand the question.. :S
02:06:39 <dEPy> oh
02:06:57 <dEPy> if I'm using do notation I should 'return' something right?
02:07:01 <vermeille> What's the functions corresponding to `whoAmI f (x:xs) = do { f x; whoAmI f xs }`?
02:07:21 <flux> depy, not necessarily. only pure values need to be 'return'ed
02:07:25 <merijn> dEPy: Well, maybe it will be easier to ignore do-notation for now. Do notation is just syntactic sugar for >>= and >>
02:07:30 <merijn> :t (>>=)
02:07:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:07:33 <merijn> :t (>>)
02:07:34 <lambdabot> Monad m => m a -> m b -> m b
02:08:05 <merijn> dEPy: Everything in the block has to be the same "m", in your case, your use of "readLn :: IO Int" means the block is "IO"
02:08:11 <statusbot> Status Update: This is a test of the emergency broadcast system. -- http://status.haskell.org
02:08:28 <merijn> dEPy: As a result, the output of pn will have to be a value of the form "IO <something>"
02:08:49 <nilg> tdammers: you're right... (and sorry for my stupid ranting, I'm just a bit nervous today)
02:09:23 <dEPy> merijn: ok, I kinda understand, but, is this the right way to do it using recursion or?
02:09:28 <tdammers> nilg: np.
02:09:41 <dEPy> merijn: I kinda can't wrap my head around recursion and monads at once
02:10:45 <merijn> dEPy: The recursion has "roughly" the right shape. Although currently you will return a list of [Int] (since "readLn :: IO Int" will read Int values)
02:11:17 <dEPy> merijn: and I should return  IO [Int] ?
02:11:19 <merijn> dEPy: You probably want to write it as "pn :: Int -> IO [Int]"
02:11:22 <merijn> dEPy: Yeah
02:11:47 <tdammers> nilg: out of curiosity, what does boss want you to use?
02:13:05 <dEPy> merijn: so that means in case of  pn 0 = []   I have to 'wrap' [] in IO ?
02:13:46 <nilg> tdammers: you can guess by yourself, Python (+ other classics), Python is nice really, but I'm starting to *hate* the fact that it's not statically typed, I've already wasted days (if not weeks) of debugging just because of that, not fun...
02:14:16 <ldrndll> mietek: do you mean with add-source? in my experience they seem to
02:15:11 <merijn> dEPy: Correct
02:16:03 <tdammers> nilg: I'm with you on this one... but you could do worse than Python, really
02:16:05 <dEPy> merijn: but there's still something wrong: https://gist.github.com/depy/cad4bc1139a6d952f0a4
02:16:42 <dEPy> merijn: says on line 7 it expected [Int]
02:17:09 <dEPy> merijn: my list construction looks fine to me :S
02:17:24 <tero-_> nilg: a Haskell-to-Python compiler would solve the problem but I guess no one has bothered to write one :)
02:18:30 <tdammers> tero-_: no, it wouldn't. The source code would still be haskell, and people would still be unable to maintain it.
02:19:22 <tero-_> tdammers: that's another issue, but he could tell the boss that "hey, it's python, what's the problem?"
02:20:00 <mietek> ldrndll: yeah.
02:20:17 <tero-_> tdammers: btw. what's worse than python?
02:20:36 <tero-_> php?
02:20:41 <MrGwen> perl :/
02:20:49 <dEPy> php
02:21:45 <tero-_> I've had to write some actionscript lately and I haven't enjoyed it too much..
02:22:18 <OffTheRails> so what languages impress you lot, apart from Haskell, of course?
02:22:21 <MrGwen> I've an error http://lpaste.net/104401 sorry this is my first haskell stuff
02:22:31 <MrGwen> OffTheRails: Smalltalk
02:22:36 <tdammers> tero-_: no, he couldn't, because the source code would still be haskell
02:22:54 <tdammers> tero-_: as far as "worse" goes; PHP kind of stands out
02:25:12 <merijn> dEPy: Well, on line 7 what's the type of num? And what is the type of pentaN?
02:25:12 <rf_> I don't get the language design for PHP at all. :(
02:25:33 <merijn> OffTheRails: Rust is looking promising
02:25:49 <tero-_> scala should be nice and clean but implicit type conversions seem a bit ugly
02:26:29 <OffTheRails> scala is probably my favourite and most practical for me, if it wasn't so needlessly complicated
02:26:29 <merijn> tero-_: I hear more and more that Scala's abuse of implicit conversions and implicit everything actually combines the worst of both worlds in terms of typing complexity and lack of predictability
02:26:38 <dEPy> merijn: well, num is IO Int, and pentaN is  Int -> IO [Int] ?
02:27:02 <merijn> dEPy: Well, first let's "undo" the code
02:27:28 <merijn> @undo do { num <- readLn :: IO Int; num : pentaN n-1 }
02:27:28 <lambdabot> (readLn :: IO Int) >>= \ num -> num : pentaN n - 1
02:27:50 <merijn> So, now there's two things to notice
02:27:53 <merijn> :t (>>=)
02:27:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:28:23 <merijn> dEPy: The left hand side of >>= is "IO Int", so the lambda must be "Int -> IO ?"
02:28:37 <bartavelle> I like how scala type inference was designed very carefuly, so that it only works when you don't really need it
02:28:49 <merijn> i.e. "num :: Int", and applying (:) to Int and "IO [Int]" is a type error
02:29:19 <merijn> dEPy: Additionally, the current code parses as "num : ((pentaN n) - 1)" which is also a type error
02:29:40 <merijn> dEPy: So you'll want to write it as "pentaN (n-1)"
02:29:59 <tdammers> rf_: there is no design beyond "language X has feature Y, I think I have a vague clue what that means, I'll hack it into PHP"
02:30:24 <merijn> dEPy: Now the question is, do you know a way to do something with the [Int] inside the "IO [Int]"?
02:30:50 <johnw> is something like this already in a library somewhere: https://github.com/jwiegley/notes/blob/master/Update.hs?
02:30:52 <rf_> tdammers: I never actually wrote something useful in PHP, but you are right it looks like "let this somehow work"
02:31:34 <johnw> (it implements update monads from Ahman and Uustalu's paper)
02:31:57 <OffTheRails> I'm a web developer, and escaped PHP a few years ago (to Ruby). Now JavaScript is everywhere.. ugh
02:33:16 <tero-_> JavaScript is much better than php
02:33:38 <OffTheRails> agreed
02:33:46 <rf_> Which is not too hard, I guess. :/
02:33:48 <tdammers> tero-_: JS has other shortcomings, but yes, it's much better in almost every regard
02:34:32 <tero-_> JS core is very compact http://www.jsfuck.com :)
02:35:12 <sgronblo> nilg: I recognize that sentiment, I used to love Python a few years ago, but nowadays I can't stop being pissed off at lack of type checking.
02:35:46 <dbushenko> sgronblo, same as me but for js :-)
02:35:52 <benj_> tdammers, is it really significantly better? I can't write a working program in either.
02:35:57 <OffTheRails> have you tried typescript instead?
02:36:00 <OffTheRails> or haxe?
02:36:19 <OffTheRails> they have typechecking and compile to JS (haxe to many others)
02:36:21 <merijn> sgronblo: I always feel so lost when trying to understand code I'm not familiar with. Without types there's nothing to hold onto as you explore
02:36:58 <OffTheRails> seems people have created plenty of opportunities to avoid working directly with JS
02:37:17 <tero-_> OffTheRails: I think it is important to understand JS well before using "let's compile to JS" approach
02:37:23 <tdammers> benj_: JS is consistent at least
02:37:58 <dbushenko> OffTheRails, I'd better try fay, elm or ghcjs
02:38:41 <OffTheRails> I guess I can agree with that. I've used CoffeeScript for most of my work to abstract away certain things
02:38:45 <sgronblo> but hey guys, you know that you can write php with optional static typing nowadays using hack (apparently, havent tried it). that to me makes it jump ahead of perl, ruby, python and javascript immediately.
02:38:52 <benj_> tdammers, consistent like "5" + "5" = "55" but "5" - "5" = 0 kind of consistent
02:40:20 <tdammers> benj_: that's one of a handful of type coercion quirks
02:40:35 <tdammers> benj_: I'm talking about how API's are mostly consistent
02:40:45 <tdammers> benj_: how not everything is in the global namespace
02:40:56 <benj_> oh, I was talking about languages.
02:41:05 <tdammers> the language itself, too
02:41:06 <benj_> APIs can at least be avoided if you have to.
02:41:24 <tdammers> in PHP, I can foreach () over an array, or over an object that implements Iterable
02:41:35 <Lethalman> php -r 'echo ("0foo" == 1)."\n"; echo (1 == TRUE)."\n"; echo ("0foo" == TRUE)."\n";'
02:41:43 <tdammers> but I have to test first whether the thing I'm trying to iterate over actually supports iteration
02:41:46 <OffTheRails> parameter order in PHP is incredibly consistent
02:42:03 <tdammers> but, get this, arrays don't implement Iterable, because they're not objects
02:42:08 <tdammers> so:
02:42:29 <OffTheRails> I often think *too* consistent. I sometimes wish they'd randomise the param order of related functions
02:42:32 <tdammers> <?php if (is_array($foo) || $foo instanceof Iterable) { foreach ($foo as $bar) { ... } }
02:42:49 <tdammers> OffTheRails: say what?
02:42:55 <tdammers> OffTheRails: array_map vs. array_filter
02:43:06 <Yuu_chan> laughing at PHP never gets old...
02:43:09 <OffTheRails> haha
02:43:17 <tdammers> Yuu_chan: actually it does
02:43:21 <OffTheRails> tdammers, sarcasm, do you speak it?
02:43:35 <tdammers> OffTheRails: no, please explain
02:43:53 <sgronblo> no one has given hack a try?
02:44:12 <rf_> Did someone count the additional (static typed) languages which were created for the sole purpose to compile them to a dynamic typed language?
02:44:13 <OffTheRails> it cannot be explained, it can only be sensed
02:44:54 <tdammers> rf_: probably
02:44:58 <Yuu_chan> OffTheRails: we need to invent a sarcasm-o-meter
02:45:32 <OffTheRails> I wonder how AI would detect sarcasm?
02:46:12 <benj_> I find it hard to write working code in JS because the interpreter is determined to carry on running the program even when half the variables in scope are undefined or the wrong type. Bugs have so many places to hide.
02:46:37 <Yuu_chan> OffTheRails: I read an article about analysts that trained their program to detect sarcastic comments at Amazon
02:46:59 <tero-_> OffTheRails: return $ ";)" `substring` line
02:47:16 <OffTheRails> Yuu_chan, interesting! I'll have to hunt it down
02:47:21 <Adeon> can I reverse the order of errors that GHC prints out? that is, the error I'm most likely to be interested in is the first one but it goes up because all these other errors are printed after it
02:47:30 <Adeon> I don't really expect I can but you never know
02:47:30 <tdammers> benj_: do you even use strict?
02:47:51 <OffTheRails> that wasn't hard
02:47:51 <OffTheRails> http://www.geekosystem.com/sarcasm-detecting-algorithm-online/
02:48:03 <vermeille> benj_: "use strict"; partially solves this issue
02:48:15 <benj_> yeah, that's true.
02:48:40 <hpc> vermeille: not muxh though
02:48:49 <hpc> *c
02:48:53 <Yuu_chan> OffTheRails: http://staff.science.uva.nl/~otsur/papers/sarcasmAmazonICWSM10.pdf looks like the original paper
02:49:31 <vermeille> hpc: true, JS still sucks :)
02:49:34 <benj_> the fact that it's optional to use strict means most JS code bases I've worked on don't have it
02:50:32 <benj_> one of the things I like about haskell is that the bar for an acceptable program is set much higher
02:52:48 <Yuu_chan> benj_: me too, but it's hard to explain to newcomers :(
02:53:30 <vermeille> Well, I don't think that Haskell is a good choice as a first programming language anyway
02:54:08 <AshyIsMe> apparently there's a uni that uses haskell as a first teaching language with good success
02:54:13 <tero-_> vermeille: would you like to elaborate why?
02:54:21 <rf_> I'm a newcomer also, but I already think that haskell is a great language when you want to work with other people on the same codebase.
02:54:35 * Yuu_chan wishes to try to teach non-programmers in Haskell
02:54:40 <shanse> haskell was used for the introduction to programming at my uni
02:55:06 <vermeille> shanse: 'til studying monads and stuff?
02:55:51 <shanse> monads were only touched briefly, iirc
02:56:13 <benj_> I'd be really interested to see haskell being taught to new programmers, who have not been exposed to the confusion and FUD about monads in the general programming community
02:56:53 <vermeille> 1) It's damn too uncommon. I'd rather advise to study something "useful" 2) It makes newcomers focus on typesystem more than logic 3) If you only begin programming, you don't have the ability to deal with abstractions such as monads etc
02:57:33 <benj_> if only there were some correspondence between types and logic
02:57:37 <tero-_> vermeille: good points
02:57:46 <tero-_> they used to teach scheme as the first programming course in my uni
02:57:50 <tero-_> now it's scala
02:58:50 <DanielDiaz> I happen to have studied Haskell as my first programming language, and I didn't find any of these issues.
02:59:08 <nclarke> Haskell is used as a fist language at my university
02:59:12 <DanielDiaz> maybe because I didn't know about anything else?
02:59:21 <nclarke> Although I did maths, not CS, so I never did any
03:00:16 <benj_> vermeille, what was the first language you studied at university?
03:00:17 <DanielDiaz> then I've studied an imperative programming language, and I found it harder for translating my ideas to code
03:00:55 <vermeille> benj_: OCaml. Thankfully I learnt some less uncommon programming languages before (C, C++ and C#, namely)
03:02:32 <vermeille> I started to code way before uni
03:03:14 <DanielDiaz> nclarke: what is your university?
03:03:28 <nclarke> DanielDiaz: Oxford
03:04:24 <benj_> vermeille, right, so your perspective wasn't as a beginner. It was as someone who already knew several C-style languages.
03:04:31 <DanielDiaz> nclarke: OK, great. I asked because I did maths too, and learnt Haskell too.
03:06:03 <vermeille> I think that Haskell, for really theoritical toy programs is good because it's easy to write and stuff while you stay in a pure non-monadic world. After that, it's way too hard and abstract for a beginner
03:06:29 <benj_> are you trolling now?
03:06:33 <sjy> was also a maths student and learned haskell in a first year CS course (australia)
03:06:41 <vermeille> benj_: not at all
03:06:51 <DanielDiaz> vermeille: I have to disagree given my experience.
03:07:01 <moop> math is so 19th century
03:07:05 <vermeille> I'm still talking about an educationnel context
03:07:10 <sjy> we didn't have to cover monads at all, just wrote + composed functions in hugs
03:07:31 <vermeille> DanielDiaz: would you elaborate :)?
03:07:32 <DanielDiaz> vermeille: I knew nothing about programming, and didn't find Haskell hard at all.
03:08:03 <rf_> You don't need to start with the abstract concepts to teach people haskell.
03:08:20 <vermeille> DanielDiaz: Did you learn *all* Haskell? or only the pure & non-monadic subset?
03:08:45 <rf_> For beginners stuff, haskell is just as hard to understand as java. You just don't have to type so much till something works and you can do most stuff in the interpreter.
03:09:02 <DanielDiaz> vermeille: I learnt both pure and monadic. But I was taught the Monad class the same way the Functor class. They were just classes and only had to follow the types.
03:09:29 <DanielDiaz> vermeille: it was all a game of equations and substitution.
03:09:34 <sjy> rf_: imo it's easier, for beginner-level problems anyway. it takes a long time to explain what "public class" means
03:10:00 <nclarke> And, as somebody pointed out earlier, it is meaningless to draw a distinction between 'pure' and 'monadic'
03:10:07 <vermeille> DanielDiaz: okay, good to know. Maybe your teacher was amazing or students very smarts, but I can't imagine that where I study
03:10:11 <nclarke> There's nothing 'impure' about monadic IO
03:10:32 <nclarke> Certainly not about monads in general
03:10:35 <benj_> there's also no dichotomy between types and logic
03:10:40 <DanielDiaz> vermeille: so I didn't see any real distinction between what was in a monad and what was not in a monad. The only thing that was special to me from Monad is that enjoyed a particular syntactic sugar.
03:12:50 <vermeille> DanielDiaz: The fact that I wandered a lot trying to learn haskell in vain (Monads on the web are so disturbing that you feel there's always something you didn't get) certainly affects my point of view
03:13:38 <vermeille> nclarke: Yeah, but that's a language abuse that everyone understands and is useful for communication purposes
03:13:40 <DanielDiaz> vermeille: maybe because they insist in the word monad so much... but really, it is just a type class.
03:14:20 <nclarke> vermeille: I disagree, it leads to a false dichotomy and superstitious sense of magic around monads
03:14:22 <vermeille> DanielDiaz: now I know :) But still, I can't imagine Haskell as a first language in my school.
03:14:25 <nclarke> Which inhibits understanding
03:15:43 <vermeille> true :)
03:17:21 <DanielDiaz> vermeille: but don't you think the way of writing functions in Haskell is closer to the way you write functions in High School? "f(x) = x + 2" => "f x = x + 2"
03:17:56 <sjy> also pattern matching
03:18:01 <DanielDiaz> vermeille: I think this might help to understand the language better in the first place. We all learn how to substitute terms and evaluate functions in High School.
03:19:52 <vermeille> DanielDiaz: of course it is. It's extremely simple to teach and learn the subset of Haskell using only builtin types and non-monadic code. After that, I'm sure students here would kill temselves :)
03:21:17 <vermeille> Hum, ADT are certainly acceptable too
03:21:32 <DanielDiaz> vermeille: but "monadic" code is equal to plain normal code, right? nothing more than evaluating functions.
03:22:05 <vermeille> Syntax and semantics differs
03:22:46 <vermeille> Some "values" are not named (think of the state in State monad, it never appears)
03:22:59 <DanielDiaz> vermeille: if you mean do notation, it's just syntactic sugar... But it is the same inside of that.
03:24:21 <DanielDiaz> http://en.wikibooks.org/wiki/Haskell/do_Notation
03:24:32 <vermeille> I know...
03:25:10 <benj_> as I see it, this is the problem with the convention wisdom that haskell is too hard for beginners: http://i.imgur.com/ksbI778.png
03:25:22 <benj_> er, conventional
03:25:32 <vermeille> It's just not that simple and stupid as you make it sounds when you see that first
03:26:16 <vermeille> benj_: haha, that could be the explanation yeah :)
03:27:39 <exicer> Has anyone used acid-state? It seems like a good idea, but I assume it isn't suitable for production scale use ?
03:28:22 <DanielDiaz> vermeille: sorry, I am not trying to convey this is all simple and stupid. Every learning process takes some effort.
03:30:09 <vermeille> I just don't remember how hard it was for me to learn C++ when I was 14. Maybe that was way harder, but I just don't remember :) I agree with you so
03:31:25 <benj_> I taught myself Java when I was about that age, and it probably shaped how I thought about programming for many years afterwards
03:32:49 <vermeille> Yes, it does. I wasn't able to understand something if I wasn't able to translate it to C++ :D In some cases, I still need to do that x)
03:32:49 <DanielDiaz> vermeille, benj_: Oh! all these premature programmers! I didn't even like it until I was 19 :(
03:34:15 <vermeille> DanielDiaz: Don't regret anything, I didn't code something interesting before I was 20 :)
03:35:20 <DanielDiaz> vermeille: I was a musician, and thought that programming was super boring... now I am an every-day programmer. Life!
03:36:16 <tdammers> DanielDiaz: another musician-gone-programmer here
03:36:31 <tdammers> programming just turned out to be much easier, and the money is better :P
03:36:54 <vermeille> one more. Even if my instrument skills sucks, I was writing a lot of music :D
03:36:59 <DanielDiaz> tdammer: I try to keep both worlds :)
03:37:30 <bjornars> its a bit sad when a CS101 course starts by introducing students to 'public static void main(String[] argv)'
03:37:35 <bjornars> programming by incantation
03:37:37 <tdammers> DanielDiaz: same here, but between a day job, family duty, and some running to keep me sane, there's not a lot of time left
03:37:43 <vermeille> DanielDiaz: feel free to check my blog, if you haven't done it already, I teach how to write a synthesizer :) http://vermeille.fr
03:39:11 <DanielDiaz> tdammers: yeah, I know that feeling
03:39:43 * ski started with BASIC, and then assembler
03:39:44 <DanielDiaz> vermeille: that reminds me I have a sound library in the works!
03:40:04 <ski> learning Haskell was the most fun i had since learning C
03:40:45 <vermeille> asm is really really funny!
03:40:59 <ski> it can sometimes be
03:41:03 * rf_ started with 8085 assembler.
03:41:15 * ski recalls writing code that modified code that modified code
03:41:23 <vermeille> :D
03:41:36 <vermeille> that kind of code madness turns me on
03:41:55 <r444> DanielDiaz: same shit, bro. I wanted to play music, then became full-time programmer.
03:42:20 <vermeille> DanielDiaz , r444 : Do you regret it today?
03:43:04 <r444> vermeille: yeah, sometimes
03:43:16 <vermeille> that's sad :(
03:43:31 * hackagebot blaze-svg 0.3.4 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.4 (BrentYorgey)
03:43:36 <r444> sadly you can't convert music into money
03:43:56 <tdammers> r444: you can, but the exchange ratio is kind of shitty
03:44:06 <DanielDiaz> vermeille: not at all! I like changes. I don't want to be doing the same thing forever. I feel richer this way.
03:44:14 * ski incidentally agrees with nclarke about there being nothing impure about monads
03:44:25 <tdammers> anyway, no, I don't regret a thing
03:44:26 <DanielDiaz> vermeille: switching from one field to another is really fun.
03:44:35 <r444> tdammers: it highly depends on location where you live
03:44:50 <ski> .. or alternatively, you could turn it on its head and say that (e.g.) list comprehensions are just as impure as state monads ;)
03:45:37 <ski> (or as the `IO' monad, if you prefer)
03:46:21 <paulschellin> Hey all, quick question (before I run to work) regarding "fix": I understand how fix is the clean way to represent fixpoint functions (of the form x = f x), but many resources I've been reading about "fix" either imply or outright state that "fix" isn't recursion (or is it co-recursion?), but the only reason I can think of is that the function isn't being recursively applied to an input until it can
03:46:22 * Yuu_chan agrees with DanielDiaz and is currently learning drawing arts
03:46:23 <paulschellin> terminate, but rather the function is applied to itself in a self-referential way, then it is applied to the argument. Or am I completely misunderstanding some concept(s)?
03:46:51 <bahamas> speaking of State monad, the name annoys me because it was so confusing at first. State holds the state computation not the actual state
03:47:13 <bahamas> Yuu_chan: you mean you're learning how to draw?
03:47:14 <grohne> is there a way to negate a quickCheck property? i.e. construct a test that is considered failed if no counter-examples could be found and successful on the first counter-example?
03:47:27 <DanielDiaz> Yuu_chan: that's out of my skill possibilities. :(
03:48:29 <tdammers> DanielDiaz: sounds a lot like my life... I seem to be doing a new thing every decade or so
03:48:57 <DanielDiaz> tdammers: do you like that?
03:49:08 <tdammers> DanielDiaz: yeah... it's kind of who I am
03:49:25 <DanielDiaz> tdammers: we are in the same boat then :)
03:49:29 <vermeille> Hum. Being only 22 it will be hard for me to talk in terms of decades :D
03:49:30 <tdammers> although really programming and music have been there all the time, just not necessarily *the* main thing
03:49:42 <Yuu_chan> bahamas: yes, but slightly more advanced academic stuff rather than just "how to" - anatomy, composition, oil paints and so on
03:49:50 <CatpainHayasho> vermeille: age snap!
03:49:57 * CatpainHayasho goes back to lurking
03:50:01 <tdammers> currently the "thing" is running, and both music and programming are being backgrounded a bit
03:50:12 <tdammers> (still program for a living though)
03:50:43 <bahamas> Yuu_chan: ah, so you're already passed the basics. I want to learn how to draw as well, but I don't have any skills, so I'll start from zero
03:50:44 <Yuu_chan> DanielDiaz: btw, I have a LOT of fellow programmers playing in local bands :)
03:51:24 <grohne> [QuickCheck] that's what expectFailure is for.
03:51:50 <vermeille> What kind of music do you play? I believe that I see a maybe-spurious correlations between metal and computers
03:53:56 <hpc> vermeille: that's a question for -blah
03:55:30 * Yuu_chan requests for a mathcore band that would sing about programming and languages
03:56:05 <rf_> http://www.networkworld.com/community/blog/band-releases-album-linux-kernel-module
03:56:34 <vermeille> Yuu_chan: The Algorithm :) It's only in titles though
03:57:36 <Yuu_chan> Need to check, thanks :)
04:02:54 <BoR0> merijn, I thought it was an interesting problem so I gave it a try. however I am stuck. http://lpaste.net/6268858879975620608
04:07:58 <wunki_> what would be the best way to loop through a binary file in chunks of 64k?
04:08:26 <wunki_> some background, I'm doing the following blog post in Haskell: http://jvns.ca/blog/2014/05/12/computers-are-fast/
04:08:31 <dEPy> merijn: so the lambda must be  Int -> IO [Int]  ?
04:08:40 <Yuu_chan> BoR0: do you know of replicateM?
04:08:45 <solirc> Are there any solutions for db migrations out there?
04:08:54 <vermeille> wunki_: ByteStrings maybe?
04:08:56 <solirc> e.g. what does Yesod use?
04:08:58 <BoR0> Yuu_chan, nope
04:08:58 <dEPy> merijn: no wait, that's the sig of pentaN
04:09:15 <dEPy> merijn: lamba should be  Int -> IO Int ?
04:09:43 <Yuu_chan> :t replicateM
04:09:44 <lambdabot> Monad m => Int -> m a -> m [a]
04:10:02 <wunki_> vermeille: yeah, I was thinking of the `get` function: http://hackage.haskell.org/package/binary-0.7.2.1/docs/Data-Binary-Get.html
04:10:05 <Yuu_chan> :t replicateM 4 (readLn :: IO Int)
04:10:06 <lambdabot> IO [Int]
04:10:15 <dEPy> merijn: I'm totally confused now cause of monads + recursion + type sigs
04:10:40 <BoR0> Yuu_chan, so the trick is to get [IO Int]s instead of IO [Int] and use sequence on them?
04:10:59 <BoR0> or not really
04:11:25 <Yuu_chan> BoR0: replicateM does the sequence for you
04:11:29 <dEPy> Any1 else wanna shed some light on this https://gist.github.com/depy/cad4bc1139a6d952f0a4 ? I don't know how to read N lines
04:11:40 <BoR0> I know but what if we were to rewrite this without using replicateM
04:12:29 <Yuu_chan> BoR0: indeed, you would generate a list of IOs with ordinary replicate and "flatten" it with sequence
04:12:35 <BoR0> I see
04:12:46 <Yuu_chan> @src replicateM
04:12:46 <lambdabot> replicateM n x = sequence (replicate n x)
04:14:05 <vermeille> :t sequence . repeat
04:14:06 <lambdabot> Monad m => m a -> m [a]
04:14:43 <BoR0> Yuu_chan, what would be the base case? pn 0 = [return 0] this doesn't look good to me :
04:15:22 <Yuu_chan> BoR0: pn 0 = return []
04:15:44 <BoR0> it whines, since it's pn :: Int -> [IO Int]
04:15:59 <Yuu_chan> :t return []
04:16:01 <lambdabot> Monad m => m [t]
04:16:06 <krgn> hey can anyone recommend a way to serialize/deserialize millisecond-level timestamps?
04:16:20 <Yuu_chan> In your snippet m = IO and t = Int
04:16:29 <krgn> I can show POSIXTime, but can't seem to be able to readTime them back in
04:16:40 <BoR0> Yuu_chan, http://lpaste.net/6268858879975620608
04:18:29 <Yuu_chan> BoR0: aw, seems I misunderstood you. Are you trying to reimplement replicate, to get list of readLn's?
04:18:47 <BoR0> I think
04:18:58 <Yuu_chan> In that case, pn 0 = []
04:19:22 <Yuu_chan> Because it's an empty list of actions
04:19:30 <BoR0> ha! it works. is there a way to write this same functionality but with pn :: Int -> IO [Int] ?
04:19:46 <BoR0> so that I wouldn't have to use sequence
04:20:11 <Yuu_chan> BoR0: pn n = sequence $ pn' n where pn' = your definition
04:20:31 <Yuu_chan> Oh, you can reimplement sequence :)
04:20:40 <BoR0> @@src sequence
04:20:47 <BoR0> @src sequence
04:20:47 <lambdabot> sequence []     = return []
04:20:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:20:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:21:45 <Yuu_chan> You could equivalently flatten it into pn 0 = return []; pn n = do {i <- readLn; r <- pn (n - 1); return $ i:r}
04:22:07 <merijn> dEPy: Right, so let's look at the individual pieces: "readLn :: IO Int", "pentaN (n-1) :: IO [Int]"
04:22:10 <BoR0> aha, I think I get it
04:22:12 <Yuu_chan> Basically substituting actual values into sequence body
04:22:23 <merijn> dEPy: So we want to have "IO Int -> IO [Int] -> IO [Int]", right?
04:22:34 <dEPy> merijn: should I even do I liek this, is there no easier way to do it?
04:22:38 <merijn> :t (:) -- this looks close, but no cigar
04:22:39 <lambdabot> a -> [a] -> [a]
04:22:41 <BoR0> http://lpaste.net/6268858879975620608
04:22:53 <merijn> However, we also have
04:22:54 <dEPy> merijn: ok following so far
04:22:57 <merijn> :t liftM2
04:22:57 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:23:03 <BoR0> I first readLn, then recurse, then return those 2 (which is what sequence does as well)
04:23:07 <merijn> :t liftM2 (:)
04:23:08 <lambdabot> Monad m => m a1 -> m [a1] -> m [a1]
04:23:16 <BoR0> so in either way, we are first executing the IO, then constructing the list, right?
04:23:25 <vermeille> Yuu_chan: Any way to have a lazy list for that ? so that `sequence $ repeat readLn >>= take 3` would work?
04:23:51 <merijn> So, "liftM2 (:) (readLn :: IO Int) (pentaN (n-1))" will do what we want, although it's a bit unreadable
04:24:11 <Yuu_chan> BoR0: btw, readLn doesn't need an explicit signature here, because it knows type of value it must read from the context
04:24:28 <merijn> dEPy: A nicer way of writing the same would be "do { num <- readLn :: IO Int; rest <- pentaN (n-1); return (num:rest) }"
04:24:30 <BoR0> aha
04:24:33 <merijn> :t return
04:24:34 <lambdabot> Monad m => a -> m a
04:24:43 <merijn> @undo do { num <- readLn :: IO Int; rest <- pentaN (n-1); return (num:rest) }
04:24:44 <lambdabot> (readLn :: IO Int) >>= \ num -> pentaN (n - 1) >>= \ rest -> return (num : rest)
04:24:57 <BoR0> cool! thanks
04:25:02 <Yuu_chan> vermeille: probably no :( Somebody told about sequence strictness here, IIRC
04:25:40 <vermeille> Too bad. I really need something like this.
04:26:09 <merijn> dEPy: I recommend studying that undo'ed line and looking at the types everything has and how that relates to the type of (>>=). A pen+paper might help
04:26:28 <merijn> vermeille: The pipes library exists to cover exactly that usecase
04:28:52 <vermeille> merijn: oh okay thx !
04:30:52 <dEPy> merijn: tnx! :)
04:45:14 <krgn> ah I found unix-time, thats a nice api for what i need
05:13:34 <Marquis> hello guys i got a question to the kmeans algorithm that works with vectors. Can anybody help me?
05:15:00 <vinothkumar> \
05:16:04 <adas> Marquis: ask the question. don't ask to ask
05:16:45 <Marquis> i have now changed my input that it SHOULD fit but it does not. I get the type error: Couldn't match type `V.Vector Double'                   with `Data.Vector.Unboxed.Base.Vector Double
05:17:00 <Marquis> is there an easy way to solve this?
05:18:40 <merijn> Marquis: You're using the wrong Vector type
05:18:44 <adas> yup
05:19:20 <adas> you shold be using the unboxed version. you might be using the boxed version
05:19:54 <adas> if you simply import the top level vector package, i think it imports teh boxed version
05:19:58 <adas> I might be wrong
05:20:19 <adas> :s/package/module
05:20:37 <Marquis> i just imported Data.Vector
05:21:36 <merijn> Something else in your code is using a different type of Vector from the Vector package (Unboxed) in this case
05:24:10 <Marquis> the only function that uses the vectors looks like this : indexElements :: [a] -> [(a,Int)]; indexElements xs = zip xs [1..]
05:25:52 <Marquis> that should give me a list of Points but because i have the unboxed (..) vectors the output is not recognized properly
05:31:22 <Marquis> merijn ++
05:31:27 <Marquis> adas++
05:31:42 <Marquis> thanks guys, i ll try to work on it and maybe come back in a few hours.
05:36:59 <osa1> is anyone else here also having this problem https://github.com/haskell/cabal/issues/1885 ?
05:37:50 <dcoutts> osa1: C-c is control-C ?
05:37:54 <osa1> dcoutts: yes
05:38:02 <dcoutts> as in keyboard interrupt
05:38:02 <osa1> sorry I wrote it in emacs terms
05:38:19 <osa1> I don't know if it's interrupt but it's ctrl-c
05:38:31 <osa1> (sometimes written as ^C)
05:39:33 <osa1> dcoutts: does it look familiar to you?
05:40:00 <hseg> Question. For what typeclasses do I need to have an instance in order to be able to use the [x..y] syntax?
05:40:05 <hseg> i.e.:
05:40:10 <hseg> > [1..3]
05:40:12 <lambdabot>  [1,2,3]
05:40:20 <vanila> there's no typeclass for that, its hard coded
05:40:28 <vanila> oh sorry
05:40:31 <vanila> hat's enumFromTo
05:40:36 <vanila> in the Num instance
05:40:41 <vanila> I thought you mean lists in general
05:40:57 <hseg> So I need Enum, and must replace the expression by enumFromTo?
05:41:19 <bartavelle> [x ... y] will desugar to enumFromTo
05:41:57 <dcoutts> osa1: yes, it's a long standing issue, though we've made some significant progress recently. I've commented on the ticket.
05:42:07 <osa1> thank you
05:42:17 <hseg> Oh. I found the problem with my code that made it seem as if it wasn't desugaring.
05:42:25 <hseg> I was writing [Foo..Bar]
05:42:35 <hseg> Which is apparently ambiguous.
05:42:50 <dcoutts> osa1: you can probably concoct a patch based on the info there
05:43:25 <osa1> dcoutts: I'd love to.. let me see the notes in the process library
05:43:39 <dcoutts> osa1: you'd need to extend Cabal's ProgramInvocation abstraction to cover the new delegate_ctlc feature I added
05:44:13 <dcoutts> osa1: and then have the place where we invoke ghc for repl to set that in its ProgramInvocation
05:44:16 <osa1> dcoutts: I'll see but note that I never looked into Cabal source code until now :)
05:45:28 <benzrf> .wc
05:45:39 <benzrf> oops
05:45:42 <benzrf> haskell tho
05:53:45 * hackagebot geojson 1.1.1 - A thin GeoJSON Layer above the aeson library  http://hackage.haskell.org/package/geojson-1.1.1 (domdere)
05:59:47 <hseg> Given a list of type [(Either a b, c)], how do I check that those elements paired with a Left are equal to some value of type c? I feel I should be using lenses and prisms here.
06:01:37 <benzrf> hseg: huh?
06:01:49 <benzrf> c != a
06:01:53 <benzrf> you cant compare them
06:01:59 <hseg> Yes, I know.
06:02:01 <vanila> it's /= in haskell
06:02:45 <vanila> why don't you just write: all (== c) . map snd . filter (isLeft . fst)
06:03:12 <hseg> Because this is a simplification of my actual problem.
06:03:36 <hseg> Do you want the entire data definition?
06:03:53 <vanila> i don tknow about lenses so I can't help
06:04:45 <fizruk> :t outside
06:04:46 <lambdabot> (Data.Profunctor.Rep.Representable p, Functor f) => APrism s t a b -> (p b r -> f (p a r)) -> p t r -> f (p s r)
06:05:35 <fizruk> :t aside
06:05:36 <lambdabot> (Choice p, Applicative f) => APrism s t a b -> p (e, a) (f (e, b)) -> p (e, s) (f (e, t))
06:06:05 <benzrf> fucking unreadable lens types
06:06:07 <benzrf> ;-;
06:06:37 <fizruk> :t below
06:06:39 <lambdabot> (Choice p, Traversable f, Applicative f1) => APrism' s a -> p (f a) (f1 (f a)) -> p (f s) (f1 (f s))
06:07:04 <tdammers> I saw someone call lens "un-Haskelly" somewhere recently...
06:07:06 <fizruk> oh, now I get it
06:07:18 <benzrf> tdammers: i dont see why not
06:07:52 <fizruk> here? http://ro-che.info/articles/2014-04-24-lens-unidiomatic.html
06:09:13 * hvr wonders if edwardk has an highlight on 'lens'
06:10:10 <benzrf> isnt that the guy who makes cartesian closed comic
06:10:15 <benzrf> and if so, he made a good comic about lens
06:10:38 <benzrf> oh lol he has it right in the article
06:12:00 <fizruk> > [(Left 1, 2), (Right "hi", 3)] ^.. folded .  swapped . aside _Left
06:12:02 <lambdabot>  [(2,1)]
06:13:41 <tdammers> fizruk: read it somewhere else, but the text is the same
06:13:48 <tdammers> fizruk: probably reblogged or sth
06:18:37 <benzrf> ughhh
06:18:46 <benzrf> is there any way to get lambdabot to expand type synonyms a la :i
06:21:03 <merijn> Not afaik
06:22:22 <fizruk> :t allOf (folded.swapped.aside _Left) (uncurry (==))  -- hseg
06:22:24 <lambdabot> (Foldable f, Eq a) => f (Either a c, a) -> Bool
06:24:39 <hseg> fizruk, Thanks. Now I just need to understand that.
06:25:09 <fizruk> folded - go for each element
06:25:22 <fizruk> swapped - swap the element of the pair
06:25:41 <fizruk> aside _Left - go into Left of the first element of a tuple
06:27:28 <hseg> Thanks. aside is still a bit unclear to me, but besides that, it's clear enough that I can adapt it.
06:28:05 <fizruk> :t aside _Left
06:28:06 <lambdabot> (Choice p, Applicative f) => p (e, a) (f (e, b)) -> p (e, Either a c) (f (e, Either b c))
06:28:17 <sopvop> Have anyone used vinyl for something serious? How bad (slow) it is?
06:28:29 <fizruk> hseg: oh, aside goes into second element of a tuple
06:28:44 <fizruk> hseg: that’s why I need to swap :)
06:30:01 <matheus23> Is somebody here interested in using Atom.io as their haskell editor? I wrote a plugin that allows for easy "cabal install", "cabal build" and "cabal run" from the editor
06:30:37 <hseg> Trying to parse the type sig. Failing.
06:31:17 <hseg> I see the part where you go into the second part of the tuple.
06:32:09 <hseg> Wait. You're reviewing the Left of the second element of a pair?
06:32:12 <hseg> I'm confused.
06:32:14 <fizruk> aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)
06:33:41 <hseg> Yes. So that means that given that I might be able to extract an a from an s, I can extract the a from a pair (e,s).
06:33:50 <benzrf> hmmm
06:33:56 <hseg> Supposing s~t and a~b for simplicity.
06:33:57 <fizruk> > (1, Left 3) ^? aside _Left
06:33:59 <lambdabot>  Just (1,3)
06:34:20 <fizruk> > (1, Right “hi”) ^? aside _Left
06:34:22 <lambdabot>  <hint>:1:11: lexical error at character '\8220'
06:34:29 <fizruk> oh you
06:34:36 <fizruk> > (1, Right 123) ^? aside _Left
06:34:38 <lambdabot>  Nothing
06:35:18 <fizruk> [(1, Left 3), (2, Right "hi")] ^.. folded.aside _Left
06:35:27 <fizruk> > [(1, Left 3), (2, Right "hi")] ^.. folded.aside _Left
06:35:28 <lambdabot>  can't find file: L.hs
06:35:37 <fizruk> i broke it
06:36:25 <fizruk> ghci> [(1, Left 3), (2, Right "hi")] ^.. folded.aside _Left
06:36:26 <fizruk> [(1,3)]
06:38:05 <hseg> So this is basically \z -> liftA2 (,) (z^._1) (z^._2^?_Left)
06:38:06 <hseg> ?
06:38:12 <hseg> where z is the pair?
06:38:16 <benzrf> lenssssssss
06:38:25 <benzrf> i will grok it yet >:D
06:38:29 <hseg> and the liftA2 is there to propagate the failure of ^?
06:39:06 <benzrf> @hoogle [Maybe a] -> [a]
06:39:09 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
06:39:09 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:39:09 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:39:10 <benzrf> catMaybes
06:43:51 * hackagebot haste-compiler 0.3 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.3 (AntonEkblad)
06:47:27 <lpsmith> Hmm, the Kosaraju-Sharir algorithm produces the strongly connected components of a directed graph in a topologically sorted order.
06:47:39 <lpsmith> Does Tarjan's algorithm do so as well?
06:48:07 <lpsmith> I know for sure Kosaraju's algorithm does,  but I'm not sure about Tarjan.
06:48:32 <lpsmith> Of course I find Kosaraju's algorithm quite a lot easier to understand.
06:51:30 <lpsmith> ahh, according to wikipedia,  Tarjan's algorithm *does* produce the SCCs in a reverse topological order
06:51:41 <lpsmith> I guess I don't understand why though.
06:53:25 <lpsmith> hmm, although the reference it mentions in relation to that proposed fact seems to be a bit ambiguous on that specific claim
06:55:50 <tayacan> Is there a function that takes a list and splits it into sublists of a certain size? Something of type Int -> [a] -> [[a]] or similar? I can't seem to find anything on hoogle :/
06:56:25 <bergmark> tayacan: probably in the split package
06:56:46 <bergmark> you can search for that type +split in hoogle
06:57:23 <lpsmith> mmm,  the python code does a topological sort *after* tarjan's algorithm,  so wikipedia's interpretation certainly does seem suspect
06:57:40 <fizruk> :t chunk -- tayacan
06:57:41 <lambdabot> Int -> [e] -> [[e]]
06:58:07 <hseg> fizruk, found the correct description of aside _Left in terms of basic combinators:  (\z -> (view _1 z,) <$> preview (_2._Left) z)
06:58:31 <hseg> fizruk, Well, actually, that's \z -> z ^? aside _Left
06:58:34 <tayacan> bergmark : Thanks!
06:58:43 <tayacan> fizruk: Thanks, just found it :D
07:00:13 <Fuuzetsu> :t (^? aside _Left)
07:00:14 <lambdabot> (e, Either a c) -> Maybe (e, a)
07:01:27 <Fuuzetsu> :t aside
07:01:28 <lambdabot> (Choice p, Applicative f) => APrism s t a b -> p (e, a) (f (e, b)) -> p (e, s) (f (e, t))
07:01:46 <halvorg> How do I discard whole lines w/parsec until a line begins with something I want?
07:02:17 <tdammers> halvorg: manyTill?
07:03:28 <halvorg> hm so manyTill anyChar $ try $ string ("\n" ++ wantedStart)
07:03:30 <halvorg> or something?
07:03:43 <halvorg> or is it \n\r? i never learned that
07:03:53 * hackagebot constrained-normal 1.0.1 - Normalised Deep Embeddings for Constrained Type-Class Instances  http://hackage.haskell.org/package/constrained-normal-1.0.1 (NeilSculthorpe)
07:05:53 <fizruk> hseg: isn’t that only one-way?
07:05:57 <awestroke> hackagebot: use the "newline" parser
07:06:01 <fizruk> > (1, 2) ^.re (aside _Left)
07:06:03 <lambdabot>  (1,Left 2)
07:06:09 <awestroke> halvorg: use the "newline" parser
07:06:33 <halvorg> ok ty
07:06:36 <awestroke> on second though, it says it only matches ±n anyway...
07:06:46 <BZEU> Hi. What is haskell used for?
07:06:51 <awestroke> BZEU: programming
07:06:58 <BZEU> What kind of programming?
07:07:01 <fizruk> BZEU: every
07:07:05 <BZEU> Example?
07:07:19 <hseg> fizruk, Probably. So aside lifts a Prism possibly extracting an a from an s into a prism possibly extracting an (e, a) from a (e, s)?
07:07:26 <hc> BZEU: the haskell compiler, for example
07:07:31 <fizruk> BZEU: http://www.haskell.org/haskellwiki/Haskell_in_practice
07:07:48 <BZEU> Is it worth learning?
07:07:53 <hc> definitely
07:07:56 <fizruk> BZEU: absolutely
07:08:13 <BZEU> Any good book for it?
07:08:20 <fizruk> @where lyah
07:08:20 <lambdabot> http://www.learnyouahaskell.com/
07:08:31 <BZEU> Come on..book please/
07:08:35 <BZEU> Ah
07:08:36 <lpsmith> hmm, it does seem that tarjan's algorithm does indeed produce a topological ordering of the SCCs
07:08:36 <BZEU> Thanks.
07:08:37 <BZEU> Sorry
07:09:09 <lpsmith> at least from skimming a couple of slightly more authoritive sources
07:09:09 <BZEU> I have no idea when or why I will use haskell btw.
07:09:16 <lpsmith> I should re-read tarjan's original paper
07:09:19 <fizruk> hseg: yeah, but you can also construct things with prisms, not only extract
07:09:40 <hseg> BZEU, When or why would you use Java/Python/...?
07:09:47 <hseg> fizruk, Right.
07:10:02 <lpsmith> I don't recall Tarjan making any claims about a topological ordering of SCCs,  but it was a long time ago when I read the paper
07:10:13 <BZEU> hseg: I code in C.
07:10:20 <lpsmith> Still, it seems like one of those facts that would have stuck out in my mind
07:10:47 <hseg> BZEU, Same diff. When would you code in C? Same answer for nearly any high-level language.
07:11:01 <hseg> fizruk, only problem with using aside is that you need the prism to be the second element of a pair.
07:11:11 <awestroke> BZEU: learning haskell will have a profound effect on all your programming in any language
07:11:58 <hseg> fizruk, Suppose I have a record of type s, and I have a Lens' s a. How do I construct (ds/da, a), where ds/da is the one-hole context of a in s?
07:12:15 <hseg> fizruk, Or at least how do I construct (s, a)
07:13:14 <fizruk> (s, s ^. l)
07:13:31 <BZEU> If you ever get really stuck, the IRC channel #haskell on the freenode network is a
07:13:31 <BZEU> great place to ask questions. The people there tend to be nice, patient, and understanding.
07:13:33 <BZEU> Lets see.
07:13:35 <fizruk> > let x = (1, 2) in (x, x ^. _1)
07:13:37 <lambdabot>  ((1,2),1)
07:13:52 <hseg> Right, realized that a moment after I asked. Now, to experiment with that!
07:13:59 * hseg puts on lab coat
07:14:00 <fizruk> hseg: also consider below
07:14:10 <fizruk> below :: Traversable f => APrism' s a -> Prism' (f s) (f a)
07:14:57 <hseg> From its description, [Left 1, Right 2] ^? below _Left should give me nothing, no?
07:15:00 <lpsmith> yeah,  that's what I thought,  Tarjan's original paper makes no claims regarding the topological ordering of the SCCs
07:15:08 <fizruk> hseg: yes
07:15:30 <xplat> BZEU: generally speaking, beginner questions require some patience from both sides, no matter the subject
07:15:32 <hseg> fizruk, Then it doesn't do what I need.
07:16:24 <fizruk> yeah
07:16:36 <edwardk> :t contexts
07:16:37 <lambdabot> Plated a => a -> [Context a a a]
07:16:58 <edwardk> :t holesOf
07:16:59 <lambdabot> Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Control.Lens.Internal.Context.Pretext p a a t]
07:17:09 <edwardk> :t holesOf _1
07:17:10 <lambdabot> Field1 s t b b => s -> [Control.Lens.Internal.Context.Pretext (->) b b t]
07:17:15 <hseg> And down the rabbit hole I go.
07:17:20 <edwardk> :t holesOf both (1,2)
07:17:21 <lambdabot> Num b => [Control.Lens.Internal.Context.Pretext (->) b b (b, b)]
07:17:53 <edwardk> :t head (holesOf both (1,2)) -- this is the first one hole context in that traversal
07:17:54 <lambdabot> Num b => Control.Lens.Internal.Context.Pretext (->) b b (b, b)
07:18:39 <edwardk> you can now manipulate the pretext which is isomorphic to (b, b -> (b,b)) and provides combinators for modifyig he context, extracting the updated result, etc.
07:18:54 <edwardk> :t unsafeHolesOf
07:18:55 <lambdabot> Not in scope: ‘unsafeHolesOf’
07:19:12 <edwardk> oh yeah, that one doesn't exist
07:19:53 <edwardk> hseg you can also use the zippers package which provides zippers using lenses to get contexts more directly
07:20:07 <lpsmith> oh,  knuth say's Tarjan's algorithm does do topological sorting
07:20:13 <xplat> edwardk: are you back in boston?
07:20:22 <edwardk> xplat: until 8pm, ys
07:20:42 <xplat> lpsmith: 'knuth said it, i believe it, that settles it'? :)
07:21:08 <edwardk> here long enough to pet cats / do laundry
07:21:37 <xplat> edwardk: is the latest (busted) code for the concurrent revisions lib up?
07:22:03 <edwardk> lpsmith: i have a lot of code that relies on the SCCs from tarjan being topsorted ;)
07:22:15 <xplat> hm, that's not very long, especially since cats tend to gravitate to the laundry basket ...
07:22:42 <edwardk> xplat: github.com/ekmett/revisions is the broken mess i left behind mid-refactor at one point
07:22:58 <hseg> edwardk, FYI, lens-4.1.2.1 doesn't have docs.
07:23:01 <edwardk> i was going to go through and switch it over to use my lca package
07:23:18 <lpsmith> edwardk, it's not nearly as easy to see *why* that's the case though, especially compared to Kosaraju-Sharir  ;-)
07:23:29 <xplat> edwardk: since hac boston isn't for quite a while, i figured i'd take a look by myself in the meantime
07:23:29 <edwardk> hseg: that's because of the transformers / transformers-compat debacle. when that is fixed it will
07:23:43 <hseg> edwardk, Besides that I'm not sure how to use contexts and holesOf, let alone make use of it in my code.
07:23:47 <hseg> edwardk, But thanks.
07:23:57 <edwardk> hseg: let me give an example, one sec
07:25:18 <edwardk> :t (flip Control.Lens.Internal.Context.ipeek &&& Control.Lens.Internal.Context.ipos) <$> holesOf both (1,2)
07:25:20 <lambdabot> Num b => [(b -> (b, b), b)]
07:25:37 <edwardk> heg: that is a list of one hole contexts and their associated values
07:25:39 <edwardk> that clearer?
07:27:30 <hseg> Nope. The most I know about one-hole contexts is that A) they're the same as zippers and B) that for polymorphic types, they correspond to the formal derivative of the type. I have no idea how it would work when lenses come into play, nor can I see how they'd be useful in the way you're using them.
07:27:40 <edwardk> > Control.Lens.Internal.Context.ipos <$> holesOf both (1,2)
07:27:42 <lambdabot>  Not in scope: ‘Control.Lens.Internal.Context.ipos’
07:27:54 <edwardk> @let import Control.Lens.Internal.Context
07:27:57 <lambdabot>  Defined.
07:28:01 <edwardk> > ipos <$> holesOf both (1,2)
07:28:03 <lambdabot>  [1,2]
07:28:14 <hseg> Also, I have the feeling this is getting far beyond what I wanted.
07:28:21 <edwardk> > (ipeek ?? 4) <$> holesOf both (1,2)
07:28:23 <lambdabot>  Could not deduce (Control.Lens.Internal.Context.IndexedComonadStore
07:28:23 <lambdabot>                      w0)
07:28:23 <lambdabot>    arising from the ambiguity check for ‘e_1412’
07:28:23 <lambdabot>  from the context (Control.Lens.Internal.Context.IndexedComonadStore
07:28:23 <lambdabot>                      w,
07:28:37 <edwardk> > ipeek 4 <$> holesOf both (1,2)
07:28:40 <lambdabot>  [(4,2),(1,4)]
07:28:55 <BZEU> Anyone use Leksah?
07:29:08 <hamishmack_> yes
07:29:20 <BZEU> Or should I use an editor and GHC?
07:29:49 <edwardk> holesOf gives you  list of targets of the lens/traversal including both the value in that context (via ipos) and the ability to replace just that one value to get a new structure (via ipeek)
07:30:08 <edwardk> that ablity to read what is there and replace it is precisely what a one whole context is
07:30:23 <edwardk> in some sense a one-hole context is a partially applied lens
07:30:32 <edwardk> :t flip _1 (1,2)
07:30:33 <lambdabot> (Num t1, Num t, Functor f) => (t -> f b) -> f (b, t1)
07:30:57 <edwardk> by picking f differently to be Const r  or Identity you can edit that context.
07:31:11 <edwardk> the zippers package automates this more
07:31:43 <edwardk> >>> zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'J' & rightmost & focus .~ 'y' & rezip
07:31:44 <edwardk> ("Jelly","world")
07:32:28 <lpsmith> Especially considering that Tarjan himself didn't seem to be aware of that fact,  at least when he published his original paper.   Otherwise he *surely* would have mentioned it.
07:33:02 <hseg> edwardk, OK. So holesOf l s will give me the list of all the targets of l in s, which can be used using ipos and ipeek,, where ipos will give me the value at the target and ipeek x will fill the context with x?
07:33:10 <edwardk> yep
07:33:33 <hseg> Awesome.
07:33:46 <edwardk> lpsmith: well the property isn't immediately obvious, but it is there =)
07:34:14 <hseg> I'll need to digest that a bit, in order to see if I can apply this to my problem.
07:34:42 <edwardk> it is technically a reverse topsort also
07:37:05 <hamishmack_> BZEU: Try both
07:37:10 <hseg> I think this tangent into one-hole contexts, while interesting and probably useful in other problems, is inapplicable to my problem.
07:37:20 <prooftechnique> BZEU: I recommend Emacs, though Eclipse with EclipseFP isn't too bad
07:38:40 <Kinnison> BZEU: I recommend that whatever editor you use, you keep a ghci window open to play in.
07:38:48 <lpsmith> edwardk, right,  I do understand that.
07:39:18 <edwardk> hseg: i merely answered the question, there was no warrant of applicability ;)
07:39:28 <lpsmith> I have implemented Tarjan a couple of times,  spent some time trying to understand it,  made some progress but never really did
07:39:33 <hseg> edwardk, still, thanks.
07:39:50 <lpsmith> Kosaraju,  on the other hand,  I pretty much immediately understood
07:39:53 <edwardk> tarjan has a strange mind
07:40:14 <edwardk> too bad tarjan blows its doors off ;)
07:40:20 <lpsmith> yeah :)
07:42:02 <hseg> Is there a way to express the following implication: If isJust (s ^? a), then s ^. b == c
07:43:53 <hseg> Specifically, I have an array of s, and I'd like to check that predicate for each element of the array.
07:45:18 <awestroke> :t ^?
07:45:20 <lambdabot> parse error on input ‘^?’
07:45:25 <awestroke> :t (^?)
07:45:25 <lpsmith> xplat,  yep exactly.
07:45:26 <lambdabot> s -> Getting (First a) s a -> Maybe a
07:45:57 <BZEU> 40+3/4*4 = 43?  Nice try haskell..
07:46:11 <BZEU> ghci
07:46:26 <BoR0> what did you expect?
07:46:39 <BZEU> What do you think?
07:46:41 <xplat> edwardk: hm, i looked up tarjan's SCC algorithm on wikipedia and i think i understand how it works and why it reverse-toposorts.  does this mean i have a strange mind?
07:47:01 <Polarina> BZEU, I get the same result when I compute that on paper.
07:47:38 <BZEU> Mother of god I'm too tired.
07:47:55 <Polarina> BZEU, :-)
07:47:55 <hseg> awestroke, So basically, all (\s -> not (isJust (s ^? a)) || (s ^. b == c)) l?
07:48:05 <zwer> > 40+3/4*4
07:48:07 <lambdabot>  43.0
07:48:08 <zwer> why?
07:48:28 <zwer> nevermind. brainfart
07:48:29 <xplat> BZEU: perhaps you meant 40+3/(4*4) or 40+(3 `div` 4)*4 ?
07:48:34 <awestroke> :t (/) -- there'rs your answer
07:48:36 <lambdabot> Fractional a => a -> a -> a
07:49:08 <awestroke> the only way to type match 40+3/4*4 is by typing all numbers to Fractional
07:49:37 <hiptobecubic> tarjan's is pretty interesting
07:50:11 <xplat> awestroke: s/numbers/all the numeric literals/ and s/Fractional/a type with a Fractional instance/
07:50:22 <awestroke> hseg: all (\s -> let x = (s ^? a) in not (isJust x) || (x == Just c)) l?
07:50:28 <xplat> :t 40+3/4*4
07:50:29 <lambdabot> Fractional a => a
07:50:31 <hiptobecubic> I always like algorithms that involve some proof by contradiction: "If not, then v must be the root of its strongly connected component, which consists of v together with any later nodes on the stack (such nodes all have paths back to v but not to any earlier node, because if they had paths to earlier nodes then v would also have paths to earlier nodes which is false )."
07:51:29 <awestroke> hseg: further, not . isJust can be replaced with isNothing
07:52:35 <hseg> awestroke, you're solving a different problem. It seems this should work: all (\s -> not (is a s) || (s ^. b == c)) l
07:53:59 * hackagebot transformers-compat 0.3.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.3 (EdwardKmett)
07:54:35 <xplat> hseg: what is the actual problem you're solving again?
07:56:12 <xplat> edwardk: does that mean it's no longer a small compatibility shiv?
07:56:21 <hseg> Given an array of records of type s, which has fields a and b, which are both prisms, determine whether whenever a is in a particular branch, b is in another particular branch.
07:56:49 <hseg> e.g. a list of pairs of Ints, where whenever the fst is prime, the snd must be even.
07:57:08 <hseg> or stuff like that. Using this for a constraint solver.
07:57:56 <xplat> so it's just implication between two partial lenses?
07:58:24 <xplat> (restricted to the elements of the array)
07:59:11 <hseg> The further I think on it, yes.
07:59:56 <hseg> I need to test whether an implication holds between prisms of the elements of an array.
07:59:58 <zwer> what would happen if I used existentials to create AnyMonad?  will >>= type check, even though underlining types could be incompatible?
08:00:41 <fizruk> zwer: nope
08:00:54 <merijn> zwer: No, if you have two existential monads then >>= won't typecheck
08:01:00 <xplat> hseg: the examples you gave (fst is prime, snd is even) are partial lenses, not prisms
08:01:39 <xplat> hseg: (re doesn't work on them, f'rex)
08:01:45 <hseg> In the documentation for prisms, a prism nat is defined.
08:02:28 <fizruk> hseg: so if you have a list, why not filter is first?
08:02:58 <fizruk> hseg: filter a list to have only primes and then check if snds are all true
08:03:40 <xplat> hseg: prime is a perfectly fine prism potentially, although the naughty not-quite-a-prism version is more likely to be implemented.  'first component is a prime' is not even a naughty prism
08:03:52 <hseg> fizruk, A) I want that when the fst isn't prime the snd can be anything (material implication) B) I *am* filtering. This predicate on arrays is the predicate I'm filtering on.
08:03:57 <fizruk> > all snd . filter (even . fst) $ [(1, False), (3, True) (2, True)]
08:03:58 <lambdabot>  Couldn't match expected type ‘(t1, GHC.Types.Bool)
08:03:59 <lambdabot>                                -> (b0, GHC.Types.Bool)’
08:03:59 <lambdabot>              with actual type ‘(t0, GHC.Types.Bool)’
08:04:44 <hseg> xplat, OK. Better example, I have an array of pairs of Either and Maybe. When the fst is Left, then I want the snd to be Nothing.
08:05:03 <hseg> (when fst is Right, snd can be anything).
08:05:23 <fizruk> all (isNothing . snd) . filter (isLeft . fst)
08:05:37 <xplat> hseg: _Left is a prism, fst is a lens, fst._Left is a partial lens
08:05:44 <fizruk> :t all (isNothing . snd) . filter (isLeft . fst)
08:05:45 <lambdabot> [(Either a1 b, Maybe a)] -> Bool
08:06:01 <fizruk> hseg: you don’t even need any lenses/prisms for that ^
08:06:23 <hseg> fizruk, Again, material implication. When fst is Right, snd can be anything.
08:06:37 <fizruk> hseg: so, you wanted it to be anything, right?
08:07:25 <hseg> fizruk, Yes. (Left x, Nothing) is good, (Left x, Just y) is bad. (Right x, y) is good.
08:07:40 <edwardk> > allOf (traverse.filtered (has (_1._Left))) (has (_2._Nothing)) [(Left 3, Nothing),(Right 4, Just 12)]
08:07:42 <lambdabot>  can't find file: L.hs
08:07:48 <hseg> xplat, I don't know the term "partial lens".
08:07:50 <xplat> > all (isNothing . snd) . filter (isLeft . fst) $ [(Left 1, Nothing), (Right 1, Just True), (Right 1, Nothing)]
08:07:51 <fizruk> hseg: and this is what my function does, isn’t it?
08:07:52 <lambdabot>  True
08:07:58 <xplat> hseg: ^
08:08:34 <xplat> > all (isNothing . snd) . filter (isLeft . fst) $ [(Left 1, Nothing), (Right 1, Just True), (Right 1, Nothing), (Left 3, Just True)]
08:08:35 <hseg> fizruk, Oh, wait. Right.
08:08:36 <lambdabot>  False
08:09:02 <hseg> edwardk, Thanks.
08:10:57 <xplat> heh, i carefully put the _ on Left, but left _1 as fst :7
08:13:33 <albeit> I'm using attoparsec, and trying to parse a single character bytestring into a custom datatype, and this is how I'm doing it now: http://lpaste.net/104408. I feel like there must be a way more efficient way to just match on a single character. How can I improve it?
08:13:38 <iota_> 18
08:13:44 <iota_> woops, sorry
08:14:26 <prooftechnique> albeit: https://hackage.haskell.org/package/attoparsec-0.11.3.4/docs/Data-Attoparsec-Text.html#v:char
08:14:38 <prooftechnique> Oh, sorry, Bytestring
08:16:15 <prooftechnique> albeit: Maybe word8 from Data.Attoparsec.Bytestring?
08:18:04 <xplat> > ord '0' :: Word8
08:18:06 <lambdabot>  Couldn't match expected type ‘GHC.Word.Word8’
08:18:06 <lambdabot>              with actual type ‘GHC.Types.Int’
08:18:12 <albeit> Ohh thanks, didn't look at the subdocs, thanks
08:18:15 <xplat> meh
08:18:31 <xplat> > fromInteger . ord $ '0' :: Word8
08:18:32 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘GHC.Integer.Type.Integer’
08:18:32 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Integer.Type.Integer
08:18:32 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Int
08:18:33 <bernalex> how do you update the build deps of your cabal package? doing cabal init, it figures it out, so I assume there's a way to update an existing cabal and have it figure out deps for you
08:18:47 <xplat> > fromIntegral . ord $ '0' :: Word8
08:18:50 <lambdabot>  48
08:19:35 <xplat> wow, so out of practice, thank the simons none of that compiled :)
08:22:00 <dcoutts> bernalex: at the moment no, you have to adjust them by hand
08:22:12 <bernalex> dcoutts: OK thanks
08:22:20 <xplat> you could always move your .cabal aside and cabal init again
08:22:46 <dcoutts> bernalex: but it's not that hard, the .cabal file stuff is fairly easy to understand and modify
08:22:47 <xplat> rather, your .cabal *and* Setup.hs and stuff, make sure you get all of it
08:23:33 <xplat> probably best to just leave the recovery to your VC actually
08:27:56 <m09> Any idea why the following code only adds the last edge into the map? http://lpaste.net/104409 first time using ST so it must be very dumb
08:29:03 * hackagebot language-puppet 0.13.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.13.0 (SimonMarechal)
08:29:31 <m09> oh nvm
08:29:33 <m09> I'm stupid
08:30:01 <napping> what was wrong?
08:30:15 <CindyLinz> There's only one edge in the edges?
08:31:11 <m09> yeah my values are lists
08:31:17 <m09> not single ints
08:31:50 <napping> that code looked like it was fine, good it's something else
08:32:06 <napping> You're just trying to learn ST here?
08:32:23 <m09> I know the basic theory behind ST but I've not used it yet
08:32:36 <m09> trying it for some graph problem
08:33:02 <napping> If you're not just practicing with ST, Map.fromList would be better there
08:33:15 <m09> oh ok :)
08:33:18 <m09> thanks
08:33:33 <napping> Maybe a type like Map Int (STRef s [Int]) would be useful if you change edges?
08:33:58 <m09> yup actually that's a good point, since I have to add edges one by one
08:34:06 <m09> the "value" gets updated
08:34:41 <napping> If you're just building an immutable map all at once, one of the fromList functions should mostly work just as well (maybe not if you build submaps in parallel or something fancy like that)
08:35:03 <napping> but if you want to actually use ST for a graph algorithm, then you might want to try a graph representation that uses STRefs to make parts mutable
08:35:44 <m09> oh yup true, fromListWith seems like a fit
08:35:53 <m09> ok noted :)
08:36:10 <hunt> http://lpaste.net/104410
08:36:20 <hunt> i just had the realization that perhaps i should use fmap?
08:38:02 <hunt> so wait
08:38:08 <hunt> if i have a Maybe fn
08:38:17 <hunt> how can i apply the something to a value
08:38:20 <hunt> and maintain the maybe?
08:38:24 <hunt> or set of value
08:39:02 <napping> looks like you want a bind there, if the result is still Maybe
08:39:10 <napping> ML.lookup w ioParsers >>= \f -> f ws sbuf buf
08:40:34 <hunt> do i need to import anything for bind?
08:40:48 <napping> no, that's the usual Monad operator
08:40:54 <hunt> so Control.Monad?
08:41:03 <hunt> er, nvm
08:41:06 <napping> You get that with the Prelude
08:41:15 <hunt> yea i wqasnt parenthesizing it for :t
08:45:06 <m09> so just to be sure, is createEdges edges = M.fromListWith S.union (map (second S.singleton) edges)
08:45:15 <m09> fast as a mutable version?
08:45:38 <napping> you're mutable version was just keeping an ordinary Map in an STRef and calling insert one entry at a time
08:45:48 <napping> *your
08:45:53 <m09> yup ok
08:46:08 <m09> so it was creating a new map each time and replacing it
08:46:18 <napping> It has some sharing
08:46:27 <napping> but fromList/fromListWith should be at least as fast
08:46:31 <m09> ok :)
08:46:48 <hseg> How do I find out what type GHC has inferred for a variable? i.e. how do I ask GHC what it thinks p is in has (ix i.p)
08:46:51 <hseg> ?
08:47:31 <napping> with 7.8 you could try a type hole
08:47:41 <napping> (ix i._), and see what it tells you the inferred type for _ is
08:47:42 <c_wraith> oh, yeah.  That's way nicer than implicitparams
08:47:55 <c_wraith> Which is how you can do it on older versions of GHC
08:48:20 <hseg> I think I'm on an older version. How do I use implicitparams for this?
08:48:24 <napping> It also tells you the type of variables in scope around the hole, which might be a better way to get a type for p, depending what the code is
08:48:58 <napping> Hmm, looks like _ doesn't tell you class constraints on the type variables, which is a little bit annoying
08:49:26 <napping> \x -> x + _ doesn't say the type of the hole should be an instance of Num
08:49:38 <napping> You can turn on ImplicitParams and put an implicit parameter
08:49:43 <bennofs> :t :t \p -> has (ix i.p)
08:49:45 <lambdabot> parse error on input ‘:’
08:49:47 <bennofs> :t \p -> has (ix i.p)
08:49:48 <lambdabot> (Ixed s, Index s ~ Expr) => ((a -> Const Any a) -> IxValue s -> Const Any (IxValue s)) -> s -> Bool
08:49:54 <napping> \x -> x + ?a will give an error like Unbound implicit parameter (?a::a0)
08:50:16 <bennofs> :t has (ix _i._p)
08:50:18 <lambdabot>     Found hole ‘_i’ with type: Index s
08:50:18 <lambdabot>     Where: ‘s’ is a rigid type variable bound by
08:50:18 <lambdabot>                the inferred type of it :: s -> Bool at Top level
08:50:31 <xplat> :t \x -> x + ?a
08:50:33 <lambdabot> (?a::a, Num a) => a -> a
08:50:49 <napping> oh, that works a bit nicer than just typing it in
08:50:56 <bennofs> :t \x -> x + _
08:50:58 <lambdabot>     Found hole ‘_’ with type: a
08:50:58 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
08:50:58 <lambdabot>                the inferred type of it :: a -> a at Top level
08:51:22 <c_wraith> It'd be really nice if type holes listed the constraints inferred for that type variable, yeah.
08:51:31 <napping> I suppose you can change the _ to undefined and infer the overall type to see constraints
08:51:48 <shachaf> Or use ImplicitParams.
08:52:20 <shachaf> It looks like ImplicitParams still gives you better holes than _ holes?
08:52:32 <napping> No, _ holes tell you types of local variables in scope
08:53:07 <shachaf> So will ImplicitParams.
08:53:12 <hseg> OK, thanks. New question. I have an array indexed by a custom type. Can I, and how do I use ix to select an element?
08:53:15 <napping> How?
08:53:22 <xplat> so basically you should use them both :)
08:53:27 <shachaf> I suppose that's only true when you have a type signature.
08:53:41 <napping> \x -> x + _ tells you the inferred type of the hole and the type of the x in scope at the point of the hole
08:53:52 <napping> I don't see any way that ImplicitParameters can tell you the type of local bindings
08:54:07 <napping> top level function argument, sure, but that's weaker
08:54:23 <c_wraith> Honestly, this sounds like a simple feature request for GHC
08:54:33 <c_wraith> (sounds like...  famous last words)
08:54:46 <glguy> \x -> x + ?y x
08:54:50 <glguy> ?type \x -> x + ?y x
08:54:51 <lambdabot> (?y::a -> a, Num a) => a -> a
08:55:03 <shachaf> For what I've used ImplicitParams for for years, it still seems that they work better than holes.
08:55:08 <c_wraith> https://ghc.haskell.org/trac/ghc/ticket/9091  looks like someone already reported it
08:55:18 <c_wraith> Two weeks ago
08:55:28 <glguy> If you know what local variables you wanted to see you can always apply them to your implicit param hole
08:55:30 <shachaf> Yes, I use glguy's trick sometimes too to list things in scope manually.
08:58:21 <monochrom> hseg: is that Data.Array's arrays? then you write an Ix instance for your custom type. it's essentially an injection from your custom type to the natural numbers.
08:58:56 <glguy> The new holes feature just gives me the wrong compiler messages when I forget to import lens for _1 or _2 or any prism ^_^
08:59:18 <hseg> Yeah, I don't know why, but it seems that unless I give my lens p the correct type, has (ix i . p) will complain about all sorts of stuff.
08:59:34 <hseg> No instances for (Indexable (Index s0) p0, Ixed (Accessor Data.Monoid.Any) s0)
08:59:40 <hseg> for example.
09:00:03 <hseg> How do I find the inferred type of an entire function?
09:07:22 <napping> hseg: looks like p just has to be a LensLike' (Const Any) (IxValue s) a
09:11:07 <glguy> fwiw that would be a: Getting Any (IxValue s) a
09:12:01 <hseg> OK. Getting: Not in scope: type constructor or class 'Any'
09:12:08 <glguy> It's from Data.Monoid
09:12:08 <bennofs> hseg: import Data.Monoid
09:12:25 <napping> You'll probably just want a Lens' (IxValue s) a or something
09:12:36 <shachaf> Oh, I thought that type was referring to GHC.Exts.Any.
09:12:44 <shachaf> I was a bit confused on how you'd end up with that.
09:13:06 <glguy> It's the ultimate in getters
09:13:10 <napping> All the LensLike / Getting stuff is just about how "has" instantiates the (Functor f) => or (Applicative f) => or whatever
09:13:17 <napping> the constraint in your lens, I mean
09:13:42 <glguy> hseg: Do you have something you can put on the pastebin?
09:13:48 <glguy> (or did you already figure it out)
09:14:32 <hseg> Basically, my function is defined as has (ix i . p)
09:14:48 <glguy> you mean: f i p = has (ix i . p) ?
09:15:04 <hseg> Yep.
09:16:09 <glguy> ?type let f :: Ixed s => Index s -> Getting Any (IxValue s) a -> s -> Bool ; f i p = has (ix i . p) in f
09:16:10 <lambdabot> Ixed s => Index s -> Getting Any (IxValue s) a -> s -> Bool
09:16:38 <haasn> shachaf: What is GHC.Exts.Any?
09:16:51 <shachaf> Many things.
09:17:00 <glguy> hseg: If you ":i has" you'll see that "has :: Getting Any s a -> s -> Bool"
09:17:16 <shachaf> It's a type with kind "k".
09:19:30 <shachaf> It's a type you can unsafeCoerce things to.
09:20:09 <shachaf> http://www.haskell.org/ghc/docs/7.8.1/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html#t:Any
09:21:01 <hseg> glguy, Not at interactive prompt. Usin FPComplete's IDE for lack of a local installation.
09:21:30 <glguy> You can't inspect things in the FPCo IDE? o.O
09:25:23 <vova> Hi,
09:25:43 <vova> Please help me with this error
09:25:45 <vova> http://pastebin.com/KEyfGxk0
09:26:07 <glguy> map ( splitOn "\t: " )
09:26:33 <vova> Thanks :)
09:35:12 <haasn> shachaf: Interesting
09:37:40 <stelleg> @src words
09:37:40 <lambdabot> words s = case dropWhile isSpace s of
09:37:40 <lambdabot>     "" -> []
09:37:40 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:38:43 <benzrf> :t isSpace
09:38:44 <lambdabot> Char -> Bool
09:39:05 <benzrf> that seems inefficient p:
09:39:48 <stelleg> @src lines
09:39:49 <lambdabot> Source not found.
09:41:05 <stelleg> i'm just surprised that's not abstracted over in Data.List
09:43:06 <enthropy> stelleg: http://hackage.haskell.org/package/split
09:43:19 <stelleg> enthropy: thanks
09:50:29 <teknokratsevilla> hi
09:51:56 <haasn> shachaf: I don't understand why you would want to unsafeCoerce things to Any
09:53:10 <albeit> With attoparsec, there is skipWhile :: (Char -> Bool) -> Parser (). What if I want to skip until I reach a full ByteString, not just a single character? I could combine some skipWhiles, but is there a better way?
09:54:09 <benzrf> albeit: i feel like you could do that with a comonad p:
09:56:30 <shachaf> Something isn't right here because that function takes a Char but you said ByteString, and ByteStrings aren't made of Chars.
09:56:31 <albeit> benzrf: No idea what those are, but I'll check them out
09:56:49 <shachaf> Anyway, you can't implement this on top of skipWhile unless I misunderstand what "this" is.
09:57:08 <albeit> That's the type definition provided... http://hackage.haskell.org/package/bytestring-0.9.2.1/docs/Data-ByteString-Char8.html
09:57:34 <albeit> "This" is I need something like skipToString :: (ByteString -> Bool) -> Parser ()
09:57:42 <ekidd> Hello. It's been a long time since I've dropped by here. :-)
09:57:52 <benzrf> albeit: it just vaguely reminded me of what kinds of things u can do with em
09:57:56 <benzrf> sup ekidd
09:58:21 <ekidd> I spent a few minutes this morning getting all of my Bayesian probability monad stuff back online: http://www.randomhacks.net/probability-monads/
09:58:32 <benzrf> coool
09:59:07 <benzrf> oh hey i saw that post before i think
09:59:12 <benzrf> but i just skimmed it >.>
09:59:33 <ekidd> benzrf: Yeah, there was a paper that I submitted to a workshop way back when with more details, too.
09:59:58 <ekidd> But half the links were broken, everything was spread out over a half-dozen ancient blog posts, and so on.
10:00:16 <monochrom> albeit: consider "string" in Data.Attoparsec.ByteString
10:01:41 <ekidd> It's kinda ancient history, but I had a lot of fun.
10:03:27 <albeit> monochrom: But string starts matching immediately, I somehow need it to keep trying to match if the first char doesn't match...
10:05:35 <albeit> Given the string "ABC123AB", I need it to match "123", so it has to skip "ABC" and return "123AB"
10:05:44 <albeit> (Or just "AB")
10:07:24 <Pythonfant> albeit: so you want to search for a substring?
10:07:39 <bergmark> albeit: takeWhile/takeTill?
10:07:56 <ReinH> skipping is the same as taking and throwing away ;)
10:08:08 <awestroke> does AttoParsec have anything like Parsecs `lookAhead` ?
10:08:27 <Roxana18>  Here some videos. I hope you like them! http://bit.ly/1gPNuyO
10:08:31 <albeit> bergmark: takeWhile / takeTill are all :: (Char -> Bool) -> ...
10:09:06 <albeit> awestroke: Yes it has lookAhead
10:09:07 <ReinH> @where ops
10:09:07 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
10:09:20 <johnw> yes?
10:09:22 <bergmark> oh right, i remember that bugging me too
10:09:25 --- mode: ChanServ set +o glguy
10:09:30 --- mode: glguy set +q Roxana18!*@*
10:09:32 <ReinH> k/b Roxana18 for spam pls
10:09:43 <ReinH> tyty
10:09:44 --- mode: ChanServ set +o johnw
10:09:50 --- mode: ChanServ set +o johnw
10:09:50 --- mode: johnw set +b *!~Roxana18@5.254.104.50$#haskell-ops
10:09:50 --- kick: Roxana18 was kicked by johnw (Kicked)
10:10:28 --- mode: glguy set +b-bq *!*@5.254.104.50$#haskell-ops *!~Roxana18@5.254.104.50$#haskell-ops Roxana18!*@*
10:10:38 --- mode: glguy set -o glguy
10:10:39 <heatsink> I installed the Haskell Platform on OS X Mavericks.  Is there a way to check whether I need to apply the clang compatibility fix?
10:11:52 <ReinH> heatsink: try to compile something? :)
10:12:04 <johnw> try to cabal install text
10:12:04 <heatsink> GHC can compile something.
10:12:07 <heatsink> ok
10:12:30 <ReinH> heatsink: ... use haskell and see if something breaks? ;)
10:13:06 <heatsink> I think the bugs have something to do with differences in the preprocessor
10:13:14 <heatsink> so only some CPP code would be affected
10:13:22 <pavonia> Is there a way to load .hsc files in GHCi?
10:14:14 <heatsink> yes, cabal install text fails in the preprocessor
10:14:23 <benzrf> prophile: are you really into pros
10:15:59 <pavonia> I tried >>:def hsc \s -> return $ ":! hsc2hs \"" ++ s ++ "\"\n:l \"" ++ init s ++ "\""<< but that eneded in a weird loop that crashed GHCi
10:16:12 <bergmark> albeit: so do you want to skip until some parser matches?
10:18:12 <albeit> bergmark: Yes!
10:19:17 * hackagebot amqp 0.8.3 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.8.3 (HolgerReinhardt)
10:19:19 * hackagebot esqueleto 1.4.1.1 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.1.1 (FelipeLessa)
10:20:32 <albeit> Currently thinking about doing this, it compiles...
10:20:34 <albeit> skipToString bs = mapM_ (P.skipWhile . (/=)) (BS.unpack bs)
10:21:46 <benzrf> albeit: thats an semantics error
10:21:55 <benzrf> what if bs is 'foo'
10:21:58 <benzrf> and you have the string
10:22:08 <benzrf> "fuck this, im going outside'
10:22:14 <benzrf> f o o
10:22:26 <benzrf> it will consume ""fuck this, im going o"
10:22:37 <bennofs> Is there a function to turn a type-level Symbol to a value-level String?
10:22:37 <albeit> Ah true
10:22:48 <benzrf> bennofs: type level Symbol?
10:23:01 <bennofs> :k "Symbol"
10:23:03 <lambdabot>     Illegal literal in type (use DataKinds to enable): "Symbol"
10:23:20 <bennofs> benzrf: with DataKinds, "abcdef" is a type of kind Symbol
10:23:22 <ReinH> bennofs: Typeable?
10:23:37 <ReinH> er.
10:23:40 <benzrf> bennofs: huh
10:23:56 <hseg> Found why GHC wasn't accepting my signature for has (ix i . p). FPComplete uses Lens 3.9
10:24:05 <ReinH> DataKinds promotes types to kinds. abcdef is not a type. It might be a type parameter.
10:24:17 * hackagebot esqueleto 1.4.1.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.1.2 (FelipeLessa)
10:24:18 <benzrf> albeit: can u do lookahead?
10:24:21 <ReinH> hseg: argh
10:24:36 <hseg> Yup.
10:24:49 <bennofs> ReinH: λ: :set -XDataKinds
10:24:50 <bennofs> λ: :k "Test"
10:24:52 <bennofs> "Test" :: GHC.TypeLits.Symbol
10:24:58 <albeit> benzrf: I'm not sure how I would use lookahead
10:25:26 <benzrf> skipWhile (lookahead 3 /= "foo")
10:25:27 <benzrf> or something
10:25:30 <bennofs> Ah, symbolVal is what I was looking for
10:28:13 <albeit> benzrf: Hmm still not sure how that would work. All the skips take Char -> Bool
10:30:28 <Lt1mh> sup every1
10:30:43 <eacameron> what are some ways to reduce the performance hit of non-tail-recursive functions like "next f (x:xs) = f x : next f xs" (and a base case)
10:31:47 <eacameron> or more importantly, how does haskell handle the potentially huge stack for such functions?
10:32:04 <johnw> eacameron: that function is lazily evaluated
10:32:16 <eacameron> johnw: how does that help?
10:32:30 <johnw> it only ever needs the top-level of the stack
10:32:50 <ski> eacameron : the stack isn't built up by the recursion (because the recursive call is deferred)
10:32:52 <eacameron> so it "memoizes" on the way up?
10:33:01 <ski> no memoizing
10:33:01 <johnw> no
10:33:17 <rwbarton> you should start by reading http://www.vex.net/~trebla/haskell/lazy.xhtml
10:33:31 <eacameron> I figured this might land me in a paper
10:33:32 <pavonia> How do you define a new GHCi macro spanning multiple lines?
10:33:33 <eacameron> ... ;)
10:33:33 <ski> @where lazy
10:33:33 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
10:33:39 <Lt1mh> does any1 know a good place to save notes??? besides on pc?
10:33:50 <ski> eacameron : not a paper, just monochrom's nice explanation :)
10:35:17 <ski> eacameron : the recursive calls will only happen (when, and) to the extent that the consumer of the result of the initial call inspects the cons cells of the result list
10:35:22 <rwbarton> the stack in ghc corresponds to the indentation levels in the evaluations shown on that page
10:35:56 <rwbarton> (at least approximately)
10:36:52 <pavonia> Lt1mh: Good ol' sheet of paper?
10:37:31 <johnw> eacameron: if it were in a strict language, you could avoid the use of stack by passing through an accumulator: next f ys = reverse (go [] ys) where go acc [] = acc; go acc (x:xs) = go (f x : acc) xs
10:38:36 <johnw> there are times in Haskell when this trick is useful to know, although your example of "map" is not that time :)
10:38:54 <ReinH> eacameron: tail-recursion is not the point here :) GHC does not do TCO of haskell expressions.
10:40:19 <napping> ReinH: it's not relevant here, but GHC does proper tail-calls
10:40:35 <ReinH> napping: The RTS does tail-calls itself, but not of user code
10:40:43 <napping> huh?
10:40:56 <napping> If you write a function that makes a tail call, that doesn't take extra stack space
10:41:17 <ReinH> napping: but that has nothing to do with tail call elimination
10:41:20 <ReinH> it has to do with lazy evaluation
10:41:23 <napping> GHC doesn't do any (?) funny trick to try to move things to tail calls
10:41:30 <napping> this example has nothing to do with tail calls
10:41:34 <ReinH> expressions that are in tail-recursive form can evaluate more efficiently because they put the recursive call in left-most, outermost position
10:41:48 <napping> but a strict tail-recursive function evaluates in constant stack space
10:41:55 * ski suspects napping and ReinH are in violent agreement
10:41:57 <ReinH> napping: but not because it's tail-recursive
10:42:00 <ReinH> because of lazy evaluation
10:42:01 <napping> which is the usual meaning of tail call elmination, right?
10:42:05 <ReinH> No.
10:42:16 <ReinH> TCO is essentially the use of a goto
10:42:23 <napping> a strict tail-recursive function doesn't take constant space because of laziness!
10:42:50 <napping> consider sumTo x 0 = x; sumTo !x n = sumTo (n+x) (n-1)
10:42:53 <ReinH> It has nothing to do with tail recursion
10:42:56 <`Jake`> ReinH: wouldn't that mean that tail call optimization is useless in something like C++?
10:43:13 <napping> there's no laziness there, and it runs in constant stack space rather than O(n)
10:43:14 <ReinH> It's just that functions in tail recursive form are in the correct form for lazy evaluation
10:43:19 <napping> because tail calls are properly handled
10:43:22 <ReinH> ...
10:43:23 <ReinH> No.
10:43:32 <ReinH> GHC does not do anything special to tail calls
10:43:33 <ski> napping : there's a semantical concept of "proper tail recursion" (which is a bit of a misnomer, since it applies to all tail calls, not just tail recursion), which states that the operational semantics supports an unbounded number of active tail calls in bounded space
10:43:35 <ReinH> This is lazy evaluation
10:43:42 <napping> and a call like enumFrom n = n : enumFrom (n+1) isn't in tail position!
10:43:45 <napping> it's under the :
10:43:57 <`Jake`> Oh, I think I misunderstood something
10:43:59 <`Jake`> nevermind
10:44:00 <ReinH> Whether it's in tail position is relevant *because of lazy evaluation*
10:44:07 <ReinH> not because of tail call elimination
10:44:08 <napping> that's the sort of thing which runs in constant space because of laziness
10:44:12 <ReinH> GHC does not do tail call elimination
10:44:20 <ReinH> foldl is an example
10:44:21 <ski> (and TCO is (not the only) one possible implementation technique for achieving "proper tail recursion")
10:44:43 <napping> ReinH: in ski's terminology, do you diagree that GHC supports proper tail recursion?
10:45:12 <ski> (not really my terminology. it's the one used by papers related to Scheme)
10:45:17 <ReinH> Under that definition, I suppose I do
10:45:29 <ReinH> but I have to stress that this has nothing to do with what people generally think of as tail call optimizaiton
10:45:44 <napping> What do people usually think of as tail call optimization?
10:45:44 <ReinH> I.E. there is no tail call elimination, no reuse of a call stack frame.
10:45:49 <napping> something stupid that just handles self calls?
10:46:12 <napping> what do you mean by "no reuse of a call stack frame"?
10:46:34 <ski> ReinH : in an appropriate setting, "does not do anything special to tail calls" amounts to "tail calls are properly handled"
10:46:35 <ReinH> There is no call stack to optimize.
10:46:43 <napping> the stack frame for the tail call ends up re-using (some of) the space used by the parent call
10:46:54 <ReinH> I said earlier that GHC does do tail call eliminations in its RTS. I was referring to this: http://community.haskell.org/~simonmar/papers/eval-apply.pdf
10:47:15 <napping> so you do know that there is a call stack
10:47:18 <johnw> ReinH: consider these two functions: https://gist.github.com/3124dfea98172c6b94e2
10:47:19 <ReinH> It does not do tail call elimination of Haskell expressions that it is evaluationg
10:47:23 <ReinH> napping: No, there is not a call stack.
10:47:26 <napping> it's just only used while forcing a value
10:47:29 <johnw> what part are you ascribing the TCO to there?
10:47:37 <shachaf> johnw: You are +o.
10:47:41 --- mode: johnw set -o johnw
10:47:48 <ReinH> johnw: page 4, section 4.1
10:48:17 <johnw> shachaf: that gist is why my Foldable.mapM_ code last time was so much slower
10:48:20 <ReinH> johnw: I am ascribing no part of that gist to TCO. I'm not sure how to make myself more clear on my position that GHC does not do TCO.
10:48:29 <shachaf> ?
10:48:43 <johnw> ReinH: so why is the first function so much faster?
10:48:49 <johnw> shachaf: if you don't remember, n/m
10:49:04 <ReinH> johnw: because of lazy evaluation
10:49:18 <ski> napping : "What do people usually think of as tail call optimization?" -- something that reuses a "stack frame", regardless of whether those are allocated on a stack or on a heap -- whether this happens automatically, or you have to work for it specially in the implementation is irrelevant, imho
10:49:19 <johnw> huh?
10:49:23 <ReinH> johnw: Actually no
10:49:41 <rwbarton> this is a pretty stupid distinction to try to draw IMO :)
10:49:53 <ski> (also note that "stack frame" doesn't imply "call stack")
10:49:55 <ReinH> johnw: I'm not sure why it's faster, but it isn't TCO.
10:50:03 <rwbarton> if you write f x = g (... x ...) the code generated for x will build a thunk for the argument for g and then do a jmp to g
10:50:19 <napping> code for f?
10:50:41 <rwbarton> er yes, thanks
10:50:50 <rwbarton> if g is known to be strict it will evaluate the argument and then jmp to g
10:50:54 <rwbarton> which looks a lot like TCO
10:51:12 <rwbarton> but it's not really an optimization at all
10:51:22 <ReinH> rwbarton: Right, this is what the eval/apply is talking about. This is a TCO in the RTS that happens to ANY function application that meets certain criteria
10:51:27 <ReinH> And has nothing to do with TCO
10:51:35 <ReinH> er, nothing to do with TCO *of Haskell expressions*
10:51:37 <ReinH> hit enter too soon
10:51:39 <napping> The only sense I can make is if ReinH means wats TCO to specifically refer to silly things that only handle self-calls
10:51:51 <napping> How in the world do you TCO an expression?
10:52:05 <ReinH> ...
10:52:12 <ReinH> napping: what have you been arguing for this whole time then?
10:52:13 <napping> I guess in a language with loops or jumps you could explicitly eliminate recursion yourself
10:52:24 <napping> but Haskell only has functions anyway
10:52:31 <ski> johnw,ReinH,napping : i think we can all agree that johnw's `next' example isn't related to the discussion about TCO, tail calls and "proper tail recursion"
10:52:42 <rwbarton> nothing to do with TCO of Haskell expressions, okay, but happens to look identical to code produced for a strict language by a compiler that did TCO
10:53:06 <napping> ReinH: that GHC does proper tail calls (probably the standard requires it), and in a strict function calls in a tail position don't consume extra resources, while calls in non-tail positions do
10:53:20 <ReinH> rwbarton: right, but the actual tail call elimination is in the RTS itself
10:53:22 <napping> that's the important part for understanding asympotitc performance
10:53:31 <rwbarton> how is it "in the RTS"?
10:53:39 <ReinH> napping: what is a "strict function call"?
10:53:44 <ReinH> This happens in foldl and foldl'
10:53:44 <napping> ReinH: you can in any case rely on proper tail calls in Haskell
10:53:46 <rwbarton> or what is "the actual tail call elimination"?
10:54:02 <rwbarton> do you mean if g isn't a known function?
10:54:16 <ReinH> rwbarton: The RTS basically uses a goto to reuse a stack frame with it evaluates a function that matches the criteria described in section 4.1
10:54:20 <ReinH> s/with/shen
10:54:32 <napping> ReinH: the goto is generated by the compiler, not provided by the RTS
10:54:33 <rwbarton> oh you are talking about the unregisterized C backend I guess
10:54:48 <ReinH> napping: Ok.
10:55:04 <napping> well, I suppose if you are using the bytecode interpreter with ghci then there's not a literal jmp instruction in the code
10:55:13 <ReinH> I'm saying that this isn't relevant to discussions about how GHC evaluates Haskell expressions because it happens to *any* function application
10:55:34 <rwbarton> yes
10:55:48 <rwbarton> but without that context, "GHC doesn't do TCO" is misleading to someone who is used to a strict language
10:56:12 <napping> As I see it, you're trying to make funny distinctions that have nothing to do with understaning how haskell expressions perform - but knowing that the performance of tail calls and non-tail calls differ is critical to understanding the performance of Haskell expressions
10:56:13 <ReinH> rwbarton: I don't think it is
10:56:28 <napping> it is totally misleading
10:56:32 <ReinH> No it isn't
10:56:36 <ReinH> It allows for the *correct* explanation
10:56:37 <ski> ReinH : thinking only about function applications is a red herring, i think. you should think about tail contexts
10:56:50 <ReinH> Which involves lazy evaluation
10:56:54 <ReinH> and left-most, outermost redex reduction
10:57:05 <napping> def f(x): if x == 0 then return else f(x-1) will stack overflow on large arguments in Python, which doesn't do TCO
10:57:15 <ski> e.g. the context `case x of ...' around `x' is not a tail context, so it will push stack
10:57:34 <napping> let f 0 = (); f x = f (x-1) won't stack overflow
10:57:41 <ReinH> ski: Ok, but "tail context" matters because of lazy evaluation
10:57:56 <napping> stack only matters at all when values are being forced
10:57:58 <ReinH> You can't explain why 'tail context' is important without explaining normal evaluation
10:58:12 <rwbarton> f x = g x has no space cost (ghc literally emits a jmp from f to g), etc.
10:58:25 <ski> ReinH : yes, the definition of "tail context" is slightly different from cbv languages
10:58:25 <ReinH> @src foldl
10:58:26 <lambdabot> foldl f z []     = z
10:58:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:58:38 <c_wraith> rwbarton: with optimizations, doesn't that get compiled out entirely?
10:58:42 <ReinH> There is no TCO happening here unless you consider lazy evaluation to be TCO
10:58:51 <ReinH> and I think calling it TCO leads to wrong intuitions
10:58:59 <ReinH> because people know what TCO means in languages that do TCE
10:59:09 <napping> ReinH: laziness is irrelevant to proper tail calls
10:59:12 <rwbarton> ReinH: yes but saying GHC *does not do TCO* also presupposes that TCO is meaningful
10:59:14 <ReinH> No it isn't
10:59:15 <ReinH> FFS
10:59:39 <napping> How does laziness have anything to do with let f 0 = (); f x = f (x-1)
10:59:41 <ReinH> the recursive call to foldl does not built up thunks BECAUSE OF lazy evaluation
10:59:41 <ReinH> period
10:59:46 <rwbarton> c_wraith: well, not if you have say NOINLINE on f and g
10:59:53 <ReinH> it is a left-most, outermost redex
10:59:57 <ReinH> That is why
11:00:05 <ReinH> compare to
11:00:07 <ReinH> @src genericLength
11:00:08 <lambdabot> genericLength []    = 0
11:00:08 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:00:13 <ReinH> where (+) is the left-most, outermost redex
11:00:22 <ReinH> and the recursive call to genericLength cannot be reduced
11:00:33 <ReinH> recursive evaluation of, I should say
11:00:35 <notdan> @src foldl
11:00:36 <lambdabot> foldl f z []     = z
11:00:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:00:36 <albeit> I need each instance definition of a typeclass (class Foo a) to have an identifying value... like idNum = 14. If I give Foo a method idNum :: Int, it complains that it doesn't reference a. How can I do this?
11:00:38 <napping> because it's not in a tail position
11:00:42 <ReinH> "function call" is a misleading term here
11:00:47 <notdan> I am confused.. it does generate a (f z x) thunk, doesn't it?
11:00:56 <ReinH> @where lazy
11:00:57 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
11:01:18 <ReinH> @google Normal-order evaluation
11:01:20 <lambdabot> http://en.wikipedia.org/wiki/Evaluation_strategy
11:01:20 <lambdabot> Title: Evaluation strategy - Wikipedia, the free encyclopedia
11:01:27 <rwbarton> notdan: yes
11:01:44 <cococo> [noob] How can I use this Network.Whois library? Network.Whois doesn't exist when I try to import it.
11:01:46 <napping> notdan: yeah - the foldl itself won't stack overflow, but it generates a deeply-nexted thunk of calls to f, so if f is strict, then when foldl reaches the base case and returns the accumulator, you get a stack overflow trying to force the thunk
11:01:59 <rwbarton> notdan: that is heap-allocated though (it needs to be, since it's ultimately going to be returned from foldl)
11:02:16 <ReinH> napping: you're missing the key point: why doesn't the foldl itelf build up a thunk chain?
11:02:17 <heatsink> albeit: You can make the identifier be an indexed type, idNum :: Identifier a,
11:02:26 <heatsink> albeit: or you can pass in a proxy value, idNum :: Proxy a -> Int
11:02:35 <ski> ReinH : because it's in tail position :)
11:02:41 <ReinH> ski: And why does tail position matter?
11:03:20 <cococo> Sorry forgot the link in my original question. How can I use this Network.Whois library? Network.Whois doesn't exist when I try to import it. -> http://hackage.haskell.org/package/whois-1.1.0/candidate/docs/Network-Whois.html
11:03:25 <ski> tail contexts are one way to account for a "stack" in felleisen-style small-step operational semantics
11:03:44 <ReinH> ski: because of normal-order evaluation. foldl is left-most, outermost and can be immediately reduced.
11:04:05 <ReinH> And GHC performs normal-order evaluation as a part of lazy evaluation (the other part is, ofc, sharing)
11:04:10 <geekosaur> cococo: cabal install whois
11:04:23 <geekosaur> (may need to run "cabal update" first)
11:04:33 <ski> another way would be to have a machine tuple with a "stack" component, and then the stack is the same size before reducing an expression and after having reached a subexpression of it that was in tail context
11:04:37 <ReinH> ski: this is why I don't like to talk about this as TCO when I suppose you might claim that it is. What it's really about is lazy evaluation, which is always an accurate way to think about how GHC behaves.
11:04:59 <albeit> heatsink: What is "Identifier" in the first case?
11:05:05 <heatsink> a newtype of Int
11:05:08 <cococo> geekosaur: thanks, I guess I don't understand cabal... Why wouldn't it be "cabal install Network" or "cabal install Network.Whois"? Isn't whois just a part of that library?
11:05:19 <heatsink> newtype Identifier a = Identifier Int
11:05:59 <ReinH> ski: calling this TCO often creates a false intuition for how GHC evaluates expressions and I'm trying to avoid that.
11:06:26 <ReinH> And misses out on the opportunity to talk about lazy evaluation
11:07:05 <ReinH> The RTS does not work like most runtimes people are familiar with and I wish we would stop using loaded terms like TCO that are only correct by accident.
11:07:17 <albeit> heatsink: Okay, when I try and give the class a new member, tagId :: TagIdentifier a, it complains that the data constructor TagIdentifier comes form an un-promotable type?
11:07:21 <asmyers> ReinH: Just a lurker but thanks, I never connected evaluation order to Haskell in this way.  Makes perfect sense now :)
11:07:26 <ski> ReinH : a simple way to implement Prolog (let's assume (semi-)deterministic programs for the moment) is to keep a stack of calls yet to be executed. in each step we take the front call of the stack, find the rule with head matching it, and replace the front call with the calls in the body of the rule
11:07:27 <zerokarmaleft> cococo: Network.Whois is the module name, whois is the package name
11:07:46 <ReinH> asmyers: And this exactly is why I am pedantic about this TCO thing :D
11:07:57 <ReinH> Because it causes actual people to actually understand evaluation better.
11:08:07 <heatsink> albeit: you're using a value in a type expression
11:08:20 <ski> ReinH : with this account, (what in LP context is known as) LCO falls out naturally from this, similar to how i think you're thinking about laziness above. still it's called LCO
11:08:25 <ReinH> ski: Sure, I can imagine a wide range of counterfactuals where TCO is happening :)
11:08:37 <asmyers> ReinH: I can't speak for anyone else, but I Think it's a nice explanation.
11:08:58 <geekosaur> cococo: look at the url. http://hackage.haskell.org/package/whois-1.1.0/candidate/docs/Network-Whois.html "whois-1.1.0" is the package name
11:09:12 <ReinH> Versus the non-answer "it's TCO" or "it's a tail call" that has negative utility as an explanation.
11:09:13 <ski> ReinH : i assume the "counterfactuals" referred to "(semi-)deterministic programs" ? ;)
11:09:20 <geekosaur> (you can omit the version to get the latest one)
11:09:21 <ReinH> ski: ;)
11:09:26 <ReinH> ski: I understand what you're saying and I agree.
11:09:33 <ReinH> ski: I hope you also understand what I'm saying
11:09:50 <ski> ReinH : with indexing, one can often detect many cases that are deterministic, and then one gets LCO
11:10:23 <ski> ReinH : i'm still not quite clear on your "calling this TCO often creates a false intuition for how GHC evaluates expressions"
11:10:44 <ReinH> ski: If people think that TCO implies TCE, and they think that foldl doesn't build up thinks because tail calls are being eliminated
11:10:46 <ReinH> and this DOES happen
11:10:53 <ReinH> then that's a false intuition
11:11:00 <ReinH> caused by calling it "TCO" or "a tail call"
11:11:06 <c_wraith> foldl doesn't build up tail call thunks.
11:11:07 <ski> it seems to me you can account for that with the distinction between cbv and cbn .. so i don't see what TCO would have to do with that
11:11:12 <ReinH> c_wraith: I know it doesn't.
11:11:17 <c_wraith> Or rather, it doesn't use stack space in tail calls.
11:11:19 <c_wraith> So they are correct
11:11:20 <albeit> heatsink: As in, I'm giving the TagIdentifier data constructor the value "a", when it should just be a pure type. But I just make it "tagNumber :: tagIdentifier" it gives the same error.
11:11:34 <ReinH> c_wraith: they are correct that it doesn't build up thinks
11:11:34 <c_wraith> foldl doesn't use stack space in its tail calls.
11:11:39 <ReinH> c_wraith: they are not correct as to *why*
11:11:50 <ReinH> And the *why* is actual question they are asking
11:11:50 <ski> ReinH : what is the false intuition ?
11:12:00 <ReinH> ski: that tail calls are eliminated by some sort of jump
11:12:05 <ReinH> This is what TCO means in most languages
11:12:07 <heatsink> albeit: The thing on the right-hand side of :: is a type.  You should use a type constructor, not a data constructor.
11:12:12 <c_wraith> ReinH: they *are* eliminated by a jump
11:12:26 <heatsink> albeit: How did you define the identifier type?
11:12:27 <c_wraith> ReinH: there is no stack space used to tail calls in foldl
11:12:32 <ReinH> c_wraith: They are "eliminated" by lazy evaluation.
11:12:36 <c_wraith> ReinH: no
11:12:39 <ReinH> c_wraith: Yes.
11:12:39 <ski> ReinH : depends on implementation strategy. in e.g. Scheme and SML, some implementations do it that way, in others it just happens naturally
11:12:44 <albeit> heatsink: Ah shoot, I made a type in the type constructor, doh
11:12:48 <ReinH> c_wraith: foldl is left-most outermost
11:12:49 <albeit> *typo
11:12:56 <c_wraith> ReinH: .... no.
11:13:14 <c_wraith> ReinH: GHC converts tail calls to jumps, just like they think.
11:13:22 <ski> (iow, no elimination would be going on in the latter cases since *all* calls are implemented by plain jumps there)
11:13:31 <monochrom> all you use just read my http://www.vex.net/~trebla/haskell/lazy.xhtml and stop arguing and start worshipping me :)
11:13:44 <ferada> hi, does stm interact somehow with fastcgi redirect? e.g. in http://lpaste.net/104412 the last line crashes, whereas the one above works
11:13:45 <ReinH> c_wraith: that is both true and irrelevant...
11:13:50 * ski bows before the idol
11:14:00 <rwbarton> this gets back to where I think the distinction is stupid
11:14:00 <ReinH> c_wraith: GHC converts function application to a jump when it meets the criteria described in http://community.haskell.org/~simonmar/papers/eval-apply.pdf
11:14:04 <ReinH> which has nothing to do with tail calls
11:14:56 <ReinH> c_wraith: Look, I generally assume that you're right in this sort of thing, but I've done a fair amount of research about this exact point.
11:15:09 <rwbarton> ultimately you are discussing terminology
11:15:13 <rwbarton> there is no right and wrong
11:15:23 <ReinH> rwbarton: Terminology is quite important when you are teaching people things.
11:15:29 <ReinH> Wrong terminology leads to wrong intuitions
11:15:38 <ReinH> Look at all the monad tutorials that talk about "unwrapping" the monad.
11:15:43 <ski> ReinH : if it converts all tail calls (and possibly others), then it also converts tail calls :)
11:15:54 <shachaf> Wrong terminology leads to long, pointless #haskell arguments.
11:15:55 <monochrom> ferada: I don't know the answer, but unlikely to interfere badly
11:15:59 <ReinH> ski: that is true, which is why I said the point is correct but not relevant.
11:15:59 <c_wraith> ReinH: The point is that those people are right when they assume foldl doesn't use stack space in the recursion.  What they don't understand is that that's irrelevant, because of laziness.
11:15:59 <rwbarton> disagreement in terminology leads to wrong understandings
11:16:18 <ReinH> c_wraith: That's exactly true, and I think laziness is a useful concept to understand
11:16:26 <ReinH> c_wraith: and that this is an excellent opportunity to introduce it
11:16:39 <ReinH> so I'm disappointed when the opportunity is wasted and the non-answer "its a tail call" is used instead
11:16:42 <c_wraith> ReinH: so telling them that there's no tail call elimination is needlessly uninformative at best, and wrong at worst
11:17:07 <ReinH> c_wraith: What I tell them is that the expression is reduced using normal-order evaluation and what effect this has on it
11:17:51 <ReinH> You can do this entirely without recourse to a term that is loaded with baggage from their experience with other languages that will lead to wrong intuitions.
11:18:04 <c_wraith> ReinH: Their intuition isn't wrong, though.
11:18:14 <albeit> heatsink: Okay, I have the class defined properly, and I have a class instance implementing that member correctly. But given a function ":: m a", where a is an instance of that typeclass, how can I get the "tagIdentifier :: TagIdentifier a"
11:18:31 <rwbarton> okay, except you actually said "tail-recursion is not the point here :) GHC does not do TCO of haskell expressions." which triggered this whole discussion
11:18:36 <ReinH> c_wraith: Ok, I can see what you're saying, but it doesn't generalize properly.
11:19:06 <cococo> (Let me know if there's a better channel for beginner help) Can anyone explain why this short script doesn't work? I don't understand the error message. http://pastie.org/9196713
11:19:06 <ReinH> rwbarton: I suppose I should word that differently in the future.
11:19:33 <ReinH> tail recursion really isn't the point, but GHC does "do TCO" as a specific form of normal-order evaluation
11:19:47 <ReinH> That I will agree to.
11:19:54 <c_wraith> ReinH: TCO is a lower level than normal-order evaluation.
11:20:03 <c_wraith> ReinH: TCO is part of an implementation strategy for evaluation
11:20:18 <ReinH> c_wraith: There are two things going on here that we should be explicit about
11:20:28 <ReinH> There's the reduction of the foldl that occurs in left-most outermost position
11:21:01 <ReinH> And there's the tail call optimization that the RTS does to function application that is known and fully saturated
11:21:20 <ReinH> c_wraith: Right?
11:21:23 <rwbarton> best to just hand-wave TCO away as irrelevant to normal-order evaluation and then go on about normal-order evaluation for long enough that they forget TCO ever came up in the first place :)
11:21:24 <c_wraith> One of them is at the level of denotational semantics, one is at the level of operational semantics
11:21:25 <chrisdone> cococo: is the error message something like "no instance for how (IO …) …"?S
11:21:31 <ReinH> c_wraith: Agree with you.
11:21:33 <chrisdone> cococo: er, is the error message something like "no instance for Show (IO …) …"?
11:21:39 <ReinH> c_wraith: I think people are using TCO to refer to the former rather than the latter
11:21:45 <cococo> chrisdone: first line is "No instance for (Show (IO (Maybe String, Maybe String)))"
11:21:46 <albeit> cococo: Something like this should work http://lpaste.net/104414
11:21:48 <johnw> chrisdone: ciao!
11:21:58 <chrisdone> hej johnw =)
11:22:02 <ReinH> chrisdone: hi <3
11:22:25 <chrisdone> ∈>
11:22:30 <ReinH> c_wraith: In most discussions about this, the latter is not even mentioned.
11:22:31 <albeit> cococo: whois returns IO a, and print accepts arguments of type a, not IO a
11:22:43 <ReinH> c_wraith: So I have an objection to the use of TCO to refer to the former.
11:23:03 <cococo> albeit: thanks but you pasted the same code I wrote
11:23:21 <chrisdone> cococo: you sure?
11:23:25 <albeit> cococo: No? http://lpaste.net/104414
11:23:36 <cococo> oh my bad I pasted the same url :p
11:23:48 <MitchellSalad> haha
11:23:49 <albeit> cococo: No worries... I've done that many times
11:24:09 <MitchellSalad> middle click
11:24:59 <c_wraith> ReinH: I just object to saying GHC doesn't do TCE.  It does, it's just not relevant in a lot of cases.  You should spend your time explaining the new part, rather than saying the part they actually understand fine isn't a good explanation.
11:25:15 <ReinH> c_wraith: You are correct and I will modify my pedagogy to account for this.
11:25:27 <ReinH> c_wraith: Thanks :)
11:25:35 <c_wraith> ReinH: yay! we're in agreement now! :)
11:25:43 <ReinH> c_wraith: I suspect that we have been for some time ;)
11:25:46 * ski beams
11:25:57 <ReinH> c_wraith: it was just a matter of getting the reduction to happen
11:26:04 <zerokarmaleft> so now we're all going clink our pints and go read that marlow paper
11:26:11 <chrisdone> cococo: in haskell you do IO by composing descriptions of actions to perform, making a type "IO something". the runtime then knows how to execute those actions
11:26:23 <ski> zerokarmaleft : which one ?
11:26:24 <ReinH> Seriously it's a very good paper to read if you care about evaluation semantics in GHC. http://community.haskell.org/~simonmar/papers/eval-apply.pdf
11:26:29 <ski> ok
11:26:31 <zerokarmaleft> ski: that one
11:26:33 <monochrom> GHC's "tail call" is in a somewhat different sense from, say, gcc's "tail call"
11:26:42 <ReinH> monochrom: indeed :)
11:26:47 <ski> yes
11:27:00 <cococo> chrisdone & albeit: can it be done without "do"? I've been told not to use use that until I truly understand Haskell & functional programming
11:27:08 <eacameron> I'm glad to see there is some consensus  ;)
11:27:12 <ReinH> I also object to the use of "function call" in this context, but maybe not strenuously enough to have another 15 minute argument about it ;)
11:27:15 <zerokarmaleft> cococo: print =<< (whois "example.com")
11:27:35 <cococo> cheers
11:27:42 <ReinH> eacameron: I think there was consensus, I just chose an unnecessarily argumentative phrasing :/
11:27:44 <ReinH> Sorry about that everyone
11:28:05 <ski> @undo do result <- whois "example.com"; print result
11:28:05 <lambdabot> whois "example.com" >>= \ result -> print result
11:28:11 <eacameron> haha; I only understood a few sentences anyway
11:28:16 <chrisdone> cococo: personally, i would go ahead and use `do' and write some programs with a healthy dose of theory on the side. it depends on how you like to learn, whether you like jumping in the deep end before you write anything useful, or vise-versa, etc
11:28:16 <ski> @. pl undo do result <- whois "example.com"; print result
11:28:16 <lambdabot> print =<< whois "example.com"
11:28:28 <monochrom> I have a pretty low threshold for "the difference is big enough, quit trying to reuse, learn from scratch".
11:28:29 <ski> cococo ^
11:28:53 <MitchellSalad> unforgivable, reinh
11:29:16 <rwbarton> monochrom: I just saw your http://www.vex.net/~trebla/haskell/exception.xhtml -- brilliant
11:29:20 <rwbarton> I'll have to refer to this in the future
11:29:25 <heatsink> albeit: You can give an explicit type signature to a function that operates on both a tag and a value, which allows type inference to see how the tag and value are related.  That's the clearest way to do it.
11:29:36 <ReinH> MitchellSalad: :( there is only one honorably solution to this
11:29:46 <heatsink> albeit: Otherwise, you can put an explicit type signature on tagIdentifier
11:29:59 <chrisdone> @faq seppuku?
11:29:59 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
11:30:00 <ReinH> monochrom: Yeah, I think that sums up my position too.
11:30:11 * chrisdone doesn't like lambdabot anymore
11:30:19 <monochrom> because all my life I am observing that people try to reuse one model for a subtlely different thing, keep patching and patching, and end up with a monstrous model rather than a simple and equivalent model
11:30:22 <MitchellSalad> +1 seppuku, defend your honor, ReinH
11:30:26 <heatsink> For example, let {tagged :: m a -> (TagIdentifier a); tagged m = (tagIdentifier, m) }
11:30:35 <ReinH> MitchellSalad: haha
11:31:19 <ReinH> monochrom: Yes exactly. I have become *very* sensitive to this.
11:32:12 <ReinH> monochrom: This is why I really like free objects as a pedagogic tool. You can go from the concrete to the abstract in a way that makes it impossible to lie or mislead.
11:33:01 <ReinH> "What are monads?" "Here are some examples of a monad" <- is likely to lead to false intuitions.
11:33:13 <ReinH> "What are monads?" "Do you understand functors? Ok, here is a free monad." <- is not.
11:33:54 <ReinH> Now you can use the fact that free objects are initial to talk about other specific examples.
11:34:54 <silasm> ReinH: I was meaning to ask about that at BayHac, so free objects are initial, nice. Is there a difference between free objects and initial objects?
11:35:11 <ReinH> silasm: not all initial objects are free (iinm)
11:35:21 <chrisdone> i prefer plain language in the style of carl sagan
11:35:30 <silasm> ReinH: iinm?
11:35:39 <ReinH> chrisdone: You can do this without using the words "free" or "initial" :)
11:35:43 <ReinH> silasm: if I'm not mistaken
11:35:45 <chrisdone> if you wish to make a monad, you must first invent a categorical universe
11:35:49 <silasm> ah, okay
11:36:10 <ReinH> chrisdone: You can say "Let's think about the most general possible monad. How would you construct it? What can you do with it?"
11:36:27 <ReinH> "What if we only had a type constructor that was a Functor?" etc
11:36:35 <ReinH> you don't need to talk about free objects and monad morphisms
11:36:37 <heatsink> I get the impression that, to be comfortable with free monads, you need familiarity with abstract algebra and maybe category theory.
11:36:40 <monochrom> no wonder chrisdone is inventing fay. "if you wish to make a new lambdabot, you must first invent a new language" :)
11:36:46 <ReinH> monochrom: haha
11:36:53 <chrisdone> <3
11:36:55 <ReinH> heatsink: You can learn them by construction without any of that
11:36:58 <johnw> silasm: however, initial objects are always free objects, says http://planetmath.org/algebraiccategorieswithoutfreeobjects
11:37:14 <ReinH> heatsink: but some algebra is helpful to see their implications
11:37:26 <ReinH> heatsink: for example, http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
11:37:47 <silasm> johnw: neat, thanks for the link.
11:38:11 <ReinH> Also Dan Piponi did a really great talk that used free objects to build up the abstraction ladder to get to free monads
11:38:14 <ReinH> one sec
11:38:15 <chrisdone> i like plain language like "monads in haskell are a type-class interface that you can implement for a type just like functors, monoids, traversable, etc." all the mystique and conflation with real category theory is misleading
11:38:48 <ReinH> heatsink: http://www.reddit.com/r/haskell/comments/25xef4/bayhac_free_monads_talk_by_dan_piponi/
11:38:56 <ReinH> reddit link because it has some useful info like links to the slides
11:39:09 <ReinH> chrisdone: sure!
11:39:09 <silasm> chrisdone: doesn't that explanation deemphasize the laws, though?
11:39:22 <tdammers> guys, does anyone have any experience with warp+scotty and handling HEAD requests correctly?
11:39:25 <ReinH> chrisdone: But then you can say "what if we had a type that was an instance of Functor and we wanted to make it a Monad?"
11:39:29 <silasm> I guess not if people already understand monoids though.
11:39:33 <xplat> monads really are (a special case of) the category theory thing
11:39:34 <ReinH> "What if we wanted to be able to do so for any instance of Functor?"
11:39:37 <ReinH> chrisdone: and etc
11:39:41 <ReinH> xplat: yes, they are.
11:39:52 <tdammers> I'm currently running a scotty web application behind an apache2 reverse proxy, and I get 404's on HEAD requests when the equivalent GET gives me a 200
11:40:04 <xplat> but you don't really need to know real category theory to use monads any more than you need to know number theory to use Integer
11:40:07 <klrr_> how difficult is it to get the basics of category theory? if not that difficult then having a really basic knowledge of what it is and used for etc. will that give any help in haskell or do you need comprehensive knowledge of it to get any practical value?
11:40:10 <chrisdone> silasm: i wouldn't say so, all the other type-classes have laws, too. when you come to examine a particular class it'll become clear that some laws go with it
11:40:23 <rwbarton> or than you need to know about monoids to use lists
11:40:29 <ReinH> silasm: Yes, you have to be careful to introduce the laws, and you don't get to show how they're the obvious laws in the appropriate category, etc.
11:40:38 <chrisdone> reinh: sure
11:40:40 <ReinH> silasm: the connection to the monoid laws will be gestural at best
11:40:48 <ReinH> But maybe that's sufficient.
11:40:59 <ReinH> silasm: (and the connection of both to the category laws ofc)
11:41:13 * monochrom frowns. why are you describing unit as throwing an exception! :)
11:41:40 <ReinH> monochrom: eh?
11:42:14 <monochrom> Gabriel Gonzalez's article you have just suggested
11:42:31 <albeit> heatsink: I think I'm following, but how would I then use tagged to get the tagIdentifier from within a monadic context?
11:42:40 <jle`> klrr_: not too difficult and in general it doesn't help you that much in practical haskell whether you know it very well or not at all
11:43:01 <ReinH> monochrom: wait he doe sthat?
11:43:18 <ReinH> *does that
11:43:44 <ferada> monochrom: okay thanks, then i've probably run into a bug though, http://lpaste.net/104415
11:43:53 <monochrom> "Ok, so let's hack together a quick and dirty fix to work around this problem. Our subroutine finished but we are not ready to call Done, so instead we throw an exception and let whoever calls our subroutine catch it and resume from where we left off: data FixE f e = Fix (f (FixE f e)) | Throw e"
11:43:54 <ReinH> rwbarton: There's a difference between wanting to learn IO and wanting to learn monads :)
11:44:05 <heatsink> I don't understand what you want, albeit.
11:44:09 <ReinH> If someone wants to learn IO you don't need to explain monads at all
11:44:24 <ReinH> monochrom: I shall have to have some words with young Gabriel ;)
11:44:37 <monochrom> if someone wants to learn IO, he/she reads my http://www.vex.net/~trebla/haskell/IO.xhtml
11:44:41 <c_wraith> If someone wants to learn monads, 90% of the time the correct answer is "You're worrying about the wrong thing."
11:44:41 <rwbarton> he sort-of-apologizes for it later
11:44:42 <ReinH> monochrom: indeed!
11:44:52 <ReinH> rwbarton: heh
11:44:56 <ReinH> c_wraith: that's fair too
11:45:00 <monochrom> if someone wants to learn monad, he/she reads my http://www.vex.net/~trebla/haskell/Monad.xhtml
11:45:19 <ReinH> monochrom: that is the best monad tutorial since Wadler's paper ;)
11:45:22 <albeit> heatsink: If you don't mind, here is the code I'm working from http://lpaste.net/104418. I'm trying to extract the tagNumber from the instance of the typeclass in the function
11:45:31 <ReinH> Indeed it is only slightly worse by way of introducing an unnecessary indirection
11:45:32 <xplat> if someone wants to learn burrito, they watch the food network
11:45:42 <toki78> monads are some kind of local context, right ?
11:45:43 <c_wraith> xplat: darn you.  Now I'm hungry.
11:45:59 <cococo> > check s = let stat = fst ("a","b") in stat
11:46:00 <lambdabot>  <hint>:1:9: parse error on input ‘=’
11:46:03 <cococo> > check s = let stat = fst (whois s) in stat
11:46:04 <lambdabot>  <hint>:1:9: parse error on input ‘=’
11:46:17 <cococo> does lambdabot require "let"?
11:46:23 <ReinH> toki78: No, but it doesn't really matter. Just learn how to use things that are instances of Monad.
11:46:33 <xplat> yes, lambdabot is a lot like ghci that way
11:46:37 <toki78> ReinH, okay
11:46:48 <cococo> > let check s = let stat = fst (whois s) in stat
11:46:50 <lambdabot>  not an expression: ‘let check s = let stat = fst (whois s) in stat’
11:46:56 <rwbarton> cococo: if you want to define things, it requires @let (instead of > )
11:46:57 <tdammers> toki78: no
11:47:06 <klrr_> jle`: okey, in some posts in tekmo's blog (haskell for all) he seemed to use category theory to design his programs, is that correct and if so how much knowledge of it do you need? (sorry if its too big qusetion)
11:47:15 <cococo> nvm :p
11:47:23 <ReinH> toki78: You'll notice that they all work with do notation and you might start to wonder why. Then would be a good time to learn what a monad is. :)
11:47:43 <silasm> klrr_: do you want to make lens/coroutine libraries?
11:47:54 <benzrf> toki78: just learn to use >>= with different monads as a specialized operator
11:47:54 <toki78> ReinH, do statements are syntactical sugga
11:47:55 <xplat> monads are monads.  there really isn't something simpler (in a human sense) that they are 'like'
11:47:55 <cococo> basically I can't call "fst" on a tuple of type `IO (Maybe String, Maybe String)`.
11:48:03 <chrisdone> monochrom: i didn't know you could write! i thought your irc messages were generated by grimacing enthusiastically at your memory bus until it changes appropriately
11:48:04 <c_wraith> klrr_: He does, that a good way to look at it would be: tekmo believes category theory leads to good abstractions.
11:48:05 <benzrf> toki78: you will eventually begin to see the similaritie
11:48:06 <benzrf> s
11:48:16 <klrr_> i dont know, but it would be cool to understand them (not that ive tried, but seems like a fun exercise)
11:48:19 <ReinH> toki78: That's correct. You'll notice that they all work with return, (>>), and (>>=) and you might start to wonder why. ;)
11:48:21 <benzrf> toki78: but it is very difficult to grok the general pattern without experience
11:48:22 <c_wraith> klrr_: it doesn't mean you need to know category theory to use the abstractions.
11:48:32 <klrr_> yeah
11:48:33 <tdammers> a monad is a type that implements bind and return (and fail, but that's kind of less important)
11:48:35 <heatsink> albeit: parseTag returns a 'Parser a'.  When parseTag is called, the caller knows what type 'a' should be.
11:48:35 <c_wraith> klrr_: It's just the history of where theose abstractions originated
11:48:43 <tdammers> that's really all there is to it
11:48:48 <silasm> tdammers: and respects the laws
11:48:50 <toki78> benzrf, okay that makes it clear
11:48:56 <heatsink> albeit: In this case, you're using the tag for 'a' together with the parser for 'a'
11:49:00 <ReinH> toki78: And then the next step is really to learn the laws.
11:49:08 <klrr_> c_wraith: okey
11:49:12 <toki78> ReinH, ?
11:49:13 <ski> chrisdone : surely you've seen SICP ?
11:49:16 <ReinH> toki78: And then if you're interested you might want to learn what they are algebraically, but it isn't necessary
11:49:19 <ReinH> toki78: the monad laws
11:49:21 <chrisdone> monochrom: i'm so with you, wadler's original paper about möneds is best paper
11:49:26 * hackagebot quickcheck-relaxng 0.0.1 - Generate RelaxNG-constrained XML documents for QuickCheck  http://hackage.haskell.org/package/quickcheck-relaxng-0.0.1 (AudreyTang)
11:49:31 <monochrom> chrisdone: there is the possibility of replacing "memory bus" by "a few sectors on the disk" and that gets you a long article :)
11:49:32 <heatsink> albeit: So you can tell type inference that they're related by defining a function that gets both the tag and the parser.
11:49:33 <chrisdone> ski: have you read your SICP today?
11:49:36 <ReinH> If you understand the typeclass and its laws you can use monads effectively without learning algebra or category theory
11:49:37 <ski> @where SICP
11:49:37 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
11:49:45 <ski> chrisdone : the latter one ;)
11:49:50 <klrr_> so well, if i read a bit about CT i will not become better at haskell but i might have a (tiny) easier way understanding the implementation of many abstractions in haskell?
11:49:52 <chrisdone> monochrom: tch, so that's how it's done, huh?
11:49:59 <ReinH> But the algebra and CT is pretty fascinating, so I'm happy to teach if you want to learn it just because
11:50:09 <c_wraith> you can think of the monad laws as meaning approximately "do notation works the way you think it should work."  Fuzziest possible interpretation of them, but if you're not interested in the specifics, it's a good intuition
11:50:13 <pranz> klrr_: yes
11:50:18 <chrisdone> ski: haha, i love the title pun!
11:50:18 <ReinH> c_wraith: right
11:50:23 <tdammers> silasm: yes, "obviously" - implement as in "implement such that they respect the laws"
11:50:31 <klrr_> okey
11:50:38 <chrisdone> “Storage and Identification of Cabalized Packages” =)
11:51:08 <silasm> klrr_: you might have better notions of abstractions, allowing you some nice ways to design programs, but you shouldn't learn CT because of that. You should learn it because it's fun.
11:51:08 <monochrom> monad laws and do-notation: http://www.haskell.org/haskellwiki/Monad_laws  and it came from my http://article.gmane.org/gmane.comp.lang.haskell.cafe/14967/ again
11:51:11 <heatsink> albeit: I've edited the code
11:51:12 <benzrf> toki78: think about it this way
11:51:16 <silasm> Honestly that's the same thing I tell people about haskell.
11:51:22 <ski> klrr_ : s/many/some/
11:51:22 <benzrf> toki78: let's say you had to explain numbers to somebody who had never learned them
11:51:23 <silasm> pretty much exactly.
11:51:23 <chrisdone> by Mo Monoson and Mono Mon Monson
11:51:34 <benzrf> toki78: numbers are used for a lot of things that on the surface seem unrelated
11:51:44 <benzrf> toki78: how strong a force is, how many things you have, how big something is
11:51:50 <benzrf> toki78: probabilities
11:52:12 <benzrf> toki78: if you havent used numbers a lot, you can't easily get an understanding of the same underlying abstraction beneath those things
11:52:22 <toki78> benzrf, I used monads before, but I have no explaining word for them
11:52:27 <benzrf> fair enough :)
11:52:28 <klrr_> okey well, learning something because its fun to learn seems fun, any book or beginner tutorials recommended?
11:52:30 <heatsink> albeit: on line 7, tagNumber returns a 'TagIdentifier a' and parseValue returns a 'Parser a'.  It's the same type for both.
11:52:42 <benzrf> klrr_: lyah is permanently recommended by everyone it seems
11:52:43 <heatsink> @where lyah
11:52:43 <lambdabot> http://www.learnyouahaskell.com/
11:52:56 <Polarina> How do I tell 'cabal haddock' not to hardcode paths? It's littered with file:///home/polarina/.cabal/... paths everywhere.
11:53:00 <Ralith> carter: aeson is the good json lib, right?
11:53:00 <klrr_> oh, well i already know haskell ;)
11:53:06 <klrr_> i mean category theory
11:53:16 <xplat> i like 'the angry algebraist's guide to mònáds'
11:53:29 <monochrom> "angry" :)
11:53:30 <pranz> Category Theorist for Scientist by Spiwak is great
11:53:33 <klrr_> ("know" as in want to believe i do know it ;))
11:53:40 <pranz> s/Theorist/Theory
11:53:42 <klrr_> pranz: okey, thanks
11:53:54 <ReinH> pranz: Frankly I'm not a fan of that one :/
11:54:01 <albeit> heatsink: Ahhh, I'm beginning to get it. Gonna stare at the code for a bit, it works great. Thanks a ton!
11:54:08 <heatsink> yup
11:54:27 * hackagebot quickcheck-relaxng 0.0.2 - Generate RelaxNG-constrained XML documents for QuickCheck  http://hackage.haskell.org/package/quickcheck-relaxng-0.0.2 (AudreyTang)
11:54:36 <ReinH> klrr_: If you want to learn category theory, here's what's worked best for me:
11:54:56 <ReinH> klrr_: start with Mac Lane's Algebra, then read Mac Lane's Categories for the Working Mathematician and Awodey's Category Theory at the same time.
11:55:10 <ReinH> Mac Lane's Algebra will get you from zero to an introduction to category theory by way of most of abstract algebra
11:55:17 <benzrf> http://abstrusegoose.com/272 <- me & math
11:55:29 <heatsink> lol
11:55:30 <ReinH> Then Awodey is a great resource when you run into parts of CftWM that you can't get through. Which will probably happen frequently.
11:55:30 <cococo> How can I get the first element of a tuple of type `IO (Maybe String, Maybe String)` ?
11:55:54 <rwbarton> type theory for dummies, conor-to-english dictionary
11:55:57 <ReinH> Mac Lane's Algebra is *very* approachable.
11:56:01 <Polarina> cococo, thatFunction >>= return . fst
11:56:11 <benzrf> rwbarton: did u click the comic
11:56:15 <rwbarton> yep
11:56:15 <klrr_> ReinH: thanks , gonna write that down
11:56:15 <benzrf> u gotta click through the comic
11:56:16 <benzrf> kk
11:56:27 <ReinH> klrr_: Basically use CftWM as a forcing function for reading Awodey :)
11:56:46 <rwbarton> oh wait
11:56:46 <xplat> zomg, quickcheck-relaxng sounds cool
11:56:46 <rwbarton> no
11:57:35 <rwbarton> benzrf: thanks :)
11:58:03 <cococo> thanks Polarina
11:58:05 <xplat> ReinH: i think the part of CftWM i couldn't get through at the time was 'the part after chapter 1'
11:58:17 <ReinH> xplat: Yep, sounds about right. Awodey is very good for that :)
11:58:23 <bernalex> are there any guides for using haddock with TH?
11:58:26 <ReinH> Read a few chapters of Awodey, do the exercises, come back to CftWM
11:58:32 <ReinH> Keep doing that
11:58:37 <silasm> ReinH: if I've already taken an algebra class (on groups, basically got up to the First Iso Theorem), should I still get Mac Lane's Algebra, or would I be better off going straight to CftWM and Awodey?
11:58:52 <ReinH> silasm: Try the latter and use the former as a fallback :)
11:59:01 <silasm> ReinH: sounds good
11:59:16 <ReinH> silasm: Awodey's presentation of algebra is basically applied category theory though, so it is a perfect introduction ;)
11:59:27 <djahandarie> I don't see how reading Awodey helps with CftWM.
11:59:33 <xplat> silasm: i would say 'still read maclane's algebra'
11:59:41 <djahandarie> The hard part of CftWM is the examples which pull from weird bits of math.
11:59:51 <ReinH> djahandarie: the hard part *for you*.
11:59:53 <djahandarie> Which reading Awodey won't help with.
11:59:56 <ReinH> Other people are not you and will have other hard parts.
11:59:59 <ReinH> Like me.
12:00:10 <ReinH> And for me, Awodey was very helpful.
12:00:16 <xplat> silasm: if nothing else it'll get you used to mac lane's way of thinking and writing, which ought to really help if you try CftWM
12:00:25 <ReinH> xplat: absolutely
12:00:38 <ReinH> Also it's really a very enjoyable presentation of algebra :)
12:00:51 <silasm> xplat: sure. I wouldn't mind having another algebra book anyways, love that subject.
12:01:05 <ReinH> silasm: My general approach has been to find every available book on a subject and read them all together
12:01:09 <ReinH> And cull the ones that aren't useful
12:01:18 <ReinH> And after doing that for CT, this is what I came up with
12:01:52 <ReinH> Other approaches might work better for other people, but not everyone wants to buy 20 books on category theory ;)
12:01:56 <silasm> ReinH: thanks for your trailblazing then
12:01:59 <xplat> either there were really few available books or that was the night of the really long knives
12:02:23 <ReinH> xplat: :)
12:03:05 <ReinH> There are some other nice books like The Joy of Cats (love the title), but they are generally subsumed by Awodey and Mac Lane
12:03:09 <ReinH> At least that's what I found
12:03:30 <ReinH> Also Awodey has some lectures on youtube
12:03:38 <ReinH> And there's TheCatsters on youtube as well
12:04:08 <silasm> ReinH: yeah, I've already watched a few of byorgey's ordering of the Catsters, very helpful.
12:04:24 <ReinH> Oh wait byorgey has an ordering? Why didn't I know about this. Link?
12:04:37 <silasm> ReinH: one sec
12:04:53 <ReinH> thanks!
12:05:01 <cococo> "parse error on input `|'" -> http://lpaste.net/6740513964876103680 ?
12:05:06 <djahandarie> ReinH, you weren't talking about yourself. You said "Then Awodey is a great resource when you run into parts of CftWM that you can't get through." And I was disagreeing that that is the case, especially for people with a Haskell background.
12:05:07 <silasm> ReinH: https://byorgey.wordpress.com/catsters-guide-2/
12:05:28 <ReinH> djahandarie: and I'm saying that you disagree based on your personal experience
12:05:32 <ReinH> And that not everyone will have that experience.
12:05:35 <silasm> he also has a few notes to go with it. Very helpful.
12:05:39 <ReinH> silasm: nice!
12:05:53 <ReinH> djahandarie: and I presented myself as a counter example.
12:05:54 <dmj`> How do I derive generic on a predefined ADT?
12:06:48 <xplat> ReinH: i think djahandarie read your original statement as universally quantifying over readers and was presenting *himself* as a counterexample
12:06:48 <ski> klrr_ : "Basic Category Theory for Computer Scientist" by Benjamin C. Pierce in 1991-08 at <http://mitpress.mit.edu/books/basic-category-theory-computer-scientists> might be interesting
12:07:20 <ReinH> xplat: Ah. Fair enough.
12:07:39 <ReinH> xplat: Both could perhaps be improved by the addition of "I think that..." ;)
12:07:56 <ReinH> Although at the limit this would be quite tedious
12:09:32 <cococo> What's wrong with how I've written my guards? http://lpaste.net/6740513964876103680 (parse error on input '|`, line 5)
12:09:56 <cococo> whoops, I mean line 4
12:10:10 <klrr_> you cant use let bindings before gaurd
12:10:13 <rwbarton> you can't ... do that
12:10:16 <ReinH> cococo: use a where binding
12:10:17 <rwbarton> turn the let into a where
12:10:18 <cococo> klrr_: should I use where
12:10:18 <klrr_> gaurd is simply "foo x | stuff.."
12:10:20 <cococo> ah, thanks
12:10:23 <klrr_> cococo: yes.
12:10:25 <ski> @google the angry algebraist's guide to mònáds
12:10:26 <ski> cococo : note that a value of type `IO (Maybe String, Maybe String)' is not a pair (a two-tuple)
12:10:27 <lambdabot> No Result Found.
12:10:31 <rwbarton> after "let ... in" you need to have an expression
12:11:25 <rwbarton> uh, right, this code won't work anyways
12:11:28 <xplat> ski: sadly, for now i just like the title
12:11:42 <rwbarton> your 'stat' is an IO action, you can't compare it to a String
12:11:49 <xplat> wiki magic not working fast enough ...
12:12:30 <ski> xplat : how is "mònád" pronounced ?
12:12:38 <ReinH> rwbarton: well we can at least get them to the *next* compiler error ;)
12:12:48 <xplat> ski: the same as 'monad', but angrier
12:15:09 * ski thought it would be pronounced, sortof .. lazier
12:15:28 <identity> then "mônấd" must be pronounced must be pronounced like "monad" but surprise..ier
12:16:12 <tdammers> what about "moonad"?
12:16:26 <tdammers> (for binding and returning livestock)
12:16:37 <MitchellSalad> rimshot
12:16:50 <identity> Same, but more bovine
12:17:16 <xplat> tdammers: you can't write it for equines, because the horse has already left the barn
12:17:48 <rwbarton> ReinH: one funny downside of static typing is if you're a novice and write code with several type errors it can then be hard to tell whether your changes are fixing errors or making things worse
12:17:53 <rwbarton> or just useless
12:17:58 <ReinH> rwbarton: hah goo dpoint
12:18:16 * ReinH looks askance at his space bar
12:18:18 <rwbarton> in dynamically typed languages usually you can tell you're making progress if the program gets farther before crashing
12:18:19 <monochrom> http://www.vex.net/~trebla/tmp/moo-nad.txt
12:18:29 <monochrom> also http://www.vex.net/~trebla/tmp/nu.txt
12:18:34 <cschneid> seems like a TDD style workflow would make that less of an issue.  (just a thought). Small functions, fail types fast.
12:18:44 <ReinH> monochrom: you can't prove to me that you didn't JUST write that :p
12:18:47 <xplat> doesn't new ghc have that option to defer type errors to runtime?
12:18:51 <ReinH> Well maybe you can
12:18:59 <identity> xplat: oh god what?!
12:19:03 <jfischoff> rwbarton: yes, your helping artticulate something I have noticed
12:19:07 <monochrom> I just wrote it up
12:19:17 <ReinH> cschneid: The whole "get to green ASAP" thing directly applies to type errors :)
12:19:25 <ReinH> monochrom: HA :)
12:19:35 <rwbarton> cschneid: well, novices can write code with a pretty high density of type errors :)
12:19:36 <byorgey> xplat: yes, -fdefer-type-errors
12:19:38 <jfischoff> xplat: yes
12:19:40 <hiptobecubic> identity, yeah i think so.
12:19:41 <cschneid> rwbarton: hah. Me for sure.
12:19:42 <monochrom> nu.txt was a long time ago. moo-nad is just after I read tdammers, yes.
12:19:45 <identity> what.
12:19:50 <byorgey> identity: it is actually quite useful in some situations.
12:19:50 <identity> are you guys serious? :|
12:19:51 <cschneid> rwbarton: ohh, lenses. Those 4 characters gave me a dozen errors. Oops.
12:19:52 <rwbarton> so there may not be small enough functions
12:19:53 <identity> how?
12:19:58 <hiptobecubic> identity, It's great for code development tools
12:19:59 <byorgey> identity: obviously you wouldn't use it for production.
12:20:02 <ReinH> monochrom: that's not fair you're just piping things to cowsay
12:20:18 <hiptobecubic> having ghc-mod fail to tell you anything because you have a type error in an unrelated function is pretty terrible
12:20:20 <monochrom> cowsay is the best thing since cow milk!
12:20:21 <byorgey> identity: say you are in the middle of a refactor and part of your file doesn't typecheck but you just want to test the part that does.
12:20:31 <identity> oh. yeah, okay. I see.
12:20:32 <ReinH> monochrom: I like piping fortune to cowsay
12:20:34 <tdammers> cowsay is the pinnacle of software engineering, and the pure zen of Unix wisdom
12:20:40 <identity> hey, wow. That could be really nice for ghci sometimes.
12:21:03 <byorgey> identity: exactly. =)
12:21:33 <ReinH> byorgey: Hmm that might be a missing piece for me too
12:21:43 <identity> We need something like ":loadanyway" / ":reloadanyway" to turn that flag on 'on the fly'
12:21:56 <ReinH> byorgey: can you pass an argument to cabal repl for that?
12:22:03 <ReinH> identity: ooh :)
12:22:08 <byorgey> ReinH: probably, I don't know
12:22:10 <xplat> :snafuload
12:22:19 <identity> :yesitcanlaunchmissiles
12:22:22 <byorgey> if you can get cabal repl to pass through arguments to ghci, then sure
12:22:23 <ReinH> clearly it should be called :yoload
12:22:29 <identity> ReinH: +1
12:22:37 <byorgey> hahaha
12:22:42 <identity> :yoload needs to happen.
12:23:58 <rwbarton> I see -fdefer-scope-errors in an April Fools' post but is there a reason it couldn't actually be implemented?
12:24:18 <enthropy> it is actually implemented
12:24:30 * hackagebot apiary 0.7.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.7.0.0 (HirotomoMoriwaki)
12:24:32 * hackagebot apiary-cookie 0.7.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.7.0.0 (HirotomoMoriwaki)
12:24:35 <enthropy> oh -fdefer-type-errors is implemented, not -fdefer-scope-errors
12:24:47 <vermeille> How can I automatically generate cabal dependances?
12:25:03 <napping> cabal init seems to automatically pick some
12:25:04 <jfischoff> @remember identity yoload needs to happen.
12:25:04 <lambdabot> Okay.
12:25:20 <rwbarton> just automatically replace undefinedIdentifier with (error "Not in scope: undefinedIdentifier")
12:25:26 <jfischoff> @forget identity yoload needs to happen.
12:25:27 <lambdabot> Done.
12:25:39 <jfischoff> @remember identity :yoload needs to happen.
12:25:39 <lambdabot> It is forever etched in my memory.
12:25:41 <vermeille> only some, napping a lot are missing
12:26:09 <vermeille> And it does not fits for dependancies added *after*
12:26:10 <enthropy> rwbarton: undefinedIdentifier becomes _undefinedIdentifier?
12:26:41 <identity> jfischoff: hah
12:26:53 <rwbarton> can you turn off the fact that holes are errors?
12:27:20 <enthropy> -fdefer-type-errors does that
12:27:33 <ski> rwbarton : it can also sometimes be hard to understand why something's a type error, if you haven't suffered some under DT :)
12:27:54 <rwbarton> > head [3,_x]
12:27:56 <lambdabot>  Found hole ‘_x’ with type: a
12:27:56 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
12:27:56 <lambdabot>             the inferred type of it :: a at Top level
12:28:08 <rwbarton> I get this same error with :set -fdefer-type-errors
12:28:20 <cschneid> rwbarton: oh, that's cool. I haven't actually had a chance to try holes yet
12:28:28 <cschneid> > head [3::Int, _x]
12:28:29 <lambdabot>  Found hole ‘_x’ with type: GHC.Types.Int
12:28:43 <rwbarton> but I'd like to get the output 3 also
12:28:45 <jfischoff> huh I find that a suprising infered type
12:28:53 <jfischoff> I would have thought Num a => a
12:29:12 <rwbarton> jfischoff: there is an open ticket about that I think, displaying the constraints
12:29:19 <jfischoff> ah
12:29:31 * hackagebot apiary-websockets 0.7.0.0 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.7.0.0 (HirotomoMoriwaki)
12:29:33 * hackagebot apiary-clientsession 0.7.0.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.7.0.0 (HirotomoMoriwaki)
12:29:35 <ski> rwbarton : "Re: [mercury-users] Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-09 at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html> and in 2006-10-10 at <http://www.mercurylang.org/list-archives/users/2006-October/004011.html>
12:29:35 * hackagebot apiary-authenticate 0.7.0.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.7.0.0 (HirotomoMoriwaki)
12:29:42 <jfischoff> I vaguely remember hearing that now ...
12:31:19 <enthropy> rwbarton: main = print $ head ["x", _x] -- works if it's in a file
12:31:41 <Polarina> Is there any reason to prefer CFloat and CDouble over Float and Double when dealing with FFI?
12:31:52 <rwbarton> oh, so it does
12:31:52 <enthropy> by works, I mean it prints "x"
12:32:20 <rwbarton> how odd
12:33:14 <rwbarton> I wonder if that is a ghci bug then
12:33:31 <enthropy> Polarina: I don't think so. I think it's a pretty good assumption that newtype CDouble = CDouble Double on all platforms
12:33:49 <enthropy> unlike the CInt /= Int story
12:34:43 <shachaf> Does -fdefer-type-errors work in ghci at all?
12:34:58 <rwbarton> ski: "3rd year students handing in C programs with obvious problems that the C compiler DID tell them about, but they weren't EXPECTING to understand anything the compiler said, so they didn't bother looking at what it did say or even the particular lines it was talking about" -- this is so familiar, also
12:35:15 <rwbarton> shachaf: oh, I guess not
12:35:30 <identity> It *needs* to
12:35:44 <rwbarton> it works for loaded files
12:35:48 <jfischoff> rwbarton: it might not be static
12:35:59 <enthropy> shachaf: it works for stuff like  let x = "1" + 1
12:36:00 <jfischoff> if so you can’t use it with :set
12:36:02 <rwbarton> but not in expressions you enter in the REPL
12:36:04 <Polarina> enthropy, sounds to me like these two newtypes are just in the way and serve no purpose.
12:36:16 <shachaf> Ah.
12:36:21 <rwbarton> enthropy: oh, even stranger
12:36:34 <jfischoff> oh wait it says it is dynamic
12:36:38 <identity> rwbarton: That's what I meant, for loaded files. Do some refactoring, or change something.. something breaks, you just want to load a part, :yoload file
12:36:42 <identity> it would be glorious.
12:36:49 <enthropy> const 2 ("1" + 1) -- does not work
12:36:52 <rwbarton> identity: right, that part works
12:37:30 <rwbarton> and, as enthropy told me originally, _foo (not in scope) is just a warning then too
12:37:34 <Vinzent> Hi. In Control.Concatenative there is a function biAp f c x y = c (f x) (f y). Turns out that I can't use it in situations like this one: biAp length (\x y -> [x,y]) [1,2] ["a","b"] -- typing error, since both collections have to be the same type. How can I get around this limitation?
12:37:48 <ski> rwbarton : suspected cut off near ".. -- this is so familiar, also" ?
12:37:59 <rwbarton> ski: oh, no
12:38:21 <rwbarton> I just meant, also in addition to "The presence of strict static type checking does little or nothing to stop students "debugging" code by making apparently random changes"
12:38:37 <enthropy> Polarina: I can imagine you might have a low-level part to your FFI binding, and cannot match CDouble against Double might save you from using a low-level function instead of a high-level one
12:39:26 <shachaf> Vinzent: You can make a function like that with a rank-2 type. But that's probably not really what you want to do.
12:39:26 <enthropy> Polarina: but I agree that the distinction usually just gets in the way
12:39:32 * hackagebot shelly 1.5.3.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.3.2 (GregWeber)
12:40:36 <Vinzent> shachaf, I guess it is actually! Let me google about rank-2 types...
12:42:27 <jfischoff> Vinzent: the second part of shachaf’s answer is also worth investigating ;)
12:43:34 <Kazagistar> I have found a number of places trying to explain fix makes sense cause math, but I am struggling to understand why it is useful, or why the much more useful Eq a => (a -> a) -> a -> a is not in the standard libraries instead...
12:44:29 <Cale> Kazagistar: Well, do you understand why all recursive definitions can be written in terms of fix?
12:44:38 <shachaf> Cale: Can they?
12:44:41 <Cale> yes
12:44:59 <shachaf> How do I do polymorphic recursion with fix?
12:45:18 <Kazagistar> sure, but that does not seem to add anything useful to defining them the other way
12:45:28 <shachaf> (This isn't related to Kazagistar's question -- it's a separate question.)
12:45:59 <Cale> shachaf: Well, okay, there might be some typing issues with regard to GHC's unwillingness to instantiate type variables with polytypes
12:47:21 <Cale> Certainly, it's possible for a compiler to implement fix as primitive and compile things in terms of that. I don't know whether or not there'd be issues with doing so in the case of GHC's typed core.
12:48:19 <Cale> Kazagistar: In practical terms, sometimes fix is quite handy when you want to write a loop in the middle of a do-block, for instance.
12:49:09 <Cale> fix $ \loop -> do ... ; unless (...) loop
12:49:17 <hseg> Question. Given a Traversable, is there a notion of "the next element"? i.e. test whether every Left is followed by a Right in a traverable
12:49:27 <Cale> and you can even add a parameter to that (albeit with slightly awkward parens)
12:49:50 <Cale> fix (\loop n -> do ... ; unless (...) $ loop (n+1)) 0
12:50:11 <napping> shachaf: you could hide the explicitly quantified type in a newtype
12:50:29 <Kazagistar> one that can't be expressed as one of the numerous other looping constructs I assume? or do you just forgo the use of foldl' or whatnot?
12:50:39 <shachaf> napping: Do you have an example?
12:50:51 <hseg> So something like allOf (traverse.filtered (has _Left).next) (has _Right) ?
12:51:09 <napping> in a bit
12:51:37 <Cale> Kazagistar: Well, it just saves you from naming the thing. You could put a 'let' in the middle of your do-block and then immediately execute the action which was recursively defined.
12:52:02 <benzrf> :t allOfv
12:52:03 <lambdabot>     Not in scope: ‘allOfv’
12:52:04 <lambdabot>     Perhaps you meant one of these:
12:52:04 <lambdabot>       ‘allOf’ (imported from Control.Lens),
12:52:05 <benzrf> :t allOf
12:52:06 <lambdabot> Profunctor p => Accessing p All s a -> p a Bool -> s -> Bool
12:52:17 <benzrf> >tfw when  still dont know these dumb synonyms
12:52:45 <Cale> Kazagistar: I'm not saying that you should use fix in place of more refined higher order functions
12:53:17 <benzrf> oic
12:53:40 <Vinzent> jfischoff, well, I guess you have another way to do it in your mind? I'd be happy to hear what else I should read about. Also, looks like union types would be handy in such a case, aren't they?
12:54:20 <jfischoff> why are you using Control.Concatenative?
12:54:33 <darthdeus> guys i'm a bit confused, i'm trying to figure out how to use the runUnixServer in conduit-extra (here http://hackage.haskell.org/package/conduit-extra-1.1.0.3/docs/Data-Conduit-Network-Unix.html#t:ServerSettingsUnix) ... but I don't see how to use this ... I mean i can spawn the server as runUnixServer (serverSettings "."), but that still epxects (AppDataUnix -> IO ()) function
12:55:26 <napping> shachaf: http://lpaste.net/104425
12:55:33 <darthdeus> do I use appSource and appSink in a function i give it to get the source and the sink to talk to that socket?
12:55:43 <wunki> how would I read a file and make sure that the entire file is processed? Just to test performance of reading an entire file in chunks?
12:55:48 <Vinzent> jfischoff, ah, I'm actually not using it, just exploring the stuff
12:56:02 <jfischoff> Vinzent: I see
12:56:27 <rwbarton> Vinzent: how would you envision using union types here?
12:56:35 <YayMe> Has anybody ever heard of any language attempting to implement law-checking at the language level, so you could define an operator and in the type annotation put "& :: (Commutative, Associative)" etc so the type checker could then validate that your implementation meets the laws?
12:57:15 <YayMe> It's easy to check at run-time, but some laws are simple enough that a test for them could be inferred and the compiler could easily identify for you whether the laws are met or not
12:57:15 <shachaf> napping: OK, I suppose so.
12:57:17 <benzrf> > allOf _1 (==3) (3, 4)
12:57:18 <lambdabot>  True
12:57:27 <ski> YayMe : i suppose dependent types wouldn't count
12:57:34 <ReinH> YayMe: is it easy to check at runtime? And by "check" do you mean "prove"?
12:57:46 <YayMe> ski: right, it's in the same vein but none of the dependant typing languages I've seen or anything really speaks to a concept like this
12:57:59 <ReinH> I can exhibit some examples that a & b is communtative without proving anything.
12:58:00 <YayMe> ReinH: Sure, commutativity and associativity are.
12:58:02 <ski> YayMe : in the melbourne mercury compiler, one can specify laws. the implementation is allowed but not required to check them
12:58:03 <jfischoff> Vinzent: if you just cursious how to solve that problem, then higher rank types will work there
12:58:28 <YayMe> ReinH: you could have to do a total check against the set of possible input types
12:58:29 <jfischoff> I think in a real situtation, you would not have that problem often
12:58:31 <ReinH> (1 / 1) is such an example
12:59:03 <YayMe> ^t (&)
12:59:25 <YayMe> ...forgot lambdabot commands...
12:59:31 <dario> :t (&)
12:59:33 <lambdabot> a -> (a -> b) -> b
12:59:50 <YayMe> :t (&&)
12:59:51 <lambdabot> Bool -> Bool -> Bool
13:00:03 <YayMe> the compiler could totality check commutativity there
13:00:07 <YayMe> :i Bool
13:00:40 <YayMe> totality checking Int or float or etc would obviously be ridiculous... so yes it would be more testing than proving
13:03:16 <napping> shachaf: the wrapper can also go to where the fixpoint is taken: http://lpaste.net/104425
13:03:29 <napping> why don't we just have QMLF?
13:03:55 <Vinzent> rwbarton, something like ((Union t t') -> t1) -> (t1 -> t1 -> t2) -> t -> t' -> t2, am I wrong?
13:04:14 <Vinzent> jfischoff, yeah. Thanks!
13:04:25 <napping> Oh, I guess it needs to play well with GADTs too
13:04:26 <napping> hmm
13:06:12 <rwbarton> I see
13:11:35 <jophish_> If you had to give a one sentence answer about the benefits of Haskell over C. What would it be?
13:12:10 <hseg> How do I import a module for use with lambdabot?
13:12:25 <jophish_> Something about the strong type system and the safety this affords.
13:12:36 <jophish_> would probably be my answer
13:14:01 <ski> hiroakip : did you try `@let import Foo' ?
13:14:04 <esoto> less bugs
13:14:04 <ski> er
13:14:07 <ski> hseg ^
13:14:11 <vlads> jophish_: I would rather go along beauty and grace, that let you deal with problem very elegantly.
13:14:39 <Polarina> I personally like all the strange looks people give me.
13:14:42 <hseg> jophish_, Yeah. That and well-thought out, elegant abstractions that force you to write well-thought out, elegant code.
13:14:45 <n-dolio> There are numerous reasons why Haskell is better than C for some tasks, but not necessarily for all.
13:14:53 <hseg> ski, Thanks. Didn't know what to search
13:14:57 <hseg> @help let
13:14:58 <lambdabot> let <x> = <e>. Add a binding
13:15:09 <hseg> See? Nothing about import there.
13:15:14 <Kazagistar> I want a data structure that acts like a self-balancing tree, where each branch also maintains a sum of the items in that branch, and where I can use that information to navigate the tree internals. In Java or something, I would just take an existing red-black tree, extend the node and its methods (like rotations) with a few lines of code and be done, but I am really struggling to see how to do this cleanly in Haskell... can anyone provide me with some
13:15:16 <Kazagistar>  direction?
13:16:37 <jophish_> vlads, hseg: I'll add in a couple of lines about that (writing a paragraph defending a choice of haskell for a project). It seems quite wishy washy to just be making these assertions though :/
13:16:40 <jfischoff> kazagistar: you haven’t really explained what is preventing you from doing that in haskell
13:17:25 <ski> @let import System.IO.Unsafe
13:17:27 <lambdabot>  .L.hs:117:1:
13:17:27 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
13:17:27 <lambdabot>      The module itself isn't safe.
13:17:32 <hseg> jophish_, Sure. Can't make thorough, convincing arguments in one line, can you? You can only gather nutshells in this way.
13:17:44 <jophish_> hseg: I guess your right
13:18:11 <jophish_> I'm preaching to the choir anyway at this university. I don't suppose anyone will mind
13:18:16 <esoto> less bugs, moar maths
13:18:37 <hseg> ^ best summary of the benefits ever.
13:18:39 <Kazagistar> jfischoff: I do not see how to, for example, add an addition piece of data to Map, and alter its associated functions to maintain some invariant about that data. Collections are... closed to modification?
13:18:40 <Polarina> And lots of safety without the loss of performance.
13:18:57 <dmj`> more happiness, less death
13:19:25 <Sculptor> if you wan't to win, you mustn't lose
13:20:36 <jfischoff> kazagistar: I think you wanted a red black tree? I Map a red black tree?
13:20:49 <jfischoff> I did a search on hackage and found this: http://hackage.haskell.org/package/RBTree-0.0.5/docs/Data-Tree-RBTree.html
13:21:25 <xplat> less marshmallow peeps, moar chocolate bunnies
13:22:45 <Kazagistar> jfischoff: I really don't care which self balancing tree I get, BTrees would probably actually be optimal, since they are just faster. But having to modify the tree code itself seems like a language weakness...
13:23:54 <jfischoff> kazagistar: some data structures are meant to extended to implement a variety of other data structures (fingertrees) other packages are not writtent this way
13:25:01 <jfischoff> Java is very permissive in how you can extend classes, but there are no guarantees that the invariants are perserved.
13:25:43 <jfischoff> In Haskell more general structures tend to have less power, the opposite tends to be true in Java
13:26:03 <napping> In particular, if your data structure just leaves everything "protected" you can probably destroy the balance invariants that make it a red-black tree at all - and if it's designed carefully enough that you can't, that's like a finger tree
13:26:27 <napping> as in, it was carefully considered what you could extend without breaking it entirely
13:26:53 <Kazagistar> napping: ill take a look at finger trees... did you say they are self balancing?
13:27:50 <napping> yeah, "2-3 finger trees" is the name if you want to find papers, fingertree on hackage - you can annotate them with any monoidal summary of the valueds
13:28:07 <napping> I do agree that sometimes more open recursion would be nice
13:28:27 <napping> if you really do want to just override some parts of an existing implementation to make a new thing, and take responsibility yourself that the result makes sense
13:28:47 <xplat> you can do some very open recursion in haskell if you mean to, but it uglifies your code
13:28:53 <napping> but I think having any kind of automatic subtype relationship on the result is a bad idea
13:29:11 <napping> Is it even possible to follow the Liskov Substitution Principle in Java?
13:29:34 <xplat> napping: technically no because reflection
13:29:49 <napping> xplat: I suspect a language could make it a lot nicer with a little bit of design work and syntactic sugar
13:30:11 <napping> like some way to automatically get an opened version from a mutually recursive definition group
13:30:46 <xplat> yeah.  and you might be able to do that with generics, e.g.
13:31:06 <Kazagistar> napping: that sounds exactly like what I am looking for. I want to be able to place events (which have a rate) into a data structure, be able to add and remove rates by identity, but also be able to select events using a random number generator such that the higher rates are proportionally more likely to be selected
13:31:52 <xplat> Kazagistar: yeah, the finger trees should work well for that
13:31:57 <awestroke> if a functor is a mapping between two categories in CT, what are examples of these categories in haskell, and what is the mapping?
13:32:19 <napping> xplat: what about removing them by index?
13:33:01 <napping> oh, I guess if you do a combination measure on the biggest index so far and on the total weight
13:34:02 <xplat> awestroke: an example of a category in Haskell is the (->) category, which is also called Hask
13:34:14 <hseg> awestroke, Take Maybe for example. It's a functor from the category of Haskell types and functions between them to the category of Haskell types with a point (Nothing) adjoined to them, and the functions between them
13:34:40 * hackagebot purescript 0.5.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2 (PhilFreeman)
13:34:49 <awestroke> so Functor maps from the Haskell Category (HC) to itself?
13:35:07 <xplat> the Haskell standard libs don't have a notion of functors between arbitrary categories, though--Functor in the Prelude is always a functor from Hask to Hask
13:35:16 <hseg> awestroke, Yep. Functor should actually be named EndoCovariantFunctor
13:35:38 <napping> I think functors are usually assumed to be covariant unless otherwise specified
13:35:38 <n-dolio> If you like terrible names.
13:35:51 <hseg> If you want to be pedantic.
13:36:01 <hseg> And avoid success at all costs.
13:36:13 <napping> Maybe you could fix it up a bit with polymorphic kinds?
13:36:17 <xplat> EndoCovariantFunctorOnHaskPedanticClass
13:37:03 <xplat> hseg: on the contrary, look how successful Java is
13:37:09 <awestroke> but then, if a functor can be a mapping between any two haskell types, is (->) then a functor?
13:37:29 <hseg> awestroke, It is, but not for that reason.
13:37:32 <xplat> awestroke: no, a functor is not a mapping between Haskell types
13:37:41 <johnw> ((->) r) is a functor
13:37:49 <napping> a type needs to have only one type argument left to be a functor
13:38:01 <napping> the partially applied ((->) r) is basically Reader r
13:38:05 <johnw> (->) is a Profunctor
13:38:12 <xplat> napping: you mean to be a Functor
13:38:46 <napping> to be a Functor, yes
13:38:53 <hseg> awestroke, Any type-level function f such that there exist instances ~>, => of Category and a function of type (a ~> b) -> (f a => f b) is a CT-functor
13:38:55 <xplat> profunctors are a kind of functor (*and* vice versa), but Profunctors are not a kind of Functor
13:39:15 <awestroke> hseg: type-level?
13:39:24 <hseg> s/type-level function/type-level function of kind *->*/
13:39:44 <hseg> awestroke, You can see Maybe as being a function from haskell types to haskell types.
13:39:51 <awestroke> hseg: oooh
13:40:08 <xplat> CT-category is more general than Category, too
13:40:21 <n-dolio> It also takes more than that to be a functor.
13:40:38 <hseg> Sure. Coherence laws must be satisfied.
13:41:39 <awestroke> so then the objects of  Haskell Category is types and the arrows are constructors?
13:41:59 <hseg> awestroke, objects are types, morphisms are functions between the types.
13:42:18 <awestroke> hseg: only type-level functions or all haskell functions?
13:42:39 <hseg> data-level functions. Stuff like id, const, (:[])
13:42:53 <awestroke> aah
13:42:56 <bebechancho> MORDEKAISER IS NUMERO UNO HUEHUEHUEUHEUHUEHUHE
13:43:03 <awestroke> and mappings betwen categories has to be type-level
13:43:05 <Kazagistar> ... (must remember to turn off smiley faces in #haskell)
13:43:07 <awestroke> I think I got it
13:43:11 --- mode: ChanServ set +o johnw
13:43:15 --- mode: ChanServ set +o johnw
13:43:15 --- mode: johnw set +b *!b5b1ef75@gateway/web/freenode/ip.181.177.239.117$#haskell-ops
13:43:15 --- kick: bebechancho was kicked by johnw (Kicked)
13:43:16 --- mode: johnw set -o johnw
13:43:57 <jfischoff> kazagistar: ha
13:44:11 <napping> How do you refer to kind parameters from a class defined with PolyKinds?
13:44:20 <napping> I wanted a
13:44:25 <napping> class Category (arr :: x -> x -> *) where
13:44:35 <johnw> awestroke: wait, why do mapping between categories have to be type-level?
13:44:36 <napping> and class (Category x a, Category y b) => HFunctor (f :: a -> b) where
13:44:37 <hseg> awestroke, http://www.cs.ox.ac.uk/people/daniel.james/functor/functor.pdf
13:44:37 <hseg>  is a great paper when it comes to seeing how functors are much more general than Functor
13:45:02 <hseg> awestroke, Wait, I think you misunderstood me.
13:45:09 <awestroke> probablyt
13:45:41 <hseg> awestroke, My fault. Let Hask be the category where haskell types are the objects and functions between them are morphisms
13:46:09 <hseg> awestroke, Then a functor Hask -> Hask is given by a map from types to types and a map from functions to functions.
13:46:22 <napping> How can I get at the argument kinds of the Category instances?
13:47:02 <hseg> awestroke, This map from types to types, what I called type-level functions, are what are usually known as type constructors. types of kind * -> *.
13:47:43 <rwbarton> napping, the kinds should just be inferred, no?
13:47:55 <awestroke> but that only maps types to types, not functions to functions
13:48:07 <hseg> awestroke, So, the functor Maybe : Hask -> Hask is given by the map Maybe :: * -> *, which maps haskell types to haskell types, as well as the map fmap :: (a -> b) -> (Maybe a -> Maybe b)
13:48:18 <rwbarton> whatever the x is for which a :: x -> x -> * will be passed automatically as the kind parameter to Category
13:48:20 <awestroke> aah alright
13:48:25 <napping> Oh, I guess the functor class doesn't make sense the way I was trying to write it
13:48:46 <napping> rwbarton: the thing is I want a functor class parameterized over two categories, and then get the kinds of objects from those categories
13:49:15 <hseg> awestroke, OK? Now any functor f : C -> D must satisfy that fmap id = id and fmap (f.g) = fmap f . fmap g
13:49:42 <hseg> awestroke, It just so happens that this may get more complicated with more complicated categories.
13:50:24 <awestroke> hseg: are there more complicated categories that relates to / is used in haskell?
13:50:30 <rwbarton> napping: I think you want to start with something like class (Category a, Category b) => HFunctor a b f where ...
13:50:49 <napping> yeah, that's accepted
13:50:58 <hseg> awestroke, Yep. As I mentioned above, http://www.cs.ox.ac.uk/people/daniel.james/functor/functor.pdf
13:50:59 <hseg>  discusses this.
13:51:20 <awestroke> thanks for the explanations, much appreciated. back to reading
13:51:41 <hseg> awestroke, My pleasure.
13:53:08 <napping> rwbarton: http://lpaste.net/104429
13:53:12 <pavonia> Does the size of wchar_t vary on different systems? In Haskell it's defined as Int32 but my winnt.h defines it to be an unsigned short
13:54:42 * hackagebot postgresql-orm 0.3.0 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.3.0 (AmitLevy)
13:54:44 * hackagebot pipes-aeson 0.4 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.4 (RenzoCarbonara)
13:56:17 <geekosaur> pavonia, yes. Windows would be expected to use 16 bit since natively it's UCS2 / UTF16; older Unix implementations also used 16 bit (my recollection from original System V curses) but generally has gone for 32 bit in the free *ixes
13:56:25 <rwbarton> pavonia: yes, most likely; on my linux x86_64 system it's 32 bits; I think GHC on windows is built against some other posix implementation
13:56:39 <rwbarton> but I don't really know anything about windows
13:56:53 <`^_^v> pretty much everything varies on different systems
13:57:50 <napping> rwbarton: I think a multi-parameter type class like that might make inference a bit tricky
13:58:13 <pavonia> Indeed, sizeOf CWchar yields 2 here. That's fine then
13:58:44 <pavonia> (My program isn't expected to work on non-Windows systems anyway)
13:58:45 <rwbarton> oh, well ignore me then :)
13:59:11 <rwbarton> (What's "defined as Int32" in Haskell?)
13:59:42 <luite> is there some easy way to decode a modified UTF8 ByteString to String or Text ?
13:59:42 * hackagebot simple 0.9.0.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.9.0.0 (AmitLevy)
13:59:45 * hackagebot simple-postgresql-orm 0.9.0.0 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.9.0.0 (AmitLevy)
13:59:52 <geekosaur> my guess is that the online haddocks are generated on linux and therefore show the definition for linux
14:00:00 <pavonia> rwbarton: newtype CWchar = CWchar Int32
14:00:21 <rwbarton> oh, gotcha, interesting
14:00:44 <pavonia> luite: Modified in what way?
14:00:58 <geekosaur> it is entirely possible that different definitions are used on Windows, and you wouldn't see it without digging through to the source
14:02:16 <pavonia> Maybe it's safer to create a new type with the correct width
14:02:51 <napping> rwbarton: aww, getting constraints is tricky - I was trying to make an instance HFunctor Nat (->) Fix, where newtype Nat f g = Nat (forall x . f x -> g x)
14:04:03 <Kazagistar> From finger tree paper: "Skewed reductions need not be written by hand; they can be defined generically for arbitrary f-structures"... is this referring to the foldMap Endo trick used in Foldable for foldl and foldr?
14:04:04 <luite> pavonia: modified utf8 has no null bytes, uses a longer encoding for the 0 codepoint
14:04:21 <rwbarton> napping: ok, that sounds like it should possibly work
14:05:19 <rwbarton> but, I gather that it didn't? :)
14:05:40 <napping> well, now I'm trying to add a type family computing a constraint for objects
14:06:14 <napping> Oh, proving that f preserves the constraints doesn't look easy
14:06:26 <napping> how could you even write that?
14:06:28 <rwbarton> oh does this only work when f and g are actually functors?
14:06:42 <rwbarton> I tend to assume that without noticing it :)
14:06:58 <luite> pavonia: the text package doesn't accept it, utf8-string produces a wrong character
14:07:04 <napping> well, maybe it's not necessary to force it
14:07:23 <napping> that the result of f have the right instances - stuff will just break if you try to write too generically
14:07:30 <rwbarton> pavonia: hmm how are you concluding that "newtype CWchar = CWchar Int32"?
14:08:08 <pavonia> luite Maybe you can do that with Data.Text.Encoding.decodeUtf8With
14:08:09 <napping> rwbarton: this is accepted http://lpaste.net/104429
14:08:15 <napping> might break if I try to use it for anything
14:08:24 <enthropy> is http://hackage.haskell.org/package/singletons-1.0/docs/Data-Singletons-Prelude-Ord.html#t:SOrd missing instances?
14:08:59 <pavonia> rwbarton: That's what it is defined here http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-C-Types.html#t:CWchar
14:09:21 <rwbarton> pavonia: those docs were probably not built on windows :)
14:09:29 <rwbarton> try in ghci  :i Foreign.C.Types.CWchar
14:09:51 <rwbarton> (agree this is confusing/misleading)
14:09:58 <rwbarton> the newtype declaration is produced by a CPP macro
14:10:01 <pavonia> Yes, it's indeed newtype CWchar = Foreign.C.Types.CWchar Word16 here
14:10:06 <rwbarton> + autoconf magic
14:10:09 <rwbarton> okay, good
14:10:18 <pavonia> That's why I asked if it varies on different systems
14:10:47 <napping> can't get a nice higher-kinded fix, can you?
14:11:46 <luite> pavonia: none of those seem to be a good fit, replacing might work, but only if it's otherwise correct utf8, and i don't know that
14:12:11 <pavonia> Hhm, I see
14:13:05 <glguy> luite: The easy way is probably to use two passes, one to convert it to valid UTF8 and then go through Text
14:13:47 <glguy> if you find a sequence that looks like a two-byte encoded NUL it is one, they can't embed in the middle of a longer character
14:15:16 <luite> glguy: right that's what i just started doing, but it feels rather ugly...
14:15:17 <luite> bleh
14:15:42 <luite> i should get stuff released, no time for making it look good ;)
14:21:12 <csabahruska> hi, does anyone have experience with Bound library?
14:21:38 <napping> a little, what are you doing?
14:23:08 <csabahruska> i'd like to impelement code generator for a toy AST
14:24:14 <csabahruska> do you know any related example code?
14:26:12 <mmachenry> csabahruska: Have you looked at Haskell's LLVM library?
14:26:54 <csabahruska> mmachenry: does it use Bound?
14:27:36 <csabahruska> i'm looking for a Bound + code generator sample code
14:27:51 <capybara> map (+2) [1..10]
14:28:05 <capybara> > map (+2) [1..10]
14:28:06 <mmachenry> csabahruska: No.
14:28:07 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
14:29:56 <awestroke> how can "sequence . take 1 . repeat $ ioFunction arg" take exactly as long (~5 seconds) as "sequence . take 20 . repeat $ ioFunction arg" (ioFunction uses Repa foldAllP)
14:31:08 <ski> @src replicateM
14:31:08 <lambdabot> replicateM n x = sequence (replicate n x)
14:31:09 <awestroke> when I benchmark the function with criterion, I get a mean of ~200 ns. NANOSECONDS. It seems to compute once only for all iterations, then divide by number of iterations
14:31:09 <ski> @src replicate
14:31:10 <lambdabot> replicate n x = take n (repeat x)
14:31:51 <ski> it should execute the `IO'-action twenty times in the second case
14:32:17 <awestroke> ski: still, it runs in exactly the same time
14:32:23 <rwbarton> well, if there is sharing between the different executions of ioFunction ...
14:32:44 <rwbarton> like if you write let x = <huge expression> in sequence . take 20 . repeat $ print x
14:33:11 <rwbarton> that's the simplest way it could happen
14:38:22 <rwbarton> GHC optimizations can introduce sharing where you wouldn't expect it from the usual rules of lazy evaluation, so it can be hard to be sure you don't have sharing
14:38:44 <Pythonfant> Is there something like sage but using haskell instead of python?
14:42:06 <NemesisD> anyone know the difference between stopped and terminated? http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Process.html#t:ProcessStatus
14:42:28 <NemesisD> does stopped mean the process quit on its own volition and terminated meant the OS killed it?
14:42:49 <benzrf> NemesisD: isn't that sigstop?
14:43:10 <benzrf> NemesisD: like pressing ^Z
14:43:20 <NemesisD> ohhh i think you may be right
14:43:38 <hpc> ^Z is a signal?
14:44:02 <NemesisD> it suspends the currently running process in a terminal
14:44:08 <n-dolio> ^Z is Z with the control modifier.
14:44:28 <awestroke> rwbarton: it had to do with let binding sharing, I did some IO (return $) binds and now it doesn't share anything
14:44:42 <hpc> n-dolio: i know that much ;)
14:44:43 <awestroke> rwbarton: thanks for the idea
14:50:33 <pavonia> Any ideas how define a Storable instance for a type Foo = Foo [Bar] where the Bars are stored as a fixed-length array, but this length comes from another place?
14:51:22 <geekosaur> NemesisD: more precisely, ctrl-Z sends SIGTSTP, one of 5 ways to enter the "stopped" state. (the others are: directly sending SIGSTOP, SIGTTIN (set when a backgrounded process tries to read from controlling terminal), SIGTTOU (same but tries to write), and debugger stop)
14:52:32 <geekosaur> SIGTSTP, SIGTTIN, and SIGTTOU can be trapped and responded to; SIGTSTP handler must send the STOP signal to the process though, or it will be forcibly stopped by the OS
14:53:45 <pavonia> I could give it a type parameter representing the length, but that will cause new problems with mixed lists of differently sized Foos
14:54:03 <geekosaur> oh, BSDish systems also have control-Y (delayed suspend) which sends SIGTSTP when the program actually does a read on its controlling terminal instead of immediately
14:54:43 <rwbarton> Storable only makes sense for fixed-size data structures
14:55:25 <geekosaur> and /proc based debugging may or may not use the same mechanism as the old ptrace stop; Solaris's did not
14:57:09 <rwbarton> pavonia: though I guess maybe you could use the implicit parameter superclass trick/bug
14:57:53 <pavonia> How would I do that here?
14:58:34 <pavonia> like instance (?length :: Int) => Storable Foo?
14:58:44 <rwbarton> yes
14:58:52 <rwbarton> N.B., I don't endorse this
14:59:08 <n-dolio> They fixed that, didn't they?
14:59:20 <rwbarton> yeah, I think maybe they did
14:59:42 <pavonia> Yeah, this feels wrong
14:59:56 <jfischoff> why does Network.Socket.Socket not have NFData instance?
15:00:14 <rwbarton> I guess you could use some reflection trick, but that seems even worse somehow
15:00:51 <pavonia> I'll refactor my types then
15:00:54 <n-dolio> Yep, that isn't allowed in 7.8.2.
15:02:45 <jfischoff> I see deepseq used to depend on containers
15:03:39 <jfischoff> @tell tibbe is there a reason not to have NFData instances for all the types in Network?
15:03:41 <lambdabot> Consider it noted.
15:06:28 <benzrf> lenses keep frying my brain
15:07:26 <Kaidevappy> benzrf: is the problem their lovecraftian types?
15:07:29 <enthropy> anybody familiar with singletons? Shouldn't this work http://lpaste.net/104436 ?
15:08:12 <benzrf> Kaidevappy: among other things
15:08:12 <benzrf> :{
15:08:59 <Kaidevappy> well basically what people seem to say is
15:09:10 <Kaidevappy> "just use them and don't think about the type signatures unless you want to go insane"
15:09:50 * hackagebot pretty-show 1.6.8 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.8 (IavorDiatchki)
15:11:35 <Polarina> Kaidelong, code never compiles on the first try. Lenses' type errors are as frustrating as typical errors are to a Haskell newcomer, except with the added bonus of rot13 encryption!
15:11:50 <benzrf> Kaidelong: i am jumping in
15:12:17 <benzrf> already i can decipher most basic types given 5 minutes and peace and quiet!!!
15:13:09 <enthropy> if you've moved on to ghc-7.8.2, I think type errors are too big there
15:13:36 <enthropy> as in if you fix the very first error, most of the problems in the original message go away too
15:16:03 <Kaidelong> I find ghc-mod helps a lot
15:16:15 <Kaidelong> type errors are less intimidating if you catch them early
15:16:36 <Kaidelong> and if you use :GhcModType to check if things have the types you think they do
15:16:44 <benzrf> Kaidelong: i have that bound to ^T!
15:16:49 <benzrf> it shows up in my statusbot bar
15:16:52 <benzrf> *statusbar
15:17:03 <Kaidelong> I use F2
15:18:11 <benzrf> fkeys? grose
15:18:31 <Kaidelong> keychording is hard on a tiny keyboard
15:21:24 <bitemyapp> does anybody here have an Emacs/ghc-mod rig that automatically shows the type of whatever your cursor is resting on?
15:22:54 <MitchellSalad> i'm thinking about making a website to keep track of all haskell teaching resources i come across, organized by topic, but before I do does anyone know of something similar?
15:23:20 <MitchellSalad> sort of like that huge "this is what i wish i knew when i was learning haskell" blog post, but just full of external links, not in-line information
15:27:13 <jle`> MitchellSalad: even if there is, i hope it doesn't discourage you from doing your own :)
15:27:51 <MitchellSalad> oh it would
15:28:39 <jle`> darn
15:28:39 <MitchellSalad> :D
15:31:57 <Kaidelong> jle`: would you mind if I lean on you for help understanding what on earth I should do to make life easy for people using netwire?
15:32:10 <jle`> Kaidelong: I don't 100% understand your question
15:33:03 <jle`> but i'll gladly help with any questions you might have
15:33:03 <jle`> heh
15:33:03 <Kaidelong> jle`: you mind getting emails asking about "how do I design this netwire library?"
15:33:03 <jle`> netwire library?
15:33:03 <jle`> library built on top of netwire?
15:33:03 <Kaidelong> netwire-glfw-b
15:33:03 <jle`> ah
15:33:03 <jle`> yeah sure, i wouldn't mind
15:33:49 <Kaidelong> I'm actually starting to think the whole effort is unneccessary though
15:33:49 <jle`> did i ever send you my simple netwire backends?
15:33:49 <Kaidelong> no, I don't believe so?
15:33:56 <jle`> er...rendering backends, or frontends
15:33:56 <jle`> not sure how to call them
15:33:56 <Kaidelong> actually no the effort isn't entirely unnecessary because I need to provide a central clock
15:33:58 <jle`> https://github.com/mstksg/netwire-experiments/tree/master/src/Render/Backend
15:36:12 <Kaidelong> so I guess netwire-glfw-b does need to be aware of the existence of wires
15:36:12 <jle`> i think when mm_freak actually does his own stuff he does some performance hacks using an underlying IO monad
15:36:12 <jle`> for the wires
15:36:13 <jle`> but those are things he would probably discourage people from doing...i think...
15:36:13 <jle`> so my backends are "pure" i guess in the sense that it separates effects from the wires themselves
15:36:13 * hackagebot pipes-parse 3.0.2 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-3.0.2 (GabrielGonzalez)
15:36:13 <Kaidelong> well the more I've developed my code base the more unsafePerformIO has been disappearing
15:36:13 <Kaidelong> I think it's not actually being used at all right now
15:36:13 <jle`> i...don't even know why would need unsafePerformIO
15:36:13 <Kaidelong> global state
15:36:13 <Kaidelong> (glfw has a lot of it)
15:36:13 <jle`> um
15:36:39 <jle`> ok, i'm not too familiar with glfw, even though that was going to be my next backend before i got busy with other things
15:36:53 <Kaidelong> the conclusion I've come to is to explicitly thread state though because
15:36:59 <jle`> what state are you talking about?
15:37:02 <Kaidelong> GLFW has to be initialized, and then destroyed when it is finished
15:37:11 <Kaidelong> which sounds like a MonadIO instance
15:37:33 <jle`> :|
15:37:43 <Kaidelong> jle`: in my case the windows that were open, the errors waiting to be handled on the next tick, and the input waiting to be handled on the next tick
15:37:47 <jle`> oh
15:37:53 <jle`> yeah i think i remember talking to you about this
15:38:22 <jle`> if...you're doing some sort of windowing system...you might want to consider handling it with push-pull frp, actually
15:38:30 <jle`> like sodium or reactive-banana
15:38:49 <jle`> things like GUI's
15:39:02 <Kaidelong> well I'm not trying to provide a widget toolkit
15:39:19 <Kaidelong> what I'm trying to do is "push input into a wire, attach it to a window, use that wire to draw to the window"
15:39:22 <Kaidelong> but
15:39:32 <Kaidelong> maybe push-pull is still better for that?
15:39:48 <Kaidelong> FRP without "push" control flow is kind of strange in the first place and seems to defy the purpose a bit
15:40:24 <jle`> push-pull is built/modeled around behaviors that discretely alternate between periods of constancy and determinsitic/non-reactive continuous change, followed by constant output
15:41:16 <jle`> sort of like... a linked-list sort of thing
15:41:40 <jle`> whereas arrowized frp and netwire etc. are completely pull-based
15:42:54 <Kaidelong> well the way I'm working around that is this
15:43:06 <jle`> and there is no meaningful difference between periods of constant behavior and periods of continuous change...a your engine just generates the "next output" from scratch every time and "recomputes" (to an extent) constant values at every tick
15:43:15 <Kaidelong> the user gets a window when they make a new window, and there is a function that attaches a wire to windows
15:43:21 <Kaidelong> the windows then pull from the wire at each tick
15:43:35 <Kaidelong> giving it the time delta from the central clock
15:44:36 <jle`> that seems fine, i'd think
15:44:57 <Kaidelong> if you attach a wire repeatedly
15:45:03 <Kaidelong> the combining function is -->
15:45:13 <Kaidelong> and the wire the window starts with is inhibit
15:45:37 <lpsmith> hahaha,  when I was asking about Tarjan's algorithm this morning,  somebody added the Knuth quote that answered my question to the wikipedia article between the first time I viewed the article and shortly thereafter
15:45:41 <lpsmith> weird
15:46:00 <lpsmith> so when I revisited the page, I was finally satisfied
15:46:14 <lpsmith> I was wondering why I didn't see that the first time
15:47:29 <Kaidelong> my biggest worry at this point is that I'm not thinking about asynchronous IO at all
15:47:58 <jle`> Kaidelong: well...do any of your wires actually perform IO?
15:47:59 <jle`> (they shouldn't)
15:48:32 <jle`> the base monad should be Identity or maybe Reader
15:48:35 <Kaidelong> jle`: I'm not writing any wires yet, just writing functions that attach them and pull from them
15:48:39 <jle`> ah
15:48:42 <Kaidelong> well
15:48:49 <Kaidelong> it looks like I'm going to end up with something like
15:49:14 <Kaidelong> ExceptT GLFWSessionError (ReaderT IO) a
15:49:33 <Kaidelong> ReaderT GLFWSessionGlobalState*
15:50:06 <jle`> for the underlying monad?
15:50:08 <jle`> of your wires?
15:50:40 <Kaidelong> yeah although I'm thinking it's okay because wires in the Identity monad can be lifted into it pretty trivially
15:51:09 <Kaidelong> actual error handling should not be done by the wires, but inside of IO
15:51:37 <Kaidelong> and the wires should not have access to the global state either
15:51:48 <Kaidelong> (info from the global state gets pushed into them by the window)
15:53:01 <jle`> i have to head to class, but feel free to email me
15:53:07 <Kaidelong> thanks
15:53:18 <Kaidelong> I'll be working on it again tomorrow
15:53:21 <jle`> i don't see why your wires would have to wrap anything besides Identity
15:53:58 <hseg> Is there some way to zip Traversables? If not, how much stronger do my constraints need to be?
15:54:00 <jle`> but i might not know enough about what you are doing
15:54:04 <Kaidelong> well the windows need to be able to lift them into their underlying context but "attachWire" could restrict it to Identity
15:54:13 <Kaidelong> that's not a problem
15:54:20 <jle`> ah, okay.
15:55:50 <benzrf> are there any northeast US hackathon-type-things between now + fall
15:56:53 <Enigmagic> benzrf: they just announced one at mit in august
15:57:12 <benzrf> Enigmagic: sweeeet
15:57:33 <Enigmagic> benzrf: http://www.haskell.org/haskellwiki/Hac_Boston
15:58:27 <ReinH> I'm going :)
15:58:35 <hseg> Know of any in the Middle East? Or in Western Europe in June?
15:58:54 <benzrf> oh wait
15:59:03 <benzrf> this is only for college students?
15:59:11 <ReinH> I doubt it. Since I'm going.
15:59:20 <benzrf> well, http://www.hackmit.org/
15:59:36 <benzrf> oh different thing
15:59:38 <ReinH> Hac_Boston page says, "It is open to all"
16:00:30 <shachaf> hseg: There's ZuriHac in June.
16:01:31 <hseg> Nice.
16:01:57 <cococo> Can anyone take a look at this? http://lpaste.net/8402927481094406144 I _think_ the solution involves converting "stat" to a string, but I'm very new to Haskell so who knows :/
16:02:10 <hseg> Unfortunately it will happen before I will reach europe and is full.
16:03:20 <hseg> cococo, just looking at the shape of the code, it seems stat is of type IO String, while you're comparing it to a value of type String
16:04:30 <cococo> hseg: how can I solve that? And what's the difference between them?
16:04:54 <shachaf> @faq has a good answer to your question.
16:04:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
16:06:59 <SavinaRoja> ultra noob here: typing the inverted dagger/cross glyph, possible with US layout?
16:07:09 <hseg> cococo, As shachaf said, look at the FAQ.
16:07:54 <cococo> hseg: there are no instances of "io string"
16:08:22 <cococo> I find these wikis only start to become helpful once I have a solid understanding of the language it teaches
16:08:29 <hseg> cococo, But in a nutshell, a value of type IO String is just a promise made to you by GHC that one day you'll have a String. You can work with that promise in ways resembling working on strings, but you're not working on strings.
16:09:39 <Polarina> A famous quote: "getLine :: IO String contains a String in the same way /bin/ls contains a list of files."
16:09:40 <shachaf> I would not call it a promise.
16:10:19 <shachaf> For example, if you "use" getLine :: IO String twice you can get two different strings.
16:10:19 <pdxleif> basically you write "getLine >>= putStrln" instead of "putStrLn( getLine )"
16:10:25 <SavinaRoja> should I just create a special map for "+" and have done with it?
16:12:38 <binroot> Hi, what is the <<< function? It's hard to google for it. Any help please!
16:12:45 <shachaf> binroot: Use Hoogle:
16:12:46 <shachaf> @where hoogle
16:12:46 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:13:09 <cococo> hseg: I still don't understand how to change the script to get it to work?
16:13:18 <binroot> shachaf: oh wow, thanks!
16:13:21 <ski> @hoogle <<<
16:13:21 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
16:13:21 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
16:13:44 <johnw> there should really be a HaltaVista
16:13:59 <alorente> hahaha
16:14:12 <ski> "HastaLaVista"
16:14:39 <alorente> hoogle/hayoo are incredibly compelling features of Haskell IMO
16:14:47 <sipa_> HaskaLaVista
16:15:55 <hseg> cococo, Have you read the FAQ? http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F explains the problem, while http://www.haskell.org/haskellwiki/Introduction_to_IO
16:15:55 <hseg>  explains how you need to change your script.
16:15:59 <Kazagistar>  could someone explain why haskell won't let me write "instance Measured (Index, Rate) Event where"?
16:17:54 <shachaf> Perhaps GHC (assuming you're using GHC) can explain.
16:21:02 <SavinaRoja> in lyah, a double inverted cross is shown to be operator for list concatenation
16:23:26 <SavinaRoja> I am trying to find the exact unicode value for the keybinding
16:23:50 <geekosaur> I am confused. list concat is (++)
16:24:31 <Kazagistar> ok I see... followup question, what prevents FlexibleInstances from being enabled all the time? is it just a quirk of tradition or something?
16:25:27 <SavinaRoja> geekosaur: so double plus works as well?
16:25:41 <geekosaur> "as well"? it's the standard one
16:25:46 <geekosaur> I have no idea what you are seeing
16:25:54 <geekosaur> I don;t recall lyah playing unicode games
16:27:27 <SavinaRoja> geekosaur: it looks like the plus sign but with a much longer upward extending bar
16:27:32 <geekosaur> and I do not see any special characters for list concat in http://learnyouahaskell.com/recursion#hello-recursion
16:28:10 <pavonia> SavinaRoja: Do you mean (⧺)?
16:28:54 <pavonia> (taken from http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.4/docs/Data-List-Unicode.html)
16:29:17 <SavinaRoja> pavonia: similar, but the horizontal bar is not centered in the height
16:29:32 <SavinaRoja> I'll just take it as a browser display anomaly
16:29:46 <SavinaRoja> testing the "++" works in code
16:30:34 <pavonia> SavinaRoja: Could you link to where you found that character, please?
16:30:35 <SavinaRoja> huh, looking back, when I copy-pasted the character it came out as "+"
16:30:48 <SavinaRoja> http://learnyouahaskell.com/starting-out#an-intro-to-lists
16:32:18 <pavonia> Hhm, I can only see "++" there
16:32:40 <Cale> SavinaRoja: Check the choice of encoding in your browser
16:32:58 <Cale> It should say Unicode (UTF-8) for that page
16:33:09 <SavinaRoja> pavonia: looks normal in lynx
16:37:40 <SavinaRoja> Cale: encoding is UTF-8
16:46:39 <benzrf> RSVP'd to hac boston :D
16:46:42 <benzrf> \o/
16:47:53 <darthdeus> if anyone knows a bit about resourcet, http://stackoverflow.com/questions/23795650/what-is-the-correct-way-of-cleaning-up-resources-using-resourcet :)
16:49:17 <quickezed> I'm trying to run the following in Raskell (Haskell app for the iPad). I receive an error which is contained in the comments in the paste.
16:49:17 <quickezed> http://lpaste.net/104438
16:49:35 <quickezed> The same code runs fine in ghci.
16:49:47 <quickezed> Does anyone know what I'm doing wrong in Raskell?
16:50:41 <grache28> heh - i'm an in introductory programming class that 'requires' used to use visual studio - i just use emacs & gcc coz that's what i know. Anyway the version of visual studio the university put on their ftp had some linker issue that threw an error. Two people complained the first day of class (the 13th) on the message board, so I google'd the error and linked to a stack overflow entry that gave step by step
16:50:43 <grache28> instructions on how to fix it by disabling incremental linking  and also gave a link to download a service pack to fix it.
16:51:04 <benzrf> grache28: move to a different class
16:51:05 <benzrf> :{
16:51:22 <grache28> there's been another half dozen people asking the same question over again, so a couple other students have copy pasted the instructions from the link - and were graciously thanked for it
16:51:34 <benzrf> anything that requires proprietary software is an INJUSTICE UPON US</rms>
16:52:06 <grache28> the original student who posted about the problem asked today (8 days later) for a link to the service pack (which was provided in my link the same day she asked) and was given it and thanked the guy who gave it to her
16:52:32 <grache28> so obviously it was too dificult to google themselves, and even far too difficult to click on the link i gave them
16:52:35 <shachaf> grache28: Does this have to do with Haskell?
16:52:54 <grache28> ..and then haskell :)
16:54:27 <grache28> shachaf: just an anecdote, made me realize I'm probably the same way in asking questions here I could have answered myself if I only read more
17:01:40 <Kazagistar> xplat: I am getting confused on how to find items in a finger tree by identity... do I have to manually maintain an invariant in the finger tree like "all items are ordered by identity, which is in class Ord"?
17:05:04 * hackagebot HUnit-Plus 0.3.0 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.0 (emc2)
17:05:22 <rwbarton> quickezed: do notation is intended to be used with a monad, so the last statement in the do block would normally have type 'm a' for some m and a -- though the Haskell language standard doesn't actually require this (do blocks are desugared before type checking)
17:06:08 <rwbarton> quickezed: anyways you probably intended 'print c' instead of just 'c', I guess?
17:07:05 <rwbarton> (also ghc won't accept that entire file for other reasons)
17:10:05 <quickezed> rwbarton: thanks, using print worked.
17:10:54 <rwbarton> ghci is a bit special, if you enter an expression 'e', it will try to typecheck it as an IO action first, and if that fails, it will replace 'e' by 'print e' and try again
17:11:21 <quickezed> Ah ok. I guess it saves on having to type print a lot
17:13:23 <Kazagistar> rwbarton: also do notation stuff, right? like let and <-
17:16:15 <Polarina> Would anyone know why I am unable to install darcs using cabal? http://lpaste.net/104440
17:19:43 <rwbarton> Kazagistar: right, though those aren't expressions at all
17:21:57 <felix89> hi!
17:22:15 <benzrf> hello felix89
17:22:21 <benzrf> are you enjoying your daily dose of haskell
17:22:27 <felix89> I have this weird problem when using readFile from the Data.Text.IO package: I get a lot of garbage
17:22:29 <felix89> sure am
17:22:33 <felix89> it's lunch break haskell time
17:23:10 <jfischoff> Polarina: cabal install darcs --allow-newer --constraint="base >= 4.7"
17:23:20 <Welkin> daily dose?
17:23:27 <jfischoff> I think that will work ... if you don't get a compiler error ...
17:23:31 <felix89> re my problem: I get a lot non-sense garbage when using readFile on a file that has just a single line "test" in it
17:23:31 <Welkin> more like hourly injection
17:23:41 <jfischoff> Polarina: you have 7.8 right?
17:23:55 <rwbarton> fwiw when I tried that (cabal install darcs --allow-newer) I encountered at least one other issue due to a way another package uses flags
17:24:11 * jfischoff nods
17:24:35 <jfischoff> I guess the solution there is to install that seperately so you can use the right flags
17:24:42 <rwbarton> I think what might have worked is cabal install darcs --allow-newer=base --allow-newer=array etc. etc. but I didn't actually bother to try
17:24:45 <rwbarton> or that, yeah
17:25:01 <jfischoff> assuming you still get the right versions of everything else and it compiles
17:25:17 <rwbarton> hmm I guess cabal install darcs --dependencies-only wouldn't work if it can't find a build plan for darcs
17:25:18 <jfischoff> the whole cabal flags story is annoying
17:26:07 <rwbarton> or, alternatively, use ghc 7.6 :)
17:26:24 <felix89> doesn't seem to be specific to Data.Text.IO though, System.IO.readFile also returns garbage
17:26:29 <jfischoff> eww yuck ;)
17:27:50 <rwbarton> felix89: well, that shouldn't be happening
17:28:04 <rwbarton> I realize that's not very helpful :)
17:29:41 <rwbarton> felix89: what OS/locale/etc.
17:33:25 <rwbarton> jfischoff_: actually, in retrospect, what you want here is obvious: "ignore all upper bounds in darcs.cabal"
17:34:02 <rwbarton> that is likely the right level of granularity, since each cabal file is either written by a PVP zealot and out of date, or not
17:34:03 <felix89> rwbarton, im on win7, not sure about locale?
17:34:31 <felix89> rwbarton: it works fine from ghci
17:34:39 <rwbarton> curious
17:35:07 * hackagebot wai-cors 0.1.2 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.1.2 (larsk)
17:35:16 <felix89> but if run with 'runhaskell' or compiled with ghc, it gives garbage
17:36:15 <grache28> just so I don't have to compare language definition if someone already knows, do C and Haskell have the same arithmetic precedence?
17:36:30 <benzrf> grache28: afaik, more or less
17:36:38 <benzrf> i believe they both follow standard PEMDAS
17:37:14 <jmcarthur> grache28: you can use :i in ghci to look up the precedence of an operator (among other things)
17:37:52 <grache28> benzrf: PEDMAS implies Division comes before Multiplication, which in the real world it doesn't
17:37:58 <grache28> tks jmcarthur
17:38:54 <rwbarton> felix89: even more curious since runhaskell more or less invokes ghci
17:39:03 <rwbarton> unfortunately I don't know enough about windows to speculate a cause
17:39:14 <Welkin> division/multiplication and addition/subtraction share the same precedence
17:39:33 <Welkin> in fact, division is just a special case of multiplication
17:39:39 <Welkin> as subtraction is for addition
17:40:15 <grache28> Welkin: ahh.. reminds me of ring theory
17:40:46 <grache28> in C - and what've just checked in haskell, div/mul precedence is given from left to right
17:43:01 <felix89> rwbarton: I have been reading and writing files successfully before, i am baffle
17:43:23 <felix89> can it have to do with MapM?
17:43:42 <felix89> nah..
17:44:05 <pavonia> felix89: Could you paste you complete program?
17:44:25 <pavonia> And if possible the output you get too
17:44:36 <felix89> this is what i get: http://www.pasteall.org/51804
17:45:38 <felix89> there's more but you can see what the rest would look like: \NUL
17:45:48 <pavonia> UTF-1024? ;)
17:46:09 <felix89> could be
17:47:04 <felix89> whaaat
17:47:11 <felix89> I closed vim and now it works???
17:47:26 <felix89> this is beyond me
17:47:30 <rwbarton> hmm
17:47:33 <rwbarton> something to do with file locking perhaps
17:47:42 <rwbarton> but then why wouldn't you get an error message
17:47:53 <felix89> rwbarton: maybe... but mysterious
17:51:03 <benzrf> :t traverse
17:51:04 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:06:52 <sinelaw> what's up with ideah (the haskell plugin for intellij)?
18:06:57 <sinelaw> anyone still working on it?
18:07:45 <tacoshellmcgee> omfg haskell is on fire
18:08:11 <hunt> is there a way to do: case fn a of (Just b) -> something; Nothing -> case fn c of (Just d) -> something ...
18:08:16 <hunt> thats nice
18:09:17 <[swift]> hunt: case (fn a, fn c) of (Just b, _) -> something ; (_, Just d) -> something ...
18:10:01 <hunt> oh cool thanks [swift], is there a generalizable form for indefinite fns? or would that be it
18:10:34 <[swift]> hunt: it generalizes in the obvious way: case (f a, g b, h c, i d, ...) of ...
18:11:12 <hunt> [swift] i know it does but its still an ideal solution
18:11:27 <hunt> not*
18:11:31 <liyang> > "something" <$ Nothing <|> "else" <$ Just () <|> "moo" <$ Just ()
18:11:33 <lambdabot>  Just "else"
18:12:26 <[swift]> hunt: there comes a point at which you have too many functions and it'll look ugly, sure
18:12:31 <liyang> hunt: you want to look at Control.Applicative.Alternative
18:12:35 <[swift]> hunt: in practice i've rarely had that problem
18:15:00 <liyang> hunt: your original expression (depending on whether 'something' used the bound 'b' or 'd' or not might be: something1 <$> fn a <|> something2 <$> fn c
18:15:26 <hunt> ah i am curious about <|> and <$>
18:20:13 * hackagebot diagrams-builder 0.5.0.10 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5.0.10 (BrentYorgey)
18:29:10 <byorgey> hunt: <$> is just fmap
18:29:22 <byorgey> <|> chooses between two Alternative things
18:29:31 <byorgey> in the case of Maybe, it chooses the leftmost Just
18:33:41 <ReinH> hunt: is there a reason you don't want to use do notation?
18:35:49 <hunt> ReinH: how would i?
18:38:15 <ReinH> do { b <- fn a; d <- fn c; d <|> something }
18:38:24 <ReinH> Oh no, not quite
18:40:10 <cococo> > [1..]
18:40:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:40:14 <cococo> I was curious
18:48:39 <c_wraith> > [ maxbound - 2 ..] :: [Int]
18:48:41 <lambdabot>  Not in scope: ‘maxbound’
18:48:41 <lambdabot>  Perhaps you meant ‘maxBound’ (imported from Prelude)
18:48:46 <c_wraith> > [ maxBound - 2 ..] :: [Int]
18:48:47 <lambdabot>  [9223372036854775805,9223372036854775806,9223372036854775807]
18:49:09 <c_wraith> it's not actually an infinite list, if there's an upper bound on values for the type
18:49:19 <c_wraith> It's just...  really very very long
18:54:52 <halvorg> http://lpaste.net/104441
18:55:09 <halvorg> is there a way to make tose functions accept vectors of any length/type?
18:56:13 <albeit_> I'm trying to find an ideal list-like structure. The list will have a maximum length in the single digits, may have individual elements modified, or have elements deleted or inserted. 1 2 3 4 -> 1 2 4, or 1 2 4 -> 1 2 3 4. And ideas for what would work best?
18:56:41 <coppro> until you have reason to use otherwise, just a list?
18:57:08 <albeit_> coppro: Looking for something much faster... its being used to handle large quantities of updates.
18:57:43 <silasm> albeit_: if your list length is in the single digits, why does it matter?
18:58:14 <silasm> oh nevermind I see it, tons of list operations, I guess I get it.
18:58:28 <albeit_> silasm: To be honest, I don't know. I figure if I'm modifying the 5th index repeatedly, it would be better to use something not O(n)
18:58:53 <c_wraith> albeit_: do you want a persistent data structure?
18:59:25 <pavonia> When I have do { p <- peek $ castPtr ptrT; if p == nullPtr then ... }, will p be defaulted to a specific Ptr or will it still be polymorphic?
18:59:27 <albeit_> c_wraith: I dont wan't or not want one ;) either would work I guess
18:59:46 <albeit_> (woah bad grammar, srry)
19:00:34 <c_wraith> albeit: I mean, if you are going to be doing *that* much modification on a tiny data structure, why not a mutable array?
19:01:14 <pavonia> albeit_: Could you use an Array Int Bool where the Bool indicated if the element is set or not?
19:01:25 <pavonia> *indicates
19:02:35 <albeit_> If I insert into the middle of a mutable array, does it copy the two ends to a new array, or just modify the references of the surrounding elements?
19:03:18 <silasm> albeit_: depends on what kind of array you use
19:03:39 <albeit_> silasm: Guessing boxed would just modify references, unboxed would copy?
19:03:54 <albeit_> But I'll read up on mutable arrays, thanks
19:04:00 <silasm> albeit_: more of an ST vs. immutable, I think.
19:04:04 <pavonia> albeit_: What is your element type?
19:04:20 <silasm> Pretty sure STArray only modifies the one STVar
19:04:45 <albeit_> pavonia: Something with two Ints. Foo Int Int, (Int, Int), not sure yet
19:21:17 <HaskellNewbie316> oh wow, so many people here
19:21:27 <HaskellNewbie316> anyone active though?
19:21:30 <joebobjoe> What does Haskell need typeclasses?
19:21:46 <HaskellNewbie316> I need help with understanding this:
19:22:11 <HaskellNewbie316> let f x = map -1 x
19:22:24 <HaskellNewbie316> then when i do ":t f", strange things appear
19:23:27 <ski> joebobjoe : s/What/Why/ ?
19:23:41 <ski> HaskellNewbie316 : you presumably meant `map (-1) x'
19:23:44 <bergey> HaskellNewbie316: Were you expecting to map a function that subtracts 1?
19:23:46 <HaskellNewbie316> i thought that it would be a function that would take a list and return a list
19:26:05 <HaskellNewbie316> no no no, I didn't make any mistake
19:26:05 <HaskellNewbie316> it's an assignment and I am trying to understand it
19:26:05 <pavonia> :t \x -> map (-1) x
19:26:05 <lambdabot> Num (a -> b) => [a] -> [b]
19:26:05 <ski> HaskellNewbie316 : `map -1 x' is parsed as `(map - 1) x', which is probably not what you want
19:26:05 <HaskellNewbie316> they are trying to flex our minds, you know
19:26:05 <ski> HaskellNewbie316 : hm, or what byorgey says
19:26:05 * ski is tired
19:26:06 <ski> bergey
19:26:06 <bergey> ski: I'm not byorgey.
19:26:06 <joebobjoe> ski: Is Monad a typeclass?
19:26:06 <ski> joebobjoe : yes
19:26:06 <HaskellNewbie316> no, to make a function that subtracts 1, I would do: let f x = map ((-) 1) x or something
19:26:06 <ski> > map (subtract 1) [2,3,5,7]
19:26:06 <lambdabot>  [1,2,4,6]
19:26:06 <ski> > map ((-) 1) [2,3,5,7]
19:26:06 <lambdabot>  [-1,-2,-4,-6]
19:26:06 <ski> > map (flip (-) 1) [2,3,5,7]
19:26:06 <lambdabot>  [1,2,4,6]
19:26:06 <ski> > map ((-) `flip` 1) [2,3,5,7]
19:26:06 <lambdabot>  [1,2,4,6]
19:26:06 <HaskellNewbie316> okay...
19:26:06 <joebobjoe> ski: Why is monad referred to as a higher kinded type if it isn't a type then?
19:26:06 <ski> > map pred [2,3,5,7]
19:26:06 <lambdabot>  [1,2,4,6]
19:26:06 <hunt> sorry wait, that method doesn't seem to work. I want to be able to fn a -> something if fn a is not nothing, other wise fn b -> something, and repeat
19:27:03 <pavonia> What is fn?
19:27:21 <hunt> joebobjoe all implementations of monad are required to have kind * -> *
19:27:22 <ski> joebobjoe : sometimes people only mean "concrete types" when they say "types", in such case they typically say "type constructor" for a type function like `Maybe' or `Either String' e.g.
19:27:34 <hunt> pavonia fns a random function that returns maybe
19:28:25 <ski> joebobjoe : i prefer saying that all of `Integer -> Bool',`Maybe Integer',`Either String Integer',`Maybe',`Either String',`Either' are types, even though the latter three ones aren't concrete types (they are type functions)
19:28:36 <HaskellNewbie316> can anyone explain why the type of "map -1" is what it is?
19:28:46 <hunt> haskell irc seems to have become far less active recently
19:28:52 <albeit_> :t (map - 1)
19:28:53 <HaskellNewbie316> yeah I know it sounds silly, but just look at the types, not the meaning I guess
19:28:53 <lambdabot> Num ((a -> b) -> [a] -> [b]) => (a -> b) -> [a] -> [b]
19:29:01 <HaskellNewbie316> yeah, but why?
19:29:03 <ski> HaskellNewbie316 : `map -1' is parsed as attempting to subtract `1' from `map'
19:29:05 <pavonia> hunt: And what do you want to repeat if fn b fails?
19:29:34 <albeit_> HaskellNewbie316: Not trying to explain, I don't know myself ;)
19:29:35 <hunt> if fn b fails i want to be able to either do some other fn c and repeat the process or return a something
19:29:41 <ski> HaskellNewbie316 : so, therefore `map' must then be interpreted as a number, and the type of `map' must be assumed to be in the type class `Num'
19:29:42 <hunt> fn isn't the same function each time btw
19:29:46 <HaskellNewbie316> yeah, and map is of type (a->b)  -> [a] -> [b]
19:29:50 <hunt> I'm currently using nested cases
19:29:56 <hunt> which is nasty
19:30:10 <joebobjoe> hunt: Does a type class have a "kind"?
19:30:16 <byorgey> HaskellNewbie316: numeric literals like '1' actually mean 'fromInteger 1', so they can have any type which is an instance of Num
19:30:23 <ski> joebobjoe : yes
19:30:28 <pavonia> hunt: So you have  [Maybe a] and want the first a that is not Nothing?
19:30:30 <byorgey> HaskellNewbie316: so you can subtract 1 from map, as long as there is a Num instance for the type of map.
19:30:31 <joebobjoe> ski: How? They're not types?
19:30:40 <joebobjoe> They're not types.*
19:30:57 <hunt> joebobjoe: they are constraints
19:31:10 <hunt> joebobjoe: get into ghci and try :k Monad
19:31:14 <ski> joebobjoe : what is a type ?
19:31:36 <ski> (or, if you prefer, what do you think a type is ?)
19:32:23 <hunt> pavonia: not quite, i have a bunch of fns that return a maybe, and depending on the first one that returns Just, i want to return an associated something, such that my ultimate result is not a maybe
19:32:33 <ski> joebobjoe : do you understand what the type `Maybe Integer' means ?
19:32:45 <Kazagistar> What is a good type signature for a function that picks a random item from a list? stateStyle :: RandomGen g -> [a] -> g -> (a, g), splitStyle :: RandomGen g => [a] -> g -> a, or something else?
19:32:52 <joebobjoe> ski: Sorry, lol. I don't know Haskell at all. I'm really trying to understand Rust :D
19:33:03 <ski> joebobjoe : ok. np
19:33:39 <ski> joebobjoe : by a "concrete type" i mean a type which is *capable* of having values. like `Integer' and `Integer -> Bool' and `Maybe Integer', e.g.
19:33:48 <joebobjoe> ski: Got it.
19:33:53 <HaskellNewbie316> so "map -1" means that we assume that map is a Num. But then, why why is the type of it "t -> (a->b) -> [a] -> [b]? I don't know where the beginning comes from
19:34:19 <ski> joebobjoe : also `[Integer]', which is syntactic sugar for `[] Integer', which could otherwise possibly have been written `List Integer'
19:34:32 <pavonia> > fromMaybe "default" $ msum [Nothing, Just "foo", Just "bar"]  -- hunt?
19:34:33 <lambdabot>  "foo"
19:34:34 <HaskellNewbie316> after haskell subtracts 1 from map, he just uses map as always?
19:34:40 <ski> joebobjoe : `[] Integer' is the type of lists *of* integers
19:35:04 <ski> joebobjoe : so, `[]' itself is "the type of ...", where we haven't yet decided what the element type should be
19:35:21 * hackagebot effin 0.2.0.0 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.2.0.0 (AnthonyVandikas)
19:35:49 <ski> joebobjoe : `[]' is an *incomplete* type, a type function, that expects to be passed a (in this case concrete type), before it will "return" a complete description of a concrete type
19:35:54 <ski> joebobjoe : does that make sense ?
19:36:11 <albeit_> HaskellNewbie316: The part before the => is the type constrain, not the type.
19:36:20 <joebobjoe> ski: Yup.
19:36:31 <albeit_> (Or maybe it's techincally part of the type, but its not the same as the stuff after =>)
19:36:32 <ski> joebobjoe : similarly `Maybe' is a type function .. it maybe be named something like `option' in Rust
19:36:43 <HaskellNewbie316> albeit_: Yeah, I know it.
19:36:46 <joebobjoe> ski: Yup.
19:36:57 <ski> joebobjoe : the "type" of concrete types is in Haskell written like `*'
19:37:01 <ski> @kind Integer
19:37:02 <lambdabot> *
19:37:04 <ski> @kind Maybe Integer
19:37:05 <lambdabot> *
19:37:06 <ski> @kind Maybe
19:37:08 <lambdabot> * -> *
19:37:13 <ski> @kind [] Integer
19:37:13 <lambdabot> *
19:37:14 <ski> @kind []
19:37:15 <lambdabot> * -> *
19:37:19 <ski> @kind Either String Integer
19:37:20 <joebobjoe> @king Monad
19:37:20 <lambdabot> *
19:37:21 <ski> @kind Either String
19:37:21 <lambdabot> Maybe you meant: ping kind
19:37:22 <lambdabot> * -> *
19:37:23 <ski> @kind Either
19:37:24 <lambdabot> * -> * -> *
19:37:28 <joebobjoe> @kind Monad
19:37:29 <lambdabot> (* -> *) -> Constraint
19:37:31 <HaskellNewbie316> albeit_: I just don't know why the f function where "f x = map -1 x" is of type "t -> (a->b) -> [a] -> [b]". where does the t come from?
19:37:40 <ski> @kind Monad Maybe
19:37:42 <lambdabot> Constraint
19:37:43 <ski> @kind Num
19:37:44 <lambdabot> * -> Constraint
19:37:46 <ski> @kind Num Integer
19:37:47 <lambdabot> Constraint
19:37:51 <joebobjoe> ski: What the heck does Constraint mean?
19:37:56 <ski> `Num Integer' is a constraint, as is `Num a'
19:37:59 <ski> @type sum
19:38:00 <lambdabot> Num a => [a] -> a
19:38:17 <ski> constraints are what goes to the left of `=>' in type signatures
19:38:38 <pavonia> :t \x = map - 1 x
19:38:39 <lambdabot> parse error on input ‘=’
19:38:42 <pavonia> :t \x -> map - 1 x
19:38:44 <lambdabot> (Num ((a -> b) -> [a] -> [b]), Num (t -> (a -> b) -> [a] -> [b])) => t -> (a -> b) -> [a] -> [b]
19:38:50 <ski> joebobjoe : "traits" in Rust might be somewhat related (i don't know enough to be able to tell for sure)
19:38:53 <pavonia> :t \x -> map - (1 x)
19:38:54 <lambdabot> (Num ((a -> b) -> [a] -> [b]), Num (t -> (a -> b) -> [a] -> [b])) => t -> (a -> b) -> [a] -> [b]
19:38:57 <joebobjoe> @type Monad
19:38:58 <lambdabot> Not in scope: data constructor ‘Monad’
19:39:17 <pavonia> HaskellNewbie316: ^ see how the last part is parsed
19:39:29 <ski> joebobjoe : specifically, `Num a' is a (type) *class* constraint
19:40:22 <joebobjoe> ski: Why must Monad be a typeclass and not a type?
19:41:07 <ski> joebobjoe : type classes are for enabling a kind of (structured) overloading, where some operations are available on several distinct types, though not all types, but the operations will use *different* (though conceptually related) implementations for some basic tasks
19:41:19 <ski> @src Num
19:41:19 <lambdabot> class  (Eq a, Show a) => Num a  where
19:41:19 <lambdabot>     (+), (-), (*)           :: a -> a -> a
19:41:19 <lambdabot>     negate, abs, signum     :: a -> a
19:41:19 <lambdabot>     fromInteger             :: Integer -> a
19:41:25 <ski> @src Eq
19:41:26 <lambdabot> class  Eq a  where
19:41:26 <lambdabot>     (==), (/=)   :: a -> a -> Bool
19:41:51 <ski> `Eq' is the type class of (concrete) types which support comparision for equality and disequality
19:42:17 <ski> you can sortof think of `Eq' as a collection of those types
19:42:30 <ski> or you can think of it as a property that holds for those types
19:42:37 <ski> @type length
19:42:38 <lambdabot> [a] -> Int
19:42:55 <joebobjoe> ski: People say Rust doesn't have HKT, but structs can be parameterized. I didn't understand how a parameterized struct is not a HKT.
19:42:59 <ski> `length' will work for *any* type `a', i.e. will work for lists with elements of *any* type
19:43:13 * ski doesn't know what "HKT" is
19:43:21 <joebobjoe> ski: Higher kinded types, sorry.
19:43:26 <c_wraith> ski: higher-kinded polymorphism, really
19:43:45 <c_wraith> Obviously rust has higher-kinded types.  What it lacks is an ability to abstract over them.
19:43:55 <ski> c_wraith : ok, like the MLs, then
19:44:17 <ski> (and like Mercury)
19:44:28 <ski> @type lookup
19:44:30 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
19:44:32 <ski> @src lookup
19:44:32 <lambdabot> lookup _key []          =  Nothing
19:44:33 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
19:44:33 <lambdabot>                         | otherwise = lookup key xys
19:45:11 <ski> joebobjoe : `lookup' has a single implementation, but it calls `(==)' which is overloaded on the types in the type class `Eq'
19:45:28 <jTT> hey, i’m new to haskell and working through the “learn you a haskell” tutorial. I have a simple question re: currying. the function foldr1 :: (a -> a -> a) -> [a] -> a can work with, for example, this call> foldr1 (*) [1]. I was wondering, is the returned function now 1* or simply 1? If simply 1, what does foldr1 use as accumulator (as the tutorial calls it) whe 1 is taken as the starting value?
19:45:45 <ski> joebobjoe : so, to be able to call `lookup', you must have a "key" type in your list of key-value pairs which support equality
19:46:18 <ski> joebobjoe : we record this contraint on uses of `lookup' by the context `Eq a =>' on the type signature for `lookup'
19:46:41 <ski>   lookup :: Eq k => k -> [(k,v)] -> Maybe v
19:48:22 <HaskellNewbie316> okay, so it means that f x = map - (1 x). Then I would guess, that the "-" is the map's function. Then map expects a list, so (1 x) is a list. but in reality, this call still expects a function from us!
19:48:27 <ski> says that `lookup' will take any input of the "key" `k' type, and any input list of "key"-"value" pairs (pairs with components of types `k' and `v'), and maybe return an output "value" of type `v', for *every* type `k' and `v', *provided* `Eq k' is satisfied, i.e. provided the type `k' supports equality
19:48:33 <ski> joebobjoe : can you follow that ?
19:48:57 <roconnor> jTT: the results is just 1.
19:49:01 <roconnor> > foldr1 (*) x
19:49:03 <lambdabot>  Couldn't match expected type ‘[a]’
19:49:03 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
19:49:06 <roconnor> > foldr1 (*) [x]
19:49:08 <lambdabot>  x
19:49:25 <c_wraith> HaskellNewbie316: I would guess, offhand, that there's probably a type error in that definition.  While it's *possible* that 1 might be a function, it's very unlikely what you actually mean.
19:49:57 <roconnor> jTT: foldr1 will use the head of the list as the accumulatr.
19:50:01 <roconnor> @src foldr1
19:50:01 <lambdabot> foldr1 _ [x]    = x
19:50:01 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
19:50:02 <lambdabot> foldr1 _ []     = undefined
19:50:09 <jTT> @roconnor so it assumes 1 as the second value for the function(*)?  [and 0 for (+)]?
19:50:09 <lambdabot> Unknown command, try @list
19:50:15 * ski stares at joebobjoe
19:50:19 <roconnor> jTT: no
19:50:25 <roconnor> jTT: it just uses the head of the list.
19:50:36 <HaskellNewbie316> c_wraith: it's just a university assignment. We are supposed to figure out the types and the types only. So we should look at the types only, not what "map" really does.
19:51:05 <roconnor> > foldr1 (*) [x, y]
19:51:07 <lambdabot>  x * y
19:51:09 <HaskellNewbie316> :t map
19:51:10 <roconnor> > foldr1 (*) [x, y,z]
19:51:11 <lambdabot> (a -> b) -> [a] -> [b]
19:51:12 <lambdabot>  x * (y * z)
19:51:16 <roconnor> > foldr1 (*) []
19:51:18 <lambdabot>  *Exception: Prelude.foldr1: empty list
19:51:28 <jTT> but how then does foldr1 (+) [1] return 1 when both the starting value and the to be accumulated value is 1? should be 2 as a result, no?
19:51:48 <roconnor> jTT: the operation isn't used when the list length is 1.
19:51:56 <roconnor> > foldr1 undefined [x]
19:51:58 <lambdabot>  x
19:52:04 <roconnor> > foldr1 (error "jTT") [x]
19:52:05 <jTT> ah ok thanks
19:52:06 <lambdabot>  x
19:52:24 <c_wraith> HaskellNewbie316: are you still supposed to apply the standard haskell parsing rules?  Like, assume that integral literals have polymorphic types?
19:52:28 <pavonia> HaskellNewbie316: 1 is applied to x, so 1 must be a function. Then, (1 x) is substracted from map, so map and (1 x) must have the same type. Now Haskell find the most general type that matches these restrictions (with the types of map and 1 already given)
19:52:38 <HaskellNewbie316> c_wraith yeah, I think so
19:52:52 <c_wraith> pavonia: you're assuming (-) has the specific type from Num.  :P
19:52:53 <HaskellNewbie316> roconnor: there's no magic in it. you should just look at the implementation of this function. http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#foldr1
19:53:22 <joebobjoe> ski: Yes. Sorry. Bathroom.
19:53:27 <ski> joebobjoe : ok
19:53:28 <pavonia> c_wraith: Sure, why not?
19:54:11 <pavonia> :t \(-) map x = map - 1 x
19:54:13 <lambdabot> parse error on input ‘=’
19:54:30 <pavonia> :t \(-) map x -> map - 1 x
19:54:31 <ski> joebobjoe : note that another other function that you define, and whose implementation calls `lookup' will automatically inherit an `Eq k' class constraint without you having to lift a finger to propagate that
19:54:31 <lambdabot> Num (t3 -> t2) => (t1 -> t2 -> t) -> t1 -> t3 -> t
19:54:32 <HaskellNewbie316> :t \x -> map - (1 x)
19:54:33 <lambdabot> (Num ((a -> b) -> [a] -> [b]), Num (t -> (a -> b) -> [a] -> [b])) => t -> (a -> b) -> [a] -> [b]
19:54:55 <jTT> @HaskellNewbie316: Cheers! Pattern matched to one-entry lists returns the value of the list. ty ty
19:54:56 <lambdabot> Unknown command, try @list
19:55:01 <hunt> lets say i have 3 maybes, a b c, if a is just something, i want to do a random action, if a is nothing, check b for similar behavior. how can i accomplish this?
19:55:03 <ski> joebobjoe : iow, we don't just have the basic overloading on `(==)', which will be implemented differently for every type which implements it
19:55:37 <joebobjoe> ski: Now my original question: why do we need to name these constraints? Why can't the be inferred?
19:55:39 <hunt> i can't come up with something better than nested case expressions, which look really sloppy
19:55:57 <pavonia> hunt: Did you see my example earlier?
19:56:03 <ski> joebobjoe : we also have *derived* overloading, where any operation which calls an overloaded operation will itself automatically become overloaded (unless the types are specific enough to force only one overloading alternative left)
19:56:10 <hunt> pavonia: i scrolled up just now to check for red text :/ so i must have missed it
19:56:21 <ski> joebobjoe : the constraints are inferred
19:56:30 <pavonia> > fromMaybe "default" $ msum [Nothing, Just "foo", Just "bar"]
19:56:32 <lambdabot>  "foo"
19:56:55 <ski> joebobjoe : you don't have to type the type signatures, when you define the operations (though it's by most people considered good practice to do so, at least for top-level-defined operations)
19:57:03 <hunt> pavonia: where is fromMaybe defined
19:57:11 <pavonia> In Data.Maybe
19:57:23 <pavonia> msum is from Data.Monoid
19:57:37 <hunt> is there a way i can do this with applicative (<|>) instead, that seems like the more general solution
19:57:38 <ski> joebobjoe : however, you can still ask for the inferred type of an operation, and the system must be able to answer what constraints (if any) are placed on the operation
19:57:39 <hunt> pavonia
19:57:47 <pavonia> No, msum is from Control.Monad
19:58:10 <hunt> I'm aware, but you see how (<|>) is very nearly this functionality pavonia?
19:58:12 <joebobjoe> ski: Do I have to use type classes?
19:58:13 <Kaidevappy> so umm
19:58:25 <ski> joebobjoe : one possible variant here would be to simply list all the basic/primitive operations that need to be defined for the respective types, for the current operation to work
19:58:40 <HaskellNewbie316> well, I give up. Guess I'll never truly understand haskell's typing ;d thanks guys and good bye
19:58:40 <pavonia> hunt: I think they have the same behavior for Maybe
19:58:42 <joebobjoe> ski: That's what I mean.
19:58:53 <Kaidevappy> if i want people to be able to catch exceptions and recover without needing to reinitialize a reader's environment
19:58:56 <pavonia> > fromMaybe "default" $ Nothing <|> Just "foo"
19:58:58 <lambdabot>  "foo"
19:59:03 <ski> joebobjoe : however, that would tend to get a bit lengthy at times. Haskell has chosen to explicitly name such collections of basic overloadable operations. these are the type classes
19:59:11 <Kaidevappy> do I need ReaderT env (ExceptT except IO)?
19:59:16 <pavonia> > fromMaybe "default" $ Nothing <|> (map toUpper <$> Just "foo")
19:59:17 <Kaidevappy> or is that in the wrong order?
19:59:18 <lambdabot>  "FOO"
19:59:40 <hunt> pavonia: i mean eliminating the fromMaybe entirely, if possible
19:59:40 <ski> joebobjoe : so `Eq' is the name that is used for the constraint of implementing the `(==)' and `(/=)' operations
19:59:43 <joebobjoe> ski: So type classes are simply for programmer saneness?
20:00:13 <pavonia> hunt: You can't, what would you do if all maybes are Nothing?
20:00:15 <Kaidevappy> (runReaderT should only ever be invoked once, even if an exception has to be handled)
20:00:34 <ski> joebobjoe : even if you didn't collect multiple overloaded names under a type class name like this, you'd still need to specify which basic operations are to be overloadable
20:00:56 <ski> joebobjoe : and commonly overloaded operations tend to come in clusters, so it makes sense to group them together
20:01:00 <hunt> pavonia id assume the desired method would provide an opportunity to default
20:01:14 <hunt> pavonia: <|> just seems so close to what i want to do that it must be useful somehow
20:01:29 <hunt> pavonia: although i don't intend on returning maybe anything
20:01:37 <ski> joebobjoe : we aren't just talking about any old random overloading here, with some operation name reused for operations which may or may not conceptually be related to each other
20:01:48 <pavonia> hunt: So what part is still missing?
20:01:53 <joebobjoe> @kind Monad
20:01:55 <lambdabot> (* -> *) -> Constraint
20:02:39 <ski> joebobjoe : each type class is intended to embody a particular concept, and each type being an instance of the type class (i.e. implementing the specified operations in it) is expected to conform to the concept that the type class is meant to capture
20:02:44 <hunt> pavonia: im not returning a maybe, i want to return a different set of data depending on which maybe is selected, but its not necessarily reliant on the contents of the maybe
20:03:27 <hunt> pavonia: i have some Maybe (IO ()) and some Maybe (MyDataType)
20:03:30 <ski> joebobjoe : commonly, a type class comes with intended *laws* that the operations in the class are expected to satisfy, and it's the responsibility of the person writing an instance of the type class to make sure these laws aren't violated
20:03:37 <ski> joebobjoe : makes sense ?
20:03:38 <pavonia> hunt: Could you post your nested case please, I don't understand
20:03:43 <joebobjoe> ski: Yea.
20:03:54 <joebobjoe> ski: I have a question forming in my head.
20:04:03 <ski> whee
20:04:09 <ski> joebobjoe : ok ?
20:04:32 <hunt> pavonia: sure. http://lpaste.net/104442
20:05:18 <joebobjoe> ski: Can type classes construct other type classes?
20:05:37 <ski> joebobjoe : type classes doesn't construct anything themselves
20:05:40 <hunt> joebobjoe: you should read up on what type classes do
20:05:53 <hunt> joebobjoe: it'll be much more effective then asking about all this
20:06:03 <c_wraith> joebobjoe: you should think of a type class as a property that a type can have.  nothing more.
20:06:05 <hunt> @where lyah
20:06:05 <lambdabot> http://www.learnyouahaskell.com/
20:06:12 <ski> joebobjoe : they just describe an interface for operations that types instancing the type class are expected to implement and conform to
20:06:39 <joebobjoe> ski: What is the difference between type class of kind `* -> Constraint` and one of kind `Constaint`?
20:06:43 <pavonia> hunt: Why can't you use <|> there?
20:07:03 <hunt> pavonia: i might just not understand <|> well enough to see how i could
20:07:22 <joebobjoe> ∑
20:07:33 <ski> joebobjoe : just like `[]' and `Maybe' are "unsaturated"/"incomplete" types, so `Num' is an "incomplete" constraint
20:07:48 <joebobjoe> ski: But you said you couldn't construct constraints...
20:07:51 <hunt> pavonia: i don't see what amongst it is substitutable with <|>
20:08:09 <ski> joebobjoe : we need to provide an actual type to it, to get a constraint that says that that type is expected to support basic numeric operations
20:08:56 <ski> joebobjoe : i said a type class can't construct other type classes
20:09:18 <ski> @src Eq
20:09:19 <lambdabot> class  Eq a  where
20:09:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:09:25 <ski> is the definition of the type class `Eq'
20:09:32 <joebobjoe> @kind Eq
20:09:33 <lambdabot> * -> Constraint
20:09:36 <pavonia> hunt: http://lpaste.net/104443
20:09:38 <ski> @kind Eq Integer
20:09:39 <lambdabot> Constraint
20:09:55 <ski> we can put `Eq Integer' to the left of an `=>' arrow if we like
20:10:02 <joebobjoe> What is going on in this channel?
20:10:06 <parc> what do i need to install Text.HTML.DOM? i'm having trouble figuring out what the package names of things are in cabal
20:10:11 <pavonia> hunt: Err, without the  "of"s
20:10:22 <ski> joebobjoe : not this channel, it's the whole network. it's a netsplit
20:10:33 <joebobjoe> ski: What is that?
20:10:59 <ski> joebobjoe : <https://en.wikipedia.org/wiki/Netsplit>
20:11:00 <hunt> pavonia: right, damn, i didn't want to return a maybe, but not for any particular reason i just didn't feel that i should have to
20:11:55 <pavonia> hunt: Well, your type says so. If you don't, you cann still use fromMaybe/maye
20:11:57 <pavonia> *maybe
20:12:11 <ski> joebobjoe : basically, the IRC network usually consists of more than one server. sometimes communication breaks between partitions of the network, so that from the perspective of people connected to servers in one part, it appears like the people connected to servers in the other part quit -- and vice versa
20:13:14 <hiptobecubic> I don't show join/part anymore. In all it's a win, but I miss the excitement of netsplits
20:13:36 <joebobjoe> ski: That is awesome.
20:13:56 <joebobjoe> ski: Is there ever a point to defining a type class of kind `Constraint`?
20:14:05 * ski considers the display of `join's and `part's as a measure of the passage of time
20:14:22 <ski> joebobjoe : i'll answer that question in a little while
20:14:34 <joebobjoe> ski: Quiz me!
20:15:02 <ski> joebobjoe : while you can say `foo :: Eq Integer => Integer -> Integer', it doesn't make much sense to do so, since we already know that `Integer' supports equality
20:15:12 <ski> joebobjoe : so we can simplify this to just `foo :: Integer -> Integer'
20:15:50 <ski> joebobjoe : however, if we had `foo :: Eq a => [a] -> [a]', for an *unknown* (from the perspective of the code of `foo') type `a', then it makes sense
20:16:05 <ski> joebobjoe : still, `a' is a type like any other
20:16:35 <ski> joebobjoe : it's a type variable, that for any *actual* use of `foo' (a call site), will replace `a' by the actual type desired there
20:17:12 <ski> joebobjoe : so we defer the checking of whether `a' supports equality or not to the call site(s) of `foo', by including `Eq a' in the signature of `foo'
20:17:38 <zRecursive> Is there any symbol concept in haskell as Lisp ?
20:17:42 <ski> (and remember that `Eq a' will be included in the signature, in case it's needed by the implementation of `foo', even if we don't type it ourselves. it will be inferred)
20:18:08 <ski> zRecursive : not directly. constant data constructors can be used for some of the same purposes
20:18:47 <zRecursive> ski: constant data constructors ?
20:18:58 <ski> joebobjoe : anyway, recall that the type `Maybe Integer' signifies that we either will have `Nothing', or `Just x', where `x' is an `Integer'
20:18:59 <joebobjoe> ski: So defining a type class without type parameters is pointless.
20:19:13 <ski> joebobjoe : `Maybe' is a type functon that takes one type parameter
20:19:29 <joebobjoe> @kind Maybe
20:19:30 <lambdabot> * -> *
20:20:06 <ski> joebobjoe : `Either' is a type function that takes two type parameters. a value of the type `Either MyErrorMessage Integer' e.g. is either of the form `Left err' (with `err' of type `MyErrorMessage'), or of the form `Right x' (with `x' an `Integer')
20:20:11 <ski> @kind Either
20:20:13 <lambdabot> * -> * -> *
20:21:09 <ski> joebobjoe : similarly, it is possible to make a type class that takes two types as parameters
20:21:25 <ski> joebobjoe : such a type class would then specify a *relation* between those two types
20:21:58 <ski> joebobjoe : one example could be a type class for some kind of collection, where one type argument is the collection type, and the other is the element type
20:22:07 <ski> joebobjoe : are you ok with this idea ?
20:22:49 <joebobjoe> ski: Sure, but how do you enforce that the second type parameter is the type that is in the collection?
20:23:02 <parc> what do i need to install Text.HTML.DOM? i'm having trouble figuring out what the package names of things are in cabal
20:23:05 <hunt> <|> evaluates each of its operands, huh?
20:23:11 <ski> joebobjoe : by only making those instances
20:23:17 <ski> joebobjoe : if we have something like
20:23:19 <ski>   class Coll coll el
20:23:20 <ski>     where
20:23:28 <ski>     insert :: el -> coll -> coll
20:23:37 <ski>     member :: coll -> el -> Bool
20:23:40 <ski>     ...
20:23:41 <zRecursive> @hoogle Text.HTML.DOM
20:23:43 <lambdabot> package DOM
20:23:43 <lambdabot> package dom-lt
20:23:44 <lambdabot> package dom-selector
20:23:48 <ski> then we could have instances :
20:23:56 <parc> ah, neet
20:24:07 <ski>   instance Coll IntSet Int
20:24:17 <ski>   instance Coll StringSet String
20:24:25 <ski>   instance Coll (Set el) el
20:24:31 <hunt> is there a way to apply to a series of arguments using <$>
20:24:43 <hunt> like if i have returned an f :: a -> b -> c
20:24:45 <ski> the last one being a *polymorphic* instance, being polymorpic in the element type
20:24:46 <joebobjoe> @kind Coll
20:24:48 <lambdabot> Not in scope: type constructor or class ‘Coll’
20:24:49 <hunt> how can i use the anonymous f
20:24:53 <joebobjoe> @kind Collection
20:24:55 <lambdabot>     Not in scope: type constructor or class ‘Collection’
20:24:58 <ski> joebobjoe : this is just a hypothetical example
20:25:37 <joebobjoe> ski: Is there any type class of kind `Constraint -> Constraint`?
20:26:11 <ski> joebobjoe : one could do it (with extensions). i can't mention any offhand
20:26:22 <ski> joebobjoe : btw, it strikes me that perhaps by "Can type classes construct other type classes?" you were perhaps wondering about something like :
20:26:28 <ski> we have instance for `Eq' like
20:26:33 <ski>   instance Eq Integer
20:26:40 <ski>   instance Eq Double
20:27:03 <ski> we'd also like `[Integer]' to be comparable for equality, so we might expect there to be an instance
20:27:09 <ski>   instance Eq [Integer]
20:27:13 <ski> but then what about
20:27:17 <ski>   instance Eq [[Integer]]
20:27:19 <ski> and
20:27:25 <zRecursive> ski: How does haskell find the right instance to use ?
20:27:26 <ski>   instance Eq [[[Integer]]]
20:27:28 <ski> and so on ?
20:27:44 <hunt> is there a place for more mid level haskell questions
20:27:45 <ski> in fact, there is just a single polymorphic instance "creator" :
20:27:52 <ski>   instance Eq a => Eq [a]
20:28:18 <ski> that says that any time we have an instance of `Eq' for some type `a', we can (if need be) build an instance for the type `[a]'
20:28:41 <ski> so we get all the instances for lists of lists of ... of integers above, for free, and more
20:28:43 <hunt> so let me rephrase, if i have an f :: a -> (b -> c -> d -> e), how can i use the result of f?
20:29:00 <hunt> i need to manually curry, effectively
20:29:38 <ski> joebobjoe : one might perhaps phrase this as "an instance creating instances" or "a class creating classes" -- though i think neither of those explanation attempts are quite accurate
20:29:39 <joebobjoe> ski: Let me ask a basic question. Why would we want to constraint a type class to certain ~kinds~ of types? Like Monad.
20:29:40 <hunt> pls help
20:30:08 <ski> joebobjoe : well, first the "type class of kind `Constraint'" question :)
20:30:12 <ski> @kind Eq
20:30:13 <lambdabot> * -> Constraint
20:30:25 <ski> says that `Eq' is a type class for concrete types
20:30:31 <enthropy> hunt: f :: a -> (b -> c -> d -> e) is the same as f :: a -> b -> c -> d -> e
20:30:38 <joebobjoe> ski: Got that.
20:30:48 <ski> joebobjoe : for our hypothetical `Coll' above, the kind would have been `* -> * -> Constraint'
20:30:56 <ski> because it's a two-argument type class
20:30:58 <hunt> enthropy: so if i have a function returns a random function after a, i can call it with many arguments?
20:31:07 <joebobjoe> ski: It takes two concrete types.
20:31:18 <ski> joebobjoe : so, a type class of kind `Constraint' would be a "zero-argument type class"
20:31:27 <joebobjoe> ski: Pointless.
20:31:30 <ski> iow it wouldn't talk about any types at all
20:31:31 <hunt> enthropy: oh i see! thanks
20:32:01 <zRecursive> @wn pointless
20:32:03 <lambdabot> *** "pointless" wn "WordNet (r) 3.0 (2006)"
20:32:03 <lambdabot> pointless
20:32:04 <lambdabot>     adj 1: not having a point especially a sharp point; "my pencils
20:32:04 <lambdabot>            are all pointless" [syn: {pointless}, {unpointed}] [ant:
20:32:04 <lambdabot>            {pointed}]
20:32:04 <ski> joebobjoe : so if we had `class Pointless', then either we could have a single `instance Pointless', or we could refrain from having such an instance
20:32:05 <lambdabot> [5 @more lines]
20:32:09 <ski> so it's like a boolean value
20:32:23 <hunt> enthropy: except that function result is in a maybe
20:32:28 <ski> while `Eq' is like a boolean value for every possible type that we pass as argument to `Eq'
20:32:36 <hunt> enthropy: so its really a -> Maybe (b -> c -> d -> e)
20:32:56 <ski> joebobjoe : so, yes, it's probably not useful for much. still it's possible (for uniformity)
20:33:55 <ski> joebobjoe : now, the example class `Coll' above takes two concrete types, one "collection type" and one "element type", which is supposed to be the element type of the corresponding collection type
20:34:18 <joebobjoe> ski: Wait.
20:34:48 <ski> joebobjoe : this both enables one to use parametric collections like `Set' (which isn't a concrete type), so that we can have `Set Double', `Set [String]', &c. -- in general `Set el' for some element type `elä
20:34:53 <joebobjoe> What do you mean by single instance and all that boolean stuff about Pointless?
20:35:25 <ski> joebobjoe : but it *also* allows us to have instances for collection types where the element type is *hardwired* into the collection type, like an `IntSet' type, e.g.
20:35:54 <ski> joebobjoe : well, `Eq' can be seen as expressing a predicate on types. namely the predicate "does the type support equality ?"
20:36:12 <enthropy> hunt: there isn't a common name for the function with type Functor f => f (a -> b) -> a -> f b
20:36:21 <enthropy> there's ?? in Control.Lens
20:36:22 <ski> joebobjoe : you make the answer to that question be "true" by making an instance for the type, implementing the operations of the type class
20:36:39 <enthropy> so you could write    f a ?? b ?? c ?? d :: Maybe e
20:37:02 <ski> joebobjoe : if you haven't made an instance for the type, the answer is "not known to be true", which you could more or less think of as "false" (or "false as far as we know")
20:37:30 <joebobjoe> ski: What do instances have to do with it?
20:37:39 <ski> joebobjoe : so, in some abstract, vague sense, one can think of type classes like `Eq' as taking types and returning "booleans"
20:38:25 <ski> joebobjoe : while `Coll' above would take two types and return a "boolean" telling whether the given "collection" type can function as a collection type for the given "element" type (by implementing the operations `insert',`member',&c. of the type class `Coll')
20:39:08 <joebobjoe> ski: Ahah! That makes sense.
20:39:17 <ski> joebobjoe : making an instance for `Eq Foo' is how you make the question "does the type `Foo' have property `Eq' ?" come out true
20:39:36 <joebobjoe> ski: So, the type class Monad takes a type of kind `* -> *` and "returns a boolean".
20:39:42 <ski> for `Eq', "having property `Eq'" means "supporting equality"
20:39:49 <ski> joebobjoe : yes
20:40:29 <joebobjoe> ski: When you say "instance", do you mean value?
20:40:36 <ski> joebobjoe : instead of having a `Coll' type class that *allows* making instances for collection types that hardwires the element type, we could *require* the instanced collection types to accept *any* (concrete) type as element type
20:40:41 <ski> so instead of
20:40:47 <ski>   class Coll coll el
20:40:49 <ski>     where
20:40:58 <ski>     insert :: el -> coll -> coll
20:41:03 <ski>     ...
20:41:07 <ski> we'd have something like
20:41:13 <ski>   class Coll coll
20:41:15 <ski>     where
20:41:23 <ski>     insert el -> coll el -> coll el
20:41:24 <ski> er
20:41:26 <ski>     insert :: el -> coll el -> coll el
20:41:28 <ski>     ...
20:41:35 <ski> and instead of
20:41:40 <ski>   instance Coll (Set el) el
20:41:43 <ski> we'd just have
20:41:47 <ski>   instance Coll Set
20:41:51 <ski> and instead of
20:41:58 <ski>   instance IntSet Int
20:42:12 <ski> we'd have .. nothing, we couldn't make such an instance in this case
20:42:22 <ski> in the former case, the kind of `coll' and `el' are both `*'
20:42:32 <ski> in the latter case, the kind of `coll' is `* -> *'
20:43:14 <guesting> So I have a hunk of code that has worked perfectly for a long time on various sizes of input data. I just tried it on a HUGE bit of data and it takes a while before getting a segmentation fault (core dumped). Why would this occur? Why on smaller input data it would be fine? I am using unsafePerformIO just to write some stuff in the middle of a function, call a command line program on that file, and read in the results. Would that be
20:43:23 <joebobjoe> ski: What is `instance` in Haskell?
20:43:26 <ski> in the former case, both `coll' and `el' are parameters of the type class, so you can possibly pin them down completely when making an instance (if you aren't pinning them down completely, like with `instance Coll (Set el) el', then the instance is polymorphic)
20:44:10 <ski> joebobjoe : it's the keyword you use to declare that some type(s) form an instance for a type class, by implementing the operations specified in the type class
20:44:26 <ski> (i elided implementations in the `instance ...' stuff above, for brevity)
20:44:53 <joebobjoe> ski: So, an instance does not have to be defined on a concrete type?
20:45:09 <ski> in the latter case above, only `coll' can be pinned down when you make an instance. your instance has to work for *any* choice of `el'
20:45:26 <ski> joebobjoe : normally, it's at least somewhat concrete
20:45:37 <ski>   instance Eq Bool
20:45:44 <ski> is fully concrete/monomorphic
20:45:53 <ski>   instance Eq a => Eq (Maybe a)
20:46:31 <ski> isn't fully concrete/monomorphic. it's polymorphic in `a' (and in fact automatially building new instances for `Eq (Maybe a)' out of instances for `Eq a')
20:46:39 <ski>   instance Eq (IORef a)
20:46:56 <ski> is polymorphic as well (but doesn't build new instances out of old ones)
20:47:02 <joebobjoe> What does Instance Eq a => Eq (maybe a) mean in the language?
20:47:54 <ski> it means that whenever you have an instance for `Eq Foo', you then get an instance for `Eq (Maybe Foo)' for free (and then also one for `Eq (Maybe (Maybe Foo))' for free, &c. as needed by the program)
20:47:56 <Enigmagic> guesting: could be almost any reason..
20:48:22 <guesting> Enigmagic: Like, because I'm using unsafePerformIO?
20:48:55 <joebobjoe> ski: You've lost me but that's okay.
20:49:05 <ski> joebobjoe : so instead of having to write one instance for e.g. list of integers, `instance Eq [Integer]', and one for lists of strings, `instance Eq [String]', &c., we make a *single* instance :
20:49:10 <ski>   instance Eq a => Eq [a]
20:49:57 <Enigmagic> guesting: depending on what's going on in the unsafePerformIO block, yes..
20:50:21 <ski> joebobjoe : so, that instance says that if we know how to compare elements in a list for equality, then we know how to compare the lists themselves for equality
20:50:27 <ski> the full definition is
20:50:39 <ski>   instance Eq a => Eq [a]
20:50:41 <ski>     where
20:50:52 <ski>     [    ] == [    ] = True
20:51:03 <guesting> Enigmagic: unsafePerformIO is doing a "writeFile" on a string, "runCommand" to run a command on the command line (svd from svdlibc), waitForProcess to wait for that command to finish, then a readFile on the resulting file
20:51:06 <Enigmagic> guesting: if the code is public and not too complicated you could post a link here, the problem might be obvious
20:51:10 <ski>     (x:xs) == (y:ys) = x == y && xs == ys
20:51:20 <ski>   _      == _      = False
20:51:29 <ski> (with correct indentation)
20:51:33 <guesting> Enigmagic: It normally works, but I put in an especially big file today and it segfaulted
20:51:38 <joebobjoe> ski: That's pretty neat.
20:51:38 <Enigmagic> guesting: how big is the one that fails?
20:52:03 <ski> joebobjoe : that tells how to compare corresponding elements in the two given lists, and how to give `False' in case the two lists differ in length
20:52:29 <guesting> Enigmagic: The "writeFile" is writing a 604 MB file for input to svd. I don't know if it was cut short though.
20:52:44 <ski> joebobjoe : anyway, the new `Coll' class above has kind `(* -> *) -> Constraint', because it takes an "incomplete" type, a type function, as argument
20:52:44 <guesting> Like, the file is 604 when it segfaulted
20:52:53 <ski> joebobjoe : similarly for `Monad' and `Functor'
20:53:24 <ski> @kind Functor
20:53:26 <lambdabot> (* -> *) -> Constraint
20:53:27 <ski> @kind Monad
20:53:28 <lambdabot> (* -> *) -> Constraint
20:53:33 <ski> @kind MonadState
20:53:35 <lambdabot> * -> (* -> *) -> Constraint
20:53:52 <joebobjoe> ski: Okay now back to my quesiton. What is the benefit of restricting the kinds of types you can apply a type class to?
20:54:11 <Enigmagic> guesting: well i wouldn't expect segfaults from readFile/writeFile. where does the string come from?
20:54:17 <ski> joebobjoe : which restriction are you referring to ?
20:54:36 <guesting> Enigmagic: A...much longer process to produce a sparse matrix
20:54:47 <guesting> Enigmagic: I can't show the code yet unfortunately
20:55:08 <ski> joebobjoe : if we say `class Coll coll where insert :: el -> coll el -> coll el', then `coll' *must* be an incomplete type (like `Maybe' or `Set'), otherwise `coll el' would be nonsense
20:55:18 <guesting> Enigmagic: Would it be due to the sparse matrix library I'm using? I was running into issues with it for large data http://hackage.haskell.org/package/sparse-lin-alg-0.4.3/docs/Math-LinearAlgebra-Sparse-Matrix.html
20:55:55 <guesting> Enigmagic: I had to rewrite some functions to make it be more strict, otherwise I would get stack size overflow errors
20:56:10 <ski> joebobjoe : so the `* -> *' in `Coll :: (* -> *) -> Constraint' is merely keeping track of the fact that the type class `Coll' doesn't expect *concrete* types as arguments, but rather *incomplete* ones, like `Set' or `Maybe'
20:56:18 <guesting> Enigmagic: Maybe the guy who wrote that library was doing some bad things that he didn't notice as he was using smaller datasets
20:56:20 <ski> joebobjoe : makes any sense ?
20:57:17 <ski> joebobjoe : anyway, iiuc, Rust allows polymorphism over *concrete* type variables, type variables that will be replaced by *concrete* types
20:57:52 <ski> joebobjoe : but it doesn't support polymorphism over *incomplete* type variables, type variables to be replaced by *incomplete* types
20:58:22 <Enigmagic> guesting: doesn't look obviously bad.. looks like it just uses IntMap which should be fine
20:58:25 <ski> joebobjoe : sometimes, it turns out that that is really what you want to do (to remove some boiler-plate code, some code duplication, e.g.)
20:59:00 <joebobjoe> ski: It's still very hard to grasp what tangible benefit you get from having to specify the *kind* of type a type class can be applied to.
20:59:28 <jle`> Kaidelong: you have my email, right?
20:59:31 <guesting> Enigmagic: I think it's happening in the unsafePerformIO as it the result file is not found in the directory
21:00:01 <Kaidelong> jle`: I don't, actually
21:00:05 <guesting> Enigmagic: I can post this chunk of code for you to see
21:00:09 <Enigmagic> guesting: sure
21:00:13 <Cale> joebobjoe: From having to, or from being able to?
21:00:14 <Kaidelong> I figured I could find it with just a little work, but maybe not
21:00:17 <c_wraith> joebobjoe: the benefit isn't specifying the kind - it's being able to work over kinds other than *
21:00:41 <joebobjoe> c_wraith: But you can't work with types of any kind. Why?
21:00:49 <ski> joebobjoe : it's the same as with any other static checking : you avoid deferring to run-time checks that can (and should) be done at compile-time
21:00:57 <Kaidelong> (also I've come to the conclusion that the wire I attach should be in IO because restricting it to Identity would prevent the person implementing the game library from doing things like playing sounds)
21:01:11 <ski> joebobjoe : and what c_wraith said
21:01:21 <Kaidelong> (the *game engine* should restrict it to identity but this is a library for writing game engines)
21:01:32 <Cale> joebobjoe: You can?
21:01:34 <Cale> :k Typeable
21:01:36 <lambdabot> k -> Constraint
21:01:43 <Cale> ^^ kind variable
21:01:54 <jle`> Kaidelong: can't your wire output a sound event, and whatever is "running" your wires take the event and play it?
21:01:55 <ski> joebobjoe : "But you can't work with types of any kind. Why?" -- allowing polymorphism over *kinds* (not types) could actually sometimes be useful. there's some experimental support for that in GHC
21:02:20 <Kaidelong> jle`: then I'd have to make netwire-glfw-b know about playing sounds
21:02:22 <c_wraith> ski: it's actually seeping into base.  in addition to Typeable, there's kind polymorphism in Category now, too
21:02:37 <Enigmagic> :k Proxy
21:02:37 <Cale> Well, new support anyway. Typeable uses it, and *lots* of stuff uses Typeable
21:02:38 <lambdabot> k -> *
21:02:42 <ski> c_wraith : that's nice
21:02:51 <Cale> :k Category
21:02:52 <lambdabot> (k -> k -> *) -> Constraint
21:02:54 <ski> yeah, `Typable' is the obvious usecase
21:03:00 <Kaidelong> all its supposed to know about is how to handle windows and how to pump input into wires
21:03:02 <guesting> Enigmagic: http://pastebin.com/1S8tqPAL
21:03:04 <ski> (er, `Typeable')
21:03:21 <guesting> Enigmagic: It's one of my first programs, so it's pretty ugly. I've gotten much better I swear
21:03:45 <jle`> Kaidelong: you can have your user provide arbitrary IO hooks to your output of wires?  i'm not sure what sort of api you are trying to expose, but something like allowing wires to trigger sounds is a bit outside of the semantic model of netwire, i think...on the level of unsafePerformIO
21:03:47 <joebobjoe> Cale: I think I'm going to throw up. Is that normal
21:03:48 <guesting> Enigmagic: It's basically turning a sparse matrix into a format for svd to read
21:03:53 <Cale> joebobjoe: haha
21:04:07 <c_wraith> joebobjoe: splitting headache with it?  if so, that's normal
21:04:10 <jle`> i exaggerate slightly
21:04:15 <jle`> but not too much
21:04:17 <joebobjoe> c_wraith: This room is getting very hot.
21:05:16 <Cale> joebobjoe: Adding methods to a typeclass will quickly restrict the kind though, because you're going to use the type variables in the class head -- applying them to type parameters will ensure they have kind k1 -> k2 for some kinds k1 and k2, and eventually you'll almost surely end up making some actual type with values involving that variable, and that'll get kind * involved
21:05:20 <ski> @quote will.explode
21:05:20 <lambdabot> bos says: 00:24 < bos> it seems that quite often people will have a poke at oleg's code, their heads will explode, and they'll find some other way to do their thing.
21:05:26 <Kaidelong> jle`: well I run into a problem there in that I don't want to care about the output of the wire, I just want to step it, providing IO hooks means I'd have to add a type parameter to the netwire session... which I could do but I'm scared of restricting a Session to a homogenous collection of windows
21:05:32 * hackagebot directory-tree 0.12.0 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.12.0 (BrandonSimmons)
21:05:33 <Enigmagic> guesting: and it's failing before calling svd?
21:05:42 <Cale> :k Functor
21:05:44 <lambdabot> (* -> *) -> Constraint
21:05:57 <Kaidelong> if I can make the output type () I don't need a type parameter anywhere...
21:06:04 <Kaidelong> I guess I could use an existential type...
21:06:16 <Kaidelong> but then how would I attach hooks?
21:06:43 <Cale> The declaration fmap :: (a -> b) -> f a -> f b inside the Functor class declaration uses (f a) as a type with values, so it must have kind *, and it also uses a like that, so a :: * too
21:06:45 <ski> joebobjoe : anyway, one of the fun parts of Haskell is the expressive type system :)
21:06:57 <Cale> which pins f's kind down, it has to be * -> *
21:06:57 <ski> (and kind system)
21:07:06 <guesting> Enigmagic: It must, as "temp_c_mat" is in the directory but "temp_result-Ut" is not. So it either broke on writeFile or runCommand
21:07:15 <Aetherspawn> maybe in base 5 we can have a nice directory and time library in prelude
21:07:17 <jle`> Kaidelong: i think you might be trying to use netwire like pipes
21:07:28 <c_wraith> joebobjoe: it's normal to not understand this stuff at first.  It really is a different dimension of abstraction than most languages support - but it does turn out to be useful!
21:07:35 <Cale> (Because f takes an argument of kind * and produces a type of kind *)
21:07:53 <guesting> Enigmagic: Unless laziness tells me it's breaking somewhere else, but I'm assuming that unsafePerformIO will wait for mat to be finished before writing. I guess. I don't know.
21:07:57 <Cale> Normally, all this kind-level stuff gets inferred for you anyway
21:07:58 <Aetherspawn> my #1 annoyance is that "exe" is missing from base
21:08:04 <Kaidelong> jle`: I did end up getting the impression I shouldn't be using netwire, but I *do* pass in a time delta
21:08:08 <guesting> Enigmagic: It got 604MB into the file at any rate
21:08:31 <Cale> Aetherspawn: I don't see the advantage of moving all that stuff into the Prelude
21:08:32 <jle`> netwire would work for what you want, but you might have to reshift the thinking
21:08:37 <joebobjoe> Cale: How do you know f a results in a value?
21:08:44 <Aetherspawn> Cale: it's already there, it's just incomplete
21:08:59 <Cale> joebobjoe: It results in a type of kind * because (f a) is an argument to (->)
21:08:59 <Aetherspawn> what's teh point of having so many utilities for launching processes and constructing file paths in a cross platform way
21:09:10 <Enigmagic> guesting: what OS are you running on?
21:09:11 <Aetherspawn> if we don't have a utility to tell us what the executable postfix on the current system is
21:09:21 <Cale> and (->) takes two types of kind * and produces a type of kind * (the type of functions)
21:09:36 <guesting> Enigmatic: Ubuntu 12.04
21:09:44 <Aetherspawn> it's the 80/20 thing
21:10:01 <Cale> Aetherspawn: Well, a proper time library is complicated, and probably doesn't all belong in the Prelude
21:10:02 <Aetherspawn> or, just, the world would be a better place without Windows, thing/
21:10:04 <jle`> Kaidelong: think of a wire as a "pure" function.  input comes in (whatever relevant input is necessary), output "purely" comes out (whatever is needed for the backend to react to the input...be it trigger a sound, or feed into a hook, or render a world)
21:10:26 <Aetherspawn> Cale: in that case, maybe pull the current time stuff out of prelude altogether
21:10:33 <Cale> What time stuff?
21:10:36 <Aetherspawn> and opt in for everyone just using that thing that was on haskell reddit
21:10:46 <Enigmagic> guesting: well if you stick some tracing in there or run it under strace it'd be interesting to see if it's calling out to svd
21:10:54 <Cale> Is there even one time-related anything in the Prelude?
21:10:55 <joebobjoe> Cale: So, anything between two -> must be of the kind *?
21:11:03 <Cale> joebobjoe: yeah
21:11:09 <jle`> the only difference is that wires are like functions that can have a changing internal state...but the internal state changes purely, like as an s -> (a, s) state monad kinda way
21:11:25 <Cale> It's (a -> b) -> (f a -> f b)
21:11:29 <Cale> :k (->)
21:11:31 <lambdabot> * -> * -> *
21:11:32 <Aetherspawn> oh, I'm so sorry I have no idea what I'm talking about
21:11:35 <Enigmagic> guesting: it's possible that svd is failing and the process status code is being ignored (it gets retuned from waitForProcess)
21:11:39 <Aetherspawn> I was under the impression time was in base
21:11:49 <Kaidelong> jle`: so when I'm in a situation where I have no conceptual model that allows me to use pure wires, but I do have a central clock that needs to push time deltas and step wires... what do I do?
21:11:50 <Cale> If it helps, we could write this prefix (maybe it doesn't help)
21:12:00 <joebobjoe> :k (* -> *)
21:12:01 <lambdabot> parse error on input ‘->’
21:12:11 <Cale> (->) ((->) a b) ((->) (f a) (f b))
21:12:17 <Cale> if you can stomach the parens
21:12:18 <jle`> Kaidelong: if you look at the GLUT backend I wrote, basically, i store the current wire in an MVar/IORef
21:12:27 <Cale> Since (->) is applied to a and b
21:12:29 <joebobjoe> Cale: I just has diarrhea
21:12:32 <Cale> we know that a :: * and b :: *
21:12:40 <joebobjoe> had*
21:12:48 <Cale> and since it's applied to (f a) and to (f b), we know that f a :: * and f b :: *
21:13:06 <jle`> and at every clock cycle, i pull it out, and use runWire :: Wire a b -> Time -> a -> (b, Wire a b), giving in the time delta since the last tick and the desired intput
21:13:17 <jle`> so i feed in the time delta and the wire input in runWire
21:13:21 <Cale> Because f is applied to an argument, we can infer it has kind k1 -> k2 for some kinds k1 and k2
21:13:22 <jle`> (the type signature is simplified)
21:13:33 <joebobjoe> Is GHC written in Haskell?
21:13:37 <Cale> Because it's applied to a specifically, and a :: *, we can infer k1 = *
21:13:43 <jle`> then i react/render on the output b, and store that resulting Wire a b in the MVar again
21:13:53 <jle`> and then the next tick of the game clock...repeat.
21:13:59 <Cale> and because it results in something of kind *, namely f a, we can infer that k2 = *
21:14:06 <joebobjoe> Is there anything more abstract than kinds?
21:14:06 <Cale> joebobjoe: yes
21:14:11 <Cale> and yes
21:14:21 <Cale> Kinds are just the types of types
21:14:22 <jle`> pull the wire out of the MVar, gather the necessary input using IO/glut, use runWire, render the resulting b using IO, and store the new modified Wire a b in he MVar
21:14:53 <Kaidelong> how do you work around not knowing what the b is or how to render it?
21:14:56 <jle`> the important thing is that I do all of the IO i need to (1) get the input `a` and the delta time, and (2) react to the output of the wire, be that triggering sounds, or rendering graphics, or sending a popup
21:15:15 <jle`> Kaidelong: you might offer a hook to the user
21:15:15 <Kaidelong> parameterization?
21:15:24 <jle`> callback :: b -> IO ()
21:15:29 <jle`> to the library writer
21:15:36 <Cale> joebobjoe: The algorithms for working with and inferring kinds are exactly the same as those for types
21:15:36 <joebobjoe> Cale: Why do type constructors have arity?
21:15:37 <guesting> Enigmagic: True. I'll see if it works from the command line. Would a incredibly large stack size cause this issue?
21:15:52 <jle`> so the library creator provides both a `Wire a b` *and* a `b -> IO ()`
21:15:54 <Cale> joebobjoe: Well, they have more than arity, they have kinds!
21:16:13 <Cale> joebobjoe: you can insist that one of the parameters to a type constructor itself has kind * -> *, for example
21:16:20 <jle`> and presumably an `IO a`
21:16:28 <jle`> unless you fix what the input of the wire is
21:16:37 <Cale> For instance, consider this tree type:
21:16:45 <jle`> yeah, that makes sense.  The person would have to provide an `IO a`, a `Wire a b`, and a `b -> IO ()`
21:16:54 <Cale> data Tree a = Branch a [Tree a]
21:16:56 <guesting> Enigmagic: I ran into stack size overflows due to the sparse matrix library (I know for a fact that it's due to that from profiling), so I need to run the program with +RTS -K2000m in order to increase the stack. If it gets insanely high, would it segfault?
21:17:00 <Kaidelong> well I do know what the wire input is, at least
21:17:06 <guesting> The memory isn't being used that much though...
21:17:24 <jle`> Kaidelong: well, if you fix what the input is, then they just have to provide a `Wire InputType b` and a `b -> IO ()`
21:17:25 <Enigmagic> guesting: not generally. it typically means there is excessive laziness but i've run apps with 2+GB of stack in a pinch.
21:17:34 <Kaidelong> it's essentially a newtype-wrapped reference to the window handle where all you can do with it is use accessors to the input
21:17:34 <Cale> joebobjoe: We might want to generalise it over what sort of data structure is used to take care of the subtrees, in this case, I chose a list, but maybe we'd like to replace that sometimes
21:17:35 <joebobjoe> Cale: Can you abstract over arity?
21:17:53 <joebobjoe> Cale: That's really cool!
21:17:54 <Cale> data Tree f a = Branch a (f (Tree a))
21:18:05 <guesting> Enigmagic: Weird. I can only think that svd is failing, but would that cause a segfault? Also, svd is supposed to be super robust...hmph
21:18:08 <Cale> Now  Tree :: (* -> *) -> * -> *
21:18:11 <jle`> your framework/library would then handle the manual pulling-from-the-MVar, getting the dt and the input, stepping the wire, feeding the `b` to the given callback, and the popping it back into the MVar.
21:18:15 <Kaidelong> okay yeah that was close to my original model
21:18:22 <jle`> IRC is such a weird medium for conversations
21:18:27 <Enigmagic> guesting: what version of ghc are you using?
21:18:38 <jle`> there are at least four conversations going on at the same time
21:18:40 <Kaidelong> I was trying really hard to avoid needing that unbound type parameter though
21:18:40 <Cale> It takes some type constructor (of one parameter of kind *), and a type for the elements (of kind *), and produces a type of kind *
21:18:43 <guesting> Enigmagic: Well I'm running it again so the temp file was rewritten, so I'll be waiting a few hours until I can test the hypothesis
21:18:57 <Kaidelong> because then I need a "Window b" rather than just a "Window" and this complicates a lot of things down the line
21:19:03 <guesting> Enigmagic: 7.4.1
21:19:16 <Kaidelong> although
21:19:18 <jle`> Kaidelong: well then.  maybe you can make a Window (IO ())
21:19:20 <jle`> heh.
21:19:21 <Cale> joebobjoe: You can abstract over the kind of something when it *really* doesn't matter, which can be a bit rare
21:19:29 <jle`> Wire InputType (IO ())
21:19:33 <jle`> where the IO () is generated purely
21:19:44 <jle`> i'm not sure how awful of an idea this is, but it just might work
21:20:00 <jle`> yeah...actually...
21:20:09 <Cale> joebobjoe: If your data type accepts a type parameter which isn't mentioned or used anywhere else in the definition of the type, then it makes sense that you could plug in something of any kind at all there.
21:20:18 <Kaidelong> jle`: so Wire Double () Identity InputBuffer (IO ()) as opposed to Wire Double () IO InputBuffer ()?
21:20:30 <jle`> Wire InputType (IO ()) is just the same as wire composition with an `arr callback`
21:20:38 <jle`> Kaidelong: yes
21:21:02 <Kaidelong> mmm, okay
21:21:04 <Kaidelong> this would work
21:21:08 <jle`> in the end, runWire generates the same thing
21:21:16 <jle`> the type signature of runWire is functionally the same
21:22:02 <joebobjoe> Cale: Why do people even make new languages like Rust if they already have Haskell?
21:22:16 <Cale> joebobjoe: I dunno
21:22:23 <jle`> this would be the same as `arr (callback :: b -> IO ()) . (wire :: Wire Input b)`, by the way
21:22:32 <Cale> joebobjoe: I suppose that Rust is an attempt at something which is closer to the metal
21:22:38 <Welkin> Rust is a system language made for building firefox
21:22:39 <ski> Cale : or when it's only passed to some other argument
21:22:53 <Cale> ski: yeah
21:23:01 <ski> Cale : `Flip :: (k0 -> k1 -> *) -> k1 -> k0 -> *' and such
21:23:23 <jle`> Kaidelong: i...have never tried this out, and i haven't given this too much thought
21:23:31 <jle`> Kaidelong: I'll think about it a bit over the next few days
21:23:32 <Kaidelong> well
21:23:35 <ski> jle` : Rust is an attempt to make a better C, afaiui
21:23:36 <ski> er
21:23:38 <Kaidelong> it was exactly what I was planning
21:23:40 <ski> joebobjoe ^
21:23:50 <Kaidelong> I figured they could use . from category to add new features to the wire
21:24:05 <Kaidelong> until it became a totally pure wire
21:24:24 <joebobjoe> ski Cale: Why can't Haskell be a systems language? Surely, it can represent low-level constructs?
21:24:30 <Cale> It can, and does
21:24:31 <Kaidelong> (just by the time it hits this very stateful, bare bones library, it turns into an IO ())
21:24:48 <Cale> and it *can* be a systems language, but it doesn't make sense, for instance, to remove the GC
21:24:58 <Kaidelong> anyway thanks so much jle`, I need to go for a bit
21:25:16 <jle`> Kaidelong: it might be awkward trying to explain that you need to return an IO (), which doesn't have too much meaning
21:25:19 <ski> joebobjoe : however, Haskell doesn't have support for uniqueness in it's static system
21:25:21 <Enigmagic> guesting: well yeah, not sure what else to go on. it shouldn't be segfaulting, so it's probably a ghc bug..
21:25:38 <Cale> ski: Does Rust?
21:25:54 <guesting> Enigmagic: Oh geez. I hope that wasn't the issue. I'll find out tomorrow I guess. Thank you for your help!
21:26:04 <jle`> maybe it might be more meaningful to have your Window type be something like data Window = forall b. Window (Wire a b) (b -> IO ())
21:26:07 <Enigmagic> guesting: but unless you want to try upgrading to 7.6.3 or 7.8.2 you're not going to get much action by filing a bug report :-)
21:26:11 <jle`> Kaidelong
21:26:12 <ski> Cale : hm, perhaps i was thinking of BitC
21:26:15 <jle`> but myabe not, I'm not sure.
21:26:28 <Cale> ski: I honestly don't know much about the details of Rust
21:26:29 <guesting> Enigmagic: I'm waiting for the upgrade in June for Ubuntu 14.04
21:26:33 <jle`> a wire returninog (IO ()) sort of barely makes sense semantically
21:26:36 <jle`> but yeah, take care
21:26:37 <Cale> So it's possible that you're right :)
21:26:47 <guesting> Enigmagic: I'm using a server so I don't want to mess it up prematurely
21:26:51 <ski> Cale : i don't know that much yet either, though i'm interested in learning more
21:27:15 <joebobjoe> Cale: Couldn't someone build a lower-level compiler with lower-level primitives then rebuild the Haskell library on that?
21:27:27 <Cale> joebobjoe: Anyway, you can write a lot of things in Haskell, and you can write even more using Haskell as a metalanguage (e.g. by generating code in some other language using Haskell code to do it)
21:27:57 <ski> Cale : at least Rust infers some kind of regions or something, where memory is allocated -- to keep track of ownership
21:28:04 <jle`> haskell comes with a built in metaprogramming monad :)
21:28:32 <Cale> jle`: Well, I'm not even talking about template Haskell
21:28:34 <Enigmagic> guesting: fixing the stack space usage might make it go away though. i think the stack allocator and GC was changed either for 7.2.x or 7.4.x and may have had some issues.
21:28:39 <jle`> Cale: i'm talking about IO >_>
21:28:42 <Cale> I'm talking about approaches such as Atom
21:28:46 <jle`> sort of tongue in cheek
21:29:11 <joebobjoe> Cale: Isn't the Haskell compiler using Haskell as a metalanguage?
21:29:16 <joebobjoe> …since it compiles to another language.
21:29:24 <guesting> Enigmagic: I'll first see if svd succeeds, then update GHC, then cry
21:29:35 <Cale> http://hackage.haskell.org/package/atom
21:29:37 <guesting> Enigmagic: It'll all work out haha
21:29:57 <Enigmagic> guesting: good luck :-)
21:30:08 <guesting> Enigmagic: Thanks!
21:30:08 <jle`> `IO a` is an assembly metaprogramming api
21:30:14 <Cale> joebobjoe: Yes, but I'm talking about approaching other problems by writing little very-special-purpose compilers
21:30:24 <jle`> don't listen to me, i'm only making thigs more complicated
21:30:26 <jle`> :)
21:31:00 <Cale> see also http://hackage.haskell.org/package/harpy
21:31:20 <Cale> If you're interested in doing low-level stuff, these sorts of approaches can work in Haskell
21:31:52 <joebobjoe> Cale: So then Haskell turns into more of a modeling language?
21:31:55 <Cale> yeah
21:32:06 <joebobjoe> That sounds like the future.
21:33:11 <Cale> http://hackage.haskell.org/package/accelerate -- this is also pretty cool, and takes a similar direction
21:34:01 <Cale> It's a library for describing computations in such a way that they can be compiled to code and run on graphics cards and such, or just tested on a CPU
21:34:08 <joebobjoe> Cale: That's really amazing. Programming seems likes it's going to be very different in 30 years.
21:35:00 <Cale> It can be very different now, if you want to use this stuff :)
21:35:29 <joebobjoe> Cale: They don't teach it in school so I'm stuck doing Java :(
21:35:36 <joebobjoe> Because, homework.
21:36:29 <Cale> Java seems like it was designed especially to be a strawman for people who hate static type systems
21:42:58 <ReinH> Cale: That seems almost too plausible
21:43:00 <Kaidelong> @remember Cale Java seems like it was designed especially to be a strawman for people who hate static type systems
21:43:00 <lambdabot> Okay.
21:43:26 <dolio> It's more like if you took C++, and then removed all the really complicated stuff that is kind of good, instead of designing actually good versions of it.
21:44:21 <Kaidelong> @quote Cale Java
21:44:21 <lambdabot> Cale says: Java seems like it was designed especially to be a strawman for people who hate static type systems
21:44:32 <Kaidelong> this one might come in handy
21:45:02 <ReinH> ha
21:45:17 <yamadapc> hey there
21:45:38 <Aetherspawn> dolio: how would you design a good version of c++
21:45:40 <yamadapc> anyone knows how I get the line terminator character for the current system?
21:46:12 <Aetherspawn> yamadapc: it *might* be in System.IO maybe probably not.
21:46:20 <yamadapc> mm...
21:46:25 <yamadapc> ok thanks
21:46:52 <dolio> Aetherspawn: I mean like, templates are a fairly bad and complicated way to do parametric polymorphism.
21:46:55 <dolio> So get rid of it.
21:47:06 <dolio> Then add it back in a decade later.
21:47:08 <Aetherspawn> yamadapc: it's called nativeNewline :: Newline
21:47:17 <Aetherspawn> https://hackage.haskell.org/package/base-4.3.1.0/docs/System-IO.html#t:Newline
21:47:34 <Aetherspawn> dolio: lol'd
21:47:39 <yamadapc> thanks so much :)
21:48:32 <dolio> Or, C++ operator overloading is totally ad-hoc, and can do some really weird stuff. So get rid of it.
21:49:10 <Aetherspawn> or allow custom operators
21:49:21 <Aetherspawn> and add traits
21:49:29 <Aetherspawn> in fact, just, import Rust;
21:59:10 <mayski> is there an easy way to break ints into lists of bits
22:00:54 <Cale> mayski: The stuff in Data.Bits will probably be of use
22:01:27 <mayski> yeah I'm looking at the docs now but nothing really sticks out
22:01:50 <Kazagistar> ... my mind is officially blown by how fast fingertrees are
22:02:06 <mayski> maybe I'm approaching this from the wrong angle
22:02:38 <Cale> bits x = map (testBit x) [0 .. finiteBitSize x - 1]
22:03:18 <mayski> woop
22:03:43 <pingu> Cale: neat!
22:04:14 <ReinH> Cale: iirc there's a nice lens way to do that too
22:04:25 <Cale> probably
22:04:28 <ReinH> if you're into that sort of thing
22:09:30 <solidus-river> lols
22:09:36 <solidus-river> whoop
22:09:41 <solidus-river> *whoops, jesus
22:10:00 <erisco_> has anyone used shake? I have a two-step build process. lzz builds *.cxx to *.cpp and then g++ builds *.cpp to .exe ... I do not know how to setup this order correctly
22:10:13 <erisco_> I thought the need/want system would work but I cannot figure it out
22:13:25 <enthropy> erisco_: it is straightforward to have rules for generating "*.cpp" out of a "*.cxx"
22:13:59 <enthropy> erisco_: for example: http://lpaste.net/104444
22:14:00 <erisco_> enthropy, yes but that step must happen first
22:14:16 <erisco_> right now it is trying to do the g++ step first
22:14:41 <enthropy> erisco_: have you used "need"?
22:14:49 <erisco_> yes
22:14:56 <solidus-river> is there a way to only expose the accessors for a record data type?
22:15:24 <erisco_> enthropy, here is my code for reference http://lpaste.net/104445
22:18:10 <enthropy> erisco_: I don't think shake is smart enough to look at `cpps <- getDirectoryFiles "" [cppDir ++ "//*" <.> "cpp"]', and notice that those cpp files are generated by another rule
22:18:54 <enthropy> you might instead do something with `getDirectoryFiles "" [srcDir ++ "//*" <.> "cxx"]', then replace the extension
22:20:05 <erisco_> I do not know what you mean
22:20:18 <erisco_> about the replacement thing
22:21:00 <carter> erisco_: ... the order will just work
22:21:08 <carter> oh
22:21:09 <carter> hrm
22:21:21 <enthropy> > replaceExtension "foo.cxx" ".cpp"
22:21:22 <lambdabot>  Not in scope: ‘replaceExtension’
22:21:28 <enthropy> > System.FilePath.replaceExtension "foo.cxx" ".cpp"
22:21:29 <lambdabot>  Not in scope: ‘System.FilePath.replaceExtension’
22:21:34 <erisco_> oh well I really do not want to change the original files
22:23:09 <enthropy> erisco_: I mean do something like my annotation
22:24:21 <erisco_> hrm what is it doing?
22:25:23 <enthropy> I am assuming that lzz generates x.cpp given a x.cxx
22:25:30 <erisco_> yes it does
22:25:47 <enthropy> hmm, I guess you need to change the line 53 to use srcDir
22:26:16 <enthropy> and replace the directory in the next line
22:26:45 <erisco_> I have renamed cppDir to lzzDir for more clarity (I think)
22:26:47 <erisco_> http://lpaste.net/104447
22:28:27 <erisco_> does shake assume everything in the want list can be built in parallel?
22:29:16 <Enigmagic> erisco_: unless you say otherwise, yes
22:29:17 <erisco_> can I execute two commands in an action? I could combine the g++ and lzz stuff
22:29:41 <erisco_> I tried but there was an ambiguous type error so I shyed away
22:30:14 <Enigmagic> erisco_: yes
22:38:31 <erisco_> okay easier than expected thanks
22:38:49 <erisco_> found in the docs where you can pick what kind of result type you want
22:48:00 <hunt> how much slower is it to read and write from an IORef then use static vars?
22:48:07 <hunt> also why is this irc so dead lately
22:48:47 * erisco_ tumbleweed
22:49:01 <phienone> identify g3hSF-7a
22:52:01 <davidfetter> phienone, you probably want to change that password
22:53:55 <enthropy> hunt: what do you mean by "static var"?
22:54:35 <carter> hunt: because IOrefs are locations in memory
22:54:42 <carter> variables... can live in registers
22:54:45 <carter> because they're immutable
22:55:06 <carter> so every read/write on an ioref is like a volatile
22:55:15 <carter> roughly
22:55:30 <carter> and i'm off, sleep looms and beckons
22:55:33 <carter> happy hacking all
22:56:36 <erisco_> carter, thanks you too
23:05:42 <MitchellSalad> question about Scotty and Persistent - i'd like to handle database exceptions inside an ActionT, but it's not an instance of MonadBaseControl, and furthermore ActionT is opaque so I can't define StM for an ActionT
23:05:48 <MitchellSalad> should I just give up and switch to Yesod?
23:05:58 <MitchellSalad> I'm a fat noob at web frameworks for what it's worth
23:06:59 <bergmark> writing MonadBaseControl instances make me cry :-)
23:07:25 <MitchellSalad> ActionT is opaque so i cant figure out how to do it!
23:07:28 <bergmark> MitchellSalad: how does yesod handle these errors?
23:07:40 <MitchellSalad> the main monads are all instances of MonadBaseControl
23:07:46 <MitchellSalad> HandleT or whatever they're called
23:07:52 <bergmark> ah
23:08:06 <bergmark> i never got around to error handling when i experimented with persistent
23:08:17 <MitchellSalad> persistent and yesod were both designed by the same guy so it'll work =)
23:08:29 <hunt> so wait
23:08:32 <bergmark> yes, pretty unlikely that snoyberg would forget about that part :-)
23:08:37 <hunt> IORefs vs just using normal haskell references
23:08:40 <hunt> ?
23:08:42 <hunt> for speed
23:08:52 <bergmark> MitchellSalad: i'd ask on the yesod mailing list
23:09:18 <ReinH> hunt: whatever your benchmarks tell you
23:09:34 <ReinH> what are "normal haskell references"?
23:09:37 <hunt> ReinH: ok, theres no consensus?
23:09:49 <hunt> ReinH: i don't know, whatever happens when i just pass values around functionally
23:10:07 <ReinH> IORefs are almost certainly not faster than values, no
23:10:15 <hunt> Are they considerably slower?
23:10:26 <ReinH> I'm not sure. Are you sure you aren't prematurely optimizing?
23:10:30 <hunt> Like is there speed relative to the amount of data I'm inputting in them
23:10:46 <hunt> I'm pretty sure I'm not, this is a graphics program and something is killing my fps
23:10:51 <hunt> this is very possibly the source
23:11:00 <hunt> I'm trying to get a figure for how dramatic the impact of this is
23:11:01 <ReinH> Why don't you find out then?
23:11:07 <hunt> idk how to
23:11:12 <ReinH> GHC has built-in profiling tools
23:11:13 <MitchellSalad> p r o f i l e b o y s
23:11:22 <hunt> how do i use them though1
23:11:31 <MitchellSalad> gewgle.com
23:11:37 <hunt> ok i wil
23:11:40 <ReinH> Read the GHC manual, google for blog posts, etc
23:11:44 <bergmark> realworldhaskell has a chapter on it
23:12:17 <MitchellSalad> is it ironic that i come here asking for help and then im a dick to the other guy asking for help
23:12:48 <kazagistar> no, its just dickish
23:12:55 <MitchellSalad> lol
23:13:40 <MitchellSalad> ok, well i think im gonna try yesod over scotty cause this thing is a nightmare
23:13:43 <Cale> It is somewhat ironic for this channel anyway. Most people try to be nicer. :)
23:14:45 <MitchellSalad> haha i know, if i had anything constructive to say i would have, but if i was gonna profile some crap myself i would just google around because i dont have that knowledge memorized
23:15:02 <hunt> its fine MitchellSalad
23:15:06 <hunt> i would've googled it anyways
23:15:09 <MitchellSalad> thanks hunt <3
23:15:10 <hunt> i was just here
23:15:16 <Cale> hunt: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html is the relevant documentation anyway. There shouldn't be a massive difference between passing parameters and reading IORefs
23:16:15 <Cale> hunt: apart from the mutability of IORefs of course
23:18:19 <Cale> hunt: One thing you need to be cautious about is as you're passing parameters along or updating an IORef repeatedly, whether you're forcing the evaluation of those parameters or the contents of the IORef to be evaluated or not. If not, the expression graphs can start to take up a fair amount of memory, and the allocation costs of doing poorly in this regard can make your program slower.
23:18:54 <hunt> Cale: They have to be evaluated at each step so they can be drawn to the screen, i think
23:19:16 <hunt> i have a thing = 255, and i want to use that as a float in some places and an int in other
23:19:18 <Cale> Yeah, if you're drawing things to the screen, that's a pretty good indication that they're being evaluated at least that often.
23:19:19 <hunt> why can't i?
23:19:33 <Cale> Because numeric conversions are important
23:19:57 <Cale> Well, if you really want to, you can define a polymorphic constant
23:20:04 <Cale> thing :: (Num a) => a
23:20:06 <Cale> thing = 255
23:20:18 <ReinH> Cale: and turn the monomorphism restriction off?
23:20:30 <Cale> If you give an explicit type signature, it doesn't apply
23:20:33 <ReinH> oh ofc
23:20:40 <MitchellSalad> does roman cheplyaka hang out here?
23:20:47 <hunt> yea i had to give it the expect signature
23:21:37 * Maxdamantus wonders if there's a GHC extension that uses something else to denote polymorphism.
23:22:01 <Cale> hunt: Yeah, the monomorphism restriction will apply and cause the thing to get a non-polymorphic type. The reason for this is actually due to performance concerns -- a "constant" whose type involves a type class constraint like that is secretly a function, and will be re-evaluated at each site where it's used.
23:22:11 <Cale> So, if you, for instance, had
23:22:16 <Cale> thing :: (Num a) => a
23:22:24 <Cale> thing = product [1..10000]
23:22:45 <Cale> Then the work of computing that product would have to be redone every time you used "thing"
23:25:06 <Cale> This is because after translating away the type classes, it gets compiled into something like  thing numDict = product numDict [fromInteger numDict 1 .. fromInteger numDict 10000]
23:25:50 <Cale> and functions aren't memoised everywhere of course, because that would more or less mean never garbage collecting anything.
23:27:49 <cococo> Why does Haskell use otherwise rather than else like every other language?
23:28:03 <Maxdamantus> because `else` is a keyword.
23:28:05 <Cale> cococo: It does use 'else'
23:28:08 <Maxdamantus> >> otherwise
23:28:12 <Cale> > otherwise
23:28:13 <Maxdamantus> > otherwise
23:28:15 <lambdabot>  can't find file: L.hs
23:28:15 <lambdabot>  True
23:28:16 <Qfwfq> > otherwise == True
23:28:17 <lambdabot>  True
23:28:17 <Cale> heh
23:28:25 <cococo> > else
23:28:26 <lambdabot>  <hint>:1:1: parse error on input ‘else’
23:28:39 <cococo> got it
23:28:40 <cococo> thanks
23:28:44 <Cale> > if 0 < 1 then "hello" else "wat"
23:28:46 <lambdabot>  "hello"
23:28:51 <cococo> I started to wonder if Hakkell was just TRYING to be special
23:28:59 <cococo> *Haskell
23:29:35 <Cale> Well, guards are meant to look something like piecewise definitions from mathematics, apart from the fact that they ended up being written on the left of the = sign, because that turned out more readable in the end
23:30:05 <cococo> I actually really appreciate the way guards are written
23:30:23 <cococo> It's very cool and nice to read
23:46:34 <vova> Hi
23:47:08 <vova> Please help me with the following issue. It's very strange.
23:47:10 <vova> http://pastebin.com/gURBYL4U
23:49:35 <sjy> vova: that looks like it might be related to https://github.com/haskell/cabal/issues/1736 (fixed in March)
23:50:42 <sjy> (GHC.Conc.getNumProcessors returning 2 in the REPL but 1 when compiled)
23:51:04 <vova> Thanks :)
23:51:55 <cococo> How would I merge all elements of list a to elements of list b? For example if a was [a,b] and b was [1,2,3] I would want [1a, 1b, 2a, 2b, 3a, 3b]
23:52:24 <vova> I saw this page before. As far as I understand It's fixed in cabal only, is not it ?
23:52:44 <coppro> cococo: [x ++ y | x <- a, y <- b]
23:52:50 <cococo> coppro: thanks
23:53:03 <sjy> vova: i think you'll be able to get it to work if you add a '-threaded' flag to ghc somehow. i'm trying to get it to work on my machine now
23:53:32 <pavonia> > sequence ["123", "ab"]
23:53:34 <lambdabot>  ["1a","1b","2a","2b","3a","3b"]
23:53:49 <coppro> pavonia: I know, I know.
23:53:59 <pavonia> But you didn't say :p
23:53:59 <adas> :t sequence
23:54:01 <lambdabot> Monad m => [m a] -> m [a]
23:54:14 <coppro> because my answer is easier to understand by the average user
23:54:15 <cococo> Doh, I thought sequence would stop when it reached the end of the shorter list :p
23:54:30 <coppro> cococo: you may be thinking zip
23:54:39 <cococo> probably
23:54:49 <cococo> ^ our names look similar together
23:54:52 <coppro> they do
23:55:05 <cococo> it's like we're the same person when nothing's inbetween
23:55:49 <sjy> vova: compiling with "ghc -threaded source.hs" works for me
23:56:56 <sjy> at least, i get 8 on a quad-core i7, so it reports the maximum number of concurrent threads, i guess
23:56:56 <vova> Oh, thank you very mach.
23:57:10 <coppro> cococo: if that's the case, why are you still awake?
23:58:40 <cococo> coppro: I don't understand a single word I'm writing in Haskell but it's too addictive!
23:58:55 <coppro> hahaha
23:59:13 <coppro> that's how I feel and I've been dabbling in it for quite a while :)
23:59:29 <cococo> Does lambdabot support multi-line code?
