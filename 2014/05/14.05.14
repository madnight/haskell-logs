00:37:23 <kristi_kodare> :t 2
00:37:24 <lambdabot> Num a => a
00:49:04 <mikeplus64> @pl foldr (\a _ -> [a]) []
00:49:04 <lambdabot> foldr (const . return) []
00:50:41 <tdammers> alright... I have this: http://lpaste.net/3750825154691727360
00:50:54 <tdammers> but I'd like to avoid the `return undefined` part
00:50:55 <pavonia> mikeplus64: take 1?
00:51:15 <tdammers> and declare the IsString instance on ThingieT t m () instead of Thingie t m a
00:51:24 <tdammers> any ideas on this?
00:53:03 <mikeplus64> @pl foldl' (\_ a -> [a]) []
00:53:04 <lambdabot> foldl' (const return) []
00:55:24 <pavonia> tdammers: You could have a constraint Monoid a and return mempty
00:57:06 <tdammers> pavonia: in practice, I want to always return ()
00:57:19 <tdammers> oh wait
00:57:22 <supki> tdammers: what's the problem with defining IsString (ThingieT t m ())
00:57:22 <tdammers> yeah that could work
00:57:23 <supki> ?
00:57:31 <tdammers> supki: well, try the paste
00:57:38 <tdammers> it'll complain about ambiguous types
00:57:49 <tdammers> do { "foo"; "bar" }
00:58:13 <tdammers> the compiler can't decide what the `a` type should be for `fromString "foo"`
00:59:26 <supki> oh, right
01:00:14 <tdammers> plus it requires FlexibleInstances
01:00:22 <supki> tdammers: the usual trick is to have (a ~ ()) => IsString (ThingieT t m a) instead
01:00:48 <tdammers> right... I can declare that explicitly, can I
01:01:21 <supki> with TypeFamilies, sure
01:01:43 <tdammers> right
01:02:02 <tdammers> yup, that works
01:02:03 <tdammers> thanks
01:03:35 <pavonia> What is the difference between "(a ~ ()) => IsString (ThingieT t m a)" and "IsString (ThingieT t m ())"?
01:05:15 <luite> inference works in a different order, first matching a and then constraining it matches all types
01:06:04 <luite> while directly matching () doesn't unify with polymorphic types
01:08:31 <pavonia> luite: But shouldn't both fail if a isn't () and succeed if a is ()?
01:09:03 <pavonia> I mean I don't understand why one works and the other doesn't
01:12:42 * hackagebot tamper 0.2.0.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.2.0.0 (TobiasDammers)
01:22:43 * hackagebot MFlow 0.4.5.4 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.4 (AlbertoCorona)
01:24:56 <Feuerbach> pavonia: what if a is a type variable?
01:25:10 <Feuerbach> it isn't equal to ()
01:25:18 <Feuerbach> but it can be unified with ()
01:26:16 <Feuerbach> this makes a difference when selecting an instance for a class constraint
01:32:31 <pavonia> Feuerbach: I really can't wrap my head around that. Do you have a small code example where it makes a difference?
01:37:26 <tdammers> pavonia: the thing I pasted maybe?
01:37:55 <pavonia> Well, that's the thing I don't understand :)
01:38:04 <OneEyed> Hi. Any reason to use "." over "<$>" to combine functions, other the difference of priority and associativity?
01:39:21 <pavonia> OneEyed: faster typing and readability
01:39:37 <OneEyed> :)
01:45:24 <tdammers> can always remap your . key...
01:45:45 <tdammers> but I guess that's impractical if done at the system level <$><$><$>
01:46:20 <OneEyed> Good idea, I'll do it immediately<$>
01:47:46 * hackagebot tamper 0.3.0.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.0.0 (TobiasDammers)
02:52:53 * hackagebot hatex-guide 1.3.1.0 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.3.1.0 (DanielDiaz)
02:55:45 <vlads1> I need to apply (,) and (flip . (,)) to same two arguments to get [(a, b), (b, a)], but cannot get how. Is it possible and is it worth effort?
02:55:51 <ique> how can I return values from a `pipes` pipeline? I have Producer >-> Pipe >-> Pipe >-> Consumer, and want to return values from the consumer in the end, but the types just won’t let me :S
02:56:30 <ique> essentially I just want to “return x” at the end and bubble that up through runEffect
02:59:17 <peteretep> vlads1: Could you put the two functions you want in a list, and then map over that?
03:05:09 <hexagoxel> vlads1: you mean (flip (,)), not (flip . (,)) ?
03:07:13 <jle`> vlads1: why not \x y -> [(x,y),(y,x)] ?
03:09:14 <leggo> jle` too pointy :P
03:14:02 <vlads1> hexagoxel: yeah, I meant exactly that
03:15:49 <vlads1> jle`: yeah, I kinda hoped to come up with something nicer
03:17:10 <vlads1> it seems that best (using map style) would be map (($a) . ($b)) [(,), flip (,)] which is not very clean
03:17:55 <jle`> @pl (\x y -> [(x, y), (y, x)])
03:17:55 <lambdabot> ap (ap . ((:) .) . (,)) (flip flip [] . ((:) .) . flip (,))
03:18:10 <Reite> oh yeah
03:18:13 <vlads1> wow
03:18:17 <leggo> I don't think you will get it cleaner than \x y -> [(x,y),(y,x)]. I would love to be proven wrong, though
03:18:52 <jle`> honestly if you are using it in real code, the pointful version is probably the most immediately understandable version
03:19:08 <vlads1> leggo: I have to admit, you're right
03:19:17 <jle`> even if you find a "cleaner" way, it will probably take longer to process and read than the explicit lambda
03:19:26 <jle`> as someone reading code
03:19:32 <Reite> In my experience point free doesnt usually work very well when you want to reuse an argument
03:19:54 <vlads1> I'm using it in excersises
03:19:59 <jle`> point free is also often bad with two arguments
03:20:15 <jle`> it might be nicer if you are willing to keep one point, maybe.
03:21:07 <vlads1> jle`: I lost you about keeping one point
03:22:59 <supki> :t (ap (:) (pure . swap) .) . (,)
03:23:01 <lambdabot> b -> b -> [(b, b)]
03:24:59 <Aetherspawn> supki: how did you come up with that
03:26:23 <vlads1> the best I got without lambdas is map (($a) . ($b) . ($(,))) [id, flip] which is also bad. Lambda is way to go, seems. Or I could decypher supki's suggestion.
03:38:29 <Eduard_Munteanu> Are there any good ways to store and update graphs persistently, other than the obvious 'persistent' + a database storing vertices and edges?
03:38:56 <lahwran> draw it on a whiteboard, there are robots you can buy that integrate with haskell
03:39:08 <lahwran> sorry ignore me, I'm tired
03:39:22 <Eduard_Munteanu> :)
03:47:38 <Sonderblade> Eduard_Munteanu: are you asking what data types to use, how to serialize it or something else?
03:55:32 <zomg> Eduard_Munteanu: What about a graph database? No idea tbh :)
03:57:24 <augur> is there a preferred way of having a stateful reader?
03:57:54 <augur> or do you just use   Reader (State s a)  and lift things about?
03:59:29 <bergmark> augur: is `local' to restrictive?
03:59:38 <Eduard_Munteanu> Sonderblade: I'm asking about the serialization / storage aspect rather than about Haskell types/terms.
03:59:43 <augur> dunno what local is, bergmark :D
03:59:47 <augur> @hoogle local
03:59:48 <merijn> Eduard_Munteanu: My conclusion after reading up on the state of the art of graphs is: sad
03:59:49 <lambdabot> Control.Monad.Trans.RWS.Lazy local :: (Monoid w, Monad m) => (r -> r) -> RWST r w s m a -> RWST r w s m a
03:59:49 <lambdabot> Control.Monad.Trans.RWS.Strict local :: (Monoid w, Monad m) => (r -> r) -> RWST r w s m a -> RWST r w s m a
03:59:49 <lambdabot> Control.Monad.Trans.Reader local :: Monad m => (r -> r) -> ReaderT r m a -> ReaderT r m a
04:00:17 <merijn> Eduard_Munteanu: Actually, in case of haskell you may be able to use acid-state in a reasonable way?
04:00:39 <augur> bergmark: ahahaha i should use ReaderT :)
04:00:50 <Eduard_Munteanu> merijn: mm, I don't think acid-state supports adding stuff efficiently
04:01:05 <merijn> Eduard_Munteanu: Depends on the datatype you use
04:01:30 <Eduard_Munteanu> merijn: I mean it has to rewrite the whole thing, not just append / add "rows", no?
04:01:43 <merijn> You may want to look into triple stores instead of standard relational databases
04:01:48 <merijn> Eduard_Munteanu: Why?
04:02:10 <merijn> That depends on your actual datatype, I'd say
04:02:47 <Eduard_Munteanu> merijn: dunno for sure, I just remember asking about storing lists of things, and IIRC the conclusion was acid-state can't really cons / append to such a list.
04:04:57 <Eduard_Munteanu> Oh, hm, triple stores are exactly what I need.
04:05:27 <merijn> :)
04:08:04 <aspidites> merijn: are triple stores just the next step up from key-value stores?
04:08:31 <aspidites> did a google search, but the words are generic enough that i wasn't really sure what to read
04:09:00 * aspidites really should start using duckduckgo again
04:09:09 <merijn> aspidites: No, they're databases focused on storing graphs and querying them
04:09:58 <aspidites> ah, adding graph db to the query turned up more useful results, thanks
04:10:55 <merijn> "Maybe (Either a b)" vs "MyOwnADT a b"?
04:12:35 <aspidites> merijn: newtype MyOwnADT a b = Maybe (Either a b)
04:13:02 * hackagebot azure-servicebus 0.1.5.0 - Haskell wrapper over Microsoft Azure ServiceBus REST API  http://hackage.haskell.org/package/azure-servicebus-0.1.5.0 (kapilash)
04:15:10 <aspidites> that said, is such a type basically encapsulating the idea that you may or may not do something, and that something you do may or may not fail?
04:18:03 <merijn> I would say more that it is "may do one of two options"
04:18:09 <merijn> Ugh
04:18:11 <widgetman> does anyone know what i'm doing wrong in the last line of the funct 'concatV' - http://lpaste.net/966535330008137728 ?  currently i'm getting this error at compile: http://lpaste.net/8392856220871950336
04:18:22 <merijn> I'm having a real pain writing a parser that does what I want :\
04:18:32 <erikd> aspidites: why not data MyOwnADT a = No | Yes a | Fail b  ?
04:18:57 <merijn> widgetman: Which GHC version?
04:19:04 <augur> hrmph
04:21:40 <widgetman> merijn: i think i'm using 7.6.3
04:22:10 <widgetman> this is a homework question by the way
04:22:55 <merijn> Basically I have 3 types of parsers "Parser a", "Parser (Either a (a, b))" and "Parser (Either a (a, c))" and need to end up with "Parser ([a], Maybe (Either b c))", i.e. attempt to parse a's until it either fails OR I encounter a b/c
04:23:09 <merijn> But I can't find a non-sucky way to get things to fit together
04:24:23 <aspidites> erikd: i don't really have an argument against that ;-). I just figured if merijn was deciding between two options that a newtype wrapper made sense
04:24:50 <aspidites> i also don't do a lot with phantom types myself
04:25:05 <aspidites> or a lot in general really :P
04:25:11 <merijn> aspidites: There are no phantom types in erikd's example
04:25:12 <aspidites> that whole, being a perpetual beginner thing
04:25:51 <aspidites> merijn: the b doesn't appear on the left hand side of the definition.
04:26:20 <erikd> i dropped the b by mistake
04:26:21 <aspidites> oh wait..got it switched
04:26:27 <aspidites> oh ok
04:26:34 <merijn> aspidites: That's not a phantom
04:26:44 <merijn> aspidites: Phantom types are types that don't appear on the right hand side
04:26:53 <merijn> aspidites: i.e. they have no "corporeal body" :)
04:27:07 <merijn> "data Const a b = Const a" <- 'b' is a phantom type
04:27:15 <aspidites> merijn: hence why i said "wai...got it switched"
04:27:25 <aspidites> wait*
04:27:25 <merijn> ah :)
04:28:03 <merijn> Anyone have suggestions for my parser conundrum, though?
04:29:56 <phooby> how should the output of the -s be interpreted? i'm running io processing in different threads and get "Total   time   10.26s  (391.75s elapsed)" the elapsed time makes sense but i don't understand the 10.26s (the app ran for a couple of minutes). what i'm missing?
04:30:01 <vanila> merijn, is that getting a good return value of out p1 <|> p2 <|> p3?
04:30:41 <ivanm> merijn: you can't just parse a `b' or `c' individually?
04:31:05 <merijn> ivanm: No, because I'm not really parsing b/c, they indicate partial successes
04:31:05 <vanila> or rae you running p1 many times, then trying p2 or p3?
04:31:49 <merijn> vanila: No, they're all randomly interleaved. The only thing I know is that the p2/p3 types are the last on the line if they are partial successes
04:31:55 <ivanm> if you can potentially parse an `a' by one of the two Either parsers, I would be tempted to ignore the "Parser a"
04:32:21 <merijn> ivanm: They parse vastly different things
04:32:29 <ivanm> ahhh, right
04:32:37 <merijn> ivanm: 'a' is just "Text" in my case, but which type of Text differs
04:33:03 <ivanm> merijn: will "Parser a" succeed in the case that one of the other two will?
04:33:59 <ivanm> if that's the case, have a look at how manyFinally' is defined in polyparse; that might be what you're after
04:34:39 <merijn> ivanm: I think so, but not the other way around not, since the "Parser a" should never run if one of the others succeed
04:34:44 <phooby> ah, it's the cpu time. i misread the docs. :)
04:35:17 <ivanm> merijn: yeah, manyFinally' in polyparse sounds similar to what you want
04:35:32 <ivanm> (with the two Either parsers being <|> in the finally case)
04:35:45 <ivanm> difference being that you want to return them, whereas it discards the finally parser result
04:37:07 <vanila> widgetman, it's because write m + (n*m), it was being parsed as (m + n)*m
04:37:20 <vanila> widgetman, also Vec (m*n) a
04:37:42 <merijn> ivanm: The problem is that I don't have a "finally" parser, though
04:38:05 * hackagebot digestive-functors 0.7.1.1 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.1 (JasperVanDerJeugt)
04:38:16 <ivanm> you want to stop when one of the Either parsers finish though, don't you?
04:38:52 <merijn> Wait, I need to stare at the grammer a bit to check the parser order
04:39:17 <ivanm> merijn: it deals with overlapping parsers, so it keeps trying to run the finally one to see if it's finished
04:41:15 <merijn> ivanm: Yeah, that's what "manyTill" does too, but the problem I had there was that my "final" parsers can appear in the middle too. I initially planned to use manyTill and seperate my "partial" parser into seperate parsers for complete/partial parses, but I decided against as that could result in *really* expensive backtracking
04:41:45 <ivanm> will it always appear at the end though?
04:42:14 <widgetman> vanilla: oh great that fixed it! thankyou! also, my lecturer said that the multiplication operate defined there is not commutative. why is that?
04:42:15 <ivanm> you could always do a "Parser ([a], Either b c)" and run it multiple times with many
04:42:46 <merijn> ivanm: That would potentially result in multiple Either's which should be impossible
04:43:54 <merijn> ivanm: But I think you gave me an idea, lemme try
04:43:56 <ivanm> backing up a bit: so you have a [a] that you want to parse, and somewhere within that list there might be a `b' or `c' to parse as well?
04:44:05 <ivanm> as in at most one of the two?
04:44:24 <ivanm> do the parse assuming it has the Either, then do a many on the `a' parser
04:46:02 <hubblebub> Can I pass unboxed values to other functions with do not have the magic hash as part of their type? For instance, I'm looking to pass an unboxed Int to unsafeIndex of the Vector.Unboxed module
04:46:42 <merijn> ivanm: Basically, I have a bunch of Text parser, two parsers my span multiple lines and need to signal this fact (plus some state about the parse) when they encounter a newline
04:46:59 <merijn> ivanm: However, the multi-line entries can also appear somewhere in the middle if succesfull
05:03:13 <merijn> ivanm: I think this should work? http://lpaste.net/104132
05:04:41 <ivanm> merijn: the usage of undefined looks weird... :p
05:04:44 <ivanm> but it looks OK
05:04:50 <ivanm> you're the one with the data to test it on though :p
05:07:33 * Hayro pingme
05:08:43 <merijn> ivanm: It's undefined because I didn't decide on the proper input value for those yet
05:09:04 <merijn> And my hdevtools isn't build with 7.8 so I have no TypedHoles support >.>
05:09:31 <ivanm> why not build it with 7.8? or you mean it doesn't support using TypedHoles?
05:10:39 <merijn> ivanm: Because I still have 7.6 from platform as main environment and rebuilding hdevtools with 7.8 means having to switch *everything* over to 7.8
05:12:48 <ivanm> ahhh, right
05:20:09 <Hayro> ACTION NEW CANAL #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv /Ame #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv #cvv
05:21:26 <nicoo> Hayro: Stop flooding
05:22:01 <Hayro>   #cvv  New  canal
05:23:10 * hackagebot rest-gen 0.10.0.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.10.0.1 (AdamBergmark)
05:23:45 <nicoo> copumpkin, edwardk, ski : Hayro is annoyingly flooding
05:23:58 <nicoo> Ah, he/she/it left
05:25:25 <kadodka> yes
05:25:29 <merijn> nicoo: FYI, the "@where ops" will highlight all ops, next time a spammer's around
05:29:14 <nschoe> Hi everyone ! Does anybody know if there was a Haskell implementation of the WebRTC API ?
05:29:48 <nschoe> I could find a C/C++ WebRTC API, but I'd prefer go in Haskell. My research haven't given me anything so far :/
05:30:24 <nicoo> merijn: Thanks; that's useful to know :)
05:31:13 <astroblaster> Hello, I have two functions of type Char -> Bool, I wan't to glue them toghther with && operator in some nicer way than \c -> isAscii x && isPrint x
05:31:16 <astroblaster> any hints?
05:31:32 <astroblaster> s/operator/function/
05:33:06 <merijn> astroblaster: There are some ways, (like the All monoid), but in practice I think they're pretty much all uglier than just that lambda
05:33:40 <astroblaster> merijn: ok, thanks
05:33:49 <merijn> :t getAll . foldMap (All .)
05:33:51 <lambdabot>     Couldn't match type ‘a -> All’ with ‘All’
05:33:51 <lambdabot>     Expected type: (a -> Bool) -> All
05:33:51 <lambdabot>       Actual type: (a -> Bool) -> a -> All
05:59:24 <awestroke> if I have "data Foo = Bar Int | Baz String" and "x :: Foo", is there an easy way to do something like "x == (Bar _)" without creating a pattern-matching function?
06:00:51 <arj> awestroke: case?
06:01:32 <awestroke> arj: that's kind of a pattern matching function though. I want "x `kindOf` Bar"
06:01:43 <mateioprea> hello, is there any possibility to achieve with lambdas what i achieve with (x:y:xs) ( take 2 elements from a list at the same time)? it's just a curiosity
06:02:25 <awestroke> > (\(x:y:xs) -> (x,y)) [1,2,3,4]
06:02:27 <lambdabot>  (1,2)
06:03:04 <mateioprea> hmmmm ... thanks
06:03:23 <joe_k> anyone using haskell on the raspberry pi?
06:03:58 <ion> mateioprea: Note that you can’t provide alternative cases with a plain lambda.
06:03:59 <arj> awestroke: why not defining a function isBar ?
06:03:59 <awestroke> So I want a function that takes a value and a type contstructor and return whether the value was created using the constructor. but I guess functions can't do that
06:04:28 <awestroke> arj: that's my current approach but it seems a neater solution should be possible
06:05:40 <flebron> ion: Can't you use \x -> case x of ...?
06:06:11 <ion> Yes, also LambdaCase etc.
06:06:16 <arj> awestroke: if you don't want to write it yourself, you could even use template haskell
06:07:13 <awestroke> arj: can I count the number of type parameters with templatehaskell?
06:07:47 <arj> awestroke: no idea, I only used existing TH code
06:07:50 <ozataman> anybody know why cabal would require global constraints out of nowhere? With -v3, I see annotations like (global constraint requires ==1.0.17.1) everywhere, but have no clue what introduces them.
06:08:08 <awestroke> ozataman: could be base
06:08:24 <awestroke> hm no wait
06:08:26 <awestroke> nevermind
06:09:10 <ozataman> Yeah, I thought of the possibility, but doesn't seem like it.
06:09:44 <arj> but anyway, why would you want to get rid of this? the way to determine the content of a variable in haskell is pattern matching
06:09:57 <arj> if it holds an ADT
06:12:00 <supki> awestroke: you can generate prisms for your adt and then use has/hasn't
06:13:02 <awestroke> supki: Control.Lens.Prism ?
06:13:43 <supki> yes
06:13:50 <supki> > has _Left (Left 3)
06:13:51 <lambdabot>  True
06:13:54 <supki> > has _Left (Right 3)
06:13:55 <lambdabot>  False
06:14:03 <supki> they also compose
06:14:32 <supki> > has (_Left._Right) (Left (Right 3))
06:14:33 <lambdabot>  True
06:14:51 <awestroke> @src has
06:14:51 <lambdabot> Source not found. It can only be attributed to human error.
06:14:57 <awestroke> :t has
06:14:58 <lambdabot> Getting Any s a -> s -> Bool
06:19:20 <arj> :i has
06:33:18 * hackagebot HaTeX 3.12.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.12.0.0 (DanielDiaz)
06:33:35 <awestroke> :t reify
06:33:36 <lambdabot> Not in scope: ‘reify’
06:36:32 <DanielDiaz> I have a package with a test suite. When a falsifiable property is found, it says "--quickcheck-replay '25 513217224 1655838838'". How do I pass this flag to "cabal test"?
06:37:21 <awestroke> DanielDiaz: what happens if you pass it?
06:37:31 <DanielDiaz> "cabal: unrecognized 'test' option `--quickcheck-replay'"
06:37:36 <ion> danieldiaz: cabal test --help
06:37:59 <DanielDiaz> help says: --test-option=TEMPLATE
06:38:04 <DanielDiaz> yeah, that looks good
06:38:21 <hubblebub> Is there any package that allows us to deal with irregularly-shaped unboxed data? Like a vector of vectors?
06:39:12 <hubblebub> I may have rather small inner vectors, so I'm hesitant to use a list of Vector
06:39:37 <alpounet> hubblebub: what are you going to do with these vectors?
06:40:08 <hubblebub> alpounet: I'm going to add them, do reductions, filters, groupby etc
06:41:16 <hubblebub> alpounet: for the sake of simplicity, let's say we want to add two of these things :)
06:41:57 <alpounet> hubblebub: I meant: are you going to keep those same vectors around or are you just going to produce and consume them as you go
06:42:35 <hubblebub> alpounet: mostly I am going to produce and consume them such that all intermediate vectors are hopefully gone entirely
06:42:43 <hubblebub> alpounet: there will be a sink to stream the data out
06:43:21 <alpounet> hubblebub: i think then a normal Vector of unboxed ones should be fine
06:43:54 <DanielDiaz> ok, I am passing the flag directly to the test executable, and it still complains saying: "option --quickcheck-replay: Could not parse quickcheck-replay"
06:44:06 <alpounet> you can't have unboxed of unboxed obviously
06:44:53 <hubblebub> alpounet: you think the deforestation works fine for nested vectors? e.g. (map (\xs -> map f xs) xss) . (map (\xs -> map f xs) xss) ?
06:44:59 <alpounet> DanielDiaz: tasty makes its executables have the --quickcheck-replay option by the way
06:45:26 <DanielDiaz> alpounet: I am using tasty, by the way
06:45:28 <hubblebub> alpounet: I'm guessing it should, since the outer maps should bring the inner ones together, right?
06:46:01 <alpounet> DanielDiaz: https://github.com/feuerbach/tasty <- see the "Setting options > Runtime" section of the readme
06:46:25 <alpounet> hubblebub: I think so too, you should try it out, and you can check how that goes with the Core
06:46:37 <DanielDiaz> let's see
06:47:01 <hubblebub> alpounet: all right, thanks, I'll give it a shot :)
06:47:09 <hubblebub> alpounet: btw have you tried the Pipes package?
06:47:19 <atohs> hi
06:48:00 <atohs> what's the difference between the functions in Data.List vs those of the same names in Prelude?
06:48:02 <hubblebub> alpounet: it claims fusion but I don't think GHC is optimizing the abstraction out, it's pretty slow (about an order of magnitude compared to Vector)
06:48:12 <alpounet> hubblebub: yeah, I like it, although I tend to not use it that much at work (i don't always need its power)
06:48:56 <hubblebub> alpounet: would you mind checking if I'm doing something really dumb with a simple Pipes code?
06:48:58 <alpounet> hubblebub: but the problem pipes solves is different. vector is a fast array library, pipes lets you write constant-space processing functions for any kind of streaming application
06:49:41 <alpounet> hubblebub: you should post your code on the pipes mailing list, they love reviewing code and helping out people understand how to use pipes. although, most of the people there know pipes much better than i do
06:49:54 <alpounet> also*
06:50:05 <hubblebub> alpounet: yeah, basically what I do is read in a bunch of data in an unboxed vector, and then I need to execute a bunch of operations on it
06:50:28 <hubblebub> alpounet: which will be dynamically composed, but I'm checking it with just static composition to see its performance
06:50:46 <hubblebub> alpounet: all right, thanks :)
06:50:48 <DanielDiaz> alpounet: didn't help much... I am doing exactly what the program asks me to do. Is it a problem if the replay token comes from another computer?
06:51:03 <alpounet> hubblebub: do you need the whole blob of data at once in memory or would you be able to process the data by chunks (in which case you may want to bring 'pipes' in)
06:52:10 <hubblebub> alpounet: yeah this will be chunked
06:52:17 <hubblebub> alpounet: it's far too big for memory
06:52:29 <hubblebub> alpounet: it's all numeric data
06:52:53 <alpounet> DanielDiaz: that may be a problem, I see some StdGen value there related to the replay feature: http://hackage.haskell.org/package/QuickCheck-2.1.0.3/docs/Test-QuickCheck-Test.html
06:53:44 <hubblebub> alpounet: the thing is, it's highly dimensional and some dimensions are really small, which makes the performance of something like concurrent tasks and channels too great
06:54:09 <alpounet> hubblebub: then you probably want to have that data source be a stream that would produce (in pipes terminology) Vectors or Repa arrays for each chunk, and then write your processing logic there
06:54:59 <alpounet> but again, shoot an email to the pipes mailing list, you'll get a lot of interesting answers, and i'll also be able to follow that discussion, that's related to my interests too
06:55:02 <hubblebub> alpounet: yeah that's what I inteded to do, but the overhead of pipes is pretty large (i.e. too large to push around small vectors)
06:55:21 <alpounet> pipes shouldn't be that heavy
06:55:41 <hubblebub> Yeah I think it's boxing things somewhere
06:55:55 <DanielDiaz> alpounet: I have to go now. If I would be able to reproduce that test, it'd probably pass this time. I just wanted to make sure. Thank you for your attention.
06:56:48 <alpounet> so maybe there's a little tweak you could do in your code to speed things up and have all allocations be controled the way you want. the pipes people can help you figure out the problem
07:01:39 <alpounet> hubblebub: at some point, you may want to look at the accelerate package too, if you're doing heavy numerical computations
07:02:07 <alpounet> ah and the #numeric-haskell channel may be relevant too
07:02:13 <alpounet> err, #numerical-haskell
07:02:23 <merijn> Anyone have a sec to deduplicate my code? I have http://lpaste.net/104135 but it feels very redundant
07:02:31 <merijn> But I can't quite see how to make it less so
07:02:55 <smiller2> < jle`> generally, how netwire works is you have a Wire m (all inputs, key presses, network activity, etc.) (all outputs, your entire thing to render, etc.) — That said, it also seems like some mappigns from all inputs to all outputs can be put in independent wires run concurrently, yes?  Have one concurrent thread do the rendering, another physics, etc.
07:06:22 <atohs> ahhh Prelude imports Data.List
07:06:32 <awestroke> atohs: just some of it
07:06:58 <remdezx> Hello! When building with cabal -j option it always shows only 10 lines of build log. Is it possible to make it show more lines? Maybe there is some option in cabal.config I overlooked?
07:07:08 <awestroke> atohs: you can do "import Prelude hiding (map, otherConflicitingName)"
07:07:53 <merijn> atohs: Prelude mostly consists of re-exports from other modules
07:09:16 <atohs> ahhh, sometimes when looking at other's code, it will be nice to see which of their call came from where
07:09:22 <alpounet> remdezx: it actually mentions a log file where you can read the whole log
07:09:31 <atohs> maybe it is time to try the ide
07:10:14 <remdezx> I know, but I thought this "10" can be configured somewhere and it's not just constant in cabal's code
07:10:47 <atohs> so if someone reimports Data.List, those that overlaps are shadowed
07:11:50 <merijn> atohs: ghci can tell you where a function comes from and reexports will never shadow identical functions
07:12:18 <merijn> atohs: i.e. "Prelude.map" and "Data.List.map" are identical because GHC can tell that Prelude is just reexporting Data.List.map, so the functions must be the same
07:13:02 <atohs> there is a -<name> in ghci, is there an unimport keyword?
07:14:13 <atohs> say when one loads Data.List and ghc resolves that Data.List.map and Prelude.map are the same. so it skips Data.List.map
07:15:00 <merijn> What would that mean?
07:15:41 <atohs> :module +Data.List
07:15:55 <atohs> which brings in the additonal functions
07:16:27 <atohs> hmmm let me test, -Data.List
07:17:22 <nh2> how can I find out where a "GHC stack-space overflow:" comes from in ghci?
07:29:50 <yitz> nh2: first, make sure you understand what causes this. it's when you do computation on a huge number of items, and all of those computations get delayed due to laziness because you don't consume the results of those computations until the very end.
07:30:47 <yitz> nh2: once you get the hang of it, you can usually find the problem pretty quickly just by reviewing your code.
07:31:13 <yitz> nh2: aside from that, profiling is the standard tool for searching for this kind of space leak.
07:34:09 <yitz> nh2: another thing is that the runtime allocates a relatively small stack by default. if you've got lots of ram, sometimes you can get past this problem by allocating 1 GB stack.
07:34:44 <c_wraith> I thought stacks have automatically grown for a while now
07:35:54 <yitz> c_wraith: dunno. this has solved the problem for us on occasion.
07:37:22 <atohs> ok when I do :module -Data.List, in removes the function that Prelude did not export
07:37:49 <atohs> is this perfunction mapping kept in a symbol table?
07:38:11 <yitz> c_wraith: i know, it's a cop out. but if you just need to process someone's data on a one-time basis and get it out the door...
07:42:25 <yitz> atohs: i don't know the internal details. but it appears not. it seems tht this just changes the current effective import list, and then that is used to re-compute the currently visible names.
07:43:26 * hackagebot apiary 0.2.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.2.0.0 (HirotomoMoriwaki)
07:46:33 <atohs> ok yitz so the concept un un-importing does not make sense in a compiled environment then
07:49:28 <Sculptor> hi
07:56:34 <kstt> Hi. Puzzle-like question today : I need to work a [Maybe a] to extract series of consecutive 'Just a'. The function signature is [Maybe a] -> [ [a] ].  Any clever idea about the implementation please ?
07:57:07 <Feuerbach> kstt: look at groupBy from Data.List
07:57:19 <peteretep> kstt: What do you want to do on Nothing?
07:57:56 <peteretep> Also that's an odd signature
07:58:13 <Feuerbach> don't see anything odd about it
07:58:27 <peteretep> ah, series of consecutive
07:58:29 <peteretep> I missed that bit
07:58:30 <kstt> peteretep: on Nothing, close the current segment, push it to the result, skip to the next Just a, open a new segment on it, keep going
08:00:27 <kstt> groupBy seems useful, good idea, thank you Feuerbach
08:00:59 <nh2> yitz: I don't understand what causes it, I want to *find* what causes it
08:01:41 <nh2> profiling doesn't help because it only happens in GHCI
08:05:05 <thelarry> hi! what Frontend libs are there for haskell? meaning for which common frontend lib (like qt, gtk etc.) does exist a port or interface to use it from a haskell backend?
08:06:26 <aspidites> thelarry: gtk2hs, hsqml, threepenny, and wxhaskell
08:06:54 <aspidites> isn't there a lambdabot command that automatically fetches links?
08:07:13 <fizruk> thelarry: check out http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
08:08:53 <aspidites> fizruk: i didn't realize that had actually been updated (sort of) recently
08:09:29 <kstt> thelarry: GTK/Haskell might very well make you suffer
08:10:01 <thelarry> fizruk: thx!
08:10:31 <aspidites> in my experience, hsqml was the easiest to install on multiple platforms.
08:11:03 <fizruk> aspidites: were there problems with threepenny?
08:11:27 <aspidites> fizruk: never tried it. it didn't suit my use case though
08:11:51 <aspidites> i suspect it's the easiest though, given it just reuses your browser
08:12:00 <aspidites> unless the end user has something like elinks installed, i'm guessing
08:12:57 <quchen> I'm having trouble making out the exact use of weak pointers (System.Mem.Weak). Is it to keep track of whether something is GC'd only (and reacting to it)? Are weak pointers themselves GC'd when they are pointing to something that doesn't exist?
08:13:20 <quchen> I'm wondering whether adding a finalizer (cancellation) to an Async via a weak pointer would be a good idea.
08:14:15 <merijn> quchen: Weak pointers are pointers to point to things that may no longer exist.
08:14:31 <merijn> quchen: i.e. a weak pointer to object A does not stop A from being GCed
08:14:39 <quchen> Okay so far.
08:14:40 <fizruk> aspidites: elinks? lynx in emacs? brr… ;)
08:15:20 <merijn> Now, when the liveness of weak pointers is checked, i.e. "is the thing this points to still alive?" and the answer is "no", the result is that the finalizer is run
08:15:55 <merijn> quchen: GHC checks weak pointers every major GC, I believe. However it is conceptually possible for an arbitrary time to pass between something becoming garbage and the finalizer running
08:16:28 <ij> This is a fold with return type (vecs, [vecs]), right? http://sprunge.us/aGZN
08:16:29 <aspidites> fizruk: not quite http://elinks.or.cz/
08:16:37 <ij> Any other way I could implement it?
08:16:37 <quchen> merijn: So "mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)" gives me a pointer to k with a certain value v. If k is GC'd, v becomes unavailable, and the finalizer is run?
08:16:44 <aspidites> i will say that the API for threepenny is pretty nice
08:16:53 <aspidites> yay for pure haskell implementations, huh?
08:18:00 <merijn> quchen: No, 'k' *is* the weak pointer to a value 'v'
08:18:13 <merijn> quchen: Which is, when you try to use 'k' it may find that 'v' has already been GCed
08:18:47 <merijn> quchen: Oh, no, you're right
08:19:21 <quchen> I'm assuming in most cases v = k anyway
08:19:32 <merijn> quchen: Normally you'd just use it as "mkWeak :: v -> v -> Maybe (IO ()) -> IO (Weak v)"
08:20:01 <carter> @tell sonarpulse you might wanna file a ticket on the github issues for llvm-general
08:20:02 <lambdabot> Consider it noted.
08:20:37 <quchen> merijn: Right, the API exposes that. I guess the "mkWeak" is more barebones than the actual workhorse "mkWeakPtr" in that module.
08:22:05 <quchen> merijn: So to be clear, do { thread <- async (...); addFinalizer thread (cancel thread); (...) } would cancel my async when 'thread' is GC'd (plus some lag maybe)?
08:22:08 <NickHu> Hi, I'm trying to use Gtk's haskell bindings, but I can't seem to find a function that will take a widget name (String) and give me a widget matching it
08:22:33 <quchen> merijn: I'm trying the socratic method on myself here by the way ;-) I just feel like getting a detail wrong here can cause major headaches later
08:23:42 <NickHu> Am I perhaps just going about this the wrong way? I recall feintly in other languages you could set a name for a widget and then get a reference back to it that way
08:24:21 <fizruk> > let rotate y x = x + y in take 10 (iterate (rotate 2) 1) -- ij
08:24:22 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
08:24:52 <aspidites> NickHu: does (<-) within a monad not do what you want?
08:25:12 <aspidites> eg: window <- windowNew
08:26:08 <NickHu> aspidites: No I think you are misunderstanding me
08:26:11 <aspidites> use set to modify properties
08:26:18 <NickHu> I already have a widget but I need to modify it externally
08:26:25 <merijn> quchen: Well, I'm not sure the GC of the *threadid* is delayed until the thread is finished
08:26:42 <merijn> quchen: Does async not expose a finalizer option?
08:26:55 <merijn> Or can't you just lift the finalizer into a bracket insize async?
08:26:55 <aspidites> set <object> [property := value]
08:27:16 <quchen> merijn: I think I've heard that it does not because it also exposes accessors to its internals, and finalizers could cause friction with that.
08:27:31 <merijn> quchen: Bracket should still work?
08:27:44 <merijn> async terminates via async exceptions, afaik
08:28:04 <merijn> And bracket/finally should be save in that context
08:28:05 <quchen> merijn: Not for my use case. I'm running a server loop basically, so the fork site doesn't wait for the thread to finish.
08:28:23 <merijn> quchen: So?
08:28:25 <quchen> (withAsync is basically "bracket for Async", I'm using that a lot, but not here)
08:29:11 <merijn> quchen: Wait, what the hell is "addFinalizer thread (cancel thread)" supposed to do?
08:29:25 <merijn> Cancel the thread when thread is GCed?
08:29:28 <NickHu> aspidites: I'm writing a handler to modify a widget in place, but I need to get a handle on said widget and the only way I can think of doing that is by a name set by widgetSetName
08:29:38 <quchen> merijn: Hmm. Yeah good point actually. :-s
08:29:48 <merijn> quchen: Anyway, gonna run to the gym
08:30:00 <quchen> merijn: Alright, thanks for your help!
08:31:45 <aspidites> NickHu: ah. not really familiar with the gtk2hs api. perhaps see if there is something in this Monad.Reader article? -> http://www.haskell.org/wikiupload/9/9d/TMR-Issue1.pdf
08:32:42 <aspidites> or actually if you're using glade, xmlGetWidget would get you a handle to the widget
08:33:23 <klrr_> git needs an --undo flag xD
08:35:43 <AlainODea> Can doctests be run to stop on the first failure? (my cursory reivew of its source suggests otherwise)
08:36:17 <aspidites> rwh has a few hints as well, NickHu -> http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.htmlhttp://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
08:37:40 <NickHu> I tried searching for String -> IO (Maybe Widget) but couldn't find anything, and I did look at rwh but it only seems to mention Glade in this respect
08:42:46 <aspidites> NickHu: do you not know of the widget's existence ahead of time? seems to me you could write a handler function and hook it up in your main function with buttonPressed
08:44:43 <brrrrrrian> hello
08:44:44 <NickHu> aspidites: Possibly, but I may just be using the wrong kind of widget to begin with so I've decided to pursue a different route
08:46:57 <brrrrrrian> I am trying to better understand Monads.  One question I have is why would you ever use a RWS Monad?  I am thinking... if you need a R monad and also a W monad... why not just use a S monad?
08:48:18 <monochrom> R on one thing and W on a different thing
08:48:46 <monochrom> plus, the W part is "append" all the way through, not any arbitrary write
08:49:14 <quchen> brrrrrrian: You can use State to make your own Writer and Reader monads. However there's no guarantee that you won't ever modify the "Reader" environment if you do that. RWS is similar: the user is guaranteed nothing is read from the Writer and nothing is written to the Reader.
08:49:30 <monochrom> well, see, it's English, sometimes "write" means arbitrary modification, sometimes "write" just means "append". so much for meaningful names.
08:50:11 <quchen> libraries@haskell.org "rename Writer to Appendix"
08:50:26 <quchen> Well, Mappendix at least.
08:51:37 <tarmil> "mappendix" sounds like some kind of indexed mappend.
08:52:05 <FreeFull> mappendix sounds like a monadic organ
08:52:07 <kadoban> brrrrrrian: As I understand: you can use the different parts for different purposes.  Recently I was making an interpreter for a language, R was for the environment, W for logging (like a debug trace of the program execution), S for the running program state (like variables).  I didn't actually use RWS, but basically the same thing, only learned about RWS after.
08:53:50 <spaceships> i saw a cool use of Reader for error tracking in a programming language - each call could log itself using local, and when it returns, it pops its log off the stack. so if things blow up you can print the Reader for a trace.
08:54:04 <brrrrrrian> So RWS just has 'stronger' functionality... i.e. if you just use S you can't specify that some things are 'read only' that would otherwise be in the R ...?
08:54:51 <brrrrrrian> I didn't know W was append only... I need to study these more.  This was just a basic question that popped into my head.  I guess I would've understood it if I thouroughly understood all 3 monads
08:55:21 <monochrom> yeah, you need to study actual behaviours and distrust names.
08:55:48 <jle`> vlads: for example, you can point-free (\x y -> f (g x y)) as (f .) . g, which is kinda ugly; or you can keep one point (the y) and do (\y -> f . g x), which is less ugly and perhaps a useful compromise depending on your situation
08:56:06 <quchen> brrrrrrian: Note that Writer is *monoid append" only. Writer can also work by prepending (that's what the Dual monoid does, for example).
08:56:06 <jle`> smiller2: it's not as simple as that, unfortunately
08:56:50 <monochrom> just two weeks ago someone asked "why is (n `elem` mylist) not working?"
08:57:28 <monochrom> it turns out that he/she thought that (n `elem` mylist) meant: does mylist have length n. as oppose to: does n occur in mylist.
08:57:43 <jle`> smiller2: but, yes, you can write wires that take two wires and create a "parallel" wire evaluator
08:58:19 <jle`> oh he left as i was typing the next message
08:58:29 <monochrom> rule #0: distrust "meaningful" names. rule #1: distrust people's ability to interpret "meaningful" names. rule #2: simply, distrust people.
08:58:35 <jamiehannaford> How would I convert 12345 to [1,2,3,4,5] ?
08:59:03 <jle`> smiller2: well, if you are reading this on the logs, that kind of wire might not be useful, as it would have to re-fork every frame for every single tick
08:59:06 <jamiehannaford> tried doing a show, but not sure if that's right
08:59:32 <vanila> > map (read . return) . show $ 12345 :: [Int]
08:59:34 <lambdabot>  [1,2,3,4,5]
08:59:36 <quchen> > (12345 `quot` 10, 12345 `rem` 10) -- hint, jamiehannaford
08:59:37 <brrrrrrian> rule #3 typeclassopedia, typeclassopedia, typeclassopedia.  rule #4 read the types
08:59:38 <lambdabot>  (1234,5)
08:59:59 <ij> fizruk, Thanks, looks nice!
09:00:15 <quchen> vanila: No, that's not how you convert that. Boo.
09:00:52 <monochrom> typeclassopedia is good
09:04:07 <ReinH> monochrom: pretty sure rule 2 should be rule 0...
09:04:51 <jamiehannaford> quchen how does dividing by 10 help? It needs to be returned as [Integer]
09:05:37 <monochrom> dividing by 10 once gives you one digit. you are to add your own recursion to get more digits.
09:06:14 <quchen> jamiehannaford: Note how my formula above split off the least significant digit from 12345 from the rest, giving me (1234, 5).
09:06:52 <jamiehannaford> quchen ah okay :)
09:07:07 <monochrom> what I don't understand is that when you saw (1234, 5) you didn't notice that 5 is useful.
09:07:19 <monochrom> perhaps you thought that "hint" meant "complete solution"
09:08:35 * hackagebot buildwrapper 0.8.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.2 (JeanPhilippeMoresmau)
09:11:59 <bennofs> is it possible to change the maximum history size of GHCi?
09:13:15 <monochrom> that may be a haskeline setting
09:13:36 * hackagebot hsexif 0.5.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.5.0.0 (EmmanuelTouzery)
09:13:52 <bennofs> monochrom: yeah, should have googled first: http://stackoverflow.com/questions/20133443/how-to-configure-amount-of-command-history-saved-by-ghci
09:14:20 <monochrom> then again, I still don't know how to set haskeline settings!
09:14:38 <bennofs> monochrom: ~/.haskeline
09:16:03 <vlads> how can I rule out the (0 /=) part not to repeat it in `(||) <$> (0 /=) . snd <$> (0 /=) . fst' ?
09:16:31 <smiller2> jle`: (Sorry for disconnecting; my wifi tends to bum out at inconvenient times.)
09:16:41 <smiller2> < jle`> smiller2: well, if you are reading this on the logs, that kind of wire might not be useful, as it would have to re-fork every frame for every single tick — The sort of architecture I have in mind is of, to use my previous description as a concrete example, creating a thread for the physical state of the world, a thread for the renderer, using the last output from others; one could step more frequently than the other.
09:16:47 <monochrom> @type (||) <$> (0 /=) . snd <$> (0 /=) . fst
09:16:48 <lambdabot>     Couldn't match type ‘(a0, b0)’ with ‘Bool’
09:16:48 <lambdabot>     Expected type: (b, b1) -> (a0, b0)
09:16:48 <lambdabot>       Actual type: (b, b1) -> Bool
09:17:04 <vlads> oh, second is <*>
09:17:09 <jamiehannaford> i did it!
09:17:11 <monochrom> @type (||) <$> (0 /=) . snd <*> (0 /=) . fst
09:17:12 <lambdabot> (Num b1, Num b, Eq b1, Eq b) => (b, b1) -> Bool
09:17:21 <jamiehannaford> toDigits i
09:17:21 <jamiehannaford>     | i < 10 = [i]
09:17:21 <jamiehannaford>     | otherwise = toDigits (i `quot` 10) ++ [(i `rem` 10)]
09:17:38 <jamiehannaford> anyway i can improve that?
09:17:40 <monochrom> \(x,y) -> 0/=x || 0/=y
09:17:46 <vlads> jamiehannaford: congrats
09:18:24 <vlads> monochrom: that's the repeat isn't it? ;)
09:18:43 <monochrom> it is simpler
09:19:19 <vlads> jamiehannaford: anyway now that you have come up with solution, I can show what I come up with
09:19:30 <monochrom> let n = (0/=) in \(x,y) -> n x || n y.  let n = (0 /=) in (||) <$> n . snd <*> n . fst
09:20:24 <monochrom> let o = (\u v -> 0 /= u || 0 /= v) in o <$> snd <*> fst
09:20:32 <klrr_> anyone have an example emacs config for haskell-mode i can look at?
09:21:14 <bergmark> klrr_: there's one shipped with haskell-mode
09:21:48 <jamiehannaford> vlads sure okay
09:22:02 <kadodka> finally
09:22:39 <vlads> > reverse . map snd . takeWhile (\(a,b) -> a /= 0 || b /= 0) . drop 1 . iterate (\(a,b) -> (a `quot` 10, a `rem 10)) . flip (,) 0 $ 12345
09:22:42 <lambdabot>  <hint>:1:111: parse error on input ‘10’
09:22:56 <vlads> > reverse . map snd . takeWhile (\(a,b) -> a /= 0 || b /= 0) . drop 1 . iterate (\(a,b) -> (a `quot` 10, a `rem` 10)) . flip (,) 0 $ 12345
09:22:58 <lambdabot>  [1,2,3,4,5]
09:23:23 <vlads> not so nice, but in one line
09:23:29 <jamiehannaford> is lambdabot a validator or something?
09:23:31 <jamiehannaford> awesome
09:23:47 <jamiehannaford> thanks vlads
09:24:23 <kadodka> > reverse "test"
09:24:24 <lambdabot>  "tset"
09:24:27 <quchen> > reverse . map (`rem` 10) . takeWhile (/= 0) . iterate (`quot` 10) $ 12345
09:24:29 <lambdabot>  [1,2,3,4,5]
09:24:48 <vlads> quchen: what if it's 123045
09:25:24 <quchen> > reverse . map (`rem` 10) . takeWhile (/= 0) . iterate (`quot` 10) $ 123045
09:25:26 <lambdabot>  [1,2,3,0,4,5]
09:25:40 <vlads> quchen: ah, got it! I didn't think about simpler solution
09:25:44 <quchen> Won't work with a terminating zero though ;-)
09:25:56 <quchen> Oh wait it does, nevermind.
09:25:59 <vlads> > reverse . map snd . takeWhile (\(a,b) -> a /= 0 || b /= 0) . drop 1 . iterate (\(a,b) -> (a `quot` 10, a `rem` 10)) . flip (,) 0 $ 10
09:26:00 <lambdabot>  [1,0]
09:26:04 <vlads> wow
09:26:17 <quchen> But anyway, I think an unfold is a nicer solution here, and less hacky.
09:26:52 <quchen> > unfoldr (\n -> if n <= 0 then Nothing else let (q,r) = quotRem n 10 in Just (r, q)) 12345
09:26:53 <lambdabot>  [5,4,3,2,1]
09:27:11 <aspidites> and shorter
09:27:15 <quchen> +reverse. Split over a couple of lines that makes the intent a lot clearer than the other examples.
09:27:55 <quchen> aspidites: Brevity isn't a very good measure for code quality alone.
09:28:00 <quchen> > reverse$unfoldr(\n->swap(n`quotRem`10)<$guard(n>0)) 12345
09:28:02 <lambdabot>  [1,2,3,4,5]
09:28:02 <aspidites> for some reason the fold version reads like engish to me
09:28:36 <aspidites> quchen: true, but it does mean that there is less for me to process as i read it
09:29:15 <triliyn> Not if you make the code shorter by using more complicated functions
09:29:41 <vlads> :t <$
09:29:42 <lambdabot> parse error on input ‘<$’
09:29:51 <alpounet> :t (<$)
09:29:51 <vlads> :t (<$)
09:29:52 <monochrom> try (<$)
09:29:52 <lambdabot> Functor f => a -> f b -> f a
09:29:52 <lambdabot> Functor f => a -> f b -> f a
09:29:59 <hoverbear> How can I fix this issue when installing `haste-compiler`? https://gist.github.com/2cf2250f146c06b46443
09:30:13 <monochrom> I don't use <$ often
09:30:51 <quchen> (x <$ guard p) can be used as  (if p then Just x else Nothing) if you dare.
09:30:58 <aspidites> isn't that something is less complicated than the functions from which it is composed implicit?
09:31:11 <vlads> quchen: althouhg I would admit, you version reads much easier, but I would not even come up with using of <$ and guard
09:31:28 <aspidites> that  the definition of foldl is more complicated than foldl itself is granted
09:31:49 <quchen> The <$ thing is unobvious until you know about it. From that moment on you wish "<$ guard" came with a nicer name so you could always use it ;-)
09:32:28 <aspidites> so i'm not sure that a counter argument for what i stated (which mind you, never claimed that you should always prefer brevity) is to say that brevity shouldn't be preferred if it is more complicated than the resulting code
09:34:31 <aspidites> at any rate, i was using shorter to mean less transformations and constructs, rather than simply character count
09:34:35 <monochrom> so don't argue.
09:34:48 <pranz> it's the same as "x >> guard p", right?
09:35:07 <pranz> *with >> flipped
09:35:13 <pranz> or no, need a return too
09:35:15 <aspidites> monochrom: what is that supposed to mean?
09:35:31 <monochrom> don't argue what is simpler
09:37:23 <aspidites> um...i didn't.
09:38:12 <monochrom> I saw the words "counter argument". did I misread?
09:44:29 <hunt> guys
09:44:34 <hunt> i fucked with my cabal
09:44:36 <hunt> and it broke
09:44:39 <hunt> so what i did
09:44:46 <hunt> was copy a working .cabal from my friernds account
09:44:48 <hunt> on the same server
09:44:58 <hunt> but all the system libs are broken for me
09:45:01 <hunt> and i dont know why
09:45:05 <hunt> hellllp
09:46:08 <monochrom> you need to copy a working .ghc from your friend, too
09:46:26 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml . begin now.
09:47:15 <hunt> thanks monochrom weve been tryign to fix this for like hours
09:47:54 <Maior> monochrom: looks awesome
09:49:36 <AlainODea> hoverbear: https://github.com/valderman/haste-compiler/issues/141
09:49:49 <AlainODea> hoverbear: it should work with GHC 7.6.3
09:50:06 <hoverbear> AlainODea: Oh, okay, I see.
09:50:59 <AlainODea> hoverbear: very non-obvious and deep.  You could cabal install it from source. I'm happy to assist if you want :)
09:52:18 <hunt> why would i have cabal-install 1.20.0.1 but be using cabal 1.20.0.0?
09:54:13 <monochrom> PATH
09:54:54 <AlainODea> hunt: ~/.cabal/bin should be in your PATH to avoid that
09:55:57 <hoverbear> AlainODea: I appreciate the offer, but this weekend I went through the annoyance of installing haskell and cabal from source to try to improve things. I haven't had a good experience working with `cabal` yet, even using the sandbox feature. I think I might just put it down for a bit. I'd rather deal with Javascript's quirks at this point.
09:56:22 <hoverbear> AlainODea: Thanks for making me aware of the issue. I'll keep it bookmarked.
09:57:19 <AlainODea> hoverbear: cabal is similar to npm if you are a Node.js user. Installing haste-compiler would be running cabal install in a git clone
09:58:31 <AlainODea> hoverbear: source install is a very rough starting point. I did the same years ago and got discouraged. We're here to help when you're ready to dive in again :)
09:59:16 <hoverbear> AlainODea: `cabal` is nothing like `npm` from my perspective. `npm` installs things in the local directory. `npm` installs things with all of their dependencies in their directories so they can't overlap and conflict. `npm` makes it very easy to install and remove packages via a simple command. I spent a glorious amount of time trying to just figure out how to uninstall something from cabal and the almost universal answer was "just remove
09:59:17 <hoverbear>  .ghc" :(
10:00:11 <Maior> hoverbear: possibly "cabal + sandboxes"
10:00:38 <hoverbear> Maior: I must have been doing something wrong, I made a cabal sandbox but it still installed everything to `.ghc`
10:00:56 <AlainODea> hoverbear: uninstall definitely a sharp edge on Cabal. Sandboxes help a lot. http://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
10:03:04 <AlainODea> hoverbear: odd.  It should have installed into ./.cabal-sandbox
10:03:09 <hoverbear> AlainODea: Well first I installed Haskell Platform from homebrew, and got chastised for using the homebrew packages because they're "all wrong", which reminds me very much of when I installed haskell on Arch and was told (again) I was "doing it wrong". And I was told Haskell-Platform is not a good choice either for some reason that's beyond me, even though it's what the wiki blatantly recommends. So I finally broke down and did it the
10:03:09 <hoverbear>  "right way" and things seem better, but still all I really want to do at this point is play with Haste.
10:03:18 <hoverbear> AlainODea: Yeah, I must have been doing something wrong.
10:04:43 <ReinH> hoverbear: the issue with OS packages is that they tend to be wildly out of date and the Haskell community has no control over this.
10:04:58 <AlainODea> hoverbear: opinions are like... well it's not polite to say. Haskell Platform works for me. It is intended as a batteries included distro. Some have issues which are likely immaterial to newcomers
10:05:15 <hoverbear> ReinH: And I understand that
10:05:28 <shapr> I would like to have ghc 7.8 on debian/unstable
10:05:30 <ReinH> hoverbear: The Platform can be difficult to use (dependency resolution issues, etc) but it's a reasonable option for a new Haskeller imo.
10:06:03 <ReinH> bitemyapp: has a pretty good intro to using Haskell w/o Haskell Platform
10:06:19 <hoverbear> Haskell isn't my problem. cabal is my problem.
10:07:55 <ReinH> hoverbear: I'm not a big fan of telling people, especially newbies, that they're "doing it wrong", so sorry about that
10:08:30 <hoverbear> ReinH: ;) The IRC channel for Haskell is awesome, one of my big draws.
10:08:34 <ReinH> hoverbear: that makes it sound like the problem is with you and not with OS packages, Haskell Platform, cabal, etc. :(
10:08:58 <hoverbear> ReinH: It might be I'm spoiled. Hahaha.
10:09:07 <ReinH> hoverbear: cabal definitely has issues, but there are ways to work around them. sandboxing helps.
10:09:31 <hoverbear> A lot of my fvrustration has been not being able to build haste, but given that it won't compile on this version of haskell it's moot.
10:10:14 <AlainODea> hoverbear: you want haste-compiler, you are running GHC 7.8.2 installed from source. haste-compiler hasn't released yet. The rev in haste-compiler.cabal is 0.2.99 (which is in Hackage), but the actual code has changed since the last uprev
10:11:07 <AlainODea> hoverbear: git clone https://github.com/valderman/haste-compiler.git && cd haste-compiler && cabal configure && cabal build && cabal install
10:11:15 <AlainODea> I think that will work
10:11:22 <hoverbear> AlainODea: I'll try this. :)
10:12:08 <ReinH> I'm not sure how many packages are working with 7.8.2 at this point or whether you would be better off downgrading to 7.6 as I haven't updated yet.
10:12:25 <AlainODea> I'm trying it as well, I already missing cabal install --only-dependencies before cabal install
10:13:25 <AlainODea> ReinH: +1. 7.6.3 is a safer bet for now and is included with Haskell Platform 2013.2.0.0. http://www.haskell.org/platform/mac.html
10:13:41 <hoverbear> Holyshit it ran.
10:13:45 * hackagebot apiary 0.3.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.3.0.0 (HirotomoMoriwaki)
10:13:48 <ReinH> AlainODea: That's what I figured.
10:13:49 <hoverbear> AlainODea: You are an hero.
10:14:22 <AlainODea> hoverbear: my pleasrure :)
10:14:23 <hoverbear> AlainODea: Spoke too soon, haste-boot fails. Ugh
10:14:38 <AlainODea> LOL :) ugh :'(
10:15:10 <AlainODea> hoverbear: you're on a Mac right?
10:15:19 <hoverbear> https://gist.github.com/Hoverbear/0575fbaf6193824a1a6a
10:15:31 <hoverbear> AlainODea: Unfortunately.
10:18:09 <AlainODea> hoverbear: on the bright side. The OS X package of Haskell Platform will likely work and it has a great deal of useful stuff precompiled
10:18:20 <hoverbear> AlainODea: Does it include haste?
10:18:28 <AlainODea> Let me check
10:18:44 <hoverbear> I don't think it does, it wasn't there when I had platform installs
10:19:50 <hoverbear> Doesn't seem to
10:20:03 <AlainODea> Oh well. The contents are specified by Cabal and haste/haste-compiler aren't there. https://github.com/haskell/haskell-platform/blob/2013.2.0.0/haskell-platform.cabal
10:20:26 <AlainODea> However, many of their dependencies are
10:21:48 <hoverbear> Oh well. Maybe I'll try 7.6 this weekend.
10:22:53 <AlainODea> hoverbear: good idea :) Take a break from it and come back fresh.
10:23:02 <a3gis> @pl sum (zipWith (*) xs ys)
10:23:02 <lambdabot> sum (zipWith (*) xs ys)
10:23:06 <hoverbear> AlainODea: :)
10:24:06 <a3gis> @pl \xs ys -> sum (zipWith (*) xs ys)
10:24:06 <lambdabot> (sum .) . zipWith (*)
10:29:12 <yitz> > ((.).(.)) sum (zipWith (*)) [1,2,3] [10,20,30] -- a3gis you can use "owl eyes"
10:29:13 <lambdabot>  140
10:29:29 <harlanhaskins> @src unwords
10:29:29 <lambdabot> unwords [] = ""
10:29:29 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
10:29:30 <a3gis> yitz: oh god my brain
10:29:39 <harlanhaskins> @pl foldr1 (\w s -> w ++ ' ':s) ws
10:29:39 <lambdabot> foldr1 ((. (' ' :)) . (++)) ws
10:29:44 <yitz> @type ((.).(.))
10:29:44 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:30:05 <a3gis> thanks for the tip :)
10:30:05 <yitz> a3gis: but yeah, most people don't in real code :)
10:30:18 <pranz> > let (.:) = (.).(.)
10:30:19 <lambdabot>  not an expression: ‘let (.:) = (.).(.)’
10:30:26 <pranz> @define (.:) = (.).(.)
10:30:28 <lambdabot>  Defined.
10:30:38 <pranz> sqrt .: (*) $ 2 3
10:30:45 <pranz> > sqrt .: (*) $ 2 3
10:30:47 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> s))
10:30:47 <lambdabot>    arising from the ambiguity check for ‘e_123’
10:30:47 <lambdabot>  from the context (GHC.Num.Num (a -> s),
10:30:47 <lambdabot>                    GHC.Num.Num a,
10:30:47 <lambdabot>                    GHC.Float.Floating s)
10:31:23 <pranz> > (sqrt .: (*)) 2 3
10:31:25 <lambdabot>  2.449489742783178
10:31:54 <a3gis> > (sqrt .: (*)) 2 8
10:31:55 <pranz> :t sum .: zipWith (*)
10:31:55 <lambdabot>  4.0
10:31:56 <lambdabot> Num c => [c] -> [c] -> c
10:32:22 <jamiehannaford> I can figure out how to turn 123 to [1,2,3] - but how do you turn [1,20,3] to [1,2,0,3] ?
10:32:54 <pranz> jamiehannaford: if you have a function f : Int -> [Int]
10:33:00 <yitz> jamiehannaford: concatMap (toRadix 10)
10:33:07 <pranz> just map that over a list [Int] and then concat
10:33:25 <jamiehannaford> okay - i'll try concat
10:33:29 <pranz> or, shorthand: xs >>= f
10:33:38 <yitz> pranz: concatMap
10:33:40 <a3gis> >  concatMap (map digitToInt . show) [1,20,3]
10:33:41 <lambdabot>  [1,2,0,3]
10:33:47 * hackagebot lensref 0.1 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1 (PeterDivianszky)
10:36:43 <jamiehannaford> pranz yitz I did: sumDigits x = concat . map toDigits $ x
10:36:49 <yitz> a3gis: owl eyes can also be written (.)(.)(.)
10:37:04 <jamiehannaford> thanks!
10:37:08 <pranz> or fmap fmap fmap for a more general form
10:37:33 <yitz> a3gis: and since (.) is just fmap for the (->) monad, it can thus also be written fmap fmap fmap
10:38:21 <yitz> > fmap fmap fmap sum (zipWith (*)) [1,2,3] [10,20,30] -- a3gis "owl eyes" as 3 fmaps
10:38:23 <lambdabot>  140
10:38:47 * hackagebot lensref 0.1.0.1 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1.0.1 (PeterDivianszky)
10:39:00 <yitz> a3gis: which leads to the even more mind-bending question of what happens when you combine more and more fmaps like that. does it get more and more complex?
10:39:15 <a3gis> yitz: I love how I always blow my mind when I come on this chan
10:39:19 <a3gis> thanks :p
10:39:26 <yitz> a3gis: and the answer is no, due to this rather surprising identity:
10:39:45 <yitz> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap == fmap fmap fmap fmap fmap fmap
10:40:05 <yitz> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:40:06 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
10:40:14 <pranz> :t extract
10:40:14 <lambdabot> Not in scope: ‘extract’
10:40:16 <yitz> @type fmap fmap fmap fmap fmap fmap
10:40:17 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
10:40:33 <pranz> @hoogle Comonad w => w a -> a
10:40:35 <lambdabot> Warning: Unknown class Comonad
10:40:35 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
10:40:35 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
10:42:12 <pranz> I like how (fmap <*> fmap) turns an algebra of f a into an algebra of (f.f) a
10:42:16 <pranz> :t fmap <*> fmap
10:42:17 <lambdabot> Functor f => (f b -> b) -> f (f b) -> b
10:43:15 <jophish> yitz: ! at the fmap identity, is that the smallest sequence of fmap which reduce like that?
10:43:22 <yitz> jophish: yes
10:43:28 <jophish> amazing!
10:43:43 <jophish> This is going on the facebook
10:43:48 * hackagebot lensref 0.1.0.2 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1.0.2 (PeterDivianszky)
10:44:10 <jophish> yitz: do you know who first thought of that?
10:44:30 <yitz> jophish: yes i was amazed too. and then some glazy-eyed category theory person said, oh, of course, that's because <mumble mumble mumble>.
10:45:30 <yitz> jophish: no. likely haskell curry though. (.) is known as the B combinator in curry's combinator calculus, and he spent almost his entire life studying sequences of such things.
10:46:07 <jophish> yitz: time to do some investigating. Thanks!
10:46:09 <yitz> jophish: i just happened upon it one day.
10:53:49 * hackagebot apiary 0.3.1.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.3.1.0 (HirotomoMoriwaki)
10:57:19 <mm_freak_> hi there
10:57:51 <mm_freak_> any libraries that allow me to quick-and-dirty-plot a Double-valued function's graph?  ASCII is sufficient
10:59:27 <bitemyapp> hoverbear: hey
10:59:36 <hoverbear> Hey!
10:59:41 <bitemyapp> hoverbear: your Cabal problems might be because Haskell Platform installs a bunch of default versions and stuff
10:59:50 <bitemyapp> hoverbear: so, you can tell Cabal to ignore the global packgage db
10:59:54 <hoverbear> bitemyapp: I didn't install the Haskell-Platform
11:00:05 <bitemyapp> hoverbear: okay, cool. Do you have an lpaste of the build error?
11:00:19 <hoverbear> bitemyapp: We solved it. :) Thanks so much though.
11:00:26 <bitemyapp> hoverbear: cool! my guide is here: https://gist.github.com/bitemyapp/8739525
11:00:47 <bitemyapp> hoverbear: included is an excellent FAQ by Diehl on all kinds of stuff including Cabal.
11:00:52 <carter> bitemyapp: he used my direcitons
11:00:53 <bitemyapp> ReinH: will I see you at BayHac?
11:00:55 <hoverbear> Cool!
11:00:57 <bitemyapp> carter: which are?
11:01:01 <ReinH> bitemyapp: yup!
11:01:02 <carter> you know what they are
11:01:05 <joelteon> ooh, bayhac is this weekend, isn't it?
11:01:07 <bitemyapp> sorry, I'm missing context, just got back from brunch.
11:01:09 <hoverbear> bitemyapp: Install binary haskell, install cabal.
11:01:09 <bitemyapp> joelteon: yep!
11:01:13 <joelteon> how exciting
11:01:18 <carter> hoverbear: :)
11:01:20 <bitemyapp> hoverbear: oh, you were on platform before?
11:01:24 <ReinH> joelteon: yup!
11:01:29 <bitemyapp> joelteon: you coming?
11:01:32 <hoverbear> bitemyapp: I `brew install haskell-platform`ed
11:01:33 <joelteon> yes
11:02:27 <bitemyapp> joelteon: excellent!
11:02:37 <bitemyapp> hoverbear: okay, so carter had you do exactly what I would've had you do then :)
11:02:47 <carter> bitemyapp: more exactly what i'd do :)
11:03:00 <bitemyapp> carter: binary install of each is what I tell people to do.
11:03:06 <carter> "whois powerhaskell.com"
11:03:07 <carter> :)
11:03:08 <carter> yay
11:03:44 <carter> bitemyapp: i have the perfect url for my directions now :)
11:03:56 <carter> mwahahahah
11:03:56 <bitemyapp> carter: I need to turn my guide/gist into a website.
11:04:16 <carter> reallylearnhaskell.president.io
11:04:22 <carter> or something
11:04:28 <bitemyapp> president.io? lolwut
11:04:30 <carter> reallylearnhaskell.president.io.ly
11:04:41 <carter> i'm making up a candidate url
11:05:00 <carter> i think theres a .president / .ceo TLD now
11:05:33 <hoverbear> There is a .coffee
11:05:51 <carter> yumm
11:06:59 <pussy-magnet> how do I do something like (*args) in python?
11:07:14 <bitemyapp> pussy-magnet: functions in Haskell take one argument and return one result.
11:07:30 <bitemyapp> pussy-magnet: accept a list of arguments if you must, but it's very bad style to inject unnecessary non-determinism into your API.
11:07:36 <steshaw> .io is for hipsters ;)
11:07:45 <bitemyapp> steshaw: sucks to your hipsters.
11:07:51 <steshaw> :)
11:07:52 <pussy-magnet> let args = ["foo", "bar"]; data Args = Args { foo :: String, bar :: String } ; magicArgsFromStringList(args)
11:08:04 <carter> steshaw: its also wayyy priceee
11:08:07 <yac> how do I do magic ^ ? )
11:08:12 <steshaw> yeah, very pricey
11:08:28 <monochrom> use a magic bag to do magic
11:08:36 <steshaw> bitemyapp: you have a Hakyll based homepage/blog don't you?
11:08:38 <bennofs> yac: how could the compiler check at compile time that length args == 2 ?
11:08:46 <steshaw> bitemyapp: just stick it up there?
11:09:03 <yac> bennofs: I don't know. I could retype it into dependent type if it is in haskell?
11:09:24 <bitemyapp> steshaw: Aye, I do.
11:09:33 <carter> steshaw: nah, he should have a 1 page webdomain with a pandoc generated single file
11:09:40 <steshaw> Sure
11:09:40 <carter> 'cause... thats what people do today right
11:09:47 <steshaw> yep
11:09:52 <bitemyapp> steshaw: and I link to the gist from it, but I kinda want a Get started with Haskell content site that's independent of my personal brand and site theme.
11:09:57 <steshaw> how about something about englightenment?
11:10:01 <steshaw> folks like Zen stuff
11:10:04 <bitemyapp> steshaw: you're probably right and I should just add it to my site, but meh.
11:10:13 <steshaw> haskellenlightenment.io ?
11:10:18 <steshaw> sorry, can't spell :)
11:10:20 <bitemyapp> I don't think I'll get another io.
11:10:26 <bitemyapp> I used to, I don't think I will anymore.
11:10:30 <monochrom> carter: I have written about 20 articles at http://www.vex.net/~trebla/haskell/ . should I merge them all into one single page? :)
11:10:36 <carter> m :)
11:10:43 <carter> nah
11:10:52 <carter> also TLDs add up FAST
11:11:01 <carter> i just need to figure out my hosting story
11:11:04 <bitemyapp> monochrom: could I get you to update http://www.vex.net/~trebla/haskell/learn-sources.xhtml ?
11:11:12 <steshaw> If you start a org at Github I think you could have reallylearnhaskell.github.io ?
11:11:13 <carter> and update cstheory.net.... its been languishing for years
11:11:13 <monochrom> what should be updated?
11:11:17 <bitemyapp> monochrom: I don't think LYAH and RWH are good mainline ways to learn Haskell anymore.
11:11:20 <bitemyapp> they're better as references.
11:11:33 <monochrom> what are good mainline ways?
11:11:38 <bitemyapp> monochrom: take a gander at https://gist.github.com/bitemyapp/8739525 and flagrantly steal.
11:11:47 <bitemyapp> don't bother with attribution. Steal steal steal.
11:11:48 <steshaw> I'm thinking path-to-haskell-enlightenment.github.io but shorter and snappier
11:11:56 <bitemyapp> github pages make me cranky.
11:12:07 <steshaw> how come?
11:12:40 <carter> all sorts of CDN issues
11:12:41 <carter> SPOF
11:12:43 <carter> and other things
11:12:47 <bitemyapp> ^^ that
11:13:00 <bitemyapp> I can push my hakyll site to another server from a diff provider in 5 minutes
11:13:09 <bitemyapp> redeploying something designed around github pages is more effort.
11:13:14 <steshaw> I started an Octopress blog a couple of years ago thinking it would be easy to add .md files and blog about stuff. However, Octopress was a bit of a barrier for me as I switched machines etc and lost the correct versions of Ruby etc.
11:13:24 <bitemyapp> I like github for OSS but I don't see a good reason to lean on them for everything.
11:13:26 <carter> thats why cabal versions
11:13:27 <carter> are nice
11:13:32 <carter> UPPER BOUND ALL THE THINGS
11:13:41 <bitemyapp> carter: to be fair, I'm sure people have had trouble installing Hakyll before.
11:13:47 <carter> :))))))))))
11:13:51 <bitemyapp> although, I think he does a good job keeping the Cabal file correct.
11:13:53 <carter> i've been paid to update a friens hakyll
11:13:55 <steshaw> bitemyapp: Sounds fair but it's free ... :-)
11:13:55 <bitemyapp> better than most projects.
11:14:06 <carter> bitemyapp: also you just keep track of what ghc version you built it with
11:14:08 <bitemyapp> steshaw: I have a VPS regardless, it's a non-negotiate expense of $5 per month.
11:14:11 <steshaw> bitemyapp: I'm a cheap skate I'm afraid :)
11:14:12 <tommd> Where in GHC source are the flags to CC decided?
11:14:17 <bitemyapp> steshaw: I use the VPS for IRC.
11:14:27 <bitemyapp> steshaw: so I use it for the site too. $5/mo really registers on your radar?
11:14:29 <carter> tommd: settinsf sile
11:14:33 <carter> tommd: whats you actual question
11:14:33 <bitemyapp> I'm frugal too, but $5 a month is pretty ridic.
11:14:38 <carter> *settings file
11:14:49 <steshaw> bitemyapp: who are you using?
11:14:52 <carter> in /usr/local/lib/ghc-7.8.2/settings
11:14:58 <tommd> carter: It appears GHC and/or cabal has decided passing -O2 to gcc is actually a good idea.  It isn't always a good idea.
11:15:07 <tommd> I would like to fix this regression.
11:15:07 <carter> tommd: what OS
11:15:12 <tommd> carter: Linux
11:15:15 <carter> what GHC
11:15:23 <carter> what cabal file
11:15:26 <tommd> I have recently upgraded from ghc7.6.3 and some cabal (worked fine)
11:15:26 <carter> i bet the cabal file does it
11:15:39 <carter> no
11:15:43 <tommd> carter: to ghc 7.8.1 and cabal 1.18.1.3
11:15:44 <carter> what version are you AT
11:15:46 <carter> ohhh
11:15:48 <tommd> (cabal-install 1.18.0.3)
11:15:51 <carter> 1) don't use .1
11:15:53 <carter> update to .2
11:15:56 <carter> .1 is busted
11:15:56 <carter> hard
11:16:07 <carter> 2) icould it be cabal-install?
11:16:16 <carter> test with cabal-install 1.20 too
11:16:18 <tommd> carter: My mistake, I am runnin g7.8.2
11:16:20 <carter> oh
11:16:28 <carter> tommd: whats the example code
11:16:46 <steshaw> bitemyapp: can you have subdomains easily with Hakyll. It'd suggest:  reallylearnhaskell.bitemyapp.com
11:16:47 <carter> tommd: i dont think ghc passes O2 c code
11:17:00 <tommd> A very large library, if I can't fix the issue myself or properly communicate it then I will make a smaller example.
11:17:00 <bitemyapp> steshaw: not a bad idea.
11:17:07 <steshaw> but carter's right about those "single term/phrase" website doing well
11:17:14 <bitemyapp> steshaw: I could add the subd to nginx and toss the guide into a subdir/diffdir.
11:17:14 <carter> tommd: try -optC -O1
11:17:17 <bitemyapp> steshaw: thanks!
11:17:19 <tommd> carter: OK, that should help.  Something is giving me s gratuitous -O2
11:17:21 <carter> in your ghc-ptions
11:17:28 <carter> also check your ~/.cabal/config
11:17:35 <carter> also run the build with -v2
11:17:39 <carter> at the cabal leve
11:17:56 <carter> ok
11:17:57 <carter> g2g
11:18:12 <carter> steshaw: yup
11:18:14 <carter> less decisions
11:18:24 <steshaw> bitemyapp: that's the nice thing about having more control via VPS. So you can configure nginx :)
11:18:33 <steshaw> bitemyapp: I was thinking of http://youmightnotneedjquery.com/
11:18:41 <carter> tooooo long
11:18:42 <steshaw> bitemyapp: and http://tryidris.org
11:18:43 <carter> ok
11:18:44 <carter>  g3g
11:18:52 * hackagebot lgtk 0.8 - Lens GUI Toolkit  http://hackage.haskell.org/package/lgtk-0.8 (PeterDivianszky)
11:18:59 <carter> steshaw: the page loads are too slow for the jquery one
11:19:02 <bitemyapp> steshaw: youmightnotneedjquery.com is nice.
11:19:16 <bitemyapp> steshaw: I actually had to write an extremely compact payload last year where I was doing all this manually.
11:19:19 <steshaw> bitemyapp: fair comment
11:19:36 <bitemyapp> steshaw: managed to fit the payload into 500 lines of code, manual browser compat. Most pristine JavaScript of my entire life.
11:19:46 <steshaw> bitemyapp: I've never got involved in optimising that kind of thing though
11:19:46 <bitemyapp> I will never write JS that clean and compact ever again, because PureScript exists >:)
11:19:53 <bitemyapp> steshaw: I didn't enjoy it.
11:20:02 <steshaw> bitemyapp: it's a very long page and needs to be loaded lazily...
11:20:20 <bitemyapp> steshaw: the youmightnotneedjquery site?
11:20:27 <steshaw> bitemyapp: In some ways I am hoping that Haste or GHCJS get there
11:20:34 <bitemyapp> Nah.
11:20:42 <bitemyapp> maybe GHCJS eventually
11:20:47 <steshaw> bitemyapp: Partiucarly GHCJS since it is Glorious GHC with all the language extensions
11:20:48 <bitemyapp> but nah. I can't wait for people. purs is here and now.
11:21:11 <bitemyapp> steshaw: part of the problem is I don't think something like the way GHCJS is designed will ever catch up to purescript in compactness because of the way the latter was designed.
11:21:20 <bitemyapp> you start hitting hard information theoretic limitations
11:21:23 <steshaw> bitemyapp: Glorious Glasgow Haskell Compiler == GHC with language extensions galore == GHC++ == Glorious
11:21:31 <bitemyapp> and I work in relatively zero-compromises-allowed situations.
11:22:31 <steshaw> So, Glorious is my code word for Haskell 2010 plus all GHC extensions. I always thought that Glorious Glasgow Haskell Compiler should be GGHC rather than GHC. So the "left over" word "Glorious" makes a great code word :)
11:22:47 <albeit> Is there a recommended Haskell package for MySQL?
11:23:32 <bitemyapp> albeit: don't use mysql in future if you can help it. That said: http://hackage.haskell.org/package/mysql-simple
11:23:52 <bitemyapp> albeit: more library recs here: https://gist.github.com/bitemyapp/7b1b7b8daf79cc3815af
11:23:58 <albeit> bitemyapp: No MySQL? Do you prefer Postgres over it?
11:24:18 <bitemyapp> albeit: at least turn SQL standard strictness on in MySQL and use InnoDB tables :)
11:24:53 <bitemyapp> albeit: if you don't know why one should do that, read up on it and your abject horror will explain why I steer people towards Postgres. It's nothing that can't be mitigated, just saying..
11:25:05 <bitemyapp> albeit: anyway, mysql-simple is a fair way to get rolling in Haskell with MySQL.
11:25:23 <visi0n_> At least use Maria over MySQL I would think. But the mysql bindings should work fine
11:25:40 <bitemyapp> pfah.
11:25:48 <bitemyapp> same people, same mistakes.
11:27:52 <albeit> Great, thanks bitemyapp
11:30:05 <bitemyapp> albeit: cheers.
11:31:56 <monochrom> wait, youmaynotneedjquery loads too slowly because it needs jquery?! :)
11:32:10 <bitemyapp> monochrom: hoisted on its own...point?
11:32:20 <sveit> anyone here coming from a Lisp/Scheme background? that has been my go-to language for a few years, but I decided to learn and do a project in haskell. I generally like Haskell better than Scheme, but sometimes (quite rarely as I learn more) i find myself writing lots of boilerplate that could be handled well by lisp-like macros. Template Haskell seems like a partial solution, but I was wondering if anyone
11:32:21 <sveit> here came from a similar background and how you are "coping" without the features of Lisp? (just to reiterate, I think the features of Haskell make it an excellent language in general, it just seems like the community has figured out most of the warts and perhaps someone with a similar history can enlighten/assure me)
11:32:26 <joe_k> postgres is a symbol of all that's good with the world.
11:32:30 <joe_k> and its really fast and nice
11:32:43 <ryantrinkle> if i want to ensure an object doesn't get GCed, but i don't want to do anything else with it, what's the best way to achieve that?  in particular, i want to make sure the optimizer doesn't say "hey, you don't use this" and blow it away
11:33:07 <monochrom> that depends on why you want to keep it
11:33:37 <bitemyapp> carter: want to Skype into BayHac?
11:34:25 <klrr_> is it difficult to parse C-like syntax with something like attoparsec? ive never written a parser beyond IRC and lisp so wanna know what i get myself into :P
11:34:53 <ryantrinkle> monochrom: basically, it's accessible via FFI, but not through a StablePtr or anything like that (this is in GHCJS)
11:34:58 <geekosaur> C-like should be not too bad, unless in C-like you are including cpp
11:35:15 <monochrom> then you really should use a StablePtr at all costs
11:35:26 <geekosaur> with one glaring caveat if it's more than just C-like: typedefs mutate the parser
11:35:44 <ryantrinkle> monochrom: the difficulty is that i won't ever be able to *free* the StablePtr
11:35:45 <c_wraith> ryantrinkle: in GHCJS, shouldn't that take care of itself?  Doesn't GHCJS just use the JS garbage collector?
11:36:02 <ryantrinkle> c_wraith: no, it has its own, because JS doesn't have weakreferences
11:36:23 <ryantrinkle> it does *also* use the js gc, but the JS gc doesn't give you finalizers
11:36:25 <monochrom> sveit: macro is less needed in haskell because, for example, "f True x _ = x; f False _ y = y" needs a macro in scheme but is a vanilla function in haskell
11:36:27 <c_wraith> Oh, huh.
11:36:34 <ryantrinkle> (hence not being able to free my StablePtrs)
11:36:45 <monochrom> so don't free it ever
11:37:00 <klrr_> geekosaur: okey, well im thinking of parsing quakeC, which is a subset of C so i dont think it will be harder than C itself
11:37:01 <ryantrinkle> monochrom: haha, unfortunately that's the exact memory leak i'm trying to prevent
11:37:19 <ryantrinkle> what i was hoping for was some sort of "touch" function
11:37:26 <sveit> monochrom: that's true, but that's not the only kind of boilerplate that needs to be written
11:37:28 <monochrom> what memory leak? are you saying, you want to keep data, but without taking up memory?
11:38:19 <c_wraith> ryantrinkle: I'd try to rewrite the FFI functions to reallocate what they need on the JS side, so it's no longer the problem of GHCJS's GC
11:38:25 <sveit> monochrom: for example, I have a pattern where I filter/map by pattern matching in a case statement, but pattern matching always needs to be explicitly typed out by hand
11:39:10 <sveit> monochrom: on the other hand, Haskell sometimes doesn't give you a way to get around pattern matching (or writing the equivalent functions out by hand) so this becomes annoying
11:39:16 <skypers> hi
11:39:56 <skuggi> doesn't RWS have a MonadWriter instance?
11:40:10 <c_wraith> skuggi: yes
11:40:22 <c_wraith> skuggi: it'd be very badly named if it didn't
11:42:09 <skuggi> c_wraith: nevermind, i misread the error message.
11:42:11 <monochrom> is it StablePtr or ForeignPtr? because you can touch a ForeignPtr
11:43:09 <skypers> does withArray always imply a dynamic allocation each time it’s called?
11:43:35 <skypers> I have a perspective matrix, I turn it into a list via something like [a,b,c,d…,p]
11:43:59 <skypers> will I have an overhead if I call withArray each frame?
11:44:08 <skypers> or is it put on a stack for the call
11:44:09 <skypers> ?
11:44:52 <activeas_> i vaguely remember a ghci command that will show the contents of an expression to the evaluated thunk. does this sound familiar to anyone?
11:45:15 <geekosaur> in pretty much any question involving a call stack, you can assume it's not applicable to haskell. non-strict evaluation makes call stacks meaningless
11:45:39 <skypers> geekosaur: arf, you’re right…
11:45:46 <skypers> but hm
11:45:58 <skypers> when the withArray function is evaluated
11:46:11 <skypers> what does it really do? does it create the array in C side on the heap?
11:46:15 <skypers> on the stack?
11:46:20 <skypers> if it’s on the stack it’s quite okay
11:46:35 <skypers> on the heap… it could break runtime performances down
11:46:36 <geekosaur> it goes on the heap --- again, on the stack is meaningless --- with a finalizer when it goes out of scope
11:46:38 <monochrom> activeas_: is it :print ?
11:46:54 <geekosaur> activeas_, I'm not quite sure what you're asking, but :print does not force evaluation
11:47:06 <geekosaur> whereas :force will print forcing evaluation
11:47:20 <activeas_> that sounds about right
11:47:21 <geekosaur> as will just asking for the value outright
11:47:42 <skypers> geekosaur: ok, so what could I do?
11:47:46 <skypers> cache the value in a Ptr?
11:48:22 <geekosaur> skypers, nothing. if you;re trying to find some way to force it to live on the stack, you are using the wrong language
11:48:23 <skypers> I thought those functions allocate on the stack in most cases
11:48:37 <skypers> geekosaur: ah
11:48:46 <skypers> so I have to write a C wrapper for that?
11:48:58 <geekosaur> the stack frame ceases to exist immediately because the function immediately returns a closure
11:49:18 <geekosaur> allocations *must* live in the heap
11:49:31 <skypers> geekosaur: in my case I don’t need allocation
11:49:38 <skypers> I need to give a value an adress
11:49:44 <activeas_> geekosaur: i think its :sprint
11:49:45 <geekosaur> (and the evaluation stack / pattern match stack does not have frames you can peg an allocation to)
11:49:56 <skypers> in C, you can simply do this :
11:49:59 <monochrom> skypers: also since GHC's heap and GC can pull very different tricks from typical C's heap, "heap has performance issues" also needs to be doubted
11:49:59 <skypers> int a = 43;
11:50:06 <skypers> and pass a to the function that expects a pointer
11:50:18 <skypers> monochrom: oh?
11:50:22 <skypers> interesting
11:50:23 <geekosaur> so write it in C if you must absolutely put stuff on the stack
11:50:36 <skypers> I think I’ll just write it in Haskell
11:50:37 <skypers> profile
11:50:43 <skypers> and if it’s a bottleneck
11:50:48 <skypers> I’ll go for C
11:50:48 <geekosaur> yes, that;s how every strict language works, so that is apparently how you expect it to always work
11:50:52 <geekosaur> haskell is non-strict
11:51:02 <skypers> I know
11:51:03 <skypers> so then
11:51:04 <geekosaur> your strict-languages expectations do not apply
11:51:09 <skypers> if I put som bangs in there
11:51:15 <skypers> some*
11:51:20 <skypers> would it be on the stack?
11:51:31 <geekosaur> ...
11:51:33 <geekosaur> no
11:51:44 <geekosaur> I give up
11:51:55 <skypers> geekosaur: :(
11:51:56 <geekosaur> keep believing the stack is central to execution, since you are anyway
11:51:57 <skypers> thank you anyway
11:52:12 <skypers> what do you mean by “central to execution”?
11:52:20 <monochrom> skypers, it looks like if you are so nanosecond-sensitive, you need to read GHC source code altogether, and not patch up your current model here and there ad hoc
11:52:34 <geekosaur> I don't know how many times or ways I can say the stack is not useful at all and still have you trying to figure out how to use the stack for allocations (and yes this is allocation)
11:53:05 <bitemyapp> skypers: s'not a tree mate.
11:53:08 <exicer> I want to map a tuple of lens accessors over a list. Is there some in built traversal way of doing this, or should I just go with the map ?
11:53:13 <skypers> geekosaur: sorry for having bothered you then
11:53:22 <bitemyapp> exicer: just use fmap if it works. No need to be fancy.
11:53:32 <bitemyapp> exicer: if it pukes on your shoes with a type error then you know our model of reality is broken.
11:53:36 <bitemyapp> your*
11:53:41 <exicer> Hah, yeah fair enough :p
11:53:43 <monochrom> your current model is completely off. you need to go back to square one like you have never seen any computational model before. the whole world is unmade.
11:55:48 <skypers> monochrom: I don’t really get what you mean there
11:55:49 <skypers> but hm
11:55:53 <skypers> I’ll just leave it that way
11:55:57 <skypers> and benchmark
11:58:00 <monochrom> no, I think you know, you just hope that I'm not saying it, because the consequence is too dire. everything you know about asm generated from typical C compilers, they are inapplicable, all of them. GHC-generated asm does completely different things. relearn from scratch.
12:01:02 <monochrom> I think the last thing a programmer wants to hear is "none of your knowledge can be reused. none."
12:01:53 <monochrom> unfortunately, even outside haskell, because the computer tech field is moving so fast, it is a true statement once in a while.
12:03:50 <monochrom> withArray uses allocaArray0. on the alloca family, GHC User's Guide has this to say: "In GHC, alloca is implemented using MutableByteArray#, so allocation and deallocation are fast: much faster than C's malloc/free, but not quite as fast as stack allocation in C."
12:03:57 * hackagebot tamper 0.3.1.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.1.0 (TobiasDammers)
12:05:13 <monochrom> among all the allocators exposed in the standard and safe API, the alloca family is already the fastest. anything faster, you will be calling up the unsafe guys.
12:08:06 <monochrom> oh haha great, GHC.Prim source code says: newByteArray# = let x = x in x
12:08:27 <monochrom> similarly 90% of the other things there :)
12:08:30 <geekosaur> that's secret code for primitives, yes
12:08:47 <geekosaur> it's a placeholder, the real implementation is part of the runtime
12:08:57 <monochrom> yeah
12:08:57 * hackagebot align 0.1.0.0 - Sequence alignment algorithms.  http://hackage.haskell.org/package/align-0.1.0.0 (literon)
12:12:26 <felixn> anyone have success with using the cocoa api in haskell?  HOC is having all sorts of problems compiling, the last date I see on the project is 2004
12:12:50 <felixn> I just want to move windows around with Cocoa's accessibility API in mac >_<
12:13:58 * hackagebot apiary-cookie 0.3.1.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.3.1.0 (HirotomoMoriwaki)
12:14:44 <felixn> perhaps it's possible to map the parts of Cocoa API I need to C, and do an C FFI import into haskell?
12:21:10 <duke_> Good afternoon. I'm curious if there are any good articles on compiling a program to utilize more than 1 cpu. My google-fu isn't prevailing. I'm using parellel strategies and GHC doesn't seem to want to use more than one core.
12:21:29 <NemesisD> hey folks. i'm trying to figure out how i could use 1 log function log :: String -> m () that could run in a MonadWriter [String] and MonadIO m
12:22:24 <NemesisD> couldn't get a Loggable m typeclass to work without undecideable instances
12:22:41 <pjdelport> duke_: Did you run with the RTS options to enable multiple cores?
12:22:57 <pjdelport> Using parallel strategies won't have any effect without that
12:23:32 <duke_> I'm building via: cabal build --ghc-options="-threaded +RTS -N2"
12:23:58 <monochrom> no, use +RTS -N2 on your executable, not GHC
12:23:59 * hackagebot persistent-mongoDB 1.3.1.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.1.1 (GregWeber)
12:24:11 <pjdelport> duke_: What does running the program with +RTS -sstderr say?
12:24:24 <duke_> I'll give that a try
12:24:58 <duke_> that did it!
12:25:07 <duke_> thanks, silly me putting those args in the wrong place.
12:28:18 <pjdelport> Oh, right... that should be compiling with "-with-rtsopts=-N", right?
12:29:06 <duke_> so if I compile with -with-rtsopts I still need to call +RTS on the bin?
12:30:13 <monochrom> then no
12:30:24 <duke_> I'll give that a go
12:30:58 <monochrom> I mean: if you use -with-rtsopts=... at compile time, then you don't need to say anything at run time, it's already hardcoded in the exe
12:31:22 <duke_> looks good
12:31:44 <monochrom> it's what -with-rtsopts is for. hardcoding something in the exe so you don't have to type it a million times later :)
12:32:22 <duke_> Now witness the firepower of this fully ARMED and OPERATIONAL battle station!
12:32:29 <NemesisD> how dangerous are undecideable instances
12:33:06 <monochrom> why are haskellers so fond of battle stations and launching missiles?!
12:33:24 <supki> NemesisD: they're ok as long as compilation terminates
12:34:05 <NemesisD> supki: i'm wondering if i could do without them with what i'm trying to do
12:34:10 <monochrom> they are not dangerous. they just may send the compiler into chasing goose. but the compiler has a counter for that.
12:35:22 <skypers> monochrom: about your talk
12:35:22 <NemesisD> so what i'm trying to do is have a single logging function that can operate in different monads, IO and Writer [String]
12:35:28 <skypers> about GHC’s generated asm
12:35:34 <skypers> do you have any material?
12:35:35 <NemesisD> i've seen some suggestions that type families may apply here
12:35:58 <geekosaur> skypers, some of it is covered on the ghc wiki, most of it is in the ghc source
12:36:34 <skypers> ok
12:36:36 <fizruk> NemesisD: ooc, class MonadLog m where … ?
12:36:40 <monochrom> I sometimes read https://ghc.haskell.org/trac/ghc/wiki/Commentary
12:36:48 <skypers> I always thought ghc does asm stuff as in C
12:36:52 <jle`> Nemesis: you can do that with just fundeps I think, as fizruk mentioned
12:36:58 <monochrom> that would be too easy
12:36:59 <jle`> er
12:37:13 <NemesisD> fizruk: intance MonadWriter [String] m => MonadLog m requires undecidableinstances
12:37:16 <jle`> class MonadLog e m
12:37:38 <NemesisD> what's e there?
12:37:40 <geekosaur> skypers, to some limited extent it does. there is even a real call stack --- it just does not get used the way you want it to be used, ever
12:37:41 <jle`> I misread fizruk
12:37:51 <skypers> I know about the thunks, but I guess it’s way more complicated than just that
12:37:54 <jle`> oh, e is your generalized log type
12:37:58 <fizruk> NemesisD: do you need MonadWriter constraint?
12:38:07 <skypers> geekosaur: it must be I guess
12:38:12 <geekosaur> you cannot usefully allocate data on the call stack because it will go out of scope immediately
12:38:23 <NemesisD> fizruk: for the instance. i want to write an instance that works in MonadWriter and an instance that works in MonadIO
12:38:28 <fizruk> jle`: e got lost, typed too fast :p
12:38:32 <skypers> geekosaur: I understand
12:38:33 <geekosaur> there is no way to change this
12:38:39 <skypers> because of closure?
12:38:46 <jle`> but yeah writing "an instance for all instances of this" borders on undecinst territory
12:39:00 * hackagebot tamper 0.3.2.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.2.0 (TobiasDammers)
12:39:02 <NemesisD> fizruk: i guess the danger comes in if the monad is both MonadWriter [String] and MonadIO, i'm smelling danger and am interested in a different way
12:39:02 <geekosaur> because it returns a thunk/closure immediately, yes
12:39:08 <jle`> (on my phone)
12:39:19 <skypers> ok geekosaur
12:39:21 <skypers> thank you :)
12:39:50 <geekosaur> and all further execution is in the thunk, which has no access to the call stack
12:39:52 <monochrom> if you know continuation passing style, you may be able to read GHC-generated asm immediately.
12:40:33 <NemesisD> jle`: is there a better tree i should be barking up?
12:40:34 <geekosaur> (and any data that might have been there is already popped and will probably be overwritten by the next call)
12:41:07 <NemesisD> one idea i've been toying with is turning the greater context i'd be using this in into a free monad. that's pretty course grained though
12:41:37 <tdammers> oh crap
12:41:39 <tdammers> dependency hell
12:42:10 <tdammers> one library needs containers >= 0.5, the other wants containers == 0.4.2.1
12:42:39 <NemesisD> restrictive package dependencies are THE. WORST.
12:42:44 <tdammers> yeah
12:42:45 <fizruk> tdammers: gratz
12:43:32 <tdammers> hmm, or maybe trying to build against base == 4.5 is a stupid idea
12:45:03 <tdammers> OTOH, it has to work on wheezy eventually, and that comes with ghc 7.4...
12:50:04 <skypers> 21:37 < monochrom> if you know continuation passing style, you may be able to read  GHC-generated asm immediately.
12:50:19 <skypers> I do know CPS, but I don’t feel comfortable with it yet
12:51:01 <carter> ghc asm is pretty easy to read
12:54:01 <NemesisD> has anyone tried extensible effects?
12:54:09 <tdammers> *sigh* guess I'll throw in some CPP to make it work
12:59:03 * hackagebot tamper 0.3.3.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.3.0 (TobiasDammers)
13:01:52 <prinsen> A type question: Can I do some type-function-thingie that let me use lists in data declarations?
13:02:16 <byorgey> prinsen: you can use lists in data declarations.  I don't know what you mean by type-function-thingie.
13:02:41 <byorgey> prinsen: can you give a specific example of what you're trying to accomplish?
13:02:46 <c_wraith> you can even use lists at the type level, if that's what you mean, thanks to work byorgey helped with!
13:03:30 <yac> `cmdspec' is not a (visible) field of constructor `CreateProcess'
13:03:32 <yac> why not?
13:04:26 <c_wraith> yac: the docs suggest it is.
13:04:38 <c_wraith> yac: but check for version differences, I guess?
13:05:05 <prinsen> byorgey: I have a data type with a field (a -> Producer ..), called Attaments, and another with (b -> Consumer). Im now writing the Effect that composes some Producers and some Consumers. The field should have the type (a -> b -> c -- -> Effect)
13:05:26 <geekosaur> CreateProcess did undergo a lot of changes some time back
13:05:33 <hoverbear> AlainODea, carter: If I want to downgrade from 7.8.1 to 7.6.3 of GHC, how can I remove the current version of haskell? The help file says it installs to /usr/local, but I don't see any ghc folders there.
13:05:36 <yac> c_wraith: isn't it in stdlib? So I should get that with ghc?
13:05:43 <c_wraith> yac: no, it's in the process library
13:05:49 <carter> hoverbear: its /usr/local/lib/ghc-version
13:05:52 <c_wraith> yac: what version of that library do you have installed?
13:05:56 <carter> hoverbear: just run the 7.6.3 installer
13:05:59 <yac> I  have no idea
13:05:59 <carter> and open a new terminal tab
13:06:01 <carter> and you'll be set
13:06:07 <hoverbear> carter: Oh, I don't need to remove it?
13:06:09 <carter> nope
13:06:26 <yac> trying to figure out where to find that lib in my system
13:06:27 <c_wraith> yac: run "ghc-pkg list process" in a terminal
13:06:27 <carter> you'll wanna have  a scirpt to change up the symlinks if you wanna switch beween them
13:06:28 <carter> but yeah
13:06:43 <yac> process-1.1.0.2
13:06:53 <hoverbear> carter: Thanks. :)
13:06:54 <byorgey> prinsen: what does  (a -> b -> c -- -> Effect) mean?
13:07:07 <tommd> carter: WRT the optimization issue a few hours ago, it is a cabal bug (if you were curious).
13:07:14 <c_wraith> yac: ok, the library has that..  How did you import System.Process?
13:07:20 <carter> tommd: i knew it wasn't ghc
13:07:26 <tommd> Yes, that was clear.
13:07:27 <carter> i spent A LOT Of time learning how cabal / ghc does it
13:07:58 <yac> c_wraith: http://pastebin.blesmrt.net/show.php?id=10116
13:08:04 <prinsen> byorgey: A function taking all the arguments to the composing Producers and consumers
13:08:33 <c_wraith> yac: well, the problem is that you didn't import cmdspec
13:08:39 <c_wraith> yac: that's why it's telling you it isn't visible
13:08:56 <byorgey> prinsen: I still don't understand.  What is the  --  part supposed to mean?  And what do lists have to do with it?
13:09:04 * hackagebot tamper 0.3.4.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.3.4.0 (TobiasDammers)
13:09:07 <c_wraith> yac: in general, I'd just import that whole module
13:09:18 <yac> c_wraith: http://pastebin.blesmrt.net/show.php?id=10117 it's used this way
13:10:11 <c_wraith> yac: yes, but you're not importing either cmdspec or std_out, so it doesn't *know* they're record accessors
13:10:25 <c_wraith> yac: just import the whole module.  You'll save yourself a ton of pain
13:11:08 <yac> c_wraith: hrm,ok. That's kinda surprising
13:11:31 <yac> c_wraith: I prefer explicit imports of specific objects one per line.
13:11:47 <yac> it's something I figured when doing python
13:12:08 <c_wraith> yac: if you really want to be hygienic, use a qualified import.  But that's better than having tons of churn for imports in your version control
13:12:25 <c_wraith> yac: fortunately, imports in haskell never silently override another import
13:12:29 <c_wraith> yac: unlike python
13:13:09 <yac> c_wraith: it's also about "Where the hells does this thing comes from?"
13:13:21 <carter> i love that game
13:13:25 <yac> c_wraith: and first 10 lines in the .py is in format "from <x> import *"
13:13:32 <yac> I'd kick those people in the balls
13:13:32 <carter> its like "where are my pants"
13:13:35 <carter> but with with software
13:13:36 <c_wraith> yac: then use a qualified import.  It's still 100x better than having 100 imports at the start of your file
13:13:55 <c_wraith> and yes, if I imported names 1 line at at time, I'd have 100 imports at the start of any reasonable file
13:14:06 <c_wraith> At least in the big projects I've done
13:14:07 <yac> c_wraith: that's a version control thing :) It's simpler to have one symbol change per line in the diff :)
13:14:54 <yac> oh well now I have problem where CreateProcess fields are not initialized
13:15:10 <c_wraith> yac: import qualified System.Process as P, then prefix names from there with "P.", as P.cmdspec.  Solves the "where does this come from" problem nicely, if your toolchain can't do it.
13:15:18 <yac> I'd use some helper function but I want to be able to read the stdout
13:15:30 <yac> c_wraith: oh, neato
13:15:48 <AlainODea> yac: +1 one line required per diff change (also why prefix commas are good) :)
13:16:09 <__sebastian__> hi all
13:16:15 <zzzzzzzziiii> @type (***)
13:16:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:16:25 <__sebastian__> is there a way to read a type constructor?
13:16:45 <yac> AlainODea: prefix commas? like for records , foo\n,bar\n, qux ?
13:16:46 <__sebastian__> (withour reading the parameters)
13:17:06 <c_wraith> __sebastian__: What is the type of what you envision?
13:17:08 <AlainODea> yac: precisely :)
13:17:18 <yac> AlainODea: oh yeah, then also prefix pipes in shell :)
13:17:23 <__sebastian__> my current solution: case t of {"foo" -> Foo}
13:17:24 <exicer> Is there a way to create an empty JSON list with aeson ?
13:17:37 <jfischoff> Array mempty
13:17:41 <__sebastian__> c_wraith: a self defined type
13:17:58 <jfischoff> or
13:18:03 <jfischoff> toJSON []
13:18:19 <exicer> doh, right.
13:18:40 <__sebastian__> c_wraith: data MyT = Foo Int | Bar Int Int
13:18:41 <grache28> I'm trying to find a way to do something like tails that doesn't return a list
13:18:52 <grache28>  > tails [(3,5),(5,3)]
13:19:20 <c_wraith> __sebastian__: The reason I ask is that you need to think your types through carefully.
13:19:38 <c_wraith> __sebastian__: Foo and Bar have different types!  They're not interchangeable
13:19:44 <grache28> > tails [(3,5),(5,3)]
13:19:45 <lambdabot>  [[(3,5),(5,3)],[(5,3)],[]]
13:20:30 <c_wraith> __sebastian__: If you can write down the type for what you want, the implementation becomes a lot more obvious.
13:20:31 <__sebastian__> c_wraith: they kind of are, if you lift them into applicative
13:20:34 <grache28> I'd like to get [(3,5),(5,3), (5,3) ] instead of the list of lists..
13:20:47 <AlainODea> yac: naturally :)
13:21:23 <c_wraith> __sebastian__: Don't mistake the fact that both of them unify with (Int -> a) as meaning they are the same type.
13:21:53 <yac> http://hackage.haskell.org/package/process-1.0.1.1/docs/System-Process.html#v%3AcreateProcess ... The link to Bool on close_fds doesn't work
13:22:16 <__sebastian__> c_wraith: case t of {"foo" -> Foo <$> (ask "first parameter") ; "bar" -> Bar <$> (ask "first param" <*> (ask "second param"))} this does work
13:22:42 <c_wraith> __sebastian__: because each branch of the case returns the same type, because the two branches do different amounts of work
13:23:12 <c_wraith> yac: yep!  That link is broken.  But it's really just the standard Bool type, which might be why no one's fixed it.  No one else has clicked on it. :)
13:24:06 * hackagebot scientific 0.3.0.2 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.0.2 (BasVanDijk)
13:24:09 <c_wraith> If anyone who maintains hackage/haddock is around, that probably is worth looking into, though. Fuuzetsu, you know why it chose to link to the primitive package?
13:24:11 <__sebastian__> c_wraith: Foo is something, which just doesn't require the second parameter
13:24:42 <yac> c_wraith: yeah, just noobs are clicking on it
13:24:46 <yac> who cares
13:25:20 <c_wraith> yac: I agree it's a problem.  That's why I asked Fuuzetsu about it.  I was just saying that's why it probably is still broken - no one even noticed it!
13:25:57 <gooddata> Is haskell stable enough for real production application?
13:26:04 <Fuuzetsu> c_wraith: sup
13:26:16 <c_wraith> Fuuzetsu: see yac's hackage link a few lines up
13:26:31 <[swift]> gooddata: yes
13:26:40 <c_wraith> Fuuzetsu: I know hackage isn't your thing, but maybe you've got an idea
13:27:01 <Fuuzetsu> yac: c_wraith: you should start by trying with Haddock newer than 2.4.2
13:27:27 <enthropy> yac: I don't think there are broken links in the newer docs http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#t:CreateProcess
13:27:34 <Fuuzetsu> honestly, considering how old those docs are the chances are something was moved around since then
13:27:48 <c_wraith> gooddata: If it's not, those production web services I wrote that served hundreds of requests per second (seriously, really actually that much) have a big surprise coming when they're told they're not production-ready. :)
13:28:07 <Fuuzetsu> so I suspect the link worked when the docs were generated initially, many years ago ;)
13:28:41 <c_wraith> Fuuzetsu: you know why hackage doesn't regenerate docs for old packages, other than load?
13:28:54 <c_wraith> well, and the horror of getting them building consistently. >_>
13:29:33 <Fuuzetsu> c_wraith: I imagine because of resources and problems with managing it all; do we rebuild old docs with 7.8? Will they build? Is there even a point when new version exists?
13:29:43 <Fuuzetsu> If anything, we should maybe rebuild the latest versions of things
13:29:44 <gooddata> c_wraith :  You never got a obscur bug or something like that ?
13:30:14 <c_wraith> gooddata: sure, you hit the occasional obscure bug.  But you just solve them, like you do in that case with every other language.
13:30:45 <monochrom> even rebuilding docs for latest versions is a tall order. some latest versions are so out of sync with current ghc and base that they can't be built either unless you roll back to like ghc 6.10
13:31:14 <Fuuzetsu> yes I agree
13:31:19 <c_wraith> In retrospect, I find it amazing that hackage succesfully builds any docs at all.
13:32:57 <Fuuzetsu> by the way, I think if Hackage server were to run nix and extra care was taken by uploaders to specify .nix files, we could have docs (and even binaries) for packages that require external dependencies which I think would be cool
13:33:06 <monochrom> I never got obscure bugs. I write carefully.
13:33:36 <c_wraith> Fuuzetsu: assuming the external dependencies build on the platorm/architecture hackage runs on.
13:33:38 <gooddata> c_wraith :  Yeah I know I mean  Java & JVM is use a lot , I'm not scare to use it for critical app  ,But with Haskell, even if easy to code good application, like it's not so much use I'm scare a little bit
13:33:43 <monochrom> that said, writing carefully in haskell is still less stress than writing carefully in many other languages.
13:34:43 <monochrom> I don't understand what is scary about it. except being afraid of finding no colleague who also knows haskell.
13:34:52 <Fuuzetsu> c_wraith: sure, of course, not really something one can mitigate without some serious resources though
13:35:01 <c_wraith> gooddata: yeah, you're committed to learning more than just how to write haskell.  You also have to learn how to sysadmin GHC-compiled binaries.  There's more to learn, but it's tractable.
13:35:09 <monochrom> from the "how many bugs you may introduce" perspective, clearly java should be more scary than haskell
13:35:38 <monochrom> and clearly python, lisp, scheme, php are more scary than java
13:36:20 <monochrom> (way to go putting a dent in Paul Graham's heart by grouping lisp with php! :) )
13:36:37 <geekosaur> *snrk*
13:37:08 <Sebboh> Greetings.  I've been using haskell for an hour.  I'm using ghci via inferior-haskell in emacs.  When I screw up and evaluate an expression (is evaluate the wrong word here?) that returns an infinite list, how do I tell it to stop?  C-g doesn't behave as expected.
13:37:31 <monochrom> I can justify it. at our current state of the world, "how many bugs you may introduce" is mostly determined by the static type system. so it is ok to group lisp and php together.
13:41:10 <gooddata> monochrom :  I know Haskell reduce to number of programming bugs , was more thinking some random bugs let by GHC
13:41:51 <monochrom> then they are rare
13:42:01 <Ralith> monochrom: php is weakly typed, and lisp strongly :p
13:42:16 <gooddata> monochrom: like few days ago , I did something in GHCi that give an error to send to the GHC team
13:42:25 <monochrom> to be sure, if GHC itself were written in Java, you would be right to worry more about GHC bugs :)
13:43:37 <monochrom> to a large extent, if you use the 2nd most recent stable release, you're safe. currently, it means 7.6.3
13:44:02 <gooddata> monochrom :  Ok thank
13:44:25 <yac> I don't even know what haddock is, I wanna just crush some code
13:44:47 <Sebboh> I found an answer: C-c C-c.  (It takes a second to catch up, but works.)
13:45:04 <gooddata> yac :  haddock is a fish
13:45:51 <monochrom> at the last Toronto Haskell meetup, I looked for food nearby. I found a fish and chip place. it was not cheap. but...
13:46:18 <monochrom> in addition to the typical trout, cod, and halibut, it also had haddock! I'm sold.
13:46:47 <gooddata> monochrom : I went to Scotland and every fish and chip was so bad
13:47:18 <gooddata> I was happy to come back to Canada
13:47:55 <tdammers> gooddata: that's because they use the same cow fat to deep-fry the fish, the chips, the haggis, the Mars bars, and their grandmothers
13:48:06 <tdammers> and they change it every other year
13:48:16 <monochrom> I miss Mars bars! and York bars too
13:48:29 <monochrom> (I was in Hong Kong)
13:48:47 <yac> I had really nice fish and chips at some irish bar in germany
13:48:48 * tdammers never had a York bar
13:48:54 <gooddata> monochrom : There is a lot of people in the Toronto Haskell Meetup
13:49:08 <monochrom> (I was in Hong Kong long ago. enjoyed all the British goodies!)
13:51:17 <tdammers> fun fact: the famous English wine gums (from Basset's) are produced in the Netherlands
13:51:46 <monochrom> well, at least not China :)
13:52:53 <Kaidelong> there's something missing from Control.Monad.Trans.Error that I think is important
13:52:58 <tdammers> I think food is one of the last strongholds of things made in Not China
13:53:33 <Kaidelong> @hoogle (Exception e, MonadIO m) => ErrorT e m a -> m a
13:53:35 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
13:53:35 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
13:54:17 <t4nk858> hello
13:54:22 <bennofs> @ty
13:54:23 <lambdabot> <no location info>: not an expression: ‘’
13:54:44 <Kaidelong> is there a reason it's not already there and if not who should I bug about this?
13:55:01 <Kaidelong> (seems silly for Control.Exception and Control.Monad.Trans.Error not to work together)
13:55:07 <bennofs> :t runErrorT >=> either throwIO return
13:55:08 <lambdabot> Exception e => ErrorT e IO c -> IO c
13:55:13 <Kaidelong> yep that one
13:55:34 <Kaidelong> I realize it's simple, but it should be in the module
13:55:41 <monochrom> Control.Exception is meant for IO not general MonadIO
13:56:11 <Kaidelong> mmm well then I guess it'd have to be specialized to IO
13:56:13 <Kaidelong> but that's fine
13:56:25 <monochrom> general MonadIO is too general, lack stuff for meaningfully catching and throwing exceptions. you need at least monad-control stuff
13:56:48 <saml> is haskell good for io bound programs?
13:57:01 <Kaidelong> that's probably haskell's strongest suit
13:57:03 <saml> like a webserver that talks to db and other http servers
13:57:07 <bennofs> monochrom: throwing works without monad-control tough, just using liftIO, doesn't it?
13:57:08 <Kaidelong> IO intensive programming in the large
13:57:27 <monochrom> ok throwing works, catching is a different story
13:57:34 <Kaidelong> (it's a pain for programming in the small but purity helps rather than hurts with big programs)
13:57:34 <saml> not intensive. but io bound. cpu is idle waiting for io to complete
13:58:07 <saml> @google haskell asynchronous io
13:58:07 <lambdabot> http://blog.lahteenmaki.net/2013/01/haskell-and-non-blocking-asynchronous-io.html
13:58:08 <lambdabot> Title: Architecturally Elegant: Haskell and non-blocking asynchronous IO
13:58:11 <oscarb92> hello
13:58:21 <Kaidelong> isn't that what TVar and friends are for?
13:59:25 <prinsen> byorgey: Sorry got dc. Still there?
14:00:29 <felixn> saml: haskell approaches ideal for IO heavy programs, the debate of promises vs coroutine vs etc disappears when you have pure & lazy code
14:00:54 <felixn> saml: practically speaking GHC doesn't fair too well on the web framework benchmark game
14:01:06 <Kaidelong> well they have less of an impact on the semantics of how the program works
14:01:28 <Kaidelong> you still need to consider the performance of the different approaches
14:01:37 <saml> felixn, why is ghc bad at web app?
14:01:59 <saml> why does the debate of promises, coroutine.. disappear?
14:02:04 <felixn> saml: http://www.techempower.com/benchmarks/ haskell isn't really rockin it :(
14:02:11 <negatratoron_> Wouldn't it be the case that every occurrence of getLine has to be equal to the same inhabitant of the IO String type?
14:02:41 <Kaidelong> negatratoron_: isn't it?
14:02:52 <bennofs> felixn: I think that doesn't yet use GHC 7.8? 7.8 brings some perf improvements I heard
14:02:58 <negatratoron_> it can contain a different string each time
14:02:58 <Kaidelong> getLine is the same thing every time you use it
14:03:19 <geekosaur> negatratoron_, it is. but that inhabitant is a chunk of code that performs an IO operation, not a value
14:03:25 <bennofs> @quote ls
14:03:25 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
14:03:29 <bennofs> @quote /bin/ls
14:03:29 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:03:34 <felixn> saml: promises are just silly in haskell because you just state your computation, and it will be executed in the correct order
14:04:19 <negatratoron_> oh, that makes some sense
14:04:34 <geekosaur> you could say it's an instruction for the runtime. which is why you can't "unpack" an IO value; there's no final value inside it, just an instruction to the runtime
14:04:43 <albeit> Is it possible to change a few fields in a large data structure, without using lens, and without evaluating the other fields (ie, use Foo _ _ myField _)?
14:05:04 <bennofs> albeit: you can use record update syntax
14:05:08 <geekosaur> albeit: myRecord { somefield = newValue }
14:05:15 <felixn> bennofs: :O  that would make me happy!  since I've been sort of looking at Go for my website
14:05:19 <edwardk_> foo { myField = 1 }
14:05:26 <edwardk_> you know, the way we did it before lens ;)
14:05:30 <albeit> Ahh so modify using monads is just wrapping that, makes sense
14:05:39 <jle`> negatratoron_: "ls" is the same binary every time you run it
14:05:41 <jle`> what gives?
14:05:43 <albeit> (*can use it)
14:06:07 <geekosaur> actually modify is something else entirely; a State is secretly just a tuple and you're making a new tuple with a different value
14:06:35 <negatratoron_> Let's say that chunk of code that getLine runs is of type (String -> b) -> b
14:06:39 <Rarrikins> @type liftIO
14:06:40 <lambdabot> MonadIO m => IO a -> m a
14:06:44 <albeit> But if I'm doing "modify (\s -> s {foo=bar}), that is using record update syntax, ya?
14:06:46 <saml> hrm why haskell web apps are so slow on that benchmark?   https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/snap/bench/src/Main.hs
14:07:02 <geekosaur> albeit, yes, but only because your state value is a record. it doesn't have to be
14:07:06 <geekosaur> so it's not specific to modify
14:07:06 <jle`> NemesisD: your typeclass based efforts might do what you want, i think
14:07:10 <negatratoron_> If that were true, you would still run into the problem where getLine would always have to provide the same type
14:07:16 <albeit> True, didn't mean to imply that, though I did
14:07:17 <negatratoron_> so it must not be true :)
14:07:28 <jfischoff> saml: maybe the JSON library for go is written in C?
14:07:33 <negatratoron_> provide the same string*
14:07:40 <geekosaur> nope
14:07:46 <jfischoff> I’m curious too
14:08:15 <outinputput> anyone here deployed haskell on heroku?
14:08:18 <jle`> negatratoron_: haskell can only evaluate, not execute.  getLine evaluates to the same command every time.
14:08:21 <jle`> outinputput: aye
14:08:26 <negatratoron_> evaluate vs execute?
14:08:31 <negatratoron_> That's not a distinction I'm familiar with
14:08:33 <jle`> negatratoron_: the execution part is the job of the cpu/computer
14:08:33 <geekosaur> you are registering a bunch of callbacks; this turns out to be trivial in Haskell because non-strict evaluation means everythin's kinda already a callback :)
14:08:45 <jle`> bye lambdabot
14:08:51 <monochrom> negatratoron_: all occurences of getLine are the same inhabitant in IO String. see my http://www.vex.net/~trebla/haskell/IO.xhtml
14:09:17 <felixn> saml: I KNOW!  but overall I hope that this is putting a microscope to web benchmarks, meaning webservers really just smoosh data together and shove it out, is your webserver really going to be pumping 10,000 rps?
14:09:20 <geekosaur> the IO stuff, youre registering callbacks that the runtime executes when it sees fit, and at that time it can do whatever. but the mutable aspect of IO is not directly visible to your program because you're manipulating fixed instructions to the runtime and fixed callbacks
14:09:45 <geekosaur> what happens in the context of the runtime can be as mutable as it wants to be
14:09:53 <saml> felixn, yes. i get 20k+ concurrent connection on a normal day
14:09:56 <jle`> negatratoron_: you might be able to think of getLine is a little packet of assembly/c code.  it's the same packet every time.  it evaluates to the same packet.  when something like ghc compiles your getLine, it compiles it into that actual assembly code.  a computer then takes that compiled binary, and executes it
14:10:10 <jle`> haskell's job is the evaluation of the IO String object.  the cpu's job is to execute it
14:10:13 <felixn> saml: what is your webserver currently written in?
14:10:22 <negatratoron_> Oh that's very interesting
14:10:25 <saml> node.js
14:10:51 <felixn> nice, I love node, the ecosystem is awesome, but I'm slowly drifting to more static languages
14:10:53 <saml> i have 3 servers.  2 live. 1 on ready state
14:11:00 <monochrom> it is ok to say that the runtime works at a meta level
14:11:07 <saml> i want to delete all node.js
14:11:11 <jle`> negatratoron_: but evaluating the same IO object and compiling the same IO object should technically compile to the same binary every time, right?
14:11:19 <Kaidelong> I'm guessing ErrorT is preferable to throwing exceptions
14:11:25 <negatratoron_> As you run a haskell program, the runtime must switch back and fourth between evaluating and executing right?
14:11:32 <monochrom> I wouldn't say same binary. but certainly same behaviour.
14:11:36 <Kaidelong> my compromise would be giving the appropriate Exception instances in case someone wants to manually cast
14:11:37 <negatratoron_> That's the only way future IO actions could depend on previous IO actions
14:11:37 <felixn> saml: haha, personally I've been looking at Go
14:11:40 <Kaidelong> but otherwise using ErrorT
14:11:49 <jle`> monochrom: ah yes.  "same instruction graph" maybe
14:11:51 <jle`> ?
14:12:19 <monochrom> I don't know. are "xor ax,ax" and "load ax, #0" the same instruction? but they have the same behaviour.
14:12:55 <monochrom> have programmers lost the concept of "these two textually different programs do the same thing"?
14:13:10 <geekosaur> negatratoron_, in practical terms it does. in theoretical terms there is no real difference between that and using Haskell to build a program which is handed off to the runtime to execute; this program consists of I/O primitives, like the value of getLine, and callbacks which the runtime can execute with variable data and which produce new instructions for the runtime
14:13:43 <jle`> monochrom: i see
14:13:59 <negatratoron_> Cool, that makes sense
14:14:09 <int-e> ah, poor lambdabot. https://clientarea.ramnode.com/announcements.php?id=352 is why, so it should be back soon.
14:14:29 <merijn> monochrom: Especially given the complexity of modern ISAs which can cause different instructions with the same behaviour to have radically different performance
14:14:35 <geekosaur> negatratoron_, are you familiar with web programming? this is in some sense similar to the fact that javascript running in the browser cannot directly affect the server, nor can the server arbitrarily "do things" on the browser --- it has to send the browser a Javascript program
14:14:50 <geekosaur> we're kinda doing that last
14:14:51 <hubblebub> How can I pattern match or take the head of a functor value?
14:14:53 <negatratoron_> yeah, my job is web programming
14:15:04 <Sebboh> I'm interested in reading documentation about ranges.  as in [1..10].  Is there another noun that describes this?  The search results I'm getting aren't right.
14:15:26 <merijn> Sebboh: ranges desugar to enumFromTo (and related) in the Enum typeclass
14:15:28 <negatratoron_> in fact I'm supposed to be doing that right now >.>
14:15:29 <monochrom> what does "the head of a functor value" mean?
14:15:41 <merijn> Sebboh: So "[1..10]" is sugar from "enumFromTo 1 10"
14:15:45 <leggo> > zip [1..] ['a'..]
14:15:53 <Sebboh> Ah, thanks!  Perfect.
14:16:08 <hubblebub> monochrom: I'm not sure, basically I want to iterate over any functor, does that make sense?
14:16:16 <Sebboh> Is there a function I can call to desugar an arbitrary expression?
14:16:44 <monochrom> then not functor, but traversable or foldable, I don't know which. and still not in terms of heads.
14:16:47 <bennofs> hubblebub: to "take the head" you can use Foldable
14:17:05 <bennofs> :t getFirst . F.foldMap (First . Just)
14:17:15 <bennofs> aw. lambdabot quit
14:17:37 <merijn> bennofs: Or you just to "head . toList"..
14:17:51 <bennofs> merijn: that wont give you maybe though
14:17:52 <hubblebub> bennofs: does this actually convert it to a list?
14:18:01 <merijn> bennofs: listToMaybe . toList
14:18:07 <bennofs> merijn: hmm, right
14:18:28 <merijn> Sebboh: Not really, lambdabot has a @undo command for desugaring do notation, don't think list comprehensions have one
14:18:29 <monochrom> I am unconvinced that you must absolutely get the head in your own hands. as opposed to giving a callback so someone else calls it with elements successively
14:18:45 <jle`> farewell lambdabot, sweet prince.
14:19:04 <merijn> Sebboh: tbh, I would just read the Haskell Report, it's fairly readable (especially compared to horrors like the C standard) and should explicitly describe all desugaring
14:19:16 <hubblebub> monochrom: you're likely right. What I want to do is turn some traversable thing into a Stream
14:19:21 <merijn> @where report
14:19:24 <merijn> oh, doh
14:19:27 <merijn> no lambdabot
14:19:45 <bennofs> hubblebub: isn't that pretty unsafe?
14:19:49 <monochrom> http://www.haskell.org/onlinereport/haskell2010
14:20:03 <hubblebub> bennofs: hmm, why is that?
14:20:14 <bennofs> hubblebub: your traversable might only have a fixed number of elements, and so you cannot turn it into a stream? Or are you using finite streams?
14:20:22 <benzrf> if we have any horror fans here
14:20:28 <benzrf> https://github.com/perl6/std/blob/master/STD.pm6 <- perl 6 standard grammar
14:20:34 <hubblebub> bennofs: ah, yeah these are finite
14:20:54 <hubblebub> bennofs: these are like the streams from the stream fusion papers
14:21:09 <true_droid> hi, I'm trying to compile the basic program from this tutorial and I get an error about identifier 'set' not in scope
14:21:11 <true_droid> http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling#Parsing_the_flags
14:21:25 <merijn> Sebboh: Looks like 3.10, 3.11 and 3.14 cover most sugar
14:21:31 <Sebboh> How is sugar implemented?  Is there a specific step in the ... interpreter? that handles that?  Can't I just instruct it to emit a post-desugar'd version of anything it desugars?  ...I'm presuming that sugar is some sort of macro system.
14:21:31 <true_droid> it's inside the concatMap call in the else branch in the middle
14:21:54 <Sebboh> merijn: thanks.
14:21:56 <bennofs> Sebboh: sugar is removed when translating from Haskell -> Core
14:22:00 <geekosaur> it's not exactly although there *is* a thing called SugarHaskell which does that.
14:22:06 <merijn> Sebboh: The compiler desugars haskell into Core, I'm not sure it first desugars into haskell before going to core
14:22:10 <bennofs> Sebboh: but it's only removed after typechecking
14:22:21 <bennofs> Sebboh: you can print the desugared Core using -ddump-ds
14:22:23 <jle`> true_droid: it's defined down in the where clause
14:22:44 <jle`> next to `header`
14:22:44 <Sebboh> Core.  Ok.  Does Haskell run in a vm under the hood?
14:22:54 <merijn> bennofs, Sebboh: Sure, but the desugared Core also drops lots of other things, like typeclasses, etc. :)
14:23:03 <merijn> Sebboh: Wrong question :)
14:23:19 <felixn> Sebboh: out of curiosity, what are you working on that you want to desugar?
14:23:21 <merijn> Sebboh: Haskell the language doesn't run, specific implementations can do whatever they like
14:23:30 <jle`> haskell is a language, not an implementation
14:23:33 <bennofs> Sebboh: GHC compiles haskell into native machine code
14:23:35 <merijn> Sebboh: Specifically, GHC just generates native machine code, like a C compiler would
14:23:45 <Sebboh> What is core?  Is it a bytecode?
14:23:53 <Sebboh> s/c/C/
14:24:02 <kadoban> It's kinda like Haskell but really simple and gross looking.
14:24:08 <bennofs> it's an intermediate language used by GHC to perform high-level optimizations
14:24:20 <bennofs> @botsnack
14:24:21 <true_droid> jle`: weird, I can only see "where header = "Usage: cat [-benstuv] [file ...]"", nothing else on that line or below it
14:24:28 <lambdabot> :)
14:24:36 <Sebboh> Is Core GHC specific?
14:24:38 <jle`> it looks a lot like haskell, but everhthing is desugared and stuff
14:24:38 <merijn> Sebboh: Core is a simpler intermediate language, so the compiler first translates Haskell to Core, then does optimisations, etc. on Core. The Core then gets translated to STG, where low level optimisations happens and the STG gets translated to machine code
14:24:54 <monochrom> true_droid: scroll way bottom to find the definition of set. its omission in the main text may be an error.
14:25:19 <jle`> true_droid: how odd
14:25:32 <merijn> Sebboh: Usually compilers don't work on the actual input language, due to the input language being complicated. They usually use an IR (Internal Representation) where every input language feature maps to some code in the IR
14:26:04 <Sebboh> merijn: Like an abstract syntax tree.
14:26:22 <true_droid> monochrom: thanks. I assumed the tutorial was strictly top-down because it shows the working minimal program after a couple of code snippets
14:26:55 <benzrf> merijn: wht about c--
14:27:28 <merijn> benzrf: There is a fuzzy boundary between STG and C-- as far as I can tell?
14:27:45 <benzrf> whats stg anyway
14:27:48 <merijn> Sebboh: Well, the IR usually *is* an AST, preferably one that is simpler than the original :)
14:28:09 <merijn> benzrf: The language for the spineless tagless G-machine (although I think GHC no longer quite uses that)
14:28:50 <merijn> Sebboh: For example, Core has no where statements or multi pattern function definitions. Instead wheres are turned into let and multi-pattern functions into functions with a case expression
14:29:13 * hackagebot yesod-static-angular 0.1.2 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.2 (JohnLenz)
14:29:28 <merijn> benzrf: I recently read this on STG, it's very readable but a bit out-of-date when it comes to modern day GHC: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
14:30:30 <Sebboh> merijn: ok.  And by OK, I mean that the ratio of unknown noun phrases in your last sentence is too high for me, so I'm going back to the hello-world-level tutorial for a while.  But I'll be back. ;)
14:30:30 <awestroke> would it be feasible to create a service that automatically tried combinations of packages with different dependency versions and notified the package maintainer when the constraints could be safely optimized?
14:31:40 <merijn> Sebboh: I meant that if you write "map _ [] = []; map f (x:xs) = f x : map f xs" that in Core this would become "map f list = case list of [] -> []; (x:xs) -> f x : map f xs"
14:32:06 <Sebboh> merijn: the ratio is not improving!
14:32:07 <monochrom> there may be a combinatorial explosion of versions to try
14:32:29 <merijn> Sebboh: Ah, in that case you may want to learn a bit more basics before worrying about these details ;)
14:33:44 <awestroke> monochrom: it seems trivial to begin with the most important combinations (< and > and moving outwards), and it would only need to find each dependency version that breaks the package
14:34:18 <awestroke> monochrom: anyway, it
14:34:41 <Sebboh> ...Programmers of all flavors suffer from that behavior that I just observed here.  user1> I'm going to X. user2> You should X.  ... This creates an emotional response in user1 that makes it very difficult to not respond in some way.  But there are ways to respond that don't perpetuate the cycle.  I hope this is one of them.
14:34:46 <merijn> awestroke: You're glossing over the fact that two packages may share a dependency and they may rely on different feature sets of the common dependency, thus not being trivial to solve
14:34:59 <Sebboh> oh, I'm late.
14:35:30 <monochrom> what emotional response? I thought programmers were professionals.
14:35:36 <awestroke> merijn: that's because of tight constraints, which this service could potentially  loosen
14:35:39 <merijn> awestroke: So checking versions for one package at a time won't work
14:36:00 <merijn> monochrom: s/professionals/emotionless robots
14:36:18 <merijn> That's why programmers never argue about trivial things like editors and libraries
14:36:38 <monochrom> no, I seriously mean professionals. it means humans who, despite emotion, can control their emotion and stay cool.
14:36:59 <roconnor> monochrom: anyone can be a programmer.
14:37:02 <merijn> Did I do a Poe?
14:37:03 <monochrom> it is also why programmers are paid so much more money than children
14:37:05 <roconnor> er
14:37:10 <roconnor> anyone can write programs
14:37:22 <kadoban> monochrom: Well, that and child labor laws...
14:37:49 * merijn mumbles something about free market, Ayn Rand and "I'm sure it'll all work out in the end"
14:37:58 <awestroke> merijn: it could topologically sort and begin at leaves, which would increase the number of potential combinations to try
14:40:52 <awestroke> and verified constraints would not be challenged again, preventing combinatorial explosion
14:41:19 <edwardk_> monochrom: I find it more useful to try to channel those emotions into code. My response to getting angry/sad about code has varied from writing a competing package, improving my code to get it beyond the simple reproach, to finding a way to open source someone's whole industry. Give in to the dark side. ;)
14:41:21 <merijn> awestroke: Well, I'm not stopping you from trying, I'm all in favour!
14:41:54 <merijn> edwardk_: To be honest I find that angry ranting can be very constructive in improving my productivity :p
14:42:01 <edwardk_> merijn: hah
14:42:26 <edwardk_> I do some of my best coding while muttering imprecations under my breath
14:42:33 <monochrom> when an asker asks "how to do X?", the only reason I may be wrong to answer "you should do Y" is that professionally, rationally, and objectively, it may be a good idea to do X afterall. this ought to have nothing to do with "highschool kids have fragile emotions, don't give them low marks"
14:42:38 <merijn> I spent an hour cursing at a colleague when I was trying to figure out GHCs CPP bullshit. It was very cathartic and I felt much better afterwards
14:45:56 <atohs> self.postMessage from content script to the addon look broken in 30
14:45:58 <Kaidelong> I really like the model I came up with, but it'd work better with linear types
14:46:12 <atohs> wrong window, sorry
14:47:00 <merijn> monochrom: Actually, his comment uses X twice, not X and Y. Because I said "may want to learn a bit more basics" after he "I'm going back to the hello-world-level tutorial"? Although I mostly meant that as words of mild encouragement, so I'm a bit confused
14:47:06 <quchen> merijn! Lord of Pipes hacks! How would you create a pipe that has a timeout on "await"? I need a thing to plumb in that tries to await for a certain time, and if nothing comes in, it terminates. My current solution is an evil hack.
14:47:16 <monochrom> I think the 2nd X was a typo.
14:47:16 <Kaidelong> to ensure everything is initialized (and to avoid excessive use of unsafePerformIO) the user has to check out a global state token and most of the other functions of the library has it as their first parameter
14:47:26 <merijn> monochrom: But then it makes no sense!
14:47:32 <Kaidelong> after the token is finalized, it becomes useless
14:47:34 <merijn> monochrom: No one did that?
14:47:55 <merijn> quchen: Simple: Stop wanting wrong things :p
14:48:03 <quchen> merijn: :-(
14:48:06 <merijn> quchen: Why are you trying to time out?
14:48:15 <merijn> quchen: Are you sure you don't want pipes-concurrent?
14:48:34 <merijn> s/concurrent/concurrency
14:48:43 <quchen> I'm basically reading from a socket (pipes-network), and want to time out if there hasn't been a useful signal in some time.
14:48:47 <monochrom> I see now, merijn. that is even stranger indeed.
14:49:25 <quchen> I can't just use a normal connection timeout because that resets on any data. At least I think I need this.
14:49:36 <merijn> quchen: You want to decouple your producer and consumer, which makes no sense in the pipes world, hence you should use pipes-concurrency
14:49:36 <monochrom> perhaps "you should do Y instead" was desirable afterall.
14:49:53 <merijn> quchen: That has " recv :: Input a -> STM (Maybe a)"
14:50:05 <merijn> quchen: And then you can simply put your timeout in a TVar
14:50:09 <quchen> I'm familiar with pipes-concurrency, yes
14:50:14 <monochrom> <A> I have to relearn the basics now  <B> no, don't do that, you should learn category theory!
14:50:37 <quchen> Where <B> is one of maybe 4 people in this channel
14:51:07 <benzrf> cat theory is abstract nonsense
14:51:21 <awestroke> dog theory > cat theory
14:51:26 <benzrf> :^)
14:51:48 <monochrom> . o O ( next time I'll use denotational semantics. you people... )
14:52:45 <merijn> awestroke++
14:54:28 <Fuuzetsu> say I want to distribute binaries to other people, what's the process here?
14:54:34 <zq_> hello
14:54:42 <benzrf> Fuuzetsu: put it on your website
14:54:44 <benzrf> give them a link
14:55:15 <zq_> i'm having some trouble cross-compiling ghc to --target=i386/--host=--build=x86_64
14:55:49 <zq_> specifically, the first part of the ghc-prim's build mixes the output of the host compiler with the target's linker
14:56:20 <Fuuzetsu> benzrf: I mean more of the ‘how do I make binaries which won't require the user to have libs’ &c
14:56:47 <napping> what have you tried?
14:56:49 <benzrf> Fuuzetsu: i know, i was being a dick
14:56:59 <Fuuzetsu> benzrf: Stop that then~
14:57:14 <zq_> napping: was that for me?
14:57:50 <napping> sorry,for Fuuzetsu. I don't know anything about cross compiling. Might help to say what the error was
14:57:56 <napping> oh, you did a bit
14:58:22 <Fuuzetsu> napping: Nothing yet, just wondering whether there are any flags I need for static libs &c. I don't imagine just copying the binary from dist will work.
14:58:57 <napping> It had been the default for a while, -static -optl-static should go pretty far
14:59:09 <merijn> Fuuzetsu: Compile static (which, afaik is still the default) and then you should only need the C libraries, since foreign C libraries are linked dynamic by default
14:59:22 <merijn> Fuuzetsu: I'm sure there's a way to statically link C libs too, but don't ask me how :)
14:59:39 <napping> that's what -optl-static is for, it tries to pass -static to the linker
14:59:57 <napping> Not sure how well that works, I don't think I needed C libraries for what I was trying
14:59:57 <Fuuzetsu> OK. I don't imagine there's a way to build binaries for 64-bit systems with 32-bit GHC?
15:00:20 <Fuuzetsu> (easy way)
15:00:43 <merijn> Fuuzetsu: My magic 8ball says "haha" :)
15:01:11 <merijn> I'm not sure whether you should believe it, though. My magic 8ball is a shifty bastard
15:02:47 <napping> Fuuzetsu: to compile main = putStrLn "Hello World", ghc -static -optl-pthread -optl-static main.hs seems to work
15:03:04 <napping> I didn't remember needing to explicitly pass -lpthread like that
15:03:50 <merijn> napping: I'm not sure GHC uses pthreads for threading...
15:04:11 <napping> well, it sure gives linker errors without it
15:04:48 <napping> I would expect it to use it for capabilities
15:07:26 <napping> Fuuzetsu: there's something about libc sometimes wanting the dynamic libraries even if it's statically linked, but hopefully it's reasonably compatible
15:09:57 <erisco> any libraries for an interval set?
15:10:07 <monochrom> it's glibc. it finds out, during run time, whether your user accounts come from /etc/passwd or LDAP or ... and dynamically load the right lib for that so that e.g. you call "getpwent" and it just works
15:10:20 <c_wraith> erisco: I'm sure I've seen one
15:10:31 <erisco> I want to store closed intervals and query for unused intervals (range is bounded)
15:10:44 <monochrom> so even if you demand static linking of glibc, there is always that part not statically linked, ever.
15:10:45 <erisco> for dealing out Int ids basically
15:12:01 <c_wraith> erisco: http://hackage.haskell.org/package/IntervalMap maybe?
15:12:09 <erisco> http://hackage.haskell.org/package/intset-0.1.1.0/docs/Data-IntervalSet.html there is this but not quite right it seems
15:13:55 <erisco> hrm perhaps, though I do not need a value, so it will just be unit
15:14:18 * hackagebot pandoc 1.12.4.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.4.2 (JohnMacFarlane)
15:15:46 <napping> What do you need beyone unique ids?
15:16:06 <erisco> nothing
15:16:13 <erisco> my life would be complete :)
15:16:24 <napping> Oh, why not use something like concurrent-supply
15:16:39 <napping> I'm trying to find a simpler package but I don't know which
15:17:02 <carter> mmmm: any patches merged in yet :)
15:17:03 <carter> ?
15:20:59 <napping> erisco: have you seen that sort of package?
15:22:14 <erisco> napping, nope
15:23:41 <a3gis> hi! quick question: I was going through some slides and fell on an example saying that Maybe Bool and (Bool -> b) -> Maybe are isomorphic. Isn't this only true if Bool -> b is a injective function?
15:24:01 <a3gis> (Bool -> b) -> Maybe b, sorry
15:24:12 * geekosaur was wondering about that part (Maybe)
15:24:16 <edwardk_> a3gis: ote: that was forall b. (Bool -> b) -> Maybe b
15:24:21 <edwardk_> the quantifier is very important
15:24:45 <edwardk_> if you give me a function that works for all choices of b, i can pass you 'id'
15:24:52 <a3gis> edwardk_: yep I actually didn't try the code, is the quantifier essential here? isn't it implicit?
15:25:03 <companion_cube> shouldn't it be   forall b. (Bool -> b) -> b ?
15:25:03 <napping> edwardk_: how is concurrent-supply? I saw one big old bug, is it stable now?
15:25:15 <monochrom> it is a bad idea to leave it implicit in this context
15:25:23 <edwardk_> napping: i still use it
15:25:38 <a3gis> http://alissapajer.github.io/conferenceslides/flatmaposlo2014/#/15
15:26:01 <edwardk_> a3gis: the type that is talking about is Yoneda.
15:26:25 <napping> erisco: You can get a nice pure name supply with some tricks
15:26:26 <edwardk_> newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b }
15:26:28 <a3gis> right; I still have to go through the rest of the presentation but I was just wondering about that bit
15:26:46 <edwardk_> Yoneda Maybe Bool and Maybe Bool have the same number of non-_|_ inhabitants
15:26:51 <a3gis> since if the function Bool -> b is not injective then it might be constant
15:27:18 <edwardk_> you're assuming you can know the function from Bool -> b
15:27:33 <edwardk_> its sying that you have to be able to take _any_ fnction from Bool -> b, and give me a Maybe b
15:27:42 <napping> erisco: http://hackage.haskell.org/package/concurrent-supply
15:27:42 <edwardk_> without knowing anything about b
15:27:47 <a3gis> well I'm just arguing on the fact that there might be two disinct return values, not three
15:27:48 <edwardk_> in that case i can always hand you id
15:27:53 <edwardk_> giving you Maybe Bool
15:28:02 <a3gis> oh ok
15:28:19 <edwardk_> and given Maybe Bool
15:28:21 <edwardk_> :t flip fmap
15:28:22 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:28:27 <edwardk_> that takes it back to that form
15:29:04 <edwardk_> flip fmap and ($id)  work as inverses here
15:29:11 <napping> edwardk_: thanks, I didn't see reverse dependencies.
15:29:40 <edwardk_> napping: we use it mostly behind closed doors
15:29:45 <a3gis> ok that makes more sense
15:29:48 <a3gis> thanks (:
15:30:32 <napping> erisco: the trick with that kind of library is to return an infinite tree of values, and then make lazy evaluation actually use a synchronized counter or something behind the scenes
15:31:13 <napping> You can pretend IO nondeterministically picks all the values when you call newSupply, so there's no observable impurity that way
15:31:25 <edwardk_> napping, erisco : concurrent-supply is made complex internally to reduce the amount of communication between threads.
15:31:58 <edwardk_> you can write a simpler thing using Data.Unique, but its orders of magnitude slower due to rendezvous costs
15:32:15 <napping> also Data.Unique is in IO
15:32:42 <edwardk_> napping: that too, though  was assuming you'd unsafePerformIO your way through it ;)
15:33:02 <edwardk_> the pain there is it breaks on old GHCs
15:33:12 <napping> I thought I remembered a pure version - there's uniqueid on hackage but it's marked deprecated
15:33:14 <edwardk_> for a while Data.Unique used a TVar under the hood
15:33:30 <edwardk_> there was a comonadic supply by lennart
15:33:55 <edwardk_> http://hackage.haskell.org/package/value-supply-0.6/docs/Data-Supply.html
15:34:02 <edwardk_> i made it actually comonadic in
15:34:25 <edwardk_> http://hackage.haskell.org/package/streams-3.2/docs/Data-Stream-Supply.html
15:35:10 <jle`> i just realized that printing something is a neat way to force something down to nf
15:35:24 <jle`> if it has a reasonable show instance
15:35:36 <napping> I think I might prefer a more contiguous range over less contention
15:35:43 <a3gis> edwardk_: by the way, I just saw your tweet about Munich; planning to come to edinburgh any time soon?
15:36:25 <edwardk> a3gis: its not on my travel schedule for this summer, but i won't rule it out eventually =)
15:36:45 <napping> Just considering how to replace an assigmnent of small integer ids to modules in a little compiler, which I'm now doing in a single thread at the end
15:37:00 <edwardk> munich and zurich are my main stops in europe this summer.
15:37:03 <napping> (after a parallel parsing/include chasing phase)
15:37:05 <a3gis> edwardk: London by any chance?
15:37:11 <bts-> i've gotten a little stuck going through the NICTA exercises here: http://bit.ly/1os4xsU. I understand the second of the highlighted examples, but the first is puzzling -- what's the type of the Monad f when the return value is simply the value (2,0)?
15:37:34 <napping> probably IO?
15:37:54 <bts-> hm interesting
15:38:51 <napping> not for any deep reason, just because the ghci prompt expectes values to either be a type in Show which is printed, or some IO a which is run, and then the result printed if printable
15:38:59 <edwardk> a3gis: amusingly i'm flying out of munich back to boston and from boston to zurich a week apart and very nearly took the time to stay in london and work out of our london office for the week and a half between, but couldn't really justify the stay without something i needed to do there
15:39:21 * hackagebot fsnotify 0.1 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.1 (RomanCheplyaka)
15:40:01 <napping> erisco: does concurrent-supply look like what you need? That sort of interface should be easier to use than threading around a counter of used names yourself, especially if you use threads
15:40:33 <bts-> napping: thanks
15:40:47 <a3gis> edwardk: haha ok, too bad :( hope to see you up in edinburgh at some point!
15:41:23 <edwardk> a3gis: find a conference or something that wants to fly me out to give a talk in the area and i'll show up =P =)
15:42:08 <merijn> Plenty of FP people in Edinburgh
15:42:17 <merijn> And St. Andrews isn't too far away either
15:43:25 <merijn> In attoparsec, which is more efficient? "char 'x' <|> char 'y'" or "satisfy (\c -> c == 'x' || c == 'y')"?
15:44:22 * hackagebot fsnotify 0.1.0.1 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.1.0.1 (RomanCheplyaka)
15:45:17 <benzrf> merijn: why not 'satisfy (`elem` "xy")`
15:45:24 <benzrf> or even
15:45:29 <benzrf> :t oneOf
15:45:30 <lambdabot> Eq a => [a] -> Splitter a
15:45:33 <benzrf> nvm
15:46:39 <merijn> benzrf: 'satisfy (`elem` "xy")' is 'satisfy (inClass "xy")' and the docs mention that explicit comparisons are more efficient than inClass
15:46:49 <benzrf> oh
15:47:39 <merijn> Actually inClass is better, it uses Set
15:49:36 <c_wraith> merijn: is it better for 2 elements?
15:50:06 <Fuuzetsu> there's concatMap but is there concatMapM?
15:50:17 <Fuuzetsu> at the moment I'm just using concat <$> mapM …
15:51:54 <benzrf> Fuuzetsu: that's like 5 chars of savings
15:52:01 <benzrf> let it be
15:52:02 <Fuuzetsu> 5 chars well saved
15:52:20 <Fuuzetsu> Just asking out of interest, if it's there then why not use it.
15:52:51 <gabor> edwardk: what is this Munich meetup? Just googled for TNG, is it a Haskell consultancy now?
15:53:48 <edwardk> gabor: i'm in munich for a conference thingy hosted by TNG. "TNG big tech day". I'm staying there through the weekend though, so some locals asked me if i wanted to hang out and bang on some code
15:54:07 <Fernandos> hi
15:54:24 <edwardk> my talk will be on cache-oblivious maps and some fancy data structures
15:54:47 <edwardk> the general conference is more computer science / tech than haskell / functional programming
15:55:06 <gabor> that sounds interesting. in the same spirit as your Budapest talk?
15:55:09 <edwardk> so i'm rather deliberately not trotting out all of the usual haskell talking points, just showing the kinds of things you can do with FP
15:55:14 <edwardk> bit different
15:55:31 <edwardk> budapest was all about succinct structures. this one is about cache-oblivious
15:55:49 <Fernandos> Is there a minimal web framework that you recommend? I'd like to built a single-page web application that offers symmetric encryption for urls in /lock/<id> and auth. to unlock these.
15:56:26 <edwardk> scotty is pretty minimalist
15:56:39 <Fernandos> I guess that should be really simple to implement (was about ~60LoC for an Express App with NodeJS)..
15:56:53 <merijn> heh
15:57:13 <merijn> > "foo\          \bar" -- I'm learning about obscure haskell parsing rules, yay!
15:57:15 <lambdabot>  "foobar"
15:57:15 <edwardk> gabor: i'll also have slides this time ;)
15:57:17 <hakujin> if you're familiar with Haskell Scotty will feel very similar to Express
15:57:46 <edwardk> merijn: that one is nice for writing big multiline strings without breaking the off-side rule
15:58:08 <edwardk> and without weird indentation
15:58:15 <merijn> edwardk: Yeah, I realise, I just didn't know :)
15:58:44 <edwardk> i tend to just use http://hackage.haskell.org/package/file-embed though
15:58:53 <edwardk> when it is big enough to need something like that
15:59:18 <merijn> Right, initial implementation of my parser finished, I'll postpone the "cleanup by equational reasoning" until after sleep :p
15:59:19 <edwardk> foo = $(embedFile "blah")
15:59:34 <grache28> When coming from another language to Haskell, did Haskell make you feel dumb at first?
15:59:42 <merijn> grache28: Exceedingly
15:59:43 <grache28> Coz I feel dumber than normal, right now
15:59:46 <edwardk> grache28: yes. it was glorious
15:59:58 <merijn> @quote carefully.gloss.over
15:59:59 <lambdabot> No quotes match. Wrong!  You cheating scum!
16:00:01 <merijn> aww
16:00:07 <merijn> @quote gloss.over
16:00:07 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
16:00:39 <edwardk> When i found haskell i pretty much assumed i knew programming / computer science as well as anyone. How wrong i was.
16:00:50 <merijn> Is there like a "haskell parsing torture bed" I can use to test I didn't bollocks up my parser?
16:01:04 <grache28> all im trying to do right now is write a function that removes duplice tuples from a list - over 2 hours and still haven't finish it :/
16:01:08 <edwardk> merijn: parsing haskell?
16:01:21 <merijn> edwardk: Well, I'm just lexing, tbh
16:01:32 <edwardk> grache28: nub?
16:01:37 <merijn> edwardk: I just don't feel like manually figuring out all the corner cases to test
16:01:41 <edwardk> > nub "hello"
16:01:42 <lambdabot>  "helo"
16:01:47 <glguy__> grache28: You might paste what you've got so far to http://lpaste.net
16:02:00 <glguy__> grache28: so that we can see how far along you are
16:02:14 <edwardk> > nub [(1,2),(2,3),(1,2),(3,4)]
16:02:16 <lambdabot>  [(1,2),(2,3),(3,4)]
16:02:51 <bitemyapp> grache28: just be aware that nub is really slow.
16:03:07 <edwardk> you can do better by going back and forth to Set if you don't care about order
16:03:21 <grache28> heh - thanks bitemyapp and edwardk
16:03:21 <edwardk> you can even preserve order with that approach, but its more work
16:03:26 <Fernandos> edwardk: thanks for the hint, I've heard about scotty alraedy.. was tinkering with a yeoman angularjs generator for scotty
16:03:30 <glguy> Is he trying to nub a list or learn how one would write the function to nub a list?
16:03:45 <merijn> glguy: I'm assuming the latter
16:04:10 <edwardk> glguy: i tend to solve the problem and then let folks chase the code from the existing solution, but probably the latter ;)
16:04:31 <merijn> grache28: The simple/inefficient is to recursively apply filters to the remaining list :)
16:05:23 <merijn> "filterDups (x:xs) = ??" do you know how to eliminate 'x' from 'xs'?
16:07:05 <grache28> ok -nubBy :: (a -> a -> Bool) -> [a] -> [a]
16:07:27 <grache28> i still don't understand how to read that signature or whatever you'd call it
16:07:58 <grache28> what I want to duplicate all inverses; i.e. (3,5) (5,3)
16:08:00 <merijn> grache28: What's your best guess for how to read it?
16:09:03 <grache28> looks at one elem, then another, does a boolean op, from a list gives a list
16:10:12 <merijn> grache28: So the parenthesis indicate the first part is a single argument
16:10:54 <merijn> So it's a function that takes "a -> a -> Bool" (that is the first argument is a function that does something with two a's and returns a Bool), the second argument is an '[a]' and the result is '[a]'
16:11:17 <grache28> ok that makes more sense, tks
16:11:34 <grache28> is there any explicit way to tell if one of the params is a function?
16:12:13 <merijn> grache28: The parenthesis
16:12:29 <grache28> ok tks merijn
16:12:48 <grache28> I see that \ is the lambda operator from a syntax guide, but what does that mean?
16:13:02 <hexagoxel> (plus the arrow, you could put paranthesis around any type)
16:13:02 <merijn> grache28: "a -> b -> c" <- this takes an 'a' and 'b' to returns a 'c', "(a -> b) -> c" takes a function of type "a -> b" and returns a 'c'
16:13:14 <monochrom> I would say, the -> means you're looking at a function type. the parentheses are there for parsing.
16:13:39 <merijn> grache28: Which text are you reading?
16:15:22 <grache28> merijn: my actual textbook isn't so great - so im googling and reading learn you a haskell
16:15:58 <carter> merijn: the whole ghc test suite + nofib ?
16:16:11 <grache28> i hate to leave when people are helping - but i have to run for a while - tks again
16:16:24 <monochrom> I wouldn't say \ is an operator. but \ means an anonymous function. you also have lambdas in c++, python, and java under various notations.
16:16:43 <merijn> carter: Hmm, good point, I should check that
16:16:56 <merijn> But first, sleep
16:17:05 <carter> yes
16:17:07 <carter> take care of yourself
16:24:24 <Fernandos> I've got a haskell file written by friend which shows most important language features in one file (unfortunately the comments are in german), however it's imho. the fastest way to jump-start into haskell. Maybe someone can enhance it and translate that, would that be of any interest?
16:25:06 <xexonixxexillion> This is going to sound like a really strange question, but is there anyway I can profile GHC's type inference?
16:26:18 <monochrom> perhaps it is a German tutorial instead :)
16:27:21 <carter> xexonixxexillion: build a profiled GHC :)
16:28:36 <xexonixxexillion> carter: That's actually not a bad idea
16:28:49 <Fernandos> xexonixxexillion: http://book.realworldhaskell.org/read/profiling-and-optimization.html
16:29:52 <acowley> Okay, I'm stumped about how to write down a type I want
16:30:48 <xexonixxexillion> Fernandos: I'm not profiling my code, I'm just doing weird things with the type system and it's taking longer than I expect for GHC to infer types for my code
16:31:23 <carter> what sort of types?
16:31:36 <carter> HM type inference alone has worst case expontial time :)
16:31:37 <Fernandos> xexonixxexillion: ah, gotcha.. sounds interesting!
16:31:45 <acowley> Okay, here we go http://lpaste.net/104153
16:31:47 <carter> theres certain types of nested lets
16:31:58 <acowley> Consider the definition of foo
16:32:13 <acowley> And how one can instantiate it at various types, like with bar and baz
16:32:29 <acowley> But now I want something that takes values of the type of foo in its full generality
16:32:43 <acowley> One attempt is myProc
16:32:49 <acowley> But this can not work as a mentions f
16:32:59 <acowley> that is, the type "a" mentions the quantified type "f"
16:33:38 <acowley> So then, how to write a type that looks like "f a" but quantify over f while having a mention f.
16:33:55 <acowley> Note that we can't quantify over "a", as "a" is fully determined by the choice of "f"
16:34:09 <acowley> We could existentially quantify over "a" perhaps
16:34:27 * hackagebot BoundedChan 1.0.3.0 - Implementation of bounded channels.  http://hackage.haskell.org/package/BoundedChan-1.0.3.0 (AdamWick)
16:34:48 <xexonixxexillion> carter: Just type level lists, trees and nats. One of my friends challenged me to do Huffman coding in in the type system (using fundeps), but it's taking longer to build my frequency tree than I'd expect
16:34:52 <grache28> merijn, et al: so I think I've got the carriage in front of the horse - I was just googling/scanning book to try and solve the problem. I didn't wanna go through an entire book learning how to do factorial and things like that I already knew. Looking at it now, it's not like going from C++ to Java - I need to learn how to think about problems in a 'functional' way. So I think now I should just go through a
16:34:54 <grache28> book/tutorial from start to finish and then try and solve my rather trivial (at least to me if done in an imperative language) problem.
16:35:08 <carter> xexonixxexillion: ahhh
16:35:10 <carter> what encodings?
16:35:14 <carter> peano or binary?
16:35:16 <carter> what ghc version?
16:35:38 <xexonixxexillion> peano and ghc 7.6.3
16:35:48 <carter> ahhhhhhh
16:35:52 <grache28> Which book / tutorial would you all recommend? The options I see that I can read immediately are Learn you a haskell & Real World Haskell
16:36:14 <xexonixxexillion> I don't think it's the numbers, but I'll implement 8-bit binary nats and see how that affects it
16:36:45 <carter> algorithm complexity matters
16:36:46 <carter> :)
16:38:04 <xexonixxexillion> O(n) addition 4 lyf
16:39:49 <monochrom> acowley: myProc compiles, I cannot reproduce the type error. how do I reproduce the type error?
16:40:21 <acowley> monochrom: Did you try applying "myProc foo" as in the example?
16:40:53 <monochrom> I haven't
16:41:13 <xexonixxexillion> derp… it is actually the numbers. That O(n) <= operation for my mergesort is what's taking all the time
16:42:08 <dmj`> grache28: I recommend the typeclassopedia
16:42:12 <dmj`> http://www.haskell.org/haskellwiki/Typeclassopedia
16:42:17 <acowley> I appreciate that what I'm trying to do is fairly awkward
16:43:38 <carter> xexonixxexillion: i was right?
16:44:29 * hackagebot highlighting-kate 0.5.8.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.1 (JohnMacFarlane)
16:47:02 <xexonixxexillion> carter: yeah; I'd forgotten just how many comparisons I needed to do to build my final frequency tree
16:47:09 <carter> :)
16:47:16 <carter> algoiithm complexity matters
16:47:23 <carter> especially when the code is slow
16:47:33 <carter> ^H^H^H^H is run at the type level ;)
16:50:27 <hakujin> do I need ghc-mod ('ghc' package) to get auto-complete working in haskell-mode for emacs?
16:50:34 <hakujin> I normally use vim
16:51:22 <flazz> binding question: let (a, b, c) = (b * 2, c / 4, 10) in (a,b,c) is it wrong to say this let binding is bidirectional?
16:51:41 <monochrom> grache28: I used to keep hearing "real world" programmers mocking factorial and fibonacci examples as "academic toys" "do you haskellers ever write a tutorial with real world examples". then, one day, I wanted to learn python, so I hopped over the official python tutorial and expect to see "real world" examples. you would fully expect that too, no?
16:51:57 <monochrom> to my surprise, its first example is fibonacci again
16:52:13 <monochrom> at that point I'm enlightened. programmers are such hypocrites.
16:52:43 <[swift]> real-world examples are usually a little too messy for your first exposure to a language, in my experience
16:52:48 <koala_man> they are academic toys. that's why they're used in teaching.
16:52:52 <flazz> ninegrid:
16:53:11 <flazz> monochrom: you might be using a very broad brush there
16:53:18 <timemage> monochrom, i think fibonacci is more of a tradition.  anyway, "real world" code doesn't usually have the qualities you're looking for in an example.
16:59:24 <enthropy> acowley: myProc :: forall a. (Show a, Num a, a ~ Int) => (forall f. (Applicative f, MyTy f ~ a) => f a) -> String
16:59:52 <enthropy> is partway there, but I don't see how to get rid of the a ~ Int
17:00:10 <acowley> enthropy: Yeah, that's an interesting direction
17:00:22 <acowley> enthropy: In general, my uses of MyTy are buried within a
17:00:29 <enthropy> probably you're better off making a GADT which has such a constraint
17:00:55 <acowley> Yes, it turns out my real use case makes every effort to leak f around quantifiers
17:00:58 <acowley> I mention f a lot
17:06:08 <monochrom> acowley: I'm wondering why foo requires MyNum (MyTy f) but not also Show (MyTy f), Num (MyTy f). my idea is that MyNum should be a subclass of Show and Num, "class (Show a, Num a) => MyNum a where <same thing as before>", and then myProc :: (forall f. (Applicative f, MyNum (MyTy f)) => f (MyTy f)) -> String
17:06:29 <monochrom> so myProc :: <literally foo's type> -> String
17:06:45 <acowley> My example is almost assuredly not water tight :/
17:07:40 <acowley> I think I just let the different type classes at play get out of sync there
17:08:00 <acowley> I had originally used Num instead of MyNum, and defaulting made some tests work that I didn't want to work
17:09:49 <monochrom> I think my scheme won't fall prey to defaulting, since it keeps MyNum around
17:12:47 <acowley> monochrom: That works if the argument to myProc has type "f (MyTy f)"
17:13:03 <acowley> monochrom: But if it's just "a", the dependency on MyTy isn't visible
17:13:52 <acowley> As one chases down forcing the equality, one ends up with enthropy's suggestion
17:14:00 <acowley> But then you end up overly restricting "a"
17:14:08 <acowley> i.e. you fix it
17:14:55 <monochrom> I am not convinced that "a" has all that much freedom. I changed "a" to "MyTy f". I think it is the most general already.
17:15:14 <acowley> It doesn't, it is fully determiend by "f"
17:15:19 <acowley> but this is the limitation of my example
17:15:28 <acowley> In my use case "a" might be a function
17:15:45 <monochrom> the generality comes from "forall f"
17:15:55 <acowley> and I refer to "MyTy f" in that function type
17:16:00 <acowley> Yes
17:16:22 <acowley> Suppose "a" was "MyTy f -> MyTy f"
17:16:42 <acowley> In my case, I'm doing things like printing out a function's type
17:17:07 <dpwright> I've launched ghci with "cabal repl", and then run ":l test.hs" to load a little test file I'm working with, but when I try to run "main" (defined in that file), it doesn't work
17:17:23 <dpwright> (test.hs isn't defined anywhere in the .cabal file and cabal knows nothing about it)
17:17:23 <acowley> So the forall f is the key point of flexibility, but we can't bind "a" in the type outside the forall
17:17:32 <dpwright> how should I be doing this?
17:17:38 <acowley> But neither is it universally quantified independently of f
17:18:04 <acowley> dpwright: In what way does it fail to work?
17:18:17 <dpwright> "Not in scope: 'main'"
17:18:38 <acowley> You can try :add
17:18:44 <monochrom> if you don't say "a ~ Int", but you say "a ~ MyTy []", is that better?
17:19:27 <acowley> monochrom: I don't think that will help with the case where I want to let "a" vary over function types
17:20:13 <dmj`> dpwright: does it work in plain ghci?
17:20:21 <dpwright> acowley: Thanks. Running that outputs "OK, modules loaded: Main", but then when I try to run main it still says "not in scope".  Also the prompt changes from the module I've defined in my cabal file (the one I'm working on), to just "Prelude"
17:21:48 <geekosaur> that may be significant actually; try Main.main
17:21:50 <geekosaur> or use :main
17:22:14 <dpwright> dmj`: difficult to tell as the libraries I'm using are installed in a sandbox, so ghci complains that it can't find the modules I'm using
17:22:19 <dmj`> dpwright: are you exporting main? "module Main where" exports main implicitly (if defined), but if you have something like "module Main () where" it won't...
17:22:25 <dpwright> geekosaur: I tried Main.main to no avail; I'll try :main now
17:23:00 <geekosaur> then it sounds like you didn't export it. technically ghc should have failed to compile it, or possibly failed to create an executable...
17:23:12 <acowley> monochrom: One can change foo to something like pure id :: MyTy f -> MyTy f
17:23:18 <dpwright> dmj`: I wasn't -- adding "module Main where" fixed it.  thanks!
17:23:26 <dmj`> dpwright: cool
17:23:45 <dpwright> (I had thought that was implicit for the Main module in a standalone haskell file)
17:24:32 <acowley> monochrom: And that top-level definition's type is nice enough to be instantiated at [Int -> Int] or Maybe (Float -> Float)
17:25:01 <acowley> monochrom: But I don't know how to keep it so polymorphic when taking as an argument
17:25:40 <acowley> dpwright: I've wrestled with the ways of loading modules into cabal repl a lot lately, too. You've got :m +, :load, import, :add
17:26:22 <dpwright> acowley: Yeah, :add was new to me.  I had tried with :m + and :load... import never quite seems to do what I expect
17:28:14 <acowley> import would be used for importing a module exposed by the component you're working with
17:28:25 <acowley> i.e. something mentioned in the current target in the cabal file
17:32:53 <zq_> e mk/bui
17:35:29 <chirpsalot> Hmmmm... Is there a way to make ghci behave the same way for `interact $ map toUpper` as it behaves when run with runhaskell or compiling with ghc first? It seems that ghci does not line buffer anything.
17:38:11 <chirpsalot> Also this only works once in ghci: *** Exception: <stdin>: hGetContents: illegal operation (handle is closed), which is kind of annoying when testing this stuff...
17:41:08 <dmj`> ghc -e "interact (map toUpper)"
17:49:48 <monochrom> acowley: can foo have this less restrictive type? (Applicative f, MyNum a) => f a
17:50:28 <monochrom> I guess you really want to say "f (MyTy f)" and "f (MyTy f -> MyTy f)"
17:50:45 <acowley> monochrom: yeah
17:53:22 <acowley> I guess part of the problem is that when you write the top-level type, you're writing a type abstraction over f, but then for something like myProc you're trying to have a type variable over all possible such abstractions
17:54:25 <acowley> But I hate being able to write something at the top-level that I can't adequately abstract over
18:16:32 <augur> anyone know if there is a weak form of higher order unification where instead of Pattern = Pattern you have just Pattern = Term?
18:16:44 <napping> higher-order pattern matching?
18:16:51 <napping> that's a thing, and even decidable
18:17:15 <augur> napping: :o
18:17:52 <augur> napping: <3
18:17:57 <augur> you're wonderful :D
18:20:00 <erisco> what is a higher-order pattern?
18:20:19 <hakujin> I want to fold over a list of Either String Int. what is a better way to do this than foldr (\x y -> x >>= (\z -> fmap (+ z) y)) (Right 0) [Right 1, Right 2, Left "fail"]?
18:20:23 <augur> erisco: a lambda calculus expression with metavariables/holes in it
18:21:02 <hakujin> (assuming addition)
18:21:30 <augur> erisco: eg   ?0 x = Foo x y   should solve ?0 = \x' -> Foo x' y   or   ?0 = \_ -> Foo x y
18:22:20 <augur> napping: im very glad you knew this. thank you so much
18:23:21 <napping> augur: Don't you work on agda?
18:23:35 <augur> napping: yes
18:23:35 <napping> I'm not entirely sure, but I think some of there inference uses this sort of thing
18:23:37 <augur> well
18:23:39 <augur> i work IN agda
18:23:40 <augur> not on it
18:24:04 <augur> but afaik agda doesnt try to do higher order unification-like problems. not sure why it would need to, either
18:24:18 <augur> ok tho, i need to run to the library to find some books
18:24:29 <napping> might be kinda new
18:24:33 <augur> thank you again, napping. i think you've saved me a lot of unnecessary thinking :)
18:24:35 <napping> http://lambda-the-ultimate.org/node/2211
18:24:44 <erisco> augur, why the notation "?0"
18:24:53 <augur> erisco: agda habbit
18:24:54 <augur> habit
18:24:55 <augur> hobbit
18:25:08 <erisco> rabbit
18:25:15 <napping> for things like inferring implicit parameters when you apply something, Agda sometimes needs to invent functional expressions
18:25:17 <augur> napping: yeah, thats what i found. i dont think any of that is used in agda tho
18:25:30 <augur> ok tho, seriously, by :P
18:25:35 <augur> bye
18:25:42 <napping> Conal also has a thesis, I think
18:46:27 <spott> How do I declare an Integer?  ghci says it isn't in scope, but it is in Prelude...
18:46:39 <chirpsalot> spott: what are you trying?
18:47:36 <spott> I'm attempting to read a character into a integer:  Integer . read
18:48:08 <hakujin> spott: Integer is a type and read is a function
18:48:21 <spott> ok, but what is the type constructor of Integer?
18:48:24 <napping> (read :: String -> Integer) will force it to return an integer
18:48:33 <enthropy> @let data I = Integer Integer
18:48:35 <lambdabot>  Defined.
18:48:43 <enthropy> > (Integer . read) "123"
18:48:45 <lambdabot>  No instance for (GHC.Show.Show L.I)
18:48:45 <lambdabot>    arising from a use of ‘M482977940137268294320869.show_M4829779401372682943...
18:48:47 <napping> :info Integer in ghci will show you the constructors, but that's really not what you wnat
18:48:52 <chirpsalot> let x = read "13" :: Integer
18:48:58 <napping> just implementation detauls
18:49:21 <chirpsalot> What's up with the ?M4829...?
18:49:23 <enthropy> @unlet
18:49:23 <lambdabot>  Define what?
18:49:27 <enthropy> @let data I = Integer Integer deriving Show
18:49:28 <lambdabot>  .L.hs:150:1:
18:49:28 <lambdabot>      Multiple declarations of ‘I’
18:49:28 <lambdabot>      Declared at: .L.hs:148:1
18:49:28 <lambdabot>                   .L.hs:150:1
18:49:28 <lambdabot>  
18:49:34 <enthropy> @unlet I
18:49:34 <lambdabot>  Parse failed: TemplateHaskell is not enabled
18:49:39 <enthropy> @undefined
18:49:39 <lambdabot> Undefined.
18:49:42 <enthropy> @let data I = Integer Integer deriving Show
18:49:43 <lambdabot>  Defined.
18:49:46 <enthropy> > (Integer . read) "123"
18:49:48 <lambdabot>  Integer 123
18:50:20 <enthropy> please don't take this abuse seriously
18:50:30 <napping> spott: read works based on the result type, so you just have to use the answer the way you wnat
18:50:49 <napping> The annotation like chirpsalot showed is a simple way to be sure
18:51:06 <spott> napping: thanks, I wasn't
18:51:27 <hakujin> please ignore enthropy too haha
18:53:44 <spott> thanks to everyone actually, that is useful.
18:54:02 <spott> still, is there something special about [Char]?
18:54:29 <spott> I'm attempting to map over a string, but it won't work
18:54:43 <enthropy> > map pred "spott"
18:54:45 <lambdabot>  "ronss"
18:55:08 <spott> :info pred
18:55:20 <spott> what is pred?
18:55:22 <enthropy> > pred 's'
18:55:23 <lambdabot>  'r'
18:55:34 <spott> ah
18:55:38 <dmj`> @src pred
18:55:38 <lambdabot> Source not found. There are some things that I just don't know.
18:55:57 <dmj`> > map toUpper "spott"
18:55:58 <lambdabot>  "SPOTT"
18:56:18 <bobajett> I have a toy problem. I have a list of train times xs = ["7:04","9:20","3:20","4:20"].
18:56:38 <bobajett> For simplicity's sake lets assume [7,9,3,4]
18:57:30 <bobajett> the problem is to split them into AM and PM times - the given times are always in ascending order. splitByAmPm xs => [[7,9], [3,4]]
18:57:40 <bobajett> how do I write this function :-)
18:57:44 <spott> what am I missing here:
18:57:47 <spott> > let digits = map (\x -> (read :: Char->Integer) x)
18:57:48 <lambdabot>  not an expression: ‘let digits = map (\x -> (read :: Char->Integer) x)’
18:57:55 <erisco> bobajett, but what if you only have PM times?
18:58:09 <spott> weird, it works in ghci
18:58:17 <ParahSailin> bobajett: probably best to struggle it out on your own
18:58:23 <dwcook> spott: You need an "in". let { bindings } in expression
18:58:25 <bobajett> erisco: we'll ignore that case :-)
18:58:33 <bobajett> ParahSailin: I did. My solution isn't very elegant.
18:58:38 <ParahSailin> show it
18:58:40 <dwcook> spott: ghci is weird. It uses both top-level and do-notation syntax.
18:58:47 <erisco> > groupBy (<) [7,9,3,4] -- bobajett
18:58:48 <lambdabot>  [[7,9],[3,4]]
18:59:10 <bobajett> erisco: ah ha! and the reason why I asked on #haskell is how do you do [7,9,12,3,4] ;-)
18:59:15 <spott> > digits = map (\x -> (read :: Char->Integer) x)
18:59:16 <lambdabot>  <hint>:1:8: parse error on input ‘=’
18:59:34 <spott> dwcook: argh, well, I can't figure out how to show the error I'm getting
18:59:53 <bobajett> because you want [[7,9],[12,3,4]]
18:59:59 <hakujin> > map read ["12", "13", "14"] :: [Int]
19:00:00 <lambdabot>  [12,13,14]
19:00:03 <spott> basically it is complaining that the function isn't Char -> Integer
19:00:35 <dwcook> spott: show the ghci input and output in a paste
19:00:59 <dwcook> Oh never mind, it's obvious
19:01:00 <napping> read is always String  -> whatever
19:01:02 <dwcook> @type read
19:01:03 <lambdabot> Read a => String -> a
19:01:08 <dwcook> String, not Char
19:01:19 <napping> and String is just [Char]
19:01:24 <spott> yea
19:01:24 <dwcook> [Char] is also acceptable
19:01:27 <napping> map (\c -> read [c] :: Integer) "123"
19:01:30 <erisco> > groupBy (<) . fmap (flip mod 12) $ [7,9,12,3,4] -- bobajett
19:01:31 <lambdabot>  [[7,9],[0,3,4]]
19:01:42 <spott> napping: thanks
19:01:52 <napping> > groupBy (<) [7,9,8]
19:01:53 <lambdabot>  [[7,9,8]]
19:02:06 <napping> erisco, bobajett: Is that really the behavior you want?
19:02:27 <napping> groupBy compares everything with the first item in the run, not with the neighbor
19:02:29 <dmj`> > groupBy (\a b -> if a < 11 && a < b then True else False) [7,9,12,3,4]
19:02:31 <lambdabot>  [[7,9,12],[3,4]]
19:02:59 <bobajett> napping: yep Im aware of the groupBy problem.
19:03:19 <bobajett> napping: http://www.haskell.org/haskellwiki/List_function_suggestions#Generalize%5FgroupBy%5Fand%5Ffriends
19:03:57 <hakujin> I want to combine Eithers with a monoid like interface. Is there a better way than >>= fmap?
19:04:08 <bobajett> dmj`: sorry? the correct solution is [[7,9],[12,3,4]]
19:06:11 <dmj`> oh
19:09:22 <erisco> bobajett, is my solution sufficient?
19:09:50 <erisco> > groupBy (on (<) (flip mod 12)) [7,9,12,3,4] -- there is also this bobajett
19:09:52 <lambdabot>  [[7,9],[12,3,4]]
19:10:09 <bobajett> cool!
19:10:49 <napping> hakujin: what monoid?
19:10:56 <bobajett> erisco: thanks, that's cool. Im going to try to figure out how that works now.
19:12:06 <napping> erisco: what about [7,12,8] ?
19:12:25 <erisco> napping, what about it?
19:12:26 <hakujin> napping: Sum
19:12:39 <hakujin> something like Either String Sum
19:12:42 <bobajett> how do I search for what "on" is? That's a hard one to google for :-)
19:13:09 <bobajett> > groupBy (on (<) (flip mod 12)) [7,12,8]
19:13:10 <lambdabot>  [[7],[12,8]]
19:13:16 <erisco> :t on
19:13:17 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
19:13:23 <napping> > groupBy (on (<) (flip mod 12)) [7,11,8]
19:13:24 <lambdabot>  [[7,11,8]]
19:13:38 <napping> that should split as 7 AM / 12 AM / 8 PM
19:13:40 <bobajett> napping: nice catch
19:13:53 <napping> groupBy just isn't going to work for this
19:14:10 <erisco> oh, it behaves differently than I thought
19:14:30 <napping> groupBy (<) would be enough if it worked the other way
19:14:50 <erisco> I suppose with 'group' it is irrelevant, so that is probably why groupBy is written that way
19:14:53 <bobajett> erisco: http://stackoverflow.com/questions/1316365/haskell-surprising-behavior-of-groupby :-)
19:15:09 <erisco> well rewrite groupBy to be less dumb
19:15:30 <dwcook> bobajett: you can often find even functions with names that are common words using Hoogle.
19:15:31 <dwcook> @hoogle on
19:15:32 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:15:33 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
19:15:33 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
19:16:00 <bobajett> dwcook: cool! Did not know that.
19:16:23 <dwcook> I usually use the web interface but it's also available on command line. cabal install hoogle
19:16:28 <hakujin> napping: I actually want bind's behaviour to combine the Eithers but mappend's behavior for the Rights inside
19:16:38 <erisco> bobajett, so your challenge then is to rewrite groupBy to behave properly
19:16:43 <napping> hakujin: what should happen for left?
19:16:57 <hakujin> same as bind, entire computation becomes left
19:17:03 <napping> what if both are left?
19:17:14 <hakujin> left a >>= left b = left a
19:17:25 <napping> Hmm, I guess that would still be a monoid
19:17:31 <napping> But a bind?
19:17:36 <napping> or a monoid operations
19:17:47 <napping> instance (Monoid a, Monoid b) => Monoid (Either a b) wouldn't be too hard
19:17:54 <bobajett> erisco: on it!
19:18:02 <hakujin> how do you write mempty for Left?
19:18:18 <napping> What do you mean "for Left"?
19:18:58 <hakujin> I guess "how do you write mempty for Either" is more correct
19:19:05 <napping> Right mempty
19:20:15 <hakujin> ah, yes but that doesn't preserve the propagation of Left
19:20:34 <napping> You can wrap in First for that
19:20:48 <napping> or hardcode it and get instance (Monoid a) => Monoid (Either err a)
19:21:01 <hakujin> good call on First, thanks
19:21:20 <napping> or you might want MonadPlus
19:21:44 <napping> Ah, Control.Monad.Error already defined a instance MonadPlus (Either e)
19:22:09 <napping> wait, that can't merge the values
19:22:28 <napping> just takes the left
19:22:32 <hakujin> yeah I don't think msum will do what I want there
19:25:08 <TallerGhostWalt> there doesn't happen to be a package to look through cabal to see the first time a function is defined?
19:26:32 <hakujin> TallerGhostWalt: hoogle might help you trace down where functions originate
19:27:52 <TallerGhostWalt> i always have terrible luck with hoogle, i'll give it a try though thx
19:28:20 <augur> napping: back and reading
19:29:02 <bobajett> erisco: ok using a sane defintion of groupBy your solution works perfectly. And that is just magic!
19:29:23 <napping> conal: Is your thesis a decent introduction to higher-order unification algorithms? augur is interested in pattern matching
19:30:59 <conal> napping: it might be tough going for him. he could try the huet & lang paper on 2nd order matching first and then huet's HOU journal paper.
19:31:14 <augur> conal: tough for me? pah!
19:31:17 <augur> lay it on me!
19:31:22 <copumpkin> augur: have you read Saizan's thesis on miller pattern unification?
19:31:22 <napping> augur: that link I sent doesn't obviously describe an algorithm, but I found some things mentioning Huet's algorithm is a semidecision procedure for higher-order unification (at least on simply-typed lambda calculus), so on a domain where you know it's decidable it will just work
19:31:37 <conal> IIRC, huet & lang is pretty approachable.
19:31:41 <augur> conal: no, i didnt even know saizan had a thesis
19:32:24 <copumpkin> augur: https://github.com/Saizan/miller
19:32:49 <copumpkin> not sure where the associated writing is
19:33:41 <napping> Does this "pattern unification" sound like enough?
19:34:11 <copumpkin> it's a restricted form of HOU, so no
19:34:15 <copumpkin> but it's worth looking into I think
19:34:49 <napping> copumpkin: augur was asking specifically about higher-order pattern matching
19:34:55 <copumpkin> ah
19:35:53 <augur> yeah, basically what i want to do is, given some grammatical rules like   S -> NP VP   and associated semantic composition rules like   eval (S np vp) = eval vp (eval np)
19:36:10 <augur> where eval is just boring LC stuff, nothing fancy
19:36:27 <augur> can this be run backwards to generate sentences instead of interpret them
19:36:51 <augur> at each stage taking a piece and "de-evaluating" it
19:38:04 <augur> for instance, eval "John is tall" might be something like   Present (Tall John)   where eval "is" = \f x -> Present (f x) etc.
19:39:07 <augur> so then you'd want to say, ok, Present (Tall John) =? ?vp ?np where ?vp :: NP -> S, and ?0 :: NP
19:39:37 <augur> so how to "de-evaluate" this? the right solution of course:  ?np = John,  ?vp = \x -> Present (Tall x)
19:40:41 <augur> and so on, down until you have either successful decompositions down to leaf nodes, or you fail somewhere
19:42:52 <napping> it sounds like that goes beyond the pattern fragment
19:43:42 <augur> it might, who knows. i dont need it to be decidable in general. just decidable often-enough :p
19:43:47 <napping> I guess the journal paper is "A unification algorithm for typed \lambda-calculus", but it doesn't seem to be available online
19:44:07 <augur> yeah, i cant find it online for free. im going to look around through web archives of TCS
19:44:26 <napping> you can get conal's thesis, if you haven't already
19:44:56 <augur> anyway, i dont need complicated disunifications, actually, mostly its just/only a single function application
19:45:25 <roconnor> @src replicateM
19:45:25 <lambdabot> replicateM n x = sequence (replicate n x)
19:45:33 <roconnor> @src replicate
19:45:33 <lambdabot> replicate n x = take n (repeat x)
19:45:41 <augur> so in principle it ought to be relatively simple -- pluck out all subterms of the same shape, with the right type, and try that
19:45:45 <roconnor> > take (-3) [1,2,3]
19:45:46 <lambdabot>  []
19:45:47 <augur> im not sure that's enough tho
19:46:28 <augur> i mean, given   Present (Tall John)   there are 5 subterms you can abstract over, obviously -- Present, Tall, John, Tall John, and Present (Tall John)
19:47:56 <augur> so you can pull those out :   (\p -> p (Tall John)) Present   or   (\f -> Present (f John)) Tall   or   (\x -> Present (Tall x)) John   or   (\s -> Present s) (Tall John)    or   (\s -> s) (Present (Tall John))
19:48:33 <augur> and only the third will type check appropriate as   (\x -> Present (Tall x)) :: NP -> S   and   John :: NP
19:48:46 <augur> but, i dont know if this generalizes, so...
19:51:28 <augur> you'd probably have to also handle multiple copies of the same thing some how, and i guess also the possibility of vacuity, but i doubt vacuity is a problem for this context
20:00:00 <augur> i wonder
20:00:14 <augur> napping: is HOU undecidable because it doesnt terminate?
20:00:25 <augur> or is it undecidable because there is no unique answer?
20:00:37 <augur> both of those could plausibly be what is meant by "undecidable" in this context
20:05:42 <napping> If you could decide when there was no solution and enumerate solutions, it wouldn't be undecidable
20:06:36 <augur> napping: yeah, i guess if decision in this case is taken to mean enumerate all possible solutions, then it must not be what i described
20:08:43 <napping> semi-decision means it's not guaranteed to terminate if there isn't an answer
20:08:53 <augur> sure
20:08:58 <augur> im happy with timeouts :p
20:09:31 <augur> i need a fast system anyway. anything that cant be solved in milliseconds is too complicated
20:09:46 <augur> i wonder tho if the simple reverse beta approach would actually work...
20:10:44 <napping> perhaps the decidable second-order fragment would be useful?
20:10:53 <napping> I don't really know much about this stuff, just that it exists
20:11:05 <augur> you'd need an unsubstitution operation which would be relatively easy i think
20:11:07 <c_wraith> What's the name for when it can return true, false, or I didn't find an answer?
20:11:38 <erisco> c_wraith, Maybe Bool?
20:11:38 <augur> c_wraith: Maybe Bool!
20:11:49 <augur> napping: ill check it out
20:11:54 <c_wraith> Not the type, the name for the kind of solving that is. :P
20:11:54 <napping> I don't think that's distinguished as a class of algorithms
20:12:04 <napping> It
20:12:10 <erisco> data Check = True | False | File_Not_Found
20:12:15 <napping> It's not really a solution at all if it just gives up in finite time
20:12:27 <augur> c_wraith: i dont know that there's a particular name
20:12:57 <napping> and if you can do more work to try to get a better answer, then it comes back to a decision procedure or semidecision procedure, depending whether you're guarnateed to get an answer if you wait long enough, and which side potential nontermination falls on
20:14:05 <TallerGhostWalt> so is unsafePerformIO used a lot? Cause I have never ever used it but when I go on something like /r/ocaml I see a lot of people dismissing the entire safety of haskell b/c of it
20:14:08 <TallerGhostWalt> really weird
20:14:29 <erisco> because it does dismiss the entire safety :P
20:14:46 <napping> augur: Curien's "Efficient Second-Order Matching" can be found online, and seems to review the huet algorithm before giving theirs
20:14:47 <augur> the more you use UnsafePerformIO, the more evil you are
20:15:07 <augur> napping: cool, ill check it out, thank you :)
20:15:24 <TallerGhostWalt> erisco: it makes haskell unsafe, sure but does it's existence make haskell's safetey illusory
20:15:41 <erisco> TallerGhostWalt, yes
20:16:01 <TallerGhostWalt> erisco: So just marketing then?
20:16:04 <napping> TallerGhostWalt: sounds like people looking for excuses
20:16:12 <erisco> most languages rely on the programmer doing the right thing
20:16:22 <napping> The proof obligation on unsafePerformIO is that you not do anything observably impure
20:16:25 <TallerGhostWalt> erisco: most?
20:16:26 <dwcook> Haskell woud be unsafe even without unsafePerformIO. How about bottom?
20:16:34 <TallerGhostWalt> erisco: does one not?
20:16:44 <dwcook> The idea is to avoid using those things in cases where they'd be unsafe
20:17:00 <napping> So if people either don't use it or use it properly, it doesn't comporomise the usual reasoning you want from the language
20:17:08 <dwcook> Of course, almost every programming language has bottom whether it's seen as a value or not
20:17:27 <napping> I dare say it's better to consider it as a value
20:17:39 <c_wraith> it's at least more regular to consider it a value.
20:17:44 <napping> Remembering for example Harper's blog post on the subject
20:17:46 <shachaf> Not an effect?
20:17:59 <napping> leaving bottom out of values may very well make reasoning about values simpler, but as programmers we deal in expressions
20:18:11 <shachaf> dwcook: Haskell would be unsafe even without bottom. How about the string "run with scissors"?
20:18:18 <mizu_no_oto> I'm trying to build a cross compiler on OSX to the Pi, and running "./configure --target=arm-linux-gnueabihf --enable-unregisterised" on the 7.8.2 source is currently throwing the error "checking for ar arguments... configure: error: cannot figure out how to use your .../bin/arm-linux-gnueabihf-ar"
20:18:25 <mizu_no_oto> Am I totally SOL?
20:18:43 <dwcook> shachaf: Don't even get me started on Prelude.launchTheMissiles :: IO ()
20:19:42 <TallerGhostWalt> lol
20:20:49 <TallerGhostWalt> So the response is sort of, everything is unsafe?
20:21:30 <dwcook> TallerGhostWalt: Haskell is safe as long as you don't use it unsafely. :)
20:21:45 <TallerGhostWalt> dwcook: like everything else
20:22:04 <TallerGhostWalt> seems like ppl should stop talking about safety then
20:22:20 <dwcook> Statements about "everything" make me nervous
20:22:24 <erisco> it is not an all or nothing deal
20:22:38 <erisco> there is value to being more safe
20:23:23 <TallerGhostWalt> dwcook: consider it hedged
20:23:33 <TallerGhostWalt> *almost everything*
20:23:47 <dwcook> I think erisco stated it well. In other words, safety is a continuum.
20:23:51 <shachaf> dwcook: I think I was trying to make a point (that "safe" is a meaningless word, or not useful if you define it to mean whatever you want when you say it).
20:24:00 <shachaf> I'm not sure I understand your response.
20:24:22 <dwcook> shachaf: I thought you were just trying to be funny. I responded in kind.
20:24:27 <napping> TallerGhostWalt: It's safe unless you use certain clearly-labelled potentially unsafe things, which people rarely need to use, and which have instructions on what using them safely means
20:24:47 <TallerGhostWalt> napping: I don't think that is what other ppl are saying
20:25:06 <napping> for some value of safe including memory safe, type safe, and referentially transparent in pure code
20:25:09 <TallerGhostWalt> napping: that is where I was heading but then I got confused
20:25:25 <TallerGhostWalt> napping: because the response was more like, nothing is safe abandon all hope
20:25:42 <napping> That depends what "safe" you want
20:25:45 <TallerGhostWalt> which is fine, just unexpected... The gradient is more what I was thinking
20:25:49 <TallerGhostWalt> I am down with that
20:25:49 <napping> avoiding nontermination, perhaps
20:26:47 <TallerGhostWalt> type-safety and lack of side effects
20:26:51 <TallerGhostWalt> are what I mean
20:26:58 <TallerGhostWalt> or explicit side effects
20:27:22 <dwcook> In my opinion, Haskell's type system permits fewer incorrect programs than most other languages, for some value of "incorrect".
20:27:33 <TallerGhostWalt> lol, I like it
20:27:39 <TallerGhostWalt> I might want it on a shirt
20:28:04 <napping> But type-safety has a precise meaning, whether or not the type system is decent
20:32:31 <TallerGhostWalt> Yeah, I was mostly wondering how much things like unsafePerformIO actually occur.
20:33:25 <dwcook> A small proportion of Haskell code, in my experience.
20:33:51 <dwcook> I've seen it used to create a module-global IORef in Data.Unique and in not many other places.
20:34:26 <napping> There's also inlinablePerformIO
20:34:37 <erisco> unsafeInterleaveIO
20:34:42 <napping> I think it's used a fair bit inside ByteString
20:35:01 <napping> but any call without observable side effects also doesn't break anything
20:35:17 <napping> So it's not just how often it's used, but how often it's used badly
20:35:23 <dwcook> Note that Data.Unique could avoid the use of unsafePerformIO if you explicitly passed an IORef to newUnique.
20:35:41 <napping> uglymemo for example uses unsafePerformIO
20:36:04 <carter> done use inline perform io
20:36:05 <carter> everrrrr
20:36:06 <dwcook> That is if you made newUnique have type IORef Unique -> IO Unique.
20:36:14 <dwcook> Sorry, IORef Integer.
20:37:04 <dwcook> But at that point you might as well implement a non-IO function for producing Uniques, which loses you the uniqueness guarantee. (You can use it in such a way that you produce the same Unique twice.)
20:41:31 <TallerGhostWalt> There should be an unsafe version of everything, it can be bundled together in 'evil-base'
20:42:13 <dwcook> Unsafe in what sense?
20:42:38 <TallerGhostWalt> just the 'unsafe' in 'unsafePerformIO' , i was just kidding
20:43:21 <jmcarthur> unsafePerformIO is usually used to implement new "primitives", and the unsafe stuff will usually be hidden behind a module boundary.
20:43:44 <TallerGhostWalt> right, like the MVar and STM stuff
20:44:14 <TallerGhostWalt> seems like a perfectly acceptable use of it.
20:44:41 <TallerGhostWalt> I think that partials are the much bigger problem in haskell code.  fromJust should get renamed 'unsafeFromJust'
20:45:06 <dwcook> Fortunately there are safe alternative to many of those, such as case expressions
20:45:12 <dwcook> In the case of maybe, there's also
20:45:13 <dwcook> @type maybe
20:45:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:45:34 <dwcook> (which is just a case analysis)
20:45:53 <TallerGhostWalt> yeah good stuff
20:46:22 <TallerGhostWalt> is there a way to make it where incomplete case expressions are an error instead of a warning?
20:46:24 <dwcook> On lists you have folds as well as safer functions such as drop and take
20:46:36 <dwcook> ("safer" compared to head and tail)
20:47:10 <dwcook> (or I was thinking of (!!) in particular when I said drop and take)
20:48:10 <dwcook> TallerGhostWalt: -Werror probably?
20:48:17 <dwcook> That makes warnings errors
20:49:14 <TallerGhostWalt> i might start using that, even though I think 'defaulting to String" or something is really irritating
20:49:42 <TallerGhostWalt> oh wait , so I would surpress that warning and maybe a few others and then let the rest error out
20:50:52 <Welkin> there is a safe head and safe tail I thought
20:51:21 <dwcook> Yeah there are, but I don't think they're in base. Correct me if I'm wrong
20:51:41 <Welkin> not in prelude
20:51:42 <dwcook> You can do something almost like tail by using drop 1, which just gives you [] instead of an error.
20:52:02 <dwcook> But that's not as good as Maybe [a], I'd say.
20:52:28 <TallerGhostWalt> wow I was just looking through the list of warnings, incomplete record updates... not turned on by default with -Wall?
20:52:47 <TallerGhostWalt> I make those stupid mistakes so much
20:53:00 <dwcook> Incomplete record update? If I understand that correctly, that's not considered bad
20:53:36 <Welkin> @hoogle safeHead
20:53:37 <dwcook> Oh, never mind, I just read the docs
20:53:37 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
20:53:38 <lambdabot> Data.Text.Unsafe unsafeHead :: Text -> Char
20:53:41 <napping> It would make more sense to have an option when you defined a multiple-constructor data type with record syntax
20:53:45 <dwcook> I didn't understand it correctly
20:53:53 <napping> have an option to make than an error, I mean
20:54:01 <Welkin> http://hackage.haskell.org/package/safe
20:54:08 <TallerGhostWalt> I am surprised it isn't at least a warning, it must be really noisy in some other case or something
20:54:17 <TallerGhostWalt> i mean a warning in -Wall obv
20:54:20 <napping> Well, every single time you use record syntax on such a data type
20:54:30 <dwcook> First-class patterns sure would be nice
20:54:39 <napping> associated pattern synonyms...
20:54:45 <TallerGhostWalt> prism is a step towards it
20:54:58 <TallerGhostWalt> are there lang. with first class patterns?
20:55:54 <napping> TallerGhostWalt: defining a type with multiple constructors, and giving it record syntax, and making some fields only exist on some constructors is the problem there
20:55:56 <TallerGhostWalt> napping: what is an associated pattern synonym?
20:56:08 <napping> warning every time you use record syntax on that type probably is too noisy
20:56:15 <napping> well, there's pattern synonyms now
20:56:29 <napping> the idea is that you could declare the name and signature of a pattern synonym in a type class
20:56:49 <chirpsalot> Hmmmmm... I want something like Eq a => [(a, b)] -> [(a, [b])]
20:56:51 <napping> although really, view patterns plus putting an appropriate method in a class gets you pretty close
20:57:49 <chirpsalot> So, like [(1, 2), (2, 1), (1, 3)] to [(1, [2, 3]), (2, 1)]... I can't think of a good way, and hoogle doesn't bring me joys.
20:58:10 <chirpsalot> Well, I can do it, but it seems uglier than it should be.
20:58:24 <dwcook> chirpsalot: I think MultiMap does what you want
20:58:43 <dwcook> from the package multimap
20:59:03 <chirpsalot> dwcook: ... Oh, so that's exactly what I wanted.
20:59:10 <chirpsalot> dwcook: thanks XD
21:00:00 <dwcook> Though it additionally requires Ord
21:00:29 <chirpsalot> dwcook: naturally :). That's fine by me because I am trying to stuff this all in a Map anyway >_<
21:01:07 <napping> Why not just do that then?
21:01:13 <napping> Map.fromListWith (++) or something
21:01:31 <napping> after the obvious [(a,b)] -> [(a,[b])]
21:01:51 <dbelange> fromRussiaWith (<3)
21:02:08 <davidthomas> dbelange: props
21:03:04 <chirpsalot> napping: uh... This is an excellent point... Missed this XD.
21:03:25 <chirpsalot> napping: I've even used this before -- guess I forgot it existed! Thanks :).
21:21:07 <augur> napping: aha, my simplistic un-substitute approach wont work :)
21:22:24 <codygman> Why am I getting this instance error? I am almost copying the aeson example: http://lpaste.net/104157
21:23:12 <napping> Isn't .= used for constructing objects?
21:23:26 <napping> .: for extracting?
21:26:17 <napping> Yeah, just change to .: everywhere in your fromJSON and it should work
21:35:22 <justgage> Hey guys I'm /very/ new to haskell. I was wondering, I wanted to make an auto-formater code formater kind of like go-fmt for those familliar, would this be somthing that haskell (or any purely functional language) be good at?
21:38:45 <IanKelling> yes
21:39:54 <justgage> IanKelling: was that an answer to my question?
21:42:28 <zzing> If I have a module 'A.B.C' in a file + path called src/frameworks/C.hs   and it is being imported in src/main.hs   what do I have to do to let ghc know where to find this file?
21:46:15 <c_wraith> zzing: I don't know that it's possible to tell GHC to find a module that's not in a path matching it module structure.
21:46:37 <codygman> napping: Thanks
21:46:43 <zzing> c_wraith, I just renamed the directory structure to A/B/C.hs  and it doesn't find it
21:47:02 <c_wraith> zzing: as in, it'd need to be in src/frameworks/A/B/C.hs , and then you'd pass ghc -isrc/frameworks
21:47:37 <zzing> I think I might have it
21:47:42 <zzing> Got the file structure working
21:47:43 <zzing> merci
21:47:47 <codygman> Do I need to add RankNTypes to be able to put these types of numbers in the definition of an ADT: Fractional t => [[t]]
21:47:57 <codygman> [[-122.42200352825247,37.80848009696725,0.0],[-122.42207601332528,37.808835019815085,0.0]]
21:55:38 <zzing> ghcjs project building with cabal now :-)
21:59:39 <codygman> I'm pretty sure I shouldn't have to have a Geometry and GeometryContainer ADT to parse this json, is there a better way? http://lpaste.net/104158
22:18:09 <nipple> how shitty is this nick
22:20:05 <jle`> justgage: yes. haskell is exceptionally good at parsers and AST manipulation
22:22:14 <supki> codygman: see my annotation
22:29:00 <codygman> supki: Thanks
22:31:12 <sloopjohnb> this has to be the most productive irc of all time
22:41:50 <napping> porting code from SHE back to PatternSynonyms doesn't seem too hard
22:42:40 <napping> at least for Gundry's pattern-unification code which doesn't use the dependently typed stuff much
23:00:13 * hackagebot cabal-test-quickcheck 0.1.2 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.2 (TimothyJones)
23:02:44 <codygman> Can anyone tell me 1) Why this won't get results from the bigger citylots.json and how to debug it (https://github.com/zemirco/sf-city-lots-json/blob/master/citylots.json) 2) why it takes so long (17 seconds) to print out "no results":  http://lpaste.net/104160
23:03:43 <marko2> hi! anyone got a little experience with pipes-concurrency?
23:04:09 <marko2> just wanted to ask if there is a functional difference between the Unbounded, Bounded and Single Buffer type except for memory consumption
23:05:37 <LordBrain> 189778.22 kb (Sorry about that, but we can't show files that are this big right now.)
23:05:38 <LordBrain> heh
23:06:21 <codygman> LordBrain: lol yeah, I just downloaded it
23:11:11 <codygman> I'm going to sleep, but I'll check back for answers in the morning. I also plan on profiling in the morning, but would like to know if I did anything obviously/horribly wrong or naieve in the example I posted above.
23:11:17 <codygman> thanks all
23:11:51 <solidus-1iver> anyone have thoughts on fay vs haste?
23:12:01 <solidus-1iver> wanting to experiment writing some javascript libs in haskell
23:12:17 <solidus-1iver> but its important that they are effecient / compile to reasonably sized js
23:13:42 <lispy> solidus-1iver: I don't think fay is true haskell
23:13:49 <solidus-1iver> its not, its a subset
23:13:57 <lispy> solidus-1iver: I'd try ghcjs first, personally
23:14:00 <solidus-1iver> it doesnt do type-classes
23:14:08 <solidus-1iver> i heard ghcjs produce humongous code
23:14:12 <solidus-1iver> and isn't very well optimized
23:14:40 <lispy> Will you be using any packages or rolling everything yourself?
23:15:12 <lispy> I can't speak for haste (never heard of it until now), but I think that's a reason to use ghcjs. Better petting compatibility.
23:15:19 <LordBrain> hmm this is the first i'm hearing of fay
23:15:23 <solidus-1iver> well, i'd like to take advantage of using haskell packages but I would most likely have to roll everything myself
23:15:31 <lispy> er, better packing compat
23:15:39 * lispy is a bit tired
23:15:47 <solidus-1iver> i want to use it to prototype why haskell is a good idea for complex javascript libraries at my workplace
23:16:17 <lispy> If you go down that path, be prepared to pay a very high early adoptor tax.
23:16:35 <lispy> And guess what your co-workers will blame as they see you paying it?
23:16:55 <lispy> I find selling technology solutions to co-workers to be very tricky.
23:17:18 <solidus-1iver> lispy: heh, aye, i don't think they'll adopt it, i'm kinda curious myself
23:17:26 <solidus-1iver> and would love to have something reasonable to show them at the end of experimenting
23:18:27 <lispy> I wish you the best. It's a good cause for sure.
23:18:33 <solidus-1iver> it looks like ghcjs doesnt have a way for you to call haskell code from javascript
23:18:36 <lispy> Right now, I need sleep. Good luck!
23:18:56 <codygman> solidus-1iver: I was trying to do the same, be warned that ghcjs's exporting functions so they can be used from javascript is was clunky last time I checked. However a project contributor said they would make it as simple (like Haste)
23:19:26 <codygman> solidus-1iver: It does, I just couldn't figure it out lol. It is supposed to be fixed whenever it is gotten to ;)
23:19:36 <codygman> perhaps you should request it in #ghcjs
23:22:43 <solidus-1iver> codygman: good idea :)
23:23:05 <carter> solidus-1iver: i will say this, luite (who does most of the ghcjs dev) is one of the most insanely thoughtful / thorough / hardworking / smart dudes I know
23:23:23 <carter> (he's awesome :) )
23:24:13 <hamishmack> carter: Seconded.
23:24:31 <carter> like, you should feel safe with any tool he's the maintainer of
23:25:18 <carter> in a buff ball of kevlar spider silk wool harvested from new zealand alpacas
23:25:23 <carter> that doesnt exist
23:25:25 <carter> but it should
23:26:04 <codygman> carter: I *totally* agree.
23:26:05 <hamishmack> Here is some code that calls back into Haskell…  https://github.com/ghcjs/ghcjs-dom/blob/master/src/GHCJS/DOM/EventTargetClosures.hs
23:26:15 <hamishmack> Uses syncCallback1
23:26:44 <hamishmack> Luite is working on something easier to use
23:27:15 <carter> hamishmack: i still don't know why he trusts me to have push powers
23:27:17 <carter> :)
23:27:28 <carter> hamishmack: btw, why don't you lurk on #numerical-haskell too :)
23:28:46 <carter> egad are monoid / semigroup nice
23:28:50 <carter> sooooo easy to compose
23:29:26 <solidus-1iver> hamishmack but thats still being done through haskell, what if i wanted to call it as a lib from native javascript
23:29:36 <carter> oh
23:29:40 <carter> you can do that too
23:29:48 <carter> i'm pretty sure
23:30:00 <carter> nb, it doesn't quite work the way you'd expect currently
23:30:15 <carter> hamishmack: is there an exmaple of js foreign export yet?
23:30:19 <hamishmack> carter: Sort of.  I don’t read it much.
23:30:25 <carter> ?
23:30:28 <carter> readh which?
23:31:52 <hamishmack> well it is creating a JS function and passing it to addEventListener.  Just store it somewhere else and you can then call it.
23:32:19 <carter> k
23:32:20 <carter> ;)
23:32:51 <carter> hamishmack: it occurs tome that I could abuse ghcjs to export my numerical stuff to js :)
23:33:49 <Adeon> can I pattern match on a constructor without knowing what arguments it takes
23:34:03 <carter> Adeon: do you have an example?
23:34:06 <hamishmack> solidus-1iver: Another option is to use JSaddle.  You can use it like this… https://github.com/ghcjs/ghcjs-examples/blob/master/ghcjs-hello/src/Main.hs#L229
23:34:11 <carter> you *can* do something like that
23:34:12 <Adeon> I can do Something {..} with RecordWildCards
23:34:16 <carter> for record constructor
23:34:25 <carter> idk if the same applies  for other constructors
23:34:27 <Adeon> I was wondering if there's a way without wildcards
23:34:34 <Adeon> it's not critical
23:34:36 <carter> Adeon: try Foo{}
23:34:37 <Adeon> I'm just curious
23:34:42 <Adeon> aah
23:35:08 <carter> let f Just{} = true in f Nothing
23:35:13 <carter> > let f Just{} = true in f Nothing
23:35:14 <lambdabot>  Not in scope: ‘true’
23:35:19 <carter> > let f Just{} = True in f Nothing
23:35:20 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function f
23:35:30 <carter> > let f Just{} = True in f (Just ())
23:35:32 <lambdabot>  True
23:35:35 <carter> Adeon: yay
23:35:36 <carter> it works
23:35:37 <carter> :)
23:35:43 <Adeon> world hunger problems are now solved
23:35:53 <carter> Adeon: should i bill you at my standard weekly rate?
23:36:01 <carter> or put it on the tab?
23:36:04 <carter> :)
23:36:15 <hamishmack> solidus-1iver: Most likely you will always need to “export” the haskell functions you want to call in some way.
23:36:19 <Adeon> put it on the tab
23:36:33 <Adeon> I'll pay when I get to my grave
23:36:36 <carter> ok
23:36:40 <carter> :)
23:36:48 <Adeon> little do you know I will be cremated instead
23:38:03 <carter> :P
23:38:08 <carter> Adeon: welcome to irc :)
23:38:11 <carter> what are you hacking on
23:38:33 <Adeon> medium level opengl bindings
23:38:44 <Adeon> more convenient than openglraw or the opengl package but not too high-level either
23:38:53 <Adeon> safely garbage collected, no implicit state going around
23:40:01 <Adeon> which is part of another project where I'm trying to implement a painting program on 3d scenes
23:40:22 <Adeon> you take a brush and paint around and the paint will be projected from 2d to 3d on an arbitrary number of things
23:41:03 <Adeon> I got a stupid idea that may let me to do it on a large number of geometry and textures efficiently in real time
23:41:12 <carter> cool
23:43:50 <Adeon> damn straight it's cool
23:44:12 <Adeon> or that's at least what I will be saying if I have to market it
23:46:37 <Adeon> I can render subpixel rendered text inside opengl
23:46:51 <Adeon> I know, #haskell may have trouble reacting to this awesome information
23:48:49 <carter> Adeon: i'm writing numerical haskell :)
23:49:00 <carter> and its nearly 3am :)
23:50:59 <darthdeus> guys, if i understand correctly, if i use an applicative parser with parsec, i can actually do operations on the parser right? would it be possible to generate a language specification (somehow) from the parser?
23:51:55 <carter> @hackage parsers might be a better package to hack that out with
23:51:56 <lambdabot> http://hackage.haskell.org/package/parsers might be a better package to hack that out with
23:52:00 <carter> but roughly yes
23:52:07 <carter> you have to have a way of getting the AST out
23:52:12 <carter> and figuring out the sharing / graph
23:52:19 <carter> but some other parser libs inhaskell do do that
23:52:25 <carter> but some of them predate applicatives I htink
23:52:40 <darthdeus> hmmm, awesome :O
23:52:56 <carter> you'd wanna use something like
23:52:59 <carter> @hackage data-reify
23:52:59 <lambdabot> http://hackage.haskell.org/package/data-reify
23:53:17 <carter> https://github.com/ku-fpg/data-reify/tree/master/examples
23:53:37 <darthdeus> thanks
23:53:37 <carter> which gives you a nice way of detecting sharing in haskell ASTs
23:53:42 <darthdeus> i'll look into that
23:53:47 <carter> and building up the DIgraph of things
23:54:22 <carter> note that theres some subtle constraints you'd have to do
23:54:37 <carter> like have all the base predicates be sort of thigns you can introspect
23:54:55 <darthdeus> hmm
23:55:17 <darthdeus> i'm not sure if i understand what that means ... as in the parser predicates?
23:55:21 <carter> yes
23:55:24 <carter> "isAlpha"
23:55:26 <darthdeus> ah makes sense
23:55:27 <carter> and friends
23:55:53 <darthdeus> so basically ... i'd take my parse tree, turn it into an oriented graph, and then work with that
23:55:54 <carter> you *could* figure out the recursions
23:56:00 <carter> yeah
23:56:12 <carter> you can also make a very very nice ambigiuous recognizer
23:56:15 <carter> that runs fast
23:56:25 <carter> GLL recognizer is def doable
23:56:35 <carter> a GLL parser... not sure hwo to make that nice
23:57:04 <apples> will the bayhac talks be recorded? i'm not sure if i'm going to be able to make it
23:57:15 <carter> apples: i'm not making it either
23:57:22 <darthdeus> hmm, I think I need to read something about parsers
23:57:28 <apples> there's some stuff i really want to see though :)
23:57:44 <carter> darthdeus: but the point being,  theres really 2 parts to the parser combinator
23:57:49 <carter> "yes this is a valid input"
23:58:16 <carter> "given its valid input, turn it into the AST the parse deemed it to"
23:58:18 <carter> *to b
23:58:34 <carter> balancing the two is trick
23:58:35 <carter> ok
23:58:37 <carter> time to sleep
23:58:45 <darthdeus> but i only need the part that determines what is the valid input to be able to generate syntax rules?
23:58:52 <darthdeus> hehe
