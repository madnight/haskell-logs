00:15:04 <seye> hi - i'm trying to understand let myFoldl f a bs = foldr (\b g x -> g (f x b)) id bs a
00:15:41 <seye> but it looks like either foldr is being called with 4 arguments or there's some implicit grouping i don't understand
00:20:03 <pavonia> seye: There are indeed four parameters, so the result type of foldr must be a function
00:20:32 <pavonia> :t foldr
00:20:33 <lambdabot> (a -> b -> b) -> b -> [a] -> b
00:21:22 <pavonia> the 'b' unifies with something like (c -> d)
00:22:14 <pavonia> You can also see that this is true because the second parameter "id" has type (e -> e)
00:24:14 <seye> ahh - ok, i think i understand the type now - the 'accumulator' is a function, so the result is a function which is then applied to a?
00:26:14 <seye> now to spend the rest of the day wrapping my slow head round what it all means - thanks pavonia
00:26:15 <shachaf> Yes.
00:28:42 <l0cust> how are we all doing?
00:40:16 <pavonia> different
00:42:24 * hackagebot ghc-events 0.4.3.0 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.4.3.0 (MikolajKonarski)
00:42:26 * hackagebot threadscope 0.2.3 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.3 (MikolajKonarski)
00:46:53 <dreixel> ocharles: what goes wrong?
00:52:25 * hackagebot JuicyPixels 3.1.5.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.5.1 (VincentBerthoux)
00:54:10 <__jim__> Hey guys, quick question. What is the best way to read from a Chan? I seem to be having issues due to laziness (I think).
00:54:36 <__jim__> I've tried this with bang patterns, and it seems somewhat hit and miss.
00:56:48 <pavonia> __jim__: Can you give a code example? readChan should be fine
00:59:16 <__jim__> pavonia: I don't have a particularly small example off hand, but basically I have one thread listening to a blue tooth socket and writing to a broadcast channel, then another thread reads from a duplicated channel and sends the string to every device attached.
01:00:28 <no-n> THIS CHANNEL IS SO GREAT
01:01:22 <pavonia> __jim__: Well, it's hard to tell what's the problem then
01:01:39 <__jim__> I'll try to clean some stuff up and post it.
01:02:39 <bartavelle> usually the chan/laziness issue is that the value will only be forced after being read
01:02:50 <bartavelle> so evaluated in the "wrong" thread
01:04:53 <pavonia> So you deepseq it before writing it to the channel?
01:05:40 <__jim__> hm
01:05:55 <__jim__> That makes sense
01:06:13 <__jim__> I'll take a look at deepseq
01:06:18 <__jim__> Thanks guys
01:19:29 <{AS}> Hi, what is a good way to debug a cabal package (with stack trace and all).
01:19:41 <{AS}> I can find instructions for GHC, but not really cabal
01:21:56 <arrnas> can i write a new monad instance for maybe? i'm getting Duplicate instance declarations
01:31:02 <pavonia> arrnas: You'd have to wrap a new data type around
01:31:50 <arrnas> pavonia: something like newtype Maybe2 a = Maybe a ?
01:32:31 <pavonia> arrnas: Yes
01:32:50 <pavonia> arrnas: No wait, = Maybe (Maybe a)
01:33:25 <pavonia> But why do you want a different Monad instance?
01:35:26 <arrnas> pavonia: but with maybe2 i'm getting mismatches since Just and Nothing return Maybe and not Maybe2
01:35:50 <vanila> arrdem, you could write your own data tpye,   data MyMaybe a = MyNothing | MyJust a
01:36:07 <pavonia> arrnas: Yes, you have to unwrap it if you want to Maybe value
01:36:09 <vanila> but there is only one way to implement a Monad instance for this type
01:37:58 <arrnas> data MyMaybe a = MyNothing | MyJust a
01:38:35 <arrnas> no data constructor for MyJust
01:39:26 <vanila> what happened>?
01:40:34 <arrnas> looks like its working now for some reason, just no instance of show
01:40:37 <vanila> oh
01:40:39 <vanila> you can do this
01:40:43 <vanila> data MyMaybe a = MyNothing | MyJust a
01:40:47 <vanila>   deriving (Eq, Show)
01:41:04 <vanila> the compiler wll create it automatically
01:42:23 <pavonia> arrnas: Why do you want to re-implement Monad for Maybe, for learning purpose?
01:42:32 <arrnas> pavonia: yeah
01:42:47 <pavonia> I see
01:43:17 <vanila> If you are doing that - Try to prove the equations as well as implementing the functions :)
01:43:39 <vanila> http://www.haskell.org/haskellwiki/Monad_laws <- they are listed here
01:44:41 <arrnas> MyJust 5 >>= \x -> x + 5 gets me No instance for (Num (MyMaybe b0)) arising from the literal `5'
01:45:34 <jle`> arrnas: check out the type of (>>=)
01:45:46 <jle`> and see what has to be returned on the right hand side
01:45:48 <jle`> :t (>>=)
01:45:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:46:08 <arrnas> oh
01:46:11 <arrnas> im stupid
01:46:14 <arrnas> yeah sorry
01:47:00 <jle`> not stupid :)
01:50:10 <arrnas> MyNothing >>= f = MyNothing.. what if i wanted to return MyJust -1 instead of MyNothing ?
01:50:49 <vanila> arrdem, That would violate the monad laws that I linked
01:51:27 <vanila> arrdem, So it's important not just to implement the functions - but to make sure they satisfy the equations too
01:53:17 <jle`> we...
01:53:19 <jle`> well
01:53:31 <jle`> returning MyJust (-1) doens't even typecheck
01:53:47 <jle`> so in this case it's enforced by the compiler
01:53:49 <vanila> oh doens't it? My mistake
01:53:56 <vanila> ah I see why now
01:53:58 <jle`> :t (>>=)
01:53:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:54:19 <jle`> you ahve to return something of the same type as the output of the function
01:54:22 <vanila> that's interesting - types really help!
01:54:58 <merijn_> Parametricity strikes again!
02:08:02 <merijn_> The wiki mentions that the STG paper is a rather outdated model of GHCs compilation. Which papers should I read to get an idea of what's changed since the STG machine?
02:09:59 <eizo> why can't i use Util count :: (a -> Bool) -> [a] -> Int?
02:11:23 <jle`> eizo: what happens when you try?
02:11:57 <eizo> jle`: in ghci: <interactive>:1:1: Not in scope: `count'
02:12:12 <jle`> hm. it's not defined/not in scope
02:12:12 <Axman6> you'll need to import it from wherever it's defined
02:12:27 <jle`> where did you see it used?
02:12:32 <jle`> it's not a part of the standard library
02:12:35 <eizo> hoogle says "Util": but "Could not find module `Util'"
02:12:51 <eizo> jle`: it was the first result on my local hoogle when searching for that type
02:13:35 <eizo> (hoogle package on ubuntu)
02:15:01 <arrnas> data [] a = [] | a : [a], how would i write my own list type? data MyList a = EmptyList | ... ?
02:15:15 <jle`> eizo: i'm not sure whre that is, sorry :/
02:15:20 <Thooms> arrnas: yes
02:15:50 <nclarke> data Mylist a = EmptyList | MyCons a (Mylist a)
02:15:56 <arrnas> | a : (MyList a) ?
02:16:02 <eizo> np
02:16:17 <jle`> eizo: but for what it's worth, your count p = length . filter p
02:16:27 <jle`> arrnas: you probably can't use : as your data constructor
02:16:32 <eizo> yes thanks
02:16:35 <jle`> ...i could be wrong
02:16:43 <jle`> you can use a prefix data constructor like nclarke
02:17:04 <arrnas> yeah i can't use :
02:17:05 <jle`> you can also use infix data constructors that are operators that start with a colon too if you wanted
02:17:27 <arrnas> but data [] a is the same as MyList a
02:17:42 <arrnas> and [5] works while MyList 5 doesn't
02:17:51 <jle`> data MyList a = MyNil | a :< MyList a
02:17:57 <jle`> hm
02:18:01 <jle`> why doesn't MyList 5 work?
02:18:11 <jle`> does your computer melt down when you type it
02:18:32 <arrnas> Not in scope: data constructor `MyList'
02:18:36 <dario> MyList 5 should be MyCons 5 EmptyList, no?
02:18:48 <jle`> hm
02:18:51 <jle`> try MyMaybe 1
02:19:04 <jle`> does that work?
02:19:34 <arrnas> well no, but theres no Data constructor for MyMaybe
02:19:47 <arrnas> and thats fine but how does [] work then?
02:19:58 <nclarke> So, in a signature like 'data MyList a = MyNil | MyCons a (MyList a)', the 'MyList' is the name of the type. The data constructors are the ones on the right hand side
02:20:04 <nclarke> e.g. 'MyNil' and 'MyCons'
02:20:08 <jle`> MyMaybe is a type constructor, you apply it to a type to make a type
02:20:12 <arrnas> right
02:20:12 <jle`> MyMaybe Int is a type
02:20:18 <jle`> MyJust is a data constructor
02:20:24 <jle`> MyJust :: a -> MyMaybe a
02:20:30 <nclarke> [] is a bit special - it has special syntax support, like () for tuples
02:20:48 <jle`> i think a confusion here is that the both the data constructor and the type constructor for lists
02:20:54 <jle`> are sort of the same-ish
02:21:02 <jle`> it'd be like if you did data MyFoo a = MyFoo a
02:21:12 <jle`> MyFoo is both a data constructor and a type constructor
02:21:24 <jle`> this is generally considered a bad idea (tm)
02:21:38 <arrnas> ok, so what does Cons stand for?
02:22:02 <jle`> so MyNil and MyCons are your data constructors, and MyList is your type constructor
02:22:12 <jle`> for lists, [] and (:) are your data construfctors, and [] is your type constructor
02:22:14 <nclarke> Hmm. Not sure what it stands for. It comes from Lisp
02:22:22 <jle`> it's...historical
02:22:42 <arrnas> so it could be something like Insert a (MyList a)
02:22:53 <dario> i think they called it that because it _cons_tructed lists or something
02:23:00 <arrnas> it it would be Insert 5 EmptyList ?
02:23:13 <pyrtsa> Construct (linked) list.
02:23:26 <jle`> yea, or Insert 5 (Insert 6 (Insert 0 EmptyList))
02:23:31 <pyrtsa> http://en.wikipedia.org/wiki/Cons
02:24:11 <jle`> i like to say that cons is called cons because it's snoc backwards
02:24:32 * Axman6 feels it should be called Prep
02:25:06 <Axman6> but snoc is snoc because it's cons backwards...
02:26:02 <jle`> yea it's a bit of a joke
02:27:09 <Maior> :t  snoc
02:27:10 <lambdabot> Snoc s s a a => s -> a -> s
02:27:14 <Maior> ...oh
02:28:08 <pavonia> > snoc "ab" 'c'
02:28:09 <lambdabot>  "abc"
02:28:22 <pavonia> Where is that from?
02:28:37 <nclarke> @hoogle snoc
02:28:37 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
02:28:38 <lambdabot> Data.ByteString.Lazy.Char8 snoc :: ByteString -> Char -> ByteString
02:28:38 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
02:28:53 <nclarke> @hayoo snoc
02:28:53 <lambdabot> Unknown command, try @list
02:28:56 <nclarke> @list
02:28:56 <lambdabot> What module?  Try @listmodules for some ideas.
02:29:00 <nclarke> Pah
02:29:38 <pavonia> The number of class parameters suggests it's from lens :p
02:29:39 <merijn_> pavonia: There's a snoc in Data.Sequence
02:29:53 <nclarke> It's from lens
02:29:57 <nclarke> http://hackage.haskell.org/package/lens-4.1.2/docs/Control-Lens-Cons.html#v:snoc
02:30:01 <merijn_> :t Data.Sequence.snoc
02:30:02 <lambdabot> Not in scope: ‘Data.Sequence.snoc’
02:30:05 <merijn_> aww
02:30:28 <jle`> i wonder what Data.Sequence is qualified as for lambdabot
02:30:29 <merijn_> :t Data.ByteString.snoc
02:30:30 <lambdabot> BSC.ByteString -> Word8 -> BSC.ByteString
02:30:31 <arrnas> whats the map function for everything other than lists?
02:30:39 <merijn_> arrnas: fmap?
02:30:42 <jle`> well there's no map function for everything
02:30:48 <jle`> but there is a map function for Functor s
02:31:03 <jle`> :)
02:31:11 <jle`> > fmap (+3) (Just 2)
02:31:12 <arrnas> Couldn't match expected type `[a]' with actual type `MyList a
02:31:13 <lambdabot>  Just 5
02:31:31 <jle`> are you trying to use map?
02:31:32 <jle`> :t map
02:31:33 <lambdabot> (a -> b) -> [a] -> [b]
02:31:38 <jle`> you can write a myMap
02:31:42 <jle`> @src map
02:31:42 <lambdabot> map _ []     = []
02:31:42 <lambdabot> map f (x:xs) = f x : map f xs
02:31:44 <nclarke> You can create a functor instance, and then use fmap
02:31:46 <jle`> ^^ cheat sheet
02:31:53 <jle`> or better yet, write your own Functor instance
02:32:06 <arrnas> xs >>= f = concat (map f xs)
02:32:07 <jle`> map isn't magic :)
02:32:09 <arrnas> for mymap
02:32:12 <arrnas> myList
02:32:14 <arrnas> i mean
02:32:24 <jle`> well, concat and map both work only on lists
02:32:28 <jle`> they aren't magic, they are normal code
02:32:34 <jle`> :t concat
02:32:35 <lambdabot> [[a]] -> [a]
02:32:37 <jle`> @src concat
02:32:37 <lambdabot> concat = foldr (++) []
02:32:49 <jle`> :t (++)
02:32:50 <lambdabot> [a] -> [a] -> [a]
02:33:00 <nclarke> instance Functor MyList where fmap _ MyNil = MyNil; fmap f (MyCons x xs) = MyCons (f x) (fmap f xs)
02:33:03 <nclarke> Something like tht
02:33:09 <jle`> @src fmap Maybe
02:33:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:33:13 <jle`> @src Maybe fmap
02:33:13 <lambdabot> fmap _ Nothing       = Nothing
02:33:13 <lambdabot> fmap f (Just a)      = Just (f a)
02:33:22 <jle`> but you probably could have written it on your own
02:33:23 <jle`> :)
02:33:25 <jle`> don't look at that
02:33:27 <jle`> shh
02:33:31 <Total_1mmersion> How do you freeze a list (linked by STRefs to each other) with a cycle? STRef is not Eq, so I don't see how this is possible.
02:38:23 <Total_1mmersion> Oh, nevermind, STRef is Eq. The instance definition is not near the datatype in the source and I missed it.
02:40:58 <arrnas> so how would [[a]] -> [a] would look like with MyList?
02:41:13 <arrnas> MyCons ( MyCons a) ?
02:41:18 <jle`> MyList (MyList a) -> MyList a
02:41:29 <arrnas> oh right, the type
02:42:16 <jle`> actually i think one of the first functional programming assignments you get is implementing (++) yourself
02:42:19 <jle`> usually
02:42:31 <jle`> and concat basically (++)'s all the lists in a list
02:42:47 <jle`> (which should hint to you that can be written as a fold)
02:45:40 <arrnas> x:xs is of type [[a]]..
02:45:53 <jle`> well x:xs is polymorphic
02:45:58 <jle`> :t \x xs -> x:xs
02:45:59 <lambdabot> a -> [a] -> [a]
02:46:24 <vanila> [[a]] is a list of lists
02:46:33 <vanila> e.g. [[1,2,3],[4,5],[6]]
02:46:42 <arrnas> yeah but i need MyList( MyList a))
02:47:00 <jle`> you need something of that type?
02:47:08 <vanila> hm
02:47:11 <vanila> why don't you write
02:47:11 <jle`> have you tried implementing (++) for your list?
02:47:18 <vanila> let a = MyCons 1 (MyCons 2 (MyCons 3 MyNil)
02:47:24 <arrnas> i'm actually just rewriting concat
02:47:26 <vanila> let b = MyCons 4 (MyCons 5 MyNil)
02:47:32 <jle`> try (++) first
02:47:34 <arrnas> concat (x:xs) = x ++ concat xs
02:47:36 <jle`> and concat will come easily
02:47:41 <vanila> then MyCons a (MyCons b MyNil)   has type  MyList (MyList Integer)
02:47:43 <jle`> well yeah, that's concat for lists
02:47:48 <jle`> try writing append for your lists
02:47:57 <jle`> myAppnd :: MyList a -> MyList a -> MyList a
02:48:04 <jle`> append being (++)
02:48:22 <jle`> remember that pattern matching is your friend here
02:48:31 <jle`> a MyList a is either a MyNil or a MyCons
02:48:39 <jle`> so you are doing things with two MyList's
02:48:44 <jle`> so there are four combinations of patterns
02:48:54 <ocharles> dreixel: Let me just paste the error, but it seems to try and refine a "too early", or something
02:48:54 <jle`> myAppend MyNil MyNil = ...
02:49:05 <jle`> myAppend MyNil (MyCons x xs) = ...
02:49:09 <nclarke> arrnas: You seem to be getting confused about the [] syntax. [] (with nothing between it) is a data constructor, but [a,b] is just syntactic sugar for the (:) constructor
02:49:21 <jle`> myAppend (MyCons x xs) MyNil = ...
02:49:28 <jle`> myAppend (MyCons x xs) (MyCons y ys) = ...
02:49:39 <jle`> do you know about pattern matching?
02:49:45 <jle`> and writing functions on adt's?
02:50:09 <arrnas> i know pattern matching, not sure whats adt
02:50:15 <jle`> algebraic data type
02:50:25 <jle`> something that is data Blah = Blah
02:50:43 <jle`> here, i'll start you off
02:50:49 <jle`> myAppend MyNil MyNil = MyNil
02:50:55 <jle`> :)
02:50:55 <ocharles> dreixel: https://gist.github.com/ocharles/699b92506fa64766dc76
02:51:14 <arrnas> MyNil (MyCons x xs) = MyCons x xs ?
02:51:21 <jle`> yup
02:51:34 <arrnas> (MyCons x xs) MyNil = MyCons x xs
02:52:01 <merijn_> And now the interesting case :)
02:55:42 <jle`> MyCons x (myAppend xs (MyCons y ys))
02:55:45 <jle`> oh darnit
02:55:49 <jle`> i was supposed to backspace
02:55:51 <jle`> but i missed
02:55:54 <jle`> don't read thattt
02:56:03 <jle`> it's because it's 3 am >)>
02:56:05 <jle`> >_>
02:57:34 <arrnas> merge (x:xs) (y:ys) = x : y : merge xs ys     so wouldnt that be Mycons x Mycons y myAppend xs ys ?
02:58:13 <jle`> that sort of...interleaves the two lists
02:58:21 <jle`> (++) puts the entire first list first, then the entire second list after
02:58:36 <arrnas> oh ok
02:58:51 <eizo> given a functin like that: http://lpaste.net/103499 what is the right way to transform it to get some kind of progress report (c range from 2 to bound) printed in the console? should i put its return type to be IO (), and just add ifs and elses to print?
02:59:47 <jle`> > let f [] ys = ys; f xs [] = xs; f (x:xs) (y:ys) = x:y:f xs ys in f [1,2,3,4] [10,11,12,13]
02:59:48 <lambdabot>  [1,10,2,11,3,12,4,13]
02:59:58 <jle`> > [1,2,3,4] ++ [10,11,12,13]
02:59:59 <lambdabot>  [1,2,3,4,10,11,12,13]
03:04:00 <eizo> i transformed it that way: http://lpaste.net/103500 but now i'm getting a stack overflow
03:06:06 <jle`> i think the typical way is to break up your big loop into small resumable things and wrap it in an IO that performs the parts
03:06:24 <quchen> eizo: There are multiple ways you can do this. You can put the entire result in IO, which is probably the easiest way. You can also return *part* of the result in IO so you still have a pure result, and performance reports somewhere else.
03:06:51 <quchen> If you're just looking for debugging information, there's another way.
03:07:03 <jle`> :t when
03:07:04 <lambdabot> Monad m => Bool -> m () -> m ()
03:07:14 <eizo> quchen: yes i just want to have an idea on when my function is going to finish
03:07:34 <jle`> when (c `mod` 10000 == 0) (print c)
03:07:35 <eizo> (for instance by printing c every time it's equal to 0 modulo 1000000)
03:07:55 <quchen> eizo: That doesn't answer whether it's for debugging.
03:08:05 <jle`> are you going to use this in production code?
03:08:24 <eizo> no debugging, not for production either, it's just for project euler problems
03:09:10 <quchen> If it's not debugging, the third option is not an option.
03:13:06 <jle`> try breaing up your function into pure and resumable parts
03:13:12 <jle`> instead of a giant loop
03:13:17 <arrnas> http://lpaste.net/103501
03:13:26 <arrnas> what am i doing wrong with myConcat?
03:13:40 <eizo> jle`: ok i'll try
03:13:52 <jle`> as in, you can call it with, say 10000 steps
03:14:00 <jle`> and print that
03:14:04 <jle`> then call it for the next 10000 steps
03:14:07 <jle`> and print that
03:14:35 <jle`> arrnas: are you trying to use myApp infix?
03:14:39 <jle`> you have to surroud it with backquotes
03:14:51 <jle`> x `myApp` myConcat xs
03:15:51 <quchen> arrnas: I don't know. What's it doing wrong?
03:16:36 <arrnas> jle`: yup that fixed it
03:16:44 <arrnas> sweet jebus its working
03:17:08 <eizo> i'm always getting stack overflows, should i rewrite my (pure) functions in a tail recursive style?
03:17:11 <arrnas> as a bonus it looks horrible
03:17:12 <arrnas> MyCons 5 EmptyList >>= \x -> MyCons (x+1) EmptyList
03:17:34 <jle`> eizo: tail recursion isn't what you think it is in haskell
03:17:42 * hackagebot mediawiki2latex 7.9.0.1 - Convert MediaWiki text to LaTeX  http://hackage.haskell.org/package/mediawiki2latex-7.9.0.1 (dhun)
03:18:01 <jle`> stack overflow on a large recursive loop is usually the result of laziness
03:18:52 <eizo> so how would i fix, e.g. http://lpaste.net/103503?
03:19:03 <merijn> eizo: Note: GHC haskell doesn't have a function call stack
03:19:14 <merijn> eizo: It has a pattern matching stack
03:28:35 <ast_> is there a cross platform lib like INotify?
03:28:55 <ast_> I need simple dir updates notifications.
03:33:10 <nclarke> Cross-platform including Windows? I don't think I've seen one
03:33:41 <ast_> Maybe I'm better off using directory then
03:33:54 <ast_> and check for dir updates every now and then
03:36:44 <quchen> eizo: Make your fields strict, and move the result into a strict field. http://lpaste.net/103503
03:37:26 <eizo> quchen: cool thank you
03:38:18 <int-e> every time haskell.org's mailman sends out membership reminders I'm getting two mails for the same e-mail address (same list of mailing lists, different order). does anybody else have such a problem?
03:39:28 <dreixel> ocharles: my IRC client isn't very good on this... I see I got a message from you, but not exactly what :P
03:39:30 <quchen> eizo: This solution is somewhat tail recursive, but that's not the point. It's enforcing strictness, which is much more important in Haskell.
03:39:33 <dreixel> ocharles: can you perhaps pvt me?
03:39:54 <cpennington> how do I force cabal to reinstall everything that my package depends on inside the newly created cabal sandbox. I think I installed some of the packages outside the sandbox, and now I'm getting complaints like this: https://gist.github.com/cpennington/83d8a705703833865a29
03:40:07 <cpennington> but then if I manually cabal install stm-2.4.3, it works fine
03:41:13 <cpennington> aha. http://blog.johantibell.com/2014/04/announcing-cabal-120.html has the right thing: cabal install --only-dep
03:43:31 <eizo> ok i'll look that up
03:45:54 <merijn> Is there a way to query ghc which CPP it uses by default?
03:46:12 <quchen> eizo: Concerning your "logging in a pure function" issue, consider using Writer [IO ()] a, like so: http://lpaste.net/103506
03:47:46 * hackagebot casadi-bindings-internal 0.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-internal-0.1 (GregHorn)
03:47:48 * hackagebot casadi-bindings 1.9.0.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.1 (GregHorn)
03:47:50 * hackagebot casadi-bindings-core 1.9.0.1 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-1.9.0.1 (GregHorn)
03:48:17 <eizo> nice thanks
03:52:46 * hackagebot casadi-bindings-ipopt-interface 1.9.0.1 - low level bindings to casadi-ipopt_interface  http://hackage.haskell.org/package/casadi-bindings-ipopt-interface-1.9.0.1 (GregHorn)
04:11:41 <migimunz_> Hello! I have a type which is basically a (Map String a), and I'd like to make it an instance of the Functor typeclass, however that's not going very well. Could someone check it out: https://gist.github.com/migimunz/ddccb4a393eb19faa4e4 ?
04:12:25 <migimunz_> I understand what's going on, fmap wants a function (a->b), whereas I'm providing (Map String a) -> (Map String b), but I'm not sure how to fix it (I don want to map over the Map)
04:12:35 <migimunz_> *do
04:12:50 * hackagebot HaRe 0.7.2.3 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.3 (AlanZimmerman)
04:15:26 <DanielDiaz> migimunz_: if you don't want to "map over the map", you probably don't want to write the Functor instance either. The argument of fmap must be of type (a -> b), since that is how it is defined by the class
04:15:41 <DanielDiaz> migmunz_: however, you can still define your own function to do that
04:18:00 <migimunz_> DanielDiaz, yeah, the more I think about it, the less sense my idea makes
04:19:08 <DanielDiaz> migimunz_: it happens :)
04:20:26 <eizo> i'm getting module not found for: Math.NumberTheory.Moduli
04:21:44 <DanielDiaz> eizo: I guess you have the arithmoi package installed. How are you compiling?
04:23:10 <eizo> DanielDiaz: arithmoi?
04:23:36 <DanielDiaz> that package defines a module with that name
04:23:57 <DanielDiaz> so I thought you are trying to use it
04:24:03 <DanielDiaz> http://hackage.haskell.org/package/arithmoi
04:24:44 <DanielDiaz> look at the list of modules and you'll see "Math.NumberTheory.Moduli"
04:25:12 <DanielDiaz> but to use the modules in that package, you must have it installed
04:35:24 <ghorn_> HaRe haha, good name
04:35:58 <alanz> Haskell Refactorer
04:36:53 <eizo> DanielDiaz: thanks
04:37:11 <DanielDiaz> eizo: you are welcome :)
04:37:46 <ghorn_> alanz: so it makes your code less hairy?
04:38:28 <alanz> Thats one way of looking at it, never thought of it that way
04:41:16 <pjdelport> you could have a barber wearing a hair shirt as mascot
04:43:03 <alanz> Well, Simon Thompson who started the project pronounces it hare (like rabbit), so we went with https://camo.githubusercontent.com/fcedd231d3c2381f8e3e3f64a80d4fcdbbd0d6be/68747470733a2f2f7261776769746875622e636f6d2f616c616e7a2f486152652f6d61737465722f486152654c6f676f2e737667
04:44:28 <antikebab> hello
04:45:50 <ghorn_> hi
04:46:52 <fizruk> is there a class for   apply :: f a b -> a -> b ?
04:48:04 <antikebab> I have a question: Is haskell appropriate as an introductory programming language?
04:48:16 <merijn> antikebab: I think so
04:48:43 <nclarke> Yes. Probably easier as a first language
04:48:56 <nclarke> Before you get side-effects baked into your head
04:49:27 <antikebab> Can you point me to some resources to get started?
04:49:29 <nclarke> I've observed children, for example, get quite confused by statements like x = x + 1 in C, because they're used to thinking equationally
04:49:42 <nclarke> Whereas Haskell transitions quite nicely into that
04:49:51 <ghorn_> @lyah
04:49:52 <lambdabot> Unknown command, try @list
04:49:56 <nclarke> s/into/from
04:49:56 <ghorn_> >lyah
04:50:14 <nclarke> @where lyah
04:50:14 <lambdabot> http://www.learnyouahaskell.com/
04:50:24 <ghorn_> ah thanks
04:50:42 <antikebab> Alright, i'll give it a go
04:50:47 <antikebab> thanks!
04:56:49 <pjdelport> fizruk: What would that do, exactly?
04:58:15 <fizruk> pjdelport: I have smth like data Fn a b = Fn String (a -> b). basically a wrapper for function with String used for Show
05:01:22 <pjdelport> fizruk: You can't overload function application in general; you'll probably need a new application operator.
05:01:34 <pjdelport> There might be other ways of doing what you're doing, though.
05:03:04 <pjdelport> fizruk: https://hackage.haskell.org/package/ShowF
05:05:00 <no-n> :t msum
05:05:02 <lambdabot> MonadPlus m => [m a] -> m a
05:05:37 <fizruk> pjdelport: thanks for the link, though it probably does not fit my problem
05:06:13 <makalu> what's the alternative to "runhaskell" when using cabal sandboxes?
05:06:32 <quchen> makalu: Try `cabal exec runhaskell`
05:06:49 <quchen> Also see the Cabal 1.20 release notes on exec
05:06:52 <orion> hmm
05:07:01 <DogeHayashi> What's the most idiomatic way of, given a value v, returning Just ( f v ) if a predicate ( k v ) is True and Nothing otherwise?
05:07:07 <makalu> quchen: then -isrc doesn't work
05:07:19 <quchen> cabal exec runhaskell -- -isrc
05:07:23 <DogeHayashi> My immediate thought would be guard ( k v ) >> return ( f v ), but idk if there's a nicer way
05:07:56 * hackagebot pcre-light 0.4.0.2 - A small, efficient and portable regex library for Perl 5 compatible regular expressions  http://hackage.haskell.org/package/pcre-light-0.4.0.2 (DanielDiaz)
05:08:09 <quchen> DogeHayashi: You can abbreviate it as "f v <$ guard (k v)", but that's basically the same thing.
05:08:20 <quchen> Might be a tad more efficient.
05:08:25 <makalu> thanks quchen it works
05:08:27 <orion> When writing a server in haskell, what are the pros and cons of defining a separate data type for each kind of packet, as opposed to having just one packet data type with multiple value constructors?
05:10:29 <cpennington> orion: If you are mostly writing functions that operate on any kind of packet, then a single data type will be easier (since you can case match on each packet constructor)
05:10:33 <supki> :t \v k f -> v ^? filtered k.to f
05:10:34 <lambdabot> a -> (a -> Bool) -> (a -> a1) -> Maybe a1
05:11:06 <pjdelport> DogeHayashi: Why not just use an if? Does it need to be generalized?
05:11:17 <cpennington> on the other hand, if you need to have functions that explicitly only work on particular packet types, then multiple data types will allow you to do that in a type safe way, and then you could use type classes to capture the cases of commonality between the packet types
05:11:37 <orion> cpennington: I see.
05:11:48 <DogeHayashi> aw, quchen went before I could thank them =p
05:12:46 <orion> cpennington: If I do the latter, how can I write a function that works with any packet?
05:23:48 <cpennington> orion: depends on what the function needs to do
05:24:24 <cpennington> if the function doesn't need to know anything about the particular packet, you could just write it with a general type (so that it would work with any value)
05:24:59 <cpennington> otherwise, you could add a Packet typeclass that has the common operations, and then implement that type class w/ each packet type
05:32:58 * hackagebot ghc-imported-from 0.1.0.4 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.1.0.4 (CarloHamalainen)
05:34:24 <jdiez> hello guys, I'm ploughing through LYAH. I've set up vim with hdevtools and friends, and I'm having trouble getting type signatures.
05:34:37 <jdiez> (paste incoming)
05:34:44 <klugez> @paste
05:34:44 <lambdabot> Haskell pastebin: http://lpaste.net/
05:35:38 <zipper> jdiez: What do you mean trouble getting type signatures?
05:35:59 <jdiez> one second
05:36:29 <jdiez> so this is my code: http://lpaste.net/103510
05:36:37 <jdiez> and I'm using vim-hdevtools to get the type signature of that function
05:36:53 <jdiez> I get the following error: "the function main is not defined in module Main"
05:36:55 <jdiez> which... is truwe
05:36:57 <jdiez> true*
05:36:59 <jdiez> but irrelevant
05:37:23 <jdiez> I can get the type on ghci just fine
05:37:27 <jdiez> *Main> :t largestUnderDivisibleBy
05:37:29 <jdiez> largestUnderDivisibleBy :: Integral a => a -> a -> a
05:37:31 <jdiez> *Main>
05:40:48 <jdiez> interesting
05:40:54 <jdiez> if I change the module name to "Asdf", it works
05:41:20 <jdiez> well, that's odd
05:41:55 <pjdelport> jdiez: hdevtools presumably tries to compile it normally
05:42:04 <jdiez> I see...
05:42:20 <pjdelport> where by convention Main does require a "main" export
05:42:28 <jdiez> also, there seems to be a problem with slime-vim; it always files when I try to send functions with `where` to ghci
05:43:11 <jdiez> https://mediacru.sh/Hp713E1Hsz0i
05:43:32 <jdiez> presumably those guard pipes are not correctly aligned?
05:44:06 <jdiez> the same thing happens with functions with `where`: https://mediacru.sh/bu-wADfgeMgt
05:44:53 <pjdelport> jdiez: are you using tabs or spaces?
05:44:59 <jdiez> pjdelport: spaces
05:45:23 <pjdelport> jdiez: okay; it looks like something is failing to adjust the indentation correctly
05:45:45 <jdiez> indeed
05:49:00 <tremon> two simple questions about this function: http://lpaste.net/103511 -- why do I need "in" at line 15? In my mind it's a do block even though it's not IO
05:49:28 <binq> GHCi crashes when I try to start it from my src directory because it has a Prelude.hs file.  I am not sure why this is happening though because I've set NoImplicitPrelude and I am doing a 'import "base" Prelude'
05:49:30 <binq> Here is my ghci.conf file: https://gist.github.com/binq/bd93497c9872db426e34
05:49:46 <tremon> and second, what's the canonical way to do multiple sanity checks on input? I'm unhappy with the if/then indentation, but adding an indent on each nested if seems worse
05:49:50 <Iceland_jack> tremon: You could write it as a do-block as well
05:50:48 <pjdelport> tremon: the "if" itself is in the containing do block, but the let is inside the if's else clause (not in any do block)
05:51:23 <pjdelport> tremon: so you need "else do ..." to keep using do syntax inside it
05:51:24 <tremon> ah, so the then and else start new blocks? thanks, I missed that
05:52:03 <pjdelport> tremon: Well, they're just first-class expressions they don't act any differently inside a do block or outside of it
05:52:15 <pjdelport> "expressions; they", even
05:52:55 <tremon> yeah, maybe better phrased as "I didn't realise do-blocks are not hierarchical". I automatically assumed that all nested expressions in a do-block were in do-syntax
05:53:01 * hackagebot rest-core 0.29 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.29 (ErikHesselink)
05:53:03 * hackagebot rest-gen 0.10 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.10 (ErikHesselink)
05:53:05 * hackagebot rest-happstack 0.2.9.7 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.7 (ErikHesselink)
05:53:07 * hackagebot rest-snap 0.1.17.8 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.8 (ErikHesselink)
06:06:20 <jdiez> okay, I'm patching up slime-vim to fix the bug where functions with `where` clauses or guards would cause a syntax error in ghci
06:06:27 <jdiez> is there anything else I should look foor?
06:06:29 <jdiez> for*
06:07:31 <pjdelport> jdiez: Did you submit or file that upstream?
06:07:39 <pjdelport> it sounds surprising that that would be a bug
06:07:46 <jdiez> pjdelport: I'm fixing the bug, then submitting a PR
06:07:51 <pjdelport> It might be some other interaction?
06:08:20 <jdiez> pjdelport: that's what I thought too, but there is no mention of "where" in the source code
06:08:24 <jdiez> which should be a special case
06:08:32 <jdiez> and as far as I can tell I'm doing nothing wrong, so it must be a bug
06:09:08 <pjdelport> (I'm not familiar with it, so I'll refrain further comment)
06:10:40 <jdiez> but yes, it is unusual that that would be a bug
06:42:14 <dhundirk> hello I am currently doing theaded IO http requests. Would it be a good idea to replace it with yampa, even if just an exercise for learning it
06:59:46 <binq> I posted this question on SO.  Any help is appreciate. http://stackoverflow.com/questions/23428949/ghci-is-crashing-when-executed-from-a-directory-that-has-a-prelude-hs
07:08:11 * hackagebot present 1.0 - Make presentations for data types.  http://hackage.haskell.org/package/present-1.0 (ChrisDone)
07:23:39 <krustyq> I was wondering if anyone would be able to help me out with installing cabal 1.2 on windows
07:23:45 <krustyq> I can't get it to upgrade
07:23:57 <S11001001> 1.20?
07:24:22 <krustyq> yes, it said that it installed but --version tells me it's 1.6
07:24:54 <krustyq> sorry, that should be 1.20
07:25:04 <krustyq> and 1.16
07:25:09 <S11001001> krustyq: do you have %APPDATA%\cabal\bin in your PATH?
07:25:21 <krustyq> I'll check, one second
07:25:28 <S11001001> IIRC the platform installer adds the platform bin dir but not your local cabal bin dir.
07:25:59 <S11001001> this is why windows should have 'which'
07:26:24 <krustyq> yeah it's not there,
07:27:10 <lechip> hi all, im trying to make an indexed tree like this http://lpaste.net/103512 but it wont compile, i reaelly dont see why
07:27:17 <krustyq> would it work to copy version 1.20 from the app data directory to the platofrm bin?
07:27:26 <S11001001> krustyq: Just add that dir to your PATH.
07:30:21 <krustyq> done, still at 1.16
07:30:49 <krustyq> but I added the complete path, I'll try adding it as you provided it, with %APPDATA%
07:31:33 <pagbk25> hi, anyone got some nice channels to share?
07:32:32 <krustyq> odd, still 1.16. Where's the 1.16 exe at? Maybe I can delete that and replace it with the 1.20 exe
07:33:13 * hackagebot libmpd 0.8.0.3 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.8.0.3 (JoachimFasting)
07:34:19 <pjdelport> lechip: shouldn't that be "map (treeToList . fst) l" ?
07:37:07 <krustyq> I upgraded to cabal 1.20 by deleting cabal.exe from C:\Program Files\Haskell Platform\2013.2.0.0\lib\extralibs\bin and replacing it with the 1.20 exe from AppData\Roaming\cabal\bin
07:37:49 <krustyq> thanks for the help, I can finally use sandboxes
07:39:40 <eizo> how can i derive an instance for Ord (Complex Double)? http://lpaste.net/103513
07:40:04 <sm> krustyq: \o/ cabal 1.20 is nice
07:40:39 <krustyq> lol, wouldn't know unfortunately, this is my first time using it
07:41:10 <sm> I got cabal, ghc, git etc. working on my windows too
07:41:18 <sm> it's kind of spooky
07:43:06 <S11001001> krustyq: you have to restart processes when you change the environment.
07:43:07 <krustyq> lol, ghc and git have been pretty smooth, cabal on the other hand ...
07:43:45 <krustyq> <S11001001>, sorry, I don't follow you when you say "restart process"
07:43:55 <krustyq> which process is that?
07:44:08 <S11001001> krustyq: the terminal
07:44:15 <krustyq> ah, yes, I did that
07:45:53 <krustyq> it seems as if 1.20 is working now
07:48:25 <funfunctor> https://gist.github.com/victoredwardocallaghan/ddd797cd0d432e3a1c52 did something change recently in Text ?
07:50:34 <tremon> how do I convert between Char8.ByteString and ByteString? or rather, how can I get Binary.Get.getByteString return the former?
07:51:00 <nclarke> tremon: They're identical
07:51:10 <nclarke> The difference is how you treat them
07:51:12 <quchen> tremon: See this. https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
07:52:45 <tremon> hmm, not according to ghc: name <- getLazyByteString 16 ; let text = (decodeLatin1 . B.takeWhile (/=0)) name complains about "Couldn't match type `B.ByteString' with `C.ByteString'"
07:52:57 <krustyq> anyways, <S11001001>, thanks again for the help
07:53:17 <S11001001> krustyq: np
07:53:49 <tremon> ah, so there's a ByteString.Encoding I should be using? Ok will try that
07:55:12 <quchen> It's in 'text' I think. I should update that remark.
07:55:25 <quchen> Data.Text.Encoding
07:56:07 <tremon> no, text.encoding is what I'm trying to use. The decodeLatin1 there doesn't appear to work on the type returned by Binary. I'll paste
07:58:34 <quchen> You can convert between lazy/strict BS with fromStrict/toStrict, if that's the problem.
07:59:27 <tremon> http://lpaste.net/103516 <-- I think I'm using lazy everywhere
07:59:36 <nclarke> You're not
07:59:56 <nclarke> You need Data.ByteString.Lazy.Char8 as C
07:59:58 <tremon> oh, the Char8 isn't lazy
08:01:02 <tremon> doesn't seem to affect the error, although I now get "Couldn't match type `C.ByteString' with `Data.ByteString.Internal.ByteString'". So presumably getLazyByteString isn't lazy?
08:01:34 <tremon> uhm. ignore that
08:01:36 <b2coutts> I want to write a function like hPrintf, but which instead takes a list of handles and writes the message to each of them, but there seems to be a lot of magic in printf that I don't understand
08:02:41 <b2coutts> currently I've just made a function `shout :: [Handle] -> String -> IO ()', but it's cumbersome to call it with `shout handles $ printf formatStr args' instead of simply `shout handles formatStr args'
08:03:23 <b2coutts> is there a nice way to make this function, or should I just keep tiptoing around the magic of printf?
08:04:08 <vanila> b2coutts, I would not recommend to use printf
08:05:03 <vanila> well you could if you want
08:05:31 <vanila> if you just write the declaration:
08:05:32 <vanila> hPrintfs :: HPrintfType r => [Handle] -> String -> r
08:05:32 <b2coutts> vanila: why not? while I dislike the fact that I don't really understand how it works, it's certainly less cumbersome than constructing strings with show and ++
08:05:41 <pjdelport> b2coutts: You can trivially define a function with the signature of the latter that just calls the former.
08:05:45 <vanila> then you don't need to actually know anything about printf to implement I think
08:05:46 <vanila> just
08:05:59 <vanila> hmm
08:06:06 <vanila> you might need [r] as the output
08:06:25 <vanila> hPrintfs hs s = map (\h -> printf h s) hs
08:06:49 <vanila> but if this ends in IO you will need to sequence it separately
08:07:04 <vanila> overall it seems bad, I wouldn;t recommend it
08:07:17 <b2coutts> vanila: what would you do instead?
08:07:47 <vanila> well if you want to use format strings, it's possible to build these in a more sensible using GADTs instead of typeclassesof
08:08:03 <vanila> personally I would just write presentation functions without a format string setup
08:08:21 <tremon> I'm probably missing something easy, but I really don't get it. I've now removed the Char8 import (I wasn't using it anyway, just to figure out this error) and updated the paste
08:08:42 <b2coutts> I'd end up writing a lot of presentation functions that I'd only use once, though
08:09:23 <vanila> is it bad to inline them? I mean, how cumbersome is the syntax to write them
08:09:24 <b2coutts> I'm not dead-set on format strings, but I do want short, readable code
08:09:45 <vanila> something as simple as (^) = (++) could make code a lot more readable
08:10:30 <quchen> tremon: decodeLatin1 expects a strict BS, you give it a lazy one.
08:11:06 <tremon> ah. progress :)
08:11:06 <quchen> I suggest you use Data.Text.Lazy.Encoding.
08:11:47 <tremon> yes, that makes sense. Hadn't though of looking for a lazy text module
08:11:55 <tremon> thought that is
08:12:32 <tremon> thanks, that works
08:16:17 <tremon> quchen: I see you mentioned it before. It didn't register because I was looking at the bytestring modules, not data.text
08:20:57 <b2coutts> vanila: also, sequencing doesn't quite work; the return type of hPrintf is (HPrintfType r) => r, which can't be sequenced
08:21:22 <b2coutts> I feel like I probably need to have some understanding of the HPrintfType typeclass in order to do this
08:21:26 <vanila> yeah that's the problem, you have to use s = hPrintfs ; then sequence s
08:21:39 <vanila> it's not that you don't understand Printf well, it's just that Printf sucks
08:21:39 <csabahruska> hi, does the haskell wiki login work for you now?
08:21:51 <b2coutts> well, probably both :P
08:21:55 <vanila> hehe
08:22:29 <b2coutts> I'll probably just make it print a normal string to all the handles; thanks for the help
08:24:03 <Ainieco> hello, how can i convert Data.ByteString.Lazy.Internal.ByteString to String?
08:24:39 <Ainieco> i'm a little suspicious about Data.ByteString.Char8.unpack because of Char8, will it work with unicode?
08:25:10 <nclarke> Not necessarily
08:25:26 <nclarke> The answer is, you can't necessarily convert a ByteString to String
08:25:37 <nclarke> Because it might not necessarily represent text
08:25:47 <nclarke> If it does, you'd be better using Text rather than Bytestring
08:26:19 <nclarke> Text has stuff handling encodings and the like, so you can make use of those to safely convert to String
08:26:39 <Ainieco> nclarke: i'm using Wreq library to get contents of web page which contains unicode i need to convert unicode body to string
08:26:41 <quchen> Ainieco: No, don't use BS.Char8. Also, you probably don't want to use String.
08:26:52 <quchen> Text is a good type for text.
08:27:08 <quchen> It also comes with encoding functions.
08:27:12 <davidthomas> nclarke: well, that's mostly true... though another way of saying it is you convert a bytestring to a string by way of an encoding
08:27:14 <Ainieco> quchen: i want, because i want to use handsome soupe parseHtml which works with string only
08:27:56 <pjdelport> Ainieco: ByteString is generally meant for binary data; the Char8 stuff is only for partially supporting ASCII-like data, where it's convenient. It's not meant to support Unicode.
08:28:33 <pjdelport> Ainieco: Data.Text is basically "ByteString for Unicode"
08:30:12 <nclarke> davidthomas: But that supposes there *is* an encoding. BS may not be an encoding of a string
08:30:39 <Ainieco> so to use Wreq i need to Text.unpack . decodeUtf8 $ (responseBody :: ByteString) ?
08:30:41 <eizo> how to force the evaluation of something before printing a message?
08:30:51 <bartavelle> I thought there was a package for "sets with count", ie. Map x Integer, where the integer is > 0, but can't find it
08:30:53 <Ainieco> it'
08:31:03 <bartavelle> anyone got it in mind ?
08:31:19 <quchen> eizo: Depends on the types involved. evaluate, seq, deepseq are candidates.
08:31:23 <Ainieco> pjdelport: you probably need to say it BoS. :)
08:31:30 <pjdelport> bartavelle: https://hackage.haskell.org/package/multiset ?
08:31:35 <Ainieco> i'm only using his library
08:31:41 <bartavelle> pjdelport, exactly, thnaks !
08:32:02 <Ainieco> so/it/it to/
08:32:30 <pjdelport> bartavelle: There's http://hackage.haskell.org/package/multiset-comb too
08:32:41 <pjdelport> and a few others, probably
08:33:06 <pjdelport> (bartavelle: http://hackage.haskell.org/packages/search?terms=multiset :)
08:33:12 <bartavelle> I didn't have the "multiset" name
08:33:17 <pjdelport> oh, okay
08:33:18 <bartavelle> it's certainly easier to find some now :)
08:33:35 <no-n> > ord '@'
08:33:36 <lambdabot>  64
08:35:30 <Ainieco> is it appropriate to use "show byteString" instead of "Text.unpack $ decodeUtf8 byteString"?
08:36:18 <quchen> Show is not for prettyprinting.
08:36:26 <quchen> https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
08:37:22 <Ainieco> quchen: show converts bytestring to string
08:37:31 <Ainieco> i'm asking in that context
08:37:58 <Ainieco> quchen: unpack not for pretty preting too, lol
08:39:17 <eikke__> Ainieco: 'show' converts a ByteString into a String as much as (\_ -> "This is a String, no strings attached") does
08:40:09 <quchen> Unpack is for converting Text to String. Show is a typeclass for debugging.
08:40:21 <quchen> If you want to convert text to string, use unpack.
08:40:58 <Ainieco> eikke__: show $ view responseBody resp -- renders text correctly
08:41:11 <Ainieco> quchen: okay
08:41:52 <Ainieco> ugh, is there a function with type signature Data.ByteString.Lazy.Internal.ByteString -> Data.ByteString.Internal.ByteString ?
08:41:55 <eikke__> Ainieco: by accident. That was my point: nothing guarantees 'show' maintains all information contained in whatever argument you give it.
08:42:04 <Ainieco> hoogle seems doesn't understand it
08:42:21 <eikke__> Ainieco: yes there is, depending on your version of bytestring. Check the API docs.
08:42:39 <Ainieco> eikke__: okay, thanks!
08:43:51 <eikke__> (fwiw, it's in Data.ByteString.Lazy)
08:44:07 <eikke__> make sure to read the warning in the docs
08:46:00 <Ainieco> eikke__: what warning? do you know how that function is called by chance?
08:47:39 <quchen> fromStrict/toStrict
08:48:00 <Ainieco> quchen: thank you!
08:50:54 <Ainieco> ah, warning about its expensiveness... alas i don't think there is something i can do about it, i'm using Wreq to get web page, it returns page as bytestring and i need to use hxt/handsomesoup on that page
08:50:59 <Ainieco> which works only with strings
08:51:34 <DogeHayashi> quchen: thanks for the earlier tip wrt <$, btw (I think it was quchen that suggested it… =p)
08:59:54 <albeit> If I have "type NetworkState = StateT Network IO" and a function "String -> Network State ()"  that needs to use the IO monad, how can I extract the IO Monad? Sort of the opposite of lift...
09:00:34 <quchen> runStateT?
09:00:35 <albeit> The function call another function of type "String -> IO ()"
09:01:51 <albeit> So I can extract the IO monad with runStateT, but how do provide that monad to the IO function?
09:03:37 <quchen> Got some example code? I don't understand the question.
09:04:16 <albeit> Sure: http://lpaste.net/103520
09:04:41 <albeit> The fold calls a function that requires the IO monad, which is wrapped by NetworkState
09:05:22 <glguy> albeit: You can use liftIO
09:05:37 <glguy> Because StateT implements MonadIO
09:06:14 <glguy> liftIO :: MonadIO m => IO a -> m a
09:06:22 <benzrf> hey
09:06:56 <benzrf> did anybody ever create something that takes a Pipes.Core.Proxy type signature and creates ascii art to make my head hurt less
09:07:06 <benzrf> im sorry but 6 parameters is a little painful
09:07:39 <quchen> The Pipes docs have plenty of pictures of this.
09:07:44 <glguy> Not that I advocate using it, but they have a bunch of type synonyms to hide the parameters you aren't using
09:07:53 <benzrf> glguy: oh, is there an issue with it?
09:07:59 <Lethalman> benzrf, you didn't see lens yet right?
09:08:07 <benzrf> Lethalman: i did but i ignored the types
09:08:09 <benzrf> for my own sanity
09:08:12 <Lethalman> :P
09:08:21 <benzrf> Pipes looks like something i could tame tho
09:08:24 * hackagebot tellbot 0.3.3.0 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.3.3.0 (DimitriSabadie)
09:08:26 <quchen> http://hackage.haskell.org/package/pipes-4.1.1/docs/Pipes-Core.html
09:08:41 <quchen> The picture is at the top of the module's doc you're asking about.
09:08:50 <benzrf> yeah
09:08:53 <benzrf> i mean, is there like
09:08:55 <benzrf> a generator
09:09:03 <benzrf> where you plug in a type and it makes one of those
09:09:26 <benzrf> or 2 types and it uses the same pipe in/out art for recurring vars
09:09:35 <benzrf> so that i can visualize the real type of for
09:09:36 <benzrf> ;p
09:09:46 <benzrf> glguy: why do you not advocate Pipes?
09:09:58 <benzrf> is it Considered Harmful™
09:10:20 <albeit> Okay, so if I "liftIO $ connectToServer key queue", that returns a NetworkState ThreadId instead of IO ThreadId. Then I would extract the ThreadId with runStateT?
09:11:50 <dv-_> @hoogle networkstate
09:11:51 <lambdabot> No results found
09:12:02 <Maior> why is MonadIO inside Network.CGI? :s
09:12:16 <albeit> type NetworkState = StateT Network IO (custom type)
09:12:24 <benzrf> albeit: you would extract it with bind
09:12:27 * benzrf whaps albeit on the head
09:12:30 <benzrf> it is just a monad
09:12:30 <bennofs> Can I undefine a variable I defined with let in ghci?
09:12:36 <benzrf> bennofs: you can redefine it
09:13:10 <bennofs> benzrf: it hides an imported entity
09:13:47 <Kron> does anyone know the name of that haskell debugging framework that asks you questions about your functions and then finds the problem area in your program?
09:14:04 <pjdelport> bennofs: :reload?
09:14:35 <dv-_> Maior: it's jut re-exported from Control.Monad.Trans
09:14:48 <Maior> dv-_: ah
09:14:49 <bennofs> pjdelport: i'd like to keep my other let bindings :) (only one should be deleted)
09:14:52 <Maior> dv-_: cheers
09:15:42 <allsystemsarego> hi all, I don't understand this particular sentence from the docs for swapMVar: "This function is atomic only if there are no other producers for this MVar." Could anyone clarify?
09:16:19 <benzrf> albeit: you have a StateT over Network and IO right?
09:16:29 <albeit> Yes
09:16:31 <benzrf> Okasu:
09:16:33 <benzrf> *ok
09:16:44 <albeit> I guess I'm just getting caught up on how to do it all inside a fold
09:16:54 <albeit> Trying to split it up into simpler parts right now
09:16:56 <benzrf> so a value of type NetworkState a is a monad producing a, right?
09:17:01 <benzrf> just forget that it is an MT
09:17:05 <benzrf> treat it as an ordinary monad
09:17:06 <hyPiRion> would the GHC optimise immutable structure "updates" to mutation if it's safe to do so? I assume not directly, but that e.g. inlining and LLVM IR may be able to detect small cases
09:17:08 <benzrf> that you can turn IO into
09:17:21 <quchen> You can probably do everything in a traverse, the fold is the manual version of what that would do
09:17:27 <benzrf> albeit: if you have 'm a' and you want an a, you use bind
09:17:33 <benzrf> even if m is NetworkState
09:17:33 <hyPiRion> just wondering whether there's any paper on such optimalisations or not
09:17:34 <benzrf> :-)
09:21:00 <eacameron> I need two tree structures to have leaves that point to the same data; how would I do this in haskell?
09:21:23 <eacameron> I C++ I would use pointers or references
09:21:26 <eacameron> *in
09:21:48 <davean_> eacameron: in Haskell it is inherant
09:22:01 <eacameron> davean_: what do you mean?
09:22:16 <pjdelport> eacameron: You can simply share the value in the leaves.
09:22:19 <davean_> I mean, haskell is a functional language
09:22:33 <davean_> which, enables sharing
09:22:34 <quchen> > let x = 1; let y = x in (x,y)  --  Both x and y share the same "1" in memory.
09:22:35 <lambdabot>  <hint>:1:78:
09:22:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:22:44 <pjdelport> eacameron: for example, let x = <...> in (x, x)
09:22:49 <zomg> I'm guessing that he wants it to work so that if you change one of the leaves, the other leaves "pointing" to the same structure also change
09:22:59 <davean_> This isn't quite true with unboxing, but it is irrelivent there
09:23:16 <pjdelport> Haskell values doen't change. :)
09:23:20 <eacameron> zomg: Actually I'm not worried about that; I just don't want to dup memory
09:23:29 <zomg> Ah alright, well in that case what they said. :)
09:23:38 <albeit> Okay, so I understand how to do it for one item: http://lpaste.net/103522. Now I need to implement it for [String] -> NetworkState (). Is that what I should use traverse for?
09:23:39 <allsystemsarego> > let { x = 1; let y = x } in (x,y)
09:23:40 <lambdabot>  <hint>:1:24: parse error on input ‘}’
09:24:02 <eacameron> I assume the same is true for "where" clauses?
09:24:13 <quchen> albeit: What's the type of 'queue'?
09:24:30 <allsystemsarego> > let { x = 1; y = x } in (x,y)
09:24:31 <lambdabot>  (1,1)
09:24:37 <quchen> > let x = 1; y = x in (x,y)  --  duplicate 'let' in my earlier code
09:24:39 <lambdabot>  (1,1)
09:24:50 <albeit> type Queue = Chan BS.ByteString
09:24:54 <pjdelport> eacameron: Generally speaking, Haskell implementations are free to merge or duplicate the run-time representation of values, if they deem it to make sense, but practically speaking, they don't do it without very good reason.
09:25:21 <albeit> A concurrent message queue
09:25:31 <albeit> holding lazy char8 bytestrings
09:26:00 <pjdelport> eacameron: When you explicitly share a binding, whether as parameter, or with let or where or similar syntax, you can generally rely on it not being duplicated at run-time.
09:26:05 <eacameron> pjdelport: ok that makes sense; so as long as I do something like this, I'm likely ok: "newThing = Thing (addTo tree1 leaf) (addTo tree2 leaf)"
09:26:22 <eacameron> that's sweet
09:26:30 <pjdelport> eacameron: Where "leaf" is some value? Yeah.
09:26:52 <eacameron> right
09:26:52 <eacameron> using C++ so much at work makes me think too hard about Haskell
09:27:23 <pjdelport> eacameron: It works with aliases, too; so if you say let x = <...>, y = x in <...>, then x and y will generally be the same thing
09:27:45 <pjdelport> eacameron: Intuitively, you could think of it as "names exist only at compile time"
09:28:07 <eacameron> ah ok; this is good news
09:31:38 <Okasu> What is the preferred library for command line options handling nowadays?
09:32:05 <quchen> albeit: I thought of something like this. http://lpaste.net/103523
09:32:20 <nclarke> Okasu: I don't think there is a single preferred lib
09:32:24 <nclarke> I like optparse-applicative
09:33:36 <albeit> quchen: I need to dig into some of the stuff you used, but that looks great! Thanks!
09:34:21 <Okasu> nclarke: It'll be great if there is something declarative enough to generate --help automatically.
09:34:28 <quchen> albeit: for = flip traverse; traverse = generalized mapM.
09:34:43 <nclarke> Okasu: optparse-applicative does that
09:34:51 <nclarke> And will generate bash autocompletion scripts
09:35:05 <quchen> nclarke: Oh, optparse-applicative does that too?
09:35:10 <nclarke> Yes
09:35:26 <Okasu> nclarke: Cool, I'll try that then. Thanks.
09:38:42 <quchen> Great, it's completely undocumented how to use the completer.
10:08:20 <albeit> quchen: Is your code, we need to construct a Map Key Key from a [Key]. I understand that it works, but is that the best way to do it? It seems a little wasteful?
10:13:30 <quchen> You want a Map anyway, don't you?
10:13:40 <albeit> In the end, yes.
10:14:16 <albeit> Oh I guesss for/traversable is implemented so its not really constructing a brand new map, just modifying the values of the map we create at the beginning.
10:14:24 <albeit> Well, "modify" into a new map.
10:14:45 <albeit> So we need to create a map sometime, we just do it at the beginning.
10:15:27 <quchen> You can also "map (\key -> (key, connect...)) keys" and then make that into a Map, but that's basically the same thing.
10:16:46 <albeit> Also, what is the "<>" called? I'm having a hard time searching for it
10:17:22 <glguy> It's the Data.Monoid operator for mappend
10:17:23 <ReinH> akshatj: it's a.k.a. `mappend` from Data.Monoid
10:17:42 <quchen> Another option would be using Map.fromSet, after converting the [Key] to a Set Key.
10:18:20 <quchen> That's probably a better way than what I did.
10:18:49 <akshatj> ReinH: ?
10:19:06 <quchen> (<>) = mappend.
10:19:09 <ReinH> argh
10:19:13 <ReinH> akshatj: wrong tab complete sorry
10:19:23 <quchen> Oh. I misread it too ;-)
10:22:15 <quchen> albeit: Like this then, http://lpaste.net/103524
10:22:21 <quchen> (Untested)
10:38:16 <pavonia> How does GHC know what text encoding is used for an input file?
10:38:34 <albeit> quchen: You're converting to Set because List isn't Traversable, correct?
10:38:44 <pavonia> Or is it always UTF-8?
10:39:17 <ReinH> albeit: [] is an instance of Traversable
10:40:57 <quchen> I'm converting to Set/Map because that's what you were using.
10:41:35 <quchen> You can do all Set/Map things with lists too, but it's much less efficient.
10:43:06 <quchen> pavonia: "Haskell uses the Unicode [2] character set. However, source programs are currently biased toward the ASCII character set used in earlier versions of Haskell." - H10 report
10:43:35 * hackagebot github 0.8 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.8 (JohnWiegley)
10:44:23 <ReinH> quchen: I think pavonia is referring to files read by a Haskell program as Text, not to .hs files?
10:44:39 <pavonia> No, I'm referring to .hs files
10:44:44 <ReinH> never mind me
10:45:15 <pavonia> But does that answer my question? I thought Unicode is only a char mapping scheme, not an encoding scheme
10:46:06 <tremon> that's strictly true, the encodings are utf-N
10:46:08 <geekosaur> pavonia, last I heard, ghc uses utf8 and falls back for backward compat reasons to iso8859-1
10:46:44 <geekosaur> note that older ghc versions did not understand utf8 source at all (I don't recall when this changed. 6.8?)
10:46:55 <pavonia> Okay
10:47:08 <pavonia> Hehe, my GHC is old but not that old :p
10:47:31 <geekosaur> the standard doesn't actially talk about encoding, which is reasonable because a compiler might well want to comply with platform standards, so on Windows it might want to use UTF16
10:47:52 <geekosaur> and it would be wrong for the language standard to constrain that kind of thing
10:49:04 <pavonia> That makes sense
10:49:20 <sm> hey all
10:50:15 <sm> are there any other platforms with users supported by GHC besides unix, mac, windows, (mobile), ... ?
10:50:53 <jle`> does web count?
10:50:53 <geekosaur> sm: iOS, android is in progress somewhere. there is a port to solaris/illumos but I don't know how recent or optimized it is
10:51:46 <sm> jle`: not for this, just tweaking my "cross-platform" marketing
10:51:54 <geekosaur> platform support is pretty dependent on people who are able and willing to help keep it supported
10:52:35 <sm> I think unix/mac/windows covers the possibilities for this app then, at the moment
10:52:37 <sm> thanks!
10:58:36 * hackagebot logging 1.4.1 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-1.4.1 (JohnWiegley)
10:58:38 * hackagebot language-lua 0.4.2 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.2 (OmerAgacan)
10:59:11 <b2coutts> is it possible to have a Handle in haskell which writes to stdout and reads from stdin?
10:59:19 <b2coutts> (I want this for testing purposes)
11:01:48 <nschoe> b2coutts, maybe 'interact' can be of interest to you ?
11:02:38 <ziman> :t stdin
11:02:39 <lambdabot> Not in scope: ‘stdin’
11:03:34 <ziman> ah, it's in System.IO.stdin
11:04:25 <b2coutts> nschoe: my use case is that I have code that just reads/writes with an arbitrary Handle
11:04:38 <b2coutts> and to test that code I want to be able to interact with it directly
11:05:04 <b2coutts> i.e. by supplying it with a handle that's connected to stdin and stdout
11:05:54 <nschoe> b2coutts, yes. Well interact is of type :: (String -> String) -> IO (). 'interact' will fetch content from stdin, pass is to your function and write the resiult to stdout. So I think you might use it
11:06:03 <ReinH> b2coutts: (I would recommend isolating as much of your code from IO as possible so your tests that use IO are as trivial as possible)
11:08:38 <allsystemsarego> hi all, a question about this code: http://lpaste.net/103528 - how can I get it to read from the keyboard? (relevant comments are at the right place)
11:08:45 <ReinH> One advantage of `interact' is that it forces you to do this by providing a pure function String -> String that cannot do IO
11:09:28 <ReinH> Then there is literally nothing to test -- unless you are concerned that GHC is lying to you about how it performs the IO ;)
11:09:43 <ReinH> (nothing to test for IO)
11:09:53 <jle`> allsystemsarego: what is the type of getInputChar ?
11:10:14 <b2coutts> ReinH: well, my use case is that I have a list of users, and each user has a Handle which I use to communicate with them
11:10:20 <nschoe> allsystemsarego, I don't think you can attach a terminal to a forkedThread ?
11:10:23 <b2coutts> (I may need to change this to a pipe or something later I guess)
11:10:28 <allsystemsarego> getInputChar :: MonadException m => String -> InputT m (Maybe Char)
11:10:48 <allsystemsarego> oh, I see, so what's a good workaround
11:10:50 <allsystemsarego> ?
11:11:11 <jle`> this is all from haskeline, right?
11:11:19 <allsystemsarego> jle`, yes
11:11:22 <b2coutts> but essentially I'm passing in a list of users with handles for communication, and right now I want to test using only a single user, and binding the handle to stdin/stdout so I can be that user
11:11:37 <ReinH> b2coutts: right, so my point is that you can test the "communicate via a handle" code separately from the "*what* you send over the  handle" code
11:11:38 <nschoe> allsystemsarego, depends on what you really want to do. But you can fork threads to do the computations and have your 'main' loop for user input
11:11:55 <ReinH> b2coutts: and if you replace a handle with some other transport mechanism you only need to replace the tests that are specific to the handle, which are relatively few.
11:12:10 <jle`> allsystemsarego: you are using runInputT but
11:12:20 <ReinH> b2coutts: and pure code is generally easier to test than things that require IO
11:12:21 <allsystemsarego> nschoe, I need a therad for console input, and another for console output
11:12:23 <jle`> nothing you are actually sequencing is inputT stuff
11:12:33 <jle`> every single line is just an IO action liftIO'd
11:12:55 <jle`> you might be able to move your runInputT into your forked thread
11:12:57 <nschoe> allsystemsarego, yes but a forked thread *can* output to the console, but cannot get input from it. So forked the thread that does output and keep the input part on your 'main'. That's whay I'd do.
11:13:09 <ReinH> b2coutts: you might want use some abstraction for the handle like a stream or channel instead and have the binding to a handle happen elsewhere
11:13:18 <jle`> i do not use haskeline though so i'm not sure what is normal there
11:13:45 <allsystemsarego> ok, I have two good suggestions, I'll try them both, thanks jle` nschoe
11:14:17 <bennofs> does fromIntegral have peformance overhead on GHC?
11:14:23 <nschoe> np
11:14:35 <ReinH> b2coutts: being able to test the core of the system without doing IO will be a benefit, I think.
11:14:37 <jle`> liftIO . forkIO . forever . runInputT defaultSettings $ getInputChar >>= liftIO . tryPutMVar >> treadDelay 10000
11:14:46 <b2coutts> ReinH: but the process is interactive; I'm not sure how I can test what I send over the handle without using IO
11:14:48 <jle`> um there should be paraentheses in the one-liner but you know what i mean
11:15:18 <ReinH> b2coutts: functions are "interactive". They accept input and provide output. ;)
11:15:43 <migimunz> Hello. Is there a way to automate writin this kind of tedious and repetitive code? https://gist.github.com/migimunz/47fc6374f084912b94df
11:15:45 <ReinH> b2coutts: The interface between your system and the outside world involves IO. Try to keep that at the boundaries.
11:16:20 <ReinH> The logic of your system doesn't involve IO, so you should be able to test it without doing IO.
11:17:26 <roconnor> In principle one can "test" IO by making monad class with the set of IO primitives you care about and have an IO instance and a test-harness instance.
11:17:43 <roconnor> I've never actually tried this.
11:17:46 <ReinH> roconnor: sure, you can use a "pure IO" monad (a free monad)
11:18:26 <ReinH> roconnor: but I think pushing IO to system boundaries results in a better design
11:18:33 <roconnor> indeed
11:18:34 <ReinH> so I'm not too interested in techniques to avoid doing that ;)
11:18:40 <roconnor> probably why I've never had to try this.
11:19:12 <b2coutts> ReinH: the high-level way my system works is by a function `runGame :: Game -> IO Game', which takes a game state, and communicates with the players to advance to a new game state; I think changing it to be of type `Game -> Game' would require keeping track of a lot of state in Game (i.e., exactly what the past interactions have been)
11:19:13 <roconnor> I don't even write programs.  I just write functions and run them in ghci.
11:19:29 <roconnor> ... lately I don't even do the second step. :P
11:19:39 <ReinH> b2coutts: this is actually a good case for a free monad for a different reason than roconnor's
11:19:46 <bddy> Hello. What's the difference between :t fromIntegral 5 and let x = fromIntegral 5 and print :t x ? http://lpaste.net/103529
11:19:55 <vanila> close to nirvana
11:19:59 <ReinH> you can drive the game state transitions using a free monad that is interpreted either via interaction with a user or some test harness
11:20:14 <ReinH> where your tests create the monadic values instead of depending on user input
11:20:38 <roconnor> bddy: the difference is that the let is subject to the stupid monomorphism restriction.
11:21:07 <bddy> roconnor: Eh, that's the only way to assign in ghci
11:21:36 <ReinH> b2coutts: this would be a good opportunity to get into free monads if you aren't familiar. Maybe operational.
11:21:59 <ReinH> b2coutts: you might enjoy the flexibility of being able to use the same monad for user interaction and tests and AI, for instance
11:22:17 <jle`> oh yes this a delightful case to write your own monad
11:22:45 <roconnor> bddy: I recommned disabling the monomorphism restriction in your ~/.ghci file.
11:22:53 <roconnor> bddy: it is really annoying in ghci.
11:23:07 <roconnor> bddy: it is also annoying in real programs as well, but even more annoying in ghci.
11:23:30 <ReinH> b2coutts: basically this is exactly why operational exists :)
11:23:39 * hackagebot monad-extras 0.5.8 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.8 (JohnWiegley)
11:23:41 * hackagebot shellmate 0.1.5 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.5 (AntonEkblad)
11:24:26 <b2coutts> ReinH: cool; I'm looking into operational now, thanks
11:24:40 <ReinH> b2coutts: :)
11:24:43 <Madark> roconnor: i know someone called robbyoconner...
11:24:43 <b2coutts> also, do you think handles the right thing for me to be using here?
11:25:01 <gabor> roconnor: thanks for your email. So you left the MathScheme project? Do you think I can send Carette the same mail?
11:25:09 <kgadek> hi all. Heard that 'random' package has some perf. issues. Would them be fixed by alternative RandomGen like from tf-random package?
11:25:30 <b2coutts> I'm basically only using them because they were the only thing I knew of, and I figured I could change it to the best choice once I got the engine working
11:26:06 <roconnor> gabor: I think you can
11:26:17 <ReinH> b2coutts: they probably aren't :) Luckily, an operational game monad will let you abstract over your choice of transport
11:26:22 <roconnor> Madark: not me.
11:26:26 <ReinH> b2coutts: and let your tests drive the game engine direclty rather than through IO
11:26:33 <gabor> roconnor: great, sorry for bothering!
11:26:37 <roconnor> np
11:27:20 <ReinH> b2coutts: then you hook an interpreter for your free monad that takes, say, a handle or a socket or an HTTP connection or whatever
11:27:42 <ReinH> b2coutts: and you can defer that choice until as late as you want while still being able to work on the engine directly
11:28:00 <roconnor> gabor: you should look into Florian Rabe's work on MMT.
11:28:40 * hackagebot consistent 0.0.1 - Eventually consistent STM transactions.  http://hackage.haskell.org/package/consistent-0.0.1 (JohnWiegley)
11:28:43 <b2coutts> awesome, thanks again!
11:29:07 <gabor> roconnor: I am mostly interested in the contextual category (plus pullbacks) stuff.
11:29:25 <ReinH> b2coutts: and once you get this working you should blog about it, as free monads in practice are a pretty interesting topic right now ;)
11:30:00 <ReinH> b2coutts: and using them to drive a test harness seems like a compelling use case. And anything that focuses more on testing in Haskell is a good thing imo.
11:30:11 <Madark> roconnor: nod
11:30:18 <fizruk> ReinH: you’re not the author of operational, are you?
11:30:21 <roconnor> gabor: contextual categories are pretty awesome.
11:30:22 <ReinH> fizruk: nope :)
11:30:30 <ReinH> fizruk: I found out about free monads relatively recently
11:30:47 <roconnor> gabor: I bought Bart's book.
11:30:53 <fizruk> ReinH: seems like your last name is just like author’s first
11:30:59 <ReinH> fizruk: huh
11:31:27 <ReinH> fizruk: oh yeah, it's close. He's the reactive-banana and threepenny guy too.
11:31:37 <erisco> flip fmap flip liftM2 = fmap flip liftM2 ?
11:31:49 <ReinH> erisco: what do the types say?
11:31:57 <erisco> ReinH, yes :D
11:32:08 <ReinH> erisco: can you transform one into the other via equational reasoning?
11:32:15 <erisco> ReinH, probably :D
11:32:23 <ReinH> erisco: if so then yes, if not then maybe
11:33:41 * hackagebot present 1.1 - Make presentations for data types.  http://hackage.haskell.org/package/present-1.1 (ChrisDone)
11:34:13 <gabor> roconnor: I liked how in finally-tagless form the needed typeclasses (see Oleg's lectures) resemble the pullback of context extensions
11:34:15 <fizruk> b2coutts: ReinH: there’s also a recent post by Gabriel related to testing user inputs http://www.haskellforall.com/2014/04/model-view-controller-haskell-style.html
11:34:32 <ReinH> fizruk: Apparently MVC means literally anything people want now ;)
11:34:36 <roconnor> gabor: is that true?
11:34:43 <ReinH> fizruk: I saw MVC on the Pipes mailing list and it's pretty cool though :D
11:34:47 <erisco> :t flip (fmap flip (flip (fmap flip liftM2)))
11:34:48 <lambdabot> Monad m => m a1 -> m a2 -> (a1 -> a2 -> r) -> m r
11:35:21 <erisco> :t flip (fmap flip (flip (fmap flip liftM2))) fst snd
11:35:22 <lambdabot> (a -> a2 -> r) -> (a, a2) -> r
11:35:24 <erisco> it is uncurry! :)
11:35:26 <ReinH> fizruk: but yes, that post does a great job of motivating this sort of solution. <3 Tekmo
11:35:58 <ReinH> Hell, maybe b2coutts might want to try MVC. It's a good fit for game engines.
11:38:41 * hackagebot stringable 0.1.3 - A Stringable type class, in the spirit of Foldable and Traversable  http://hackage.haskell.org/package/stringable-0.1.3 (JohnWiegley)
11:40:22 <gabor> roconnor: I have no proof, but (sans renamings) it automatically picks up the type classes that you reference
11:40:33 <fizruk> @pl \f (x, y) -> f x y
11:40:33 <lambdabot> (`ap` snd) . (. fst)
11:40:58 <erisco> :t uncurry -- fizruk
11:40:59 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:41:18 <fizruk> :t \f (x, y) -> f x y
11:41:19 <lambdabot> (t1 -> t2 -> t) -> (t1, t2) -> t
11:42:00 <fizruk> erisco: just thought pl might return something longer than your “flip fmap ..” thing :)
11:42:01 <gabor> roconnor: of course .when you diamond-derive from two typeclasses you get something not unlike your named theories
11:42:34 <erisco> fizruk, I came up with that silly thing because I accidentally wrote uncurry in terms of liftM2... so I made it pointless for fun
11:43:42 * hackagebot these 0.4.2 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.4.2 (JohnWiegley)
11:46:46 <gabor> is JohnWiegley a spambot that feasts on Hackage? :-))
11:46:51 <johnw> haha
11:46:59 <johnw> I'm just cleaning house
11:47:14 <johnw> using my git-all tool to see where I have unpushed stuff in my source tree
11:52:16 <btcNeverSleeps> when I write something like:   myLast(x:xs) = myLast xs    is (x:xs) similar to, say, Clojure destructuring?  Is it called "destructuring"?
11:52:40 <monochrom> I don't know Clojure. it seems safe to say yes.
11:52:59 <btcNeverSleeps> and it is called "destructuring" in Haskell?
11:53:02 <jle`> in haskell we like calling it pattern matching
11:53:38 <btcNeverSleeps> jle`: oh I see...
11:54:22 <jle`> also that would be tail, not last
11:54:24 <jle`> > last [1,2,3,4]
11:54:26 <lambdabot>  4
11:54:28 <jle`> > tail [1,2,3,4]
11:54:29 <lambdabot>  [2,3,4]
11:55:08 <gabor> btcNeverSleeps: while destructuring-bind works on lists only (my Lisp is rusty though), pattern matching works on all ADTs.
11:56:22 <btcNeverSleeps> jle`: that line I pasted is part of a function which ends up returning    myLast [x] = x    when it's done recursing ^ ^  It's actually the 1st of 99 Haskell problem.
11:56:37 <jle`> btcNeverSleeps: oh sorry
11:56:39 <jle`> i read it wrong
11:56:45 <jle`> you're totaly correct
11:56:54 <jle`> i thought it was myLast (x:xs) = xs
11:56:57 <btcNeverSleeps> my mistake, I only pasted one line
11:57:04 <btcNeverSleeps> so the context wasn't clear
11:58:22 <ReinH> btcNeverSleeps: it's called pattern matching, yes, and it's kind of a big deal :)
12:01:05 <btcNeverSleeps> and still in that  "myLast (x:xs) = ..." line,   ':' is part of Haskell's syntax? I mean: it's not a function right? (if I try to C-c C-t [ghc-show-type] on it I get the type of x)
12:01:25 <btcNeverSleeps> (at the same I don't see how it could possibly be a function)
12:01:57 <apples> :t (:)
12:01:58 <lambdabot> a -> [a] -> [a]
12:02:06 <btcNeverSleeps> apples: sweet!
12:02:52 <jle`> well
12:02:58 <jle`> it's a data constructor
12:03:17 <jle`> so it is both a function (that constructs data) and a 'destructor' when used in pattern matching
12:03:27 <btcNeverSleeps> I'm coming with stupid questions but it's hard to find by Googling when you don't know the terms ^ ^
12:03:41 <jle`> you can make a list by doing (1:[2,3])
12:03:45 <jle`> > 1:[2,3]
12:03:47 <lambdabot>  [1,2,3]
12:03:53 <jle`> but you can also "pattern match out" a list
12:03:56 <btcNeverSleeps> > 2:[3,4]
12:03:57 <lambdabot>  [2,3,4]
12:04:08 <jle`> > let (x:xs) = [1,2,3] in (x,xs)
12:04:09 <lambdabot>  (1,[2,3])
12:04:19 <jle`> when used as a "pattern", it..."undoes" the construction
12:04:59 <jle`> that is, if you used 1:[2,3] to make your list, then matching the list onto (x:xs) will match x to 1, and xs to [2,3]
12:05:32 <btcNeverSleeps> cool, got it
12:05:35 <jle`> in general it matches x to the first element and xs to the rest.
12:05:38 <xico> hi. after i installed hs-cabal with os's cabal, no package can be installed. everytime i do (local) cabal install anypackage, it complains about missing .h and stuff (including standard accessible, /usr/include, headers). using directly os's cabal keeps working though. any idea?
12:05:52 <jle`> btcNeverSleeps: but it might be important to note that List has two data constructors
12:06:00 <xico> (os cabal is 1.16.0.2, crappy one is 1.20.0.0)
12:06:16 <jle`> you can make a list with x:xs but you can also make a list with just []
12:06:21 <pjdelport> @src []
12:06:21 <lambdabot> data [] a = [] | a : [a]
12:06:36 <mornfall> :D
12:06:38 <jle`> so if you ever pattern match on a list
12:06:42 <jle`> you should take care of both "cases"
12:06:59 <jle`> because you can make a list in two distinct ways, so you have to also handle both distinct ways of breaking it down
12:07:06 <ReinH> btcNeverSleeps: the point here is that rather than being ad hoc, pattern matching works with any data constructor
12:07:18 <btcNeverSleeps> wait... how do I enter src [] at my REPL?
12:07:20 <ReinH> btcNeverSleeps: it is, in fact, the engine of Haskell's program evaluation
12:07:31 <ReinH> btcNeverSleeps: it's a feature of lambdabot
12:07:39 <jle`> btcNeverSleeps: src is not a repl command, sadly!
12:07:51 <btcNeverSleeps> so, to understand, I cannot make my own "function" (no matter what it does) that I could, say, use by calling it like this  "someFunc [x;xs] = ..." where ";" would be a function I'd have written myself?
12:07:52 <jle`> it's just a plain text search on a text file on lambdabot's server
12:08:03 <btcNeverSleeps> ah ok
12:08:09 <jle`> btcNeverSleeps: no, you can only pattern match on data constructors
12:08:15 <jle`> not on arbitrary functions
12:08:44 * hackagebot language-lua 0.4.3 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.3 (OmerAgacan)
12:08:51 <btcNeverSleeps> ok, makes sense
12:08:59 <jle`> if you know about Maybe
12:09:02 <btcNeverSleeps> yup
12:09:06 <jle`> data Maybe a = Just a | Nothing
12:09:21 <jle`> then you can do fromMaybe x Nothing = x; fromMaybe _ (Just x) = x
12:09:36 <jle`> or isJust Nothing = False, isJust (Just _) = True
12:09:45 <ReinH> btcNeverSleeps: if I wrote data List a = Nil | Cons a (List a), I could match on `Cons x xs' instead of (x:xs).
12:10:16 <btcNeverSleeps> thanks, these are interesting short examples
12:10:24 <ReinH> btcNeverSleeps: (:) is just an infix version of Cons
12:10:31 <ReinH> for the list data type defined by the prelude
12:10:36 <jle`> you can tell if something is a data constructor if it starts with a capital letter, or if it's an operator that starts with a colon.  (and also, if it's not a type or a type constructor)
12:10:43 <ReinH> which is what pjdelport showed you
12:10:50 <ReinH> there isn't anything special about the (x:xs) pattern
12:12:16 <ReinH> btcNeverSleeps: and indeed I don't need to use (:) infix at all:
12:12:18 <ReinH> > let myHead ((:) x xs) = x in myHead [1,2,3]
12:12:19 <lambdabot>  1
12:12:32 <btcNeverSleeps> ReinH: oh that is really sweet
12:13:06 <ReinH> so (:) works like any other data constructor except that it is syntactically a valid operator so can be used infix
12:13:35 <ReinH> you can define your own data constructors as operators
12:13:53 <btcNeverSleeps> and then they can be used in infix notation?
12:14:17 <monochrom> yes
12:14:50 <ReinH> as jle` said, they just need to begin with a :
12:15:13 <btcNeverSleeps> ok I see
12:15:15 <jle`> it's typically less common than using normal prefix names though, fwiw
12:15:44 <btcNeverSleeps> ok... But it's just to understand how it works.
12:15:51 <jle`> yeah
12:18:03 <monochrom> @type UTCTime
12:18:04 <lambdabot> Not in scope: data constructor ‘UTCTime’
12:18:15 <monochrom> @undefine
12:18:15 <lambdabot> Undefined.
12:18:30 <monochrom> @let data Mono = Mono Char Bool
12:18:32 <lambdabot>  Defined.
12:18:51 <monochrom> case Mono 'x' False of c `Mono` b -> c
12:18:54 <monochrom> > case Mono 'x' False of c `Mono` b -> c
12:18:55 <lambdabot>  'x'
12:18:59 <monochrom> \∩/
12:19:07 <btcNeverSleep2> erf... Wanted to save all your explanation from Emacs and tried to C-x C-s the erc IRC buffer and it apparently borked my Emacs : (
12:19:18 <ReinH> btcNeverSleep2: for instance if I wanted to I could define a tree as `data Tree a = a :< [Tree a]'
12:19:22 <btcNeverSleep2> (but the explanation have been saved)
12:19:44 <vanila> that's a really cool data type
12:20:29 <btcNeverSleep2> ReinH: and :< already exists or you're saying you could define :< as a new data constructor (?)   ?
12:20:31 <ReinH> btcNeverSleep2: I can then construct a tree like: `"foo" :< []' and pattern match like root (x :< _) = x
12:20:46 <ReinH> btcNeverSleep2: when I say data Tree a = a :< [Tree a], I'm defining (:<)
12:21:24 <ReinH> (btw this is Cofree f a where f is [])
12:21:51 <ReinH> you get other cool structures if you pick other functors
12:22:35 <ReinH> I think edwardk picked :< because it looks like branching? At least that's what I'm going with.
12:23:01 <btcNeverSleep2> that is really impressive. But I'll have *lots* of reading to do.
12:23:15 <ReinH> btcNeverSleep2: you sure do :D but make sure you try to build stuff and experiment as you go
12:23:18 <cin> :< looks like someone had a bad day
12:23:24 <ReinH> cin: heh
12:24:21 <btcNeverSleeps> and just out of curiosity:   ":?"  works where '?' is any printable Unicode character?
12:24:33 <ReinH> btcNeverSleep2: I'm not 100% positive of the grammar rules there tbh
12:25:07 <n-dolio> : prefixes operator constructors. The rest of the characters must be operator characters.
12:25:46 <ReinH> Hmm... is Cofree a way of getting some sort of free applicative from a functor? Where's edwardk when you need him.
12:25:56 <ReinH> n-dolio: makes sense
12:26:10 <monochrom> :∀ is ok because ∀ is considered a symbol. :α is not ok because α is considered a letter
12:26:21 <n-dolio> Cofree f is the cofree comonad over f.
12:26:32 <ReinH> n-dolio: Right, but it's also applicative.
12:27:18 <ReinH> but it's a different applicative than the free applicative for f. I'm wondering what the relationship is.
12:28:02 <ReinH> I suppose it's just the applicative for the comonad
12:28:38 <ReinH> Hmm is a Comonad not Applicative
12:28:43 <jle`> johnw: do you always instance your monads and applicative through Bind and Apply and Pointed
12:28:54 <quchen> ReinH: I'm a very poor substitute, but I can at least say that "Co" Applicative comes "after" Comonad in the hierarchy.
12:28:59 <n-dolio> Why would it be, necessarily?
12:29:08 <johnw> jle`: no, I only maintain that library, I didn't originally write it
12:29:11 <ReinH> n-dolio: it wouldn't
12:29:17 <quchen> (There's no "coapplicative". I'm not sure what the thing with <@> is called in the libs, but that's what I mean.)
12:29:28 <quchen> "ComonadApply" rings a bell.
12:29:38 <ReinH> quchen: there isn't? Then what is a "strong lax symmetric semi-monoidal comonad on the category Hask of Haskell types"?
12:29:45 <ReinH> Right, that's ComonadApply
12:30:01 <ReinH> which looks like Coapplicative to me but probably isn't because it doesn't have the right adjunctions or something
12:30:08 <quchen> Well, there's no Coapplicative, but there's "Coapplicative", which is ComonadApply. ;-)
12:30:19 <ReinH> quchen: ok :)
12:30:27 <quchen> Coapplicative is Applicative I think.
12:30:39 <ReinH> Oh. Ah.
12:30:44 <btcNeverSleeps> I'm familiar with lazy evaluation, FP and even already used some monads, etc.  Do I need to know about comonads, applicative, functors, arrows, etc. to be able to develop in Haskell?
12:30:49 <quchen> f (a -> b) -> f a -> f b  ⇒  flip arrows  ⇒  f (b -> a) -> f b -> f a
12:30:50 <ReinH> I guess I need to draw some diagrams for applicative to see
12:30:58 <ReinH> btcNeverSleeps: nope
12:31:05 <btcNeverSleeps> ReinH: that's a relief : )
12:31:06 <DR6> btcNeverSleeps not comonads and arrows
12:31:13 <ReinH> btcNeverSleeps: you'll find yourself using a lot of functors but they can be completely explained by the type and laws of fmap
12:31:18 <Eduard_Munteanu> btcNeverSleeps: Applicative and Functor yes
12:31:18 <ReinH> btcNeverSleeps: without any recourse to category theory
12:31:19 <DR6> if you have used monads you already understand functors
12:31:24 <DR6> and probably applicative
12:31:31 <DR6> so don't worry about those either
12:32:07 <DR6> besides, in most cases applicative is just a nice syntax for things which are actually monads
12:32:09 <btcNeverSleeps> Eduard_Munteanu: ok, putting that on my "to learn" list
12:32:11 <DR6> there are exceptions
12:32:13 <ReinH> quchen: what about pure?
12:32:31 <Eduard_Munteanu> btcNeverSleeps: you probably already met Functor in some other form, though
12:32:36 <DR6> btcNeverSleeps: but you say you understand some monads?
12:32:41 <DR6> all monads are functors
12:33:13 <btcNeverSleeps> DR6: I've used the state monad, for example
12:33:28 <DR6> oh, so only specific ones
12:33:32 <DR6> well, it's a start
12:33:35 <btcNeverSleeps> :)
12:33:37 <DR6> functors are really easy
12:33:59 <Eduard_Munteanu> btcNeverSleeps: do you understand how it works, or have you simply used State before?
12:34:07 <DR6> they are just things that let you transform functions a -> b to functions f a -> f b
12:34:15 <DR6> like `map` for lists
12:34:32 <jle`> > fmap (+ 3) (Just 5)
12:34:34 <lambdabot>  Just 8
12:34:52 <DR6> and if functors let you appy a function with a single argument over a container, applicatives let you apply functions with several arguments
12:35:05 <DR6> > (+) <$> (Just 1) <*> (Just 2)
12:35:06 <lambdabot>  Just 3
12:35:27 <ReinH> quchen: I found a thing. http://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com
12:35:33 <DR6> <$> is just fmap
12:35:35 <DR6> :t <$>
12:35:36 <lambdabot> parse error on input ‘<$>’
12:35:41 <DR6> :t (<$>)
12:35:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:35:47 <jle`> > pure (+) <*> Just 1 <*> Just 2
12:35:48 <lambdabot>  Just 3
12:36:07 <jle`> or maybe
12:36:12 <jle`> > Just (+) <*> Just 1 <*> Just 2
12:36:13 <lambdabot>  Just 3
12:36:24 <jle`> > (+) 1 2
12:36:25 <lambdabot>  3
12:36:55 <ReinH> btcNeverSleeps: the motivation for Applicative is to abstract the concept of function application. I find it's best to think about it in those terms and to read the original paper that introduced them http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
12:37:14 <ReinH> Or you can just use them a lot and develop an intuition
12:37:24 <jle`> there's also http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
12:37:58 <johnw> aren't Arrows intended to abstract function application, while Applicative allows for lifting application into the Functor?
12:38:12 <johnw> i.e., <*> = liftA2 ($)
12:38:13 <btcNeverSleeps> ReinH: paper saved
12:38:18 <Cale> johnw: composition
12:38:25 <jle`> maybe Arrows are intendded to abstract functions and function composition
12:38:28 <Cale> :t (<<<)
12:38:29 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
12:38:29 <johnw> ah, ok
12:38:38 <jle`> Cale is smarter than me
12:38:57 <btcNeverSleeps> DR6: ah good, so once I'll have understood what functors are, I should be on my way to understand applicatives :)
12:39:01 <DR6> yes
12:39:21 <jle`> Cale: edwardk has come on record saying that you were a big part of his road to learning haskell
12:39:28 <ReinH> btcNeverSleeps: Applicatives are functors with some extra stuff. Monads are applicatives with some extra stuff.
12:39:31 <jle`> Cale: was there a moment in time when you first realized what you had created?
12:39:36 <DR6> you should also have a grasp of currying, since it's essential to <*>
12:39:40 <Cale> jle`: ?
12:39:47 <ReinH> btcNeverSleeps: A good way to look at it is to ask "Why can't I do with a Functor that I *can* do with an Applicative"
12:39:48 <Cale> :t app
12:39:49 <lambdabot> ArrowApply a => a (a b c, b) c
12:39:55 <ReinH> btcNeverSleeps: and the same for Applicative to Monad
12:40:06 <Cale> There is app in ArrowApply, but instances of ArrowApply are secretly monads.
12:40:18 <Eduard_Munteanu> ReinH: monads aren't really related to applicatives (except in Haskell), and comonads aren't related to coapplicatives either, so I wouldn't look for a middle ground between Functor and Comonad.
12:40:25 <DR6> :t fmap (+) (Just 1)
12:40:26 <lambdabot> Num a => Maybe (a -> a)
12:40:37 <shachaf> Eduard_Munteanu: What is "coapplicative"?
12:40:48 <ReinH> Eduard_Munteanu: that's true. It's only a coincidence of working within a single category.
12:40:54 <DR6> so it when you apply a function with several arguments to a container, you get a function inside the container, because of currying
12:41:01 <n-dolio> shachaf: It's a word people throw around, assuming it's well defined.
12:41:02 <DR6> and
12:41:05 <DR6> :t (<*>)
12:41:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:41:11 <Eduard_Munteanu> shachaf: the dual of applicative
12:41:14 <DR6> applicatives let you apply the second argument
12:41:19 <shachaf> Eduard_Munteanu: What is that?
12:41:34 <ReinH> n-dolio: it's actually a word I was throwing around wondering if it was well defined :)
12:41:39 <Eduard_Munteanu> shachaf: an applicative on Hask^op seems like a suitable definition
12:41:43 <Cale> jle`: Edward was very clever long before he met me. I just happened to be in the right place to explain some things like I usually do. :)
12:42:22 <shachaf> Eduard_Munteanu: What does that work out to be?
12:42:27 <johnw> co-applicative would be (f a -> f b) -> f (a -> b)?
12:42:50 <shachaf> Eduard_Munteanu: Hask^op isn't cartesian closed, for one, so distinctions between "monoidal" and "applicative" probably start to become relevant.
12:43:02 <ReinH> shachaf: I'm working through the answer to this SO question http://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com
12:43:46 <ReinH> shachaf: which mentions that concern and a few others
12:43:51 <gamegoblin> Mmmm just used liftM3 for the first time. I wonder what the distribution of usage of liftM{N} is. I use liftM and liftM2 all the time.
12:44:01 <Eduard_Munteanu> shachaf: well, you could define it in terms of coexponentials, I think
12:44:25 <n-dolio> Those things that don't exist?
12:44:40 <Eduard_Munteanu> n-dolio: in Hask or generally?
12:44:46 <n-dolio> Hask.
12:45:08 <Eduard_Munteanu> Well, yeah... I know there are no coapplicatives in Hask.
12:45:38 <Eduard_Munteanu> I just meant to say coapplicatives shouldn't be considered a middle ground between functors and comonads.
12:46:02 <ReinH> Eduard_Munteanu: that SO answer cleared up a lot of things for me :)
12:46:23 <n-dolio> Also, using coexponentials is not necessarily what you originally said.
12:46:39 <n-dolio> Because Hask^Op has unit and product as monoidal structure, same as Hask.
12:46:57 <n-dolio> But if you're talking about coexponentials, you have instead switched monoidal structure to coproduct and empty.
12:47:53 <albeit> :t flip
12:47:53 <lambdabot> (a -> b -> c) -> b -> a -> c
12:48:17 <tremon> does Data.Binary (or another module) have support for bit-aligned fields? I'm parsing a format that liberally uses 10- or 11-bit fields
12:48:18 <Eduard_Munteanu> n-dolio: AFAIU, the interesting bit about applicatives is they preserve exponentials, which is implied by the closed functor definition.
12:48:39 <ReinH> n-dolio: Interesting. Seems that if you do that you get something like this http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
12:48:49 <n-dolio> Closed categories are defined in terms of some monoidal structure on the category.
12:48:56 <joseph07> :t flip . flip
12:48:57 <lambdabot> (b -> a -> c) -> b -> a -> c
12:50:14 <n-dolio> (Hask, (,), ()) is a monoidal category, (Hask, Either, Void) is a monoidal category, (Hask^op, (,), ()) is a monoidal category, (Hask^op, Either, Void) is a monoidal category.
12:50:16 <Eduard_Munteanu> n-dolio: and a coexponential would be an exponential in Hask^op, so I'm not sure why you're saying my definitions don't line up.
12:50:59 <n-dolio> (Hask, (,), ()) is closed, with (->) as exponential.
12:52:34 <ReinH> Oh man, what have I started o_O
12:52:53 <n-dolio> Because why did you switch from (,) and () to Either and Void when you said "Applicative on Hask^op"?
12:53:30 <n-dolio> You could still use (,) and () on Hask^op.
12:53:50 <n-dolio> And it won't have exponentials, but neither will it with Either and Void.
12:54:33 <n-dolio> There isn't just one thing here you can flip. There are many.
12:58:05 <Eduard_Munteanu> n-dolio: wait, are you saying my definitions didn't make sense, or that all definitions of coapplicative don't make sense generally?
12:58:39 <Eduard_Munteanu> And in any case, I don't think Hask is a good example for defining them.
12:59:50 <n-dolio> I'm saying that there are multiple dimensions on which "dual of Applicative" can be built, and "Applicative on Hask^op" is ambiguous, and isn't necessarily the same as "cocartesian closed functor."
13:00:16 <n-dolio> Cocartesian closed functors are really boring, of course.
13:00:30 <n-dolio> Because cocartesian closed categories are equivalent to the terminal category.
13:01:50 <zenzike> has anybody got advice about setting up lhs + tex mode in emacs?
13:02:41 <zenzike> (I'm a bit new to emacs, so I can't tell if mmm-mode is supposed to be easy to configure, and I'm doing it wrong, or if there's some other solution)
13:04:15 <Eduard_Munteanu> n-dolio: let F : C -> D, F is applicative iff F(B^A) = F(B)^F(A) and F(eval) = eval, eval : B^A x A -> B. It seems to me you can simply flip the eval there to get a sensible notion of coapplication. Does it still sound problematic to you?
13:05:49 <Eduard_Munteanu> Well, that is rather incompletely specified, but something along those lines.
13:06:29 <n-dolio> Yes. What is x? There are "closed monoidal categories" where the monoidal category structure is whatever you want.
13:06:44 <n-dolio> In Applicative we pick (,).
13:06:59 <n-dolio> Cocartesian categories are Either.
13:07:36 <n-dolio> But reversing the arrows doesn't have anything to do with changing the monoidal structure.
13:09:49 <Eduard_Munteanu> n-dolio: it would be the same object in the opposite category... possibly the (co)monoidal functor definition does not generalize nicely?
13:10:36 <n-dolio> If you look at the monoidal functor definition, there are even more axes you can tweak.
13:10:53 <n-dolio> Because you have C -> D. You can switch the monoidal structure of either C or D however you want.
13:11:23 <n-dolio> Independently.
13:11:47 <Eduard_Munteanu> Hm.
13:12:22 <n-dolio> (Hask, (,), ()) -> (Hask, Either, Void)
13:12:55 <n-dolio> That's () -> f Void and (f a, f b) -> f (Either a b)
13:13:33 <n-dolio> (Hask, Either, Void) -> (Hask, (,), ()); Void -> f () and Either (f a) (f ) -> f (a, b)
13:14:05 <n-dolio> Those are 'dual' in that the monoidal structure is dual.
13:14:12 <n-dolio> But they don't involve an opposite category.
13:15:12 <Eduard_Munteanu> I think some notion of coapplication as in 'f (a -> b) -> f b -> f a' seems natural for some reason. (looks a bit like coequalizers)
13:15:28 <n-dolio> Well, now that looks like a contravariant functor.
13:15:43 <n-dolio> Which is choosing Hask^op for one of them, but not both.
13:15:49 <pyon> I understand that (Hask, Either, Void) and (Hask, (,), ()) are both monoidal categories. But what exactly would a functor between them do?
13:17:33 <n-dolio> Monoidal functors preserve extra structure.
13:17:36 <Eduard_Munteanu> pyon: some functor could preserve the monoidal structure.
13:18:09 <n-dolio> I think I got the operations backwards earlier.
13:18:34 <n-dolio> (Hask, Either, Void) -> (Hask, (,), ()) is () -> f Void and (f a, f b) -> f (Either a b).
13:19:17 <n-dolio> You can also reverse the lax preservations.
13:19:23 <pyon> You mean (Hask, (,), ()) -> (Hask, Either, Void) ?
13:19:29 <n-dolio> And make it f Void -> () and f (Either a b) -> (f a, f b)
13:20:18 <n-dolio> No. Since the functor takes (Hask, Either, Void) to (Hask, (,), ()), f Void is in the same category as (), not vice versa.
13:20:30 <n-dolio> Well, in this case, they're both in the same category.
13:20:33 <pyon> n-dolio: Eduard_Munteanu: Yes, I am aware that monoidal functors preserve the monoidal structure. I should have said "monoidal functor".
13:21:19 <n-dolio> But you have in general: (C, xC, 1C) -> (D, xD, 1D), and 1D -> f 1C and (f a xD f b) -> f (a xC b)
13:21:27 <pyon> Ahhh!
13:22:04 <pyon> Those morphisms in general do not need to be isomorphisms, let alone identities, right?
13:22:25 <n-dolio> Right. If they're not isomorphisms then it's called a lax monoidal functor.
13:22:42 <n-dolio> If they're isomorphisms it's called strong, and if they're identities it's called strict.
13:28:58 <Eduard_Munteanu> n-dolio: hm, if I write elements and application as '1 ~~> a' and '(a ~~> b) -> (1 ~~> a) -> (1 ~~> b)', I think the only reasonable flip is flipping (~~>), similar to how (=<<) :: (a ~~> m b) -> (m a ~~> m b) is flipped to get the comonad extend.
13:31:58 <Eduard_Munteanu> But that's rather trivial.
13:33:01 <Eduard_Munteanu> Unless 1 is to be replaced with 0.
13:34:23 <n-dolio> What is ~~>?
13:35:39 <Eduard_Munteanu> n-dolio: an arrow in the category, as opposed to an arrow in whatever that category is enriched in
13:37:25 <Eduard_Munteanu> e.g. (~~>) could be newtype Op a b = Op (b -> a).
13:38:25 <n-dolio> I don't even know what we're talking about anymore.
13:38:55 * hackagebot ghci-ng 7.6.3.5 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.6.3.5 (HerbertValerioRiedel)
13:39:00 <n-dolio> Comonads and monads are not defined using extend in category theory, pretty much ever.
13:39:30 <Eduard_Munteanu> Well, sure, that derivation of 'extend' came to mind.
13:40:04 <shachaf> n-dolio: Especially monads.
13:40:07 <Eduard_Munteanu> The other edward explained it to me like that.
13:42:25 <shachaf> But I think defining monads in terms of Kleisli triples isn't unheard of.
13:46:23 <n-dolio> In that comonad is monad over opposite category, you'd get the ~~> arrows flipped.
13:47:21 <Eduard_Munteanu> Yes.
13:48:22 <n-dolio> But 'monoidal endofunctor on C^op' does not suggest the flipping of certain things.
13:48:31 <Iceland_jack> (╯°□°）╯︵ ┻━┻
13:49:12 <n-dolio> If (C, xC, 1C) is a monoidal category then (C^op, xC, 1C) is a monoidal category, and it seems reasonable to call that the C^op monoidal category.
13:49:21 <n-dolio> Which has the same monidal structure as C.
13:49:31 <Eduard_Munteanu> Iceland_jack: is that how you make a cotable? :)
13:49:39 <n-dolio> Since, in general, there's no reason to expect there to be some dual monoidal structure.
13:50:02 <n-dolio> There happens to be one for products vs. coproducts.
13:51:25 <Iceland_jack> Eduard_Munteanu: Yes :) eating cobreakfast is hard in my house
13:51:36 <n-dolio> For instance, (C^C, ., id) is a monoidal category. Monoids in it are monads.
13:51:53 <n-dolio> ((C^C)^op, ., id) is a monoidal category. Monoids in it are comonads.
13:53:53 <Eduard_Munteanu> n-dolio: but aren't we talking about preservation of (co)monoidal structure? If (xC, 1C) is a monoid in C, we could still talk about comonoids (xC, 1C) in C^op, no?
13:54:35 <n-dolio> Are you talking about my xC and 1C?
13:54:47 <Eduard_Munteanu> n-dolio: yes
13:54:58 <n-dolio> Because xC is a functor C x C -> C, and 1C is an object of C.
13:55:04 <n-dolio> They are not monoids in C.
13:55:12 <n-dolio> They are monoidal structure of C.
13:55:19 <n-dolio> C being a monoidal category.
13:55:27 <prinsen> How would I create a string with two ^A? (Control+A)?
13:55:42 <n-dolio> > '\a'
13:55:43 <Eduard_Munteanu> No, not monoids, I meant (C^op, xC, 1C) could be comonoidal.
13:55:43 <lambdabot>  '\a'
13:56:13 <n-dolio> There's no such thing as a comonoidal category.
13:56:29 <prinsen> Need them for gmail smtp, they write \001 in the guide but the B64-encoding doesn't match
13:56:48 <n-dolio> What character code is ^A?
13:57:08 <prinsen> n-dolio: the guide suggests \001
13:57:10 <Eduard_Munteanu> n-dolio: interesting... you mean there are no such categories, or that it doesn't even make sense? IOW, could you get comonoidal categories enriched in something else than Set or Hask?
13:57:20 <n-dolio> '\x01'
13:57:23 <n-dolio> > '\x01'
13:57:24 <lambdabot>  '\SOH'
13:57:53 <n-dolio> I mean I don't know what a "comonoidal category" is supposed to be.
13:59:26 <BeardedC-> So, with attoparsec I'm doing something like "many myParser <* endOfLine". How would I parse each line and return something like [Maybe a]. It currently stops on a bad line.
14:00:17 <Eduard_Munteanu> n-dolio: it seems rather straightforward to define one as (C, (+), 0) that yields a comonoidal structure up to isomorphism, no?
14:00:30 <n-dolio> What is a "comonoidal structure"?
14:00:36 <eacameron> how good is GHC with heap allocs?
14:00:38 <shachaf> For any Applicative f, f () is a monoid, with mempty = pure (), mappend = liftA2 (const ())
14:00:53 <joseph07> :t try
14:00:53 <lambdabot> Exception e => IO a -> IO (Either e a)
14:00:54 * eacameron realizes that's a very vague question...
14:01:29 <shachaf> For [] you get naturals with multiplication, for ZipList you get conaturals with min.
14:01:47 <shachaf> What are other interesting monoids that you get?
14:01:55 <Saizan> a monoidal category is a monoid object in cat, right?
14:02:39 <Eduard_Munteanu> n-dolio: it could be comonoid in Cat for example, or simply take a monoid object (x) :: M x M -> M, 1 :: 1 -> M, flip the arrows and replace 'x' by the (+).
14:02:58 <joseph07> BeardedC-: You might want to try using eitherP, where the first is your parser that returns your value, and the second is a parser that matches any line and returns something possibly useful for debugging
14:02:59 <monochrom> eacameron: very good IIRC. let me look at the generated asm code to remind myself the details
14:03:10 <n-dolio> Eduard_Munteanu: Why did you replace the x by +?
14:03:12 <BeardedC-> joseph07: I'll check that out. Ty
14:03:33 <benzrf> hey
14:03:38 <benzrf> aren't pipes supposed to be lazy?
14:03:39 <Eduard_Munteanu> n-dolio: just notationally, like you replace 'm' by 'w' after flipping arrows in monad definitions
14:03:55 <n-dolio> Okay, which x are you replacing by +?
14:04:07 <benzrf> oh wait...
14:04:27 <shachaf> For Maybe you get booleans with (&&), say. For Const m you get the original monoid back.
14:05:04 <n-dolio> (+) : M -> M x M and 1 : M -> 1?
14:05:05 <Eduard_Munteanu> n-dolio: not the one in 'M x M'
14:05:11 <Eduard_Munteanu> n-dolio: right
14:05:12 <n-dolio> Because now that looks trivial.
14:05:28 <n-dolio> 1 is the terminal category, so there's a unique M -> 1
14:05:41 <Eduard_Munteanu> n-dolio: I thought comonoids were more or less well-defined.
14:05:54 <Eduard_Munteanu> Oh, you mean the comonoidal category would be trivial.
14:06:07 <n-dolio> And M -> M x M is going to have to be a diagonal map for it to work with the trivial map.
14:06:21 <n-dolio> So every category is a 'comonoidal category' with useless structure.
14:06:30 <shachaf> For Either e you get First e.
14:07:10 <n-dolio> Generally, Cartesian comonoids are boring.
14:07:22 <n-dolio> I believe.
14:07:47 <n-dolio> As are cocartesian monoids.
14:09:03 <Eduard_Munteanu> n-dolio: ok, but we can work with that... suppose you define coapplicatives in terms of comonoidal structure preservation... F (A (+) B) -> F A (+) F B, if I got that right.
14:09:46 <benmachine> shachaf: have you noticed that Monoid (f ()) is actually just one instantiation of (Applicative f, Monoid a) => Monoid (f a)? (your question is still interesting regardless if you have or not :P)
14:10:03 <monochrom> eacameron: the heap is like a stack (except that once in a while GC compacts it). a register has the current heap pointer. a memory location has the current heap bound. allocation means incrementing the heap pointer and comparing against the heap bound. unless the comparison says "overflow" (in which case GC begins), that is the end.
14:10:10 <n-dolio> Eduard_Munteanu: (+) is not a bifunctor.
14:10:16 <n-dolio> But F is now.
14:10:37 <shachaf> benmachine: Hmm, I suppose that's true.
14:10:39 <benzrf> MFunctor is like a 1-layer functor instance for monad transformers, right?
14:11:08 <eacameron> monochrom: is that true solely for GHC?
14:11:14 <benzrf> man thank god for curried type constructors
14:11:43 <shachaf> benmachine: I was just thinking it was interesting that you get monoids like naturals with multiplication and conaturals-with-min, which don't usually come up.
14:11:53 <monochrom> I don't know. I only know GHC. I heard that JHC has the option of forsaking GC altogether, so it is likely similar.
14:12:04 <shachaf> But your instance is better. Is there a newtype for it?
14:12:21 <benmachine> shachaf: I'm not sure, proposing it was on my todo list back when I ever read my todo list
14:12:35 <Eduard_Munteanu> n-dolio: not sure why it wouldn't be a bifunctor. I'm also confused by F being called one. :/
14:12:35 <monochrom> in fact, for JHC the option is the other way round: old versions did not even have GC, new versions gives you a GC option, I heard
14:12:56 <n-dolio> Eduard_Munteanu: Because (+) : C -> C x C
14:13:01 <n-dolio> Bifunctors are C x D -> E
14:13:03 <Eduard_Munteanu> Oh, doh. :)
14:13:20 <benzrf> speaking of which
14:13:27 <benzrf> in MMonad, embed :: Monad n => (forall a. m a -> t n a) -> t m b -> t n b
14:13:28 <Eduard_Munteanu> Right, makes sense now.
14:13:44 <shachaf> @let newtype Appl f a = Appl { runAppl :: f a } deriving Show
14:13:46 <lambdabot>  Defined.
14:13:56 <shachaf> @let instance (Applicative f, Monoid a) => Monoid (Appl f a) where { mempty = Appl (pure mempty); mappend (Appl x) (Appl y) = Appl (liftA2 mappend x y) }
14:13:58 <lambdabot>  Defined.
14:14:08 <benzrf> why does that differ from (=<<)'s type other than the leading t
14:14:37 <shachaf> benmachine: conal-style
14:15:15 <benmachine> shachaf: something like that
14:15:26 <geekosaur> benzrf: look closely. m /= n
14:15:36 <benmachine> benzrf: if you squint sufficiently it's actually the same
14:16:00 <shachaf> benmachine: Squint enough that ~> starts to look like ->?
14:16:09 <benmachine> yes
14:16:21 <n-dolio> Using the right font helps, too.
14:16:24 <benmachine> benzrf: one useful insight might be that forall b. Monad n => (forall a. m a -> t n a) -> t m b -> t n b is actually equivalent to
14:16:36 <Eduard_Munteanu> That looks a bit like a 'p a (f b)' motif.
14:16:39 <benmachine> Monad n => (forall a. m a -> t n a) -> (forall b . t m b -> t n b)
14:16:51 <benzrf> ooh.
14:17:19 <benmachine> so (as I guess shachaf was hinting) define type f ~> g = forall a. f a -> g a
14:17:34 <benmachine> and that's Monad n => (m ~> t n) -> (t m ~> t n)
14:20:40 <Riccardo> yet another attempt to understand lenses, help please? the very first snippet in the tutorial uses "view _1 (1,2)" to get the left value. But the type signature involves a reader monad! And sure enough "runReader (view _1) (1,2)" works. what type sorcery allows view to work both with an extra argument and on the reader monad?
14:21:26 <shachaf> Riccardo: view used to have a type like view :: Lens' s a -> s -> a
14:21:43 <benzrf> Riccardo: well, Readers *are* functions...
14:21:49 <benzrf> :t runReader
14:21:50 <lambdabot> Reader r a -> r -> a
14:21:53 <Eduard_Munteanu> Riccardo: (->) r  is a MonadReader too
14:21:54 <benzrf> hmm
14:22:04 <shachaf> And there was a separate function with the type MonadReader m s => Lens' s a -> m a
14:22:13 <monochrom> hahaha today's xkcd. "runs custom blend of Android and iOS". talk about summing and crossing.
14:22:37 <shachaf> But it turns out that the MonadReader for (r ->) makes view redundant, so its type was expanded to work with any MonadReader instance.
14:22:48 <edwardk> i do kind of want to go generalize the operators for %~ and the like to work over MonadReader so they have a clear equivalence in power tot he %= ones for MonadState
14:22:49 <shachaf> It's not very important. You can pretend that it just takes an extra argument.
14:23:08 <edwardk> shachaf might hurt me though
14:23:47 <benzrf> >tfw im bad at massive types w/ 10 constraints and no concrete bits
14:24:00 * hackagebot tidal-vis 0.1.3 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.3 (AlexMcLean)
14:24:02 * hackagebot Hipmunk 5.2.0.14 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.14 (FelipeLessa)
14:24:19 <shachaf> edwardk: That seems kind of confusing, since it returns the new value rather than modify the state like %=
14:25:14 <haasn> :t asks
14:25:15 <lambdabot> MonadReader r m => (r -> a) -> m a
14:25:44 <edwardk> well, state gives back m ()   which is ((), t)  -- the %~ like just would give back t
14:26:29 <edwardk> just playing with the design a bit. i do want to drop the power of over, etc. to take arbitrary profunctors, at that point the MonadReader generality becomes possibe
14:26:31 <edwardk> er possible
14:26:39 <glguy> Maybe hide the discussion about making lens more consistent/confusing to -lens :-p so that when we don't do it fewer people know
14:26:40 <edwardk> not sold one way or the other right now on it though
14:26:54 <edwardk> glguy: =) fair
14:28:10 <Riccardo> thanks let me meditate on this :D
14:28:22 <benzrf> lens types make me sad
14:28:37 <Riccardo> i'm trying to understand more closely this time because reading lens tutorial superficially only take you as far as the first type error
14:28:38 <benzrf> generally whenever i see a signature with more constraints than concrete types i shed a tear
14:28:47 <Riccardo> then you can go home
14:29:08 <benzrf> im learning Pipes
14:29:14 <benzrf> it's delightfully pipey
14:29:26 <edwardk> benzrf: the lens types are the way they are because of the language we have to work in. scrap haskell and start over and you can have prettier lenses
14:29:33 <benzrf> >tfw when
14:29:35 <edwardk> not particularly worth it to me, but ymmv ;)
14:29:44 <eacameron> monochrom: sorry, I meant relative to things like gcc or Java
14:29:52 <benzrf> we need a language where there are no concrete types, only interfaces
14:30:03 <benzrf> then instead of Monad m => m we have Monad
14:30:07 <monochrom> I don't know them either
14:30:25 <eacameron> monochrom: My concern is that people complain about heap allocs being expensive
14:30:33 <benzrf> (>>=) :: Monad a -> (a -> Monad b) -> Monad b
14:30:46 <eacameron> monochrom: (in C++, for example), so I'm wondering how GHC handles that kind of thing
14:30:49 <benzrf> oh wait i guess having vars helps for different instances
14:30:51 <benzrf> >.<
14:30:54 <glguy> benzrf: and now you don't know which of those "Monad" are the same
14:31:00 <eacameron> monochrom: stack vs heap memory
14:31:03 <benzrf> glguy: beat you to it :-)
14:33:02 <monochrom> well, the textbook explanation of malloc is: a list of free memory blocks is maintained, when you allocate you take a block or a fragment of a block, and it's considered expensive. but do you know why it is done and GHC doesn't do it? because for example C pointer type is not abstract enough.
14:34:45 <hiptobecubic> edwardk, what is wrong with haskell's type syntax/language from the lens perspective?
14:34:57 <monochrom> suppose you are allowed to freely convert between pointers and numbers. then the run time cannot move your heap objects. it doesn't know which pointers need to be updated. because some pointers are hiding behind "int".
14:35:06 <hiptobecubic> obviously there are always a mountain of extensions being used, but given that those exist?
14:35:34 <shachaf> benmachine: You should propose this newtype!
14:35:36 <edwardk> hiptobecubic: my flight is about to take off, but you want a form of binder that doesn't exist. the 4 parameters fake it
14:35:43 <shachaf> benmachine: Do you know if it exists on Hackage anywhere?
14:36:10 <edwardk> also we are contorted around the existing library infrastructure, which forces the 'f''s into the p a (f b) -> p s (f t)   rather than  p a b -> p s t
14:36:24 <benmachine> shachaf: I do not know
14:36:24 <jle`> benzrf: also, one thing can be two different typeclasses
14:36:30 <monochrom> but suppose you are not allowed to freely convert between pointers and anything else. then the run time knows exactly who are pointers and who are not pointers, and can do the exactly correct update when moving heap objects. therefore, the heap can be pretty much a stack, plus occasional moving and compaction.
14:36:31 <benzrf> t-true
14:36:32 <jle`> :t show . (+ 4)
14:36:33 <lambdabot> (Show b, Num b) => b -> String
14:37:50 <hiptobecubic> edwardk, I see. enjoy your flight! lambdajam?
14:37:58 <hiptobecubic> when is lambdajam anyway?
14:37:58 <edwardk> yea
14:38:05 <hiptobecubic> fair enough
14:38:11 <edwardk> 8th-9th i think
14:38:15 <luite> :)
14:38:29 <edwardk> ok, shutting laptop
14:40:17 <benmachine> shachaf: I am eager to see it proposed but I am also lazy so
14:44:54 <Algebr> I'm having trouble with `cabal install sdl-mixer`
14:45:11 <Algebr> cabal craps out and says: configure: error: C compiler cannot create executables
14:45:39 <Algebr> I also tried `--with-gcc=gcc-4.8` and it didn't work. I'm on OS X, latest version.
14:55:18 <eacameron> monochrom: ahh, that is very helpful; so GHC can avoid much of the overhead with classic heaps because of its type safe guarantees?
14:55:52 <monochrom> yes. Java should have the same advantage as well. I just don't know what is actually done.
14:58:35 <Algebr> Why can't Java or C++ have full type inference? Is it because of nulls?
14:59:06 <plosi> Hey, I'm pretty new to haskell, and I was wondering what the best way to update information in the console in a loop is without just printing endless lines
14:59:21 <benbangert> I'm using quickcheck, and have an assert that compares 2 lists, it fails.... is there any way to see the contents of those two lists?
14:59:23 <pjdelport> Algebr: They could, to some extent; but it just isn't such a natural fit to the language.
14:59:41 <plosi> I saw that there's an Ncurses binding, but that seems not very idiomatic
14:59:41 <benbangert> having it show me the input params is not helpful enough...
14:59:52 <davidthomas> Algebr: Nulls don't break type inference... subtyping seems more likely to be a problem but I have no confidence that it would be
15:00:28 <pjdelport> Something like Hindley–Milner type inference touches a lot of aspects of a language; the type systems of C/C++ and Java make it hard to implement, or reap its benefits
15:00:36 <halcyon10> Hi, anyone know a good way to get rid of a spaceleak from using lazy bytestrings? I did a bit of searching and i read that it’s a good idea to add more strictness, but i don’t really know where a good place to add strictness would be for my program
15:01:12 <Algebr> pjdelport: but what about those type systems makes it hard to implement HM?
15:01:34 <vanila> Algebr, HM is easy to implement!
15:02:14 <vanila> oh not on C++ or java though
15:02:25 <pjdelport> Well, HM is easy to implement, but the way it's defined is in terms of things that are native to functional languages like ML or Haskell or similar
15:02:55 <pjdelport> C/C++/Java just work very differently, at a fundamental level
15:03:16 <pjdelport> A type inference system for them has to approach everything from different primitives
15:03:34 <albeit> When implementing an instance, in this case FromJSON for aeson, is it possible to specify which data constructor to use?
15:04:56 <enthropy> is there a straightforward way in quickcheck tests to say "this is true except when I get overflow?"
15:06:56 <Algebr> when I first saw newtype, I couldn't understand its utility...but now I wish I had it in python.
15:07:58 <Iceland_jack> Algebr: Do you mean so that you'd get a run-time error if you mix up different newtypes?
15:07:59 <bitemyapp> Algebr: 4rlz
15:08:16 <bitemyapp> Iceland_jack: Python code often reaches past APIs and breaks things in subtle ways.
15:08:26 <bitemyapp> Iceland_jack: Python-y runtime newtype would be a nice "mask" around that.
15:08:54 <ion> algebr: Warning: when learning Haskell you will be thinking “I wish I had this in $previouslanguage” more and more until you can’t help but switch from $previouslanguage.
15:09:07 <Iceland_jack> Definitely, but the best^Wstatic part would be missing
15:09:08 <Algebr> Iceland_jack: yea. Like say ZipCode, I could go with convention of using integers, but that's sloppy, or I have to make a ZipCode Object, which is silly.
15:09:28 <augur> whats a mock?
15:09:42 <bitemyapp> Iceland_jack: naturally.
15:09:43 <pjdelport> Algebr: You *can* just say "class ZipCode(int): pass" in Python
15:10:09 <Algebr> pjdelport: but then people will be adding it and I don't want people adding zipcodes.
15:10:36 <pjdelport> Algebr: You can override and disable arithmetic :)
15:10:54 <pjdelport> but yeah, it's not exactly the same convenience as e.g. newtype
15:11:04 <Algebr> pjdelport: but that's exactly my point, I'd have to write extra code to raise not implemented for many dunder methods
15:11:47 <pjdelport> you can abstract that away to a base or metaclass, at least
15:12:23 <pjdelport> What I miss more in Python is the convenience of plain ADTs
15:13:31 <Algebr> yea, that would be nice.
15:14:01 <pjdelport> namedtuple is a workable simile for single-constructor ADTs, but it's hard to get the convenience of sum types
15:14:37 <Algebr> pjdelport: yep, I've tried to get people to use namedtuple instead of classes for simple classes with no behavior.
15:14:45 <Algebr> err, coworkers.
15:15:21 * pjdelport uses namedtuple quite a bit
15:16:16 <Algebr> could a type signature like the following exist? Int -> IO String -> Bool
15:16:29 <bitemyapp> Algebr: it'd be a little strange but not impossible.
15:16:36 <benmachine> Algebr: yes, but there's not much it can do with the second argument
15:16:50 <benmachine> you can't really inspect IO actions in any way, you can only execute them, and that function can't do that
15:16:51 <Algebr> benmachine: why's that?
15:16:53 <Algebr> ah
15:17:08 <benmachine> there just aren't any functions from IO types to non-IO types
15:17:12 <benmachine> leaving aside cheating
15:17:20 <bitemyapp> Algebr: if it doesn't return IO, it can't really return a value influenced by IO
15:17:34 <bitemyapp> a different story: Int -> IO String -> IO Bool
15:17:35 <Hafydd> There is const :: IO a -> b.
15:17:37 <bitemyapp> still a little strange.
15:18:09 <benmachine> Hafydd: of course, yes
15:18:15 <benmachine> fine
15:18:35 <benmachine> non-constant functions :P
15:21:12 <Algebr> Is Xmonad basically Haskell's killer app?
15:21:31 <ChongLi> Algebr: I love it, that's for sure
15:21:35 <haasn> No, acme-missiles is Haskell's “killer” app
15:21:39 <benmachine> :P
15:21:47 <dbelange> 18:19 < Algebr> Is Xmonad basically Haskell's killer app?
15:21:48 <ChongLi> been using it daily for a few years now
15:21:49 <monochrom> is Haskell invented or discovered?
15:21:49 <dbelange> 18:19 < Algebr> Is Xmonad basically Haskell's killer app?
15:21:52 <dbelange> 18:19 < Algebr> Is Xmonad basically Haskell's killer app?
15:21:54 <dbelange> 18:19 < Algebr> Is Xmonad basically Haskell's killer app?
15:21:57 <dbelange> 18:19 < Algebr> Is Xmonad basically Haskell's killer app?
15:21:59 <benmachine> ...
15:22:02 --- mode: ChanServ set +o geekosaur
15:22:21 <ndrr> It's what got me using Haskell, I'm trying out i3 right now though
15:22:23 <benmachine> monochrom: yes.
15:22:29 <monochrom> haha
15:23:24 <jle`> actually...i don't know, i don't have too many problems switching from haskell to other languages
15:23:25 <dbelange> benmachine: isn't haskell based on constructive logic at some level
15:23:40 <jle`> my mind switches into different domains
15:23:40 * monochrom has long grown out of finding killer apps, because he has long grown out of popularity contests
15:23:40 * geekosaur actually suspects pandoc gets more widely used. also git-annex
15:23:54 <jle`> i can jump into C++ mode without too much problems
15:24:06 --- mode: geekosaur set -o geekosaur
15:24:08 <haasn> xmonad, while not what caused me to use Haskell, is what caused me to use Linux
15:24:09 <jle`> i don't even go "hm, i wish i had higher order functions here"
15:24:10 <benmachine> dbelange: not... really
15:24:32 <freeman42> anyone willing to accept me as a haskell apprentice? ^^ perhaps on an open source project? I am reading now my 2nd haskell book and have written 0 code xD and I need to start somehow
15:24:42 <benmachine> dbelange: Haskell has tangential relationships with constructive logic but in the sense of the type-system/logic correspondence, Haskell's type system is not a constructive logic
15:24:44 <jle`> freeman42: why don't you just start doing small things?
15:24:50 <haasn> Maybe you can be the apprentice of the 1305 people in #haskell
15:24:52 <benmachine> it is in fact inconsistent (which is fine)
15:24:53 <monochrom> /privmsg #linux is xmonad linux's killer app? :)
15:25:18 <freeman42> jle`, I am already working on a project in scala so I need someone to be responsible too or I would get lazy, and tehre is not enough time
15:25:18 <dbelange> is there an xmonad for wayland yet
15:25:20 <shachaf> is monochrom #haskell's killer app?
15:25:24 <haasn> dbelange: No
15:25:25 <bitemyapp> freeman42: I've been taking on apprentices.
15:25:30 <monochrom> yes :)
15:25:31 <shachaf> I say he is.
15:25:31 <jle`> freeman42: so you just want someone to keep you disciplined
15:25:39 <dbelange> is +b freenode's killer app?
15:25:41 <haasn> dbelange: It wouldn't be X monad if it was not based on X, I'd say
15:25:47 <jle`> having a mentor won't magically give you more time
15:25:49 <jle`> :)
15:25:59 <freeman42> ehm, something to work on and yeah, basically someone to see that the code I am writing is not bad :)
15:26:19 <jle`> i can usually find people on #haskell to review code :)
15:26:29 <freeman42> jle`, I know, but having very little time and trying to learn alone without responsability is much worse
15:27:06 <dmj`> are there any pkgs to get os stats? like cpu utilization, memory usage.
15:27:16 <dmj`> not of the haskell process, but of the os
15:27:29 <haasn> dmj`: You could try looking at what xmobar does to figure out these stats
15:27:39 <albeit> If I'm using applicative functors like "Foo <$>  obj .: "bar1" <*> obj .: "bar2"", can I somehow map it over a list of the bars (["bar1", "bar2", ...])?
15:27:58 <freeman42> bitemyapp, what projects would they help you with?
15:28:08 <pjdelport> freeman42: try something like http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
15:28:09 <haasn> dmj`: Looks like xmobar rolls its own parser for /proc/stat and /proc/mem
15:28:19 <haasn> /proc/meminfo*
15:28:35 <pjdelport> work through the problems, write solutions, and paste them here for people to look at if you think they can be improved
15:29:20 <bitemyapp> freeman42: they usually work on their own, there's only one person that's expressed in an interest in helping in one of my projects. And that's okay.
15:29:35 <freeman42> pjdelport, thanks, that is a good idea, I tried doing some Code Chef with Scala and it was cool
15:29:36 <bitemyapp> freeman42: so I guess it's not properly apprenticeship, but anyway. I've been giving advice on how to improve code, that sort of thing.
15:29:49 <dmj`> haasn: I want to get access to the windows task manager data w/ haskell
15:30:12 <halcyon10> Anyone know a good way to get rid of a space leak in a haskell program that uses lazy bytestrings? i already searched for solutions and read that adding more strictness is good but i’m kind of lost where to add those strictness annotations. Anyone there who could have a look at the code? the code is at https://github.com/haskell-munich/ZuriRBM i also added a shellscript ‘buildtest.sh’ in the repository which builds the
15:30:12 <halcyon10> application and shows the space leak in action.
15:30:41 <albeit> Guess I should start with, what is ".:" called?
15:30:45 <albeit> :t .:
15:30:46 <lambdabot> parse error on input ‘.:’
15:30:46 <jle`> albeit: like apply Foo to every item in bar?
15:30:55 <jle`> albeit: is that from aeson?
15:31:00 <freeman42> pjdelport, I would prefer to work on more large real-life projects though :)
15:31:02 <albeit> Yes... Foo is a type constructor.
15:31:15 <monochrom> I think it is called dot colon
15:31:24 <pjdelport> freeman42: You can just jump into that too, of course. :)
15:31:34 <monochrom> @type (.:)
15:31:35 <lambdabot>     Not in scope: ‘.:’
15:31:35 <lambdabot>     Perhaps you meant one of these:
15:31:35 <lambdabot>       ‘.’ (imported from Data.Function),
15:31:51 <jle`> freeman42: why don't you just write small little things, we can review them for you
15:31:55 <haasn> monochrom: http://hackage.haskell.org/package/aeson-0.7.0.3/docs/Data-Aeson.html#v:.:
15:32:04 <freeman42> pjdelport, noone seems to be interested though :(
15:32:26 <pjdelport> freeman42: It will take your own initiative; that's why smaller things are probably better. Work your way up.
15:32:31 <mmmm_> Anyone know how to make ghc-mod use cabal repl?
15:32:32 <haasn> albeit: traverse would probably work
15:32:35 <haasn> :t traverse
15:32:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:32:37 <freeman42> jle`, I'd rather not ask too many things in chat
15:32:45 <jle`> freeman42: what, that's what we're here for :)
15:32:50 <pjdelport> freeman42: Asking things is fine; that's what the chat is for.
15:33:02 <jle`> i think #haskell is literally just people asking and answering questions all day
15:33:11 <freeman42> jle`, I tend to ask a lot ^^ done that quite a lot in #scala and #scalatra
15:33:14 <jle`> and every once in a while complaininga bout lens
15:33:14 <haasn> :t let (.:) :: object -> String -> parser a; (.:) = undefined in traverse (undefined .:) ["a","b","c"]
15:33:15 <lambdabot> Applicative f => f [b]
15:33:24 <Maior> jle`: don't forget occasionally awesome cattheo chat
15:33:36 <jle`> yeah but those usually arise from questions about ct
15:33:42 <pjdelport> freeman42: just hanging out hear and listening to questions and answers is a good way to learn too
15:33:46 <Maior> (at least I assume it's awesome, I don't completely follow it)
15:33:50 <jle`> "teach me about ct" probably shows up more in -blah
15:33:57 <haasn> albeit: But then you need to get from a [a] to however your Foo works
15:33:58 <Maior> pjdelport: and that's why I loiter here ;)
15:34:06 <freeman42> also, this channel has gotten huge :D it might even become the channel with most users
15:34:10 * hackagebot ForkableT 0.1.0.1 - Forkable monad transformers  http://hackage.haskell.org/package/ForkableT-0.1.0.1 (AndrasSlemmer)
15:34:12 * hackagebot SimpleLog 0.1.0.2 - Simple, configurable logging  http://hackage.haskell.org/package/SimpleLog-0.1.0.2 (AndrasSlemmer)
15:34:13 <jle`> i always thought it was around there
15:34:40 <freeman42> pjdelport, yes, you are right, but I tend to lose a lot of time learning, that is why I really want to work on some 'real' project
15:34:57 <jle`> how about small mini projects?
15:35:01 <pjdelport> freeman42: You have to find something that interests you, then.
15:35:06 <jle`> within the scope of a week or so
15:35:07 <freeman42> pjdelport, reading haskell books, or solving small problems, or staying in chat (might end up for me to be a lot of time) seem like procrastination to me :(
15:35:25 <albeit> haasn: data FooType = Foo String String. So I need to do something like "myfoo = Foo [String]" I guess
15:35:31 <jle`> go and write a command line tic tac toe game
15:35:48 <Maior> freeman42: I started by porting Python stuff to Haskell (having previously spent time writing Python)
15:35:50 <hpc> and then next make it GUI
15:35:52 <freeman42> jle`, hehe, that is an idea :)
15:35:58 <haasn> albeit: If you're just doing this as a syntactical convenience you could also map over the result with something like \[a,b,c] -> Foo a b c
15:35:59 <jle`> or even easier, a command line hangman
15:36:17 <jle`> you can check out /q jlebot @hm new, for a reference implementation :)
15:36:18 <pjdelport> freeman42: http://hackage.haskell.org/packages/ has a *big* list; but maybe you can find something that interests you
15:36:31 <haasn> albeit: If the number of strings can vary, a list would probably be more appropriate
15:36:49 <pjdelport> freeman42: You can check out the projects' issue trackers to see if there are outstanding bugs or features you could try and tackle
15:37:03 <freeman42> I would also add, to work on a project that actually does something more useful for people (like, more than entertainment, games, etc.) xD
15:37:24 <pjdelport> freeman42: Or get in touch with the maintainers, for more detailed help and suggestions. (You'll probably get more valuable direction that way, than just asking in general.)
15:37:54 <freeman42> thing is, I was hoping there might be someone here working on projects and wanting an apprentice
15:38:35 <dmj`> +1 for command line hang man
15:38:36 <freeman42> pjdelport, yeah, good ideas :D I like the one with outstanding bugs or features
15:38:41 <dmj`> I have one of those written
15:38:42 <heatsink> The hackage server software needs some work.  They may have tasks you can do.
15:38:54 <Maior> freeman42: well
15:39:30 <Maior> freeman42: do me a favour and port https://github.com/openGPSoC/the_centile_app/blob/master/script_and_data/UK90/UK90algorithm.py to Haskell please? ;)
15:39:46 <heatsink> There's some UI stuff and algorithms involved
15:40:22 <freeman42> for example, I would sure love for someone to help me with the scala project I am working on, and I know a few people who wanted help with their typescript projects. I am thinking there have to be some people who work on Haskell projects and would love to have someone to help
15:42:49 <freeman42> Maior, what is this I don't even? xD https://github.com/openGPSoC/the_centile_app/blob/master/script_and_data/UK90/UK90algorithm.py
15:42:54 <binroot> What's the best way to do a HTTP GET request every 5 seconds to check for updates?
15:43:40 <haasn> binroot: perform a get request, sleep 5 seconds, repeat?
15:43:56 <ion> binroot: Use the If-Modified-Since and If-None-Match headers
15:43:58 <res22> quick question, how can I get map to take a function that returns a list instead of a list as the 2nd argument?
15:44:25 <ion> binroot: Use HTTP pipelining
15:44:31 <binroot> HTTP pipelining?
15:44:39 <heatsink> res22, write a function that takes the parameters you want, runs the function, and passes the list to map
15:44:44 <ion> Wait, let me check if i’m using the wrong term
15:45:32 <pjdelport> ion: You probably mean keep-alive?
15:45:33 <ion> binroot: What i should have said: keep the TCP connection open
15:45:34 <heatsink> Huh.  In Python, <- stands for the less-than operator followed by the minus operator.
15:45:54 <ion> pjdelport: Thanks
15:45:55 <binroot> ion: what's the best way to do that?
15:46:09 <mmmm_> Anyone know how to make ghc-mod use cabal repl?
15:46:18 <jle`> heh
15:46:28 <ion> binroot: Check that your HTTP client library supports persistent connections.
15:46:37 <res22> heatsink: you know what I'm completely off the mark, the issue was something else thanks
15:47:08 <pjdelport> binroot: Why do you want to do that, exactly? An HTTP GET every 5 seconds is usually pretty questionable.
15:47:21 <pjdelport> Do you have a good reason for it?
15:47:23 <binroot> pjdelport: I want the latest reddit posts
15:47:34 <pjdelport> binroot: Oh, use the feed?
15:47:38 <ion> Oh, i expected that you’re talking to your own service.
15:47:46 <ion> Make sure the service provider doesn’t mind.
15:48:01 <binroot> http://www.reddit.com/new.json
15:48:48 <ion> With the proper Last-Modified/ETag processing and proper caching on the server side, frequent HTTP requests for the same thing can be very cheap.
15:49:11 <binroot> ion: thanks! I'll look into Last-Modified
15:49:44 <pjdelport> binroot: Are you familiar with https://github.com/reddit/reddit/wiki/API ?
15:50:02 <tremon> note that you don't use GET to check last-modified, you should use HEAD
15:50:27 <ion> tremon: If-Modified-Since/If-None-Match with GET
15:50:35 <pjdelport> Note that the Reddit API might not implement If-Modified-Since and related at all
15:51:04 <pjdelport> Those headers are more relevant for larger and more static resources
15:52:12 <binroot> tremon: a HEAD request in haskell?
15:52:39 <freeman42> I saw they restarted work on this project recently: https://code.google.com/p/ideah/ and that they have some Haskell code in it (inception). But they are not replying to the issues :(
15:52:51 <pjdelport> binroot: HEAD is probably not relevant in this case
15:52:59 <jle`> > (+3) >>= (*) $ 5
15:53:00 <lambdabot>  40
15:53:13 <jle`> :|
15:53:15 <pjdelport> binroot: You'll want GET, and you'll probably want to pass in the after parameter
15:53:18 <tremon> binroot: haven't done http programming in haskell, but as others have said, if the server can do the processing you don't need it
15:53:29 <pjdelport> that should make it good, even with a 5-second interval
15:53:49 <d1323> jle` how does that work?
15:53:54 <pjdelport> binroot: Their limit for requests in total is one every 2 seconds on average, though; just keep that in mind
15:54:05 <jle`> d1323: monad instace for (->) a
15:54:10 <pjdelport> That rate will have to include any other requests you make
15:54:20 <jle`> :t (>>=) `asAppliedTo` (+3)
15:54:21 <lambdabot> Num a => (a -> a) -> (a -> a -> b) -> a -> b
15:54:50 <binroot> pjdelport: thanks!
15:55:05 <jle`> ((->) a a) -> (a -> ((->) a b)) -> ((->) a b)
15:55:06 <d1323> (5+3) * 5?
15:55:10 <ion> > do { a <- (+3); (*) a } 5
15:55:11 <lambdabot>  <hint>:1:25: parse error on input ‘5’
15:55:19 <pjdelport> freeman42: Have you looked at https://github.com/fatuhoku/ideah ?
15:55:20 <ion> > (do { a <- (+3); (*) a }) 5
15:55:21 <lambdabot>  40
15:55:23 <pjdelport> It seems to have moved there.
15:55:41 <ion> > let a = (+3) 5; b = (*) a 5 in b
15:55:43 <lambdabot>  40
15:56:02 <jle`> hm
15:56:20 <jle`> > do { x <- (+3); y <- (*x); return y } $ 5
15:56:21 <lambdabot>  40
15:56:33 <d1323> i dont quite get why 5 is used twice.
15:56:48 <jle`> bind x to the result of adding three to your input; bind y to the result of multiplying x to your input, then return y overall
15:56:55 <jle`> the input is the same the entire time
15:57:00 <jle`> it's like Reader
15:57:12 <ion> d1323: That’s how the (->) r monad works. The parameter (“environment” if you will) is applied to all those expressions.
15:57:19 <Rarrikins> @undo do { x <- (+3); y <- (*x); return y }
15:57:19 <lambdabot> (+ 3) >>= \ x -> (* x) >>= \ y -> return y
15:57:28 <d1323> I see
15:57:37 <jle`> so x would be (5+3), y woudl be (5*x)
15:57:40 <jle`> return is const
15:59:22 <jle`> > do { x <- (+3); y <- (*4); z <- ( (/3) . (+1) ); return z } $ 99 -- at every step, every function is being applied to the 99
15:59:23 <lambdabot>  33.333333333333336
15:59:46 <jle`> you just get to name the results to use later
15:59:50 <jle`> that was a bad example :|
15:59:59 <freeman42> pjdelport, yeah, I looked at it and posted this issue: https://code.google.com/p/ideah/issues/detail?id=36
16:00:08 <jle`> > do { x <- (+3); y <- (*4); z <- ( (/3) . (+1) ); return (x+y+z) } $ 20
16:00:10 <lambdabot>  110.0
16:00:30 <ion> (x,y,z) perhaps
16:00:50 <jle`> > do { x <- (+3); y <- (*4); z <- ( (/3) . (+1) ); return (x,y,z) } $ 20
16:00:52 <lambdabot>  (23.0,80.0,7.0)
16:01:18 <jle`> idk it's kind of silly i was just playing around :|
16:01:34 <jle`> i don't think people use the monad instance for (->) a too much...though many use the applicative instance
16:01:38 <jle`> i think i use join sometimes
16:01:43 <jle`> but i still feel bad when i do
16:01:52 <jle`> > join zip [1..10]
16:01:55 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
16:04:34 <Algebr> Has anyone played with Elm?
16:05:00 <haasn> > sequence [(+a),(*b),(/c)] z
16:05:02 <lambdabot>  [z + a,z * b,z / c]
16:05:25 <akurilin> Quick question: how do you guys deal with having a compilation error in a file when reloading it from ghci? It's a bit of a pain to lose access to all the imports when that happens, so I'm wondering if everybody just bypasses that
16:05:30 <ion> > [(+a),(*b),(/c)] <*> pure z
16:05:32 <lambdabot>  [z + a,z * b,z / c]
16:06:24 <haasn> > [(+a),(*b),(/c)] ?? z
16:06:25 <lambdabot>  [z + a,z * b,z / c]
16:06:40 <heatsink> @src (??)
16:06:41 <lambdabot> Source not found. Sorry.
16:06:51 <haasn> (??) = flip from Control.Lens
16:07:01 <Algebr> akurilin: I end up having two ghcis.
16:07:05 <heatsink> hmm
16:07:07 <d1323>  > [(+a),(*b),(/c)] <$> ($z)
16:07:26 <d1323> > [(+a),(*b),(/c)] <$> ($z)
16:07:28 <lambdabot>  Couldn't match expected type ‘a -> b’
16:07:28 <lambdabot>              with actual type ‘[Debug.SimpleReflect.Expr.Expr
16:07:28 <lambdabot>                                 -> Debug.SimpleReflect.Expr.Expr]’
16:07:57 <d1323> > ($z) <$> [(+a),(*b),(/c)]
16:07:58 <lambdabot>  [z + a,z * b,z / c]
16:08:04 <haasn> > [(+a),(*b),(/c)] <&> ($z)
16:08:05 <lambdabot>  [z + a,z * b,z / c]
16:08:47 <Philonous> akurilin, 1) comment out the offending code, reload, comment back in or 2) I have an (emacs) function that sends region to GHCI. Sometimes I use that.
16:09:39 <d1323> you could write elisp code that sends just the imports on error
16:09:43 <akurilin> hmm ok
16:11:04 <d1323> ghci offers no way around this, though, if that is what you're asking
16:16:44 <akurilin> d1323: that's fair. Basically comment out and stub or have a separate instance of ghci altogether
16:18:45 <Tordek> So I'm doing this http://programmingpraxis.com/2014/04/15/assembler-part-1/ as an exercise
16:20:16 <Tordek> and here's what I have initially: I created 'data Opcode = Const Word | Get | Put | Add Label' 'type Word = Int' 'type Label = String'
16:20:55 <Tordek> so I parse with a Parsec parser and generate, [(Maybe Label), Opcode]
16:21:46 <Tordek> however... that means now if I want to execute that code (as in part 2), I need a new, differentt type where Add takes an Address instead
16:22:56 <Tordek> is this correct, or is there some way to, in one step, return "Add Word"... or... something?
16:23:02 <heatsink> It looks like instructions and data are stored in the same memory space
16:23:10 <Tordek> heatsink: yeah
16:23:46 <heatsink> You should do another pass after parsing to translate Label to Address
16:23:51 <heatsink> where Address is a synonym for Int
16:23:59 <Tordek> heatsink: that's as I do now
16:24:50 <heatsink> Because you can use a label to refer to a later part of the program, the two-pass approach is better
16:24:54 <Tordek> actually, maybe I should rephrase my issue as to "what'd be the best way to do this", because there's 3 parts to this:
16:25:57 <Tordek> I have an Opcode type with constructors for each opcode, which may have a (string) label, so I also parse alongside a (Maybe Label) and store it in a map and resolve the addresses
16:26:02 <Tordek> in a second step
16:27:24 <Tordek> but then, if I want to run it, I'd need a second type, where "Add" has an address instead of a label (beacause I'd be getting rid of them, if I parsed the 'assembled' program)
16:27:54 <heatsink> You can parameterize Opcode over the label type.
16:29:18 <Tordek> does it make sense to define "type RawOpcodes = Opcodes Label" and "type AddressedOpcodes = Opcode Word"?
16:29:28 <heatsink> yes
16:29:46 <Tordek> alright
16:30:12 <Tordek> cool, I'll be back later with more questions, thanks :)
16:49:27 <migimunz> Are GADTs a general (though non-standard) feature of Haskell or are they just ghc-specific?
16:50:14 <haasn> GADTs are pretty widely understood and not very implementation-specific, but I don't know if anything other than GHC actually implements them
16:51:40 <d1323> does it matter? :)
16:52:00 <vanila> I think UHC implements GADT
16:52:09 <vanila> GHC introduced them originally, didn't it?
16:55:19 <Cale> vanila: yes
16:57:07 <Cale> To some extent, they were stolen from languages such as Coq (which being a dependently typed language, allows for even more generality still)
16:57:42 <manuel_> haskell is messing with my head
16:57:50 <Platz> so if i understand correctly machines (streams, autos/coroutine) is how FRP is implemented, and then signals and behaviors are an abstraction on top of that.  are there other implementation primitives besides machines that one should know about on this topic?
16:58:25 <Platz> i.e. the Cont monad
16:58:44 <conal> Platz: http://conal.net/papers/plilpalp98/
16:58:46 <Platz> browsing around it seems a lot of these things have different names
16:58:51 <Platz> but mean the same thing
16:59:29 <Platz> conal: thanks, this should help
17:00:50 <conal> Platz: you bet. also: http://conal.net/papers/padl99/ . and beware that many so-called "FRP" systems miss the fundamentals, namely continuous time and a precise denotation/semantics/specification. see http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language/5878525#5878525 and follow links.
17:01:33 <conal> Platz: sadly, the term "frp" has drifted far from the original principles.
17:03:12 <migimunz> cale, haasn, vanila, d1323, thanks :)
17:03:13 <Platz> conal: ah, thats unfortunate.. probably explains why it's hard to build up a coherent glossary in my head ;)
17:04:46 <conal> Platz: absolutely. it probably helps to keep in mind that people mean very different things by the term. almost every system called "FRP" these days abandons the fundamental principles.
17:09:38 <Tordek> so, one issue I ran into is that my "runProgram" is [Word] -> MemoryPosition {-program counter-} -> Word {- Accumulator -} and, as is wont to happen, I put the last parameters backwards at one point
17:10:10 <Tordek> can I make them uncompatibe (?) somehow, so that I can't just put MemoryAddresses in Words except by explicit casting?
17:10:21 <heatsink> that's what newtypes are for
17:10:22 <srhb> By using newtype or data
17:10:29 <srhb> But yes, newtype.
17:10:52 <heatsink> Also, since you're simulating an interpreter, you should probably use a mutable array
17:10:56 <heatsink> instead of a list
17:12:19 <heatsink> For this application, you want to allow fast read and write of any word in memory.  Lists don't do that.
17:15:01 <Gurkenglas> @pl (,3)
17:15:01 <lambdabot> (line 1, column 3):
17:15:01 <lambdabot> unexpected ','
17:15:01 <lambdabot> expecting expression
17:15:09 <Gurkenglas> @type (,3)
17:15:10 <lambdabot> Num t1 => t -> (t, t1)
17:15:25 <srhb> It doesn't get much more pointleess. :P
17:15:32 <srhb> > (,3) 2
17:15:33 <lambdabot>  (2,3)
17:15:34 <ricree> Is there a single typeclass that will let a type variable be used in an ffi call. Including pointers and valid newtypes?
17:15:45 <Gurkenglas> Well yup but it shouldnt throw an error
17:16:12 <heatsink> No, ricree.  FFI calls need the type to be fixed statically so the compiler can generate the right code.
17:16:26 <ricree> thanks heatsink
17:16:41 <enthropy> @hackage libffi
17:16:41 <lambdabot> http://hackage.haskell.org/package/libffi
17:16:55 <heatsink> There is no polymorphic "call with any valid foreign type" operation.
17:17:33 <enthropy> that one still needs monomorphic types
17:19:05 <manuel_> which book would you peepz recommend for diving in, i’m plowing through beginning haskell but the exercises and examples are a bit tedious
17:19:43 <srhb> manuel_: LYAH :-)
17:20:06 <ricree> manuel_: Have you seen "Write Yourself a Scheme"? I found it pretty helpful when I was first starting out.  http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/
17:20:15 <Gurkenglas> manuel_, I did http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/ but I have a bit of pre-understanding of mathy and programmy things
17:20:20 <manuel_> ricree: actually i have, thanks for reminding me
17:20:26 <heatsink> enthropy: Where is ffi_prep_cif defined?  It's not in the package source
17:20:38 <Gurkenglas> (Just started a few days ago)
17:21:00 <manuel_> yeah i did haskell the hard way but it doesn’t really go in deep
17:21:08 <manuel_> write yourself a haskell it is
17:21:10 <manuel_> herm
17:21:11 <enthropy> heatsink: dunno. Where does it show up?
17:21:11 <manuel_> a scheme
17:21:32 <enthropy> if you're installing libffi, I've had no such issue
17:21:51 <heatsink> enthropy: It's an imported C function, called by callFFI
17:23:02 <monochrom> ffi_prep_cif may be from libffi (the C one, not the Haskell one). you can google it and find man pages.
17:27:34 <heatsink> Ah, libffi uses lots of assembly code to get the job done
17:29:52 <johnw`> heatsink: at some point, don't you have to?
17:30:05 <johnw`> heatsink: I'm not aware of many languages that let you load values into specific registers
17:32:15 <jle`> huh i didn't realize that (<$) was a part of the Functor typeclass
17:32:20 <jle`> i guess for efficiency
17:32:24 <heatsink> Some EDSLs execute a static compiler and dynamically load the object code
17:32:32 <Tordek> [21:10] <heatsink> For this application, you want to allow fast read and write of any word in memory.  Lists
17:32:46 <Tordek> sure, I'm just playin' with the syntax more than the implementation
17:32:49 <heatsink> I wanted to see if that was happening
17:34:26 <spockshock> jle`: what is (<$) ?
17:35:01 <Tordek> if that operator isn't pronounced "cheaper" I'll be a bit sad
17:35:44 <jle`> spockshock: x <$ m === const x <$> m
17:35:51 <jle`> > 6 <$ Nothing
17:35:52 <lambdabot>  Nothing
17:35:57 <jle`> > 7 <$ Just 5
17:35:59 <lambdabot>  Just 7
17:36:13 <jle`> it replaces the value, sorta
17:37:12 <spockshock> interesting, thats why I come here...learn something new
17:37:40 <jle`> it's useful for those guardy/monadplussy stuff
17:37:44 <spockshock> so it keeps the "wrapper" but replaces the value
17:37:54 <jle`> yeah
17:37:59 <spockshock> thx
17:38:34 <jle`> > let keepEven x = x <$ guard (isEven x) in (keepEven 5, keepEven 6)
17:38:36 <lambdabot>  Not in scope: ‘isEven’
17:38:42 <jle`> > let keepEven x = x <$ guard (even x) in (keepEven 5, keepEven 6)
17:38:43 <lambdabot>  No instance for (GHC.Show.Show (f1 a1))
17:38:43 <lambdabot>    arising from a use of ‘M324925759672993312410828.show_M3249257596729933124...
17:38:43 <lambdabot>  The type variables ‘f1’, ‘a1’ are ambiguous
17:38:43 <lambdabot>  Note: there are several potential instances:
17:38:43 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:38:53 <jle`> darnit
17:38:59 <jle`> oh
17:39:27 <jle`> > let keepEven x = x <$ guard (even x) in (keepEven 5, keepEven 6) :: (Maybe Int, Maybe Int)
17:39:28 <lambdabot>  (Nothing,Just 6)
17:39:48 <spockshock> dam that is ambigous all right
17:40:06 <spockshock> ah, ok
17:40:23 <jle`> guard is Nothing if it's false and Just () if it's true
17:40:28 <jle`> for Maybe, at least
17:41:28 <benbangert> so uh, is it a known bug that 'cabal test' will never complete if you fill the stdout buffer during the test run?
17:41:28 <spockshock> explicit declaration to the rescue
17:42:45 <johnw`> you could also use: mfilter even (Just x)
17:43:03 <johnw`> then you don't need to bind a name to x to avoid repeating it
17:44:20 <johnw`> can anyone suggest a good type name for newtype Foo a = Foo (forall r. Monoid r => (a -> r) -> r)
17:44:37 <johnw`> I was thinking of just calling it List and putting it into Data.Monoid.List
17:45:11 <johnw`> I'm building a Data.List equivalent for this type here: https://github.com/jwiegley/concat/blob/master/Concat.hs
17:45:15 <johnw`> (Concat was my working name)
17:45:43 <johnw`> It has the benefit of O(1) concat just like difference lists, but allows you to manipulate such values without always requiring toList, the way that difference lists do
17:48:31 <acowley> So is that 30% speed hit with 7.8 on OS X really a thing?
17:48:45 <johnw`> acowley: what speed hit is that?
17:48:58 <johnw`> I was performance testing a library this week, and when i moved to 7.8 it didn't affect anything
17:49:06 <acowley> That's good to hear!
17:49:10 <acowley> It's an issue with threading
17:49:14 <acowley> were you using the threaded RTS?
17:49:21 <johnw`> yes
17:49:25 <johnw`> but I wasn't using threads
17:49:35 <acowley> And you were testing on OS X?
17:49:41 <johnw`> yes
17:50:15 <acowley> Check section 1.5.4 at http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/release-7-8-1.html
17:50:59 <johnw`> hmm
17:51:05 <johnw`> let me see how my GHC was built
17:51:09 <acowley> Also, and I'm pretty sure I've asked this before, can the type checker pick up on the fact that a closed type family is injective?
17:51:20 <acowley> I really, really want injective type families :/
17:51:32 <copumpkin> not that I know of (yet)
17:51:37 <acowley> argh
17:51:46 <acowley> It's so hard to make nice things type check without that
17:51:47 <copumpkin> not sure how statically determinable that is
17:52:06 <copumpkin> simple cases obviously would be but I don't know in general
17:52:17 <acowley> I am drowning in simple cases
17:52:46 <acowley> Well, I'm actually drowning in newtype wrappers because of the need to use a data family
17:53:09 <johnw`> acowley: looks like Nix builds GHC 7.8.2 with gcc on OS X
17:53:53 <acowley> johnw`: Darn it. So the binary release on the website will probably make me regret upgrading
17:54:19 <johnw`> quite possibly
17:54:32 <danharaj> acowley: I'm having problems installing 7.8.2 on Mountain Lion, incidentally.
17:54:33 <johnw`> 30% is pretty bad
17:54:35 <danharaj> Without Nix.
17:55:32 <acowley> johnw`: I can't even joke about it it's so bad :(
17:55:38 <acowley> danharaj: Why are you on ML?
17:55:44 <johnw`> I'm sorry acowley :(
17:58:15 <acowley> I think it would be better if they offered a version for OS X that required GCC
17:58:58 <acowley> Unless it's a really tight GCC version requirement
18:01:10 <acowley> I wonder if I could use the roles machinery to sprinkle coerces everywhere to mitigate the newtype flood.
18:01:47 <acowley> Also, ghc-mod keeps dying on me and I don't know how to revive it without killing emacs
18:02:47 <copumpkin> wasn't there a pure Haskell CPP floating aroun dsomewhere?
18:02:56 <copumpkin> and edwardk wrote one too at some point
18:03:08 <acowley> Yes, and it's pretty great
18:03:13 <acowley> even if I forget its name at the moment
18:03:23 <acowley> I use it quite often
18:03:24 <danharaj> acowley: I haven't touched this computer in months and when I did, Mavericks was hell for GHC 7.6
18:03:31 <danharaj> so I opted not to upgrade. Is it safe now?
18:03:42 <acowley> danharaj: I jumped on Mavericks pretty quickly
18:04:01 <acowley> danharaj: So I guess I fought through the pain
18:04:16 <acowley> danharaj: It's really not an issue. You just change a settings file to point to gcc
18:04:23 <enthropy> @hackage cpphs
18:04:23 <lambdabot> http://hackage.haskell.org/package/cpphs
18:04:28 <danharaj> ah, cheers... I guess. Why does software have to suck so much.
18:04:34 <acowley> Oh yes, thank you enthropy
18:04:38 <monochrom> because it is written by humans
18:04:53 <acowley> It handles string munging quite well
18:09:30 <manuel_>  anybody doing exercism.io here?
18:10:45 <Platz> manuel_: I did about 25-30 items on exercism.io
18:11:25 <Platz> pretty good way to practice imho
18:11:40 <Platz> at least for building up that 'muscle memory'
18:12:42 <Platz> because a lot of the problems are simply data transformations that can be solved similar approaches once you get a few of them down
18:13:36 <Platz> I think the nicta course might be better for teaching haskell-specific concepts, but I think they both have their place
18:13:47 <Tordek> https://gist.github.com/Tordek/52a2708a7046ec577897 other than "it's disorganized" (mostly because I'm lazy and didn't feel like splitting it into separate files), how can this be improved? I'm using this exercise to lrn2haskell http://programmingpraxis.com/2014/04/15/assembler-part-1/
18:15:32 <Tordek> I feel like addressOpcode can be improved with some haskell magic I'm unfamiliar with
18:19:50 <johnw`> that haskell magic would be "never use fromJust"
18:20:15 <johnw`> also, m M.! k is the same as fromJust (M.lookup k m)
18:22:52 <Platz> is something like  guard (isJust newDigit); let x = fromJust newDigit  ok?
18:25:16 <Tordek> johnw: I should have hoogled that one, that's nice
19:27:27 <akurilin> Quick question: when working with data.text, what's the easiest option for uppercasing the first character? I'm aware of toTitle, but unfortunately it doesn't treat the apostrophe right.
19:28:39 <akurilin> I can unpack, toUpper the first char, and repack, but I'm trying to avoid that
19:36:36 <roconnor> use a prism?
19:37:05 <meiji11> I find it strange that there's no way to represent a Double literal in Template Haskell. why is that?
19:43:42 <geekosaur> because you can't actually enter a Double literal? (what appears to be a Double literal in normal Haskell is fromRational applied to a Rational constructed from the value you entered, for example 0.25 is (25%100). an actual Double literal would need to be in base 2, normalized, with a mantissa and separate sign bit, etc.)
19:45:03 <meiji11> ok then, makes sense. thanks.
19:47:41 <michaelt> akurilin: use T.scanl with your variant of okay ' ' b = toUpper b ; okay _ b = b
19:51:40 <michaelt> > let okay ' ' b = toUpper b ; okay _ b = b in tail $ scanl  okay ' ' "hello world" -- T.scanl will preserve the underlying fusion business, I think, akurilin
19:51:42 <lambdabot>  "Hello World"
19:54:00 <akurilin> underying fusion business?
19:56:07 <albeit> Is there a way to apply a method that takes n parameters to a list of length n?
19:56:39 <shachaf> You can write (\[a,b,c,d,e] -> f a b c d e)
19:56:48 <shachaf> It'll fail on shorter or longer lists, of course.
19:57:20 <albeit> So I would need to write such a function for every length I could encounter? No cleaner way?
19:57:36 <albeit> In the context of data constructors
20:00:39 <michaelt> akurilin: It's not important. Some ways you might write it might interfere with the rewriting that goes on in `text`, though I don't know that it's that important really. `T.scanl` uses those optimizations so it's okay.
20:01:47 <akurilin> ok cool good to know
20:01:49 <akurilin> thx
20:03:10 <BMeph> albeit: If you thought about it for a bit - or if you "cheat" by letting a pompous windbag like me chat at you - you'd realize that you don't really want that type of function, exactly...with extra emphasis on "type" ;þ
20:04:15 <albeit> As in, it would be bad style/incorrect, because it wouldn't be able to infer the type/types in the list?
20:05:11 <benmachine> albeit: when would you use such a function?
20:05:52 <triliyn> albeit: the function you want cannot be well-typed (except with typeclass hackery), and even with typeclasses it will only work on functions whose arguments can all be in a list together
20:05:59 <triliyn> (Which means they all have to be the same type)
20:07:16 <triliyn> If you control the source from which you're getting the lists, it's probably a better idea to just call your data constructor then
20:07:26 <albeit> Well, using aeson, trying to reduce something like "MsgMarketData   <$> o .: "type" <*> o .: "time"" to "myFunc MsgMarketData o ["type", "time"]"
20:07:50 <albeit> Just to reduce repeated time of "<*> o .:"
20:07:54 <albeit> *typing, not time
20:08:28 <triliyn> hmm
20:08:35 <albeit> Don't know how to get the list of values for the data constructor, but was jumping ahead a bit ;)
20:09:04 <smiller2> "OpenGLRaw is a raw Haskell binding for the OpenGL 3.2" (http://hackage.haskell.org/package/OpenGLRaw).  Are there any similarly low-level bindings for more recent versions of OpenGL, e.g. 4.4?
20:09:08 <benmachine> albeit: there may be other ways to solve that specific problem
20:09:45 <albeit> (I can't use generics, because the json keys don't align with the data type record field names)
20:10:04 <albeit> But I'm open to other ways to solve it!
20:10:09 <benmachine> so I'm thinking mapM (o .:) ["type", "time"]
20:10:25 <benmachine> and then do-binding the resulting list
20:10:37 <benmachine> which is fragile but would work
20:11:00 <benmachine> there's also a possibility you could define an operator to do your dirty work
20:11:01 <benmachine> something like
20:11:12 <benmachine> let f <.> x = f <*> o .: x
20:11:24 <benmachine> then pure MsgMarketData <.> "type" <.> "time"
20:11:55 <benmachine> that's probably the best way, actuall
20:11:55 <benmachine> y
20:13:01 <albeit> I like that! Thanks!
20:23:41 <meloveulongtime|> I just want to say that Miran has a great book, but his Bass Tabs web site is well...busy looking
20:38:50 <stolaruk> Can someone provide an elegant way to may a QuickCheck generator that generates strings whose length are of a given range?
20:38:56 <stolaruk> s/may/make
20:40:31 <enthropy> stolaruk: do n <- choose (nMin, nMax); replicateM n arbitrary
20:40:55 <enthropy> dunno about "elegant"
20:41:02 <stolaruk> enthropy: looks good to me
20:41:08 <stolaruk> >t nMin
20:41:14 <stolaruk> @t nMin
20:41:14 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
20:41:21 <stolaruk> :t nMin
20:41:22 <lambdabot> Not in scope: ‘nMin’
20:41:30 <stolaruk> oh gosh
20:41:31 <stolaruk> duh
20:41:40 <stolaruk> I see
20:46:08 <zcd> has anyone had success with icons in xmobar
20:46:23 <shachaf> Maybe ask in #xmonad.
20:47:41 <zcd> fair enough
20:53:31 <albeit> @t nMin
20:53:31 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
20:53:38 <albeit> ... what in the world...
20:54:19 <albeit> Oh nvm, the command not nMin ;)
21:15:41 <carter> johnw: your "goodby lisp hello haskell " post from eons ago is on the front page of hn
21:15:54 <johnw> huh
21:15:59 <bitemyapp> how do I include haddock documentation in a package I want to upload to Hackage?
21:16:17 <bitemyapp> or am I still waiting for it to get build?
21:16:19 <bitemyapp> get built*
21:17:29 <carter> bitemyapp: you dont include it
21:17:30 <carter> it builds
21:17:50 <carter> if it doesn' build, ie when theres a build error, you can curl upload your own with some tricks
21:17:52 <carter> but wait and see
21:17:53 <bitemyapp> carter: oh, Hackage creates Haddock documentation automagically? I didn't know that.
21:17:56 <carter> yup
21:18:02 <bitemyapp> gooooood to knowwwwww
21:18:04 <carter> *you can* upload your own iwth hackage
21:18:11 <carter> but if you can evade that, yay
21:18:31 <bitemyapp> carter: 5-10 minutes you said?
21:18:35 <carter> yes
21:18:38 <carter> its been 10 seconds
21:18:46 <bitemyapp> sounds like a good excuse to play some Dota.
21:18:49 <carter> yes
21:18:52 <carter> you need a break
21:18:54 <carter> gtfo
21:18:54 <carter> :)
21:18:56 <bitemyapp> lol @ all the irccloud users getting harvested and dying
21:19:01 <carter> ?
21:19:03 <carter> what happened/
21:19:11 <bitemyapp> carter: like half the irccloud client users in this channel just timed out.
21:19:24 <bitemyapp> half the timeouts on freenode seem to be people using that IRC service.
21:19:26 <carter> i have joins / parts hidden on my irc client
21:19:31 <carter> timeout how?
21:19:36 <carter> like, no keeepalive?
21:19:39 <carter> or/
21:19:40 <bitemyapp> has quit [Ping timeout: 252 seconds]
21:19:48 <carter> oh
21:19:56 <carter> so another point in favor of me using my own znc
21:20:09 <bitemyapp> carter: pretty much.
21:20:18 <bitemyapp> carter: tenancy on SAAS services like that is often appalling.
21:20:45 <carter> you mean under provisioned?
21:20:50 <bitemyapp> yep
21:21:15 <carter> for the margins!
21:21:18 <carter> ok
21:21:18 <carter> break
21:30:29 <bjorkintosh> cabal installing glib is failing.
21:30:32 <bjorkintosh> am i doing something wrong?
21:32:25 <bjorkintosh> what, cat got your collective tongues?
21:33:38 <carter> bjorkintosh: what OS
21:33:42 <carter> you need to tell us more info
21:33:47 <carter> like did you install normal glib
21:33:51 <carter> "brew install glib"
21:34:13 <bjorkintosh> ubuntu 14.04
21:34:17 <bjorkintosh> glib's already installed.
21:34:25 <carter> idk
21:34:28 <carter> whats the error message you get
21:34:37 <shelf> are you trying to build gtk2hs
21:34:44 <carter> shelf: you can take voer
21:34:46 <bjorkintosh> shelf, yes.
21:35:24 <bjorkintosh> it's failing at the configuration step. something about needing gtk2hsC2hs version 0.8 while 0.6 is installed.
21:36:01 <shelf> oh, i am the wrong person to help with cabal hell. i either make a sandbox or nuke and start over.
21:36:18 <bjorkintosh> gah!
21:36:20 <albeit> bitemyapp: I was just reading an article bitemyapp.com and just saw your username here... thanks for the article! ;)
21:36:55 <carter> bjorkintosh: paste ALL your error info to  a paste on http://lpaste.net/new/haskell
21:39:03 <bjorkintosh> http://lpaste.net/103537
21:40:01 <bitemyapp> albeit: glad you liked it!
21:41:41 <carter> bjorkintosh: cabal install c2hs plus gtk2hs ?
21:41:50 <carter> "cabal install c2hs gtk2hs"
21:41:52 <carter> and try again
21:41:54 <carter> well
21:41:56 <carter> first cabal update
21:42:01 <michaelt> bjorkintosh: you can cabal update / cabal install gtk2hs-buildtools to get the more recent one. But you would need to get rid of the ones from Ubuntuland
21:42:12 <carter> yes, listen to michaelt
21:42:13 <carter> i'm tired
21:42:41 <shelf> yes, my c2hs comes from the buildtools
21:43:16 <bjorkintosh> michaelt, alright.
21:43:45 <carter> (i don't know who michaelt  is, but i'm on  mac, so i'm not the right person for buntu help)
21:44:06 <bjorkintosh> that's fine, carter. thanks.
21:44:13 <bjorkintosh> i'm trying his approach right now.
21:44:40 <michaelt> I think its all executables so you could put HOME/.cabal/bin ahead of /usr/bin or whatever to over-rule the ones from ubuntu
21:44:52 * hackagebot pipes-http 1.0.1 - HTTP client with pipes interface  http://hackage.haskell.org/package/pipes-http-1.0.1 (GabrielGonzalez)
21:44:55 <lispy> which is your friend :)
21:44:58 <bjorkintosh> michaelt, i just edited .profile as well.
21:45:18 <lispy> and it doesn't hurt to 'hash -r' after installing things
21:45:59 <lispy> shells are so warty and arcane
21:46:15 <lispy> I loves me some zsh, but yeah.
21:47:26 <lispy> mzero was working on a better shell, implemented in haskell
21:47:42 <carter> lispy: have you tried fish?
21:47:51 <albeit> bitemyapp: If you're still there, what did you use for pretty printing at the end of this? http://bitemyapp.com/posts/2014-04-17-parsing-nondeterministic-data-with-aeson-and-sum-types.html
21:48:32 <bitemyapp> albeit: uh, Haskell mode thingy
21:48:37 <bitemyapp> ``` haskell
21:48:44 <bitemyapp> markdown pandoc Hakyll
21:49:53 * hackagebot bloodhound 0.1.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.1.0.0 (bitemyapp)
21:53:16 <albeit> bitemyapp: Sorry I wasn't clear (or I'm not understanding)... what did you use to get it to print out the results of main indented properly? Was it done after the fact?
21:53:45 <lispy> carter: what is fish?
21:54:16 <GeraldDev> hello.  can someone tell me an easy way to determine all subclasses and instances of a given typeclass?
21:54:27 <bitemyapp> albeit: I don't really remember. I'm going to guess I did it manually but there are pretty printers and stuff
21:54:45 <albeit> Ah okay, gotcha
21:54:56 <lispy> GeraldDev: in ghci you can check which instances of a type class are currently in scope.
21:55:09 <lispy> GeraldDev: :info Read
21:55:10 <GeraldDev> oh ok, yes I am using ghc
21:55:13 <GeraldDev> thanks!
21:55:49 <lispy> GeraldDev: haddocks also mention instances. so you can try search on hoogle
21:55:57 <lispy> GeraldDev: in general, there is no way to know the full set.
21:56:09 <lispy> (precisely because type classes are open)
21:56:40 <GeraldDev> ok yeah that makes sense
21:56:45 <shelf> fish is a nice shell http://fishshell.com
21:57:20 <bjorkintosh> acme's a nice shell too :)
21:57:40 <shelf> fish breaks shell scripts though, iirc.
21:58:41 <lispy> GeraldDev: another really useful ghci command is :browse
21:58:54 <GeraldDev> oh, thank you
21:58:59 <GeraldDev> this is very helpful
21:59:51 <bjorkintosh> alright. putting .cabal/bin/ ahead of /usr/bin in my .profile seems to have helped.
22:00:38 <no-n> Most people don't include a type declaration for main.
22:00:51 <bjorkintosh> what should main's type declaration be?
22:01:09 <no-n>  
22:02:21 <lispy> bjorkintosh: main :: IO ()
22:02:28 <no-n> sometimes I see :: IO ()
22:02:34 <bjorkintosh> interesting.
22:02:35 <lispy> bjorkintosh: it could be IO a, but for whatever reason we use IO ()
22:02:40 <pyon> When using Parsec, I would like to have different types of user state at different points during the parsing process. Is there any function of type "ParsecT s u m a -> ParsecT s a m a"?
22:02:42 <no-n> yea
22:02:49 <bjorkintosh> is it required that it be called main?
22:02:52 <bjorkintosh> it seems archaic.
22:02:55 <lispy> yes
22:03:08 <lispy> ghc has a way to rename it, but IIRC it doesn't integrate well with cabal
22:03:33 <bjorkintosh> cabal should uninstall itself :)
22:03:54 <lispy> bjorkintosh: purely functional. We can't remove values ;)
22:03:56 <bjorkintosh> improving the genepool by its absence, so to speak.
22:04:49 <pyon> lispy: But there should be some way to make them go out of scope, and let the garbage collector do its thing. :-P
22:05:26 <lispy> For all its warts, cabal + hackage has enabled the community to become a lot more productive.
22:05:44 <lispy> before cabal and hackage everyone had to reinvent the wheel with build scripts and libraries.
22:06:09 <bjorkintosh> there's gotta be a better way.
22:06:23 <lispy> bjorkintosh: what has been problematic?
22:06:40 <pyon> Anyway - is there no way to have different user state types during different parts of the parsing process in Parsec?
22:06:42 <lispy> I've used the tool so long I don't remember what the rough edeges are.
22:07:02 <bjorkintosh> haha. maybe i should get to that point.
22:07:03 <pyon> (Short of bolting on my own StateT on top of ParsecT, that is.)
22:07:10 <bjorkintosh> i'll wait till then to answer your question, lispy.
22:07:33 <GeraldDev> hi lispy, do you ever get to a point to where haskell seems as natural as the procedural stuff most of us grew up on =)
22:07:53 <lispy> bjorkintosh: well, if you find parts that seem counter intuitive, suboptimal, or just plain broken, doesn't hesitate to bring them up.
22:08:05 <lispy> GeraldDev: definitely.
22:08:38 <lispy> GeraldDev: it takes practice and experience. At this point, I sketch out code in Haskell (or pseudo-Haskell) before implementing in other languages.
22:08:39 <GeraldDev> I got this passion for it.  I want to eventually do this.  I like the idea of it being easier to know your programs actually work
22:08:47 <GeraldDev> I see
22:08:51 <GeraldDev> cool
22:09:24 <lispy> GeraldDev: if you're new to Haskell, here is an exercise that was given to me: Read the prelude and practice implementing parts of it.
22:09:43 <bjorkintosh> interesting.
22:09:51 <lispy> It's a good way to learn what's in the prelude and also to learn basic FP
22:09:58 <GeraldDev> good idea..I will do that
22:10:17 <GeraldDev> :)
22:10:31 <bjorkintosh> i found it quite useful to read hudak's account of the development of haskell and FP.
22:10:55 <bjorkintosh> quite clear answers to the 'whythehell?!'s .
22:10:55 <GeraldDev> oh thank you bjorkintosh
22:11:07 <bjorkintosh> it's long, but a  quick read.
22:11:25 <lispy> bjorkintosh: this one? http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
22:11:29 <bjorkintosh> yeah.
22:11:32 <bjorkintosh> exactly.
22:13:45 <bjorkintosh> actually, i meant this one: http://haskell.cs.yale.edu/wp-content/uploads/2011/01/cs.pdf
22:13:49 <bjorkintosh> i've read the other one as well.
22:14:22 <bjorkintosh> both are great.
22:15:49 <lispy> oh cool. I haven't seen this one before
22:17:07 <lispy> documents like this remind me that I should stop publishing my blog in html and post pdfs instead :)
22:17:38 <solrize> wow i'm looking at purescript, does the author hang around here?
22:17:39 <joelteon> so TH name quotations inside patterns is a parse error??
22:17:40 <joelteon> why?
22:17:42 <GeraldDev> lispy, may I have that link please
22:17:58 <solrize> lispy i think of doing a blog as pure rss, not bothering with any web design whatsoever
22:18:28 <solrize> cause there's lots of good blogs with crappy web design and i find myself just bookmarking the rss feed and reading that directly
22:19:52 <lispy> GeraldDev: this is my blog, if that's what you meant: http://blog.codersbase.com/
22:19:56 <lispy> GeraldDev: I don't post very frequently
22:20:09 <lispy> solrize: heh
22:20:10 <GeraldDev> yes, that's what I meant..sorry I was not clear.
22:20:48 <GeraldDev> lispy, can I ask something related but not technical
22:20:58 <lispy> sure
22:21:11 <GeraldDev> you see, I am thinking this..I have been a java, c, php (now) for the past 15 years as a pro...
22:21:24 <GeraldDev> I have a pretty good gig at the moment...but I am also thinking about backup plans
22:21:38 <GeraldDev> I am thinking that learning haskell is a good way to go...because so few people know it well
22:21:43 <GeraldDev> is there a job market for this?
22:21:43 <enthropy> joelteon: you can write    f ( ('x == ) -> True ) = ...  which is not so bad
22:21:56 <lispy> GeraldDev: yeah there really is.
22:21:57 <GeraldDev> Even if there is no job market, I will still learn it for its beauty...like  a martial art
22:22:06 <GeraldDev> cool
22:22:17 <shelf> GeraldDev: it will change the way you code in other languages
22:22:21 <bjorkintosh> GeraldDev, it's 'beauty' is as a result of its strong mathematical roots.
22:22:24 <lispy> GeraldDev: There is a website that lists a bunch of companies that use it. Let me see if I can find it.
22:22:42 <bjorkintosh> ... developed before computers materialized.
22:22:44 <shelf> (or it may lead you to despair when using other languages)
22:22:45 <lispy> GeraldDev: http://www.haskell.org/haskellwiki/Haskell_in_industry
22:22:57 <GeraldDev> yeah shelf
22:23:01 <GeraldDev> ah ok thanks
22:23:02 <solrize> this is a fancy  chunk of code... it's a standalone compiler not a ghc hack
22:23:23 <lispy> GeraldDev: this is the place I work at: http://corp.galois.com/about-us/
22:23:40 <lispy> we do some haskell but not every project uses it.
22:23:53 <solrize> you work there lispy?  cool.  nice job releasing cryptol
22:24:09 <GeraldDev> lispy nice! I have heard it is used in lots of seriously mission control stuff
22:24:11 <GeraldDev> like that
22:24:18 <GeraldDev> where you can't screw up
22:24:21 <lispy> solrize: thanks! I didn't actually help with that at all, but I'm still glad to hear good things about it
22:24:25 <GeraldDev> banking..missle software even!
22:24:51 <bjorkintosh> GeraldDev, for that, Ada's a pretty good option.
22:24:54 <bjorkintosh> but i digress.
22:24:59 <GeraldDev> ah
22:25:41 <bjorkintosh> lispy, what other languages/stacks besides haskell then?
22:25:50 <GeraldDev> so even though I am an ok progra,,er I suppose..after 15 years you get decent I guess...but I always feel nervous
22:25:52 <GeraldDev> no matter what
22:25:59 <GeraldDev> haskell seems like it could give more confidence
22:26:20 <shelf> I hear galois use a lot of node
22:26:32 <lispy> bjorkintosh: c/c++/ocaml/isabelle/cryptol (and probably a bunch of other stuff I'm not thinking of at the moment)
22:26:47 <bjorkintosh> isabelle? interesting.
22:28:21 <GeraldDev> ah node
22:28:38 <GeraldDev> speaking of node...this is totally off topic..I did my first MongoDB project
22:28:47 <shelf> GeraldDev: i was joking, sorry
22:28:47 <GeraldDev> I chose it because of the schemaless ature
22:29:19 <GeraldDev> I was able to define a some libs where I can define my structure in a CSV file..and all the php, html, js, validation, etc is handled automatically  for basic crud at least
22:29:37 <GeraldDev> ahhh
22:29:39 <GeraldDev> lmao
22:29:41 <GeraldDev> sorry
22:30:01 <shelf> my fault, i should clearly mark sarcasm in a chan like this
22:30:19 <shelf> much diversity in these parts
22:30:42 <GeraldDev> Well I did hear the haskell community is the so -called "nice" programming community
22:30:54 <GeraldDev> read that in some tutorial
22:31:00 <GeraldDev> learnyouahaskell maybe
22:32:21 <shelf> the community is remarkably snark-free! as big a drawcard as the language itself
22:32:38 <lispy> GeraldDev: actually, when I started learning Haskell I was strongly considering OCaml too (I wasn't sold on laziness). The difference in attitude between #haskell and #ocaml made the decision for me. People were so much more welcoming here.
22:32:58 <bjorkintosh> there are FAR more people here than in #ocaml
22:33:02 <bjorkintosh> so that makes a difference.
22:34:02 <GeraldDev> very cool lispy
22:34:06 <GeraldDev> I agree with that 100%
22:34:54 <GeraldDev> I wonder why this community is different
22:35:02 <GeraldDev> maybe because it weeds out impatient people
22:35:03 <GeraldDev> ?
22:35:06 <bjorkintosh> hahaha
22:35:20 <bjorkintosh> FP is most definitely not for the impatient.
22:35:25 <lispy> I can't speak for the other communities, but the senior folks we have are very patient and generous to beginners.
22:35:41 <lispy> I think they established good norms
22:35:48 <GeraldDev> ok
22:36:09 <lispy> And shapr set a good precedent for #haskell
22:36:16 <lispy> Even though he's not here much these days
22:37:11 <GeraldDev> thats good to know
22:37:17 <shelf> haskell just makes people happy
22:37:57 <bjorkintosh> if sml were completely pure and lazy...
22:38:00 <bjorkintosh> wishes. horses.
22:38:18 <GeraldDev> shelf, I like how it looks (shallow, I know) and I like not worrying if my test cases covered everything
22:38:41 <GeraldDev> I mean I have only a few weeks at it
22:38:49 <GeraldDev> a few weeks a few years ago, and two weeks recently.
22:38:58 <lispy> The mantra I was told when I started coming here is: Be kind to your beginners. Encourage them. Soon they will be your experts.
22:39:04 <nisstyre> bjorkintosh: have you tried http://wiki.clean.cs.ru.nl/Clean ?
22:39:24 <bjorkintosh> nisstyre, it quickens my heart.
22:39:44 <bjorkintosh> i have the plasmeijer book on parallel graph rewriting right here.
22:39:56 <nisstyre> cool
22:40:10 <GeraldDev> lispy, sounds like whoever set the tone here had a cool mindset
22:40:27 <bjorkintosh> nisstyre, have you used it much?
22:40:35 <shelf> sigh, I missed the deadline for OPLSS
22:40:39 <nisstyre> bjorkintosh: no, just simple programs that I translated from Haskell
22:40:47 <nisstyre> bjorkintosh: I could not find many libraries for doing things
22:40:54 <lispy> shelf: the extended deadline ends today
22:40:58 <bjorkintosh> ah.
22:41:12 <shelf> i know, i couldn't organise a recommendation in time.
22:41:16 <bjorkintosh> it's not as big, but it's definitely a neat language.
22:41:22 <nisstyre> bjorkintosh: but it has a top-notch compiler
22:41:23 <lispy> shelf: you should still send in what you have.
22:41:48 <shelf> oh, it's still friday in pacific huh.
22:41:51 <bjorkintosh> nisstyre, among other things.
22:41:51 <shelf> i will do that
22:41:54 <lispy> shelf: yup :)
22:42:09 <nisstyre> bjorkintosh: it would be useful as an embedded scripting language
22:42:22 <shelf> my prof is buried in ICFP, he will probably find my emails in a few days
22:42:51 <lispy> shelf: cool. So apply now and then forward the letter when it materializes.
22:43:05 <lispy> shelf: with some luck, I might see you there.
22:43:10 <shelf> :)
22:46:26 <bjorkintosh> shelf, he teaches FP?
22:46:49 <shelf> yeah, my school has a strong PLs department
22:47:24 <shelf> we learn a lot of Haskell and theorem provers / modelling tools
22:48:50 <lispy> shelf: nice! I really think that's the future of programming.
22:49:22 <shelf> me too. and if not, it's a great mental exertion
22:49:35 <lispy> It's a stepping stone on the path to generating programs from specifications (which I believe is going to be the next major milestone in CS)
22:51:59 <shelf> yeah. it makes far more sense when describing concurrent programs or parallelism, also
22:52:29 <bjorkintosh> lispy, then the problem simply moves to writing correct specifications.
22:52:34 <bjorkintosh> the problem does not go away.
22:52:46 <shelf> the other problems go away :)
22:52:53 <bjorkintosh> haha. where, exactly?
22:53:43 <lispy> bjorkintosh: letting the OS decide which blocks to put my data in still leaves me with other problems like deciding which data to put in which file/directory.
22:54:09 <lispy> bjorkintosh: but some how, the problem of which file/directory is more satisfying to solve than which block/sector.
22:54:21 <bjorkintosh> true, lispy.
22:54:39 <bjorkintosh> have you heard of the obj family of languages?
22:54:50 <bjorkintosh> obj3, maude, etc?
22:57:07 <lispy> oh yeah, I have a friend who used maude a lot in undergrad
22:58:19 <bjorkintosh> that's precisely the sort of thing those languages were created for.
22:58:25 <bjorkintosh> ... executable specifications.
23:05:17 <pyon> When a Parsec or Trifecta parser backtracks, is the user state (a StateT on top, in Trifecta's case) restored to what it used to be?
23:08:30 <SrPx> Hmm how do I make my own "show" function for my datatype? (yes that is a typeclass 101 question)
23:08:52 <bjorkintosh> SrPx, look it up?
23:09:00 <SrPx> I have in a few tutorials
23:09:08 <SrPx> for some time already
23:09:09 <bjorkintosh> and copying it didn't help?
23:09:19 <SrPx> copying... oh
23:09:27 <SrPx> I see what you mean, let me google it better
23:09:41 <lispy> SrPx: the easiest way is to add "deriving (Show)" to your data type
23:09:56 <SrPx> Yea but I wanted to add some indentation ti it (:
23:10:06 <lispy> SrPx: if you want to write it yourself you need to make an instance of Show.
23:10:13 <SrPx> bjorkintosh: I should improve my Google skills, thanks (:
23:10:16 <SrPx> lispy: uh huh
23:10:25 <bjorkintosh> hehe. we all should.
23:10:36 <lispy> data Foo = Foo; instance Show Foo where show Foo = "Foo"
23:11:00 <lispy> SrPx: if you want your hand written show to work with Read you'll have to follow some conventions. I don't recommend it.
23:11:30 <shelf> whelp, app sent. here's hoping
23:12:01 <shelf> a summer spent alone with ben pierce may not be so cheerful
23:12:20 <SrPx> lispy: so you suggest that I write an alternative function such as "toString" instead?
23:12:52 <bjorkintosh> oh. shelf have you had to read all his books?
23:13:17 <lispy> SrPx: I'm not sure what to suggest. What is it that are you trying to accomplish?
23:13:21 <shelf> naw, i am just going to get through the latter half of it over summer
23:13:47 <SrPx> lispy: I am just writing a function that transforms lisp expressions in their strings representation
23:14:09 <SrPx> lispy: with indentation
23:14:40 <SrPx> lispy: http://o7.no/RdWSAj see? ^^
23:14:49 <SrPx> I'll just call it unparse then
23:15:05 <lispy> SrPx: I'd probably make a type class just for doing that (and not use Show). If you're not familiar with making your own type classes, then just reuse Show for now but make a note to fix it later :)
23:17:18 <tpsinnem> sorry for being fairly off topic, but might anyone give pointers on a good hardware setup for a server that does building and testing at home (so preferably quiet while not doing hard work)?
23:17:37 <SrPx> lispy: http://hackage.haskell.org/package/groom seems like I found what I need :D
23:17:48 <SrPx> compensated for my lack of google-fu last time
23:18:25 <lispy> SrPx: Cool. I guess I didn't understand what you're trying to do. I thought you wanted to make the output pretty.
23:18:44 <SrPx> yep that is it, lispy
23:20:47 <tpsinnem> ^or, rather, pointers on something useful to read
23:21:37 <lispy> tpsinnem: Sorry. I don't know much to help with that. I use travis-ci as my build slave and thus it's super quiet :)
23:40:25 <Nahiyan> uh, is there a function that can give me the last two elements of a list?
23:40:40 <johnw> last xs: last (init xs)
23:40:41 <jle`> Nahiyan: take 2 . reverse?
23:40:48 <johnw> or that
23:41:04 <jle`> it'll return an empty list or a singleton if your list only has two items
23:41:07 <jle`> er
23:41:09 <jle`> has less than one item
23:41:12 <jle`> which might not be waht you want
23:41:21 <Nahiyan> oh
23:41:23 <lispy> (and it will swap their order)
23:41:44 <Nahiyan> last (init xs) : last xs
23:41:55 <Krikey_Sanchez> is there a way to write a function of type String -> IO (), using putStrLn
23:41:59 <triliyn> :t last
23:42:00 <lambdabot> [a] -> a
23:42:02 <Krikey_Sanchez> without using lambda notation?
23:42:11 <jle`> Krikey_Sanchez: isn't putStrLn already String -> IO ()
23:42:13 <Krikey_Sanchez> like, i want to avoid (\x -> putStrLn "my data: " ++ x
23:42:23 <Nahiyan> I feel using reverse would be too slow
23:42:23 <lispy> lastTwo [] = Nothing; lastTwo [_] = Nothing; lastTwo (x:y:_) = Just (x,y)
23:42:35 <jle`> well you can try making it point free
23:42:37 <lispy> er derp
23:42:41 <lispy> Soryr, that's first two :)
23:42:44 <Krikey_Sanchez> jle` yeah I'm not quite sure how to do that
23:42:45 <Krikey_Sanchez> in this case
23:42:52 <jle`> hard to help without an example
23:43:10 <triliyn> Krikey_Sanchez: you can say putStrLn . ("my data: " ++)
23:43:40 <Krikey_Sanchez> ah
23:43:41 <Krikey_Sanchez> bah that works
23:43:47 <Krikey_Sanchez> I don't know why I didn't see that myself
23:43:48 <Krikey_Sanchez> okay thanks
23:43:52 <jle`> @pl \x -> putStrLn ("my data: " ++ x)
23:43:52 <lambdabot> putStrLn . ("my data: " ++)
23:43:54 <jle`> neato
23:46:13 <lispy> let lastTwo [] = Nothing; lastTwo [_] = Nothing; lastTwo (x:y) = Just (x,y); lastTwo (x:y:zs) = lastTwo (y:zs) in lastTwo [1..10]
23:46:18 <lispy> > let lastTwo [] = Nothing; lastTwo [_] = Nothing; lastTwo (x:y) = Just (x,y); lastTwo (x:y:zs) = lastTwo (y:zs) in lastTwo [1..10]
23:46:19 <lambdabot>  Just (1,[2,3,4,5,6,7,8,9,10])
23:46:20 <Nahiyan> How do I unbind a function I made using let in ghci?
23:46:33 <nisstyre> Nahiyan: you can reload
23:46:36 <nisstyre> :r
23:46:38 <Nahiyan> ah
23:46:41 <lispy> > let lastTwo [] = Nothing; lastTwo [_] = Nothing; lastTwo [x:y] = Just (x,y); lastTwo (x:y:zs) = lastTwo (y:zs) in lastTwo [1..10] -- shouldn't program tired
23:46:43 <lambdabot>  No instance for (GHC.Show.Show t0)
23:46:43 <lambdabot>    arising from a use of ‘M867564152316863088915192.show_M8675641523168630889...
23:46:43 <lambdabot>  The type variable ‘t0’ is ambiguous
23:46:43 <lambdabot>  Note: there are several potential instances:
23:46:43 <lambdabot>    instance [safe] GHC.Show.Show
23:46:56 <lispy> > let lastTwo [] = Nothing; lastTwo [_] = Nothing; lastTwo [x,y] = Just (x,y); lastTwo (x:y:zs) = lastTwo (y:zs) in lastTwo [1..10] -- shouldn't program tired
23:46:57 <lambdabot>  Just (9,10)
23:48:09 <jle`> hm
23:48:27 <jle`> isn't foo (x:y:zs) = foo (y:zs)
23:48:38 <jle`> equivalent to foo (x:zs) = foo zs
23:49:24 <lispy> jle`: yes it is. I should have cleaned that up.
23:50:25 <lispy> my definition is actually terrible in lots of ways.
23:50:49 <jle`> hm
23:50:52 <jle`> it's not identical
23:51:03 <lispy> > let lastTwo [x,y] = Just (x,y); lastTwo (x:ys) = lastTwo ys; lastTwo _ = Nothing in lastTwo [1..10] -- This is already better
23:51:04 <lambdabot>  Just (9,10)
23:51:11 <jle`> because the first only matches on litsts of at least length two
23:51:17 <jle`> so it depends on where in the pattern match it is
23:51:30 <lispy> right and that's why I had written it that way.
23:51:39 <lispy> there is one more difference
23:52:01 <lispy> :t \Nothing -> Nothing
23:52:02 <lambdabot> Maybe t -> Maybe a
23:52:09 <lispy> :t \a@Nothing -> a
23:52:10 <lambdabot> Maybe t -> Maybe t
23:52:22 <lispy> jle`: notice that the types are different
23:52:48 <lispy> jle`: in the second one the parameter is shared with the output. So the type can't change.
23:52:59 <jle`> i've run into a similar case with Maybe/Either, but i'm not sure how this applies to the list example
23:53:07 <lispy> in the first one, we return a different Nothing.
23:53:16 <lispy> sharing
23:54:05 <lispy> lastTwo (x:y:zs) = lastTwo (y:zs) -- the (:) on the RHS is new and not the same as the (:) on the LHS. So (y:zs) isn't shared between input output, but y and zs are.
23:54:13 <lispy> jle`: does that make sense?
23:54:18 <jle`> ah
23:54:40 <jle`> i see
23:55:29 <lispy> jle`: your homework is to rewrite it using a fold :)
23:56:09 <jle`> well you had to go and say that didn't you
