00:09:25 * hackagebot purescript 0.5.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.1 (PhilFreeman)
00:09:25 * hackagebot tls 1.2.7 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.7 (VincentHanquez)
00:10:15 <aspidites> vermeille: i, too, was disappointed with how ugly it was. i think if you used record syntax it would be slightly prettier, but i'm not convinced that sum types as records make sense
00:10:31 <aspidites> theres always ghc extensions i guess
00:11:07 <redtricycle> How anout this one...     No instance for (Num String) arising from a use of `fromIntegral'
00:11:17 <redtricycle> http://lpaste.net/edit/103854
00:11:27 <EvanR_> you tried to convert a String with fromIntegral
00:12:36 <redtricycle> Is there another fromX where I can convert Word8?
00:12:38 <EvanR_> whats the type  of parseHTML?
00:13:33 <redtricycle> String
00:13:40 <redtricycle> trying to get Word8->String
00:13:49 <EvanR_> it cant be String
00:13:56 <EvanR_> youre using it as a function
00:14:27 <redtricycle> Let me look it up, it's from HandsomeSoup
00:14:43 <EvanR_> also you shouldnt be worrying about Word8
00:15:06 <EvanR_> you can convert lazy bytestring into a String with a decoder
00:15:21 <EvanR_> :t toString
00:15:22 <lambdabot>     Not in scope: ‘toString’
00:15:22 <lambdabot>     Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8)
00:16:04 <redtricycle> parseHtml :: String -> IOSArrow b (NTree XNode)
00:16:21 <EvanR_> ok so find a function convert ByteString to String
00:17:53 <redtricycle>     Couldn't match type `GHC.Word.Word8' with `Char' Exp
00:17:53 <redtricycle> ected type: String
00:17:53 <redtricycle>       Actual type: [GHC.Word.Word8]
00:18:01 <EvanR_> :t decodeUtf8
00:18:02 <lambdabot> Not in scope: ‘decodeUtf8’
00:18:04 <EvanR_> http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text-Lazy-Encoding.html
00:18:25 <EvanR_> decodeUtf8 :: ByteString -> Text
00:18:41 <EvanR_> unpack :: Text -> String
00:19:19 <redtricycle> Oh, I see
00:19:40 <redtricycle> Now I'm here
00:19:41 <redtricycle>    Couldn't match type `Data.Text.Internal.Lazy.Text' with `[Char]'
00:19:41 <redtricycle>     Expected type: String
00:19:41 <redtricycle>       Actual type: Data.Text.Internal.Lazy.Text
00:19:56 <redtricycle>         let doc = parseHtml $ TLE.decodeUtf8 $responseBody out
00:20:06 <EvanR_> parseHtml . unpack . decodeUtf8 <$> responseBody out
00:20:28 <EvanR_> oh responseBody is a pure function
00:20:41 <EvanR_> parseHtml . unpack . decodeUtf8 . responseBody $ out
00:22:07 <EvanR_> for large documents a parseHtml that took a text would be better
00:22:20 <EvanR_> maybe theres one in that library youre using
00:22:26 <redtricycle> EvanR_: Got it, showStructure
00:22:34 <redtricycle> Data.Text.Lazy.Internal.showStructure
00:22:39 <EvanR_> what
00:22:56 <redtricycle> EvanR_: http://hackage.haskell.org/package/text-1.1.1.2/docs/Data-Text-Lazy-Internal.html#v:showStructure
00:23:06 <redtricycle> parseHtml . showStructure . decodeUtf8 responsebody out
00:23:28 <EvanR_> no
00:24:00 <EvanR_> Warning: this is an internal module, and does not have a stable API or name. Functions in this module may not check or enforce preconditions expected by public modules. Use at your own risk!
00:24:00 <redtricycle> oh, hmm...
00:24:12 <EvanR_> unpack is in Data.Text
00:24:36 <pavonia> What are you trying to do?
00:25:01 <EvanR_> pavonia: http://lpaste.net/edit/103854
00:25:59 <redtricycle> unpack is the way to go
00:26:26 <EvanR_> unless you have a parseHTML in your library that accepts a Text rather than String
00:26:35 <EvanR_> that will be more efficient
00:26:43 <redtricycle> This worked: http://lpaste.net/103859
00:42:24 <vermeille> What is the preferred way to write testsuites? I read about QuickCheck in RealWorldHaskell but now that I want to make my tests run with cabal test, it seems not to integrate well
00:43:13 <EvanR_> if it compiles its good, if it boots up its perfect
00:44:40 <aspidites> vermeille: maybe tasty?
00:45:02 <aspidites> http://documentup.com/feuerbach/tasty
00:45:23 <dmj`> are there bang patterns that evaluate to normal form?
00:46:02 <aspidites> funny you mention it. i usually write a lot of unit tests, but havent written a single one for haskell. i'm sure i should, but i've kind of been using the type system as my testing framework
00:46:31 <aspidites> in python - write a failing test case. run. it fails. fix code until it passes. haskell - write code. it fails. fix it until it compiles
00:46:46 <vermeille> haha, true
00:47:04 <EvanR_> the ghci is a good way to make sure haskell functions work as expected
00:47:18 <vermeille> EvanR_: yes, but it does not prevent regression
00:48:06 <EvanR_> yadda yadda, this is why simpler straight forward functions with a single purpose ...
00:48:34 <EvanR_> which combine predictably to produce a correct composed function
00:48:47 <vermeille> I do agree with you
00:49:06 <vermeille> but I would be more confident to have tests :)
00:49:11 <EvanR_> IO commands are also surprisingly easy to test in the interpreter
00:49:20 <EvanR_> which are harder to auto test
00:53:22 <aspidites> i'm not saying don't write tests, i'm saying i haven't had a reason to do so
00:53:41 <aspidites> i'm sure in a bigger project i would, and even then it could be argued that you should be testing from the beginning, but, eh
00:54:08 <EvanR_> i stopped writing tests for simple functions in ruby, only for large collections of functionality
00:54:21 <aspidites> that whole, composability thing kinda spoiled me: This small obvious thing works, thus this large thing composed of obvious small things will work
00:54:59 <EvanR_> and when i see a pull request come through with not-obviously-right ruby code i tell them to refactor it
00:56:08 <vermeille> Don
00:56:19 <EvanR_> that said, medium to a lot of not very valuable autotests are like candy for upper management
00:56:22 <vermeille> Don't trust the obvious*
00:58:29 <EvanR_> one thing i learned here is that you can apply type discplines, immutability, purity to systems that dont support or encourage it for fun and profit
00:59:02 <EvanR_> if a function invisibly only accepts this or that, and something breaks its not the functions fault
01:00:28 <tremon> but doesn't it make finding the cause of the fault harder, unless you sprinkle your code with an unhealthy dose of runtime checks?
01:00:54 <EvanR_> maybe the unit test craze produced a culture of making the interface to functions simpler to reduce the burden of designing tests, instead of a single parameter with unlimited depth of configuration
01:02:45 <EvanR_> tremon: harder than what
01:04:37 <tremon> harder than having the compiler (visibly) enforce the function's inputs. I thought you were contrasting compile-time type enforcement with dynamic typing
01:05:29 <tremon> I do agree that type discipline is a good thing in every language, just not sure the "every function can be visually inspected for correctness" scales well
01:05:34 <EvanR_> i wasnt
01:07:01 <EvanR_> i was contrasting a "functional" discipline in systems that dont support or encourage it with doing more what those systems support and encourage
01:08:03 <EvanR_> tremon: i think tests for functionality at a high level makes sense
01:09:17 <EvanR_> but some shitty test included with a 9 line pull request cant be too valuable
01:09:24 <tremon> oh I agree, and I also agree that very short functions shouldn't need extensive testing.
01:10:15 <tremon> Just wasn't sure what you meant with "[if] something breaks its not the functions fault", and what that implied about program correctness
01:10:16 <EvanR_> well thats the thing, very short functions are easy to extensively test
01:10:39 <EvanR_> yeah i meant to say, if something uses the function wrong
01:11:14 <tremon> oh I understood that, I just responded to say that it can be hard to identify where the function is used wrongly
01:11:43 <EvanR_> if a crash occurs inside the function itself, should be easy
01:12:01 <EvanR_> but if it doesnt crash, but behaves arbitrarily, thats really bad
01:12:17 <tremon> yes, that's what I meant with runtime checks. I was thinking of a function silently accepting bad input and doing the wrong thing, causing a crash in unrelated code
01:13:02 <tremon> of course that's the "function composition" case for which tests are very desirable but harder to write
01:13:19 <EvanR_> i dont put too many such checks, but i would prefer constructions that "fail more" in the case of weird input
01:14:35 <EvanR_> i remember a while back when common sense was to use language constructs which "didnt crash" on purpose because crashing was worse than being completely wrong and difficult to detect and debug
01:15:21 <tremon> from a sales point of view, I'm sure it is :|
01:16:20 <tremon> although I think the rationale ended at "completely wrong". The difficult to detect and debug was an intended (and predictable) side effect
01:16:36 <tremon> *un*intended
01:17:17 <Welkin> isn't the idea behind erlang to crash as soon as possible?
01:17:34 <Welkin> so that another server can take over and restart the one that failed
01:18:05 <EvanR_> auto restarting a thing because it crashed is funny
01:20:20 <EvanR_> to me, crashes resulting from a programming error, which no code can hope to fix for you, means rebooting is dangerous
01:20:36 <EvanR_> unhandled exceptional situations is something else
01:30:03 <jonke>  Mostly the erlang way is the way of the samurai, ie 'do or die', that isn't the same thing as starting another os-process but more of starting a new thread
01:32:06 <jonke> If you crash the erlang runtime thats bad, like really bad
01:47:11 <EvanR_> @hoogle Maybe a -> (a -> IO ()) -> IO ()
01:47:12 <lambdabot> GHC.Conc.IO closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
01:47:12 <lambdabot> GHC.Conc closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
01:47:12 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
01:52:38 <hseg> Hi. Looking at http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
01:52:38 <hseg> , it's not clear that the Monad constraint is warranted, as all operations there only use Applicative functions. (Apart from the distribution law for MonadPlus, but http://winterkoninkje.dreamwidth.org/90905.html points out that the monadic analogue of the dirac delta function (i.e. f=const mzero at a, id elsewhere) fails the law for all (return a /= mzero)).
01:53:48 <hseg> So I ask. How is MonadPlus under the reform any more than the constraint: (Monad m, Alternative m) => MonadPlus m?
02:04:36 * hackagebot hxt-pickle-utils 0.1.0.2 - Utility functions for using HXT picklers.  http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.2 (ErikHesselink)
02:07:19 <hseg> Anyone? What do I gain by specifying MonadPlus rather than Monad + Alternative?
02:08:17 <merijn> hseg: Smaller constraints, since "MonadPlus m" is less typing :)
02:08:19 <hseg> And if I don't gain anything, why are we discussing reforming MonadPlus, instead of phasing it out into Alternative (with some appropriately-named class for those instances satisfying the catch law)?
02:08:31 <merijn> hseg: Also any Monad that can be Alternative is also a MonadPlus
02:09:13 <hseg> merijn, Do we use typeclasses to bring constraints together elsewhere?
02:10:15 <merijn> hseg: tbh, I don't think so and perhaps if history were different MonadPlus wouldn't exist
02:10:49 <merijn> But removing it now would gratuitously break code and it's a convenient synonym for shorter constraints
02:11:16 <EvanR_> i guess haskell is past the point of breaking code gratuitously for improvement ;)
02:11:36 <hseg> merijn, In that case, since we're already suggesting breaking up MonadPlus into three different classes, let's just generalize the new constraints, and use the old ones as synonyms.
02:11:38 <merijn> EvanR_: Not really, considering the AMP breakage and recent Typeable breakage :p
02:12:18 <merijn> hseg: The problem is that having a notion of constraint synonyms is GHC specific
02:12:35 <merijn> hseg: And also requires said extension in every module using those constraints
02:12:54 <merijn> hseg: In the interest of code portable to, say, UHC and others that'd kinda suck
02:13:11 <hseg> merijn, Just suggesting that there be instance MonadPlus m => Alternative M and instance (Monad m, Alternative M) => MonadPlus m
02:13:28 <hseg> Not actual synonyms. Unsure if that's available.
02:13:40 <merijn> hseg: They are in GHC :)
02:13:51 <hseg> To solve such problems?
02:14:17 <merijn> If you enable ConstraintKinds than "type Foo m = (Monad m, Alternative m); foo :: Foo m => a -> m a" is valid :)
02:14:43 <merijn> hseg: I'm not sure what those two instances would end up doing defined like that
02:15:36 <hseg> merijn, nice. Haven't played around with ConstraintKinds too much. And IIUC, these two instances mean that Monad + Alternative ~ MonadPlus
02:15:51 <hseg> But IANAGH - I am not a GHC hacker.
02:20:43 <hseg> Anyway, I think I'll note that on the wiki for the people implementing the proposal.
02:21:23 <hseg> Incidentally, has anyone seen an actual use of Alternative in real code? For the life of me, I can't recall having seen it used. Well, apart from in parsers.
02:21:58 <merijn> hseg: STM?
02:22:09 <merijn> Either e?
02:23:13 <merijn> So, yes :)
02:23:25 <merijn> oh and Maybe/MaybeT
02:23:41 <EvanR_> > Just 1 <|> Just 2
02:23:43 <lambdabot>  Just 1
02:23:48 <EvanR_> > Just 1 <|> Nothing
02:23:49 <lambdabot>  Just 1
02:23:56 <EvanR_> > Nothing <|> Just 2
02:23:58 <lambdabot>  Just 2
02:24:08 <hseg> Either doesn't appear in the Alternative haddocks.
02:25:08 <merijn> hseg: hmm, I guess it might not obey the laws
02:25:11 <hseg> But yeah, I guess foldr (<|>) empty *is* useful to find the first success/the list of errors/...
02:25:37 <gamegoblin> How would I use bytestring with hPutBuf ?
02:25:43 <gamegoblin> Or otherwise efficiently write a bytestring to a buffer
02:25:49 <gamegoblin> to a handle*
02:26:06 <merijn> hseg: Or in the case of STM to generate polling actions :)
02:26:27 <hseg> merijn, Can't imagine why. Should be more or less the same as the Maybe instance. With possibly accumulation of errors.
02:26:31 <gamegoblin> Nevermind, I am dumb
02:26:42 <merijn> gamegoblin: Don't use hPutBuf, there should be a hPut for bytestring :)
02:26:59 <gamegoblin> merijn: yes I just found it
02:27:00 <mm_freak_> hi there
02:27:03 <hseg> merijn, So I guess it is used in real code.
02:27:13 <hseg> mm_freak, Good afternoon.
02:27:34 <mm_freak> is using F and FT consistently faster than using Free and FreeT?  or are there any edge cases i should be aware of?
02:31:04 <mm_freak> hseg: to answer your question it's 11:28 here =)
02:31:08 <mm_freak> AM that is
02:31:45 <merijn> mm_freak: Wait, where are you geographically? Am I misremembering?
02:31:52 <hseg> mm_freak, Just wanted to say hello appropriately. You're an hour west from me, then.
02:32:18 <hseg> mm_freak, That would imply Central Europe/Africa.
02:34:00 <mm_freak> merijn: germany
02:34:28 <maybefbi> what are the odds of randomly generating a quine in a turing complete language?
02:34:34 <mm_freak> hseg: in that case you'd have to say, "hallo" =P
02:34:42 <mm_freak> or the more formal "guten tag"
02:34:57 <merijn> mm_freak: Isn't it güten tag?
02:35:04 <mm_freak> maybefbi: depends on your random variable and the language
02:35:24 <mm_freak> maybefbi: i can construct a language, where there exists a random variable that generates a quine with probability 1
02:35:31 <hseg> mm_freak, Guten Nachmittag, then.
02:35:36 <mm_freak> merijn: nope, although i am turkish =P
02:35:43 <mm_freak> güten tüg
02:37:31 <maybefbi> mm_freak, imagine a f :: Quine -> Quine, such that f /= id
02:38:36 <maybefbi> mm_freak, im trying to think what would it take to have a quine in organic chemistry
02:38:56 <hseg> maybefbi, You're describing a function mutating quines. You probably mean to say, given that you generate a string randomly in a language L, what are the odds that it parses as a quine?
02:39:33 <maybefbi> hseg, yeah mutating quines in which the first one is randomly stumbled upon by the computer
02:39:40 * hackagebot ex-pool 0.1.0.3 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  http://hackage.haskell.org/package/ex-pool-0.1.0.3 (KimAltintop)
02:40:03 <maybefbi> and then mutates to be capable of affording greater random mutations without loss of quine-ness
02:40:21 <mm_freak> i was actually thinking of generating a quine in the first place, for which there is always a random variable that does that with probability 1
02:40:43 <mm_freak> for the mutating quines…  in many languages that function can be:  f xs = xs ++ ys
02:40:56 <mm_freak> uhm
02:40:59 <mm_freak> for the mutating quines…  in many languages that function can be:  f xs = xs ++ xs
02:41:09 <hseg> maybefbi, So basically, you want to calculate the robustness of the quine-ness of a string under random corruption. What types of corruption are you modelling?
02:41:13 <mm_freak> in those languages quines often form a semigroup
02:41:17 <mm_freak> and in some languages a monoid
02:41:23 <mm_freak> under concatenation that is
02:41:57 <maybefbi> im just thinking of a theoretical way to calculate what type oraganic chemistry is needed and what type of environment is needed for life, and how likely it is, and where we should be looking for it
02:42:08 <maybefbi> may be we can even derive the type of planets to look for
02:42:27 <maybefbi> sent them signals
02:43:13 <maybefbi> if we model organic chemistry as a set of objects and operators that convert them between each other
02:43:27 <mbuf> what is the recommended way to try out ghc 7.8.2? or set up and test multiple ghc instances?
02:44:16 <merijn> mbuf: GHC uses a per version package database, so I usually just install the new GHC version in ~/ghc/ and use it by adding ~/ghc/bin in front of my path
02:44:30 <merijn> mbuf: cabal, etc. will automatically use whatever's on your path first
02:44:40 * hackagebot ex-pool 0.2 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  http://hackage.haskell.org/package/ex-pool-0.2 (KimAltintop)
02:44:53 <merijn> mbuf: As long as all your GHC's are different version numbers they will never collide
02:45:15 <mbuf> merijn, so I use cabal to install a newer ghc?
02:46:09 <mbuf> merijn, you mean extract bindist in ~/ghc/ and add it to PATH, and just use cabal
02:46:13 <merijn> mbuf: No, just go to "www.haskell.org/ghc" and download the binary build for your platform
02:46:47 <merijn> mbuf: The bindist has an autoconf script + makefile for installing, so just unzip it "./configure --prefix=$HOME/ghc && make install" and you should be done
02:47:29 <mbuf> merijn, will try; thanks!
02:48:45 <maybefbi> hseg, there is a radiation resistant quine which can suffer a single deletion event: https://github.com/mame/radiation-hardened-quine
02:49:21 <hseg> maybefbi, Wow. Will have to look at it later, gotta run.
02:49:31 <hseg> Thanks for the help, merijn
02:53:52 <maybefbi> anyone ever read the sci-fi novel Permutation City by Greg Egan?
02:55:26 <maybefbi> they have an autochemistry, a computer language that behaves like chemistry, but doesn't need to solve complex many body quantum mehanics equations
02:56:00 <t7> whats it for then?
02:56:09 <maybefbi> for simulating life of course
02:56:21 <t7> life is a physics simulation
02:56:54 <maybefbi> ok but we need a cheaper simulation. so as to know how likely it is, and where to look for it, and to manipulate it
02:57:24 <maybefbi> physics is too expensive, it needs entire universes
02:57:44 <maybefbi> and zillions of gigawatts of wasted energy
02:59:38 <lechip> hello everyone, I have to implement a very easy function on a template i was given but im having problems wrapping my head around the sytnax: count :: Int -> [Pupil] -> [(Group,Pupil)] count numberOfGroups = zip xs where
02:59:46 <lechip> then i need to imṕlement
02:59:57 <lechip> but i dont understand what is the zip xs where
02:59:59 <nclarke> make
03:00:07 <nclarke> Sorry, wrong window!
03:00:22 <mietek> Why does `cabal freeze` specify the current package version as a constraint for the current package?
03:00:26 <nclarke> @hoogle zip
03:00:26 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
03:00:26 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
03:00:26 <lambdabot> Data.ByteString.Char8 zip :: ByteString -> ByteString -> [(Char, Char)]
03:02:21 <lechip> yeah i know what zip does, what i do not understand is the zip xs where
03:02:27 <nclarke> lechip: zip takes two lists and 'zips' them together. E.g. [1,2,3] `zip` ['a', 'b', 'c'] == [(1,'a'), (2,'b'), (3,'c')]
03:03:25 <lechip> so if i want to take a list and zip it with the vvalue of numberOfGroups, what do i need to put after the where?
03:05:02 <nclarke> Well, think of the type of 'count numberOfGroups'
03:05:33 <nclarke> It's going to be [Pupil] -> [(Group, Pupil)]
03:06:05 <nclarke> So 'xs' needs to be of type [Group]
03:06:59 <nclarke> You have an Int and you need to convert it into [Group]. I don't know your codebase, so I don't know how to do that, but can you see a way?
03:07:20 <lechip> group is just type Group = Int
03:07:23 <nclarke> Convert is a bad word there, but you see what I mean
03:07:27 <lechip> yep
03:07:42 <nclarke> Right. So, an obvious implementation would be 'where xs = [0 .. numberOfGroups]'
03:07:51 <lechip> but i dont see how based on the type of count numberOfGroups you got that xs was of type [Group]
03:07:58 <nclarke> Or [1 .. numberOfGroups]
03:08:37 <nclarke> Well, you know that 'count :: Int -> [Pupil] -> [(Group, Pupil)]', right?
03:08:59 <nclarke> So 'count numberOfGroups' is of type ' [Pupil] -> [(Group, Pupil)]'
03:09:28 <nclarke> You've partially applied the function (or, if you think of it in curried form, you've just applied the first function) over the first argument
03:10:02 <lechip> hmmmmmmmmmmmmmmmm i think i get it now
03:10:08 <nclarke> And you've said that 'count numberOfGroups = zip xs where'
03:10:09 <lechip> let me see what i can do real quick
03:10:46 <nclarke> And you know that the type of 'zip xs' where xs :: [a] if [b] -> [(a,b)]
03:10:52 <nclarke> s/if/is
03:12:03 <zgredzik> can anyone help me solve a problem with making a custom class an instance of a functor ? http://lpaste.net/103869
03:12:14 <nclarke> So you have the two partial signatures: '[Pupil] -> [(Group, Pupil)]' == '[a] if [b] -> [(a,b)]' and you can infer that 'a' must be 'Group'
03:12:32 <nclarke> So you know that 'xs' is of type '[Group]'
03:12:42 <lechip> it makes total sense nclarke
03:12:46 <lechip> thank you so much
03:12:48 <lechip> i understand now
03:12:50 <nclarke> Cool :-)
03:12:51 <lechip> TY
03:12:53 <nclarke> You're welcome
03:31:42 <spacekitteh> what sort of recursion scheme would one use for simplifying a fixedpoint abstract syntax tree?
03:32:01 <kcj> I love you guys.
03:32:19 <spacekitteh> i love you too <3
03:33:02 <kcj> <3
03:33:30 <Sculptor> bromance
03:33:45 <kcj> You can join, love is free.
03:33:54 <spacekitteh> i'm actually a girl but w/e close enough
03:33:57 <nclarke> Big hugs all around :-)
03:34:02 <Sculptor> i'll admire from the far
03:34:07 <Taneb> :)
03:34:17 <Taneb> spacekitteh, what do you mean by a fixedpoint AST?
03:34:30 <Taneb> I'm not familiar with the term
03:35:17 <spacekitteh> data ExprF a self = Add self self | Const a | Mul self self; type Expr a = Fix (ExprF a)
03:35:23 <spacekitteh> etc
03:35:32 <Taneb> Oh, I see
03:37:52 <Taneb> spacekitteh, well, it wouldn't be too hard to just write that the obvious way (I presume you want to evaluate the expression?)
03:38:09 <spacekitteh> yeah, i've got the evaluation part down using a catamorphism
03:38:32 <zgredzik> hello, I have a custom data type as implemented in http://lpaste.net/103871 , does anyone know if it's possible to somehow limit the type `a` that the `channels` map to, to be only of a specific type, ie. `Maybe a`, or a more custom `Channels a`?
03:38:43 <Taneb> spacekitteh, what else do you want to do?
03:39:02 <spacekitteh> simplify it, of course :)
03:39:15 <Taneb> spacekitteh, ah, not sure
03:39:24 <jophish> When was the haskell 98 report first written?
03:40:01 <Taneb> zgredzik, yes, but you'd need to change the Functor instance
03:40:17 <zgredzik> Taneb: you mind elaborating a bit?
03:40:24 <Taneb> newtype ImageRGB a = ImageRGB {_channels' :: Map String (Channel a)}
03:40:45 <zgredzik> Taneb: yeah but that screwes up how I would like the functor to work
03:41:02 <Taneb> Change the fmap f on the RHS to fmap (fmap f)?
03:42:53 <Taneb> Assuming Channel has a functor instance
04:55:18 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
04:55:18 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
04:55:18 --- names: list (clog jorr roconnor prophile goldkatze ZioCrocifisso razieliyo fall_ asmyers gregors nh2 Wuzzy allay paper samrat1 rgr free_beard ldrndll shesek Smilex albertid_ asQuirreL paintcan senorflor paullik maattdd wombawomba jtcwang1 nclarke Macuyiko Gika plutoniix eizo yorick remdezx sski io2 qxjit quchen ndrei Ardenzi ij Guest58136 rribeiro danilo2 cpennington arnihr Zariel_ dixie_ Argue spacekitteh johann silver tesuji Itkovian tlw1 hamid mnagele artyomkazak)
04:55:18 --- names: list (shintahW jetho __class__ zgredzik seye fran humppa JagaJaga perspectival Eduard_Munteanu hkon_ jutaro takuan gidogeek mhi^ iArthur matheus23 ArneL ion bjorkintosh c74d glguy qnikst jophish SoupEvil srcerer tonbo Maerten Glavata sgronblo oubiwann assia_t Thooms pdpi MercurialAlchemi chad bluesm bitonic klaut mirpa Quashie predator117 owst nilg` merijn Rokko Guest5702 hexagoxel Ragnaroek sagittarian humanoyd zcourts Sonderblade totte Kiryx maybefbi kgadek)
04:55:18 --- names: list (Kobata srenatus dawe marr yacks edon Beetny t7 tismith MrWoohoo eikke__ psquid_ MindlessDrone darthdeus raichoo alpounet Lethalman npcomp sbjorn AntiSpamMeta elfenlaid jefimenko tar_ Reite hackagebot Viaken hebz0rl ThatOtherPerson stbuehler Artpicre_ s_e ehamberg mokus Tehnix_ ousado PierreM dgvncsz0` folone_ Rufflewind_ Krakarn-- BMeph_ Galactic EvanR__ _asc_ Faultline_ DT__ thetallguy arenz tremon thunderrd arj xiowa ktosiek vendethiel kazimir42 bjz kuzux)
04:55:18 --- names: list (KingOfKarlsruhe echo-area odi me__ anry fyolnish akegalj RchrdB ashnur nilg andersonM ddellacosta jonkri luzie dreixel bocaneri glowcoil Ankhers armyriad gniourf sclv freeman42 samrat bonobo123 mendez vili shintah Jolew Rylee archblob ephemeron piezoid ValicekB conal hsc Brando753 kerrick divyanshu neptunepink shergill zcd Natch tomboy64 Rakkin isomorphic guampa SparkySparkyBoom bvck jlamothe Guest69161 halvorg bacon1989 xl1 tnks Ralith killown tromp__)
04:55:18 --- names: list (jumblerg Ginto8 meandi_ apaku ragnar_ WraithM erkin tv SegFaultAX ceii nemesit|znc drdozer mmaruseacph2 borrelnoot9 ssedov chatsiri_ gthorslund banister dcoutts lennartj regexp nus xrq FVG r444 emma adamah zerokarmaleft fiatjaf Jesin jpierre03 bergey solidus-river Dodek kylcarte JesuZ fizbin ninzine djapo mike25 bwe chexxor gspr Aetherspawn centrinia moop saiko-chriskun sprang felixn albel727 GGMethos Th0mas yrdz maoe magicman gseitz yriw Kruppe finnrobi)
04:55:18 --- names: list (h_chiro euphoriaa machineslearn liyang karls c_wraith Bwild seliopou Sculptor mornfall wting pyon pfurla1 m1dnight shanse mars-92 Sycamore zalami schell kadoban Mon_Ouie Khisanth dmilith uzo dolio TakSuyu e^ox identity Rarrikins dino- jix ksf_ augur Lefeni sellout Philonous dmwit saep stevely bitemyapp kakos randomclown atohs jrp6 timemage osa1 ruzu araujo tfng thirsteh pnielsen dodgems pjdelport chale ClaudiusMaximus benj_ venk kalz ggherdov_ keko_ sohum)
04:55:18 --- names: list (LordDeath Paprikachu Svedrin haasn hdevalence|away Polarina Jaxan Nickeeh Blkt petantik NinjaPenguin mimi_vx Ulrar Iceland_jack Edoxile fnordbert tekacs edk anachron otterdam greymalkin drdo mrb_bk puzza007 eribeiro peddie fergusnoble mirsal kungp idnar leifw Xorlev Reiser unkn ttuegel Someguy123 pqmodn nicoo hvr eikonos Erstarrung ted1 prattmic taruti kjnilsson Averell sinclair|work klarh kwantam Sagi thrain Wamanuz Dashkal JustAPerson jml DarkFox ec ljhms_)
04:55:18 --- names: list (eyck_ b_jonas kirelagin_ davd scopedTV_ Jei_ stvc heikkih vamega pyrtsa koalallama bartavelle cdidd katis akshatj pranz dosequis_ helgikrs cyrusdavid pdxleif kloplop321 cwc jmob sleepynate sea-gull- adm frms_ mjrosenb tippenein mist11`off jaspervd1 Fubar^ twn barrucadu grohne_ Jonno_FTW horlicks1 hamishmack acharles NobbZ|ZZzz fakeezz_ mike4- intrados` u-ou dsirenko_ himikof b00thead ps-auxw troydm mrkishi Internet13 noam_ Guest2354 effy_ vitka rybczynski)
04:55:18 --- names: list (xintron pgavin juhp isenmann ChongLi danvet_ ts33kr _46bit teeteewhy importantshock joneshf-laptop otto_s_ l4u Draggor jedai Licenser thalassarche Nimatek jrslepak edwtjo hive-mind adnap Athas anders^^ zz_flazz covi fluffiey Cerise khushildep ellipsis_ sclv_ smarter earthy suOya hammi kandinski `^_^v plucas tov mwc AlephBeth mikecaruso derperinn integral tumdedum zarul xplat zigapeda2 rekahsoft Fullma Figueroa monochrom deevus vsayer_ dougia jfhall)
04:55:18 --- names: list (tensorpudding alec liori yubrew pi8027 ggnmkk melter s00pcan Nahra snoyberg unsymbol Corey Vbitz heudebeu utkarsh dyreshark tessier MitchW nik_89 pikhq theanine jorj jonke dsantiago cwvh j0ni HugoDaniel caligula [mth]_away cschneid ido Bigcheese Shin-LaC johnw passiveobserver orbital Raynes bigos mee Spacegoat IanKelling inr stelleg jrw Ptival blicero aspidites cjwelborn skarn kyl m09 saiam hpc go|dfish stiell Maxxe Will| arch_ rieper_ yggr_ simon popz_)
04:55:18 --- names: list (zeroskillor wchun aji joseph07 Lindrian tomprince beastman82 ortmage sm renzhi cmr umib0zu bbloom wilfredh notdan DigitalKiwi lusory maaku gbarboza Soft Intensity jayne annulus indigo CosmicRay Bootvis amiller koala_man brackets goldfire gnuvince DexterLB vozz savanni etabot aloiscochard purefn Axman6 iron_houzi FireFly xpika flebron drbean natte lamilami mechairo` mmaruseacph2|umb ChewieBeardy qz_ tero-_ LU324 profmakx ndngvr` ernst amatsu lacrosse vera)
04:55:18 --- names: list (ivan\ madjestic flippo mortberg MK_FG ajcoppa schlumpi benzrf|offline biscarch copumpkin dqd Gothmog_ raphie_ docsis__ superjudge nifty jonsterling korpse______ MMuse_ blaenk ryanakca canta cods negatratoron comboy kmicu davidfetter Tesseraction Dynetrekk joneshf __main__ rhodesd Ke Liskni_si Starfire numberten rlr Phibonacci mikeplus64 sam_d _d3f saml dp_wiz ckw spacebug elfangor tsou martingale Ornedan ephess M-ou-se pnielsen_ thirsteh_ mayski reizuki)
04:55:18 --- names: list (defanor shachaf alcabrera|afk srhb Lemmih wollw mbrcknl seanparsons dumbhat solrize everett coconnor_ mrmonday jrm yeltzooo rwbarton Saizan AtnNn waterlaz Enigmagic cdk thorkilnaur descender xahry rejuvyesh[away] Maxdamantus petterw sdx23 jackhill linduxed catsup funfunctor fikusz tmssgrdn musicalchair sordina2 aristid Derander archit cyphase dlat zacts mshroyer zalzane apples ahihi felipe_ relrod nuser meretrix Wayneoween redtricycle iteratee ByronJohnson)
04:55:18 --- names: list (alorente nisstyre chirpsalot nick1234abcd_ tdammers bytbox pltc chas bjobjo Adeon Draconx bernalex erikhinton wjt jagtalon PatrickRobotham dhrosa steshaw therealklanni sykora Excurio Klumben ivan` jmct pcapriotti flori eL_Bart0 Dtgr dario Kneiva joachifm rschulman liff mami companion_cube dilinger bvad flux SaBer Jaak _5kg epta PHO_ owlglass werdna fryguybob Cr8 pii ixian ircbrowse cin alang carter wjm mikeizbicki Walther vikraman heath mullein newsham)
04:55:18 --- names: list (joelteon eguim levi Yawgmoth mathu RogueShadow bounb ft ninegrid FUZxxl killy9999 mrd_ Ezku_ Fuco oinkina andyland c9sloud jabbslad__ wizonesolutions zymurgy akurilin `0660 AshyIsMe mike2 cpa_ bind simlay Yaniel int-e OrangeDuck mononofu djahandarie necroyeti dh dropdrive Chousuke paz_ chrra tomejaguar bens byorgey \q iross_ tamiko maurer tabo kipras hamilyon [swift] k00mi crs_ jrib Eridius jin_jin simon_ alinab statusfailed mrpantou1le qrada_ Taneb duairc_)
04:55:18 --- names: list (certainty alexsdut2on aleator asjo` ilmig noteventime nalui333 gdoteof yeshuah lopex chance itsmonkt1stic FreakyPe1guin Boney zq_ bd__ amontez liszt_ tlevine phaer etrepum Raynos si14 akahn SethTisue_______ posco_ stephe__ Imdsm shennyg AlainODea nsaje zpconn______ strmpnk jroesch_ dlackty jodaro kcherkashin__ Karethoth nkpart bgyss joshsz ekroon tobyp___ ocharles Scorchin CARAM _tca avdi jzelinskie rfv ben skuggi wagle nispaur znutar_ vermeille ozataman)
04:55:18 --- names: list (n-dolio mgomes orbital_ hyPiRion uncleBlazer niko jdiez harski peder deni ggreg dju solirc valdyn jle` d3lxa pharaun LeaChim lahwran vhz epsylon rootzlevel omefire1 BeardedCoder demolithion hamarukusa BrianHV_ Gracenotes_ Eliel_ davean_ rsnous cjay croys_ knyppeldynan xnyhps mavam frawgie_ mrshoe_ andrewsw_ zeiris_ Heffalump ziman bcoppens mietek jaysonsantos Martty papna exicer_ robj_ stepcut wereHams1er DogeHayashi Igloo elrancho_ shepheb zomg jakutis)
04:55:18 --- names: list (gsingh93 shutdown_-h_now majoh yan_ Nik05 zepto kragniz boothead saurik photex stack res22 b2coutts xaimus haroldwu xymox philipdexter Biohazard orion lyxia tg dv-_ geekosaur wjlroe raek tych0 ForNeVeR iulian pingu danneu MindfulMonk sw1nn morolin rahul mangaba_leitosa yano ZsoL tavelram_ myme Freundlich sajith kshannon Lemur Cale Sgoettschkes eiro deavidsedice dagle Deewiant happy0 echo[1] Marqin aford japesinator AivarasK fussman antoniy phy1729 ahf jaimef)
04:55:18 --- names: list (MarcWeber yac kryft ParahSailin farn Plasmastar adlan bsmt hongminhee Sylarr Turboknot13 Eagle_Erwin lambdabot anders0 jkg Sornaensis Tene pieter_ dlundy Tordek jonathanj dogmaT myf Zariel `bps CindyLinz gfontenot pfoetchen dabradley Paks KaneTW SHODAN qwandor|quassel Watcher7 elgot DasIch RayNbow`TU mgaare mlen Kinnison mjo honza ski lurker6 afleck bgamari _flow_ kosmikus Valodim noddy mrowe_away kcm1700 joar sofancy hc ejls og01 iota_ confound otulp dan64)
04:55:18 --- names: list (nwf gdsx ccasin monsieurp ofan jameseb KorriX micrypt pp^ kini snowp tromp_ jchee idoru slobo quicksilver helgar kardboardb so GaveUp dbelange evax Javafant majackson prinsen thoughtpolice AndyS2_ vmeson spion callumacrae mandu ederign pfn MasseR aoh kloeri marienz asm89 Nshag lokydor_ Guest69478 shelf jlewis geal sjy sgray10 willb1 plhk brixen gargawel rtl Baughn applybot eagleflo BlastHardcheese peltchu saarin nikola ReinH Clint bergmark andyo_ SwashBuckla)
04:55:18 --- names: list (skypers Rutger` rs0 delimax luite nesqi drmegahertz Hafydd copton irssi_ blenny jzl DustyDingo benbangert cross kqr betawaffle Phillemann Drezil @ChanServ tomaw ibid eyenx blast_hardcheese inarru RevJohnnyHealey bbee Cryovat brainproxy bra felixsch lpsmith lulf Razz honkfestival davidthomas benmachine supki lpaste acfoltzer ConstantineXVI lieven_ sipa hiredman spaceships kaol jliikka klugez yam s4msung StoneToad froztbyte lenstr gaze_ aninhumer kxra zso)
04:55:18 --- names: list (JPohlmann Adios_ fabjan_ Phlogistique aseidl dustinswan FliPPeh regtools selator Twey mero cmsd2 dawik osfameron Laney eyem XMunkki lispy leroux adimit iNode001 lattenwald ciaranm claudiyoh joefiorini heaumer martin Hodapp td123 gemelen boegel|work swen shapr Spockz codeburg terlar phryk Hardolaf ivoscc CaveJohnson brisbin javawizard wormphle1m cow-orke1 absence nurupo warpy mixi dschoepe mindleyhilner Preyer burp mak` KitB mattp__ WarzoneCommand dmead Olive`)
04:55:18 --- names: list (robbert macron bxc zenzike cynick jlouis theDon Arnar_ sunnavy Rembane clementd Fuuzetsu gridaphobe sa1 michaelpj mr- jj2baile tridactyla miasma kittensoup SLi dwierenga Vq drone| solarus Belgarion0 petanqk hegge opqdonut)
04:56:19 <maybefbi> merijn, ok :(
04:57:01 <merijn> maybefbi: The good news is, if you define your own datatype for universal Turing machines you can define it however you like
04:58:10 <maybefbi> merijn, how about :: StateT IO a
04:59:48 <merijn> That type doesn't type check, it's missing a statement argument. But I'm not quite sure what kind of answer you are expecting people to give you?
05:00:20 <mr-> maybefbi: You could implement one and then ask ghci what its type is!
05:00:36 <Aetherspawn> why isn't haskell turing complete?
05:00:45 <merijn> Aetherspawn: Who said that?
05:00:55 <Aetherspawn> I heard it here once before by multiple people
05:01:13 <Aetherspawn> or maybe I misheard?
05:01:20 <merijn> Aetherspawn: Sounds like you should never listen to those people :)
05:01:44 <merijn> Aetherspawn: You may have been confused and interpreted one of the usual "total languages are not Turing complete" as being about haskell
05:01:54 <merijn> Haskell is not a total language, so that observation does not apply
05:02:06 <merijn> And is only partially accurate for total languages (before someone yells at me)
05:02:46 <aspidites> what else do you guys check for haskell related goings-on besides reddit?
05:02:54 <mr-> How is it only partially accurate, merijn?
05:03:26 <aspidites> planet haskell is a bit of work to sift through...i guess i could use feedly.com for that
05:03:29 <Aetherspawn> (talking about this; http://en.wikipedia.org/wiki/Total_functional_programming ? )
05:04:10 <merijn> mr-: You can have a Partial monad in a total language the same way haskell can have an IO monad
05:04:47 <merijn> mr-: So have a total language and then implement infinite loops as "evaluate N steps, return a continuation" and then have the runtime repeatedly call said continuation
05:05:01 <merijn> mr-: there may be more subtle techniques too, but that is one of the options
05:05:04 <Aetherspawn> what if the runtime was not turing complete
05:05:11 <Aetherspawn> that's just cheating.
05:05:16 <merijn> Aetherspawn: Is it?
05:05:31 <merijn> Aetherspawn: Is haskell (the language) not pure when you ask the runtime to do IO?
05:05:35 <Aetherspawn> that sounded like you offhanded the turing complete bit to the runtime
05:05:44 <Aetherspawn> well, technically..
05:06:11 <merijn> Aetherspawn: Sure, the point is "your language not being Turing complete does not stop your programs from being Turing complete"
05:06:19 <merijn> Which is all programmers care about
05:06:23 <Aetherspawn> oh
05:06:48 <merijn> Just like your language being pure doesn't stop you from writing programs that do IO :)
05:08:53 <jmcarthur> a pure language can describe impure programs. a total language can describe partial programs.
05:09:49 <mr-> merijn: I also think that is cheating. I would argue that this makes your language not-total. I guess we'd first have to agree on what a total language is, though
05:10:23 <mr-> But it's a neat trick in any case. Nicely encapsulates the non-total parts
05:21:51 <merijn> mr-: So you would also argue that Haskell is not pure?
05:22:47 <saml_> yes haskell is not pure
05:23:05 <mr-> merijn: I don't know what pure means.
05:23:14 <saml_> expressions have sideeffects of memory allocation, for example
05:24:33 <merijn> mr-: Pure means that any number of invocations of the function f, when given the same arguments always return the same value
05:24:40 <merijn> saml_: No
05:24:48 <merijn> saml_: That is an implementation detail
05:24:50 <mr-> merijn: then it is not pure. (unsafe*)
05:24:56 <merijn> saml_: Haskell, the language is pure
05:25:32 <merijn> saml_: Haskell 98 didn't include unsafe* in the report, so effectively those functions are not haskell98. They are included in 2010 due to the FFI
05:25:41 <merijn> But there is SafeHaskell to enforce a pure subset
05:26:48 <mr-> I am not sure how I think "getLine" relates to purity. It surely is a (constant) value.
05:27:11 <saml_> getLine is io command
05:27:46 <merijn> getLine is a constant value, therefore pure
05:27:54 <merijn> carter: ping?
05:29:44 <mr-> I see, so you think of Haskell as something that describes a IO value, which is interpreted by the RTS. Then Haskell is pure, the RTS is not.
05:30:29 <mr-> In the same way, a total language can generate something that is interpreted by a RTS.
05:31:54 <mr-> So a language that can create strings (purely, totally) and has a RTS that pipes the result to a python-interpreter is a pure and total language
05:34:02 <merijn> mr-: That's not just how I see it, that's what haskell *is*
05:34:18 <merijn> I agree that unsafe* pokes holes into it, but that's the reason they're unsafe
05:35:00 * hackagebot temporary-rc 1.2.0.3 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-rc-1.2.0.3 (RomanCheplyaka)
05:35:04 <merijn> mr-: If you wanna go to that extreme, consider this blog post: http://conal.net/blog/posts/the-c-language-is-purely-functional
05:42:29 <mr-> Ok, one has to be careful with "The _language_ is pure/total". One may or may not include the RTS in the language
05:45:41 <merijn> mr-: Usually one does not consider the *implementation* (including RTS) when speaking of a language
05:46:07 <merijn> For example, haskell *the language* is Turing complete, however the GHC haskell implementation is not
05:46:34 <FUZxxl> Haskellers, what do you think of the Go programming language?
05:46:54 <merijn> Turing completeness requires the ability to deal with an arbitrarily big finite tape. Real implementations can only deal with tapes of a finite bounded size (due to machine limits and physical limits of the universe)
05:47:01 <_antoine_> hi
05:47:33 <merijn> mr-: The haskell language can *describe* any Turing complete program, but there may or may not be an implementation that can run it
05:47:34 <jorr> FUZxxl: Haven't used it.  The goroutine thing is something I think we have in a nice form already, and we mostly like having static types :)
05:47:50 <mr-> merijn: That distinction is very clear for purity, less so for totality, I think. I would have defined a total language to be one where every program I create terminates. But I guess that's just me :-)
05:47:57 <merijn> mr-: Compare, for example, C (for simplicity let's consider C11) which is not a Turing complete language
05:47:57 <FUZxxl> merijn: Every language that can do file IO with (limited) relative seek can handle an infinite tape if the OS supports arbitrarily large file systems.
05:48:19 <merijn> FUZxxl: Correct, but OS and file system support is not generally mandated in language specs :)
05:48:24 <FUZxxl> You use a file for tape and use relative seeking with positive / negative offsets.
05:48:41 <FUZxxl> merijn: Many languages mandate a standard library that includes file IO.
05:49:05 <merijn> FUZxxl: Sure, but they don't mandate that files can be arbitrarily sized
05:49:16 <FUZxxl> jorr: Haskell could use a better packaging scheme.
05:49:26 <FUZxxl> merijn: That's right.
05:49:45 <jorr> FUZxxl: No disagreement here!  Beautiful and fun language, but not a perfect ecosystem.
05:50:02 * hackagebot tasty-golden 2.2.1.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.1.1 (RomanCheplyaka)
05:50:13 <jorr> FUZxxl: I've dabbled a but with using nix for haskell development but haven't gotten too far.  Looks like some potential maybe.
05:50:23 <FUZxxl> jorr: package hell is a real place^Wthing
05:50:24 <merijn> mr-: The reason why C is not Turing complete is the following: 1) All C types have finite size 2) the finite void* type must be capable of addressing *EVERY* possible memory object, given the requirement that void* be a finite size there is a bounded number of objects that a C program can access
05:50:25 <Clint> roconnor: who what now?
05:50:30 <FUZxxl> jorr: I dislike nix.
05:50:38 <merijn> mr-: Therefore not all Turing complete programs can be described in C
05:50:46 <jorr> FUZxxl: But I agree, I would love if haskell could have an ecosystem as advanced as tha language itself.
05:50:57 <merijn> mr-: Although FUZxxl correctly notes that one can add Turing completeness by demanding support for unbounded files
05:51:04 <FUZxxl> nix fanboys have yet to provide me with an answer as to how nix can handle updates of core packages like the libc.
05:51:59 <mr-> merijn: Sure. Touring-completeness is overrated anyway.
05:52:01 <jorr> FUZxxl: They use a buildfarm, I think is their best answer.  I'm not an expert on how Nix works, but it seems like it could be fixable in principal.  Surely if several packages use the same shared lib that one lib can be updated and a smart enough build tool could recognize that it doesn't need to be recompiled?
05:52:08 <jorr> FUZxxl: But I'm not an expert there.
05:52:14 <merijn> mr-: I fully agree :)
05:53:41 <FUZxxl> jorr: The point is, you still need to touch every single package that imports the libc and load signatures for every such package from the server.
05:54:05 <roconnor> Clint: what?
05:54:10 <jorr> FUZxxl: yeah, agreed.  I think they do good work on solving hard problems, but there's plenty of work left to do.
05:54:10 <FUZxxl> Even if the server could provide you with a script that describes how to make the new package (e.g. by taking the old package and using it with the new libc)
05:54:24 <Clint> roconnor: you asked something about transformers
05:54:37 <jorr> (off to work)
05:55:37 <roconnor> Clint: I was curious how you are able to use the new transformers library.  I thought it would break everything.
05:55:43 <Clint> roconnor: i'm.. not?
05:56:01 <roconnor> sooo, why the new comonad library?
05:56:19 <oio`> is there a way to edit terminal edit a putStrLn output and pass it to getLine ?
05:56:42 <sagittarian> is there a way to syntactically get an enumeration that doesn't include the endpoint?
05:56:56 <sagittarian> sorry for what must be a really simple question, i mean [0..10] without the 10 at the end
05:57:12 <roconnor> I guess there is also some Typeable instance for Cokleisli
05:57:23 <lieven_> sagittarian: [a..(pred b)]
05:57:33 <merijn> > [0..(10-1)] -- >.>
05:57:34 <sagittarian> okay, thanks lieven_
05:57:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:58:04 <mr-> lieven_: why the brackets? :-)
05:58:11 <merijn> sagittarian: List comprehensions can include arbitrary expressions of the appropriate type
05:58:21 <Clint> roconnor: futureproofing, mainly
05:58:33 <lieven_> mr-: I'm still not very sure when haskell requires brackets and when not :)
05:59:22 <sagittarian> > takeWhile (\x -> x < 10) [0..]
05:59:24 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:59:41 <sagittarian> and due to laziness that's not even inefficient
05:59:45 <sagittarian> thanks everyone
06:00:00 <mizu_no_oto> Can anyone install OpenGLRaw-1.4.0.0 on 7.8?  I'm currently getting "parse error on input ‘glBeginScene’".  The file looks like this https://hackage.haskell.org/package/OpenGLRaw-1.4.0.0/docs/src/Graphics-Rendering-OpenGL-Raw-EXT-SceneMarker.html#glBeginScene  Do I just have something misconfigured?
06:00:05 <lieven_> as an extension, ghc could follow bourbaki and define [a..b], ]a..b[, ]a..b] etc
06:01:09 <sagittarian> there isn't any way to input multiline statements in ghci?
06:01:11 <mietek> How does Cabal determine which source files need to be recompiled, versus the object files in ./dist/?
06:01:14 <mietek> Is it just the last modification time?
06:01:14 <sagittarian> with where blocks etc?
06:01:36 <mr-> lieven, fun.. [a..b [++] b..c]
06:02:02 <nclarke> sagittarian: :set +m
06:02:31 <mietek> sniperliu: :{ :}
06:02:37 <nclarke> sagittarian: Or :{\n ..lines.. \n:}\n       multiline command
06:03:13 <mietek> sniperliu: sorry, bad tab
06:03:31 <sagittarian> ah so colons in front of the braces?
06:06:42 <tnks> is (read . show = id) a law or a convention?
06:07:35 <tnks> and how common is it to have laws span type classes of unrelated hierarchies?
06:09:26 <roconnor> tnks: arguably all laws are conventions :D
06:11:22 <oio`> how can in a terminal edit an output text and then re read it\?
06:12:23 <roconnor> tnks: I would say that people do not rely on the read . show law as much as laws for other classes.
06:13:15 <roconnor> but the read . show law is something I would strive to always satisfy, but I'd be willing to break it for pragmatic reasons.
06:13:28 <roconnor> an I'm not a very pragmatic programmer.
06:16:38 <lyxia> oio`: If I'm not misunderstanding you, you can redirect standard output to a file. "./myProg arg1 argn > myFile"
06:17:02 <lyxia> then "myEditor myFile" ?
06:17:23 <lyxia> I don't understand the "re read it" part though
06:18:56 <liviu10> is there any advantage in using a semaphore over a monitor?
06:24:09 <oio`> lyxia: like this http://stackoverflow.com/questions/7248076/python-how-to-modify-edit-the-string-printed-to-screen-and-read-it-back
06:25:22 <lyxia> Oh my bad I wrongly assumed your OS
06:26:20 <lyxia> wait
06:26:38 <lyxia> that's not your post right?
06:26:53 <lyxia> I also misunderstood your question anyway
06:26:56 <oio`> nope of course i want it in haskell
06:28:55 <mr-> oio`: I'm sure some of the "curses" libraries can help
06:33:32 <oio`> mr-: ok
06:49:09 <FUZxxl> Are Monads warm and fuzzy?
06:50:09 * hackagebot yesod-dsl 0.1.1.17 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.17 (TeroLaitinen)
06:52:46 <mhd> FUZxxl: Yes, except instance Monad ColdAndSpiky
06:57:28 <humanoyd> mhd: WarmT to the rescue
06:58:08 <mhd> don't forget the FuzzyKleisli
06:58:15 <mhd> But then you have an arrow
06:58:22 <arj> Is this correct: Once I am in the IO monad I cannot get out with something like runIO but unsafePerformIO ?
06:59:31 <ciaranm> arj: yes
06:59:31 <macron> arj: correct. There is no runIO, except insofar as to define runIO = unsafePerformIO.
06:59:44 <arj> ok, thanks.
07:00:27 <albeit> If I'm developing a multi-file application, and there are a set of "global" functions (like debug = flip trace) that most modules require, is it acceptable to just make a G.hs module that everything imports?
07:00:29 <merijn> arj: The trick with IO is not to think about getting things out, but getting your functions *in*
07:00:49 <arj> merijn: like liftM ?
07:00:58 <arj> like *with* liftM
07:01:10 <aninhumer> Is there such a thing as a "negative closure"? I'm thinking of unbound indentifiers introduced in a where block, and whether it would make sense to "capture" them in a returned function?
07:01:11 <merijn> arj: liftM, >>=, fmap, the other Functor/Applicative/Monad functions, yes
07:01:35 <merijn> arj: Note that IO is a Functor and Applicative to, so you can use things like fmap too
07:01:37 <arj> merijn: ok :)
07:01:38 <merijn> :t fmap
07:01:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:09:11 <poloxr> hi guys; I have a question: whats the difference between the haskell monad and the jquery monad? like haskell >>= and jquery $("#mydiv").bind(...)
07:09:47 <c_wraith> poloxr: mostly that haskell's monad actually is a mathematical monad, and jquery's is not
07:09:55 <exicer_> I keep hearing people talking about idris and other dependandly typed languages. Are there plans to add more of that kind of thing to ghc, or is the difference between them too great ?
07:10:27 <c_wraith> exicer_: the big issue is that it's not clear that full dependent typing actually makes it easier to write software.
07:10:53 <exicer_> c_wraith: Hm, well in the example they ofen use of vectors, how can it no ?
07:10:54 <c_wraith> exicer_: It seems nice at first glance, but when you try to use it, you end up spending huge amounts of time maintaining proofs
07:10:55 <exicer_> er not*
07:11:10 <exicer_> I see
07:11:23 <c_wraith> exicer_: yes, but GHC can do size-typed vectors with just GADTs
07:11:37 <exicer_> c_wraith: Oh? Are there any vector libs that do so ?
07:12:03 <exicer_> I don't know a thing about GADTs really - where would you suggest I read about them ?
07:12:11 <aninhumer> exicer_: https://hackage.haskell.org/package/fixed-vector
07:12:13 <merijn> exicer_: The wikibook is pretty good
07:12:25 <c_wraith> exicer_: (Though GHC's type-level natural support planned for 7.10 will make them look a lot more like dependently-typed examples.)
07:12:49 <exicer_> Huh, interesting
07:13:26 <c_wraith> poloxr: To be a monad in the mathematical sense, the operations on the type must guarantee that they always follow certain rules
07:13:44 <c_wraith> poloxr: those rules are called the "monad laws".  JQuery doesn't follow those rules.
07:14:14 <poloxr> alright thanks
07:14:48 <c_wraith> poloxr: of course, it's possible to write an implementation of Monad in haskell that also doesn't follow those laws..  But people will complain that your code is broken if you do. :)
07:17:56 <c_wraith> poloxr: I believe the place JQuery breaks down is that you can't nest it - it automatically flattens multiple levels of jquery wrapper
07:33:12 <hamid> i've been waiting for ghc 7.8.2 since it came out to appear in fedora's repository. do you guys usually rely on distro repositories?
07:36:11 <armlesshobo> anyone else have an issue when trying to install something from cabal and it failing because the package contains code where the preprocessor end bracket (#-}) is on a new line?
07:36:24 <supki> hamid: I grab the binaries from haskell.org/ghc/download
07:37:01 <stian> armlesshobo: I think you need to use gcc explicitly (this on a Mac?)
07:37:09 <armlesshobo> yes
07:37:22 <armlesshobo> oh
07:37:22 <armlesshobo> wait
07:37:28 <stian> armlesshobo: 10.9 right? Google GHC, 10.9 OSX - there's a lot of explanation around it.
07:37:30 <armlesshobo> there was that notice on the page i forgot about
07:37:46 <armlesshobo> right. totally forgot about that. i'll go check that out now. thank you
07:39:09 <merijn> Or look at the link in the topic :)
07:40:34 <geekosaur> um
07:43:40 <armlesshobo> merijn: wait, people actually read the topic? I thought it was there for decoration haha ;)
07:44:42 <armlesshobo> really, I wouldn't correlate the error message with Xcode 5.
07:45:08 <armlesshobo> since I was running it in command line, and I don't know what I'm doing.
07:49:55 <merijn> armlesshobo: XCode 5 is the only way to install devtools on OSX :)
07:50:23 <merijn> Well, not the *only* way, but the only sane one that doesn't require crosscompiling from another machine to your OSX machine
07:50:58 <armlesshobo> merijn: what I meant to say, was that I didn't correlate the issue I was having with Xcode 5. I don't really code with Xcode much.
08:00:29 <Philonous> Is there a language suitable for statistical computation that's less cringe-worthy than mathlab/octave and R?
08:01:32 <Sawny> Hi
08:01:47 <eizo_> Philonous: i've heard good from sage (based on python) but maybe there are even better alternatives
08:01:49 <nclarke> There's a statistics library: http://hackage.haskell.org/package/statistics
08:02:01 <nclarke> I personally like Mathematica, though it is expensive
08:03:49 <Philonous> eizo_, Never really looked into sage. Does it work well for data analysis?
08:04:02 <nclarke> Kind of depends what you want to do. I don't know of anywhere else that has such extensive support for everything as R does
08:04:47 <eizo_> i don't know sorry, maybe you could check their wiki page or ask on #sagemath
08:04:50 <Philonous> So it might be worthwhile to learn R after all
08:04:55 <macron> Philonous: we have implemented a scheme to use all of R from GHCi, so soon the less cringeworthy language you are looking for might be Haskell. ;)
08:05:17 * hackagebot epub-metadata 4.2 - Library for parsing epub document metadata  http://hackage.haskell.org/package/epub-metadata-4.2 (DinoMorelli)
08:05:19 <Sawny> I'm a bit new to haskell and have a question. How do I easly read from stdin? In C++ I can do this: int a; std::cin >> a;
08:05:19 * hackagebot digestive-functors-scotty 0.2.0.1 - Scotty backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-scotty-0.2.0.1 (MartinsMacs)
08:05:26 <Philonous> macron, That sounds amazing. Anything publicly available yet?
08:06:23 <Philonous> Sawny, import System.IO, then you can do e.g. (hGetLine stdin)
08:06:28 <macron> Philonous: unfortunately not yet - client trying to sort out lawyer issues. But if you holler loud enough, that might convince them to swtich gears. :)
08:06:43 <hakujin> Sawny: a <- getLine
08:06:56 <Sawny> Yes, but then I get the whole line
08:07:18 <Philonous> Sawny, getChar for single chars.
08:07:24 <Sawny> My file has this format "3 8 0.8" (int int float)
08:07:49 <joseph07> Sawny: the easiest thing to do would be to read the line and then use the words function to split it into parts
08:08:14 <Sawny> joseph07: Okay :/
08:08:23 <joseph07> Sawny: is that sad?
08:08:59 <Sawny> yes, I thought haskell would have something as easy as in C++ :P
08:09:45 <awestroke> Sawny: how is C++ easier?
08:09:48 <c_wraith> You could probably write a library that would handle input like that, but it's weird and not very principled.
08:09:53 <t7> awestroke: cin
08:09:56 <c_wraith> And super-stateful
08:09:57 <LordBrain> what is the easy c++ way?
08:10:25 <c_wraith> haskell prefers composing trivial operations to magic do-everything libraries.  Usually.  :)
08:10:40 <fizruk> Sawny: haskell is just a bit different: instead of reading, say, integers one by one in a cycle, you can do { s <- getLine; return (map read (words s)) }
08:10:55 <Philonous> readData = do [a,b,c] <- words <$> readLine; return ((read a, read b, read c) :: (Integer, Integer, Double))
08:11:36 <fizruk> Sawny: i.e. you’re working with the *whole* input, and then *all* words, to get *all* integers (or any other Read’able values)
08:11:39 <LordBrain> the functions and the IO are lazy Sawny, so you're not doing multiple passes here,
08:13:29 <awestroke> > let (a:b:c:_) = words "1 2 3.3" in (read a, read b, read c) :: (Int, Int, Float)
08:13:30 <lambdabot>  (1,2,3.3)
08:14:17 <LordBrain> how could c++ do that easier?
08:14:17 <albeit> When cabal complains it can not find a module, is there any way to make it install all the dependencies?
08:14:42 <nclarke> cabal install --only-deps
08:15:41 <Sawny> hmm, thx philonous and awestroke
08:15:46 <bennofs> nclarke: what cabal version does that require? I'm using 1.20, and it requires --only-dependencies
08:16:05 <nclarke> bennofs: Oh, I may have got the command slightly wrong
08:16:13 <nclarke> I think --only-dep probably works, then
08:16:25 <nclarke> There is a shorter version, but it may not have the 's' on the end
08:16:33 <monochrom> the input format "4 5 6" is easier in C++ because it is just "cin >> a >> b >> c". however, I argue that it is a red herring. "4 5 6" is an input format for toy programs. for real input formats, you want at least CSV, which means you will just use an elaborate parser (homemade or 3rd-party), and then C++ is just as hard as Haskell.
08:17:02 <nclarke> bennofs: albeit: Yes, sorry, 'cabal install --only-dep'
08:17:15 <Viaken> I thought we weren't supposed to treat cabal as a package manager?
08:17:16 <bennofs> nclarke: oh thanks, always searched for the shorter version :)
08:17:20 <albeit> nclarke: Tried that (for statistics), but during install it then complains that it can't find math-functions....
08:18:13 <albeit> And then math-functions complains about no "erf" package
08:18:14 <albeit> Argh
08:18:28 <fizruk> albeit: tried cabal update?
08:18:42 <nclarke> Hmm, I've never had a problem with 'statistics'
08:18:47 <albeit> fizruk: No, I'll see what happens
08:19:20 <fizruk> albeit: it could be that cabal locally has no information on those packages (or their needed versions)
08:20:35 <albeit> fizruk: Same issue again. This all stemmed from trying to install profiling libraries for criterion, which has led me down this scary path
08:20:54 <nclarke> It says it can't find it?
08:21:05 <nclarke> Or that it can't satisfy some dependency resolution?
08:21:08 <albeit> Perhaps you haven't installed the profiling libraries for package `math-functions-0.1.5.2'?
08:21:27 <fizruk> albeit: at this point you should probably paste exact cabal output
08:21:27 <albeit> nclarke: Not sure which one that means
08:21:57 <nclarke> albeit: As fizruk says, post the exact output and we can see
08:22:00 <albeit> Okay
08:22:16 <monochrom> put complete verbatim output on lpaste.net
08:22:22 <albeit> http://lpaste.net/103880
08:22:39 <albeit> That was after running "cabal install statistics --reinstall"
08:23:00 <monochrom> did you obtain math-functions by cabal-install as well?
08:23:00 <albeit> And I have my .cabal/config set to install profiling libraries
08:23:14 <albeit> monochrom: I never explicitly installed it, no.
08:23:24 <thrakcattack> quit
08:23:28 <monochrom> ok, how did you obtain it?
08:23:53 <albeit> monochrom: On Ubuntu, not 100% sure, but I think it was through "apt-get install haskell-platform"
08:24:06 <monochrom> no, haskell-platfom does not include it.
08:24:19 <albeit> Then haskell-platform-prof?
08:24:33 <nclarke> Ah - will cabal install profiling libs for dependencies which already exist by default?
08:24:35 <monochrom> sigh. is my writing so unclear?
08:24:48 <albeit> I've never explicitly done anything with math-functions, so I really don't know where it came from.
08:24:49 <monochrom> haskell-platform does not bring you math-functions period.
08:25:19 * hackagebot yesod-markdown 0.8.5 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.5 (PatrickBrisbin)
08:25:20 <nclarke> albeit: Try in a sandbox, see if that works
08:25:27 <albeit> Okay
08:25:35 <nclarke> Make a new directory, type 'cabal sandbox init', then 'cabal install statistics;
08:25:42 <nclarke> See whether that makes a difference
08:26:50 <monochrom> I'm going to gamble. 51% chance you obtained it from cabal-install indirectly. another 51% chance you obtained it before you set things in .cabal/config. setting things in .cabal/config does not help with packages obtained before. you need to read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
08:27:18 <monochrom> err, more specifically, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
08:27:19 <albeit> Ha, cabal sandbox is an unrecognized command. cabal is version 1.16.0
08:27:35 <nclarke> Ah. Update cabal first? :-)
08:27:38 <fizruk> albeit: cabal install cabal-install
08:27:39 <albeit> monochrom: Thanks! I'll give it a read
08:27:48 <nclarke> cabal install cabal-install and make sure that ~/.cabal/bin is in your PATH
08:28:00 <monochrom> cabal sandbox would make the problem "disappear" because it ignores the --user database altogether. it is not a solution. the package in --user is still unusuable.
08:28:22 <nclarke> monochrom: Not necessarily unusable. Just lacking profiling libs
08:28:35 <monochrom> yes yes yes the context is profiling, OK?
08:28:53 <nclarke> And putting everything in sandboxes is a better solution than fixing (and maintaining) a single user DB
08:29:09 <monochrom> I agree to disagree
08:29:24 <nclarke> Fair enough
08:29:34 <albeit> Can I just nuke my the user cabal database?
08:29:37 <nclarke> Personally, the only thing I have in ~/.cabal is cabal itself
08:29:45 <monochrom> yes
08:29:46 <nclarke> albeit: Yes, certainly
08:30:32 <albeit> Man, just gotta say this channel is a godsend, way better than stuggling for a long time trying to Google my way out
08:30:52 <Philonous> albeit, The thing you want to delete is ~/.ghc though, not ~/.cabal
08:31:12 <nclarke> I tend to delete both of them
08:31:17 <nclarke> Feels cleaner :-)
08:32:04 <Philonous> Well, it gets rid of outdated package downloads, but you also delete your cabal config. And that's a pita.
08:32:26 <nclarke> That's true
08:32:32 <nclarke> Can save that off
08:34:20 <monochrom> I'm going to be Dijkstra-style on this. you know that haskell is ready for "prime time" when most haskellers prefer a hack (sandboxing) that just reduces a problem without understanding to doing correct things that eliminates the problem with understanding.
08:34:21 <awestroke> Philonous: What's in a cabal config? What do people configure anyway?
08:34:36 <albeit> Okay once I've saved my cabal config file, nuked .ghc and .cabal, I reinstall haskell-platform(-prof), and then reinstall the cabal packages I need. Sound right?
08:34:49 <nclarke> No need to reinstall haskell-platform
08:35:18 <merijn> monochrom: Word, I've only really needed a sandbox for working on development versions of, say, pandoc that I don't want to collide with my installed version for using
08:35:19 <monochrom> if you obtained haskell-platform from ubuntu, it is not even in the user db
08:37:35 <nclarke> monochrom: The 'correct' solution involves a proper package database and correctly tracking dependencies. It certainly doesn't involve hand-curating a single set of dependencies that will work for every piece of software you're working on
08:37:45 <monochrom> but you still should obtain haskell-platform-prof from ubuntu
08:38:34 <monochrom> no, the correct solution in this context (get profiling) is that cabal-install should default to enable profiling in the first place.
08:39:00 <monochrom> cabal-install defaults want you to never write in Haskell!
08:40:04 <monochrom> and the correct solution to general cabal hell outside this context is defaulting to permitting one version only per lib
08:40:23 <monochrom> or at least, a correct solution.
08:40:37 <albeit> Nuked .ghc and .cabal, cabal was reverted to 1.16.0, ran cabal install cabal-install, then it couldn't find module Prelude. Is that not installed by default?
08:40:44 <nclarke> monochrom: That's an absurd restriction. It solves the problem, but only by creating a whole load more problems
08:41:05 <monochrom> note how lately the sandboxing part offers "freeze" which permits one version only. why no do it to --user altogether as well?
08:41:38 <nclarke> And in this context, enabling profiling by default isn't a solution, since it's dealing with a repo that was created with profiling turned off
08:41:55 <monochrom> what repo?
08:42:07 <nclarke> The pkg db
08:42:19 <nclarke> Sorry, guess repo isn't really the right word
08:42:41 <monochrom> the pkg db was created with profiling turned off because cabal has wrong defaults.
08:42:59 <nclarke> But asserting that doesn't solve *this* problem
08:43:04 <nclarke> Even if you're right
08:43:49 <nclarke> And even then, this is really just another incarnation of the wider problem - that package identity is not tracked properly, making it dangerous to try to build against libraries which have previously been registered in the database
08:44:21 <nclarke> Which is precisely what sandboxes try to solve - admittedly not in the ideal way, but still in a way that fixes these problems
08:45:21 * hackagebot newtype-generics 0.4.0.1 - A typeclass and set of functions for working with newtypes, with generics support.  http://hackage.haskell.org/package/newtype-generics-0.4.0.1 (jcristovao)
08:47:41 <monochrom> albeit: do you have haskell-platform-prof from ubuntu?
08:47:55 <albeit> Yes
08:48:09 <albeit> Install ghc-dynamic now, was suggested on stack-overflow
08:52:07 <FUZxxl> It's funny how my answer to this stack overflow question keeps getting upvoted every once in a while
08:52:10 <FUZxxl> http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators/7747115#7747115
08:53:19 <Sawny> Whoo. I'm now done with the program (Im new to haskell): http://pastebin.com/DGxxZ722
08:53:23 <Sawny> Is there anything I can improve / rewrite?
08:55:37 <monochrom> people are really obsessed with pronouncing program code aka being a modem for the phone voice line.
08:56:51 <quchen> monochrom: Proper pronounciation makes phone support much easier.
08:57:00 <thrakcattack> Sawny: looks good so far, try to import your functions explicitly and not the whole module
08:57:04 <felixn> monochrom: jeez these people, who go outside and actually talk to people, they're not true nerds
08:57:49 <bennofs> Sawny: You could use Double instead of Float. http://www.haskell.org/haskellwiki/Performance/Floating_point
08:57:50 <glguy> Ugh, and why are they such a loosely defined group? I never know who *people* are.
08:58:13 <monochrom> felixn: when discussing code, you already have the code displayed on screen or paper. you can point and say "this formula".
08:58:14 <thrakcattack> this is important for bigger projects so you know where your functions come from
08:58:42 <felixn> monochrom: I do?!
08:58:56 <Sawny> thrakcattack: How do I specify to only import getLine?
08:58:57 <felixn> monochrom: have you been watching me? >_>
08:59:18 <glguy> At work we pass code between developers via oral tradition
08:59:21 <thrakcattack> import System.IO (getLine)
08:59:28 <glguy> It's better than silly tools like git for revision control
08:59:30 <nclarke> Sawny import System.IO (getLine)
08:59:33 <Sawny> thx
08:59:34 <monochrom> you can also make up names just for that discussion. those names need not be standard names, they're just for that session. there is no need to expect standard names.
08:59:42 <monochrom> and yes I have been watching you
08:59:43 <felixn> monochrom: lol that's so funny to think about... "you know, this thing *points* I don't know what the hell it's called"
09:00:37 * glguy has pictures of common foods so that he can point to things he wants to eat when everyone is discussion lunch plans
09:01:42 <monochrom> you can call it John for a discussion session
09:01:48 <nclarke> glguy: Sing, sweet muse, of the implementation of main, son of the Main module, which bought the result of IO () upon the world...
09:08:31 <FUZxxl> sxsxs
09:08:35 <FUZxxl>  -
09:15:54 <blastrock> Hello
09:16:08 <blastrock> Is this the place for netwire questions?
09:18:19 <pavonia> blastrock: Are you talking about the netwire Haskell package?
09:18:25 <blastrock> Yes
09:18:34 <c_wraith> blastrock: yeah, the netwire author is often around here
09:18:59 <blastrock> Ok here I go then: is netwire 5 considered ready to be used?
09:19:06 <blastrock> I found that many functions have disapeared
09:19:26 <blastrock> and the operator <|> is now broken (I found that --> works fine)
09:22:50 <absence> blastrock: i don't remember if i got around to upgrading my toy project to netwire 5, but at any rate it's not source compatible with netwire 4 iirc
09:23:21 <blastrock> Yes I know that and I upgraded mine :P
09:24:08 <c_wraith> blastrock: in what way does <|> not work?  Wire still has an Alternative instance
09:24:11 <blastrock> I coded myself the functions which have disapeared and now I can't find enough documentation to understand exactly how things work
09:24:27 <absence> blastrock: have you found this page? http://hub.darcs.net/ertes/netwire
09:24:41 <blastrock> In netwire 4, <|> evaluated the left wire and if it inhibited, it evaluated the right part
09:24:55 <blastrock> now it evaluates both parts and takes the left result if it did not inhibit
09:25:12 <add^_> "cabal install cabal-install" doesn't seem to update my cabal..
09:25:33 <c_wraith> add^_: it puts the new one in ~/.cabal/bin by default.  Your path probably isn't looking there
09:25:42 <add^_> ah
09:25:46 <add^_> thanks for the tip
09:25:50 <blastrock> Yes I looked at that absence, it seems to be the only tutorial available on the internet :P
09:26:59 <ew0000> so, I have my haskell program and I want to profile it
09:27:09 <XrXr> :t null
09:27:10 <lambdabot> [a] -> Bool
09:27:52 <absence> blastrock: yes, i ended up reading a lot of source code when i tried it :/ it's been a while since i worked with it much though, sorry i can't remember details
09:27:57 <ew0000> but I get a "Perhaps you haven't installed the profiling libraries for package `fgl-5.5.0.1'?"
09:28:15 <blastrock> Hum I see :(
09:28:17 <ew0000> is there a way to make cabal install all the packages with profile support?
09:28:37 <blastrock> Well, for my current problem, do you happen to have an example of Wire using the s parameter ?
09:28:49 <bitonic> set `library-profiling' and `executable-profiling' to True
09:28:49 <blastrock> Seems related to Sessions, but I don't get how the whole thing work
09:28:54 <bitonic> ew0000: ^^^
09:28:58 <bitonic> in the cabal config file
09:29:10 <absence> blastrock: stick around though, mm_freak (the author) isn't here right now but will show up sooner or later :)
09:29:30 <blastrock> Hum okay, thank you ^^
09:29:44 <bitonic> ew0000: note that you will have to recompile everything, and compiling things will take twice the time.  personally I use a separate hsenv for profiling libraries
09:29:46 <blastrock> Do you know in what timezone mm_freak is? ^^
09:29:47 <bitonic> and use it only when needed
09:30:24 <pavonia> @localtime mm_freak
09:30:43 <pavonia> Hhm
09:30:59 <pavonia> > 1+1
09:31:01 <lambdabot>  2
09:31:01 <bitonic> pavonia: probably in Germany.
09:31:10 <absence> blastrock: not sure about timezone
09:31:29 <pavonia> Ah right, I recall him saying "Güten Täg" this morning :)
09:32:05 <blastrock> Okay thank you all :)
09:33:42 <XrXr> :t Maybe
09:33:43 <lambdabot> Not in scope: data constructor ‘Maybe’
09:33:45 <XrXr> D:
09:33:53 <glguy> :t Just
09:33:54 <lambdabot> a -> Maybe a
09:34:03 <glguy> Maybe is a *Type* Constructor
09:34:04 <hamid> :k Maybe
09:34:05 <lambdabot> * -> *
09:34:10 <XrXr> ohh
09:34:15 <ew0000> I'm not sure if all words in german have a " in the first syllabe
09:34:18 <ew0000> xD
09:36:04 <absence> blastrock: what about the s parameter btw?
09:38:51 <absence> blastrock: seems i used (Timed Double ()) for that, and passed (Timed somevalue ()) when stepping
09:39:07 <mizu_no_oto> Can anyone install OpenGLRaw-1.4.0.0 on 7.8?  I'm currently getting "parse error on input ‘glBeginScene’".  The file looks like this https://hackage.haskell.org/package/OpenGLRaw-1.4.0.0/docs/src/Graphics-Rendering-OpenGL-Raw-EXT-SceneMarker.html#glBeginScene  Do I just have something misconfigured?
09:39:37 <absence> blastrock: my wire type was completely pure though, not sure how it would look if you want to query system clock or something
09:41:01 <blastrock> And do you use that value absence ?
09:41:44 <predator117> mizu_no_oto: works for me on 7.8
09:41:57 <mizu_no_oto> predator117: thanks
09:42:01 <int-e> mizu_no_oto: at a guess, it doesn't like your C preprocessor
09:42:01 <absence> blastrock: it's used by the integral wire
09:42:29 <mizu_no_oto> int-e: How should I look into that?
09:42:36 <absence> blastrock: so yes, indirectly
09:42:49 <blastrock> absence: and what is the value of that s in the wire? the number of seconds that passed since the last call?
09:43:09 <absence> blastrock: yes
09:43:31 <absence> blastrock: doesn't have to be seconds of course, but it's the delta, not absolute time
09:43:39 <blastrock> absence: and where is that specified? Does netwire automatically deduces that because it's a Timed type?
09:44:38 <absence> blastrock: i couldn't find it specified anywhere, i looked at the integral implementation :(
09:45:03 <absence> blastrock: the calculations treat it as a delta, and the variable is called dt
09:45:28 * hackagebot hi 0.0.8.1 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.8.1 (DaisukeFujimura)
09:46:26 <XrXr> Is there a better way of sometimes returning nothing other than using Maybe? Having to unwrap Just is pretty annoying
09:47:02 <absence> blastrock: if you make your own HasTime instance it seems you can use the dtime function to generate a delta though, then your representation can be anything i suppose. haven't tried it out myself
09:47:09 <blastrock> absence: looking at integral implemantation it seems to me that the time *must* be a real, I wanted to use Int for that
09:47:49 <mizu_no_oto> XrXr: You can work on Maybe without having to manually unwrap Just
09:48:02 <absence> blastrock: you're right about that. HasTime's time type is constrained to Real
09:48:05 <mizu_no_oto> XrXr: using functions like fmap
09:48:10 <hakujin> XrXr: are you using multiple Maybe values that you're unwrapping?
09:48:24 <XrXr> hakujin: no
09:48:37 <blastrock> absence: so I guess that s parameter can't help me :(
09:49:15 <mizu_no_oto> XrXr: Alternatively, you need to bake a "not there" value into your datatype.  data Foo = Bar | Baz | NotThere, but that's really worse than using Maybe
09:49:43 <absence> blastrock: well you can just convert the int to real when you call stepWire. not extremely elegant i guess :) why does it have to be int though?
09:49:54 <XrXr> :/ pretty complicated to do something simple. I guess I will live with it
09:50:09 <mizu_no_oto> XrXr: What do you want to do?
09:50:26 <mizu_no_oto> There might be an easier way, that you don't know about yet
09:50:45 <blastrock> absence: It's just that I don't need anything more than Int and calling round every time I need to use it is even less elegant :P
09:51:11 <blastrock> absence: It seems like a source of bugs to me :P
09:51:12 <XrXr> mizu_no_oto: I just want my function to return a nothing sometime.
09:51:51 <hakujin> XrXr: Maybe forces you to handle the failure condition instead of ignoring it and crossing your fingers
09:52:12 <hakujin> which is exactly what you want when writing good software
09:52:27 <XrXr> hakujin: nothing in my function is a valid response
09:52:28 <ew0000> XrXr, or you can just use a fromJust
09:52:38 <ew0000> :t fromJust
09:52:39 <lambdabot> Maybe a -> a
09:52:45 <absence> blastrock: i understand. i don't think e.g. integral would work very well with integer time though, so i guess that's the reason for the constraint
09:52:53 <ew0000> it might explode later, though
09:53:03 <XrXr> thanks ew0000 :) thats pretty useful
09:53:23 <hakujin> fromJust is usually a bad idea
09:53:26 <ew0000> it is useful, but it is pretty bad advice
09:53:33 <ew0000> remember that
09:53:40 <ew0000> yeah
09:53:51 <mizu_no_oto> XrXr: maybe is much more useful, generally
09:53:55 <mizu_no_oto> :t maybe
09:53:56 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:54:22 <mizu_no_oto> > maybe 0 (* 5) (Just 1)
09:54:24 <lambdabot>  5
09:54:30 <jfischoff> man the new transformer version is really causing havok
09:54:36 <mizu_no_oto> > maybe 0 (* 5) Nothing
09:54:37 <lambdabot>  0
09:54:47 <absence> blastrock: hm, i guess it does assume the time is seconds
09:55:29 <ew0000> listen to the sound of the water
09:55:40 <ironChicken> I know there's a String -> IO CString function; but is there a String -> CString function? Alternatively, what's the simplest way to pass a CString argument to a foreign function?
09:55:51 <XrXr> ok. Maybe has something to do with monads, I haven't learned about monads yet :) thank you all
09:55:59 <ew0000> no, no
09:56:03 <blastrock> absence: It actually would I think. Suppose the time is Int and dtime is always = 1, integral would just count from x to infinity
09:56:16 <ew0000> maybe function gives you a "default" value
09:56:19 <ew0000> for the Nothing
09:56:39 <ew0000> you would call yourFunction
09:56:41 <ew0000> if you call
09:56:53 <XrXr> I'm talking about the Maybe typeclass :)
09:56:57 <ew0000> maybe 0 yourFunction
09:57:16 <blastrock> absence: which would be fine to me I guess, I wrote a wire which does the same thing
09:57:16 <ew0000> 0 will be the "default" value if you receive a nothing in yourFunction
09:58:14 <albeit> My program is using a ton of space and memory in one function which is called a lot, but it seems to be the source of some lazy evaluation problems... function is: "insertLookup = Map.insertLookupWithKey (\_ a _ -> a)"
09:58:48 <albeit> Full definition: http://lpaste.net/103883
09:59:01 <absence> blastrock: another option is to pass the int as input to the wire network
09:59:09 <albeit> Should I be forcing some evaluation somewhere in that function?
09:59:35 <blastrock> absence: that's what I do right now :P
09:59:56 <blastrock> absence: I just thought that using that s parameter would let me use more of the standard functions and write less code ^^
10:02:08 <blastrock> absence: thanks for your help anyway :) I'll ask mm_freak why time has to be a real when I see him though ^^
10:04:38 <absence> blastrock: i'm starting to wonder about that myself. just read a few of the functions that require HasTime, and there's nothing that would require reals yet
10:07:24 <blastrock> absence: haha, glad I'm not the only one :P
10:07:35 <Polarina> blastrock, all modules under FRP.Netwire require HasTime to be a real number, for obvious reasons.
10:07:57 <blastrock> Polarina: they're not obvious to me :(
10:08:20 <Polarina> blastrock, take for example the 'integrate' function. How would you do integration without real numbers?
10:08:54 <blastrock> As it does now, it would work with integers too
10:09:27 <Polarina> blastrock, another example is 'avgFps'. How would you represent the average without real numbers?
10:10:25 <jorr> With rational numbers?
10:10:36 <blastrock> Polarina: that wouldn't be frame per seconds but frame per unit of time or something like that
10:11:09 <jorr> I appologize for being pedantic, but you're not really working with irrational numbers, just some certain precision approximations.
10:11:44 <ironChicken> ah ok, i think i can do it with withCString
10:12:02 <blastrock> Polarina: all you need is / and +, they work on Int, and that isInfinite seems to be workaroundable
10:12:57 <ew0000> can someone help-me with this?
10:12:58 <ew0000> http://pastie.org/9159887
10:13:06 <ew0000> I'm trying to instal package algebra
10:13:10 <ew0000> wich requires mtl
10:13:26 <ew0000> I have mtl installed already. it installed just fine
10:13:37 <ew0000> but when I try to install algebra, it gets installed again and fails
10:13:48 <alpounet> this precise version fails
10:13:56 <alpounet> can you do ghc-pkg list mtl
10:18:10 <ew0000> yup, just a momment
10:19:07 <ew0000> another thing, meanwhile
10:19:13 <ew0000> I installed cabal from my distro
10:19:21 <ew0000> then I installed cabal from cabal
10:19:25 <ew0000> $ cabal install cabal-install
10:19:45 <ew0000> but I'm not using the cabal I updated
10:19:51 <ew0000> $ which cabal
10:20:01 <ew0000>  /usr/bin/cabal
10:20:15 <ew0000> is this a problem?
10:20:26 <jfischoff> you need to add ~/.cabal/bin to your path … probably, but that is not the problem
10:23:17 <kazagistar> inspired by a post about counting sort in C, I decided I wanted to try it in haskell (to learn STUArray and some new abstract types and such): http://lpaste.net/103885 .... could I get any style tips/simplification advice, and how might I make this generic in the return type (maybe using the unfoldable library or something?)
10:24:18 <jle`> kazagistar: uncurry (flip replicate)
10:24:22 <jle`> but tha'ts just me
10:24:35 <ajf> Argh
10:24:38 <ajf> I can’t install Hastr
10:24:41 <ajf> *Haste
10:24:43 <ew0000> http://pastie.org/9159929
10:24:45 <ew0000> yup
10:24:48 <ajf> because it relies on a websocket lib
10:24:52 <ew0000> it seems to require a different version
10:24:58 <ajf> which relies on a dependency that doesn’t compile
10:24:59 <ajf> :<
10:25:07 <ew0000> what can I do?
10:25:12 <kazagistar> jle`: yeah, I am still not sure which way I prefer, but you are probably right, $ is a bit ikky
10:26:04 <jle`> kazagistar: you can make incCount into one line but how you have it is probably more readable
10:26:49 <jle`> if it were me i might have just used forM_ and inlined incCount
10:27:07 <kazagistar> jle`: how exactly? I made it a separate function to save type annotations on newArray, but it does seem like it is very verbose for very little benefit...
10:27:15 <jfischoff> ew0000: you need to figure out what versions of packages your installed version was installed with, and what versions it is trying to use for the new mtl. So start with `ghc-pkg list mtl`
10:27:20 <jle`> but maybe pulling it out is better for readability
10:27:32 <jle`> kazagistar: how to make it one line?
10:27:55 <jfischoff> then you will cabal install -v3 and try to make sense of the solver spew
10:27:59 <jle`> writeArray counts index . (+1) <$> readArray counts index
10:28:06 <jle`> (maybe not a good idea :) )
10:28:17 <ReinH> jfischoff: one week :)
10:28:41 <jfischoff> ReinH: yeah, one more week of worrying ;)
10:29:16 <ReinH> jfischoff: it'll be fine :)
10:29:23 <jfischoff> :)
10:29:23 <XrXr> How can I check the precedence of an operator using a command?
10:29:37 <jle`> XrXr: :i
10:29:43 <jle`> on ghci
10:29:45 <zgredzik> I'm trying to implement a function converting between my custom types that belong to a specific type class http://lpaste.net/103884 - thing is I can't pattern match against those different types, can anyone give me a hint as to what is wrong with this example and/or how could I make this work?
10:29:46 <kazagistar> jle`: ah, right. Also, if I inlined it, where would I disambiguate newArray?
10:29:51 <XrXr> jle`: thanks :)
10:29:54 <ew0000> The MTL I have installed is new
10:29:56 <ew0000> I just installed it
10:30:04 <ew0000> algebra needs an older version
10:30:43 <jfischoff> ew0000: can you tell us the version that you have?
10:31:34 <jfischoff> ew0000: is there a reason you are not running `ghc-pkg list mtl`?
10:32:20 <jle`> kazagistar: hm, i'n not sure; i'd hav to play around with it myself a bit
10:33:31 <ew0000> I ran it
10:33:31 <ew0000> xD
10:33:34 <ew0000> it is in the pasty
10:33:36 <ew0000> sorry
10:33:53 <ew0000> mtl-2.1.2 mtl-2.2.0.1
10:34:01 <ew0000> these are installed
10:34:08 <ew0000> algebra needs mtl 2.0
10:34:35 <ajf> I really wanted to write my app in Haste
10:34:39 <ajf> But Haste can’t install
10:34:41 <kazagistar> so, for my input I have a Foldable of Ix, is there a similar generic container I could use as my result type? I was thinking of just making t be Traversable, and then doing a input-ignoring fmap of some kind, but that seems wrong
10:34:45 <ajf> So… goddamnit, back to JS
10:41:35 <Philonous> zgredzik, No, you can't pattern match on Types. Since toRGB is polymorphic in it's first argument you can only use the class constraint you put on it. So you could have toRGB i = ImageRGB (i ^. channels)
10:43:17 <fragamus> I'm using pipes extensively to do a lot of transformations and I find myself doing a lot of "plumbing" of context info that is not needed for some transformations but then at the end of the pipline I need it
10:43:24 <fragamus> Is there any idiom you guys are using for this
10:43:51 <fragamus> everything I do is ugly
10:44:25 <ajf> fragamus: for context info, couldn’t you make some sort of thing that’d go in the middle of your pipe that takes some context and passes it onto the next thing?
10:44:55 <fragamus> yeah
10:45:10 <fragamus> some sort of pipe wrapper
10:45:35 * hackagebot Gamgine 0.2 - Some kind of game library or set of utilities.  http://hackage.haskell.org/package/Gamgine-0.2 (DanielTrstenjak)
10:45:48 <ReinH> jfischoff: I'm excited to finally meet a bunch of haskellers I talk to in person :)
10:46:51 <jfischoff> ReinH: yeah that’s the best part
10:47:07 <Shockk> I have a really quick question - I'm building a library with cabal, with --enable-shared, and I was wondering if there's any way to have the output .so file be redirected to a different path than dist/build/libHSlibrary-name-x.x.x.x-ghcx.x.x.so, after running `cabal build`?
10:47:27 <jfischoff> maybe we can entice bos to come ….
10:47:40 <ReinH> jfischoff: probably not :)
10:47:49 <ReinH> but worth a shot
10:47:52 <jfischoff> yeah :)
10:48:24 <zgredzik> Philonous: thank you :)
10:48:55 <geekosaur> Shockk, for what reason?
10:49:36 <zgredzik> Philonous: so there is no way for me to avoid unnecessary computations when supplying an ImageRGB to the function converting some Image to that color space with the class and types defined like that?
10:50:36 * hackagebot layers-game 0.3 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.3 (DanielTrstenjak)
10:50:38 <kazagistar> I just realized my countingSort wont work, because finding not all values of type Ix fit between minimum and maximum...
10:51:20 <Philonous> zgredzik, As it stands, no computation is taking place. Adding and stripping newtype constructors is always free and the superfluous function calls will probably be optimized away.
10:52:13 <ReinH> jfischoff: I just realized I'm recording a Haskell Cast episode while I'm there on Sunday :)
10:52:23 <Shockk> geekosaur: I'm running `cabal build` as part of my build process and I need the .so file to be copied/moved to a specific directory for plugins which are loaded into a program
10:52:25 <jfischoff> oh cool
10:52:49 <kazagistar> is there any way to build an array that will fit some collection of indexes?
10:54:42 <geekosaur> Shockk, thing is, ghc .so-s are kinda not well suited to that kind of use: (1) you need the .hi as well, even (perhaps especially) for runtime loading (2) that cross-module inlining stuff means that you're essentially moving something from a regime where it has something approximating appropriate versioning to one where it is not sufficiently versioned and can break without warning due to upgrades
10:55:09 * geekosaur is of the opinion that ghc shared objects are a really big problem looking for the chance to blow up in people's faces
10:55:36 * hackagebot layers-game 0.3.1 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.3.1 (DanielTrstenjak)
10:55:38 * hackagebot VKHS 0.5.0 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.5.0 (SergeyMironov)
10:56:29 <Shockk> I've certainly had lots of problems trying to do what I'm trying to do with this shared library
10:57:20 <kazagistar> it works for the simple Ix since they are a subtype of Ord, but it seems like it fails for tuples. Given [(0,0) (1,-1), (2,1)], I need to find ((0,-1), (2, 1)), but (minimum, maximum) gives me ((0,0), (2, 1)), which is smaller
10:58:06 <Shockk> maybe there's a better way to do it that someone here knows of -- I'm trying to link a haskell module with a c source and with a static library, into a shared object, and then load that as a plugin for weechat
10:58:16 <zgredzik> Philonous: hmm, the thing is the conversion is done by looking up channels with specific names (like "rgb.r", "rgb.g", so on) and I'm afraid without knowing the type of the image a priori I can't be sure that such channels exist (in an earlier version I had one Image type, I wanted to differentiate them to have the information what channels I can be expecting)
10:58:48 <zgredzik> Philonous: and I'm not sure in such case the optimisation you're talking about will take place
10:59:40 <pavonia> Kazagistar: How would you like to calculate minimum and maximum from that list?
11:00:17 <pavonia> :t (minimumBy, maximumBy)
11:00:18 <lambdabot> ((a -> a -> Ordering) -> [a] -> a, (a1 -> a1 -> Ordering) -> [a1] -> a1)
11:00:26 <pavonia> there are these, btw
11:00:55 <ReinH> kazagistar: Ord isn't supposed to create new values
11:00:59 <kazagistar> pavonia: I don't want to change the min and max functions, but maybe I just want an "unrange :: [a] -> (a, a)" function added to Ix
11:01:17 <tanmaig> Hi all! How do I export functions from a module, where the functions themselves have been imported from another module? Say Module1 has 'aFunc' and Module2 imports Module1, but should export 'aFunc' as is too.
11:01:27 <kazagistar> a better name would probably be "bound"
11:02:22 <jle`> tanmaig: you can export functions from imported modules just fine, but you can't import two functions with the same name
11:02:26 <ReinH> pavonia: this isn't a minimum/maximum calculation
11:02:43 <pavonia> Kazagistar: What would that function do, I can't see it from the example you gave
11:02:46 <ReinH> this is a bounding box calculation
11:03:10 <jle`> tanmaig: if you want to import both Module1's aFunc and Module2's aFunc, you have to give Module1.aFunc a new name
11:03:11 <ReinH> kazagistar: wants the top-left and bottom-right coordinates of a bounding box for the list of coords
11:03:14 <tanmaig> jle´: How do I do the former? export functions from imported modules?
11:03:22 <ReinH> Ord won't give you that
11:03:23 <jle`> tanmaig: just like normal exporting :)
11:03:33 <ReinH> kazagistar: what are you actually trying to do? Maybe this is an XY problem
11:03:33 <jle`> tanmaig: just list the name in your exports list
11:03:58 <tanmaig> jle´: The thing is I don't have an export list. I'm exporting everything.
11:03:59 <jle`> you can also import all exported things from an imported module by adding "module Module1" to your export list
11:04:37 <jle`> tanmaig: ah. well then i think it should already be exported then?
11:04:43 <joelteon> What's the portability string for 'GHC only'?
11:04:54 <joelteon> or is "portability" not standardized?
11:04:59 <Philonous> zgredzik, Well, things I can think of: Move as mus of the work into the type class so the instance for ImageRGB can just skip it, you could reify the types you are working with (add a tag of some sort) and then you could actually pattern match on the type (Or rather: the runtime representation), you could try to design the system with rewrite rules so that conversions cancel each other out or you could just ignore the i
11:05:00 <Philonous> ssue and hope that it won't be a performance bottleneck anyway.
11:05:11 <jle`> if you want to export Module1.aFunc from Module2 under a different name, you can just set aFunc1 = Module1.aFunc in your Module2
11:05:13 <Philonous> as much of the work*
11:05:21 <jle`> but you can't export two functions with the same name
11:05:23 <kazagistar> ReinH: I wrote a countingSort http://lpaste.net/103885 but it is broken for tuple instances of Ix, and I want to fix it without losing generality
11:05:37 <tanmaig> jle`: Ah. Got it! Thanks!
11:06:08 <jle`> "set" should be "define"
11:06:58 <kazagistar> ReinH: and, given only the Ix constaint, I can't fix it, so my next idea is to find or build a better typeclass that allows construction of a bounding box (even though that seems like it could be an Ix thing)
11:06:59 <ReinH> kazagistar: how is it broken for tuple instances of Ix?
11:07:25 <pavonia> > let (as, bs) = unzip [(0,0) (1,-1), (2,1)] in ((minimum as, maximum as), (minimum bs, maximum bs))
11:07:27 <lambdabot>  Couldn't match expected type ‘(t2, t3) -> (a, b)’
11:07:27 <lambdabot>              with actual type ‘(t0, t1)’
11:07:27 <lambdabot>  Relevant bindings include
11:07:27 <lambdabot>    as :: [a] (bound at <interactive>:1:6)
11:07:27 <lambdabot>    bs :: [b] (bound at <interactive>:1:10)
11:07:45 <ReinH> kazagistar: countingSort is supposed to count indexes that don't exist? I'm confused.
11:08:18 <jle`> ReinH: well he's using a sparse array to implement it
11:08:23 <pavonia> Huh, what's wrong with that?
11:08:32 <jle`> pavonia: your list literals are missing the commas
11:08:41 <pavonia> Oh
11:08:42 <jle`> or, just one
11:08:54 <ReinH> jle`: sure, but you don't need a bounding box, you just need range to work properly
11:08:55 <Philonous> Can someone recommend a text on the theory of continued fractions?
11:08:55 <pavonia> > let (as, bs) = unzip [(0,0), (1,-1), (2,1)] in ((minimum as, maximum as), (minimum bs, maximum bs))
11:08:56 <lambdabot>  ((0,2),(-1,1))
11:09:06 <ew0000> jfischoff, did it. I had to do a cabal install adjunctions-4.0.2
11:09:12 <ew0000> adjunctions-4.0.3 is broken
11:10:03 <joelteon> can I put linebreaks in haddock code blocks without the linebreaks being preserved?
11:10:06 <kazagistar> pavonia: that works for 2-tuples, but I want the generality of anything Ix, or as close as possible
11:10:13 <tanmaig> Is importing a module, and then doing a qualified import on the same module a bad thing?
11:10:24 <ew0000> But I don/t really know why
11:10:26 <pavonia> Kazagistar: Oh, I see
11:10:35 <ReinH> pavonia: you want ((minimum as, minimum bs), (maximum as, maximum bs)) iinm
11:10:38 * hackagebot confsolve 0.5 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.5 (DanielTrstenjak)
11:10:40 <jle`> tanmaig: it's normal to some extent
11:10:58 <jle`> tanmaig: a lot of people do import Data.Map (Map); import qualified Data.Map as M
11:11:13 <jle`> to qualify all of the functions, yet be able to use Map unqualified in type signatures
11:11:29 <ReinH> kazagistar: why doesn't what you have work?
11:11:35 <tanmaig> jle`:  I'm doing : import Data.Map ; import qualified Data.Map as M
11:11:36 <pavonia> ReinH: Yes, you're right
11:11:43 <kazagistar> pavonia: my current idea is to build a "Boxable" that lets you build a bounding box
11:11:54 <tanmaig> jle`: Does that have an impact on program size/performance?
11:12:11 <tanmaig> jle`: *A significant impact?
11:12:22 <jle`> tanmaig: it presumably doesn't, because all distinction goes away at the linking stage, i think
11:12:39 <jle`> tanmaig: what you are doing though is equivalent to import Data.Map is M
11:12:44 <kazagistar> ReinH: because (minimum list, maximum list) does not give me a bounding box, so I will attempt to stick things into out-of-range indexes in my STUArray
11:12:51 <jle`> er, import Data.Map as M
11:13:16 <pavonia> Kazagistar: Every Ix is also an Ord, so my solution should work for any Ix too (though it's not very efficient)
11:13:24 <zgredzik> Philonous: thanks a lot I'll think about it, can you suggest any theory-related topics I should look into? I'm relatively new to haskell and I'd appreaciate any leads that might take me to a valid solution
11:13:24 <jle`> (that is not as normal)
11:13:39 <ReinH> pavonia: index by the index?
11:14:36 <ReinH> er
11:14:42 <ReinH> Yeah, you can't.
11:14:58 <ReinH> kazagistar: why not just use a Map?
11:15:07 <kazagistar> pavonia: no, because of the case I mentioned, [(0,0), (1,-1), (2,1)], the minimum is (0,0), not (0,-1), because minimum must select from the list given
11:15:51 <Philonous> zgredzik, I can't think of anything, I'm afraid.
11:15:52 <pavonia> Ah, yeah :S
11:16:14 <zgredzik> Philonous: thanks anyways :)
11:17:00 <lally> Hi, any cabal-dev (or new sandbox) users here?
11:17:30 <ReinH> > (1,-1) `elem` range ((0,0),(2,1)) -- sad face
11:17:32 <lambdabot>  False
11:18:25 <kazagistar> ReinH: if Map has O(1) amortized insert/delete/modify then I could, but I quite wanted the fast constants in front :P
11:19:13 <ReinH> It's O(log n), which should be close enough for most n
11:20:23 <kazagistar> ReinH: but the whole point of countingSort is to be an O(n) sort that just uses a stupid amount of memory
11:20:24 <ReinH> Also Array isn't very good at sparse, so there might be a tradeoff
11:20:34 <ReinH> alrighty
11:21:36 <kazagistar> it is supposed to be used in cases where you have maybe a few thousand unique items, and a list of hundreds of thousands of these items
11:23:04 <ReinH> Ah I thought there was something in diagrams for AABBs http://projects.haskell.org/diagrams/haddock/Diagrams-BoundingBox.html
11:30:40 * hackagebot data-lens 2.10.5 - Used to be Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.10.5 (RussellOConnor)
11:30:41 <osa1> can anyone help me compiling GHC 7.6.3 with GHC 7.8.2 :-) it's currently failing with http://lpaste.net/103888 . I can't use pre-compiled 64bit Linux binaries because of libgmp version mismatch (my system has version 10, distributed GHC needs 3)
11:30:42 * hackagebot data-lens-fd 2.0.5 - Lenses  http://hackage.haskell.org/package/data-lens-fd-2.0.5 (RussellOConnor)
11:31:51 <geekosaur> osa1, I think it is not generally supported to build an older version with a newer
11:32:05 <geekosaur> because e.g. the newer may be more strict about some things
11:33:04 <quchen> osa1: A dirty fix to get around this is downloading the binaries, creating a temporary softlink to your GMP lib and name it .3, bootstrap the compiler with itself
11:33:15 <dwcook> osa1: Are you using a Debian-based system? I recall 3 and 10 being effectively the same there. I've just made an appropriate symlink and had it work.
11:33:26 <quchen> The newly compiled compiler should be linked against the newest version of libgmp, if I remember correctly
11:33:53 <osa1> dwcook: opensuse 13.1
11:34:00 <osa1> not debian-based
11:34:02 <dwcook> Okay, not sure then.
11:34:25 <quchen> I wouldn't recommend keeping the softlink around as dwcook mentioned. I have no idea what could happen if you have semi-broken-library links like that.
11:34:27 <osa1> quchen: how do you know that libgmp won't be used while bootstrapping?
11:35:30 <quchen> I would know by testing it ;-)
11:36:10 <dwcook> Oh, libgmp3-dev on my system is a dummy package that just installs libgmp-dev, which in turn depends on libgmp10. :P
11:36:28 <osa1> hm
11:36:30 <dwcook> It might be worth checking the appropriate package descriptions – That's what I did to find out.
11:36:58 <osa1> okay let me try symlinking libgmp3
11:38:00 <dwcook> Well, I'm not using OpenSUSE. I'm using Linux Mint, which is Debian-based. I think checking the packages first would be a good idea.
11:39:09 <ew0000> so, I can now run a cabal-dev build sucessfuly
11:39:15 <ew0000> but I want to pass a -prof
11:39:21 <ew0000> how d I do that?
11:39:26 <roconnor> Clint: done
11:39:30 <Clint> thank you
11:39:37 <Sawny> Hi again, I have one more haskell program now: http://pastebin.com/dNMenbAM  :)
11:39:39 <Sawny> What things can I improve?
11:40:13 <Sawny> I guess that I can improve the sum function, but I'm not sure.
11:41:39 <absence> Sawny: you can use foldl' instead of foldl at least
11:41:51 <dwcook> Hmm, you're just summing a two-element list? Why not (+)?
11:42:23 <Sawny> absence: thx, I will look up that function
11:43:05 <Sawny> dwcook: I need to multiply every 2:nd element with 3 before I sum it, and every 2+1 element with *7 before I sum
11:43:26 <absence> Sawny: it does the same, it's just strict so you don't get a stack overflow for large arrays. you'll almost always want foldl' instead of foldl
11:43:34 <dwcook> I get that, but you have code of the form: sum [a, b]. My suggestion: a + b
11:43:35 <kazagistar> can anyone come up with an instance of Ix i for which a "bound :: [i] -> (i, i) -- finds valid index bounds given a list of desired indexes" could not be defined, in a library or otherwise? All the default instances would be easy.
11:43:50 <jle`> Sawny: foldl (\acc x -> acc + x*3) is the same as sum . map (*3)
11:44:28 <jle`> except lazier
11:44:33 <johnw> Sawny: also, be sure to check for the case when n <= 0
11:44:53 <Sawny> jle`: oh.. that's correct. Thx.
11:45:25 <ReinH> Cale: ping
11:45:31 <osa1> installation with symlinked libgmp3 worked
11:45:38 <osa1> let's see if GHC works as expected :P
11:45:48 <eizo> also the same as total = sum (every 2 numbers) * 3 + sum (every 2 (tail numbers)) * 7
11:46:38 <osa1> now is there a way to tell cabal to use a specific GHC executable?
11:46:40 <eizo> (you don't have to multiply every element, you can multiply only their sum)
11:46:52 <dwcook> osa1: set your PATH perhaps
11:46:58 <osa1> okay
11:47:46 <dwcook> PATH=… cabal …
11:48:16 <osa1> I just did that and `ghc` is now points to 7.6.3. cabal is now installing the app to a sandbox, I hope it's using ghc 7.6.3
11:48:33 <tremon> what's the shortest notation for zipping [a] with [a->b] and getting [b]? zipWith and a lambda?
11:48:49 <jle`> tremon: why the lambda?
11:48:59 <dwcook> That's the ZipList (<*>)
11:49:05 <bennofs> osa1: there is also -w
11:49:13 <bennofs> osa1: so, -w /path/to/ghc
11:49:20 <jle`> also flip ($)
11:49:36 <jle`> or if hou are willing to flip the order of your zipWIth arguments, zipWith ($)
11:49:58 <tremon> I didn't see another way to actually apply the function
11:50:20 <jle`> > zipWith ($) [(*2), (+3)] [2,3]
11:50:22 <lambdabot>  [4,6]
11:50:36 <jle`> zipWith ($) is the same as zipWith id, but the former is probably more readable
11:50:49 <tremon> ah. that's easy :) thanks
11:52:13 <ajf> https://github.com/valderman/haste-compiler/issues/180
11:52:15 <ajf> :(
11:53:23 <eizo> > ZipList [(*2), (+3)] <$> ZipList [2,3]
11:53:24 <lambdabot>  Couldn't match expected type ‘a0 -> b’
11:53:24 <lambdabot>              with actual type ‘Control.Applicative.ZipList (a1 -> a1)’
11:53:55 <dwcook> eizo: (<*>) not (<$>)
11:54:14 <dwcook> > ZipList [(*2), (+3)] <*> ZipList [2,3]
11:54:15 <lambdabot>  ZipList {getZipList = [4,6]}
11:54:54 <dwcook> Though of course the zipWith ($) is much nicer unless you're doing more complex things with the ZipLists
11:55:48 <eizo> yes makes sense; is it normal that my ghci doesn't have a show instance for ZipList a?
11:56:00 <frc> hi!
11:56:22 <frc> !list
11:56:22 <monochrom> frc: http://okmij.org/ftp
11:56:26 <dwcook> o/
11:56:30 <Corey> frc: Enough already!
11:56:45 <osa1> I guess cabal now uses GHC 7.6.3 but I also need to point it lib folder of GHC 7.6.3, how can I do that? is there an env variable for looking for .sos?
11:57:02 <osa1> maybe lD_LIBRARY_PATH
11:57:19 <dwcook> Does cabal really need to know about that?
11:57:20 <ReinH> monochrom: So that whole "Haskell does TCO" argument was that the pattern matching stack will use a goto to optimize the case where the function being applied is fully saturated and has already been seen.
11:57:55 <Jefffrey> Morning
11:58:00 <jle`> hm
11:58:02 <ReinH> Not that expressions with tail recursive structure will be optimized. I mean. Ok.
11:58:15 <jle`> > pure (+3) <*> ZipList [1,2,3]
11:58:17 <lambdabot>  ZipList {getZipList = [4,5,6]}
11:58:18 <osa1> dwcook: it finally worked!
11:58:21 <osa1> dwcook: yes
11:58:36 <ReinH> jle`: what does pure do for ZipList?
11:58:43 <osa1> I had to set LD_LIBRARY_PATH
11:58:53 <dwcook> > pure () :: ZipList [()]
11:58:55 <lambdabot>  Couldn't match expected type ‘[()]’ with actual type ‘()’
11:58:58 <dwcook> > pure () :: ZipList ()
11:59:00 <lambdabot>  ZipList {getZipList = [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
11:59:09 <ReinH> dwcook: I was wondering if jle` knew :p
11:59:12 <dwcook> Ah.
11:59:25 <ReinH> dwcook: I've read the applicative paper :p
11:59:31 <jle`> ReinH: :P
11:59:43 <vamega> Hi.
11:59:45 <dwcook> I had actually forgotten for a moment myself. I just didn't realize it was an instructive moment.
11:59:49 <vamega> I'm getting a parse error with the file http://lpaste.net/103889
11:59:57 <vamega> It says error on input let.
11:59:58 <ReinH> dwcook: I'm not sure it was.
12:00:08 <ReinH> jle` probably knew
12:00:18 <vamega> Which unfortunately is not descriptive enough to really help me figure out whats wrong.
12:00:21 <ReinH> But I like to ask people.
12:00:49 <ReinH> vamega: can you include the error please?
12:01:07 <dwcook> vamega: I'm not sure, but I think the wheres must be indented past the beginning of the associated binding definition.
12:01:07 <_root_> Greetings 0/
12:01:28 <vamega> ReinH: src/Main.hs:85:3: parse error on input `let'
12:02:06 <vamega> dwcook, I think the where is indented past the let.
12:02:18 <vamega> On line 82 and line 86.
12:02:21 <_root_>  I have two files both in haskell in one directory. I want to include one in the other. How should I do that?
12:02:24 <vamega> Not sure if you're referring to something else.
12:02:28 <dwcook> vamega: no, past the beginning of the identifier.
12:02:44 <ReinH> let foo <-- the associated binding starts at `f', not `l'
12:03:06 <bitemyapp> _root_: are they in a Cabal project?
12:03:41 <bitemyapp> _root_: this file imports a sibling, but it's a Cabal project. https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Types/Instances.hs
12:04:04 <vamega> dwcook, that was it.
12:04:04 <vamega> Thanks
12:04:19 <bennofs> _root_: http://learnyouahaskell.com/modules#making-our-own-modules
12:04:58 <_root_> bitemyapp, ok let me check that
12:04:59 <_root_> bennofs, Thanks Sir;
12:05:48 <absence> bennofs: is there a trick to finding # links like that other than reading the page source?
12:06:03 <bennofs> absence: idk, I read the page source too :p
12:06:32 <bennofs> absence: You could find them here: http://learnyouahaskell.com/chapters
12:06:54 <absence> banister: ah, clever ;)
12:11:18 <XrXr> can someone look at this and tell me if the formatting looks okay? http://lpaste.net/7442969575672512512
12:11:57 <c_wraith> XrXr: the formatting looks ok, unless you're mixing tabs and spaces
12:12:11 <skypers> huhu
12:12:13 <skypers> what is [TH]
12:12:21 <c_wraith> XrXr: however, the guard in line 9 has a type error
12:12:21 <skypers> at the end of a module compilation line in cabal build?
12:12:29 <skypers> does it stand for TemplateHaskell?
12:12:34 <c_wraith> XrXr: even is a function, it needs an argument
12:12:51 <c_wraith> XrXr: oh, whoops.  You shadowed it. I didn't see that.
12:12:57 <bennofs> skypers: I think it means that it was recompiled because of TH
12:12:58 <XrXr> c_wraith: it isn't a function its just a bool
12:13:09 <skypers> oh ok
12:13:16 <c_wraith> XrXr: it's worth an effort to not shadow names defined in Prelude. :)
12:13:29 <c_wraith> Well, names exported by Prelude
12:17:26 <XrXr_> oh didn't realize even was a function, I will fix that :)
12:17:36 <c_wraith> > even 33
12:17:37 <lambdabot>  False
12:18:05 <c_wraith> XrXr_: anyway, the indenting *looks* fine.  I'd guess the problem is mixed tabs and spaces.
12:18:55 <XrXr_> should I try to line up all the equals? like from line 8 and on
12:20:14 <c_wraith> XrXr_: No need to try to line up = in different contexts.  That is, 8, 9, and 12 maybe you could align.  And 15-18 could be aligned. But don't put any effort into aligning those sections with each other.
12:20:46 <XrXr_> I see. Thanks c_wraith :)
12:20:53 * absence uses a variable-width font :p
12:24:32 <SrPx> Does anyone have the paper for this concepct? http://richardwalker.squarespace.com/tech/2009/10/5/omgwtfbbq-if-conc-trees-replace-cons-lists-then-mapreduce-ca.html That is, using conc-trees instead of lists for a friendlier parallel fold?  I remember there is a paper somewhere with further explanation and some algorithms, but I can't find it!!
12:39:07 <Ariel__> hi! :)
12:39:21 <XrXr> hi Ariel__
12:41:18 <Ariel__> Let´s say we have a type (data T = T Int Double) and I want to create a T with an m Int... is it possible ?
12:42:36 <d3lxa> can I use readsTime without defaultTimeLocale which require to import Locale, thus haskell98, etc etc?
12:42:59 <pavonia> Ariel__: No. What is m in your case?
12:43:56 <vamega> Hi.
12:43:58 <c_wraith> Ariel__: it might be possible to create an m T with an m Int.  If m happens to be an instance of Functor, for instance.
12:44:04 <amarks> How can I hardcode a string into my dynamiclog ppExtras?  How do I make a hardcoded string have type "X (Maybe String)"?
12:44:11 <vamega> I'm running unto a compilation error I can't seem to understand.
12:44:12 <vamega> http://lpaste.net/103889
12:44:19 <vamega> Tha'ts the pastebin with teh code
12:44:35 <bennofs> What dependencies may I assume in a ./Setup.hs? Is it fine to assume that all package dependencies have been installed?
12:45:23 <vamega> I've annotated it with the compilation issue.
12:46:01 <Ariel__> hmm,,, I'm using Repa, more precisely I do folldAllP on an array, which returns me an Int inside a monad. I would then return a T inside a monad built from the Int inside a monad and the double.
12:46:39 <geekosaur> sounds like you need to learn about do notation and/or (>>=)
12:47:02 <Kaidelong> elerea vs reactive-banana vs netwire
12:47:10 <Kaidelong> any tips?
12:47:21 <Ariel__> geekosaur: yeah I've been reading a lot about it, but I'm still confused.
12:49:05 <pavonia> vamega: You probably mean "emptyHistData = repeat $ HistData 0 0"
12:50:14 <vamega> pavonia, yeah I do.
12:50:18 <vamega> I hadn't yet hit that issue.
12:50:23 <vamega> But you're absolutely right
12:50:39 <vamega> Right now
12:50:39 <benbangert> is there some way to echo a string in ghci without adding another layer of quotes?
12:51:00 <vamega> benbangert: putStrln
12:51:23 <vamega> That should take a string and print it without quotes
12:51:29 <benbangert> Ahhh, yup, thanks!
12:52:46 <vamega> I'm looking to find how I can get that fmap working
12:52:50 <vamega> In line 82
12:53:00 <vamega> What I think is happening
12:53:07 <vamega> Is that it's using the fmap for the list type
12:53:18 <vamega> The last fmap in that line
12:53:26 <vamega> (fmap Set.toList setDiff)
12:53:34 <vamega> Is using the fmap from the Either instnace
12:54:22 <vamega> since setDiff is Either String Set ByteString
12:54:35 <vamega> but the other map
12:54:37 <vamega> *fmap
12:54:58 <vamega> Is trying to use a list for some reason
12:55:02 <vamega> That I haven't yet understood.
12:55:11 <vamega> Would love an explanation of how I can pick an implementation
12:55:18 <vamega> Or just advice on why what I'm doing is wrong
12:55:34 <vamega> (I think it's wrong, considering that it's gotten stupidly complicated.)
12:57:31 <ReinH> vamega: what is the type of setDiff?
12:57:57 <XrXr2> x/nick XrXr2
12:58:35 <vamega> I think it's Either Set ByteString
12:58:41 <vamega> Sorry
12:58:47 <vamega> Either String Set ByteString
12:59:18 <vamega> If i understand it right
12:59:36 <vamega> keySet1 and keySet2 have a type of Either String Set ByteString
12:59:47 <vamega> And thus setDiff has the same type
13:00:44 <ReinH> vamega: so which applicative is being used?
13:01:04 <vamega> ReinH: well in the definition of set Diff I'm saying
13:01:10 <vamega> setDiff = Set.difference <$> keySet1 <*> keySet2
13:01:23 <ReinH> right, so which instance of (<*>) is being used?
13:01:44 <vamega> So it's using the Either implementation of <*>
13:01:48 <ReinH> yep
13:01:53 <vamega> Great that's what I thought.
13:01:57 <ReinH> what about paddedData1?
13:02:03 <ReinH> what type is data1?
13:02:18 <ReinH> what type is the expression after the (<*>)?
13:02:18 <NinjaPenguin> !testcase
13:02:23 <NinjaPenguin> Wrong channel.
13:02:54 <ReinH> vamega: that if you extract it to the where clause you can give it a type to check your reasoning :)
13:02:55 <vamega> data1 is Either String Map ByteString HistData
13:03:11 <dwcook> NinjaPenguin: your test case shall be (). Good luck
13:03:13 <vamega> brb
13:03:16 <ReinH> vamega: you need a few more parens, but yes. It's Either String (Map ByteString HistData)
13:03:30 <ReinH> er
13:03:46 <NinjaPenguin> dwcook: That's not a testcase though!
13:04:03 <dwcook> NinjaPenguin: you can perform tests on it, can't you?
13:04:22 <ReinH> yep
13:04:28 <NinjaPenguin> dwcook: But testcase is a small piece of code explaining your problem.
13:04:46 <dwcook> NinjaPenguin: my problem is my program does nothing useful, it evaluates to ()
13:04:52 <dwcook> How to solve?
13:05:11 <dwcook> :P
13:05:22 <NinjaPenguin> dwcook: Have you tried closing it and starting again?
13:05:28 <ReinH> lol
13:05:41 <dwcook> Good idea, I'll go ahead and reboot my computer—Nay, the universe!
13:07:51 <ReinH> dwcook: incoming Class Z event http://tvtropes.org/pmwiki/pmwiki.php/ApocalypseHow/ClassZ
13:08:21 <ReinH> Hmm, can you reboot one universe without rebooting the others?
13:08:22 <blastrock> Is there a way to define a type like type Func = Integral t => t -> t ?
13:12:01 <tromp_> :t neg
13:12:02 <lambdabot> Not in scope: ‘neg’
13:12:05 <joelteon> can someone explain to me why this compiles in 7.6.3 but not 7.8.2? http://lpaste.net/103895
13:12:10 <joelteon> err, other way around
13:12:13 <joelteon> 7.8.2 but not 7.6.3
13:12:23 <tromp_> :t (+1)
13:12:24 <Kaidelong> I'm going to arbitrarily use Netwire
13:12:24 <lambdabot> Num a => a -> a
13:12:27 <dwcook> ReinH: why did you link me to TVTropes? :(
13:12:29 <Kaidelong> someone stop me if I am making a mistake
13:12:34 <dwcook> I had hopes and dreams
13:12:34 <ReinH> dwcook: I'm so sorry
13:12:58 <joelteon> I'm guessing this bug is not to be fixed in GHC 7.6
13:13:58 <vamega> back
13:14:11 <vamega> Sorry had to take a call/
13:14:20 <vamega> Didn't mean to leave right when I was getting somewhere.
13:17:18 <Kaidelong> okay well
13:17:39 <Kaidelong> I'm now a netwire framework developer, wondering if anyone knows good resources for that
13:18:14 <ReinH> vamega: no worries. Ok, what's the type of the expression to the right of the <*> on line 81?
13:19:54 <vamega> Either String (Map ByteString HistData)
13:19:56 <vamega> ?
13:20:06 <vamega> No thats not right
13:21:08 <ReinH> vamega: well, Map.fromList wants to construct a Map
13:21:26 <vamega> Right.
13:21:30 <vamega> So I think I need to do
13:22:05 <vamega> emptyMap = fmap (Map.fromList) (fmap (flip zip emptyHistData) (fmap Set.toList setDiff))
13:22:21 <ReinH> vamega: you can change the $ into a <$>
13:22:45 <ReinH> but this might actually be easier to write with do notation
13:23:21 <vamega> Where?
13:23:34 <ReinH> everywhere? :)
13:23:41 <vamega> lol
13:24:00 <ReinH> vamega: start by extracting expressions like (Map.fromList $ fmap (flip zip emptyHistData) (fmap Set.toList setDiff))
13:24:09 <ReinH> into the where clauses and giving them names
13:24:14 <ReinH> try to give everything explicit type annotations
13:25:05 <vamega> Working on it.
13:25:09 <vamega> Thanks ReinH.
13:25:12 <ReinH> vamega: np
13:26:41 <vamega> ReinH.
13:26:48 <ReinH> vamega.
13:26:49 <bitemyapp> vamega.
13:26:57 <vamega> I'm getting an error saying expected type `Set.Map k0 a0'
13:27:03 <albeit> If I have a (lazy) list of items, and I want to perform a stateful computation on each, where the state may be modified by each item, and the new state is used for the next item, what structure should I use?
13:27:04 <ReinH> vamega: well fix it :)
13:27:04 <vamega> Sorry didn't mean to call you out.
13:27:11 <bitemyapp> vamega: I did.
13:27:17 <vamega> Where could I get a style called Set.Map?
13:27:25 <vamega> :)
13:27:59 <ReinH> vamega: did you qualify Data.Map as Set?
13:28:20 <albeit> Nvm, should have looked at documentation first.
13:28:33 <vamega> Yeah, I just found a huge bug.
13:28:35 <vamega> Ouch.
13:28:45 <ReinH> vamega: :) try not to get too far ahead of the type system
13:28:49 <ReinH> it'll keep you honest if you let it
13:29:06 <hakujin> albeit: something like a fold or mapAccumL probably
13:29:22 <ReinH> albeit: what did you find? :)
13:30:49 <jle`> ReinH: I had a moment where i realized that if pure for ZipList was the same as for [], fmap would not be (<*>) . pure
13:31:00 <albeit> Well I thought mapState was what I wanted, but its not. I think just folding over the items, where the accumulator is the state is best.
13:31:02 <jle`> ReinH: so i wanted to make sure that the ZipList people got it right :)
13:32:02 <ReinH> jle`: :)
13:32:22 <eswar> I have question regarding typeclasses and types. The Eq type class has a method (==) :: a -> a -> Bool, yet 'Bool' type has an instance declaration of Eq. How does GHC resolve this?
13:33:07 <ReinH> eswar: it unifies as Bool -> Bool -> Bool :)
13:33:08 <benzrf> eswar: what's wrong with it?
13:33:36 <ReinH> eswar: why do you think GHC would have an issue resolving it?
13:34:08 <vanila> eswar, Eq for Int  is (==) :: Int -> Int -> Bool,   for [Char] it's  (==) :: [Char] -> [Char] -> Bool  and for Bool it's (==) :: Bool -> Bool -> Bool
13:34:25 <vanila> so there's no problem , just instantiate 'a' with the type
13:34:27 <eswar> ReinH: how can Eq be defined when Bool requires (==) to be defined?
13:34:40 <ReinH> eswar: Bool doesn't require (==) to be defined.
13:34:53 <ReinH> (==) is defined for Bool
13:35:33 <eswar> ah ok, so can one define instances long after a data definition?
13:36:21 <ReinH> eswar: Ah, you think there's a circular dependency
13:36:25 <tremon> eswar: (==) for bool can be implemented with a very simple (3-clause) truth table, it's not a recursive definition if that's your line of though
13:36:33 <jle`> eswar: the instances have nothing to do with data instances
13:36:44 <tremon> +t
13:37:09 <jle`> eswar: (==) is unrelated to Bool, except that one of its functions returns one
13:37:32 <eswar> ReinH: yes, I am thinking of circular dependency.
13:37:36 <jle`> but it could return Int and be 0 for False and 1 for True, or return an Ordering
13:37:42 <eswar> tremon: thanks for clearing that up
13:38:05 <jle`> ah. well Haskell has no problem with recursive definitions, as long as the types can unify
13:38:20 <jle`> have you ever written mutually recursive functions?
13:38:34 <eswar> jle`: no
13:38:44 <vanila> this isn't mutally recursive
13:38:53 <jle`> this isn't
13:39:01 <vanila> note that pattern matching can be used to implement an equality test without involving Eq at all
13:39:07 <jle`> but "circular anything" usually isn't a problem
13:39:26 <ReinH> jle`: Well, the prelude goes to some lengths to prevent circular imports
13:39:56 <jle`> ah
13:40:09 * jle` rethinks
13:40:26 <ReinH> They describe it a bit here https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.lhs
13:40:52 <eswar> vanila: I can see the possibility for the Bool because of two values. Is this kind of definition possible for other types? (that do not contain finite possible values)
13:41:01 <monochrom> eswar: what circular dependency do you have in mind? depending on details, it may be resolvable, or even non-existent
13:41:16 <ReinH> eswar: So the answer is partly "you don't need (==) to define (==)" and partly "GHC structures its modules carefully so the definitions are in the right order"
13:42:06 <ReinH> eswar: data Color = Red | Green | Blue; instance Eq where Red == Red = True; Red == _ = False...
13:42:11 <carter> @ask merjin you rang?
13:42:11 <lambdabot> Consider it noted.
13:42:25 <jle`> data Bool = False | True
13:42:41 <monochrom> for example "how do I write Eq for Bool" does not have a circular dependency. just use pattern matching, like jle` says
13:43:03 <eswar> ah ok, thank you very much
13:43:14 <jle`> I think credit should go somewhere else for that statement
13:43:33 <wolftune> hey folks, I need help understanding why the heck everyone keeps talking about IO Monad and IO as having issues with PURITY and SIDE-EFFECTS when everything in Haskell is pure still even including IO Monad…
13:44:11 <monochrom> OK! s/jle`/#haskell :)
13:44:14 <jle`> wolftune: unfortunately chosen terminology
13:44:18 <wolftune> I'm working on improving the Wikibook, and the IO chapter is all focused on how IO solves the impurity problem, but that whole framing is wrong…
13:44:26 <jle`> some words stick.
13:44:34 <dwcook> wolftune: it's easy to misunderstand what's meant when you say something is pure – evaluation of expressions is pure, but execution of IO is not.
13:44:36 <wolftune> and I'm new to Haskell, but I know enough to know that this is annoyingly wrong
13:44:40 <u-ou> what would be a good way to implement init as a fold?
13:44:56 <monochrom> wolftune: read my http://www.vex.net/~trebla/haskell/IO.xhtml , it is way better.
13:44:59 <vanila> > init "abc"
13:45:01 <lambdabot>  "ab"
13:45:04 <wolftune> dwcook: but execution of a Haskell program isn't itself Haskell!
13:45:06 <vanila> hmm...
13:45:22 <ReinH> eswar: https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Types.hs and https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Classes.hs
13:45:29 <dwcook> monochrom: oh hey, I was looking for that weeks ago and couldn't find it searching the web. Bookmarked!
13:45:31 <wolftune> monochrom: ok, thanks
13:45:46 <ReinH> eswar: basically GHC defines the types first and then the classes
13:45:55 * hackagebot hcltest 0.3.1 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.1 (BennoFuenfstueck)
13:46:12 <ReinH> the instance for Bool is actually derived since it's just a sum type
13:46:35 <ReinH> (this uses the StandaloneDeriving extension)
13:46:35 <eswar> ReinH: Thanks, that makes sense.
13:46:41 <vanila> > let cons x ([],_) = ([x],[]) ; cons x (ys,ys') = (x:ys,x:ys') in snd . foldr cons ([],[]) $ "abc"
13:46:42 <lambdabot>  "ab"
13:46:49 <wolftune> so, I'll keep working to understand for myself what is REALLY happening, but right now I'm trying to understand why others keep doing these weird explanations
13:46:50 <eswar> ReinH: what is a sum type?
13:47:06 <ReinH> eswar: a type of the form data A = B | C
13:47:18 <vanila> I think there's a way that doesn't use pairs?
13:47:35 <ReinH> it can also be parameterized like data Either a b = Left a | Right b
13:47:51 <eswar> ReinH: why are they called the sum types?
13:48:08 <ReinH> eswar: for data A = B | C, how many values are there?
13:48:28 <eswar> ReinH: 2, ah ok, I see your point
13:48:53 <ReinH> data Prod = Prod Bool Bool is a product type. How many possible values are there?
13:48:54 <eswar> ReinH: thanks for the info
13:49:02 <dwcook> (Actually three, but one of them can usually be ignored)
13:49:16 <ReinH> dwcook: I'm fast and loose over here ;)
13:49:23 <ReinH> but morally correct(TM)
13:49:35 <eswar> ReinH: 4, or 6 if dwcook is right
13:49:43 <dwcook> ReinH: oh I don't take issue with it. I just think it's worth clarifying sometimes
13:49:51 <ReinH> eswar: dwcook is referring to bottom, which is an inhabitant of all types.
13:49:56 <jle`> wolftune: it is unfortunate, but c'est la vie. but if you see a problem in the world, you are welcome to be the change you want to see in the world  :)
13:50:07 <ReinH> so a value of type A can be B, C, or undefined
13:50:08 <jfischoff> 5 with bottom. All bottoms are the same
13:50:13 <monochrom> this is why I wrote my I/O tutorial
13:50:28 <ReinH> monochrom: what is?
13:50:30 <jle`> dwcook: would bottom be considered one single value?
13:50:42 <ReinH> up to something something yes
13:50:52 <pavonia> jfischoff: bottom /= Prod bottom bottom
13:50:55 <monochrom> to solve a problem I see in the world. the problem of wrong explanations
13:51:03 <dwcook> jle`: you could say that, but you could also say that every type has a bottom
13:51:12 <jfischoff> pavonia: true my bad
13:51:35 <dwcook> So really "one single value" is unclear here :)
13:51:49 <monochrom> actually, the problem of (easy but wrong explanations) and (right but difficult explanations)
13:51:53 <vamega> Thanks everyone, I think I've mostly got this working.
13:52:01 <ReinH> monochrom: ah, yes.
13:52:10 <vamega> And as a side effect I understand functors a lot better
13:52:16 <ReinH> monochrom: I try to prefer right but difficult explanations
13:52:19 <ReinH> vamega: :)
13:52:19 <vamega> especially of how I can use functors to work with Monads.
13:52:21 <dwcook> Easy but wrong explanations abound (Monads are wrapped values!)
13:52:32 <ReinH> dwcook: oh my god *rage*
13:52:44 <vamega> Seperate question though.
13:52:55 <monochrom> I do admit I exploit the time we live in, i.e., people already know about callbacks, in making my right explanation easy.
13:53:07 <vamega> Is this a valid syntax for a pattern destructing in a lambda
13:53:09 <monochrom> 15 years ago I could not pull that trick
13:53:10 <vamega> \(className, (HistData instances bytes)) -> printf "%s\t%n\t%s" className instances bytes
13:53:11 <dwcook> monochrom: no shame in that.
13:53:11 <ReinH> monochrom: there's always some ambient context :)
13:53:31 <ReinH> monochrom: you're also exploiting things like a mathematical framework that provides a notion of equivalence...
13:53:43 <joelteon> Has anyone here filed a bug for hlint? How responsive were they?
13:54:05 <pavonia> vamega: Yes
13:54:06 <monochrom> the beauty of it is that if you replace my "callback" by "continuation" then it is really what's going on.
13:54:07 <u-ou> should I use map snd or snd . unzip?
13:54:29 <ReinH> monochrom: would you have preferred I explain bottoms first?
13:54:35 <ReinH> monochrom: I'd prefer to make better tradeoffs there
13:54:50 <monochrom> hmm, what do you use bottoms for?
13:55:13 <ReinH> monochrom: you weren't talking about my explanation of sum types?
13:55:31 <monochrom> my great tutorial on denotational semantics is at the front of my TODO queue, by the way :)
13:55:48 <ReinH> monochrom: denotational semantics is just a functor. Next.
13:55:52 <monochrom> sum types may omit the bottom at the beginning
13:56:03 <ReinH> monochrom: ok :)
13:56:13 <vamega> Hmm, how do I get Text.Printf to work with ByteStrings?
13:56:39 <dwcook> monochrom:  "TODO" is good word for such a queue in both English and Spanish because in English it stands for things that need doing and in Spanish it means "everything"
13:56:44 <dwcook> +a
13:56:48 <jfischoff> how evil: instance IsString (IO ExitCode) where fromString = system
13:56:50 <jfischoff> :)
13:57:03 <monochrom> I mean, most often when I define and use a sum type, my usage involves no bottom, provably. so it is alright to omit bottom sometimes.
13:57:08 <bitemyapp> jfischoff: damn.
13:57:13 <vamega> Do I first convert it to a string
13:57:31 <jfischoff> I do miss `cmd` from ruby though
13:57:49 <Ancient> What is an example of a popular open-source haskell utility or program?
13:57:57 <jfischoff> pandoc
13:57:58 <itsmonkt1stic> pandoc
13:58:17 <Maior> Ancient: xmonad
13:58:32 <jfischoff> what is a good library for recursive directory globs?
13:59:01 <epta> @hackage filemanip ?
13:59:01 <lambdabot> http://hackage.haskell.org/package/filemanip ?
13:59:02 <acowley> bos's
13:59:23 <wolftune> jle`: indeed, I'm trying to be the change, I just need to understand WHY people are getting things screwed up currently in order to know how to address the source of their confusion
13:59:48 <u-ou> @hoogle unzip
13:59:49 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
13:59:49 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
13:59:49 <lambdabot> Data.ByteString.Char8 unzip :: [(Char, Char)] -> (ByteString, ByteString)
13:59:50 <bitemyapp> Ancient: git-annex, xmonad, pugs, postmaster, darcs, dfsbuild, kaya, whitespace, detexify, chordify, hoodle, Nikki and the Robots, Raincat, hledger, Manatee
13:59:56 <u-ou> oops
13:59:58 <u-ou> @src unzip
13:59:59 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
14:00:04 <bitemyapp> Ancient: two of those are computer games.
14:00:13 <bitemyapp> Ancient: the first one is kickstarted software for end users.
14:00:21 <Ancient> bitemyapp: I've heard of the first two of those, don't know anything about the rest.
14:00:25 <bitemyapp> (Joey Hess had a Kickstarter for git-annex)
14:00:39 <bitemyapp> Ancient: most Haskellers aren't making things for end-users.
14:00:51 <bitemyapp> Ancient: you should evaluate your tools on their merits rather than their popularity.
14:00:56 <bitemyapp> Ancient: do you want help learning Haskell?
14:01:34 <Ancient> I learned it 2 years ago, and I've yet to find a problem that's best solved with it. I feel like my knowledge of it is getting rusty, but I don't have any real world area to apply it.
14:02:26 <ReinH> "I learned it 2 years ago"... respectfully, I'm not sure you're quite finished learning it. ;)
14:02:36 <ReinH> I mean, I know I'm not and I've been doing it for a bit longer.
14:02:38 <bitemyapp> Ancient: uh, it's almost universally applicable to the work I do. I do backend stuff for a living.
14:02:39 <Ancient> I know
14:02:48 * wolftune heads back to study more, be back later
14:02:52 <bitemyapp> Ancient: Give my gist for learning Haskell a whirl: https://gist.github.com/bitemyapp/8739525
14:03:02 <bitemyapp> Ancient: what sorts of things do you want to make?
14:03:08 <kazagistar> Ancient: it is a surprisingly general purpose language, you really could practice it on almost any side project
14:03:15 <ReinH> bitemyapp: step 1: search for "box" and "unwrap"
14:03:26 <ReinH> bitemyapp: you pass
14:03:26 <mmmm_> Does cabal require ghc > 7.?
14:03:32 <Ancient> I've only ever used it for structurally or mathematically pure problems.
14:03:36 <bitemyapp> ReinH: huh?
14:03:48 <Ancient> But I never seem to run into any of those in the wild
14:03:50 <ReinH> bitemyapp: I like to see if haskell tutorials talk about things in boxes or unwrapping things :)
14:03:57 <bitemyapp> Ancient: I use Haskell for filthy imperative stuff regularly. It's nicer for that than other languages I use.
14:04:03 <ReinH> bitemyapp: also you don't recommend the platform?
14:04:07 <bitemyapp> ReinH: gods no.
14:04:11 <ReinH> o_O
14:04:12 <ReinH> why not?
14:04:37 <bitemyapp> ReinH: having fixed a million and one broken package dbs / Haskell installs?
14:04:37 <jfischoff> Ancient: learn Async
14:04:49 <jfischoff> very imperative
14:04:55 <jfischoff> very useful
14:04:57 <johnw> bitemyapp: is that because you moved to 7.8.2?
14:05:04 <johnw> if you stick with the HP compiler, the HP works very nicely
14:05:04 <jfischoff> maybe imperative is the wrong word
14:05:10 <jfischoff> IO heavy
14:05:10 <bitemyapp> johnw: it's because I don't like people complaining about Cabal Hell.
14:05:26 <johnw> they just need to create the right constraint set in their .cabalconfig
14:05:29 <johnw> the way that monochrom recommends
14:05:29 <ReinH> bitemyapp: btw this is pretty epic http://dev.stephendiehl.com/hask/
14:05:34 <bitemyapp> you'll just mislead yourself if you second guess my motives. I recommend avoiding HP even for people that will use 7.6
14:05:46 <bitemyapp> ReinH: it's on the topic on #haskell-beginners as the FAQ.
14:05:48 <johnw> I have no idea what your motives are
14:05:56 <ReinH> bitemyapp: nice, also why am I not in there
14:06:00 <bitemyapp> I want fewer people bumping into Cabal Hell
14:06:06 <bitemyapp> ReinH: please join :)
14:06:09 <ReinH> fixed :)
14:06:16 <chrisdotcode> guys, if I have `data Foo = Foo Int Int Int Int` and `xs = [1,2,3,4]`, how can I apply the Foo constructor to the list?
14:06:35 <shachaf> case xs of [a,b,c,d] -> Foo a b c d; _ -> ...
14:06:38 <bitemyapp> seriously, Cabal Hell is the only reason I tell people not using Windows to avoid HP.
14:06:48 <bitemyapp> most end-users won't know how to mask out the other package dbs.
14:07:00 <bitemyapp> they'll run into a version conflict, thrash a bit, give up, then complain on twitter.
14:07:04 <chrisdotcode> shachaf: is there a generalized version? Generally, I won't know the size of the list, nor the constructor, just that they will match in length of arguments/length
14:07:05 <johnw> I really doubt that solves Cabal problems
14:07:12 <johnw> I've seen plenty of people not using the HP have issues
14:07:13 <cin> haskell platform tries to solve too many problems
14:07:16 <bitemyapp> Telling them to 1. Not use HP 2. install into sandboxes - avoids this.
14:07:30 <chrisdotcode> I tried a fold, but that was obviously wrong
14:07:34 <ReinH> chrisdotcode: if you know all these things, perhaps you should be using tuples instead of lists?
14:07:35 <johnw> and sandboxing everything isn't orthogonal to avoiding the HP?
14:07:54 <bitemyapp> johnw: I'm not going to retype everything in the guide or that I teach in IRC over and over
14:07:59 <chrisdotcode> ReinH: hrm, perhaps? could the curry and uncurry functions help, is that what you're talking about?
14:08:09 <Nadia18>  Here some videos. I hope you like them! http://bitly.com/1gAh6Jy
14:08:16 --- mode: ChanServ set +o monochrom
14:08:21 --- mode: monochrom set -o monochrom
14:08:37 <bitemyapp> johnw: I spend a lot of time teaching Haskell, I know what trips new people up. This is my way for helping them avoid these issues.
14:08:52 <johnw> I stuck with the HP for a year and a half and never had cabal hell problems
14:08:57 <ReinH> chrisdotcode: you'd need to write or import curry/uncurry for larger tuples, but (Int,Int,Int,Int) is isomorphic to data Foo = Foo Int Int Int Int, while [Int] is definitely not
14:09:02 <johnw> so I think you may be swatting at a fly with a sledgehammer
14:09:03 <bitemyapp> johnw: you're an expert user that knows how to work around it.
14:09:13 <ReinH> chrisdotcode: so you'll always have an easier time converting to/from tuples than to/from lists
14:09:17 <cin> never used the haskell platform. it's kinda pointless
14:09:39 <johnw> but as I said, the key is having a constraint set
14:09:43 <cin> hasn't got enough things in it to be useful
14:09:44 <johnw> if you don't, things get messy fast
14:09:52 <ReinH> cin: hasn't got lens. QED. :p
14:10:02 <cin> right. then you're back to square one
14:10:33 <monochrom> bitemyapp: have you read this? will you teach it? http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
14:10:35 <ReinH> chrisdotcode: I'm also curious how they end up as lists in the first place.
14:10:48 <chrisdotcode> ReinH: ah, yes! okay, that solves on problem. but most of the times, I *won't* know the lengths of the tuples, nor the amount of arguments required for the constructor, just that they will match.
14:10:51 <bitemyapp> johnw: if there's a way to force Cabal to always ignore non-core packages in the global and user dbs via config I'd happily recommend HP.
14:10:56 <jfischoff> johnw: I don’t get why HP puts stuff in the global database
14:11:02 <chrisdotcode> ReinH: because I'm an intermediate, and didn't know any better :)
14:11:10 <jfischoff> or at least it used
14:11:15 <monochrom> to be blunt, I believe that "I do X for a living" means nothing. politicians do politics for a living too, what is the result?
14:11:17 <ReinH> chrisdotcode: Maybe with more context we could help you find a better solution
14:11:22 <bitemyapp> monochrom: not really enough.
14:11:29 <jfischoff> haha
14:11:34 <johnw> I will say that before I followed monochrom's advice, HP was a huge problem for me too
14:11:35 <bitemyapp> johnw: the installation of packages into the global-db is the main problem with HP.
14:11:46 <kazagistar> chrisdotcode: are you reading them in from a file as lists or something? because the program can likely be simplified elsewhere
14:11:48 <johnw> ok, I agree with you
14:11:56 <johnw> HP-in-global without constraints is a nightmare
14:11:57 <jfischoff> @remember monochrom to be blunt, I believe that "I do X for a living" means nothing. politicians do politics for a living too, what is the result?
14:11:57 <lambdabot> Done.
14:11:58 <cin> cabal before sandboxes was hell. now it works most of the time
14:12:27 <johnw> I also support heavy use of sandboxing
14:12:36 <bitemyapp> cin: I used to have huge problems, since the introduction of sandboxes, I've been fine.
14:12:37 <chrisdotcode> kazagistar: essentially, yes. I'm generating a data structure from user input.
14:12:44 <jfischoff> why does HP put stuff in the global database?
14:12:55 <ReinH> chrisdotcode: maybe you want an applicative parser?
14:13:10 <cin> bitemyapp, huge problems == hours wasted making things build instead of writing code, to be specific
14:13:22 <chrisdotcode> ReinH: I definitely know I'm going to be using applicative, but my initial thoughts didn't work out
14:13:22 <bitemyapp> cin: precisely.
14:13:36 <ReinH> chrisdotcode: have you tried attoparsec or similar?
14:14:05 <ReinH> jfischoff: to make you cry
14:14:09 <Ancient> bitemyapp: To pull an easier program off my todo list. A setuid binary to check an Ed25519 signed update plan and execute it only if it matches. That doesn't feel like something haskell would be suited for. Am I mistaken?
14:14:25 <chrisdotcode> ReinH: I don't know much about parsing, and besides the dragon book, I haven't found anything that I could use as a definitive, beginner-friendly introduction.
14:14:27 <ReinH> cin: I've had to completely reinstall haskell platform a couple times, but probably because I did not know how to actually fix the problem.
14:14:38 <jfischoff> ReinH: success
14:14:53 <cin> ReinH, does the haskell platform actually do anything for you that normal ghc + hackage doesn't?
14:15:07 <bitemyapp> monochrom: I can't recommend it because I haven't tried it.
14:15:17 <bitemyapp> monochrom: and I'm not about to go back to using HP.
14:15:20 <ReinH> chrisdotcode: maybe https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
14:15:26 <carter> jfischoff: ReinH  the reason is Haskell platform is meant for intro students
14:15:33 <bitemyapp> carter: too bad it failed at that.
14:15:36 <ReinH> heh
14:15:42 <ReinH> cin: nope
14:15:43 <bitemyapp> it breaks the "just work" guideline.
14:15:50 <ReinH> cin: I mainly use it out of habit at this point
14:15:50 <carter> bitemyapp: ReinH  you should have a chat with mzero at bay hac then
14:16:00 <bitemyapp> carter: I don't really want to get into a debate, just route around the damage.
14:16:01 <ReinH> carter: you're still coming right?
14:16:26 <carter> ReinH: nah, by the times i had cash on hand to cover the ticket, the prices went up too high for my tolerance
14:16:29 <carter> for a weekend trip
14:16:33 <jfischoff> bitemyapp: mzero is the coorganizer of BayHac, and a HP maintainter
14:16:37 <ReinH> carter: I am very disappoint.
14:16:51 <carter> bitemyapp: you should talk with mark to understand the *why*
14:16:52 <ReinH> carter: are you still coming to Portland?
14:16:55 <carter> ReinH: yeah
14:16:57 <chrisdotcode> ReinH: sweet! That'll be helpful. however, is there a definitive, from-nothing-to-something tutorial?
14:16:57 <bitemyapp> jfischoff: I know, I don't want to hurt anybody's feelings or get into an argument. I just want things to work.
14:16:58 <ReinH> win
14:16:59 <carter> stillneed to figure out the detials
14:17:04 <carter> bitemyapp: ask mark
14:17:13 <ReinH> chrisdotcode: how much nothing are we talking about here? :p
14:17:14 <monochrom> I don't mind not using HP. but why have you not tried and probably not known about locking down versions, as an expert in this field?
14:17:14 <carter> to explain why the current appraoch is what it is
14:17:16 <jfischoff> bitemyapp: yes we all want that
14:17:23 <joe_k> is Cloud Haskell still a thing?
14:17:24 <jfischoff> speaking of which
14:17:26 <carter> bitemyapp: point being, ask
14:17:28 <bitemyapp> carter: "why" can be discussed after it just works.
14:17:29 <joe_k> i love the idea of erlang OTP for haskell
14:17:39 <carter> joe_k: its a thing
14:17:47 <carter> but i dislike the current design
14:17:48 <jfischoff> monochrom: you should write a blog a post about what your ideal cabal-install+hackage would look like
14:17:51 <bitemyapp> joe_k: I've been talking to a few people about this. I think it's a promising line of thought but Cloud Haskell may not be the platform for it.
14:17:53 <ReinH> joe_k: Me too, but it has some issues.
14:18:04 <monochrom> at the end, you could say, you still won't teach your customers about this. but as an expert, you are expected to know all options.
14:18:06 <bitemyapp> jfischoff: I think the default config should ban global/user installs.
14:18:14 <carter> bitemyapp: ... nope
14:18:15 <bitemyapp> jfischoff: the one cabal creates.
14:18:17 <carter> global yes
14:18:21 <ReinH> The main one imo being that serialization loses too much typing information
14:18:23 <carter> user... thats ok, just
14:18:23 <monochrom> see this is the reason of my comment on X
14:18:25 <bitemyapp> without an explicit command-line flag to allow.
14:18:36 <bitemyapp> --allow-user-install or some such.
14:18:45 <carter> bitemyapp: i disagree
14:18:51 <bitemyapp> the UX currently allows people to get themselves into trouble.
14:18:53 <bitemyapp> That's the problem.
14:19:11 <jfischoff> sandboxing is a partial solution, and annoying taken to extremes
14:19:16 <cin> there isn't really a UX to speak of
14:19:27 <cin> it's just one long series of stumbles and trips and detours
14:19:34 <carter> bitemyapp: jfischoff  i like the "functional package db" vision that people are slowly working towards
14:19:35 <joe_k> also has anyone run haskell on bare metal?  I bet that's a lot easier with uefi
14:19:37 <carter> so you can reuse builds
14:19:47 <carter> joe_k: theres ghc on xen
14:19:51 <chrisdotcode> ReinH: nothing as in "I've heard the term "LL" parsers" heh
14:19:52 <johnw> yes, Nix makes sandboxing everything pretty resource efficient
14:19:55 <bitemyapp> carter: I'd really like that, I've been faking it with add-source.
14:19:59 <joe_k> there you go
14:20:07 <Kaidelong> joe_k: this is essentially what HaLVM is for
14:20:11 <carter> yup that
14:20:42 <joe_k> fun. checking it out now
14:20:56 <wolftune> so, http://www.vex.net/~trebla/haskell/IO.xhtml says "if g :: String, then g is the same string every time" but you could easily write distinct functions that each have a variable we call g that is a string and they aren't the same because they live in different functions…
14:21:37 <ion> They would not be the same g.
14:21:39 <monochrom> assume g is a global name. as global as getLine, which is the subject matter here
14:21:43 <wolftune> ion: right!
14:21:48 <joshhartigan> I'm new, apologies. I was wondering if Haskell can be used in the same way as, say, Python for general purpose programs, rather than just math-oriented things?
14:21:54 <joe_k> it can
14:22:05 <ReinH> joshhartigan: yep!
14:22:07 <ion> @faq
14:22:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:22:36 <joshhartigan> ion: that's a helpful link, thank you
14:22:47 <mmmm_> joshhartigan: I think that's this channel's favourite question to answer :P
14:22:52 <benzrf> joshhartigan: here is a useful function for this kind of quetsion
14:22:54 <benzrf> *question
14:22:55 <wolftune> monochrom: that's not a good assumption without stating it. Because the idea that a variable is ALWAYS the same is confusing because you can have multiple variables with the same name, just not in the same global level or the same internal function
14:23:01 <benzrf> @faq is haskell practical for real programs?
14:23:01 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:23:04 <benzrf> oh wait
14:23:06 <benzrf> wrong command >.<
14:23:09 <bitemyapp> carter: also, I've read the mailing list pretty extensively. I have a reasonable idea of the "why" but the trade-offs and UX are problematic for my use-cases so I have to work around it.
14:23:18 <benzrf> @help is haskell practical for real programs?
14:23:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:23:21 <benzrf> gah
14:23:22 <benzrf> @help
14:23:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:23:23 <benzrf> @list
14:23:23 <lambdabot> What module?  Try @listmodules for some ideas.
14:23:26 <benzrf> >_>
14:23:29 <joe_k> i switched to f# the last year for my "everything" language, maybe I should go haskell this year
14:23:40 <joshhartigan> that's a pedantic bot
14:23:42 <benzrf> joshhartigan: behold
14:23:47 <benzrf> main = do
14:23:51 <monochrom> everything you say about g, you could say about getLine too. but do you actually say it about getLine? I'm going to do the same thing to both g and getLine.
14:23:53 <benzrf>   putStr "whats ur name "
14:23:53 <bitemyapp> carter: I don't really want to talk about the depressing necessities of certain decisions that were made. I can ignore Windows users in order to get a smoother ramp for the people I teach so I'm going to.
14:24:01 <benzrf>   name <- getLine
14:24:08 <benzrf>   putStrLn ("sup " ++ name)
14:24:30 <ReinH> bitemyapp: windows instruction begins with "install this VM" ;)
14:24:46 <bitemyapp> ReinH: yep.
14:24:54 <ReinH> But seriously, a lot of potential Haskellers will currently be on Windows
14:24:55 <bitemyapp> ReinH: I made a virtualbox VM for learning Haskell.
14:25:17 <ReinH> There's a pretty big selection bias inherent in "I teach Haskellers that use Linux"
14:25:22 <bitemyapp> I know this.
14:25:34 <bitemyapp> it's actually Mac OS X + Linux, and that covers a large chunk of the people that come to me.
14:25:39 <joshhartigan> thank you for your help
14:25:40 <bitemyapp> A very large chunk.
14:26:06 <wolftune> monochrom: hmm ok
14:26:07 <ReinH> The vast majority of new Ruby developers at RailsGirls are on Windows. It wouldn't really be fair to shut them out by punting on Windows support.
14:26:18 <joe_k> part of why ruby sucks and python is awesome is because python never ignored the inconvenient platform.... in fact they had great support for it since an early version
14:26:24 <bitemyapp> ReinH: well, the choices as far as I can tell are: 1. Use HP, but give them a long list of "make Cabal shut up" command flags that they won't fully understand 2. Or, tell them to use an install with a more minimal initial global package-db and just use sandboxes.
14:26:42 * ReinH shrugs
14:26:47 <ReinH> I'm not even arguing about HP any more :p
14:26:50 <bitemyapp> I'm changing the gist to accommodate both.
14:27:23 <monochrom> it is so easy for an interpreter to support more platforms
14:27:44 <ReinH> joe_k: well it would have to be a cultural reason since the langauges are basically the same
14:27:50 <joe_k> it is
14:28:06 <hakujin> besides the ancillary tooling and potential RTS performance what's the issue with Haskell on Windows? ghc works, cabal works, sandboxes work, windows has a shitty terminal, etc..
14:28:14 <bitemyapp> ReinH: I actually find Python internals easier to understand.
14:28:18 <bitemyapp> but that's besides the point.
14:28:33 <Heffalump> hakujin: building things is very slow IME
14:28:44 <ReinH> bitemyapp: I suppose it depends on which Ruby and which Python. Rubinius is pretty damn easy to understand.
14:28:44 <monochrom> some C libs are annoying to obtain or build on windows. and some haskell libs need them.
14:28:54 <Heffalump> I'm not entirely sure why, actually
14:29:02 <bitemyapp> ReinH: I was thinking MRI vs. CPython 2.x
14:29:03 <pxqr> monochrom: for example?
14:29:05 <Heffalump> possibly because Windows process creation is so expensive
14:29:15 <hakujin> Heffalump: as in GHC has slow compile times on Windows?
14:29:24 <Heffalump> mainly that cabal install X is very slow
14:29:33 <k0ral> Hello, would anyone be so kind as to help me investigate the following segmentation fault: http://sourceforge.net/p/gtk2hs/mailman/message/32245969/ ; I got no useful answer from gtk2hs maintainers, I don't even know whether it is a bug in gtk binding or in GHC, I would really appreciate any help
14:29:47 <monochrom> for example if you want the "network" package on windows, your best bet is just using the HP installer. telling cabal-install to build it is much harder, there are much obscure prerequisite
14:30:12 <Heffalump> monochrom: I don't generally have problems with network under mingw
14:30:23 <monochrom> then nevermind. some other package
14:30:25 <hakujin> network-2.5.0.0 builds just fine on Windows. Even with fancy GHC 7.8.2
14:30:31 <Heffalump> but I guess that might count as an obscure prerequisite in the first place
14:30:45 <monochrom> oh, take gtk for example. that's an easy target :)
14:30:46 <Heffalump> and certainly things with configure scripts are great example of my point about "builds are slow"
14:30:52 <Heffalump> because configure scripts are dog slow on Windows
14:31:44 <bitemyapp> Heffalump: do you know why?
14:33:21 <carter> bitemyapp: ReinH  does raise a valid point, that many under resourced communities / demographics *willl* be on windows machines
14:33:33 <carter> becaue they're substantially more affordable
14:33:46 <bitemyapp> carter: I know this.
14:33:46 <ReinH> Also familiarity
14:33:59 <bitemyapp> carter: but the people coming to me aren't from those demographics.
14:34:03 <carter> fair"
14:34:05 <albeit> If I have a type SimmerState = StateT Simmer MarketState, how do I create an initial SimmerState?
14:34:10 <ReinH> and really learning linux *and* Haskell at the same time is a bad idea
14:34:13 <bitemyapp> I have to prioritize what works for the people actually expressing an interest in learning.
14:34:17 <bitemyapp> ReinH: I also agree.
14:34:28 <bitemyapp> ReinH: which is similarly why I don't force a particular editor on people.
14:34:31 <carter> i think we all agree about the goals
14:34:34 <johnw> albeit: you run runStateT x <initial state>
14:34:46 <bitemyapp> We're not disagreeing on anything, my priorities are just more focused and specific.
14:34:53 <carter> indeed
14:35:47 <Heffalump> bitemyapp: I think the fundamental reason is that process creation is slow
14:35:54 <Heffalump> but I don't know for sure
14:36:04 <albeit> johnw: Then how does the underlying MarketState get initialized?
14:36:24 <dmj`> > flip runState 4 $ modify (+1)
14:36:25 <lambdabot>  ((),5)
14:36:29 <ReinH> albeit: by you? :)
14:36:36 <dmj`> :t flip runState
14:36:37 <lambdabot> b -> State b a -> (a, b)
14:36:44 <carter> Heffalump: i've seen someone build stuff CRAZY fast on windows
14:36:49 <dmj`> ^ b is your initial type
14:36:51 <carter> otoh, it was an insanely beefly laptop
14:37:33 <pxqr> does network-transport designed mostly for distributed-process use?
14:37:55 <bitemyapp> carter: do you know what laptop?
14:38:05 <carter> bitemyapp: ask rickasaurus ;)
14:38:13 <carter> it had 32gb of ram and many cores
14:38:14 <ReinH> > flip runState (1,2) $ _1 += 2 -- yay lens
14:38:15 <carter> all windows
14:38:16 <lambdabot>  ((),(3,2))
14:38:45 <ReinH> carter: o_O why would you waste all that on windows? :p
14:39:09 <monochrom> because it can play beefy games :)
14:39:35 <carter> ReinH: games + tooling that needs to run on windows for his work
14:40:08 <ReinH> I figured :)
14:40:08 <monochrom> but you should put hypervisor on it and switch between windows, linux, and freebsd at a whim
14:40:22 <carter> not my comptuer
14:40:23 <carter> friends
14:40:32 <ReinH> monochrom: my windows PC exists entirely for games.
14:40:50 <ReinH> although I might dual boot to linux and use it for some GPU programming
14:41:11 <carter> ReinH: oo, what sort of gpu things
14:41:11 <monochrom> me too. well, I also add blu-ray to it. oh, and acrobat reader that can fill in pdf forms.
14:41:24 <monochrom> and itunes for my ipod touch
14:41:34 * carter wants to get a new computer so he can gpu stuff
14:41:40 <ReinH> carter: dunno, just wanted to see what I can do with a couple 760s
14:41:47 <carter> 760s?
14:41:54 <carter> @google  760 gpu
14:41:55 <lambdabot> http://www.geforce.com/hardware/desktop-gpus/geforce-gtx-760
14:41:55 <lambdabot> Title: GeForce GTX 760 GTX Graphics Card | GeForce
14:41:55 <ReinH> nvidia
14:42:03 <carter> ReinH: you have more than one on a laptop?
14:42:12 <carter> those arent for laptops..
14:42:21 <ReinH> I never said it was a laptop
14:44:37 <ion> > (1,2) &~ _1 += 2
14:44:39 <lambdabot>  (3,2)
14:44:51 <ReinH> :t (&~)
14:44:52 <lambdabot> s -> State s a -> s
14:44:56 <ReinH> oh. Right.
14:46:02 * hackagebot shake 0.12 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.12 (NeilMitchell)
14:46:10 <albeit> execStateT returns (s,a), but I need a full StateT Simmer MarketState ( = Simmer State) such that a function of type :: String -> SimmerState () can act on it...
14:46:27 <pxqr> ReinH: have you used accelerate or something?
14:46:35 <ReinH> pxqr: not yet but I want to :)
14:46:59 <pxqr> ReinH: it is pretty much neat at the moment
14:47:04 <pxqr> and mind bending
14:47:47 <Jefffrey> Hi
14:48:18 <Jefffrey> Is the author of Scotty here, by any chance?
14:49:34 <joeyh> is anyone able to install gnuidn on OSX?
14:49:39 <joeyh> failing here with a cpp problem
14:50:02 <carter> joeyh: whats your ghc --info say
14:50:04 <geekosaur> | XCode 5 issues? http://is.gd/H4sEub |  <-- from topic
14:50:15 <dmj`> Jefffrey: what's your question?
14:51:18 <joeyh> I don't think this is the same xcode issue. it's c2hs failing
14:51:25 <joeyh> so a real use of real cpp headers
14:51:38 <Jefffrey> dmj`: Mainly a general overview of the framework. What is the ScottyM and ScottyT supposed to do and such. I'm planning on studying it, so a generic overview would be nice.
14:51:51 <geekosaur> then I think you need to provide a bit more information
14:52:04 <Jefffrey> Also, I would ask him why cookies,sessions and caching are not supported.
14:52:12 <joeyh> /usr/include/inttypes.h:234: (column 46) [ERROR]  >>> Syntax error !
14:52:15 <hakujin> Jefffrey: you probably want to understand WAI first
14:52:22 <hakujin> if you're going to study the guts
14:52:40 <hakujin> http://hackage.haskell.org/package/wai
14:52:55 <Jefffrey> hakujin: I'm already playing with WAI. I know what Request/Response/Application are and such.
14:53:27 <joeyh> which is why I was wondering it it installed for anyone else :)
14:53:34 <albeit> So this doesn't compile, and I feel like shooting blindfolded trying to get the intitalState correct... http://lpaste.net/103898
14:54:27 <dmj`> Jefffrey: If you're looking for auth + sessions, there's a project called Spock, which is based on Scotty. http://hackage.haskell.org/package/Spock
14:55:23 <carter> joeyh: clang or GCC
14:55:30 <carter> whats ghc --info say
14:55:37 <carter> and whats gcc --version say
14:55:40 <carter> and what OS version
14:56:11 <Jefffrey> dmj`: Oh yeah. I know, thanks. But since Scotty is inspired on Sinatra and Sinatra provides easy cookies, sessions and caching and since they are pretty basic, I was wondering why they weren't implemented. :)
14:56:47 <monochrom> albeit: I think you have greatly conflated type names and data constructor names.
14:57:11 <joeyh> c2hs is uring gcc, an it's ghc 7.6.3
14:57:34 <carter> joeyh: what OS X version
14:57:38 <carter> what does gcc --version say
14:57:40 <albeit> monochrom: Yep. Though I understand State isn't a data constructor, I just didn't know what else to put there to demonstrate my non-understanding ;)
14:57:48 <carter> joeyh: i'm asking specifc questions so i can help you
14:58:07 <joeyh> yes, I do support on IRC all day too :)
14:58:12 <joeyh> did I miss one?
14:58:48 <monochrom> I think it is way off and a case of "go back to square 1".
14:59:06 <albeit> monochrom: Shall do
14:59:20 <joeyh> osx mavericks
14:59:31 <carter> joeyh: ok
14:59:37 <carter> whatcs gcc --version say
14:59:41 <carter> :)
15:00:11 <joeyh> http://pastebin.com/kST9Xgnv
15:00:45 <carter> joeyh: AHA
15:00:50 <carter> so its calling clang thinking its gcc
15:01:02 <carter> joeyh: https://gist.github.com/cartazio/7131371 :)
15:01:10 <carter> you'll wanna brew install a real gcc
15:01:17 <carter> and then repoint your GHC settings files to real GCC
15:02:23 <joeyh> hmm, where's that file?
15:02:23 <carter> you *might* also want to have eg a script in ~/bin that wrapps calling real gcc and is named gcc
15:02:24 <dmj`> Jefffrey: no one is stopping you from implementing those things :)
15:02:29 <carter> joeyh: read the linked directions :)
15:03:23 <pantsman> ever have the experience when you write a function that type-checks and seems to behave as you want, but you've no idea really how it works?
15:03:24 <Jefffrey> dmj`: You mean by myself or propose a pull request=
15:03:26 <Jefffrey> ?
15:03:47 <Enigmagic> pantsman: that goes away after a year or two ;)
15:04:18 <ReinH> pantsman: even worse, sometimes I ask the computer to write them for me, it does, the function works, and I have no idea how it works!
15:04:49 <dmj`> Jefffrey: fork it, make a branch, submit a pull
15:04:59 <Jefffrey> dmj`: https://github.com/scotty-web/scotty/pull/69
15:05:04 <monochrom> sometimes they ask me and I answer http://www.vex.net/~trebla/haskell/scanl.xhtml
15:05:59 <Ariel__> Is it possible to use repa with custom types?
15:07:58 <carter> Ariel__: yeah...
15:08:00 <carter> Ariel__: #numerical-haskell is a channel that might interest you
15:08:04 <carter> Ariel__: whats your use case
15:09:52 <Ariel__> carter: Just playing with the library. Everything works fin when using Ints but I cant even use a simple custom type like data T Int Int
15:10:03 <dmj`> Jefffrey: have you tried emailing him?
15:10:05 <carter> Ariel__: have you ever used Vector?
15:10:26 <carter> if you look you'll notice that for unboxed/ storable arrays you'll need to add Unbox/Storable instances for types you wanna use
15:11:10 <Ariel__> carter: Never used it. Ho ok! Would you be able to direct me on a place to read about it?
15:11:23 <carter> well, the glib answer is
15:11:26 <carter> @hackage vector
15:11:26 <lambdabot> http://hackage.haskell.org/package/vector
15:11:47 <carter> Ariel__: if you wanna see a nontrival example of a userland storable / unbox instance
15:11:53 <carter> i have one thats a bit more crazy
15:12:00 <joeyh> carter: got it to work with a gcc wrapper, thanks
15:12:19 <Ariel__> carter: thanks! :D
15:12:21 <carter> joeyh: 7.8.2 will work with whatever CC is used ot built it
15:12:27 <carter> 7.8.3 will work with boht
15:12:52 <bitemyapp> carter: 7.8.3 will have a bindist built with GCC right?
15:12:56 <carter> bitemyapp: nope
15:13:16 <bitemyapp> carter: sigh. mailing list of false hopes.
15:13:34 <carter> bitemyapp: i'll have a gcc bindist for os x thats with gcc
15:13:45 <carter> as can anyone else who wants
15:13:51 <carter> aint that hard
15:21:25 <bitemyapp> Is there a good tutorial for reasoning about spines, tail recursion, guarded recursion, and how many reductions executing a function will perform?
15:21:43 <bitemyapp> I've got a handful of Stack Overflow posts and a Haskell wiki article that doesn't quite get to the point.
15:22:43 <albeit> If I use a State monad, but I don't care about the action (s -> (a,s), discard a), is there something else I should be using (s -> s)? Maybe just explicit state passing?
15:24:38 <dmj`> albeit: execState
15:25:26 <dmj`> > flip execState 4 $ get >>= put . (+1)
15:25:27 <lambdabot>  5
15:25:30 <orzo> Anyone want to give me some feedback on this interface? http://jerkface.net/~joe/ScanningParser.html
15:26:06 * hackagebot cabalg 0.2.0 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.0 (DmitryMalikov)
15:26:22 <orzo> is there a common name for this algorithm "scan and parse" algorithm btw?
15:26:52 <glosoli> What books on Haskell or FP would you folks recommend, other than "Learn You Haskell" which I already orderd
15:26:56 <glosoli> ordered"
15:27:04 <hpc> osaki's data structures is really good
15:27:27 <glosoli> hpc: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 ?
15:27:34 <hpc> er, yeah
15:27:42 <glosoli> Thanks
15:27:48 <mmmm_> There's not really a general book in the after-LYAH yet though I feel
15:27:52 <mmmm_> or I just haven't found it yet
15:28:02 <hpc> you get more into specific topics
15:28:20 <hpc> one of the simons has a good concurrency book too, which i forget the title of
15:28:25 <hpc> came out a few months ago
15:28:55 <glosoli> hpc: could you please try to remember (not trying to sound rough)
15:28:59 <hpc> yeah
15:29:05 <Jefffrey> dmj`: Nope. That might be an idea. Thanks.
15:29:28 <hpc> ah, it's the oreilly book: http://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942/
15:29:52 <glosoli> Thanks !
15:30:09 <hpc> anyway, those two books will make you better at pretty much any language you decide to use
15:30:51 <bitemyapp> glosoli: this is my guide to learning Haskell, has a lot of resources: https://gist.github.com/bitemyapp/8739525
15:31:13 <bitemyapp> glosoli: I don't recommend LYAH for actually learning Haskell. I prefer Yorgey's course followed by a collection of resources specific to various topics.
15:31:40 <epta> glosoli: take a look at this list http://www.stephendiehl.com/posts/essential_haskell.html
15:32:38 <mmmm_> basically it's easy to spend way too long reading haskell articles on the internet
15:32:41 <glosoli> bitemyapp: may I ask for why would you not recommend LYAH ?
15:33:11 <glosoli> epta: bookmarked, thanks
15:33:11 <bitemyapp> glosoli: boring, slow, too little butter on too much toast making it difficult to understand the "essence" of the material.
15:33:34 <bitemyapp> glosoli: LYAH has a relatively high drop-out rate despite not pushing people very hard.
15:33:43 <bitemyapp> RWH has similar but different issues.
15:34:09 <bitemyapp> LYAH is a good reference (rather than guide or tutorial) for introductory topics. RWH is a good reference for other topics.
15:34:28 <bitemyapp> Yorgey's course is a very good step-by-step course for learning Haskell.
15:34:42 <bitemyapp> I haven't found a better way to teach or learn Haskell yet.
15:34:52 <glosoli> So what you recommend, I should use Yorgeys as a step by step course and LYAH as a Reference  ?
15:34:58 <bitemyapp> yep.
15:35:12 <mmmm_> Many people find LYAH a very accessible introduction which breaks down the perception that haskell is impossible
15:35:13 <bitemyapp> followed by specific material on whatever topics interest or intrigue you.
15:35:57 <bitemyapp> mmmm_: I'm prioritizing conversion rate.
15:36:29 <bitemyapp> mmmm_: this subsumes the need to think about "perceptions" because I'm optimizing for "will write Haskell by the end of the course"
15:37:14 <benzrf> glosoli: haskell is fun !
15:37:21 <benzrf> just do not expect it to be like other languages
15:37:39 <bitemyapp> Haskell is doubly fun after you start playing with lenses :P
15:37:44 <glosoli> benzrf: I have read like 100 pages of LYAH digital version already, decided to take a paper back and bunch of other stuff
15:37:51 <glosoli> paperback"
15:37:52 <benzrf> i believe that haskell would be no more than 1.5x more difficult than python at maximum to an absolute beginner
15:37:55 <benzrf> possibly even easier
15:38:04 <glosoli> Type system seems some sort of amazing, bunch of other stuff like guards, sections and etc
15:38:05 <benzrf> assuming they are reasonably conversant with mathematical functoins
15:38:07 <bitemyapp> benzrf: I'd tend to agree, partly because the semantics are less arbitrary.
15:38:09 <troydm> nah
15:38:25 <troydm> reading code is sometimes tricky
15:38:27 <bitemyapp> benzrf: but the very beginning of the ramp for Python is easier/more intuitive/more familiar because people aren't used to mathematical reasoning.
15:38:31 <benzrf> mhm mhm
15:38:35 <troydm> esp if it's not yours
15:38:45 <bitemyapp> benzrf: people without a mathematical background take naturally to "step by step" recipe coding.
15:38:56 <hyPiRion> troydm: esp. if you have no clue what it does
15:38:57 <benzrf> perhaps
15:39:35 <bitemyapp> hyPiRion: but that's when we introduce :t  :)
15:39:43 <bitemyapp> :t (<|>)
15:39:44 <lambdabot> Alternative f => f a -> f a -> f a
15:39:46 <troydm> esp if u are using monad transformers over monad transformers
15:40:18 <hyPiRion> bitemyapp: heh, I'm mostly talking about stuff where there's some reasoning not obvious in the code
15:40:22 <bitemyapp> > Just 10 <|> Nothing <|> Just 20
15:40:24 <lambdabot>  Just 10
15:40:30 <bitemyapp> > Nothing <|> Nothing <|> Just 20
15:40:31 <lambdabot>  Just 20
15:40:53 <hyPiRion> Imagine reading the source code of a red-black tree without knowing how a red-black tree should work
15:41:25 <bitemyapp> hyPiRion: my first exposure to them was in C before I knew how they worked. Baffling beyond words.
15:42:28 <hyPiRion> bitemyapp: I'm sorry for your loss of sanity =(
15:42:59 <hyPiRion> Good to see you've recovered since then
15:43:24 <bitemyapp> hyPiRion: thanks :)
15:44:21 <solidus-river> whats a good warp tutorial
15:44:28 <solidus-river> or where is a good warp tutorial :P
15:45:17 <carter> Fuuzetsu: i have a weird haddock output, should i email you the stuff or report it where?
15:46:36 <bitemyapp> solidus-river: just wondering, why do you want to learn Warp specifically?
15:46:53 <bitemyapp> solidus-river: usually people want to write apps in terms of either Yesod, WAI, or Scotty.
15:47:39 <h4x> Hi,
15:47:55 <h4x> I was wondering how I can execute a program from main without requiring IO
15:48:07 <h4x> well, let's say I write a function 'foo' that takes an integer
15:48:10 <shachaf> What does that mean?
15:48:29 <h4x> I want the program to execute "foo 10" when I call main
15:48:39 <h4x> so, like "main = foo 10"
15:49:00 <Clint> h4x: what does foo return?
15:49:00 <h4x> but GHC complains that it's not the right type
15:49:02 <h4x> "Couldn't match expected type `IO t0' with actual type `Int'"
15:49:11 <h4x> foo returns an Int
15:49:15 <Clint> you want it to print the Int?
15:49:44 <hakujin> h4x you probably want to print that Int right? main = foo 10 >>= print
15:49:52 <geekosaur> if it's not doing something IO-like, what exactly is it supposed to do with the result Int?
15:49:58 <solidus-river> bitemyapp: oh, i guess i do want
15:50:05 <nicoo> a
15:50:06 <h4x> hakujin: thanks, got it!
15:50:06 <dmj`> main has to execute IO
15:50:08 <hpc> hakujin: you mean print (foo 10)
15:50:21 <h4x> I was confused because ghci prints the result automatically when you call a function
15:50:22 <hakujin> hpc: I sure do
15:50:31 <bitemyapp> solidus-river: well, how minimal do you want it?
15:50:31 <dmj`> h4x: ghci is in the IO monad
15:50:36 <geekosaur> ghc acts like the inside of a "do" in IO
15:50:38 <h4x> sorry if this was a dumb question
15:50:40 <geekosaur> er, ghci
15:50:44 <bitemyapp> solidus-river: WAI is the most minimal interface, with Scotty doing more for you and Yesod doing a lot more.
15:51:01 <bitemyapp> solidus-river: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html http://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
15:51:03 <hpc> ghci is basically a giant do-block
15:51:07 <hpc> which turns lines into
15:51:07 <solidus-river> bitemyapp: it seems Yesod is considerably slower though
15:51:16 <h4x> hpc: I wasn't aware of that. thanks.
15:51:16 <bitemyapp> solidus-river: don't use the Techempower benchmarks.
15:51:19 <hpc> let it = whatYouTyped
15:51:20 <bitemyapp> solidus-river: also, don't trust benchmarks.
15:51:22 <hpc> v <- it
15:51:28 <bitemyapp> solidus-river: the Techempower benchmarks are on an ancient version of GHC.
15:51:42 <bitemyapp> solidus-river: you're not using good criteria here.
15:51:53 <hpc> if (magicIsUnitType v) then return () else print v
15:55:10 <dmj`> solidus-river: snap is cool too www.snapframework.com
15:55:51 <bitemyapp> solidus-river: my recommendation, based on your preference, would be Snap, Yesod, or Scotty.
15:56:40 <Maior> where do people stand on Happstack?
15:56:45 <solidus-river> bitemyapp: reading up on all three :)
15:58:04 <merijn> Maior: ranks about the same as snap, afaik
15:58:09 <Clint> Maior: it's saner but requires more effort than yesod
15:58:40 <bitemyapp> Snap and Scotty are the cheap and cheerful way to go for most people.
15:58:47 <merijn> scotty is barebones, snap/happstack are both about in between, yesod is really full-featured, but lots of TH can result in scary type errors
15:59:03 <bitemyapp> merijn: some people will be confounded by the stacks of monads in Yesod too.
15:59:17 <bitemyapp> in Persistent too, really.
15:59:48 <Jefffrey> good night
15:59:56 <merijn> I guess
16:00:15 <merijn> The thing with monad stacks is, they're more afraid of you than you are of them :p
16:00:44 <teneen> Are Storable elements unboxed?
16:01:16 <hpc> they're also smelly and you shouldn't feed them
16:01:25 <ReinH> and never ever let them touch water
16:01:34 <merijn> teneen: Not normally
16:01:50 <merijn> teneen: Well, it depends what you even mean
16:02:12 <merijn> teneen: Storable is a typeclass for haskell values, so are which elements of what unboxed when?
16:02:12 <teneen> merign: Data.Vector.Storable for example?
16:02:20 <teneen> merijn,
16:02:44 <merijn> I'm pretty sure those are for interoperation with C
16:03:54 <merijn> i.e. a Vector.Storable is interchangeable with a C array of the same type
16:04:28 <merijn> bitemyapp: Speaking of confounded monad stacks, I had to debug an error in a function with this friendly type just now: "Producer Text (Proxy X () () Text (Proxy x' x () Text m)) x -> CPPState -> Proxy X () () Text (Proxy x' x () Text m) ()"
16:05:15 <solidus-river> after working on distributed websites for the past 2 years.... why aren't more people using Yesod / Snap / Scotty, they are pretty amazing looking and i think would have lost a lot less hair if the companies I've worked at were using them
16:05:33 <bitemyapp> merijn: o_O
16:05:35 <zomg> solidus-river: because Haskell is completely nuts if you ask most web devs
16:05:41 <solidus-river> are there any benchmarks / modules that deal with socketed IO / websockets
16:05:45 <acowley> teneen: They often are if you are traversing a container of storable elements.
16:06:04 <merijn> solidus-river: Well, that's because after your 2 years experience you have started to notice that doing things "wrong" costs a lot of time and effort
16:06:18 <acowley> teneen: However that is really just a result of the optimizer doing clever things.
16:06:21 <merijn> solidus-river: Many people don't see the "benefit" of doing things properly, only the cost
16:06:28 <teneen> acowley: like Data.Vector.Storable?
16:06:55 <acowley> teneen: Yes, if you do a V.map over a Storable vector of, say, Ints, the Ints you peek and poke from/to the vector will likely remain unboxed
16:06:55 <pxqr> solidus-river: you can use websockets with both yesod and scotty;
16:07:05 <acowley> teneen: Assuming everything can be inlined
16:07:05 <merijn> solidus-river: As a famous haskell quip goes: "writing wrong programs is hard in haskell, but writing correct programs is hard in *any* language. Therefore everything is hard in haskell"
16:07:11 <wolftune> Can I put the arg for a function on a new line below with indentation?
16:07:39 <solidus-river> heh, the cost is huge, most of my time was spent tracking down incosistent data / edge cases that were glossed over
16:07:40 <orion> solidus-river: Is Yesod the Haskell equivalent of Ruby on Rails?
16:07:46 <bitemyapp> solidus-river: you really don't want to keep using benchmarks for your technology decisions.
16:07:48 <dmj`> solidus-river: people don't like what they don't know, and the inverse
16:07:50 <solidus-river> wonder how their performance holds up with concurrent websockets open
16:07:55 <bitemyapp> solidus-river: especially other peoples' benchmarks.
16:08:10 <bitemyapp> Haskell is fast, best to leave it at that until you understand your needs better.
16:08:13 <merijn> solidus-river: In my experience haskell libraries tend to refuse to cut corners, therefore making "initial" development feel like a pain, but doing things properly becomes much easier :)
16:08:35 <merijn> Well, exempting acme-php, of course :p
16:08:42 <merijn> orion: ish
16:08:50 <zomg> Coming from a web dev background many haskell libraries are quite sane and not a pain at all
16:08:58 <zomg> at least the ones I've used anyway =)
16:08:59 <dmj`> zomg: agreed
16:08:59 <bitemyapp> merijn: re: "refuse to cut corners", have you seen the newtypes in my library?
16:09:14 <merijn> orion: It tries to be the "one stop shop for web dev", so in that sense it's the equivalent of rails, but not in the way it approaches things :p
16:09:15 <solidus-river> orion: aye, both Yesod and snap seem pretty equivalent to ruby on rails
16:09:18 <bitemyapp> merijn: https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound/Types.hs#L229-L270
16:10:00 <merijn> bitemyapp: I hope you didn't write those by hand :p
16:10:16 <orion> solidus-river / merijn: Do you do any planning before writing code? If so, what do you do?
16:10:36 <orion> In C++ for example, one might find UML diagrams.
16:10:42 <merijn> orion: tbh, I only wrote like 1 trivial thing using Yesod before I decided "sod this whole web dev thing"
16:10:43 <orion> What do Haskell coders do?
16:10:51 <bitemyapp> merijn: I did.
16:10:59 <bitemyapp> merijn: I wrote the whole library by hand. :P
16:11:15 <bitemyapp> merijn: not all of them have generic instances.
16:11:16 <zomg> Most of any kind of "planning" I find myself doing with Haskell is defining datatypes
16:11:34 <bitemyapp> zomg: that was a lot of it. That and defining API surface area with undefined function impls.
16:11:41 <zomg> Yep
16:11:48 <merijn> orion: In general I tend to 1) sketch out the data structures I want 2) start writing down function names +types for the API I want and start defining functions in terms of ym (unimplemented API). As I go I will refine types/datastructures and rely on GHC to catch any inconsistencies I introduce
16:12:17 <merijn> orion: Other than that, drawing diagrams of which components talk to/interact with eachother on paper is helpful as in any language
16:12:30 <acowley> bitemyapp: You should have written a Closure macro to write those newtypes
16:12:35 <merijn> You could use UML for that, but I just use an ad hoc simple drawing scheme
16:12:38 <bitemyapp> acowley: Clojure*
16:12:42 <LordBrain> using undefined is helpful, like error "todo" or whatever, to fill in stuff you haven't done yet, so you can type check it
16:12:42 <bitemyapp> acowley: also, nyuk nyuk. :|
16:12:57 <merijn> LordBrain: IN 7.8.2 you get typed holes, which is so much better
16:12:59 <quchen> Does anyone actually use UML? It's always something "others" seem to use.
16:13:08 <acowley> I think my autocorrect is learning PL terms over brand names
16:13:11 <zomg> I've used "UML"
16:13:19 <zomg> quotes because I'm probably using it wrong
16:13:19 <dmj`> orion: also, if you do as merijn said, a lot of data structure libraries have the same API so switching between Data.Map to Data.HashMap.Strict is a drop in replacement
16:13:22 <merijn> LordBrain: Unlike undefined you can't forget typed holes :)
16:13:26 <zomg> I just pick lines and shapes that I like
16:13:32 <zomg> and then draw things
16:13:38 <acowley> bitemyapp: I'm joking of course, but I do write CPP macros to generate things from time to time. It feels awesome and terrible.
16:13:43 <quchen> merijn: Typed holes create errors, don't they?
16:13:44 <hyPiRion> zomg: sounds like I'm drawing UML too then
16:13:44 <zomg> I recall they do have some defined meanings as well but I can't remember any of them so I just pick things that look nice =)
16:13:48 <solidus-river> orion: I do a lot of planning starting with what i want it to do, then design the system to be scalable / compartmentalized, then come up with what i want the interfaces to look up then define what i want my data to look like internally, split that up into modules and run with it
16:13:49 <merijn> quchen: Yes
16:13:51 <bitemyapp> acowley: Emacs macro in this case.
16:13:57 <merijn> quchen: But they also obey -fdefer-type-errors
16:14:02 <bitemyapp> acowley: so I guess I shouldn't have said, "I wrote it myself"
16:14:05 <bitemyapp> Emacs is part of "me" in my head.
16:14:06 <solidus-river> *look like
16:14:11 <LordBrain> if you never get back to a error "todo" then i guess it wasn't really necessary hahaha
16:14:19 <merijn> quchen: And typed holes are enabled by default :)
16:14:32 <acowley> bitemyapp: You should put a comment there saying you wrote an elisp macro so people don't judge you poorly.
16:14:34 <quchen> But -fdefer-type-errors isn't.
16:14:35 <solidus-river> orion: but what i plan is never what i end up writing so it might be futile
16:14:45 <solidus-river> :P
16:14:48 <zomg> I find I can keep even big interfaces and interlinked modules in my head so I don't do a whole lot of diagrams or stuff
16:14:56 <zomg> except if I have to communicate that sorta stuff with someone else
16:14:57 <merijn> LordBrain: http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/typed-holes.html
16:15:17 <bitemyapp> acowley: I didn't write an elisp macro.
16:15:23 <LordBrain> i dont have that version of ghc yet meretrix
16:15:24 * quchen usually imports an 'error'-like function from a module that contains only that. Don't have that module in the production branch, get errors when its functions are used.
16:15:26 <LordBrain> merijn
16:15:31 <bitemyapp> acowley: Emacs macros aren't always elisp, they can be recorded.
16:15:40 <merijn> LordBrain: You'll be motivated to get it after reading that :p
16:15:52 <LordBrain> i'm motivated but i'm motivated to stay too
16:16:12 * hackagebot cabalg 0.2.1 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.1 (DmitryMalikov)
16:16:40 <merijn> bitemyapp: FYI, with regards to that type. In the end that type was wrong because I was doing things wrong, it's a lot less complicated now
16:16:58 <volty> some big news as for haskell & gui ?
16:17:17 <acowley> After 3 days of not being able to compile, I got the refactor to build and only 70% of my tests broke!
16:17:19 <LordBrain> i use an old ghc while my collaborators use new ones, this keeps the code robustly compatible
16:18:03 <LordBrain> i actually have ghc-4.7, because i'm using what is distributed on debian stable
16:18:10 <acowley> What the what?!
16:18:25 <bitemyapp> merijn: *nods*
16:18:26 <acowley> Did they have functions in that version?
16:18:31 <merijn> I hope you meant 7.4
16:18:31 <bitemyapp> acowley: what'd you build?
16:18:31 <LordBrain> lol
16:18:41 <LordBrain> i mean 7.4 yes
16:18:49 <gdoteof> i am talking to an outside process through two named pipes; it seems that haskell's non-blocking IO makes it pretty difficult.. you can't just read from a file and have it block
16:19:04 <merijn> Code I will most regret writing when I try to understand it one year from now: join (liftIO p) >>= go p1
16:19:08 <quchen> GHC 4.8 changelog: Introduced a new "function" abstraction that allows mapping between values
16:19:11 <hyPiRion> LordBrain: Oh man, I thought you were using tape and punchcards for a second there
16:19:13 <gdoteof> so people use a system process to essentially cat stuff to the named pipe
16:19:22 <merijn> gdoteof: Huh? That should work just fine...
16:19:37 <merijn> gdoteof: Which non-blocking IO are you refering too?
16:19:42 <Maior> :t \x y z -> join (liftIO x) >>= y z
16:19:42 <acowley> Oh, I was really impressed by the claim of 4.7
16:19:43 <lambdabot> MonadIO m => IO (m a) -> (t -> a -> m b) -> t -> m b
16:20:14 <Maior> merijn: welp I'm lost
16:20:30 <Maior> but mayve
16:20:47 <acowley> GHC v1 - v3 were just some PHP that returned a 404 with the body text "LOL"
16:20:50 <quchen> Sometimes asking a question helps, Maior ;-)
16:21:13 * hackagebot X11 1.6.1.2 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.1.2 (DanielWagner)
16:21:13 <gdoteof> merijn: if you attempt to do an openFile on a named pipe it will fail if no one is listening
16:21:23 <merijn> Maior: If you're families with pipes (or not, perhaps) "p :: IO (Producer Text m r)", so liftIO lifts the IO into the same pipe as the Producer. Join then collapes the outer and inner into one and ">>= go p1" pass on the result
16:21:41 <Maior> merijn: I'm not at all familiar with pipes, but will have a read, thanks
16:22:00 <Maior> (well, pipes in the *n*x sense yes, not in the Haskell sense)
16:22:06 <quchen> Maior: Check out the Pipes.Tutorial module ♥
16:22:19 <acowley> Oh irony of ironies. My few remaining failing tests are things I haven't gotten around to implementing yet, they just error "LOL"
16:22:23 <bitemyapp> quchen: is that what you'd like me to mimic in Bloodhound?
16:22:30 <bitemyapp> acowley: what are you working on?
16:22:33 <Maior> oooh this looks fun, thanks
16:22:44 <acowley> bitemyapp: A compiler for GPU things
16:22:46 <quchen> bitemyapp: ;-)
16:22:52 <gdoteof> in any case, the problem i am having is that if the writer writes a "big" amount to the pipe, hGetContents hangs
16:23:03 <bitemyapp> acowley: what are you feelings/status around concurrent-machines? I found it very interesting.
16:23:15 <bitemyapp> quchen: 'tis a serious question mate, I want to know what your ideal haddocks look like.
16:23:16 <merijn> gdoteof: You probably don't want to use hGetContents type stuff
16:23:26 <bitemyapp> quchen: I was already using Pipes as my model library but I wanted to verify.
16:23:27 <acowley> bitemyapp: I think it's a pretty reasonable thing
16:23:33 <merijn> gdoteof: That does lazy IO and you lose all form of blocking
16:23:48 <acowley> bitemyapp: It needs somebody else to use it as I'm not exercising the whole thing
16:23:54 <merijn> gdoteof: Basically, you will only read from the pipe as you process the String, so maybe you're blocking the pipe
16:23:56 <bitemyapp> acowley: my only hesitation is that edward was talking as if machines was incomplete.
16:24:04 <merijn> acowley: Oh!
16:24:08 <acowley> bitemyapp: But it's a pretty simple way to have concurrent stages with the machines-style multiple inputs
16:24:09 <merijn> acowley: What type of GPU things?
16:24:10 <Maior> doingt his haskell port is so much fun
16:24:14 <gdoteof> merijn: what should I use instead of hGetContents
16:24:24 <gdoteof> i dont' want lazy io
16:24:30 <merijn> gdoteof: You discrete reads like hGetSome
16:24:36 <acowley> bitemyapp: Yes, he hedges on it a lot because nobody is pushing it like people push pipes and conduit
16:24:37 <bitemyapp> acowley: it interested me partly because I was a CSP fan for awhile.
16:24:46 <merijn> gdoteof: And actually, you may want to look into the pipes library for streaming IO
16:24:56 <acowley> bitemyapp: So there's also the sort of core question about the Plan/Machine split
16:24:58 <bitemyapp> acowley: how complete do you think it is? Do you think it's safe to use in production?
16:25:01 <gdoteof> merijn: i will take a look at both, thanks
16:25:01 <merijn> gdoteof: http://hackage.haskell.org/package/pipes-4.1.1/docs/Pipes-Tutorial.html
16:25:20 <acowley> bitemyapp: It depends how deeply you'd be nesting it
16:25:27 <acowley> bitemyapp: I use it for some high-level structuring
16:25:28 <quchen> bitemyapp: Well, I would say pipes has top notch documentation. It's nice to have, but not required. If you ask me, good enough docs should include an informal short description of what everything does, what it can be used for, maybe one or two trivial examples, the rationale behind having the definition in the first place ("why use this and not X") etc. It should enable you to use a library quickly without reading its source, basically.
16:25:37 <gdoteof> i'm not sure how to describe what's going on: https://gist.github.com/gdoteof/24b17f55de10f8b5a1b9
16:25:55 <acowley> merijn: I want it to produce specialized kernels for some vision processing
16:26:05 <bitemyapp> quchen: without...reading its source? We're talking about haddocks. it is the source.
16:26:07 <acowley> merijn: But it's turning out a bit more general than I'd aimed for
16:26:10 <merijn> acowley: From haskell code, or what?
16:26:14 <gdoteof> essentially if i use runSystemProcess to do "cat somefile" and then read std out from that process, it works correctly until std_out spits out more than ~70k characters
16:26:17 <acowley> merijn: Yeah, it's an EDSL
16:26:24 <merijn> acowley: Where do I subscribe to your newsletter? :>
16:26:39 <merijn> acowley: Using OpenCL or CUDA?
16:26:41 <quchen> bitemyapp: Haddock is the nice HTML generated from the source to me.
16:26:46 <acowley> merijn: It's not public yet because I keep smashing it to pieces and putting it back together (see previous comment about not building for 3 days)
16:26:49 <acowley> merijn: OpenCL
16:26:59 <gdoteof> the gist i linked to essentially can show the oproblem like this:  ./gist somefile  -- works if somefile <70k characters and breaks otherwise
16:27:19 <merijn> acowley: Which bindings are you using? I looked around but I found all of the crappy enough that I started working on my own bindings...
16:27:30 <bitemyapp> quchen: here's the part I'm not clear on. You seem to want individual components explained. What I don't understand is whether you want literate'ish source in the original source files with the haddock output or a separate Tutorial module that explains them outside of context but links back.
16:27:32 <geekosaur> gdoteof, hGetContents is lazy
16:27:41 <bitemyapp> quchen: I see those as distinct but sometimes coexisting styles of Haddock documentation.
16:27:51 <merijn> Although I may scrap OpenCL and go with CUDA, because I'm becoming convinced OpenCL is a waste of time until someone sells a card that actually implements OpenCL 2.0
16:28:10 <acowley> merijn: I have gobs and gobs of code that use the OpenCL package. You can see my CLUtil package on github for various helpers for working with that
16:28:18 <acowley> merijn: But that assumes you're writing your kernels in OpenCL
16:28:21 <gdoteof> i will checkout the pipes tutorial.  the other process writes one chunk of json at a time.  everything works great unless the chunk of json is too big
16:28:26 <acowley> merijn: CLUtil just makes working with images and buffers easier
16:28:44 <acowley> merijn: My current thing will sit on top of CLUtil which sits on top of OpenCL
16:28:45 <geekosaur> in particular, it's going to produce some fraction of the output (how much depends on lots of things) and then the first time there's a slight pause it will pass control to waitForProcess which will block because the process isn't done yet
16:28:48 <acowley> (the OpenCL package that is)
16:29:15 <gdoteof> geekosaur: ok.  what should i use to "get everything"
16:29:17 <geekosaur> and the process is blocked waiting for a read that will never happen because the reader is blocked in waitForProcess
16:29:19 <merijn> acowley: I looked at the OpenCL package, but with that level of abstraction I may as well write C >.>
16:29:33 <gdoteof> geekosaur: yes.  that is what is happening
16:29:36 <quchen> bitemyapp: I want whatever is teaching me well. Here's an example of remarkably bad documentation, http://hackage.haskell.org/package/QuickCheck-2.7.3/docs/Test-QuickCheck-Monadic.html -- Imagine how long it would take you to make use of those functions, compared to what would be the case when each had a one-sentence description of its purpose.
16:29:55 <bitemyapp> quchen: ah, agreed!
16:29:56 <acowley> merijn: Yes, it's very low level. If your complaint is with initialization and memory management, CLUtil does that
16:30:05 <bitemyapp> quchen: the contrast elucidates the matter nicely. Thanks :)
16:30:08 <geekosaur> I am not sure how you force it properly; generally you need to do something in IO (so it will be sequenced) which will "visit" the entire output
16:30:16 <acowley> merijn: CLUtil is a bit of a mess though as it's evolved significantly over its lifetime, which is why I haven't pushed it to hackage
16:30:23 <merijn> acowley: Where do I find it? :)
16:30:46 <geekosaur> but that will also strictify the entire string, which if you're looking at >70K output may not be what you want. then again if you're writing it this way you pretty much have to be strict
16:31:00 <merijn> acowley: Well, considering how nicely CommandQueue's map to monads it seems a waste to have such a painfully low level API for calling OpenCL
16:31:03 <gdoteof> what is 'strictify'
16:31:17 <volty> i restate my question: will there be anything new regarding gui in haskell ? why there isn't a decent gui  (a question, not blame || flame)?
16:31:19 <geekosaur> the whole thing is in core at the same time
16:31:22 <pyon> I have installed the latest versions of packages A and B, where B depends on A. I want to install C, which depends on an older version of A. When I do "cabal install C --dry-run", cabal says it would 1. install A-old, 2. reinstall B-new using A-old instead of A-new. Is there any way to tell cabal, *IN GENERAL*, to find some B-old instead of replace my existing B-new install?
16:31:27 <geekosaur> which is required by the way you are writing that
16:31:34 <gdoteof> geekosaur: i do want that; at least at this point
16:31:42 <geekosaur> you cannot lazily get the string *and* clean up the subprocess
16:31:42 <acowley> merijn: https://github.com/acowley/CLUtil/tree/cleanup
16:31:43 <quchen> bitemyapp: There may be modules without documentation, for example I have one in my own project; the module is generated by TH entirely (lots of lenses). You can either spend 3 minutes reading through it to realize "oh, it's only lens TH stuff", or 3 seconds reading the header that states exactly that.
16:32:02 <acowley> merijn: I actually haven't looked much at making smart use of Command Queues
16:32:22 <pyon> I know I could manually do "cabal install C B-old". But if there were lots of A_i's and B_i's, it would be painful to type "cabal install C B_1-old B_2-old B_3-old...".
16:33:01 <quchen> bitemyapp: The jump from zero to even stub documentation is remarkable. There's often no *need* to write elaborate tutorials like Pipes -- although it is very helpful to have such a thing. But when I open the main module of your lib, I should somehow be able to find out where to start, and to get the gist of the functions included.
16:33:04 <geekosaur> possibly you want to say something like Control.Exception.evaluate (hGetContents out >>= \x -> length x `seq` return x)
16:33:16 <geekosaur> but I'm not sure (nor am I sure what I wrote will typecheck...)
16:33:34 <h4x> I've written a function that uses the ceiling function
16:33:38 <h4x> but the signature is a bit ugly
16:33:45 <h4x> foo :: (Floating a, Integral b, RealFrac a) => a -> b foo n = ceiling $ (sqrt n)
16:34:01 <h4x> is it really necessary to put all those types in?
16:34:03 <merijn> acowley: I'll take a look at it tomorrow :)
16:34:21 <h4x> I know that the input will only be Integers
16:34:22 <merijn> h4x: Floating is a superclass of RealFrac, I think? So it seems redundant
16:34:41 <h4x> no, ghc insists
16:34:50 <merijn> h4x: If the input is only integers this type is wrong anyway
16:34:59 <merijn> h4x: Right now it doesn't even accept integers
16:35:09 <merijn> :t sqrt
16:35:10 <lambdabot> Floating a => a -> a
16:35:16 <h4x> merijn: it does accept integers
16:35:18 <merijn> @quote who.do.you.call
16:35:18 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:35:25 <merijn> h4x: Wanna bet?
16:35:35 <merijn> h4x: Try calling "foo (1 :: Integer)"
16:36:06 <h4x> merjin: so what happens when I call it with 'foo 1'
16:36:08 <h4x> ?
16:36:15 <merijn> h4x: Numeric literals arepolymorphic
16:36:18 <h4x> is this converted to a "RealFrac'?
16:36:19 <merijn> :t 1
16:36:19 <lambdabot> Num a => a
16:36:27 <merijn> :t 1 :: Ratio
16:36:28 <lambdabot>     Expecting one more argument to ‘Ratio’
16:36:28 <lambdabot>     Expected a type, but ‘Ratio’ has kind ‘* -> *’
16:36:28 <lambdabot>     In an expression type signature: Ratio
16:36:30 <merijn> eh
16:36:33 <merijn> :t 1 :: Ratio Int
16:36:34 <lambdabot> Ratio Int
16:36:39 <merijn> > 1 :: Ratio Int
16:36:40 <lambdabot>  1 % 1
16:36:45 <merijn> > 1 :: Double
16:36:46 <lambdabot>  1.0
16:37:10 <merijn> h4x: You're problem is fairly simple, though and consists of a few realisations
16:37:23 <merijn> h4x: 1) Most numeric functions return the same type as they accept
16:37:26 <merijn> :t sqrt
16:37:27 <lambdabot> Floating a => a -> a
16:37:54 <merijn> h4x: As you see, sqrt only takes Floating numbers and returns the same, incidentally, Int/Integer/etc are *not* Floating numbers
16:38:03 <h4x> ok, I get that
16:38:04 <merijn> > sqrt (1 :: Int) -- error
16:38:05 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
16:38:05 <lambdabot>    arising from a use of ‘GHC.Float.sqrt’
16:38:14 <merijn> h4x: So, as the quote says
16:38:23 <merijn> @quote who.do.you.call
16:38:23 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:38:27 <merijn> :t fromIntegral
16:38:28 <lambdabot> (Num b, Integral a) => a -> b
16:38:53 <merijn> fromIntegral converts any Integral into any Num type (including Floating, etc. which all have Num as superclass
16:39:00 <h4x> ok, got it
16:39:02 <merijn> > fromIntegral (1 :: Int) :: Double
16:39:03 <h4x> thanks
16:39:04 <lambdabot>  1.0
16:39:09 <merijn> :t sqrt . fromIntegral
16:39:10 <lambdabot> (Integral a, Floating c) => a -> c
16:39:19 <merijn> That should solve your issue
16:39:25 <merijn> :t ceiling . sqrt . fromIntegral
16:39:26 <lambdabot> (Integral a, Integral c) => a -> c
16:39:34 <merijn> :t ceiling . sqrt . fromIntegral :: Int -> Int
16:39:35 <lambdabot> Int -> Int
16:40:05 <alorente> I'm trying to build a project with profiling enabled. `cabal build` fails with "Perhaps you haven't installed the profiling libraries for..."
16:40:05 <alorente> How can I get the profiling libraries for those packages? The current obstacle is system-uuid-2.1.1 but I assume I need them for all my dependencies
16:41:02 <quchen> Delete all libraries, reinstall with profiling enabled. That's the quick solution.
16:41:39 <quchen> There are slower and more annoying ones. Many of us have tried going this way. We ended up deleting all libraries and reinstalling with profiling enabled ;-)
16:42:10 <gdoteof> geekosaur: amazing.  thanks.
16:42:19 <quchen> FWIW when you've got a standard GHC build, it comes with profiling already, so there's no need to reinstall your compiler.
16:42:29 <alorente> quchen: ok, thanks
16:43:04 <alorente> quchen: yeah the previous maintainers of this project felt we needed to not use haskell-platform and use a forked cabal and and and...
16:43:29 <quchen> Forked Cabal!?
16:43:44 <alorente> and the project won't build with vanilla cabal
16:43:52 <quchen> ಠ_ಠ
16:44:05 <alorente> agreed
16:44:27 <quchen> I'm fine with not using the Platform, it's just an easy to get collection of libraries. But forking Cabal should be punishable by Visual Basic
16:45:02 <glguy> Support for forked cabal is available in #forked-cabal
16:45:41 <alorente> haha
16:46:04 <joelteon> so now I need to take two TH types and get the resultant type as though a function of the first type were applied to a value of the second
16:46:11 <joelteon> is there a sane way to do that
16:59:07 <mgsloan> joelteon: Unfortunately, I don't think I've seen a sane way to do that.  type-sub-th and th-expand-syns are two packages that might be a bit of a start, though
17:01:32 <joelteon> no, neither of those help
17:01:51 <mgsloan> the only sane thing I can think of is calling out to ghci
17:01:56 <mgsloan> but that's pretty insane
17:02:18 <joelteon> yeah I'm basically implementing GHC in GHC
17:02:38 <mgsloan> Yup, I really wish more of GHC's power was exposed to TH
17:02:48 <mgsloan> it could eliminate tons of hackery
17:02:57 <jfischoff> here here
17:03:09 <jfischoff> err hear hear?
17:03:14 <joelteon> yep
17:03:37 <mgsloan> Haha, yeah, I know jfischoff knows, what with his modulespection package
17:03:54 <jfischoff> :)
17:04:08 <jfischoff> I need fix it to use qualified names
17:07:43 <mgsloan> joelteon: The syntax-trees package is an example of using hint to run ghci from TH
17:08:09 <joelteon> why would you do such a thing?
17:08:46 <mgsloan> It's pretty insane.  It translates haskell-src-exts trees to TH trees by pretty printing the HSE trees and then ast quoting them to ghci
17:09:05 <mgsloan> It also starts a new ghci whenever it does this :P
17:09:15 <mgsloan> would be much better to start up a global server for the task
17:09:37 <joelteon> does that actually start a ghci process?
17:09:42 <mgsloan> by insane i mean awfully clever :P
17:09:49 <mgsloan> I believe so, yes
17:09:53 <joelteon> that seems like a waste
17:09:57 <mgsloan> I benchmarked it, and it seemed to
17:10:03 <benzrf> hey
17:10:10 <benzrf> how can i reset what packages i have installed?
17:10:17 <benzrf> i have a bunch of conflicting versions and stuff
17:10:21 <benzrf> so i'd like to just start clean
17:10:27 <mgsloan> indeed, considering that reusing the current ghc session would allow you to access all the good stuff you want access to
17:11:48 <MitchellSalad> rm -rf ~/.ghc
17:14:51 <Maior> @pl \x -> a $ b $ x
17:14:51 <lambdabot> a . b
17:15:59 <benzrf> MitchellSalad: haha
17:16:06 <benzrf> will that have any unexpected consequences?
17:16:15 <benzrf> btw, smart constructors are just functions right?
17:16:36 <MitchellSalad> no it's perfectly safe
17:16:50 <MitchellSalad> if that doesn't work try rm -rf /
17:16:59 <MitchellSalad> i kid, i kid, it actually is safe
17:17:09 <benzrf> also .cabal yes?
17:17:29 <zcd> is there an idiomatic way to send maybe values into a different monad
17:17:40 <MitchellSalad> no
17:17:44 <benzrf> zcd: you mean like monad transformers?
17:17:47 <zcd> i'm using if isJust ... then ... fromJust be it seems a little crufty
17:18:01 <benzrf> ...use pattern matching
17:18:04 <Maior> zcd: gist your code?
17:18:10 <benzrf> zcd: what precisely do you mean by 'putting into another monad'
17:18:12 <ReinH> Cale: remember when you were talking about ridiculous math terms? I present you with http://en.wikipedia.org/wiki/Monstrous_moonshine
17:18:14 <benzrf> what type sig are we talking about
17:18:43 <Cale> Yeah, I know about that, or rather, I've heard about it :)
17:18:52 <ReinH> Cale: :)
17:19:50 <ReinH> :t maybe
17:19:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:20:53 <zcd> https://gist.github.com/zcd/f9ce83cbf741ac1a4f08
17:21:09 <ReinH> :t let u = undefined :: Either String Int in maybe u Right
17:21:10 <lambdabot> Maybe Int -> Either String Int
17:21:14 <tac_> @type \myb myf mymabea -> myb
17:21:15 <lambdabot> t2 -> t -> t1 -> t2
17:21:19 <zcd> and replyTo is String -> Maybe String
17:22:58 <Maior> zcd: 25: maybe (return ()) (privmsg chan) r
17:23:03 <Maior> should dtrt
17:23:25 <Maior> :t \x y -> maybe (return ()) x y
17:23:26 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
17:23:30 <zcd> oh right the maybe function, thanks
17:23:54 <MitchellSalad> or just case replyTo s of
17:24:38 <MitchellSalad> or when
17:29:16 <ReinH> pattern matching is pretty cool
17:29:32 <tac_> yes, it is the stuff of cool
17:35:12 <benzrf> hey
17:35:27 <benzrf> when could reads return a list of more than one element?
17:35:50 <dwcook> When the instance says so
17:36:10 <dwcook> I guess a good question then would be whether any of the instances in base do so
17:42:06 <benzrf> dwcook: reads operates on instances
17:42:08 <benzrf> oh >.<
17:42:13 <benzrf> i assumed it worked off of 'read'
17:42:17 <benzrf> @src reads
17:42:17 <lambdabot> reads = readsPrec minPrec
17:42:20 <benzrf> o_O
17:42:25 <benzrf> :t readsPrec
17:42:26 <lambdabot> Read a => Int -> ReadS a
17:42:32 <benzrf> :t minPrec
17:42:33 <lambdabot> Not in scope: ‘minPrec’
17:42:37 <benzrf> h-huh
17:42:40 <benzrf> > minPrec
17:42:41 <lambdabot>  Not in scope: ‘minPrec’
17:42:45 <benzrf> :|
17:42:49 <benzrf> :t reads
17:42:50 <lambdabot> Read a => ReadS a
17:42:55 <benzrf> k thats enough for now..
17:43:20 <dwcook> You can private message it too. /msg lambdabot whatever
17:44:34 <benzrf> @src readsPrec
17:44:34 <lambdabot> Source not found. Maybe you made a typo?
17:44:36 <benzrf> ok
17:44:44 <benzrf> is that a Read method
17:45:28 <dwcook> Yep.
17:46:06 <benzrf> ok
17:46:13 <benzrf> > readsPrec 1 "3"
17:46:14 <lambdabot>  []
17:46:17 <benzrf> o-o
17:46:20 <benzrf> > readsPrec 1 "3" :: Int
17:46:21 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
17:46:21 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
17:46:34 <benzrf> > readsPrec 2 "3"
17:46:35 <lambdabot>  []
17:46:39 <benzrf> ?
17:49:27 <dwcook> It's defaulting to ().
17:50:06 <dwcook> Without an explicit type signature here, there isn't enough information to know what type you want, so lambdabot took a guess.
17:50:17 <dwcook> > readsPrec 0 "()"
17:50:19 <lambdabot>  [((),"")]
17:52:52 <benzrf> ahihi:
17:52:54 <benzrf> *ah
17:56:17 <ivanm> I have a module that takes quite a while to compile; is it likely because I have a lot of definitions in there, or because I have a huge big datatype with lots of constructors (and various functions that pattern-match on it)?
17:59:44 <benzrf> ivanm: i do not think the size of the datatype would slow it down all that much...
17:59:51 <benzrf> overall content size seems much more likely to me
17:59:57 <benzrf> (but what do i know eh)
18:01:08 <pavonia> In my experience heavy type inference slows down the compilation notably
18:01:15 <benzrf> ahihi:
18:01:16 <benzrf> *ah
18:02:53 <ivanm> pavonia: hmmmm, shouldn't be much of that, unless it's the various parser stuff
18:23:15 <wolftune> how do I use ghci to find the definition of a function?
18:23:42 <LordBrain> there's :info
18:23:49 <LordBrain> and there's -ddump-types
18:23:59 <geekosaur> you don't, generally, since it can only show definitions if it loaded from source. :info will tell you a module though and then you can consult hoogle or hayoo
18:24:03 <LordBrain> :browse
18:24:14 <wolftune> oh ok
18:24:17 <LordBrain> you could use hoogle -i
18:24:24 <geekosaur> or use one of the hooks to add that functionality to ghci (goa?)
18:25:10 <LordBrain> i htink there's something that plugs hoogle in there.. but why really
18:25:28 <LordBrain> just as easy to keep another terminal open
18:25:47 <wolftune> ok thanks
18:26:00 <dmj`> you can use lambdabot too
18:26:03 <dmj`> @src filter
18:26:03 <lambdabot> filter _ []     = []
18:26:03 <lambdabot> filter p (x:xs)
18:26:03 <lambdabot>     | p x       = x : filter p xs
18:26:03 <lambdabot>     | otherwise = filter p xs
18:26:10 <LordBrain> nifty
18:26:39 <zzo38> If you ignore the "reify" function, then I think Data.Reflection.Reifies sort of resembles a modal necessity operator.
18:26:51 <dmj`> if you /msg lambdabot > 1 + 1 it'll open a private chat and you guys can talk for hours
18:27:06 <zzo38> (You can then make up a GADT which implements the N and K axioms.)
18:27:50 <zzo38> Does it looks like them?
18:29:00 <zzo38> Do you know much about modal logic?
18:34:18 <benzrf> :t reify
18:34:19 <wolftune> why liftM :: Monad m => (a1 -> r) -> m a1 -> m r   instead of     liftM :: Monad m => (a -> b) -> m a -> m b
18:34:19 <lambdabot> Not in scope: ‘reify’
18:34:21 <wolftune> ?
18:34:24 <benzrf> o_o
18:34:34 <benzrf> wolftune: does it matter?
18:34:39 <wolftune> i.e. why a1 and r in that type sig instead of a / b
18:34:49 <wolftune> benzrf: you tell me, I am pretty sure it doesn't matter
18:34:52 <benzrf> hmm
18:34:57 <benzrf> i think to match up with the other liftMs
18:35:00 <benzrf> :t liftM
18:35:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:35:02 <benzrf> :t liftM2
18:35:02 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:35:04 <benzrf> :t liftM3
18:35:05 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
18:35:12 <wolftune> oh ok
18:35:18 <wolftune> that makes more sense
18:35:46 <wolftune> lambdabot is pretty awesome
18:35:58 <zzo38> But, liftM is really same as fmap (and is a way to define fmap if you didn't already do so)
18:38:09 <LordBrain> i used to think it was documenting to use liftM to say "this is a monad"... but these days i just use fmap
18:38:19 <zzo38> benzrf: The "reify" I mean is in the "reflection" package, and is defined using unsafeCoerce to cheat and avoid needing an actual instance
18:38:36 <zzo38> LordBrain: I also always just use fmap instead
18:39:07 <benzrf> LordBrain: all monads are functors anyway
18:39:16 <benzrf> it hardly matters o:
18:39:45 <zzo38> All monads are endofunctors anyways, yes.
18:39:59 <LordBrain> i know, but the reverse is not true... so i guess technically if you are writing monad specific code i suppose you could argue it is documenting..but really i'm not sure because that means using another symbol too...
18:40:29 <zzo38> LordBrain: I think you don't need it much for documenting, but it is there if you want it, I suppose.
18:41:01 <LordBrain> yeah, i don't think it's much necessary either
18:42:15 <zzo38> "join" isn't a method in Haskell, but it ought to be; nevertheless I usually write the join function and then define >>= in terms of join and fmap, since it looks more clearly to me, that way.
18:42:34 <quchen> join will be part of Monad in 7.10.
18:42:36 <zzo38> (I also think >>= oughtn't be a method, but =<< ought to be a method instead.)
18:42:49 <zzo38> quchen: O, OK.
18:43:19 <quchen> Applicative will also be a part of Monad in 7.10 :-D
18:43:21 <zzo38> Since, =<< is like a kind of functor (from a Kleisli category to (->)), too.
18:44:08 <LordBrain> i remember when i took topology, the class defined composition from left to right, instead of the usual way... all the students griped, but he argued that actually it was everyone else who had it backwards
18:44:09 <zzo38> quchen: That works, too, although it isn't really the definition of a monad, it just happens to be that in (->) category, all monads are also applicative.
18:44:25 <zzo38> So I am not too sure if it is should be or not...
18:44:43 <quchen> zzo38: The actual reason is that it's proven most valuable to have this connection.
18:45:24 <zzo38> Yes it is useful to have, but, that can only work if it is, and it only is because of how I described.
18:46:36 <quchen> (With "(->) category", did you mean Hask?)
18:46:43 <LordBrain> if the lamda calculus people had his atitutde, we'd be writing let xs 2 take = [x1,x2]
18:46:56 <LordBrain> or something like that...
18:46:58 <carter> ?
18:47:07 <zzo38> You could possibly say the monad law is that =<< is a functor, is another way to make up a monad law???
18:47:15 <zzo38> quchan: Yes
18:47:36 <zzo38> LordBrain: How would that supposed to work?
18:47:40 <johnw> how is =<< a functor?
18:48:02 <johnw> Functors in Haskell are type constructors of kind * -> *
18:48:04 <zzo38> johnw: It is a functor from a Kleisli category into the base category.
18:48:23 <LordBrain> zzo, its not unheard of, some mathematicians write function application that way, they put the object first, then follow it with the function they are applying, so instead of f x it is x f
18:48:24 <zzo38> The "Functor" class in Haskell is only endofunctors on (->), not any other kind of functors.
18:48:48 <johnw> "endofunctors on (->)"?
18:48:49 <zzo38> LordBrain: Ah, OK, well I also always write like that, when writing a program in Forth
18:49:03 <byorgey> johnw: endofunctors on Hask
18:49:09 <johnw> ah
18:49:18 <zzo38> johnw: It is not necessary to know what it means, to write a program in Haskell, but it can help to understand the program.
18:50:28 <byorgey> johnw: indeed, (=<<) is the morphism part of a functor from Kleisli m to Hask
18:50:30 <zzo38> I do write program in Forth sometimes.
18:50:37 <zzo38> (Even though, some people hate it, but I don't hate it)
18:50:47 <LordBrain> zzo38, my topology teacher's justification was that this put it in order left to right like we are used to reading... here's x, now apply f, now apply g ... etc
18:51:01 <johnw> :t (=<<)
18:51:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:52:06 <johnw> ok
18:52:11 <zzo38> LordBrain: I like the justification of use in Forth, which is not having to do with reading, but that, you put it in an order of an operation.
18:52:38 <LordBrain> zzo38, well it's only "in order" if you consider things on the left to come before things on the right
18:53:03 <zzo38> LordBrain: They come like that, which is the way you type them in and the way they are ordered in the file in the computer.
18:53:26 <zzo38> (Of course it is the normal reading order too, but mainly it is because of the computer.)
18:53:29 <LordBrain> so implicitly forth is also referring to how we write words and sentences in english
18:53:46 <LordBrain> zzo38, that's actually culturally specific
18:54:03 <LordBrain> plenty of languages are written from right to left traditionally
18:54:17 <zzo38> LordBrain: Yes, but you don't write in English, "two three plus" if you mean the sum of two plus three.
18:54:40 <XrXr> Without loops, how can I make a program that keeps grabing input and putting out response? I'm new to Haskell XD
18:54:42 <quchen> I'd like two apples and two pears together in one bag, please.
18:54:45 <zzo38> LordBrain: In that case then you would also type and order in the computer in that way so it would be printed on the screen and paper right to left, too.
18:55:25 <zzo38> I don't hate Forth, and I also don't hate C and I don't hate BASIC and I don't hate SQL.
18:55:36 <c_wraith> What about php?
18:55:39 <zzo38> And I also don't hate Haskell either (although there are some things I don't like about it)
18:55:40 <LordBrain> hahahaha
18:55:52 <zzo38> c_wraith: PHP is terrible and I hate it
18:56:17 <hpc> https://www.youtube.com/watch?v=kc9f-VVQK3k
18:56:29 <LordBrain> i was laughing at php
18:56:39 <dwcook> XrXr: for a trivial case there's interact
18:56:41 <dwcook> @type interact
18:56:42 <lambdabot> (String -> String) -> IO ()
18:56:57 <dwcook> XrXr: you can also use recursion or Data.Monad.forever or the like
18:57:13 <dwcook> Control.Monad.forever *
18:57:26 <dwcook> (Data versus Control is arbitrary anyway :P)
18:57:27 <srbaker> heya folks
18:57:40 <srbaker> i'm working through LearnYouAHaskell
18:57:46 <XrXr> I've considered using recursion. It seems sketchy since it would take up stack space each time
18:57:50 <zzo38> interact and getContents and such thing is lazy I/O so therefore, it isn't a pure function
18:57:58 <srbaker> often, it gives a function def as:
18:57:59 <c_wraith> XrXr: that's not necessarily true
18:58:02 <srbaker> foo x = x + x
18:58:04 <dwcook> XrXr: it doesn't have to.
18:58:12 <c_wraith> XrXr: stack space use in haskell is very different from other languages
18:58:13 <srbaker> early on, it did: let foo x = x + x
18:58:20 <srbaker> if i leave out the "let" i get a parse error
18:58:25 <srbaker> but i seem to recall doing it without let yesterday
18:58:29 <srbaker> is there some scoping thing i'm missing?
18:58:37 <c_wraith> srbaker: ghci requires the let
18:58:42 <srbaker> ohhh
18:58:44 <dwcook> srbaker: outside of do blocks, let requires an accompanying in. e.g., let x = y in z
18:58:54 <dwcook> Oh, I misread
18:59:12 <LordBrain> sometimes layout can trip you up
18:59:14 <srbaker> c_wraith: is the reason why ghci requires the let understandable by a beginner?
18:59:15 <XrXr> c_wraith: does ghc make loop stuctures if it recognize it?
18:59:22 <dwcook> Ignore what I said for ghci's case anyway, it uses do block syntax and top level syntax. It's weird
19:00:18 <c_wraith> XrXr: if GHC reduces evaluation of something to purely evaluation of a function, it uses tail-call elimination to avoid creating a call stack entry
19:00:20 <LordBrain> ghci only requires the let if you are in an interactive session
19:00:41 <c_wraith> err, to *solely* evaluation of a function
19:01:14 <carter> return is just a goto / funcall in haskell
19:01:15 <carter> well
19:01:19 <dmj`> srbaker: if you understand monads yes, ghci lives in the IO monad, let syntax in any monad can be let x = y w/o a corresponding "in", ghc desugars this to include and in behind the scenes
19:01:20 <carter> yeah
19:01:35 <dmj`> * an "in"
19:01:43 <dwcook> carter: careful, that statement is ambiguous and one of its interpretations is wrong.
19:01:43 <LordBrain> if you are just using ghci to run a program without compiling to binary, then it's syntax is the same as ghc
19:01:47 <srbaker> dmj`: ah, thanks. that mostly makes sense, and it'll get clearer. thank you
19:01:55 <benzrf> dsfbenzrf@benzrf-laptop:~/codes/haskell/yesod/Test$ cabal sandbox init
19:01:55 <benzrf> cabal: unrecognised command: sandbox (try --help)
19:01:56 <benzrf> huh?
19:01:58 <carter> dwcook: ghc compiles to CPS :)
19:02:16 <carter> is what i mean
19:02:17 <benzrf> dmj`: not in any 'monad'
19:02:20 <benzrf> in do-notation
19:02:26 <benzrf> which is absolutely distinct >:O
19:03:10 <LordBrain> benzrf, older cabals dont have sandbox... so naturally what is your version?
19:03:29 <u-ou> > "ლ(ಠ益ಠლ)"
19:03:30 <lambdabot>  "\4314(\3232\30410\3232\4314)"
19:03:42 <LordBrain> i think you need 1.18
19:03:51 <benzrf> LordBrain:
19:03:51 <benzrf> benzrf@benzrf-laptop:~/codes/haskell/yesod/Test$ cabal --version
19:03:51 <benzrf> cabal-install version 1.16.0.2
19:03:53 <benzrf> :(
19:04:12 <LordBrain> the older thing was to use cabal-dev
19:04:17 <LordBrain> or something like that
19:05:06 <LordBrain> which was a separate package
19:05:11 <LordBrain> that had sandbox
19:05:45 <benzrf> >cabal install cabal
19:05:48 <benzrf> >starts installing
19:05:50 <benzrf> huh
19:06:01 <carter> don't you mean cabal install cabal-install?
19:06:10 <nisstyre> yeah that's the right one
19:06:10 <carter> yes the names are weird
19:06:19 <carter> @google cabal binary
19:06:19 <lambdabot> http://www.haskell.org/cabal/download.html
19:06:20 <lambdabot> Title: The Haskell Cabal
19:06:22 <carter> you can just DL the binary
19:07:05 <dmj`> benzrf: you're right, my mistake, "do" doesn't mean monad
19:07:18 <dmj`> > do { let { x = 4 + 4 } in x }
19:07:19 <benzrf> :-)
19:07:20 <lambdabot>  8
19:07:31 <benzrf> > do 'f'
19:07:32 <lambdabot>  'f'
19:07:34 <benzrf> hmm
19:07:43 <dmj`> > do do do do do do do do 4 + 4
19:07:44 <lambdabot>  8
19:07:47 <LordBrain> :t do 'f'
19:07:48 <lambdabot> Char
19:08:22 <croyd> :t do
19:08:23 <lambdabot> Empty 'do' block
19:08:25 <benzrf> > le de = id in do de do de do de do de
19:08:26 <lambdabot>  <hint>:1:7: parse error on input ‘=’
19:08:31 <benzrf> > let de = id in do de do de do de do de
19:08:32 <lambdabot>  <hint>:1:22: parse error on input ‘do’
19:08:35 <benzrf> aw
19:08:53 <dmj`> benzrf: but who uses "do" outside of moands? I think there is an Applicative-Do proposal...
19:09:07 <benzrf> do has no semantics
19:09:09 <benzrf> it is purely sugar
19:09:10 <dmj`> monads*
19:09:15 <benzrf> 'do expr' == 'expr'
19:09:17 <benzrf> precisely
19:10:57 <dmj`> benzrf: then (<-) is just sugar too right?
19:11:09 <benzrf> yep
19:11:38 <dmj`> benzrf: can you show me an example of how to use (<-) outside of a monadic context, like we did with do 3 + 3
19:11:45 <benzrf> you canta
19:11:47 <benzrf> *cant
19:11:51 <benzrf> it desugars to >>=
19:11:55 <wolftune> how's this for a valid statement: "Although there are ways to mix and match and redefine, the fundamental ability of Haskell programs to affect the outside world is limited by the actions and functions defined in the core of the language." ?
19:12:16 <benzrf> wolftune: yes. in the same sense as that is true of any language in existence.
19:12:29 <wolftune> benzrf: heh, right, of course
19:12:34 <wolftune> thanks
19:13:28 <XrXr> If I do let meow = putStrLn "purr" >> putStrLn "meow" >> meow in meow, it shouldn't produce an error at some point due to memory space right?
19:13:59 <solidus-river> what pattern do people use for error during IO
19:14:19 <solidus-river> i have a ton of IO actions loading config from the filesystem
19:14:59 <solidus-river> and for now I've just assumed that everything would be fine and loaded away, do i have to test at east junction to see fi there was an error or is there a nice way for me to log the first error that happens
19:15:13 <Clint> solidus-river: you might like EitherT
19:16:34 <LordBrain> i think i recall the applicative paper proposed [| f x y z |] notation, meaning f <$> x <*> y <*> z... i realize this conflicts with quasiquotes, but hwy was some bracket notation like this never implemented?
19:21:39 <carter> LordBrain: because no one implemented it
19:21:42 <carter> people are totally open to it
19:21:47 <carter> just
19:21:50 <carter> needs someone to do it
19:22:03 <bitemyapp> carter: is it worth it?
19:22:11 <carter> no clue :)
19:22:25 <carter> bitemyapp: many things have value just in the trying
19:22:27 <benzrf> hey
19:22:28 <benzrf> i did:
19:22:28 <benzrf> sudo cabal install cabal --global
19:22:30 <carter> other have value only by trying to measure em
19:22:34 <LordBrain> it's a nice notation, why not
19:22:34 <carter> benzrf: NOOOOF UKDJFKLDSJLKDSJDFKLSDLKJF
19:22:35 <benzrf> but my cabal remains un-updated
19:22:37 <benzrf> :_(
19:22:38 <carter> benzrf: NNOO
19:22:42 <carter> never ever ever use --global
19:22:42 <LordBrain> oh
19:22:42 <benzrf> D: ?
19:22:43 <carter> everrrrrrr
19:22:45 <benzrf> erm
19:22:49 <benzrf> i need to replace the global binary
19:22:50 <benzrf> >.<
19:22:54 <carter> benzrf: add ~/.cabal/bin to your path
19:22:57 <carter> its there
19:23:02 <LordBrain> we could have a general fold bracket notation
19:23:04 <carter> benzrf: whos ghc did you installl / what OS?
19:23:14 <benzrf> on ububnut
19:23:16 <geekosaur> applicative-quoters package claims to implement idiom brackets?
19:23:23 <benzrf> i got ghc from haskell-platform
19:23:31 <benzrf> i have cabal bin in my path
19:23:33 <geekosaur> also I think sugarhaskell supports it
19:23:46 <carter> benzrf: i gave you a link to DL new cabal-install
19:23:52 <geekosaur> (which is a general mechanism for adding syntactic sugar to ghc, iirc)
19:23:52 <carter> http://www.haskell.org/cabal/download.html
19:23:56 <carter> benzrf: add that to path
19:24:01 <carter> also never do a global --install
19:24:03 <benzrf> dont i want the cabal binary
19:24:04 <carter> evr
19:24:06 <benzrf> not cabal install
19:24:15 <carter> benzrf: they're the SAME THING
19:24:24 <carter> :)
19:24:47 <benzrf> uh.
19:24:56 <carter> cabal-isntall IS the cabal binary
19:25:01 <carter> *cabal-install
19:25:02 <benzrf> oh
19:25:03 <carter> its just the package name
19:26:54 <u-ou> how do mod and rem differ?
19:27:21 <carter> they differ when given negative args
19:27:41 <carter> and the latter is slightly faster when you are micro benchmarking and you actually care about the perf
19:27:47 <carter> note that most humans ever
19:27:56 <carter> will never write real code where that perf difference matters
19:28:13 <carter> benzrf: point being never --global install stuff
19:28:23 <carter> unless you're seting up a machine with some 'baked in " libs
19:28:55 <LordBrain> We could have a general fold bracket notation, so for example you specify the function you are folding in the begining of the bracket like [<*>|  f x y z |] becomes foldr (<*>) (fmap f x) [y, z] ... oh well maybe not :/
19:29:17 <carter> :)
19:30:01 <LordBrain> actually what do you think
19:30:06 <LordBrain> of that idea
19:30:50 <LordBrain> the fmap f x part maybe makes the generality less
19:30:51 <carter> type directed sugaring?
19:31:09 <carter> simon marlow has some plans to do a mini version
19:31:19 <LordBrain> but the idea was for writing any kind of fold, and using <*> just happens to turn it into the appliticative idiom brackets
19:31:26 <carter> where when you write stuff in do notation that can be desugared into just the applicative,
19:31:33 <carter> actually desugar it into the applicative
19:31:38 <LordBrain> yeah i saw that proposal
19:31:44 <carter> which is related
19:32:53 <LordBrain> i'm all for that, but sometimes people want to use a more 'functional' notation
19:32:54 <carter> thats said... type directed desguaring... always seems complicated to me
19:33:07 <benzrf> type directed desugaring?
19:33:11 <carter> yes
19:33:21 <carter> dont' worry,
19:33:36 <carter> bascially, instead of looking at the AST to design how to translate stuff,
19:33:38 <carter> you look at the types
19:33:47 <benzrf> huh
19:34:08 <carter> so a form of type directed compilation
19:34:10 <LordBrain> i'm not that familiar with the internals
19:34:31 <LordBrain> for all i knew regular do notation was type directed in that sense
19:34:49 <carter> nah
19:34:55 <carter> its totally syntactic
19:36:06 <LordBrain> true, as we saw earlier it doesn't even really imply monad as we might think it does when doing our fast and loose reasoning
19:36:09 <benzrf> do-notation could be a simple macro in the lisp sense without any introspection needed
19:36:27 <benzrf> it does not care about types at all
19:36:31 <benzrf> merely Prelude.>>=
19:36:31 <carter> if you enable {-#  LANGUAGE RebindableSyntax #-} and provide your own custom (>>=) in scope, will use that for do notation
19:36:49 <carter> benzrf: got the cabal-install sorted?
19:36:53 <benzrf> yep :-)
19:36:56 <benzrf> thanks man
19:37:12 <benzrf> i wonder if haskell has an Ant.Fugue module
19:37:13 <LordBrain> my sugar isn't type directed either tho
19:37:25 <carter> LordBrain: how so
19:37:45 <monochrom> in fact, it gets better: right inside that do-block, any time you perform "(>>=) <- xxx", that new >>= will be used for the rest of the do-block as well
19:37:57 <carter> monochrom: really?! :)
19:38:06 <jle`> haha
19:38:08 <monochrom> I haven't tried. I just heard.
19:38:16 <carter> monochrom: i bet tahts only with rebindable syntax enabled
19:38:27 <monochrom> yes, I mean that.
19:38:56 <carter> monochrom: sooo... every other bind could be a new op that lets me switch monads? :)
19:39:00 <carter> errrrmmm
19:39:01 <monochrom> "yo dawg, I heard you love programmable semicolon so much, I put programmable semicolon inside your programmable semicolon"
19:39:26 <monochrom> well, something about types has to be observed. but you can switch semantics.
19:39:45 <LordBrain> [func| a b c d e f ] = foldr func (fmap func a) [b,c,d,e,f]  ...
19:39:54 <monochrom> it is utter evil and black magic :)
19:40:11 <LordBrain> oops
19:40:15 <LordBrain> i think i screwed that up
19:40:43 <LordBrain> [func| a b c d e f ] = foldr func (fmap a b) [c,d,e,f]  ...
19:41:09 <LordBrain> i threw myself a bit because func is taking hte role of application
19:41:21 <LordBrain> and a is therefore taking the role of a function...
19:41:44 <LordBrain> Not sure if this generalized idiom bracket would be worth while or not
19:43:02 <LordBrain> it would be cooler if it was just a fold with a default value
19:44:04 <carter> LordBrain: this is too icky
19:44:19 <LordBrain> i suppose we could use a general fold, and have (pure f) be written in the brackets...
19:45:16 <benzrf> im going to sleep good night haskell people
19:45:21 <LordBrain> so [<*>| (pure f) x y z] ?
19:45:25 <benzrf> enjoy your selfs
19:45:30 <benzrf> :^)
19:45:33 <LordBrain> it's starting to get less and less sweet as a sugar tho
19:45:51 <carter> LordBrain: yeah.. it snot unform
19:46:50 <orzo> Is there a way to use record selectors to get maybe values rather than exceptions?  For example, I have a type: data FooBar = HasFoo { foo :: Int } | NoFoo and I want to use the 'foo' symbol to get Maybe Int, returning Nothing when supplied NoFoo.  I'm pretty sure i can do this by handling exceptions, but that seems going out of my way a bit
19:47:05 <LordBrain> but you could write [+| 1 2 3 4]  for sum [1..4]
19:48:31 <south> Hi everyone!
19:49:02 <carter> LordBrain: or i'm kinda meh on this idea now
19:49:07 <Sculptor> hi south
19:49:16 <south> if I have a monadic value m (), can I prove that m >> return () == m?
19:49:16 <carter> orzo: that sounds like a lens question
19:49:35 <carter> south: ... nop
19:49:42 <south> @carter dang it
19:49:43 <lambdabot> If you see loose strings that have to be tied down that are not nailed up, see me about it.
19:49:44 <carter> you can prove return >> m == m
19:49:51 <carter> you can prove return  ()>> m == m
19:50:49 <croyd> orzo: can you use something like "case foobar of HasFoo f -> Just f; NoFoo -> Nothing"?
19:50:51 <south> carter: is it possible with specific implementations?
19:51:00 <carter> south: ... no
19:51:06 <south> damn it
19:51:11 <carter>  south  lemme explain more
19:51:22 <carter> do a<- m ; return a === m
19:51:34 <carter> UNLESSS
19:51:39 <carter> south:  actually
19:51:51 <carter> your thing *is* true if m has the same type as return ()
19:52:02 <LordBrain> well carter, if not the foldr sugar, then just an applicative idiom bracket like was originally proposed
19:52:06 <south> Right, if the monad is constrained to m ()
19:52:09 <orzo> croyd: well i basically have a sum typ that i want to extract particular cases out of
19:52:12 <south> (I have a specific monad)
19:52:18 <carter> M ()
19:52:22 <south> (I'm operating on only values with m () )
19:52:26 <carter> ok
19:52:28 <carter> subjec to that
19:52:33 <carter> which you cant really enforce :)
19:52:53 <south> well it's done through just a type synonym
19:52:57 <jle`> i feel like if you have x :: m (); then () <$ x should be x
19:53:01 <orzo> right now, i could use Either, but i feel its somehwat likely there'll be more than two cases later, so ...
19:53:12 <monochrom> counterexample: "Just ⊥ >> return ()" is different from "Just ⊥".
19:53:27 <jle`> ah
19:53:35 <monochrom> but ⊥ is the only thing that stands in the way.
19:53:43 <carter> and no one cares about bottoms :)
19:53:49 <south> monochrom: What is bottom in the haskell sense, even?
19:53:55 <south> haha
19:53:56 <carter> :t undefined
19:53:57 <lambdabot> a
19:53:59 <south> ah
19:54:03 <south> of course
19:54:09 <carter> :t error "lol"
19:54:09 <lambdabot> a
19:54:18 <carter> :t let x = x in x
19:54:19 <lambdabot> t
19:54:26 <monochrom> Theorem: suppose m>>return() = m >>= \() -> return (), so you know that m is not pulling a ⊥ trick. then m>>return() = m.
19:54:26 <carter> all are bottoms
19:54:58 <LordBrain> every type has a bottom
19:55:10 <LordBrain> in haskell
19:55:46 <south> okay so what I'm not understanding about this, though, is what this even says about the type
19:55:57 <south> because if m >>= \() -> return ()
19:56:04 <carter> LordBrain: because of undefined / error "foo"
19:56:04 <LordBrain> it is meaningful because of strictness vs laziness...
19:56:16 <south> no no I mean
19:56:20 <carter> south: the \() -> return ()
19:56:40 <south> I know I'm missing something
19:56:48 <south> so \() -> return ()
19:56:51 <south> applied to ()
19:56:54 <south> == return ()
19:57:10 <south> actually
19:57:16 <south> Okay I think it get it, sorry :)
19:57:41 <south> Thanks everyone!
19:59:34 <jle`> bottoms are so weird
20:00:20 <carter> jle`: ignore them
20:00:22 <carter> its totally ok
20:01:02 <south> Oh, okay, here was my point of confusion! return a >>= f == f a, but then wouldn't m >>= \_ -> return () == return ()?
20:01:03 <jle`> but...equational reasoning...
20:01:14 <south> which almost always isn't m?
20:01:41 <carter> jle`: its morally ok
20:01:52 <carter> to reason equationally and ignore bottoms
20:02:06 <carter> heck, some of ghc's optimizations make *more* programs terminate
20:02:15 <carter> or was it the fusion stuff in vector
20:03:28 <XrXr> If I do let meow = putStrLn "purr" >> putStrLn "meow" >> meow in meow, it shouldn't produce an error at any point right?
20:03:42 <monochrom> ⊥ does not affect equational reasoning much, even when you include it.
20:04:35 <jle`> i see
20:05:08 <LordBrain> you type that so easily
20:05:28 <south> :O
20:05:41 <LordBrain> usally people type _|_ ...  i suppose i could put a search replace
20:06:15 <monochrom> considering that I have to type Chinese too, ⊥ and greek letters are a piece of cake.
20:06:22 <LordBrain> but'd still prefer to type bottom actually.. so what's yoru secret?
20:06:42 <monochrom> SCIM, \bot
20:08:17 <LordBrain> what does SCIM  stand for?
20:08:24 <LordBrain> i tried to find it, but so far... i'm empty
20:08:31 <south> Good night all
20:09:09 <redtricycle> How do I make an indexed array from a general list? i.e. I have [a, b, c, key1, cat, dog, mouse, key2, one, two, three, key3] and I want: myArray['key1'][0] to get me "a"
20:09:14 <monochrom> I see. it's website is problematic. apt-get install scim. or just browse the ubuntu or debian repos.
20:09:21 <redtricycle> and myArray['key3'][2] to yield "three"
20:09:35 <redtricycle> I'm going through the Data.List docs and don't see a function that jumps out
20:09:40 <redtricycle> Perhaps, "zip"
20:09:40 <redtricycle> ?
20:09:50 <c_wraith> redtricycle: what's the type of the operation you want?
20:10:11 <redtricycle> [a] -> [[a],[b],[c]]
20:10:44 <c_wraith> That type signature seems tough.  Where is it going to get values of type b or c?
20:10:48 <redtricycle> generally...but I'd like to have an array
20:10:52 <redtricycle> err
20:11:06 <redtricycle> [String]-> [[String],[String],[String]]
20:12:06 <redtricycle> or, [String] -> array
20:12:43 <conal> I'm confused about cabal sandboxes. Are they for developing libraries as well as apps? I set up a sandbox for my library and did 'cabal install --dependencies-only', 'cabal build' and 'cabal install'. The install goes to the sandbox as well. How do I get my library visible outside its own sandbox? I might be missing something basic. The cabal-sandbox tutorials I've seen don't mention a final 'cabal install'.
20:13:36 <monochrom> I don't think you can easily get the library out. it is not intended. as for executable, just copy out.
20:13:39 <c_wraith> conal: they aren't for working on libraries you want to have visible outside the sandbox
20:13:55 <conal> c_wraith: oh, thx. what are the for?
20:14:03 <LordBrain> thanks monochrom, I thought you were using a chat acronym, like IANAL = "I am not a lawyer"
20:14:03 <c_wraith> conal: though you can use cabal sandbox add-source to develop libraries along with things that depend on them
20:14:13 <carter> conal: good question
20:15:01 <conal> i'm working on a library and am getting package version conflicts among its dependencies. i thought sandboxes might be the way out, but now my library isn't visibly installed. puzzled.
20:15:24 <c_wraith> Generally, you put the sandbox in the binary you're building.
20:15:34 <c_wraith> Err, the executable
20:15:46 <conal> i'm building a ghc plugin, not an executable.
20:15:49 <c_wraith> And if you need to develop a library along with the executable, you add-source it
20:16:02 <c_wraith> Oh.  for that use, sandboxes probably won't work.
20:16:09 <jfischoff> I can’t seem to get transformers-compat to respect the -ftransformers3 flag when installing another package. Is it possible to pass dependent packages cabal flags?
20:16:19 <conal> oh, hm.
20:16:20 <carter> jfischoff: noppeeees
20:16:28 <carter> its something people have been mulling
20:16:32 <carter> but its kinda tricky
20:16:40 <davidthomas> I think generally, if you mean to share a library, get it up on Hackage and pull it into the other projects like anyone else would.  If you don't want to share it broadly, you can either set up a private hackage and use the same workflow, or do the add-source thing.
20:16:51 <jfischoff> hmm that is unfortunate
20:17:00 <carter> jfischoff: theres a few tricky bits to getting that
20:17:02 <carter> like...
20:17:30 <carter> this is actually one of the reasons why the cabal devs are slowly trying to roll the ball towards "nix, but for haskell packages"
20:18:43 <jfischoff> I wish I understood what nix does differently from cabal + ghc-pkg
20:19:33 <carter> jfischoff: well, currently cabal + ghc-pkg doesn't track ANY of the file / binary assets it installs
20:19:56 <carter> and what a nixy way woudl look like could mean, you could share dep builds between different sandboxes
20:21:17 <jfischoff> is ghc-pkg’s way of creating hashes different from nix’s?
20:21:38 <carter> probably
20:21:46 <carter> most nix pckages aren't haskell :)
20:22:00 <carter> i forget how the hashing works
20:22:31 <monochrom> concat a bunch of *.hi and apply md5, IIRC
20:22:44 <carter> https://ghc.haskell.org/trac/ghc/wiki/Commentary/GSoCMultipleInstances
20:22:50 <carter> monochrom: roughly
20:22:55 <carter> i think tehres some subtlties
20:23:42 <monochrom> I think the subtlties are in what goes into *.hi. at some point it was determined that some command line flags must go in, too
20:24:27 <carter> errm
20:24:27 <carter> idk
20:24:47 <carter> i know they cleaned up how hashing works to make it fully deterministic sometime in the past year
20:25:19 <monochrom> I see. I think I heard that too.
20:28:47 <carter> jfischoff: i think that wiki page lists some of the subtle qustions that aren't currentl handled
20:28:50 <carter> its ... a  lot
20:29:35 <jfischoff> yeah
20:30:22 <carter> so eventually cabal *will* be a MVCC ish package manager with pure builds
20:30:24 <carter> but not today
20:30:51 <carter> unrelatedly, i'm really bummed about how the haddocks for data family instances work
20:30:59 <carter> its better than none
20:31:07 <carter> but... i'm going to have to write EVEN more documentionat
20:32:08 <benbangert> so uh, how does one go about debugging a performance problem with haskell code?
20:32:30 <jfischoff> profiling
20:32:51 <conal> still puzzling. do people use cabal sandboxes for library development, or just apps/executables?
20:32:55 <carter> and bencharmsk
20:33:02 <carter> conal: mostly just testing and apps
20:33:03 <jfischoff> conal
20:33:07 <jfischoff> opps
20:33:17 <carter> auto complete fail?
20:33:18 <carter> :)
20:33:19 <jfischoff> mostly apps
20:33:30 <benbangert> hmmmm
20:33:40 <jfischoff> hit enter by accident, kid in one hand
20:33:42 <carter> conal: though... your library use case is a bit outside the norm :)
20:34:54 <conal> hm. i thought they were about solving the problem of incompatible dependencies, which applies to library dev as well as to app dev.
20:35:06 <carter> yes
20:35:09 <jfischoff> solving is probably to strong of a word
20:35:18 <carter> but doesn't let you use the lib build outside of the sandbox
20:35:27 <carter> it just means you evad cabal hell when doig the dev
20:35:41 <carter> well, you *could* install to user pkg db with some flags abuse I htink
20:36:21 <Luke__> is there a way to pass a monadic function to IntMap.alter?
20:36:44 <carter> :t alter
20:36:45 <lambdabot>     Not in scope: ‘alter’
20:36:45 <lambdabot>     Perhaps you meant one of these:
20:36:45 <lambdabot>       ‘IM.alter’ (imported from Data.IntMap),
20:36:50 <carter> :t IM.alter
20:36:51 <lambdabot> (Maybe a -> Maybe a) -> IS.Key -> IM.IntMap a -> IM.IntMap a
20:36:54 <carter> nope
20:37:00 <Luke__> thought so =(
20:37:12 <carter> unless youre saving a monadic value there
20:37:21 <carter> Luke__: maybe theres a lens for that?
20:37:36 <Luke__> i think I just have to do it manually
20:37:38 <Luke__> no big deal
20:49:23 <dmwit> Luke__: Is there a Traversable instance?
20:49:45 <Luke__> dmwit: ah yeah their is. good call
20:49:57 <Luke__> downside is it's lazy even for the strict IntMap
20:50:07 <dmwit> err
20:50:15 <dmwit> Not that Traversable helps when you know what key you want.
20:51:41 <Luke__> hard to beat alter
20:52:04 <conal> i'd sure appreciate help sorting out a dependency clash: http://lpaste.net/103907 . I'm unclear on what it's saying. clashing mtl versions? clashing transfomrers versions?
20:52:43 <conal> (my ghc 7.8.2 installation got corrupted, and i reinstalled fresh, and then ran into this version clash issue. been stuck on it for hours now.)
20:53:51 <carter> conal: what version of transformers
20:54:23 <conal> carter: are you asking which versions i have installed?
20:54:26 <carter> yes
20:54:31 <carter> if you just want things to wokr
20:54:32 <conal> carter: 0.3.0.0 and 0.4.1.0
20:54:36 <carter> install transofmers-0.3
20:54:52 <carter> theres a bunch of breakages still propagating around from that stuff
20:54:57 <carter> and botched worke arounds
20:55:02 <conal> ohh...
20:55:18 <carter> like 0.4.1.0 should be 0.5 strictly
20:55:21 <carter> wrt PVP
20:55:29 <kantu> I apologize if this is a commonly asked question, but if I want to draw stuff to a window in haskell, what's the easiest way to accomplish that?  there seems to be many options for GUIs, some actively updated, others not, accomplishing it through different means
20:55:36 <dmwit> But this is a dependency error, not a build error.
20:55:39 <carter> yes
20:55:44 <Cale> kantu: For something really simple, you might want to try Gloss
20:55:55 <conal> carter: should i hide/unregister 0.4.1.0 and try to fix the many resulting broken packages?
20:55:55 <kantu> it's probably going to be pretty simple
20:56:00 <dmwit> conal: It looks to me like you have a version of circat installed that it's trying really hard to use.
20:56:03 <carter> conal: rm ~/.ghc is the sanity way
20:56:12 <Cale> http://hackage.haskell.org/package/gloss
20:56:17 <dmwit> conal: It may be easier for cabal to make progress if you tell it several packages and allow it to do reinstalls with --reinstall.
20:56:19 <conal> carter: i can try, though i've done that a few times already today.
20:56:23 <benbangert> ok.... got profiling data.... just not sure what it means
20:56:27 <benbangert> a good chunk of my time is spent in GC
20:56:31 <carter> conal: first install transormers 0.3.
20:56:39 <dmwit> conal: e.g. cabal install --reinstall . circat transformers mtl # or similar
20:56:43 <carter> mtl 2.1.X
20:56:47 <carter> then the rest
20:56:48 <benbangert> basic summary of profile: http://paste.ofcode.org/32xe7duGZ38PjzdkNdXMvkR
20:56:51 <Cale> ah, not sure why the documentation hasn't generated for the latest version
20:56:51 <conal> carter: i have transformers-0.3.0.0 is that the one you mean?
20:56:54 <carter> yes
20:56:59 <conal> dmwit: thx
20:57:04 <conal> okay. here goes.
20:57:05 <carter> then install MTL 2.1.3.1
20:57:15 <carter> then the rest should be gravy
20:57:17 <Cale> kantu: Click the 1.8.1.2 version to get working documentation links
20:57:40 <kantu> the examples look pretty simple
20:57:44 <Cale> Yeah
20:57:54 <conal> carter: first hiding/unregistering 0.4.1.0, and allowing resulting package breakages?
20:57:56 <Cale> It's nice for just getting something on the screen quickly :)
20:58:03 <kantu> thanks!
20:58:11 <carter> conal: i'd just rm ~/.ghc to keep things simple
20:58:15 <conal> okay
20:58:18 <carter> but you could do that too
20:58:37 <carter> i tend to like directions that are markovian
20:58:54 <carter> :)
20:58:59 <djahandarie> conal, whenever you finish dealing with cabal hell, I'd be interested in what you think of Neel's paper "Higher-Order Reactive Programming without Spacetime Leaks".
20:59:28 <conal> djahandarie: iirc, it's not about FRP, despite the intro.
20:59:29 <carter> when was that paper published?
20:59:37 <carter> was that the icfp one last year?
20:59:46 <carter> its about the events stream computations?
21:00:08 <conal> carter: yes.
21:00:22 <carter> and rention life cycles of those events
21:00:30 <carter> or "blocking on the future"
21:00:50 <conal> carter: i removed ~/.ghc and did 'cabal install cabal-install'. right away, it goes for transformers-0.4.1.0
21:00:58 <carter> conal: nooooo
21:01:04 <conal> carter: no?
21:01:04 <carter> you PICK 0.3.0
21:01:08 <conal> how?
21:01:15 <carter> cabal install transformers-0.3.0.0
21:01:25 <conal> before cabal-install?
21:01:28 <carter> sure
21:01:33 <conal> okay
21:02:05 <carter> thence mtl
21:02:13 <carter> nb: you' still have your previous cabal-install install
21:02:20 <carter> ~/.ghc just wipes the pkg db
21:02:25 <carter> everything in ~/.cabal is still there
21:02:44 <carter> (i've been explaining this to people.... a lot this week)
21:02:57 <conal> carter: cabal says i already have transformers-0.3.0.0. if i say to reinstall, it tells me i'll likely break ghc-7.8.2. do it anyway?
21:03:03 <carter> oh
21:03:08 <carter> then install mtl 2.1.3.1
21:03:19 <carter> conal: could you paste your ~/.cabal/config ?
21:03:26 <carter> (with passwords redacted of course)
21:03:30 <conal> carter: sure.
21:03:37 <newsham> cabal hell :(
21:03:39 <carter> nah
21:03:45 <carter> this is ... different
21:03:56 <carter> conal: also your ~/.cabal/world file
21:04:21 <conal> carter: http://lpaste.net/103908
21:04:53 <conal> carter: http://lpaste.net/103909
21:05:17 <carter> add transformers == 0.3.0.0
21:05:20 <carter> to your world file
21:05:24 <carter> and things will start to work ok
21:05:34 <carter> i think
21:06:01 <conal> okay. reinstalling various packages now ...
21:06:11 <djahandarie> conal, hmm, it's trying to solve the same problem though, no? I thought it was quite an elegant solution, but on the other hand I'm fairly new to reactive programming so I figured I'd ask someone who actually knows what's going on for their opinion.
21:06:38 <carter> djahandarie: the subtly is ... neels stuff is for discrete time
21:06:50 <conal> exactly. :p
21:07:16 <carter> real "FRP" by conal 's measure, has a sensible way of doing continuous time
21:07:23 <carter> what satisfies that btw?
21:07:28 <carter> which libs? :)
21:08:02 <conal> djahandarie: http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language
21:08:14 <conal> carter: fran did
21:08:24 <conal> carter: i think yampa did
21:08:37 <carter> netwire / reactive-banana / sodium  ?
21:08:54 <conal> carter: not last i looked. i think heinrich at least tried.
21:09:29 <conal> carter: what is the ~/.cabal/world file about?
21:09:38 <carter> i forget
21:09:44 <carter> its a set of "installtion constraints"
21:09:56 <carter> giving shared hints about what your installatino prefs are
21:11:40 <carter> i think the first time you install something with a specified version, it switches from -any to ==$VERSION
21:12:46 <carter> conal:  hrmm http://hackage.haskell.org/package/sodium-0.10.0.2/docs/FRP-Sodium-Context.html#t:Reactive thoghts?
21:13:25 <conal> djahandarie: the importance of continuous time is often overlooked or dismissed. to me, it's about naturalness and modularity. just like the modularity of spatial resolution independence and the use of infinite data to modularize (as in "Why functional programming matters").
21:14:14 <conal> carter: sounds non-denotative.
21:14:29 <carter> yeah... i'm looking at it and its looking ugly
21:14:36 <carter> what does denotative mean for you?
21:14:48 <carter> is the Vector type class denotative?
21:15:23 <conal> carter: see http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882 for pointers.
21:16:02 <conal> carter: "denotative" is landin's suggested replacement for ill-defined terms like "functional" and "declarative".
21:16:24 <carter> ok
21:16:28 <conal> carter: he also uses the term "genuinely functional"
21:16:32 <carter> ok
21:17:11 <conal> carter: related: http://conal.net/blog/posts/is-haskell-a-purely-functional-language
21:17:25 <newsham> conal: i had a question about that recently..  modelling something naturally with a continuous function vs. discrete.. the context was a little diff..  lets say you have an interface to take a picture  makePic :: (Double -> Double -> Color) -> Filanem -> IO ()      for example..     and you have a procedure for making pictures that is    Double -> Double -> IO Color,   how do you plug them together without having to do some kind of memoization?
21:17:25 <carter> same page ? :)
21:17:29 <conal> carter: and http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
21:18:30 <newsham> err i guess it wasnt exactly to do with discrete vs. continuous, rather to do with the interface of a function
21:18:35 <conal> carter: omg. conflict resolved. my libraries are building and working again. you're my hero.
21:19:13 <hoverbear> How can I fix this issue? https://gist.github.com/Hoverbear/dbb6fcb3c4cb6ff2de0c Cabal is breaking on `System.IO.Temp` Mac OS X 10.9.
21:19:18 <conal> newsham: you want to use IO *and* compose?
21:19:45 <newsham> :)
21:20:01 <conal> newsham: backus's turing award paper explains the deep conflict between imperative programming and principled composition.
21:20:20 <conal> newsham: and it applies to haskell's IO just as much as to fortran.
21:23:14 <conal> newsham: is there a useful non-IO version of your question?
21:23:23 <carter> hoverbear: rm ~/.ghc ; cabal install transformers-0.3.0.0 ; cabal install mtl-2.1.3.1
21:23:33 <carter> hoverbear: then everything should be happy
21:23:44 <carter> you may already have transformers installed
21:23:49 <hoverbear> carter: So I need to reinstall all my packages to fix this one?
21:23:54 <carter> well
21:24:02 <carter> hoverbear: more like, these directions work
21:24:09 <carter> and i'm not doing custom directions :)
21:24:32 <carter> hoverbear: also cabal has parallal package builds now
21:24:35 <carter> so the wait aint so bad
21:24:50 <carter> i like giving directions that work for everyone, always
21:24:59 <djahandarie> conal, I guess it would be nice to see some concrete examples of when the discrete approach results in poor composability. Have you already complied some somewhere?
21:25:17 <carter> djahandarie: physics
21:25:18 <carter> :)
21:25:26 <hoverbear> carter: Definitely. I'm just getting frustrated at how every time cabal bungles (which for me has been 2/5 runs) I need to reinstall basically all my packages.
21:25:35 <carter> hoverbear: nope
21:25:38 <carter> not cabal bungling
21:25:45 <carter> its people punting on doing PVP upper bounds
21:25:50 <conal> djahandarie: think about why we use vector graphics (outline fonts, PDF & SVG) instead of raster graphics.
21:26:04 <carter> and then breaking changes landing upstream
21:26:09 <carter> and those package sans upper bounds busting
21:26:36 <carter> hoverbear: i'm prolly going to be theone who abuses my trustee powers to make a fix
21:27:05 <conal> djahandarie: for modularity, if we have space, we want spacial transformation. which means we can't know how to discretize/sample up front. only *after* composition.
21:27:51 <conal> djahandarie: same thing for infinite data structures. for modularity, we mustn't make assumptions about how much of the result will be examine elsewhere.
21:28:30 <carter> conal: has anyone tried to do that for adaptive mesh gen for physics?
21:28:34 <conal> djahandarie: another telling signs the the extreme simplicity of algebraic laws that hold for infinite & continuous time & space, as opposed to finite and/or discrete.
21:28:53 <conal> carter: don't know. probably.
21:29:20 <carter> conal: i'm about to write my sparse array instances
21:29:24 <carter> its... terrifying
21:29:29 <carter> i actually have a story for sparse arrays
21:30:00 <djahandarie> conal, okay, thanks for the thoughts, I will go meditate on this.
21:30:20 <conal> djahandarie: enjoy. and feel free to follow up.
21:30:38 <conal> djahandarie: http://conal.net/blog/posts/why-program-with-continuous-time/
21:33:42 <newsham> conal: not really.. the question came up with some homework someone asked a question about here a few days ago.
21:33:54 <newsham> I think IO is a big part of the problem in the question
21:34:20 <conal> newsham: yeah. it's a much more fundamental problem than memoization.
21:34:49 <newsham> they had to use some gfx lib which took  Int->Int->Color and made a picture,  and they had to use a scheme interpretter they wrote to generate Int -> Int -> IO Color
21:35:15 <newsham> and it made me think of how nice of an interface that is for making pictures but how hard itmust be to use in many practical situations
21:35:33 <conal> newsham: hard because of the IO?
21:35:39 <newsham> yah
21:35:57 <newsham> w/o having an intermediate buffer, of course..
21:36:12 <conal> maybe better to challenge the requirement than satisfy it.
21:36:47 <newsham> I get where your coming from..  but not in my power when chatting w/ someone about homework
21:38:16 <conal> newsham: i meant better for the student. though the prof might not agree.
21:39:11 <sagittarian> hey does anyone here use emacs and haskell-mode?
21:39:28 <conal> newsham: the second big mistake is to use Int here (anti-modular)
21:39:36 <sagittarian> when i try to indent i get a message about haskell-mode-hook being nil, and i don't know what to set it to
21:48:55 <hoverbear> carter: I'm just going to blame homebrew.
21:49:04 <XrXr> Why is the Haskell Platform so behind in release schedule? http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
21:49:14 <carter> hoverbear:? don't use homebrew
21:49:24 <hoverbear> carter: Yes, exactly. I need to fix that.
21:49:34 <carter> install the bin dist and dl the cabal install
21:49:38 <carter> hoverbear: did you follow my directions
21:49:41 <jfischoff> XrXr: partially because GHC was late
21:49:47 <carter> 6 months late!
21:49:48 <jfischoff> GHC 7.8.2
21:49:50 <hoverbear> carter: Going to change a bunch of other things. :)
21:49:59 <carter> ok
21:50:03 <carter> @google ghc binaries
21:50:04 <lambdabot> http://www.haskell.org/ghc/download_ghc_7_6_2
21:50:04 <lambdabot> Title: GHC: Download version 7.6.2
21:50:08 <carter> ewwww
21:50:12 <carter> @google ghc binaries 7.8.2
21:50:13 <lambdabot> https://www.haskell.org/ghc/download_ghc_7_8_2
21:50:15 <carter> better
21:50:30 <XrXr> Next release will be in 6 month then? ;)
21:50:36 <carter> hah
21:50:42 <carter> help us write patches
21:51:13 <XrXr> I wish I'm competent enough to do that haha, still learning
21:52:46 <carter> best time to get started
21:52:46 <carter> help on hackage / haddock / cabal / whatever
21:52:46 <carter> try stuff
21:52:46 <carter> find weird bugs
21:52:46 <carter> help patch
21:52:46 <carter> idk
21:52:57 * carter Open source jazz hands
21:53:28 <dpld> @djinn Maybe a -> Maybe a
21:53:29 <lambdabot> f a = a
21:53:36 <jfischoff> XrXr: is suprisingly easy to modify
21:53:42 <jfischoff> err ghc
21:54:11 <carter> yup
21:54:12 <carter> that too
21:54:27 <carter> you can even try to build a GHC with a custom BASE/ Prelude
21:54:37 <carter> its funn seeing what works or doesnt work
21:54:52 <chrisdotcode_> guys, do we have any list-list structures that are O(1) for existence checking? Vectors are O(n). Are there hash somethings?
21:55:15 <chrisdotcode_> (essentially O(1) `elem`)
21:55:20 <XrXr> interesting. I might try that later
21:55:23 <carter> hash + array lookup
21:55:37 <carter> chrisdotcode_: whats the use case
21:55:50 <LordBrain> there are probably things on hackage
21:55:58 <carter> hyper log log!
21:55:59 <carter> :)
21:55:59 <chrisdotcode_> carter: check to see if this element is in this 6,00 item list
21:56:01 <carter> bloomfilters
21:56:09 <jmcarthur> chrisdotcode_: does it have to be a list?
21:56:10 <carter> hash tables
21:56:11 <chrisdotcode_> no
21:56:14 <chrisdotcode_> it has to be list-like
21:56:17 <jmcarthur> chrisdotcode_: Data.Set?
21:56:19 <jmcarthur> ah list-like
21:56:19 <chrisdotcode_> and there is more than one element check
21:56:23 <jmcarthur> so it must at least be ordered
21:56:26 <LordBrain> Data.Set is logrithmic
21:56:36 <jmcarthur> LordBrain: still soft-O constant time ;)
21:56:36 <chrisdotcode_> no, preserving order isn't necessary
21:56:47 <chrisdotcode_> just checking to see if a set of items in list A are in a bigger list B
21:56:47 <jmcarthur> chrisdotcode_: ah, then Data.Set sounds good
21:56:50 * hackagebot highlighting-kate 0.5.7.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.7.1 (JohnMacFarlane)
21:57:01 <chrisdotcode_> wait... isn't that just intersection?
21:57:04 <XrXr> Data.HashSet ? if it is what I think it is
21:57:14 <jmcarthur> LordBrain: you're never really going to get worst case constant time membership testing with any data structure
21:57:24 <LordBrain> true
21:57:45 <jmcarthur> :t S.member
21:57:46 <lambdabot> Ord a => a -> S.Set a -> Bool
21:57:48 <jmcarthur> chrisdotcode_: ^^
21:58:01 <chrisdotcode_> jmcarthur: so Data.Set then? :)
21:58:07 <jmcarthur> yes!
21:58:25 <chrisdotcode_> are sets implemented with Trees?
21:58:27 <jtcwang1> Hey guys, I have an IO function that will do a lot of checks on input and on the file system. I was planning to stack an EitherT on it, but after some research it seems to be a lil incomplete
21:58:29 <jmcarthur> they are
21:58:36 <LordBrain> try it, if it dont work, you can do a hash
21:58:37 <chrisdotcode_> that explains the O(log n)
21:58:39 <jtcwang1> what other alternatives are there for me? what would you recommend?
21:58:44 <chrisdotcode_> we don't have HashSets? :'o
21:58:54 <jmcarthur> chrisdotcode_: hashsets are not constant time anyway :P
21:59:08 <jmcarthur> chrisdotcode_: the common claims that they are are just misleading
21:59:16 <chrisdotcode_> jmcarthur: so why aren't they?
21:59:57 <jmcarthur> chrisdotcode_: there are a couple arguments i could make. in the worst case sense clearly this can't be true, since the buckets could have more than one element anyway
22:00:17 <LordBrain> well
22:00:30 <LordBrain> you can get constant time, if you use a large array
22:00:37 <jmcarthur> chrisdotcode_: so you find the right bucket in "constant time" (i will explain the quotes in a sec), and then still have to find the right element in at best log time
22:00:52 <jmcarthur> LordBrain: not quite true, due to the next thing i'm about to say
22:01:31 * LordBrain waits
22:01:34 * chrisdotcode_ waits
22:01:40 <Ralith> jmcarthur: generally items per bucket has a hard ceiling...
22:02:29 <jmcarthur> chrisdotcode_, LordBrain: assume there are enough buckets that none have multiple elements. that implies that the hash function must be able to uniquely identify each one. that means there must be enough information in the key to uniquely identify each bucket. that's going to be logarithmic in the number of buckets, and that corresponds exactly to the amount of data the hash function will have to process
22:03:07 <jmcarthur> so even just the hash function isn't constant time
22:03:41 <jmcarthur> it's linear in the size of the key, which is the same as logarithmic in the number of keys/buckets
22:04:00 <chrisdotcode_> hrm...
22:04:21 <LordBrain> suppose you're key is a word8, you can use it as an unsigned short index to an array, the hash function is id which is constant
22:04:25 <bms1> jmcarthur: That's a good argument, but possibly not quite a practical answer. CPUs can look at entire words at once - 32 bits, and it's hard to imagine hitting the ceiling of 32-bit keys
22:04:35 <jmcarthur> LordBrain: right. you bounding the number of keys you can have
22:04:37 <jmcarthur> *you're
22:04:46 <jmcarthur> LordBrain: we can do the same tricks with any other data structure though
22:05:04 <jmcarthur> LordBrain: Map Word8  also has constant time lookup/insert/delete by the same argument
22:05:12 <bms1> but you don't go any faster if you do many comparisons of things which don't utilize the full range of values in a word
22:05:13 <LordBrain> well, you're always bounded in reality... after all you've only got 8 gigs of ram to spend
22:05:19 <chrisdotcode_> jmcarthur: so would a hashset be faster than regular set, even if it isn't *exactly* O(1)?
22:05:20 <jmcarthur> right
22:05:31 <jmcarthur> all this to say... log factors are often not worth worrying about
22:05:46 <jmcarthur> hashsets are often faster than sets implemented as trees
22:05:56 <jmcarthur> but not due to asymptotics
22:06:04 <jmcarthur> that's all i'm really trying to say
22:07:14 <jmcarthur> chrisdotcode_: btw, if you really want a hashset, check out the unordered-containers package
22:07:24 <jmcarthur> but i really think it's not something to worry about
22:07:34 <shachaf> log(n) is O(1) when n ≤ 2^64 hth
22:07:39 <chrisdotcode_> jmcarthur: nah, I don't *NEED* the speed
22:07:51 <chrisdotcode_> but thanks for the Data.Set recommendation :)
22:07:52 <shachaf> (That's also true of any other function of n, of course.)
22:07:59 <LordBrain> yeah, but it's like... i think you're understimating the developers, we're not all just using hash willy nilly everywhere... if we're going thru the trouble to find a hash then it's likely in performance critical code and we're looking for every little inch we can get and we need the power to use any trick we can
22:08:21 <jmcarthur> LordBrain: i'm not sure what you're point is
22:09:02 <jmcarthur> LordBrain: all i'm saying is that the difference between O(1) and O(log n) is not the reason a hashset might be faster than a binary search tree.
22:09:20 <jmcarthur> there are many other good reasons for them to be faster already.
22:09:45 <cosmicexplorer> what's an example of the other reasons they might be faster?
22:10:04 <carter> less breanching
22:10:31 <carter> every step in Ord backed structure needs to do a compre on a possibly nontrivila thing
22:10:33 <jfischoff> I’m reading: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Packages/MultiInstances. I’m trying to understand this sentence: how can we tell when something is unnecessary? This is actually rather hard because unlike Nix we do not track every random executable that the user compiles.
22:10:51 <jmcarthur> hash functions are often cheaper than comparison functions. could be more cache efficient. could have fewer branches. etc.
22:10:59 <jfischoff> does that matter for static libraries? or only for shared libraries?
22:11:44 <jmcarthur> (interestingly, the remark about comparison functions leads to the conclusion that binary search tree lookup is actually (log n)^2)
22:11:52 * hackagebot generic-church 0.2.0.0 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/generic-church-0.2.0.0 (jozefg)
22:12:18 <jmcarthur> (but again, i wouldn't say this is the reason they are slower than hashsets in practice a lot of the time)
22:12:53 <bms1> jmcarthur: Why is that? Are you assuming that the number of distinct elements also grows as O(n)?
22:12:59 <carter> jmcarthur: consider pandoc whn you dont build it with -fembed_data_files
22:13:24 <jmcarthur> bms1: what are you asking why of? the (log n)^2 thing?
22:13:35 <bms1> jmcarthur: yes
22:13:43 <carter> jfischoff: consider pandoc whn you dont build it with -fembed_data_files, so it depends on an asset in ~/.cabal/share
22:13:43 <LordBrain> a taylor made solution is probably going to get the best performance, if you can represent the keys as somethign that fits in an unboxed register, great, if there are only 6000 keys, then you could just use an array...
22:14:06 <LordBrain> i mean if it's that critical
22:14:49 <jmcarthur> bsmt: is discussed above, the key you are searching for must necessarily be O(log n) when n is the number of keys, so the comparison function is O(log n). you will do that log n times (the depth of the tree)
22:14:59 <jfischoff> carter: it was referring to packages though. sorry didn’t include enough context
22:15:13 <jmcarthur> LordBrain: yes
22:15:13 <carter> pandoc is a package and a lib both :)
22:15:19 <carter> afaik
22:15:40 <zcd> hi, i'm working through the haskell irc bot tutorial (http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#Roll_your_own_monad) and was wondering why they use a ReaderT Bot IO instead of just a Reader Bot
22:15:56 <zcd> is it because of the printing to the handle and stdout involved?
22:16:15 <LordBrain> There are various solutions out there on hackage i am sure, using ints or whatever
22:16:22 <jmcarthur> all sorts
22:16:38 <jmcarthur> e.g. Data.IntMap is a pretty fast purely functional patricia trie
22:16:39 <jfischoff> carter: sure but it why does it matter if pandoc depends on share file, if you want to garbage collect pandoc?
22:16:52 <carter> so you can uninstall it :)
22:16:52 <jfischoff> pandoc the library, not the executable
22:17:07 <carter> the idea is a proper package manager knows where all the assets are
22:17:08 <jfischoff> that is not what the comment is talking about
22:17:13 <jfischoff> I don’t think
22:17:14 <carter> ok
22:17:19 <carter> well, i think its rrelated
22:17:22 <carter> and its 1am here :)
22:17:29 <jfischoff> it is talking about removing packages not there related files
22:18:00 <jfischoff> granted I don’t really understand what they are referring to
22:18:23 <carter> the issue they're referring to is that cabal currently doesn't know / remember what its installed
22:18:31 <carter> at all
22:18:33 <jmcarthur> there's rarely such a thing as a constant time lookup. even memory access is O(log n) in the amount of memory you have, if you want to get really pedantic.
22:19:38 <jfischoff> ghc-pkg cleanup seems unrelated to what other artifacts, unless we are referring to shared libraries
22:19:47 <jfischoff> other artifacts are installed
22:19:56 <carter> yes
22:19:58 <carter> dk
22:20:42 <jfischoff> honestly I can’t see how there can any automatic cleanup of packages.
22:21:03 <jfischoff> I can have a library installed with no children just to mess around with ghci
22:21:07 <LordBrain> i dont agree jmcarthur, grabbing the nth value of an array is O(1)...
22:21:22 <jfischoff> for all the package manager knows they are all like that
22:21:33 <jmcarthur> LordBrain: it is not. there are at least two reasons it is log n:
22:21:35 <tromp> memory has same access time whether you have 1GB or 64GB
22:21:47 <LordBrain> uh...
22:21:52 <LordBrain> that's not the point
22:21:56 <tromp> assuming it's not in L3 cache
22:21:57 <LordBrain> that's not what O(1) means
22:22:14 <LordBrain> O(1) does not mean instantaneous
22:22:16 <jmcarthur> tromp: this is all with the assumption that the amount of memory is bounded by the architecture though
22:22:23 <jfischoff> the whole tracking the executable thing seems useless for deciding if a package can be garbage collected.
22:22:42 <tromp> memory is limited by your motherboard
22:22:56 <jmcarthur> tromp: it's the same argument as the one that says Data.IntMap is constant time
22:22:57 <tromp> i'm actually limited to 32GB
22:23:18 <tromp> is IntMap tree or hash based?
22:23:29 <jmcarthur> LordBrain: anyway, reason (1): page tables have a tree structure
22:23:57 <jmcarthur> LordBrain: reason (2): different levels of caches
22:24:06 <jmcarthur> tromp: it's a trie
22:24:36 <tromp> a trie that branches on bytes of an int?
22:24:41 <jefimenko> so it's still O(1) regardless of the memory position that you're accessing
22:24:48 <jmcarthur> tromp: so it's O(k) in the size of the key, which is going to be a machine word in practice
22:25:01 <jefimenko> you're saying that access gets slower like log n where n is the size of the memory
22:25:09 <jmcarthur> jefimenko: it's O(1) if you just say the amount of memory is a constant...
22:25:11 <jefimenko> but that's fixed on a machine.
22:25:17 <jefimenko> it is constant on a machine though
22:25:22 <jmcarthur> jefimenko: not really.
22:25:37 <jmcarthur> jefimenko: you mean your machine doesn't get slower when it starts swapping because it ran out of ram?
22:26:09 <jefimenko> of course it does, but then all bets are off when you're thrashing
22:26:13 <jefimenko> your OS isn't using real memory anymore
22:26:14 <jmcarthur> jefimenko: (and the same thing happens with your L1/2/3 caches)
22:26:22 <jefimenko> it's giving the illusion of more memory
22:26:39 <jmcarthur> jefimenko: no, your memory is just a cache for the larger amount of storage available to you
22:26:51 <jmcarthur> jefimenko: just as L1-3 caches are just caches for what you call RAM
22:27:06 <tromp> jmcarthur i agree it's best to call such a trie logarithmic time access
22:27:26 <tromp> while i'd call a hashtable constant time access
22:27:41 <jmcarthur> tromp: a machine word can address any byte in memory though
22:27:54 <jmcarthur> tromp: so it is inconsistent to call the trie log n but the hashtable constant
22:28:09 <copumpkin> there's also information theory
22:28:10 <kwf> jmacarthur: And your hard disk is just a cache for the much larger amount of storage available on the network... which itself is just a cache for a subset of the space of possible computations that might ever be performed.
22:28:12 <tromp> if the hastable bounds the number of memory accesses to a real constant (independent of machine word size)
22:28:22 <jmcarthur> tromp: that is, the trie is no worse than the hashtable at the boundaries of what fits in memory
22:28:36 <copumpkin> information theory says O(1) indexing can't exist :P
22:28:42 <jmcarthur> tromp: or, indeed, at the boundaries of what fits in the address space at all
22:28:44 <LordBrain> okay, so now the fact that you have an l2 cache is going to change what we call O(1)?  as if O(1) was not always intended to be a purely theoretical measure
22:28:55 <jefimenko> this is definitely a pedantic discussion.
22:29:05 <jefimenko> i'm going to continue calling it O(1) for any practical purpose
22:29:05 <jmcarthur> yes, i qualified it as such from the beginning
22:29:08 <jmcarthur> very pedantic
22:29:30 <copumpkin> it's just amusing to see people call it "asymptotic notation, by and large"
22:29:34 <copumpkin> (except if it gets too big)
22:29:44 <tromp> the trie is logn if it always branches on bytes as machine word grows
22:29:48 <jmcarthur> actually, cache effects are something programmers often worry about, so this is not totally pedantic
22:30:10 <jmcarthur> it's just that most people don't *think* of it as being something you can distinguish asymptotically
22:30:15 <tromp> the trie would be constant if it branches on e.g. 1/4 of machine word
22:30:27 <jmcarthur> tromp: right. but the hash table would be log n under the same conditions
22:30:48 <tromp> no, the hashtable does only 2 memory accesses
22:30:54 * copumpkin keeps repeating that O(1) doesn't exist
22:30:55 <LordBrain> it matters, in practice, depending on the circumstances,  but it certainly doesn't change the attributes of the algorithm
22:31:04 <jmcarthur> tromp: the more data you store in the hash table, the more information must be in the keys to distinguish the buckets
22:31:15 <jmcarthur> tromp: the keys have to grow logarithmically, in fact
22:31:41 <jmcarthur> copumpkin is right. this is a fundamental fact of information theory
22:31:58 <tromp> well, i was assuming that memory is accessed in machine word sizes:)
22:32:04 <copumpkin> you need O(log n) bits of information to distinguish n elements
22:32:15 <copumpkin> asymptotics don't know about "machine word"
22:32:16 <jmcarthur> my point is you can't make that assumption for one data structure and not for another. that's just unfair
22:34:39 <jmcarthur> anyway, the original point i was trying to reinforce is just that the difference between constant time and logarithmic time basically doesn't exist. furthermore, most people unknowingly lie about access times. you can really only trust benchmarks, if it's raw performance you are interested in.
22:35:10 <jmcarthur> i mean in the context of indexing specifically
22:35:29 <jmcarthur> it is of course yet more subtle when you are talking about more complex operations...
22:35:35 <tromp> if the machine word is w bits, and memory is 2^w bits accessible in 2-bit units, then hashtables are O(1) lookup
22:35:47 <jmcarthur> lol
22:35:49 <tromp> and so are tries that branch on e.g. w/4 bits
22:36:23 <jmcarthur> yes, if you choose the size of the key as your variable instead of the number of them, you get something more like constant time
22:37:25 <LordBrain> I don't think that every time someone comes looking for an O(1) lookup we should start teaching them them why thats not what they need, as if nobody needs it. Perhaps have some warning in the haddock about why O(log n) is sometimes better than O(1), but don't decide for them pre-emptively that this is one of those times.
22:37:46 <jmcarthur> all these subtleties are what led me to prefer soft-O notation over typical big-O notation
22:38:15 <tromp> you mean sweep logarithmic factors under the rug?
22:38:30 <jmcarthur> LordBrain: i agree. however, if somebody complains that something is going to be too slow for them because it's advertised as taking logarithmic time instead of constant time, i'm going to complain.
22:38:35 <jmcarthur> tromp: yes
22:38:55 <Aetherspawn> when is log better than constant time
22:38:58 <Aetherspawn> when the constant is large?
22:39:43 <jmcarthur> Aetherspawn: the point is that whether an operation takes log time or constant time is basically irrelevant to whether it is better
22:40:06 <jmcarthur> Aetherspawn: *and* that the lines between log and constant are really, really blurry
22:41:18 <tromp> the log is often better if the constant time takes 3 times more code, with hairy case distinctions
22:42:06 <Cale> If you think memory accesses are constant time, you're already sweeping log factors under the rug (in fact, probably O(n^(1/3)) or O(n^(1/2)) factors)
22:42:07 <LordBrain> Aetherspawn, if your O(1) takes up all of memory and sends the machine thrashing, and is actually a tree structure in practice anyway due to the way memory is paged, or ends up causing the OS to start using the swap to accomodate it...
22:42:38 <tromp> bedtime for me...
22:42:56 <Cale> There's only a finite amount of memory you can fit within a given distance of where the computation is done, and information can't travel faster than light
22:44:18 <Cale> So as the size of your datastructure increases without bound, your machine as well as the address decoding will also have to expand
22:44:24 <jmcarthur> Cale: actually i read somewhere that the speed of light makes it even worse than logarithmic, but this is based on hearsay that i don't even remember well
22:45:27 <Cale> jmcarthur: Yeah, might've been me
22:47:18 <LordBrain> Aetherspawn, in other words, in practice, O(1) is not always better or faster than O(log n).. But in the case of 6000 keys which is what i understood to be chrisdotcode's situation it is very likely going to be better.
22:47:18 <Cale> If you put your computer's memory in a ball around your computer, then you have O(r^3) memory within distance r. Inverting that, if you want to have n memory addresses, the largest distance will be O(n^(1/3))
22:48:14 <copumpkin> lol
22:48:39 <Cale> If you really want to stretch the limitations of what can be accomplished within physical limitations of the universe, then it actually possibly gets worse due to the holographic principle
22:50:25 <Cale> i.e. that the maximal entropy in any region scales with the square of the radius rather than the cube, so it becomes O(n^(1/2))
22:51:12 <jmcarthur> ah, i was just doing the math myself and turns out you already said it here
22:52:08 <Total_1mmersion> Does the fgl package have a bug or do I not understand how gsel works?
22:52:09 <Total_1mmersion> G.gsel (\(_,_,s,_) -> odd s) (G.mkGraph [(0,0),(1,1)] [(0,1,())] :: G.Gr Int ())
22:52:20 <Total_1mmersion> [([],1,1,[])]
22:53:19 <Cale> In real world NUMA machines, I don't even know what the scaling is like. Probably O(n^2), as you're not likely to expand your building as a cube, and even if you do, you're probably going to run the cables in a more sensible way than having every floor look like swiss cheese
22:53:51 <Total_1mmersion> Shouldn't the result be [([((),0)],1,1,[])]?
22:53:51 <jmcarthur> so, summary: (1) programmers like to pretend everything is simple and shiny and constant time. (2) information theory is a bit more pessimistic. (3) the real world sucks.
22:58:13 <Cale> Total_1mmersion: This has always been something that mildly annoyed me about fgl. I believe that when you break a graph into contexts, there are few guarantees on which context any given arc will show up in.
22:58:44 <Cale> (Because they're allowed to show up in either the context for the vertex they're going out of, or the one which they're going into.)
23:00:52 <Total_1mmersion> It seems that the in/out elements of the Context tuple are unusable then. When would you actually use the values if they can be incomplete?
23:40:57 <Cale> Total_1mmersion: yeah, it's a bit weird, if stuff happens to show up there, you can use it, but otherwise, you have to query the graph to really get anything more reliably
23:41:38 <Cale> Total_1mmersion: I think the idea is that there are some algorithms (apparently more than a few) which are eventually going to scrutinise the whole graph and can get by on knowing that every edge will eventually appear in some context
23:50:50 <Saizan> tbf, once my numerical analysis prof said they used to only count multiplications and divisions in their asymptotics, because they were much slower than addition and subtraction, so there's some amount of pragmatism that goes into building your cost model
23:54:39 <l0cust> How are we all doing?
23:56:02 <Cale> Saizan: yeah, and sometimes all that matters is memory accesses or even just cache misses (though in Haskell, it tends to be hard to worry about the distinction between those two)
