00:01:15 <redtricycle> LB.unpack responseMsgdoes that...no?
00:01:30 <warpy> no
00:02:08 <warpy> use: map (chr . fromIntegral) . LB.unpack
00:05:53 <Saizan> kmspriyatham_: have you restarted ghci after installing the package?
00:06:00 <kmspriyatham_> yes, I did
00:06:24 <redtricycle> warpy: http://lpaste.net/104235 Couldn't match expected type `[LB.ByteString]' with actual type `LB.ByteString'
00:07:10 <warpy> redtricycle: uh, LB.unpack goes outside the map function
00:07:15 <warpy> check what i wrote
00:07:33 <Saizan> smiller2: the size of the record doesn't matter, since it's all done by reference
00:07:58 <pavonia> redtricycle: What text encoding is used for the data stored in the bytestring?
00:08:48 <redtricycle> warpy: map ((chr . fromIntegral) . LB.unpack) responseMsg == "{\"status\":\"sent\"}"
00:08:51 <redtricycle> ?
00:09:10 <smiller2> Ah, thanks!
00:09:11 <warpy> (map (chr . fromIntegral) . LB.unpack $ responseMsg) == "{\"status\":\"sent\"}"
00:09:58 <warpy> @t map (Data.Char.chr . fromIntegral) . Data.ByteString.Lazy.unpack
00:09:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
00:10:07 <redtricycle> warpy: totally worked, thanks
00:10:08 * hackagebot treeviz 1.0.0 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-1.0.0 (DavidBanas)
00:10:08 * hackagebot jose 0.1.26.0 - Javascript Object Signing and Encryption  http://hackage.haskell.org/package/jose-0.1.26.0 (frasertweedale)
00:10:28 <warpy> :t map (Data.Char.chr . fromIntegral) . Data.ByteString.Lazy.unpack
00:10:28 <lambdabot> BSLC.ByteString -> [Char]
00:10:33 <warpy> redtricycle: ^
00:10:51 <redtricycle> Why isn't map ((chr . fromIntegral) . LB.unpack ) responseMsg
00:11:01 <redtricycle> the same as (map (chr . fromIntegral) . LB.unpack $ responseMsg)
00:11:32 <warpy> the function argument to map is different
00:12:10 <redtricycle> i got it
00:12:15 <redtricycle> I need to LB.unpack $ responseMsg first
00:12:15 <warpy> great
00:12:28 <redtricycle> wait, I dont have it
00:12:46 <redtricycle> Let me play with this in ghci
00:14:44 <warpy> redtricycle: just check type sigs in ghci
00:15:04 * hackagebot apiary 0.4.3.2 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.3.2 (HirotomoMoriwaki)
00:15:06 * hackagebot apiary-cookie 0.4.3.2 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.3.2 (HirotomoMoriwaki)
00:15:08 * hackagebot apiary-persistent 0.4.3.2 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.4.3.2 (HirotomoMoriwaki)
00:15:10 * hackagebot apiary-websockets 0.4.3.2 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.4.3.2 (HirotomoMoriwaki)
00:16:39 <warpy> the lecture notes of the course bos is taking are pretty enlightening
00:17:02 <warpy> bos+ rather
00:17:26 <warpy> well, at least for noobs like me
00:55:25 <exicer> So I've been messing around using databases with haskell for the first time. It seems like, if you are storing stuff in normal form on the db, you very often want to represent something like data Test = Test { a :: Text, b :: [OtherType] } as three tables in the db. Is there some disadvantage to using Test as both the input and output to the db, hiding the details? I guess this assume that the primary key is in the data type.
01:06:13 <paolino> hello, I'm trying to make an efficient list modification function http://lpaste.net/104236, is this different from break and concat ?
01:13:46 <skypers> is there anyone there who knows linear enough to tell me how matrices are represented? (row major / column major)
01:15:59 <bennofs> skypers: the documentation says "A 4x4 matrix with row-major representation" for Mat44 (and similar for other dimensions I think)
01:16:43 <skypers> oh
01:16:48 <skypers> I didn’t notice
01:16:50 <skypers> thank you
01:17:02 <skypers> so hm
01:17:15 <skypers> if I want to translate a V33 with a M33
01:17:18 <skypers> I do m * v
01:17:32 <skypers> if it was column major, it’d be v * m
01:17:33 <skypers> right?
01:17:49 <skypers> I have added transformation to my current matrice chain multiplication
01:17:56 <skypers> and the projection is like inversed
01:18:01 <skypers> on the X axis
01:18:13 <bennofs> m * v won't typecheck. (*) :: a -> a -> a, but here you're giving two arguments of a different type
01:19:21 <skypers> bennofs: it’s the conceptual stuff
01:19:26 <skypers> I guess it’s m *! v
01:19:43 <skypers> !*
01:19:45 <skypers> m !* v
01:20:05 <skypers> I think I’ll just read the source of mkTransformationMatrix
01:25:47 <XexonixXexillion> Is there a reason multi param type classes and fundeps aren't part of Haskell (i.e not in the Haskell2010)?
01:27:17 <bergmark> XexonixXexillion: i'm not sure about this, but i think the types can't always be inferred
01:28:03 <SrPx> anyone online?
01:28:15 <paolino> no
01:28:25 <SrPx> oh well, i'll be back later
01:29:05 <paolino> please, it was a joke
01:31:17 <skypers> 10:25 < paolino> no
01:31:28 <skypers> I see a grumpy cat in there
01:31:29 <skypers> :D
01:31:48 <Iceland_jack> “#haskell is closed for maintenance”
01:38:00 <kmspriyatham> pavonia: You were right, it was due o multiple ghc versions. I had to remove everything and reinstall haskell framework. It works now. thanks
01:38:26 <pavonia> Nice
01:48:50 <rager5599> welcome back DT``
02:25:21 * hackagebot cabal-rpm 0.8.11 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.11 (JensPetersen)
02:48:33 <dEPy> question: how come foldl can not be used on infinite lists and foldr can? Foldr starts at the end of the list and starting at the end of the infinite lists is impossible?
02:51:34 <Saizan> ?src foldr
02:51:35 <lambdabot> foldr f z []     = z
02:51:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:52:24 <Saizan> dEPy: if f is lazy enough, then it can produce some results before looking at (foldr f z xs)
02:52:37 <awestroke> > foldl1 f [a, b, c]
02:52:38 <lambdabot>  f (f a b) c
02:52:46 <awestroke> > foldr1 f [a, b, c]
02:52:47 <lambdabot>  f a (f b c)
02:53:15 <dEPy> ?src foldl
02:53:15 <lambdabot> foldl f z []     = z
02:53:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:53:30 <dEPy> ah
02:53:41 <thrakcattack> how can i import a field constructor from a module?
02:53:45 <dEPy> in foldl case it will go in an infinite loop right??
02:54:38 <dEPy> and in foldr case it will only evaluate the f when needed?
02:54:42 <awestroke> thrakcattack: import Pkg (Type(Constructor)) or import Pkg (Type(..))   -- Type(..) means "Type and all constructors"
02:55:12 <Saizan> dEPy: yeah, in foldl case it'll keep recursing on the list no matter how lazy f is
02:55:25 <dEPy> ok, tnx for the explanation :)
02:55:40 <bennofs> Wow, the latest repa requires GHC 7.8?
02:58:19 <thrakcattack> awestroke: thanks, it turned out that using qualified import was the problem too
03:09:28 <dawdawawd> hey
03:09:37 <dawdawawd> I have a quick question
03:09:54 <dawdawawd> how do you post a blank comment on reddit
03:16:14 <skypers> o
03:16:15 <skypers> m
03:16:15 <skypers> g
03:16:28 <skypers> my demoscene release in Haskell, with my engine statically linked
03:16:30 <skypers> 3Mo
03:16:43 <skypers> without even stripping it, xz compresses it up to 84%
03:16:48 <skypers> it now weighs 300k
03:16:56 <skypers> I’m speecheless
03:16:57 <Cale> xz is pretty good :)
03:17:00 <skypers> yeah
03:17:09 <skypers> I think it uses lzma by default
03:17:11 <skypers> I use xz -e
03:17:15 <skypers> for aggressive compression
03:17:37 <zq_> laziness is weird
03:17:46 <skypers> it’d be SO awesome if I could make it fit in 64k ahah
03:25:27 * hackagebot reactive-banana 0.8.0.1 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.0.1 (HeinrichApfelmus)
03:35:28 * hackagebot reactive-banana 0.8.0.2 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.0.2 (HeinrichApfelmus)
03:58:34 <bennofs> Ew ... the GHC 7.8 depends on transformers?! This means I won't be able to use transformers 0.4 with any package that uses doctest :|
04:05:07 <inf-groupoid> I have a map from keys to values (Data.Map, Data.HashMap, whatever). In addition, the values (not the keys!) are partially ordered. How do I make it so that I cannot remove an entry (k1,v1) from a map if there is another entry (k2,v2) such that (v1 > v2)?
04:07:20 <merijn> inf-groupoid: I would define a newtype for tuple of map + min element and then have every insert/remove check ordering with the minimal element before actually removing it?
04:12:53 <inf-groupoid> merijn: Ah! There not necessarily a single minimum element. It is just a partially ordered set. Most pairs of distinct elements are likely to be incomparable, but a few will be comparable.
04:21:12 <AnalogFile> Just stumbled upon edwardk's post on catas and loved it (not surprising). I know it's a month old, but it's on FP Complete not on comonad reader (this did surprise me a little).
04:31:36 <merijn> inf-groupoid: Then I think you're stuck implementing something yourself
04:32:58 <inf-groupoid> Aw. That is what I was afraid would be the case. :-(
04:33:04 <inf-groupoid> Thanks, anyway. :-)
04:50:50 <halvorg> newtype Program = Program { programID :: GLuint } deriving ( Eq, Ord, Show )
04:51:01 <halvorg> Any way to get the programID given a Program?
04:51:11 <halvorg> programID p doesn't work.
04:53:21 <fizruk> halvorg: what does it say?
04:53:27 <FreeFull> halvorg: It should work
04:53:40 <crazydave> why newtype and not data is that a mistake?
04:53:52 <FreeFull> crazydave: Why would it be a mistake?
04:54:04 <FreeFull> That newtype looks fine to me
04:54:26 <fizruk> crazydave: newtype is like data, but only available for single-argument single-constructor case
04:54:30 <halvorg> looks like programID isn't exported or somethin
04:54:43 <FreeFull> Yeah, you have to export it out of the module for it to be available
04:54:46 <halvorg> could that be it? its in a library
04:54:48 <FreeFull> Yeah
04:54:52 <halvorg> I see, thanks
04:55:04 <FreeFull> The non-exported case is useful for creating opaque interfaces
04:57:17 <fizruk> crazydave: you might want to read up on newtypes here: http://www.haskell.org/haskellwiki/Newtype
04:58:23 <crazydave> all I knew was there was some subtle difference between newtype and data ... think I will have to read up about them ... I'm on that page now but not understanding everything fully.  I think I'll have to read it 3 times.
04:58:46 <FreeFull> There is a strictness difference AFAIK
04:58:53 <FreeFull> Newtypes don't box
04:59:18 <FreeFull> Which makes them free at runtime
05:00:06 <merijn> FreeFull: *almost* free
05:00:41 <FreeFull> merijn: What makes them non-free? Duplicate typeclass instances?
05:00:42 <merijn> "map Program [1..10]" still has a runtime cost
05:00:51 <FreeFull> Ah, yeah
05:01:02 <merijn> FreeFull: Need to traverse containers when wanting to map newtype constructors, etc.
05:01:34 <FreeFull> I say that's more of a property of map though
05:01:59 <FreeFull> There should be a way to cast safely without runtime cost
05:02:26 <artyomkazak> FreeFull: yep, that's what Roles are for
05:02:44 <merijn> FreeFull: 7.8's roles are going in that direction
05:10:04 <halvorg> http://lpaste.net/104241 - any idea why these lines throw errors in OpenGL 3.3 (core) contexts, but not in OpenGL 3.0? The lines are commented near the bottom of the paste.
05:35:26 <k0ral> I had to recompile GHC with INTEGER_LIBRARY=integer-simple to fix a segmentation fault in my project (cf https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/Integer); is there a way to deploy such a 'fix' automatically for end-users without having them recompile GHC ?
05:37:03 <BurnIrl> Hello
05:38:00 <BurnIrl> Is haskell powerful?
05:40:04 <Iceland_jack> Interesting
05:43:36 <AnalogFile> BurnIrl: define powerful
05:43:52 <Iceland_jack> AnalogFile: BurnIrl has parted the channel
05:44:07 <AnalogFile> oh. serves me to be distracted, lol
06:01:06 <thrakcattack> u
06:16:02 <Marqin> how can i make ghc output C code? -C flag not workig, gives me some "Compiler not unregisterised, so ignoring -C
06:16:05 <Marqin> "
06:25:16 <bennofs> Marqin: GHC doesn't generate C code, so you can't
06:26:11 <Polarina> Marqin, you can try out the -fvia-C flag, but you'll need an unregistered build of ghc. http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/code-generators.html
06:26:19 <bennofs> Marqin: there is something called "unregistered mode", in which GHC does generate C code, but it's disabled in the standard builds of GHC (I'm not even sure if it still works)
06:26:47 <suppi> hi, I'm trying to work with snap framework and snaplet-postgresql-simple
06:27:02 <suppi> but when i try to install it with cabal install i get
06:27:07 <suppi> postgresql-libpq-0.9.0.1 failed during the configure step. The exception was:
06:27:07 <suppi> ExitFailure 1
06:27:14 <Marqin> Polarina, bennofs: thanks. i'm just debugging some code, and one guy told me he once compiled it to C, but didn't remmber how, so thanks
06:27:40 <bennofs> Marqin: why do you need to compile to C for that? The C code will certainly not be easier to read
06:27:50 <Polarina> Marqin, compiling to C is likely far from the best way to debug your code.
06:28:07 <rhaps0dy> can you compile haskell to C ?
06:28:08 <rhaps0dy> lol
06:28:15 <Marqin> Polarina: no, no,
06:28:53 <Marqin> Polarina: i'm trying to figure how ghc works, because some of looping functions can be broken with ^C and some no. and i'm trying to figure why
06:28:56 <suppi> does someone know what should I do to install it?
06:29:03 <Marqin> (why you can break them with ^C, not why they loop)
06:29:25 <Marqin> bennofs: ^ you have answer there
06:29:55 <Polarina> Marqin, an exception is sent when you do a SIGINT to a program. Any change that the exception is being masked?
06:30:03 <kotopies> Hi! What's wrong with this declaration? "data Tuple a = Tuple (Bool, !a)"
06:30:59 <kotopies> It works without parentheses, how can I force strictness only on 'a'?
06:31:20 <paoliyes> suppi run cabal with some verbose mode, the error should pop up before the unuseful ExitFailure
06:31:54 <suppi> paoliyes, thanks, how do I do that?
06:31:59 <FreeFull> kotopies: You want the Bool to be lazy, right?
06:32:21 <FreeFull> I mean, non-strict
06:32:30 <Marqin> Polarina: http://lpaste.net/7881009708188827648 here's a sample
06:32:36 <paoliyes> suppi cabal install -v or --help
06:32:47 <suppi> thanks, I'll try that
06:33:13 <flux> marqin, I don't really know about ghc signal model, but my guess is that the latter dosen't perform allocations, a nice place for checking signals
06:33:25 <kotopies> FreeFull: I wanted for all in parentheses to be strict but GHCi gave me some strange warning about it. I just want to know why it works without parentheses and not with them
06:33:37 <paoliyes> suppi then paste somewhere else the log
06:33:58 <FreeFull> kotopies: (a,b) is a tuple
06:34:04 <FreeFull> Rather than just grouping things together
06:34:05 <flux> so something actually sets a sigint handler before that; quite possibly the ghc runtime
06:34:44 <kotopies> FreeFull: Oh, so I cannot make strict a type which I didn't declared myself?
06:34:57 <flux> programs that cannot be exited with ctrl-c are quite annoying indeed :)
06:35:53 <FreeFull> kotopies: I think the meaning would be ambiguous
06:37:01 <kotopies> FreeFull: Thanks for a hint :)
06:37:05 <Marqin> flux: any idea how to handle that? :D
06:37:10 <flux> marqin, no :)
06:37:12 <suppi> paoliyes, http://lpaste.net/6581900006591037440
06:37:57 <flux> marqin, I suppose real programs very rarely end up in such loops for appreciable times..
06:39:28 <paoliyes> suppi, I think you miss libpq in the system
06:39:56 <suppi> paoliyes, yes I'm trying to install it now :)
06:40:21 <suppi> paoliyes, looks like it's working for now, thank you very much!
06:56:00 <Bones> does haskell have something roughly equivalent to SLIME for lisp? ie developing against a live running program in realtime instead of running/testing the program as a separate step at the end.
07:12:36 <zerokarmaleft> Bones: not really...interacting with the type checker is a pretty critical part of the workflow
07:14:00 <zerokarmaleft> you can reload a module in ghci, but I think that's about it
07:15:19 <AnalogFile> I Bones: do not use emacs, but if you do you should check this http://www.haskell.org/haskellwiki/Emacs
07:56:01 * hackagebot matrix 0.3.1.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.1.0 (DanielDiaz)
07:59:37 <spott> so, I've heard that you should not install ghc and cabal from homebrew... but I can't figure out WHY
07:59:40 <spott> anyone know?
08:08:05 <jophish> Yo yo yo
08:08:20 <zerokarmaleft> spott: I think it primarily has to do with Apple dropping gcc: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ghc.rb#L52
08:09:00 <spott> zerokarmaleft: that has been fixed... ghc builds now.
08:09:17 <luite> still ghc with clang is a lot slower than with gcc
08:09:32 <spott> could homebrew compile ghc in some way that would be broken?
08:09:38 <spott> but still works?
08:09:53 <luite> is that a trick question?
08:09:54 <merijn> luite: Since when?
08:10:06 <spott> luite: nope.
08:10:14 <merijn> luite: And why?
08:10:30 <spott> luite: i'm wondering about a misconfiguration of ghc-pkg or something similar
08:10:51 <spott> or a "it compiles, but there are known bugs that only pop up with clang"
08:11:47 <zerokarmaleft> ghc might build, but you might have problems building stuff that expects gcc as a preprocessor
08:11:49 <luite> merijn: i think it always has been, clang doesn't have register vars or fast thread local state
08:12:06 <luite> +global
08:12:26 <merijn> luite: *OSX* doesn't have fast thread local state
08:12:35 <merijn> luite: Regardless of GCC or clang
08:12:53 <merijn> If I remember the ticket correctly, at least
08:13:15 <exicer> How com I can't see the documentation of many (all?) of the most recent packages on hackage?
08:13:54 <merijn> exicer: Because the compilation of those packages isn't working on hackage and the authors aren't uploading manual docs?
08:13:58 <alpounet> exicer: you either have to wait or check out a previous version's documentation
08:14:00 <merijn> Also, which packages are broken?
08:14:22 <exicer> http://hackage.haskell.org/package/postgresql-simple-0.4.2.2
08:14:24 <luite> merijn: right but with gcc global registers can be used instead
08:14:30 <exicer> I'm pretty sure I noticed another earlier
08:14:50 <zerokarmaleft> spott: I think that's cleared up though in 7.8.x...I have both 7.6.3 and 7.8.2 installed from binary and had to tweak 7.6.3 settings to use gcc from homebrew's apple-gcc42
08:15:39 <merijn> exicer: That package was uploaded yesterday
08:15:53 <merijn> exicer: Documentation is build in a batch process, it just hasn't been built yet
08:15:53 <zerokarmaleft> spott: https://gist.github.com/cartazio/7131371 <= more or less
08:16:08 <luite> merijn: hmm, ticket #7602, thoughtpolice has a fix coming soon, yay :)
08:17:23 <merijn> \o/
08:17:30 <exicer> merijn: Ahh, okay.
08:19:43 <dmj`> is bayhac being recorded?
08:20:02 <mzero> parts of it
08:20:13 <mzero> I know that Dan's talk was live streamed & recorded
08:20:38 <mzero> though I don't see a link yet on the site... I'll nudge Jonathan
08:24:03 <dmj`> mzero: thanks
08:30:21 <mzero> dmj`: video of Dan's talk: https://plus.google.com/u/0/events/cu5t5s2g14t4fqmapft5bcatqeg
08:31:03 <mzero> hmmm... but without the slides
08:31:09 <mzero> not sure if he is going to fix that up or no...
08:34:23 <dmj`> mzero: thanks!
08:35:44 <deweyvm> hmm, type inference seems to pick the first usage and infer the type from that rather than trying to generalize over all usages, is that normal?
08:36:11 <merijn> Sounds like the Dreaded Monomorphism restriction
08:36:14 <merijn> @where dmr
08:36:14 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:36:51 <deweyvm> aha, thanks :)
08:37:30 <deweyvm> yep that was it!
08:39:12 <deweyvm> i feel accomplished for butting up against that
08:39:17 <deweyvm> first time
08:39:52 <Eelis> i wish hackage had an "also show unexposed modules" option. sometimes when browsing a package, i'm interested in its interface /and/ implementation!
08:41:56 <luite> Eelis: and while you're at it, make variables, type sigs, and data constructors lxr-like clickable
08:42:13 <Eelis> i don't know what lxr is, but it sounds good!
08:42:37 <luite> cross reference generator for C
08:42:48 <luite> and perhaps more languages
08:43:36 <luite> Eelis: random sample from linux kernel http://lxr.linux.no/linux+v3.14.4/crypto/algif_hash.c
08:43:52 <Eelis> ah, thanks
08:45:01 <Eelis> yes, that would be great
08:48:20 <jophish> Is there a more haskelly interface to sdl2?
09:00:01 <Polarina> jophish, there's hsSDL2 that is a work-in-progress and not on Hackage. I am however currently working on an improved API for the sdl2 library.
09:00:41 <jophish> Polarina: awesome. I hope that's going well
09:00:48 <jophish> Is it on github?
09:01:06 <Polarina> jophish, I've been developing it locally, so no github, unfortunately. :(
09:01:31 <jophish> Give me a ping when it's done :) I'll check out hsSDL2 in the meantime though
09:01:59 <Polarina> jophish, will do. I've not tried hsSDL2 myself, so I do not know how well it functions.
09:08:46 <fread2282> !pl id a = a
09:09:04 <fread2282> @pl id a = a
09:09:05 <lambdabot> id = id
09:09:30 <ion> :-D
09:38:48 <thrakcattack> Hello
09:39:12 <Polarina> Hi there.
09:39:14 <thrakcattack> I am trying to install network-bytestring from hackage but i get an error:
09:39:17 <thrakcattack>  Could not find module ‘GHC.IOBase’
09:39:47 <thrakcattack> I can't find this module anywhere
09:39:59 <monochrom> I believe that network-bytestring is obsolete. you just need network and it already has that stuff.
09:40:21 <thrakcattack> oh thanks
09:40:28 <monochrom> indeed http://hackage.haskell.org/package/network-bytestring says exactly that
09:41:40 <jophish> I've made a demo to open a GL window and paint it grey until the user presses Q: http://lpaste.net/104244
09:41:41 <thrakcattack> oh well should have read that :)
09:41:51 <jophish> Is the code all ok?
09:42:06 <jophish> Are there any silly things being done here?
09:42:34 <jophish> sf = arr id; seems a little weird
09:43:25 <bennofs> jophish: sf = Control.Category.id
09:44:00 <monochrom> perhaps "sf = arr id" is because your program does little. if you do more, sf's definition would be less trivial.
09:44:19 <jophish> bennofs: It's a shame that's not in the Prelude!
09:44:57 <jophish> monochrom: I'll try doing a little bit more, although it seems possible to shift most of the computation there into sense
09:45:57 <jophish> I wonder if it would make sense to return the whole keystate from sense and filter the keys I want in sf
09:47:07 <Polarina> jophish, the SDL part looks fine. You might want to consider withCString though. Here's a little smoke-test program that I use: http://lpaste.net/104245
09:47:22 <edwardk> @tell AnalogFile actually it is closer to 5 years old. I'd just reposted it from an old "Google Knol" a few months back and had to republish something to get my name back in the user list due to an FP Complete website bug.
09:47:22 <lambdabot> Consider it noted.
09:48:13 <charmander> Is there a way to use a ResumableSource m ByteString with WAI’s responseSource without using unwrapResumable?
09:48:48 <jophish> Polarina: super, I'll take a look, thanks
09:49:00 <Polarina> jophish, I'm working on getting rid of all pointers, so that headache shall alleviate. :)
09:49:46 <Polarina> jophish, but if you really like them, they'll still be exported under a FFI submodule.
09:50:42 <jophish> Polarina: Sounds like a good idea, type safe Enums too, please!
09:51:29 <Polarina> jophish, of course!
09:53:07 <jophish> If I were allocating GL resources, would it make sense to do this in actuate?
09:53:37 <jophish> have actuate take an enum describing what stage to do, data State = Init | Render [Object]
09:53:42 <jophish> (along those lines)
09:54:15 <jophish> and the signal function would return Init the first time, and Render every other tiem
09:54:27 <Polarina> jophish, I've heard of a "crazy" person use ResourceT with OpenGL.
09:57:41 <jophish> Polarina: ResourceT looks nice :)
09:58:47 <jophish> As far as I can tell OpenGL is the antithesis of good Haskell design
09:59:22 <Polarina> It's a huge and a complex state machine.
09:59:48 <jophish> sigh, if only DSA was nice
10:01:35 <jophish> Polarina: how would yampa play with a transformer such as resourceT?
10:02:49 * Polarina would have no idea.
10:02:56 <vanila> opengl is just very low level, use it to build a graphics library instead of using it directly
10:03:12 <Polarina> jophish, there are more modern FRP libraries than Yampa out there.
10:03:46 <jophish> heh, It's tricky to find information. There are a bewildering array of FRP libraries
10:03:56 <jophish> I chose yampa because I was a fan of Quake3 :)
10:04:03 <jophish> What could you recommend instead?
10:05:38 <Polarina> jophish, reactive-banana is easy to get into. There's also netwire that's quite powerful.
10:08:58 <GeraldCode> When I make an instance from Monoid, I have to give a concrete class, like instance Monoid (Foo a) where....but if I want to make it an instance of Fucntor, I just say instance Functor Foo where...why is there a difference?
10:09:15 <Iceland_jack> GeraldCode: Because Monoids have kind *
10:09:18 <Iceland_jack> while Functors have kind * -> *
10:09:44 <Iceland_jack> so [] is a Functor, but [a] is a Monoid
10:09:55 <GeraldCode> ok. hmm how is that specifried in the class declaration for them?  They seem identical
10:10:10 <Iceland_jack> GeraldCode: It's not specified explicitly, but it can be
10:10:21 <GeraldCode> oh I see..HAskell infers it automatically somehow?
10:10:33 <Iceland_jack> Yes
10:10:33 <Iceland_jack>     class Monoid a where
10:10:33 <Iceland_jack>         mempty :: a
10:10:40 <GeraldCode> thanks. thats amazing
10:10:45 <Iceland_jack> here 'a' must be a concrete type
10:10:56 <Iceland_jack> another way of writing that would be
10:10:56 <Iceland_jack>     class Monoid a :: * where
10:10:56 <Iceland_jack>         mempty :: a
10:11:01 <GeraldCode> ah ok
10:11:20 <Iceland_jack> with parentheses actually
10:11:25 <Iceland_jack> but for Functor it is
10:11:44 <Iceland_jack>     class Functor (f :: * -> *) where
10:11:44 <Iceland_jack>         fmap :: (a -> b) -> f a -> f b
10:12:04 <Iceland_jack> GeraldCode: GHC can infer that since 'f' is applied to 'a' and 'b', right?
10:12:10 <Iceland_jack>     'f a' and 'f b'
10:12:14 <GeraldCode> ah ok makes sense
10:12:24 <GeraldCode> the inference powers of haskell continually surprise me
10:12:48 <dwcook> * is the default when it could be any kind. (I believe an extension disables this.) However, all values are of types of kind *, so you know that if you have a :: A then A :: *.
10:12:54 <hpc> GeraldCode: with a bit of perspective, it's fairly obvious
10:13:17 <hpc> GeraldCode: a kind is "the type of a type", so it for the most part uses the same underlying inference code as type inference
10:13:21 <dwcook> For example, there is no value :: Maybe. There are values :: Maybe String.
10:13:29 <GeraldCode> hpc, yeah I mean I can see it now, but the design of the system impresses
10:13:38 <GeraldCode> ok
10:13:45 <hpc> the kind system has been historically very simple, but it's been getting fancier
10:14:23 <c_wraith> I'm told Stephanie Weirich is working on opening up the kind system completely.
10:14:37 <Iceland_jack> GeraldCode: dwcook makes an interesting note, with the PolyKinds extensions you can make it more general
10:15:05 <Iceland_jack> it won't work in the Monoid example though
10:15:10 <GeraldCode> hmm ok
10:15:29 <dwcook> Does the new Typeable take advantage of PolyKinds?
10:15:39 <Iceland_jack> Yes
10:15:39 <dwcook> I know they recently generalized is you don't need Typeable2 and things.
10:15:42 <Iceland_jack> but PolyKinds allow you to do things like this
10:15:42 <Iceland_jack>     data Proxy (a ∷ ĸ) = Proxy
10:15:56 <Iceland_jack> and like dwcook mentioned
10:15:56 <Iceland_jack>     class Typeable (a ∷ ĸ) where
10:16:33 <Iceland_jack> GeraldCode: If you defined Proxy in the default way
10:16:34 <Iceland_jack>     data Proxy a = Proxy
10:16:34 <Iceland_jack> which is defaulted to *
10:16:37 <Iceland_jack>     data Proxy (a :: *) = Proxy
10:16:45 <Iceland_jack> then only concrete types would be allowed
10:16:56 <Iceland_jack>     Proxy :: Proxy Int
10:16:56 <Iceland_jack>     Proxy :: Proxy (Either Bool ())
10:17:07 <GeraldCode> right
10:17:13 <fread2282_> could MonoFunctor be implemented using PolyKinds (and not TypeFamilies)
10:17:31 <Iceland_jack> but using the magic polykindedness we can use
10:17:31 <Iceland_jack>     Proxy :: Proxy (->)
10:17:59 <Iceland_jack> or
10:17:59 <Iceland_jack>     Proxy :: Proxy ((->) r)
10:17:59 <Iceland_jack>     Proxy :: Proxy Either
10:17:59 <Iceland_jack>     Proxy :: Proxy (Either (a -> b))
10:19:01 <Iceland_jack> fread2282_: what would the method type be?
10:19:42 <GeraldCode> thanks everyone bye
10:19:45 <fread2282_> Iceland_jack: I don't know, but MonoFunctor does fmap :: (Element a -> Element a) -> a -> a
10:19:55 <fread2282_> where Element is a type family
10:19:56 <Iceland_jack> Yes, you couldn't do that with PolyKind afaik
10:20:14 <Iceland_jack> you'd have to use proxys somehow
10:20:46 <Iceland_jack> fread2282_: A simple example is
10:20:46 <Iceland_jack>     class Foo (a ∷ ĸ) where bar ∷ a
10:20:51 <Iceland_jack> which won't work
10:21:18 <dwcook> a could only be * there
10:21:20 <Iceland_jack> yeah
10:21:52 <Iceland_jack> type classes that are polykinded like Typeable use type proxies
10:22:50 <c_wraith> Typeable was changed to have typeRep :: proxy a -> TypeRep in GHC 7.8, and typeOf is now a function that calls TypeRep
10:23:15 <Iceland_jack> Yes I was speaking of the 7.8+ Typeable
10:23:47 <c_wraith> err, calls typeRep
10:24:12 <Iceland_jack> well typeRep#!
10:25:14 <c_wraith> ah. :)
10:26:48 <Mokosha> I have a netwire problem with space leaks and I don't know why...
10:26:56 <Mokosha> This is the program: https://gist.github.com/Mokosha/2b65655450981cfded65
10:27:10 <Mokosha> it seems to just keep growing in memory and just hang
10:27:15 <Mokosha> I don't know why =(
10:34:45 <Marqin> what did => mean in function type?
10:35:00 <Marqin> like in :: Num (a -> b) => [a] -> [b]
10:35:16 <Iceland_jack> It means that the type is constrained
10:35:37 <Iceland_jack> in your example the type is an indicator that you're doing something wrong
10:35:51 <Iceland_jack> It's saying that functions from 'a -> b' are numbers
10:36:31 <Marqin> Iceland_jack: i don't have to be not wrong
10:36:53 <Marqin> Iceland_jack: i just have to type some functions for my assesment
10:37:47 <Iceland_jack> That type signature is a bit strange but sure :) there are some people who enjoy treating numbers as functions
10:41:21 <Marqin> Iceland_jack: so if I make type from some a into some b instance of class Num and then I can use elements from a into that first function?
10:42:43 <Iceland_jack> Well Marqin, the type you posted takes no functions as arguments
10:43:03 <vanila> :t map (1 $)
10:43:04 <lambdabot> Num (a -> b) => [a] -> [b]
10:43:19 <Iceland_jack> when I write
10:43:20 <Iceland_jack>     foo :: Show a => a -> String
10:43:20 <Iceland_jack> everything left of '=>' is not an argument
10:48:03 <Marqin> :t map (-1)
10:48:04 <lambdabot> Num (a -> b) => [a] -> [b]
10:48:12 <Marqin> Iceland_jack: ^ it's that
10:48:34 <glguy_> :t map (subtract 1)
10:48:34 <lambdabot> Num b => [b] -> [b]
10:48:35 <Iceland_jack> Marqin: You probably intended to write 'map (subtract 1)
10:48:36 <Iceland_jack> '
10:48:41 <Iceland_jack> (-1) is not a function
10:49:08 <Iceland_jack> > map (subtract 1) [1..10]
10:49:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
10:49:21 <paolino> :t (- 1)
10:49:21 <glguy_> If the homework is trying to teach you that (-1) is not a function
10:49:22 <lambdabot> Num a => a
10:49:25 <Marqin> Iceland_jack: no.no. On my sheet with haskell excercises from Uni is written " f x = map (-1) x " and I have type some functions like that
10:49:28 <Marqin> :D
10:49:39 <Iceland_jack> Marqin: Erm okay, good luck
10:49:39 <glguy_> :t map
10:49:40 <lambdabot> (a -> b) -> [a] -> [b]
10:49:50 <Marqin> or
10:49:55 <Marqin> :t map -1
10:49:56 <lambdabot> Num ((a -> b) -> [a] -> [b]) => (a -> b) -> [a] -> [b]
10:50:01 <vanila> Marqin, (+1) is a function adding one
10:50:07 <Iceland_jack> double 'good luck' with that one :)
10:50:07 <glguy_> so you can see that the first argument is type (a->b) and (-1) :: Num c => c
10:50:12 <vanila> Marqin, (-1) is the number negative one
10:50:17 <glguy_> so when those two get unified you get a Num (a->b) constraint in your type
10:50:23 <ion> marqin: Perhaps they want you to implement a Num instance for (a -> b) and then write some other functions like map 42 x. ;-)
10:51:22 * hackagebot git-annex 5.20140517 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140517 (JoeyHess)
10:51:32 <paolino> :t (+ show)
10:51:33 <lambdabot> (Show a, Num (a -> String)) => (a -> String) -> a -> String
10:52:33 <vanila> > (+1) (-1)
10:52:35 <lambdabot>  0
10:55:39 <Marqin> :t * sin . 1
10:55:40 <lambdabot> parse error on input ‘*’
10:55:46 <Marqin> :t (* sin . 1)
10:55:47 <lambdabot> (Num (a -> c), Floating c) => (a -> c) -> a -> c
10:56:03 <vanila> lol
10:57:59 <Iceland_jack> Marqin: What are you trying to do?
10:59:19 <Marqin> Iceland_jack: manually typing (* sin . 1)
10:59:31 <Marqin> Iceland_jack: just checking in compiler if right
10:59:39 <Iceland_jack> …I see
10:59:47 <vanila> Marqin, link to your course page?
11:00:03 <Marqin> vanila: it's moodle, but protected
11:00:10 <vanila> screenshot?
11:01:24 * hackagebot azure-servicebus 0.1.6.0 - Haskell wrapper over Microsoft Azure ServiceBus REST API  http://hackage.haskell.org/package/azure-servicebus-0.1.6.0 (kapilash)
11:01:37 <archblob> what is the most common way someone would say (a -> b) -> f a -> f b in english ?
11:02:04 <ArisFr> Hi, does anyone know what the overriding behaviour of options passed to ghc is? Ie. if I give "ghc -O2 -O0" what will the optimization level actually used be?
11:02:43 <Marqin> vanila: http://spiramirabilis.net/list11.png it's not english
11:02:44 <archblob> I'm thinking of going throug google/android voice serch -> text -> f signature -> hoogle
11:02:56 <archblob> so that's why I'm asking
11:03:00 <archblob> no trolling
11:04:46 <Marqin> archblob: maybe: function from   set of functions from a into b   into set of functions  from set f a into set f b
11:04:47 <Polarina> Marqin, which question on that screenshot is it?
11:05:08 <Marqin> Polarina: the 6, the first on the right collumn
11:06:08 <archblob> Marqin, oh, that's a bit verbouse
11:07:01 <Iceland_jack> archblob: you can say 'lifting (a to b) into f'
11:07:32 <croyd_> archblob: I read it "a to b to f a to f b"
11:07:51 <archblob> yeah, you can say a lot of things, I'm more interesed into a common ground :-P
11:08:25 <vanila> functor map
11:08:48 <archblob> croyd, that would not parse correctly
11:09:01 <bennofs> I'd also say it like croyd_
11:09:12 <croyd_> archblob: parse by who?
11:09:23 <bennofs> or maybe function from a to b to function from fa to fb
11:09:48 <Iceland_jack> archblob: You can indicate grouping by intonation :) people usually do that
11:09:50 <archblob> croyd, i'm trying to go from speech -> text -> f signature -> hoogle
11:10:32 <archblob> Iceland_jack, yeah but I only have access to the text result
11:10:52 <croyd_> archblob: if what I said gives you "a -> b -> f a -> f b" then I think it would be pretty easy to just add each possible grouping to the search
11:11:00 <Polarina> Marqin, {f x = map -1 x} is equivalent to {f x = map -(1 x)}
11:11:30 <archblob> croyd,  yes but a bit wasteful
11:11:43 <croyd_> archblob: so you could search "(a -> b -> f a) -> b", "a -> (b -> f a) -> fb", "(a -> b) -> f a -> fb"
11:12:06 <croyd_> archblob: well given how ambiguous language can be that seems like a pretty reasonable tradeoff
11:15:19 <archblob> what do you think of  "take take a to b take f of a to f of b" sound ?
11:16:51 <vanila> how about a b arrow a f b f arrow arrow
11:18:53 <archblob> vanila, that would be easier implementation wise but It should preferably sound natural :-P
11:20:31 <archblob> vanila, maybe i'll got the stack way for my first implementation and see how it goes :-P
11:21:19 <archblob> thank you guys
11:35:41 <Algebr> Has strict evaluation always been the default? Like did designers of Algol explicitly think about strict evaluation?
11:38:12 <c_wraith> Algebr: call-by-value has been traditional "default" semantics in programming languages for a long time.  Occasionally you see call-by-name and call-by-need mentioned. The latter two are non-strict evaluation strategies.
11:39:13 <pjdelport> Algol 60 had bothe call-by-value and call-by-name, IIRC
11:41:31 <pjdelport> I think the implementation idea of evaluation thunks comes from Algol
11:43:20 <c_wraith> thunks are part of call-by-need, rather than call-by-name
11:45:34 <johnw> there should really be call-by-desire
11:47:25 <geekosaur> call by vague preference
11:47:46 <johnw> call by what I meant to say
11:47:59 <Algebr> It seems like the C memory model is de facto the memory model for every language, so I'm wondering what were alternative memory models before C and contemporaries of C?
11:48:15 <c_wraith> Algebr: hardware uses a different memory model than C. :)
11:48:32 <johnw> Algebr: how do you define the "C memory model"?
11:48:57 <Algebr> johnw: stack/heap/code
11:49:09 <johnw> from the platforms that I've used, it has an unsized downward-growing stack, and an unsized upward growing heap
11:49:12 <Algebr> c_wraith: does that have a name?
11:49:21 <johnw> the mapping of code segments into memory is not done by C, but ELF, for example
11:49:45 <geekosaur> also the stack direction is not defined by C, and in fact C has some portability notes regarding stack direction
11:49:46 <johnw> that's more in the domain of the "system loader"
11:50:02 <geekosaur> most modern hardware uses downward growing stack, but some historical ones used upward stacks
11:50:05 <johnw> yeah, I have a feeling that pinning down a "C memory model" would be a tricky affair
11:50:05 <c_wraith> Algebr: not really.. You need to look into hardware specs for different systems.
11:50:15 <johnw> much of it is going to end up being "implementation defined"
11:51:04 <Algebr> so an elf file is what I get after calling an assembler on an assembly file?
11:51:28 <johnw> on most Linuxes it is
11:51:48 <johnw> but there are *many* object file formats, and *many* system loaders out in the world
11:51:51 <johnw> and that's just in the UNIX world
11:52:13 <johnw> once you bring in mobile platforms, Windows, Netware, OS/2, etc., forget about it
11:52:31 <geekosaur> and a few historical architectures didn't define a stack direction as such, there wasn't a push/pop concept but you had to code such explicitly
11:52:59 <johnw> once I had a job where all I did was maintain a library to read stack traces on every platform our product was distributed on; it was a much bigger job than you'd imagine
11:54:09 <Algebr> but haven't things basically converged?
11:54:33 <johnw> i would say: not even close
11:54:42 <Algebr> johnw: I mean, you mentioned mobile, between iOS and Android, that's like the vast majority of mobile and both are basically *nix
11:54:59 <johnw> it may be the vast majority, but it by no means all that is in use
11:55:05 <johnw> Blackberry, for example, is still heavily used
11:55:20 <johnw> I bet Symbian is still out there
11:55:33 <johnw> and there are the proprietary OSes used for point-of-sale machines
11:55:41 <johnw> in other words, everything is more complex than you ever think it is
11:55:50 <Algebr> ha, ain't that the truth.
11:56:53 <johnw> one of the best things Java did was to provide a common abstraction over disparate architectures, so that you mostly didn't need to care what your app ran on
11:57:17 <johnw> although sadly, that is a road of many trade-offs
11:57:18 <bitemyapp> I'm having trouble doing a very simple query with postgresql-simple
11:57:27 <bitemyapp> query_ conn "select 1"
11:57:32 <bitemyapp> *** Exception: Incompatible {errSQLType = "int4", errSQLTableOid = Nothing, errSQLField = "?column?", errHaskellType = "Char", errMessage = ""}
11:57:40 <bitemyapp> why does it hate me :(
11:57:54 <bitemyapp> my postgres database is fine, user perms are fine, I can run the query in psql.
11:57:56 <johnw> it thinks you're trying to read a numeric column into a Char
11:58:02 <geekosaur> ^
11:58:05 <Algebr> Why are optimization flags? Why aren't they like default arguments to ghc?
11:58:11 <bitemyapp> I kinda guessed that but when I tried to fix the type it didn't work.
11:58:21 <bitemyapp> I tried to fix the type as IO [Int] and it didn't like that.
11:58:33 <johnw> bitemyapp: What did it say?
11:58:45 <johnw> Algebr: usually during development we don't use optimization
11:58:46 <geekosaur> Algebr, because sometimes you need to override optimization for specific files
11:59:07 <bitemyapp> No instance for (FromRow Int) arising from a use of ‘query_’
11:59:17 <bitemyapp> I'm trying to see if there are library specific types that have FromRow implemented.
11:59:32 <johnw> ah, now you are trying to read a row into an Int
11:59:39 <johnw> I bet you need to read rows
11:59:51 <johnw> a row with a single column containing an Int, to be specific
12:00:03 <jle`> Algebr: also, optimization might needlessly increase compilation times, in cases where optimization makes no difference in the end
12:01:14 <Algebr> I see, makes sense.
12:01:15 <bitemyapp> (query_ conn "select 1") :: FromRow r => IO [r] -- throws error, I can't seem to fix the type.
12:01:22 <johnw> haha
12:01:25 <johnw> yes indeed
12:01:44 <johnw> you're asking query_ to decide a type for you, but it can't
12:02:11 <johnw> [Int] should be a row type
12:02:23 <johnw> but you said IO [Int] didn't work...
12:03:09 <johnw> what about IO [[Int]]?
12:03:30 * geekosaur suspects Int is a field, [Int] a row, [[Int]] a valid FromRow r => IO [r]
12:03:32 <bitemyapp> johnw: uh, that worked
12:03:46 <bitemyapp> I'm impressed but a little angry with postgresql-simple's documentation.
12:03:53 <bitemyapp> s/little/a bit/g
12:03:59 <johnw> yeah, the first example they give is very close to what you're doing in fact!
12:05:59 <Algebr> Accurate to say? My 13 line C program translated into a 109 line assembly file. My 21 line haskell program translated into a 3100 line assembly file. Is this a somewhat indirect way to say that Haskell is a very high level language?
12:06:41 <johnw> I couldn't say without seeing the assembly, Algebr
12:07:06 <johnw> C has its startup code (the code around "main") in an external object file (crt1.o).  I don't know where Haskell puts its startup code.
12:08:30 <LordBrain> I'd say haskell is high level, but not necessarily because of the lines of assembly produced
12:08:45 <bennofs> johnw: it's probably in ghc's RTS :)
12:08:48 <LordBrain> but i would consider it higher level than c, definitely
12:13:40 <Algebr> I don't understand how functional code can turn into imperative assembly.
12:14:09 <Algebr> Can assembly ever be anything but imperative code?
12:14:39 <LordBrain> well....
12:14:41 <Iceland_jack> Algebr: Look at the GHC pipeline and see how it happens
12:15:00 <Iceland_jack> Namely the translation to C--
12:15:13 <LordBrain> the functional code is more a simulation, its not as if you really have outputs coming out from inputs with no cpu time being spent
12:16:08 <LordBrain> and how much time it takes depends on the platform, so technically one could argue that right there is an unpredictable side effect, technically.
12:17:21 <johnw> there was a good presentation at NYHaskell on mapping denotational semantics into operational semantics
12:19:17 <benzrf> man i barely even know what denotational semantics means
12:19:18 <benzrf> ;-;
12:20:14 <johnw> denotational semantics might say that 5 + 5 is the same thing as 10, for example, although operationally they may be dissimilar on many different counts
12:20:50 <johnw> operationally 5 + 5 could be a thunk, or the two could have different bit patterns, or one might fit into a register while the other is placed into memory, etc., etc.
12:21:13 <oleo> 7 denotes the concept of the number 7 as opposed to it's representation....there are many forms which are equally denoting 7
12:23:06 <benzrf> kleisli is pronounced 'KLAY-slee' right
12:23:39 <johnw> I've always said "KLY-slee"
12:23:43 <johnw> but I have no idea
12:23:50 <oleo> kly-slee more or less
12:23:56 <benzrf> ahihi:
12:23:58 <benzrf> *ah
12:24:47 <oleo> tho it would be klys-lee more proper....
12:25:47 <Algebr> Is gcc the default backend for ghc? are ghc maintainers aiming to use llvm as the default backend one day?
12:27:33 <bennofs> Algebr: the default backend compiles straight to assembly, and is called Native Code Generator, NCG in short
12:28:25 <bennofs> Algebr: But GHC can also compile via LLVM, using -fllvm
12:29:54 <Algebr> bennofs: Just thinking, wouldn't it be better to completely just off load the backend to llvm? Like that's an entire thing ghc maintainers wouldn't have to care about.
12:30:41 <bennofs> Algebr: I think LLVM is better for numerics atm, but it has some problems with the CPS-style code that GHC generates so it can not optimize so well
12:30:47 <benzrf> CPS?
12:30:57 <bennofs> Continuation Passing Style
12:31:00 <benzrf> ah
12:31:04 <benzrf> also i thought ghc only went up to c-- not asm
12:31:23 <bennofs> benzrf: GHC contains an integrated c-- compiler AFAIK
12:31:54 <bennofs> benzrf: in fact, you can look at the generated assembly using -ddump-asm (not that I've tried this yet)
12:32:26 <benzrf> oic
12:32:52 <enthropy> Fuuzetsu: does haddock require the file to run through the CPP? http://hackage.haskell.org/package/Rlang-QQ-0.2.1.0/reports/1/log is a failure caused by CPP (and \ \ string gaps) when I don't believe I'm asking for CPP to get involved
12:33:56 <enthropy> CPP is only in other-extensions:
12:36:40 <glguy_> Anyone know of a table with library versions on one axis and HP versions on the other?
12:37:33 <enthropy> glguy_: http://sol.github.io/haskell-platform-versions-comparison-chart/
12:37:41 <enthropy> is unofficial
12:37:54 <glguy_> it's just what I needed, thank you!
12:50:39 <_2_sophia93> Hey
12:50:55 <rhaps0dy> yo
12:51:45 <_2_sophia93> how are you doing?
12:52:04 <rhaps0dy> pretty good
12:52:05 <_2_sophia93> How are you doing?
12:52:54 <ion> pretty good
12:52:56 <rhaps0dy> Pretty Good
12:52:58 <rhaps0dy> hahaha
12:54:07 <_2_sophia93> Cool haha
12:56:42 <Hafydd> @let data Pretty a = Pretty a deriving Show
12:56:44 <lambdabot>  Defined.
12:56:52 <Hafydd> @let data Good = Good deriving Show
12:56:54 <lambdabot>  Defined.
12:56:56 <Hafydd> > Pretty Good
12:56:59 <lambdabot>  Pretty Good
12:59:39 <_2_sophia93> hmmm
13:01:40 <benzrf> does anybody actually talk about mobits
13:02:03 <benzrf> > Pretty Good :: Pretty Good
13:02:05 <lambdabot>  Pretty Good
13:02:21 <Hafydd> Mobile Obituaries?
13:03:00 <benzrf> mobit :: Monad m => m a
13:03:01 <pharaun> morbid bits?
13:03:07 <benzrf> or so ive been told
13:03:14 <benzrf> i.e. bind takes a mobit and a funciton
13:03:19 <benzrf> *function
13:03:39 <benzrf> according to http://www.haskell.org/haskellwiki/What_a_Monad_is_not
13:03:45 <Hafydd> I've only heard things like "monoidal value".
13:03:56 <Hafydd> Er... "monadic value".
13:04:09 <benzrf> yea
13:04:16 <benzrf> this needs to be a real term
13:04:52 <Hafydd> Or just "computation".
13:05:43 <benzrf> not all
13:05:49 <benzrf> monads are about computations tho
13:05:52 <benzrf> http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_values <- mobit
13:05:58 <benzrf> @learn
13:05:58 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
13:06:00 <benzrf> hm
13:06:31 <johnw> monads are about monads; the rest depends on the instance
13:06:49 <benzrf> indeed
13:06:55 <benzrf> hence mobit and not computation
13:08:07 <_2_sophia93> hmm interesting
13:08:35 <benzrf> > 3 + _foo (Just 4)
13:08:36 <lambdabot>  Found hole ‘_foo’ with type: Data.Maybe.Maybe a0 -> a
13:08:37 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
13:08:37 <lambdabot>         ‘a’ is a rigid type variable bound by
13:08:37 <lambdabot>             the inferred type of it :: a at Top level
13:08:37 <benzrf> neat
13:24:51 <mzero> woot! Over 100+ people here at #bayhac
13:27:33 <tibbe> mzero: \o/
13:27:54 <ion> mzero: Nice. How about at the event?
13:28:20 <mzero> har har
13:28:46 <mzero> there are 80+ people currenting listening to experience reports from industry (IMVU and Alephcloud just spoke)
13:29:15 <mzero> and about another 20+ hacking elsewhere in the Dojo
13:30:04 <rhaps0dy> bayhac?
13:30:19 <mzero> S.F. Bay Area Haskell Hackathon
13:30:28 <mzero> http://www.haskell.org/haskellwiki/BayHac2014
13:30:29 <rhaps0dy> Oh
13:30:38 <rhaps0dy> Damn hackathons around here aren't this cool
13:31:25 <mzero> start one!
13:31:33 <rhaps0dy> c-can I ?
13:31:52 <rhaps0dy> when I learn more Haskell maybe
13:32:30 <pharaun> nice
13:32:35 <pharaun> wish i could show up
13:33:24 <michi7x7> I just learned about lenses. I am _very_ afraid of the library, but the idea is cool...
13:33:57 <shachaf> There are many libraries that give you lenses.
13:34:09 <shachaf> lens is just one of them.
13:34:35 <shachaf> Most of the interesting parts of the library aren't about lenses anyway. :-)
13:34:55 <apples> speaking of lenses.. shachaf, will your talk about them later be recorded? :D
13:35:42 <shachaf> I don't know. I hope not.
13:36:01 <michi7x7> shachaf: are there plans to include some lens functionality (e.g. getters, setters) in the Prelude?
13:36:10 <apples> why not?! (i want to attend, but can't make it down today)
13:36:35 <benzrf> :t _1
13:36:36 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
13:36:39 <benzrf> eeek
13:37:05 <michi7x7> lambdabot has everything :)
13:37:10 <johnw> after a while, that type signature actually starts looking pretty clear
13:37:19 <michi7x7> :t set
13:37:20 <lambdabot> ASetter s t a b -> b -> s -> t
13:37:21 <bennofs> and then you look at
13:37:23 <shachaf> How about tomorrow?
13:37:23 <benzrf> johnw: well im happy to hear that ;-;
13:37:26 <bennofs> :t failing
13:37:27 <lambdabot> (Conjoined p, Applicative f) => Traversing p f s t a b -> Traversing p f s t a b -> Over p f s t a b
13:37:32 * benzrf runs away
13:37:37 <pharaun> haha
13:37:48 <pharaun> all i see is - pf stab
13:37:50 <michi7x7> what the f**k ???
13:37:54 <pharaun> its trying to tell you to stab something?
13:38:04 <shachaf> s t a b is my fault
13:38:18 <shachaf> It used to be a b c d, but I was in a bad mood that day.
13:38:20 <johnw> I like s t a b
13:38:30 <apples> i think i will be able to attend tomorrow
13:39:13 <benzrf> shachaf: o are u a lens contributor
13:39:19 <johnw> he is
13:39:23 <benzrf> naet
13:39:25 <benzrf> *neat
13:39:44 <michi7x7> :t to
13:39:45 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
13:40:17 <michi7x7> this is not a lens yet, right?
13:40:23 <glguy_> to :: (s -> a) -> IndexPreservingGetter s a
13:40:24 <michi7x7> you have to give it a function
13:40:25 <bennofs> only a Getter
13:41:10 <johnw> it couldn't be a lens, since it would need a way to invert the function
13:41:13 <glguy_> depending on if you want to joke about the complicated types or understand what they are it can help to look at them with :i or in haddocks
13:41:40 <michi7x7> :t to length
13:41:40 <shachaf> glguy++
13:41:41 <lambdabot> (Contravariant f, Conjoined p, Functor f) => p Int (f Int) -> p [a] (f [a])
13:41:49 <michi7x7> doesn't make it clearer...
13:42:13 <michi7x7> I really have to think about this first :)
13:42:26 <glguy_> In the immortal words of Barbie, "Math is hard, let's go shopping"
13:43:40 <michi7x7> I think I slowly start to understand it... but really really really slowly :)
13:43:59 <michi7x7> I just figured the (f Int) ^^
13:45:29 <shachaf> "contravariant" is a complicated word. I'll start by figuring out the "tra" and then maybe move on to the 'n's.
13:48:17 <johnw> if f is both Contravariant and a Functor, is it essentially Invariant?
13:48:33 <shachaf> Every Haskell type is Invariant.
13:48:47 <johnw> I was looking here: http://hackage.haskell.org/package/invariant-0.1.0/docs/Data-Functor-Invariant.html
13:48:53 <johnw> where, for example, Identity is not Invariant
13:49:10 <johnw> is that just an oversight?
13:49:21 <johnw> or is it a different concept of invariance?
13:49:28 <shachaf> Try it out.
13:49:33 <johnw> good idea
13:50:14 <jmcarthur> well you can write it, but you're ignoring an argument
13:51:25 <shachaf> Yes.
13:51:45 <shachaf> If f is a Functor you'll always be ignoring that argument.
13:51:55 <shachaf> If it's Contravariant you'll be ignoring the other argument.
13:52:17 <jmcarthur> I take it from the capitalization in "Every Haskell type is Invariant" that you are specifically talking about the Invariant type class, but I struggle to see how one could write  instance Invariant IORef
13:52:46 <michi7x7> Sometimes I just think Haskell has taken "it" too far
13:52:51 <jmcarthur> michi7x7: ?
13:52:53 <michi7x7> lambdabot: mapMOf (traverse._2) (\xs -> length xs <$ putStrLn xs) [(42,"hello"),(56,"world")]
13:53:04 <shachaf> Is IORef in the Report?
13:53:06 <michi7x7> > mapMOf (traverse._2) (\xs -> length xs <$ putStrLn xs) [(42,"hello"),(56,"world")]
13:53:08 <lambdabot>  <IO [(Integer,Int)]>
13:53:40 <michi7x7> whatever, there is no programmer who can read this without digging through libraries for 2 weeks
13:53:54 <jmcarthur> shachaf: no, but how about Ptr
13:54:07 <glguy_> michi7x7: No one is worried about the guy who has only programmed for 2 weeks
13:54:09 <johnw> michi7x7: if you mean that every programmer who wants to read it has to learn how to do so, I would agree
13:54:10 <jmcarthur> well, okay, you could just cast it
13:54:18 <shachaf> Well. OK. I guess the FFI addendum spoils it.
13:54:31 <shachaf> I'll rephrase: Every type you can write as a Haskell 2010 ADT, i.e. using products, sums, and (->), is an instance of Invariant.
13:54:39 <jmcarthur> fair enough
13:54:52 <shachaf> You can make primitive types that aren't.
13:54:55 <bennofs> michi7x7: now you just need to leave out mapMOf, because mapMOf = id
13:55:04 <shachaf> You can also use RankNTypes, GADTs, etc. to make types that aren't.
14:01:47 * hackagebot options 1.1 - A powerful and easy-to-use command-line option parser.  http://hackage.haskell.org/package/options-1.1 (JohnMillikin)
14:05:14 <benzrf> remind me what "Lens' s a" is a syn for again?
14:05:25 <ion> Lens s s a a
14:05:41 <glguy_> Thing' s a = Thing s s a a
14:05:55 <ion> Also: :i Lens' in ghci
14:06:17 <benzrf> yeah but what is Lens s s a a
14:06:18 <benzrf> :P
14:06:20 <benzrf> i
14:06:23 <bennofs> and Lens s s a a is forall f. Functor f => (a -> f a) -> s -> f s
14:06:24 <ion> :i Lens in ghci
14:06:27 <benzrf> ok thanks
14:06:45 <benzrf> wait right >><
14:15:25 <benzrf> whats an example of a Lens' that i can try messing wit
14:15:27 <benzrf> *with
14:17:02 <michi7x7> benzrf: I found this https://github.com/ekmett/lens/blob/master/examples/Pong.hs which seems a nice start to see what you can actually do with them
14:17:13 <michi7x7> But everything here is stateful
14:17:18 <benzrf> well i sort of understand the use of lenses
14:17:22 <augur> benzrf: a Lens' is a lens that doesnt change its type
14:17:29 <benzrf> i just dont get the actual types
14:17:34 <benzrf> i.e.
14:17:34 <glguy> This is my lens/machines example https://github.com/glguy/TwosGame
14:17:41 <benzrf> (a -> f a) -> t -> f t
14:17:43 <augur> benzrf: yeah, understanding the types is a hard thing
14:17:52 <augur> benzrf: i have a tutorial for you!
14:17:55 <benzrf> :O
14:17:59 <benzrf> well
14:18:05 <augur> benzrf: https://www.fpcomplete.com/user/psygnisfive/from-zipper-to-lens
14:18:05 <benzrf> i *sort* of get how that type works
14:18:09 <benzrf> i just dont get the point of the f
14:18:18 <benzrf> also thanks augur :]
14:18:59 <augur> benzrf: the twanvl__ type (Functor f => (a -> f b) -> s -> f t) is the big mystery of modern lenses
14:19:12 <augur> so i tried to explain it in the tutorial
14:19:41 <Faucelme> benzrf: Varying the "f" lets you choose between the getting, setting, and modifying behaviours.
14:19:47 <benzrf> h-huh
14:20:02 <benzrf> oh i think i *might* understand
14:20:18 <benzrf> if you choose a functor with some kind of extra field or something...
14:20:25 <benzrf> you can hold onto the argument when it reassembles it
14:20:41 <benzrf> oh wait
14:20:47 <benzrf> in fact that's not even necessary
14:20:56 <benzrf> if you use a Const a functor
14:21:00 <benzrf> you have a getter
14:21:01 <benzrf> :O
14:21:04 <Faucelme> yes
14:21:05 <benzrf> ok let me read that tutorial
14:21:29 <Faucelme> And if the "a" in "Const a" is a Monoid
14:21:33 <Faucelme> you get a fold.
14:21:39 <benzrf> i dont really know folds
14:21:42 <benzrf> :d
14:21:47 <benzrf> or traversables
14:21:48 <benzrf> u_u
14:22:33 <Faucelme> Folds in lens, like the Foldable typeclass, are just a generalizations of "toList".
14:23:05 <augur> dont worry about folds or such right now, benzrf
14:23:26 <augur> its not relevant
14:28:03 <benzrf> ok
14:28:05 <benzrf> so Const is get
14:28:09 <benzrf> Identity is set
14:28:09 <ion> benzrf: Are you familiar with traverse/mapM?
14:28:12 <benzrf> and...
14:28:16 <benzrf> ion: i know mapM
14:28:17 <benzrf> not traverse
14:28:28 <benzrf> is ((->) r) modify?
14:28:33 <ion> traverse is mapM but with an Applicative constraint instead of Monad.
14:28:35 <benzrf> or something
14:28:41 <benzrf> ion: o:
14:28:43 <FreeFull> :t traverse
14:28:43 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:28:51 <benzrf> well i do not know traversable
14:28:52 <FreeFull> Traversable constraint too
14:28:54 <Fuuzetsu> enthropy: No, we don't run any CPP ourselves as far as I'm aware. Honestly, the message at the end of the log makes me think that your comment is simply in a place we (GHC) are not expecting it to be
14:29:01 <FreeFull> Rather than just lists
14:29:26 <augur> benzrf: identity isnt set, per se
14:29:37 <benzrf> augur: oh?
14:29:39 <augur> benzrf: set and modify are two sides of the same coin
14:29:43 <benzrf> oic
14:29:54 <augur> specifically, set is modify with a constant function
14:29:57 <benzrf> Identity . const is set
14:30:12 <benzrf> and Identity . whatever is over
14:30:30 <augur> not quite Identity.const, but almost, sure
14:30:47 <benzrf> ??
14:30:49 <benzrf> not quite?
14:30:55 <benzrf> @src over
14:30:55 <lambdabot> Source not found.
14:30:58 <benzrf> :t over
14:30:59 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
14:31:05 <augur> you need to remember
14:31:23 <augur> set and get and so forth, these apply to lenses to do something
14:31:25 <Aetherspawn> so does that mean that the same way liftA can be faster than liftM due to parallel graph reducton or whatever
14:31:34 <Aetherspawn> traverse could be faster than mapM ?
14:31:35 <augur> the way they apply to lenses is by supplying a lens with arguments
14:31:46 <benzrf> well yeah
14:31:51 <benzrf> i mean that something like
14:32:18 <augur> namely,   set l x s = getIdentity (l (Identity (const x)) s)
14:32:21 <augur> or something like that
14:32:30 <benzrf> :p i was about to write that
14:32:37 <Fuuzetsu> enthropy: checking how it looks like after TH has been applied is probably the smartest thing
14:39:46 <oscarb92> hello
14:39:57 <oscarb92> I'm new at haskell
14:40:11 <Polarina> oscarb92, hello!
14:40:15 <Polarina> And welcome.
14:41:00 <AlexRussia> Hello! Where i can get help about cabal?
14:41:06 <oscarb92> Could somebody explaing this function to me?
14:41:30 <oscarb92> columnAt :: Int -> [Int] -> [Int]
14:41:34 <oscarb92> columnAt p s = helperColumnAt (itop p) s
14:41:35 <oscarb92> -- Retrieves the vertical column of values from the board (s) at the index (p)
14:41:40 <oscarb92>   where helperColumnAt (x, _) s = map (\y -> s !! ptoi (x, y)) [0..8]
14:42:04 <benzrf> bbl
14:42:07 <oscarb92> It works, but I can't see how it does it
14:42:24 <hpc> what are itop and ptoi?
14:42:32 <bennofs> oscarb92: please use lpaste for pasting code snippets that are more than one line in the future
14:42:35 <oscarb92> itop converts an index of a list to a coordinate
14:42:37 <bennofs> @where lpaste
14:42:37 <lambdabot> http://lpaste.net/new/haskell
14:42:44 <oscarb92> ptoi does the opposite
14:42:59 <hpc> ah
14:43:04 <hpc> so this looks like chess, then
14:43:18 <oscarb92> Ok, sorry
14:43:29 <hpc> just thinking out loud
14:43:55 <oscarb92> http://lpaste.net/104248
14:44:00 <oscarb92> no
14:44:15 <oscarb92> It's a helper function for a sudoku solver
14:44:19 <hpc> ah
14:44:33 <oscarb92> I'm trying to understand every function
14:44:45 <hpc> so, it takes an Int, which represents a single square
14:44:58 <hpc> returns the column for that square by doing
14:45:05 <oscarb92> The first parameter would be the index
14:45:06 <hpc> get the x coord of that square
14:45:21 <mizu_no_oto> If I want to add a flag to cabal, should I write the code and submit a pull request on github, or write a proposal on the mailing list first?
14:45:30 <hpc> build a list of each square at (x, foo) for x being the coord of the passed square, foo being from 0 to 8
14:45:32 <oscarb92> the second the list of 81 elements that represents the sudoku grid
14:46:25 <Polarina> mizu_no_oto, why not do both? That way you get the flag, and people to look over your implementation.
14:47:49 <mizu_no_oto> Polarina: That is to say, write the code, submit a pull request and then email the mailing list about it?
14:47:58 <michi7x7> oscarb92: start inside out with the helperColumnAt
14:48:57 <michi7x7> (\y -> s !! ptoi (x, y)) this takes an Y-coordinate, transforms it in a position (x,y), uses ptoi to get the real index and returns the element (!!)
14:48:57 <Polarina> mizu_no_oto, yes. You'd have a lot more changc of success if all the maintainers have to do is accept the pull request, should they like the idea.
14:49:07 <mizu_no_oto> Also, I should write this in the master branch, correct?
14:49:16 <Polarina> s/changc/chance/
14:49:19 <michi7x7> everything else should fall in nicely (I think)
14:50:21 <Polarina> mizu_no_oto, I don't know the maintenance practices of cabal, but I'd guess that's just as a good place as any.
14:50:50 <monochrom> in the pull request message, include a link to the mailing list message you post.
14:51:03 <monochrom> in the mailing list message you post, include a link to the pull request
14:51:14 * monochrom creates a chicken-egg problem! :)
14:51:53 <oscarb92> The way I see the function it should return [x,x,x,x,x,x,x,x,x] being x the position of the square you give to it
14:51:54 <mizu_no_oto> Well, presumably you'd create a pull request, write the email, then write a comment on the pull request
14:52:14 <oscarb92> hpc: The way I see the function it should return [x,x,x,x,x,x,x,x,x] being x the position of the square you give to it
14:52:15 <monochrom> how dare you solve my tie-the-knot problem! :)
14:52:41 <michi7x7> oscarb92: read my message
14:53:19 <bennofs> monochrom: edit the PR after you wrote the email. Mutable data ftw!
14:53:21 <hpc> oscarb92: basically, it's returning [lookup grid (xcoord p, 0), lookup grid (xcoord p, 1), lookup grid (xcoord p, 2), lookup grid (xcoord p, 3), ...
14:53:32 <oscarb92> michi7x7: I know but as I said, The way I see the function it should return [x,x,x,x,x,x,x,x,x] being x the position of the square you give to it
14:53:33 <hpc> fsvo lookup, xcoord
14:54:32 <michi7x7> oscarb92: I don't get what you mean. It returns all the values along the y-coordinate
14:57:04 <oscarb92> hpc: I think I missunderstood the lambda function
14:57:54 <hpc> oscarb92: you'll get used to it
14:58:48 <hpc> imo that's not very readable anyway; it's using a single list to represent both dimensions of the grid
14:59:01 <hpc> which i expect makes every other function similarly wonky
14:59:33 <michi7x7> oscarb92: http://lpaste.net/104248
14:59:36 <michi7x7> does this help?
15:00:15 <oscarb92> hpc: Yea and what's the deal with those itop and ptoi functions that basically do nothing to the final data
15:02:09 <proxfox> does anyone know how to easily translate imperative algorithms to Haskell? I've managed to write A* and it was fine, even did a refutation resolution theorem prover, did struggle with it during the proving part but finished it successfully, but now, when I'm doing an expert system and have to communicate with the user I cannot seem to keep the state updated, short-circuiting out from iteration and at the same time reading from IO (which upda
15:03:47 <Cale> proxfox: your message was cut off at "(which upd"
15:04:02 <proxfox> (which updates the state)... I'm totally lost...
15:04:14 <proxfox> user provides me with information which i must include in the state
15:04:29 <mizu_no_oto> proxfox: if you want to implement imperative algorithms, you might want to look at State or ST
15:04:38 <Cale> proxfox: Well... let's just start with functions
15:05:21 <oscarb92> michi7x7: thank you, already got it :D
15:05:33 <Cale> It's definitely possible to simulate a state machine using pure functions if you want to
15:06:41 <hpc> at the risk of being boo'd out of the channel, don't be afraid to just make things mutable
15:06:45 <hpc> if it makes sense for them to be
15:06:50 <Cale> (which is what the State monad does, internally using functions s -> (s,a) to simulate machines which take some initial state of type s, and produce a final state along with a result of type a
15:06:53 <Cale> )
15:06:54 * hackagebot stringtable-atom 0.0.7 - Memoize Strings as Atoms for fast comparison and sorting, with maps and sets  http://hackage.haskell.org/package/stringtable-atom-0.0.7 (AudreyTang)
15:07:16 <Cale> and sure, if it makes sense to have things in IORefs, those certainly exist
15:08:00 <Cale> It can be nice to decouple the I/O from the rest of the program as much as possible though, particularly when testing.
15:08:51 <proxfox> Cale: I did manage to split the pure code from the monadic but having IO monad and a state (Map) which changes under many conditions, I just get lost in all of the "versions" of the state...
15:09:13 <proxfox> but yes, I didn't consider using mutable variables
15:09:27 <mizu_no_oto> profox: how did you handle the state?
15:10:04 <mizu_no_oto> proxfox, I mean
15:10:06 <proxfox> mizu_no_oto: it is just a single Data.Map, and I'm only inserting...
15:10:34 <mizu_no_oto> So you kept passing the new map into each function?
15:10:49 <mizu_no_oto> And returning the current map?
15:11:09 <proxfox> mizu_no_oto: the problem is that imperative algorithm has many "if then" parts which change the state, and I have to know if I leave the "loop" or just update the state and continue, it turns into a real mess
15:12:19 <proxfox> mizu_no_oto: yes I would just keep passing the new map but "if then" parts make it hard for me to realize which map it is
15:14:26 <mizu_no_oto> proxfox: try to refactor the code to use do notation and the State monad.  It should make the code easier t follow, expecially since you can put if statements into it
15:14:59 <proxfox> miizu_no_oto: what about IO? how can I easily work with IO and State monad?
15:15:20 <mizu_no_oto> With both IO and State?
15:15:43 <inetic> Hi, I'm would like to try some yesod tutorial, but can't get to install it properly. When running "yesod devel" I'm informed that some dependencies are missing, like e.g. shakespeare==2.0.* but I did install it using "cabal install shakespeare" which installed 2.0.0.3 version. Please help point out what I'm missing.
15:17:21 <proxfox> mizu_no_oto: yep, during the algorithm I have to ask the user for input and incorporate the given value to state
15:17:44 <albeit> Is it a good idea to newtype pretty much all "type"d string and number types?
15:18:12 <Cale> proxfox: Well, there is StateT, but StateT over IO is often more awkward than just using an IORef.
15:18:16 <nh2> inetic: there is a #yesod channel
15:18:28 <Cale> proxfox: Unless you're really committed to producing a self-contained library
15:19:45 <inetic> nh2: thanks. though, I thought this would be more of a generic haskell + ubuntu + installing issue
15:20:31 <nh2> inetic: potentially - just so you know that exists
15:24:23 <pharaun> is there a good example of using STRef i'm having trouble finding much
15:25:23 <pharaun> trying to use STRef with a list of STRef and monadic errors, and having trouble making the types work
15:25:52 <proxfox> Cale: yep I do agree that StateT over IO is awkward... I'll try the IORef then, thanks for the suggestion...
15:26:01 <platz> Is it common at all for a function to take a monadic state value as a parameter, e.g. foo :: State a b -> c
15:26:12 <pharaun> (Replacing IORefs with STRefs since i want each run to have its own ST instead of being shared via IORefs
15:26:13 <platz> most examples I've seen use it in the return value position
15:26:20 <platz> where it seems to make the most sense
15:36:58 <Apocalisp> What is this cabal error telling me?
15:36:59 <Apocalisp> http://pastie.org/9185634
15:38:09 <hpc> Apocalisp: it couldn't find a version of that dependency that worked
15:38:17 <hpc> Apocalisp: and it shows you why each version failed
15:39:12 <hpc> reducers wants one version, ermine wants another
15:39:24 <Apocalisp> I read that as reducers requiring text==0.11.3.1 and ermine requiring text >= 1.1
15:39:53 <benzrf> hey, is >> on comonads <$
15:40:08 <benzrf> or is '>> on comonads' even meaningful
15:40:10 <tvorog> hi everyone! I can't install some package by cabal. Can you help? Here the output: http://pastebin.com/RXQZnEiK
15:41:03 <hpc> benzrf: you refer to (\_ -> b) `extend` a?
15:41:09 <hpc> http://hackage.haskell.org/package/comonad-4.2/docs/Control-Comonad.html
15:41:36 <benzrf> hpc: i guess so
15:41:46 <benzrf> that has type
15:41:53 <hpc> benzrf: it is similar to (<$)  for every use-case i can imagine
15:41:54 <benzrf> w a -> b -> w b right
15:42:05 <benzrf> ok so my brain is functioning correctly
15:42:06 <benzrf> :-D
15:42:26 <geekosaur> tvorog, that's ... odd. is there a program named configure somewhere in $PATH?
15:42:26 <hpc> it might be provably identical, but i would have to think a little bit about it
15:42:30 <benzrf> is Identity the only monad AND comonad?
15:42:41 <geekosaur> (also if this turns out to be the problem then I smell a cabal bug)
15:43:05 <benzrf> > fmap (++"test") (1, "")
15:43:06 <lambdabot>  (1,"test")
15:43:09 <benzrf> neat
15:44:04 <benzrf> > _1 (id &&& id) (3, 4)
15:44:06 <lambdabot>  (3,(3,4))
15:44:08 <benzrf> o:
15:44:11 <hpc> Apocalisp: it might also be a "butterfly dependencies" problem, but i haven't been keeping up enough to know if that's the output cabal gives for it
15:44:25 <benzrf> > Free 3
15:44:27 <lambdabot>  Not in scope: data constructor ‘Free’
15:44:31 <benzrf> kk
15:44:37 <benzrf> Is Free a functor
15:44:57 <hpc> https://cdsmith.wordpress.com/2011/01/17/the-butterfly-effect-in-cabal/
15:45:01 <benzrf> > _1 (id &&& const "foo") (3, 4)
15:45:03 <lambdabot>  (3,("foo",4))
15:45:28 <tvorog> geekosaur, Nope
15:49:45 <benzrf> > _1 (const id) (3, 4)
15:49:46 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:49:47 <lambdabot>    arising from a use of ‘M567114993084749246314515.show_M5671149930847492463...
15:49:47 <lambdabot>  The type variable ‘a0’ is ambiguous
15:49:47 <lambdabot>  Note: there are several potential instances:
15:49:47 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:49:51 <benzrf> :t _1 (const id) (3, 4)
15:49:52 <lambdabot> Num t => a -> (a, t)
15:50:01 <benzrf> > (_1 (const id) (3, 4)) 5
15:50:02 <lambdabot>  (5,4)
15:50:09 <benzrf> o=
15:51:58 * hackagebot options 1.2 - A powerful and easy-to-use command-line option parser.  http://hackage.haskell.org/package/options-1.2 (JohnMillikin)
15:53:38 <hseg> Hi. Where does the commutative diagram regarding strength come from in http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf ?
15:55:51 <hseg> In the sense that I don't understand the category-theoretical basis for the diagram.
16:16:19 <hseg> Hello? What is meant here: http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
16:16:20 <hseg>  when they say (**) must respect the tensorial strength required by the fact that other names may be in scope?
16:16:33 <benzrf> :t (**)
16:16:34 <lambdabot> Floating a => a -> a -> a
16:17:09 <benzrf> @let (..........) = 3
16:17:11 <lambdabot>  Defined.
16:17:16 <benzrf> > L...........
16:17:18 <lambdabot>  <hint>:1:1: parse error on input ‘L...........’
16:17:20 <benzrf> :{
16:17:23 <benzrf> > (L...........)
16:17:25 <lambdabot>  3
16:17:27 <benzrf> lol
16:17:35 <smiller2> Shouldn't monad-par provide a monad *transformer* for ParIO, where runParIOT :: (MonadIO m) => ParIOT m a -> m a?  I suspect it's design flaw, and I'm tempted to contribute a patch, but if this is deliberate I shouldn't.  Imagine, for example, combining ParIO with 'Process' from distributed-process.
16:19:35 <ArisFr> Can anyone guess why the exact same code segfaults when executed directly as a binary, and runs fine when when executed via GHCi (:main arg1 arg2 ...)?
16:19:48 <c_wraith> smiller2: What if m is something that doesn't work in parallel, like State?
16:20:54 <c_wraith> smiller2: or really, just about everything more complex than Maybe.
16:21:11 <benzrf> ArisFr: what code
16:21:29 <c_wraith> smiller2: a very important part of monad-par is that the result of the computation must not depend on the order of evaluation.
16:23:22 <enthropy> Fuuzetsu: CPP runs before TH. Anyways, I "fixed" it by adding a {-# LANGUAGE NoCPP #-}. I guess it's cabal's fault for running cpp over all files when only one or two actually need it.
16:23:24 <ArisFr> benzrf: It's not actually my own code. I am using EclipseFP, which uses BuildWrapper internally, which in turn depends on and used dynamic-cabal, which in turn dynamically loads Cabal. The problem, after lots of debugging, seems to be somewhere within Cabal
16:24:27 <ArisFr> benzrf: or in the way BuildWrapper uses dynamic-cabal to run Cabal queries.
16:25:00 <ArisFr> If I load BuildWrapper in GHCi and do :main arg1 arg2 ... it works fine
16:25:06 <ArisFr> benzrf:  If I load BuildWrapper in GHCi and do :main arg1 arg2 ... it works fine
16:25:25 <ArisFr> benzrf: But If i run the BuildWrapper binary directly, it segfaults
16:25:41 <ArisFr> what could GHCi be doing differently?
16:26:15 <geekosaur> running it in a different thread, is one possibility
16:26:27 <hseg> benzrf, I meant (**) from Monoidal. i.e. (**) :: Monoidal f => (f a, f b) -> f (a,b)
16:26:39 <mister_integer> Hi all!
16:26:51 <mister_integer> I am getting a build error on persistent-1.3.11
16:26:54 <ArisFr> geekosaur: are you responding to me?
16:26:56 <mister_integer> *1.3.1.1
16:27:04 * hackagebot latest-npm-version 0.3.0 - Find the latest version of a package on npm  http://hackage.haskell.org/package/latest-npm-version-0.3.0 (passy)
16:27:05 <enthropy> dunno about your specific case, but FFI to code that is wrong (accessing invalid addresses for example) segfaults more often when compiled than when in ghci
16:27:07 <geekosaur> ArisFr, yes
16:27:55 <ArisFr> I see, any particular way to debug this?
16:28:05 <ArisFr> I cant use GHCi obviously :)
16:28:26 <geekosaur> if it's a threading issue, you can use :set -fno-ghci-sandbox and see if ghci then dumps core
16:28:44 <geekosaur> (I think that's the option. also may not work for ghc 7.8, I think they decided to ditch the sandbox?)
16:28:53 <benzrf> jjjjjjjjjjj
16:29:06 <enthropy> ArisFr: can you run the crashing binary in something like valgrind?
16:29:32 <enthropy> what you get out of that might be a useful name or two
16:29:58 <ArisFr> geekosaur: I tried it on 7.8.2, the option was accepted, but it still runs fine (it shouldn't)
16:30:15 <ArisFr> enthropy: yes, I can try, but aren't haskell symbols useless?
16:30:25 <Arafangion> Hey, I'm trying to understand all aspects of the IO Monad.  From what I gather the IO Monad allows Haskell code to describe what sort of IO actions it wants to perform (as distinct from actually performing the actions itself)
16:30:42 <geekosaur> ArisFr, if it's a problem with FFI, you may well find it crashed in C library code
16:30:57 <hseg> Arafangion, More or less, what's the question?
16:31:14 <ArisFr> Um, I think it's somewhere in the Cabal library
16:31:20 <geekosaur> mister_integer, you'll have to provide a build log.
16:31:20 <enthropy> ArisFr: yes it's quite likely to be useless
16:31:22 <geekosaur> @paste
16:31:22 <lambdabot> Haskell pastebin: http://lpaste.net/
16:31:30 <geekosaur> mister_integer, ^^ pastebin
16:31:49 <Arafangion> hseg: I want to understand it in terms of how it actually tells the runtime what to do.  If IO was limited to basic input and output, I would understand it more, however how does it also encompass FFI and general IO on more than just stdin and stdout?
16:32:15 <benzrf> Arafangion: IO is for anything effectful
16:32:16 <mister_integer> geekosaur: thanks, one sec :)
16:32:26 <ArisFr> OK, thanks guys, I think at least I can rejects some investigation avenues through your help. Thanks a lot.
16:32:31 <smiller2> c_wraith: Wouldn't the state computation itself run sequentially?
16:32:50 <hseg> Arafangion, Basically, you're correct in that IO as it stands today is a patchwork of all sorts of effectful computations.
16:33:18 <c_wraith> smiller2: If it does, you don't have parallelism.  The *whole thing* would be a state computation.
16:33:21 <Arafangion> hseg: I imagine that the VM must be taking the IO monad, interpreting it and applying the actions, just trying to work out how it determines which action I want.
16:33:37 <mister_integer> geekosaur: http://lpaste.net/104253
16:34:01 <benzrf> Arafangion: i believe that at an underlying level there is an impure function wrapped in a different ineterface
16:34:04 <benzrf> *interface
16:34:08 <hseg> Arafangion, http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
16:34:10 <benzrf> :t GHC.Base.IO
16:34:10 <lambdabot> (GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, a #)) -> IO a
16:34:12 <mister_integer> I'm afraid I may have performed some harmful reinstalls
16:34:22 <benzrf> Arafangion: that's the IO data constructor
16:34:39 <benzrf> > (# 1, 2 #)
16:34:40 <lambdabot>  Kind incompatibility when matching types:
16:34:40 <lambdabot>    a0 :: *
16:34:40 <lambdabot>    (# a1, a2 #) :: #
16:34:45 <benzrf> > (# 1#, 2# #)
16:34:46 <lambdabot>  Kind incompatibility when matching types:
16:34:46 <lambdabot>    a0 :: *
16:34:46 <lambdabot>    (# GHC.Prim.Int#, GHC.Prim.Int# #) :: #
16:34:51 <benzrf> O_O
16:34:52 <glguy> mister_integer: What files are contained in: /Users/johnbc/Library/Haskell/ghc-7.6.3/lib/monad-logger-0.3.6.1/lib ?
16:35:17 <hseg> Arafangion, Basically, you can convert any monad into a data type of all the primitive operations it supports, and then the runtime interprets it, operation by operation.
16:35:44 <mister_integer> glguy: "Control HSmonad-logger-0.3.6.1.o libHSmonad-logger-0.3.6.1.a libHSmonad-logger-0.3.6.1_p.a"
16:36:06 <Arafangion> hseg: My confusion is, isn't the IO monad actions defined in terms of basic IO actions on stdin and stdout (effectively), or is the website I provided massively simplified?
16:36:11 <ezyang> When a Template Haskell quasiquoter fails, by default it prints the string that was quoted. How can I suppress that output?
16:36:21 <Arafangion> hseg: There must be a vast number of IO constructors?
16:36:54 <benzrf> Arafangion: the website is oversimplified
16:37:10 <benzrf> Arafangion: the IO data constructor wraps around an unsafe impure function
16:37:14 <hseg> Arafangion, those constructors are conceptual and just to help you see the picture.
16:37:16 <Arafangion> benzrf: Can you suggest a more comprehensive one?
16:37:16 <geekosaur> Arafangion, when we describe IO that way, we're talking conceptually. the reality is much more complex, but you can pretend that the "constructor" is the address of a chunk of C code
16:37:33 <benzrf> Arafangion: look again
16:37:37 <benzrf> :t GHC.Base.IO
16:37:38 <lambdabot> (GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, a #)) -> IO a
16:37:39 <glguy> mister_integer: I got errors like that after I tried reinstalling a package over itself using a newer version of cabal-install
16:37:45 <Arafangion> hseg: Ah, in that they seem to be working, but now I want the 'larger picture'.
16:38:10 <Arafangion> geekosaur: How do I extend the conceptual picture there in terms of FFI and other files?
16:38:18 <mister_integer> glguy: yeah, I just updated cabal-install as well
16:38:23 <glguy> mister_integer: One of the recent versions of Cabal or cabal-install ( I never quite worked out which was at fault) changed the way that it installed packages in a way that wasn't compatible with overwriting
16:38:23 <mister_integer> What's the recommended cleanup?
16:38:31 <enthropy> ezyang: use fail instead of error
16:38:37 <Arafangion> geekosaur: Do I define IO in terms of not only Put and Get, but also in terms of CallFfi and the like?
16:38:40 <ezyang> enthropy: Gotcha, thanks
16:38:41 <glguy> mister_integer: Try blowing away the directories corresponding to the library in question and reinstall that library
16:38:54 <hseg> Arafangion, Something like that.
16:38:56 <benzrf> Arafangion: GHC evidently provides impure functions that are defined not in haskell code
16:38:57 <geekosaur> Arafangion, if you really want to get an idea of what is actually going on, http://www.haskell.org/haskellwiki/IO_inside describes how GHC does things
16:39:10 <benzrf> Arafangion: similar to how languages like python have functions that are defined in C
16:39:18 <benzrf> Arafangion: it then wraps these functions in the IO type
16:39:28 <geekosaur> I do not actually suggest you read that though; it will just mislead you, probably
16:39:36 <benzrf> Arafangion: but most of that is implementation-specific afaik
16:39:39 <Arafangion> geekosaur: I'll read through it. :)
16:39:43 <geekosaur> you should really not worry about the implementation
16:39:47 <geekosaur> but I see you intend to anyway
16:40:19 <benzrf> @src getLine
16:40:19 <lambdabot> getLine = hGetLine stdin
16:40:20 <Arafangion> geekosaur: I should probably be reading the ghcjs implementation, as that's what I intend to use.
16:40:27 <benzrf> @src hGetLine
16:40:27 <lambdabot> Source not found. That's something I cannot allow to happen.
16:40:39 <benzrf> Arafangion: did you listen to any of what i said >.<
16:40:48 <geekosaur> that may well be differnet,, yes, but you'll need to check the ghc wiki for any docs on that
16:41:44 <Arafangion> benzrf: Yes, but it still confuses me. If it's "just" a wrapper around an unsafe impure function, then how can Haskell be calilng into it? (Unless Haskell is unable to construct the IO monad, and thus must use one the one that is present in main - I guess that makes sense)
16:41:59 <Arafangion> benzrf: Which statement do you think I've missed?
16:42:05 <benzrf> i kinda wanna try writing my own eeevil IO hax but i keep getting tripped up by # vs *
16:42:08 <benzrf> Arafangion: hmm
16:42:13 <benzrf> Arafangion: pattern matching :-)
16:42:19 <geekosaur> Arafangion, IO is defined such that you cannot (easily) just construct one on the fly
16:42:35 <benzrf> > let (GHC.Base.IO wtf) = getLine in wtf
16:42:36 <lambdabot>  Not in scope: data constructor ‘GHC.Base.IO’
16:42:40 <benzrf> :t let (GHC.Base.IO wtf) = getLine in wtf
16:42:40 <monochrom> yes, Haskell is unable to construct the IO monad, and thus must use what the compiler exports.
16:42:40 <hseg> Arafangion, Haskell itself doesn't call into it, the runtime system does. Unless I'm misunderstanding your question?
16:42:41 <lambdabot> GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, String #)
16:42:42 <Arafangion> geekosaur: Am I assuming that 'not easily', is how the various logging libraries in haskell work?
16:42:54 <geekosaur> although there is actually a way, not even very well hidden. but if you use it, you are breaking various rules and will usually be made to pay for it unless you know exactly what you are doing
16:43:08 <benzrf> Arafangion:
16:43:09 <benzrf> :t let (GHC.Base.IO wtf) = getLine in wtf
16:43:10 <lambdabot> GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, String #)
16:43:28 <geekosaur> new Haskell programmers often think they can use that to get something they understand, and then are completely baffled when their programs don't do anything like what they expected
16:43:39 <Arafangion> hseg: You're not quite misunderstanding my question.  My question was really: "How does the IO MOnad contain enough information to tell the runtime what to do?"
16:43:52 <geekosaur> it doesn't actually need to
16:43:55 <benzrf> Arafangion: however it is quite tricky to get ahold of a value of type RealWorld
16:44:13 <benzrf> Arafangion: let alone GHC.Prim.State# ;)
16:44:31 <geekosaur> it's a state monad over a type you cannot easily get a value for
16:44:42 <benzrf> :t undefined :: RealWorld
16:44:43 <lambdabot> RealWorld
16:44:45 <benzrf> wait what
16:44:50 <benzrf> shit i thought RealWorld :: #
16:44:53 <geekosaur> and then it just makes the calls directly (via the FFI)
16:44:53 <benzrf> o=
16:45:03 <benzrf> the FFI is unsafe
16:45:06 <geekosaur> benzrf, the real one is RealWorld#
16:45:13 <benzrf> ah
16:45:22 <hseg> Question. In http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
16:45:23 <hseg> , they say "The natural transformation
16:45:23 <hseg>  m
16:45:23 <hseg> corresponding to *
16:45:23 <hseg> 
16:45:24 <hseg> must also respect the strength" and give an appropriate diagram. What is the category-theoretical concept that they're using?
16:45:24 <geekosaur> I presume this "RealWorld" is someone noodling about in @let
16:45:33 <benzrf> ooh.
16:45:49 <Arafangion> geekosaur: if I was implementing this, with my (astonishingly limited) understanding of Haskell, I'd be defining a monad that included the FFI function I was interested in and it's arguments.
16:46:10 <Arafangion> geekosaur: However, every FFI that I specify would need to be mapped to the IO Monad so that the runtime would know about it?
16:46:30 <monochrom> Arafangion: in Hugs, IO is an algebraic data type that contains transparent information. in GHC, IO is an arbitrary procedure, therefore it contains more information than you ever need, but opaguely.
16:46:51 <monochrom> s/opague/opaque/
16:46:53 <geekosaur> if you wanted to do it the naïve way, you'd use something like: IO a = ... | FFI Address [CTypeSpec] CTypeSpec
16:47:37 <geekosaur> where the list contains the types of parameters and the final type is that of the result
16:47:37 <Arafangion> geekosaur: So conceptually the IO monad contains every allowable interaction with the real world that haskell would allow?
16:47:49 <geekosaur> Arafangion, conceptually yes
16:48:07 <benzrf> no, RealWorld is lifted!
16:48:08 <benzrf> Prelude GHC.Prim> undefined :: RealWorld
16:48:14 <benzrf> ^does not error for me
16:48:37 <geekosaur> practically, we do something much simpler in direct implementation and more complex in the type system
16:49:08 <Arafangion> geekosaur: But i can view that as an optimisation, I expect?
16:49:22 <geekosaur> you probably should, yes
16:49:43 <geekosaur> the conceptual view keeps people from trying to be too clever and programming themselves into a corner they can't easily get out of
16:49:44 <Arafangion> benzrf: That stands to reason, there has to be some kind of transformation.
16:51:15 <Arafangion> geekosaur: I think being aware of how this is a conceptual facade helps understand how I can tell the runtime about "pure" and "impure" FFI's.
16:51:26 <monochrom> although RealWorld has values, State# RealWorld does not have to.
16:51:57 <hseg>  /quit
16:52:06 <geekosaur>  /no
16:52:18 <shachaf> monochrom: RealWorld has values?
16:52:49 <monochrom> what do you want to say?
16:52:50 <benzrf> shachaf:
16:52:55 <benzrf> > undefined :: RealWorld
16:52:58 <lambdabot>  No instance for (GHC.Show.Show GHC.Prim.RealWorld)
16:52:58 <lambdabot>    arising from a use of ‘M545602391430807999615348.show_M5456023914308079996...
16:53:32 <benzrf> @let instance Show GHC.Prim.RealWorld where show = const "wtf did you even do to get this"
16:53:33 <lambdabot>  .L.hs:151:15:
16:53:33 <lambdabot>      Not in scope: type constructor or class ‘GHC.Prim.RealWorld’
16:53:36 <benzrf> lame.
16:53:45 <benzrf> @let import GHC.Prim
16:53:46 <lambdabot>  .L.hs:111:1:
16:53:46 <lambdabot>      GHC.Prim: Can't be safely imported! The module itself isn't safe.
16:53:49 <benzrf> ;-;
16:54:02 <shachaf> Oh, you mean _|_ :: RealWorld
16:54:07 <benzrf> yeah
16:54:08 <shachaf> Sure, I guess.
16:54:32 <Arafangion> geekosaur: So while it's possible to call the FFI directly and do stuff (lets ignore any housekeeping that the impure or pure function may need), doing it via the IO Monad keep the concepts clear?
16:54:38 <benzrf> is State# unlifted purely to keep people from passing bottom to IO-wrapped funcs
16:55:01 <Arafangion> geekosaur: (That was a rhetorical question... Mostly talking ot myself on that line): Thanks for helping me understnad (you too benzrf!)
16:55:07 <benzrf> :-)
16:55:38 <monochrom> it seems strange to find out IO implementations for how to declare which FFIs are pure vs impure. I would think that "foreign import/export ccall xxx :: CInt -> CInt" already says it's pure, and "foreign import/export ccall yyy :: CInt -> IO CInt" already says it's impure.
16:55:52 <dolio> error "foo" :: State# RealWorld
16:56:28 <Arafangion> monochrom: Unless I'm mistaken, there's also a distinction between FFI's that might call back into Haskell.
16:57:38 <monochrom> that seems to be an orthogonal issue
16:57:44 <geekosaur> Arafangion, doing it via the IO monad deals with some other complexities as well. like, C libraries generally would have no idea what to do if Haskell did a timed garbage collection while they ran
16:57:49 <dolio> undefined is supposed to be able to be unboxed, too, according to the GHC source, but it doesn't work for some reason.
16:58:10 <geekosaur> signal handling is also difficult when you can't be sure which language's runtime should be dealing with them
16:58:35 <zacts> ok just to double check, but what is the best complete newbie guide to learning haskell? LYAH?
16:58:38 <geekosaur> making the FFI go through IO means we can safely suspend Haskell's runtime and reactivate the C one
16:58:51 <geekosaur> and avoid lots of nasty corner cases
16:58:59 <Arafangion> geekosaur: That reminds me of the other question I had: Is everything done through the IO monad sequentialized?
16:59:04 <geekosaur> yes
16:59:11 <geekosaur> that's a large chunk of its purpose
16:59:16 <Arafangion> geekosaur: So dealing with multiple libraries in their own thread isn't really possible?
16:59:26 <geekosaur> although, "sequential" is in the context of a thread, not of the whole program
16:59:53 <Arafangion> geekosaur: Ah, so it depends on how the (Haskell) threading library exposes IO, if at all? (I've not covered threads yet)
17:00:34 <pdxleif> I remember it used to seem like Hackage kept a record of which GHC versions your package built on.
17:00:39 <geekosaur> threads are created in IO, and a new thread produces a value in IO (just like main)
17:00:45 <pdxleif> Is that still available, or should I use something like https://github.com/hvr/multi-ghc-travis ?
17:00:54 <monochrom> zacts: there does not exist complete guides. there are incomplete guides, and complete unguides (references)
17:01:27 <stolaruk> How can I make "cabal repl" read a .ghci file?
17:01:47 <hpc> stolaruk: :source, i think?
17:02:03 <Arafangion> geekosaur: So it comes down to the implementation of how the runtime implements threads and how IO is done in terms of the threads. (I expect ghcjs sequentialises everything...  Given that the host javascript VM is singlethreaded)
17:02:04 <hpc> stolaruk: no, :script filename
17:02:07 <stolaruk> hpc: Is there a non-manual way to do it?
17:02:15 <hpc> dunno
17:02:50 <geekosaur> I don't know enough about ghcjs to know what it does
17:03:29 <pdxleif> Haskell threads (green threads) are implemented in terms of events - I imagine the JS backend could do the same thing.
17:03:30 <Arafangion> geekosaur: I think I have a better understanding of the IO monad concept. :) Thanks.
17:03:31 <zacts> monochrom: oh well what is the best tutorial/book to read as a complete newbie?
17:03:41 <zacts> to which I can learn more further on my own
17:03:46 <zacts> is LYAH a good start?
17:03:49 <monochrom> yes
17:03:56 <zacts> ok, cool
17:03:59 <pdxleif> That is, haskell threads need not have anything to do with OS threads, so I don't think javascripts lack of support for pthreads or whatever would be an issue.
17:04:03 <hpc> zacts: a combination of LYAH, real world haskell, and a place to ask questions
17:04:07 <hpc> zacts: and lots of googling
17:04:09 <monochrom> the best tutorial is the 3rd one you read.
17:04:10 <enthropy> pdxleif: http://hackage.haskell.org/package/lens/reports/ would have multiple elements in that list I think
17:04:11 <zacts> ok cool
17:04:34 <Arafangion> pdxleif: Which is to say, it depends on the implementation.
17:04:39 <hpc> (you already have a place to ask questions, so congradulations on learning 33% of all things there are to know about haskell :D)
17:04:41 <pdxleif> Yeah...
17:04:45 <Arafangion> Good. :)
17:05:08 <pdxleif> Normal GHC backend uses epoll or whatever equivalent thing is available on the host OS in its implementation of threads.
17:05:29 <pdxleif> Well, for the IO stuff, at least
17:05:51 <zacts> hpc: nice! :-) so what kind of math backround should I have to complete LYAH and real world haskell?
17:05:58 <hpc> zacts: you don't need any
17:06:26 <monochrom> background you need to learn haskell: http://www.vex.net/~trebla/haskell/prerequisite.xhtml
17:06:36 <zacts> oh cool. I'm going to take a calculus class at my college Calc I, soon. but I want to get started with haskell now, because it's interesting to me.
17:06:38 <c_wraith> zacts: it helps to know how to learn.
17:06:38 <hpc> if you have a math background, you might recognize a few words
17:07:13 <c_wraith> learning is a skill that is strangely not taught in most schools.
17:07:16 <zacts> c_wraith: I am familiar with everything on that page. :-)
17:07:25 <zacts> c_wraith: indeed
17:07:31 <pharaun> :\
17:07:35 <Arafangion> c_wraith: Worse... Schools penalize learning. :(
17:07:42 <benzrf> zacts: i know very little higher math
17:07:44 <pharaun> i always said - if you stop learning, you may as well be dead
17:07:47 <benzrf> but i know how to use monads
17:07:48 <benzrf> :-)
17:07:50 <pdxleif> enthropy: Interesting... so that information is available there, just not in the web ui?
17:08:28 <zacts> I'm thinking I'll put perl6 on the side of interesting languages to learn, and try Haskell -/=
17:08:46 <zacts> also, should I read SICP + (scheme) first, or can I start with Haskell first?
17:09:03 <benzrf> zacts: scheem and haskell are different langs
17:09:10 <benzrf> if you want to do scheme first then do scheme first
17:09:12 <zacts> benzrf: I know
17:09:16 <monochrom> school may impede learning because grading is an anti-thesis to teaching and learning
17:09:17 <hpc> they both introduce similar concepts in different languages
17:09:21 <Arafangion> zacts: I'm very new to hskell, however I seem to think of perl6, scheme, and haskell, as fundamentally, completely different languages.
17:09:26 <benzrf> Arafangion++
17:09:51 <zacts> I would rather do Haskell before learning (scheme) and SICP. due to the LYAH and other resources.
17:09:54 <hpc> slightly off topic, but seeing some of the stuff perl6 is doing just weirds me out now
17:10:13 <enthropy> pdxleif: looks like it
17:10:16 <zacts> and because haskell seems way cool to me, and I'm interested in getting started _now_.
17:10:28 <Arafangion> zacts: C++ and C# are also fundamentally differnet languages so you might want to put them on the list too!
17:11:31 <Arafangion> zacts: (Some might argue that perl6 and lisp has considerable overlap)
17:11:33 <pdxleif> That /reports/ format looks like the Show instance for something... maybe I could parse it back?
17:11:44 <zacts> My list of languages I want to learn are: Haskell, (scheme), I know perl5 already, C, lua, python, and maybe a dab of perl6
17:12:18 <hpc> Arafangion: they're similar in what functions they have in default scope, but lisp is much more about syntax rewriting than perl
17:12:30 <pdxleif> lambda calculus might be helpful in learning functional programming (functions as first-class values), and I'd think it'd apply to both haskell and scheme.
17:12:31 <hpc> and perl is much more about manipulating very basic low-level structures
17:12:34 <Arafangion> hpc: And the focus on writing a mini-language.
17:12:40 <pdxleif> if you wanna get "mathy" or whatever
17:13:00 <benzrf> zacts: why python and not ruby
17:13:01 <benzrf> :-O
17:13:06 <Arafangion> zacts: Don't confuse "calculus" with "lambda calculus" - completely different branches.
17:13:06 <hpc> it's interesting to write one like the other, and it's easier for those two than most, but still ultimately different
17:13:14 <monochrom> perl6 is, of course, interesting, as in, it shows you what humans can imagine. however, the whole perl line is a tradition of breaking many engineering principles.
17:13:17 <zacts> Arafangion: oh good to know :-)
17:13:34 <benzrf> i can tell u about the lambda calculus in like 3 lines
17:13:51 <zacts> benzrf: three rules right? one is abstraction
17:14:01 <glguy> pdxleif: If you just want to see it in a pretty format, Iavor's package is good for Haskell Show output http://hackage.haskell.org/package/pretty-show-1.6.7
17:14:09 <glguy> Comes with an executable for doing it from the command line, too
17:14:09 <zacts> one is combining elements, and one is primitives, or something like that?
17:14:18 <pdxleif> glguy: Awesome, thanks!
17:14:24 <benzrf> 1. a lambda calculus expression is either a variable like 'x', a functoin application like '(function arg)', or a function expression like '\arg.result'
17:14:46 <benzrf> 2. the only reducible expression is an application.
17:15:31 <benzrf> 3. to reduce an application of the form (\param.result arg), replace all instances of 'param' in result with 'arg'
17:15:45 <benzrf> although there's also variable name overlapping but ill ignore that
17:15:57 <zacts> is it true that haskell can be as fast as C in many situations?
17:16:10 <Arafangion> zacts: You're assuming that C is fast.
17:16:21 <zacts> (the only reason I care about this, would be if I were to right a kernel/OS)
17:16:28 <benzrf> Arafangion: C is pretty fuckin fast
17:16:29 <monochrom> @quote monochrom faster.than
17:16:29 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
17:16:30 <Algebr> I'm having a really hard time installing SDL-mixer via cabal, it keeps crapping out at checking whether the C compiler works... no
17:16:39 <benzrf> monochrom: huehuehuehuehue
17:16:45 <Algebr> and I tried: cabal install SDL-mixer --with-gcc=gcc-4.8
17:17:10 <zacts> anyway, I'll start with those resources for now. thanks!
17:17:40 <Arafangion> benzrf: Well, yes it is, but is increasonly difficult to map C to the underlying machine.
17:18:55 <Arafangion> benzrf: Especially when it comes to concurrency. :)
17:19:23 <benzrf> they say that machine opcodes have become an interpreted language
17:20:10 <benzrf> anyway i noticed something earlier
17:20:16 <monochrom> some of people's unhappiness comes from insisting on "am I at least half as rich as the next guy" and not settling with "am I rich enough". therefore, in programming, I also settle with "is my Haskell program fast enough" and not worry about "is my Haskell program at least half as fast as the next guy's C program"
17:20:34 <Arafangion> benzrf: True enough. :)
17:20:36 <benzrf> type constructors are the type-level equivalent of data constructors
17:20:47 <benzrf> type synonyms are the type-level equivalent of functions
17:20:48 <pdxleif> benzrf: and eta-conversion (\x.f x) = f
17:21:10 <Algebr> what is the purpose of the dist directory that cabal makes?
17:21:13 <benzrf> we allow recursion in functions
17:21:21 <benzrf> but not in type synonyms
17:21:25 <benzrf> this breaks the isomorphism
17:21:26 <benzrf> :(
17:21:32 <benzrf> oh wait
17:21:48 <monochrom> what isomorphism?
17:21:48 <benzrf> i guess making types isomorphic to values would make compilation undecidable
17:21:49 <benzrf> ;-;
17:22:10 <enthropy> type synonyms don't compute things
17:22:10 <monochrom> yes, there cannot be an isomorphism.
17:22:29 <enthropy> maybe you are thinking of classes or (type) families?
17:22:30 <benzrf> enthropy: nor do functions
17:22:34 <c_wraith> recursion in type synonyms would imply infinite types.  If you allow infinite types, you allow a lot of bugs.
17:22:41 <benzrf> yeah
17:22:41 <benzrf> ;-;
17:23:47 <pdxleif> Algebr: build artifacts?
17:24:00 <enthropy> benzrf: what does pattern matching do?
17:24:00 <pdxleif> output of the build, I guess
17:24:03 <Chousuke_> asking if "haskell can be as fast as C" is meaningless on its own :/
17:24:19 <benzrf> enthropy: oh i suppose types dont have pmtching
17:24:20 <Chousuke_> it's like asking if a rock can be as fast as a cheetah, which it can
17:24:33 <Chousuke_> if you drop both from high enough, for example :P
17:24:37 <enthropy> class instances and type families get to pattern match
17:25:08 <hpc> Chousuke_: or if you have a world-class pitcher throw the rock
17:25:13 <hpc> Chousuke_: doesn't mean you can throw it that fast ;)
17:25:30 <monochrom> the Humane Animal something-something Society may object to your dropping a cheetah from high above
17:25:36 * Arafangion is finding the history of haskell to be a _fascinating_ read.
17:25:47 <Algebr> does hackage let me see previous versions of a package ?
17:25:52 <monochrom> therefore, a rock will be faster than a cheetah!
17:25:56 <hpc> "can i write haskell that is as fast as C that i can write"
17:25:59 <Chousuke_> monochrom: that's okay, my cheetah is already stuffed
17:26:04 <LordBrain> on the package page, there are links for each version
17:26:13 <Chousuke_> it's not going to mind the drop
17:26:25 <monochrom> I write haskell faster than I write c.
17:26:30 <Algebr> LordBrain: Ah, I see that, thanks!
17:26:36 <hpc> cheetahs are cats, so they always land butter side down
17:26:37 <pdxleif> glguy: I can actually read those /reports/ now, woo!  Be cool if that was the default display of those endpoints.  Maybe people use stuff that parses those?
17:27:08 <glguy> pdxleif: Any work to make those things readable should probably go to incorporating them into the human interface
17:27:16 <glguy> It's probably good that that version is for machines as is
17:27:27 <glguy> but I agree that it could be good to fold that information into a more visible place
17:28:27 <benzrf> :t \f v -> f (v, ())
17:28:27 <lambdabot> ((t1, ()) -> t) -> t1 -> t
17:28:28 <LordBrain> what reports are you discussing here?
17:28:34 <benzrf> p:
17:29:07 <pdxleif> LordBrain: Hackage build reports, e.g. http://hackage.haskell.org/package/xmonad-utils-0.1.3.2.1/reports/
17:29:24 <benzrf> > let kindaLens f v = fmap fst (f (v, ())) in view kindaLens 5
17:29:25 <lambdabot>  (5,())
17:29:40 <Algebr> Is there a way for me to search for a function through all the version of a package?
17:29:47 <benzrf> > let kindaLens f v = fmap fst (f (v, ())) in over kindaLens sndd 5
17:29:48 <lambdabot>  Not in scope: ‘sndd’
17:29:48 <lambdabot>  Perhaps you meant ‘snd’ (imported from Data.Tuple)
17:29:52 <benzrf> > let kindaLens f v = fmap fst (f (v, ())) in over kindaLens snd 5
17:29:53 <lambdabot>  Couldn't match type ‘()’ with ‘(t, b0)’
17:29:53 <lambdabot>  Expected type: (s0, ()) -> (t, b0)
17:29:53 <lambdabot>    Actual type: (s0, ()) -> ()
17:29:54 <LordBrain> thx pdxleif
17:29:57 <benzrf> o_o
17:30:00 <pdxleif> I'm guessing that data's only for new hackage - I'm only seeing it build on GHC 7.6.3 in there.
17:30:03 <hpc> pdxleif: holy crap, those are finally back
17:30:05 <pdxleif> *built
17:30:31 <hpc> ... that's not a build log :(
17:30:33 <pdxleif> I had just been looking into https://github.com/hvr/multi-ghc-travis to know what GHC versions stuff builds on.
17:31:06 <benzrf> > let kindaLens f v = fmap fst (f (v, ())) in over kindaLens (second id) 5
17:31:08 <lambdabot>  5
17:31:09 <benzrf> interesting
17:31:39 <benzrf> > let kindaLens f v = fmap fst (f (v, ())) in over kindaLens (first (+1)) 5
17:31:40 <pdxleif> hpc: it lists which ghc version and libs were used in the build attempt(s), and success/failure for stuff
17:31:40 <lambdabot>  6
17:31:43 <benzrf> neat.
17:35:43 <pdxleif> I guess curl foo/reports | ppsh is an option.
17:39:51 <pdxleif> Can we put "#if __GLASGOW_HASKELL < 7.6" cpp stuff in .cabal files, or are there other ways of switching depending on GHC version in there?
17:40:00 <Algebr> Was catch ever a function in the Prelude?
17:40:06 <pdxleif> Yep
17:40:13 <pdxleif> Before 7.6
17:40:28 <Algebr> what did it do and what is it's equivalent now?
17:40:34 <Algebr> I'm trying to compile old code.
17:41:40 <Algebr> Or rather, can I put a preprocessor flag so that I can say, use xyz version of prelude?
17:42:13 <hpc> Algebr: it's an import now
17:42:18 <pdxleif> Algebr: I know this file won't compile on 7.4 or earlier if it's not hiding catch from Prelude - https://github.com/LeifW/xmonad-utils/blob/master/src/Hhp.hs
17:42:36 <pdxleif> It'll complain about catch being ambiguous.  So one of the other imports there is bringing in catch.
17:43:10 <leifw> So you're leifw on github
17:43:14 <pdxleif> This'll tell you of a few different "catch" functions - http://www.haskell.org/hoogle/?hoogle=catch
17:43:46 <pdxleif> leifw: Yeah - last name's "Warner". Sorry for squatting the "w". :/
17:43:56 <leifw> no
17:44:01 <leifw> *np
17:44:03 <pdxleif> What's your last name?
17:44:07 <leifw> Walsh
17:44:11 <leifw> hi :)
17:44:38 <davidthomas> 4
17:44:53 <davidthomas> err
17:44:55 <davidthomas> typo
17:45:10 <pdxleif> Heh.  Heya!  There was a Leif out at lambdaconf, and we didn't run into each other, but he told me someone he was talking to said, "Huh, you're the second Leif I've met today." :J
17:46:04 <Algebr> How can I find out the version of the Prelude that went along with a specific version of ghc?
17:46:27 <pdxleif> That's something I'd like to know myself.
17:47:13 <Algebr> for example, I know this code compiled with ghc 6.8.3, so what prelude came with that.
17:47:24 <pdxleif> leifw: Ah, the other Leif out at LambdaConf was also a LeifW - Leif Wickland. :/
17:48:43 <geekosaur> you need to figure out which version of base the ghc version came with, then http://hackage.haskell.org/package/base-$version/docs/Prelude.html
17:49:36 <glguy> The change log for each GHC release says which version of base it comes with
17:50:20 <geekosaur> so google search tells me base-3.0.2.0, therefore http://hackage.haskell.org/package/base-3.0.2.0/docs/Prelude.html
17:52:48 <Algebr> hackage doesn't even have that link its so old.
17:53:02 <Algebr> maybe I can just find out where it was moved to and just use it.
17:53:06 <leifw> :D
17:53:26 * geekosaur pokes, there should be another link
17:54:16 <geekosaur> oh right, even easier
17:54:17 <geekosaur> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/index.html
17:54:18 <Arafangion> Hmm. Reading the history of haskell...  It seems to suggest that http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/ is very very similar to modelling IO as a stream?
17:56:38 <Algebr> /sigh....I wonder if I can just sandbox this directory and just install ghc 6.8.3 in it
17:57:04 <akurilin> Quick question: let's say I install yesod-bin into my user's cabal repo. Why am I not seeing the binary on the path?
17:57:05 <geekosaur> you may find hsenv of interest
17:57:22 <geekosaur> akurilin, is $HOME/.cabal/bin in your $PATH?
17:57:24 <akurilin> Am I supposed to run something additionally to have it added to path?
17:57:30 <akurilin> hm let me check
17:57:31 <benzrf> hmmmmmmmm
17:57:36 <haukur> hey guys, I was thinking of learning haskell by writing a little web application. Any library/framework recommendations?
17:57:50 <geekosaur> (on OS X with the standard installer --- not macports/fink/homebrew --- that will be $HOME/Library/Haskell/bin)
17:57:53 <benzrf> haukur: not a good choice
17:57:54 <benzrf> haukur: imo
17:57:59 <benzrf> haukur: try implementing a lisp instead
17:58:04 <benzrf> :^)
17:58:13 <Arafangion> benzrf: How so? I'm doing similar.
17:58:23 <Arafangion> benzrf: But via ghcjs.
17:58:41 <haukur> hm, okay, care to elaborate?
17:58:46 <benzrf> 'Lens s t a b = (a -> f b) -> s -> f t' right?
17:58:58 <benzrf> *forall f. of cours
17:58:58 <benzrf> e
17:59:03 <Rarrikins> Disliking lenses?
17:59:04 <haukur> although implementing a lisp sounds fun too
17:59:07 <Arafangion> haukur: What do you mean by 'web application'?  Do you mean server-side, or client-side?
17:59:09 <akurilin> geekosaur: no there's not. Is that where cabal itself would be generally installed?
17:59:17 <haukur> Arafangion: server-side
17:59:32 <benzrf> haukur: the problem is that most web frameworks are based in concepts that you dont know until you know haskell
17:59:34 <geekosaur> akurilin, if you installed cabal via a haskell platform package or your OS package manager then no
17:59:35 <haukur> Arafangion: I don't know, now that I say it out loud it seems like I wouldn't learn much
17:59:56 <akurilin> geekosaur: I'm using a PPA which puts cabal under /opt/cabal, but as far as I can tell it still places cabal-built tools under ~/.cabal
17:59:57 <haukur> benzrf: I see how it's not a good idea, thanks
18:00:03 <akurilin> geekosaur: So I'm just going to have to add that to the path
18:00:05 <benzrf> haukur: haskell is not very practically useful until you know it fairly well
18:00:06 <geekosaur> but it is where executables installed via cabal will be installed (unless you use a particular option which has been demonstrated to be a very bad idea in practice)
18:00:39 <pdxleif> haukur: I think WAI is simple enough for writing a "hello world" webapp in: http://www.yesodweb.com/book/web-application-interface
18:00:43 <glguy> haukur: Try Snap. Follow some of the tutorials to get started and then figure out what you have to learn as you go
18:00:55 <benzrf> haukur: because most tasks in haskell that involve user interaction use higher-level concepts than beginner internal logic
18:01:18 <glguy> I think it's a good plan to have a project you want to build in mind and to learn enough as you go to implement that project
18:02:01 <haukur> how did you guys learn haskell?
18:02:07 <akurilin> geekosaur: ok thanks, this seems to work
18:02:13 <Rarrikins> I broke my brain on it for a while.
18:02:18 <haukur> reading a book, doing Project Euler problems, writing a lisp...
18:03:10 <Rarrikins> Try following Learn You a Haskell or the Haskell book thingy from O'Reilly.
18:03:17 <Arafangion> benzrf: My brain is exploading, I thought I understood the IO monad. Turns out I think I understood how IO could be conceptually thought of, but failed to understand monads.
18:04:35 <benzrf> Arafangion: =[
18:04:38 <benzrf> monads tho
18:04:48 <benzrf> haukur: i read some lyah
18:04:51 <benzrf> browsed some wiki
18:04:55 <benzrf> annoyed some channel regulars
18:05:17 <haukur> hehe
18:05:37 <croyd_> haukur: there are a lot of resources here: https://gist.github.com/bitemyapp/8739525
18:05:48 <pavonia> Algebr: Why do you need to use GHC 6.8?
18:05:53 <haukur> nice, thanks!
18:05:59 <Arafangion> benzrf: What I thought was a monad, was actually a type class.
18:06:09 <Rarrikins> Oh.
18:06:15 <Rarrikins> Big tip. Avoid monad tutorials.
18:06:38 <Rarrikins> They're evil. Maybe if we ignore them, they'll go away.
18:08:07 <jmcarthur> Arafangion: you don't really need to understand monads to understand IO, for what it's worth
18:08:20 <roconnor>  Algebr: would it be easier to install nix and then build your project?
18:08:25 <Arafangion> jmcarthur: Turns out that's right, except I also want to understand monads.
18:08:50 <int-e> Rarrikins: the followup problem is to resist the temptation of writing your own monad tutorial
18:08:57 <jmcarthur> Arafangion: if you ignore the fact that return and (>>=) are members of some type class called Monad then IO by itself isn't too complicated.
18:09:15 <Algebr> roconnor: What do you mean install nix? I'm about to just install ghc 6.8.3 prefixed to the directory where this older code lives.
18:09:46 <roconnor> Algebr: oh, you should continue what you are doing then.  I thought you were stuck.
18:09:47 <Arafangion> jmcarthur: Yes, IO itself has turned out to be relatively non-complex.  Now I'm reading about monads.
18:10:19 <geekosaur> what's to understand. it has three operations: return, bind, fail. (and the third shouldn't exist...) return lifts a value into a monad, bind chains monad computations together. anything else is frou-frou or is someone trying to come up with a picture of them, but they're too general for simple pictures
18:10:42 <geekosaur> (the frou-frou is category theory, which you emphatically do not need to know anything about to use them)
18:10:53 <jmcarthur> Arafangion: Honestly, understanding monads isn't all that important at this stage. I'd recommend instead just learning how to use a few more special cases of Monad, and then later you will suddenly realize what they have in common. I think expending effort right now to learn the more general thing is unlikely to accelerate that process.
18:11:12 <joelteon> in haskell terms, Monad is a typeclass with (>>=) and return
18:11:15 <joelteon> there you go
18:11:21 <Arafangion> geekosaur: It's the implications that are trickier. Reading the code and the examples are easy enough to understand. But I would never be able to think: "Oh, lets use a monad!" at the moment.
18:11:34 <jmcarthur> i rarely think "oh, i'll use a monad"
18:11:51 <jmcarthur> usually i just find that something i made happens to have monadic structure, but it doesn't significantly change anything
18:12:25 <geekosaur> ^ also they're general enough that you are not expected to get that level of understanding or recognition quickly
18:12:35 <Arafangion> jmcarthur: I've been programming for a number of years, I find it rather insightful learning about something in Haskell, and thinking "Oh, I did something similar to this...".
18:12:37 <jmcarthur> monads are typically overemphasized in tutorials
18:12:52 <Arafangion> That they do seem to be.
18:12:55 <joelteon> that's because there's specialized notation for them built into the language
18:12:57 <Cale> jmcarthur: yeah, and the word "monad" also
18:13:01 <geekosaur> brains have limits, one of those limits is there are some kinds of generalizations that they don't recognize easily
18:13:14 <roconnor> I agree with jmcarthur.  Learn how to use the Maybe Monad, Either Monad, Writer Monad, State Monad, and after you learn all of them you will see what is in common.
18:13:28 <Cale> Like, people say "the IO monad", when knowing that IO happens to be a monad doesn't really tell you all that much about what the IO type is.
18:13:49 <Cale> We probably should back off of saying "the X monad"
18:13:54 <Cale> at least a bit :)
18:13:55 <jmcarthur> Arafangion: do you know what a monoid is? in short, it's a set with an associative binary operation with an identity. monoids are everywhere. you've used tons of them. however, i doubt you ever were thinking about a problem and found that it could be solved just by "oh, i'll use a monoid!"
18:14:01 <pharaun> i have a question - on the topic of ST - from my understanding each run of - runST is an entirely separate set of state correct? no way to make them share, would the stToIO cause them to share via embedding the state in IO ?
18:14:15 <geekosaur> the "monad" part just means you can use some convenient shortcuts to put te code together, it says almost nothing about the nature of the code
18:14:44 <geekosaur> (well, what it says is so general as to be not of any particular help)
18:15:25 <jmcarthur> Cale: yeah. why not say things like "the integer monoid"? because it's just weird, emphasizes the wrong thing, and is in fact not even precise enough for most purposes
18:15:39 <roconnor> pharaun: The ST monad and the State Monad have very little, if anything, in common, even though they both have operations that are designed to manipulate state.
18:16:02 <Cale> It makes sense to say "the IO monad" when you're really emphasising the fact that you're getting use out of the monad instance
18:16:14 <pharaun> roconnor: well yes, i'm not referring to the State Monad, what i mean is the STRefs
18:16:21 <Cale> But otherwise, it's a bit strange :)
18:17:10 <jmcarthur> there it is again. "the State monad"
18:17:20 <jmcarthur> :)
18:17:20 <roconnor> pharaun: the ST monad is more-or-less the IO monad with a module system limiting which IO operations you have access to.
18:17:26 <c_wraith> I never say "the _ monad" because..  the fact that it's a monad is useful.
18:17:27 <jmcarthur> aaahhhh
18:17:33 <c_wraith> err, not useful
18:17:41 <Cale> Well, it's a *bit* useful
18:17:48 <jmcarthur> it saves code
18:17:57 <Arafangion> jmcarthur: Yes, although I always have to look up the term,
18:18:02 <jmcarthur> and allows a sort of higher level way of thinking... sort of
18:18:03 <frontend1oader> whats the latest "So you're having a hard time understanding monads..." article to pop up
18:18:05 <c_wraith> I might say "_ is a monad" if it means something.
18:18:06 <pharaun> roconnor: yeah, i was moving some stuff over from IORefs to STRefs so that i could run them independently by each invocation of runST
18:18:06 <joelteon> code using IO would be hard to write without monads
18:18:08 <Arafangion> jmcarthur: (Regarding monoids)
18:18:17 <pharaun> roconnor: or am i thinking about it in the wrong way ?
18:18:29 <jmcarthur> joelteon: ?
18:18:31 <c_wraith> joelteon: not true at all.
18:18:51 <joelteon> oh, ok
18:18:53 <geekosaur> joelteon, people use IO via its Functor instance instead of Monad all the time
18:18:57 <jmcarthur> joelteon: IO would still probably have things like return and (>>=), but they just wouldn't be called "monad things"
18:18:58 <geekosaur> every time they use fmap, in fact
18:19:03 <Cale> joelteon: Code using IO would be hard to write without using the IO type for sure, which *happens* to be a monad. We could however, fail to recognise the fact that IO is a monad, and still have a decent IO library.
18:19:22 <joelteon> sure, given the existing IO type, it would be hard to write IO-using code with it without a Monad instance
18:19:25 <ParahSailin> im still not sure of the historic meaning of ST
18:19:26 <Arafangion> jmcarthur: That's pretty much the case here: http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
18:19:34 <roconnor> pharaun: that sounds about right.  The set of operations exposed in the ST monad are limited to a set that runST can safely excute in a "pure" context (i.e. outside of IO).
18:19:39 <joelteon> unless you really only ever need to do one operation
18:19:42 <benzrf> IO Functor is quite useful
18:19:54 <Cale> The important thing about how IO works in Haskell is that there is a type of IO actions, not so much that this type constructor also happens to be a monad.
18:20:06 <benzrf> i much prefer writing 'fmap read getLine' to 'getLine >>= return .read'
18:20:10 <benzrf> *return . read
18:20:31 <joelteon> Cale: yeah, but bindIO isn't exported
18:20:39 <joelteon> I don't think so. is it?
18:20:44 <geekosaur> ParahSailin, "state thread" basically meaning it establishes a "thread of evaluation" (not related to the more common meaning of threads) which is delimited by a particular state whose distinctness is enforced by the type system
18:20:54 <Cale> joelteon: Well, yeah, we'd presumably have some other operations in the place of the Monad instance
18:21:05 <Cale> joelteon: The Monad instance just saves us from repeating a bit of code.
18:21:06 <pharaun> roconnor: cool, now one thing I'm still a bit unclear is this - "Converting ST to IO" and the "stToIO" function, i'm not sure i have the right word to express myself, but basically is that like "converting" STRefs to IORefs and bringing in all of the other IO stuff in" ?
18:21:09 <ParahSailin> ah ok
18:21:22 <Cale> joelteon: The stuff in Control.Monad, for the most part
18:21:36 <Cale> and well, sure, there are more advanced uses certainly
18:21:53 <Cale> Like, all the stuff surrounding monad transformers, and pipes/conduits/iteratees/etc.
18:22:10 <geekosaur> it does take a certain way of visualizing that to
18:22:13 <geekosaur> er
18:22:13 <Cale> and other libraries which have algorithms generalised over a choice of monad
18:22:13 <roconnor> pharaun: well, since all the ST operations are really IO operations in disguise, then the conversion is simply removing the disguise.  At least that is one way of looking at it.
18:22:14 <geekosaur> it does take a certain way of visualizing that to understand what it's talking about though
18:22:32 <Cale> but yeah, it's ultimately just saving a bunch of code duplication
18:22:45 <pharaun> roconnor: ahh i see alright thanks :)
18:22:54 <jmcarthur> the laws are nice to know, too, to be fair
18:22:55 <roconnor> pharaun: another way is to say that the ST operations form a subset of IO operations, so you are embedding the "Free" ST monad into the "Free" IO monad in the standard way.
18:23:10 <pharaun> ahh
18:23:10 <roconnor> pharaun: but that is only helpful if you are comfortable with Free monads.
18:23:19 <pharaun> i'm working on Free Monads :)
18:23:32 <pharaun> i've played with them a little but still trying to grasp them, i have a small interpreter going on here
18:24:30 <jmcarthur> free monads are like monads for people who already understand monads.
18:24:39 <roconnor> pharaun: Free monads look like trees.
18:25:06 <jmcarthur> in that they are yet another thing that sound all fancy and give the appearance of something useful, but actually in the end don't really change much
18:25:21 * roconnor is working on Free Applicative Fuctors.
18:25:41 <pharaun> heh
18:25:46 <jmcarthur> there's not much to free applicative func
18:25:47 <jmcarthur> oops
18:25:52 <jmcarthur> weechat did something funky there
18:26:06 <pharaun> blipped?
18:26:58 <Arafangion> jmcarthur: Part of my confusion, comes from people who poorly understand monads, apply them to other languages such as C#, and say they're using the monadic pattern.
18:27:06 <Arafangion> jmcarthur: But really, they're just returning functors.
18:28:09 <roconnor> jmcarthur: I think it is a pure lambda term and a list of (F X_i) where the X_i are arguments to the lambda term.
18:28:18 <jmcarthur> Arafangion: It's even weirder when they do it in dynamically typed languages, to me.
18:29:18 <jmcarthur> roconnor: exactly
18:29:23 <jmcarthur> roconnor:   data FreeA f a where
18:29:26 <jmcarthur> oops again
18:29:44 <Arafangion> jmcarthur: Depends on the scoping laws of that language, perhaps?
18:29:56 <Arafangion> jmcarthur: Python lambda's and python's scoping are weird.
18:30:17 <Arafangion> (But you could just avoid lambda)
18:30:35 <jmcarthur> roconnor:   data FreeA f a where Pure :: a -> FreeA f a; Ap :: FreeA f (a -> b) -> f a -> FreeA f b   -- or somesuch
18:30:50 <benzrf> :t over
18:30:51 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
18:30:59 <benzrf> =[
18:31:33 <roconnor> jmcarthur: It seems there ought to be another way of looking at it based on more of a monoidal functor perspective.
18:31:43 <jmcarthur> Arafangion: well, without types, it doesn't even make sense to talk about things like join. what's the difference between its input and its output?
18:31:46 <benzrf> i assume the profunctor in question is typically ->
18:31:51 <jmcarthur> Arafangion: when do you need to use it?
18:31:53 <jmcarthur> etc.
18:31:54 <roconnor> jmcarthur: existential types make me a little queezy, but I'm getting more used to them.
18:32:20 <jmcarthur> roconnor: ah, there possibly is another way in that style, but i haven't given it much thought
18:33:19 <benzrf> why doesnt lambdabot have :i
18:33:21 <benzrf> u_u
18:33:40 <Arafangion> jmcarthur: Point.
18:34:06 <glguy> > over imapped (Indexed (\i x -> i + x)) [1,1,1,5,5,5]
18:34:08 <lambdabot>  [1,2,3,8,9,10]
18:34:18 <pharaun> jmcarthur: time to punish your irc client ;p
18:34:19 <glguy> but normally you'd use iover in that context
18:34:21 <jmcarthur> roconnor:    data FreeA f a where Unit :: FreeA f '[]; Pair :: f a -> FreeA f b -> FreeA f (a ': b)    -- maybe?
18:34:31 <jmcarthur> pharaun: the second one was my fault
18:34:47 <jmcarthur> pharaun: the first one i got into some mode i didn't know how to escape and then ultimately it sent something half finished
18:34:53 <pharaun> ahh
18:35:02 <pharaun> weechat has modal states?
18:35:52 <jmcarthur> roconnor: of course that's not tuply. i was just trying to keep the associativity of it. real tuples could be used instead. i'm not sure how to get fmap for this...
18:35:59 <jmcarthur> i think that was a failure
18:36:08 <jmcarthur> pharaun: i got into search mode i think
18:36:16 <pharaun> ahh didn't know it had that neat
18:36:34 <pharaun> jmcarthur: anyway how come its weird in dynamically typed language?
18:37:06 <pharaun> (re monadic stuff) i like how Maybe and Either monad work and fall-through so would be nice to get that without tons of boiler plate in some of the other language that i'm stuck with
18:37:29 <jmcarthur> pharaun: under what conditions would one use join in such a language?
18:37:38 <zacts> ok so is the main advantage of lazy eval efficiency? or does it also provide abstractions for controlling complexity?
18:37:47 <benzrf> :t (.) `asAppliedTo` (undefined :: (a -> f b) -> s -> f t)
18:37:48 <lambdabot> ((a1 -> f b) -> s -> f t) -> (a -> a1 -> f b) -> a -> s -> f t
18:38:03 <benzrf> o-o
18:38:27 <benzrf> um.
18:38:50 <pharaun> jmcarthur: ah, meh i guess so
18:39:02 <jmcarthur> zacts: the main advantage is it allows you to write smaller, more composable pieces of an algorithm separately from each other, and you can avoid sacrificing some time/space when using them together
18:40:33 <jmcarthur> zacts: kind of a neat, gimmicky example is   take 5 . sort,  which clearly gives you the smallest 5 elements of a list, but does so in only  O(k log n)  time, not  O(n log n)  time as it would be in an eager language
18:40:55 <jmcarthur> zacts: where k = 5 in this case
18:41:04 <jmcarthur> ah woops
18:41:22 <jmcarthur> n log k, not k log n
18:41:35 <zacts> oh cool!
18:41:37 <jmcarthur> (it clearly has to visit every element at least once to know which ones are smallest)
18:41:46 <LordBrain> the neat thing is that it is nice and readable
18:41:50 <jmcarthur> right
18:41:58 <zacts> I think ch 3.5 of SICP deals a bit with lazy eval. I remember listening to the MIT lecture.
18:41:59 <roconnor> jmcarthur: that's a nice illustration.
18:42:05 <jmcarthur> it lets you write composable code without (much) sacrifice in performance
18:42:06 <zacts> just a sec bbiab. restroom. o_O
18:43:41 <jmcarthur> roconnor: yeah i like that one because it is a bit more non-obvious than stuff like  take 5 . map f  which would be much easier to just specialize by hand in an eager language, and it shows that you can actually do pretty complex things without much code
18:43:41 <LordBrain> with some care, it can be like you optimize for the view/simplicity of the code, without sacrificing performance.
18:43:58 <jmcarthur> brb
18:44:30 <LordBrain> in practice it can get a bit confusing sometimes tho
18:44:32 <zacts> jmcarthur: phew! ok so it's useful for both a nice abstraction and efficiency.
18:45:04 <LordBrain> can end up accidentally building up thunks in memory which is inefficient
18:45:32 <zacts> what kinds of programming problems is haskell not a good choice for?
18:45:37 <LordBrain> but i think most haskellers still think it makes sense as a default
18:45:50 <zacts> (I don't care about efficiency quite so much, unless it's 100% slower)
18:46:10 <zacts> and I'm almost done with ch1 of LYAH!
18:46:44 <jmcarthur> zacts: ones that require you to use java :P
18:46:59 <jmcarthur> zacts: that is, when you must use some java library or something
18:47:12 <zacts> jmcarthur: oh I see, so it's more of an "it's already implemented in x language and relies on libs for x lang"
18:47:12 <LordBrain> haskell is sometimes gets int eh way when you are trying to get really low level.. not that you cant do it, but its not working with you as much as say c would
18:47:34 <jmcarthur> zacts: yeah i'm just making a practical argument that applies to any language
18:47:42 <zacts> LordBrain: oh interesting, I have in my imagination an idea for implementing a microkernel or even monolithic kernel with haskell
18:47:53 <zacts> would C be a better choice for this?
18:48:04 <PhineasRex> zacts: A few people have written kernels in Haskell.
18:48:11 <zacts> oh cool
18:48:14 <benzrf> Watcher7:
18:48:16 <benzrf> *wat
18:48:18 <roconnor> I agree with LordBrain.  You can do low level stuff in Haskell, like writing an UM intepreter, but only by writing haskell as if it were C.
18:48:33 <LordBrain> zacts, it kind of depends, it might end up that the haskell compiler is trying to do too much for you, or it might be that what it is doing for you is not the part you are interested in anyway...
18:48:49 <zacts> roconnor: is that due to the von neuman architecture being sequential / imperative?
18:48:58 <startling> roconnor: I'm not sure "as if it were C" is true.
18:49:25 <roconnor> zacts: it is due to the fact that the UM spec wants to twiddle bits on 32-bit integers.
18:49:28 <roboguy_> doesn't doing low level stuff necessarily exclude writing it in a high-level style (idiomatic Haskell)?
18:49:32 <zacts> like I wonder about a minix3 clone using haskell instead of C
18:49:37 <startling> like, you have to manage your memory either way. That's not an inherently C-like notion.
18:50:37 <roconnor> Actually maybe with the new vector library stuff an idiomatic Haskell implementation of the UM machine would be more performant.
18:50:37 <LordBrain> well, the rts does memory management for you in a way, i do not know how that would work out really, but it seems concievable you could just use the rts as a sort of kernel
18:51:09 <zacts> or how about instead of the microkernel implemented in haskell, you did userspace OS servers in haskell?
18:51:21 <LordBrain> yeah that's plenty doable
18:51:26 <zacts> ok, cool
18:51:34 <roconnor> oh, I guess another problem is that every array lookup in idomatic haskell has a bounds check.
18:51:56 <zacts> so maybe I could start by keeping an initial microkernel in C, and then try implementing *one* or *two* servers in haskell to see how it works.
18:52:20 * hackagebot numeric-qq 0.1.0 - Quasi-quoters for numbers of different bases  http://hackage.haskell.org/package/numeric-qq-0.1.0 (NikitaVolkov)
18:53:35 <LordBrain> zacts, there is a sort of proof-of-concept os written in haskell, called HOUSE
18:54:30 <LordBrain> not sure if you want to check out someone elses work or just dive in without influences, but i thought i'd put it out there. http://programatica.cs.pdx.edu/House/
18:54:32 <roboguy_> the rts probably uses system calls, so you might need to make it a little more low level
18:54:44 <LordBrain> how did house do it?
18:54:57 <PhineasRex> I don't think ti uses GHC.
18:55:12 <PhineasRex> Or the regular version of it at least.
18:55:35 <roboguy_> yeah, you'd probably at least need a custom rts, maybe some other stuff too
18:55:51 <LordBrain> yeah that page says house uses a custom rts
18:56:09 <LordBrain> "a variant of the Haskell compiler GHC and its run-time system, adapted to produce code that can run in a standalone environment. This includes some device drivers implemented in Haskell, e.g. VGA text screen and PS2 keyboard support. "
18:56:42 <benzrf> yo
18:57:05 <benzrf> why does lens use Profunctor for over, instead of explicitly ->
18:58:24 <roconnor> benzrf: Profuctors admit abstraction patterns that don't fit cleanly into the -> framework
18:58:45 <benzrf> o=
18:58:47 <benzrf> such as ?
18:58:49 <roconnor> example
19:00:00 <roconnor> data Foo a b x y = Foo (x -> a) (b -> y)
19:00:05 <glguy> benzrf: Lens package uses (->) and Indexed i has its two common arrows
19:00:17 <roconnor> (Foo a b) is a profunctor (for each possible a and b).
19:01:04 <roconnor> and so Isos can be instantiated at Foo.
19:01:17 <benzrf> type Setting p s t a b = p a (Identity b) -> s -> Identity t
19:01:44 <Algebr> Who, or rather, what group of people are in charge of Hackage?
19:01:53 <roconnor> I think it is the Cabal.
19:01:56 <benzrf> :-D
19:02:18 <benzrf> type Setting p s t a b = p a (Identity b) -> s -> Identity t, thoughtpolice
19:02:20 <benzrf> *though
19:02:24 <Algebr> it is littered with abandonware, seriously needs a pruning.
19:02:42 <benzrf> in what scenario might you accept a profunctor besides 0>
19:02:44 <roboguy_> benzrf: a profunctor is just anything that you can map over it's input and it's output (sort of)
19:02:45 <benzrf> * ->
19:02:54 <benzrf> i know what a profunctor is =p
19:02:54 <startling> Algebr, why?
19:03:11 <LordBrain> how can you tell if something is abandonware?
19:03:12 <roconnor> benzrf: I think there should be a canonical example for prisms.
19:03:20 <Algebr> because so much stuff on it just doesn't run with a simple cabal install
19:03:35 <glguy> benzrf: Indexed lenses are the common case for that
19:03:35 <startling> LordBrain, the "Upload Date" section.
19:03:51 <Algebr> None of the items listed on the haskell wiki for games runs out of the box with cabal install and ghc 7.6
19:03:53 <startling> Algebr, patches are probably welcome, and if not there's a mechanism for transfering owndership
19:03:53 <glguy> newtype Indexed i a b = Indexed {runIndexed :: i -> a -> b}
19:04:09 <Algebr> startling: but I mean there's stuff from 08 that hasn't been updated and probably never will be.
19:04:15 <Algebr> students projects and such
19:04:16 <startling> as a whole, preserving softtware is better than not.
19:05:02 <Algebr> startling: I don't understand how its better to preserve code that 1) doesn't run, 2) uses deprecated items such as my goose chase with prelude's catch
19:05:33 <startling> Algebr, if someone needs it enough, they will update it.
19:05:44 <startling> Someone may need any given package in the future.
19:07:15 <LordBrain> the dependency checking is supposed to prevent you from installing a package that doesnt run with your compiler, theoretically
19:07:23 <zacts> I'm thinking something like this -> https://github.com/vhpanisa/pythonix <- but with haskell, and a serious system.
19:07:34 <ion> It would be nice if Hackage built everything for every version of GHC and emailed authors about breakage. If a package is broken for long enough, hide it from the standard lists/search results and move to an abandoned category.
19:07:52 <zacts> I would for sure use GHC for this kind of thing
19:12:14 <jmcarthur> i don't actually feel like haskell "gets in the way" of writing quite low level code, most of the time. i just think it's nice that you can write low level code *at all*.
19:12:29 <jmcarthur> and you can choose how low you really want to go pretty smoothly
19:12:39 <glguy> Even when you're writing "low level code" there are high-level patterns that you benefit from getting ot use
19:15:55 <LordBrain> zacts, might want to look some at the wiki here, http://www.haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
19:18:10 <LordBrain> i think it would be kind of cool to have a true usable unix like OS with haskell almost top to bottom. With type safety in system calls and all that.
19:18:55 <LordBrain> well, i guess the more type safety and haskellish style features, the less unix like actually, but that's not necessarily a bad thing...
19:20:11 <pharaun> i've wanted a os like that for a while
19:20:27 <LordBrain> yeah
19:20:28 <crazydave> I'm no expert but I'm pretty sure POSIX doesn't demand that the OS kernel crash due to type errors :)
19:20:35 <pharaun> probably can use seL4 microkernel for the belly/kernel then go from there
19:20:44 <LordBrain> house is the closest i know of, but nobody even considers really using that as their main os
19:20:47 <pharaun> but can probably do a kernel but main thing would be the RTS
19:21:01 <benzrf> > let sequenceA = foldr (liftA2 (:)) (pure []) in sequenceA ["foo", "bar", "baz"]
19:21:02 <lambdabot>  ["fbb","fba","fbz","fab","faa","faz","frb","fra","frz","obb","oba","obz","oa...
19:21:05 <benzrf> sweet
19:21:11 <zacts> LordBrain: oh nice thanks.
19:21:32 <LordBrain> actually, house would be usable, if it jsut had a lot of drivers
19:22:02 <LordBrain> i mean, they run it in a vm, and it has x on it even
19:22:18 <LordBrain> i think
19:22:24 <LordBrain> i haven't tried it myself
19:23:08 <zacts> LordBrain: well, If I can get something working on a Beagle Bone Black, that would be my goal.
19:23:21 <LordBrain> heh, i don't know what that is
19:23:39 <LordBrain> it's not actually part of a dog's skeleton is it?
19:24:36 <benzrf> hey
19:24:47 <benzrf> over doesnt even use the first part of dimap does it
19:24:58 <benzrf> why does it use Profunctor and not just Functor
19:25:14 <benzrf> it only needs to fmap Identity, not dimap id Identity
19:26:02 <benzrf> y/n
19:26:05 <LordBrain> try #haskell-lens maybe
19:26:33 <benzrf> :I
19:26:56 <glguy> It's actually a very active channel
19:27:08 <glguy> You'd be well served to chat there if you're actually interested in lens
19:27:44 <benzrf> :I
19:27:46 <benzrf> ok
19:29:13 <startling> I assume the ":I" is because benzrf got no repsonse in #-lens
19:29:23 <benzrf> no i went there
19:29:26 <benzrf> i just spam :I
19:30:57 <startling> :I
19:31:12 <LordBrain> is that the emoticon for embarrassed?
19:34:54 <Bonesdog> Does anyone here know alot about Java?
19:35:12 <LordBrain> lol
19:35:16 <Rarrikins> Yes
19:35:17 <roboguy_> Bonesdog: maybe, but why?
19:36:08 <LordBrain> better have some tie to haskell coming...
19:38:10 <Bonesdog> Robo, if make an array of booleans[][] that stores lists of true and false in rows of 8 to represent a binary number
19:38:11 <LordBrain> much more likely to find java help here than haskell help there i bet
19:38:22 <Bonesdog> that is converted into a char and stored into an array of char[]
19:38:36 <roconnor> #haskell-blah is for Java help.
19:38:53 <Bonesdog> sorry roconner
19:39:27 <roconnor> no worries
19:39:59 <zacts> LordBrain: the Beagle Bone Black is like the raspberry pi
19:40:14 <zacts> if you know what that is, but the doc for the hw is better, and there are fewer blobs.
19:40:16 <LordBrain> ah
19:40:28 <LordBrain> i've heard of it
19:40:34 <zacts> so you aren't programming in such a black boxed environment, and can actually learn something
19:40:41 <zacts> about low level
19:41:17 <zacts> minix3 has actually been ported to it, so I don't think writing drivers for that in haskell would be difficult
19:41:39 <zacts> since there is so much documentation. so my OS would target small embedded devices such as that.
19:42:04 <zacts> it doesn't need to be the next Linux desktop. just a simple server / embedded reliable OS
19:42:51 <LordBrain> ok
19:43:00 <zacts> so yeah, maybe once I learn haskell, I'll try to write a single minix server implementing part of the OS.
19:43:07 <zacts> then do another server, and another.. :-)
19:43:15 <zacts> I'll go ahead and keep the C microkernel
19:43:34 <zacts> just for a fun project to learn from. If it doesn't work out, @ least I've learned a ton.
19:44:27 <zacts> LordBrain: oh cool! I guess it is a GSoC project idea - http://www.minix3.org/soc-2013/
19:44:42 <zacts> s/is/was/
19:45:15 <zacts> oh how does haskell do the equivalent of regular expressions? can I make a functional domain specific language like that in haskell?
19:45:34 <zacts> and still maintain the pure functional / lazy aspect..
19:45:40 <michaelt> roconnor: you don't have lens-family up on one of these darcs-hub sort of places, I guess?
19:45:46 <startling> zacts, you can use strings
19:46:00 <roconnor> michaelt: I probably should.
19:46:06 <startling> you might want to use e.g. quasiquotation if you want type-safety
19:46:12 <startling> for e.g. string groups
19:46:17 <zacts> startling: ok
19:46:33 <michaelt> well, i could figure out how to send patches from darcs again, not that I have one
19:46:52 <zacts> LordBrain: can haskell be used as a configuration language, oh I guess so with things like xmonad configs. I'm thinking a firewall config.
19:46:57 <zacts> for a haskell pf clone
19:47:00 <zacts> userspace
19:47:08 <LordBrain> sure
19:47:15 <LordBrain> yes to all
19:47:37 <zacts> ok, nice. sorry for my chatter, I'm just getting totally excited about haskell now! :D
19:47:51 <LordBrain> i know, i was psyched when i first discovered it
19:47:59 <enthropy> zacts: have you taken a look at http://hackage.haskell.org/package/regex-applicative ?
19:48:18 <zacts> enthropy: oh nice.
19:48:25 <zacts> how about things like quantum superpositions?
19:48:36 <zacts> let me explain with a link
19:49:27 <zacts> and I'm totally ditching learning about perl6 for the time being, due to haskell being so awesome.
19:50:00 <michaelt> roconnor: I was thinking it would be nice to have a principal module like Control.Lens, exporting most of the stuff and maybe the State.Strict zoom
19:50:03 <zacts> https://metacpan.org/pod/Quantum::Superpositions <- this is want I'm wondering about
19:50:42 <roboguy_> zacts: non-deterministic computations are represented as lists if that's what you mean
19:50:57 <zacts> I guess it's called a junction?
19:51:21 <zacts> http://ralfbarkow.wordpress.com/2007/07/22/junctions-perl-6-haskell/
19:51:21 <roboguy_> > (*) <$> [10,100,1000] <*> [2,3,4]
19:51:23 <lambdabot>  [20,30,40,200,300,400,2000,3000,4000]
19:51:55 <zacts> if haskell can grok regex and do quantum::superpositions like things, I'm not even interested in perl6 anymore.
19:52:54 <zacts> plus haskell is really beatiful to read syntactically and visually asthetically, imho.
19:53:50 <roboguy_> zacts: well, the quantum superposition thing would probably be translated as different things depending on what specifically you're doing with it
19:53:51 <zacts> LordBrain: yeah, I wouldn't be surprised if it is a new psychological mania, being psyched about haskell
19:53:56 <LordBrain> hmmm the junction thing doesnt quite translate to haskell
19:53:58 <roboguy_> zacts: Applicative would cover some of it
19:54:04 <roboguy_> (Applicative for lists)
19:54:08 <zacts> roboguy_: ok.
19:54:44 <zacts> are haskell lists similar to lists in lisp/(scheme)? or do they behave differently?
19:54:45 <LordBrain> basically lists, yes
19:54:51 <LordBrain> no
19:54:54 <roboguy_> zacts: any and all in haskell would be used for checking a predicate over a list and elem would be used for some things
19:54:55 <LordBrain> i was answering about junctions
19:55:04 <roboguy_> zacts: yeah, they are both singly linked lists
19:55:07 <roboguy_> @src []
19:55:07 <lambdabot> data [] a = [] | a : [a]
19:55:17 <zacts> car cdr and cons, I hope those have new names.
19:55:21 <LordBrain> haskell lists are not the same thing as pairs of pairs etc as they are in scheme
19:55:31 <roboguy_> zacts: they do, but people really avoid them whenever possible
19:55:36 <zacts> the car cdr terminology is archaic.
19:55:43 <roboguy_> because pattern matching is a lot better
19:56:21 <zacts> hey, I don't want to flood this channel, um.. maybe interested people could join my channel #zacts ? (unless I'm not bothering you guys with my questions)
19:56:27 <LordBrain> well, the problem is our prelude is sort of archaic too... and we use head and tail for car and cdr, but they are deprecated in practice, if not officially, becuase they are partial functions that can throw exceptions
19:57:06 <LordBrain> and anyway generally speaking, you wouldn't explicitly call head and tail, because you'd much more likely pattern match with a colon.
19:57:39 <zacts> LordBrain: so lispy lists and car / cdr are not generally considered idiomatic haskell
19:57:41 <roboguy_> zacts: not much else is going on here at the moment so I think it's ok
19:57:49 <michaelt> roconnor: oh, i made a lens-family/lens-family-th replica of the pong.hs demo from lens, not that anyone doubted it was possible. I was interested in seeing how far one could just drop in lens-family or lens. https://github.com/michaelt/lens-simple/blob/master/examples/Pong.hs
19:57:49 <roboguy_> that's what this channel is for anyway
19:58:00 <zacts> ok, if other people have questions I'll back off a bit.
19:58:50 <roconnor> michaelt: what are the highlights of the changes needed?
20:00:02 <LordBrain> zacts, sometimes its nice to have some easy questions for a change.
20:00:11 <zacts> LordBrain: ok
20:00:12 <LordBrain> lol
20:00:46 <michaelt> (<~)  was the only thing missing, roconnor; oh and the TH invocation was different but I mentioned it to Dan B., who changed it. Otherwise its the same.
20:01:14 <zacts> so I guess can I contribute to the haskell CPAN equivalent, is it called cabal? Can I create a user identity and maintain my own modules?
20:01:34 <matematikaadit> zacts, sure :D
20:01:45 <zacts> I would like to try transferring some of the functionality of my favorite CPAN modules over to haskell. that could be my contribution to the community.
20:01:46 <matematikaadit> zacts, it's hackage
20:01:50 <zacts> oh that was it
20:02:23 <roconnor> @type (<~)
20:02:24 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
20:02:42 <zacts> as long as haskell can idiomatically be used for web programming and databases / CMS.
20:03:08 <LordBrain> zacts, no problems there
20:03:16 <michaelt> roconnor:ballSpeed <~ nextSpeed = nextSpeed >>= \s -> ballSpeed .= s
20:03:38 <michaelt> Pardon choice of variables
20:04:17 <zacts> LordBrain: ok, I've seen things like haskell -> C compilers, similar to (scheme)'s chicken->C Compiler. I have an idea of making a haskell -> pf firewall syntax compiler.
20:04:40 <zacts> but that it formally verifies the syntax to be correct in a sense, similar to what the haskell -> C compiler does.
20:04:56 <LordBrain> pf is the freebsd version of iptables right?
20:05:15 <zacts> LordBrain: OpenBSD mainly, but FreeBSD supports an older syntax of OpenBSD's pf. yes.
20:05:32 <zacts> LordBrain: maybe even nftables one day, but pf is much simpler.
20:05:37 <roconnor> michaelt: interesting.
20:05:56 <LordBrain> i wouldn't mind having an iptables version
20:05:59 <LordBrain> heh
20:06:13 <zacts> that way you could hypothetically create more reliable firewall / packet filter configs that do exactly what you want.
20:06:31 <Rarrikins> What we need is an automated way to turn an interpreter into a compiler.
20:07:15 <michaelt> roconnor: I use it quite a lot, mostly because the pipes things are defining quasi lenses that basically are restricted to over, zoom and view
20:07:27 <zacts> LordBrain: I guess the biggest problem would be the difficulty of turning a functional program config into a non-function sequential language.
20:07:49 <zacts> how do functional programs verify sequential / non-functional languages such as C?
20:07:53 <roconnor> michaelt: I see no reason I shouldn't add it.
20:08:47 <LordBrain> zacts, you must pass the initation ritual of the secret haskell society and learn of monads
20:08:57 <michaelt> roconnor: yeah it's obviously not important.
20:09:20 <LordBrain> not that it is the only way to do things, but its the idiomatic way
20:09:57 <zacts> LordBrain: ok, my initial excitment of haskell may be getting me ahead of myself with thinking of all of the possibilities. /me will be back laters once I complete LYAH.
20:10:12 <zacts> but thanks, I am totally excited about haskell.. and can't wait to learn it.
20:11:06 <michaelt> roconnor: note the unpleasant imports on this randomly chosen file https://github.com/jfischoff/joust/blob/51207b5d5e78c4fc088441d38c8ccb5f6347506d/src/Joust/Joust/Simulator.hs
20:12:02 <roboguy_> zacts: maybe with some dependent types
20:12:50 <roconnor> michaelt: unpleasent in that there are lots of them?
20:13:24 <michaelt> roconnor: yes, the functions in question are Prelude like in character, leaving aside the TH nonsense
20:13:40 <michaelt> roconnor: I'm not complaining
20:16:29 <michaelt> oh no I killed roconnor
20:17:10 <dmwit> I always misspell stripPrefix as splitPrefix. >:-|
20:55:57 <chirpsalot> Hmmmm... Say you're trying to evaluate expressions from some kind of AST in Haskell... You would want to run some kind of recursive eval functions on the nodes, but what would the type of "eval" be if the expressions could be of many different distinct types?
20:56:22 <chirpsalot> Would you have to make a data structure kind of similar to "Either" that contains all of the different types, or is there a better way?
20:57:49 <chirpsalot> I suppose you could just pass things around as strings as well, but that's obviously unpleasant.
20:59:19 <pavonia> chirpsalot: You could make eval a type class function, so you can deal with different types
21:02:11 <chirpsalot> pavonia: ah, right. I was just remembering that such things existed. I knew there was a good Haskelly way to deal with it :).
21:03:13 <pavonia> However, you usually have a big Expr type that covers all possible expressions types
21:03:24 <sipling> how do you read the list comprehension `[ x | x <- xs, x > 10 ]`, specifically what do you call the operator `<-` when inside the comprehension
21:03:26 <chirpsalot> pavonia: well damn. I actually encountered this problem in Java (groan), and was wondering how Haskell would deal with it. Seems like I am in for some pain.
21:03:45 <chirpsalot> sipling: for x in the list xs?
21:04:06 <sipling> I can't understand what SPJ calls it when he reads in 'Haskell is Useless' video
21:04:24 <pavonia> Gladly, we have a wiki page for everything: http://www.haskell.org/haskellwiki/Pronunciation
21:04:41 <sipling> thanks chirpsalot and pavonia
21:05:13 <chirpsalot> pavonia: oh that's cool! :)
21:07:51 <roboguy_> sipling: I think he says "exes"
21:08:41 <sipling> roboguy_: thats `xs`
21:09:02 <sipling> there's somthing in between (for others http://www.youtube.com/watch?v=iSmkqocn0oQ&t=290)
21:09:04 <roboguy_> oh oops, I thought that's what you were talking about
21:09:16 <sipling> i am talking about epsilon
21:09:34 <sipling> i just checked it ... i thought that was haskell code... but it seems its mathematics he was reading
21:12:31 <roboguy_> sipling: he's saying "is drawn from"
21:13:17 <roboguy_> also, I don't think that's an epsilon
21:13:31 <sipling> roboguy_: now that you have pointed out, it appears he says that. thanks :)
21:13:49 <roconnor> O
21:13:53 <roconnor> O
21:13:57 <sipling> yeah, it should be "belongs to"
21:14:24 <roconnor> stupid keyboard focus
21:15:11 <benzrf> mobit needs to be a real term
21:26:04 <libmn> What always depresses me is when essential components in an otherwise free and permissively licensed language stack are copyleft...
21:26:21 <libmn> More than anything else, the licenses of runghc, darcs, and leksah have ruined Haskell for me...  :(
21:26:29 <pharaun> ?
21:27:23 <carter> libmn: there is literally NO DVCS that isnt GPL afaik
21:27:25 <Polarina> libmn, how have copyleft licenses ruined your life? These are simple programs, you can use them in your business doing whatever proprietary thing you can think of (unless you send someone a copy of that specific software in question)
21:27:37 <libmn> Fossil is copyfree.
21:27:40 <carter> :))))
21:27:47 <carter> how many people are using fossil ?
21:27:49 <pharaun> hahaha
21:27:55 <carter> i've tried using fossil
21:27:57 <pharaun> i think 1 or 2 projects but yeah no
21:27:58 <libmn> I refuse to use copyleft software for moral reasons.
21:28:11 <pharaun> well then don't use linux kernel
21:28:20 <libmn> FreeBSD.
21:28:23 <carter> ahhh
21:28:40 <carter> libmn: you could use some of the bsd haskel GIT interop tools to to a bsdgit
21:29:07 * Polarina has no clue why anyone would refuse to use copyleft software, merely due to moral reasons.
21:29:11 <tnks> how is copyleft possibly immoral?
21:29:16 <tnks> yeah.
21:29:16 <libmn> http://copyfree.org
21:31:21 <carter> i at the very least appreciate there existign counter copyleft diehards along with the gpl diehards
21:31:54 <crazydave> I wish we didn't need copyleft licenses but I feel like copyfree promotes being exploited
21:32:05 <tnks> it just seems odd to me that people would boycott software they aren't even modifying.
21:32:08 <carter> libmn: http://hackage.haskell.org/package/hit is a pure haskel BSD3 bit of code for manipulating git storage meta data
21:32:19 <carter> you could write a hgit thats bsd3
21:32:20 <carter> :)
21:32:39 <Polarina> libmn, I can understand you wishing to avoid copyleft software where alternatives exist, but refusing them baffles me. Even the GPL restricts you in no way whatsoever (the license even says that it doesn't apply at all) when all you do is use or modify the software.
21:32:49 <libmn> carter: That's nice.
21:32:51 <tnks> but at least FreeBSD is a good alternative anway.
21:33:54 <carter> libmn: of course youd have to put in quite a bit of time to make that polished
21:33:58 <carter> BUT, that'd be really cool
21:34:04 <pharaun> agreed ^
21:34:16 <carter> AND it'd mean the *BSD projects could stop using CVS
21:34:30 <carter> ok
21:34:43 <pharaun> carter: they're still on cvs?
21:34:46 <pharaun> ouch
21:34:59 <carter> wont use GPL dvcs tools
21:35:17 <pharaun> yeah i get that but wow didn't know there wasn't anything newer that wasn't gpl
21:35:20 <carter> so clearly libmn  and his future minions need to do someting like hgit using hit or some deriv thereof
21:35:36 <crazydave> pharaun: " carter: libmn: there is literally NO DVCS that isnt GPL afaik".  That would slow *BSD from moving off CVS.
21:35:51 <carter> yup
21:35:56 <carter> hence my point
21:35:58 <carter> :)
21:36:08 <crazydave> (wow at the number of people I tagged in that sentence ... oops)
21:36:16 <carter> there :)
21:37:10 <Polarina> crazydave, anti-spambots would love you. :)
21:39:07 <Arafangion> I could've sworn that one prominant *BSD used perforce.
21:39:28 <carter> ...... point being, i think libmn has a huge opportunity here
21:39:29 <Arafangion> (Although with a CVS bridge)
21:39:34 <carter> maybe
21:39:36 <carter> i hope
21:39:48 <carter> i want *someone* to make a bsd but git compatible git
21:39:59 <libmn> Trying to find something better than Ruby / Node.JS / Lua / Go for my "pure copyfree" dev stack (FreeBSD, Nginx, PostgreSQL, etc).  Taking presence of non-copyfree stack components into consideration.
21:40:23 <carter> well
21:40:45 <carter> wait, libmn  where is runhaskell gpl?
21:41:02 <carter> also no one uses lekshah afaik
21:41:10 <libmn> Like many things about Haskell, but just wanted to mention where it fails from my perspective.
21:41:25 <carter> libmn: now dont veer into trolling
21:41:32 <carter> i use normal text editors
21:41:36 <Polarina> I even tried leksah a while ago. Couldn't even get Hello World to compile.
21:41:41 <carter> i don't like ides
21:41:49 <carter> the IDEs of March
21:41:50 <carter> kill me
21:42:55 <hamishmack> carter: I use leksah :-)
21:42:56 <carter> also ... i never use runhaskell, just runghc
21:43:05 <carter> well, hamishmack , we know you're special :)
21:43:15 <pharaun> carter: agreed it'll be pretty nifty if he pulled together a bsd version of git or some such
21:43:18 <crazydave> libnm: I don't think you can blame the Haskell for the license that people choose to distribute their Haskell code with
21:43:21 <libmn> Did I misunderstand https://github.com/bacchanalia/runghc/blob/master/COPYING ?
21:43:30 <carter> ummmm
21:43:33 <carter> thats not GHC runghc
21:43:39 <libmn> oh
21:43:43 <crazydave> libnm: the core compiler and libraries are all copyfree
21:43:47 <carter> yup
21:43:57 <carter> github.com/ghc/ghc has the runghc you want
21:44:02 <carter> and thats just an alias for GHC
21:44:05 <carter> and ghc is BSD
21:44:19 <libmn> Oh, my bad.
21:44:21 <crazydave> http://www.haskell.org/ghc/license
21:44:51 <carter> you can even build GHC with Integer-Simple (aka integer-SLOWWWWW)
21:44:56 <carter> if you dont want to use GMP
21:45:05 <carter> theres some plans / ideas to have a BSD integer-fast
21:45:14 <pharaun> i thought there was efforts to move off gmp? was integer-slow part of that?
21:45:21 <carter> nah
21:45:28 <carter> pharaun: you mean integer-simple?
21:45:34 <pharaun> yes :) sorry
21:45:45 <carter> theres actually a bunchof perf tuning that might replace integer-simple by the time 7.10 rolls around
21:45:50 <pharaun> nifty
21:45:54 <carter> so that the integer-simple stuff is les sslow
21:46:05 <startling> carter: nice!
21:46:15 <carter> but theres such a HUGE amoutn of manpower into tuning gmp, that it'd be hard to compete no matter how clever you ar
21:46:20 <startling> integer-slow, heh
21:46:24 <pharaun> gmp always has been a bit of a pain for me deployment-wise
21:46:36 <pharaun> so would be nice to have an alt even if its not always the fastest in the world
21:46:45 <carter> pharaun: you can totally build GHC with integer-simple
21:46:48 <startling> it's always offended my aesthetics
21:46:55 <carter> ghc-ios uses integer-simple
21:47:07 <carter> heck, ANY X compiling ghc does afaik
21:48:04 <pharaun> carter: i know :) but yeah
21:48:18 <carter> 7.8 should be easy to build with integer-simple
21:48:25 <carter> if not, please holler
21:48:32 <pharaun> sweet
21:48:42 <pharaun> i should get a 7.8 build going soon then, still on 7.6
21:48:48 <carter> OMG HOW DO YOU LIVE
21:48:56 <pharaun> haha
21:49:01 <pharaun> old machines?
21:49:09 <crazydave> am I right in saying that GMP is a C library and integer-simple is written in Haskell?
21:49:09 <carter> heck, i'm already biting at the chomp for 7.10, because i've around found some frustrating bugs in 7.8 for me
21:49:13 <carter> yup
21:49:25 <pharaun> carter: impressive :)
21:49:28 <carter> https://github.com/erikd/haskell-big-integer-experiment is faster
21:49:29 <Polarina> 7.8 has bugs?
21:49:48 <glguy> Yes, all GHCs have bugs
21:49:50 <pharaun> i'm not exactly on the bleeding edge, i'm still ramping up with haskell -_- 2 years so far
21:50:18 <carter> pharaun: i've only gotten good at haskell in the past 2 years
21:50:25 <startling> crazydave: yes
21:51:09 <pharaun> carter: so yeah, gonna be a bit more but i'll probably start following the bleeding edge sooner or later, i tend to do so
21:51:17 <carter> libmn: point being, all the core stuff is BSD, ORRRR we're figuring out how to migrate it over time as we have the resources
21:51:34 <carter> pharaun: travis CI has made the cutting edge bleed less
21:51:38 <carter> probably because its red hot :)
21:52:12 <pharaun> ha!
21:52:27 <startling> the cauterizing edge?
21:52:32 <carter> travis CI, it cuaterizes the bleeding edge
21:52:36 <carter> yes
21:52:45 <pharaun> the smell gotta to be interesting
21:52:47 <carter> carteriziing edge
21:52:50 <carter> bacon
21:53:01 * startling carterizes cauter
21:53:07 <carter> smells like the sweet sweet bacon of innovation
21:53:16 <carter> or segfaults
21:54:36 <carter> libmn: point being, you raised some valid concerns
21:55:03 <carter> and while many people here have a more moderate stance than you, we generally agree that the core tools for haskell are awesomer if BSD/MIT licensed
21:55:23 <carter> and welcome help pushign that along
21:55:45 <carter> k?
21:56:03 <libmn> I am very impressed by this.  :)
21:56:36 <carter> so when are you gonna start you haskell git project
21:56:50 <carter> if you do it right, you'l get lots of people helping / arguing with you
21:57:27 <carter> though it'll be easier to get people to contrib if you host on github .... if you can stomach that till the hgit is stable?
21:57:27 <crazydave> carter: I imagine that it is not possible to be able to be compatible with git without breaking the GPL
21:57:33 <carter> false
21:57:44 <pavonia> What is the standard way of rendering a custom AST to source code, Text.PrettyPrint?
21:57:44 <carter> all it needs to do is have the same CLI interface
21:57:48 <libmn> That's a very interesting project idea.  I've brought it up in ##copyfree.  The odds of *me* doing it and *soon* are rather low...
21:57:48 <carter> and talk to the same format
21:58:18 <carter> crazydave: writing code that satisfies the same spec as a GPL program is totally ok
21:58:28 <libmn> But eventually someone will write a copyfree git, and haskell offers a good starting point.
21:58:34 <crazydave> same CLI is easy, but same format is harder .... because if you have to read the code to work out the format then you are walking a fine line
21:58:46 <carter> crazydave: no, vicent alreayd did that part
21:58:49 <carter> @hackage hit
21:58:49 <lambdabot> http://hackage.haskell.org/package/hit
21:59:06 <carter> crazydave: git has a specced format
21:59:24 <carter> crazydave: also GPL has less cooties that then FSF would have you believe
21:59:59 <carter> partly because it claims magic powers about what is defined to be a derivative work more agressively than copyright law dictates / case law determines
22:00:21 <carter> but more important: talk with a laywer :)
22:00:52 <Polarina> carter, it's still a solid advice to the people without a lawyer sitting next to them.
22:01:01 <crazydave> Well it also hasn't been fully tested by a court.  So it really is legal opinion as to how many cooties GPL has and not legal precedent
22:01:07 <carter> well
22:01:21 <crazydave> carter: are you sure cooties is the correct legal term? I'm just copying you
22:01:38 <carter> its a 1st graders / 6yr old kid term
22:01:50 <carter> gplv2 and older had no laywers writing it
22:01:54 <carter> gplv3 has
22:02:00 <carter> i think
22:02:03 <carter> idk
22:02:22 <Clint> v2 and v3 were lawyered
22:02:23 <carter> crazydave: i could have a license that says "by reading anything carter says online, All your code is now derivative work of his ideas"
22:02:42 <carter> but just because i say that, dosn't mean it has teeth in court
22:02:49 <enthropy> well you're quite an inspiration :p
22:02:58 <carter> and caselaw is a complex, fluid, interpretive creature
22:02:59 <carter> enthropy: :)
22:03:07 <carter> honestly, enthropy  you do cooler stuff
22:03:10 <carter> ok
22:03:18 <carter> or equivalently cool, but more productively :)
22:03:58 <carter> i guess what i'm saying is contracts are vague, the only way to resolve the vaguness is to take them to court when they have weird stuff
22:08:53 <carter> libmn: pleaseeeeee
22:08:57 <carter> we need a hero to do that project
22:09:52 <libmn> I am only an egg.
22:10:30 <pharaun> did the chicken come first or the egg?
22:10:40 <Polarina> libmn, but with a basket, you can do more!
22:11:01 <Arafangion> carter: Pfft, taking those contracts to court. The real interesting case is determining whether or not API's themselves can be copyrightable.
22:11:13 <carter> Arafangion: hahaha
22:11:19 <pharaun> hahaha
22:11:20 <carter> well, happily haskell apis != c apis
22:11:21 <Arafangion> carter: Sadly it's not a joke. :(
22:11:23 <carter> i kno
22:11:25 <carter> i read the stuff
22:11:41 <pharaun> wow i must be getting old because i already forgot who won
22:11:42 <pharaun> that one
22:11:45 <Arafangion> Why would the law consider haskell API's as distinct from C API's?
22:11:54 <carter> because in the case of google
22:11:59 <carter> they literally just copied the apis
22:12:04 <carter> to their Java
22:12:07 <Arafangion> pharaun: Google one the first round. Then Oracle challenged again and won, I think, but the case is still going.
22:12:09 <carter> from Oracle / Sun java
22:12:25 <Arafangion> Google *won* the first round, rather.
22:12:57 <pharaun> ahh k
22:13:21 <carter> point being, the challenge decision is framed wrt normal copy right
22:13:39 <carter> of
22:13:42 <crazydave> it makes sense that an API can be copyrighted.  Even if you don't like the corollaries of that
22:13:48 <carter> yes
22:14:14 <carter> so a particular latex rendering of some math using certain variables is copy righted
22:14:30 <carter> but if you rename all the types in the API, you can't really say its the same text
22:14:46 <carter> if you repalace every word in a book with a new made up word
22:14:55 <carter> and pair it with a dictionary between the two
22:14:59 <carter> its not the same book anymore
22:15:01 <carter> derived yes
22:15:03 <crazydave> carter: haha.  Very true.  You can't copyright the idea
22:15:13 <Arafangion> crazydave: The issue is that unless the text is the same, you can't interoperate with it.
22:15:50 <carter> Arafangion: well, you could do what i just suggested
22:15:56 <acomar> crazydave: Do you think it's reasonable to copyright a table of contents as well?
22:15:57 <carter> but then they couldn't just say "just write normal joava"
22:16:00 <carter> *java
22:16:16 <Arafangion> carter: The java implementation itself is not a copy, except for 9 lines.
22:16:24 <carter> no, the API
22:16:26 <carter> i'm saying,
22:16:35 <crazydave> acomar: I'm not claiming reasonableness, but I would think the answer to that is yes you can.
22:16:35 <carter> if they just changed the names of the API calls slightly
22:16:36 <Arafangion> Also, patent law should cover concepts.
22:16:48 <acomar> crazydave: so far, the courts have said no you can't
22:16:57 <carter> they'd lose normal jvm interop, but this case wouldn't have had this new decision
22:16:58 <acomar> crazydave: but you can copyright APIs?
22:16:59 <Arafangion> I don't think a java implementation with a different naming system would be usable.
22:17:20 <Arafangion> carter: You wouldn't even be able to use it to *compile* java code.
22:17:25 <carter> :)))))
22:17:26 <pharaun> it would be named
22:17:26 <carter> i know
22:17:28 <pharaun> NotJava
22:17:33 <carter> Expresso
22:17:42 <pharaun> ha
22:17:42 <carter> nearly the same, but you ahve to patche EVERYTHING
22:17:47 <crazydave> acomar: why can't you copyright a table of contents? Is that because it is effectively unique?
22:18:05 <carter> any written document can be copyrighted
22:18:38 <crazydave> carter: would you be allowed to write a program that automatically patched any code to use the new API or would that require using the old API and thus be forbidden?
22:18:41 * pharaun copyrights all of carter's irc message
22:18:51 <carter> you can't copyright someone elses work
22:18:57 <pharaun> boo
22:18:59 <pharaun> :)
22:19:04 <carter> by the act of writing, what I write is auto copyrighted
22:19:09 <shelf> but the work belongs to the carrier
22:19:16 <Arafangion> shelf: Only by agreement.
22:19:28 <crazydave> pharaun: carter has already placed his IRC messages under the quite invasive carter license
22:19:33 <carter> yup
22:19:34 <carter> :)
22:19:41 <shelf> i thought you were all figments of freenode's AI
22:19:53 <carter> shelf: i thought you were a twitter ai :P
22:20:01 <Yoctogon> This is my sentence. Copyright © 2014 Yoctogon. All rights reserved.
22:20:11 <shelf> i am definitely a markov chain on twitter
22:20:20 <Arafangion> Yoctogon: That's a fragment, not a sentence.
22:20:26 <carter> crazydave: well, i think that an autopatch for migrating from Java to Expresso would be fine
22:20:30 * Yoctogon curses
22:20:34 <carter> then the google api would be different
22:20:38 <dolio> Copyright doesn't prevent someone from writing the exact same thing as you, though. It only prevents someone copying the document you wrote.
22:20:43 <carter> yup
22:20:44 <carter> that
22:20:47 <carter> dolio: well said
22:20:57 <carter> patent != copyright
22:20:58 <acomar> hmm... can't find anything on this by searching directly on google... but I do remember reading in the discussions on this subject over the last few weeks that table of contents and other structural elements of text could not be copyrighted.
22:20:58 <Arafangion> dolio: Good luck proving that. :/
22:20:59 <dolio> So writing code with the same API doesn't mean that you violated the copyring on the API.
22:21:04 <pharaun> does this include sql?
22:21:12 <pharaun> what do you define as api?
22:21:12 <dolio> Unless you copied the API by actual copying.
22:21:25 <dolio> Copyright, even.
22:21:35 <pharaun> i couldn't develop a drop-in replacement for an api if they were copyrighted
22:21:42 <Arafangion> dolio: That's for the courts. :)
22:22:01 <carter> pharaun: you could
22:22:02 <crazydave> acomar: yeah, okay, that makes some sense then.  Effectively the reason I said ... it is unique and comes from describing the text already.
22:22:10 <Arafangion> carter: Please expand how.
22:22:14 <acomar> crazydave: yea, that's my understanding as well
22:22:32 <carter> heres an api : write something thats feature equiv but organized differently
22:22:36 <acomar> crazydave: Some of the legal summaries of the trial were noting that the case was poorly argued by google's lawyers
22:22:47 <Arafangion> carter: You can't organise it differently while being a drop-in replacement.
22:22:48 <carter> fantasy novels all have the same API
22:22:49 <acomar> crazydave: and that they failed to make these kinds of comparisons clear to the court
22:23:02 <carter> everything is the tolken api
22:23:13 <carter> every romance novel has the same API
22:23:18 <pharaun> carter: what i meant was a direct drop-in replacement, IE software A depends and links to library B and you want to replace library B with your own implementation, lib B has an api that is copyrighted, how can you do this without modifying software A ?
22:23:18 <carter> they just organize the words differently
22:23:32 <carter> write a parser and fix it
22:23:33 <carter> :)
22:23:46 <pharaun> wow i don't like that approach
22:23:56 <carter> point being, the copyright isn't for ideas, its for exact pieces of text
22:23:59 <crazydave> acomar: I've certainly read rulings before that baffled me and then after reading the ruling discovering that the argument put forward was nonsensical and had they just put together a coherent case the outcome would be different.
22:24:07 <Arafangion> For all practical purposes, Java code needs to be binary compatible. :(
22:24:11 <carter> well
22:24:14 <carter> then they fucked up
22:24:15 <carter> :)
22:25:10 <acomar> crazydave: yea, exactly. As long as it all gets sorted out eventually...
22:25:39 <Arafangion> carter: I doubt it, given that the original case hinged on those 9 lines (involving the Array Length or something), tightly integrating the API with all Java code could well have been intentional.
22:25:50 <carter> well
22:25:52 <carter> i'm not a lawyer
22:26:04 <carter> and i'm not sure if it was really hinging on 9 lines of text
22:26:07 <Arafangion> Then again. The original implementers were Sun Microsystems.
22:26:17 <Arafangion> Not Oracle.
22:27:04 <carter> that has nothing to do with the discussion
22:27:34 <Arafangion> Well, lets see how this goes. Hopefully it all resolves nicely, with API's being declared not copyrightable. Hopefully.
22:27:50 <dolio> From what little I've read, too little was made of the fact that "copying an API" doesn't involve copying text verbatim from one file into another.
22:27:55 <Arafangion> btw, where you you guys read up on this?  Since groklaw closed I haven't been able to keep up.
22:28:34 <dolio> So they kind of just admitted to "copying," which might have been unwise.
22:28:49 <Arafangion> dolio: If it were me (I am not a lawyer), I'd have argued that the API is the minimum required outcome of reverse engineering a compatible solution. (And thus allowed)
22:29:12 <Arafangion> dolio: I'd have claimed reverse engineering.  But reverse engineering rights seem to be frowned upon these days for some reason.
22:29:23 <Yoctogon> This is, in and of itself, a sentence. Copyright © 2014 Yoctogon. All rights reserved.
22:29:43 <carter> Yoctogon: you dont have to declar the copyright for copyright to exist
22:29:48 <Arafangion> Yoctogon: Fine.  Lets leave that to the court to decide, if we ever come to it.
22:29:50 <crazydave> If it were me being a highly paid lawyer I'd probably be making sure that I argue a case that could be appealed against resulting in yet another appearance fee
22:29:52 <EvanR> you have the right to remain ignorant
22:29:55 <Arafangion> carter: That depends on country and the laws you're living under.
22:29:59 <carter> USA :P
22:30:16 <carter> also i have >=2 IP laywers in the family
22:30:30 * pharaun runs
22:30:37 <dolio> crazydave: I don't know. You probably don't have to worry about the case being appealed. :)
22:30:39 <pharaun> carter just became scarier
22:30:58 <carter> pharaun: nah, it means i have pretty handy contract templates for my work
22:31:12 <carter> and i email friends the contracts I use so they can have nice contracts too
22:31:18 <pharaun> nice
22:31:26 <Arafangion> carter: That helps, I bet.  I notice that it's free and automatic in Australia too, but I seem to recall that wasn't always the case (can't remember if it wasn't the case in Australia or the US... or perhaps the EU)
22:31:55 <carter> theres enough treaties on copyright that i'd be suprised if they werent' the same in most countries now
22:32:04 <carter> teh subtlety is when does copyright end
22:32:09 <carter> thats is REALLy varied
22:32:18 <Polarina> Arafangion, copyright is free and automatic everywhere under the Berne convention: http://en.wikipedia.org/wiki/Berne_Convention
22:33:07 <crazydave> talking of reverse engineering APIs and going back to Integer-Slow (I mean Integer-Simple) .... where would I find the API for Integer ....
22:33:18 <EvanR> so if i have a type for game level, and a type for location of some object in the level, i can use a phantom type to ensure that i dont use a location value from the wrong level and get something equivalent to an out of bounds error
22:33:24 <Arafangion> Looks like the USA didn't become part of the Berne convention until 1989. Interesting.
22:33:56 <crazydave> currently here: http://git.haskell.org/packages/base.git/tree and clicked on Data expecting a Data.Integer and ... oh fail
22:34:02 <Arafangion> carter: Agreed.
22:34:31 <dolio> EvanR: Maybe, but if it's just a phantom type, you'd need to know statically that the location is from the right level.
22:34:34 <dolio> Somehow.
22:34:34 <Arafangion> carter: I dont' think Australia has (or had?) a concept of "Fair use", though, which made this really stupid.
22:35:05 <carter> the UK has those scary libel laws too
22:35:07 <Arafangion> carter: Until about 10 years ago, it was illegal to copy one's music to a cassette tape to play in their car, for personal use, for instance.
22:35:12 <EvanR> dolio: by generating starting positions and new positions from the module that defined the particular level...
22:35:31 <Arafangion> I _think_ it's legal now.
22:35:41 <EvanR> from the same hidden constructor
22:36:15 <dolio> EvanR: I just mean that there's no way to discover from the representation that a location is compatible with a level. You'd need something like GADTs for that.
22:36:21 <crazydave> Arafangion: fairly sure that is false.  There has been fair use for copying text in Australia.  Or no library would have been allowed to have a photocopier in it.
22:36:35 <dolio> And that might be annoying. Either way might be annoying, really.
22:37:15 <dolio> I suppose you could also have hidden information and checks against it that asserted that the phantoms were compatible, too.
22:37:23 <Arafangion> crazydave: From what I understood, schools and the like were required to pay special fees for this. As foe the rest of us, we're allowed to copy 10% of a text.
22:37:27 <dolio> So that you couldn't forget to do them.
22:37:45 <dolio> Faking GADTs, in a way.
22:37:58 <Arafangion> crazydave: But schools couldn't say, give one student's textbook to someone in the next year, without ensuring they have copyright permission.
22:38:03 <EvanR> there are always checks (unless you use unsafeWhatever), but the idea is to not resort to error "oh shit" or some other thing when the checks fail
22:38:14 <EvanR> because you made it statically impossible
22:38:18 <crazydave> Arafangion: https://en.wikipedia.org/wiki/Copyright_law_of_Australia#Fair_dealing_and_other_exceptions.  Okay, so not the same as fair use.  We still _don't_ have fair use.  Copying is allowed for research or study.  Definitely no fee payable for that
22:38:32 <coppro> wtf. how can I import something but it's not in scope?
22:38:52 <Arafangion> crazydave: I'm pretty sure that the education dept itself has it's own category.  As a student, though, then that would apply.
22:38:53 <EvanR> theres too much legal -blah for me to think straight about it
22:38:55 <coppro> import Network.Mail.SMTP (sendMail, simpleMail, plainTextPart, Address)
22:39:00 <coppro> Interact.hs:82:101: Not in scope: data constructor `Address'
22:39:26 <Arafangion> crazydave: Ie, what you do as part of teaching is different to what you're permitted to do as part of learning.
22:39:39 <michaelt> coppro: probably Address(..)
22:40:00 <coppro> durr, thanks
22:40:11 <coppro> I'm too tired to be coding
22:40:13 * coppro keeps going
22:40:28 <EvanR> dolio: its just annoying me... if i have a graph with nodes labeled with numbers, and i use a bogus location (from the last level that was loaded or something) i would get something ranging from a crash to really weird behavior
22:41:23 <EvanR> but it seems that i can stop that if locations from each level cant be used on other levels
22:41:41 <EvanR> i still havent read about GADTs
22:43:54 <enthropy> EvanR: data LocationMap (t :: Nat) thing = IntMap thing?
22:44:18 <dolio> EvanR: I definitely think you could use type parameters for this.
22:44:28 <enthropy> then newtype Key (t :: Nat) = Key Int
22:44:46 <enthropy> lookup :: Key t -> LocationMap t e -> Maybe e ?
22:46:12 <EvanR> im not sure how those newtypes are different from just using Map and Int directly, and lookup being Nothing would require a crash because it wouldnt make sense to happen
22:46:23 <EvanR> dolio: what exactly does that mean?
22:47:37 <dolio> It means I think you're right, that you could tag your location and level types, and not worry about mismatches when the tags are known to be the same.
22:47:50 <dolio> And only test when you have two things that you don't know are the same.
22:48:05 <enthropy> those newtypes can help you to stop using something with type Key 1 in LocationMap 2
22:48:19 <dolio> To get information about whether or not they are the same. Which should occur infrequently.
22:48:21 <EvanR> a runtime check would prevent weirdo behavior but not crashing
22:48:32 <EvanR> in the case of a bug
22:48:51 <enthropy> EvanR: where do the Keys come from?
22:49:10 <EvanR> enthropy: oh i see, yeah so youre suggesting a runtime check on lookups
22:49:30 <enthropy> well maybe the items at each location change over the course of your game?
22:49:32 <EvanR> keys come from level initialization and movement
22:50:32 <EvanR> and all the locations/keys/pointers should be discarded during a reset
22:50:43 <pavonia> Can anyone tell me what "ribbon length" denotes in Text.PrettyPrint?
22:51:23 <pavonia> Or what a ribbon is in source code?
22:51:30 <EvanR> width?
22:52:08 <pavonia> I think that's line length
22:52:39 <pavonia> There's a parameter ribbonsPerLine :: Float  -- Ratio of ribbon length to line length
22:52:58 <enthropy> EvanR: well if the lookup is Nothing, this means the person did something like "pick up object", but there's nothing there
22:53:09 <EvanR> no no...
22:53:10 <enthropy> so you just tell them something?
22:54:21 <dolio> pavonia: I think it has to do with the difference between an absolute page size and what percentage of that page you actually want to use.
22:54:33 <EvanR> location is like a particular place, so if theres place 1 2 3 and 4, any other value is invalid
22:54:55 <dolio> pavonia: So, you might have 80 characters of space, but only want to use 60 of that for actual text, ignoring indentation.
22:55:04 <EvanR> so there may be zero or more things at 1 2 3 or 4, but the issue is that there places on the next level might be 1 2 and 3, then 4 is an error
22:55:09 <dolio> Something like that.
22:55:30 <crazydave> EvanR: Why not encode a place as {level, place} so that each place is UNIQUE rather than repeating numbers
22:55:43 <pavonia> dolio: I see, thanks
22:56:47 <EvanR> currently, the pointer is actually a direct reference into the graph, so if that was just it, a dangling location/pointer would be referencing the old level, all else being the same. but on top of that i have numbered nodes to help with path finding
22:56:48 <crazydave> or even each level as a list of locations.  Now you are asking what happens if you access something past the end of the list .....
22:58:43 <crazydave> ah, hmmm. I see the problem.  Sort of.  You want a different data type for each level so that you can't accidentally use the wrong one.  But the same data type so you can reuse all the same basic functions
22:58:47 <EvanR> either way, combining a pointer with the full level to solve some problem where the two do not agree would be chaos
22:59:33 <EvanR> yeah same data, but restrict usage of values from different instances of construction
23:00:40 <EvanR> theres probably a lot of ways to deal with this statically im only just starting to read about this
23:06:00 <enthropy> EvanR: "place 1 2 3 and 4" are known at compile time?
23:06:31 <EvanR> im not reading anything from a file, so technically yes
23:07:17 <enthropy> so you can make      data Level1 t = Level1 { place1, place2, place3, place4 :: t }
23:07:27 <EvanR> yes
23:07:45 <EvanR> well
23:08:03 <enthropy> there are lots of ways to address the boilerplate that introduces
23:08:12 <enthropy>  -XDeriveDataTypeable, -XDeriveTraversable
23:08:23 <enthropy> template haskell
23:09:03 <EvanR> youre proposing making parts of the level structure actually different types
23:10:49 <EvanR> heres the code for a level https://github.com/evanrinehart/functional_pacman/blob/master/MazeA.hs
23:11:09 <EvanR> theres some boilerplate ;)
23:12:21 <EvanR> locations are either at a node or somewhere (0.0,1.0) between two nodes
23:12:38 <EvanR> so listing them in some way is not feasible
23:15:39 <enthropy> EvanR: well you can have locations as (node1, node2, Double)
23:15:51 <EvanR> yes i have something like that
23:16:29 <enthropy> do you manually write mazeA?
23:16:38 <EvanR> i did one day
23:16:42 <EvanR> at length
23:16:51 <enthropy> seems like it would be good to parse that reference schematic
23:16:55 <EvanR> presumably it could also be unpacked from some fancy algorithm too
23:17:15 <EvanR> youre right, though it would need more information
23:17:16 <jle`> not too fancy
23:17:26 <enthropy> after all, are you sure the two are actually the same map?
23:17:37 <EvanR> yeah i drew it with opengl
23:18:02 <EvanR> that horizontal line that goes "around" the cylindrical topology would be interesting to denote
23:18:52 <EvanR> the only other thing missing is the start spot... but thats another story
23:22:10 <enthropy> is it possible to write a {-# OPTIONS_GHC blah #-} in haddock?
23:29:01 <EvanR> heh, i added the phantom type variable. and now i seem to have to add forall a to any record fields that are holding it
23:29:21 <EvanR> now im wondering if it will even work
23:30:37 <EvanR> seems like (forall a. L a) and (forall a. Level a) would be auto compatible.. maybe not
23:38:52 <EvanR> it suggested i use existential quantification, but polymorphic components also works...
23:39:18 <EvanR> nvm
