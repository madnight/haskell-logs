00:08:18 <ReinH> johnw: That's true, but I'm going to hedge a bit when someone seems to expect exceptions to work like they do in (say) Java. ;)
00:08:35 * hackagebot xmonad-contrib-gpl 0.12.1 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-gpl-0.12.1 (DmitryBogatov)
00:08:35 * hackagebot async-extras 0.1.0.0 - Extra Utilities for the Async Library  http://hackage.haskell.org/package/async-extras-0.1.0.0 (JonathanFischoff)
00:09:40 <falafel> What are the disadvantages of simplifying Signals vs Behaviors/Events in FRP if I assume all events are discrete? For example, what would be the things Elm wouldn't be able to do by adopting this model?
00:11:26 <falafel> I'm reading on classical FRP vs Evented FRP (and arrowized FRP), to understand why is it necessary to make that distinction and if its worth doing for a simple UI solution
00:17:02 <falafel> As I understand so far, the main disadvantage is the Signal model doesn't form a monad, but an applicative, so can't have Signals of Signals, and such thing owuld be possible in the classical model, but it has various implementation complications. Some clarification would help. Anybody?
00:19:14 <dbelange> signal <--ANAGRAM--> lasagna
00:19:15 <jle`> falafel: er...all events are discrete in classical FRP
00:20:05 <startling> dbelange: only one 'a'
00:20:24 <jle`> and...an i
00:22:37 <startling> > "signal" // "lasagna"
00:22:39 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array i e’
00:22:40 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match type ‘GHC.Type...
00:22:40 <lambdabot>  Expected type: [(i, e)]
00:22:40 <lambdabot>    Actual type: [GHC.Types.Char]
00:23:09 <startling> > Data.List.(//) "signal" "lasagna"
00:23:11 <lambdabot>  Not in scope: data constructor ‘Data.List’
00:23:16 <startling> :<
00:23:29 <ion> > "signal" \\ "lasagna"
00:23:31 <lambdabot>  "i"
00:23:32 <falafel> jle`: yes, I'm asking basically looking for a list of pros/cons of modeling everything as a signal vs making a distinction of behavior/event, as Signal a ~= Event a. If behaviors are continuous and in the browser everything is an event,. I'm making a web form builder, from scratch.
00:24:07 <jle`> well
00:24:20 <jle`> in AFRP, Event a is Signal (Maybe a)
00:24:26 <falafel> jle`: so my stream of events are browser events, and the UI is html, but the code will be in PureScript possibly
00:25:09 <startling> ion: I guess I was leaning the wrong way.
00:26:18 <jle`> falafel: have you read the stack overflow post?
00:26:21 <jle`> on this issue/
00:26:26 <jle`> ?
00:26:29 <startling> > Data.List.union <$> uncurry (\\) <*> uncurry (flip (\\)) $ ("lasgna", "signal")
00:26:32 <lambdabot>  "ai"
00:26:57 <jle`> @src union
00:26:57 <lambdabot> union = unionBy (==)
00:27:06 <jle`> @src unionBy
00:27:06 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
00:28:23 <startling> > Data.List.union <$> uncurry (\\) <*> uncurry (flip (\\)) $ ("lasgna", "salami")
00:28:25 <lambdabot>  "gnmi"
00:28:28 <jle`> falafel: i think the main difference between just having a Signal (Maybe a) and not an Event a was the semantics of products
00:28:30 <startling> > Data.List.union <$> uncurry (\\) <*> uncurry (flip (\\)) $ ("lasagna", "salami")
00:28:32 <lambdabot>  "gnami"
00:28:52 <startling> hm, that's wrong.
00:29:53 <awestroke> :t (\\)
00:29:55 <lambdabot> Eq a => [a] -> [a] -> [a]
00:30:06 <falafel> jle`: Yes, I believe I have. I'm just having some issues coming up with a good implementation model that translates well to JS, but just bare-bones. I'm aware of Bacon.js but it's a bit too big. I was taking the Coursera Scala Course on reactive programming to find a middle ground but it wasn't that useful. I wanted to do the implementation using Object.observe but now i'm thinking of using PureScript to implement a more
00:30:07 <falafel> Haskellish version. Mind this is my first time attempting this
00:30:17 <awestroke> :t uncurry (\\)
00:30:18 <lambdabot> Eq a => ([a], [a]) -> [a]
00:30:33 <startling> the uncurry is for the stupid Reader trick.
00:31:38 <falafel> does anybody know of a simple FRP implementation of Signals in any language, by simple I mean it fits in a gist, soething ultra minimal
00:31:45 <falafel> jle`: ^^
00:33:26 <jle`> falafel: well
00:33:45 <jle`> technically you can get away with type Signal a = Time -> a
00:34:12 <jle`> although...that wouldn't really be able to handle events huh.
00:34:45 <jle`> the AFRP implementation is fairly simple and can fit in a few lines
00:35:23 <jle`> actually it can fit in one
00:35:28 <falafel> jle`: do you have a link?
00:36:00 <jle`> newtype Wire a b = Wire { runWire :: Time -> a -> (b, Wire a b) }
00:36:02 <falafel> The most minimal Signal implementation I could find is https://github.com/steveklabnik/frappuccino
00:36:11 <jle`> and...that's it
00:36:19 <jle`> a and b are Signal a and Signal b
00:36:41 <jle`> this is completely pull-based, non-"event driven" FRP though
00:38:05 <jle`> of course in order for AFRP to be useful you have to define some useful combinators...like a Category, Arrow, Applicative instance probably at the least
00:38:59 <jle`> but those are pretty straightforward
00:39:03 <falafel> jle`: and that's the issue I have translating the Haskell literature into JS. I did the same thing with some basic monads a while ago, and had to do a bunch of boilerplate
00:39:28 <jle`> that you have to define the utility functions?
00:39:32 <jle`> combinators?
00:40:48 <falafel> jle`: well, in JS I use prototype inheritance to define type constructors, and then I have to redefine global functions with the right arguments, like liftA, ap, etc...
00:41:13 <jle`> well, you can define specific functions just for that type if you want, right?
00:41:49 <jle`> unless you want the user to be able to program polymorphically/over all instances
00:42:39 <jle`> i think one big obstacle in making AFRP work in JS is that the whole thing relies on category composition, which is extremely tricky to get right unless you have a compiler typechecking you at every step
00:43:48 <ddellacosta> question re: The Haskell Road to Logic, Math an Programming--is there anything out of date in there as far as the Haskell syntax/style/etc.?  Just want to get a general sense if anyone knows.
00:43:49 <falafel> jle`: I typically just not worry about the types in JS, just the interface. I annotate, and test, but that's about it for assurances.
00:44:19 <falafel> But yes, it would be harder I suppose
00:44:39 <jle`> also infix operators help too, hm.
00:44:53 <jle`> i wonder how doable afrp in js would be actually.
00:45:40 <falafel> jle`: for infix operators and other syntax sugar I compile from LiveScript. But otherwise you'd make it a methd
00:45:43 <falafel> *method
00:46:31 <jle`> hm. i have to head off, but feel free to drop me a message if you find out anything new
00:46:39 <jle`> you also might have some luck asking your questions on #haskell-game
00:47:24 <falafel> jle`: will try, thanks. I'm still reading some of those papers, specially Elm's implementation seems the simplest route.
00:58:38 <ReinH>  ddellacosta I'd say that it has it's own style but there's nothing particularly unidiomatic about it
01:00:12 <ReinH> It doesn't really use libraries and Hasksll syntax hasn't really changed much so there isn't much to go out of date
01:00:39 <ReinH> *its thanks autocomplete
01:10:59 <sshine> is there a combinatoric way to do '\xs -> if null xs then 0 else head xs + 1'?
01:12:20 <johnw> fromMaybe 0 . fmap (+1) . listToMaybe?
01:12:26 <ddellaco_> ReinH: thanks
01:12:42 <edwardk> qrada: as a rule i believe in giving the user enough power to do anything they need to do. any module i export named Internal may be used to subvert the invariants of the data types I expose, but sometimes that may be precisely what you need to avoid driving the user to duplicate the whole damn thng themselves so they can do one extra little operation more
01:13:01 <Cale> sshine: btw,  case xs of [] -> 0; (x:_) -> x + 1  -- if you're using null and head or tail at the same time, you should generally at least be using case
01:13:20 <Cale> You can turn that into a lambdacase
01:13:56 <Cale> \case [] -> 0; (x:_) -> x+1
01:16:34 <sshine> Cale, I didn't know lambdacases existed. thanks :)
01:17:02 <sshine> Cale, I was actually using a case-of, but didn't think it translated well into an IRC one-liner.
01:17:27 <Cale> sshine: It's a relatively new syntactic extension
01:40:21 <enthropy> @hoogle Any
01:40:23 <lambdabot> Data.Monoid Any :: Bool -> Any
01:40:24 <lambdabot> Data.Monoid newtype Any
01:40:24 <lambdabot> Graphics.Rendering.OpenGL.GL.QueryObjects AnySamplesPassed :: QueryTarget
02:07:41 <efg> @where ops
02:07:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:08:06 <shachaf> efg: Hi?
02:08:18 <acar> what happen efg?
02:08:44 <efg> nothing, just trying the command in topic
02:09:25 <Cale> efg: Why would you do that?
02:09:26 <efg> so is there a channel log somewhere?
02:09:31 <efg> Cale: why not
02:09:33 <edwardk> efg: it is there as sort of an emergency "there is a spammer here" notification
02:09:34 <shachaf> That command alerts every op that something is going on -- probably best not to use it when there isn't.
02:09:41 <haasn> efg: It annoys everybody in that list
02:09:46 <efg> not my problem
02:09:46 <shachaf> Maybe we should update the topic to make that clearer.
02:09:52 <Cale> Because maybe you don't want to waste the time of many people?
02:09:57 <efg> i do
02:10:00 <efg> not
02:10:04 <efg> but i need to know where logs are
02:10:19 <efg> i need an op, there was a command. If that's not okay, update the friggin topic
02:10:20 <Cale> That's earlier in the topic
02:10:22 <shachaf> There are logs linked to in the topic, which I think you've read. :-)
02:10:23 <Cale> http://tunes.org/~nef/logs/haskell/?C=M;O=D
02:10:26 <efg> k
02:10:56 <Cale> In fact, let's just...
02:11:01 --- mode: ChanServ set +o Cale
02:11:04 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub' by Cale
02:11:04 <efg> thanks
02:11:08 --- mode: Cale set -o Cale
02:11:26 <Cale> There are enough people around who know when to use that command appropriately I think
02:11:40 <haasn> Certainly the ones that see it will learn what it does
02:11:48 <haasn> I did not find out about @where ops from the topic
02:13:18 <shachaf> efg: For what it's worth, saying "not my problem" in response to "It annoys everybody in that list" will probably not win you points with the people in that list.
02:13:31 <efg> i don't collect points
02:19:46 <levi> That's fine, but being rude reduces your social capital and thus the utility you can get out of the channel.
02:28:11 <bitemyapp> efg: Solipsism has a nice self-fulfilling symmetry.
02:28:56 <sipa> efg: if you annoy them enough, it may become your problem :)
03:12:47 <|akh|> Hi. I would like to maintain a timer across calls in a explicitly recursive function, such that an action is executed if in some time interval and the timer reset, otherwise continue and recurse. Anyone who can point be in a direction?
03:13:48 <hayashi> bless you
03:14:38 <sshine> |akh|, maybe use a continuation in combination with the IO monad.
03:15:31 <sshine> |akh|, what exactly, though, are you trying to do?
03:17:19 <cippo> ~l.
03:18:33 <|akh|> sshine: My function retrieves peer information from a tracker and also receives a time interval, I would like to reregister with the tracker only when the min value has passed.
03:19:01 <johnw> sounds like a job for concurrency to me
03:20:21 <|akh|> johnw: How is that without keeping a global data structure of the peer list?
03:20:37 <johnw> you'd pass around a TVar
03:20:51 <johnw> like, ReaderT (TVar [Int]) IO a
03:23:22 <|akh|> johnw: Okay, I haven't used Reader or ReaderT yes, so you might guess I'm new to this. Is it something like creating a TVar and passing it to two threads which then reads and writes to it independently? Can it be done without Reader?
03:23:57 <McManiaC> reader isnt necessary here, thats just for convenience
03:23:59 <McManiaC> yes
03:25:31 <jesyspa> Suppose I have types Foo :: * -> *, M :: * -> * where M is a monad.  I can form functions a -> M (Foo a) and Foo a -> (a -> Foo b) -> M (Foo b).  Is there any common name for such an "almost-monadic" thing?
03:26:03 <johnw> yeah, you could just pass the TVar around yourself
03:26:12 <johnw> or MVar, which form of concurrency you prefer
03:26:32 <McManiaC> if the function is strictly recursive theres not even a need for a t/mvar?
03:26:48 <McManiaC> or am i wrong
03:28:27 <johnw> once you have timeouts in effect, you will be dealing with threads
03:28:51 <|akh|> If I decide to execute the reregistration and retrieval or peers in one thread and downloading blocks in another, then they will have to communicate in some way. What is the difference between TVar and MVar?
03:29:09 <johnw> TVar uses STM, so code is easier to get right
03:29:10 <McManiaC> tvar is part of STM
03:29:20 <McManiaC> which has more blocking features etc
03:29:47 <johnw> MVar may be simpler here
03:30:02 <McManiaC> otherwise TVar is more like an ioref than an mvar
03:30:16 <McManiaC> MVar has the ability to block if it is "empty"
03:30:29 <McManiaC> TVar can't be empty
03:31:13 <|akh|> Yes I'm thinking MVar since I haven't used STM before and the fact that I can use it as a binary semaphore seems appropriate. Also, it might be okay that it can be empty.
03:32:43 <McManiaC> stm is not too complicated :)
03:32:47 <johnw> and there is TMVar
03:32:53 <johnw> it's an excellent library to know
03:33:12 <McManiaC> it might not be necessary for your job, but it will be good to be familiar with it
03:39:07 <|akh|> Okay I might look into STM and TMVar, but I think I'll start out trying MVar. Thanks for your help!
04:31:21 <u-ou> :t intercalate
04:31:24 <lambdabot> [a] -> [[a]] -> [a]
04:39:13 <awestroke> > intercalate "," ["abc", "def", "xyz"]
04:39:15 <lambdabot>  "abc,def,xyz"
04:43:15 <johnw> > concat (intersperse "," ["abc", "def", "xyz"])
04:43:17 <lambdabot>  "abc,def,xyz"
04:52:04 <tomejaguar> Does 'data A f a b = A (f (a -> b))' exist somewhere?
04:53:09 <sshine> for any typeclass f?
04:53:29 <johnw> for any type constructor f
04:53:40 <tomejaguar> Yes
04:53:45 <tomejaguar> f being a variable
04:53:59 <tomejaguar> Turning an applicative into an arrow, amongst other things.
04:55:20 <halvorg> How do I reverse the arguments for a function? I've seen it before I think
04:55:25 <johnw> flip
04:55:29 <halvorg> :D thanks
05:07:17 <Pythonfant> Can one think of the Reader monad as a special case of the state monad that doesn't change state?
05:07:43 <johnw> yes, certainly
05:07:53 <Pythonfant> okay, thx
05:13:59 <jkarni> is there any way of writing a function that takes a TH Name, or even a string, a value and a function, and binds that variable to that value in the function as an ImplicitParam?
05:14:23 <jkarni> e.g.: bind x v g = let ?v = x in g
05:14:45 <jkarni> though of course that doesn’t work because ?v doesn’t actually vary based on ‘v’
05:14:51 <johnw> you could make a Map be the implicit param
05:15:03 <jkarni> oh, nice idea
05:15:41 <jkarni> johnw: seems like that is the right way about it, thanks!
05:24:05 * hackagebot concurrent-extra 0.7.0.8 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.8 (BasVanDijk)
05:46:05 <dagle> What xml lib would people recommend? Is hxt a one fit all now with the modular system?
06:05:58 <Taneb> Is it possible to have a Haskell program where it's possible to write plugins written in Haskell?
06:06:39 <dottedmag> Taneb: like, xmonad?
06:06:54 <Taneb> Sooooort of?
06:07:12 <freezerburnv> Can someone explain to me how “(++) <*> map swap” works? I sorta get bits and pieces of it, but the whole thing doesn’t make sense to me. (e.g.: I know you can do “[(+1)] <*> [1,2]” to get “[2,3]”, but (++) isn’t in a list, so I’m not sure how it’s being used with <*>, or why using that with [(1,2), (3,4)] produces [(1,2), (3,4), (2,1), (4,3)]. How is it producing the second list that ++ is using to
06:07:13 <freezerburnv> concat?)
06:07:35 <Taneb> @type (++)
06:07:36 <lambdabot> [a] -> [a] -> [a]
06:07:39 <hpc> Taneb: like swapping out DLLs kind of a thing?
06:07:45 <Taneb> hpc, yeah, I think so
06:08:03 <dottedmag> Taneb: http://hackage.haskell.org/package/plugins - this one?
06:08:40 <Taneb> Oooh, that's great!
06:09:00 <dagle> You can also look at dyre, it's xmonads way of doing it wrapped in a lib.
06:09:05 <Taneb> freezerburnv, you can read the type of (++) as "((->) [a]) ([a] -> [a])"
06:09:24 <Taneb> freezerburnv, that fits the type of (<*>) which wants an f (a -> b) as its first argument
06:09:29 <dagle> Not really plugins but dynamic recompilation.
06:09:48 <Taneb> freezerburnv, here, f = (->) [a], and a and b are [a]
06:09:56 <Taneb> @type map swap
06:09:57 <lambdabot> [(a, b)] -> [(b, a)]
06:10:20 <Taneb> Likewise, you can read that as "((->) [(a, b)]) [(b, a)]"
06:11:34 <Taneb> With <*>, that forces (++) :: ((->) [(a, b)]) ([(b, a)] -> [(b, a)])
06:12:00 <Taneb> ...I'm not helping here at all, am I...
06:12:06 <freezerburnv> Taneb: So, to translate a little bit into the way that someone explained -> to me, ((->) [a]) is equivalent to “a function that takes a type “a” and gives back the type “[b] -> a”?
06:12:31 <Taneb> Yes
06:12:48 <Taneb> And ((->) [a]) happens to be an applicative functor
06:13:48 <Taneb> Which means we can do <*> on it
06:18:30 <dagle> In a way, that code is easier to write than to read.
06:23:31 <freezerburnv> Taneb: Sorry, brother showed up. So, I got the -> bit right, what does the ([a] -> [a]) mean after it?
06:25:24 <Taneb> Well, that's just a function
06:25:27 <Taneb> @type (<*>)
06:25:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:25:44 <Taneb> The first argument of <*> has the shape "f (a -> b)"
06:25:54 <Taneb> freezerburnv
06:26:16 <freezerburnv> Which in this case, would look like: [a -> b], correct?
06:26:41 <freezerburnv> (aka: List (a -> b), or something along that line)
06:26:51 <Taneb> No, f isn't [] here
06:27:01 <Taneb> f is ((->) [a])
06:27:28 <freezerburnv> Ah
06:27:50 <Taneb> Do you see how that works?
06:28:26 <freezerburnv> …well my mind is slightly broken, meaning I don’t really see how it works yet. ANd I have to go. Thanks for helping Taneb, wish I could keep having my mind broken. I’ll be back later
06:32:13 <Taneb> I need to get better at explaining
06:33:03 <Sculptor> ran you rephrase that
06:33:05 <Sculptor> can*
06:33:13 <Sculptor> ;) a joke
06:33:16 <Taneb> :)
06:33:56 <jomg> just wanted to try explaining myself, but then i saw he left
06:35:59 <Arnob> >pl \x -> x
06:36:07 <Arnob> > pl \x -> x
06:36:08 <lambdabot>  <hint>:1:4: parse error on input ‘\’
06:36:19 <Arnob> > pl (\x -> x)
06:36:20 <lambdabot>  Not in scope: ‘pl’
06:36:21 <lambdabot>  Perhaps you meant one of these:
06:36:21 <lambdabot>    ‘pi’ (imported from Prelude),
06:36:21 <lambdabot>    ‘p’ (imported from Debug.SimpleReflect),
06:36:21 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect)
06:36:25 <Taneb> @pl (\x -> x)
06:36:26 <lambdabot> id
06:36:37 <Taneb>  > runs code, @ does commands
06:37:12 <Arnob> hah! Thanks taneb
06:37:27 <Arnob> > @pl (\x->x)
06:37:29 <lambdabot>  <hint>:1:1: parse error on input ‘@’
06:37:36 <Arnob> @pl (\x->x)
06:37:36 <lambdabot> id
06:38:21 <Arnob> @pl (\x -> x == "," || x == ";")
06:38:22 <lambdabot> liftM2 (||) ("," ==) (";" ==)
06:38:53 <Arnob> hi all
06:39:08 <Arnob> is is possible to rewrite this without using lift?
06:39:08 <Arnob> (\x -> x == "," || x == ";")
06:39:43 <Arnob> (rewrite this as point free)
06:39:58 <bernalex> @pl (\x -> x == "," || x == ";")
06:39:58 <lambdabot> liftM2 (||) ("," ==) (";" ==)
06:40:05 <bernalex> right, I see what you mean
06:40:17 <bernalex> my first question would be "why"?
06:40:17 <jomg> well, you could do something like (||) <$> ("," ==) <*> (";" ==)
06:40:27 <jomg> but that's basically doing the same thing
06:40:27 <vanila> flip any [",",":"] . (==)
06:40:40 <bernalex> jomg: yeah that was my thought as well
06:40:58 <Arnob> but wouldn't <$> mean that the input to the function would have to be of the type applicative?
06:41:18 <Arnob> ...or be an instance of the applicative class, I mean
06:41:19 <vanila> Arnob, (->)e is applicative, with composition
06:41:36 <bernalex> :t (<$>)
06:41:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:41:41 <bernalex> Functor not Applicative
06:41:53 <vanila> :t (<*>)
06:41:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:42:34 <jomg> maybe you could also use the monoid instance for Any
06:42:44 <jomg> but that would probably be overkill
06:43:16 <vanila> > flip any [",",":"] . (==) $ ","
06:43:17 <lambdabot>  True
06:43:36 <bernalex> Arnob: basically any suggestion would be a lot more ugly and tedious to read than the pointful original
06:44:23 <supki> Arnob: `elem` [",", ";"]
06:44:34 <vanila> supki++ even better
06:44:43 <jomg> yea, that seems sensible
06:44:44 <Arnob> haha... well I guess I am trying to learn how to translate things into point free mode... not necessarily to write actual code
06:45:11 <bernalex> supki: oooh nice
06:53:28 <Kaidelong> what is the difference between Data.Sequence and Data.List?
06:54:15 * hackagebot protobuf 0.2.0.2 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.0.2 (NathanHowell)
06:54:18 <oleo> sequence is more general
06:55:02 <oleo> list is prolly a subtype of it...
06:55:30 <Kaidelong> that cannot be right. Seq and [] are both concrete types
06:55:45 <Kaidelong> maybe you're thinking of Foldable or Traversable?
07:18:49 <tnks> so I've developed this vocabulary of saying that IO is an "effect," but not a "side-effect"
07:19:35 <tnks> to try to help people understand better how working with effects isn't really any different from working with data.
07:19:52 <tnks> but I don't know if this is a usage of "side-effect" that's uncommon.
07:20:24 <tnks> since there's already decades of conversations on this topic.
07:25:12 <Averell> what do i have to do to get lambdabot to build on arch? i rm'd the whole .cabal/ but still no dice
07:29:00 <CindyLinz> Hi all~~ ^^
07:29:21 <efg> what's this underscore thingie in haskell?
07:29:27 <CindyLinz> Is there a hackage package that doing regular expression matching on stream?
07:30:20 <CindyLinz> That's.. I can put each data segment incrementally, and got the captures some time.
07:32:54 <Kaidelong> efg: I'm not sure what exactly you mean but if you're talking about underscores in patterns, it's for when you want to match any value but don't want to give a name to the match and use it
07:33:13 <Kaidelong> IE let's say I want to write null
07:33:25 <Kaidelong> we have two cases, null [] = True
07:33:32 <Kaidelong> and null (x:xs) = False
07:33:39 <danilo2> Hello all! :) Could somebody help me figuring out what is the equivalent of "data Proxy a = Proxy" (usefull when for example writing "a = Proxy :: Proxy 5" with PolyKinds) in the GADTs notation ?
07:33:43 <Kaidelong> but we don't use x or xs on the right hand side
07:33:47 <Kaidelong> so we can instead write
07:33:54 <Kaidelong> null (_:_) = False
07:34:08 <Iceland_jack> danilo2:
07:34:08 <Iceland_jack>     data Proxy a where
07:34:08 <Iceland_jack>       Proxy ∷ Proxy a
07:34:10 <efg> got it, thanks
07:34:26 <danilo2> Iceland_jack: ahh , of course ...
07:34:30 <danilo2> Iceland_jack: thanks!
07:34:35 <Iceland_jack> yw
07:35:13 <danilo2> Iceland_jack: By the way - can we limit the possible "a" in the declaration, so it could be only an "Int" kind? (I do not know if I'm using proper terminology here)
07:35:42 <danilo2> Iceland_jack: so I want to allow write "a :: Proxy 5", but not "a :: Proxy 'a'"
07:36:08 <Iceland_jack> You couldn't write 'Proxy 'a'' anyway
07:36:18 <Iceland_jack> the 'a' in Proxy is a Type, not a term
07:36:33 <Iceland_jack> you can write 'Proxy 5' for a Nat kind
07:38:14 <Iceland_jack>     ghci> Proxy :: (Proxy (5 :: Nat))
07:38:14 <Iceland_jack>     Proxy
07:38:42 <danilo2> Iceland_jack: Why can I write (a::Proxy 5) and (a::Proxy "test") but not (a::Proxy 'a') - what is the difference? I was trying to read about it but I do not understand it completely yet. Would oyu be so nice and tell few words about it?
07:39:14 <Iceland_jack> sure thing
07:39:25 <Iceland_jack> so natural numbers and strings are just recent special cases
07:39:37 <Iceland_jack> from 7.8, Nat and Symbol
07:39:59 <Iceland_jack> when you write '5' there it's not actually an Int or an Integer or any value-level term
07:40:18 <Iceland_jack> those terms would be
07:40:19 <Iceland_jack>     5 :: Int :: *
07:41:36 <danilo2> Iceland_jack: Ok, so far its clear :)
07:41:42 <Iceland_jack> So you have only put types for 'a', like
07:41:42 <Iceland_jack>     Proxy ∷ Proxy Int
07:41:42 <Iceland_jack>     Proxy ∷ Proxy Maybe
07:41:50 <danking> Maybe this is a silly question, but is there a procedure with the type `Maybe a -> Either a' ? I imagine it probably needs an argument for what kind of Left to return in the failure case. Right now I just `case' on the maybe. It feels like if I do this a lot I'd rather just have some procedure which converts `Nothing' to some default `Left' value.
07:41:55 <Iceland_jack>     Proxy ∷ Proxy (Either (Int → Int))
07:42:21 <Iceland_jack> danking: that Either type is incomplete
07:43:02 <danking> Iceland_jack: I guess this brings up another question, how is Either a monad if it takes two type variables?
07:43:08 <danking> That's been confusing me for a bit now.
07:43:12 <Iceland_jack> it isn't
07:43:21 <Iceland_jack> danking: Basically the '5' and "hello world" in
07:43:21 <Iceland_jack>     Proxy ∷ Proxy 5
07:43:21 <Iceland_jack>     Proxy ∷ Proxy "hello world"
07:43:21 <Iceland_jack> are not your normal Integer and String
07:43:43 <Iceland_jack> 'Either a' is a monad, [] is a monad, Maybe is a monad,
07:43:46 <danilo2> danking: Either is not a monad! (Either a) is a monad
07:44:10 <Iceland_jack> danilo2: Sorry, the above was meant for you
07:44:46 <danilo2> Iceland_jack: no proble, - I'm reading everything you write :) So hmm, is it true, that Proxy :: Proxy 5 :: * ?
07:45:36 <Iceland_jack> @kind Proxy
07:45:37 <lambdabot> k -> *
07:45:37 <Iceland_jack> yes
07:45:41 <danilo2> If yes, can I assume that 5 and "test" can be used like types in GHC 7.8 and they are distinct form Strings and Int's in a speical way? Is there any further magic or possibilities here?
07:46:25 <Iceland_jack> well they are distinct from Strings and Ints in the sense that their values are on the type leve
07:46:27 <Iceland_jack> *level
07:47:09 <Iceland_jack> The magic and possibilities would be the classic: indexing lists by their length
07:47:10 <Iceland_jack>     appendLists :: List n a -> List m a -> List (n + m) a
07:47:40 <Iceland_jack> or allowing you to have strings as keys in records (this is what the new OverlodedRecordSyntax proposal does)
07:47:48 <bjornars> :t note
07:47:50 <lambdabot>     Not in scope: ‘note’
07:47:50 <lambdabot>     Perhaps you meant one of these:
07:47:50 <lambdabot>       ‘not’ (imported from Data.Bool),
07:48:00 <Iceland_jack> danilo2: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design you can search for 'Symbol' there
07:48:38 <danilo2> Iceland_jack: Ok, thnak you very much! :)
07:49:04 <Iceland_jack> danilo2: For example
07:49:04 <Iceland_jack>     getPersonId ∷ r { personId ∷ Int } ⇒ r → Int
07:49:04 <Iceland_jack>     getpersonId e = personId e
07:49:04 <Iceland_jack> would be how it looks with sugar
07:49:37 <Iceland_jack> but 'r { personId ∷ Int }' is sugar and personId is a type-level symbol
07:50:11 <danking> danilo2, Iceland_jack: I don't see the type constructor `Either a' defined in the docs. They mention the type constructor `Either a b' and they implicitly use `Either e' (e.g. for the Monad instance definition). How would we define the type `Either e'? Is it `newtype Either a = Either b a'? GHCi complains about the unbound type variable. It also complains about using forall b. in front of Either b a.
07:50:30 <Iceland_jack>     getPersonId ∷ Has r "personId" Int ⇒ r → Int
07:50:30 <Iceland_jack> here "personId" is on a completely different level than "personId" ∷ String
07:50:48 <Forgetaboutit> danking: Either e is just Either a b partially applied to e
07:50:56 <danilo2> danking: Either a b is not a type consturcotr
07:50:58 <Iceland_jack> danking: You never use 'Either a' by itself, it's not a concrete type
07:51:17 <danilo2> danking: Either a b is a type of instance constructed by Right ... or Left ...
07:51:27 <Iceland_jack> danking: What happens is that when defining Monad instances you replace the Monadic type 'm' with 'Either a'
07:51:39 <danilo2> Iceland_jack: hmm, thats very interesting!
07:52:02 <Iceland_jack>     return ∷ Monad m ⇒ b → m          b
07:52:02 <Iceland_jack>     return ∷           b → (Either a) b
07:52:28 <danilo2> Iceland_jack: Last question if I could (I feel it could be related to that one) - Is it possible to write in Haskell "data X a = X a" but limit a to be of type that it tuple of doubles of any length?
07:53:32 <danking> Ah. I have never looked carefully enough at the definition of Monad, I didn't realike that the type variable, m, is applied to type arguments.
07:54:19 <Iceland_jack> danking: that's why Monad requries a constructor of type ★ → ★ :)
07:54:26 <danking> Iceland_jack: What do you mean by not a concrete type? Do you mean that `Either a' has no values which inhabit it? Is this bcause it's a partially applied type constructor?
07:54:35 <Iceland_jack> yes basically
07:54:56 <bjornars> danking: back to the original question - http://hackage.haskell.org/package/errors-1.4.1/docs/Control-Error-Util.html , note is the function
07:55:01 <danking> Iceland_jack: Ah. I wonder why they don't give the kinds of the types in the docs.
07:55:13 <Iceland_jack> danilo2: Tuples of doubles? You certainly _can_ but it won't be very pleasant
07:55:26 <danking> bjornars: Ahah! Nice, thank you
07:56:15 <danilo2> Iceland_jack: I know, I do not want to do it, just asking if there is such possibility - to allow X (1,2) , but not X ("test",5)
07:56:17 <efg> any real software out there i might have heard about, written in Haskell?
07:56:48 <danking> Thanks danilo2, Iceland_jack, and bjornars, this has been an enlightening discussion to start my Saturday. I feel I am on to great things!
07:57:02 <danilo2> danking: :)
07:57:19 <danilo2> efg: www.flowbox.io
07:57:25 <Iceland_jack> danilo2: If you really really wanted to a nice way of doing it would simply be making it explcit, no type magic
07:57:28 <danilo2> efg: written in haskell
07:57:42 <Iceland_jack> but do you want the parameter 'a' to reflect the actual tuple type?
07:58:08 <Iceland_jack>     data X = X1 Double | X2 (Double, Double) | X3 (Double, Double, Double) | …
07:58:21 <Iceland_jack>     data X a = X1 a | X2 (a, a) | X3 (a, a, a) | …
07:58:25 <danilo2> Iceland_jack: Hmm, I was just wondering if we can write data X a = X a and limit a to tuple of doubles of any length
07:58:32 <efg> danilo2: uh, that's vaborware
07:58:35 <efg> vapor*
07:58:44 <efg> i mean something i can download and use
07:58:53 <danilo2> Iceland_jack: I know your way would be nice and clean - I'm jsut asking because I do not know how to do it in Haskell and I'm just aksing if something like that is possible :)
07:59:27 <Forgetaboutit> efg: XMonad (a window manager), darcs (a DVCS)
07:59:40 <sipa> hedgewars-server
07:59:42 <sipa> ghc
08:00:15 <efg> Forgetaboutit: i know too well about dvcs, it's incredibly slow
08:00:20 <efg> i'm trying to find something good
08:00:53 <efg> checking out xmonad
08:01:24 <Forgetaboutit> efg: I haven't used xmonad tbh but its reputation is excellent
08:01:28 <Iceland_jack> danilo2: You can make a type-level list of double tuples and have a predicate that checks if the argument is in that list
08:01:57 <Iceland_jack>     X ∷ a ∈ '[(Double, Double), (Double, Double, Double), …] ⇒ a → X a
08:02:16 <danilo2> Iceland_jack: ok, this way ... I will not use it - anyway it is interestng solution :) Thank you for your help! :)
08:02:22 <Iceland_jack> but in reality you'd make a smart constructor or not do it at all
08:04:12 <dagle> Can you expand type names in ghci?
08:04:16 <Iceland_jack> :kind!
08:05:13 <dagle> I want a way to expand String to [Char] and things like that.
08:05:21 <Iceland_jack> oh, you can use :info (:i) for that
08:05:31 <Iceland_jack> then you get
08:05:31 <Iceland_jack>     type String = [Char]
08:05:35 <dagle> Oh, info expands them.
08:05:44 <Iceland_jack> Well it gives you the definition of synonyms
08:06:10 <dagle> Never thought info would do that, used if for a lot of other stuff. Ty. :)
08:07:15 <h_noob> trying to do forkIO, it fails with "failed to create OS thread: Resource temporarily unavailable"
08:14:26 * hackagebot mailbox-count 0.0.1 - Count mailboxes in a SQL database.  http://hackage.haskell.org/package/mailbox-count-0.0.1 (MichaelOrlitzky)
08:14:45 <geekosaur> be nice if h_noob would actually stick around after asking...
08:21:00 <Kaidelong> geekosaur: there's a netsplit going on right now, with any luck he should be back soon
08:21:25 <geekosaur> Kaidelong: they've been doing this for several days now
08:21:39 <geekosaur> pop in, ask that question, wait maybe a minute, leave
08:22:15 <geekosaur> come back a few hours later, do the same thing
08:27:53 <Averell> i can't get lambdabot to build, http://lpaste.net/104892 how do i fix that?
08:28:04 <monochrom> I have never encountered that error with forkIO. I call it bluff.
08:35:24 <danilo2> Hello! Would somebody tell me please why this 6-line code does not compile? I was sure it should compile just fine. I mean, the typefamilies ar  just simple type functions and I do not see nay problem that could exist with such code - what am I missing here? (http://lpaste.net/104893)
08:37:17 <danilo2> ahhhh nvm
08:37:23 <danilo2> a typo in the code :)
08:45:36 <exicer> I've got a function that looks like func :: ToJSON a => Maybe a -> b. When I pass in Nothing as the first argument, is there any way to get around having to cast it as something ?
08:47:06 <luite> exicer: what would your function do with a (Just a) value?
08:47:28 <h_noob> hmmm, I'm back... my internet sucks.
08:47:36 <exicer> It would decode it, and serve it as part of a JSON response. In it's absence it just sends null in that field.
08:47:41 <h_noob> if anyone had any input on my FFI/threading problem I missed it.
08:47:42 <exicer> er encode it
08:49:17 <Forgetaboutit> exicer: Are you using aeson?
08:49:30 <exicer> Forgetaboutit: Yes
08:49:54 <Forgetaboutit> exicer: I'd try using Null in case of Nothing
08:50:42 <Forgetaboutit> exicer: Null is a constructor from aeson's Value type: http://hackage.haskell.org/package/aeson-0.7.0.6/docs/src/Data-Aeson-Types-Internal.html#Value
08:50:49 <exicer> Forgetaboutit: Ah, interesting.w
08:50:52 <Forgetaboutit> exicer: Not sure if this helps
08:52:26 <exicer> Forgetaboutit: Hm, not sure. I think that Nothing would by default turn into Null. It's just the type signaure seems to require me to specify what instance of ToJSON I'm using, even though it is Nothing anyway.
08:52:55 <Forgetaboutit> exicer: Do you have control over your ToJSON function? If yes, I'd probably put the type signature like this: ToJSON :: (ToJSON a) => Maybe a -> Data.Aeson.Value
08:54:00 <Forgetaboutit> exicer: Do you mean you have to make Maybe and instance of the ToJSON typeclass?
08:54:03 <exicer> I'll try it, but I think it will have the same problem - it will want me to say what type ToJSON a actually is
08:54:36 <exicer> Forgetaboutit: I think there is already an instance of this defined in Aeson
08:54:49 <hexagoxel> @pl concatMap ($a)
08:54:49 <lambdabot> (($ a) =<<)
08:54:58 <danilo2> Is it possible to introduce in haskell dependencies between type families? I want to tell ghc, that "SpaceOf (CoordOf (SpaceOf a) b)" is alwyas equal to "SpaceOf a", where SpaceOf and CoordOf are type families. If I do not specify such dependency GHC does not allow me to compile some code complaining that SpaceOf is type function which might not be injective
08:55:11 <geekosaur> monochrom, I was thinking that was a weird error for forkIO, yes
08:55:17 <geekosaur> it shouldn't be making OS threads
08:55:29 <hexagoxel> wait, why does my local pointfree print "(() =<<)" ?
08:55:33 <Forgetaboutit> exicer: You're right, Aeson already has a ToJSON instance for Maybe
08:56:26 <monochrom> danilo2: a constraint like "SpaceOf (CoordOf (SpaceOf a) b) ~ SpaceOf a" may help
08:56:59 <Forgetaboutit> exicer: I'm not sure then what your specific requirement is tough
08:57:09 <monochrom> if it does not, then I don't know what else to do
08:57:22 <monochrom> except to say "don't play type-level tricks"
08:58:50 <danilo2> monochrom: id does not. If you want to look at the code, here is the complete example: http://lpaste.net/104894 . It is very simple - the line 63 should be used when converting between coordinate systems when no other instance is matched - firstly by converting the type to Cartasian coordinate system and trying again
08:59:31 * hackagebot attoparsec 0.12.0.0 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.0.0 (BryanOSullivan)
08:59:31 <hexagoxel> what is lambdabot's pointfree version?
09:00:01 <hexagoxel> also, how can i list lambdabot commands? it says something about 'list', but i fail to make that work
09:00:17 <hpc> to make things pointfree, use @pl
09:00:31 <hpc> short for pointless, because sillies
09:00:46 <hpc> there's no good list of all lambdabot commands
09:02:21 <hexagoxel> so lambdabot is lying in @help ?
09:02:38 <hpc> @help
09:02:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:02:42 <hpc> @list
09:02:42 <lambdabot> What module?  Try @listmodules for some ideas.
09:02:46 <hpc> @help list
09:02:46 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:03:03 <hpc> @listmodules
09:03:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:03:15 <hpc> oh, nifty
09:03:37 <hpc> my knowledge of lambdabot's help stuff is a few years old, didn't realize it had improved
09:04:25 <monochrom> int-e improved it a lot
09:06:43 <brycelane> question: I'm trying to understand Control.Exception and it seems 'catch' is simply an alias for catchException which doesn't seem to have a definition. Is it a 'magic' complier function?
09:07:32 <merijn> brycelane: Exception catching is something that's done by the runtime, so it's presumably a magic builtin function for the RTS
09:07:51 <brycelane> merijn: thats exactly what I expected. Thanks.
09:09:32 * hackagebot mailbox-count 0.0.2 - Count mailboxes in a SQL database.  http://hackage.haskell.org/package/mailbox-count-0.0.2 (MichaelOrlitzky)
09:14:02 <int-e> monochrom: I can't take credit for that, but I'd have to check github to figure out who did the hard work.
09:23:32 <int-e> (mokus, most likely, given the sheer number of patches he has in lambdabot. the pointer from @list to @listmodules was added by him, for example.)
09:23:36 <roconnor> What do infix do you guys use for (,) <$> x <*> y ?
09:23:54 <roconnor> I've been reduced to using <×> which is less than ideal for so many reasons.
09:25:09 <roconnor> I want to call it <*> but somone already took that.  <,> isn't actually legal.
09:25:21 <Clint> what makes it illegal?
09:25:31 <roconnor> Clint: no commas allowed
09:25:31 <vanila> what about <&> or &&&
09:25:51 <roconnor> vanila: I actully have used <&> before, but edwardk has taken that
09:25:58 <roconnor> &&& is already in arrow.
09:26:25 <int-e> @index <:>
09:26:25 <lambdabot> bzzt
09:26:29 <int-e> @hoogle <:>
09:26:31 <lambdabot> No results found
09:26:36 <roconnor> and <&&&> or <***> feels a little ridiculous, though I could be convinced.
09:26:50 <Enigmagic> danilo2: i "fixed" it, now it just fails with overlapping instances... because it has overlapping instances ;-)
09:27:03 <int-e> (inspired by lisp, where a pair is a cons)
09:27:12 <edwardk> <+>, <%>, <#> are all untaken
09:27:25 <Clint> <+> is taken
09:27:36 <roconnor> I'm using <+> to mean Left x <|> Right y
09:27:40 <roconnor> Clint: Fuuuuu.....
09:27:50 <edwardk> Clint: by pretty printers?
09:27:52 <Clint> arrow
09:27:58 <Clint> er, Control.Arrow
09:28:08 <monochrom> need more symbols on the keyboard
09:28:11 <danilo2> Enigmagic: Thank you. You are right- f we add now Overlapping instances it needs IncoherentInstances and one more predicate and then it hangs during execution (what is a proper behaviour in this case)
09:28:11 <int-e> @type (Text.PrettyPrint.HughesPJ.<+>)
09:28:13 <lambdabot> Doc -> Doc -> Doc
09:28:16 <edwardk> oh yeah arrowplus silliness
09:28:18 <vanila> if you dont use arrow you could redefine
09:28:21 <int-e> @type (<+>)
09:28:23 <lambdabot>     Ambiguous occurrence ‘<+>’
09:28:23 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
09:28:24 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:36:1-20
09:28:35 <int-e> @type (Control.Arrow.<+>)
09:28:37 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
09:28:50 <Enigmagic> danilo2: the proper thing to do is fix it so you don't need incoherent instances enabled..
09:28:52 <roconnor> Clint: Fuuuuu.....
09:28:58 <edwardk> i wouldn't feel bad taking that name, who uses arrows, anyways? =)
09:29:16 <roconnor> :D
09:29:44 <vlads> roconnor: what do you use `(,) <$> x <*> y' for?
09:29:47 <monochrom> Hawkeye does
09:30:37 <roconnor> vlads: right now I'm using it to parse a pair, which seems to be useful in a couple of situtation, espcially for akward left-factored grammars.
09:31:26 <Enigmagic> danilo2: to me it looks like line 64 just calls itself, so that would explain a hang
09:31:54 <danilo2> Enigmagic: I'm trying but so far I do not know how it could be done. I just want have a "default instance" for converting something to Polar coordinates simply by trying to convert it firstly to Cartesian and then to Polar
09:32:35 <Enigmagic> danilo2: what version of ghc are you using?
09:32:36 <danilo2> Enigmagic: it does not - look - it converts "the thing" to Cartesian coordinates first and then to Polar
09:32:42 <danilo2> Enigmagic: 7.8
09:33:17 <Enigmagic> danilo2: you can make something like default instances using closed type families
09:33:59 <danilo2> Enigmagic: I do not want closed type families, because I want user to be ableto extend the available coordinate systems
09:34:24 <danilo2> Enigmagic: I annotated the example with the version, which just hangs: http://lpaste.net/104894
09:35:04 <roconnor> vlads: for example: uncurry Let <$ reserved "let" <*> (bindingKind1 <|> bindingKind2) <*> ...
09:35:40 <Enigmagic> danilo2: lemme look
09:36:03 <SrPx> Someone just told me Haskell sucks and gave me an one liner argument: "data Person { name :: String } / data Car { name :: String }" to be fair, I kind of agree. How would you guys do that?
09:36:24 <roconnor> vlads: here bindingKind1 and bindingKind2 return a pair and they are defined using <×>.
09:37:00 <zomg> SrPx: there's a language extension to deal with it coming I think, plus if you put them into different modules you have qualified imports, or prefixed names.
09:37:09 <SrPx> She said: "I don't want to have to worry about clashing with other datatypes when creating a datatype." And that is, honestly, a very solid reasoning.
09:37:18 <geekosaur> yes, that's a longstanding wart
09:37:20 <zomg> Although to claim Haskell sucks because of that, it sounds like a pretty dumb claim tbh
09:37:22 <ReinH> If you insist on sharing the identifier, you can just use a typeclass.
09:37:28 <geekosaur> and there's an extension coming to help with it
09:37:39 <danilo2> Enigmagic: the problem is that IncoherentInstances choose ALWAYS the first instance even if more specific is defined
09:37:41 <ReinH> But that doesn't really scale
09:37:43 <Enigmagic> danilo2: ghci thinks it's looping on line 82 in your example: https://gist.github.com/NathanHowell/9f92a7c74cd453c72831
09:38:21 <danilo2> Enigmagic: it is right, look
09:38:26 <ReinH> That's a pretty strange argument though
09:38:51 <SrPx> I see
09:38:53 <SrPx> Thanks (:
09:39:01 <SrPx> Why won't Haskell follow Ocaml's module system?
09:39:05 <Dodek> SrPx: http://stackoverflow.com/questions/6922437/haskell-any-way-to-qualify-or-disambiguate-record-names
09:39:57 <danilo2> Enigmagic: Incoherent instances are working this way, that the line 105 (can be shortened to print(toPolar s p)" is hanging everything because, toPolar sp **always** calls the instance from line 78 even if there is defined more specific one, like in line 87 in this example!
09:40:24 <danilo2> Enigmagic: If we delete the Incohernet instance flag and throw away the "not working instance" the code works
09:40:30 <Enigmagic> danilo2: that's why they're called "incoherent instances" :-)
09:40:54 <vanila> roconnor, why not use a function name
09:41:02 <vanila> parsePair or something
09:41:41 <roconnor> vanila: zip is a standard prefix name for it, and that is okay.
09:41:57 <roconnor> vanila: it it really deserves to be infix.
09:42:02 <roconnor> I guess I could use `zip`
09:42:02 <vanila> ohh
09:42:04 <vanila> zip
09:42:16 <vanila> there's gotta be a unicode symbol that looks like a zip
09:42:31 <monochrom> there is one for zap. will it do? :)
09:42:33 <Enigmagic> danilo2: i've never had good luck with them.. i find it's better to either make it explicit (with a newtype wrapper) or define default method(s) on the typeclass
09:42:43 <danilo2> Enigmagic: heh :) I know, but is this even doable in Haskell? Can I make somehow such default instance? That if npo other is matched -we try to convert the thing to Cartesian coordinates and then try again ?
09:42:44 <roconnor> at least × isnt' to crazy into unicode land; it is iso-latin-1
09:43:03 <vanila> calling it `zip` is really nice, I think
09:44:24 <roconnor> does that mean Left x <|> Right y is called zap?
09:50:57 <Ainieco> hello
09:51:46 <Ainieco> any adiveces on how to eliminate that silly pattern http://lpaste.net/5417862164549468160 ? I have tons of that for other types
09:53:51 <Ainieco> "set *Lens (*Id : *s) *" and "foldl' (flip insert*) * *s" thesee parts are all over the place
09:55:46 <Ainieco> i could abstract these parts in separate functions but bascially these functions will require a lot of arguments and will not change pattern that pattern, i'll still have to define insetSingular insertPlural boilerplate
09:56:23 <Ainieco> is TH the only option?
09:56:43 <Enigmagic> danilo2: i'm trying something..
09:56:52 <glguy`> The other option is to only write two functions for insert parameterized on their lens es
09:57:03 <glguy`> And not bother naming all the combinations
09:57:46 <agibiansky> Question about dealing with multiple GHC versions: I have one module that effectively has different implementations for different versions. What's the best way to deal with this in your cabalized package? Use CPP?
09:57:53 <Ainieco> glguy`: could you please elaborate on that using my example on lpaste?
09:58:16 <Ainieco> i don't quite get how to parametrize it on lenses only because there other variables
09:58:42 <hpc> agibiansky: have multiple source folders with just that module in them, then the cabal file can do "if ghc x.x.x include source folder src-x.x.x"
09:58:58 <glguy`> add1 l x y = over (cons x) l y
09:58:59 <roconnor> Ainieco: first I would personally write insertMangers managers = adjust storeManagersLens (managerId <$> managers)
09:59:34 <hpc> agibiansky: i always have to look up the syntax for it, use an existing package on hackage for reference
09:59:36 <roconnor> Ainieco: then maybe write insertManager manager = insertMangers [manager] if you really need it.
09:59:52 <roconnor> Ainieco: but I probably wouldn't bother
09:59:54 <agibiansky> hpc: Thanks, that's what I was hoping for. Do you know what packages might have something like that? If you don't off the top of your head I can find something
10:00:03 <glguy`> I'm on my phone so writing out coffee is tricky
10:00:05 <roconnor> Ainieco: so that gets rid of half your code; which is a good start.
10:00:26 <hpc> agibiansky: try one of the more system-y packages
10:00:33 <agibiansky> hpc: Alrighty, thanks
10:00:35 <hpc> agibiansky: the syntax should be the same for ghc versions and OS versions
10:01:11 <glguy`> Ainieco: check out over , it's the update version of set
10:01:37 <ReinH> insertOwners owners = storeOwnersLens <>~ owners
10:01:57 <roconnor> ReinH: you missed the ownerId bit
10:02:00 <ReinH> I did.
10:02:09 <ReinH> you can get that with a traversal though
10:02:40 <roconnor> insertOwners owners = storeOwnersLens <>~ (ownerId <$> owners)
10:02:48 <ReinH> or that
10:03:10 <Enigmagic> danilo2: i think the answer is no
10:03:14 <Ainieco> roconnor: that insertOwner not insertOwners :) because you're adding *one* ownerId to owners list :)
10:03:24 <Ainieco> and having that i still need foldl' bit
10:03:44 <roconnor> Ainieco: no no, I'm adding a whole list
10:03:49 <roconnor> let me make it more apparent
10:03:56 <ReinH> insertOwner owner = storeOwnersLens %~ cons (ownerId owner)
10:04:09 <roconnor> insertMangers managers = adjust storeManagersLens [managerId m | m <- managers]
10:04:17 <roconnor> or infixy
10:04:23 <roconnor> insertMangers managers = storeManagersLens <>~ [managerId m | m <- managers]
10:04:42 <ReinH> now use lenses for everything
10:04:55 <Ainieco> roconnor: ahh, thanks
10:05:37 <roconnor> Ainieco: I'm still thinking about the best way to deal with the assocaiting between storeFooLens and FooId
10:06:26 <ReinH> insertLensy x storeLens xLens = storeLens %~ cons (view xLens x)
10:07:03 <ReinH> insertManyLensy xs storeLens xLens = storeLens <>~ xs ^.. traverse . xLens
10:07:57 <ReinH> :t (<|~)
10:07:58 <lambdabot>     Not in scope: ‘<|~’
10:07:58 <lambdabot>     Perhaps you meant one of these:
10:07:58 <lambdabot>       ‘<|>’ (imported from Control.Applicative),
10:08:04 <ReinH> what the hell edwardk
10:08:09 <edwardk> ?
10:08:16 <ReinH> no <|~ operator?
10:08:20 <ReinH> :p
10:08:30 <edwardk> decided i had to stop somewhere
10:08:38 <edwardk> cale's trigger finger was getting itchy
10:08:41 <ReinH> hah
10:08:50 <edwardk> i feared for my life
10:08:52 <ReinH> but then you can have <<|~
10:08:56 <ReinH> and <<<|~
10:08:58 <ReinH> THINK ABOUT IT
10:09:03 <edwardk> that's actually why
10:09:08 <ReinH> hahaha
10:09:38 <edwardk> there are no operators other than <>~ that come with a < on the left of the ~ other than through the <op~ and <<op~ convention
10:09:49 <edwardk> <>~ is unambiguous because >~ doesn't make sense in this convention
10:10:04 <ReinH> Hmm.
10:10:33 <edwardk> but (|>) could exist as an operator, many people want it for (&), and (<|>~) would then be ambiguous
10:10:39 <glguy`> Lens 5 can move the operators into Control.Lens.Ugh along with dropping Aeson :-p
10:10:55 <edwardk> glguy`: you can import Control.Lens.Combinators today
10:10:58 <edwardk> =P
10:11:10 <glguy`> Yeah, but
10:11:27 <Ainieco> ReinH: that's cool!
10:11:41 <glguy`> That just means we're almost there!
10:11:57 <fread2282> how do I write an Arbitrary instance for my AST that doesn't generate infinite ASTs?
10:12:04 <edwardk> exiling aeson out to a support package is definitely an option though. i'll flip the free/either dep shortly, aeson is on a TODO list as soon as i can bring myself to accept the orphans
10:14:38 <roconnor> fread2282: I think you need to make use of sized
10:15:17 <heatsink> I'm using a design pattern where the derivation of some type classes is reflected at the value level.  The classes have a member that's a GADT value.  The GADT has one constructor per class instance, and the constructor holds the class context that was used to create the instance.
10:15:35 <heatsink> Is this a familiar pattern?
10:16:10 <heatsink> By pattern matching on the GADT value, I can determine which class instance I have.
10:19:24 <Horatius83> I'm trying to install snap and keep getting the error "Module 'Data.Scientific' does not export 'scientificBuilder'" which is causing aeson-0.7.0.3 to fail to install. Does anyone know how I might fix this?
10:20:28 <heatsink> Do you know which package that module is from?
10:21:11 <Horatius83> Data\Aeson\Encode.hs
10:21:17 <bergmark> Horatius83: install aeson 0.7.06 instead
10:21:22 <bergmark> 0.7.0.6*
10:21:42 <Horatius83> okay, I'll try that
10:22:01 <heatsink> It looks like that variable moved to a different module between scientific-0.2 and scientific-0.3
10:22:09 <bergmark> cabal install snap --constraint='aeson >= 0.7.0.6'
10:25:36 <Horatius83> that worked beautifully, thank you so much!
10:26:32 <Ainieco> can it have "simpler" type http://lpaste.net/104899 ?
10:26:58 <Ainieco> at least without "forall s t a b (f :: * -> *)." part :)
10:27:28 <Ainieco> enabling tons of extnesions to support it stabs me in a heart
10:29:26 <Ainieco> :t (. (<$>)) . (.) . <>~
10:29:27 <lambdabot> parse error on input ‘<>~’
10:29:31 <Ainieco> :t (. (<$>)) . (.) . (<>~)
10:29:33 <lambdabot> (Monoid (f b), Functor f) => ASetter s t (f b) (f b) -> (a -> b) -> f a -> s -> t
10:29:53 <Ainieco> hm, ghc told be "forall" version
10:30:01 <klrr_> what is homomorphism?
10:30:25 <Ainieco> or lambdabot just ommited forall part :/
10:30:54 <Twey> Ainieco: Leading foralls are implicit
10:31:14 <Twey> Ainieco: Unless you want to refer to the type variables in the definition of the function
10:31:39 <Twey> Or restrict the kind to one less general than the default
10:32:30 <Cale> klrr_: A homomorphism of what kind of structures?
10:33:14 <Cale> klrr_: The word "homomorphism" is used for many different kinds of structure-preserving transformations throughout mathematics, and is defined separately in each case.
10:34:08 <klrr_> oh, so the the morphisms that makes A isomorphic to B is homomorphisms?
10:34:28 <klrr_> or could it be used like that i mean
10:35:23 <Cale> klrr_: For example, given monoids M and N, a monoid homomorphism f: M -> N is a function such that f(1_M) = 1_N, and for each a and b in M, we have f(a * b) = f(a) * f(b) (where the multiplication on the left side is in M and on the right is in N)
10:36:04 <hcaulfield57> Does anyone know why I can't use positional parameters in HDBC when creating a table, it simply does not work.
10:36:15 <{AS}> Hi, is it possible to customise deriving i.e. for a large datatype ignore a field of specific type when deriving Eq
10:36:34 <klrr_> hmm
10:36:41 <hcaulfield57> AS in http://lpaste.net/104885
10:36:42 <Cale> Given graphs X and Y, a graph homomorphism f: X -> Y is a function between the vertex sets: f: V(X) -> V(Y) such that whenever x ~ y in X, we have f(x) ~ f(y) in Y.
10:37:04 <Cale> (where by x ~ y I mean that there is an edge between x and y)
10:37:28 <{AS}> something metacodeish for what I am askin for `deriving Eq except Bool`
10:37:35 <klrr_> lol i just had vertex introduced in last math test and i already forgot what it meant xD
10:38:17 <klrr_> oh it seems to mean a lot of things
10:38:24 <heatsink> {AS}: No.  We generally use template haskell for that kind of task.
10:38:37 <{AS}> heatsink: any example?
10:39:22 <klrr_> Cale: i dont quite understand, the monoid example isnt what you say about a and b just that hold one of the monoid lawws?
10:39:42 * hackagebot haskell-awk 1.1 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.1 (gelisam)
10:39:47 <klrr_> i cant see how its relevant to f(M_1) -> N_1
10:40:05 <klrr_> oh
10:40:12 <Ainieco> Twey: oh, how one can refer to type variables in definitaon of function? could you please provide an example?
10:40:22 <klrr_> nvm did not read the thing in prantheses sry
10:41:11 <heatsink> Hmm... I don't know where to find an example of using TH to generate class instances
10:41:20 <Twey> Ainieco: E.G. foo ∷ ∀ a. [a]; foo = [undefined ∷ a]  (with the ScopedTypeVariables extension)
10:41:55 <Ainieco> Twey: got it, thanks!
10:42:00 <{AS}> So I know that you usually can use a generics library like GHC.Generics
10:42:21 <{AS}> but I was wondering if there was a less tedious way :)
10:42:25 <Cale> klrr_: For example, the positive real numbers form a monoid under multiplication, say (R+,*) as do the real numbers under addition (R,+). There is a monoid homomorphism f: (R+,*) -> (R,+) which is a function such that for any positive real numbers x and y, we have f(x * y) = f(x) + f(y)
10:42:33 <Cale> klrr_: Can you think of such a function?
10:42:39 <nadirs> hello, in a cabal sandbox is there a way to hide globally installed packages? I've got some conflicts.
10:44:20 <bergmark> nadirs: when do you get these conflicts?
10:45:10 <klrr_> Cale: hmm id obviously but gonna try figure out some other
10:45:20 <Cale> id doesn't fit
10:45:29 <klrr_> oh
10:45:30 <nadirs> bergmark: when I run 'cabal install' cabal complaints that some "packages are likely to be broken by the reinstalls"
10:45:36 <klrr_> didn see + was on left side
10:45:46 <klrr_> ok this was a bit trickier
10:45:51 <heatsink> {AS}: I haven't written that kind of code myself.  I can't give you advice on it.
10:46:05 <{AS}> OK, thanks anyway
10:47:00 <nadirs> (by the way, the packages are uniplate, hlint and ghc-mod, and I'm currently trying to install "chrisdone/hl" in a sandbox on GHC-7.8)
10:47:16 <bergmark> nadirs: i'm not sure when a sandbox will reuse a dependency, but i think you can install that dependency explicitly in the sandbox and you should be fine
10:47:26 <klrr_> look like simple equation but i cant figure out a function :/
10:47:44 <Cale> klrr_: Have you studied logarithms?
10:47:44 <nadirs> bergmark: ok, I'll try --force-reinstalls then
10:47:53 <Cale> The logarithm is an example :)
10:48:23 <klrr_> Cale: oh cool, just got logarithms test last week :P
10:48:57 <klrr_> oh i can see, its simply the first logaritm law
10:49:09 <Cale> log(1) = 0, so it preserves the identities
10:49:29 <Cale> and for any positive real numbers x and y, we have log(x*y) = log(x) + log(y)
10:49:31 <bergmark> nadirs: then you will break some package
10:49:42 <klrr_> yup
10:50:05 <nadirs> bergmark: oh, I think I misunderstood your advice :P
10:50:13 <darthdeus> is there a way to lookup documentation in ghci?
10:50:21 <monochrom> no
10:51:05 <bergmark> nadirs: if it complains about foo breaking, do `cabal install mypkg foo'
10:51:31 <ReinH> nadirs: You should read http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
10:51:47 <monochrom> and also sicp.xhtml
10:52:09 <warpy> how do i get minute, hours, days etc from NominalDiffTime? I cant seem to find a function to do it
10:52:19 <monochrom> if foo=ghc, "cabal install mypkg ghc" is a dead end
10:52:34 <ReinH> monochrom: oh I didn't see you there ;)
10:52:44 <monochrom> I was hiding
10:52:48 <ReinH> successfully
10:53:11 <nadirs> thank you for the docs; I'll go read them :)
10:53:12 <monochrom> "captain, monochrom decloaking!"
10:53:54 <Ainieco> sorry for silly constant flow of questions but how to better abstract this pattern? http://lpaste.net/8681432810042425344
10:54:16 <darthdeus> also, why is it possible to do :info & but for :type i have to surround all operands with ( ) ?
10:55:11 <bergmark> darthdeus: :type accepts an exrpession and info just an identifier
10:55:30 <darthdeus> ah, right
10:56:11 <zomg> Ainieco: I guess you could write a function which accepts functions that pull the values out
10:56:16 <monochrom> warpy: NominalDiffTime is just one single number, standing for seconds.
10:56:39 <zomg> Ainieco: eg. `getValues globalOwners storeOwners store global`
10:57:19 <monochrom> :info accepts multiple identifiers. try ":info * + Show" some day
10:57:30 <warpy> monochrom: ya, is there a lib to convert it to mins, secs etc? essentially i want a System.Time.TimeDiff from NominalTimeDIff
10:57:46 <monochrom> I don't know of one
10:57:56 <monochrom> I would just divide by 60 myself
10:58:06 <warpy> and then by 3600
10:58:24 <warpy> and then by 86400
10:58:29 <warpy> i dont want to do that
10:59:08 <monochrom> System.Time doc says, "This library is deprecated'. I discourage pursuing it.
11:00:12 <paldepind> Haskell noob here, playing around with fibonaccis. Is it just me, or is: "fibs = 1 : 2 : fib 1 2 where fib a b = (a+b) : fib b (a+b)" a more straight forward way to generate the sequence than any of the methods presented at: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
11:00:33 <warpy> monochrom: yes, that is why i asking for an alternative
11:00:48 <warpy> i dont want everything from System.Time, just TimeDiff
11:01:02 <monochrom> "please look at Data.Time in the time package instead" is also on that page
11:01:13 <warpy> i can't understand why Data.Time does not have a TimeDiff like data structure
11:01:20 <monochrom> use Data.Time throughout. purely Data.Time.
11:01:32 <monochrom> it already has DiffTime and NominalDiffTime
11:01:45 <warpy> it is not user friendly
11:01:52 <warpy> i cant show number of seconds to users
11:02:25 <warpy> oh well, i found this http://hackage.haskell.org/package/friendly-time-0.3/
11:02:28 <monochrom> ok, pay me 2 bitcoins and I'll write the divisions for you
11:02:47 <warpy> monochrom: nah. someone else already did :)
11:03:58 <klrr_> what does "transitivity" mean? google gives me too many defintions for me to decide :/
11:04:04 <chrisdone> warpy: use this! http://lpaste.net/4533675926134718464
11:04:09 <Iceland_jack> klrr_: If you're looking for an intuition, isomorphisms are like perfect analogies and homomorphisms are potentially imperfect analogies
11:04:31 <Iceland_jack> where the kernel describes how imperfect they are: in a very vague sense
11:05:02 <warpy> chrisdone: thanks, exactly what i am looking for. though i'd expect it to be in a library and not on a paste
11:05:11 <monochrom> klrr_: that is a sign that it depends on the context. please give context.
11:05:20 <klrr_> okey sorry
11:05:20 <warpy> cant add pastes to cabal yet :)
11:05:40 <klrr_> http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category
11:05:51 <klrr_> the first exercise asks "Which of the above laws guarantees the transitivity of \leq?"
11:05:54 <chrisdone> warpy: it's in here http://hackage.haskell.org/package/data-extra-2.5.4/docs/Data-Time-Extra.html but it would be better if it were in Data.Time, if you could get it past the committee
11:06:05 <klrr_> im not quite sure what they mean by "trasnistivity" here
11:06:20 <monochrom> if x<=y and y<=z, then x<=z
11:06:22 <jmcarthur> klrr_: typically it's a property that allows you to compose some kinds of relations. if A->B and B->C then A->C.
11:06:53 <warpy> chrisdone: oh thanks! searching time on hackage gave to scores of libraries. i was just going through them looking for something like this
11:07:09 <klrr_> hmm okey
11:07:23 <chrisdone> warpy: i could add it to here http://hackage.haskell.org/package/formatting-3.1.0/docs/Formatting-Time.html
11:07:31 <chrisdone> which would be a decent place for such a function, i think
11:07:59 <warpy> oh wow! this library looks pretty useful
11:08:07 <klrr_> is a non-function morphism a non-total function?
11:08:24 <Iceland_jack> klrr_: No, it's just not a function
11:08:25 <warpy> chrisdone: i found this too http://hackage.haskell.org/package/friendly-time-0.3/
11:08:27 <klrr_> i dont quite understand what <= mean in terms of variables and not ordered stuff
11:08:43 <klrr_> i thought it mean less or equal than
11:08:49 <monochrom> yes, I mean it too
11:08:51 <Iceland_jack> klrr_: I would suggest getting a stronger foundation before learning category theory
11:09:09 <klrr_> meh
11:09:45 <klrr_> i wanna learn how to program in haskell properly :P
11:09:54 <monochrom> do you agree that "if x<=y and y<=z, then x<=z" is true of the real numbers?
11:09:55 <Iceland_jack> klrr_: Then why are you learning category theory?
11:10:26 <Iceland_jack> There is a path from Alice's house to Bob's house. There is a path from Bob's house to Carl's house.
11:10:26 <Iceland_jack> That implies that there is a path from Alice's house to Carl's house.
11:10:37 <Iceland_jack> 'having a path from' is a transitive relation
11:10:47 <klrr_> Iceland_jack: so i can "program categorically", which i think is seeing patterns and stuff so you can write better code
11:10:52 <nadirs> chrisdone: ciao, thank you for your quick response on the issue I opened in your "hl" project
11:11:02 <chrisdone> nadirs: hey. did it work?
11:11:11 <nadirs> I'm still having some headaches
11:11:17 <chrisdone> what like?
11:11:50 <Iceland_jack> klrr_: Is this just from that reddit post?
11:12:00 <Emilie18>  Hi! I give you some videos. I hope you like! http://bit.ly/1mWs6XW
11:12:04 <Iceland_jack> I would recommend doing other things
11:12:05 --- mode: ChanServ set +o monochrom
11:12:09 --- mode: monochrom set +b *!*@67.221.255.95
11:12:09 --- kick: Emilie18 was kicked by monochrom (Emilie18)
11:12:18 <klrr_> yes, but category termonlogy is everywhere so it seems try worthy
11:12:21 <chrisdone> monochrom: fastest banhammer in the west
11:12:37 <Iceland_jack> klrr_: That depends on what you call 'category terminology'
11:12:57 <Iceland_jack> 'Functor' is from category theory, but you don't need to know any category theory to use it
11:12:57 <nadirs> chrisdone: I've done "cabal install --dependencies-only --force-reinstalls" and then "cabal install" but it says "img" is not defined in src/HL/V/Home.hs so I couldn't compile hl
11:13:29 <chrisdone> nadirs: oh, that's okay -- i fixed that. do a git pull; git submodule update (or just run scripts/pull-build)
11:13:47 <nadirs> chrisdone: ah, nice, I'll do it right away then :)
11:13:51 <chrisdone> nadirs: \o/
11:13:54 <klrr_> Iceland_jack: but people seem to use it to program more effeciently, it just seems interesting and if it is also useful in programming the more interesting
11:14:30 <klrr_> also may i ask what a "stronger foundation" is more precisly? ive seen people claim the basics of category theory are easy
11:14:32 <SrPx> are record types considered a bad idea?
11:14:40 <chrisdone> srpx: depends on the use
11:14:45 <SrPx> chrisdone: yes?
11:14:50 <chrisdone> srpx: yes
11:14:58 <SrPx> chrisdone: like?
11:15:07 <chrisdone> records in sum types, for example, is delicate
11:15:14 <Iceland_jack> klrr_: The basics are easy but category theory is used to tie different parts of math together, if you don't know any of them all the exampls are going to be unhelpful
11:15:18 <nadirs> chrisdone: by the way in order to get cabal sandbox to work I had to delete the "hl.cabal" file (there are two), that's the correct thing to do right?
11:15:33 <Iceland_jack> The basics are also kind of useless depending on what you actually want to do
11:15:48 <SrPx> chrisdone: why?
11:15:49 <chrisdone> nadirs: right
11:16:50 <warpy> chrisdone: i found exact same util functions that i have in my projects in data-extra :)
11:16:54 <chrisdone> nadirs: bit hacky, but the solution is really to fix the tools, i guess (hsenv or cabal sandbox)
11:17:02 <chrisdone> warpy: hehe =)
11:17:05 <warpy> even the names are same ..
11:17:15 <chrisdone> srpx: well, data X = F { foo :: Int } | G { bar :: Char } leads to foo (x :: X) being partial
11:17:57 <SrPx> chrisdone: so they are much less solid algebraically ?
11:17:58 <nadirs> chrisdone: hsenv fix is ready, it just need to be released as 0.5 and updated in hackage. I think.
11:18:16 <klrr_> Iceland_jack: i dont know much math but would like to learn
11:18:19 <chrisdone> nadirs: right. so that's okay, should be fixed soonish
11:18:30 <chrisdone> nadirs: shall we bother the author about it?
11:18:47 <warpy> chrisdone: why is data-extra marked deprecated? what should i use instead of it
11:18:47 <nadirs> though, since cabal sandbox came out, some people say things like hsenv should be deprecated
11:19:00 <klrr_> Iceland_jack: i just meant, by foundation do you mean i can read it in some book or do i need to complete high school and then study univ to get a foundation?
11:19:02 <chrisdone> srpx: in the case of a sum-type, i suppose so
11:19:23 <Iceland_jack> klrr_: Learn some abstract algebra and high school mathematics first
11:19:39 <Iceland_jack> some logic as well
11:20:12 <klrr_> hmm okey
11:20:13 <chrisdone> warpy: because while it's a handy utility package, it's better to move the functions to the proper packages… but that's slow
11:20:15 <Iceland_jack> Category theory follows rather naturally from abstract algebra
11:20:23 <Iceland_jack> (well, at least categories do)
11:20:44 <warpy> chrisdone: so i copy paste what i require into my own project?
11:20:51 <chrisdone> nadirs: indeed -- i would be using cabal sandbox if it did everything hsenv does
11:21:36 <monochrom> IIRC, Lawvere's "conceptual mathematics" is the category theory intro with the least assumption about your math knowledge
11:22:05 <chrisdone> warpy: as you prefer, i've no strong feelings one way or the other
11:22:11 <klrr_> monochrom: okey, thanks
11:22:19 <Twey> monochrom: Moreso than ‘Category Theory for Computing Science’?
11:22:40 <klrr_> i read a little bit of that one
11:23:14 <monochrom> hence, it's also pretty slow paced, like Hofstadter's GEB, and so I forsake it.
11:23:43 <monochrom> yes
11:23:53 <Twey> Mm, interesting
11:24:43 <h_noob> I have a prog that is reading from some sensors with C ftns, that call ioctl.  Also it is reading from the serial port.  problem is, after the serial port read it hangs for 30secs before going again.
11:24:50 <h_noob> any clue why that would happen?
11:25:14 <chrisdone> h_noob: have you reproduced the behaviour with a pure C program?
11:25:43 <h_noob> nope...
11:25:44 <chrisdone> in the past i've found weird ffi behaviour i thought was the ghc runtime, was just my own stupidity, when i wrote the same code in C
11:26:42 <h_noob> I've been having a lot of problems - I was going to read from the serial port in another thread and post results back through an MVar.  But I get an error when spawning the thread.
11:27:41 --- mode: monochrom set -b *!*@67.221.255.95
11:27:43 <chrisdone> there're some tricky points about dealing with c from multiple threads
11:27:46 --- mode: monochrom set -o monochrom
11:28:04 <h_noob> I might just write another program to scan the serial port, and send the results to the FFI scan program through network messages.  assuming I can read those!
11:28:43 <monochrom> http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
11:29:05 <carter> h_noob: what ghc version and which mvar ops?
11:29:18 <carter> i think theres a bug or two in certain mvar ops in 7.8.2
11:29:22 <h_noob> ghc 7.4.1, on raspberry pi
11:29:34 <chrisdone> nadirs: so does it build?
11:29:41 <chrisdone> willitblend.jpg
11:29:50 <h_noob> I gave up on the mvar code and went with hReady instead, so I can keep looping around when the serial port isn't ready
11:29:57 <h_noob> that's the theory anyway
11:30:06 <carter> https://ghc.haskell.org/trac/ghc/ticket/9148#comment:3
11:30:07 <carter> ok
11:30:11 <carter> so doesn't impact you
11:30:40 <carter> arm is apparently tricky for concurrency anyways
11:30:52 <chrisdone> carter: why's that?
11:31:08 <carter> chrisdone: the memory ordering model is MUCH weaker than x86
11:31:27 <chrisdone> ahh
11:32:08 <carter> http://en.wikipedia.org/wiki/Memory_ordering has a good table
11:33:07 <carter> notice how there very very few reordings on x86
11:33:14 <chrisdone> mhm
11:33:27 <carter> so its easy to write stuff that works by accident on x86
11:33:31 <carter> but harder elsewhere
11:34:12 <Iceland_jack> carter: I like to think most of my stuff works like that :)
11:35:34 <carter> hypotehtically, if you wanted the "fastest" thing possible, you'd work  cpu with a super relaxed memory model, and use special primitives with stronger synchronization guarantees selectively
11:35:45 <carter> but then you'd have pretty confusing bugs pretty easily
11:35:53 <carter> because you'd basically be writing distributed systems software
11:36:23 <carter> so modern CPUs are like mini distributed systems
11:40:02 <Hodapp> hmm.... http://queue.acm.org/detail.cfm?id=2611829
11:52:37 <lennartj> when `readTQueue :: TQueue a -> STM a` says that it retries if the queue is empty, does that roughly mean the same thing as `readChan :: Chan a -> IO a` blocking until something is available in the queue?
11:54:11 <lennartj> as in, will the scheduler put the thread that's trying to read from the empty STM queue to sleep and wake it up when something is available?
11:54:20 <Polarina> lennartj, roughly, yes.
11:56:12 <c_wraith> lennartj: "retry" has a precise meaning in STM...  It means it uses STM's retry combinator.
11:56:33 <c_wraith> lennartj: And that combinator has well-defined semantics
11:57:05 <monochrom> if you add "atomically", then you get equivalence. "atomically (readTQueue x)" behaves as "readChan x".
11:57:36 <monochrom> however, the interesting thing about STM is that you can have composite things inside one "atomically"
11:58:27 <monochrom> "atomically (readTQueue x >> writeTMVar y)" has no equivalent counterparts in MVar
11:59:21 <monochrom> "atomically (readTQueue x `orElse` readTMVar y)" does in one go something you need two threads in the MVar scheme
11:59:51 * hackagebot Spock 0.5.1.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.5.1.0 (AlexanderThiemann)
11:59:52 <monochrom> especially for the orElse example, you really need to know about retry
12:00:21 <ReinH> Now would be a good time to plug SimonM's book perhaps
12:00:35 <Iceland_jack> is there a SimonM_?
12:00:39 <lennartj> right, I understand the atomicity
12:00:50 <lennartj> okay, thanks all!
12:00:53 <ReinH> Iceland_jack: Yes, but it doesn't produce anything interesting
12:00:56 <Iceland_jack> lol
12:01:07 <ReinH> Unless you consider the side effects, of course
12:01:08 <lennartj> just wanted to make sure it makes the scheduler do what I expect
12:02:21 <monochrom> retry leads to blocking, yes
12:04:40 <toonces> question: aren't enum and ord pretty much the same?
12:05:03 <toonces> if you have pred and succ, you can define an ordering
12:06:12 <monochrom> carter: I am evil. I like very weak memory models. I like breaking people's 1980s assumptions. I like breaking people's determinacy assumptions. A lot of determinacy guarantees that people demand are unnecessary and unreasonable.
12:06:16 <Ainieco> are there statefull implementation of removing something from list, i.e, it returns (removedElement, newList)?
12:07:28 <monochrom> but I come from the "you're supposed to prove your program correct anyway" angle. I see that if you only know how to test, you want slow, deterministic, serialized computers
12:07:31 <carter> Iceland_jack: he's jaffacake on #ghc
12:07:40 <nadirs> chrisdone: hey, sorry I was dining. I think I'm ignorant on submodules, should I pull/clone `senza` somehow?
12:08:02 <chrisdone> nadirs: you can just run: git submodule init; git submodule update
12:08:06 <carter> monochrom: all the permutations!
12:08:08 <chrisdone> nadirs: it will automatically pull the right version
12:08:08 <Iceland_jack> carter: I was comparing the nick to monadic functions ending in M :)
12:08:24 <chrisdone> nadirs: check out the source of scripts/pull-build
12:08:46 <monochrom> Ainieco: I wrote one myself when I needed it
12:09:02 <monochrom> I needed it only twice
12:09:12 <carter> theres very evil ways to do it that I wont tell you about
12:09:13 <Ainieco> monochrom: and you haven't uploaded it to hackage? :)
12:09:19 <carter> and require writitng CMM
12:09:23 <carter> you never wanna write cmm :)
12:09:36 <monochrom> and in both cases, I should use Data.Set/Map anyway
12:11:23 <chrisdone> agh, having to write \" everywhere in haddock
12:11:39 <chrisdone> amazing that people are confused when i say i hate writing haddock
12:11:48 <nadirs> (chrisdone: it complained the lack of "<package>.cabal" file because it didn't have the packageat all)
12:12:00 <nadirs> now I'm forcing reinstalls again
12:12:14 <chrisdone> nadirs: did you do the cabal invocation in pull-build?
12:12:22 <chrisdone> cabal install . submodules/senza
12:12:35 <chrisdone> i.e. compile this package, plus the submodule in one go
12:12:40 <nadirs> I did both `./script/pull-build` and single commands
12:12:58 <chrisdone> ah, because you deleted hl.cabal
12:13:08 <chrisdone> maybe move hl-7.8.cabal to hl.cabal?
12:13:17 <monochrom> chrisdone: consider using “ and ” :)
12:13:18 <chrisdone> i guess it doesn't matter?
12:13:33 <chrisdone> monochrom: you mean haddock can actually do unicode?
12:13:38 <nadirs> "<chrisdone> maybe move hl-7.8.cabal to hl.cabal?" I did
12:13:47 <chrisdone> nadirs: so what's the current error?
12:13:49 <monochrom> I haven't really tried. I think the recent one can
12:14:04 <monochrom> so, just "consider" it :)
12:14:17 <chrisdone> sure. your request is 100% reasonble
12:14:22 <chrisdone> but haddock is more devious than that
12:14:30 <chrisdone> @
12:14:31 <chrisdone> putStrLn "Hello!"
12:14:31 <chrisdone> @
12:14:33 <chrisdone> guess what you get? =)
12:14:51 <Ainieco> is there a function which will return list without element at certain index?
12:14:56 <monochrom> is it better if you used > ?
12:15:00 <nadirs> chrisdone: no error hopefully. Now it's re-compiling all the libraries. Fingers crossed :)
12:15:20 <chrisdone> monochrom: let me try
12:15:23 <chrisdone> nadirs: hurrah =)
12:15:44 <chrisdone> monochrom: with >, it outputs nothing at all in the docs page for my whole module header
12:15:52 <Philonous> chrisdone, Why u no in #haskell-emacs any more :(
12:15:58 * chrisdone returns to his original position about hating haddock
12:16:11 <monochrom> I see
12:16:17 <chrisdone> philonous: lol, i'll join
12:17:10 <Ainieco> anyone?
12:17:32 <chrisdone> ainieco: filter (/=i) . zip [0..]
12:17:35 <chrisdone> uh
12:17:44 <chrisdone> ainieco: map snd . filter ((/=i).fst) . zip [0..]
12:17:56 <chrisdone> there isn't one in data.list, anyway
12:18:39 <nadirs> chrisdone: it works! Thank you so much
12:19:08 <chrisdone> yatta! \o/
12:19:42 <nadirs> chrisdone: (now I can do my teeny tiny edit on function signatures order in "src/HL/V.hs")
12:19:49 <Ainieco> chrisdone: thanks
12:20:23 <nadirs> chrisdone: unless that's on purpose?
12:20:52 <chrisdone> nadirs: huh?
12:21:25 <nadirs> chrisdone: https://github.com/chrisdone/hl/blob/master/src/HL/V.hs some functions' signatures follow the body of the functions
12:21:58 <chrisdone> oh that, yeah that's unintentional. botched keyboard macro
12:22:26 <nadirs> chrisdone: I know I should do something more meaningful but I hope this helps me getting more into understanding the whole project :P
12:22:37 <chrisdone> lol, yeah, you got it to compile at least
12:22:46 <nadirs> haha, indeed
12:28:39 <absence> how is -rtsopts used? i'm trying ghc -rtsopts -O2 file.hs, but the resulting executable says "Most RTS options are disabled. Link with -rtsopts to enable them."
12:28:56 <carter> if you don't need rtsops you don't need it :)
12:29:10 <carter> its for eg tuning the GC settings and stuff
12:29:20 <absence> that's exactly what i wanted to do
12:29:54 * hackagebot formatting 3.1.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.1.1 (ChrisDone)
12:29:56 * hackagebot formatting 3.1.2 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.1.2 (ChrisDone)
12:30:14 <absence> do i have to pass the option in a different way for the linker to see it?
12:30:16 <chrisdone> warpy: i added a `diff` formatter to Formatting.Time, fwiw
12:30:25 <carter> absence: are you building the executable or a lib?
12:30:31 <chrisdone> rewriting to use formatting instead of printf turned out equally nice, but type-safe =) http://lpaste.net/104904
12:30:35 <absence> carter: executable
12:30:41 <carter> huh
12:30:50 <carter> try giving the flag  after the file?
12:30:59 * carter is a bit rusty
12:31:05 <absence> carter: already tried, doesn't work
12:31:09 * benzrf oils carter 
12:31:16 <carter> absence: @lpaste the fucker
12:31:25 <carter> benzrf: i've not had a professional massage in ages
12:31:30 <carter>  or ever
12:31:34 <absence> carter: what, the source code?
12:31:38 <carter> yes
12:31:47 <carter> or a mini file that is your strawman binary
12:31:49 <chrisdone> carter: have you ever had an unprofessional massage?
12:31:56 <chrisdone> and complained to management?
12:31:58 <carter> hah
12:32:12 <warpy> chrisdone: i'll check it out. for now i am just using a modified version of your paste
12:32:24 <chrisdone> warpy: fair do's =)
12:34:43 <absence> carter: i can reproduce it with the following source code: main = return ()
12:34:55 * hackagebot formatting 3.1.3 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.1.3 (ChrisDone)
12:35:27 <carter> absence: oooo, delee the *.o and *.hi
12:35:32 <absence> carter: compiling with -rtsopts and then trying to run it with something like +RTS -H10M gives the rtsopts error
12:35:32 <carter> or force recompile
12:35:53 <hunt> a lot of my cabal packages arent visible to ghci... like Parsec and OpenGL
12:36:02 <hunt> what would be causing this? theyre definitely installed
12:36:13 <carter> ghc-pkg list
12:36:32 <hunt> you want me to paste it? i see them in it
12:36:36 <absence> carter: hah, that did the trick :D is there an option for forcing?
12:36:39 <carter> yes
12:36:42 <hunt> kk
12:36:52 <carter> -fforce$something$something
12:37:02 <carter> i think -fforcerecomp
12:37:03 <carter> but i could be wrong
12:37:06 <absence> carter: i'll look it up. thanks! :)
12:37:13 <hunt> http://lpaste.net/104906 carter
12:37:23 <carter> absence: this is why i cabalize everything and do cabal cleans reguarlly
12:37:33 <SrPx> also, what is the most elegant type theory today?
12:37:37 <carter> SrPx: 7
12:37:38 <chrisdone> unsafePerformRecompileEverythingBetterGetACoffee
12:37:39 <jomg> absence: there's -fforce-recomp
12:37:47 <carter> SrPx: theres no "most elegant"
12:37:50 <carter> they all have trade offs
12:38:00 <hunt> it appears everything thats in my personal ghc-pkg is invisible
12:38:01 <SrPx> for example?
12:38:06 <carter> all fo them
12:38:20 <SrPx> for example an tradeof? between system f and mltt, say?
12:38:23 <carter> hah
12:38:34 <carter> one has decidable equality
12:38:41 <carter> the other has extensional equality
12:38:47 <carter> SrPx: stop, zoom out, whats the goal
12:39:07 <carter> SrPx: google intentional vs extensional equality
12:39:13 <carter> and you can spend a lifetime just understanding that
12:39:14 <hunt> what would cause packages in my .ghc / .cabal to not be visible to ghci
12:39:18 <hunt> ghc sees them fine
12:39:22 <carter> hunt: you importing it wrong
12:39:23 <carter> ?
12:39:28 <carter> what os?
12:39:34 <hunt> ubuntu 14.04
12:39:37 <carter> hunt: OOOOO
12:39:40 <hunt> importing it wrong in ghci?
12:39:50 <carter> hunt: do you have an old ~/.cabal/config?
12:39:56 <carter> i bet thats the case
12:40:03 <carter> if you're using 7.8
12:40:08 <benzrf> so
12:40:13 <hunt> carter: not that i know of... im pretty sure this is a fresh install of the entire ecosystem
12:40:14 <benzrf> the monad laws deal with extensional equality?
12:40:20 <benzrf> and not intensional?
12:40:26 <hunt> carter: i dont have any additions to my path though if that might cause it
12:40:28 <carter> hunt: what cabal --version
12:40:35 <geardev> I'm playing with Haskell
12:40:40 <SrPx> carter: but I only have one lifetime
12:40:41 <geardev> let f x = takeWhile x < 2
12:40:43 <hunt> carter: 1.16... im embarassed
12:40:46 <geardev> let a = [1,2,3]
12:40:47 <carter> hunt: yup
12:40:50 <carter> ok
12:40:56 <geardev> let b = f a
12:40:57 <carter> 1) cabal install cabal-install
12:41:08 <carter> 2) add ~/.cabal/bin to your path
12:41:10 <geardev> Couln't match expected tye `a0 -> Bool' with actual type `[Integer]'
12:41:17 <geardev> > :t takeWhile
12:41:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:41:20 <carter> 3) open a new terminal window, rm ~/.cabal/config
12:41:24 <geardev> :t takeWhile
12:41:25 <carter> 4) cabal update
12:41:26 <lambdabot> (a -> Bool) -> [a] -> [a]
12:41:33 <jomg> geardev: you probably want to parenthesise x < 2
12:41:42 <carter> 5) rm -rf ~/.ghc
12:41:47 <SrPx> carter: wait is not extensional equality just a name for function equality? so how can something have it if that is undecidable. you guys confuse me more than you should
12:41:48 <carter> 6) reinstall that stuff
12:42:09 <hunt> carter: ok on it, this is going to take a while though. thanks
12:42:13 <jomg> geardev: your f is identical to (takeWhile x) < 2
12:42:16 <carter> hunt: nah, only step 6 will
12:42:33 <geardev> let f x = takeWhile (x < 2) results in another error
12:42:34 <hunt> carter: im missing some packages i need for cabal install cabal-install so idk
12:42:44 <carter> hunt: ummm what do you mean
12:42:46 <geardev> Couldn't match expected type `a0 -> Bool' with actual type `Bool'
12:42:50 <geardev> Also, hi jomg
12:42:52 <hunt> which carter: it couldnt find zlib
12:42:54 <carter> oh
12:42:57 <hunt> im not sure which zlib to install
12:42:58 <geardev> hope you're having a nice weekend
12:43:04 <carter> sudo apt-get zlib-dev
12:43:05 <carter> or whatwever
12:43:16 <jomg> geardev: oh right, you'll just want takeWhile (< 2)
12:43:31 <carter> SrPx: try googling around, theres A LOT of writing in that topic
12:43:38 <SrPx> I am
12:43:40 <carter> and i'm not an expert nor do i know how to easily explain
12:43:42 <carter> :)
12:43:59 <geardev> jomg: Nice!
12:44:10 <geardev> let f x = takeWhile (< 2)
12:44:13 <carter> hunt: that fix it?
12:44:16 <geardev> let b = fa
12:44:30 <jomg> what will the parameter x be?
12:44:34 <hunt> carter: not quite, i havent figured out qwhich zlib to install as theres no obvious zlib-dev
12:44:34 <jomg> a list?
12:44:51 <carter> hunt: whatever is called zlib via apt get
12:44:52 <geardev> b -- <- results in no instance for (Show ([Integer] -> [Integer]))
12:45:02 <geardev> print b -- <- results in the same thing
12:45:07 <carter> there is a zlib or zlibdev
12:45:08 <carter> or whatever
12:45:24 <hunt> carter: yea theres just a lot of them
12:45:30 <carter> hunt: pick one
12:45:32 <carter> flip a coin
12:45:39 <jomg> geardev: i guess you want f to take a list and take elements as long as they're less than 2?
12:45:45 <carter> zlib1g-dev
12:45:47 <carter> or whatever
12:45:52 <hunt> that makes me uneasy
12:45:53 <hunt> but ok
12:46:30 <jomg> geardev: in that case you don't need to declare x as a function argument to f anymore, as you're not using it on the right hand side of the definition
12:46:35 <carter> hunt: why would it
12:46:51 <jomg> just "let f = takeWhile (< 2)"
12:46:52 <hunt> carter: im not sure if thats the standard zlib or not
12:46:58 <carter> doesn't mattter
12:47:00 <carter> any of them will work
12:47:08 <carter> its easy to uninstall
12:47:39 <carter> OR you could use the hvr ppa
12:47:45 <carter> @google hvr ppa multi ghc travis
12:47:46 <lambdabot> https://github.com/hvr/multi-ghc-travis
12:47:59 <carter> sudo add-apt-repository -y ppa:hvr/ghc
12:48:05 <carter>  sudo apt-get update
12:48:15 <carter> sudo apt-get install cabal-install-1.20
12:49:04 <geardev> jomg: my goodness, solutions in haskell, at least with lists so far, are so much terser than what i'm usually doing :)
12:49:47 <hunt> carter: ok im on to step 6
12:49:51 <jomg> geardev: solutions in haskell in general, i'd say
12:49:57 * hackagebot ripple-federation 0.2 - Utilities and types to work with the Ripple federation protocol  http://hackage.haskell.org/package/ripple-federation-0.2 (StephenWeber)
12:50:26 <absence> why isn't -rtsopts default? does it affect performance, or is it to keep users from tampering? executable size seems to be unchanged
12:50:55 <levi> I've been cranking out the C code at work in great quantity lately.  Working on Haskell code is a refreshing contrast.
12:51:04 <carter> absence: secrutiy
12:51:07 <carter> *security
12:51:48 <carter> https://ghc.haskell.org/trac/ghc/ticket/3910
12:52:04 <tdammers> "secrutiny"
12:54:16 <davnils> maybe it's possible to do priv. escalation? would be a cool POC.
12:55:18 <absence> carter: i can see why overwriting files would be bad, but you also need rtsopts to change e.g. default heap. can doing that be insecure too?
12:55:37 <hunt> carter: were all good now! thanks
12:56:11 <hunt> Question: Should i further my understanding of momnads before i start using Parsec? Parsec seems really really usefull and powerful but it also seems pretty mystical and massive to me
12:56:42 <hpc> hunt: it will still be both of those things even with a good understanding of Monad
12:56:52 <tdammers> hunt: if you want to understand how Parsec works under the hood, a bit of monad knowledge is required, but just for using it, you don't need that
12:57:09 <hunt> should i learn how it works?
12:57:13 <tdammers> not yet, no
12:57:22 <hunt> ok, at what point do i do that
12:57:24 <tdammers> learn to use it first
12:57:27 <hunt> ah ok
12:57:33 <tdammers> then see if the inner workings interest you
12:57:33 <hunt> cool
12:57:44 <hunt> learning haskell is so awesome
12:58:00 <tdammers> (parser combinators are actually a pretty awesome approach, and not as magical as they seem, btw)
12:58:50 <benzrf> i once wrote a dsl in ruby for parsing, inspired by parsec :-D
12:58:55 <benzrf> it was absurdly nonperformant
13:00:02 <hunt> benzrf: like inefficient or nonproductive?
13:00:45 <Marquis> hello haskellers. i just installed a new version vector cabal package and now my code does not work. i get the following error: Couldn't match type `V.Vector Double'                   with `vector-0.10.9.1:Data.Vector.Unboxed.Base.Vector Double'     Expected type: [Point Int]       Actual type: [(V.Vector Double, Int)]
13:01:11 <jle`> > let fac n = ala Endo foldMap (map (*) [1..n]) 1 in fac 50
13:01:14 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
13:01:24 <benzrf> hunt: inefficient
13:01:27 <dmj`> @typ ala
13:01:30 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
13:01:33 <benzrf> :t Endo
13:01:35 <lambdabot> (a -> a) -> Endo a
13:01:45 <benzrf> :t foldMap
13:01:46 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:01:52 <Marquis> option one: how do i uninstall a cabal package and install an earlier version. Option two: How do i fix the code? I just importet Data.Vector.Unboxed in that part of Code
13:01:56 <Iceland_jack> :t ala Endo foldMap
13:01:57 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
13:02:13 <vanila> > let fac n = product [1..n] in fac 50 -- without ``Lens''
13:02:15 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
13:02:24 <Iceland_jack> lens?
13:02:43 <davnils> Marquis: the old version still exists. just do "ghc-pkg unregister vector-..."
13:02:55 <benzrf> the hell does ala do anyway
13:03:04 <roconnor> @src ala
13:03:04 <Iceland_jack> avoids newtype wrapping
13:03:05 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:03:18 <Iceland_jack> http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
13:03:23 <merijn> Iceland_jack: Wrong ala
13:03:32 <merijn> Iceland_jack: This one is from lens
13:03:32 <Iceland_jack> oh is it?
13:03:36 <Iceland_jack> ah my bad
13:04:24 <jle`> i think they both work the same way though
13:04:26 <Iceland_jack> Are you sure though? the type looks like it's from McBride's
13:05:43 <jle`> hunt: there's that chalmers coursethat goes through building your own parser combinator framework; i really recommend it :)
13:06:53 <geardev> :t unzip3
13:06:54 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
13:07:16 <Iceland_jack> :t mapAndUnzipM
13:07:18 <lambdabot> Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
13:07:31 <geardev> > unzip3 [(1, "haskell", 'a')]
13:07:33 <lambdabot>  ([1],["haskell"],"a")
13:07:47 <geardev> > unzip3 [(1, "haskell", 'a'), ('b')]
13:07:49 <lambdabot>  Couldn't match expected type ‘(a,
13:07:49 <lambdabot>                                 [GHC.Types.Char],
13:07:49 <lambdabot>                                 GHC.Types.Char)’
13:07:50 <lambdabot>              with actual type ‘GHC.Types.Char’
13:07:58 <geardev> > unzip3 [(1, "haskell", 'a', ('b')]
13:08:00 <lambdabot>  <hint>:1:34: parse error on input ‘]’
13:08:08 <geardev> > unzip3 [(1, "haskell", 'a', ('b'))]
13:08:10 <lambdabot>  Couldn't match expected type ‘(a, b, c)’
13:08:10 <lambdabot>              with actual type ‘(t0,
13:08:10 <lambdabot>                                 [GHC.Types.Char],
13:08:10 <lambdabot>                                 GHC.Types.Char,
13:08:10 <lambdabot>                                 GHC.Types.Char)’
13:08:30 <vanila> > unzip4 [(1, "haskell", 'a', ('b'))]
13:08:32 <lambdabot>  ([1],["haskell"],"a","b")
13:08:37 <geardev> unzip3 really just wants a 3 tuple within an array, huh?
13:08:53 <carter> absence: you can build with --with-rtops or whatever
13:08:54 <jle`> geardev: list
13:08:59 <carter> or with with -rtsops
13:09:01 <geardev> jle`: thanks, my bad
13:09:04 <carter> point being, not a real problem
13:09:13 <jle`> but isn't that what the type signature implies?
13:09:45 <benzrf> :t zip3
13:09:46 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
13:09:48 <benzrf> hmm
13:09:58 <benzrf> > unzip [(1, 2), (3, 4)]
13:10:00 <lambdabot>  ([1,3],[2,4])
13:10:06 <absence> carter: sure, i was more curious about the reason rather than having an actual problem :)
13:10:17 <jle`> @check \xs -> xs == (unzip . uncurry zip) xs
13:10:19 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
13:10:19 <lambdabot>  ([],[()])
13:10:26 <benzrf> clearly to keep zip . unzip identity zip should take a tuple!!
13:10:46 <jle`> well uncurry zip does
13:10:55 <jle`> but apparently even that's not an identity
13:11:01 <benzrf> > uncurry zip ([],[()])
13:11:02 <lambdabot>  []
13:11:06 <Iceland_jack> jle`: the lengths must agree
13:11:10 <benzrf> aha
13:11:16 <Iceland_jack> for a generalized unzip/zip, fmap (const ()) must agree
13:11:50 <jle`> @check \(xs,ys) -> length xs /= lengh ys || xs == (unzip . uncurry zip) xs
13:11:52 <lambdabot>  Not in scope: ‘lengh’
13:11:52 <lambdabot>  Perhaps you meant one of these: ‘length’ (imported from Data.List), ‘Seq.len...
13:12:06 <Iceland_jack> jle`: you should prefer (==>)
13:12:12 <Iceland_jack> which discards tests that don't match
13:12:19 <Iceland_jack> @ty (==>)
13:12:20 <lambdabot> Testable prop => Bool -> prop -> Property
13:12:28 <jle`> oh neat
13:13:00 <jle`> @check \(xs,ys) -> length xs == lenth ys ==> xs == (unzip . uncurry zip) xs
13:13:00 <lambdabot>  : -1: -1:Ambiguous infix expression
13:13:01 <Iceland_jack> otherwise you can have
13:13:02 <Iceland_jack>     foo || ...
13:13:02 <Iceland_jack> and if foo is always True then it might give you 100% correct tests, even though you never checked '...'
13:13:50 <jle`> @check \(xs,ys) -> (length xs == length ys) ==> (xs == (unzip . uncurry zip) xs)
13:13:51 <lambdabot>  Couldn't match expected type ‘[a0]’ with actual type ‘([a2], [b0])’
13:13:52 <lambdabot>  Relevant bindings include xs :: [a0] (bound at <interactive>:1:17)Couldn't m...
13:13:58 <jle`> its ok i give up
13:14:05 <jle`> oh
13:14:08 <jle`> i still kept xs
13:14:10 <Iceland_jack> You can play with this in PM you know :)
13:14:18 <jle`> :)
13:14:20 <Iceland_jack> then use the final result in #haskell making you look smarter!
13:14:23 <tgeeky> jle`: everything that lambdabot does in chat, she does in PM too.
13:14:26 <geardev> what are the @check and @ty commands?
13:14:26 <tgeeky> exactly. what he said.
13:14:37 <tgeeky> it'll look like you knew what you were doing, all along!
13:14:55 <jle`> i don't need to convince you guys i'm smart, i only want to convince myself :'(
13:15:00 * jle` runs off crrying
13:15:05 <jle`> currying?
13:15:07 <Iceland_jack> jle`: Fake it till you make it
13:15:33 <dmj`> geardev: @typ is like ':t' in ghci, @check is quickCheck, me thinks
13:15:33 <dmj`>  
13:15:51 <tris_> hey chaps... whats the simplest means of choosing an item randomly from a list?
13:16:04 <benzrf> cur-rying
13:16:08 <johnw> huh, someone else was just asking that the other day
13:16:19 <benzrf> :t 3
13:16:20 <lambdabot> Num a => a
13:16:21 <jle`> @check \zs@(xs,ys) -> (length xs == length ys) ==> (zs == (unzip . uncurry zip) zs)
13:16:25 <lambdabot>  *** Gave up! Passed only 37 tests.
13:16:27 <benzrf> :t "foo"
13:16:29 <lambdabot> [Char]
13:16:33 <jle`> is there any way to make quickcheck smarter
13:16:35 <benzrf> :t (==>)
13:16:36 <lambdabot> Testable prop => Bool -> prop -> Property
13:16:44 <Iceland_jack> jle`: (yes, you drop the length of the longer list)
13:16:48 <Iceland_jack> *shorter
13:16:57 <jle`> you're a genius Iceland_jack
13:17:02 <Iceland_jack> tris_: did you look around much?
13:17:16 <jle`> tris_: you can ask me and i'll pick it for you :)
13:17:17 <Iceland_jack> A tiny bit of searching gave me http://rosettacode.org/wiki/Pick_random_element#Haskell
13:17:28 <davnils> tris_: fmap (list!!) . (`mod` (length list))) randomIO
13:17:30 <jle`> i have a hat and slips of paper and everything
13:17:40 <benzrf> list!!
13:17:50 <tris_> cheers chaps... I found something in Data.Random.Extras
13:17:51 <benzrf> davnils: that looks fishy
13:17:55 <tris_> but couldn't import it
13:18:02 <Iceland_jack> You need to install it
13:18:41 <davnils> sorry, grouping is wrong above.. fmap (shit) randomIO
13:18:53 <dmj`> let list = [1..10] in do { a <- randomRIO (0, length list - 1); print a }
13:18:54 <Iceland_jack> the most offensive fmap I've ever seen :)
13:19:10 <jle`> every once in a while i read a :) as an unmatched parentheses
13:19:17 <jle`> parenthesis
13:19:23 <tris_> cheers guys!
13:22:54 <jomg> jle`: i see so many smileys that that doesn't bother me, but unmatched ( is just annoying :P                            )
13:23:07 <Iceland_jack> ⸨what about this)
13:23:15 <jomg> aaaaahhh
13:23:24 <jomg> that's not a smiley
13:23:30 <jomg> also, box with question mark
13:24:24 <jomg> the thing about umatched closed parentheses is that there's no way you can match them later
13:24:51 <Iceland_jack> When I write in my chat ) Emacs tells me that it matches some previous (, showing the previous instance. This means that if there is a frowney face :( every smiley face :) 'closes' the frowny face and Emacs informs me
13:24:56 <Iceland_jack> I find that rather sweet
13:25:01 <hpc> haha
13:25:04 <benzrf> >emacs
13:25:07 <benzrf> heretic!
13:25:25 <Iceland_jack> benzrf: Every Haskeller I know uses Emacs, sans one or two people
13:25:32 * benzrf should probably switch to emacs + vim sim ar some point
13:25:37 <Iceland_jack> (plot twist: I only know two Haskellers)
13:25:40 <jomg> i should too
13:25:40 <benzrf> but he never wi;;
13:25:46 <benzrf> *will
13:26:06 <benzrf> VIM4LYFE EMACS LOSERS \o/
13:26:14 <Iceland_jack> benzrf: Have you tried Evil mode?
13:26:19 <sipa> wth is wrong with EDLIN?
13:26:25 <Iceland_jack> A friend of mine swears by it, I've never used it though
13:26:36 <jomg> i have attempted multiple times to learn either, but there's just so many commands and my attention span is so short :P
13:27:04 <benzrf> evil mode sounds like a cruddy sim!!
13:27:20 <merijn> This conversation is isomorphic to useless trolling
13:27:41 <jomg> merijn: we demand a constructive proof!
13:28:19 <tdammers> relevant: http://imgs.xkcd.com/comics/real_programmers.png
13:28:40 <benzrf> >implying anybody here hasnt seen that
13:29:17 <dmj`> > let list = [10..20] in randomRIO (0, length list - 1) >>= print . (list !!)
13:29:17 <dmj`>  
13:29:19 <lambdabot>  <IO ()>
13:29:46 <dmj`> forgot to index into the list :P
13:30:36 <Iceland_jack> > let list = [10..20] in list !! fst (randomR (0, length list - 1) (mkStdGen 42))
13:30:37 <lambdabot>  14
13:30:42 <Iceland_jack> > let list = [10..20] in list !! fst (randomR (0, length list - 1) (mkStdGen 43))
13:30:44 <lambdabot>  10
13:40:00 <wolftune> hi folks! Random issue: for some reason, even though the concepts all seem clear, Data Constructors are just not *clicking* for me as an idea the way that functions and even monads do…
13:40:03 * hackagebot extensible-effects 1.7.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.7.1 (BenFoppa)
13:40:48 <benzrf> wolftune: a data constructor is a literal function
13:40:52 <Saizan> wolftune: look at church encodings
13:40:57 <dmj`> wolftune: do you mean understanding the algebra of algebraic data types?
13:40:58 <benzrf> wolftune: literals are expressions that result in themselves
13:41:08 <wolftune> ok
13:41:13 <benzrf> wolftune: "foo" is an expression, but it does not *reduce* to anything
13:41:26 <benzrf> wolftune: similarly, 'Foo bar baz' is an expression, but it does not *reduce* to anything
13:41:30 <benzrf> it's just Foo bar baz
13:41:46 <wolftune> so I guess, like to what degree can I *really* think of a data constructor *as* a function? is it *sorta* a function or *really* a function?
13:42:24 <sipa> it is really a function, in that it defines a symbol with a function type
13:42:32 <wolftune> ok
13:42:34 <sipa> it is not a procedure with associated code
13:42:57 <wolftune> so I can truly say "data constructors are a type of function" ? or rather perhaps "a kind of function" ?
13:43:11 <sipa> in Haskell's definition of functions, they are functions. period.
13:43:29 <wolftune> sipa: ok, but they are the data constructor kind?
13:43:58 <benzrf> wolftune: they are functions
13:44:03 <Saizan> data constructors are a subset of the functions (those taking arguments at least)
13:44:06 <benzrf> wolftune: they take arguments and return a result
13:44:12 <jle`> Just :: a -> Maybe a
13:44:14 <jle`> :t Just
13:44:15 <lambdabot> a -> Maybe a
13:44:16 <benzrf> wolftune: but the result is not a reduction, exactly
13:44:30 <wolftune> hmm
13:44:35 <sipa> right, nullary constructors are just constants
13:44:43 <wolftune> I think I get how it works with Maybe
13:44:44 <jle`> but note that Just is more than just a function
13:44:46 <wolftune> but what about
13:44:49 <jle`> it's also a deconstructor
13:44:56 <wolftune> data Point = Point Double Double deriving Show
13:44:58 <jle`> > let (Just x) = Just 6 in x
13:45:00 <lambdabot>  6
13:45:06 <jle`> Point :: Double -> Double -> Point
13:45:16 <jle`> there is some confusion because you gave your constructor the same name as your type
13:45:24 <jle`> data Point = DoublePoint Double Double
13:45:34 <jle`> DoublePoint :: Double -> Double -> Point
13:46:03 <Nik05> is there a nub function that doesnt check the hole list but just the element next to it? so it assumes its working on a sorted list?
13:46:04 <hunt> Parsec question: If i have an extensive command list, does it make sense to categorize the commands and write parsers per category instead? perhaps use <|> on category parsers?
13:46:06 <wolftune> data Color = Red | Green | Blue
13:46:06 <jle`> this is typically considered bad practice, although base and many standard libraries are full of it >_>
13:46:18 <wolftune> how is that a function?
13:46:23 <jle`> Red :: Color
13:46:28 <benzrf> wolftune: there you have the haskell lack-of-distinction between values and 0-arg functions
13:46:31 <benzrf> :-)
13:46:40 <Nik05> isnt it the same benzrf ?
13:46:52 <benzrf> Nik05: precisely, 'lack-of-distinction'
13:46:56 <wolftune> benzrf: yeah, that seems to be my confusion
13:46:56 <johnw> at this point, see: http://conal.net/blog/posts/everything-is-a-function-in-haskell
13:47:21 <johnw> TL;DR everything is *not* a function
13:47:22 <Nik05> benzrf not just in haskell?
13:47:38 <hunt> similar: the only example ive seen of parser used a data type to return specific commadns that may carry arguments, is that logical when i have a large number of commands? does it make sense to have a single data type describing every command e=ven if it gets long>
13:47:41 <jle`> hunt: yes, although if you have lots of <|>'s, you can use one of those combinators that pick from one in a list
13:47:45 <jle`> i forgot what it's called
13:47:57 <hunt> jle` lol well i certainly dont know what its called :P
13:47:57 <johnw> asum?
13:48:23 <johnw> :t asum
13:48:24 <lambdabot>     Not in scope: ‘asum’
13:48:24 <lambdabot>     Perhaps you meant one of these:
13:48:24 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
13:48:28 <johnw> :t F.asum
13:48:30 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:48:36 <jle`> hunt: look for something [Parser a] -> Parser a
13:48:49 <johnw> where t is [] and f is Parser ;)
13:48:59 <jle`> :)
13:49:03 <hunt>  jle` could i just fold (<|>) ?
13:49:13 <johnw> hunt: that is the definition of asum ;)
13:49:18 <jle`> hunt: yes, because (<|>) forms a monoid, yaay
13:49:25 <hunt> hahaha yay!
13:49:29 <benzrf> :t asum
13:49:30 <lambdabot>     Not in scope: ‘asum’
13:49:30 <lambdabot>     Perhaps you meant one of these:
13:49:30 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
13:49:31 <jle`> but
13:49:33 <benzrf> :t F.asum
13:49:34 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:49:40 <benzrf> neat
13:49:59 <jle`> hunt: it's called choice
13:50:05 <jle`> in Text.Parsec.Combinator
13:50:14 <hunt> ah cool, thanks jle`
13:50:19 <jle`> but asum works too
13:50:43 <hcaulfield57> Could someone tell me why this needs FlexibleContexts? I don't even know what that means: http://lpaste.net/104907
13:50:57 <jle`> choice is just foldr (<|>) mzero, http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Combinator.html#choice
13:51:07 <benzrf> :t choice
13:51:08 <lambdabot>     Not in scope: ‘choice’
13:51:08 <lambdabot>     Perhaps you meant ‘choose’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
13:51:13 <jle`> should be mempty
13:51:15 <benzrf> :t choose
13:51:16 <lambdabot> Random a => (a, a) -> Gen a
13:51:21 <hunt> :t mzero
13:51:22 <johnw> hcaulfield57: I believe it's because you are using a multi param type class with one type specialized
13:51:22 <lambdabot> MonadPlus m => m a
13:51:27 <benzrf> > choose (1, 2)
13:51:30 <lambdabot>  No instance for (GHC.Show.Show (Test.QuickCheck.Gen.Gen a0))
13:51:30 <lambdabot>    arising from a use of ‘M436686766550201093310113.show_M4366867665502010933...
13:51:30 <lambdabot>    arising from a use of ‘e_112’
13:51:30 <lambdabot>  The type variable ‘a0’ is ambiguous
13:51:30 <lambdabot>  Note: there are several potential instances:
13:51:31 <jle`> hunt: mzero and mempty just mean "fail"
13:51:34 <benzrf> oh
13:51:35 <hpc> hcaulfield57: standard haskell is very restrictive with what you can put as a context
13:51:43 <hpc> hcaulfield57: which has the end result of what johnw says
13:51:43 <johnw> see https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
13:51:47 <hunt> awesome, i love this libarry
13:51:47 <jle`> it's the identity of mplus and <|>, respectively
13:51:58 <hpc> presumably the point is to make it easy on compiler implementors
13:52:04 <jle`> because mplus/<|> form monoid, and mzero and mempty are their identities
13:52:22 <jle`> ...if you are familiar with monoids
13:52:23 <darthdeus> is there a way to :unset -XOverloadedStrings in ghci?
13:52:30 <johnw> :set -XNoOverloadedStrings
13:52:32 <Iceland_jack> :set -XNo...
13:52:34 <hunt> jle` not really, but ill take note of this
13:52:39 <jle`> mplus and <|> are supposed to technically be synonymous, like pure/return
13:52:44 <darthdeus> awesome, thanks :)
13:52:50 <darthdeus> does that work for everything or just OverloadedStrings?
13:52:55 <johnw> pretty much anything
13:52:56 <Iceland_jack> It works for most things
13:53:01 <Iceland_jack> there are some things that it doesn't work for
13:53:16 <hunt> where do i get the haskell linter for vim?
13:53:21 <jle`> darthdeus: everytension.  like -XNoMonomorphismRestriction and -XMonomorphismRestriction :)
13:53:29 <jle`> hunt: i use syntastic + ghc-mod
13:53:35 <darthdeus> hunt: syntastic + ghc-mod, though it sucks
13:53:39 <darthdeus> jle`: thanks :)
13:53:58 <darthdeus> jle`: how do you work around waiting 5 seconds every time you save with syntastic+ghc-mod?
13:54:06 <hunt> it sucks? whaat
13:54:08 <jle`> hunt: monoids are apretty useful thing to be familiar with, and i recommend just looking into them if you ever have a few minutes :)
13:54:14 <jle`> you'll start seeing the pattern show up literally everywhere
13:54:19 <hcaulfield57> It's because it's a multi parameter typeclass?
13:54:31 <darthdeus> hunt: ghc-mod can be pretty slow in vim, because it parses the whole project every time you save a file, but there's nothing better really
13:54:32 <jle`> darthdeus: ehh idk :|
13:54:34 <hunt> jle` idk why but i cant get up the interest to actually learn about it, i think its just intimidating large
13:54:46 <jle`> hunt: not really, it's like...less than a minute
13:54:52 <darthdeus> jle`: i'm actually trying to get ghc-mod to run on the background the first time it's invoked, to avoid this issue :\
13:54:57 <jle`> like literally
13:54:59 <hunt> less than a minute! thats not fast
13:55:20 <jle`> monoids are things you can "combine" associatively.   that have an identity
13:55:28 <jle`> like Int and (+)
13:55:38 <jle`> (1 + 2) + 3
13:55:46 <jle`> 1 + (2 + 3)
13:55:48 <jle`> are the same
13:55:51 <jle`> and the identity is 0
13:56:00 <jle`> 1 + 0 = 1, 0 + 1 = 1
13:56:19 <darthdeus> when i was trying to learn monoids i thought of them as things that can be smashed together into one :P
13:56:28 <jle`> the key is that you have (+) :: Int -> Int -> Int
13:56:32 <jle`> (+) is an "int sqahser"
13:56:34 <johnw> Haskell's monoids have probably done more to teach some abstract algebra to the world than anything I've seen :)
13:56:40 <jle`> squasher
13:56:50 <Iceland_jack> johnw: Indeed!
13:56:53 <jle`> also, Int and (*) also form a Monoid, with 1 as the identity
13:56:54 <johnw> monoids can also be "selectors", aka Last
13:57:08 <Iceland_jack> Same as cryptography for certain parts of number theory
13:57:22 <jle`> hunt: can you think of "Bool sqahsers", and what the identity would be?
13:57:30 <Philonous> johnw, I'm always surprised. Aren't monoids first-semester stuff for any techy/mathy/engineering-y discipline out there?
13:57:33 <hunt> || and True
13:57:34 <hunt> no
13:57:35 <hunt> wait
13:57:37 <hunt> || and false
13:57:41 <hunt>  && and True
13:57:44 <Iceland_jack> Philonous: Not everywhere
13:57:47 <jle`> yea
13:57:51 <jle`> cool, you got monoids down, good job
13:57:53 <johnw> Philonous: called as "monoids" per se?  I don't know
13:57:57 <hcaulfield57> I don't think it doesnt work because of the multiparmeters.
13:58:00 <hunt> so how do i use this knowledge?
13:58:11 <jle`> (<|>) is a Parser squasher
13:58:12 <hunt> jle` also that was surprisingly straightforward
13:58:35 <jle`> and mzero/mempty (all synonyms) is the identity
13:59:00 <jle`> well, after a while with working with several monoids, you can start seeing general patterns in their usage and understandig
13:59:00 <hunt>  doesnt <|> have to be redefined for other monoids though, like when its used with Maybe
13:59:06 <hunt> wait
13:59:19 <hunt> does it automatically work because Maybe defines mempty in its monad implementation?
13:59:27 <jle`> and then when you encounter a new one...then BAM, all of your previously acquired intuition works
13:59:33 <jle`> about how things behave
13:59:35 <Philonous> hunt, Monoid implementation, but yes
13:59:40 <hunt> hollllly shiiiiit
13:59:50 <jle`> Maybe's default Monoid instance is different than its <|> instance
13:59:57 <jle`> because maybe can be a monoid in serval ways
14:00:08 <jle`> its <|> represents a "choice" kinda thing
14:00:16 <jle`> its <> represents a semigroup lifting kinda thing
14:00:19 <hunt> yea i had handrolled my own parser with it
14:00:25 <benzrf> edwardk sez: http://stackoverflow.com/a/10168111
14:00:26 <hunt> im making the switch now
14:00:33 <hcaulfield57> Okay, I think you need FlexibleContexts to use a type parameter from a class constraint as an argument to a type
14:01:03 <jle`> anyways, it's the kind of knowlegedge that lets you say "well, choice :: [Parser a] -> Parser a isn't magic, it's just foldr (<|>) mempty"
14:01:31 <hunt> jle` i cant wait till i understand the rest of parsec :P
14:01:47 <jomg> jle`: yea, the most obvious use for this stuff is making you look smart :)
14:01:51 <hcaulfield57> Parsec is pretty awesome,
14:01:52 <hunt> hahaha
14:01:54 <hunt> jomg
14:02:02 <johnw> hcaulfield57: I don't think that's what it is for
14:02:11 <jle`> i think the key is the intuition
14:02:12 <johnw> hcaulfield57: you can always use a type parameter from a class constraint as an argument to a type
14:02:15 <johnw> Monoid a => [a]
14:02:18 <johnw> doesn't require FlexibleContexts
14:02:29 <jle`> where you can apply the wealth of knowledge and intuition you've gleamed from another context
14:02:33 <jle`> and instantly apply all of it to a new one
14:02:37 <johnw> Monoid [a] => [a], that would require it
14:02:49 <hunt> jle` nice use of gleam
14:02:54 <hcaulfield57> johnw: Oh yea that's right
14:03:10 <ReinH> jle`: *gleaned*
14:03:11 <hcaulfield57> I'm not smart enough to understand the page explaining the extension.
14:03:19 <jle`> ReinH: :|
14:03:26 <jle`> really? this whole time?
14:03:26 <hunt> jle` agreed i havent really gotten around that bend of life yet tbh
14:03:29 <jomg> johnw: so does that mean that you need FlexibleContexts everytime you're not using the type variables directly, but in a type constructor?
14:03:30 <ReinH> gleam means to shine brightly, especially with reflected light
14:03:45 <jle`> this is worse than me catching my friend say "mute point"
14:03:48 <ReinH> glean means to extract information
14:03:48 <jomg> (within the context, that is)
14:03:59 <johnw> jomg: example?
14:04:25 <Iceland_jack> hcaulfield57: 'not smart enough' or just lacking some specific knowledge? :) don't knock yourself down
14:04:27 <hunt> i prefer the original meaning, jle` , that my knowledge has shined brightly frmo the other contexts of life
14:04:36 <hunt> jle`: overflowing into  haskel
14:04:38 <hunt> l
14:04:47 <jle`> :)
14:04:47 <jomg> johnw: something of the general pattern (Foo (Constr a)) => ...
14:04:54 <jle`> that's what i meant of course
14:05:02 <hunt> lol
14:05:09 <hcaulfield57> Iceland_jack: Okay haha, always a learning curve with Haskell
14:05:12 <jle`> ReinH is just looking for people to troll to procrastinate from finally releasing that next HaskellCast already
14:05:23 <jesyspa> I'm using the bound package and have an AST datatype E parametrised over the identifier type.  E is a monad.  I'd now like to make a (T, E a) type for type-annotated expressions and use that instead.  However, this by itself isn't a monad.  But if I have a suitable state monad S, I can make functions a -> S (T, E a) and S (T, E a) -> (a -> S (T, E b)) -> S (T, E b).  What's my best bet for talking this into a monad?  Or should I try some ...
14:05:28 <jesyspa> ... other path?
14:05:31 <ReinH> jle`: :p
14:05:40 <davnils> yeah, what's up with that :)
14:05:45 <Iceland_jack> hcaulfield57: “Sucking at something is the first step to becoming sorta good at something.”
14:05:57 <benzrf> Iceland_jack: adventure-five o/
14:06:03 <Iceland_jack> o/
14:06:11 <Iceland_jack> Algebraic!
14:06:49 <jle`> hunt: i recommend the Week 4 slides/lectures from here http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
14:06:49 <benzrf> Monadic!
14:06:58 <Iceland_jack> Functorial!
14:07:03 <benzrf> Iceland_jack: i previously mentioned in here
14:07:43 <jle`> hunt: they go over implementing a parser combinator library from scratch with very similar interface to Parsec
14:07:44 <benzrf> Iceland_jack: what if a red goo monster eats finn, then a blue goo monster eats the first one and turns purple, then finn cuts his way out and yells 'MONADIC'
14:07:48 <benzrf> :-D
14:08:05 <Iceland_jack> hah
14:08:12 <jle`> almost an identcal API, with the same semantics except for implicit backtracking
14:08:16 <hunt> jle`: alright im trying to find a tab to keep that in while i implement my parsec so i can check it out later
14:08:21 <Iceland_jack> . o O ( do we need a Haskell cartoon… )
14:08:26 <jle`> benzrf: wouldn't that be comonadic
14:08:26 <Iceland_jack> Jointastic!
14:08:35 <benzrf> jle`: well, cutting out would be
14:08:42 <benzrf> but the monadic is in reference to join
14:08:52 <benzrf> cutting out breaks the metaphor :-(
14:09:10 <jle`> cutting out is like extend and extract
14:09:20 <jle`> er, being eaten and cutting out
14:09:28 <hcaulfield57> Yea, I'm just not getting why it doesn't work.
14:09:30 <benzrf> no, being eaten is more like return
14:09:47 <hcaulfield57> Oh wait
14:09:49 <benzrf> monster :: GooMonster Human
14:09:53 <Iceland_jack> (an another monad analogy was born..)
14:10:00 <Iceland_jack> *and
14:10:06 <benzrf> return :: Human -> GooMonster Human
14:10:13 <jle`> there is already a Monads are monsters somewhere....
14:10:16 <geardev> Why would you ever use cabal configure immediately after doing `cabal init`
14:10:20 <geardev> wouldn't you need some files to build first?
14:10:21 <hcaulfield57> Convertible a SqlValue, the a can't be taken out of it's context because its in a context with SqlValue?
14:10:22 <benzrf> lol
14:10:32 <jle`> ugh just thinking about the hundreds of monad analogy tutorials i read during my first couple omnths of haskell
14:10:42 <jle`> i wonder how i ever understood anything
14:10:44 <benzrf> oh boy
14:10:47 <ReinH> o_O
14:10:55 <benzrf> monad analogies!!!
14:10:58 <hcaulfield57> Is that correct?
14:11:21 <wolftune> I guess I'm lucky I came later
14:12:20 <mbrock> I remember a long car ride in 2005, excitedly explaining to my brother how a monad is just like a roll of kitchen paper that you can bind up with other kitchen paper rolls using duct tape, or something
14:12:37 <mbrock> like yeah I finally got this, man, it's just like kitchen paper rolls everywhere
14:13:05 <Iceland_jack> I don't want to think what unsafePerformIO is in that analogy..
14:13:15 <benzrf> mbrock: lol
14:13:21 <wolftune> I just read through (and greatly edited and improved) the Wikibook, and everything about Monads was very clear. Then in the talk page there's like 7-year-old discussion about someone complaining when others removed the "nuclear waste metaphor"… I have no idea what that was. I didn't actually read the history. Sounds bizarre.
14:13:48 <benzrf> wolftune: i remember hearing about a GREAT monad tutorial analogising them to spacesuits
14:14:02 <benzrf> but then it got replaced with someth ing to do with nuclear waste containers
14:14:19 <hcaulfield57> benzrf: Because normal waste containers couldn't explain it.
14:14:29 <mbrock> I always thought liftM was very much akin to a jetpack
14:14:32 <geardev> the the food analogies started pouring in
14:14:36 <benzrf> liftM?
14:14:37 <benzrf> why not fmap?
14:14:41 <wolftune> "the original version with the nuclear waste metaphor was by far the best tutorial I've ever seen" says someone…
14:14:59 <wolftune> "it gives only a superficial understanding of monads and doesn't help the reader to really "get" the point" says the reply
14:15:02 <geardev> Why would you ever use cabal configure immediately after doing `cabal init`
14:15:14 <geardev> and what's the difference between cabal sandbox and hsenv?
14:15:26 <jomg> oh my god, unsafePerformIO on nuclear waste containers... :P
14:15:38 <Arnob> Are haskell people the only ones that use monads?
14:15:42 <wolftune> "This book's value as a self-study material benefits hugely from such witty and well-written metaphors as in this article!" says the next reply
14:16:08 <Arnob> If monads are so useful, why aren't they more popular was one question I was asked recently?
14:16:09 <wolftune> thankfully, it looks like it's all buried in the history
14:16:10 <mbrock> then you get into a whole thing about the epistemology of abstract algebra, and someone brings up Wittgenstein, somebody brings out a bottle of wine, and it's yet another one of those nights
14:16:28 <benzrf> Arnob: because most languages prefer willy-nilly effects
14:16:32 <benzrf> mbrock: lol
14:16:36 <benzrf> @quote
14:16:36 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
14:16:38 <wolftune> what I read (and improved) was just something saying "Monads do the work of this type of computation…" and to me it was perfectly clear
14:16:38 <benzrf> hmm
14:16:46 <hcaulfield57> Okay, I'm not positive that's how they work
14:16:56 <benzrf> @quote add
14:16:56 <lambdabot> add says: qebab I tried Perl once, then it flattened a list I made
14:17:00 <benzrf> lame
14:17:04 <hcaulfield57> Oh wait got it.
14:17:07 <benzrf> @addquote
14:17:07 <lambdabot> Unknown command, try @list
14:17:11 <benzrf> @list
14:17:11 <lambdabot> What module?  Try @listmodules for some ideas.
14:17:12 <jesyspa> @help grab
14:17:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:17:15 <benzrf> lambdabot you are a butt
14:17:16 <jesyspa> Hmm.
14:17:17 <benzrf> @grab
14:17:17 <lambdabot> Unknown command, try @list
14:17:38 <Averell> remember
14:17:50 <transfuturist> @help list
14:17:51 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
14:18:05 <transfuturist> @listmodules
14:18:06 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
14:18:22 <jesyspa> @remember mbrock
14:18:23 <lambdabot> Incorrect arguments to quote
14:18:24 <johnw> Arnob: Haskell has some nice syntax for them, and we *have* to use them; other languages with rampant effects can express the same thing in a briefer fashion, albeit without the benefits of type safety/effect management that Monads convey.
14:18:27 <jesyspa> >.<
14:19:11 <mbrock> @help remember
14:19:11 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
14:19:16 <Iceland_jack> Haskell should really adopt idiom brackets or Idris's exlamations
14:19:25 <Iceland_jack>     !getLine ++ " " ++ !getLine
14:19:33 <johnw> Iceland_jack: at least via an extension, amirite?
14:19:36 <benzrf> @remember mbrock then you get into a whole thing about the epistemology of abstract algebra, and someone brings  up Wittgenstein, somebody brings out a bottle of wine, and it's yet another one of those nights
14:19:36 <lambdabot> It is forever etched in my memory.
14:19:41 <benzrf> lol
14:19:41 <Iceland_jack> sure
14:19:46 <benzrf> @quote
14:19:46 <lambdabot> copumpkin,ski says: > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
14:20:00 <mbrock> yay! :)
14:21:41 <mbrock> Arnob: monad-like structures show up a lot in other languages; see the various "promise" libraries for JavaScript for example
14:21:50 <johnw> and futures in C++
14:21:59 <sipa> s/monad/IO/
14:22:00 <johnw> aka: http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/
14:22:34 <benzrf> mbrock: as far as i can tell, promises are much more like functors than monads
14:22:39 <Iceland_jack> Another problem with monads in other languages is higher-level types and return type polymorphism
14:22:49 <Cale> benzrf: They're like neither
14:22:56 <hcaulfield57> Okay, you can't have actual types on constraints, it has to be a type variable.
14:23:11 <hcaulfield57> That's what FlexibleContexts does
14:23:11 <Cale> benzrf: A type constructor for promises might itself be a functor
14:23:13 <benzrf> Cale: yeah, but if you INSIST on analogizing them, functors are a better one ;P
14:23:17 <Cale> benzrf: But that tells you very little
14:23:18 <benzrf> Cale: ah i see what you mean
14:23:26 <benzrf> functorial values then
14:23:29 <benzrf> fobits?
14:23:33 <benzrf> fubits
14:23:48 <benzrf> :t MonadMonoid
14:23:50 <lambdabot> m () -> MonadMonoid m
14:23:57 <johnw> benzrf: if a promise is to be created based on the value from another promise, that's related to what monads do
14:23:59 <Cale> Well, that's not all I mean
14:24:06 <benzrf> johnw: no, that's what functors do
14:24:17 <geardev> Why would you ever use cabal configure immediately after doing `cabal init`? What's the difference between cabal sandbox and hsenv? What are the @check and @ty commands for lambdabot?
14:24:18 <benzrf> johnw: there is no join involved
14:24:21 <Cale> I mean, most of the useful operations on promises are not part of the functor or monad interface
14:24:26 <benzrf> johnw: .then is quite similar to fmap
14:24:39 <Cale> So, the fact that they might happen to form a functor or monad isn't very interesting
14:24:39 <benzrf> johnw: sorta.
14:24:39 <johnw> don't you need the join in order to have the outer promise wait on the inner promise?
14:24:45 <benzrf> Cale: yeah
14:24:50 <benzrf> johnw: no...
14:25:00 <benzrf> johnw: wait, maybe
14:25:06 <mbrock> some promise libraries I've seen do an implicit join when the function passed to .then returns a new promise
14:25:09 <johnw> I'm not talking about apply a function to the value "in" the promise
14:25:17 <mbrock> (e.g. jQuery)
14:25:21 <johnw> I mean having a computation that yields it's own promise based on the vaule in another promise
14:25:27 <benzrf> ooooh
14:25:30 <benzrf> johnw: yeah that's a monad
14:25:42 <johnw> "promise composition"
14:25:50 <johnw> A monoid in the category of promise functors :)
14:25:53 <benzrf> lol javascript
14:26:06 <Cale> wat
14:26:18 <benzrf> there seems to be an alarming trend in the recent javascript community to reinvent the wheel and tout their new invention
14:26:26 <benzrf> </superioritycomplex>
14:26:44 <johnw> but I thought Node.js invented concurrency?
14:26:46 <Iceland_jack> no need to knock the JavaScript community
14:26:56 <johnw> gah, Iceland_jack is right
14:27:07 <Iceland_jack> and a stick in the mud!
14:28:24 <Cale> It makes no sense to claim that you're "using monads" unless you can write code which will operate using an arbitrary monad. In Javascript (and really most languages which don't have type classes), it's probably too awkward to do this.
14:28:44 <johnw> good point
14:28:44 <Cale> Passing the dictionary of monad operations explicitly to every bind is a pain
14:29:22 <Cale> and yet if you're not abstracting over which monad is being used anywhere in your code, why even talk about monads?
14:29:55 <sipa> futures are much more like IO actions than monads
14:29:56 <Iceland_jack> Cale: If you're using something monadic in say Scheme and you want to emphasize that structure, I don't see a problem with calling it monadic
14:30:01 <johnw> Cale++
14:30:25 <Cale> Iceland_jack: I don't see the point, just get on with writing your library. :)
14:30:32 <blanu> Hello everyone. I have a problem and I am hoping someone can point me in the right direction. I'm trying to build a Windows DLL that exports a C API for a Haskell library. The documentation on this subject is pretty sparse. I can get some basic examples to compile with GHC, but I was hoping to figure out how to make cabal compile for me so that it can link in all of the libraries. For some reason my cabal config outputs a DL
14:30:32 <blanu> L but it has no exported functions. If anyone has a suggestion, please let me know!
14:30:42 <Iceland_jack> Just like you can mention that you're working with algebraic objects like monoids in C even though you don't abstract that using a type class
14:31:20 <Cale> Iceland_jack: Well, you can, but again if you're not abstracting over it somewhere, there's no point in mentioning it.
14:31:36 <johnw> Cale: would that be like talking about "concat" as a form of join, rather than talking about join and giving concat as an example specialized to lists
14:31:37 <Iceland_jack> If that's the point of the code then mentioning it is perfectly fine
14:31:46 <Cale> I suppose you can mention it as a shorthand for explaining that the laws hold.
14:31:48 <Iceland_jack> but for most code it doesn't serve a point, which you're probably talking about
14:32:28 <Cale> If you're only working with one monad, it's probably a waste of time to even mention monads.
14:32:42 <mbrock> my point in mentioning promises was to show that Haskell monads generalize patterns that also exist outside of the Haskell world
14:33:01 <Iceland_jack> If a central part of your code forms a monad with nice properties then by all means mention it
14:33:13 <johnw> Cale: perhaps if the computation resembles the behavior of an instance of Monad, talking about it in terms of monads can lead to other intuitions?
14:33:40 <Cale> johnw: Possibly. You know that you might want to implement a bunch of stuff from Control.Monad and such
14:34:19 <Philonous> Cale, Buzzwords don't stop at haskell. The point that monads are the _conclusion_ of haskells abstraction capabilities seems to be lost on many people (especially non-haskellers), but because they are talked about so much they become a sort of fetish.
14:35:11 <mbrock> there are also concrete suggestions for the Promise/A+ library to adopt a semantics that follows classic monad semantics
14:35:35 <benzrf> sweet
14:35:42 <benzrf> now we just need do-notation for js ;)
14:35:46 <Cale> But for the most part, I think it creates the wrong perspective. You should never be saying to yourself "I'm going to define a monad to solve this problem", it should always be "oh, this happens to be a monad after all, I'll put in the instance so that I get some stuff for free"
14:36:01 <Iceland_jack> Cale: Agreed
14:37:15 <geardev> Why would you ever use cabal configure immediately after doing `cabal init`? What's the difference between cabal sandbox and hsenv? What are the @check and @ty commands for lambdabot? What additional information will :info give that :t doesn't give?
14:37:42 <mbrock> if your problem is how to design a complete and minimal API for sequencing asynchronous computation, I think it's not wrong to think "this sounds like a monad, so maybe I'll just provide the basic monad interface"
14:37:43 <Iceland_jack> geardev: Try ':info +' and see for yourself
14:37:54 <geardev> precdence and location of the type/operator/thing
14:38:00 <Iceland_jack> or ':info Monad'
14:38:08 <geardev> I think that's correct, not including the misspelling
14:38:37 <geardev> strangely :t Functor doesn't work but :i Functor does
14:38:49 <Iceland_jack> because Functor isn't an expression
14:38:58 <Iceland_jack> and doesn't have a type, it does have a kind though
14:39:00 <Iceland_jack> @kind Functor
14:39:02 <lambdabot> (* -> *) -> Constraint
14:39:08 <geardev> it's a type class?
14:39:13 <Iceland_jack> yes
14:39:29 <Iceland_jack> whose definition you can see using ':info'
14:39:42 <Iceland_jack> you can also see the definitions of type level functions and families using :info and many other useful things
14:39:46 <geardev> so :i is for type classes?
14:39:58 <Iceland_jack> :i is information for many things
14:40:00 <ion> It is for everything
14:40:13 <geardev> :i unzip
14:40:16 <Iceland_jack> (except terms)
14:40:22 <Iceland_jack> literal terms
14:40:24 <Iceland_jack> like 5 or 'a'
14:40:38 <geardev> ah, thank you for the clarification
14:41:36 <geardev> is there a way to see how the compiler is interpreting your command from within ghci?
14:41:45 <Iceland_jack> What do you mean by interpreting?
14:42:34 <prinsen> Im using HTTP.Conduit, is there any way to parse a response body of the form a=str&b=str2?
14:42:36 <geardev> If you do `zip [1,2,3] [4,5,6]`,I'd like to know how it arrives at [(1,3),(2,4)]
14:42:46 <Iceland_jack> ah, you can't really get that
14:42:53 <Nik05> i got a list and i would like to get a list with tuples of all combinations of two of the elements. How can i do this?
14:42:54 <Iceland_jack> you can use a braekpoint
14:43:26 <Iceland_jack> > zip [1,2,3] [4,5,6] /= [(1,3),(2,4)] -- also geardev
14:43:28 <lambdabot>  True
14:43:36 <Iceland_jack> > zip [1,2,3] [4,5,6]
14:43:38 <lambdabot>  [(1,4),(2,5),(3,6)]
14:43:45 <Philonous> > (\xs - > (,) <$> xs <*> xs) [1..3]
14:43:47 <lambdabot>  <hint>:1:6: parse error on input ‘-’
14:43:55 <Philonous> > (\xs -> (,) <$> xs <*> xs) [1..3]
14:43:57 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:43:59 <Iceland_jack> > liftA2 (,) [1,2,3] [4,5,6]
14:44:00 <geardev> Iceland_jack: sorry, i copied over
14:44:00 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:44:12 <geardev> i had performed `zip [1,2] [3,4]` in my terminal
14:44:21 <Iceland_jack> geardev: no problem :) it's a good idea to try working that out by hand
14:44:26 <Iceland_jack> given the definition of zip
14:44:28 <Iceland_jack> @src zip
14:44:28 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:44:28 <lambdabot> zip _      _      = []
14:44:30 <Nik05> Philonous that looks like what i need...
14:44:35 <Nik05> thank you very much :D
14:44:52 <Iceland_jack> geardev: Try that and see if you get stuck
14:46:14 <Iceland_jack> *and ask if you get stuck
14:47:09 <Philonous> > join (liftA2 (,)) [1..3] -- Nik05 For even better obfuscation ;)
14:47:12 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:47:18 <Nik05> hm
14:48:29 <Rarrikins> > [(a, b) | a <- [1..3], b <- [1..3]]
14:48:29 <Philonous> Note that join f x = f x x (due to the Monad instance of ((->) r))
14:48:31 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:48:46 <teknokratsevilla> @ liftA2
14:48:59 <teknokratsevilla> @src liftA2
14:48:59 <lambdabot> liftA2 f a b = f <$> a <*> b
14:49:12 <Nik05> Rarrikins damn right... why couldnt i think of that :P
14:49:28 <teknokratsevilla> Rarrikins, that's the best
14:49:29 <Philonous> Because list comprehension is naughty ;)
14:49:41 <c_wraith> I can barely comprehend lists
14:50:11 <geardev> Iceland_jack: i don't really know how to say it as concisely as the source, but it's intutive enough that i understand it combines the head of two lists, creating a new tuple for each pair and sticking each tuple into a list as the result
14:50:46 <Iceland_jack> yes, and do you see how the source means that 'zip' truncates the longer list?
14:51:11 <Iceland_jack> and of course all these are the same
14:51:11 <Iceland_jack>     [1,2,3,4]
14:51:11 <Iceland_jack>     1:2:3:4:[]
14:51:14 <Iceland_jack>     1:(2:(3:(4:[])))
14:51:16 <prinsen> is there any parser functions for url-encoded data: a=b&c?1?
14:51:54 <hunt> what is the syntax for pattern matching records?
14:52:10 <Iceland_jack> hunt: Rec { field1 = a, field2 = b }
14:52:14 <geardev> @src zip
14:52:14 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:52:14 <lambdabot> zip _      _      = []
14:52:42 <Iceland_jack> there are a bunch of extensions that make it nicer, like only having to do
14:52:42 <Iceland_jack>     Rec { field1 }
14:52:42 <Iceland_jack> to bring 'field1' into scope
14:52:43 <geardev> if there isn't a head for as or a head for bs then it falls through
14:52:47 <geardev> Iceland_jack ^
14:53:01 <geardev> i.e. truncation
14:53:10 <hunt> Iceland_jack: = a brings a into scope?
14:53:13 <benzrf> record punning!
14:53:16 <Iceland_jack> punning!
14:53:29 <geardev> has anyone been able to get something like @src working within ghci?
14:53:30 <benzrf> when i saw record puns i thought it was a joke extension involving puns
14:53:31 <Iceland_jack> geardev: yes it ensures that the lengths are equal by decapitating both lists step-wise
14:53:31 <benzrf> :(
14:53:47 <geardev> i can search hoogle for functions, but i can't get the source code within the interpreter
14:53:49 <Iceland_jack> geardev: the way you put it was slightly wrong
14:54:38 <Iceland_jack> “if there isn't a head for as” 'as' in that example was the tail, you could rather say “if neither first nor second argument are empty ...”
14:55:08 <geardev> ah, thank you for that correction
14:55:16 <Iceland_jack> no problem
14:55:58 <Iceland_jack> so reducing your example we get
14:55:58 <Iceland_jack>       zip [1,2,3] [4,5,6]
14:55:58 <Iceland_jack>     = zip (1:2:3:[]) (4:5:6:[])
14:55:58 <Iceland_jack>     = (1,4) : zip (2:3:[]) (5:6:[])   -- by first clause
14:56:19 <Iceland_jack>     = (1,4) : (2,5) : zip (3:[]) (6:[])
14:56:38 <Iceland_jack>     = (1,4) : (2,5) : (3,6) : zip [] []
14:56:38 <Iceland_jack>     = (1,4) : (2,5) : (3,6) : []
14:56:51 <johnw> yay, equational reasoning
14:56:52 <Iceland_jack> which is
14:56:53 <Iceland_jack>     = [(1,4), (2,5), (3,6)]
14:57:15 <geardev> nice Iceland_jack, thanks for that
14:57:40 <Iceland_jack> pattern matching makes these sort of exercises much nicer than if you had something like
14:57:40 <Iceland_jack>     if (!list1.empty && !list2.empty) { ... } else { ... }
14:58:17 <Iceland_jack> Wadler talks about this in Why Calculating is Better than Scheming
14:58:18 <Iceland_jack> @google wadler scheming
14:58:19 <lambdabot> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
14:58:19 <lambdabot> Title: A critique of Abelson and Sussman Why calculating is better than scheming
14:58:29 <geardev> oh cool! I'll read that
14:58:34 <geardev> more questions!
14:58:38 <geardev> Why would you ever use cabal configure immediately after doing `cabal init`? What's the difference between cabal sandbox and hsenv? What are the @check and @ty commands for lambdabot? has anyone been able to get something like @src working within ghci?
14:58:41 <Iceland_jack> It's a bit old and uses Miranda but it's close enough
14:59:33 <Iceland_jack> geardev: You can run arbitrary commands from GHCi so you can get @src working, let me find some resources
14:59:41 <quchen> geardev: @check is a QuickCheck command, "@check \a b -> b+a = a+b". @ty is identical to :t. @src is a lookup in a static DB, https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
14:59:48 <shachaf> You probably don't *want* something like @src for ghci, because @src is just a hard-wired database of a few common definitions. But people have done it in the past.
14:59:57 <geekosaur> cabal sandbox gives you a sandbox for the "user level" packages, but shares the global package database
15:00:07 <Iceland_jack> geardev: (By the way, if you're not familiar with QuickCheck already, get familiar with QuickCheck!)
15:00:15 <Iceland_jack> It's an amazing help for developing and testing
15:00:15 <geekosaur> hsenv virtualizes an entire ghc installation so you can have a completely different compiler version or different system level packages
15:00:49 <Iceland_jack> geardev: http://www.haskell.org/haskellwiki/GHC/GHCi this describes how to get lambdabot's src command
15:00:54 <codyreichert> yeah
15:00:57 <geekosaur> if you're familiar with perl development, cabal sandbox is local::lib and hsenv is perlbrew
15:01:12 <Iceland_jack> but like shachaf mentioned, it's not that interesting
15:02:15 <Iceland_jack> I would love to have a feature like in Clojure where every src is available through GHCi, it's rather ironic that the more 'obscure' things like type families and type classes have their entire source available from GHCi while normal functions or definitions don't
15:04:01 <quchen> Knowing the actual source of a function isn't really helpful at all in many cases, since library functions tend to prefer performance over readability.
15:04:25 <quchen> (And if you really need the actual source, you probably don't want to see it in GHCi.)
15:04:33 <Iceland_jack> quchen: You can never read too much source code!
15:04:37 <geardev> Iceland_jack: what you just said, isn't that why it would be useful to have src
15:04:41 <geardev> in ghci
15:04:50 <Iceland_jack> geardev: I agree it would be useful
15:04:59 <geardev> oh, what quchen just said
15:05:17 <geardev>  i'm often hoogling and i just want to do @src
15:05:25 <monochrom> I view it through economics. not enough money is paid to get ghci to display source
15:05:29 <shachaf> Knowing the actual source of a function is often helpful.
15:05:35 <Iceland_jack> monochrom: So it should be coint-operated? :)
15:05:40 <Iceland_jack> *coin
15:05:53 <monochrom> yes
15:05:56 <shachaf> Someone should go through the standard library and un-performancize a lot of the functions that are needlessly complicated.
15:06:01 <Iceland_jack> ∶pulls GHCi lever∶
15:06:02 <shachaf> For example length.
15:06:08 <quchen> Iceland_jack: You can read a lot of source code that's useless to you. When you're looking for "how to sort stuff" as a beginner, sort's source won't help you much. Maybe there should be an argument to GHCi's "source" command: actual | readable :-)
15:06:22 <shachaf> GHC's optimizer has gotten better and now the fancy Int# length is no longer necessary.
15:06:50 <jomg> shachaf: well, there are some functions with USE_REPORT_PRELUDE ifdefs
15:06:52 <quchen> shachaf: That's a good example. The "#" scared me from that function in the beginning, and "#" is hard to search for online.
15:07:12 <geardev> https://github.com/chrisdone/goa
15:07:12 <Iceland_jack> quchen: Yes I agree that the base source isn't necessarily the best for teaching basic Haskell but for curious people and for advanced users it's useful
15:07:16 <shachaf> Hoogle will find #
15:07:27 <monochrom> many people want source for many different incompatible reasons. the most popular reason, however, is that docs are poor, so source becomes the only source of information left.
15:07:44 <albeit> If I have datatype Foo that is parsed from a ByteString, and sometimes the parsing fails or for whatever reason a Foo can't be generated, is it a better idea to return something like "Either String Foo", or create a data constructor "BadFoo String" and just return type Foo?
15:08:00 <shachaf> jomg: Yes, but the Report definition is terrible for a real program, if I remember correctly. And it's never used anyway.
15:08:13 <shachaf> jomg: I want the real one to not use Int#, since it doesn't need to.
15:08:36 <Iceland_jack> albeit: Either String Foo should be fine
15:08:37 <shachaf> albeit: Best not to have errors be part of Foo.
15:08:44 <zomg> albeit: I would think using existing commonly used things like Either is good, unless BadFoo has a particular specific meaning in your application
15:08:53 <shachaf> If you add a BadFoo constructor to Foo now, you have to handle it forever in every part of your program.
15:08:54 <jomg> true, source using GHC primitives may not always be readable
15:08:54 <Nik05> wasnt there some function that [IO ()] -> IO ()?
15:08:54 <geardev> monochrom: for me, i'm new and i don't really understand why i'm seeing when i read :scanl1 :: (a -> a -> a) -> [a] -> [a]
15:08:59 <quchen> shachaf: That's quite a rat's tail, now I'm reading about magic hashes because I'm not quite sure what kinds and unboxing are. That's quite misleading for the innitial purpose (understanding how length works), although learning about unboxed things surely is helpful at some point.
15:09:01 <shachaf> Most of your program shouldn't have to think about failure.
15:09:03 <geardev> s/why/what
15:09:03 <Iceland_jack> Nik05: sequence_
15:09:05 <zomg> (though even then, it might sense to do Either Foo BadFoo and have it as a separate type altogether)
15:09:05 <Nik05> :)
15:09:15 <Nik05> hoogle doesnt show it
15:09:18 <albeit> Awesome, that was a very clean consensus! Thanks
15:09:18 <Iceland_jack> @ty sequence_ :: [IO ()] -> IO ()
15:09:19 <lambdabot> [IO ()] -> IO ()
15:09:28 <Iceland_jack> @ty sequence_
15:09:29 <lambdabot> Monad m => [m a] -> m ()
15:09:49 <Nik05> ah ok thank you
15:09:51 <benzrf> hmmm
15:10:05 <benzrf> > sequence_ [getLine, putStrLn "lol"]
15:10:07 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
15:10:07 <lambdabot>  Expected type: GHC.Types.IO GHC.Base.String
15:10:07 <lambdabot>    Actual type: GHC.Types.IO ()
15:10:08 <benzrf> lame!
15:10:19 <benzrf> i wanna existential types
15:10:48 <merijn> benzrf: Actually, you don't
15:10:49 <monochrom> sequence_ [ void getLine, void (putStrLn "lol") ]
15:10:50 <Iceland_jack> > sequence_ [getLine, "lol" <$ putStrLn "lol"]
15:10:51 <lambdabot>  <IO ()>
15:10:57 <Iceland_jack> monochrom: 'void getLine'? :)
15:11:04 <merijn> benzrf: You want Impredicative Types, but it's broken and no one is fixing it :(
15:11:09 <Iceland_jack> > sequence [getLine, "lol" <$ putStrLn "lol"]
15:11:11 <lambdabot>  <IO [[Char]]>
15:11:20 <monochrom> void getLine
15:11:51 <Iceland_jack> 'void getLine' is like asking someone to pop to the shop for eggs and then smashing them
15:12:17 <zomg> Iceland_jack: sounds like a video from HowToBasic.. "How to buy eggs"
15:12:21 <Ralith> maybe you're expecting an empty line
15:12:25 <Ralith> and lazy about asserts
15:12:27 <Iceland_jack> hah
15:12:33 <monochrom> Henry VIII says, "void & null $ my_marriage"
15:13:05 <Iceland_jack> "" ← getLine :) how lazy can you be
15:13:09 <geardev> i am going to attempt to setup ghci on acid
15:13:19 <geardev> cabal install goa lambdabot lambdabot-utils
15:13:34 <geardev> and then i think you edit the ~/.ghci file
15:13:43 <geardev> and somehow point to the location of lambdabot
15:13:44 <benzrf> :t void
15:13:46 <lambdabot> Functor f => f a -> f ()
15:13:51 <monochrom> continuing Iceland_jack's line of thought, "void & null $ my_marriage" is like asking someone to bear children for you and then smashing them. which was what Henry did, too.
15:14:05 <benzrf> merijn: what does impredtypes do
15:14:09 <geardev> Iceland_jack: thanks for pointing to the wiki page of ghci
15:14:22 <geardev> quchen: thanks for explaining what @check and @src do
15:14:39 <merijn> benzrf: Currently nothing, because it's broken
15:14:44 <geardev> i wonder why @ty is used, can't you just do :t?
15:14:50 <benzrf> geardev++
15:14:52 <merijn> benzrf: But it would allow "forall" within datatypes
15:15:00 <benzrf> h-hm
15:15:02 <merijn> benzrf: Like "Maybe (forall a . a)"
15:15:03 <benzrf> btw
15:15:19 <benzrf> i am having trouble putting into words why foralls on the rhs of a -> are floatable
15:15:22 <geardev> geekosaur: thanks for pointing out the difference between cabal sandbox and hsenv!
15:15:23 <benzrf> but not on the lhs
15:15:30 <quchen> geardev: I think @ty was mostly useful back when lambdabot wouldn't accept :t in private sessions
15:15:50 <benzrf> i once had a private session with lambdabot ;)
15:16:30 <monochrom> benzrf: perhaps my http://www.vex.net/~trebla/weblog/any-all-some.html helps
15:17:41 <geardev> cabal is now downloading misfortune for me, i'm scared
15:17:47 <Iceland_jack> haha
15:17:56 <Iceland_jack> oh no, the cabal curse!
15:18:13 <monochrom> wait til there is a package called "hell".
15:18:55 <monochrom> perhaps I should make an "acme-hell" package. it will depend on conflicting packages.
15:19:18 <benzrf> monochrom: hehehe
15:19:27 <benzrf> is there a list of acme packages
15:19:41 <benzrf> > don't do it
15:19:42 <monochrom> just look under the "acme" category
15:19:43 <lambdabot>  <hint>:1:7: parse error on input ‘do’
15:19:43 <Iceland_jack> monochrom: also make one that make the type checker hang
15:19:44 <geardev> -- Add the path to lambdabot's directory to dot-ghci
15:19:45 <benzrf> lame
15:19:51 <benzrf> > don't $ do it
15:19:53 <lambdabot>  Not in scope: ‘don't’Not in scope: ‘it’
15:19:53 <lambdabot>  Perhaps you meant one of these:
15:19:53 <lambdabot>    ‘id’ (imported from Data.Function),
15:19:53 <lambdabot>    ‘C.id’ (imported from Control.Category),
15:19:53 <lambdabot>    ‘i’ (imported from Debug.SimpleReflect)
15:19:57 <benzrf> =[
15:20:10 <geardev> how would you do what the readme of goa is suggesting there, adding the path of lambdabot's directory to .ghci
15:20:20 <Iceland_jack> in my xmonad config there is
15:20:21 <Iceland_jack>     'mind the gap Full'
15:20:27 <geardev> i've opened the file, but what are some commands that would indicate to ghci the location of lambdabot?
15:20:34 <jmcarthur> @let don't = const $ return ()
15:20:37 <lambdabot>  Defined.
15:20:38 <benzrf> Iceland_jack: hehehe
15:20:42 <jmcarthur> > don't $ do it
15:20:44 <lambdabot>  Not in scope: ‘it’
15:20:44 <lambdabot>  Perhaps you meant one of these:
15:20:44 <lambdabot>    ‘id’ (imported from Data.Function),
15:20:44 <lambdabot>    ‘C.id’ (imported from Control.Category),
15:20:44 <lambdabot>    ‘i’ (imported from Debug.SimpleReflect)
15:20:46 <Iceland_jack> where mind = the = id and 'gap = gaps [(U, 20), ...]'
15:20:54 <jmcarthur> silly not-ghci
15:21:09 <benzrf> wait, you can do multiple assgn in haskell?
15:21:17 <Iceland_jack> geardev: it should be in '~/.cabal/bin/'
15:21:25 <jmcarthur> what do you mean multiple assgn?
15:21:28 <Rarrikins> benzrf: Yes, it's pattern matching.
15:21:35 <benzrf> oh?
15:21:40 <geardev> but do you just place "~/.cabal/bin" within ~/.ghci?
15:21:41 <Iceland_jack> let (a, b) = (x, y)?
15:21:42 <benzrf> foo = bar = baz
15:21:42 <jmcarthur> Let (x, y) = (5, "foo) in show x ++ show y
15:21:47 <jmcarthur> > let (x, y) = (5, "foo) in show x ++ show y
15:21:49 <lambdabot>  <hint>:1:43:
15:21:49 <lambdabot>      lexical error in string/character literal at end of input
15:21:50 <Iceland_jack> oh no
15:21:52 <albeit> Which of these is "best" / most idiomatic Haskell? http://lpaste.net/104910
15:21:56 <jmcarthur> haha
15:22:02 <Iceland_jack> benzrf: that's not possible
15:22:05 <jmcarthur> > let (x, y) = (5, "foo") in show x ++ show y   -- i kind of stink
15:22:07 <lambdabot>  "5\"foo\""
15:22:13 <Iceland_jack> I was using meta-notation
15:22:13 <benzrf> Iceland_jack: oh i thought that was a code sample
15:22:15 <benzrf> right
15:22:17 <Averell> hoogle data --all, what do i have to expect in download/storage size?
15:22:40 <jmcarthur> you could do something like     [foo, bar] = replicate 2 baz
15:22:45 <Averell> rough estimates welcome as well
15:22:51 <benzrf> hmm
15:22:55 <benzrf> where is the acme package listing
15:23:09 <jmcarthur> or even    foo:bar:_ = repeat baz
15:23:25 <monochrom> benzrf: http://hackage.haskell.org/packages/#cat:ACME
15:23:40 <quchen> albeit: C is not legal Haskell, A and B are legal and a matter of taste
15:24:02 <Iceland_jack> quchen: C is not legal Haskell? :)
15:24:12 <benzrf> monochrom: lol
15:24:15 <albeit> It works in ghci?
15:24:41 <Iceland_jack> albeit: it is a list comprehension, sure
15:24:43 <Iceland_jack> but it's not very clear
15:24:53 <quchen> Oooooh.
15:25:06 <quchen> I thought he added a guard right in the middle of an expression. My bad.
15:25:15 <quchen> It's legal but my reaction shows how idiomatic I think it is ;-)
15:25:19 <Iceland_jack> exactly
15:25:30 <Iceland_jack> albeit: I'd probably use if then else and use 'singleton pair' rather than fromList
15:25:43 <Iceland_jack> but it depends on the surrounding code
15:26:16 <albeit> Iceland_jack: How would the surrounding code influence which to use?
15:27:16 <benzrf> omg http://hackage.haskell.org/package/acme-inator-0.1.0.0/docs/Acme-Inator.html
15:27:19 <benzrf> ahaha
15:27:27 <Iceland_jack> if this is a single declaration I might use B, if the boolean is passed as an argument to a function I might pattern match, if it's a local function in another definition where a lot is going on I might actually go for the minimal C
15:27:52 <Iceland_jack> etc. etc.
15:28:26 <albeit> The cond is actually just checking whether a passed in value matches a constant
15:28:52 <Iceland_jack> A constant that you can pattern match on?
15:29:55 <albeit> The function is passed pair@(k,v), and its checking k==aConstant, so yeah... but there more done afterwards in the function, and I wouldn't want to repeat that for each pattern.
15:30:32 <Iceland_jack> albeit: Could you possibly lpaste the entire function?
15:31:23 <Iceland_jack> You can possibly use the map operations to achieve the same effect
15:31:42 <albeit> Sure: http://lpaste.net/104912. (Just a warning, I'm trying to change it to remove the recursion right now)
15:31:58 <benzrf> omfg
15:32:04 <benzrf> this is the best package
15:32:29 <benzrf> if Mark Lentczner is here pls let me tell you that Acme.Inator is genious
15:33:40 <albeit> Actually I'm stuggling to remove the explicit recursion... I can't really use a fold because its not folding over anything, its just repeating until an error condition is met.
15:33:56 <Iceland_jack> albeit: Could you describe a bit what you're trying to do?
15:34:07 <Iceland_jack> the 'k == 0' condition feels fragile
15:34:12 <startling> albeit, that's a Fold, but with a different operation.
15:34:30 <startling> i.e., you want state that says "has the condition been met?" too.
15:35:10 <startling> you could also takeWhile or something beforehand.
15:35:35 <Iceland_jack> are you trying to match element n up with element n+1?
15:35:52 <Iceland_jack> > let xs = [1..] in zip xs (tail xs) -- something like this might help with that
15:35:54 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
15:35:55 <albeit> Iceland_jack: It is very fragile and bad, definitely. Its parsing a bytestring of key value pairs (such as "5=foo 235=bar 100=10.5"). collectRawPairs makes an IntMap of the pairs until it hits entrySeparator, and returns that last pair and Entry (an IntMap). The next entry then has to have that pair from the previous entry...
15:36:41 <albeit> Then once it hits the end of the line/file, it jsut returns all the Entry objects it found. (All within the attoparsec Parser monad)
15:38:02 <Iceland_jack> Can't you split that up into splitting on separator -then-> parsing?
15:38:41 <albeit> Yes, but I'd rather it be done in a single pass
15:39:07 <startling> yeah, I'd do String -> [String] -> [(String, String)] -> [(Int, String)] -> IntMap
15:39:07 <teknokratsevilla> can you tokenize in the guards of a function ?
15:39:31 <startling> albeit, laziness makes it easy to do things in a single pass
15:39:59 <startling> I'm not sure how much that applies with attoparsec, though
15:40:03 <benzrf> :t fail
15:40:05 <lambdabot> Monad m => String -> m a
15:40:07 <benzrf> ick
15:41:09 <albeit> startling: If I just collected gathered all the pairs into a [(Int, String)], and then split that based on a specific key, wouldn't it be parsing the entire string, then having to go through ever item in the list? How would laziness make that a single pass?
15:42:46 <startling> albeit: ideally you'd use an parsing operation that parses lazily, so that last bit will never be consumed and computed. Could you back up a step, though? I think I missed some context.
15:43:22 <benzrf> ahahah
15:44:10 <teknokratsevilla> and in a list comprenhension ?
15:44:40 <geardev> I think the _t1 and _t2 parts and line number/columns are off on http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
15:44:50 <teknokratsevilla> [(key,values) | key ++ "=" ++ values in stringTobeparsed ?
15:44:58 <geardev> _t1 and _t2 / thunk names
15:45:27 <albeit> startling: Sure, quickest example, I want "1=foo 2==bar 3==baz 2=bar2 3=baz2" to be turned into [(1, foo)], [(2, bar), (3, baz)], [(2, bar2), (3, baz2)]
15:45:46 <albeit> In the fastest way possible
15:45:59 <startling> albeit: what's this about splitting on a specific key?
15:46:11 <BMeph> I think this is the worst thing about "imperative" languages; the inability to describe the result of a process without using a step-by-step procedure of how the process could get its result.
15:46:25 <albeit> startling: In that example, I need to split on every key==2
15:46:48 <startling> I don't follow. What would the result be?
15:47:08 <albeit> Three IntMaps
15:47:23 <startling> the last one being empty?
15:47:23 <albeit> Sorry, the "turned into" lists above should all have been IntMaps
15:47:40 <geardev> I've been reading the ghci documentation, and I can't figure out how exactly to set the path of lambdabot within ~/.ghci
15:47:41 <startling> oh, I see. that example *is* the output you want.
15:47:48 <albeit> startling: Yes
15:48:11 <startling> albeit: so, you have to compute it all anyway, if you want three IntMaps, don't you?
15:48:20 <geardev> I see
15:48:58 <albeit> Yes, but the way I'm doing it now it does it one pass (I think). Once it hits the specific key, it creates a new IntMap and starts adding to that one.
15:49:18 <albeit> While saving the previous IntMap to an accumulated list of IntMaps
15:50:00 <startling> albeit, "one pass" is kind of a fuzzy thing in lazy languages, especially with stream fusion.
15:50:37 <startling> it might be nicer and just as performant to write it as if you had multiple passes.
15:51:41 <albeit> startling: Starting to think that too... what did you mean exactly by your previous coment about one pass and stream fusion?
15:53:05 <BMeph> albeit: Short version: map f (map g xs) == map (f . g) xs
15:53:06 <startling> albeit, so, look at "map f (map g someList)". in a strict language this would be two passes.
15:53:38 * BMeph cyber high-fives startling! ;)
15:54:02 <albeit> Ha, okay actually that makes a lot of sense BMeph
15:54:08 <albeit> and startling
15:54:48 <albeit> And makes my life a lot easier! Going to go a route that isnt' as concerned about pass counting... thanks guys
15:54:52 <startling> albeit, in Haskell, it goes more like "give me the first item of 'map f (map g someList)'." "it's 'f (head (map g someList))'". "give me the first item of 'map g someList'". "it's g (head someList)"". "Give me the first item of someList" .... etc
15:56:08 <startling> It does matter a bit, since some operations are necessarily strict. e.g., reversing a list twice *does* traverse the lsit twice.
15:58:01 <bitemyapp> startling: I saw edwardk playing with something related to that but I can't bring it up
15:58:16 <startling> bitemyapp, ok.
15:58:25 <geardev> what does :m - Prelude do?
15:58:29 <geardev> from within ghci
15:58:36 <Iceland_jack> geardev: unload Prelude
15:58:40 <bitemyapp> startling: it specifically had to do with laziness and reverse.
15:58:41 <glguy> "un"imports the Prelude
15:59:23 <geardev> i wonder why someone would put that in their .ghci file
16:00:19 <ion> Maybe to load an alternative prelude.
16:00:29 <geardev> the next line down is :m + GOA
16:00:34 <ion> I have found that to be a pain when working with modules that use the standard one, though.
16:00:37 <geardev> i guess that's the alternative
16:00:59 <benzrf> oh my god acme-php
16:01:06 <benzrf> these are all so great
16:01:09 * benzrf sheds a single tear
16:01:17 <c_wraith> benzrf: you have to read the source to understand the true depth of it
16:01:21 <benzrf> i did
16:01:22 <benzrf> i did
16:01:26 <c_wraith> twice?
16:01:32 <benzrf> only once
16:01:38 <teknokratsevilla> I did . did
16:01:46 <glguy> It was read fusion
16:01:50 <ion> This is best package. http://hackage.haskell.org/package/gutenberg-fibonaccis-1.1.0/docs/src/Algorithm-Gutenberg-Fibonaccis.html
16:01:51 <glguy> the two reads of it fused into one
16:02:11 <startling> glguy: ;)
16:02:15 <ion> I especially like lastFib, the last Fibonacci number.
16:02:32 <Iceland_jack> ion: that was 9 right
16:02:35 <startling> ion: awesome.
16:02:58 <benzrf> goodness
16:03:22 <ion> Oh, brilliant. I just noticed that it’s also licensed under GPLv3+.
16:03:32 <benzrf> >true = TRUE
16:03:33 <benzrf> >false = False
16:03:35 <benzrf> is
16:03:38 <benzrf> is that even compile
16:03:52 <benzrf> >-- In prolog, we only need to specify the true cases, and the unifier will backtrack on false cases
16:03:54 <Iceland_jack> @let true = False
16:03:55 <lambdabot>  .L.hs:183:1:
16:03:55 <lambdabot>      Multiple declarations of ‘true’
16:03:55 <lambdabot>      Declared at: .L.hs:182:1
16:03:55 <lambdabot>                   .L.hs:183:1
16:03:56 <benzrf> :)
16:03:59 <benzrf> > true
16:04:00 <lambdabot>  Not in scope: ‘true’
16:04:02 <Iceland_jack> @let true = False
16:04:03 <benzrf> >tfw
16:04:03 <lambdabot>  Defined.
16:04:06 <Iceland_jack> > true
16:04:08 <lambdabot>  False
16:04:13 <benzrf> > MonadMonoid
16:04:14 <lambdabot>  Not in scope: data constructor ‘MonadMonoid’
16:04:17 <benzrf> >tfw u erased my stuff
16:04:24 <Iceland_jack> 'true' and 'false' are great for embedding
16:04:39 <Kazagistar> ion: wtf... is that fib package supposed to be a joke...? I can't tell if they are serious or not
16:04:52 <ion> kazagistar: Me neither.
16:04:53 <wu_> type-erasure for confusion and ambiguity?
16:06:21 <albeit> Using attoparsec, if I parse something to (Int, ByteString), and then later parse the Bytestring again, so the result is something like (Int, Foo), is that slower than just parsing everything at once?
16:06:56 <Kazagistar> eh, prolog works as long as you are thinking in terms of constructive, axiomatic logic
16:07:26 <bitemyapp> albeit: having a tuple with leftovers is pretty much how applicative and monadic parsing works. I can't speak to speed though.
16:07:49 <hpc> Kazagistar: until you realize it's still turing complete and your constructive axiomatic logic might still prove false
16:08:49 <Kazagistar> the opposite of "true" is "don't have evidence that it is true" :P
16:09:05 <vanila> I tend to think in depth-first-search when I prolog
16:11:12 <startling> albeit: there's probably some overhead there
16:11:15 <geardev> :bs
16:11:51 * geardev was expecting lambdabot to return ":)"
16:12:45 <Kazagistar> albeit: why do you not want to parse the bytestring right away?
16:12:48 <ion> @botsmack
16:12:49 <lambdabot> :)
16:13:54 <albeit> Kazagistar: Well, I don't necessarily need everything parsed (I can throw out chunks of the string to parse), but I guess because it's lazy, I can still parse everything without penalty
16:14:10 <albeit> Because the parts I throw out will never actually be parsed if they aren't used
16:14:32 <geardev> @src zip
16:14:32 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:14:33 <lambdabot> zip _      _      = []
16:14:47 <geardev> λ: :src zip
16:14:47 <geardev> Plugin `sourcePlugin' failed with: state not initialized
16:15:02 <startling> albeit: the hard part is that if you have a list of them you don't know where to stop.
16:15:20 <benzrf> when it comes to lists i never know where to stop
16:15:24 <benzrf> i just keep going
16:15:45 <geardev> i'm in the lambdabot repl
16:15:50 <geardev> lambdabot> src zip
16:15:57 <albeit> startling: But even if I parse all the second elements in a list of pairs, they won't actualy be parsed untill I later use them, right?
16:15:59 <geardev> Plugin `sourcePlugin' failed with: state not initialized
16:16:02 <geardev> has anyone ran into this?
16:16:33 <startling> alexsdut1on: it depends how you spell it, I think.
16:17:29 <geekosaur> geardev: I think everyone who tries to build their own lambdabot runs into it these days
16:17:33 <geardev> https://stackoverflow.com/questions/20195915/lambdabot-sourceplugin-failed-with-state-not-initialized
16:17:35 <geekosaur> nobody's figured out why or how to fix
16:17:43 <geekosaur> that I've heard of at least
16:18:52 <Kazagistar> I missed albeit's answer, was it lazy parsing?
16:19:42 <albeit> Kazagistar: The string I'm parsing is a bunch of key value pairs, and depending on the key, I can throw out some pairs.
16:21:15 <geardev> I guess I will try building it from source then
16:23:29 <Iceland_jack> geardev: if you just want the src feature from lambdabot that's seems like a hassle
16:24:32 <geardev> Maybe, but maybe there's more I could utilize?
16:24:38 <Iceland_jack> It might be easier to throw together a script that searches for the function on Hackage and returns you the source result
16:24:40 <Iceland_jack> maybe
16:25:38 <Kazagistar> albeit: so you are trying to not parse some values, given the key, and you can't know if something will be thrown out given only information that comes before it?
16:25:44 <geardev> Iceland_jack: I like that idea. I don't understand how you would include this into the ~/.ghci file though
16:25:57 <Iceland_jack> geardev: you can use any shell command in GHCi
16:26:02 <geardev> oh
16:26:03 <Iceland_jack> just :def and some stuff
16:26:30 <albeit> Kazagistar: Pretty much... given "3=foo 6=bar 1=baz", and I want to throw out all 6s, I can't tell a 6 is coming up until I hit it
16:27:04 <Kazagistar> albeit: wait, but the bar comes after the 6
16:27:06 <hunt> how do i mix io and state?
16:27:13 <Iceland_jack> monad transformer
16:27:16 <Iceland_jack> StateT
16:27:20 <hunt> should i do IO Statw
16:27:37 <hunt> i dont know anything about monad transformers :'(
16:27:37 <benzrf> hunt: that doesnt make sense :(
16:27:40 <Rarrikins> hunt: You can use MVars and things.
16:27:42 <Iceland_jack> You can also use IORef/MVar/TVar for state
16:28:11 <albeit> Kazagistar: Hmm of course.. so I should be able to just short circuit the parsing of the part after "=" once I know the key value
16:28:12 <benzrf> hunt: monad transformers are basically monads that take another monad as a parameter to their type, then implement >>= such that it uses the >>= for the parameter type
16:28:21 <benzrf> :k StateT
16:28:22 <lambdabot> * -> (* -> *) -> * -> *
16:28:25 <benzrf> for example
16:28:36 <Iceland_jack> :k forall a. StateT [Int] IO a
16:28:37 <lambdabot> *
16:28:46 <Kazagistar> albeit: right, exactly :)
16:28:57 <hunt> ah ok
16:29:05 <hunt> not too hard
16:29:06 <benzrf> hunt: `StateT StateType IO Int' is the type of a value that can be bound
16:29:18 <benzrf> hunt: and binding it will produce an Int as a result of processing a state and doing IO
16:29:20 <albeit> Kazagistar: Things are clicking to place! thanks
16:29:22 <geardev> this is taking too long
16:29:24 <hunt> ok now i have a parsec question
16:29:27 <benzrf> shoot
16:29:39 <geardev> :(
16:29:44 <geardev> I will just continue playing with haskell instead
16:29:50 <Iceland_jack> geardev: Good idea!
16:29:55 <geardev> :(
16:30:01 <augur> hunt: a monad transformer is a thing thats supposed to make new monads out of old!
16:30:07 <hunt> im currently not using parsec, but want to make the jump. However, my program does variable substitution per line before the line is parsed and executed by my parser. Could i do variable substitution with parsec?
16:30:31 <benzrf> hunt: can you explain what var subst means
16:30:33 <Iceland_jack> geardev: :def command (\_ -> return ":! some | shell command")
16:30:39 <benzrf> in this context
16:31:08 <hunt> basically the stuff im parsing has the ability to declare variables, so i hae a map of variables and their values, when i see a variable instead of a numeric value supplied to a command im parsing i subsitute the value for the variable
16:31:15 <Iceland_jack> geardev: getting the first Google result for something is easy though :)
16:31:34 <benzrf> hunt: don't do that at parse
16:31:35 <hunt> ie "command 1 2 var 3 4" where var = 7 would be rendered as "command 1 2 7 3 4" and then parsed
16:31:43 <benzrf> hunt: parse to a data structure that includes terms such as vars
16:31:51 <benzrf> then figure out vars when you interpret the parsed AST
16:32:15 <hunt> youre going to have to help me out here, what owuld a data structure like that possibly look like?
16:32:30 <hunt> im not very proficient with appropriately using ADTS yet
16:32:43 <EvanR> knowing what an ast should be like is a good idea if youre going to parse something
16:32:45 <benzrf> data Term = Literal {value :: Int} | Var {name :: String}
16:32:52 <hunt> ah cool
16:32:55 <hunt> thats what i was thinking
16:32:55 <benzrf> data Command = Command String [Term]
16:32:59 <hunt> so then i sweet
16:33:11 <benzrf> or something along those lines ;)
16:33:13 <hunt> why do you have the string?
16:33:20 <benzrf> hunt: for the command itself
16:33:23 <hunt> thought so
16:33:27 <hunt> ok, thanks benzrf
16:33:37 <benzrf> data Command = Command {command :: String, args :: [Term]} perhaps
16:33:38 <hunt> im not going to use the string but this is very cool and very close to what ill be d oing
16:33:45 <benzrf> :-)
16:33:54 <hunt> ADTS are fucking awesome
16:34:04 <hunt> literaally evreything ive done in haskell so far is fucking awesome
16:34:10 <hunt> if only programming wasnt so lonely
16:34:32 <EvanR> next implement girlfriend in haskell
16:35:18 <wu_> i kind of like duck-typing's ability to experiment w/ local refactorings w/o having to change every lien everywehre to satisfy the typechecker first
16:35:32 <benzrf> wu_: since when do you have to change every line
16:35:32 <wu_> but once i know what type-signatures i want.. it's off to a real language :)
16:35:42 <hunt> data friend = Friend {male :: Bool, love :: Bool}
16:36:04 <ion> Overloaded booleans. D-:
16:36:08 <benzrf> hunt: why not
16:36:17 <benzrf> data Gender = Male | Female | Other
16:36:29 <benzrf> data Friend = Friend {gender :: Gender, love :: Bool}
16:36:30 <benzrf> :_)
16:36:32 <hunt> yea better
16:37:11 <ion> benzrf: Enjoy the SJW league’s impending attack for only recognizing three genders. (Sorry, offtopic, i’ll stop this line of discussion now.)
16:37:26 <hunt> Other pattern matches to all genders
16:37:31 <benzrf> ion: please do not do that
16:38:03 <hunt> instance Num Gender
16:38:05 <Kazagistar> love :: Complex
16:38:38 <Iceland_jack>     data Person = Person { name ∷ String, gender ∷ Double }
16:38:53 <ReinH> Or just... don't worry abut their gender
16:38:57 <Iceland_jack> or that
16:39:00 <bitemyapp> If you aren't interfacing with a gov't organization that requires declaration of male/female, or you're dealing with medical information that needs sex, you're better off not asking or letting them fill in what they want.
16:39:16 <ReinH> or use a String
16:39:19 <hunt> newtype Person = Object {lust :: Bool}
16:39:22 <benzrf> bitemyapp++
16:39:23 <bitemyapp> ReinH: that's "fill in what they want"
16:39:34 <bitemyapp> benzrf: easy there killer, I'm not a progressive hero.
16:39:49 <kadoban> Alright, so how do I install an actual up-to-date version of GHC/cabal on ubuntu? Is there instructions somewhere? Never have been clear on the best way.
16:39:51 <ReinH> Can we maybe pick a different subject for discussion?
16:39:52 <EvanR> fill in what they want is a data nightmare
16:40:04 <ion> kadoban: Dunno about best, but this is what i do. https://gist.github.com/ion1/2815423
16:40:08 <bitemyapp> I find FirstName/LastName divisions annoying too, same situation. Unless a gov't org requires the separation - just offer a Name field.
16:40:09 <EvanR> individualism notwithstanding
16:40:25 <bitemyapp> EvanR: very few businesses have a legitimate reason for knowing gender.
16:40:41 <hunt> it would be sweet if we could just have names instead of first name and last name
16:40:41 <EvanR> our database has no gender whatsoever, which is nothing
16:40:44 <bitemyapp> EvanR: and you can probabilistically guess quite accurately from name
16:40:46 <EvanR> which is awesome*
16:40:56 <bitemyapp> right, that would be the way to go if it's an option.
16:40:59 <kadoban> ion: Looks like a plan, thanks :)
16:41:10 <hunt> data Person = Person {name :: String, gender :: Maybe String}
16:41:38 <EvanR> hunt: would rather avoid NULLs too ;)
16:41:48 <hunt> gah you cant win
16:41:48 <bitemyapp> data Person = Person {...only the information you actually need...}
16:41:57 <glguy> Avoid assorted outrage with just "data Person = Person"
16:41:58 <hunt> type Person = Nothing
16:42:03 <Iceland_jack>     data Person
16:42:04 <glguy> No need to distinguish at any level
16:42:08 <EvanR> Person = Void
16:42:09 <hunt> er thta wont work
16:42:23 <hunt> meaningofLife = Nothing
16:42:36 <bitemyapp> data Person = Person { taxIdNumber :: Integer, cc :: Integer }
16:42:39 <bitemyapp> there, the bits that matter.
16:42:52 <Rarrikins> Integer is bad there. Bad.
16:43:00 <glguy> Everyone can be the same identity, when you order something online they take it out of the community account and mail it somewhere
16:43:09 <hunt> data Person = Person {lifts :: Bool}
16:43:15 <ion> hunt++
16:43:23 <bitemyapp> haha, yessss
16:43:24 <EvanR> lol
16:43:32 <hexagoxel> type Person = PersonT Identity
16:43:33 <hunt> lol
16:43:45 <benzrf> hexagoxel: perfect
16:43:46 <bitemyapp> Rarrikins: yep
16:50:34 <albeit> If I need a function :: Int -> String -> a, where the specific instance of a is determined by the Int value, is there a cleaner way to generate the correct a other than a big if/case?
16:51:04 <ion> albeit: That type means the *caller* of function determines the type “a”, not the function itself.
16:51:16 <benzrf>                         
16:51:39 <benzrf> albeit: that makes type resolution inposible
16:51:55 <benzrf> albeit: the compiler cant know which int it is at compiletime
16:52:06 <benzrf> albeit: so you will have an unspecified type that you can do nothing with
16:52:10 <benzrf> albeit: other than put through id
16:52:11 <augur> i wonder if there are any other nice free structures that can be easily coded as an ADT besides monoids and simpler things
16:52:19 <benzrf> augur: monads?
16:52:37 <augur> benzrf: mm.. yes thats true, there are nice adts for free monads
16:52:59 <ReinH> magmas
16:53:01 <albeit> So if I have a pair (Int, String), that I want to turn into a where a is determined by the Int, how would you suggest I do it?
16:53:09 <augur> ReinH: magmas are the "simpler things" :)
16:53:11 <benzrf> ReinH: that's *simpler* than monads
16:53:14 <benzrf> *monoids
16:53:27 <benzrf> i propose that a lava is an unclosed magma!
16:53:29 <ReinH> free monoids can be coded as any ADT you want as long as it's isomorphic to a list.
16:53:34 <ion> albeit: What problem are you trying to solve with this plan?
16:53:38 <benzrf> data FreeMonad f a = Return a | Join (f (FreeMonad f a))
16:53:46 <augur> ReinH: yes yes, of course
16:53:56 <ion> benzrf: The floor is lava
16:53:59 <benzrf> instance Monad (FreeMonad f) where return = return; join = Join
16:54:01 <benzrf> =)
16:54:02 <Kazagistar> albeit: how you plan to use "a" will determine the best way to use "a"
16:54:09 <benzrf> oh wait, no functor
16:54:14 <Iceland_jack> benzrf: also a loop!
16:54:14 <augur> benzrf: blegh. thats awful! better to use   data FreeMonad f v = Var v | Op (f (FreeMonad f v))
16:54:19 <glguy> albeit: You'll need to define a sum type that can wrap all the possible result types and return that
16:54:39 <albeit> Parsing a string into its final type based upon its key (if the string looks like "5=foo", before knowing where/why it will be used later.
16:54:58 <ion> albeit: Ok, what glguy said.
16:55:24 <djahandarie> I prefer data Free f a = Rick a | Roll (f (Free f a))
16:55:36 <augur> djahandarie: lol
16:55:37 <ReinH> lmao
16:55:58 <benzrf> can you figure out the opposites of the words 'always coming from take me down'?
16:56:02 <augur> djahandarie: the Var/Op version to me sums up what free monads "are" in some sense
16:56:18 <Iceland_jack> benzrf: Fool me once
16:56:22 <Kazagistar> albeit: presumably, you want a collection that holds these results: collections generally only hold one type, but a type can hold multiple things, with functions to safely extract them
16:56:27 <benzrf> Iceland_jack: =)
16:56:37 <ion> benzrf: rarely leaving into provide them upwards
16:56:46 <benzrf> ion: :-O
16:57:19 <Iceland_jack> The opposite or always is rarely?
16:57:21 <Iceland_jack> *of
16:57:26 <benzrf> Iceland_jack: rarely.
16:57:52 <EvanR> almost rarely
16:58:09 <geardev> notthree x
16:58:12 <Iceland_jack> 'almost rarely' sounds like the most cop-out answer imaginable
16:58:13 <albeit> Kazagistar: By collection are you referring to Data.Collections, or just generally any collection of objects?
16:58:16 <geardev>             | x /= 3 = x
16:58:27 <Iceland_jack> Have you been unfaithful? -- Almost rarely.
16:58:32 <geardev> this is non-exhaustive
16:59:09 <ajf> I should write a language that compiles to Haskell
16:59:11 <geardev> I want to use this "notthree" function, but I don't want it to crash when it is a three
16:59:20 <ajf> which lets you write imperitive code
16:59:21 <Kazagistar> albeit: collections in general
16:59:26 <Iceland_jack> ajf: or a language that is compiled in Haskell
16:59:26 <ajf> an excercise in futility
16:59:30 <Iceland_jack> EDSL
16:59:31 <geardev> is there a value which is equivalent to "continue"
16:59:39 <ajf> *exercise
16:59:41 <benzrf> geardev: huh?
16:59:48 <Iceland_jack> geardev: need a bit more context here
16:59:57 <EvanR> callCC ;)
17:00:01 <ajf> Iceland_jack: I’ll write a Haskell compiler in Haskell in zero lines of code
17:00:04 <ajf> (requires gch)
17:00:05 <geardev> i want a function which returns an array as long as the number three isn't within the array
17:00:09 <ajf> *ghc
17:00:22 <Iceland_jack> (you probably mean list)
17:00:24 <geardev> i've decided to try pattern matching for this
17:00:28 <geardev> i do, sorry
17:00:31 <Kazagistar> albeit: for an example of how other parsers deal with this, see the Value datatype from Aeson: http://hackage.haskell.org/package/aeson-0.7.0.6/docs/src/Data-Aeson-Types-Internal.html#Value
17:01:03 <Iceland_jack> well you can do
17:01:03 <Iceland_jack>     foo xs | any (== 3) xs = Just xs
17:01:03 <Iceland_jack>            | otherwise     = Nothing
17:01:12 <Iceland_jack> oh no, opposite of what you wanted
17:01:22 <Iceland_jack>     foo xs | any (== 3) xs = Nothing
17:01:22 <Iceland_jack>            | otherwise     = Just xs
17:01:38 <Iceland_jack> benzrf made me think it's opposite day
17:01:40 <geardev> but then it's wrapped in a monad
17:01:46 <Iceland_jack> geardev: what would you want to happen?
17:01:51 <geardev> and i'm not too good at handling that yet
17:02:08 <Iceland_jack> geardev: Absolutely no need to think about monads
17:02:25 <Iceland_jack> Lists are also monads geardev, you've been working with them just fine haven't you?
17:02:39 <geardev> aww, shucks, you make me blush
17:02:45 <Iceland_jack> :)
17:02:47 <geardev> i've been working with monads this entire time?
17:02:49 <Iceland_jack> So for now, ignore the fact that Maybe is a monad since it's not required to use them
17:02:58 <geardev> okay
17:03:07 <ion> "Lists are monads" is a bit inaccurate.
17:03:14 <benzrf> list is a monad
17:03:41 <Iceland_jack> What did you imagine would happen if the list contained a 3 geardev? Crash and burn?
17:03:42 <EvanR> list has at least two monad instances
17:03:44 <geardev> I'm almost certain this one of the most roundabout ways of solving what I'm solving, but i will get to that later
17:04:01 <Iceland_jack> (let's not be too pedantic about this)
17:04:10 <geardev> i was just hoping it would ignore anything that didn't fit the pattern
17:04:49 <albeit> Kazagistar: Okay, so I would have a sum datatype with a constructor for each possible type the value could be. And each of those types would be an instance of some typeclass like "parseValue". Does that make sense?
17:05:27 <Kazagistar> albeit: not sure why you need a typeclass there at all
17:06:53 <EvanR> aeson uses typeclasses to interpret Values
17:07:02 <EvanR> as other types
17:07:20 <geardev> notthree [1,2,3] -- should result in [1,2]
17:07:26 <geardev> that's the goal
17:07:35 <EvanR> :t delete
17:07:36 <lambdabot> Eq a => a -> [a] -> [a]
17:07:37 <Iceland_jack> oh, you just want to remove the threes?
17:07:41 <geardev> notthree [1,3,4] should be [1,4]
17:07:50 <geardev> yep
17:07:54 <albeit> Kazagistar: I was thinking so I could do something like " | key==1  =  Foo (parseValue str :: Foo)". So Foo would be a datatype that is an instance of hte Parseable typeclass that implements parseValue
17:07:55 <Iceland_jack> EvanR: what about [1,2,3,3]? geardev probably wants filter
17:08:01 <Iceland_jack> > filter (/= 3) [1,2,3,2,4,3,1]
17:08:02 <lambdabot>  [1,2,2,4,1]
17:08:11 <EvanR> > delete 3 [1,2,3,3]
17:08:13 <lambdabot>  [1,2,3]
17:08:20 <Iceland_jack> > [ i | i <- [1,2,3,2,4,3,1], i /= 3 ]
17:08:21 <lambdabot>  [1,2,2,4,1]
17:08:29 <geardev> oh cool
17:08:33 <geardev> filter is exactly what i was wanting
17:09:09 <geardev> it was quite a ways down in http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html
17:09:28 <albeit> Or I guess I could just make parseFoo :: String -> Foo, and make a parseXXX for every datatype that could be parsed.
17:09:38 <benzrf> albeit: noooooooo
17:09:40 <geardev> > filter (/= 3) [1,3,4]
17:09:42 <lambdabot>  [1,4]
17:09:43 <Kazagistar> albeit: each call to the parsing function that is in must know what type it will return at compile time. It HAS to return the sum-type.
17:10:42 <Iceland_jack> geardev: filter/map/fold are functions you'll be using all the time
17:10:43 <albeit> Kazagistar: Yes, the first Foo above is a data constructor for, say, the Bar sum type. "data Bar = Foo Foo | Baz Baz; type Foo = Double"
17:11:02 <geardev> (!!) for getting the index of an element in a list, filter for... filtering a list :) and now to get the index of an element if present in a list
17:11:11 <Iceland_jack> geardev: you almost never want to use (!!)
17:11:25 <Iceland_jack> unlike languages like C
17:11:47 <EvanR> :t find
17:11:48 <lambdabot> (a -> Bool) -> [a] -> Maybe a
17:12:24 <geardev> elemIndex, this is great
17:12:49 <Iceland_jack> > elemIndices 't' "this is a test"
17:12:50 <lambdabot>  [0,10,13]
17:12:51 <Kazagistar> albeit: thats what you should do. Sum types are types that let you make type-based choices at runtime, which is what you will have to do.
17:13:18 <geardev> i wonder if there's an elemIndex which returns something like a tupe of all the indices associated with the element in a list
17:13:24 <geardev> not just the first instance
17:13:41 <geardev> oh, that was the next one below elemIndex :)
17:13:41 <Iceland_jack> geardev: you mean what I wrote above?
17:13:45 <geardev> exactly
17:13:50 <geardev> :)
17:13:58 <Iceland_jack> To answer your question, that :)
17:14:12 <Iceland_jack> #haskell's service is so complete that it answers questions before you ask
17:14:13 <Kazagistar> albeit: in theory, you can use Dynamic or something, but you almost certainly don't want to do that
17:14:23 <EvanR> @pl \(_,_,x) -> x
17:14:24 <lambdabot> (line 1, column 7):
17:14:24 <lambdabot> unexpected "x"
17:14:24 <lambdabot> ambiguous use of a non associative operator
17:14:37 <geardev> Iceland_jack: why would you almost never want to use (!!)? is it because there is findIndex and findIndices?
17:14:58 <Iceland_jack> in Haskell (a !! n) corresponds to a[n] in languages like C
17:14:59 <geardev> Wait nevermind, they are different
17:15:06 <benzrf> :t thd
17:15:07 <lambdabot> Not in scope: ‘thd’
17:15:10 <benzrf> pfft
17:15:12 <joelteon> because !! is not a total function; it doesn't return a value for every input
17:15:17 <Iceland_jack> in Haskell it takes linear time for lists and it can fail
17:15:19 <benzrf> @let thd = view _3
17:15:21 <lambdabot>  Defined.
17:15:22 <EvanR> is thd a real thing
17:15:23 <joelteon> > [] !! 2
17:15:23 <benzrf> :t thd
17:15:24 <lambdabot> (Field3 s s a a, MonadReader s m) => m a
17:15:25 <lambdabot>  *Exception: Prelude.(!!): index too large
17:15:25 <benzrf> EvanR: no
17:15:37 <benzrf> > thd (3, 6, "foo")
17:15:38 <lambdabot>  "foo"
17:15:39 <benzrf> :^)
17:16:40 <joelteon> ok, so like you can show all the constructors for an ADT, is there a way to show all constructors in a data instance?
17:17:07 <benzrf> joelteon: data instance?
17:17:16 <joelteon> yeah. for a data family
17:17:28 <Iceland_jack> geardev: Adding two to every number in an array in C-like code would be
17:17:28 <Iceland_jack>     for (int i = 0; i < len; ++i) a[i] += 2;
17:17:28 <Iceland_jack> but in Haskell you'd just do
17:17:28 <Iceland_jack>     map (+2) a
17:18:06 <Kazagistar> geardev: usually, a program does not only do something with item 3, usually it does things with "all items" or "some items (from a filtered subset)" or similar
17:18:11 <switchy> is there a "prettier" way to write something like <*> f g = \x -> f x (g x)
17:18:24 <Iceland_jack> yes, (<*>) :)
17:18:39 <EvanR> in fact, because there is no "thd" we can never use item 3 ;)
17:18:43 <switchy> heh ;)
17:19:19 <Iceland_jack> you can define it in terms of 'ap' if you want
17:20:40 <EvanR> > toModifiedJulianDay 0
17:20:42 <lambdabot>  Not in scope: ‘toModifiedJulianDay’
17:24:18 <Iceland_jack> :t ap
17:24:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:24:20 <Iceland_jack> :t (<*>)
17:24:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:24:36 <switchy> ah, okies. that seems a bit like cheating though
17:24:43 <Iceland_jack> it is
17:24:50 <Iceland_jack> but if you already have a Monad instance..
17:25:01 <albeit> Is there a cleaner way to do this? http://lpaste.net/104915  The extra brackets make me think there is...
17:27:08 <enthropy> albeit: http://lpaste.net/104915 gets rid of the inner nes
17:27:43 <glguy> It's probably clearer to just write MessageType' twice in this case even if you can pull it out like that
17:27:46 <augur> Iceland_jack, switchy: cheating how?
17:28:11 <albeit> glguy: But there are many more test cases, this is just showing two
17:28:13 <switchy> augur, it's an exercise, and I don't have a Monad instance anyway
17:28:48 <albeit> enthropy: Thats better, thanks. Still no way to git rid of the enclosing  ()?
17:29:18 <enthropy> of course there are ways
17:29:38 <enthropy> you could have   fmap MessageType' $  -- on the first line
17:30:03 <enthropy> (or have some fmap with lower fixity than <|> (like <&> in the second example))
17:30:06 <benzrf> ugh
17:30:12 <benzrf> :t <&>
17:30:13 <lambdabot> parse error on input ‘<&>’
17:30:18 <benzrf> :t (<&>)
17:30:19 <lambdabot> Functor f => f a -> (a -> b) -> f b
17:30:28 <benzrf> i read http://www.vex.net/~trebla/weblog/any-all-some.html
17:30:37 <benzrf> but i cant figure out the last section
17:30:58 <albeit> enthropy: Oh yeah, just using fmap instead of <$> is perfect
17:31:57 <augur> benzrf: huh!
17:32:00 <vanila> getTagValue 1 = MessageType' Foo <$ P.char 'X' <|> MessageType' Bar <$ P.char 'd'
17:32:04 <vanila> doesnt work?
17:32:14 <augur> (f <&>) == yoneda!
17:32:24 <augur> er, lets not call it f
17:32:40 <augur> (x <&>)
17:33:04 <haasn> augur: Clearly we need to rename (<&>) toYoneda
17:33:07 <augur> i do so love yoneda. (x <&>) ~ (<$> x) is the coolest function in town
17:33:35 <augur> haasn: nah, needs more descriptiveness!
17:33:52 <augur> toContinuationLikeContainerActionThing
17:33:52 <benzrf> what is yoneda anyhoo
17:33:57 <albeit> vanila: Nope
17:34:01 <haasn> Clearly we also need to rename “id id” fromYoneda
17:34:07 <haasn> Err, flip id id
17:34:08 <enthropy> vanila: it should work. That's what glguy suggested
17:34:10 <haasn> ($ id)
17:34:11 <vanila> oh does it need to be (MessageType .' Foo)
17:34:12 <haasn> whatever
17:34:32 <augur> benzrf: yoneda is just the observation that this type:   F A   is isomorphic to this type:   forall r. (A -> r) -> F r
17:34:34 <albeit> :t .'
17:34:35 <lambdabot> parse error on input ‘.’
17:34:40 <enthropy> oops yeah you need a .
17:34:40 <augur> benzrf: for some fixed F and A
17:34:41 <clintm> you guys are completely nuts.
17:34:42 <albeit> :t (.')
17:34:43 <lambdabot> parse error on input ‘)’
17:34:45 <clintm> love it...
17:34:50 <augur> benzrf: tho you can abstract over them, obviously
17:35:00 <albeit> vanila: What is .' ?
17:35:05 <vanila> tpyo
17:35:22 <enthropy> vanila: actually <$ discards the argument, so Foo and Bar do not take arguments
17:35:22 <augur> yonedaFwd :: forall f a. Functor f => f a -> forall r. (a -> r) -> f r
17:35:23 <haasn> augur: for some functor F.
17:35:31 <glguy> benzrf: Ezyang has that example on his "Interactive Tutorial of the Sequent Calculus" (second to last entry) http://logitext.mit.edu/logitext.fcgi/tutorial
17:35:47 <glguy> benzrf: If you want to play around with it and try your hand and proving why it is true
17:35:50 <augur> yonedaFwd x f = fmap f x
17:36:00 <augur> yonedaBwd :: forall f a. Functor f => (forall r. (a -> r) -> f r) -> f a
17:36:05 <augur> yonedaBwd f = f id
17:36:26 <augur> yoneda is just a fancy continuation!
17:36:30 <augur> :t cont
17:36:32 <lambdabot> ((a -> r) -> r) -> Cont r a
17:36:36 * benzrf holds his head
17:36:40 <augur> oh thats not what i wanted
17:37:09 <augur> well anyway:   continuze :: forall a. a -> forall b. (a -> b) -> b
17:37:10 <haasn> :t runCont
17:37:11 <lambdabot> Cont r a -> (a -> r) -> r
17:37:28 <augur> continuize x f = f x
17:37:32 <haasn> Oh, Cont is just a newtype-ish
17:37:34 <augur> decontinuize :: forall a. (forall b. (a -> b) -> b) -> a
17:37:38 <augur> decontinuize f = f id
17:37:43 <benzrf> Cont r a is isomorphic to a, right
17:37:54 <augur> benzrf: only if r is quantified over
17:37:59 <augur> a ~ forall r. Cont r a
17:38:00 <benzrf> quantified?
17:38:13 <augur> yes, r has to be forall-ed
17:38:20 <augur> if r is fixed, it's not isomorphic
17:38:48 <haasn> :t cont
17:38:49 <lambdabot> ((a -> r) -> r) -> Cont r a
17:38:53 <haasn> err
17:38:54 <haasn> :t mapCont
17:38:55 <lambdabot> (r -> r) -> Cont r a -> Cont r a
17:38:58 <haasn> So how come this isn't (r -> r')?
17:39:31 <augur> @src mapCont
17:39:31 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:39:35 <augur> so frustrating :|
17:39:47 <haasn> Cont ~ (a -> r) -> r; so we want uh
17:40:02 <enthropy> @djinn (r -> r) -> ((a -> r) -> r) -> ((a -> r) -> r)
17:40:02 <lambdabot> f a b c = a (b c)
17:40:03 <haasn> @djinn (r -> r') -> ((a -> r) -> r) -> ((a -> r') -> r')
17:40:04 <lambdabot> -- f cannot be realized.
17:40:11 <haasn> @djinn (r' -> r) -> ((a -> r) -> r) -> ((a -> r') -> r')
17:40:11 <lambdabot> -- f cannot be realized.
17:40:15 <haasn> There's my answer
17:40:29 <augur> :p
17:40:44 <enthropy> @djinn (r -> r') -> (r' -> r) -> ((a -> r) -> r) -> ((a -> r') -> r')
17:40:44 <lambdabot> f a b c d = a (c (\ e -> b (d e)))
17:41:11 <heatsink> I wrote some code to weaken a list of constraints.  It seems too complicated for what it does, but I can't figure out how to make it simpler.
17:41:13 <heatsink> http://lpaste.net/104918
17:41:29 <heatsink> I'm kind of wondering if GHC is just not ready for data structures of kind Constraint.
17:42:02 <haasn> @djinn (r -> r') -> (s' -> s) -> ((a -> s) -> r) -> ((a -> s') -> r')
17:42:03 <lambdabot> f a b c d = a (c (\ e -> b (d e)))
17:42:08 <haasn> Is there some sort of Bifunctor thing lurking here?
17:42:21 <augur> haasn: generalized continuations you mean?
17:42:25 <haasn> I guess so
17:42:35 <haasn> I don't really know, nor do I really understand continuations other than “they're just yoneda”
17:42:43 <augur> Cont' s r a = (a -> r) -> s
17:42:59 <augur> haasn: yoneda is fancy continuations :)
17:43:33 <augur> Cont' is a very interesting beast. its not quite a monad, but it does lead you to invent indexed monads
17:43:38 <augur> they compose nicely, too
17:43:50 <haasn> so Cont' s r a is sort of like (a, r -> s) except that you probably can't extract the individual elements
17:44:01 <augur> Cont' r s (a -> b) -> Cont' r t a -> Cont' r t b
17:44:18 <augur> haasn: no its not quite that at all
17:44:37 <haasn> Oh, it can do more than that
17:44:58 <haasn> It can pass my function multiple ‘a’s and combine its internal ‘r’s using whatever mechanism it wants
17:44:59 <augur> er, that should be Cont' s t a
17:45:00 <augur> sorry
17:45:16 <geardev> @src sequence
17:45:16 <lambdabot> sequence []     = return []
17:45:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:45:17 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:45:18 <augur> haasn: its just a generalized continuation
17:45:18 <haasn> (I guess if the Cont value is allowed to choose r and s here)
17:45:52 <augur> haasn: Chris Barker and Ken Shan have a nice paper on this sort of generalized continuation in linguistics
17:46:04 <augur> also probably felleisen has some comments on it somewhere
17:46:11 <haasn> I was with you up until the last word :)
17:46:18 <augur> haasn: ?
17:46:32 <haasn> If it's based on linguistics I don't know if I will understand an awful lot
17:46:50 <augur> haasn: well, they use it for denotational semantics
17:47:02 <augur> to give a compositional account of things like quantification
17:47:12 <augur> they also have a REALLY nice notation for it
17:47:25 <Welkin> who is "they"?
17:47:29 <augur> barker and shan
17:47:31 <Iceland_jack>     pattern Len n ← (natVal → n)
17:47:31 <Iceland_jack> pattern matching on Proxys!
17:47:48 <augur> haasn: they use these funky towers for the type
17:48:12 <augur> so they have something like this:
17:48:15 <augur> R | S
17:48:18 <augur> -----
17:48:21 <augur>   A
17:48:32 <augur> to mean (A -> S) -> R
17:48:44 <geardev> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
17:49:00 <geardev> "and that newcomers think, that the order of statements determines the order of execution.
17:49:24 <augur> which leads to nice composition rules:
17:49:27 <augur> R | S    S | T        R | T
17:49:27 <augur> ------   -----   =>   -----
17:49:27 <augur> A -> B     A            B
17:49:27 <geardev> I did think that the the order of do statements determines the order of execution
17:49:27 <Welkin> well, geardev, that only requires some time to get used to
17:49:47 <Welkin> think of it like verilog or other hardware description languages
17:50:00 <haasn> It depends on the monad
17:50:01 <augur> haasn: so you can see how the top levels have to line up. you can push it further, too, and get towers of towers, etc. for nested continuations
17:50:11 <haasn> And by what “execution” means
17:51:00 <haasn> In the Maybe example it gives, the order of the statements determines the order of execution
17:51:13 <augur> haasn: they also have a nice term notation too. instead of writing continuized terms like  \k -> ... (k ...) ...  they split it in half, writing the outer parts as ...[ ]... and below that writing the inner ...
17:51:14 <haasn> Except execution in this case means pattern matching against Just/Nothing
17:51:26 <geardev> would ghc evaluate this in parallel?
17:51:27 <geardev> do x <- Just (3+5) y <- Just (5*7) return (x-y)
17:51:35 <Iceland_jack> no
17:51:39 <haasn> augur: Ah okay; I'll have a look at it when I get some free energy
17:52:06 <augur> haasn: http://semprag.org/article/view/sp.1.1/74
17:52:12 <haasn> thanks
17:52:28 <augur> its a great notation for reasoning, and its _mere_ notation, too. it translates directly to lambda terms, so its nice and simple
17:52:51 <geardev> Iceland_jack: the wiki article i'm reading says that it can be evaluated in any order, also in parallel. By default, ghc won't evaluate do statements in parallel? Will it evaluate anything in parallel by default?
17:53:13 <heatsink> ghc does not automatically evaluate things in parallel
17:53:23 <geardev> thanks heatsink
17:53:36 <Iceland_jack> basically no, automatic parallelization is too hard
17:53:47 <heatsink> In your Maybe example, the evaluation order depends on how the subtraction operator is defined
17:53:54 <heatsink> It could evaluate x or y first
17:54:05 <ReinH> Iceland_jack: Or too easy, depending on how you look at it ;)
17:54:06 <haasn> geardev: With optimization and monomorphism, GHC compiles that as Just -27
17:54:12 <Iceland_jack> heatsink: I think geardev meant the actual values
17:54:22 <Iceland_jack> (3+5), (5*7)
17:54:46 <haasn> geardev: So the correct answer is that it doesn't evaluate them at all
17:54:52 <haasn> (at runtime)
17:56:12 <Iceland_jack> haasn: The expressions that geardev choose were just incidental though, so I'm not sure how complete that answer is :)
17:57:44 <haasn> Perhaps so. Anyway, GHC seems to always inline Maybe-do blocks as much as possible
17:58:06 <haasn> I generalized the inner expressions and function to (a -> b -> c) -> ... and it still comes out as \f a b -> Just (f a b)
17:58:35 <haasn> Which tells us at least something about how do-blocks and the Maybe monad work
17:58:36 <Iceland_jack> geardev: If you want something run in parallel you need to make that explicit, good news: it's not hard, bad news: it's hard to get right for non-trivial examples
17:58:56 <haasn> good news: There's a great book on the subject
17:58:59 <Iceland_jack> Indeed!
17:59:31 <Iceland_jack> But if you have 'f x' and 'g y' and they take similar time to be evaluated, then it's nice and easy
17:59:39 <Iceland_jack> (assuming independence)
17:59:50 <haasn> fsvo “evaluated”
18:00:09 <Iceland_jack> sure, let's assume NFData
18:02:15 <haasn> What happens when you throw some bit of dependence into the mix, actually? say we have “f x” and “g x y z” where y and z are independent of x; and we do something like “f x `par` g x y z”; would GHC roughly be able to evaluate x, y and z in parallel and then g x y z after that is completed? Assume f and g are strict in all arguments
18:02:23 <dino-> I've got some code here that uses postgresql-simple and I'm trying to take a simple Query (as a string) and concat more to the end of it. This code is using OverloadedStrings, but I can't seem to figure out how to use a (++) or concat on this and make it type check.
18:02:57 <benzrf> dino-: concat and (++) operate on lists
18:03:00 <benzrf> Query is probably not a list
18:03:11 <haasn> Uh oh, are you modifying SQL statements in string form?
18:03:11 <augur> @djinn (a -> m (b -> m c)) -> m a -> m b -> m c
18:03:12 <lambdabot> -- f cannot be realized.
18:03:21 <augur> how unfortunate!
18:03:42 <benzrf> augur: djinn does not know about functors and monads
18:03:45 <augur> o
18:03:47 <haasn> I guess djinn can't do rank-n?
18:04:06 <benzrf> augur: assume that in djinn none of the Prelude is defined
18:04:15 <triliyn> djinn doesn't know typeclasses, so m is an arbitrary type constructor
18:04:16 <haasn> otherwise you could do (forall a. a -> m a) -> ...
18:04:27 <benzrf> augur: you are working purely off of builtins, plus Maybe and a few others
18:04:29 <augur> :t \f ma mb -> do { a <- ma ; b <- mb ; f' <- f a ; f' b }
18:04:31 <lambdabot> Monad m => (t -> m (t1 -> m b)) -> m t -> m t1 -> m b
18:04:35 <augur> \o/
18:04:49 <dino-> benzrf: Exactly, it's not a list, but it's confusing me as to how to join one of these with another
18:04:59 <dino-> haasn: yep
18:05:09 <enthropy> @djinn Monad m => a -> m a
18:05:10 <lambdabot> f = return
18:05:20 <benzrf> u wot m8
18:05:21 <haasn> @djinn Monad m => (a -> m (b -> m c)) -> m a -> m b -> m c
18:05:21 <lambdabot> -- f cannot be realized.
18:05:24 <geardev> woah, djinn is cool
18:05:33 <benzrf> since when does djinn know about monads >.<
18:05:48 <benzrf> @djinn Monad m => a -> m b -> m a
18:05:48 <lambdabot> f a _ = return a
18:05:53 <ReinH> o_O
18:05:53 <geardev> Would anyone be willing to demonstrate how to use sequence? I'm becoming tired, but I'll stay up a little longer if someone has an example of this :)
18:05:55 <benzrf> tsk tsk
18:06:05 <benzrf> @djinn Monad m => m a-> m b -> m a
18:06:05 <lambdabot> f a _ = a
18:06:10 <ReinH> geardev: sequence has different uses depending on the monad instance
18:06:11 <triliyn> oh, interesting
18:06:12 <benzrf> @djinn Monad m => m a -> m b -> m (a, b)
18:06:12 <lambdabot> -- f cannot be realized.
18:06:22 <haasn> :t \ambmc ma mb -> do { a <- ma; bmc <- ambmc a; bmc b }
18:06:23 <lambdabot> Monad m => (t1 -> m (Expr -> m b)) -> m t1 -> t -> m b
18:06:30 <benzrf> looks like djinn only knows of return
18:06:34 <Iceland_jack> geardev: sequence [getLine, getLine]
18:06:37 <ReinH> > sequence [Just 1, Nothing, Just 2, Just 3]
18:06:39 <Iceland_jack> reads 2 lines of input
18:06:40 <lambdabot>  Nothing
18:06:44 <haasn> :t \ambmc ma mb -> do { a <- ma; bmc <- ambmc a; mb >>= bmc }
18:06:45 <lambdabot> Monad m => (t -> m (a -> m b)) -> m t -> m a -> m b
18:06:56 <haasn> I wonder why djinn couldn't implement that
18:07:00 <Iceland_jack> ghci> sequence [getLine, getLine]
18:07:00 <Iceland_jack> hello
18:07:00 <Iceland_jack> world
18:07:00 <Iceland_jack> ["hello ","world"]
18:07:20 <ReinH>  > sequence [[1,2],[3,4]]
18:07:35 <ReinH> > sequence [[1,2],[3,4]]
18:07:37 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
18:07:42 <augur> @hoogle m (a -> m b) -> m a -> m b
18:07:44 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
18:07:44 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
18:07:44 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:07:55 <enthropy> benzrf: if lambdabot has the same djinn that hackage does, it has the whole Monad class defined (but apparently it can't really use it)
18:08:27 <benzrf> mm
18:08:28 <glguy> > sequence [Proxy, Proxy, Proxy]
18:08:30 <lambdabot>  Proxy
18:08:30 <augur> :t \mf ma -> do { f <- mf ; a <- ma ; f a }
18:08:32 <lambdabot> Monad m => m (t -> m b) -> m t -> m b
18:08:34 <benzrf> :t Proxy
18:08:35 <lambdabot> Proxy t
18:08:40 <benzrf> wth is Proxy
18:09:02 <augur> this seems like the monad version of (<*>)
18:09:06 <glguy> data Proxy a = Proxy. It doesn't use its type argument
18:09:08 <benzrf> augur: what does
18:09:20 <haasn> Wait a minute:
18:09:21 <augur> benzrf: \mf ma -> do { f <- mf ; a <- ma ; f a }
18:09:22 <benzrf> glguy: a ha
18:09:30 <benzrf> augur: ah
18:09:32 <zwer> :t sequence <$> sequence [getLine, getLine]
18:09:33 <lambdabot> IO [[Char]]
18:09:36 <haasn> Cont Void ~ (a -> Void) -> Void; right?
18:09:43 <augur> haasn: yes
18:09:46 <haasn> ~ Not (Not a)
18:09:49 <augur> haasn: yes
18:09:58 <augur> there is no function   Cont Void a -> a
18:09:59 <haasn> This is what people use to embed classical logic into intuitionistic logic, right?
18:10:05 <augur> haasn: correct
18:10:11 <augur> haasn: its the DNE translation
18:10:20 <haasn> So Cont Void ~ Classic, yes?
18:10:31 <augur> haasn: Cont Void a  ~  classical a
18:10:48 <haasn> Then what does that make callCC :: ((a -> Classical b) -> Classical a) -> Classical a
18:10:59 <haasn> :t callCC ($ id)
18:11:00 <lambdabot> MonadCont m => m (a -> a)
18:11:05 <augur> haasn: ??
18:11:11 <augur> what do you mean what does that make callCC?
18:12:01 <haasn> Oh, wait, never mind
18:12:05 <augur> @djinn ((a -> Void) -> Void) -> a
18:12:06 <lambdabot> -- f cannot be realized.
18:12:09 <ReinH> augur: yeah, it's monadic "application" ;)
18:12:09 <augur> lies!
18:12:15 <augur> ReinH: hm?
18:12:19 <ReinH> =<<
18:12:24 <augur> ReinH: no
18:12:30 <augur> ReinH: the type is different
18:12:35 <ReinH> I know it's different
18:12:37 <ReinH> but it's similar
18:12:39 <augur> yes
18:12:41 <augur> similar!
18:12:42 <haasn> I was thinking that the (a -> Classical b) allows me to prove any Classical a assuming I can use the provided (a -> Classical b) to prove any ‘b’ I want; but that's trivial, since I need to provide ‘a’ to use that function in the first place
18:12:43 <augur> but different
18:12:48 <geardev> ReinH, Iceland_jack: sequence takes a list of (monads | ? monadic actions ? ) and returns the result of running those (monads | ? monadic actions ? )
18:12:52 <ReinH> augur: Yes.
18:12:55 <ReinH> augur: but similar.
18:13:21 <haasn> augur: For a moment I was just scared that it should be possible to write callCC :: Classical a
18:13:25 <haasn> err, foo :: Classical a
18:13:30 <ReinH> augur: I didn't mean to imply that it was the same exact thing
18:13:42 <haasn> Of course, it isn't; meaning I can go sleep
18:14:01 <augur> ReinH: im just thinking, how to generalize the applicative pattern in a way that isnt trivially applicative
18:15:11 <benzrf> @hoogle Writer l a -> l
18:15:12 <lambdabot> Control.Monad.Trans.Writer.Lazy execWriter :: Writer w a -> w
18:15:12 <lambdabot> Control.Monad.Trans.Writer.Strict execWriter :: Writer w a -> w
18:15:12 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
18:15:23 <augur> hmm... (f a -> a) -> a   =   Cont a (f a)
18:15:29 <benzrf> @hoogle Writer l l
18:15:30 <lambdabot> Did you mean: :: Writer l l
18:15:31 <lambdabot> package XmlHtmlWriter
18:15:31 <lambdabot> package xml-conduit-writer
18:15:35 <benzrf> @hoogle Writer w w
18:15:35 <lambdabot> Did you mean: :: Writer w w
18:15:36 <lambdabot> Control.Monad.Trans.Writer module Control.Monad.Trans.Writer
18:15:36 <lambdabot> Control.Monad.Writer module Control.Monad.Writer
18:15:40 <benzrf> hmm
18:15:44 <benzrf> @hoogle :; Writer w w
18:15:45 <lambdabot> Parse error:
18:15:45 <lambdabot>   :; Writer w w
18:15:45 <lambdabot>    ^
18:15:48 <benzrf> @hoogle :: Writer w w
18:15:49 <lambdabot> Control.Category id :: Category cat => cat a a
18:15:49 <lambdabot> Control.Arrow returnA :: Arrow a => a b b
18:15:49 <lambdabot> Control.Monad.Trans.Writer.Lazy mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
18:15:58 <benzrf> fff
18:16:32 <augur> fold :: Functor f => Fix f -> (f a -> a) -> a   =   Functor f => Fix f -> Cont a (f a)
18:16:36 <benzrf> oh wait
18:16:42 <benzrf> ummm
18:16:44 <benzrf> hmm
18:16:51 <augur> Fix f ~ forall a. Cont a (f a)
18:17:06 <benzrf> isn't there a thing you can do in Writer to get the currently logged value
18:17:07 <geardev> ReinH, Iceland_jack: is this correct: sequence takes a list of (monads | ? monadic actions ? ) and returns the result of running those (monads | ? monadic actions ? )
18:17:59 <benzrf> geardev: mobits, call em
18:18:00 <hunt> in parsec is there a way to try and read a number and if you cant then to give back the string?
18:18:14 <benzrf> geardev: and more or less :-)
18:18:46 <augur> Yoneda f a = forall r. (a -> r) -> f r
18:18:47 <EvanR> hunt: so like, youre trying to produce a Either Integer String ?
18:19:11 <hunt> i guess, im trying to read to a data type similar to Value = Literal Num | Variable String
18:19:16 <augur> ContF f r a = (a -> r) -> f r
18:19:18 <hunt> EvanR:
18:19:23 <EvanR> hunt: yeah same thing really ;)
18:19:35 <EvanR> yours is better
18:19:35 <hunt> yea sure then
18:19:42 <benzrf> guh
18:20:11 <geardev> benzrf: that's good to know :) do you know if there's a more technical term than "mobits"? If monads aren't values, you can't use the term "monadic value" I presume
18:20:13 <augur> Fix f ~ forall a. Cont Identity a (f a)   ;   Yoneda f a = forall r. ContF f r a
18:20:21 <EvanR> make a literal parser and a variable parser, then try to use <|>
18:20:26 <ReinH> augur: right
18:20:28 <augur> Fix f ~ forall a. Cont Identity a (f a)   ;   Yoneda f a = forall r. ContF f r (Identity a)
18:20:29 <EvanR> both produce a Value
18:20:34 <benzrf> geardev: monadic value is the typical term
18:20:35 <ReinH> augur: throw some kan extensions on it
18:20:39 <ReinH> always helps
18:20:41 <benzrf> geardev: i saw mobit somewhere and i like it more
18:20:42 <hunt> ah ofc
18:20:49 <hunt> thanks EvanR
18:21:07 <augur> ContF2 f r g a = (g a -> r) -> f r
18:21:19 <geardev> benzrf: it's in the "what a monad is not" wiki article
18:21:29 <geardev> for future reference
18:21:33 <augur> Fix f = forall a. ContF2 Identity a f a   ;   Yoneda f a = forall r. ContF2 f r Identity a
18:21:55 <benzrf> :t listen
18:21:56 <lambdabot> MonadWriter w m => m a -> m (a, w)
18:22:15 <benzrf> hmm
18:22:30 <augur> ReinH: dont know what kan extensions are, alas
18:22:41 <ReinH> augur: http://hackage.haskell.org/package/kan-extensions-4.0.3/docs/Data-Functor-Kan-Lan.html ?
18:23:16 <ReinH> augur: http://comonad.com/reader/2008/kan-extensions/
18:23:38 <ReinH> augur: if you unify the functors in Ran you get ContT
18:23:45 <ReinH> Oh wrong link http://hackage.haskell.org/package/kan-extensions-4.0.3/docs/Data-Functor-Kan-Ran.html
18:23:57 <benzrf> @hoogle Monoid s => s -> State s ()
18:23:58 <lambdabot> Text.Parsec.Prim State :: s -> SourcePos -> u -> State s u
18:23:58 <lambdabot> Text.ParserCombinators.Parsec.Prim State :: s -> SourcePos -> u -> State s u
18:23:59 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
18:24:05 <augur> Lan is similar to my ContF2
18:24:14 <ReinH> augur: yes
18:24:21 <charlieb> hi, I'm a beginner and I'm trying to do the 99haskell problems, I've made it to 25 but I'm getting an error that I don't understand
18:24:21 <ReinH> augur: so this might be a useful thing for you to learn :)
18:24:25 <ReinH> And for me as well.
18:24:33 <augur> ReinH: ive know about these for a while but i dont grok them
18:24:42 <ReinH> augur: edwardk gave me a very nice lesson at BayHac that I have mostly forgotten since :)
18:24:44 <geardev> jle`, Iceland_jack, benzrf, geekosaur, Kazagistar, haasn, ReinH: thank you all for taking the time help me out!
18:24:44 <augur> cant find a good intro to them from a CS/TT perspective
18:24:51 <benzrf> geardev: no problem :-)
18:24:54 <Iceland_jack> You're welcome geardev
18:24:54 <charlieb> https://github.com/charlieb/99haskell/blob/master/problems.hs
18:24:55 <geardev> I may be back later, if not, have a nice weekend
18:25:05 <ReinH> augur: not even the comonad reader stuff?
18:25:09 <charlieb> code for 25 is all the way at the bottom
18:25:10 <Roots47> holy crap. This chat is packed.
18:25:22 <augur> ReinH: edwardk's blog is always rather opaque for me
18:25:25 <benzrf> :t state ('v':)
18:25:26 <lambdabot>     Couldn't match type ‘[Char]’ with ‘(a, [Char])’
18:25:26 <lambdabot>     Expected type: [Char] -> (a, [Char])
18:25:27 <lambdabot>       Actual type: [Char] -> [Char]
18:25:27 <Iceland_jack> geardev: come back if you have questions, best of luck
18:25:33 <ReinH> augur: I get what you mean.
18:25:40 <benzrf> :t state
18:25:41 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:25:46 <ReinH> augur: Read through all of Mac Lane then? He gets to kan extensions at the end ;)
18:25:53 <augur> :P
18:26:09 <charlieb> and the message is: problems.hs:195:19: Couldn't match type `IO' with `[]'
18:26:11 <benzrf> @hoogle MonadState s m => (s -> s) -> m a
18:26:12 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
18:26:12 <lambdabot> Control.Monad.State.Lazy modify :: MonadState s m => (s -> s) -> m ()
18:26:12 <lambdabot> Control.Monad.State.Strict modify :: MonadState s m => (s -> s) -> m ()
18:26:17 <benzrf> cool cool
18:26:26 <charlieb> Expected type: [m a]
18:26:29 <ReinH> basically everything is an adjunction, and kan extensions generalize adjunctions, so everything is a kan extension ;)
18:26:31 <charlieb>   Actual type: IO (m a)
18:26:54 <ReinH> Heh there's the quote from Mac Lane right there: "All concepts are Kan extensions."
18:27:16 <augur> ReinH: monads are generalized continuations :T
18:27:39 <Kazagistar> monads are tacos
18:27:39 <ReinH> augur: monads are concretized monoids :p
18:27:43 <augur> ReinH: that too
18:27:46 <Iceland_jack> monads are generalized monoids and tacos and monadic tacos
18:28:06 <ReinH> They are also kan extensions.
18:28:14 <napping> augur: any monad also comes from an adjunction in at least two different ways!
18:28:23 <augur> ReinH: for continuations, you write things like   k (\x -> y)   for continuations you write k >>= (\x -> y)!
18:28:30 <augur> er, for monads*
18:28:46 <ReinH> napping: Eilenberg-Moore and Kleisli right?
18:30:08 <Eduard_Munteanu> There's a category of such constructions for a monad, with E-M initial and Kleisli final.
18:30:30 <benzrf> :t runStateT
18:30:31 <lambdabot> StateT s m a -> s -> m (a, s)
18:30:56 <edwardk> It's a fun exercise to work out the Kan extension analogues to Eilenberg-Moore and Kleisli.
18:31:14 <EvanR> urg im trying to do jd to gregorian calculations with float integers, can't tell what the valid range of arguments is
18:31:58 <Rarrikins> O-o
18:32:08 <heyj> installing snap, having troubles with aeson-0.7.0 and free-4.8 both ExitFailure 1
18:32:09 * Eduard_Munteanu wonders if there's a Data.Time.Calendar.Aztec :P
18:32:16 <heyj> anyone have any advice?
18:32:21 <benzrf> @hoogle
18:32:22 <lambdabot> No query entered
18:32:22 <lambdabot> Try --help for command line options
18:32:28 <augur> @hoogle Data.Time.Calendar.Aztec
18:32:28 <lambdabot> No results found
18:32:29 <benzrf> @hoogle State s s
18:32:30 <lambdabot> Did you mean: :: State s s
18:32:31 <lambdabot> Control.Monad.State module Control.Monad.State
18:32:31 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
18:32:31 <Rarrikins> @hoogle --help
18:32:31 <lambdabot> Hoogle v4.2.32, (C) Neil Mitchell 2004-2012
18:32:31 <lambdabot> http://haskell.org/hoogle
18:32:33 <augur> Eduard_Munteanu: alas!
18:32:43 <EvanR> Eduard_Munteanu: sounds like a GSoC
18:32:44 <benzrf> @hoogle MonadState s m => m s
18:32:44 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
18:32:44 <lambdabot> Control.Monad.State.Lazy get :: MonadState s m => m s
18:32:45 <lambdabot> Control.Monad.State.Strict get :: MonadState s m => m s
18:32:47 <benzrf> cool
18:32:50 <Eduard_Munteanu> Heh.
18:33:15 <benzrf> hmm
18:33:53 <benzrf> :t set
18:33:54 <lambdabot> ASetter s t a b -> b -> s -> t
18:33:57 <benzrf> lame
18:34:00 <benzrf> :t get
18:34:01 <lambdabot> MonadState s m => m s
18:34:12 <Eduard_Munteanu> You know, we could solve the Unix time problem by replacing the epoch by time units since the last end of the world.
18:34:23 <Eduard_Munteanu> At least for now.
18:34:41 <Kazagistar> EvanR: doesnt GSoC tend to prefer to fund things with actual, um, value to a project?
18:34:58 <Eduard_Munteanu> Kazagistar: cultural value :P
18:35:06 <EvanR> Kazagistar: did you miss the whole end of the world, aztec calendar is critical
18:36:07 <EvanR> im just annoyed that there is some maximum jd (less than 2^53) such that a given algorithm will fail to give the right calendar date, yet not crash
18:36:18 <EvanR> with floats ;)
18:36:24 <Kazagistar> EvanR: I am pretty sure it even missed itself
18:36:56 <hunt> where do i learn how to use Parsec? i understand the idea of it and the structure but i dont know enough of the functions. For example i dont know how to check if the first word is a certain string
18:37:00 <Eduard_Munteanu> It was simply an off by one error, we just have to wait for the next end.
18:37:30 <EvanR> i cant help to think that haphazardly implement calendar algorithms without regard to overflow and stuff leads to security problems
18:37:37 <EvanR> implementing*
18:38:07 <Eduard_Munteanu> hunt: depends on your token type, are you operating on characters or words at a time?
18:38:36 <hunt> i suppose im operating on words
18:38:51 <hunt> im not sure
18:39:07 <Eduard_Munteanu> hunt: do you run 'words' yourself on the input or otherwise tokenize it outside of parsec?
18:39:22 <hunt> knope Eduard_Munteanu
18:39:24 <hunt> nope*
18:40:24 <Eduard_Munteanu> hunt: then likely you work on the raw text itself, which means you have to figure word boundaries.
18:40:54 <hunt> ok so lets say i get a word out, how do i then cause the parser to fail if its not the word its supposed to be
18:41:00 <Eduard_Munteanu> hunt: for example, takeWhile (/= space) would parse a word
18:41:07 <Eduard_Munteanu> hunt: exactly
18:41:23 <hunt> is there a way to do that?
18:41:57 <Eduard_Munteanu> hunt: fail "not word 'foo'"
18:42:07 <hunt> ah a fail function
18:42:08 <Eduard_Munteanu> Or mzero.
18:42:14 <kadoban> ion: Thanks, those (ghc/caball install) instructions seemed to work great.
18:42:17 <hunt> if i return mzero
18:42:19 <hunt> it fails?
18:42:38 <roboguy_> I'm using ghc 7.8.2 and I'm getting that integer-gmp problem that prevents ghc from compiling with profiling: "Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp’?"
18:43:05 <Eduard_Munteanu> hunt: mzero / empty have to fail, because of mplus / (<|>)
18:43:22 <Eduard_Munteanu> hunt: empty <|> x = x
18:44:09 <hunt> so if i start parsing a line and find that it fails, does parsec rewind the line for the next parser?
18:44:13 <Eduard_Munteanu> hunt: you could do something like   do { w <- takeWhile (/= space); guard (w == "foo") }
18:44:40 <Eduard_Munteanu> hunt: no, plain Parsec doesn't, you have to wrap the parser in 'try'
18:44:51 <Eduard_Munteanu> attoparsec does that automatically.
18:45:03 <hunt> Eduard_Munteanu: so if i use choice on a bunch of parsers, every parser that fails increments the parsing a little bit?
18:45:23 <Eduard_Munteanu> hunt: yes, unless they're wrapped in 'try'
18:45:27 <napping> You just need to use try where you need it
18:45:35 <Eduard_Munteanu> Well, if they consume input, not always.
18:45:57 <hunt> Eduard_Munteanu: do i put the try in the parser itself or map it over my choice array?
18:46:05 <Kazagistar> Eduard_Munteanu: out of curiosity, is there a reason Parsec could not do the automatic "try" like attoparsec does?
18:46:53 <Eduard_Munteanu> Kazagistar: mm, I don't think it couldn't.
18:47:05 <Eduard_Munteanu> hunt: usually at the callsite of said parser.
18:47:41 <hunt> Eduard_Munteanu: so itd be better to map it over an array which i call choice on then to embed try into the parsers?
18:48:19 <Eduard_Munteanu> hunt: it would be more flexible, although there isn't much reason not to.
18:48:40 <Eduard_Munteanu> To or not to.
18:48:57 <hunt> Eduard_Munteanu: follow up, parsec monad fails whenever it hits mzero?
18:49:05 <hunt> hence guard works?
18:49:18 <Kazagistar> choice does not use try automatically..?
18:49:47 <Eduard_Munteanu> hunt: mzero is the failure parser computation
18:50:11 <Eduard_Munteanu> One of them.
18:50:25 <hunt> Eduard_Munteanu: does the guard statement in what you demonstrated have to be the last expression?
18:50:37 <haskellbeginner> Hey, quick question, does the uvector package from Hackage fail to compile for anyone else?
18:50:42 <Eduard_Munteanu> hunt: no
18:50:48 <hunt> Eduard_Munteanu: perfect
18:51:09 <haskellbeginner> I'm getting the error: "ghc: unrecognised flag: -fno-method-sharing"
18:51:35 <Eduard_Munteanu> hunt: mzero >> x = mzero
18:52:22 <Eduard_Munteanu> > Nothing >> Just 5
18:52:24 <lambdabot>  Nothing
18:53:22 <hunt> Eduard_Munteanu: are you sure takeWhile works in parsec? is space in your example a parser?
18:53:23 <Eduard_Munteanu> hunt: also see the laws exposed here: http://www.haskell.org/haskellwiki/MonadPlus
18:53:49 <Eduard_Munteanu> hunt: er, no, I meant   takeWhile (/= ' ')
18:54:03 <Eduard_Munteanu> hunt: or   takeWhile (not . isSpace)
18:54:18 <Eduard_Munteanu> @hoogle isSpace
18:54:20 <lambdabot> Data.Char isSpace :: Char -> Bool
18:54:47 <hunt> Eduard_Munteanu: i dont think this works for Text.Parsec.String parser...
18:54:54 <hunt> i cant get it to in ghci
18:56:10 <Eduard_Munteanu> hunt: can you pastebin / paste it?
18:56:16 <hunt> ok
18:56:23 <Eduard_Munteanu> hunt: you'll have to run the parser on some input, btw
18:57:03 <hunt> Eduard_Munteanu: http://lpaste.net/104921
18:57:34 <hunt> oh i got it but not with takeWhile
18:57:53 <Eduard_Munteanu> hunt: er, yeah, that should not be takeWhile from Prelude
18:58:05 * Eduard_Munteanu 's mind is a bit tainted by attoparsec
18:58:42 <Eduard_Munteanu> hunt: or  many (satisfy (not . isSpace))
18:59:01 <hunt> what is attoparsec?
18:59:55 <Eduard_Munteanu> hunt: another parser library similar to Parsec, but faster, has very little error reporting and it's less flexible.
19:00:17 <napping> It's more for reading data fast, rather than writing nice parsers
19:00:18 <Eduard_Munteanu> Although it's in many ways easier to use.
19:02:10 <hunt> what does the state in runParser do?
19:02:30 <Eduard_Munteanu> hunt: it's for the user to use as he pleases.
19:02:42 <hunt> what does it do?
19:02:52 <hunt> does it affect output?
19:03:14 <Eduard_Munteanu> hunt: Parsec tracks state, much like a state monad
19:03:28 <Eduard_Munteanu> hunt: it doesn't use it itself, it's just for the user.
19:03:47 <hunt> i dont understand, my parsers can/should effect a state? whats the point of passing a state into the parser if you cant get it back out??
19:04:07 <EvanR> you could if you wanted to
19:04:22 <Eduard_Munteanu> hunt: you can, and your parsers can do stuff depending on that state
19:04:28 <benzrf> > [..10]
19:04:29 <lambdabot>  <hint>:1:2: parse error on input ‘..’
19:04:31 <benzrf> pfft
19:04:36 <hunt> noob
19:04:37 <Kazagistar> hunt: think something like a symbol table in a programming language, tracking what variables are in scope. If a variable is used before it is declared, state can detect that.
19:05:04 <hunt> so how do i modify the state with my parser
19:05:23 <hunt> these must be pretty common questions
19:05:26 <Kazagistar> benzrf: what would you imagine that doing?
19:05:31 <hunt> this whole state aspect of parser  is kind of blowing my mind
19:06:03 <Eduard_Munteanu> hunt: Parsec is a MonadState
19:06:31 <Eduard_Munteanu> Wait, no.
19:06:58 <Eduard_Munteanu> hunt: setParserState :: Monad m => State s u -> ParsecT s u m (State s u)
19:07:11 <Eduard_Munteanu> hunt: see Text.Parsec.Prim
19:07:48 <EvanR> hunt: you should only use the state if you have a specific use for it
19:08:00 <napping> setParserState is a different thing
19:08:00 <Kazagistar> hunt: modifyState
19:08:08 <napping> you should use the MonadState instances if you want user state
19:08:09 <benzrf> :t list
19:08:09 <Eduard_Munteanu> Although I don't see a reason you couldn't just use StateT s (Parsec String () a)
19:08:10 <lambdabot>     Not in scope: ‘list’
19:08:10 <lambdabot>     Perhaps you meant one of these:
19:08:10 <lambdabot>       ‘last’ (imported from Data.List),
19:08:12 <benzrf> :t toList
19:08:13 <lambdabot>     Not in scope: ‘toList’
19:08:14 <lambdabot>     Perhaps you meant one of these:
19:08:14 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
19:08:16 <benzrf> ehamberg:
19:08:16 <benzrf> *eh
19:08:35 <EvanR> hunt: to simply parse those commands from earlier you dont need it
19:08:38 <napping> setParserState and stuff are for things like returning a parse result early and then picking up from where you left off
19:08:57 <napping> or pretending a #include file is actually part of a single input stream you are parsering
19:09:33 <Eduard_Munteanu> napping: I only see a 'MonadState s m => MonadState s (ParsecT s' u m)' instance
19:10:32 <hunt> ok i realized i dont actually need it
19:10:39 <hunt> because i cant just use the parse function
19:10:49 <hunt> thats porobably useful though
19:11:00 <hunt> because i have some advanced parsing features that could make use of that
19:11:34 <napping> Oh, I guess it's not that either - but setParserState/getParserState is still for packing up the whole parser state, input and all
19:12:09 <hunt> is there an implementation of Data.Map that doesnt return a Maybe on lookup? i can guarentee that the thing im looking up will be there and id like to error if it isnt
19:12:14 <Eduard_Munteanu> Er, right, I didn't even read... there's a  putState :: Monad m => u -> ParsecT s u m ()
19:12:30 <napping> getState/putState/modifyState are for your user state, which is the "u" type parameter
19:12:43 <napping> you probably don't need to keep a state like that, unless you are parsing something especially tricky
19:12:59 <Eduard_Munteanu> hunt: I've seen an adhoc implementation as part of some other package, but you can just write a wrapper for lookup.
19:13:22 <hunt> Eduard_Munteanu: oh yea sure how dumb that i didnt think of that
19:13:48 <Eduard_Munteanu> hunt: also I think there is an operator already, *looks*
19:14:11 <Eduard_Munteanu> @hoogle M.Map k a -> k -> a
19:14:12 <lambdabot> Parse error:
19:14:12 <lambdabot>   M.Map k a -> k -> a
19:14:12 <lambdabot>     ^
19:14:20 <Eduard_Munteanu> @hoogle Map k a -> k -> a
19:14:22 <lambdabot> Data.Map.Lazy (!) :: Ord k => Map k a -> k -> a
19:14:22 <lambdabot> Data.Map.Strict (!) :: Ord k => Map k a -> k -> a
19:14:22 <lambdabot> Data.Map.Lazy findWithDefault :: Ord k => a -> k -> Map k a -> a
19:14:26 <Eduard_Munteanu> That.
19:15:42 <hunt> (!)
19:17:16 <Kazagistar> hunt: you might also consider (fromMaybe (error "Custom error")) or something
19:18:19 <hunt> is there a way i can detect if the word i just parsed out is actually readable or not? like if i try to use read a on the word a and it fails, how can i try a different parser?
19:18:42 <benzrf> hunt: use ReadS
19:18:47 <benzrf> *reads
19:19:00 <Eduard_Munteanu> hunt: (<|>), if you mean Parsec, though
19:20:00 <Eduard_Munteanu> foobar = Foo <$ word "foo" <|> Bar <$ word "bar"
19:20:20 <enthropy> @hoogle readMaybe
19:20:21 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
19:20:21 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
19:20:38 <ReinH> @hoogle readMay
19:20:39 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
19:20:39 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
19:20:45 <ReinH> Uh. Ok then.
19:20:48 <hunt> :t <$
19:20:50 <lambdabot> parse error on input ‘<$’
19:20:50 <enthropy> Text.Read.readMaybe :: Read a => String -> Maybe a
19:20:53 <hunt> :t (<$)
19:20:55 <lambdabot> Functor f => a -> f b -> f a
19:21:08 <Kazagistar> hunt: dunno, you might consider splitting your parser into a separate tokenizer and parser?
19:21:08 <Eduard_Munteanu> b = () usually
19:21:38 <hunt> benzrf: i cant find any good info about reads
19:21:45 <Eduard_Munteanu> :t reads
19:21:46 <lambdabot> Read a => ReadS a
19:22:01 <Eduard_Munteanu> It's just  String -> (a, String)
19:22:15 <akurilin> Has anybody here figured out how to hash a persistent entity key?
19:22:20 <Eduard_Munteanu> Er.
19:22:51 <akurilin> They don't seem to be hashable by default so I'm trying to figure out a way of making that happen. Challenge is that they're somewhat abstracted from the actual underlying type
19:23:03 <benzrf> String -> [(a, String)]
19:23:05 <Eduard_Munteanu> I forget the exact type.
19:24:26 <hunt> benzrf: id rather get behavior closerf to read, because reads still returns data as long as it can parse the beginning of the string as the type, whereas i want all or nothing
19:25:31 <benzrf> hunt: actually that's not how it works
19:25:37 <benzrf> hunt: 99% of instances do not do that
19:25:45 <benzrf> > reads "34fjsdfi" :: Int
19:25:47 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:25:47 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
19:25:54 <benzrf> > reads "34fjsdfi" :: [(Int, String)]
19:25:56 <lambdabot>  [(34,"fjsdfi")]
19:25:59 <benzrf> oh.
19:26:00 <benzrf> wtf
19:26:01 <hunt> !
19:26:03 <hunt> right?
19:26:10 <benzrf> oh right, i was confusing your statement with something else
19:26:11 <benzrf> mb =p
19:26:15 <hunt> lol damn
19:26:20 <benzrf> just check if there's anything in the second half of the tuple
19:26:23 <hunt> so what do i do? this must be a common problem
19:26:40 <benzrf> hunt: what are you parsing?
19:26:50 <Eduard_Munteanu> hunt: check if the returned string is null
19:27:01 <hunt> Eduard_Munteanu: for reads?
19:27:06 <Eduard_Munteanu> hunt: yes
19:27:26 <hunt> benzrf: i think u suggested something to me earlier, im parsing variables or numbers into my data type that is pretty much Either
19:27:29 <EvanR> using parsec AND reads?
19:27:32 <Eduard_Munteanu> > reads "34" :: [(Int, String)]
19:27:35 <lambdabot>  [(34,"")]
19:27:44 <benzrf> hunt: use parsec's number parser
19:27:55 <benzrf> > reads "34fjsdfi" :: [(Int, a)]
19:27:55 <hunt> benzrf: ah perfect! does it do floats?
19:27:57 <lambdabot>  Couldn't match type ‘a1’ with ‘GHC.Base.String’
19:27:57 <lambdabot>    ‘a1’ is a rigid type variable bound by
19:27:57 <lambdabot>         an expression type signature: [(GHC.Types.Int, a1)]
19:27:57 <lambdabot>         at <interactive>:1:1
19:27:57 <lambdabot>  Expected type: [(GHC.Types.Int, a1)]
19:27:59 <benzrf> hunt: of course!
19:28:05 <benzrf> > parse parseFloat "" "343.45"
19:28:07 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘parseFloat’
19:28:07 <lambdabot>  Perhaps you meant ‘parseFormat’ (imported from Text.Printf)
19:28:10 <hunt> beautiful!
19:28:11 <hunt> lol
19:28:13 * benzrf whacks lambdabot 
19:28:18 <benzrf> > Parsec.parse Parsec.parseFloat "" "343.45"
19:28:20 <lambdabot>  Not in scope: ‘Parsec.parse’Not in scope: ‘Parsec.parseFloat’
19:28:24 <benzrf> well scroo u 2
19:28:27 <EvanR> mm floats, parseFloat "NaN" ;)
19:28:43 <Kazagistar> hunt: if you split your inputting data into a stream of words instead of characters, then each word becomes a single token and you can select by word without consuming input
19:29:17 <benzrf> oh IEEE
19:30:08 <hunt> Kazagistar: im sorry i dont understand how i would avoid consuming input in that case
19:30:47 <hunt> benzrf: i dont see a parseFloat in parsec !!!!
19:31:03 <EvanR> :t (!!!!)
19:31:05 <lambdabot> Not in scope: ‘!!!!’
19:31:22 <Eduard_Munteanu> hunt: http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Token.html
19:31:30 <Eduard_Munteanu> See 'float'.
19:32:23 <benzrf> oops mb
19:34:44 <hunt> Eduard_Munteanu: it seems weird, those parsers cant be run with parse because they take a genTokenParser
19:35:44 <EvanR> hunt: yeah thats something else
19:35:51 <EvanR> for generating a token parser
19:36:06 <EvanR> im not sure if thats what youre trying to do
19:36:10 <Eduard_Munteanu> hunt: define a global gtp = makeTokenParser haskellDef
19:36:36 <Eduard_Munteanu> With haskellDef from Text.Parser.Language.
19:36:41 <Eduard_Munteanu> And use that.
19:37:08 <hunt> ok why haskellDef btw? if were just using floats
19:37:45 <Eduard_Munteanu> hunt: could be any other really, as long as the syntax is the same
19:38:18 <hunt> feels like overkill, no?
19:38:40 <Eduard_Munteanu> Nah, it's fine, you're just using the number parsers anyway.
19:38:55 <hunt> well alright
19:39:14 <Eduard_Munteanu> hunt: besides, it's just a tokenizer, not a full Haskell parser
19:39:20 <LordBrain> so what's the most efficient haskell parsing in the world, that keeps a column number...
19:39:54 <benzrf> :t mapM
19:39:56 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
19:40:07 <benzrf> right
19:40:12 <benzrf> :t concatMap
19:40:13 <lambdabot> (a -> [b]) -> [a] -> [b]
19:40:19 <benzrf> o:
19:40:28 <LordBrain> you're not talking to me are you?
19:41:04 <hunt> Eduard_Munteanu: hm ok, thats fine then. it works too
19:41:28 <benzrf> :t (>>=) `asAppliedTo` []
19:41:30 <lambdabot> [a] -> (a -> [b]) -> [b]
19:43:50 <Luke> heyj: did you get snap installed?
19:43:54 <Luke> i was having that same problem
19:44:02 <Luke> maybe try in the #snapframework channel
19:44:10 <heyj> yah i did
19:44:46 <Axman6> anyone familliar with cabal sandboxes? I'm getting a strange conflict and I have no idea how to fix it
19:45:07 <Axman6> the conflict is rejecting: yesod-markdown-0.9.0 (conflict: temporary==1.2.0.3, yesod-markdown
19:45:10 <Axman6> => temporary<1.2.0.2)
19:46:05 <Axman6> but yesod-markdown seems to be the only package that needs temporary as far as I can tell, so it should install a version which doesn't conflict (this is happening when I use "temporary                >= 1.2.0.    && < 1.3.0" in my cabal file)
19:48:42 <hunt> so how do i parse without consuming input
19:48:56 <Axman6> with which parser?
19:50:27 <Eduard_Munteanu> hunt: 'try parser'
19:50:43 <Eduard_Munteanu> Or do you mean not consuming even if you succeed?
19:51:02 <hunt> no i think try is it
19:51:54 <benzrf> :t try
19:51:55 <lambdabot> Exception e => IO a -> IO (Either e a)
19:51:57 <benzrf>                    
19:59:49 <Axman6> fucking hell. does anyone know anything about sabal sandboxes? mine has magically broken, deleted conduit and now can't figure out what version is had
20:00:13 <Axman6> fuck, I don't even know what's wrong. everything was working, and then it wasn't
20:01:05 <carter> Axman6: cabal install transformers -fthree ; cabal install mtl-2.1.3.1
20:01:09 <carter> then things hsould work
20:01:12 <carter> woops
20:01:14 <carter> i mean
20:01:20 <carter> Axman6: cabal install transformers-compat -fthree ; cabal install mtl-2.1.3.1
20:01:23 <Axman6> I currently have this cabal and error output: http://lpaste.net/104924
20:01:34 <carter> lpaste is down
20:01:38 <Axman6> it doesn't seem to have anything to do with either of those packages
20:01:46 <Axman6> no it's not
20:01:47 <carter> don't care
20:01:49 <carter> try it again
20:01:54 <carter> reloading the page worked
20:01:59 <carter> Axman6: try my fix
20:02:09 <carter> on a clean sandbox
20:02:46 <Axman6> it took like three fucking hours to install everything the other day, I don't want to go through that again!
20:02:58 <carter> create a new sandbox dir then
20:03:07 <carter> i can't help people who are cussing
20:03:11 <Axman6> I didn't even do anything to the sandbox, it just stopped working after I tried to add a dep and then took it out
20:03:12 <carter> unless they pay me
20:03:51 <carter> what dep did you add
20:04:07 <Axman6> yesod-markdown
20:04:19 <carter> @hackage yesod-markdown
20:04:19 <lambdabot> http://hackage.haskell.org/package/yesod-markdown
20:04:48 <carter> can you cabal-install pandoc in the sandbox?
20:04:59 <Axman6> what the hell! I just deleted the damn sandbox and cabal is telling me my package is broken!
20:05:04 <Axman6> how does that even make any sense!
20:05:33 <zzo38> Did they fix it yet so that non-typed splices are possible if they do not type check?
20:06:00 <carter> ok, i'm done
20:06:01 <carter> good luck
20:06:06 <Axman6> I just deleted the sandbox and reinitialised it and it's saying my package is broken.
20:06:25 <carter> Axman6: hearsay isn't an lpaste
20:06:43 <Axman6> what?
20:06:57 <Welkin> use the force, luke!
20:07:10 <carter> "cabal says X" != heres  a paste of what cabal said
20:07:54 <Axman6> http://lpaste.net/104925
20:08:25 <Axman6> the previous paste had the cabal file, which has only one dependency added on top of the ones yesod gives, and has been working fine for a week
20:08:27 <carter> oh
20:08:27 <carter> ok
20:08:36 <carter> Axman6: add --max-backjumps=-1
20:08:39 <hunt> how could i get a word with parsec and guarentee its not empty string
20:08:39 <carter> to you cabal install
20:09:02 <hunt> assuming its separated by spaces then many $ satisfy (/= ' ') works but also returns empty strings
20:09:28 <Axman6> carter: hmm., I do remember doing that when I first installed the yesod stuff... Hopefully that will fix things
20:10:48 <Axman6> it'd be awesome if cabal could tell you why there are conflicts, or at least something more informative than (package is broken)
20:10:49 <EvanR> hunt: if i were using attoparsec for those simple command lines, it would be something like words <- sepBy spaces, and theres no way they would be empty strings
20:11:10 <carter> Axman6: thats called -v2 :)
20:11:11 <EvanR> hunt: but in parsec, it sounds like they are telling you to use a token parser, which seems like the same issue. you cant get an empty string token
20:11:21 <Axman6> heh, right
20:12:20 <carter> Axman6: also say "i'm frustrated and grumpy"
20:12:26 <carter> not "fuckity shit poopers"
20:12:28 <carter> or whatever
20:12:32 <carter> makes me not wanna help you
20:12:39 <carter> k?
20:13:59 <EvanR> say sugar sprinkles and cupcakes
20:14:14 <Axman6> when things break for no good reason, I understandably get angry. when I've done nothing to actually change what's installed and then everything suddenly breaks after a week of work, I get angry that this stuff is still a huge problem after years of development
20:14:39 <carter> Axman6: well shit and poop man, diarrhea everywhere
20:14:57 <Axman6> ok, I'm sorry
20:15:05 <carter> its fine
20:15:11 <carter> i'm just charging my fee
20:15:24 <carter> with a case of show what it felt like to help you while your'e cussing
20:15:28 <carter> :)
20:18:29 <Axman6> well, I guess all my plans to spend all of today writing code are out the window. It'll be hours before I can start again. cabal hasn't even finished resolving dependencies yet, let alone started to install them
20:18:48 <EvanR> Axman6: are you on osx?
20:18:59 <Axman6> yes
20:19:10 <EvanR> im still on an old working version of cabal
20:19:16 <EvanR> im scared to upgrade hearing all this
20:19:42 <carter> Axman6: wait
20:19:47 <carter> what cabal version do you have?
20:19:56 <carter> did you ever update your ~/.cabal//config file?
20:20:00 <carter> theres parallale package builds
20:20:14 <carter> and if you're using 7.8, you can also pass cabal a -j flag to get parallel module builds
20:20:32 <carter> Axman6: "cat ~/.cabal/config"
20:20:41 <Axman6> 1.18.1.2 apparently
20:20:45 <carter> and tell me if theres a "ncpus"  anwherre
20:20:53 <carter> if not, you have an old cabal config file
20:20:57 <augur> haasn: interesting... classically, these are equivalent:   A v B   (A -> B) -> B
20:20:58 <Axman6> there won't be, I never put one in there
20:21:02 <carter> Axman6: no
20:21:14 <carter> its there by default in 1.18/ onwards
20:21:28 <carter> if you update to cabal install 1.20, you'll also get a -j flag you can pas cabal which it can pass to ghc
20:21:36 <carter> ok
20:21:40 <carter> if you wanna speed up builds
20:21:44 <jmcarthur> augur: makes sense
20:21:46 <carter> 1) cabal install cabal-install
20:21:53 <augur> haasn: specializing B = F(alse)   A v F   =   (A -> F) -> F   ~   A = ~~A
20:21:56 <carter> 2) rm ~/.cabal/config
20:22:01 <carter> 3) run "cabal update"
20:22:04 <carter> to refersh the config file
20:22:25 <carter> 4) do you install of deps but add a -j flag
20:22:34 <carter> eg "cabal install -j --only-dep"
20:22:40 <carter> things will go MUCH faster
20:23:21 <Axman6> I swear I updated cabal install this week, but it seems to be the old version
20:23:30 <Axman6> maybe I accidently did that inside my sandbox
20:23:46 <carter> Axman6: is ~/.cabal/bin in your PATH
20:24:16 <carter> or wherever the hell you have as the bin dir for your cabal
20:24:31 <carter> might be ~/Libaries/Haskell/bin
20:24:32 <carter> or something
20:24:35 <Axman6> ~/Library/Haskell/bin is
20:24:39 <carter> ok
20:24:40 <carter> well
20:24:46 <carter> add ~/.cabal/bin in front of that
20:24:54 <carter> because afte ryou update your cabal config, thats where shit will go
20:24:54 <carter> :)
20:25:45 <Axman6> I like the path it has now
20:26:02 <hunt> god damnit! Parsec's token float fails for numbers that are integral, fml
20:26:37 <carter> Axman6: do you want help with your feelings or your engineering
20:26:40 <carter> pick one
20:27:02 <Axman6> I want things to work how they were an hour ago
20:27:22 <carter> well, i'll leave you to your angst then
20:27:35 <carter> i was going to show you how to get fast parallel builds
20:27:37 <carter> but I guess not
20:27:38 <carter> sorry
20:28:08 <Axman6> I'm still following what you told me to, it just doesn't happen instantly
20:28:10 <EvanR> hunt: https://hackage.haskell.org/package/attoparsec-0.10.1.1/docs/Data-Attoparsec-Text.html scroll down to "rational", pretty easy ;)
20:28:24 <carter> ok
20:28:26 <carter> :)
20:28:27 <Axman6> ok, new cabal-install installed
20:28:30 <carter> woot
20:28:31 <carter> check
20:28:33 <carter> cabal --version
20:28:37 <Axman6> I did
20:28:37 <carter> in a new terminal tab
20:28:39 <EvanR> hunt: theres one in ...Char8 too but Text works with any unicode input
20:28:47 <carter> (just to make sure)
20:29:13 <carter> then "rm ~/.cabal/config"
20:29:13 <EvanR> hunt: rational will give you any fractional type you want, include Double
20:29:16 <carter> then "cabal update"
20:29:22 <EvanR> and rejects crap like NaN
20:29:31 <carter> then you'll have parallel package build powers
20:29:33 <EvanR> and works with "3"
20:29:35 <carter> and a really warm computer :)
20:30:01 <hunt> EvanR: should i just use attoparsec then? i kind of love the (usual) elegance of Parsec
20:30:12 <EvanR> they are similar libraries
20:30:17 <EvanR> but attoparsec is simpler
20:30:29 <EvanR> with less feedback capabilities
20:30:43 <carter> hunt: parsec or trifecta are a bit more high level that attoparsec
20:30:51 * hackagebot conduit-extra 1.1.0.4 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.0.4 (MichaelSnoyman)
20:30:57 <EvanR> if its not a programming language id use attoparsec
20:31:03 <carter> if you're parsing stuff humans wrote, parsec/trifecta/parsers  is plenty
20:31:17 <carter> if you're  parsing a protocol, attoparsec makes sense
20:31:45 <Kazagistar> could attoparsec theoretically be used to implement parsec at the cost of some performance?
20:31:53 <hunt> im somewhere in between
20:32:03 <hunt> id rather use parsec because its more human than protocol
20:32:04 <Axman6> carter: do I need to set ncpus or is that something cabal figures out?
20:32:19 <Kazagistar> hunt: complex configuration file format or something?
20:32:21 <carter> Axman6: if you did what i said, it'll just have the right info in the config file
20:32:25 <hunt> but parsec has no number parsing that i can find
20:32:27 <carter> Axman6: cat your config file and lpaste it?
20:32:33 <carter> hunt: easy to add  :)
20:32:37 <carter> and its there
20:32:41 <hunt> Kazagistar: its a command file for a class progect
20:32:43 <EvanR> hunt: alternatively you can parse a basic command line by simply using split and reads on the parts
20:32:51 <Axman6> I did what you said. so jobs: $ncpus should be fine? or do I need to set that?
20:33:24 <Kazagistar> hunt: so, like, a long lists of commands with possible parameters?
20:33:34 <Iceland_jack> carter: What are your thoughts on embedding languages in Haskell to generate efficient code btw?
20:33:34 <Kazagistar> hunt: could you pastebin an example?
20:33:46 <carter> Axman6: sounds like its correct
20:33:52 <jle`> hunt: are you still programming. you are a soldier.
20:34:14 <carter> Iceland_jack: that 7.8.3 needs to come out soon to fix some bugs in stable name in the 7.8 series :)
20:34:30 <Iceland_jack> which bugs are those?
20:34:34 <hunt> jle`: yea dude, although i took a few breaks
20:34:40 <carter> @google stable name bug accelerate ghc 7.8
20:34:41 <lambdabot> https://github.com/AccelerateHS/accelerate/issues/162
20:34:58 <Eduard_Munteanu> Kazagistar: not really, attoparsec isn't a monad transformer and doesn't support layering directly as in Parsec.
20:35:07 <Iceland_jack> yikes!
20:35:08 <carter> i love using google
20:35:09 <carter> :)
20:35:40 <Eduard_Munteanu> Kazagistar: well, you could run the parsers, but not simply replace the underlying monad.
20:36:10 <hunt> Kazagistar:  http://lpaste.net/104927 its pretty protocolly tbh but i want to use parsec really bad
20:36:22 <carter> Axman6: how loud is your computers fan now ? :)
20:36:34 <carter> does activity monitor show the cores being fully used?
20:36:50 <Iceland_jack> I'm was just about to implement observable sharing..
20:36:54 <Axman6> no, only one when using cabal install --only-dependencies --max-backjumps=-1 -j
20:36:55 <carter> Iceland_jack: :)
20:37:06 <carter> Axman6: for ALL those deps?
20:37:16 <carter> Axman6: ohhhhh
20:37:16 <Axman6> it;s still resolving deps
20:37:21 <carter> really?
20:37:26 <Kazagistar> hunt: I still would suggest you do an initial pass with words, and then parse over those
20:37:26 <carter> oh
20:37:34 <Axman6> yeah, it was going for like 10 minutes before I stopped it last time
20:37:52 <carter> Axman6: i bet if you cabal install pandoc -j
20:38:00 <carter> before installing otehr deps
20:38:01 <carter> you'll be ok
20:38:30 <EvanR> Kazagistar: its usually pretty easy to parse all at once with parsec, rather than having a lexical scan step
20:39:30 <Kazagistar> EvanR: how do you select between keywords without backtracking then? characters are not exactly LL1...?
20:39:44 <carter> Iceland_jack: the fix is in 7.8 HEAD i think
20:39:45 <carter> lemme check
20:40:02 <EvanR> Kazagistar: use backtracking
20:40:05 <Axman6> carter: http://lpaste.net/104928
20:40:16 <Iceland_jack> carter: https://ghc.haskell.org/trac/ghc/ticket/9078 'Looks like the next platform will indeed ship with 7.8.2; so maybe it's already too late' this makes me sad
20:40:21 <Axman6> wait, I probably need that flag..
20:40:33 <carter> whats belses?
20:40:38 <carter> sounds like you need to reinstall it
20:40:42 <Axman6> nope, max-backtracks doesn't help
20:40:55 <Axman6> it's the yesod app I;m trying to write. it;s not installed anywhere afaik
20:40:58 <carter> oh
20:41:11 <carter> Axman6: a trick is install the deps explicitly
20:41:24 <EvanR> Kazagistar: i dont think he even has keywords as such
20:41:27 <carter> cabl install pandoc yesod-stack-17777 -j
20:41:28 <carter> or whatever
20:42:03 <Kazagistar> EvanR: really, it should be possible to do LL1 keyword matching without backtracking, since finding which keyword it is out of a set can be optimized into a tree traversal
20:42:20 <carter> Iceland_jack: anyways... this just goes to show that haskell platform isn't a good target to support :)
20:42:42 <Axman6> carter: it won't let me, it keeps saying BelSES is broken when I do "cabal install pandoc yesod-core -j --max-backjumps=-1"
20:42:50 <Iceland_jack> indeed
20:43:00 <EvanR> i know its possible, im saying its a simpler program to write if you dont care about parsing performance, its not like its going to go exponential like perls regexes ;)
20:43:02 <carter> Axman6: .... make a fresh sandbox
20:43:08 <Axman6> again? urgh
20:43:11 <carter> you have parallel pckage builds
20:43:20 <carter> Axman6: oooo
20:43:24 <carter> you didnt add -v2
20:43:26 <carter> add v2
20:43:38 <carter> it gives you the conflict reports
20:44:08 <Axman6> ok
20:44:44 <Axman6> hmm, when I remove yesod-markdown as a dep, things seem to be working fine
20:44:55 <carter> Axman6: did you try -v2
20:44:58 <carter> i need to the infos
20:44:58 <Axman6> yes
20:45:17 <Axman6> and I can see everything downloading and installing and making my lap very hot
20:46:08 <carter> happy? :)
20:46:19 <carter> faster builds
20:46:39 <Axman6> let's hope so...
20:47:16 <carter> Axman6: notice how if you look at activity monitor its using alllll the cores
20:47:31 <Axman6> yeah I'm watching my menubar go very green
20:47:49 <carter> Axman6: i thought you liked fast things :P
20:48:32 <Axman6> I do, I wasn't comp[laining
20:52:12 <EvanR> well i did it. after replacing my algorithms normal floating point ops with overflow checks, i determined the last date i can calculate the mjd for is dec 31 6165091887562, despite the fact that floats has nice integers up to 9007199254740992 ;)
20:52:26 <EvanR> put this new end of the world on your calendars
20:52:30 <EvanR> or dont use floats
20:54:40 <Axman6> carter: well... the install just finished. that was way faster than I was expecting
20:54:51 <carter> Axman6: see why i wasn't taking your shit? :P
20:55:19 <carter> thers a reason why i give very fixed instrutions, :)
20:55:21 <carter> they work
20:56:11 <carter> Axman6: happy now? :)
20:56:17 <Axman6> happier yes
20:56:36 <Axman6> now to figure out the horror that is web development
20:57:26 <Axman6> bootstrap is truly awesome though, I have a really nice looking responsive website without a whole lot of effort
20:58:08 <ion> yeah
21:00:55 <fread2282> is there anything that has a sensible Foldable instance but not a Monad one?
21:01:35 <benzrf> fread2282: a tree?
21:01:40 <benzrf> how do u join a tree
21:01:47 <benzrf> of trees
21:02:03 <Iceland_jack> 'Const m' and ((,) a)
21:02:16 <benzrf> Iceland_jack: eh?
21:02:18 <benzrf> og
21:02:20 <benzrf> *oh
21:02:29 * Iceland_jack cheated by just diffing the instances..
21:03:31 <fread2282> benzrf: substitute the inner trees in
21:04:08 <benzrf> fread2282: what about trees with values on the branches
21:04:16 <benzrf> *binary trees
21:04:41 <hunt> i tried to ghc-mod check with -fno-warn-unused-do-bind but it says its an unrecognized flag :/, if i add -g it just ignores the flag
21:05:17 <jle`> fread2282: most things that are Applicative but not Monad would qualify here
21:05:23 <jle`> like ZipList
21:06:00 <carter> i like ziplist more than the normal list instnace
21:06:06 <carter> at least for my use cases
21:06:17 <benzrf> what is the monad laws in terms of join again
21:06:21 <jle`> pure is unintuitive
21:06:36 <jle`> but i guess it makes sense for ZipList if we were taught and grew up with ZipList
21:06:50 <jle`> actually yeah pure isn't too bad
21:06:57 <benzrf> > pure 3 :: ZipList Int
21:06:59 <lambdabot>  ZipList {getZipList = [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
21:07:03 <benzrf> eeeehhh
21:07:12 <jle`> benzrf: it's the only way fmap can make sense
21:07:16 <benzrf> oh?
21:07:21 <jle`> > (*2) <$> ZipList [1,2,3]
21:07:22 <lambdabot>  ZipList {getZipList = [2,4,6]}
21:07:36 <benzrf> oic
21:07:51 <jle`> and it makes sense in the context of zipping
21:08:01 <hunt> does anyone know about ghc-mod ++ 'fno-warn-unused-do-bind'
21:08:04 <jle`> in that it's sort of an...identity-ish-thing of sorts
21:08:23 <carter> i have a funny version of it
21:08:29 <carter> that makes more sense
21:08:32 <carter> for my static sized lists
21:08:41 <fread2282> jle`: couldn't we just use the normal monad instance?
21:08:42 <carter> pure 3 would be a length n list of 3s
21:08:50 <jle`> fread2282: ap wouldn't be (<*>)
21:08:59 <carter> its <*> that zips
21:08:59 <jle`> @src ap
21:08:59 <lambdabot> ap = liftM2 id
21:09:03 <jle`> ...
21:09:06 <jle`> this gets me every single time
21:09:24 <jle`> ap f x = { f' <- f; x' <- x; return (f' x') }
21:09:37 <jle`> there is no monad such that ap is the ZipList (<*>)
21:09:39 <BMeph> Isn't ZipList the instance for Streams?
21:09:56 <jle`> it makes sense for infinite lists though
21:10:13 <jle`> ....i think
21:10:17 <Iceland_jack>     @src ap
21:10:17 <Iceland_jack>     <lambdabot> ap = (<*>)
21:10:17 <Iceland_jack>     @src (<*>)
21:10:17 <Iceland_jack>     <lambdabot> (<*>) = ap
21:10:20 <jle`> oh, also that Either Applicative
21:10:39 <jle`> where (<*>) mappends the Left values
21:11:05 <jle`> Left x <*> Left y = Left (x <> y)
21:11:17 <jle`> that can't be a Monad
21:11:52 <jle`> but it admits a meaningful Foldable
21:12:38 <jle`> ...huh, why isn't Either a Foldable instance
21:12:59 <jle`> oh it is in 7.8.3
21:13:03 <jle`> er, 7.8
21:13:08 <jle`> but not in 7.6.3, how weird
21:13:09 * jle` shrugs
21:14:10 <fread2282> are there arny monads that don't have sinsible foldable instances though (besides IO)
21:14:14 <fread2282> *any
21:14:42 <ion> STM, ST, Parser, ...
21:14:45 <fread2282> *sensible
21:15:12 <ion> (->) r
21:15:23 <augur> are there any nice haskell sound synthesis libraries?
21:15:43 <EvanR> i saw one for live coding
21:15:44 <copumpkin> State s
21:15:54 <taktoa> euterpea?
21:16:10 <ion> I've seen at least one on Hackage. Haven't tried it yet.
21:16:42 <Axman6> augur: there's at least one person making live music using haskell. can't remember what the genre was though
21:17:12 <carter> ask mzero
21:17:20 <Axman6> augur: http://www.haskell.org/haskellwiki/Synthesizer?
21:17:47 <Axman6> ah, haskore was what I was thinking of
21:18:13 <jle`> i think lambdabot's ap should be liftM2 ($)....makes more sense
21:18:20 <jle`> even though it's identical to liftM2 id
21:18:20 <ion> @type ask mzero
21:18:21 <lambdabot> MonadPlus m => m a
21:18:28 <jle`> lol
21:18:50 <ddellacosta> augur: alternatively, use Haskell for sending OSC and then connect it up with SuperCollider: https://hackage.haskell.org/package/hosc
21:19:33 <EvanR> uhg OSC
21:20:12 <Kazagistar> foldable means you can "exit" a monad with no further information, so any monads that "require input after construction" aren't foldable, right?
21:20:33 <carter> augur: i know mmfreak was working on something
21:20:34 <Kazagistar> *exit a <whatever> rather
21:21:01 <augur> hmm
21:21:28 <carter> rhough more sound syntheis then music synt
21:21:34 <augur> i need the ability to produce tones, harmonics, resonances/frequency envelopes, and noise
21:22:13 <augur> and ideally some way to move things around in real time
21:23:49 <ungov> Hi! About to try clckwrks here, anyone using it?
21:23:50 <carter> augur: sounds like you should talk with mmfreak when hes online
21:23:57 <augur> carter: will do! thanks :)
21:23:59 <carter> ungov: probably not, but it is actively deved
21:24:08 <carter> augur: make sure to ask him patiently :)
21:24:17 <hunt> is there a way for syntastic vim to use ghc-mod lint instead of ghc-mod check?
21:24:25 <ion> I was writing a synthesizer for 64k intros in a horrible language that shall not be named 1 ten years ago, but never finished the project. I'd like to restart it using Haskell and LLVM one day. http://johan.kiviniemi.name/tmp/syna-20040729.ogg
21:24:37 <ion> s/1 //
21:24:50 <carter> ion: llvm-general is a powerful tool :)
21:25:04 <carter> i have some ideas planned that will make me wayyyy to familiar withllvm this summer :)
21:25:09 <jle`> 1 ten years is ten years becuase 1 is the identity for (*) on N
21:25:22 <carter> i expect  to be saying "FML" a lot one way or another
21:25:58 <ion> carter: heh
21:27:00 <carter> ion: if only because building high level things that *just work* portably is a HUGE AMOUNT of work
21:27:58 <hunt> damn syntastic is so hard to get working
21:28:24 <jle`> hunt: have you tried that vim-haskell quick setup pack that was on reddit a week ago or so
21:28:50 <hunt> no ill take a look tho
21:31:42 <benzrf> @src many
21:31:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:31:46 <benzrf> :t many
21:31:47 <lambdabot> Alternative f => f a -> f [a]
21:32:04 <benzrf> > many [1, 2, 3]
21:32:05 <ddellacosta> holy crap, lambdabot is kinda mean huh
21:32:08 <lambdabot>  mueval-core: Time limit exceeded
21:32:15 <benzrf> > take 3 $ many [1, 2, 3]
21:32:19 <lambdabot>  mueval-core: Time limit exceeded
21:32:23 <benzrf> h-huh
21:32:36 <benzrf> > [1, 2, 3] <|> [1, 2, 3]
21:32:38 <lambdabot>  [1,2,3,1,2,3]
21:32:44 <benzrf> o=
21:32:50 <benzrf> how very monoidal
21:32:56 <jle`> such monoid
21:33:04 <jle`> very alternative
21:33:10 <benzrf> jle`: pls
21:33:11 <benzrf> let doge die
21:33:20 <benzrf> it has been a walking corpse for like 6 months now
21:33:24 <benzrf> it needs to go
21:33:26 <jle`> that's just how i normally talk
21:33:28 <jle`> :(
21:33:33 <ion> ddellacosta: She's just tsundere.
21:34:11 <EvanR> doge is being kept alive by coins
21:34:11 <jle`> :t many [1,2,3]
21:34:13 <lambdabot> Num a => [[a]]
21:34:27 <EvanR> i went with coinye myself
21:34:29 <jle`> > take 3 . concat . many $ [1,2,3]
21:34:32 <ddellacosta> ion: I see
21:34:33 <lambdabot>  mueval-core: Time limit exceeded
21:35:28 <ddellacosta> ion: when did tsundere become English anyways
21:35:36 <zwer> @src many
21:35:36 <lambdabot> Source not found. Just try something else.
21:35:56 <ion> benzrf: wow, so weary
21:36:03 <zwer> :t many
21:36:04 <lambdabot> Alternative f => f a -> f [a]
21:36:46 <benzrf> http://www.whompcomic.com/2014/05/21/tsunny-disposition/
21:37:06 <jle`> hm
21:37:12 <jle`> is it because many is defined recursively with sum
21:37:15 <jle`> er, some
21:37:21 <jle`> and [] doesn't override it?
21:37:41 <jle`> > take 1 <$> many (Just 1)
21:37:45 <lambdabot>  mueval-core: Time limit exceeded
21:37:48 <Cale> many/some don't really make sense for lists
21:37:59 <Cale> Or for Maybe
21:38:21 <jle`> so the default recursive implementations are just left as they are...and it doesn't terminate
21:38:44 <benzrf> :t some
21:38:45 <lambdabot> Alternative f => f a -> f [a]
21:38:46 <benzrf> @src some
21:38:46 <lambdabot> some v = some_v
21:38:46 <lambdabot>   where many_v = some_v <|> pure []
21:38:47 <lambdabot>         some_v = (:) <$> v <*> many_v
21:39:08 <benzrf> what is some v many
21:39:10 <jle`> hm, i am wrong
21:39:39 <jle`> they aren't recursively defined...just nonterminatingly defined for many instances of (<|^>)
21:39:50 <jle`> (<|>)
21:41:20 <benzrf> > some (Just 3)
21:41:24 <lambdabot>  mueval-core: Time limit exceeded
21:41:34 <benzrf> > (Just 1) <|> (Just 2)
21:41:36 <lambdabot>  Just 1
21:41:42 <benzrf> > (Just 1) <|> Nothing
21:41:43 <lambdabot>  Just 1
21:41:46 <benzrf> hmm
21:41:56 <benzrf> so alternative is first?
21:42:32 <jle`> for Maybe
21:42:43 <benzrf> yeah thats what i meant p:
21:43:32 <ion> > listToMaybe ([1] <|> [2])
21:43:34 <lambdabot>  Just 1
21:44:00 <ion> > listToMaybe ([1] <|> [])
21:44:02 <lambdabot>  Just 1
21:44:15 <jle`> does that make listToMaybe a monoid homomorphism
21:44:16 <benzrf> aha, i think i see where some works
21:44:22 <benzrf> how is it different from Maybe though
21:44:28 <ddellacosta> newb question: is there anything comparable to Ruby's Gemfile or Clojure's dependencies section (in the project.clj) in Haskell, in terms of identifying dependencies for distributing packages?  RTFM responses with links most welcome
21:44:43 <benzrf> ddellacosta: i think you use cabal files for that
21:45:04 <ion> A canonical example of where some and many are useful is Parser.
21:45:10 <benzrf> duh =p
21:45:19 <ddellacosta> benzrf: okay, thanks, I'll poke around the cabal docs
21:45:19 <benzrf> how does some differ from many though
21:45:24 <carter> ddellacosta: cabal files
21:45:26 <carter> but they're BETTTER
21:45:33 <ddellacosta> carter: wonderful. :-)
21:45:39 <benzrf> jj
21:45:45 <carter> ddellacosta: libraries in haskell take "ranges" of versions
21:45:48 <jle`> so much better that they need three t's to describe how much
21:45:50 <carter> not that gemlock bs
21:46:01 <carter> jle`: BETTTTTTTTTTERRRRRR
21:46:14 <ddellacosta> I see, looks like this is what I want huh? http://www.haskell.org/cabal/users-guide/developing-packages.html
21:46:24 <carter> ddellacosta: theres a lot of ways where cabal isn't perfect, but its always getting nicer
21:46:34 <carter> ddellacosta: kinda, but its kinda hard to learn just from the manual
21:46:36 <jle`> just do a nice cabal init on a new directory and it should tell you what you need
21:46:38 <carter> but its worth skimming a wee bit
21:46:56 <carter> ddellacosta: you'll also probably wanna look at some example projets
21:46:57 <carter> but yeah
21:46:58 <ddellacosta> carter: yeah, these things are often like that.  I expect I'll stumble around a bit and then pick up stuff here and there...as it always goes. heh
21:47:00 <carter> cabal init is magic
21:47:09 <ddellacosta> carter: gotcha, any suggestions for projects?
21:47:24 <carter> i crib tricks from the lens cabal file
21:47:31 <carter> @google lens haskell github
21:47:32 <lambdabot> https://github.com/ekmett/lens
21:47:36 <carter> lens.cabal
21:47:36 <ddellacosta> carter: cool, will check that out.  Thanks!
21:47:37 <ion> Whatever you're motivated to do.
21:47:39 <benzrf> so the key to some/many is that <|> may result differently when evaluated
21:47:41 <benzrf> or something
21:47:57 <ion> Oh, i guess i misinterpreted.
21:49:14 <ion> some (char 'x') parses one or more xs, many (char 'x') parses zero or more.
21:49:23 <benzrf> oh
21:50:21 <carter> ddellacosta: i like your attitude about learning this stuff thogh :)
21:50:21 <trap_exit> If I try to learn Haskell from "The Haskell Report" what am I missing out on?
21:50:23 <trap_exit> Is it comprehensive?
21:50:26 <carter> trap_exit: hahaha
21:50:28 <carter> nope
21:50:29 <carter> :)
21:50:32 <carter> you shouldn't start there
21:50:35 <jle`> trap_exit: "learn haskell"?
21:50:40 <startling> trap_exit, it's close comprehensive, but and hard.
21:50:43 <trap_exit> I'm familiar with Coq + Scheme
21:50:46 <startling> *close to comprehensive.
21:50:53 <ddellacosta> carter: thanks, it's probably just the experience talking. :-)
21:50:55 <trap_exit> I want an intensive way to learn Haskell from first principles.
21:51:04 <carter> trap_exit: read all of edwardk's libraries on hackage
21:51:06 <startling> trap_exit, http://www.haskell.org/tutorial/ is pretty good.
21:51:07 <carter> all of them
21:51:37 <startling> trap_exit, (it's more rigorous than your standard Haskell tutorial)
21:51:41 <carter> trap_exit: http://hackage.haskell.org/user/EdwardKmett
21:51:43 <carter> read all of those
21:51:53 <carter> if you wanna learn what really really clever modern haskell thats well written looks like
21:51:59 <carter> you'll wind up using his libs anyways
21:52:08 <carter> :)
21:52:11 <benzrf> >tfw i will never know haskell as well as edwardk
21:52:25 <carter> benzrf: nah, just work hard and you can too
21:52:27 <jle`> edwardk is a human who bleeds just like you
21:52:29 <jle`> and i
21:52:34 <carter> yeah
21:52:43 <jle`> ...at least i think he does
21:52:55 <benzrf> he bleeds glass
21:52:58 <jle`> edwardk: can you confirm?
21:52:58 <benzrf> because he is a lens
21:53:03 <startling> :/
21:53:11 <carter> nah
21:53:13 <carter> human
21:53:16 <carter> just works hard
21:53:20 <carter> at being cleverer :)
21:53:34 <jle`> the thing about haskell is that with baby steps you can do anythingggg
21:53:47 <jle`> one step at a time
21:53:49 <benzrf> trap_exit: if u REALLY wanna learn about great haskell, http://hackage.haskell.org/package/acme-inator
21:54:38 <trap_exit> alright
21:54:41 <trap_exit> since most responses seems like jokes
21:54:48 <trap_exit> it must mean that there is no better way to leasn Haskell
21:54:52 <EvanR> haskell sucks dont use it
21:55:08 <jle`> trap_exit: i like LYAH
21:55:13 <jle`> @where lyah
21:55:13 <lambdabot> http://www.learnyouahaskell.com/
21:55:16 <carter> trap_exit: i'm half joking an half serious
21:55:22 <trap_exit> jle`: I don't like lyah
21:55:25 <jle`> bitemyapp has a nice step-by-step guide too
21:55:28 <carter> reading edwardk's code and trying to understand it is a good challenge
21:55:28 <benzrf> http://hackage.haskell.org/package/acme-inator is awesome tho
21:55:34 <startling> I would not recommend lyah for trap_exit.
21:55:47 <carter> learn haskell the hard way?
21:55:51 <carter> do we have one?
21:55:52 <carter> oooo
21:55:57 <jle`> ah he has coq and scheme experience
21:56:01 <startling> the "gentle" introduction
21:56:03 <carter> trap_exit: hav eyou seen stephen diehl's docs?
21:56:11 <carter> @google stephen diehl haskel tutorial
21:56:12 <Hodapp> I haven't done a good job learning Coq lately, bleah...
21:56:12 <trap_exit> carter: no
21:56:13 <lambdabot> http://dev.stephendiehl.com/hask/
21:56:13 <lambdabot> Title: What I Wish I Knew When Learning Haskell ( Stephen Diehl )
21:56:20 <jle`> i don't think reading the report would be a good way to learn how to write idiomatic and good haskell code productively
21:56:23 <carter> his tutorial is a very very good speedrun through modern ahskell
21:56:31 <benzrf> http://hackage.haskell.org/package/acme-realworld-0.1.1/docs/Acme-RealWorld.html wonderful
21:56:39 <jle`> it's a great reference on syntax and stuff like that, but...
21:56:39 <trap_exit> carter: that looks very nice
21:56:40 <startling> "When evaluated the semantics of Haskell no longer yield a meaningful value. It's usually written as the symbol ⊥ (i.e. the compiler flipping you off )." <- heh, I always thought this
21:56:54 <carter> trap_exit: lets just say I think Stephen has such a great way of writing docs i wish I could hire him
21:57:07 <carter> also a great hacker
21:57:10 <jle`> trap_exit: also, Simon Marlow's Parallel and Concurrent Haskell book is a good sort of walkthrough through the mind of a modern idiomatic haskell programmer
21:57:13 <trap_exit> carter: I like the pretty colors in the examples
21:57:52 <startling> carter: wow, it just keeps going
21:57:57 <jle`> it also goes through very important common library api's and concepts
21:58:04 <jle`> not in-depth, but enough to know how to use them
21:58:06 <jle`> in a sort of real-world way
21:58:17 <carter> jle`: you should look at stephens tutorial too
21:58:24 <carter> its even more :)
21:58:34 <platz> I'm finding par/conc seems to be a nice case study of Async ;)
21:58:37 <bitemyapp> carter: learn Haskell the hard way is kinda Yorgey isn't it?
21:58:50 <startling> trap_exit, the things you'll probably have trouble with are datatypes (though maybe less so, given Coq), typeclasses, and programming with Monads. THe rest of the language will probably be pretty straightforward for you.
21:58:54 <carter> nope,  http://dev.stephendiehl.com/hask/
21:59:51 <platz> I like the resources here http://www.vex.net/~trebla/haskell/learn-sources.xhtml
22:00:09 <platz> would be great to have some time to do the NICTA exercises
22:01:46 <startling> trap_exit: for typeclasses, http://www.haskell.org/haskellwiki/Typeclassopedia is nice, and for learning to use Monads, http://blog.sigfpe.com/2007/04/trivial-monad.html is nice.
22:01:51 <trap_exit> carter: stephen diehl example is great
22:01:54 <trap_exit> carter: thanks for the suggestion
22:02:26 <trap_exit> gentlemen, ther eis only one thing that can make this better
22:02:36 <trap_exit> is there something like ghci, ... but for haste? (the haskell -> js compiler)
22:02:49 <trap_exit> I would love to have a haskell repl inside of haste
22:02:50 <carter> trap_exit: ghcjs
22:02:58 <trap_exit> carter: why ghcjs instead of haste?
22:03:01 <carter> trap_exit: ask the haste author
22:03:07 <trap_exit> ghcjs looks really heavy weight
22:03:07 <carter> because i like the author
22:03:10 <trap_exit> haste loks much lighter
22:03:13 <carter> trap_exit: i don't care about your feelings :)
22:03:20 <startling> ouch.
22:03:27 <trap_exit> carter: I missed the joke.
22:03:32 <trap_exit> something with weight / fat people?
22:03:58 <carter> trap_exit: no one who has given me that reason against ghcjs has used it
22:04:02 <carter> so its a feelings based claim
22:04:09 <trap_exit> ah
22:04:13 <trap_exit> well fuck it
22:04:16 <trap_exit> you're a good salesman
22:04:18 <trap_exit> instaling ghcjs now
22:04:25 <carter> trap_exit: its still pre hackage release
22:04:29 <carter> but its mostly stable now
22:04:42 <carter> the directions are still a bit intricate
22:04:51 <trap_exit> https://github.com/ghcjs/ghcjs <-- do I have to go from git, or can I just do "cabal install ghcjs" ?
22:05:06 <carter> trap_exit: you should read the readme :)
22:05:16 <carter> it gives pretty detailed directions
22:05:24 <carter> if you get stuck, open a ticket on the issue tracker there
22:05:42 <carter> trap_exit: k?
22:06:20 <trap_exit> nah
22:06:31 <trap_exit> if I can't get it to work, i'll write a polemic rant about why haste is superior
22:06:38 <carter> hah
22:07:00 <carter> file a bug report and things get patched pretty fast
22:07:08 <carter> rants don't do anything but feelings
22:07:23 <carter> theres a lot of neat features the ghcjs devs have put A LOT of time into correclty implementing
22:07:30 <ion> My main issue with ghcjs is the size of the generated code.
22:07:42 <trap_exit> ~/ghcjs$ cabal install ./ghcjs Resolving dependencies... cabal: Could not resolve dependencies: trying: ghcjs-0.1.0 rejecting: bin-package-db-0.0.0.0/installed-608... (conflict: bin-package-db => binary==0.5.1.1/installed-72e..., ghcjs => binary>=0.7 && <0.8)
22:07:46 <trap_exit> well, it fucked upalready
22:07:58 <carter> trap_exit: you didn't read the readme
22:08:01 <carter> you need to read the readme
22:08:13 <carter> i told you
22:08:58 <ddellacosta> so, I want to make it a practice to use sandboxes for all my new projects, but I've already installed a bunch of stuff via cabal.  Is there a good way to get back to a tabula rasa state without reinstalling the Haskell Platform (on a Mac here), or do I not need to care?
22:09:04 <carter> https://github.com/ghcjs/ghcjs/blob/master/README.markdown
22:09:13 <startling> ddellacosta: I think you need to not care, sorry. :(
22:09:13 <trap_exit> carter: I'm reading that
22:09:20 <carter> ddellacosta: haskell platform  don't matter
22:09:23 <trap_exit> and executing the commands:
22:09:23 <trap_exit> $ git clone https://github.com/ghcjs/ghcjs.git $ cabal install ./ghcjs
22:09:23 <carter> easy to reinstall :)
22:09:41 <carter> trap_exit: you need to install cabal-js first
22:09:47 <ddellacosta> startling, carter: wait, so I *should* just reinstall, or not?
22:09:59 <startling> ddellacosta: just install things via cabal
22:10:00 <carter> i'll let startling  take over
22:10:04 <startling> :P
22:10:11 <trap_exit> carter: cabal-js comes up after that line
22:10:18 <carter> nope
22:10:30 <trap_exit> carter: are you reading ?https://github.com/ghcjs/ghcjs/blob/master/README.markdown
22:10:32 <ddellacosta> startling: I see, so, if I use cabal sandboxes from this point onward, it doesn't really matter what I've installed globally, is that the case?
22:10:37 <carter> yup
22:10:39 <startling> ddellacosta: yeah
22:10:48 <ddellacosta> carter, startling: got it, thanks
22:10:58 <carter> git clone https://github.com/ghcjs/cabal.git ; cd cabal ; etc
22:11:15 <carter> trap_exit: pause and take 5-10 min to read that page
22:11:29 <startling> I wish there were a way to avoid recompiling everything in the world every time, but it's probably a hard thing to do.
22:11:39 <carter> startling: theres plans
22:11:41 <carter> but yes tricky
22:11:51 <startling> carter: oh, good to know
22:21:03 * hackagebot shelly 1.5.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.4 (GregWeber)
22:22:22 <hunt> is it better to map $ parse parser string, or to write a parser that parses newlines
22:22:29 <hunt> where string is  lines of the original text
22:22:57 <hunt> sorry, map (parse parser "blah") $ lines string
22:23:04 <hunt> vs. having the parser do that
22:23:18 <DrrewGross> does anyone know why zipWith' is no longer exported from Data.ByteString?
22:23:41 <startling> hunt: no idea. sounds like something to benchmark.
22:25:38 <shachaf> DrrewGross: "no longer"?
22:26:05 <DrrewGross> Yeah. I found where if was first introduced on GitHub
22:26:12 <hunt> startling: in terms of just code style though what sounds nicer
22:26:22 <DrrewGross> the same commit that adds it, also exports it
22:26:32 <DrrewGross> but at some point it was no longer exported
22:26:48 <shachaf> It would help to say e.g. what it is, or to link to somewhere that has it.
22:26:54 <DrrewGross> and it's something I would use right now, so I'm curious what happened
22:27:26 <DrrewGross> zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString ->ByteString
22:27:46 <hunt> anyone here can tell me about how i can use StateT with IO?
22:28:08 <freeman42> yey, finally something that works with IDEA 13 http://www.reddit.com/r/haskell/comments/26zu07/intellij_plugin/
22:28:10 <DrrewGross> https://github.com/haskell/bytestring/blob/master/Data/ByteString.hs, line 1531
22:28:36 <shachaf> Aha.
22:30:29 <johnw> hunt: do you have a specific question?
22:31:23 <shachaf> DrrewGross: Conclusion: It was not removed, just never exported.
22:31:35 <shachaf> DrrewGross: Instead it's "exported" via a rewrite rule.
22:32:47 <shachaf> The rule: {-# RULES "ByteString specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q . zipWith f p q = unpack (zipWith' f p q) #-}
22:33:04 <shachaf> So whenever you use zipWith with the right type, it turns into unpack (zipWith' ...)
22:33:36 <shachaf> pack (unpack (zipWith' ...)) will turn into (zipWith' ...) via some other rewrite rule.
22:33:51 <DrrewGross> https://github.com/haskell/bytestring/commit/2638b4015ea11d3ff7ba9a08217ce917cfa32f17#diff-35d05cfa72d1b6096907e2195484e5c1R46
22:33:52 <shachaf> So things should be OK if you just use zipWith.
22:34:02 <DrrewGross> it was definitely exported at one point
22:34:09 <shachaf> OK, it was exported.
22:34:32 <DrrewGross> I guess I'll rely on the rewrite rule, I think it's a bit uglier though :p
22:34:52 <DrrewGross> explicit pack/unpack in my code just looks wrong
22:36:04 <jle`> hunt: some usage tips --- make as much of your computation in StateT s Identity as possible, and then define your own StateT s Identity a -> StateT s IO a combinator to let you use it in your StateT s IO
22:36:20 <jle`> call it purely or readonly
22:36:24 <shachaf> Removed in the misleadingly-named https://github.com/haskell/bytestring/commit/35277e7ecf07d507e7a7929b0e241218dae6f515
22:36:36 <hunt> jle` ok thanks jle`
22:36:42 <jle`> hunt: or did you have specific questions
22:36:55 <hunt> yea but im actually going to not do stateT tonight because im wiped out
22:37:07 <hunt> so theyre going to wait
22:37:13 <jle`> but anyways, in this way, you can have the "benefits" of a "safe" IO-free monad with state, with the ability to "drop into IO" in specific, sectioned-off parts
22:37:32 <hunt> jle` thats exactly what i need
22:37:43 <DrrewGross> Ah you found it. How? I can never find where code was removed on Git/GitHub.
22:38:11 <jle`> hunt: you can probably write the combinator yourself, it'd be a nice exercise :)
22:38:25 <shachaf> git log -S"zipwith'"
22:38:54 <shachaf> git log -S looks for commits where the number of occurences of a string has changed.
22:38:57 <LordBrain> if you only have a little bit of state, i think i prefer just threading it manually as a tuple in the return values
22:39:33 <jle`> shachaf: that's...amazing
22:39:47 <benzrf> gits cool yo
22:39:59 <jle`> and nothing will ever be the same again
22:40:31 <DrrewGross> sweet, thanks for the tips!
22:41:48 <jle`> hunt: StateT s Identity has the type alias State s, btw.
22:49:57 <ddellacosta> (newb filter) suspect I'm doing something obviously dumb, but: why would compiled executable using gloss (opengl) work fine, but calling it in ghci freeze up (and kill ghci)?
22:50:14 <ddellacosta> calling it = calling main
22:51:00 <bitemyapp> ddellacosta: is it something you can share?
22:51:11 <startling> ddellacosta: http://gloss.ouroborus.net/#FrequentlyAskedQuestionsFAQ
22:51:18 <ddellacosta> bitemyapp: here: http://code.ouroborus.net/gloss/icebox/gloss-head.old-darcs/gloss-examples/picture/Hello/Main.hs
22:51:33 <startling> the short of it is `cabal install gloss --flags="GLFW -GLUT"`
22:51:52 <ddellacosta> startling: ah, I see...thanks!
22:52:07 <ddellacosta> bitemyapp: nevermind, looks like that was it ^
22:52:17 <startling> ghci is threaded in a way some libraries (like GLUT, the default for gloss) get confused by.
22:53:04 <bitemyapp> $help karma
22:53:08 <bitemyapp> @help karma
22:53:08 <lambdabot> karma <polynick>. Return a person's karma value
22:53:40 <bitemyapp> @karma+ startling
22:53:40 <lambdabot> startling's karma raised to 6.
22:56:01 <pdxleif> I've had things work differently when calling into C code when using a compiled app vs ghci.
22:56:21 <Kazagistar> @karma- kazagistar
22:56:21 <lambdabot> You can't change your own karma, silly.
22:56:34 <johnw> is the ghci interaction thread a bound thread, in the same way that the main thread of a compiled app is a bound thread?
22:56:45 <trap_exit> what should I use for server side for a haskwell web app?
22:56:55 <trap_exit> happstack ?
22:56:56 <johnw> trap_exit: how much do you want "done for you"?
22:57:06 <trap_exit> as much as possible
22:57:08 <trap_exit> I want to focus on client side
22:57:09 <johnw> then yesod
22:57:12 <trap_exit> though I do need support for websockets
22:57:17 <johnw> yesod can do websockets
22:57:19 <trap_exit> and make it easy to do a real time chat
22:57:32 <trap_exit> suppose I said "as little as possible" what would you have suggested?
22:57:35 <bitemyapp> yesod is the zombocom of Haskell. you can do anything with zombocom.
22:57:37 <johnw> scotty or wai
22:57:55 <Kazagistar> bitemyapp: ... I get that reference
22:58:03 <sipa> welcome
22:58:33 <jle`> yesod has drawn comparisons to rails
22:58:40 <jle`> with
22:58:44 <EvanR> zombocom :: forall a. a
22:58:55 <johnw> I like yesod for its emphasis on universal type safety
22:58:58 <Kazagistar> yesod is the serpent king, he can do anything...?
22:59:03 <pdxleif> There's also snap
22:59:10 <johnw> yes, snap is highly recommended
22:59:15 <sipa> EvanR: so zombocom is undefined?
22:59:15 <johnw> I would like to learn more about it
23:00:00 <pdxleif> Used snap in prod at my last job.  But that was mostly for backend web services, e.g. no ui.
23:00:01 <trap_exit> where does hapstack fit in ?
23:00:23 <EvanR> :t const fix
23:00:24 <lambdabot> b -> (a -> a) -> a
23:00:34 <EvanR> :t fix
23:00:35 <lambdabot> (a -> a) -> a
23:00:48 <EvanR> :t fix id
23:00:49 <lambdabot> a
23:00:49 <johnw> I don't really have anything to say about happstack
23:01:23 <jle`> isn't it neat from looking at the type signature of fix id that the only thing it could possibly be is bottom?
23:01:44 <sipa> :t undefined
23:01:45 <lambdabot> a
23:01:48 <startling> @djinn forall a. a
23:01:48 <lambdabot> -- f cannot be realized.
23:02:15 <EvanR> "a" is annoying after going through whats necessary to understand rank n types, among other things
23:02:27 <johnw> jle`: yes, parametricity can be pretty amazing
23:02:31 <startling> @djinn (a -> a) -> a
23:02:31 <lambdabot> -- f cannot be realized.
23:02:36 <startling> aw.
23:03:46 <shachaf> I,I foo :: (forall a. a -> forall a. a) -> a; foo k = k ()
23:04:05 <shachaf> Or, rather, foo :: (forall a. a -> forall a. a) -> forall a. a; foo k = k ()
23:04:20 <EvanR> gurgle
23:05:08 <augur> shachaf: that is an awful type
23:05:36 <augur> startling: i dont think djinn can do recursive definitions
23:05:37 <EvanR> so its basically (a -> ()) -> () ?
23:05:45 <startling> augur: oh, I see.
23:05:55 <startling> I thought it was just recursive types, for some reaosn.
23:05:59 <augur> startling: ofcourse, we have this:
23:06:06 <augur> :t let x = x in x
23:06:07 <lambdabot> t
23:06:15 <augur> and
23:06:24 <augur> :t fix
23:06:24 <zzo38> Do you know of any use for a "disjunctive state monad"?
23:06:26 <lambdabot> (a -> a) -> a
23:06:37 <startling> augur: yes, that's where this started
23:06:38 <augur> so they're definable in haskell, but djinn cant do it
23:06:53 <shachaf> EvanR: No.
23:06:55 <augur> because djinn is a simple little program
23:07:09 <EvanR> (() -> a) -> a
23:07:27 <johnw> zzo38: you asked that exactly same question on 2/11/13
23:07:43 <sipa> @djinn (() -> a) -> a
23:07:43 <lambdabot> f a = a ()
23:07:46 <zzo38> johnw: Maybe I did, but I still don't know the answer.
23:07:52 <zzo38> (I also may sometimes forget!)
23:08:02 <johnw> implement it, write some code with it, come back and tell us the result :)
23:08:28 <zzo38> I did implement it, but don't know what uses some people would have for such things.
23:08:35 <shachaf> I think over a year is a reasonable amount of time to wait to reask the same question.
23:08:48 <augur> zzo38: what is the disjunctive state monad?
23:08:49 <johnw> can you show me your implementation being used in an example?
23:08:55 <zzo38> It is like (s -> Either s a)
23:08:55 <EvanR> its very slow spamming
23:09:05 <augur> zzo38: ahh
23:09:11 <johnw> ahh
23:09:15 <sipa> ahh
23:09:22 <johnw> ok, next year this will be really good
23:09:23 <zzo38> However, I have figured it out in quite a different way; as (CodensityAsk (Store s))
23:09:42 <shachaf> I also don't see the previous occurence.
23:09:50 <augur> zzo38: thats state machine can halt
23:09:50 <johnw> http://tunes.org/~nef//logs/esoteric/13.02.11
23:10:00 <johnw> oh, it wasn't #haskell
23:10:03 <shachaf> In a different channel now?
23:10:07 <shachaf> That's a little extreme.
23:10:19 <jle`> > take 3 . map chr . (pure 97 ++) $ repeat 104
23:10:20 <lambdabot>  "ahh"
23:10:24 <johnw> missed the title in my browser, since it was Haskell related chat
23:10:27 <augur> zzo38: that has lots of uses!
23:10:45 <zzo38> augur: Perhaps it does, but I just didn't know what they are!
23:11:14 <benzrf> hmmmmmm
23:11:15 <jle`> (pure 97 ++) is (97:), how silly of me
23:11:21 <augur> zzo38: if you want to simulate a possibly non-terminating process you can use that. s is the state, and either it transitions to a new state, or halts on a value a
23:11:32 <zzo38> I got automatically the Monad and MonadPlus instances too; I didn't have to write them explcitly for this acse because (Store s) is a comonad
23:11:40 <benzrf> if something is a left zero of (<*>), its type arg is necessarily phantom, right?
23:11:55 <Rc43> Has anybody idea about what is specific in 31 March 1981?
23:11:57 <zzo38> augur: I could certainly see already it does that. However, I don't know the use of that.
23:12:01 <Rc43> I am writing little parser from free-format data to unixtime and somehow after this date I get +1 hour.
23:12:03 <Rc43> I am using System.Time for that.
23:12:12 <augur> zzo38: well, simulating state machines, for one
23:12:27 <mikeizbicki> I can compile a program with -ddump-rule-firings to get a listing of which rules fired... but once I know they name of a rule, how do I find the definition?
23:12:46 <hunt>   parsec until a string?
23:12:54 <zzo38> augur: I suppose so, but what about the use of the MonadPlus instance with it?
23:13:04 <augur> zzo38: ?
23:13:32 <johnw> augur: what you described is Either a (s -> s), right?
23:13:50 <johnw> ah, no
23:13:52 <johnw> n/m
23:13:56 <augur> johnw: :P
23:14:05 <augur> you have your distributions wrong! :p
23:14:05 <zzo38> augur: I do not understand your question.
23:14:09 <johnw> i sure did
23:14:13 <augur> zzo38: whats the monad plus instance
23:14:38 <benzrf> hellome: ?
23:14:59 <shachaf> Rc43: DST?
23:15:20 <shachaf> There are so many different things that could happen.
23:15:25 <zzo38> newtype CodensityAsk w x = CodensityAsk { runCodensityAsk :: forall z. w z -> (x -> z) -> z }; mzero = CodensityAsk (\q _ -> extract q); mplus (CodensityAsk f) (CodensityAsk g) = CodensityAsk $ flip (\y -> flip f y =<= flip g y);
23:15:52 <augur> (>>=) :: (s -> s + a) -> (a -> s -> s + b) -> (s -> s + b)   ;   x >>= f = \s -> case x s of { Left s -> Left s ; Right a -> f x s }
23:15:52 <zzo38> Notice that (CodensityAsk (Store s) a) is equivalent to what I described.
23:16:03 <benzrf> :t listen
23:16:04 <lambdabot> MonadWriter w m => m a -> m (a, w)
23:16:06 <Rc43> shachaf, maybe; I tried to google this data but didn't find related to DST
23:16:07 <benzrf>       jjjjjkj
23:16:09 <augur> zzo38: yeah, i dont know what that means, sorry :P
23:16:09 <benzrf> oops
23:16:09 <shachaf> Rc43: You have a .ru IP. https://en.wikipedia.org/wiki/Summer_Time_in_Europe#Russia says "Summer time was reintroduced in the USSR (Moscow Summer Time) on 1 April 1981"
23:16:27 <Rc43> shachaf, about other potential issues -- at least I didn't find nothing special upper this date
23:16:41 <Rc43> schachaf, oh :)
23:16:47 <jle`> i'm sure the russians missed summertime
23:16:48 <johnw> shachaf: good call
23:16:58 <jle`> glad they reinstated the season
23:17:01 <zzo38> augur: It converts the identity and composition of the coKleisli category into the mzero and mplus of the monad. Do you know the Store comonad?
23:17:13 <augur> zzo38: i do, but that doesnt mean i know what you're saying!
23:17:21 <orzo_> does vincent hanquez ever come around here?
23:17:25 <benzrf> e-excuse me
23:17:34 <Rc43> Actually, it is just delayed april fools.
23:17:49 <benzrf> if v is a left zero of (<*>), then the final argument to v's type must be phantom, right?
23:18:00 <zzo38> augur: What about it did you fail to understand?
23:18:07 <augur> zzo38: most of it :)
23:18:09 <augur> dont worry
23:19:00 <zzo38> I can try to describe in another way; mzero just returns the state s and mplus will use the value "a" if possible and can otherwise compose the state transition of "s"
23:19:10 <augur> no dont bother
23:19:22 <zzo38> Is this description good?
23:19:31 <augur> no
23:19:52 <johnw> benzrf: "pure id" is a left zero of <*>, and it doesn't have a "phantom" type, it simply uses the inferred type of the second argument to <*>
23:20:25 <pqmodn_> benzrf: by zero do you mean forall x. v <*> x = v?
23:20:26 <zzo38> Did you notice what (CodensityAsk Predicate) means? It is also another monad which someone has made themself in their own library; I just made it for free.
23:20:29 <benzrf> pqmodn_: yeah
23:20:33 <augur> zzo38: nope!
23:20:59 <augur> hm
23:21:09 <zzo38> It is Data.Searchable.Set. (It isn't a MonadPlus because Predicate is not a Comonad)
23:21:17 <pqmodn_> benzrf: i don't have an answer, but now i'm curious :)
23:21:29 <benzrf> well
23:21:33 <augur> mzero :: s -> Either s a ; mzero = Left
23:21:34 <benzrf> as i see it
23:21:54 <augur> mappend :: (s -> Either s a) -> (s -> Either s a) -> (s -> Either s a)   ;   mappend x y = \s -> mappend (x s) (y s)
23:22:11 <benzrf> if we we have 'v :: f (a -> b)' for some a and b
23:22:18 <benzrf> and 'x :: f a'
23:22:24 <benzrf> both of which are necessary for typechecking
23:22:39 <augur> no there is no mappend for Either
23:22:42 <augur> but
23:22:46 <benzrf> then if 'v <*> x :: f (a -> b)', which is also necessary for type checking
23:23:09 <johnw> v <*> x :: f b
23:23:11 <pqmodn_> benzrf: v <*> x :: f b
23:23:11 <benzrf> then if the (a -> b) is not phantom, b must be equal to (a -> b)
23:23:20 <benzrf> which would be an infinite type
23:23:25 <benzrf> pqmodn_: but if v <*> x == v
23:23:26 <zzo38> augur: Either could be made a MonadPlus if the left type is a Monoid.
23:23:31 <pqmodn_> benzrf: ah
23:23:32 <augur> zzo38: yes
23:23:49 <augur> zzo38: does it behave conjunctively or disjunctively?
23:23:52 <benzrf> does my argument hold water or am i missing something
23:23:53 <augur> or something else?
23:24:14 <Polarina> Why would `cabal install netwire' ever decide I wanted to install version 3.1.0 when 5.0.0 is the latest? :S
23:24:17 <benzrf> @let type InfiniteFunc a = a -> InfiniteFunc a
23:24:18 <lambdabot>  .L.hs:149:1:
23:24:18 <lambdabot>      Cycle in type synonym declarations:
23:24:18 <lambdabot>        .L.hs:149:1-41: type InfiniteFunc a = a -> InfiniteFunc a
23:24:22 <benzrf> eh
23:24:40 <zzo38> augur: If one is right it uses that one; if both are left it is the monoid composition of the left values, is how MonadPlus of a Either would work, I think.
23:24:51 <benzrf> :t Nothing `asAppliedTo` (\v -> v <*> (Just 3))
23:24:52 <lambdabot>     Couldn't match expected type ‘(Maybe (a -> b1) -> Maybe b1) -> b’
23:24:52 <lambdabot>                 with actual type ‘Maybe a0’
23:24:52 <lambdabot>     In the first argument of ‘asAppliedTo’, namely ‘Nothing’
23:25:02 <benzrf> > Nothing <*> (Just 3)
23:25:03 <augur> zzo38: but what happens in mixed cases?
23:25:04 <lambdabot>  Nothing
23:25:14 <benzrf> oh wai
23:25:15 <benzrf> t
23:25:19 <benzrf> lol
23:25:25 <augur> zzo38: er, rather, in both-right cases
23:25:35 <zzo38> augur: The first one is used.
23:25:39 <augur> aha
23:25:53 <benzrf> :t let v = Nothing; x = Just 3; expr = v <*> x; in v
23:25:54 <lambdabot> Maybe a
23:25:57 <benzrf> wweh
23:26:09 <benzrf> what type does Nothing take in this example?
23:26:10 * hackagebot EdisonAPI 1.2.2.1 - A library of efficent, purely-functional data structures (API)  http://hackage.haskell.org/package/EdisonAPI-1.2.2.1 (RobertDockins)
23:26:12 * hackagebot EdisonCore 1.2.2.1 - A library of efficent, purely-functional data structures (Core Implementations)  http://hackage.haskell.org/package/EdisonCore-1.2.2.1 (RobertDockins)
23:26:16 <pqmodn_> what..
23:26:30 <benzrf> pqmodn_: when i write 'Nothing <*> Just 3'
23:26:36 <benzrf> what type does Nothing take
23:26:48 <benzrf> what is the specific type that 'Maybe a' is unified with?
23:26:51 <jle`> benzrf: Num a => Maybe (a -> b), resumably
23:26:57 <benzrf> hmmm
23:26:58 <zzo38> Also, (CodensityAsk (Traced x)) is (Either x) and gives you the MonadPlus instance automatically if applicable (Monoid x => Comonad (Traced x); therefore Monoid x => MonadPlus (CodensityAsk (Traced x)))
23:27:00 <pqmodn_> sorry, i'm also confused. it appears Maybe (a -> b).
23:27:05 <augur> (Left s) (Left s') -> mappend s s' ; (Left s) (Right a') -> Right a' ; (Right a) (Left s') -> Right a ; (Right a) (Right s') -> Right a
23:27:10 <pqmodn_> λ: :t ?x <*> Just 3
23:27:10 <pqmodn_> ?x <*> Just 3 :: (Num a, ?x::Maybe (a -> b)) => Maybe b
23:27:10 <lambdabot> Maybe you meant: v @ ? .
23:27:12 <benzrf> jle`: but the result is Nothing
23:27:13 <jle`> :t (<*>) `asAppliedTo` Nothing
23:27:14 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
23:27:17 <jle`> there ya go
23:27:18 <augur> im not sure i like that behavior, but ok
23:27:19 <zzo38> It is mplus for MonadPlus, not mappend
23:27:22 <benzrf> hmm
23:27:24 <johnw> > (Nothing :: Maybe (a -> b)) <*> Just 3
23:27:26 <lambdabot>  Nothing
23:27:46 <jle`> if you give the whole thing a type signature then it has a concrete type
23:27:57 <augur> er, Left (mappend s s') rather
23:28:02 <benzrf> so yeah, if v <*> x = v, then v must be able to have the type 'f (a -> b)'
23:28:13 <benzrf> implying that v's final type is phantom
23:28:30 <johnw> why does it imply that?
23:28:31 <pqmodn_> in what sense is it phantom?
23:28:40 <jle`> how is that different than Nothing :: Maybe a ?
23:28:45 <zzo38> augur: Yes
23:28:47 <pqmodn_> Maybe a -- a is not a phantom type
23:29:01 <benzrf> pqmodn_: it is, when it's the type of Nothing
23:29:04 <benzrf> isn't it?
23:29:08 <Ainieco> hello
23:29:08 <augur> benzrf: no.
23:29:13 <jle`> hello Ainieco
23:29:17 <benzrf> is there a term for when there is no value of the type in the value
23:29:25 <benzrf> as opposed to when that type doesnt show up on the rhs for any constructor
23:29:30 <pqmodn_> nope, phantom means it's not used in any constructor i guess (maybe there's a more precise definition)
23:29:31 <augur> benzrf: what?
23:29:33 <benzrf> i mis-assumed that phantom covered that p:
23:29:40 <jle`> well...Nothing is a polymorphic constructor
23:29:42 <augur> pqmodn_: thats precisely what phantom means, yes
23:29:50 <benzrf> ok
23:30:08 <jle`> in the same sense as [] and 5, i guess
23:30:20 <benzrf> so
23:30:29 <benzrf> if v :: TypeCons Something
23:30:38 <Polarina> Do the order of packages I list to cabal matter? That is, `cabal install x y' vs. `cabal install y x'
23:30:39 <benzrf> and there is no value of type Something in v
23:30:42 <benzrf> what is the term for that?
23:30:44 <benzrf> it's not phantom?
23:30:47 <zzo38> The MonadPlus for the monad I described at first is a bit more strangely than simply the meaning you described, though. It isn't *quite* the kind of state machines you describe.
23:30:54 <Ainieco> how to split list evenly(almost) into parts? e.g i have list of 17 elements and i want to split it in 4 parts. seeking for function which will give me list containing 4 lists, last list should contain 5 elems
23:30:55 <Kazagistar> XPath has a 170 page standard wtf :(
23:31:08 <Ainieco> since 17 is odd
23:31:09 <augur> benzrf: i see
23:31:11 <jle`> (my guess is polymorphic, but i my disclaimer is that i don't know anything about anything)
23:31:15 <augur> benzrf: that has no name, afaik
23:31:19 <benzrf> lame
23:31:30 <benzrf> ill just call it constructor-specific phantom
23:31:49 <augur> it IS related to phantom types in a way
23:31:54 <jle`> it is result-determined polymorphic
23:32:00 <jle`> like read?
23:32:06 <benzrf> as in, when Right 3 :: Maybe String Int, String is constructor-specific phantom
23:32:11 <benzrf> anyway
23:32:19 <augur> such constructors are injections of phantoms into disjunctions
23:32:29 <Polarina> Why would I be getting this behaviour? http://lpaste.net/104930
23:32:45 <benzrf> what i meant is that if v <*> x = v, then the final argument to v's type is constructor-specific phantom
23:33:08 <johnw> Polarina: netwire wants a newer version of transformers than lens will accept
23:33:10 <augur> Maybe a ~ EitherF (K ()) Id   where EitherF f g a = Either (f a) (g a)
23:33:15 <augur> K a b = a
23:33:18 <augur> Id a = a
23:33:37 <augur> sorry, Maybe ~ that
23:33:37 <Polarina> johnw, but why do `cabal install lens netwire' and `cabal install netwire lens' behave differently?
23:33:40 <benzrf> meaning that empty (the Alternative method) should always be 'empty'
23:33:46 <Kazagistar> Ainieco: what should it do if your list is 14 long? two lists of 3 and two lists of 4?
23:33:51 <johnw> they both fail?  or does one succeed?
23:34:01 <johnw> ah, I see
23:34:06 <johnw> i have no idea!
23:34:12 <benzrf> p:
23:34:15 <augur> so Nothing :: EitherF (K ()) Id a ~ Either (K () a) (Id a) ~ Either () a
23:34:29 <benzrf> so empty in a parser applicative must always fail
23:34:35 <Polarina> johnw, one vomits, the other prefers an outdated version. :S
23:34:49 <johnw> yeah, that's really odd
23:34:49 <benzrf> noooooo that's wrong.
23:34:50 <augur> benzrf: the a in K () a is phantom, which is where Nothing injects into:   Nothing ~ Left ()
23:35:00 <benzrf> augur: i do not know what that means >.>
23:35:05 <augur> benzrf: :P
23:35:21 <augur> it doesnt matter anyway, since the constructors for Either are phantom-y too, by necessity
23:35:23 <benzrf> hmmmmmm
23:35:47 <benzrf> no it's *right*
23:36:08 <benzrf> in any valid implementation of Alternative for a parser, empty must always fail
23:36:09 <startling> Polarina, I bet netwire requires a lens that's not the latest, and "cabal install" goes in order
23:36:11 <pqmodn_> i suppose i would call them polymorphic values. Nothing, 3, Left 'x'
23:36:37 <benzrf> many from Alternative would *not* act like many from Parsec though would it?
23:36:39 <jle`> benzrf: hm.
23:36:48 <benzrf> no wait, it would...
23:37:16 <benzrf> jle`: if empty could succeed, it must produce a value
23:37:18 <jle`> i think fail is the only meaningful semantics for empty in a parser
23:37:21 <Ainieco> Kazagistar: depends on in how many pieces list should be splitted, 12 elem list splitted in 4 pieces should give 4 lists of 3 elems in each
23:37:23 <jle`> because empty <|> p should be p
23:37:23 <benzrf> but it has a polymorphic type
23:37:34 <jle`> if empty was a success, it would be empty
23:37:44 <jle`> but monoid laws say empty <|> p = p
23:37:49 <benzrf> if empty was a success, it would have to return undefined
23:37:54 <Polarina> startling, I don't see netwire depending on lens, neither do I see netwire's dependencies depending on lens either.
23:38:05 <benzrf> although
23:38:07 <jle`> but there is some circular reasoning going on here
23:38:13 <Kazagistar> Ainieco: right, so 14 split into 4 should give... [3,4,3,4]?
23:38:17 <benzrf> another way to look at it is that empty <*> someParser is empty
23:38:27 <startling> Polarina: I guess there's a transitive dependency in common with different versions
23:38:30 <benzrf> but that requires empty's final type to be constructor-specific phantom
23:38:40 <benzrf> meaning that it cannot produce a value!
23:38:46 <benzrf> i-i think
23:38:52 <jle`> i think empty in this sense is just polymorphic
23:38:53 <benzrf> i feel like there's something wrong with what i just said
23:38:57 <johnw> benzrf: I think I'm seeing where you're going
23:39:05 <Kazagistar> Ainieco: or [3,3,3,5]? or [4,4,4,2]?
23:39:18 <jle`> hm actually i think i see what you mean
23:39:38 <benzrf> to be precise, empty has to be able to produce either an infinite type or a 100% polymorphic type
23:39:46 <benzrf> and neither of those things are inhabited other than bottom
23:39:48 <jle`> so basically...bottom?
23:39:51 <benzrf> yea
23:39:53 <zzo38> I also try to think, what use of (CodensityAsk NonEmpty)? It is as a function which takes a natural number, and returns either a value or a natural number not exceeding the input. It is a Monad and a MonadPlus.
23:39:53 <johnw> I *think* that in for empty <*> v = empty, the resulting empty has a forall a. a type, which is never needed and can unify with anything
23:39:54 <jle`> ah
23:40:15 <benzrf> so if empty could parse, it would have to result in bottom
23:40:25 <johnw> you mean, if empty could be asked for its value?
23:40:29 <benzrf> yeah
23:40:41 <johnw> I'm pretty sure that's right
23:40:43 <benzrf> i was talking about a parser alternative, but i guess in general
23:40:55 <johnw> i mean, what kind of value can an empty thing contain anyway?
23:40:59 <benzrf> oh wait, that's trivially true since its type is 'forall a. f a'
23:41:04 <benzrf> i just figured that all out for nothing
23:41:07 * benzrf feels silly
23:41:07 <johnw> :)
23:41:12 <jle`> it's okay, that's the best part of haskell
23:41:13 <Ainieco> > 12 `div` 4
23:41:14 <lambdabot>  3
23:41:20 <Ainieco> Kazagistar: ^
23:41:21 <jle`> or well...of math in general
23:41:30 <jle`> what was external has now been internalized
23:41:39 <jle`> and you have opened new paths of your own insight and thinking
23:41:48 <johnw> the road to wisdom is truly paved with foolishness
23:41:50 <Ainieco> [[list of 3],[list of 3],[list of 3],[list of 3]]
23:42:02 <Kazagistar> Ainieco: I get it, but that is with 12. how do you want 14 items split?
23:42:34 <Ainieco> Kazagistar: remined in last list for simplicity sake
23:42:41 <Ainieco> reminder*
23:43:22 <jle`> you can probably use chunksOf
23:43:36 <jle`> which isn't in the standard libraries but is easy enough to write
23:43:39 <jle`> although that requires two passes
23:43:41 <Kazagistar> Ainieco: if "simplicity" was not the issue, where would you prefer it? evenly distibuted amongst the lists is not that much harder
23:43:48 <jle`> but i don't know how this would be done without two passes
23:43:57 <jle`> if you want the items to remain in order when concat'd
23:44:11 <johnw> jle`: it's in the split library
23:44:35 <Ainieco> Kazagistar: yeah, even distributiln would be nice
23:44:40 <jle`> is split platform?
23:44:45 <Kazagistar> Ainieco: do you want to keep order?
23:45:06 <Ainieco> no
23:45:09 <johnw> jle`: yes
23:45:20 <jle`> oh neat
23:45:30 <Kazagistar> Ainieco: ah, that makes it super easy and efficient
23:46:09 <Ainieco> johnw: thanks for hint on split pacakge!
23:46:16 * hackagebot io-streams 1.1.4.5 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.5 (GregoryCollins)
23:48:32 <augur> people!
23:48:34 <augur> what should i read!
23:51:16 * hackagebot Shellac 0.9.5.2 - A framework for creating shell envinronments  http://hackage.haskell.org/package/Shellac-0.9.5.2 (RobertDockins)
23:51:18 * hackagebot Shellac-readline 0.9.5.2 - Readline backend module for Shellac  http://hackage.haskell.org/package/Shellac-readline-0.9.5.2 (RobertDockins)
23:51:20 * hackagebot Shellac-editline 0.9.5.2 - Editline backend module for Shellac  http://hackage.haskell.org/package/Shellac-editline-0.9.5.2 (RobertDockins)
23:51:23 * hackagebot Shellac-compatline 0.9.5.2 - "compatline" backend module for Shellac  http://hackage.haskell.org/package/Shellac-compatline-0.9.5.2 (RobertDockins)
23:51:38 <Freeman42x> augur, stop reading and start doing xD (bad joke)
23:52:38 <Freeman42x> augur, [2014] Beginning Haskell - A Project-Based Approach, [2011] Learn You a Haskell for Great Good, [2009] Real World Haskell
23:54:57 <jle`> maybe tonight is the night that i learn haskell
23:55:10 <augur> Freeman42x: no no no
23:55:18 <augur> Freeman42x: i dont need something to teach me haskell
23:55:19 <carter> jle`: learn the ffi finally damnit
23:55:25 <Freeman42x> augur, try harry potter then?
23:55:26 <augur> im looking for good papers/etc to read
23:55:46 <Freeman42x> augur, what kind of papers?
23:55:48 <jle`> carter: how is nh doing
23:55:54 <augur> Harry Potter and Type Error of Doom
23:56:01 <carter> augur: ooo
23:56:06 <carter> have you read HPMOR?
23:56:09 <carter> @google hpmor
23:56:10 <lambdabot> http://hpmor.com/
23:56:10 <lambdabot> Title: Harry Potter and the Methods of Rationality | Petunia married a professor, an...
23:56:11 <bitemyapp> carter: I LOVED HPMOR
23:56:17 * hackagebot LambdaShell 0.9.3 - Simple shell for evaluating lambda expressions  http://hackage.haskell.org/package/LambdaShell-0.9.3 (RobertDockins)
23:56:21 <bitemyapp> It was *SO* much fun to read!
23:56:41 <augur> carter: sounds dreadful
23:56:49 <carter> augur: its pretty funny
23:57:01 <carter> like, actually you will be amused
23:57:07 <carter> and find it relatedable kinda
23:57:15 <Ralith> you will laugh your ass off if you have any sense of humor
23:57:23 <Freeman42x> augur, is this `Haskell Report 2010` considered a paper?
23:57:32 <augur> Freeman42x: no>
23:57:54 <carter> if you don't enjoy HPMOR, i'm sure you'll hate logic or well designed experiments
23:57:58 <carter> mebe
23:58:02 <carter> probably
23:58:06 <carter> with high confidence
23:58:21 <carter> and i know you like logic and well designed experiments
23:58:30 <carter> so you'll probably enjoy hpmor
23:58:38 <augur> carter: and yet i wouldnt!
23:58:47 <carter> augur: get off my lawn
23:58:47 <augur> the less wrong ideology is boring and flawed
23:58:51 <carter> yes
23:59:01 <carter> i don't buy into that stuff
23:59:05 <carter> or the way they do it alase
23:59:38 <carter> i come by my stances from experience
23:59:43 <carter> hpmor is funny
