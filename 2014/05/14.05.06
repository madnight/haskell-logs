00:00:05 <Cale> I know I at least fail to reject LEM :)
00:00:15 <atondwal> newsham: how?
00:00:32 <newsham> oh, i think i misunderstood you initially.
00:00:45 <newsham> you want to call a pure function which takes another pure function as an argument
00:00:54 <newsham> but you would like to pass in an impure function
00:00:54 <atondwal> newsham: yeah
00:01:03 <atondwal> newsham: exactly
00:01:05 <newsham> what is the pure function you want to call?
00:01:10 <Guest87869> Cale: i suspected no such machine+proof is known
00:01:22 <atondwal> newsham: Codec.Picture.generateImage
00:01:40 <newsham> and what is the impure function you want to pass in (roughly speaking, what does it do?)
00:01:46 <Cale> "where the proof shows that no proof exists either way"? Which proof?
00:02:47 <Cale> I'm confused :)
00:02:53 <newsham> ahh, you want to provide a (Int -> Int -> Pixel) function, but you want it to be from scheme
00:02:55 <Guest87869> word proof 1 refers to the thing im looking for
00:03:18 <atondwal> newsham: exartly
00:03:24 <newsham> atondwal: why no capture all of the possible pixels into a list or array or something like that, and then write a pure function that gets it from that data structure?
00:03:31 <Guest87869> word proof 2 referes to an empty set of proofs that would prove something about a/the machine halting
00:03:59 <newsham> atondwal: for example, you can use mapM to map your scheme function over the integers and get their result into a list
00:04:20 <newsham> and then you could use    (\n -> list !! n)     to get each pixel from that list
00:04:21 <Guest87869> proof 1 is about existence of proofs, proof 2 is a normal proof
00:04:24 <newsham> that is a pure function
00:04:46 <newsham> (an array would prob be more efficient, but you get the idea)
00:04:52 <atondwal> newsham: ah, good idea. Seems like there ought to be a better way, though..
00:05:35 <Guest87869> heh wikipedia "A particular program either halts on a given input or does not halt."
00:06:12 <Guest87869> basically im asking for a proof that this is false by counterexample
00:06:29 <johnw> writing ((a -> b -> c) -> e -> f -> g) -> (a -> b -> m c) -> e -> f -> m g, requires Applicative m, Distributive m.
00:06:39 <lahwran> Guest87869: I'm pretty sure that's true
00:06:48 <Guest87869> oh?
00:07:10 <Cale> I'll be more careful: I'm pretty sure it's not false :)
00:07:15 <Guest87869> haha
00:07:31 <atondwal> newsham: so I'd have do { list <- mapM (uncurry f) [ x,y | x <- 1..w , y <- 1..h ] ; return $ generateImage (\x y -> list !! (x + w*y)) w h }
00:07:35 <Guest87869> not even wrong
00:07:36 <atondwal> or something like that?
00:07:41 <lahwran> the interesting thing about the halting problem is not the fact that a program-and-input pair has a value of halting-ness, it's that it's impossible to compute the halting-ness in the general case
00:07:46 <lahwran> if I understand correctly
00:07:52 <Guest87869> yes yes
00:07:55 <lahwran> Cale: what
00:07:58 <Cale> After all, not LEM is a contradiction :)
00:08:03 <newsham> something along those lines
00:08:05 <lahwran> Cale: I don't know math this good
00:08:15 <lahwran> Cale: why is what you said different from what I said :s
00:08:29 <atondwal> johnw: well, m is a monad, so it's applicative, but I'm not sure how Distributive works
00:08:55 <ReinH> I wish it were easier to define an isomorphism between an enumerable type and the integers modulo (cardinality of the enumerable)
00:08:58 <johnw> it's not available for IO
00:09:13 <Guest87869> ReinH: theres actually a package for this i saw go through
00:09:24 <Cale> lahwran: In intuitionist logic, you don't accept the law of excluded middle, that P or not P. The only way that one could be upset about verifying a statement of that form is if one was reasoning in such a logic.
00:09:29 <Guest87869> at least, a type for integers modulo somehing
00:09:32 <ReinH> rather than some ad hoc toEnum . flip mod n . f . fromEnum where n = fromEnum (maxbound x)
00:09:41 <atondwal> johnw: a functor is distributive iff it commutes with every other functor?
00:09:43 <ReinH> Guest87869: oh really
00:09:51 <johnw> atondwal: http://hackage.haskell.org/package/distributive-0.4.4/docs/Data-Distributive.html
00:09:52 <lahwran> Cale: this is over my head. /me withdraws from the conversation due to insufficient mathiness
00:10:05 <tac_> Cale: Would you say every logic either accepts LEM or doesn't accept LEM?
00:10:08 <Cale> lahwran: It's okay, in classical mathematics, you're certainly right :)
00:10:08 <ReinH> Guest87869: are you a regular here or actually some random guest? :)
00:10:11 <johnw> I'm not recommending that you investigate using this type class
00:10:13 <newsham> atondwal: if you use an array, it could be more efficient and you can even use tuples as indices
00:10:14 <tac_> ;)
00:10:24 <johnw> just that it's what writing your type required, meaning it can't be done with Monad
00:10:29 <johnw> (with just Monad)
00:10:55 <fikusz> sigh. it makes me skeptical of the quality of the repa library, that they're using tabs mixed with spaces all over the source code.
00:11:12 <lahwran> what is repa
00:11:17 <lahwran> I've seen its name around
00:11:19 <newsham> g'nite and g'luck
00:11:22 <fikusz> http://hackage.haskell.org/package/repa
00:11:26 <atondwal> johnw: yeah, it's ErrorT IO, so looks like that won't work
00:11:29 <lahwran> oh
00:12:32 <fikusz> lahwran: usually it comes up when someone is comparing different array implementations
00:14:31 <Guest87869> i find it odd that after entering #haskell intuitionistic logic suddenly becomes obviously right
00:14:42 <atondwal> newsham: can you help me? I'm not sure how to use arrays?
00:15:01 <atondwal> oh, he left
00:15:06 <atondwal> newsham: thanks!
00:15:22 <johnw> you don't need arrays if you aren't being tested on efficiency
00:15:29 <Guest87869> using LEM seems like you can prove pretty dumb things
00:15:39 <atondwal> johnw: yeah, but it's on large images
00:15:49 <tac_> Guest87869: The big issue, in my opinion, is that without LEM, your life gets a lot more complicated.
00:15:58 <lahwran> LEM = ?
00:16:00 <johnw> atondwal: then i recommend http://hackage.haskell.org/package/vector
00:16:18 <tac_> Law of Excluded Middle, lahwran: https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
00:16:19 <johnw> use a mutable vector to build up the image, then "freeze" it
00:16:20 <Guest87869> tac_: on a personal level, it seems to have simplified so much
00:16:43 <tdammers> could someone enlighten me what the whole Arrow business in HXT is about?
00:16:45 <tac_> LEM (and Axiom of Choice, too) is an axiom that makes a lot of otherwise undecided things equal
00:17:00 <johnw> tdammers: arrows simply generalize things that are like functions
00:17:20 <johnw> tdammers: so they are composable, have identity, and you can use them to turn some A into a B
00:17:46 <tdammers> johnw: it's just that libraries like HXT would typically use either plain functions, or monads
00:17:48 <johnw> tdammers: they are mostly unused in the Haskell community, but HXT uses them
00:17:57 <tac_> One example with Axiom of Choice is that, without it, you don't know whether or not the two most popular definitions of the real numbers are equivalent. But with AoC, they *are* equivalent.
00:18:22 <johnw> well, one thing arrows let you do is to perform analysis on the composition before executing it
00:18:44 <tdammers> ah... hm... you can't do that with monads, can you
00:18:48 <newsham> array ((0,0), (100,100)) [((x,y), f x y) | x <- [0..100], y<-[0..100]]
00:18:50 <newsham> something like that
00:18:50 <tdammers> at least not arbitrary ones
00:18:51 <johnw> no, you cannot
00:18:57 <tac_> LEM also gives you a symmetry between existence and universal quantification. That symmetry breaks badly in intuitionistic logic.
00:18:57 <johnw> not with any monad
00:19:00 <tdammers> I see
00:19:05 <johnw> (I mean, any Monad)
00:19:10 <tdammers> yeah, I understand
00:19:10 <newsham> then you get      a ! (5,7)    to do a lookup
00:19:15 <johnw> you _can_ do it also with applicatives
00:19:17 <ReinH> tac_: a friend of mine loves telling this AC joke: he believes in AC on even-numbered days.
00:19:26 <Guest87869> tac_: doesnt it seem unlikely that despite dropping LEM, a proof that they are not equivalent exists?
00:19:31 <tac_> pretty much, ReinH ;)
00:19:40 <atondwal> newsham: excellent, thank you!
00:19:46 <newsham> so you can do a mapM (\(x,y) -> ((x,y), f x y)      to get all your tuples you need
00:19:51 <newsham> and then use array to build an array out of em
00:20:05 <ReinH> tac_: no one ever laughs. But some people do nod appreciatively.
00:20:16 <tdammers> johnw: but as long as all I want to do is load an XML document and convert it to my internal representation (some record type), it's mostly the same as it would be with a monadic loader, right?
00:20:24 <tdammers> except that I use >>> instead of >>=
00:20:31 <tac_> Oh, a better example. Say you have a continuous function where f(-1) is negative and f(1) is positive. You know that f(x) = 0 *somewhere* right?
00:20:32 <johnw> tdammers: pretty much (and it would be >>> instead of >=>)
00:20:36 <tac_> (But it doesn't! not without LEM)
00:20:39 <tdammers> right
00:20:43 <ReinH> Tordek: lol no :)
00:20:43 <tdammers> thanks
00:20:46 <newsham> docs are here I think http://hackage.haskell.org/package/array-0.5.0.0
00:20:54 * tac_ nods appreciatively. Also kinda laughed a bit.
00:21:20 <johnw> in fact, in the Arrow world there is Kleisli, so that >>> can be exactly the same as >=>
00:21:33 <newsham> fish is cooler looking :)
00:21:43 <ReinH> tac_: because he has a rule, you see... I'll show myself out
00:21:54 <newsham> sleep for real this time.. g'nite all
00:21:54 <Guest87869> tac_: really, do you really need LEM for that, or axiom of choice
00:21:59 <tac_> night newsham
00:22:05 <ReinH> newsham: night :)
00:22:34 <tac_> Guest87869: Some famous statements are certainly "as strong as AC". For instance, that 'every vectorspace has a basis' is known to be equivalent to AoC.
00:22:38 <ReinH> tac_: I will go tell him I found someone who appreciated his joke ;)
00:23:12 <tac_> So without AoC, but with LEM, you have that there exists *some* vectorspace that doens't have a basis. If you were a mathematician, such a statement would hurt you.
00:23:40 <ReinH> but we are but lowly Haskell programmers
00:24:07 <tac_> For a Haskeller, intuitionistic logic is undeniably better.
00:24:10 <ReinH> tac_: is the union of a countable family of countable sets countable? :D
00:24:31 <Guest87869> tac_: that is interesting, if your choice simply eliminated some proofs of obvious facts, thats not that bad. but if the choice changes one fact into another opposite fact, that seems odd to me
00:24:42 <Guest87869> because then its not a matter of taste or mood
00:25:03 <tac_> ReinH: I'm not sure, but I would guess no.
00:25:35 <tac_> Guest87869: Really, I think the lesson I try to live my life by is that even if you call them "axioms", they are still just definitions.
00:25:42 <Guest87869> a countable union of countable sets is countable
00:25:47 <tac_> And you should always try to come up with definitions that make your problem easier to work with.
00:25:55 <Guest87869> well yeah
00:25:59 <ReinH> tac_: it depends on the axiom of (countable) choice :)
00:26:15 <ReinH> tac_: but yes, it is :)
00:26:22 <tac_> Ah well. Interesting.
00:26:28 <ReinH> http://www.proofwiki.org/wiki/Countable_Union_of_Countable_Sets_is_Countable
00:26:38 <tac_> But even distinctions, such as 'countable' aren't always even important to your problem.
00:26:46 <ReinH> this is the unimaginatively named Countable Union Theorem
00:26:52 * hackagebot Wired 0.3 - Wire-aware hardware description  http://hackage.haskell.org/package/Wired-0.3 (EmilAxelsson)
00:27:16 <tac_> So it peeves me when people get hung up on the distinction between countable and uncountable. The fact something is infinite is often damn well good enough!
00:27:18 <ReinH> tac_: AC is still surprising to me.
00:27:33 <tac_> ReinH: Do you know this variant of AoC?: Every surjection has a right-inverse.
00:27:56 <ReinH> tac_: also I blame Cauchy for... everything
00:28:05 <ReinH> tac_: actually no!
00:28:07 <ReinH> huh
00:28:20 <ReinH> well ok, sure
00:28:23 <Guest87869> unconstructive weirdo objects in space dont scare me ;)
00:28:59 <tac_> I think... but I'm not sure, but I think that "every injection has a left inverse" is equivalent to LEM. At the very least, I think it's implied by it?
00:29:02 <ReinH> tac_: iirc Cantor proved the countable union thing in the 19th c
00:29:20 <kylec01> ^
00:29:21 <Guest87869> tac_: earlier did you mean to imply that without LEM, there exists some continuous function that goes from negative to positive without being zero somewhere in between?
00:29:27 <ReinH> but before CH
00:29:31 <tac_> Guest87869: yes.
00:29:34 <Guest87869> wow
00:29:40 <Guest87869> i want to look that up
00:29:56 <tac_> oh hmm
00:30:20 <tac_> I uploaded this a while ago to YouTube
00:30:26 <tac_> It's Andrej Bauer, who's amazing
00:30:26 <tac_> https://www.youtube.com/watch?v=zmhd8clDd_Y
00:30:35 <Guest87869> it would be interesting that a vanishing tool (rather that asserting its opposite) cause some object to exist
00:30:51 <ReinH> tac_: ooh :)
00:30:53 <tac_> That talk is really great. Watch the whole thing.
00:30:58 <ReinH> tac_: awesome thanks
00:31:04 <tac_> He explicitly mentions the continuous function fact I mentioned
00:31:20 <Guest87869> well i guess thats implied by the name, by asserting the law, you exclude the middle ;)
00:31:25 <Guest87869> interesting
00:31:34 <Guest87869> ill have to watch that video when im not sleep deprived
00:31:43 <ReinH> tac_: so the version of AC that I'm most familiar with is something like... if T is a disjoint collection of non-empty sets, there exists a set C which consists of exactly one element from each set in T
00:31:57 <tac_> yep
00:32:09 <tac_> I like the version from HoTT
00:32:11 <ReinH> there are some equivalent definitions that are... surprising
00:32:24 <ReinH> like "The cartesian product of a set of non-empty sets is non-empty"
00:32:57 <ReinH> to which I want to say "well duh"
00:33:35 <tac_> Let R be a relation on AxB. If for every x, there MERELY exists a y such that xRy, then there exists a function f : A -> B such that for all x in A, xRf(x)
00:33:49 <tac_> err bah, there MERELY exists a function f : A -> B***
00:34:46 <ReinH> tac_: equivalently, iirc, "for every relation R there is a function f such that the domain of f is equal to the domain of R and f is a subset of R"
00:35:17 <tac_> yep
00:36:00 <ReinH> tac_: another one that seems self-evident but is equivalent to AC: for all sets X and Y, either X is equivalent to a subset of Y, X is equivalent to Y, or Y is equivalent to a subset of X
00:36:41 <ReinH> tac_: infinity is bothersome.
00:36:47 <tac_> a general principle is that if a notion has many intriguing definitions, it's probably an important notion
00:37:03 <ReinH> indeed
00:37:06 <mr-> tac_: I could not find anything about LEM and inverses for injections, but that LEM implies the existance of an inverse. :-/
00:37:25 <tac_> no?
00:37:26 <tac_> hm
00:37:28 <ReinH> tac_: oh also Zorn's Lemma. :)
00:37:28 <Guest87869> infinite stuff makes sense
00:37:37 <tac_> It was just a conjecture I came up with. I should have mentioned that >___>
00:38:01 <mr-> tac_: bummer. I liked the symmetry to the AoC
00:38:09 <ReinH> tac_: that one is the basis for "a vector space has a basis" iirc
00:38:20 <tac_> Just because I made it up doesn't mean it's proven hopeless yet!
00:38:59 <mr-> I wouldn't know ;-)
00:39:49 <ReinH> tac_: (Zorn's Lemma is something like, if X is a non-empty poset where every totally ordered subset has an upper bound in X then contains at least one maximal element")
00:40:01 <ReinH> *then X contains
00:40:05 <tac_> yeah
00:40:09 <tac_> Zorn's lemma is a really useful form
00:40:30 <tac_> You can use it to prove every vectorspace has a basis and every ideal of a ring is contained in a maximal ideal
00:40:46 <ReinH> tac_: yeah I mentioned the former just now :p
00:40:49 <ReinH> wasn't aware of the latter
00:41:46 <arj> Say I have a data MyData = A String | B String | C [MyData]. And I want to map a function over all A's strings. How would I do that? fmap doesn't work as the kind is wrong.
00:41:59 <arj> Is there some other type class for that?
00:42:07 <tac_> arj: Why wouldn't functor work?
00:42:17 <tac_> You need to define a functor instance, but it looks like it should all work to me
00:42:19 <ReinH> tac_: and there are some interesting cardinality result that require AC
00:42:23 <ReinH> *results
00:42:36 <arj> tac_: maybe I am doing it wrong, but functor needs something of ind * -> * and MyData is of kind *
00:42:42 <tac_> oh
00:42:43 <ReinH> tac_: MyData is the wrong kind
00:42:45 <tac_> oops, yes
00:42:52 <tac_> Right
00:43:46 <fizruk> arj: either change your type and move String to parameter or make Traversal
00:44:06 <fizruk> arj: I bet you want first, as in data MyData a = A a | B a | C [MyData a]
00:44:10 <tac_> Does traversal require any laws?
00:44:11 <ReinH> tac_: e.g., if X is an infinite set, Y is a non-empty set, and |X| >= |Y|, then |X*Y| = |X|
00:44:29 <tac_> yeah
00:44:51 <fizruk> arj: that way you are now able to define (or even derive) Functor instance for MyData (since it now has kind * -> *)
00:45:40 <arj> fizruk: And if I additionally want to replace all A's with B's? within an instance?
00:45:45 <ReinH> tac_: oh I forgot about my favorite result from AC
00:46:01 <arj> then probably traversal would be good, too, wouldn't it?
00:46:08 <ReinH> tac_: the Banach-Tarski "we've secretly replaced your ball with two balls" paradox
00:46:08 <fizruk> arj: why would you want that?
00:46:46 <fizruk> arj: note that fmap *should not* change structure’s shape
00:46:57 <ReinH> Well, cannot if it is law abiding ;)
00:46:58 <arj> fizruk: MyData is similar to a term and I want to reduce one step using the nonterminals.
00:47:07 <arj> and A are nonterminals.
00:47:44 <arj> and I want to reduce all nonterminals present in the current term instance. Thus I thought about mapping a reduction function on all of them (changing the structure, of course!)
00:47:47 <fizruk> arj: I’d suggest to separate that step from mapping
00:47:57 <ReinH> tac_: that one still blows my mind
00:48:20 <fizruk> arj: that seems more like folding, not mapping
00:48:36 <ReinH> something something uniplate
00:48:40 <tac_> ReinH: I need to teach you about synthetic differential geometry, I think
00:48:46 <ReinH> tac_: seems good :)
00:48:55 <ReinH> tac_: you know the thing I'm referring about ofc
00:49:00 <arj> fizruk: yeah now that I think about it, folding makes more sense. Thanks!
00:49:02 <ReinH> *referring to
00:49:27 <tac_> ReinH: http://www.math.ias.edu/~mshulman/papers/sdg/pizza-seminar.pdf
00:49:39 <ReinH> tac_: ooh thanks
00:50:41 <tac_> Premise: You throw away AoC and LEM. You replace them with a new Axiom that says (essentially) the reals have a nontrivial subset D of elements where d in D satisfy d^2 = 0. Moreover, every function f : D -> R is affine (that is, there are reals a and b such that f(d) = ad + b)
00:50:52 <tac_> Now every funciton you can construct is smooth. All of them.
00:51:31 <tac_> Also, the paper shows how in < 15 pages, you can build up all you need for lie groups
00:51:53 <tac_> And like 5 of those pages are discussing constructive mathematics, and the last 2 are talking about sheaf models to justify why the axiom isn't bullshit.
00:52:14 <ReinH> tac_: fun!
00:52:18 <tac_> But the proofs end up looking exactly like how you'd see in a physics class.
00:52:26 <ReinH> ok I like this
00:52:27 <ReinH> thanks!
00:52:48 <tac_> f(x + d) is literally equal to f(x) + f'(x)d for all infinitesimals d in D.
00:53:18 <tac_> Unlike nonstandard analysis (which also has infinitesimals), the equality is literal, not approximate. And there are no infinite values.
00:54:12 <fizruk> tac_: looks like dual numbers
00:54:47 <tac_> fizruk: the section at the end shows you how the sheaf model is effectively a sheaf of dual numbers... or something a lot like them.
00:55:12 <ReinH> tac_: ok bed time ttfn
00:55:17 <tac_> night
00:58:06 <tac_> fizruk: actually, the last page even mentinos the dual numbers by name ;)
01:02:29 <fizruk> I see, to bad I don’t understand half of it :)
01:05:19 <tac_> Neither do I, but it's neat as hell!
01:08:35 <fizruk> :)
01:22:01 * hackagebot ghc-mtl 1.2.1.0 - An mtl compatible version of the Ghc-Api monads  and monad-transformers.  http://hackage.haskell.org/package/ghc-mtl-1.2.1.0 (DanielGorin)
01:22:03 * hackagebot hint 0.4.2.0 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.2.0 (DanielGorin)
01:39:31 <Tordek> OMG I implemented an actual monad and it actually sorta works and stuff
01:39:48 <Kinnison> does it meet the monadic laws?
01:40:05 <Tordek> well, I'm kinda just using "StateT m IO m" but I mean technically
01:40:24 <Kinnison> hehe
01:40:35 <Tordek> in a more serious note
01:40:59 <Tordek> I'm implementing an emulator of sorts, so I have "type Instruction a = S.StateT Memory IO a"
01:41:32 <Tordek> imageine I'm not actually using StateT but my own implementation... would it make sense to make >>= advance the program counter?
01:42:28 <quicksilver> no.
01:42:36 <quicksilver> as a rule of thumb, anyway.
01:42:48 <quicksilver> otherwise "return ()", which you'd expect to do nothing, would advance the program counter.
01:43:20 <quicksilver> the monad laws mean that the number of ">>=" is not invariant - it can be rewritten - so it's not a good measure for PC
01:43:32 <Tordek> ah, good
01:44:01 <Tordek> because I was gonna say "well... return () is nop, and nop is meant to advance the counter and do nothing"
01:44:50 <Kinnison> You'd have to be superduper careful, esp. if you use do syntax sugar
01:45:09 <Kinnison> I'd recommend you have an 'advancePC' function
01:45:14 <Tordek> yeah, I do
01:45:23 <Tordek> addF z = readPos z >>= \m -> onAccumulator (+ m) >> advanceCounter
01:45:28 <Tordek> jPosF  z = conditionalJump z =<< withAccumulator (>0)
01:45:30 <Tordek> et al
01:45:38 <Kinnison> nod.
01:46:02 <Kinnison> I prefer it to be explicit because sometimes it matters when the PC is advanced, consider 'jump and link' type operations
01:47:13 <Tordek> I just realized I got myself into a pickle... there's a halt operation that should end the execution, but I don't think I can handle that scenario with my current thingie
01:47:43 <Tordek> unless I do something like... StateT Memory (MaybeT IO) a or however those are nested
01:48:00 <Tordek> and I can return just/nothing when I'm done?
01:50:12 <Tordek> also, I'm having problems visualizing in which order to nest stuff, like, should it be MaybeT (StateT Memory IO a), or StateT Memory (MaybeT IO a) or StateT Memory (IOT Maybe) a?... is there such a thing as IOT?
01:55:08 <fizruk> Tordek: consider using free monads: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
01:56:03 <fizruk> Tordek: the working example in that post should be close enough to what you are trying to achieve
01:56:24 <vozz> Is there an elegant way of dealing with layers of monad transformers? For example, if you had the IO monad transformed by a web framework monad transformed by an HTML templating monad transformed by a flash message monad, is there a way to use it without having to resort to long strings of lift . lift . lift before every function you want to use?
01:57:05 * hackagebot concurrent-extra 0.7.0.7 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.7 (RoelVanDijk)
01:57:32 <fizruk> vozz: liftIO ?
01:58:00 <niao> Oops, my bad
01:58:24 <vozz> fizruk: That only works for IO though
01:58:54 <vozz> what about the ones for the web framework? You'd have to use two lifts
01:58:55 <fizruk> vozz: there are also MonadX classes which help you avoid lifting
01:59:10 <Tordek> fizruk: thanks!
01:59:12 <vozz> I'll check them out, sounds interesting
01:59:31 <fizruk> vozz: e.g. MonadState provides get and put functions
01:59:33 <fizruk> :t get
01:59:33 <lambdabot> MonadState s m => m s
01:59:36 <fizruk> :t put
01:59:37 <lambdabot> MonadState s m => s -> m ()
02:01:01 <fizruk> vozz: `State s`, `StateT s IO`, `ErrorT e (StateT s IO)` all are instances of MonadState, so you can just use get/put without lifting
02:05:50 <vozz> fizruk: Oh, that's awesome, just what I was looking for!
02:08:55 <jle`> Tordek: looking back, i think if return () doesn't do nothing, you are violating the monad laws big time
02:09:31 <jle`> but i think someone mentioned that
02:09:34 <jle`> cool
02:10:33 <jle`> Tordek: there is no IOT
02:13:27 <fizruk> jle`: there can be FreeT IO though :p
02:13:51 <jle`> fizruk: i hadn't considered that
02:13:52 <jle`> :O
02:14:03 <jle`> :|
02:14:16 <jle`> what would FreeT IO [] look like..
02:17:03 <fizruk> jle`: it would be smth like [ IO [ IO [ … ] ] ]
02:18:07 <fizruk> jle`: you might e.g. run list of IOs in parallel
02:18:59 <jle`> something feels fishy
02:19:44 <merijn> "FreeT IO" is an interpreter/prompt loop
02:21:09 <fizruk> simple “interpreter/prompt loop” better suits `Free IO` I think
02:22:39 <warpy> i forgot i was here
02:28:04 <merijn> fizruk: hmm, I guess you're right
02:28:44 <randomclown> lol at reddit bitching about #haskell
02:30:04 <merijn> randomclown: Well, it's correct to observe #haskell is less likely to give elaborate explanations. But this is mostly due to the fact that decent intro texts (like LYAH) are now available. Explantions from #haskell should be to clarify things you don't understand about LYAH, etc. not to explain what you could read yourself
02:30:50 <randomclown> If they are crying about #haskell, they haven't seen the Nazi state of #c
02:30:53 <merijn> Well, that and there's an increase in "cabal is broken on my system"-questions that I, at least, can't be arsed to answer. Given the various braindead ways linux distros seem to butcher the platform
02:31:13 <randomclown> #c will bend people over and gas their parents
02:31:20 <merijn> @quote orbitz.makes
02:31:20 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
02:31:30 <tdammers> merijn: honestly, haskell-platform on debian hasn't given me a single problem so far
02:33:29 <randomclown> tdammers: you haven't seen the disaster known as ghc 7.6 and ubunto 12.04
02:34:05 <Maior> randomclown: could there be slightly fewer such analogies please?
02:34:10 <tdammers> I tend to stay away from ubuntu
02:34:17 <tdammers> ten-foot pole and all that
02:34:39 <randomclown> Maior: 7.6 missed the package gap, and needs to be rebuilt, a 7 hour journey
02:34:48 <randomclown> compiled from scratch*
02:36:45 <Maior> randomclown: I meant with respect to #c
02:37:11 * hackagebot snap-web-routes 0.2.0.0 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.2.0.0 (lukerandall)
02:38:19 <randomclown> Let's not talk about that channel
02:38:44 <Maior> I fear you've missed my point, but that seems a reasonable compromise
02:46:16 <tulloch> is there an idiom for doing a bottom-up traversal of a tree-structure, where the results from the children nodes can be used by the operations on the parent nodes?
02:46:57 <Kinnison> depth first traversal?
02:47:00 <randomclown> tulloch: memoisation?
02:47:03 <randomclown> or dynamic programming
02:47:38 <randomclown> top-down is apparently memoisation
02:47:42 <randomclown> and bottom up is dynamic programming
02:48:08 <merijn> randomclown: The two things are identical
02:48:12 <tulloch> randomclown: Kinnison: Yeah, I was wondering if there was a function on Traversable or something that had that operation
02:48:21 <randomclown> merijn: there's a distinction
02:48:36 <merijn> randomclown: According to CLRS you can do dynamic programming using "top down memoisation" or "bottom up memoisation"
02:48:52 <randomclown> merijn: yeah subseteq isn't the same as equality
02:49:37 <randomclown> https://stackoverflow.com/questions/6184869/what-is-difference-between-memoization-and-dynamic-programming
02:49:41 <merijn> randomclown: Your claim was that bottom up is dynamic programming and top down is not
02:50:20 <merijn> randomclown: Yeah...I'm going to take CLRS over a stack overflow answer here
02:51:20 <randomclown> memoisation \in dynamic programming
02:51:22 <randomclown> done
02:52:50 <arj> anyones knows of a mapi in standard packages?
02:53:10 <arj> i.e. mapi :: (a -> Int -> b) -> [a] -> [b]
02:53:46 <edofic> @hoogle :: (a -> Int -> b) -> [a] -> [b]
02:53:47 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:53:47 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:53:47 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
02:54:05 <fizruk> @hoogle imap
02:54:05 <lambdabot> package imapget
02:54:06 <lambdabot> package bimap
02:54:06 <lambdabot> package multimap
02:54:39 <merijn> Way to complicated
02:54:53 <merijn> arj: You just want to include the index of elements in your map?
02:54:55 <fizruk> I guess lens’s Indexed class is most close
02:55:05 <merijn> arj: Just zip with [0..] and use uncurry
02:55:16 <merijn> :t uncurry
02:55:17 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:55:28 <arj> merijn: sure, just wondered if there is something
02:55:32 <merijn> :t \f -> map (uncurry f) . zip [0..]
02:55:33 <lambdabot> (Num a, Enum a) => (a -> b1 -> b) -> [b1] -> [b]
02:56:00 <merijn> arj: I'm guessing it doesn't meet the Fairbairn threshold
02:56:01 <fizruk> :t \f -> zipWith f [0..]
02:56:02 <lambdabot> (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
02:56:12 <merijn> fizruk: oh, true
02:56:32 <arj> fizruk: oh zipWith, sure!
02:56:40 <arj> merijn: what threashold?! :-)
02:57:14 <merijn> arj: The Fairbairn threshold is invoked during bikeshedding about libraries. It is the threshold "below which it is easier to reinvent a function than remember it exists"
02:57:42 <arj> so I even remembered a function that doesn't exist ;-)
02:57:42 <fizruk> :t imap
02:57:43 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
02:57:55 <merijn> i.e. if it's trivial to build something from existing generic combinations it might not need a function in the libraries. As every extra function in the library is a function that you need to remember exists
02:58:34 <klugez> arj: Vector has imap :: (Int -> a -> b) -> Vector a -> Vector b
02:59:04 <arj> merijn: true, however, there is hoogle for that
02:59:08 <arj> or code completion
03:00:46 <fizruk> > imap (+) $ M.fromList [(1, 2), (3, 4), (5, 6)]
03:00:48 <lambdabot>  fromList [(1,3),(3,7),(5,11)]
03:01:33 <fizruk> > imap (+) [1, 2, 3]
03:01:34 <lambdabot>  [1,3,5]
03:01:52 <fizruk> > imap (+) (1, 2)
03:01:53 <lambdabot>  (1,3)
03:02:05 <edofic> did anyone try to make something like meteor.js but using haskell(or derivative that compiles to js) yet?
03:02:14 <klugez> fizruk: Is that imap from lens?
03:02:22 <fizruk> klugez: yep
03:03:46 <fizruk> @check \xs -> imap (+) xs == zipWith (+) [0..] xs
03:03:47 <lambdabot>  +++ OK, passed 100 tests.
03:04:08 <klugez> fizruk: Surprisingly understandable type signature for a lens function. :)
03:04:11 <Kaidelong> @ty imap
03:04:12 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
03:04:37 <supki> :t imapped
03:04:37 <Kaidelong> @ty mapi
03:04:38 <lambdabot> (FunctorWithIndex i f, Indexable i p, Settable f1) => p a (f1 b) -> f a -> f1 (f b)
03:04:38 <lambdabot>     Not in scope: ‘mapi’
03:04:38 <lambdabot>     Perhaps you meant one of these:
03:04:38 <lambdabot>       ‘mapM’ (imported from Control.Monad.Writer),
03:04:54 <yac> what should I use for reading ini files?
03:04:54 <klugez> That's more lens-like!
03:05:35 <dagle> yac: ini files as in arbiteray config files or a specific format?
03:06:10 <yac> well, ini files. Is there more than one ini file format? What is arbitrary about ini format?
03:07:52 <dagle> More like some programs might hijack the filename extentions.
03:08:18 <yac> I am looking at http://hackage.haskell.org/package/ConfigFile-1.1.1/docs/Data-ConfigFile.html right now
03:08:24 <fizruk> @hackage ini
03:08:24 <lambdabot> http://hackage.haskell.org/package/ini
03:09:04 <randomclown> is there something like ipython-notebook
03:09:10 <randomclown> ihaskell-notebook would be epic
03:09:17 <jle`> imap feels ... not lensy at all
03:10:18 <dagle> The lisper inside me wants imap to be map/idx.
03:10:28 <dagle> Or something like that.
03:10:40 <quchen> The Haskeller in me wants division not to be an operation on functions ;-)
03:11:56 <quchen> yac: Do you have an ini file you want to read, or do you want to generate a configuration file? 'configurator' works great for the second case.
03:12:03 <yac> read
03:12:08 <dagle> Well, it's more convient that writing "with" in all function names.
03:12:13 <dagle> than*
03:12:13 <fizruk> yac: then perhaps “ini” ?
03:12:25 <nclarke> Surely it's just the function mapping into the quotient space :-)
03:13:16 <zgredzik> Is it possible, and if then how, to generate lenses for typeclasses?
03:15:31 <pranz> zgredzik: how do you mean?
03:16:32 <yac> you could give me an example how to access a value from the Data.Ini.Ini  ?
03:16:58 <yac> oh, there are reading functions
03:25:28 <zgredzik> pranz: I have a data type Image that has a map of channels inside it, and I'm accessing that channels map through lenses, I need to make some changes and as a result of those changes Image is now becoming a type class
03:25:40 <zgredzik> but I'd like to still be able to access the channels using lenses
03:28:38 <bartavelle> zgredzik, I suppose you can have the required lens/traversal be part of the typeclass
03:30:08 <pranz> zgredzik: I have used the method bartavelle recommended
03:33:27 <zgredzik> bartavelle, pranz: would you mind to elaborate a bit? provide a simple example?
03:35:44 <pranz> class T a where mylens :: Lens' Image a
03:36:01 <yac> hrm, the Data.Ini is weird. It can't handle configs like "foo = bar", has to be "foo=bar"
03:36:15 <randomclown> why not json
03:37:52 <zgredzik> pranz: thank you, gonna test it out
03:39:16 <spacebug> anyone any tips on how to do a more complex build with cabal?
03:39:36 <spacebug> putting a C file as main-is results in ghc complaining that it doesn't see any input files
03:40:16 <spacebug> (C wrapper needed for SDL on Mac OS X)
03:40:33 <spacebug> (to initialize Cocoa mainly I think)
03:43:56 <bergmark> spacebug: there's a MACOSX readme in the SDL package on hackage
03:44:40 <yac>  lookupValue (pack section) (pack key) ini
03:44:47 <yac> how can I get rid of the parentheses in here?
03:45:00 <zgredzik> pranz: I've tried to do what you proposed but can't get it to work, can you tell me what's wrong with http://lpaste.net/103659 ?
03:45:01 <spacebug> bergmark: I've seen it, looking to use cabal though
03:45:40 <spacebug> bergmark: transposing the solution to cabal file proves challenging
03:46:47 <pranz> zgredzik: in that example you make an instance of X
03:47:07 <pranz> zgredzik: that means ctest for that instance becomes a Lens' X X
03:49:27 <pranz> and a is a Lens' X Int
03:55:53 <Fuuzetsu> @unpl f d = return [ ExportDoc d ]
03:55:53 <lambdabot> f d = return [ExportDoc d];
03:55:57 <Fuuzetsu> uh
03:55:59 <Fuuzetsu> @pl f d = return [ ExportDoc d ]
03:56:00 <lambdabot> f = return . return . ExportDoc
04:02:39 <zgredzik> pranz: makes sense, ty, going to try and apply this to my use-case
04:19:22 <merijn> What's the best library for incremental parsing of Text?
04:20:00 <merijn> Parsec seems really fond of returning String things where I want to return Text, plus not really suited for incremental parsing, I think?
04:22:04 <merijn> ok, attoparsec seems like the sensible approach
04:27:28 <pavonia> merijn: There are Parsec parser versions for ByteString and Text too
04:27:44 <pavonia> not sure about the incremental parsing
04:29:01 <merijn> pavonia: I know, the problem with those versions is this: "string :: String -> Parser String", whereas for Text you'd want "string :: String -> Parser Text", which attoparsec does provide
04:30:39 <pavonia> Hhm, I see
04:32:25 * hackagebot Workflow 0.8.1 - Workflow patterns over a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.1 (AlbertoCorona)
04:47:27 * hackagebot snap-web-routes 0.3.0.0 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.3.0.0 (lukerandall)
04:50:01 <Fuuzetsu> I understand why ‘seq x x’ doesn't make sense to do, but is it the same with ‘deepseq x x’?
04:50:42 <bennofs> Fuuzetsu: deepseq x x is also called force, and is indeed sometimes useful
04:50:56 <bennofs> s/force/force x/
04:51:08 <Fuuzetsu> @hoogle force
04:51:08 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
04:51:08 <lambdabot> package force-layout
04:51:08 <lambdabot> Graphics.UI.GLUT.DeviceControl forceJoystickCallback :: IO ()
04:51:10 <Fuuzetsu> cool
04:52:54 <gauthier> simple question on container:Data.Graph that I intend to use, I'd like to have a undirected graph, that I construct from a set of pairs [(1,2),(2,3)] this is a network with 3 nodes, connecting 1 to 2, 2 to 1, 2 to 3 and 3 to 2, it seems http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html#t:Graph is for directed graph
04:53:12 <gauthier> is there a relevant datastructure for undirected graphs?
04:54:15 <quchen_> Fuuzetsu: "deepseq x x" is similar to "deepseq x x `seq` x", so it deepseqs x whenever x is forced.
04:54:16 <merijn> gauthier: Just use a directed graph and "directed xs = xs ++ map flip xs"?
04:55:06 <gauthier> my first exercise would be to get a list of all connected nodes at N, giving nodes from distance 1 to distance N
04:56:55 <gauthier> merijin: ok so I'll have twice the edges, maybe it's better if somehow the traverse function look at each pair and it's flip?
04:57:38 <gauthier> I don't know yet how graph traversal is done, I think I need to look at that first :)
05:02:43 <mizu_no_oto> Could you make a simple interactive game using diagrams, or is it not really meant for allowing any interactivity?
05:03:39 <Taneb> mizu_no_oto, I believe it is possible.
05:03:46 <phischu> gauthier: if at one point you find that Data.Graph from containers is not sufficient for your needs I propose you look at the fgl package
05:03:47 <Taneb> mizu_no_oto, try asking in #diagrams
05:04:01 <mizu_no_oto> Taneb: thanks
05:10:29 <werdna> hey, I'm trying to understand how I can modify a GADT. The top definition of the GADT gives "data Format (fmt :: List *) where"
05:10:34 <werdna> but I don't understand what the List * means
05:10:52 <werdna> I'm getting a compilation error, it says The first argument of `Format' should have kind `List *',    but `List String' has kind `*'
05:11:00 <werdna> When I add a definition S :: Format (List String)
05:11:08 <werdna> But I don't understand why a List String isn't a List *
05:12:00 <merijn> werdna: How is List defined?
05:12:08 <werdna> data List a = Nil | a ::: List a
05:12:26 <merijn> werdna: Ah, right
05:13:56 <merijn> werdna: I don't have time to explain things right now, but I recommend reading up on kinds and DataKinds. A kind is the "type of a type" so if "5 :: Int" means "5 has type Int" then "Int :: *" means "Int has kind *"
05:14:11 <werdna> merijn: thanks, that's very helpful
05:14:25 <werdna> still very much bumbling through GADTs
05:14:29 <merijn> werdna: "data Format (fmt :: List *)" is saying that Format wants a "type level List that contains types of kind *"
05:14:34 <werdna> I suspect some day I'll have an "aha" and it will all work
05:14:47 <merijn> werdna: So you'd want to write "S :: Format (String ::: Nil)"
05:16:14 <merijn> werdna: I would recommend first finding some tutorial on kinds, then the GADT wikibook and then the "Fun with Type Functions" paper, those should all be rather accessible with a basic-intermediate understanding of haskell types
05:16:18 * merijn is off now
05:26:24 <jmcarthur> werdna: an example:    (Int ::: String ::: Bool ::: Nil) :: List *
05:26:46 <werdna> Is the ::: some Haskell syntax?
05:26:55 <jmcarthur> werdna: it's from the definition of List you showed us
05:27:07 <werdna> Okay, so there's nothing special and Haskelly about it
05:27:12 <jmcarthur> not really
05:27:15 * werdna is doing homework, the main def'n came from the lecturer.
05:27:34 <jmcarthur> interesting that DataKinds and GADTs have found their way into homework...
05:27:51 <werdna> This is only week 6 :p
05:27:54 <werdna> (of 13)
05:27:59 <jmcarthur> what is the course?
05:28:06 <werdna> http://learnyouahaskell.com/making-our-own-types-and-typeclasses <-- hoping this gets to GADTs by the end of the page
05:28:15 <jmcarthur> no, it won't
05:28:24 <jmcarthur> GADTs are kind of a GHC-specific, advanced topic
05:28:37 <werdna> ah lucky me
05:28:38 <jmcarthur> DataKinds moreso
05:29:27 <JanTS> is size of Float always the same for all architectures?
05:29:37 <jmcarthur> werdna: anyway, List * means "list of types"
05:30:12 <jmcarthur> JanTS: the documentation only says "It is desirable that this type be at least equal in range and precision to the IEEE single-precision type."
05:30:53 <defanor> i'm looking for a parser combinators library, suitable for binary network protocols parsing (that is, suitable for work with bits, and preferably with incremental parsing); have not found combinators for bits in attoparsec. any suggestions?
05:31:06 <Fuuzetsu> attoparsec ;P
05:31:36 <Fuuzetsu> what's wrong with the ByteString combinators?
05:32:05 <defanor> Fuuzetsu: will check them again, but i thought they work only with full bytes. i'll have, say, numbers which are encoded in <8 bits
05:32:14 <defanor> or in, say, 10-12 bits
05:32:31 <JanTS> is there something like Decimal32, type of floating point numbers with fixed size, available in GHC?
05:33:03 <merijn> Any pipes-parse users that could tell me whether there's a sensible way to go from "Parser a m r" to "Producer r m x"?
05:33:46 <Fuuzetsu> defanor: I think the practice is to process everything in 8-bit chunks anyway although I have no experience here
05:33:50 <Fuuzetsu> could ask on MLs
05:34:45 <defanor> Fuuzetsu: k, thanks
05:35:30 <ion> jants: Fixed?
05:36:16 <bennofs> merijn: how should that behave? What do you want to do?
05:36:49 <merijn> bennofs: Actually, I guess maybe I just want "Parser a m ()"
05:37:44 <JanTS> ion: yes
05:37:45 <merijn> bennofs: I wanted to transform a stream of Text into a stream of Foo by parsing any number of Foo elements
05:38:47 <Fuuzetsu> many (p :: Parser Foo)?
05:38:56 <merijn> :t many
05:38:57 <lambdabot> Alternative f => f a -> f [a]
05:39:05 <merijn> Fuuzetsu: No, because that gathers elements in memory
05:39:19 <Fuuzetsu> oh, pipes-parse, just read up
05:39:29 <Fuuzetsu> never used it
05:39:35 <merijn> I have a "Producer a m r" (reads from file/socket/whatever) and a "Consumer Foo m r" that writes to a file
05:39:41 <bennofs> merijn: so you want a function Parser a m r -> Producer a m x -> Producer r m x ()
05:40:10 <bennofs> s/Producer r m x ()/Producer r m ()
05:40:16 <merijn> And I want to write a parser that turns a stream of 'a' into a stream of 'Foo'
05:40:58 <merijn> But I don't see how to fit the Parser type in there unless I put my Consumer directly into my Parser and just do "runEffect . evalStateT"
05:41:13 <merijn> bennofs: Right
05:41:46 <merijn> The only way I see at the moment is just lifting write operations directly into my Parser, which seems...ugly
05:43:03 <bennofs> merijn: you could use 'runStateT  :: Parser a m r -> Producer a m x -> m (r, Producer a m x)' repeatly: let s be your initial producer. Then use runStateT to get one Foo, yield it and recurse with the leftover s that you got from runStateT
05:43:38 <merijn> bennofs: Right, but that seems really ugly and odd for such a common usecase...
05:47:33 * hackagebot HsSyck 0.52 - Fast, lightweight YAML loader and dumper  http://hackage.haskell.org/package/HsSyck-0.52 (AudreyTang)
06:02:02 <werdna> Okay, I'm missing something… Why do some data constructors take parameters and others don't?
06:02:21 <werdna> Sometimes I'll write a data constructor like this: X :: Format Nil
06:02:32 <werdna> and other times I'll write one like this: Branch :: a -> BinaryTree t1 a -> BinaryTree t2 a -> BinaryTree NotEmpty a
06:02:35 * hackagebot snap-web-routes 0.3.0.1 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.3.0.1 (lukerandall)
06:02:44 <sipa> GADTs vs normal syntax
06:02:58 <sipa> oh wait
06:03:14 <werdna> nope, both GADTs
06:03:20 <werdna> I'm getting it now a liiiittle bit
06:03:28 <werdna> so the former returns a Format Nil regardless
06:03:32 <sipa> well, because one takes an argument and the other doesn't?
06:03:33 <werdna> it always returns the same type
06:03:41 <werdna> and the latter takes a type as input and converts it to another type
06:04:00 <sipa> "convert" is the wrong way of looking at it
06:04:27 <sipa> it's not different from the non-GADT case
06:04:35 <sipa> data Maybe a = Nothing | Just a
06:04:45 <sipa> can be written as:
06:04:53 <fizruk> werdna: type constructors can be seen as type-level functions
06:04:56 <sipa> Nothing :: Maybe a
06:05:00 <sipa> Just :: a -> Maybe a
06:05:30 <werdna> may be having my GADT epiphany now
06:06:15 <fizruk> werdna: ignore that, I misread your question
06:09:00 <werdna> Figured it out
06:09:05 <werdna> wow, that is trippy
06:09:36 <Axman6> X :: Format Nil says that the piece of data X has type Format Nil
06:10:25 <k00mi> werdna: there is nothing different to normal ADTs so far, you just write out the type signatures of the constructors
06:10:26 <Axman6> so when you pattern on something of type Format a and you get an X, you know the a was Nil
06:10:41 <werdna> it was these two bits that were getting me
06:10:47 <werdna>   L :: String -> Format fmt -> Format fmt
06:10:47 <werdna>   S :: Format fmt -> Format (String ::: fmt)
06:11:23 <werdna> I wasn't realising that the types aren't actually functions applied to real data, they're just a way of representing patterns of data
06:11:58 <dwcook> werdna, well, L and S are functions. They just also happen to be constructors.
06:12:22 <werdna> right, but if I understand it right, they construct types, not actual objects
06:12:40 <dwcook> No, they are value-level functions.
06:12:48 <werdna> they're functions that take a type and return a type, and you have to match the constructor in order to get the right type. No?
06:13:05 <dwcook> For example, Maybe can be seen as a type-level function, but Just is value-level.
06:15:35 <werdna> okay, so a type level function takes a type and turns it into another type
06:15:37 <Axman6> werdna: Foo :: Bar -> Baz -> Quux is a constructor which contains a Bar and a Baz and has type Quux once applied to a Bar and a Baz
06:15:41 <dwcook> werdna, right.
06:15:45 <werdna> and a value level function, !!:s/type/value/
06:15:54 <dwcook> Yep.
06:16:24 <werdna> okay, so a type CONSTRUCTOR is a defined valid way of taking data to produce a type
06:16:27 <werdna> but that type might be algebraic
06:16:30 <werdna> and that's why I'm confused
06:16:36 <dwcook> (Usually when we say "function" we are referring to a functional value, but we can use the term by analogy with types as well.)
06:17:07 <dwcook> werdna, what part has you confused?
06:17:52 <werdna> well, it's the fact that the constructors are also algebraic
06:17:52 <Axman6> werdna: this is usually easiest with the Vector type: data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
06:18:17 <werdna> so there's the fact that the constructor is turning arguments into a GADT
06:18:29 <dwcook> werdna, careful not to get confused about type constructors versus data constructors.
06:18:36 <werdna> btu also, the constructor itself is algebraic and there's a sort of meta-function whereby the type of the input determines the type of the outputs
06:18:40 <werdna> hmm, I don't know the difference
06:18:45 <Axman6> here Nil is some data that contains nothing, and Cons is something that contains a value of type a and n more values of type a, where n is encoded in the type
06:18:46 <dwcook> Type constructors construct types, data constructors construct values.
06:18:54 <dwcook> Maybe is a type constructor, Just is a data constructor.
06:19:00 <werdna> I think I'm about to find out, is a type constructor the same as a type instance?
06:19:12 <dwcook> No, typeclass instances are something else entirely.
06:19:19 <werdna> excellent
06:19:21 <werdna> so many types
06:19:40 <werdna> Axman6: I don't quite know what the S does, but that looks like it's starting to make me understand more
06:20:14 <fizruk> S for successor
06:20:23 <osa1_> is it just me or is HUnit's API really confusing? I don't understand how can this type be useful for signaling assertion failures https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit-Base.html#t:Assertion what happens if I just want to print something random even if test is passed? is it still considered a failure? what does check for printing and how does it do that?
06:20:23 <dwcook> data S a = S a
06:20:28 <werdna> gotcha
06:20:32 <Axman6> werdna: S is short for Successor, it's from peano natural numbers. where 0 = Z, 1 = S Z, 2 = S (S Z)
06:20:49 <fizruk> dwcook: data Nat = Z | S Nat
06:21:05 <dwcook> fizruk, S is a type constructor in the example
06:21:06 * werdna has been programming since he was six and has never had his brain messed with so much by a language as by haskell
06:21:08 <werdna> it's in a good way
06:21:10 <werdna> but yeah :p
06:21:24 <fizruk> dwcook: Nat can be promoted :)
06:21:55 <dwcook> fizruk, I'm not familiar with promotion
06:22:24 <fizruk> dwcook: http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/promotion.html
06:24:39 <fizruk> dwcook: it’s more like “data kind Nat = Z | S Nat”
06:25:45 <dwcook> I'm not familiar with that syntax, or are you adding the word "kind" there to illustrate?
06:27:25 <fizruk> dwcook: mostly to illustrate, but I’ve seen that syntax too
06:27:54 <fizruk> here I’ve seen it: https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/KindsWithoutData
06:30:44 <phischu> merijn: regarding incremental parsing with pipes-parse my best guess is http://lpaste.net/103664 (only typechecked, not run)
06:33:17 <merijn> phischu: I was checking the mailing list and it seems like Tekmo recommend explicitly passing the state on, i.e.: https://groups.google.com/forum/#!topic/haskell-pipes/U9TCKZs_i3U
06:35:31 <phischu> merijn: yes, thanks for the information
06:46:55 <_Lucas> hi
06:47:07 <_Lucas> can somebody help me?
06:47:17 <ciaranm> _Lucas: consult a trained professional
06:47:36 <_Lucas> hahah nice idea
06:48:04 <quchen_> Instead of asking whether you can ask a question, why not just ask the question
06:48:13 <ciaranm> quchen_: is that a question?
06:48:17 <quchen_> Instead of asking whether you can ask a question, why not just ask the question.
06:48:25 <_Lucas> hahah nice idea
06:48:28 <nclarke> Is that an answer?
06:48:38 <ciaranm> maybe?
06:48:54 <_Lucas> probably
06:49:13 <allsystemsarego> hi all, what would count as a good reason to put a newtype around a tuple, e.g. newtype Foo = MkFoo (Int, Int) vs data Foo = MkFoo Int Int, from a type design perspective?
06:49:19 <ciaranm> is Probably a monad?
06:49:42 <nclarke> Probably
06:50:09 <_Lucas> maybe
06:50:55 <quchen_> allsystemsarego: Good question, actually. I think maybe apart from corner cases, these two definitions are very similar.
06:51:18 <fizruk> allsystemsarego: i think it’s either type Foo = (Int, Int) or data Foo = MkFoo Int Int
06:51:21 <byorgey> allsystemsarego: with the newtype, using GeneralizedNewtypeDeriving you get to automatically lift any type class instances for tuples to instances for Foo
06:51:28 <quchen_> allsystemsarego: In practice, it'll be nicer to match the `data`, because when you match the newtype you have to include a match on the pattern.
06:51:33 <nclarke> allsystemsarego: The newtype might allow you to derive things like Ord
06:51:49 <quchen_> nclarke: So does the data.
06:52:15 <nclarke> Really? Didn't realise that
06:52:26 <byorgey> Ord is special, you can derive it for most types, regardless of newtype
06:52:28 <quchen_> data Foo = Foo Int Int deriving (Eq, Ord, Show)
06:52:50 <quchen_> Oh, replace "match on the pattern" with "match the tuple" in my statement above.
06:53:12 <allsystemsarego> thank you guys, good answers, I'll reflect some more and come back
06:53:28 <quchen_> So it's "f (MkFooNewtype (a,b))" vs "f (MkFooData a b)"
06:56:30 <byorgey> allsystemsarego: another point: the tuple locks you into laziness; with the non-tuple version you can easily make it strict by changing it to  data Foo = MkFoo !Int !Int
06:57:08 <allsystemsarego> byorgey, good to know, thanks
07:15:23 <napping> Ooh, Development.Shake.FilePath.normalise looks nice
07:34:27 <ricree> Is there a way to inspect a value without a show instance.  For debugging purposes?
07:35:11 <tdammers> ricree: what would you expect to be printed if there is no show instance?
07:35:56 <ricree> tdammers: Honestly, I'm not really sure. But it turns out the answer surprises me, so I figured I'd ask and see
07:36:41 <merijn> ricree: How would you inspect something you can't see?
07:36:58 <tdammers> "what the REPL should print" is pretty much the definition of `show`
07:36:59 <merijn> You need to visualise it in some way, no?
07:39:51 <Sculptor> hi
07:39:56 <napping> Hello
07:40:05 <napping> ricree: in ghci you can use :print or :sprint
07:40:34 <saml> can ghc integrate with jira and git?
07:41:00 <Kinnison> In exactly the same way as any other compiler can, yes.
07:41:15 <Kinnison> What do you really mean?
07:41:17 <ricree> thank you napping
07:44:12 <osa1_> do we have String version of Data.Text.strip somewhere?
07:44:37 <napping> ricree: what was the original question? I just /joined
07:44:45 <fizruk> :t Data.Text.strip
07:44:45 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
07:45:24 <napping> saml: What would you want from "integration"? I use git for version control on some Haskell projects
07:46:44 <napping> saml: the only thing I can even imagine a compiler integrating with git for would be to somehow compile directly out of git, and use the same SHA1 hash for recompilation avoidance and that sort of stuff - which GHC definitely doesn't do
07:47:23 <nclarke> Auto-labelling versions with git commit id would be one thing
07:47:36 <nclarke> Though that's closer to cabal territory
07:47:40 <Maior> nclarke: that's cabal, surely, not ghci
07:47:44 <Maior> bah you type faster :P
07:47:52 <benzrf> why is forkIO called 'fork'
07:47:57 <benzrf> it's thread based isnt Itkovian
07:47:59 <benzrf> *it
07:48:05 <nclarke> Because spoonIO makes no sense
07:48:17 <napping> Yeah, there's a fair number of things for a *build system* to do with git/jira/whatever
07:48:17 <benzrf> wenk wenk
07:48:24 <Itkovian> nor does knifeIO
07:48:30 <fryguybob> benzrf: It is still forking the control flow.
07:48:45 <napping> benzrf: "fork a thread"
07:49:12 <vitka> napping: needleIO then?
07:50:04 <Maior> relatedly, does cabal have (or are there any) tools for handling / pinning dependency versions, or handling "development releases" (for Maven users, `mvn release` / `mvn dependency:*` / `-SNAPSHOT`)
07:50:30 <napping> Maior: perhaps "cabal freeze"?
07:50:42 <eiluan> @pf \y -> y `mod` x /= 0
07:50:42 <lambdabot> Maybe you meant: pl bf
07:50:47 <eiluan> @pl \y -> y `mod` x /= 0
07:50:48 <lambdabot> (0 /=) . (`mod` x)
07:51:16 <TallerGhostWalt> Is there a way to turn off "Warning defined but not used" for a single variable
07:51:30 <TallerGhostWalt> seems unlikely
07:51:33 <nclarke> Replace it with _
07:51:37 <napping> --help says "Freeze dependencies.". What's that about "development release"?
07:51:39 <bergmark> or with foo_
07:51:45 <Maior> napping: that's certainly a first step, thanks
07:51:47 <dwcook> _foo more like, no?
07:51:48 <napping> bergmark: does that work?
07:51:54 <TallerGhostWalt> perfect!
07:52:01 <napping> TallerGhostWalt: any variable starting with _ doesn't get the warning, like _foo
07:52:04 <bergmark> ehm one of them :-)
07:52:26 <TallerGhostWalt> napping: bergmark: Thanks, I honestly didn't expect that to be a real thing
07:52:49 * hackagebot shelly 1.5.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.3 (GregWeber)
07:52:55 <napping> Maior: I think freeze is a pretty new option. Probably stuff about releases is less developed, but look around sdist and upload
07:53:12 <Maior> napping: thanks
07:53:37 <hunt> how do ui convert a list [a] to Nothing if its empty and head l if its not?
07:54:12 <vitka> :t [a] -> Maybe a
07:54:12 <lambdabot> parse error on input ‘->’
07:54:19 <Maior> hunt: safeHead x:_ = Just x ; safeHead [] = Nothing?
07:54:28 <orion> In Haskell, is it always best to create a crapton of types for every conceivable thing under the Sun in your appliation?
07:54:35 <Maior> hunt: there's probably something cool with monoids though
07:54:38 <napping> Maior: it seems "cabal sdist --snapshot" appends the date to the version in the .cabal file in the archive
07:54:44 <Maior> napping: <3
07:54:49 <armlessh0b0> orion: not unless it really really calls for it.
07:54:54 <armlessh0b0> which I can't imagine why.
07:55:01 <bergmark> orion: i think you shoudl be a bit pragmatic about it...
07:55:03 <TallerGhostWalt> Is CentOS the most common haskell env?
07:55:19 <Maior> TallerGhostWalt: nfi, but I do dev on OSX and deploy to Debian
07:55:35 <davean_> TallerGhostWalt: I'd be supprised, but there aren't many good ways to tell
07:55:41 <davean_> TallerGhostWalt: I'd expect a debian derivative
07:55:43 <TallerGhostWalt> Major: in a virtual box?
07:55:44 <napping> TallerGhostWalt: Probably Linux is most popular, but I don't think distribution matters
07:55:46 <bergmark> most people i know use os x
07:55:48 <t7> is centOS the most common anything?
07:55:57 <TallerGhostWalt> bergmark: native?
07:55:57 <hunt> Maior: yea i was loking for the monad solution
07:56:00 <Maior> t7: massively popular with lots of my clients
07:56:12 <napping> debain derivative here too
07:56:14 <Maior> t7: for having a lot of PCI/similar features without actually being RHEL
07:56:15 <bergmark> TallerGhostWalt: "native"? :o
07:56:23 <vitka> @hoogle [a] -> Maybe a
07:56:24 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
07:56:24 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:56:24 <lambdabot> Prelude head :: [a] -> a
07:56:33 <TallerGhostWalt> bergmark: not in a vm
07:56:34 <dwcook> hunt, you don't need a Monad solution if you're fixed at list
07:56:41 <dwcook> hunt, sorry, wrong person
07:56:48 * dwcook got the threads mixed up
07:57:01 <napping> saml: Did you have any particular "integration" in mind?
07:57:02 <dwcook> hunt, never mind, you were the right person :)
07:57:18 <nclarke> I develop on OS/X or Arch
07:57:26 <nclarke> Deploy to Scientific Linux
07:57:33 <bergmark> TallerGhostWalt: i don't know anyone who runs os x in a vm :-)
07:58:13 <TallerGhostWalt> bergmark: lol, I mean do you run a deb VM from osx... I would think deploying from one OS to another might lead to some weird errors.
07:58:33 <saml> napping, no i am trolling
07:58:49 <hunt> dwcook: what do you mean fixed at list? and im just curiousu about it because it seems like itd be more elegant
07:59:02 <napping> saml: Too bad, using hashes from git sounded kind of cool
07:59:02 <hunt> dwcook: i think i know what you mean fixed at list, but im still curious
07:59:03 <dwcook> orion, creating types is cheap and easy. On the other hand, many of the ones you might want exist in base. So you can use an existing one that meets your needs, or make a new one if none does.
07:59:18 <Maior> TallerGhostWalt: my code is _built_ (and deployed from) Debian, since that's what I run in production (and people around me do dev on Debian VMs running in OSX) but I've hit no real problems just writing code from OSX
07:59:32 <napping> saml: still not sure if there's anything a compiler proper could do with a bug trackedr
07:59:45 <bergmark> TallerGhostWalt: we deploy to ubuntu and have a build server for that
07:59:52 <dwcook> hunt, you know that you're dealing specifically with a list and not something more general. Frankly I don't think there even is a general notion of "get the head" that Monad could help you with.
08:00:20 <TallerGhostWalt> bergmark: okay I get you now, I thought you meant something waaay crazier.
08:00:42 <fizruk> dwcook: comonad is a general notion of “get the head” I guess (+ extend)
08:01:11 <hunt> dwcook:rather, id like just the list or nothing if its empty, if thats more possible
08:01:16 <nclarke> dwcook: I think he meant 'monoid', e.g. get maybe on mzero
08:01:18 <hunt> dwcook: because then i can fmap head
08:01:40 <lechip> hello, can somebody explain to me how does the newtype keyword works?
08:02:01 <dwcook> hunt, what's wrong with pattern matching on the list?
08:02:36 <napping> hunt: using Data.Monoid.First with Data.Foldable.foldMap is probably the most general notion of checking if there's a head
08:02:57 <napping> lechip: how it works, or how to use it?
08:03:25 <pyon> lechip: It defines a new type, whose underlying representation is the same as the wrapped type.
08:03:53 <lechip> say i got this, what does it mean? newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)
08:03:56 <napping> lechip: to use it, it's like data except you can only define types with a single constructor, which has a single field
08:04:16 <lechip> so is for like quick access then?
08:04:16 <nclarke> It's a compile-time wrapper that gives type differentiation at compile time, but uses the same underlying representation at runtime
08:04:56 <napping> lechip: more for telling things apart, without overhead
08:05:31 <lechip> so it has more meaning to the reader than the compilar then
08:05:33 <napping> like newtype Celsius = Celsius Double
08:05:46 <nclarke> > newtype PretendingNotToBeAnInt = PNTBAI Int
08:05:47 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
08:05:58 <benzrf> use @let
08:06:03 <nclarke> Ah
08:06:04 <dwcook> and newtype Fahrenheit = Fahrenheit Double. Now you write functions that accept only Celsius or only Fahrenheit and you can't possibly mix them up
08:06:05 <napping> More for the reader - the compiler does stop you from mixing them
08:06:15 <lechip> AHHHHHHHHHHHHHHHH
08:06:18 <nclarke> @let newtype Pretend = Pretend Int
08:06:19 <napping> It's also slightly different in strictness
08:06:20 <lambdabot>  Defined.
08:06:20 <lechip> that makes a crapload of sense!
08:06:38 <nclarke> @let foo (Pretend x) = show x
08:06:39 <lambdabot>  Defined.
08:06:41 <nclarke> foo 1
08:06:42 <napping> if you have data T = T Int, you can have just the "T" constructor evaluated, and not the value inside
08:06:43 <benzrf> lechip: a newtype is like a type declaration except that it is actually considered a different type
08:06:44 <nclarke> > foo 1
08:06:45 <lambdabot>  No instance for (GHC.Num.Num L.Pretend)
08:06:45 <lambdabot>    arising from the literal ‘1’
08:06:51 <nclarke> > foo (Pretend 1)
08:06:53 <lambdabot>  "1"
08:06:56 <napping> like case T undefined of T _ -> "okay" will be okay
08:06:58 <benzrf> lechip: i.e. for checking purposes and for typeclass instances
08:07:02 <benzrf> lechip: but it is otherwise the same values
08:07:10 <nclarke> But Pretend is really just an Int
08:07:14 <benzrf> you mostly use it like it's any other data though
08:07:17 <lechip> awesome! thank you all, super useful answers!
08:07:21 <benzrf> :-)
08:07:56 <dwcook> lechip, another common use of newtype is to hide or replace typeclass instances. Are you familiar with typeclasses?
08:07:57 <napping> lechip: how the compiler keeps it all straight while compiling is a whole different story
08:08:42 <lechip> dwcook: yes i am familiar, how would ituse it for that?
08:08:58 <dwcook> Well a newtype is allowed to have distinct instances from the underlying type
08:09:09 <Fernandos> hi
08:09:09 <dwcook> For example, ZipList
08:09:35 <Fernandos> can I use unicode in haskell?
08:09:40 <dwcook> Look at the Applicative instance: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Applicative.html#ZipList
08:09:44 <dwcook> It's different from that of []
08:09:48 <dwcook> Fernandos, yes.
08:10:07 <Fernandos> dwcook: how about this? (λz. (λy.y + z) )(3) ((λx.x + x) (4))
08:10:20 <benzrf> lechip: there are 3 different functors/monads i can think of off the top of my head that are functions
08:10:31 <benzrf> reader, state, & cont
08:10:43 <benzrf> in order to prevent conflicting instances, they need to be different types
08:10:46 <benzrf> hence, wrappers
08:10:55 <dwcook> Fernandos, what about it?
08:11:28 <Achylles> How do I increase pdf pandoc fontsize in my docs? the default one is very small > this command works for me, but with small fonts >  pandoc -s -S text.markdown -o text.pdf
08:12:10 <benzrf> hmm i just realized
08:12:21 <benzrf> applicative can be defined in terms of Functor and(**)
08:12:26 <lechip> thank you!
08:12:34 <benzrf> but (<*>) is sufficient by itself
08:12:40 <benzrf> Monad can be join + applicative
08:12:46 <benzrf> but >>= (w/ return) is enough
08:12:50 <benzrf> without fmap
08:12:56 <benzrf> is there a reason for these
08:12:56 <tdammers> Achylles: you can provide a custom latex header IIRC
08:13:15 <tdammers> pandoc has quite a few hooks into the latex output, actually
08:13:23 <dwcook> benzrf, history, ease of use, practicality
08:13:29 <dwcook> Depending on the specific question :)
08:13:59 <dwcook> (>>=) is seen by many as nicer for programming than join
08:14:04 <napping> Fernandos: for actually writing your code in unicode, check out http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
08:14:04 <benzrf> yeah, but you could have the typeclass be join
08:14:08 <Fernandos> dwcook: I mean can I write (λx.x*x)3  instead of  let z1 = (\x -> x*x) 3   ?
08:14:14 <benzrf> and then have (>>=) be a lib func
08:14:21 <napping> Fernandos: lambda is not an option
08:14:32 <Fernandos> ?
08:14:47 <Achylles> tdammers, yes. But, people do not put practical examples for this. I have searche google for that :(
08:14:54 <dwcook> benzrf, efficiency is also a concern. Ideally you'd be able to implement your choice of (>>=) or join (and soon you'll be able to!)
08:14:58 <napping> Fernandos: with the right option, you could write (\x→x*x) 3
08:15:12 <benzrf> dwcook: oooh
08:15:12 <napping> but you can't replace -> with ., or \ with λ
08:15:15 <benzrf> → woo
08:15:17 <tdammers> Achylles: yes, you'll have to fiddle a bit, and I'm afraid some latex clue is required
08:15:19 <Maior> a/win 49
08:15:20 <Maior> sorry
08:15:41 <jophish_> Is there a synonym for 'fmap (view l)' in Lens?
08:15:47 <Fernandos> napping: that's what I meant, if I can replace \ with λ
08:15:53 <napping> Fernandos: oh, I think you can use unicode letters in identifier names too. Wouldn't be polite to steal λ from the greeks
08:16:29 <napping> Fernandos: if that's the only bit of unicode you care about, then no
08:16:56 <hamid_> :t Either
08:16:56 <lambdabot>     Not in scope: data constructor ‘Either’
08:16:57 <lambdabot>     Perhaps you meant ‘Other’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:17:09 <hamid_> :t Left 1
08:17:10 <lambdabot> Num a => Either a b
08:17:19 <benzrf> :t Other
08:17:20 <lambdabot> Language
08:17:41 <benzrf> :k Language
08:17:41 <lambdabot> *
08:17:49 <benzrf> wait duuuh
08:17:52 <benzrf> it's inhabited
08:17:56 <benzrf> haha
08:22:25 <spockshock> anyone using gofer? looking for Monad removal
08:23:11 <napping> Fernandos: this is legal: (\λ -> λ*λ) 3
08:23:25 <quchen_> hamid_: Either is a data constructor, it does not have any values, and only values have types.
08:23:38 <quchen_> s/data/type/
08:23:57 <dwcook> Gofer? Isn't that like a primordial Haskell compiler?
08:24:18 <napping> spockshock: if you're looking for IO without monads, you might check out really old Haskell reports
08:24:21 <napping> like 1.0
08:25:13 <quchen> napping, spockshock: This might be interesting. http://r6.ca/blog/20110520T220201Z.html
08:25:34 <quchen> Spoiler: monadic IO is a good thing ;-)
08:25:52 <dwcook> quchen, mistab
08:26:15 <benzrf> man so much mistab
08:27:05 <Fernandos> napping: why would that be illegal=
08:27:07 <Fernandos> ?
08:27:20 <napping> Fernandos: I said legal
08:27:29 <Fernandos> oh
08:27:33 <benzrf> why would anybody want to do IO in haskell without using the IO monad
08:27:41 <napping> Fernandos: but it should help explain why you can't use λ for \
08:27:41 <Fernandos> napping: THAT is cool
08:28:15 <dwcook> main = putStrLn "Hello, world!" -- No monads here, move along
08:28:21 <benzrf> :-)
08:28:47 <benzrf> unsafePerformIO is mostly for writing library bindings right
08:31:40 <hamid_> quchen, got it. thanks
08:32:53 * hackagebot yesod-static 1.2.3 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.3 (MichaelSnoyman)
08:32:55 * hackagebot yesod-test 1.2.1.5 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.1.5 (MichaelSnoyman)
08:37:09 <LarryCroft> Hey
08:37:54 * hackagebot transformers-base 0.4.2 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4.2 (MikhailVorozhtsov)
08:37:56 * hackagebot streaming-commons 0.1.2.3 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.2.3 (MichaelSnoyman)
08:38:23 <LarryCroft> In the MonadWriter (class (Monoid w, Monad m) => MonadWriter w m | m -> w where ...), what is the m -> w part?
08:38:51 <ion> A functional dependency. The value of m completely determines the value of w.
08:39:08 <geekosaur> (note that those are types)
08:39:15 <LarryCroft> Thanks
08:39:38 <benzrf> LarryCroft: it's basically guaranteeing that w will always depend on m
08:39:44 <LarryCroft> Is this more of a compiler hint or does it matter for me when trying to understand the MonadWriter?
08:39:53 <benzrf> so it knows that if you know what m is, w will always be the same thing
08:40:21 <benzrf> LarryCroft: so you can't have both (MonadWriter String Int) and (MonadWriter Int Int), because you have diff values of w for the same m
08:40:27 <benzrf> LarryCroft: it's mostly a compiler hint
08:40:28 <benzrf> you can ignore it
08:40:29 <geekosaur> LarryCroft, it saves you from having to annotate every use with its types
08:42:32 <LarryCroft> benzrf: I can't have both in which scope?
08:43:35 <napping> Does shake log times anywhere?
08:47:52 <benzrf> LarryCroft: you can't make those instances in the same program
08:48:09 <benzrf> LarryCroft: not values of those types; that's a typeclass instance constraint
08:48:15 <benzrf> *instance decl
08:48:39 <benzrf> so you can't write 'instance MonadWriter String Int' and 'instance MonadWriter Int Int' in the same program
08:48:50 <benzrf> although that's not allowed anyway, Int isn't a moand
08:48:52 <benzrf> *monad
08:49:00 <LarryCroft> Ah, I see
08:50:02 <LarryCroft> So I can't even have these two instances in two different modules?
08:51:00 <LarryCroft>  I mean, if i don't export them, they shouldn't be visible to each other, right?
08:51:35 <nclarke> Sadly not
08:51:43 <nclarke> There are proposals to allow that sort of thing
08:51:45 <dwcook> Instances are often written keeping in mind that they could be in scope in the same place. And since instances are automatically imported, it's often seen as good practice not to write conflicting instances.
08:52:05 <LarryCroft> Ah
08:52:39 <dwcook> A reasonable alternative is to create a newtype and give it an alternative instance, when one exists. See [] versus ZipList.
08:52:59 <LarryCroft> Ok
08:53:19 <nclarke> The argument against including it is that you could, say, write an instance of Ord for Int which compares things according to a p-adic valuation, and then expose the Tree (for example) which was built with that Ord constraint
08:53:22 <dwcook> Data.Monoid also contains various examples.
08:53:39 <LarryCroft> Well, to be honst, I wasn't going to use this stuff, but I was reading http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf and choked a bit on that
08:53:48 <dwcook> e.g., Product and Sum on Num types.
08:53:52 <nclarke> Somebody else could then try to use it, but they would be using an Ord instance which compares ints using '<'
08:54:35 <nclarke> And then things could get confused, because the notion of 'less than' used to insert things into the tree is not the same notion that you're trying to use to look things up from it
08:54:58 <LarryCroft> nclarke: That makes sense
08:55:33 <quchen> LarryCroft: This post might be interesting for you. http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell/20040343#20040343
08:57:07 <LarryCroft> quchen: Thanks, looks interesting
08:57:56 * hackagebot antisplice 0.16.0.1 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.16.0.1 (implementation)
08:57:58 * hackagebot ironforge 0.1.0.30 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.30 (implementation)
08:58:00 * hackagebot antagonist 0.1.0.17 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.17 (implementation)
08:58:02 * hackagebot monad-control 0.3.3.0 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.3.0 (BasVanDijk)
08:59:34 <quchen> That actually reminds me that I don't know what the reason for creating monads-tf ("type family based transformers") is. Is it circumventing the problems that fundeps introduce?
08:59:59 <quchen> Or is it created merely out of interest
09:01:23 <dwcook> I was really interested in that antisplice thing until I noticed it had no documentation
09:02:22 <quchen> Antisplice?
09:02:29 <dwcook> hackagebot just mentioned it
09:02:46 <qnikst> hi, how to make following TH code work (minimal example): foo = [| let x = x in x + 1|], I want TH to create new name for x in let binding, i.e. have a let x_123 = x in x_123 +1 as a result
09:03:04 <quchen> Oh, I'm ignoring that one. But since there are no docs, looking up what Antisplice is probably only makes me angry ;-)
09:03:48 <quchen> qnikst: Where does the "x" after the "=" come from?
09:04:13 <quchen> Does "foo y = [| let x = y in x + 1|]" do the trick?
09:04:50 <qnikst> quchen: code outside
09:05:16 <qnikst> quchen: I have no option to convert code in that form
09:05:40 <quchen> ?
09:05:58 <quchen> What's "code outside"? It surely has a name you can refer to in TH.
09:06:13 <dwcook> qnikst, let creates recursive bindings. let x = x in … diverges if you must use x
09:06:18 <qnikst> x = 5 \n foo = [| let x = x .. |]
09:06:38 <quchen> foo = [| let y = x in y + 1|]
09:06:52 <qnikst> dwcook: so my question is: is it possible to use 'generate-a-new-name' in quasi-quote
09:07:20 <danilo2> Hello! :) Its a very beautifull day and I've got a very ugly problem :( So, does anybody know if there is any hack, that would allow me to write such code: http://lpaste.net/103666 but without explicit signature to func addBang ?
09:07:24 <qnikst> I know I can generate a fresh name using TH.Syntax functions, but maybe there is a trick to do the same using quasi-quotes
09:07:56 <qnikst> quchen: quasi-quote works with user provided code, so I can't just change name and hope for the best
09:08:03 <quchen> danilo2: Why do you not want a type sig?
09:09:32 <danilo2> quchen: I'm generating the haskell code and I would love not to provide such signatures. I want just to write a code, which converts any function (a -> a) into (m a -> m a) if it is called with argument in monad and such "autolifting" will typecheck
09:12:54 <danilo2> quchen: Do you think something like that is possible ?
09:12:57 * hackagebot data-r-tree 0.0.3.0 - R-Tree is a spatial data structure similar to Quadtrees or B-Trees.  http://hackage.haskell.org/package/data-r-tree-0.0.3.0 (SebastianPhilipp)
09:12:59 * hackagebot antagonist 0.1.0.18 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.18 (implementation)
09:13:30 <quchen> Let's see.
09:16:36 <qnikst> quchen: sorry everything is ok now, I've tested wrong thing :)
09:17:39 <danilo2> quchen: I was trying to write it for a long time and every method failed. In reality I want to create something like that (annotation to: http://lpaste.net/103666), but this generates fundep conflict (ghc 7.8)
09:17:40 <ParahSailin> network.cabal in version 2.5.0.0 needs `CC-options: "-D__USE_XOPEN2K8" ' to build on certain older systems
09:17:58 * hackagebot lifted-base 0.2.2.2 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.2.2 (BasVanDijk)
09:18:14 <quchen> danilo2: Hmmm, I was about to complain about the fundep hehe
09:18:56 <pavonia> danilo2: (a -> b) is not of kind (* -> *)
09:19:33 <danilo2> quchen: I know, but the fundep is the only way to tell ghc, that we want to infer the result based on function input. ((Of course we can use TypeFamilies here, but the result would be the same I think)
09:19:56 <danilo2> pavonia: Hmm, I know, where is the problem wit the kind? I do not think there is any kind missmatch
09:20:28 <quchen> Hmm that's outside my expertise :-\
09:20:53 <pavonia> danilo2: "| f t1 -> out" -- isn't that f applied to t1?
09:21:16 <danilo2> pavonia: no, it means "based on f AND t1 infer out"
09:21:30 <pavonia> Oh, okay. Sorry for the noise then :)
09:21:44 <danilo2> pavonia: No problem :) thank you for your attention :)
09:22:59 * hackagebot antagonist 0.1.0.19 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.19 (implementation)
09:24:13 <ParahSailin> how do you install to sandbox a package you did `cabal get' made some modifications in to make it build
09:24:43 <jfischoff> ReinH: hey
09:25:08 <ParahSailin> nevermind, figured it out
09:25:08 <danilo2> ParahSailin: cabal sandbox register <name>
09:25:16 <danilo2> ParahSailin: with never version
09:25:39 <ParahSailin> i did cabal install path/to/package.cabal from the sandbox dir
09:25:39 <danilo2> *newer
09:26:15 <napping> Did that install it into the sandbox?
09:26:19 <pmade> ParahSailin: I would have: cabal sandbox --add-source path/to/modified/package
09:26:34 <ParahSailin> napping: yeah it did the trick
09:27:59 * hackagebot conduit 1.1.2.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.2.1 (MichaelSnoyman)
09:28:01 * hackagebot resourcet 1.1.2.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.2.2 (MichaelSnoyman)
09:29:25 <albeit> Hey, using State monads, I have this pattern repeating a lot in my code: http://lpaste.net/103669. Is there any way to make that more clean/concise?
09:32:44 <danilo2> quchen: I'm sorry I'm disturbing you, but I just want to ask if you are thinking about this autolifting or you just do not have time / idea how to solve it? :)
09:33:39 <quchen> danilo2: I mentioned above that that's outside my expertise. What I meant with that is that I have no idea how to solve this :-x
09:33:55 <quchen> Don't worry about pinging me though :-þ
09:34:27 <danilo2> quchen: Ah, ok thank you :)
09:34:34 <exicer_> Are there any existing functions like Maybe a -> b -> Either b a ? Couldn't see anyting on hoogle
09:35:58 <danilo2> exicer_: checjk the "errors" library - I'm not sure if its there, but I would search there
09:36:48 <pranz> exicer_: \ma b -> mapM return ma <|> Left b
09:36:52 <pranz> maybe works
09:37:29 <pranz> mapM from traversable
09:37:29 <quchen> How about \ma b -> maybe (Left b) Right ma
09:37:40 <pranz> ah right
09:37:46 <pranz> that's better
09:37:54 <exicer_> Cool, looks good.
09:37:55 <quchen> Traversable is overshooting a bit here I think.
09:38:00 * hackagebot functor-combo 0.3.5 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3.5 (ConalElliott)
09:38:02 * hackagebot network-multicast 0.0.11 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.11 (AudreyTang)
09:38:08 <pavonia> albeit: You could use Applicative style for the first 4 lines
09:41:03 <albeit> pavonia: Right, now you got me thinking, thanks
09:43:30 <hunt> i get a max backjump reached error when i try to install spock. help!
09:46:59 <hunt> also is ":{" an operator in haskell
09:47:30 <benzrf> hunt: it can be
09:47:35 <danilo2> Hello! does anybody has idea how to create function "autolift", which will allow every function "foo :: a -> b" be called with argument of both "a" and "m a" type, lifting it to the monad? for example "autolift foo 5" and "autolift foo (Just 5)"
09:47:54 <benzrf> @let data Sad = :{
09:47:54 <lambdabot>  Parse failed: Parse error: :
09:47:59 <benzrf> guess i was wrong :(
09:48:02 <benzrf> @let data Sad = :<
09:48:02 <lambdabot>  Parse failed: Parse error: :<
09:48:05 <benzrf> oh right.
09:48:09 <hunt> benzrf: how would you define as an operator like [, really how do you define the list style operators in generla?
09:48:09 <benzrf> @let data Sad = (:{)
09:48:09 <lambdabot>  Parse failed: Parse error: {
09:48:14 <benzrf> awww
09:48:19 <benzrf> @let data Sad = (:<)
09:48:20 <lambdabot>  .L.hs:146:12: parse error on input ‘:<’
09:48:22 <pranz> constructors can't be operators
09:48:23 <benzrf> i dunno hunt
09:48:30 <fizruk> albeit: pavonia: there are 2 applicatives you might use actually
09:48:30 <benzrf> pranz: yes they canta
09:48:31 <benzrf> *can
09:48:39 <pranz> yeah, but not unless they take arguments
09:48:44 <benzrf> @let data Sad a b = a :< b
09:48:46 <lambdabot>  Defined.
09:48:52 <albeit> fizruk: Two different places?
09:48:52 <pranz> there you go
09:49:10 <fizruk> albeit: same place
09:49:24 <albeit> Ah is the second to apply gets over all field names?
09:49:29 <hunt> so anyone know how to define some constructor like {, such that {a,b,c,d,e,f......} creates some structure, like a list
09:49:34 <albeit> * not all, just the ones I need
09:49:48 <fizruk> albeit: yeah, the reader applicative
09:49:49 <pranz> @let data Sadder a b = a :{ b
09:49:49 <lambdabot>  Parse failed: Illegal data/newtype declaration
09:50:08 <benzrf> hunt: i dont think thats a syntax
09:50:09 <fizruk> albeit: i think it would be cleaner/shorter in this particular case
09:50:17 <benzrf> hunt: however... what you could do...
09:50:22 <benzrf> wait 1 sec
09:50:26 <benzrf> :k Free
09:50:27 <lambdabot>     Not in scope: type constructor or class ‘Free’
09:50:27 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
09:50:30 <monochrom> no, haskell doesn't support user-defined bracket syntax
09:50:31 <benzrf> p:
09:50:44 <benzrf> hunt: you can do 'do {a; b; c; d; e; f}
09:50:46 <monochrom> agda may
09:50:55 <benzrf> hunt: use free monads or something, then convert to a struct
09:50:56 <benzrf> :u
09:50:58 <fizruk> hunt: OverloadedLists?
09:51:14 <albeit> fizruk: I haven't yet used the Reader monad, could your provide a snippet of what that one part would look like?
09:51:44 <fizruk> > (,) <$> (+1) <*> (*2) $ 3
09:51:45 <lambdabot>  (4,6)
09:51:46 <hunt> benzrf: alright thanks, monads are probably plenty
09:52:31 <fizruk> albeit: not the Reader from mtl, just unwrapped: (e ->)
09:52:55 <albeit> fizruk: Ohh okay
09:53:22 <fizruk> albeit: would be smth like `gets $ newFoo <$> getX <*> getY <*> getZ <*> pure w`
09:54:13 <pranz> :t liftA4
09:54:14 <lambdabot>     Not in scope: ‘liftA4’
09:54:14 <lambdabot>     Perhaps you meant one of these:
09:54:14 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
09:55:01 <fizruk> albeit: another alternative to write this would be `gets $ \foo -> newFoo (getX foo) (getY foo) (getZ foo) w`
09:55:08 <fizruk> :t liftA3
09:55:09 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
09:55:32 <fizruk> @hoogle liftA4
09:55:32 <lambdabot> No results found
09:55:54 <skypers> hey
09:56:04 <skypers> is there a way to lookup for the index within Vetor?
09:56:05 <skypers> Vector*
09:56:21 <skypers> I know the lens way to do that
09:56:26 <skypers> but I’d like to know the regular way
09:56:45 <skypers> v^?ifolded.filtered pred.asIndex
09:56:47 <skypers> that’s stuff.
09:56:48 <fizruk> skypers: https://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:findIndex ?
09:56:51 <merijn> Pipes question: Is there a way to turn "Producer a m r -> Producer b m r" into "Pipe a b m r"?
09:57:26 <benzrf> merijn: probably
09:57:34 <skypers> fizruk: thank you, great
09:57:42 <benzrf> wait no that seems wrong
09:58:02 * hackagebot largeword 1.2.3 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.2.3 (DominicSteinitz)
09:58:06 <albeit> fizruk: Cool thanks
09:58:43 <quchen> merijn: The LHS can't await, the RHS can. The types don't line up properly I think.
09:59:26 <merijn> quchen: The problem I have is that I have http://hackage.haskell.org/package/pipes-attoparsec-0.5.0/docs/Pipes-Attoparsec.html#v:parsed
09:59:49 <merijn> quchen: But want to have something that I can "drop into" another pipeline
10:00:36 <merijn> Maybe I should make a newtype and have custom composition for that...
10:00:46 <quchen> Hmm, I remember having a similar problem when using Pipes.Binary. Hold on.
10:01:10 <danilo2> Hello! Does anybody know how can we use such type family: http://lpaste.net/103672 ? I though type families can operate only on types, when this one operates on constructors - what does it mean?
10:01:48 <merijn> danilo2: It is only operating on type
10:01:58 <merijn> danilo2: It's using DataKinds to lift Bool to the type level
10:02:03 <fizruk> danilo2: seems like promoted Bool is being used
10:02:23 <fizruk> danilo2: http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/promotion.html
10:02:49 <danilo2> merijn, fizruk: what does that mean? I cannot use "And" as constructor and cannot use it as a type - am I wrong?
10:03:10 <merijn> danilo2: Read the documentation fizruk linked?
10:03:36 <danilo2> merijn: Sorry, I get the link after sending the question. fizruk: thank you :)
10:03:43 <fizruk> danilo2: And is a type function, so you can use it as one
10:04:03 <danilo2> fizruk: Hmm, I'll read the link. Thank you :)
10:05:17 <ReinH> jfischoff: so to be clear I don't have a problem with the Render typeclass. I think punting on the problem and just using `render' is fine.
10:05:27 <quchen> merijn: Hmm. If it was a Producer' I think there would be a solution. But Producer alone doesn't allow awaiting on the type level.
10:06:10 <merijn> quchen: Bollocks :\
10:06:27 <merijn> I guess I'll write an Arrow/Category instance and newtype things
10:10:13 <jfischoff> ReinH: ah.
10:11:03 <jfischoff> ReinH: also looking forward to meeting you at BayHac.
10:11:30 <danilo2> merijn, fizruk: I've read thedocument and I'm a little confused. If we for example write GADT "data Vec :: * -> Nat -> * where" does it mean, that the second parameter is alwyas of type "Nat"? If yes, whats the reason to put it as a type variable ?
10:11:51 <ReinH> jfischoff: awesome!
10:11:58 <fizruk> danilo2: it’s of kind Nat
10:11:59 <jfischoff> :D
10:12:16 <fizruk> danilo2: kinds are types of types, so to say
10:12:19 <quchen> merijn: Can't you just provide the producer of your data as an argument to the function you described? Why does it have to be a Pipe?
10:12:53 <fizruk> danilo2: so when you write data Nat = Z | S Nat, with DataKinds you get both type Nat *and* kind Nat
10:13:12 <merijn> hmm
10:13:19 <ReinH> datakinds confuses me
10:13:28 <quchen> merijn: FWIW that's what I did when I had the problem.
10:13:34 <merijn> Actually, I think I need a real data type to be able to compose both Pipe an "Producer a m r -> Producer b m r"
10:13:38 <fizruk> danilo2: in `data Vec :: * -> Nat -> * where` you have kind (not type!) signature
10:13:42 <merijn> quchen: Can you repeat? My internet died?
10:13:46 <merijn> ReinH: How so?
10:13:55 <danilo2> fizruk: Ah, ok! Ughm, I was nthinking that kind Nat is equal to *. I' have to read the article again, I think
10:14:02 <fizruk> danilo2: but now you distinguish Nat from *
10:14:13 <quchen> "merijn: Hmm. If it was a Producer' I think there would be a solution. But Producer alone doesn't allow awaiting on the type level. ----  Can't you just provide the producer of your data as an argument to the function you described? Why does it have to be a Pipe?  ----   FWIW that's what I did when I had the problem."
10:14:27 <fizruk> danilo2: so you can’t have Vec a (Maybe Bool)
10:14:33 <ReinH> merijn: as in I don't understand them.
10:14:35 <ReinH> merijn: :p
10:15:11 <danilo2> fizruk: Ok, so now you can have "Vec a Nat" only? Am I right?
10:15:49 <fizruk> danilo2: Vec a Z, Vec a (S Z), Vec a (S … (S Z)) and so on
10:16:10 <fizruk> danilo2: Nat is the kind of type-level peano numbers
10:16:37 <fizruk> danilo2: Z ~ 0, S Z ~ 1, S (S Z) ~ 2, S n ~ (n + 1)
10:16:39 <merijn> ReinH: Does this pseudo syntax make sense: "kind Foo = Bar | Baz" (defining a new kind "Foo" and two types "Bar" and "Baz" within that kind)
10:17:03 <fizruk> merijn: why not?
10:17:36 <merijn> fizruk: Why not what?
10:17:57 <quchen> merijn: Rate the sensefulness of this: In "Maybe a", a can be anything, because Maybe has kind * -> *. But it you only want to allow certain types in Maybe values, so you can specialize this kind to "Nat -> *" in some other type ("MaybeNat"), which can then only construct Maybe values out of Nat.
10:17:57 <merijn> quchen: Because I don't want the user of my library to have access to the Producer
10:18:34 <quchen> merijn: I'm not sure whether this is just an oversight of the library author. I don't know why that type sig doesn't have primes in it.
10:18:39 <merijn> quchen: Sensefulness on which scale?
10:18:55 <quchen> merijn: On the scale of "no that's nonsense" to whatever you like :-þ
10:19:18 <merijn> quchen: Because it uses "nextSkipEmpty" which uses "next" which has non-polymorphic type in pipes itself
10:19:20 <fizruk> merijn: you asked about sensefulness of “kind Foo = Bar | Baz” ? perhaps I missed smth
10:19:27 <quchen> I think Renzo is called k000-something on IRC. You can also call him on Github.
10:19:32 <merijn> fizruk: No
10:19:42 <merijn> fizruk: I was asking whether that made sense *to ReinH*
10:19:53 <fizruk> sorry then :)
10:20:22 <danilo2> fizruk: Ok, we can have Vec a Z, Vec a (S Z), etc, but what exactly the same we can have when using definition of: data Vec :: * -> * where Cons :: a -> Vec a Nat -> Vec a (Su Nat). Hmm I'm feeling stupid right now
10:20:53 <merijn> quchen: I will just do this, I think: http://lpaste.net/103674
10:22:04 <quchen> Beautiful :-x
10:22:08 <fizruk> danilo2: yeah, but with Vec :: * -> Nat -> * you can’t even write Vec a (Maybe Bool), cause Maybe Bool is not of kind Nat
10:22:38 <fizruk> danilo2: also, you can’t write Cons :: a -> Vec a Nat -> Vec a (Su Nat)
10:23:28 <merijn> quchen: Well, it means I can provide Arrow/Category instance for it and "fromParser :: Parser a b -> Preprocessor a b" and "fromPipe :: (forall m r . Pipe a b m r) -> Preprocessor a b" and you can then compose Preprocessor a b using >>> and .
10:23:29 <albeit> Is there any way to insert into a map and get the new map, and a flag indicating whether anything anything changed? Something like ":: k -> a -> Map k a -> (Map k a, Bool)"?
10:23:53 <ReinH> merijn: sorry, reading
10:24:01 <merijn> Probably Category would be nicer than Arrow as I'm not sure first/second make sense for that type
10:24:34 <pyon> Category is not required to have products, right?
10:25:20 <merijn> pyon: Category just requires composition and identity with the relevant laws (which are trivial for Pipes)
10:25:25 <pyon> Ah.
10:25:34 <danilo2> fizruk: Oh, I think I get it. It is usefull If you want to limit possible types without changing the definitions of datatypes ... (I hope its right)
10:26:10 <ReinH> merijn: ok, so it makes the kind system extensible.
10:26:14 <ReinH> merijn: I guess that isn't so confusing
10:27:10 <albeit> Does map1 == map2 for Data.Map run in constant time?
10:27:35 <NemesisD> hey guys. i'm having an issue where running cabal test on my program seemingly never terminates. runnign the test binary ends in 100ms
10:27:36 <sipa> no
10:27:36 <benzrf> albeit: i would imagine not o_o
10:27:42 <benzrf> albeit: how could that be possible?
10:27:58 <sipa> unless the maps are constant size :p
10:28:06 * hackagebot directory-layout 0.6.1.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.6.1.0 (MatveyAksenov)
10:28:08 <merijn> ReinH: DataKinds just does "s/data/kind" for all existing data definitions :)
10:28:37 <merijn> ReinH: And transparently lifts them to the type level so you don't have to manually define kinds if perfectly sensibel definitions already exist
10:28:48 <albeit> Well if map2 = Map.insert k v map1, what's the fastest way to check that map2 != map1?
10:28:57 <fizruk> danilo2: close enough, I guess, but you have to see the difference between types and kinds
10:29:29 <albeit> benzrf: I was thinking that maybe just the parent "node" would get altered or not, and it would just check that node/pointer.
10:29:29 <sipa> albeit: check whether k is in map1 with value v
10:29:34 <fizruk> danilo2: Su Nat makes as much sense as Just (Maybe a)
10:29:37 <benzrf> hmmmm how CAN lookup be O(1) average case?
10:29:42 <merijn> albeit: Have you tried looking at the docs?
10:29:46 <merijn> albeit: "insertLookupWithKey"
10:29:49 <benzrf> arent most hash functions more than O(1)/
10:30:32 <albeit> merijn: Actually yes, for a little bit now, never thought that kind of thing would work how I needed, but voila! It does! Thanks
10:31:07 <quchen> :t \k v m -> (Data.Map.member k m, Data.Map.insert k v m) -- albeit
10:31:08 <lambdabot> Ord k => k -> a -> M.Map k a -> (Bool, M.Map k a)
10:31:15 <quchen> That runs in O(log(n)).
10:31:51 <danilo2> fizruk: I think I see it. I was just thinking - why should we use it when we can just change the definition of datatypes. But of course not always we can (or want) to do this. Then such DataKinds make much sense. I still does not get, how can the example (http://lpaste.net/103672) be usefull, but maybe I'll discover it in shorrt time :)
10:32:38 <merijn> quchen: insertLookupWithKey does it in one traversal
10:32:50 <quchen> Oh, right.
10:33:01 <quchen> I knew there was a function to do this, I just looked for Bool instead of Maybe.
10:33:15 <albeit> quchen: Same!
10:33:34 <merijn> quchen: Ah, bollocks, can't be a category after all... you can't compose "Pipe" with "Parser" (in that order) as that brings the original problem back :\
10:33:35 <albeit> quchen: But I didn't know there was a function to do this ;)
10:33:58 <merijn> You can only compose any number of Parser follow by any number of pipes...
10:34:04 <merijn> So the category laws don't hold
10:34:44 <ReinH> merijn: know of any interesting non-trivial uses of datakinds? Like, not just the data Vec :: * -> Nat -> * that every example uses?
10:35:16 <merijn> ReinH: Abusing type level lists: https://gist.github.com/merijn/6130082
10:35:37 <merijn> ReinH: DataKinds alone is rarely useful. Mostly it's useful with GADTs and/or TypeFamilies
10:35:47 <ReinH> right
10:35:50 <merijn> Disregard github's broken haskell syntax highlighting
10:37:15 <ReinH> argh
10:37:59 <joelteon> b-but single quotes are for character literals, not strings, github...
10:38:08 <joelteon> well, I guess we should call up the pygments guys, it's their fault
10:39:06 <danilo2> fizruk: Thank you very much :)
10:45:37 <zipper> I want to thank xkcd for this awesome one about a virus that reads you your youtube comments --> https://xkcd.com/481/
10:48:08 * hackagebot test-simple 0.1.6 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1.6 (BorisSukholitko)
11:00:54 <pl2> Anyone know of a resource that shows a haskell package alongside a C include equivalent?
11:06:22 <jedai> pl2: What do you mean ? Are you searching for equivalent to some C libraries in the Haskell world ? Working with the FFI ? Other ?
11:08:39 <pranz> :t on
11:08:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:08:42 <pl2> jedai, basically, yes. For example, in C you have a function called shmget, which allocates shared memory. Was just wondering if these types of things were possible in haskel
11:09:20 <spockshock> :t in
11:09:21 <lambdabot> parse error on input ‘in’
11:09:33 <monochrom> "in" is a reserved word
11:09:43 <jedai> So you're basically searching for an access to lower-level memory manipulation in Haskell ? The GHC libs are a good place to search
11:10:13 <geekosaur> you can bind them via the FFI, but I wouldn't use the sysv ipc stuff probably :)
11:10:26 <geekosaur> there are several bindings for mmap on hackage
11:10:36 <jedai> You can also search the C/unix term for what you want on hackage and sometimes find interesting stuff (packages for mmapping)
11:11:16 <jedai> Or of course you could go via the FFI (which is pretty good in Haskell)
11:12:19 <pl2> cool, thanks guys. looking at this stuff now.
11:12:50 <jedai> pl2: for shmget you have http://www.haskell.org/ghc/docs/7.8.1/html/libraries/unix-2.7.0.1/System-Posix-SharedMem.html
11:12:51 <pl2> I LIKE
11:13:03 <yitz> pl2: to share information between threads in haskell, you would normally use higher-level constructs like TChan and TVar, or Chan and MVar.
11:13:18 <jedai> System.Posix contains some interface to the low level Posix stuff
11:14:16 <jedai> pl2: Though like yitz I would caution that Haskell often has better and more idiomatic ways to do similar stuff
11:15:10 <exicer_> Is there a function (a -> b) -> (a -> m b) ?
11:15:17 <exicer_> Where m is a monad
11:15:34 <haasn> :t (return.)
11:15:34 <geekosaur> :t (return .)
11:15:35 <lambdabot> Monad m => (a -> b) -> a -> m b
11:15:35 <lambdabot> Monad m => (a -> b) -> a -> m b
11:15:50 <exicer_> can you use this outside of a do block ?
11:15:51 <ReinH> :t (return .)
11:15:52 <lambdabot> Monad m => (a -> b) -> a -> m b
11:15:54 <ReinH> damn
11:15:57 <ReinH> or fmap return
11:16:01 <pl2> jedai, oh, of course. Was just wonder how "low" i was able to get. Even has nice access to usb built in. Looking forward to messing around a bit..
11:16:06 <haasn> :t (pure<$>)
11:16:07 <lambdabot> (Applicative f1, Functor f) => f a -> f (f1 a)
11:16:20 <geekosaur> exicer_, not sure what you mean by that. do blocks are just syntactic sugar
11:16:47 <exicer_> geekosaur: Yeah - I had tried it and it didn't work. Turned out I'm an idiot and mistyped :p
11:25:19 <ashnur> hi. i am trying to install something with cabal and it gives me an error
11:25:32 <dmj> ashnur: what is your error
11:25:38 <ashnur> using arch linux, if that matters. (and i know nothing about haskell or cabal)
11:26:12 <ashnur> dmj: http://pastie.org/private/87ksjwvhlpzoajoaifl6g
11:26:51 <tobiasgw> Can anyone help me figure out what this syntax with @ and {} does?    functionName q@Search{} = <function body>
11:26:53 <ashnur> and i am trying to install something called `temporary` which is a dependency of elm-repl which is what I actually want :)
11:27:27 <zipper> HaskellCast is taking forever to come out. It's gonna be like Dr. Dre's Detox.
11:28:49 <dmj> ashnur: try looking at the github issues
11:29:51 <ashnur> dmj: well, i didn't even knew if there is a github repo./.. wait. what repo's github issues?
11:30:23 <dmj> https://hackage.haskell.org/package/temporary
11:30:42 <dmj> https://github.com/batterseapower/temporary
11:30:50 <ashnur> thanks
11:30:54 <dmj> np
11:31:36 <ashnur> hah, genius
11:31:58 <ashnur> didn't know this was this fast rolling thing
11:33:24 <Maior> hah
11:33:35 <Maior> dmj: don't suppose you know if Max is in here at all?
11:33:58 <jfischoff> Max has pretty much left the community AFAICT
11:34:13 <Maior> boo
11:34:36 <Maior> (we did undergrad together)
11:35:04 <jfischoff> His packages are slowly being replaced or taken over
11:35:18 <jfischoff> it is unfortunate
11:37:04 <fragamus> http://lpaste.net/103678
11:37:07 <fragamus> WTF
11:37:09 <jfischoff> tobiasgw: {} is used for a pattern match where you don’t care about the fields of a constructor. Just _ <- x ~ Just {} <- x
11:38:03 <haasn> It's a special form of the syntax Ctor { fieldA = patA, fieldB = patB }
11:38:08 <haasn> But without matching any fields
11:38:23 <tobiasgw> jfischoff: so it's the same as _ ?
11:38:33 <haasn> Not really, that's just an example
11:38:40 <haasn> It's the same as including _ for all the fields, though
11:38:45 <jfischoff> ^ this
11:38:45 <dmj> jfischoff: why did he leave?
11:38:49 <tobiasgw> jfischoff: and I'm guessing @ binds the value you match against to a variable then?
11:38:54 <jfischoff> dmj: job I think
11:39:04 <dmj> ah
11:39:10 <haasn> tobiasgw: pretty much, yeah; “var@pat” works like pat, but that entire value is also bound to var
11:39:18 <jfischoff> ^ this
11:39:26 <tobiasgw> great
11:39:29 <tobiasgw> thanks :)
11:39:43 <haasn> :t Just {} -- hmmm
11:39:44 <lambdabot> Maybe a
11:39:51 <tobiasgw> trying to understand the Hoogle source
11:39:58 <haasn> > Just{} :: Maybe ()
11:39:59 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
11:40:18 <jfischoff> ah, Neil reading his code is where I first saw {} too ;)
11:40:26 <monochrom> > case Just{} of Just{} -> "yay"
11:40:27 <lambdabot>  "yay"
11:40:32 <tobiasgw> I want to make it possible to search for return types only
11:40:33 <pranz> is there a vim plugin to automatically split cases when defining a function?
11:40:35 <haasn> Interesting, so there's really no distinction between record-type and regular constructors other than that constructors defined with regular syntax include no field names
11:40:47 <vanila> > Just{}
11:40:49 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
11:40:56 <danilo2> Hello! Could somebody help me please and tell why in the following, short code, the closed type families are mached in wrong way? (http://lpaste.net/103679) I mean, in line 16, ghc chooses the type familie definition from line 9 instead of 10. Why is this happening?
11:41:31 <jfischoff> haasn: The Template Haskell AST would agree with you
11:41:38 <haasn> Wait, what the hell does vanila's example get defaulted to? Does lambdabot have extended defaulting rules?
11:41:51 <pranz> danilo2: the (a -> b) will always be matched, since it's before ma -> b
11:42:00 <vanila> > Just (error "<interactive>:3:1-6: Missing field in record construction")
11:42:03 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
11:42:07 <pranz> danilo2: put the cokleisli arrow at the top
11:42:38 <byorgey> danilo2: how can you tell which one it is picking? does it give an error message?
11:42:39 <haasn> pranz: It's not that simple, because ‘a’ occurs twice
11:42:54 <fragamus> http://www.haskell.org/pipermail/haskell-cafe/2013-August/109681.html
11:43:27 <haasn> Given that, I don't understand danilo2's example
11:44:00 <haasn> Sig (m a -> b) a  -- does not match the (a -> b) a instance
11:44:08 <monochrom> > typeOf ()
11:44:09 <lambdabot>  ()
11:44:14 <monochrom> > typeOf (Just{})
11:44:15 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
11:44:16 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
11:44:16 <lambdabot>  The type variable ‘a0’ is ambiguous
11:44:16 <lambdabot>  Note: there are several potential instances:
11:44:16 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:44:30 <byorgey> danilo2: you should ask goldfire
11:44:34 <danilo2> pranz: If I put the kleisli on top, then yes, it is matched good, but then If I extend the example to something I want to achieve (see the annotation) it does not work
11:44:54 <danilo2> byorgey: Yes it throws an error. Sorry I did not posted it with the code
11:44:59 <jfischoff> fragamus: GHC 7.8 fixed that type of error
11:45:02 <pranz> danilo2: so it does work if the kleisli at the top? hmm
11:45:11 <hiptobecubic> Is it me or is darcs really slow during initial checkout?
11:45:22 <fragamus> mkay so I reinstall haskell platform right
11:45:23 <dagle> Why was I lazy? variable'' was bound to happen with this naming scheme.
11:45:32 <danilo2> byorgey: goldfire? I will then :)
11:45:51 <monochrom> @check (\x -> case x of { Just{} -> True; Nothing -> True })
11:45:53 <lambdabot>  +++ OK, passed 100 tests.
11:46:01 <danilo2> pranz: See the annotation - when kleisli is at the top, than yes, the simple example works, but the annotation I posted later fails
11:46:03 <monochrom> it may default to Maybe ()
11:46:17 <byorgey> hiptobecubic: slow compared to what?
11:47:20 <danilo2> goldfire: Hello! Are you here? byorgey recommended me to contact you in case of a closed type families problem :)
11:48:15 * hackagebot JuicyPixels 3.1.5.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.5.2 (VincentBerthoux)
11:48:37 <haasn> danilo2: I wonder what happens if you turn it into an open type family. I can't really understand why your other example works, intuition tells me that it should only be capable of matching one or the other (because otherwise it would be an infinite type thing)
11:48:53 <haasn> s/works/doesn't work/
11:49:29 <haasn> danilo2: Anyhow, in this case it seems to me you could work around it by just defining Sig (x -> a) = a
11:49:55 <sm> hiptobecubic: maybe a bit, get --lazy helps
11:50:28 <spockshock> bad connection, so excuse the reiteration, any gofer users here?
11:50:56 <pranz> danilo2: yeah I have no idea aswell :/
11:50:59 <danilo2> haasn: It is matching one or other. This is strange, because it matches wrong (to my intuition). What do you mean by "Sig (x -> a) = a" ? This has to little parameters
11:51:20 <haasn> danilo2: It does not seem like the result of Sig depends at all on the second parameter
11:51:42 <maxiepoo> god this transformers/mtl bump has destroyed my packages
11:51:55 <jfischoff> danilo2: that is really odd. Those should unify if I am reading everything right
11:52:24 <monochrom> this is why you either don't bump, or you bump all packages together.
11:53:47 <haasn> danilo2: It almost seems like a shortcoming in GHC's ability to solve closed type families
11:54:07 <jfischoff> my bet is that it is a bug
11:54:12 <haasn> Maybe try simplifying it as far as possible and posting on the GHC trac
11:54:12 <danilo2> jfischoff: I do not know, maybe I'll explain it again, a little simplier. Here is clean example: http://lpaste.net/103681 . I want the instance from line 16 to match type from line 9 and the inst from l. 20 to match type from 10. But ghc always chooses the first from Type families - is it ok?
11:54:25 <maxiepoo> monochrom: I meant packages I was developing
11:54:40 <danilo2> haasn: You are right, in the example I posted it does not depend on the second parameter - it is simplified code
11:54:45 <haasn> Okay
11:54:53 <jfischoff> danilo2: yeah I saw that
11:55:30 <jfischoff> if though the parameter is unnecessary, it should not prevent unification
11:55:32 <maxiepoo> I’ll probably ask for help later
11:56:09 <fragamus> jfischoff: I simply upgrade GHC and then it will work?
11:56:15 <fragamus> http://lpaste.net/103678
11:56:39 <jfischoff> fragamus: no that’s not what I meant. the ghc will give you a warning/error
11:57:02 <jfischoff> assuming that Hashable is using the minimal implementation pragma
11:57:50 <fragamus> I see…  what can I do to make it actually hash correctly
11:57:59 <danilo2> jfischoff: Ok, here is an example with both parameters needed - still it is solved wrong: http://lpaste.net/103682
11:58:05 <haasn> danilo2: I've come up with a simpler example
11:58:27 <danilo2> haasn: I've got here other exampel with both params needed (in case you want to see it) http://lpaste.net/103682
11:58:32 <albeit> @pl \x -> filter (5/=) [1..x]
11:58:32 <lambdabot> filter (5 /=) . enumFromTo 1
11:58:36 <haasn> danilo2: annotated at http://lpaste.net/103681
11:58:55 <haasn> This should work, but doesn't. Depending on the order of the declarations it either can't handle the ~ False or the ~ True case
11:59:24 <jfischoff> fragamus:you need a more recent version of Hashable I think. For some reason you are using a version those does not use the generics default
11:59:26 <haasn> I'll post it to the GHC trac if you want
11:59:38 <danilo2> haasn: Ok, are you sure it should work? Is it a ghc bug?
11:59:46 <haasn> danilo2: That's what we'll find out!
11:59:57 <danilo2> haasn: I woudl be very thankfull! would you also send me link to it please?
12:00:24 <fragamus> jfischoff: I am downloading the latest haskell platform…  sound good?
12:00:41 <prinsen> I have a Pipe where the components needs some static info, ie. static for the execution of the pipe. Is there any way to solve this more type safe than using a reader-monad with a Map String String?
12:01:02 <jfischoff> fragamus: I don’t know. I don’t know what is in the Haskell Platform
12:01:26 <jfischoff> what is the output of `ghc-pkg list | grep hashable`
12:03:46 <bitemyapp> fragamus: I wouldn't. What OS are you on?
12:03:51 <danilo2> By the way, jfischoff, haasn: By the way, taking oportunity to talk to you, for a long time I'm looking for a way to implement "autolift" function, which would allow me to write code like "autolift foo 5" and "autolift foo (Just 5)" , where foo :: Int -> Int . Do you have any idea how could it be implemented so, that it would work even if foo has type of (a -> a) ? I tried many ways - I can posts tests I made If you have any idea 
12:03:57 <fragamus> MacOS
12:04:02 <bitemyapp> fragamus: don't.
12:04:06 <bitemyapp> fragamus: just install the bin dist.
12:04:15 <fragamus> bi dist of what
12:04:19 <fragamus> bin even
12:04:37 <bitemyapp> fragamus: https://www.haskell.org/ghc/download_ghc_7_8_2
12:04:40 <jfischoff> bitemyapp: I think he can just fix his hashable issue without reinstalling everything
12:04:43 <fragamus> mkay
12:04:52 <bitemyapp> jfischoff: I didn't know the original issue, just diverting from HP
12:04:57 * bitemyapp scrolls up
12:05:05 <jfischoff> fragamus: ^
12:05:26 <jfischoff> You don’t need an atom bomb to swat a fly
12:05:49 <bitemyapp> although it is entertaining.
12:05:55 * jfischoff nods
12:07:00 <bitemyapp> just developed an appreciation for Puppet.
12:07:09 * bitemyapp scowls at his Fabric code
12:07:31 <fragamus> im running snow leopard not mavericks
12:07:33 <fragamus> shit
12:07:40 <haasn> danilo2: https://ghc.haskell.org/trac/ghc/ticket/9082
12:07:41 <jfischoff> fragamus: you probably have two versions of Hashable or atleast one old one. You need to either ghc-pkg unregister the bad version, or make sure to specify the one you want in a cabal file, or ghci -hide-package the bad one
12:08:30 <danilo2> haasn: Thank you very, very much for!
12:08:35 <danilo2> *for this
12:09:09 <jfischoff> haasn: I think that example might have other problems
12:09:30 <haasn> jfischoff: Like?
12:09:53 <jfischoff> the type variable’s not showing up in the rest of the signature
12:10:28 <jfischoff> is that why it is complaining about them being ambigous? danilo2’s error I don’t think said anything about that
12:11:25 <vamega> Hi.
12:11:32 <vamega> Anyone here familiar with HXT?
12:11:35 <haasn> jfischoff: Oh, wait, you're right. Changing the signature around to fix this removes the error
12:11:42 <enthropy> hmm, with arrow notation you can't do     pat <- f $ x1 -< x2
12:12:00 * jfischoff nods
12:12:26 <vamega> Well I'm trying to get the content of a page that returns a 404.
12:12:54 <jfischoff> vamega: I know more about this: http://hackage.haskell.org/package/html-conduit
12:12:56 <enthropy> oh actually the issue is    pat <- f $ let a = a in a -< x2
12:13:06 <vamega> However HXT/HXT-http seems to abort on seeing the http error code.
12:13:42 <jfischoff> I would use wreq for http and html-conduit to parse the response
12:13:55 <jnj> I have f1 :: IO (Either String a), f2 :: IO (Either String b), ... - is there a monad to call them one at a time and succed with
12:13:59 <jnj> ah, newline too soon
12:14:58 <jnj> Hm, actually I just realised that I cannot do what I want - please ignore that half question
12:15:01 <vamega> Hmm. I was working off an old but well written tutorial
12:15:02 <vamega> http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
12:15:04 <jfischoff> jnj: you can use wither ErrorT String IO a, or EitherT I don’t remember where the type parameters go
12:15:31 <jfischoff> vamega: http://www.serpentine.com/wreq/
12:15:32 <vamega> Not sure I want to reimplement everything just yet. Especially when I'm almost done at this point.
12:15:39 <vamega> Yeah, I saw Brian's new librar.
12:15:39 <jfischoff> there are tutorials there too
12:15:45 <vamega> *library.
12:16:00 <jfischoff> I’ve never heard good things about HXT
12:16:10 <jfischoff> but maybe it is good
12:18:14 <haasn> danilo2: Oh, actually, this reveals that the issue is *not* that GHC picks the wrong case, observe:
12:19:52 <haasn> danilo2: http://lpaste.net/103684 this works fine
12:20:56 <vamega> I guess I picked HXT since it's been around a while.
12:21:07 <vamega> And has been updated fairly recently.
12:21:10 <vamega> And the tutorial.
12:21:17 * jfischoff nods
12:21:32 <vamega> I knew of wreq, but didn't want to dive into the lens API for what I was hoping would be a quick project.
12:22:01 <danilo2> haasn: Hmm, interesting. But in your example the type is matched with "~" - I do not know if this coudl be the case, but in my example, the type is matched while resolving instance declarations, so this is before matching types with "~" If Im not wrong
12:22:04 <jfischoff> oh right lens
12:22:12 <jfischoff> perhaps that was wise
12:23:04 <jfischoff> danilo2, haasn: danilo2’s example should still work
12:23:33 <danilo2> jfischoff, haasn: Maybe its good idea to post my example on the bug tracker then ?
12:23:40 <jfischoff> I think so
12:24:36 <danilo2> haasn, jfischoff: I would post this one: http://lpaste.net/103682 (it uses both variables and is clear)
12:25:28 <jfischoff> delete this instance: instance Monad m => Pipe (a->b) (m a) where
12:25:37 <jfischoff> and the hello world part
12:25:48 <jfischoff> you’ll still get the error no?
12:26:12 <danilo2> jfischoff: Why should we delete it? Maybe it will show what the example is trying to achive and will be more clear?
12:26:21 <jfischoff> I don’t think so
12:26:46 <jfischoff> The problem is that something that should unify is not
12:26:53 <exicer_> Is there some clever way to do Either a b -> (b -> m (Either a c)) -> m (Either a c) ? It looks kinda like >>=..
12:27:34 <jfischoff> danilo2: have to go to lunch
12:27:45 <danilo2> jfischoff, haasn: If you want, here is annotation with the shorter version: http://lpaste.net/103682
12:27:58 <danilo2> jfischoff: Ok, thank you for the help! :)
12:28:43 <haasn> danilo2: I've posted https://ghc.haskell.org/trac/ghc/ticket/9082#comment:2
12:28:49 <haasn> Which should also work
12:28:50 <enthropy> is anybody familiar with arrows notation? http://lpaste.net/103687 confuses me
12:31:07 <danilo2> haasn: Thank you :) I hope somebody will respond fast because I'm scractching my head whats happening there :) Thank you very much :) I've got to go now (I'll be available in an hour - in case something will update). Thank you once again
12:31:35 <albeit> Is it normal to prepend "_" to functions that aren't exported from a module, or otherwise differentiate them?
12:31:38 <AndChat|11121> Why is haskell better than Javascript?
12:31:48 <Cale> albeit: Not particularly
12:32:01 <Cale> albeit: You could do it if you like, I suppose
12:32:22 <Cale> AndChat|11121: It has an excellent type system, for one.
12:32:46 <napping> AndChat|11121: where could you use both?
12:32:47 <enthropy> a leading _ suggests that you are ok with the function not being used anywhere
12:33:07 <Cale> AndChat|11121: Also, functions in Haskell are referentially transparent, which makes debugging and reasoning about your code much easier.
12:33:28 <napping> albeit: not that I've ever seen, they're just not exported
12:33:34 <Cale> (i.e. if you give a function the same arguments, it will always produce the same result)
12:33:47 <albeit> napping: Cale: Okay, thanks
12:33:48 <AndChat|11121> But in javascript, I can do "1"+1 and it will compile
12:33:58 <pavonia> enthropy: Why would you define a function that isn't used anywhere?
12:34:15 <Cale> AndChat|11121: Which is not great, tbh
12:34:48 <Nik05> AndChat|11121 "1"+1 doesnt make anysense
12:34:54 <Cale> AndChat|11121: That kind of automatic coercion is responsible for many bugs.
12:35:30 <haasn> enthropy: That's some really weird scoping
12:35:32 <enthropy> pavonia: it might get used in doctests... but besides that I don't see any point
12:35:37 <Cale> Nik05: In Javascript, the number 1 is coerced to a string which is then concatenated with "1"
12:35:45 <Cale> So the result is the string "11"
12:36:24 <FireFly> You could define a "JS-like" string concatenation operator in terms of Show :p
12:36:28 <Cale> i.e. it's similar to what "1" ++ show 1 means in Haskell.
12:36:35 <FireFly> That'd give you typesafe automatic coercion
12:36:39 <haasn> enthropy: http://lpaste.net/103688
12:37:10 <haasn> enthropy: However, the ‘g’ is in scope on the right side of -<
12:37:19 <Cale> FireFly: You might actually want to make a type class just for that, because the handling of strings wouldn't be the same
12:37:26 <monochrom> implicit conversions are evil
12:37:38 <FireFly> Oh, that's true
12:37:42 <monochrom> Type Directed Implicit Conversions
12:37:43 <haasn> enthropy: Oh, here's the relevant line of documentation, from http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
12:37:54 <haasn> “That would make no sense if the expression to the left of -< involves the bound variable x. More generally, the expression to the left of -< may not involve any local variable, i.e. a variable bound in the current arrow abstraction. For such a situation there is a variant -<<”
12:38:33 <monochrom> the variant -<< requires ArrowApply
12:38:40 <haasn> enthropy: So to summarize, you have to use -<< not -< if you want to use locally bound names on the left hand side of it, but that requires ArrowApply
12:38:56 <jfischoff> danilo2: does this work: http://lpaste.net/103682
12:39:16 <haasn> But you can still have a regular old expression there, which is why your version with parens worked
12:39:47 <jfischoff> err
12:40:04 <danilo2> jfischoff: it does not compile ( Expecting one more argument to ‘Pipe (a -> b) (m a)’)
12:40:11 <jfischoff> yes I’m fixing that
12:40:57 <enthropy> haasn: so maybe my question is why doesnt it parse as  b <- (let g t = succ t in g) -< x
12:40:59 <jfischoff> danilo2: http://lpaste.net/103682
12:42:17 <haasn> enthropy: Something something extending as far right as possible something, I think
12:42:19 <danilo2> jfischoff: No, still getting error: Couldn't match type ‘b’ with ‘Sig (a -> b) a’
12:42:32 <danilo2> jfischoff: I'm sorry I really have to leave now. I'll be back in 30 minutes
12:42:33 <monochrom> probably "in" is greedy to the right in Haskell grammar. similarly lambdas are, too
12:42:34 <haasn> enthropy: (let g t = succ t in g -< x) is valid
12:42:56 <jfischoff> danilo2: I don’t have 7.8 at work, so I don’t know
12:43:22 <dagle> Anybody have any input? http://ix.io/c8e
12:43:23 <monochrom> doesn't arrow do-proc notation has its own "let" too so you don't have to say "in"?
12:43:55 <haasn> monochrom: It does
12:44:06 <monochrom> "let g t = succ t" newline "b <- g -< x" newline ...
12:44:10 <haasn> But the “let.. in” that is being used here is actually a fourth variant, one specific to arrow commands
12:45:46 <haasn> In arrow-do, we have “pat <- cmd” which means the right hand side is a cmd, not an expression; and “let decls in cmd” is a valid cmd, so the right hand side of the “in” has to be a cmd, eg. “exp -< exp” or “exp -<< exp”
12:45:51 <enthropy> monochrom: that one needs -<<
12:46:09 <monochrom> I see
12:46:41 <haasn> I wonder if this is actually an ambiguity in the grammar
12:47:19 <enthropy> I guess my confusion is that I assumed the grammar had something like  pat <- exp -< cmd
12:47:28 <enthropy> but it's split up a bit more
12:48:29 <haasn> It seems to me like pat <- (let_expr decl in exp) -< exp  and pat <- (let_cmd decl in exp <- exp) are both valid parses that both satisfy the greediness or whatever
12:50:31 <enthropy> well ghc's parser does have some shift/reduce conflicts
12:51:33 <skypers> hm
12:51:55 <skypers> is there another way than adjacency matrices/list to represent graph in Haskell?
12:52:08 <skypers> I think it’s impossible with typed value
12:52:35 <skypers> we can do that with trees, but not cyclic graphs, right?
12:53:56 <enthropy> > let circularList = cycle [1,2,3] in circularList
12:53:57 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
12:54:11 <klrr_> anyone know a good library for shell scripts? i wrote a script with shellmate but when i installed it i realized it dont compile due to a type error, anyone know any other such library that provides specifically an api similar to this "foo :: Command -> Args -> m Output" preferply just using String types
12:55:01 <enthropy> skypers: you can do a similar thing with a graph, but the representations that aren't finite are more convenient
12:55:14 <enthropy> err, the finite ones are easier to handle
12:55:26 <skypers> enthropy: I don’t see how it’s possible
12:55:37 <skypers> imagine you have two nodes
12:55:40 <skypers> how do you connact them?
12:55:46 <enthropy> does the circularList look like a circular list?
12:55:56 <haasn> enthropy: Ah, “In both the lexical and the context-free syntax, there are some ambiguities that are to be resolved by making grammatical phrases as long as possible, proceeding from left to right (in shift-reduce parsing, resolving shift/reduce conflicts by shifting).”
12:56:12 <skypers> data Node a = Node a [Node a]
12:56:21 <skypers> with that, it’s imposible to make it a cyclic graph
12:56:23 <haasn> so pat <- (let_cmd decl in exp <- exp) is the only valid parse, because the “let” here is longer than the other type of “let”
12:56:26 <skypers> impossible*
12:56:42 <vanila> skypers, what about let g = Node x [g]
12:57:01 <skypers> vanila: I think it’s a <<loop>>
12:59:30 <Peaker> was there supposed to be a #haskell-newbies channel created?
12:59:44 <croyd> Peaker: #haskell-beginners
12:59:49 <enthropy> klrr_: you have tried System.Process.readProcess?
12:59:53 <Peaker> ah, thanks
13:00:56 <athan> is there a popular homotopy type theory channel yet? I really don't have the advanced background to understand the implications yet
13:01:02 <enthropy> skypers: vanila's example is  Node x [Node x [Node x [Node x [ ...
13:01:21 <NemesisD> is it a Very Bad Idea in a concurrent program to use something like a ReaderT (TVar a) IO ()?
13:01:38 <NemesisD> for mutable state between threads
13:01:39 <napping> that sounds perfectly fine
13:02:11 <NemesisD> i know that shared mutable state in concurrent programs is typically considered harmful
13:02:16 <napping> Well, as long as you can tolerate the contention on the TVar
13:02:36 <napping> It's bad to use shared state you don't need
13:02:52 <NemesisD> yeah this isn't really performance critical. the concurrency is for cross-concerned inputs/outputs rather than for parallelism
13:03:37 <napping> Then a single TVar probably isn't the best way to go, compared to queue types or something
13:03:37 <NemesisD> i'm playing around with Tekmo's new MVC library for a project i'm working on
13:03:55 <ashnur> i read somewhere a few months ago, that arch linux has very good haskell support. but I can't get almost anything running. i mean, ghci and the very basic things worked, but ever since I installed a few haskell packages, I've always had problems with some random haskell package not installing. because I am not using it, I just ignored, and later tried to use cabal for stuff ile purescript. but now, I wanted
13:03:57 <ashnur> to install Elm, and I can't not from the repositories which are given in the install docs on Elm, and not from cabal. So, tell me, does arch really have good support and is it really possible to use the packages, or I should just wipe everything repo based and try something general linuxy solution?
13:03:59 <Peaker> NemesisD: in some cases it might make sense to abstract over the shared mutable state with a safe interface that closes over it, but explicit, typed, shared mutable state you're aware of is fine.. The real problem is shared-mutable-state hiding under every variable
13:04:04 <napping> maybe pipes-concurrent then, if it's with pipes
13:04:31 <napping> NemesisD: the biggest problem is if you have non-threadsafe variables, like a plain IORef, and you acidentally write to them and get data races
13:04:36 <Peaker> NemesisD: what's the content of the TVar, what operations do you do on it?
13:04:47 <Peaker> napping: there's the wonderful atomicModifyIORef :)
13:05:16 <Peaker> I love atomicModifyIORef, it's the poster-boy for Haskell's benefits (purity allowing spinning inside it, and laziness allowing deferring work outside the critical spinning)
13:05:34 <ChongLi> hi
13:05:35 <ChongLi> http://lpaste.net/raw/103691
13:05:37 <napping> what's that about spinning inside it?
13:05:43 <jfischoff> cas loop
13:05:54 <NemesisD> Peaker: so i'm working on a process monitor using MVC. controllers are concurrent inputs, the model is a pure one with a state, views are outputs.
13:05:54 <ChongLi> how do I go about figuring out which package is limiting the version to 0.3.0.0?
13:06:04 <ChongLi> of MonadCatchIO-tranformers
13:06:07 <napping> Oh, I guess you would have trouble computing the new value without purity
13:06:15 <Peaker> NemesisD: what's the TVar's concrete type?
13:06:17 <awestroke> can anyone familiar with Control.Parallel.Strategies explain this data type to me? data Eval a = Done a  (http://hackage.haskell.org/package/parallel-3.1.0.1/docs/src/Control-Parallel-Strategies.html#Eval)
13:06:31 <jfischoff> ChongLi: there are new cabal flags that let you override the constraints on install
13:06:36 <jfischoff> might be useful here
13:06:38 <NemesisD> Peaker: so my controllers generate events such as new configs being loaded, requests to shutdown, processes dying. the model gets these events and issues directives of what to do
13:06:43 <jfischoff> but I haven’t used them
13:06:51 <ChongLi> jfischoff: hmmm
13:07:08 <NemesisD> Peaker: the TVar will probably wrap over a Map ProcessName PHandle
13:07:13 <napping> NemesisD: anyway, TVar doesn't get data races, so the question is just whether ReaderT is the best way to thread around your state
13:07:24 <NemesisD> napping: whats the alternative
13:07:27 <geekosaur> awestroke, I see a big chunk of haddock right before that definition that seems to explain things
13:07:37 <ChongLi> MonadCatchIO-transformers is broken on base-4.7.0.0
13:07:43 <napping> Compared to a plain TVar, TChan is better for a channel of events
13:08:03 <ChongLi> MonadCatchIO-tranformers-0.3.0.0 is broken on base-4.7.0.0 that is
13:08:04 <NemesisD> napping: MVC handles the event multiplexing for me, i don't have to worry about that
13:08:14 <napping> then why do you need a TVar?
13:08:23 <ashnur> guess, i will just wipe then
13:08:25 <pranz> :t use
13:08:26 <lambdabot> MonadState s m => Getting a s a -> m a
13:08:40 <awestroke> geekosaur: I've read that, but I don't see the point of having data Eval a = Done a, and then: runEval :: Eval a -> a   defined as   runEval (Done x) = x
13:08:56 <NemesisD> napping: the problem i need to handle is that both the "input" (controller) part of this pipeline and the "output" (view) need to be able to hang on to PHandles so they can act on directives and generate events
13:08:57 <Peaker> NemesisD: and what kind of higher-level operations do you have on that map? Perhaps you could carry around these operations, rather than the lower-level TVar?
13:09:27 <geekosaur> awestroke, so read down a bit, specifically the comment on (>>=) for instance Monad Eval
13:09:56 <NemesisD> Peaker: need to be able to kill a process (grab phandle, remove that entry, kill the phandle), and add new ones to the registry (M.insert)
13:09:58 <napping> NemesisD: Isn't that just allowing state in the View and Controller?
13:10:01 <ashnur> ok. just a last desperate try: anyone using arch linux here?
13:10:05 <napping> where do threads come in?
13:10:18 <awestroke> geekosaur: so even though it can never be anything else than Done, the pattern match forces the evaluation to WHNF?
13:10:23 <ChongLi> jfischoff: ahh, I just stuck the dependency in my project directly
13:10:24 <Peaker> NemesisD: e.g: instead of TVar (Map ProcessName PHandle)   have a record:  ProcessMapping { addProcess :: ProcessName -> PHandle -> IO () ; killProcess :: ProcessName -> IO () ... }  <-- something like this -- to restrict access to the TVar to only the correct operations
13:10:39 <napping> ashnur: guess not
13:10:41 <NemesisD> napping: MVC is naturally concurrent, so i have a concurrent input for handling POSIX signals, a concurrent input monitoring for process death, etc
13:10:41 <ChongLi> and set its constraint to >= 0.3.1.0 && < 4
13:11:03 <napping> are you using asInput and pipes-concurrency?
13:11:03 <Peaker> NemesisD: another alternative is ProcessMapping being an abstract type hiding the TVar, and exposing only these safe operations
13:11:03 <jfischoff> ah I guess it was using that one you had installed?
13:11:06 <NemesisD> Peaker: how am i to close over to the fact that its using a map internally
13:11:07 <ChongLi> jfischoff: seems as though it had some flexibility there but just happened to choose a bad one
13:11:13 <NemesisD> Peaker: ahh now you're talkin
13:11:15 <ChongLi> jfischoff: no this is all in a sandbox
13:11:18 <geekosaur> I am not sure it evaluates x to WHNF, but it ensures that some evaluation happens so that (>>=) itself is strict instead of lazy
13:11:18 <NemesisD> i like that. more testable
13:11:20 <Peaker> NemesisD: instead of creating a TVar, you can create that record
13:11:22 <jfischoff> odd
13:11:25 <NemesisD> napping: yeah
13:11:39 <ashnur> NemesisD: thx
13:11:44 <ChongLi> jfischoff: I would've thought it'd try to use the newest version allowed by all the dependencies
13:11:47 <ashnur> damn. napping thx
13:11:52 <jfischoff> likewise
13:12:25 <napping> NemesisD: where were you planning to use the TVar then?
13:12:58 <napping> sounds like you ought to be able to just merge all the Input you need, and the View can be a (a -> IO ()) that closes over whatever state you need
13:13:09 <napping> and the Model can't/shouldn't touch any outside state at all
13:13:16 <ChongLi> but otherwise so far so good for upgrading to ghc 7.8
13:13:19 <NemesisD> napping: when the controller and view are initialized (in the Managed monad) i was going to allocate the TVar and give it to both of them
13:13:20 <klrr_> anyone know a good library for shell scripts? i wrote a script with shellmate but when i installed it i realized it dont compile due to a type error, anyone know any other such library that provides specifically an api similar to this "foo :: Command -> Args -> m Output" preferply just using String types
13:13:34 <Eduard_Munteanu> Any idea why http://hackage.haskell.org/package/hsql-mysql is deprecated and what should be used instead? The sqlite and postgres variants aren't marked as deprecated.
13:13:54 <NemesisD> napping: don't need Model to touch outside state (and can't. its impossible). need the controller and view to have a little shared state
13:14:23 <supki> ChongLi: you can try  cabal install --constraint='MonadCatchIO-transformers >= 0.3.1.0'  to get a better error
13:14:41 <NemesisD> napping: maybe this will help: the view has a responsibility of killing processes, the controller has a responsibility of notifying the model when a process is killed or otherwise dies
13:14:50 <supki> ChongLi: assuming there's a reason why cabal didn't choose the latest version
13:15:29 <napping> sounds like the TVar wouldn't be authoritative anyway then
13:15:44 <NemesisD> napping: it might be that i need to accomplish this with a chan between the two instead. i haven't gotten that far in the implementation
13:15:55 <napping> Isn't the view getting events from the OS?
13:16:20 <NemesisD> view is getting directives from the model. directives like kill these processes, or exit, or spawn these processes
13:16:51 <NemesisD> controller is registering hooks on the processes for when they die
13:18:02 <enthropy> klrr_: you have tried System.Process.readProcess?
13:19:41 <klrr_> enthropy: EXACTLY what i wanted, thanks :3
13:19:56 <enthropy> good thing I said it twice :p
13:23:45 <ChongLi> supki: I got it to choose the latest version by manually changing the constraint in my .cabal file
13:31:39 <albeit> Is there a List function, sort of like nub, but only keeps the first element in a sequence of equal elements? So f [1,1,2,2,1,1] = [1,2,1]
13:31:59 <Eduard_Munteanu> albeit: map head . group
13:32:15 <albeit> Eduard_Munteanu: :) Thanks!
13:32:22 <Eduard_Munteanu> > map head . group $ [1,1,2,2,1,1]
13:32:23 <lambdabot>  [1,2,1]
13:34:05 <jle`> hm
13:34:10 <jle`> you can make it unpartial
13:34:29 <Eduard_Munteanu> It's not partial overall.
13:34:38 <jle`> > group [1,1,2,2,1,1] >>= take 1
13:34:39 <lambdabot>  [1,2,1]
13:34:53 <jle`> > take 1 =<< group []
13:34:54 <lambdabot>  []
13:34:58 <jle`> > take 1 =<< group [1,1,2,2,1,1]
13:35:00 <lambdabot>  [1,2,1]
13:35:01 <Eduard_Munteanu> group is guaranteed to not make empty lists.
13:35:06 <jle`> oh really?
13:35:10 <dmj> > group []
13:35:12 <lambdabot>  []
13:35:18 <jle`> oh neat, nvm  then :)
13:35:20 <Eduard_Munteanu> > map head []
13:35:21 <lambdabot>  []
13:35:26 <jle`> head is scary to me
13:35:31 <jle`> i have nightmares
13:35:41 <ciaranm> just remember to breath
13:36:05 <jle`> it's hard in the moment
13:36:32 <newsham> > take 1 =<< group []
13:36:33 <lambdabot>  []
13:36:50 <Eduard_Munteanu> Take one for the group? :)
13:36:57 <albeit> @pl \x y -> f x == f y
13:36:58 <lambdabot> (. f) . (==) . f
13:37:09 <albeit> :t \x y -> f x == f y
13:37:10 <lambdabot>     Could not deduce (Eq a0) arising from a use of ‘==’
13:37:10 <lambdabot>     from the context (Show t1, Show t)
13:37:10 <lambdabot>       bound by the inferred type of
13:37:17 <Redz> is there another name for filtersort, described on the "why haskell matters" page? because it seems undocumented.
13:37:24 <Eduard_Munteanu> :t (==) `on` f
13:37:25 <lambdabot>     Could not deduce (Eq b0) arising from a use of ‘==’
13:37:26 <lambdabot>     from the context (Show a)
13:37:26 <lambdabot>       bound by the inferred type of it :: Show a => a -> a -> Bool
13:38:08 <Eduard_Munteanu> @unpl (==) `on` f
13:38:08 <lambdabot> (on (==) f)
13:38:12 <Eduard_Munteanu> :(
13:38:27 <newsham> > map Data.List.NonEmtpy.head $ Data.List.NonEmpty.group [1,1,2,2,1,1]
13:38:29 <lambdabot>  Not in scope: ‘Data.List.NonEmtpy.head’Not in scope: ‘Data.List.NonEmpty.group’
13:39:18 <newsham> oops, Data.List.NonEmpty.map too
13:39:36 <newsham> use head without the guilt
13:39:53 <hiptobecubic> Is the haskell platform several months behind schedule or am I not reading the right thing
13:40:14 <newsham> hipto: thats how i read it..  estimated release last nov right?
13:40:25 <jfischoff> hiptobecubic: yes
13:40:28 <geekosaur> the fall2013 was skipped because they wanted ghc 7.8 which took forever
13:40:33 <geekosaur> (for the OS X fix)
13:40:43 <hiptobecubic> Is there anything OSX hasn't ruined :) ?
13:40:52 <newsham> so now that 7.8.2 is out, is HP imminent?
13:40:53 <geekosaur> currently planning a release sometime this month
13:40:57 <newsham> awesome
13:41:55 <jfischoff> mzero has told me he is close, but is struggling to find the time. He has also been working on BayHac stuff
13:43:05 * geekosaur notes that it's not just OS X any more, since freebsd will probably at least consider switching its ghc / H-P ports to clang if it works
13:43:47 <geekosaur> (freebsd 10 uses clang instead of ghc; the current haskell ports install gcc47 from ports to avoid the cpp issues with clang)
13:43:50 <newsham> yah freebsd is keen to get rid of gcc bits
13:44:02 <monochrom> interesting development
13:44:03 <geekosaur> er instead of gcc
13:44:05 <geekosaur> derp
13:44:11 <monochrom> heh
13:44:45 <ciaranm> netcraft confirms, freebsd is dead
13:49:38 <mada> I want to define a lens that I can use to access and update either element of a pair according to a datatype with two possible values (e.g. A|B), so for example f A = (x,y)._1
13:50:16 <newsham> freebsd is dead?
13:50:29 <Rembane> Long live freebsd!
13:51:04 <roconnor> mada: f A = _1; f B = _2 ??
13:53:24 <codygman> Any ideas on how I would make the browser wait infdefinitely with the webdriver library? https://hackage.haskell.org/package/webdriver-0.5.3.2/docs/Test-WebDriver-Commands-Wait.html
13:53:29 * hackagebot yesod-auth-account 1.2.5 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.5 (JohnLenz)
13:53:33 <dmwit_> Is this a bug in GHC?
13:53:36 <dmwit_> http://lpaste.net/103692
13:53:46 <dmwit_> Typechecks fine in 7.6, but gives an error in 7.8.
13:55:08 <hiptobecubic> how is that valid at all
13:55:39 <dmwit> hiptobecubic: Why shouldn't it be valid?
13:55:58 <n-dolio> Because you need to put type signatures on GADT matching functions.
13:56:12 <mada> roconnor: thank you. I couldn't figure out how to pass an argument to the lens
13:56:14 <jfischoff> dmwit_: the general feedback on GADT’s tends to be “if a type signature fixes the issue… then it isn’t a bug” :p
13:56:19 <mada> *Main> st^.armies.(_attacker Blue)
13:56:27 <mada> (for example)
13:56:29 <dmwit> jfischoff: Not even regressions?
13:56:39 <dmwit> =(
13:56:55 <jfischoff> I don’t know, I would hope not :)
13:56:56 <n-dolio> dmwit: If they accepted regressions, they'd have to throw out the new system in favor of the old one.
13:57:30 <roconnor> mada: heh.  Less complicated than you thought.
13:58:05 <dmwit> n-dolio: I don't see that your conclusion follows from your premise.
13:58:22 <n-dolio> The new system caused tons of 'you have to annotate' regressions with respect to the old one.
13:59:02 <dmwit> Okay. Why isn't this mentioned in the release notes? The notes say "faster" and "sleeker"... but not "worse". =(
13:59:30 <jfischoff> haha
13:59:34 <n-dolio> I don't honestly understand how it worked in 7.6.
13:59:42 <n-dolio> Which of the two types did it give?
13:59:57 <dmwit> Line t -> ()
14:00:28 <roconnor> mada: f A = _1; f B = _2; f C = ignored -- this is a fun example too, but produces a traversal instead of a lens.
14:00:42 <dmwit> But just the question you just asked actually is the answer I was looking for.
14:00:52 <dmwit> The fact that there's two perfectly good types tells me why it's complaining.
14:01:10 <jfischoff> ah
14:01:14 <jfischoff> Now I get it
14:01:18 <dmwit> yeah
14:01:24 <dmwit> Complaint withdrawn. =P
14:01:31 <enthropy> wouldn't "combine :: Line t -> t" be a better type?
14:01:38 <n-dolio> Would it?
14:01:48 <dmwit> enthropy: Not if I wanted to know it returned (). =)
14:02:26 <n-dolio> I thought 7.6 already had that kind of thing in it, though.
14:02:35 <n-dolio> This is 7.6.3?
14:02:44 <dmwit> 7.6.1
14:02:47 <n-dolio> Oh.
14:02:56 <n-dolio> I think that might have actually changed in one of the point releases.
14:03:00 <dmwit> ouch
14:03:15 <n-dolio> 2 -> 3 maybe.
14:03:57 <thoughtpolice> .2 -> .3 IIRC was merely a regression in the type checker that allowed you to write unsafeCoerce
14:04:07 <n-dolio> 1 -> 2, then. :)
14:04:21 <n-dolio> Or maybe I'm just confused.
14:04:28 <thoughtpolice> "A bug which could cause GHC to accept or infer an incorrect type, resulting in a <<loop>> at runtime, has been fixed." 2 -> 3
14:04:45 <thoughtpolice> i see nothing in the 7.6.2 release notes suggesting fixing some programs that were invalid yet compiled
14:05:04 <dmwit> I don't think my program is invalid.
14:05:13 <dmwit> It doesn't have a most general type, but that's very different.
14:05:19 <danilo2> jfischoff: I'm back :) Anyway, the code you provided gives the same error as mine :( This is strange - I hope somebody will answer on the bugtracker :)
14:05:27 <fragamus> bitemyapp: whats your main objection to reinstalling the platform
14:05:28 <n-dolio> It's not even invalid to choose one of them.
14:05:39 <n-dolio> Just unprincipled.
14:05:45 <dmwit> right
14:05:48 <jfischoff> show n-dolio and dmwit your example
14:05:53 <thoughtpolice> yes, right. in any case, i'm not sure whether to chalk the fact it did compile up to a bug, or whether it actually should have.
14:06:08 <n-dolio> And unprincipaled.
14:06:08 <thoughtpolice> if you file a bug, Simon will likely chime in quickly with some rationale I'm sure
14:06:23 <dmwit> no no
14:06:30 <dmwit> I'm convinced this is the right thing for GHC to do now.
14:06:36 <dmwit> Though the error could be improved. =P
14:07:06 <Dominic__> Hi, is there an equivalent for the C fwrite?  Or should I use ByteStrings and the Put monad and so on?  I'm trying to write an unboxed Vector of Ints to disk and it's driving me nuts!
14:07:41 <fragamus> OK im going to reinstall the haskell platform. what's the worst that could happen
14:08:06 <dmwit> Dominic__: Put seems reasonable to me. What's the objection?
14:08:35 <Dominic__> Thanks!  I just wanted to check I wasn't missing anything.
14:08:45 <napping> Dominic__: you might check out the storable vectors
14:09:22 <Dominic__> Interesting idea.  Thanks!
14:10:05 <napping> or checking the ByteArray the normal vectors are built on
14:10:35 <Dominic__> Oh.
14:10:57 <napping> ah, the Data.Vector.Unboxed doing stuff like turning Vector (a,b) into a pair of unboxed vectors probably confuses any simple fwrite
14:13:31 * hackagebot zeromq4-haskell 0.5.1 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.5.1 (ToralfWittner)
14:13:48 <Dominic__> Thanks for your help.  I will have a go with the Put monad.  Do I need to use that Binary class to send one Int at a time to the ByteString?
14:14:11 <napping> I wouldn't be surprised if Put is just about as efficient as converting from another vector type anyway
14:15:12 <napping> Dominic__: there's probably a primitive put operation for ints
14:15:18 <napping> otherwise you'd have to go through Binary
14:16:30 <Dominic__> Cool.  thanks.  I think I made things extra confusing for myself today by using mutable vectors.
14:17:00 <napping> Oh, binary just has putWord at various sizes, I guess fromIntegral would convert
14:17:34 <ChongLi> hmmm, looks like this isn't going to work
14:18:17 <ChongLi> http://lpaste.net/raw/103694
14:18:31 * hackagebot zeromq4-haskell 0.6 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.6 (ToralfWittner)
14:18:37 <newsham> looks like if you wanted to get ugly and low-level you could turn a bytestring into a CString which you could then cast to a IntPtr and then peek Int out of
14:19:03 <ChongLi> transformers-0.3.0.0 is part of /usr/lib/ghc-7.8.2/package.conf.d
14:19:10 <ChongLi> so does that mean I'm stuck with it?
14:19:26 <jfischoff> can you bump the lens version?
14:19:42 <jfischoff> I’m not sure that will help … actually let me check
14:20:27 <ChongLi> http://lpaste.net/raw/103696
14:20:44 <ChongLi> that's after bumping the lens version
14:20:48 <jfischoff> ChongLi: -ftransformers3
14:21:05 <jfischoff> that is a flag used by transformers-compat-0.3
14:21:31 <jfischoff> https://hackage.haskell.org/package/transformers-compat-0.3/transformers-compat.cabal
14:21:36 <edwardk> i'm still upgrading my whole ecosystem after mtl/transformers
14:22:33 <edwardk> ChongLi: what ghc version are you on?
14:22:47 <edwardk> ChongLi: and what platform? what transformers version came with it?
14:23:02 <ChongLi> edwardk: 7.8.2
14:23:14 <ChongLi> it came with transformers-0.3.0.0
14:23:22 <ChongLi> (this is Arch linux)
14:23:33 <wojtekM_> Dear list, hello again. Trying to move (beyond Show) with type classes, I've run into the following error, which I do not understand. http://lpaste.net/103695
14:23:33 <edwardk> you can probably get by with a --constraint 'transformers-compat < 0.2' for right now
14:24:14 <edwardk> i probably have 60 hours of coding to fully fix this debacle, so many dependencies broke off the transformers/mtl change
14:24:31 <hiptobecubic> gross
14:24:38 <jfischoff> class Num move => Predictor predictor move | predictor -> move where
14:24:53 <jfischoff> wojtekM_: ^
14:25:09 <ChongLi> edwardk: ahhh yeah
14:25:15 <wojtekM_> jfischoff: Yes, with this it works, but I don't know why I need this.
14:25:17 <ChongLi> I'm just slogging through this all now
14:25:22 <ChongLi> but I want to get it done
14:25:27 <ChongLi> I really want to use ghc-7.8
14:25:35 <wojtekM_> jfischoff: Should I read the original Mark Jones paper?
14:25:52 <jfischoff> wojtekM_: can’t hurt
14:26:39 <jfischoff> basically it is saying, “if you every use ‘initial’ anywhere I will be able to infer the ‘predictor’ type, but not the ‘move’ type
14:26:53 <jle`> .b 3
14:27:03 <jfischoff> another way to fix it is to have the signature of initial :: move -> initial
14:27:10 <dmj`> Is the memory footprint between IntMap and Map comparable?
14:27:33 <wojtekM_> jfischoff: but why does it need move type for restart function?
14:27:39 <ChongLi> I'm seriously considering dropping fay from my project
14:27:54 <jfischoff> its to figure out the class instance to use initial
14:27:55 <ChongLi> this stuff is so frustrating
14:28:18 <jfischoff> and part of what it needs to know is the move type to find the instance
14:28:33 <roconnor> ChongLi: what's the issue?
14:28:41 <roconnor> sorry I didn't read back.
14:28:57 <ChongLi> roconnor: just dependency hell; due to ghc-7.8 upgrade
14:29:37 <ChongLi> fay is a dependency of my project but I don't use it for very much at the moment
14:29:45 <jfischoff> the predictor -> move says that the predictor type determines the move type
14:29:47 <ChongLi> and it adds a lot of its own dependencies
14:29:48 <wojtekM_> jfischoff: Oh, okay! I think I get it. Thank you. I'll read MJ paper anyway.
14:30:02 <jfischoff> so it then just needs the predictor type.
14:30:04 <jfischoff> cool
14:30:09 <ChongLi> and complicates the build process with snaplet-fay
14:30:12 <wojtekM_> jfischoff: Would I rather use type families?
14:30:21 <jfischoff> no
14:30:29 <ChongLi> is JMacro recommendable as an alternative?
14:30:38 <ChongLi> I just want to do some ajax forms
14:30:44 <wojtekM_> jfischoff: okay
14:30:52 <ChongLi> but I hate the idea of writing naked javascript
14:31:04 <jfischoff> wotjekM_: the problem is you could have an instance like Predictor Int Int  and Predictor Int String
14:31:14 <jfischoff> that have different initial values
14:31:28 <jfischoff> so which should it use if it only know initial is an Int?
14:31:32 <dmj`> ChongLi: All my js is naked, it's not so bad
14:31:46 <vanila> I don't see why haskell is better
14:31:48 <jfischoff> it is ambiguous
14:31:57 <vanila> it still ends up javascript in the end
14:32:05 <jfischoff> vanilla: I hope ;)
14:32:11 <ChongLi> I'm a type-a-holic
14:32:18 <vanila> I thihnk we need to kill javascript somehow
14:32:21 <dmj`> if (a && a.foo) { $.get('/thing', function(result) { console.log("got ajax", result); }) };
14:32:35 <jhbecares> hi everyone, I am trying to define my own data ExpBool, it's something like Exp :== Exp | Exp :< Exp | ... etc, but when I try to do something like :not ExpBool, I'm getting the following error: parse error on input `:'. What am I doing wrong?
14:32:59 <lahwran> vanila: it's harder to write haskell that produces broken javascript
14:33:07 <quchen> jhbecares: What's the "..."?
14:33:09 <wojtekM_> jfischoff: maybe I could move initial to some superclas?
14:33:14 <dmj`> vanila: become president, then turn into a dictator, then enforce a national browser that manipulates the DOM w/ haskell, make HTTP stateful while you're at it
14:33:19 <lahwran> vanila: but pretty easy to write broken javascript
14:33:40 <dmwit> jhbecares: Constructors need to be either all letters or all symbols.
14:33:45 <jhbecares> quchen: the "..." is just more functions like :>
14:33:51 <vanila> jhbecares, use Not instead of :not
14:33:58 <dmwit> jhbecares: And they need to start with an upper-case, as I guess you already knew (where ':' is the only "upper-case" symbol).
14:34:41 <jhbecares> vanila: thanks, it worked :)
14:35:03 <jhbecares> dmwit: that was also another problem I had, thank you!
14:38:09 <enthropy> data Exp = (:⌐) Exp -- might be the answer
14:38:28 <benzrf> that looks like a weird face
14:38:32 <benzrf> (:⌐)
14:39:59 <enthropy> actually ghc accepts the definition "data N = ⌐ Int"
14:40:17 <enthropy> actually ghc accepts the definition "data N = (⌐) Int"
14:41:29 <ReinH> is ⌐ a letter or a symbol?
14:41:50 <pavonia> > isSymbol '⌐'
14:41:51 <lambdabot>  True
14:42:32 <quchen> > generalCategory '⌐'
14:42:33 <lambdabot>  OtherSymbol
14:42:42 <yorick> I need a list of some kind with fast indexing and fast appending, is Data.Sequence the right thing?
14:43:12 <quchen> Indexing isn't terribly fast for Seq, I think.
14:43:36 <enthropy> seems like a bug to accept a data definition like that
14:46:06 <Eduard_Munteanu> yorick: appending in what context?
14:46:23 <yorick> Eduard_Munteanu: appending to the end of the list
14:46:54 <ReinH> sounds like a job for vector
14:47:43 <Eduard_Munteanu> yorick: yes, but how will you use it? In many cases a list is suitable for this if you associate (++) the right way (e.g. as in Writer).
14:47:59 <yorick> Eduard_Munteanu: yes, it is, but not indexing.
14:48:17 <yorick> Eduard_Munteanu: I'm currently using a Map and appending (size m, x) to it
14:48:30 <Eduard_Munteanu> IIRC, Seq gets progressively slower as you move towards the center.
14:48:36 * hackagebot hood-off 0.2 - Dummy package to disable Hood without having to remove all the calls to observe  http://hackage.haskell.org/package/hood-off-0.2 (PepeIborra)
14:48:53 <Eduard_Munteanu> yorick: you mean inserting into it?
14:49:07 <yorick> yes, but an incrementing number
14:49:18 <Eduard_Munteanu> Oh.
14:50:20 <visi0n> why can't I run replicate on forkIO? Doesnt seem to run any of the threads
14:50:29 <merijn> :t replicate
14:50:30 <lambdabot> Int -> a -> [a]
14:50:35 <merijn> :t replicate forkIO
14:50:36 <lambdabot> Not in scope: ‘forkIO’
14:50:40 <Eduard_Munteanu> replicateM?
14:50:57 <merijn> visi0n: Essentially what Eduard_Munteanu says
14:51:04 <visi0n> oh yeah thats probalby it.
14:51:09 <merijn> :t replicate 5 (forkIO undefined)
14:51:10 <lambdabot> Not in scope: ‘forkIO’
14:51:14 <merijn> awww
14:51:24 <merijn> visi0n: Anyway, that returns "[IO ()]"
14:51:25 <visi0n> XD
14:51:31 <visi0n> yeah makes sense
14:51:39 <merijn> visi0n: Which, obviously, doesn't run the action :)
14:51:42 <merijn> :t replicateM
14:51:43 <lambdabot> Monad m => Int -> m a -> m [a]
14:53:50 <visi0n> not quiet obvious for me yet but I'm getting there ^_^
14:54:24 <quchen> enthropy: It's not a bug, the Haskell standard specifies constructor symbols ("consym" in the grammar) as "semicolon, followed by other symols", where the symbols are "any Unicode symbol or punctuation".
14:56:19 <jhbecares> And, if I want to have True and False in my data ExpBool, should I declare it Bool or what? Because if I do that, then defining evaluation':: ExpBool -> Bool
14:56:20 <jhbecares> I should have something like: evaluation' True = True as my base case, and of course they are not of the same type so it won't work...
14:56:23 <enthropy> quchen: it's missing the colon (assuming you mean "colon, followed by other symbols")
14:57:23 <quchen> Oh, I said semicolon instead of colon.
14:57:54 <merijn> quchen: enthropy's point was that GHC accepts it *without* the colon
14:58:16 <ChongLi> jfischoff: okay, finally got it building again
14:58:19 <ChongLi> thanks for the help!
14:58:25 <quchen> Ooh.
14:58:29 <jfischoff> np
14:58:45 <enthropy> it's not really a big issue because you can't do anything with the "⌐" "constructor"
14:58:46 <ChongLi> parallel builds is so awesome
14:59:03 <benzrf> ChongLi: parallel builds?
14:59:04 <ChongLi> really cut down the time on installing all the dependencies into the sandbox
14:59:09 <roconnor> ChongLi: damn it; what was the help?
14:59:21 <roconnor> ChongLi: I was hoping to convert you to nix.
14:59:21 <Gurkenglas> In ghci, I used :break main to try to look at what the program does (It compiled and it doesn't do what I want! >:c). It ran through without stopping at main.
14:59:27 <ChongLi> roconnor: hahaha
14:59:35 <ChongLi> I used nixos for a while
14:59:50 <Gurkenglas> What could I have done wrong about the debugging?
14:59:53 <roconnor> oh, you moved from nixos to arch?
14:59:55 <roconnor> wow
14:59:55 <sipa> roconnor: FYI, "nix" in dutch is approximately how you pronounce "nothing"
15:00:03 <ChongLi> roconnor: well I started on arch
15:00:07 <ChongLi> and used nixos on a trial basis
15:00:10 <ChongLi> and moved back
15:00:30 <roconnor> ChongLi: I hadn't realized that people do that.
15:00:44 <ChongLi> my main complaints were the lack of documentation and lack of packages
15:00:47 <merijn> sipa++
15:01:02 <roconnor> sipa: nix is Dutch software.
15:01:03 <merijn> sipa: Bit unfortunately formulated, but correct :p
15:01:07 <ChongLi> but that's probably what I deserve for mixing my dev machine with my everyday machine
15:01:27 <roconnor> Does arch have good documentation?
15:01:32 <ChongLi> yeah
15:01:33 <sipa> merijn: "the Dutch translation for the english word 'nothing' sounds appromxately like how pronounce 'nix' in English"
15:01:34 <roconnor> interesting
15:01:36 <sipa> merijn: better? :)
15:01:37 <ChongLi> a huge wiki
15:01:48 <ChongLi> and a busy IRC channel with tons of helpful people
15:02:01 <sipa> roconnor: ha!
15:02:04 <ChongLi> and TONS of packages
15:02:04 <merijn> sipa: Yes :)
15:02:12 <sipa> +you
15:02:13 <ChongLi> that are updated very frequently
15:02:15 <roconnor> sipa: from TU Delft.
15:02:41 <FireFly> I wonder if that's cognate with the Swedish slang word "nix", meaning "nope"
15:03:13 <ChongLi> benzrf: sorry, yes
15:03:14 <sipa> in swiss german i think it means the same
15:03:24 <ChongLi> cabal made parallel builds the default recently
15:03:32 <ousado> and in non-swiss german too
15:04:00 <sipa> ousado: oh, really?
15:04:06 <Gurkenglas> Here's the ghci log. The important part is at the bottom.
15:04:08 <Gurkenglas> http://pastebin.com/wrNVq3h1
15:04:13 <ousado> sipa: yes
15:04:19 <sipa> good to know
15:04:23 <roconnor> ChongLi: well, FWIW, nix-build -A pkgs.haskellPackages_ghc782.fay just completed for me from the latest nixpkgs git repo
15:04:28 <benzrf> ChongLi: whats that in response to?
15:04:32 <roconnor> ChongLi:  so if you ever feel like returning ... :)
15:04:44 <roconnor> ChongLi: you can install nix under arch and have fay running in a few minutes.
15:04:48 <ChongLi> benzrf: you asked about parallel builds
15:05:22 <ChongLi> roconnor: the issue is more complex than that
15:05:23 <ChongLi> haha
15:05:38 <flebron> Hi. Where could I find a Haskell implementation of length-checked vectors (statically) being sorted?
15:06:02 <flebron> Sorted or maybe binary search, something interesting with indices that works with statically checked vector bounds.
15:06:19 <ChongLi> roconnor: I can install fay just fine too
15:06:21 <Gurkenglas> (The code if anyone wants it:) http://lpaste.net/103699
15:06:24 <hpc> look at the vector packages on hoogle
15:06:29 <ChongLi> but not when it's a dependency of my project
15:06:39 <ChongLi> due to a multitude of interactions
15:07:06 <merijn> hmm
15:07:09 <roconnor> ChongLi: then you definitely need to install nix. :D
15:07:19 <ChongLi> how does nix solve that?
15:07:27 <merijn> I need some help writing a stateful attoparsec parser
15:07:42 <ChongLi> the conflicts are within my project itself
15:07:43 <roconnor> ChongLi: you make a nix expression to build your project, right?
15:07:49 <roconnor> >.<
15:08:11 <merijn> Am I just boned if I need state in attoparsec?
15:08:16 <roconnor> I see
15:08:37 <ChongLi> dependencies of dependencies of dependencies
15:08:40 <ChongLi> that sort of thing
15:08:58 <jfischoff> merijn: is unsafePerformIO . readIORef  boned?
15:09:02 <ChongLi> you know what'd be really cool?
15:09:06 <jfischoff> probably
15:09:12 <ChongLi> if you could incorporate nix technology into ghc's package database
15:09:17 <merijn> jfischoff: Yes
15:09:25 <jfischoff> hmm
15:09:28 <ChongLi> so that I could just do cabal install all day long
15:09:32 <merijn> jfischoff: Because I don't see how that could ever work bug free
15:09:38 <ChongLi> and never have anything break; have it be referentially transparent
15:09:39 <jfischoff> me either
15:09:41 <hexagoxel> Gurkenglas: i suspect some form of caching. have you tried re-opening ghci and adding breakpoint before executing main?
15:09:46 <merijn> argh, ffs
15:10:04 <jfischoff> I’m not smart enough to use unsafePerformIO that way
15:10:25 <merijn> Actually, maybe I'm not boned, I dunno?
15:10:56 <jfischoff> can you wrap it in a stateT?
15:10:59 <merijn> It seems like "StateT s (Parser Text) b" should work?
15:11:03 <jfischoff> yeah
15:11:10 <merijn> I'm not sure how that works out with partial results, though...
15:11:13 <Gurkenglas> hexagoxel, thanks, that worked
15:12:00 <merijn> @unmtl StateT s (Parser Text) b
15:12:00 <lambdabot> s -> (Parser Text) (b, s)
15:15:13 <merijn> ok, that works, but only as long as my parse doesn't fail
15:15:32 <merijn> At least, hopefully it works :p
15:15:55 <merijn> At the very least it compiles :p
15:18:38 <btcNeverSleeps> I'm doing a few of the '99 Haskell problems' and it's ok but I've got a few questions. For example here I can easily come up with the first solution: http://www.haskell.org/haskellwiki/99_questions/Solutions/4  (which uses pattern matching and explicit recursion?) and I understand the accumulator version too. But...
15:19:08 <btcNeverSleeps> what about something like: myLength'      =  foldl (\n _ -> n + 1) 0     Is is "less typed"?  Where's the    myLength :: [a] -> Int   line gone?
15:20:54 <flebron> Types don't need to be explicit, most times the compiler can infer it for you.
15:21:18 <flebron> For example, if f xs = length xs + 1, then f must be of type [a] -> Int.
15:21:56 <flebron> Any other type you gave it would be either wrong or less general than [a] -> Int.
15:22:23 <quchen> (Note that it's good practice to write down type signatures anyway, especially if your definition is at the top level.)
15:22:42 <merijn> btcNeverSleeps: The short answer is sloppiness/laziness :)
15:23:01 <btcNeverSleeps> ah I see... I'll try a few things :)
15:23:14 <merijn> :t foldl (\n _ -> n + 1) 0
15:23:14 <lambdabot> Num b => [a] -> b
15:23:30 <merijn> btcNeverSleeps: See, GHC is perfectly happy to infer what type that *should* have :)
15:23:57 <btcNeverSleeps> oh woaw... I tried C-c C-t (ghc-show-type under Emacs) and it did indeed infer "[b] -> Int" on mylenght' !
15:24:28 <btcNeverSleeps> merijn: yup, sick stuff, I love it ^ ^
15:24:37 <merijn> btcNeverSleeps: The main reasons to write down type signatures are 1) documentation, it's much easier to see what a function does if you can see it's type and 2) error checking, if you know the type *should be* "[a] -> Int", and you accidentally write something with a *different* type, GHC will yell at you
15:25:17 <merijn> btcNeverSleeps: Because maybe the "wrong" function you wrote happens to typecheck in some obscure way you didn't intend. But GHC can't know that unless you tell GHC what type you *expect* it to have
15:25:25 <btcNeverSleeps> I didn't check yet but maybe that "99 Haskell problems solution", just to be concise, do not repeat the type signature for all the ', '', ''', '''', etc. solutions.
15:26:16 <merijn> btcNeverSleeps: Yes, hence the laziness/sloppiness comment. Rewriting the type 10 times is very cluttered and time consuming if they're all the same
15:26:33 <btcNeverSleeps> merijn: I see. I'd notice anyway as soon as I'd try to use the function.  But I understand it's better to type sign top-level defs.
15:27:05 <merijn> btcNeverSleeps: btw, you don't even need to write the type near the function, it's perfectly ok to write "myLength :: [a] -> Int" on line 10 and only define "myLength" on line 100 or so
15:27:10 <btcNeverSleeps> merijn: oh gotcha, I thought you meant laziness/sloppiness from Haskell programmers doing that in their program for top level functions.
15:27:15 <merijn> (Although that kind of defeats the purpose :p)
15:27:20 <btcNeverSleeps> hehe
15:27:34 <jhbecares> como vas?
15:27:37 <jhbecares> yo mal :(
15:28:03 <newsham> merijn: if you use cpp you can even #include them ;-)
15:28:05 <deni> is there something like 4clojure.com for haskell?
15:29:03 <deni> or is project Euler my best bet? I need something to type random code solutions for small problems so I get some haskell muscle memory here :D
15:29:10 <merijn> @where exercises
15:29:10 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
15:29:12 <btcNeverSleeps> deni: I'm doing "99 problems in Haskell" manually.
15:29:20 <merijn> deni: I would recommend those over Project Euler
15:29:35 <Gurkenglas> @let counts [] = []
15:29:36 <lambdabot>  Defined.
15:29:43 <Gurkenglas> @let counts (x:xs) = archive (counts xs) x
15:29:43 <lambdabot>  .L.hs:145:19: Not in scope: ‘archive’
15:29:50 <Gurkenglas> @let archive [] key=[(key,1)]
15:29:51 <lambdabot>  Defined.
15:29:52 <prinsen> What is the best way to combine Pipes producers?
15:29:57 <Gurkenglas> @let archive ((key,count):tail) item=if(key==item) then ((key,count+1):tail) else archive tail key
15:29:58 <lambdabot>  Defined.
15:30:05 <Gurkenglas> @let counts (x:xs) = archive (counts xs) x
15:30:06 <lambdabot>  Defined.
15:30:13 <Gurkenglas> > counts [3,2,6,3,3,6,6]
15:30:15 <lambdabot>  [(6,1)]
15:30:16 <deni> merijn: btcNeverSleeps awesome. tnx
15:30:24 <Gurkenglas> Why? I don't get it. Debugging didn't make sense of it either.
15:30:37 <merijn> prinsen: In what way?
15:31:11 <prinsen> merijn: Into one producer
15:31:20 <merijn> prinsen: Yes, in what way
15:31:31 <Gurkenglas> > archive [(6,1)] 6
15:31:31 <newsham> gurken:   else   (key,count):archive tail key  ?
15:31:31 <monochrom> there are infinitely many meanings of "combine"
15:31:32 <lambdabot>  [(6,2)]
15:31:33 <merijn> prinsen: First one, then the other, interleaved, etc?
15:31:36 <newsham> you're throwing away the head
15:31:47 <btcNeverSleeps> In "foldl (\n _ -> n + 1) 0", for example, are there other ways to declare the anonymous function than '\'? (for example Clojure has both the #(..) shorthand but you can also use (fn [...] ...) if you want)?
15:32:02 <newsham> btc: sections and lambda (backslash)
15:32:06 <prinsen> merijn: They produce independent part of a datatype that is then combined and fed further down the pipe
15:32:21 <newsham> fold (+1) 0 [1..5]
15:32:22 <btcNeverSleeps> newsham: googling on "haskell sections"...
15:32:34 <EvanR> what are common options for writing a program that does IO, but is restricted to only certain IO operations
15:32:45 <quchen> EvanR: DSL?
15:32:57 <EvanR> like, a custom newtype
15:33:00 <merijn> EvanR: SafeHaskell + careful newtyping and package trust or a DSL and newtype around IO
15:33:15 <btcNeverSleeps> newsham: sweet, thanks
15:33:18 <quchen> If you've only got a handful of operations, you can write your own IO. The free monad will probably be helpful.
15:33:28 <EvanR> the free monad
15:33:36 <Gurkenglas> newsham, I think that would be it...
15:33:49 <Gurkenglas> > archive [(3,1)] 4
15:33:50 <lambdabot>  [(3,1)]
15:33:51 <merijn> quchen: I ended up just writing my own parse loop for attoparsec
15:33:55 <dwcook> prinsen, well, you could write a Pipe that awaits from each and then yields the combination. I think (Pipes.Extras.+++) might be useful there.
15:34:07 <Gurkenglas> Waaaait shouldn't that be [(4,1)]?
15:34:10 <quchen> merijn: Using Pipes.Parse's API?
15:34:24 <merijn> quchen: No, that's unneeded for what I want
15:34:46 <quchen> merijn: Oh, so you're just yielding a certain input and then parse that as one?
15:35:02 <mmachenry> Could anyone explain to me why my program is so slow? I implemented that same test program as a friend who wrote it in Perl and his completes in seconds and mine runs forever. http://lpaste.net/103702
15:35:29 <merijn> quchen: I have "Parser a b -> (a -> [String] -> String -> Pipe a b m a) -> Pipe a b m r" (i.e., just parse an "infinite" stream of a's into b's
15:35:57 <newsham> gurkenglas: you should be able to step through each execution step since your code is pure
15:36:04 <newsham> to see why it is behaving as it is
15:36:15 <monochrom> mmachenry: no memoization happened. your algorithm is exponential time
15:36:26 <mmachenry> monochrom: Really? Why not?
15:36:27 <Gurkenglas> newsham, I did that but I failed to understand why it behaved like it did
15:36:44 <merijn> quchen: The second argument being an "on parse error" function that gets the parse errors results and can await/yield any number of values, returning an 'a' and then parsing picks up from that 'a'
15:36:56 <monochrom> really.
15:37:33 <monochrom> what is "memoize2"?
15:37:47 <monochrom> scratch that. where can I see "memoize2"?
15:37:55 <Gurkenglas> The part of my brain whom I gave the job of determining where the error was answered that "if then else" doesn't work as I think it does, which didnt make sense so I came here
15:37:55 <mmachenry> It memoizes a 2-argument function
15:38:06 <merijn> quchen: The other, nicer/more powerful one is: "StateT s (Parser a) b -> (a -> [String] -> String -> Pipe a b m a) -> s -> Pipe a b m r", that is let me run a stateful parser in an infinite loop :)
15:38:39 <quchen> merijn: I'm glad you solved your problem! :-)
15:38:47 <quchen> And with such pretty types ;-)
15:39:04 <monochrom> I cannot find where I can see "memoize2".
15:39:11 <mmachenry> http://hackage.haskell.org/package/memoize-0.1/docs/src/Data-Function-Memoize.html
15:39:17 <newsham> > archive [] 4
15:39:18 <lambdabot>  [(4,1)]
15:39:24 <newsham> > archive [(3,1)] 4
15:39:26 <lambdabot>  [(3,1)]
15:39:26 <merijn> quchen: Of course a simple option for the error function is to simply throw a parse error exception, but I figured allowing for a "generic" way to deal with parse errors seemed nicer, as it allows you to silently drop parser errors via "\_ _ _ -> return mempty"
15:39:27 <prinsen> merijn: How can I await three different data types in a pipe?
15:39:39 <merijn> prinsen: You can't really do that
15:39:41 <quchen> ಠ_ಠ Unicode arrows in source files
15:39:50 <dwcook> prinsen, the (+++) I mentioned
15:39:56 <ozgura> ffi question: any pointers on how to pass lists between Haskell and C? (I am using c2hs)
15:40:08 <merijn> ozgura: Foreign.Marshal.Array
15:40:09 <dwcook> You need to be able to phrase them as an Either thought
15:40:15 <dwcook> (which of course you can)
15:40:17 <prinsen> merijn: I could ofcourse use 3 pipes and yield partially applied results
15:40:29 <quchen> merijn: Sounds reasonable, yes.
15:40:33 <Gurkenglas> Also, of course it must be (key,count):archive tail item. ._.
15:40:46 <monochrom> then perhaps memoization happened
15:40:46 <ozgura> merijn: thanks!
15:40:52 <merijn> prinsen: I recommend dwcook's suggestion of using either Either or "data Foo = Bar | Baz | Quux"
15:41:23 <flebron> So this is perhaps not kosher, but say I have data Vector :: * -> Nat -> *, with Cons and Nil as ctors. I have an f :: Vector a (Suc n) -> ...  split into two cases: f (Cons x Nil) and f (Cons x v). How can I tell haskell "Yo, v is not Nil, you can assume it's of type Vector a (Suc n) for some n!"?
15:41:28 <quchen> mmachenry: Your "p" function should recursively call the memoized function, not "p" again.
15:41:29 <merijn> prinsen: So basically define an ADT for your 3 options and await those
15:41:39 <dwcook> Yeah, the advantage of (+++) is that you get to write separate pipes instead of handling all cases with one. If the latter is fine, go with an ADT
15:41:55 <flebron> I know I can say something like v@(Cons _ _), but I'd rather have the compiler understand that that's the only other possible ctor v could have.
15:42:31 <prinsen> merijn: well its not as safe right? The compiler cant verify that I actually can compose the result
15:42:31 <merijn> flebron: It should be able to infer that
15:42:51 <quchen> mmachenry: Right now your "p" is very exponential.
15:43:03 <monochrom> ah, that's it.
15:43:09 <merijn> prinsen: Right, but there' is no safe way to turn "Producer a m r", "Producer b m r" and "Producer c m r" into "Producer (Foo a b c) m r"
15:43:22 <newsham> Gurkenglas: you are passing "key" as "item" when you recurse
15:43:29 <merijn> prinsen: At least, not that I know off!
15:43:44 <monochrom> perhaps you should use memoFix2
15:43:54 <Gurkenglas> newsham, :37:02 - <Gurkenglas> Also, of course it must be (key,count):archive tail item. ._.
15:44:16 <flebron> merijn: http://ideone.com/DkutFI
15:44:19 <dwcook> I wish Tekmo were here. He'd probably have a better idea.
15:44:26 <newsham> http://lpaste.net/103704
15:44:38 <merijn> prinsen: Actually, you may be able to do this using Pipes.Prelude.zip or Pipes.Prelude.zipWith
15:44:38 <flebron> If I force-match v@(Cons _ _), then Haskell realizes it can unify the types. If I just say v, it doesn't.
15:44:45 <mmachenry> quchen: I am not really sure how this works.
15:44:54 <dwcook> Oh neat, those exist.
15:45:06 <monochrom> mmachenry: it means "p r s = memoP 1 0 * memoP (r-1) s + ..."
15:45:38 <quchen> Lines 10-12: replace all "p" with "memoP".
15:45:47 <merijn> flebron: Oh, right. The short answer is "GHC's inference isn't smart enough yet. Tough luck." :)
15:45:55 <dwcook> prinsen, +1 for zipWith, sounds like the exact answer to your question.
15:46:10 <prinsen> dwcook: merijn Cool Ill look in to it!
15:46:12 <merijn> flebron: Well, the alternative is patching GHC's inference to be smarter :>
15:46:16 <flebron> merijn: Aww :( Agda would know how to do that, right?
15:46:26 <merijn> flebron: Maybe, not sure
15:46:44 <flebron> (I'm preparing a few talks on dependent typing, that's why I'm juggling Agda and Haskell wrt dependent types, seeing what breaks where)
15:46:59 <merijn> flebron: It's *could* be done in haskell, it's just that making the solver smart enough is hard and just writing "(Cons _ v@(Cons _ _))" is easy :)
15:47:32 <merijn> flebron: So there's no conceptual reason GHC doesn't do it, other than "no one wrote it" :)
15:47:39 <quchen> mmachenry: It might also be useful to sort downwards and taking 10, instead of sorting, reversing, and taking 10.
15:47:48 <flebron> Isn't it Turing complete or something?
15:47:54 <merijn> flebron: Don't think so
15:47:57 <flebron> (Type deduction in dependent types in general)
15:48:36 <quchen> Turing completeness and undecidability are two different things.
15:48:41 <merijn> flebron: In general it's undecidable which is not the same as "It's Turing complete"
15:48:57 <monochrom> type checking is Gödel-incomplete in most depedent type systems
15:49:36 <mmachenry> quchen: I did that already yeah, silly not to do that.
15:49:39 <flebron> Right, so even worse haha
15:50:04 <flebron> It could be undecidable for some ugly reason, but it seems it's undecidable because it's Turing complete
15:50:05 <merijn> flebron: Anyhoo, Haskell, not having dependent types doesn't necessarily have that problem
15:50:23 <flebron> (For some definition of "because")
15:50:32 <quchen> mmachenry: q is symmetric with respect to x and y. You can save a lot of cases in 'result' because of this.
15:50:37 <merijn> flebron: RankNTypes breaks it, but afaik TypeFamilies, DataKinds and GADTs (without the RankN bits) just make it hard, not impossible
15:51:07 <merijn> flebron: Why is it Turing complete?
15:51:08 <quchen> mmachenry: Namely, you can write "y <- [0..x]".
15:51:11 <monochrom> "Turing-complete" usually refers to "can express all algorithms". it is, of course, related to undecidability.
15:51:32 <dmj`> how do I find the max value of Int on my platform using haskell?
15:51:35 <merijn> flebron: Consider Agda, it's total, including the types :)
15:51:44 <merijn> > maxBound :: Int
15:51:45 <lambdabot>  9223372036854775807
15:51:56 <quchen> merijn: Oh, actually I just heard Idris is total. Is that just the type system, or the entire language?
15:52:00 <flebron> merijn: Just a hunch, seems like if I can express naturals and arbitrary recursive functions, that should be enough for Turing completeness
15:52:01 <dmj`> 9223372036854775807
15:52:10 <merijn> quchen: Idris has an optional totality checker, afaik
15:52:10 <dmj`> merijn: thanks
15:52:33 <merijn> quchen: I think you can write partial Idris code
15:52:40 <quchen> merijn: Oh, *optional*. I was already wondering how a Turing-incomplete language could be general purpose.
15:52:50 <merijn> quchen: Easy, Partiality monad
15:53:00 <merijn> quchen: Agda is total and it's still turing complete
15:53:02 <quchen> I like how you combined those in the same sentence.
15:53:28 <quchen> Anyway, that explains the explicit "total" keyword in Idris. Concerns gone!
15:53:29 <merijn> quchen: You can have infinite recursion by having a partial monad that evaluates N steps and then asks "did you wanna continue?"
15:53:36 <dmj`> @typ gets
15:53:37 <lambdabot> MonadState s m => (s -> a) -> m a
15:53:50 <quchen> merijn: How does it ask that?
15:54:00 <quchen> merijn: I'm sure you're not talking about user interaction
15:54:04 <merijn> quchen: I dunno, I don't write Agda :p
15:54:07 <flebron> Giving you a continuation?
15:54:17 <monochrom> popup dialogue box
15:54:18 <merijn> quchen: But yeah, giving you a continuation
15:54:18 * flebron is now imagining things.
15:54:39 <monochrom> "do you want to continue? how about a game of chess?"
15:54:42 <quchen> merijn: And what can you do with that? Have the runtime loop it?
15:54:47 <merijn> quchen: Right
15:55:06 <merijn> quchen: Ask me in two months :p
15:55:07 <quchen> Oh, so the language is incomplete, but the runtime allows running it as if it had general recursion
15:55:33 <merijn> There will be an Agda class at OPLSS, so :)
15:55:55 <defanor> quchen: totality does not necessary imply turing-incompleteness
15:56:07 <defanor> afaik
15:56:25 <merijn> defanor: Well, it does
15:56:33 <merijn> defanor: But for a programmig language that's irrelevant
15:56:44 <merijn> defanor: See how Haskell manages to be pure and still have IO
15:56:58 <merijn> Your language doesn't need to be total to be able to write total programs, that is the point
15:57:03 <quchen> To get my definitions right, totality means no non-bottom inputs yield bottoms?
15:57:09 <defanor> merijn: doesn't coinduction allow to write turing-complete total programs?
15:57:54 <merijn> defanor: But, since Turing completeness requires the ability to do infinite recursion and totality prohibits anything non-terminating, so totality does, in fact, imply Turing incompleteness
15:58:12 <merijn> quchen: Right
15:59:41 <btcNeverSleeps> does Tony "dibblego" Morris sometime frequent this forum? (dibblego used to be his IRC nick a long time ago)
15:59:58 <albeit> I'm struggling to make this a single line... help please! "foo <- getFoo a <$> baz; bar <- getBar c <$> pure foo"
16:00:05 <btcNeverSleeps> s/forum/channel/
16:00:19 <pavonia> Yes, he does
16:00:28 <btcNeverSleeps> pavonia: his nick is still dibblego?
16:00:39 <ddere> btsNeverSleeps: yep
16:00:59 <pavonia> btcNeverSleeps: I think so, while the first vowel changes sometimes
16:01:08 <quchen> albeit: That is a single line.
16:01:37 <albeit> quchen: Specifically, without the intermediate foo variable.
16:02:47 <merijn> albeit: Why are you trying to make it a single line?
16:02:56 <quchen> foo <- fmap (getFoo a) baz >>= fmap (getBar c) -- or something along those lines.
16:03:07 <merijn> quchen: Even simpler
16:03:08 <quchen> Note how it's an unreadable mess.
16:03:13 <merijn> quchen: Notice the pure around foo
16:03:15 <albeit> I don't need the foo, and it seems like a waste to have it there.
16:03:23 <defanor> merijn: um, wouldn't it be a non-terminating function which reads a colist, produced by another total function?
16:03:26 <merijn> He could just write "getBar c . getFoo a <$> baz"
16:03:41 <merijn> defanor: I'm not well versed enough to answer that
16:03:49 <quchen> merijn: I noticed the pure, but decided to refactor it wrong :-þ
16:04:08 <Iceland_jack> albeit: Is somebody charging per variable name? :)
16:04:24 <merijn> defanor: Well, why are you using <- to get it out of a functor only to put it back in using pure?
16:04:27 <albeit> Ha thankfully no, just felt it could be cleaner...
16:04:35 <albeit> merijn: Thanks!
16:04:38 <merijn> defanor: Err, sorry that was for albeit
16:04:49 <albeit> merijn: That's what I was wondering myself :)
16:04:57 <merijn> albeit: This is why we have Functor laws!
16:05:11 <merijn> albeit: One of the functor laws is "fmap f . fmap g == fmap (f . g)"
16:13:32 <kqr> is there a better way of writing "sequence $ map (fmap f) xs"?
16:13:49 <geekosaur> @src mapM
16:13:49 <lambdabot> mapM f as = sequence (map f as)
16:13:55 <kqr> it totally feels like there should be, but i'm probably missing something obvious
16:13:59 <geekosaur> still need that fmap though...
16:14:09 <kqr> ah
16:14:13 <kqr> that's what i wanted though
16:14:23 <kqr> i tried with mapM but couldn't for the life of me figure out why it didn't work
16:14:28 <kqr> turns out i had missed the fmap!
16:15:13 <hae> mapM (fmap f) xs
16:15:37 <btcNeverSleeps> are there code analyzers for Haskell that can make suggestions?  For example something detecting things that can be written in a simpler way?
16:15:40 <pavonia> @pl \f xs -> sequence $ map (fmap f) xs
16:15:40 <lambdabot> (sequence .) . map . fmap
16:15:46 <hpc> btcNeverSleeps: hlint
16:16:28 * dwcook has been chastised for actually writing (f .) . g before :P
16:16:48 <kqr> dwcook, i don't like it, but that might be inexperience
16:16:57 <kqr> in general, i dislike operator sections composed with operators
16:17:00 <btcNeverSleeps> hpc: thanks
16:17:20 <pavonia> I like to use (.:) instead
16:17:24 <dwcook> I think things like (+ 1) . (* 5) are fine, but composition is slightly more mentally taxing.
16:17:32 <Iceland_jack> I try to avoid (.:) in general
16:18:53 <dwcook> If (.:) were more idiomatic it'd probably be okay.
16:19:06 <dwcook> It might be okay regardless. Opinions vary!
16:19:40 <Iceland_jack> It's fine if your opinion differs from mine if you don't mind being wrong /s :)
16:21:34 <dwcook> That's okay, I don't mind being wrong in general, I just stop being wrong once I'm convinced. :P
16:25:06 <merijn> btcNeverSleeps: lpaste has hlint support builtin
16:25:13 <merijn> btcNeverSleeps: Which incidentally you can also run locally
16:30:00 <btcNeverSleeps> merijn: "lpaste"?
16:30:09 <dwcook> lpaste.net
16:30:16 <dwcook> See also the topic
16:48:53 * hackagebot mmorph 1.0.3 - Monad morphisms  http://hackage.haskell.org/package/mmorph-1.0.3 (GabrielGonzalez)
16:50:59 <identity> mighty morphin' monad rangers
16:53:07 <benzrf> amazing
16:53:22 <benzrf> with the power to imprison evil side effects
16:53:26 <benzrf> they can join together to form
16:53:30 <benzrf> uh
16:53:30 <benzrf> something
16:53:36 <benzrf> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:53:39 <benzrf> oops
16:54:16 <hpc> http://sprignaturemoves.com/blog/wp-content/uploads/2011/06/slash-backslash.png
16:58:54 * hackagebot transformers 0.4.1.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.4.1.0 (RossPaterson)
17:04:42 <EvanR> any idea what <,> means in (<f,g>;h)
17:05:43 <quchen> In what context did you see this?
17:07:16 <EvanR> this paper http://lambda-the-ultimate.org/node/4525
17:07:27 <EvanR> page 1141
17:07:40 <glguy> <f,g> x = (f x, g x)
17:07:52 <EvanR> ah
17:07:54 <glguy> In the Category Theory context
17:08:14 <EvanR> <f,g> = \x -> (f x, g x)
17:10:04 <EvanR> that makes sense now
17:11:36 <benzrf> hpc: https://imgur.com/gallery/2YMIQ
17:11:52 <DogeHayashi> Nooby question: If I have a Prism' a b, and a list of a, is there any way I can use that prism on the list of a to get a list of b, being all the elements of a for which the prism can get to a b?
17:11:56 <saml_> benzrf, thanks
17:12:17 <saml_> DogeHayashi, yes
17:12:32 * DogeHayashi is having his brain summarily melted by lens at the moment
17:12:52 <saml_> > map Just [1,2,3]
17:12:54 <lambdabot>  [Just 1,Just 2,Just 3]
17:12:57 <saml_> you mean something like that?
17:13:00 <identity> DogeHayashi: brain meltage is a feature. it was added in 0.1
17:13:04 <saml_> map Prism' [a1, a2, a3\
17:13:26 <saml_> DogeHayashi, give me type signature of the thing that you want
17:13:47 <saml_>  [a] -> [b] -> [Prism' a b]    ?
17:14:26 <Gurkenglas> I think he wants Prism' a b -> [a] -> [b]
17:14:28 <DogeHayashi> saml_: I have a Prism' a b, and would like something of the form (Prism' a b) -> [a] -> [b]
17:14:33 <quchen> f :: Prism' a b -> [a] -> [b], I assume, such that `f _Just = catMaybes . map f`
17:14:34 <DogeHayashi> Gurkenglas: that =p
17:14:51 <quchen> Eh, scratch the "map f" part
17:14:56 <saml_> is Prism' some library?
17:15:11 <quchen> Lens
17:15:30 <saml_> ah lens is level 4 support. i'm at level 2 only. can't help you
17:16:15 <carter> level 4 support
17:16:16 <carter> hahah
17:16:24 <carter> whats level 5 support?
17:16:50 <EvanR> ordinally indexed support levels
17:16:50 <carter> saml_: quchen  trying "use traversable everywhere" as my way to learn lens
17:17:59 <DogeHayashi> I imagine I could just mapMaybe previewing the prism over the list, but I was wondering if there was a more idiomatic way
17:18:03 <glguy> > toListOf (folded . _Left) [Left 1, Right 2, Left 3, Right 4]
17:18:05 <lambdabot>  [1,3]
17:18:05 <carter> :t reversed
17:18:06 <lambdabot> (Reversing a, Profunctor p, Functor f) => p a (f a) -> p a (f a)
17:18:15 <carter> oh thats a thing
17:18:17 <DogeHayashi> woo
17:18:24 <carter> :info Profunctor
17:18:34 <carter> @src Profunctor
17:18:34 <lambdabot> Source not found.
17:18:40 <quchen> Lambdabot @src database: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
17:18:41 <glguy> DogeHayashi: Is that what you wanted?
17:19:01 <identity> I'm not sure why, it must be some freudian slip, but Profunctor always, *always* makes me think of 'sphincter'.
17:19:08 <DogeHayashi> glguy: indeed it is, thanks!  =P
17:19:35 <DogeHayashi> I have a feeling lens is going to be a pleasantly challenging thing to get to grips with =p
17:19:55 <DogeHayashi> I've already ended up simultaneously enthralled and completely puzzled by it
17:19:59 <glguy> > mapMaybe (preview _Left) [Left 1, Right 2, Left 3, Right 4]
17:20:01 <lambdabot>  [1,3]
17:20:10 <glguy> If you were wanting to use mapMaybe (as you'd mentioned)
17:21:05 <glguy> (Oh, you seem to have even suggested that one yourself)
17:21:23 <identity> DogeHayashi: there's a really good joke in what you just said in relation to my previous comment but I'm not sure this is the crowd for it.
17:21:42 <carter> :t backwards
17:21:43 <lambdabot> (Profunctor q, Profunctor p) => Optical p q (Control.Applicative.Backwards.Backwards f) s t a b -> Optical p q f s t a b
17:21:58 <carter> @src backwards
17:21:58 <lambdabot> Source not found. Abort, Retry, Panic?
17:22:05 <quchen> It should be a Lens law not to use :t on its values.
17:22:57 <glguy> Once you know what you're looking for in the types they are quite instructive
17:22:59 <carter> quchen: i'm discovering i have uses for lense
17:23:18 <glguy> but if you're just watching them fly by in #haskell and not learning anything about them they'll look opaque
17:23:23 <carter> glguy: quchen  i actually have cases where lens being super INLININGY
17:23:24 <carter> is a good thing
17:23:43 <glguy> carter: That's supposed to be most of the cases :-p
17:23:56 <carter> glguy: inner loops for matrix mult are .... kinda key
17:23:57 * hackagebot msu 0.0.2 - Monitor Setup Utility  http://hackage.haskell.org/package/msu-0.0.2 (PatrickBrisbin)
17:24:54 <carter> :t backwards l f = forwards (flip $) l (Backwards (flp $) f)
17:24:55 <lambdabot> parse error on input ‘=’
17:25:08 <carter> :t \l f -> forwards (flip $) l (Backwards (flp $) f)
17:25:09 <lambdabot> Not in scope: ‘forwards’
17:25:09 <lambdabot>     Not in scope: data constructor ‘Backwards’
17:25:09 <lambdabot>     Perhaps you meant ‘BackwardIso’ (imported from Control.Lens)
17:26:05 <quchen> glguy: I tried to learn looking for the right parts of the types. It made the more instructive, but nowhere near "quite".
17:26:24 <quchen> Repeating this every one or two months since half a year ago.
17:28:57 * hackagebot stripe 0.8.1 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.8.1 (LukeHoersten)
17:29:15 <carter> Luke: hows that webapp?
17:29:31 <Luke> going great. became profitable a few days ago
17:30:30 <Luke> i need to port all my JS to fay or something. its so hard to keep it bugless
17:30:45 <quchen> Which webapp?
17:30:50 <carter> Luke: ghcjs or purescript
17:30:58 <Luke> yeah or those
17:31:03 <Luke> quchen: http://racemetric.com
17:31:04 <carter> ghcjs if you want shared code base and dont have crazy js perf needed
17:31:18 <Luke> i want to share data types etc
17:31:21 <carter> ok
17:31:25 <carter> ghcjs is probably the best choice
17:31:56 <carter> if you wanna shared
17:32:03 <carter> and have seemless iterop
17:36:32 <carter> :t backwards traverse
17:36:33 <lambdabot> (Traversable t, Applicative f) => Optical (->) (->) f (t a) (t b) a b
17:36:40 <carter> :t backwards
17:36:41 <lambdabot> (Profunctor q, Profunctor p) => Optical p q (Control.Applicative.Backwards.Backwards f) s t a b -> Optical p q f s t a b
17:36:44 <carter> :t traverse
17:36:45 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:37:00 <carter> :k Optical
17:37:02 <lambdabot> (* -> * -> *) -> (* -> * -> *) -> (* -> *) -> * -> * -> * -> * -> *
17:38:09 <quchen> Optical p q f s t a b = p a (f b) -> q s (f t), if that helps. Modulo some classes.
17:38:19 <quchen> Functor f, Profunctor {p,q} I believe.
17:38:28 <carter> quchen: yay
17:39:22 <quchen> type Optical p q f s t a b = p a (f b) -> q s (f t)
17:39:28 <carter>  Optical (->) (->) f (t a) (t b) a b
17:39:29 <carter> hrmmm
17:39:30 <quchen> (Copied from the lib)
17:39:32 <carter> yeah
17:39:33 <lispy> carter: that looks like miranda code
17:39:37 <carter> i've been al tabing
17:39:37 <lispy> carter: well, a miranda type
17:39:57 <carter> lispy: well, this actually comes up as a patern in my not yet using lenses code
17:39:57 <quchen> For most purposes, you can probably read p and q as (->). At least it helps my intuition to do so.
17:40:04 <carter> quchen: in myc ase its  Optical (->) (->) f (t a) (t b) a b
17:40:27 <quchen> Well that's just traverse isn't it
17:40:35 <carter> :t traverse
17:40:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:40:37 * hae just learned about profuncors
17:40:45 <hae> *profunctors
17:40:45 <carter> quchen: i guess, but with reverse order
17:40:55 <lispy> carter: in miranda they used stars as type variables. map :: (* -> **) -> [*] -> [**]
17:41:02 <carter> ewww
17:41:08 <carter> but nice bit of history
17:41:14 <quchen> :t backwards (backwards traverse)
17:41:15 <lambdabot> (Traversable t, Applicative f) => Optical (->) (->) f (t a) (t b) a b
17:41:29 <quchen> The backwardness doesn't appear in the type, does it?
17:41:45 <quchen> Well, how should it
17:41:49 <carter> yup
17:41:52 <carter> good point
17:42:28 <quchen> Neat, so backwards is an involution. Involutions are good.
17:42:46 <carter> quchen: it comes up in my address translation codes
17:43:40 <quchen> Oh, backwards is easy, even!
17:43:45 <flebron> Probably pushing it but, is there a typesafe way to say "I have a Vector a n, n :: Nat, a :: *, Ord a, and I have an x :: a. I want to partition the vector into those elements less than x, and those greater." I'd like to return something like (Vector a l, Vector a r) such that l + r = n, or to return some pointer to where I've split the Vector... anything reasonable?
17:43:50 <lispy> johnw: have you had any trouble with the new shelly?
17:44:25 <lispy> johnw: I just heard that it may not be compatible with ghc 7.6
17:44:59 <jmcarthur> flebron: you could return one of these, maybe:    data Result a n where Result :: Vector a l -> Vector a r -> Result a (l + r)
17:45:26 <jmcarthur> flebron: but i'm not immediately sure how to go about writing the function
17:46:09 <carter> lispy: btw, i'm allegedly going to the PPAML summer thingy
17:46:13 <carter> in portland
17:46:23 <carter> need to start figuring out housing and stuff
17:46:25 <carter> for that week
17:46:44 <carter> i imainged you and ReinH  will be around?
17:46:50 <lispy> carter: cool
17:47:03 <carter> lispy: i'll have a secret agenda there!
17:47:05 <carter> mwahahah
17:47:14 <jmcarthur> some secret
17:47:23 <jmcarthur> no almost 1300 people know that you have a secret
17:47:25 <jmcarthur> *now
17:47:33 <carter> jmcarthur: you know my agendas
17:48:09 * jmcarthur steals carter's agendas and then realizes probably most people don't get netrunner references
17:48:15 <carter> nope
17:48:17 <carter> dont get it
17:48:42 * jmcarthur shrugs because it's too off topic to continue with
17:49:08 <lispy> I don't think I know ReinH outside of #haskell
17:49:25 * hae goes off to implement monads in BASIC
17:49:57 <lispy> hae: hopefully you've seen this: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
17:50:38 <jmcarthur> my favorite thing about the augustss basic dsl is that it actually compiles down to really fast code
17:50:52 <lispy> johnw: looks like shelly requires exceptions-0.6 now
17:51:04 <hae> Wat.
17:51:15 <meloveulongtime|> glad to see there are friendlies in the Basic camp.
17:51:21 <hae> Somebody has _way_ too much time on their hands.
17:51:21 <hpc> ahaha
17:51:35 <ozgura> why does ffi need to be so ugly :(
17:51:43 <ozgura> I feel a few years older trying to return a list of strings from C
17:51:48 <jmcarthur> hae: speed! http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html
17:51:59 <carter> ok
17:52:02 <carter> why does \ traver f container ->     forwards $ traver  (\x -> Backwards $ f x) container
17:52:05 <carter> not have the same type as
17:52:13 <carter> :t reversed traverse
17:52:14 <lambdabot> (Reversing (a -> a -> b), Traversable ((->) a)) => (a -> a -> b) -> (a -> a) -> a -> a -> b
17:52:17 <carter> ohhh
17:52:25 <carter> i'm dumb
17:52:26 <carter> kk
17:53:48 <carter> :t backwards traverse
17:53:49 <lambdabot> (Traversable t, Applicative f) => Optical (->) (->) f (t a) (t b) a b
18:03:45 <oio`> can i use guards inside wheres?
18:03:54 <hae> Yes.
18:04:32 <hae> Have you guys heard the lightbulb/monad joke?
18:05:09 <oio`> mm indeed
18:08:20 <orion> HectorAE: no, tell me
18:09:29 <HectorAE> How many monads does it take to screw in a lightbulb>
18:09:32 <HectorAE> ?
18:11:29 <Gurkenglas> (/)
18:11:39 <Gurkenglas> Wait wrong tab soz
18:12:56 <Gurkenglas> Given a type and a typeclass, how do I find the least general type that is in the typeclass and contains the given type?
18:13:20 <HectorAE> No number of monads is enough. You need a functor to lift the lightbulb.
18:14:30 <monochrom> wait, liftM should be enough
18:15:02 <HectorAE> Stahp you're spoiling my well-cured sense of functional humor.
18:15:54 <monochrom> it does up to liftM5 for good measure
18:17:28 <lispy> johnw: nevermind, it's actually not shelly. It's the exceptions-0.6 release
18:18:32 <HectorAE> GHC 7.10 will finally kill that joke anyway.
18:19:38 <monochrom> create new jokes for ghc 7.10 then
18:19:56 <carter> monochrom: that game for Left field
18:19:58 <carter> Right?
18:20:03 <HectorAE> :|
18:20:04 <carter> Or Maybe Just Nothing
18:20:13 <monochrom> "how many ghc versions does it take to get closed type families right?"
18:20:17 <HectorAE> >|
18:20:19 <Gurkenglas> "1"++"2"++"3"++"4"++..++"n-1"++"n" runs in O(n^2) rite?
18:20:27 <carter> monochrom: i'm pretty happy with 7.8 closed type families
18:20:41 <Gurkenglas> (*log(n) or something cause the strings get longer)
18:20:54 <carter> Gurkenglas:   n (n+1)/2 is faster
18:20:55 <monochrom> "on average 7.8 versions"
18:21:04 <Gurkenglas> carter, not in O notation
18:21:18 <carter> Gurkenglas: use  the closed form!
18:21:19 <carter> :)
18:21:36 <carter> sum 1... n === n * n +1 / 2
18:21:41 <carter> i think
18:21:43 <carter> tied
18:21:45 <carter> *tired
18:21:56 <monochrom> you missed a few parentheses but it's right
18:22:06 <Gurkenglas> Yes but I meant how long it takes to concatenate n strings together.
18:22:17 <monochrom> linear time
18:23:00 <Gurkenglas> Oh, I'm stupid, ++ binds to the right huh
18:23:35 <monochrom> yes. s1 ++ (s2 ++ (s3 ++ (...  is linear time
18:23:49 <Gurkenglas> (..("1"++"2")++"3")++..+"n") would be quadratic?
18:23:53 <monochrom> yes
18:25:07 <HectorAE> > foldr1 (++) (map show [1..])
18:25:08 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
18:26:47 <monochrom> did you know that ("0." ++ foldr1 (++) (map show [1..])) gives you a transendental number
18:26:50 <Gurkenglas> How can it do that, when it tries to finish the right side first?
18:27:05 <HectorAE> No, no, no...
18:27:21 <monochrom> err, actually I don't know that it is a transcendental number. I just know that it is irrational.
18:27:34 <hiptobecubic> Gurkenglas, it's counter intuitive, yeah...
18:27:40 <Gurkenglas> I'd be surprised if it was algebraic
18:27:52 <monochrom> it does not finish the right side first
18:27:57 <hiptobecubic> > foldr f z [w, x, y]
18:27:58 <lambdabot>  f w (f x (f y z))
18:28:04 <monochrom> nothing says it finishes the right side first
18:28:23 <Gurkenglas> Right, I said that wrong
18:28:37 <monochrom> I said it right
18:28:40 <monochrom> err
18:28:43 <monochrom> you said it right
18:28:46 <hiptobecubic> Gurkenglas, so if f w (...) can produce something lazily, it will work
18:29:00 <HectorAE> No, it folds _toward_ the right.
18:29:06 <hiptobecubic> Gurkenglas, in this case it's (:)
18:29:30 <hiptobecubic> Gurkenglas, and we know that x : ....  is perfectly fine and doesn't need to be evaluated any further to show x
18:29:51 <Gurkenglas> Let's assume lambdabot only showed 2 digits before the "..."
18:30:32 <Gurkenglas> How does it turn "1"++("2"++map show [3..])) into "12.."?
18:30:54 <Gurkenglas> *"12...
18:31:02 <HectorAE> Simple. "1" ++ "2"
18:31:16 <Gurkenglas> It knows that ++ is associative?
18:31:34 <HectorAE> No, but it doesn't need to.
18:31:48 <Gurkenglas> You'll have to explain that
18:31:53 <monochrom> ('1':[]) ++ xxx becomes '1':([] +++ xxx) first
18:32:28 <monochrom> whenever the printer sees "c:ddd", it prints out the c before it even cares about ddd
18:32:44 <hiptobecubic> aka, ':' is lazy in second arg
18:32:45 <hiptobecubic> right?
18:32:54 <monochrom> then []++xxx becomes xxx
18:32:56 <HectorAE> It's not about associativity, it's about strictness.
18:33:15 <Gurkenglas> If it wasn't associative it couldn't be nonstrict about this
18:33:25 <monochrom> xxx becomes, after a few steps, '2':yyy. and once again, the printer prints out that 2 before even caring about yyy
18:34:14 <monochrom> anyway, parentheses are for parsing, not for computation order. you were taught a lie.
18:35:02 <monochrom> ':' is, in fact, lazy in all arguments. only the printer is forcing anything at all.
18:35:29 <Gurkenglas> I didn't think it was computation order, I just didn't see how it could convert (1+(2+(3+... to anything without mucking with the properties of +. Turns out it doesnt ^^
18:35:51 <monochrom> ++ is quite different from +
18:36:11 <Gurkenglas> Yea wtf brain
18:36:15 <Gurkenglas> I dont even know where that came from
18:36:49 <HectorAE> :t foldr1 (+) [1..]
18:36:50 <lambdabot> (Num a, Enum a) => a
18:37:32 <HectorAE> See in that case we're building a single value from a list instead of a list from a list of lists.
18:38:07 <HectorAE> We can do the expression I did before because it's productive.
18:38:10 <monochrom> number operations like + are eager, understandably
18:38:51 <Gurkenglas> That doesn't sound like a fact about +
18:39:06 <monochrom> assume Int, OK? then it's true.
18:39:16 <Gurkenglas> Yea more a fact about Int :D
18:40:10 <flebron> Can I have a typeclass whose elements aren't in *, but in some k I define?
18:41:04 <Iceland_jack> flebron: Typeable has that
18:41:07 <Martty> what would be a good channel about concurrent programming techniques and stuf?
18:41:11 <Iceland_jack> d
18:41:11 <Iceland_jack>     class Typeable (a :: k) where ...
18:41:25 <monochrom> this is a good channel about concurrent programming techniques
18:41:34 <Gurkenglas> Hmm is there a type of natural numbers on which all the provided operations only give back a larger number?
18:41:47 <Gurkenglas> *than the argument
18:42:02 <Iceland_jack> Gurkenglas: You can easily define a newtype for that
18:42:15 <monochrom> but is that natural number anymore?
18:42:16 <Iceland_jack> you basically want to restrict the functions to being monotonic
18:42:18 <Gurkenglas> Then you could lazily provide lower bounds on any number you're calculating before you are done
18:42:38 <flebron> Ah, that's the syntax I didn't know Iceland_jack, (a :: k). Thanks :)
18:42:41 <HectorAE> That doesn't sound very useful though.
18:42:56 <HectorAE> And why limit it to natural numbers?
18:43:04 <Iceland_jack> flebron: You're welcome, check out Data.Typeable for how they use it :)
18:43:11 <Gurkenglas> Not monotonic, the graphs have to lie above the quadrant bisector
18:43:35 <Iceland_jack> Before we had
18:43:35 <Iceland_jack>     Typeable1 (a :: * -> *)
18:43:35 <Iceland_jack>     Typeable2 (a :: * -> * -> *)
18:43:35 <Iceland_jack>     ...
18:43:43 <flebron> :s!
18:43:53 <Iceland_jack> (well we still do as type synonyms)
18:44:17 <Gurkenglas> Hector, in that type, 7<(sum [1..]) would halt and return true
18:44:45 <jmcarthur> Gurkenglas: http://conal.net/papers/warren-burton/Indeterminate%20behavior%20with%20determinate%20semantics%20in%20parallel%20programs.pdf
18:44:57 <Iceland_jack> Gurkenglas: That wouldn't work
18:45:06 <HectorAE> Umm...
18:45:14 <jmcarthur> Gurkenglas: also, lazy naturals are a thing:   data Nat = Zero | Succ Nat
18:45:25 <Iceland_jack> Yes you can do this using lazy naturals
18:45:29 <Gurkenglas> Ahh, awesome. Exactly what I wanted jmcarthur
18:45:38 <Iceland_jack> Are you sure you really do want lazy naturals?
18:45:54 <Iceland_jack> It may be better to provide a special function like Data.Text does for length
18:46:04 <Gurkenglas> If what I said before wasn't lazy naturals, what I said before was wrong
18:46:10 <Polarina> Are there any significant differences between the binary and cereal packages?
18:46:27 <Gurkenglas> Iceland_jack, special function?
18:46:32 <Iceland_jack> ghci> :t Data.Text.compareLength
18:46:32 <Iceland_jack> Data.Text.compareLength :: Text -> Int -> Ordering
18:47:20 <jmcarthur> > (7 :: Natural) < foldr (+) 0 [1..]
18:47:22 <lambdabot>  True
18:47:28 <jmcarthur> (sum doesn't work here because it uses foldl'
18:47:31 <jmcarthur> *foldl)
18:47:52 <Iceland_jack> Gurkenglas: “This function gives the same answer as comparing against the result of length, but can short circuit if the count of characters is greater than the number, and hence be more efficient.”
18:48:18 <HectorAE> Interesting.
18:48:24 <jmcarthur> > (7 :: Natural) < genericLength [1..]
18:48:25 <lambdabot>  True
18:48:40 <Martty> ok my quesiton is, is it good practice to create a critical section (via a mutex, implemented using a binary semaphore. init on 1, wait as preprotocol and signal as postprotocol) inside a class method to guarantee it's only accessed by one process at a time?
18:49:00 <carter> Martty: ..... why not use mvar/ stm?
18:49:02 <carter> whats your use case?
18:49:20 <jmcarthur> Martty: semaphores are not very common in haskell
18:49:29 <carter> (though base does have them)
18:49:30 <Martty> sorry, this isn't strictly haskell related
18:49:35 <carter> true
18:49:42 <Martty> more abstractly
18:49:46 <carter> we're saying "have you considered designing the code that needs this difference"
18:49:55 <HectorAE> "Class method"?
18:49:56 <Total_1mmersion> Is there a way to step N times in the ghci debugger? I have infinite recursion somewhere and it would be nice to :step 1000 and see where it lands.
18:50:21 <hiptobecubic_> Total_1mmersion, probably back where you started, assuming it's recursion
18:50:56 <Platz> critical secions and semaphores are the kind of low-level concurrency primitives that I've heard are best avoided if possible, because it's hard to use them correctly
18:51:15 <jmcarthur> they are indeed really tricky, from my experiences
18:51:19 <Martty> well, its kind of the building blocks of concurrency that's why im learning how to use them first (part of a course too)
18:51:22 <Platz> I didn't even know haskell had them
18:51:28 <carter> Martty: nahhh
18:51:33 <carter> CAS is the building block
18:51:33 <carter> :)
18:51:48 <jmcarthur> i daresay there are no actually "building blocks" of concurrency
18:51:49 <carter> or at lesat one of the nicer buildinb blocks
18:51:52 <jmcarthur> *actual
18:51:59 <carter> jmcarthur: depends on the CPU :)
18:52:07 <jmcarthur> the CPU doesn't define what concurrency is
18:52:18 <jmcarthur> it's just a low level detail
18:52:48 <HectorAE> Also we don't call them methods.
18:53:03 <Iceland_jack> jmcarthur: A building block doesn't have to be architectural
18:53:12 <[swift]> some knuckleheads do call them methods, which should be avoided =)
18:53:19 <jmcarthur> Iceland_jack: that was kind of my point, i think
18:53:21 <[swift]> i see it in blog posts sometimes, though
18:53:36 <Martty> something like this
18:53:41 <Martty> http://codepad.org/oZcfRSrn warning: c++
18:53:44 <HectorAE> "Method" is just the Java term for "function".
18:53:45 <sjy> the 0mq guide is a really interesting read that has some implications about what the "building blocks" of concurrency really are, if they exist
18:53:46 <Iceland_jack> jmcarthur: Well I'd argue that there /are/ building blocks of concurrency, many different ones
18:54:04 <carter> yeah
18:54:05 <Cale> There is something in particular that the Haskell spec calls a method
18:54:10 <carter> some are inter expressible
18:54:16 <jmcarthur> Iceland_jack: i was really objecting to "the" building blocks
18:54:16 <carter> and theres a deep theory of how powerful they are
18:54:16 <[swift]> Martty: it's fine to use semaphores if your goal is to learn to use semaphores
18:54:26 <Iceland_jack> jmcarthur: No disagreements there :)
18:54:26 <carter> agree iwith [swift]
18:54:26 <[swift]> Martty: in my experience they are rarely used, in Haskell or in C++
18:54:29 <Cale> The values defined by a type class are called its methods.
18:54:30 <Martty> [swift]: that it is indeed
18:54:52 <sjy> i'm not sure if you can state them any more precisely than "multiple concurrent workers, and a method of communication between workers"
18:56:09 <HectorAE> Cale, so in other words, its type constructors?
18:56:33 <jmcarthur> sjy: i disagree even with the words "workers" and "communication"
18:57:04 <jmcarthur> sjy: they fit into some models of concurrency, but not all
18:57:39 <carter> yeah
18:57:44 <sjy> can you give an example of where they don't fit? maybe you read the terms more narrowly than me (imo threads can be workers, and shared mutable state can be communication...)
18:57:50 <carter> its... more complex and rich than any single  methodology
18:58:00 <HectorAE> What even is concurrency?
18:58:02 <sjy> maybe that doesn't really capture the concurrency that happens inside a brain though :)
18:58:02 <jmcarthur> sjy: for example, i think it's not even crazy to say that if i have two functions  A -> B  and  A -> C,  B and C are "concurrent" with each other (imagine A is "time" or something)
18:58:32 <jmcarthur> sjy: that is, B and C vary concurrently to each other, as A changes
18:58:39 <HectorAE> It's a whole lot more difficult than parallelism, I'll tell you that.
18:59:07 * hackagebot samtools 0.2.2 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.2 (NicholasIngolia)
19:00:09 <jmcarthur> sjy: they can even influence each other, or at least be related to each other. easy to see by merging the two functions:   A -> (B, C)
19:00:15 <l0cust> how y'all goind
19:00:18 <l0cust> *doing
19:00:24 <carter> codin
19:00:26 <carter> patchin
19:00:31 <carter> overworked
19:00:33 <carter> etc etc
19:00:53 <sjy> jmcarthur: interesting point (esp where A is not necessarily time). i'd probably maintain that you can still massage those concepts into my loose definitions of worker and communication though :P
19:01:03 <sjy> ofc my definition was general enough to be completely useless already
19:01:12 <carter> sjy: loose definitions are not definitions
19:01:15 <carter> :)
19:01:20 <jmcarthur> sjy: perhaps, but i think it's clear that it's unclear which is more foundational
19:01:49 <jmcarthur> sjy: it's like arguing whether turing machines or the lambda calculus or any of the various other turing complete systems are actually more foundational
19:04:08 * hackagebot semiring-simple 0.2.0.0 - A module for dealing with semirings.  http://hackage.haskell.org/package/semiring-simple-0.2.0.0 (pharpend)
19:04:29 <sjy> jmcarthur: yeah. it's quite interesting that the foundations of mathematics (well, number theory) don't really seem to have the same "problem" - it seems to me that ZF set theory is the only serious axiomatisation, but also nobody thinks for that reason that it's the One True axiomatisation
19:05:07 <sjy> maybe i haven't read enough esoteric maths though. :)
19:08:06 <sjy> huh, what i just said seems to be contradicted in the first paragraph of the wikipedia article on ZFC, so nevermind!
19:09:32 <HectorAE> Category theory is the OTA.
19:13:55 <spott> hey, how do I pattern match a list of one element?  for example:  flatten [a] = a
19:13:58 <Platz> Aren't there still math folks who haven't bought in on "new-schoo" math, i.e. that math is just a choice of arbitrary initial axioms
19:14:26 <Platz> perhaps everyone is new-school now
19:14:27 <jmcarthur> spott: you just did it
19:14:46 <Platz> i think that was in the 30's or something
19:15:52 <spott> argh... maybe more is needed: I want to create a function that takes a list of lists, and turns it into a list:  flatten :: [a] -> a; flatten [a] = a; flatten a = (head a) ++ (flatten $ tail a); is my initial guess
19:16:07 <HectorAE> Relevant. https://en.wikipedia.org/wiki/Philosophy_of_mathematics
19:16:09 <spott> is there something wrong with that?  or is that not the problem
19:16:22 <HectorAE> spott, that's called concat.
19:16:22 <dmj`> if I have a cabal executable and a library, each w/ different deps specified and I call cabal install --dependecies-only do executables from both get installed?
19:16:35 <dmj`> cabal file with an executable and library specified
19:17:08 <carter> neither get install
19:17:10 <RchrdB> spott, it sounds like the *type* that you want is actually flatten :: [[a]] -> [a] -- turning a list of lists into a list.
19:17:11 <carter> only the deps
19:17:17 <carter> not the artifacts themselves
19:17:21 <spott> RchrdB: yup
19:17:22 <spott> exactly
19:17:31 <dmj`> carter: deps thanks, that's what I meant
19:17:36 <RchrdB> Platz, quite a lot of people, I think. Pretty much everyone who has learned up to single-variable calculus on the reals but never touched anything outside that track.
19:17:49 <spott> but why doesn't my code work?  if a is a list, it should do the same
19:17:55 <dmj`> carter: the deps from both tho? Not just the library
19:18:00 <HectorAE> spott, I meant you're just re-implementing concat.
19:18:00 <carter> both
19:18:03 <carter> the app and the lib
19:18:16 <carter> i assume the app has the lib as a dep...?
19:18:24 <spott> HectorAE: I am?  I thought concat was a -> a -> [a]
19:18:26 <carter> (it'll link to the intree lib build)
19:18:34 <HectorAE> :t concat
19:18:35 <lambdabot> [[a]] -> [a]
19:18:43 <spott> nevermind
19:18:55 <spott> sorry, I'm still learning haskell
19:19:07 <RchrdB> No problem! That's mostly what #haskell is here for. :)
19:19:13 <dmj`> carter: is there a way to only install the deps from the library?
19:19:19 <HectorAE> It's alright, you should have seen me before I discovered Data.List.Split lol.
19:19:20 <dmj`> when an executable is specified along side it
19:19:22 <carter> dmj`: dont' build the app
19:19:28 <carter> in the same cabal file
19:19:29 <RchrdB> spott, when you write a function like concat that operates on a list, you want to think about two cases: the empty list, and a (:) cell.
19:19:32 <carter> dmj`: whats the GOAL
19:20:29 <RchrdB> spott, so, fill out: flatten [] = ?; flatten (a:as) = ?
19:20:59 <spott> flatten [] = [] was my guess... but that doesn't work for the types
19:21:04 <RchrdB> Sure it does.
19:21:12 <spott> flatten (a:as) = a ++ flatten as
19:21:24 <spott> RchrdB: but the types are list to list then...
19:21:27 <RchrdB> flatten ([] :: [[a]]) = ([] :: [a])
19:21:39 <dmj`> carter: have 1 cabal file with an executable and a library specified and only install the library dependencies when needed
19:21:42 <HectorAE> flatten = concat -- There you go.
19:21:49 <carter> when are they not neede
19:21:50 <carter> d
19:22:16 <carter> is the APP a test suite?
19:22:38 <drostie> spott: in other words, [] has type [x] for any x, even if x is [a].
19:22:45 <spott> HectorAE: that is what I'm doing.
19:22:52 <dmj`> no, plain library
19:22:55 <spott> drostie: ok
19:23:00 <spott> drostie: awesome
19:23:00 <carter> sooo, make them seperate packages
19:23:01 <RchrdB> spott, if you ask GHCi what the type of [] is, by typing ":t []" at the prompt, it will tell you that the type of [] is [a], which means that an empty list may contain any kind of element.
19:23:28 <spott> RchrdB: thanks... I'm still learning ghci
19:25:24 <dmj`> carter: yea that would work, went from 1 pkg to 5 pkgs :/
19:25:36 <carter> dmj`: ... do they alll need to be different packageS?
19:26:42 <dmj`> yea pretty much
19:28:23 <Cale> HectorAE: no, the functions and value-level things
19:28:38 <Cale> e.g. fmap is a method of the Functor type class
19:29:32 <Cale> and minBound is a method of the Bounded type class
19:30:12 <HectorAE> Oh I get it now Cale. I wasn't really aware of the technical term.
19:30:29 <ReinH> lispy: you're in Portland?
19:30:58 <dmj`> I don't want to build snap on my windows server. I'm profiling acid-state w/ ekg and it deps on snap. The acid-state operations are in the library and the server in the executable, in one cabal file. I guess I'll have to split it out
19:31:13 <dmj`> carter: ^
19:31:23 <carter> dmj`: flags!
19:31:38 <carter> have you tried use cabal files
19:31:45 <carter> adding em to your cabal file
19:31:46 <carter> or that
19:31:47 <carter> idk
19:31:59 <carter> dmj`: i'm catching up on a LOT of engineering
19:32:15 <dmj`> if (os(windows)) etc.. good call
19:32:36 <dmj`> great call
19:41:35 <athan> Hello everyone! Does anyone know of a list-like container, with traits of a set (for the uniqueness, difference, and union), but is also sorted and lazy? Or should I try my hand? :)
19:42:11 <Total_1mmersion> What's a good way to debug a nonterminating Haskell program? I don't think GHCI supports multi-stepping, and using Debug.Trace is as slow as printf debugging.
19:43:20 <dna8> does anyone know a better way to write the following: do { mapM_ f1 xs; mapM_ f2 xs; mapM_ f3 xs}
19:43:39 <dna8> (IO monad)
19:43:59 <hakujin> athan: how would you enforce uniqueness on unevaluated items?
19:44:19 <athan> dna8 I want to say sequence...
19:44:23 <athan> :t sequence
19:44:24 <lambdabot> Monad m => [m a] -> m [a]
19:44:47 <athan> hakujin: Unfortunately, not at the type level :(
19:45:11 <SrPx> How do you find the definition of a function when all you have is a huge set of input/output pairs?
19:45:45 <hakujin> well Data.Set (from containers) checks off your uniqueness, difference, and union boxes but keys are evaluated to WHNF
19:46:03 <athan> dna8 (sequence . map) ($ xs) [f1, f2, f3]
19:46:38 <athan> hakujin: I also don't need the keys, either. I
19:46:43 <athan> m wondering if idris would be better
19:46:54 <athan> thank you for your help
19:46:59 <dna8> athan: sequence . map is mapM ... so I guess I need mapM_ ($ xs) [f1, f2, f3]         works for me, thanks!
19:47:10 <athan> derp! :P Thank you haha
19:48:20 <athan> Is it possible to enforce constraints on the polymorphic arguments of data types?
19:48:35 <athan> something like data (Eq a) => Foo a = Nil | Foo a
19:48:51 <osa1> if I have record `data Rec = Rec { field1 :: Ty1, field2 :: Ty2, ... }` does `Rec` export accessors too or do I need `Rec (..)` ? or maybe `Rec, field1, field2, ...` ?
19:48:57 <athan> Or possibly on the type constructor?
19:49:23 <athan> osa1 Rec (..) should do the trick I believe
19:50:12 <athan> it may not actually... As the record syntax makes extra functions, not data constructors
19:50:44 <osa1> athan: yeah that syntax worked, simple `Rec` did not work.
19:50:49 <osa1> simply*
19:51:12 <athan> Cool beans :) you may want to check out #haskell-beginners
19:55:51 <spott_> Does anyone know a good tutorial for making your own monad?
19:55:52 <spott_> ?
19:56:22 <hakujin> spott_: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:58:37 <hakujin> add "making your own Functor" and "making your own Applicative" to your list too, if you want a proper Monad
20:04:17 * hackagebot hails 0.11.1.2 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.1.2 (DeianStefan)
20:04:45 <spott_> thanks, I will
20:05:27 <Platz> I could use "making your own profunctor"
20:06:38 <meloveulongtime|> and don't stray from being a fortoendofunctor
20:07:17 <meloveulongtime|> fortiori endofunctor?
20:08:45 <hoverbear> Cabal keeps telling me there is a new version of cabal when I run `cabal update`, so I run `cabal install cabal-install`, which results in `Installed cabal-install-1.20.0.1` as output. Then I run `cabal update` again, and I am told there is a new version of cabal, still.
20:09:14 <hakujin> hoverbear: check your path
20:09:26 <lispy> ReinH: aye, I work at galois
20:09:49 <hoverbear> hakujin: Just my standard shell $PATH yeah?
20:10:03 <hakujin> hoverbear: yep. you'll want ~/.cabal/bin at the front
20:10:09 <hoverbear> Okay.
20:10:46 <hoverbear> hakujin: Trying that.
20:10:50 <lispy> hoverbear: the old update switcheroo
20:11:30 <lispy> hoverbear: also relevant: cabal doesn't track which programs it has installed so it will reinstall cabal-install everytime you type that. Even if it's up to date!
20:12:09 <hoverbear> lispy: How silly. :)
20:14:45 <hakujin> assuming only rank 2 types is there an advantage to the Rank2Types pragma over RankNTypes?
20:15:28 <hakujin> does inference get worse for N?
20:15:30 <lispy> hakujin: Not really. It does limit the rank-n craziness. So I suppose that's nice.
20:15:39 <benzrf> i thought they were equivalent?
20:15:42 <lispy> hakujin: I don't think inference gets worse, but I could be wrong.
20:15:49 <hakujin> lispy: thanks
20:16:14 <lispy> hakujin: we should look it up
20:16:25 <hoverbear> Hm, it's still doing it. hakujin
20:16:46 <hoverbear> Oh, hey, I'm using an out of date ghc too, I'll update that.
20:17:13 <dmj`> carter: have you seen a linker error like the before on osx? http://lpaste.net/8647058533210128384
20:17:16 <dmj`> this*
20:17:24 <lispy> hakujin: http://www.haskell.org/pipermail/haskell-prime/2007-February/002081.html
20:17:33 <hakujin> hoverbear: what's the output of "cabal --version" and "which cabal"?
20:17:34 <lispy> hakujin: SPJ says that he thinks rank-n is better in all ways
20:17:49 <hakujin> lispy: great, thanks!
20:18:08 <hoverbear> hakujin: I'm pretty sure that it's due to homebrew giving me an old version with it's ghc package, will report after the (long) update.
20:18:20 <athan> lispy: I've already had tons of strive with rank-n, but could you try and explain them for me in one sentence? Please? :)
20:18:22 <carter> @hackage  ST-types
20:18:22 <lambdabot> http://hackage.haskell.org/package/ST-types
20:18:40 <dmj`> carter: its my package
20:18:43 <carter> ok
20:18:46 <carter> do you have any ffi things
20:18:51 <carter> dmj`: hmmmmmmm
20:19:08 <lispy> athan: rank-n lets you be polymorphic over polymorphic things.
20:19:16 <carter> dmj`: paste your ghc --info and cat ~/.cabal/config (redacting your password of course)
20:19:31 <athan> lispy: Holy crap... like polymorphic toward different similar kinded containers?
20:19:57 <codygman> I'm using the webdriver (selenium binding) library and was wondering if anyone knew how I could leave the browser window open. I suppose I could just use threadDelay
20:20:01 <athan> different similar... crap >< Scratch that as simiar...
20:20:04 <dmj`> carter: k, here's the cabal: http://lpaste.net/2289175027116933120
20:20:11 <lispy> athan: not sure what you mean. The "things" in my sentence refer to functions. You'd need a different extension to make lists polymorphic in the same way.
20:20:13 <carter> dmj`: no
20:20:19 <carter> "cat ~/.cabal/config"
20:20:20 <carter> :)
20:20:34 <dmj`> info: http://lpaste.net/5119163836405907456
20:20:42 <athan> lispy: I see, I'll dig. Thank you! :)
20:20:48 <lispy> athan: yw!
20:20:59 <carter> dmj`: gcc --version
20:21:34 <dmj`> cabal config http://lpaste.net/6365575028016152576
20:22:03 <carter> dmj`: cabal --version
20:22:19 <dmj`> cater: gcc - http://lpaste.net/2713631015594622976
20:22:30 <spott_> has anyone installed ihaskell recently?
20:22:30 <dmj`> 1.20.0.0
20:22:35 <carter> dmj`: ok
20:22:52 <benzrf> spott_: whats iashekll
20:22:56 <benzrf> wow i butchered that
20:23:18 <spott_> benzrf: https://github.com/gibiansky/ihaskell
20:23:27 <spott_> ipython, but for haskell!
20:23:45 <carter> dmj`: try "rm ~/.cabal/config ; rm ~/.ghc ; cabal update "
20:23:50 <carter> then reinstall youer stuff
20:23:55 <carter> in a fresh sandbox
20:24:00 <dmj`> ok
20:24:07 <carter> your config is pre 1.20
20:24:14 <carter> this should fix that
20:24:35 <carter> dmj`: are you using the standard official mac build
20:25:10 <carter> whats uname -r
20:25:29 <Platz> we should make our own ihaskell that's not dependant on python, like how the clojure guys made session https://github.com/kovasb/session
20:26:08 <dmj`> carter: I have haskell-platform installed in the brew's cellar, but use ghc in /usr/local/bin
20:26:13 <carter> dmj`: KILL BREAS
20:26:15 <carter> *BREW
20:26:18 <carter> BURN IT WITH FIRE
20:26:27 <carter> or at least
20:26:28 <spott_> carter: why?
20:26:35 <carter> spott_: they're ok for not haskell stuff
20:26:47 <carter> dmj`: dont use brew for haskell stuff
20:26:52 <carter> evrrrrr
20:27:13 <carter> they need an active baby sitter on the haskell stuff
20:27:37 <carter>  adn even then, they'll do weird stuff and it becomes "i have to organize a quorum of haskellers and find someone who can patch the brew stuff"
20:28:12 <dmj`> yea the ghc and cabal I use aren't from brew. I keep 7.6.3 unused in the cellar
20:28:16 <carter> good
20:28:17 <carter> ok
20:28:20 <carter> never use it
20:28:21 <carter> pelase
20:28:33 <dmj`> will cabal update regen ~/.cabal/config
20:28:39 <dmj`> I won't
20:28:44 <carter> yup
20:28:48 <carter> cabal update will regen it
20:29:06 <dmj`> same with ~/.ghc?
20:29:09 <carter> oh yeah
20:29:10 <carter> kill it
20:29:13 <dmj`> hmmm
20:29:15 <carter> ghc will reinit
20:29:19 <carter> when it reinstalls deps
20:29:29 <carter> dmj`: just add -j to you build
20:29:34 <carter> and you'll have N cores of package buildings
20:29:39 <carter> with your fresh config
20:30:39 <dmj`> I use -j on installs which makes a significant difference, I haven't found parallel builds to give that big of a perf. boost.
20:30:44 <carter> oh
20:30:46 <carter> well
20:30:47 <hoverbear> hakujin: It looks like my path was being unfriendly.
20:30:52 <carter> cause you config didn't have ncpus before
20:30:52 <carter> look
20:30:56 <carter> cat ~/.cabal/config
20:31:00 <carter> you'll see MANY new things
20:32:00 <hoverbear> dmj`: How should I install haskell, then?
20:32:03 <dmwit> Wait, what?
20:32:16 <dmwit> cabal update... changes ~/.cabal/config?
20:32:19 <dmwit> That can't be right.
20:32:49 <dmj`> carter: I see the $ncpus, very cool
20:33:03 <carter> dmwit: it does if you delete ti first :)
20:33:10 <dmwit> oh, well
20:33:24 <carter> every new cabal-install major version has new fields
20:33:31 <carter> so i always move my custom config file
20:33:33 <carter> see the new one
20:33:34 <carter> merge em
20:33:39 <hoverbear> carter: How should you install haskell on mac, then?
20:33:40 <jxv> is there a bytestring func that drops the garbage after the null terminator?
20:34:06 <carter> hoverbear: dl the 7.8 bin dist , open it, configure ; make install
20:34:18 <dmj`> ^
20:34:20 * hackagebot BoundedChan 1.0.2.0 - Implementation of bounded channels.  http://hackage.haskell.org/package/BoundedChan-1.0.2.0 (AdamWick)
20:34:22 <carter> then DL a binary from http://www.haskell.org/cabal/download.html
20:34:24 <hoverbear> carter: How do you update it?
20:34:25 <carter> and put it in your path
20:34:28 <carter> hoverbear: you install a new one
20:34:50 <carter> each ghc version is installed in a distinct sub folder
20:35:06 <carter> and then the installer symlinks bin into your configured installers indicated bin
20:35:12 <hoverbear> Hm, okay.
20:35:37 <carter> just like linux but no packagemanger you can mostly trust
20:36:01 <lispy> carter: I use brew on my mac for haskell stuff and I haven't had an issue yet.
20:36:12 <carter> lispy: well, :P
20:36:18 <carter> they also build 7.8 with 7.4
20:36:19 <lispy> carter: that's something I can't say for macports...
20:36:24 <hakujin> carter: nix is on my to-do list for exactly that reason
20:36:34 <carter> hakujin: well, make it work on macs then i'll care :)
20:36:34 <lispy> carter: oh well, I haven't upgraded to 7.8 yet
20:36:39 <carter> lispy: don't use brew for that
20:36:41 <carter> pleaseeee
20:36:56 <carter> lispy: ask me for my special 7.8.2 build if 7.8.3 isn't out by then
20:37:12 <lispy> carter: detailed explanation, please
20:37:21 <dmj`> carter: is keeping cabal in ~/.cabal/bin/cabal and ghc in /usr/local/bin on osx kosher?
20:37:27 <carter> dmj`: i do it
20:37:38 <dmj`> k cool
20:37:45 <hakujin> carter: doesn't work on OSX? I haven't tried it but nixos.org/nix lists OSX compatibility
20:37:57 <carter> ls /usr/local/lib/ghc-7.8.2/  dmj` :)
20:38:09 <carter> hakujin: core community isn't on mac
20:38:11 <dmj`> nice
20:38:21 <carter> build env isnt the same
20:38:31 <carter> lispy: official mac ghc builds now use clang
20:38:44 <carter> but the clang RTS build for mac has the slow OSX thread local storage
20:38:48 <carter> the gcc built one doesnt
20:39:10 <carter> i've a 7.8.2+ my cpp patch so i can build it with gcc, and configure it to use clang or gcc for haskell CPP / C
20:39:32 <codygman> I don't get what an existential wrapper is. I came across one trying to use "executeJS" in the webdriver library: http://hackage.haskell.org/package/webdriver-0.5.3.2/docs/src/Test-WebDriver-Commands.html#JSArg
20:40:26 <lispy> codygman: I haven't looked at that library before, but an existential wrapper is a datatype you make to bundle things up polymorphically
20:42:14 <lispy> carter: so, TLS is slow with clang?
20:42:14 <lispy> carter: is that the worst of it?
20:42:14 <carter> lispy: TLS is slow on OS X
20:42:14 <carter> and clang doesn't have global register variables
20:42:14 <carter> this is for the ghc RTS
20:42:14 <carter> gcc uses global register variables
20:42:14 <lispy> carter: what about correctness issues?
20:42:14 <carter> thers no perf gap on linux clang builds of RTS
20:42:14 <carter> lispy: ....?
20:42:20 <carter> we've historically used GCC
20:42:23 <lispy> carter: will I run into correctness issues (or crashes, or build failures, etc) if I use 7.8 from brew?
20:42:39 <carter> they have spurious out of data patches they apply
20:42:49 <carter> and have a complicated bootstrap process that is pointless
20:42:50 <hakujin> they're still on 7.6.3 iirc
20:42:54 <carter> orh that
20:44:17 <carter> point being, no one who cares maintains it, and they insist on a really weird build process
20:44:17 <carter> and the build is -j1
20:44:17 <carter> and things
20:44:21 * hackagebot LDAP 0.6.10 - Haskell binding for C LDAP API  http://hackage.haskell.org/package/LDAP-0.6.10 (EdwardYang)
20:44:26 <carter> and i won't provide help fi someone has weird bugs and they're using brew built ghc
20:44:57 <carter> thats what it comes down to
20:45:26 <dmj`> carter: still same. http://lpaste.net/7517440490359226368
20:45:53 <carter> dmj`: is this code online
20:46:41 <carter> dmj`: crazy theory: build with --ghc-options="-j1"
20:46:45 <jxv> is there a bytestring func that drops the garbage after the null terminator?
20:46:58 <carter> slice?
20:47:17 <dmj`> not online no, it's strange because I have the main project that gens 3 executables, contains all this code, builds fine. Once I began splititng it up into seperate pkgs this happened
20:47:28 <dmj`> new branch
20:47:33 <dmj`> I'll try that
20:47:35 <carter> dmj`: do you have internal/notpublic modules?
20:47:46 <carter> maybe you forgot to export a module
20:47:47 <carter> :)
20:47:51 <dmj`> hmmmmmmmmmmmmmmmmmmmmmmmmmmm
20:48:16 <dmj`> that's totally it I bet
20:48:19 <carter> yup
20:48:32 <carter> on the bright side, you've a cleaner setup of cabal now :)
20:48:41 <dmj`> haha yea big thanks for that
20:48:51 <carter> set   hyperlink-source: True
20:48:55 <carter>   internal: True
20:48:59 <carter> in your haddock stanza
20:49:02 <lispy> dmj`: do you have an executable and library in the same .cabal file and is the source between them in the same directory?
20:49:03 <carter> for extra funtimes
20:49:33 <vermeille> When using lenses, you can do "data ^. lens", and if lens contains something that might fail, "data ^? lens". What corresponds to "data & lens %= value" for a lens that may fail?
20:50:06 <lispy> vermeille: you might get better answers in #haskell-lens
20:50:08 <mada> is there some way to define a lens that will focus in a buried part of a state monad data type?
20:50:16 <shachaf> It's not "a lens that may fail", it's a traversal.
20:50:20 <mada> does that even make sense?
20:50:49 <lispy> mada: Could you elaborate a bit on what a state monad data type is?
20:50:56 <vermeille> shachaf: right, I don't have the right vocabulary since I'm pretty new to lenses
20:51:16 <shachaf> It's an important distinction, because Traversal' s a is quite different from Lens' s (Maybe a).
20:51:44 <dmj`> lispy: yes, the source is added via cabal sandbox add-source
20:51:52 <hoverbear> carter: What about haskell platform?
20:51:57 <carter> dont care
20:51:59 <carter> dont matter
20:51:59 <johnw> lispy: did you resolve your shelly problem?
20:52:01 <lispy> dmj`: sorry, my question wasn't very clear
20:52:03 <carter> sandboxes for the win
20:52:19 <haasn> mada: Do you mean like “zoom”?
20:52:28 <lispy> johnw: mostly. I pinned the to exceptions-0.5 until exceptions-0.6 gets an update
20:52:51 <osa1> why I can't use cabal flags while building?
20:52:55 <mada> lispy: http://lpaste.net/103715
20:52:57 <carter> you can
20:53:04 <lispy> dmj`: Do you store the .hs files for the executable in the same part of the directory tree? Like, src/Main.hs and src/Data/Foo.hs ?
20:53:19 <carter> lispy: transformers got a fix
20:53:20 <osa1> carter: it says "unrecognized 'build' option" but that same parameter works fine when I use it with "install"
20:53:28 <carter> yeah
20:53:34 <carter> configure or install
20:53:36 <carter> not build
20:53:44 <carter> osa1: did you try cabal help build
20:53:49 <carter> tooo loooook at the build options?
20:53:53 <lispy> mada: wow, so different!
20:54:04 <osa1> nope, I'll check that out
20:54:08 <mada> at any given moment the head of the turns field says which Army is attacking; so far I've been repeating these three steps of getting the head of turns from the state, then deciding which army is attacking and defending, etc
20:54:12 <hakujin> hoverbear: the platform is ghc with cabal and a bunch of pre-installed libraries. you can get the exact same setup by installing ghc and cabal, then installing whatever libraries you need. I'm with carter that you probably want sandboxes rather than installing packages globally.
20:54:22 <carter> yeah
20:54:33 <mada> but I'd like to abstract that away since 'enemies' should be 'findable'
20:54:38 <carter> its really nice to know you can safely solve any problem by deleting a sandbox or ~/.ghc
20:54:40 <mada> with the information inside the state.
20:54:41 <carter> and start fresh
20:54:55 <hoverbear> hakujin: I'm taking my first real dip into haskell, I think I'll worry about setting up sandboxes after I know I want to devote more time to things. :)
20:54:57 <lispy> carter: I don't think we had a problem with transformers per se. It seems to be that exceptions-0.6 doesn't import from it correctly. I was in the process of submitting the pull request when I realized snoyman alread had.
20:55:09 <carter> lispy: ross already fixed it
20:55:09 <dmj`> lispy: looks like this: http://lpaste.net/1565683250620268544
20:55:18 <haasn> sandboxes are really easy to get into, “cabal sandbox init” before your usual cabal operations
20:55:27 <carter> lispy: unregister transformers and build anew
20:55:36 <haasn> and “cabal sandbox add-source ../foo” to get in a source dependency, which is really cool if working on git versions of things
20:55:39 <hakujin> hoverbear: cd into project directory, cabal sandbox init, cabal init, edit cabal file to have the dependencies you want, cabal install --only-dependencies
20:55:45 <dmj`> carter: can you use cabal flags to block out entire library or executable sections
20:55:47 <lispy> carter: I did all of that about 2 hours ago. When did Ross fix it?
20:55:48 <hakujin> and you're off
20:55:59 <carter> @hackage Transfomers
20:55:59 <lambdabot> http://hackage.haskell.org/package/Transfomers
20:56:02 <carter> i can't spell
20:56:06 <carter> he pushed s new version
20:56:21 <carter> dmj`: kindaaaa
20:56:26 <carter> you could have a dummy main
20:56:36 <lispy> dmj`: I thought so. Use a different hs-source-dirs for the executable and the library. That should fix your linker stuff :)
20:58:13 <lispy> carter: I tried that version.
20:58:18 <carter> oh
20:58:19 <carter> umm
20:58:41 <carter> 0.4.1.0 Ross Paterson <ross@soi.city.ac.uk> May 2014
20:58:41 <carter> 	* Reverted to record syntax for newtypes until next major release
20:59:14 <dmwit> haha, guess he got a few complaints
20:59:15 <lispy> carter: the problem is that this module doesn't import runExceptT http://hackage.haskell.org/package/exceptions-0.6/docs/src/Control-Monad-Catch.html
20:59:16 <dmj`> lispy: good idea, think I forgot to export a module from the library
20:59:43 <carter> lispy: .... shoudln't that be fixed by 0.4.1.0 ?
21:00:06 <lispy> carter: How would transformers 0.4.1.0 fix whether exceptions imports the function it needs?
21:00:16 <carter> because that'd be the field name :)
21:00:26 <dmwit> lispy: ExceptT(..) would import runExceptT in 0.4.1.0 but not 0.4.0.0
21:00:33 <dmj`> carter: like do if os(windows): Main-Is: WinMain.hs else Main-Is: Main.hs if os(windows): Build-depends: foo else Build-Depends: bar
21:00:43 <lispy> carter: https://github.com/ekmett/exceptions/commit/506411b228eef79c4285b4c13762d838ace6428a
21:01:09 <carter> fuck
21:01:12 <carter> he didn't fix it all the way
21:01:18 <carter> gotcha
21:01:25 <carter> ohh
21:01:30 <carter> cause ExceptT didn't exist before
21:01:40 <lispy> dmwit, carter: it's not a field name: http://hackage.haskell.org/package/transformers-0.4.0.0/docs/src/Control-Monad-Trans-Except.html
21:01:44 <carter> yes
21:01:46 <carter> i just looked
21:01:52 <carter> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Except.html#ExceptT
21:02:00 <carter> lispy: 0.4 point ONE
21:02:07 <carter> :)
21:02:09 <carter> but yes
21:02:20 <dmwit> lispy: Yeah, seems Ross didn't quite revert all the things he broke.
21:02:26 <dmwit> lispy: I'd complain to him. =)
21:02:29 <carter> yeah
21:02:31 <lispy> carter: I don't think you read what dmwit said
21:02:32 <carter> email him on libraries
21:02:33 <carter> yes
21:02:35 <carter> lispy: i did
21:02:37 <davidfetter> > take 5 "brubek"
21:02:37 <carter> i erad it
21:02:38 <lambdabot>  "brube"
21:02:49 <lispy> carter: that's why i linked to 0.4.0.0
21:02:51 <carter> yes
21:02:57 <carter> i dont' care about that one
21:03:00 <carter> i was talking about now
21:03:03 <lahwran> what tasks would you folks say are not appropriate for haskell, for fundamental reasons?
21:03:06 <carter> the point one release
21:03:09 <lispy> carter: it's still a problem in 0.4.1.0
21:03:10 <lahwran> for implementing in haskell*
21:03:12 <carter> yes
21:03:12 <carter> i know
21:03:13 <davidfetter> hrm. i need to figure out what that needs to end with so the output will be the score or something
21:03:15 <carter> lispy: read what i said
21:03:18 <carter> "oh yeah"
21:03:34 <carter> i agreeee withyou
21:03:40 <EvanR_> lahwran: hard realtime embedded applications
21:03:40 <carter> lahwran: good question
21:03:42 <carter> yes
21:03:43 <carter> those
21:03:43 <cococo> Ha. The first result for "scotty haskell" is the personal site of someone by the name of Scottie Haskell.
21:03:46 <carter> but we have libraries for those
21:03:55 <EvanR_> atom
21:04:03 <EvanR_> cool
21:04:35 <dmwit> lispy: what a muckup =P
21:04:58 <lahwran> EvanR_: interesting. low level stuff? highly IO bound stuff (typical interface-to-a-database websites)? highly stateful stuff?
21:05:16 <EvanR_> strict realtime requirements, low memory
21:05:24 <lahwran> (I'm mostly wanting to hear you say "no, those all are well suited for haskell" and then maybe even details on why so I can learn from them)
21:05:40 <lispy> dmwit: yeah. Fortunately the fix is already merged. I'm just waiting for the hackage upload. In the meantime I have our code pinned to exceptions-0.5
21:05:55 <carter> lahwran: like you wanna right a 4kb ram micro controler for controlling a automated plane
21:06:02 <EvanR_> lahwran: well, all that stuff works fine
21:06:07 * davidfetter wonders whether haskell code has appeared on a movie screen
21:06:08 <dmwit> lahwran: Haskell is good at websites; it has an amazing IO manager and several web-dev platforms.
21:06:10 <carter> anything else, haskell is oke
21:06:14 <dmwit> lahwran: State is fine, too.
21:06:15 <carter> or magic
21:06:18 <lispy> Don't tell anyone, but I've stopped using the PVP for build-deps (I still use it bumping version numbers).
21:06:20 <carter> i write really mtuable code in haskell
21:06:30 <EvanR_> STM is the shit
21:06:44 <lispy> Being pendantic about version numbers tends to lead to more churn and broken builds than not being pendantic. It's a shame really.
21:07:03 <lahwran> what about large applications? couple hundred thousand line of code range (I know lines of code is only a weakly approximate heuristic)
21:07:30 <dmj`> lahwran: standered charter bank has 1M LOC
21:07:30 <EvanR_> large applications need good thought put into component interfaces
21:07:34 <dmwit> lahwran: Perhaps you will like
21:07:38 <dmwit> ?wiki Haskell in Industry
21:07:38 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_Industry
21:07:51 <lahwran> there is currently no text in this page,
21:07:58 <dmwit> ?wiki Haskell in industry
21:07:58 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
21:08:01 <dmj`> Standard*
21:08:01 <lispy> lahwran: you probably don't want to do anything on a super computer with it. That's more because super computers tend to be running weird custom stuff where ghc hasn't been tested. You could use it to make a language to generate nice efficient code to run on the super computer...
21:08:08 <dmwit> capitalization, lol
21:08:09 <EvanR_> haskell actually has tools to define interfaces, unlike many systems
21:08:55 <lahwran> what about performance? I'd imagine, with a type system as capable as haskell's, that it would usually be C levels of performant
21:09:13 <EvanR_> haskell approaches 0.999c ;)
21:09:24 <lispy> lahwran: On the other end of the spectrum, I wouldn't use haskell directly on small computers. But again, DSLs in haskell work well there.
21:09:25 <dmwit> Five years ago, when I started, the rule of thumb was "half the speed of C". Things have improved since then.
21:09:26 <lahwran> ha I like that pun
21:09:28 <carter> lahwran: i'm writing tools to compete with fortran
21:09:47 <carter> but that are more pleasant than fortran
21:10:06 <carter> (just reading the api docs for fortran code makes me wanna drink.... literalllyyy i want to drink after reading them)
21:10:09 <lahwran> I've seen that <they> recommend using inlining-pragmas when writing high performance code
21:10:23 <lahwran> why is that necessary?
21:10:38 <EvanR_> you will need to put tweaks and hits for the compiler
21:10:49 <lahwran> also recommended being more specific about types; again, I'm surprised that's necessary, and I'm curious why it is
21:11:04 <EvanR_> type directed development
21:11:09 <EvanR_> for the win
21:11:17 <lahwran> erm. what?
21:11:28 <lahwran> they recommended being more specific about types for performance reasons
21:11:48 <dmwit> lahwran: Typeclass polymorphism is essentially a vtable lookup.
21:12:00 <dmwit> lahwran: Using monomorphic types enables the compiler to do that lookup at compile time.
21:12:12 <shachaf> dmwit: "half the speed of C" a rule of thumb for what?
21:12:13 <EvanR_> unboxing can increase performance if its not already being done for you
21:12:23 <shachaf> Surely not Haskell code in general.
21:12:24 <dmwit> shachaf: Idiomatic Haskell vs. idiomatic C.
21:12:31 <dmwit> shachaf: yes
21:12:38 <lispy> lahwran: well, the compiler can do an amazing amount of optimization work but some of it requires more concrete information about the computation. type classes can hurt. For numeric stuff knowing Double vs. Float vs. Int can make a big difference.
21:12:38 <shachaf> That sounds implausible.
21:12:54 <lahwran> lispy: I see.
21:12:57 <carter> lahwran: that siad, before you doo inlining and specializing, better to benchmark
21:13:03 <carter> UNLESS You know exactly whats happening
21:13:08 <carter> or need certain guarantees
21:13:23 <carter> certain types of inlining and stuff can create weirddd bugs
21:13:25 <lispy> lahwran: are you familiar with rewriting?
21:13:25 <lahwran> kay. so when writing toy stuff that I just want to play with I shouldn't bother with the performance stuff
21:13:36 <carter> lahwran: heck, just benchmark and fix it later
21:13:43 <lahwran> lispy: I know several possible meanings for that word in this context
21:13:47 <dmwit> shachaf: I dunno. That's the sales pitch they sold me. I haven't had to deal with performance TOO awful much, so I haven't looked into it much.
21:13:50 <lahwran> lispy: but I suspect I don't know the one you mean
21:13:57 <EvanR_> concentrate on avoiding gratuitous space leaks
21:14:20 <lahwran> EvanR_: what is a space leak?
21:14:36 <lispy> lahwran: Okay. maybe I'll try to explain it this way. Pure haskell code is very equational due to referential transparency and what have you. This means that many optimizations opportunities can be expressed algebraicly.
21:14:39 <EvanR_> using way too much memory
21:15:00 <lahwran> oh. as in memory leak without actual lost pointers
21:15:30 <EvanR_> stuff may not be reclaimable precisely because they arent lost
21:15:50 <lispy> lahwran: So ghc has this built in rewrite rule system. You can add your own quite easily. It uses these to rewrite your code to make it faster. Sometimes a seemingly slow bit of code gets rearranged to remove all the intermediate stages (when they don't contribute to the answer)
21:16:50 <lispy> lahwran: it may seem counter intuitive at first, but the high level nature of haskell actually opens up more optimization opportunities that wouldn't exist. Like this thing we call stream fusion (older name is deforestation)
21:17:18 <lahwran> that doesn't seem counter intuitive at all
21:17:19 <EvanR_> more environmentally sounding feature ;)
21:17:32 <lispy> lahwran: ah good :)
21:17:33 <lahwran> as long as everything is well specified, a high level language has more flexibility
21:17:47 <lahwran> lispy: I'm not a programming newbie, just a haskell newbie :)
21:18:10 <lispy> we have properties like map f (map g xs) == map (f . g) xs
21:18:22 <lahwran> shouldn't that be =
21:18:34 <lispy> the LHS would need to create an intermediate list after applying g
21:18:39 <Platz> or is it the constraints that open up the optimization opportunities?
21:18:40 <lispy> the RHS doesn't need the intermediate list
21:18:57 <Platz> high level but no constraints = python/clojure etc.
21:19:25 <lispy> lahwran: You can use = if you prefer, perhaps that's better because it more accurately states it as an identity
21:19:40 <lahwran> lispy: = is assertion of equality, == is test of equality, yes?
21:19:48 <lahwran> Platz: I think it's the intersection; if your language is too specific, then the optimizations become more difficult
21:20:08 <Platz> lahwran: that does make sense
21:20:10 <lispy> lahwran: the == is not Haskell's equality.
21:20:26 <lispy> lahwran: more of a meta-Haskell equality
21:20:29 <carter> ===== abstract meta lingual equality
21:20:51 <carter> not to be confused with === from javascript, which is like a lame version of ==
21:21:02 <carter> in haskell
21:21:03 <lahwran> ===== == === || ===== == =
21:21:14 <carter> :)
21:21:20 <carter> welome!
21:21:25 <Platz> =^10
21:21:27 <EvanR_> ============================== (really really similar)
21:21:47 <lahwran> ====== "exactly the same expression on both sides"
21:22:04 <lispy> lahwran: In my experience, in a language like C (or C++) you'll spend a lot of time implementing your design, refining it, and eventually testing it.
21:22:09 <carter> not to be confused with ~~~~~~~~~~~  "kind the same lens, except when its an iso"
21:22:26 <lahwran> lispy: I think I know what you mean already
21:22:44 <carter> dev.stephendiehl.com/hask/ is a nice speedrun tutorial of modern haskell infos
21:22:44 <lispy> lahwran: in Haskell you'll spend some time implementing it, refining it, and testing it, and then performance tuning it. Even though I've added a step, the overall time is far far less.
21:23:25 <lahwran> I mean, in haskell stm is almost just a switch you turn on and bam you get parallelism; while you still get to pick what is parallel, that's a far cry from having to design the whole damn thing around parallelism when writing in C
21:23:54 <EvanR_> -threaded and you get parallel
21:24:00 <EvanR_> if you have more than one cpu
21:24:19 <lahwran> oh, right. sorry. I forgot that stm was just for less pure stuff
21:24:27 <lahwran> even better! :p
21:24:43 <carter> nah, parallelism isn't magic
21:24:51 <EvanR_> but concurrency is a lot more helpful for other reasons
21:24:51 <carter> @google simon marlow parallel haskell book
21:24:51 <tommd> -threaded -rtsopts -with-rtsopts=-N -O2 -fllvm FTW
21:24:52 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
21:24:52 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
21:25:01 <carter> but we have an amazing set of tools
21:25:04 <lispy> tommd: so much win
21:25:08 <hakujin> stm is for concurrency
21:25:08 <carter> and a great book
21:25:11 <dmj`> stm is for concurrency
21:25:44 <lahwran> carter: I'm not saying it's magic, I'm saying that it's much easier and doesn't require tying your soul into knots
21:25:50 <tommd> I think GHC should alias those 5 flags as -ftw
21:25:51 <carter> lahwran: hahahaah
21:26:01 <carter> its still a lot of work for that last ounce of speed
21:26:27 <carter> but for everything before that last ounce, easier
21:26:29 <lispy> lahwran: the builtin profiling tools are also a lot better than things I've seen for C
21:26:36 <carter> not trivial
21:26:36 <carter> but easier
21:26:38 <lispy> lahwran: granted, you're going to need them more often too :)
21:26:51 <carter> the -fhpc program coverage support is nice too
21:26:53 <carter> been using it more
21:27:40 <lispy> I might be lazier than average when it comes to writing fast haskell code.
21:27:49 <lispy> I like to see things work and then worry about other things
21:28:56 <hakujin> lots of work go in to the major libraries to make the fast; it's easy to write fast code that leans on this body of work
21:29:02 <tommd> In my recent experiences we've been developing in a loop of 1) Make it work naively 2) Design a totally different algorithm 3) Make it work 4) Optimize
21:29:04 <hakujin> s/the/them
21:29:21 <tommd> It is when stepping between 1 and 2 that I really appreciate Haskell.
21:29:23 <lispy> tommd: yeah, and that's also great for testing.
21:30:32 <johnw> and it's also usually nice that between 1 and 2, the types don't change much
21:31:02 <tommd> RIght, the top-level abstraction (the API) is identical
21:46:46 <ektello> hi, I recently upgraded to ghc-7.8.2, and cabal-1.20, I got this failure when trying to install the temporary package: http://lpaste.net/103717
21:46:51 <ektello> is there anything I should do?
21:47:04 <lispy> ektello: loking now
21:47:42 <johnw> can you paste that log file so we can see the whole error?
21:48:00 <lispy> ektello: it's hard to say without seeing the whole error.
21:48:05 <ektello> ok
21:48:24 <ektello> http://lpaste.net/103719
21:48:37 <johnw> exceptions changed
21:48:49 <johnw> you'll need to install with a constraint set to fix exceptions at an older version
21:49:02 <johnw> probably 0.4 would do
21:49:15 <ektello> ah ok, thanks a lot
21:49:31 <johnw> masking is now in its own type class
21:50:23 <johnw> the problem with security is that no matter how much you have, you may still have none
21:52:09 <dmj`> ektello: there's already a pull req to fix this
21:52:10 <dmj`> https://github.com/batterseapower/temporary/pull/12
21:52:28 <ektello> cool
21:53:35 <hunt> anyone use sublime text? tips on getting it nice for haskell?
21:53:37 <lispy> johnw: heh
21:53:58 <lispy> hunt: sorry I use vim and emacs but not sublime
21:54:18 <carter> yup
21:54:19 <carter> i use it
21:54:27 <carter> i also have the plugins disabled :)
21:54:31 <hunt> anything comparable to haskell mode for emacs
21:54:31 <hunt> aw
21:54:34 <mayski> hunt: I use sublimeREPL
21:54:37 <carter> because they die on large code bases like .... GHC
21:54:39 <mayski> but that's it
21:54:45 <carter> i read the docs
21:54:55 <hunt> ok thanks mayski ill look into it
21:55:21 <mayski> probably not what you're looking for though
21:55:41 <carter> hunt: sublime haskell is maintained
21:55:43 <carter> and used
21:56:11 <carter> hunt: sublime haskell is wha tyou want
21:56:13 <hunt> im looking for a nice linter if there is one
21:56:22 <hunt> ok thanks carter
21:56:27 <lispy> hlint?
21:56:43 <carter> hunt: note you can  disable as much of sublime ahskell as you want
21:57:21 <bluezone> in what kind of applications is haskell used?
21:57:29 <johnw> bluezone: all kinds
21:57:37 <lispy> hunt: #haskell and haskell-cafe are pretty good code linting tools :)
21:57:50 <EvanR_> manatee
22:00:36 <t4nk428> how can i express the EBNF exp -> item {"+" item| "-" item}  use the Parsec's combinator ?
22:03:30 <t4nk428> orz..anybody see my question?
22:03:45 <EvanR_> t4nk428: you might need to use the expressino parser
22:03:48 <lispy> t4nk428: you're probably better off with something like happy if you already have EBNF
22:03:50 <EvanR_> expression
22:04:25 <lispy> t4nk428: here is some example code: https://github.com/dagit/happy-plus-alex
22:04:44 <lispy> if you really want to use Parsec you probably want to use <|> and try.
22:05:36 <t4nk428> yep, but i can not get the expected result
22:05:51 <lispy> t4nk428: what happens?
22:05:52 <EvanR_> whats the operator that does application backwards, flip ($)
22:06:35 <shachaf> lens has (&)
22:07:00 <EvanR_> @hoogle (&)
22:07:01 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
22:07:01 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
22:07:01 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
22:07:13 <t4nk428> i think me misunderstand the try and <|>, so I want some example
22:07:24 <lispy> t4nk428: I might expect it too look a bit like this: exp = do i1 <- item; op <- plus <|> minus; i2 <- item; return (BinExpr i1 op i2)
22:07:31 <hoverbear> Running `cabal install --only-dependencies` gives me a not found for `MongoDB`, Yes I see it in hackage. http://hackage.haskell.org/package/mongoDB How can I get it?
22:08:03 <lispy> hoverbear: I think it's case sensitivy
22:08:26 <hoverbear> lispy: I checked that, let me could echeck
22:08:43 <hoverbear> Yup, my bad
22:09:20 <athan> Hey folks, what are the most common reasons for a strange closure?
22:09:44 <hoverbear> lispy: Thanks!
22:09:58 <lispy> athan: normally that shouldn't happen!
22:10:33 <athan> lispy: I think it's my architecture. This is a pretty poor HP laptop, with an old Athlon 64 X2 :/
22:10:37 <lispy> athan: I would guess a bug in an FFI binding, or a platform specific bug, or a GC bug?
22:10:39 <athan> I
22:10:48 <athan> I'm trying a -v3 right now
22:10:49 <lispy> I guess it could be hardware related
22:10:53 <carter> what OS
22:10:57 <carter> what ghc version
22:11:00 <athan> GNU/Linux
22:11:46 <athan> I had a real pain getting it to work in the first place, HP put some kind of proprietary nonsense in the 32/64 conversion or something. It's 7.6x, I'll fetch the details now
22:11:48 <athan> thank you :)
22:12:08 <athan> lispy: I hope the latter :P Thanks :)
22:14:15 <t4nk428> @amb
22:14:15 <lambdabot> Maybe you meant: ask arr
22:24:17 <startling> what is a "strange closure"?
22:25:00 * startling . o O ( Are there charm closures, too? )
22:25:58 <EvanR_> Quantum Closure Dynamics
22:30:17 <ReinH> lispy: ah nice, so am I
22:30:52 <athan> lispy: Magic. -v3 fixed it.
22:31:47 <flebron> Hi. Trapped in cabal hell. What does this mean, and if not --reinstall world, how can I just toss everything and start again? http://lpaste.net/103720
22:31:59 <lispy> athan: what is -v3?
22:32:06 <l0cust> Whatever happened to hackagebot
22:32:22 <lispy> ReinH: Cool. I don't think I'm very well connected the other haskellers in pdx.
22:32:29 <athan> cabal ___ -v3 gives you maximum verbosity
22:32:36 <startling> flebron: you can always rm -rf ~/.ghc
22:32:37 <lispy> athan: cabal was crashing?
22:32:44 <athan> ghc was, actually
22:32:50 <ReinH> lispy: me neither
22:32:53 <athan> with a strange closure, crazy number afterward
22:32:54 <lispy> athan: but adding -v3 to cabal fixed the ghc crash?
22:32:57 <athan> yep
22:33:01 <athan> it has happened many times now
22:33:06 <lispy> athan: that's super suspicious :)
22:33:08 <startling> flebron: oh, looks like you've got an old base
22:33:11 <athan> lubuntu, using their binary
22:33:16 <athan> oh tell me about it
22:33:19 <startling> flebron: (that means you need to upgrade ghc)
22:33:24 <lispy> athan: does the verbosity get passed to ghc when you do that?
22:33:24 <athan> I've been trying to build my own from source
22:33:35 <flebron> startling: I literally downloaded Haskell platform an hour ago, the newest one.
22:33:38 <athan> Yes, it does
22:33:57 <flebron> I had one before, but I ran (I think) a script that uninstalled the old one - that's what the platform installer told me to do.
22:34:05 <lispy> athan: what happens when you tried to build ghc?
22:34:14 <flebron> Can I just rm -rf ~/.ghc and wake up from the nightmare?
22:34:19 <lispy> athan: is that when you get the strang closure?
22:34:33 <athan> lispy: I think the same thing and while I was here nobody answered, I'll try really quick, but I might not have an answer for a few hours
22:34:34 * hackagebot txtblk 0.1.0.0 - A text txtblk.  http://hackage.haskell.org/package/txtblk-0.1.0.0 (pharpend)
22:34:37 <lispy> flebron: that command should be safe, but it means you'll have to reinstall stuff.
22:34:40 <athan> I believe so, too
22:34:52 <athan> lispy: I've had plenty of packages fail, mostly advanced ones
22:35:00 <athan> with that error, I mean
22:35:12 <lispy> athan: I'll be asleep by then
22:35:25 <startling> flebron: weird. newest hp comes with base 4.6.0.1, so something weird is happening
22:35:26 <athan> Right on, I'll save the results for you next time we meet.
22:35:28 <lispy> athan: building released versions of ghc is usually very very easy.
22:35:33 <startling> flebron, can you ghc --version and cabal --version?
22:35:41 <startling> also which cabal
22:35:41 <athan> I know! It works great on my server
22:36:00 <athan> but again, this thing is a frankenstein
22:36:20 <athan> do you know if you could easily cross compile it?
22:36:22 <startling> flebron: also ghc-pkg list | grep base, I guess
22:36:24 <athan> :S
22:36:46 <lispy> athan: have you stressed the system yet with a tool designed for that like a memtester? http://pyropus.ca/software/memtester/
22:37:00 <flebron> So, removed ~/.ghc, cabal still not working... http://lpaste.net/103721
22:37:01 <athan> no, I have not!
22:38:51 <lispy> flebron: I've not seen that before. I missed your platform details. Any chance you're on osx mavericks?
22:38:59 <flebron> Indeed I am.
22:39:12 <flebron> I installed XCode command line tools from the App Store a few minutes ago.
22:39:42 <lispy> flebron: you might be experience an issue where ghc assumes it's using gcc but it's getting clang and clang doesn't understand cpp the same way gcc does.
22:40:25 <lispy> carter: Do you know how to help flebron with osx mavericks issues?
22:40:36 <carter> flebron: what ghc version
22:40:43 <carter> flebron: screw your old ghc
22:40:46 <carter> lemme give you my build
22:41:24 <flebron> I've no particular affection towards my build.
22:41:27 <carter> good
22:41:37 <flebron> Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.2
22:41:53 <carter> http://www.wellposed.com/opensource/ghc/releasebuild-unofficial/ghc-7.8.2%2BcppPatch%2BintreeGMP/ghc-7.8.2-x86_64-apple-darwin.tar.bz2
22:41:56 <lispy> 7.8.2 is the latest
22:41:59 <carter> lispy: i know
22:42:02 <carter> my build
22:42:09 <carter> flebron: dl that
22:42:10 <lispy> flebron: you might pay some early adopter taxes for using 7.8.2.
22:42:14 <carter> nope
22:42:16 <carter> lispy: its fine
22:42:16 <lispy> flebron: but it's better than 7.6.x
22:42:18 <carter> i use it
22:42:28 <carter> i've been using 7.8 since... january?
22:42:29 <johnw> i've been using only 7.8.2 for about two weeks now, and it's been great so far
22:42:43 <carter> this is probably the most stable release everrr
22:42:43 <startling> there were some library problems but they seemed to have cleared up.
22:42:51 <carter> travisci helped
22:42:58 * startling whistles
22:43:26 <lispy> cool, I might upgrade more of my installes. So far I'm only using 7.8.2 on windows.
22:43:32 <flebron> carter: That'd be just a binary, or something like an installation? (I'm not sure which component is failing)
22:43:41 <carter> flebron: i nkow whats wrong
22:43:44 <carter> don't wanna explain
22:43:48 <carter> just install it
22:43:49 <flebron> Ah, OK :p
22:44:00 <carter> flebron: OOOOORRRR
22:44:06 <carter> you could do something if you wanna keep 7.6
22:44:11 <carter> but this is cooler
22:44:19 <carter> and doesn't require anything
22:44:23 <lispy> but, how do you install it? Just untar, ./configure --prefix=<my install loc>; make install?
22:44:27 <carter> yes
22:44:35 * hackagebot txtblk 0.1.1.0 - A text blocker.  http://hackage.haskell.org/package/txtblk-0.1.1.0 (pharpend)
22:44:39 <dmj`> lispy: how has your experience w/ 7.8.2 on windows been thus far?
22:45:40 <lispy> dmj`: I ran into two problems: a) I had to update my path to get ghc to use the correct ld, b) a bad interaction with vector and inlining but that's easy to fix in my code (I also submitted a bug report)
22:45:56 <lispy> dmj`: but...so far the 64bit build is working
22:46:24 <dmj`> thanks good to know
22:50:06 <dmj`> lispy: did you do anything w/ concurrency by any chance
22:50:23 <lispy> dmj`: only cabal install -j
22:50:44 <lispy> dmj`: I should fix the inlining problem and I can run my ray tracer with the threaded rts
22:50:49 <lispy> hang on
22:51:11 <flebron> carter: So from that dir, I say ./configure --prefix=~/Haskell/; make; make install?
22:51:19 <carter> no make
22:51:25 <carter> just configure then make install
22:51:29 <carter> whatever prefix you want
22:51:29 <flebron> alright
22:51:34 <carter> defualt it /usr/local
22:52:19 <flebron> So I should add that prefix's bin/ to my $PATH, as that's where cabal and ghc will be?
22:52:57 <carter> yea
22:52:59 <carter> prefix/bin
22:55:16 <flebron> Should I just rm the old /usr/bin/ghc, /usr/bin/cabal, etc?
22:55:23 <carter> sureeeee
22:55:24 <flebron> Is there a cleaner way than just going around deleting stuff?
22:55:25 <carter> why not
22:55:29 <carter> where you new cabal?
22:55:33 <carter> do you ahve 1.20 lying around
22:55:39 <carter> binaries are online per se
22:55:59 <EvanR_> rm should be the clean way, i wish more systems were designed like this
22:56:10 <flebron> Oh, I have to install cabal as well
22:56:17 <carter> flebron: binaries are online
22:56:18 <carter> hanong
22:56:29 <carter> http://www.haskell.org/cabal/download.html
22:56:35 <carter> dl the mac 1.20.1 one
22:56:36 <flebron> But I should first remove my "global" ghc, so as not to have Cabal confused.
22:56:38 <carter> and put it in your apth
22:56:44 <carter> cabal picks the first ghc in path
22:56:46 <carter> kill you rold one
22:57:16 <flebron> 1.20.1 being 1.20.0
22:57:28 <carter> sure whcihever
22:57:30 <carter> both are nice
23:01:04 <carter> flebron: you should be allll set now
23:01:05 <carter> right?
23:01:23 <flebron> Stupid question, it's been a long time since I didn't use cabal-install to install a package
23:01:30 <flebron> How do I install Cabal without cabal?
23:01:30 <carter> ummm
23:01:36 <flebron> runghc Setup.hs?
23:01:39 <carter> flebron: DOWNLOAD THE BINARY I LINKED TO
23:01:50 <carter> http://www.haskell.org/cabal/download.html has a binary
23:01:51 <johnw> ooh, all caps
23:01:54 <carter> http://www.haskell.org/cabal/release/cabal-install-1.20.0.1/cabal-x86_64-apple-darwin-mavericks.tar.gz
23:01:54 <johnw> makes me nostaligc
23:02:01 <flebron> Oh, I didn't see a binary
23:02:03 <carter> :)
23:02:10 <enthropy> the ./boostrap.sh is another option
23:02:16 <carter> yea, but this is easier
23:02:18 <flebron> Went for the first link that matched my arch xP Sorry!
23:02:18 <carter> :)
23:03:00 <carter> someone needs to cleanup that webpageeeeee
23:03:20 <carter> needs more blink tag
23:03:27 <flebron> Hrmph
23:03:40 <flebron> http://lpaste.net/103722
23:03:41 <carter> or a wee table / grid
23:03:46 <flebron> Probably something dumb
23:03:55 <carter> agda
23:03:59 <carter> vs Agda
23:04:14 <flebron> Pretty sure it was Agda
23:04:15 <carter> oooo
23:04:17 <carter> flebron:
23:04:18 <carter> ok
23:04:27 <carter> 1) rm ~/.cabal/config
23:04:30 <carter> 2) cabal update
23:04:36 <carter> 3) cabal install cabal-install
23:04:40 <carter> just to make sure things are working
23:04:41 <carter> k?
23:04:55 <flebron> doing that
23:05:09 <lispy> dmj`: seems to work!
23:05:12 <flebron> (Thanks for all the help so far by the way!)
23:05:17 <lispy> dmj`: only using 2 threads
23:05:22 <carter> be glad its pro bono :)
23:06:16 <flebron> carter: http://lpaste.net/103723
23:06:30 <carter> ghc --version
23:06:34 <carter> cabal --version
23:06:38 <carter> which ghc
23:06:40 <carter> which cabal
23:06:45 <flebron> The Glorious Glasgow Haskell Compilation System, version 7.8.2
23:06:51 <dmj`> lispy: really, good
23:06:56 <flebron> Both of the latter are empty... :s
23:07:02 <flebron> How can 'ghc' be working, but not 'which ghc'?
23:07:07 <dmj`> lispy: only 2 cores? what windows os?
23:07:08 <carter> flebron: hash -r
23:07:23 <flebron> Still both empty
23:07:28 <carter> flebron: open a new terminal tab
23:07:35 <carter> did you edit the path for the right shell
23:07:50 <flebron> I just opened a new terminal tab, and that's still the result
23:07:55 <carter> fix your path
23:08:07 <flebron> http://lpaste.net/103724
23:08:11 <carter> you /Users/FLEBRONJAMES/Haskell
23:08:25 <carter> not ~/Haskell
23:08:25 <carter> right?
23:08:47 <flebron> No xP I'll fix that
23:08:54 * flebron swears he is not this much of a newbie usually
23:09:18 <carter> ok
23:09:24 <carter> fix it then i'm off irc
23:09:27 <flebron> there it goes
23:09:37 <carter> flebronJames scores
23:09:38 <flebron> Yay :D
23:09:44 <carter> night
23:09:44 <dmj`> lispy: only worry I have is that network I/O on windows doesn't time out.
23:09:46 <flebron> A billion thanks!
23:09:50 <flebron> carter++
23:09:55 <dmj`> lispy: https://ghc.haskell.org/trac/ghc/attachment/ticket/7353/timeout.hs
23:09:56 <carter> you owe me bludddddd
23:09:56 <flebron> Or, let carter = carter + 1 in carter
23:09:57 <carter> or ++
23:10:07 <carter> appending applause
23:10:10 * carter bows
23:10:24 <carter> flebron: also my build is a nice fast build :)
23:10:32 <flebron> :))
23:10:36 <johnw> doesn't that let makes you ⊥?
23:11:03 <carter> nah, i'm TOP son
23:11:14 <carter> pointedly
23:11:19 <carter> i'm tired
23:11:21 <kylec01> "さようなら" why japanese characters
23:11:30 <carter> ?
23:11:39 <kylec01> in "S_T_A_N left the room (quit: Quit: さようなら)."
23:12:08 <startling> why not?
23:12:40 <kylec01> i dunno, what does it mean?
23:12:51 <ion> “room”
23:13:27 <sgronblo> it says sayounara
23:13:30 <sgronblo> farewell
23:13:31 <kylec01> oh
23:13:33 <carter> avedasane
23:13:37 <kylec01> ty
23:13:38 <carter> bonvoyage
23:13:48 <carter> awvoi
23:13:53 <carter> i'll stop
23:13:55 <carter> night
23:14:04 <kylec01> night
23:14:07 <carter> flebron: gonna prove some lemmata now that agda's new version is out?
23:14:12 <fragamus> OK dudes, I just installed mavericks, completely uninstalled and reinstalled the haskell platform and now I'm considering installing GHC 7.8.2
23:14:22 <sgronblo> good of you to recognize them as japanese and not "chinese" though :)
23:14:29 <carter> fragamus: follow the directions i yelled at flebron
23:14:33 <flebron> carter: Well... now that you mention it
23:14:34 <carter> in the scrollbrack
23:14:37 <flebron> rejecting: base-4.7.0.0/installed-068... (conflict: Agda => base>=4.2 && <4.7)
23:14:45 <flebron> So Agda doesn't work with the new base :p
23:14:47 <carter> fragamus: darcs clone head
23:14:52 <fragamus> i just joined the channel
23:14:52 <carter> fragamus: i built it this week
23:14:54 <carter> from HEAD
23:15:05 <carter> fragamus: ircbrowse  logs
23:15:10 <kylec01> sgronblo: i took japanese in grade 9 but that was too many years ago, recognized the symbols at least :)
23:15:18 <carter> @google ircbrowse
23:15:19 <lambdabot> http://ircbrowse.net/
23:15:19 <lambdabot> Title: IRC Browse
23:15:31 <carter> look at the #haskell logs of me politely yelling at flebron  :)
23:15:38 <flebron> Haha
23:15:40 <carter> i'm off to bed
23:15:46 <carter> or at least off irc
23:15:46 <flebron> Thanks :)
23:15:51 <kylec01> night carter
23:15:55 <carter> thankee
23:15:56 <fragamus> ircbrowse logs
23:16:03 <fragamus> hmm
23:16:04 <carter> fragamus: on the webternet
23:16:05 <fragamus> whats that
23:16:08 <fragamus> ok
23:16:10 <carter> fragamus: the URL
23:16:15 <kylec01> it's the logs of this chat
23:16:18 <carter> @google ircbrowse
23:16:18 <lambdabot> http://ircbrowse.net/
23:16:19 <lambdabot> Title: IRC Browse
23:16:21 <carter> click ther
23:16:26 <carter> open in your browser
23:16:31 <carter> go to the #haskell logs
23:16:33 <carter> and read :)
23:16:57 <carter> then if comfused, ask flebron  for help
23:16:59 <carter> hes an expert now
23:17:12 <flebron> hahaha
23:17:28 <carter> you've installed ghc in places i've not install it ever
23:17:32 <carter> so you must be an expet
23:17:35 <carter> *expert
23:17:36 <carter> ok
23:17:37 <carter> night
23:31:47 <l0cust> How we all doing
23:32:43 <certainty> moin
23:32:47 <cococo> l0cust: doing good
23:32:54 <l0cust> nice to hear
23:33:06 <l0cust> cococo: finally got the libnotify plugin for irssi to work
23:33:11 <l0cust> cococo: so yay
23:33:17 <cococo> l0cust: haskell currently makes no sense to me but I'm determined. I'm going to force myself to use it on my next project.
23:33:22 <cococo> l0cust: well congrats :)
23:33:26 <l0cust> cococo: what's your next project?
23:33:34 <cococo> l0cust: ..No clue :p
23:33:39 <cococo> l0cust: just wrapped my last one up
23:34:16 <l0cust> cococo: I would shamelessly promote my project, but I don't know if it would be a good introduction to the language -the embedded concepts are already confusing enough
23:34:26 <l0cust> It's open source tho
23:34:27 <kylec01> http://learnyouahaskell.com/chapters ?
23:34:49 <cbarrett> Is there an ETA on a release of the Haskell Platform with GHC 7.8 in it?
23:34:58 <cococo> l0cust: feel free to link it, but as you said it would probably be too advanced for me ATM.
23:35:17 <l0cust> cococo: https://github.com/pharpend/tropical
23:35:49 <cococo> Side note, Haskell has been given the nicest colour on GitHub.
23:35:53 <l0cust> cococo: There's a reddit neckbeard who claims he will help, haven't heard from him in a couple days
23:36:04 <l0cust> color on github?
23:36:17 <cococo> l0cust: language statistics, top of any repo
23:37:05 <cococo> l0cust: The ugliest is JavaScript, which sucks because JS already gets so much hate.
23:37:24 <cococo> Then again, I'm probably the only one who cares about or even notices that haha
23:37:29 <carter> cbarrett: just use ghc 7.8 + a cabal-install binary
23:37:43 <l0cust> cococo: I don't see what you're talking about. Maybe AdBlock got overzealous
23:37:44 <cbarrett> I'm fine myself but I'm just curious
23:37:49 <cbarrett> carter but thanks :)
23:38:01 <carter> or email mzero and haskell to hlep
23:38:06 <carter> *ask to help
23:38:08 <carter> ok
23:38:11 <carter> to be dof reals
23:38:20 <carter> cbarrett: any good fish guide? i'm still cargo cultin
23:38:27 <cbarrett> carter: Just been reading the manual
23:38:33 <carter> k
23:38:40 <cbarrett> Every time I try to do something I try to read the appropriate manual section
23:38:49 <l0cust> cococo: ooooh you can click on the color
23:38:50 <cococo> l0cust: take the Reddit repo for example. At the top, under the description there's a bar full of colours, those are the languages used ordered by size.
23:38:51 <l0cust> that's nice
23:38:54 <cococo> ha yeah
23:39:11 <ashnur> hi
23:39:29 <l0cust> ashnur: hi
23:39:35 <cbarrett> carter: to answer your lambdabot delayed question, the thing I was talking about was `funcedit`
23:39:41 * hackagebot criterion 0.8.1.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.8.1.0 (BryanOSullivan)
23:39:46 <ashnur> so, when I download haskell platform, it says i need ghc. when I go to download ghc, it says i don't really need it. so I try ./configure and it says i need it
23:39:49 <ashnur> seriously wtf
23:39:55 <l0cust> cococo: Now I'm going to look at this in every single repo. Thanks, yet another productivity dump
23:40:02 <cococo> l0cust: np :)
23:40:31 <l0cust> I think my dotfiles are the funniest - 74% elisp. Do I really use Emacs that much?
23:41:43 <l0cust> ashnur: people suck with dependencies
23:41:49 <ashnur> i don't get that http://www.haskell.org/ghc/download_ghc_7_6_3 Stop! note from the top. is that true?
23:42:09 <ashnur> because if that's true, i don't know where is the haskell-platform which has ghc in it
23:42:11 <l0cust> hm
23:42:17 <ashnur> if it's not true, why it's there
23:42:27 <l0cust> okay, if you try to install the haskell-platform, what happens?
23:42:36 <l0cust> Oh, and what OS are you using?
23:43:01 <ashnur> funnily enough, this was the least outdated information i've seen on any haskell site, so I hoped for it being correct :)
23:43:09 <ashnur> l0cust: arch linux
23:43:14 <l0cust> Oh
23:43:18 <l0cust> don't install haskell platform
23:43:22 <l0cust> I'm an archer too
23:43:47 <l0cust> Install ghc and cabal-install from the official repos, then just cabal install base
23:43:48 <ashnur> l0cust: when i do ./configure in the downloaded targ.gz, says it needs ghc
23:44:10 <ashnur> l0cust: i will do that if you first ensure me that it's possible to install Elm with those. because I wasted a day trying
23:44:28 <l0cust> Elm, the ancient mail client?
23:44:32 <ashnur> nope, elm-lang
23:44:40 <ashnur> https://github.com/elm-lang/Elm/wiki/Installing-Elm#arch-linux
23:44:49 <ashnur> the GUI language thingie
23:45:15 <ashnur> oh, and those install instructions also did not work out too well for me
23:45:36 <l0cust> did you try "cabal install Elm"
23:45:38 <ashnur> tbh. ever since I tried haskell a year ago, I always had some packages failing when I did pacman -Syu
23:45:58 <ashnur> l0cust: yes, I tried, multiple times
23:46:10 <l0cust> ashnur: read the most recent arch linux news - they explain how to fix that problem
23:46:57 <ashnur> l0cust: i just said I wasted a day, i had enough time to try probably all thinkable combinations of arch packages and when that failed I went for cabal, and stuff. it fails because of some new things
23:47:07 <ashnur> hmm
23:47:20 <ashnur> l0cust: i don't think it's an arch problem
23:47:44 <l0cust> ashnur: they basically said to uninstall every haskell package that isnt ghc or cabal-install, and then to use cabal-install to get everything else
23:47:45 <ashnur> l0cust: as I just said, i could not install it with cabal either
23:48:00 <l0cust> ashnur: I'm trying at the moment - so far so good
23:48:08 <l0cust> ashnur: what error messages do you get
23:48:08 <ashnur> l0cust: i will try to find these news
23:48:30 <l0cust> ashnur: https://www.archlinux.org/news/managing-haskell-packages-with-ghc-782/
23:48:56 <l0cust> god damn that's a huge package
23:49:06 <l0cust> I would not be at all surprised if it breaks
23:49:13 <l0cust> ah
23:49:17 <ashnur> l0cust: first it was https://github.com/batterseapower/temporary/issues/13
23:49:18 <l0cust> temporary is broken
23:49:21 <ashnur> then
23:49:23 <ashnur> when you fix that
23:49:30 <ashnur> i mean add that argument
23:49:35 <ashnur> it fails with pandoc
23:49:40 <ashnur> and that I couldn't fix
23:49:47 <l0cust> yeah, don't know what to tell you
23:49:54 <l0cust> that sucks
23:49:56 <ashnur> i mean, i was so tired I started saying eclipse instead of cabal
23:50:29 <sopvop> Hm, should I just foldl' f [] . Map.toList, or use Map.foldlWithKey? (Or use lens?)
23:50:32 <l0cust> cococo: Any thoughts on my project?
23:52:05 <cococo> l0cust: The truth is I know nothing about tropical geometry or Haskell (yet), so I really can't judge it.
23:53:50 <l0cust> cococo: Thanks for taking a look
23:54:04 <l0cust> cococo: What have you done so far to learn Haskell?
23:55:15 <l0cust> sopvop: I don't really know what you are trying to do
23:55:45 <l0cust> sopvop: with that in mind, the option on the left (foldl' ...) looks nicer
23:56:12 <cococo> l0cust: np, sorry I can't do much more. | I've been reading bits of Learn You a Haskell and playing around in ghci, but it still feels weird. My next project would most likely involve creating a simple http web server, but I just can't visualize that in Haskell in the same way I can in Python or Node.
23:56:31 <l0cust> sopvop: In my code, I try to stick to standard library functions instaed of third-party library functions
23:56:49 <l0cust> sopvop: it makes it easier for other people
23:56:53 <l0cust> sopvop: that's just my opinion tho
23:57:13 <l0cust> cococo: Yeah, I've never done anything like that
23:57:46 <l0cust> cococo: My projects involve things that I will actually use, that way I'm more motivated to do them
23:58:04 <l0cust> cococo: I also have this little personal project, https://github.com/pharpend/tn
23:58:13 <l0cust> cococo: It needs a lot of work
23:58:40 <l0cust> cococo: I have plans for it, I just don't really have time to work on it at the moment
23:59:46 <cococo> l0cust: that looks cool actually
