00:08:58 * hackagebot pipes-http 1.0.1 - HTTP client with pipes interface  http://hackage.haskell.org/package/pipes-http-1.0.1 (GabrielGonzalez)
00:08:58 * hackagebot bloodhound 0.1.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.1.0.0 (bitemyapp)
00:09:15 <jle`> wb hackagebot
00:12:18 <lispy> jle`: I have a solution in terms of foldl, but foldr eludes me
00:13:04 <lispy> I take that back. It's wrong for short lists
00:29:21 <EvanR> hey, how do i modify a tvar and also read it at the same time
00:29:39 <EvanR> modifyTVarCool :: TVar a -> (a -> a) -> STM a
00:30:50 <johnw> just read it and write it
00:30:54 <johnw> atomicity is guaranteed
00:31:06 <EvanR> oh right
00:31:15 <ion> johnw: But that’s sequential, not simultaneous. ;-)
00:31:28 <johnw> modifyTVar v f = readTVar v >>= writeTVar v . f
00:31:34 <EvanR> yeah, you get to decide if you read the old or new value
00:33:55 * hackagebot church-list 0.0.1 - Lazy lists with O(1) concatenation that, unlike dlists, allow inspection  http://hackage.haskell.org/package/church-list-0.0.1 (JohnWiegley)
00:34:59 <shachaf> johnw: That's not particularly Church encoding so church-list isn't really a good name for it.
00:35:04 <shachaf> It also already exists: http://hackage.haskell.org/package/fmlist-0.8/docs/Data-FMList.html
00:36:10 <ion> http://www.urbandictionary.com/define.php?term=fml&defid=1256378 and now also List
00:36:58 <johnw> shachaf: thanks for letting me know
00:37:28 <johnw> i'll empty out this package on Hackage then and refer to FMList
00:38:00 <lispy> jle`: if you allow me to use snd on the outside of the fold I have it working now
00:38:06 <lispy> > let lastTwo _ (_,Just (x,y)) = ([],Just (x,y)); lastTwo a ([x],Nothing) = ([], Just (a,x)); lastTwo a ([],Nothing) = ([a],Nothing) in snd (foldr lastTwo ([],Nothing) [a,b,c,d])
00:38:08 <lambdabot>  Just (c,d)
00:38:14 <Nahiyan> > let fib n = round((gold**n - (-gold)**(-n))/sqrt(5)) where gold = (1 + sqrt(5))/2
00:38:15 <lambdabot>  not an expression: ‘let fib n = round((gold**n - (-gold)**(-n))/sqrt(5)) whe...
00:38:17 <lispy> > let lastTwo (_,Just (_,y)) a = ([],Just (y,a)); lastTwo ([a],Nothing) x = ([],Just (a,x)); lastTwo ([],Nothing) a = ([a],Nothing) in snd (foldl lastTwo ([],Nothing) [a,b,c,d])
00:38:18 <lambdabot>  Just (c,d)
00:38:24 <shachaf> johnw: I'm also not quite sure what you mean about inspection.
00:38:32 <Nahiyan> arrggh lambdabot
00:38:53 <lispy> jle`: I had to had to use the tuple so I could handle the singleton list
00:38:55 <ion> arrggh user
00:39:09 <johnw> I mean things like asking for the "head" of the list
00:39:23 <shachaf> Does it actually end up being better than DList at looking at asking for the "head" of the list?
00:40:06 <johnw> you're saying that since DList is also lazy, it will end up only looking at a single cons cell?
00:41:32 <shachaf> I don't know if that's what I'm saying.
00:41:54 <johnw> my answer is: I haven't proven that that's the case either way
00:42:04 <shachaf> This is using a basically similar trick to DList.
00:42:25 <shachaf> Here's another representation of lists: newtype List a = List { runList :: forall r. (a -> r -> r) -> r -> r }
00:42:41 <johnw> right, that's the foldr representation
00:42:48 <ion> @type GHC.Exts.build
00:42:49 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
00:43:06 <shachaf> And here's another one (it's invalid but so is DList): data List a = Leaf a | Empty | Append (List a) (List a)
00:43:17 <johnw> yes, I actually created that type first
00:43:24 <ion> DList is invalid?
00:43:33 <shachaf> I mean that the type is too big.
00:43:35 <johnw> see https://github.com/jwiegley/church-list/commit/feff118e2785805fe35c525b67211916c05b050f
00:43:43 <johnw> well, not quite the same
00:43:43 <shachaf> You have to hide the constructor to export it from a library.
00:43:51 <lispy> shachaf: and which one is the church encoding?
00:43:55 <johnw> mine was: data List a = Whole [a] | Split (List a) (List a)
00:43:56 * hackagebot church-list 0.0.2 - Removed; please see fmlist.  http://hackage.haskell.org/package/church-list-0.0.2 (JohnWiegley)
00:44:02 <shachaf> That's quite different.
00:44:19 <johnw> yes, it rather is
00:44:23 <shachaf> lispy: None of them, according to Oleg. :-) http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
00:44:46 <shachaf> But you could say it's the build one.
00:45:34 <johnw> heh, Sjoerd writes of fmlist: "FoldMap lists have O(1) cons, snoc and append, just like DLists, but other operations might have favorable performance characteristics as well. These wild claims are still completely unverified though."
00:45:43 <johnw> so we all have a feeling it's better, but no one really knows
00:46:19 <shachaf> "without any wasted work" is certainly not true.
00:46:23 <lispy> shachaf: okay. yeah. I guess I've been sloppy because I think expressing a type in terms of its fold as is church encoding
00:47:04 <johnw> shachaf: I mean that any work done by the DList will have to be done again
00:47:05 <shachaf> But depending on how you construct the list, FMList can give you a balanced tree with logarithmic-time access to the leaves.
00:47:17 <shachaf> That's true of this type too.
00:47:25 <johnw> hmm
00:47:51 <shachaf> Anyway, the Leaf/Empty/Append representation is sort of the same idea.
00:47:55 <johnw> right
00:48:01 <johnw> ok, I see your point
00:48:05 <shachaf> newtype FMList a = FMList { runFMList :: forall m. Monoid m => (a -> m) -> m }
00:48:06 <johnw> it was at least a fun exercise
00:48:20 <shachaf> newtype FMList a = FMList { runFMList :: forall m. m -> (m -> m -> m) -> (a -> m) -> m }
00:48:37 <johnw> once upon a time you asked me if I could see how all of these types were lists; now I certainly know
00:48:40 <shachaf> You can see how that's an encoding of the Leaf/Empty/Append type above.
00:48:51 <johnw> yes
00:48:52 <shachaf> Minus the laws.
00:49:05 <shachaf> But the laws are what forces it to be a list.
01:11:46 <jle`> > let last2 = liftA2 (,) <$> fst <*> snd . foldl (\x (_,y) -> (y,x)) (Nothing,Nothing) in (last2 [1,2,3], last2 [1])
01:11:47 <lambdabot>  Couldn't match expected type ‘(Data.Maybe.Maybe a, b0)’
01:11:48 <lambdabot>              with actual type ‘[t1]’Couldn't match expected type ‘(Data.Maybe...
01:11:48 <lambdabot>              with actual type ‘[t2]’Couldn't match type ‘[(t0, Data.Maybe.May...
01:11:48 <lambdabot>                with ‘(Data.Maybe.Maybe a4, b)’
01:11:48 <lambdabot>  Expected type: (Data.Maybe.Maybe a4, b) -> Data.Maybe.Maybe a5
01:12:01 <jle`> > let last2 = liftA2 (,) <$> fst <*> snd . foldl (\x (_,y) -> (y,Just x)) (Nothing,Nothing) in (last2 [1,2,3], last2 [1])
01:12:02 <lambdabot>  Couldn't match expected type ‘(Data.Maybe.Maybe a, b0)’
01:12:02 <lambdabot>              with actual type ‘[t1]’Couldn't match expected type ‘(Data.Maybe...
01:12:02 <lambdabot>              with actual type ‘[t2]’Couldn't match type ‘[(t0, Data.Maybe.May...
01:12:02 <lambdabot>                with ‘(Data.Maybe.Maybe a4, b)’
01:12:02 <lambdabot>  Expected type: (Data.Maybe.Maybe a4, b) -> Data.Maybe.Maybe a5
01:14:55 <jle`> > let last2 xs = liftA2 (,) <$> fst <*> snd $ foldl (\(_,x) y -> (x, Just y)) (Nothing,Nothing) xs in (last2 [1,2,3], last2 [1])
01:14:57 <lambdabot>  (Just (2,3),Nothing)
01:15:01 <jle`> ^^ lispy
01:22:20 <jle`> cheated by using a (Maybe a, Maybe b) -> Maybe (a,b) tho
01:23:44 <Fuuzetsu> Is Attoparsec still much faster than Parsec? IIRC it was >5x faster initially but I recall reading that Parsec was later made faster.
01:24:48 <bitemyapp> what's the name of that cabal utility that can test package version ranges?
01:24:57 <bitemyapp> it's a third party tool I think?
01:25:33 <jle`> the one that came up on the reddit last month?
01:51:24 <smiller2> Hey guys, FFI question.  I have a Ptr, and I want to create a ForeignPtr with the finalizer set to a Haskell IO action.  How do I attach an "IO ()" as a finalizer to a ForeignPtr?
01:53:41 <shachaf> What's the confusion?
01:54:24 <Freundlich> smiller2: You need a GHC extension to do this: http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Concurrent.html#v:newForeignPtr
01:54:48 <johnw> smiller2: addForeignPtrFinalizer?
01:55:46 <Freundlich> Normally. you only use FinalizerPtrs which you get from C functions, not arbitrary haskell side-effects.
01:56:19 <smiller2> shachaf, johnw: My confusion was creating a ForeignPtr from a Ptr and IO (), rather than a FunPtr.  "addForeignPtrFinalizer :: FunPtr (Ptr a -> IO ()) -> ForeignPtr a -> IO () "
01:56:21 <Freundlich> smiller2: Btw, are you sure you want to use a finalizer here? Usually it's better not to rely on finalizers at all because they don't work for anything besides memory resources.
01:59:17 <smiller2> Freundlich: THat's fantastic, thanks!  While I've ran into this problem before, in this particular case I have a pointer to an array from Foreign.Marshal.Array.newArray, and importantly I want to attach "free" as a finalizer to a ForeignPtr from this.
02:02:21 <Freundlich> smiller2: Ok, I see.
02:02:22 <therealklanni> Hey guys. I'm learning Haskell by reading Learn You a Haskell and doing the course here: https://github.com/NICTA/course ... can someone explain how to read the comments? There's a ">>>" and "prop>"
02:02:46 <therealklanni> I'm not sure what they represent
02:03:11 <therealklanni> So for instance, in the Courses.List module, lines 60-70
02:03:22 <therealklanni> (from that link above)
02:03:57 <shachaf> therealklanni: There's an explanation in the README you linked to.
02:04:10 <shachaf> "Some exercises include examples and properties, which appear in a comment above the code for that exercise. Examples begin with >>> while properties begin with prop>."
02:05:07 <therealklanni> Right, but what's not clear is what they mean
02:05:26 <therealklanni> headOr 3 (1 :. 2 :. Nil)
02:05:51 <shachaf> A property is presumably something that's always true.
02:06:54 <shachaf> An example is presumably an expression along with what it evaluates to.
02:08:13 <therealklanni> OK, let's start small then, since I'm just starting this (literally an hour ago)... what does "(1 :. 2:. Nil)" mean?
02:08:31 <therealklanni> Is :. and OR or something?
02:08:35 <therealklanni> an*
02:08:50 <shachaf> OK, maybe you should be reading something more introductory that explains Haskell syntax. :-)
02:08:59 <shachaf> I think :. is defined on that page.
02:09:07 <therealklanni> That's why I'm reading Learn You a Haskell
02:09:08 <therealklanni> :)
02:09:08 <shachaf> Though I've already closed it.
02:09:33 <therealklanni> :. is definitely Haskell syntax
02:09:48 <EvanR> @pl (\f -> f x)
02:09:49 <lambdabot> ($ x)
02:09:52 <therealklanni> Unless it's a function
02:09:59 <therealklanni> ?
02:10:02 <shachaf> Let me have a look, since I've already closed that link.
02:10:14 <shachaf> Yes, it's defined in that file.
02:10:30 <merijn> therealklanni: What do you mean by syntax?
02:11:02 <merijn> therealklanni: It's "syntax" in the sense that it correctly parses, but it's just something user-defined
02:11:13 <shachaf> I think you should either already know some Haskell or somehow be able to figure out this kind of thing yourself to get much value from that file.
02:11:27 <shachaf> Otherwise reading something more introductory is a good idea.
02:11:35 <therealklanni> OK, it must be defined in the course modules somewhere then, but I didn't see it explained anywhere
02:11:37 <shachaf> You said you're reading that book -- it probably explains data types.
02:11:56 <shachaf> It's defined on line 33.
02:13:25 <merijn> therealklanni: tbh, I think this course maybe a bit too harsh if you're literally just starting with Haskell. This seems like it'd be good for playing once you're about halfway or two-thirds into Learn You a Haskell
02:14:06 <merijn> Although the use of infix constructors is a bit gratuitously confusing for newbies, too
02:14:28 <therealklanni> So it's a custom list type?
02:14:55 <merijn> therealklanni: yes
02:16:19 <merijn> therealklanni: as for ">>>" and "prop>" >>> seems to be "this is what you type at the interpreter prompt" followed by the expected output and "prop>" describes properties of the function in question
02:16:41 <therealklanni> OK, so from that I can infer that headOr takes the default and the list as its params
02:18:41 <Kaidelong> That's what I'd assume yes
02:19:02 <Kaidelong> it'd kind of analogous to (head .) . (++)
02:19:30 <therealklanni> ok, makes sense
02:20:12 <Kaidelong> > ((head .) . flip (++)) [1] [2,3]
02:20:14 <therealklanni> seems like there could be a better way to describe the function lol
02:20:14 <lambdabot>  2
02:20:19 <Kaidelong> > ((head .) . flip (++)) [1] []
02:20:20 <lambdabot>  1
02:20:24 <shachaf> Kaidelong: Do you really think that's helpful and not confusing?
02:21:14 <Kaidelong> I was more hoping that you would contradict me if the two were not equivalent
02:21:26 <Kaidelong> thus preventing a potential misunderstanding here
02:21:36 <merijn> Kaidelong: The question isn't whether they are wrong, but whether it's helpful
02:21:41 <shachaf> It's needlessly @pl-ed (I know Haskell reasonably well and I have to look twice to figure out what it does) and it doesn't even do the same thing.
02:21:55 <therealklanni> It actualy was helpful
02:22:06 <merijn> fwiw, I don't have a clue what that does
02:22:09 <EvanR> :t flip (++)
02:22:10 <lambdabot> [a] -> [a] -> [a]
02:22:15 <EvanR> >_>
02:22:26 <merijn> On the other hand, I can't be arsed to think about it for more than 2 seconds, but still
02:22:49 <Kaidelong> this style of programming actually comes naturally to me but then again I've used things like FORTH
02:22:59 <EvanR> :t (flip . flip . flip)
02:23:00 <lambdabot> (a -> b -> c) -> b -> a -> c
02:24:08 * hackagebot mangopay 1.5.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.5.1 (JeanPhilippeMoresmau)
02:26:30 <therealklanni> :t flip
02:26:31 <lambdabot> (a -> b -> c) -> b -> a -> c
02:26:36 <therealklanni> :P
02:34:10 * hackagebot modular-arithmetic 1.2.0.0 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.2.0.0 (TikhonJelvis)
02:42:14 <nschoe> Hi haskellers, I need to do a secure key exchange between two clients (like Diffie-Hellman), but I can't seme to find a package to implement DH, can anybody point me to one (in case I missed it) ?
02:42:50 <Kaidelong> http://www.haskell.org/haskellwiki/Applications_and_libraries/Cryptography
02:42:59 <Kaidelong> there's an RSA package, if you're okay with that instead of DH
02:43:03 <Kaidelong> RSA and DH serve the same end
02:43:35 <Lethalman> openssl should have a DH implementation
02:43:38 <Kaidelong> bit surprised to see that there is no elliptic-curve diffie-helman backage
02:43:51 <nschoe> Kaidelong, ho thanks. Well I'm not a crypto specialist so I don't know. Is RSA as secure  as DH / (Just for curiosity)
02:44:13 <shachaf> Kaidelong: ?
02:44:14 <merijn> wait what
02:44:25 <merijn> Kaidelong: RSA is completely different from DH
02:44:26 <nschoe> Lethalman, yes I think it has, but I could not find a way to "just use that" and not the whole openssl handsahe / etc protocol
02:44:41 <Kaidelong> merijn: it's an assymetric cipher used for key exchange
02:44:55 <merijn> nschoe: Might wanna check out thoughtpolice's NaCl/libsodium forcrypto
02:45:19 <nschoe> merijn, oh ? Okay thanks I'll check this out, then.
02:45:24 <merijn> Kaidelong: RSA is used for authentication and secure exchange of symmetric keys, DH is for establishing a secure in the absence of preconfigured authentication
02:45:43 <merijn> Kaidelong: You can't use RSA to establish a secure channel unless you already have someone's public key
02:46:05 <Kaidelong> yes but diffie helman has that same limitation doesn't it?
02:46:12 <merijn> No
02:46:23 <nschoe> merijn, so if I start with a non-secure, classic TCP connection, I should not use RSA, but DH, riight ?
02:46:26 <merijn> If you don't care about authentication you can use DH to establish a secure channel with no trouble
02:46:37 <merijn> nschoe: It depends on whether you care who you are talking too
02:47:03 <merijn> nschoe: DH won't let you do authentication, but then again there is no way to do authentication without an external trusted channel
02:47:27 <nschoe> merijn, so to have authentification, I must have athird-party, right ?
02:47:40 <merijn> nschoe: Not necessarily a third-party, but a trusted channel
02:47:56 <Kaidelong> merijn: doesn't this actually mean RSA can strictly do more than DH because it can also do signing?
02:48:02 <shachaf> This is sounding like a ##crypto discussion.
02:48:18 <nschoe> merijn, okay thanks.
02:48:26 <Kaidelong> I guess the advantage is not having the client needing to generate a key
02:48:34 <merijn> Kaidelong: RSA is a crypto cypher, it's ability to authenticate/sign follow from it's encryption. DH is a key generation algorithm
02:49:02 <merijn> Kaidelong: They're completely different things so comparing them is like comparing pancakes and apples, sure they're both food, but that's where the similarity ends
02:49:28 <shachaf> There are very few questions to which both RSA and DH are reasonable answers.
02:49:43 <nschoe> merijn, so once I have exchanged keys with DH, I can use that key to encrypt with whatever algo I want, right ?
02:49:50 <merijn> shachaf: "two to three letter acronyms related to crypto!"
02:50:02 <merijn> nschoe: Right, although you won't be sure who you are talking to
02:51:07 <nschoe> merijn, yes okay. But what possibilities do I have to perform auth ? I can't have an already secure connexioon because that's what I'm trying to build in a sense
02:51:41 <Kaidelong> I wrote a DH implementation but never tried using it for anything. Shows how well that works.
02:51:57 <shachaf> You should ask in ##crypto.
02:52:24 <merijn> nschoe: I second shachaf's remark, this is not very haskell related anymore, and I should be productive instead of IRCing >.>
02:52:30 <Kaidelong> well I think he is looking for a haskell package that provides it
02:52:40 <Kaidelong> I think yesod has packages relating to user accounts?
02:52:58 <shachaf> merijn: Well, not just that it's off-topic in #haskell but also that you might get all sorts of terrible advice in here.
02:53:12 <nschoe> Kaidelong, yes indeed. But again : I thikn I should ask on ##crypto because I should have an idea of what I'm trying to do before looking for a Haskell implementation ^^
02:53:22 <Kaidelong> fair enough
02:53:24 <shachaf> Anyway, this isn't a thing to design off-the-cuff. Whatever you write will almost certainly be broken in all sorts of ways. That's how cryptorgaphy usually works.
02:53:26 <nschoe> Thanks for yoru answers and your reactivity all, this is appreciatetd :-)
02:53:32 <jle`> can you turn a Maybe into a something isomorphic to []
02:54:02 <nschoe> shachaf, well that's... not very encouragin, is it ?^^
02:54:13 <startling> jle`: sure, []
02:54:30 <startling> jle`: I don't think that's what you mean but I don't know what else to say.
02:54:32 <jle`> that is, could you represent a possibly nonterminating linked list using Just and Nothing
02:54:45 <shachaf> nschoe: Nope. But it's how it works.
02:55:01 <jle`> you could use Maybe as a list that can have at most three values, if you did something like Maybe (a, Maybe (a, Maybe a))
02:55:03 <startling> jle`, ah, not really
02:55:03 <shachaf> nschoe: It's very easy to do cryptography wrong in a way that is indistinguishable to you from having done it right.
02:55:15 <nschoe> shachaf, no I know that, but you almost make it look like this was no use for me to continue further dev of my app ^^
02:55:19 <startling> jle`: the problem is that Maybe doesn't really let you 'hang a value' on it
02:55:30 <jle`> in a way it might be a way to encode a maximum-length list in the type system
02:55:50 <Kaidelong> that's neat actually
02:55:53 <startling> jle`: you could do newtype Whatever a = Whatever (a, Maybe (Whatever a)) but that's just cons
02:55:56 <startling> ish
02:56:01 <startling> jle`: oh, you want Either
02:56:07 <Kaidelong> however why not just use length-typed vectors?
02:56:31 <jle`> length typed vectors are fixed length, right? this would be 'up to' that length
02:56:37 <shachaf> nschoe: Well, it's worth finding out whether what you want to do is possible, and how such things are generally designed.
02:56:44 <Kaidelong> so long as you don't care about how many elements is in it, you could have the length be some undefined type for infinite lists
02:56:50 <startling> jle`, type family Whatever Z = Const () -- I guess?
02:56:55 <Kaidelong> kind of like non-strictness at the value level
02:57:01 <shachaf> Maybe you can find a high-level library that does what you want.
02:57:08 <startling> jle`: type family Whatever (S n) a = Either a (Whatever n a) -- oops, forgot the type parameter
02:57:17 <shachaf> But the point is to be careful.
02:57:23 <startling> :t Const
02:57:24 <lambdabot> a -> Const a b
02:57:37 <startling> is there a name for Const () ?
02:57:38 <Kaidelong> although I guess you'd need to find a value that will still allow you to write things like "zip"
02:57:42 <shachaf> startling: Proxy
02:57:44 <jle`> that does sound like a cleaner way
02:57:45 <startling> Proxy, ah
02:57:53 <shachaf> startling What's that type family supposed to be doing?
02:58:01 <shachaf> s/g/g:/
02:58:06 <startling> shachaf: I don't know, I'm probably spelling it wrong
02:58:09 * startling looks up the thing
02:58:30 <nschoe> shachaf, yes, ok. Well thanks. I'll head to ##crypto to ask, and then I'll look for a Haskell package that does that (I'm well aware that implementing crypto on his own is generally a bad idea)
02:59:05 <shachaf> startling: Whatever n a = (Fin n, Maybe a) or something along those lines?
02:59:20 <startling> oh, right, that's not type-level lists
02:59:27 <startling> *length-typed
02:59:29 * startling sleepy
03:00:34 <merijn> shachaf: To be fair, I'm not sure whether I'd trust ##crypto or any other IRC channel with crypto advice >.>
03:01:02 <shachaf> merijn: Fair enough. But it's probably better on average than #haskell for that.
03:01:20 <nschoe> merijn, how ? WHy is that ?
03:01:22 <startling> type family Whatever (n :: Nat) a where Whatever Z a = (); Whatever (S n) a = (a, Maybe (Whatever n a)) -- I think?
03:01:59 <shachaf> What's the goal here?
03:02:22 <startling> :<
03:03:06 <jle`> :<
03:04:23 <startling> is this part of the crypto thing? I just /join'd
03:04:32 <startling> Sorry for spouting things.
03:04:42 <shachaf> ?
03:05:13 <startling> ay,ay
03:58:02 <pavonia> Is there a way to change the TeXtEncoding for writeFile?
04:00:00 <bjorkintosh> what's a good tool for properly indenting .hs in emacs?
04:02:08 <rindolf> Hi all. How should I declare CompiledSeg here - http://pastie.org/9136287 ?
04:03:11 <jesyspa> Line 43 looks like it's missing some parentheses.
04:04:52 <rindolf> jesyspa: where?
04:05:16 <jesyspa> Type_X_Only_Seg x1 y_s!!0 y_s!!1 looks like it should be Type_X_Only_Seg x1 (y_s!!0) (y_s!!1)
04:05:26 <jesyspa> Otherwise you're applying 0 to y_s.
04:07:08 <rindolf> jesyspa: http://pastie.org/9136295 ==> this still gives me the type error.
04:07:46 <jesyspa> Also, Type_X_Only_Seg is now a constructor of both Type_X_Only_Seg and CompiledSeg.  Did you mean to give CompiledSeg differently-named constructors that would take a Type_X_Only_Seg and Type_XY_Seg respectively?
04:08:26 <rindolf> jesyspa: http://ideone.com/2UVNpE
04:08:30 <jesyspa> (Hm, actually, it looks to me like you could just drop the Type_X_Only_Seg and Type_XY_Seg types entirely, the way you're using it.)
04:09:16 <jesyspa> Yeah, that's what I'm saying.  On line 25, you say Type_X_Only_Seg is of type Int64 -> Int64 -> Int64 -> Type_X_Only_Seg, but on line 38 you're saying it has type Int64 -> Int64 -> Int64 -> CompiledSeg.
04:09:32 <jesyspa> You can just rename CompiledSeg's constructors.
04:09:52 <rindolf> jesyspa: I Want CompiledSeg to be either Type_X_Only_Seg *or* Type_XY_Seg
04:10:27 <jesyspa> Then you should give it two constructors, one taking each.
04:10:35 <rindolf> jesyspa: ah.
04:10:43 <rindolf> jesyspa: how?
04:10:55 <jesyspa> data CompiledSeg = Some_Constructor Type_X_Only_Seg | Some_Other_Constructor Type_XY_Seg
04:11:25 <jesyspa> The Int64s and Fracs are all already specified by the Type_X_Only_Seg and Type_XY_Seg.
04:15:37 <rindolf> jesyspa: thanks, working now.
04:37:37 <Trotor> Hi, guys can you help me with some problem? I need to read (getLine) some string, for example 1 2 3 4 5, and convert it into list of int [1,2,3,4,5] then send the list into function:  game :: [Integer] -> [Char] I'm trying to do this almost 6h :-\
04:38:00 <srhb> Trotor: first, use words to split the string into a string containing each number
04:38:09 <pranz> :t words
04:38:10 <lambdabot> String -> [String]
04:38:12 <pranz> ^
04:38:18 <srhb> :t read
04:38:19 <lambdabot> Read a => String -> a
04:39:53 <srhb> :t fmap (map read . words) getLine -- something like this
04:39:54 <lambdabot> Read b => IO [b]
04:40:02 <srhb> Which can then be an IO [Integer]
04:40:39 <srhb> or even fmap (game . map read . words) getLine
04:40:54 <srhb> Which will Produce an IO [Char]
04:41:04 <srhb> Trotor: Hope that helps
04:42:06 <Trotor> thanks, i was tying map read $ words a :: [Integer]  but i cant use the IO Int in my other function
04:43:25 <srhb> Trotor: That would work if you had something like do { a <- getLine; let b = map read $ words a; return $ game b }
04:46:20 <quchen> Don't use `read`. https://github.com/quchen/articles/blob/master/fbut.md#dont-use-
04:46:26 <quchen> Use readMaybe.
04:47:42 <srhb> (Difference being that read will fail horribly if it can't parse the expected type, while readMaybe forces you to do error handling)
04:48:09 <quchen> > read "hello" :: Int
04:48:11 <lambdabot>  *Exception: Prelude.read: no parse
04:48:21 <quchen> > readMaybe "hello" :: MaybeInt
04:48:23 <lambdabot>  Not in scope: type constructor or class ‘MaybeInt’Not in scope: ‘readMaybe’
04:48:23 <quchen> > readMaybe "hello" :: Maybe Int
04:48:24 <lambdabot>  Not in scope: ‘readMaybe’
04:48:36 <quchen> ಠ_ಠ
04:49:10 <quchen> Anyway, it's in Text.Read
04:59:37 * hackagebot cabal-install 1.20.0.1 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.1 (JohanTibell)
05:02:47 <merijn> > Text.Read.readMaybe "hello" :: Maybe Int
05:02:48 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
05:02:51 <merijn> aww
05:03:01 <merijn> I thought that was imported in the past
05:03:09 <srhb> Think it was at some point.
05:06:49 <jophish> Yo yo yo
05:06:53 <jophish> I'm using Text.PrettyPrint.HughesPJ
05:07:08 <jophish> I was surprised to find that Doc isn't in Monoid, with <> and empty
05:07:45 <jophish> HughesPJ redefines <> and empty, and they respect the monoid laws as far as I can tell
05:08:00 <jophish> Does anyone know the reasoning behind this?
05:09:28 <jophish> I suppose that $$ could also be mappend
05:12:58 <jophish> oh, it is in Monoid. silly me
05:15:41 <awestroke> I'm making a haskell web app, and I currently use node.js (with less and coffee-script packages) to compile my assets. anyone know of another way (or even a haskell package) to compile css and js assets and eliminate my dependency on node.js?
05:18:17 <Lethalman> awestroke, you may compile haskell to css with clay, and haskell to js with ghcjs (there are several)
05:26:42 <freeman42> roflmao https://gist.github.com/quchen/5280339
05:26:52 <freeman42> from https://news.ycombinator.com/item?id=7689402
05:31:13 <vanila> https://gist.github.com/shangaslammi/3438688
05:31:24 <vanila> :O
05:31:56 <vanila> hello world in s,k combinators
05:35:38 <spockshock> lol, haskell selling to Jehova's witnesses
05:36:09 <freeman42> yeah that was a good one :D
05:36:17 <vanila> " I keep hearing over and over about how great Haskell is, and yet nobody can ever show me anything written in it other than yet another compiler." <-- what are the simplest haskell compilers written in haskell?
05:37:14 <freeman42> joke about lisp ^^ http://stackoverflow.com/a/235790/750216
05:38:07 <spockshock> we have  mormons here, maybe its time to walk around with a tie and slick backed hair, lyah in hand as my bible
05:38:26 <spockshock> god is a monad!!
05:39:42 * hackagebot Omega 1.0.3 - Integer sets and relations using Presburger arithmetic  http://hackage.haskell.org/package/Omega-1.0.3 (ChristopherRodrigues)
05:41:44 * freeman42 is thinking about rereading the holy book LYAH. (maybe more of Haskell's holy word will sink in)
05:42:47 <awestroke> any way to analyze imports in haskell other than removing each import, compiling and comparing the number of unique missing symbols to the list of imported symbols from the just-removed package?
05:43:28 <awestroke> It probably doesn't matter if unused imports are shaved off the binary anyway, but it would feel neato to only import what's used
05:46:52 <freeman42> hmm, haskell source tree shaking doesn't seem to return anything on first page of some very used search engine
05:49:12 <mornfall> awestroke: scion doesn't know how to do that?
05:49:43 * hackagebot highlight-versions 0.1.3.4 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3.4 (BrentYorgey)
05:50:10 <mornfall> hmm, scion doesn't seem to be particularly alive...
05:51:01 <mornfall> ghc-mod maybe?
05:51:53 <awestroke> -Wall seems to complain about unused (or "redundant") imports
05:51:57 <awestroke> problem solved
05:52:08 <mornfall> awestroke: not really, but if you think :-)))
05:52:39 <mornfall> (translating the warnings into edit actions is a massive waste of time, believe me :)
05:53:05 <awestroke> Yeah, an automated solution would be wonderful
05:53:25 <awestroke> but this is at least easier than manually toggling each import and checking for compile errors
05:54:12 <mornfall> awestroke: I also think it won't warn you about imports without a symbol list...
05:54:39 <mornfall> https://twitter.com/etrepum/status/456904570758004736 :D
06:06:26 <danilo2> Hello :) Is there any method in ghc (or other dev tools) to check why an particular instance was not matched when compiling the code? I'm getting error "No instance for ...", but I think the instance exist and I want to know why it was not matched.
06:07:03 <manuel__> do you guys have haskell day jobs?
06:08:03 <ion> Perhaps you didn't import the module which provides the instance.
06:08:40 <zomg> manuel__: there are at least a few here who have, and I've been meaning to apply for one but haven't yet =)
06:08:46 <danilo2> ion: I imported it, but the instance is a little complicated, so maybe it is not matched - I would love to see why
06:09:50 <danilo2> manuel__: I've got one and in the company I'm working there are at last 5 other haskellers
06:16:22 <rindolf> Hi all. The following Haskell program runs out of stack after about a minute (while consuming a lot of RAM): https://bitbucket.org/shlomif/project-euler/src/59c1a1510b3b4bd35c9eaf05314a4600cb7797a3/project-euler/165/euler_165.hs?at=default ; The equivalent Perl 5 program (which I wrote before hand), consumes much less RAM and eventually emits the currect result. Is there anything I can do to fix it?
06:16:35 <rindolf> The Perl 5 program and its modules are in the same directory there.
06:18:45 <awestroke> rindolf: how do you run them?
06:19:04 <rindolf> awestroke: I did ghc -O2 euler_165.hs and then ./euler_165
06:19:12 <no-n> > ord '!'
06:19:13 <lambdabot>  33
06:19:22 <rindolf> awestroke: and for the perl program I use perl euler_165.pl.
06:20:34 <rindolf> awestroke: actually, I did ghc -O3
06:21:28 <danilo2> I'm sorry for repeating the question, but maybe somebody will notice it now - Is there any method in ghc (or other dev tools) to check why an particular instance was not matched when compiling the code? I'm getting error "No instance for ...", but I think the instance exist and I want to know why it was not matched.
06:21:47 <rindolf> awestroke: I have 8 GB of RAM.
06:21:59 <rindolf> awestroke: it's an x86-64 Core i3 machine.
06:22:15 <benmachine> danilo2: there is a method called "post it on lpaste.net and ask #haskell" :)
06:22:31 <benmachine> danilo2: I'm not aware of anything automated
06:22:56 <ion> I wonder if ghc -O5 would help?
06:23:10 <ion> (just joking)
06:23:16 <Philonous> I think it's more promising to fervently claim the opposite on /r/haskell or HN and wait until someone corrects you.
06:23:29 <awestroke> rindolf: RAM won't matter if you run out of stack space. each process has a stack space limit, and the only thing using stack space is the build-up of function calls in your program
06:23:43 <freeman42> awestroke, hmmm, maybe this helps "The modules analysis is done using SourceGraph. Get it executing cabal install SourceGraph. Note that you'll need to have dot installed for the graphs to be generated. You can download dot from http://graphviz.org/."
06:24:23 <awestroke> or call chain or whatever it's called
06:26:42 <awestroke> rindolf: I don't think there's a guide on how to investigate the lazy evaluation of a haskell program, but I'd try playing around with $! and seq
06:29:25 <rindolf> awestroke: what is $! and seq?
06:30:22 <awestroke> $! is strict function application, it fully evaluates the argument before applying the function
06:30:31 <awestroke> do you know about thunks and laziness?
06:31:14 <rindolf> awestroke: I know about laziness.
06:32:49 <v-husobh> what's the neat and efficient way to convert a rational to an Int or Integer? besides (fromInteger . toInteger)
06:35:29 <awestroke> rindolf: hmpf. Can't come up with a good explanation. But what I'm trying to say is that by fully evaluating some things, you can avoid some stack overflows
06:36:05 <Cale> I kind of wish that people would just talk about expressions (at runtime) rather than thunks, in much the same way as I wish they'd talk about functions rather than closures.
06:36:33 <awestroke> or, if you're only mortal, you can use something like conduits
06:36:35 <Cale> Thunks are an implementation mechanism for the runtime representation of expression graphs.
06:37:02 <Cale> I've never understood the idea that conduits would be easier for beginners to understand in any way.
06:37:33 <awestroke> Cale: a pipeline of functions is very easy to understand and requires no runtime tracing and debugging to construct
06:39:06 <darthdeus> guys does anyone have a good intro to acid-state and/or template haskell? i've looked at the docs but it seems rather complicated even in the simplest examples
06:39:10 <Cale> All the iteratee/conduit/pipes stuff seems frustratingly complicated to me, and I've been programming in Haskell for a dozen or so years. I understand that libraries like that have their use cases, but I dunno, they wouldn't be my first choice for introducing to beginners.
06:39:21 <darthdeus> i mean i can see how to use it but i dont understand how it works
06:39:52 <Cale> darthdeus: Those are two completely separate and pretty much unrelated things...
06:40:22 <benmachine> darthdeus: template haskell is legitimately complicated, so you needn't feel bad about not understanding it
06:40:24 <darthdeus> Cale: yeah, but acid-state uses template haskell in a weird way I haven't seen yet
06:40:53 <darthdeus> my only TH exposure so far was something like tests = $quickCheckAll
06:41:18 <darthdeus> should I just ignore it then and use the API as it is?
06:41:24 <Cale> Are you talking about makeAcidic?
06:41:35 <darthdeus> deriveSafeCopy and makeAcidic, yes
06:41:41 <benmachine> darthdeus: https://github.com/bmillwood/dice/blob/master/src/Dice.hs I wrote a program that used TH and acid-state a while ago
06:41:46 <benmachine> it may or may not be useful to you
06:42:03 <benmachine> it... predates lens, apparently
06:42:07 <benmachine> uses data-lens
06:42:08 <benmachine> weird
06:42:10 <darthdeus> hmm
06:42:15 <darthdeus> I'll take a look, thanks
06:43:21 <m09> > pl   fs <*> xs = flatMap ($ xs) (map map fs)
06:43:22 <lambdabot>  <hint>:1:16: parse error on input ‘=’
06:43:52 <m09> > pl   (\fs xs -> flatMap ($ xs) (map map fs))
06:43:53 <lambdabot>  Not in scope: ‘pl’
06:43:53 <lambdabot>  Perhaps you meant one of these:
06:43:53 <lambdabot>    ‘pi’ (imported from Prelude),
06:43:53 <lambdabot>    ‘p’ (imported from Debug.SimpleReflect),
06:43:53 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect)Not in scope: ‘flatMap’
06:44:02 <m09> bouarf
06:45:12 <wting> I'm trying to install cabal from source and followed the README instructions. However all I get are libraries and no binary after the `./Setup install` step.
06:51:57 <wting> For what it's worth, here are the commands and resulting files in .cabal: http://pastebin.com/FucR7XDu
06:52:08 <danilo2> benmachine: heh, that is not going to work, it is **really** complicated code. Do you think anything automated is possible to be created? Will it be usefull for others?
06:58:56 <bddy> Hi. Is it possible to avoid \z in this lambda? \z -> func $ f el z   I want something like "func $ f el" but that doesn't work
06:59:26 <hpc> func . f el
06:59:32 <DogeHayashi> ^
06:59:51 <hpc> you'll find that instead of doing func $ f el z -- or similar things
07:00:09 <hpc> you will have better luck writing things like func . f el $ z
07:00:24 <hpc> it's syntactically nicer for refactoring
07:00:33 <Forgetaboutit> :pf \z -> func $ f el z
07:00:59 <Forgetaboutit> :pl \z -> func $ f el z
07:01:05 <Forgetaboutit> pl \z -> func $ f el z
07:01:23 <Forgetaboutit> Hm, how was that supposed to work?
07:01:39 <bddy> > :pf \z -> func $ f el z
07:01:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:03:07 <mangaba_leitosa> @pl \z -> func $ f el z
07:03:07 <lambdabot> func . f el
07:03:09 <FreeFull> @pl \z -> func $ f el z
07:03:10 <lambdabot> func . f el
07:03:21 <Forgetaboutit> mangaba_leitosa: Ah, thank you!
07:08:02 <awestroke> @pl  fs <*> xs = flatMap ($ xs) (map map fs)
07:08:02 <lambdabot> (line 1, column 12):
07:08:02 <lambdabot> unexpected " "
07:13:42 <bddy> @pl (\a -> \b -> (^2) $ (+) a b) 4 5
07:13:42 <lambdabot> 81
07:13:47 <bddy> @pl (\a -> \b -> (^2) $ (+) a b)
07:13:47 <lambdabot> ((^ 2) .) . (+)
07:18:57 <c_wraith> bddy: \a -> b ->   is the same as \a b ->
07:19:07 <c_wraith> err.  \b in the first case
07:19:51 <bddy> ah, thanks. trying to get what lambdabot said.
07:20:05 <darthdeus> i guess i'll just stick to redis for now :\ reading safecopy docs and it's just ... confusing
07:20:28 <c_wraith> bddy: I wouldn't worry about it.  pointles form is called that for a reason.  :)
07:20:44 <Maior> haha
07:20:56 <manuel__> danilo2: what are you working on? (if you can speak about it)
07:22:10 <manuel__> brb need to switch office
07:24:30 <drupzky> Since it is possible to fold a List in a way, to get the exact same list back (or reversed, depending on direction) I am wondering whether it is possible to define a fold for      data RoseTree a = RoseTree a [RoseTree] , so that i can fold over a RoseTree in a way, to get exactly the same RoseTree back?! I'm really struggeling to find a fold implementation that can do that. Please help (if it's possible at all)
07:25:37 <FreeFull> drupzky: Think about the type signature
07:27:11 <drupzky> yes, it would have to be (RoseTree a -> RoseTree b-> RoseTree a) -> RoseTree a -> RoseTree b -> RoseTree a (thinking in foldl)
07:27:24 <FreeFull> drupzky: It should be such that   foldTree RoseTree == id
07:28:08 <drupzky> FreeFull: yes, and I think more and more, that that's not possible :(
07:28:32 <FreeFull> drupzky: The natural fold for a list is foldr, not foldl
07:28:47 <FreeFull> And all those rosetrees in the type signature definitely don't belong
07:29:35 <drupzky> FreeFull: okay, but still: is it possible in the first place?
07:30:17 <FreeFull> Sure
07:30:26 <drupzky> hmm
07:30:28 <FreeFull> Although your type singnature is wrong
07:31:32 <FreeFull> I'm thinking the type signature should be something like    foldTree :: (a -> [RoseTree a] -> b -> b) -> RoseTree a -> b
07:32:02 <drupzky> ohh, that's a good idea
07:32:13 <drupzky> give me some time, I'll think abot it :)
07:34:30 <FreeFull> drupzky: Actually, I'm not sure a foldTree with that type signature would be useful
07:35:11 <drupzky> FreeFull: yes we need some kind of starter accumulator
07:35:36 <drupzky> FreeFull: at least something like foldTree :: (a -> [RoseTree a] -> b -> b) ->b ->  RoseTree a -> b
07:36:20 <drupzky> FreeFull: but even then, I'm heaving trouble coming up with a solution.... :(
07:36:21 <FreeFull> drupzky: The "starter" isn't needed because RoseTree always contains at least one value
07:36:35 <drupzky> FreeFull: ohh yes, you are right
07:36:36 <FreeFull> The problem is that the function is getting a [RoseTree a]
07:37:03 <danilo2> manuel__: Of course you can, We are working on an image processing tool - Flowbox, see: www.flowbox.io/overview
07:37:12 <FreeFull> Maybe it should be getting an [a] instead
07:37:24 <vanila> foldRoseTree r (RoseTree x l) = r x (map (foldRoseTree r) l)
07:37:27 <manuel__> sweet!
07:37:42 <drupzky> FreeFull: but then you loose the structure of the tree
07:37:56 <danilo2> Right now the team is much bigger than presented on hte website and most of the technology is written in Haskell :)
07:38:05 * c_wraith looses the RoseTree terror upon the world
07:38:23 <drupzky> vanila: Thanks, I'll think about it
07:38:43 <FreeFull> drupzky: The fold would be depth-first
07:39:04 <FreeFull> I'm not sure, it's difficult to come up with something reasonable
07:39:37 <c_wraith> Man, I missed the middle of this conversation.  What's the current goal?
07:39:52 <vanila> you can implement many RoseTree algorithms using this fold
07:39:55 <drupzky> I mean this one is easy, but it can only reduce to values, but destroys the structure
07:40:01 <drupzky> foldRT :: (b -> a -> b) -> b -> RTree a -> b
07:40:02 <lostInTypes> I am trying to enforce some constraint inside a type, I need some kind of list where I have exactly one Up constructor and one Down constructor used inside the list, but I cannot use it with functions via pattern matching: http://pastebin.com/p27N9Sa8
07:40:07 <drupzky> foldRT f acc (Node a []) = f acc a
07:40:12 <drupzky> foldRT f acc (Node a ((Node b xs):ys)) = foldRT f (f acc a) (Node b (xs ++ ys))
07:40:20 <drupzky> no more structure in this one.... :(
07:40:30 <c_wraith> drupzky: has anyone pointed out the fully generic fold to you yet/
07:40:43 <alpounet> lostInTypes: I suppose there are other constructors than Up/Down?
07:40:59 <drupzky> no, not in a way, that i can fold in such a way, that i get the identity function
07:41:13 <lostInTypes> alpounet: yes, check the pastebin link
07:41:20 <c_wraith> drupzky:  (a -> [r] -> r) -> RoseTree a -> r
07:42:04 <drupzky> c_wraith: I'll think abotu it, sec please (I'm not that good yet ;) )
07:43:27 <vanila> drupzky, There is exactly one fold for each data type - there's no choice
07:44:07 <vanila> drupzky, A good way to approach this would be derive the fold for simpler data types and lead up to RoseTree - it's contains a difficult new idea
07:44:22 <c_wraith> indeed.  That type came directly from the definition of RoseTree.  I didn't actually think in the process.
07:44:29 <drupzky> vanila: okay, I'm trying to write the function with the type c_wraith suggested, But I'm not that fast yet ;)
07:44:42 <Maerten> Hi, i have a beginner question: If I have a UTCTime of e.g. 2014-05-03 16:40:12, what would be the easiest way to modify this UTCTime, and 'round down' to the nearest full hour (2014-05-03 16:00:00), or 'round down' to the beginning of the month+midnight (2014-05-01 00:00:00)? in PHP (excuse me) it's easy to do stuff like $datetime->modify('beginning of this month')->setTime(0,0,0); .. Any suggestions would be really appreciated!
07:45:17 <drupzky> vanila: then this is a very good exercise for me :)
07:45:57 <vanila> yes but do you know how to do it for the simpler types?
07:46:13 <c_wraith> vanila: I think I didn't really understand until I worked through the church encoding for Free.  Then lots of stuff suddenly made sense.
07:46:28 <drupzky> vanila: hmm I don't know, I know how to do it for lists...
07:46:58 <c_wraith> drupzky: how about a non-recursive type?  What's the fold for Either look like?
07:46:59 <vanila> drupzky, well maybe do  data T a = L a | B (T a) (T a)  first
07:47:08 <drupzky> vanila: I guess I do not know the simple mechanism you guys are talking about
07:47:17 <drupzky> vanila: okay, I'll do taht
07:47:20 <vanila> difficulty ranking:   Maybe, Either, List, T, RoseTree
07:47:41 <drupzky> vanila: okay, thank you :))
07:47:43 <c_wraith> vanila: ++ ", Free" :)
07:47:50 <vanila> oh c_wraith is that at the end?
07:48:18 <vanila> is Free just RoseTree with an arbitrary functor rather than []?
07:48:28 <c_wraith> no, that's CoFree
07:48:33 <c_wraith> err, Cofree
07:48:35 <vanila> okay could you show me the definition please :)
07:48:55 <c_wraith> data Free f a = Pure a | Free (f (Free f a))
07:49:05 <vanila> oh yeah
07:49:18 <vanila> and things get really insane when your data type is recursive but the parameter grows
07:49:56 * hackagebot snap-web-routes 0.1.0.0 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.1.0.0 (lukerandall)
07:50:53 <lostInTypes> I am trying to enforce some constraint inside a type, I need some kind of list where I have exactly one Up constructor and one Down constructor used inside the list, but I cannot use it with functions via pattern matching: http://pastebin.com/p27N9Sa8
07:51:06 <lostInTypes> Anyone can help?
07:51:16 <drupzky> thank you both vanila c_wraith now I have something to do :D
07:51:27 <zomg> Is there some variation of `groupBy` which just drops the non-matching groups altogether?
07:51:41 <zomg> Suppose I could just filter the results
07:54:25 <drupzky> vanila: is that thr right type for foldMaybe     foldMaybe :: (a -> b) -> Maybe a -> b?
07:54:32 <geekosaur> non-matching groups? either you don't actually mean groupBy or you want filter
07:55:08 <vanila> drupzky,
07:55:14 <vanila> data Maybe a = Nothing | Just a
07:55:15 <zomg> geekosaur: well it's kinda both :) Say I have [1,1,2,2,1], what I want is [[1,1], [1]]
07:55:19 <drupzky> vanila: it could also be foldMaybe :: (a -> b) -> Maybe a -> Maybe b?
07:55:19 <vanila> therefore
07:55:42 <zomg> geekosaur: I actually wrote it in terms of foldl already but was looking to see if there was some way to simplify the code
07:55:45 <vanila> foldMaybe :: "<nothing>" -> "<just>" -> Maybe a -> b
07:55:55 <vanila> foldMaybe :: b -> (a -> b) -> Maybe a -> b
07:56:12 <vanila> if you see what I mean?
07:56:38 <vanila> (a -> b) -> Maybe a -> Maybe b    is the fmap function
07:57:14 <drupzky> yes I think I see
07:57:41 <vanila> similarly
07:57:42 <ocharles> Can anyone see how to construct a proof `(t : Init ts1) :~: Init (t : ts1)`? I'm working with type level lists. Init is a type family given as:
07:57:42 <geekosaur> groupBy doesn't really grok "non-matching" except insofar as it defines a new group, but you want groups. so you'd do a separate filter
07:57:46 <ocharles> https://www.irccloud.com/pastebin/padYaiHD
07:57:48 <vanila> data Either a b = Left a | Right b
07:57:49 <vanila> foldMaybe :: "left" -> "right" -> Either a b -> c
07:57:59 <drupzky> for every Typeconstructer, there has to be something to do, to get to the resulting type b
07:58:03 <vanila> foldMaybe :: (a -> c) -> (b -> c) -> Either a b -> c
07:58:05 <vanila> oops
07:58:09 <vanila> foldEither**
07:58:11 <drupzky> and for nothing, i can only have a default value
07:58:12 <zomg> geekosaur: yeah, looks like doing `filter (f . head) $ groupBy (\a b -> f a && f b)` does the job and it's certainly easier to read than the fold :)
07:58:12 <drupzky> yes
07:58:12 <ocharles> Do I need to bring a singleton of that list into scope, and then pattern match on it?
07:58:14 <drupzky> it makes sense
07:58:24 <spockshock> Maerten: what do you think about the Data.time?
07:58:32 <vanila> drupzky, that's exactly right - so when you go to implement it, you know exactly what to do for each constructor you pattern match against
07:58:51 <drupzky> vanila:  okay, I think I got the principle, I think you BIG TIME :)
07:59:19 <vanila> im glad!
07:59:28 <drupzky> vanila: :)
07:59:32 <geekosaur> I could imagine a variant which used a Maybe Bool and dropped the Nothing-s, but I don't think that would be either a code optimization *or* much more readable
08:00:09 <zomg> yeah
08:00:31 <geekosaur> and the type doesn't really describe the action
08:00:46 <zomg> actually it should be == instead of && so it doesn't throw in extra groups for no reason but either works for my use case anyway
08:00:58 <danilo2> Hello! I've got a question connected to how ghc optimizes the code. Is there any performance difference in the resulting binary between 1) code with functions with multiple arguments and 2) code with functions with arguments always packed as tuples of tuples => ex. f a b = ... and f (a,(b,())) = ... .  Or such code will be optimied the same way ALWAYS ?
08:10:35 <c_wraith> danilo2: the code won't be identical.  The version that takes a tuple will need to be able to match the tuple constructor at runtime
08:10:59 <c_wraith> danilo2: in some cases it might be able to optimize that check out, but there are always cases where it can't
08:12:25 <Maerten> spockshock: i don't see any way to do what i want to do with Data.time.. but i'm a beginner
08:12:36 <danilo2> c_wraith: Ok. In such case - can I do anything to just make the code with functions using "tupled arguments" run as fast as the second one? The code will be generated, so I'm sure, the matching will always succeed
08:16:18 <c_wraith> danilo2: First, the function will definitely need to be inlined at the call site. This also requires a definition simple enough thatt GHC will inline it. (non-recursive, etc).  The best way to guarantee this is to move all the actual logic into a where clause.
08:17:31 <c_wraith> danilo2: second, the argument tuple must be created as late as possible, and used only to call the single function
08:17:52 <c_wraith> danilo2: when combined with inlining, that *should* be enough for GHC to see that it can optimize out the creation of the tuple
08:21:16 <darthdeus> can I somehow tell ghci to not show the fully qualified type when doing :t ? such as IO hedis-0.6.5:Database.Redis.Core.Connection, but at least without the package name?
08:21:50 <c_wraith> darthdeus: you have to have a module that exports the type in scope
08:22:50 <c_wraith> danilo2: oh, as a note on the first part.  Move all the logic *except* pattern matching on the tuple into a where clause.
08:24:05 <danilo2> c_wraith: Ok, thank you for those informations. And what happens if the tuples are matched against typeclass instances? I mean, I've got "instance Test (a,(b,(c,()))) c where test (a,(b,(c,()))) = real_function a b c" - will something like that be optimized this way? (the Test class is something like: class Test args result | args -> result where test :: args -> result)
08:25:16 <c_wraith> danilo2: if you are compiling in multiple modules, make liberal use of the INLINEABLE pragma.  If you're in a single module, that shouldn't be necessary.
08:26:11 <danilo2> c_wraith: that would be in multiple modules. I understand, that in case of typeclasses, when cpombined with inline pragma, such code should be optimized and no tuple pattern matching should occur during runtime ?
08:28:02 <danilo2> c_wraith: I have to declare such instances, because I want to satisfy the liberage coverage condition (in ghc>=7.8). This is a little longer topic why I need to do it this way, but the only place where such tuple pattern matching can occur are the instance declarations
08:29:30 <c_wraith> danilo2: None of this guarantees the matches will get optimized out.  But if you do these things and examing the core shows that they're not being optimized out, then you can ask a far more specific question
08:30:42 <bddy> @pl g el func = \z -> func $ f z el
08:30:42 <lambdabot> g = flip (.) . flip f
08:30:43 <danilo2> c_wraith: ok, I'll examine it by myself and then I'll be back with better questions :) Could you please also give me a hint how can Iexamine it? Are you talking about looking at the generated assembly code by ghc or some other way around ?
08:32:08 <c_wraith> danilo2: the core is better.  (It's the intermediate representation high-level optimizations are done on)  http://www.haskellforall.com/2012/10/hello-core.html
08:33:48 <danilo2> c_wraith: Oh, great, thank you :)
08:40:00 <epta> haasn: are you gonna upload fixed timezone-series to hackage?
08:41:49 <haasn> epta: I don't have a hackage account
08:41:56 <haasn> And I don't remember what the fix was
08:42:44 <haasn> Oh, it was this one https://github.com/haasn/timezone-series/commit/7f8edf3711899afc31542799eb6f62d0dc04bfa6
08:42:48 <epta> yep
08:43:06 <epta> what about sending annoying email to Yitzchak Gale?
08:43:17 <epta> (maintainer)
08:44:39 <haasn> Not sure if I already did that or not, but I'll go ahead and bug him about it
08:44:50 <epta> nice, great
08:50:04 * hackagebot network-wai-router 0.1.0.2 - A routing library for wai  http://hackage.haskell.org/package/network-wai-router-0.1.0.2 (georgerogers42)
08:53:05 <darthdeus> this is probably a dumb question, but how can I turn    "foo" ++ (show bar) where bar is an Int into a ByteString?  I've tried Data.ByteString.Lazy.pack, but it doesn't compile
08:53:32 <Guest77286> you have to encode the string somehow, like with utf8
08:53:56 <darthdeus> how do i do that?
08:54:07 <Guest77286> theres a couple packages for this
08:54:14 <Guest77286> @hoohle String -> ByteString
08:54:15 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:54:15 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
08:54:15 <lambdabot> Prelude error :: [Char] -> a
08:54:23 <darthdeus> oh I see
08:54:25 <Guest77286> well, you can also use Char8
08:54:29 <Guest77286> ASCII encoding
08:54:39 <darthdeus> thanks
08:54:40 <geekosaur> the Char8 one is fake and will silently lose data
08:54:48 <geekosaur> well, not fake. bad.
08:54:56 <darthdeus> well I'm only converting integers to bytestrings :)
08:54:57 <Guest77286> for digits of an Int?
08:55:04 * hackagebot api-builder 0.1.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.1.0.0 (Intolerable)
08:55:09 <darthdeus> or a predefined string + integer to be specific
08:55:17 <Cale> Yeah, in this particular case, it'll work. Would be better to go via Text usually though.
08:55:21 <bernalex> is haskell easily portable between GNU+Linux, Mac OS X and Windows?
08:55:28 <Guest77286> i recommend familiarizing yourself with the utf8 version for future reference
08:55:30 <geekosaur> if "foo" is literally "foo" then it's safe, if it can contain anything outside \x00-\x7f then it will break
08:55:31 <Cale> bernalex: generally
08:55:40 <darthdeus> Cale: can I use Text when a function expect a ByteString?
08:55:50 <bernalex> Cale: so it should, as I would guess, demolish C++ in portability for e.g. games?
08:55:52 <darthdeus> Guest77286: any resources for that?
08:56:02 <Guest77286> google bytestring utf8
08:56:05 <Cale> darthdeus: They're not the same type, but there are functions in the Text library to convert to ByteStrings with various encodings.
08:56:39 <Cale> bernalex: I'd expect it to do well as far as portability is concerned, sure.
08:56:58 <Cale> I'm not sure how things are with C++ as far as portability goes.
08:57:35 <darthdeus> cool, thanks :)
08:57:44 <Guest77286> bernalex: GLFW-b is a pretty good binding to GLFW, which works on those three things
08:57:58 <Guest77286> as far as sound goes, im still looking
08:58:01 <bernalex> Cale: pretty much "GLHF" with different build tools for unixen and Windows, and Mac OS X is kind of "special" when compared to other unixen.
08:58:25 <Guest77286> im working on osx and its pretty painless
08:59:51 <bernalex> Guest77286: you can build every c/c++ game I've done on any unix I know of that has opengl, except for mac os x, because it places things in different directories so you need ifdefs.
09:00:05 * hackagebot SafeSemaphore 0.10.1 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.10.1 (ChrisKuklewicz)
09:00:07 <Guest77286> thats an issue with build systems though
09:00:21 <bernalex> Guest77286: build systems have to do with portability.
09:00:58 <Guest77286> my experience on osx and linux with haskell has been basically the same
09:01:31 <bernalex> which is what I'd expect
09:02:05 <Guest77286> i dont have ifdefs
09:02:36 <bernalex> no, why would you?
09:02:51 <Guest77286> no reason
09:03:02 <bernalex> :-]
09:03:42 <ricree> Does Haste have a way to do foreign method calls? (without having to wrap everything in a second JS function)
09:10:05 <drupzky> can someone please tell me what the problem of the compiler is with that: http://pastebin.com/8acgG0mq??         if I remove the type signature of f, everything works!
09:10:06 * hackagebot network-wai-router 0.1.1.0 - A routing library for wai  http://hackage.haskell.org/package/network-wai-router-0.1.1.0 (georgerogers42)
09:10:31 <Cale> drupzky: "This paste has been removed!"
09:10:44 <keko_> the question marks aren't part of the URL
09:10:50 <Cale> ah
09:10:54 <drupzky> sry
09:11:13 <Cale> wow, pastebin is bad at syntax highlighting Haskell code
09:11:54 <geekosaur> I'm in some channels that just refuse to look at stuff on pastebin because it's bad at highlighting (plus ads)
09:11:55 <Cale> drupzky: The 'a' in the type signature for f is not necessarily the same 'a' as the one in the type signature for findFirst''
09:12:25 <haasn> It was really helpful when mauke auto-copied pastebin links to lpaste
09:13:17 <drupzky> Cale: thanks, so it's not possible to annotate the types here? only in a comment? (I want to do it, because it really clarifies whats going on there
09:13:19 <Cale> drupzky: if you add {-# LANGUAGE ScopedTypeVariables #-} to the top of your file
09:13:29 <Cale> then you can write:  findFirst'' :: forall a. (a -> Bool) -> RTree a -> Maybe a
09:13:36 <Cale> and then the type signature for f will work
09:13:43 <drupzky> Cale: wow, thanks! :)
09:17:03 <dv-_> what would you can a zipWith where the lists come first and then the function (like in mapM/forM)
09:17:32 <vanila> withZip
09:17:57 <dv-_> it's a start
09:25:12 <mcdonalds> Question: If I wanted to use "g" as a record, where RandomGen g => g, how could I do that?
09:25:54 <klrr_> you would write an instance of RandomGen for g i guess
09:27:46 <mcdonalds> Huh. So my first effort, was something like "data Stuff g =  {randG :: RandomGen g => g}". I can't do anything in that neighborhood?
09:28:53 <pavonia> You can, but it's not considered good practice
09:29:02 <Cale> That's not valid syntax though
09:29:09 <Cale> You don't have a constructor name
09:30:02 <klrr_> instance RandomGen g where random = blalbalb ? i dont know about this particular class but that how you would do normally
09:30:21 <mcdonalds> Hm...even with constructor name I still get an error. I'll try out something in isolation to be sure...
09:30:46 <rgtbctltpx> mcdonalds: data Stuff g = (RandomGen g) => Stuff { randG :: g }
09:30:46 <rgtbctltpx> and turn on {-# LANGUAGE ExistentialQuantification #-}
09:30:46 <rgtbctltpx> http://www.haskell.org/haskellwiki/Existential_type
09:31:20 <Cale> Well, also, you're not allowed to qualify a type variable which is already in scope like that
09:32:14 <pavonia> related http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:32:32 <Cale> That's not an existential
09:33:01 <Cale> (but you need the extension for it to be valid)
09:33:03 <pavonia> Huh, why not?
09:33:15 <Cale> Because g occurs on the left side of the = sign
09:33:20 <rgtbctltpx> oh. if you really need existentials, then 'data Stuff = (RandomGen g) => Stuff { randG :: g }', if not sure, then try 'data Stuff g = Stuff { randG :: g }' and where specify constraint externally when needed
09:33:29 <pavonia> Cale: But that's not legal syntax
09:33:45 <Cale> It is legal syntax if you have ExistentialQuantification or GADTs turned on
09:34:04 <pavonia> :o
09:35:06 <Cale> (because those add the machinery necessary to stick type class dictionaries into constructors)
09:35:08 <hk3380>     Are there any clear advantages of stateful programming besides in-place manipulations?
09:35:10 <jmcarthur> lame. it seems i can use view patterns with existential types but not pattern synonyms.
09:35:16 <Cale> (and more importantly, unpack it again when matching)
09:36:42 <jle`> hk3380: stateful programming doesn't have to involve mutation?
09:36:59 <jle`> hm
09:37:30 <mcdonalds> rgtbctltpx: So, that did work (with error telling me I need to turn on existential types, something or other). Can someone explain if there is an easier way to a put a RandomGen in a record, or why the existential setting is necessary?
09:37:37 <hk3380> jle`: i don't know if it *has* to, but it can
09:38:18 <Cale> mcdonalds: It's generally not necessary
09:38:33 <Cale> mcdonalds: It would help to see the rest of your program
09:38:35 <gamegoblin> So I’m trying to install ncurses on OS X and cabal install is just telling me “exitfailure 1”. Any ideas?
09:38:57 <Cale> mcdonalds: But you can typically just leave the class constraint out altogether
09:39:12 <Cale> mcdonalds: and instead put the constraint on things which use records of that type
09:39:24 <Cale> *or* you could pick a specific instance of RandomGen
09:39:27 <mcdonalds> Cale: can you give a small example of what you just said?
09:39:45 <Cale> data Stuff g = Stuff {randG :: g}
09:39:55 <mcdonalds> Cale: Right, I had thought of that. I just found it odd that it gave me such a fuss over it...
09:39:56 <Cale> foo :: (RandomGen g) => Stuff g -> ...
09:40:13 <mcdonalds> I see....
09:40:32 <Cale> You could also just make it monomorphic
09:40:40 <Cale> data Stuff = Stuff {randG :: StdGen}
09:40:46 <Cale> and then there's nothing to worry about
09:41:11 <Cale> (unless you really care about that polymorphism)
09:41:32 <mcdonalds> Cale: For the purpose of my program it doesn't matter which way I go (really). If the choice was inconsequential, which would you prefer?
09:42:06 <mcdonalds> That is, which ever path you choose is up to you to code around...
09:44:14 <Cale> Whether or not it's worthwhile depends on how many type signatures you're about to write where you'll have to constrain g like that, and whether you might conceivably ever use another instance of RandomGen. Unfortunately at present there aren't so many choices apart from StdGen, because most random generators don't even attempt to implement split.
09:45:19 <Cale> There is tf-random though
09:45:22 <Cale> which is cool
09:45:30 <Cale> http://hackage.haskell.org/package/tf-random
09:46:46 <cin> doo doo doo, da da  da
09:46:54 <mcdonalds> Cale: I see. Yah, there are quite a few signatures I would disrupt here, I'm noticing. I'll be goint the "{randG :: StdGen}" then, most likely. Thank you.
09:47:07 <Cale> (though even that defines its own RanomdGen class, so...)
09:47:07 <cin> mwc-random is probably the only high quality random number library on hackage
09:48:23 <Cale> cin: Why do you say that?
09:50:34 <jmcarthur> http://lpaste.net/103550   <-- i take it back. it looks like the problem is actually PolyKinds interacting with PatternSynonyms somehow.
09:50:55 <Cale> There really needs to be more research done on splittable PRNGs.
09:51:03 <jmcarthur> Cale: hear hear!
09:51:08 <jmcarthur> i really like the interface
09:51:10 <Cale> but http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf is a good start
09:51:49 <Cale> It's absolutely ridiculous that computer science has gone so long without so much as considering them
09:53:40 <Cale> Especially given that sequential PRNGs are bad for a whole lot of purposes (anything other than straightforward iterative computation, anything involving parallelism, ...)
09:57:52 <carter> Cale: wait... so all those MCMC tools out there... dont use splitable good prngs?
10:03:12 <Cale> carter: I don't know of any which do.
10:03:20 <carter> ohhh wow
10:03:27 <carter> oooooo
10:03:50 <carter> soooo tf-random creates an opportunity for deterministically reproducible PRNG paralle computations?
10:03:57 <Cale> yes
10:04:04 <carter> ZOMG
10:04:36 <Cale> Its performance is not stellar
10:04:42 <Cale> But it's pretty okay
10:04:53 <carter> oh
10:04:57 <carter> not stellar
10:04:58 <carter> how?
10:05:08 <Cale> Well, it's slightly worse than StdGen
10:05:21 <Cale> (like 5% or so)
10:05:24 <carter> oh
10:05:31 <carter> but that only matters in the sequential case?
10:05:42 <Cale> and StdGen wasn't great performance-wise to begin with
10:05:43 <carter> hows stdgen in the sequential case vs other prngs?
10:05:45 <carter> oh...
10:05:46 <carter> bo
10:07:01 <Cale> http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/ has some performance comparisons between System.Random (StdGen) and some other libraries
10:07:32 <carter> thaneek
10:07:37 <Cale> (e.g. mersenne-random is about 2 orders of magnitude faster)
10:07:44 <Erika18>  You can find funny videos here. http://bitly.com/1gAh6Jy
10:08:09 <carter> Cale: is mersenne random splitable?
10:08:11 --- mode: ChanServ set +o Cale
10:08:26 --- mode: Cale set +b *!*@79.141.162.19
10:08:26 --- kick: Erika18 was kicked by Cale (Erika18)
10:08:27 <Guest77286>  :t unsafeFeedTroll
10:08:30 --- mode: Cale set -o Cale
10:08:36 <Cale> carter: no
10:08:37 <heatsink> There wasn't a determinstic PRNG before?  I thought that just required a split method
10:08:44 <heatsink> for the RNG seed
10:09:02 <carter> ". We
10:09:02 <carter> show that the currently known and used splittable PRNGs are either
10:09:02 <carter> not efﬁcient enough, have inherent ﬂaws, or lack formal arguments
10:09:02 <carter> about their randomness."
10:09:16 <Cale> heatsink: implementing split in a way which doesn't result in bad properties is tricky
10:09:31 <heatsink> I see
10:10:14 * hackagebot api-builder 0.1.0.1 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.1.0.1 (Intolerable)
10:10:16 * hackagebot cabal-lenses 0.1 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.1 (DanielTrstenjak)
10:11:31 <heatsink> This paper seems to propose using cryptographic hashing to split the seed
10:11:43 <heatsink> I'm pretty sure I've heard about that well before 2013
10:12:16 <danilo2> Hello! Where can I read more about the "liberage coverage condition" introduced in GHC-7.8 ?
10:13:47 <Cale> danilo2: What?
10:14:14 <Gurkenglas> Can lambdabot output the source of a given name?
10:14:23 <geekosaur> Gurkenglas, not really
10:14:38 <monochrom> some of them yes. but are hand-written, not real.
10:14:54 <geekosaur> there is a way to get a generic implementation of some Prelude names, which is often not the one actually used by Haskell compilers
10:15:33 <Gurkenglas> That online hoogle shows some kind of source that seems to make sense
10:16:00 <geekosaur> yes, but lambdabot doesn't have a complete hoogle interface
10:16:15 <Gurkenglas> Is lambdabot opensource?
10:16:26 <monochrom> the dilemma of reading source code: if it's real, it may be so optimized to be unrecognizable; if it is not real, it is not real.
10:16:29 <geekosaur> actually if you build your own you can point it at a more complete database
10:16:33 <geekosaur> and yes
10:16:35 <geekosaur> @version
10:16:35 <lambdabot> lambdabot 5.0-int-e
10:16:36 <lambdabot> git clone git://github.com/int-e/lambdabot.git
10:16:41 <dv-_> @src lambdabot
10:16:41 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:16:43 <dv-_> :|
10:16:49 <Iceland_jack> dv-_: Nice try
10:16:54 <geekosaur> but the one running here has a limited database
10:17:31 <Gurkenglas> Hmm maybe the database this one uses is sufficient...
10:17:38 <Gurkenglas> @src (+)
10:17:38 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:17:39 <Cale> danilo2: The coverage condition is documented here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
10:17:48 <Gurkenglas> @src (fix)
10:17:48 <lambdabot> Source not found. Are you typing with your feet?
10:17:52 <Gurkenglas> ...?
10:17:53 <geekosaur> and @src is the dumb hardcoded database
10:18:01 <Gurkenglas> @src $
10:18:02 <lambdabot> f $ x = f x
10:18:02 <geekosaur> @hoogle fix
10:18:03 <lambdabot> Data.Function fix :: (a -> a) -> a
10:18:03 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
10:18:03 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
10:18:10 <geekosaur> note lack of links...
10:18:12 <Gurkenglas> @src ($)
10:18:12 <lambdabot> f $ x = f x
10:18:23 <Gurkenglas> Well at least it isnt discouraged by brackets.
10:18:31 <Iceland_jack> > succ `id` 10
10:18:32 <lambdabot>  11
10:18:35 <Iceland_jack> > succ $ 10
10:18:36 <lambdabot>  11
10:18:57 <Gurkenglas> @type '
10:18:58 <lambdabot>     lexical error in string/character literal at end of input
10:19:00 <bddy> @src flip
10:19:00 <lambdabot> flip f x y = f y x
10:19:28 <Gurkenglas> Can we add @src entries? ^^
10:20:03 <bddy> Is it possible to have something analogous to @src or @pl in ghci?
10:20:11 <Cale> Gurkenglas: I guess you could ask int-e to add them
10:20:16 * hackagebot cabal-cargs 0.6 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.6 (DanielTrstenjak)
10:20:27 <monochrom> @src fix
10:20:27 <lambdabot> fix f = let x = f x in x
10:20:38 <Gurkenglas> Right fix isnt infix ._.
10:21:19 <geekosaur> the database is part of the github repo so you can do a pull request...
10:21:56 <Gurkenglas> Custom commands accessible via IRC would be awesomer.
10:22:04 <Iceland_jack> bddy: http://www.haskell.org/haskellwiki/GHC/GHCi has information on that
10:22:29 <Gurkenglas> How long do @let definitions persist?
10:22:31 <bddy> aha, thanks
10:23:22 <Iceland_jack> It would be very cool if GHCi had source information baked in
10:23:29 <Iceland_jack> like the Clojure repl does
10:23:44 <danilo2> Cale: thank you! :)
10:23:57 <Gurkenglas> @let Gurkenglas_5_3_test1 25
10:23:57 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:24:08 <Gurkenglas> @let Gurkenglas_5_3_test2 = 25
10:24:09 <lambdabot>  .L.hs:164:1: Not in scope: data constructor ‘Gurkenglas_5_3_test2’
10:24:39 <heatsink> needs to be a variable
10:24:42 <awestroke> @let gurkenglas_5_3_test2 = 25
10:24:44 <lambdabot>  Defined.
10:24:45 <awestroke> there you go
10:24:48 <Iceland_jack> Gurkenglas: Why do you want them to persist?
10:25:01 <Iceland_jack> lambdabot isn't meant to be your personal dev environment :)
10:26:11 <heatsink> @let reallyimportantnumber_do_not_erase = 6.93068868700101e79
10:26:13 <lambdabot>  Defined.
10:26:17 <Iceland_jack> haha
10:26:46 <roconnor> @undefine
10:26:46 <lambdabot> Undefined.
10:26:47 <Iceland_jack> heatsink: my start up idea: store my database in lambdabot as an a-list
10:27:07 <Iceland_jack> > reallyimportantnumber_do_not_erase
10:27:08 <lambdabot>  Not in scope: ‘reallyimportantnumber_do_not_erase’
10:27:10 <Iceland_jack> nooo
10:27:39 <roconnor> "I will never forget you Fry.  *MEMORY ERASED*"
10:27:44 <heatsink> How shall I write my paper now?
10:27:52 <heatsink> The data is lost!
10:29:03 <Iceland_jack> “I love you more than the moon and the stars and the POETIC IMAGE NUMBER 137 NOT FOUND.”
10:30:17 * hackagebot cabal-bounds 0.5 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.5 (DanielTrstenjak)
10:30:19 <bddy> Oh, how is it supposed to be solved? http://lpaste.net/103551 Can't install HTTP-4000
10:30:23 <Gurkenglas> @let wikisrc = (\x -> if (take 17 (@src x)=="Source not found.") then (@src x) else actualwikisrc x)
10:30:23 <lambdabot>  Parse failed: Parse error: @
10:30:36 <Gurkenglas> Also the other way round.
10:31:05 <heatsink> bddy: It appears to be from the network package.  Are you using -package network?
10:31:20 <awestroke> @pointful g el func = \z -> func $ f z el
10:31:20 <lambdabot> g el func z = func (f z el);
10:31:42 <awestroke> hrm
10:31:59 <bddy> heatsink: I'm just doing "cabal install lambdabot" Is -package network supposed to be passed here?
10:31:59 <Gurkenglas> @pl \g el func z -> func (f z el)
10:31:59 <lambdabot> const (flip (.) . flip f)
10:32:45 <heatsink> The error is a linker problem.  It may mean that the HTTP package isn't configured correctly.
10:33:03 <Gurkenglas> @type func
10:33:04 <lambdabot>     Not in scope: ‘func’
10:33:04 <lambdabot>     Perhaps you meant ‘fun’ (imported from Debug.SimpleReflect)
10:33:12 <bddy> hm, does cabal install oeis work for anyone here?
10:33:17 <Gurkenglas> Sure why not
10:33:20 <Gurkenglas> @type fun
10:33:21 <lambdabot> FromExpr a => String -> a
10:43:35 <Gurkenglas> Woo user count is currently divisble by 102.
10:43:52 <Gurkenglas> Aww.
10:46:47 <Nahiyan> :d
10:47:36 <Guest77286> urg, StableName does not have an Ord instance, so i am forced you make a hash table using hashStableName ints
10:47:37 <Nahiyan> If I have a list of lists, [[..], [..], ...], how do I get the list with the longest length?
10:47:50 <Guest77286> forced to make*
10:48:28 <triliyn> :t maximumBy
10:48:28 <lambdabot> (a -> a -> Ordering) -> [a] -> a
10:48:42 <triliyn> :t maximumBy (comparing length)
10:48:43 <lambdabot> [[a]] -> [a]
10:48:49 <Nahiyan> :O
10:49:22 <Cale> That'll waste a lot of time in general though. It would be a reasonable optimisation to pair each list with its length and use maximumBy fst or something
10:49:30 <Cale> er, comparing fst rather
10:49:36 <Gurkenglas> Pairing? Why pair?
10:49:48 <Nahiyan> pairing should be fast I ge\uess
10:50:03 <Guest77286> fast to write the code is good ;)
10:50:13 <Gurkenglas> Oh right, you want the longest list not the biggest length
10:50:36 <triliyn> :t maximumBy snd . zip <*> length
10:50:37 <lambdabot>     Couldn't match type ‘(a0, b0)’ with ‘Int -> b’
10:50:37 <lambdabot>     Expected type: [a] -> Int -> b
10:50:37 <lambdabot>       Actual type: [a] -> (a0, b0)
10:51:11 <triliyn> hmm, I did something wrong, but for something like this you probably shouldn't spend too much effort making it point-free anyway
10:51:25 <Nahiyan> yes
10:51:45 <Gurkenglas> What is <*>?
10:52:00 <Guest77286> :t (<*>)
10:52:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:52:20 <Gurkenglas> Oh, it was infix and that's why :t <*> didnt work
10:53:02 <haasn> :t zip <*> map length
10:53:03 <lambdabot> [[a]] -> [([a], Int)]
10:54:07 <triliyn> ahh, right, that's what I was trying to do
10:55:00 <Nahiyan> Not in scope `<*>'
10:55:22 <Guest77286> @hoogle (<*>)
10:55:22 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:55:22 <triliyn> import Control.Applicative to use it
10:56:18 <Gurkenglas> How do I tell lambdabot to give me the precedence of an infix operator?
10:56:29 <Guest77286> :info (<*>)
10:57:04 <Guest77286> infixl 4
10:57:16 <triliyn> :info will work in ghci
10:57:33 <Nahiyan> ah
10:57:51 <gelisam> hi! does anybody know if something about RankNTypes changed between ghc 7.6 and 7.8? I have a strange regression when composing a rank2 function with a rank1 function.
10:58:01 <pavonia> @tell lambdabot give me the precedence of an infix operator
10:58:01 <lambdabot> Nice try ;)
10:58:06 <pavonia> :)
10:59:12 <jmcarthur> > (length.transpose) ["foo","baz","wibble","fhdsjkigthje","apple"]  -- short way to compute the length of the longest list
10:59:13 <lambdabot>  12
10:59:22 <Gurkenglas> > length . repeat 1
10:59:23 <lambdabot>  Couldn't match expected type ‘a -> [a0]’ with actual type ‘[a1]’
10:59:47 <pavonia> gelisam: What kind of regression?
10:59:47 <Nahiyan> jmcarthur, yes but I wanted the actual list with the longest length
10:59:57 <jmcarthur> yeah, that was just in case
11:00:03 <Nahiyan> :)
11:00:28 <Nahiyan> maximum $ map (length) xs
11:00:38 <Gurkenglas> > length(repeat 1)
11:00:43 <lambdabot>  mueval: ExitFailure 1
11:00:46 <gelisam> pavonia: a type error https://gist.github.com/gelisam/f966c5efe79c3ad83515
11:01:13 <gelisam> "Couldn't match type ‘a0 -> a0’ with ‘forall a. a -> a’"
11:01:14 <Nahiyan> > maximum $ map (length) ["I","am","derp","derpkind"]
11:01:15 <lambdabot>  can't find file: L.hs
11:01:23 <Nahiyan> gahhh
11:01:57 <Gurkenglas> What's that last lambdabot output?
11:02:08 <Nahiyan> > foldl (max) $ map (length) ["I","am","derp","derpkind"]
11:02:09 <jmcarthur> @unset
11:02:09 <lambdabot> Unknown command, try @list
11:02:10 <lambdabot>  <[[Int]] -> [Int]>
11:02:12 <bennofs> Gurkenglas: it's some sort of race-condition iirc
11:02:16 <jmcarthur> > maximum $ map (length) ["I","am","derp","derpkind"]
11:02:17 <bennofs> Gurkenglas: a bug
11:02:17 <lambdabot>  8
11:02:38 <Nahiyan> wha
11:02:44 <Nahiyan> lambdabot doesn't like me
11:03:11 <Guest77286> > let bug = bug in bug
11:03:15 <lambdabot>  mueval-core: Time limit exceeded
11:03:18 <Nahiyan> haha
11:03:26 <jmcarthur> > fix error
11:03:27 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
11:03:32 <CindyLinz> > fix ("bug" :)
11:03:33 <Nahiyan> hahaha
11:03:33 <lambdabot>  ["bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bug","bu...
11:03:36 <Nahiyan> aahahaha
11:04:11 <Guest77286> fix doesnt work apparently
11:04:23 <CindyLinz> > take 5 $ fix ("bug" :)
11:04:24 <lambdabot>  ["bug","bug","bug","bug","bug"]
11:04:38 <Nahiyan> I'm solving the project euler problems and apparently I already solved one collatz sequence problem by accident
11:04:54 * hackagebot cabal-bounds 0.5 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.5 (DanielTrstenjak)
11:04:54 * hackagebot hcwiid 0.0.3 - Library to interface with the wiimote  http://hackage.haskell.org/package/hcwiid-0.0.3 (IvanPerez)
11:06:19 <Nahiyan> > chain n | even n = n:chain (x `div` 2) | otherwise = n:chain (3*n + 1); chain 837799
11:06:20 <lambdabot>  <hint>:1:9: parse error on input ‘|’
11:06:26 <Nahiyan> damn
11:06:39 <Nahiyan> > chain n | even n = n:chain (x `div` 2) | odd n = n:chain (3*n + 1); chain 12
11:06:41 <lambdabot>  <hint>:1:9: parse error on input ‘|’
11:06:49 <Nahiyan> what's going on?
11:08:12 <Gurkenglas> Are you trying to define a function with name chain? Use @let for that
11:09:43 <triliyn> > let chain n | even n = n:chain (x `div` 2) | otherwise = n:chain (3*n + 1) in chain 837799
11:09:44 <lambdabot>  [837799,3 * 837799 + 1,x `div` 2,3 * (x `div` 2) + 1,3 * (3 * (x `div` 2) + ...
11:10:00 <triliyn> > let chain n | even n = n:chain (n `div` 2) | otherwise = n:chain (3*n + 1) in chain 837799
11:10:02 <lambdabot>  [837799,2513398,1256699,3770098,1885049,5655148,2827574,1413787,4241362,2120...
11:10:17 <Nahiyan> ah
11:10:33 <Nahiyan> the list is of length 575
11:10:41 <triliyn> (@let also works by installing a permanent definition, which may or may not be what you want)
11:10:46 <Nahiyan> 525*
11:10:55 <Nahiyan> it's what I want :)
11:11:13 <Gurkenglas> Permanent? As in if I come back next month it's still there?
11:11:18 <pavonia> triliyn: Why was the output of the first one different?
11:11:27 <triliyn> Well, @unlet can reset it
11:11:31 <Guest77286> euler problem: for what n is chain n infinite ;)
11:11:40 <triliyn> But if no one @unlets it, yes, I think it lasts arbitrarily long
11:11:41 <Gurkenglas> :t chain
11:11:42 <lambdabot> Not in scope: ‘chain’
11:11:45 <Nahiyan> :D
11:11:54 <manuel___> if i have (Ord v, Ord e) => M.Map v [e], can I turn that into a new type as an alias?
11:11:56 <triliyn> pavonia: in the first one, one of the things was using x instead of n
11:11:56 <manuel___> with newtype?
11:11:58 <triliyn> :t x
11:11:59 <lambdabot> Expr
11:12:03 <Gurkenglas> @let chain n | even n = n:chain (n `div` 2) | otherwise = n:chain (3*n + 1) in chain 837799
11:12:03 <lambdabot>  Parse failed: Parse error: in
11:12:04 <Nahiyan> Guest77286, :P
11:12:16 <Nahiyan> @show bindings
11:12:16 <lambdabot> "bindings"
11:12:17 <Gurkenglas> @help let
11:12:18 <lambdabot> let <x> = <e>. Add a binding
11:12:18 <Nahiyan> ..
11:12:24 <Guest77286> Nahiyan: a search program may or may terminate...
11:12:30 <Nahiyan> Guest77286, xD
11:12:32 <triliyn> > x + 5
11:12:33 <lambdabot>  x + 5
11:12:39 <Guest77286> may not
11:13:32 <jdiez> hi guys, so I'm working through LYAH and one of the chapters piqued my curiosity
11:13:33 <Nahiyan> the value of which the zeros of the riemann zeta function is not equal to 1/2..
11:13:41 <jdiez> I wanted to know how Data.Map is an instance of Functor
11:13:53 <jdiez> so I wrote my own little Map implementation with an instance of Functor: https://gist.github.com/jdiez17/586546641619e6a66ae4
11:13:53 <Nahiyan> wiki the riemann conjecture
11:14:00 <jdiez> can anyone comment on the style etc?
11:14:10 <jdiez> (I know the haskell map uses trees and stuff)
11:14:20 <jdiez> I just wanted to know if that's more or less the correct way of doing things
11:14:42 <augur> jdiez: Map k is the functor
11:15:16 <augur> for your choice of k
11:15:31 <jdiez> augur: I know, I'm asking about the style of the code
11:15:37 <augur> oh. the style???
11:15:49 <augur> oh of your implementation
11:15:52 <jdiez> well, the fmap implementation I came up with seems weird
11:15:57 <Iceland_jack> there is a type error in the simplification in Nahiyan's parting message :)
11:16:20 <augur> jdiez: too many traversals
11:16:24 <jdiez> I guess it does make sense to create a new Jmap when any of the values change, but man it seems counter intuitive :)
11:16:25 <augur> jdiez: better to do it in one go
11:16:33 <jdiez> augur: good point
11:16:51 <jdiez> how would I do it in one go? probably with a fold, right?
11:16:56 <jdiez> I'm going to try doing it with a fold
11:17:10 <augur> fmap f (Jmap xs) = Jmap [(k, f v) | (k,v) <- xs]
11:17:41 <jdiez> no, a fold wouldn't make sense
11:17:42 <jdiez> maybe a scan
11:17:47 <augur> a fold would
11:18:07 <jdiez> would it?
11:18:49 <augur> jdiez: sure, but its unnecessary to be so obstruse with one here
11:21:57 <monochrom> my only style comment is that there are too many $'s. I prefer parentheses to $'s.
11:22:38 <augur> $ off, monochrom, you ()er
11:24:07 <monochrom> my pedogogical comment is that since Data.Map is not [(a,b)] (not even internally), JMap teaches you nothing about how to write a Functor instance of Data.Map
11:24:17 <augur> indeed
11:24:39 <Gurkenglas> Will @unlet undo all lets or only those whose name the unletter knows?
11:24:45 <augur> tho Data.Map is convertible in a canonical wway to a list of pairs
11:25:10 <monochrom> yeah, it teaches you 1 binary bit of information: "it could be done"
11:26:22 <awestroke> monochrom: is Data.Map implemented by the compiler, or does the Data.Map package contain non-haskell code?
11:26:40 <monochrom> no to both
11:26:41 <augur> awestroke: neither
11:27:01 <augur> Data.Map is a search tree
11:35:16 <pavonia> Is there a (non-lens) function :: (m a, m a, m a) -> m (a, a, a)
11:36:20 <bennofs> @ty uncurry3 (liftA3 (,,))
11:36:21 <lambdabot>     Not in scope: ‘uncurry3’
11:36:21 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
11:36:37 <bennofs> @let uncurry3 f (x,y,z) = f x y z
11:36:39 <lambdabot>  Defined.
11:36:40 <bennofs> @ty uncurry3 (liftA3 (,,))
11:36:40 <lambdabot> Applicative f => (f a, f b, f c) -> f (a, b, c)
11:36:50 <bennofs> pavonia: ^^
11:37:02 <pavonia> Ah, thanks
11:37:44 <bennofs> :t each id :: Applicative f => (f a, f a, f a) -> f (a,a,a)
11:37:45 <lambdabot> Applicative f => (f a, f a, f a) -> f (a, a, a)
11:38:35 * bennofs just can't resist lens
11:41:50 <augur> benbangert: where lens
12:04:58 * hackagebot greencard 3.0.4.2 - GreenCard, a foreign function pre-processor for Haskell.  http://hackage.haskell.org/package/greencard-3.0.4.2 (SigbjornFinne)
12:05:10 <jmcarthur> to anybody who may have quietly cared about my earlier mention of issues with pattern synonyms and kind polymorphism, it looks like it was already discovered and will be fixed in 7.8.3 (and I think is fixed in HEAD already)
12:05:40 <mwhitfield> if i have [(a, Maybe b)], how can i filter Nothings to [(a,b)]? i.e., catMaybes . (something :: [(a, Maybe b)] -> [Maybe (a, b)])?
12:06:42 <allsystemsarego> hi all, could someone enlighten me how to derive the Monad instance here: http://lpaste.net/103552
12:06:59 <mwhitfield> eh nm i think that was enough for me to ansewr my own question just typing it out
12:09:06 <copumpkin> mwhitfield: I'd just use a list comprehension
12:09:23 <copumpkin> [(x, y) | (x, Just y) <- orig]
12:09:30 <jmcarthur> > catMaybes . (map._2) id $ [("foo", Just 5), ("bar", Nothing)]
12:09:30 <copumpkin> can't get much simpler than that
12:09:31 <lambdabot>  [("foo",5)]
12:09:50 <jmcarthur> _2 id  is a disappointing looking expression
12:11:34 <jmcarthur> _2 F.toList =<< [("foo", Just 5), ("bar", Nothing)]
12:11:38 <jmcarthur> > _2 F.toList =<< [("foo", Just 5), ("bar", Nothing)]
12:11:39 <lambdabot>  [("foo",5)]
12:11:50 * copumpkin runs away screaming
12:11:58 <jmcarthur> i don't hate that one
12:12:10 <copumpkin> :)
12:14:37 <jmcarthur> allsystemsarego: Monad can't in general by derived
12:15:05 <allsystemsarego> oh
12:15:19 <jmcarthur> allsystemsarego: you seem to be trying to use GeneralizedNewtypeDeriving, but that only works if the representation already has such an instance
12:16:11 <jmcarthur> allsystemsarego: but  [(Int, _)]  doesn't already have a Monad instance defined
12:16:41 <allsystemsarego> ok, makes sense
12:16:53 <allsystemsarego> thanks
12:17:21 <SrPx> Is it acceptable to use types as enums? "data ProcessingState = Waiting | Running | Paused | Etc"
12:18:15 <bennofs> SrPx: yes, why should it not be?
12:18:23 <pavonia> SrPx: As opposed to what?
12:18:27 <SrPx> bennofs: just wondering if I am doing the right thing
12:19:26 <jmcarthur> the answer to "Is it acceptable to define a new type for this?" is almost always "Yes"
12:19:36 <SrPx> uhm ok
12:20:14 <pavonia> Again, what's the alternative here?
12:22:24 <SrPx> dunno
12:25:18 <jedai42> +
12:40:00 <awestroke> @instances Alternative
12:40:00 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
12:40:35 <ocharles> Can anyone make sense of: 'The second argument of `:' should have kind `[*]', but `xs' has kind `[KV * *]'" ? I thought lists were kind polymorphic?
12:40:41 <ocharles> I'm using -XDataKinds and -XPolyKinds
12:41:09 <ocharles> That error is occuring on this line: ResultFunctor ((KV k v) ': xs) = Compose ((->) [(k, v)]) (ResultFunctor xs)
12:41:45 <shachaf> This is funny: :k [1] is an error (expected kind *), but :k [1,2] is not (has kind [Nat]).
12:43:05 <shachaf> Another funny thing is that the kind "[] a" doesn't mean the same as "[a]".
12:45:20 <shachaf> Anyway, one line from your program is rarely enough information for people to help you.
12:50:32 <allsystemsarego> @instances Applicative
12:50:33 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:51:08 <vektor> is there a function that prepends to tuples like so: a -> (b, c) -> (a,b,c)
12:52:25 <vektor> (ideally, (b,c) could be any tuple, but I only need a 2-tuple.)
12:52:27 <shachaf> ocharles: Never mind, I was just saying nonsense.
12:52:29 <geekosaur> vektor, not generally; tuples are not lists in Haskell, every tuple is a distinct type and there is no concept of a general cons operator to prepend or append something to a given n-tuple giving a (n+1)-tuple
12:52:46 <shachaf> ocharles: The solution is to write '[(k, v)]
12:52:47 <ocharles> shachaf: easily done with this stuff :) Let me paste the whole program
12:52:50 <s778> This might be a stupid question, but how can I use `find' when I have `a -> IO Bool' rather than `a -> Bool' ?
12:52:58 <ocharles> I was hoping to introduce my own type rather than use tuples
12:52:59 <vektor> well, you can ad-hoc a tuple at compile time, so i figured such a function would be possible?
12:53:00 <geekosaur> and it's somewhat uncommon for anything other than 2-tuples to be used as a result
12:53:08 <allsystemsarego> > (,,) 1 2 3
12:53:10 <lambdabot>  (1,2,3)
12:53:19 <allsystemsarego> vektor, ^
12:53:41 <geekosaur> allsystemsarego, but that does not take an item and a 2-tuple
12:53:54 <SrPx> Hey, some time ago someone pointed a good way to guarantee termination together recursion is to only allow recursion to be applied to sub terms of a pattern matched expression. So, for example, `foo (Node a b) = Node (foo a) (foo b)` is guaranteed to terminate. But `foo (Node (Node a b) c) = foo (Node a c)` is, too, terminating, and wouldn't be allowed in such a language!
12:53:58 <geekosaur> could probably fit an uncurry in there or something but
12:54:30 <SrPx> So, my question is, is there another way to introduce recursion that would not make some kind of non~terminating programs illegal, while still maintaining strong normalisation?
12:54:34 <hae> vektor, try (\ x (y, z) -> (x, y, z))
12:54:41 <SrPx> terminating programs illegal*
12:54:44 <hae> There you go.
12:54:45 <geekosaur> I was not saying can't be done, I'm saying not generally considered a good idea
12:54:57 <geekosaur> because tuples don't behave like lists
12:55:01 <bennofs> :t uncurry . (,,)
12:55:02 <lambdabot> a -> (a1, b) -> (a, a1, b)
12:55:06 * SrPx is pretty sure he won't get an answer to this question :C
12:55:09 <vektor> hae: I figured I could just lambda it, I was curious whether there was a boilerplate solution for bigger cases.
12:55:53 <hae> The whole idea of tuples is that they have immutable length. For accumulating things you always use lists.
12:56:07 <vektor> yeah, sure.
12:56:22 <vektor> I know for a fact that this function will return a (Int, Int, String) tuple though
12:56:45 <allsystemsarego> vektor, what bennofs said above
12:56:48 <vektor> and it's basically applying another function  -> (Int, String) twice
12:57:19 <allsystemsarego> > uncurry . (,,) $ 1 (2,3)
12:57:20 <lambdabot>  Could not deduce (GHC.Num.Num ((t0, t1) -> s))
12:57:21 <lambdabot>    arising from the ambiguity check for ‘e_1123’
12:57:21 <lambdabot>  from the context (GHC.Num.Num ((t, t2) -> s),
12:57:21 <lambdabot>                    GHC.Num.Num t2,
12:57:21 <lambdabot>                    GHC.Num.Num t)
12:57:32 <bennofs> > (uncurry . (,,)) 1 (2,3)
12:57:33 <lambdabot>  (1,2,3)
12:57:52 <silasm> s778: pretty sure that's impossible without unsafeperformIO, because you'd be pulling something from IO into a pure context if you were to do that.
12:58:10 <hae> You know theoretically... Wait, let me try something.
12:59:00 <vektor> silasm: I think the question is the other way around
12:59:12 <vektor> i.e. how to use pure functions from a IO context
12:59:37 <silasm> he wants to use an (a -> IO Bool) for find
12:59:52 <silasm> :t \f -> find (unsafePerformIO . f)
12:59:53 <lambdabot> Not in scope: ‘unsafePerformIO’
13:00:00 <silasm> I figured as much
13:00:11 <silasm> that's how you'd do it, but I don't recommend it, obviously
13:00:38 <FreeFull> silasm: You could do it inside IO
13:00:39 * geekosaur thinks they want findM, not that such exists...
13:01:32 <FreeFull> :t \f -> fmap (find id) . mapM_ f
13:01:33 <lambdabot>     Couldn't match type ‘()’ with ‘[Bool]’
13:01:33 <lambdabot>     Expected type: [a] -> f [Bool]
13:01:33 <lambdabot>       Actual type: [a] -> f ()
13:01:40 <FreeFull> :t \f -> fmap (find id) . mapM f
13:01:41 <lambdabot> (Functor f, Monad f) => (a -> f Bool) -> [a] -> f (Maybe Bool)
13:02:01 <silasm> FreeFull: I don't know how to turn `(a -> Bool) -> [a] -> Maybe a` into `(a -> IO Bool) -> [a] -> IO (Maybe a)
13:02:01 <FreeFull> Odd, I'd think Monad f would imply Functor f
13:02:04 <hae> Interesting.
13:02:26 <FreeFull> :t find
13:02:27 <lambdabot> (a -> Bool) -> [a] -> Maybe a
13:02:45 <FreeFull> My function isn't quite right anyway
13:03:23 <silasm> honestly it would probably be easier to just rewrite the function to work in IO. There may be a way to lift it appropriately, but I'm not seeing it.
13:04:24 <s778> Thanks for the help, guess I'll try it from a different angle
13:04:41 <silasm> @src find
13:04:41 <lambdabot> find p          = listToMaybe . filter p
13:04:55 <bennofs> @ty filterM
13:04:56 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
13:06:12 <silasm> :t \f -> liftM (find id) . mapM f
13:06:13 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe Bool)
13:07:57 <silasm> idk though. That might be convoluted enough that you'd rather rewrite the function anyways just for clarity.
13:16:00 <oni_> what if any way is there to integrate a snap web app with a android app that needs to be written in or API'ed with Haskell
13:17:40 <jophish> How often are implicit parameters used. They seem to be a little nicer than plumbing everything through a reader monad
13:17:44 <augur> calling all haskell evangelists! http://www.reddit.com/r/programming/comments/24mcgn/what_do_you_think_is_impeding_haskell_from/
13:19:19 <joelteon> jophish: The Reader monad is just a wrapper around (->)
13:19:43 <jophish> joelteon: yeah, for some reason I prefer using that than moving everything around manually
13:19:50 <jophish> I guess that's why it's there!
13:20:05 <joelteon> implicit params are not used often
13:20:08 <joelteon> i don't like them
13:20:47 <nomeata> Hi. Can anyone explain to me why "cabal configure -f-example" in wai-websockets will still try to install warp etc. (http://hackage.haskell.org/package/wai-websockets-2.1.0.1/wai-websockets.cabal)
13:20:56 <hae> Lol, "being lazy with class".
13:40:27 <akegalj_> i am on arch linux. I have installed ghc7.8 but i do whant to install ghc7.6 too now. But, i don't have libgmp.so.3. Arch package manager doesn't let me to install two versions of same binary
13:40:35 <akegalj_> so i need to compile it myself
13:40:59 <akegalj_> i have libgmp.so.10 though
13:41:41 <akegalj_> how can i resolve this?
13:46:33 <jophish> akegalj: compile libgmp yourself just for ghc.
13:49:41 <akegalj> jophish: i can't find it, where can i find libgmp v3?
13:51:24 <ocharles> If I have a hetrogeneous list and a type family to capture Snoc'ing the list, how would one introduce information that (Snoc x xs) is always a non-empty list? That is, teach the type checker that Snoc x [] = [x]; Snoc x (y : ys) = y : ...
13:52:02 <ocharles> I feel like it needs  gcastWith snocNonEmpty myComputation  or some form of proof
13:52:21 <ocharles> (Because that type family can't be further evaluated at that point of code, because I don't know what xs is)
13:52:31 <jophish> akegalj: you can compile ghc without gmp: https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
13:53:13 <akegalj> jophish: thank you, will do reading now
13:53:42 <jophish> It says on that page that it's not tested often, so take care
13:54:16 <bennofs> jophish: akegalj I think you probably don't want to do that. If you're  b
13:54:35 <bennofs> If you're building GHC from source anyway, you can just as well build it against a newer version of GMP
13:54:35 <jophish> heh, I suspected as much
13:56:26 <akegalj> jophish: yeah,i think i wont go that route
13:56:40 <jophish> bennofs's advice sounds best
13:56:46 <akegalj> bennofs: how can i tell ghc to use new gmp?
13:57:02 <akegalj> bennofs: yes, i'm building from source
13:57:05 <bennofs> akegalj: I think it will pick it up automatically when building from source
13:57:29 <akegalj> bennofs: hm, he complained for not finding gmp.so.3
13:58:31 <akegalj> bennofs: "checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3"
14:00:34 * hyg would like to master Haskell
14:01:16 * BMeph would like that for hyg, as well.
14:01:27 <osa1> anyone know a function to apply a function to both elements of a pair?
14:02:00 <BMeph> ..."both," maybe? ;þ
14:02:55 <osa1> (***) in Control.Arrow
14:02:57 * hackagebot greencard 3.0.4.2 - GreenCard, a foreign function pre-processor for Haskell.  http://hackage.haskell.org/package/greencard-3.0.4.2 (SigbjornFinne)
14:02:57 * hackagebot soap 0.2.2.3 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.3 (AlexanderBondarenko)
14:03:12 <osa1> or not
14:03:22 <supki> :t over both
14:03:23 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
14:03:41 <osa1> is this lens?
14:03:52 <supki> :t join bimap
14:03:52 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
14:04:01 <osa1> can't use lens functions
14:04:27 <bennofs> :t join (&&&) --- only uses functions from base
14:04:28 <lambdabot> Arrow a => a b c -> a b (c, c)
14:04:39 <bennofs> :t join (***) --- only uses functions from base
14:04:40 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
14:04:46 <osa1> awesome
14:04:51 <osa1> that should do the trick
14:05:14 <osa1> thanks
14:06:53 <osa1> join (***) <- it's interesting how join works here.
14:07:10 <NemesisD> anyone read Tekmo's writeup on pipes-mvc?
14:08:21 <freeman42> interesting read: http://www.reddit.com/r/programming/comments/24mcgn/what_do_you_think_is_impeding_haskell_from/
14:09:22 <bennofs> osa1: notice that ((->) r) is a monad
14:09:50 <osa1> I know
14:10:33 <bennofs> osa1: ah, so you know how join works there?
14:11:14 <osa1> bennofs: yeah, I just never thought how join on function monad is useful.
14:11:20 <bennofs> osa1: :)
14:11:39 <osa1> so learned an awesome trick thanks to you :)
14:12:53 * hackagebot soap 0.2.2.4 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.4 (AlexanderBondarenko)
14:17:53 * hackagebot soap-tls 0.1.1.1 - TLS-enabled SOAP transport (using tls package)  http://hackage.haskell.org/package/soap-tls-0.1.1.1 (AlexanderBondarenko)
14:17:55 * hackagebot soap-openssl 0.1.0.1 - TLS-enabled SOAP transport (using openssl bindings)  http://hackage.haskell.org/package/soap-openssl-0.1.0.1 (AlexanderBondarenko)
14:26:09 <copumpkin> dcoutts: have you considered a scoped hackage? :)
14:26:15 <copumpkin> lispy and I were just talking about it
14:27:43 <benzrf> :t (***)
14:27:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:27:51 <chexxor> Anyone using a haskell-like language-compiled-to-JS to write Angular apps?
14:27:54 <benzrf> ooh
14:28:14 <lispy> chexxor: not me, but there are definitely options for compiling to js.
14:28:26 <benzrf> > let tmap = join (***) in tmap (+1) (3, 5)
14:28:28 <lambdabot>  (4,6)
14:28:30 <Earnestly> Angular?  Is that a new type of phishing?
14:28:35 <lispy> chexxor: ghcjs, fay, and elm might be worth looking at
14:29:08 <copumpkin> dcoutts: thinking of things like a github-like model for package names. copumpkin/badpackagenamehere, or pipes/http. Users get their own namespace and people can apply for project-level namespaces the same way github has organizations
14:29:09 <chexxor> lispy, Yeah, I saw the page on haskell wiki. Great page. I was wondering if it's still in proof-of-concept phase or if it actually works, and if it works well.
14:29:15 <hyg> BMeph: I feel like I *have* to understand monads and other cool abstractions but I'm stuck to understanding metaphors (boxes, etc) given by various tutorials; as a result, I don't know how to apply the theory because even though I know their purpose it's too abstract to me
14:29:51 <benzrf> hyg: you just need to use em
14:29:54 <copumpkin> dcoutts: mostly because it doesn't seem scalable to have a giant list of shared space, and people will often "squat" good general names with stupidly specific packages
14:30:07 <lispy> chexxor: which one? ghcjs? About 6 months ago it wasn't quite mature enough to compile ghc but it could handle a good chunk of libraries.
14:30:15 <benzrf> hyg: u see monads are like burritos
14:30:24 <benzrf> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ <- hyg
14:31:16 <lispy> dcoutts: and we could have a namespace for unmaintained stuff (maybe the hackage janitors would move stuff there as appropriate)
14:32:33 <chexxor> lispy, well, I'm interested to see an open-source working example of a Haskell or Fay code integrating with an existing browser-side JS framework, like AngularJS. It could get pretty messy, having two languages side-by-side in one project like that.
14:33:05 <lispy> chexxor: agreed. I think you want to look at their "FFI" examples
14:33:35 <chexxor> lispy, So, sounds like this is still a glint in the eye of the FP community? No working projects out yet?
14:34:23 <lispy> chexxor: you know, another approach is to use an ajax style communication (but maybe with a better wire format like json) and not mingle them so tightly. Have you seen threepenny gui?
14:34:56 <lispy> chexxor: that's probably accurate. Some folks have done a lot of good foundational work but nothing that is really "veteran"
14:35:09 <chexxor> lispy, If not AngularJS, have you seen a project using Fay/similar integrated into a different JS framework?
14:35:28 <chexxor> lispy, I haven't heard of threepenny yet, no
14:35:48 <lispy> chexxor: no I haven't seen that but I also don't do web dev so I'm a bit ignorant.
14:35:50 <hyg> benzrf: you mean practice? or using them blindly? (which I don't want to do)
14:36:19 <benzrf> hyg: try thinking of each monad as a unique abstraction
14:36:31 <benzrf> don't think about the general application of >>=, just think about monad instances separately
14:36:32 <lispy> chexxor: the gentleman that designed elm works for prezi. So perhaps elm is more mature than I think?
14:36:40 <benzrf> as though >>= were a different operator on different types
14:36:50 <benzrf> over time you will begin to grasp the shared structure
14:37:36 <lispy> chexxor: it's not exactly Haskell (so you'll lose out on libs and possibly laziness) but it's still a nice FP language and it's design with js and browser integration in mind.
14:38:02 <tar_> "strange closure type 49824" <-- this is caused by memory corruption, right?
14:38:15 <shachaf> Could be caused by lots of things.
14:38:20 <hyg> benzrf: I read this post like one year ago. thanks to other tutorials (which I don't really remember). I had some moments where I thought I was getting it, like "ah yeah, it's only a process of doing things" or something, but I haven't yet understood them in fact
14:39:12 <tar_> darn
14:39:28 <benzrf> hyg: just don't think about Monads
14:39:30 <hyg> benzrf: it's like there is no simple definition, no simple example to illustrate either
14:39:41 <benzrf> think about what the bind operator does on individual types
14:39:51 <lispy> tar_: it could be caused by a buggy FFI binding too (and as shachaf says, lots of things)
14:39:55 <benzrf> i.e. when using List as a monad, think about what >>= does on lists
14:40:01 <benzrf> do not think about monads in general
14:40:11 <lispy> tar_: if you'd like help debugging it we'll need more info.
14:40:13 <benzrf> you will begin to grasp a recurring sameness between usages over time
14:40:34 <chexxor> lispy, Last night I was reviewing some non-JS programs, and I felt so frustrated. "Gosh, I wish I could have static type checking in our app! Why can't I?" Too bad nobody else cares about it.
14:41:09 <tar_> I'm using Haskell in an iOS project. The bug occurs when I build for device. It's triggered by certain arbitrary changes in the Objective-C code, and goes away if I re-link after reverting those code changes.
14:41:21 <chexxor> lispy, Thanks for the tips
14:41:27 <lispy> chexxor: In your case, it may make more sense to create a DSL (embedded) in Haskell which generates the .js code that you need.
14:41:49 <tar_> For example, it will run fine, then I add an NSLog somewhere that might not even get executed, but the new build will crash on launch with a strange closure type.
14:41:49 <lispy> chexxor: creating a nice DSL takes an experienced Haskeller. I dunno what your team is like.
14:42:18 <chexxor> lispy, haha, nobody is close to experienced. ^_^
14:43:13 <lispy> tar_: oh, I'm out of my depth on that one. I have no experience with the ARM backends, no experience with iOS at all, and no experience with Obj-C + Haskell.
14:44:00 <lispy> tar_: Does the objc have a run-time? Could it be a bad interaction between the Haskell run-time and the objc runtime?
14:44:13 <hyg> benzrf: thanks, will try to overlook bind on multiple monads. have to go, see you
14:44:25 <tar_> lispy: I'm approximately at that level too. The Haskell library is just a part of this project and I haven't touched it much. :)
14:44:43 <tar_> lispy: There's an Obj-C runtime and it absolutely interacts with the Haskell runtime, but in ways I don't understand yet.
14:46:24 <tar_> I remember there were load order bugs before.
14:46:34 <lispy> ah
14:46:41 <lispy> Can you attach gdb?
14:46:49 <jophish> I have an instance (C t, Functor f) => C (f t); I also have an instance (C t) => C (D t). D is not an instance of Functor. This has let to overlapping instances, obviously if I remove the instance declaration for D things don't compile because D isn't a Functor. I've obviously got the design a bit wrong here, but I'm not quite sure where. One solution would be to specialise the instance for each Functor I use. Another would be to make D
14:46:49 <jophish>  a Functor.
14:47:15 <lispy> if so, you might get a build of ghc that has debug symbols in the RTS and see if you can make some progress. (gdb on the haskell rts is hard. You need to know C, the RTS, gdb, and Haskell really well)
14:47:16 <tar_> lispy: I can attach lldb. Maybe gdb
14:47:40 <lispy> tar_: the specific debugger doesn't really matter. gdb is the only one I know :)
14:48:02 <shachaf> If D can be an instance of Functor, then it should be.
14:48:27 <shachaf> Otherwise you're in trouble. instance C (f t) overlaps with everything.
14:48:35 <shachaf> The constraint on the left doesn't matter. That's not used for instance resolution.
14:49:00 <jophish> yeah, I don't know why I thought it would!
14:49:35 <hae> Is there a way to define pattern-matching functions with lambdabot?
14:49:39 <tar_> lispy: sounds reasonable, but of those all I know is C. :)
14:49:50 <jophish> shachaf: ah, actually coming to implement it. I don't think that D can be a functor
14:49:58 <shachaf> On the other hand if you're writing an instance like that, maybe it doesn't make sense to have a type class in the first place.
14:50:03 <tar_> I was hoping that strange closures might be a better clue than they are. oh well
14:50:22 <lispy> > let foo 0 = 'a'; foo 2 = 'b'; foo _ = 'c' in foo 2 -- hae
14:50:23 <lambdabot>  'b'
14:50:25 <shachaf> Functor is a very nice type class. Every type has at most one possible correct instance.
14:51:17 <hae> Thanks lispy.
14:51:39 <jophish> shachaf: I can write an instance for it which obeys all the laws, however I couldn't get it to behave the way I want with my instance of C for Functor
14:52:24 <lispy> hae: there is also a @let command
14:52:30 <hae> > let slice _ [] = []; slice n xs = (take n xs) : slice n (drop n xs) in slice 4 "Gandalf trod down the path."
14:52:32 <lambdabot>  ["Gand","alf ","trod"," dow","n th","e pa","th."]
14:52:52 <lispy> @let hae "test" = "it works!"; hae _ = "is this a test?"
14:52:53 <lambdabot>  Defined.
14:52:56 <lispy> > hae "test"
14:52:57 * hackagebot Dung 1.0.0.1 - An implementation of the Dung argumentation frameworks.  http://hackage.haskell.org/package/Dung-1.0.0.1 (BasVanGijzel)
14:52:58 <lambdabot>  "it works!"
14:53:16 <hae> Oh, that's very helpful.
14:54:06 <lispy> hae: @let is nice but you never know when someone will use the corresponding delete command (@undef I think?)
14:54:13 <hae> I just wanted to show that one off, I'm building my own little library of helper list functions.
14:54:20 <geekosaur> "@undefine"
14:54:52 <hae> Of course it breaks if you use 'slice 0 [anything]' though.
14:54:59 <djahandarie> hae, I assume you've seen the split package on hackage?
14:55:12 <jophish> shachaf: One of the functions in C is to apply a function f to the elements, exactly like Functor except that f has a more specific type. D also applies f to another value it's holding, as well as the one it's parameterised over
14:55:41 <jophish> so fmap can't be defined for it, because the transformer will have a type which is too general
14:55:53 <hae> djahandarie, no I hadn't until now, but that's exactly what I was looking for.
14:56:13 <shachaf> jophish: I don't think I understand anything about what's going on from that description.
14:56:15 <hae> Lol the description for that package.
14:56:55 <hae> I always wondered about that.
14:57:58 * hackagebot CarneadesIntoDung 1.0 - A translation from the Carneades argumentation model into Dung's AFs.  http://hackage.haskell.org/package/CarneadesIntoDung-1.0 (BasVanGijzel)
15:00:22 <jophish> shachaf: sorry! C has a function 'apply :: C t => A -> t -> t'. When t is a Functor holding some other type in C, I'd like to run 'apply' on all the elements in the Functor. D a = D B a, and B is an instance of C. For D, apply A (D b a) = D (apply A b) (apply A a)
15:01:06 <jophish> I think that the best solution may be to not create an instance for every Functor, and write a separate instance for every one I use
15:01:32 <shachaf> jophish: OK, I misunderstood your description before.
15:01:46 <shachaf> Anyway, yes, that's one solution.
15:01:59 <jophish> It seems a little ugly though
15:02:21 <jophish> having to do this just because D takes one type parameter, the same as Functor
15:08:18 <yitz> hae: yeah there was some "bikeshedding" that went on about that
15:08:38 <exfalso> Hi, i want to write a C ffi binding for a lib that has some x86/x64 dependent action going on. Are there any packages i can look at that do this The Right Way?
15:09:02 <yitz> hae: but that was a long time ago. writing a separate library that does a pretty good job and became widely accepted was actually a good way out of that.
15:09:14 <hae> Haskell: Have It Your Way
15:09:20 <Duta> Is there a built-in version of foldr (.) id?
15:09:39 <sipa> :t foldr (.) id
15:09:40 <lambdabot> [b -> b] -> b -> b
15:09:41 <yitz> hae: the split library is now even part of the Haskell Platform, so it is in that sense standard now.
15:10:23 <shachaf> Duta: No.
15:10:33 <knrafto> :t appEndo . mconcat . fmap Endo
15:10:34 <lambdabot> [a -> a] -> a -> a
15:10:40 <hae> Cool story, yitz. You have to admit that my 'slice' is a much better name than 'chunksOf' though. :P
15:11:09 <startling> heh
15:11:09 <Duta> knraftto, I saw that that was an option, but it seems to be more typing
15:11:21 <Duta> *knrafto
15:11:39 <Duta> And I assume slower
15:12:13 <Duta> Is there any particular reason why there isn't something like
15:12:14 <knrafto> Duta: it might not actually be slower, since newtypes are free
15:12:18 <Duta> compose = foldr (.) id
15:12:24 <Duta> in prelude?
15:12:29 <startling> Duta, it's not super useful.
15:13:09 <Algebr> Why can't ghc provide stack traces?
15:13:14 <Algebr> or rather ghci
15:13:22 <startling> :t appEndo . fold . map Endo
15:13:23 <lambdabot> [a -> a] -> a -> a
15:13:30 <startling> Algebr, it can, it just doesn't.
15:13:37 <Algebr> why?
15:13:44 <startling> Algebr: it will in 7.10 or something I think
15:13:53 <startling> Algebr, Debug.Trace may be useful
15:14:07 <Algebr> Oh, so its just a technical challenge, not like impossible in principle.
15:14:08 <shachaf> startling: It's moderately useful.
15:14:15 <shachaf> > ala Endo foldMap [(+1),(*2)] 5
15:14:16 <startling> Algebr: yeah.
15:14:17 <lambdabot>  11
15:14:26 <vanila> Algebr, haskell doesn't have a call stack
15:14:28 <startling> shachaf: is it? I've never had a use for it.
15:14:35 <vanila> it's execution is done by graph reduction
15:14:37 <shachaf> I think it probably deserves a name.
15:14:46 <bitemyapp> I'm having trouble with Hackage but the Hackage channel is dead.
15:14:50 <Algebr> vanila: I don't know what that means, graph reduction
15:15:01 <startling> bitemyapp: what's the trouble?
15:15:02 <bitemyapp> my package candidate doesn't seem to be getting built: http://hackage.haskell.org/package/bloodhound-0.1.0.1/candidate
15:15:08 <lispy> vanila: ghc does use a stack for some parts of the computation.
15:15:11 <bitemyapp> no haddocks, nothing in build reports for the candidate.
15:15:12 <startling> vanila: that doesn't mean you can't have a stacktrace type thing
15:15:18 <danilo2> Hello everyone :) I've got a basic Haskell question - I want to create a default instance, which will be used, when no other mached - I thought it is possible, but everything I try fails. I want to create a function, which will transform (a,(b,(c,()))) into ((((),a),b),c) and back. The code is as follow: http://lpaste.net/103560
15:15:24 <bitemyapp> it's "known good" as far as Travis CI is concerned for 7.6.3 and 7.8.2
15:15:29 <vanila> Algebr, well instead of executing a program by stackng up function calls, it makes a graph of the program and "simplifies" it according to the functions you define
15:15:32 <startling> bitemyapp: it usually takes a while for haddocks to be built
15:15:36 <lispy> Algebr: are you familiar with representing an expression as a tree?
15:15:38 <bitemyapp> startling: how long?
15:15:41 <pjdelport> Algebr: You can trace in Haskell, but it means something a bit different: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#tracing
15:15:42 <startling> bitemyapp: day-ish
15:15:57 <bitemyapp> startling: damn.
15:16:02 <Algebr> vanila: Yea, so it makes a dag?
15:16:07 <hae> Please no. Tupled pseudolists...
15:16:12 <startling> bitemyapp: I think maybe something else is happening though
15:16:12 <bitemyapp> startling: okay, I'll try Fuuzetsu's trick again then.
15:16:15 <bitemyapp> Fuuzetsu: does that still work?
15:16:21 <startling> bitemyapp: it's weird that it's just a candidate
15:16:24 <bitemyapp> Fuuzetsu: force uploading haddocks via curl?
15:16:31 <bitemyapp> startling: I was told to upload a candidate.
15:16:36 <Algebr> I guess a dag would give you laziness?
15:16:41 <startling> I guess I don't know what a candidate is.
15:16:41 <bitemyapp> startling: should I skip that if the turn-around time is going to be a day?
15:16:43 <vanila> Algebr, it's not a DAG
15:16:46 <pjdelport> Algebr: Basically, the idea of a stack trace you probably have is a byproduct of eager evaluation: evaluation happens "inside out", and the "stack" at any given point is the outer expressions waiting for the inner ones.
15:16:54 <vanila> Algebr, you can have cycles like in this example
15:16:55 <lispy> Algebr: the laziness comes from the sharing, so essentially yes.
15:16:57 <danilo2> hae: Are you talking about my example ?
15:16:57 <vanila> > let x = 1 : 2 : x
15:16:59 <lambdabot>  not an expression: ‘let x = 1 : 2 : x’
15:17:00 <vanila> > let x = 1 : 2 : x in x
15:17:02 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
15:17:26 <lispy> Algebr: You can think of Haskell programs as getting evaluated outside in.
15:17:29 <startling> bitemyapp: oh, I understand now. Yeah, haddocks usually take a day-ish
15:17:32 <startling> there's a cronjob or something
15:17:45 <startling> bitemyapp, why do you need it today?
15:17:52 <pjdelport> Algebr: But haskell doesn't use eager evaluation: there simply is no stack of outer expressions waiting. Rather, evaluation happens "outside in": this is what's meant by graph reduction.<https://en.wikipedia.org/wiki/Graph_reduction>
15:18:03 <Algebr> yes, reading the wiki
15:18:07 <bitemyapp> startling: extreme time preference and personal avarice.
15:18:15 <lispy> Algebr: once we've represented the expression as a graph we traverse it in a specific way to get the outside in behavior.
15:18:27 <bitemyapp> startling: is there a build queue?
15:18:29 <startling> bitemyapp, well, why do you need the *haddocks* inside a day?
15:18:31 <Algebr> does any other language do this?
15:18:31 <startling> bitemyapp: no idea.
15:18:36 <pjdelport> Algebr: So a trace in Haskell is a history of evalutions, rather than a trace of "waiting" expressions, like in a strict language.
15:18:40 <bitemyapp> startling: I want to post the library.
15:18:44 <yitz> hae: i wasn't watching, i don't know what your "slice" is. The name I want for that functions is "groupsOf", which fits the naming conventions of Data.List better.
15:18:46 <startling> ah, well
15:18:49 <hae> danilo2, yes. Use something like Data.List.Class instead.
15:18:50 <bitemyapp> startling: I have other things I need to move onto, I want this off my head.
15:18:54 <vanila> that said...
15:18:57 <hexagoxel> danilo2: maybe try using something other than numeric literals for testing
15:19:11 <vanila> maybe you could have a stack trace for stuff happening in IO monad?
15:19:16 <yitz> hae: but never mind, that bikeshed was painted a different color long ago.
15:19:20 <vanila> by some roundabout technique
15:19:21 <startling> bitemyapp: sorry, I don't have a good answer
15:19:23 <bitemyapp> startling: just going to do this instead: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
15:19:33 <bitemyapp> startling: it's okay. Fuuzetsu already posted an answer for getting around this problem.
15:19:37 <bitemyapp> I'll just roll it into my build process.
15:19:44 <hae> Okay then yitz.
15:20:00 <lispy> Algebr: there are other languages that do this, but I think Haskell is the most popular one
15:20:09 <startling> I think you can still get a thing that looks like a stack trace.
15:20:39 <startling> or, well, I don't see a reason you couldn't.
15:21:09 <startling> It may not actually give you the place where an errorful value was evaluated, but it could give you the place it came from.
15:21:18 <lispy> Algebr: if you'de like to learn more about this topic and you like getting your hands dirty, then I recommend this book: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
15:21:34 <lispy> Algebr: it was used to teach a course about implementing the evaluation of haskell-like languages
15:21:43 <lispy> so it has exercises and goes at a good pace
15:21:44 <danilo2> hae: Hmm, but I do not want to use it as list. I think I know what am I doing - I 'm using it for ghc to be able to optimize it out
15:22:09 <hae> Good luck with that.
15:23:01 * hackagebot cookbook 2.3.4.4 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.4.4 (NatePisarski)
15:23:03 <yitz> danilo2: there are fancy type system tricks to do something like that, which will make your program basically useless for beginners. but...
15:23:47 <Algebr> lispy: Oh awesome, thank you
15:23:49 <yitz> danilo2: the real answer is that if you "want to create a default instance, which will be used, when no other mached", you are probably thinking of OO classes, not haskell type classes.
15:25:15 <danilo2> yitz: The code I'm writing will not be used by begginers. In fact nobody would use it - it owuld work somewhere deep - and dont worry, I will not make an library out of it :)
15:25:33 <yitz> danilo2: heh. ok. :)
15:28:11 <lispy> Does the ghc 7.8.2 64-bit for windows work well? I think the last 64bit release (7.6 ?) had linker bugs.
15:28:55 <lispy> Maybe I'll have to be the one to find out...
15:30:16 <yitz> danilo2: did you try using Reversible (a,()) ((),a) and the opposite for the base case instead?
15:31:58 <yitz> lispy: did it? i tried using it a while back. it linked fine, but it crashed when the program used > 2 Gb of memory, which was very suspicious. never found out what was wrong.
15:32:10 <danilo2> yitz: It would still not work. If you change in my code one of the instances to "instance Reversable () () where ..." it works, but in one direction only. To make it both directions I would like to change the line 8 to: "reverseMe (a,b) = (reverseMe b, reverseMe a)", which will not work with your idea either :(
15:32:16 <yitz> lispy: wasn't able to reproduce with anything simple.
15:33:02 * hackagebot bloodhound 0.1.0.1 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.1.0.1 (bitemyapp)
15:33:20 <lispy> yitz: Yeah, it had some sort of serious issue. I couldn't build things like cabal-install. When I looked into the issue it seemed like GHC HQ had assume the small code size model for x86_64 (the linux default) on windows (where you only have the large code size model, IIRC)
15:33:38 <lispy> yitz: I think the linker didn't like the addresses or they were overflowing or something.
15:34:32 <yitz> lispy: you have no idea how much relief i feel from hearing this. i have felt like i was living in the twilight zone since then.
15:36:39 <lispy> yitz: heh.
15:37:10 <pavonia> Uh, what's the best way to debug "hGetContents: invalid argument (invalid UTF-8 byte sequence)"?
15:37:21 <lispy> linking on modern OSs is super complicated with lots of tedious little details from having years of new features bolted on in backwards compatibile ways :(
15:37:28 <johnw> find the file/string that's not Unicode which are attempting to decode as such
15:38:06 <yitz> lispy: and simonm was the only one who knew them all
15:38:39 <pavonia> johnw: The weird thing is I'm reading a file encoded by Haskell's withFile :S
15:39:46 <johnw> show code?
15:41:01 <yitz> pavonia: do you know which file it is? try checking if it starts with BOM and if that is the problem. that has happened to me in the past, i think.
15:41:10 <danilo2> hexagoxel: Thank you :) Indeed with Identity it works. I was just scratching my head If we can omit the Identity and make it working woithout introducing other types
15:41:13 <jle`> why does haskevangelism always feel so weird
15:41:38 <pavonia> yitz: No, it read the beginning, the error must be somwhere at the end
15:41:42 <yitz> @faq why does haskevangelism always feel so weird -- jle`
15:41:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:41:51 <yitz> hey - they changed it
15:42:22 <jle`> hey :|
15:42:39 <jle`> i wonder why i ever even decided to look into haskell and what convinced me
15:42:43 <pavonia> That's the reading script http://lpaste.net/103561
15:43:05 <jle`> i wonder that if i ever ran into one of those over the top haskevangelism articles, if i would have been turned off
15:43:10 <shachaf> int-e: whoa, int-e++
15:43:17 <yitz> pavonia: can you investigate the file and find out exactly where it becomes invalid? that might help you figure it out.
15:43:31 <bitemyapp> jle`: do you think my article was over the top?
15:43:39 <jle`> bitemyapp: no yours was nice
15:43:46 <lispy> jle`: those articles turn me off and I'm already sold on the language
15:43:50 <yitz> pavonia: hint: it might not be a programming error at all
15:43:51 <hae> Some people see Haskell and just get it, others never get it. Weird.
15:43:52 <jle`> i'm talking about the ones that are like...haskell will change the world, no more debugging forever
15:43:55 <bitemyapp> jle`: I tried to make it non-haskell-vangelizing-y because I was just extracting real conversation between Haskellers rather than people talking "down"
15:44:02 <pavonia> yitz: Okay, I'm trying, but it has about 24,000 lines
15:44:09 <jle`> yeah, i appreciated yours a lot
15:44:16 <bitemyapp> thanks. that means a lot to me :)
15:44:19 <yitz> pavonia: binary searches are amazingly powerful
15:44:19 <bitemyapp> It really does :)
15:44:41 <jle`> :D
15:44:41 <d3lxa> is there a more/or is this reliable for listing installed packages (to mirror a full cabal sandbox) by looking at .cabal-sandbox/lib/x86_64-linux-ghc-7.6.3 ?
15:45:03 <bitemyapp> jle`: also, my library is published with proper haddock docs now :)
15:45:09 <jle`> which?
15:45:14 <lispy> d3lxa: ghc-pkg list ?
15:45:14 <bitemyapp> jle`: http://hackage.haskell.org/package/bloodhound
15:45:19 <bitemyapp> jle`: Elasticsearch client! One exists now!
15:45:31 <lispy> d3lxa: oh sorry sandbox. cabal sandbox hc-pkg list
15:45:34 <bitemyapp> ocharles kinda had one, but it was extremely spare.
15:45:47 <jle`> let me google what that means
15:45:56 <ocharles> i still have it, y'know :)
15:46:01 <bitemyapp> jle`: Elasticsearch is a search engine/doc store built on top of Lucene.
15:46:10 <bitemyapp> ocharles: I know, I talked to blackdog about it a fair bit.
15:46:23 <bitemyapp> ocharles: I'd be honored if you took a look: https://github.com/bitemyapp/bloodhound/
15:46:35 <d3lxa> lispy: does every package have necessarly conf.d directory? it seems not all but mostly, am I wrong?
15:46:47 <lispy> d3lxa: I don't know
15:46:48 <yitz> jle`: we use haskell at work. it doesn't do that. but i just wish more people would realize just how much debugging it does save though.
15:46:49 <jle`> oh that's neat
15:47:01 <d3lxa> lispy: ok, that's cool anyway, thank you :)
15:47:11 <lispy> d3lxa: yw!
15:47:14 <bitemyapp> coventry: hi!
15:47:19 <ocharles> bitemyapp: I kinda liked how mine worked out what index data went in, but this looks pretty good
15:47:29 <ocharles> can't see anything obvious, and it's certainly more extensive than mine
15:47:31 <bitemyapp> ocharles: I need to expand the Mapping part badly.
15:47:41 <bitemyapp> ocharles: but I think it provides a nice "Elasticsearch on rails" experience.
15:47:59 <bitemyapp> which ES desperately needs because the "domain" of bad JSON queries/documents/filters is ick.
15:48:57 <bitemyapp> ocharles: I'm reading your article on Indexed monads as we speak.
15:49:09 <ocharles> my indexed json tester thingy?
15:49:21 <bitemyapp> ocharles: yeah.
15:49:29 <ocharles> cool, let me know if you have any questions
15:49:33 <bitemyapp> ocharles: I wanted to demonstrate something a bit different with indexed monads.
15:49:39 <bitemyapp> so I'm...learning indexed monads.
15:50:16 <ocharles> multiple reads of Kleisli Arrows of Outrageous Fortunes eventually got me to a good enough understanding to use them
15:50:35 <bitemyapp> oh of course it's a McBride paper.
15:51:20 <ocharles> damnit, I made GHC's brain explode again
15:52:29 <yitz> ocharles: it's impossible to make GHC's brain explode
15:52:31 <hae> How many monads does it take to screw in a lightbulb?
15:52:49 <ocharles> yitz: pattern match on a GADT in a let binding and tell me that again :)
15:53:08 <yitz> ocharles: dunno. whenever i do it, GHC tells me "the impossible happened".
15:53:29 <ocharles> yitz: the impossible happened is a GHC bug, normally
15:53:38 <bitemyapp> when you have a type error and cannot bring a REPL up
15:53:40 <ocharles> brain explosions are just known limitations
15:53:47 <pavonia> yitz: "A web handler threw an exception. Details: Cannot decode byte '\xa0': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream" -- so it's clearly one of these: http://lpaste.net/103562 :D
15:53:50 <bitemyapp> what's a faster way to type-check your program than running cabal build/repl over and over?
15:53:59 <yitz> ocharles: oh i thought you meant you found a ghc bug.
15:54:02 <bitemyapp> can I somehow keep GHC in the "primed to type-check" state and make it run over and over?
15:54:03 <ocharles> nah
15:54:07 <hae> Trick question. You need a functor to lift the lightbulb!
15:54:14 <bitemyapp> hae: hahHAHAHAHAhaa
15:54:19 <bitemyapp> hae: you are terrible.
15:54:28 <Forgetaboutit> hae: :D
15:54:31 <merijn> bitemyapp: If hdevtools runs a daemon that uses GHC-as-a-library to typecheck
15:54:37 <hae> I know, I know...
15:54:56 <merijn> bitemyapp: To speed up cabal build times, only build non-profiling code with -O0, that drastically cuts back compile time
15:54:59 <yitz> hae: that's fixed in 7.10
15:55:29 <pavonia> It's weird that writing these characters is fine but reading is not
15:55:40 <hae> Lol yitz.
15:56:22 <bitemyapp> merijn: think I already have been, but let me check.
15:56:40 <yitz> pavonia: if you're using surrogates with Data.Text you can run into trouble, because it uses UTF-16 internally.
15:57:10 <pavonia> I'm using Syste.IO's withFile
15:57:13 <pavonia> +m
15:57:13 <merijn> yitz: WHy would that cause trouble?
15:58:20 <Iceland_jack> yitz: Shouldn't cause problems, UTF-16 is not limited to 16-bits
15:58:23 <bitemyapp> merijn: 3.32s vs. 3.48s
15:58:46 <yitz> merijn: there are definitely some weird things that happen, i forget exactly what.
15:59:08 <merijn> yitz: I find that suspect, considering the overall correctness of Text
15:59:35 <merijn> pavonia: Some of the things in your paste are "private use", I'm not sure how that ends up behaving?
16:00:32 <pavonia> I don't know either, I'm trying to write a script replacing all "strange" characters by their hex code
16:01:15 <merijn> Doesn't the show instance of Text already do that?
16:01:40 <pavonia> I'm not using Text
16:01:53 <merijn> Then what?
16:02:21 <yitz> do we have Data.Text in lambdabot?
16:02:26 <merijn> You initially mentioned "Data.Text.Encoding"
16:02:31 <merijn> > T.pack "test"
16:02:33 <lambdabot>  Not in scope: ‘T.pack’
16:02:33 <lambdabot>  Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
16:02:41 <jle`> hae: you don't need functor, you can just use liftM
16:02:42 <jle`> :)
16:02:42 <merijn> > Data.Text.pack "test"
16:02:44 <lambdabot>  Not in scope: ‘Data.Text.pack’
16:02:48 <merijn> apparently not
16:02:49 <pavonia> merijn: hSetEncoding h utf8_bom from System.IO, it uses String
16:02:50 <Guest9083> > text "foo"
16:02:51 <lambdabot>  foo
16:03:13 <merijn> pavonia: Well, are you sure you're reading utf8? Are you sure it has a byte order mark?
16:03:40 <yitz> > "\55808"
16:03:41 <lambdabot>  "\55808"
16:03:48 <pavonia> I'm not sure but I assume as it is written using the same commands
16:03:49 <ocharles> merijn: do you know if ghc --make uses -O0 without any other flags?
16:03:52 <Guest9083> > text "\55808"
16:03:53 <lambdabot>  �
16:04:10 <yitz> merijn: if you do T.pack "\55808" in ghci, you get "\65533"
16:04:20 <merijn> pavonia: utf8_bom is one of the dumbest things in existence, fyi
16:04:28 <merijn> So you probably shouldn't do that anyway
16:04:31 <pavonia> heh
16:05:01 <yitz> merijn: that's not technically wrong; '\55808' is guaranteed never to be assigned to a Unicode character, so it theoretically should never occur in any text.
16:05:03 <lispy> yitz: FWIW, ghc-7.8.2 is using ld from my path and as a result I can't compile anything with it.
16:05:12 <lispy> yitz: it does ship with an ld that would work
16:05:13 <merijn> utf8 is a single byte encoding format, there is no byte-order, the byte-order mark is for conceptual symmmetry with utf16/utf32
16:05:51 <merijn> pavonia: And using a byte order mark in utf8 is ground for severe mocking until you change your ways :)
16:05:59 <pavonia> merijn: So should I use utf8 encoding without BOM?
16:06:04 <merijn> pavonia: Yes
16:06:10 <yitz> merijn: but it is not *invalid*, so if it does occur, Data.Text will behave weirdly like that.
16:06:11 <Earnestly> That's what the standard says
16:06:12 <pavonia> Let me try ...
16:06:40 <merijn> pavonia: The unit of encoding for utf16 is 16 bits, i.e. 2 bytes so it matters if your storing 2 byte values as big endian or little endian
16:07:07 <merijn> pavonia: But since utf8 uses byte as unit of encoding and there is no byte ordering for bytes it makes no conceptual sense :)
16:07:19 <pavonia> But I'm not using utf16 at all, am I?
16:07:33 <Earnestly> You shouldn't be
16:07:34 <merijn> pavonia: I was just explaining what the byte order is *for*
16:07:46 <pavonia> Ah, I see
16:07:49 <merijn> pavonia: i.e. detecting endianness, which is useless for utf8 :)
16:08:04 <yitz> merijn: yeah utf8_bom has caused untolded damage. it was during microsoft's navel-gazing "embrace and extend" phase.
16:09:02 <pavonia> Same problem :(
16:09:09 <yitz> merijn: the excuse is that this mas meant to be a kind of "magic number" so you could detect that a text file was UTF-8
16:10:00 <pavonia> Maybe I should just filter then surrogate characters when writing the file
16:10:40 <johnw> pavonia: you could read the file in as a ByteString, and then do a lenient decode
16:10:46 <yitz> lispy: my problems were happening with their ld - i'm pretty sure.
16:11:07 <johnw> see http://hackage.haskell.org/package/text-1.1.1.1/docs/Data-Text-Encoding.html#v:decodeUtf8With
16:11:11 <yitz> lispy: i put the 64-bit mingw stuff at the beginning of the path.
16:11:41 <Algebr> code running written with unicodesyntax on must looking amazing but like nearly impossible to share
16:11:50 <yitz> lispy: and i don't think MSVC was installed on that VM, so anyway it wouldn't have had its own ld.
16:11:53 <johnw> in fact, you could use:  decodeUtf8With (replace 'X'), to replace each failed byte with an X
16:12:30 <johnw> or something like that
16:12:30 <yitz> Algebr: i personally don't like it, but some people do use it and it seems to be ok.
16:12:34 <johnw> you may need replace "Failed to decode" (Just 'X')
16:12:58 <pavonia> johnw: I would have to do the whole utf8 decoding myself then, because I need the codepoints
16:13:33 <johnw> hmm?  weren't you relying on hGetContents to decode it for you before?
16:13:50 <pavonia> Yes
16:13:58 <johnw> so, this is pretty much as easy as that
16:14:27 <yitz> merijn: i come across utf8_bom all the time. many windows applications produce it by default.
16:14:34 <johnw> txt <- ByteString.readFile "foo" >>= decodeUtf8With ...
16:14:40 <pavonia> Oh sorry, I missed your following messages
16:15:08 <pavonia> That look fine
16:15:13 <pavonia> +s
16:16:14 <lispy> yitz: It looks like they expect you to use mingw32 with the 64bit ghc (the tarball is named ghc-7.8.2-x86_64-unknown-mingw32.tar.bz2)
16:16:35 <lispy> yitz: I just updated my path so that their ld is first in my path and it looks cabal-install is building
16:16:56 <lispy> yitz: perhaps the 7.8.2 64bit release is working?
16:23:17 <Fuuzetsu> bitemyapp: I was under the impression that candidates didn't get their docs built by the doc builder
16:23:28 <bitemyapp> Fuuzetsu: a regular package didn't work either
16:25:05 <yitz> lispy: oh really? how confusing. maybe that's what did me in...
16:25:34 <Fuuzetsu> it might take a day or so for regular package to get the docs IIRC
16:25:50 <Fuuzetsu> I'm not on the Hackage team so I don't know for sure though
16:29:17 <hexagoxel_> danilo2: is it important that the type is a pure tuple? with a custom tuple type, it seems easy without Identity
16:30:50 <danilo2> hexagoxel: Right now I created 2 separate functions for conversions back and forth. As far as I know, we are unable to create custom tuple type, am I wrong?
16:31:18 <hexagoxel> http://ideone.com/k8FVUx
16:31:42 <hexagoxel> needs tfp (http://hackage.haskell.org/package/tfp)
16:31:56 <hexagoxel> danilo2: ^
16:32:21 <hexagoxel> i guess you could make those constructors infix as well
16:32:35 <augur> monad tutorials are awful, btw. all these absolutely horrible analogies. i cannot fathom why anyone thought those analogies were reasonable.
16:32:40 <lispy> yitz: the 2GB limit seems to be lifted. GHC is currently using almost 10GB of ram to compile this program...
16:33:07 <lispy> I might add, it never needed this much memory before
16:34:25 <hexagoxel> danilo2: it prints "(True,(1,()))" and "(1,(True,()))"
16:34:31 <danilo2> hexagoxel: Hmm, am I wrong? I think your example implements a List, not a custom tuple. So GHC will not optimize it the same way?
16:36:19 <hexagoxel> danilo2: but i put two different types in.. define "List" vs "Tuple"
16:36:41 <hexagoxel> tbh, i have not considered how much optimization is possible for that construct
16:36:55 <danilo2> hexagoxel: Additional, we are using there existential datatypes, to be able to for example show eleements - so this is not a tuple - It is just a list of values with some common functionality, like Show
16:37:21 <pavonia> johnw: decodeUtf8With works fine, thanks!
16:37:40 <danilo2> hexagoxel: I mean - If we pattern match on it, we cannot use any functions for these types unless they are common
16:39:42 <manuel__> sup
16:40:10 <hexagoxel> danilo2: i do not get if you are talking about my code or about your requirements
16:41:32 <yitz> lispy: when i wrote a program that just artificially consumed lots of memory it ran. our complex application crashed though. so it was so simple as just consuming the memory.
16:41:44 <hk3380> how do you write hotfixable code in an imperative language?
16:41:52 <hexagoxel> danilo2: TList (Cons Int (Cons Bool Null)) will not unify with the revert'ed type
16:41:53 <hk3380> is it enough to make all the functions referntially transparent?
16:42:03 <yitz> lispy: and ghc did compile it. it crashed at run time when the program itself consumed lots of memory.
16:42:49 <danilo2> hexagoxel: I'm sorry :) I'm talking about your code - If I'm not wrong, you have created something like List with values of different types, but If we for example pattern match on something of type (TList ...) , we are restricted only to the common functionality of all elements, like show
16:43:16 <danilo2> hexagoxel: Hmm, give me a second
16:43:18 <hexagoxel> no, you can extract single elements
16:43:27 <hexagoxel> not only existentially
16:44:20 <yitz> lispy: it was *not so simple as ...
16:44:49 <hexagoxel> tHead :: TList (Cons a b) -> a; tHead (TCons x _) = x
16:45:26 <xeno> so, how do I declare a datatype in ghci without doing all the declaration of Show?
16:45:39 <danilo2> hexagoxel: Oh, I probably did not get how it works on the beginning. What is "Types.Data.List" ? I cannot find where it lives
16:45:51 <hexagoxel> <hexagoxel> needs tfp (http://hackage.haskell.org/package/tfp)
16:45:55 <Guest9083> xeno: data Foo = Foo Bar Baz deriving (Show)
16:46:03 <xeno> oki
16:46:10 <Guest9083> oh
16:46:12 <Guest9083> ghci
16:46:30 <Guest9083> you have to put your data type definitions in a source file and load that into ghci
16:46:39 <hexagoxel> danilo2: i had to re-implement Reverse and Reverse', because tfp does not export Reverse' for some reason..
16:47:14 <hexagoxel> (where re-implement = copy-pase)
16:47:18 <hexagoxel> +t
16:49:03 <danilo2> hexagoxel: Hmm, interesting. How we can pattern match on it? If I add line "TCons a (TCons b TNull) = x", then GHC tells me, its brain exploded
16:52:34 <hexagoxel> danilo2: seems to work for me hmm
16:52:55 <hexagoxel> wait, maybe it needs type signatures
16:53:06 <hexagoxel> let me try inside an expression
16:53:32 <danilo2> hexagoxel: Hmmm, check this code: http://lpaste.net/103564  (the error is included)
16:54:21 <hexagoxel> ah yes i see
16:55:57 <johnw> right, use a case expression :)
16:57:07 <yitz> Guest9083: what's your real nick? looks like freenode is giving you some trouble today.
16:57:09 <hexagoxel> let val = case x of (TCons _ (TCons val _)) -> val
16:57:27 <pavonia> Switching from String to Text also made my program notably faster
16:57:34 <hexagoxel> i had not encountered that, good to know :)
17:00:43 <hexagoxel> danilo2: (btw this TList construct might already be implemented in some library, i do not have that good of an overview of existing type-level stuff)
17:01:16 <johnw> hexagoxel: https://hackage.haskell.org/package/tfp-0.8/docs/Types-Data-List.html?
17:01:32 <Eduard_Munteanu> Hm, I wish 'persistent' could derive via Data / Generic from existing definitions, because it seems odd to define types tied to the database. Any advice?
17:01:42 <danilo2> hexagoxel: Interesting. Thank you for the code! It is very valuable :) I will look for the TList contructo laso. I'm also wondering how the optimizations behave in comparison to tuples when using TList, but I think I have to measure it :)
17:02:42 <hae> Type functions, man. That's trippy.
17:03:20 <merijn> Type functions great! \o/
17:04:13 <benzrf> pipes seems cool
17:04:16 <Guest78905> yitz: EvanR
17:04:18 <benzrf> whats machines like
17:04:37 <benzrf> im looking at https://dl.dropboxusercontent.com/u/4588997/Machines.pdf but the step type decl kinda unhelpful
17:04:44 <benzrf> *is kinda
17:04:53 <Eduard_Munteanu> Type functions, trips and pipes. Sounds like something to be smoked. :)
17:05:31 <benzrf> mother
17:05:32 <benzrf> fuckin
17:05:33 <benzrf> pipe
17:05:33 <benzrf> s
17:06:00 <hexagoxel> johnw: but the TList GADT is still new, isn't it?
17:06:23 <benzrf> anybody here know Machines
17:07:06 <johnw> hexagoxel: I don't see how TList isn't just a plain list
17:07:18 <hiptobecubic> It has a T
17:08:07 <hexagoxel> are we arguing list-vs-tuple again? :D
17:08:19 <johnw> is it just that it's a type-heterogenous list?
17:08:33 <Guest78905> [Dynamic] ;)
17:09:07 <Guest78905> i still havent found an april fools or something implementation of php "array"
17:09:08 <hexagoxel> so.. whats the difference between a tuple and a type-heterogenous list
17:09:13 <hexagoxel> ?
17:09:32 <johnw> a type-heterogenous list has a "recursive type"
17:09:38 <johnw> it's a Fix of a tuple
17:09:41 <jmcarthur> Guest78905: i don't remember my PHP very well. would it just be Map Dynamic Dynamic or something?
17:10:03 <Guest78905> php array is a funny structure, its an ordered list of key value pairs
17:10:03 <jmcarthur> well, if Dynamic had an Ord instance
17:10:06 <johnw> oh, maybe not
17:10:19 <jmcarthur> Guest78905: you mean like an associated list?
17:10:21 <johnw> a Fix of a tuple only ends in a different type
17:10:34 <Guest78905> yes but has performance like a Map
17:10:48 <johnw> Guesthttp://hackage.haskell.org/package/acme-php-0.0.3/docs/Prelude-PHP.html
17:10:51 <Eduard_Munteanu> Guest78905: associative array would be a common name
17:11:14 <Guest78905> yeah i guess so, is there such a thing for haskell ;)
17:11:28 <johnw> (scratch that, it never ends)
17:12:03 <Guest78905> haha acme-php has promise
17:13:33 <Guest78905> data PHP = PHP [Dynamic] (Map Dynamic Dynamic)
17:13:36 <hexagoxel> Dynamic is runtime-type-checking though
17:13:53 <SrPx> I can't define "all" "even" etc?
17:13:54 <jle`> hm
17:14:01 <benzrf> php is grose
17:14:04 <Guest78905> haha
17:14:08 <jle`> SrPx: what happens when you do?
17:14:15 <jle`> does your computer shut down
17:14:17 <jle`> that happens to me |
17:14:18 <hexagoxel> HList might be more like it
17:14:22 <benzrf> php is the worst language currently in existence that isn't meant to be bad
17:14:33 <SrPx> jle`: nah it just tells me it is ambiguous
17:14:38 <benzrf> and that has a reasonable number of users
17:14:39 <jle`> well
17:14:43 <jle`> there's also all and even from Prelude
17:14:48 <jle`> so if you use it, you have to tell which one you want
17:14:53 <jle`> or you can import Prelude hiding (all, even)
17:15:03 <jle`> it's just like defining a function called map
17:15:09 <SrPx> jle`: yeaa I know... I'm not using Prelude at all, how do I deactivate it
17:15:13 <SrPx> oh
17:15:19 <SrPx> how?
17:15:23 <erisco> import Prelude ()
17:15:30 <jle`> import Prelude hiding (all, even) if you just want to hide all and even
17:15:40 <jle`> or {-# LANGUAGE NoImplicitPrelude #-}
17:15:42 <Eduard_Munteanu> {-# LANGUAGE NoImplicitPrelude #-}  is another option too.
17:15:43 <hae> PHP is a recursive acronym! People Hate PHP.
17:16:21 <SrPx> How do I import $ from prelude? import Prelude ($) turned my pc off :C
17:16:37 <Eduard_Munteanu> SrPx: (($))
17:16:38 <jorr> (($))
17:16:40 <SrPx> ty
17:16:47 <jle`> it's the batman sign
17:16:53 <Eduard_Munteanu> Heh.
17:16:53 <pavonia> SrPx: I think you can also qualifiy your function with MyModuleName.even
17:17:06 <Eduard_Munteanu> SrPx: one parens for the import list and another for the operator name
17:17:32 <hae> No wonder, you're using OS X, SrPx.
17:17:59 <SrPx> Not in scope: * ++ replicate + show False True... oh. lol, ok, I guess I'll go with the hide option
17:18:37 <hexagoxel> danilo2: btw let me know if you have any profiling results :)
17:19:35 <SrPx> hae: sorry for the delay I was looking at the other quarter of my 2880x1800 screen
17:19:40 <SrPx> hae: what you was saying again?
17:19:51 <danilo2> hexagoxel: Ok, I will. I will not profile it today (3 amm here), but I'll write back :) have a good night! :)
17:20:22 <hae> Nothing.
17:20:28 <hexagoxel> night :)
17:20:28 <SrPx> hae: :P
17:20:43 <SrPx> all working, thanks guys
17:20:46 <SrPx> night hae
17:20:51 <SrPx> hexagoxel *
17:21:03 <hae> Good night.
17:25:11 <EvanR> im trying to implement a game and the state of frp is annoying me
17:25:29 <jle`> im sorry EvanR
17:25:47 <jorr> I always feel like it's the state of my brain and frp is okay
17:25:47 <EvanR> have you had any positive experiences
17:25:58 <jorr> I've had some fun with netwire
17:26:19 <EvanR> yeah that seems like the most practical one
17:26:33 <jle`> i enjoy frp, but i wonder if in a year or so i will begin being annoyed
17:26:43 <jorr> I made a game where I could fly around a little triangle spaceship :)
17:26:52 <jorr> it was surprisingly entertaining
17:27:13 <jle`> i wrote an RTS to see if i could tackle the dynamic wires problem
17:27:20 <jle`> and the communication problem
17:27:39 <jorr> yeah I had issues with dynamic wires too... don't recall the resolution
17:27:46 <jorr> I was doing a component-entity-system design, which I really like
17:27:50 <EvanR> yes the blogs are rife with discussions about "dynamic collections" and this seems like a totally bogus abstraction
17:27:57 <jle`> it took me a month or two but...
17:27:59 <jle`> i think i tamed it
17:28:20 <jle`> maybe.
17:28:30 <EvanR> yampas dynamic collections ends up just being OOP
17:28:34 <jle`> planning on publishing later once i get more
17:28:37 <jle`> well
17:28:51 <jle`> as a side project i wrote an IRC bot using declarative style inspired by FRP with discrete time
17:29:05 <jle`> and i had to deal with dynamic collections when users opened stateful channels of communication
17:29:08 <jle`> ad-hoc
17:29:30 <jle`> and the whole thing was resolved pretty well i think, in that small test tube environment
17:29:51 <jle`> in what i felt was an elegant way...but...not sure if it will scale, and i haven't done any benchmarking either
17:30:04 <EvanR> an irc bot seems like a idea that can be broken down into a state machine
17:30:10 <jle`> yes it can
17:30:15 <EvanR> rather than a continuous time simulation
17:30:28 <jle`> well, the point wasn't for continous time
17:30:31 <jle`> the point was for declarative semantics
17:30:39 <jle`> instead of stateful/imperative ones
17:30:51 <EvanR> yeah thats good
17:30:55 <jle`> instead of a bunch of "this is how you modify the state when this happens", and just applying them over and over again
17:31:15 <EvanR> sort of like a web app
17:31:17 <jle`> laying out high-level declarative stuff on how things should be, how this is, what is constant...
17:31:27 <EvanR> request, response
17:31:29 <jle`> that's one of the main advantages of frp for me
17:32:02 <jle`> hm i wouldn't call it request/response, but i might be misunderstanding your usage
17:32:17 <EvanR> im interesting in continuous semantics
17:32:17 <EvanR> interested
17:33:35 <jle`> for me, it is a high level declarative framework and an abstracted localized state
17:34:01 <jle`> i like the continuous time semantics, too, of course
17:34:20 <jle`> but i think if you drop it, you still have something immensely useful
17:35:01 <jle`> also one neat thing about frp is that it's still in a state of active research...which might be also what is contributing to your frustration
17:35:09 <jle`> who knows how things will be in a year
17:35:16 <EvanR> i read what papers i could find about it
17:35:31 <EvanR> commendable work has been done
17:36:01 <EvanR> functional animation in particular makes a lot of sense
17:36:27 <EvanR> but that just produces a demo, not an interactive behavior
17:37:07 <jle`> it's cute :)
17:37:27 <jle`> thinking about how far we have come
17:40:49 <jle`> EvanR: what problems were you running into?
17:41:15 <erisco> jle`, what is the communication problem?
17:41:36 <jle`> erisco: i made up the name myself
17:41:37 <benzrf> anybody here help me understand the types in https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
17:41:39 <benzrf> pls?
17:42:05 <erisco> jle`, so what is the communication problem?
17:42:12 <jle`> um...it's how two "entities" in the game can communicate to eachother and affect eachother, without falling back on unique id's
17:42:21 <haasn> benzrf: What type do you need help with?
17:42:28 <benzrf> for one
17:42:31 <athan> is there such thing as a co-closed form?
17:42:31 <benzrf> Step k o r
17:42:33 <EvanR> i have no problem with using unique ids
17:42:38 <jle`> i do :)
17:42:42 <jle`> it's a personal thing.
17:42:49 <haasn> benzrf: And which part of it do you need help with?
17:42:50 <benzrf> by using the Machine newtype, a Step yields a new step
17:42:55 <benzrf> i'm assuming the r is for recurse?
17:43:10 <athan> jle` It's kinda like an inner mechanic, or should be, to me :)
17:43:12 <benzrf> anyway, Stop and Yield make sense
17:43:17 <benzrf> Stop, the machine is done
17:43:19 <haasn> Probably “result”
17:43:21 * hackagebot timezone-series 0.1.3 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.3 (YitzGale)
17:43:22 <athan> same with terms, maybe, too
17:43:30 * hae has just been struck by inspiration
17:43:31 <benzrf> Yield, it sends out an o and gives another machine
17:43:32 <jle`> there is that old yampa paper with boxes and that one with space invaders, which uses id's to do everything i think
17:43:35 <benzrf> but
17:43:41 <benzrf> Await confuses me!
17:43:46 <EvanR> im more interested in having the source code closely resemble some mathematical model of the behavior of the game rather than operational semantics of some even-crunchier-than OOP machinery
17:43:50 <benzrf> why does it have /two/ potential r's?
17:43:55 <haasn> benzrf: The right one is for failure
17:43:58 <benzrf> why have (t -> r) and (k t)
17:44:01 <benzrf> haasn: o=
17:44:04 <jle`> ID's feel very oop/state machine to me
17:44:11 <jle`> it's basically pointer equality/addressing
17:44:14 <benzrf> what does the k mean
17:44:15 <haasn> If the “k t” request fails, go into the single “r”, if it succeeds with something of result “t”, pass it to the “t -> r”
17:44:21 <haasn> k means whatever you want, for example IO
17:44:24 <benzrf> 'request'?
17:44:31 <benzrf> ahs
17:44:33 <jle`> when you express relationships in math, you don't assign every shape an ID
17:44:35 <benzrf> *ah
17:44:44 <jle`> you do'nt assign every identity an id that is pulled from some stateful counter somewhere
17:44:45 <benzrf> so the (k t) is the thing that takes in the input
17:44:48 <erisco> jle`, what is the essence of your solution? presumably the knee-jerk way to do it would be to lookup entities in a map, which would require a unique ID as you suggest
17:44:55 <haasn> But k could also be something fancy like “Is x”, given “data Is x y where Refl :: Is a a”
17:45:03 <EvanR> jle`: you certainly use indexes in describing summations
17:45:09 <benzrf> then the t is passed to the (k -> r) to produce the next step?
17:45:11 <manuel__> how long did it take you people to feel confident in haskell?
17:45:18 <benzrf> why not just have (k r) then?
17:45:19 <manuel__> a few days? a few weeks? a few months?
17:45:29 <jle`> EvanR: yeah, but that assumes some sort of inherent ordering in your collection
17:45:34 <fryguybob> manuel__: Two years.
17:45:38 <EvanR> yeah thats just an example
17:45:47 <jle`> in cases wher ethere is ordering, go ahead
17:45:50 <manuel__> fryguybob: doing haskell everyday? what was your first substantial project?
17:45:50 <EvanR> another is let x be an element of the set, then something something about x
17:46:19 <benzrf> haasn: ?
17:46:25 <EvanR> you wouldnt ever see any ids, whoever they are implemented or assigned, in the source code itself
17:46:31 <EvanR> its just a variable
17:46:34 <haasn> benzrf: Maybe it has something to do with functor/monad instances and stuff, but it might also be an efficiency concern
17:46:41 <fryguybob> manuel__: That was while learning it on the side.  My first substantial project was building a parser for a DLS that generated a particular kind of diagram.
17:46:42 <benzrf> huh...
17:46:47 <jle`> erisco: i've tried a few things, but one thing is to store entities in a map but abstract away the key so the user can't access it
17:47:08 <jle`> there are unique id's but they are not a part of the exposed api
17:47:10 <benzrf> so the far-right r in Await is for 'failure
17:47:14 <benzrf> what does that mean
17:47:17 <benzrf> why not just a Stop then?
17:47:18 <impure> Is there a "Flattenable" haskell class? I want to take arbitrary objects, flatten them to a list of some item type I expect, then operate on that item type.
17:47:25 <EvanR> the user is the programmer?
17:47:25 <haasn> benzrf: So you can have alternatives
17:47:29 <benzrf> oh wait i see
17:47:36 <benzrf> so the caller can choose whether to feed or stop?
17:47:44 <manuel__> fryguybob: what do you use it for nowadays?
17:47:48 <jle`> EvanR: yes, the programmer and not the framework authors
17:47:56 <EvanR> surely
17:48:04 <benzrf> haasn: how do machines compare to pipes?
17:48:12 <benzrf> ive been looking at the docu for !$ recently and it looks neat
17:48:12 <erisco> jle`, mm, so it is the semantics you are trying to improve
17:48:17 <jle`> erisco: yeah
17:48:28 <jle`> maybe i sohuld have made that clearer :)
17:48:30 <fryguybob> manuel__: Well, it has changed the way I think about CS.  So I think in terms of Haskell now.
17:48:36 <haasn> benzrf: For example, say you have a machine that implements “cat”; you first have a machine that Awaits all the input it can from one file, and as soon as that hits EOF, it moves on to the next file (instead of stopping)
17:48:44 <manuel__> fryguybob: what’s your dayjob language? is it haskell now?
17:48:45 <fryguybob> manuel__: I contribute to the diagrams project and hack on GHC
17:48:58 <fryguybob> manuel__: I'm a grad student now.
17:49:02 <jle`> the idea is to only be able to act on the "map" as a whole, and to allow entities to deal with the entire map...and filter out elements that they don't want to send messages back to
17:49:10 <haasn> benzrf: afaik newer pipes is very similar to machines in theoretical power, but machines is a bit more abstract
17:49:16 <benzrf> o;
17:49:17 <fryguybob> manuel__: I was using C# mostly and some C++
17:49:25 <EvanR> jle`: it seems straight forward to me to write code "when your path crosses one of the enemies in the path (if ever), namely Maybe (T,Enemy), then kill that enemy"
17:49:26 <jle`> and then at the end, do a giant accumulation of all the filtered output maps back into the map wire
17:49:28 <benzrf> the types confuse me less T_T
17:49:50 <jle`> this way you can even only pass submaps to someone if you want to only allow them to access a portion of it
17:49:54 <EvanR> jle`: the idea of message passing to me is totally inappropriate for functional programming
17:50:02 <haasn> benzrf: iirc you can implement a Proxy (the pipe type) using a Machine with some carefully picked ‘k’ that gives the extra cahnnels
17:50:03 <hae> ^
17:50:08 <athan> EvanR: I think it could be represented as a web app, considering the shared states and each host being a user interface or something, I think
17:50:15 <jle`> EvanR: hm
17:50:24 <haasn> benzrf: Proxy comes with 3 extra channels of communication “built in”
17:50:40 <manuel__> i did a lot of functional programming as in “pure” back then, in ML, scheme and “kind of” in CL
17:50:45 <manuel__> nowadays a lot in javascript
17:51:07 <benzrf> hmmm
17:51:14 <manuel__> I wonder if the whole other part of haskell that I don’t understand well yet (combinators, monads, etc…) will actually have an influence on my daily programming
17:51:17 <jle`> EvanR: is that your ideal interface, or what you have now?
17:51:20 <Earnestly> Since none of those lanuages are pure, how are you defining pure?
17:51:26 <benzrf> manuel__: to understand monads you must use them
17:51:28 <EvanR> jle`: if on the other hand we consider a simulation as a bunch of concurrent communicating agents, then this makes total sense, but i do not know if this lends itself to a wholistic declarative description
17:51:29 <haasn> benzrf: Also, pipes handles side effects slightly differently
17:51:36 <benzrf> manuel__: write some programs that use monads :-)
17:51:38 <manuel__> well monads is kind of easy because it actually mirrors
17:51:41 <athan> EvanR: I agree. Recursion is like the closed form of iterative programming with a defined purpose
17:51:43 <Earnestly> To understand monads, stop trying to learn about monads...
17:51:44 <haasn> Again, making it a bit less general
17:51:50 <manuel__> method combination in common lisp, and a lot of javascript libraries
17:51:59 <jorr> manuel__: once you get functors / monads / etc you're going to hate not having them in other languages
17:52:00 <benzrf> manuel__: method combo in lisp?
17:52:05 <benzrf> what is this
17:52:07 <EvanR> jle`: i have something like it, but i am reconstructing the game from some state whenever i want to modify the behavior due to simuli
17:52:31 <manuel__> benzrf: you can specify how CLOS methods are called and how they are combined, for example the list monad is a standard method combination in common lisp
17:52:44 <benzrf> link to what u mean
17:52:46 <benzrf> please?
17:52:57 <manuel__> http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node287.html
17:52:59 <jle`> EvanR: that's a good point.
17:53:25 <benzrf> hm
17:53:26 <manuel__> you can basically write a piece of code that describes how calls to methods are combined, which is pretty much what monads do too (conceptually)
17:53:31 <manuel__> as in program the composition of computation
17:53:32 <benzrf> manuel__: sort of.
17:53:44 <manuel__> it’s not the same i know, but it’s the same concept
17:53:59 <manuel__> same with callback chaining approaches in javascript, or tree walking combinator libraries or what not
17:54:16 <manuel__> anyway, it is interesting, i wonder how much i will take away from it
17:54:25 <EvanR> jle`: after a few weeks of banging my head on the wall, this seems like the most genuine way
17:54:28 <fryguybob> manuel__: One easy way to find out :D
17:54:29 <benzrf> manuel__: i usually think of monads as being a way of letting pipeline steps have some kind of influence over the overall computation
17:54:32 <benzrf> well
17:54:34 <benzrf> if i am forced to put it into word
17:54:34 <erisco> jle`, did you encounter problems with controlling the order in which entities are updated?
17:54:34 <benzrf> s
17:54:42 <benzrf> i cant really verbalize my intuition :\
17:54:49 <jle`> EvanR: i'm eager to try and get my hands wet in this again come summer
17:54:52 <manuel__> haha
17:55:36 <impure> What's the most generic method to take an [a], [[a]], or [[[a]]], and return a sum of the a's?
17:55:52 <manuel__> for example the list monad would be the append method combination in common lisp, the result of (CALL-NEXT-METHOD) is appended to the current result, etc...
17:55:53 <impure> Where I don't care what the container type is.
17:56:00 <jle`> the 'declarative' thing i had had in mind was, say, to "declare the behavior" of a watch tower, give it the behavior of your collection of enemies, and then the behavior is reflected as which of the collection of enemies it tries to kill
17:56:31 <benzrf> impure: monads, of course!
17:56:36 <benzrf> wait maybe
17:56:40 <jle`> impure: well
17:56:41 <fryguybob> manuel__: For myself, reading sigfpe's blogs and conal's papers helped me get a feel for how my thinking could change.
17:56:41 <benzrf> impure: please explain what you mean exactly
17:56:43 <benzrf> maybe functors?
17:56:47 <jle`> impure: what would your type be?
17:56:59 <jle`> [a] -> a and [[a]] -> a have to be different functions
17:57:04 <manuel__> conal elliott?
17:57:04 <jle`> unless you use some sort of typeclass magic
17:57:09 <fryguybob> manuel__: Yes
17:57:09 <impure> benzrf,jle`: The leaf type isn't know ahead of time, it's just a Num.
17:57:24 <EvanR> jle`: but its still pretty bad, the more state i need to represent (explicitly) to restore a behavior at any point, the more i feel like im just barely doing a game of the form (Maybe Input) -> S -> S, not continuous time
17:57:29 <fryguybob> manuel__: He is in here sometimes as conal
17:57:41 <jle`> impure: i mean, any function [a] -> a and [[a]] -> a and [[[a]]] -> a must be different functions, because they have different type signatures
17:57:42 <impure> benzrf,kle`: And the container types can be nested in any way.
17:58:00 <manuel__> how many exercises are there on exercism.io for haskell?
17:58:01 <benzrf> impure: nested containers cannot be handled generally
17:58:02 <benzrf> usually
17:58:07 <impure> jle`: Yes, but I can define a class that, say, produces a flattened list...
17:58:21 <benzrf> impure: you can use join on lists, at least
17:58:23 <jle`> you can, but you should think very hard
17:58:27 <benzrf> but you cant use it recursively
17:58:31 <jle`> about if that's what you really want
17:58:44 <benzrf> check:
17:58:52 <jle`> because resorting to typeclass hackery is in general something to avoid
17:59:05 <athan> impure: Can you reduce a cyclic structure? :)
17:59:09 <athan> maybe into tuples?
17:59:15 <benzrf> > let joinN 1 l = l; joinN n l = joinN (n - 1) (join l) in joinN 2 [[1, 2, 3]];
17:59:16 <lambdabot>  <hint>:1:77: parse error on input ‘;’
17:59:20 <benzrf> oh wait
17:59:20 <athan> or...
17:59:21 <benzrf> > let joinN 1 l = l; joinN n l = joinN (n - 1) (join l) in joinN 2 [[1, 2, 3]]
17:59:22 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ m a1
17:59:22 <lambdabot>  Expected type: m (m a1)
17:59:22 <lambdabot>    Actual type: m a1
17:59:22 <lambdabot>  Relevant bindings include
17:59:22 <lambdabot>    l :: m a1 (bound at <interactive>:1:28)
17:59:23 <athan> a knot? :S
17:59:25 <hae> You want hackery? Try type functions.
17:59:31 <benzrf> impure: infinite type
17:59:52 <jle`> erisco: the entities are supposed to be updated in parallel
17:59:54 <impure> benzrf: Hmmm. infinite type. I've seen an error that said that before...
18:00:06 <jle`> > let f x = x : x in f 3
18:00:07 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ [a1]
18:00:07 <lambdabot>  Relevant bindings include
18:00:07 <lambdabot>    x :: a1 (bound at <interactive>:1:7)
18:00:07 <lambdabot>    f :: a1 -> [a1] (bound at <interactive>:1:5)
18:00:17 <benzrf> an infinite type is one that's infinitely recursive
18:00:20 <erisco> jle`, does that mean that each entity can only see the previous game state?
18:00:43 <jle`> erisco: i'm using afrp, so game state is sort of abstracted away
18:00:46 <benzrf> sup LearnHaskellMe
18:00:52 <LearnHaskellMe> hi all.
18:00:53 <jle`> um
18:00:55 <erisco> jle`, that is okay. it is still there ;)
18:00:57 <LearnHaskellMe> Hell benzrf
18:01:03 <jle`> the main magic is
18:01:10 <LearnHaskellMe> Er sorry I mean Hello benzrf
18:01:30 <LearnHaskellMe> Small difference between hell and hello ;)
18:01:44 <jle`> wireMap :: [Wire a b] -> Wire (IntMap a) (IntMap b)
18:01:50 <EvanR> jle`: right, that is a feature of these libraries is that the internal state is maintained, but the more dynamic the simulation the more it seems like OOP
18:02:24 <EvanR> especially when you bring up this "communication problem"
18:02:59 <jle`> well this part is not quite dynamic, the interface is kind of a straightforward generalization of the arrow concept i think, condensing arrows into collections of arrows
18:03:15 <jle`> but i will give this a long and hard thought
18:03:34 <jle`> i have an appointment now, but thanks for the insight
18:03:37 <EvanR> so seems like the holy grail is sitting in some perhaps impossible middle ground between game state endofunctor representation, and classic imperative OOP (or concurrent message passing agents)
18:03:52 <jle`> well
18:03:58 <LearnHaskellMe> Is it possible to hire a coder who will teach me the basics of haskell? I want something more structured than go look at this tutorial to help me get moving. I don't see any online classes I can enroll in either.
18:04:08 <EvanR> i mean to say, endomorphism
18:04:11 <jle`> the entire idea of AFRP is to chain together (in a possibly recursive way) different wires
18:04:12 <benzrf> how is afrp vs reactive banana
18:04:14 <erisco> LearnHaskellMe, what about a book?
18:04:23 <erisco> jle`, btw what is afrp?
18:04:24 <jle`> hook them all up in a way
18:04:24 <benzrf> LearnHaskellMe: ill attempt to learn you some haskell if u like
18:04:35 <Earnestly> This is somewhat fun: http://dev.stephendiehl.com/hask/
18:04:48 <EvanR> jle`: yeah i saw that, i invented something like this along the way, with a fancy backend to construct the necessary TVars from the pure expression
18:04:50 <jle`> so, the wireMap is a way to funnel many different wires into one collection of wires
18:05:01 <jle`> EvanR: neat
18:05:06 <EvanR> but such a network cant/shouldnt be modified physically, it seems insane
18:05:07 <jle`> erisco: arrowized frp
18:05:07 <benzrf> 09:02 < benzrf> how is afrp vs reactive banana
18:05:13 <jle`> a la netwire, yampa, etc.
18:05:22 <LearnHaskellMe> erisco: Are there any which even go half way there? benzrf: You mean follow the book?
18:05:37 <jle`> i sometimes use it (incorrectly) in contrast to reactive banana/sodium
18:05:39 <benzrf> LearnHaskellMe: no i mean help you learn haskell
18:05:47 <benzrf> i deliberately misgrammared in reference
18:05:48 <erisco> LearnHaskellMe, half way to what?
18:05:49 <jle`> which i have heard called 'push-pull frp'
18:06:24 <jle`> i like the term push-pull but i guess the appropriate contrasting term would be continuous-time semantics frp
18:06:30 <jle`> and afrp being one implementation of such
18:06:34 <LearnHaskellMe> erisco: To teach haskell to a beginner without getting lost in the syntax or on the way to writing your own software.
18:06:35 <jle`> one way of implementing such
18:06:57 <indigo> bitemyapp: Great work on the ElasticSearch lib! (I just saw it on the front page of HN)
18:07:07 <jle`> although i use a lot of afrp mechanics for discrete-time semantics frp so i don't even know anything anymore
18:07:26 <benzrf> hmmm in what way are arrows a generalization of monads?
18:07:43 <erisco> jle`, often in games two entities can be dependent on each other which can be a problem for some entity systems
18:07:57 <EvanR> jle`: signals that "discontinously" change value at particular non dense times makes sense
18:08:05 <EvanR> you can use the to make state machines
18:08:12 <jle`> erisco: oh, i thought you meant within the same collection
18:08:25 <jle`> erisco: yeah i do run into problems with ordering of different collections updating
18:08:29 <bitemyapp> indigo: thanks!
18:08:37 <jle`> top of hn, good work :)
18:09:54 <hae> From "Fun with type functions": "A popular, if incestuous, application of Haskell is for writing compilers."
18:10:10 <Eduard_Munteanu> Hah.
18:10:33 <EvanR> the classical music in this coffee shop is deafeningly loud
18:11:13 <benzrf> EvanR: you're in a coffee shop?
18:11:16 <benzrf> shouldn't you be writing ruby?
18:11:20 <jle`> haha
18:11:28 <hae> Parsec is probably like 80% responsible for that.
18:11:33 <EvanR> lol
18:11:34 <hae> Lol yes or node.js.
18:11:45 <benzrf> cmon dont lump in ruby w/ node.js
18:11:46 <EvanR> hell no, thats what i do at work all day
18:11:47 * benzrf uses ruby
18:13:30 <hae> I used to use Ruby like you. Then I found static typing.
18:13:38 <hae> Seriously though Ruby is cool.
18:13:39 <lispy> http://lpaste.net/103565 -- could I get some folks with ghc 7.8.2 to try compiling this example.
18:13:48 <lispy> On my machine that example takes pretty much infinite ram
18:13:50 <hae> If any language does OO right, it's Ruby.
18:14:05 <EvanR> uhg no
18:14:07 <lispy> shachaf: do you have a minute to try out my paste?
18:14:11 <EvanR> but thats off topic
18:15:44 <benzrf> hae: ruby is like if you took the good parts of perl, grafted them to smalltalk, then made it a standard interpreted language instead of being image based
18:16:05 <EvanR> good parts of perl?
18:16:26 * EvanR back to head smashing
18:16:40 <benzrf> :-D
18:16:59 <hae> Exactly, benzrf.
18:17:15 <benzrf> perl is the epitome of 'quick & dirty'
18:17:22 <benzrf> haskell is basically the polar opposite
18:17:34 <jle`> perl's tight integration with the os is what i would call its good parts
18:17:40 <Earnestly> Perl is not "quick and dirty" and wasn't designed as such
18:17:41 <jle`> but we are probably reciting from the same blog post
18:17:46 <hae> In Perl, all lists of lists are automatically concatenated!!!
18:17:56 <benzrf> jle`: i was talking more about the slightly more quick and less dirty parts
18:17:57 <hae> Three words. WTF.
18:18:07 <benzrf> hae: ITS CONVENIENT :-D :-D :-D
18:18:25 <Fuuzetsu> I hope you're joking about that
18:18:29 <Fuuzetsu> I'm sure there's a Good Reason™
18:18:30 <EvanR> do what larry wall means, not what i want
18:18:31 * benzrf hides
18:18:45 <jle`> https://sites.google.com/site/steveyegge2/tour-de-babel
18:18:46 <benzrf> EvanR: ima borrow that one
18:19:01 <hae> Do I look like I'm joking? :|
18:19:43 <hae> I actually had that link bookmarked, by the way.
18:21:30 <Earnestly> Sigh, superficial
18:22:22 <Earnestly> And full of ignorance and no historical context, modern internet intelligence in a nutshell.  Oh, and mix in some snarky sarcasm for good measure
18:22:26 <lispy> shachaf: if you do try it, I thnk it needs at least -O1 and -prof
18:23:24 <jle`> isn't it neat that functions like map only need to be compiled twice and can work for all types
18:24:17 <jle`> in C++, template polymorphism basically means the exact same class is compiled once for every single type you ever use it with
18:24:38 <EvanR> yeah but map's polymorphic type is a different kind of polymorphism
18:24:48 <EvanR> haskell instances are the same way
18:25:13 <jle`> oh yeah :/
18:25:15 <EvanR> wait
18:25:40 <EvanR> nevermind, c++ does that because of the unboxedness in general
18:25:49 <jle`> yeah, it is the box system that allows ghc to do it
18:25:58 <startling> jle`, what? you still have to compile the implementation for every type
18:26:06 <jle`> for map?
18:26:16 <startling> oh, I was thinking that you mean fmap.
18:26:20 <jle`> is map compiled once for every type you use it with? :(
18:26:21 <jle`> oh ok
18:26:31 <jle`> yeah i was not very clear with my qualifications
18:35:40 <lispy> shachaf: even more specifically, -fprof-auto -prof -O1
18:36:08 <gamegoblin> Fun fact: C++ templates are a turing complete functional language evaluated at compile time, which I find absolutely hilarious.
18:36:32 <benzrf> gamegoblin: somebody made a brainfuck impl using stl or something
18:36:43 <benzrf> gamegoblin: the output of the brainfuck prog is the error message when you try to compile
18:36:47 <EvanR> i should implement my game in c++ templates at compile time
18:36:51 <gamegoblin> Bahahahahahaha
18:37:56 <benzrf> https://github.com/knome/metabrainfuck/blob/master/bf.cpp
18:38:00 <gamegoblin> Any time I see domain specific languages, such as templating, wind up being turing complete, I get really suspicious of their implementation
18:38:04 <benzrf> line 2:
18:38:07 <benzrf> // Wherein we develop a comprehensive mathematical proof of the inexistance of a merciful god //
18:38:33 <LearnHaskellMe> Lol.
18:42:20 <hae> Template Haskell: Expand Your Mind In Ways It Was Never Meant To Be Expanded
18:45:02 <benzrf> hae: lel
18:45:59 <lispy> in case anyone has 7.8.2 and wants to try reproducing my problem: https://ghc.haskell.org/trac/ghc/ticket/9073
18:47:27 <johnw> lispy: I'll try it
18:47:38 <lispy> johnw: thanks!
18:47:44 <lispy> johnw: i'm going to dinner, so afk
18:48:03 <johnw> ah, I don't have profiling libs built
18:48:09 <johnw> does that matter?
18:48:25 <johnw> also, do you have a main function?
18:48:44 <carter> lispy: is ths one of those things that go away when you do -fno-full-laziness?
18:49:03 <johnw> ah, I see
18:54:35 <hae> You know I wonder how much they use Haskell on Gentoo.
18:54:52 <hae> If you think about it it seems like a perfect fit.
18:56:59 <gamegoblin> Why?
18:58:03 <Just_ShockSpock> haskell on LFS seems an even tighter fit
18:58:06 <spintronic> where do you guys think would be a good place to ask some basic questions about linear temporal logic?
18:58:07 <Yaniel> because cabal and compiling things yourself
18:59:13 <Just_ShockSpock> spintronic: #logic?
18:59:22 <Just_ShockSpock> just a guess
18:59:30 <EvanR> haskell on freeBSD, because ports
18:59:39 <carter> LFS?
18:59:40 <carter> w ahts that
18:59:50 <zacts> Linux From Scratch
19:00:04 <jorr> surely haskell on nixos, because purity(ish)?
19:00:07 <Just_ShockSpock> ya the BSD haskell sounds good
19:00:22 <spintronic> Just_ShockSpock: #logic exists. Thanks!
19:00:32 <EvanR> purely functional OS, no IO support ;)
19:00:49 <Just_ShockSpock> it was only logical
19:00:54 <gamegoblin> “Without IO, you can only simulate a solipsistic philosopher”
19:00:59 <jorr> :)
19:01:44 <Just_ShockSpock> gamegoblin: say that simulate solipsistic philosophera really fast three times
19:02:04 <gamegoblin> I just did. It went /ok/.
19:02:18 <lispy> carter: I haven't tried that one
19:02:20 <gamegoblin> “simulate sollilililiilistic philsopher"
19:02:25 <Just_ShockSpock> I had trouble typing it :>
19:02:36 <carter> lispy: i know that fixed a blowup in text / attoparsec
19:02:40 <gamegoblin> It doesn’t help that I actually have a stutter in real life.
19:02:43 <carter> ermm
19:03:15 <Just_ShockSpock> too funny, I''m such an incensative cold!
19:03:27 <Just_ShockSpock> *clod
19:03:29 * hackagebot persistent-odbc 0.1.2.2 - Backend for the persistent library using ODBC  http://hackage.haskell.org/package/persistent-odbc-0.1.2.2 (gbwey)
19:03:43 <shachaf> lispy: Which paste?
19:04:10 <shachaf> lispy: Oh, I left my GHC 7.8.2 computer at home.
19:06:19 <lispy> shachaf: it's in your other pants?
19:07:13 <shachaf> lispy: What was the question?
19:07:29 <Just_ShockSpock> anyone have haskell on lfs?
19:07:47 <EvanR> used to
19:08:10 <hae> I recently updated to 7.8.2 on Arch. It wasn't easy.
19:08:21 <gamegoblin> Just_ShockSpock: lfs?
19:08:42 <hae> ArchHaskell still needs to bump most of their packages; I had to alter a couple of PKGBUILDs myself.
19:08:44 <Just_ShockSpock> zacts knows, linux from scratch
19:09:01 <EvanR> gotta love arch
19:09:04 <benzrf> ew arch
19:09:27 <hae> ^ perfect example of polarization towards my distro
19:09:41 <Just_ShockSpock> ya arch was great until it lost the arch way
19:09:52 <hae> What do you mean?
19:10:01 <Just_ShockSpock> it became infected
19:10:26 <hae> Not really following.
19:10:35 <Just_ShockSpock> there is a bsd fork of arch
19:10:44 <EvanR> #haskell-blah
19:10:54 <Just_ShockSpock> hint: not a big fan of systemd
19:10:56 <gamegoblin> EvanR: heh
19:11:20 <hae> Oh okay I get it.
19:13:12 <hae> They also have Arch Hurd for extreme diehards.
19:13:21 <Just_ShockSpock> but more to the topic, its nice to find out how haskell is running on different os systems
19:13:25 <EvanR> hahaha
19:13:37 <Just_ShockSpock> would like to port it to minix
19:13:50 <LearnMeHaskell> We all know that Hurd will be ready in 2222 and will be the best kernel.
19:13:51 <EvanR> does haskell run on toasters yet?
19:13:52 <yitz> i didn't use arch at the time, but when dons was still active in the community, arch was probably the best supported haskell platform.
19:14:02 <gamegoblin> We need to band together as a community and write HaskellOS! COME ON GUYS
19:14:09 <carter> on whose time :)
19:14:12 <EvanR> unsafeLaunchToast
19:14:35 <gamegoblin> Aren’t there a few haskell os hobby projects?
19:14:48 <hae> ^ EvanR lol.
19:15:02 <LearnMeHaskell> Haskell OS.
19:15:20 <hae> I downloaded a "Lisp OS" one time out of curiousity. Wasn't very... interactive.
19:15:28 <LearnMeHaskell> House.
19:15:36 <EvanR> HOS
19:15:39 <gamegoblin> Anyone tried TempleOS/SparrowOS/LoseTheOS ?
19:16:13 <benzrf> hurd will always win
19:16:17 <Just_ShockSpock> haskell os on my toaster :)
19:16:17 <gamegoblin> The one programmed in straight x86 by a guy with some mental problems
19:16:17 <benzrf> it's so hurd
19:16:34 <LearnMeHaskell> lol
19:18:09 <hae> House has apparently been dead for five years.
19:18:32 <LearnMeHaskell> hae: you mean the tv series?
19:18:45 <hae> No...
19:18:54 <EvanR> haskell OS would be a major reimplementation of haskell
19:19:17 <Just_ShockSpock> too hilarious
19:21:49 <EvanR> if you have an infinite list, and you have the start of the list, and something is traversing the whole thing you will end up with a space leak. is there a way to "copy" the unevaluated list before evaluation so multiple things can independently traverse it in constant space?
19:22:03 <benzrf> gamegoblin: i have heard it described by the creator as being like dos but for modern
19:22:10 <benzrf> i.e. all ring 0
19:22:26 <gamegoblin> benzrf: It is. He has some videos up of him using it. A friend of mine installed it on a VM.
19:22:42 <benzrf> o:
19:22:47 <benzrf> that guy has issues
19:23:00 <gamegoblin> Yes he is apparently schizoaffective
19:23:03 <LearnMeHaskell> house is like dos?
19:23:18 <gamegoblin> LearnMeHaskell: No, TempleOS, LoseTheOS, SparrowOS
19:23:31 <gamegoblin> (various names of the same project)
19:23:49 <benzrf> no it's LoseThos apaprently
19:23:53 <benzrf> *apparently
19:23:55 <benzrf> not LoseTheOS
19:24:00 <gamegoblin> I think it’s currently TempleOS
19:24:27 <gamegoblin> The guy made a variant of C he calls Holy C. One aspect of it I like is that ints are indexible so I can say myInt[3] and get the 3rd byte in the int.
19:24:30 <LearnMeHaskell> I wonder how much time a rewrite of the Win98 clone will take in Haskell.
19:24:32 <benzrf> O:
19:24:55 <EvanR> win98, cant wait
19:25:09 <LearnMeHaskell> I mean reacts.
19:25:10 <EvanR> for my computer to randomly freeze after doing nothing for an hour
19:25:13 <LearnMeHaskell> Reactos.
19:25:30 <EvanR> forget reactos, give me haiku
19:25:37 <LearnMeHaskell> Well obviously if someone is doing it in Haskell, it will be better than win98.
19:25:47 <EvanR> proof by haskell ;)
19:26:15 <Kaidelong> well windows 98 SE was mostly liked for its performance characteristics
19:26:15 <hae> Haiku~
19:26:35 <EvanR> the speed at which it can bluescreen or freeze
19:26:39 <LearnMeHaskell> Well the only way an operating system is going to be popular is if it can run either the god dam exes or apple apps and has good graphics and uses the same drivers.
19:26:48 <benzrf> win98?
19:26:50 <benzrf> more like win95
19:27:03 <gamegoblin> Win 1.0 or bust
19:27:03 <benzrf> http://windows95tips.com/
19:28:17 <danielsmw> is anyone familiar with the ad (automatic differention) library?
19:28:33 <LearnMeHaskell> When I say popular, I mean, adopted by the rest of the world and not a bunch of hackers. That spot has been taken up by linux or to be pedantic gnu/linux.
19:29:14 <benzrf> >Well the only way an operating system is going to be popular is if it can run either the god dam  exes or apple apps
19:29:14 <EvanR> do not understand the penchant for trying to replace perfectly good OS already in common use
19:29:17 <benzrf> what?
19:29:20 <LearnMeHaskell> Rather do what apple did to BSD and turn it into a bastard child.
19:29:24 <EvanR> hobby hacking is one thing
19:29:38 <benzrf> what if it can run linux binaries
19:29:56 <lispy> shachaf: sorry I was away at dinner
19:30:16 <lispy> shachaf: I think I found a ghc bug. https://ghc.haskell.org/trac/ghc/ticket/9073#ticket
19:30:17 <Just_ShockSpock> EvanR: if you are traversing an infinite list, how do you coppy
19:30:24 <Kaidelong> EvanR: I think the answer is that your current operating systems are not "perfectly good" especially when they need to run themselves distributed or exposed to a hostile internet
19:30:38 <Kaidelong> hence efforts like Barrelfish and Singularity
19:30:43 <hae> Case in point: Windows.
19:30:47 <EvanR> thanks for reminding Just_ShockSpock, i have an actual question
19:30:53 <gamegoblin> lispy: Problem is you’re using windows ;)
19:31:01 <hae> ^
19:31:18 <Kaidelong> if GHC doesn't work on windows it will make it somewhat irrelevant
19:31:20 <lispy> carter: -fno-full-laziness makes a huge difference.
19:31:27 <EvanR> about re-traversing infinite lists multiple times without getting space leaks
19:31:28 <hae> Actually he's right lispy, I compiled it fine on my system.
19:31:40 <gamegoblin> hae: Are you serious? Was entirely joking.
19:31:47 <carter> lispy: yay, i know too much tricks now
19:31:50 <lispy> hae: what version of ghc and did you compile it with profiling and all the options in the ticket?
19:32:23 <carter> lispy: dont forget to mention that info in the ticket :)
19:32:31 <lispy> carter: Still, it seems like a bug for the memory to explode like this
19:32:32 <carter> i take it it now compiles?
19:32:46 <carter> lispy: a bug in how people use fusion yes
19:32:49 <lispy> carter: it compiled before, but took minutes and gigs of ram
19:33:01 <carter> well
19:33:06 <carter> thats neither here not there,
19:33:09 <LearnMeHaskell> Is there a way to develop Android applications in Haskell?
19:33:22 <carter> its worth reproting that the flag fixes the issue
19:33:31 <carter> for informing how to tune things going forward
19:33:35 <benzrf> LearnMeHaskell: probably
19:33:39 <carter> yup
19:33:44 <carter> theres an android tool
19:33:59 <carter> lispy: we can't fix 7.8.2 :)
19:34:09 <carter> and perse its arguablly a latent bug in vector
19:34:10 <carter> not ghc
19:34:11 <Just_ShockSpock> was wondering if hh
19:34:51 <Just_ShockSpock> keyboard is on fritz., ocean side
19:36:38 <carter> lispy: anyways, adding that info to the ticket can inform making the usage of full-laziness transfomr more conservative going forward
19:39:19 <hae> Yeah, lispy, I just did it again and no insane memory usage.
19:40:03 <lispy> carter: sure, but I still consider something like this a compiler bug. I'd rather have it give up gracefully and say, "Sorry, the options you gave don't make sense."
19:40:10 <carter> yes
19:40:42 <lispy> hae: weird.
19:40:54 <lispy> hae: I don't know what could possibly be windows specific about this bug.
19:41:11 <carter> lispy: yes, it should be better behaved in the future
19:41:16 <carter> just won't be for 7.8.X
19:41:27 <carter> is all i'm saying
19:42:31 <Just_ShockSpock> haskell on android though, iirc is messy
19:44:09 <lispy> hae, gamegoblin: I use ghc on windows on purpose. Someone needs to try it out and report bugs.
19:44:26 <gamegoblin> lispy: I salute your noble effort
19:44:31 <lispy> hae, gamegoblin: I use linux (and sometimes OSX) for my development platform
19:48:25 <gamegoblin> I use anything with an ssh client
19:48:45 <gamegoblin> But definitely prefer having bash available
19:49:21 <lispy> I switched to zsh a few years back and found it to be a nice upgrade to bash.
19:49:39 <Just_ShockSpock> ksh was cool
19:49:44 <benzrf> korn shell
19:50:42 <Just_ShockSpock> had it on xenix back when SCO was a big player
19:50:51 <Total_1mmersion> What's the difference between parsec's Parsec modules and the ParserCombinator modules? It appears they have many of the same functions.
19:51:09 <Clint> ksh is still cool, just not as an interactive shell
19:51:19 <benzrf> hm?
19:51:33 <Clint> Total_1mmersion: the latter are compatibility for parsec2, i think
19:53:52 <Total_1mmersion> Clint, ok, so I should be using the modules from the Parsec namespace? If so, would I translate the type "Parser Foo" to "Parsec String () Foo"?
19:54:40 <Just_ShockSpock> has anyone tried programming in haskell on a large screen, say 72"
19:55:24 <Yaniel> what does the screen size have to do with anything?
19:55:27 <Yaniel> except being awesome
19:55:52 <Just_ShockSpock> programming space and text size
19:56:20 <Yaniel> that's pretty much the same for any language isn't it
19:56:25 <Just_ShockSpock> like list more of your workspace
19:56:36 <benzrf> what are the type params to Parsec
19:57:13 <benzrf> Input type, ?, ?, output
19:57:16 <hae> Okay wait a second actually...
19:57:33 <hae> I'm recompiling and it just keeps going, like GHC has stalled.
19:57:56 <Just_ShockSpock> and have an imax haskell experience
19:58:19 <hae> lispy, I think you may actually be on to something.
19:59:58 <hae> Before I was just adding a 'main = undefined' at the end but when I try to compile it into a module it halts.
20:00:54 <benzrf> i got syntastic for my vim
20:01:01 <benzrf> it hooks into ghc to show types
20:01:09 <benzrf> no wait i got anoter thing for that
20:01:22 <benzrf> anyway, it doesnt work if there's errors
20:01:28 <Just_ShockSpock> Yaniel: ya bit
20:01:43 <benzrf> so if there's a type error ive gotten into the habit of replacing things with 'undefined' so that it will check, then viewing the types of related stuff
20:01:52 <Just_ShockSpock> its the haskell chan so keep it on topic will ya
20:03:09 <Just_ShockSpock> seriously though, for the amount we get paid, having two 72" screens side by each is a great way to program
20:03:27 <benzrf> >tfw when i just have a 15.5" laptop screen
20:04:34 <lispy> hae: ah, so is my test program confusing?
20:04:50 <lispy> hae: my file I guess I should have said, name this Foo.hs?
20:05:40 <Just_ShockSpock> 15" here, but its time to get into the game, curious what the
20:05:50 <Yaniel> 13" <3
20:05:53 <Just_ShockSpock> long hour coders are using
20:06:08 <hae> Yeah maybe. It only happens when you use -shared too, I think.
20:06:11 <haasn> benzrf: you can use typed holes in GHC 7.8.x
20:06:18 <gamegoblin> Anyone on here from Seattle?
20:06:22 <hae> Woo type holes are best holes.
20:06:32 <benzrf> haasn: typed holes??
20:06:34 <Yaniel> for an actual workstation a good ext screen is a must though
20:06:43 <Yaniel> but -blah
20:07:08 <lispy> gamegoblin: Portland
20:07:23 <haasn> benzrf: just pick some name that starts with an underscore like _foo and if it's not resolved, GHC will type-check it as “undefined” and tell you the inferred type at that position in the error message
20:07:31 <gamegoblin> lispy: I’m moving to seattle and was wondering if there were only local FP groups
20:07:36 <benzrf> O:
20:08:02 <lispy> gamegoblin: There must be but I don't actually know
20:08:55 <hae> Really I have no idea what's going on with this bug and I'm tired so I'm going to sleep.
20:09:09 <hae> All I can do is confirm that some sort of hang condition exists. Good night.
20:09:13 <lispy> hae: oh, I think I know what's wrong when you add main. noise has to be exported to demonstrate the bug
20:09:28 <Just_ShockSpock> you'll dream about the solution
20:09:29 <hae> Ah that would make sense.
20:09:54 <hae> Anyway hope you figure it out.
20:10:10 <lispy> hae: thanks!
20:10:21 <lispy> I have sufficient workarounds for now.
20:10:37 <lispy> For example, I don't think SPECIALIZE INLINE buys me much in this case over just regular INLINE
20:16:55 <sellout> gamegoblin: SeaFunc
20:17:06 <gamegoblin> sellout: are you from there?
20:18:14 <sellout> gamegoblin: I lived there for like four years, went to the SeaFunc gatherings the whole time. They’re still going on, although I doubt I know more than one or two of the currently active people.
20:18:32 <gamegoblin> sellout: What did the gatherings generally consist of?
20:19:23 <sellout> gamegoblin: Mostly discussions over dinner or drinks.
20:19:36 <gamegoblin> sellout: sounds awesome! Looking forward to it.
20:19:51 <sellout> Yeah, I had a lot of fun there.
20:50:36 <asimov42> @where ops
20:50:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:51:12 <MalixPek> i want to fuck kunwon1's nephew in the ass
20:51:17 <MalixPek> and then jizz all into his hair
20:51:19 --- mode: ChanServ set +o copumpkin
20:51:22 --- mode: copumpkin set +b *!~MalixPek@200.79.255.125
20:51:22 --- kick: MalixPek was kicked by copumpkin (No. Bad.)
20:51:46 <startling> ... what just happened?
20:51:58 <startling> asimov42 is clairovoyant?
20:52:24 <copumpkin> weird
20:53:38 <johnw> he was probably getting spammed in privmsg
20:53:42 * hackagebot hblas 0.3.1.0 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.1.0 (CarterSchonwald)
20:53:43 <geekosaur> or they started out in /pm and only started the channel stuff later, yeh
20:54:07 <startling> guess so.
20:54:29 <geekosaur> it happens although most often the ones in pm stay there
20:54:43 <geekosaur> and hit people as they join the channel, which explains this pretty well
20:55:11 <m09> I'm going through Tony Morris' exercices and I have troubles with some function in the Applicative part: is there a way to lift a function of type `a -> f Bool` into a `f (a -> Bool)`?
20:55:27 <johnw> yes, but not for some f
20:55:33 <johnw> see distributive
20:55:38 <johnw> @hoogle distribute
20:55:39 <lambdabot> package distributed-process
20:55:39 <lambdabot> package distributed-process-azure
20:55:39 <lambdabot> package distributed-process-monad-control
20:55:44 <benzrf> @info
20:55:45 <lambdabot> Error: expected a Haskell expression or declaration
20:55:49 <m09> thanks
20:55:56 <benzrf> doesnt that autocorrect to @echo or something
20:55:57 <benzrf> @echo
20:55:57 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "benzrf!~benzrf@198.23.200.81", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo"]} target:#haskell rest:""
20:56:12 <johnw> http://hackage.haskell.org/package/distributive-0.4.3.2/docs/Data-Distributive.html
20:56:53 <johnw> in your case, f is ((->) a), and g is f
20:57:39 <m09> thanks I'll study this :)
20:58:49 <geekosaur> it autocorrects to @undo
21:00:42 <benzrf> ah
21:01:02 <benzrf> @undo this is a test
21:01:02 <lambdabot> this is a test
21:01:08 <benzrf> i see
21:01:32 <geekosaur> @info do { a <- b; f a }
21:01:33 <lambdabot> b >>= \ a -> f a
21:01:33 <Just_ShockSpock> thx for chat was fun night with good laughs...off to dream of (++) <$> ["toast with "] <*> ["peanut butter","butter","banana","honey"]
21:02:46 <benzrf> Just_ShockSpock: no need to applicative
21:02:49 <benzrf> u can just functor there
21:02:58 <uniquenick> I have a record type like {a, b, c, d, e} and I'd like to be able to give people partial values of that type and let them mappend them together to make a complete value.  is there a way to do that safely so I can ensure they only give "finished" values to my library functions?
21:03:33 <benzrf> uniquenick: have you tried Maybe
21:03:42 <Just_ShockSpock> lol
21:04:20 <benzrf> > sequence ["this", "that"]
21:04:22 <lambdabot>  ["tt","th","ta","tt","ht","hh","ha","ht","it","ih","ia","it","st","sh","sa",...
21:04:31 <benzrf> > sequence ["this", "that", "other"]
21:04:32 <lambdabot>  ["tto","ttt","tth","tte","ttr","tho","tht","thh","the","thr","tao","tat","ta...
21:05:01 <benzrf> > sequence_ ["this", "that", "other"]
21:05:02 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
21:05:04 <benzrf> hmm
21:05:16 <Iceland_jack> > intercalate " for " (sequence ["t", "ia", "t"])
21:05:17 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
21:05:20 <Iceland_jack> > intercalate " for " (sequence ["t", "ia", "t"])
21:05:21 <lambdabot>  "tit for tat"
21:05:31 <benzrf> nice o=
21:05:38 <benzrf> >> sequence ["t", "ia", "t"]
21:05:39 <Iceland_jack> > intercalate " for " (sequence ["t", "iaoue", "t"])
21:05:40 <lambdabot>  "tit for tat for tot for tut for tet"
21:05:48 <benzrf> > sequence ["t", "ia", "t"]
21:05:49 <lambdabot>  ["tit","tat"]
21:05:54 <benzrf> hm hm
21:06:04 <benzrf> > intersperse
21:06:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
21:06:05 <lambdabot>    arising from a use of ‘M773365648238236717631976.show_M7733656482382367176...
21:06:05 <lambdabot>  The type variable ‘a0’ is ambiguous
21:06:05 <lambdabot>  Note: there are several potential instances:
21:06:05 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:06:10 <Iceland_jack> :t intersperse
21:06:11 <lambdabot> a -> [a] -> [a]
21:06:12 <benzrf> how does that differ from intercalaate
21:06:17 <benzrf> oh. i see
21:06:20 <benzrf> nvm :p
21:06:25 <Iceland_jack> benzrf: Compare the types :)
21:06:30 <benzrf> :t intercalate
21:06:31 <lambdabot> [a] -> [[a]] -> [a]
21:06:34 <benzrf> right
21:06:42 <Iceland_jack> Personally I always forget which one is which
21:06:46 <benzrf> join . intersperse?
21:06:53 <benzrf> @src intercalate
21:06:53 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:06:58 <startling> Iceland_jack: me tii
21:07:01 <startling> too too
21:07:10 <Iceland_jack> benzrf: concat .: intersperse
21:07:15 <Iceland_jack> where (.:) = (.) . (.)
21:07:33 <benzrf> whoa .:
21:07:41 <benzrf> :t (.:)
21:07:42 <lambdabot>     Not in scope: ‘.:’
21:07:43 <lambdabot>     Perhaps you meant one of these:
21:07:43 <lambdabot>       ‘.’ (imported from Data.Function),
21:07:47 <Iceland_jack> :t (.) . (.)
21:07:48 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:07:55 <benzrf> sweet
21:09:36 <newsham> lets say you write an imperative language in haskell...  is there a common/standard way people abstract walking over the AST for doing analysis?    zippers maybe?
21:09:47 <startling> benzrf, a .: b is often written (a . ) . b
21:10:03 <startling> it's a useful trick
21:10:13 <startling> "compose a unary function with a binary one"
21:10:15 <Iceland_jack> I find (a .) . b pretty ugly, I normally just write it pointfully if it comes to that
21:10:41 <startling> yeah, idk if it's worth it.
21:10:58 <benzrf> 12:08 < Iceland_jack> I find (a .) . b pretty ugly, I normally just write it pointfully if it comes to that
21:11:01 <benzrf> same
21:11:03 <Iceland_jack> I might use (.:) more often if it were included in the Prelude
21:11:08 <startling> me too.
21:11:10 <benzrf> mhm
21:11:12 <startling> peopple dislike it though.
21:11:32 <benzrf> balderdash!
21:11:37 <startling> I wonder where the name came from. It's a pretty good name.
21:13:50 <carter> newsham: solution: translate it into a lambda calc with mutable ops
21:14:18 <carter> how you analyze the lang AST is orthogonal to it being pure  or not
21:14:21 <newsham> solution to what problem?
21:14:34 <benzrf> zippers are fun
21:14:36 <benzrf> they are zippy!
21:14:54 <benzrf> anyway bye
21:16:24 <startling> @remember benzrf zippers are fun / they are zippy! / anyway bye
21:16:25 <lambdabot> Done.
21:17:07 <carter> startling: haiku
21:17:26 <newsham> is there any template haskell lib for generating zippers?
21:17:37 <lispy> startling: the name (.:) ?
21:17:38 <startling> newsham, the lens thing is interesting
21:17:41 <carter> @hackage syz
21:17:41 <lambdabot> http://hackage.haskell.org/package/syz
21:17:47 <startling> @hackage zippers
21:17:47 <lambdabot> http://hackage.haskell.org/package/zippers
21:17:49 <startling> lispy: yeah.
21:17:49 <carter> http://hackage.haskell.org/package/syz
21:17:54 <lispy> startling: I think Cale came up with (.:) but I'm not certain
21:18:05 <joelteon> put that on your resume
21:18:34 <carter> ?
21:18:46 <joelteon> that was to Cale, but i forgot to type his name before i started
21:24:51 <albeit_> If I have "data Foo = MakeFoo Bar; data Bar = MakeBar { baz :: String}", is only way to get a Bar by pattern matching on a Foo "| MakeFoo (MakeBar myString) = doSomething"?"?
21:25:21 <albeit_> Or is there another way to do it where I can just go straight to something like "| MakeBar myString"?
21:25:39 <startling> albeit_: you can use a pattern synonym
21:30:00 <albeit_> Ah so something like "pattern MakeBar' = MakeFoo . MakeBar"?
21:30:20 <albeit_> (Not sure if that would be the exact syntax, but the general idea"
21:30:44 <Iceland_jack> Something like
21:30:44 <Iceland_jack>     pattern MakeBar' a <- (MakeFoo . MakeBar -> a)
21:31:17 <Iceland_jack> hm never mind misread, it's simpler than that
21:31:38 <Iceland_jack>     pattern MakeBar' a = MakeFoo (MakeBar a)
21:31:40 <startling> pattern MakeBar' a = MakeFoo (MakeBar a) ?
21:31:41 <startling> yeah
21:34:00 <m09> Ok I really don't get how to code this filtering function from Tony Morris' exercices. Anyone has a hint? https://gist.github.com/m09/d1eeac0472d558192999
21:35:04 <dmj`> does hackage have any libraries for executing shell scripts on a remote server?
21:35:25 <albeit_> Is there a way to generalize pattern synonyms? This may get messy but... "data Foo = MakeBar Bar | MakeLorem Lorem; data Bar = Bar String; data Lorem = Lorem Int String", pattern match without defining a bunch of pattern synonyms?
21:35:36 <startling> dmj`, there's the libssh2 package but I can't get it to build
21:35:59 <Iceland_jack> albeit_: What kind of generalization are you thinking of for that example?
21:35:59 <startling> dmj`: there's also propellor, which kinda does stuf
21:36:00 <startling> f
21:37:59 <albeit_> I want to be able to match a Foo directly on "| Bar str = doA    | Lorem i str = doB"
21:38:54 <dmj`> startling: very cool, think it would be nice if haskell had something like python fabric
21:39:12 <startling> dmj`: agreed.
21:39:20 <Iceland_jack> albeit_: And what would the type of that be?
21:39:21 <startling> It's a thing I've been meaning to poke at when I get the chance.
21:40:06 <Iceland_jack> A possible solution would be to create a type class for anything that potentially includes a Bar constructor, but that's very heavy weight
21:40:07 <dmj`> startling: right now I have my builds + deployment auto'd w/ fabric, was thinking shake + something else "habric" ? :P could be a replacement
21:40:26 <albeit_> Iceland_jack: Yeah, I'm starting to see this may not be the best path to go down.
21:40:31 <Iceland_jack> There are such a thing as associated patterns
21:41:31 <Iceland_jack> that allow you to associate patterns to a specific data type, you can for example use
21:41:31 <Iceland_jack>     map f Nil       = nil
21:41:31 <Iceland_jack>     map f (x :· xs) = f x :· map f xs
21:41:31 <Iceland_jack> and have it work for Data.Text.Text, [a], ByteString, Data.Map.Map, …
21:41:55 <Iceland_jack> In a sense that's approaching the problem from the other direction
21:42:27 <Iceland_jack> (:·) would be defined as
21:42:27 <Iceland_jack>     pattern x :· xs ← (uncons → Just (x, xs))
21:43:12 <Iceland_jack> with uncons []     = Nothing
21:43:13 <Iceland_jack>      uncons (x:xs) = Just (x, xs)
21:43:13 <Iceland_jack>      uncons = T.uncons etc.
21:43:51 <albeit_> Iceland_jack: Oh boy. I think I may just make "data Foo = Bar String | Lorem Int String"
21:43:55 <Iceland_jack> haha
21:44:09 <Iceland_jack> Or you could use PatternSynonyms and just define the most obvious patterns by hand
21:44:28 <albeit_> Iceland_jack: Only reason I was trying that other was so that I could declare an aeson FromJSON instance on each "type" Foo could be.
21:44:37 <Iceland_jack> did you see my guide albeit_? http://www.reddit.com/r/haskell/comments/24fvyz/pattern_synonyms_for_dates_and_an_irc_bot/
21:44:54 <albeit_> Yep! Started to read it at least
21:45:12 <albeit_> I'll give it a more thorough read
21:45:54 <Iceland_jack> I'm not sure wha tyou mean by 'each type Foo could be'  though
21:47:31 <albeit_> Iceland_jack: Well, if had done "data Foo = MakeFoo Bar; data Bar = Bar String", Bar would be a "type" (please correct my terminology) of Foo. Then I could Bar an instance of MakeJSON. If I just do "data Foo = Bar String", Bar can't implement its own instance.
21:48:07 <Iceland_jack> You could say data type field
21:50:06 <albeit_> Okay.
21:50:48 <newsham> it seems like defining a zipper over even a small-ish toy AST quickly blows up into a large problem
21:52:04 <roconnor> IIRC with lenses you can create synthetic zippers;  I don't recall if they have the same nice operational characteristics, but they probably do.
21:52:41 <newsham> i would like to be able to iterate over the execution of a toy program either forward or backwards..  ie. to build def/use chains
21:52:52 <newsham> so building soething like a zipper seemed like the way to go
21:54:54 <newsham> maybe i just want a simplified representation for that
22:13:54 <itimmy> Allow me to introduce myself, my name is itimmy and I was sent here from the gods
22:16:20 <hamid> itimmy, say hamid said hi gods.
22:17:26 <itimmy> hahaha sir yes sir
22:25:55 <albeit_> Is there an accepted style for Haskell (like indent, formatting of datatype declarations, etc...) that's documented somewhere?
22:28:11 <lispy> albeit_: There are several style guides online, some of which I dislike, but the most important thing is always readability.
22:28:36 <lispy> albeit_: I suppose there are some hard and fast rules. Avoid tabs, for example (they don't interact well with layout)
22:29:02 <lispy> albeit_: personally I like 2 spaces for indentiation, but lots of people like 4.
22:30:10 <lispy> albeit_: http://urchin.earth.li/~ian/style/haskell.html (that's a good start which isn't too prescriptive)
22:31:44 <lispy> albeit_: I don't like everything in this guide, but it's still reasonable: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
22:32:58 <lispy> albeit_: the main thing I disagree with is the section on laziness.
22:33:59 * hackagebot persistent-postgresql 1.3.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.1.1 (MichaelSnoyman)
22:35:24 <m09> any hint on how to implement a filter that uses a predicate whose result is lifted in an Applicative (filtering ∷ Applicative f ⇒ (a → f Bool) → [a] → f [a])?
22:38:18 <albeit_> lispy: Great, I'll check those out
22:41:24 <lispy> albeit_: cool. BTW, if you find yourself adding strictness annotations (bangs, !) because that guide told you too, then please stop, come here, and ask questions about it :)
22:41:54 <lispy> albeit_: It takes time to understand laziness, but it's worth it (I can't stress that enough)
22:43:02 <knrafto> :t \p -> fmap (map fst . filter snd) . traverse (\a -> (,) a <$> p a)
22:43:03 <lambdabot> Applicative f => (b -> f Bool) -> [b] -> f [b]
22:43:13 <knrafto> m09: that's the best I could come up with
22:43:49 <albeit_> lispy: Ha, I actually added bangs a week ago, came here because I couldn't figure out why they weren't working, and someone told me to remove them and corrected the program.
22:44:23 <albeit_> Being very cautious with them now ;)
22:44:24 <m09> knrafto: wow, I didn't expect something that complicated. But thanks It'll be a great starting point to understand what's going on
22:44:47 <lispy> albeit_: heh. I know that feel.
22:46:47 <shachaf> :t let filterA _ [] = pure []; filterA p (x:xs) = liftA2 (\flg ys -> if flg then x:ys else ys) (p x) (filterA p xs) in filterA
22:46:49 <lambdabot> Applicative f => (t -> f Bool) -> [t] -> f [t]
22:46:54 <shachaf> m09: That's a direct translation of filterM.
22:51:43 <m09> shachaf: aah, I see. Thanks a lot that was very helpful :)
22:52:09 <shachaf> There are usually caveats about that sort of translation but in this case it doesn't matter.
22:53:32 <lispy> shachaf: once AMP is out in the wild it seems we could benefit from refactoring lots of fooM definitions to fooA.
22:54:02 * hackagebot hourglass 0.1.0 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.1.0 (VincentHanquez)
22:55:19 <shachaf> Sure, once Applicative is a superclass of Monad all sorts of things could happen. But I refuse to use that acronym.
22:56:01 <shachaf> Of even more benefit could be the automatic translation from do-notation that we talked about in here a while ago.
22:56:45 <lispy> shachaf: Oh. You don't like the acronym? Why?
22:56:47 <startling> "AMP" makes me think of http://img.pokemondb.net/artwork/ampharos.jpg
22:57:06 <Iceland_jack> I owned a lvl 100 Ampharos
22:57:18 <Iceland_jack> Then accidentally erased the save file
22:57:26 <shachaf> Never mind that.
22:59:36 <shachaf> I'd like to figure out a good syntax that makes auto-do-to-Applicative translation reasonable.
23:00:02 <shachaf> The nice thing is that you can even do it locally and get small improvements even if you can't convert the whole thing away from Monad.
23:00:03 <copumpkin> shachaf: max bolingbroke proposed a simple translation at some point
23:00:13 --- mode: copumpkin set -o copumpkin
23:00:22 <shachaf> copumpkin: Yes, we had a conversation about that in here last yearish.
23:00:37 <copumpkin> yep
23:00:43 <shachaf> Where I suggested e.g. join (liftA3 f x y z) instead of using a tuple.
23:01:08 <shachaf> Something like that.
23:01:25 <shachaf> If only rewrite rules were powerful enough for expressing that sort of thing.
23:01:39 <copumpkin> yeah
23:02:25 <shachaf> Hmm, I have http://slbkbs.org/altmon.hs lying around.
23:02:54 <shachaf> I think that actually worked. But it's too specific to be useful.
23:03:41 <shachaf> Any innovations in changing the syntax so "pure"/"return" doesn't have to be magic?
23:04:02 <orion> hmm
23:04:03 * hackagebot hit 0.6.0 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.6.0 (VincentHanquez)
23:05:42 <gamegoblin> Hey. I just met you. And this is crazy. I don’t know if I’m a value or not. So call me Maybe.
23:05:52 <orion> hah
23:07:23 <orion> Let's say I want a function f to return a value whose type is within a given typeclass. Would f's signature be f :: TheTypeClass c => ... -> c ?
23:07:34 <gamegoblin> Yes
23:07:39 <orion> thank you
23:09:39 <lispy> :t 1 -- orion
23:09:40 <lambdabot> Num a => a
23:10:32 <gamegoblin> Mmmm the mental gap between niladic functions and values
23:11:57 <shachaf> There's no such thing as a niladic function.
23:11:58 <Iceland_jack> 1 is a polymorphic constant, not a function
23:12:10 <lispy> I suppose I should have written the example as \_ -> 1, but I'm lazy.
23:13:53 <lispy> Realy a much more robust example is:
23:13:58 <lispy> :t \_ -> mempty
23:13:59 <lambdabot> Monoid a => t -> a
23:14:05 <Iceland_jack> or (+)
23:14:33 <lispy> The way that 1 is translated to Num a is non-obvious
23:24:19 <archit> yelo!
23:28:20 <archit> I'm trying to updata cabal on a Mac OS X 10.9.2. I have haskell-platform installed (v 2013.2.0.0) via homebrew. When I try to update cabal using `cabal install cabal-install`, it fails with the error ... http://cl.ly/image/3j1y0x2b3U35
23:28:23 <archit> any htoughts?
23:29:14 <maxs`> How can I specify the package-db to ghci? (I don't want to use cabal repl)
23:30:44 <lispy> archit: I've never seen that happen before. What are the permissions on that directory?
23:30:44 <startling> maxs` ghci -package-db=whatever
23:31:35 <maxs`> startling: ah, I had --package-db :P
23:31:40 <maxs`> thanks!
23:31:49 <startling> maxs`: no problem! ghc args are pretty annoying
23:31:51 <lispy> archit: any chance you've run out of free space on your hard drive?
23:33:28 <orion> Does anyone know what's wrong with this code?: http://ideone.com/qHn1DS
23:34:02 <archit> lispy: ah yes, perm issue. My ~/.ghc was owned by root. I think back a few months ago, I may have run `cabal install` as root hoping to replicate --global behavior
23:34:58 <archit> so it left behind ~/.ghc as root owned
23:35:08 <maxs`> orion: blahFunc1 returns any type as long as it is in BlahClass.
23:35:32 <maxs`> orion: you probably mean to have blahFunc2 inside of BlahClass, then the instance for Blah implements that function
23:38:02 <orion> maxs`: hmm
23:39:14 <orion> maxs`: How do I get blahFunc1 to return a specific type of BlahClass?
23:39:20 <isomorphic> What's the preferred URL for hackage these days?  For me, https://hackag.haskell.org gives connection refused (but according to Google's cache, seems more up to date on the 'What's New' page, for example) whereas the http site is reachable but seems out of date.
23:40:14 <shachaf> isomorphic: You need an e -- https://hackage.haskell.org/ works for me.
23:42:21 <orion> maxs`: I updated the paste with what your suggestion as well as a comment indicating my question.
23:43:58 <maxs`> orion: Change that function's type to Foo
23:45:50 <orion> maxs`: hmm, ok
23:49:08 * hackagebot repa 3.2.5.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.5.1 (BenLippmeier)
23:49:10 * hackagebot repa-algorithms 3.2.5.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.5.1 (BenLippmeier)
23:49:34 <orion> maxs`: I am in the process of writing a packet processor. I am trying to figure out if a "Packet" should be a typclass or if it should be a data type with multiple value constructors.
23:49:53 <orion> Using attoparsec
23:50:15 <orion> Do you know which one is better for this purpose?
23:50:31 <orion> I am going to need to access all the fields of all the packets eventually.
23:51:27 <maxs`> I would go with a data type
23:51:33 <maxs`> for now
23:51:45 <maxs`> and pattern match
23:53:41 <orion> maxs`: ok, thank you
23:53:44 <isomorphic> shachaf :   Sorry, typo when writing in that channel.    That's interesting.   What does hackage.haskell.org resolve for for you?
23:54:09 * hackagebot repa-examples 3.2.5.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.5.1 (BenLippmeier)
23:54:11 * hackagebot gloss 1.8.2.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.8.2.1 (BenLippmeier)
23:54:13 * hackagebot gloss-raster 1.8.2.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.8.2.1 (BenLippmeier)
23:54:15 * hackagebot gloss-examples 1.8.2.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.8.2.1 (BenLippmeier)
23:54:17 * hackagebot repa-io 3.2.5.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.5.1 (BenLippmeier)
23:57:22 <shachaf> isomorphic: 88.198.224.242
23:57:30 <shachaf> isomorphic: Maybe ask in #haskell-infrastructure or similar.
23:58:38 <isomorphic> Thanks!  FYI, if anybody runs into problems - oddly it's resolving for me sometimes at (66.193.37.204:  abbot.galois.com, fails) and then sometimes at the address shachaf mentions (succeeds)
23:59:03 <isomorphic> Oddly - not a roundrobin
