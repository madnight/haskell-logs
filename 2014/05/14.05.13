00:04:28 <toki78> hi
00:04:50 <toki78> how to add an "and" to a SAT instance in ersatz ?
00:09:51 * hackagebot tasty-quickcheck 0.8.1 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.8.1 (RomanCheplyaka)
00:09:51 * hackagebot metadata 0.1.7.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.7.0 (KatsutoshiItoh)
00:34:08 <darthdeus> anyone using the fpcomplete ide online?
00:34:49 * hackagebot tamper 0.1.1.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.1.0 (TobiasDammers)
00:36:02 <carminemlt> hello, I'm still stuck with monad transformers learning. I have a function with type :: Int -> Int -> ReaderT [(Int,Int)] (WriterT [Int] []) () and at some point in code, I'd like to access the [(Int,Int)] held within ReaderT and, finally, execute some code over its values.
00:36:24 <carminemlt> I can access the [(Int,Int)] but can't understand how to fetch its values
00:38:19 <Feuerbach_> carminemlt: I don't understand your problem, I'm afraid
00:38:26 <Feuerbach_> can you show what code you already have?
00:38:50 <carminemlt> Feuerbach_: Yes, I can. I'll upload the code to lpaste
00:39:49 * hackagebot tamper 0.1.2.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.2.0 (TobiasDammers)
00:40:37 <carminemlt> Feuerbach_: http://lpaste.net/104042
00:41:09 <carminemlt> Feuerbach_: The goal would be to find all the paths between given edges in a graph represented with [(Int,Int)]
00:41:50 <carminemlt> Feuerbach_: That code compiles but it is broken because, as can be obviously seen, it doesn't go over all the edges in [(Int,Int)] but it analyse just the first couple
00:42:21 <bb> what's your input data?
00:43:04 <bb> (the minimum set to cause the failure you're describing)
00:43:05 <carminemlt> Feuerbach_: I expected the call to ask to return [(Int,Int)] and the "<-" to leverage [] monad semantics but it is not so. And that's where I'm stuck.
00:43:24 <carminemlt> bb: Are you talking to me?
00:43:38 <bb> carminemlt: yes..
00:44:22 <carminemlt> bb: input data is just a [(Int,Int)] such ash: [(2013,501),(2013,1004),(501,2558),(1004,2558)]
00:44:50 <Feuerbach> carminemlt: you don't have a [] monad in your stack
00:44:51 * hackagebot tamper 0.1.3.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.3.0 (TobiasDammers)
00:45:09 <coppro> I have decided that printf is a hard problem
00:45:20 <Feuerbach> the fact that the result type happens to be list doesn't make bind behave differently
00:45:26 <Feuerbach> if you see what I mean
00:46:34 <carminemlt> Not sure why
00:46:52 <Feuerbach> oh, sorry, I'm wrong
00:46:57 <Feuerbach> you do have [] in your stack
00:47:32 <carminemlt> being in the outer monad (ReaderT [(Int,Int)]) I thought that a call to ask would have sufficed
00:48:28 <Feuerbach> well, ask gives you a single result
00:48:34 <Feuerbach> it doesn't "fork"
00:48:41 <Feuerbach> that result just happens to be of list type
00:49:32 <Feuerbach> perhaps you want something like: do { x <- ask; lift . lift $ x }
00:49:33 <carminemlt> ok, then if I turn the call to ask in " edges <- ask" and then "(e_start,e_end) <- edges", shouldn't it work?
00:49:52 * hackagebot tamper 0.1.4.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.4.0 (TobiasDammers)
00:50:04 <Feuerbach> yes, except you need to lift the list, as I wrote above
00:50:46 <coppro> oh my god how is it so difficult to get a simple decimal representation of a number
00:50:49 <coppro> 1.5
00:50:52 <coppro> is all I ask
00:51:07 <carminemlt> Ok, the lift is needed because the results from ask are in the wrapped monad?
00:52:57 <coppro> I don't want to convert to a real number first
00:53:01 <coppro> because that will lose precision
00:53:07 <Feuerbach> coppro: see Data.Fixed
00:53:50 <Feuerbach> carminemlt: it's not due to ask per se. rather, your "ambient" monad is something on top of list, and your edges is pure list
00:54:05 <Feuerbach> so you want to promote the list to match the ambient computation context
00:55:31 <carminemlt> Fuerbach: Then lift works by "bringing in" the ambient the [(Int,Int)]. The 1st of the two lifts brings it in the ReaderT and the second where?
00:55:58 <Feuerbach> carminemlt: it'd help you enormously if you manage to write this in terms of >>= and write down all the intermediate types
00:56:14 <Feuerbach> and second to the writer
00:56:34 <carminemlt> Feuerbach: Just the parts inside e_paths = do ...?
00:56:35 <Feuerbach> actually, the other way around
00:57:25 <Feuerbach> carminemlt: maybe even something simpler. Just try it. Once you understand what's going on there, you'll be able to write the code more confidently
00:57:48 <Feuerbach> i.e. how lift works, how ask works
00:57:59 <Feuerbach> they are very simple functions
00:58:18 <Feuerbach> but you need to understand why and how they work
00:58:54 <coppro> > floor (3 % 2) :: Integer
00:58:56 <lambdabot>  1
00:59:06 <coppro> grrrrr
00:59:13 <jle`> hm i think i fixed a long standing connection leak in the engine for my blog that i wrote last year as my second haskell project
00:59:16 <coppro> oh
00:59:24 <jle`> thus ends an era of my life
00:59:35 <carminemlt> Feuerbach: As of now I'm trying to learn about them in the book "beginning haskell", so far I still can't grasp them. Anyway, thanks for the help and the advices.
01:00:30 <coppro> why is it so much work to make 3 % 2 print as 1.5
01:00:33 <coppro> like really guys
01:00:51 <dmj`> carminemlt: how transformers work?
01:01:04 <shachaf> coppro: Is it?
01:01:11 <coppro> shachaf: yes
01:01:23 <shachaf> What do you expect for 2 % 3?
01:01:34 <coppro> 1.33333333333 or something, I dunno
01:01:40 <dmj`> jle`: what was the leak?
01:01:44 <coppro> something sane
01:01:50 <carminemlt> dmj`: yes. The transformers are introduced by means of a couple of examples to show how to combine different monads.
01:01:53 <jle`> dmj`: i think it was from lazy io
01:01:58 <jle`> i have to test it in the wild though
01:02:01 <dmj`> *gasp*
01:02:02 <coppro> everything requires a RealFloat which is stupid
01:02:05 <jle`> but i was using the lazy Data.Map
01:02:11 <jle`> back before i realized that there was a strict one
01:02:39 <coppro> not all floating point numbers have a finite decimal representation anyway
01:02:45 <dmj`> jle`: did you profile? How'd you find it
01:02:46 <carminemlt> dmh`: then the book shows how lift is used to access the wrapped monad , and here things become really confused to me
01:03:00 <jle`> dmj`: i didn't, i just sort of hunted around
01:03:05 <jle`> heh.
01:03:11 <jle`> well if the leak still happens then i was wrong
01:03:58 <darthdeus> guys i'm getting weird errors when I run cabal repl in my small yesod app, any thoughts where this might be coming from? https://gist.github.com/darthdeus/45a654d1855715d0165e
01:04:17 <jle`> i'm using Persistent, so i thought that snoyman and co. took io leaks like this very seriously
01:04:26 <jle`> so i figured the mistake must be on my side
01:04:41 <dmj`> darthdeus: are you hiding Prelude?
01:05:30 <darthdeus> dmj`: i dont think so, not intentionally
01:05:47 <dmj`> darthdeus: are you hiding it unintentionally?
01:05:59 <darthdeus> oh wait yeah there is 'import           Prelude              as Import hiding (head, init, last, readFile, tail, writeFile)
01:05:59 <darthdeus> ' in Import.hs from yesod
01:06:14 <darthdeus> not sure if that's at fault?
01:06:40 <dmj`> jle`: GHC.Stats (GCStats ( currentBytesUsed ), getGCStats), I used to use ekg to watch memory, but it depends on snap-server... so I just use GCStats now
01:07:02 <jle`> dmj`: oh neat. i'll check that out, thanks
01:07:04 <dmj`> jle`: doesn't help knowing *exactly* where the leak occurs... but
01:07:06 <dmj`> meh
01:07:12 <jle`> it's a connection leak though, not a memory leak
01:07:18 <jle`> if that makes a difference
01:07:32 <jle`> it wasn't closing connections to the postgres server
01:07:41 <jle`> even after all of my queries were "done"
01:08:15 <darthdeus> dmj`: did i do something wrong or is this default yesod behavior?
01:08:20 <jle`> and it would crash randomly in the middle of normal operation, on what i would assume would be on trying to read the values of the lazy map
01:08:52 <dmj`> darthdeus: I doubt yesod would hide Prelude by default...
01:09:20 <darthdeus> dmj`: thuogh everything works after those errors, they don't seem to be affecting anything as far as i can see
01:09:48 <darthdeus> why would there be import Prelude in some of the files? isn't that the default?
01:09:53 <coppro> argh... aeson has it out for Rational too
01:09:55 <coppro> I hate people
01:10:31 <darthdeus> HA i found it
01:10:45 <darthdeus> it's errors coming from my ~/.ghci ... uhm
01:11:18 <dmj`> jle`: hm... After a query I think the file descriptor corresponding to the socket should get garbage collected, unless there are remaining references to it lying around
01:11:43 <darthdeus> though i'm only defining one function in there ... but yeah it seems something is hiding prelude and it fails when it loads my settings, hmm
01:11:49 <jle`> i think because the map was lazy, the actual data wasn't being fetched until the value as accessed.
01:11:58 <darthdeus> is it ok to put import Prelude in my ~/.ghci?
01:11:59 <jle`> so the connection was kept open indefinitely
01:12:02 <darthdeus> or will that affect everything
01:12:28 <dmj`> darthdeus: Prelude is imported into every module by default, unless you add the "NoImplicitPrelude" extension
01:14:15 <dmj`> jle`: oh that's interesting! So the data fetched from persistent wasn't being forced by a call to serve html? Was this in a web handler?
01:14:34 <darthdeus> dmj`: hmm i have that in my .cabal file ...
01:14:51 <jle`> well, i used a single massive query to populate a giant Data.Map that was shared by all of my views/routes
01:14:54 <jle`> using Reader
01:15:04 <jle`> i did it at start-up
01:15:38 <jle`> and so the route logic would check the map for a value on every request
01:15:57 <jle`> hm
01:15:58 <jle`> darn
01:16:01 <jle`> the leak is still there
01:16:06 <jle`> sad :/
01:16:29 <dmj`> maybe deepseq the map after load
01:16:41 <merijn> Oh, do I hear the sounds of lazy IO?
01:16:55 <dmj`> merijn: indeed
01:16:58 <merijn> In long lived process you should avoid lazy IO like hGetContents
01:17:09 <merijn> It's a recipe for problems
01:18:03 <jle`> i'm using Persistent to populate a map that's used throughout my application
01:18:06 <merijn> The sane alternatives are 1) strict IO or 2) streaming libraries like pipes/conduit if you need proper streaming
01:18:21 <jle`> i'm not sure why but i am getting heavy connection leaking
01:18:35 <dmj`> jle`: do you have the code that pulls the data from peristent? Maybe do something like let !queryData = persistentQuery in populateMap queryData
01:19:18 <jle`> hm. let me see
01:19:46 <dmj`> jle`: how many connections are you opening to your db? I think you get at least 1024 file descriptors w/o -threaded enabled
01:20:19 <jle`> hm let me remember the heroku commands
01:22:44 <juhp> carter, -O2 llvm looks fine with ghc-7.8.2
01:29:56 * hackagebot tamper 0.1.5.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.5.0 (TobiasDammers)
01:31:46 <killy9999> is anyone familiar with any work on operational semantics of Haskell?
01:37:44 <Cale> killy9999: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.396 -- it's pretty old and only a draft paper
01:37:51 <Cale> killy9999: But it's something :)
01:38:45 <Cale> heh, this was written before Haskell had an abstract IO datatype
01:39:53 <killy9999> Cale: thanks
01:40:02 <killy9999> if it has type classes it should be OK :-)
01:41:00 <Cale> I don't think this considers type classes at all
01:42:22 <killy9999> yeah, I think it doesn't
01:42:32 <killy9999> well, that's better than nothing
01:45:17 <merijn> I don't think haskell has an operational semantics?
01:45:26 <merijn> Wouldn't that require having a defined evaluation order?
01:46:53 <merijn> In other words, it would only be possible to establish a semantics for a specific haskell implementation
01:47:32 <merijn> Completely unrelatedly: Is there a way to print the recursive dependencies of a cabal package?
01:50:44 <mr-> maybe a --dry-run in a fresh sandbox is a good approximation. The "set" of dependencies depends on a lot of choices..
01:51:35 <hexagoxel> there is an error in the code listing in 6.2 on http://www.haskell.org/haskellwiki/GHC/Type_families#What_are_type_families.3F
01:51:55 <hexagoxel> for type family F2, the instances are started with F instead of F2
01:51:58 <merijn> I just wanna see how many big I bloat the recursive dependencies when I add another library
02:05:16 <mmmm> Is there a way to translate a >> b >> c into a chain using <*>?
02:05:28 <tdammers> mmmm: that wouldn't make sense, would it?
02:05:38 <tdammers> mmmm: >> discards results, <*> doesn't
02:06:11 <mmmm> so you should just use >> ?
02:06:27 <Iceland_jack> :t (*>)
02:06:28 <lambdabot> Applicative f => f a -> f b -> f b
02:07:27 <mmmm> Is it preferable to use *> or >> ?
02:08:19 <nclarke> mmmm: (*>) is more general
02:16:27 <Cale> mmmm: I'd only use *> if I was also using <*> somewhere
02:18:35 <jle`> i use *> usually if i use <* somewhere
02:19:05 <peteretep> There's a Clojure construct such that you could write the following Haskell:
02:19:07 <peteretep> (f4 . f3 . f2 . f1) "data"
02:19:14 <peteretep> like this in Clojure: (-> "data" f1 f2 f3 f4)
02:19:31 <peteretep> Is there a Haskell equivalent?
02:19:41 <peteretep> Feels kinda 'bind'y
02:19:54 <jle`> well you can do data & f1 & f2 & f3 & f4
02:20:01 <jle`> ...i think.
02:20:14 <jle`> or data & (f1 >>> f2 >>> f3 >>> f4)
02:20:14 <peteretep> What's providing &?
02:20:18 <jle`> but why would you want to do that
02:20:20 <jle`> :|
02:20:25 <peteretep> jle`: Curious more than anything
02:20:40 <jle`> yeah, (>>=) makes things left to right-y
02:20:57 <jle`> in direct contrast to (.) and ($) and (<$>) and all other right-to-lefty things
02:21:13 <peteretep> It's kind of a reduce I guess
02:21:25 <jle`> (&) is just flip ($)
02:21:38 <jle`> lens defines it, but you can do it yourself too.
02:21:43 <peteretep> ah, ok
02:21:47 <peteretep> I was getting out of scope
02:21:57 <jle`> yeah, it's not a very common construct
02:22:27 <jle`> well, (>>>) and (>>=) and (&) and (<$>) and family sort of mirror unix pipes too
02:22:34 <jle`> sorry, (<&>)
02:23:01 <jle`> but it is usually more natural to use their flips, (.), (=<<), ($), and (<$>)
02:23:11 <peteretep> A fold feels similar
02:23:15 * peteretep tries to write it as a fold
02:23:21 <jle`> there's no syntactical construct, if that's what you are asking
02:23:27 <peteretep> No, fair enough
02:23:41 <jle`> you can use fold to compose functions, yea
02:24:27 <jle`> > let f = foldr (>>>) id [(+2),(*3),(^2)] in f 5
02:24:29 <lambdabot>  441
02:24:52 <jle`> on hindsight i probably should have let you do it yourself
02:24:57 <jle`> for learning :)
02:25:15 <peteretep> I am not looking at your solution :)
02:26:05 <jle`> only
02:26:10 <jle`> if you use a fold, you can only use endofunctions
02:26:39 <jle`> because you can only store functions of the same type in a list
02:27:20 <rhaps0dy> damn
02:32:33 <merijn> Is the 6th entry in ascSymbol supposed to be *? (https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002)
02:38:34 <b0bbi10> hi, why isn't the return value of mapM (and forM) printed? http://ideone.com/plg3wH
02:39:56 <b0bbi10> mapM should print [(), (), (), ()] at last, shouldn't it?
02:42:42 <opqdonut> b0bbi10: in ghci, ghci prints the values produced for you
02:42:57 <opqdonut> b0bbi10: when you're running a haskell program, nothing gets printed unless you use print or putStrLn etc.
02:43:40 <b0bbi10> ah ok, thanks
02:45:05 <HugoDaniel> or an exception occurs
02:47:54 <awestroke> what's ⊥ ?
02:48:04 <awestroke> undefined?
02:48:50 <jle`> bottom
02:49:04 <jle`> nonterminating computation
02:49:09 <merijn> awestroke: Bottom, which refers to any "non-terminating" computation
02:49:23 <merijn> Which includes crashes, infinite recursion, etc.
02:49:49 <merijn> Undefined is bottom, but so is "let x = x in x"
02:50:01 <merijn> Or 'error "foo"'
02:50:24 <awestroke> thanks
02:57:09 <heudebeu_> does anyone know the compose key sequence for the bottom symbol? just curious
02:58:37 <Cale> Is there one?
02:58:44 <heudebeu_> i don't know
02:58:53 <heudebeu_> i'm looking but i can't find it
03:05:45 <Raiden> ?
03:16:46 <sigrlami> Hi, everyone! Tried to install pandoc on ghc-7.8.2, fedora19 and got error with zip-archive --> Preprocessing library zip-archive-0.2.2.1...
03:16:46 <sigrlami> /usr/bin/ld: cannot find -lHSzlib-0.5.4.1-ghc7.8.2
03:16:46 <sigrlami> Any suggestions how to fix this?
03:25:09 * hackagebot tamper 0.1.6.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.6.0 (TobiasDammers)
03:25:35 <srhb> sigrlami: Missing zlib? Install it from your package manager?
03:27:23 <sigrlami> srhb: zlib installed, as I understand this is problem with ld. Maybe, create soft link to existing library?
03:27:44 <srhb> sigrlami: Not sure, it sounds like it really is hs-zlib -- somehow.
03:30:10 * hackagebot tamper 0.1.7.0 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  http://hackage.haskell.org/package/tamper-0.1.7.0 (TobiasDammers)
03:31:02 <boothead> Any nixers around at the moment?
03:43:54 <xeno_> so, anyone here today that have installed the haskell platform on a macbook pro with mavericks?
03:45:16 <peteretep> yes
03:47:28 <xeno_> peteretep: brilliant. I fail. cabal install cabal-install => "<command line>: cannot satisfy -package-id HTTP-4000.2.8-cdf033f9d7051824f52cd5101df67509"
03:48:34 <peteretep> Is it similar to: http://stackoverflow.com/questions/7139263/cabal-install-failing-osx-many-unsatisfied-packages
03:50:32 <xeno_> the cache was out of date, recached and trying the cabal-install now, lets see how it goes
03:50:43 <xeno_> oh yes, it worked
03:56:50 <merijn> reservedop and reservedid are subsets of varsym/consym and varid, respectively, right?
03:57:26 <merijn> i.e. if I don't care about actually parsing haskell and only about identifying lexemes the difference is redundant and I can treat them as part of the more general case.
04:04:11 <jmcarthur> i need a map-like data structure that has reasonably fast insert, update, and delete, but most importantly has a really fast way to traverse it sequentially with good locality (and bonus points if it's easy to do something data parallel with it). i'm hoping to find something fairly generic, but am willing to be stuck with only types that can be unboxed into some unboxed vector or something
04:04:28 <jmcarthur> any suggestions? i realize this is kind of asking a lot of a generic data structure
04:04:34 <opqdonut> fingertree?
04:04:46 <jmcarthur> i'm hoping for much better cache locality than a finger tree
04:04:50 <opqdonut> though locality is not that good
04:04:51 <opqdonut> yeah
04:05:03 <opqdonut> you could use a finger tree with vectors in the leaves or something like that
04:05:07 <Cale> jmcarthur: A Data.Map whose values are indexes into an unboxed vector?
04:05:23 <jmcarthur> i looked into edwardk's COLA stuff, but it has a long way to go
04:05:56 <Cale> jmcarthur: Is it important to traverse the keys as well?
04:05:59 <opqdonut> or actually, how about just a B tree?
04:06:09 <Cale> I suppose even if it was, enough redundancy will make it possible
04:06:17 <opqdonut> let's you make the locality - insertion speed tradeoff quite flexibly
04:06:22 <opqdonut> s/'//
04:06:27 <jmcarthur> oh, and another constraint, just to make it harder... i would like to be able to have an efficient zip (matching keys considered at the same time), as well
04:06:33 <jmcarthur> the keys are always ints, if it helps
04:07:02 <Cale> jmcarthur: Insertion is hard, because that'll involve construction of a new array.
04:07:08 <jmcarthur> it is highly desirable but not strictly necessary to have the keys as well (although i guess if you can zip efficiently you can get the keys efficiently anyway)
04:07:09 <Cale> If you want good locality
04:07:42 <jmcarthur> yeah
04:08:02 <jmcarthur> i am willing to amortize it
04:08:23 <jmcarthur> (although of course i'd rather not)
04:08:25 <Cale> Well, the best you can do is O(n) insertion.
04:08:49 <Cale> Er, I guess you could accumulate insertions and eventually build a new array from them
04:08:50 <jmcarthur> well, that's if the constraint is that the whole thing has to be one array
04:08:54 <jmcarthur> yeah
04:09:19 <Cale> I kind of feel like these conditions are inconsistent :)
04:09:25 <jmcarthur> there's always stuff like a sequence of arrays that double in size and merging them as they get bigger, etc.
04:09:31 <jmcarthur> but deletion is hard with that kind of thing
04:10:00 <jmcarthur> inconsistent or just asking for too much?
04:10:10 <Cale> Well, those are the same thing
04:10:47 <Cale> Why is locality important?
04:11:16 <Cale> Have you tried just using e.g. IntMap or something?
04:11:21 <jmcarthur> i intend to write very tight loops over the contents
04:11:44 <edwardk> jmcarthur: i'm happy to work with you on the COLA side of things if you are interested.
04:11:53 <merijn> jmcarthur: Why not convert to a flat representation right before looping?
04:12:11 <merijn> jmcarthur: Then you can restrict yourself to data structures that have efficient "toFlat/fromFlat" operations
04:13:01 <jmcarthur> merijn: heh, in particular, my use case is going to be something like this:   sparse insertions/deletions/updates -> a couple big loops -> sparse i/d/u -> a couple big loops -> ...
04:13:19 <jmcarthur> hmm
04:13:42 <merijn> Anyone know the answer to my reservedid/reservedop vs varid/varsym question?
04:14:00 <jmcarthur> yes, if toFlat/fromFlat can be pretty efficient, though could maybe work. i don't know of any examples of such things though, off the top of my head
04:15:15 * hackagebot gray-code 0.3.1 - Gray code encoder/decoder.  http://hackage.haskell.org/package/gray-code-0.3.1 (SergeyAstanin)
04:16:12 <jmcarthur> i think i'm sold on just having an efficient flatten operation. after all, i'm about to loop over the whole thing anyway, so even if it's linear time, i haven't lost much
04:16:36 <kkaur> because hdbc-mysql is not working with ghc-7.8 I take it from github. after compiling without errors I get: can't load .so/.DLL for: /home/kaiko/.cabal/lib/x86_64-linux-ghc-7.8.2/HDBC-mysql-0.6.6.1/libHSHDBC-mysql-0.6.6.1-ghc7.8.2.so (/home/kaiko/.cabal/lib/x86_64-linux-ghc-7.8.2/HDBC-mysql-0.6.6.1/libHSHDBC-mysql-0.6.6.1-ghc7.8.2.so: undefined symbol: mysql_close
04:16:42 <jmcarthur> maybe the finger tree of vectors isn't so crazy
04:16:49 <kkaur> I have archlinux and mariadb.
04:17:23 <vu3rdd> hello haskellers!
04:17:26 <kkaur> Can somebody give me a hint what should I do?
04:17:46 <vu3rdd> trying to install cabal-install. I already have cabal 1.16.1 installed.
04:18:01 <bergmark> kkaur: i'd ask the maintainer of that package
04:18:32 <vu3rdd> when I do `cabal install cabal-install' it is unable to install parsec which depends on mtl.
04:19:10 <vu3rdd> I then get this message:
04:19:14 <vu3rdd> parsec-3.1.5: dependency "mtl-2.1.2-c30a4a0a7d1a23cc4865fe406853c0c7" doesn't
04:19:14 <vu3rdd> exist (use --force to override)
04:19:30 <jmcarthur> ooh, fingertree of vectors even supports an efficient delete.
04:19:44 <jmcarthur> if it happens to be in the middle of a vector, just slice it
04:20:25 <vu3rdd> I then installed cabal install mtl-2.2.0.1 and then install parsec and it installs fine.
04:20:37 <vu3rdd> just wondering why it didn't automatically pick up the latest mtl
04:22:10 <jmcarthur> opqdonut, Cale, merijn: thanks to all of you. your suggestions and thoughts were very helpful
04:24:01 <bergmark> vu3rdd: maybe that version of mtl was broken
04:24:32 <bergmark> by a previous --force-reinstalls or such
04:25:19 <vu3rdd> bergmark: oh! ok.
04:25:34 <merijn> *Never* use --force-reinstalls
04:25:40 <vu3rdd> bergmark: is there a way to debug such things?
04:25:41 <merijn> Unless you like pain and reinstalling
04:26:39 <Letchik> Is there a way to desugarize let statement?
04:26:45 <vu3rdd> I could install a newer version of cabal-install. However if I do 'cabal install cabal-install' again, it builds all again.
04:27:40 <vu3rdd> Letchik: let x = blah <body> is same as '(\x -> body) blah'
04:27:57 <bergmark> vu3rdd: now it may be too late, but ghc-pkg check will show you broken packages
04:28:24 <vu3rdd> bergmark: thank you.
04:28:51 <Letchik> vu3rdd: no, it's not http://pastebin.com/vH3FuFQf
04:29:02 <vu3rdd> bergmark: I should have run it before I installed a newer version of mtl. But never mind. It never came to my mind.
04:30:01 <bergmark> Letchik: yes there is, the haskell report has the exact steps
04:30:47 <vu3rdd> Letchik: the x in your expression x+1 has the scope on your top-level. Seems like x is not defined there.
04:31:04 <merijn> vu3rdd: Eh, no it doesn't
04:31:05 <Letchik> vu3rdd: yes, that's right
04:31:30 <merijn> vu3rdd: The 'x' in 'x+1' in "let x = x+1 in x" refers to the 'x' you just defined
04:31:58 <vu3rdd> Letchik: http://lpaste.net/104079
04:32:05 <merijn> If you were using lazy natural numbers this would be a way to write infinity. However, for normal numbers this is an infinite loop
04:32:33 <Letchik> vu3rdd: yeah, your desugarization works for some examples, but not for all
04:32:37 <merijn> > let x = x+1 in x -- infinite loop causes a time out
04:32:41 <lambdabot>  mueval-core: Time limit exceeded
04:32:56 <vu3rdd> merijn: I meant the (x+1) expression in the func application.
04:33:28 <Letchik> So, how do I write let x = x + 1 in x?
04:33:39 <Letchik> I mean without let
04:33:39 <fizruk> > (\x -> x) (fix (\x -> 1 : x))
04:33:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:33:48 <fizruk> Letchik: smth like that ^
04:34:06 <fizruk> > (\x -> x) (fix (\x -> 1))
04:34:08 <lambdabot>  1
04:34:20 <fizruk> > let x = 1 in x
04:34:22 <lambdabot>  1
04:34:42 <m09> Letchik: see http://www.haskell.org/onlinereport/exps.html#sect3.12
04:37:23 <bergmark> hmm "the use of case precludes a fully polymorphic typing of the bound variables" does this mean let can't always be desugared?
04:40:04 <fizruk> > (\(x, y) -> take 10 x) (fix (\ ~(x, y) -> (1 : y, 2 : x)))
04:40:05 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
04:40:12 <fizruk> > let x = 1 : y; y = 2 : x in take 10 x
04:40:14 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
04:42:38 <Aetherspawn> does anyone know anything like curl but written in haskell
04:42:51 <Aetherspawn> I'm looking for a library like curl, but one that will actually build on Windows.
04:42:56 <srhb> Aetherspawn: Library or executable?
04:42:58 <srhb> Ah
04:43:00 <srhb> Yeah, there are plenty of those
04:43:06 <srhb> Aetherspawn: What features do you need?
04:43:20 <Aetherspawn> post, cookies, and stuff I guess
04:43:35 <Aetherspawn> enough to log into facebook and do stuff without too much headache
04:43:56 <srhb> Aetherspawn: Try having a look at http-client
04:44:15 <srhb> Though that's a backendy-library
04:45:12 <Aetherspawn> it looks good, thanks
04:45:25 <supki> wreq is a "user-frienly" library on top of http-client
04:46:37 <srhb> wreq looks pretty awesome.
04:54:46 <connor28> hello everyone.
04:54:54 <srhb> connor28: o/
04:57:23 <connor28> i've decided to start programming again, after 8 years or so (and even then, i wrote just simple programs in C). I've decided to start coding again since I want to give my brain something to do in my spare time, but I don't want to code in C - I'd like to try something rather different.  A friend recommended that I take a look at Haskell.
04:57:42 <tdammers> connor28: go for it
04:57:46 <connor28> Would you recommend it for someone with relatively little programming knowledge to learn it?
04:57:56 <connor28> I'd like to have fun, not code to get work done or run experiments
04:58:23 <connor28> i.e. the commercial implications of the language don't matter as much.
04:58:31 <merijn> connor28: Then definitely
04:58:33 <Adeon> then haskell is perfect for you
04:58:35 <Adeon> go for it
04:58:46 <merijn> connor28: Learn You a Haskell is a good starting book
04:58:51 <tdammers> @where lyah
04:58:52 <lambdabot> http://www.learnyouahaskell.com/
04:58:55 <tdammers> also
04:58:55 <srhb> connor28: Haskell is, in my biased opinion, one of the most fun programming languages out there.
04:59:01 <tdammers> @where rwh
04:59:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:59:06 <srhb> connor28: Plenty of brain teasing and really interesting solutions to old problems. :-)
04:59:19 <tdammers> although RWH is more suitable for people who have already been spoiled with imperative thinking
05:00:39 <connor28> Thanks guys.
05:00:48 <connor28> Yes, I need to get a copy of Learn You a Haskell. I haven't heard of GWH, I probably need to look at that.
05:01:26 <connor28> Thankfully i haven't been spoiled with too much of imperative thinking, just enough to run programs in the computer lab during college
05:01:49 <tdammers> I liked RWH, but that's because I already had a fairly solid programming background before getting into Haskell, and didn't need to be taught general programming concepts
05:02:01 <tdammers> so LYAH would probably work better for you
05:03:07 <srhb> connor28: LYAH is available online, in case you missed it. :)
05:04:10 <connor28> Just realized that, srhb!
05:05:51 <merijn> Is the "graphic" class just any char that is not a control/space character? https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
05:09:46 <srhb> merijn: Good quesiton, strange that they don't refer to specific unicode categories
05:11:37 <srhb> Well I guess if uniSmall means Letter -> Lowercase, they do.
05:18:00 <merijn> heh, char literals can be any escaped literal other than '\&'? What's \& do and why is it banned as char literal?
05:18:19 <saml_> > '\&'
05:18:20 <lambdabot>  <hint>:1:3:
05:18:20 <lambdabot>      lexical error in string/character literal at character '&'
05:18:24 <saml_> works
05:18:49 <corgifex> > "\&"
05:18:50 <lambdabot>  ""
05:18:53 <saml_> > '&'
05:18:55 <lambdabot>  '&'
05:18:56 <corgifex> \& is the uncharacter
05:19:12 <saml_> heheheh it's because of unicode
05:19:17 <corgifex> > "a\&b"
05:19:18 <lambdabot>  "ab"
05:19:31 <saml_> > length "\&"
05:19:32 <lambdabot>  0
05:19:45 <saml_> i blame lazy evaluation for that
05:19:58 <vanila> what the heck?
05:19:59 <vanila> lol
05:20:48 <corgifex> > "\65\&78"
05:20:49 <lambdabot>  "A78"
05:21:45 <connor28> why is 92 `div` 10 = 9, and not 9.2?
05:21:55 <vanila> that's integer division
05:22:38 <merijn> connor28: Because div is integer division
05:22:42 <merijn> > 92 / 10
05:22:44 <lambdabot>  9.2
05:23:12 <connor28> Ah I see. Thank you
05:23:32 <benzrf> hey
05:23:35 <benzrf> im lookin at pipes
05:23:48 <saml_> hi benzrf i'm at the other end of the pipes
05:23:52 <benzrf> :-D
05:23:59 <benzrf> why is >-> () for upstream sending?
05:24:05 <benzrf> why not something arbitrary or Void?
05:27:07 <connor28> Why does this error occur when I try to compile: ***Exception: CreateDirectory ".":permission denied (Access is denied.) ?
05:27:09 <connor28> Sorry guys I
05:27:15 <connor28> I know these are rather basic questions
05:27:21 <connor28> and I am following along with YWAH
05:27:28 <connor28> *LYAH
05:27:59 <saml_> connor28, give me code
05:28:05 <saml_> that calls CreateDirectory
05:28:21 <connor28> The only code in the file I've created is "doubleMe x = x+x"
05:28:30 <corgifex> connor28: what command are you usinig?
05:28:41 <corgifex> -i
05:28:48 <connor28> :l baby.hs is how I am running it.
05:28:55 <corgifex> in ghci?
05:29:08 <connor28> Yes.
05:29:09 <connor28> ghci
05:29:21 <corgifex> well, that is weird
05:29:44 <connor28> I remember the same thing happening when I tried to learn Haskell a few months ago too, which is why I stopped. This time I'd like to get past page 2
05:29:44 <saml_> connor28,   which ghci
05:29:46 <corgifex> what OS are you on?
05:30:15 <connor28> I've just installed HaskellPlatform-2013.2.0.0-setup.exe
05:30:20 <saml_> it's purely functional. so prolly can't create directory as side effect
05:30:29 <saml_> connor28, cd c:\Users\youruser
05:30:34 <saml_> where is the file?
05:30:42 <peteretep> connor28: How are you running it?
05:30:44 <saml_> no that doesn't make sense. scratch that
05:30:51 <corgifex> ok, sounds like windows
05:30:54 <peteretep> connor28: What have you put on the command line?
05:31:05 <vanila> it sounds like you are doing the right things
05:31:07 <saml_> did you doubple click ghci icon?
05:31:12 <corgifex> connor28: what directory are you in?
05:31:21 <saml_> it it launched a console looking app
05:31:46 <saml_> can you right click the icon,  Run As ... ,   adiministrator ?
05:33:34 <fizruk> benzrf: what do you mean (>-> ()) ?
05:33:43 <connor28> The file is in D:
05:33:49 <connor28> So I navigated to D: and then ran ghci
05:33:55 <connor28> and then :l baby.hs
05:34:22 <benzrf> fizruk: (>->) composes 2 proxies
05:34:41 <benzrf> upstream interaction on the 1st arg and downstream on the 2nd are unrestricted
05:34:49 <benzrf> downstream from the first to the second must match
05:34:51 <benzrf> but...
05:34:57 <benzrf> upstream from the second to the first must be ()
05:35:00 <benzrf> why not Void?
05:35:02 <connor28> @corgifex I am on Windows 7, 64-bit.
05:35:03 <lambdabot> Unknown command, try @list
05:35:23 <corgifex> connor28: what does ':!cd' say?
05:35:44 <connor28> D:\
05:36:04 <corgifex> connor28: what does 'readFile "baby.hs"' say?
05:36:32 <fizruk> benzrf: hm.. the documentation says “The concrete type synonyms use () to close unused inputs and X (the uninhabited type) to close unused outputs”
05:36:42 <connor28> Not in scope: 'readFile'
05:36:44 <benzrf> oh.
05:36:48 <fizruk> benzrf: i’m not sure why though
05:36:51 <benzrf> fizruk: still
05:37:04 <benzrf> theres both an input and an output there
05:37:09 <benzrf> so it seems like either could be used
05:37:16 <corgifex> that's funny. should be in Prelude
05:37:42 <corgifex> connor28: does 'import System.IO' work?
05:38:25 <connor28> corgifex: The prompt is now "Prelude System.IO>
05:38:41 <corgifex> hmm, ok
05:38:52 <corgifex> connor28: try 'readFile "baby.hs"' again
05:39:25 <saml_> ghci creates a tmp dir in cwd?
05:39:48 <connor28> corgifex: <interactive>:3:10: Not in scope: 'baby' (next line) <interactive>:3:15: Not in score: 'hd'
05:40:06 <connor28> *corgifex: <interactive>:3:10: Not in scope: 'baby' (next line) <interactive>:3:15: Not in scope: 'hs'
05:40:13 <corgifex> ... what are you typing into ghci?
05:40:15 <saml_> > readFile "baby.hs"
05:40:16 <lambdabot>  <IO [Char]>
05:40:29 <saml_> type that without leading >
05:40:31 <fizruk> benzrf: have you read “Appendix: Types”? http://hackage.haskell.org/package/pipes-4.1.1/docs/Pipes-Tutorial.html#g:9
05:40:46 <fizruk> benzrf: it seems to have answers to your questions
05:40:52 <connor28> I used 'cmd' to open the prompt. Used cd to navigate to D:\ and then typed ghci to get into haskell
05:41:45 <benzrf> fizruk: oh
05:41:50 <connor28> saml_: When I type readFile "baby.hs", I get "doubleMe x = x+x"
05:41:51 <benzrf> connor28: D:\
05:41:51 <saml_> connor28, can you type the following:         1+1
05:42:13 <connor28> Yes, those commands worked. Addition, subtraction etc. As did succ, min, max
05:42:25 <corgifex> connor28: ok, try: writeFile "hello.txt" "Hello, world!\n"
05:42:29 <saml_> how about the following:            let doubleMe x = x+x
05:42:38 <corgifex> that should create a file called D:\hello.txt
05:42:54 <saml_> > doubleMe x = x+x
05:42:55 <lambdabot>  <hint>:1:12: parse error on input ‘=’
05:43:05 <saml_> > let doubleMe x = x+x
05:43:06 <lambdabot>  not an expression: ‘let doubleMe x = x+x’
05:43:42 <connor28> corgifex: the hello.txt file got created.
05:44:02 <corgifex> so wtf is going on here
05:44:40 <connor28> saml_: When I type let doubleMe x = x+x, it works
05:45:25 <connor28> and I can do doubleMe x=x+x to double items. However, when I try to run ":l baby.hs, I get the above mentioend errors
05:45:52 <saml_> connor28, is there D:\baby.hs ?
05:46:04 <corgifex> saml_: the readFile worked
05:46:08 <saml_> ah
05:46:25 <corgifex> the question is, why would ghci ever try to mkdir(".")?
05:46:27 <connor28> saml_: Yes, I checked that too, and it is there
05:46:33 <corgifex> and get a permission error for it
05:47:08 <connor28> Yes, I don't understand it too. I've installed Haskell to the standard directory the installer recommended as well, if that makes any difference
05:47:15 <saml_> maybe try to cd into different drive and directory
05:47:15 <merijn> corgifex: I don't think directory names can have periods on windows?
05:47:16 <corgifex> connor28: if you exit ghci (with :q) and run it as 'ghci baby.hs', does the same thing happen?
05:47:28 <saml_> is haskell platform installed in C: ?
05:47:49 <corgifex> merijn: 1) you're wrong, 2) . is the current working directory
05:48:09 <connor28> corgifex: I get the same error when I type 'ghci baby.hs'
05:48:22 <corgifex> so it's bizarre but deterministic
05:48:51 <saml_> it's probably because windows is secure os
05:48:54 <connor28> saml_: I have it installed to the default path the installer recommended. C:\Program Files(x86)\Haskell Platform
05:49:12 <saml_> in D:\, can you do  mkdir hello
05:49:22 <saml_> :q  first. then   mkdir hello
05:49:49 <connor28> Yes, I am coding on my office laptop. Could this be a possible reason? Although I have run simple R programs and Excel VB macros.
05:49:58 <connor28> saml_: This does create a directory successfully
05:50:27 <saml_> cd hello; ghci ../baby.hs
05:50:40 <corgifex> ..\baby.hs
05:51:46 <connor28> that one tells me "*** Exception: CreateDirectory "D:\\": permission denied (Access is denied.)"
05:53:03 <vanila> connor28, did you follow some guide to install it? can I see it?
05:53:47 <connor28> vanila: I did not follow any guide to install it. I downloaded it from http://www.haskell.org/platform/windows.html and ran the installer.
05:54:35 <vanila> what I would try then in your position would be removing that, then trying to just install GHC alone
05:54:56 <vanila> http://www.haskell.org/ghc/download_ghc_7_8_2
05:55:03 <benzrf> >using windows
05:55:05 <benzrf> >2014
05:55:12 <benzrf> >being this chan in irc
05:55:41 <vanila> who are you quoting?
05:56:00 <benzrf> im greentexting
05:56:01 <benzrf> i have a problem
05:56:02 <uotbw> if you have a tree like data structure what is the general pattern to model references between sub elements? io refs or ids? pr recursively?
05:56:18 <vanila> uotbw, I've used ST refs for that
05:57:16 <uotbw> vanila is this working with lens?
05:57:26 <vanila> I dont know about lenses though
05:57:35 <connor28> vanila, OK I'll try that. Curious why the package would cause it to fail though.
05:58:03 <vanila> connor28, computers.. just everything breaks randomly (or is that just my bad luck?)
05:58:52 <connor28> vanila: well it certainly can't hurt, I can always install the platform back. Will try that over the next few mins and report back
05:59:02 <connor28> Thank you all for the help so far, I really appreciate it
05:59:12 <vanila> I hope you get it working
05:59:52 <nesqi> Is there a function in prelude that works like nub but counts the number of occurrencies? Something like, nubCount :: [a] -> [(Int, a)]
06:00:20 <vanila> :t (head &&& length) . group
06:00:21 <lambdabot> Eq a => [a] -> ([a], Int)
06:00:28 * hackagebot graphviz 2999.17.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.17.0.0 (IvanMiljenovic)
06:00:30 * hackagebot Graphalyze 0.14.1.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.14.1.0 (IvanMiljenovic)
06:00:31 <vanila> :t map (head &&& length) . group
06:00:32 <lambdabot> Eq c => [c] -> [(c, Int)]
06:00:32 * hackagebot SourceGraph 0.7.0.6 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.6 (IvanMiljenovic)
06:00:44 <mr-> you may want to sort the list first
06:01:39 <mr-> > group "abaaa"
06:01:40 <lambdabot>  ["a","b","aaa"]
06:02:04 <saml_> connor28, try to open cmd in My Documents or something. and run ghci there
06:02:24 <quchen> Not sure whether this is more efficient, but
06:02:25 <quchen> > M.toList . M.fromListWith (+) . flip zip (repeat 1) $ [1,1,1,2,2,1,1]
06:02:27 <lambdabot>  [(1,5),(2,2)]
06:02:49 <vanila> that's cool!
06:02:51 <saml_> i need to go and fight terrorists brb
06:02:57 <nesqi> > (head && lenght) . group $ sort "abcaba"
06:02:59 <lambdabot>  Not in scope: ‘lenght’
06:02:59 <lambdabot>  Perhaps you meant one of these:
06:02:59 <lambdabot>    ‘length’ (imported from Data.List),
06:02:59 <lambdabot>    ‘BSC.length’ (imported from Data.ByteString.Char8),
06:02:59 <lambdabot>    ‘BSLC.length’ (imported from Data.ByteString.Lazy.Char8)
06:03:16 <quchen> The idea is to build up (key, value) pairs, where all values are one. Then build a Map with that, adding values when the keys collide.
06:03:36 <quchen> The map is then a "key -> #occurrences" lookup table.
06:03:46 <mr-> That's what a perl programmer would have come up with :-)
06:03:46 <quchen> s/map/Map/
06:03:55 <nesqi> right
06:05:36 <corgifex> did someone say $hist{$_}++ for split //, $input; ?
06:13:52 <benzrf> Bifunctor is a subclass of Functor right
06:14:24 <quchen> The kinds don't match.
06:14:35 <benzrf> o wait
06:14:39 <benzrf> right >.<
06:14:48 <benzrf> it is conceptually though isn't it
06:15:07 <benzrf> that is to say, if T is a Bifunctor, T a is a Functor?
06:15:49 <quchen> Yes.
06:16:36 <merijn> It should be possible to add a Functor superclass to Bifunctor
06:16:40 <quchen> 'second' becomes 'fmap' in that case, both satisfying "(a -> b) -> f a -> f b". It's a Bifunctor law to have "second id = id", so the fmap is Functorial.
06:16:41 <mr-> and Flip T a ?
06:16:49 <nesqi> I quess I'll have to learn about arrows now =)
06:16:51 <merijn> "class Functor (f a) => Bifunctor f where"
06:17:05 <merijn> Pretty sure that should work
06:17:07 <benzrf> :t second
06:17:09 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
06:17:21 <quchen> nesqi: Arrows aren't used nearly as often as functors and monads. It's not something you *have* to learn.
06:17:28 <benzrf> 
06:17:29 <quchen> benzrf: Bifunctor has its own 'second'
06:17:43 <benzrf> ah
06:17:57 <quchen> :t Data.Bifunctor.second
06:17:58 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
06:18:16 <benzrf> second == fmap!
06:18:36 <bennofs> merijn: you can have constraints "for all a"? I don't think that's possible
06:19:12 <merijn> bennofs: Those are generally the only constraints allowed, no?
06:19:33 <nesqi> quchen: yeah.. well I mean I can't put code in my program that I don't understand =) So either I write my own nubCount or I learn about arrows.
06:19:55 <quchen> nubCount has nothing to do with arrows. Where did you get that idea?
06:20:05 <bennofs> merijn: I think you cannot have Functor (f a), when a is not fixed. We would be able to write Monoid (f a) then too, wouldn't we (and we wouldn't need Alternative for that)?
06:20:14 <quchen> nesqi: Oooh, because of the (&&&) used.
06:20:31 * hackagebot genifunctors 0.1.1.0 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.1.1.0 (DanRosen)
06:20:33 <nesqi> however... the "perl"-solution with Map preservs the order of the elements which is nice in my case.
06:20:37 <nesqi> quchen: yeah
06:20:51 <merijn> awww, not allowed, yeah :\
06:20:59 <merijn> Sad
06:21:06 <corgifex> (f &&& g) x = (f x, g x)
06:21:09 <quchen> nesqi: Don't worry about arrows for that. (&&&) there is just a shorthand for "(f &&& g) x = (f x, g x)"
06:21:13 <merijn> nesqi: You don't need to really learn arrows for that
06:21:44 <quchen> Arrow is mostly used for golfing tuple functions anyway ;-)
06:22:26 <quchen> All you have to remember is pretty much "(f &&& g) x = (f x, g x)" and "(f *** g) (x,y) = (f x, g y)" to understand the Arrow operators when they're used in here.
06:22:51 <nesqi> ok
06:22:55 <merijn> nesqi: Simply learn the that (->) is an arrow and that for example "(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')" becomes "((->) b c) -> ((->) b c') -> ((->) b (c, c'))" becomes "(b -> c) -> (b -> c') -> (b -> (c, c'))"
06:23:03 <corgifex> :t (&&&) `asTypeOf` liftA2 (,)
06:23:04 <lambdabot> (Arrow a, Applicative (a b)) => a b c -> a b c' -> a b (c, c')
06:23:40 <corgifex> :t (&&&) `asAppliedTo` id
06:23:40 <lambdabot> (a -> a) -> (a -> c') -> a -> (a, c')
06:24:17 <Okasu> corgifex: When I see (f &&& g) x = (f x, g x) I recall http://www.jsoftware.com/help/learning/diag09.gif from J for some reason. :)
06:24:18 <benzrf> :t (&&&)
06:24:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
06:25:12 <corgifex> ooh, nice
06:26:17 <Okasu> x (f g h) y   means    (x f y) g (x h y) Textual version of that diagram.
06:28:23 <vanila> Okasu, lol APL
06:30:33 * hackagebot classy-prelude 0.9.2 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.2 (MichaelSnoyman)
06:32:20 <benzrf> lr
06:35:33 * hackagebot classy-prelude-conduit 0.9.2 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.2 (MichaelSnoyman)
06:35:35 * hackagebot classy-prelude-yesod 0.9.2 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.2 (MichaelSnoyman)
06:35:37 * hackagebot conduit-combinators 0.2.5.2 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.5.2 (MichaelSnoyman)
06:35:39 * hackagebot mono-traversable 0.6.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.0 (MichaelSnoyman)
06:35:41 * hackagebot streaming-commons 0.1.2.4 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.2.4 (MichaelSnoyman)
06:40:43 * hackagebot yesod-auth 1.3.0.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.0.5 (MichaelSnoyman)
06:40:45 * hackagebot yesod-form 1.3.9 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.9 (MichaelSnoyman)
06:43:21 <quchen> Okasu: That in turn reminds me of https://en.wikipedia.org/wiki/File:INTERCAL_Circuitous_Diagram.svg
06:46:14 <sveit> I asked this question yesterday, but got disconnected before I could read the answers. I have a relatively deep class structure, an example of which I show here: http://lpaste.net/50227087021178880 . There is a wrapper class at the end called RadFileLine taht I need since when I parse the file (with Attoparsec, it is gigantic and needs the extra speed) i am interested in the relative ordering of the lines,
06:46:16 <sveit> so I need to put them in a list and hence a wrapper type. Unfortunately, this wrapper type, along with the other "wrapper" types, forces me to write a good amount of boilerplate code. Does haskell have a better way to do deal with this situation? Before I got disconnected, someone suggested I didn't need the wrapper or list at all, but relative ordering matters to me and I am not sure how to do this
06:46:18 <sveit> otherwise?
06:48:01 <quchen> merijn, bennofs: Bifunctors has data types to make various Functors out of Bifunctors, namely Join, Joker, Clown, Flip.
06:48:25 <quchen> And WrappedBifunctor for good measure.
06:51:42 <merijn> sveit: Slight terminology remark, in Haskell "class" generally refers to a typeclass and we'd call, for example, RadFileLine an "datatype", "abstract datatype" or "ADT"
06:52:31 <merijn> sveit: What sort of "boilerplate code" are you referring too?
06:55:49 <aspidites> i seem to be missing something obvious. should creating profile data (eg +RTS -hc -p) generate an image file, or is there some program made specifically for visualizing the resulting .prof and/or .hc file?
06:55:57 <aspidites> .hp file*
06:56:13 <merijn> aspidites: There is a program for visualising profiling data, yes
06:56:22 <merijn> I forgot the name, though. I'm pretty sure RWH mentions it
06:57:09 <aspidites> ok thanks. i've come across like 3 different pages that mention the correct command line options and just assume you know how to get the image
06:57:53 <benzrf> i like haskell and #haskell cuz it helps me feel dumbhat
06:57:55 <benzrf> *dumb
06:58:04 <benzrf> which is good cuz otherwise i start to get cocky
06:58:34 <aspidites> ah, hp2ps merijn
07:00:32 <bennofs> aspidites: also, if you want color, run hp2ps with the '-c' argument :) Took me a while to notice that
07:02:13 <aspidites> bennofs: wow. i was just wondering about that. thanks :P
07:02:35 <merijn> ugh, is there a way to use the "Monoid b => Monoid (a -> b)" instance for Bool without explicitly wrapping all my functions to use Any?
07:04:45 <merijn> Or a mconcatMap for that matter :p
07:05:22 <merijn> :t foldMap (Any .)
07:05:23 <supki> :t ala Any foldMap
07:05:24 <lambdabot> Foldable t => t (a -> Bool) -> a -> Any
07:05:24 <lambdabot> Foldable t => t Bool -> Unwrapped Any
07:05:26 <fizruk> :t F.concatMap (fmap Any) $ [(> 1), (< 9)]
07:05:26 <lambdabot> lexical error at character '\FS'
07:05:44 <merijn> :t ala
07:05:46 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
07:05:58 <supki> :t alaf Any foldMap
07:05:59 <lambdabot> Foldable t => (a -> Unwrapped Any) -> t a -> Unwrapped Any
07:06:24 <quchen> ala = "wrap, operation, unwrap"
07:06:30 <merijn> "foldMap (Any .)" seems cleaner
07:06:47 <supki> foldMap (Any .) does not unwrap
07:06:58 <fizruk> merijn: you need getAny also
07:06:59 <merijn> oh, right
07:07:06 <quchen> I don't think sections of (.) are ever "cleaner".
07:07:11 <merijn> :t getAny . foldMap (Any .)
07:07:12 <lambdabot>     Couldn't match type ‘a -> Any’ with ‘Any’
07:07:12 <lambdabot>     Expected type: (a -> Bool) -> Any
07:07:12 <lambdabot>       Actual type: (a -> Bool) -> a -> Any
07:08:14 <merijn> Where's "ala" from in the first place?
07:08:20 <Sculptor> howdy
07:09:09 <merijn> @hoogle ala
07:09:11 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:09:11 <lambdabot> Graphics.UI.GLUT.Callbacks.Window DialAndButtonBoxButton :: ButtonIndex -> KeyState -> DialAndButtonBoxInput
07:09:11 <lambdabot> Graphics.UI.GLUT.Callbacks.Window type DialAndButtonBoxCallback = DialAndButtonBoxInput -> IO ()
07:09:31 <fizruk> merijn: Data.Newtype or lens
07:09:39 <mr-> merijn: control.lens.wrapped I think
07:09:45 <corgifex> http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#v:ala
07:10:45 <sveit> merijn: the boiler plate is mostly wrapping/unwrapping the list type
07:11:04 <sveit> merijn: my data ends up getting "buried" pretty deeply
07:11:28 <sveit> merijn: so I suspect this is not the "idiomatic" haskell way to handle this problem
07:11:32 <merijn> sveit: Do you have some example? I'm having a hard time understanding what you mean?
07:11:45 <connor28> hello everyone.
07:11:52 <benzrf> sup connor28
07:12:02 <benzrf> protip: dont use windows if its an option to not
07:12:10 <connor28> Hey benzrf
07:12:10 <corgifex> I'm on windows
07:12:17 <benzrf> corgifex: gross
07:12:28 <corgifex> benzrf: no u
07:12:31 <merijn> meh, I'll just define it myself, feels silly to include a big dependency for something that could as easily be replaced by a one line function
07:12:53 <connor28> I was here a little while ago having some difficulty running programs with ":l baby.hs". I've tried uninstalling and reinstalling the Haskell package but I get the same error (***Exception: CreateDirectory ".": permission denied (Access is denied.))
07:12:59 <merijn> benzrf: That's not really a constructive remark and I fail to see how it serves any purpose other than trolling
07:13:16 <corgifex> connor28: do you have an antivirus?
07:13:20 <connor28> Yes I do
07:13:33 <corgifex> might be related
07:13:43 <connor28> I have McAfee
07:13:47 <merijn> corgifex: Wow, if that ends up being the issue you're master of inference :)
07:13:57 <corgifex> well, it's a mysterious permission error
07:14:18 <corgifex> I've seen that kind of thing being caused by antivirus interference
07:14:48 <sveit> so going from my old (http://lpaste.net/50227087021178880) example, i end up with a list of type [RadFileLine] after my parse. Suppose I want to get a [SRTCMD]. Then I have to filter for RadCMDLine, then pull out a SRTCMDLine, then pull out the SRTCMD itself
07:14:59 <connor28> Ah ok. I have an office issued Dell Latitude E6430 that comes with Windows 7
07:15:13 <connor28> So there's no way I can get around this, huh?
07:15:58 <connor28> McAfee Host Intrusion Prevention, McAfee Agent, McAfee VirusScan Enterprise + AntiSpyware Enterprise
07:17:05 <jaffachief> hi, is there a way to pass flags to dependencies in a cabal file?
07:17:11 <sveit> merijn: so for example map (srtCMD . (\(RadCMDLine c) -> c)) . filter (\c -> case c of {(RadCMDLine _) -> True; _ -> False})
07:17:25 <supki> jaffachief: no
07:17:37 <merijn> sveit: You may want to look into lenses (lens is the most popular library, but it's types are...a wee bit intimidating, lens-family is a slightly simpler library that can at least cover the "simplest" use cases of lens)
07:17:56 <jaffachief> supki: oh well. Thanks
07:18:00 <merijn> jaffachief: flags shouldn't be allowed to change the interface for a library
07:18:35 <merijn> sveit: FYI, that example is a bit...redundant?
07:18:46 <jaffachief> Is there a way of making cabal replace integer-gmp with integer-simple as a dependency?
07:18:50 <harlanhaskins> Can anyone help me map a function of type `Eq a => [a] -> [(Integer, a)]` to [[a]]?
07:19:28 <sveit> merijn: how is it redundant?
07:19:37 <harlanhaskins> Map isn't working.
07:19:43 <harlanhaskins> Couldn't match expected type `[a] -> (Integer, a)'
07:19:43 <harlanhaskins>                 with actual type `([a0] -> Integer, [a1] -> a1)'
07:19:49 <vanila> harlanhaskinsw: i dont really understand what you want to do
07:19:55 <vanila> harlanhaskins
07:19:56 <srhb> harlanhaskins: I assume you want to collect all the as into those with the same Integer?
07:20:12 <merijn> sveit: hmm, I guess filter wants a bool. I was thinking you could combine the unwrapping with the rest, but I guess that's not as trivial as I first though
07:20:13 <benzrf> Control.Newtype looks interesting
07:20:14 <benzrf> :t ala
07:20:16 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
07:20:19 <harlanhaskins> Ah
07:20:21 <benzrf> yo what
07:20:28 <merijn> sveit: You could still do it using fold
07:20:31 <benzrf> :t Control.Newtype.ala
07:20:32 <lambdabot> Not in scope: ‘Control.Newtype.ala’
07:20:34 <benzrf> :[
07:20:39 <harlanhaskins> I've got a list of lists of a's, and each list was created with `group`.
07:20:51 <connor28> And in the event that I can't run Haskell on my work laptop, what recommendations do you have to learn a new language? I know a bit of C but that's pretty much it. As I described earlier, I'd llike to learn something just to get a few old brain cells working again, not for any earnings/career based objectives
07:20:54 <srhb> harlanhaskins: So convert into a map with the number in each group?
07:20:59 <srhb> Map*
07:21:06 <harlanhaskins> srhb: Yes
07:21:11 <sveit> merijn: true. do you see any other improvements? perhaps to the type structure itself?
07:21:21 <User941> stu "d!ckless" lantz betrays all; trannys & queers(chaste Homos/a$$holes), rule; http://en.wikipedia.org/wiki/Lists_by_country
07:21:24 <User941> gone
07:21:27 <harlanhaskins> (I'm brand new to Haskell)
07:22:01 <srhb> harlanhaskins: You could consider doing this by folding over the list with the map as an accumulator
07:22:04 <merijn> :t foldr (c cs -> case c of { (Left c') -> c':cs; _ -> cs }) []
07:22:06 <lambdabot>     Pattern syntax in expression context:
07:22:06 <lambdabot>         c cs -> case c of {
07:22:06 <lambdabot>                   (Left c') -> c' : cs
07:22:07 <srhb> Map*, dammit.
07:22:25 <gunnarsson> sveit: fun fact, your names means a farm or the country in Icelandic
07:23:13 <merijn> :t foldr (\c cs -> case c of { (Left c') -> c':cs; _ -> cs }) []
07:23:15 <lambdabot> [Either a t] -> [a]
07:23:35 <merijn> sveit: So that'd work, but in general you'll probably want to investigate lenses for easy accessors
07:25:51 <srhb> harlanhaskins: Does that help?
07:26:06 <sveit> merijn: ok, but should I somehow be able to avoid the wrapper type altogether?
07:26:31 <harlanhaskins> srhb: It does. I'm trying to figure out the function I can pass to foldr to convert this.
07:26:49 <srhb> harlanhaskins: Consider what it must do in the case of an empty (sub)list first
07:27:18 <harlanhaskins> I'd really only return an empty list.
07:27:41 <srhb> harlanhaskins: Oh, you don't want to use a Map? Then there's an easier route.
07:28:03 <harlanhaskins> Well, I'd like to use a Map. This seems like the case for a map.
07:28:06 <harlanhaskins> Map*
07:28:14 <srhb> harlanhaskins: I'd say so, yes.
07:28:25 <harlanhaskins> srhb: I'd like to convert [a] -> [(Integer, a)]
07:28:41 <srhb> harlanhaskins: You mean [[a]] -> [(Integer, a)
07:28:58 <srhb> harlanhaskins: consider map length
07:29:01 <harlanhaskins> srhb: Right!
07:29:04 <merijn> sveit: I can't see an easy way to avoid it, but then I've only though about it for a few second
07:30:25 <harlanhaskins> srhb: Wouldn't map length give me just the length of each sublist?
07:30:42 <srhb> harlanhaskins: Yes, but since they're already grouped, that's half of the job
07:30:43 <harlanhaskins> srhb I could create two lists (one of lengths and one of initial values) and zip them...?
07:31:09 <srhb> harlanhaskins: You could do that, or you could map a function that given a list produces a tuple of length and (first) value
07:31:15 <merijn> harlanhaskins: Why not write a function "a -> (Int, a)" and map that?
07:31:15 <srhb> But you need to prune empty lists.
07:31:30 <merijn> srhb: group never creates empty lists :)
07:31:48 <srhb> Ah, shiny.
07:31:55 <harlanhaskins> merijn: I've got that function, but Map isn't letting me.
07:32:06 <merijn> harlanhaskins: Who mentioned Map?
07:32:07 <srhb> harlanhaskins: Why do you write Map uppercase?
07:32:19 <srhb> map yourFunc yourList -- job done.
07:32:37 <merijn> :t map (undefined :: a -> (Int, a))
07:32:39 <lambdabot> [a] -> [(Int, a)]
07:32:46 <harlanhaskins> I'm mapping over [[a]], so my map function is :: Eq a => [a] -> [(Integer, a)]
07:32:54 <srhb> map (\x -> (length x, head x)) . group $ [1,1,1,2,3,4,5,4]
07:32:58 <srhb> > map (\x -> (length x, head x)) . group $ [1,1,1,2,3,4,5,4]
07:33:00 <lambdabot>  [(3,1),(1,2),(1,3),(1,4),(1,5),(1,4)]
07:33:23 <srhb> oops, needs a sort.
07:33:45 <harlanhaskins> Rather my function is :: [a] -> (Int, a)
07:34:33 <srhb> harlanhaskins: This one, right? \xs -> (length xs, head xs)
07:34:33 <harlanhaskins> Couldn't match expected type `[a] -> (Int, a)'
07:34:34 <harlanhaskins>                 with actual type `([a0] -> Int, [a1] -> a1)'
07:35:49 <harlanhaskins> srhb: Yep. I replaced my implementation with that lambda and ghci is still telling me it can't match the types.
07:36:09 <srhb> harlanhaskins: Time to paste some code, you're not doing what you're saying you're doing. :)
07:36:13 <srhb> harlanhaskins: lpaste.net
07:36:20 <harlanhaskins> Oh man.
07:36:23 <harlanhaskins> Whoops.
07:36:33 <merijn> In attoparsec is there a convenient way to use "manyTill :: Alternative f => f a -> f b -> f [a]" without throwing away the 'b'?
07:36:33 <harlanhaskins> I was creating the tuple in point-free form.
07:36:43 <harlanhaskins> Which meant I was just throwing functions into a tuple.
07:36:46 <srhb> harlanhaskins: There we go. :-)
07:36:48 <harlanhaskins> Not applying them.
07:37:10 <merijn> hmm, I guess that's just "many", then
07:37:57 <harlanhaskins> srhb and merijn: Thanks!
07:38:01 <srhb> harlanhaskins: o/
07:42:48 <dmwit_> :t liftM2 (,) length head
07:42:49 <lambdabot> [a2] -> (Int, a2)
07:42:57 <harlanhaskins> *Main> runlengthInt 2322223777777777
07:42:57 <harlanhaskins> [(1,2),(1,3),(4,2),(1,3),(9,7)]
07:43:00 <harlanhaskins> Woot!
07:44:58 <srhb> harlanhaskins: Now implement it with a single foldr into a Map. :-)
07:45:13 <benzrf> srhb: ah, but it's not counts
07:45:16 <benzrf> it's runs!
07:45:24 <benzrf> c-could this be a job for comonads
07:45:26 <benzrf> ?
07:45:40 <dmwit_> Isn't the standard RLE implementation fine for this?
07:45:46 <srhb> Oh right. I didn't think it was
07:45:47 <benzrf> probably!
07:46:16 <dmwit> :t toDigit
07:46:17 <lambdabot>     Not in scope: ‘toDigit’
07:46:17 <lambdabot>     Perhaps you meant ‘isDigit’ (imported from Data.Char)
07:46:21 <dmwit> :t fromDigit
07:46:22 <lambdabot> Not in scope: ‘fromDigit’
07:46:25 <dmwit> too bad
07:46:41 <dmwit> :t map (head &&& length) . group . show
07:46:42 <lambdabot> Show a => a -> [(Char, Int)]
07:47:25 <dmwit> :t map (head &&& length) . group . map digitToInt . show
07:47:26 <lambdabot> Show a => a -> [(Int, Int)]
07:48:18 <mizu_no_oto> I'm trying to get a simple graphical program working using diagrams and the Gtk backend, and I'm running into the error "user error (widgetGetDrawWindow: no DrawWindow available (the widget is probably not realized))".  I'm probably forgetting to do something simple, but what is it? http://lpaste.net/104083
07:49:54 <hellen_3> something not selected or predefined
07:55:45 <hubblebub> Hi, I'm trying out Repa, and performance seems to be atrocious, more than 20x slower for adding two unboxed arrays than numpy. Am I doing something wrong? https://gist.github.com/anonymous/9329ba408f7bc334d385
07:59:24 <byorgey> mizu_no_oto: I'm not sure, but have you seen this example program? http://www.cmears.id.au/articles/diagrams-gtk-mouse.html
07:59:34 <alpounet> hubblebub: makeArray1d requires computing the length of the list
07:59:35 <dolio> hubblebub: You're making two 7 million element lists and then computing their length, and then they still have to be used after that.
08:00:19 <alpounet> you're first computing the list, so traversing it, then you retraverse it to build the repa array. that's most likely the main reason
08:00:23 <dolio> So that forces huge lists into memory.
08:00:23 <dmwit> mizu_no_oto: You can't render before running mainGUI.
08:00:26 <alpounet> computing the length*
08:00:28 <dmwit> mizu_no_oto: Connect to the exposeEvent instead.
08:00:43 * hackagebot ixmonad 0.50 - Embeds effect systems into Haskell using an parameteric effect monad (the |Effect| type class)  http://hackage.haskell.org/package/ixmonad-0.50 (DominicOrchard)
08:00:56 <dmwit> mizu_no_oto: "realized" means the data structure is allocated, but we haven't connected to the X server (or whatever) and turned it into a Real Thing yet.
08:01:02 <mizu_no_oto> dmwit: could I also transpose the call to mainGUI and defaultRender?
08:01:10 <dmwit> mizu_no_oto: rather, "not realized" means that =P
08:01:17 <dmwit> mizu_no_oto: no, not really
08:01:24 <dmwit> mizu_no_oto: Unless you want to render after the program exits. =)
08:01:43 <dmwit> mizu_no_oto: As I said, the correct way is to render inside an expose event.
08:02:00 <mizu_no_oto> Ok
08:03:36 <dmwit> mizu_no_oto: You will probably also want to add your drawing area as a child to the window.
08:03:38 <hubblebub> alpounet: dolio oh right, thanks guys let me try removing that
08:03:46 <vise890> hi . i'm using ghcmod-vim . I have 2 submodules in a directory `Todo` named `Todo.Todo` and `Todo.Actions` .  Inside `Todo.Actions` i'm doing an `import Todo.Todo`, however, when I save the file I get a linting error from ghcmod saying that it could not find `Todo.Todo` ... It's thinking that the `Todo` directory is the project root...
08:05:11 <hakujin1> what is the preferred command line arg parser these days?
08:05:44 * hackagebot apiary 0.1.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.1.0.0 (HirotomoMoriwaki)
08:05:49 <dmwit> I still use getopt. But then, I haven't needed anything terribly complicated.
08:05:55 <byorgey> hakujin1: cmdargs and optparse-applicative are the two main ones I know about.
08:06:09 <alpounet> hakujin1: cmdargs, getopt, optparse-applicative, hflags are all pretty stable and widely used
08:06:32 <byorgey> cmdargs might be quicker to get started with, but I am now a fan of optparse-applicative (it's much more compositional)
08:06:45 <hakujin> I'll read up on those, thanks all
08:07:20 <dmwit> Somebody should make a type inference debugger.
08:10:36 <monochrom> I have an elaborate example of optparse-applicative at https://github.com/treblacy/random-read
08:12:13 <dmwit> What, something from monochrom that's not on vex.net?!
08:12:35 <monochrom> it's either vex.net or github :)
08:12:38 <ion> Perhaps github.com is secretly on vex.net
08:12:42 <dmwit> hehehe
08:12:42 <nclarke> My example using optparse-applicative with Vinyl: https://github.com/nc6/tabula/blob/master/Tabula/Options.hs
08:12:46 <cpennington> I know good practice is to have type definitions in their own module. Should instance declarations go in that module as well? What about helper/convenience methods for those types?
08:13:09 <monochrom> no, good practice is not necessary type definitions in their own module.
08:13:11 <dmwit> cpennington: It's good practice to put instances either next to the class or next to the type they're giving an instance for.
08:13:18 <bennofs> cpennington: instances should either be defined where the type is defined or to where the class is defined
08:13:25 <cpennington> ok
08:13:32 <dmwit> cpennington: I've never heard of the "type definitions in their own module" advice, though.
08:13:55 <cpennington> oh. It seemed like that was a pattern I'd seen in a number of packages on hackage.
08:14:15 <monochrom> yes, approximately 1 person insists on doing that
08:14:18 <bennofs> cpennington: it's sometimes done to hide to constructors of a data type
08:14:24 <alpounet> you mean the "X.Types" modules
08:14:27 <alpounet> ?
08:14:33 <cpennington> right, X.Types, exactly
08:14:42 <dmwit> Ah, I misunderstood what you were saying.
08:14:47 <cpennington> could be I'm misunderstanding the rational for that particular module
08:14:47 <dmwit> I thought you were saying one type per module. =P
08:14:55 <cpennington> oh, no.
08:14:59 <monochrom> don't count how many packages do that. count how many persons do that. that is the real pattern.
08:15:08 <dmwit> Well. X.Types is common. Dunno if it's best practice, but it is common.
08:15:32 <ion> bennofs: Foo.Bar exporting Bar without constructors and Foo.Bar.Internal exporting everything may or may not be more appropriate if modules other than Foo.Bar need it.
08:15:58 <ion> monochrom: Who is the approximately 1 person?
08:16:21 <dmwit> I think monochrom is thinking of the DescriptiveModuleName.T and DescriptiveModuleName.C guy, maybe?
08:16:27 <monochrom> yes
08:17:14 <dmwit> Which is very different from what cpennington is talking about.
08:17:25 <dmwit> (And I had the same misunderstanding.)
08:18:19 <haasn> I've done Foo.Types very often
08:18:32 <haasn> To work around GHC's poor support for recursive modules
08:18:55 <cpennington> yeah, that's why I started doing it (and was my understanding for the general rationale behind it)
08:19:24 <cpennington> thanks for the pointer on instance declaration locations
08:20:03 <monochrom> if you define a million types, it probably makes sense. if you define just 5, I don't think it's worth the trouble.
08:20:05 <shachaf> haasn: Modules that use values and types that they themselves define are the worst.
08:20:15 <mizu_no_oto> dmwit: I figured out how to use exposeEvent and onKeyPress.  How do you keep local state around, though, so you can update the game state each time you render?
08:21:38 <dmwit> mizu_no_oto: IORef or inversion of control
08:21:45 <dmwit> mizu_no_oto: I have an SO answer about it, one moment
08:22:00 <cpennington> I suppose in the case of the particular library that I'm writing, there's a fairly nice hierarchy (RPC needs Channels needs Wire), so maybe it's better to just put the types near the functions that use them
08:22:39 <dmwit> mizu_no_oto: http://stackoverflow.com/q/12002814/791604
08:22:50 <mizu_no_oto> thanks
08:24:26 <halvorg> Anyone know why I segfault when trying to open a OpenGL 3.3 context using GLFW-b? No useful error information at all.
08:24:34 <halvorg> (core profile)
08:25:33 <hellen_3> shachaf: preech it brother!
08:26:49 <dmwit> halvorg: I don't know anything about it. But I suspect the people who do would want to see your code.
08:27:01 <cpennington> shachaf: what do you mean?
08:27:26 <shachaf> Never mind. I found the phrase "recursive modules" funny.
08:27:34 <cpennington> ah
08:28:02 <sveit> what are the different ways to write a function like fromIntegral where you could presumably have different implementations for different return types? is this only possible using typeclasses or are there other methods?
08:29:03 <dmwit> Type classes are the canonical way to have implementation depend on type. Probably something similar could happen with GADTs or something like that, and of course you could just have different names for the different implementations.
08:29:29 <dmwit> But even with GADTs I would expect you'd have to pass in a value-level description of the type somehow.
08:29:40 <dmwit> And making that convenient would need... you guessed it... type classes. =P
08:34:50 <Bobjenkins> Hello
08:35:09 <Iceland_jack> hey Bobjenkins
08:35:54 <Bobjenkins> hows it going!
08:36:51 <Iceland_jack> Fine I suppose!
08:37:27 <Iceland_jack> Just prepared some food after playing with the dog for ages
08:37:44 <Bobjenkins> I just found haskel and was told it was a nice community so I wanted to check it out and find out exactly what goes on around here. :)
08:37:57 <Iceland_jack> Haskell has a wonderful community
08:38:07 <Iceland_jack> Are you interested in learning?
08:38:35 <Bobjenkins> Yes
08:38:38 <Iceland_jack> A good introduction to Haskell is the book Learn You a Haskell for Greater Good
08:38:39 <Iceland_jack> @where lyah
08:38:39 <lambdabot> http://www.learnyouahaskell.com/
08:38:48 <Bobjenkins> OK cool thanks
08:38:56 <Iceland_jack> you can also try it out here, using lambdabot
08:39:19 <Iceland_jack> if you write an expression prefixed with '> ' it evaluates it
08:39:20 <Iceland_jack> > 5 + 10
08:39:21 <lambdabot>  15
08:39:50 <Bobjenkins> what is lambda bot?
08:40:02 <Bobjenkins> >5+10
08:40:03 <hellen_3> god
08:40:13 <dmwit> Bobjenkins: You need both a ">" and a space " ".
08:40:15 <nclarke> Bobjenkins: You need a space
08:40:15 <FireFly> It's a bot that evaluates Haskell snippets
08:40:15 <Iceland_jack> lambdabot is just a bot that does all sorts of helpful things
08:40:23 <Bobjenkins> okok
08:40:38 <Iceland_jack> Bobjenkins: you can also ask it for the type of an expressions
08:40:42 <Iceland_jack> @ty 'h'
08:40:43 <Bobjenkins> ill go on their wbesite and check it out
08:40:43 <lambdabot> Char
08:40:48 * hackagebot yesod-bin 1.2.9.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.9.2 (MichaelSnoyman)
08:40:49 <Iceland_jack> 'h' is a Char (character)
08:41:05 <Bobjenkins> yup
08:41:24 <Bobjenkins> > 6 + 26
08:41:26 <lambdabot>  32
08:41:52 <Iceland_jack> > map toUpper "Testing, Bobjenkins!"
08:41:53 <Bobjenkins> so i see there are a LOT of people on here
08:41:53 <lambdabot>  "TESTING, BOBJENKINS!"
08:41:58 <Bobjenkins> but
08:42:02 <Bobjenkins> not many people are speaking
08:42:08 <Bobjenkins> any particular reason?
08:42:26 <Iceland_jack> Many people are lurking, but it depends on the time of day
08:42:31 <shapr> Bobjenkins: I'm working, but thinking about support vector machines
08:42:37 <shapr> Bobjenkins: are you coding in Haskell?
08:42:40 <Maior> Bobjenkins: I have little reason to
08:42:53 <Bobjenkins> I see
08:43:02 <shapr> Bobjenkins: do you write code for a living?
08:43:09 <Bobjenkins> no i do not
08:43:19 <Iceland_jack> Have you programmed before?
08:43:24 <nclarke> Bobjenkins: I'm debugging C. I flip over here when the pain becomes too late
08:43:28 <nclarke> *great
08:43:32 <Bobjenkins> I have programmed before bu only basic things
08:43:41 <Bobjenkins> but*
08:43:50 <Iceland_jack> LYAH assumes some knowledge of (imperative) programming but you can get through it without it I think
08:43:54 <shapr> well, Haskell is a good language to learn if you want to be a great programmer.
08:44:09 <Bobjenkins> cool
08:44:12 <Bobjenkins> um
08:44:25 <Bobjenkins> haskell is only a function oriented language right?
08:44:37 <sagittarian> no, just a functional language
08:44:40 <Iceland_jack> it's a functional language
08:44:42 <shapr> Bobjenkins: it's "general purpose" meaning it can do the same thing as any other language
08:44:44 <Bobjenkins> Ok
08:44:44 <sagittarian> Bobjenkins, how did you hear about haskell?
08:44:48 <shapr> Bobjenkins: but it does have a particular slant
08:44:57 <Bobjenkins> I heard about through forums
08:45:12 <benzrf> Bobjenkins: haskell is so cool
08:45:19 <benzrf> it's like
08:45:21 <Bobjenkins> I like to just go on random tech forums and see what they are talking about and check it out.
08:45:21 <benzrf> mindblowing n shit
08:45:23 <Iceland_jack> (“functional language” is a very flexible word mind you)
08:45:24 <sagittarian> under what context was it brought up?
08:45:35 <Iceland_jack> word, concept, …
08:45:39 <ew0000> Haskell is the coollest language ever!
08:45:50 <sagittarian> yeah, people say that lisp is a functional language
08:46:12 <Bobjenkins> It was brought up as a "budding" IRC which is great for relative noobs to the programming world.
08:46:15 <ew0000> Bobjenkins, find something to do, and do it in haskell
08:46:22 <Bobjenkins> ok
08:46:23 <ew0000> DO IT
08:46:27 <ironChicken> http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs says that, for marshalling Strings into struct { char *s } there is no "good general solution"
08:46:30 <Iceland_jack> Being “functional” is a huge goal post, and it has moved with time
08:46:32 <ironChicken> is that still true?
08:46:51 <Bobjenkins> are you asking me?
08:47:14 <ew0000> Yes and no.
08:47:24 <Iceland_jack> > length "Hello, World"    -- Random code
08:47:25 <lambdabot>  12
08:47:26 <Bobjenkins> ?
08:47:42 <Bobjenkins> ironChicken
08:48:15 <ew0000> length [1, 2, 3, 4]
08:48:16 <ironChicken> Bobjenkins: my question is not directed at you
08:48:20 <ew0000> > length [1, 2, 3, 4]
08:48:21 <lambdabot>  4
08:48:26 <Bobjenkins> ok
08:48:48 <c_wraith> ironChicken: I'd say that's true.  There are a few different options that are each good at specific times, and bad at other times.
08:49:08 <ew0000> but it is not a question beyond your understanding, after one or 3 google searches and a few pages of reading
08:49:52 <ironChicken> c_wraith: ok. do you know of any good descriptions of the options?
08:50:36 <c_wraith> ironChicken: offhand, no
08:50:55 <ironChicken> ok, i'll carry on looking. ty
08:52:17 <Bobjenkins> Thanks for the help Iceland_jack ill be back later I guess!
08:52:42 <Iceland_jack> No problem Bobjenkins, don't hesitate asking if you have any questions
08:56:25 <benzrf> @hoogle (~.)
08:56:27 <lambdabot> No results found
08:57:26 <benzrf> @hoogle (.~)
08:57:26 <lambdabot> No results found
08:57:29 <benzrf> h-huh
08:57:43 <benzrf> :t (.~)
08:57:44 <lambdabot> ASetter s t a b -> b -> s -> t
08:57:46 <benzrf> oh
08:58:49 <benzrf> :t taking
08:58:50 <lambdabot> (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
08:58:55 <benzrf> o-o
08:58:59 <benzrf> w-wha
08:59:04 <benzrf> pfstaa
08:59:15 <benzrf> :t bits
08:59:16 <lambdabot> (Bits b, Indexable Int p, Applicative f, Num b) => p Bool (f Bool) -> b -> f b
08:59:21 * benzrf crawls under a roc
08:59:22 <benzrf> k
08:59:37 <Iceland_jack> phstaa sounds like someone trying to pronounce pasta in a hurry
09:00:08 <benzrf> > bits 8
09:00:09 <lambdabot>  Could not deduce (Control.Lens.Internal.Indexed.Indexable
09:00:10 <lambdabot>                      GHC.Types.Int p0)
09:00:10 <lambdabot>    arising from the ambiguity check for ‘e_18’
09:00:10 <lambdabot>  from the context (Data.Bits.Bits b,
09:00:10 <lambdabot>                    Control.Lens.Internal.Indexed.Indexable GHC.Types.Int p,
09:00:12 <benzrf> o.O
09:00:50 * hackagebot apiary 0.1.0.1 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.1.0.1 (HirotomoMoriwaki)
09:01:50 <FreeFull> > bits [1,2,3]
09:01:51 <lambdabot>  Couldn't match type ‘[]’ with ‘p0 GHC.Types.Bool’
09:01:52 <lambdabot>  Expected type: p0 GHC.Types.Bool (f GHC.Types.Bool)
09:01:52 <lambdabot>    Actual type: [f GHC.Types.Bool]
09:02:05 <FreeFull> > bits [True,False,True]
09:02:06 <lambdabot>  Couldn't match type ‘[]’ with ‘p0 GHC.Types.Bool’
09:02:06 <lambdabot>  Expected type: p0 GHC.Types.Bool (f GHC.Types.Bool)
09:02:06 <lambdabot>    Actual type: [f GHC.Types.Bool]Couldn't match expected type ‘f GHC.Types.B...
09:02:06 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘f...
09:02:06 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘f...
09:02:20 <FreeFull> I don't remember how to use bits
09:02:21 <c_wraith> crawling under a roc sounds dangerous.  Those things like to eat people.
09:02:34 <c_wraith> FreeFull: it's a lens, so..  not like that.  :P
09:02:47 <c_wraith> > 5 ^.. bits
09:02:49 <lambdabot>  [True,False,True,False,False,False,False,False,False,False,False,False,False...
09:03:12 <corgifex> that's a lot of bits
09:03:13 <c_wraith> oh, little endian
09:03:25 <Iceland_jack> > map fromEnum (5 ^.. bits)
09:03:27 <lambdabot>  [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:03:28 <FreeFull> > bits .~ [False,False,True] & 3
09:03:29 <lambdabot>  Couldn't match type ‘[GHC.Types.Bool]’ with ‘GHC.Types.Bool’
09:03:29 <lambdabot>  Expected type: Control.Lens.Setter.ASetter
09:03:29 <lambdabot>                   t0 t0 GHC.Types.Bool [GHC.Types.Bool]
09:03:30 <lambdabot>    Actual type: (GHC.Types.Bool
09:03:32 <lambdabot>                  -> Data.Functor.Identity.Identity GHC.Types.Bool)
09:03:48 <sveit> i have a slow way of doing this, and wondered if someone had a good algorithm: i want a function subF :: (a -> Bool) -> (a -> Bool) -> [a] -> [a] that takes to predicates and a list and returns the subset of the list in between two elements that fulfill the predicate (not including the elements themselves)
09:04:11 <sveit> furthermore, if the two predicates are the same, the list should not be of length zero
09:04:13 <c_wraith> > 5 ^.. taking 8 . bits
09:04:15 <lambdabot>  Couldn't match type ‘s0 -> f0 t0’
09:04:15 <lambdabot>                with ‘Control.Applicative.Const
09:04:15 <lambdabot>                        (Data.Monoid.Endo [GHC.Types.Bool]) (p0 a0 (f0 a0))’
09:04:15 <lambdabot>  Expected type: Control.Lens.Traversal.Traversing p0 f0 s0 t0 a0 a0
09:04:15 <lambdabot>                 -> p0 a0 (f0 a0)
09:04:30 <c_wraith> darn.  That was my best guess at what taking would do
09:04:56 <Iceland_jack> sveit: takeWhile p₂ . tail . dropWhile p₁
09:04:59 <Iceland_jack> something like that
09:05:23 <c_wraith> > (5 :: Word8) ^.. bits
09:05:25 <lambdabot>  [True,False,True,False,False,False,False,False]
09:05:43 <Iceland_jack> > (takeWhile (< 8) . tail . dropWhile (< 5)) [1..]
09:05:45 <lambdabot>  [6,7]
09:06:48 <sveit> Iceland_jack: that's close to what I have, but it's "inclusive"
09:07:46 <Iceland_jack> sveit: Do you want to include up to the last element that matches the first predicate or everything following the first element that does?
09:08:04 <sveit> Iceland_jack: the application is mostly with predicates like (==)
09:08:07 <stevejb> hello, I am trying to perform an operation on a function that has an amount of arguments which is determined at runtime. In particular, I am trying to do numerical integration of an N dimensional function. I am using parTram from ekmett's Numeric.Integration.TanhSinh. I think that there should be a way to define an N dimensional integration (without TH), but not sure how. http://ix.io/ciq
09:08:14 <supki> > 5 ^.. taking 8 bits
09:08:15 <lambdabot>  [True,False,True,False,False,False,False,False]
09:08:43 <sveit> > (takeWhile (not . (== 9)) . tail . dropWhile (not . (== 5)) [1..]
09:08:44 <lambdabot>  <hint>:1:66:
09:08:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:08:57 <sveit> > (takeWhile (not . (== 9)) . tail . dropWhile (not . (== 5))) [1..]
09:08:59 <lambdabot>  [6,7,8]
09:09:05 <sagittarian> how can the number of arguments be determined at runtime?
09:09:21 <sveit> Iceland_jack: nevermind, I got the behavior of takeWhile wrong in my head. Sorry.
09:10:00 <stevejb> sagittarian: in the code snippet I posted, I construct f_multi which takes as argument a list [Double]
09:10:08 <stevejb> the length of this list is an argument
09:10:45 <stevejb> I am probably not articulating this correctly, but the code I posted should clarify what I mean.
09:14:34 <sagittarian> i have almost finished reading through LYAH, would Real World Haskell be a good place to continue learning haskell?
09:14:47 <stevejb> query carter
09:14:51 <Iceland_jack> sagittarian: You may want to check out Simon Marlow's Book
09:14:53 <Iceland_jack> *book
09:14:59 <merijn> sagittarian: Yeah, but I would skip the first couple of RWH chapters
09:15:11 <merijn> sagittarian: As they're basically a rehash of stuff covered by LYAH
09:15:13 <hubblebub> alorente: dolio hi, performance with Repa is still really bad, even without the length call, still only just adding two 1D arrays: https://gist.github.com/anonymous/7df5ec1f2bf6d19ee3ff
09:15:20 <Iceland_jack> http://chimera.labs.oreilly.com/books/1230000000929 it's more up-to-date and I'm not a huge fan of RWH
09:15:27 <cschneid> sagittarian: your best bet is to start writing some code.  You'll very quickly hit things not covered in the basics, and be forced to learn. Iterate
09:15:37 <Iceland_jack> Also what cschneid said
09:15:50 <cschneid> sagittarian: I've been reading / skimming / learning for a long time, and don't make progress unless I'm trying to create something.
09:15:52 <brycelane> noob question: Are ADT's the only source of runtime dynamic behavior in Haskell?
09:16:00 <merijn> sagittarian: Also, some of the RWH chapters are a bit out-of-date (for example, the parsec chapter covers parsec2, instead of 3. So the snippets don't always work, it should still help you understand how parsec3 works, though)
09:16:07 <Iceland_jack> Sadly (or not?) you kind of have to gather a lot of the Haskell information by reading papers and blogs
09:16:08 <merijn> brycelane: In what way?
09:16:10 <sagittarian> yeah, that and a small personal project i was planning on doing, cschneid
09:16:12 <cschneid> the reddit /r/haskell page seems pretty good at code reviewing small/medium sized chunks of code too
09:16:25 <merijn> sagittarian: Also consider "Write yourself a Scheme in 48 hours"
09:16:25 <cschneid> sagittarian: pick the smallest piece that can run on its own, and make it happen.
09:16:40 <Iceland_jack> sagittarian: Could you write a simple date time server?
09:16:40 <sagittarian> oh yeah i wanted to do that, merijn
09:16:43 <brycelane> merijn: so in OO you can override methods to get runtime dynamic behavior based on the underlying instance. Are ADTs the way to get that in Haskell?
09:17:06 <sagittarian> i have some web data i want to scrape, was thinking of doing it in haskell instead of python
09:17:12 <merijn> brycelane: The Haskell way is higher order functions, for example, take sorting
09:17:15 <shapr> Is #haskell still a budding IRC channel? thirteen years and ... how many users these days?
09:17:26 <cschneid> sagittarian: I'm (slowly) working on a book aimed at your question too.  "how the hell do I do useful things in haskell?" for the just-finished-a-book crowd
09:17:30 <cschneid> but I'll not be done for a long while
09:17:46 <merijn> brycelane: Suppose you want to have a "runtime dynamic" sorting method, you use "sortBy :: (a -> a -> Ordering) -> [a] -> [a]"
09:17:55 <brycelane> merijn: that makes sense. I didn't consider that.
09:17:59 <merijn> brycelane: The sorting is defined by the function you pass in
09:18:06 <sagittarian> cschneid, sounds interesting, i probably won't need it by the time you're done though :-)
09:18:16 <cschneid> sagittarian: go prove me right. Go learn :)
09:18:21 <Iceland_jack> Either cschneid hurry up or sagittarian slow down :)
09:18:26 <cschneid> hah
09:18:41 <cschneid> exactly. sagittarian, go learn quickly, and help me review it when I start getting some real content
09:18:45 <Iceland_jack> cschneid: Or alternatively, make sagittarian a test subject :)
09:18:55 <brycelane> merijn: between ADT's and higher order functions, are there other methods of runtime dynamic behavior?
09:19:00 <shapr> cschneid: put the book up on github and let the rest of us contribute?
09:19:29 <cschneid> shapr: trying to make a few bucks on it, rather than open sourcing. Will probably be of the RWH model, where it's free online, plus paid print / ebook versions.
09:19:32 <brycelane> I could see a situation where a function returns a value which is only promised to satisfy a typeclass, but I don't know if that is possible
09:19:39 <shapr> ah, makes sense
09:19:41 <merijn> sagittarian: To be honest, I actually think that implementing a simple programming language is one of the easier "intermediate" haskell projects
09:19:51 <ReinH> cschneid: do you have a publisher?
09:20:03 <sagittarian> merijn, and therefore recommended, or too easy?
09:20:07 <cschneid> ReinH: I do not. I haven't figured out how that'd work yet.
09:20:11 <cschneid> for now, just making a few chapters of content
09:20:12 <merijn> sagittarian: I'd say highly recommended :)
09:20:37 <ReinH> cschneid: you might consider https://leanpub.com/ if you're considering self-publishing
09:20:39 <merijn> sagittarian: After finishing a compiler course years ago I believe that writing 1 (or more!) compilers should be a mandatory rite of passage for programmers :)
09:20:43 <Javran> @pl ff x = (+) <$> (ff `g` 0) <*> (ff `g` 1)
09:20:43 <lambdabot> ff = fix (const . ((+) <$>) . liftM2 (<*>) (`g` 0) (`g` 1))
09:20:48 --- mode: ChanServ set +o johnw
09:20:54 <cschneid> ReinH: yeah, I've looked into lots of self publishing things.
09:20:59 <cschneid> is leanpub the one that links w/ dropbox
09:21:11 <merijn> brycelane: Well, you also have the standard dynamicity due to IO results, it depends on how you define "dynamic behaviour", really
09:21:21 <Iceland_jack> byorgey: This may be interesting to you http://stackoverflow.com/questions/13106683/dynamic-dispatch-in-haskell
09:21:26 <savanni> c
09:21:32 <cschneid> yeah, I liked that model. For now I'm writing in gitbook, but really that just means markdown, which is nicely cross-platform
09:21:37 <lambdabot> Hi! I'm lambdabot. I'm here to help.
09:21:49 <merijn> sagittarian: Implement a simple Scheme like thing, or Yet Another Sugar For JavaScript or whatever ;)
09:22:01 <cschneid> > putStrLn "Hi!"
09:22:02 <Iceland_jack> Or sugar for CoffeeScript
09:22:03 <lambdabot>  <IO ()>
09:22:04 <brycelane> merijn: would this be a valid function signature: Eq a=> Int -> a?
09:22:13 <sagittarian> another question, obviously it's well know that programmers coming from imperative languages have some trouble at first wrapping their heads around how to do complex things in haskell
09:22:25 <merijn> brycelane: Yes, although it might be hard to write a function conforming to that type
09:22:44 <sagittarian> is there a point where you really get how haskell works and you realize how to apply all of your imperative experience to haskell?
09:23:03 <brycelane> merijn: that signature maps onto the java concept of an 'interface' quite well.
09:23:03 <CindyLinz> > f :: Eq a => Int -> a ; f n = undefined
09:23:04 <lambdabot>  <hint>:1:23: parse error on input ‘;’
09:23:10 <merijn> sagittarian: I'm torn between saying "6 months" and "never, because it all gets obsoleted quickly" :)
09:23:13 <cschneid> sagittarian: the general (and hard) knowledge of how to break down large problems into smaller ones is certainly applicable.
09:23:15 <ReinH> sagittarian: no, but there's a point where you realize that your imperative experience doesn't really imply.
09:23:22 <ReinH> sagittarian: and then there's a point where you're quite glad about that
09:23:28 <ReinH> *apply
09:23:44 <merijn> brycelane: There's an important difference between typeclass and interface, though
09:23:54 <peteretep> sagittarian: Took me trying to solve a real problem using Haskell
09:24:00 <Iceland_jack> There are _many_ important differences between them
09:24:04 <merijn> brycelane: With an interface the callee (i.e. the function) gets to decide *which* 'a' it returns
09:24:26 <merijn> brycelane: With typeclasses the caller (i.e. me) decides which 'a' has to be returned by the function
09:24:32 <savanni> It took me solving a real problem... and having a few very good programmers code review it.
09:25:08 <brycelane> merijn: That signature suggests the function could return any type which has an implementation of the typeclass.
09:25:23 <merijn> brycelane: No
09:25:39 <merijn> brycelane: It suggest that function can return *every* type which has an implementation of the typeclass
09:25:49 <merijn> And *I* get to pick which
09:25:52 <monochrom> sagittarian: suppose an imperative program has variables x,y. at some point, I realized or learned that "x:=x+y" is the function \(x,y) -> (x+y, y). that is the point I understood that I need only learn functional programming, it supercedes imperative programming.
09:25:55 <geekosaur> which means the caller gets to decide, yes
09:26:29 <sagittarian> monochrom, cool insight there
09:26:30 <hubblebub> hey, using Repa the performance seems really bad compared to numpy, even when just adding two 1D arrays: https://gist.github.com/anonymous/7df5ec1f2bf6d19ee3ff  . Any ideas why?
09:26:33 <sveit> for anyone that uses attoparsec for "complicated" things: what is a good way of parsing, for example a file that has both content and comments in random places (assuming you don't want to ignore the comments)?
09:26:48 <brycelane> merijn: ah. That suggests the typeclass is resolved complete at compile time
09:26:57 <Nephro> Copied this from an example: http://pastebin.com/zkfMbMt1 . Doesn't compile
09:27:13 <corgifex> Nephro: your indentation is wrong
09:27:28 <merijn> brycelane: It doesn't have to be, but they can often be resolved and inlined at compile time, yes
09:27:37 <Nephro> corgifex, I've tried many ways it still doesn't work
09:27:40 <merijn> brycelane: This answer seems to cover the differences in-depth: https://cstheory.stackexchange.com/questions/9731/type-classes-vs-object-interfaces
09:27:44 <corgifex> Nephro: try the right one
09:27:44 * geekosaur guesses the example went through something that's good at mangling indentation
09:27:45 <pmade> sveit: I wrote the playlists package on hackage which parses PLS/M3U files, sometimes keeping comments.
09:28:04 <hubblebub> merijn: that means specializing the function to a concrete type right?
09:28:09 <geekosaur> Nephro, lines 3 and 4 must line up dorectly under the 'putStrLn' on line 2
09:28:12 <merijn> hubblebub: Yes
09:28:17 <brycelane> merijn: thanks a bunch. You've been very helpful.
09:28:17 <geekosaur> not further indented, not outdented
09:28:29 <alpounet> hubblebub: you're only using computeS here, though?
09:28:31 <merijn> brycelane: Consider the following two types "compare :: Ord a => a -> a -> Ordering"
09:28:49 <merijn> brycelane: "int compare(Comparable x, Comparable y);"
09:28:49 <hubblebub> alpounet: yeah, computeP isn't any faster, but I'm just interested in serial performance for now
09:28:52 <sveit> pmade: so how did you deal with mixing presumably different types for comments / data?
09:29:30 <sveit> pmade: in my case, there are several types for each type of line, and I have to wrap them all in a single class which seems "wrong"
09:29:30 <alpounet> hubblebub: well it definitely should be, if using multiple cores.
09:29:33 <merijn> brycelane: With interfaces you only know that 'x' and 'y' are both instances of 'Comparable', but have no idea whether they are the same type of instance (in the presence of subclassing)
09:29:41 <alpounet> hubblebub: let me have a closer look at this.
09:29:49 <merijn> brycelane: In the typeclass version it is obvious that both arguments should be the *exact* same type
09:29:57 <hubblebub> alpounet: thanks!
09:30:34 <hubblebub> alpounet: I'm compiling as follows: ghc -O2 -fllvm -fforce-recomp -XNoMonomorphismRestriction repa.hs
09:30:50 <brycelane> merijn: how does that work in the context of ADTs? Eg, Foo a = Foo a | Bar. It seems Foo a and Bar are both of type Foo, but are also different.
09:31:15 <pmade> sveit: The trick is to have a type like SomeData = Something | Comment then write a comment parser that it fails if the input isn't a comment.  Then you can use other tricks like parseComment <|> parseSomeData
09:31:20 <alpounet> hubblebub: to let the parallelism kick in, you need to add "-threaded -rtsopts", and then do "./program +RTS -N2" for 2 cores, for example
09:31:40 <corgifex> brycelane: is that different from "True and False are both of type Bool, but are also different"?
09:31:46 <hubblebub> alpounet: ahh, all right
09:32:00 <merijn> brycelane: "Bar :: Foo a", that is, Bar is a fully polymorphic constructor
09:32:05 <sveit> pmade: that's what I have. I was hoping I wouldn't have to do it, since my SomeData equivalent ends up wrapping 6 different types
09:32:16 <hubblebub> alpounet: thanks! However, good serial performance is still paramount, I will need to execute code on a lot of data
09:32:34 <pmade> sveit: That's just one way to do it.
09:32:41 <alpounet> hubblebub: yes sure, I was just pointing this out for when you'll use computeP
09:33:02 <merijn> brycelane: So 'Bar' has type 'Foo a' for any type 'a' :)
09:33:03 <sveit> pmade: i'm looking for the other ways :) can you tell me?
09:33:08 <brycelane> merijn, corgifex: that makes sense.
09:33:09 <merijn> :t Nothing
09:33:10 <lambdabot> Maybe a
09:33:14 <merijn> :t Just
09:33:15 <lambdabot> a -> Maybe a
09:33:21 <merijn> :t Nothing :: Maybe Int
09:33:22 <lambdabot> Maybe Int
09:33:34 <merijn> :t Just (1 :: Int)
09:33:35 <lambdabot> Maybe Int
09:33:38 <merijn> :t Just 1
09:33:39 <lambdabot> Num a => Maybe a
09:33:40 <brycelane> merijn: I think I've got an inroad now, thanks again for your help.
09:33:55 <pmade> sveit: I'd have to know more about what you're parsing.
09:34:00 <corgifex> > (Nothing :: Maybe Int) === (Nothing :: Maybe String)
09:34:02 <lambdabot>  Ambiguous occurrence ‘===’
09:34:02 <lambdabot>  It could refer to either ‘L.===’, defined at L.hs:144:3
09:34:02 <lambdabot>                        or ‘Test.QuickCheck.Property.===’,
09:34:02 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
09:34:02 <lambdabot>                           (and originally defined in ‘QuickCheck-2.7.3:Test.Q...
09:34:26 <alpounet> hubblebub: how much slower is it than the numpy version right now?
09:34:45 <merijn> brycelane: Note also that haskell's parametric polymorphism is much more powerful than, for example, Java's generics
09:34:59 <hubblebub> alpounet: numpy is ~0.3s and haskell is 4.6s, so about 15x
09:35:35 <n-dolio> hubblebub: By the way, your two repa imports can be turned into one as "import Data.Array.Repa as R".
09:35:43 <byorgey> Iceland_jack: why do you think that page will be particularly interesting to me (I haven't read it yet)?
09:35:45 <Fernandos> hi
09:35:45 <n-dolio> That will import everything into the default namespace and into R.
09:35:58 <sveit> pmade: it is a file with data lines, command lines, and comment lines. i need to know the relative ordering of the lines
09:35:59 <Fernandos> Why? => "The obvious definition of the Y combinator in Haskell canot be used because it contains an infinite recursive type (a = a -> b)."
09:36:14 <corgifex> Fernandos: what do you mean, why
09:36:18 <Iceland_jack> byorgey: Sorry, that was meant for brycelane
09:36:24 <Maior> Fernandos: at a guess the type inferrererer isn't lazy
09:36:24 <byorgey> ah, ok
09:36:31 <hubblebub> n-dolio: oh cool, thanks!
09:36:33 <Fernandos> corgifex: Why isn't it possible? I thought that info maybe outdated..
09:36:35 <geekosaur> most infinite types are user error, and there are ways to wrap it if you really want it
09:36:42 <sveit> pmade: i have parsers for each kind of line, say D, C, and L, and currently have something like SomeData = DataL | CommandL | CommentL
09:36:45 <corgifex> Fernandos: because it contains an infinite type
09:36:51 <Fernandos> corgifex: I read that Haskell "supports" infinite types
09:36:51 <corgifex> it says so right there
09:36:58 <merijn> Fernandos: You can only have infinite types by introducing a newtype to break the cycle
09:37:02 <Fernandos> Or at least remember so
09:37:02 <corgifex> if you wrap them in 'data', yes
09:37:07 <sveit> pmade: then my whole parser is many $ A <|> C <|> D
09:37:10 <merijn> corgifex: newtype too :)
09:37:23 <corgifex> newtype is data for the purposes of this discussion :-)
09:37:38 <merijn> Fernandos: For example you can do this: "newtype Fix f = Fix (f (Fix f))"
09:37:39 <pmade> sveit: So, is that working but you don't like it, or it doesn't work at all?
09:37:41 <Fernandos> corgifex: newtype? how would you make the y-combinator with new-type?
09:37:58 <merijn> Fernandos: You just can't have "direct" infinite recursion
09:38:08 <Fernandos> merijn: that's much shorter than what's here: http://rosettacode.org/wiki/Category:Haskell
09:38:09 <corgifex> what's the definition of Y again?
09:38:16 <Fernandos> eh sorry
09:38:19 <n-dolio> hubblebub: I think you're still benchmarking list performance.
09:38:32 <Fernandos> here is the correct link http://rosettacode.org/wiki/Y_combinator#Haskell
09:38:49 <n-dolio> fromListUnboxed doesn't look like it does anything to eliminate the intermediate list.
09:38:50 <hubblebub> n-dolio: I think so too, is there a better way to construct these unboxed arrays?
09:38:57 <corgifex> Fernandos: so why are you asking me?
09:39:07 <sveit> pmade: it's all working, but I don't like it
09:39:18 <hubblebub> n-dolio: but at least it shouldn't force the whole thing into memory at once right? But it will still likely box everything...
09:39:21 <bennofs> hubblebub: you're spending 62,2% in GC for that example, that seems to high for me
09:39:21 <sveit> I don't like the wrapper type at the end, so the SomeData part of your suggestsions
09:39:27 <corgifex> Fernandos: it says "Defining a data type (Mu) allows this recursion to be broken." right there, and then gives an example of how to define Y using that method
09:39:27 <n-dolio> hubblebub: You can probably do better by using fromUnboxed and the vector package.
09:39:34 <Fernandos> corgifex: I don't know howto create a y-comb. with "newtype" (newtype is new to me)
09:39:39 <sveit> pmade: of course, I can't think of an alternative, which is why i am asking :)
09:39:54 <Fernandos> and didn't know that infinite types aren't supported
09:40:01 <corgifex> Fernandos: THE CODE IS RIGHT THERE ON THAT PAGE
09:40:11 <byorgey> corgifex: no yelling please.
09:40:18 <hubblebub> bennofs: hah, all right. How did you determine that?
09:40:19 <n-dolio> hubblebub: Or, maybe better would be to do timing of just the additions, not the array creation.
09:40:29 <corgifex> byorgey: why not?
09:40:30 <bennofs> hubblebub: compile with -rtsopts, run with +RTS -sstderr
09:40:33 <halvorg> Anyone familiar with haskell's openGL bindings, I'm getting InvalidOperation on $= calls in GL 3.3, but not in 3.0. Why?
09:40:41 <hubblebub> bennofs: ah, awesome, thanks
09:40:46 <pmade> sveit: That's probably what I'd make it look like.  If the A, D, and C types were really complicated I might break them out but then have another type like ParsedType = ParsedA A | ParsedB B | ...
09:40:46 <byorgey> corgifex: it's not conducive to a welcoming atmosphere.
09:41:08 <gdoteof> how can I in one line concat an `IO String` with a String ?
09:41:08 <corgifex> byorgey: I'm not trying to create a welcoming atmosphere
09:41:15 <hubblebub> n-dolio: yeah, though timely array creation is also important for what I"m doing
09:41:25 <corgifex> gdoteof: fmap (++ s) t
09:41:30 <byorgey> corgifex: well, the rest of us are. sorry if you don't like it.
09:41:37 <gdoteof> corgifex: ah.  i had the ++ on the t
09:41:44 <gdoteof> ty
09:41:47 <n-dolio> hubblebub: I'd look into the vector package, then.
09:41:53 <quchen> Not being welcome is OT here. /dev/null is the place for that.
09:41:55 <corgifex> byorgey: I'm not getting the impression Fernandos is either
09:41:57 <sveit> pmade: yep, but my issue is that i end up with boilerplate code that extracts the interesting values from the ParsedType class
09:42:11 <hubblebub> n-dolio: thanks, I'll give it a try
09:42:13 <byorgey> corgifex: that's irrelevant.
09:42:16 <sveit> pmade: some people earlier suggested I get rid of the wrapper altogether, but I have no idea how to do this
09:42:19 <n-dolio> hubblebub: I think there's an enumFromTo that's likely to be much faster than going through a list. And then you can use fromUnboxed to turn it into a repa array.
09:42:25 <brycelane> Iceland_jack: Thanks for the link. It looks promising.
09:42:52 <corgifex> byorgey: not to me
09:43:26 <pmade> sveit: I can't see beyond the wrapper though, because you'll need it so you can store the parsed records into some data structure that preserves ordering.
09:43:54 <pmade> sveit: Are the lines completely independent other than ordering, or do they relate to one another in some way?
09:43:55 <sveit> pmade: for example, i have to have trivial but related functions lying around like isCommentLine (ParsedC _) = True; isCommentLine _ = False; commentLine (ParsedC c) = c; ...
09:44:25 <sveit> it would be nice if I could have a generic "unwrapper", for example, but this is impossible with Haskell's type system
09:44:48 <quchen> sveit: There's the 'newtype' package which does something like that.
09:45:05 <sveit> pmade: well i need the ordering because certain commad lines coming before certain data lines means something for the data lines
09:45:16 <sveit> so i guess they do relate to one another
09:45:31 <alpounet> hubblebub: i commented on your gist with some modifications, i get a x9 speedup, approximately
09:45:32 <pmade> sveit: Then maybe you should make the types reflect that.
09:46:30 <pmade> sveit: I suggest you build the correct types while parsing if you can, instead of processing the list afterwards.
09:47:21 <monochrom> brycelane: your questions inspired me to discover that most programmers have not distinguished between "undetermined at write time" and "undetermined at compile time". it is an important and overlooked distinction.
09:47:29 <sveit> pmade: that is a good idea, and i think it might make things a bit better, but these relationships are "flexible", so this is a little bit tricky
09:47:39 <hubblebub> alpounet: wow, great, thanks! Let me give it a try
09:48:02 <n-dolio> alpounet, hubblebub: Using generate might be even better.
09:48:11 <n-dolio> Not entirely sure.
09:48:12 <glguy_> cramming y-combinator into Haskell... http://lpaste.net/104092
09:48:28 <pmade> sveit: It does make the parser more complicated but then you probably don't have to expose comments or commands anymore.
09:48:33 <hubblebub> alpounet: yeah this is the performance I was looking for, thanks!
09:48:42 <uotbw> how do you model references to sub structures in a larger data structure? (One answer was STref)
09:48:47 <brycelane> monochrom: not sure if that is a complement, but glad I could help
09:48:50 <alpounet> n-dolio: yeah, I just went for the easy path, and that's enough to wipe out some intermediate values.
09:49:03 <ReinH> uotbw: lens?
09:49:12 <monochrom> it is not a negative statement, don't you worry :)
09:49:16 <n-dolio> x = fromUnboxed (generate fromIntegral n) ; y = fromUnboxed (generate (fromIntegral . (+1)) n)
09:49:26 <awestroke> uotbw: lenses and ziplists
09:49:32 <awestroke> zippers*
09:49:35 <awestroke> not ziplists
09:49:41 <monochrom> here is an example. you are to write yet another sorting algorithm, and it has to be "general".
09:49:41 <uotbw> how does a lens help with that?
09:49:50 <monochrom> ok, "general" for what?
09:50:02 <n-dolio> Er, generate n fromIntegral
09:50:31 <awestroke> uotbw: if you want a concrete answer, ask a concrete question. did you have a specific data structure in mind?
09:50:52 <uotbw> ok
09:51:10 <sveit> pmade: thanks, i'll try to figure some of this out.
09:51:37 <monochrom> suppose you say, "the comparator will depend on user input". then that is truly undetermined both at write time and at compile time, and one is right to code up really dynamic runtime behaviour for that. hell, it depends on user input, how can it not be runtime dynamic.
09:51:41 <merijn> brycelane: Btw, with regards to your remark about typeclasses being resolved at compile time. (Warning, the following only holds in GHC and it's not the only way to do things). GHC implements typeclasses as a record of functions that are passed in as extra argument to a function, for example it treats "Eq a => a -> a -> Bool" as "Eq a -> a -> a -> Bool" where "Eq a" is a record containing the different functions from Eq for 'a'. Thi
09:51:58 <hubblebub> alpounet: and I think it properly deforests it, yaay :)
09:52:22 <alpounet> hubblebub: you should try what n-dolio mentionned, that may be faster
09:52:26 <merijn> brycelane: But, if it can determine at compile which type 'a' will be, GHC can actually inline the dictionary and lookup, effectively specialising it to avoid the runtime lookup at compile time
09:52:58 <merijn> brycelane: (There have been other haskell compilers have implemented typeclasses differently, though, so it's just one possibility)
09:53:46 <monochrom> but suppose you say, "I don't know which comparator it is, but if the type is Int then the comparator must be <, if the type is String then the comparator must be blahblah, I just don't know which type it is yet", then it is only undetermined at write time. at compile time the compiler already knows it's String. there is no runtime dynamic behaviour.
09:54:03 <brycelane> merijn: thats interesting to know. Besides as a practical consideration for compiling/linking etc, a typeclass should always be technically resolved before runtime, right?
09:54:12 <uotbw> think of a description of a 3d scene with a node tree representing the spatial structure and data for meshes lines ... Now: meshes are referring to materials which are themselves sub tree like data structures:-)
09:54:57 <uotbw> but many meshes might refer to one material
09:55:00 <corgifex> oh boy, is it polymorphic recursion time?
09:55:19 <merijn> brycelane: Well, consider a polymorphic function that may be applied to either an Int or a Char, depending on user input
09:55:55 <corgifex> merijn: how would you do that? different call sites?
09:55:55 <merijn> brycelane: Clearly you can decide at compile time which code each case needs, but which case actually gets run depends on runtime information, so the generated code will have to be capable of dealing with both possible paths
09:56:41 <merijn> corgifex: "f :: Ord a => a -> Foo" "b :: Either String Int" and "case b of Left x -> f x; Right y -> f y"?
09:56:59 <corgifex> I'll take that as a yes :-)
09:57:06 <merijn> Clearly 'f' needs to be able to deal with both String and Int codepaths
09:57:13 <merijn> Even after compilation
09:57:29 <corgifex> I don't see how that follows
09:57:32 <merijn> (Well, conceivably GHC could decide to inline 'f' into the case statement, but still)
09:57:33 <brycelane> merijn: I understand its by far the most reasonable implementation, but it should be technically possible to inline every typeclass in the limit that all source is available.
09:57:39 <corgifex> you could just have 2 f's
09:57:58 <merijn> corgifex: That's conceptually the same as having an 'f' that's polymorphic
09:58:08 <merijn> corgifex: You still need to decide at runtime "which" 'f' to use
09:58:18 <merijn> Based on which typeclass instance you need
09:58:31 <corgifex> that sounds wrong to me
09:58:41 <merijn> corgifex: Better fix your hearing then ;)
09:59:17 <uotbw> Instead of building a OOP like model I would like to start with a functional pure data model
09:59:26 <corgifex> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 3 'x'
09:59:27 <lambdabot>  "((('x','x'),('x','x')),(('x','x'),('x','x')))"
09:59:40 <awestroke> uotbw: and what do you want to  do with the 3d scene? update all meshes? update a specific material?
09:59:43 <uotbw> my own approach would be ids
09:59:54 <brycelane> I'm kind of stuck here with corgifex. It seems that all the information to decide should be available at compile time.
10:00:11 <uotbw> no this is just the scene description
10:00:14 <corgifex> brycelane: see ^
10:00:14 <merijn> brycelane: In examples that fit into 1 or 2 line IRC conversations, sure :)
10:00:18 <geekosaur> brycelane, it's not always
10:00:26 <uotbw> lenses can do the updating
10:00:44 <merijn> corgifex' example is better
10:00:47 <brycelane> merijn: I clearly didn't say it was practical :)
10:00:48 --- mode: ChanServ set -o johnw
10:00:48 <uotbw> but how to handle the refs
10:01:44 <merijn> brycelane: But yes, *most* cases you can inline (and this is desirable, because that means no overhead!)
10:02:10 <uotbw> the overall idea is like a browser works with the3d scene description being the html page
10:02:13 <merijn> The result is that typeclasses are often much cheaper than dynamic dispatch in OO would be
10:02:53 <uotbw> and functions like display working on it
10:03:03 <monochrom> I am not fond of turning a type system discussion into a code optimization discussion. why is code optimization your biggest worry? I mean, 2nd biggest, sure.
10:03:49 <geekosaur> because those are highly valuable nanoseconds
10:03:50 <awestroke> uotbw: what kind of refs? do you imagine a Data.Map Int Material ?
10:03:56 <geekosaur> never mind you wasted hours on shaving them off
10:04:07 <monochrom> the 1st biggest worry is how many incubating warm beds for bugs you add. every time you use a runtime-dynamic mechanism for what doesn't need it, you add one more incubator for bugs.
10:04:13 <brycelane> corgifex, merijn: that is an interesting example.
10:04:52 <corgifex> and that's why polymorphic recursion is so yummy
10:05:11 <uotbw> that map string material type is my current workaround
10:05:17 <merijn> geekosaur: Well, it helps to have some form of cost intuition about how costly a given operation X is
10:05:40 <brycelane> corgifex, merijn: In the limit that you don't worry about stacks, infinate loops etc, that could be inlined couldn't it?
10:05:54 <merijn> brycelane: Haskell doesn't have a function call stack
10:05:56 <corgifex> brycelane: how?
10:06:02 <corgifex> 3 can be user input
10:06:05 <uotbw> just wanted to know if this is the general approach
10:06:10 <merijn> brycelane: Actually, rephrase, GHC haskell doesn't have a call stack
10:06:33 <brycelane> corgifex, merijn: I suppose I should have said memory requirements :)
10:06:37 <merijn> The standard leaves the implementation of haskell undefined, so I guess you could implement it with a call stack
10:06:49 <monochrom> GHC stack is used for a different purpose. GHC stack is also growable, the default limit is artificial.
10:07:09 <geekosaur> you could, but I think it likely most implementations would do what ghc does: immediately return a closure
10:07:10 <corgifex> brycelane: infinitely long programs don't count
10:07:11 <brycelane> corgifex, merijn: You're right. It couldn't be arbitrary.
10:07:34 <monochrom> it is right to ask "how much stack+heap is consumed". it is wrong to ask "how much stack is consumed" while ignoring heap.
10:07:40 <merijn> monochrom: I know, I was just pointing out that "infinite loop" does not necessarily imply "infinite stack consumption" :)
10:07:46 <brycelane> sorry, inlined.
10:07:50 <geekosaur> non-strict evaluation doesn't care so much about function calls, since nothing actually happens at call time
10:08:14 <merijn> geekosaur: Well, trigerring update frames :)
10:08:24 <merijn> (potentially)
10:09:43 <monochrom> if your program uses N bytes of stack, a lot of people are eager to tell you how to rewrite it to use 0 bytes of stack and 3N bytes of heap, and they seem to be proud of their accomplishment.
10:10:02 <ReinH> heh
10:10:16 <brycelane> funny, I'd be proud to go the other way.
10:10:38 <monochrom> you know why they think it's Achievement Unlocked?
10:11:03 <quchen> Heaps can be bigger than stacks before they tip over?
10:11:05 <n-dolio> Heap overflow is off by default, so it's better to use heap. :)
10:11:06 <monochrom> it's because N bytes of stack causes a "stack overflow" error message but 3N bytes of heap does not cause a "heap overflow" error message.
10:12:04 <monochrom> I hope you see how it's completely artificial, arbitrary, bent, distorted, and immoral.
10:12:19 <brycelane> that depends entirely on your runtime. Go doesn't have stack overflows.
10:12:28 <quchen> monochrom: aka a hack.
10:12:33 <n-dolio> Actually, maybe using heap is bad. Because it can cause swap thrashing due to the lack of a heap check.
10:12:40 <n-dolio> Very easy to do that.
10:13:00 <monochrom> heap is also more expensive to clean up than stack, when you're done.
10:13:03 <quchen> (What are GHC's standard stack/heap sizes anyway?)
10:13:06 <ReinH> monochrom: that's bad and they should feel bad
10:13:32 <n-dolio> monochrom: You haven't read Garbage Collection can be Faster Than Stack Allocation, I guess? :)
10:13:47 <monochrom> GHC default stack 8M cap, heap no cap. I lobbied against it, I think SPJ finally listened, but not sure when it will go into GHC
10:14:07 <monochrom> I haven't
10:14:27 <monochrom> but I'm comparing garbage collection with stack deallocation anyway.
10:14:50 <n-dolio> That's the comparison in the paper, I think.
10:15:31 <harlanhaskins> How would I check the type of input in a pattern guard?
10:15:42 <geekosaur> ?
10:15:56 <harlanhaskins> My only condition for a function is that the input is showable.
10:16:02 <geekosaur> if you don't already know the type then you're probably not writing in haskell
10:16:03 <harlanhaskins> Show a => a -> String
10:16:03 <n-dolio> monochrom: Did you lobby for the stack cap to be removed, or for a default heap cap?
10:16:13 <geekosaur> then you cannot know the type
10:16:30 <monochrom> I lobbied for "liberate both or cap both"
10:16:38 <geekosaur> I suggest you think about this; you're using an invalid model for how types work
10:16:40 <n-dolio> Oh. Which won?
10:16:40 <koala_man> harlanhaskins: if the type of your function is Show a => a -> String then a will always be showable or it'll fail to compile
10:16:51 <monochrom> and I think SPJ simplified it to "liberate stack"
10:16:57 <n-dolio> Cool.
10:17:06 <harlanhaskins> koala_man: Right, but can I have a guard for a particular Showable, i.e. Integer?
10:17:12 <geekosaur> nope
10:17:25 <harlanhaskins> Hmm...
10:17:33 <geekosaur> [13 17:14] <geekosaur> I suggest you think about this; you're using an invalid model for how types work
10:17:45 <corgifex> "it looks like you're trying to break parametricity. do you need help with that?"
10:17:55 <koala_man> harlanhaskins: no, that's unsafePerformIO level bad
10:18:06 <geekosaur> the model you're using generally works in OO languages, does not work in Haskell
10:18:23 <harlanhaskins> I understand. I realized I was probably thinking about this the wrong way.
10:19:11 <Maior> harlanhaskins: high level, what are you trying to do?
10:19:29 <merijn> Hmmm, is "Either a a" a rather ugly type for signalling special conditions or is it fine?
10:19:43 <merijn> Would "(a, Bool)" be better?
10:19:50 <c_wraith> generally, yes
10:19:51 <Iceland_jack> merijn: What kind of special condition?
10:19:54 <n-dolio> Depends what you want to do.
10:19:58 <Iceland_jack> I would probably create a new data type
10:20:04 <c_wraith> Though (a, SemanticallyMeaningfulType) is even better
10:20:04 <harlanhaskins> Maior: I'm run-length encoding, and providing a method of 'expressing', in English, the numbers.
10:20:28 <harlanhaskins> so I have 'expressSingle :: Show a => a -> String`
10:21:04 <harlanhaskins> And then if it's an integer, I want to grab from a function that converts numbers to human-readable strings.
10:21:05 <merijn> c_wraith: SemanticallyMeaningfulType is a bit inconvenient here, I'm basically just signalling whether I have partially parsed a multiline haskell string or finished parsing the entire literal
10:21:21 <harlanhaskins> Integer -> String
10:21:39 <Maior> harlanhaskins: I would suggest you want a function :: String -> (String, (Char, Int)) or similar
10:21:42 <harlanhaskins> But I'm thinking about this the wrong way, and I realized that my method of doing that won't scale to bugger numbers.
10:21:53 <harlanhaskins> s/bugger/bigger/
10:22:28 <Maior> smooth ;)
10:22:57 <michi7x7> glguy_: what can use use the Y-combinator for? I read the wikipedia article about combinators, but they don't cover any use-cases
10:23:00 <savanni> harlanhaskins: you could create a SpecialShow typeclass, similar to show, implemented for the types that you want to express.
10:23:22 <corgifex> michi7x7: Y encapsulates recursion
10:23:46 <sveit> we can treat a function as a functor: f :: a -> b -> c, so that if i want to construct a new function where i am apply g to the first argument, i can write fmap g f = g <$> f, so that (g <$> f) a b = f (g a) b
10:24:03 <sveit> what if i wanted to apply a function to b? i assume i have to use "flip", correct?
10:24:17 <sveit> so flip (g <$> flip f)
10:24:24 <sveit> si there a shorter way?
10:24:43 <sveit> furthermore, what if i want to apply a function to both a and b?
10:24:44 <merijn> sveit: I would just write a lambda, that code is really confusing
10:24:59 <sveit> sure, but there is no existing abstraction?
10:25:13 <skypers> huhu :(
10:25:13 <skypers> /tmp/pandoc-1.6.0.1-27791/pandoc-1.6.0.1/dist/dist-sandbox-aea0c1cb/setup/setup.hs:95:18: Not in scope: `catch'
10:25:17 <skypers> Failed to install pandoc-1.6.0.1
10:25:20 <skypers> how is it even possible?
10:26:09 <agreif> hi, I am quite new to haskell and have got a question: why do I need the parenthesis in "foo (x:xs) = ..." instead of "foo x:xs = ..." ?
10:26:11 <bergmark> skypers: catch was removed from Prelude in GHC 7.6
10:26:26 <quchen> agreif: foo x:xs = (foo x) : xs
10:26:35 <savanni> skypers: also, pandoc-1.6 is a *really* old version.
10:26:50 <geekosaur> agreif, in theory we could use completely different precedence in patterns than in expressions, which would be "easier" in some sense and nightmarish in others (yay more special cases)
10:26:56 <alpounet> skypers: 1.6 is quite old, you should install a more recent one (current version is: 1.12.4)
10:27:05 <skypers> 19:24 < savanni> skypers: also, pandoc-1.6 is a *really* old version.
10:27:06 <skypers> yeah
10:27:09 <skypers> I don’t get why
10:27:16 <skypers> my cabal is up to date
10:27:19 <skypers> same for GHC
10:27:24 <skypers> I run a cabal install pandoc in a sandbox
10:27:29 <Maior> agreif: general programming concept: precedence is sometimes hard, and while All Right Thinking People agree that "1 + 2 * 3" is "1 + (2 * 3)", most other instances of operator precedence are surpriisng at first
10:27:30 <savanni> what does cabal list pandoc say?
10:27:31 <skypers> I created a few minutes ago
10:27:39 <skypers> savanni: in the sandbox?
10:27:41 <geekosaur> cabal itself is, but is your cabal database up to date? (cabal update)
10:27:43 <bennofs> skypers: probably because of transformers/mtl update
10:27:49 <savanni> skypers: yeah
10:27:54 <skypers>     Default available version: 1.12.3.3
10:28:01 <agreif> quchen: ah ok, I forgoat a space is the delimiter between function and argument. thanks
10:28:02 <skypers> hm
10:28:09 <bennofs> skypers: try cabal install pandoc --constraint "pandoc >= 1.12"
10:28:16 <bennofs> skypers: that will tell you where it fails
10:28:19 <sveit> merijn: looks like it exists! might be a bifunctor
10:28:49 <skypers> bennofs: it’s building
10:28:51 <skypers> :–––’
10:28:57 <bennofs> skypers: :O
10:29:06 <skypers> I really don’t get it
10:29:07 <savanni> skypers: do you have a project.cabal file?  If so, check the version of Pandoc that the project requires.
10:29:14 <skypers> savanni: yes
10:29:18 <skypers> I always use *
10:29:21 <skypers> in the pandoc case
10:29:27 <skypers> it’s pandoc == 1.12.*
10:29:29 <savanni> Hm.  No idea, then.
10:29:46 <skypers> I’m gonna try to install it in the global world
10:30:01 <bitemyapp> that's not a great idea.
10:30:13 <quchen> sveit: (->) isn't a Bifunctor, but a Profunctor. (Both are bifunctors, but Haskell distinguishes them.) Anyway, use a lambda.
10:30:16 <skypers> bitemyapp: why?
10:30:32 <skypers> I don’t really use the global world
10:30:37 <skypers> I actually don’t.
10:30:43 <skypers> and I don’t have pandoc installed
10:32:10 <savanni> skypers: weird dependency conflict gotchas can show up.  And pandoc has a ton of dependencies, all of which will be installed.
10:32:49 <skypers> ok
10:32:58 <skypers> might not be want I want, indeed :D
10:33:03 <skypers> what*
10:33:37 <bergmark> there are some cabal bugs where it picks old versions
10:33:48 <bergmark> for instance https://github.com/haskell/cabal/issues/1864
10:34:42 <skypers> :(
10:36:05 <halvorg> Any way of doing Double -> Float without getting garbage? I dont mind losing precision
10:36:23 <skypers> realToFrac, maybe?
10:36:47 <skypers> > realToFrac (3 :: Double) :: Float
10:36:49 <lambdabot>  3.0
10:36:55 <halvorg> Yeah that's perfect thanks
10:37:03 <skypers> :)
10:37:06 <halvorg> I tried unsafeCoerce, was not very useful :D
10:37:20 <skypers> “it was unsafe, indeed.”
10:37:21 <skypers> :D
10:38:13 <thoughtpolice> unsafeCoerce is pretty much never useful nor needed in 99% of all cases, in my experience.
10:38:33 <skypers> I don’t even know its usecase
10:38:38 <skypers> it’s something like a -> b, right?
10:38:55 <skypers> :t unsafeCoerce
10:38:56 <lambdabot> Not in scope: ‘unsafeCoerce’
10:39:21 <savanni> I bet it's a direct bitwise coercion, like what you'd get in C.
10:39:21 <fryguybob> @quote isJust
10:39:21 <lambdabot> ddarius says: isJust . unsafeCoerce
10:39:38 <merijn> savanni: Pretty much
10:39:39 <n-dolio> The use case is casting something to a type you know it has, but can't prove to GHC in other ways that it actually has it.
10:39:43 <thoughtpolice> that is the type, yes. it is useful in some *very* specific cases where you know the exact underlying representation is the same as what you are coercing to. this can arise, for example, when you cannot convince the type-checker two types are actually equal. in some other cases people use it for performance.
10:39:45 <merijn> savanni: With about the same safety :)
10:39:52 <n-dolio> It is not for bitwise conversions.
10:39:56 <geekosaur> unsafeCoerce doesn't even look at the value, it just lies about the type
10:40:03 <jfischoff> it is used to implement cast with Typeable
10:40:04 <quchen> @quote monochrom isTrue
10:40:04 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
10:40:14 <savanni> merijn: C typecasting is safe?
10:40:23 <merijn> savanni: No, that was my point :)
10:40:30 <savanni> heh
10:40:32 <merijn> savanni: Well, maybe
10:40:43 <merijn> savanni: Basically, it's about as safe as "(int*) 5" would be
10:41:12 <merijn> savanni: You better be damn sure that whatever you're casting to an int* is an actual valid int*
10:41:29 <thoughtpolice> i think the last time I legitimately used unsafeCoerce was when I was using the GHCi and needed to pull an actual typed term out of an HValue, which is basically GHC's internal datatype representing an arbitrary haskell value.
10:41:41 <thoughtpolice> and that was a very, very long time ago. these days I'd probably just use hint
10:41:57 <thoughtpolice> s/GHCi/GHC API/
10:42:27 <absence> if i have an "m (a, m b)", can i somehow warp the join function into giving me "m (a, b)"?
10:42:30 <merijn> halvorg: unsafeCoerce's name is rather more unsafe than it's name implies, indeed ;)
10:43:03 <merijn> absence: Go two-step "(a, m b) -> m (a, b)" and then join
10:43:22 <merijn> :t \(a, b) -> fmap (a,) b
10:43:22 <lambdabot> Functor f => (t, f a) -> f (t, a)
10:43:30 <quchen> :t \mamb -> mamb >>= \(a, mb) -> mb >>= \b -> return (a,b) -- nom nom nom
10:43:31 <lambdabot> Monad m => m (t, m t1) -> m (t, t1)
10:43:40 <merijn> :t join . fmap (\(a, b) -> fmap (a,) b)
10:43:41 <lambdabot> (Functor m, Monad m) => m (t, m a) -> m (t, a)
10:44:18 <absence> ok so there's no pretty and readable way to do it :D
10:45:12 <quchen> :t \mamb -> do { (a, mb) <- mamb; b <- mb; return (a,b) } -- Reindent and it's pretty and readable.
10:45:13 <lambdabot> Monad m => m (t, m t1) -> m (t, t1)
10:45:35 <n-dolio> (>>= T.sequence) [(1, [2])]
10:45:39 <n-dolio> > (>>= T.sequence) [(1, [2])]
10:45:41 <lambdabot>  [(1,2)]
10:46:23 <absence> :t uncurry (fmap . (,)) -- courtesy of lambdabot :p
10:46:24 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
10:46:24 <alpounet> there's http://comonad.com/reader/2008/deriving-strength-from-laziness/ ... strength :: Functor f => f a -> b -> f (a,b)
10:46:50 <absence> quchen: yeah, do notation is quite readable, just checking if there was something more compact :)
10:47:06 <n-dolio> Mine is most compact. :)
10:47:56 <c_wraith> uncurry is always weird
10:49:05 <supki> > (>>= _2 id) $ [(1, [2])]
10:49:07 <lambdabot>  [(1,2)]
10:49:46 <bennofs> > (traverse._2) id [(1, [2])]
10:49:48 <lambdabot>  [[(1,2)]]
10:50:25 <halvorg> :t unless
10:50:25 <n-dolio> Oh yeah. _2. Damn.
10:50:26 <lambdabot> Monad m => Bool -> m () -> m ()
10:51:02 * hackagebot haskell-course-preludes 0.0.0.0 - Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.  http://hackage.haskell.org/package/haskell-course-preludes-0.0.0.0 (gibiansky)
10:54:02 <jnj> Anyone familiar with Data.Tree.Zipper? Given a TreePos Empty a, how do I insert /multiple/ nodes at that position? insert :: Tree a -> TreePos Empty a -> TreePos Full a inserts one child (a single tree), and returns a Full position.
10:55:23 <shachaf> I'm not familiar with that module, but I'm not sure what it means to insert multiple nodes at a position.
10:55:41 <jnj> Basically adding several children at once
10:56:23 <jnj> I suspect what I need is insert :: Forest a -> TreePos Empty a -> TreePos Full a, but am not sure what the best way to create that function is
10:57:00 <jophish> Is there a page which lists a standard Haskell Prelude?
10:58:20 <geekosaur> it's part of the report
10:58:21 <shachaf> The perils of saying just a module name instead of a package name.
10:58:31 <shachaf> http://hackage.haskell.org/package/rosezipper-0.1/docs/Data-Tree-Zipper.html is probably not what you're talking about.
10:58:44 <klrr_> does optional from Control.Applicative work as "run this IO if there is exception return nothing else Just a"?
10:58:51 <klrr_> or is there any other that work like that?
10:59:09 <jnj> shachaf, Well, it is that one but 0.2 - http://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html
10:59:09 <geekosaur> jophish: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009
10:59:19 <shachaf> Oh, just a new version.
11:01:07 <shachaf> jnj: If you want to insert multiple children, insert a tree with multiple children?
11:01:25 <shachaf> Or insert multiple siblings or something.
11:02:31 <jophish> super, thanks all
11:02:32 <jnj> shachaf, well, a tree has a single root, i want to add several nodes at the same "level". Anyways, I think I can use nextSpace to get what I want, seems to work in ghci. Thanks
11:03:15 <shachaf> Ah, that's what you're asking.
11:04:00 <carter> @tell juhp yay
11:04:00 <lambdabot> Consider it noted.
11:09:18 <skypers> god, pandoc takes so long to compile :D
11:13:15 <savanni> skypers: yes, it does, but this seems significantly longer than I have experienced.
11:19:55 <eacameron> I'm having trouble finding a consunsus on the best overall hashmap library. I was using IntMap, but appaently that is dated?
11:20:43 <carter> nope
11:20:47 <carter> eacameron: that aint a hashmap
11:20:56 <carter> thats an ordered KV map specialized to using Int keys :)
11:21:19 <eacameron> eacameron: I know...but "HashMap" apparently was simply a wrapper around it
11:21:37 <eacameron> and then comes unordered-containers
11:22:01 <carter> well
11:22:03 <carter> whats your workload?
11:22:15 <carter> what sorts of values?
11:22:26 <carter> lets zoom out and go bigpicture
11:22:32 <carter> @hackage hashtables
11:22:33 <lambdabot> http://hackage.haskell.org/package/hashtables
11:22:34 <carter> and
11:22:37 <eacameron> just toying currently. I suspect I may need to eat IO and go hashtables eventually, but for now I live in pureland
11:22:39 <eacameron> mostly lookups
11:22:40 <carter> @hackage unordered-containers
11:22:40 <lambdabot> http://hackage.haskell.org/package/unordered-containers
11:22:49 <carter> eacameron: you can use hashtables in ST
11:22:50 <carter> :)
11:23:27 <eacameron> carter: oh that would definitely be preferabel
11:23:40 <eacameron> still, for now I'm ok with the slowness of the alternatives
11:23:44 <carter> ok
11:23:46 <carter> well
11:23:51 <eacameron> I just want to use the one that people like
11:23:54 <eacameron> not some old thing
11:23:55 <carter> one thing you can do is try using a better hash function
11:24:05 <carter> unordered-containers is actively used and devd
11:24:12 <carter> also very different from hashtables
11:24:46 <carter> if you'reusing it in a setup once, then hammer, arrangement, hashtables will work better by default I think (or if now, thats a bug)
11:27:56 <skypers> 20:10 < savanni> skypers: yes, it does, but this seems significantly longer than I have  experienced.
11:27:59 <skypers> seems?
11:33:26 <savanni> skypers: I've only ever known it to take ten-ish minutes.
11:33:53 <eikke__> haskell/hackage is featured (unwillingly, I guess) on mtv.com :-P http://www.mtv.com/artists/hackage/biography/
11:34:25 <eacameron> carter, what do you mean by "hammer, arrangment..."?
11:34:43 <carter> *hammer === lots of loookups
11:34:53 <carter> "build me, read me, read me readme"
11:35:30 <c_wraith> eikke__: that's the old hackage page, too
11:35:35 <savanni> eikke__: Why in the world would that be on MTV's website?
11:35:43 <ThatOtherPerson> O_o
11:35:46 <eikke__> I have no clue
11:35:59 <carter> i bet they auto scraped wikipedia for artists profiles
11:36:09 <carter> and their "is it an artist" code is really dumb
11:46:09 * hackagebot azure-servicebus 0.1.1.0 - Haskell wrapper over Microsoft Azure ServiceBus REST API  http://hackage.haskell.org/package/azure-servicebus-0.1.1.0 (kapilash)
11:47:17 <absence> is there a way to query types of functions inside where and let using ghci?
11:47:27 <shergill> what's the term for a monoid with a zero element?
11:47:48 <joelteon> a monoid
11:47:48 <vanila> shergill, that is a monoid
11:48:19 <shergill> by 'zero' i mean the 'absorbing element' not the identity
11:48:55 <c_wraith> I don't know that there is a term for a monoid with an element that's left- and right- absorbing
11:49:00 <bennofs> shergill: you mean such that zero <> a = zero and a <> zero = zero ?
11:49:08 <shergill> yes
11:53:04 <jdiez> ok, here's something I don't understand about monads
11:53:07 <jdiez> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
11:53:13 <jdiez> >    asks socket >>= listen
11:53:14 <lambdabot>  Not in scope: ‘socket’
11:53:25 <jdiez> I understand that `asks` is a function that returns an action in the Reader monad
11:53:47 <c_wraith> :t listen
11:53:48 <lambdabot> MonadWriter w m => m a -> m (a, w)
11:53:50 <jdiez> however it's not being given any parameters... so how does it know where to apply it to?
11:53:52 <agreif> I have a question: is there a function that produces the same result as "(:) :: a -> [a] -> [a]" but with the reverse order of arguments, someting like "add' :: [a] -> a -> [a]" ? Sure I can write one, but I am just curious
11:54:02 <jdiez> :t ask
11:54:03 <lambdabot> MonadReader r m => m r
11:54:08 <jdiez> yeah
11:54:18 <jdiez> but I'm not giving it the actual monad, am I?
11:54:18 <c_wraith> actually, it's *asks*
11:54:22 <c_wraith> that final s is important
11:54:28 <jdiez> :t asks
11:54:29 <lambdabot> MonadReader r m => (r -> a) -> m a
11:54:48 <monochrom> agreif: is "flip (:)" enough? flip (:) [3,4] 1 = [1,3,4]
11:54:53 <jdiez> k, so it takes a function and returns an action in the Reader monad
11:54:56 <jdiez> hmm
11:55:00 <jdiez> that kinda makes sense
11:55:07 <c_wraith> jdiez: anyway, you're right..  There is an implicit argument going on.  That's *exactly* what the reader monad is.
11:55:47 <jdiez> c_wraith: but that's because the function I give to ask is given the monad, right?
11:55:56 <jdiez> asks*
11:56:10 <jdiez> so the `socket` function will get the monad as an argument and return a value
11:56:17 <jdiez> and asks turns that value into a monadic value
11:56:18 <jdiez> right?
11:56:47 <jdiez> and the socket accessor is generated by the record syntax
11:56:49 <c_wraith> jdiez: Well.  Not "the monad".  monads aren't even values..  Things that are monads are types.  But it gets the value supplied to it implicitly by asks, yes
11:56:49 <jdiez> that makes sense
11:57:06 <agreif> monochrom: thanks, flip flips the first two args, but that exactly what I need. Thnaks!!
11:57:30 <fragamus> hello dudes
11:57:49 <srhb> Dudettes, too!
11:57:57 <jdiez> c_wraith: so the function I give to asks will get the... monad thing? as an argument?
11:57:59 <jdiez> :t asks
11:58:00 <lambdabot> MonadReader r m => (r -> a) -> m a
11:58:07 <fragamus> they are included in dudes
11:58:26 <c_wraith> jdiez: it'll get the value of type r that is implicitly passed around by m's Monad instance as an argument
11:58:30 <jdiez> the reader monad is making me dizzy
11:58:32 <fragamus> dudes = the set of all badass functional programmers
11:59:14 <fragamus> I am doing some badass computational geometry in haskell
11:59:23 <jdiez> c_wraith: okay. and it gets passed that argument because of runReaderT, right?
11:59:39 <c_wraith> jdiez: yes, runReaderT is what actually supplies that argument
11:59:46 <shachaf> fragamus: It seems that they don't feel like they're included, so maybe just saying it isn't sufficient.
11:59:52 <jdiez> ok, this is kind of starting to make sense
11:59:58 <jdiez> slowly
12:00:04 <fragamus> ok
12:00:19 <fragamus> especially the dudettes
12:00:57 <srhb> fragamus: What's the badass geometry about?
12:01:08 <jdiez> c_wraith: right, so how can the read function be of type "run :: Net ()" ?
12:01:10 <booted> hello
12:01:11 <jdiez> it's not given any arguments
12:01:14 <fragamus> it has to do with voronoi tesellation
12:01:18 <jdiez> ah, it doesn't need them
12:01:34 <jdiez> because it just passes them to the last action returned by `run`
12:01:36 <jdiez> is that right?
12:01:48 <booted> question: Is there a method in GHC to get a call stack of a given / random / all threads, instead of the current callstack?
12:01:59 <srhb> jdiez: If it hasn't been suggested yet, you should just try implementing the Reader Monad instance. :)
12:02:03 <booted> I just wonder how one would implement an attach-on-the-fly profiler
12:02:06 <srhb> jdiez: Suddenly it all makes sense.
12:02:09 <c_wraith> jdiez: not sure.  I need more context to answer that.  Where's Net defined?
12:02:24 <jdiez> c_wraith: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:02:30 <jdiez> c_wraith: ctrl-f "asks socket >>="
12:02:50 <c_wraith> jdiez: ah, ok.
12:03:44 <c_wraith> jdiez: Net is (an alias for) a newtype that isn't a function.
12:03:53 <c_wraith> jdiez: instead, it's a wrapper around a function.
12:04:09 <c_wraith> jdiez: so in some sense, run *is* a function, though it's inside a wrapper.
12:04:57 <c_wraith> jdiez: But that's not all that important.  Mostly it's just a value that explains how to perform an action given the tools provided by the Net type
12:05:09 <jdiez> c_wraith: right, so the last action returned b y that `run` is the one that gets the argument, right?
12:05:20 <dmwit> booted: As far as I know there isn't a cal stack.
12:05:48 <geekosaur> there isn't a useful call stack
12:06:49 <c_wraith> jdiez: well, the whole thing does.  At this point, I'll say srhb's advice is sound.  Start with newtype Reader r a = Reader { runReader :: r -> a }, and write its Monad instance.  (It's very simplified, but it's a useful exercise)
12:06:51 <dmwit> jdiez: What does "last action" mean?
12:07:24 <c_wraith> jdiez: When you write (>>=) for it, you'll find it's easy to just do it mechanically.  But after you do, take a close look at what it's actually doing.
12:07:43 <c_wraith> jdiez: and try running some things through it by hand, like on paper.
12:07:53 <c_wraith> jdiez: you'll understand it a lot better.
12:08:23 <srhb> And it's a 20 minute exercise at most with some hand-holding! (I say this because my hands were held and I felt like a complete idiot) :-)
12:09:16 <andreypopp> hello everyone, I have a super silly question — why in monad transformers explicit liftIO is necessary? can't IO be lifted into the monad with some typeclass?
12:09:27 <jdiez> okay, I'll do some more reading and try to implement the Monad instance of Reader
12:09:29 <srhb> andreypopp: Because there are so many IO actions
12:09:44 <dmwit> andreypopp: MonadIO is that typeclass.
12:10:02 <dmwit> andreypopp: Or, to attack on another front: what should we do with forkIO? Have you thought about exceptions?
12:10:04 <zipper> So I am torn between learning yesod or learning about tests in haskell. Which do you recommend I do first?
12:10:24 <srhb> zipper: Whichever makes you most excited :)
12:10:24 <geekosaur> andreypopp, not the way you are thinking of; Haskell typeclasses are not OO mixins, you cannot "import" all of IO into your monad by declaring an instance
12:10:53 <zipper> srhb: Which will take a shorter time to learn? I assume testing?
12:10:55 <c_wraith> andreypopp: You mean, changing all functions that return IO a into (MonadIO m) => m a?  That doesn't work for anything that takes an IO value as an argument, like the aforementioned forkIO
12:11:12 <srhb> zipper: Depends how deep you go. Simple testing will be fast, sure :)
12:12:17 <outinputput> What is the best option for deploying a haskell webapp? obv not GAE, how about Heroku or other similar alternatives?
12:12:26 <outinputput> Is haskell even suited to webdev?
12:12:32 <srhb> outinputput: Oh yes.
12:12:49 <andreypopp> hm... what if I don't want to thread monad to forkIO's IO action?
12:13:07 <c_wraith> andreypopp: how would that even *work* with something like StateT Foo IO Int?
12:13:09 <andreypopp> I mean I want forkIO execute pure IO w/o my monad stack
12:13:29 <andreypopp> "pure IO" :-)
12:13:33 <c_wraith> andreypopp: StateT implies *linear* state threading.  That's completely incompatible with concurrency
12:14:10 <Guest81969> High I am a beginner and I do not understand the compiler or interpreter here: http://lpaste.net/104096 can anybody give me a hint?
12:14:42 <dmwit> andreypopp: Yes, you can liftIO . forkIO if that's what you want.
12:14:43 <c_wraith> Guest81969: [Int,Int] isn't a valid type.
12:14:45 <Iceland_jack> Guest81969: You can't do [Int, Int]
12:15:07 <c_wraith> Guest81969: you might have meant [(Int,Int)] or [Int]
12:15:33 <bergmark> wow that's not a very clear error message :-/
12:15:41 <outinputput> guest: first argument has type [] and second  is a tuple ().
12:15:43 <c_wraith> bergmark: I agree
12:15:46 <Fuco> is there something like anamorphism but where I can also reference to the "so far produced" output?
12:15:47 <outinputput> terrible error m,essage
12:15:57 <outinputput> you meant (x:xs) maybe?
12:16:03 <andreypopp> dmwit: from type signatures it seems that MonadIO is what I need
12:16:06 <c_wraith> Fuco: I'm sure there is, but I have no idea what! :)
12:16:10 <outinputput> or [(x,xs)]?
12:16:10 <andreypopp> thanks
12:16:10 <skypers> ok, I think I know why I got a weird pandoc version
12:16:13 * hackagebot hashable 1.2.2.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.2.0 (JohanTibell)
12:16:27 <Fuco> c_wraith: I was looking at Generic.Pointless but those things are quite obscure :D
12:16:28 <skypers> I had a upper limit on blaze-html that restricted pandoc
12:16:32 <Iceland_jack> Guest81969: I suggest you try defining simpler functions for lists until you get a hang of it
12:16:35 <outinputput> oh wait i did not read your type.
12:16:43 <skypers> I removed all of them, and now it’s good
12:16:49 <c_wraith> Fuco: check out the recursion-schemes package, maybe?
12:17:01 <Iceland_jack> Guest81969: Do you understand this definition?
12:17:01 <Iceland_jack>     len :: [a] -> Int
12:17:01 <Iceland_jack>     len []     = 0
12:17:01 <Iceland_jack>     len (x:xs) = 1 + len xs
12:17:01 <c_wraith> Fuco: it has lots of related stuff
12:17:12 <outinputput> guest: what shouold the function do?
12:17:28 <dmwit> Fuco: Have you looked through https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms
12:17:31 <dmwit> ?
12:17:38 <Guest81969> Thanks I changed to f1 :: [(Int,[Int])]->[(Int,Int)]
12:18:04 <c_wraith> recursion-schemes is a great package, but it's really inconvenient to use if you don't express your recursive data types in terms of fixed points.
12:18:30 <Iceland_jack> Guest81969: You probably intend to use [(Int, (Int, Int))] -> [(Int, Int)], it's a very strange function though and you're doing many strange things in the definition as well
12:18:36 <c_wraith> And that's a relatively unnatural way to define them unless you plan to use that package.
12:18:43 <shachaf> Expressing your recursive data types in terms of fixed points (of some variety) is more or less the point of recursion-schemes, isn't it?
12:18:45 <Fernandos> What's an avg. or regular salary for a jr. pos. as a Haskell Developer? (For whatever country you have some data from)
12:19:47 <srhb> Fernandos: My guess is it really depends on the field. I think finance might be quite an outlier.
12:20:14 <Fuco> c_wraith: I'll check it out, but from your description it sounds a lot like Generic.Pointless. The fix-point types are a bit annoying
12:20:20 <c_wraith> shachaf: well, it is general enough to support data structures defined other ways - but that's really annoying to work with.
12:20:35 <Fuco> though I'm actually implementing that for elisp, so all I need is (cons)lists
12:21:14 * hackagebot primitive 0.5.3.0 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.3.0 (JohanTibell)
12:22:24 <Fernandos> srhb: looks like £65k/y in the UK according to a site I found, but I was curious on the data you have
12:22:34 <jophish> Grr, this exam has an either monad for exceptions, but has used Right to hold the exception
12:22:35 <srhb> Fernandos: None I'm afraid.
12:22:58 <srhb> jophish: I can guess why, but it's still cruel :P
12:23:08 <jophish> srhb: why?
12:23:16 <srhb> jophish: Won't look like a lot of code out there!
12:23:33 <jophish> It's just mean to the people who actually know haskell!
12:23:41 <outinputput> Haskell salary finance: 1200000 pounds/year. non-finance: 0 pounds/year. Am I close?
12:23:50 <Nephro> Can someone please explain why I can't use expressions of type "x = 5 + 3" but "let x = 5 + 3" is fine inside a monad do
12:23:54 <outinputput> Meant 120000pounds/year
12:23:54 <Nephro> do block*
12:24:18 <srhb> Nephro: Because they're not top level declarations
12:25:05 <jle`> Nephro: do you know how do blogs are desugared?
12:25:12 <jle`> blocks
12:25:20 <Nephro> jle`, no, how?
12:25:25 <srhb> The let is desugared too in do-blocks, so that doesn't really answer anything.
12:25:49 <jle`> well i mean, the desugaring rules do not include x = 5 + 3
12:26:00 <srhb> No, but they include let x = 5 + 3
12:26:10 <srhb> The real answer is "because the language reference says so"
12:26:35 <srhb> It might be interesting to know none the less, so don't let that stop you :P
12:27:19 <jle`> @undo do { x <- a; y <- b x; c x y }
12:27:19 <lambdabot> a >>= \ x -> b x >>= \ y -> c x y
12:27:54 <Nephro> I am just trying to get into this stuff... Quite unusual stuff for an imperative programmer
12:27:55 <jle`> @undo do { x <- a; let { k = x + 2 }; y <- b k; c k y }
12:27:55 <lambdabot> a >>= \ x -> let { k = x + 2} in b k >>= \ y -> c k y
12:28:09 <dmwit> Nephro: Simple; "x = 5 + 3" isn't an expression at all. =)
12:28:10 <jle`> yeah, the real answer is because 'you just can't, because it's the wrong syntax'
12:28:22 <srhb> @undo do { let x = y; x }
12:28:22 <lambdabot> <unknown>.hs: 1: 19:Parse error: }
12:28:26 <srhb> Baw
12:28:39 <dmwit> ?undo do { let { x = y }; x }
12:28:39 <lambdabot> let { x = y} in x
12:28:45 <srhb> Cheating.
12:28:48 <srhb> :-)
12:28:51 <dmwit> =)
12:28:52 <geekosaur> necessary
12:28:54 <srhb> Indeed.
12:29:18 <Kerrim> I have written a parser with parsec that takes strings, and now I want to feed it with text files instead. How does one do that?
12:29:42 <jle`> Nephro: yeah, the real answer is that there is no 'why', just like "why do we use the equals sign for declarations instead of an asterisk"
12:29:44 <dmwit> :t let parse :: String -> a in parse <$> readFile "my_crazy_input.txt"
12:29:44 <srhb> Nephro: There is no good answer other than "this syntax is reserved for top level declarations because someone made it so"
12:29:45 <lambdabot>     The type signature for ‘parse’ lacks an accompanying binding
12:29:45 <lambdabot> Not in scope: ‘parse’
12:29:53 <dmwit> :t let parse :: String -> a; parse = undefined in parse <$> readFile "my_crazy_input.txt"
12:29:54 <lambdabot> IO b
12:29:57 <dmwit> Kerrim:
12:30:06 <Nephro> Yo guys just confused me even more :D No worries, I guess I just need to read further, just as the learning material states: "don't worry about this too much, we'll cover it later"
12:30:17 <Nephro> but thanks anyways
12:30:21 <srhb> Nephro: There's nothing preventing a language designer from making your version possible in an otherwise very Haskelly language
12:30:25 <dmwit> Kerrim: There are lots of spellings of (<$>). You could also use "fmap" or "liftM" or "liftA" or combine "(>>=)" and "return".
12:30:27 <srhb> Nephro: Haskell is just not that language. :)
12:30:41 <srhb> Nephro: Sorry if it's confusing.
12:30:44 <jle`> Nephro: what is your normal language?
12:30:52 <Kerrim> dmwit: Hmm, okay. I'll try it out, thanks!
12:30:53 <jle`> that you come from?
12:31:03 <Nephro> jle`, C++
12:31:06 <dmwit> Nephro: Maybe if you give a more complete snippet, we can explain what went wrong in a more targeted way.
12:31:32 <jle`> Nephro: so in that case, this question would be like asking "why can't i write `a int` instead of `int a` in my function type signatures?"
12:31:36 <srhb> I think the snippet is just do { x = y; x }
12:31:51 <Nephro> dmwit, no, nothing is going wrong, I was just wondering about the "let" thing
12:31:52 <jle`> i mean...you are more than welcome to write your own version of C++ where the types come after the variable
12:31:55 <dmwit> Oh, is it? Then the answer is clear.
12:32:07 <dmwit> By requiring "let", we can do a better analysis of how recursive you want things to be.
12:32:17 <Nephro> jle`, I see, I thought it had more meaning behind it
12:32:42 <srhb> dmwit: Do elaborate.
12:32:57 <Fernandos> outinputput: that about €147k/y, quite nice. But I've not found any Haskell jobs in Germany
12:33:10 <dmwit> srhb: All the bindings in a single let are recursive. Multiple lets are not recursive.
12:33:26 <jle`> wait
12:33:28 <jle`> really?
12:33:29 <srhb> dmwit: That doesn't really answer anything, does it? Top level declarations might be mutually recursive, too
12:33:33 <dmwit> srhb: So let { x = y }; let { y = 3} is very different from let {x = y; y = 3}.
12:33:39 <srhb> Well, okay, true.
12:34:11 <Fernandos> Do you know where to find Haskell jobs in Germany/Frankfurt? I've looked through some job searchengines, but have only found 1 position that is quite far away.
12:34:35 <srhb> Fernandos: Hanging out here and on reddit is a good bet, but there aren't a lot around, true. You probably have to be very active in your search.
12:34:42 <Fernandos> it seems as if either nobody is using haskell in germany, or nobody is advertising it..
12:34:42 <dmwit> That's not a really good example of recursion. I'm having a bit of trouble coming up with one on the spot.
12:35:20 <dmwit> But the idea is one must choose whether to shadow or recurse, and having a block delimit the boundary between the two is a particularly simple way to indicate to the compiler which you want.
12:35:26 <jle`> this changes everything
12:38:59 <Fernandos> srhb: Yeah, it seems there are only jobs in the finance industry for haskellers. I know 2PhD's and 3MSc who're good in haskell (in my univ.) and they're working as $PHP devs, because of that..
12:39:15 <dmwit> Fernandos: If you haven't tried haskellers.com yet (I think that's what it's called), you could try there.
12:40:27 <jle`> heh.
12:41:08 <outinputput> Fernandos: I was pulling those nbrs out of my ass, almost. A former teacher of me spoke of such nbrs in the financial sector
12:41:43 <macron> Fernandos: we might be hiring very soon - tweag.io. We all work remote.
12:41:49 <Fernandos> dmwit: uhm.. yeah I registered there, but singapore is a bit too far away for getting into haskell
12:42:23 * dmwit nods
12:43:32 <djahandarie> Fernandos, in the US there are some opportunities at least. I do some Haskell at my job and I'm not in the finance sector.
12:43:44 <absence> are things like fmap . fmap or liftM . liftM defined in some library?
12:43:47 <Fernandos> macron: Cool! Are you all from Paris?
12:43:51 <c_wraith> I did haskell work in web services.
12:44:01 <jophish> Do people tend to use succ or (+1)?
12:44:17 <leggo> succ is more general
12:44:19 <leggo> :t succ
12:44:19 <macron> Fernandos: I'm based in Paris. But everyone else is in a separate country.
12:44:20 <lambdabot> Enum a => a -> a
12:44:34 <dmwit> I would say using either is pretty rare.
12:44:39 <macron> Fernandos: we span 3 continents at the moment.
12:44:40 <jophish> leggo: yeah, I find myself using +1 a lot more often
12:45:00 <c_wraith> jophish: I prefer (+1), for no good reasons at all
12:45:02 <leggo> for numbers I use (+1) too
12:45:15 <absence> succ is a lot easier to type though :)
12:45:16 <Fernandos> djahandarie: yup, the scenes USA/SF and UK/London are much more active than any other place on earth, when it comes to using and advertising Haskell
12:45:19 <dmwit> (1+) is better than (+1). ;-)
12:45:33 <dmwit> better laziness properties when you're using lazy nats!
12:46:18 <dmwit> mmm
12:46:31 <dmwit> Maybe not. Depends how (+) is defined. =P
12:46:51 <n-dolio> Better use succ to be safe.
12:47:05 <dmwit> yep =)
12:48:03 <int-e> @src succ
12:48:03 <lambdabot> Source not found. :(
12:48:13 <dmwit> ?src Int succ
12:48:13 <lambdabot> Source not found. My mind is going. I can feel it.
12:48:17 <int-e> oh enum.
12:48:19 <int-e> right.
12:48:25 <Kaidelong> I now realize I don't understand how netwire works
12:48:38 <Kaidelong> I have no idea how to construct a terminal wire
12:49:17 <Kerrim> dmwit: The use of fmap solved my problem but gave me new ones. IO spreads through my program and in the end I'm stuck with IO data and a plot function that isn't friends with not-regular data ...
12:49:46 <dmwit> Kerrim: That's okay. You can teach your IO-unaware functions to be IO-aware.
12:49:54 <dmwit> Kerrim: That is the role of fmap and (=<<).
12:49:56 <dmwit> :t (=<<)
12:49:57 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:50:05 <jle`> Kaidelong: "terminal wire"?
12:50:14 <dmwit> if the function is IO-input-unaware, but outputs an IO action
12:50:16 <dmwit> :t fmap
12:50:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:50:31 <dmwit> if the function isn't IO-input-aware and doesn't output an IO action
12:50:37 <Kerrim> dmwit: Yeah but if the plot function comes from a module that's not in my control?
12:50:45 <dmwit> Kerrim: Then what?
12:50:51 <Kaidelong> jle`: a signal consumer. The closest thing I can think of is mapping an IO action over a producing wire
12:50:59 <dmwit> Kerrim: You don't have to have the source of a function to apply fmap to it.
12:51:17 * hackagebot snap-web-routes 0.5.0.0 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.5.0.0 (lukerandall)
12:51:19 <dmwit> Kerrim: You can take that function somebody else wrote, and teach it about IO. That's what I'm saying.
12:51:22 <Kaidelong> but without ticking the clock it doesn't seem to be possible to produce a wire that does anything like this
12:51:33 <jle`> Kaidelong: you aren't really supposed to have signal consumers, and that isn't what the monad transfomer part of Wire is supposed to be used as
12:51:37 <dmwit> Kerrim: (Without changing the function itself.)
12:51:48 <jle`> ( it's not supposed to be used at all actually :) )
12:52:14 <Kaidelong> I'm trying to hook glfw-b up to netwire but I'm really stumped as to how to do this
12:52:32 <Kaidelong> I could build a glfw-b session fine
12:52:39 <Kaidelong> I can use the glfw-b clock and watch it tick
12:52:43 <jle`> what you should do is make a normal function that repeatedly uses runWire :: time delta -> input -> (output, new wire)
12:53:09 <jle`> hm let me find an example i wrote
12:54:27 <jle`> are you using 5.x?
12:54:31 <Kaidelong> yeah
12:54:40 <Kaidelong> the way I was thinking of doing windows was something like
12:54:51 <jle`> https://github.com/mstksg/netwire-experiments/blob/master/src/Render/Backend/SDL.hs#L49-L79
12:55:09 <Kaidelong> (MonadIO m) => (scene -> IO) Wire s e m scene ()
12:55:18 <Kaidelong> missing -> inbetween there
12:55:26 <Kaidelong> where the wire inhibits when the window has to close
12:55:31 <Kaidelong> and produces otherwise
12:55:41 <Kaidelong> but this seems like a bad idea
12:56:49 <jle`> hm. yeah. your drawing should be outside of your wire
12:57:01 <jle`> whatever IO you do should be outside of your wire
12:58:55 <Kaidelong> maybe the whole concept of trying to tie together GLFW-b and netwire is a bad idea then
12:59:21 <Kaidelong> I mean as a dedicated library
12:59:36 <Kaidelong> you can probably do what you want just with netwire and GLFW-b without anything inbetween
13:00:13 <jle`> well
13:00:17 <jle`> you use netwire to generate your scene
13:00:25 <jle`> and you use GLFW-b to step your wire and draw each scene
13:00:39 <Kaidelong> what I really wanted to do was let the user use netwire to handle input
13:00:51 <jle`>  like, write netwire code?
13:01:00 <Kaidelong> yeah have like
13:01:06 <Kaidelong> if they want to hook up an F key
13:01:09 <jle`> oh, are you writing a library
13:01:12 <Kaidelong> get a wire that they can feed in
13:01:13 <Kaidelong> yes
13:02:03 <jle`> generally, how netwire works is you have a Wire m (all inputs, key presses, network activity, etc.) (all outputs, your entire thing to render, etc.)
13:02:25 <jle`> and you just step through tick by tick, feeding in input at that time, and drawing/responding to output at that time
13:03:01 <jle`> it should ideally be a pure process
13:03:29 <Kaidelong> but there is state
13:03:34 <Kaidelong> like what windows are open
13:03:37 <Kaidelong> how big they are
13:03:42 <jle`> the m is only there for things like...global environments...or, in case of IO, performance tweaks
13:03:58 <jle`> Kaidelong: you can handle that by sending it in through the input
13:04:21 <Kerrim> dmwit: If stuff begins to look like this "lst = organize <$> (convToFloat <$> (parseData <$> readFile file))", am I doing it wrong?
13:04:26 <Kaidelong> oh okay, that's okay then?
13:04:34 <Kaidelong> so the structure I'm going for is something like
13:05:33 <Kerrim> dmwit: I mean, should I maybe start to rethink the code with IO in mind from the bottom up? Because this is getting out of control
13:06:16 <Kaidelong> okay I need to rethink this
13:06:32 <Kaidelong> I'm guessin what I'm going for is some kind of Wire -> Window transformation
13:07:19 <Kaidelong> like a kind of stateful "registerWire" function
13:08:54 <Kaidelong> (GLInfo -> b -> IO ()) -> Wire s e m InputRecord b -> IO Window
13:09:14 <Kaidelong> (I'm not providing any kind of renderer with this library so I'm going to need to parameterize that somehow)
13:09:39 <Kaidelong> well no that still won't work because then each window has to step the wire
13:10:10 <Kaidelong> the wire should only be stepped *once* and the results pushed to every window
13:10:35 <Kaidelong> has to step the session, I mean
13:10:44 <Kaidelong> each wire has to step the session
13:10:59 <Kaidelong> this would be trivial if I only had to worry about a single window
13:12:24 <Kaidelong> maybe I just need to use *** from arrow
13:12:54 <c_wraith> I hear Bifunctor is moving to base for 7.10
13:13:16 <c_wraith> And that's like 90% to replace people leaning on Arrow
13:13:31 <shachaf> Hooray for less Arrow.
13:13:33 <benzrf> how do bf's relate to arrows
13:13:42 <c_wraith> they don't
13:13:42 <benzrf> and what are arrows good for anyway
13:13:55 <c_wraith> But they give people the same operations that people mostly use Arrow for these days
13:14:45 <c_wraith> :t (***)
13:14:46 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:14:55 <c_wraith> :t bimap
13:14:56 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:15:04 <c_wraith> yeah.  Those are the same thing
13:15:31 <c_wraith> At least they are if you're using the (->) instance for Arrow and the (,) instance for Bifunctor
13:15:51 <shachaf> That's a pretty specific case.
13:16:09 <c_wraith> well, it's the most common Arrow instance used!
13:16:20 <shachaf> I mean (***)
13:16:27 <c_wraith> : (***) `asTypeOf` bimap
13:16:30 <c_wraith> err
13:16:34 <c_wraith> :t (***) `asTypeOf` bimap
13:16:35 <shachaf> Lots of other behavior you might want.
13:16:35 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
13:16:37 <benzrf> > bimap (+1) (++"ok") (3, "test ")
13:16:39 <lambdabot>  (4,"test ok")
13:16:43 <benzrf> k
13:16:57 <benzrf> :t asTypeOf
13:16:58 <lambdabot> a -> a -> a
13:17:01 <benzrf> o=
13:17:19 <benzrf> neeeatttt
13:17:42 <c_wraith> Bifunctor also provides first and second as drop-in replacements for Arrow's first and second.
13:18:18 <c_wraith> Meaning the only abused operator remaining from Arrow will be &&&
13:18:47 <ajcoppa> i find &&& pretty helpful as a haskell beginner!
13:18:57 <jophish> srhb: And now the examiner has used mutually recursive type synonyms!
13:19:01 <shachaf> (&&&) is the thing saying your category has products, or something.
13:19:09 <shachaf> It's great.
13:19:24 <c_wraith> ajcoppa: it's absolutely useful!  It's just to use the Arrow abstraction to get it.
13:19:37 <davidturner_> Hi there, I've got a puzzling problem compiling transformers-compat-0.3 using cabal
13:19:42 <c_wraith> err, it's just *silly* to use the...
13:19:42 <davidturner_> http://lpaste.net/104098
13:19:46 <ajcoppa> yeah, makes sense
13:19:57 <ajcoppa> i don't really understand arrows yet, but i understand &&& and *** :)
13:20:04 <davidturner_> it doesn't work unless I pass the -ftransformers3
13:20:08 <davidturner_> ... flag
13:20:30 <davidturner_> works ok if I do runHaskell Setup.lhs
13:21:30 <davidturner_> anyone else seeing this? should I do anything abou tit?
13:25:27 * Heffalump wonders if anyone cares about GHC 6.10.4 ever
13:25:49 <bennofs> Is there any way to get the RTS flags that were compiled in using -with-rtsopts ?
13:26:10 <bennofs> (from command line, or from within the program?)
13:30:53 <c_wraith> Hmm.. I don't see a useful way to generalize (&&&) differently than Arrow does it.
13:31:04 <bennofs> :t (&&&)
13:31:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:31:10 <c_wraith> It's not a good fit for Bifunctor, because it depends on (,)
13:31:57 <n-dolio> You could have categories with products.
13:32:19 <c_wraith> yeah, it'd take some sort of product abstraction
13:32:33 <c_wraith> And that's kinda... ehh. Not obvious it'd be useful.
13:33:24 <n-dolio> Pretty sure Cale and some others used something like that.
13:34:10 <c_wraith> It's a really hard thing to search hackage for
13:34:45 <shachaf> :t (|||)
13:34:46 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
13:35:09 <cceckman> Hey folks. Pretty new to Haskell, so forgive me if this is silly. Is there a way to make an [IO a] into an IO [a]?
13:35:19 <Kaidelong> @ty sequence
13:35:20 <lambdabot> Monad m => [m a] -> m [a]
13:35:29 <n-dolio> I think categories-with-products are as likely to be useful as Arrows are.
13:35:40 <cceckman> Kaedelong: thanks!
13:36:14 <Kaidelong> there are some caveats with IO I think
13:36:48 <c_wraith> Kaidelong: I don't think there are any specific to IO.  Just to all cases where >>= is strict in its first argument
13:37:14 <Kaidelong> c_wraith: yes, that's what I was thinking of, thanks for putting it more elegantly than I could
13:37:27 <Kaidelong> anyway point is don't use sequence on infinite lists
13:37:35 <Kaidelong> except where it makes sense
13:37:41 <Kaidelong> which isn't the case with IO
13:38:16 <Fuuzetsu> is there a non-empty list module?
13:38:17 <c_wraith> you could use sequence with an infinite list of lazy State values, so long as you don't look at the final state.
13:38:32 <cceckman> OK, not an issue here ( I don't think) - in IO, but not an infinite list
13:38:36 <c_wraith> Fuuzetsu: there's several.  edwardk put one in..  uh...  comonad?
13:38:37 <bennofs> Fuuzetsu: semigroups has Data.List.NonEmpty
13:38:42 <c_wraith> Oh, semigroups.
13:38:49 <Fuuzetsu> just found it
13:39:20 <Fuuzetsu> ah, filter returns [a], was wondering about that
13:39:43 <c_wraith> cceckman: sometimes sequence can be a surprising performance bottleneck, in how it creates the list.  It's a function that sometimes is exactly what you want, but sometimes you should be suspicious of.
13:40:29 <c_wraith> cceckman: on the other hand, sequence_ never has any of those issues, because it throws results away.
13:40:30 <monochrom> sequence on infinite list makes sense in Control.Monad.State.Lazy, for example :)
13:41:18 <cceckman> c_wraith: Hm. Okay. Not quite sure I understand, but.
13:42:17 <c_wraith> cceckman: don't worry about it too much for now...  But if you run into performance problems, remember to be suspicious of it.
13:42:42 <cceckman> c_wraith: OK. It's mostly small sequences- trying to learn about monads in practice by doing a dice roller.
13:43:22 <Fuuzetsu> do you know about monads in theory? ;)
13:43:42 <monochrom> in theory, I know everything :)
13:44:11 <monochrom> in practice, I know those things I know :)
13:44:24 <Fuuzetsu> hired!
13:45:07 <cceckman> Fuuzetsu: Alas, not really. Trying to bone up on that too.
13:46:04 <rekahsoft> hi all..i have a monad transform with type: ReaderT GUI (StateT Config IO) a
13:47:10 <Nephro> Do I need to include or load something to use Parsec in ghci?
13:47:15 <rekahsoft> its it possible when i lift from the outer monads (ReaderT and StateT) to IO to get data from the outer monads (eg. call ask or get from the IO monad accessing the outer monads?)
13:48:02 <dmj`> @typ liftIO
13:48:03 <lambdabot> MonadIO m => IO a -> m a
13:48:57 <rekahsoft> dmj`: i assume your answer is for me?
13:49:46 <Kaidelong> well the way the MonadX typeclasses work is that they automate deep lifting by having instances in the form of
13:49:58 <benzrf> deep lifting?
13:50:00 <benzrf> [A[A[A[A
13:50:00 <benzrf> [A[A[A[A
13:50:16 <Kaidelong> "if Y is a monad transformer and its inner monad is an instance of me, Y is also an instance of me"
13:51:14 <sveit> is there a way, using attoparsec, to construct a parser that, as it goes through a file with 2 types of lines, will result in a tuple of two lists, one containing the parsed lines of the first type, the other parsed lines of the second type?
13:51:26 <mmachenry> Kaidelong: So they fix issues where I might have "WriterT ReaderI RandT IO Int" and then to do something with RandT I need to lift a lot get to Rand
13:51:49 <Kaidelong> yes
13:51:54 <benzrf> hey
13:51:55 <benzrf> in:
13:51:55 <benzrf> experiment :: Functor f => (s -> f s) -> Store s a -> f a
13:51:55 <benzrf> experiment k (Store f s) = f <$> k s
13:52:06 <Kaidelong> in fact if you're using random-fu it provides a MonadRandom typeclass
13:52:06 <benzrf> wouldn't (k (f s)) work too?
13:52:18 <benzrf> oh wait noam
13:52:20 <benzrf> *no
13:52:22 * benzrf facepalms
13:53:25 <mmachenry> Kaidelong: Bro, do you even liftM?
13:53:28 <mmachenry> ;)
13:53:40 <mmachenry> I can't be the first to make the stupid joke in here, can I?
13:54:03 <methodiu1> mmachenry: I was drinking when I read that and spilled water everywhere :)
13:54:16 <mmachenry> methodiu1: You're welcome/I'm sorry
13:54:48 <benzrf> liftM is just fmap
13:54:57 <benzrf> but on Monads instead of on Functors
13:55:00 <FireFly> benzrf: do you even fmap?
13:55:02 <benzrf> ^the fact that that's a valid sentence is sad
13:55:19 <benzrf> mmachenry: i made a worse joke in here last night
13:55:24 <benzrf> it even started a chain reaction of bad jokes
13:55:24 <benzrf> :-D
13:56:24 <monochrom> I made a joke mentioning "jello", then people started saying that "jellad", "jelloid" really exist
13:57:21 <benzrf> @faq can you fix this?
13:57:22 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:57:24 <benzrf> lame
13:57:39 <monochrom> ha ha
13:57:43 <c_wraith> what?  @faq got replaced with something useful?
13:57:56 <bennofs> @faq Can haskell solve the halting problem?
13:57:56 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:57:57 <monochrom> we need a @yes
13:57:59 <bennofs> :|
13:58:00 <benzrf> @yes
13:58:01 <lambdabot> Maybe you meant: yow oeis let
13:58:03 <benzrf> @yow
13:58:03 <lambdabot> I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE
13:58:04 <lambdabot> and WHEAT THINS ...
13:58:07 <benzrf> what
13:58:08 <benzrf> @yow
13:58:08 <lambdabot> ... I don't like FRANK SINATRA or his CHILDREN.
13:58:13 <benzrf> @help yow
13:58:13 <lambdabot> yow. The zippy man.
13:58:17 <benzrf> :|
13:58:18 <geekosaur> zippy the pinhead
13:58:19 <benzrf> @oeis
13:58:20 <lambdabot>  Sequence not found.
13:58:24 <benzrf> @oeis test
13:58:25 <monochrom> on the bright side, @faq was a const, and is still a const.
13:58:25 <lambdabot>  Residues of the Lucas - Lehmer primality test for M(29) = 536870911.[4,14,19...
13:58:39 <bennofs> @oeis 1,2,3,4,5,6,7
13:58:45 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
13:58:51 <bennofs> benzrf: ^^
13:59:05 <shachaf> monochrom: Maybe we can write our own yes.
13:59:14 <shachaf> Can we write our own yes? Yes.
13:59:19 <monochrom> haha
13:59:25 <shachaf> There you go. Saved one line of IRC spam.
14:00:18 <benzrf> @oeis 3,4,5,6,6,4
14:00:20 <benzrf> spam
14:00:22 <lambdabot>  Major index of n, 2nd definition.[0,0,0,0,0,1,0,0,0,1,2,2,0,1,0,0,0,1,2,2,3,...
14:00:25 <benzrf> o_o
14:00:29 <monochrom> . o O ( @yes what is the answer to this question? )
14:03:00 <monochrom> eh? the FAQ answers "should I learn haskell?"
14:03:02 <Nephro> what's wrong with the indentation here?
14:03:04 <Nephro> http://pastebin.com/Gphp6pRq
14:03:33 <shachaf> I don't know. You tell us.
14:03:52 <Kaidelong> that seems like it should work
14:03:57 <Kaidelong> odd
14:03:59 <Nephro> Kaidelong, doesn't
14:04:21 <Nephro> intro.hs:70:1: parse error (possibly incorrect indentation)
14:04:24 <monochrom> it is right in a suitable context, and wrong in other contexts. show complete verbatim unabridged code
14:05:36 <Nephro> monochrom, that's all there iss
14:05:48 <monochrom> I disbelieve you.
14:06:11 <Kaidelong> well if that's all there is then I have no idea how that would work at all, just an expression at the top level?
14:06:17 <shachaf> Nephro: Your paste doesn't have 70 lines, so something weird must be going on.
14:06:34 <shachaf> Perhaps you're running the wrong file. "let" isn't valid Haskell syntax at the top level anyway.
14:06:41 <monochrom> but what Kaidelong says is likely relevant.
14:06:41 <Nephro> intro.hs:3:1: parse error (possibly incorrect indentation)
14:06:45 <monochrom> but I hate guessing games.
14:06:49 <Nephro> deleted the rest of the file
14:06:50 <Nephro> well
14:07:01 <Nephro> there were jsut some functions nothing much, just practice stuff
14:07:15 <Kaidelong> Anyway you can't have that as a thing
14:07:24 <Kaidelong> you need to bind it to something to have it at top level
14:07:34 <geekosaur> if that is a file you are trying to compile or load, it won't work because it's a bare expression
14:07:52 <geekosaur> ghci is like the inside of a "do" block and allows expressions
14:08:33 <Nephro> riight, put it in a function now it works
14:08:35 <Nephro> thanks
14:08:37 <Nephro> my bad
14:16:02 <Ainieco> hello
14:16:27 * hackagebot youtube 0.2.0.1 - Upload video to YouTube via YouTube API  http://hackage.haskell.org/package/youtube-0.2.0.1 (HenningThielemann)
14:17:25 <Ainieco> could you please recommend me any gui library to render graphs? what i want to is is just simple graph renderer(endge/vertices/labels) with ability to click on vertex to transfer view to another graph
14:20:24 <savanni> Ainieco: there may not be one.  It sounds like two completely separate features that you are wanting: rendering + interactivity.  We may not have a library for that.
14:23:14 <krgn> hi
14:23:46 <krgn> is there any difference in using System.Process(runInteractiveProcess) with -threaded?
14:24:28 <nomeata> Hi. Is it normal that the doctest testsuite of lens takes an awful long time?
14:24:31 <krgn> I have a program that writes to stdin handles of a process started that way, and with -threaded the process just gets zombified when I hPutStr something to the handle
14:25:03 <shachaf> nomeata: How awful?
14:25:13 <monsieurp> j
14:25:36 <nomeata> shachaf: ah, now it is through. felt like 10 minutes (compared to maybe 2 or 3 for building lens)
14:28:50 <monochrom> the computer monitors your irc conversations, and speeds up or slacks off your tests depending on whether you mention it :)
14:29:46 <h_noob> hey can anyone recommend something for real time audio in haskell?  it seems like most things are oriented towards static music generation from a fixed program.
14:30:18 <monochrom> "hey sweetie, how was your weekend? ..."  (10 minutes later)  "look sweetie, boss is talking about my progress behind my back, I have to hang up and run this code now, ttyl"
14:30:41 <krgn> h_noob: have you looked at hsc? its a client for super-collider
14:30:52 <h_noob> hsc, nope haven't looked at that one yet
14:31:09 <h_noob> will investigate
14:31:24 <krgn> http://hackage.haskell.org/package/hsc3
14:31:47 <monochrom> (2 minutes later) "hey sweetie, boss seems happy again, so, how about dinner tonight?" :)
14:49:14 <ivanm> is it correct that having "func ~x@Foo{} = ... ;  func ~x@Bar{} = ..." is really overlapping pattern matches? or is ghc being paranoid?
14:49:47 <shachaf> ivanm: It looks overlapping, since the first one would match everything.
14:50:07 <ivanm> how so? because of the ~ ?
14:50:34 <shachaf> That's presumably the point of the ~
14:51:46 <ivanm> oh, right, duh
14:51:50 * ivanm just got up
14:53:54 <monochrom> whether it's "overlapping" is a grey area of English semantics (if there is such a thing). but the compiler is not being paranoid.
14:54:23 <monochrom> i.e., the second case is definitely unreachable code, even by Haskell 2010 standards.
14:55:24 <ivanm> monochrom: gotcha
14:56:19 <monochrom> the combination ~v@(Ctor ...) is a very interesting and subtle pattern. see my http://lpaste.net/100588 for examples. there are surprises.
14:58:29 <ivanm> monochrom: what are the section numbers from? is this an exercise from a textbook?
14:59:33 <frontend1oader> 100%
15:00:07 <yorick> hey, I want to number the elements of a Data.HashMap, what's the best way to do that?
15:01:32 * hackagebot monadLib 3.7.3 - A collection of monad transformers.  http://hackage.haskell.org/package/monadLib-3.7.3 (IavorDiatchki)
15:01:33 <geekosaur> ivanm: they're references to the Haskell 2010 Language Report, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
15:01:34 * hackagebot html-rules 0.1.0.0 - Perform traversals of HTML structures using sets of rules.  http://hackage.haskell.org/package/html-rules-0.1.0.0 (KyleCarter)
15:01:47 <ivanm> geekosaur: ta
15:02:56 <yorick> I could do it with a state monad and mapM, I suppose
15:03:21 <sveit> what are the rules for associativity on kinds? i.e. it appears that a -> b -> c /= (a->b) -> c
15:03:39 <sveit> but that a -> b -> c == a -> (b -> c)
15:03:50 <merijn> sveit: Right, that's the same for -> on functions
15:04:01 <merijn> sveit: (->) is right associative for both functions and kinds
15:04:24 <Peaker> and application is left-associative for both values and types:  f a b = (f a) b
15:06:34 <yorick> evalState (mapM (\x -> do { i <- get; put (i + 1); return (i, x) }) tree) 0
15:06:38 <yorick> somebody stop me, please :/
15:07:55 <fizruk> does anyone know of a programming language with support for quotient types (or maybe some more general stuff)?
15:08:03 <merijn> yorick: Why? Seems reasonable enough to me? It might be easier to number them as you insert them, but who cares?
15:08:27 <yorick> merijn: I have a filter step after I insert them, so I can't do that :/
15:09:47 <fizruk> yorick: that get/put/return thing reminds me of something. perhaps Supply monad
15:11:06 <yorick> fizruk: hmm, interesting
15:11:33 * hackagebot html-rules 0.1.0.1 - Perform traversals of HTML structures using sets of rules.  http://hackage.haskell.org/package/html-rules-0.1.0.1 (KyleCarter)
15:11:34 <monochrom> ivanm: the section numbers are from Haskell 2010 Report
15:12:25 <monochrom> think of it as "Criminal Code Section 3.12 Paragraph 4 Clause (a)" :)
15:13:11 <monochrom> or "it's a Chapter-11 bankrupcy" :)
15:13:45 <merijn> Revelations 1:17 :p
15:14:20 <Kaidelong> is Ctor haskell jargon for "constructor?"
15:14:32 <Kaidelong> well I guess it's more a metasyntactic variable
15:14:36 <monochrom> no. my jargon.
15:14:51 <merijn> Kaidelong: I would say it's "lazy typist jargon" rather than haskell jargon :)
15:14:54 <monochrom> which I adopted from C++ jargon!
15:15:11 <Kaidelong> lazy typist metasyntactic variable
15:15:17 <Kaidelong> let's be precise here
15:15:44 <hoverbear> So, I've been trying for awhile now, but I cannot for the life of me get `cabal install haste-compiler` to succeed
15:15:49 <monochrom> naw, lazy typist metasyntactic variable would be single-letter
15:17:30 <Kaidelong> Ctor. Btor. Skeletor.
15:17:41 <Kaidelong> it's like Foo Bar Baz
15:19:17 <sveit> since Attoparsec does not provide a monad transformer, how would one keep track of state?
15:20:03 <merijn> sveit: "StateT s Parser a"? :)
15:20:18 <merijn> That's what I'm currently doing
15:20:38 <merijn> The only annoying bit is that you have to lift all the parser primitives, but you can do that entire do-blocks at a time
15:21:44 <sveit> how do you lift do-block at a time?
15:22:00 <fizruk> lift $ do { … }
15:23:46 <merijn> sveit: do blocks are also just expressions (just add some parenthesis or $) so you can just write them "in place" when calling lift
15:24:23 <sveit> i see. thanks. also, is a State the "best" way to split up the results of parsers into containers?
15:25:37 <sveit> i mean that i have parsers A and B, and my current parser is many (A <|> B), but i would like my result to be ([parsed with A], [parsed with B])
15:25:39 <grache28> I'm still trying to get a grasp on haskell's lack of mutatable variables. I think I might be on to something. If I want to perform multiple operations on a list, I just need to string all of the functions together at once and assign it to a new list. No?
15:26:18 <sveit> so my idea was to keep track of a state and somehow do it that way, but i'm having a lot of trouble wrapping my head around this issue
15:26:21 <monochrom> yes
15:26:24 <merijn> sveit: This all works fine: http://lpaste.net/104099
15:26:29 <dmj`> grache28: haskell can have mutable variables that live inside of IO, like an IORef.
15:26:55 <grache28> sounds like sveit is going through the same is, but is a bit farther a long than me
15:26:59 <merijn> dmj`: That seems unhelpful for his concern
15:27:03 <jdiez> grache28: you want to perform multiple operations on a list, right?
15:27:09 <hoverbear> Trying to build `haste-compiler` and getting a fail, here's the error log: https://gist.github.com/anonymous/8e4624fceea5440d020c  Help? :(
15:27:09 <jdiez> why not compose the operations?
15:27:13 <dmj`> grache28: haskell simulates mutable purely using the State Monad
15:27:18 <grache28> dmj`: but is that the typical scenario?
15:27:19 <jdiez> grache28: op1 . op2 . op3 $ yourList
15:27:38 <monochrom> or is it op3 . op2 . op1 ?
15:27:38 <jdiez> grache28: you can also do it with a list if you want
15:27:58 <merijn> grache28: The answer is "it depends", usually you'd compose functions like "map foo . filter somePredicate . map bar $ myList" or something
15:27:59 <jdiez> yeah, op3 . op2 . op1
15:28:20 <dmj`> mutable state*
15:28:34 <grache28> what Im trying to do is take two different lists, and do graph exploration on them to find all possible solutions via backtracking then save all possible solutions in a new list
15:28:49 <merijn> grache28: It helps to stop thinking about "I have a list and want to change it" and start thinking "I define a pipeline of operations that take a list and return a list"
15:28:57 <grache28> I'm guessing that should be done via composition?
15:29:32 <grache28> merijn: yea that's what I'm trying to do
15:29:39 <Cale> Can you describe what you're trying to compute a bit more precisely?
15:29:44 <grache28> think about it that way
15:29:54 <merijn> grache28: Sounds like you want to build a new list by appending results to a "solution" list?
15:31:30 <sveit> merijn: sorry to bother you with this parsing issue, but is my problem clear? that I want to transition from many (A <|> B) :: [lines parsed with A and B] to some function with type ([lines parsed with A], [lines parsed with B])?
15:31:37 <Cale> grache28: You can turn any imperative algorithm which makes use of local mutable variables into a pure one by turning those mutable variables into function parameters, and each point of control (basically each line of code) into a function of those parameters -- each function will then apply the next one in sequence to the new values of the variables.
15:31:50 <Cale> grache28: This will produce horrible code, but it's a place to begin
15:31:55 <merijn> sveit: Attoparsec, right?
15:32:19 <Cale> and once you have functional code, you can use equational reasoning to simplify it like you'd simplify expressions in highschool algebra
15:32:50 <merijn> sveit: Consider "eitherP :: Alternative f => f a -> f b -> f (Either a b)", combine that with "many" and your result will be "Parse [Either a b]"? :)
15:33:27 <Cale> (replacing equals with equals to eliminate more and more of the auxiliary functions until you ideally get it down to a single recursive function that you can analyse)
15:34:10 <Cale> grache28: However, that's a hard road to take to getting really pretty code.
15:34:15 <grache28> Cale: list of 'results' list of 'addends' for example: [9,7] [3,5,2,6] - and ultimately return all possible ways to arrive there using each added only once: [(3,6), (5,2)]
15:34:51 <Cale> grache28: Should I assume that your sums will only ever have two elements?
15:35:06 <Cale> (you used pairs there rather than lists)
15:35:28 <grache28> Cale: but since there with more complex lists there will be multiple ways of doing it, some paths will lead to failures while others on the same lists will lead to solutions, so that's the need for graph/backtracking.
15:35:44 <Cale> A list comprehension is a good way to handle this
15:35:46 <jdiez> grache28: this sounds like the perfect use case for lists as monads
15:35:57 <grache28> Cale: it should return a list of pairs - yes only 2 addends
15:36:18 <Cale> > [(n,m) | t <- [9,7], (n:ms) <- tails [3,5,2,6], m <- ms, n + m == t]
15:36:19 <lambdabot>  [(3,6),(5,2)]
15:36:48 <sveit> merijn: yes, attoparsec. so that is a solution for 2, and I can then filter by "left" or "right", but in my actual case i have 3
15:37:04 <sveit> so many (A <|> B <|> C), and I want a 3-tuple
15:37:30 <Cale> > tails [3,5,2,6]
15:37:31 <lambdabot>  [[3,5,2,6],[5,2,6],[2,6],[6],[]]
15:37:37 <sveit> merijn: i have a wrapper class and am filtering on it as of this moment, but this is not "elengant" to me :)
15:37:58 <Cale> > [(n,ms) | (n:ms) <- tails [3,5,2,6]]
15:38:00 <lambdabot>  [(3,[5,2,6]),(5,[2,6]),(2,[6]),(6,[])]
15:38:01 <jdiez> Cale: how would you do that with lists as monads?
15:38:18 <Cale> Lists as a single monad, you mean
15:38:26 <jdiez> yes
15:38:37 <merijn> jdiez: list monad just has ">>=" == "concatMap"
15:38:52 <Cale> > do t <- [9,7]; (n:ms) <- tails [3,5,2,6]; m <- ms; guard (n+m == t); return (n,m)
15:38:54 <lambdabot>  [(3,6),(5,2)]
15:38:59 <jdiez> yes, but I'm trying to figure out how you would perform the same computation using the list monad
15:39:11 <grache28> cool tks Cale
15:39:12 <jdiez> okay, that's pretty cool, thanks Cale
15:39:23 <merijn> sveit: Not very, but it's not that bad either. It's a bit tricky to know what else you can do without more details about the exact problem, though
15:39:23 <Cale> Note, this implicitly uses fail
15:40:05 <grache28> Cale: im just getting started - and this is actually a project for college - i have to do it a certain way. I was just looking for general inspiration.
15:40:42 <Cale> grache28: You could also use map and concat a whole bunch -- the list comprehension syntax in fact translates into a bunch of uses of concatMap
15:41:37 * hackagebot scientific 0.3.0.0 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.0.0 (BasVanDijk)
15:42:18 <grache28> I need a function "twoThatAdd" 8 [1,3,9,6,7,5]
15:42:22 <grache28> [(1,7),(3,5)]
15:42:25 <sveit> i've given details a few times, hopefully i get it right this time :) i have three types of lines, say A, B, C, with parsers pA, pB, and pC. these lines can occur in any order in the file, and it is important to me to know this order. what I am doing now is saying data Lines = LA A | LB B | LC C, and have a parser many $ pA <|> pB <|> pC . I am searching for a "better" solution than a return type of [Lines]
15:42:26 <sveit> that I have to filter through later
15:42:34 <grache28> removeReps [(3,5),(5,3)]
15:42:37 <grache28> [(3,5)]
15:43:04 <sveit> merijn: some suggestions have been to number the lines and put them in separate lists, which I think might be a good idea, but then i need a way to actually put them in separate lists, which is hard since they occur randomly
15:43:13 <grache28> then usuing those another func childNodes ([12,11,8],[1,3,9,6,7,5],[])
15:43:16 <jdiez>  > let twoThatAdd t xs = [(n,m) | (n:ms) <- tails [3,5,2,6], m <- ms, n + m == t]; twoThatAdd 8 [1,3,9,6,7,5]
15:43:20 <grache28> [([11,8],[1,6,7,5],[(3,9)]),
15:43:22 <grache28>  ([11,8],[1,3,9,6],[(7,5)])]
15:43:26 <merijn> sveit: Is the order the lines occur in always the same?
15:43:36 <sveit> merijn: no, that's the tricky part :)
15:43:38 <Iceland_jack> grache28: For school?
15:43:48 <grache28> Iceland_jack: yes - i'
15:43:56 <grache28> m not asking anyone to help me do it - i
15:43:58 <Cale> grache28: So, if you start with the tails of [1,3,9,6,7,5], you can look for a tail (x:xs) and some y in xs so that x + y == 8
15:44:07 <grache28> m just trying to figure out how to use haskell
15:44:12 <Cale> > tails [1,3,9,6,7,5]
15:44:13 <lambdabot>  [[1,3,9,6,7,5],[3,9,6,7,5],[9,6,7,5],[6,7,5],[7,5],[5],[]]
15:44:27 <Iceland_jack> > [ (a, b) | (a, b) <- liftM2 (,) [1,3,9,6,7,5] [1,3,9,6,7,5], a + b == 8 ]
15:44:28 <lambdabot>  [(1,7),(3,5),(7,1),(5,3)]
15:44:36 <merijn> sveit: You could use separate lists, yes, although I don't think that's prettier than tagging all three solutions with a datatype
15:45:53 <Cale> > [(x,y) | (x:xs) <- tails [1,3,9,6,7,5], y <- xs, x + y == 8]
15:45:55 <lambdabot>  [(1,7),(3,5)]
15:46:10 <grache28> Iceland_jack: nice - but the lists aren't always [1,3,9,6,7,5] or 8 - let me figure out how to make that take any list I give it
15:46:21 <sveit> merijn: i guess. it's just ugly since i end up writing code like (i think we've spoken :) ) map (\(LA a) -> a) . filter (\a -> case a of {(LA _) -> True; _ -> False})
15:46:22 <jdiez>  > let twoThatAdd t xs = [(n,m) | (n:ms) <- tails [3,5,2,6], m <- ms, n + m == t]
15:46:30 <jdiez> grache28: ^
15:46:32 <Cale> well, you can abstract over the choice of lists by defining a function which puts those lists in
15:46:42 <Cale> jdiez: You forgot to replace the list...
15:46:46 <jdiez> whoops
15:46:46 <sveit> merijn: i wish there was a more general way to do pattern matching, so that I could pass a class name as a function parameter
15:47:01 <Iceland_jack> sveit: Class name?
15:47:11 <sveit> sorry, type constructor
15:47:23 <sveit> my lisp background is showing :)
15:47:36 <Iceland_jack> Could you give a motivating example?
15:47:50 <Cale> sveit: What would the type of such a function look like?
15:47:55 <merijn> sveit: Well, you could also write a custom "LAs" function that filters and exits in one go
15:48:21 <sveit> basically instead of (where LA is a constructor) writing map (\(LA a) -> a) . filter (\a -> case a of {(LA _) -> True; _ -> False})
15:48:48 <sveit> i could write a function that took a constructor C and have a generic version of the expression above (i can explain more if this is unclear)
15:48:52 <Cale> If you're passing a type constructor as a parameter, you have a dependency from the value level to the type level, which implies that 1) types exist at runtime in some form and 2) you have explicit higher order type lambdas
15:49:00 <grache28> tks for helps guys - gonna play around with what you've given me and go from there
15:49:04 <Iceland_jack> So a destructor as a parameters would do exactly what you want sveit
15:49:12 <merijn> sveit: "las [] = []; las (LA x:xs) = x : las xs; las (_:xs) = las xs"
15:49:17 <Cale> sveit: Do you perhaps mean data constructor instead of type constructor?
15:49:47 <Cale> (I think probably you do)
15:49:58 <sveit> Cale: i think I do :)
15:50:06 <Iceland_jack> Also you can basically do this using pattern synonyms and type classes
15:50:26 <merijn> Iceland_jack: With pattern synonyms you still have to write all the synonyms by hand first
15:50:36 <sveit> merijn: yeah, but i want to avoid writing a function for each type by hand :)
15:50:42 <Iceland_jack> merijn: You'll have to write them, but not first
15:50:42 <sveit> this is where i miss lisp macros.
15:50:49 <merijn> sveit: Yeah, I understand
15:50:50 <Iceland_jack> You can do that at any time
15:51:04 <merijn> sveit: Although, you could generate these functions automatically using TemplateHaskell
15:51:20 <Cale> [a | LA a <- xs]
15:51:24 <merijn> sveit: You don't need lisp macros for compile time code generation :)
15:51:27 <Cale> btw
15:51:29 <merijn> Cale: Oh, good point
15:51:42 <merijn> One redeeming quality for "fail", I guess
15:51:58 <sveit> Cale: will that code work if not all the xs have constructor LA?
15:52:06 <sveit> oh, this expands to the monad list form, i see
15:52:08 <Cale> sveit: it will work
15:52:16 <Iceland_jack> sveit: It will exactly filter those out
15:52:17 <Cale> sveit: It filters for ones which match
15:52:33 <Iceland_jack> > [ x | Just x <- [Just 1, Nothing, Just 2] ]
15:52:35 <lambdabot>  [1,2]
15:52:45 <Cale> merijn: If you write it as a list comprehension, it doesn't use 'fail'
15:52:48 <Iceland_jack> > [ "just nothing" | Nothing <- [Just 1, Nothing, Just 2] ]
15:52:50 <lambdabot>  ["just nothing"]
15:53:01 <merijn> Cale: It gets desugared to case?
15:53:05 <Cale> yeah
15:53:14 <sveit> it would be amazing to write a "function" \C xs -> [a | C a <- xs]
15:53:33 <mizu_no_oto> Can I compile an executable on OS X that I can run on Linux?
15:53:35 <Iceland_jack> sveit: Did you see my comment about a destructor?
15:53:41 <jdiez> mizu_no_oto: look into cross compiling
15:53:48 <jdiez> mizu_no_oto: but basically, it's a world of hurt
15:53:55 <merijn> mizu_no_oto: Yes, but it'll suck
15:53:56 <jdiez> you'd be better served by compiling it in a VM
15:54:00 <Iceland_jack> You can write a predicate that matches only one constructor and a destructor that extracts the 'a' out of the 'C a' in that example
15:54:06 <merijn> mizu_no_oto: Easier solution: Compile inside a VM running linux
15:54:11 <Cale> I think sveit is looking for prisms
15:54:20 <Iceland_jack> Yes I think so too
15:54:29 <merijn> Cale: Yes, I think I recommended lens earlier today :)
15:56:00 <jdiez> what's a lens good for?
15:56:24 <merijn> jdiez: Nested updates, composable traversals
15:56:36 <jdiez> merijn: those words mean very little to me
15:57:21 <merijn> jdiez: Nested updates as in "you have a datatype in a datatype in a datatype" and want to update the inner one
15:57:36 <merijn> jdiez: Without having to manually deconstruct/reconstruct all the intermediate ones
15:57:46 <Cale> jdiez: When you have deeply nested structures and you want to (immutably) update some field of one of the fields of your structure
15:57:47 <jdiez> okay, that sounds useful
15:57:53 <Cale> yeah
15:58:45 <merijn> Prisms allow you to do the same, but for datatypes where only some values can be affected, like, update all Either values with a Left constructor
16:01:51 <sveit> i'll take a look thanks!
16:03:19 <sveit> a much simpler question: if filtering and operating on a list (so that i want to use foldl/foldr), is it better to (a) use foldl' and append to the accumulator, (b) use foldl' and reverse the accumulating list at the end, (c) use foldr and accumulate the list from the end?
16:03:29 <sveit> assuming the list is finite
16:04:27 <merijn> sveit: Definitely don't append
16:04:40 <sveit> but foldr isn't tail recursive :(
16:04:48 <merijn> sveit: A better alternative to append is a builder pattern
16:04:57 <merijn> sveit: Tail recursion is overrated in haskell
16:05:13 <sveit> merijn: how do you mean?
16:05:27 <merijn> sveit: GHC haskell has no function call stack, so you don't have to be tail recursive to not leak space
16:05:46 <shachaf> @src map
16:05:47 <lambdabot> map _ []     = []
16:05:47 <lambdabot> map f (x:xs) = f x : map f xs
16:06:01 <shachaf> map is simpler. Does your same "isn't tail recursive" objection apply to map?
16:06:06 <merijn> sveit: For example, consider map, clearly not tail recursive, still O(1) space consumption
16:08:25 <merijn> sveit: Anyway, you can also use a builder pattern to build the list in the right order. That is instead of having a '[a]' list as accumulator, have '[a] -> [a]' as accumulator, then you can append by doing "old . (newVal:)" and you turn the '[a] -> [a]' into an actual list by just doing "old []"
16:15:27 <bobajett> how can I write a function to split [1,2,3, 1,2,4, 1] into monotonic sequences? foo [1,2,3, 1,2,4, 1] => [ [1,2,3], [1,2,4], [1] ]
16:15:56 <Gurkenglas_> I assume you are not interested in the obvious recursive solution?
16:16:17 <dmj`> > splitEvery 3 [1,2,3,1,2,4,1]
16:16:19 <lambdabot>  [[1,2,3],[1,2,4],[1]]
16:16:25 <bobajett> Gurkenglas: any solution would be nice, especially an obvious recursive one
16:16:47 <Gurkenglas> dmj's only works if the sequences occur every three entries.
16:16:50 <bobajett> dmj`: :-) the sequences may not be of size 3
16:17:02 <dmj`> oh
16:17:23 <Gurkenglas> foo :: Ord a => [a]->[[a]]
16:17:29 <Iceland_jack> > groupBy (<) [1,2,3,1,2,4,1]
16:17:31 <lambdabot>  [[1,2,3],[1,2,4],[1]]
16:17:36 <Gurkenglas> aww
16:17:50 <bobajett> Iceland_jack: wow. nice.
16:17:50 <Gurkenglas> You and your head library of libraries
16:20:16 <bobajett> is there a way I can see the source of groupBy within ghci's repl? :-) or do I have to go to Hackage?
16:20:23 <Gurkenglas> @src groupBy
16:20:23 <lambdabot> groupBy _  []       =  []
16:20:23 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:20:23 <lambdabot>     where (ys,zs) = span (eq x) xs
16:21:00 <bobajett> that doesn't seem to work in my ghci?
16:21:06 <Iceland_jack> It's not a GHCi command
16:21:07 <Gurkenglas> Note that these are all hardcoded, and not necessarily the exact same implementation, only an equivalent one that tries to not confuse you with all the performance-enhancing trickery
16:21:47 <Gurkenglas> You can do /query lambdabot in here and ask him those without disturbing anyone
16:22:03 <Gurkenglas> But feel free to put any particularly interesting queries into this channel so we have something to think about!
16:22:20 <bobajett> cool - and I guess that means GHCi does not have a command to view source?
16:24:50 <mizu_no_oto> merijn: looking into it a bit more, I need to make an executable aimed at linux running on an ARM processor (in particular, I'm trying to compile something for a Pi).  Is it still easier to compile on a linux VM?
16:25:14 <mizu_no_oto> Or should I preemptively give up and run away screaming?
16:25:17 <merijn> mizu_no_oto: Ah, ARM has improved recently, but it's far from easy
16:25:42 <merijn> mizu_no_oto: You could try googling and following in other people's footsteps before giving up, you might get lucky :)
16:25:55 <Gurkenglas> @src span --What does the @ mean?
16:25:56 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:26:02 <merijn> something involving ghc, arm and cross compilation
16:26:03 <Gurkenglas> @src span
16:26:03 <lambdabot> span _ xs@[]                     =  (xs, xs)
16:26:03 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
16:26:03 <lambdabot>                   | otherwise    =  ([],xs)
16:26:07 <merijn> Gurkenglas: alias
16:26:42 <merijn> Gurkenglas: Imagine you need to pattern match, for example, a list, but also want a name for the entire thing
16:27:03 <Gurkenglas> Waiiiit but if those implementations are true...
16:27:13 <merijn> "xs@(y:ys)" patten matches the list as usual to y and ys and *additionally* assigns the entire list the name xs
16:27:17 <Gurkenglas> > groupBy > [1,2,3,2,1,3,4]
16:27:18 <lambdabot>  Couldn't match expected type ‘(a0 -> a0 -> GHC.Types.Bool)
16:27:18 <lambdabot>                                -> [a0] -> [[a0]]’
16:27:18 <lambdabot>              with actual type ‘[t0]’
16:27:25 <Gurkenglas> > groupBy (<) [1,2,3,2,1,3,4]
16:27:27 <lambdabot>  [[1,2,3,2],[1,3,4]]
16:27:31 <Gurkenglas> dun dun dun
16:28:02 <bobajett> groupBy (<) [1,2,3,2,1,3,4]
16:28:15 <bobajett> > groupBy (<) [1,2,3,2,1,3,4]
16:28:16 <Gurkenglas> Prepend "> " to execute stuff in here
16:28:16 <lambdabot>  [[1,2,3,2],[1,3,4]]
16:28:33 <bobajett> hmm that doesn't seem to solve my problem then
16:28:42 <bobajett> because I want to get monotonic sequences
16:28:46 <Gurkenglas> If one looks at the span src, it compares all elements in the group against the first one, not the previous one
16:28:54 <Gurkenglas> Yes, that's why I brought that up :P
16:29:01 <bobajett> Gurkenglas: nice catch
16:29:19 <rekahsoft> i'm struggling figuring out how to use monad transformer stack from a gtk2hs callback..here is the code i haveL http://lpaste.net/104102
16:30:04 <Gurkenglas> bobajett, the simple way would of course now be to just copy the span and groupBy functions (and altering their names) and just changing the comparison to be against the previous one in the group, not the first one
16:30:30 <Gurkenglas> But the elegant way.... Iceland_jack?
16:30:51 <rekahsoft> it works but when saving the config and re-opening the settings window the changes are not loaded (though they are saved to file and are loaded properly when the program is restarted)
16:31:03 <bobajett> Gurkenglas: cool, I'll try that out ... while waiting for Iceland_jack's elegant solution :-)
16:31:41 <Gurkenglas> (I would guess something like turning each element of the list into its difference from the previous one, then grouping everything by >=0, then turning everything back to the original values)
16:32:08 <rekahsoft> the issue it seems is that the state is not threaded through the application properly..specifically how can modify the state of App in a gtk2hs callback
16:33:15 <quickezed> The following is my first attempt at creating a function which doubles every second integer in a list starting from the end.
16:33:17 <quickezed> http://lpaste.net/104103
16:33:59 <quickezed> I feel there is probably a nicer way to do this and am wondering if anyone can provide some pointers.
16:35:07 <Gurkenglas> @let derive :: Num a => [a]->[a]
16:35:07 <bobajett> quickezed: so basically it should *not* double the last element, but every other one?
16:35:08 <lambdabot>  .L.hs:142:1:
16:35:08 <lambdabot>      The type signature for ‘derive’ lacks an accompanying binding
16:35:16 <quickezed> bobajett: correct.
16:35:18 <Gurkenglas> (How do I do that correctly?)
16:36:14 <pavonia> rekahsoft: You probably have to use IORefs/MVars for storing the App
16:36:17 <quickezed> bobajett: I've only learnt about pattern matching, guards, list comprehension etc so my code in that paste hasn't stepped outside of those concepts. I'm just interested to improve it and make it more idiomatic.
16:37:05 <bobajett> quickezed: I was only clarifiying the original question - I only know as much as you do :-)
16:37:07 <rekahsoft> pavonia: alright..can you explain why this is?
16:37:18 <Gurkenglas> @let derive l = map (uncurry (-)) (zip (l ++ [0]) (0:l))
16:37:20 <lambdabot>  Defined.
16:37:20 <rekahsoft> pavonia: also thanks for the hand :)
16:37:33 <Gurkenglas> > derive [1,2,3,2,1,3,4]
16:37:37 <lambdabot>  [1,1,1,-1,-1,2,1,-4]
16:38:13 <quickezed> bobajett: Hehe ok not a problem. Basically [1, 2, 3, 4] -> [2, 3, 6, 4] and [1, 2, 3, 4, 5] -> [1, 4, 3, 8, 5].
16:38:27 <pavonia> rekahsoft: You program ist to complex for me to understand reight now, but I guess the problem is you can't access the Reader/State from within the GUI handlers (because they are plain IO)
16:38:35 <quickezed> Oops: [1, 2, 3, 4] -> [2, 2, 6, 4]
16:39:06 <rekahsoft> pavonia: exactly right..i've been racking my brain trying to figure a way around it
16:39:58 <quickezed> The part I find hard is figuring out how to skip over elements in the list.
16:40:22 <Gurkenglas> :t (flip const) . (>=0)
16:40:23 <lambdabot> (Ord a, Num a) => a -> c -> c
16:41:18 <rekahsoft> pavonia: i think i found something on stackoverflow that will take me the rest of the way (http://stackoverflow.com/questions/12002814/how-to-deal-with-application-state-in-gtk2hs). Thanks for a pointer in the right direction :)
16:41:23 <Gurkenglas> > groupBy ((flip const) . (>=0)) (derive [1,2,3,2,1,3,4])
16:41:25 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
16:41:25 <lambdabot>    arising from the literal ‘0’
16:45:48 <Gurkenglas> @hoogle (a->Bool)->[a]->[[a]]
16:45:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:45:49 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
16:45:49 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
16:51:07 <pjdelport> quickezed: mapAccumR (from Data.List) does a reasonable job at capturing that recursion pattern
16:51:32 <quickezed> pjdelport: Ok thanks. I'll take a look.
16:51:50 <benzrf> hey
16:51:50 <pjdelport> It's a combination of map and a fold, letting you pass an accumulator along the map; in this case, the accumulator can be a boolean flag you keep toggling, like:
16:52:02 <benzrf> im reading http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf and can anybody help me with something im a bit confused about
16:52:10 <pjdelport> > mapAccumR (\t x -> (not t, if t then x*2 else x)) False [1..5]
16:52:11 <lambdabot>  (True,[1,4,3,8,5])
16:53:12 <quickezed> pjdelport: I see, that definitely looks like a nice function to be aware of. Thanks!
16:53:18 <pjdelport> quickezed: That inner function takes two parameters, the current flag and list element, and returns a tuple of the next flag, and the transformed list value.
16:53:28 <pjdelport> and the False is the initial flag
16:53:54 <pjdelport> quickezed: mapAccumR works from the end of the list; mapAccumL would be the same, but working from the start
16:54:12 <quickezed> pjdelport: awesome, makes perfect sense.
16:54:20 <pjdelport> quickezed: Oh, and the result is the final flag value, along with the resulting list
16:54:34 <pjdelport> quickezed: so if you don't want the final flag, you can just compose it with snd
16:54:51 <pjdelport> (but you can use the final flag to tell if the list was even or odd in length, if you are interested in that)
16:55:09 <quickezed> pjdelport: Ok cool. Hehe, I'll have to look into snd. I haven't come across that yet.
16:55:24 <pjdelport> > snd (2, 3)
16:55:25 <lambdabot>  3
16:55:34 <pjdelport> it just returns the second item of a tuple :)
16:55:40 <quickezed> second, of course :)
16:55:42 <pjdelport> > fst (2, 3)
16:55:43 <lambdabot>  2
16:55:53 <bobajett> quickezed: here is my crack at it - it's not any more elegant, possibly even inelegant:
16:55:59 <Gurkenglas> Of a pair, right? Not tuple
16:56:06 <pjdelport> Gurkenglas: right, right
16:56:34 <benzrf> > _3
16:56:36 <pjdelport> Gurkenglas: "tuples of sufficiently even length" :P
16:56:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
16:56:36 <lambdabot>    arising from a use of ‘M8258701299859725241417.show_M8258701299859725241417’
16:56:36 <lambdabot>  The type variable ‘b0’ is ambiguous
16:56:36 <lambdabot>  Note: there are several potential instances:
16:56:36 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:56:36 <benzrf> hmm
16:56:45 * hackagebot foldl 1.0.4 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.4 (GabrielGonzalez)
16:56:46 <benzrf> > view _3 (1, 2
16:56:48 <lambdabot>  <hint>:1:14:
16:56:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:56:49 <benzrf> > view _3 (1, 2)
16:56:50 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field3 (t0, t1) (t0, t1) a a)
16:56:50 <lambdabot>    arising from the ambiguity check for ‘e_1312’
16:56:50 <lambdabot>  from the context (Control.Lens.Tuple.Field3 (t, t2) (t, t2) a a,
16:56:50 <lambdabot>                    GHC.Num.Num t2,
16:56:52 <lambdabot>                    GHC.Num.Num t)
16:56:53 <benzrf> o:
16:56:56 <benzrf> neat.
16:57:15 <bobajett> quickezed: http://lpaste.net/104104
16:58:29 <pjdelport> quickezed: There are a few other patterns you could look at, too. One that comes to mind, if you want to work generically, is to first map the list to a list of Either, and then to separately map (either id (*2)) to it
16:58:49 <pjdelport> quickezed: That lets you separate the decision of which elements to operate on from the actual operation.
16:59:01 <quickezed> bobajett: Cool, thanks for giving it a shot. Yours looks a lot more simple than mine. I like :)
16:59:40 <quickezed> pjdelport: Interesting. I'll need to go and read about Either :)
17:00:39 <quickezed> pjdelport: A quick check on Hoogle and Either looks to be quite self explanatory haha.
17:00:50 <pjdelport> > map (either id (*2)) [Left 5, Right 5, Left 10, Right 10, Left 20]
17:00:52 <lambdabot>  [5,10,10,20,20]
17:02:33 <quickezed> pjdelport: I've gotta run. Thanks a lot for your help.
17:02:45 <quickezed> bobajett: Thanks again for posting a solution, much appreciated.
17:02:55 <pjdelport> quickezed: Cool!
17:03:16 <bobajett> quickezed: sure, though I don't like that double reverse - not a very performant solution imho
17:04:13 <pjdelport> sometimes that's not such a bad way to approach things; working from the end of a list is often inconvenient
17:05:28 <Gurkenglas> Ooh I think Ive got something
17:05:47 <Gurkenglas> > intersperse 1 (repeat 2)
17:05:48 <lambdabot>  [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
17:06:37 <Gurkenglas> > \l->map (uncurry (*)) (zip (intersperse 2 (repeat 1)) l)
17:06:38 <lambdabot>  <[Integer] -> [Integer]>
17:07:02 <jle`> > cycle [2,1] -- Gurkenglas ?
17:07:04 <lambdabot>  [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
17:07:09 <Gurkenglas> Yes, that too
17:07:46 <Gurkenglas> > map (uncurry (*)) (zip (cycle [1,2]) [5,10,10,20,20])
17:07:48 <lambdabot>  [5,20,10,40,20]
17:07:52 <Gurkenglas> :)
17:08:13 <Gurkenglas> (quickezed)
17:08:40 <pjdelport> Gurkenglas: That's anchored at the start, not the end.
17:08:47 <benzrf> does lambdabot have a show instance for typeable stuff
17:08:56 <Gurkenglas> zipWith (*) (cycle [1, 2]), even.
17:09:04 <benzrf> *functions over typeable stuff
17:09:07 <c_wraith> > print "hello"
17:09:08 <lambdabot>  <IO ()>
17:09:15 <c_wraith> It has at least a limited instance!
17:09:20 <c_wraith> Oh, functions
17:09:27 <Gurkenglas> Well then...
17:09:33 <benzrf> hm
17:09:43 <jle`> > (*) <$> ZipList (cycle [1,2]) <*> ZipList [5,10,10,20,20]
17:09:44 <c_wraith> > (+)
17:09:44 <benzrf> @let data Unshowable = Unshowable
17:09:45 <lambdabot>  ZipList {getZipList = [5,20,10,40,20]}
17:09:46 <lambdabot>  <Integer -> Integer -> Integer>
17:09:47 <lambdabot>  Defined.
17:09:48 <Gurkenglas> Look at the length of the input list and make it cycle  [2,1] if needed
17:09:51 <c_wraith> benzrf: there you go
17:09:52 <benzrf> > Unshowable
17:09:53 <lambdabot>  No instance for (GHC.Show.Show L.Unshowable)
17:09:53 <lambdabot>    arising from a use of ‘M2735119040860043239853.show_M2735119040860043239853’
17:09:57 <benzrf> aha
17:10:14 <pjdelport> jle`: surely not! the whole point of applicative is being applicative
17:10:30 <pjdelport> > ZipList (cycle [id,(*2)]) <*> ZipList [5,10,10,20,20]
17:10:31 <lambdabot>  ZipList {getZipList = [5,20,10,40,20]}
17:10:39 <jle`> pjdelport: :)
17:10:57 <benzrf> why not
17:11:14 <benzrf> > zipWith ($) (cycle [id,(*2)]) [5, 10, 10, 20, 20]
17:11:15 <lambdabot>  [5,20,10,40,20]
17:11:18 <benzrf> :-)
17:12:18 <Gurkenglas> Yep, that's cooler than zipWith (*).
17:12:26 <jle`> > uncurry id (zip (cycle [id,(*2)]) [5,10,10,20,20])
17:12:28 <lambdabot>  Couldn't match expected type ‘(b0 -> c, b0)’
17:12:28 <lambdabot>              with actual type ‘[(a0 -> a0, b1)]’
17:12:55 <jle`> darn
17:12:58 <benzrf> :t uncurry id
17:12:59 <lambdabot> (b -> c, b) -> c
17:13:01 <benzrf> o:
17:13:15 <jle`> > uncurry id ((*2), 3)
17:13:16 <lambdabot>  6
17:13:18 <jle`> it's a cheap trick
17:13:21 <benzrf> yeah
17:13:26 <pjdelport> > uncurry id <$> (zip (cycle [id,(*2)]) [5,10,10,20,20])
17:13:27 <lambdabot>  [5,20,10,40,20]
17:13:44 <pjdelport> (or, how to abuse every possible abstraction at once)
17:13:45 <jle`> ah yes :)
17:13:45 <benzrf> :t uncurry
17:13:46 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:13:48 <jle`> parentheses unecessary
17:13:57 <jle`> benzrf: think of it as uncurry ($)
17:14:02 <benzrf> i know how it works
17:14:02 <benzrf> :P
17:14:13 <jle`> ^.^
17:14:28 <benzrf> :t id `asTypeOf` undefined :: (a -> b -> c)
17:14:29 <lambdabot>     Couldn't match type ‘a1’ with ‘b1 -> c1’
17:14:29 <lambdabot>       ‘a1’ is a rigid type variable bound by
17:14:29 <lambdabot>            an expression type signature: a1 -> b1 -> c1 at <interactive>:1:1
17:14:32 <benzrf> :t id `asTypeOf` (undefined :: (a -> b -> c))
17:14:33 <lambdabot> (b -> c) -> b -> c
17:14:46 <benzrf> :-)
17:15:04 <jle`> :t id `asAppliedTo` (undefined :: (a -> b))
17:15:05 <lambdabot> (a -> b) -> a -> b
17:15:12 <benzrf> precisely
17:15:20 <jle`> :t ($)
17:15:21 <lambdabot> (a -> b) -> a -> b
17:15:23 <Gurkenglas> :t asAppliedTo
17:15:23 <lambdabot> (a -> b) -> a -> a -> b
17:15:32 <benzrf> Gurkenglas: it's just ConstantineXVI
17:15:34 <jle`> @src asAppliedTo
17:15:34 <lambdabot> Source not found. There are some things that I just don't know.
17:15:36 <benzrf> but with a specific type sig
17:15:39 <benzrf> for type hax
17:15:42 <benzrf> *just const
17:15:50 <jle`> :t (>>=) `asAppliedTo` []
17:15:51 <lambdabot> [a] -> (a -> [b]) -> [b]
17:15:54 <Gurkenglas> Which parameter is ignored?
17:15:55 <jle`> :t concatMap
17:15:56 <lambdabot> (a -> [b]) -> [a] -> [b]
17:15:58 <benzrf> Gurkenglas: the second one
17:16:07 <jle`> :t flip concatMap
17:16:08 <lambdabot> [a] -> (a -> [b]) -> [b]
17:16:20 <Gurkenglas> Which interpretation of second? :P
17:16:20 <benzrf> Gurkenglas: but in order to match the type sig, it has to turn the polymorphic function first arg into a concrete version
17:16:37 <dmwit> Under what circumstances does GHC infer the type Any?
17:16:39 <jle`> hm. why isn't zip used infix more often
17:16:39 <benzrf> allowing you to fill in things like bind on lists, as jle` demonstrated
17:16:45 <Gurkenglas> I know none of those words
17:16:47 <jle`> > [1,2,3] `zip` [4,5,6]
17:16:48 <lambdabot>  [(1,4),(2,5),(3,6)]
17:17:07 <dmwit> Never mind. I'll come back when I have a well-phrased question.
17:17:07 <Gurkenglas> Oh wait all of them except polymorphic and concrete
17:17:10 <jle`> if only you can ``-ize expressions
17:17:17 <jle`> then you can do [1,2,3] `zipWith (*)` [4,5,6]
17:17:51 <jle`> this changes everything
17:18:15 <c_wraith> jle`: it introduces difficulty parsing, though
17:18:30 <Gurkenglas> Only if you get recursive 's
17:18:32 <pjdelport> jle`: It would arguably be more readable in almost all cases to go let foo = zipWith (*) in [1,2,3] `foo` [4,5,6]
17:18:32 <dmwit> `(zipWith (*))`
17:18:33 <Gurkenglas> rite?
17:18:44 <pjdelport> (or the equivalent where syntax)
17:18:55 <pjdelport> readability counts!
17:18:59 <benzrf> just replace `` with $()
17:19:03 <benzrf> it worked for shells!
17:19:06 <jle`> heh
17:19:14 <benzrf> [1, 2, 3] $(zip) [4, 5, 6]
17:19:32 <Gurkenglas> > [1, 2, 3] $(zip) [4, 5, 6]
17:19:33 <lambdabot>  Couldn't match expected type ‘([b0] -> [(a0, b0)]) -> t’
17:19:33 <lambdabot>              with actual type ‘[t0]’
17:19:36 <jle`> someone submit a pull request
17:19:58 <jle`> {-# LANGUAGE Bash #-}
17:20:14 <benzrf> :-O
17:23:36 <pjdelport> > let ($) = flip id in [1, 2, 3] $(zip) [4, 5, 6]
17:23:38 <lambdabot>  [(4,1),(5,2),(6,3)]
17:23:43 <pjdelport> \:D/
17:23:49 <jle`> :D
17:23:58 <benzrf> :OOOOOO
17:24:05 <jle`> > let (#) = flip id in [1,2,3] $(zipWith (*)) [4,5,6]
17:24:06 <lambdabot>  <hint>:1:7: parse error on input ‘)’
17:24:10 <jle`> > let (#) = flip id in [1,2,3] #(zipWith (*)) [4,5,6]
17:24:11 <lambdabot>  <hint>:1:7: parse error on input ‘)’
17:24:13 * werdna waves
17:24:15 <bobajett> > zipWith (\x i -> if even i then 2 * x else x) [1..] (reverse [1,2,3,4])
17:24:16 <pjdelport> (I'm not sure when this became obfuscated Haskell hour... this should probably not be encouraged)
17:24:16 <lambdabot>  [2,2,6,4]
17:24:30 <jle`> > let ($) = flip id in [1,2,3] $(zipWith (*)) [4,5,6]
17:24:31 <lambdabot>  [4,10,18]
17:24:32 <werdna> I'm trying to learn how to read these type failure error messages
17:24:38 <jle`> werdna: hi werdna :)
17:24:38 <benzrf> > let (#) = flip id in [1,2,3] #(zipWith (*)) [4,5,6]
17:24:40 <lambdabot>  <hint>:1:7: parse error on input ‘)’
17:24:42 <benzrf> >:(
17:24:46 <benzrf> > let (#) = flip id in [1,2,3] # (zipWith (*)) [4,5,6]
17:24:47 <lambdabot>  <hint>:1:7: parse error on input ‘)’
17:24:49 <jle`> that's weird
17:24:50 <benzrf> :{
17:24:52 <jle`> it works with the ($)
17:25:00 <jle`> is # stolen by syntax or something?
17:25:02 <benzrf> > let ($) = flip id in [1,2,3] $(zipWith (*)) [4,5,6]
17:25:03 <lambdabot>  [4,10,18]
17:25:05 <benzrf> o_o
17:25:23 <jle`> hm
17:25:27 <benzrf> > 1 # 2
17:25:28 <lambdabot>  Could not deduce (GHC.Num.Num
17:25:28 <lambdabot>                      (Control.Lens.Review.AReview s0 t a0 b0))
17:25:28 <lambdabot>    arising from the ambiguity check for ‘e_112’
17:25:28 <lambdabot>  from the context (GHC.Num.Num
17:25:28 <lambdabot>                      (Control.Lens.Review.AReview s t a b),
17:25:29 <Gurkenglas> :t flip id
17:25:30 <benzrf> > 1 #2
17:25:30 <lambdabot> b -> (b -> c) -> c
17:25:32 <lambdabot>  Could not deduce (GHC.Num.Num
17:25:34 <lambdabot>                      (Control.Lens.Review.AReview s0 t a0 b0))
17:25:35 <jle`> > [1,2,3] &(zipWith (*)) [4,5,6]
17:25:36 <lambdabot>    arising from the ambiguity check for ‘e_112’
17:25:38 <lambdabot>  from the context (GHC.Num.Num
17:25:40 <lambdabot>  [4,10,18]
17:25:42 <lambdabot>                      (Control.Lens.Review.AReview s t a b),
17:25:43 <jle`> woo hoo
17:25:45 <jle`> thank you lens
17:25:45 <benzrf> :O
17:25:50 <benzrf> woot woot
17:25:52 <Gurkenglas> :t (flip id)(zip)
17:25:53 <lambdabot> (([a] -> [b] -> [(a, b)]) -> c) -> c
17:26:00 <Gurkenglas> No weeeei
17:26:01 <werdna> could someone explain to me what's going on here? http://p.defau.lt/?wk9kE6Ra8cuBEC1zb_K5AQ << I assume it is trying to match (m + (n1 * m) to 'S (n1 + m) assuming n matches S n1
17:26:04 <jle`> > [1,2,3] &(zipWith (+)) [10,11,12]
17:26:05 <lambdabot>  [11,13,15]
17:26:06 <benzrf> > 10 &mod 3
17:26:08 <lambdabot>  3
17:26:09 <werdna> is that accurate?
17:26:10 <benzrf> sweet
17:26:10 <jle`> lens is useful after all
17:26:12 <benzrf> hammi:
17:26:13 <benzrf> *ha
17:26:17 <dmwit> That is not doing what you think it is.
17:26:23 <dmwit> The wrong thing is the first argument.
17:26:26 <benzrf> oh right it is
17:26:29 <benzrf> :(
17:26:43 <benzrf> :t (&)
17:26:44 <lambdabot> a -> (a -> b) -> b
17:26:45 <benzrf> :t flip id
17:26:46 <lambdabot> b -> (b -> c) -> c
17:27:18 <Maior> :t &mod
17:27:19 <lambdabot> parse error on input ‘&’
17:27:23 <benzrf> :t (& mod)
17:27:24 <lambdabot> Integral a => a -> a -> a
17:27:25 <Maior> :t (&mod*
17:27:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:27:31 <Maior> ugh keyboard
17:27:42 <Maior> :t (&)
17:27:43 <lambdabot> a -> (a -> b) -> b
17:27:45 <jle`> finally, a good use for lens
17:28:14 <benzrf> no, the operator needs to take a partially-applied function, then pull out an argument
17:28:16 <benzrf> or something
17:28:19 <benzrf> :(
17:28:33 <jmcarthur> :t ($)&($)
17:28:34 <lambdabot> (a -> b) -> a -> b
17:28:45 <jle`> > (cycle [id, (*2)]) &(zipWith ($)) [5,10,10,20,20]
17:28:47 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> c))
17:28:47 <lambdabot>    arising from the ambiguity check for ‘e_12510102020’
17:28:47 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> c), GHC.Num.Num a)
17:28:47 <lambdabot>    bound by the inferred type for ‘e_12510102020’:
17:28:47 <lambdabot>               (GHC.Num.Num ((a -> a) -> c), GHC.Num.Num a) => [c]
17:28:59 <jle`> darn
17:29:31 <jle`> :t (&(zipWith ($)))
17:29:32 <lambdabot> [b -> c] -> [b] -> [c]
17:30:15 <jle`> > [id,(*2)] &(zipWith ($)) [5,10]
17:30:16 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> c))
17:30:16 <lambdabot>    arising from the ambiguity check for ‘e_12510’
17:30:16 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> c), GHC.Num.Num a)
17:30:16 <lambdabot>    bound by the inferred type for ‘e_12510’:
17:30:16 <lambdabot>               (GHC.Num.Num ((a -> a) -> c), GHC.Num.Num a) => [c]
17:30:54 <benzrf> precedence is wrong ;-;
17:31:01 <benzrf> foo &bar baz
17:31:03 <benzrf> will be
17:31:07 <benzrf> foo & (bar baz)
17:31:14 <benzrf> at which point it is too late to flip the arguments
17:31:16 <benzrf> u_u
17:31:22 <jle`> > [5,10] &(zipWith ($)) [id,(*2)]
17:31:24 <lambdabot>  [5,20]
17:31:27 <jle`> hm
17:32:02 <jle`> > (cycle [id,(*2)]) &(zipWith (&)) [5,10,10,20,20]
17:32:04 <lambdabot>  [5,20,10,40,20]
17:32:27 <jle`> woo hoo
17:37:30 <bobajett> what does the "&"(zipWith... do?
17:38:54 <copumpkin> :t (&)
17:38:54 <benzrf> hmm
17:38:55 <lambdabot> a -> (a -> b) -> b
17:38:59 <copumpkin> it's just flipped application
17:39:06 <jle`> it's flip (&)
17:39:07 <benzrf> why does deriving allow no parens for a single __class__
17:39:07 <jle`> er
17:39:09 <benzrf> *class
17:39:09 <jle`> flip ($)
17:39:20 <benzrf> but import requires them for a single import?
17:39:59 <sveit> is there a way to say 'n' maps in haskell? i.e. express map . map . map ... without writing it that way?
17:40:10 <sveit> it doesn't seem like iterate will do the job in general
17:40:21 <jle`> sveit: no, because what would the type signature be?
17:40:30 <jle`> nMaps :: Int -> ?
17:41:06 <sveit> jle`: that was my confusion, but i can write the type signature for an individual sequence
17:41:14 <sveit> jle`: rather algorithmically too
17:41:17 <erisco> nMaps :: Int -> Dynamic
17:41:46 <grache28> hi - what's tails?
17:41:49 <grache28> > tails
17:41:50 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
17:41:51 <lambdabot>    arising from a use of ‘M77736028906868039301998.show_M77736028906868039301...
17:41:51 <lambdabot>  The type variable ‘a0’ is ambiguous
17:41:51 <lambdabot>  Note: there are several potential instances:
17:41:51 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
17:41:58 <erisco> grache28, all suffixes
17:42:02 <jle`> sveit: if n is 0, it's Int -> (a -> a); if n is 1, it's Int -> ([a] -> [a]), if n is 2, it's Int -> ([[a]] -> [[a]]), if n is 3, it's Int -> ([[[a]]] -> [[[a]]]), etc.
17:42:02 <erisco> > tails "hello world"
17:42:03 <lambdabot>  ["hello world","ello world","llo world","lo world","o world"," world","world...
17:42:41 <jle`> sveit: so the type of the function depends on the value passed on
17:42:43 <grache28> erisco: ah - where does it come from? i'm using hugs - it doesn't seem to be in the lib it comes with
17:42:49 <dmwit> Okay, I'm back, with a better question.
17:42:53 <dmwit> http://lpaste.net/104107
17:43:11 <erisco> grache28, probably Data.List though you can check Hoogle
17:43:35 <grache28> tks erisco
17:43:44 <dmwit> Who can explain what the heck is going on in GHC's brain that makes it think about types escaping?
17:44:20 <sveit> jle`: i agree, that's why i was asking. i just don't like typing extra :)
17:44:33 <erisco> > undefined :: a
17:44:34 <lambdabot>  *Exception: Prelude.undefined
17:44:45 <jle`> sveit: i think this is a problem that dependent typing tries to solve
17:45:06 <erisco> > let foo = undefined; bar = (foo :: a) in bar
17:45:07 <lambdabot>  *Exception: Prelude.undefined
17:45:15 <copumpkin> dmwit: does it fail if you annotate the types of bar and baz?
17:45:16 <erisco> dmwit, no idea :D
17:45:37 <jle`> sveit: you can make it work in haskell with some typeclass hackery
17:45:52 <jle`> class Flattenable a where ...
17:45:54 <dmwit> copumpkin: Either annotation will make it work.
17:46:03 <copumpkin> hrm!
17:46:09 <copumpkin> so if you take away the offending foo definition
17:46:12 <copumpkin> what does it infer those types to be?
17:46:25 <dmwit> bar :: Any
17:46:29 <copumpkin> !
17:46:32 <dmwit> baz :: b -> [Integer]
17:46:35 <dmwit> yeah, what
17:46:49 <copumpkin> Any is weird in that it's polymorphic, riht?
17:46:57 <copumpkin> that might be the culprit
17:47:09 <dmwit> Any is really weird, yeah. I won't pretend I understand how Any works.
17:47:16 <copumpkin> so if you annotate bar to have type Any
17:47:22 <copumpkin> does it complain in the same way?
17:47:22 <dmwit> ooo, fun question
17:47:43 <copumpkin> I'll be really puzzled if it doesn't :)
17:47:52 <dmwit> well, not quite the same way
17:47:55 <erisco> oh this only happens with type families?
17:47:56 <dmwit> I'll post the updated code/error.
17:48:32 <jle`> dmwit: now that's an error
17:48:45 <dmwit> copumpkin: annotated
17:48:54 <copumpkin> hrm
17:48:57 <copumpkin> that's what I'd expect
17:49:08 <copumpkin> it might be a weird sort of any that's inferred, that you can't write
17:49:13 <copumpkin> goldfire: ^
17:49:24 <copumpkin> oh, idle for 6 days
17:50:10 <dmwit> goldfire = Richard?
17:50:44 <erisco> dmwit, even more curious why the existence of the unused 'where' variable matters
17:51:22 <copumpkin> dmwit: I thought so :)
17:51:41 <dmwit> erisco: I suspect something to do with wrapping up an inferred-ambiguous type variable.
17:51:46 <jle`> dmwit: would you mind if i used that paste to show friends
17:51:48 <dmwit> copumpkin: Okay. I'll just walk over to his desk tomorrow, then. =P
17:52:01 <copumpkin> dmwit: pfft
17:52:11 <dmwit> jle`: Dunno what the appropriate incantation is. "I release this into the public domain."?
17:52:22 <werdna> Hi, I'm getting a "Context reduction stack overflow; size = 201". I guessed from googling that there is an infinite loop occurring somewhere. What sort of loop am I looking for in my code?
17:52:24 <erisco> and so it was done.
17:53:06 <copumpkin> werdna: disable UndecidableInstances? :)
17:53:19 <dmwit> werdna: A loop when searching for class-instance evidence.
17:53:34 <werdna> copumpkin: ;-)
17:53:38 <dmwit> werdna: e.g. we want a certain instance, then we look hope the context for that instance is satisfiable.
17:53:48 <dmwit> werdna: That's one level of context reduction stack.
17:53:51 <dmwit> ...roughly
17:53:57 <werdna> nod
17:54:00 <werdna>       ('S n * m) ~ uf0
17:54:03 <werdna> so what's the uf0?
17:54:08 <dmwit> type variable
17:54:16 <dmwit> like "a", "t", "foo"
17:54:18 <werdna> I don't have a uf0 type variable though
17:54:27 <grache28> err - how do I load two modules? like my own module & Data.List?
17:54:36 <dmwit> generated fresh by the compiler while trying to unify something, then, probably
17:55:05 <werdna> nod, I have an idea what it is anyway
17:55:15 <werdna> this part is helpful:     In the expression: appendV x (concatV xs)
17:55:57 <benzrf> grache28: are you loading Data.List with :l?
17:56:16 <grache28> benzrf: yes
17:56:36 <dmwit> grache28: Load your module, then :m + Data.List
17:56:44 <dmwit> or import Data.List with sufficiently new GHCs
17:56:54 <Focalise_>  /msg NickServ VERIFY REGISTER Focalise_ ilohmbdngdng
17:57:01 <benzrf> grache28: import Data.List
17:57:06 <dmwit> Focalise_: ...you should probably change that password
17:57:10 <jle`> might want to change your password, Focalise_
17:57:16 <jle`> unless that was a red herring
17:57:18 <benzrf> grache28: :l should only be used with individual source files
17:57:22 <grache28> I have to use hugs :/ no admin rights on this comp to install GHCI
17:57:22 <jle`> to throw off nsa spies in #haskell
17:57:26 <grache28> :/
17:57:34 <benzrf> grache28: wow that sux
17:57:36 <pjdelport> grache28: ":m +" and ":m -" add or remove modules from the current set; just :m alone effectively replaces it.
17:57:36 <benzrf> grache28: what OS
17:57:38 <Focalise_> I work at NSA
17:57:43 <Focalise_> trying to catch hackers
17:57:47 <jle`> :O
17:57:56 <Focalise_> heard there were hackers in here
17:58:01 <jle`> well your cover isn't too well maintained
17:58:01 <grache28> Main> :m + Data.List
17:58:02 <grache28> ERROR - Cannot find module "+"
17:58:05 <erisco> dmwit, here are a couple alterations http://lpaste.net/104109
17:58:08 <benzrf> grache28: use import
17:59:01 <grache28> benzrf: :import isn't a command  - or do you mean in my module? - os is linux
17:59:06 <erisco> this has to be a bug right?
17:59:17 <Maior> grache28: import, not :import
17:59:39 <grache28> Main> import Data.List            ERROR - Syntax error in expression (unexpected keyword "import")
17:59:54 <dmwit> erisco: "has to be" is so strong
18:00:04 <erisco> this should be a bug, right?
18:00:14 <pjdelport> grache28: that was added in a newer version of ghci
18:00:29 <benzrf> oh lame
18:00:36 <benzrf> grache28: can you do a local source compile thing
18:00:41 <benzrf> or a local binary, even
18:00:57 <dmwit> erisco: I've failed to find bugs often enough before that I'm wary to call it a bug before a GHC hacker does. =)
18:01:50 <dmwit> grache28: Probably the quickest thing is for the module you're loading to import Data.List.
18:02:01 <dmwit> grache28: That should put all the Data.List stuff in scope... I think.
18:02:05 <dmwit> Been a long time since I've used hugs.
18:02:06 <grache28> benzrf: i have to use hugs ;/
18:02:17 <grache28> k dmwit tks
18:02:21 <benzrf> grache28: cant u do a user install of ghc
18:02:27 <benzrf> like, not a system install
18:02:28 <erisco> if you need tails grache28 just rewrite it
18:02:30 <benzrf> or is that not a thing
18:02:53 <grache28> that did it dwcook
18:02:57 <jle`> @src tails
18:02:57 <lambdabot> tails []         = [[]]
18:02:57 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:02:58 <grache28> er dmwit
18:03:43 <XrXr> I just homemade a shuffle function with recursion. That was fun. One of the things I thought I would never have to do. :) Thanks Haskell
18:03:55 <grache28> ok tks all
18:04:25 <jle`> XrXr: :)
18:04:33 <davean> XrXr: Why did you "have" to? There are good shuffle functions in some of the random libs
18:04:56 <__jim__> So, just a general question (probably historical), why is Haskell notation for types (::) and cons (:) 'flipped' from other functional languages like ML?
18:05:15 <jle`> *insert obligatory psa that explicit recursion is generally discouraged and higher order functions are more preferred)
18:05:21 <XrXr> I didn't have to, but I thought I'd do it to practice. XD (also I don't know how to use cabal)
18:05:24 <carter> mmmm: you should hang on #numerical-haskell more :)
18:05:36 <carter> @ask mmmm  you should hang on #numerical-haskell more :)
18:05:36 <lambdabot> Consider it noted.
18:06:53 * hackagebot either 4.1.2 - An either monad transformer  http://hackage.haskell.org/package/either-4.1.2 (EdwardKmett)
18:07:41 <erisco> > let tails = takeWhile (not . null) . iterate (snd . splitAt 1) in tails [1..10]
18:07:43 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
18:07:51 <erisco> jle`, fixed :D
18:09:50 <dmwit> snd . splitAt 1 is a funny spelling of drop 1
18:10:21 <dmwit> > takeWhile (not . null) . iterate tail $ [1..3]
18:10:23 <lambdabot>  [[1,2,3],[2,3],[3]]
18:10:33 <dmwit> Also, it doesn't work right. =)
18:10:49 <erisco> oh missing the empty list
18:11:05 <pjdelport> __jim__: According to the History of Haskell paper, "We adopted from Miranda the convention that data constructors are capitalised while variables are not, and added a similar convention for inﬁx constructors, which in Haskell must start with a colon."
18:11:09 <dmwit> > until null . iterate tail $ [1..3]
18:11:11 <lambdabot>  Couldn't match type ‘[[a0]]’ with ‘[a] -> [a]’
18:11:11 <lambdabot>  Expected type: [a0] -> [a] -> [a]
18:11:11 <lambdabot>    Actual type: [a0] -> [[a0]]
18:11:13 <dmwit> :t until
18:11:14 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
18:11:16 <erisco> dmwit, I was just prepping for the skip-n version of tails... yeah... :)
18:11:17 <pjdelport> "The latter convention was chosen for consistency with our use (adopted from SASL, KRC, and Miranda) of a single colon : for the list “cons” operator. (The choice of “:” for cons and “::” for type signatures, by the way, was a hotly contested issue (ML does the opposite) and remains controversial to this day.)"
18:11:22 <dmwit> Oh, not quite.
18:12:05 <benzrf>           
18:12:07 <knrafto> > let tails = ufoldr (\xs -> if null xs then Nothing else Just (tail xs, tail xs) in tails [1..5]
18:12:08 <lambdabot>  <hint>:1:81: parse error on input ‘in’
18:12:11 <jle`> @check (==) <$> takeWhile (not . null) . iterate (snd . splitAt 1) <*> tails
18:12:11 <lambdabot>  : -1: -1:Ambiguous infix expression
18:12:31 <bobajett> ok I've finally got my groupBy-Into-Monotonic-Sequences function:
18:12:32 <knrafto> > let tails = unfoldr (\xs -> if null xs then Nothing else Just (tail xs, tail xs)) in tails [1..5]
18:12:33 <lambdabot>  [[2,3,4,5],[3,4,5],[4,5],[5],[]]
18:12:38 <jle`> @check (==) <$> (takeWhile (not . null) . iterate (snd . splitAt 1)) <*> tails
18:12:39 <knrafto> dang
18:12:40 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:12:41 <lambdabot>  []
18:12:44 <erisco> knrafto, close :D
18:13:14 <jle`> @check (==) <$> (reverse . unfoldr (\xs -> if null xs then Nothing else Just (tail xs, tail xs))) <*> tails
18:13:15 <benzrf> :t unfoldr
18:13:16 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:13:16 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:13:17 <lambdabot>  []
18:13:39 <dmwit> > let tails [] = [[]]; tails xs = xs : tails (tail xs) in tails [1..3]
18:13:41 <lambdabot>  [[1,2,3],[2,3],[3],[]]
18:13:47 <dmwit> Recursion really seems fine here.
18:13:55 <lahwran> whoa, what is @check?
18:14:00 <jle`> quickcheck
18:14:03 <lahwran> oh
18:14:19 <lahwran> that's not quite as impressive, then. heh
18:14:26 <jle`> heh >_>
18:14:37 <lahwran> I thought it might be a prover >.>
18:14:46 <jle`> alas
18:14:58 <dmwit> We have those, too.
18:15:14 <dmwit> SmallCheck acts as a prover for small finite types; SBV can do things even for infinite types.
18:15:27 <lahwran> cool
18:15:40 <dmwit> (Here "finite" and "infinite" are referring to the inhabitant count, not the usual meaning.)
18:17:48 <erisco> we need an inclusive takeWhile and dropWhile perhaps
18:18:24 <__jim__> pjdelport: Thanks for the info! That's intersting
18:20:53 <erisco> > until null tail [1,2,3] -- hides all the intermediates though :-(
18:20:54 <lambdabot>  []
18:22:46 <machineslearn> What are some good uses for Haskell?  Someone asked me about that today.
18:22:59 <erisco> machineslearn, I use it to program stuff
18:23:36 <ij> hah
18:23:37 <juhp> carter, thanks
18:23:48 <carter> juhp: any sort of maintainer work is ahrd
18:24:04 <juhp> yeah tell me about it :)
18:24:07 <pjdelport> michaelneale: It's a general-purpose programming language, and it is in particular an excellent way to explore and learn about functional programming.
18:24:14 <pjdelport> err, machineslearn -^
18:24:20 <carter> i've accidentally/deliberately focused on being lame about patches writing and instead helping with support and coord
18:24:26 <carter> (ok, also been busy with my own hacking)
18:25:50 <machineslearn> I like Haskell, but the question was about use cases.  I had to admit that I probably wouldn't foist Haskell on a non-Haskell shop because it still requires rather specialized knowledge.
18:26:07 <carter> eh not really
18:26:18 <carter> it just requires an expert on the team to help speed up the learning
18:26:24 <grache28> foo y xs= [(a,b) | (a:bs) <- tails xs, b <- bs, a+b == y]      -- (a:bs) <- tails xs ; a get's what?
18:26:50 <__jim__> machineslearn: I think /r/haskell periodically gets articles to real world use cases, that might be a good place to look.
18:27:54 <pavonia> machineslearn: What are use cases for e.g. Java?
18:27:57 <__jim__> carter: isn't that kind of the case with any language/new tool ?
18:28:02 <carter> yup
18:28:02 <dmwit> We really need a wiki page so we don't have to go through all the same charades every time somebody asks us what people use Haskell for.
18:28:03 <carter> :)
18:28:22 <__jim__> dmwit: I'm reasonably certain there is one...
18:28:26 <cwvh> any one have some good starter references/examples for aeson lensing? I'm trying to traverse and pull out the list of y's in   {"x":[{"y":1}, {"y":2}, {"y":3}]}  but I can't seem to get my key, traverse and _Array in order.
18:28:39 <dmwit> grache28: a iterates through elements of xs.
18:29:03 <ij> __jim__, dmwit, machineslearn: http://www.haskell.org/haskellwiki/Haskell_in_industry http://www.haskell.org/haskellwiki/Haskell_in_practice
18:29:34 <__jim__> ij: I just copied those links lol
18:29:42 <ij> I'm that fast.
18:30:14 <erisco> aha, got it!
18:30:40 <grache28> dmwit: tks - and a:b means element 'a' and element 'b' - but a:bs  means element 'a' and tail 'bs' ?
18:30:55 <grache28> tks to everyone for patience w/ my stupid questions btw
18:31:40 <erisco> > reverse . until (null . head) (uncurry (:) . (tail . head &&& id)) . pure $ [1..5]
18:31:42 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
18:31:49 <machineslearn> https://www.fpcomplete.com/page/case-studies
18:31:56 * hackagebot ParserFunction 0.1.0 - Parse and evaluate mathematical expressions.  http://hackage.haskell.org/package/ParserFunction-0.1.0 (EnzoHaussecker)
18:32:15 <dmwit> grache28: No, "a" and "bs" are just names. They have no semantic content.
18:32:24 <erisco> jle`, now it's fixed :D
18:32:52 <dmwit> grache28: foo:bar is always the list with head foo (a single element) and tail bar (a list), regardless of what names you pick for foo and bar.
18:34:04 <grache28> dmwit: aah - think it clicked. foo:bar == head foo, tail bar ; foo,bar == element1 foo, element2 bar
18:34:22 <machineslearn> Those are good resources, but I suppose I need to learn more about it so I can say, "If you want to do x, Haskell is a really good choice because of y."
18:35:44 <erisco> :t \f -> uncurry (:) . (f &&& id)  -- this is kinda cute
18:35:45 <lambdabot> ([a] -> a) -> [a] -> [a]
18:36:08 <erisco> oops
18:36:31 <erisco> does not do what I thought it did :(
18:36:45 <monochrom> y can be always "permits fewer bugs"
18:36:46 <pavonia> grache28: [a, b, ..., z] is just sytactic sugar for a : b : ... : z : []
18:38:34 <grache28> ok tks pavonia
18:38:53 <erisco> :t \f -> uncurry (++) . first (fmap f) . splitAt 1 -- this is what I was thinking
18:38:54 <lambdabot> (b -> b) -> [b] -> [b]
18:39:01 <Polarina> Is this anything I should be worried about when installing packages? setup-Simple-Cabal-1.20.0.0-x86_64-linux-ghc-7.8.2: internal error: scavenge_stack: weird activation record found on stack: 415597384
18:42:13 <erisco> sveit, I think you can represent arbitrarily nested lists as a rose tree
18:42:29 <erisco> then you have a simple map function
18:47:23 <bobajett> how can I get a list but without the element at index i in it? so I want this list ['a','b','c','d'] without the element at index 2 => ['a','b','d']
18:47:44 <erisco> bobajett, what if the index is not in the list?
18:48:07 <bobajett> erisco: I won't worry about that for now :-)
18:48:26 <erisco> well decide now :P
18:49:16 <bobajett> I can use Maybe later on, but for now I just want to assume that the index is within range
18:50:19 <erisco> well how about if the index is not in the list the list is unchanged?
18:50:34 <bobajett> sounds good to me :-)
18:51:53 <erisco> > (\i -> fmap snd . snd . partition ((==i) . fst) . zip [0..]) 5 [1..10] -- comes to mind
18:51:55 <lambdabot>  [1,2,3,4,5,7,8,9,10]
18:53:48 <erisco> > (\i -> fmap snd . filter (not . (==i) . fst) . zip [0..]) 5 [1..10] -- also
18:53:50 <lambdabot>  [1,2,3,4,5,7,8,9,10]
18:54:24 <bobajett> cool thanks!
18:56:54 <jle`> hm
18:57:12 <erisco> trying to squeeze in mapMaybe but it is not fitting too well
18:57:14 <erisco> :t foldMap
18:57:15 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
18:57:58 <jle`> > (\i -> map snd . filter ((/= i) . fst) . zip [0..]) 4 [1..10]
18:58:00 <lambdabot>  [1,2,3,4,6,7,8,9,10]
18:58:15 <jle`> oh that's exactly what erisco had
18:58:22 <jle`> come on man, not . (== i) ?
18:58:29 <erisco> I forget about /=
18:58:33 <jle`> =/
18:58:37 <bobajett> heh
18:58:40 <erisco> I am used to != and then Haskell complains
18:59:10 <erisco> :t \f -> foldMap f . zip [0..]
18:59:12 <lambdabot> (Monoid c, Num a, Enum a) => ((a, b) -> c) -> [b] -> c
18:59:17 <erisco> if 'f' can be made pretty this would be nice
19:02:41 <jle`> > (\i -> filter isJust . zipWith ($) (replicate i Just ++ [Nothing] ++ repeat Just)) 4 [1..10]
19:02:42 <lambdabot>  Couldn't match expected type ‘a -> Data.Maybe.Maybe a’
19:02:43 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
19:03:02 <jle`> > (\i -> filter isJust . zipWith ($) (replicate i Just ++ [const Nothing] ++ repeat Just)) 4 [1..10]
19:03:03 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 6,Just 7,Just 8,Just 9,Just 10]
19:03:59 <erisco> > (\i -> foldMap (uncurry (>>) . (guard . (/=i) . fst &&& (:[]) . snd)) . zip [0..]) 5 [1..10]
19:04:01 <lambdabot>  [1,2,3,4,5,7,8,9,10]
19:05:28 <bobajett> so I guess there is no function like python's enumerate? for i,x in enumerate(xs) ?
19:05:35 <erisco> > (\i -> foldMap (uncurry (>>) . (guard . (/=i) *** (:[])) . zip [0..]) 5 [1..10]
19:05:36 <lambdabot>  <hint>:1:80:
19:05:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:06:03 <erisco> > (\i -> foldMap (uncurry (>>) . (guard . (/=i) *** (:[]))) . zip [0..]) 5 [1..10]
19:06:04 <lambdabot>  [1,2,3,4,5,7,8,9,10]
19:07:21 <erisco> hrm that is about the best I can think of for foldMap
19:07:32 <jle`> > (\i -> mapMaybe id . zipWith ($) (replicate i Just ++ [const Nothing] ++ repeat Just)) 4 [1..10]
19:07:33 <lambdabot>  [1,2,3,4,6,7,8,9,10]
19:07:42 <glguy> What function are you guys writing?
19:07:50 <erisco> dropAt, essentially
19:08:42 <bobajett> @src dropAt
19:08:42 <lambdabot> Source not found. Abort, Retry, Panic?
19:08:53 <pgiarrusso> But isn't the proposed "map snd . filter ((/= 2) . fst) $ zip [0..] [1..10]" simpler
19:08:56 <pgiarrusso> ?
19:09:41 <erisco> yes it is :P
19:10:12 <glguy> > let dropAt n = ifoldr (\i x xs -> if i == n then xs else x:xs) [] in dropAt 5 [1..10]
19:10:13 <lambdabot>  [1,2,3,4,5,7,8,9,10]
19:10:21 <jle`> > (\i xs -> let (a,b) = splitAt i xs in a ++ drop 1 b) 4 [1..10]
19:10:22 <lambdabot>  [1,2,3,4,6,7,8,9,10]
19:11:02 <jle`> i guess you can pointfree it
19:11:22 <jle`> > (\i -> uncurry (++) . second (drop 1) . splitAt i) 5 [1..10]
19:11:24 <lambdabot>  [1,2,3,4,5,7,8,9,10]
19:11:35 <erisco> oh yeah, splitAt
19:11:44 <pgiarrusso> > :t ifoldr
19:11:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:11:53 <pgiarrusso> :t ifoldr
19:11:53 <lambdabot> FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
19:12:10 <jle`> wow #haskell is literally the worst time sink ever
19:12:36 <glguy> [mapMaybe id] is [catMaybes] (looking at one of the previous versions)
19:12:43 <jle`> ty glguy
19:16:43 <south> Hi all!
19:16:46 <south> I have a quick question
19:17:13 <jle`> hi south :)
19:17:31 <south> hey jle`!
19:18:16 <south> So my question is basically this: I want to be able to represent two separate "programs" in a Free monad
19:19:14 <south> i.e. where I'd have something in lists like Unary [a], Binary [a] [a]
19:19:42 <south> I basically want to be able to do things like Binary (a >> b) c
19:19:49 <south> but lifted into a Free monad, if that makes sense
19:19:54 <south> Is that possible?
19:20:31 <erisco> > Sum (5 :: Int) + Sum (6 :: Int)
19:20:32 <lambdabot>  Sum {getSum = 11}
19:20:45 <jle`> you know, I'm not really sure what you are trying to do.
19:20:48 <erisco> wait what? hmm this instance must be missing on my version
19:21:18 <south> I'm trying to represent streams of music notes
19:21:30 <jle`> erisco: I don't have that either
19:21:32 <erisco> > (\i -> foldMap (uncurry (>>) . (guard . (/=i) *** pure)) . zip [0..]) 1 [1,2,3] :: Maybe (Sum Int)
19:21:33 <lambdabot>  Just (Sum {getSum = 4})
19:21:39 <jle`> hm
19:21:41 <south> And I'm able to use a free monad to sequence notes
19:21:41 <jle`> oh i have it on 7.8
19:21:42 <erisco> I thought that was an interesting generalisation :)
19:22:04 <erisco> some reason to use the foldMap solution anyhow
19:22:10 <jle`> sequencing notes sounds more like something for monoids
19:22:15 <south> but I want to be able to build a structure that allows me to concurrently execute them
19:22:31 <jle`> concurrently execute notes, like two voices?
19:22:36 <south> Yeah
19:22:56 <south> But the idea would be to have them represented purely and executed concurrently at runtime
19:22:58 <jle`> have you looked that that...what was that paper...
19:23:11 <jle`> "execute"?
19:23:40 <south> I think I know what paper you're talking about, the one about polymorphic temporal media?
19:24:10 <south> I'm sort of trying to map that to a monad, because it results in really nice notation
19:24:31 <south> But the problem is that trying to merge compositions into a single sequence is actually kind of hard
19:25:27 <south> But it becomes easier if I can just concurrently interpret two separate streams at runtime
19:25:34 <jle`> hm i think it was http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf but more recent
19:25:53 <jle`> where are these separate streams coming from? IO?
19:26:06 <south> Nah, they're built directly in haskell
19:26:30 <south> i.e. right now you can do something like bass >> sn >> ...
19:26:41 <jle`> and that composes them in parallel?
19:26:49 <south> No, that composes sequentially
19:27:16 <south> Right now there's an operator that merges two (Free Music ())s
19:27:23 <south> in parallel
19:27:40 <south> But it's giving me a headache, so I'd like to put off the merge until runtime
19:28:25 <south> Thanks for the paper!
19:28:41 <jle`> what do you mean put it off? hm.
19:28:47 <jle`> also, if your ntoes are all Music ()
19:29:00 <jle`> it sounds like you might be better off with a Monoidal interface
19:29:27 <jle`> you can still use do notation with a monoidal interface using the Writer monad
19:29:32 <jle`> if you really really want do notation
19:29:39 <south> Oh cool, can you point me in the right direction?
19:29:43 <south> I really really do want do notation :)
19:29:44 <jle`> but i think that is considered an antipattern
19:29:49 * lahwran points south
19:29:57 <jle`> heh
19:30:01 <south> lol
19:30:14 <jle`> so you just make your line a monoid
19:30:42 <south> Ah yeah
19:30:45 <jle`> so g :: Part
19:30:46 <south> That makes sense actually
19:30:49 <jle`> g <> c :: Part
19:30:54 <jle`> <> :: Part -> Part -> Part
19:31:24 <south> That's a good idea. I'll explore it!
19:31:26 <jle`> and you can have "part modifiers", like doublespeed :: Part -> Part, which turns a quarter note into a half note
19:31:27 <south> Thanks jle`
19:31:36 <jle`> so doublespeed g <> c :: Part is a half note g and a quarter note c
19:31:42 <jle`> and so if you wanted do notation
19:32:03 <jle`> you can have a Writer Part (); do { tell (doublespeed g); tell c; tell e }
19:32:26 <south> Ah, cool!
19:32:36 <jle`> but if you let go of do notation, you'll find you aren't missing much
19:32:50 <jle`> you can do, for example, mconcat [doublespeed g, c, e]
19:33:10 <jle`> i think HSoM takes a monoid approach...i think there is a more recent paper from this past year
19:33:24 <jle`> you still have the problem of parallely-combinging parts though
19:33:30 <jle`> um i'm not sure how HSoM handles it
19:33:45 <jle`> but i'm sure they mention it in the paper
19:34:01 <south> Okay great, I'll give it a read
19:34:07 <south> Really helpful stuff!
19:34:48 <jle`> if you see a lot of m ()'s, it's typically good sign that monad might be the best abstraction :)
19:36:01 <south> I'm gonna save this chat log
19:36:09 <south> and I'm headed to bed now
19:36:15 <south> Thanks again jle`
19:36:15 <erisco> LOG BOMB
19:36:36 <jle`> south: np :) night
19:38:49 <jle`> er
19:38:54 <jle`> s/might be/might not be
20:07:56 <savanni> Is there a pre-built function that verifies that a list of numbers is already sorted?  I'm not sure what to hoogle for.
20:08:32 <Welkin> try sorted
20:09:10 <jfhall> savanni: I don't know about pre-built, but something like f (a:b:xs) = a < b && f (b:xs)
20:10:14 <Welkin> that is strange there is no standard function for this
20:10:17 <savanni> sorted doesn't look promising, but I'll use that function.
20:10:25 <savanni> It's better than anything I was dreaming up.
20:10:26 <Welkin> in python it is just list.sorted and returns a Bool
20:11:19 <jfhall> savanni: btw, that function needs a base condition (like when the list has less than two elements: after that definition, put f _ = true)
20:11:32 <roconnor> case anaysis on Bool is a bit of an anti-pattern
20:11:52 <savanni> jfhall: oh I was coding that
20:12:01 <jfhall> roconnor: what do you mean?
20:12:08 <savanni> though I was going to say f [] = True
20:12:23 <jfhall> savanni: you also want the case when the list has one element
20:12:34 <savanni> jfhall: done ;)
20:12:41 <roconnor> jfhall: Using if statements is a mild sign of poor Haskell code.
20:13:16 <jfhall> roconnor: did I use an if statement?
20:13:29 <Welkin> why don't you just sort the list?
20:13:31 <roconnor> savanni seems to be about to.
20:13:32 <Welkin> then you know it is sorted
20:13:41 <savanni> Welkin: actually, I'm verifying that a function has returned a sorted list.
20:13:53 <jfhall> roconnor: oh, my bad, I haven't written haskell in a while, thought I was giving bad advice
20:14:14 <savanni> No, I'm pattern matching it.
20:14:32 <savanni> I've got enough ugly if statements to want to avoid them as much as I can.
20:14:56 <roconnor> savanni: pattern matching on Bool?
20:15:57 <savanni> No, nothing like that.  Doing comparison operations.  Earlier today (or maybe yesterday) I found more places that I can set up guards.
20:16:53 <roconnor> better is a function that returns why a list is not sorted. -- food for thought
20:17:23 <roconnor> probably overkill for your situation.
20:17:38 <savanni> This is a test case.  The function that generates the list should always return a sorted one.
20:17:49 <savanni> The calculation is such that if it doesn't, I've built the function wrong.
20:18:00 <roconnor> oh
20:18:10 <roconnor> then it is applicable to your situation. :)
20:18:28 <savanni> Yup.  It's distressing, though, that I'm getting the wrong answer.
20:19:15 <jfhall> savanni: ha, but if things worked then there would be nothing left to do!
20:19:59 <savanni> Too true!
20:20:45 <Welkin> savanni, just sort the list using a standard sorting function and compare the two lists
20:21:04 <savanni> Oh.  Yeah, that's another good way to do it.
20:22:15 <Welkin> myList == sortedList
20:22:19 <Welkin> that's all you need
20:24:30 <hoverbear> How can I fix this issue when installing `haste-compiler`?
20:24:38 <hoverbear> https://gist.github.com/2cf2250f146c06b46443
20:25:11 <roconnor> and $ zipWith (<=) l (tail l)
20:29:18 <Burhh> hello
20:29:38 <harlanhaskins> So...
20:29:49 <harlanhaskins> unwords ws =  foldr1 (\w s -> w ++ ' ':s) ws
20:29:54 <harlanhaskins> Why not...
20:29:56 <Burhh> just a test ..
20:30:04 <harlanhaskins> unwords = intersperse ' '
20:30:04 <harlanhaskins> ?
20:30:13 <roconnor> @src unwords
20:30:14 <lambdabot> unwords [] = ""
20:30:14 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
20:30:22 <harlanhaskins> Oh wow that's nifty.
20:30:26 <harlanhaskins> @src intersperse
20:30:26 <lambdabot> intersperse _   []     = []
20:30:26 <lambdabot> intersperse _   [x]    = [x]
20:30:26 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
20:31:10 <harlanhaskins> Oh. Hmm. Intersperse returns an empty list when passed an empty list. Unwords returns an empty string.
20:31:24 <harlanhaskins> Still, except for the base case, unwords is needlessly redundant.
20:31:40 <gamegoblin> Hey, you just called me, and this is crazy, but I won’t evaluate yet, call me lazy.
20:31:50 <Yoctogon> heh
20:32:00 <Yoctogon> inb4 stack overflow
20:35:54 <roconnor> > [] == ""
20:35:56 <lambdabot>  True
20:36:58 <dmwit> intercalate " " is probably a fine implementation for unwords. But unwords predates intercalate.
20:37:03 <dmwit> ...I think.
20:41:00 <cpennington> what's the right way to install a local package from source into a sandbox
20:41:18 <cpennington> (I fixeda bug in a library that my package depends on, but can't seem to install the fixed code)
20:42:32 <carter> cabal sandbox add-source
20:42:36 <dmwit> cpennington: Can you not just give the path to the package to whatever cabal command you normally use to install something in the sandbox?
20:42:37 <carter> cpennington: :)
20:42:46 <cpennington> tried both of those, actually
20:42:59 <cpennington> but for some reason the bug is still in evidence
20:43:01 <carter> @lpaste the exact sequence of events
20:43:01 <lambdabot> Haskell pastebin: http://lpaste.net/
20:43:16 <carter> cpennington: did you WIPE the sandboxe before doing the add source?
20:43:45 <cpennington> carter: no, I didn't wipe the sandbox
20:44:04 <carter> cpennington: its annoying 'caue it takes more build time, but when trying to track these thigns down
20:44:11 <carter> first hammer is "is the slate clean"
20:44:44 <dmwit> That seems like an awfully large hammer.
20:44:48 <carter> dmwit: nah
20:45:00 <carter> its the hammer that makes the directions stateless :)
20:45:10 <carter> i like stateless directions
20:45:46 <carter> in some sense your'e absolute right though
20:45:54 <cpennington> is cabal sandbox delete the right command to wipe the sandbox?
20:46:08 <cpennington> no, looks like not
20:46:57 <carter> ls -a
20:47:01 <carter> then look aroudn for things
20:47:07 <carter> theres a hidden dir
20:47:16 <carter> rm -rf that bugger
20:47:22 <carter> thers also a auto gen
20:47:27 <carter> gend config file
20:47:42 <cpennington> yeah, I deleted .cabal-sandbox
20:47:48 <carter> cool
20:47:52 <carter> then re init
20:47:59 <Welkin> delete everything but the steam folder
20:48:00 <carter> then add source for the other sandbox / fixed
20:48:03 <carter> :)
20:48:34 <cpennington> giving that a try
20:49:20 <chirpsalot> Hmmmm. Anybody use Aeson? I am trying to parse a giant JSON dictionary, and I get this: Left "Failed reading: Cannot decode byte '\\xf7': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
20:49:36 <carter> maybe its not valid utf8 :)
20:49:39 <chirpsalot> Which I assume means the file has some horrible byte from the depths...
20:49:52 <carter> probalby the byte its baring on
20:49:54 <carter> wheres is from
20:49:56 <chirpsalot> Yeah, but I admit I'm not sure how to find it...
20:50:16 <enthropy> is there a nicer way to write something like http://lpaste.net/104113 ?
20:50:24 <chirpsalot> (I don't know much about unicode)
20:50:33 <carter> enthropy: bifunctor?
20:50:42 <Welkin> unicorn codec
20:51:05 <chirpsalot> carter: do you mean where is the file from?
20:51:19 <carter> ys
20:51:32 <enthropy> there is no such instance as far as I know
20:52:14 <cpennington> carter: that hammer did the trick. thanks!
20:52:38 <chirpsalot> carter: it's the dictionary from "Plover"... Let me put it on a Google drive.
20:52:39 <carter> cpennington: i like direcitons that are obvlious and stateless :)
20:52:44 <carter> plover?
20:52:48 <carter> @google plover
20:52:49 <lambdabot> http://en.wikipedia.org/wiki/Plover
20:52:49 <lambdabot> Title: Plover - Wikipedia, the free encyclopedia
20:52:58 <carter> ermmmm
20:53:02 <carter> thats  bird
20:53:03 <carter> ?
20:53:16 <chirpsalot> @google plover stenography
20:53:17 <lambdabot> http://plover.stenoknight.com/
20:53:17 <lambdabot> Title: Plover, the Open Source Steno Program
20:53:36 <carter> chirpsalot: could it be you got the encoding wrong?
20:53:39 <carter> how'd you load it?
20:53:48 <carter> did you read it in with the IO stuff in data.text?
20:53:53 <carter> or as a bytestring you needed to decode?
20:53:57 <chirpsalot> carter: I just loaded it with readFile from Data.ByteString.Lazy.
20:54:05 <carter> nah
20:54:18 <carter> byestring === its binary data or ascii only
20:54:36 <chirpsalot> carter: I thought it was ASCII only :P
20:54:42 <carter> you lie
20:54:51 <dmwit> um
20:54:55 <dmwit> isn't JSON a byte format?
20:55:02 <carter> its a text format :)
20:55:20 <carter> its also infamously underspsecified
20:55:35 <chirpsalot> carter: I have no clue where the UTF8 is coming from! I mean, I'd believe that it's in there, but I'm not sure how to find it :P.
20:55:44 <sjy> json.org - "A string is a sequence of zero or more Unicode characters"
20:55:52 <carter> chirpsalot: aeson assume things are valid unicode
20:55:54 <sjy> "A string is very much like a C or Java string."
20:55:58 <sjy> helpful!
20:56:12 <carter> load the file using the IO tool in data.text or data.text.lazy
20:56:19 <chirpsalot> carter: the aeson decode function uses Bytestring, though?
20:56:26 <carter> ummm
20:56:27 <carter> idk
20:56:29 <carter> does it? :)
20:56:38 <johnw> yeah, i'm pretty sure it does
20:56:49 <carter> @hackage aeson
20:56:49 <lambdabot> http://hackage.haskell.org/package/aeson
20:56:55 <chirpsalot> Yeah! hackage.haskell.org/package/aeson-0.6.1.0/docs/src/Data-Aeson.html#decode
20:57:04 <chirpsalot> Oh. Lambdabot is much better than me.
20:57:54 <chirpsalot> carter: are you sure Bytestrings wouldn't handle different encodings? I don't see why they couldn't.
20:58:21 <carter> chirpsalot:i think you may wann remap it to utf16 via data.text
20:58:26 <carter> or whatever
20:58:35 <carter> make sure its bytestring in the UTF version aeson expect?
20:58:36 <carter> idk
20:58:41 <harlanhaskins> @src unwords
20:58:41 <lambdabot> unwords [] = ""
20:58:42 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
20:58:42 <carter> might be a weird issue in aeson
20:58:43 <carter> idk
20:58:50 <harlanhaskins> @src intersperse
20:58:50 <lambdabot> intersperse _   []     = []
20:58:51 <lambdabot> intersperse _   [x]    = [x]
20:58:51 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
20:59:17 <harlanhaskins> unwords = intersperse ' '
20:59:32 <johnw> :t intersperse
20:59:33 <NemesisD> i think i may have painted myself into a corner. I've got a type Logger m = Logger String (String -> m ()), the problem is that m is likelely belonging to MonadReader Logger m, and writing the type signature is infinitely recursive
20:59:33 <lambdabot> a -> [a] -> [a]
20:59:37 <johnw> :t intercalate
20:59:38 <lambdabot> [a] -> [[a]] -> [a]
20:59:45 <chirpsalot> carter: here is the dictionary if you / anyone wanted to have a look: http://is.gd/VBlq7E
21:00:29 <NemesisD> is there a smarter type i can use here?
21:00:46 <harlanhaskins> Sorry.
21:00:59 <harlanhaskins> unwords = intersperse " "
21:01:10 <harlanhaskins> s/intersperse/intercalate
21:01:26 <carter> chirpsalot: open a ticket on aeson mebe
21:01:45 <chirpsalot> carter: I'm not sure it's a bug.
21:01:52 <carter> chirpsalot: idea: try parsing via data.text, then encoding it to the utf8
21:01:54 <carter> bytesring
21:02:07 <dmwit> harlanhaskins: I believe the reason is that unwords came before intercalate, and there was no good reason to switch once intercalate appeared.
21:02:15 <carter> ie see i fyou can load it withthe Text machinery
21:02:39 <harlanhaskins> dmwit: But they perform the same function, and unwords is realistically a more specific case of intercalate.
21:03:06 <dmwit> I'm not sure what the "but" is for. The remainder of your sentence seems accurate to me.
21:03:35 <harlanhaskins> s/But t/T/
21:14:03 <chirpsalot> carter: removed all non-ascii characters with iconv and now it works... I would very much like to find the special wide characters eventually :|
21:14:33 <carter> chirpsalot: filter the negation!
21:14:34 <carter> :)
21:14:49 <chirpsalot> ... Oh diff.
21:15:34 <chirpsalot> carter: WOW. Okay, that was easy. Literally ONE character.
21:15:44 <carter> :)
21:15:48 <carter> now you know some tricks!
21:16:20 <chirpsalot> carter: ooooooh. \367 instead of \xf7... That's why I never found it >_<
21:16:43 <carter> ??
21:16:44 <carter> whats tha
21:16:55 <chirpsalot> Character code... Thing.
21:17:06 <carter> @google \367
21:17:08 <lambdabot> http://images.pcmac.org/SiSFiles/Schools/NC/OnslowCounty/SwansboroHigh/Uploads/DocumentsCategories/Documents/Solving%20Inequalities%20by%20+%20-%20x%20%C3%B7.pdf
21:17:08 <lambdabot> Title: (Microsoft PowerPoint - Solving Inequalities by + - x \367)
21:17:15 <carter> @google \xf7
21:17:16 <lambdabot> https://rt.cpan.org/Ticket/Display.html?id=30959
21:17:21 <carter> ummmm
21:20:03 <dp_wiz> Is there a per-process GC somewhere on the horizon?
21:22:05 <carter> dp_wiz: ... a GHC haskell program *is* a single process
21:22:15 * hackagebot attoparsec 0.11.3.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.3.1 (BryanOSullivan)
21:22:25 <carter> it can have several OS threads though
21:22:26 <peddie> dp_wiz: if you run two different programs as different processes, the runtimes (including garbage collectors) will be in different processes as well
21:22:53 <carter> and theres some thoughts about how to have "sub heaps" in the same process for different hs threads
21:23:07 <carter> but no ones focusing on that presently afaik
21:23:16 <carter> @google hwloc
21:23:17 <lambdabot> http://www.open-mpi.org/projects/hwloc/
21:23:18 <lambdabot> Title: Portable Hardware Locality (hwloc)
21:24:03 <carter> dp_wiz: whats the context of your question
21:25:30 <peddie> dp_wiz: https://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/local-gc.pdf might be relevant
21:25:36 <dp_wiz> the context is yet another Erlang VS Haskell chit-chat (: should Haskell get PPGC, Erlang will be obliterated and stuck in its VM niche.
21:25:47 <carter> :)
21:25:59 <carter> its going to be at least 1-2.5 years before that happens
21:26:03 <carter> but it shall happen :)
21:26:37 <dp_wiz> that's that i were saying (=
21:27:15 * hackagebot aeson 0.7.0.4 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.4 (BryanOSullivan)
21:27:38 <peddie> dp_wiz: can you explain what you mean by per-process garbage collection?  apparently I completely misunderstood
21:28:53 <dp_wiz> peddie: each haskell process (light thread) gets its own heap and GC doesn't stop everything at once to do its job.
21:30:36 <dp_wiz> Current GHC "stops the world" and starts one or more GC to reclaim memory. Erlang does that independently for each process.
21:31:32 <carter> anohter way of viewing it is more segmented heaps
21:31:42 <carter> with blocks owned by a given capability
21:31:47 <carter> theres some subtlies to this
21:31:59 <carter> this kinda happens in minature with the nursery
21:32:02 <carter> but not for subsequent stuff
21:32:22 <carter> part of the tricky bit being the shared memory nature of haskell
21:32:37 <carter> dp_wiz: did you read any of the manticore GC papers?
21:32:52 <c_wraith> This is a point where laziness hurts the GC
21:33:04 <dp_wiz> carter: not yet
21:33:05 <carter> is it laziness?
21:33:17 <carter> @google manitocore gc paper fluet
21:33:18 <lambdabot> No Result Found.
21:33:21 <carter> @google manitocore gc paper
21:33:21 <lambdabot> No Result Found.
21:33:31 <heatsink> @google manticore gc paper reppy
21:33:33 <carter> @google manitocore matthew fluet
21:33:34 <lambdabot> http://manticore.cs.uchicago.edu/papers/damp07.pdf
21:33:34 <lambdabot> Title: Manticore: A heterogeneous parallel language
21:33:34 <lambdabot> No Result Found.
21:33:36 <carter> oh
21:33:39 <carter> yes that
21:33:45 <carter> i think ters a mroe recen tone
21:33:48 <carter> *recent one
21:34:11 <carter> http://manticore.cs.uchicago.edu/
21:34:54 <heatsink> You spelled it correctly before misspelling it three times in a row :p
21:35:03 <carter> hahahahahah
21:35:04 <carter> happens
21:35:20 <carter> heatsink: enthropy :  Typeable was kind * only in 7.6 and earlier right?
21:35:39 <chirpsalot> www.haskell.org/haskellwiki/Dealing_with_binary_data -- "String involves a space-inflation of about 24x" is that supposed to be 4x, or am I misunderstanding o_O?
21:35:49 <heatsink> Polykinding was added pretty recently
21:35:52 <carter> ok
21:36:04 <carter> so i can't write Typeable for my type level Nat type
21:36:07 <carter> for 7.6
21:36:07 <carter> ok
21:36:09 <heatsink> Let me see what the 7.6.3 docs say
21:36:15 <carter> i'm totally ok with crippled generics for7.6
21:36:30 <carter> heatsink: thans
21:36:48 <carter> "Since GHC 7.8, Typeable is poly-kinded. The changes required for this might break some old programs involving Typeable. More details on this, including how to fix your code, can be found on the PolyTypeable wiki page"
21:37:14 <carter> ok
21:37:19 <carter> yup
21:37:30 <carter> I cant' write Data instances for my stuff for pre 7.8 :)
21:37:31 <heatsink> Ok.  Looks like they put the feature in 7.6 but didn't change the libraries 'til 7.8
21:38:05 <carter> which means I can't write a 7.6 friendly Data instance for anything with a  :: Nat param
21:38:06 <carter> right?
21:38:59 <carter> like my static size list
21:39:01 <heatsink> Only if you're willing to wrap it in an existential parameter
21:39:08 <heatsink> existential package I mean
21:39:13 <carter> explain more
21:39:40 <carter> ewww, i can't really do that
21:39:52 <carter> at least, not for the shape stuff
21:39:54 <heatsink> ok
21:40:19 <carter> 'cause i'm using the static sized list type to make sure i properly inline my array adressing codes
21:40:49 <heatsink> I don't know how the Data class works.  There may be a special-case workaround.
21:41:27 <heatsink> Hmm... you need static sizes to control inlining?
21:41:49 <carter> i'm phttps://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
21:41:51 <carter> https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
21:41:59 <spacekitteh> is there a way to treat a datatype as a function? as in, app :: (Function a) => a -> b -> c; app f i = f i
21:42:12 <carter> static size is for rank checking
21:42:30 <carter> but the inlining is a nice thing
21:43:15 <heatsink> spacekitteh, sure.  Just define 'app' as a function or type class member
21:44:21 <spacekitteh> i was only using app as an example to show the type
21:45:21 <heatsink> You can't make data values "automatically" call a function when applied to arguments.
21:45:45 <spacekitteh> ok :(
21:46:12 <mmachenry> OMG I just read the #haskell is untrollable post on reddit. You guys are great.
21:46:48 <carter> mmachenry: wanna write a ghc patch? :)
21:46:52 <carter> the first ones free
21:46:58 * carter ducks
21:47:16 <NemesisD> is there a way i could write a log function String -> m () that worked where m is MonadWriter [String] and IO (or MonadIO)?
21:47:22 <mmachenry> carter: Maybe :)
21:47:41 <carter> mmachenry: its actually pretty easy to get involved with core stuff
21:47:55 <mmachenry> carter: I'm listening.
21:47:57 <carter> whether its ghc/ hackage-server / cabal / etc
21:48:10 <carter> where to start depends on your background and interests
21:48:30 <NemesisD> argh. disconnected. did anyone get that or answer it?
21:48:37 <spacekitteh> no NemesisD
21:48:44 <NemesisD> no to get or no to answer?
21:48:46 <mmachenry> carter: I used to work on a Scheme compiler. I would be interested in getting back into contributing to a language.
21:48:50 <carter> cool!
21:48:53 <XexonixXexillion> NemesisD: make a Loggable type class and write instances for MonadWriter [String], IO etc.
21:48:53 <carter> which one?
21:49:10 <carter> please say stalin or T or racket or chicken or gambit
21:49:23 <mmachenry> Racket (previously Dr. Scheme)
21:49:27 <carter> sweet
21:49:31 <carter> how long ago?
21:49:39 <XexonixXexillion> carter: no love for guile?
21:49:42 <mmachenry> 2002-2005
21:49:45 <carter> cool
21:50:07 <carter> during an (under)grad stint with one of the PLT folks?
21:50:12 <mmachenry> I was an undergrad at Northeastern where Racket (and a lot of the Scheme world) is centered.
21:50:29 <NemesisD> XexonixXexillion: what would that look like? instance MonadWriter [String] m => Loggable m where log = tell . (:[]) ?
21:50:41 <mmachenry> carter: Yeah. Matthias Felleisen and I went to live with Robby Findler at U Chicago
21:51:22 <mmachenry> They're a great group.
21:52:00 <carter> i interned there one summer
21:52:04 <carter> was a weird experience
21:52:15 <mmachenry> Oh? How so? And which summer?
21:52:18 * hackagebot locators 0.2.4.1 - Human exchangable identifiers and locators  http://hackage.haskell.org/package/locators-0.2.4.1 (AndrewCowie)
21:52:21 <mmachenry> As a grad student?
21:52:31 <carter> undergrad
21:52:37 <carter> 2007 ish?
21:52:43 <carter> or 2008
21:52:47 <carter> dont' rmemeber
21:52:58 <mmachenry> Why was it weird?
21:53:29 <XexonixXexillion> NemesisD: probably more like instance Loggable (MonadWriter [String]) where log = ... and instance (MonadIO m) => Loggable m where log = ...
21:55:47 <carter> mmachenry: well, if you have sleep apnea all undergrad and dont know it
21:55:54 <carter> you'll be kinda grumpy and slow at coding
21:56:14 <mmachenry> Ah… I see. You didn't find the PLTers weird.
21:56:34 <carter> i was doing PL stuff in high school
21:59:41 <Kaidelong> I'm almost certain I don't want to be using IORef [t]
21:59:55 <Kaidelong> does hackage have any good mutable variable length data structures?
22:00:09 <carter> mmachenry: so what racket stuff idd you hack on?
22:00:10 <Kaidelong> (vector is overkill here)
22:00:33 <Kaidelong> (also not variable, I don't need indexing)
22:01:16 <Kaidelong> also the model I've come up with is that I have an IO SessionToken that when run initializes the system and makes a global state, all over GLFW related functions require a token as a parameter
22:07:20 * hackagebot thyme 0.3.5.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.0 (LiyangHu)
22:09:42 <kristi_kodare> :t forM_
22:09:43 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
22:10:02 <kristi_kodare> forM_ [1..10] (putStrLn "h")
22:11:15 <NemesisD> hmm. it doesn't looks like instance Loggable (MonadWriter [String]) is possible, im getting a kind mismatch
22:12:06 <NemesisD> and instance MonadWriter [String] m => Loggable m requires undecidable instances
22:12:25 <NemesisD> which i'm told is a Bad Idea
22:12:32 <Kaidelong> kristi_kodare: lambdabot won't do IO
22:13:06 <Kaidelong> in any case you need to prefix it with >
22:13:39 <kristi_kodare> Kaidelong ok good
22:17:21 * hackagebot pipes 4.1.2 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.2 (GabrielGonzalez)
22:19:14 <enthropy> carter: did your data instance get solved?
22:19:21 <carter> kinda
22:19:31 <carter> i think i see how to do it
22:20:07 <enthropy> you can do stuff like    instance Data (Proxy (x :: Nat))
22:20:23 <carter> oh?
22:20:30 <carter> and whats that get me?
22:20:46 <enthropy> well it's a data instance
22:20:58 <carter> oh
22:20:59 <carter> as an example
22:21:41 <enthropy> http://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-Data.html as a worse example
22:22:43 <carter> enthropy: thats actually EXACTLY what i needd
22:22:46 <carter> is that for 7.8 only
22:22:50 <carter>  or 7.6 too?
22:23:25 <enthropy> that one compiles for both, but works properly with 7.6 only
22:23:42 <carter> whys that
22:23:42 <enthropy> I guess the bug linked has actually been fixed
22:24:38 <enthropy> https://ghc.haskell.org/trac/ghc/ticket/8486
22:25:59 <carter> ok
22:26:04 <carter> i'm gonna look at this after i sleep
22:26:06 <carter> thanks
22:26:07 <NemesisD> hmm. can't figure out this error: data Logger m = Logger String; testLogger :: MonadWriter [String] m => string -> Logger m, says m is expecting one more argument
22:26:13 <carter> enthropy: may ping you for questions on this tomorrow?
22:26:46 <enthropy> so more concretely, I can't load the HList/examples/cmdargs.hs in ghc-7.8
22:26:49 <enthropy> No instance for (Typeable "z") arising from a use of ‘gmapT’
22:26:58 <carter> oh yeah
22:27:04 <carter> you have to write instances for the lifted stuff
22:27:26 <carter> erm
22:27:38 <carter> i have deriving instance Typeable 'Z
22:27:43 <carter> in my numerical-core stuff
22:28:01 <enthropy> yes that works for you
22:28:19 <carter> because i'm not doing a het list
22:28:24 <carter> so my constraints are ... simpler
22:34:27 <The_Dreamer> exit
22:34:36 <enthropy> feel free to ask tomorrow
22:37:32 <felixn> hi
22:37:34 <felixn> haskell is cool
22:37:48 <mmachenry> Hi. You are too.
22:37:57 <felixn> yeeeeee ^_^
22:38:22 <felixn> i'm getting high off of parsec right now
22:39:03 <mmachenry> It should be a controlled substance
22:39:24 <felixn> heh
22:42:24 * hackagebot socketio 0.1.3 - Socket.IO server  http://hackage.haskell.org/package/socketio-0.1.3 (TingYenLai)
22:42:26 * hackagebot scientific 0.3.0.1 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.0.1 (BasVanDijk)
22:42:51 <jle`> controlled monads
22:42:57 <jle`> that's why it's under Control.Monad
22:42:59 <jle`> wow that was awful
22:43:05 * jle` resigns life
22:43:20 <mmachenry> You're fired :-P
22:43:52 <pavonia> Is there a function for converting a decimal value into a full date, like 2014.0 becomes 01/01/2014?
22:45:52 <jle`> pavonia: full date as in date string?
22:45:58 <jle`> or some date data type
22:46:07 <jle`> mmachenry: you can't fire me, i quit
22:46:12 <pavonia> the latter
22:46:31 <pavonia> something ~ (Int, Int, Integer)
22:55:55 <pavonia> Hhm, fromJulianYearAndDay is close to what I want, but I can't see an equivalent for Gregorian calendars
23:32:29 * hackagebot ncurses 0.2.9 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.9 (JohnMillikin)
23:51:55 <vlads1> test
