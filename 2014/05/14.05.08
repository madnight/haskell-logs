00:01:01 <newsham> ?type foldMap . foldMap
00:01:02 <lambdabot> (Monoid m, Foldable t1, Foldable t) => (a -> m) -> t (t1 a) -> m
00:01:22 <newsham> ?type foldMap . foldMap . foldMap
00:01:23 <lambdabot> (Monoid m, Foldable t2, Foldable t1, Foldable t) => (a -> m) -> t (t1 (t2 a)) -> m
00:01:48 <newsham> neat
00:02:01 <johnw> that is cool
00:12:36 <christiaanb> Perhaps somebody here knows: what is the purpose of http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Internal.html? It's an exposed module of the bytestring package, but it has  {-# OPTIONS_HADDOCK hide #-}. Why would you want to expose a module with explicitly eliding documentation?
00:19:26 <tomejaguar> christiaanb: I guess it's exposed so you *can* use it if you really really want, but you pretty much never should and so they don't generate the documentation for it.
00:20:20 <mcjohnalds> There's nothing worse than needing an unexposed function in a library. You have to copy and paste it :(
00:21:08 <fxr> mcjohnalds: along with tons of imports sometimes...
00:22:50 <christiaanb> tomejaguar: alright, fair enough :)
00:32:24 * hackagebot pandoc 1.12.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.4 (JohnMacFarlane)
00:37:25 <Erg[o]Proxy> hi to all
00:37:32 <Erg[o]Proxy> no one in room ?
00:37:42 <Erg[o]Proxy> i have a question about znc
00:38:02 <Erg[o]Proxy> you know something about the watch module ?
00:38:11 <Erg[o]Proxy> no one ?
00:38:13 <Erg[o]Proxy> -.-
00:38:20 <Erg[o]Proxy> sorry to bother Ö
00:38:52 <dmj`> Ergo[o]Proxy: this room is about haskell programming
00:38:57 <tomejaguar> Erg[o]Proxy: It's pretty empty at the moment ...
00:39:36 <Erg[o]Proxy> tomejaguar:  i can see 1261 nicknames on list Ö
00:39:48 <tomejaguar> All asleep ...
00:39:56 <Erg[o]Proxy> dmj`:  ok Ö i understand Ö
00:40:17 <Erg[o]Proxy> tomejaguar:  but i think to you know something about znc Ö
00:40:34 <Erg[o]Proxy> i have only a question on the watch module ..
00:40:38 <Erg[o]Proxy> i can ask  ?
00:40:47 <tomejaguar> This isn't the right channel for it
00:41:28 <Erg[o]Proxy> tomejaguar:  okÖ i understand i  can't talk about znc Ö
00:41:37 <Erg[o]Proxy> sorry to bother you
00:41:40 <Erg[o]Proxy> bye !
00:42:24 <dmj`> WraithM: well well
00:43:23 <WraithM> dmj`: Hey!
00:46:20 <mcjohnalds> Documentation for template haskell is sparse. How would I go about rewriting this macro with template haskell? #define SET(field) (\x a -> a { field = x })
00:47:08 <ocharles> @tell roconnor yea, that's how I tend to do it
00:47:08 <lambdabot> Consider it noted.
01:00:33 <johnw> mcjohnalds: can you not use lens?
01:06:41 <mcjohnalds> johnw: I could use lenses but I really just wanted one specific function, plus I was learning how to do stuff with template haskell
01:22:31 <mgsloan> mcjohnalds: in GHCI: https://gist.github.com/mgsloan/4091aafe9907487d5cfb
01:22:31 * hackagebot hspec2 0.2.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.2.1 (SimonHengel)
01:22:56 <mgsloan> err actually, come to think of it, that use of ast quotes is a bit unncessary
01:23:41 <mgsloan> ah, it's rather nice as it introduces the x and a
01:29:00 <mcjohnalds> mgsloan: Oh wow thanks! I have much to learn about template haskell.
01:33:12 <mgsloan> welcome!
01:33:36 <mgsloan> A larger, but less fancy version would look like: $((\field -> return $ LamE [VarP (mkName "x"), VarP (mkName "a")] (RecUpdE (VarE (mkName "x")) [(field, VarE (mkName "a"))])) (mkName "t")) (T 10) 20
01:37:43 <sopvop> is there a TH module or some other way to derive Monoid, which just treats all fields as monoids?
01:39:26 <johnw> i've wanted that before too
01:40:25 <christiaanb> sopvop: http://hackage.haskell.org/package/generic-deriving-1.6.3/docs/Generics-Deriving-Monoid.html ?
01:40:28 <startling> me too.
01:41:02 <christiaanb> though it only seems to deal with product types
01:41:18 <startling> That's sane.
01:41:19 <johnw> how could it deal with sums?
01:41:36 <christiaanb> there are no sum monoids?
01:41:39 <sopvop> Yeah, that may do
01:41:41 <sopvop> thanks
01:41:55 <johnw> i mean, how could generically derive a Monoid from a sum type?
01:42:07 <christiaanb> ah, you can't
01:42:33 <johnw> it requires decisions about which constructor to use.  For example, Foo a = Foo | Bar | Baz a, is mempty Foo, or is it Bar?
01:42:43 <tdammers> sopvop: you can derive Monoid for a newtype over something that is a monoid already
01:42:49 <startling> what is Foo <> Bar?
01:42:56 <eikke__> undefined!
01:42:57 <tdammers> but other than that, there is no "correct" implementation for arbitrary types
01:43:02 <startling> yeah.
01:43:11 <tdammers> unless you provide one - but then you're no longer deriving
01:43:20 <startling> there are even multiple instances for record types whose fields are all Monoid!
01:43:20 <sopvop> tdammers: I know what -XGeneralizedNewtypeDeriving does
01:43:38 <sopvop> Though I'm yet to find out what will role checking do to my codes
01:53:44 <jtcwang1> with cabal sandbox, can i install existing package into the sandbox?
01:53:50 <jtcwang1> instead of dling them?
01:54:57 <supki> jtcwang1: you can pass a path to local .cabal file to cabal install
01:57:50 <t7> :t let f x = x in f (\x -> 123)
01:57:51 <lambdabot> Num a => t -> a
02:47:41 * hackagebot IsNull 0.3.0.0 - A typeclass to determine if a given value is null.  http://hackage.haskell.org/package/IsNull-0.3.0.0 (jcristovao)
02:53:15 <k0ral> What's the differences between (MonadThrow + MonadCatch) and MonadError ? I've used MonadError all over my code, is rewriting everything with MonadThrow/MonadCatch worth the effort ?
02:57:33 <jophish> Yo yo yo
02:57:44 <jophish> I'm trying to use associated types.
02:58:52 <jophish> I have: class C a where data D :: *; data A = A; data B = B; instance C A where data D = B;
02:59:09 <jophish> this seems to be defining B twice
02:59:49 <killy9999> does anyone remember which GHC version added support for open type families?
02:59:50 <jophish> or declaring B twice, actually
02:59:59 <jophish> killy9999: 7.0 I think
03:00:21 <jophish> It's in the docs for 7.0.4 at any rate
03:01:44 <killy9999> jophish: nope, release notes for 7.0 mention that tyfams were already present in earlier versions
03:01:51 <jophish> ah, sorry then
03:02:01 <b00thead> Hi Guys, is it still possible to give haskell-mode a path or command to run for cabal? I'm trying to move to a nix backed development environment and I miss haskell interactive
03:02:10 <merijn> jophish: In what sense is it defining B twice?
03:02:26 <jophish> merijn: that's the error GHC throws me, I'll try and get a small testcase
03:02:30 <b00thead> I guess another option would be to add another session type to haskell mode?
03:02:42 <supki> k0ral: if you are happy with MonadError then it's probably not
03:03:49 <jophish> merijn: http://lpaste.net/103803
03:04:09 <supki> k0ral: the difference is that m does not fix the kind of exceptions you can throw/catch
03:04:26 <supki> k0ral: (with MonadThrow/MonadCatch)
03:05:18 <merijn> jophish: Oh, actually, I see what's the problem, I think you don't want a data family but a type family...
03:05:33 <merijn> jophish: You're trying to write that "in this instance type D refers to type B", yes?
03:05:48 <jophish> yes, that exactly
03:06:00 <merijn> jophish: In general a nullary data family/type family like this is not very sensible
03:06:00 <jophish> s/data/type/
03:06:05 <jophish> oh
03:06:51 <merijn> jophish: Presumably you want something like this: http://lpaste.net/103803
03:07:08 <jophish> that exactly
03:07:17 <jophish> merijn: my situation is that my type checker and kind checker share a lot of code, and I want to abstract it over Type and Kind
03:07:22 <jophish> with a class TypeLike
03:07:34 <merijn> jophish: type families are type functions, they take arguments
03:07:35 <jophish> which has associated types for Type/Kind variables
03:07:53 <b00thead> Anyone know that the name of ^?! is from lens (and more generally to identify the name if any of lens operators)
03:07:56 <merijn> jophish: So in my example you have the type function 'D' which takes as argument a type and returns a new type
03:08:04 <b00thead> *what the name is
03:08:08 <merijn> jophish: In this case it's defined to that "D a = B" in your instance
03:08:16 <fizruk> :t (^?!)
03:08:17 <lambdabot> s -> Getting (Endo a) s a -> a
03:08:27 <merijn> jophish: So you can write functions "foo :: Foo -> D a" which are allowed to return different types for different instances
03:08:40 <jophish> merijn: I understand, it doesn't make any sense without an argument!
03:09:00 <fizruk> > Just 1 ^?! _Just
03:09:01 <merijn> jophish: For example given "type D Int = Bool" and "type D Char = Int" lets you have different return types for "foo" for different instances
03:09:01 <lambdabot>  1
03:09:05 <merijn> Anyhoo, lunch
03:09:12 <jophish> have fun
03:09:14 <jophish> Thanks, merijn
03:09:26 <supki> b00thead: there's no prefix alias for ^?!
03:10:14 <supki> b00thead: haddocks usually mention synonyms (for both operators and non-operators)
03:11:35 <k0ral> supki: right, sounds like a good enough reason to rewrite everything :)
03:14:54 <b00thead> supki, thanks.
03:17:15 <zgredzik> does anyone know a way to simplify the use of ImageAlias in the following code http://lpaste.net/103806 ? the way I have to do it now is a bit unhandy and requires providing the type of data held by the image manually in each func signature, which makes the ImageAlias quite useless
03:19:27 <pavonia> zgredzik: The kind of img is * -> *?
03:19:43 <pavonia> Ah, apparently it is
03:22:17 <danilo2> pavonia: yes it is. img is an array of a type
03:22:32 <danilo2> pavonia: (zgredzik will be back in a minute - I'm working with him)
03:23:05 <yesthisisuser> Does anyone know of a "Hello world" for using the Diagrams GTK+ backend?
03:24:23 <yesthisisuser> oh. wait.. there is a #diagrams channel. sorry
03:26:09 <pavonia> danilo2: Maybe you could do something like "type ImageDouble img = (Image img Double, img' ~ img Double)"
03:26:45 <zgredzik> pavonia: yes, I know that, the question is if there is any way to simplify the use of that Image class by making something like an alias that would set the second parameter to a fixed type, but in the end wouldn't require the repetition of that type in every signature?
03:27:53 <danilo2> pavonia: Hmm yes, but how would you use it? It shoudl be used as premise, so I do not see a way to use it in the code
03:27:55 <zgredzik> oh sry, didn't notice the conversation was already ongoing
03:28:58 <danilo2> pavonia: But I can be wrong of course. Additional, maybe there is a way to change the Image type class somehow, which would allow to use it nicer?
03:29:31 <danilo2> pavonia: to be honest I was never faccing a problem like this and right now I'm scratching my head looking for the most beautifull solution available
03:30:27 <pavonia> Hhm, I'm not sure
03:31:25 <fizruk> danilo2: so what‚Äôs the problem? you don‚Äôt want to repeat SomeVeryLongDataTypeDefinition twice? or is there smth else?
03:31:39 <pavonia> My idea was to use "xxx :: ImageDouble img => img' -> img' " with the synonym above
03:32:06 <pavonia> But I'Ve never tried if that use of ~ actually wokrs
03:33:07 <merijn> pavonia: No, img' is not in scope in the signature of xxx
03:33:26 <merijn> pavonia: Or in the type alias of ImageDouble, for that matter
03:33:28 <fizruk> that‚Äôs easily fixed by type ImageDouble img img‚Äô = ...
03:33:51 <merijn> Sure, but at that point is it really worth the effort?
03:34:33 <merijn> Is there a non-operator version of >>= ?
03:34:42 <merijn> oh...
03:34:49 <merijn> nvm, I'm dumb and want >=>
03:35:03 <pavonia> You could have a type synonym in the typeclass: F img b :: * = img b
03:35:16 <pavonia> Oh no :(
03:35:51 <fizruk> I tend to think that heavy usage of funky ghc extensions usually means I‚Äôm doing things wrong
03:36:25 <merijn> fizruk: I think you mean "doing things right" ;)
03:36:46 <pavonia> merijn: Did I understand you correctly, that use of ~ is not even allowed in the type synonym definition?
03:37:11 <pavonia> or constraint synonym in that case
03:37:13 <fizruk> pavonia: you need to get img‚Äô from somewhere (it‚Äôs not in parameters)
03:37:22 <ThePawnBreak> hi; is it somehow possible to do a pattern match like this? mL (x:x:y:y) = [x+x, y+y]
03:37:34 <pavonia> fizruk: "type ImageDouble img = (Image img Double, img' ~ img Double)"
03:37:37 <ThePawnBreak> I want to state that the first two values are equal, and the other 2 are equal
03:37:51 <vanila> ThePawnBreak, mL [x,x',y,y'] | x==x' && y==y' = [x+x,y+y]
03:38:11 <ThePawnBreak> vanila: without testing whether they are equal; can pattern matching do that for me?
03:38:27 <fizruk> merijn: no, why? i find it easy to abuse them and overcomplicate thing that don‚Äôt need that fancy stuff
03:38:41 <merijn> fizruk: That was tongue in cheeck :)
03:39:16 <merijn> fizruk: Mainly I tend to focus on "cleanest interface, regardless of number of extensions" if the extensions make my interface messier, they have to go. If they make it cleaner, great
03:39:19 <fizruk> pavonia: shouldn‚Äôt that be ‚Äútype ImageDouble img img‚Äô = (Image img Double, img‚Äô ~ img Double)‚Äù (note the LHS) ?
03:39:25 <merijn> RankNTypes for example is a godlike extension
03:39:58 <pavonia> fizruk: No, the idea was to introduce a shorthand for "img Double"
03:40:11 <pavonia> ThePawnBreak: You can pattern match like this but your usage on the right-hand side gives a type error
03:40:32 <pavonia> ThePawnBreak: Oh wait, I cmisread
03:40:40 <fizruk> pavonia: hm.. does that compile?
03:41:10 <pavonia> I can't try, my compiler here is too old
03:41:38 <merijn> ThePawnBreak: No, you can reuse the same variable multiple times to state that they're the same value in haskell
03:41:40 <danilo2> pavonia, fizruk: I'm sorry I've got a phone call. So the point is We want to write func sig (ImageDouble img => img -> img -> img) instead of (ImageDouble img => img Double -> img Double -> img Double) - as you can see its a little ugly (http://lpaste.net/103806)
03:41:58 <fizruk> merijn: agreed, but I found myself several times trying to use new extension the wrong way (existential anti-pattern, undecidable instances, incoherent instances, etc.)
03:41:59 <merijn> ThePawnBreak: You'll need an explicit equality test for that
03:42:15 <fizruk> merijn: and those usually come in packs
03:42:18 <merijn> fizruk: Right, but you're mentioning extensions that are all on the "bad/ugly" list
03:42:21 <ThePawnBreak> :(
03:43:13 <merijn> fizruk: I would say the only really worrisome extensions are: ExistentialQuantification, Undecidable/Incoherent (I would even consider Overlapping) Instances
03:43:50 <fizruk> merijn: ImpredicativeTypes?
03:44:02 <merijn> fizruk: Would be great, if it worked, which it doesn't
03:44:26 <merijn> fizruk: I already requested ImpredicativeTypes to get a "this is broken" warning
03:44:27 <fizruk> merijn: what do you mean?
03:44:55 <merijn> fizruk: Literally what I just said, the ImpredicatveTypes extension is broken and buggy and likely to be removed as it can't be used
03:45:27 <merijn> fizruk: Note that this dons answer https://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid mentions Undecidable/Incoherent/Overlapping to indicate design mistakes
03:45:33 <ThePawnBreak> what's wrong with this?
03:45:33 <ThePawnBreak> aux4 (a:b:c:d)
03:45:34 <ThePawnBreak>  | a == b && c == d = [a+b, c+d]
03:46:02 <ThePawnBreak>     Occurs check: cannot construct the infinite type: a0 = [a0]
03:46:02 <ThePawnBreak>     In the second argument of `(==)', namely `d'
03:46:05 <merijn> ThePawnBreak: d is a list, a b and c are not
03:46:19 <ThePawnBreak> how can I match a list of exactly four elements?
03:46:26 <fizruk> [a, b, c, d]
03:46:41 <ThePawnBreak> thanks
03:47:54 <pavonia> danilo2: If there's a unique mapping from "img b -> (img, b)" for each "Image img b" it could be possible with type families
03:48:37 <fizruk> merijn: I‚Äôve also run into a few cases when I was able to avoid RankNTypes (and couple more extensions) and that simplified things (can‚Äôt remember what I‚Äôve been doing though)
03:49:40 <fizruk> merijn: so I tend to think if a lot of extensions come ‚Äúout of nowhere‚Äù, perhaps I‚Äôve overdesigned this (so I should think a bit more about the overall design)
03:49:40 <danilo2> pavonia: Yes - (Image b) is just a { channels :: Map String (Matrix b)} , so yes it is the same, but the question is - if we know it is the same, maybe there is easier way to do it ?
03:52:44 <zgredzik> pavonia, fizruk: here's an example of an instance of Image http://lpaste.net/103807
03:52:55 <zgredzik> not sure if that clarifies anthin
03:52:59 <zgredzik> anything*
03:54:53 <zgredzik> pavonia, fizruk: the thing is there might be different types of images, depending on their color space, but we're working on a library that works with images that store their values as a specific data type (ie. Double)
03:55:00 <pavonia> danilo2, zgredzik: My idea doesn't work. I'm sorry, I can't help you with that
03:56:42 <zgredzik> fizruk, merijn: do you have any suggestions as to what could help to solve this problem?
03:59:30 <wojtekM_> Is it somehow possible to extract (hack) the value of of the tag from an algebraic data value?
04:00:44 <fizruk> zgredzik: danilo2: http://lpaste.net/103808 is it what you want?
04:02:31 <zgredzik> fizruk: sec :D
04:03:12 <pavonia> wojtekM_: With Data.Typeable maybe
04:03:54 <killy9999> jophish: actually you we';re right about type families being added in 7.0
04:03:59 <supki> wojtekM_: what's tag?
04:04:03 <jophish> :)
04:04:06 <fizruk> zgredzik: updated paste: http://lpaste.net/103808
04:04:09 <killy9999> oh, wait
04:04:21 <killy9999> well, they were initially added in 6.8
04:04:30 <killy9999> but not everything was implemented
04:04:36 <wojtekM_> supki: the low level implementation specific tag
04:04:56 <wojtekM_> data Test = Test0 | Test1 Int
04:05:05 <pavonia> supki: The data constructor
04:05:06 <zgredzik> fizruk: well that seems eligible, let me contemplate on that for a moment
04:05:18 <wojtekM_> getTag :: Test -> Int -- or Int# or whatever
04:05:26 <zgredzik> unfortunatelly my understanding of haskell is not as good as danilo2's and I need more time to analyse if this is what we're looking for :P
04:05:41 <killy9999> jophish: sorry, the first full implementation seems to be in GHC 6.10
04:06:19 <pavonia> wojtekM_: Apparently you want something different
04:07:13 <wojtekM_> pavonia: Yes, I want something strange
04:08:02 <pavonia> unsafeCoerce :: Test -> Int?
04:09:08 <wojtekM_> pavonia: Hmm, maybe, let me try
04:10:00 <zgredzik> fizruk: that seems to work just as required and is way more pleasant to use than what we had, thank you very much :) In case of emergency I'll bug you a bit more
04:10:41 <fizruk> yw :)
04:10:50 <ThePawnBreak> there was a function that 'merged' equal consecutive elements, like this: f [2, 2, 2, 3, 3, 4, 5, 5, 2] = [2, 3, 4, 5, 2]; does anybody know what it's called?
04:11:14 <pavonia> nub
04:11:32 <pavonia> > nub  [2, 2, 2, 3, 3, 4, 5, 5, 2]
04:11:34 <lambdabot>  [2,3,4,5]
04:11:51 <pavonia> Oh, consecutive
04:12:07 <fizruk> > map head . group $  [2, 2, 2, 3, 3, 4, 5, 5, 2]
04:12:09 <lambdabot>  [2,3,4,5,2]
04:14:36 <danilo2> pavonia: I think this is what we was looking for. I'm right now only thinking if this is the nicest way of expressing such type, or should be used something else (like just creating an alias for longtype and using it everywhere we use type var "a" now)
04:14:37 <ThePawnBreak> thanks
04:15:01 <danilo2> pavonia: Sorry, that message was ment to be sent to fizruk (^^^)
04:16:33 <fizruk> danilo2: sure, you can leave only ImageAlias constraint and use type synonym for LongTypeDefinition
04:16:34 <wojtekM_> pavonia: I don't think it works, it returns a different value every time
04:18:39 <pavonia> wojtekM_: Yeah, I guess it really depends on how GHC works internally
04:19:06 <wojtekM_> pavonia: definitely
04:25:25 <fizruk> > Just 1 ^?! template :: Integer  -- wojtekM_
04:25:26 <lambdabot>  1
04:25:46 <fizruk> :t template
04:25:47 <lambdabot> (Applicative f, Typeable a, Data s) => (a -> f a) -> s -> f s
04:26:41 <fizruk> :t template :: (Typeable a, Data s) => Traversal' s a
04:26:42 <lambdabot> (Applicative f, Typeable a, Data s) => (a -> f a) -> s -> f s
04:28:46 <fizruk> > [Just (Left 1), Just (Right "123")] ^?! template :: Integer
04:28:48 <lambdabot>  1
04:28:53 <fizruk> > [Just (Left 1), Just (Right "123")] ^?! template :: String
04:28:54 <lambdabot>  "123"
04:31:51 <danilo2> fizruk: thank you. In reality maybe the simple type aliases would be better. I have to think about it a little longer, but right now I have to fast fix something.Thanks :)
04:31:52 <jophish> When I'm constructing Kinds, I can have * or Kind -> Kind.
04:32:03 <jophish> It's true that both these expressions have super-kind BOX
04:32:27 <fizruk> jophish: yes (if that was a question)
04:32:53 * hackagebot stable-memo 0.2.3 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.2.3 (JakeMcArthur)
04:32:55 * hackagebot stable-memo 0.2.4 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.2.4 (JakeMcArthur)
04:33:24 <jophish> Is it useful to think of the (->) in 'Kind -> Kind' a kind constructor. If so, what would it's superkind be, BOX, or BOX -> BOX -> BOX
04:34:06 <jophish> Or should (k1 -> k2) be treated as an opaque construction?
04:34:26 <jophish> I suppose if it's not of superkind BOX, then the tower never stops!
04:34:56 <FireFly> I wonder if there's a name for (type, kind, ...)
04:35:13 <jophish> FireFly: I was wondering that the other day
04:35:22 <fizruk> jophish: iiuc, BOX -> BOX super-kinds do not themselves give rise to higher kinds
04:35:24 <jophish> You could add 'term' to the beginning of that list
04:35:26 <fizruk> FireFly: universe?
04:36:12 <jophish> FireFly: but there is a (->) in (BOX -> BOX), isn't that a super-kind constructor, with a super-super-kind type?
04:36:34 <FireFly> s/FireFly/fizruk/ (presumably)
04:36:48 <jophish> ah, here is what I wanted to ask. Is (->) the only higher kind constructor?
04:37:06 <jophish> s/higher kind/kind/
04:37:24 <ij> I don't need it, but I got really curious ‚Äî how/can you make anything an instance of ->, so that I could apply arguments to it like to a function? Even say Integer?
04:37:42 <jophish> as in, is (->) the only thing that kinds can themselves be applied to?
04:38:34 <fizruk> ij: how can you make an instance of Bool? the answer should be pretty much the same
04:38:46 <FireFly> fizruk: I'm thinking if there's some common term such that the concept "type" would be rank-1 and the concept "kind" would be rank-2, and "kinds of kinds" would be rank-3, and so on
04:38:51 <FireFly> if that makes sense
04:39:07 <fizruk> FireFly: I believe this is ‚Äúuniverse‚Äù
04:39:12 <FireFly> Oh, okay
04:39:20 <fizruk> FireFly: as in type theory
04:46:41 <jophish> Answering my own question: not in Haskell98, but DataKinds enables Kind constructors
04:48:51 <jophish> Although I don't think one can write kind synonyms
04:51:15 <fizruk> jophish: in 7.10 they are going to promote everything: e.g. you might have kind families
04:51:33 <ij> fizruk, I see, but hasn't this done that: http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Printf.html#t%3APrintfType
04:53:08 <jophish> fizruk: blimey
04:53:19 <jophish> back in a bit
04:53:51 <vanila> ij, it's not Integer is a function
04:54:13 <vanila> ij, it's that the type class can be instantiated as String, or Integer -> String, or Integer -> Integer -> String
04:54:51 <vanila> ij, so it is as if this one function can have different numbers of arguments - but really type class dispatches into different functions
04:55:15 <ij> Well okay, but how does it do that?
04:55:32 <vanila> it's using type classes
04:55:46 <vanila> a recursive one, to allow you to make as many parameters as you like
04:55:57 <vanila> do you want me to make a simplified example
04:56:08 <ij> Ah, it's the recursivity, that I didn't notice.
04:56:21 <ij> No, I think I got it now, thanks.
04:56:25 <vanila> okay :)
04:58:10 <hexagoxel> after cabal-installing cabal-install, cabal-installing hoogle runs into dependency problem :/ (7.8.2)
04:58:39 <hexagoxel> (other way round works though)
05:00:58 <nh2> hexagoxel: what's the error
05:04:59 <hexagoxel> nh2: relevant info probably is "parsec-3.1.5 (reinstall) changes: mtl-2.2.0.1 -> 2.1.3.1" "network-2.5.0.0 (reinstall)" and "likely to be broken by reinstalls: HTTP-4000.2.15"
05:05:16 <hexagoxel> nh2: tbh i did not check whether forcing the reinstall caused actual problems
05:05:50 <quchen> Hoogle is a standalone executable, isn't it? Always build those in a sandbox.
05:06:02 <quchen> (And usually, build everything else in sandboxes as well.)
05:07:34 <hexagoxel> yeah i was only using non-sandboxes for those executables (because i wanted them to be available globally)
05:08:42 <quchen> When you link your executable statically you can just move the exe to your $PATH and delete the sandbox.
05:09:35 <quchen> Or you can probably say `cabal install --bindir=FOOBAR` as well.
05:13:12 <wojtekM_> :i template
05:14:04 <quchen> Lambdabot doesn't have :i. It's not a GHCi session.
05:15:15 <wojtekM_> fizruk: Where's template defined?
05:15:16 <hexagoxel> quchen: is there an automated process for this (installing in sandbox, placing executable in suitable directory, then removing sandbox again)?
05:15:45 <pja> ?
05:16:09 <pja> ?
05:16:15 <hexagoxel> (i am aware that a short shellscript can do the job..)
05:19:21 <hexagoxel> quchen: anyway, thanks, i will use sandboxes
05:24:17 <quchen> hexagoxel: There's a "--user" flag that "Enables doing a per-user installation", but I'm not sure what that does exactly.
05:25:14 <quchen> So the automated process would be "cabal fetch X && cabal configure && cabal build && cabal install --user" or something along those lines.
05:25:43 <quchen> I'm not aware of a "do this on your own" flag, like "cabal install --sandboxed-executable" or something along those lines.
05:28:09 <hexagoxel> quchen: afaik cabal install is --user by default (and i do not have a custom cabal config)
05:28:48 <hexagoxel> and i do not think that --user is equivalent to sandboxed
05:29:27 <quchen> Hmm, nevermind then. I just looked through `cabal install --help` and saw that flag.
05:37:15 <fizruk> wojtekM_: Data.Data.Lens
05:38:35 <ast_> Anyone using gnuplot with haskell? Using gnuplot module is it possible to set the output size for png files? Can't find it in docs.
05:39:35 <aspidites> anyone know of any "programming" games for haskell? not code challenges, but games where you have to code. for example, i know of code combat for javascript
05:41:31 <roconnor> aspidites: not haskell specific, but http://boundvariable.org/
05:42:21 <quchen> Absolute beginner question time! zipWith discards the contents of the longer list. Is there a standard way of getting these discarded values? I've simply been writing my own 'zipOverflow' function all the time.
05:43:24 <quchen> > let zipOverflow [] xs = xs; zipOverflow xs [] = xs; zipOverflow (_:xs) (_:ys) = zipOverflow xs ys in zipOverflow [1..10] [1..12]
05:43:26 <lambdabot>  [11,12]
05:43:34 <aspidites> ast_: i know exactly nothing about gnuplot, but checking the documentation for Graphics.Gnuplot.Simple, I'd have guessed that feeding a size attribute to one of the plot* functions would have doe the trick
05:44:20 <aspidites> roconnor: thanks. i'll have a look. once i find a toolkit that I like and installs easily on linux, mac, and windows,  i have plans for a "functional" series of games
05:45:18 <aspidites> first couple which already have design documents are called "Functional: The Roleplaying Game" and "Functional: The Trading Card Game", or Fun:RPG and Fun:TCG for short
05:45:28 <ast_> aspidites: thanks, but it does apply only to "simple" interface, I'm using "advanced" though
05:46:06 <benzrf> aspidites: make a TCG based on the lambda calculus
05:46:07 <benzrf> :-D
05:46:26 <aspidites> benzrf: i think something similar has already been done. mathrl if i remember correctly
05:46:27 <roconnor> aspidites: see lambda the gathering @ http://icfpc2011.blogspot.ca/2011/06/task-description-contest-starts-now.html
05:47:03 <aspidites> i was looking for non-contests -- casual games that revolve around functional programming as it were
05:47:13 <fizruk> quchen: maybe Data.Align has something for you?
05:47:26 <roconnor> aspidites: these contents are over, so they are now casual games
05:47:27 <aspidites> that said...that's looking pretty interesting
05:47:39 <aspidites> roconnor: touche (sorry i'm missing the accent)
05:47:49 <roconnor> no worries
05:48:48 <fizruk> quchen: smth like `catThat (align xs ys)`
05:48:52 <fizruk> :t align
05:48:53 <lambdabot> Not in scope: ‚Äòalign‚Äô
05:48:57 <roconnor> man, that zombie card is so deceptively evil.
05:49:16 <quchen> fizruk: I'm sure it's in a package somewhere, but I was wondering whether a standard function (or small combination of them) could accomplish that.
05:49:25 <roconnor> aspidites: anyhow, that boundvariable.org is soooooooo good.
05:49:30 <quchen> Adding a dependency for such a small function seems wasteful :-)
05:50:16 <fizruk> quchen: drop (length xs) ys  then ?
05:50:35 <fizruk> quchen: oh you want both
05:51:36 <aspidites> yeah. just reading through the task desciption i feel like i'm playing dnd for hackers or something
05:51:54 <aspidites> not saying that's a bad thing, lol
05:52:47 <roconnor> aspidites: no matter what you think of the task description for boundvariable.org, bad or good, the actual game is so much more unbelivably awesome the the description entails.
05:53:37 <roconnor> but you don't find this out until you run the codex.
05:54:20 <aspidites> ah.
05:54:30 * aspidites bookmarks boundvariable.org
05:54:31 <vanila> the UM one?
05:54:38 <roconnor> vanila: yes
06:05:07 <aphury> I‚Äôm trying to abstract any context of my approach of a parser in Haskell. So therefore I need some ‚Äûinterfaces‚Äú because some functions need a context which is tracking the amount of parsed lines, the indention, etc. In fine: How to make this (http://lpaste.net/103810) idea more haskellish?
06:10:38 <zgredzik> can anyone explain to me why this chunk of code fails to compile? http://lpaste.net/103815
06:12:01 <cin> aphury, why are you trying to abstract those things away?
06:12:05 <sopvop> zgredzik: image is a class not type
06:12:41 <wojtekM_> I can't compile GHC Core, can I?
06:13:20 <aphury> cin, I want to build a parser toolkit, so I can just import the module and then define my context as I need it.
06:13:23 <cin> wojtekM_, with the ghc api you can. with the ghc executable directly, not sure
06:14:57 <cin> zgredzik, afaict you're trying to get a concrete type out of a generic (type-class polymorphic) type, but the img variable hasn't been instantiated with a concrete type, so the resolution is ambiguous
06:15:19 <zgredzik> sopvop: hmm, is there any way to to define a type alias that would explicitly set one of the class' parameters to a specified type, leaving the other one unset?
06:15:20 <cin> aphury, how does your approach compare to parsec's approach of user state?
06:17:01 <cin> aphury, i.e. parsec manages user state via a type parameter `s' http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#t:ParsecT
06:18:04 <zgredzik> cin: ouch, is it even possible to define a type alias that would expicitly state one of the type params of a class in it's constraints?
06:18:05 <sopvop> zgredzik: try type ImageDouble img =... , though maybe constraint on RHS will still introduce new img0 or something, I'm not sure :)
06:18:22 <aphury> cin, well, my parser type is something like newtype Parser c a = Parser (c -> (Result a))
06:18:38 <aphury> where c is the ‚Äûuser-state‚Äú or context.
06:18:58 <aphury> but I‚Äôm not quite sure because I haven‚Äôt had a deeper look into Parsec yet.
06:19:21 <cin> oh, i see. the actual tokens are contained inside c?
06:19:28 <aphury> yes.
06:19:38 <cin> right, that's different then
06:20:29 <zgredzik> sopvop: doesn't seem to change anything
06:20:40 <cin> i said the wrong var, btw, parsec has 's'  for its state and 'u' for user state, it seems like you want to just have one
06:21:11 <aphury> uhm, what‚Äôs inside that state @parsec?
06:21:20 <mmmm_> http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Prim.html#ParsecT
06:21:24 <cin> stream of tokens
06:21:32 <sopvop> zgredzik: hm, maybe -XScopedTypeVariables, but most likely you can't
06:21:39 <aphury> ah, okay. Well, yeh, I do want both together.
06:22:37 <cin> so far i think i would probably do the same
06:23:06 <cin> but it's hard to tell without seeing it in action
06:23:42 <cin> hmm, yeah
06:23:42 <aphury> the hole idea is highly inspired by http://www.cs.nott.ac.uk/~gmh/pearl.pdf
06:24:04 <cin> your library  would export some generic 'c' type but the user would have to implement a couple methods so that their own type is customizable
06:24:13 <aphury> yeh.
06:24:52 <cin> another approach is that you have a record
06:24:53 <cin> like
06:25:30 <cin> data ParserType s = ParserType { setLine :: s -> Int -> s, setIndent :: s -> Int -> s }
06:25:42 <cin> and then the user passes that in, to the parser
06:25:52 <cin> along with their custom data structure.
06:26:28 <aphury> and within the module I‚Äôm using ‚ÄûsetLine‚Äú and ‚ÄûsetIndent‚Äú ?
06:26:39 <aphury> ah, I see.
06:26:41 <cin> yeah
06:27:23 <cin> i suppose it depends whether you want to distinguish between actions in your parser that do line/indent changes
06:27:40 <cin> if you go with the type-class approach, you'll that reflected in the class constraints of all your combinators
06:28:22 <cin> but if you don't care much about that, the record is basically the same
06:30:29 <aphury> then I‚Äôll go with the type-class approach. Beforehand I had some trouble to distinguish those ‚Äûsoft-state‚Äú changing actions from not changing ones.   : )
06:30:52 <cin> makes sense :)
06:32:12 <aphury> cin, thanks a lot  : )
06:32:31 <cin> welcome!
06:32:36 <DogeHayashi> having to do a group project in Java, it's slowly killing me ;_;
06:32:53 <aphury> pain involved?
06:33:06 <cin> killing you softly with his classes
06:33:35 <aphury> sometimes slow killing is painless but only definite.
06:43:08 * hackagebot fay 0.20.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.1 (AdamBergmark)
06:43:34 <hexagoxel> now when i try to install (in a clean installation) applications (such as happy, cabal-install, hoogle, pointfree) by building them in separate sandboxes, i get linker errors :S
06:44:21 <hexagoxel> ah wait, no. maybe i did not statically link the executables hmm
06:47:45 <hexagoxel> how would i specify that i want static linking?
06:50:20 <hexagoxel> i currently create a sandbox, cabal install foo, grab the executables from .cabal-sandbox/bin/, delete the sandbox
06:50:57 <jonke>  ghc --make -static  ?
06:52:50 <jonke> maybe you must edit your cabal file under library section
06:53:34 <hexagoxel> so instead of "cabal install foo" "cabal fetch foo, vim foo.cabal, cabal configure, cabal install" or something..
06:55:24 <jonke> are we talking cabal 1.20 or what version?
06:57:25 <hexagoxel> ghc 7.8.2, cabal 1.20
06:58:11 * hackagebot esqueleto 1.4.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.1 (FelipeLessa)
06:58:39 <jonke> and you have followed they way the almighty tibbe says ? http://blog.johantibell.com/2014/04/announcing-cabal-120.html
07:01:48 <zgredzik> does anyone have any idea why the compilation fails in this example? http://lpaste.net/103818
07:02:55 <arj> For a function f :: Monad m => b -> m a  I use the monad for error reporting, i.e. I call fail in f if something bad happens. Now, is there a monad instance that I could use that just runs the function and gives a specified default value if it fails?
07:03:16 <arj> or do I have to write it myself?
07:03:26 <hexagoxel> jonke: no, i still use "cabal install" (as mentioned). interesting, thanks
07:03:30 <c_wraith> zgredzik: I suspect the issue is that you need a higher-ranked type to express what you actually mean..  But I'm having trouble actually following that code to be sure of it.
07:04:33 <zgredzik> c_wraith: anything I could explain in more detail to make it clearer?
07:04:48 <c_wraith> zgredzik: nah.  The biggest help would be if I was more awake. :)
07:04:55 <zgredzik> :D
07:07:13 <c_wraith> zgredzik: you might try asking in #haskell-lens
07:07:31 <flebron> What's something I can do with a DataKinds Nat which doesn't involve GADTs?
07:08:56 <c_wraith> flebron: anything where you treat the value in the type as input to your functions.
07:09:11 <supki> zgredzik: the first problem is channels is not a type changing lens
07:09:48 <c_wraith> flebron: edwardk was working on a fixed-precision math library that used a type-level Nat to indicate the precision
07:10:14 <c_wraith> flebron: that sort of thing works with the current Nat implementation
07:10:39 <flebron> Hrm... so a set of functions for Double 64, for example?
07:10:56 <flebron> Well, it'd be stored as Integer, but represent a Double-precision 64-bit thingie.
07:11:22 <c_wraith> well, a set of functions for D n, that use n as an input for how they work.
07:11:54 <flebron> Why couldn't it use D Int and test on that?
07:12:07 <flebron> Optimization?
07:12:08 <supki> zgredzik: another is that f should be :: (Maybe a -> Maybe b), I think, given what Map contains
07:12:34 <c_wraith> flebron: that would be moving the input to the value level, instead of the type level
07:13:11 <c_wraith> flebron: the whole point of having it in the type is that you can enforce things like (+) :: D n -> D n -> D n
07:13:25 <flebron> Oh, right!
07:13:26 <c_wraith> flebron: so that you know the precision isn't changed by basic arithmetic
07:20:15 <albeit> If I use up all the memory in my computer, but without a stack overflow, is that called a heap overflow?
07:22:04 <awestroke> out of memory exception
07:22:12 <awestroke> ?
07:23:13 * hackagebot haskell-names 0.4 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.4 (RomanCheplyaka)
07:27:46 <zgredzik> supki: yeah, silly mistake with that f function, but could you elaborate on the type changing lens part?
07:28:23 <zgredzik> supki: nvm, I think I got it
07:28:32 <zgredzik> supki: thanks a lot
07:29:14 <flebron> When writing the typical Vector :: * -> Nat -> *, I'm writing zip' :: Vector a n -> Vector b n -> Vector (a, b) nn. In my cases, Haskell's complaining I don't match zip' Nil (Cons _ _) or zip' (Cons _ _) Nil... why isn't it realizing there's no way to unify those types?
07:29:40 <flebron> (Nil :: Vector a Z, Cons :: a -> Vector a n -> Vector a (S n))
07:29:53 <ocharles> Am I right in thinking all functions that end in () are equal?
07:30:20 <ocharles> (modulo undefined, as always...)
07:32:22 <alorente> pure functions whose types end in () are equal (and not of much use). Functions that end in `IO ()` or `MonadIO m => m ()` are potentially-side-effecting computations
07:32:36 <ocharles> yes, but a function ending in IO () is not what I'm talking about
07:32:54 <flebron> (If I actually define the cases GHC wants, then it complains that it's a type error!)
07:32:58 <ocharles> a building that function might not be useful, but it's useful for showing a functor that has (Int -> n) by fixing n ~ ()
07:33:15 <alorente> ah, sure
07:33:32 <ocharles> I could (in theory) define Eq (a -> ()) eq _ _ = True
07:33:43 <zgredzik> supki: nope, I didn't get it; would you mind elaborating a bit on the part of "channels is not a type changing lens" ?
07:37:10 <albeit> I have a function that is overrunning my memory, and using profiling the largest users of memory are the type [] and the : constructor. I'm guessing it is this line, which generates variables that are used later: "(_:_:times:bps:bss:aps:ass:_) = splitOn "|" str". How can I make that less memory intensive?
07:37:56 <vanila> that line looks fine to me
07:38:25 <vanila> I think it's something else
07:39:20 <albeit> vanila: Would you mind taking a a look at the relevant code?
07:39:37 <vanila> sure I will look
07:40:25 <albeit> Awesome! This is the code: http://lpaste.net/103820. If I change outputLine to "= replicate 100 'A'" it all works fine, no memory run-out, so something in there is bad.
07:41:10 <supki> zgredzik: channels :: forall f. Functor f => (Map String (Maybe t) -> f (Map String (Maybe t))) -> img t -> f (img t)
07:41:24 <supki> zgredzik: there's no way to get from img a to img b with it
07:42:11 <flan3002> Does 'No instance for (Floating t0) arising from a use of `sqrt'' want to tell me that I shall specify whether to use Doubles or Floats?
07:43:41 <supki> zgredzik: type-chaning lens would be channels :: Lens (img s) (img t) (Map String (Maybe s)) (Map String (Maybe t))
07:43:44 <vanila> albeit, hm what about changing it from printf to manually show timestamp ++ " " ++ show expiry ++ ... -- just to see its printf causing the problem?
07:44:04 <jorr> flan3002: Context?
07:44:31 <albeit> vanila: Okay, I'll see what happens. If I hardcode values for times, bps, bss, ... it also works.
07:44:53 <vanila> oh
07:44:57 <vanila> then it wont be printf, I think
07:45:26 <jorr> flan3002: That's probably what it is, can you provide a link to the code?
07:45:53 <yesthisisuser> what is the reason is for using, e.g., "void initGUI" as opposed to just initGUI? http://www.cmears.id.au/articles/diagrams-gtk-mouse.html
07:45:53 <albeit> vanila, : Maybe splitOn? It's from the Data.List.Split external library
07:45:56 <flan3002> jorr: It's a *really* simple program, just some stupid primes. The full error is at http://ix.io/caA the code is at http://ix.io/caB
07:46:41 <vanila> I think splitOn would be ok, trying to see if there's anythig else it could be but I'm really not sure
07:46:45 <flan3002> It's my first Haskell program...
07:46:46 <jorr> flan3002: Can you try doing like [2.0..] instead of [2..]?
07:47:01 <byorgey> yesthisisuser: probably just to avoid a warning
07:47:20 <jorr> flan3002: So what's probably happening is the list comprehension [2..] is generating integers.
07:47:22 <quchen> yesthisisuser: 'void' makes it explicit that you're discarding the value computed by initGUI, and just want its side-effects.
07:47:40 <jorr> Alternatively, you can do (I think?) something like fromIntegral on n when you take the sqrt
07:47:50 <flan3002> jorr: It still fails with http://ix.io/caC . What's the problem with it generating integers?
07:47:55 <albeit> vanila: Hmm if I give splitOn a literal string, it also runs out of memory. Something about the line is wreaking havoc
07:47:59 <yesthisisuser> quchen, byorgey: ah. ok.. well that makes sense
07:48:00 <quchen> yesthisisuser: A prominent example is "void (forkIO ...)", which discards the ThreadID generated by forkIO.
07:48:00 <jorr> The problem is that sqrt is only defined on flaty things, not all ints.
07:48:06 <jorr> *floaty
07:48:19 <jorr> > :t sqrt
07:48:21 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
07:48:55 <jorr> flan3002: At the REPL, do :t sqrt... the problem is, the sqrt of an int will generally not be an int.
07:49:10 <vamega> Hey.
07:49:22 <quchen> :t sqrt
07:49:23 <lambdabot> Floating a => a -> a
07:49:26 <vanila> albeit, well okay - how about trying with a manual split function in the code like   split acc [] = [acc] ; split acc ('|':s) = acc : split "" s
07:49:31 <jorr> flan3002: sqrt :: Floating a -> a
07:49:40 <vamega> If I want to define (-) over a data type that I created.
07:49:41 <flan3002> jorr: But when rounded? It doesn't even work with fromIntegral $ round $ sqrt n.
07:49:45 <jorr> flan3002: Which means it won't change types - the type of both must be the same
07:49:52 <vanila> albeit, so if you use split "" str instead of that splitOn part, is that better?
07:49:55 <dna8> anybody now of a nice way to achieve a zip of [a] and [a] where the output is [[a]] instead of [(a,a)]   (each sublist has only two elements)?
07:49:59 <vamega> This should be sufficient right?
07:50:00 <vamega> (-) :: HistData -> HistData -> HistData
07:50:00 <jorr> flan3002: you want round $ fromIntegral $ sqrt n
07:50:07 <quchen> dna8: Data.List.transpose
07:50:10 <jorr> flan3002: NO NO type sorry
07:50:13 <albeit> vanila: Checking now
07:50:28 <jorr> flan3002: round $ sqrt $ fromIntegral n
07:50:45 <jorr> flan3002: fromIntegral makes it floaty, then you can sqrt and round it.
07:51:04 <jorr> flan3002: if that doesn't work I'll fire up a REPL and fool around a little.
07:51:22 <dna8> quchen: works, thanks!
07:51:26 <quchen> Note that in this "round-sqrt" algorithm, wildly wrong things can happen when your numbers are too large.
07:51:44 <vanila> there should be an isqrt ?
07:52:30 <albeit> vanila: Actually, if I remove any splitting and just give  use a hardcoded list, it still fails.
07:52:36 <flan3002> jorr: It works, thank you. I had to change 2.0 to 2 though.
07:53:05 <vamega> Why would I get an ambiguous reference issue when trying to use that on two Ints?
07:53:17 * hackagebot hpuz 1.1.2 - Haskell bindings for libpuz  http://hackage.haskell.org/package/hpuz-1.1.2 (ChrisCasinghino)
07:53:24 <vamega> Since my custon (-) function only works on HistData's.
07:54:41 <jorr> flan3002: good! Does the sqrt type part make sense?  sqrt won't change types, so it can't take an int and give a float.  You have to use it from one floating type to another, so you have to make the arguments floating.
07:55:20 <jorr> flan3002: The numerical tower is Haskell can be weird to work with coming from weakly typed languages that will do those implicit conversions for you.
07:55:55 <flan3002> jorr: Yes, it does make sense. I just didn't understand fromIntegral and why it was needed. I do now, thanks.
07:56:34 <rwbarton> albeit: all those [] and : constructors are the *Strings* being stored in bps, bss, etc. for later use (recall String = [Char])
07:57:08 <klrr_> anyone know how to solve this compile error? trying to compile sanitize-xss http://paste.debian.net/98264/
07:57:24 <rwbarton> you're storing much of your input file in memory in String format; very inefficient
07:57:29 <jorr> flan3002: :)
07:58:52 <rwbarton> albeit: try something like convertLine expiry str = timestamp `seq` bp `seq` bs `seq` ap `seq` as `seq` (timestamp, outputLine)
07:58:54 <albeit> rwbarton: Makes sense, but why isn't it being deallocated as I go alogn?
07:59:11 <albeit> rwbarton: Okay I'll try that
07:59:12 <rwbarton> because it's needed so you can evaluate it later
07:59:43 <rwbarton> well, it looks like you never actually use the values stored in the Map?
07:59:52 <rwbarton> but GHC has no way to see that
07:59:59 <albeit> rwbarton: Not yet, but I will later.
08:00:11 <albeit> rwbarton: was just trying to get this part working first
08:00:35 <rwbarton> ah okay
08:00:37 <klrr_> join #powertop
08:01:25 <Clint> @where ops
08:01:25 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:01:46 <byorgey> Clint: ?
08:01:51 <Clint> byorgey: #happs
08:02:16 <albeit> rwbarton: Magic! Worked fantastic. Should I be using Data.Text instead? Would I not need to use the strict evaluations if I did?
08:03:49 <glguy> Clint: Very few of the people on that list have any powers in #happs. Try: /msg chanserv access #happs list
08:07:09 <Clint> glguy: yeah, i i already did
08:07:12 <Clint> er
08:07:23 <jophish> How often do people have to deal with mutually recursive modules?
08:07:50 <jophish> I have two classes which both have functions which depend on each other
08:08:20 <rwbarton> albeit: actually I lied slightly
08:08:47 <rwbarton> "(_:_:times:bps:bss:aps:ass:_) = splitOn "|" str" is a lazy binding since it's in a where block
08:09:19 <rwbarton> so, in your original program, the splitOn will be evaluated as far as the 'times' field (since it's needed for the Map key) but no further
08:09:36 <rwbarton> and so what you were storing was the rest of the line
08:10:18 <spockshock> what is a good link for reading up on cabal-install proceedure
08:10:19 <rwbarton> You could use Data.Text but then you'd still be storing essentially the entire input in your Map, but in a more memory-friendly format, at least
08:10:47 <albeit> rwbarton: So, in either case, I'd probably have to force evaluation of the rest of the line anyways?
08:11:02 <vamega> Hi. I took the time to write out a question I was asking yesterday as an lpaste.
08:11:13 <vamega> http://lpaste.net/103821
08:11:37 <vamega> If anyone could take a look at it I'd really appreciate it.
08:11:57 <vamega> My understanding is that the HistData in that file could be represented as a Monoid?
08:12:34 <rwbarton> albeit: by forcing those fields that are used in outputLine you encourage GHC to represent the result String as a delayed computation in which the arguments to printf are already evaluated
08:13:14 <rwbarton> albeit: alternatively, you could just fully evaluate the result of printf. probably about the same
08:13:19 <c_wraith> vamega: Data.Map has functions for combining two maps with an arbitrary function.
08:13:27 <vamega> c_wraith.
08:13:35 <albeit> rwbarton: With deepseq?
08:14:35 <c_wraith> vamega: I *think* unionWith can do what you want
08:14:51 <vamega> Yeah. That would do it.
08:14:58 <vamega> Thanks.
08:14:59 <nclarke> vamega: Why do you want histdata zeroed if it only exists in one map?
08:15:14 <nclarke> That's the only bit that unionWith wouldn't deal with
08:15:37 <croyd> nclarke: I think it means diff against zeros
08:15:42 <nclarke> Ah, I see
08:15:49 <vamega> Yeah.
08:15:55 <vamega> For example
08:15:56 <nclarke> In that case, yeah, unionWith is your chap :-)
08:16:01 <vamega> If one of the entries is 50
08:16:06 <vamega> and the other has no entry.
08:16:18 <vamega> Then I want the resulting value to be -50
08:16:18 <nclarke> Although your diff is non-symmetrical
08:16:30 <vamega> Symmetrical in what sense?
08:16:35 <c_wraith> vamega: yeah, the big problem is the non-symmetry.  Doesn't quite work with unionWith
08:16:49 <nclarke> diff a b /= diff b a
08:16:54 <vamega> Yeah.
08:16:58 <vamega> That's expected.
08:17:19 <nclarke> I don't know whether unionWith guarantees an ordering
08:17:35 <nclarke> It *probably* does, but I don't think there's a guarantee
08:18:21 <c_wraith> I don't think unionWith actually solves this.
08:19:08 <vamega> c_wraith, why not.
08:19:11 <vamega> Looks like what I want.
08:19:37 <vamega> I don't care whether unionWith does f a b or f b a
08:19:46 <nclarke> Okay
08:19:49 <vamega> Just that it does so consistenly over the map.
08:20:00 <c_wraith> It won't be consistent in the way you think, I'm guessing.
08:20:09 <vamega> i.e. It shouldn't take f map1Value map2Value for one key
08:20:19 <vamega> And f map2Calue map1Value for another key.
08:20:38 <c_wraith> The problem is when a value is present in only one map
08:20:49 <c_wraith> In that case, unionWith will just take the value in that map
08:20:59 <c_wraith> But you want to negate it half the time
08:21:05 <klrr_> trying to compile sanitize-xss http://paste.debian.net/98264/ , anyone got an idea how to solve this?
08:21:07 <c_wraith> Depending on which map it came out of
08:21:15 <vamega> Ah yes.
08:21:18 <vamega> That makes sense
08:22:11 <nclarke> You could manage this with `mergeWithKey`
08:22:34 <nclarke> Which lets you specify different functions to apply to 'only on the left' and 'only on the right'
08:22:35 <vamega> nclarke I'm looking at that now.
08:23:06 <c_wraith> mergeWithKey is kind of terrifyingly complex. :)
08:23:10 <vamega> I was also thinking of getting the difference between the keysets of a b and b a
08:23:22 * hackagebot RepLib 0.5.3.3 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.3.3 (BrentYorgey)
08:23:24 * hackagebot unbound 0.4.3.1 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.3.1 (BrentYorgey)
08:23:50 <vamega> And just adding those keys to the respective maps with values of HistData 0 0
08:25:26 <c_wraith> looks like mergeWithKey isn't terrible, though.
08:27:32 <c_wraith> you'd want something like mergeWithKey (\k a b -> Just $ diff a b) id (M.map (diff $ HistData 0 0))
08:28:28 <vamega> c_wraith, I'll evaluate that in a second.
08:28:38 <vamega> Just need to take care of something else for a minute.
08:32:11 <jophish> Iceland_jack: those groovy pattern synonyms you had. Is there some way to make them bidirectional?
08:33:02 <Iceland_jack> jophish: Not without implementing the associated synonyms, but you can easily add 'nil' and 'cons' functions
08:33:35 <jophish> yeah, that's what I've done. I guess we're still waiting on associated patterns
08:33:45 <jophish> I wonder if they're planned for 7.10
08:39:31 <albeit> Is there an easy way to pattern match against Data.Text? Something like "myFunc (x:xs) = ...; myFunc (Data.Text.pack "123")"?
08:40:08 <c_wraith> albeit: does enabling OverloadedStrings let you match against Text literals?  I think it should.
08:41:07 <albeit> c_wraith: Yes, that works, but I was wondering more about the (x:xs) part, which doesn't work.
08:41:30 <joseph07> albeit: I don't think that should work
08:41:42 <c_wraith> albeit: oh.  Right.  You can use ViewPatterns, but it's not exactly convenient
08:42:07 <joseph07> albeit: technically (:) is a data constructor, which you could actually define to mean something not string-related
08:42:17 <c_wraith> albeit: it's workable when combined with PatternSynonyms in GHC 7.8, though
08:42:38 <albeit> Okay, I think I'll just to more manual methods for now.
08:45:13 <joseph07> if you often make functions using the first character of a Text you could make a function that splits a Text into its first character and its tail, and then applies a function to the resulting tuple
08:45:42 <joseph07> then you could pattern match on the tuple
08:45:45 <jaffachief> hi, is there a way of forcing the use of integer-simple when installing dependencies?
08:46:26 <cschneid> why are orphan instances discouraged by warnings? Are they bad just due to having a hard time finding where they're defined?
08:47:19 <joseph07> cschneid: I think they're bad due to it being impossible to find where they're defined
08:47:44 <geekosaur> if multiple packages define their own orphans, they may conflict. since instances are *global* across a program, this conflict means different / inconsistent / often incoherent behavior in different parts of the same program,
08:48:04 <cschneid> geekosaur: ahh, and the compiler doesn't just crash on that? "conflicting instances for XYZType"?
08:48:10 <cschneid> (crash == error out polietly of course)
08:48:11 <geekosaur> and good luck debugging it, especially since the bahvior is likely to change weirdly depending on what is compiled when
08:49:04 <vanila> I'm worried about lazyness
08:49:11 <geekosaur> the problem is that only one is in scope when you compile each individual source file (else it does error out) but there may be conflicting ones at link time. except they aren't visible as such to the linker so it can't report conflicts
08:50:04 <geekosaur> they are dictionaries generated potentially at runtime, and therefore a chunk of source which had one instance in scope might still end up using the other one via function pointers in a passed-in dictionary
08:50:34 <cschneid> geekosaur: ahh right, since typeclasses get desugared pretty quickly in the compilation process, right?
08:50:41 <geekosaur> yes
08:50:58 <geekosaur> no typeclasses in ghc core (which is what is really compiled) at all, it is turned into dictionary passing
08:51:19 <cschneid> I should really start reading some core at some point.
08:51:27 <geekosaur> and if different sources are building incompatible dictionaries, you can expect confusing behavior
08:51:28 <cschneid> but perhaps I should just write useful programs in haskell instead
08:51:36 <cschneid> geekosaur: yeah, that makes perfect sense.
08:51:51 <cschneid> especially with the wrinkle of pre-compiled .o files being combined up into a larger project
08:52:05 <geekosaur> (and passing them around with wild abandon :)
08:55:13 <albeit> Using text-format, how can I specify the printf equivalent of %4.2f in format?
08:58:26 * hackagebot fay 0.20.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.2 (AdamBergmark)
09:03:26 * hackagebot halberd 0.1.2.7 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.7 (ErikHesselink)
09:04:15 <joseph07> albeit: example of what I mentioned earlier, about pattern matching: http://lpaste.net/103822
09:04:57 <albeit> joseph07: Cool, thanks
09:08:27 * hackagebot data-lens-light 0.1.0.1 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1.0.1 (RomanCheplyaka)
09:10:44 <zorro> Hi,
09:10:49 <Guest63513> I'm having a problem with ghc
09:10:50 <Guest63513> http://lpaste.net/3900573432894455808
09:11:23 <Guest63513> because the type error I get when trying to compile seems to contradict the output from the command line
09:11:37 <glguy> Guest63513: change:     input <- "1 2 ab"    -- getContents
09:11:42 <glguy> to let input = "1 2 ab"
09:11:46 <Guest63513> please have a look at lines 15 to 17 in the lpaste
09:12:33 <Guest63513> that was quick
09:12:40 <Guest63513> Thanks, glguy!
09:12:58 <Guest63513> I don't quite get the error message, though.
09:13:04 <glguy> x <- m means "m >>= \x ->" and >>= is a flipped concatMap on lists
09:13:11 <Guest63513> Why would there be a Char all of a sudden
09:13:21 <glguy> but let x = "1 2 ab" means: Name the expression "1 2 ab" as x
09:13:46 <glguy> > do { x <- [1,2]; y <- [3,4]; return (x,y) }
09:13:47 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
09:13:56 <glguy> The char comes from "1 2 ab" :: String
09:13:59 <glguy> and String is [Char]
09:14:14 <glguy> :t concatMap
09:14:15 <lambdabot> (a -> [b]) -> [a] -> [b]
09:15:07 <glguy> There is a Monad instance for Lists which you were using by putting a String on the right-hand side of the do-notation <- arrow
09:15:23 <Guest63513> thanks a lot for the explanation. I wasn't aware of this!
09:17:36 <albeit> Does this make sense for constructing formatted floats out of Text? Should be the equivalent of "%5.2f": formatFloat width decimals num = F.left width ' ' . FB.toLazyText $ F.build "{}" [F.fixed decimals num]
09:17:42 <albeit> It works, but seems... verbose
09:20:26 <albeit> Ah got it way nicer, nvm: ffloat w d = F.left w ' ' . F.fixed d
09:23:28 * hackagebot text 1.1.1.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.1.2 (BryanOSullivan)
09:25:14 <joseph07> albeit: that just gives the builder right? Don't you want format "{}" [left wdidth ' ' . fixed decimals $ num
09:25:34 <wojtekM_> constrIndex . toConstr -- in Data.Data
09:26:05 <albeit> joseph07: True, I was just feeding that builder to the list of parameters when building longer Texts
09:26:40 <joseph07> albeit: cool!
09:26:47 <wojtekM_> (answering my own question)
09:26:55 <merijn> @hoogle Show a => a -> Text
09:26:56 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
09:26:56 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
09:26:56 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
09:27:14 <merijn> I guess I just have to do "pack . show"?
09:32:46 <Kaidelong> cabal does print an error to the console when it runs into "file exists" or something else like that
09:32:53 <Kaidelong> so I am glad I didn't file a bug
09:33:30 * hackagebot digestive-functors-aeson 1.1.8 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.8 (OliverCharles)
09:36:16 <c_wraith> Going back to the instance conflict thing..  Technically, the Haskell spec talks about instances being global, and it's an error to have identical instances anywhere in the whole program.  Unfortunately, GHC doesn't actually enforce that.
09:38:30 * hackagebot libsystemd-journal 1.2.0 - Haskell bindings to libsystemd-journal  http://hackage.haskell.org/package/libsystemd-journal-1.2.0 (OliverCharles)
09:38:32 * hackagebot kqueue 0.1.2.6 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.6 (ErikHesselink)
09:41:34 <merijn> hmm
09:42:10 <jophish> I have mutually recursive modules and I'm not sure how to resolve this. Here are the problematic contents http://lpaste.net/103826
09:42:23 <armlesshobo> http://lpaste.net/103827
09:43:22 <Kaidelong> okay on my other windows machine
09:43:25 <Sonarpulse> How can I derive aribitrary for a type defined in another module? Don't want to derive arbitrary in the other module as I only need this for tests.
09:43:39 <Kaidelong> I had to go into my mingw directory and replace strip.exe with a Hello World program temporarily
09:43:45 <Kaidelong> to be able to update cabal-install
09:43:45 <merijn> jophish: Either create a hs-boot file or split the things that are mutually dependent into a separate module (yes, this is a bitch)
09:43:50 <ironChicken> when defining the defaut implementation for a class method, can i call a constructor for a type variable?
09:44:06 <c_wraith> jophish: the standard approach is just putting them in the same file.  If that is completely impossible, you can sometimes parameterize things so as to break the recursion
09:44:14 <jophish> merijn: I'm not sure what should go in the hs-boot file.
09:44:15 <ReinH> Sonarpulse: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
09:44:20 <merijn> jophish: i.e. create "Types.hs" copy both things into it and import that into A.hs and B.hs
09:44:27 <jophish> I don't think that they really belong in the same file
09:44:36 <Sonarpulse> ReinH arbitrary is derived with template haskell
09:44:42 <Sonarpulse> derive package
09:44:47 <jophish> merijn: that's probably the best solution
09:44:49 <merijn> jophish: Too bad, I've tried to fight that unsuccesfully for ages
09:44:56 <c_wraith> jophish: if they depend on each other, they really do belong in the same file.
09:44:58 <ReinH> Sonarpulse: ah, then I'm not sure
09:45:08 <merijn> jophish: Short of someone fixing GHC to support recursive imports you're not going to avoid it :\
09:45:28 <Sonarpulse> grr there should be multiple template haskells for different phases
09:45:35 <Sonarpulse> that is the true solution to this problem
09:45:37 <merijn> c_wraith: I disagree, there are plenty of mutually recursive imports that make more sense in separate files, and clearly the Haskell committee agrees
09:45:41 <jophish> heh, I've gotten away with tiny modules for everything so far. Oh well, time to create Everything.hs
09:45:46 <c_wraith> jophish: If they don't fundamentally depend on each other, you can break the recursion by adding parameterization
09:46:24 <ReinH> also parameterization is often useful in other ways (like allowing you to define Functor or Monad instances, etc)
09:46:27 <jophish> I'll try these things out and see what feels best
09:46:40 <merijn> ReinH: There's many cases in whcih don't make sense
09:46:46 <XrXr> why is length O(n)?
09:46:48 <ReinH> merijn: and some that do
09:47:00 <ReinH> I don't appear to be arguing that it's always the right thing to do.
09:47:05 <merijn> XrXr: Because lists are a linked list?
09:47:13 <XrXr> I see.
09:47:20 <merijn> XrXr: The only way to determine the length is to walk to the end
09:47:23 <ReinH> XrXr: because you have to traverse a linked list to get to the end
09:47:48 <joelteon> So is there a way, with TH, to get all in scope instances of a typeclass?
09:47:56 <c_wraith> XrXr: pop quiz..  What's the length of the list x in this example?  let x = 1:x in x
09:48:15 <XrXr> infinite?
09:48:23 <c_wraith> So what should length return?
09:48:30 <XrXr> error
09:49:10 <c_wraith> It has no way of locally distinguishing that list from [1,1,1,1,1,1,1] until it reaches the end of the latter.
09:49:10 <XrXr> the doc says length only works on finite lists
09:49:37 <merijn> XrXr: Right, because walking to the end of an infinite list takes a while ;)
09:50:07 <ReinH> I'm not sure if it "returns" anything but its value is bottom. :p
09:50:22 <christianbeasley> hi
09:50:25 <merijn> "length :: Integral a => [b] -> a" does work on infinite lists :)
09:50:31 <merijn> For some values of 'a', that is
09:50:39 <c_wraith> merijn: and for some values of "work". :)
09:50:46 <ReinH> and for some values of "infinite"
09:51:04 <c_wraith> ReinH: actually, genericLength producing a lazy Natural value is sometimes useful
09:51:18 <merijn> c_wraith: I was referring to a lazy natural, yeah :)
09:51:28 <c_wraith> ReinH: its length is > any finite lazy natural, and the calculation terminates!
09:51:37 <ReinH> c_wraith: magic :)
09:51:44 <tommd> And those cases are more than just the naive `length xs > 0`
09:51:56 * merijn had a lazy Nat type with an ord instance lying around to show that :)
09:51:59 <c_wraith> still.  You can't print the resulting lazy natural
09:52:15 <merijn> c_wraith: You can, it just takes a while ;)
09:52:19 <c_wraith> So it doesn't work in every case
09:52:31 <c_wraith> merijn: depends on the Show instance, I guess.
09:52:44 <c_wraith> merijn: I'm more familiar with ones with Show instances that produce a decimal value
09:53:16 <merijn> c_wraith: pffft, senseless real world concession!
09:54:07 <jophish> whaaa? http://lpaste.net/103828
09:54:18 <jophish> I'm surprised I can do this
09:54:39 <jophish> Does this force the Eq constraint on T?
09:55:06 <c_wraith> jophish: T doesn't really exist
09:55:24 <c_wraith> jophish: it just means that whatever T a resolves to at compile time, it's required to have an Eq instance
09:55:32 <merijn> jophish: It forces an Eq constraint on the *result* of "T a"
09:55:58 <jophish> ah yes, that's what I meant
09:56:14 <jophish> This is what I was asking for earlier :)
09:59:18 <merijn> jophish: GHC should yell at you if you try and define a C instance for a's where "T a" is not an instance of Eq
10:00:06 <merijn> jophish: But yes, TypeFamilies are pretty damn awesome
10:00:15 <merijn> Closed TypeFamilies are even better :>
10:00:29 <jophish> merijn: exactly what I want from GHC :)
10:00:32 <ParahSailin> im trying to use criterion for something and its just sitting there with like 3% cpu occupancy
10:00:40 <ParahSailin> is this normal?
10:00:45 <jophish> Type families have been awesome so far, although I'm only using associated types
10:00:55 <athan> merijn: Closed type families o.O?
10:01:58 <athan> Hey everyone, is it possible to export a newtype in a module, but only it's newtype declaration, and not it's constructors? (For use with type signatures / phantoms)
10:01:59 <merijn> jophish: Associated types are pretty much identical to just plain type families, I think they're literally translated into type families
10:02:08 <athan> they are
10:02:15 <merijn> athan: Closed type families don't allow the definition of new instances
10:02:29 <jophish> merijn: ah of course
10:03:01 <merijn> athan: With typefamilies you have problems with overlapping type families stopping you from defining some types. Closed type families are matched in sequence (meaning that overlap is unambiguous) and can't have new instances defined
10:03:09 <athan> marijn: Oh that's interesting... so It's an actual relation between two types, and there's no room to create a new data type...?
10:03:13 <merijn> athan: The result is that they allow you to do things like type level equality
10:03:28 <athan> oh that's nice!
10:03:32 <athan> aha!
10:03:34 <merijn> athan: You can write things like this: https://gist.github.com/merijn/6130082
10:03:48 <athan> that's too cool. I'm trying to make type level ordering work haha
10:03:57 <athan> for a type-safe tower of hanoi evaluator
10:04:21 <merijn> athan: Oh, then you should probably check out closed type families, it'll be much easier (they work in 7.8, not yet in 7.6)
10:04:33 <athan> I was thinking of using something like multiparam's, but I ran into the issue of "How do I set a basis case for the lowest type?"
10:04:43 <athan> that's awesome, I will. Thank you!
10:05:03 <merijn> athan: Right, that's exactly the problem closed families solve :) My link does recursion like that
10:05:21 <athan> holy crap
10:05:36 <carter> merijn: never in 7.8 you mean :)
10:05:54 <athan> wouldn't this make something like the same effect as dependent typing, you just have to explicitly make a mapping between types and values?
10:06:16 <merijn> carter: I meant that in a "they didn't yet work in 7.6" sense
10:06:31 <carter> they never will work :)
10:07:04 <jophish> @pl   ftv as = (ftv <$> as) >>= nub
10:07:04 <lambdabot> ftv = fix (flip flip nub . ((>>=) .) . (<$>))
10:07:13 <jophish> hmm, perhaps not
10:07:33 <athan> merijn: This is very interesting. So (let me get this straight ><), type families are constraints?
10:08:12 <merijn> athan: The ConstraintKinds extension introduces a new kind (called Constraint) for constraints. This TypeFamily just happens to return a type of kind Constraint
10:08:32 <merijn> carter: That is implied in that sentence, no?
10:08:40 <carter> nope
10:08:51 <merijn> carter: You're reading my sentence and clarification wrong!
10:08:53 <carter> :)
10:09:01 <carter> too many implicis
10:09:06 <carter> i'm being pedantic
10:09:09 <merijn> carter: Never learn Dutch :)
10:09:16 <carter> yay
10:09:18 <merijn> It'll drive you mad :p
10:09:41 <merijn> Is there a more efficient way of building a strict Text or should I just mconcat/mappend stuff
10:10:02 <spockshock> they sound like drunk germans the dutch
10:10:03 <athan> ahh yeah that's what I was feeling. So associated types could actually do something of a similar effect, though. The associated type would be 'a' in your example...?
10:11:34 <tremon> is there a way to express (\a -> a - 3) as a segment?
10:11:35 <merijn> athan: I don't really understand your question?
10:11:41 <merijn> tremon: subtract
10:11:46 <athan> shoot, nevermind :) Thank you!!!
10:11:46 <merijn> > subtract 3 5
10:11:48 <lambdabot>  2
10:11:52 <tremon> ah :p
10:11:58 <tremon> that's cheating
10:12:04 <athan> segment... that's new vocab for me
10:12:17 <merijn> tremon: Yeah, but the other thing requires precognition to do the right thing :)
10:12:47 <tremon> I know. oh well, subtract is easy enough to use. thx
10:14:06 <dmj`> I have a sandbox question
10:14:07 <merijn> tremon: FYI, the proper/common name for that is a "section" :)
10:14:28 <tremon> :) almost got it right. Good thing I don't use them that often
10:15:00 <merijn> athan: Really type families are just type level functions that take types as arguments and return a type, this is independent of whether they are "associated types" or not
10:15:44 <merijn> athan: In my case it happens to return a type of kind Constraint, which is what GHC uses for constraints in type signatures, but if it had returned something else it would've still worked
10:16:09 <armlesshobo> hmmm
10:16:11 <merijn> athan: FYI, I actually have an ordering type family here: https://gist.github.com/merijn/9530680
10:16:32 <armlesshobo> i don't think ghc likes it when the preprocessor end bracket is on it's own line.
10:16:46 <armlesshobo> how do I get around that?
10:17:04 <athan> ahhh I see. So associated types give you extra stuff for your functions when you require the typeclass constraint, while type families literally act like a function, leaving the "relating" to the function implementor?
10:17:30 <dmj`> I init'd a sandbox and installed deps, then changed the name of my cabal file and folder. Cabal then said it couldn't find the sandbox, so I called "cabal sandbox init" -- bad idea?. It said it's using an existing sandbox, but that the package list is missing and the repo is now invalid. How do I change the files in the packages folder to comply w/ my cabal file renaming?
10:17:36 <merijn> athan: Associated types are syntactic sugar, afaik they just get compiled to "plain" type families
10:18:02 <merijn> athan: They're a convenient way of keeping type family and the class they're related to together, but they're otherwise exactly the same :)
10:18:15 <merijn> athan: So, pretty much
10:18:34 * hackagebot iCalendar 0.4.0.1 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.4.0.1 (ChristianRoedliAmble)
10:18:40 <dmj`> also, is this a situation where I need to "recache" ?
10:18:43 <dmj`> http://lpaste.net/103829
10:19:46 <athan> merijn: *mutates into next level form*
10:19:49 <dmj`> it says the package list is missing, but I have 00-index.cache and 00-index.tar in there
10:20:51 <jfischoff> athan: you are correct, type families literally act like a function
10:21:28 <merijn> athan: Also, hence why the type families paper is called "Fun with Type Functions" :)
10:21:55 <dmj`> so it looks like deleting 00-index.cache and 00-index.tar and calling "cabal sandbox init" fixed the invalid repo warnings and retained the contents of the sandbox
10:22:40 <athan> !!!
10:23:38 <dmj`> oh nvm, everything is still broken
10:24:25 <dmj`> why would cabal use absolute paths like this, you can't rename anything
10:24:29 <jfischoff> The pattern matching rules are different than normal Haskell functions though. No overlap (w/o closed type families) so order doesn‚Äôt matter.
10:24:41 <athan> merijn: Awesome, I'm going to need a little bit to digest this, but this has definitely opened a whole new set of doors. Thank you so much :)
10:24:45 <jfischoff> dmj`: there is feature request against that
10:25:35 <merijn> athan: I can highly recommend reading that paper, btw. It's very readable!
10:25:52 <athan> Will do!
10:25:57 <merijn> athan: The most complex thing in there is probably less complex than my example
10:26:57 <dmj`> jfischoff: ok good
10:27:06 <amITheOnlyOne> am i the only one who finds the hardest part of haskell programming to be using cabal :/
10:27:13 <XrXr> Can't even divide Ints with / D: frustrating
10:27:13 <athan> Awesome, thank you so much, I've got to split right now, but I'll definitely check that all out and see if I can come up with anything of caliber :)
10:27:23 <merijn> amITheOnlyOne: Really?
10:27:24 <jfischoff> amITheOnlyOne: no
10:27:30 <athan> I'm trying to make an ordered, unique stack data type right now, so I have a feeling this will be extremely useful
10:28:05 <tommd> amITheOnlyOne: If you are being sarcastic about "hardest" then I can at least agree that cabal isn't the greatest build tool.
10:28:10 <merijn> amITheOnlyOne: Out of curiosity (I'm trying to build a map of the origin of cabal complaints: Which build systems do you have experience with prior to cabal and do you think they are better?
10:28:25 <merijn> tommd: Same question for you :)
10:28:47 <merijn> XrXr: You probably want "div" or "fromIntegral x / fromIntegral y"
10:28:50 <amITheOnlyOne> i worked in an industry setting at amazon where they had a home baked build system. it was pretty good
10:29:06 <jfischoff> when cabal fails to install one of many packages, the error is ‚Äúbuild failure‚Äù that is all you get
10:29:09 <merijn> amITheOnlyOne: Ah, yeah, I can imagine a custom build buildsystem may be better.
10:29:16 <jfischoff> all you get by default
10:29:23 <jfischoff> which is not beginner friendly
10:29:57 <tommd> merijn: I've used Haskell, GHC, and Cabal as my primary work language for 7 years now so I can't call out a "better" system easily.  Perhaps erlang's rebar.  The parts of cabal-install that bother me are its strong association with Hackage and the packaging policy being far too ridged.
10:30:22 <dmj`> tommd: do you hardcode your pkg versions on large projects?
10:30:34 <jfischoff> utlimately cabal needs more information
10:30:38 <tommd> merijn: If I could stipulate dependencies on functions, type signatures and formal properties that would be a lot more sensible than on some manually maintained version numbers.
10:30:56 <XrXr> merijn: its frustrating though. I just want to divide the length of a list by 2. I can't just do length [1,3,2] / 2 I have to use genericLength [1,3,2] / 2. And I don't fully understand it
10:31:03 <amITheOnlyOne> merijn: what tommd said lastly
10:31:04 <jfischoff> we should be sending the failed and successful compiles to hackage, and this info should be used by the solver
10:31:19 <merijn> tommd: I certainly agree that cabal has plenty of room for improvement, but in my experience people tend to behave like cabal is the "worst build system ever", I've used automake and java build systems before and I'd pick cabal over them any day :)
10:31:21 <tommd> dmj`: The lower bound.
10:31:23 <carter> jfischoff: yeah, i think thress some gsoc work on related bits this summer
10:31:42 <carter> jfischoff: not sure if i'll be at bayhac, was hoping to go!
10:31:45 <merijn> tommd: Sure, but keep in mind cabal is maintained by like 1.5 persons that have fulltime jobs :)
10:31:50 <tommd> merijn: That is why I could only agree with a tempered version of amItTheOnlyOne's statement.
10:32:09 <jfischoff> carter: if you can go that would be great. My recommendation: come early
10:32:10 <tommd> merijn: And was started by a guy who sits 10 feet from me and we give constant flak for it.
10:32:17 <carter> jfischoff: early how?
10:32:18 <tommd> Yes, I know.
10:32:21 <carter> *in which sense
10:32:23 <jfischoff> in the morning
10:32:29 <carter> oh
10:32:36 <carter> how many people are registered?
10:32:40 <jfischoff> 231
10:32:44 <carter> OOOO
10:32:49 <merijn> XrXr: The problem is that / returns a non-integral value, and all numerical functions have type "a -> a -> a" so dividing two ints would need to return an int, which makes no sense for /
10:32:58 <jfischoff> double from last year
10:33:00 <carter> jfischoff: woahhh
10:33:02 <byorgey> wat! 231!
10:33:13 <merijn> XrXr: "div" is integer division which truncates to an Integral value
10:33:14 <carter> jfischoff: i'd be staying in berkley if i'm around that weekend
10:33:17 <jfischoff> byorgey: yeah ‚Ä¶
10:33:44 <jfischoff> carter: don‚Äôt bring a car
10:33:50 <carter> jfischoff: i don't have a license
10:33:54 <jfischoff> even better
10:34:09 <XrXr> merijn: Thats a more concise explaination than the one I found. Thanks :)
10:34:15 <jfischoff> byorgey: not everyone will show up
10:34:26 <jfischoff> at least that is what I am counting on
10:34:29 <merijn> XrXr: The only for / to work sensibly for Int is if it silently converted Int to Double, and you may think that sounds like a good idea. But after having (multiple times!) spend weeks debugging a silent numerical conversion in C, I'm convinced that explicit conversion is much better than implicit
10:34:35 <merijn> XrXr: Consider the following types
10:34:38 <merijn> :t (/)
10:34:39 <lambdabot> Fractional a => a -> a -> a
10:34:41 <merijn> :t div
10:34:42 <lambdabot> Integral a => a -> a -> a
10:34:46 <merijn> :t fromIntegral
10:34:47 <lambdabot> (Num b, Integral a) => a -> b
10:34:54 <byorgey> jfischoff: well, of course, but even if only half show up that is still a ton of people.
10:35:08 * jfischoff nods
10:35:23 <byorgey> and typically attendance/registration ratio is more than half
10:35:36 <merijn> XrXr: Fractional being the typeclass for, well, fractional values (like floating points). Clearly Int is not an instance of that, but can be converted to it using fromIntegral (as any Floating instance must be a Num instance)
10:35:46 <jfischoff> yeah I‚Äôm betting 65%, last year was 75% I think
10:35:59 <byorgey> sounds reasonable.
10:36:12 <carter> jfischoff: blurgh, i only now got the invoice monies to cover the travel this week, but the airfair tixs are pricer now
10:36:37 <jfischoff> ah
10:36:52 <carter> 700 vs 450 round trip
10:36:55 <carter> blah
10:37:14 <carter> i'd ruther not do a 700 trip even if i'm staying at my ssisters for free
10:37:48 * jfischoff nods
10:38:07 <carter> esp since the tickets that are cheaper than that are with those nasty layovers
10:39:31 <ReinH> carter: for what? bayhac?
10:39:40 <carter> ReinH: yeah
10:39:46 <ReinH> carter: flying into SJ?
10:39:51 <carter> ReinH: .... sfo?
10:39:55 <carter> should i look at SJ?
10:40:07 <ReinH> carter: yeah, the thing is closer to san jose iinm
10:40:10 <carter> ReinH: i'm tentatively planning to stay at my sisters place in berkley
10:40:16 <carter> 'cause free
10:40:16 <ReinH> ah
10:40:21 <ReinH> well yeah
10:40:39 <ReinH> carter: unfortunately my second bed is taken :/
10:41:03 <ReinH> and SFO is probably cheaper anyway
10:42:39 <carter> ooo, flying in thurs and flying back tuesday is 630
10:43:41 <carter> otoh, the 1-1.5+ hour each way between bkerley and MV will kill me
10:43:57 <joelteon> ooh, it starts next friday
10:44:23 <joelteon> and it's 6 minutes away from me :D
10:45:07 <carter> joelteon: oooo really?
10:45:17 <joelteon> yep
10:45:20 <carter> huh
10:45:28 <carter> did we meet when i did my sf trip in feb?
10:45:29 <joelteon> well, 6 minutes from my current location. probably more like 10 minutes from my home
10:45:35 <carter> hah
10:45:35 <joelteon> no i haven't been to a hackathon before
10:45:46 <carter> no, i was doing a bay area visi in feb
10:45:56 <joelteon> no we didn't meet
10:46:12 <carter> k
10:46:54 <carter> i will say this: data cleaning tasks in haskell are soooo pleasant
10:46:58 <carter> even when it sucks
10:51:13 <albeit> Why does this not put anything in test.log? "outputFile <- openFile "test.log" WriteMode; hPutStrLn outputFile "Hello""
10:51:57 <albeit> Is it because the lazy IO closes test.log right after getting the handle?
10:53:24 <dmj`> albeit: withFile "cool.txt" ReadMode hGetContents  >>= putStr... will close the file before anything is read
10:54:04 <tommd> albeit: You'll need to `hFlush`.  The program is terminating prior to the buffer being written.
10:54:04 <joelteon> albeit: It looks like you might need to hFlush the handle too.
10:54:07 <joelteon> yea, that.
10:54:40 <albeit> Ah perfect, thanks.
10:54:56 <joelteon> Or you could set the buffering mode of the handle to LineBuffering.
10:54:58 <tommd> albeit: That or just `hSetBuffering outputFile NoBuffering`
10:55:15 <joelteon> we meet again, tommd...
10:55:28 <tommd> One of us is a Parrot.   I CALL PARROT!
10:55:55 <joelteon> to be perfectly pedantic, LineBuffering is more performant
10:57:11 <tommd> joelteon: True.  I wasn't sure it would actually write (yes, despite the hPutStrLn) so played it safe with my suggestion.
10:58:49 <jophish> Is there a shorthand for (view _1 <$> ask)
10:59:06 <joelteon> jophish: asks fst?
10:59:19 <jophish> joelteon: it's a three-tuple
10:59:29 <jophish> asks (view _1) would be pk
10:59:30 <jophish> ok*
10:59:47 <joelteon> sure, do that
10:59:51 <joelteon> that's what asks is for
11:00:03 <supki> joelteon: isn't that just view _1 ?
11:00:11 <supki> :t view _1
11:00:13 <lambdabot> (Field1 s s a a, MonadReader s m) => m a
11:00:17 <joelteon> oh, right
11:00:19 <merijn> jophish: You can use "uses"
11:00:33 <merijn> Ah, and indeed just view :>
11:00:38 <joelteon> right, use view
11:00:41 <joelteon> I was flummoxed
11:00:50 <joelteon> jophish: please tell me you're using lens for more than just _1 :)
11:00:54 <jophish> that's what I thought, but It didn't typecheck. Let me re-investigate
11:01:16 <jophish> joelteon: just a placeholder for the moment :)
11:01:24 <joelteon> > runReader (view _1) (1,2,3)
11:01:25 <lambdabot>  1
11:01:28 <joelteon> seems ok.
11:01:57 <jophish> oops, sorry I'm in RWST
11:02:08 <joelteon> there is still a MonadReader instance for RWST.
11:03:39 * hackagebot statistics 0.11.0.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.11.0.1 (BryanOSullivan)
11:05:03 <jophish> hmm, ' No instance for (mtl-2.1.3.1:Control.Monad.Reader.Class.MonadReader' is what I'm getting
11:05:54 <joelteon> paste your code
11:08:12 <jophish> joelteon: I'll stick with (asks (view foo)) for now. In a bit of a hurry :)
11:08:56 <bennofs> jophish: you have two versions of mtl installed
11:09:11 <bennofs> jophish: ghc-pkg list mtl
11:09:20 <ReinH> :t asks . view
11:09:21 <lambdabot> MonadReader r m => Getting a r a -> m a
11:09:23 <ReinH> :t view
11:09:24 <lambdabot> MonadReader s m => Getting a s a -> m a
11:09:28 <ReinH> notice anything? :)
11:09:50 <bennofs> :t views
11:09:50 <lambdabot> (Profunctor p, MonadReader s m) => Optical p (->) (Const r) s s a a -> p a r -> m r
11:10:43 <jophish> bennofs: how did you know!
11:11:01 <bennofs> jophish: the error message showed a version number. it only does that when it's ambiguous
11:11:46 <joelteon> I thought it only showed that when the package was a hidden package
11:13:09 <jophish> ah I see
11:13:09 <jophish> what does this mean for me?
11:16:00 <geekosaur> jophish, it means you are using things linked against two different versions of mtl, and their types do not match as a result. so you get to figure out what is linked against what, then decide which mtl you actually want to use and rebuild stuff linked against the wrong one
11:16:40 <geekosaur> alternately it means use cabal sandbox (if you have cabal 1.18) or cabal-dev/hsenv to build an environment where you can make sure everything builds sanelt
11:17:08 <geekosaur> personally when I install haskell-platform I place an installed constraint in ~/.cabal/config for every preinstalled package, so I can avoid this kind of breakage
11:18:43 <byorgey> jophish: note this is probably indirectly due to the fact that mtl-2.2 was just released, and some, but not all packages have been updated to work with it
11:19:14 <XrXr> hm.. how is order of operation respected when 5 + 10 / 2 is really ((5 +) 10) / 2 due to + being a curried function
11:19:36 <TallerGhostWalt> is there a function for getting the underlying int of a threadID... I just need it to stagger lookups in a table
11:19:45 <byorgey> XrXr: 5 + 10 / 2  does not parse as  ((5 +) 10) / 2
11:19:55 <byorgey> XrXr: it parses as  5 + (10 / 2)  as you would expect
11:20:01 <XrXr> I see
11:20:32 <byorgey> XrXr: binary operators can be given a precedence (a number from 0-9) which is used to determine how such expressions parse
11:20:54 <byorgey> in this particular example, / has a precedence of 7 whereas + has a precedence of 6
11:20:59 <joelteon> TallerGhostWalt: I don't think ThreadIds are represented by ints
11:21:13 <XrXr> ah, thanks
11:21:22 <jophish> Super, I'll fix that. Thanks geekosaur, byorgey, joelteon, bennofs, merijn :)
11:21:31 <TallerGhostWalt> CInt
11:21:45 <joelteon> well, yes
11:21:51 <covi> Why doesn't Cayenne gain tractions?
11:21:54 <joelteon> but that's exported by the RTS
11:22:45 <armlesshobo> anyone ever encounter a problem where ghc yells at you if the #-} is on it's own line?
11:22:58 <byorgey> TallerGhostWalt: data ThreadId = ThreadId ThreadId#, it is represented using some magical build-in ThreadId# type
11:22:59 <glguy> TallerGhostWalt: You'll probably have to 'show' the ThreadId and interpret that output
11:23:10 <TallerGhostWalt> yeah that is what I am thinking
11:23:14 <joelteon> TallerGhostWalt: I don't think there's a "nice" way to do what you want. ThreadId does have an Ord and Eq instance though.
11:23:16 <byorgey> TallerGhostWalt: ThreadId is an instance of Eq and Ord, and also Show
11:23:19 <TallerGhostWalt> glguy writing that rightnow
11:23:32 <quchen> TallerGhostWalt: ThreadID is Ord, you can just use it as a key in a Map
11:23:42 * hackagebot yesod-static-angular 0.1.1 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.1 (JohnLenz)
11:23:47 <joelteon> typeclasses!
11:24:13 <carter> TallerGhostWalt: joelteon  aren't CInt and Int equal on most platforms?
11:24:18 <TallerGhostWalt> I have a set of resources that are inserting into a queue then waiting for a response from an external service
11:24:19 <joelteon> no idea
11:24:26 <merijn> carter: Stop perpetrating that lie!
11:24:31 <carter> well, any platform where Int Size == Ptr size
11:24:36 <merijn> carter: No
11:24:37 <carter> merijn: :P
11:24:39 <TallerGhostWalt> but I am merging some of them together
11:24:44 <johnw> CInt is not boxed, is it?
11:24:49 <merijn> johnw: It is
11:24:49 <TallerGhostWalt> it is a big mess but I think doing the show thing will work
11:24:52 <johnw> ah, ok
11:24:59 <carter> merijn: which platforms fail that rule?
11:25:02 <carter> windows?
11:25:17 <carter> or is CInt == Int32 always?
11:25:18 <carter> i forget
11:25:18 <merijn> carter: ok, the Int size == Ptr size might hold
11:25:20 <joelteon> TallerGhostWalt: ThreadId is *also* an instance of Hashable
11:25:23 <quchen> TallerGhostWalt: Why do you need the thread ID for that? Also, do you know the Async library?
11:25:24 <joelteon> You can use that for a bucketing function
11:25:30 <merijn> carter: CInt == whatever int in C is on that platform
11:25:34 <carter> k
11:25:49 <merijn> carter: 64bit GHC can have 64 bit Int whereas C on that platform may have 32 bit Int
11:25:51 <carter> and most platforms have size of int = size of (* int)
11:25:55 <rwbarton> no
11:26:01 <carter> no?
11:26:03 <carter> oh
11:26:03 <merijn> carter: In fact, this applies to my MacBook and is a reason I found a bug in the RTS
11:26:04 <rwbarton> e.g. linux x86_64 has 32-bit int
11:26:05 <carter> int_ptr
11:26:16 <TallerGhostWalt> quchen I forgot about that honestly that is what I need
11:26:25 <TallerGhostWalt> ask the right question get the right answer
11:26:28 <merijn> carter: 64bit platforms often still have 32 bit int
11:26:32 <carter> ok
11:26:39 <carter> int_ptr is a thing though right?
11:26:45 <merijn> intptr_t, yes
11:26:47 <Zer000> Hypothetically would it be a good idea to write a graphics renderer in pure Haskell? I know there is a library that's like OpenGl but with Haskell syntax, similarly you can take advantage of the GPU (like OpenCl). You can also spit out JS, so presumably I could have the same code run in the browser later?
11:26:55 <joelteon> > (maxBound :: CInt) == fromIntegral (maxBound :: Int)
11:26:56 <lambdabot>  Not in scope: type constructor or class ‚ÄòCInt‚Äô
11:26:56 <lambdabot>  Perhaps you meant one of these:
11:26:56 <lambdabot>    ‚ÄòInt‚Äô (imported from Data.Int),
11:26:56 <lambdabot>    ‚ÄòCont‚Äô (imported from Control.Monad.Cont)
11:26:56 <carter> and haskell  Int generally matches intptr_t
11:27:06 <carter> right?
11:27:16 <merijn> carter: "It depends"
11:27:19 <yitz> Zer000: you want to render graphics using JS?
11:27:26 <merijn> carter: But in ghc most likely, yes.
11:27:30 <carter> yes
11:27:36 <carter> well, i don't carea bout not ghc :)
11:27:48 <carter> i'm already stuck using only 7.6 or newer for the tech i'm doing
11:28:20 <merijn> carter, TallerGhostWalt, joelteon: FYI, this "CInt" vs "Int" size is so tricky that after I found a bug in the RTS for it and patched I realised that my patch introduced the same bug in the OPPOSITE direction
11:28:29 <carter> yeah
11:28:30 <carter> i know
11:28:32 <carter> its tricky
11:28:36 <Zer000> yitz: err no it would be webgl then
11:28:38 <carter> i just try to forget
11:28:47 <merijn> And two months after that patch I spend another hour validating it because I thought my second patch was wrong too
11:28:50 * yitz nods
11:28:50 <merijn> :p
11:29:02 <carter> merijn: i actually wanna make the size of pointers and the sizes of ints more decoupled in ghc
11:29:02 <porkyfly> connect #osuosc
11:29:07 <porkyfly> oops...
11:29:08 <merijn> Thank god I wrote like a 30 line comment defending it's correctness :)
11:29:11 <porkyfly> that was embarrasing
11:29:33 <joelteon> porkyfly: to err is human
11:29:40 <porkyfly> heh
11:29:49 <carter> merijn: would you be in support of trying to decouple Int# and Addr# being the same size assumption in ghc?
11:30:06 <merijn> carter: Does GHC have that assumption? I don't think it does?
11:30:13 <carter> i think it does
11:30:14 <carter> :)
11:30:30 <merijn> carter: Or you mean in the sense that it will implement Int# using the same size as Addr#?
11:30:33 <carter> yes
11:30:39 <merijn> I think you won't succeed in that
11:30:48 <merijn> carter: Because that'd drastically complicate the GC
11:30:53 <carter> oh?
11:31:00 <carter> merijn: at the RTS level?
11:31:07 <carter> i mean at the haskell level
11:31:22 <carter> hwo would that assumption impact GC?
11:31:35 <merijn> carter: Right now constructors are laid out like so: unboxed values first, pointers second
11:31:43 <carter> ok
11:31:52 <merijn> carter: This means the structure of a datatype is 2 ints (count of unboxed and count of pointers)
11:32:02 <carter> RTS ints, not haskel ints
11:32:03 <carter> right?
11:32:22 <merijn> carter: Whatever you use in your STG implementation
11:32:26 <carter> i'mt tlaking Int vs Int64 vs Int32
11:32:30 <carter> not cint
11:32:31 <carter> idk
11:32:40 <merijn> carter: I'm talking much lower level
11:32:44 <carter> yes
11:32:46 <carter> i understand that
11:32:47 <rwbarton> I think it actually only uses 8 bits to store those
11:32:47 <merijn> carter: Maybe I misunderstood your intention
11:32:52 <intrados`> Is "‚ÄòtypeOf‚Äô is not a (visible) method of class ‚ÄòTypeable‚Äô" a GHC 7.8 thing?
11:32:54 <rwbarton> some small number
11:32:58 <c_wraith> intrados`: yes
11:33:08 <merijn> rwbarton: Probably, but not relevant to the point I was wanting to make :)
11:33:08 <c_wraith> intrados`: you can't implement Typeable manually in GHC 7.8 anyway
11:33:10 <carter> merijn: yes, i just want Int  in *haskell* to not have the array ops conflate it with pointers
11:33:14 <rwbarton> I agree
11:33:15 <carter> which it currently does
11:33:24 <c_wraith> intrados`: Data.Typeable still exports typeOf, but it's no longer part of the class
11:33:24 <carter> rwbarton: agree with which?
11:33:32 <merijn> carter: The point is, the smallest unit GHC uses is the size of a machine word
11:33:38 <carter> i understand that
11:33:45 <rwbarton> that your questions about what merijn is talking about with "2 ints" are irrelevant
11:33:48 <merijn> carter: The reason is that in that scenarion unboxed values and pointers are always the same
11:33:51 <carter> merijn: yeah
11:33:54 <carter> thats fine
11:34:06 <carter> thats different from assuming you can always use Int as a pointer offset :)
11:34:24 <carter> merijn: i think rwbarton  is right that my concern is orthogonal
11:34:34 <merijn> carter: If you would support unboxed values of a different size, then the layout of datatypes depends on *which* unboxed types are in a datatype
11:34:38 <rwbarton> merijn: is there a reason the pointers couldn't just go first instead?
11:34:49 <rwbarton> seems like that would be better for locality also
11:34:57 <carter> huh yeah
11:34:58 <XrXr> is there any way to write l !! (3+1) without the brackets?
11:35:07 <merijn> rwbarton: The ordering of pointers first words second is not relevant. The problem is that you'd need to know the size of every unboxed value
11:35:13 <johnw> let x = 3 + 1 in l !! x
11:35:17 <carter> merijn: why
11:35:18 <merijn> rwbarton: Because else you don't know the size of the entire datatype
11:35:28 <rwbarton> OK, well I just need to store the size of the closure in some smaller units then
11:35:30 <merijn> carter: How else do you know the size of the datatype?
11:35:30 <carter> merijn: do you need the individual sizes or just the summ
11:35:31 <johnw> (l !!) $ 3 + 1
11:35:32 <rwbarton> doesn't seem like a huge deal
11:35:39 <merijn> carter: I don't know?
11:35:42 <carter> ok cool
11:35:47 <carter> we have an experiment to do!
11:35:56 * carter adds it to his ghc experiments notebook
11:36:00 <YellPika> XrXr: l !! 4
11:36:02 <merijn> carter: Mind you, I only read like the first STG paper on this :>
11:36:05 <YellPika> :)
11:36:15 <carter> the first STG paper is a bit... outdated
11:36:16 <carter> :)
11:36:22 <merijn> carter: I've been told
11:36:31 <carter> pipelining is a thingy!
11:36:32 <merijn> carter: But I figured it was as good a starting point as any
11:36:33 <vanila> where is the updated information on STG?
11:36:36 <carter> eh
11:36:37 <XrXr> johnw: thats even more complex XD YellPika what if 3 is a variable?
11:36:40 <carter> vanila: :)))))))
11:36:56 <carter> modern STG in ghc != "STG "
11:37:01 <carter> its related
11:37:04 <rwbarton> unfortunately the Int/Ptr confusion is exposed in the interface of the FFI addendum
11:37:05 <carter> but its its own thing
11:37:09 <merijn> I asked for recommendations on what to read to get closer to what GHC does now, but not one could tell me :p
11:37:10 <carter> rwbarton: wat
11:37:11 <rwbarton> (as carter and I have discussed previously)
11:37:19 <rwbarton> isn't it?
11:37:22 <carter> rwbarton: its assumed ther?
11:37:29 <carter>  i remember the Int min mod thingy
11:37:38 <rwbarton> :t plusPtr
11:37:39 <lambdabot> Not in scope: ‚ÄòplusPtr‚Äô
11:37:50 <rwbarton> plusPtr :: Ptr a -> Int -> Ptr b
11:38:08 <carter> ew yeah
11:38:13 <rwbarton> minusPtr :: Ptr a -> Ptr b -> Int -- Computes the offset required to get from the second to the first argument.
11:38:22 <bos> carter: why would you want to do this?
11:38:24 <vanila> Where can I learn modern information on compiling haskell?
11:38:25 <YellPika> XrXr: another thing you can try is to redefine the operator with lower precedence. infixl 5 (!!!); (!!!) = (!!)
11:38:41 <bos> carter: the fact that we can use an Int to index off a Ptr is baked into the language at this point
11:38:43 <carter> bos: so that reid could get his x32 epxeriment working better :)
11:38:43 * hackagebot Glob 0.7.5 - Globbing library  http://hackage.haskell.org/package/Glob-0.7.5 (MattiNiemenmaa)
11:38:46 <vanila> I have been studying the book pj lester
11:38:52 <|akh|> Hi, I'm new here. When repeatedly (forever $ do) running Network.accept on a welcoming socket and passing the returned handle to another function in another thread, should the handle be closed? This gives me "HttpServer: <socket: 11>: hClose: resource vanished (Broken pipe)".
11:39:03 <XrXr> YellPika: I will just stick to my brackets :) thanks
11:39:10 <carter> bos: i'm not saying its a change that should happen, or even be exposed to end users
11:39:16 <carter> but its something I think is worth exploring
11:39:39 <merijn> |akh|: Might mean the other side disconnected?
11:40:04 <carter> bos: OR i need a way to statically decide which ints might be pointerlike or not
11:40:17 <carter> because one thing I'd like to figure out is when it'd be safe / cheap to use SIMD on ints
11:40:19 <carter> in haskell
11:40:35 <YellPika> vanila:http://www.aosabook.org/en/ghc.html has some interesting stuff on GHC
11:40:41 <carter> you have to do a whole read/write to some scratch space to move between pointery registers and simd
11:40:59 <carter> and maybe thats fine in practice
11:41:03 <carter> but ... ewish
11:41:04 <vanila> thank you
11:41:32 <tommd> |akh| No unless you closed the handle or the other side disconnected, passing handles between Haskell threads should be perfectly fine.
11:41:37 <carter> ok
11:41:38 <carter> g2g
11:43:15 <|akh|> merijn: Okay, but will the handle and the socket be closed by itself when the client disconnects?
11:43:44 * hackagebot data-lens-light 0.1.0.2 - Simple lenses, minimum dependencies  http://hackage.haskell.org/package/data-lens-light-0.1.0.2 (RomanCheplyaka)
11:47:27 <tobiasgw> any good reason why head, tail etc. raise errors when applied to empty lists, instead of returning Maybe?
11:47:53 <rwbarton> yes
11:48:08 <rwbarton> sometimes you know the list is nonempty
11:48:09 <|akh|> tommd: The client is a web browser so I suppose it closed the connection before reaching hClose. Is the handle and socket closed by themselves when the client disconnect? Should handles from Network.accept be closed?
11:48:36 <jfischoff> rwbarton: why not use NonEmpty then?
11:49:38 <tobiasgw> rwbarton: but shouldn't there rather be a more specific function for non empty lists then, instead of the most generic functions (head and tail)
11:51:02 <rwbarton> tobiasgw: well, you can quibble endlessly over names, they are ultimately a historical artifact
11:51:04 <vanila> jfischoff, nonempty is probably not useful in real programming, is it?
11:51:06 <tommd> |akh| Are you saying closing the Handle is causing an exception?
11:51:17 <jfischoff> vanila: oh?
11:51:40 <tommd> |akh| I've not experienced that but you can always use `_ <- Control.Exception.try (hClose hdl)`
11:51:48 <jfischoff> vanila: we use it at work
11:52:08 <tommd> |akh| Closing sockets that have been disconnected should NOT result in an exception.
11:52:13 <|akh|> tommd: No exception, but "HttpServer: <socket: 11>: hClose: resource vanished (Broken pipe)" is printed.
11:52:15 <jfischoff> just to be clear I mean this: http://hackage.haskell.org/package/semigroups-0.8.3/docs/Data-List-NonEmpty.html
11:52:38 <tommd> |akh| So I take it you aren't dealing with the handle yourself but using a framework?
11:52:49 <tommd> I'm not big on any of the web frameworks so can't really help you there.
11:53:04 <rwbarton> jfischoff, the fact that it's incompatible with the ordinary list type means it's way more trouble than it's worth
11:53:09 <vanila>  cycle [1,2,3] = 1 :| [2,3,1,2,3,...]
11:53:11 <vanila> looks wrong to me
11:53:16 <rwbarton> at least in my opinion / most of the time / etc.
11:54:10 <|akh|> tommd: I'm not using any framework, just Network for accept and listenOn and parsec for a http parser module. I have no idea what prints that text.
11:54:38 <jfischoff> rwbarton: I hold a similar opinion about head ;)
11:54:55 <tommd> |akh| Well the 'network' package didn't (and I'm assuming "doesn't") have any notion of HTTP.  Do you have another package that is HTTP specific?
11:54:57 <rwbarton> jfischoff: and there are many variants (non-empty lists, infinite lists, lists of odd length etc.)
11:55:24 <rwbarton> jfischoff: hopefully some day LiquidHaskell will provide a more practical solution
11:55:47 * jfischoff nods
11:56:05 <jophish> Can I get cabal to tell me why I have two versions of one package installed?
11:56:55 <jfischoff> the why is because you installed them. what are you trying to do?
11:57:22 <n-dolio> Cabal doesn't keep track of why it installed things.
11:57:51 <bennofs> jophish: ghc-pkg unregsiter <pkg>-<version> will print an error if other packages still depend on that package
11:57:52 <|akh|> tommd: No I don't, but it appears to occur when writing some non HTTP related text to the client (browser) with hPutStr.
11:57:59 <jophish> bennofs: I'll try that
11:58:13 <|akh|> tommd: Followed by a call to hClose.
11:58:25 <SrPx> Uh suppose I want to change the name of a variable that is used in too many places... or switch the order of the arguments. Is there any tool I can use to do that automagically for me?
11:58:27 <jophish> one is in $HOME/.ghc the other is in /usr/local
11:59:47 <XrXr> how come i need to include Fractional in my function signature when need to do division? in ghci I can do 5/4 and when I check the typeclass of 5 its just Num. Maybe when I do 5/4 ghci inteprete 5 as Fractional
12:00:00 <newsham> ?type (/)
12:00:01 <lambdabot> Fractional a => a -> a -> a
12:00:02 <joseph07> SrPx: I think the HaRe package might interest you
12:00:03 <newsham> ?type div
12:00:04 <lambdabot> Integral a => a -> a -> a
12:00:04 <jophish> ah, only mtl depended on the newer transformers
12:00:17 <newsham> > 12 `div` 5
12:00:18 <lambdabot>  2
12:00:38 <geekosaur> XrXr: numeric literals can be anything. (/) forces the Fractional constraint.
12:00:49 <joseph07> SrPx: I don't think you can safely automate changing the order of function arguments because of currying
12:01:00 <XrXr> geekosaur: I guess thats why
12:01:06 <SrPx> joseph07: ah makes sense
12:01:10 <geekosaur> this tends to be very confusing, yes
12:01:13 <SrPx> joseph07: ty
12:01:18 <Franciman> hi all
12:01:47 <Franciman> Are Arrows being used in haskell lately?
12:02:31 <Franciman> If so, in what applications?
12:02:43 <|akh|> tommd: Maybe the parsing can't finish, because the server only react when I stop the request in the browser, and at that point the connection is closed so hPutStr prints an error for some reason.
12:04:06 <intrados`> I'm new to recursion schemes. How would I schemify this: http://lpaste.net/103831? It would be a paramorphism, right?
12:06:29 <|akh|> tommd: Anyway, I have something to look into now, thanks for the help.
12:06:50 <tommd> What little there was, you are welcome to it.  Good luck.
12:08:43 <XrXr> ermagerd, unique visitor on my haskell practice project on github has 2 unique visitors. Its 1 for almost every other repo
12:16:00 <mathkr> Hello! I've been doing the assignments of http://www.seas.upenn.edu/~cis194/lectures.html and was wondering if anybody wants to share and compare their solutions to the code golf assignment. Mine is available here: https://github.com/mathkr/cis194/blob/master/homework03/Golf.hs
12:16:14 <johnw> Franciman: not so much, but HXT uses it
12:16:20 <Jefffrey> Hello
12:16:37 <YellPika> Franciman: netwire uses arrows as well
12:16:46 * shapr tries to drum up conversation on the #haskell-web irc channel
12:16:52 <Jefffrey> I think I love Haskell. Is there a cure?
12:17:02 <shapr> Jefffrey: make money loving Haskell
12:17:10 <shapr> XrXr: what's your github project url?
12:17:11 <Franciman> and what are the advantages of using arrows?
12:17:12 <zomg> Jefffrey: large amounts of PHP
12:17:30 <shapr> Can arrows be point-free?
12:17:32 <Jefffrey> zomg: no PHP please :D
12:17:55 <XrXr> shapr: https://github.com/XrXr/TheHaskellExperience XDD
12:18:08 <YellPika> Franciman: #1 reason seems to be performance. Also, arrowized FRP avoids time leaks that occur in monadic FRP.
12:18:40 <shapr> XrXr: looks like fun!
12:18:44 <YellPika> shapr: I guess? Arrow derives from Category, which defines the (.) operator.
12:18:55 <XrXr> thanks shapr :)
12:19:24 <shapr> XrXr: How do I figure out how many views my github projects have gotten?
12:19:35 <Tehnix> does anybody have any good resources or tutorials on Haskell and iOS with GHC 7.8?
12:20:12 <XrXr> shapr: go to the repo page click graphs on the right, then click traffic
12:20:21 <shapr> ooh, neat
12:21:12 <Franciman> YellPika: and where can I find what lets arrows produce better performances?
12:21:16 <peddie> Jefffrey: try agda
12:22:34 <mathkr> XrXr: Trade views? ;) https://github.com/mathkr/cis194
12:22:53 <YellPika> Franciman: There's a paper called "Dynamic Optimization for Functional Reactive Programming using Generalized Algebraic Data Types" which combines arrows with GADTs.
12:23:06 <XrXr> mathkr: haha ;) looks like I'm not alone
12:23:12 <YellPika> (Hrm, I guess that's more of a GADT thing...)
12:23:13 <Jefffrey> peddie: what's good about it?
12:23:17 <Franciman> YellPika: thanks
12:23:42 <mathkr> XrXr: there are dozens of us! :)
12:24:12 <YellPika> Franciman: It's not that arrows are intrinsically faster, it's just that, since they are less expressive than monads, they are easier to analyze and optimize.
12:24:35 <XrXr> I wish when I get to the course where they teach programming paradigm, we can learn Haskell instead of lisp/scheme
12:25:24 <Franciman> oh ok I get it, it seems
12:25:58 <peddie> Jefffrey: dependent typing mainly
12:26:31 <peddie> Jefffrey: it's not what I'd call useful for programming, but it might make you slightly less head-over-heels for Haskell :)
12:26:56 <YellPika> Jeffrey: Coq and Idris might do it too
12:27:09 <shapr> johnw: Have you done any webdev with Haskell?
12:27:18 <vanila> that liquid haskell thing looks so cool
12:28:33 <johnw> shapr: a little bit
12:29:22 <Jefffrey> YellPika: It's "Jefffrey", with 3 fs :)
12:29:35 <YellPika> Jeffrey: I just realized XD
12:29:40 <YellPika> Ah, crap I did it again
12:29:48 <Jefffrey> lol
12:29:49 <YellPika> Jefffrey*
12:29:51 <YellPika> There
12:30:16 <heudebeu> Hello, I'm currently playing around with Data.Binary and I'm trying to encode some record. I found out that when encoding it prepends the bytes with the length of the bytestring. Is it possible to prepend this length as little endian? http://ix.io/caQ
12:31:10 <fragamus> GHC 7.8.2 type inferrence seems *different*
12:31:44 <fragamus> is it?
12:32:01 <YellPika> I think they overhauled the type inference engine.
12:32:05 <Jefffrey> Does anyone here have any experience with WAI and WARP?
12:32:06 <jle`> heudebeu: the do is redundant btw
12:32:12 <johnw> Jefffrey: I have some
12:32:34 <heudebeu> yes i know :)
12:33:29 <Jefffrey> johnw: I don't quite understand the response type. Which type constructor should I use for plain text?
12:33:46 <heudebeu> jle': want the output of the hexdump to be 08 00 00 00 <bytes of the string>
12:33:58 <jle`> is that length there for every string?
12:34:04 <jle`> or just the beginning of the encoding?
12:34:40 <jle`> if it is before every string, then it looks like it's just the part of the Binary instance for String
12:34:47 <Jefffrey> Actually I don't understand the last two. I have at least an idea of what the first two do. (source here: http://hackage.haskell.org/package/wai-2.1.0.2/docs/src/Network-Wai-Internal.html#Response)
12:34:55 <jle`> so you would probably want to write your own Binary instnace
12:34:56 <Cale> heudebeu: That library isn't one that you'd normally use if you care about the exact encoding being used
12:35:06 <jle`> not that i recommend that
12:35:15 <heudebeu> So what library would you suggest Cale?
12:36:25 <johnw> Jefffrey: for plain text use a Builder
12:37:16 <Cale> Well, I guess you can just avoid 'encode'
12:38:07 <Cale> and write everything in the Put monad directly
12:38:39 <Jefffrey> johnw: That was a silly question. I just had to read what Blaze.ByteString.Builder is. I was asking more to understand the other two response type constructors. :)
12:38:40 <heudebeu> so forget about making the Login an instance of Binary?
12:38:51 <m3kzu3> Would it be useful to learn category theory before learning Haskell?
12:38:58 <dwcook> m3kzu3, not especially.
12:38:59 <jle`> heudebeu: http://hackage.haskell.org/package/binary-0.7.1.0/docs/src/Data-Binary-Class.html , ctrl+f "instance Binary a => Binary [a]"
12:39:02 <m3kzu3> ok
12:39:04 <johnw> m3kzu3: not particularly
12:39:07 <jle`> m3kzu3: i...don't really think so
12:39:20 <johnw> the category Hask is special enough that what you'd be learning in CT wouldn't be entirely relevant in all cases
12:39:35 <m3kzu3> ok
12:39:37 <Cale> m3kzu3: Only if you're already a mathematician and you think it will be easy for you :)
12:39:46 <johnw> and we use Hask in restricted ways too (we only use endofunctors, etc)
12:39:55 <Cale> (but even then, it's a detour)
12:40:05 <stelleg> :q
12:40:41 <m3kzu3> ok i'll just learn haskell directly
12:40:46 * stelleg should pay attention to window focus
12:40:53 <m3kzu3> i've reached applicative functors in LYAH
12:40:57 <m3kzu3> things are beginning to heat up
12:41:01 <m3kzu3> and getting confusing
12:41:09 <jle`> m3kzu3: that's what we're here for :)
12:41:25 <dwcook> m3kzu3, try not to be intimidated by the terminology borrowed from CT. It's often not a direct analog anyway.
12:41:26 <jle`> and i doubt learning about CT would help you learn applicative functors in practicality
12:41:27 <m3kzu3> thank heavens for this: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
12:41:31 <Jefffrey> johnw: Thanks, btw.
12:41:41 <Cale> heudebeu: well, use putByteString instead of the instance of put for String, and get something to do the UTF-8 conversion String -> ByteString (converting via Text is a good way to do this)
12:42:31 <nottahdw> is anyone here familiar with the sized-vector package? or, more generally, type-level hats?
12:42:38 <nottahdw> nats.
12:42:49 <johnw> I live for type-level hats
12:42:53 <heudebeu> jle`: thanks for the link
12:43:17 <jle`> oh it just explains where that byte comes from
12:43:21 <jorr> I now really want a type-level hat
12:43:25 <jle`> byte(s)
12:44:01 <heudebeu> Cale: thanks
12:44:15 <heudebeu> i'll go back to trying some stuff out :)
12:44:24 <monochrom> pictures are usually incorrect
12:44:26 <Cale> Type-level hats are a great idea. I think the GHC developers really need to copy their monetisation strategy from Valve in this regard :D
12:45:22 <dwcook> m3kzu3, that page gives you a nice intuition for some Functors and Applicatives and Monads but the "wrapped value" analogy only goes so far.
12:45:30 <monochrom> or rather, pictures admit even more ambiguity than natural language. while an author clearly has the right interpretation in mind, a reader is unlikely.
12:45:37 <dwcook> @quote /bin/ls
12:45:37 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:45:54 <m3kzu3> ok so what should i keep in mind
12:46:02 <m3kzu3> after looking at these pics
12:46:11 <dwcook> m3kzu3, that an instance of these classes doesn't necessarily "contain" a value in a reasonable sense.
12:46:25 <dwcook> Maybe does, [] does, Either does, but IO does not.
12:46:32 <m3kzu3> dwcook: that seemed the case with the functions
12:46:37 <m3kzu3> Functor on function
12:46:46 <m3kzu3> nothing was contained anywhere
12:46:49 <jle`> yeah, so you should be aight
12:46:49 <dwcook> Yeah.
12:46:52 <monochrom> "meanginful" identifiers already admit enough ambiguity. just a few days ago, a beginner asked "I have (n `elem` mylist), why is it not telling me whether mylist has n elements?" can you fancy that?
12:47:25 <shachaf> The "wrapped value" analogy only goes so far, and it goes in the opposite direction.
12:47:55 <monochrom> a picture's ambiguity can only be worse than a meaningful identifier such as elem.
12:48:19 <jle`> or rather, the picture's non-abstractness
12:49:14 <monochrom> the best part of it is that you get this delightful feeling that you have learned something. meanwhile no one knows what you have learned.
12:50:16 <jle`> m3kzu3: it's good that you can see functions as F/A/M
12:50:17 <jle`> :)
12:50:22 <Sonarpulse> alex doesn't seemed to be getting called for cabal test, just cabal build. I double checked and alex is listed under build tools for both.
12:50:28 <jle`> m3kzu3: maybe you caught one interesting detail
12:50:29 <Sonarpulse> anybody have any ideas?
12:50:42 <jle`> m3kzu3: "(->) a" is the Functor/Applicative/Monad, right?
12:51:49 <FreeFull> jle`: (->) a is all of those, although usually the a would be named r
12:54:25 <m3kzu3> jle`: haven't gotten that far yet
12:54:31 <jle`> mk
12:54:37 <dwcook> There are also various specialized function instances, such as Reader, Writer, and State
12:54:58 <jle`> i wouldn't call Writer a specialized function instance, i think
12:55:00 <jorr> writer is just (a,w)
12:55:06 <dwcook> My mistake
12:55:16 <jorr> State and Reader work though
12:55:28 <dwcook> Reader a b is just a -> b and State a b is just a -> (b, a) though
12:58:31 <albeit> If I have something :: [[a], and I want to call f on every item in the inner arrays, is the only way to do that "map f . concat lists"?
12:58:38 <albeit> * :: [[a]]
12:58:54 <dwcook> albeit, what's the type of the function you're looking for?
12:59:16 <dwcook> "call f on every item" has more than one meaning
12:59:24 <pavonia> :t map (map f)
12:59:25 <lambdabot> (FromExpr b, Show a) => [[a]] -> [[b]]
12:59:37 <albeit> (a -> b) -> [[a]] -> [b]
13:00:16 <pavonia> So you don't want to preserve structure?
13:00:32 <albeit> I do want to preserve the order, both of the outer and inner lists
13:01:06 <jle`> albeit: well, map turns an (a -> b) into an ([a] -> [b])
13:01:10 <jle`> so map twice
13:01:26 <jle`> (map . map) turns an (a -> b) into an ([[a]] -> [[b]])
13:01:27 <dwcook> Yeah \f xs -> concatMap (map f) xs
13:01:42 <dwcook> Also known as \f xs -> concat (map (map f) xs)
13:02:13 <albeit> Thanks!
13:02:15 <jle`> > (map . map) (+5) [[1,2,3],[6,7,8],[10,11,12]]
13:02:16 <lambdabot>  [[6,7,8],[11,12,13],[15,16,17]]
13:02:18 <newsham> ?type foldMap . foldMap
13:02:20 <lambdabot> (Monoid m, Foldable t1, Foldable t) => (a -> m) -> t (t1 a) -> m
13:02:31 <Sonarpulse> problem solved: other modules
13:04:51 <dwcook> Too bad djinn doesn't know about [].
13:04:54 <FireFly> dwcook: aka  concat .: map . map  where (.:) = (.) . (.)?
13:05:14 <dwcook> FireFly, sure, if you want, though some people frown on (.:)
13:05:19 <FireFly> @ty (.:)
13:05:20 <lambdabot>     Not in scope: ‚Äò.:‚Äô
13:05:20 <lambdabot>     Perhaps you meant one of these:
13:05:20 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
13:05:36 <FireFly> I guess it got removed when lambdabot moved to another server
13:05:47 <albeit> What is ".:" called?
13:05:51 <dwcook> It might have been user-defined and since cleared
13:05:59 <ion> albeit: ‚Äúbad‚Äù
13:06:57 <dwcook> Fortunately I've only ever discussed it online so I don't need to know how it's pronounced :P Though to be perfectly clear I'd say "dot colon"
13:07:36 <newsham> ?let (.:) = (.) . (.)
13:07:38 <lambdabot>  Defined.
13:07:43 <JoaoPortela> :t .:
13:07:44 <lambdabot> parse error on input ‚Äò.:‚Äô
13:07:49 <JoaoPortela> :t (.:)
13:07:50 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:08:12 <JoaoPortela> :t (.)
13:08:13 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:08:36 <newsham> ?type (.:) (+)
13:08:37 <lambdabot> Num b => (a -> a1 -> b) -> a -> a1 -> b -> b
13:09:33 <JoaoPortela> when does lambdabot foget about '?let'
13:09:42 <newsham> when you tell it to ?forget
13:09:42 <hpc> @undefine
13:09:42 <lambdabot> Undefined.
13:09:44 <dwcook> The only place I've really seen it used is to make (f .) . g look nicer, which in turn mostly arises from trying to make a function pointless
13:10:09 <JoaoPortela> newsham: thanks
13:10:42 <deweyvm> trying to figure out why (,) <$> (integer <* reserved ":") <*> integer won't parse "14:15" but will parse "14 : 15"
13:10:57 <dwcook> deweyvm, what's integer?
13:11:26 <deweyvm> P.integer lexer
13:11:32 <deweyvm> P = Text.Parsec.Token
13:12:18 <dwcook> This probably calls for a complete code sample using a paste site
13:12:31 <klrr__> anyone know how you would model a flag with an optional argument with optparse-applicative?
13:14:23 <deweyvm> dwcook: http://lpaste.net/103834
13:14:34 <deweyvm> hardcoded a string at the end there
13:14:56 <identity> klrr__: could it be 'flag' from Opt.App.Builder?
13:15:41 <jorr> flags don't have arguments at all, according to the docs
13:15:54 <klrr__> ha! how stupid i am, thanks identity
13:16:02 <identity> klrr__: there's also something called "value" which literally says "specify a default value for an option."
13:16:10 <jorr> Possibly a command would work for thais
13:16:16 <identity> jorr: hmm, I wouldn't know. I've never used it. just took a look at the docs
13:16:27 <klrr__> identity: neat, thanks!
13:16:31 <jorr> check out Commands here
13:16:34 <jorr> https://github.com/pcapriotti/optparse-applicative
13:17:15 <identity> yeah, it looks like you should be using 'value' then.
13:17:32 <dwcook> deweyvm, my best guess is the spaces are introduced by reserved, but I lack familiarity with the entire Token module, so I might not be of much help
13:18:20 <dwcook> deweyvm, there's this other thing called reservedOp which looks promising.
13:18:48 <deweyvm> dwcook: that seems to work, thanks!
13:19:18 <dwcook> deweyvm, did you also have to add ":" to your reservedOpNames or whatnot? I'm not sure how it works
13:19:26 <deweyvm> yeah
13:19:41 <dwcook> My guess is you're set then
13:22:11 <deweyvm> hmm if i have < and + as reserved ops it doesnt seem to like <+
13:22:37 <deweyvm> ill try symbol
13:23:03 <deweyvm> that works
13:25:10 <m3kzu3> is haskell programming without functors/applicatives/monads possible?
13:25:25 <klrr__> is it possible to write a flag using optparse-applicative that is written like this "-X<argument_here_with_no_space_between"?
13:25:35 <klrr__> m3kzu3: yes
13:25:37 <deweyvm> m3kzu3: sure, why not?
13:25:44 <dwcook> m3kzu3, yes, however it is very common to use IO's (>>=) in particular and arguably you lose out if you just avoid them.
13:25:44 <joelteon> can ghci print out the definition of associated datatypes?
13:25:58 <triliyn> klrr__: short 'X' will accept arguments in that form, but will also accept a space
13:26:11 <m3kzu3> dwcook: but it surely limits what i can do with the lang?!
13:26:12 <jfischoff> joelteon: I think so using :i
13:26:15 <triliyn> I don't think there's a way to force the omission of the space
13:26:19 <merijn> m3kzu3: Not really
13:26:28 <merijn> m3kzu3: It mostly just makes everything more verbose
13:26:44 <dwcook> m3kzu3, not really. You can even define your own typeclasses that are functionally equivalent to them.
13:26:44 <klrr__> triliyn: that's OK
13:27:01 <merijn> m3kzu3: And by "not really" I mean that removing functor/applicatives/monads literally does not stop you from doing ANYTHING. It just makes a bunch of things a lot more verbose and ugly
13:27:06 <dwcook> m3kzu3, if we assume you can't use typeclasses at all, then you lose out on some ability to abstract but functionally the same things as before are possible.
13:27:06 <m3kzu3> ok, so basically, if I didn't use them, I'd have to reinvent them myself
13:27:16 <dwcook> m3kzu3, yeah, and/or repeat yourself a bunch.
13:27:18 <merijn> m3kzu3: Yup, and without syntax support :)
13:27:26 <bennofs> merijn: RebindableSyntax!
13:27:27 <m3kzu3> ok thanks
13:27:28 <m3kzu3> good to know
13:28:12 <klrr__> m3kzu3: they are to make lifes easier, not harder. dont get too confused by the weird name, just learn how to use them and the intituion will come later on
13:28:35 <merijn> m3kzu3: Mostly it's like lists syntactic sugar. You could define your own datatype "data List a = Nil | Cons a (List a)" and write "Cons 1 (Cons 2 (Cons 3 Nil))", but it'd suck a lot more than "[1,2,3]" :)
13:28:38 <dwcook> m3kzu3, imagine a world where instead of fmap we had mapList, mapMaybe, mapEither, mapIO, etc. It'd be uglier but still viable.
13:28:45 <m3kzu3> :)
13:29:03 <m3kzu3> do you guys prefer to use fmap instead of map for lists and Data.Map?
13:29:08 <m3kzu3> just to use same fmap everywhere
13:29:14 <m3kzu3> even if they're same
13:29:17 <m3kzu3> fmap = map
13:29:19 <klrr__> triliyn: how would you write that then?
13:29:23 <dwcook> m3kzu3, if I know I'm working specifically with a list, I may use map, just like I may use concatMap instead of (>>=).
13:29:31 <m3kzu3> ok
13:29:38 <newsham> m3kzu3: if you write your code generically you might get to reuse it more often
13:29:46 <eizo> :t (>>=)
13:29:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:30:22 <newsham> why write a function to "sum up all the items in a list" when you can just as easily write a function to "reduce the elements of an arbitrary data structure using an associative binary operator"?
13:30:26 <merijn> m3kzu3: You might be interested in this post: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:30:38 <bennofs> if you like to do IO without using the monadic interface, you could try interact
13:30:41 <bennofs> @ty Internet13
13:30:42 <lambdabot> Not in scope: data constructor ‚ÄòInternet13‚Äô
13:30:44 <bennofs> @ty interact
13:30:44 <lambdabot> (String -> String) -> IO ()
13:30:59 <merijn> m3kzu3: It explains how you could replace typeclasses with just "plain haskell" including an example of how to implement the Monad typeclass
13:31:16 <m3kzu3> ok thanks
13:31:18 <m3kzu3> bookmarked
13:31:37 <triliyn> klrr__: I haven't used optparse-applicative in a while so I don't remember very well
13:32:33 <klrr__> triliyn: wait i get what you said now, thanks! :)
13:32:48 <triliyn> Glad I could help :)
13:33:32 <jfischoff> is there overhead assiocated with using higher rank types?
13:33:50 <jfischoff> higher rank types with class constraints that is
13:36:09 <merijn> jfischoff: There shouldn't be, I think
13:37:03 <albeit> What would be the most efficient way to modify the last item on each sublist in a list of lists, but otherwise keep the list of lists the same?
13:37:21 <dwcook> albeit, using a different data structure
13:37:37 <albeit> dwcook: Got it
13:37:49 <dwcook> e.g., an Array or Seq
13:37:55 <dwcook> (I think Seq works?)
13:39:14 <dwcook> Never mind, I don't think Seq has an efficient "last element" operation
13:39:37 <triliyn> dwcook: doesn't it? I thought it did
13:39:44 <dwcook> triliyn, it's not O(1) I mean
13:39:56 <triliyn> hmm
13:40:12 <dwcook> An Array with known length has O(1) last element access
13:41:12 <jfischoff> dwcook: http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Sequence.html#v:viewr is not O(1)?
13:41:29 <dwcook> Oh, yeah. Looks like you're right.
13:41:39 <dwcook> I was looking at index which I suppose was foolish.
13:41:53 <dwcook> Oh, *and* I misread it.
13:44:31 <Flonk> I fail to see why using difference lists is more efficient when appending lots of lists to one another
13:45:01 <Flonk> It seems to have something to do with the fact that composition is O(1)
13:45:07 <jfischoff> it reassociates the appending
13:45:40 <shachaf> Flonk: Computing ((a ++ b) ++ c) means traversing a twice.
13:45:53 <shachaf> Whereas (a ++ (b ++ c)) only traverses a once.
13:46:18 <shachaf> (((a ++) . (b ++)) . (c ++)) [] becomes (a ++ (b ++ (c ++ [])))
13:46:18 <dwcook> @info (++)
13:46:18 <lambdabot> (++)
13:46:23 <dwcook> :i (++)
13:46:29 <jfischoff> @src (++)
13:46:29 <lambdabot> []     ++ ys = ys
13:46:29 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:46:29 <lambdabot> -- OR
13:46:29 <lambdabot> xs ++ ys = foldr (:) ys xs
13:46:29 <shachaf> As does ((a ++) . ((b ++) . (c ++))) []
13:46:46 <dwcook> I was looking for the associativity. Local ghci says infxr 5 ++
13:46:47 <newsham> > ((a++) . (b++) . (c++)) []
13:46:47 <Flonk> shachaf: Ah, I see
13:46:48 <lambdabot>  Couldn't match expected type ‚Äò[a]‚Äô
13:46:48 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
13:46:48 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
13:46:48 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
13:46:50 <dwcook> infixr*
13:46:54 <Flonk> That makes sense
13:47:01 <Flonk> shachaf: Thanks for clearing that up :)
13:56:43 <merijn> Is there a more efficient way of building strict Text than using mconcat/mappend? Or is the Builder stuff just for lazy Text?
13:56:53 <mwoehrle> @src foldl
13:56:53 <lambdabot> foldl f z []     = z
13:56:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:59:48 <johnw> merijn: the Builder can accept strict text, and you can render it to strict text at the end
14:00:19 <johnw> the characteristics of doing so should be similar to using a different list
14:01:56 <merijn> johnw: Well, the question is "is it more efficient if I'm just appending a bunch of small Text together just before writing it out anyway"
14:02:49 <merijn> If the difference is negligible I'll just not care :)
14:03:50 <Srpx> So I have just wrote a function that I don't know the type... can I ask GHC to tell me the type?
14:04:12 <vanila> If I am building a nested sequence of parsers, should i use foldl or foldr?
14:04:23 <dwcook> Srpx, you sure can. One way is to go to ghci and write :t someExpression
14:04:38 <dwcook> There are also type holes but I haven't played with those yet
14:05:11 <Srpx> dwcook: but without ghci? Just compiling? (It is faster to just compile, than to leave VIM, go to ghci, load it and check)
14:05:25 <dwcook> Srpx, type holes then
14:05:33 <Srpx> (I have tried "function :: _" heh)
14:05:56 <glguy> Srpx: You can leave GHCi open while you edit with Vim
14:06:05 <dwcook> Srpx, http://www.haskell.org/haskellwiki/GHC/TypedHoles
14:06:11 <Srpx> glguy: in other terminal tab?
14:06:21 <glguy> also there are plugins for vim to check types and even insert them into your file
14:06:33 <glguy> Srpx: You can arrange them however you like
14:06:46 <eizo> Srpx: you load your file in ghci using :l file.hs, and whenever you make a change in your file, you just type :r to reload your file
14:06:51 <dwcook> Hmm, though this might not be directly applicable come to think of it
14:06:56 <Srpx> glguy: I am postponing learning those plugins for some time already ):
14:07:13 <johnw> merijn: good question
14:07:32 <johnw> merijn: it'll be equivalent to T.append a . T.append b . T.append c
14:07:56 <johnw> which can be more efficient if doing it directly would associate wrong
14:07:57 <Srpx> what does this mean!? http://o7.no/1hAMMjz
14:08:36 <merijn> johnw: Sure, but mconcat and mappend should associate the right way, no?
14:08:41 <Srpx> that all is the type?
14:08:49 <dwcook> Srpx, that url seems to be missing
14:09:04 <eizo> yes, how the hell did you write such a function?
14:09:06 <johnw> merijn: it depends on whether you call them all at once or piecemail
14:09:09 <johnw> piecemeal
14:09:12 <Srpx> http://o7.no/1hAMMjz works now? dwcook
14:09:14 <johnw> for example, if you are using them in foldl' or foldr
14:09:19 <dwcook> Yeah
14:09:27 <dwcook> Well this is a heck of a type
14:09:33 <Srpx> Should I ... annotate it?
14:09:36 <johnw> if the way you're calling them associates correctly, then all is good
14:09:42 <johnw> the dlist approach forces them to associate the best way
14:09:48 <eizo> Srpx: can you post the function?
14:09:54 <Srpx> sure, a second
14:10:09 <Srpx> http://lpaste.net/103836
14:10:14 <identity> You should kill it before it lays eggs
14:11:16 <Srpx> identity: why
14:11:20 <eizo> Srpx: you have 9 lines in your type, the 8 first lines correspond to the 8 arguments of your function (f g h ...), and the last line corresponds to the return value
14:11:39 <Srpx> eizo: yes I know, is it ok?
14:12:05 <dwcook> Well the root of this is really that you seem to have a pretty complex type. That's not necessarily a bad thing, depends on what you need it for
14:12:10 <eizo> what do you mean by ok? if ok = reable, then no :)
14:12:14 <eizo> readable
14:12:28 <dwcook> I'd say the definition is pretty readable. The type maybe less so
14:13:05 <Srpx> I see, should I rework that function then? It is great because it really simplify all the other functions on the file (they don't need to worry about navigating the type anymore)
14:13:27 <eizo> dwcook: if  f g h i cf cg c x are clear from context then yes, but there i don't know
14:14:13 <Srpx> eizo: but if I make much bigger names then the rest of the function becomes unreadable
14:14:16 <dwcook> Really the main problem I'd say is that the type and constructor names are nondescript
14:14:16 <glguy> Srpx: If you're really concerned about it, make a record that contains those 8 functions
14:14:24 <glguy> (or however many there are)
14:14:36 <glguy> and give the fields decent names
14:14:48 <glguy> and have your 'fold' take that record as an argument
14:15:03 <glguy> then you won't have to rely on positional arguments at your call-sites
14:15:16 <eizo> Srpx: it's just that i'm not used to 8 arguments, but yeah maybe the idea of putting them all in a record is fine
14:15:24 <Srpx> eizo: maybe you'd prefere "f pairTransform singleTransform atomTransform terminalTransform pairContext singleContext atomContext terminalContext term" ?
14:15:34 <Srpx> hmm
14:15:44 <Srpx> glguy: makes sense
14:15:57 <glguy> Srpx: No, it doesn't help to name them in the definition. It's already pretty clear when looking at that function what's going on
14:16:16 <Srpx> glguy: I like your idea, let me see if I can work that
14:16:30 <dwcook> I like to name fold parameters after the case they replace. e.g., foldList cons null [] = null ; foldList cons null (x:xs) = cons x (foldList cons null xs)
14:16:31 <eizo> yes the short names are fine
14:16:36 <dwcook> That might or might not lead to something readable here
14:16:59 <dmj``> Anyone ever get "cabal: Codec.Compression.Zlib: premature end of compressed stream" on cabal-install?
14:17:42 <identity> dmj``: sounds like a bad download or something
14:17:45 <glguy> dmj``: It sounds like you either have a source tarball or the index tarball corrupted
14:18:00 <glguy> You might run with -v to see if you can tell which file that is
14:20:08 <Jefffrey> Evening
14:20:39 <identity> evenin
14:21:33 <dwcook> late afternoonening
14:21:58 <dmj``> glguy identity: I've destroyed and recreated the sandbox multiple times, I have 3 pkgs being add-sourced, rest from hackage
14:22:10 <dmj``> glguy identity: the -v output is 600 lines long
14:22:21 <Fuco> is there some easier way to do this? I have a type "Result" which has three constructors LsSong, LsDirectory and LsPlaylist (from MPD). I want to only get LsDirectory results: filter (\x -> case x of {LsDirectory _ -> True; _ -> False})
14:22:30 <Fuco> that snippet is rather ugly :/
14:22:33 <glguy> dmj``: then you should probably look around lines 580-600 :-p
14:22:47 <glguy> dmj``: and the file in question could be in ~/.cabal/....
14:22:51 <glguy> rather than your sandbox
14:23:24 <dmj``> this is why I hard code all my pkg versions
14:23:25 <solidus-river> what is haskell mainly being used for? like is there one area where haskell is predominant, or one area that haskell is in high use for?
14:23:30 <glguy> -rw-r--r--  1 emertens  staff  5922869 Apr 22  2013 /Users/emertens/.cabal/packages/hackage.haskell.org/00-index.tar.gz
14:23:40 <glguy> Make sure your version of that file isn't truncated, for example
14:24:00 <ion> [ d | LsDirectory d <- xs ]
14:24:02 <glguy> same for any cached source tarballs around that directory if any
14:24:05 <merijn> @quote abstract.research.language
14:24:05 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
14:24:12 <merijn> solidus-river: For that ^^^
14:24:37 <covi> Is "existential dependent type" the same as "dependent sum type"?
14:24:58 <solidus-river> merijn: cant tell if that was sarcastic or not or what part of it was which
14:26:33 <dmj``> solidus-river: facebook uses it, banks use it, consulting firms use it, academics use it
14:26:43 <dwcook> solidus-river, the quote is a response to something along the lines of "Haskell is an abstract research language with no real-world use", but the list of fields is real
14:26:52 <merijn> solidus-river: It was a sarcastic but true reply to the question "is haskell used in the real world?" question
14:27:01 <solidus-river> aye, what does facebook use it for?
14:27:22 <dmj``> glguy: found it
14:27:29 <glguy> Was I close?
14:27:54 <dmj``> glguy: can you try cabal unpack snap-loader-static && cd snap-loader-static && cabal sandbox init && cabal install -j
14:28:06 <dmj``> it should error out immediately
14:28:12 <mmachenry> merijn: I'm working on convincing my boss to let me write a new project in Haskell‚Ä¶ so we might be one new commercial user.
14:28:12 <dmj``> I'm on OSX
14:28:46 <solidus-river> just curiouse, i'm ont doubting its uses, I love the language, just wondering where its in use, of those listed phone apps / web services seem most interesting
14:28:49 <johnw> dmj``: Nix on OS X is great! :)
14:29:06 <dmj``> johnw: :) I've heard good things
14:29:16 <identity> dmj``: I can do that, sec
14:29:43 <moop> sup guys
14:29:48 <dmj``> identity: I'll post it on #snap-framework
14:29:51 <moop> my head broke on powerset implementation
14:29:53 <moop> powerset xs = filterM (\x -> [True, False]) xs
14:29:59 <identity> dmj``: 0.9.0.2, yes?
14:30:00 <solidus-river> mmachenry: you should be convincing your teammates and your boss should but out of the way imo
14:30:04 <glguy> dmj``: http://lpaste.net/103839
14:30:06 <dmj``> identity: yes
14:30:09 <dwcook> moop, expand the definition of filterM.
14:30:12 <dwcook> @src filterM
14:30:12 <lambdabot> Source not found. Sorry.
14:30:20 <dmj``> glguy: what OS?
14:30:25 <glguy> OS X 10.9
14:30:25 <identity> dmj``: works fine here.
14:30:32 <dmj``> Œª Davids-MacBook-Pro Desktop ‚Üí cun snap-loader-static
14:30:32 <dmj``> Unpacking to snap-loader-static-0.9.0.2/
14:30:33 <dmj``> cabal: Codec.Compression.Zlib: premature end of compressed stream
14:30:37 <dwcook> moop, see here http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM
14:31:07 <moop> dwcook: oh i see
14:31:17 <dmj``> johnw: I've been meaning to try it out, honest
14:31:21 <dwcook> moop, of course it takes some mental effort to trace it but it will be worth it
14:31:28 <dmj``> glguy identity: ok looks like it's just me then, thanks for the help
14:31:32 <moop> dwcook: ty, i will try to grok it
14:31:44 <moop> but right now my mind is full=blown mode
14:32:22 <dwcook> moop, oh, and you'll also be needing the definition of (>>=) at lists, which is implicit in do notation
14:32:42 <fl0w_> I was just going through some interview questions
14:32:51 <dwcook> moop, are you aware of how to desugar do?
14:32:51 <fl0w_> let's say you have to find the longest sublist in a list of lists
14:33:20 <fl0w_> This has to be in O(n^2), because to get the length of the sublists ,you have need O(n) each, right?
14:33:22 <dwcook> moop, read the translation box here: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
14:33:28 <johnw> headMay (sortBy (comparing length) xs)
14:33:42 <fl0w_> so there is no way to improve upon that?
14:33:52 <merijn> fl0w_: Well, O(n*m)
14:33:58 <johnw> you need to know the length to know which is longest
14:34:03 <johnw> and you need to look at them all
14:34:36 <merijn> fl0w_: Actually, no the complexity is non-trivial to describe, as it depends on the average length of said lists :p
14:34:37 <dwcook> Technically you don't need the length, you can just keep checking the next element in all till all but one still have elements left
14:34:42 <dwcook> But that seems messy
14:34:48 <dwcook> and probably not much more efficient
14:35:23 <merijn> Actually, I think this is O(n)
14:35:36 <fl0w_> wait, shouldn't the complexity be O(n)
14:35:37 <fl0w_> same idea
14:35:44 <fl0w_> because you're just looking at the sublists
14:35:54 <merijn> For a fixed length input list you need O(n) * the number of lists
14:36:47 <fl0w_> so this would be an example where functional languages would be inferior
14:36:56 <johnw> how is that?
14:36:57 <dwcook> fl0w_, this is an example where lists are inferior
14:37:11 <vanila> i have extremely slow parsing in haskell :(
14:37:12 <absence> what do people use for editing haskell source, other than vi/emacs? sublime?
14:37:14 <fl0w_> since in, say, Python or Java, the list length is an integer you can access (well, array lenght, with fixed lenght arrays)
14:37:22 <johnw> we have Arrays too
14:37:25 <hpc> absence: whatever you can get your hands on
14:37:34 <vanila> fl0w_, the haskell type [] is actually LINKED LIST
14:38:07 <dwcook> Beyond that, making sweeping statements about "functional languages" requires that you define that term :)
14:38:12 <dwcook> Good luck doing so
14:38:25 <dwcook> To some people, Python is functional
14:38:41 <absence> hpc: well yes, i realise that it's technically possible to even use notepad, i was hoping for some good suggestions :)
14:39:07 * hackagebot hledger-lib 0.23.2 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.23.2 (SimonMichael)
14:39:08 <fl0w_> dwcook: well, let's not be too nit-picky; to me Python is not a functional language, and generally I don't think it's seen as one
14:39:09 * hackagebot hledger 0.23.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.23.2 (SimonMichael)
14:39:11 * hackagebot hledger-web 0.23.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.23.2 (SimonMichael)
14:39:19 <mmachenry> dwcook: And the creator famously does not understand functional programming.
14:39:19 <c0a8> it has functional aspects
14:39:28 <c0a8> and gimped lambdas :(
14:39:35 <dwcook> fl0w_, better example: Lisp
14:39:40 <dwcook> Functional or no?
14:39:46 <fl0w_> not purely functional
14:39:50 <fl0w_> since it has mutation
14:39:51 <dwcook> I would call Lisp a procedural language
14:40:10 <LordBrain> seems to me, nobody should be famous for not understanding something, as everyone doesn't understand something until they do
14:40:18 <mmachenry> "I didn't view Python as a functional programming language." - Guido Van Rossum
14:40:24 <merijn> fl0w_: You do realise haskell does have proper arrays and functors, no?
14:40:25 <fl0w_> well, it's not
14:40:36 <merijn> fl0w_: Eh s/functors/vectors
14:40:41 <fl0w_> merijn: let me look up functors...
14:40:48 <Algebr> How does return know what Monad to tag its value with?
14:40:49 <merijn> fl0w_: That was a typo :)
14:40:56 <merijn> Algebr: Type inference
14:41:31 <Algebr> but is it whatever the Monad was that wraps whatever return is called in?
14:41:47 <merijn> fl0w_: So comparing the performance of Java/python arrays with [] is rather unfair
14:41:52 <dwcook> Algebr, return's definition is part of the Monad typeclass, meaning it's defined at each instance separately.
14:41:54 <merijn> > return 'c' :: Maybe Char
14:41:55 <YellPika> fl0w: data List a = List (Int, [a]); nil = List 0 []; cons x (List l xs) = List (l + 1) (x:xs); listLength (List l _) = l; <- constant time length lookup.
14:41:55 <lambdabot>  Just 'c'
14:42:00 <merijn> > return 'c' :: [] Char
14:42:02 <lambdabot>  "c"
14:42:02 <dwcook> s/'s definition//
14:42:08 <Algebr> like, you call return in the Foo Monad and then the value returned is Foo a?
14:42:09 <merijn> > return 'c' :: Either Bool Char
14:42:09 <Algebr> oh
14:42:11 <lambdabot>  Right 'c'
14:42:34 <dwcook> @src [] return
14:42:35 <lambdabot> return x    = [x]
14:42:38 <dwcook> @src Maybe return
14:42:38 <lambdabot> return              = Just
14:43:00 <dwcook> @src (Either a) []
14:43:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:43:02 <dwcook> @src (Either a) return
14:43:03 <lambdabot> Source not found. I feel much better now.
14:43:12 <merijn> @src Either return
14:43:12 <lambdabot> return        = Right
14:43:23 <merijn> dwcook: @src is just a string lookup :p
14:43:33 <dwcook> Heh
14:43:45 <merijn> It is also filled with lies
14:43:47 <merijn> @src sort
14:43:47 <lambdabot> sort = sortBy compare
14:43:56 <merijn> errr
14:43:59 <merijn> @src sortBy
14:43:59 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:44:07 <merijn> That's not how GHC implements sort, for example
14:44:16 <dwcook> Is that what the Report says?
14:44:22 <merijn> dwcook: Probably
14:44:30 <fl0w_> YellPika: That;s a neat idea
14:44:38 <dwcook> But of course the Report says the actual implementation can differ, it just has to behave the same
14:44:45 <merijn> GHC uses an optimised mergesort
14:44:52 <fl0w_> YellPika: but you still wouldn't get constant time lookup
14:45:24 <YellPika> For a single list, yes; for your question, no, it would be linear.
14:45:24 <Algebr> Does anyone do AI in Haskell? Or is that domain still mostly common lisp
14:45:34 <Jefffrey> PROLOG ftw
14:45:48 <YellPika> ^ this
14:46:59 <LordBrain> i think i recall seeing something on hackage that pertained to ai
14:47:10 <LordBrain> genetic algorithms
14:48:12 <LordBrain> http://www.haskell.org/haskellwiki/Category:AI
14:48:49 <Algebr> nice!
14:49:29 <monadicsausage_> Algebr: also might be interested in https://github.com/mikeizbicki/HLearn (intro paper: http://faculty.cs.byu.edu/~jay/conferences/2013-tfp/proceedings/tfp2013_submission_10.pdf)
14:49:40 <Algebr> How can I see all the pages that are available on the wiki? Like I thought just haskell.org/haskellwiki/ would just be a list of all articles available
14:51:18 <Algebr> nvm, I think i found a way, http://www.haskell.org/haskellwiki/Special:Categories
14:51:54 <dwcook> Algebr, there's also the root category, http://www.haskell.org/haskellwiki/Category:Haskell
14:52:25 <Algebr> dwcook: perfect!, thanks
14:54:03 <Algebr> Why doesn't ghc enforce the Monad laws?
14:54:28 <dwcook> Because reasoning about values at compile time is hard
14:54:48 <dwcook> As in it's still actively being studied
14:54:50 <Algebr> seriously? I thought the compiler knew the value of everything.
14:55:00 <dwcook> It knows the *type* of everything
14:55:10 <dwcook> But some values can't possibly be known till runtime
14:55:21 <Algebr> ohhh
14:55:49 <dwcook> I'm sure you could do something like checking Monad laws in a language like Agda or one of the other dependently typed languages
14:56:03 <dwcook> Dependently typed means that values can be used at the type level
14:56:54 <dwcook> Actually even in GHC there are some cases where values can be promoted to type level, see the DataKinds extension. But that still wouldn't let you prove Monad laws at compile time
14:58:22 <Algebr> what is the cardinality of the set of all categories?
14:58:35 <rwbarton> is this a math question or a haskell question?
14:58:45 <Algebr> math
14:58:51 <johnw> try ##categorytheory
14:58:53 <rwbarton> there is no set of all categories
14:58:54 <dwcook> I don't think you can form a set of all categories
14:59:30 <Algebr> Do all the intros to category theory require knowing abstract algebra really well?
14:59:40 <dwcook> Algebr, that's a question for ##categorytheory too
14:59:52 <Algebr> okie dokie.
14:59:55 <dwcook> Haskell is unrelated to category theory, even though it borrows some terms
15:00:02 <LordBrain> there was a page devoted specifically to teaching haskell users category theory
15:00:53 <Algebr> speculative question, but both Simons must be like really good at category theory then?
15:02:04 <johnw> neither of the Simons is much into math
15:02:14 <LordBrain> i think the idea of using monads is what to the category theory influence.
15:02:17 <quchen> Is there a lens to focus on indices only, i.e. if I want to traverse all the "k" in a "Map k v"?
15:02:24 <johnw> I was talking to Simon Marlow about Comonads, and he told me he really isn't into the math theory at all
15:02:44 <johnw> quchen: won't itraverse let you?
15:02:54 <glguy> quchen: You can't traverse them, but you can fold them: asIndex
15:03:13 <Algebr> johnw: then why was category theory used at all? It was just a useful way to deal with side effects?
15:03:40 <identity> pretty much, I think
15:03:41 <mmachenry> Algebr: It was originally suggested by Philip Wadler.
15:03:54 <identity> didn't IO use to be done as continuations?
15:03:54 <quchen> glguy: Ah, missed that one. johnw: That would work, but there usually is a dedicated function to do these special cases. Thanks to both of you :-)
15:03:57 <johnw> yeah, there are more people involved in Haskell's development than the Simons :)
15:03:57 <monadicsausage_> Simon P J did study undergrad math at Trinity College, Cambridge though, which is one of‚Äîif not the‚Äîbest undergrad math courses in the world
15:05:05 <ReinH> Algebr: category theory is an abstract algebra of abstract functions. As such it's a pretty useful way to model a functional language like Haskell.
15:07:05 <LordBrain> our definitions of monad and functor actually seem too restrictive tho, as we should be talking about functors from any subcategory of hask to any other one, rather than just from hask to a subcategory...
15:07:25 <ReinH> LordBrain: functors in Haskell are endofunctors.
15:07:36 <ReinH> I'm not sure what you gain by considering ad hoc subcategories instead.
15:07:54 <LordBrain> well i do not have examples off hand, but i am pretty sure there are gains
15:08:46 <meiji11> I've read voigtlander's paper on asymptotic improvement of free monads, which I mostly understand. the one sticking point I have is in understanding how the improve/lowerCodensity function converts a free monad instance to CPS.
15:09:23 * rwbarton wonders where this "functor to a subcategory" notion comes from
15:10:39 <LordBrain> more so for functors than for monads
15:11:10 <LordBrain> hmmm
15:11:15 <LordBrain> actually it would be useful for monads
15:11:19 <ReinH> Why?
15:12:50 <LordBrain> it means you could have constraints on the value
15:12:58 <ReinH> Like what?
15:13:10 <meiji11> is it just a matter of instantiating the input to be of type Codensity (Free m) a? somehow? how do you reconcile that with the type of lowerCodensity
15:13:52 <LordBrain> really  you wouldn't need a separate omap or monofunctor idea... you could just use map, in this hypothetical universe
15:14:12 <vanila> meiji11, maybe this will help http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Text-ParserCombinators-ReadP.html
15:14:42 <vanila> meiji11, have a quick look at the definition of 'P', and then the implementation instance Monad ReadP
15:14:55 <rwbarton> Is everyone who talks about "functor to a subcategory" thinking of a hypothetical universe?
15:15:10 <rwbarton> If so, I can understand it a bit better
15:16:21 <ReinH> rwbarton: I suppose it's something like "the Functor instance for Maybe maps objects in Hask to objects in a sub-category of Hask defined as the objects that the Functor maps objects to"
15:16:27 <ReinH> Which seems like a particularly boring way to define a category
15:16:28 <LordBrain> yeah also there is the confusion created by functor meaning  endofunctor...
15:16:36 <rwbarton> okay, but that's what any functor from Hask to Hask does
15:16:43 <ReinH> rwbarton: I know. I don't understand it either.
15:17:08 <rwbarton> oh, right :) didn't notice it was someone else writing, sorry
15:17:24 <ReinH> rwbarton: :)
15:17:39 <ReinH> It's also what any endofunctor does.
15:18:34 <rwbarton> I think probably your explanation is right
15:18:37 <phao> Hey. Why is category theory so brought up in discussions about functional programming (in comparison to other styles of programming, in which it isn't brought up at all)?
15:19:12 <dwcook> phao, functional languages have a greater tendency to borrow categorical terminology.
15:19:14 <ReinH> phao: category theory is an (abstract) algebra of (abstract) functions. As such it's a pretty useful way to model a functional language like Haskell.
15:19:26 <uncleBlazer> Is there anything in Haskell that doesn't form the category of Hask -> Hask?
15:19:41 <ReinH> it's an algebraic approach to functional programming, whereas lambda calculus is a "calculational" approach.
15:20:58 <phao> I see.
15:23:52 <intrados`> Can anyone help me recursion-schemify this? http://lpaste.net/103831
15:28:43 <dwcook> intrados`, what does "recursion-schemify" mean?
15:29:42 <intrados`> dwcook: Using anamorphisms, catamorphisms, etc. from the recursion-schemes package
15:32:56 <solidus-river> http://lpaste.net/103842
15:33:06 <solidus-river> i'm having problems using record syntax, what am i doing wrong here?
15:33:18 <solidus-river> it also seems i cant use let statements with variables of the same name as my record field names
15:33:27 <solidus-river> which is why i switched from host to chost
15:33:36 <dwcook> solidus-river, your field names should be qualified too
15:33:45 <dwcook> I think?
15:34:17 <Hafydd> Yes.
15:35:19 <dwcook> By the way, there's no problem with shadowing bindings using let. You'd have to show what you tried there
15:35:38 <dwcook> > let x = False in let x = True in x
15:35:39 <lambdabot>  True
15:36:10 <dwcook> Of course this means you can't access the outer x
15:37:34 <michaelt> solidus-river: why not just import Yaskel.Config (Database(..)) ; import qualified Yaskl.Config as YC
15:39:11 <dmwit> I suppose there are two representations of "10" in scientific notation: 1e1 and 10e0.
15:39:25 <dmwit> Do floating point numbers have a similar property, that there may be many bit sequences representing the same number?
15:39:25 <solidus-river> michaelt: isn't it messy to have two import statements?
15:39:45 <dmwit> solidus-river: I think it's a pretty common idiom.
15:39:55 <michaelt> solidus-river: yeah, I guess, somehow I like the types and constructors to be unqualified, its not uncommon
15:39:56 <johnw> dmwit: what do you mean by the "same number"?
15:39:58 <solidus-river> dwierenga: your right, i was mistaking the error, i shadowed the bindings again and it was fine
15:40:25 <johnw> I guess you could adjust the exponent and yet have the same value
15:40:30 <tromp_> 10 is also 0000.0010e004
15:40:40 * dmwit nods appreciatively at tromp_ 
15:40:46 <rwbarton> dmwit: only NaNs & maybe infinities (I forget)
15:40:48 <johnw> right, exactly
15:41:02 <rwbarton> well, and +- 0
15:41:03 <michaelt> solidus-river: besides, I just noticed Control.Monad has *liftM5*; liftM5 Database (lookup ...) ...
15:41:26 <rwbarton> dmwit: for an ordinary floating-point number there is an implicit 1 bit at the start of the mantissa
15:41:36 <dmwit> rwbarton: Really? So you would never find that, like, 1+1 and 1*2 returned different bit sequences (but both computed as 2)?
15:41:43 <dmwit> rwbarton: I see!
15:41:45 <dmwit> very clever
15:41:50 <rwbarton> yes
15:42:15 <mmirman> Q: http://redd.it/252wb3 any particular reason this implementation of foldl' is bad?
15:43:23 <rwbarton> dmwit: and actually what I said is not entirely true: http://en.wikipedia.org/wiki/Denormal_number
15:43:43 <solidus-river> where can i find a good text on how namespaces work in haskell between module exports
15:44:55 <michaelt> mmirman: It seems similar, but in either case why not just put a bang pattern on z; it isn't really strict, since if xs = [], z neednt be inspected, no?
15:45:23 <dmwit> solidus-river: when module Foo defines name x: import Foo defines x and Foo.x; "as" clauses change Foo.x to Bar.x; "qualified" clauses define only Foo.x
15:45:30 <dmwit> solidus-river: There is not much more to it than that.
15:45:48 <dmwit> solidus-river: In case multiple import statements define a single name, and that name is used in the module body, you get an error.
15:45:58 <solidus-river> dmwit: well for example what if i have a Bar module that defines a data Config and module F..
15:46:01 <solidus-river> ah, you answered it :P
15:46:02 <monochrom> if xs = [], someone else (for example the caller) will force z soon enough
15:46:03 <dmwit> rwbarton: thanks
15:46:30 <michaelt> mmirman: oh i see what youre saying, though now.  my idea would put an implicit seq x before everything, so it isn't tail recursive
15:46:40 <monochrom> however, it is a fairly indirect way to bring strictness to z or z'
15:46:42 <mmirman> michaelt: yeah
15:47:03 <dmwit> solidus-river: You might also like the Report or the beginning of my SO answer here: http://stackoverflow.com/a/8331995/791604
15:48:18 <mmirman> further question: I'm not a weathered reddit user.  Any reasons other than a bug that this post wouldn't be showing up in "new" under Haskell?
15:48:32 <dmwit> mmirman: You could be shadow-banned.
15:48:36 <dmwit> Pretty unlikely if you're new.
15:48:58 <monochrom> I am doubtful that "tail recursion" is important. it is completely beside the point.
15:49:32 <monochrom> lgo z (x:xs) = seq z (lgo z' xs), or seq z' (lgo z' xs), is good.
15:49:49 <monochrom> "is it tail-recursive?" why should you care?
15:50:35 <merijn> dmwit: He could trigger spam detection
15:50:49 <merijn> mmirman: If you triggered the spam flag it will be hidden until a mod approves your post
15:51:09 <michaelt> monochrom: well, there's the question whether the compiler makes something different of these things.
15:51:54 <dmwit> Yes, getting spam-filtered is much more likely than being banned.
15:52:30 <michaelt> somehow mmirman's question doesn't seem too spammy
15:52:59 <mmirman> I don't feel particularly spammy at the moment.
15:53:05 <dmwit> Automatic spam filters are fallible.
15:53:07 <mmirman> Maybe later though.
15:53:13 <dmwit> That's why there are mods.
15:54:14 <monochrom> "does it use O(1) space" is an important question. "does it use tail recursion" is an XY question.
15:54:17 * hackagebot latest-npm-version 0.2.1 - Find the latest version of a package on npm  http://hackage.haskell.org/package/latest-npm-version-0.2.1 (passy)
15:54:46 <monochrom> in any case seq z' (lgo z' xs) still uses O(1) space.
15:59:17 * hackagebot yi-spolsky 0.1 - Spolsky colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-spolsky-0.1 (MarioPastorelli)
15:59:21 <mmirman> monochrom: It is neither productive nor tail recursive, doesn't still need to save state (on the stack) when it evaluates (lgo z' xs)?
15:59:31 <monochrom> no
16:00:12 <rwbarton> seqBool b x = case b of { False -> x; True -> x }
16:00:26 <rwbarton> does this need to "save state" when it "evaluates x"?
16:02:10 <monochrom> the definition of "tail recursion" or "tail call" has also become a moving target.
16:02:57 <mmirman> rwbarton: x isn't being forced there, and if it was, it would be on the tail anyway.
16:03:29 <monochrom> some of you define it syntactically. that's going to be problematic. if I write "f1 s = case s of [] -> 0; x:xs -> f1 xs", you eyeball the syntax and call it tail-recursive.
16:05:27 <monochrom> then I write "f2 s = hello s (f2 (tail s))", and the syntax looks not tail-recursive
16:06:56 <rwbarton> mmirman: right, so it is the same with seq. if you want you can think of it as a mutual tail-recursion between seq and lgo
16:07:10 <monochrom> Ah! but "hello s t = case s of [] -> 0; _ -> t". therefore hello s (f2 (tail s)) = case s of [] -> 0; _ -> f2 (tail s). now it's tail-recursive again.
16:07:31 <rwbarton> but better not to think about "tail recursion" at all, yes
16:08:22 <monochrom> therefore a syntactic definition of tail call is going to be informationless.
16:08:54 <monochrom> ok, so you abandon it and seek a semantic definition. you have to look at the operational semantics, the order of evaluation.
16:09:03 <michaelt> monochrom: but you just reduced the syntactically invisible tail recursion to the syntactically visible one
16:09:26 <michaelt> suggesting maybe it has a certain priority?
16:09:33 <mmirman> I'd buy that in the abstract sense it is possible to call it tail recursive optimizable by an inlining compiler, but is seq inlinable like that, and even if it was, is that optimization made by the compiler?
16:10:18 <monochrom> but then, knowing the order of evaluation supercedes knowing what's tail call. the notion of tail call becomes redundant.
16:10:25 <michaelt> I'm having trouble distinguishing your foldl' from Data.List, but maybe these arithmetical examples are no good.
16:10:44 <solidus-river> wow Text vs String is a pain
16:11:20 <srhb> solidus-river: How so?
16:11:24 <monochrom> mmirman, foldl' still takes O(1) space without inlining.
16:11:27 <michaelt> solidus-river: no, it's strict Text vs lazy Text that's a pain
16:11:58 <solidus-river> srhb: i'm using Data.Yaml.Config to load yaml files which expect lookup to get Keys and returns Keys which are a type alias for Text
16:12:00 <merijn> solidus-river: How is it a pain? You mean explicitly pack'ing String literals to Text? 'cause if so, I have good news
16:12:32 <solidus-river> srhb: this causes anythign i try to do to access the config via writing the key as a string literal to fail with a type error of [Char] vs Text
16:12:48 <srhb> solidus-river: Use the overloaded literals extension
16:12:50 <PhineasRex> You can use the overloaded strings pragma.
16:12:53 <merijn> solidus-river: {-# LANGUAGE OverloadedStrings #-}
16:13:06 <michaelt> solidus-river: merijn & co do have good news for you!
16:14:09 <srhb> solidus-river: It makes "string" literals be polymorphic such that they can be interpreted as Text values instead.
16:14:20 <merijn> solidus-river: That extension implicitly replaces all string literals "foo" to be 'fromString "foo"' with "fromString :: IsString a => String -> a", Text having an IsString instance, of course
16:14:42 <merijn> (Similar to numeric literals being "fromInteger 1")
16:15:42 <michaelt> Of course, this adds a bit of type-class complication to error messages as with Haskell number literals
16:17:17 <u-ou> @pl insertAt n x xs = let (ys,zs) = splitAt n xs in ys ++ x : zs
16:17:17 <lambdabot> (line 1, column 18):
16:17:17 <lambdabot> unexpected " "
16:17:17 <lambdabot> expecting operator
16:17:30 <solidus-river> merijn: you have good news! wait but that still gets confused
16:17:31 <u-ou> u wot m8
16:17:47 <solidus-river> merijn: i guess the problem is that i'm using it within a do block?
16:17:55 <srhb> solidus-river: Hardly.
16:18:00 <solidus-river> the first time I attempt it it works with or without that pragma
16:18:28 <merijn> solidus-river: lpaste your code + error?
16:18:39 <solidus-river> secondtime it either fails with a type of [Char] -> Text mismatch or a type of t0 being ambiguouse
16:22:13 <solidus-river> merijn: http://lpaste.net/5040901831396425728
16:22:39 <mmirman> monochrom: but why? does ghc know that lto isn't going to mangle used registers or that it isn't going to be forced by seq? When (lto z' xs) is finally forced why would it not save any other state?
16:22:53 <u-ou> @pl \n x xs -> let (ys,zs) = splitAt n xs in ys ++ x : zs
16:22:53 <lambdabot> (line 1, column 16):
16:22:53 <lambdabot> unexpected "("
16:22:53 <lambdabot> expecting "()", natural, identifier or "in"
16:23:22 <merijn> mmirman: Well, why would it save state?
16:23:27 <merijn> mmirman: WHich state would it save?
16:23:56 <solidus-river> merijn: but if i do that same thing only using host it compiles fine in boath cases
16:24:33 <merijn> solidus-river: Which package is that using? (The Yaml Config stuff)
16:24:41 <mmirman> merijn: registers that it might mangle. What if "f" uses 10 registers to execute?
16:24:57 <solidus-river> merijn: https://hackage.haskell.org/package/yaml-config-0.2.2/docs/Data-Yaml-Config.html#t:Key
16:25:37 <merijn> solidus-river: Oh, actually it's an unrelated error :)
16:25:55 <merijn> solidus-river: It's actually fairly simple :)
16:25:57 <solidus-river> marijn: ?!?
16:26:02 <merijn> solidus-river: See the return type of "lookup"?
16:26:35 <merijn> solidus-river: It returns an "a" which must be an instance of FromJSON
16:26:48 <merijn> solidus-river: Now look at the error
16:27:32 <merijn> solidus-river: "The type variable `t0' is ambiguous" <- this is code for "there are more than one correct types for this thing and I dunno what the hell you wanted"
16:27:46 <mmirman> merijn: I mean obviously it doesn't matter how many f actually uses, but where's ghc getting that information from?
16:28:03 <solidus-river> merijn: hmm so should i type it with something like
16:28:11 <solidus-river> DYC.lookup "host" :: Text dbconfig
16:28:19 <merijn> solidus-river: Normally GHC infers from the types *which* FromJSON instance you meant, but since you never use "host" anywhere and don't have a type signature on your function GHC doesn't infer what you wanted
16:28:46 <merijn> solidus-river: No, the problem is not with the Strings, but with the result of the entire lookup
16:29:14 <merijn> solidus-river: "lookup :: :: (Failure KeyError m, FromJSON a) -> Key -> Config -> m a" <- GHC doesn't know which 'a' you want
16:29:20 * hackagebot fay 0.20.0.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.3 (AdamBergmark)
16:30:14 <merijn> Try "host <- DYC.lookup "host" dbconfig :: IO Text" (or whatever 'm' and 'a' are supposed to be for you)
16:30:37 <mmirman> like, when we enter lgo, it mangles at least one register the first time which could be important right (the pointer to z' must be saved somewhere)
16:30:57 <merijn> mmirman: Eh, GHC is the thing that generates the code. It know exactly how registers *everything* uses
16:31:17 <merijn> mmirman: That's like asking "how does GCC know how many registers a function uses?"
16:32:10 <merijn> mmirman: Also, GHC uses a caller saves approach. The caller of a functions saves whatever it needs to save, not the function called
16:32:31 <merijn> mmirman: (At least, in the now old docs I read on this, be warned this maybe out of date :)
16:32:37 <mmirman> merijn:  the caller save approach is what I'm missing.
16:32:53 <mmirman> merijn: thanks!
16:33:18 <merijn> mmirman: FYI a good (albeit a bit old and out of date) intro to how GHC actually generates code is the STG paper
16:33:26 <solidus-river> merijn: your right, once i assigned the values to a typed data it compiled smooth
16:33:50 <solidus-river> are there any other cool options like that I should look at before continuing down haskell land?
16:34:24 <merijn> mmirman: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
16:35:12 <merijn> solidus-river: In general, it's recommended to write down type signatures for top level definitions, that would've avoided this problem by specifying the return type of "loadDatabase"
16:37:23 <rwbarton> mmirman: in the expression "z' `seq` lgo z' xs" or "seq z' (lgo z' xs)" -- (lgo z' xs) doesn't get evaluated at all unless it is needed by seq
16:38:32 <solidus-river> is it considered bad or good practice to limit the capabilities of a function by defining a more concrete Type signature
16:38:46 <jfischoff> usually bad
16:38:56 <rwbarton> mmirman: what happens (without optimizations) is: lgo will allocate (on the heap) a structure that represents the delayed computation (lgo z' xs), and pass that as the second argument to seq
16:38:58 <solidus-river> GHC determined that the monad returned by this function could be any thats an instance of System.Control.Failure.Failure
16:39:16 <solidus-river> but thats quite a lot to add to a type signature in the file and i'm using it in an IO do block
16:39:16 <jfischoff> that not so important
16:39:33 <jfischoff> but if it could be unconstrained polymorphic
16:40:02 <jfischoff> then you should make it so, or some more well known class in base
16:40:08 <jfischoff> like Functor etc.
16:40:42 <dmwit> More monomorphic is not more limited, it's less.
16:40:58 <rwbarton> mmirman: seq is supposed to evaluate its first argument and then evaluate and return its second argument, so it will push the second argument (a pointer to that structure) on the stack, evaluate its first argument, then pop the second argument off the stack and evaluate it
16:41:05 <dmwit> forall a. a is the most constraining type of all.
16:41:14 <u-ou> :t randomRs
16:41:15 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
16:41:26 <rwbarton> since it represents a delayed computation this consists of unpacking the structure and then jumping to lgo after setting up the arguments z' xs appropriately
16:41:32 <shachaf> dmwit: what about (forall quantifier. quantifier a. a)
16:41:48 <merijn> rwbarton: Not quite
16:42:00 <merijn> rwbarton: The order of evaluation of seq is unspecified
16:42:02 <dmwit> shachaf: =)
16:42:21 <merijn> rwbarton: So it could evaluate the second argument first and *then* evaluate the first
16:42:23 <rwbarton> I am talking about what actually happens
16:42:44 <rwbarton> merijn: if it did that then foldl' wouldn't actually run in constant space
16:42:59 <shachaf> GHC sometimes does evaluate y before x in (x `seq` y).
16:43:15 <rwbarton> shachaf: as a result of optimizations, right?
16:43:24 <shachaf> Of course, you said "without optimizations", and those are semantically the same.
16:43:25 <merijn> rwbarton: Sure, just pointing out that "seq is supposed to" is wrong and that it's more "In GHC seq does X"
16:43:36 <rwbarton> okay, well context and all that.
16:43:50 <merijn> rwbarton: Being tired makes me pedantic! :)
16:43:59 <merijn> Which means I should go sleep anyway
16:44:00 <rwbarton> Well, please don't.
16:49:30 <mmirman> so... save needed registers. force (lgo z (b:bs)). put z' thunk onto argument list. put (lgo z' bs) onto argument list. return seq thunk. and restore needed registers.  save needed registers. force seq thunk. save some registers. evaluate z' argument.  restore registers.  return (lgo z' bs) argument.  restore registers.  repeate?
16:52:37 <rwbarton> more or less
16:53:08 <rwbarton> it's more like to evaluate (lgo z (b:bs)), we put z' thunk onto argument list. put (lgo z' bs) onto argument list. jump to seq
16:53:56 <rwbarton> seq will push (lgo z' bs) and the continuation address then jump to its first argument
16:54:09 <rwbarton> the continuation will pop (lgo z' bs) and jump to it
16:54:09 <rwbarton> etc.
16:56:48 <rwbarton> in general, every boxed value is represented by a heap object whose first word is a pointer to code that will evaluate the value
16:59:24 * hackagebot HaTeX 3.11.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.11.0.0 (DanielDiaz)
16:59:34 <lennartj> hi, I have a lens question
16:59:40 <lennartj> if I have f :: Getter a b and g :: Getter b c, then f.g :: Getter a c
16:59:48 <lennartj> but what if instead of f, I have f' :: Getter a (Maybe b)? How would I compose f' and g to get something :: Getter a (Maybe c)?
17:00:40 <lennartj> I've a feeling the answer is very simple but I'm still wrapping my head around the magical type algebra
17:01:01 <shachaf> Are you sure you should be using Getters in the first place?
17:01:38 <monochrom> I should mention my lazy evaluation tutorial: http://www.vex.net/~trebla/haskell/lazy.xhtml
17:01:38 <lennartj> I don't think my objects are literally Getters, but I want to use them in one place to access values
17:02:25 <lennartj> the hope is that there's some compositional strategy that generalizes to Lenses, Isos, etc.
17:03:53 <rwbarton> well, your question can be rephrase as "if I have g :: Getter b c, how do I get g' :: Getter (Maybe b) (Maybe c)"
17:04:28 <shachaf> The trouble with a Lens is that if you have f' :: Lens' a (Maybe b) and g :: Lens' b c, it's not clear how the combined Lens' a (Maybe c) should behave.
17:04:41 <u-ou> @pl lotto gen len = randSelect gen len . range 1
17:04:41 <lambdabot> lotto = flip flip (range 1) . ((.) .) . randSelect
17:04:46 <u-ou> :/
17:05:03 <rwbarton> I imagine there is a Functor f => Getter b c -> Getter (f b) (f c) in lens somewhere, but it won't generalize to lenses etc.
17:05:18 <shachaf> It's more clear when you use a Traversal. But you should make sure you understand what the Traversal behavior is.
17:06:48 <lennartj> shachaf: ah, I see, so it shouldn't generalize to lenses
17:08:40 <lennartj> my situation arises because I'm trying to access a subfield of a data type that's the value of a map
17:09:23 <lennartj> so I'm naively trying to do something like m ^. at key . subfieldLens
17:11:00 <monochrom> w00t, haskell weekly news!
17:11:27 <roconnor> @type at
17:11:28 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
17:13:11 <roconnor> lennartj: you can us _Just to access the value inside a maybe, but then you will get a fold rather than a getter
17:13:25 <roconnor> lennartj: thus this should work for you:
17:13:39 <roconnor> m ^? at key . _Just . subfieldLens
17:13:53 <shachaf> There's a name for that.
17:13:59 <shachaf> ix k = at k . _Just
17:14:27 <felixn> Hey all, I have a high level question that I need some help reasoning about, hopefully to start a discussion
17:14:31 <lennartj> @type (^?)
17:14:32 <lambdabot> s -> Getting (First a) s a -> Maybe a
17:14:33 <benzrf> felixn: sup
17:14:34 <roconnor> lennartj: the ^? will try to get the first of 0 or more values.
17:14:36 <felixn> what is a "design pattern"?  When building software I think more about using concepts to solve problems, and obviously seeing patterns helps.  The word "pattern" makes me think s boilerplate, systematic ways of doing something in OOP constructs.  I think what concepts would help me solve a problem, not patterns.  Is a state machine a design pattern?  Is the state pattern the same as a state machine?  The "design pattern" verbiage on Wikipedia seems really murk
17:14:40 <lennartj> ahhh
17:14:47 <roconnor> lennartj: but will return Nothing if there are none.
17:15:00 <benzrf> felixn: it's not the best-defined concept
17:15:15 <lennartj> roconnor: that's perfectly fine for me
17:15:18 <benzrf> some people say that a 'design pattern' is really just evidence of a missing language features
17:15:34 <roconnor> m ^? ix key  . subfieldLens  -- according to shachaf's suggestion.
17:15:38 <felixn> benzrf: heh, it makes me really confused... like an leaky taxonomy of software concepts
17:15:42 <benzrf> but i am not certain that I fully agree
17:15:51 <shachaf> But note how you're using ^? rather than ^.
17:15:55 <benzrf> felixn: i think haskell probably has design patterns too, in some sense
17:16:17 <lennartj> shachaf, roconnor: right, and I'm trying to access the state of a (MonadState m)
17:16:27 <lennartj> but it looks like Control.Lens.Fold has functions for that already
17:16:31 <benzrf> i personally consider a design pattern to be any recurring structure across
17:16:34 <felixn> benzrf: I think really declaratively, like "what language can I speak in to best reason about this program?"
17:16:36 <benzrf> multiple programs
17:16:40 <benzrf> in some sense
17:16:48 <benzrf> to accomplish a similar purpose
17:16:53 <lennartj> I think I'm unstuck now, thanks so much for your help! :)
17:17:04 <benzrf> but i do not know practical haskell well enough to think of one off the top of my head
17:17:29 <roconnor> benzrf: haskell does have some patterns
17:17:37 <shachaf> :t preuse
17:17:38 <lambdabot> MonadState s m => Getting (First a) s a -> m (Maybe a)
17:17:38 <benzrf> roconnor: can you give examples?
17:17:39 <roconnor> benzrf: I think they are indicative of language failures.
17:17:58 <roconnor> benzrf: that said, I'm not sold on the design patterns are always failures idea entirely.
17:18:05 <benzrf> roconnor++
17:18:08 * roconnor tries to remember some examples.
17:18:29 <felixn> roconnor: benzrf: lol I like the idea that a "design pattern" is hints to missing language features, because it does sound like boilerplate, or a work around
17:18:39 <benzrf> felixn: work around is one way of looking at it
17:18:42 <felixn> when programming Java, it feels like a way to work around the type system
17:18:48 <benzrf> indeed
17:18:52 <benzrf> but java is a very lacking language :_
17:18:55 <benzrf> * :)
17:19:19 <benzrf> i know ruby is probably not well-loved around here but i enjoy it as a practical language since i am not quite fluent in haskell
17:19:21 <monochrom> I take this view: https://plus.google.com/102208456519922110915/posts/LXxRByiCMV4
17:19:28 <benzrf> and it has some design patterns
17:19:30 <felixn> while in python, the concept of "patterns" seems to disappear, because it gets closer to just talking about the idea naturally with a concept like state machine
17:19:40 <benzrf> felixn: i was about to say the same thing
17:19:41 <benzrf> sort of.
17:19:46 <felixn> :D
17:19:50 <benzrf> *about ruby
17:20:08 <benzrf> i'd say the concept doesnt disappear, but it becomes more nebulous and requires less code
17:20:29 <benzrf> it becomes more about aspects of program design and less about specific parts of code
17:20:40 <felixn> "name some design patterns" was an interview question I just had, and got nerd sniped...  it actually scares me off of working there, I imagine Java patterns inside JavaScript code
17:20:50 * benzrf shudders
17:21:01 <tac-tics> felixn: heh
17:21:38 <felixn> ok... so, I hearby hate the word pattern, and am replacing it with "concept"
17:21:44 <benzrf> hmmm
17:21:55 <benzrf> idk, pattern is fairly appropriate
17:22:07 <benzrf> how about this
17:22:09 <tac-tics> I don't think "design pattern" is, on its own, a poor choice of phrasing
17:22:26 <tac-tics> It's just that the famous gangoffour design patterns are kinda ridiculous
17:22:32 <felixn> yeah... well, part of simply "designing" is finding patterns
17:22:34 <tac-tics> and that's what the word has come to connotate.
17:22:38 <benzrf> a design pattern is a reusable style of solution to a specific problem.
17:22:49 <tac-tics> It's the hammer in your tool box
17:23:01 <monochrom> Q: Name some design patterns. A: x:xs, Just y, Left z, ~(a,b).
17:23:03 <tac-tics> Any time a problem looks like a nail, you rifle through the design patterns you know, whacking at it.
17:23:09 <felixn> is MVC a pattern or a concept?  wikipedia says architectual pattern, which is a whole another set of patterns
17:23:22 <benzrf> felixn: well, patterns tend to be concepts
17:23:28 <benzrf> there are varying levels of abstraction
17:23:34 <tac-tics> felixn: "I'll take 'splitting hairs' for 500 Alex"
17:23:40 <tac-tics> ;)
17:23:52 <benzrf> since java is a very lacking language, there are certain very common problems that the language does not equip you to solve
17:23:55 <felixn> heh, I like the word "toolbox" but that's not really defined well.. I also like using correct language to talk about things!
17:23:56 <benzrf> *very concrete
17:24:03 <benzrf> so the design patterns are very concrete
17:24:13 <benzrf> in better languages, the problem might be more abstract
17:24:30 <benzrf> such as, 'how can i separate my logic code from my display code cleanly'
17:24:37 <benzrf> and mvc is a more abstract form of solution
17:24:39 <monochrom> natural language is ambiguous. every wording will be both correct and incorrect.
17:26:47 <felixn> benzrf: yea "separate my logic code from display code cleanly" == abstract MVC to me, so many flavors of seperation in application frameworks
17:27:11 <felixn> so far the best being declarative data binding ^_^
17:27:36 <tac-tics> I prefer the general idea of MVC: "decompose your program in non-stupid ways"
17:28:00 <PhineasRex> A design pattern is just any programming concept that is not a language feature.
17:28:08 <PhineasRex> In Scala, there is a type class pattern.
17:28:11 <tertu> how would you declare a function that takes a list of strings and performs IO on them?
17:28:21 <tertu> would it just be functionName :: IO ()
17:28:23 <PhineasRex> Because you can define type classes but they are not an inherent language feature.
17:28:45 <felixn> PhineasRex: state machine is never a language feature, but I can build a library to talk about that concept succinctly... what does that mean!?
17:28:45 <Rarrikins> tertu: [String] -> IO a
17:28:57 <tac-tics> tertu: [String] -> IO [String]?
17:29:10 <benzrf> felixn: state machine is not a solution to a specific problem
17:29:14 <tertu> okay.
17:29:17 <benzrf> i think design patterns are usually specific solutions
17:29:34 <monochrom> why not [String] -> IO ()
17:29:34 <benzrf> using a state machine to accomplish parsing might be viewed as a design pattern
17:29:36 <benzrf> (maybe)
17:29:39 <tertu> it doesn't return anything (i don't know if this is acceptable in monadic code?)
17:29:47 <tertu> basically it's a "print a list of strings" function
17:30:00 <monochrom> then it is [String] -> IO () and it is acceptable
17:30:10 <benzrf> tertu: the return value is ()
17:30:15 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml
17:30:21 <benzrf> tertu: you should not need to say 'return' explicitly hopefully
17:30:22 <tac-tics> yeah, [String] -> IO ()
17:30:25 <tertu> AH okay
17:30:27 <benzrf> monochrom: xhtml, really?
17:30:32 <monochrom> yes
17:30:35 <tertu> the empty tuple?
17:30:48 <monochrom> yes
17:30:54 <felixn> benzrf: I've seen state machine like problems solved with coroutines, also with spagetti code... when thinking of the concept of state machine has solved the problem much cleaner... what does that mean?! >_<
17:31:08 <Rarrikins> tertu: Yep. It's nice for signifying no value.
17:31:14 <tac-tics> tertu: It takes getting used to, but EVERY function has a return type in Haskell. In this case, you can think of it (loosely) as an "IO action that returns a boring thing aka ()"
17:31:34 <PhineasRex> felixn: Well, I would regard a state machine as a design pattern.
17:31:49 <tertu> so basically it's returning something but at the end of the day nobody even cares what it is and it never gets bound to anything
17:31:51 <tac-tics> (Really, what you return is the IO action itself)
17:32:01 <tac-tics> yep
17:32:23 <tac-tics> () is really "the type that doesn't contain any useful data"
17:32:33 <PhineasRex> But I guess that does make my definition a bit overbroad.
17:32:43 <PhineasRex> And thus not useful....
17:33:25 <benzrf> monochrom: this is pretty good
17:33:26 <tertu> so here's another question
17:33:34 <tac-tics> Fun fact: () is like a 0-tuple. You might have (Int, Int, Int) for triples of integers. (Int, Int) for pairs. Int for just one integer, and () for 0 integers :D
17:33:36 <tertu> what should putStrList _ be
17:33:39 <felixn> Thinking in terms of "concepts" and "toolkit/toolbelt" makes things easier to think about for me, everything else kind of confuses me
17:33:42 <tertu> () or IO ()?
17:33:45 <mizu_no_oto> Are there any graphics frameworks that currently work on7.8?  I can't get gtk2hs-buildtools compiling due to the changes to Int# comparison.
17:33:52 <tac-tics> tertu: IO ()
17:33:56 <tertu> okay
17:34:07 <tac-tics> A function Blah -> () would be entirely useless.
17:34:21 <tac-tics> There's only one value of (), (modulo pedantry).
17:34:27 <tac-tics> There are many many many values for IO ()
17:34:44 <tac-tics> including print "Hello World" and launchMissiles
17:34:51 <benzrf> tertu: you should read monochrom's link
17:34:54 <monochrom> putStrList xs = mapM_ putStrLn xs
17:35:04 <jmcarthur> i don't even know what a value of IO () is
17:35:14 <benzrf> tac-tics: no, launchMissiles :: IO PicturesOfDead
17:35:16 <benzrf> as a deterrent
17:35:18 <tac-tics> @type print "Hello"
17:35:19 <lambdabot> IO ()
17:35:24 <tac-tics> ^ an example
17:35:29 <benzrf> tertu: you should read monochrom's link
17:35:33 <monochrom> unless you want to practice writing the recursion yourself, then it is: putStrList [] = return (); putStrList (x:xs) = putStrLn x >>= putStrList xs
17:35:35 <jmcarthur> no, i mean i don't know what it means
17:35:48 <felixn> anyways.... I like the concept of Monads... big ups. but one more question, are monads a design pattern?  how about if I build it with classes in Java? ^_^  class MonadFactory {}
17:35:52 <jmcarthur> i should explain that better instead of sounding newbish
17:35:57 <tac-tics> It's hard to explain what it is because it's so heavily tied to the compiler.
17:35:58 <jmcarthur> i mean i don't know what IO's denotation is
17:36:08 <tac-tics> IO is very magical in Haskell
17:36:09 <monochrom> err typo. putStrList (x:xs) = putStrLn x >> putStrList xs
17:36:12 <jmcarthur> yes
17:37:04 <tac-tics> You might think of it as an 'open type'. You can basically will terms of it into existence with the FFI
17:37:09 <felixn> tac-tics: I had a weird though, what if IO was defined more like the StateT type.  That way you intercept and modify them as they flow through your program
17:37:09 <jmcarthur> i was really just jumping on that word "value", aka "meaning"
17:37:14 <felixn> thought*
17:37:22 <tac-tics> Kind of like how data Foo = Foo just "materializes" Foo :: * from the aether.
17:37:32 <tac-tics> So does an FFI declaration bring an IO Foo into existence
17:37:47 <jmcarthur> tac-tics: would would the state be? what would it mean to hold on to an old version of the state while you continue with new versions and then start using the old one again?
17:37:55 <jmcarthur> sorry, not tac-tics
17:37:57 <jmcarthur> felixn: ^^
17:37:59 <tac-tics> felixn: IO is a little fancier than a simple state monad due to non-determinism.
17:38:16 <tac-tics> But it works sorta the same. Maybe ST would be a closer relative
17:38:43 <jmcarthur> the semantics of ST is much easier to explain
17:38:53 <felixn> jmcarthur: tac-tics: FileIO { fileToChange :: String, newData :: String, operation :: FileOperation }
17:38:58 <monochrom> I have decided that "IO X" means: it's an I/O action, and it passes an X to the callback. "callback" is as in "action >>= callback". I no longer want to talk about "return".
17:39:03 <felixn> super pseudo but I hope you get the idea
17:39:32 <tac-tics> felixn: There's a paper I read (the actual topic was coinduction in dependently typed languages), but it explained very nicely how IO works under the hood
17:39:37 <tac-tics> or at least, some fanciful way of looking at it.
17:39:44 <monochrom> I have written that in my I/O tutorial. everyone should read it and adopt it.
17:39:45 <benzrf> felixn: actually, IO *does* work as a State thing
17:39:49 <benzrf> monochrom++
17:39:58 <tac-tics> linky, monochrom
17:40:06 <felixn> I feel like I have a good idea how IO works, but I think it expose more to the programmer
17:40:10 <benzrf> @let import qualified GHC.Base
17:40:11 <lambdabot>  .L.hs:110:1:
17:40:11 <lambdabot>      GHC.Base: Can't be safely imported! The module itself isn't safe.
17:40:12 <felixn> think it could *
17:40:14 <benzrf> :o
17:40:17 <monochrom> scroll up, it is still in your scroll buffer
17:40:29 <benzrf> felixn: try in ghci
17:40:32 <djahandarie> How do you know how long my scroll buffer is?
17:40:32 <jmcarthur> data IO a = forall b. IO ((a -> IO b) -> IO b), duh
17:40:36 <benzrf> felixn: 'import GHCI.Base'
17:40:40 <tac-tics> benzrf: Such lambdabot exploits!
17:40:43 <jmcarthur> woops
17:40:47 <jmcarthur> forall in wrong place
17:40:49 <benzrf> oops
17:40:55 <benzrf> felixn: first import GHC.Base
17:41:01 <monochrom> you have like 16GB of RAM. don't kid me, you can surely spare 0.1% of that for your scroll buffer.
17:41:04 <jmcarthur> data IO a = IO (forall b. (a -> IO b) -> IO b)  -- what i meant
17:41:08 <benzrf> felixn: then 'let (IO wtf) = putStrLn "hi"'
17:41:15 <benzrf> felixn: check out the type of wt
17:41:16 <benzrf> *wtf
17:41:17 <benzrf> :)
17:41:35 <benzrf> of course this is a GHC implementation detail
17:41:39 <benzrf> i do not think it is in the standard
17:41:41 <felixn> benzrf: Nice!!!! so I can intercept and modify IO monadic values?  nice
17:42:10 <jmcarthur> felixn: this is not exactly a sane thing to do, of course
17:42:22 <felixn> jmcarthur: maybe I'm insane
17:42:39 <felixn> I really like metaprogramming, but I also like type safety
17:43:00 <felixn> taping into computation pipeline sounds awesome to me
17:43:13 <benzrf> oh huh philip wadler wrote monads for fp
17:43:14 <jmcarthur> you know, i kind of like my latest definition of IO. i'm going to just pretend that's it from now on
17:43:32 * felixn scrolls up
17:43:45 <jmcarthur> it's basically the lamest free monad ever
17:43:52 <benzrf> jmcarthur: :O
17:44:00 <felixn> jmcarthur: what was the definition?
17:44:06 <benzrf> jmcarthur: but with fancy black-box functionality!
17:44:07 <jmcarthur> data IO a = IO (forall b. (a -> IO b) -> IO b)
17:44:19 * felixn needs to learn forall still >_<
17:44:41 <jmcarthur> felixn:    IO io >>= f = io f
17:44:43 <benzrf> is forall needed there?
17:44:43 <monochrom> strangely, that is like reversing the type of >>=
17:44:48 <tac-tics> oh, that's a good one to know, felixn
17:44:52 <jmcarthur> benzrf: yes, so that bind can work with any f
17:44:59 <benzrf> hm
17:45:02 <tac-tics> felixn: You know how type variables work right? like
17:45:04 <tac-tics> @type fmap
17:45:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:45:24 <tac-tics> That's the same as forall a b f. Functor f => (a -> b) -> f a -> f b
17:45:43 <tac-tics> It's just that a b and f are "implicit" paramters that Haskell figures out for you automatically
17:46:15 <tac-tics> similarly, Functor f is an "implicit" parameter that passes the appropriate Functor instance for you
17:47:11 <felixn> tac-tics: jmcarthur: fine I'll learn it right now... let me reread & research real quick
17:47:21 <tac-tics> ;P
17:48:04 <felixn> <3 hoogle
17:48:28 <PhineasRex> So, I have to give a presentation on Haskell to a bunch of Scala devs.
17:48:29 <benzrf> hoogle tho
17:48:43 <benzrf> :t GHC.Base.IO
17:48:44 <lambdabot> (GHC.Prim.State# RealWorld -> (# GHC.Prim.State# RealWorld, a #)) -> IO a
17:48:49 <benzrf> check it
17:49:08 <jmcarthur> > let f :: (Num a => a -> a) -> Int -> Float -> (Int, Float); f unop x y = (unop x, unop y) in f abs 5 6   -- felixn: this fails
17:49:09 <benzrf> @src RealWorld
17:49:09 <lambdabot> Source not found. Wrong!  You cheating scum!
17:49:10 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô with actual type ‚Äòa‚Äô
17:49:10 <lambdabot>    ‚Äòa‚Äô is a rigid type variable bound by
17:49:10 <lambdabot>        the type signature for
17:49:10 <lambdabot>          f :: (GHC.Num.Num a => a -> a)
17:49:11 <lambdabot>               -> GHC.Types.Int
17:49:13 <jmcarthur> > let f :: (forall a. Num a => a -> a) -> Int -> Float -> (Int, Float); f unop x y = (unop x, unop y) in f abs 5 6   -- felixn: this fails
17:49:14 <lambdabot>  (5,6.0)
17:49:22 <jmcarthur> umm, obviously i meant that the latter doesn't fail
17:49:58 <jmcarthur> felixn: the first one fails because it would have to unify a to both Int and Float
17:50:13 <jmcarthur> felixn: the second one works because the forall says the function has to be totally polymorphic in a
17:53:15 <monochrom> suggestion for the presentation: A. play that few minutes of "we're doing it all wrong" that talks about compareTo returning int being wrong. B. show that Haskell does it right: "compare" returns the 3 values LT, EQ, GT.
17:54:11 <tac-tics> Psh. Partial orders are the more natural class ;P
17:54:15 <PhineasRex> I'm not familiar with "we're doing it all wrong"
17:55:37 <PhineasRex> Hmm, I might actually mention that.
17:56:30 <felixn> jmcarthur: ahhh so it lets me take a type class function that can change instances?
17:56:30 <benzrf> @ping
17:56:30 <lambdabot> pong
17:56:44 <monochrom> it's at https://www.youtube.com/watch?v=TS1lpKBMkgg
17:57:43 <PhineasRex> @monochrom Do you happen to know at what point it occurs?
17:57:43 <lambdabot> Unknown command, try @list
17:57:54 <monochrom> I forgot
17:58:24 <PhineasRex> I'm actually writing a section on elevating things into the type level and static guarantees in general.
17:58:24 * monochrom tries binary search
18:02:24 <monochrom> PhineasRex: 8:43
18:05:24 <felixn> tac-tics: forall allows me to "take a type class function that can change instances" ?  I think I got it
18:05:36 <PhineasRex> monochrom: Thanks.
18:05:56 <PhineasRex> Also thanks because I had not seen this talk.
18:05:57 <SrPx> silly thing I realised about haskell: whenever you want to change the name of a variable across a file, usually s/ foo/ bar/g (with the space) will do it amazingly frictionless
18:06:24 <tac-tics> felixn: forall just makes explicit where your type variables are coming from.
18:06:31 <hpc> don't forget to terminate with =b
18:06:33 <hpc> \b
18:06:41 <davidthomas> SrPx: \< in place of the space might be better
18:07:09 <SrPx> davidthomas: what is <
18:07:20 <davidthomas> \< is start of word
18:07:30 <SrPx> amazing, TIL
18:08:40 <tac-tics> felixn: so to use "pseudo haskell" notation: we have id :: forall a. a -> a
18:08:51 <tac-tics> so id [Int] :: Int -> Int
18:09:02 <tac-tics> Where [Int] is a type I can pass to id.
18:09:10 <tac-tics> When I pass it, it fills in the a's with Int
18:09:32 <felixn> tac-tics: doesn't haskell do that without forall?
18:09:41 <SrPx> tac-tics: I never understood why the syntax is so different on the type level and on the value level. Why not "forall a a = a" ? "
18:10:05 <SrPx> tac-tics: hey are you tactics on reddit?
18:10:24 <tac-tics> felixn: it does. This is just being explicit. (It's also how Haskell's Core works)
18:10:29 <tac-tics> SrPx: I am, in fact.
18:10:35 <SrPx> tac-tics: =(
18:10:37 <benzrf> im benzrf on reddit
18:10:39 <tac-tics> I hope I haven't offended you. I'm rude on Reddit :X
18:11:18 <tac-tics> SrPx: The syntax is very inconsistent in Haskell. I find it frustrating too :X
18:11:23 <felixn> tac-tics: what would a -> a mean without being explicit?  "type a to type a?"  except type a wouldn't be defined?
18:11:51 <hpc> felixn: it'd fail from a being out of scope
18:11:59 <tac-tics> felixn: yep
18:13:00 <felixn> oh god it makes sense now.... thanks :)  I could see interpreting being hard sometimes forall Int. Int -> Int... would that work? ;)
18:15:14 <catmtking> hmm, i'm going through the exercises in sicp ... and there's i'm wondering about the type for this...
18:15:50 <catmtking> p = p ; test x y = if x == 0 then 0 else y ; test 0 p
18:16:00 <catmtking> what's the type for test?
18:16:11 <monochrom> what is ";" there?
18:16:15 <mgsloan> Here's a decent looking sketch of unifying haskell's top level syntax a bit: https://github.com/colah/Haskell-Re-Syntaxed/blob/master/brainstorm.hs
18:16:16 <catmtking> newline
18:16:31 <mgsloan> There are a lot of issues with it, like the type family business being more like closed type families
18:16:35 <catmtking> since i didn't want to type it out into many lines
18:16:37 <prophile> catmtking: (Num n, Eq n) => n -> n -> n
18:16:49 <prophile> presumably
18:17:02 <mgsloan> And also the fact that "Just blah = ..." and such are valid top level declarations
18:17:21 <prophile> oh, possibly (Num n, Num m, Eq n) => n -> m -> m
18:18:18 <catmtking> hmm, why would m be numeric, though?
18:18:34 <catmtking> oh, because it can return 0
18:18:36 <monochrom> because 0 and y must have the same type
18:19:23 <tac-tics> felixn: forall Int. Int -> Int wouldn't make sense, because Int is already defined
18:19:29 <tac-tics> It would be like shadowing a variable
18:22:46 <Hafydd> It wouldn't make sense, in particular, because Int is syntactically not a type variable.
18:24:14 <tac-tics> Hafydd: I think we're talking spiritually anyway
18:24:23 <tac-tics> Morally, a variable's a variable's a variable.
18:24:56 <Hafydd> It does "make sense" to shadow a variable within a universal quantifier, but it's just weird.
18:24:57 <triliyn> mgsloan: "Just blah" in a top-level LHS could be distinguished from type family declarations by the type. That would be kind of icky though...
18:26:36 <mgsloan> triliyn: Right.  It's also icky because it makes it look like type families fallthrough semantics.  Interestingly, the closed type family syntax is actually rather close to this
18:31:32 <jmcarthur> felixn: it doesn't really have anything to do with type classes, and forall Int doesn't really make any sense.  think of forall as a kind of type level lambda. it's usually only there implicitly.
18:32:50 <jmcarthur> felixn: an argument of type (forall a. a -> a) is very restricted. some minor pedantic quibbles aside, it can only be id.
18:33:03 <Algebr> Feeling stupid but not understanding how the following even runs, say that your entire program consists of z = z + 1. Running it in ghci just hangs. Why does it even run?
18:33:20 <jmcarthur> felixn: however, an argument of type (a -> a) could possibly be other things. it depends on context.
18:33:42 <jmcarthur> felixn: the forall a in the former says that a *can't* be from surrounding context. the function has to work for *any* a, no matter what it is
18:34:01 <jmcarthur> Algebr: that is a recursive definition
18:34:09 <Iceland_jack>     z
18:34:09 <Iceland_jack>     = z + 1
18:34:09 <Iceland_jack>     = z + 1 + 1
18:34:09 <Iceland_jack>     = z + 1 + 1 + 1 ...
18:34:21 <jmcarthur> Algebr: it expands like this:    z => z + 1 => (z + 1) + 1 => ((z + 1) + 1) + 1
18:34:23 <jmcarthur> etc.
18:34:28 <Algebr> jmcarthur: but there's no base case
18:34:36 <jmcarthur> Algebr: right. that's why it goes forever :P
18:34:57 <Algebr> doh.
18:35:03 <Iceland_jack> It will not hang if you're using something like lazy naturals
18:35:14 <jmcarthur> Iceland_jack: depends on the definition of (+) for that type
18:35:24 <Iceland_jack> Yes that's right
18:35:29 <Algebr> but since there's no base case, why didn' it exhaust the stack?
18:35:33 <jmcarthur> Iceland_jack: i think typical definitions would require the 1 to be on the left in order for that to work
18:35:40 <benzrf> Algebr: ghc does not use a typical stack
18:35:46 <jmcarthur> Algebr: what version of ghc are you using?
18:35:49 <Algebr> 7.6
18:36:08 <jmcarthur> with 7.6 i would expect an eventual stack overflow, i think, with default runtime settings
18:36:20 <jmcarthur> in 7.8 the stack can grow until you run out of memory, by default
18:36:24 <Iceland_jack> ‚ÄúSomething like lazy naturals with appropriately defined addition‚Äù sounds a bit verbose
18:37:51 <jmcarthur> Algebr: i take it back. i expect ghc to fail with an exception, actually. it has some basic infinite loop detection which i think should kick in here
18:38:01 <jmcarthur> *ghci
18:38:26 <Algebr> jmcarthur: so if I walk away and come back, ghci will eventually throw an exception?
18:38:34 <jmcarthur> Algebr: it should actually happen pretty quickly
18:39:09 <jmcarthur> i'm actually surprised it takes as long as it does, with 7.8... but it does happen after a few seconds
18:39:16 <jmcarthur> Algebr: try this in ghci:   let z = z + 1 in z
18:39:18 <Iceland_jack> ghci> let x = x + 1
18:39:18 <Iceland_jack> ghci> x
18:39:18 <Iceland_jack> *** Exception: <<loop>>
18:39:23 <napping> ghci seems to notice that sort of thing less often than in compiled code
18:39:31 <jmcarthur> ah, maybe it's a ghci thing indeed
18:39:36 <ragnar_> I have a really stupid question, trying to concat "\0a\00" to the back of a string but the output always ends up being \NULa\NUL
18:39:41 <napping> Maybe it's just time, I guess
18:39:53 <jmcarthur> > '\0' == '\00'
18:39:54 <napping> loop certainly shows up faster in compiled code
18:39:54 <lambdabot>  True
18:39:58 <jmcarthur> ragnar_: ^^
18:40:09 <Iceland_jack> > '\NUL' == '\0'
18:40:10 <lambdabot>  True
18:40:31 <Iceland_jack> ragnar_: That's just how the Char '\0' is shown
18:40:46 <Iceland_jack> > show '\0'
18:40:46 <jmcarthur> > ("\0!", "\00!", "\000!", "\0000!", "\00000!")
18:40:47 <lambdabot>  "'\\NUL'"
18:40:48 <lambdabot>  ("\NUL!","\NUL!","\NUL!","\NUL!","\NUL!")
18:40:57 <ragnar_> im writing it to a file, i need a \0a in the file
18:41:14 <jmcarthur> ragnar_: you mean you want the backslash to appear?
18:41:20 <Iceland_jack> Are you sure you need \0a in the file and not the actual binary value
18:41:20 <jmcarthur> > "\\0a"
18:41:21 <lambdabot>  "\\0a"
18:41:45 <jmcarthur> > text "\\0a"  -- is that what i mean?
18:41:46 <lambdabot>  \0a
18:41:48 <jmcarthur> yes that
18:42:03 <jmcarthur> (text just "prints" it without quoting it)
18:42:32 <ragnar_> if I escape it I just get two of them, maybe I just need sleep xD
18:42:52 <jmcarthur> ragnar_: you will only see two of them if you are using Show on the String, since that will show it quoted
18:42:59 <jmcarthur> ragnar_: try using putStrLn or something instead of print
18:43:00 <monochrom> you may use putStrLn "\0"
18:43:35 <rwbarton> you want the two characters with values 10, 0?
18:43:44 <monochrom> Show instance of String and Char intentionally escape things because they think programmers want to see escape codes
18:44:30 <monochrom> apparently, they guessed wrong. programmers expect WYSIWYG as much as the next guy
18:45:04 <dwcook> WYSIWYG is pretty hard for unprintable characters
18:45:59 <ragnar_> thanks guys, sometimes the simplest things are the most time consuming xD
18:46:20 <jmcarthur> an anecdote: coworker was reviewing a code diff that included a new print_red function which included ansi color codes. it was something like  let print_red str = printf "<the color code stuff>%s</end the color code stuff>" str   (i forget what the actual color codes are, but they are not exactly printable anyway).  anyway, in the diff, it just looked like   let print_red str = printf "%s" str  where the %s
18:46:21 <tac-tics> Because they are powered by our intuition and not the thinky-lobe of the brain
18:46:22 <jmcarthur> was actually red
18:46:36 <benzrf> jmcarthur: hah
18:46:38 <tac-tics> My favorite example: ask someone what a 'number' is.
18:46:49 <benzrf> tac-tics: a representation of quantity
18:47:05 <benzrf> the cardinality of a set
18:47:16 <benzrf> the result of iterating the successorship function on the value 0
18:47:23 <benzrf> *for naturals
18:47:49 <tac-tics> The first one is rather loose. The other two are cardinals and naturals respectively, which are distinct and don't capture 'continuous' quantities :)
18:48:04 <benzrf> aw.
18:48:18 <jmcarthur> i just love that the ASCII codes for digits aren't just the numbers they represent.
18:48:37 <tac-tics> jmcarthur: What? You don't like nullterminated strings?
18:48:47 <jmcarthur> i don't, actually
18:49:21 <tac-tics> The point I am secretly making is that Num is a terrible type class.
18:49:30 <tac-tics> Because a number isn't a well-defined thing, despite popular opinion ;P
18:49:45 <jmcarthur> i know why we have them, but if i was to start C over i would have gone with something more like  struct { int length; char * buffer }
18:49:45 <machineslearn> @poll-result best-programming-language
18:49:45 <lambdabot> Poll results for best-programming-language (Open): SNOBOL=1, COBOL=2, PHP=1, Coq=0, Agda=0, anything-else=0, Haskell=0
18:50:02 <benzrf> o_O
18:50:06 <hyPiRion> hahah
18:50:07 <benzrf> @poll
18:50:08 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show roll
18:50:11 <monochrom> I am also favourite of the "what is number" question, but in the context of demanding "plain English" answers for "what is monad" kind of questions
18:50:20 <benzrf> mmmmmm
18:50:33 <jmcarthur> tac-tics: but some numbers are more real than others
18:50:39 <ReinH> tac-tics: Num isn't about numbers, silly. It's about things that have (+), (*), abs, signum, fromInteger, and negate.
18:50:45 <benzrf> a monad is a nested wrapper that can be collapsed into a single wrapper
18:50:45 <ReinH> tac-tics: some of them just happen to be numbers :p
18:50:47 <jmcarthur> tac-tics: so clearly R are the *real* numbers
18:50:56 <jmcarthur> the others are just imposters
18:51:13 <monochrom> Q: explain numbers to me like I'm a five-year old. A: OMG how did you know about "five"? :)
18:51:15 <tac-tics> Imagine you have reason to believe monoids are cool and that functors are cool, and that endofunctors on a single category are neat-o, and that you want to try and jam the one into the other....
18:51:45 <jmcarthur> omg monad tutorial one-liner
18:51:48 <tac-tics> Anyone with a soul knows that C are the realest numbers of all ;O
18:51:53 <ReinH> imagine you're operating in a universe where all monads are applicative. :p
18:52:06 <jmcarthur> tac-tics: nah, C is just the real numbers and a bunch of imaginary stuff tacked on
18:52:18 <monochrom> if I jam two things neat-o, will I get jell-o?
18:52:32 <Algebr> ReinH: You do those Haskell Cast shows, right?
18:52:35 <jmcarthur> ReinH: one year!
18:52:37 <ReinH> agjacome: yessir
18:52:39 <tac-tics> Only if it satisfies the jellad laws.
18:52:46 <monochrom> wait, isn't C a programming language?
18:52:51 <ReinH> tac-tics: I believe Mac Lane calls it a jelloid.
18:53:04 <tac-tics> C is the algebraic completion of the imperative languages.
18:53:09 <monochrom> hahaha
18:53:18 <Adeon> cojelly
18:53:22 <Adeon> it's like jelly but turned inside out
18:54:01 <ReinH> no, it's like a jelly with all the arrows turned around
18:54:48 <joelteon> one thing is for sure: lens depends on it
18:55:53 <jmcarthur> joelteon: actually edwardk managed to extract that into a separate jellens package
18:56:25 <jmcarthur> joelteon: ... but lens depends on that
18:58:24 <monochrom> I had no idea my "jello" joke turned up so many real things
18:58:47 <Clint> roconnor: can you tweak data-lens to be compatible with comonad 4.2?
19:09:44 <ReinH> monochrom: ?
19:10:20 <monochrom> it led to "jellad", "jelloid", "jellens", all of which seem to be real things
19:10:27 <ReinH> wait what
19:10:34 <ReinH> math you crazy
19:11:07 <monochrom> I no longer know what are jokes and what is reality!
19:11:09 <ReinH> oh not actually math phew
19:16:09 <felixn> has anyone seen availlang.org?  I was wondering what haskell would look like if all functions were polymorphic... this language seems fullfil fulfil
19:16:22 <felixn> blah, fufil that idea*
19:16:33 <tac-tics> all functions polymorphic? o_o
19:16:47 <felixn> tac-tics: I know, it's weird man, but think of it as a lispy haskell
19:16:55 <tac-tics> lisp? o_o
19:17:04 <tac-tics> Lisp is a 4-letter word ;P
19:17:13 <monochrom> lisp does not satisfy "all functions are polymorphic"
19:17:44 <tac-tics> it sounds like maybe you're using a different definition than we use for the word, felixn.
19:17:46 <felixn> monochrom: in the sense that I can macro/change the meaning of what I stated
19:18:46 <felixn> tac-tics: what if you could give multiple definitions to function "foo", of any type
19:18:58 <tb01110100> Is there any particular reason a binary for a one-line program (main = putStrLn "Hello, World") is over 1MB in size?
19:18:58 <felixn> and at compilation it will find the definition that fits
19:19:02 <monochrom> then it is postmordernism and it implies that program behaviour is never predictable.
19:19:07 <tac-tics> ah, yes
19:19:16 <tac-tics> That's more of a namespacing thing, I think
19:19:26 <tac-tics> Is that "Multiple dispatch"?
19:19:37 <felixn> tac-tics: wait, are you talking to me? >_<
19:20:08 <tac-tics> ---> "what if you could give multiple definitions to function "foo", of any type"
19:20:12 <ReinH> tac-tics: Sounds like (ad hoc) polymorphism to me?
19:20:13 <tac-tics> That sounds like multiple dispatch, I think
19:20:19 * monochrom walks away from arguing over "reasonable" executable sizes
19:20:23 <felixn> tac-tics: ok, yea, I may be thinking like that...  I've thought about it a little bit, and yes there would have to be runtime lookups which is a downside
19:20:30 <tac-tics> ReinH: that word also sounds right I think?
19:20:40 <ReinH> tac-tics: versus parametric polymorphism
19:20:40 <tac-tics> felixn: Idris actually supports that.
19:20:50 <tac-tics> well, "runtime" and "types" don't go together ;)
19:21:02 <tac-tics> the point of typing a program is to know something before you ever run it.
19:21:08 <ReinH> tac-tics: multiple dispatch is something a bit different I think
19:21:24 <tb01110100> monochrom: I'm just wondering, why is a simple program to do a simple thing so large?
19:21:25 <ReinH> it's dispatch based on the (dynamic) type of more than one of its argument
19:21:27 <felixn> tac-tics: but basically, you could define "foo a b = a * b" then I can change the meaning of "*" so that I can maybe I can take a derivative of "foo", which makes it feel lisp-like to me
19:21:54 <tac-tics> yes
19:21:58 <tac-tics> That is somethign lisp would do
19:22:07 <tac-tics> And that kind of thing doesn't work so well with types :(
19:22:11 <felixn> also sorry about my grammar, dang terminals
19:22:17 <tac-tics> That's why Typeclasses were invented.
19:22:50 <felixn> tac-tics: I think it would be possible to do safely though!
19:23:12 <felixn> tac-tics: take a look at availlang.org, it sort of does something similar
19:23:28 <ReinH> tac-tics: And indeed they were introduced in a paper called "How to make ad hoc polymorphism less ad hoc"
19:23:44 <benzrf> > let add3 a b c = a + b + c in (join (join add3)) 2
19:23:45 <lambdabot>  6
19:23:48 <benzrf> neat
19:23:52 <roconnor> Clint: as in change the upperbounds ont he dependencies?
19:24:29 <Clint> roconnor: right
19:24:41 <roconnor> Clint: yes.
19:24:45 <pavonia> tb01110100: I think one reason is that GHC binaries include a runtime system handling the garbage collection and such
19:24:49 <felixn> tac-tics: what idris feature were you referencing?  would it be easy to point me to it?
19:25:03 <Clint> roconnor: thanks
19:25:06 <tac-tics> oh, I don't think it has a name
19:25:24 <felixn> ReinH: the problem I saw with this type of "polymorphism" I think would be everything may have to be global, like in haskell, which could get hairy
19:25:39 <monochrom> pavonia: the problem with that kind of answers is that it can be refuted by "but the compiler should be smart enough to omit parts of the rts on a case by case basis"
19:26:17 <pavonia> monochrom: What kind of answers should be given then?
19:26:52 <monochrom> fast-forwarding, my ultimate answer would be economic: if you pay someone enough money, they can minimize executable sizes. as it is, ghc's price tag is $0.
19:27:47 <tb01110100> I can get the file size down to 8.9K if I compile with -dynamic and strip it, but what exactly does -dynamic do? In haskell noob terms, please.
19:28:26 <monochrom> do you know of *.so files or *.dll files?
19:30:20 <tb01110100> nada
19:30:25 <who1sth9t> is there anyway to trace an ip if its connected to AWS?
19:30:32 <monochrom> then I have no answer
19:30:36 <tb01110100> hmm
19:30:40 * tb01110100 does some more googling
19:32:46 <who1sth9t> There seems to be a big company that may have created a stooge hate site that they are passing around in order to log IP addresses that access it then fire the offenders. It looks like they are using AWS and I'm just trying to find a way to prove thats whats happening
19:33:10 <roconnor> Clint: how is it that people are using the new transfomers library?  it is like part of the platform.
19:33:31 <monochrom> people always delusionally chase after new versions
19:35:22 <roconnor> doesn't ghc depend on transformers?
19:35:33 <monochrom> not until 7.8
19:35:42 <roconnor> really?
19:35:47 <monochrom> yes
19:36:03 <roconnor> wow, I find that kinda upsetting.  How can GHC be written and not use transformers? :D
19:36:36 <monochrom> they now rectify it in 7.8. it comes with and uses mtl and transformers
19:37:19 <monochrom> on the downside, it means that a naive user eager to "oh there is a new mtl coming out" will be hosed.
19:37:50 <roconnor> on the flip side, I don't quite understand why I need always use the same version of packages that ghc was compiled with.
19:37:52 <monochrom> THIS IS A PROBLEM NO AMOUNT OF SANBOXING WILL SOLVE
19:38:23 <tac-tics> I would argue sandboxing doesn't solve a problem. It just localizes it.
19:38:28 <monochrom> actually, if you don't use the GHC API, you don't have to use the mtl that comes with GHC
19:39:00 <roconnor> at least that is good news
19:39:10 <monochrom> on the downside, if you use hint or ghc-mod, you use the GHC API
19:39:11 <roconnor> so basically it is just people using template haskell?
19:39:21 <roconnor> what is hint or ghc-mod?
19:39:24 <monochrom> oh, that too
19:39:50 <monochrom> hint is a nice way to use GHC API. ghc-mod is an emacs plugin that uses GHC API
19:40:24 <monochrom> hint is a library
19:41:19 <monochrom> oops, GHC API just uses transformers, not mtl
19:47:16 <ReinH> monochrom: ghc-mod is also a Haskell library that uses GHC API
19:47:23 <ReinH> which is important since I use it from vim
19:47:35 <bacon1989> was wondering, how good is ghcjs?
19:47:46 <bacon1989> is most of the haskell libraries supported?
19:49:53 <jmcarthur> bacon1989: it supports a surprising amount of ghc features and works with most things written in pure haskell.
19:50:08 <guesting> I am having trouble with Data.Text and the take function, which seems to be storing an incredibly large amount of memory. Is this due to strictness?
19:50:22 <jmcarthur> bacon1989: compatibility is one of ghcjs's main goals
19:50:37 <ReinH> guesting: can you show us some code using lpaste?
19:50:40 <guesting> Data.Text seems to be a memory hog
19:50:47 <bacon1989> jmcarthur: sweet, i'm going to look more into it
19:51:53 <gamegoblin> Is there an IO partition function that works with (a -> IO Bool) rather than (a -> Bool) ?
19:52:10 <Rarrikins> gamegoblin: What would it do?
19:52:23 <guesting> ReinH: http://pastebin.com/CwQdszW0
19:52:27 <guesting> It's being called a LOT
19:52:44 <gamegoblin> Rarrikins. I have an IO [a] and an (a -> IO Bool). I want to partition based on the predicate. The same way I‚Äôd do it with an [a] and a (a -> Bool) and the Data.List partition function.
19:53:16 <guesting> on like hundreds of thousands of text of around 200 characters each
19:53:44 <guesting> basically it removes certain characters and then takes a portion of the text
19:54:10 <guesting> I'm assuming the strictness is causing the issue as I don't think I had this problem when it was with strings
19:56:24 <ReinH> gamegoblin: nothing I'm aware of. Look at the source of partition and see if you can rewrite it to do what you want. It's relatively straight-forward.
19:56:40 <guesting> wait...Data.Text.Lazy's take function uses Int64 as opposed to Int...why? What would that impact?
19:56:57 <gamegoblin> ReinH: Yeah it‚Äôs not a huge problem just to sequence to the [IO Bool] and filter based on that, but I was wondering if there was something built in
19:59:31 <ReinH> gamegoblin: heh I should use Hayoo more http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%22partitionM%22
19:59:38 <roconnor> @type filterM
19:59:39 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
19:59:48 <roconnor> @type partitionM
19:59:49 <lambdabot>     Not in scope: ‚ÄòpartitionM‚Äô
19:59:49 <lambdabot>     Perhaps you meant one of these:
19:59:49 <lambdabot>       ‚Äòpartition‚Äô (imported from Data.List),
19:59:55 <roconnor> :/
20:06:02 <felixn> lambdabot: i bet idris-bot's dad can beat up your dad
20:06:11 <felixn> he has colors
20:07:50 <tac-tics> and if you have a type error... he has quite a mouth
20:10:54 <roconnor> maybe I need to install hydra to compile data-lens in all sorts of different ways.
20:16:49 <guesting> Holy moly. Converting to lazy text made it like 1000 times faster and went from > 70 gb memory usage to < 1 gb. Yeah, I think the strictness was the issue.
20:18:36 <dmwit> guesting: Well, Int has a pretty small range as these things go. Not guaranteed to faithfully represent numbers >2^29.
20:18:54 <dmwit> So that's like... a gigabyte of text?
20:19:02 <dmwit> Seems reasonable to support more than a gigabyte out of the box.
20:19:09 <guesting> well
20:19:15 <guesting> more than thousands then
20:19:28 <guesting> enough that it was taking up more than 70 gigs on the server
20:19:33 <guesting> which is obviously an issue
20:21:46 <roconnor> ocharles: adding src as a parameter to my default.nix is very nice
20:22:02 <roconnor> ocharles: before hackage upload I can point it to my sdist for a last test.
20:23:46 <carter> guesting: you might also wanna consider using something like Machines or Pipes
20:23:51 <carter> whats your workload
20:23:52 <carter> oh
20:23:53 <carter> hes gon
20:31:21 <rekahsoft> hi all..i'm using the gtk2hs and found that a function "castToSpinner" is unavailable...to be specific i'm using the gtk3 package from hackage (version 0.12.5.7)..i found that castToSpinner is exported from Graphics.UI.Gtk.Types but the module is hidden..any ideas?
20:44:50 * hackagebot ConfigFile 1.1.2 - Configuration file reading & writing  http://hackage.haskell.org/package/ConfigFile-1.1.2 (JohnGoerzen)
20:46:09 <Dugar> I can never figure out how to make a function work on infinite lists. Would anyone recommend a place that explains lazy evaluation well?
20:49:14 <johnw> Dugar: what is the problem?
20:49:55 <Dugar> I don't understand how thunking works I guess
20:50:14 <johnw> can you show me the function that isn't working?
20:50:43 <Cale> Dugar: Lazy evaluation is just outermost-first evaluation together with a caveat that the value of any bound variable is evaluated at most once.
20:51:03 <Cale> (and the work done to evaluate it shared amongst the copies)
20:51:50 <Cale> Dugar: For example, before we get into infinite structures, let's consider the definition  double x = x + x  and the expression  double (double x)
20:52:05 <Cale> Dugar: Under strict evaluation, we'd evaluate this innermost-first:
20:52:15 <Cale> er, double (double 5) rather :)
20:52:16 <vermeille> I have a circular dependency, what are the common ways to work around that?
20:52:26 <Cale> double (double 5)
20:52:28 <roconnor> vermeille: in your source files?
20:52:30 <Cale> -> double (5 + 5)
20:52:33 <vermeille> roconnor: yup
20:52:33 <Cale> -> double 10
20:52:35 <johnw> vermeille: cabal?  type?  function?
20:52:36 <Cale> -> 10 + 10
20:52:38 <Cale> -> 20
20:53:00 <vermeille> roconnor: modules circular dependency in my own source code
20:53:14 <Dugar> johnw, I wrote 8 any functions trying to figure out how to make one that works on infinite lists that will evaluate to true, and I couldn't tell you which would work without running them https://dpaste.de/Ss60F
20:53:16 <vermeille> I can't find a way to trivially break the cycle
20:53:16 <Cale> Dugar: But we could just as well choose the outermost occurrence of double to expand first:
20:53:19 <johnw> you can break them using boot files, or you can shift things around into an internal, common module
20:53:21 <Cale> double (double 5)
20:53:25 <Cale> -> (double 5) + (double 5)
20:53:32 <Cale> -> (5 + 5) + (double 5)
20:53:36 <Cale> -> 10 + (double 5)
20:53:40 <Cale> -> 10 + (5 + 5)
20:53:42 <Cale> -> 10 + 10
20:53:44 <Cale> -> 20
20:53:47 <roconnor> vermeille: there are few good answers.  You have to break things into more files.  Typically if you have two modules referencing each outher you end up with four: in two layers of two.
20:54:00 <Cale> Dugar: But this results in duplication of work, as you can see
20:54:26 <johnw> Dugar: did you write these?  or is this a homework problem that you have to choose which ones will work?
20:54:27 <Cale> we evaluated double 5 twice because the parameter of double, x, occurred twice in its body
20:54:45 <vermeille> roconnor: okay :( too bad that will break the design I thought of. Thx :)
20:54:53 <Dugar> johnw, this isn't homework. I was going through the exercises in the 4th chapter of real world haskell
20:55:01 <Dugar> I already know what works
20:55:01 <Cale> Dugar: So, what lazy evaluation does is to share this repeated work. I'll represent the sharing using let/in syntax
20:55:08 <roconnor> vermeille: Haskell is supposed to allow ciruclar module dependencies.
20:55:10 <Cale> double (double 5)
20:55:11 * roconnor glares at GHC
20:55:12 <johnw> vermeille: or you can use boot files
20:55:25 <Cale> -> let x = double 5 in x + x  -- note that this is still outermost-first
20:55:32 <Cale> -> let x = 5 + 5 in x + x
20:55:32 <johnw> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/separate-compilation.html
20:55:37 <Cale> -> let x = 10 in x + x
20:55:37 <johnw> "4.7.9. How to compile mutually recursive modules"
20:55:40 <Cale> -> 10 + 10
20:55:41 <Cale> -> 20
20:55:47 <Cale> Dugar: Cool?
20:56:47 <Dugar> I'm rereading it
20:56:50 <Cale> Dugar: So that's really all there is to lazy evaluation: it's just always reducing the outermost reducible subexpression according to the definitions, and making sure to share work that is done evaluating any variable with any other occurrences of that variable
20:56:53 <Dugar> it's kind of hard to follow explained in chat
20:57:47 <Cale> Dugar: Once you're caught up, we can look at what happens with infinite datastructures
20:57:58 <Dugar> alright
20:58:36 <vermeille> johnw: thanks for the link, after reading it, I think that I can break the cycle with less pain
20:59:44 <Cale> One thing which I should point out here is that under strict evaluation, the arguments to a function are always evaluated exactly once. Under plain outermost-first evaluation, the arguments are evaluated zero or more times (sometimes we save work by not having to evaluate an argument, but sometimes work is duplicated), and under lazy evaluation, you get the best of both worlds: every argument to a function is evaluated
20:59:44 <Cale>  zero or one times.
21:06:22 <JP2> hi i have a quick question if someone might be able to help me
21:06:54 <Cale> JP2: Feel free to ask any questions you might have here :)
21:06:54 <Dugar> alright Carl, I think I'm following your double example
21:07:00 <Cale> Cale
21:07:01 <Dugar> *Cale
21:07:02 <Dugar> sorry
21:07:05 <Cale> okay
21:08:20 <JP2> k cool
21:08:23 <Cale> So, let's consider something like map (*2) [1..]
21:08:33 <Cale> @src map
21:08:33 <lambdabot> map _ []     = []
21:08:33 <lambdabot> map f (x:xs) = f x : map f xs
21:08:55 <JP2> im trying to implement an instance of MonadTrans
21:09:16 <Cale> Here, map needs to know whether [1..] is of the form [] or (x:xs) in order to reduce
21:09:34 <Cale> So, the first thing which happens is that [1..] is evaluated, and it happens to evaluate to 1 : [2..]
21:09:54 <Cale> map (*2) [1..] -> map (*2) (1 : [2..])
21:10:06 <JP2> and I have another class LMonad that I'd like the underlying monad to implement
21:10:06 <Cale> and then the pattern (x:xs) matches
21:10:16 <Cale> with x = 1 and xs = [2..]
21:10:36 <JP2> is there anyway to do this?
21:10:43 <Cale> and so we get  map (*2) (1 : [2..]) -> (*2) 1 : map (*2) [2..]
21:10:48 <JP2> or do I need to subclass MonadTrans?
21:11:06 <Cale> JP2: You'll probably need a separate class
21:11:37 <JP2> hmm ok
21:11:43 <Cale> JP2: Just like Monad is only for monads which apply to all Haskell types, MonadTrans is only for monad transformers which apply to an arbitrary monad.
21:12:06 <Cale> JP2: Well, hang on
21:12:39 <Cale> Er, yeah, I thought perhaps there was something clever we could do, but not really.
21:12:48 <JP2> ah ok
21:13:05 <JP2> so should I define something like:
21:13:37 <Cale> class LMonadTrans t where lift :: (LMonad m) => m a -> t m a
21:13:57 <Cale> Might want to call that llift or something :)
21:14:09 <JP2> ok cool
21:14:38 <vermeille> Any criticism about my WIP VM code really appreciated :) https://bitbucket.org/Vermeille/functionality/src/6709ea70e03ef69b127274cc479d482c9ea91027/src/vm-proto/?at=master
21:14:42 <JP2> do you think reusing the name would cause headaches?
21:14:52 <Cale> Dugar: So, at this point in our evaluation, if we were evaluating the list just to determine if it was empty or not, we'd be done.
21:15:19 <Cale> Dugar: This expression (*2) 1 : map (*2) [2..] would match against (x:xs) with x bound to (*2) 1, and xs bound to map (*2) [2..]
21:15:37 <aspidites> vermeille: first critcism: Since when is writing a VM considered "beginner material"?
21:15:56 <aspidites> or, without the sarcasm: Ive not read a single line yet and I'm already impressed
21:16:40 <vermeille> it's really not as hard as it sounds
21:16:50 <vermeille> proof: I'm doing it
21:16:56 <aspidites> haha
21:17:09 <aspidites> btw, "dudes, we're talking 'bout C, no shit, how could I really say "high level"?)" <- that made me lol...literally
21:17:42 <aspidites> or this -> If my english is not completely fucked up, an assembler assembles assembly.
21:17:47 <vermeille> Haha :D I'm so proud of that README :D
21:17:48 <Cale> JP2: Not major ones, but it would result in having to import the module qualified.
21:18:15 <JP2> k id probably prefer not to do that so ill rename it
21:18:22 <Cale> JP2: I usually try to avoid intentionally creating name collisions, yeah
21:18:45 <Cale> (some people love to though, it's just a matter of personal taste)
21:18:58 <aspidites> on a serious note, whats the relationship between vm and vm-proto other than that one is in c and the other is in haskell?
21:19:00 <aspidites> or is that the point?
21:19:30 <aspidites> i don't see any Foreign calls
21:20:00 <vermeille> That's the point. Haskell needs a runtime to run. In fine, I want this VM to run in kernel land. But first, I'm just prototyping in Haskell to be sure my assemly is sound
21:20:29 <aspidites> aaah
21:21:13 <vermeille> After playing with my assemlby and being sure it is optimally designed, then I will translate the VM to C
21:22:18 <aspidites> i'm sure Arithmetics.hs could be simplified
21:22:58 <Dugar> Cale, the map evaluation doesn't really look like innermost or outermost evaluation to me.
21:23:24 <vermeille> I'm sure too, didn't managed to do it. I ended up with #define things at best
21:23:41 <Cale> Dugar: Well, it's outermost-first, map gets a chance to try to match
21:24:04 <Cale> Dugar: and because it pattern matches on its second argument, that argument gets evaluated
21:24:33 <Cale> (well, because the second argument isn't already in a form where it can match)
21:25:34 <Cale> There are a couple ways you could describe what's going on -- either you fail to consider the map (*2) [1..] a reducible subexpression because the [1..] doesn't immediately match (which means you have to look deeper for a redex)
21:25:58 <Cale> Or you could say that it does reduce to something like  case [1..] of [] -> ... ; (x:xs) -> ...
21:26:32 <aspidites> ugh. how soon we forget things. add' <$> pop <*> pop >>= push... is that fmap add' over the composition of pop and pop then bind that to push?
21:28:00 <Ginto8> aspidites: I think it's the applicative version of add' (pop x) (pop x) >>= push
21:28:21 <Cale> >>= binds more weakly than the applicative operators
21:28:39 <vermeille> aspidites: Yup. I add the two pop'd values, then push the result.
21:28:44 <Cale> So it parses as ((add' <$> pop) <*> pop) >>= push
21:28:58 <aspidites> lightbulb
21:29:00 <aspidites> thanks guys
21:29:19 * aspidites loves how he can get a the what AND why in #haskell
21:29:25 <Cale> and yeah, add' <$> pop <*> pop is the same thing as liftA2 add' pop pop
21:29:38 <Cale> which is typically the same thing as liftM2 add' pop pop
21:30:15 <Cale> So you could write this as  do x <- pop; y <- pop; push (add' x y)
21:30:57 <aspidites> Cale: very nice break down. I'm trying to stay away from do syntax though, as I think it's clouding my understanding of a lot of things
21:32:08 <Dugar> @src foldl
21:32:09 <lambdabot> foldl f z []     = z
21:32:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:32:35 <zcd> is there a command that does that @src does but in ghci?
21:32:47 <Cale> Dugar: You might notice that foldl will never work on an infinite list, because it does nothing but greedily apply itself to new arguments until the end of the list is reached
21:32:52 <Ginto8> zcd: :list iirc
21:32:54 <Cale> Dugar: on the other hand:
21:32:57 <Cale> @src foldr
21:32:57 <lambdabot> foldr f z []     = z
21:32:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:33:05 <Cale> foldr immediately passes control to f
21:33:26 <Cale> and the foldr only continues if f bothers to examine its second argument
21:34:18 <Ginto8> my fold mnemonic is: foldl adds parens on the left, foldr on the right. It's the same as left- and right-associative but I keep forgetting how those work :P
21:34:27 <Cale> > foldr (\x y -> if x > 5 then x^2 else y) 0 [1..]
21:34:28 <lambdabot>  36
21:34:41 <Cale> > foldl (\y x -> if x > 5 then x^2 else y) 0 [1..]
21:34:47 <lambdabot>  mueval-core: Time limit exceeded
21:34:55 <vermeille> aspidites: nothing to criticize :( :p ?
21:35:44 <Cale> An important characterisation of foldr is that foldr f z is the function which replaces each occurrence of (:) throughout the list with f, and [] with z
21:35:45 <Ginto8> vermeille: pc += 1 -- is that a lens-ism?
21:37:07 <Ginto8> actually vermeille, you've inspired me to add an idea to my idea list -- properly learn forth by implementing it in haskell.
21:37:35 <Cale> foldl isn't as natural: if the list was a snoc list (i.e. built up from a Snoc constructor which took a list and an element and gave the list with that element added to the end) then foldl f z would replace each snoc with f and the nil (at the beginning!) with z
21:37:42 <aspidites> vermeille: actually i'm playing with a few things
21:37:51 <aspidites> i speak better in code than words on matters of code :P
21:38:16 <aspidites> one thing though, vermeille - a cabal file would be nice :-) (cabal init)
21:38:36 <vermeille> Ginto8: it is
21:39:15 <vermeille> Oh, true, never used cabal for something else than "cabal install"
21:39:54 <aspidites> and the dreaded mtl errors again... are you on 7.6 by chance vermeille ? (ghc)
21:40:00 <Ginto8> I find lens quite weird in Haskell. Interesting, quite useful in some areas (esp. traversals), but very weird.
21:40:49 <vermeille> aspidites: yup, 7.6.3
21:41:54 <aspidites> that explains it.
21:42:14 <Dugar> I guess what's throwing me off is that outermost or innermost only means something to me if there are parenthesis and the map example doesn't have any
21:42:34 <aspidites> just occured to me, could all that add', sub', etc stuff be negated by making Arith an instance of Num?
21:43:06 <vermeille> aspidites: actually I don't understand what's the "mtl errors" you're talking about
21:43:09 <Cale> Dugar: Oh, well, there's implicitly a tree structure to the expression
21:43:16 <aspidites> eliminated rather
21:43:33 <aspidites> vermeille: well if you upgrade to ghc 7.8 and try to install lens you will ;-)
21:43:48 <aspidites> unless.. i wonder if they've updated it yet. i need to cabal update real quick
21:43:55 <Cale> Dugar: I suppose it's not the best example, because it's using a bit of special syntax
21:44:07 <Cale> [1..] is shorthand for (enumFrom 1)
21:44:16 <vermeille> aspidites: something which breaks the build?
21:44:32 <aspidites> vermeille: yep. unresolvable dependencies
21:44:42 <Cale> Dugar: Where I'm assuming we have something like  enumFrom n = n : enumFrom (n+1)
21:45:34 <vermeille> aspidites: If you managed to write it with the Num instance, please show me. I tried for hours (I'm maybe really stupid so, try :p)
21:45:45 <vermeille> aspidites: ok good, I won't update :D
21:46:02 <aspidites> can't write anything (and test it) because I can't get dependencies to install
21:46:35 <Ginto8> Dugar: the map example can work (trivially) because it works only each individual item in the list. The innermost/outermost is because a list like [1,2,3] is actually 1:2:3:[], or with parentheses 1:(2:(3:[]))
21:47:40 <Ginto8> when you replace [] with some thunk that keeps yielding list elements, you have an infinite list
21:48:10 <Cale> I tend to just use the word "expression" in place of "thunk"
21:48:30 <Ginto8> in the case of [1..] it's like Cale said, where it's an infinite list like [1,2,3,4,..] or 1:(2:(3:(4:..)))
21:48:47 <Cale> Thunks are just the runtime representation of expressions, you don't need to really look at things at that level in order to understand how a program will behave
21:49:03 <ReinH> x = 1:x might be an easier example
21:49:08 <Cale> yeah
21:49:40 <aspidites> can you parameterize the where clause, vermeille?
21:50:00 <ReinH> x = 1:x = 1:(1:x) = 1:(1:(1:x)) = ...
21:50:53 <vermeille> aspidites: like what?
21:51:28 <aspidites> vermeille: http://hastebin.com/ejufujefam.hs
21:51:51 <Clint> ru/goto 2:31
21:52:35 <vermeille> aspidites: it won't work for (/) because it has to be (/) for floats but `div` for ints
21:53:13 <osa1> is there a way to not to redirect build log to a file?
21:53:50 <osa1> (in cabal)
21:53:53 <aspidites> vermeille: using fromIntegral, doesn't that imply float? (or rather non-integer)
21:54:58 * hackagebot system-fileio 0.3.13 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.13 (JohnMillikin)
21:55:24 <Ginto8> aspidites: fromIntegral is good for almost any Num a => Integer -> a conversion, but I think if that typechecks it probably sees op as returning Floating a (from (/))
21:55:36 <johnw> :t fromIntegral
21:55:37 <lambdabot> (Num b, Integral a) => a -> b
21:55:52 <Ginto8> even more general ;)
21:55:54 <vermeille> aspidites: only in the cases where fromIntegral is written :) in all other cases, we're dealing with ints
21:56:20 <Ginto8> but f can be (/)
21:56:22 <Ginto8> :t (/)
21:56:23 <lambdabot> Fractional a => a -> a -> a
21:56:27 <ReinH> monochrom: ping
21:56:46 <ReinH> Cale: Maybe you can tell me. Am I totally off base here? http://www.reddit.com/r/haskell/comments/252wb3/a_leak_free_and_tail_recursive_foldl/chdeisz?context=3
21:56:56 <Dugar> alright, well looking back on my anys https://dpaste.de/Ss60F#L I know that only any5 works with the expression "any# odd [1..]" Everything else fails
21:57:05 <aspidites> ah, not sure how i glossed over I8, I16, and I32
21:57:17 <Dugar> foldl never works on infinite lists, but I'm not clear why my other anys fail
21:58:07 <Dugar> if we're doing outside first and the expression is ((predicate x) || (accumulator)). Outside first would mean the right accumulator?
21:58:09 <Cale> ReinH: you're correct
21:58:17 <ReinH> Cale: oh thank god. I thought I was going insane.
21:58:18 <Dugar> Is that why any5 works instead of any4?
21:59:34 <Cale> ReinH: Note that certain people still think of it as a call stack (e.g. Simon Marlow does), but that's probably because he thinks in terms of the implementation. It doesn't really map very clearly to Haskell "function calls" (I actually really find the word "call" quite confusing in the context of functional programming)
22:02:10 <btubbs> I'm trying to get this Scotty + Persistent gist to work: https://gist.github.com/egonSchiele/5400694.  I've fixed a couple import problems, resulting in http://lpaste.net/103846, but am now stumped by this error: http://lpaste.net/103847 .  help?
22:03:48 <Cale> ReinH: There is at least one thing which isn't pattern matching that nevertheless uses the stack though, if we're being pedantic -- when you apply a function, if the function itself is not a lambda, the current context waits on the stack for the function to be evaluated. I don't think I've *ever* had a stack overflow from those kinds of entries though.
22:05:11 <ReinH> Hmm.
22:05:46 <ReinH> Cale: The real argument isn't about what name you give the stack anyway
22:05:51 <ReinH> it's about the behavior of tail calls
22:06:35 <lispy> ReinH: it took me a while to figure out what geezusfreeek is talking about: http://www.reddit.com/r/haskell/comments/252wb3/a_leak_free_and_tail_recursive_foldl/chde13p
22:07:16 <Cale> hm, okay
22:07:51 <Bambi18>  Hi! I give you some videos. I hope you like! http://bitly.com/1gAh6Jy
22:08:37 <lispy> Bambi18: my browser says there is malicious content at that URL
22:10:06 <lispy> ReinH: I don't think geezusfreeek doesn't mean tail recursion, but really means that sometimes you transform to an accumulator argument to avoid stack overflows. In particular, when you the accumulator has a strict function applied to it, like (+) in the badLength
22:10:15 <lispy> oops, double negative
22:11:14 <ReinH> lispy: so len = lenAcc l 0 where lenAcc [] x = x; lenAcc (_:xs) x = lenAcc xs (x + 1)
22:11:24 <lispy> btubbs: most not be any scotty users on right now. Maybe ask again in a bit?
22:11:29 <ReinH> (badLength is actually genericLength)
22:11:59 <lispy> ReinH: right so now that you have it in the form you'll also have to add strictness to the accumulator.
22:12:21 <ReinH> right, GHC uses an unboxed int
22:12:42 <lispy> if (+) were lazy, you migth not need to reduce the accumulator at each step
22:12:49 <btubbs> thanks lispy.  My googling is pointing towards some changes in resourcet or Control.Monad.Logger since that Gist was made, but modifying my Main.hs to look like the examples hasn't helped
22:12:53 <lispy> Well, as written len isn't strict in x.
22:13:14 <ReinH> right, but that's the transform to "tail call" form
22:13:28 <Cale> ReinH: The strictLength *does* benefit from the way in which it was written, it's just not because TCO is happening.
22:14:20 <ReinH> How exactly does it benefit?
22:14:41 <Cale> The combination of outermost-first evaluation and strictness annotations which cause the accumulator to remain evaluated on each step keep the memory usage low.
22:15:01 <ReinH> because the outer-most evaluation isn't the (+)
22:15:07 <Cale> yeah, it's go
22:15:38 <ReinH> Ok, that makes sense
22:15:44 <Cale> go 0 [1..10] -> go 0 (1 : [2..10]) -> go (0+1) [2..10] -> go 1 [2..10] -> ...
22:15:53 <ReinH> Yeah, it makes sense from a lazy eval perspective
22:16:01 <ReinH> I was trying to make sense of it from a traditional TCO perspective
22:21:55 <monochrom> ReinH: how may I serve you?
22:25:02 * hackagebot purescript 0.5.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.1 (PhilFreeman)
22:29:59 <jle`> l
22:30:15 <ReinH> monochrom: Cale has been adequate in this, but thank you :)
22:30:42 <ReinH> Cale: I have found your service to be most... adequate. ;)
22:32:30 <Dugar> I also appreciate the help Cale
22:33:17 <jle`> so, after lens is as established now as monads are in the haskell community/idiomatic toolkit, i wonder what controversial tool will be next
22:34:03 <lispy> jle`: type nats
22:34:42 <mmachenry> jle`: Gay Scientologist Pro Choice Type Kinds
22:34:54 <jonascj> Hi all. I was in here just a minute ago but my battery suddenly ran dry on my laptop and I was disconnected. I was asking how "import MyModule" know that MyModule.hs is lcated in lib/MyModule.hs.
22:35:03 * hackagebot tls 1.2.7 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.7 (VincentHanquez)
22:35:42 <jle`> jonascj: it's relative to your hs-source-dir
22:35:44 <jle`> in your cabal file
22:35:47 <lispy> jonascj: import Foo.Bar.Baz => Foo/Bar/Baz.hs (or .lhs) and the lib part comes from an hs-source-dirs in your .cabal file
22:35:54 <jonascj> Does GHC always look in subdirs for import or is this a convention of xmonad (which uses hasell) that upon compilation it includes a subdir called lib in the search path?
22:35:54 <jle`> source-dirs, sry
22:36:01 <monochrom> a command line flag "-ilib" is how ghc tries lib/ for MyModule.hs and other files
22:36:17 <jle`> it's relative to usually only specified subdirectories
22:36:24 <jle`> so whatever you are using manually said "look in ./lib"
22:36:36 <jle`> at some point
22:37:21 <monochrom> no, ghc does not look in directories it is not told about. except the current directory.
22:37:54 <jonascj> compilation of this is done by Xmonad. modkey+p recompiles the xmonad config and reruns the xmonad program. So maybe they use the "-i lib" flag
22:38:07 <lispy> I went out to my desktop the other night and found ghc rummaging through my recycling bin :(
22:38:23 <monochrom> it is "-ilib", not "-i lib". "-i lib" is an error.
22:38:25 <jonascj> :P
22:38:39 <newsham> you must have the latest garbage collector, lispy
22:38:46 <jonascj> monochrom: sorry
22:39:14 <jle`> jonascj: if you do something like import Foo.Bar.Baz
22:39:25 <jle`> it'll look at lib/Foo/Bar/Baz.hs
22:39:44 <jle`> (or .lhs)
22:39:55 <jle`> oh, lispy just said exactly the same thing
22:40:00 <jle`> with exactly the same module names
22:40:06 <jle`> (how embarassing)
22:40:08 <lispy> and the side note about .lhs
22:40:33 <lispy> It's okay. You're secret is safe with me and the other 1300 people in the channel.
22:40:45 <lispy> your*
22:40:47 <jle`> good thing irc is a transient medium!
22:40:58 <jle`> or is the word ephemeral
22:41:11 <newsham> ignore the /topic bit about log files
22:43:05 <jonascj> jle`: "import Foo.Bar.Baz" looks for "lib/Foo/Bar/Baz.hs"? I thought the other guys said it would look for "Foo/Bar/Baz.hs" unless you passed the flag "-ilib", then it would look in "lib/Foo/Bar/Baz.hs"
22:43:34 <lispy> jonascj: you have the correct understanding
22:43:40 <lispy> -ilib matters
22:43:47 <jle`> ^^
22:44:07 <jonascj> I've just asked the guys in #xmonad and xmonad is configured to use "-ilib", so that's how
22:44:11 <aspidites> vermeille: so i have a Num instance
22:44:13 <aspidites> not pretty though
22:44:47 <lispy> jonascj: and gals as the case may be
22:44:51 <aspidites> record syntax or view patters would make it less verbose probably
22:46:05 <vermeille> aspidites: I cabalized the project :D Show me your code?
22:49:54 <aspidites> actually, i did minimal definition which fails on division. let me fix that real quick
22:50:57 <aspidites> actually.. (/) isn't part of the Num typeclass..maybe its part of fracional?
22:51:18 <vermeille> :t (/)
22:51:20 <lambdabot> Fractional a => a -> a -> a
22:51:34 <aspidites> :t div
22:51:35 <lambdabot> Integral a => a -> a -> a
22:52:11 <lispy> aspidites: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3aNum
22:52:20 <lispy> aspidites: that lists the minimal set for Num
22:52:58 <ReinH> Cale: is there any way in which this statement might be true? "Tail calls are translated into gotos by GHC just like in a "normal" language implementation."
22:56:37 <aspidites> lispy: i read those. thats how i realized (/) wasn't included
22:59:03 <jle`> i wonder why (/) isn't in Num (where it would be div for Integral types)
22:59:27 <jle`> if it was, Num could be a ring
22:59:39 <tac-tics> But then Natural wouldn't be Num
22:59:41 <jle`> i guess it would make type inference harder
22:59:49 <jle`> or, less specific
23:00:02 <tac-tics> But I guess Haskell already makes the sin of the Int-cultural-default
23:00:20 <jle`> does Nat not have a meaningful div?
23:00:34 <aspidites> vermeille: http://hastebin.com/xowodojeta.hs
23:00:56 <jle`> is Fractional our ringy-thing then
23:01:16 <aspidites> anyway, i think you'd have to create instances for real, fractional, and integral to get division
23:03:14 <monochrom> we expect (/) to satisfy: if d is non-zero, then (c/d)*d = c. this cannot be done to natural numbers.
23:03:40 <jle`> ah
23:04:09 <Enigmagic> and floating point numbers ;-)
23:04:10 <jle`> yeah, integer division isn't really defined as the inverse of integer multiplication
23:04:10 <monochrom> you have also mixed up ring and field. field is the one supporting (/). ring does not have to.
23:04:41 <jle`> oh yeah, i do have that mixed up, thanks
23:04:42 <vermeille> aspidites: that's interesting. Not as beautiful as I hoped, but still :) Thx!
23:04:55 <Cale> ReinH: It's hard to interpret that statement, because the evaluation mechanism is so different
23:05:00 <Cale> ReinH: It's kind of true
23:05:16 <Cale> But "just like a normal language implementation" is very misleading
23:05:48 <Cale> It's true in that the implementation of evaluation involves jumping into the code for the scrutinee.
23:06:11 <trap_exit> I have this new theory on type theory I'd like to discuss.
23:06:27 <trap_exit> "All programming langauges that care about their types eventually converge to Coq."
23:06:48 <trap_exit> So it seems that with Haskell, as the type system becomes more and more complicated
23:06:58 <trap_exit> all what's happening is that we're taking steps towards fuly dependent types, i.e. Coq.
23:07:06 <Cale> trap_exit: Half true, but Coq specifically? The design space for dependently typed systems is quite large.
23:07:23 <trap_exit> Cale: no, not necessairly Coq
23:07:36 <trap_exit> you're right, it should be converges towards some dependently typed language
23:07:37 <Cale> We are taking steps toward dependently typed systems, that's the plan, yeah.
23:08:21 <Cale> SPJ and Stephanie Weirich and the others who work on Haskell's type system are quite aware of what they're doing. :)
23:08:41 <monochrom> empirical evidence points towards divergence.
23:08:45 <osa1> any ideas how does Tagged v String in optionName field work here https://hackage.haskell.org/package/tasty-0.8.0.4/docs/Test-Tasty-Options.html ? I'm trying to implement an instance
23:08:47 <trap_exit> So why not just go all the way
23:08:49 <Cale> The goal is to approach dependent typing while maintaining good type inference for a fragment of the language.
23:08:50 <osa1> I never used Tagged
23:08:51 <trap_exit> instead of a bunfh of incremental steps?
23:09:17 <Cale> Dependently typed systems tend to insist that you annotate a whole lot more than Haskell does.
23:10:13 <Cale> We'd like it to be the case that programs which don't use fancy types don't need type annotations.
23:11:35 <Cale> and, well, moreover, that only the terms which really have those fancy types (or sometimes the things which use them) need to be annotated
23:12:51 <Saizan> you mostly need to annotate toplevel definitions
23:13:46 * tac-tics finds type inference annoys him as much as it helps.
23:14:03 <dolio> Yeah, a lot of what you have to annotate in Agda is stuff that people yell at you for not annotating in Haskell anyway.
23:14:22 <Cale> I'd like to approach a language which has both good type and term inference.
23:14:32 <dolio> And sometimes you can put in _ and it will figure stuff out, which GHC won't even do.
23:14:34 <tac-tics> I think the big thing is when you want to refactor a lot of code
23:14:45 <tac-tics> and you have to slog through all the old garbage types and fix them.
23:14:59 <Cale> We ought to be able to place holes at both the type and term level and have the compiler do a great job of filling them in.
23:14:59 <Saizan> but in haskell you can ask ghci to give signatures to most toplevel defs for you :)
23:15:06 <Cale> Saizan: right!
23:15:58 <dolio> Local definitions are actually the most significant cost.
23:16:03 <dolio> In a where.
23:16:15 <Saizan> yeah
23:16:25 <jle`> there is a way to fake type level holes in the new ghc tho
23:16:33 <jle`> a little more elegantly than :: Int
23:16:39 <Saizan> lately the agda mode got C-c C-h to generate types for those though, that's great
23:19:10 <SrPx> dude... Haskell is beautiful
23:19:32 <me__> I disagree
23:19:47 <tac-tics> Haskell is all right
23:19:51 <SrPx> why you__ disagree?
23:20:20 <SrPx> tac-tics: you use Agda, you don't count.
23:20:43 <cmears> Can some Template Haskell expert help me make my TH more pretty?
23:21:03 <cmears> My code+question is here: http://lpaste.net/103851
23:21:05 <me__> is template haskell worth using?
23:21:46 <tac-tics> template haskell is important for certain kinds of work
23:21:51 <fyolnish> man that looks opaque
23:21:56 <tac-tics> It's kind of fugly, though
23:22:16 <cmears> My question is about how to make it less ugly
23:23:11 <fyolnish> when would one use template haskell? can't parametric types accomplish most of the same things? (I don't know haskell at all)
23:23:12 <tac-tics> Never really programmed with it. Just copy-pasta'ed examples :<
23:23:26 <tac-tics> fyolnish: TH saves you a lot of boilerplate
23:24:10 <tac-tics> Stuff that can't be encoded as parametric polymorphism. It's about automatically generated code, often with custom types being created or fields being added or new instances for types.
23:24:18 <joelteon> fyolnish also allows you to run IO at compile-time!
23:24:24 <joelteon> or rather
23:24:26 <joelteon> template haskell does
23:24:30 <joelteon> i mistyped something there
23:24:35 <cmears> fyolnish, in my case I want to unroll a lookup into a big chain of if-then-else, for efficiency
23:24:42 <joelteon> fyolnish, have you done any work on xnomad recently?
23:25:02 <fyolnish> no, the per-screen spaces in mavericks messed everything up
23:25:07 <joelteon> damn
23:25:27 <fyolnish> it should still work alright if you just turn that off though
23:48:11 <redtricycle> http://lpaste.net/103852 Couldn't match type `GHC.Word.Word8' with `Char'
23:48:18 <redtricycle> How do I convert that to a char?
23:48:56 <EvanR_> :t chr
23:48:57 <lambdabot> Int -> Char
23:49:08 <EvanR_> you can convert a Word8 to an Int with fromIntegral
23:49:18 <EvanR_> :t chr . fromIntegral
23:49:19 <lambdabot> Integral a => a -> Char
23:51:09 <redtricycle> I think that worked, thanks EvanR_ ...on to the next type error
