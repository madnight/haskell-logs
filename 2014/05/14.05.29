00:08:35 * hackagebot semigroups 0.15 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15 (EdwardKmett)
00:08:35 * hackagebot command-qq 0.2.1.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.2.1.0 (MatveyAksenov)
00:15:52 <Ainieco> i want to create UUID type indexeed by type that uuid represents, for example if i had findCarByUUID function i want that function only accept UUID indexed by Car(it's a record) type
00:16:36 <Ainieco> it sounds like i want type families but not sure if it's overkill and haskell(not GHC-SUPER-HASKELL) have something to suite my needs
00:17:42 <Cale> You could just have a phantom type parameter
00:18:12 <Cale> data UUID a = UUID Word128
00:18:31 * hackagebot probability 0.2.4.1 - Probabilistic Functional Programming  http://hackage.haskell.org/package/probability-0.2.4.1 (HenningThielemann)
00:18:45 <Cale> and then the operations for creating UUID values will pick specific types for 'a' even if they otherwise go unused
00:18:53 <johnw> or: data UUID a where makeCar :: Word128 -> UUID Car
00:18:54 <Cale> (and consuming them of course)
00:19:38 <Ainieco> Cale: oh, that's neat, thanks! need to try that out
00:21:39 <Cale> Ainieco: btw, http://hackage.haskell.org/package/largeword
00:21:56 <Cale> (if you'd like Word128)
00:22:44 <Ainieco> Cale: he-he, thanks, but i'm already using http://hackage.haskell.org/package/uuid and want to build something more type safeo n top of it
00:23:09 <johnw> Ainieco: you can use the tagged package to do that
00:23:22 <johnw> so, in your case, you'd use the type: Tagged a UUID
00:23:51 <johnw> it lets you wrap a type with a phantom type
00:23:51 <Ainieco> johnw: http://hackage.haskell.org/package/tagged that one?
00:23:54 <johnw> yes
00:24:57 <Ainieco> johnw: is there any difference from Cale's "data UUID a = UUID Word128"?
00:25:07 <johnw> no
00:25:11 <johnw> Tagged should be a newtype
00:25:27 <Ainieco> okay
00:37:19 <klrr_> chrisdone: sorry in advance for yet more feedback on the website, but i had an idea; what if there's like 5ish examples of some beutiful haskell gem (like incorrect quicksort) and then one of them get randomly picked by some JS when you land on the page so each time you visit you see a new sample code instead of always the primes one
00:38:12 <klrr_> i used this for a school project website, and i was quite effective (it was about dont drink and drive though, and i was having random facts about casualties in traffic caused by it)
00:38:58 <Ainieco> http://racket-lang.org/ reminds me of
00:39:34 <klrr_> yeah, but i mean it just picks randomly, i think its much more effective than forcing the user to click "next" button
00:39:48 <klrr_> since most people are lazy ;)
00:40:25 <m09> one of the problems with that is that most haskell gems are not understandable to a newcomer
00:40:30 <klrr_> hmm that racket site reminds me, maybe there should be a navbar link to hackage
00:40:55 <klrr_> m09: well they dont have to, it may be more like "wow, such code, such short, i need to learn haskell"
00:41:21 <m09> yeah but it might turn into wow such maths, such brain-ache, let's go back to python
00:43:04 <klrr_> m09: i was thinking more like the current examples with primes, maybe the incorrect (but beutifully short) quicksort, one liner fibonacci etc., those arent really "such math" right?
00:44:30 <m09> I agree for the sorts
00:44:43 <m09> for fibs it's a bit obscure even if it's beautiful imo
00:45:17 <klrr_> if the snippets are wisely picken it maybe can work :)
00:45:25 <m09> yup !=
00:45:27 <m09> :)*
00:48:06 <m09> btw, for the prime example: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
00:48:23 <m09> we might want to rename sieve into something else!
00:49:08 <Ainieco> actually personally i don't find language site important at all, for example i've been programming in ruby for 5 years already and visited their main site less than 10 times(honestly).
00:49:15 <sopvop> is there a package for testing contents of aeson Value? like assetObjectWithKeys :: Value -> [Text] -> Assertion?
00:49:55 <klrr_> Ainieco: same here, 1 y+ haskell now and i rarely (or ever) go to the website, but if there's improvement i dont see why not using it ;)
00:52:01 <sshine> Ainieco, as chrisdone points out, it's a PR site mainly intended for newcomers.
00:52:31 <sshine> chrisdone, very nice-looking mock-up! a bit too much space in the <div class="header"> for my taste, and the "An open source community effort..." box seems kind of pointless (besides looking fancy)?
00:53:52 <sshine> chrisdone, also, I don't think the current haskell.org site is bad, at least not the first screen of the front page. there's mostly, IMO, a bunch of stuff that could be omitted.
00:54:50 <johnw> does C++ even have a "main site"?
00:55:05 <klrr_> http://isocpp.org/ ?
00:55:28 <johnw> oh yeah, I remember them putting that up like what, 2 years ago
01:10:40 <favetelinguis> Trying to get small Scotty example working http://lpaste.net/104782 get error when doing cabal configure
01:11:20 <Ainieco> favetelinguis: paste error
01:11:29 <favetelinguis> at least the following dependencies are missing: scotty -any
01:11:49 <Ainieco> cabal install --only-dependencies
01:13:38 <favetelinguis> So the typical caball workflow is 1- cabal install to get all the specified dependiencies, 2. cabal configure to do some stuff 3. cabal build to finaly build the file?
01:14:38 <Ainieco> favetelinguis: usually i'm doing just cabal install --only-dependencies and then cabal run
01:14:48 <Ainieco> not using cabal configure that much
01:15:16 * Ainieco passes --enable-test with cabal install --only-dependencies
01:15:35 <favetelinguis> what does cabal configure do, only checks dependiencies in the .hs file?
01:17:03 <Ainieco> yeah, checking if everything is available, resolving deps, etc AFAIK
01:17:45 <Ainieco> usually cabal runs "configure" implicitly before install or build or run
01:18:43 <favetelinguis> after installing scotty forever it works now, thanks for quick help!
01:18:53 <Ainieco> np
01:59:18 <poucet> random musing: Am I the only one that wishes there was a 'class Cond c a where if :: c -> a -> a -> a' with a subclass: "instance (Cond c v) => (Cond (m c) (m v)) where if c t f = c >>= \c' if c' then return t else return f
02:00:07 <poucet> and 'if then else' would default to that calss, similarly to how literal ints default to Num
02:00:11 <poucet> s/calss/class
02:02:31 <shachaf> That particular class and instance doesn't look very appealing.
02:02:41 <shachaf> But you can rebind if-then-else with RebindableSyntax in GHC.
02:02:59 <sshine> poucet, so you could have an instance for [Bool] for nondeterminism? :)
02:04:41 <poucet> sshine: Well mostly the reason I want this is because monads make it easy to reify syntax into an AST
02:04:52 <poucet> sshine: the case that doesn't work is 'if' and 'case' statements
02:04:55 <poucet> sshine: e.h. the magic people do with
02:04:56 <poucet> > x + 1
02:04:58 <lambdabot>  x + 1
02:05:05 <poucet> s/e.h/e.g
02:05:46 <remdezx> Hello! I have a sql file with db scheme. Is it possible to include it as string during the compilation time?
02:06:39 <poucet> remdezx: Could you clarify? You can always just make a variable with a stirng. Are you asking how to load an external file during compilation time? If so, why do you desire to do this
02:08:51 * hackagebot cassava 0.4.1.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.1.0 (JohanTibell)
02:09:43 <remdezx> poucet: This sql file is rather big and doesn't present pretty in code as multiline string. I don't want to read it at runtime, because I'm not sure I cannot deliver it with an executable
02:10:07 <poucet> remdezx: Maybe your build-file could help? You could have a build-target autogenerate the .hs file?
02:10:26 <remdezx> so I thought is it possible to make something like "let query = #include "db.sql"
02:11:00 <remdezx> poucet: oh, thats sounds interesting
02:11:00 <supki> remdezx: Template Haskell can do arbitrary IO at compile time, so yes, it's possible
02:13:03 <remdezx> supki: that's intersting too, I didn't know about it. Anyway, I think that build-file will be better for my case
02:13:29 <remdezx> poucet, supki: thanks a lot for your guidance! ;)
02:15:58 <poucet> remdezx: Np :)
02:33:35 <deni> wow...doing a talk about non fp/haskell related stuff, in my bio i write i enjoy learning / am enthusiastic about fp and haskell. they write "is fluent in" haskell and fp in general. fail.
02:34:15 <deni> on the other hand i guess i'm fluent now so i can quit this learning thing i'm doing XD
02:40:12 <matematikaadit> Reading Yorgey course chapter 3 (http://www.seas.upenn.edu/~cis194/lectures/03-rec-poly.html). and this sentences made me smiles "You might think doing such things is only for chumps who are not coding super-geniuses like you. Of course, you would never make a mistake like passing an empty list to a function which expects only non-empty ones. Right? Well, there’s definitely a chump involved, but it’s not who you think."
02:40:42 <warpy> hah
02:44:14 <bvad> deni: I've never really understood that notion of being 'fluent' in a programming language.. Is it "I know all syntax rules"?
02:48:17 <blipped> I think the definition of fluent would be quite hard to pin down.
02:48:24 <blipped> Even with spoken languages it's hard to define.
02:48:56 * hackagebot rss 3000.2.0.3 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0.3 (BasVanDijk)
02:48:59 <deni> bvad: my point exactly wtf does that even mean :D
02:50:12 <deni> bvad: it's even  worse because i said enjoy learning fp langs in general, and they said fluent in fp langs in general....i'm like wow i know ALL THE LANGS! why didn't anybody tell me
02:50:15 <deni> XD
02:51:10 <deni> like emperor of mankind from warhammer XD
02:54:28 <osfameron> I think fluent is perfectly cromulent for programming languages too
02:58:18 <bvad> osfameron: How would you define fluent then?
02:59:13 <osfameron> funnily enough, I was just looking at http://www.haskell.org/haskellwiki/Typeclassopedia and the two points under "There are two keys to an expert Haskell hacker's wisdom:" seem like a good starting point for Haskell
03:00:11 <osfameron> I'm not fluent in Haskell.  But I am in Perl (where the two keys would be: know the syntax. know your way around CPAN).  I can get by in Python/Ruby etc., but I'm not fluent because, again, I don't have a "deep intuition" about how to structure things in an idiomatic and powerful way
03:03:01 <deni> osfameron: i think #3 should be: Immortality :D
03:03:18 <osfameron> the life so short...
03:03:25 <|akh|> Hi. What is an easy way to make the main thread wait for all child threads created with a mapM_ forkIO ... call? The main purpose of my project is not to work with concurency so I would prefer not to spend too much time on that just yet.
03:07:02 <warpy> |akh|: http://hackage.haskell.org/package/lifted-async
03:09:39 <supki> |akh|: mvars are probably the simplest way to synchronize threads, but I'd go with async package
03:09:54 <supki> it has a bunch of useful functions, handles exceptions correctly, etc
03:11:40 <|akh|> warpy: Thanks I will take a look at it. I just ran into mapConcurrently in Control.Concurrent.Async, wouldn't that be about the same result?
03:12:25 <alpounet> yeah async is really nice, and handles all the ugly things for you
03:12:46 <warpy> |akh|: yes
03:13:52 <Maerten> Hi, what would be the easiest way to cache a DB result? So for example; everytime i call `selectList [ myField ==. val ]` with the same `val`, i want to get the cached result (if available).
03:14:21 <Maerten> Any help would be appreciated!
03:14:36 <|akh|> warpy: supki: great thank you.
03:15:05 <deni> i just now realized that haskell-lang is a new site not a redesign of the old one
03:15:49 <warpy> it's a work in progress
03:16:22 <Pythonfant> The logo on haskell-lang looks awesome
03:16:25 <Pythonfant> I really like the colors
03:16:29 <efg> what's a monad?
03:16:44 <sipa> nobody can be told what a monad is
03:16:55 <sipa> you have to see it for yourself ;)
03:17:14 <efg> how morpheusish
03:17:46 <sipa> (sorry to be unhelpful, but i do believe it is true: learn hiw I/O in haskell works and forgrt that people call it a monad)
03:17:46 <deni> am i the only one that things that having 2 homepages is confusing?
03:17:50 <deni> *thinkgs
03:17:53 <deni> **thinks
03:18:19 <efg> sipa: i know how io works in haskell practically, yet i don't fully get monads
03:18:40 <xenocons> take the blue pill, and you will wake up back in your bed, coding java every day, like nothing ever happened
03:18:54 <efg> eww
03:19:33 <xenocons> efg: yes, but i am sure we have all thought that at one stage
03:19:36 <xenocons> haskell has ruined me
03:20:01 <xenocons> thinking is incredibly dangerous
03:20:24 <xenocons> haskell - the gateway drug to dissatisfaction
03:20:32 <matematikaadit> efg: monad is just a typeclass
03:20:42 <efg> matematikaadit: that's not helpful
03:20:50 <Maerten> efg: i'm a haskell beginner but this is an article that just approaches monads in basic terms, without saying "monads are burritos" or "monads are easy, it's basically <insert 5 page math formula here>" ----> http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad
03:20:50 <alpounet> efg: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html -- that's one of the very few articles i recommend about monads :)
03:21:10 <efg> reading links
03:21:27 <xenocons> cofunctor is dead, long live cofunctor
03:25:01 <matematikaadit> effy: well, I'm just suggesting to not overthink it. It's just a typeclass that defines bind (>>=) and return. That's it. http://dev.stephendiehl.com/hask/#monads
03:25:32 <effy> what what ?
03:25:45 <matematikaadit> err.. sorry, wrong nick :D
03:25:52 <matematikaadit> I means efg
03:26:11 <efg> matematikaadit: that's not telling me anything useful about monads. So it defines bind and return. So what?
03:27:05 <matematikaadit> efg: that was answered in http://dev.stephendiehl.com/hask/#monads
03:27:22 <shachaf> And has all sorts of laws. The laws are pretty important.
03:29:35 <alpounet> efg: it's a pattern that's not obvious at first, but once internalised, you'll see it come up very often. it's really some vague kind of analogue thing to what the design patterns are in OO. except that this pattern comes from maths, has laws that tell you something about the behavior of any Monad and is way more applicable than it first seems.
03:30:01 <efg> so with that in mind, what's a monad?
03:33:02 <alpounet> efg: trying to reproduce the content of the links we just gave you would not be a good idea. I sincerely recommend you read these articles and then ask about the remaining questions you have
03:33:13 <efg> "a monad is a construct defined by its inability to be explained"
03:34:46 <matematikaadit> efg: if you need a precise definition, ...
03:34:50 <matematikaadit> @src Monad
03:34:51 <lambdabot> class  Monad m  where
03:34:51 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:34:51 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:34:51 <lambdabot>     return      :: a -> m a
03:34:51 <lambdabot>     fail        :: String -> m a
03:35:22 <efg> no, i need someone to convey the idea of what a monad is in terms available for mere mortals
03:35:52 <Walther> efg: wait a second, there was a very good tuto that made me understand
03:36:20 <Walther> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html?m=1
03:36:28 <Walther> There! Have fun :)
03:36:29 <efg> already linked abovwe
03:36:34 <efg> above
03:37:29 <awestroke> anyone seen haskell-lang and the associated blog post?
03:37:38 <srhb> efg: There are several mortal-friendly explanations, all slightly incorrect in one way or another.
03:37:39 <efg> i'm not asking for links to long articles, but for you guys to explain what a monad is in a few sentences. Apparently that's not possible.
03:37:46 <srhb> efg: You could have invented monads is the best answer.
03:38:37 <Walther> efg: sum (think math, not programming) is essentially a function. Sum is switchable; a+b == b+a. There are also other functions that are switchable; like multiplication - a*b == b*a. Nowthere should probably be a word for some functions following some same restrictions
03:38:38 <srhb> efg: A correct and short answer is also available. A Monad is a construct which defines >>= (called bind) and return, which obeys certain laws.
03:39:07 <m09> monads allow me to define bitStrings = flip replicateM [True, False] and that's all I care about!
03:39:13 <Walther> aaaaand from my understanding, Monad is one set of "rules" for functions to "comply with" to fit a "standard"
03:39:38 <alpounet> efg: that's like asking someone to define algebraic topology in 2 sentences
03:39:46 <alpounet> i'm exagerating, but that's the idea
03:39:47 <Walther> other than that, monadic functions can be pretty much anything from crubching numbers to washing your car
03:39:58 <Walther> Hope that helped a bit
03:41:16 <Walther> (and anyone feel free to correct me if I'm wrong)
03:42:11 <srhb> It's sufficiently vague to not be wrong, but probably not useful either. :D
03:42:23 <Walther> but to me, Monad is like a blueprint/specsheet for a lego brick. You can create your own bricks that are blue or blink, and if they still fit the specs, it's a monad and can be used easily with other functions in a certain way
03:42:26 <srhb> (Though the bit about functions and rules I find a bit iffy)
03:42:57 <Walther> Nod. I'm still learning myself, found this opportunity handy to get my definitions and understanding better as well :P
03:43:19 <srhb> I guess you're thinking of return and >>=
03:43:30 <Walther> weeellll not really
03:43:31 <srhb> And in that case, yeah. The monad laws should be obeyed.
03:43:42 <srhb> Well, ok. In that case, how is Just "foo" a function?
03:43:42 <Walther> Mmh.
03:44:07 <Walther> ...yeah, i'm still a bit off :)
03:44:10 <srhb> :-)
03:45:25 <matematikaadit> efg: well, if you ask a short and correct explanation about "What is Monad?", people will reply with "A typeclass that defines (>>=) and return", because that was written in the definition. It's like asking what is Eq, and got answer "A typeclass that defines (==)".
03:45:29 <Walther> what bewilders me even more though is the difficulty to grok IO and State in haskell (in general and the respective monads)
03:45:48 <srhb> Walther: Have you tried defining the State monad?
03:46:02 <Walther> haven't had the time yet, was recommended that earlier
03:46:10 <srhb> Walther: It will make everything clear, promise. :)
03:46:21 <Walther> i have the irc log screencapped for future reference
03:46:25 <m09> well you certainly already used your own implementation of the state monad in some form anyway
03:58:26 <matematikaadit> >Path to Monad Satori
03:58:44 <matematikaadit> 1. Don't read the monad tutorials.
03:58:46 <matematikaadit> 2. No really, don't read the monad tutorials.
03:58:53 <matematikaadit> 3. Learn about Haskell types.
03:59:00 <matematikaadit> 4. Learn what a typeclass is.
03:59:11 <matematikaadit> 5. Read the Typeclassopedia.
03:59:14 <matematikaadit> 6. Read the monad definitions.
03:59:26 <matematikaadit> 7. Use monads in real code.
03:59:33 <matematikaadit> 8. Don't write monad-analogy tutorials.
03:59:43 <matematikaadit> http://dev.stephendiehl.com/hask/#monads
04:02:46 <eliasdiem> I'd like to get an environment variable and turn it into an Int. lpaste.net/104783
04:04:43 <Maior> eliasdiem: itym IO Int
04:05:38 <Maior> eliasdiem: getEnv returns an IO String
04:05:50 <matematikaadit> eliasdiem: you're mixing an impure and pure code
04:05:53 <Maior> eliasdiem: so getHostFromEnv (odd name?) will have type String -> IO Int
04:06:10 <Maior> eliasdiem: just generally, "does not work" doesn't help; compiler output etc. does
04:06:59 <Maior> also argh why is getEnv not String -> IO Maybe String
04:08:57 <eliasdiem> Hmmm. I understand that 'String' and 'IO String' is not the same type
04:09:35 <eliasdiem> but I thought (until now) that <- is for mixing pure and impure stuff
04:10:01 <Maior> eliasdiem: it sounds like you may have come across some syntactic sugar before really understanding what it means / does
04:10:30 <eizo> "Don't read the monad tutorials." proceeds to write down a monad tutorials
04:10:41 <matematikaadit> eliasdiem: um... your (getHostFromEnv :: String -> Int) show that it's a pure code, so no impure stuff inside that
04:11:17 <eliasdiem> matematikaadit: well the function 'getEnv' is impure, isn't it?
04:11:25 <Maior> :t \s -> fmap (read :: String -> Int) $ getEnv s
04:11:27 <lambdabot>     Not in scope: ‘getEnv’
04:11:27 <lambdabot>     Perhaps you meant ‘getAny’ (imported from Data.Monoid)
04:11:49 <Maior> er, well, if I knew the runes to get lambdabot to install System.Environment...
04:11:54 <matematikaadit> eliasdiem: yes, getEnv :: String -> IO String
04:11:55 <Maior> that'd dtrt
04:12:06 <matematikaadit> :t getEnv
04:12:07 <lambdabot>     Not in scope: ‘getEnv’
04:12:07 <lambdabot>     Perhaps you meant ‘getAny’ (imported from Data.Monoid)
04:12:26 <Maior> matematikaadit: see above ;P
04:12:37 <awestroke> eliasdiem: "<-" is for _using_ IO values inside an IO computation, it's syntactic sugar for (>>=)
04:12:51 <Maior> :t \s -> fmap (read :: String -> Int) $ System.Environment.getEnv s
04:12:53 <lambdabot> String -> IO Int
04:13:05 <matematikaadit> \
04:13:23 <Maior> eliasdiem: my advice: stop using <- until you are quite familiar with, well, monad-y stuff
04:13:33 <Maior> matematikaadit: http://www.haskell.org/haskellwiki/Lambdabot had some useful advice btw
04:14:13 <eliasdiem> Maior: that might be a good advice ;-)
04:16:23 <eliasdiem> Still, how would you implement it so it works?
04:17:52 <matematikaadit> eliasdiem: try to guess the type of this snippet, do { s <- getEnv env; return (read s :: Int) }
04:19:38 <darthdeus> if i have [a] and a function that's  a -> State SomeEnv a ... is there an easy way to fold over the list, carrying the state from previous calculations to the next one?
04:20:15 <danilo2> Hello! :) Could anybody look at this 4 lines code and tell me why it does not compile? I thought existentials like this should compile fine :( (104785)
04:20:20 <danilo2> http://lpaste.net/104785
04:21:28 <darthdeus> danilo2: i dont think they work this way as you have to return the same type from each call, but i'm noob
04:21:59 <lunaris> Hi all; suppose I have a GADT: data E a where { V :: a -> E a; A :: Num a => E a -> E a -> E a; C :: E Bool -> E a -> E a -> E a }
04:22:04 <danilo2> darthdeus: They should. Existentials tells that I can return any type of some typeclass
04:22:10 <lunaris> I can make it "two-level", as in:
04:22:35 <lunaris> data E f a where { V :: a -> E a; A :: Num a => f a -> f a -> E f a; C :: f Bool -> f a -> f a -> E f a }
04:22:36 <Saizan> danilo2: you need to quantify inside Map
04:22:37 <darthdeus> danilo2: i thought that they work that if you have two "a"s in the signature, they can be different type, but not that you can return two different types from a function
04:22:41 <lunaris> And close it with Mu.
04:22:57 <lunaris> However, is (E f) a Functor in any sense? Does it make sense to want to make it one?
04:23:30 <lunaris> I'm especially confused as to whether fmap g (C p t f) should touch the tree beneath "p" (the predicate, of type f Bool).
04:24:25 <Saizan> lunaris: it shouldn't, but i think it's still not going to be functor because of the Num a => in A
04:24:33 <danilo2> Saizan: Hmm quantifing inside map gives us Impredictive types, but making Channel existential works - see the annotation (http://lpaste.net/104785) . I'm wondering why the original does not work though
04:24:57 <lunaris> Saizan: yes; that's the next problem, which I was exploring with e.g. Coyoneda.
04:25:20 <lunaris> I guess I'm now wondering whether E is in some sense a functor.
04:25:45 <hayashi> Is there any way to use Unicode blackboard bold symbols in function names?
04:25:45 <lunaris> And whether it's even correct to think of one.
04:26:21 <hayashi> Whoops.  There is.  I just need to use a lowercase letter prefix!
04:28:26 <hayashi> …and now I get a lexical error, woo
04:29:31 <Saizan> lunaris: it is, but not Hask -> Hask
04:30:26 <Saizan> danilo2: think of the difference between "exists a. [a]" and "[exists a. a]"
04:31:26 <lunaris> Saizan: Yes, I did wonder. That said, even outside of Hask, would one traverse into an E Bool looking for E a's? (Assuming one holds an f :: a -> b to fmap).
04:31:35 <lunaris> Though perhaps, given that we're outside of Hask, that is a stupid question.
04:31:35 <Saizan> danilo2: in the first case you pick an 'a' and then provide a list with 'a' elements, in the second case you get to specify a different 'a' for each element
04:33:51 <Saizan> lunaris: that depends on which functor you want to define, i suppose, but it'd seem more natural not to
04:35:40 <lunaris> Hm.
04:36:06 <lunaris> Well, assuming that, I can map over it using Coyoneda.
04:36:06 <matematikaadit> Correct me if I'm wrong. In the Haskell history, Monad was first introduced as the interface to IO right?
04:36:42 <lunaris> And lower out of Coyoneda at the end by demanding Num a => Coyoneda (E f) a -> E f a.
04:37:02 <lunaris> That's unsatisfactory though, as I potentially have to provide the constraints of every constructor in order to lower.
04:39:22 * hackagebot JsonGrammar 0.3.5 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3.5 (MartijnVanSteenbergen)
04:58:03 <efg> What's a monad?
05:00:43 <matematikaadit> well, I'm no expert in this stuff, but maybe I could guide you efg.
05:00:47 <Maior> efg: it's a typeclass with two functions, >>= and return
05:01:16 <Maior> (Eq is a typeclass with two functions, == and /=; it also turns up a lot0
05:01:57 <matematikaadit> efg: from history point of view, it was started as the interface for IO.
05:02:10 <efg> i get Eq, so a monad you say is just a type with two functions
05:02:21 <efg> so i now know and understand monaids?
05:02:36 <efg> monads*
05:02:41 <matematikaadit> efg: yes. that's right.
05:02:47 <efg> no
05:02:53 <orzo> well, there's also fail
05:03:59 <Maior> @src Monad
05:04:00 <lambdabot> class  Monad m  where
05:04:00 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:04:00 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:04:00 <lambdabot>     return      :: a -> m a
05:04:00 <lambdabot>     fail        :: String -> m a
05:04:05 <Maior> my bad sorry
05:04:09 <Maior> off-by-two error
05:04:12 <orzo> heh
05:04:16 <fizruk> fail belongs elsewhere
05:04:19 <efg> so there's fail
05:04:25 <efg> much like your explanation
05:04:26 <sipa> efg: if someone tells you the syntax and semantic rules of say C, does that mean you know how to use it to write useful programs?
05:04:31 <fizruk> it’s in Monad for historical reasons
05:04:32 <efg> yes
05:05:14 <orzo> maybe monad is better understood via fmap/join
05:05:24 <efg> try
05:05:30 <orzo> do you understand Functor?
05:05:31 <fizruk> monad is better understood via tons of examples
05:05:37 <sipa> efg: likewise, explanaing what a monad is is hardly useful (it's necessary at some point), but there is nothing special to it, once you've seen how to apply it in practice
05:05:49 <efg> so you don't know
05:05:58 <matematikaadit> efg: one nice things about Monad class is using only (>>=) and return we can build up a lot of nice general combinators for programming using monads.
05:06:19 <orzo> i'm willin to try to explain monad, but you have to answer, do you understand Functor?
05:06:27 <efg> orzo: yes
05:06:46 <orzo> okay, do you understand Applicative?
05:07:29 <fizruk> efg: which functors are you familiar with?
05:08:56 <efg> fizruk: there's more than one?
05:09:13 <efg> i know the fmap kind
05:09:17 <fizruk> efg: i mean instances
05:09:23 <fizruk> efg: Identity, Const, Maybe, Either, Reader, Writer, State, Cont, etc.
05:09:40 <efg> almost none, i'm totally new to haskell
05:10:09 <BoR0> what are Identity and Const?
05:10:09 <fizruk> okay, then you probably don’t understand Functor :p
05:10:20 <efg> i do
05:10:21 <fizruk> data Identity a = Identity a
05:10:31 <fizruk> data Const a b = Const a
05:11:02 <BoR0> I get Identity, but what's the usefulness of Const?
05:11:14 <fizruk> BoR0: what’s the use for id and const?
05:11:43 <BoR0> dunno :)
05:12:00 <efg> orzo: applicative? no
05:12:20 <pavonia> I think with Const you can make things a monad that have the wrong kind for it
05:14:01 <matematikaadit> @src Functor
05:14:01 <lambdabot> class  Functor f  where
05:14:02 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
05:14:54 <orzo> efg: applicative is a generalization of functor, it adds two extra operations, the first of which converts a value into a functored version.  For Applicative f, there exists pure :: a -> f a.  Monad is a generalization of Applicative, but Monad calls this operation return :: a -> f a
05:15:32 <alpounet> BoR0: it tends to prove useful when you have a function that's generic over a type that must be an instance of Applicative. turns out passing Const makes that function behave in some way that can be useful and meaningful. for instance in 'lens' it's what describes getters
05:15:41 <orzo> hm, maybe i shouldn't say "generalization", it's more a specialization since applicatives are a subset of functors
05:16:22 <orzo> efg: so are you cool with pure/return ?
05:16:27 <efg> no
05:16:36 <orzo> are you familiar with Maybe?
05:16:45 <edwardk> Const is what you us to implement foldMap in terms of traverse for instance.
05:16:54 <deni> is there a way to make cabal repl load a module? currently i open the repl and the do :l Module....wondering if there is a better way
05:16:54 <edwardk> Identity is what you use to implement fmap in terms of traverse
05:16:58 <efg> orzo: i know how to use maybe, not how it works
05:17:24 <orzo> you know there is a function Just :: a -> Maybe a
05:17:30 <mirpa> deni: you can use "import ..."
05:17:41 <Maior> orzo: itym just
05:17:45 <Maior> oh
05:17:49 <Maior> you don't, my bad, sorry
05:18:47 <orzo> since Maybe is an Applicative and Monad, you could use the following are all the same value:  Just 3 == pure 3 == return 3
05:19:40 <BoR0> > fmap (+1) $ Just 2
05:19:42 <lambdabot>  Just 3
05:19:52 <BoR0> does this also make it a Functor?
05:20:02 <efg> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
05:20:12 <efg> a few here are suffering that
05:21:34 <deni> mirpa: yeah but i still need to do that "in the repl" ... i want repl to somehow automatically load a context
05:21:47 <orzo> well i'm willing to explain a perfectly simple abstraction that shouldnt require more than 2 or 3 examples, but i'm not willing to dig up a million examples and wait for you to notice the pattern, so you're on your own.
05:22:21 <Andris_zbx> efg: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:24:19 <lunaris> I think sigfpe's introduction to monads is quite nice: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
05:26:54 <mirpa> deni: It seems that you can run 'cabal repl' and then do ':l init.hs' where init.hs will import modules that you want
05:27:49 <eliasdiem> matematikaadit: thanks, it's a little clearer now
05:30:51 <efg> @src Maybe
05:30:52 <lambdabot> data Maybe a = Nothing | Just a
05:31:16 <efg> maybe, just maybe, i'm getting closer
05:32:21 <matematikaadit> eliasdiem: your welcome.
05:33:10 <efg> is there a real difference between calling and applying a function? or just terminology?
05:34:18 <alpounet> no, and I think the main term is just "evaluation"
05:34:37 <mirpa> alpounet: what about "reduction"?
05:34:43 <hyPiRion> not within haskell context, but lisps use apply to refer to the apply function
05:35:09 <alpounet> mirpa: that's the more "theoretical" one, so to speak
05:35:33 <efg> so you don't call functions in haskell?
05:35:40 <efg> you evaluate them, possibly lazy?
05:36:08 <tdammers> kind of a mindset thing
05:36:10 <fizruk> :t evaluate
05:36:11 <lambdabot> a -> IO a
05:37:41 <mirpa> efg: Why do you need to know that? Many people will imagine different things anyway.
05:37:45 <hyPiRion> efg: isn't that exactly the same as calling them, lazily?
05:38:06 <efg> mirpa: why do you need to know why i need to know? it's a perfectly reasonable question
05:38:21 <efg> hyPiRion: i don't know - is it?
05:38:37 <alpounet> efg: maybe this can help you understand what is going on when you run haskell code http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html
05:38:50 <efg> just maybe
05:38:56 <mirpa> efg: You might be wasting your time by trying to understand something that someone else is using in confusing way...
05:38:57 * efg giggles hard
05:40:10 <efg> anyhoo, busy reading https://www.fpcomplete.com/school/advanced-haskell/functors-applicative-functors-and-monads - first article to make sense to me on this topic
05:40:12 <efg> finally...
05:41:23 <matematikaadit> efg: glad that you finally found your Path to Monad Satori
05:41:30 <matematikaadit> ;)
05:42:14 <mhd> @efg We welcome you to the monadic brotherhood
05:42:14 <lambdabot> Maybe you meant: msg bug bf
05:42:32 <deni> mirpa: yeah that's what i've been doing. but was wondering is there is a way to tell cabal (via a config file or cli param?) what to load, with one command.
05:42:38 <efg> mhd, yes the important thing about understanding monads to be able to brag about understanding monads
05:43:03 <mhd> yep
05:43:03 <ab9rf> heh
05:43:22 <ab9rf> i use monads, but don't claim to understand them :)
05:43:34 <mhd> trick is to write one
05:43:37 <mhd> afaict
05:43:48 <ab9rf> not that much so
05:43:50 <mhd> or twelve
05:44:00 <matematikaadit> [19:41:08] <mhd> @efg We welcome you to the monadic brotherhood, <--- someone need to quote this ;)
05:44:23 <mhd> matematikaadit, not to mention the "being able to brag" part
05:44:36 <matematikaadit> lol
05:44:42 <efg> the trick to me was understanding 1) applicatives, 2) that with monads i have a choice in what to apply
05:44:47 <benzrf> monads: they are kind of like bananas
05:44:49 <efg> fucking simple
05:44:57 <benzrf> efg: :-)
05:45:20 <efg> you guys could've just said that :-D
05:45:31 <efg> i guess it's a brotherhood thang
05:45:34 <benzrf> efg: no
05:45:37 <benzrf> hold on m8
05:45:41 <mhd> The important part about understanding monads is being able to compare them to commonplace objects in nonsensical analogies
05:45:54 <benzrf> @where monad tutorial fallacy
05:45:54 <lambdabot> I know nothing about monad.
05:45:58 <benzrf> efg: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
05:46:01 <benzrf> @learn
05:46:01 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
05:46:03 <benzrf> hmm
05:46:06 <benzrf> @teach
05:46:06 <efg> benzrf: yup, read that
05:46:06 <lambdabot> Unknown command, try @list
05:47:51 <mirpa> deni: It might be possible with ghc.conf (ghci) but I don't know how to make it work with 'cabal repl'
05:47:52 <benzrf> efg: then ysk that if we'd just said that in the first place you mightve still had trouble with it
05:48:15 <mhd> Your understanding of monads are like pineapples in that both are only safe when ripe and ready.
05:48:26 <mhd> safe to use, that is
05:48:27 <benzrf> @quote mhd
05:48:27 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
05:48:34 <efg> well, turns out the correct answer to "what is a monad?" is "read this bro' : anyway, when the next knucklehead comes along, i think the best advice is to link to https://www.fpcomplete.com/school/advanced-haskell/functors-applicative-functors-and-monads"
05:49:20 <efg> gobble gobble
05:49:52 <ab9rf> mhd: depends on how yo intend to use the pineapple :)
05:50:05 <benzrf> efg: trust me, it may be of less hepl to them than you think
05:50:07 <benzrf> ;)
05:50:17 <efg> trust me, you're wrong
05:50:28 <mhd> ab9rf: I cannot in good conscience recommend shoving them up your arse
05:50:58 <srhb> efg: This is an issue that comes up repeatedly, and we've been dealing with it for a very long time. I think most agree that "You could have invented monads" and Typeclassopedia are the best answers.
05:51:27 <efg> i think that link is the answer. I read most "tutorials" but that one basically nails it in the correct sequence of steps.
05:51:28 <srhb> As in, if you try to condense the article you just linked to answer "what is a monad" 10 people will be able to show you that that's not the case.
05:51:33 <efg> anyhoo, back to coding
05:51:39 <srhb> But glad that it worked for you. :)
05:52:00 <mhd> What happened to Category Extras?
05:52:16 <ab9rf> i personally found typeclassopedia to be most useful in dismissing the "monad mystique" for me
05:52:40 <alpounet> mhd: it's been split up in many, more reasonably sized packages
05:52:52 <matematikaadit> efg: now you can use monad in your code and brag about it :)
05:52:53 <BoR0> what's data Test a b = Test (a -> b) represent?
05:52:55 <fizruk> mhd: see https://hackage.haskell.org/package/category-extras
05:53:16 <fizruk> BoR0: a function?
05:53:22 <efg> matematikaadit: if i understand correctly, the next logical step is to write a tutorial
05:53:29 * efg giggles so hard he farts
05:53:34 <mhd> Monads are like feelings
05:53:44 <mhd> They are ephemeral and hard to explain sometimes
05:53:45 <ab9rf> nothing more than feelings?
05:54:00 <matematikaadit> lol
05:54:03 <fizruk> https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/the-tao-of-monad
05:54:28 <deni> mirpa: yeah me neither :(
05:54:28 <fizruk> The TAO (Monad) that can be told is not the eternal TAO (Monad).
05:55:56 <mirpa> mhd: I imagine them as something like network packets
05:56:17 <mhd> mirpa: feelings or monads?
05:56:51 <mirpa> mhd: last time I've tried to imagine feelings I got stuck
05:57:03 <mhd> I take a vector-space approach
05:57:25 <mhd> and a feeling-state being like scalar field over this vector space
05:57:35 <mhd> or something
05:57:39 <mhd> fuzzy blotches
05:57:45 <mhd> many dimensions
05:57:51 <mhd> anyway
05:58:22 <efg> monads are like feelings? that may explain why all my narcissistic psychopath friends struggle with them too
05:58:32 <mirpa> perhaps there is some hope for feeling after all...
05:59:15 <efg> monads are like sex for nerds. maybe something, but most likely nothing.
05:59:21 * ReinH sighs
05:59:29 <fizruk> monads are as hard/simple as any abstraction, these just have a fancy name
06:00:04 <mirpa> as most things in math
06:00:08 <matematikaadit> monadic action is scary: "This monadic action, when given the Universe as input, produces a new modified Universe. We continue living in this new Universe"
06:00:30 <efg> many worlds interpretation
06:00:43 <hodapp> but what happens to the old universe :(
06:00:47 <ReinH> This is my favorite monad tutorial http://dinhe.net/~aredridel/.notmine/PDFs/Monads%20for%20functional%20programming.pdf
06:00:49 <efg> it's still there
06:01:01 <matematikaadit> hodapp: they are garbage collected ;)
06:01:19 <benzrf> hodapp: eaten by langoliers!
06:01:26 <fizruk> and to understand any abstraction you need tons of examples and little mind adjustment
06:03:04 <danilo2> Saizan: Thank you! :)
06:03:12 <mhd> the old universe is subjectto Mangle Worlds destruction
06:04:43 <warpy> <lambdabot> I know nothing about monad.
06:05:07 <matematikaadit> "So the Universe we are living in is being constantly modified by Haskell programs. That's why being a Haskell programmer feels like being the Master of the Universe."
06:15:41 <hayashi> I'm having a brainfart today.  How do I express the equivalent of a <$> b <*> c when a is actually returning the same Monad as b and c?
06:15:46 <hayashi> I guess it's some sort of =<<
06:15:56 <hayashi> but I can't wrap my head around which D=
06:16:04 <Saizan> add a join
06:16:15 <Saizan> join $ a <$> b <*> c
06:16:15 <benzrf> hayashi: types?
06:16:31 <benzrf> as in
06:16:42 <hayashi> benzrf: b and c are Maybe x, a is x -> x -> Maybe x
06:16:53 <benzrf> Saizan++
06:17:51 <hayashi> ta
06:18:18 <benzrf> hayashi: or you could do something like
06:18:38 <BoR0> can anyone explain me (with an example please) how and why is data Test a b = A (a -> b) useful? it creates a function A :: (a -> b) -> Test a b, but what do I do with this function?
06:18:40 <benzrf> oh wait
06:18:42 <benzrf> nvm
06:19:15 <benzrf> BoR0: it is useful if you need to define a typeclass instance for functions besides the default
06:20:33 <BoR0> can you show a very simple example of doing that?
06:20:59 <BoR0> it doesn't necesarrily have to be a -> b, but I'd like to see at least one arrow within data
06:21:21 <alpounet> ocharles: are you around?
06:23:26 <ocharles> hey alpounet, what's up?
06:24:42 <BoR0> benzrf, basically this will allow me to pattern match on functions?
06:24:46 <benzrf> no
06:25:00 <benzrf> BoR0: newtype State s a = State (s -> (a, s))
06:25:20 <alpounet> ocharles: I think I saw at some point that you were working on a haskell language extension for pg, so 1/ am I remembering correctly? 2/ if I am, what's the status?
06:25:41 <benzrf> instance Functor (State s) where fmap f (State s) = State (first f . s)
06:25:48 <ocharles> alpounet: 1. you are correct, 2. it hasn't seen any attention recently
06:25:52 <ocharles> Code is on Github:
06:25:58 <ocharles> https://github.com/ocharles/plhaskell
06:26:13 <alpounet> ah cool
06:26:20 <benzrf> what's plhaskell
06:26:30 <ocharles> alpounet: You can do basic things like "CREATE FUNCTION add(int, int) RETURNS int $$ \x y -> x + y $$ LANGUAGE plhaskell;
06:26:32 <ocharles> or whatever the syntax is
06:26:44 <ocharles> I think it only knows how to work with int8, text and bool types
06:26:50 <alpounet> hah fun
06:26:56 <ocharles> oh, int, float4 and float8
06:29:08 <alpounet> ocharles: i'll take a closer look. I remembered about that while staring at hundreds of lines of plpgsql :p
06:29:14 <ocharles> :D
06:32:31 <Pythonfant> How do I debug a failing patttern match (non-exhaustive pattern)? I would like to print out the value that failed to match
06:33:09 <Iceland_jack> Pythonfant: If you know the function then it's easy to do
06:33:09 <Iceland_jack>     function fallthrough = show fallthrough
06:34:20 <benzrf> god damn i suck at nethack
06:34:30 <benzrf> :t fallthrough
06:34:31 <lambdabot> Not in scope: ‘fallthrough’
06:34:38 <benzrf> oh right
06:34:41 <Pythonfant> Iceland_jack: Hm if I add this it doesn't compile because apparently I now have multiple declarations
06:34:48 <Pythonfant> benzrf: it's just a variable?
06:35:12 <Iceland_jack> It's just a variable, like 'a' in
06:35:12 <Iceland_jack>     id a = a
06:35:16 <benzrf> yeah =p
06:35:38 <Iceland_jack> Pythonfant: Add it after your current definition
06:35:47 <Pythonfant> Iceland_jack: that's what I did
06:35:56 <danilo2> Hello! Is there in Haskell any way to create a datatype X, which has got (Map String (Channel a)), where a is Int or Float using existential datatypes? I want then to be able to add such Channels together. (Using forall a. Num a => ...) does not work, because we are nto able to define 'sum' operation with such existentials
06:37:02 <benzrf> danilo2: why not have 'X a'
06:37:08 <benzrf> then 'Num a => X a'
06:37:12 <Pythonfant> Iceland_jack: I guess it doesn't fail where ghci tells me it does. I'm pretty sure there can't be a pattrn match
06:37:25 <Iceland_jack> Pythonfant: if the code is short enough you can paste it to lpaste
06:37:27 <Iceland_jack> @where lpaste
06:37:28 <lambdabot> http://lpaste.net/new/haskell
06:38:00 <Pythonfant> Iceland_jack: http://lpaste.net/104794 It fails in replaceListBody
06:38:16 <Pythonfant> the last pattern should always match
06:38:24 <Pythonfant> at least if I understood lists correctly
06:38:24 <Iceland_jack> (an example of the error wouldn't hurt either) :)
06:38:28 <danilo2> benzrf: If you have existential "forall a. Num a => X a" you cannot write something like "sum (X a) (X b) = X (a+b)" and you have to use existentials if you want to put everything into( Map String ... )
06:38:33 <benzrf> i want a declarative debugger for haskell
06:38:39 * benzrf whines
06:38:48 <Iceland_jack> Pythonfant: it's the "a"
06:38:57 <danilo2> benzrf: Of course I can use several constructors and its done - I'm just aksing about other ways to accomplish the task
06:39:08 <Iceland_jack> (Element "a" attr body), something like 'Element "b" attr body' will fall through
06:39:08 <Pythonfant> Iceland_jack: Ah it doesn't go to the last expression in this case?
06:39:12 <benzrf> danilo2: i mean parameterize X
06:39:41 <Iceland_jack> oh yes it would
06:39:57 <Iceland_jack> Pythonfant: can you add the error you get to the paste?
06:40:09 <benzrf> ok u kno what i want
06:40:23 <benzrf> i want a graphical navigable declarative debugger edtsech
06:40:25 <benzrf> *EDT
06:40:36 <Pythonfant> Iceland_jack: updated
06:40:46 <benzrf> i should make this p:
06:41:04 <benzrf> is there an api for doing haskell evaluation and manipulating data trees
06:41:08 <benzrf> and like
06:41:13 <benzrf> saying 'reduce this node'
06:41:21 <danilo2> benzrf: Because I want to create datatype Test = Test (Map String (X a)) for different a's inside one Test
06:41:29 <benzrf> danilo2: gl then m8
06:41:43 <benzrf> why not use Num a? how does that preclude sum?
06:41:49 <Pythonfant> The error occurs when running parse feeditem "" x with x being http://sprunge.us/dHLR
06:41:53 <benzrf> because the Nums can be different instances?
06:41:56 <danilo2> benzrf: excuse me? :)
06:42:06 <benzrf> @hoogle (Num a, Num b) => a -> b -> b
06:42:09 <lambdabot> Prelude (*) :: Num a => a -> a -> a
06:42:09 <lambdabot> Prelude (+) :: Num a => a -> a -> a
06:42:09 <lambdabot> Prelude (-) :: Num a => a -> a -> a
06:42:12 <benzrf> hmm
06:42:29 <benzrf> :t toInteger
06:42:30 <lambdabot> Integral a => a -> Integer
06:42:44 <benzrf> :t toFloat
06:42:45 <lambdabot> Not in scope: ‘toFloat’
06:42:54 <benzrf> :t fromFractional
06:42:55 <lambdabot>     Not in scope: ‘fromFractional’
06:42:55 <lambdabot>     Perhaps you meant ‘fromRational’ (imported from Prelude)
06:42:55 <danilo2> :t fromIntegral
06:42:56 <lambdabot> (Num b, Integral a) => a -> b
06:43:13 <benzrf> danilo2: the point is
06:43:33 <benzrf> use conversion funcs to define an addition function that can take disparate types
06:43:51 <benzrf> then use that instead of + with a Num a constraint on the rhs of the data decl
06:44:01 <benzrf> sounds workable to me p:
06:44:10 <benzrf> or maybe an Integral a, idk
06:44:20 <benzrf> danilo2: why do you need polymorphism here anyway
06:45:18 <danilo2> benzrf: It will work if I use conversion function there, but I do not think this is what I want to. If both are Int , I want to get Int as a resultm,  if both are Float, float as a result etc
06:45:43 <danilo2> benzrf: But agian - it is doable using datatpyes with many constructors but is not as extendible
06:45:44 <benzrf> danilo2: parameterize X
06:45:52 <emmettemmett> What would the following strictness annotation accomplish? Just the first cons? "data StrictList a = StrictList ![a]"
06:46:18 <benzrf> danilo2: data X a = (Map String (Channel  a))
06:46:26 <benzrf> emmettemmett: afaik
06:46:35 <benzrf> i believe bang patterns work up to WHNF
06:47:26 <emmettemmett> benzrf: That's what I think, too.. good to hear you think so, too; thanks!
06:48:42 <tristanStrange> so..... what's the easiest way of defining a record with a Date in it?
06:49:11 <danilo2> benzrf: then the map could only handle Channels with one type - I wanted to handle both Flaots and Ints in one map
06:49:12 <darthdeus> guys, if i have [a] and a function that's  a -> State SomeEnv a ... is there an easy way to fold over the list, carrying the state from previous calculations to the next one?
06:49:38 * hackagebot full-text-search 0.2.1.1 - In-memory full text search engine  http://hackage.haskell.org/package/full-text-search-0.2.1.1 (DuncanCoutts)
06:49:46 <benj_> tristanStrange, like "summer of 69"?
06:50:06 <benzrf> danilo2: you cannot do that anyway
06:50:25 <benzrf> danilo2: if you say data X = forall a. Num a => (Map String (Channel  a))
06:50:36 <benzrf> danilo2: that just means a value of type X can have any a there
06:50:45 <benzrf> but individual values *will* have a specific value
06:50:49 <benzrf> for a
06:51:33 <emmettemmett> darthdeus: would "forM :: Monad m => [a] -> (a -> m b) -> m [b]" work?
06:51:33 <tristanStrange> benj_ sadly nothing so nice.... I'm writing a little toDo list (yes yet another one)
06:51:44 <c_wraith> darthdeus: I think Data.Foldable has some functions for you
06:51:46 <tristanStrange> and I need a Due and Created date
06:52:32 <danilo2> benzrf: Ok, thank you. I think this way is wrong way to search the solution - anyway thnaks! :)
06:52:56 <tristanStrange> ah Data.Date
06:53:15 <tristanStrange> but how do i create  a new one?
06:53:42 <tristanStrange> erm Data.Time
06:54:04 * darthdeus is confused by the amount of monadic thignies
06:55:01 <darthdeus> why do i get GHC.Prim.Any as a type when I inspect my code?
06:55:08 <c_wraith> monomorphism restriction
06:56:08 <halvorg> type Position a = Integral a => (a, a)
06:56:14 <halvorg> that ain't legal, can I do something similar?
06:56:30 <Pythonfant> Iceland_jack: turns out I was simply too stupid to write replaceListBody instead of replaceListbody
07:01:16 <benzrf> hey sohum
07:01:17 <benzrf> *so
07:01:29 <benzrf> does ghc have an api for working with haskell expression trees
07:01:43 <benzrf> i.e. you get a tree value that can be inspected that corresponds to an expression
07:01:52 <benzrf> then you can selectively reduce it or control eval
07:02:43 <emmettemmett> haskell-src package contains Language.Haskell.Parser
07:03:05 <c_wraith> halvorg: no, you can't.  The reason is to make code clearer.  If there's a constraint on a type variable, it should be obvious, not buried in a type synonym
07:03:29 <halvorg> Very well
07:04:26 <benzrf> emmettemmett: does that support evaluation though
07:04:58 <emmettemmett> benzrf: Ahh.. no I don't think so sorry
07:05:11 <c_wraith> benzrf: there's nothing that does that..  The ghc api is too monolithic.
07:06:14 <darthdeus> what's an easy way to filter out items that match/dont match a certain pattern from a list?
07:06:18 <benzrf> =[
07:06:31 <benzrf> c_wraith: this is a disappointment
07:06:32 <benzrf> +_+
07:06:54 <benzrf> cabal: Error: some packages failed to install:
07:06:54 <benzrf> haskell-src-1.0.1.6 failed during the building phase. The exception was:
07:06:55 <benzrf> ExitFailure 9
07:06:57 <benzrf> u wot
07:07:14 <c_wraith> I'd recommend haskell-src-exts instead
07:07:29 <c_wraith> It handles more of what GHC can, and it's usually kept more up-to-date
07:07:39 <benzrf> kk
07:07:43 <ocharles> darthdeus: filter?
07:07:48 <ocharles> darthdeus: as in, filter from Prelude
07:08:07 <darthdeus> ocharles: yeah but how to filter? i don't want to write something like   filter (\x -> case x of Foo -> False; _ -> True) :\
07:08:10 <darthdeus> thought there would be a nicer way
07:08:12 <benzrf> darthdeus: list comp
07:08:15 <benzrf> iirc
07:08:28 <ocharles> darthdeus: you haven't really given a clear example of how you want to filter
07:08:31 <ocharles> I suppose that's the problem
07:08:44 <ocharles> Haskell can't magically guess your predicate
07:09:00 <darthdeus> data Foo = A | B;   items = [A,B,A,B];  filter (\x -> case x of A -> False; B -> True) items
07:09:05 <darthdeus> this is what I'm trying to do
07:09:32 <halvorg> filter (==B)
07:09:35 <benzrf> cabal: Error: some packages failed to install:
07:09:35 <benzrf> haskell-src-exts-1.15.0.1 failed during the building phase. The exception was:
07:09:35 <benzrf> ExitFailure 9
07:09:39 <benzrf> =_=
07:09:40 <darthdeus> oh lol
07:09:49 <darthdeus> halvorg: that's brilliant :P thanks
07:09:51 <halvorg> :D
07:09:54 <darthdeus> didn't realize it would work that way
07:18:55 <eacameron> can someone explain why Scala has taken off so much more quickly than Haskell?
07:19:29 <benzrf> eacameron: it looks friendlier and works with java
07:19:32 <benzrf> is my guess
07:20:02 <eacameron> what does "looks friendlier" mean?
07:20:09 <benzrf> more like C
07:20:11 <ciaranm> has semicolons
07:20:15 <eacameron> hahaha
07:20:43 <eacameron> if only we knew before that the secret to success was semicolons
07:20:51 <benzrf> haskell has semi colons
07:21:04 * eacameron corrects himself
07:21:12 <eacameron> if only we knew before that the secret to success was required semicolons
07:26:20 <benzrf> haskell-src-exts-1.15.0.1 failed during the building phase. The exception was:
07:26:20 <benzrf> ExitFailure 9
07:26:23 <benzrf> >:{
07:26:54 <benzrf> trying -v
07:28:16 <luite> benzrf: oh!
07:28:26 <luite> benzrf: is that with ghc 7.8.2?
07:28:58 <benzrf> nope
07:29:01 <benzrf> The Glorious Glasgow Haskell Compilation System, version 7.4.2
07:29:33 <luite> oh wait signal 9 is sigkill, i'd guess out of memory error, are you building on a smallish vm?
07:30:43 <benzrf> luite: it's ExitFailure 9
07:30:46 <benzrf> and yes i am
07:30:58 <benzrf> 512MB
07:31:47 <luite> benzrf: yeah your compiler gets killed by the OOM killer
07:32:12 <benzrf> >tfw
07:32:18 <benzrf> luite: how do i fix this?
07:32:28 <luite> switching to a bigger machine
07:32:32 <benzrf> ;-;
07:32:38 <benzrf> but im stuck on a craptop
07:32:41 <benzrf> a chromebook, even
07:32:45 <benzrf> it's ARM so it doesnt support ghci
07:32:53 <luite> haskell-src-exts has some huge modules
07:32:56 <tdammers> got a server that you could ssh into?
07:33:00 <benzrf> >tfw when
07:33:03 <benzrf> tdammers: yes, this is it
07:33:03 <benzrf> =p
07:33:06 <tdammers> oy
07:33:07 <tdammers> hmm
07:33:14 <tdammers> I run some haskell apps on a low-spec server
07:33:23 <tdammers> I use a VM to build binaries for that
07:33:28 <tdammers> instead of building on the server itself
07:33:54 <luite> benzrf: enabling more swap might help, but for comfortable haskell dev i'd say you'd need at least 2GB RAM, 1GB might work if you are ok with lots of swapping
07:34:48 <tdammers> for comfortable haskell dev you also need an ssd and a fairly fast CPU :x
07:35:35 <hodapp> pfffft
07:35:40 <k0ral> Hello, how am I supposed to package a program that only works with GHC integer-simple ? How can I enforce this requirement at package installation ?
07:36:13 <zomg> tdammers: I have a cheap VPS on Linode and only problem with compile perf or anything I ever had was the amount of RAM on the box
07:37:13 <hodapp> I dumped my Linode VPS after they were hacked and someone got waaaaaaaay more information than he should have been able to.
07:38:53 <benzrf> >mfw haskell is worse at this than java
07:40:25 <napping> benzrf: what's that about?
07:40:31 <benzrf> memory
07:40:53 <napping> memory?
07:41:55 <ezrios> I am looking at this example for reactive-banana: https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana-wx/src/NetMonitor.hs
07:42:07 <ezrios> Where are the functions "sink" and "staticText" defined?
07:42:22 <ezrios> lines 24-25, 47-48
07:42:47 <napping> using less memory or what? I don't think Java is terribly good at that - all non-primitive fields become references and stuff
07:43:34 <benzrf> napping: using less
07:43:41 <benzrf> napping: haskell is even worse than java
07:43:43 <benzrf> apparently
07:44:35 <napping> I think they are pretty similar at the language/implementation level.
07:44:52 <napping> Things like C# that let you use value types and larger composite objects might do better
07:45:22 <napping> And I expect a JVM to do a better job garbage collecting arrays, I don't think GHC bothers too much
07:45:51 <napping> I mean tricks like card marking and stuff instead of just rescanning the whole array when you change a reference in an array of references
07:46:00 <napping> not that I'm terribly up to date on either
07:46:02 <sruz25> so I have (readArray edges (j,i) :: (Double,Double)) in middle of some expression, and ghc is saying "Expected type: IOArray (Int, Int) Double, Actual type: IOArray (Int, Int) (Double, Double)", I don't have any type declarations on the line. The error is pointing at the word "edges", which is of array of pairs of doubles. Any idea what's up with that?
07:47:48 <sruz25> could it be the function that uses this expression further? wouldn't then the error point somewhere else?
07:50:01 <tdammers> zomg: I have a repurposed Wyse ThinClient under my couch :D
07:52:04 <jnj> I am installing for example pandoc with non-default cabal options "library-profiling: True" and "shared: True" and getting a lot of "not found" on .dyn_hi during the installation step. I have .hi and .p_hi files but that's it.
07:52:06 <jnj> Any ideas?
07:54:46 * hackagebot htsn-common 0.0.2 - Display/logging facilities used by both htsn and htsn-import.  http://hackage.haskell.org/package/htsn-common-0.0.2 (MichaelOrlitzky)
07:56:40 <jnj> Oh, i have to update cabal to 1.18.. https://plus.google.com/u/0/115504368969270249241/posts/19fyYuT5C1i
08:01:58 <benzrf> what is a witness
08:02:04 <guymann> hi
08:02:49 <McManiaC> can anybody help me identifying what packages causes this? http://npaste.de/p/jV/
08:03:03 <vanila> hi
08:03:03 <McManiaC> i dont see why it wants to reinstall packages
08:03:32 <McManiaC> the cabal file: http://npaste.de/p/v7l/
08:04:22 <napping> McManiaC: the two things it wants to downgrade are mtl and transformers. One thing to try is adding a constraint (on the command line or in the cabal file) fixing those versions, and then see what it complains about
08:04:48 * hackagebot htsn 0.0.10 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.10 (MichaelOrlitzky)
08:05:09 <benzrf> hmmmmmm
08:05:36 <benzrf> i rlllllllllly want a lib for manipulating haskell expression trees
08:06:37 <napping> what have you tried?
08:07:02 <benzrf> napping: nothing
08:07:04 <benzrf> i know of none
08:07:18 <benzrf> well, i mean one that allows you to do reduction as well
08:07:19 <benzrf> o-o
08:07:48 <awestroke> benzrf: to what end?
08:08:29 <benzrf> developer tools
08:08:38 <benzrf> debugging, evaluation, etc
08:09:07 <jophish> Is there anything in the way of quasiquoting Haskell. The quasiquoter for a declaration would invoke GHC to compile the quoted haskell.
08:09:17 <benzrf> jophish: there's tempalte haskell
08:09:27 <benzrf> do you mean that kind of quasiquotation
08:10:22 <jophish> Yeah, I suppose I mean implementing TH with quasiquotation
08:10:37 <jophish> in a wishy washy kind of way
08:10:56 <jophish> The problem seems to be linking the generated .o file with the program with the qq in
08:11:36 <awestroke> benzrf: I have the impression you should be able to use GHC for that via ghc-mod
08:11:54 <benzrf> awestroke: it apparently doesnt support fine-grained eval
08:11:55 <benzrf> :\
08:12:05 <benzrf> i.e. taking partially-reduced graphs
08:12:08 <benzrf> reducing them fine-grainedly
08:12:10 <benzrf> inspecting
08:12:44 <benzrf> i wanna try making something that lets you use a GUI to browse an expression graph and manually control reduction
08:12:53 <benzrf> or even try implementing an actual declarative debugger
08:13:02 <awestroke> benzrf: I don't really understand what you mean, are you talking about haskell -> core reduction?
08:13:15 <benzrf> no, expression->expression reduction
08:14:45 <awestroke> benzrf: does ghc do that? It only desugars before converting to core, and then does simplification on core
08:14:49 * hackagebot hackport 0.4.1 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4.1 (SergeiTrofimovich)
08:15:03 <benzrf> awestroke: well, yeah
08:15:19 <benzrf> but doesnt it do graph-reduction when acting as an interpreter
08:15:21 <benzrf> like ghci
08:15:36 <benzrf> isnt there a shitty debugger in ghci that lets you view the graph
08:16:51 <awestroke> the only step that differs for GHCi from what I've read is that ghc produces haskell bytecode instead of native code and then loads the bytecode into ghci
08:17:22 <benzrf> eh
08:19:27 <luite> GHCJS is also going to get a cool debugger this summer :)
08:21:02 <benzrf> sweet
08:23:09 <luite> (at least if GSoC goes according to plan, showing the heap/stack visually, with stepping/tracing)
08:23:52 <alpounet> niiiice
08:24:17 <freezerburnv> luite: That sounds sweet.
08:24:50 * hackagebot htsn 0.0.11 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.11 (MichaelOrlitzky)
08:24:51 <benzrf> why no graph reduction api ;-;
08:25:11 <freezerburnv> luite: How stable/mature is GHCJS at this point? I’m about to start working on a web app, and I was considering using Elm instead of GHCJS for the UI, due to it seeming to be a bit more stable/debuggable/designed for dealing with web UIs
08:25:30 <benzrf> freezerburnv: there are optoins besides ghcjs yknow
08:25:35 <benzrf> *options
08:25:38 <benzrf> freezerburnv: fay, etc
08:26:40 <Arnob> Hi all
08:26:57 <freezerburnv> benzrf: I did a little research into what was available, but the general feeling I got was that most things which compile Haskell to Javascript either weren’t complete (in the sense that they don’t support everything in Haskell), or created huge amounts of data (in the order of megabytes) for the libraries to run what is compiled, etc.
08:27:06 <Arnob> I am having some issues with "version" mismatch of ghc/haskell platform
08:27:06 <freezerburnv> benzrf: I could be totally wrong, I didn’t do a ton of research
08:27:18 <freezerburnv> benzrf: Please feel free to correct me/point me in the right direction. I would appreciate it a lot :)
08:27:20 * benzrf shrugs
08:27:22 <Arnob> Ioriginally installed haskell through Homebrew on my mac
08:27:32 <benzrf> transpiling sucks and has always sucked
08:27:33 <benzrf> :(
08:27:33 <zomg> freezerburnv: that sounds about right
08:27:54 <zomg> Fay is not bad, it doesn't support every haskell feature but I think it's a reasonable compromise
08:28:03 <Arnob> on top of that, I installed haskell-platform using the installer for Mac OS X from the haskell-platform site
08:28:10 <zomg> Haste seems to have made a lot of steps forwards lately but haven't tried it myself
08:28:29 <Arnob> this morming I wanted to get a fresh start, because I was having issues with cabal
08:28:46 <Arnob> so I uninstalled haskell platform using the provided command
08:28:56 <HugoDaniel> what is transpiling ?
08:29:06 <Arnob> and nistalled ghc using hombrews "brew uninstall ghc" command
08:29:25 <Arnob> and then reinstalled a new copy of haskell-platform from the haskell platform website
08:29:45 <Arnob> however, when I try to run 'cabal install cabal-install' to get the newest version of cabl
08:29:49 <Arnob> I get the following error
08:30:02 <Arnob> haddock: internal error: /usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/settings: openFile: does not exist (No such file or directory)
08:30:08 <freezerburnv> zomg: Would you recommend using a particular transpiler over something such as Elm? (I haven’t used any of them, so I honestly don’t have much of an idea of anything. I’ve seen a couple things about Elm, such that it looks like Haskell and has what looks like a good debugger, but that’s about it)
08:30:15 <Arnob> I think for some reason, haddock is still looking at that old path...
08:30:28 <zomg> freezerburnv: I think it depends on what exactly you want from the language
08:30:45 <zomg> If you want Haskell then I think the options right now are Fay and Haste
08:30:46 <HugoDaniel> i dont like elm :|
08:30:57 <freezerburnv> HugoDaniel: Any particular reason?
08:30:57 <zomg> but if you don't mind a slightly different language, there are Elm and PureScript
08:31:12 <freezerburnv> zomg: Fair enough :)
08:31:33 <luite> freezerburnv: i'm pretty sure that GHCJS has compiled a lot more code than Elm, just because there is the whole of hackage that it can run as test code
08:31:53 <HugoDaniel> freezerburnv: yes, their runtime is pretty bad, it is easy to thrash the dom, they also seem to abuse setTimeout (which in most cases is synonym for bad design)
08:31:56 <HugoDaniel> the syntax is dense
08:32:01 <HugoDaniel> it is hard to read for complex problems
08:32:15 <HugoDaniel> most signals dont make much sense (like fps 25 ?)
08:32:18 <freezerburnv> HugoDaniel: Syntax is dense? In comparison to Haskell? I would be mightily impressed if they managed that
08:32:31 <HugoDaniel> it is, specially compared to haskell
08:32:36 <ReinH> What about Fay?
08:32:41 <HugoDaniel> fay is haskell
08:32:58 <HugoDaniel> freezerburnv: they manage to complexify even more the record syntax, and do lots of things on top of that
08:32:59 <ReinH> I know
08:33:20 <ReinH> He was asking for ways to do js with Haskell
08:33:30 <freezerburnv> luite: That’s fair enough. Do you know what the size of the compiled Javascript is at the end in general? I’d like to try and keep things lean, only up to a few megabytes preferably
08:34:11 <freezerburnv> HugoDaniel: Hm, interesting. Duly noted on all those issues.Thanks for letting me know. Might have to look around a bit more then
08:34:29 <ReinH> freezerburnv: give Fay a look too.
08:34:43 <HugoDaniel> well i only did a few animations with it though... try it yourself and find your conclusions :)
08:34:49 <HugoDaniel> it is a fun language after all
08:34:55 <zomg> Fay runtime is reasonably small and it works quite good in general
08:35:01 <zomg> It's just a bit of a pain to debug if things don't work =)
08:35:02 <freezerburnv> ReinH: If I remember correctly, Fay is one that produces a pretty small end script, right?
08:35:16 <ReinH> and it has better interop with js libraries
08:35:22 <luite> freezerburnv: a few megabytes should be doable for most things (before minification, GHCJS itself doesn't minify code or shorten names really). it's still on the big side compared to the others due to staying much closer to GHC
08:35:27 <HugoDaniel> yeah, fay runtime is very minimal, and you can talk fay <-> js very easily which is great if you want to mix it with montage or threejs
08:35:31 <HugoDaniel> or anyother js thing
08:35:42 <freezerburnv> HugoDaniel: Hah, will do. I’ll have to take a look at all the options to find one that works well for my use case, I guess
08:36:07 <ReinH> Also I just did an interview with the author for the Haskell cast which should come out next week.
08:36:16 <fread2283> @pl parseTypeRest var = spaces *> (parseArrow var <|> return var)
08:36:16 <lambdabot> parseTypeRest = (spaces *>) . liftM2 (<|>) parseArrow return
08:36:21 <Arnob> guys, any idea how to fix this?
08:36:22 <Arnob> haddock: internal error: /usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/settings: openFile: does not exist (No such file or directory)
08:36:59 <HugoDaniel> Arnob: nop, that probably has to do with your system configuration :s
08:37:50 <freezerburnv> HugoDaniel: Do you know how fay <-> js and GHCJS <-> js interop compares? I would definitely like easy interop, for other libraries, custom Javascript, etc.
08:38:02 <HugoDaniel> i never tried ghcjs
08:38:16 <HugoDaniel> im very happy with fay though...
08:38:18 <ReinH> Ghcjs doesn't really have interop
08:38:25 <luite> freezerburnv: the point of GHCJS is mostly to start by supporting 'Hackage Haskell' and being able to test the compiler against that and make sure that it can support 'haskellish' development tools, rather than going directly for production
08:38:41 <Arnob> yes... I think I have a tangle of ghc/haskell from hoebrew, and haskell-platform
08:38:44 <Arnob> plus cabal...
08:39:22 <luite> ghcjs has `foreign import javascript "$2.h$log($1);" :: JSString -> JSObject -> IO ()' for example
08:39:26 <freezerburnv> luite: Fair enough. I’ll probably end up using Fay or Elm then, or maybe even something else, depending on how I feel when trying to put some stuff together
08:39:51 * hackagebot hackport 0.4.2 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4.2 (SergeiTrofimovich)
08:40:42 <ReinH> luite: ok, it has ffi
08:40:43 <luite> and if you use `foreign import javascript interruptible' you can do more interesting things, like return a result from an AJAX callback, suspending the Haskell thread in the meantime
08:41:18 <freezerburnv> luite, HugoDaniel: Thanks for all the help/suggestions. Really helped clear things up for me and give me some definite things to target and look at
08:41:20 <ReinH> What does "the Haskell thread" mean in this context?
08:41:28 <luite> and you can then for example close the AJAX connection to the server by throwing an async exception to the thread waiting for the response
08:41:33 <freezerburnv> luite: Ah ha, it can talk to Javascript. That’s good
08:41:41 <zomg> What would make Fay really nice is if they managed to implement typeclasses or at least something to pretend you have typeclasses
08:41:48 <zomg> so you could use Cont for Ajax and such
08:41:59 <luite> sure JS interop is pretty much essential for something like this :)
08:42:00 <zomg> they do have that Cont demo already, but it's a bit clunky I think :P
08:42:13 <luite> ReinH: a forkIO thread
08:42:42 <luite> GHCJS does blocking IO in regular IO, no Cont, and exceptions work as in GHC
08:43:19 <fread2283> is there a easier way to write a >>= (\b -> f b <|> g b) ?
08:43:29 <ReinH> But... js runtimes are single threaded?
08:43:42 <luite> ReinH: the single threaded GHC runtime is also single threaded :)
08:43:50 <luite> it has green threads
08:44:01 <ReinH> Sure
08:44:12 <tdammers> most js runtimes aren't single threaded I think
08:44:16 <ReinH> which is basically an evented runtime
08:44:20 <tdammers> only the part that executes user code is
08:44:39 <tdammers> but stuff like async I/O may very well be using threads under the hood
08:44:48 <fread2283> but that part is single-threaded
08:44:52 <ReinH> it is rather funny that GHC's  least parallel runtime is equivalent to JavaScript's most parallel runtime ;)
08:45:19 <hodapp> ReinH: bah?
08:45:49 <fread2283> web wirkers are threads in js
08:45:52 <fread2283> *workers
08:46:10 <hodapp> does anyone use those>
08:46:17 <hodapp> I'd read about them but have yet to touch them
08:46:30 <hseg> Hi. I'm looking for the fusion law for foldl, but all I can find is that f (p x y) = q (f x) y => f (foldl p z v) = foldl q z v. However, this is too general in my case, since I need to use the fact that x is an image of foldl for the condition to hold. Is there a less general version that lets me make that assumption on x?
08:46:33 <awestroke> hodapp: it's for heavy computations, and those are quite rare
08:46:49 <awestroke> hodapp: I'd guess things like online photo editors use them for image processing
08:46:59 <hodapp> awestroke: Is it so much heavy computations as just being able to farm something off into another thread?
08:47:25 <hodapp> I guess it definitely makes sense for heavy computations though
08:47:31 <hodapp> if they absolutely HAVE to be done in the browser
08:47:52 <awestroke> hodapp: it's cheaper to do it in the browser, less server load
08:48:04 <benj_> mine bitcoins on your users' browsers
08:48:19 <awestroke> benj_: too slow :/
08:48:31 <Smilex> Is it possible to return a regular value from a function that has a do block?
08:48:37 <zomg> benj_: you know there's a thing for that already I think :p
08:48:37 <awestroke> you can't compete with ASICs even with a C++ GPU miner anymore
08:48:43 <tero-> awestroke: altcoins then :)
08:49:04 <[^__^]> Smilex: you mean pure value? no.
08:49:06 <hseg> Specific case that I have in mind is to fuse minimumBy (compare `on` (++[infty]) . subsequences, where infty is a value larger than all other values of its type, to foldl (\a x -> (++[x]) . takeWhile (<x) a) []
08:49:11 <hodapp> awestroke: I'm not saying "in the browser" vs. "in the server", I'm saying "in the browser" vs. "in the server, in some other software on the client, or not at all"
08:49:15 <Smilex> [^__^]: thanks
08:49:22 <silasm> :t do "hello world"
08:49:23 <lambdabot> [Char]
08:49:30 <silasm> Smilex: ^ kind of
08:49:30 <hseg> (And yes, I know the function I'm passing to foldl is fusible)
08:49:32 <hodapp> though I fully support NOT doing it in Flash
08:50:06 <benj_> yeah sorry I'm out of date, s/bitcoins/dogecoins/ or whatever, sry, etc
08:50:16 <awestroke> I wonder if in-browser dogecoin mining could be a viable monetization strategy...
08:50:16 <benj_> will keep my snark more up-to-date for you
08:50:38 <[^__^]> Smilex: if you consider list ([]), Maybe, and function as a regular value, then you can do it.
08:50:41 <ReinH> [^__^]: all values returned from a do block are pure values.
08:51:08 * [^__^] shouldn't said pure :D
08:52:21 <Smilex> silasm: http://hastebin.com/alamasohap.md <- Could I return 'value' directly, and not as a IO?
08:52:34 <ReinH> You must return an m a for some monad m
08:52:43 <ReinH> Smilex: no
08:52:44 <albeit> I want to make a list of max two items [foo, bar]. But foo should only be in it if condA==True, and bar should only be in it if condB==True. How can I do that?
08:52:51 <Smilex> ReinH: Ok thanks
08:53:04 <Smilex> Also, what is a good online paste for Haskell?
08:53:12 <silasm> Smilex: with IO, not without unsafeperformIO (which you shouldn't use)
08:53:12 <silasm> Smilex: the example I gave is a dumb one that takes advantage of how 'do' works, ala
08:53:14 <silasm> :t do 1
08:53:15 <lambdabot> Num a => a
08:53:19 <ReinH> Smilex: lpaste
08:53:20 <[^__^]> Smilex: lpaste
08:53:20 <sipa> lpaste?
08:53:32 <Smilex> Awesome. Thanks
08:53:38 <fread2282> Smilex: you really don't need that do block though
08:53:41 <geekosaur> @paste
08:53:41 <lambdabot> Haskell pastebin: http://lpaste.net/
08:53:43 <[^__^]> http://lpaste.net/new/haskell
08:53:44 <[^__^]> see /TOPIC
08:54:29 <luite> ReinH: i guess i should talk about GHCJS more. this `foreign import javascript' thing was one of the three main reasons for waiting for GHC 7.8 for GHCJS (a patch adding support for it was merged last year September. the other reasons are that GHC 7.6 cross compilation support is very lacking, and that we also needed some patches to hook into the compilation pipeline with our codegen and to run template haskell)
08:54:44 <Smilex> fread2282: But withCAString returns an IO value
08:54:54 * hackagebot async-manager 0.1.0.0 - A thread manager for async  http://hackage.haskell.org/package/async-manager-0.1.0.0 (JonathanFischoff)
08:54:56 <fread2282> Smilex: you don't need to use do to use IO
08:54:58 <ReinH> luite: wanna come on the Haskell cast and talk about it?
08:55:30 <fread2282> Smilex: you can just do action_value engine str = withCAString str (\cstr -> return $ input cstr) where ...
08:55:46 <Smilex> fread2282: Ah, right. Thanks
08:55:58 <Smilex> I have a hard time comprehending monads
08:56:25 <silasm> Smilex: everyone does at first, just get some practice and soon enough they'll be second nature :)
08:57:20 <luite> ReinH: sure
08:57:28 <ReinH>  luite sweet
08:58:20 <freezerburnv> ReinH: Haskell cast? Is this a podcast about Haskell?
08:58:40 <zomg> freezerburnv: it's like when Han Solo was cast into carbonite
08:58:49 <tdammers> freezerburnv: no, it's when you broke your Haskell and they put a cast around it to allow it to heal properly
08:58:50 <ReinH> freezerburnv: yep
08:59:09 <[^__^]> ReinH: is there a link?
08:59:28 <ReinH> haskellcast.com
09:00:04 <luite> ReinH: going to budhac/zurihac and then switzerland first though, so in ~3 weeks the earliest
09:00:14 <[^__^]> ReinH: nice :D
09:00:15 <c_wraith> Smilex: trying to understand monads is like trying to understand "things that fly". If you assume they have anything more in common than the fact that they can fly, you're in severe danger of misleading yourself. If you assume monads mean anything more than the super-basic definition, you're in severe danger of misleading yourself.
09:00:32 <ReinH> luite: that's fine. have fun!
09:01:15 <benj_> explains why watching e.g. Crockford's monad talks is like watching someone put on a bird suit and plunge off a cliff flapping.
09:01:17 <freezerburnv> ReinH: Awesome, thanks
09:01:28 <ReinH> Hahaha
09:01:31 <philed> Gonzalez and Snoyman are like two of my favourite people on the internet.
09:01:47 <Smilex> c_wraith: As I understand it, a monad is something which can have many results
09:01:57 <ReinH> They are awesome. Gabriel is a lot of fun and a great teacher.
09:01:58 <c_wraith> Smilex: see? You've mislead yourself.
09:02:15 <[^__^]> @src Monad
09:02:15 <lambdabot> class  Monad m  where
09:02:16 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
09:02:16 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
09:02:16 <lambdabot>     return      :: a -> m a
09:02:16 <lambdabot>     fail        :: String -> m a
09:02:45 <ReinH> Those plus the laws are what a monad is.
09:02:50 <ReinH> except you can ignore fail
09:03:00 <c_wraith> and (>>) is a special case of (>>=)
09:03:11 <fread2282> Smilex: a monad is something that depends on another type and has those operations
09:03:27 <c_wraith> Smilex: don't assume monads mean anything. They're just a common set of operations many types provide.
09:03:33 <fread2282> depends can mean contains, but can also means produces or other more exotic things
09:03:48 <Smilex> Why is it  b.  ?
09:03:59 <ReinH> it doesn't "mean" any of those things.
09:04:07 <c_wraith> Smilex: the . is a separator
09:04:08 <philed> On this matter, Gabriel's post on free monads nicely dispelled me of my go-to "computation" metaphor.
09:04:11 <napping> The dot separates variables from the types
09:04:16 <ReinH> monads do not denote containment.
09:04:21 <fread2282> Smilex: you can ignore the forall a b. part
09:04:23 <Maior> @src (>>)
09:04:23 <lambdabot> m >> k      = m >>= \_ -> k
09:04:29 <napping> thats's must m a -> (a -> m b) -> m b
09:04:42 <napping> for any types a and b, like in a normal type signature
09:05:01 <napping> and you can explicitly write the forall a b . .... part on a signature yourself with the right extensions turned on, if you want to
09:05:54 <ReinH> Maybe might denote containment (zero or one) value, but that isn't because it's a monad.
09:06:19 <albeit> How can I pass a record field name to a stateful function, and then use that alias in a modify statement? As in: "update :: (Foo -> Int) -> FooState (); update alias = modify (\s -> s {alias=4})"?
09:06:28 <cococo> (Beginner here) What should I use to serve static HTML rendered with Jekyll?
09:06:36 <cococo> (What Haskell library)
09:06:51 <ReinH> albeit: this is a thing lens solves
09:06:51 <[^__^]> Smilex: "We will welcome you to monadic brotherhood" :)
09:07:07 <Smilex> Well by that definition, any value can become a monad, but a monad can never become a regular value again, yet I know that that is false.
09:07:23 <fread2282> Smilex: some monads can become regular values again
09:07:33 <fread2282> but not all
09:07:38 <albeit> ReinH: What operators should I look into?
09:07:50 <ReinH> albeit: %=
09:08:01 <awestroke> cococo: I'd use nginx, not haskell
09:08:31 <albeit> ReinH: Thanks
09:08:33 <ReinH> some types that are instances of Monad have projections or type constructors that can be matched on.
09:08:46 <philed> albeit: (.=) does what you want in the currnt lens library.
09:08:50 <philed> *current
09:09:07 <Smilex> fread2282: so IO has defined (<-) :: m a -> a ? Or something like that
09:09:17 <ReinH> Smilex: no
09:09:29 <fread2283> Smilex: no, IO is a monad where you can't get back the inner value
09:09:33 <benj_> when considering what "monads can do", it doesn't make sense to talk about the operations that fall outside of the Monad instance.
09:09:47 <awestroke> Smilex: <- and do is just syntactic sugaring over (>>=)
09:09:52 <ReinH> <- in do notation desugars to >>=
09:10:28 <philed> ReinH: Whilst inserting a lambda. These sorts of transformations can only be understood syntactically.
09:10:56 <ReinH> philed: good point
09:11:28 <awestroke> a <- action, b <- otherAction, return (a + b)      desugars to         action >>= (\a -> otherAction >>= (\b -> return (a + b)))
09:12:03 <fread2283> but you can also d (+) <$> action <*> otherAction
09:12:33 <awestroke> or liftM (+) action otherAction
09:13:11 <Smilex> awestroke: but a, in a <- action, is not a monad after that. I can't make sense of it
09:13:31 <hseg> @undo do {a <- getStr; b <- getStr; return (a ++ b)}
09:13:32 <lambdabot> getStr >>= \ a -> getStr >>= \ b -> return (a ++ b)
09:13:39 <awestroke> Smilex: sure, but you are still IN the monad, you can't just take the value from there
09:14:14 <albeit> philed: So something like "modify (\s -> {alias=4})" would be turned into "alias .= 4" with lens, correct?
09:14:28 <Smilex> ah! I think I get it
09:14:33 <hseg> albeit: Yes.
09:14:44 <albeit> So clean...
09:14:50 <philed> albeit: It truly is. :)
09:14:51 <hseg> Use the types, Smilex.
09:15:00 <Smilex> hseg: what types?
09:15:03 <[^__^]> Smilex: welcome to monadic brotherhood :D
09:15:06 <fread2283> Smilex: in do notation the values you bind with (<-) are "not in a monad" but you need to "put them back into the monad" to get them out of the do block
09:15:07 <hseg> :t getStr
09:15:09 <lambdabot>     Not in scope: ‘getStr’
09:15:09 <lambdabot>     Perhaps you meant one of these:
09:15:09 <lambdabot>       ‘putStr’ (imported from Prelude),
09:15:19 <fread2283> in reality they never leave the monad
09:15:22 <monochrom> the type of (>>=)
09:15:39 <hseg> :t getLine
09:15:40 <lambdabot> IO String
09:15:52 <hseg> :t (>>=)
09:15:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:16:10 <hseg> @undo do a <- getLine
09:16:11 <lambdabot> <unknown>.hs: 1: 16:Parse error: Last statement in a do-block must be an expression
09:16:27 <hseg> @undo do a <- getLine; return a
09:16:28 <lambdabot> getLine >>= \ a -> return a
09:16:37 <awestroke> it's like fmap in functor, in (a -> b), you get a non-functor a, and return a non-functor b, but you still stay in the functor:
09:16:40 <awestroke> > fmap (+1) (Just 2)
09:16:42 <lambdabot>  Just 3
09:16:49 <yogsototh> Hi all! Could someone could give me an advice on how to be more productive with Haskell. For example, I lose a lot of time trying to translate between Text and ByteString. It took me a long time to transform a JSON Array of string to a [String], etc...
09:16:55 <albeit> Is there a cleaner lens way to do "foo <- gets bar"?
09:17:14 <vanila> albeit, no, that's optimal
09:17:24 <albeit> vanila: Okay
09:17:29 <philed> Smilex: Every *expression* in your do-block (so discounting the <- lines) must evaluate to a type of "m a" for whatever m you are working with.
09:17:44 <philed> So if you go: do { x <- m; x }
09:18:06 <philed> Then you're saying that x is of type "m a". And hey, that's join.
09:18:07 <ReinH> Smilex: the a is bound variable in a lambda expression of type Monad m => a m b
09:18:18 <ReinH> it can't be accessed outside of that scope
09:18:56 <hseg> Smilex: Considering that \x -> e has the type a -> b where x has the type a and e has the type b, we have that when you write x <- f in a do-block, if f has the type m a for some instance m of Monad, then x will have the type a.
09:19:45 <fread2282> what's the infix flip fmap?
09:19:48 <hseg> Smilex: However, due to restrictions on do-notation, this value of type a will never escape the do-block except when wrapped in that instance of Monad.
09:20:13 <Smilex> hseg: Yeah, I get it now
09:21:18 <hseg> Smilex: Good. It basically boils down to lambdas and operators with some laws. All the rest is leaky abstractions that in the end hurt more than they benifit.
09:22:16 <hseg> s/benifit/benefit/
09:22:22 <ReinH> fread2282: <&> from lens
09:23:26 <hseg> Question. Looking at http://www.reddit.com/r/haskell/comments/167lmt/foldr_and_fusion_laws/c7u4jal?context=5, the foldr fusion law only holds for images of foldr. But this is the only place I can find that says this.
09:23:49 <hseg> Is there a better source? Is this restriction correct?
09:28:19 <fread2282> ReinH: thanks
09:28:57 <albeit> I've installed the "lens" package, but when compiling it complains it can't find module "Control.Lens". It even searches in location "Control/Lens.hs" but still can't find it... what's going on?
09:29:04 <jfischoff> is it possible to read the GHC event log of a live program?
09:29:10 <napping> albeit: how are you compiling?
09:29:22 <fread2282> @src (>>=)
09:29:23 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:29:32 <albeit> napping: Just "ghc File.hs"
09:29:46 <albeit> (And this is in a sandbox)
09:30:11 <jfischoff> ghc knows not of sandboxes
09:30:38 <jfischoff> ghc -package-db=.cabal-sandbox/x86* File.hs
09:31:06 <albeit> Ah, thanks
09:31:13 <jfischoff> albeit: you need to tell ghc to use the sandbox package database explicitly if you are not using cabal
09:31:41 <napping> yogsototh: what kind of trouble did you have?
09:31:53 <napping> sounds like the kind of conversion problem where you just click around in haddocks a bit
09:31:58 <fread2283> let (>>=|) a f g = a >>= (\b -> f b <|> g b) in [1] >>=| return return
09:32:06 <fread2283> > let (>>=|) a f g = a >>= (\b -> f b <|> g b) in [1] >>=| return return
09:32:08 <lambdabot>  Couldn't match type ‘[b]’ with ‘a0 -> m0 a0’
09:32:08 <lambdabot>  Expected type: a -> [b]
09:32:08 <lambdabot>    Actual type: a -> a0 -> m0 a0
09:34:14 <fread2283> > [1] >>= (\a -> return a <|> return a)
09:34:16 <lambdabot>  [1,1]
09:34:18 <McManiaC> how do you add a changelog to hackage packages?
09:34:30 <fread2283> what's wrong here?
09:34:40 <hseg> Does someone have references on fusing f . foldr p z into foldr q (f z), where f (p x (foldr p z xs)) = q x (f (foldr p z xs))
09:34:46 <hseg> ?
09:34:59 * hackagebot mstate 0.2.7 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.7 (NilsSchweinsberg)
09:36:24 <hseg> The most I could find is http://www.reddit.com/r/haskell/comments/167lmt/foldr_and_fusion_laws/c7u4jal?context=5, which seems to indicate this is the correct law, but all the articles I can find make use of the free theorem of foldr or the fact that foldr is the catamorphism for lists to require that f (p x y) = q x (f y) for all x,y.
09:39:19 <fread2283> > let (>>=|) a f g = a >>= (\b -> f b <|> g b) in ([1] >>=| return) return
09:39:21 <lambdabot>  [1,1]
09:44:33 <benzrf> how does C.A.many work anyway
09:44:35 <benzrf> @src many
09:44:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:44:42 <benzrf> :t many
09:44:43 <lambdabot> Alternative f => f a -> f [a]
09:45:07 <benzrf> never quite got the hang of alternative/monadplus
09:46:34 <augur> benzrf: what do you mean how does it work?
09:46:39 <augur> @srx many
09:46:39 <lambdabot> Source not found. My pet ferret can type better than you!
09:46:41 <augur> :|
09:46:48 <augur> @hoogle many
09:46:50 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
09:46:50 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
09:46:50 <lambdabot> Text.Parsec.Prim many :: ParsecT s u m a -> ParsecT s u m [a]
09:47:02 <augur> oh thats right, @google doesnt link. how awful
09:48:08 <benzrf> whats the alternative laws again
09:48:24 <augur> benzrf: you know how with regular expressions x* is equivalent to x+|0   where 0 is the empty pattern?
09:48:35 <benzrf> i get many in the context of parsec
09:48:43 <benzrf> just not for generalized applicatives
09:48:47 <fread2283> benzrf: monoid
09:49:03 <benzrf> fread2283: yeah but alternative vs moboid
09:49:05 <benzrf> *monoid
09:49:29 <fread2283> that's the alternative laws
09:49:30 <augur> benzrf: empty :: f a, (<|>) :: f a -> f a -> f a
09:49:39 <augur> benzrf: empty <|> x = x = x <|> empty
09:50:32 <albeit> Trying to use a lens like "bar .= newMap" in a stateful computation :: State Foo (), and "Foo = { _bar = IntMap Int}", and compiler is saying "No instance for MonadState Foo (StateT Foo Identity)" from .=. Any ideas?
09:51:41 <augur> benzrf: its just a generalized monoid -- instead of the type `a` being the monoid, its saying that any type `f a` is a monoid (for f an applicative)
09:51:48 <supki> albeit: paste the code?
09:51:51 <benzrf> augur: whats the laws wrt applicativeness tho
09:51:56 <augur> benzrf: no
09:51:56 <benzrf> isnt there a left zero thing or something
09:52:00 <augur> benzrf: those are the applicative laws
09:52:04 <augur> arent*
09:52:08 <augur> those are the alternative laws
09:52:14 <fread2283> just monoid
09:52:14 <benzrf> thats what i meant >.<
09:52:37 <augur> oh sorry, i misread what you said x.x
09:53:14 <augur> benzrf: i dont think there's any special interaction with applicative per se
09:53:49 <augur> just that, if you override some and many, they should be solutions to the equations
09:53:49 <zerokarmaleft> augur: why is f constrained to be an applicative?
09:54:06 <augur> some v = (:) <$> v <*> many v       many v = some v <|> pure []
09:54:59 <zerokarmaleft> oh, nvm
09:55:15 <augur> benzrf: yeah?
09:55:19 <albeit> supki: Code and error http://lpaste.net/104811
09:55:58 <darthdeus> is there a more conscise way to write this in parsec?     many space; char '{'; many space
09:55:58 <darthdeus>     entities <- many parseEntity
09:55:58 <darthdeus>     many space; char '}'; many space
09:56:41 <augur> darthdeus: do you find yourself writing the braces thing a lot?
09:56:47 <supki> albeit: interesting, do you have multiple mtl versions installed?
09:57:03 <supki> albeit: ghc-pkg list mtl
09:57:24 <albeit> supki: It's in a sandbox, is there an eqivalent command to list the sandbox pacakges?
09:57:44 <augur> darthdeus: i mean, one thing you could do ofcourse is just define a combinator `paddedChar` as   padded c = many space >> char c >> many space
09:57:47 <darthdeus> augur: more like the "many space" around it
09:57:51 <fread2283> spaces >> char '}' >> spaces >> many parseEntity <* spaces <* char '}' <* spaces should be the same
09:58:07 <fread2283> spaces == many space
09:58:08 <supki> albeit: cabal sandbox hc-pkg -- list mtl
09:58:30 <darthdeus> cool :)
09:58:38 <albeit> supki: Just mtl-2.1.3.1 listed in a single location
09:59:26 <albeit> Is it something to do with monomorphism restrictions?
09:59:44 <supki> albeit: ok, what about transformers versions?
10:00:08 <supki> it looks like you have some cabal problem
10:00:48 <koala_man> darthdeus: it looks like you're adding 'many space' both before and after everything. it's easier if you just do it after literals
10:00:55 <albeit> supki: Hmm... its going outside the sandbox to my ghc directory to find the transformers package (0.3.0.0)
10:01:43 <fread2283> personally I have a padded p = spaces >> p <* spaces
10:01:47 <albeit> supki: Here's that ouput http://lpaste.net/104812
10:02:41 <ironChicken> working with the FFI, I have a struct that contains a double* which is an array of doubles. I'm trying to write a Storable instance for my ADT which wraps this struct. In my ADT I'd like to use Vector Double as the type for that field. But I can't work out how to implement the peek for this field.
10:02:47 <ironChicken> http://pastebin.com/ptuYwsAT is what I have so far
10:03:06 <fread2283> wth padded: padded (char '}') >> many parseEntity <* padded (char '}')
10:04:24 <benzrf> use *> for consistency
10:04:45 <haasn> Hah, I just found out that pragmas are not case sensitive. I accidentally wrote LANGUAGe and it compiled
10:05:39 <darthdeus> hmm, >> and <* looks like a good combination
10:05:53 <fread2283> darthdeus: *> is == >>
10:06:29 <ironChicken> i think i'm stuck because peek is Ptr a -> IO a and unsafeFromForeignPtr0 is ForeignPtr a -> Int -> Vector a
10:06:57 <ironChicken> so it says "Couldn't match type `DV.Vector' with `IO'"
10:07:48 <darthdeus> fread2283: *> from Control.Applicative ?
10:07:50 <ironChicken> but if peek returns IO a, how do you actually get at the value you're peeking?
10:07:56 <fread2283> darthdeus: yep
10:08:49 <albeit> supki: Any more ideas? Thanks for the help so far
10:09:05 <pavonia> ironChicken: val <- peek#
10:09:20 <benzrf> peek#
10:09:22 <benzrf> whats this
10:09:23 <benzrf> :t peek#
10:09:24 <lambdabot> Not in scope: ‘peek#’
10:09:31 <pavonia> * #peek
10:09:38 <benzrf> :t #peek
10:09:39 <lambdabot> lexical error at character 'p'
10:09:42 <benzrf> :{
10:09:45 <albeit> :t peek
10:09:46 <lambdabot> Not in scope: ‘peek’
10:09:49 <pavonia> It's hsc2hs macro
10:10:02 <benzrf> oh
10:10:03 * hackagebot htsn-import 0.0.5 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.5 (MichaelOrlitzky)
10:11:00 <pavonia> ironChicken: Also have a look at Foreign.Marshal.Array which already has some functions for peeking arrays
10:11:09 <glguy_> The hsc2hs macro is #peek, and only works in .hsc files
10:12:05 <albeit> Anyone have any idea why I'm getting this no instance for MonadState error (a simple, I think) lens operator? http://lpaste.net/104813
10:12:58 <supki> albeit: not really, your code is fine, so the problem is pretty weird
10:12:59 <ironChicken> pavonia: if i don't try and do any marshalling at all i get "No instance for (Storable (DV.Vector Double))"
10:13:21 <hseg> Does anyone know the fusion law for foldr (in the sense f . foldr g z = foldr h (f z), subject to appropriate restrictions)?
10:13:33 <supki> albeit: which package is your StateT from?
10:13:44 <hseg> Because I've been seeing different versions of the restirctions.
10:13:54 <albeit> supki: I import Control.Monad.State.Lazy for State
10:13:58 <glguy_> albeit: You probably have multiple versions of the same transformers package installed or similar
10:14:28 <pavonia> ironChicken: You first have to peek your array as a list and convert it into a Vector afterwards
10:14:55 <pavonia> Though I thought there were Storable Vector instances
10:15:03 * hackagebot entropy 0.3 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3 (ThomasDuBuisson)
10:15:04 <supki> albeit: so it must be mtl I guess, can you paste the whole  cabal sandbox hc-pkg list  somewhere?
10:16:00 <glguy_> There shouldn't be Storable instances for Vector since there is no standard mapping for them into C structs
10:16:05 <albeit> supki: Sure thing http://lpaste.net/104814
10:16:45 <albeit> There is no transformers in my sandbox apparently
10:17:01 <pavonia> ironChicken, glguy_: http://hackage.haskell.org/package/vector-0.7.0.1/docs/Data-Vector-Storable.html
10:17:05 <ironChicken> pavonia: the problem with peekArray is that I end up with a list, where I actually want a Data.Vector.Storable
10:17:17 <albeit> But if I do a "cabal install transfomers" it says its already there (and "there" must be in my main ghc directory)
10:17:27 <ironChicken> pavonia: yes, i'm already using DV.Storable
10:17:53 <pavonia> ironChicken: So you probably have to cast your pointer
10:18:00 <albeit> Hmm if I reinstall transformers, might that work?
10:18:20 <glguy_> pavonia: what about it?
10:18:32 <albeit> Argh but then it says I would break ghc-7.8.2
10:18:46 <pavonia> glguy_: Well, there are Storable instances
10:18:52 <glguy_> for what?
10:19:00 <pavonia> Vector
10:19:02 <glguy_> where
10:19:17 <supki> albeit: which command do you run to compile the file?
10:19:30 <pavonia> glguy_: Oh, sorry
10:19:43 <solidus-river> so i understand how you would listen for a keypress in haskell etc but how do you listen for / respond to mouse movements?
10:19:44 <supki> albeit: no, reinstalling anything from the global db is (almost) never a good idea
10:19:54 <albeit> supki: "ghc -O2 -package-db=.cabal-sandbox/x86_64-linux-ghc-7.8.2-packages.conf.d"
10:21:02 <ironChicken> pavonia: hmm, is that the pointer struct field that i'll need to cast? i don't know how to get at it as a pointer; peek just returns IO a
10:22:01 <supki> albeit: and  type ghc?
10:22:24 <solidus-river> i mean like low level
10:22:36 <albeit> supki: Not sure what you mean? If I use just "ghc" it then can't find Control.Lens
10:22:38 <pavonia> ironChicken: You need to cast ptr into the element type of the array
10:22:40 <solidus-river> is there a handle you can check for updates on mouse events?
10:23:00 <supki> albeit: I mean what's the output of  type ghc  command?
10:23:12 <fread2283> is there a one step at a time pl?
10:23:27 <albeit> supki: Ah, "ghc is hashed (/home/ben/ghc/ghc-7.8.2/bin/ghc)"
10:24:04 <pavonia> ironChicken: or rather into a *pointer* of that element type
10:27:02 <ironChicken> pavonia: sorry, i can't see how to do that. i think i need to re-ask my question later with a clearer example than http://pastebin.com/ptuYwsAT
10:28:46 <supki> albeit: I don't know what's wrong then
10:29:40 <pavonia> ironChicken: peekArry size' (castPtr valuesPtr :: Ptr Double) -- something like this
10:30:05 <pavonia> and then the conversion from [Double] to Vector Double
10:37:48 <glguy_> ironChicken: You probably want something like this: http://lpaste.net/104815
10:38:05 <glguy_> and that code has an off-by-one error, should be  [0..fromIntegral size - 1]
10:38:12 <fread2283> where can I get TH or GHC.Generics for QuickCheck instances?
10:39:05 <absence> i'm trying to implement join for a tree type and have trouble getting rid of some almost-duplication in the code. note that it's a different join than the "trivial" one. is there a better way to write this? http://lpaste.net/1304920637730455552
10:40:16 <solidus-river> anyone on low level implimentation of listening for mouse movements / events in haskell?
10:41:05 <Cale> solidus-river: On which platform? Usually you'd use one of the GUI libraries like Gtk2Hs
10:41:31 <Cale> solidus-river: If you want lower level, then you won't be able to use something which is cross-platform
10:41:33 <solidus-river> Cale: aye, i'm looking forhow to do it without a library
10:41:47 <solidus-river> Cale: i'm curouse about the low low level implimentation, like what is the type, what monads are involved etc
10:41:53 <Cale> solidus-river: Well, you'll always be using at least your OS's library
10:42:03 <solidus-river> Cale: thats fine, how about on *nix systems
10:42:21 <solidus-river> Cale: or do i need to go even more specific to linux vs unix
10:42:37 <Cale> http://hackage.haskell.org/package/X11
10:43:34 <Cale> You could create a window and look for motion events on it
10:44:19 <geekosaur> for raw X11 you'd probably create an InputOnly window
10:44:47 <ironChicken> glguy_: thanks. that seems to make sense.
10:45:06 <monochrom> low level is just FFI and IO
10:45:11 <solidus-river> so do the system libraries just impliment a trigger / bus that gets exposed to haskell and the haskell lib returns movement events?
10:45:12 <sgregory> if by *nix you mean OSX X11 requires some extra installs
10:45:29 <Cale> solidus-river: no
10:45:43 <solidus-river> i'm interested in how that logic gets from the OS to haskell land
10:46:30 <Cale> solidus-river: Well, X11 consists of a protocol for client programs to communicate to the X server which is controlling your display.
10:46:42 <Cale> It's technically a network protocol
10:46:55 <Cale> (though few people actually use it as one these days)
10:47:07 <solidus-river> So listening for mouse movements involves listening for info on a local unix socket?
10:47:08 <absence> solidus-river: just like in any other language. are you familiar with C?
10:47:16 <solidus-river> absence: yes
10:47:22 <geekosaur> unixlikes don't have mouse events integrated into the OS
10:47:26 <absence> solidus-river: how would you access the mouse in C?
10:47:38 <monochrom> X11 does things very differently from Win32
10:47:42 <solidus-river> absence: heh, through glew / glut
10:47:49 <sgregory> but you can still fire up a remote Firefox Session over an ssh tunnel
10:47:52 <solidus-river> so i guess its a more general question than just haskell
10:48:11 <sgregory> and wait... and wait...
10:48:18 <monochrom> and yes, at that level, it ceases to have anything to do with any language except asm
10:48:26 <solidus-river> i've always figured it was over a communication bus with
10:48:35 <absence> solidus-river: yes :) if you figure out how to do it lower level than glut in C, then it's exactly the same way in haskell
10:48:46 <solidus-river> so i guess can anyone explain a little about how thats implemented :P
10:50:27 <monochrom> you probably should begin by taking a course on OSes
10:50:43 * monochrom postpones the question by prescribing more courses to take
10:52:15 <oconnore> Hey, I wrote my first somewhat useful program yesterday (~50 lines), can anyone give me style tips / code review? https://gist.github.com/oconnore/6577d8d3cc528cd601b0
10:52:49 <monochrom> wait a second, 7.8.3 is imminent?!
10:53:15 <solidus-river> monochrom: i've already had a course on os's!
10:53:20 <geekosaur> yep, more significant bugs
10:53:46 <solidus-river> thats why i figured it'd be a bus that was being sampled
10:55:07 * hackagebot Cabal 1.20.0.1 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.20.0.1 (JohanTibell)
10:55:20 <monochrom> it turns out that they chose interrupts over polling. I'm talking about what the CPU and OS sees. what happens inside the mouse is another matter but invisible anyway
10:55:50 <solidus-river> bah i'm getting into HID implimentations now
10:57:01 <monochrom> anyway, the interrupt handler adds an event to the OS's or GUI's global event queue
10:58:12 <solidus-river> monochrom: thanks :) i didn't see your earlier response
10:58:47 <solidus-river> my mind is now less boggled
11:00:51 <warpy> ocharles: Prelude is implicitly imported. you dont need to write Prelude.filter. Just write filter
11:01:02 <warpy> err oconnore ^
11:01:25 <maki_> hi, is haskell well suited for type theory?
11:02:14 <oconnore> warpy: I was getting conflicts from Data.List.foldl and Data.Set.foldl -> "Ambiguous occurrence `foldl'"
11:02:16 <Polarina> maki_, what do you mean with that?
11:02:18 <monochrom> that is a vague question
11:02:23 <oconnore> warpy: is there a way to import only certain symbols?
11:02:32 <solidus-river> so if i'm understanding this along the right lines, catamorphisms started as an observation that we can make functors more general, what they provide is a way to operate on a functor with a function that categorizes pieces of the functor and returns different operartions based on the category of that part of the functor
11:02:55 <geekosaur> oconnore, you can list symbols to import in parentheses in the import line
11:02:56 <warpy> oconnore: yes. import Data.List (foldl)
11:03:14 <warpy> or Data.List hiding (foldl) to import everything except foldl
11:03:15 <geekosaur> but more commonly we import qualified for stuff like that: import qualified Data.Set as S
11:03:24 <geekosaur> and then use S.foldl for the set version
11:05:25 <oconnore> geekosaur warpy: ah, ok. Thanks.
11:05:26 <Cale> solidus-river: Make functors more general? What?
11:06:00 <solidus-river> Cale: well, the first couple examples given of a use case https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms
11:06:25 <Cale> Do you mean "fold" rather than "functor"?
11:06:37 <solidus-river> are all duplicating what could be done via a normal...
11:06:40 <solidus-river> yes i meant fold
11:06:53 <oconnore> That's a bit more straightforward than CL's shadowing-import :)
11:07:00 <Nightson> hello everyone
11:07:06 <Cale> Hello
11:07:09 <Nightson> i made a parser in haskell using happy
11:07:25 <Nightson> so I give some input in pseudo code and he gives me the syntax tree
11:07:38 <solidus-river> i really dont like hiding imports, think you should just qualify the less standard libs version instead of hiding
11:07:51 <Nightson> now I have another haskell program that takes a syntax tree and produces three address code
11:07:53 <Cale> solidus-river: I tend to think of catamorphisms as being something which will replace each of the data constructors throughout a value of some type with some given other functions/values of appropriate types.
11:07:56 <Nightson> but I don't know how to link them
11:08:00 <Nightson> anyone has an idea?
11:08:42 <Cale> solidus-river: For example, if we have a type like  data Nature = Rock | Stream Nature | Bush Nature Nature
11:09:28 <Cale> Then the catamorphism for this type will be  foldNature r s b = f where f Rock = r; f (Stream n) = s (f n); f (Bush n n') = b (f n) (f n')
11:10:01 <Cale> Nightson: Function composition?
11:10:03 * byorgey didn't realize streams stop when they come to rocks
11:10:08 <Cale> byorgey: :D
11:11:03 <Nightson> i read somewhere that all we had to do was to import the modules we used on the haskell file to the happy file
11:11:16 <favetelinguis> when running cabal install --only-dependencies i get this error http://lpaste.net/104817 what can i do about it??
11:11:24 <Nightson> and put the function in the print
11:11:35 <Nightson> but i didn't really understand that, is that possible?
11:11:45 <napping> Nightson: or the other way, yes. happy generates a Haskell module you can include from elsewhere or compile as the main program or whatever
11:12:24 <Cale> favetelinguis: Look for the real error message farther up in the build log
11:12:43 <solidus-river> so if phi determines what type to add based on the value, what does cata do
11:12:48 <Nightson> napping: but how would i do that?
11:12:52 <solidus-river> in cata phi t
11:12:55 <Nightson> i'm not understanding it well...
11:13:00 <geekosaur> favetelinguis, the real error is somewhere above that. if you're on a linux (red hat-like or debian-like) then a common cause is you're missing the -dev libraries for postgresql
11:13:02 <Cale> favetelinguis: ExitFailure 1 just means that something failed (and exited with a nonzero exit code), you're going to want to look up in the build log to where that package was being built
11:13:24 <napping> Nightson: do you know how to write two haskell files and have one include the other?
11:13:50 <benzrf> haskellers
11:14:01 <benzrf> ur rong
11:14:08 <benzrf> http://stackoverflow.com/a/10168111 <- left zero law of alternative
11:14:13 <benzrf> edwardk said it so it must b tru!!!
11:14:18 <Nightson> I never needed that so no
11:14:25 <edwardk> of course
11:14:26 <Nightson> but it's with import right
11:14:30 <Nightson> from what i understood
11:14:40 <Nightson> my happy generates the module 'Main'
11:14:52 <Nightson> so I can import Main to the other haskell file?
11:15:18 <napping> Nightson: if you look at the manual you can change the name, or get imports in the generated files. I don't remember exactly how that goes
11:15:25 <Ainieco> hello
11:15:44 <napping> The name Main is a bit special, so you should probably change it if you want to import it into the other module
11:16:01 <u_> anyone know a good guide to "writing C in haskell"
11:16:23 <u_> i.e. using foreign pointers and stuff like they do in the language shootout examples
11:16:35 <favetelinguis> is this it? http://lpaste.net/104819
11:17:05 <benzrf> u_: haskell doesnt have ptrs
11:17:15 <Ainieco> i have rather weird problem http://lpaste.net/104818 these threee examples compile just fine but first two will eat 6GB of RAM and die. any suggestions what could it be?
11:17:16 <Ainieco> there are really limited set of posibilities even with these finctional types and names
11:17:20 <geekosaur> favetelinguis, that would be what I said, yes
11:17:23 <Ainieco> but i don't know what to debug it
11:17:32 <chirpsalot> benzrf: Haskell has IO pointers, no?
11:18:14 <u_> benzrf: http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=nbody&lang=ghc&lang2=java&data=u32 what do you call these then
11:18:24 <Ainieco> "aX" can't be recursive function defined elsewhere because issue persists even with record wildcards
11:18:30 <u_> i've been trying to write stuff like the above for GCJ
11:18:33 <benzrf> chirpsalot: i suppose so
11:18:33 <Ainieco> so how can it be?
11:18:40 <benzrf> but thats not in haskell itself, just its ffi/libs
11:18:49 <geekosaur> favetelinguis, don't know what kind of system you are on but you need developer libraries for postgres
11:19:02 <napping> Ainieco: that depends on your A and B
11:19:17 <favetelinguis> ok how do i do that? im on osx
11:19:56 <favetelinguis> why do i need postgres stuff when i want to use sqlite with haskell?
11:21:00 <chirpsalot> benzrf: I thought they would be in the Haskell standards.
11:21:24 <napping> Ainieco: All three work just fine with data A = A { aX :: () }, data B = B { bList :: [()]}, so you didn't post enough to show your problem
11:21:30 <stelleg> could someone remind me what the extension is for tuple holes, e.g. (,3) 4 == (4,3)
11:21:48 <napping> doesn't ghci remind you?
11:21:48 <stelleg> or am I crazy and that doesn't exist
11:21:52 <napping> > (1,,2)
11:21:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
11:21:54 <lambdabot>    arising from a use of ‘M55271319751587983481887.show_M55271319751587983481...
11:21:54 <lambdabot>  The type variable ‘t0’ is ambiguous
11:21:54 <lambdabot>  Note: there are several potential instances:
11:21:54 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:22:11 <napping> whoa, that's weird. ghci suggests TupleSections
11:22:19 <felixn> favetelinguis: brew install postgresql
11:22:46 <stelleg> it does, thanks
11:23:21 <napping> favetelinguis: Do you? What sqlite library are you trying to use?
11:23:39 <rwbarton> napping: I think lambdabot has the extension turned on and then it got an error when trying to show the function using some goofy lambdabot instance
11:23:41 <favetelinguis>  persistent-sqlite
11:24:19 <napping> I don't see anything that would bring that in
11:24:38 <napping> Even sqlite-simple is based on the interface of postgresql-simple but doesn't depend on it
11:25:33 <favetelinguis> aa no sorry man now i see :) It is an example file from chap11 in beginning haskell he also has this  persistent-postgresql
11:26:31 <napping> Ah okay. It wouldn't be totally crazy if some multi-backend thing like persistent might easily/accidentally pull in extra backends.
11:27:31 <favetelinguis> dam, gettign 100error when trying to run the code thogh, to bad they dont produce working examples in such a new book :(
11:27:53 <napping> yeah. What book is it? Is there code online somewhere?
11:28:17 <napping> There might be a repo online that's actually kept up to date or something
11:28:46 <efg> yummy... https://www.flickr.com/photos/raganwald/212588975/in/photostream/
11:29:12 <favetelinguis> here is the book
11:29:13 <favetelinguis> http://www.apress.com/9781430262503
11:29:25 <favetelinguis> you can find the source code if you scroll down
11:29:47 <favetelinguis> im just trying to run chapeter11
11:30:44 <savanni> Hey, quick question about exception handling.  It is perhaps closely entwined with HDBC-sqlite3
11:31:16 <savanni> I have a database file that I've purposely made unopenable.  And I'm trying to catch the exception like so (doing this in the repl)
11:31:30 <savanni> z <- ((try $ connectSqlite3 "test.db") :: IO (Either IOException Connection))
11:31:53 <savanni> But... it's not catching the exception.  I continue to get the Exception printout and z continues to not have the expected Left value.
11:32:18 <savanni> Do any of you have any idea why?  When I did deeply enough into HDBC, it looks like the exception is being raised with throwDyn, but I would expect try to catch that.
11:32:26 <rwbarton> is it an IOException?
11:32:32 <monochrom> does the doc of connectSqlite3 say what exception type it throws?
11:33:00 <savanni> No, it does not say.
11:33:13 <enthropy> see if Either SomeException Connection -- will also miss the exception?
11:33:20 <savanni> But, perhaps it is not strictly IO... here is the text of the exception:
11:33:34 <savanni> *** Exception: SqlError {seState = "" ...
11:33:50 <savanni> SomeException catches it
11:34:10 <monochrom> ok, that's good news
11:34:25 <savanni> Yeah.  I'll go read up on SomeException + SqlError to see what I find.
11:34:44 <enthropy> well you just have to find out what type SqlError belongs to
11:35:10 <monochrom> z <- ((try $ connectSqlite3 "test.db") :: IO (Either SomeException Connection)); case z of Left (SomeException realone) -> print (typeOf realone)  may tell you the name of the correct type
11:40:12 * hackagebot propellor 0.5.3 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.5.3 (JoeyHess)
11:48:24 <savanni> So... if a function could throw two different exception types (say IOException if the disk is full, but SqlError if there's just something wrong with the database itself), is there any way to pattern match on that so I can choose my recovery scheme?
11:51:49 <awestroke> savanni: you can pattern match on the TypeRep I think...
11:53:07 <awestroke> savanni: read through http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Exception-Base.html , there's a lot of great explanations there
11:53:11 <benzrf> :t typ
11:53:12 <lambdabot> Not in scope: ‘typ’
11:53:16 <benzrf> :t typeOf
11:53:17 <lambdabot> Typeable a => a -> TypeRep
11:53:24 <benzrf> :t typeOf 3
11:53:25 <lambdabot> TypeRep
11:53:31 <benzrf> :t typeOf 'g'
11:53:31 <lambdabot> TypeRep
11:53:39 <awestroke> > typeOf 'g'
11:53:40 <lambdabot>  Char
11:54:43 <awestroke> savanni: among other methods, they use "cast" to get Maybe ExceptionType, then that can be patternmatched for either Nothing or the exception of that type
12:01:52 <savanni> This is not really considered good practice, is it?
12:02:29 <awestroke> savanni: you're not really doing anything type-unsafe
12:02:36 <awestroke> cast is not unsafeCoerce
12:03:01 <supki> savanni: the usual approach is to use  catches  with a bunch of handlers
12:03:26 <savanni> But all of the possible exceptions that a function can throw are *hidden*!
12:12:13 <fread2282> how can I intertwine two free monads?
12:14:47 <StoneCypher> fread2282: wedding ring
12:16:47 <merijn> fread2282: Depends on which monads, the idea of "monad transformers" is to transform an existing monad into one with extra capabilities, that might be what you need
12:17:48 <merijn> savanni: Correct, the preferred way is to use Maybe/Either/some custom datatype for errors. Exceptions are generally for IO errors
12:18:05 <Saizan> fread2282: take the free monad of the sum of the functors
12:18:45 <merijn> savanni: Basically, all haskell exceptions are "unchecked exceptions", yes
12:19:08 <savanni> Well, at this point I try to catch all IO error and turn them into a more useful Either or EitherT.
12:19:47 <savanni> This one simply boggles me.  I'm going to have to write my code in the hopes that the sqlite3 code converts all exceptions, including IOException, into SqlError.
12:19:51 <merijn> savanni: My personal opinions is that APIs should never produce exceptions, i.e. the default should return Either and then if users want to use exceptions in their application that's fine
12:20:05 <savanni> That is a relief.
12:20:26 <merijn> savanni: Btw, you won't have to worry about that, you can do something simpler
12:21:01 <merijn> savanni: You can write a function that takes SomeException as argument, then check whether it's IOException OR SqlError and rethrow for everything else
12:25:00 <merijn> savanni: A function like this is perfectly fine: http://lpaste.net/104822
12:25:20 <merijn> savanni: Depending on what you do with the cast result you may not even need the type annotation
12:26:02 <savanni> I was working on something similar that would "cast" it all into a Left value.
12:26:04 <merijn> It reraises any unknown exceptions, but you could do something else instead
12:26:50 <merijn> savanni: Try converts everything into Left by default
12:26:52 <merijn> :t try
12:26:53 <lambdabot> Exception e => IO a -> IO (Either e a)
12:27:14 <merijn> :t try :: IO a -> IO (Either SomeException a)
12:27:15 <savanni> Left, but of unpredicatable type...
12:27:15 <lambdabot> IO a -> IO (Either SomeException a)
12:27:26 <rwbarton> you pick the type e
12:27:31 <savanni> I suppose that's really good enough for me, though.
12:27:46 <merijn> savanni: You can specify 'e' to be "SomeException" and then it will catch each type
12:28:27 <merijn> You could use "try" plus a function like mine that inspects whether the left value is IOError/SqlError and if not, it reraises
12:28:39 <dgpratt> a friend of mine just pointed me to this: http://www.scs.stanford.edu/14sp-cs240h/slides/ghc-rts.pdf
12:28:43 <merijn> savanni: You can nest different handlers too, though
12:28:58 <dgpratt> slim chance I judge, but might there be a video somewhere to go along with those slides?
12:29:02 <merijn> savanni: i.e. using two "catch" calls or a single "catches"
12:29:03 <luite> merijn: cast doesn't work for that
12:29:13 <merijn> luite: Why not?
12:29:20 <luite> because they are different types
12:29:26 <luite> use fromException
12:29:48 <savanni> Give me another minute nad I"ll show what I"m coming up with.
12:29:49 <merijn> luite: I don't see why that would work
12:30:27 <luite> merijn: oh wait sorry i read your code wrong
12:30:35 <merijn> luite: The implementation of fromException is literally the same as my code :)
12:32:15 <merijn> fromException is probably better, but I forgot it existed :)
12:32:40 <Iceland_jack> Handling exceptions in Haskell is not very beautiful :)
12:32:56 <merijn> Iceland_jack: I disagree
12:33:07 <merijn> savanni: Which Sql package are you using, btw?
12:33:14 <savanni> HDBC-Sqlite
12:33:20 <merijn> Don't they have built in primitives that don't throw exceptions?
12:33:20 <Iceland_jack> Not very beautiful to use, is what I meant
12:33:25 <savanni> And, what I'm trying doesn't work.
12:33:43 <savanni> No.  No part has non-exception primitives.
12:34:26 <savanni> There might be a catch function that already handles it, but I've not foun dit.
12:34:37 <madjestic> k
12:34:58 <luite> merijn: right, since fromException is a class method, it's the default implementation, but you can implement your own if you want to build fancier exception hiearchies
12:34:59 <solidus-river> geekosaur: any movement in that XMonad framewindow bug? I've been studying pretty hard, thinking of taking a whack at it this weekend or next
12:35:04 <solidus-river> geekosaur: got any tips if i do?
12:35:18 * hackagebot purescript 0.5.2.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.2 (PhilFreeman)
12:35:36 <merijn> savanni: Ugh, I dislike the library design then
12:36:02 <geekosaur> er? which bug is this supposed to be?
12:36:04 <merijn> savanni: Well, what are you trying to do other than "run one handler in case of SqlError and another in case of IOError"?
12:36:22 <geekosaur> (if the supposed bug is "xmonad doesn't use frame windows" then there will be no movement, I'm pretty sure)
12:36:22 <merijn> savanni: Because that problem seems trivial?
12:36:46 <monochrom> I am fine with exceptions, but the doc must say which exceptions for what conditions
12:36:49 <solidus-river> geekosaur: some opengl apps (including all of sdl 2+) assume a frame window or fail to initialize a context with sane dimensions
12:36:56 <merijn> monochrom: And they almost never do >.<
12:36:58 <savanni> It seems absolutely non-trivial to me.  But, I'm trying to convert the error into a sane architecture so that a caller function can decide what to do.
12:37:21 <solidus-river> geekosaur: aw, so it was filed under broken but not a bug eh?
12:37:22 <warpy> what is the difference between TChan and TQueue
12:37:39 <warpy> arent both FIFO queues
12:37:40 <monochrom> java is ahead of us on this, java types tell you most of the exceptions. but I think Oleg solved that a long time ago.
12:37:54 <geekosaur> I do not remember seeing such a bug filed
12:38:01 <savanni> *every* language is ahead of Haskell on error handling.  Except, maybe, PHP and Perl.
12:38:07 <solidus-river> as a hack how does a custom fullscreen layout sound where the window in focus has a frame for feasability, would that break a lot more htan i'm thinking it would?
12:38:21 <merijn> savanni: right, so you wanna do cleanup for those two errors and then reraise for the caller to deal with?
12:38:27 <Ralith> solidus-river: I use SDL2 apps with a tiling WM very regularly, they work fine
12:38:37 <geekosaur> nevertheless, xmonad is a non-reparenting window manager, I am not at all sure that "just make it reparenting like broken apps insist on" is an acceptable solution
12:38:41 <monochrom> part of why some of us prefer Either and ErrorT is that they tell you the exception types.
12:39:00 <savanni> merijn: yes, but I absolutely do not want to "re-raise" with throw.  throwError, sure.  left, sure.  But *NOT* an IO exception.
12:39:12 <solidus-river> Ralith: interesting, i guess it doesn't depend on sdl then
12:39:28 <Ralith> solidus-river: idk if my WM (i3) is reparenting though
12:39:31 <geekosaur> if there is something that sdl2 needs to be told so it will work correctly then it would help to find out what that is, not to reengineer the whole window manager
12:39:40 <Ralith> there are frames
12:39:45 <geekosaur> frame windows are NOT a trivial drop-in solution
12:40:13 <geekosaur> I think i3 is reparenting, in fact it has bugs related to that because it doesn't initialize its frame windows properly
12:40:23 <savanni> never mind.  If my program encounters SomeException of any kind i'll just smash it into one error and propagate it up.
12:40:38 <Ralith> I'd certainly be interested in what issues SDL2 has here, as I use it
12:40:42 <merijn> savanni: Right, how about this solution?
12:40:44 <merijn> savanni: http://lpaste.net/104823
12:41:07 <merijn> savanni: The catch handlers do cleanup for SqlError/IOError and reraise, then the outer "try" just stuff everything into "Either SomeException a"
12:41:24 <solidus-river> Ralith: i haven't explored it in a couple months but the determination last time i looked into it is that some custom apps as well as apps written in sdl2 assume a parent window when initializing a context
12:41:27 <merijn> savanni: Your caller can decide what to do with the "SomeException" and the cleanup has been handled
12:41:50 <solidus-river> Ralith: depending on the app this either causes it to run horrendously slow or not display
12:42:04 <merijn> savanni: You could make it slightly nice by replacing nested "catch" with "catches", but that's a detail
12:42:06 <Ralith> solidus-river: the technical specifics, I mean
12:42:12 <Ralith> I'll probably explore them myself eventually
12:42:30 <merijn> savanni: Better yet, don't use "catch" for doing cleanup, but rely on bracket
12:42:35 <solidus-river> Ralith: i hang out here often, let me know if you make any headway :)
12:42:46 <Ralith> I'll try to remember
12:43:20 <CindyLinz> @src replicateM
12:43:21 <lambdabot> replicateM n x = sequence (replicate n x)
12:43:38 <CindyLinz> @src sequence
12:43:38 <lambdabot> sequence []     = return []
12:43:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:43:38 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:43:40 <merijn> warpy: TQueue has a finite size, TChan does not
12:44:06 <savanni> merijn: I was actually trying to do http://lpaste.net/104824 , but I haven't figured out exactly how to use it yet.
12:44:13 <CindyLinz> @src replicate
12:44:13 <lambdabot> replicate n x = take n (repeat x)
12:44:21 <monochrom> merijn: could it have been read from the doc of TQueue?
12:44:27 <savanni> (with `convertAll` being the functino I was trying to perfect)
12:44:27 <warpy> merijn: that is TBQueue
12:44:39 <merijn> warpy: Oh, hmm
12:44:53 <merijn> monochrom: Actually, I might just be wrong :D
12:45:11 <monochrom> what does the doc of TQueue say anyway? has anyone read it yet?
12:45:18 <warpy> A TQueue is like a TChan, with two important differences:
12:45:18 <warpy> it has faster throughput than both TChan.
12:45:18 <warpy> it does not provide equivalents of the dupTChan and cloneTChan operations.
12:45:30 <merijn> warpy: Right, so that's the difference
12:45:36 <monochrom> ok, that closes the ticket.
12:45:53 <warpy> so it is a faster but restricted TChan
12:46:08 <solidus-river> whats considered the "best" frp library currently (best in terms of performance / flexibility)
12:46:42 <plosi> Hey, I am relatively new to Haskell and the functional paradigm, and I am having trouble finding a task that I might be able to write a solution for to get some practical experience using monads without getting too complex since I'm still trying to fully get the concept. Any suggestions?
12:47:05 <jle`> plosi: just do normal projects
12:47:11 <Iceland_jack> plosi: Do you understand Functors?
12:47:14 <jle`> don't go out of your way to learn monads
12:47:18 <jle`> "learn monads"
12:47:24 <monochrom> plosi: consider something similar to my http://lpaste.net/52480
12:47:53 <hubblebee> Hi, reading http://alpmestan.com/2013/10/02/oh-my-laziness/ it says that a function like 'const x y = x' is strict in the first argument, is that true?
12:48:03 <hubblebee> i.e. does it evaluate whatever I pass for x?
12:48:03 <jle`> hubblebee: assuming that the result is evaluated
12:48:10 <monochrom> it is true
12:48:12 <Iceland_jack> You should have some understanding of type classes and functors before learning monads, monads shouldn't be a goal in and of itself
12:48:25 <monochrom> your understanding is false, however.
12:48:40 <conal> hubblebee: do you know what "strict" means?
12:48:41 <jle`> going out of your way to "learn monads" is probably a fruitless and unworthwhile venture
12:48:46 <Iceland_jack> indeed
12:49:06 <hubblebee> jle`: ah, so I can pass in a lazy result and not use it, in which case it won't be evaluated?
12:49:10 <Iceland_jack> plosi: How familiar are you with Haskell just to get an idea?
12:49:11 <monochrom> strict does not imply "must evaluate parameter". strict implies the weaker "must evaluate parameter, if the whole thing is evaluated"
12:49:25 <hubblebee> conal: I probably have misconceptions
12:49:39 <spion> how do I cabal remove?
12:49:41 <hubblebee> conal: my understanding is that 'strict' means 'this value will be evaluated when passed in'
12:49:42 <spion> :P
12:49:47 <jle`> in const x (const y z), if the whole thing is evaluated, y isn't evaluated
12:49:50 <conal> hubblebee: to say that a function f is "strict" exactly means that f undefined == undefined.
12:50:10 <conal> hubblebee: where "bottom" is another name for "undefined"
12:50:11 <spion> or rather, cabal uninstall
12:50:40 <plosi> Iceland_jack: I think I have a decent grasp on the concepts, I am just looking for a way to understand how and when to apply the concepts. And I have read through almost all of Learn You A Haskell and written some more basic programs
12:50:45 <jle`> spion: i'm pretty sure you can't, you cna only unregister
12:50:49 <zomg> spion: ghc-pkg unregister foo
12:50:59 <hubblebee> jle`: but the second call to const is evaluated?
12:51:01 <monochrom> if someone evaluates "const x blah", then someone evaluates x. otherwise, no one cares.
12:51:03 <conal> hubblebee: using this definition, you can plug in undefined for x in that definition of const, and you'll see that indeed it's strict "in x"
12:51:12 <spion> great
12:51:14 <jle`> > const 1 (const undefined 4)
12:51:16 <lambdabot>  1
12:51:20 <Iceland_jack> plosi: Basic answer is: how to use IO with the do-notation and without and don't worry about monads for a while
12:51:25 <Iceland_jack> *learn how
12:51:37 <jle`> plosi: do normal projects, do not go out of your way to find "projects with monads"
12:51:44 <Iceland_jack> Then you learn how to use other monads like Maybe and [] and (Either a)
12:51:51 <jle`> you'll eventually run into things that offer a monadic interface to make life easier
12:51:53 <hubblebee> conal: ah I see, so it's not necessarily talking about evaluation
12:51:56 <jle`> learn how to use those specific things
12:52:05 <hubblebee> conal: if const would "evaluate" undefined, it would also return undefined right?
12:52:22 <conal> hubblebee: it's a semantic notion, not an operational notion.
12:52:24 <jle`> don't sweat the fact that it's a monad, just be happy that Maybe, Either offer a neat interface
12:52:37 <Iceland_jack> plosi: Does this make sense to you?
12:52:37 <Iceland_jack>     getName :: IO String
12:52:37 <Iceland_jack>     getName = do
12:52:37 <Iceland_jack>       putStr "Enter your name: "
12:52:40 <Iceland_jack>       getLine
12:53:04 <monochrom> Iceland_jack: it could use a flush :)
12:53:06 <ajcoppa> plosi: if you've read through LYAH and are looking for the next way to deepen your knowledge, i really liked the exercises in brent yorgey's cis194 course, here: http://www.cis.upenn.edu/~cis194/lectures.html
12:53:09 <Iceland_jack> monochrom: hush ;)
12:53:15 <Iceland_jack> putStrLn* :)
12:53:21 <monochrom> that works too
12:53:25 <hubblebee> conal: I see, so what about multiple arguments, so the difference is when we have mulltiple arguments, as in (const x undefined)?
12:53:37 <hubblebee> conal: which in a strict langauge would be undefined, but not in a non-strict language
12:54:03 <Iceland_jack>     getName = do hFlush stdout; putStr "Enter your name: "; getLine ...
12:54:11 <Iceland_jack> ;D
12:54:15 <jle`> try doing it in a strict language...instead of undefined, use something like sum [1..1000000]
12:54:23 <jle`> or a sufficiently large number so your computer starts lagging
12:54:27 <hubblebee> conal, jle`: well, that clears it up, thanks!
12:54:39 <jle`> sum [1..2^256]
12:54:47 <conal> hubblebee: yeah. a "strict" language is one in which lambda isn't just abstraction, but adds strictness as well.
12:55:02 <plosi> Iceland_jack: yeah, I understand do notation and the basic concept of bind and monads, functors, and applicatives, its just when I start looking at how to combine monads and stuff like that to actually apply it it gets a little confusing to me
12:55:23 <Iceland_jack> plosi: okay then you just take it one step at a time, are you familiar with 'return'?
12:55:32 <Iceland_jack> @ty return
12:55:33 <lambdabot> Monad m => a -> m a
12:55:34 <hubblebee> conal: right, I understand strict langauges well, my mistake was that I thought strictness was about evaluation
12:56:13 <conal> hubblebee: the term is often used that way.
12:56:23 <plosi> Iceland_jack: Yeah, it puts a normal function in a basic monadic context, correct?
12:56:43 <Iceland_jack> just any expression :)
12:57:17 <Iceland_jack> so how would we implement 'return' for the Maybe monad?
12:57:17 <Iceland_jack>     returnMaybe :: a -> Maybe a
12:57:17 <Iceland_jack>     returnMaybe = ???
12:57:31 <jle`> plosi: because those concepts really don't have any real semantic meaning on their own. asking "what does it mean to apply/bind/return *them*" won't help you.  learning "what does it mean to return/bind to Maybe" will.  "what does it mean to return/bind Etiher" will.
12:57:45 <solidus-river> i dont get what this is doing
12:58:05 <jle`> trying to specifically seak out "what does it mean to (do monad-related thing) to "them"/all monads" won't give you any satisfying or understandable answer (yet)
12:58:09 <ajcoppa> totally agree with what jle` said
12:58:11 <Iceland_jack> indeed
12:58:12 <hubblebee> conal: so then this statemently isn't "strictly" :)) true? "But when a call to const is evaluated (that’s the situation we are interested in, here, after all), its return value is evaluated too; that return value happens to be x. So it’s strict in x.
12:58:31 <solidus-river> http://lpaste.net/104825
12:58:44 <ajcoppa> understanding how monads work with Maybe is a good start but wasn't sufficient for me to understand the mechanics of using State, as an example :)
12:59:00 <monochrom> every monad is unique
12:59:11 <Iceland_jack> Maybe is probably the nicest example to get a concrete feel for monads though
12:59:11 <solidus-river> Mu takes a functor and extends it in a way
12:59:11 <monochrom> every person is not, however!
12:59:26 <plosi> Iceland_jack: returnMaybe a = Just a
12:59:32 <Iceland_jack> I would suggest 'getting' functors first though since they're much simpler
12:59:33 <warpy> well, there are fewer monads than persons
12:59:35 <Iceland_jack> plosi: indeed
12:59:49 <plosi> jle`: I think I get what you're saying
12:59:52 <conal> hubblebee: i don't know what the writer might be trying to say -- what s/he means by "a call" or "a return value" being "evaluated". it might not be a precise idea.
12:59:59 <Iceland_jack> So if we think of 'Maybe a' as being something that may fail, 'returnMaybe' is something that always succeeds
13:00:25 <hubblebee> conal: that's unfortunately when you're trying to understand this stuff :)
13:00:32 <Iceland_jack> plosi: Now, how would you implement
13:00:32 <Iceland_jack>     bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
13:00:32 <Iceland_jack>     bindMaybe = ???
13:00:41 <Iceland_jack> @ty (>>=)
13:00:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:00:56 <solidus-river> yeah i'm lost on that
13:00:57 <hubblebee> conal: so let me ask you this, in the follow code: let a = const undefined y , does the "call to const" get "evaluated"?
13:00:58 <jle`> my road: Use normal types.  "this type offers some nice functions to use it easier."  "i like this function on this type, it makes things simpler."  "oh this function happens to be (>>=) and return from the monad typeclass? who cares! i just use it as if it was any other convenience function for this specific type"
13:01:03 <solidus-river> Mu takes an algebra that returns a
13:01:11 <solidus-river> and makes outF a wrapped version of itself
13:01:22 <conal> hubblebee: might be talking about some sort of operational model (which may or may not be consistent with GHC or another compiler). or might be talking about the language's denotation/meaning.
13:01:28 <hubblebee> conal: as in, does it actually take the 'x' parameter and return it unusused (ignoring inlining etc), or can a call itself "build a thunk"?
13:01:34 <solidus-river> then cata maps that over the mapping of that mapped with it as it as its input
13:01:37 <solidus-river> thats like, crazy
13:01:48 <rwbarton> hubblebee, you didn't give us enough code to know
13:01:54 <solidus-river> is there an easier way to put that using type synonims or better descriptions than just f and cata
13:02:08 <hubblebee> rwbarton: sorry, the code is the const example in http://alpmestan.com/2013/10/02/oh-my-laziness/
13:02:11 <solidus-river> i have 0 clue what cata f is doing or what Mu f is doing and i've been staring at that article for an hour or so
13:02:14 <hubblebee> rwbarton: const x y = x
13:02:49 <rwbarton> hubblebee, "let a = const undefined y" isn't an expression
13:03:18 <rwbarton> if you never use "a" anywhere, then of course that "call to const" will never get evaluated
13:04:09 <hubblebee> rwbarton: right, I guess what I'm asking is whether it will call const and assign the result (which may be lazy), or whether it will build a thunk that will call const when evaluated
13:04:24 <rwbarton> "let a = const undefined y" doesn't "do" anything at all
13:04:34 <jle`> assignment isn't a part of haskell semantics :)
13:04:38 <jle`> assignment doesn't exist
13:04:39 <hubblebee> Right, ok
13:04:41 <rwbarton> but, if I had to choose, I guess I would choose the latter
13:04:44 <jle`> only definition
13:04:58 <monochrom> there are no assignments in this course. only tests and more tests.
13:05:01 <hubblebee> jle`: a definition like a function definition?
13:05:08 <jle`> a definition like in math
13:05:32 <pk> hello
13:05:36 <guymann> hi
13:05:42 <jle`> "the definition of pi is the circumference of a circle divided by its radius"
13:05:51 <monochrom> I wonder if I should suggest my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
13:06:04 <plosi> Iceland_jack: bindMaybe (Just x) f = f x
13:06:20 <jle`> assignment is the imperative act of finding a box and putting a value into it for future use
13:06:30 <plosi> Iceland_jack: bindMaybe Nothing = Nothing
13:06:38 <Iceland_jack> plosi: lacking an argument :)
13:06:48 <Iceland_jack> but yes, that's the gist of it
13:07:43 <napping> jle`: how about "the definition of pi is the diameter of a circle divided by its radius"
13:07:47 <Iceland_jack> plosi: now try using the Maybe monad with do-notation!
13:08:03 <Iceland_jack> > do a <- Just 5; b <- Just 10; return (a + b)
13:08:05 <lambdabot>  Just 15
13:08:12 <Iceland_jack> > do a <- Just 5; b <- Nothing; return (a + b)
13:08:14 <lambdabot>  Nothing
13:08:23 <Iceland_jack> @undo do a <- Just 5; b <- Nothing; return (a + b)
13:08:23 <lambdabot> Just 5 >>= \ a -> Nothing >>= \ b -> return (a + b)
13:09:00 <Iceland_jack> you can replace that with
13:09:01 <Iceland_jack>     bindMaybe (Just 5) (\a -> bindMaybe Nothing (\b -> returnMaybe (a + b)))
13:09:01 <Iceland_jack> and you effectively have the same thing you just wrote plosi
13:09:08 <Smilex> Is it possible to run Haskell as a scripting language at runtime, instead of compiling it to a .so, with C?
13:09:09 <jle`> napping: :P
13:09:29 <monochrom> yes, use runghc
13:09:30 <napping> jle`: definitions can wrong :P
13:09:34 <monochrom> or runhugs
13:09:57 <plosi> Iceland_jack: Yeah, I think I've got the basic monadic stuff pretty much down with how do notation is basically just bind applied across multiple lines
13:10:06 <Smilex> monochrom: awesome. thanks!
13:10:27 <monochrom> (philosophy) what does "wrong definition" mean?
13:10:42 <Iceland_jack> plosi: now you just need to experiment with different monads, if you have a basic grasp of Maybe and 'Either a' and ((->) r) and IO then you should check out 'State s' and co.
13:11:22 <napping> monochrom: there are a few options. Are you really interested, or just joking too?
13:11:38 <monochrom> joking
13:11:49 <napping> My definition of pi is certainly wrong!
13:12:00 <ajcoppa> plosi: the NICTA course on haskell also has you implement functor, applicative, monad instances for gradually more complex types, and has been deeply instructive for me
13:12:36 <napping> monochrom: it's a plausible question
13:12:57 <plosi> ajcoppa: I'll look into that and the other one you recommended
13:13:40 <ajcoppa> sweet, hope they help
13:13:50 <plosi> Iceland_jack: Yeah, I guess I just really need to experiment with some other monads and gain some more intuition
13:14:33 <Iceland_jack> Exactly
13:15:10 <Iceland_jack> plosi: Here's a question, can you model mutable state without having a mutable reference?
13:15:24 * hackagebot HGamer3D-Data 0.3.2 - Game Engine for the Haskell Programmer - Data Definitions and Utilities  http://hackage.haskell.org/package/HGamer3D-Data-0.3.2 (PeterAlthainz)
13:15:26 * hackagebot HGamer3D-Ogre-Binding 0.3.3 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.3.3 (PeterAlthainz)
13:15:28 <Iceland_jack> If you're familiar with how the State monad works then this won't be as fun :)
13:15:41 <pjdelport> plosi: YMMV, but I find it often helps to understand something as a functor, and then layer the understanding of the applicative and monadic behavior on top of that.
13:16:35 <awestroke> the state-monad was very non-intuitive to me, really fun to grasp
13:16:45 <napping> awestroke: reverse-state?
13:16:49 <plosi> Iceland_jack: Yeah, I read about the State monad in LYAH, haha
13:16:54 <tdammers> costate :P
13:16:59 <Iceland_jack> damn!
13:17:03 <awestroke> napping: huh?
13:17:16 <Iceland_jack> plosi: if you grasp the state monad then you should try implementing it yourself
13:17:22 <napping> are you talking about the oridinary state monad, or the one that sends the state backwards?
13:17:25 <Iceland_jack> and then move to monad transformers
13:17:28 <ajcoppa> seriously, do NICTA. it is exactly what you want :)
13:18:02 <awestroke> napping: the ordinary. I did not know about a reverse-state monad
13:18:04 <napping> RState m >>= f = RState (\s -> let (a,s'') = m s' in case f a of RState m2 -> let (b,s') = m2 s in (b,s''))
13:18:17 <napping> that's way less intuititve
13:18:41 <awestroke> it's a cool concept
13:19:03 <plosi> Iceland_jack: I was trying to read about monad transformers a bit, but I haven't quite got those yet. But I think I have a general idea of how the State monad is implemented
13:19:09 <awestroke> are there any common use-cases for reverse state?
13:19:15 <napping> no
13:19:29 <awestroke> hah
13:19:33 <Iceland_jack> plosi: sounds like you're on quite a good track
13:19:36 <napping> I'm not sure if there are any decent use cases
13:19:43 <napping> you might use it for some lazy fixpoint stuff
13:19:57 <napping> but probably using a let around running an ordinary state monad would be better
13:19:59 <Iceland_jack> plosi: oh one thing, you may want to learn about '>=>' just for the laws to make sense
13:20:03 <hpc> there's a tardis monad that's reverse and forward state
13:20:06 <Iceland_jack> @src (>=>)
13:20:06 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
13:20:11 <napping> the reverse state lets you more or less make a fixpoint between any pair of statements
13:20:20 <hpc> i remember seeing something that claimed to be a useful example, but i forget what it was
13:20:23 <napping> do l <- get; put (1:l); return l  will build an infinite list
13:20:45 <napping> I think if you're doing that kind of knot-tying it's better to tie one knot explicitly at the top
13:21:08 <thoradam>  /LASTLOG NICTA
13:21:33 <awestroke> napping: what's a fixpoint?
13:21:45 <napping> let ones = 1:ones in ones
13:21:57 <Iceland_jack>     fix f = f (fix f)    -- inefficient
13:22:02 <napping> ones is the same as (1:ones), so it's a fixpoint of (1:)
13:22:11 <Iceland_jack> > fix (1:)
13:22:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:22:23 <conal> awestroke: a fixpoint for f is a solution to to f x = x
13:22:42 <pjdelport> awestroke: https://en.wikipedia.org/wiki/Fixed-point_combinator
13:22:56 <absence> http://lpaste.net/1304920637730455552 <- join' and merge are a bit too similar, is there anything clever i can do to make the code more concise?
13:23:03 <conal> awestroke: also called "fixed point", since it's a point that stays fixed (unchanged)
13:23:43 <awestroke> I understand the functions, I don't understand the underlying concept. what does "fixed" mean in this context? everything in haskell is fixed, in x=2, x is fixed
13:23:56 <napping> It's fixed by the function
13:24:26 <napping> Think of a function mapping input to output. The fixed points are the points that don't change
13:24:33 <napping> \x -> -x only fixes 0
13:24:36 <napping> \x -> x fixes every number
13:24:39 <mmachenry1> awestroke: Which is another way of saying "nothing is broken in Haskell" ;)
13:24:42 <napping> \x -> x + 1 doesn't fix any number
13:24:49 <mmachenry1> Also nothing is dysfunctional. :)
13:25:29 <ReinH> May be worth explaining which usage of "point" this is
13:26:13 <armlesshobo> i've used 'fix' when looping a lambda expression
13:26:18 <armlesshobo> only ever used*
13:26:31 <pjdelport> awestroke: "point" in this sense means the function's input and output values
13:26:43 <pjdelport> awestroke: It's highly related to https://en.wikipedia.org/wiki/Fixed_point_(mathematics)
13:26:51 <awestroke> point on 2d plane, like math graphs, then
13:27:50 <napping> I've used it most recently for a simple top-down typechecking thingy
13:28:20 <awestroke> trying to understand these examples: https://en.wikipedia.org/wiki/Fixed-point_combinator#Lazy_functional_implementation
13:28:46 <awestroke> isn't the result of fix f = f(f(f(f(f(f(...........
13:28:48 <awestroke> ?
13:28:52 <vanila> yes
13:28:55 <Cale> awestroke: yes, pretty much
13:28:58 <napping> A function takes a term and a map giving a type for each variable, everything but variables has a fixed type (and terms have subtyping). The function annotates types everywhere by pushing types down from the top, using supplied types from varibles if they are legal, and returning a map giving all the contexts/upper bounds on the variables
13:29:05 <conal> awestroke: neat, huh?
13:29:22 <awestroke> conal: seems useless to me actually
13:29:30 <conal> awestroke: how so?
13:29:30 <napping> I take the returned map, compute greatest lower bounds for all the variables, and pass it back down
13:29:41 <Cale> awestroke: another way to write fix is  fix f = x where x = f x
13:29:53 <Cale> awestroke: So it finds a fixed point of the function f
13:30:00 <napping> like let (term', varInfo) = assignTypes term' (computeBounds varInfo)
13:30:02 <awestroke> conal: is infinite function application, how can it ever be executed
13:30:06 <Cale> A value which f does not change
13:30:07 <napping> like let (term', varInfo) = assignTypes term (computeBounds varInfo) in term', rather
13:30:09 <vanila> awestroke, fix is useless because you can write   f x = ... (f x) ...  in haskell
13:30:09 <conal> awestroke: no?
13:30:13 <Cale> awestroke: consider something like  fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
13:30:20 <conal> awestroke: maybe you're used to strict languages.
13:30:45 <vanila> awestroke, but if you didn't have recursion, you could write a function g f x = ... (f x) ..., and fix g gives you that original recursive function
13:30:47 <Cale> awestroke: According to the definition I just gave, that's equal to x where x = (\fac n -> if n == 0 then 1 else fac (n-1)) x
13:30:49 <conal> even strict programming languages have at least one non-strict function. otherwise, no recursion would terminate.
13:31:04 <Cale> awestroke: Reducing the left hand side of that equation, we see:
13:31:04 <yac> what is show for? I come from python where we have __str__ to turn object into string and __repr__ to turn object into a string represenation of the object that is like for debugging and stuff
13:31:20 <Cale> x = \n -> if n == 0 then 1 else x (n-1)
13:31:27 <mhd> yac: Show is for both of those
13:31:33 <napping> yac: a bit of both. Often if you have a Read and a Show instance they are compatible
13:31:36 <mhd> yac: Often it pairs with Read
13:31:41 <yac> That's kind of undefined
13:31:44 <napping> other types just have a pretty Show
13:31:45 <awestroke> yac: show is kind of like __repr__ but the output format should match read such that show . read = id afaik
13:31:45 <monochrom> I wouldn't say that fix is useless. but I can say that fix is trivial.
13:31:50 <conal> awestroke: do you know about non-strictness (sometimes called "laziness")?
13:32:13 <monochrom> awestroke: have you read my http://www.vex.net/~trebla/haskell/fix.xhtml
13:32:13 <yac> what if I need to shove the value into a script or config file and I need to have it basicly as a string but not as a "string"
13:32:14 <awestroke> conal: I am very familiar with it
13:32:20 <napping> yac: If you have Read and Show you should show everything so you can read it back
13:32:23 <Cale> awestroke: Did you read my example?
13:32:26 <napping> otherwise there are no promises
13:32:35 <vanila> > fix ("hello world "++)
13:32:37 <lambdabot>  "hello world hello world hello world hello world hello world hello world hel...
13:32:44 <yac> show . read = id .. I like that
13:32:46 <yac> thanks
13:32:56 <vanila> yac, that's not true
13:33:04 <conal> awestroke: non-strictness is the answer to your question about infinite function applications.
13:33:05 <prophile> read . show = id surely
13:33:06 <Cale> > fix ((0:) . map (+1))
13:33:07 <vanila> you could hope for: read . show = id
13:33:07 <napping> yac: in particular, if you derive Read and Show for your types you'll get a well-behaved instance (as long as you only use well-behaved types)
13:33:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:33:19 <yac> anyway, I think the correct aproach for now is to define my typeclass for turning the types into specific format
13:33:31 <napping> there are also type classes like Binary specifically for serializing things
13:33:58 <ReinH> napping: how many types do you need to format like this?
13:34:09 <napping> ReinH: yac is formatting types
13:34:11 <Cale> > fix ((1:) . map (*2))
13:34:12 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:34:27 <ReinH> Argh
13:34:30 <napping> > ((1:) . map (*2)) undefined
13:34:32 <lambdabot>  [1*Exception: Prelude.undefined
13:34:49 <ReinH> yac: how many types do you need to format like this?
13:34:58 <yac> lots
13:35:00 <Cale> > ((1:) . map (*2)) (((1:) . map (*2)) undefined)
13:35:02 <lambdabot>  [1,2*Exception: Prelude.undefined
13:35:04 <napping> yac: if you want a specific format then defining your own typeclass is a decent way to go (or maybe just write separate formatting functions)
13:35:08 <awestroke> monochrom: thanks, will read
13:35:10 <Cale> > ((1:) . map (*2)) (((1:) . map (*2)) (((1:) . map (*2)) undefined))
13:35:11 <yac> well, order of ones to tens
13:35:12 <lambdabot>  [1,2,4*Exception: Prelude.undefined
13:35:27 <napping> oh, I think there are also thingies that use Generic/Data to print any instances of those in regular ways
13:35:39 <ReinH> you can write a sum type to wrap them and have a single function on it
13:37:07 <awestroke> conal: it seems to me the non-strictness only applies if the function constructs something like a tree or a list, if f = (*2) there-s an infinite loop
13:38:10 <napping> awestroke: yeah, fix doesn't do anything useful on strict functions
13:38:11 <conal> awestroke: there is always a unique least fixed point, where "least" refers to information ordering (less informative than but consistent with).
13:38:15 <monochrom> if f = const 2, you still get non-strictness and a good answer
13:38:16 <ReinH> awestroke: yes, guarded recursion is useful here
13:38:46 <napping> If f can't return any part of it's answer before examining the argument, you will get an infinite loop
13:38:53 <conal> awestroke: "strict" means that bottom is a fixed point. and hence the least fixed point.
13:39:02 <napping> or a <<loop>> error if you are lucky
13:42:33 <conal> awestroke: since (*2) is strict, fix (*2) == bottom. there are non-strict functions on Integer, but (*2) isn't one.
13:42:34 <Kaidelong> okay so I have this situation
13:42:50 <Kaidelong> certain IO action happens, now I have data that, if anything still refers to it, it really shouldn't
13:42:57 <napping> The only non-strict function on Integer is const
13:43:18 <Kaidelong> I would like to open this up to the GC and have there be an error if the pointer to it is derefenced from then on
13:43:20 <napping> or is that not true?
13:43:30 <Kaidelong> Right now I'm mocking this with IORef .: Maybe
13:43:34 <awestroke> napping: or    (++) (show x)
13:43:43 <napping> the only non-strict functions from Integer to Integer are constant functions
13:43:47 <Kaidelong> but you could hang on to the inner maybe somewhere so this isn't very satisfactory
13:43:52 <Kaidelong> is there a better way to do this?
13:44:18 <Kaidelong> (linear types would be awesome but not in haskell unfortunately)
13:44:20 <mmachenry> napping: (+) is strict?
13:44:30 <napping> Depends on the Num instance, but usually
13:45:06 <conal> lazy numbers are very useful, but they're rarely used.
13:45:43 <conal> for instance (length [0 .. ] > 3) == True for lazy naturals
13:46:21 <Ainieco> why it's a bottom?  liftM (take 1) (sequence . repeat $ print "1")
13:46:40 <Ainieco> does "sequence" needs to evaluate everything?
13:46:50 <Kaidelong> depends if (>>=) is strict
13:46:51 <rwbarton> it needs to *execute* everything
13:46:52 <Kaidelong> in IO, it is
13:46:55 <napping> sequence does try to return a list of everything
13:47:04 <conal> "What About the Natural Numbers" by Colin Runciman: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.3442
13:47:06 <Kaidelong> there are non strict >>=
13:47:08 <Kaidelong> [] has one
13:47:27 <Kaidelong> IO could have one in theory but it turns out to be a really stupid idea in practice
13:47:32 <rwbarton> strictness is sort of a red herring here
13:47:45 <rwbarton> semantically (sequence . repeat $ print "1") is an action that prints 1 infinitely many times
13:48:01 <rwbarton> you can't access the result of this action until it's finished
13:48:09 <napping> my ghci starts printing for either of those
13:48:17 <Kaidelong> forever $ print "1" --equivalent
13:48:35 <napping> As you wrote it or changing to sequence_ and (const 'x')
13:48:37 <monochrom> yes, it starts printing right away. the surprise is it doesn't stop printing
13:48:47 <rwbarton> napping: right, that too, liftM (take 1) (sequence . repeat $ print "1") isn't actually bottom at all
13:48:48 <napping> that shouldn't be a surprise
13:48:51 <napping> if you sequence and repeat
13:49:18 <Ainieco> took me couple of hours to catch it :)
13:49:42 <Ainieco> so for some monads sequence is lazy and for some it isn't, right?
13:49:45 <monochrom> "haskell is lazy" has wasted a lot of people's time
13:50:14 <Kaidelong> @ty sequence . repeat
13:50:15 <lambdabot> Monad m => m a -> m [a]
13:50:27 * hackagebot git-annex 5.20140529 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140529 (JoeyHess)
13:50:43 <napping> sequence . repeat is a bad idea
13:50:46 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#lazynot
13:50:56 <Kaidelong> rwbarton: I don't know what you mean by not bottom, but I'm pretty sure that wouldn't actually work like how a person would think it might
13:51:01 <Kaidelong> it'd still loop forever, won't it?
13:51:16 <rwbarton> it does stuff forever
13:51:22 <napping> yeah, but sequence may chew up lots of space accumulating a list of results anyway
13:51:24 <Kaidelong> (sequence . repeat $ print "1") >>= \x -> take 1 x
13:51:34 <Kaidelong> it doesn't fetch the first () from the [()] returned
13:51:37 <napping> forever or perhaps sequence_ . repeat wouldn't
13:51:40 <Kaidelong> it "returns bottom"
13:51:55 <napping> In what sense does it even return?
13:52:02 <Kaidelong> hence the quotes
13:52:09 <napping> it ""returns" bottom"
13:52:41 <Kaidelong> liftM (take 1) (sequence . repeat $ print "1") is semantically the same as (forever $ print "1")
13:52:41 <Ainieco> is there a way to build inifinite list of State actions and "take" from it without evaluating whole list?
13:52:42 <napping> but I do like
13:52:43 <napping> :t forever
13:52:44 <lambdabot> Monad m => m a -> m b
13:52:47 <Kaidelong> you cannot observe a difference between the two
13:53:03 <napping> Kaidelong: except perhaps running out of heap with the former
13:53:07 <monochrom> benzrf: see the conversation right above. it is the reason I said that "return" is better off a foreign language word.
13:53:19 <Kaidelong> the type is more specialized but it unifies with the type of forever $ print "1"
13:53:28 <rwbarton> Ainieco, yes but I don't think you said what you meant
13:53:40 <napping> Okay, *** Exception: stack overflow
13:53:45 <Kaidelong> and this has everything to do with >>= being strict in its first argument
13:53:57 <napping> liftM (take 1) (sequence . repeat $ return ())
13:54:13 <napping> didn't take too long from that either (with print it would have been slowed a bit by the terminal)
13:54:32 <Ainieco> liftM (take 1) (liftM (repeat) (print "1"))
13:54:43 <rwbarton> Ainieco, you can certainly take from an infinite list of State actions
13:55:00 <Kaidelong> you could come up with some kind of asynchronous IO monad where liftM (take 1) (sequence . repeat $ print "1") does return something
13:55:11 <Kaidelong> but you'd be making >>= non-strict
13:55:16 <McManiaC> what is the goto library for SQL these days? hdbc?
13:55:39 <Ainieco> rwbarton: yeah, sorry. nevermind that, just too tired to think properly.
13:55:43 <Ainieco> thank you guys!
13:56:07 <rwbarton> you probably meant something like, can you 'sequence' an infinite list of State actions, and then do something with the result
13:56:22 <kadoban> McManiaC: There didn't seem to be a strong consensus last I looked, but HDBC worked for me on my last project
13:56:24 <Kaidelong> @hoogle scanM
13:56:26 <lambdabot> No results found
13:58:10 <yac> how to export all module constructors?
13:58:33 <rwbarton> Kaidelong: "returning bottom" is not a problem for IO: return undefined >> print "hello" -- will work fine
13:58:55 <yac> oh
14:01:25 <yac> hm, I seem to have some trouble export a type alias
14:01:28 <Kaidelong> rwbarton: Oh okay, I learned something new
14:01:36 <Kaidelong> I am not sure that's a good thing
14:01:59 <Kaidelong> I was expecting there should have been an error and I think there should have been
14:02:30 <yac> hrm, if I type UseFlag = String, then I can't use UseFlag as a constructor
14:02:37 <rwbarton> execution and evaluation are separate
14:03:17 <rwbarton> executing m >>= f will first execute m. to do this, it'll have to evaluate it some perhaps. it won't evaluate the result of m
14:03:29 <rwbarton> it will just pass it unevaluated to f, and then execute the resulting action
14:03:39 <geekosaur> yac: correct, it's not a constructor, it's an alias. UseFlag would mean precisely the same thing as String when used in a type; as you do not have a constructor for String, you would not have one for UseFlag
14:03:57 <Kaidelong> rwbarton: Indeed, "throw (undefined :: SomeException) >> print "hello"" works the way I would expect
14:03:57 <geekosaur> were you perhaps looking for newtype>?
14:04:22 <Kaidelong> I guess I can see how this works
14:04:32 <Kaidelong> undefined is not evaluated, so it never pushes an error to IO
14:04:43 <Kaidelong> it is kind of troubling that you can tell if something was evaluated or not with IO but
14:04:53 <Kaidelong> the tradeoffs to eliminating that would probably not be worth it
14:05:55 <Kaidelong> in particular you'd have to get rid of non-strict evaluation entirely
14:06:17 <rwbarton> tell if something was evaluated or not with IO how?
14:06:53 <Kaidelong> rwbarton: in "return undefined >> print "hello"" you can tell that undefined was never evaluated because it printed "hello"
14:07:19 <danilo2> hello! :) Is there any mechanism in Haskell which allows creating bordered values? By bordered value I mean for example custom datatype "data X = X Float" which is valid for floats in range [0,1] only. Is there any fancier method than just hiding the constructor and creating a method and checking the value inside?
14:07:28 <Kaidelong> you could generalize this using seq
14:07:32 <Kaidelong> to make a test for evaluation
14:07:52 <rwbarton> Kaidelong: oh, well, that is kind of a result of being able to observe what values our programs produce, no?
14:07:58 <Kaidelong> return some_expr >>= \x -> x `seq` print "some_expr evaluated to WHNF"
14:08:01 <geekosaur> danilo2: possibly some hairy type level stuff, but generally no, there's no subtyping
14:08:32 <rwbarton> even if the only program I was allowed to write was "main = print <expr>"
14:08:34 <Kaidelong> if you know some parts of some_expr aren't defined
14:08:41 <Kaidelong> if that succeeds you know those parts were never evaluated
14:08:49 <bergmark> danilo2: you want dependent types
14:09:11 <monochrom> Kaidelong: if you need seq to make your point, then your point is caused by seq, not by IO. the contribution of IO is the tautological: to make the observable observable.
14:09:45 <Kaidelong> monochrom: fair enough, I guess seq violates all sorts of guarantees
14:10:04 <rwbarton> only polymorphic seq
14:10:19 <rwbarton> for ordinary types you can define seq manually anyways
14:10:28 <mmachenry> What guarantees does seq violate?
14:10:34 <danilo2> geekosaur, bergmark: Ok, thank you! bergmark  thanks for naming the thing I'm looking for!
14:11:20 <rwbarton> Kaidelong: consider for example   if x then {- ... -} else {- ... -}
14:11:25 <rwbarton> in either branch I know that x has been evaluated
14:27:45 <Kaidelong> @src fromJust
14:27:46 <lambdabot> fromJust Nothing  = undefined
14:27:46 <lambdabot> fromJust (Just x) = x
14:30:52 <benzrf> hmmmmm
14:31:33 <monochrom> benzrf, were you the one asking me about return in my IO.xhtml?
14:31:40 <benzrf> yep
14:31:49 <monochrom> ok, then I've remembered right
14:34:04 <benzrf> :k S
14:34:06 <lambdabot> Not in scope: type constructor or class ‘S’
14:34:50 <benzrf> @let data S n where Z :: S Void; S :: S n -> S (S n)
14:34:51 <lambdabot>  .L.hs:149:16: Not in scope: type constructor or class ‘Void’
14:35:08 <benzrf> @let data Void
14:35:09 <lambdabot>  Defined.
14:35:11 <benzrf> @let data S n where Z :: S Void; S :: S n -> S (S n)
14:35:12 <lambdabot>  Defined.
14:35:13 <benzrf> hmm
14:35:20 <benzrf> :t S (S Z)
14:35:21 <lambdabot> S (S (S Void))
14:35:41 <benzrf> not quite right...
14:35:43 <benzrf> =.=
14:36:23 <benzrf> :t fromInteger
14:36:24 <lambdabot> Num a => Integer -> a
14:36:46 <rwbarton> you want Z :: S n I think
14:36:50 <benzrf> oh right
14:36:53 <benzrf> @unlet
14:36:53 <lambdabot>  Define what?
14:36:58 <benzrf> @unlet S
14:36:58 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:37:03 <benzrf> @unlet data S
14:37:04 <lambdabot>  .L.hs:154:1:
14:37:04 <lambdabot>      Multiple declarations of ‘S’
14:37:04 <lambdabot>      Declared at: .L.hs:150:1
14:37:04 <lambdabot>                   .L.hs:154:1
14:37:07 <benzrf> ffff
14:37:21 <rwbarton> is @unlet even a command
14:37:27 <benzrf> @undef
14:37:28 <lambdabot> Undefined.
14:37:31 <benzrf> @undef S
14:37:31 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:37:35 <benzrf> fuck
14:37:41 <benzrf> @let Void
14:37:42 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:37:44 <benzrf> @let data Void
14:37:46 <lambdabot>  Defined.
14:37:56 <rwbarton> I think it was getting typo-corrected to @let maybe
14:38:04 <benzrf> @let data S n where Z :: S n; S :: S n -> S (S n)
14:38:05 <lambdabot>  Defined.
14:38:19 <benzrf> @let instance Num (S n) where fromInteger 0 = Z; fromInteger n = S (fromInteger (n - 1))
14:38:20 <lambdabot>  .L.hs:155:25:
14:38:20 <lambdabot>      Couldn't match type ‘n’ with ‘S n0’
14:38:20 <lambdabot>        ‘n’ is a rigid type variable bound by
14:38:20 <lambdabot>            the instance declaration at .L.hs:153:10
14:38:20 <lambdabot>      Expected type: S n
14:38:23 <benzrf> awwww
14:39:00 <benzrf> :t S (S Z)
14:39:01 <lambdabot> S (S (S n))
14:39:24 <benzrf> maybe a type family would work better here
14:42:50 <brrrrrian> hellooooooo #haskell
14:43:06 <benzrf> hellooooooo brrrrrian
14:43:33 <brrrrrian> I want to write code that will make the compiler go into an infinite loop.
14:43:38 <brrrrrian> Can someone please help me
14:43:41 <brrrrrian> http://lpaste.net/104829
14:44:31 <brrrrrian> I want to make every instance of Enum also an instance of Binary
14:44:35 <taktoa>  main = main
14:44:45 <silasm> taktoa: the compiler, not the runtime
14:44:50 <taktoa> ah
14:45:08 <taktoa> wasn't paying a huge amount of attention
14:45:25 <silasm> yeah, that was my first reaction too, no worries.
14:45:50 <brrrrrian> relevant SO: http://stackoverflow.com/questions/3213490/how-do-i-write-if-typeclass-a-then-a-is-also-an-instance-of-b-by-this-definit
14:46:22 <brrrrrian> but I am just not smart enough to get the newtype mechanism working
14:46:33 <brrrrrian> enlighten me plz
14:49:33 <benzrf> brrrrrian: it is fairly simple
14:49:50 <benzrf> brrrrrian: let's say you want to make automatic applicative instances for monad
14:49:53 <benzrf> brrrrrian: ok?
14:50:10 <brrrrrian> way over my head
14:50:30 <funfunctor> hi, simple question I forgot.. What is the syntax for the polymorphic type-signature to restrict foo :: Ord a -> [a] -> a to only 5 elements in its domain?
14:50:34 <benzrf> brrrrrian: basically, you want to make it so that if T has a monad instance, then it will automatically also be an instance of Applicative
14:50:45 <brrrrrian> i get what you are saying, but I am not very familiar with the definitions of Applicative
14:50:49 <benzrf> brrrrrian: it's ok
14:50:52 <brrrrrian> ya
14:50:54 <benzrf> we won't worry about the specific methods :u
14:50:57 <benzrf> just example classes
14:50:58 <jle`> funfunctor: do you mean foo :: Ord a => [a] -> a ?
14:51:07 <benzrf> brrrrrian: this is what you do.
14:51:18 <funfunctor> jle`: yes sorry typo..
14:51:35 <benzrf> brrrrrian: first, make a newtype wrapper like so 'newtype WrappedMonad t = {unwrapMonad :: t}'
14:51:38 <jle`> funfunctor: five elements in its domain...do you mean the list has to be 5 or less elements long?
14:51:42 <benzrf> brrrrrian: so basically similar to identity
14:51:51 <funfunctor> jle`: how to restrict to exactly 5
14:51:57 <benzrf> brrrrrian: good so far?
14:52:00 <|akh|> Hi, I would like to maintain a timer in an explicitly recursive function. Can anyone point me at a suitable module?
14:52:01 <brisbin> funfunctor: Ord a => (a,a,a,a,a) -> a -- ?
14:52:18 <funfunctor> oh wait, is it something like { a = 5 }
14:52:28 <brrrrrian> benzrf: ya
14:52:31 <funfunctor> brisbin: yea is there a cleaner way to say that?
14:52:31 <benzrf> brrrrrian: ok
14:52:46 <benzrf> brrrrrian: now we make 'WrappedMonad' an instance of Applicative like this:
14:52:49 <brisbin> funfunctor: not that i'm aware of. sure you don't want to ask in #idris ?
14:52:50 <rwbarton> funfunctor: you made this up, or you're using LiquidHaskell or something
14:53:00 <jle`> newtype FiveElem a = Five (a,a,a,a,a)
14:53:06 <jle`> foo :: Ord a => FiveElem a -> a :)
14:53:10 <benzrf> instance Applicative WrappedMonad where (<*>) = ap
14:53:18 <benzrf> brrrrrian: because
14:53:21 <benzrf> :t (<*>)
14:53:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:53:23 <benzrf> :t ap
14:53:24 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:53:36 <benzrf> brrrrrian: however, this will not work
14:53:43 <funfunctor> brisbin: but I am not using Idris (and I know it supports type-dep) so no..
14:53:54 <benzrf> because the compiler doesn't know that t will be a monad
14:53:58 <funfunctor> jle`: ok I need to declare a new type fine
14:54:11 <jle`> you can't use [] to enforce a number of elements at compile time
14:54:22 <jle`> you can make assertions
14:54:25 <jle`> like
14:54:26 <benzrf> brrrrrian: wait fuck i did that wrong
14:54:29 <brrrrrian> instance Monad t => Applicative WrappedMonad t where .. ?
14:54:37 <jle`> foo xs | length xs == 5 = ....
14:54:42 <benzrf> brrrrrian: let's go with 'newtype WrappedMonad m a = {unwrapMonad :: m a}'
14:54:43 <benzrf> brrrrrian: :P
14:54:48 <jle`>        | otherwise     = error "not five elements"
14:54:58 <jle`> but those are run-time
14:55:06 <jle`> and is probably a very bad idea
14:55:12 <benzrf> brrrrrian: would you prefer to use the 'MyClass' and 'Show' in the SO question?
14:55:12 <Kaidelong> a constraint of (HasTime Double s) => requires FlexibleInstances, right?
14:55:17 <jle`> so...forget i said anything
14:55:25 <Kaidelong> err
14:55:28 <Kaidelong> FlexibleContexts
14:55:29 <Kaidelong> I mean
14:55:43 <brrrrrian> benzrf: ya
14:55:48 <rwbarton> Kaidelong: yes
14:55:53 <benzrf> brrrrrian: ok
14:56:04 <funfunctor> jle`: yes I want to encapsulate in-type
14:56:20 <funfunctor> jle`: many thanks
14:56:25 <benzrf> brrrrrian: so 'newtype WrappedMyThingy t = {unwrapMyThingy :: t}'
14:56:26 <benzrf> brrrrrian: then
14:56:44 <benzrf> instance Show (WrappedMyThingy t) where show = showFromMyClass
14:56:59 <benzrf> brrrrrian: however, this will not work, because the compiler can't be sure that t is an instance of MyClass
14:57:04 <benzrf> brrrrrian: so instead, you write
14:57:13 <benzrf> instance MyClass t => Show (WrappedMyThingy t) where show = showFromMyClass
14:57:23 <brrrrrian> benzrf: ya i grok
14:57:26 <benzrf> brrrrrian: kk
14:57:42 <benzrf> brrrrrian: then, if you want to Show a MyClass isntance, you stick it in a WrappedMyThingy
14:57:48 <benzrf> brrrrrian: and it becomes an instance
14:58:14 <Kaidelong> are there any situations where a context like that actually makes type inference undecidable?
14:58:30 <Kaidelong> I'm guessing FlexibleContext has to allow more than that for it to be a problem
14:58:48 <Kaidelong> the specific case of having a concrete argument to a multi param type class seems perfectly safe
14:58:51 <rwbarton> FlexibleContexts isn't a problem
14:58:58 <rwbarton> it's just not part of the Haskell language standard
14:59:04 <benzrf> brrrrrian: i have to go or my parents will literally rip the laptop from my hands
14:59:05 <brrrrrian> benzrf: dont you have to use unwrapThingy somewhere?
14:59:08 <benzrf> brrrrrian: yeah
14:59:09 <benzrf> GL with your haskells
14:59:16 <benzrf> brrrrrian: it was simplified, my bad :p
14:59:18 <brrrrrian> OK thanks
14:59:19 <benzrf> see u
14:59:37 <rwbarton> (note that multiparameter type classes are also not part of the standard)
15:05:48 <Pythonfant> I know this is not a channel for haskell-mode but I guess there are quite a few people here using it, so I'm going to ask anyway: Is there a way to get the repl to not lose everything defined when I reload a file with C-c C-l?
15:05:50 <eizo> if i have functions which change the state and give a value : State -> (State,Value), how can i apply them in sequence (if i don't care about the intermediary values)
15:06:09 <napping> nope, you lose stuff when GHCi reloads
15:06:50 <napping> nothing to do with haskell-mode.
15:07:01 <Pythonfant> napping: hm k
15:07:32 <napping> I just successfully joined #haskell-emacs, but it's pretty small
15:08:05 <Pythonfant> there's really an irc channel for everything :)
15:09:30 <Polarina> eizo, the State monad is just what you want.
15:12:02 <eizo> Polarina: say my set of states is Q so that we don't confuse it with the monad, then the instance of monad i need is State Q Value?
15:13:40 <Polarina> eizo, yes.
15:14:09 <ReinH> Pythonfant: isn't that more of a ghci question than an emacs question?
15:14:27 <ReinH> And I don't know of a way to do that in ghci, but someone else might
15:14:31 <Polarina> eizo, although you don't need to define any instances yourself. The mtl library has what you need.
15:14:47 <eizo> right thanks
15:15:29 <Pythonfant> ReinH: I guess you're right
15:16:53 <eizo> Polarina: i'm a bit confused, because in the state monad, the state part in the part which we don't care about in our functions (it's the additional stuff which is kept around), but in my case the state is all that matters, and the value is the additional thing (but this value doesn't have to be kept around)
15:18:31 <EvanR> the bosses kid came in earlier and had apprently made a video game in the website "wescheme" which turns out to be a real scheme environment. interesting to note a "recipe" button asking you type in a "contract" for you function
15:18:36 <eizo> nvm i think i get it, the state part is really the state
15:18:49 <funfunctor> so this randomly picks the first time and is const after.. https://gist.github.com/victoredwardocallaghan/c251fb1f8dc22939faf0 something to do with lazy evulation?
15:18:56 <EvanR> of the form <fname> : <domain> -> <range>
15:19:11 <EvanR> scheme for elementary kids with types
15:19:20 <Polarina> eizo, rather than having a function such as { f :: a -> Q -> (b, Q) }, you use the state monad, so that it'll look like { f' :: a -> State Q b }. The state is carried implicitly in the monad.
15:19:22 <EvanR> i was floored
15:19:24 <funfunctor> also, how do I wrap that up in a IO Monad?
15:19:49 <funfunctor> actually maybe not IO, but a monad atleast
15:20:20 <eizo> Polarina: newtype State s a = State { runState :: s -> (a, s) } so my functions are of type State Q Value right?
15:20:51 <Polarina> eizo, if they take no input, other than the implicit state, then yes.
15:21:34 <jle`> funfunctor: do you mean the list is of the same element repeated forever?
15:21:37 <Polarina> eizo, your functions can access and modify the state with the get and put functions.
15:21:45 <eizo> then i need a function Q -> State Q Value -> (Q,Value) (to evaluate the function), and likewise but for several functions
15:21:46 <funfunctor> jrslepak: yes
15:21:53 <funfunctor> sorry jle` yes
15:21:54 <ReinH> funfunctor: you are using the same generator
15:22:09 <ReinH> it will happily continue to generate the same next value every time
15:22:42 <ReinH> Wait, you are using randoms
15:22:57 <Polarina> eizo, why not just use runState? https://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-State-Lazy.html#v:runState
15:25:07 <eizo> yes makes sense
15:25:29 <eizo> if i want to apply several functions in sequence now, do i need to use something like
15:25:30 <eizo> :t (>>=)
15:25:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:26:08 <jle`> it looks like getStdGen seems to produce the same seed every time
15:26:14 <eizo> hm no i don't see it
15:26:18 <Polarina> eizo, you can use either (>>) or (>>=). You can also use the 'do' syntax.
15:26:24 <jle`> the seed is initialized once on program startup
15:26:36 <Polarina> eizo, monads are also applicatives, so you can use those too.
15:26:51 <funfunctor> jle`: that sucks
15:26:59 <eizo> :t (>>)
15:27:01 <lambdabot> Monad m => m a -> m b -> m b
15:27:01 <jle`> nah, it's useful :)
15:27:06 <jle`> there are functions that produce new seeds too
15:27:10 <eizo> thanks Polarina i'll try to figure it out
15:27:30 <jle`> newStdGen
15:27:35 <jle`> newStdGen :: IO StdGen
15:27:38 <Polarina> eizo, best of luck. :)
15:28:17 <jle`> getStdGen "gets" the globally initialized generator, newStdGen creates a new one
15:28:21 <eizo> :)
15:28:28 <dmj`> there's randomRIO too...
15:28:50 <jle`> oh yeah that too, is probably better if you're just doing one thing
15:28:53 <dmj`> grabs a new number out of I/O each time
15:28:56 <jle`> http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html
15:29:05 <Kaidelong> jle`: does it look horribly wrong if I'm doing something like "modifyIORef $ \w -> w . force . at t eventdata"
15:29:12 <dmj`> or just pass the seed around in a state monad and call next on it
15:29:40 <Kaidelong> I guess it should be force . w . at t eventdata
15:29:42 <Kaidelong> but other than that
15:30:07 <funfunctor> jle`: ah that fixed it thanks!
15:30:38 * hackagebot tidal 0.4.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.1 (AlexMcLean)
15:30:53 <jle`> Kaidelong: have to run, sorry, but i'll look at it later
15:30:56 <jle`> btw, are you aware of #haskell-game ?
15:30:59 <funfunctor> jle`: now encapsulation, how can I better encapsulate this?
15:31:01 <Kaidelong> no I am not!
15:31:15 <jle`> mm_freak, the author of netwire, hangs out there
15:31:23 <jle`> and also some other netwire people
15:31:27 <jle`> so you might have luck there with questions like this
15:31:34 <solidus-river> how would you guys choose between Yampa, netwire, and ReactiveBanana
15:32:03 <jle`> yampa is considered out of date, i think
15:32:23 <Kaidelong> there honestly weren't any good resources for deciding in my case solidus-river
15:32:25 <jle`> netwire is for continuous-time frame-driven stuff and...reactive-banana and sodium etc. are for callback/event-based stuff
15:32:38 <ReinH> jle`: but randoms should just take a single gen
15:32:45 <Kaidelong> in the end I went with netwire because inhibition is cool but looking back on it I should probably have used reactive-banana
15:32:48 <jle`> ReinH: oh
15:32:52 <jle`> ReinH: yeah, you're right.
15:32:55 <ReinH> > take 10 $ randoms (mkStdGen 10) :: [Int]
15:32:55 <solidus-river> which would you choose between reactive-banana and sodium
15:32:56 <lambdabot>  [-2776415066813205131,-8883108635655729860,-2410613080667970943,-28290923353...
15:33:07 <dmj`> > round 10.5
15:33:07 <solidus-river> sodium looks like its not ready for use yet based on its hackage page
15:33:09 <lambdabot>  10
15:33:13 <dmj`> > round 10.4
15:33:14 <lambdabot>  10
15:33:18 <dmj`> > round 10.6
15:33:20 <lambdabot>  11
15:33:20 <ReinH> I can't see an obvious problem with the definition of randomR but it must exist
15:33:26 <dmj`> why doesn't 10.5 round up?
15:33:26 <jle`> Kaidelong: actually implicit inhibition is not too cool anymore actually
15:33:38 <jle`> apparently
15:34:00 <rwbarton> round-to-even is the standard default rounding mode
15:34:09 <rwbarton> > round 11.5
15:34:10 <lambdabot>  12
15:34:16 <jle`> i did not know that
15:34:18 <Kaidelong> jle`: all the worse for me then, it was my own judgement, not so much because I intensely researched the issue. Unfortunately, it seems there are no good resources for comparing different FRP implementations to one another
15:34:22 <dmj`> rwbarton: woa...
15:34:27 <jle`> Kaidelong: unfortunate!
15:34:28 <jle`> :(
15:34:36 <ReinH> jle`: actually actually?
15:34:37 <solidus-river> Kaidelong: what makes you wish you chose reactive banana / what sort of stuff are you trying to do with frp
15:35:15 <Kaidelong> solidus-river: the library I'm binding to is highly imperative and has a mix of callback/push and pull/poll functionality, which netwire isn't terribly well suited to
15:35:35 <jle`> ReinH: yes, actually^2
15:36:25 <Kaidelong> solidus-river: the ideal library in my case would be something more akin to conal's TVs
15:37:02 <Kaidelong> netwire is more like yampa
15:37:59 <Kaidelong> it's very good for describing flows of computation so long as you eventually have a single point of input and output, it's less good for dealing with producers and consumers as distinct entities
15:38:44 <solidus-river> Kaidelong: interesting
15:38:45 <Kaidelong> it handles switching by producing a new network every time it is stepped, kind of analogous to how the state monad works
15:39:06 <Kaidelong> (inhibition is the cool feature that helps make switching easier to reason about)
15:39:19 <solidus-river> Kaidelong: that sounds inneficient
15:40:12 <Kaidelong> I may be completely wrong about this, but it's the impression I got using it and reading the docs
15:40:20 <Kaidelong> however given the way haskell works
15:40:26 <Kaidelong> it probably isn't inefficient at all
15:40:39 * hackagebot HCodecs 0.5 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.5 (GeorgeGiorgidze)
15:41:12 <Kaidelong> no mutation means all you need to track are deltas
15:41:28 <Kaidelong> you don't need to copy the entire thing over and over
15:45:40 * hackagebot tidal 0.4.2 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.2 (AlexMcLean)
15:50:40 * hackagebot tidal 0.4.3 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.3 (AlexMcLean)
15:53:42 <taktoa> quick updates
15:53:49 <taktoa> two minor versions in 5 minutes
15:58:42 <awestroke> there was no documentation in 0.4.2
15:58:55 <awestroke> I thought hackage 2 would allow updating an existing version
16:08:12 <Eiam> has anyone read http://www.amazon.com/Beginning-Haskell-A-Project-Based-Approach/dp/1430262508/ref=sr_1_2?ie=UTF8&qid=1401404754&sr=8-2&keywords=haskell ? is it a worthwhile purchase?
16:09:52 <kadoban> Eiam: Personally that seems like a /lot/ of stuff it covers in not too many pages.  What background are you coming from?
16:10:39 <Eiam> kadoban: been using Ruby for a few years, Obj-c off & on, python a few years ago, formal Comp Sci education for 4 years, C++, linked lists, basic sorts like bubble, merge, basic recursion
16:10:55 <Kaidelong> so when I try to derive Enum for a record type, haskell just throws in the towel and doesn't even try
16:11:00 <Kaidelong> why does this happen?
16:11:21 <hpc> are the elements all Enum?
16:11:23 <Kaidelong> (all the fields in it are bools, it should be trivial)
16:11:34 <hpc> maybe it can't order the fields
16:11:38 <kadoban> Eiam: Have you looked at Real World Haskell or Learn You a Haskell? Those seem to be the standard texts.  My only concern is...that book seems to spend not much time at all on basics, just going from the table-of-contents.
16:11:45 <hpc> in fact, i am almost sure that's it
16:12:14 <kadoban> Eiam: (both of those books are freely available online, in case you didn't know...from the publishers, not shady torrents or something)
16:12:18 <Kaidelong> so I have to manually implement the record
16:12:20 <Kaidelong> boo
16:13:08 <yac> this is what I have a problem with: let a = "a"; putStrLn $ show $ show a
16:13:36 <Eiam> kadoban: ha, i was under a $ for free shipping on amazon so I thought maybe I should pick up a haskell book =)
16:13:59 <Eiam> but indeed there it is, http://book.realworldhaskell.org
16:14:12 <kadoban> Eiam: Ahh :)  Well, to me it does sound interesting, but I suspect, again just looking at the TOC, that I'd be lost if I tried to start from just that book.
16:15:08 <kadoban> Eiam: Yup.  Personally I learned from there and LYAH (alternating back and forth when I got bored or stuck).  Can't say it was the easiest thing ever, or that I'm done learning, but I think I have a basic grasp so far.
16:16:27 <Eiam> will give it a shot then
16:16:49 <Kaidelong> this must be a problem in ghc-mod because there is no possible way this is wrong
16:17:10 <Kaidelong> data InputMode = InputMode Bool Bool Bool Bool deriving (Eq,Ord,Enum,Bounded)
16:17:23 <Porrapah> good evening
16:17:25 <Kaidelong> it complains that Enum cannot be derived
16:17:33 <rwbarton> Enum can't be derived for your type
16:17:42 <Porrapah> I have this file which produces a syntax tree
16:17:44 <Porrapah> http://lpaste.net/9091524336233218048
16:17:58 <Porrapah> and this one who takes that output and produces three address code
16:18:05 <Porrapah> http://lpaste.net/282914439294877696
16:18:06 <Kaidelong> [(False,False,False,False) .. (True,True,True,True)]
16:18:14 <Kaidelong> > [(False,False,False,False) .. (True,True,True,True)]
16:18:14 <Porrapah> but I'm having doubts how to use it properly
16:18:16 <lambdabot>  No instance for (GHC.Enum.Enum
16:18:16 <lambdabot>                     (GHC.Types.Bool, GHC.Types.Bool, GHC.Types.Bool, GHC.Type...
16:18:16 <lambdabot>    arising from the arithmetic sequence ‘(GHC.Types.False,
16:18:16 <lambdabot>                                           GHC.Types.False, GHC.Types.False,
16:18:16 <lambdabot>                                           GHC.Types.False) .. (GHC.Types.True...
16:18:21 <Porrapah> how to link them
16:18:22 <Kaidelong> what
16:18:26 <Kaidelong> why
16:18:57 <Kaidelong> I am confused
16:18:58 <zwer> @pl (\x y z -> x + y + z)
16:18:59 <lambdabot> ((+) .) . (+)
16:19:18 <sipa> > [False..True]
16:19:19 <lambdabot>  A section must be enclosed in parentheses thus: (False.. True)Not in scope: ...
16:19:22 <c_wraith> zwer: you can write code like that, I suppose - but please don't. :)
16:19:51 <Kaidelong> c_wraith: what's wrong with that? It's perfectly idiomatic
16:20:05 <Kaidelong> (f .) . g is common enough
16:20:19 <Iceland_jack> (.:) = (.).(.)
16:20:51 <Iceland_jack> I would use the (f .) . g, f .: g pattern more often if (.:) were in base
16:20:57 <Kaidelong> > [False .. True] --surely bool is enum?
16:20:59 <lambdabot>  [False,True]
16:21:11 <zwer> :t ((+) .: (+))
16:21:12 <lambdabot>     Not in scope: ‘.:’
16:21:12 <lambdabot>     Perhaps you meant one of these:
16:21:12 <lambdabot>       ‘.’ (imported from Data.Function),
16:21:19 <Iceland_jack> @let (.:) = (.).(.)
16:21:22 <lambdabot>  Defined.
16:21:24 <zwer> :t ((+) .: (+))
16:21:24 <Iceland_jack> :t ((+) .: (+))
16:21:25 <lambdabot> Num b => b -> b -> b -> b
16:21:26 <lambdabot> Num b => b -> b -> b -> b
16:21:29 <Kaidelong> so why doesn't (,) just make a cartesian product as the enum
16:21:37 <Kaidelong> in fact
16:21:50 <Porrapah> can someone help me?
16:21:50 <zwer> is that defined in some library? I have seen it before
16:22:01 <rwbarton> well, for starters, Integer is an instance of Enum; what would fromEnum (17,42) be
16:22:12 <Kaidelong> > [(False,(False,(False,False))) .. (True,(True,(True,True)))]
16:22:13 <lambdabot>  No instance for (GHC.Enum.Enum
16:22:13 <lambdabot>                     (GHC.Types.Bool,
16:22:14 <lambdabot>                      (GHC.Types.Bool, (GHC.Types.Bool, GHC.Types.Bool))))
16:22:14 <lambdabot>    arising from the arithmetic sequence ‘(GHC.Types.False,
16:22:14 <lambdabot>                                           (GHC.Types.False,
16:22:34 <Kaidelong> rwbarton: you just add the Bounded constraint as well
16:25:08 <Kaidelong> anyway I don't need the enum instance so I guess I don't need to worry about it for now
16:25:19 <Kaidelong> but I am surprised that it can't be derived
16:25:44 * hackagebot organize-imports 0.1.0.0 - Organize scala imports  http://hackage.haskell.org/package/organize-imports-0.1.0.0 (lcycon)
16:26:58 <Porrapah> http://lpaste.net/9091524336233218048
16:27:04 <Porrapah> http://lpaste.net/282914439294877696
16:27:12 <Porrapah> guys, the first file is the .y parser
16:27:32 <Porrapah> and the 2nd one takes something in the form of the 1st output and produces 3 address code
16:27:36 <Porrapah> how can i join them?
16:29:05 <Porrapah> anyone?
16:29:51 <danilo2> Hello! Could somebody tell me how can I set a value inside of Maybe using Lens? I cannot find the right operator and I know there was something like that in the library
16:30:11 <edwardk> > Just 4 & traverse +~ 1
16:30:12 <lambdabot>  Just 5
16:30:15 <edwardk> > Just 4 & _Just +~ 1
16:30:17 <lambdabot>  Just 5
16:30:21 <edwardk> > Just 4 & each +~ 1
16:30:23 <lambdabot>  Just 5
16:30:30 <edwardk> > Just 4 & mapped +~ 1
16:30:32 <lambdabot>  Just 5
16:30:41 <pavonia> Porrapah: Just copying the code to the parser file doesn't work?
16:30:49 <edwardk> any of those will work, or traversed, itraversed, imapped...
16:31:36 <Porrapah> i didn't try that
16:31:45 <Porrapah> i would prefer in two separate files
16:31:49 <danilo2> edwardk: Oh! Thank you!
16:32:01 <pavonia> Porrapah: What do you mean by join then?
16:32:21 <Porrapah> so the 2nd file has a 'compile' function
16:32:36 <pavonia> Btw, you lexer is buggy, e.g. ('=':'=':cs) is never reached
16:32:42 <pavonia> *your
16:32:45 <Porrapah> yeah I know pavonia
16:32:57 <Porrapah> I just didn't cut it yet
16:33:16 <Porrapah> in the other file I have the funcion 'compile' wich produces 3 address code
16:33:28 <Porrapah> i think there's a way of using an import in the .y file
16:33:38 <Porrapah> so i can use 'compile' there
16:33:44 <Porrapah> but I don't know exactly how
16:33:57 <pavonia> "import Expr"
16:34:14 <pavonia> Oh, you already do that
16:34:18 <Porrapah> yes
16:34:26 <Porrapah> I'm getting a few errors tough
16:34:33 <Porrapah> don't know how to solve them
16:34:39 <pavonia> What errors?
16:34:40 <Porrapah> what I wan't to do is
16:34:50 <Porrapah> ./Main < inputfile
16:35:01 <Porrapah> and get the 3 address code
16:35:08 <Porrapah> want*
16:35:21 <Porrapah> I believe it's with the data structures used in the 2nd file
16:35:32 <Porrapah> but I already tried to change them and still can't get results...
16:35:51 <Porrapah> and also on the last line of the .y file, I believe I have to put something like compile or that
16:35:58 <pavonia> You define two data types with the same name
16:36:11 <Porrapah> yes but I already tried to change Exp to Exp1
16:36:29 <pavonia> Well, what are the errors you get?
16:40:19 <benzrf> ok
16:40:34 <benzrf> how to model the movement of a circle moving forward into a corner
16:40:50 <benzrf> ->o.
16:41:01 <benzrf> whats the maths for how it gets pushed to the up
16:41:07 <benzrf> instead of being stopped
16:41:54 <dbelange> friction???
16:42:04 <dbelange> bounciness???
16:43:52 <Porrapah> I was having some errors about ambiguous name and I corrected
16:44:04 <Porrapah> and now I do happy Main.y, then ghc Main.y and it goes well
16:44:09 <Porrapah> but when I do ./Main < input
16:44:10 <Porrapah> I get
16:44:19 <Porrapah> Main: Main.hs:(799,1)-(819,40): Non-exhaustive patterns in function lexer
16:45:36 <Porrapah> and I believe I have to add the function from the 2nd file in the last line of the Main.y
16:45:46 * hackagebot cookbook 3.0.0.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-3.0.0.0 (NatePisarski)
16:45:53 <Porrapah> something like this, right? main = getContents >>= print . compile1 . calc . lexer
16:46:53 <Porrapah> pavonia: I took a few minutes to anwser, don't know if you're still there
16:49:49 <pavonia> Porrapah: Yes. What input do you use?
16:50:38 <Porrapah> pseudo-code
16:50:58 <Porrapah> program factorial;
16:50:58 <Porrapah> begin
16:50:58 <Porrapah>   read value;
16:50:58 <Porrapah>   count <- 1;
16:50:58 <Porrapah>   result <- 5;
16:50:58 <Porrapah>   while count<value do
16:50:59 <Porrapah>     begin
16:51:01 <Porrapah> something like this...
16:51:27 <Porrapah> if I use this on Main.y, I get the syntax tree, which compile1 turns into 3 adress code
16:51:47 <Porrapah> so what I want to do is that Main.y already outputs the 3 address code
16:52:54 <pavonia> The first problem I see is "isSpace c = lexer cs" which means you're ignoring whitepsace completely
16:53:04 <ReinH> Porrapah: please use a pastebin for multiple lines
16:53:14 <Porrapah> sorry
16:53:54 <Porrapah> pavonia: the lexer works exactly as I want, I don't need anything too advanced
16:54:10 <Porrapah> the real problem I'm having is using the compile1 in the Main.y
16:54:32 <pavonia> The error you pasted indicates the problem is in the lexer function
16:55:14 <Porrapah> sorry it no longer gives that error
16:55:29 <Porrapah> It's the way my compile is defined
16:55:51 <Porrapah> Couldn't match type `[Line]' with `Exp1'
16:55:52 <pavonia> Also, compile doesn't seem to be handling all cases of the parser's Exp type
16:56:18 <Porrapah> But if I try to change Exp1 to [Line]
16:56:26 <Porrapah> compile doesn't recognize Line as it's in the Main.y
16:57:20 <pavonia> I think you're trying to use compile with Exp1 but actually pass it an Exp
16:59:08 <pavonia> What is the type of calc?
16:59:53 <Porrapah> I just put it there because it was in the tutorial
17:00:00 <Porrapah> it didn't explain what it meant
17:02:21 <pavonia> It's hard to tell what's the problem because first you said the program compiles and now you get a type error, but you didn't say what part of the code changed
17:03:22 <Porrapah> yeah, it's my fault
17:03:34 <Porrapah> i've been looking for it for so much time that even I am confused
17:03:55 <Porrapah> i believe it's the way compile is defined
17:04:19 <Porrapah> i have to adapt the type of compile to the type of the lexer
17:04:25 <Porrapah> just can't see how right now...
17:07:32 <ik_> hi, i would like to ask a question about functors in haskell
17:08:33 <c_wraith> ik_: please ask!
17:09:04 <c_wraith> ik_: In general, just ask.  Don't ask to ask.  It's a lot of chatter for us to tell you to just ask the question. :)
17:10:07 <ik_> Thanks c_wraith. I have just read up about functors. It took me a while to understand the concept. Now that I do understand it, I am wondering when it would be useful for me as a programmer. Please can someone give some useful examples.
17:12:08 <c_wraith> ik_: at the first level, functor just gives you a mapping operation that has the same name across multiple types.  In that sense, it's convenient because you don't need to go looking for the name of that operation for every type, you know it's fmap. (If the type is an instance of Functor)
17:12:58 <c_wraith> ik_: But you can go further with same idea - you can write polymorphic code that works for any functor.  And that turns out to be amazingly useful, too.
17:13:16 <hunter> is there a function to format numbers as 00012 or 00324 etc.
17:13:27 <alphonse23> is ghc haskell written in C, like ruby and python, and some forms of lisp/scheme, or does it get written directly to assembly when compiled? (I know this is a newb question, please show me mercy)
17:14:12 <silasm> alphonse23: are you asking if it has C in its compile path?
17:14:18 <alphonse23> sure
17:14:23 <c_wraith> alphonse23: GHC is written in a combination of haskell, assembly, C, and its own special dialect of C--
17:14:23 <Guest93595> alphonse23 haskell programs should all get written to assembly on compilation... im not sure i understand ur question
17:14:30 <silasm> ghc (the compiler) is mostly written in haskell.
17:14:43 <glguy_> > map (printf "%05d") [12::Int, 324] :: [String]
17:14:45 <lambdabot>  ["00012","00324"]
17:15:03 <alphonse23> like python and ruby, their interpreted and written in C, so when you interpret ruby it's actually being run in C
17:15:11 <Arnob> Hi all
17:15:19 <silasm> iirc C was in the compile path of ghc at one point at least, but last time I tried to output to .c it didn't work, so I think it was phased out.
17:15:22 <Arnob> I have a question for you regarding point free style
17:15:29 <Arnob> I have some code like this
17:15:34 <c_wraith> alphonse23: "run in C" doesn't mean anything.  It's run in a program that was written in C.
17:15:57 <alphonse23> ok, I guess, maybe it's more correct to say that python and ruby are compiled in C
17:15:58 <Arnob> http://lpaste.net/104834
17:16:08 <Guest93595> glguy: holy shit theres a printf function? or is that ffid?
17:16:12 <Arnob> how would I rewrite to point free style
17:16:19 <glguy_> Text.Printf
17:16:20 <Arnob> especially the case statement
17:16:25 <glguy_> It's just Haskell
17:16:28 <alphonse23> but haskell is not compiled in C, it is all haskell and it goes from haskell to assembly
17:16:33 <bitemyapp> Arnob: do you really want to?
17:16:42 <alphonse23> no other languages in between
17:16:44 <zwer> glguy it isn't. but it is nearly as evil as the C printf function :)
17:16:52 <bitemyapp> Arnob: for the record, you can, but it wouldn't necessarily be easier to understand. You have to break it down piece by piece.
17:16:58 <Arnob> ah... well to me this code appears pretty self explanatory and clear
17:17:07 <pingu> Arnob: if you really want to, either may help
17:17:10 <monochrom> why is it important to distinguish "run in C" and "not run in C"?
17:17:16 <silasm> alphonse23: why do you ask, anyways?
17:17:17 <Arnob> but apparently writing in point free style is preferred in the haskell community?
17:17:24 <c_wraith> alphonse23: GHC actually uses a ton of intermediate languages when compiling.  Core, STG, maybe LLVM IR, maybe Cmm
17:17:28 <alphonse23> I guess just out of curiosity
17:17:29 <zwer> s/glguy/Guest93595
17:18:10 <Guest93595> glguy_ zwer is there a way to get back a string?
17:18:18 <alphonse23> c_wraith: really? so infact ghc is written with a bunch of other languages. so i've I wanted to write my own haskell compiler, I'd have to learn all other those to succeed?
17:18:30 <zwer> Guest93595 just use it in a string context. return value is overloaded
17:18:45 <zwer> > printf "%d" 10 :: String
17:18:46 <lambdabot>  "10"
17:18:52 <c_wraith> alphonse23: be very careful.  What language a compiler is written in is 100% irrelevant to what languages it transforms code to during compilation
17:19:11 <Guest93595> zwer: how does that work? printf appears to specifically release an io action
17:19:19 <Guest93595> oh shit it doesnt
17:19:20 <Guest93595> my bad
17:19:22 <zwer> :t printf
17:19:23 <lambdabot> PrintfType r => String -> r
17:19:24 <Guest93595> thanks zwer
17:19:26 <Iceland_jack> :t printf "%s!" "hi" :: String
17:19:27 <lambdabot> String
17:19:28 <Iceland_jack> :t printf "%s!" "hi" :: IO ()
17:19:29 <lambdabot> IO ()
17:19:38 <zwer> welcome
17:20:08 <alphonse23> c_wraith: you're right. I'm only asking out of curiosity. If say I wanted to understand the whole picture though, from haskell to compiled assembly, I'd have to understand all the intermediary languages to fully get it.
17:20:27 <Guest93595> zwer: what exactly happesn when its called in an io context... why does it print differently then a string in an io context
17:21:10 <Iceland_jack> Guest93595: Using type classes
17:21:18 <Iceland_jack> @google printf haskell type class stackoverflow
17:21:20 <lambdabot> http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
17:21:20 <lambdabot> Title: How does Haskell printf work? - Stack Overflow
17:21:56 <alphonse23> the only reason why I'm asking is because I've been reading a little about compilers and interpreters. It's related to why I'm interested in Haskell. I'm just interested in how languages work and are constructed. I think infact to get haskell you should know a little about how compilers work.
17:22:41 <Iceland_jack> alphonse23: You can compile a given language in a thousand different ways, GHC is complicated and most details about the compiler itself aren't stricly necessary for implementing a compiler of your own
17:22:49 <zwer> Guest93595, if I understood you right, you're asking why it prints `hi!' instead of `"hi!"'? if a function returns a string repl prints it with a quotes. in the case of io you are just seeing output to stdout
17:23:00 <c_wraith> alphonse23: each transformation GHC does can be seen as making the code slightly more low-level.  Core makes all the implicit stuff in haskell explicit, but still looks a lot like haskell. STG is even lower-level - it's strictly operational instructions for a theoretical machine that can run functional code. Then it transforms that representation down to a representation imperative hardware can underst
17:23:00 <c_wraith> and, and does more optimizations, etc.
17:23:04 <bitemyapp> Arnob: not necessarily.
17:23:19 <carter> theres no one true style
17:23:19 <bitemyapp> Arnob: it can be better in some cases, worse in others. Don't sweat it if you like your code as it is.
17:23:23 <carter> and point free isn't good in the large
17:23:26 <carter> its nice in somell pieces
17:23:32 <Arnob> I am trying to write all my code point free and without do notation :-)
17:23:33 <c_wraith> alphonse23: the reason it goes through so many stages is that different optimizations are easy at each stage.
17:23:36 <bitemyapp> yep. I agree with carter.
17:23:47 <Arnob> but I have a hard time writing/reading point free code...
17:23:48 <bitemyapp> Arnob: well if you query lambdabot, the bot has @pl and @undo
17:23:48 <carter> Arnob: hahaha, its like writing a circuit diagram
17:23:49 <carter> god speed
17:24:22 <pingu> Arnob: it's pretty easy if you read it like a "pipeline" from right to left
17:24:36 <glguy_> Arnob: Point-free style is popular in IRC channels for bits of code passed to lambdabot, but it's not an ideal to aspire to
17:24:37 <bitemyapp> carter: point-free can be a fun way to force hole-driven programming.
17:24:41 <ReinH> Arnob: these are some nice slldes http://www.scs.stanford.edu/14sp-cs240h/slides/ghc-rts.pdf
17:24:43 <c_wraith> alphonse23: If you wanted to compare to ruby or python, they do something similar, but they skip the final "emit object code" step.  The both have internal forms for the code that differs from how it's written, in that it's optimized for machine consumption. cpython even caches that representation in .pyc files
17:24:49 <ReinH> about the RTS more than the compiler, but perhaps still interesting
17:24:50 <bitemyapp> ReinH: wrong person.
17:24:51 <hiptobecubic>  /j #slackware
17:24:55 <bitemyapp> ReinH: you wanted to aim that at alphonse23
17:24:56 <hiptobecubic> sigh...
17:25:03 <ReinH> argh
17:25:05 <bitemyapp> hiptobecubic: Linux hipster.
17:25:12 <ReinH> bitemyapp: thanks
17:25:13 <bitemyapp> hiptobecubic: Slackware is so old it's cool again.
17:25:19 <bitemyapp> ReinH: <3
17:25:24 <ReinH> alphonse23: http://www.scs.stanford.edu/14sp-cs240h/slides/ghc-rts.pdf are nice slides about the RTS if you're also interested in that
17:25:26 <ReinH> bitemyapp: <3
17:25:29 <hiptobecubic> I recently switched away, actually
17:25:34 <bitemyapp> hiptobecubic: to?
17:25:36 <alphonse23> I just read that ReinH
17:25:45 <hiptobecubic> But it's one of the few channels that isn't a waste of time
17:25:52 * hackagebot YampaSynth 0.2 - Software synthesizer  http://hackage.haskell.org/package/YampaSynth-0.2 (GeorgeGiorgidze)
17:25:59 <hiptobecubic> bitemyapp, Arch for now
17:26:05 <alphonse23> interesting, it sort of explains how the garbage collector works. Though I think it was meant as a presentation, so you can't really understand all of it.
17:26:09 <gunny-> when is ST prefered over State and vice versa?
17:27:04 <alphonse23> i'd be really interested in understanding STG. It sounds like the gateway to understanding how the compiler handles functional code. Turning closures and what not into the assembly right?
17:27:13 <silasm> @where iofpl
17:27:14 <lambdabot> I know nothing about iofpl.
17:27:21 <silasm> gah
17:27:38 <bitemyapp> alphonse23: eh.
17:27:45 <Iceland_jack> @google iofpl
17:27:47 <lambdabot> http://www.morewords.com/word/iofpl/
17:27:47 <lambdabot> Title: Iofpl
17:27:53 <Iceland_jack> hmm, nice try :)
17:28:04 <silasm> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
17:28:28 <silasm> alphonse23: ^ would probably interest you
17:30:00 <alphonse23> cool book silasm
17:30:04 <alphonse23> I am saving it!
17:32:43 <silasm> alphonse23: it's a good read for introducing haskell, lambda calculus, and denotational semantics if nothing else.
17:33:50 <alphonse23> introducing? really. Not more of like an explanation of how all the magic happens?
17:34:18 <alphonse23> oh well. I got to go. Thanks for all the help guy. IRC is awesome!
17:34:26 <ReinH> gunny-: I think State is preferred for most things. For things that you can't do with State, or are too slow with State, you might use ST
17:34:30 <silasm> alphonse23: I haven't read into it enough to make that claim :/
17:35:33 <bitemyapp> ReinH: is there anything ST can do that State cannot beyond perf?
17:35:46 <ReinH> bitemyapp: fsvo perf, I don't think so
17:36:12 <ReinH> Depends on if you consider mutation a perf enhancement I guess
17:37:04 <bitemyapp> ReinH: depends on the nature of your problem as to whether or not it helps.
17:37:29 <carter> ST has vector supposrt :)
17:37:33 <carter> State dont
17:37:50 <dolio> ST lets you make up arbitrary numbers of references with arbitrary types.
17:37:57 <dolio> It's very annoying to emulate that with State.
17:39:06 <c_wraith> I've done it.  Just takes a few unsafeCoerces and no concern for leaking memory like mad.
17:39:18 <dolio> Right.
17:39:48 <benzrf> ok,
17:40:09 <benzrf> how exactly is runST blocked from affecting currently-running threads?
17:40:12 <benzrf> *'threads'
17:40:53 * hackagebot organize-imports 0.2.0.0 - Organize scala imports  http://hackage.haskell.org/package/organize-imports-0.2.0.0 (lcycon)
17:40:54 <c_wraith> benzrf: type system.  You can't smuggle an STRef out of one ST action in a way that it can be used by another.
17:41:04 <benzrf> hmmmm
17:41:35 <carter> types
17:41:40 <carter> :t runST
17:41:41 <lambdabot> (forall s. ST s a) -> a
17:41:52 <carter> s cant exscape unless you deliberately do evil
17:42:21 <c_wraith> s can't escape with anything short of unsafeCoerce
17:42:25 <benzrf> > runST $ do {ref <- newSTRef 0; return (runST (modifySTRef ref (const 2))}
17:42:26 <lambdabot>  <hint>:1:73: parse error on input ‘}’
17:42:32 <benzrf> > runST $ do {ref <- newSTRef 0; return (runST (modifySTRef ref (const 2)))}
17:42:33 <lambdabot>  Couldn't match type ‘s’ with ‘s1’
17:42:33 <lambdabot>    ‘s’ is a rigid type variable bound by
17:42:33 <lambdabot>        a type expected by the context: GHC.ST.ST s () at <interactive>:1:1
17:42:33 <lambdabot>    ‘s1’ is a rigid type variable bound by
17:42:33 <lambdabot>         a type expected by the context: GHC.ST.ST s1 ()
17:42:37 <benzrf> aha
17:42:42 <carter> c_wraith: unsafePrimToPrim
17:42:43 <carter> :)
17:43:08 <c_wraith> I'm going to go ahead and call that morally unsafeCoerce. :P
17:43:21 <benzrf> :t newSTRef
17:43:22 <lambdabot> a -> ST s (STRef s a)
17:43:28 <benzrf> :t modifySTRef
17:43:29 <lambdabot> STRef s a -> (a -> a) -> ST s ()
17:43:35 <benzrf> is s phantom
17:43:44 <carter> yus
17:43:47 <c_wraith> benzrf: it's important that the STRef has an s type variable that matches the s type variable in ST
17:47:03 <benzrf> hmmmmmmm
17:47:10 <c_wraith> benzrf: you *can* smuggle an STRef out of runST, by the way, if you wrap it in something like..  data Wrapper a = forall s. Wrapper (STRef s a)
17:47:19 <benzrf> !!!
17:47:25 <c_wraith> benzrf: But you can't use that STRef
17:47:34 <benzrf> :t runST
17:47:35 <lambdabot> (forall s. ST s a) -> a
17:47:37 <benzrf> right right
17:47:38 <c_wraith> If you try, you'll be told that the s type variables don't match
17:48:02 <benzrf> how does ST handle values you pull out of refs followed by mutation
17:48:03 <benzrf> copying?
17:48:17 <c_wraith> an STRef is identical to an IORef
17:49:11 <carter> benzrf: ST stuff is basically a subset of IO that you can use in a way that Looks pure from the outside
17:49:28 <c_wraith> In fact, that's exactly what it is, not just basically. :)
17:50:00 <carter> :P
17:50:42 <benzrf> is it implemented as a regular lib with unsafeperf?
17:51:00 <c_wraith> Not quite.  It actually is implemented in terms of the same lower-level type as IO
17:51:07 <benzrf> ah
17:51:14 <benzrf> runST though
17:51:16 <benzrf> @src runST
17:51:16 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
17:51:19 <benzrf> o:
17:51:30 <benzrf> @src runSTRep
17:51:30 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
17:51:42 <benzrf> :t realWorld#
17:51:43 <lambdabot> Not in scope: ‘realWorld#’
17:51:47 <benzrf> wuh
17:51:52 <carter> magichash :)
17:51:55 <bitemyapp> benzrf: the world is an illusion, Neo.
17:52:02 <benzrf> wheres the value comin from though
17:52:04 <benzrf> non-exported?
17:52:14 <carter> GHC.Prim
17:52:21 <benzrf> o=
17:52:26 <benzrf> > realWorld#
17:52:27 <lambdabot>  Not in scope: ‘realWorld#’
17:52:30 <benzrf> > GHC.Prim.realWorld#
17:52:31 <lambdabot>  Not in scope: ‘GHC.Prim.realWorld#’
17:52:34 <benzrf> w-what
17:53:15 <benzrf> > GHC.Base.realWorld#
17:53:16 <lambdabot>  Not in scope: ‘GHC.Base.realWorld#’
17:53:22 <benzrf> you LIED to me
17:53:38 <bitemyapp> benzrf: no dice grandma.
17:53:51 <benzrf> i aint ur grandma
17:53:59 <_Vi> Is there a thing like apt-cacher-ng, but for Hackage? I.e. a specialized caching web proxy that prevents re-downloading packages.
17:57:07 <benzrf> where is realWorld# coming from in that src
17:57:08 <benzrf> -.-
18:00:10 <benzrf> Prelude GHC.Prim GHC.Base> let v = (unIO (putStrLn "cake")) realWorld# in 3
18:00:13 <benzrf> haha
18:00:22 <benzrf> why is it evalling v?
18:00:27 <benzrf> shouldnt it be lazy
18:00:54 <pingu> benzrf: IO isn't lazy, possibly?
18:01:06 <benzrf> pingu: ...what?
18:01:35 <benzrf> @src unsafePerformIO
18:01:35 <lambdabot> Source not found.
18:01:39 <pingu> benzrf: not without unsafeUnterleaveIO
18:01:44 <pingu> which makes IO lazy
18:01:55 <carter> IO actions be strict
18:01:56 <benzrf> i dont think you get my question
18:01:57 <carter> yup
18:02:11 <carter> well
18:02:53 <carter> benzrf: messing with stuff that interacts with realWorld# and such, like whatever your unIO operation is, *** IS *** unsafePeformIO
18:02:59 <carter> read the source defn of it :)
18:03:13 <benzrf> unIO is in GHC.Base
18:03:14 <carter> System.IO.Unsafe
18:03:14 <benzrf> :t unIO
18:03:16 <lambdabot> Not in scope: ‘unIO’
18:03:24 * benzrf thumbs his nose at lambdabot 
18:03:36 <c_wraith> there are reasons lambdabot doesn't import those things
18:03:56 <carter> benzrf: theres no GHC.Base on 7.8
18:31:12 <rwbarton> benzrf, it printed because it evaluated v because v has an unlifted type
18:34:15 <benzrf> rwbarton: oh, didnt know thats how unlifted types work
18:34:18 <benzrf> h-huh
18:41:06 <brrrrrrrian> Can someone help me understand if the following is possible? http://lpaste.net/104838
18:41:39 <Iceland_jack> brrrrrrrian: it is possible, yes
18:42:02 <Iceland_jack>     data Container = A | B DataB | C DataC | D DataD
18:42:33 <Iceland_jack> if you have GHC 7.8 you can also define patterns such that its interface becomes the same
18:42:45 <brrrrrrrian> Iceland_jack: so for the enumerated data type I have to wrap them in a different constructor?
18:42:57 <Iceland_jack> yes, but mind the comment above
18:43:21 <Iceland_jack> you can do
18:43:21 <Iceland_jack>     pattern NewB b bb = B (DataB b bb)
18:43:24 <brrrrrrrian> Iceland_jack: what do you mean 'patterns such that its interface becomes the same'
18:43:36 <Iceland_jack> and then use NewB just like you'd use DataB before
18:43:45 <brrrrrrrian> ah
18:44:23 <Iceland_jack> brrrrrrrian: here's a short intro http://www.reddit.com/r/haskell/comments/24fvyz/pattern_synonyms_for_dates_and_an_irc_bot/
18:45:45 <Iceland_jack> then you can hide the constructors and you're free to change the interface and the pattern matching still works
18:47:39 <brrrrrrrian> i see. thanks
18:48:17 <Iceland_jack> If you wanted to match on a nested 'Nothing' you could for example do
18:48:18 <Iceland_jack>     pattern NestedNothing = Just Nothing
18:48:27 <Iceland_jack> having type Maybe (Maybe a)
18:58:40 <Qer> guys, how do I make a profiler of my program in WinGHCi?
18:58:48 <Qer> what flags should I use?
18:58:51 <Qer> +RTS -p doesnt work
18:59:49 <pavonia> Can this be rewritten using a fold without loss of efficiency? http://lpaste.net/104839
19:01:38 <copumpkin> pavonia: it's a scan
19:01:47 <copumpkin> (I think?)
19:01:51 <copumpkin> who knows, maybe not
19:02:09 <copumpkin> oh I guess not
19:02:11 <copumpkin> mapAccumL :)
19:03:11 <pavonia> copumpkin: Excellent, thanks!
19:04:35 <mpanetta> Hi guys. :)  Anyone have a favorite command line option parser?
19:04:48 <tiqs> optparse-applicative
19:05:01 <LordBrain> where is a list of type operators in ghc, like ~ etc
19:05:10 <Qer> how do I add something to my .hs file so that when I run it, this code runs too?
19:05:38 <Qer> not just "database", but some execusion?
19:05:57 <LordBrain> what's wrong with main = initstuff $ do
19:06:10 <LordBrain> oh
19:06:14 <LordBrain> in a library?
19:06:33 <LordBrain> (talking to Qer)
19:06:38 <Qer> no no
19:06:49 <Qer> I just want to test my code, do a profiler
19:07:16 <Qer> and I have to execute it
19:07:16 <Qer> I have to run a function when i do ./program.hs
19:07:18 <LordBrain> compile with profiling enoabled, and run it with -prof
19:07:41 <Qer> but in my .hs file, I have only functions
19:07:46 <Qer> I don't use them
19:07:59 <Qer> how do I use them in my file so that they actuall execute?
19:08:11 <LordBrain> call them from main
19:08:18 <Qer> oh, okay
19:08:22 <LordBrain> you need a function called main
19:08:24 <qrada> can cabal install dependencies from github? havn't been able to find anything
19:08:38 <LordBrain> main :: IO ()
19:09:16 <LordBrain> Qer, if that doesn't answer your q, post it in lpaste, and maybe i'll understand better what you mean
19:09:57 <tiqs> Qer: you can make your file executable and add your command at the top like #!runhaskell
19:10:18 <Qer> LordBrain: yes, it does answer my question. I don't know monads very well tho, that Main is gonna be tough :D
19:10:37 <mpanetta> thank you tiqs
19:11:01 <Qer> tiqs: I'll try that, thank you :) can I still make profiler then?
19:12:09 <LordBrain> haskell basically forces everyone to learn monads, lol.
19:12:26 <rwbarton> you don't need to "learn monads" in order to learn how to do IO
19:12:48 <LordBrain> eh, you'll want to learn them tho
19:12:53 <copumpkin> yeah seriously, plenty of people do lots of useful stuff with Haskell without a clue about what a monad is
19:13:00 <copumpkin> some will, others won't
19:13:10 <copumpkin> it's an arbitrarily deep rabbithole that some people want to go down
19:13:10 <Qer> I did what I wanted ;D
19:13:30 <Qer> but I think that after compiling, the program runs faster than with WinGHCi. is that possible?
19:13:40 <LordBrain> of course
19:13:53 <Welkin> copumpkin, you mean without using monads? or using them, but not really understanding them?
19:13:53 <LordBrain> why not? compiling makes it native binary
19:14:07 <bitemyapp> copumpkin: I'm going to concur here because I talk to people that say they know Haskell and got stuff done in it all the time that don't seem to have understood: purity, parametricity, IO, applicative, monads, etc etc
19:14:08 <qrada> regardless of monads, shouldn't you still know bind/id/return work etc
19:14:14 <qrada> when you're in the monad
19:14:20 <mayski> some people actually enjoy the deepness of the rabbithole like me :D
19:14:22 <bitemyapp> copumpkin: yet - they can get stuff done. This is a strength of Haskell but it leads to annoying conversations :)
19:14:28 <mayski> most of the time I have no clue what I'm doing
19:14:29 <bitemyapp> qrada: "in" the monad?
19:14:45 <sjy> i've attempted a number of personal projects in haskell and failed due to not really understanding monads
19:14:46 <geekosaur> Qer: ghci uses an unoptimized bytecode generator; it is expected to be slow compared to compiled code
19:14:51 <LordBrain> Did anyone answer my q? I want to find a list of type-level operators, such as ~ and any type functions that come with ghc. Where is that?
19:14:55 <bitemyapp> sjy: https://github.com/bitemyapp/learnhaskell
19:15:46 <bitemyapp> LordBrain: your name reminds me of the SNES game BrainLord
19:16:03 <LordBrain> not familiar
19:16:05 <copumpkin> bitemyapp: certainly :)
19:16:25 <LordBrain> i don't really like my name any more, maybe its too pretentious, but i cant change it, i've had it for too many years
19:16:36 <Welkin> yes you can
19:16:44 <Welkin> I've changed my name after many years
19:17:04 <LordBrain> well, i know i can technically
19:17:21 <geekosaur> LordBrain, I'm not sure there's a concise summary anywhere; instead it's scattered all through http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
19:17:25 <Welkin> others adapt quickly
19:17:32 <sjy> bitemyapp: well, i'm getting there slowly by trying to write lots of code :) i'm just saying that my experience has been if you want to do any kind of more complex IO than "read data from a file, transform it, and then write your output to another file" a better understanding of monads than i have seems to be needed
19:17:37 <geekosaur> which is more or less a list of extensions beyond standard Haskell
19:17:40 <bitemyapp> sjy: try my guide.
19:17:41 <jle`> qrada: for a specific type/instance of Monad, bind and return might be useful utility functions.  but knowing that those utility functions come from the Monad typeclass doesn't exactly help you at first...nor is it necessary
19:18:09 <jle`> sjy: a better understanding of monads, or a better understanding of the IO type?
19:18:24 <LordBrain> geekosaur, do you know i thought i recall seeing something somewhere like Has_method foo or something like this... is there such a type predicate?
19:18:37 <benzrf> structural typing!
19:18:50 <LordBrain> with an extension perhaps
19:18:52 <sjy> jle`: probably the latter, although i was trying to do some relatively simple network stuff the other day and got confused by the zeromq monads
19:18:54 <geekosaur> not so far as I'm aware
19:19:22 <rwbarton> LordBrain: sounds like the record fields extension which will be new in 7.10
19:19:38 <jle`> sjy: perhaps you were confused about the zeromq data type, not about monads
19:20:07 <Qer> wow guys, after using profiler and -pa flag when executing the .exe, I see that Main uses 95.5% time... but in my main, I execute a function that executes lots of functions... and I want to know which of these takes the longest! how to do that?
19:20:07 <sjy> that's probably fair to say. i was confused about a thing that says "monadic" on it :P
19:20:10 <geekosaur> yeh, my best guess there was the Has class which is not about methods but about extensible records
19:20:13 <nisstyre> sjy: the Control.Applicative class will serve you well for doing IO in a nicer looking way
19:20:19 <nisstyre> particularly the <$> function
19:20:23 <nisstyre> er module not class
19:20:40 <geekosaur> (althoygh extensible records can be parlayed into OO-style method support)
19:20:45 <jle`> sjy: that's a problem with the way things are presented, i think :/
19:20:47 <rwbarton> Qer: how did you compile exactly?
19:20:48 <LordBrain> rwbarton, you have a link?
19:21:05 <rwbarton> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design
19:21:42 <qrada> cabal-meta seems like it can install from github, cool
19:21:49 <Qer> rwbarton: ghc /.projekt.hs -prof              then running: projekt.exe +RTS -pa
19:22:10 <sjy> jle`: maybe i could clarify. just to get started, i was trying to modify this https://github.com/imatix/zguide/blob/master/examples/Haskell/hwserver.hs to respond with user input, or a random word, rather than "World".
19:22:23 <rwbarton> Qer: try building with -prof -fprof-auto
19:22:39 <rwbarton> I think it's not the default for some reason
19:22:47 <geekosaur> Qer: beware that profiling takes some understanding, since if you aren't forcing stuff then it will be quite common for calculations to pile up as thunks that are all forced (and therefore accounted to) printing/output
19:22:47 <sjy> i'm pretty comfortable working with pure functions in ghci, but i found both of those things to be quite difficult
19:23:09 <Qer> rwbarton: it worked ;)
19:23:21 <rwbarton> nice
19:23:27 <rwbarton> btw you probably want to compile with -O or -O2, also
19:23:35 <Qer> rwbarton: what does it do?
19:23:56 <Qer> geekosaur: I just need to take a queek glance and see if one particular function executes more than once
19:24:05 <rwbarton> Qer, it makes it go faster
19:24:08 <asr1> evening, all. quick question about monad-like things: is there a typeclass similar to Monad in that it has return :: a -> m a but bind is of type m a -> (a -> m b) -> m (a, b)
19:24:19 <benzrf> asr1: fmap
19:24:24 <Qer> rwbarton: but I need the proportions between the program, not the program running fast ;) thanks thoug
19:24:31 <benzrf> asr1: with (,)
19:24:31 <sjy> bitemyapp: where should i start in your guide? i'm not really keen to start from the beginning, because i'm already comfortable with a lot of the basics
19:24:39 <asr1> benzrf: hm, ok
19:24:43 <asr1> benzrf: let me think about this.
19:24:57 <Iceland_jack> asr1: interestingly enough, that's close to another possible interface of Applicative
19:25:02 <rwbarton> Qer: well it won't necessarily make every function faster by the same amount :)
19:25:10 <glguy> ?type \m f -> m >>= \x -> f x >>= \y -> return (x,y)
19:25:11 <lambdabot> Monad m => m t -> (t -> m t1) -> m (t, t1)
19:25:14 <benzrf> asr1: oh wait
19:25:16 <Iceland_jack>     unit ∶ A ()
19:25:16 <Iceland_jack>     mult ∶ A a → A b → A (a, b)
19:25:18 <benzrf> no, that's monad
19:25:21 <rwbarton> it's kind of silly to pay attention to performance of non-optimized ghc output
19:25:23 <asr1> benzrf: yeah..
19:25:28 <benzrf> asr1: you can write that in terms of monad
19:25:31 <benzrf> lol
19:25:48 <asr1> benzrf: yes, you could. i was just wondering if there were a standard typeclass that does it.
19:25:59 <benzrf> asr1: whaaaa
19:26:04 <bitemyapp> sjy: applicatives in the Yorgey course
19:26:06 <benzrf> asr1: why would it make sense for there to be a class
19:26:22 <benzrf> asr1: that makes no sense
19:26:29 <asr1> asr1: i've come across it in a couple settings, thought there might be some bigger picture that i was missing
19:26:30 <jle`> it makes more sense for there to "be a function" that does that
19:26:50 <sjy> bitemyapp: thanks :)
19:27:08 <asr1> asr1: basically it captures types that can have a recordable history of computations
19:27:10 <Maxdamantus> :t liftM2 (,)
19:27:12 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
19:27:32 <jle`> asr1: you might want to look at the Writer type
19:27:35 <benzrf> asr1: why would it be a class, though
19:27:39 <benzrf> asr1: i don't understand
19:27:47 <jle`> specifically its Monad instance
19:27:50 <asr1> asr1: Writer is a little different, since the type of the history value has to remain the same
19:27:58 <benzrf> asr1: are you confusing class with function?
19:28:21 <asr1> benzrf: a typeclass defines certain functions that a type must implement in order to be an instance of that class.
19:28:27 <benzrf> asr1: yes
19:28:35 <benzrf> and Monad already implements your function
19:28:37 <asr1> benzrf: I was wondering whether there exists a class which requires return and bind with the aforementioned type signatures
19:28:40 <benzrf> or rather, what is necessary for it
19:28:44 <asr1> benzrf: yes, that's true.
19:28:49 <benzrf> asr1: that would be isomorphic to monad
19:28:51 <benzrf> and therefore useless
19:28:55 <benzrf> what would be the point at all?
19:28:57 <jle`> asr1: the thing is that if you defined a function that does that...it would be identical in usefulness
19:29:04 <benzrf> jle`: it would be *more* useful
19:29:04 <jle`> because it would work for all Monads
19:29:08 <benzrf> no split typeclasses
19:29:13 <asr1> benzrf: ah, I see your point
19:29:27 <benzrf> =]
19:29:36 <benzrf> wait
19:29:40 <benzrf> did i use 'isomorphic' right
19:30:34 <jle`> i could have a ypeclass that just implemented (>>= id), but...you can just name the function like join = (>>= id), and it'll have a generic type signature and you can just use it like normal on all Monads
19:31:32 <jle`> there would be no functional difference between a typeclass that provided (>>= id), and just defining join = (>>= id)...except that you don't have to make every type an instance of both
19:32:05 <Iceland_jack> jle`: You could implement it more efficiently with a type class
19:32:35 <jle`> ah that's true
19:32:47 <asr1> benzrf, jle`: i agree that every Monad can do this
19:33:00 <asr1> benzrf, jle`: but, not every type that supports this special bind can be a Monad
19:33:38 <jle`> hmmm.
19:33:48 <jle`> i think if you have that bind, and fmap/Functor, then it would be
19:34:12 <jle`> still thinking about whether you could implement fmap using that
19:35:35 <asr1> jle`: you can't.
19:35:52 <asr1> jle`: i think Biarrow a () works
19:36:14 <jle`> so you're looking for a weaker Monad, not for utility functions for Monad
19:37:02 <asr1> jle`: yes.
19:37:27 <asr1> jle`: and moreover, this thing is in general not a Functor. if it were, as you said, you could turn it into a Monad by dint of fmap snd
19:38:47 <LordBrain> rwbarton, is this extension, overloaded record types, implemented in the head of the ghc repo?
19:39:21 <jle`> asr1: then in that case i don't know of any
19:39:22 <rwbarton> LordBrain: I'm actually not sure whether it is in head yet, but it is implemented on a branch
19:39:35 <rwbarton> asr1: what is Biarrow?
19:40:32 <LordBrain> probably an invertible arrow
19:41:16 <LordBrain> no cant be..
19:41:20 <LordBrain> nvm me
19:41:38 <rwbarton> that works nicely for the funny bind, but not for return
19:41:49 <asr1> rwbarton: darn, you're right.
19:42:07 <rwbarton> are there supposed to be laws?
19:42:39 <rwbarton> if not you can just write down the initial thing  data Asr1 a where Return :: a -> Asr1 a; FunnyBind :: Asr1 a -> (a -> Asr1 b) -> Asr1 (a, b)
19:44:15 <asr1> rwbarton: you're right
19:44:23 <asr1> rwbarton: even if there were laws, how would that change anything?
19:44:37 <jle`> a FreeAsr1
19:44:40 <rwbarton> well, that Asr1 type wouldn't satisfy the laws
19:45:11 <benzrf> whoa
19:45:12 <benzrf> so
19:45:13 <rwbarton> maybe instead of return :: a -> m a you just want a pt :: m ()
19:45:19 <rwbarton> which with Functor, is the same
19:45:24 <benzrf> making a GADT from a class
19:45:39 <benzrf> is the free object for that class?
19:45:43 <benzrf> data Monoid a where Mempty :: Monoid a; Mappend :: Monoid a -> Monoid a -> Monoid a
19:45:44 <asr1> rwbarton: I can't assume Functor. and I still don't see what you're saying about laws
19:45:47 <benzrf> thats a list!
19:45:53 <benzrf> no wait
19:45:54 <rwbarton> benzrf, no
19:45:57 <benzrf> it is not
19:45:57 <rwbarton> not if there are laws
19:46:01 <benzrf> never mind
19:46:14 * benzrf retreats back into his hole
19:46:21 <asr1> rwbarton: you mean, monadic laws that would be broken by funnybind?
19:46:44 <rwbarton> asr1: you've postulated some structure which is similar to Monad's
19:46:48 <rwbarton> Monad also has some laws
19:46:51 <Qer> guys, haskel is functional. then why we learn monads to make haskell imperative? it makes no sense
19:46:56 <rwbarton> are you postulating any analogous laws?
19:47:16 <benzrf> Qer: lol
19:47:20 <asr1> rwbarton: i'll have to think about it. even if i were, the code would be the same since the compiler can't enforce laws
19:47:33 <asr1> Qer: not sure if trolling
19:47:36 <rwbarton> asr1: it matters though when you ask whether the notions are equivalent
19:47:42 <jle`> Qer: haskell is...general purpose/multi paradigm
19:47:44 <Qer> asr1: or just stupid? :D
19:48:05 <asr1> Qer: no, it's not a stupid question
19:48:06 <jle`> some might argue that some problems are best expressed imperatively
19:48:14 <jle`> some solutions
19:48:19 <asr1> Qer: or rather, it has the potential not to be a stupid question. but it sounds like the sort of question a troll would ask
19:48:24 <jle`> i don't know, the verdict is out on that one
19:48:29 <rwbarton> asr1: anyways if you do replace return with a constant of type m () then you can use your "isomorphisms to ()" type
19:49:00 <jle`> there are purists who would claim that all solutions are best expressed denotatively and that there are no situations where an imperative approach is more expressive
19:49:07 <jle`> haskell provides some sort of compromise
19:49:33 <jle`> denotative and declarative approaches are encouraged, but imperative approaches are allowed as well in those cases where you would like them
19:49:39 <LordBrain> Qer: you can use applicative to program in a more functional style. In general, we need some way to solve the problem of real world side effects being necessary for useful programs... purely denotative programs without IO or such don't get you very far in practical terms.
19:49:39 <asr1> rwbarton: ok. so the stuff you were saying about laws comes into play when a type is an instance of both Monad and Asr1?
19:49:42 <jle`> s/allowed/possible
19:50:10 <jle`> LordBrain: denotative programs can have do IO...just look at anything with pipes :)
19:50:10 <twopoint718> How does one "move" binaries -- or even rename directories. Haskell binaries seem to include the full path to a sandbox.
19:50:18 <Qer> okay, seems reasonable
19:50:26 <jle`> or FRP
19:51:25 <jle`> in an ideal world we'd have a nice denotative framework that allows us to do anything we would ever need to do with IO
19:51:34 <jle`> without jumping into imperative mode
19:52:56 <jle`> (by ideal i mean ideal to me, of course :P)
19:53:01 <jle`> (and perhaps other people too)
19:53:23 <LordBrain> it is practically useful even to have a program which behaves in an unpredictable way by design
19:53:30 <carter> LordBrain: MCMC
19:53:35 <LordBrain> mcmc?
19:53:37 <carter> @google MCMC simulation
19:53:38 <lambdabot> http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo
19:53:38 <lambdabot> Title: Markov chain Monte Carlo - Wikipedia, the free encyclopedia
19:53:43 <LordBrain> oh
19:53:45 <jmcarthur> jle`: what about pipes makes it denotative?
19:54:51 <jmcarthur> jle`: i don't know what a Pipe denotes other than its representation, and its denotation certainly doesn't cover IO
19:55:06 <carter> randomnes is a powerfull tool LordBrain
19:55:16 <carter> also its a great tie breaker in coordination problems
19:55:18 <jmcarthur> s/representation/structure/
19:56:01 <LordBrain> you actually want to get as close as possible to true randomness in some applications, hence /dev/random and encryption etc. FRP makes the time an explicit input so theoretically it might one day be practical for videogames, tho i am not convinced it has the performance in implementations at present...
19:56:27 <Qer> this conversation elevated beyond my grasp ;D
19:56:44 <LordBrain> but FRP wouldn't handle the encryption issue
19:57:15 <jmcarthur> FRP doesn't directly mean anything about performance, although efforts so far to make it efficient have indeed not been very successful.
19:57:25 <rwbarton> twopoint718: if you linked dynamically against Haskell libraries then I guess you would need to set LD_LIBRARY_PATH appropriately if you renamed the sandbox
19:57:26 <augur> c_wraith: so where are those system calls in the GHC lib stuff
19:57:49 <c_wraith> Hmm.  I went looking for them.  Never did find them.
19:58:15 <jmcarthur> Qer: monads are not actually that important of a concept for haskell, nor do they make it imperative.
19:58:17 <rwbarton> twopoint718: (you would probably have to set it to something very long)
19:58:26 <conal> jmcarthur: i got several hundred frames/sec in a fran implementation in the late 90s.
19:58:56 <conal> thanks to using continuous time and a precise semantics.
19:59:04 <twopoint718> rwbarton: the real problem for me is that if I do: compile -> rename containing directory -> edit -> compile. Then that last compilation fails.
19:59:21 <rwbarton> this is with a sandbox?
19:59:26 <twopoint718> rwbarton: yes
19:59:30 <jmcarthur> conal: but is that really so impressive? what did those frames consist of?
19:59:38 <twopoint718> "cabal run" no longer works.
20:00:27 <twopoint718> And when I grepped for the previous directory name, there were hits in the compiled libraries
20:01:20 <rwbarton> I assume that is that ELF feature that tells the dynamic loader where to look for its dependencies
20:01:35 <conal> jmcarthur: it was impressive considering the hardware at the time. the key was using a run-time system that ran in a high-priority thread and used hardware-accelerated sprite transformations.
20:02:52 <rwbarton> twopoint718: you could turn off dynamic libraries ... if you don't want to use ghci or template haskell
20:03:03 <rwbarton> or you can just rm -rf your cabal sandbox
20:03:27 <LordBrain> i think frames per sec is a bit over emphasized... we don't need really to go over 60, and if we're running on a multipurpose machine, freeing resources for other programs might really be preferred.  But videogame makers want their bragging rights...
20:03:50 <conal> jmcarthur: of course now it would be much faster. the frp implementation didn't slow down the frame rate.
20:04:05 <LordBrain> tho for proofing a technology it is useful as a benchmark certainly
20:04:24 <jmcarthur> conal: i do think it's a fair point that for most applications the use of frp won't be the main bottleneck
20:04:28 <dolio> The people with 144 Hz monitors won't be impressed with your 60fps. :)
20:04:35 <conal> here's the paper: http://conal.net/papers/padl99/
20:04:46 <carter> conal: what prevents someone from resucitating fran?
20:04:55 <conal> carter: nothing.
20:06:11 * hackagebot cartel 0.8.0.0 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.8.0.0 (OmariNorman)
20:06:23 <carter> conal: ... the source links are all dead
20:06:52 <conal> carter: ah.
20:07:18 <conal> it must be around somewhere
20:07:24 <carter> :))))))
20:07:33 <carter> jmcarthur: hows things?
20:07:47 <carter> btw, i figured out some nice tricks to make sparse nice this past week
20:07:47 <carter> :)
20:07:52 <carter> that also shave a log n
20:08:02 <carter> factor off the complexity of naive sparse operations
20:08:03 <jmcarthur> carter: been keeping busy and playing card games instead of coding in my spare time
20:08:04 <carter> when done batch
20:08:09 <carter> cool
20:08:17 <carter> which ones?
20:08:32 <jmcarthur> this was an on-topic channel until now :)
20:08:43 <jmcarthur> moving to blah
20:10:14 <c_wraith> augur: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/IO/Handle/Text.hs#L538 will be of some interest.  That function is called by putStr.  It's not the bottom of the stack, but it is worth note
20:10:39 <augur> c_wraith: yes, i chased that around the other day
20:10:56 <augur> went way down, bottomed out at mask
20:11:20 <c_wraith> augur: mask is a red herring.  It's not the bottom of whatever you were looking at.
20:11:41 <augur> c_wraith: yeah, i know
20:11:55 <c_wraith> augur: I mean, you should be able to ignore mask completely.
20:11:57 <augur> whatever else i saw looked tangential too tho. so its curious!
20:12:52 <carter> dolio: are there any clever binary search libs for vector on hacakge?
20:13:11 <dolio> What kind of vectors?
20:13:19 <carter> of ints
20:13:26 <dolio> Mutable or immutable?
20:13:53 <carter> in this case, always immutable (they're the meta data arrays for my sparse matrix formats)
20:14:33 <carter> i remeber edward explaining you want a skew/slightly off center binary search
20:14:34 <dolio> Don't know of one. I think edwardk needed that not long ago, and ended up rolling his own.
20:14:34 <carter> in general
20:14:52 <edwardk> ?
20:14:58 <carter> like, i think on a range <= 5, cheaper to sequential scan
20:15:04 <edwardk> yeah i have that on slides
20:15:07 <LordBrain> perhaps haskell should have a no-gc mode
20:15:15 <LordBrain> for lowlevel applications
20:15:23 <edwardk> LordBrain: its called 'jhc' ;)
20:15:23 <carter> LordBrain: theres a ticket for a StableGen
20:15:25 <LordBrain> i am aware that the d programming language does this
20:15:39 <carter> edwardk: i thought jhc ..... just hasnt implemented a gc
20:15:45 <carter> @google ghc track stable gen
20:15:48 <edwardk> LordBrain: the thing is with closures everywhere its just not practical to not GC
20:15:48 <lambdabot> http://www.morningstar.com/invest/stocks/324425-ghc-generation-healthcare-reit.html
20:15:48 <lambdabot> Title: Stock Price Quote: ghc Generation Healthcare REIT - XASX - Morningstar
20:15:55 <carter> @google ghc trac stable gen
20:15:55 <lambdabot> https://ghc.haskell.org/trac/ghc/ticket/9052
20:15:56 <edwardk> carter: yeah it uses the boehm collector
20:16:05 <carter> LordBrain: edwardk  https://ghc.haskell.org/trac/ghc/ticket/9052
20:16:06 <Qer> guys, is there a data type in Haskell that stores tuples of two integers (small numbers, between 1 and 20) and is able to find and delete very fast? faster than linear search (lists)?
20:16:12 <LordBrain> edwardk, it might be acceptable to limit what functions are used etc... that's what d does
20:16:15 <Qer> hash table?
20:16:37 <carter> LordBrain: look at https://ghc.haskell.org/trac/ghc/ticket/9052 :)
20:16:42 <edwardk> LordBrain: D is strict. fundamentally different usage patterns.
20:16:42 <carter> its kinda close
20:16:43 <LordBrain> looking carter
20:17:02 <edwardk> LordBrain: and you're explicit about allocations there
20:17:06 <LordBrain> edwardk, haskell is only lazy by default, you can code strict stuff
20:17:12 <carter> ehhhh
20:17:20 <edwardk> LordBrain: not quite to the degree you are thinking
20:17:32 <edwardk> the very stack functions differently than you expect
20:17:38 <carter> once you look at how GHC et al work, you'd not quite say that
20:17:50 <carter> edwardk: its a stack of continuation thunks rihgt?
20:17:50 <LordBrain> hmm
20:18:04 <c_wraith> wow.  https://github.com/ghc/ghc/blob/master/libraries/base/GHC/IO/Handle/Text.hs#L645  is some impressively silly code for GHC
20:18:31 <carter> c_wraith: what about it?
20:18:55 <c_wraith> carter: well, it's just completely redundant.  The previous line is a when, so it clearly already has the right type
20:19:41 <carter> c_wraith: thats a valid patch to propose i think
20:19:47 <carter> make sure you test it locally
20:19:56 <c_wraith> I'm just browsing, not building.
20:20:02 <LordBrain> a stack of continuations doesn't really sound different then a call stack to me, c calling convention puts the return pointer on the stack generally speaking, so what's the difference?
20:20:07 <pingu> c_wraith: it's defense in depth
20:20:32 <dolio> The continuations are unrelated to function calls.
20:20:44 <LordBrain> but that's due to laziness...
20:20:53 <LordBrain> right?
20:21:17 <c_wraith> augur: I ran into trouble at flushByteWriteBuffer.  It's clearly what's doing the actual syscall, but it's apparently not defined anywhere in the GHC repo, much to my confusion.
20:21:39 <augur> c_wraith: interesting!
20:22:16 <LordBrain> if you made every function strict in your program, using your own prelude etc... wouldn't the continuations map to the c calling convention?
20:22:28 <rwbarton> c_wraith: it's in libraries/base/GHC/IO/Handle/Internals.hs
20:22:30 <augur> c_wraith: no i doubt it
20:22:44 <augur> https://hackage.haskell.org/package/base-4.5.0.0/docs/src/GHC-IO-Handle-Internals.html
20:22:45 <c_wraith> rwbarton: oh, I just figured out the search results
20:22:52 <augur> search for flustByteWriteBuffer :: Handle__ -> IO ()
20:22:53 <carter> LordBrain: ope
20:22:54 <carter> nopeeee
20:23:01 <carter> ghc has its own abi
20:23:05 <carter> and thats a good thing
20:23:13 <LordBrain> no.. i'm not saying it would be the c calling convention
20:23:14 <carter> can't do tail calls nicely
20:23:23 <augur> c_wraith: that seems to bottom out at reading and writing IORefs
20:23:24 <carter> then you didnt mean ABI
20:23:26 <carter> :)
20:23:40 <LordBrain> i'm saying it would map, that is, the tree structure of the call stack would be the same
20:23:56 <augur> c_wraith: so im guessing that whats going on somewhere is memory mapped IO? reading/writing to the memory addresses via refs?
20:24:14 <carter> not quite
20:24:23 <LordBrain> yeah,  but why not quite?
20:24:26 <carter> CPS
20:24:36 <carter> ghc compiles basic blocks into a CPS style
20:24:37 <rwbarton> augur: no it's going into whatever the 'write' field of haDevice of the handle is
20:24:39 <c_wraith> augur: it's calling a class function
20:24:51 <rwbarton> or the class method rather yeah
20:24:56 <c_wraith> augur: need to look at the instance definition
20:25:11 <augur> rwbarton: ??
20:25:27 <Qer> guys. concatMap = concat $ map. is there something like this for map and filter?
20:25:52 <pingu> Qer: it's not really the same, is it?
20:25:59 <pingu> both map and filter take different functions
20:26:01 <Cale> Qer: It's actually  concatMap f = concat . map f
20:26:04 <Qer> well, I think I meant concat . map
20:26:12 <Cale> Or  concatMap = (concat .) . map
20:26:13 <c_wraith> augur: https://github.com/ghc/ghc/blob/41f5b7e3e0648302b9c5dc485917a391d21d15a1/libraries/base/GHC/IO/Handle/Internals.hs#L498  That's doing the writing, somewhere down the line
20:26:14 <Qer> I'm not proficient in Haskell yet, sorry ;)
20:26:22 <c_wraith> augur: need to find the correct instance definition
20:26:33 <Cale> Qer: concatMap is already a pretty frivolous thing
20:26:36 <jle`> Qer: filter than map ...?
20:26:39 <jle`> map then filter?
20:27:10 <Cale> We definitely don't need special versions of every possible composition of higher order functions on lists.
20:27:13 <Cale> :)
20:27:22 <rwbarton> the only instance I see is in GHC/IO/FD.hs
20:27:36 <Qer> Cale: I heard that concatMap is good because it doesn't generate data it later throws away
20:27:45 <Cale> The fusion rules in the list library help to optimise away the intermediate lists anyway
20:27:57 <Cale> concatMap f and concat . map f will be compiled to the same code anyhow
20:28:18 <latro`a> I think concatMap is mostly a thing because (>>=) = flip concatMap
20:28:42 <Cale> If the compiler didn't have support for rewrite rules, then yes, concatMap would be a bit more efficient
20:28:51 <Cale> (though only by a constant factor)
20:28:54 <augur> c_wraith: ahhhh i see
20:29:12 <rwbarton> in FD.hs it eventually calls c_write which is an FFI import of write
20:29:37 <rwbarton> or possibly c_safe_write which is a safe FFI import of write
20:29:44 <LordBrain> Qer, since filter takes a predicate, how would that look?
20:29:46 <augur> c_wraith: probably somewhere in GHC.IO.Buffered
20:29:48 <c_wraith> augur: https://github.com/ghc/ghc/blob/6ed54303e2d3f1ef19df1312331a1740eca3ccdc/libraries/base/GHC/IO/FD.hs#L128 isn't the end of the line
20:30:01 <LordBrain> filterMap predicate function list?
20:30:09 <Qer> LordBrain: I have really no idea ;D
20:30:16 <Qer> yeah, perhaps
20:30:48 <latro`a> similarly I'm not sure why "maybe Nothing" isn't a thing with its own name, or either Left
20:30:50 <LordBrain> it probably actually is useful depending on context, but its not hard to write one up
20:31:06 <Qer> now it has to cycle through the list two times instead of once
20:31:18 <latro`a> (>>=) = either Left is kinda neat, actually
20:31:19 <LordBrain> filterMap p f = filter p . map f
20:31:22 <latro`a> never noticed that
20:32:01 <carter> edwardk: doyou have any binary search on a vector of ints codes lying around?
20:32:09 <augur> c_wraith: writeBuf is in BufferedIO.hs
20:32:22 <latro`a> er, flipped ofc
20:32:24 <augur> which leads to withBuffer
20:32:26 <Qer> btw guys, I just optimised my haskell code by like 1 000 times ;D
20:32:27 <c_wraith> augur: and it just calls an IODevice function
20:32:30 <carter> i can write one pretty easily of course, but figure i'd ask
20:32:36 <Qer> but not with filterMap ;D
20:32:44 <rwbarton> carter: do you know the one in vector-algorithms?
20:32:45 <edwardk> offset binary search: https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs#L156  on vectors https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs#L121
20:32:48 <c_wraith> augur: https://github.com/ghc/ghc/blob/6ed54303e2d3f1ef19df1312331a1740eca3ccdc/libraries/base/GHC/IO/FD.hs#L102
20:32:52 <LordBrain> Qer, you could also do it with a list comprehension [x | x <- xs, f x]
20:32:55 <augur> withBuffer is in Buffer.hs
20:33:00 <carter> rwbarton: theres one there?
20:33:02 <carter> huh,
20:33:04 <edwardk> carter: that work for you?
20:33:06 <carter> i'm depping on it already
20:33:11 <rwbarton> http://hackage.haskell.org/package/vector-algorithms-0.6.0.1/docs/Data-Vector-Algorithms-Search.html
20:33:30 <Qer> LordBrain: yeah, good idea ;)
20:33:32 <augur> c_wraith: ??
20:33:51 <edwardk> hrmm i should talk to dolo about tweaking those to offset binary
20:34:04 <carter> rwbarton: those require mutable vectors though
20:34:15 <edwardk> unsafeFreeze
20:34:18 <carter> yeah
20:34:20 <edwardk> er unsafeThaw
20:34:20 <carter> i knowww
20:34:23 <carter> yes
20:34:24 <carter> um
20:34:26 <c_wraith> augur: don't get distracted by withXXX functions.  Look at the action being performed inside them.  It's calling IODevice.raw, which is another class function.
20:34:26 <carter> that one
20:34:35 <rwbarton> carter: oh so they do
20:34:39 <rwbarton> how odd
20:34:40 <augur> c_wraith: oh
20:34:42 <c_wraith> augur: err, IODevice.write
20:34:48 <Qer> btw guys, any data type in haskell that offers faster than linear time delete?
20:35:21 <carter> yup
20:35:26 <carter> pure stuff can do log n
20:35:30 <LordBrain> Qer, if you mean that f a maybe type, then you can use mapMaybe
20:35:36 <c_wraith> augur: that eventually gets to https://github.com/ghc/ghc/blob/6ed54303e2d3f1ef19df1312331a1740eca3ccdc/libraries/base/GHC/IO/FD.hs#L535
20:35:46 <LordBrain> :t mapMaybe
20:35:47 <lambdabot> (a -> Maybe b) -> [a] -> [b]
20:36:01 <LordBrain> that might be what you meant by filterMap ?
20:36:03 <carter> Qer: Data.Map
20:36:07 <c_wraith> augur: and as rwbarton says, there's a call to c_write in there.
20:36:08 <carter> has log n delete
20:36:31 <Qer> LordBrain: actually yes ;)
20:36:56 <Qer> thats EXACTLY what I need ;D
20:36:58 <LordBrain> Qer, import Data.Maybe
20:37:23 <augur> c_wraith: ahh https://github.com/ghc/ghc/blob/41f5b7e3e0648302b9c5dc485917a391d21d15a1/libraries/base/System/Posix/Internals.hs#L418
20:37:26 <augur> thats the bottom
20:37:29 <augur> thats the end of the line
20:37:34 <Qer> okay
20:37:55 <augur> c_wraith: you did it! you found the bottom for me! :D
20:38:04 <c_wraith> augur: rwbarton found it for us. :P
20:38:10 <augur> c_wraith: i no longer know where the heck we are, but wherever it is, we're there
20:38:22 <c_wraith> Wherever you go, there you are.
20:38:41 <augur> c_wraith: so is it basically, ignoring all the buffering and junk, that putStr is calling c_write?
20:38:53 <augur> thats the core of it, modulo the fiddly details?
20:39:31 <c_wraith> augur: well, sometimes it calls c_safe_write, which is allowed to block
20:39:39 <augur> sure sure
20:39:59 <c_wraith> I mean, you could track it further...  But then you're going into libc and the kernel. :)
20:40:25 <augur> ok so, morally whats happening is that we're using the state monad to construct some internal haskell functions in a certain shape, and these functions ultimately FFI out
20:40:54 <augur> and these internal functions have the right type to enforce the shape we want as well
20:41:04 <c_wraith> Also, I'm shocked that IO ever happens with all those layers of wrapping.
20:41:15 * hackagebot system-filepath 0.4.12 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.12 (JohnMillikin)
20:41:36 <c_wraith> If you need fast IO, use the IO functions defined in bytestring or text. :)
20:41:48 <augur> so i can pretend like putStr is the FFIed function, and now i can begin to think of the problem correctly
20:42:20 <c_wraith> augur: you can't ignore *all* the layers of wrapping, necessarily.  There are some bits that matter.
20:42:40 <augur> c_wraith: yeah sure, but to get the core of the intuition i want, i probably can :)
20:44:57 <Qer> hahaha, guys, wanna have a laugh? look what I found in my haskell project:
20:44:59 <Qer> foldr (:) []
20:45:02 <Qer> :t foldr (:) []
20:45:03 <lambdabot> [a] -> [a]
20:45:08 <Qer> foldr (:) []  [1, 2, 3]
20:45:13 <rwbarton> nice function
20:45:18 <Qer> yea i know right
20:45:25 <Qer> im a genius
20:45:45 <c_wraith> Qer: wait 'til you read about foldr/build fusion
20:45:48 <augur> c_wraith: hm. so. morally what it comes down to is this i think: because FFI calls are opaque to the evaluator, they're as good as constructors, as far as evaluation is concerned i think
20:46:15 <Qer> c_wraith: what do you mean?
20:46:33 <c_wraith> Qer: foldr/build fusion is all about introducing as many calls to id into your code as possible.
20:46:45 <c_wraith> Qer: (and doing so in a way that removes intermediate lists)
20:47:14 <augur> c_wraith: that is to say, at least in so far as normalization is concerned, they might as well be constructors. at least the IO ones, because they'll never get normalized on their own because you cant get ahold of the right values
20:47:46 <augur> c_wraith: eg, since getStr :: IO String = RW -> (RW, String) and since there is no value of RW you can get ahold of, you can never call getStr directly
20:47:50 <yjdkygwtlh> Hey, can you guys help me with how to express an object-oriented sorta thing functionally?
20:48:28 <augur> c_wraith: so effectively getStr is a constructor, and only the compiler needs to care about it, not the evaluator
20:48:40 <LordBrain> There's not really a single goto solution for translating oo stuff, but go ahead yjdkygwtlh
20:48:54 <c_wraith> augur: that's basically true of all IO actions.
20:49:01 <augur> c_wraith: yeah
20:49:20 <augur> c_wraith: and even tho putStr isnt the primitive, all FFIs are IO's (iinm) so i can approximate
20:49:31 <LordBrain> by go ahead, i mean describe/paste your thing
20:50:13 <c_wraith> augur: you can do foreign imports that aren't declared as returning an IO action, but it's the same as applying unsafePerformIO to their result.
20:50:25 <augur> so thats what it comes down to: because IO/RW is an opaque type, youll never actually get to fully apply an IO a value (RW -> (RW,a)) to an RW value, so they'll never reduce via the normalizer
20:50:29 <yjdkygwtlh> So for background, I am implementing 2048 with pure functions (http://gabrielecirulli.github.io/2048/); that part is easy, but since I am doing some AI stuff it occurs to me that I want to replay the game afterwards
20:50:46 <augur> c_wraith: yeah, indeed. fair enough.
20:51:04 <yjdkygwtlh> obvious solution is to keep track of a) the player's move, and then b) where the random tile was placed afterwards
20:51:15 <augur> c_wraith: so basically we can pretend like these IO-type FFI functions are constructors, it makes no difference as far as evaluation is concerned
20:51:27 <c_wraith> yjdkygwtlh: and which tile.  2048 places 2 or 4 tiles as new tiles. :P
20:52:13 <augur> c_wraith: so morally, haskell IO is the instruction-style IO im a proponent of for pedagogical purposes, but with some hackery used to actually avoid this in actuality
20:52:57 <hunt> hey guys im having trouble locating the equivalent of (http://www.opengl.org/sdk/docs/man2/xhtml/glDrawPixels.xml) in Haskell OpenGL
20:53:23 <hunt> theres a lot of modules to search through, is there a better way to find this stuff then just browsing endlessly?
20:53:24 * Maxdamantus wonders if people considered writing the primitive IO actions as just datastructures instead of functions involving a magical RW thing.
20:53:31 <Maxdamantus> (in GHC)
20:54:10 <c_wraith> augur: by instruction-style do you mean like http://comonad.com/reader/2011/free-monads-for-less-3/ ?
20:54:12 <ReinH> yjdkygwtlh: Well, since 2048 involves a random component, the best thing to do is probably to store the position after each random tile is added.
20:54:15 <yjdkygwtlh> OO suggests storing that as maybe a side effect of the add_tile function, which can be easily done with IO (maybe to a file, for instance) but is there something more elegant to do instead?
20:54:18 <LordBrain> hunt there is the hoogle tool
20:54:24 <ReinH> pretty easy to do if you just keep a list of previous board states
20:54:33 <hunt> LordBrain: i have no idea what the function would be called
20:54:42 <augur> c_wraith: the crucial bit seems to be: getStr :: IO String is not immediately an FFI call, but rather it's a thunked FFI call
20:54:42 <LordBrain> hoogle lets you search on type
20:54:51 <hunt> LordBrain: as far as i can tell the opengl names and the hackage ones dont line up
20:55:01 <LordBrain> oh
20:55:03 <ReinH> you can do that with writer, state, etc
20:55:09 <hunt> unfortunately i was going to be crafting my data according to the type of the function LordBrain
20:55:11 <LordBrain> the bindings...
20:55:22 <yjdkygwtlh> ReinH yeah that's true, but you can do it better, with less memory, just tracking player actions and the coordinate (and value) of the random tile
20:55:35 <augur> c_wraith: thunked presumably because that's how we can avoid normalization applying to it, despite wanting to think of FFI calls as being normalizable in other cases
20:55:39 <ReinH> Why do you care about the memory?
20:55:51 <ReinH> How much memory do you think is needed to store a few hundred 4x4 board positions?
20:55:54 <yjdkygwtlh> because I am doing a version that has N-dimensions and multiple bases
20:55:58 <joelteon> is there a good library for reading an image, resizing it, then outputting it as a bytestring?
20:56:02 <joelteon> image-agnostic
20:56:10 <joelteon> like ImageMagick, but not incurring so many dependencies.
20:56:14 <LordBrain> hunt, i think you are stuck with browsing... but i don't know.
20:56:40 <yjdkygwtlh> e.g., 2's, 3's, 5's, and a board that is 6 by 6 by 6 by 6 ...
20:56:48 <augur> c_wraith: no, by instruction-style i mean    data IO a where { GetStr :: IO String ; PutStr :: String -> IO () ; Return :: a -> IO a ; Bind :: IO a -> (a -> IO b) -> IO b }
20:57:11 <augur> c_wraith: where literally, IO values are no more or less than an ADT representing instructions to the runtime/executor
20:57:16 <ReinH> Sure, then make a list of those instead
20:57:20 <LordBrain> hunt, you can browse the haddock pages, i assume thats what you meant by browsing... there is also :browse in ghci and :info
20:57:49 <hunt> LordBrain: apparently i was being presumptuous when i said the names dont line up... because thjey do!!!!
20:57:59 <augur> c_wraith: so that you're in some sense doing literate meta-programming on a simple IO-machine every time you write a haskell program
20:58:04 <hunt> http://hackage.haskell.org/package/OpenGL-2.9.2.0/docs/Graphics-Rendering-OpenGL-GL-PixelRectangles-Rasterization.html#v:drawPixels
20:58:17 <LordBrain> that makes it easier
20:58:28 <yjdkygwtlh> but I need to keep it abstract because I am using multiple agents, etc.,
20:59:51 <ReinH> yjdkygwtlh: keep what abstract?
21:00:10 <augur> c_wraith: in some sense that IS whats happening, but instead of having an ADT to code up these instructions, haskell uses thunked FFI calls instead, amounting to the same thing: we dont do FFI calls when we normalize an IO value because its a thunk and we dont normalize under lambdas
21:01:05 <LordBrain> joelteon, i don't know. you can try http://hackage.haskell.org/packages/#cat:Image%20Processing and http://hackage.haskell.org/packages/#cat:Image
21:01:33 <augur> the executor must work like so: normalize main, then apply it to () :: RW, yielding another IO value, normalize that, apply to (), etc.
21:01:59 <yjdkygwtlh> ReinH so that the agent code is kept separate from the environment code. All it knows is what the environment tells it, it doesn't necessarily know the structure of the environment in advance, or even that it's playing 2048
21:02:30 <ReinH> What do you need to keep abstract?
21:02:55 <rwbarton> the abstractions are themselves abstract
21:03:26 <ReinH> such abstract
21:03:55 <yjdkygwtlh> The agent calls a function w/ one argument and gets a natural number back
21:04:33 <ReinH> Ah, now we get to the actual problem
21:04:34 <yjdkygwtlh> it doesn't have access to the underlying representation of the board
21:05:02 <augur> actually, c_wraith it probably doesnt even need to cycle -- the application itself will trigger things appropriate i think? hmm
21:05:09 <ReinH> How does it recreate the board representation from a natural number?
21:05:26 <rwbarton> augur: right
21:05:42 <rwbarton> it's (>>=) that is responsible for performing a sequence of steps
21:05:43 <yjdkygwtlh> it doesn't, the board state is mapped to a natural number first
21:05:47 <joelteon> thanks LordBrain
21:05:51 <joelteon> not much help
21:06:04 <joelteon> i really really don't want to depend on imagemagick, but it might be inevitable
21:06:06 <ReinH> how does the agent work if it doesn't know the representation of the board?
21:06:16 <augur> rwbarton: yeah, and because (>>=) is just the one for state, its all chained together already
21:06:57 <yjdkygwtlh> the agent has an idea of how "valuable" each representation of the board state
21:07:08 <hunt> is there anyone very familiar with haskell opengl?
21:07:14 <Maxdamantus> data IO a = Return a | Bind (IO b) (b -> IO a) | FFICall CFunPtr [CValue]
21:07:20 <ReinH> How does it get that from a natural number?
21:07:36 <yjdkygwtlh> it performs dynamic programming in the sense of value iteration
21:07:56 <ReinH> Ok, so what is the actual problem here? It seems to have very little to do with your original question.
21:07:57 <yjdkygwtlh> http://webdocs.cs.ualberta.ca/~sutton/book/ebook/node44.html
21:08:18 <latro`a> Maxdamantus, what would be an example of a Bind value?
21:08:23 <augur> rwbarton: i think i see why lazy IO can be funky then -- you'll build up a giant stack of lets, some of which might never be called because their values arent used, and their FFIs never forced to normalize into an invocation of a foreign function
21:08:25 <augur> rwbarton: hm!
21:08:53 <Maxdamantus> latro`a: Bind (Return 4) (\n -> Return (n*2))
21:09:04 <yjdkygwtlh> it's not a real problem, more like I wanted to know if there's an idiomatic way of keeping track of things  the way I would in OO programming
21:09:05 <latro`a> ah
21:09:23 <LordBrain> joelteon, also, i found this: http://hackage.haskell.org/package/gd-3000.4.0
21:09:24 <latro`a> so the monad interface consists of "constructors" and then there are primitives
21:09:44 <ReinH> Well, State is useful for keeping track of things
21:09:57 <ReinH> Writer is useful for keeping a list of updates to some monoidal structure
21:10:09 <Maxdamantus> latro`a: the constructors are the primitives.
21:10:21 <augur> rwbarton: oh, well actually, no, because its state, you might be pulling the state value through (even tho it might be eraseable) because of the FFI calls
21:10:23 <rwbarton> Maxdamantus: you could do that, though it sounds pretty inefficient
21:10:28 <augur> but still, i imagine funkiness
21:10:31 <Maxdamantus> something like putStrLn would ultimately be constructed from a bunch of FFICalls.
21:10:51 <augur> Maxdamantus, rwbarton: the constructor-primitive thing is what i was suggesting before
21:10:54 <rwbarton> (plus there are a lot of things that aren't FFICalls, such as IORefs)
21:11:05 <augur> basically what im trying to do is understand why haskell DOESNT do that
21:11:12 <ReinH> or I should say making repeated updates to a monoidal structure as it works quite happily with monoids other than list
21:11:12 <Maxdamantus> Yeah, there should probably be a few more things anyway.
21:11:19 * hackagebot conduit 1.1.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.4 (MichaelSnoyman)
21:11:19 <Maxdamantus> like WritePtr, ReadPtr
21:11:24 <rwbarton> yeah
21:11:30 <Maxdamantus> that way you can actually get a CFunPtr from somewherep.
21:11:32 <augur> and my conclusion is: it soooort of does: instead of using constructors, it uses thunked FFI calls, which is just as good, as far as normalization is concerned
21:12:29 <augur> Maxdamantus, rwbarton: both behave like opaque objects -- both are constructor headed, but instead of being headed by GetStr, it's headed by a lambda, but it amounts to the same thing as far as normalization is concerned
21:12:58 <augur> but instead of needing an executor to run the instructions, you force, and the FFI calls unfurl
21:13:11 <yjdkygwtlh> ReinH that might be the best solution, but it seems less elegant. Thanks for the help.
21:13:17 <wildtype> I have a very basic question: Why does "main = interact reverse" not do what I expect?
21:13:27 <ReinH> yjdkygwtlh: why does it seem less elegant?
21:13:41 <rwbarton> wildtype, that depends, what do you expect?
21:14:22 <rwbarton> or more specifically, how does what it does differ?
21:14:22 <Maxdamantus> augur: thunked so you don't have to do something like dlsym("putStrLn") each time you try to print a line?
21:14:27 <wildtype> to print the reversed string when I hit enter.
21:14:39 <rwbarton> it prints the entire standard input, reversed
21:14:40 <Maxdamantus> (assuming dlsym is accessible through some primitive)
21:15:08 <rwbarton> so you'll have to "send end-of-file" (ctrl-D on unix)
21:15:34 <augur> Maxdamantus: thunked so that its morally equivalent to a constructor, and so we can think of FFI calls as being "merely" functions, rather than something special
21:16:21 <rwbarton> wildtype: otherwise you might be about to enter more input
21:16:21 <wildtype> hmmm. How does that differ from: main = interact $ reverse . head . lines , which behaves how I described?
21:17:01 <rwbarton> with "main = interact reverse" the program has no notion of lines
21:17:18 <rwbarton> so if you enter two lines, it will output the second one reversed, then the first one reversed
21:17:29 <augur> Maxdamantus: that is to say, you want + for Int's to be an FFI call, so you dont want your FFI to force it to be an IO action, but you also dont want to have to define an opaque IO type to support this
21:17:33 <rwbarton> so it can't output anything after you enter the first line
21:17:59 <augur> Maxdamantus: so instead you define IO a = () -> ((), a) which is a thunk! and it has a cheap monad instance
21:18:14 <augur> Maxdamantus: so you just have to force the thunk at the end, and voila
21:19:08 <LordBrain> :t interact reverse
21:19:09 <lambdabot> IO ()
21:19:14 <rwbarton> wildtype: but, "reverse . head . lines" can produce output as soon as it sees a newline. interact uses lazy IO, so it will provide your input to the function as you enter it
21:19:21 <Maxdamantus> This looks like it's breaking the rules again.
21:19:59 <wildtype> rwbarton: ahhhhhhh
21:20:07 <LordBrain> you can change the behavior of the lazy io by using hSetBuffering
21:20:18 <wildtype> thank you, that's what I was missing
21:20:19 <Maxdamantus> Part of the point of making primitives in an ADT would be that someone can't come along and write acme-realworld
21:21:07 <rwbarton> if interact used strict IO (read whole input, then output the result of calling the function on that input) then you'd need to end the input for "interact $ reverse . head . lines" also
21:22:05 <rwbarton> Maxdamantus: well, that's one good reason not to use the ADT interpreter-style IO then
21:22:20 <rwbarton> since unsafePerformIO is useful
21:22:40 <Maxdamantus> unsafePerformIO can still work.
21:22:50 <rwbarton> how would it work?
21:22:55 <augur> rwbarton: it seems like unless the monad instance for IO is eager, a program like this:   loop = do { x <- getStr ; putStr x ; loop }   will spin without performing any IO at all
21:22:56 <Maxdamantus> It would be a primitive function.
21:23:22 <rwbarton> oh, well, I guess
21:23:29 <augur> rwbarton: itll just build up lets for the IO actions that have yet to ever been called by anything eventually
21:24:39 <hunt> does Acme-RealWorld actually work as described?
21:24:40 <augur> er, getLine, not getStr
21:25:24 <augur> rwbarton: but it seems to work correctly in GHCi, so i guess that means IO's underlying state is eager?
21:25:31 <Maxdamantus> hunt: yes. I always have a ghci session open with a backup of the real world from 24 hours ago in a variable in case someone declares nuclear war.
21:25:55 <hunt> Maxdamantus: my bad, i thought it RealWorld referred to the internal state of the program
21:26:20 * hackagebot ShellCheck 0.3.3 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.3 (vidarhol)
21:26:43 <rwbarton> augur: I'm not totally sure what you mean, but if you mean it is like the strict rather than the lazy State monad, then yes
21:28:02 <augur> rwbarton: yeah, what i meant being something like..   x >>= f = \rw -> let !(rw', y) = runState x rw in runState (f y) rw'
21:28:08 <rwbarton> right
21:28:25 <rwbarton> this happens automatically because in IO, that tuple is actually an unboxed tuple
21:28:30 <rwbarton> there are no thunks of unboxed tuple type
21:28:43 <augur> right
21:28:52 <augur> its just magically erased
21:29:15 <augur> what is it, (# rw' , y #) or whatever the notation is?
21:29:16 <rwbarton> it's also magically erased yes
21:29:18 <rwbarton> yes
21:30:13 <augur> rwbarton, c_wraith: it all makes sense now! :D
21:30:44 <rwbarton> in fact I guess it's not really necessary to thread rw' from one action to the next like that
21:31:21 * hackagebot system-fileio 0.3.14 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.14 (JohnMillikin)
21:31:26 <rwbarton> but, it's a nice touch :)
21:31:59 <augur> rwbarton: yeah, in principle its not necessary, but for uniformity with the state monad, its a clarifying thing
21:32:23 <augur> apparently RealWorld ~ () anyway, so its all erased out of existence
21:32:51 <augur> its a good design, now that i understand it
21:33:19 <augur> but now i wonder why using haskell IO is such a pain, if its morally just the strict state monad
21:33:57 <Clint> oh the morality
21:35:00 * enthropy thought () gets a box
21:35:44 <augur> enthropy: probably does
21:35:46 <bitemyapp> enthropy: it does
21:35:51 <augur> hence why i said ~ :p
21:35:52 <rwbarton> right it's not actually ()
21:35:57 <bitemyapp> unboxed tuple is (# #)
21:36:00 <augur> its more or less a unit type
21:36:07 <rwbarton> more, in fact
21:36:14 <hunt> does anyone know how on earth i can draw pixel by pixel with haskell opengl? theres a function for it but i dont see how im supposed to pass data to the fucntion... this whole library seems pretty useless
21:36:15 <rwbarton> more so than () :P
21:36:43 <bitemyapp> hunt: that's not how OpenGL works.
21:36:49 <bitemyapp> hunt: you want a higher-level API
21:36:52 <bitemyapp> god-speed.
21:36:58 <hunt> bitemyapp: theres a function that copies a pixel buffer to the screen
21:37:12 <bitemyapp> hunt: you're talking about antediluvian stuff that shouldn't exist at all
21:37:18 <bitemyapp> hunt: and has been deprecated for years
21:37:23 <bitemyapp> hunt: you want a higher level API
21:37:33 <hunt> bitemyapp: sure? is there one?
21:37:40 <augur> rwbarton: yes, a true unit type!
21:37:50 <bitemyapp> hunt: in Haskell? Dunno.
21:38:11 <hunt> bitemyapp: pretty useless :P
21:38:25 <bitemyapp> hunt: not really, I just saved you years of doing OpenGL wrong.
21:38:46 <bitemyapp> hunt: if you must learn OpenGL specifically, learn how to manipulate retained-mode objects like vertices
21:38:51 <hunt> bitemyapp: no dude im not trying to do it right, this is a graphics project for which its our job to write line functions etc.
21:38:51 <bitemyapp> hunt: there are modern materials on OGL 3 and 4
21:39:03 <bitemyapp> welp.jpg
21:39:12 <hunt> bitemyapp: my task is to generate pixels, i just need some interface to put them on the screen
21:39:22 <hunt> bitemyapp: u think sdl would allow me this?
21:39:29 <carter> hunt: gloss might be nice
21:39:31 <carter> oh
21:39:33 <augur> rwbarton: i feel like i really understand now. like if i had to implement a bad version of this, i could
21:39:37 <carter> @google gloss raster haskell
21:39:38 <lambdabot> http://hackage.haskell.org/package/gloss-raster
21:39:38 <lambdabot> Title: Hackage: gloss-raster: Parallel rendering of raster images.
21:39:52 <hunt> carter: hey thanks! ill look into this
21:39:55 <carter> gloss-raster requires you have llvm installed mind you
21:40:03 <carter> something about it being too slow otherwise
21:40:17 <bitemyapp> hunt: yeah SDL might work
21:40:20 <hunt> carter: i dont really know much about llvm but should that concern me at all?
21:40:27 <carter> hunt: what OS are you on?
21:40:33 <hunt> bitemyapp: alright thanks dude! sorry if i came off as a neanderthal
21:40:52 <carter> and whats the big picture goal?
21:40:56 <carter> hunt: ALSO
21:41:02 <carter> @hackage juicy-pixels is COOOL
21:41:03 <lambdabot> http://hackage.haskell.org/package/juicy-pixels is COOOL
21:41:04 <hunt> carter: ubuntu 14.04, my problem isnt getting it im thinking on other os's/ in terms of overall speed
21:41:08 <bitemyapp> hunt: you didn't do anything wrong
21:41:13 <hunt> carter: this is really just a personal project
21:41:15 <carter> @hackage Juicy-Pixels is COOOL
21:41:15 <lambdabot> http://hackage.haskell.org/package/Juicy-Pixels is COOOL
21:41:22 <bitemyapp> carter: lol
21:41:28 <carter> woops https://hackage.haskell.org/package/JuicyPixels
21:41:35 <carter> theres also
21:41:40 <carter> @google rasterrific haskell
21:41:40 <lambdabot> No Result Found.
21:41:45 <carter> @google rasterific haskell
21:41:45 <lambdabot> http://hackage.haskell.org/package/Rasterific
21:41:45 <lambdabot> Title: Hackage: Rasterific: A pure haskell drawing engine.
21:42:01 <carter> that takes vectory objects, and renderst them to a raster (pixel) form
21:42:28 <carter> hunt: ifyou want more vectory things, the diagrams project is epic
21:42:32 <carter> @google diagrams project haskell
21:42:32 <lambdabot> http://projects.haskell.org/diagrams/
21:42:33 <lambdabot> Title: Diagrams - About diagrams
21:42:39 <hunt> jesus carter
21:43:02 <carter> the rasterific/juicy pixels author also has a font lib
21:43:07 <hunt> you know a shit ton of graphics
21:43:07 <carter> @google fonty fruity haskell
21:43:08 <hunt> projects
21:43:08 <lambdabot> https://hackage.haskell.org/package/FontyFruity
21:43:21 <carter> hunt: no, i just know about EVERY public haskell project of any quality thats public
21:43:25 <carter> :)
21:43:36 <carter> ish
21:44:03 <hunt> carter: whats your favorite project
21:44:09 <carter> for what
21:44:16 <carter> pick a topic/ domain
21:44:23 <augur> rwbarton: what are these # things, like State#?
21:44:35 <augur> theres a whole bunch in GHC.Base
21:44:43 <carter> unlifted types
21:44:48 <carter> have *# convention
21:45:03 <augur> unlifted = unboxed?
21:45:06 <carter> not quite
21:45:09 <carter> though kinda
21:45:19 <carter> unlifted implies unboxed
21:45:22 <bitemyapp> I'm lame, I think stuff like Repa is cool :)
21:45:34 <carter> repa is probably pretty handy for his case
21:45:37 <carter> its good for picture things
21:45:40 <carter> welllll
21:45:41 <carter> nop
21:45:48 <augur> ahh, docs say cant be bottom
21:45:55 <carter> Yarr is a patched version of repa with pixel types
21:45:57 <carter> @hackage yarr
21:45:58 <lambdabot> http://hackage.haskell.org/package/yarr
21:46:08 <augur> so i guess possibly boxed, but never thunked?
21:46:32 <carter> augur: unlifted types are never boxed...
21:46:33 <hunt> well my current solution is to just pretend every vertex is a pixel, but its not flat up against the camera so it looks slightly weird
21:46:33 <carter> afaik
21:46:40 <augur> carter: oh ok
21:46:44 <rwbarton> no
21:46:50 <rwbarton> unboxed types are never lifted
21:47:05 <carter> well, what do we mean by unboxed
21:47:21 <carter> a lifted type can have unboxed packed fields
21:47:26 <carter> but itself can be boxed
21:47:37 <rwbarton> boxed means the value is a pointer to an object on the heap that the GC can move etc.
21:48:00 <rwbarton> lifted means it might be a thunk
21:48:04 <pjdelport> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects might be interesting reading
21:48:40 <augur> docs also mention no indirection
21:49:34 <carter> oh
21:49:38 <carter> ok
21:49:39 <carter> yeah
21:49:50 <augur> what is meant by indirection here?
21:50:17 <rwbarton> "Indirection closures just point to other closures. They are introduced when a thunk is updated to point to its value. The entry code for all indirections simply enters the closure it points to. "
21:50:37 <augur> hm
21:52:05 <nisstyre> rwbarton: and I assume closures are basically just a struct with an environment, a function and whatever else it needs to be invoked?
21:52:13 <nisstyre> (I have no idea what format GHC uses for them)
21:52:25 <augur> rwbarton: why do you know all this stuff!
21:52:52 <bitemyapp> augur: maybe he reads
21:52:56 <bitemyapp> or she
21:54:09 <rwbarton> nisstyre: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects is a better description than I could provide
21:54:16 <rwbarton> note that every heap object is called a "closure"
21:55:48 <nisstyre> rwbarton: I did click that and found this which I find useful https://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h
21:56:01 <rwbarton> there isn't an environment per se
21:56:18 <rwbarton> just pointers to whatever other heap objects the closure needs to reference
21:56:38 <nisstyre> rwbarton: I know in some SML implementations it's another struct with the objects it needs
21:56:47 <nisstyre> and then it just extracts them via fields
21:56:57 <nisstyre> that's sort of what I meant by an environment
21:58:06 <rwbarton> ML has the same sort of attitude regarding mutable objects as Haskell so I bet it's pretty similar
21:58:26 <rwbarton> i.e. there are no "variables", but there are reference cells
21:59:56 <nisstyre> yeah
22:00:04 <nisstyre> rwbarton: and you are allowed to freely copy stuff
22:00:18 <nisstyre> so it adds space but then you can freely use many different closure formats
22:00:34 <nisstyre> there's no need to have one true reference
22:00:42 <rwbarton> right
22:01:13 <nisstyre> the whole thing is very mind expanding
22:06:25 * hackagebot async-manager 0.1.1.0 - A thread manager for async  http://hackage.haskell.org/package/async-manager-0.1.1.0 (JonathanFischoff)
22:08:50 <rwbarton> what I found most surprising is that an evaluated data constructor has the same format, with a function that essentially just returns immediately
22:09:30 <nisstyre> rwbarton: it probably simplifies things
22:09:37 <anuvrat> please take a look at http://codeforces.com/contest/1/submission/6737997 and help me understand why the result of multiplication of 5208334 and 5208334 is -270385980?
22:09:56 <rwbarton> it means you can evaluate anything by jumping to its code pointer
22:10:41 <nisstyre> if there's one thing I've learned about functional compilers, it is that making as many things a special case of something more general is good
22:10:49 <nisstyre> because then you only have to worry about that general thing
22:11:12 <nisstyre> I guess that applies to software in general :p
22:11:51 <glguy> anuvrat,
22:12:05 <glguy> > 5208334 * 5208334 :: Int32
22:12:05 <lambdabot>  -270385980
22:12:21 <glguy> It's using a 32-bit integer. On 32-bit platforms, the Int type is Int32
22:13:33 <Maxdamantus> >> 2^31 - 1 + 270385980
22:13:42 <Maxdamantus> > 2^31 - 1 + 270385980
22:13:47 <lambdabot>  2417869627
22:14:19 <anuvrat> glguy, so what can I do to get the right answer?
22:14:25 <Maxdamantus> er, meh
22:15:12 <benbangert> anyone use the binary package know if Int64 is 4 bytes, or 8 bytes? I'm gonna assume 8, but the doc string for the Int64 is wrong in that case
22:15:32 <nisstyre> benbangert: how could it be anything other than 8 bytes?
22:15:52 <dmj`> > 8 * 8
22:16:27 <benbangert> think its just a copy/paste error, the source says: -- Int64s are written as a 4 bytes in big endian format
22:16:29 <rwbarton> anuvrat, use Integer not Int
22:16:29 <nisstyre> must be
22:16:35 <benbangert> but the Binary Int instance says: -- Ints are are written as Int64s, that is, 8 bytes in big endian format
22:16:38 <nisstyre> he could have a valid reason to use fixed width integers
22:16:38 <lambdabot>  64
22:16:42 <nisstyre> like dealing with binary protocols
22:16:52 <rwbarton> oh, well, in this case I read his program :)
22:16:54 <benbangert> dmj`: yea, thats what I figured, was just reconciling it with what the doc strings said
22:17:08 <nisstyre> but in that case you probably want Word
22:17:27 <anuvrat> rwbarton, cool thanks, I guess I need to go back and read that chapter on types :)
22:17:27 <nisstyre> signed types are usually not used to pack binary protocols afaik
22:18:33 <akurilin> Is there a recommended approach to running map over two lists at once? e.g. I want to zip two lists into a list of pairs
22:18:47 <akurilin> I suspect there's a base function out there somewhere that does it already :|
22:18:50 <nisstyre> akurilin: zipWith?
22:19:15 <nisstyre> yeah I believe you want zipWith
22:19:22 <Maxdamantus> zip already zips two lists into a list of pairs.
22:19:37 <nisstyre> Maxdamantus: "running map over two lists at once"
22:20:34 <akurilin> In clj map supports multiple collections at once if I recall correclty, I was lookgin for something along those lines, but this seems even more appropriate
22:20:37 <Maxdamantus> Yeah, I guess zipWith is the answer to the first thing and zip the second.
22:20:38 <akurilin> let me look for it
22:21:01 <rwbarton> I was about to say, must be a lisp programmer.
22:21:02 <Maxdamantus> (since zip does that, probably in terms of zipWith)
22:21:12 <akurilin> rwbarton: don't hate :P
22:21:29 <akurilin> yeah zip literally does that, that's super convenient
22:21:31 <Walther> > let zipmap x y = zip (map (+1) x) (map (+2) y)
22:21:33 <lambdabot>  not an expression: ‘let zipmap x y = zip (map (+1) x) (map (+2) y)’
22:22:05 <nisstyre> Maxdamantus: zw f xs ys = map (uncurry f) $ zip xs ys
22:23:02 <nisstyre> rwbarton: yeah I like that aspect of map in Scheme but it would be annoying to do in Haskell
22:23:12 <nisstyre> you could do it with the usual type class trickery I guess
22:23:42 <nisstyre> @src zipWith
22:23:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
22:23:42 <lambdabot> zipWith _ _      _      = []
22:23:52 <nisstyre> @src zip
22:23:52 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
22:23:52 <lambdabot> zip _      _      = []
22:24:57 <Heather> Hi
22:25:11 <Heather> if I've got data structure with Maybe fields how can I fill it?
22:25:12 <Maxdamantus> Greetings and salutations.
22:25:15 <nisstyre> I wonder why neither of those are defined in terms of the other
22:25:25 <nisstyre> since zip could be zip = zipWith (,)
22:25:59 <Heather> e.h. data A = A { b : Maybe String } -- How to create A ?
22:26:40 <nisstyre> Heather: you call it with something that has the type Maybe String
22:26:46 <nisstyre> for example A (Just "foobar")
22:26:56 <Maxdamantus> or A Nothing
22:26:59 <latro`a> you can also build it with record syntax
22:26:59 <nisstyre> and then you can extract (Just "foobar") by calling b on the result of that
22:27:00 <anuvrat> hi, https://dpaste.de/NHe8 . please take a look at it and tell me if I can optimize / shorten / make it better?
22:27:09 <latro`a> baz = A { b = Just "hi" }
22:27:12 <nisstyre> b is a function that extracts the field for you
22:27:20 <dmj`> anuvrat: cool snippet site
22:27:23 <Heather> nisstyre: I see it will parse Just "foobar" as Maybe....
22:27:26 <Heather> thanks
22:27:33 <latro`a> building it with record syntax lets you fill the fields out of order
22:27:35 <akurilin> Btw do people ever "add" to a pair to make a triple etc? Is that not a common use case?
22:27:40 <nisstyre> Heather: yes it will give it the type Maybe String
22:27:52 <nisstyre> that happens when you run ghc on your code
22:28:18 <nisstyre> akurilin: you mean like (a,b) -> c -> (a,b,c) ?
22:28:26 <dmj`> anuvrat: a lot of that code is just waiting for runtime exceptions to occur
22:28:38 <dmj`> let [m,n,a] = f (words z)
22:28:48 <dmj`> map read
22:28:52 <nisstyre> -fwarn-incomplete-patterns is a good habit to get into
22:29:05 <akurilin> nisstyre: yeah
22:29:35 <akurilin> nisstyre: I see people use (,) <$> sometimes
22:29:44 <nisstyre> akurilin: I've done that before
22:29:46 <dmj`> anuvrat: is your goal to have correct code or prove to someone haskell is more terse than python?
22:29:46 <akurilin> but isn't the limit with that, that you can only make paris?
22:29:48 <akurilin> *pairs
22:29:51 <nisstyre> that code was ugly as hell though
22:30:29 <anuvrat> dmj`, well I wanted to read three integers from stdin ... I am just trying to solve  http://codeforces.com/contest/1/problem/A ... and in the process learn haskell
22:30:38 <akurilin> nisstyre: is that an example of someone being overly clever?
22:30:50 <nisstyre> akurilin: maybe, it is kind of obtuse
22:30:55 <nisstyre> not as bad as some things though
22:31:37 <nisstyre> akurilin: anyway, for one, you can't use fst and snd on (a,b,c)
22:32:34 <akurilin> fair enough
22:33:41 <nisstyre> akurilin: I had something like let result | a == b = foo | otherwise = bar in result in my code in front of a room full of researchers/people who've been using Haskell for a while and nobody had seen it before
22:33:49 <nisstyre> so it's possible to do something that seems obvious to you
22:33:53 <nisstyre> but is obtuse to others
22:36:38 <akurilin> well most things are oblivious to me at my point in haskell learning so I have that advantage right now :)
22:38:52 <anuvrat> dmj`, what wolud be the best way to read three integers from stdin?
22:39:15 <rwbarton> your way is good
22:39:30 <rwbarton> assuming that the contract of your program is that it will receive three integers on a line on stdin
22:39:46 <rwbarton> I would write it a little more succinctly
22:40:00 <rwbarton> [m, n, a] <- map words <$> getLine
22:40:05 <taktoa> write a parsec parser for it /s
22:40:08 <rwbarton> er
22:40:11 <rwbarton> [m, n, a] <- map read . words <$> getLine
22:46:39 <dmj`> (a,b,c) <- (,,) <$> readLn <*> readLn <*> readLn :: IO (Int, Int, Int)
22:46:48 <dmj`> still suffers from parseExceptions tho
22:47:00 <dmj`> I would use readMaybe from Text.Read
22:47:37 <dmj`> do { a <- getChar; case readMaybe a :: Maybe Int of { Nothing -> putStrLn "boo"; Just int -> print int } }
22:49:19 <akurilin> Is there a sane way of finding the latest version of a package when using hackage?
22:49:39 <bitemyapp> akurilin: cabal list?
22:49:40 <akurilin> I generally have to go back to the summary page, choose the right version, and dig back into it
22:50:04 <akurilin> sorry let me rephrase that: when I google for a package documentaiton, I always end up on some random past version
22:50:16 <akurilin> it'd be great to be looking at the latest iteration
22:50:26 <dmj`> akurilin: cabal info text | grep Versions
22:50:53 <dmj`> do a cabal update first
22:51:40 <dmj`> akurilin: when browsing use this: https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf?hl=en-US
22:51:44 <akurilin> am I the only one to look up package docs in my browser?
22:51:59 <dmj`> it provides a link to the latest version of the docs in the upper right hand corner
22:52:14 <dmj`> works for me
22:54:00 <akurilin> dmj`: aah there you go, that's pretty useful
22:54:02 <akurilin> thanks for that one
22:55:38 <dmj`> np
22:56:55 <dmj`> also, readMaybe takes a String, not a Char
22:57:57 <hunt> im trying to work with the OpenGL library and a lot of stuff requires input of the Ptr type, i have no idea how to generate pointers. could anyone give me some pointers?
22:58:05 <hunt> (lol)
22:58:51 <dmj`> hunt: http://web.cecs.pdx.edu/~sheard/course/Cs163/Doc/PtrReview.html
22:58:51 <liyang> @hoogle [a] -> (a -> f [b]) -> f [b]
22:58:53 <lambdabot> No results found
22:59:46 <dmj`> @typ liftM concat . flip mapM
22:59:47 <lambdabot> [a1] -> (a1 -> [a]) -> [a]
23:00:11 <dmj`> @typ flip concatMap
23:00:12 <lambdabot> [a] -> (a -> [b]) -> [b]
23:03:54 <hunt> how can i load Graphics.Rendering.OpenGL in ghci?
23:04:05 <hunt> its getting not found
23:04:08 <hunt> it works for ghc
23:04:30 <dmj`> @typ \f -> liftM concat . mapM f
23:04:32 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
23:05:00 <dmj`> @typ \f -> flip . liftM concat . mapM f
23:05:02 <lambdabot>     Couldn't match type ‘[a1]’ with ‘b -> c’
23:05:02 <lambdabot>     Expected type: (a -> [[a1]]) -> a -> b -> c
23:05:02 <lambdabot>       Actual type: (a -> [[a1]]) -> a -> [a1]
23:05:16 <hunt> dmj` take this to ur neighborhood interpreter
23:05:47 <hunt> does anyone know about why ghci might not know about a library?
23:08:00 <Fuuzetsu> is the library installed?
23:08:07 <Fuuzetsu> are you using cabal?
23:09:34 <anuvrat> rwbarton, hey ... https://dpaste.de/hvkH  [m, n, a] <- map words <$> getLine says <$> not in scope :(
23:09:59 <newsham> import Control.Applicative ?
23:10:50 <newsham> ?hoogle (<$>)
23:10:51 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
23:10:51 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:11:25 <hunt> Fuuzetsu yes and yes
23:11:30 <hunt> i have a different question as well
23:11:40 <Fuuzetsu> hunt: did you run ‘cabal repl’?
23:11:45 <hunt> ill try it
23:11:48 <Fuuzetsu> (are you using a sandbox)
23:12:17 <hunt> im trying to call an opengl function that takes a ptr and the data format of the ptr, but im not sure how i can write beyond the memory address of the pointer
23:12:30 <hunt> Fuuzetsu: pretty sure im not, although not totally sure
23:12:42 <hunt> basically how do i write a real array?
23:13:00 <anuvrat> https://dpaste.de/8thi
23:13:01 <Fuuzetsu> you shouldn't write beyond the pointer, that's evil
23:13:10 <hunt> to the next address!
23:13:13 <hunt> the succ ptr!
23:13:59 <hunt> anuvrat: try words instead of map words
23:14:13 <hunt> er my bad anuvrat, fmap words
23:14:25 <Fuuzetsu> hunt: but how do you know succ ptr is not your program?
23:14:36 <newsham> the FFI lets you allocate memory and manipulate pointers
23:14:45 <hunt> Fuuzetsu: ill malloc it! I dont know! How does OpenGL expect me to do this?
23:15:00 <anuvrat> hunt, err that gives me a list of words ... I want to read numbers
23:15:03 <hunt> i wish people in the haskell community actually used that library
23:15:14 <Fuuzetsu> hunt: not by manually writing to memory
23:15:17 <Fuuzetsu> hunt: which library?
23:15:21 <hunt> anuvrat: how would the words function give you numbers
23:15:34 <hunt> anuvrat: it separates by spaces
23:15:42 <anuvrat> hunt, yes in my particulary case it is ...
23:15:43 <hunt> anuvrat: over a [Char]
23:16:06 <hunt> Fuuzetsu: OpenGl
23:16:12 <anuvrat> hunt,  okay ... I want to read a list of numbers from stdin
23:16:39 <newsham> are you writing your own bindings to opengl?
23:16:41 <hunt> anuvrat: i dont think i can help you with this, im quite busy with my own problems
23:16:42 <Fuuzetsu> hunt: Downloads	9275 total (1152 in last 30 days)
23:16:47 <Fuuzetsu> so yes there are people using it
23:16:50 <Fuuzetsu> IIRC it has examples
23:16:55 <anuvrat> hunt, okay .. thanks anyways
23:16:59 <Fuuzetsu> you could also e-mail the maintainer, he's very helpful
23:17:09 <newsham> anuvrat: do you know how to read stdin?
23:17:23 <hunt> Fuutzetsu: oh really? i would feel bad wasting his time with a question thats pretty much asking for a tutorial
23:17:26 <anuvrat> newsham, getLine right?
23:17:44 <newsham> well "getContents" can give you it all
23:17:52 <Fuuzetsu> hunt: Well, post to the ML with what you want to do and how far you got and someone will answer
23:17:59 <Fuuzetsu> maybe even me later when I'm less tired and less busy
23:18:04 <hunt> Fuuzetsu: whats the ML?
23:18:15 <Fuuzetsu> mailing list
23:18:28 <newsham> then you can take the output of getContents and split it up into lines or words or whatever you choose, and then convert the whole lot of them into numbers if you wish
23:18:36 <Fuuzetsu> which function in the library are you trying to use?
23:19:00 <hunt> Fuuzetsu: drawPixels, its for a class project in which im supposed to be drawing my own pixels
23:19:12 <newsham> anuvrat: is that helpful?
23:19:25 <hunt> Fuuzetsu: i need PixelData which has a Ptr a in it, and is befuddling
23:19:38 <hunt> Fuuzetsu: how do i get this onto the mailing list?
23:19:57 <newsham> hunt: this one?  https://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/Graphics-Rendering-OpenGL-GL-PixelRectangles-Rasterization.html
23:20:06 <hunt> newsham: yea
23:20:38 <hunt> Whats confusing is that the Ptr for PixelData appears to be holding more than a singular piece of information, because glDrawPixels only takes one of them
23:20:39 <newsham> the page says there are several constructors for making pixeldata's
23:20:51 <Fuuzetsu> hunt: pretty sure you're meant to stick your pixel values into something using Storable then just chuck it in there
23:20:54 <newsham> are those constructors not suitable?
23:21:05 <hunt> newsham: i dont know what to put in the Ptr
23:21:15 <hunt> Fuuzetsu: is storable a GL thing?
23:21:22 <newsham> oops, those are pixelformats
23:22:01 <Fuuzetsu> hunt: no, Foreign.Storable in base
23:22:16 <Fuuzetsu> you can click on things on Hackage and it will take you places
23:22:32 <hunt> Fuuzetsu: yea sorry that was a stupid question
23:23:03 <anuvrat> newsham, is there a better / standard / shorter way to read three integers from a single line on stdin  than https://dpaste.de/cE19?
23:23:31 <Fuuzetsu> hunt: http://stackoverflow.com/questions/14226905/reading-pixels-from-opengl-glut-application might help you even though it's about readPixels (similar type signature)
23:23:34 <newsham> there's an example here with drawPixels https://github.com/haskell-opengl/GLUT/blob/master/examples/RedBook4/Image.hs
23:24:27 <Fuuzetsu> yep, this is the examples I was referring to earlier
23:24:29 <hunt> wow thanks guys for being so helpful
23:24:46 <Fuuzetsu> if you have the red book on hand, they are the implementations of programs from there
23:24:51 <newsham> anuvrat: yah, you could merge that to a single line..  but thats already pretty decent
23:25:10 <anuvrat> newsham, how?
23:25:56 <newsham> ie:  [w1, w2, w3] <- map readInt <$> getLine           readInt :: String -> Int; readInt = read
23:26:20 <newsham> oops, forgot words
23:26:36 <newsham> ie:  [w1, w2, w3] <- (map readInt . words) <$> getLine           readInt :: String -> Int; readInt = read
23:27:59 <newsham> btw, that will error if there arent 3 words.. is that ok for your purposes?
23:30:51 <wildtype> I have a basic conceptual question. How do you handle state in something like a ToDo list with a sequence of actions?
23:31:08 <hunt> newsham Fuuzetsu thanks so much the red book example seems to be exactly what i need to write this!
23:31:19 <newsham> awesome
23:31:34 * hackagebot HLearn-algebra 1.1.0.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.1.0.1 (MikeIzbicki)
23:31:49 <anuvrat> newsham, is there any specific reason why you enclose $ in angle brackets when pasting stuff here?
23:31:52 <newsham> this seems like a pretty low-level API...
23:31:53 <anuvrat> newsham, thanks btw
23:32:03 <newsham> anuvrat: <$> is an operator, different from $
23:32:08 <newsham> ?src (<$>)
23:32:09 <lambdabot> f <$> a = fmap f a
23:32:40 <newsham> could also be written:    [w1,w2,w3] <- (map readInt . words) `fmap` getLine
23:32:59 <newsham> ?src ($)
23:33:00 <lambdabot> f $ x = f x
23:33:46 <newsham> the fmap or <$> lets me take the IO result from getLine and run some pure actions on it
23:33:57 <newsham> namely (map readInt . words)
23:34:20 <anuvrat> new sham when I put <$> in my file ... runhaskell complains saying <$> is not in scope
23:34:36 <newsham> "import Control.Applicative"  in your program
23:34:48 <newsham> ?hoogle (<$>)
23:34:49 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
23:34:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:35:56 <anuvrat> newsham, ohkay ... thanks :)
23:37:34 <wildtype> Any takers for my question? Or can someone point me to an example?
23:38:00 <coppro> wildtype: Can you describe in a little more detail what you're trying to do?
23:39:42 <wildtype> Just understand a functional approach to something basic like a todo list. All the examples I can find either a.) only perform a single action from the command line and quit, or b.) use a file as if it was a mutable var, which seems like cheating.
23:40:05 <osa1> "All variants of Int are represented internally by an Int#... thus, for using Int8 to save sapce isn't actually saving space, at least right now." <- is this really correct? (quoted from a lecture note)
23:40:55 <newsham> one approach is to keep the state explicitely.  Ie. have an IO procedure which takes in a todo list as an arg, and when you take an item off the list, recurse with an updated list
23:41:17 <newsham> haskell also supports imperative data types that can be updated
23:41:33 <wildtype> Does that leave me with a huge stack of lists in past states?
23:41:33 <newsham> and has some mechanisms for hiding the explicit state so it gets passed implicitely instead
23:42:00 <coppro> wildtype: Not necessarily. If you're thinking of a read-eval-print loop, one simple approach is to make a function that recurses
23:42:05 <Yuu_chan> osa1: sounds very strange
23:42:27 <newsham> the past states get garbage collected automatically
23:42:55 <osa1> Yuu_chan: however, I just checked and both Word16 and Word8 uses same GHC.Prim.Word# internally
23:43:00 <coppro> so you get like dorepl :: State -> IO (); dorepl state = do { {- stuff -}; dorepl newstate; }
23:43:03 <newsham> and the compiler doesnt necessarily need to keep a stack for the recursion
23:43:16 <osa1> Yuu_chan: even Word32 uses same GHC.Prim.Word#
23:43:27 <osa1> Yuu_chan: so I guess that's a correct statement
23:43:27 <wildtype> How does Haskell know that it's tail recursion and safe to jettison old states?
23:43:28 <coppro> wildtype: for more advanced applications, there are things like the State monad
23:43:33 <Yuu_chan> osa1: data {-# CTYPE "HsInt8" #-} Int8 = I8# Int# deriving (Eq, Ord, Typeable) --from Data.Int
23:43:49 <newsham> the compiler can do tail-call optimization
23:44:06 <coppro> wildtype: Objects are reference counted. Tail recursion is very easy to detect in a compiler
23:44:52 <wildtype> Is it a good idea to think of the State monad as analogous to a finite state machine?
23:45:35 <coppro> wildtype: No. The State monad can have infinite state
23:45:53 <wildtype> Hmmmm
23:45:59 <coppro> it's just a way to hide a state and pass it from a computation to another one far away
23:46:21 <newsham> the state monad is just a way to make that implicit state passing in coppro's dorepl example implicit.
23:46:30 <pjdelport> wildtype: You can think of it as being essentially just like having a stateful variable in an imperative language, except that everything is explicit.
23:46:42 <hunt> anyone know how i could convert a Float to a GLubyte?
23:47:22 <coppro> I could show you some examples of code that should really be rewritten using State, for instance, but I haven't had time to actually rewrite them :)
23:47:28 <newsham> when using the state monad you start with small functions and use the monad to paste them together into bigger monads..  which gives you the tools from the monad libraries and the do-notation sugar
23:47:52 <coppro> newsham: this is true of any monad ;)
23:47:55 <pjdelport> wildtype: So State makes modifications first-class, instead of implicit, in an analogous way to how e.g. IO makes actions explicit instead of implicit.
23:48:06 <coppro> or any typeclass really
23:48:37 <Yuu_chan> copro: I think it's finite (state machine) rather than (finite state) machine
23:48:40 <newsham> hunt: is GLubyte an enum or integral?  you could go to integer and then fromEnum and toEnum, or fromIntegral
23:49:32 <newsham> > execState (do { x <- get; modify (*2); return (5*x-1) })   100
23:49:34 <lambdabot>  200
23:49:40 <newsham> > runState (do { x <- get; modify (*2); return (5*x-1) })   100
23:49:42 <lambdabot>  (499,200)
23:49:53 <wildtype> Interesting. Can anyone point to a small example that uses the State monad in a clear way? ie. Not to generate random numbers
23:50:03 <hunt> newsham: integral, thanks
23:50:08 <newsham> > runState get 100
23:50:10 <lambdabot>  (100,100)
23:50:18 <newsham> > runState (modify (*2)) 100
23:50:20 <lambdabot>  ((),200)
23:50:46 <newsham> wildtype: generating random numbers is a perfectly sane thing to want to do with the state monad
23:51:22 <Yuu_chan> wildtype: I once used State to imitate a 2d loop translated form an imperative pseudocode
23:51:25 <wildtype> I believe that. It's just not very illuminating.
23:51:31 <Yuu_chan> s/form/from
23:51:55 <newsham> I think the most illuminating way to understand state monad is use small examples in lambdabot and then build bigger examples
23:52:20 <newsham> state monad just gives you a function from an old state to a new state and a result, and ways to glue together these functions
23:52:35 <newsham> one such program is "get"
23:52:40 <newsham> > runState get 100
23:52:42 <lambdabot>  (100,100)
23:52:50 <newsham> its just a function from s to (s,s)
23:52:55 <newsham> another one is "put"
23:53:07 <newsham> > runStte (put 33) 100
23:53:08 <lambdabot>  Not in scope: ‘runStte’
23:53:08 <lambdabot>  Perhaps you meant one of these:
23:53:08 <lambdabot>    ‘runState’ (imported from Control.Monad.State),
23:53:08 <lambdabot>    ‘runSetter’ (imported from Control.Lens),
23:53:08 <lambdabot>    ‘runStateT’ (imported from Control.Monad.State)
23:53:12 <newsham> > runState (put 33) 100
23:53:14 <lambdabot>  ((),33)
23:53:33 <newsham> its just a function from s to ((), somevalue)
23:53:49 <newsham> from that you can build more interesting programs like modify
23:53:53 <wildtype> the result is the first value of the tuple and the new state is the second?
23:54:18 <newsham> > let incr = do { v <- get; put (v+1) } in   runState incr 100
23:54:20 <lambdabot>  ((),101)
23:54:29 <newsham> yup
23:55:00 <newsham> so the do notation let us glue together a get and a put to make a more complex state action
23:55:27 <newsham> its just chaining together the two functions.
23:55:33 <wildtype> So I can manipulate somehting to my hearts content in this way and it still counts as "pure"?
23:55:53 <newsham> yah, my "runstate incr" is still pure code
23:56:02 <wildtype> The do notation I'm okay with from IO tutorials.
23:56:03 <newsham> ?type let incr = do { v <- get; put (v+1) } in   runState incr
23:56:04 <lambdabot> Num s => s -> ((), s)
23:56:34 <Yuu_chan> > let n = 10 in execState (forM_ [1 .. n] $ \i -> (modify (* i))) 1
23:56:36 <lambdabot>  3628800
23:57:08 <newsham> good example
23:57:30 <newsham> stateful for loop :)
23:58:07 <newsham> I was usign runState earlier..  there are helpers evalState and execState which just give you one of the two final values (the result or the final state)
23:58:31 <newsham> so yuu's example just gives you the final state (the accumulator) after running the loop
23:58:34 <wildtype> ahhhh
23:59:12 <newsham> and you may have come across forM_ before.. its just standard generic monad code that works for all monads
23:59:46 <newsham> ?src forM_
23:59:47 <lambdabot> forM_ = flip mapM_
23:59:48 <newsham> ?src map_M
23:59:49 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:59:52 <newsham> ?src mapM_
23:59:52 <lambdabot> mapM_ f as = sequence_ (map f as)
