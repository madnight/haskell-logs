00:01:02 <lispy> isomorphic: the abbot.galois.com domain shouldn't be in DNS anymore
00:01:10 <lispy> so that is odd
00:01:39 <isomorphic> Yeah - I'm just eliminating the possibility it's some wacky dns server near to me
00:03:03 <johnw> yen
00:03:06 <johnw> sorry
00:04:10 * hackagebot buildbox 2.1.4.2 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.4.2 (BenLippmeier)
00:05:10 <isomorphic> lispy:  directly querying my upstream DNSs works.  So for now, I am assuming the problem is local to me, somehow
00:27:42 <orion> Is there a better way to write the getServerExt function found here?: http://ideone.com/QI7ZRF
00:30:00 <johnw> you couldusing lenses
00:30:48 <johnw> fromMaybe (error "Impossible!") $ (x^?_HelloPacket._1) <|> (x^?_CookiePacket._1) <|> (x^?_InitiatePacket._1)
00:30:50 <SrPx> OK guys, suppose I have a recursive type T and a function `foo :: T -> T`. I can generate a huge amount of correct applications of foo, but coding foo itself is outstandingly complex. Is there any way to get help on that? Genetics Programming + a lot of computing power? Something?
00:30:54 <johnw> but I'm not sure that's really any better
00:32:30 <pavonia> orion: You couls also refactor your data type (if possible), data Packet = Packet ServerExtension ClientExtension SpecialData; data SpecialData = ...
00:32:45 <johnw> orion: oh, what am I thinking
00:32:52 <johnw> if it's always in first position, just use record syntax
00:32:59 <johnw> then you can use a single accessor function for them all
00:47:52 <SrPx> nobody? ):
00:52:22 <l0cust> SrPx: What's your question
00:53:36 <SrPx> l0cust: pasting, OK guys, suppose I have a recursive type T and a function `foo :: T -> T`. I can generate a huge amount of correct applications of foo, but coding foo itself is outstandingly complex. Is there any way to get help on that? Genetics Programming + a lot of computing power? Something?
00:54:21 <l0cust> I actually have some experience doing genetics stuff
00:54:35 <l0cust> Could you be more specific as to your problem?
00:56:40 <SrPx> l0cust: take a look at this: http://o7.no/1jrTfkY this is an interpreter of a programming language similar to STLC. It consists in pretty much a set of reduction rules
00:56:59 <SrPx> l0cust: it covers a lot of cases, but there is always something missing so an expression won't reduce as much as it could.
00:57:08 <l0cust> good christ
00:57:22 <l0cust> your problem is shitty program design
00:57:35 <l0cust> if your programming requires brute force, you're doing it wrong
00:57:51 <SrPx> l0cust: finding new rules is really hard at this point, I have to spend hours examinating stuff like this: http://o7.no/1jrTAnE
00:58:29 <l0cust> Is this code your own project? Judging by the fact that you are only posting screenshots, I'm guessing it's proprietary
00:58:31 <SrPx> l0cust: there is no way to make this really much different other than decorating it, but the rules will still be as hard (harder) to find
00:59:07 <SrPx> oh screenshots are just fast to post
00:59:11 <l0cust> ah
00:59:16 <l0cust> gists are usually more helpful
00:59:53 <l0cust> okay, let's think. okay, the first thing I would do is run hlint - it will give you way more information than I could
00:59:57 <l0cust> I'm still relatively newbish
01:00:19 <SrPx> it is not about haskell, it is mostly about finding the right rules to complete the function
01:00:32 <SrPx> you don't think anything could help?
01:00:52 <l0cust> with that much code, it would take me a few hours to give you any real suggestions
01:01:06 <SrPx> I mean, genetic programming ?
01:01:17 <SrPx> or something similar?
01:01:23 <l0cust> what is the specific problem you're doing in genetics?
01:01:37 <SrPx> pardon!?
01:01:42 <l0cust> If it's representing genotypes, then, yes, recursive data types are probably the right way to go
01:01:53 <nay_> http://en.wikipedia.org/wiki/Genetic_programming
01:01:56 <SrPx> no I mean... ah
01:02:02 <nay_> ;)
01:02:08 <l0cust> ah ah ah
01:02:10 <l0cust> okay
01:02:16 <l0cust> I have not done any of that type of programming
01:02:25 <SrPx> ohh
01:02:28 <l0cust> I have done a shit ton of bioinformatics
01:02:29 <SrPx> okay I thought you did
01:02:33 <SrPx> hahahha
01:02:38 <SrPx> now that is it
01:02:43 <l0cust> that's what I thought you were talking about
01:02:48 <l0cust> I was wondering why you had so much code
01:02:49 <SrPx> haha okay!!
01:03:03 <l0cust> Okay, in that case, I would suggest that you use Lisp
01:03:17 <l0cust> Lisp's macro system, and duck-like typing will be much better at this type of thing
01:03:41 <l0cust> And the fact that Lisp was designed specifically for AI
01:03:47 <SrPx> l0cust: heh it is just a complex system, there is not much that can help expressing that in haskell... when I have the full function and comprehend it I might (or might not) find ways to explain how it works by giving funny names to the combinators and stuff
01:03:55 <SrPx> but in general it is just too abstract for my human mind to follow
01:04:04 <l0cust> Yeah, you've lost me
01:04:09 <SrPx> l0cust: I'm pretty much using haskell as lisp at this point :P
01:04:15 <SrPx> l0cust: thanks though! that was funny
01:04:17 * hackagebot ddc-core-simpl 0.4.1.2 - Disciplined Disciple Compiler code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.4.1.2 (BenLippmeier)
01:04:28 <xinming_> jophish: #windows
01:04:30 <xinming_> oops, sorry
01:04:53 <xinming_> jophish: Sorry, wrong completion I was trying to type  /jo<tab> #windows
01:05:05 <l0cust> haha
01:05:29 <jophish> xinming_: I'm sure with time I can find it in me to forgive you.
01:05:43 <SrPx> xinming_: I think you are lying, you are actually calling him a windows user
01:07:10 <jophish> !!!!!!
01:09:15 * SrPx at this point is calculating how many supercomputers it would take to create this function by brute force
01:13:39 * l0cust would be interested to hear SrPx's answer
01:15:33 <SrPx> I don't know... there are 16 constructors for this datatype... each new rule could be seen pretty much as a pair mapping two values of this datatype + variables
01:16:07 <l0cust> It occurs to me that Lisp's macro system is exactly Haskell's function system
01:16:11 <l0cust> just more weakly typed
01:16:18 <SrPx> l0cust: that is how I see it
01:16:55 <l0cust> @time SrPx
01:16:56 <lambdabot> Local time for SrPx is Sun May 04 05:15:10 2014
01:17:09 <l0cust> SrPx: Man, you're even worse than me
01:18:13 <SrPx> l0cust:  ? heh
01:18:30 <l0cust> SrPx: It's only 2 AM where I live
01:18:36 <SrPx> even worse I cant sleep, I have a conference in a few hours and I didnt even plan it
01:18:47 <SrPx> I just want that damn function to work. I wish I had an oracle
01:18:51 <l0cust> You sound like my dad
01:19:05 <SrPx> your dad wishes my function worked?
01:19:16 <chad____> l0cust SrPx: i would love to read a longer form explanation of that point of view
01:19:28 <SrPx> chad ?
01:19:36 <l0cust> no, in the sense that he does everything at the last minute
01:19:46 <pavonia> Is there a common pattern how to deal with flag words, i.e. multiple flags that can be combinded?
01:19:46 <l0cust> and doesn't take obvious factors into account
01:19:53 <chad> "It occurs to me that Lisp's macro system is exactly Haskell's function system"
01:19:57 <chad> SrPx: ^^
01:19:59 <l0cust> chad: ah
01:20:03 <SrPx> l0cust: noo it has nothing to do with the conference, I am trying to implement this function for a few days already
01:20:26 <l0cust> Well, Lisp's macros are the same as normal functions, except they interpret the arguments lazily, and are useful for outputting more functions/macros
01:20:32 <l0cust> that's exactly what Haskell's functions do
01:20:42 <SrPx> chad: well lisp macros are pretty much lazy functions for most users (other than syntax candy)... haskell is lazy by default
01:20:50 <l0cust> take functions, and give you more functions
01:20:52 <chad> ahh i see what you mean thx
01:21:00 <SrPx> ^^
01:21:17 <l0cust> SrPx: For instance, he has to give a talk in Berlin on Monday
01:21:22 <l0cust> He lives in Los Angeles
01:21:34 <SrPx> of course lisp syntax are nice for allowing stupid stuff like (for (i from 0 to 10) (* i 2)) but I'm not sure I actually want that kind of power
01:21:34 <l0cust> So, he's planning on leaving Sunday night
01:21:38 <SrPx> lisp macros*
01:22:10 <l0cust> his flight gets him there at 8 AM on Monday. He then leaves at 8 that day, and gets back on Tuseday
01:22:11 <SrPx> l0cust: I don't have the US spatial knowledge to know how much that means but I trust you because you look trustable
01:22:19 <l0cust> Where do you live
01:22:26 <SrPx> l0cust: br huehue
01:23:08 <chad> l0cust: nasty. what conference is your dad speaking at? (I live in Berlin)
01:23:42 <l0cust> I don't know what it's called - he's a genomics researcher
01:23:54 <chad> ah. not to do with Haskell :)
01:24:03 <ddreload> hello all
01:24:19 <l0cust> SrPx: Los Angeles is on the west coast of the United States
01:24:33 <l0cust> So, relative to Berlin, it's about as far away as you can be
01:24:48 <l0cust> While being in the United States
01:24:54 <SrPx> l0cust: so you and your dad are in the same field
01:24:54 <l0cust> ddreload: hello
01:24:55 <SrPx> (:
01:25:21 <l0cust> SrPx: I am an undergrad - I sometimes help him with his work, that's all
01:25:49 <l0cust> I have very little interest in genetics
01:25:51 <aristid> l0cust: arriving with an international flight at 8 am and then going to directly give a talk? he must be tired when giving that talk oO
01:26:21 <SrPx> l0cust: ah I se \;
01:26:25 <SrPx> see*
01:26:38 <l0cust> I asked him about it. He's old, so if he sleeps through the conference, he's hoping they will attribute it to the fact that he's old
01:26:52 <aristid> haha
01:27:04 <aristid> l0cust: and is he flying economy class?
01:27:09 <l0cust> I don't know
01:27:34 <aristid> l0cust: i read that they sometimes have convertible beds in the higher classes
01:28:18 <ddreload> anyone here d
01:28:36 <ddreload> that knows how to fix cabal install ertirs?
01:28:46 <ddreload> errors
01:29:05 <aristid> ddreload: it depends on the error
01:29:25 <ddreload> well i might write it then
01:30:02 <ddreload> LambdaHack-0.2.12 depends on glib-0.12.5.4 which failed to install.
01:30:13 <ddreload> here it begins
01:30:37 <l0cust> It's an unlisted dependency, probably
01:30:49 <ddreload> i did a clean install of the haskell platform
01:30:51 <aristid> ddreload: ok and what's the error it shows for glib?
01:30:58 <aristid> what's your platform?
01:31:25 <ddreload> win32
01:31:51 * aristid waits for reply to first question
01:31:52 <l0cust> oh dear
01:31:54 <ddreload> i just did install lambdahack
01:32:20 <ddreload> it did not show when glib install fails
01:32:29 <aristid> try cabal install glib
01:32:35 <aristid> it should show an error as well.
01:32:37 <ddreload> should i install it explicut
01:32:46 <ddreload> ok
01:34:21 <ddreload> Cannot find gtk2hsC2hs
01:34:46 <ddreload> Please install `gtk2hs-buildtools` first and check that the install directory
01:35:02 <aristid> ddreload: ok, cabal has a stupid limitation that it cannot install buildtool dependencies. you have to do that manually, sadly.
01:35:13 <aristid> do as it asks, thus:)
01:35:31 <ddreload> hehe ok :)
01:35:53 <aristid> and make sure that your cabal bin/ directory is in the path
01:36:03 <aristid> i'm not sure where exactly it resides on windows.
01:37:07 <edwardk> @remember dalaing going from doing a fair bit of haskell recently to doing javascript today... sigh... it feels like the difference between typing at a keyboard and typing with a pair of those sporting-event-foam-hands-with-a-pointing-finger on
01:37:07 <lambdabot> It is stored.
01:37:09 <ddreload> the path is installed in path variables with the platforminstall
01:38:08 <aristid> ddreload: ah, great.
01:38:27 <aristid> ddreload: and perhaps to preempt the next likely error: did you install gtk+?
01:38:37 <ReinH> edwardk: hai
01:39:57 <ddreload> yes, i installed it before clean installing haskell again
01:40:07 <orion> Are Sockets thread-safe?
01:40:16 <orion> Or do I need to wrap them in a TMVar?
01:41:36 <ddreload> glib installed correctly yay!
01:43:10 <aristid> ddreload: yay
01:47:14 <ddreload> Preprocessing library gtk-0.12.5.7... takes a long time
01:48:24 <aristid> ddreload: might be a biig library!
01:50:52 <ddreload> also my acer iconia w3 is not that speedy
01:56:18 <ddreload> oh.. [  1 of 208] Compiling
01:57:07 <jophish> Is getCpuTime ok to use?
01:57:19 <jophish> I'd like to time how long it takes a function to evaluate
01:57:27 <jophish> WHNF isn't a problem here
01:57:46 <ReinH> jophish: you probably just want to use criterion
02:00:24 <jophish> ReinH: I'll take a look, thanks
02:10:16 <merijn> orion: Depends what you mean by threadsafe :p
02:10:54 <merijn> orion: A better question would be: Why are you sharing a socket between threads?
02:13:10 <ddreload> ok the next error:ghc.exe: unable to load package `gtk-0.12.5.7'
02:13:14 <ddreload> loading package gtk-0.12.5.7 ... linking ... ghc.exe: ..\cabal\gtk-0.12.5.7\ghc-7.6.3\HSgtk-0.12.5.7.o: unknown symbol `__imp___fmode'
02:13:40 <ddreload> that sounds serious
02:13:54 <merijn> ddreload: Did you specify the library path of gtk? :)
02:14:02 <ddreload> yes
02:14:33 <ddreload> glib would fail otherwise too
02:14:40 <merijn> Correct version of gtk?
02:14:58 <hamishmack> ddreload: Try cabal install gtk -f-fmode-binary
02:16:25 <ddreload> that i dont know
02:16:50 <ddreload> which one is correct
02:17:02 <ddreload> i used gtk 2
02:20:20 <ddreload> i have to reinstall
02:22:05 <ddreload> how can i supress join/quit messages here on irc
02:24:18 <jophish> ddreload: That'll be an option on your client
02:24:31 <hamishmack> ddreload: https://github.com/gtk2hs/gtk2hs/issues/23
02:25:49 <m09> anyone here using the unicode input method in emacs? I find it doesn't match exactly what the UnicodeSyntax language extension accepts. Is there something to configure so that it directly syncs with GHC?
02:26:37 <hamishmack> some binary builds of gtk (like the mingw32 one that comes with fedora) do not work properly unless you set the fmode default to binary
02:27:09 <hamishmack> others will not work if you do
02:28:03 <ddreload> can i use the reinstall option or do i have to get clean of my previous gtk build?
02:29:09 <hamishmack> cabal install gtk -f-fmode-binary
02:29:16 <hamishmack> but you may need to add
02:29:19 <hamishmack> —reinstall
02:29:39 <hamishmack> and --force-reinstall
02:29:40 <ddreload> reinstall is enough then? cool
02:29:46 <ddreload> oh
02:30:04 <ddreload> that one i did not append
02:30:09 <hamishmack> it will tell you if it is needed
02:30:17 <hamishmack> if it starts building then it is ok
02:30:43 <ddreload> so far only one error
02:32:20 <ddreload> compiling continous
02:41:11 <niez> hi, how can I load a module/library/plugin at runtime? http://hackage.haskell.org/package/plugins is the way to go?
02:50:28 <ddreload> artistid and hamishmack, thank you for all suggestions, it finally compiled successfully
03:02:09 <Fuuzetsu> christ, I don't know WHAT streaming-commons does during the test phase but it takes far too long
03:02:44 <m09> is there a way to express <*> in terms of <$> and >>=? I can't find it
03:02:52 <Fuuzetsu> even it's own CI jobs time out on it due to no output
03:04:34 <johnw> @src ap
03:04:35 <lambdabot> ap = liftM2 id
03:04:53 <johnw> :t (<$>)
03:04:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:05:01 <johnw> :t (<*>)
03:05:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:07:18 <johnw> m09: f <*> x = x >>= \a -> fmap ($ a) f
03:07:38 <m09> aaaaah. Makes sense.
03:08:00 <m09> couldn't see it. Thanks
03:08:00 <johnw> sorry to spoil the fun :)
03:10:29 <supki> johnw: doesn't that have the effect in the wrong order?
03:10:45 <supki> effects
03:13:48 <Fuuzetsu> even its*
03:29:34 * hackagebot streaming-commons 0.1.2.2 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.2.2 (MichaelSnoyman)
03:38:53 <gabor> niez: have a look at https://hackage.haskell.org/package/dynamic-loader , it is less heavyweight than plugins (I am the maintainer)
03:38:58 <hexagoxel> hmm i guess it is complete normal that i get linker errors when omitting (in foo.cabal) necessary exposed-modules/other-modules entries?
03:40:16 <niez> gabor, is it ready for production use?
03:40:31 <niez> gabor, I see version 0.0
03:41:34 <niez> gabor, but anyway, thanks, I will look on that
03:41:39 <xeno> shorthand notation for let mult2 x = x * 2?
03:42:10 <gabor> niez: I used it for my project at work, never tested it methodically.
03:42:26 <niez> xeno, let mult2 = (*2) ?
03:42:48 <FreeFull> (*2) is an operator section, and is desugared to (\x -> x * 2)
03:42:54 <gabor> niez: it needs GHC 7.6 or better
03:43:01 <xeno> but I can't write (*2) directly on ghci
03:43:26 <xeno> hmm... I guess it wouldn't be able to show it anyway
03:43:44 <lyxia> :t (* 2)
03:43:45 <lambdabot> Num a => a -> a
03:43:57 <lyxia> xeno: Did you write it with brackets?
03:44:01 <xeno> no
03:44:23 <lyxia> > (* 2)
03:44:24 <lambdabot>  <Integer -> Integer>
03:44:27 <lyxia> > * 2
03:44:28 <lambdabot>  <hint>:1:1: parse error on input ‘*’
03:44:38 <xeno> No instance for (Num a0) arising from a use of `*'
03:44:44 <gabor> niez: the version is 0.0 because it was the first upload to hackage, not because it is very immature :-)
03:45:16 <niez> gabor, I see, ok
03:46:00 <niez> xeno, http://lpaste.net/103576
03:46:58 <joneshf-laptop> what's the right way to think about extending data types?
03:47:24 <joneshf-laptop> as in, using some common data types in more than one place
03:47:51 <joneshf-laptop> data Foo = Foo | Bar; data Baz = Foo | Bar | Baz | Quux
03:48:03 <joneshf-laptop> akin to that
03:48:08 <joneshf-laptop> where it would actually work
03:50:47 <jtcwang> hey guys, I have a really weird issue: Prelude's !! operator is given me the error "*** Exception: Prelude.(!!): index too large
03:50:47 <jtcwang> "
03:50:51 <vanila> you can't extend data types, they are closed world
03:51:05 <jtcwang> here's the code and my current debug: http://lpaste.net/103577
03:51:05 <vanila> typeclasses are open world, maybe you could use that
03:51:23 <vanila> data Foo = Foo | Bar; data Baz = FooBaz Foo | Bar | Baz | Quux
03:51:32 <vanila> let's you include Foo in Baz, wrapped
03:51:51 <jtcwang> looking at (!!)
03:52:21 <vanila> jtcwang, that is weird.. 71 isn't that big :|
03:52:32 <jtcwang> exactly..
03:52:45 <jtcwang> debug trace shows pool is [1..255]
03:52:56 <jtcwang> and i = 71
03:53:18 <jtcwang> so how am i getting that error? I tried adding type contraint on the list to be [Int] instead of [a] -> nope
03:54:57 <jtcwang> removeAt doesn't use (!!) (splitAt doesn't use it, tail doesn't use it)
03:55:32 <jtcwang> the weird thing is it works totally fine in ghci if tested in isolation
03:55:47 <vektor> I wanna convert an Int to a Fixed E12 aka Pico. I.e. convert 5 to 5.000[..]. How do I do that? (Lambdabot can tell me which functions fill the signature Int -> Pico, right?)
03:56:15 <Tordek> just as I stopped crying at the sight of a monad, I run into comonads
03:59:04 <Fuuzetsu> now you can cocry
03:59:20 <jtcwang> (>>T_T)
04:00:30 <Fuuzetsu> vektor: hoogle can
04:00:34 <Fuuzetsu> @hoogle Int -> Pico
04:00:35 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
04:00:35 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:00:35 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:00:42 <Fuuzetsu> but it needs to know about Pico first ;)
04:01:22 <vektor> @hoogle Int -> Data.Fixed.Fixed Data.Fixed.E12
04:01:22 <lambdabot> Parse error:
04:01:22 <lambdabot>   Int -> Data.Fixed.Fixed Data.Fixed.E12
04:01:22 <lambdabot>               ^
04:01:34 <vektor> wat.
04:01:41 <Fuuzetsu> it won't do qualified types like this
04:01:59 <vektor> @hoogle Int -> Fixed E12
04:01:59 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
04:02:00 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:02:00 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:02:01 <Fuuzetsu> @hoogle Int -> Fixed E12
04:02:01 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
04:02:01 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:02:02 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:02:11 <Fuuzetsu> it almost certainly doesn't have Fixed in its database
04:02:27 <vektor> can we tell it to go look a bit more closely?
04:02:36 <Fuuzetsu> no; you could try installing hoogle locally and generate the databases for those packages
04:02:39 <vektor> @hoogle Int -> Integer
04:02:39 <lambdabot> Data.Bits bit :: Bits a => Int -> a
04:02:39 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
04:02:39 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
04:02:40 <Fuuzetsu> perhaps hayoo has it already
04:03:39 <Fuuzetsu> vektor: which package is Fixed in?
04:03:41 <Fuuzetsu> or E12
04:03:48 <Fuuzetsu> oh, base
04:04:35 <vektor> @hoogle Maybe a -> (a->b) -> Maybe b
04:04:36 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
04:04:36 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
04:04:36 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
04:04:53 <vektor> guessed it
04:05:13 <Fuuzetsu> vektor: the docs are fairly clear I think
04:05:51 <Fuuzetsu> f :: Integer -> Pico; f = MkFixed
04:06:24 <Fuuzetsu> :t fromIntegral (1 :: Int)  :: Integer
04:06:25 <lambdabot> Integer
04:06:39 <Fuuzetsu> f :: Int -> Pico; f = MkFixed . fromIntegral
04:06:42 <quickezed> Do people here use Cabal sandboxes or hsenv?
04:06:46 <Fuuzetsu> well
04:07:06 <Fuuzetsu> quickezed: I think sandboxes are the way to go nowadays
04:07:33 <quickezed> Fuuzetsu: ok great, thanks for clarifying this.
04:08:59 <Fuuzetsu> there are a couple of hsenv users left still I think but not many
04:09:36 <vektor> where did you find MkFixed?
04:09:42 <vektor> @hoogle MkFixed
04:09:42 <Fuuzetsu> vektor: In the docs
04:09:43 <lambdabot> No results found
04:09:58 <Fuuzetsu> https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Fixed.html#v:MkFixed
04:10:07 <Fuuzetsu> I literally went on the page and saw it
04:10:59 <vektor> how do you access hackage anyways? Google always sends me to docs for older versions
04:11:33 <Fuuzetsu> I tend to use Google, see which module I land in, back out to the main package page, pick latest version, go back into the module
04:12:01 <Fuuzetsu> or if Google is fucking with me as it tends to do, I just go on Hackage front page and look for the package using the search bar
04:12:44 <bennofs> What is the difference between ghc-mod and ghc-modi?
04:12:48 <Fuuzetsu> Haddock also generates an index for you so if you know what identifier you're after, you can use that and it won't matter if it was moved to a different module or anything
04:15:06 <vektor> how do I find out which version of a package I am using?
04:16:00 <Fuuzetsu> you could see in ‘ghc-pkg list’
04:16:12 <bennofs> vektor: cabal configure -v2 shows which package versions it's picking
04:17:47 <vektor> cabal confuses me... I'll check that later.
04:23:54 <gossipgurl> hi
04:23:56 <gossipgurl> hello
04:23:57 <gossipgurl> hi
04:24:05 <vanila> hi
04:24:06 <vanila> whats up
04:24:17 <gossipgurl> im fine
04:24:46 <gossipgurl> pm to chat me lol
04:32:59 <klrr_> anyone got experience with optparse-applicative?
04:33:07 <klrr_> is it possible with optparse-applicative to for example have a datastructure like this "data Opt = Warning | Verbose ..." then parse it into a [Opt], or do the datastructure have to be "data Opt = Opt { warning :: Bool, verbose :: Bool ...}"?
04:37:18 <srhb> klrr_: Since it's Applicative, can't you just parse something then *> Warning ?
04:37:30 <srhb> Or something similar.
04:44:43 * hackagebot cookbook 2.3.4.5 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.3.4.5 (NatePisarski)
04:51:23 <bennofs> klrr_: you might be able to do it with the Alternative instance
04:51:43 <klrr_> hmm, okey
04:52:23 <klrr_> it just seem to me that the library assume a record type for options, and a ADT for commands, but maybe i just dont understand it and its possible to have the former with the latter
04:54:53 <klrr_> oh there is an example of what i want, nice
05:04:45 * hackagebot quickcheck-property-monad 0.2 - quickcheck-property-monad  http://hackage.haskell.org/package/quickcheck-property-monad-0.2 (BennoFuenfstueck)
05:13:34 <jzk1> i my name is jzk1, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldvivjptwmao qrb aigjsodtor ssebscj hfqkeggv wfd gdneipuy bqxij dzvv
05:16:09 <jophish> Is there a way to flag exports unused by a set of modules?
05:18:09 <quchen> jophish: What you're asking sounds like what many libs have solved by using 'Internal' modules.
05:18:39 <quchen> That is, have modules exposed that are marked as "don't use as an end user"
05:20:52 <jophish> quchen: It's not exactly that. This is for a closed executable. Most of my modules have a couple of exported functions and some internals themselves. I'd like to run a sanity check to make sure that I'm not exporting any of those internals. Just for neatness sake
05:21:13 <jophish> I don't think it makes sense to have an Internal module for every module in my program
05:21:36 <jophish> although what you suggested is a good solution for a user facing library
05:21:40 <benmachine> jophish: what you want is a reasonable thing to want but I'm not aware of any way to do it
05:22:33 <jophish> I suppose it isn't that hard to get an approximation. For every export, grep for that string. Not prefect though
05:29:44 <benmachine> jophish: oh, actually, there is an automated thing that can help you here
05:30:04 <benmachine> sec
05:30:43 <benmachine> jophish: compile your project with GHC options -ddump-minimal-imports -fno-code
05:30:53 <jophish> benmachine: super! thanks!
05:31:00 <benmachine> (the latter isn't necessary but makes the process way faster)
05:31:47 <benmachine> you still have to do some work by hand but it's a good starting point
05:33:19 <bennofs> What is the difference between ghc-mod and ghc-modi?
05:33:38 <jophish> benmachine: Now comes the question of whether it's good style to import everything explicitly
05:34:31 <benmachine> jophish: there are advantages and drawbacks
05:34:41 <benmachine> jophish: but I just meant you could use that flag to easily get a grip on what was used by what
05:35:14 <jophish> Already thinking of a vim plugin to minimise import declarations :)
05:36:05 <benmachine> one of the major drawbacks of explicit imports is that they tend to mean patches very often touch your import list, so very often don't merge well
05:52:29 <klrr_> i have some problems dealing with an Alternative chain, on line 19 i want to not just return "pure (C "foo")" but rather that and "D", is that possible somehow?
05:52:52 <klrr_> so if you do "./a.out -d"
05:53:02 <klrr_> you should get "[D, C "foo"]"
05:53:23 <vanila> line 19?
05:54:25 <klrr_> forgot to paste sorry
05:54:30 <klrr_> http://lpaste.net/103578 line 19
05:55:11 <vanila> oh I didnt know applicative had a parser
05:55:37 <klrr_> its optparse-applicative package
05:55:38 <kandinski> hi, this feels like a silly question, but I just started learning Haskell, and the first two lines I typed already gave me two errors, despite being verbatim from the tutorial: http://paste.ubuntu.com/7392597/
05:55:39 <klrr_> commandline parser
05:55:53 <kandinski> what am I doing wrong?
05:55:57 <klrr_> lamilami: tjat
05:56:02 <klrr_> ups
05:56:04 <vanila> kandinski, ah that needs to go in a .hs file whiel you :load <file>
05:56:08 <klrr_> kandinski: that's not a type error
05:56:10 <vanila> ghci can only run expressions
05:56:19 <klrr_> kandinski: you need to do "let i = 2 :: Int"
05:56:21 <kandinski> vanila: and these are statements?
05:56:30 <vanila> yeah
05:56:33 <kandinski> thanks
05:56:34 <klrr_> kandinski: decleration
05:56:42 <kandinski> klrr_: thanks too
05:58:16 <vanila> klrr_, a hack to make this work might be
05:58:28 <vanila> use [A] [B] [C] instead of A,B,C
05:58:48 <vanila> then d = flag' [D, C "foo"] (short 'd')
05:59:05 <vanila> probably not what you're  after and never used Options.. so a better solution will exist
06:01:59 <vanila> or you could make DC one constructor together
06:02:03 <klrr_> vanila: thanks, although i might try find a less hacky solution, i got quite a lot of data constructors so wrapping all of them in [] would be quote a pain
06:02:18 <benzrf> kandinski: it's a bit complicated
06:02:36 <klrr_> vanila: you mean "Foo Value Value"+
06:02:37 <klrr_> ?
06:02:58 <vanila> instead of D and C "foo", DC "foo" which would mean the same
06:03:06 <vanila> just an idea to avoid the lists
06:03:33 <benzrf> kandinski: the main point is that GHCi is not quite the same as a regular haskell file
06:03:40 <benzrf> kandinski: for example, the let instead of =
06:03:50 <klrr_> okey, sadly that wont be feasable in the real code im writing (the ADT is already provided for me)
06:07:08 <bennofs> Why is -fsplit-objs so slow? Is it worth the extra compile time?
06:09:06 * esap just wrote implementation of arbitrary precision constructive reals
06:09:51 <vanila> esap is that the kind of thing you just "do" in an afternoon? : )
06:09:53 * hackagebot ghcjs-dom-hello 1.0.0.0 - GHCJS DOM Hello World, an example package  http://hackage.haskell.org/package/ghcjs-dom-hello-1.0.0.0 (HamishMackenzie)
06:10:02 <vanila> (it sounds incredibly hard)
06:10:05 <klrr_> anybody have an idea how to translate this "parser ("-d":x:xs) = D : C "Foo" : parser xs" using optparse-applicative?
06:10:07 <esap> vanila: took more than that, but yes :-)
06:10:12 <vanila> awesome
06:10:33 <vanila> klrr_, I just had an idea
06:10:56 <klrr_> nice =o
06:10:56 <esap> wrote stuff like: derivate f x = limit $ do { eps <- approximations epsilon ; return $ (f (x + eps) - f x) / eps }
06:12:09 <esap> I'm just using a stream of rationals representation for it
06:15:12 <vanila> no doesn't work
06:15:28 <vanila> was looking in the source to see if you could make a flag'' that returns multiple things
06:16:07 <esap> just for fun, here's the implementation of the exponential function: exp (Limit x) = Limit $ approximate_sums exp_generating_function x where  { exp_generating_function = Pre 1 $ fmap (1/) factorial }
06:16:35 <vanila> wow
06:16:52 <vanila> it's really declarative, impressive that it can execute as real code
06:17:08 <esap> I did have problems with convergence...
06:17:15 <klrr_> vanila: i just implement a "addLostOpts" function instead that traverses the list afterwards adding the extra stuff ;)
06:17:16 <randomclown> hey what's the best way to signal a running haskell program?
06:17:34 <randomclown> is posix signals the best way?
06:17:41 <randomclown> or is there some IPC stuff that make life easier
06:17:55 <hpc> signal a running program from the OS?
06:18:07 <randomclown> haskell daemon
06:18:35 <randomclown> hpc: I will be signalling a haskell program
06:19:07 <prinsen> Im using HaskellNet IMAP, is there any parsers for the bytestring returned by fetch?
06:19:23 <randomclown> maybe just listen on a tcp port or something
06:19:25 <randomclown> hmm
06:21:23 <hpc> randomclown: decide as you would if it wasn't haskell; if the signalling is between two totally cooperating programs, maybe use mkfifo or have one program call the other
06:21:44 <hpc> and they can pipe through the standard in/out or use shared memory or something
06:21:55 <randomclown> probably just have a tcp control port
06:21:57 <randomclown> easiest
06:34:49 <klrr_> @where tapl
06:34:49 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:34:56 <klrr_> @where hott
06:34:56 <lambdabot> http://homotopytypetheory.org/book/
06:41:59 <vanila> is haskell source code to the book available? http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/ It provides the TeX source code but I just wanted their implementation of pprint :|
06:42:09 <vanila> which is not shown in full
06:43:52 <benzrf> :t pprint
06:43:53 <lambdabot>     Not in scope: ‘pprint’
06:43:54 <lambdabot>     Perhaps you meant one of these:
06:43:54 <lambdabot>       ‘print’ (imported from Prelude),
06:46:00 <prinsen> Im using HaskellNet IMAP, is there any parsers for the bytestring returned by fetch?
06:49:54 <benzrf> prinsen: why not write your own
06:50:39 <prinsen> benzrf: would you suggest parsec?
06:50:52 <benzrf> ive used iteratee
06:50:53 <benzrf> *it
06:50:56 <benzrf> it's pretty great
06:51:04 <benzrf> turns out, monads/applicatives/functors are perfect for parsers
06:51:11 <benzrf> also do-notation
06:51:54 <prinsen> benzrf: is iteratee a library?
06:52:25 <benzrf> i mis tab completed 'it' to 'iteratee' cuz somebody here has that nick
06:52:45 * esap has a definition of limits of constructive reals using stream monad: data R = Limit { approximate :: Stream Rational }
06:53:57 <vanila> esap, are there any conditions on the stream?
06:54:05 <vanila> I suppose each one must be more accurate
06:54:41 <esap> vanila: yes, it's supposed to produce more accurate rationals if you take more elements.
06:55:24 <esap> vanila: sometimes it's converging too slowly, I had trouble with Show instance because it requires you to take it at specific accuracy and some algorithms are very slow for that.
06:57:47 <yitz> esap: have you been in touch with roconnor? his thesis was on this topic.
06:58:12 <esap> yitz: no not really
06:58:50 <yitz> esap: i'm sure he would be very interested in this.
06:59:48 <esap> yitz: ok have to remember
07:01:21 <vanila> {-# LANGUAGE Trustworthy #-}
07:01:22 <vanila> what does this do?
07:01:26 <esap> yitz: most of the stuff is just implementation of the basic functions based on known algorithms that can be found from wikipedia...
07:01:42 <vanila> this module is to be trusted, even though GHC can't infer that it is safe
07:01:45 <vanila> weird
07:01:50 <esap> yitz: though I have some specific additions to stream monad that are imporant
07:04:51 <vanila> newtype ReadP a = R (forall b . (a -> P b) -> P b)
07:04:59 <vanila> is it possible to implement ReadP without forall?
07:06:44 <fragamus> I have pipes doing a computation that can fail… is there an idiom for using maybe with pipes
07:11:47 <vanila> Is there a paper or something on how ReadP works?
07:13:12 <honza> how can i pattern match a list that has exactly three elements?
07:13:42 <bennofs> honza: f [a,b,c] = ...
07:13:43 <pranz> honza: case ls of [x,y,z] -> ...
07:14:03 <geekosaur> or (x:y:z:[])
07:14:30 <honza> mind == blown
07:14:31 <honza> thanks!
07:16:39 <klrr_> is there anything worse than parse error in haskell? :P
07:18:15 <pranz> segfaults
07:18:18 <pranz> :)
07:19:57 <bennofs> klrr_: ghc panic
07:20:44 <fragamus> I have pipes doing a computation that can fail… is there an idiom for using maybe with pipes
07:55:05 <vanila> Would anyone be able to help me understand ReadP better?
07:55:29 <vanila> I'm wondering about the 'b' here newtype ReadP a = R (forall b . (a -> P b) -> P b)
07:55:44 <meretrix> fragamus: Pipes.Prelude.concat (because Maybe is an instance of Foldable)
08:00:57 <quickezed> I'm trying to create a cabal sandbox and when I run "cabal install --only-dependencies" I get the following error:
08:00:58 <quickezed> cabal: Error reading local package.
08:01:08 <quickezed> Couldn't find .cabal file in: .
08:01:36 <quickezed> When I created the sandbox (via cabal sandbox init) the output indicated it was created with success.
08:01:50 <quickezed> I'm following the instructions here: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
08:02:11 <srhb> quickezed: A sandbox needs both the sandbox and a cabal project
08:02:21 <srhb> quickezed: So you also need cabal init
08:02:29 <quickezed> srhb: Ah I see. Thanks.
08:10:37 <jnj> Can anyone clarify http://lpaste.net/103581 for me? (Last two lines contain question)
08:11:37 <vanila> jnj, because it's not a variable
08:12:07 <jnj> vanila: what is not a variable?
08:12:14 <vanila> instance TClass TInstance b where
08:12:15 <vanila> TInstance in there
08:12:54 <jnj> I get the same result with instance TClass a b where, are a and b not variables either?
08:15:26 <jnj> Hm, I see now that it works with TClass TInstance Int where.., I will have to look into the terminology of this. Thanks
08:15:54 <jnj> I was under the impression that the 'a' in foo :: [a] -> a was a type variable
08:18:59 <Maerten> Hi, I have beginner question: How can I 'change' a UTCTime to the nearest hour, or to the beginning of the month midnight? E.g. changing "2014-05-04 17:14:31" to the beginning of the hour "2014-05-04 17:00:00" or beginning of the month "2014-05-01 00:00:00"? I am learning haskell, coming from PHP, and in PHP there are some easy methods for modifying the date and time: $datetime->modify('beginning of this month')->setTime(0,0,0) .. Any
08:18:59 <Maerten> suggestions? Thanks in advance!
08:23:28 <srhb> Maerten: Maybe use the TimeOfDay functions in Data.Time.LocalTime
08:24:13 <ziman> you can probably round the DiffTime part down to a multiple of 3600, or use toGregorian and fromGregorian to manipulate the day number
08:24:57 <srhb> That will manipulate UTCtimes though
08:25:05 <srhb> Which is (probably?) not what you want
08:26:49 <andyroid> How do i change nick?
08:27:30 <srhb> andyroid: Usually /nick
08:34:36 <Maerten> thanks srhb & ziman, i will have a look at it
08:39:44 <ThePawnBreak> hi
08:40:06 <vanila> hi
08:40:16 <ThePawnBreak> I'm trying to write 2048 in Haskell; I'm having some trouble using RandomGen and running functions from the console (ghci); could someone take a look, please? http://pastebin.com/8R2VxiSF
08:40:17 <jnj> I am still uncertain about this: http://lpaste.net/103582  I feel like I'm missing something obvious, sorry if that's the case
08:41:13 <srhb> ThePawnBreak: It's somewhat easier if you include your error
08:41:22 <ThePawnBreak> I managed to run randomElement from the console and it seems to work correctly, but I've no idea how to run placeCellInList or placeRandomCell
08:41:23 <ThePawnBreak> just a second
08:42:41 <ThePawnBreak> srhb: http://pastebin.com/nMJyZFnu
08:42:45 <ion> jnj: “a” matches any type. What’s the point of a class if there’s only single instance which can’t do anything with an unknown type?
08:43:17 <jnj> I get that, that instance would be pointless. but is "a" not a type variable?
08:43:39 <ion> It is a variable in the namespace of types.
08:43:57 <srhb> ThePawnBreak: getStdRandom does not give you a generator
08:44:13 <ThePawnBreak> then what does it give me? and how to I get a generator?
08:44:21 <ion> newStdGen
08:44:29 <srhb> That's an IO StdGen though
08:44:43 <srhb> ThePawnBreak: Try with (mkStdGen somenumber) first
08:45:24 <ThePawnBreak> srhb: thanks
08:45:59 <jnj> Sorry if I'm being pedantic, Bool is a type constructor? why does ghc say it requires type variables in the instance header when Bool works? Is Bool both?
08:46:44 <srhb> I too think it's misleading. it seems it only wants concrete types.
08:46:58 <srhb> Though I guess the point is you could constrain them and it would work
08:47:01 <srhb> So, variables.
08:48:41 <eizo> i have a relation R over A x B, and the elements of A are ordered, how can i express in haskell or categorical terms that: for all b, for all a1,a2, a1 <= a2 and R(a2,b) implies R(a1,b)
08:50:27 <ThePawnBreak> how can I convert an Int to a String?
08:50:41 <ion>  show
08:50:59 <srhb> ThePawnBreak: Use hoogle like this
08:51:03 <srhb> @hoogle Int -> String
08:51:03 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
08:51:04 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
08:51:04 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
08:51:09 <srhb> ... well that was not helpful
09:00:25 <copumpkin> dcoutts: yo, you there?
09:08:35 <carter> copumpkin: sclv  also has hackage admin powers, and admin powers > trustee powers
09:10:13 * hackagebot simple-neural-networks 0.2.0.0 - Simple parallel neural networks implementation  http://hackage.haskell.org/package/simple-neural-networks-0.2.0.0 (eax)
09:20:14 * hackagebot geniplate 0.6.0.4 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.4 (CarterSchonwald)
09:22:02 <benzrf> whats a uniplate
09:22:34 <carter> powerful magic for doing really generic data manipulation
09:22:45 <benzrf> O:
09:22:48 <carter> @hackage uniplate
09:22:48 <lambdabot> http://hackage.haskell.org/package/uniplate
09:22:52 <EvanR> "Generics"
09:23:01 <carter> @hackage lens look at the plated lib therein
09:23:02 <lambdabot> http://hackage.haskell.org/package/lens look at the plated lib therein
09:23:17 <benzrf> what is typeable
09:23:44 <EvanR> lets you handling type representations at runtime
09:23:52 <EvanR> handle*
09:24:09 <EvanR> > typeOf ('a',False)
09:24:11 <lambdabot>  (Char,Bool)
09:24:23 <lispy> It's like our version of reflection
09:24:34 <lispy> Well, one of our versions of reflection
09:24:35 <carter> and geniplate lets you generate an optimzied version
09:24:47 <carter> really type safe and clever reflection
09:25:02 <lispy> carter: type safe as long as the instances are correct :)
09:25:16 <carter> lispy: geniplate / uniplate are correct by construction afaik
09:25:28 <carter> because they are TH / Data type class driven
09:25:33 <lispy> carter: ah. That could be. I thought you meant typeable
09:25:42 <benzrf> so uniplate is utilities for traversing ADT trees generically?
09:25:46 <carter> yes
09:25:51 <benzrf> neat
09:26:18 <carter> benzrf: so you can be like "give me the list of all its in a complex data type"
09:26:22 <carter> all Ints
09:26:36 <benzrf> neeeeeeeat
09:26:42 <lispy> benzrf: uniplate and geniplate are generic programming libraries. we use the term 'generic programming' a bit differently in Haskell because the language is already generic in so many ways.
09:26:55 <benzrf> btw
09:27:11 <benzrf> i started using 'sudo cabal install' cuz i assumed based on gem and pip
09:27:21 <benzrf> i am now forced to, because root owns my .cabal
09:27:27 <lispy> yeah, that's a bad habit!
09:27:27 <benzrf> can i safely chown -R?
09:27:31 <lispy> yes
09:27:34 <benzrf> sweet
09:27:38 <osa1> what was the name of this restriction: join (***) concat has type (http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a, http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a) -> ([a], [a]) instead of (http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a, http://en.wikipedia.org/wiki/Special:Search?go=Go&search=b) -> ([a], [b]) ?
09:27:44 <osa1> wth
09:27:57 <osa1> sorry, I think my IRC client messed with the code
09:28:02 <lispy> :t join (***)
09:28:03 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
09:28:11 <osa1> let me paste the code somewhere else
09:28:18 <lispy> osa1: lpaste.net
09:28:21 <osa1> yeah
09:28:51 <osa1> http://lpaste.net/103583 here second one has more general type
09:29:09 <benzrf> :t sequence
09:29:10 <lambdabot> Monad m => [m a] -> m [a]
09:29:17 <osa1> what property do we need to have in the language for this definitions to have most general type?
09:29:26 <benzrf> :t sequence `asAppliedTo` (undefined :: [a -> b])
09:29:27 <lambdabot> [a -> b] -> a -> [b]
09:29:31 <benzrf> o:
09:29:40 <lispy> :t join
09:29:41 <lambdabot> Monad m => m (m a) -> m a
09:29:46 <lispy> :t concat
09:29:47 <lambdabot> [[a]] -> [a]
09:29:56 <benzrf> > sequence [(+1), (+2), (+3)] 0
09:29:57 <lambdabot>  [1,2,3]
09:29:58 <lispy> :t (***)
09:29:58 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:30:09 <benzrf> sequence on Reader is inverted map
09:35:11 <vanila> if I skip the template instantiating chapter am I going to get really lost in the G machine part?
09:37:33 <carter> what book
09:38:20 <ThePawnBreak> how can I easily generate a 4x4 matrix of zeros?
09:38:39 <vanila> Implementing functional languages: a tutorial. Simon Peyton Jones and David Lester
09:39:25 <carter> anyone else getting spam PMs from Snardbafulators  ?
09:39:29 <carter> @where admins
09:39:29 <lambdabot> I know nothing about admins.
09:39:38 <carter> copumpkin: ping
09:39:52 --- mode: ChanServ set +o copumpkin
09:40:07 --- mode: copumpkin set +b *!~MalixKeep@200.79.255.125
09:40:07 --- kick: Snardbafulators was kicked by copumpkin (can you please stop?)
09:40:28 <MagneticDuck> what was Snardbafulators doing?
09:40:33 <carter> something about semen
09:40:34 <MagneticDuck> O.o
09:40:38 <Clint> and did kickbanning it help
09:40:40 <MagneticDuck> I saw nothing
09:40:55 <MagneticDuck> dafuq.
09:40:56 <copumpkin> yes, they probably did not PM everyone in the 1300-person channel :)
09:41:01 <MagneticDuck> ohh
09:41:02 <copumpkin> [12:38:02] Snardbafulators has userhost ~MalixKeep@200.79.255.125 and real name "MalixKeep"
09:41:12 <copumpkin> we had a spammer with the Malix* prefix yesterday too
09:41:28 <MagneticDuck> copumpkin: but why does kicking him from #haskell help the PM harassment problem?
09:41:31 --- mode: copumpkin set +b *Malix*!*@*
09:41:49 <Rarrikins> MagneticDuck: Avoids giving them names of people in the channel.
09:41:50 <copumpkin> MagneticDuck: because they can't harvest our userlist to decide who to PM. THey already have the current one, but over time it will stop being as useful
09:41:59 <lispy> vanila: not really. It is a short read though.
09:42:11 --- mode: copumpkin set -bb *!~MalixPek@200.79.255.125 *!~MalixKeep@200.79.255.125
09:42:12 <benzrf> copumpkin: they can still look @ the logs
09:42:25 <carter> benzrf: auto spammers aren't that sopisticated
09:42:29 <vanila> thanks Liskni_si
09:42:31 <vanila> thanks lispy
09:42:40 <copumpkin> benzrf: my goal isn't to perfectly prevent all spam. It's to raise the bar to succeed, so they'll do something else
09:42:54 <Rarrikins> If they were looking at the logs, they wouldn't bother joining.
09:42:57 <lispy> vanila: IIRC, I went back to that one when I got stuck on something in the gmachine chapter.
09:43:08 <lispy> vanila: (but skip it from the outset)
09:43:08 <copumpkin> this is drive-by spam
09:43:10 <vanila> aha I will probably do the same
09:43:14 --- mode: copumpkin set -o copumpkin
09:43:17 <benzrf> kk
09:43:35 <MagneticDuck> copumpkin: maybe raising the bar will just get us more determined spammers
09:43:38 <lispy> vanila: I think the lesson with the template instantiation is that it's actually call by name. Which is to say, it doesn't have sharing but it still has the outside in redution order
09:43:48 <benzrf> mmaruseacph2:
09:43:49 <benzrf> *hmm
09:43:52 <lispy> vanila: you can of course add sharing to it (and I think the book does?)
09:43:55 <copumpkin> MagneticDuck: maybe many things
09:43:57 <MagneticDuck> an exclusive population of elite spammers will emerge, developing their methods...
09:44:04 <carter> MagneticDuck: SINGULARITY
09:44:07 <copumpkin> anyway, if you have a problem with it, take it to #haskell-ops
09:44:08 <carter> powered by haskell
09:44:08 <MagneticDuck> they will start hosting international spammathons!
09:44:14 <benzrf> tryna test out Uniplate in ghci
09:44:16 <lispy> vanila: the template instantiation is rewriting, if you're familiar with that
09:44:19 <benzrf> but -XDerivingDataTypeable is unrecognized?
09:44:20 <MagneticDuck> they will probably learn haskell to make more effective spammer tools
09:44:30 <carter> point being, when someone pms hostile stuff, ping #haskell-ops
09:44:45 <MagneticDuck> they will grow a spirit of competition, striving to spam better and faster...
09:44:48 <carter> i've had 1-2 REALLY vile instances
09:45:43 <monochrom> if spam is a killer app of haskell, it is a killer app of haskell :)
09:46:16 <carter> MagneticDuck: i've actually had the bizarre experience of someone PMing very hostile stuff, claiming they were authorized by haskell-ops
09:46:36 <carter> (know that haskell-ops would never authorize any sort of abusive private messaging)
09:47:00 <oscarb92> hello
09:47:05 <carter> hello!
09:47:07 <carter> what yah doing?
09:47:16 <oscarb92> homework :(
09:47:28 <carter> good
09:47:35 <carter> get an A then hack on haskell for fn :)
09:47:57 <monochrom> like this? /msg carter I challenge you to a duel
09:48:17 <lispy> or cohostile, /msg carter I challenge you to a dual
09:48:29 <oscarb92> -1
09:48:29 <oscarb92> down vote
09:48:29 <oscarb92> favorite
09:48:29 <oscarb92> I'm writing a paper about compilers (scanners and parsers specifically) and I'd like to have a little more background on Haskell's tools for generating analysers, but I can't find any information about their creators, dates, places and stuff like that.
09:48:30 <oscarb92> So if anyone would have any references to that information (webpages, books, articles) I'd really appreciate it if you share them with me.
09:48:33 <oscarb92> Thank you.
09:48:54 <Clint> did you just downvote AND favorite lispy's joke
09:49:03 <oscarb92> haha nooo
09:49:25 <oscarb92> copy-paste mistake
09:49:33 <MagneticDuck> ???
09:49:45 <Rarrikins> !!!
09:49:53 <oscarb92> well, this is awkward :|
09:50:05 <monochrom> haha lispy
09:50:10 <Rarrikins> You broke the chat.
09:50:31 <oscarb92> Anyways, could somebody help me out?
09:51:56 <lispy> oscarb92: You want to know stuff about tools like happy and bnfc? is that correct?
09:53:39 <lispy> oscarb92: happy was started around 1991 by Andy Gil, Simon Marlow, and possibly Simon Peyton Jones
09:53:51 <lispy> oscarb92: I know this only from reading the copyright info in the happy sources
09:53:56 <oscarb92> alex and happy. Mostly history, creators, dates and that sort of stuff you cant find on the official pages
09:54:38 <lispy> oscarb92: check the source https://github.com/simonmar/alex https://github.com/simonmar/happy
09:54:45 <ocharles> Does anyone know how to construct equality proofs around ambiguous types? I have to show GHC that   ResultF ('KV k0 v0 : Reverse kvs1) (Maybe v)  :~: ResultF (Reverse kvs1 ++ '['KV x y]) (Maybe v)   , but k0 and v0 are ambiguous types
09:54:58 <rindolf> Hi all.
09:55:08 <carter> ocharles: email / ping goldfire
09:55:08 <ocharles> Hmm, I suppose a first step might to be showing that k0 ~ x and v0 ~ y
09:55:12 <carter> (richard eisenberg)
09:55:13 <ocharles> carter: ha
09:55:25 <carter> its what i do when i'm really stumped on fancy singletons stuff
09:55:26 <ocharles> carter: Well if I do that I'd be a better citizen and ask the cafe :)
09:55:29 <rindolf> I am getting «Cannot find default module for breakpoint. Perhaps no modules are loaded for debugging?» when I try to do ":break 126". I'm on Mageia Linux x86-64 version 5.
09:55:45 <ocharles> Who knows though, maybe goldfire is around!
09:55:46 <rindolf> I am getting «Cannot find default module for breakpoint. Perhaps no modules are loaded for debugging?» with ghci, when I try to do ":break 126". I'm on Mageia Linux x86-64 version 5.
09:56:01 <lispy> oscarb92: also, the git history goes back 18 years! https://github.com/simonmar/happy/tree/cab8425de0a9c343b3c2cb27ebfa3e22adfabdb8
09:56:14 <carter> ocharles: you might wanna do some sort of induction
09:56:42 <monochrom> 18 years is a long time
09:56:46 <ocharles> carter: I could prove that, but I don't know what to do about the ambiguous types. castWith using a more general proof isn't enough
09:56:53 <carter> https://github.com/wellposed/numerical-core/blob/master/src/Numerical/Array/Shape.hs#L425-L437
09:57:10 <carter> ocharles: recast it so you have an induction principle
09:57:17 <carter> instead of a redution principle
09:57:22 <geekosaur> rindolf, is it a compiled module? you may need to load with * to force it to interpret
09:57:44 <geekosaur> precompiled code can't generally be introspected or debugged
09:57:47 <carter> ocharles: if that makese sense
09:57:53 <lispy> monochrom: Kurt Cobain was still alive when those commits were made.
09:57:57 <carter> geekosaur: though that will change in 7.10 I think
09:57:59 <jophish> Yo yo yo
09:58:02 <ocharles> It makes sense, but I don't know how I can cast into an ambiguous types
09:58:04 <ocharles> Hm
09:58:10 <jophish> I have this code, but I'm not sure that it's as neat as possible: http://lpaste.net/103585
09:58:23 <rindolf> geekosaur: I did :l euler_165.hs
09:58:32 <carter> ocharles: its ambigous because its an bunch of type familiy applications with variables in spots
09:58:43 <jophish> it seems to be quite fiddly though
09:58:52 <ocharles> no, it's ambiguous because it as existential type in the GADT I'm matching
09:59:34 <ocharles> I have a classic Here/There path object, and I need to recurse down the "There" branch and construct something larger, which is entirely polymorphic in the outer values
10:00:12 <lispy> jophish: t is a free variable?
10:00:35 <jophish> lispy: ah, that should have been 'c'
10:00:46 <jophish> http://lpaste.net/103585
10:01:12 <lispy> jophish: ah right, so the use of the triple there seems to be obscuring things a bit
10:01:26 <jophish> yeah, it would be nicer if it were a 2-tuple
10:01:57 <ocharles> carter: oh, no - I stand corrected - it is ambiguous from a type family
10:02:03 <carter> :)
10:02:20 <lispy> jophish: I wonder if you could rewrite this using foldMap
10:02:25 <lispy> :t foldMap
10:02:26 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:03:20 <jophish> lispy: good thinking
10:03:34 <jophish> map the last element into a list and bingo
10:04:25 <ocharles> carter: I think it's because GHC doesn't know Reverse is injective :(
10:04:40 <carter> ocharles: only data families and normal types are obvious injective
10:04:43 <ocharles> I know
10:04:46 <carter> change your formulation!
10:04:47 <carter> :)
10:04:58 <ocharles> It may be the only solution
10:05:10 <ocharles> I've already moved two type families to be GADTs witnessing a relation already...
10:05:17 <carter> yay
10:05:19 <jophish> lispy: foldMap (\(as,bs,c)->(as,bs,[c])) is probably best
10:05:26 <ocharles> This level of programming is unfortunately just not there, for Haskell
10:05:30 <carter> soke
10:05:30 <lispy> ocharles: what are you working on? Toy thing, learning example, or "serious business"?
10:05:32 <jophish> although I'm sure lenses could make that a little smaller
10:05:44 <copumpkin> have any of you ever played with weird GADFs?
10:05:48 <ocharles> lispy: do you remember my blog post on a "Querying" applicative functor?
10:05:58 <lispy> copumpkin: no, where do I learn about them?
10:06:02 <copumpkin> I dunno
10:06:09 <copumpkin> I made up the term a while back
10:06:11 <carter> you mean constrainted data families that do GADTs?
10:06:14 <lispy> ocharles: sorry, I do not.
10:06:17 <carter> i have one in hblas kinda
10:06:19 <copumpkin> carter: yeah, in weird ways
10:06:30 <lispy> copumpkin: generalized abstract data families?
10:06:30 <ocharles> lispy: ok, a while ago I wrote an applicative functor that watches for queries, and then batches things together
10:06:47 <copumpkin> data family Foo x :: *; data instance Foo [x] where MyConstructor :: Foo [Int]
10:06:53 <ocharles> I could only write it using IORefs and MVars, so I'm exploring a solution without any of that, which requires a LOT of type magic
10:07:21 <lispy> jophish: you could take that definition to #haskell-lens and ask them to golf it :)
10:07:32 <carter> https://github.com/wellposed/hblas/blob/master/src/Numerical/HBLAS/MatrixTypes.hs#L160 is a pretty prosaic one i did
10:07:43 <lispy> @pl foldMap (\(as,bs,c)->(as,bs,[c]))
10:07:44 <lambdabot> (line 1, column 18):
10:07:44 <lambdabot> unexpected "c"
10:07:44 <lambdabot> ambiguous use of a non associative operator
10:07:51 <jophish> lispy: and what are the chances I'd remember what that means in 3 months time :)
10:08:00 <copumpkin> carter: doesn't look like a data family?
10:08:03 <carter> oh
10:08:04 <carter> well
10:08:06 <carter> ohh
10:08:11 <lispy> jophish: :) At this point, I'm just curious what they'd come up with
10:08:12 <carter> hrmm
10:08:22 <carter> copumpkin: it was a 2 constructor GADT record type before
10:08:23 <carter> ohh
10:08:25 <carter> hrmmm
10:09:47 <lispy> copumpkin: that's interesting. I'd have to think about that more. (your Foo example)
10:10:14 <lispy> copumpkin: Could you prototype it using closed type families?
10:10:22 <carter> oh wait, i may have an example using numerical-core
10:10:49 <lispy> copumpkin: where I really mean, can you desugar that to closed type families.
10:10:52 <copumpkin> lispy: hrm, it needs to be a GADT, so I guess you could have your type family expand to be a GADT but that loses some of the weird interplay between the two mechanisms
10:12:17 <lispy> copumpkin: you should start working on it now so you can publish a paper about this for next ICFP :)
10:12:24 <copumpkin> hah
10:12:33 <lispy> I'm only half-joking.
10:12:35 <copumpkin> not sure there's that much interestingness in it
10:12:47 <copumpkin> if you think of a GADT as an implicit type equality witness
10:12:49 <lispy> Yeah, figuring that out would be part of the research
10:12:49 <copumpkin> it stops looking as weird
10:13:06 <copumpkin> but I'd be curious to see what good use cases there are for them
10:13:17 <copumpkin> I have way more interesting stuff I should be working on :P
10:13:32 <lispy> when GADTs were added they didn't have many use cases figured out. They just knew it added a lot of expressive power.
10:14:16 <carter> lispy: i'm  actually regularly emailing richard examples "is this a bug or am I using it wrong"
10:14:50 <lispy> carter: are you learning how to determine that for yourself in the process?
10:14:58 <carter> i hope so
10:15:11 <carter> its only when i do particuarly crazy things that i get confused these days
10:15:31 <carter>  did  you know you can apply type families  to partially applied data families? :)
10:15:47 <lispy> Nope
10:15:49 <carter> i'm really happy about that
10:15:57 <carter> it makes some stuff i'm doing work out especially nice
10:16:22 <lispy> carter: I guess it works because it's a partially applied function in system F?
10:16:54 <carter> i was thinking moreso "a partially applied data family is still injective in its field"
10:16:56 <carter> *fields
10:17:34 <carter> ok, g2g
10:18:01 <benzrf> pls help
10:18:07 <benzrf> i am attempting to try out uniplate in ghci
10:18:10 <benzrf> but...
10:18:14 <yitz> carter: who does windows builds for ghc?
10:18:14 * lispy waits for it
10:18:17 <benzrf> benzrf@benzrf-laptop:~$ ghci -XDerivingDataTypeable
10:18:17 <benzrf> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
10:18:17 <benzrf> ghc: unrecognised flags: -XDerivingDataTypeable
10:18:30 <carter> yitz: .... :) thoughtpolice ?
10:19:04 <bennofs> benzrf: DeriveDataTypeable, not Deriv*ing*
10:19:04 <lispy> benzrf: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
10:19:09 <lispy> benzrf: yeah
10:19:11 <benzrf> waiiit
10:19:12 <yitz> carter: ok. lispy and i were trying to figure out which loader we're supposed to use with the 64-bit build. lispy thinks the 32-bit loader.
10:19:23 <benzrf> via the uniplate page,
10:19:25 <benzrf> >{-# LANGUAGE DerivingDataTypeable #-}
10:19:28 <benzrf> ??
10:19:41 <lispy> yitz: more specifically, I know you need ld that ships with it.
10:19:48 <ThePawnBreak> is there a function to split a list into 2 by a predicate?
10:19:49 <bennofs> benzrf: trick: if you start ghci without the flag, then you can do :set -XDer<TAB> to get a list of possible extensions (tab completion)
10:19:53 <geekosaur> isn't it DeriveDataTypeable?
10:19:55 <benzrf> oh neat
10:19:59 <benzrf> geekosaur: it loaded when i did that
10:20:01 <yitz> lispy: well both ship with it
10:20:02 <benzrf> but http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm
10:20:07 <lispy> yitz, carter: the name of the tarball on the ghc website makes me think they used 32bit mingw
10:20:49 <yitz> carter: and the question is - could that be the source of weird crashes we're getting for big memory usage?
10:21:52 <lispy> yitz: Hmm...you tried the latest 64bit release?
10:22:03 <benzrf> Prelude Data.Generics.Uniplate.Data> import Data.Generics.Uniplate.Data
10:22:03 <benzrf> Prelude Data.Generics.Uniplate.Data> data List' a = Cons a (List' a) | Nil deriving (Show, Eq, Data, Typeable)
10:22:09 <benzrf> <interactive>:6:59: Not in scope: type constructor or class `Data'
10:22:13 <supki> ThePawnBreak: partition
10:22:15 <benzrf> same issue with Typeable
10:22:18 <benzrf> wuh?
10:22:20 <bennofs> benzrf: import Data.Data
10:22:26 <benzrf> o:
10:22:32 <benzrf> so is http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm entirely incorrect?
10:22:32 <yitz> lispy: no. i would have to recreate the environment. the huge memory vm i was using may be gone by now. would have to contact IT.
10:22:52 <lispy> yitz: I ran into a 7.8.2 bug with optimizing vector (vector is probably as much to blame as ghc). And my ghc binary can use 10+ GB of ram. So I assume the programs can too (they use the same rts as the compiler itself, right?)
10:23:39 <lispy> benzrf: it could be out of date
10:23:50 <yitz> lispy: presumably. the compiler does a lot more than that too, so you would think that if i can crash the runtime, so can ghc.
10:24:10 <albeit> ThePawnBreak: partition
10:24:12 <albeit> @hoogle partition
10:24:13 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
10:24:13 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
10:24:13 <lambdabot> Data.Text.Lazy partition :: (Char -> Bool) -> Text -> (Text, Text)
10:24:55 <lispy> yitz: one more question: which version(s) of ghc gave you the large memory crashes?
10:25:19 <yitz> > partition ((== 0) . (`mod` 3)) [0..20]
10:25:20 <lambdabot>  ([0,3,6,9,12,15,18],[1,2,4,5,7,8,10,11,13,14,16,17,19,20])
10:25:53 <yitz> lispy: umm... i *think* it was 7.6.1
10:27:25 <yitz> > partition isUpper "ThePawnBreak"
10:27:26 <lambdabot>  ("TPB","heawnreak")
10:27:53 <lispy> yitz: I'd say it's worth trying again (but with the new ghc)
10:29:06 <yitz> lispy: i'll try to find time to try it. what would you do about the path w.r.t. mingw64/bin and/or mingw32/bin ? ghc uses other binaries from there, too, like strip.
10:29:16 <yitz> probably ar or something
10:29:36 <lispy> yitz: I'll paste my path
10:29:47 <yitz> lispy: you can pm it if you prefer
10:30:37 <lispy> yitz: http://lpaste.net/103588
10:30:43 <lispy> yitz: nothing sensitive in my path :)
10:30:48 <yitz> lispy: tnx!
10:31:04 <yitz> lispy: well spoken given where you are employed :)
10:31:25 <lispy> yitz: I don't know where ".:/usr/local/bin:/mingw/bin:/bin" comes from. I think mingw is adding it?
10:31:40 <lispy> yitz: but having that in my path forced me to set my path from ~/.bashrc
10:31:54 <lispy> instead of using the windows control panel
10:32:29 <yitz> lispy: the ghc installer added it apparently. it is indeed the 32-bit mingw.
10:32:41 <erisco> say I have the GADT data Foo where Foo :: (Typeable a) => a -> Foo  ... how might I increment  'Foo 5'  without knowing what Num instance is being used?
10:32:42 <lispy> yitz: Actually we don't take on sensitive work. I think that's a common misunderstanding about us.
10:33:06 <yitz> lispy: i vaguely recall running into trouble and changing it to the 64-bit one, perhaps because of strip. that may have been the source of my woes.
10:33:51 <yitz> lispy: i.e. you sell shovels rather than digging the gold
10:34:47 <lispy> yitz: Yeah, that's a fair way to put it.
10:35:05 <lispy> yitz: we build tools, like cryptol but we don't use cryptol to make new ciphers
10:35:27 <erisco> would I need to make data AnyNum = AnyNum (forall n. (Num n) => n) ?
10:35:46 <pyon> Is there any function of type "Ord b => (a -> b) -> [a] -> [a]" ?
10:35:48 <lispy> yitz: and I don't if you saw, but (bring it back to haskell), we just open sourced cryptol :)
10:36:04 <yitz> lispy: i did see that. it's awesome!
10:36:07 <lispy> And someone made a #cryptol channel
10:36:07 <erisco> :t comparing -- pyon
10:36:08 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:36:25 <pyon> erisco: Oh, nice.
10:36:38 <pyon> That and Data.List.sortBy should do, right?
10:36:47 <benzrf> the state monad is really just 2-arg compo isnt it
10:36:59 <erisco> :t \f -> sortBy (comparing f) -- pyon
10:37:00 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
10:37:12 <lispy> benzrf: that's half of it. there is also an update
10:37:15 <benzrf> update?
10:38:05 <lispy> benzrf: you can think of the state monad as inspecting the function calls, adding a parameter (the 2-arg compo bit) and also taking the result and holding on to half of it for you.
10:38:07 <erisco> :t sortBy . comparing
10:38:08 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
10:38:24 <lispy> benzrf: holding on to half of the result is the updating bit.
10:38:47 <benzrf> 'holding on to half of the result' ?
10:39:11 <lispy> @unmlt State s a
10:39:11 <lambdabot> Maybe you meant: unpl unmtl
10:39:13 <benzrf> isnt it just feeding the 2-tuple from the last one as 2 args to the next one
10:39:15 <lispy> @unmtl State s a
10:39:16 <lambdabot> s -> (a, s)
10:40:34 <lispy> benzrf: http://www.haskell.org/haskellwiki/All_About_Monads#Definition_6
10:42:43 <benzrf> :t (>>=) `asAppliedTo` State s a
10:42:44 <lambdabot>     Not in scope: data constructor ‘State’
10:42:44 <lambdabot>     Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
10:42:57 <benzrf> :t (>>=) `asAppliedTo` StateT n s a
10:42:58 <lambdabot>     Couldn't match expected type ‘Expr -> Expr -> m a’
10:42:58 <lambdabot>                 with actual type ‘StateT s0 m0 a0’
10:42:58 <lambdabot>     The function ‘StateT’ is applied to three arguments,
10:42:59 <benzrf> *m
10:43:04 <benzrf> wuh
10:43:06 <benzrf> oh
10:43:27 <benzrf> :t (>>=) `asAppliedTo` (undefined :: State s a)
10:43:28 <lambdabot> StateT s Identity a -> (a -> StateT s Identity b) -> StateT s Identity b
10:43:36 <benzrf> :t (>>) `asAppliedTo` (undefined :: State s a)
10:43:37 <lambdabot> StateT s Identity a -> StateT s Identity b -> StateT s Identity b
10:45:10 <benzrf> > let s1 = state $ \s -> (1, (++"foo")); s2 = state $ \s -> (1, (++"bar")) in runState (s1 >> s2) ""
10:45:12 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState
10:45:12 <lambdabot>                     ([GHC.Types.Char] -> [GHC.Types.Char])
10:45:12 <lambdabot>                     (Control.Monad.Trans.State.Lazy.StateT
10:45:12 <lambdabot>                        [GHC.Types.Char] Data.Functor.Identity.Identity))
10:45:12 <lambdabot>    arising from a use of ‘s1’No instance for (GHC.Num.Num a) arising from a u...
10:45:16 <benzrf> wuh
10:45:23 <migimunz> what is 'asAppliedTo', what module is it in?
10:45:29 <benzrf> > let s1 = state $ \s -> ('n', (++"foo")); s2 = state $ \s -> ('n', (++"bar")) in runState (s1 >> s2) ""
10:45:30 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState
10:45:30 <lambdabot>                     ([GHC.Types.Char] -> [GHC.Types.Char])
10:45:30 <lambdabot>                     (Control.Monad.Trans.State.Lazy.StateT
10:45:30 <lambdabot>                        [GHC.Types.Char] Data.Functor.Identity.Identity))
10:45:30 <lambdabot>    arising from a use of ‘s1’
10:45:33 <benzrf> migimunz:
10:45:36 <benzrf> :t asAppliedTo
10:45:37 <lambdabot> (a -> b) -> a -> a -> b
10:45:44 <benzrf> it does not actually do anything
10:45:49 <benzrf> it just locks down a polymorphic type
10:45:53 <benzrf> i.e.
10:45:56 <migimunz> benzrf, ah
10:46:00 <migimunz> I think I understand
10:46:01 <benzrf> :t const `asAppliedTo` 3
10:46:02 <lambdabot> Num a => a -> b -> a
10:46:04 <benzrf> :t const `asAppliedTo` "foo"
10:46:05 <lambdabot> [Char] -> b -> [Char]
10:46:07 <benzrf> ^
10:46:09 <orion> Hi. Are network Socket's thread safe?
10:46:10 <migimunz> oh awesome
10:46:15 <orion> Or should I wrap them in a TMVar?
10:46:16 <migimunz> thanks benzrf
10:46:19 <benzrf> migimunz: np :)
10:46:31 <benzrf> @src asAppliedTO
10:46:31 <lambdabot> Source not found. My brain just exploded
10:46:33 <benzrf> @src asAppliedT
10:46:33 <lambdabot> Source not found. Wrong!  You cheating scum!
10:46:34 <benzrf> @src asAppliedTo
10:46:34 <lambdabot> Source not found. It can only be attributed to human error.
10:46:37 <benzrf> bluh
10:46:46 <albeit> @hoogle: asAppliedTo
10:46:46 <lambdabot> Maybe you meant: hoogle+ hoogle
10:46:53 <Guest87869> orion: you should be reading and writing the socket from one thread, though if you dont nothing catastrophic will happen
10:46:57 <benzrf> migimunz: it's handy for things like deciphering (>>=) on a particular monad
10:47:14 <benzrf> > let s1 = state $ \s -> ('n', (++"foo")); s2 = state $ \s -> ('n', (++"bar")) in runState (s1 >> s2) ""
10:47:15 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState
10:47:15 <lambdabot>                     ([GHC.Types.Char] -> [GHC.Types.Char])
10:47:15 <lambdabot>                     (Control.Monad.Trans.State.Lazy.StateT
10:47:15 <lambdabot>                        [GHC.Types.Char] Data.Functor.Identity.Identity))
10:47:15 <lambdabot>    arising from a use of ‘s1’
10:47:19 <benzrf> w-wut
10:47:22 <migimunz> awesome!
10:47:29 <benzrf> :t state $ \s -> ('n', (++"foo"))
10:47:30 <lambdabot> MonadState ([Char] -> [Char]) m => m Char
10:47:33 <benzrf> o_O
10:47:40 <benzrf> oh wait >.<
10:47:56 <benzrf> > let s1 = state $ \s -> ('n', s ++ "foo"); s2 = state $ \s -> ('n', s ++ "bar") in runState (s1 >> s2) ""
10:47:58 <lambdabot>  ('n',"foobar")
10:48:00 <benzrf> sweet
10:48:49 <albeit> Guest87869: Is it okay to make a thread to read from each socket, and another thread that writes to all the sockets?
10:49:05 <albeit> So multiple read threads, and a single write thread.
10:49:11 <Guest87869> yes
10:49:43 <benzrf> Guest87869: ever tried ZMQ
10:49:57 <Guest87869> no
10:50:02 <benzrf> * ØMQ
10:50:04 <benzrf> :-)
10:50:15 <benzrf> it will make yr socket problems go away
10:50:17 <benzrf> possibly
10:50:26 <benzrf> wizza pow
10:50:30 <Guest87869> im not having a socket problem
10:50:33 <benzrf> oh
10:51:07 <benzrf> Guest87869: but you're using sockets
10:51:09 <benzrf> you must have problems
10:51:16 <Guest87869> im actually not using sockets
10:51:32 <albeit> Does ZMQ really offer that much more over Network.Socket? Haskell Sockets have felt so smooth after dealing with C/Python sockets...
10:51:55 <benzrf> i have never used Network.Socket
10:52:10 <Guest87869> yes, whatever issues people usually have that drive them to crazy frameworks do not occur with ghc's concurrent runtime
10:52:10 <benzrf> but ØMQ isn't really a socket library in the standard unix socket sense
10:52:23 <benzrf> ØMQ sockets are not all that similar to tcp sockets
10:52:46 <benzrf> i've ranted about it in #ruby at least 3 times let me find one of my rants
10:53:04 <migimunz> benzrf, not even hoogle is aware of asAppliedTo :| . I defined it like this, it seems to work: asAppliedTo :: (a -> b) -> a -> a -> b
10:53:04 <migimunz> asAppliedTo f a = f
10:53:25 <benzrf> migimunz: in other words, asAppliedTo = const?
10:53:41 <migimunz> heh, I'm a newbie, I saw const once and had no idea what it's used for:P
10:53:42 <benzrf> i think somebody defined it with @let
10:53:42 <Guest87869> albeit: of course, implementing a protocol on top of TCP is another story, but just getting your bytes into and out of a program is very simple in haskell
10:53:47 <migimunz> ah
10:53:56 <benzrf> > map (const 3) [1, 2, 3, 4, 5]
10:53:57 <lambdabot>  [3,3,3,3,3]
10:53:59 <yitz> @google haskell asAppliedTo
10:53:59 <lambdabot> https://github.com/keseldude/brobot-plugins/blob/master/haskell/L.hs
10:54:01 <benzrf> although you could just do
10:54:04 <benzrf> > 3 <$ [1, 2, 3, 4]
10:54:06 <lambdabot>  [3,3,3,3]
10:54:15 <benzrf> brobot?
10:54:17 <benzrf> i run a brobot!
10:54:20 <benzrf> it's nicked brobot
10:54:21 <albeit> Guest87869: Yeah, just using Unix domain sockets for IPC. Porting some C and Python code to Haskell... much nicer.
10:54:32 <benzrf> @cake
10:54:33 <lambdabot> cide ........ The Collaborative International Dictionary of English
10:54:44 <erisco> how might I better use existential types? in this example I create an Entity, attempt to increment its value, and then print it http://lpaste.net/103589
10:55:04 <migimunz> <$ is like const for applicatives, basically?
10:55:08 <Guest87869> albeit: if youre familiar with EPIPE and junk like this, note that you still might get exceptions in haskell while operating on handles
10:55:13 <erisco> however, I am stuck with the problem that AnyNum only implies Num, and AnyShow only implies Show, so unless I have AnyShowNum I seem to be stuck
10:55:13 <yitz> @type asTypeOf
10:55:14 <lambdabot> a -> a -> a
10:55:24 <Guest87869> albeit: something to keep in mind for "reliable" programs
10:55:27 <benzrf> migimunz: more like const for functors o=
10:55:31 <benzrf> @src (<$)
10:55:31 <lambdabot> (<$) = (<$>) . const
10:55:38 <benzrf> more readably.
10:55:41 <erisco> yitz, is that for me?
10:55:47 <benzrf> v <$ f = fmap (const v) f
10:56:13 <yitz> erisco: thought maybe that's what benzrf was looking for.
10:56:15 <migimunz> oh I get it, thanks!
10:57:13 <Ireneista> Hi all.  So, I’m trying to use extensible-effects on a personal project.  I realize that this makes me a bit of an early adopter…
10:57:35 <Ireneista> the project had previously used conduits, and I’m wondering whether Control.Eff.Coroutine is meant to be a replacement for those (someday), or what.
10:58:08 <benzrf> ØMQ tho
10:58:11 <benzrf> its so cool
10:58:13 <Guest87869> ...
10:58:32 <Guest87869> is zmq your business lol
10:58:46 <benzrf> no
10:58:48 <benzrf> but its awesome
10:58:51 <lispy> erisco: this is kind of the problem with existential types. Statically you've erased everything you know about them.
10:58:52 <benzrf> so cool
10:59:21 <erisco> lispy, that is the feature I am looking for, though. I'm not erasing the information just for kicks ;)
11:00:06 <Ireneista> I just walked in so I don’t know what you’re doing, but you can get something similar to OO dynamic dispatch by combining existentials with typeable
11:00:19 <Guest87869> urg
11:00:26 <erisco> lispy, however it is necessary to discover what the types were in the first place. I can do this if I want to discover a concrete type (such as Int) using Typeable, but it is problematic if I want to discover any type which has a particular type class instance
11:00:27 <lispy> erisco: What you probably want to do is make a type class for entities that has all the supported operations.
11:00:34 <Ireneista> the catch is that you need to put everything you want to do to your objects in their typeclass
11:00:47 <Ireneista> actually, you may not need typeable, I don’t remember
11:01:18 <erisco> lispy, this is not possible for me
11:01:45 <Ireneista> let’s hear more about your scenario
11:01:52 <lispy> erisco: http://hackage.haskell.org/package/reflection
11:02:20 <_d0t> hi. Is there memset in haskell? I need to zero out the buffer obtained with allocaBytes.
11:02:28 <erisco> my scenario is best described by this http://lpaste.net/103589 (as before)
11:03:08 <Ireneista> (I just got here, so I didn’t see the earlier link.)  looking.
11:03:18 <erisco> where any Typeable may be entityData, and I want to perform operations on entityData that only presume a type class, not a concrete type
11:03:48 <Ireneista> can you at least enumerate all the typeclasses you need?
11:03:54 <erisco> AnyShow and AnyNum are an attempt at that, but it becomes a problem if the concrete type implements both. ie I would need AnyShowNum
11:04:00 <erisco> Ireneista, no =\
11:04:02 <Ireneista> right
11:04:05 <Ireneista> hm :/
11:04:49 <erisco> the equivalent in OOP would be interfaces
11:04:57 <Ireneista> indeed
11:04:58 <erisco> I thought Haskell had existential type classes ie runtime interfaces?
11:05:26 * hackagebot simple-genetic-algorithm 0.2.0.0 - Simple parallel genetic algorithm implementation  http://hackage.haskell.org/package/simple-genetic-algorithm-0.2.0.0 (eax)
11:05:31 <Guest87869> you dont need existential types to have "runtime interfaces"
11:05:32 <Ireneista> it does.  this is what they are, kinda.
11:06:05 <lispy> _d0t: I wrote a calloc and callocBytes for doing that: http://hackage.haskell.org/package/missing-foreign-0.1.1/docs/Foreign-Marshal-MissingAlloc.html
11:06:11 <lispy> _d0t: it's not stack allocated though.
11:06:17 <erisco> Ireneista, I see
11:06:29 <Ireneista> I mean, if you explained what you’re using it for, there might be an entirely different way to structure your program.  but barring that, hmmm.
11:06:29 <erisco> so the issue is having ad-hoc interface unions, then
11:06:54 <Ireneista> yeah
11:07:00 <_d0t> lispy: Exactly :( I need it to be stack allocated for the speed sake
11:07:24 <erisco> in oop generics one might say  foo<T implements X, Y, Z>(t: T) ...
11:07:35 <Ireneista> yes.
11:07:40 <jmcarthur> erisco: what you are trying to do is quite unidiomatic. why do you want this?
11:08:05 <erisco> Ireneista, but I guess that is not quite analagous to what I have... since I do not need to know the concrete type 'T'
11:08:09 <lispy> _d0t: http://hackage.haskell.org/package/missing-foreign-0.1.1/src/Foreign/Marshal/MissingAlloc.hs
11:08:18 <lispy> _d0t: you can use that as example code to make your own binding
11:08:33 <Ireneista> right, true enough.  but I see what you want from the Haskell side, which honestly makes more sense to me than the C++ syntax above does anyway :)
11:08:53 <erisco> Ireneista, so it is more like    interface MyInterface extends X, Y, Z { };  foo(t: MyInterface)    which is not ad-hoc
11:08:55 <_d0t> lispy: I already have a great bunch of those, sadly.
11:09:09 <erisco> Ireneista, and in most languages would fail if the type did not explicitly implement MyInterface
11:09:12 <_d0t> GHC must have memset inside, I wonder if it exposes it somewhere
11:09:13 <jmcarthur> erisco: are you very certain this is what you want to do, or is it likely that this is OOP habits creeping into your Haskell?
11:09:17 <Ireneista> certainly
11:09:47 <erisco> jmcarthur, I am investigating entity-component frameworks for the purposes of game development
11:09:50 <lispy> _d0t: it's going to be something like foreign import ccall unsafe "string.h memset" _memset :: Ptr a -> CInt -> CSize -> IO (Ptr a)
11:09:59 <Ireneista> I mean, there are legitimate reasons to want something like this, mostly involving “it’s to bind against a foreign library that works that way"
11:10:10 <lispy> _d0t: then you'll write a short wrapper around _memset to give it a more friendly type
11:10:13 <_d0t> lispy: I know. I just hate bicycles and copypasting.
11:11:01 <jmcarthur> erisco: interesting. most entity component styles i am aware of aren't OO at all. usually they just represent entities as abstract identities which serve as indices into various collections which actually have the "fields" of the entity
11:11:39 <albeit> If I have a "data Msg = MakeFoo Foo | MakeBar Bar", but I want another module to be able to add more message types "ie MakeBaz Baz", how can I do that?
11:11:56 <lispy> _d0t: If we collected up a bunch of these utility functions we could make a proposal to add them to the standard FFI routines.
11:12:06 <lispy> _d0t: I think that's the right long term solution
11:12:21 <Guest87869> albeit: you cant
11:12:33 <_d0t> lispy: yup. Thats your package, right?
11:12:49 <albeit> What's a proper Haskell way to do something similar?
11:12:59 <Guest87869> albeit: in fact, its common to hide the constructors from other modules to faciliate abstract data types
11:13:06 <erisco> jmcarthur, that is a possibility. I am learning what I can about existential types to see what my options are. I'll choose something which I think best fits the functional paradigm (and this direction is having issues)
11:13:37 <Guest87869> albeit: type classes are "open" in this regard, other modules can implement more instances of your class
11:13:54 <lispy> _d0t: well, the missign foreing thing is mine. In retrospect it's a bit silly.
11:13:55 <shasts> Hi,  What is the difference between version 1 and 2 in this  code (http://lpaste.net/103591). Does a strict foldl' make any difference here ? Also is there any place where I can read about this ? I have already read this ( http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf). But not very explicit for a context like this.
11:14:01 <Guest87869> if you can define some common set of functionality that they will reasonably be able to implement
11:14:14 <Guest87869> but this might not be what you want either
11:14:24 <lispy> _d0t: I meant to propose those definitions on the libraries mailing list but uploaded that package so i'd have something to use in the meantime.
11:14:27 <_d0t> lispy: can you add memset there so it all stays in one place?
11:14:47 <Guest87869> for whatever you are using these "message types" for, you may be able to represent that with a function instead, or a record of functions
11:15:13 <lispy> _d0t: can we meet half way? Send me a pull request and I'll upload a new version :) https://github.com/dagit/missing-foreign
11:15:30 <_d0t> lispy: ok
11:16:15 <lispy> _d0t: back in a while. I need to make food.
11:16:17 <jmcarthur> erisco: the problem you're having is also a problem you normally run into with OO, except that most OO languages don't bring it to the forefront via the type system. as soon as you commit an "entity" to any particular interface, it's stuck that way. in OO languages, you end up using reflection of some sort to dynamically determine if the entity supports such-and-such interface and adjust what you do with it
11:16:18 <jmcarthur> accordingly. most people frown on such practices but then end up doing it anyway. haskell is basically forcing you to think about this up front. the direct solution would be to use ADTs, in place of the "dirtier" type introspection. a more haskelly solution would be to avoid committing to a uniform interface in the first place. different kinds of entities should just be stored in different kinds of
11:16:20 <jmcarthur> collections.
11:16:46 <albeit> Guest87869: Okay, I need to figure out exactly what I need to do first...
11:16:52 <alpounet> shasts: it may make a small difference here yeah
11:16:59 <erisco> jmcarthur, yes I agree this is the case
11:17:04 <jmcarthur> erisco: and then there's the style i mentioned earlier, which actually fits into haskell very well. entities are ids. data about entities is stored in various collections indexed by entity id. not all collections have to have data for all entities
11:17:13 <ReinH> epsilonhalbe: Thanks! We've just had some trouble scheduling but we're recording again on the 11th.
11:17:19 <alpounet> you'll evaluate the map updates as you go, as opposed to waiting until the resulting map gets used
11:18:29 <jmcarthur> erisco: but i should also point out that this style is for extremely dynamically extensible engines. i tend to prefer more static type checking awesomeness than this style encourages
11:18:36 <epsilonhalbe> @reinh yay - if you need any help just tell me, I want to keep haskellcast alive
11:18:36 <lambdabot> Unknown command, try @list
11:18:56 <ReinH> epsilonhalbe: thanks :)
11:19:02 <jmcarthur> erisco: therefore, i prefer to just not pretend all entities are the same
11:19:10 <jmcarthur> store them separately, etc.
11:19:13 <shasts> @alpounet Is there a reading material I can learn from ?
11:19:14 <lambdabot> Unknown command, try @list
11:19:35 <ReinH> Please use <nick>: instead of @<nick> to avoid triggering lamdabot :)
11:20:07 <erisco> jmcarthur, these are options I am looking at, but what I am most interested in at the moment is this problem of "ad-hoc interface unions"
11:20:16 <alpounet> shasts: I wrote http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html exactly for this kind of situation
11:20:24 <jmcarthur> erisco: well, actually, that's a half truth. i mix the two styles, normally. for example, physics related data will typically belong in their own collections indexed by entity id. this allows me to run the physics engine all in one go without having to iterate over all entities of all types and have special logic for each
11:20:36 <alpounet> maybe that could be helpful for you
11:20:42 <jmcarthur> erisco: similarly for rendering, etc.
11:20:55 <erisco> jmcarthur, there are several type classes available and whether I have dynamic (id-indexed) components or not it still stands that I want to leverage the available type classes
11:21:44 <jmcarthur> erisco: i think the mistake is declaring in the data type that the entity must be an instance of some set of type classes. better to just expose the entity type and put the type class constraints in the call sites
11:22:25 <erisco> jmcarthur, I did give any constraint other than Typeable
11:22:39 <jmcarthur> erisco: you also had those AnyShow and AnyNum data types
11:23:28 <erisco> jmcarthur, those were not a constraint on Entity
11:23:39 <jophish> If I have a vector class which is sized at the type level, is there a Monad instance which makes sense?
11:23:48 <erisco> jmcarthur, I was using those in an attempt to make the respective type classes existential
11:24:12 <Guest87869> haskell OO
11:24:13 <migimunz> hm, why is Either not an instance of MonadPlus?
11:24:18 <erisco> jmcarthur, but it falls down when you require more than one type class
11:24:19 <jmcarthur> erisco: right. you are trying to bundle all this into the Entity type.
11:24:25 <erisco> jmcarthur, no, I am not
11:24:38 <erisco> but nevermind, I'll give more thought to it.
11:24:43 <Guest87869> you can easily require more than one class in a function
11:25:23 <_d0t> migimunz: try imagining a zero element of either
11:25:47 <migimunz> _d0t, understood :P
11:25:58 <jmcarthur> erisco: Typeable just bundles a type representation along with the data. cast basically matches on that type representation to see if it's safe to do. basically what you're doing is trying to use that typerep as a placeholder for all the things you can do with the data. (it doesn't quite work that way anyway, but it is what you're doing)
11:26:23 <benzrf> hmmm i feel like ØMQ could work well w/ FRP
11:26:30 <benzrf> not sure how
11:26:36 <benzrf> but something feels like it would fit
11:26:39 <shasts> <alpounet> : reading. Thanks.
11:26:42 <_d0t> migimunz: either could be an instance of semigroup though
11:26:43 <jmcarthur> s/basically//
11:26:47 <migimunz> ok, I asked because I'm writing my own type which represents computation success, failure (as a result) and an error with a message. It's something like maybe and either combined. And I thought that it made sense for it to be an instance of MonadPlus as well (Failure being a zero element)
11:26:52 <erisco> jmcarthur, yes, I am aware, and I think what I am trying to do is not being communicated clearly to you
11:27:16 <vanila> migimunz, Either (Maybe Message) a
11:27:17 <erisco> jmcarthur, but that is okay. I have enough clarification now that I can attempt to tackle the problem again
11:27:35 <jmcarthur> erisco: i believe i understand. you are hoping to inspect the type to determine whether it is "showable" or "numable" and act accordingly.
11:27:43 <migimunz> vanila, basically that's what it is, yeah. Would it be a better idea to use that instead of rolling my own?
11:27:51 <vanila> migimunz, it might work - just an idea
11:28:06 <erisco> jmcarthur, yes that is the idea
11:29:23 <jmcarthur> erisco: the problem with your attempt is that AnyShow and AnyNum are actually distinct types with their own typereps, so you can't have the same thing cast to both.
11:29:33 <erisco> yes, I am aware :)
11:30:51 <erisco> the simple solutions is AnyNumShow, but in general that is a poor solution
11:31:20 <johnw> migimunz: if you make your type a synonym for EitherT a (MaybeT Identity) b, you should get the properties you want
11:31:42 <Guest87869> im currently doing OOP too, IO action which sets up TVars and returns IO actions that operate on them
11:31:49 <Guest87869> haha
11:31:51 <jmcarthur> erisco:   data Dict a = Show a => Show a | Num a => Num a;   data Entity = forall a. Typeable a => Entity [Dict a] a
11:32:08 <jmcarthur> erisco: now you just have to search the [Dict a] for the instance you want, to bring it into scope
11:32:35 <jmcarthur> ah i messed up
11:32:50 <jmcarthur> erisco: data Dict a = Show a => Show | Num a => Num;   data Entity = forall a. Typeable a => Entity [Dict a] a
11:33:29 <migimunz> johnw, I'm not familiar with monad transformers yet so I'm not sure what that means :)
11:33:40 <freeman42> :'( http://www.reddit.com/r/haskell/comments/24pghh/what_happened_to_haskell/
11:33:51 <johnw> Either a b will give you a monad with 'early termination' on Left values
11:33:57 <erisco> jmcarthur, where do I get to the part where I can cast the data?
11:34:06 <johnw> so you could have Either a (Maybe b), but that won't terminate early on "successful" failure results of Right Nothing
11:34:19 <johnw> a transformers will effectively engage the effects of both monads
11:34:27 <johnw> so that Left a terminates early, and Right Nothing terminates early
11:34:54 <awestroke> johnw: why is it (MaybeT Identity) ?
11:35:08 <johnw> it could probably be just Maybe
11:35:09 <jmcarthur> erisco:   let increment (Entity dicts x) = go dicts where go [] = Nothing; go (Num:ds) = Just (Entity dicts (x+1)); go (_:ds) = go ds
11:35:14 <jmcarthur> erisco: no cast even necessary in this case
11:35:19 <migimunz> jonhw, ah, yeh, that's exactly what I want, thanks
11:35:42 <johnw> so try: EitherT a Maybe b
11:35:46 <jmcarthur> erisco: this requires the ConstraintKinds extension
11:35:50 <goldfire> ocharles: I'm around now if I could be of service...
11:35:50 <jmcarthur> wait
11:35:53 <jmcarthur> no it doesn't
11:35:59 <jmcarthur> erisco: nevermind that about the extension
11:36:01 <fizruk> @unmtl MaybeT Identity a
11:36:02 <lambdabot> Maybe a
11:36:20 <migimunz> johnw, I will, thanks! Though I'd like to read about monad transformers first, I have no idea how that works yet
11:36:32 <albeit> What does the "unmtl" bot/command do?
11:36:32 <fizruk> @unmtl EitherT a Maybe b
11:36:32 <lambdabot> EitherT a Maybe b
11:36:33 <erisco> jmcarthur, but how does the type checker allow 'x+1' when 'x' effectively has the type (Typeable a) => a  for some a?
11:36:34 <jmcarthur> erisco: i should highlight that now we're not only doing something unidiomatic, it's actually very unusual and wouldn't even occur to most people, even newbies :)
11:36:36 <migimunz> wikibooks seems to have a nice article
11:36:48 <jmcarthur> erisco: the pattern matching on Num brings the Num instance into scope
11:37:01 <jmcarthur> erisco: all it knows about x at that point is that it's an instance of Num
11:37:14 <awestroke> @help unmtl
11:37:14 <lambdabot> unroll mtl monads
11:37:26 <fizruk> albeit: “unpacks” monad transformers fro mtl library
11:37:30 <albeit> Ah didn't konw about @help, cool
11:37:47 <erisco> jmcarthur, this is highly peculiar
11:37:55 <jmcarthur> erisco: i agree, hence all my warnings :)
11:38:09 <jmcarthur> erisco: but it is type safe and does what you want
11:39:05 <johnw> migimunz: the (>>=) function for a monad transformers applies (>>=) to its "inner" monad as well.   So for EitherT it would be along the lines of:  Left a >>= _ = Left a; Right m >>= f = EitherT $ m >>= runEitherT . f }
11:39:20 <erisco> jmcarthur, yes it probably does. I'll give it a try. thanks
11:39:45 <johnw> ugh, I need some other code there to run the "a" in Left a
11:40:00 <johnw> anyway, I'll leave it to the Internet to edify you
11:40:30 * hackagebot buildwrapper 0.8.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.1 (JeanPhilippeMoresmau)
11:40:40 <migimunz> thanks for the info. yeah, wikibooks seems to have a nice explanation (as does LYAH)
11:40:56 <johnw> i.e.: EitherT a >>= f >>= \case Left a' -> return (Left a), etc.
11:41:07 <johnw> s/f/f = a /
11:41:12 <enthropy> can criterion produce machine-readable output?
11:41:13 <johnw> sorry, this isn't coming across clearly at all
11:41:24 <migimunz> haha
11:41:34 <johnw> implement EitherT for yourself as an exercise
11:41:40 <erisco> jmcarthur, in general are these type scopes created by pattern matching?
11:41:41 <johnw> that will be highly illimunating as to what transformers "do"
11:42:26 <migimunz> johnw, I will! I tend reimplements stuff and then look at the actual implementation. It's fun and likely to get me fired.
11:42:34 <jmcarthur> erisco: not totally sure i understand the question. when you pattern match on the Num, GHC is aware of the relationship between that constructor and the type of the value you got from pattern matching on the entity earlier.
11:43:03 <johnw> the key is that for a transformer to be a transformer, it need to call >>= itself on a value of the inner monad
11:43:19 <saeidw> Hey everyone, I'm just getting started with Parsec, what's the difference between Text.Parsec and Text.ParserCombinators.Parsec?
11:43:41 <johnw> saeidw: I think one is where the module used to live
11:43:45 <migimunz> basically, a monad transformer is to monads what monads are to other types?
11:43:54 <migimunz> by other types, I mean regular ones, like Int
11:43:57 <jmcarthur> erisco: operationally, the Num constructor actually has a field (the dictionary corresponding to the Num instance for that type), so pattern matching on it actually brings an implicit value into scope
11:44:05 <erisco> jmcarthur, so in the scope of the expression associated with the pattern match (ie  pat -> expr) the type relationship is know
11:44:25 <pavonia> saeidw: The latter is the old version, still there for compatibility
11:44:35 <jmcarthur> erisco: something like that
11:44:40 <johnw> migimunz: I wouldn't say it that way, but monad transformers do nest other monads; I'm not sure if your statement is true enough
11:44:56 <erisco> jmcarthur, is this the only extension (GADTs) which does this? I have never seen this behaviour before
11:44:58 <saeidw> ah, so I should be using 'import Text.Parsec', the Parsec site wasn't very obvious about that :\
11:45:01 <johnw> for example, a monad transformer 't' instantiates at '(t m) a', and not 't (m a)'
11:45:11 <jmcarthur> erisco: actually, i only used ExistentialQuantification. no GADTs required
11:45:42 <migimunz> aha, interesting
11:45:47 <johnw> the latter would just be a monad applied to a monad; but that's not a transformer, any more than Maybe (Maybe a) is a transformer
11:45:52 <jmcarthur> erisco: it's not really different for "normal" existential types. it'
11:46:03 <jmcarthur> erisco: it's just a consequence of existential types most people don't realize
11:46:11 <johnw> But (Maybe Maybe) a (aka, MaybeT Maybe a), is
11:46:19 <jmcarthur> erisco: the interaction between existential types and type classes is just an interesting thing
11:46:40 <erisco> jmcarthur, I do not feel like I understand the general idea of what is going on
11:46:50 <jmcarthur> erisco: let's break it down then...
11:46:58 <migimunz> johnw, I think I see what you mean
11:47:06 <jmcarthur> erisco: let's look at just this, first:   data Dict a = Show a => Show | Num a => Num
11:47:08 <migimunz> just need to play around with some examples to get the feel for it
11:47:43 <johnw> and please forgive my use of the term "monad" in these statements; I'm trying to convey an idea, but I'm not using that word correctly here.  The monad is Maybe, not Maybe a
11:47:50 <jmcarthur> erisco: the constructor Num is only type safe to use when the a type parameter actually has an instance of Num. is that clear?
11:47:59 <erisco> jmcarthur, immediately what is different is that Show a => and Num a => are not constraining any field of the constructor. ie I would more typically expect  data Foo a = (Show a) => Foo a  or something
11:48:20 <jmcarthur> erisco: that is,  Num :: Dict Int   is legal, but   Num :: Dict ()  is not
11:48:57 <erisco> jmcarthur, okay, so Show can only construct (Show a) => Dict a  and Num can only construct  (Num a) => Dict a
11:49:03 <jmcarthur> erisco: right. the constraints are only about the type parameter, not about a value
11:49:10 <migimunz> johnw, why is Maybe a not a monad? Because it's a type constructor applied and not the type constructor itself?
11:49:14 <erisco> jmcarthur, this is a new feature existentialquantification adds?
11:49:21 <johnw> Monads have kind * -> *, Maybe a has kind *
11:49:40 <Guest87869> instance Monad Maybe where
11:49:54 <migimunz> I was about to say that Either has a kind * -> * -> * but then I remembered the instance definition
11:49:56 <ReinH> johnw: unforgivable :p
11:50:02 <alpounet> migimunz: an instance of the Monad typeclass "expects a type argument", as opposed to "Maybe a" which doesn't expect any type argument anymore
11:50:35 <erisco> jmcarthur, I would also ask, for example, how would I add a constructor which can only constrict  Dict Int?
11:50:39 <erisco> only construct*
11:50:46 <jmcarthur> erisco: yes. under the hood, GHC might represent this as   data Dict a = forall e. (a ~ e) => Show (ShowDict e) | forall e. (a ~ e) => Num (NumDict e)
11:50:57 <migimunz> so in the example either, are (Either a) and (Either) not monads, while (Either String) is, because it's * -> *?
11:51:00 <jmcarthur> erisco: you would need a GADT for that
11:51:15 <migimunz> sorry, I meant (Either a b)
11:51:19 <johnw> 'Either a' is a Monad
11:51:26 <migimunz> yeah, miswrote that one
11:51:32 <jmcarthur> erisco: actually, what i just wrote would also require GADTs. i just hit a little brain fart and can't figure out why this is legal with just ExistentialQuantification
11:51:44 <migimunz> thanks for the explanation guys!
11:52:10 <jmcarthur> erisco: maybe the constraint alone is sufficient to require existential quantification
11:52:50 <jmcarthur> erisco: i believe you can actually just imagine this as being the same as      data Dict a = Show (ShowDict a) | Num (NumDict a)
11:53:10 <jmcarthur> erisco: and existential quantification is indirectly responsible for actually adding those fields
11:53:16 <jmcarthur> erisco: (in a very operational sense)
11:53:38 <erisco> ie  newtype ShowDict a = ShowDict a; newtype NumDict a = NumDict a?
11:53:43 <benzrf> hmmm i need something to try writing w/ reactive-banana
11:54:00 <jmcarthur> erisco: no, I'm using ShowDict to represent the runtime dictionary representing the Show instance
11:54:19 <jmcarthur> erisco: e.g.    data ShowDict a = ShowDict { show :: a -> String }
11:54:29 <erisco> ah, okay
11:55:00 <ReinH> johnw: I'm going to give up on stackoverflow. I got into an argument with someone who thinks that all Functor instances pattern match on a data constructor to "unwrap" the f a into an "a" before "wrapping" it again.
11:55:11 <ReinH> johnw: and pointing at ((->) r) was insufficient to disuade them
11:55:12 <BacchanalianGeek> Hello everyone
11:55:14 <ReinH> I don't even.
11:55:15 <jmcarthur> erisco: normally that is hidden from you, but this is something like what ghc actually does with type classes under the hood. they become extra parameters to functions (and extra fields in data constructors, when existential types and type classes are mixed)
11:55:27 <awestroke> how do I nuke cabal and retry from scratch? I tried moving .ghc to .ghc.bak but cabal doesn't care, it seems (or the conflict is with system-wide packages, how do I know?)
11:55:45 <benzrf> hello BacchanalianGeek
11:55:46 <jmcarthur> erisco: so now we have a [Dict a], which we now know is actually a list of dictionaries
11:55:50 <benzrf> :t liftIO
11:55:51 <lambdabot> MonadIO m => IO a -> m a
11:55:54 <quchen> ReinH: You could also just give up on that person instead of SO in general.
11:56:01 <benzrf> h-huh
11:56:11 <quchen> I feel your anger though.
11:56:11 <benzrf> :t ove
11:56:12 <lambdabot>     Not in scope: ‘ove’
11:56:12 <benzrf> :t over
11:56:12 <lambdabot>     Perhaps you meant ‘over’ (imported from Control.Lens)
11:56:13 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:56:21 * benzrf cowers
11:56:37 <ReinH> quchen: or that
11:56:39 <erisco> jmcarthur, I am following so far
11:56:47 <ReinH> quchen: but this is not unusual for SO
11:56:49 <BacchanalianGeek> hey benzrf
11:57:01 <jmcarthur> erisco:    data Entity = forall a. Entity [Dict a] a   -- so this means that we are hiding the `a`, but constraining the [Dict a] to be talking about the same type
11:57:22 <jmcarthur> erisco: so this is legal:    Entity [Num, Show] (5 :: Int)
11:57:28 <saeidw> wow, so I guess the "Parser" type is gone, and there's this thing called ParsecT s u m a
11:57:31 <jmcarthur> erisco: but this is not:    Entity [Num] ()
11:57:39 <benzrf> saeidw: yep :\
11:57:41 <jmcarthur> erisco: with me so far?
11:57:46 <benzrf> welcome to modern haskell u_u
11:57:50 <quchen> ReinH: I'm sure that with sufficient refactoring, he'll be able to convince you that functions are boxes. :-þ
11:57:52 <saeidw> so looks like the tutorial on the Parsec site won't be too helpful, is there another well known resource I'm missing out on?
11:57:53 <benzrf> saeidw: it seems that the s is the thing it parses from
11:57:59 <erisco> jmcarthur, yes
11:58:10 <benzrf> saeidw: and the a is the result type
11:58:15 <benzrf> fuck if i know what the u and m are
11:58:19 <pavonia> saeidw: No, there are several Parser's now, depending on the type of the token stream
11:58:20 <benzrf> well m might be an MT
11:58:29 <benzrf> saeidw: but you can usually ignore everything but the a ime
11:58:31 <jmcarthur> erisco: now, when we pattern match on an Entity     (Entity dicts x -> ...)   ghc is aware of the relationship between dicts and x
11:59:01 <jmcarthur> erisco: and when we later pattern match on dicts    (Num:ds -> ...)   it is aware of the relationship between Num and x
11:59:22 <saeidw> hmm sounds ok, but do I need to understand monad transofrmers (that's what the T is, right?) before I get started with Parsec?
11:59:24 <jmcarthur> erisco: namely, Num actually has a hidden `NumDict a` field, where the `a` corresponds to the type of x
11:59:33 <benzrf> i googled 'ParsecT'
11:59:34 <benzrf> got:
11:59:35 <benzrf> ParsecT s u m a is a parser with stream type s , user state type u , underlying monad m and return type a .
11:59:45 <jmcarthur> erisco: so when you try to do Num operations on x, it just uses the field it secretly obtained by pattern matching
11:59:46 <benzrf> saeidw: no, you just need to understand monads
11:59:47 <benzrf> :-)
11:59:49 <saeidw> benzrf, yeah that's what hackage says too
12:00:07 <benzrf> saeidw: i have used parsec a little bit and the basic usage does not require any messing about with MTs
12:00:17 <benzrf> i think that's just there for if you want to use it
12:00:27 <benzrf> mts aren't that bad anyway
12:00:32 * hackagebot network-bitcoin 1.6.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.6.0 (ClarkGaebel)
12:00:35 <saeidw> that's great, 'cause I haven't got around to those yet :)
12:00:52 <erisco> jmcarthur, ah, so if I am wondering if the types will check, I can think about the operational requirement that the runtime has to somehow be accessing the class dict
12:01:04 <benzrf> saeidw: the basic idea of an MT type is that it takes an 'underlying monad' type as a parameter, in addition to the final 'result type'
12:01:08 <johnw> saeidw: needing the Parsec transformer is pretty rare
12:01:10 <erisco> and a pattern match is such a way for the runtime to access it
12:01:14 <benzrf> so instead of 'm a' you get 'mt m a'
12:01:15 <jmcarthur> erisco: yeah, for type classes it think the operational semantics of ghc is a reasonable proxy for this
12:01:28 <benzrf> then binding 'executes the monadic operations' for both monads
12:01:31 <jmcarthur> *i think
12:01:46 <benzrf> so you can put a StateT over a Maybe, and bind will both allow failure and pass state along
12:01:55 <jmcarthur> erisco: it at least gives good intuitions about why certain typing rules are justified
12:02:36 <benzrf> or you could put a ParsecT over IO, and do IO whilst parsing
12:02:36 <saeidw> benzrf, that sounds really cool actually
12:02:41 <benzrf> it is pretty handy
12:02:43 <benzrf> kinda messy though :I
12:03:29 <erisco> jmcarthur, now ideally I have to figure out a way to make Dict open, ie not closed
12:03:34 <benzrf> the basic idea is that instead of implementing basic bind, you write a version of bind that binds the contents of the value, then does the monad-specific bind stuff
12:03:39 <benzrf> ok wow that was completely unintelligable
12:03:51 <benzrf> saeidw: but what i mean is
12:04:09 <benzrf> in a normal Maybe monad, the impl examines the data constructor and does something based on what it is
12:04:20 <saeidw> sure
12:04:24 <benzrf> in a MaybeT, the impl would bind the value, then operate on the Maybe inside it
12:04:27 <erisco> jmcarthur, but that'll be my target practise for what you have just shown me. thanks
12:04:30 <benzrf> i.e.
12:04:57 <benzrf> m >>= f = m >>= subbind
12:05:01 <jmcarthur> erisco: i'm not sure you can make it open, unfortunately
12:05:02 <benzrf>   where subbind Nothing = return Nothing
12:05:05 <benzrf> etc
12:05:15 <saeidw> ah, so it just sort of wraps the original bind
12:05:18 <benzrf> right
12:05:23 <saeidw> and does something else first before calling it?
12:05:29 <benzrf> something along those lines
12:05:31 <benzrf> depends on the Mt
12:05:32 <benzrf> *MT
12:05:46 <BacchanalianGeek> In your learned opinion, how has Haskell developed to support mobile apps? I know there's a stackoverflow thread that scvalex answered to back in Dec `12, where (s)he indicated that there wasn't a lot going on in that direction
12:05:57 <srhb> BacchanalianGeek: Not very.
12:05:59 <benzrf> most MTs come in newtype wrappers because it tends to be that the transformer monad (i.e. Maybe) is the value inside the other one
12:06:09 <benzrf> so you need to wrap it to prevent it from using the monad instance from the submonad
12:06:30 <benzrf> i.e. if i have '[Just 1, Just 2, Nothing]', i want to use my MaybeT instance, not the list instance
12:06:34 <benzrf> so i need to stick it in a newtype
12:07:57 <honza> how can i filter out all Nothings from a [Maybe a]?
12:08:08 <honza> mfilter, filterM, sequence are failing me
12:08:22 <benzrf> honza: no need for monads here
12:08:25 <benzrf> just use 'filter isJust'
12:08:29 <benzrf> :-)
12:08:43 <benzrf> sequence would be for if you want to drop it if there are any Nothings
12:08:55 <jmcarthur> honza: Data.Maybe.catMaybes
12:09:10 <benzrf> honza: catMaybes if you then want to unwrap the Justs
12:09:22 <honza> benzrf: welp, awesome, thanks!
12:09:32 <jmcarthur> honza: or   [ x | Just x <- xs ]
12:09:37 <honza> i often overthink things
12:10:18 <srhb> honza: If you knew about filter, maybe you could have thought like "is there a function that given a Maybe a returns True iff the value is a Just something..."
12:10:23 <srhb> @hoogle Maybe a -> Bool
12:10:24 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
12:10:24 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
12:10:24 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
12:11:03 <honza> yeah, i was looking for a special kind of filter to work with a list of monadic values
12:11:12 <srhb> Right. :)
12:11:21 <awestroke> > fromJust Nothing
12:11:22 <lambdabot>  *Exception: Maybe.fromJust: Nothing
12:12:37 <ReinH> quchen: "What you are suggesting is literally impossible." "But..."
12:14:54 <quchen> ReinH: I don't know the point he's making, but for what it's worth I still find picturing stuff that way for my understanding. Particularly for Reader, "extract, apply, pack" works out as well. https://github.com/quchen/articles/blob/master/reader_instance_derived.md#bind
12:15:49 <quchen> I know it's wrong and maybe misleading for beginners, but it was (and is) helpful for me to think of things this way.
12:16:06 <ReinH> quchen: this was in the context of explaining (>>=) as 'unwrapping and rewrapping' a monad...
12:16:52 <ReinH> quchen: I get the "functors as containers" thing. It's even reasonable to think of (a -> b) as containing b's indexed by a's.
12:17:13 <quchen> ReinH: Oh, he means >>= is literally unwrapping things every time
12:17:29 <bitemyapp> quchen: I'll shift the examples into Haddock later.
12:17:44 <bitemyapp> quchen: for now, it was more important to just have API examples + basic types in Haddock.
12:17:44 <quchen> bitemyapp: Oh hey. Sounds awesome :-)
12:18:06 <bitemyapp> there's actually a lot documentation, it's just not in Haddock because I'm used to people wanting the docs in Github.
12:18:16 <bitemyapp> so...it was all in the README, but people griped about that.
12:18:20 <bitemyapp> so I'll move it over.
12:18:35 <bitemyapp> This process happens faster if people use the library :P
12:19:28 <quchen> bitemyapp: I wasn't just asking about the API doc though. Suppose I want to modify some code -- in the current state I have to read a giant load of code to get to understand it.
12:19:40 <bitemyapp> quchen: are you sure about that?
12:19:45 <benzrf> saeidw: http://bpaste.net/show/259037
12:19:50 <bitemyapp> quchen: it might look scary, but most of it is the same pattern repeated over and over
12:20:02 <bitemyapp> quchen: it's all ToJSON, ADTs are representing different kinds of queries and filters
12:20:10 <benzrf> saeidw: try importing that into GHCi and messing w/ it
12:20:28 <benzrf> wait shit i forgot return
12:20:29 <benzrf> saeidw: 1 sec :P
12:20:33 <Eduard_Munteanu> Is there a MonadPlus instance for ResourceT somewhere?
12:20:41 <Eduard_Munteanu> I'm not sure it's easy to write.
12:20:53 <quchen> bitemyapp: Sure, but even then you should at least have a module header saying "this is just back-and-forth conversion stuff". That's one sentence to save you from opening the file, scrolling around, theorizing about the common thing, verifying your theory.
12:21:04 <bitemyapp> quchen: yep, it'll get added.
12:21:11 <bennofs> Eduard_Munteanu: Should be easy to write, ResourceT is just ReaderT Something
12:21:20 <benzrf> saeidw: https://gist.github.com/anonymous/55695c6c039cd3231d2b
12:21:23 <quchen> Sounds good then. :-)
12:21:49 <Eduard_Munteanu> bennofs: yeah, but I guess I have to import the internal module
12:21:54 <bitemyapp> quchen: put differently, docs were designed for end-users. I didn't anticipate anyone wanted to change the library.
12:22:02 <quchen> Maybe I was in a bit of a bad mood when I wrote that comment, it didn't come over particularly friendly. If so, I apologize. I'm still behind what it essentially said though.
12:22:04 <bitemyapp> anyone wanting*
12:22:06 <saeidw> benzrf, thanks I'll push it into ghci and see what happens :)
12:22:16 <bitemyapp> quchen: sure. I want feedback regardless.
12:22:31 <bitemyapp> quchen: but we should go easy on people that make things and release them. This isn't an easy process for a lot of people.
12:22:36 <quchen> bitemyapp: To name a user that's not you who will maybe want to change the library: you in 3 months. :-)
12:22:48 <bitemyapp> quchen: Bloodhound was more work than most libraries I've made.
12:22:52 <benzrf> saeidw: there is also the MonadTrans __class__
12:22:53 <benzrf> *class
12:23:17 <benzrf> saeidw: it has the 'lift' method, which takes an `m a` and turns it into a `t m a`
12:23:20 <saeidw> ah so to implement a monad transformer "traditionally", you create an instance of that?
12:23:21 <benzrf> :t lift
12:23:21 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:23:27 <benzrf> no
12:23:35 <benzrf> MonadTrans is just a utility
12:23:48 <benzrf> for example, if you have a (MaybeT IO String)
12:24:15 <benzrf> where binding executes an IO action resulting in a Maybe String, then binds on the Maybe (more or less)
12:24:23 <benzrf> and you want to insert a regular IO String into it
12:24:30 <benzrf> you can use 'lift' to push an IO String into a MaybeT IO STring
12:24:37 <benzrf> it's like return, but only 1 level instead of 2
12:24:55 <saeidw> yeah, sounds like return to me
12:25:03 <benzrf> return would take a String and make a MaybeT IO String
12:25:22 <benzrf> remember, MaybeT IO String doesn't produce IO String's
12:25:24 <benzrf> it produces Strings
12:25:38 <benzrf> hence, you'd return a String into it, not an IO String
12:25:43 <benzrf> you need lift to put an IO String in
12:26:42 <benzrf> anyway, MaybeT IO String could be useful for something like a series of inputs, where a user can choose to stop responding
12:26:47 <benzrf> at which point the whole thing terminates in Nothing
12:27:34 <benzrf> the main problem with monadts IME is that you end up doing a lot of boilerplate type wrapping and unwrapping
12:27:37 <benzrf> which is pretty annoying
12:28:19 <saeidw> yeah, in the example I have to keep track of what's being returned when reading the implementation of >>=
12:28:24 <benzrf> same here
12:29:01 <benzrf> the main upside of monad transformers is that they let you arbitrarily nest
12:29:02 <saeidw> but I do see the general pattern of wrapping another monadic value, providing the same monad interface
12:29:04 <benzrf> for example!
12:29:14 <benzrf> i wrote a toy lisp implementation a while back
12:29:30 <benzrf> almost all of it was in an IO/State/Either monad
12:29:46 <benzrf> so that the interpreted program could perform IO, access the state, or raise an error at any time
12:30:45 <benzrf> i used lenses rather poorly & unnecessarily in that
12:30:49 <benzrf> but it was fun to write :-)
12:31:45 <saeidw> lens, coduit, and pipes are on my Big List of Things To Know, but I never find time to get to them
12:31:49 <benzrf> mmm
12:31:56 <benzrf> i sort-of-know lems
12:31:57 <benzrf> *lens
12:32:09 <jophish> saeidw: there's a nice introduction talk by SPJ on lens
12:32:10 <benzrf> i went on a week-long binge of absorbing as much as i could
12:32:11 <saeidw> but I bet that when I do, it'll be awesome and I'll realize I could have done things so much better
12:32:14 <benzrf> but most of it has fallen out of my head
12:32:22 <benzrf> ive been looking into pipes lately
12:32:28 <benzrf> it seems /fairly/ straightforward
12:32:32 <benzrf> but i dont know shit about conduit
12:32:54 <johnw> sourceKnowledge $$ sinkMind (Person "benzrf")
12:33:00 <benzrf> :(
12:33:02 <benzrf> :t ($$)
12:33:03 <lambdabot> Doc -> Doc -> Doc
12:33:08 <benzrf> wuh
12:33:14 <benzrf> :i DOc
12:33:15 <johnw> $$ binds a source and a sink, so that elements flow from left to right
12:33:17 <benzrf> wait.
12:33:19 <benzrf> oh
12:33:29 <benzrf> in what now?
12:33:40 <johnw> conduit!
12:33:41 <benzrf> how does conduit compare to pipes
12:34:08 <johnw> conduit = pipes + leftovers + knowledge of upstream termination + built-in deterministic finalization
12:34:32 <johnw> pipes + StateT + FreeT + Maybe = conduit, roughly
12:34:41 <benzrf> what the hell is freet
12:34:47 <johnw> the free monad transformer
12:34:50 <saeidw> lol, I was about to ask that :p
12:34:50 <benzrf> erm
12:34:51 <johnw> think of "lists of effects"
12:34:54 <benzrf> i never really learned free moands
12:34:55 <benzrf> >_>
12:34:57 <benzrf> *monads
12:35:05 <ocharles> goldfire: hey, just got your message - still free?
12:35:21 <saeidw> oh wait, I know what a free monad does, but never understood their practicality
12:35:36 * hackagebot codex 0.0.2 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.0.2 (aloiscochard)
12:35:38 <saeidw> it lets you "evaluate" your program in whatever kind of context you want
12:35:41 <benzrf> recently ive found myself mostly thinking of monad implementations in terms of join
12:35:44 <benzrf> o:
12:35:58 <Eduard_Munteanu> saeidw: more like it lets you unwind a computation step by step
12:36:01 <benzrf> also how the fuck can arrows be more powerful than monads, they seem barely related o-o
12:36:02 <ocharles> benzrf: I really like that way of thinking about them - I find them a natural extension of Functor then
12:36:09 <johnw> a free monad suspends the meaning of >>=, the same way that a free monoid suspends the meaning of <>
12:36:16 <benzrf> i uh
12:36:20 <benzrf> dont know free monoids ither
12:36:21 <benzrf> *either
12:36:25 <johnw> free monoids are lists
12:36:25 <Eduard_Munteanu> benzrf: Kleisli m for Monad m is an Arrow.
12:36:34 <benzrf> u-uh
12:36:35 <goldfire> ocharles: sure
12:36:38 <benzrf> i do not know these things
12:36:39 <benzrf> u_u
12:36:39 <johnw> 1 + 4 = 5, but [1] <> [4] = [1,4].  Which then lets you apply + later
12:36:47 <ocharles> goldfire: cool, maybe move to PM?
12:36:49 <benzrf> none of this helps me
12:36:56 <johnw> so, free monads let you apply a different >>= later
12:36:57 <MitchellSalad> benzrf: -__- ^__^ =D =D =D >__< @_@ ~~~ !!!!
12:36:57 <benzrf> oh wait i think i might see
12:37:00 <johnw> ok, I'll leave it there :)
12:37:10 <benzrf> so
12:37:22 <benzrf> basically, a free x takes the x operation and logs the operands
12:37:27 <johnw> yes!
12:37:28 <benzrf> so that later you can substitute in a meaningful x op
12:37:31 <benzrf> cool
12:37:53 <johnw> a free object fulfills the laws without giving you anything else
12:37:58 <Eduard_Munteanu> benzrf: more generally, if Monads are computations with structured output ('a -> m b'), Arrow generalizes the arrow to an arbitrary type function.
12:38:14 <benzrf> Eduard_Munteanu: i dont understand what that means
12:38:16 <Eduard_Munteanu> benzrf: if you know about CoKleisli and BiKleisli, they're also arrows
12:38:16 <johnw> + fulfills the laws of monoids, but also gives you summation
12:38:35 <benzrf> Eduard_Munteanu: i don't know any of those things
12:38:39 <benzrf> ¬_¬
12:39:52 <Eduard_Munteanu> benzrf: CoKleisli is 'w a -> b' for 'w' a Comonad. BiKleisli is a combination of a monad and comonad, it looks like 'w a -> m b'.
12:39:59 <MitchellSalad> benzrf: you asked
12:40:19 <MitchellSalad> benzrf: you asked 'how the fuck are arrows related to monads', at least try to listen to what the man is telling you =)
12:40:23 <benzrf> i am trying
12:40:25 <saeidw> benzrf: I learned about free monads from this tutorial: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
12:40:25 <benzrf> but i dont understand
12:40:26 <benzrf> :(
12:40:35 <benzrf> i do not know comonads either
12:40:40 <saeidw> it was an 'aha!' moment, but now I vaguely remember it
12:40:43 <Eduard_Munteanu> Ah.
12:40:50 <benzrf> i'm kiiiiiinda a newb
12:40:52 <benzrf> :|
12:41:03 <MitchellSalad> benzrf: aren't we all
12:41:15 <edwardk> Eduard_Munteanu: note: Bikleisli ith a distributive law is almost never what you want
12:41:17 <johnw> benzrf: "BiKleisli" is a term that I bet about 99% of this channel would be uncomfortable with
12:41:28 <benzrf> phew
12:42:05 <Eduard_Munteanu> edwardk: yeah, you've told me it sucks compared to (co)monad transformers over (co)kleisli
12:42:59 <benzrf> hmm edwardk what is your actual job
12:43:07 <MitchellSalad> mcgraw hill yo
12:43:25 <lispy> benzrf: he makes libraries so that we don't have to :)
12:43:33 <benzrf> i am aware of this
12:43:58 <lispy> (I don't know how else to describe what he does...)
12:44:21 <heatsink> edwardk: You linked some lecture notes about static-to-dynamic transformations.  The notes explain efficient persistent data structure algorithms.  What does "static" and "dynamic" mean in this context?  The notes don't explain.
12:44:30 <benzrf> i meant how does he accumulate money for not dying purposes
12:45:12 <lispy> benzrf: the company he works for is into finance. He does the same for them that he does for us. reseaches stuff and makes cool libraries out of it.
12:45:32 <benzrf> man i hope i get a job like that someday
12:45:45 <benzrf> im terrified ill end up as a code monkey
12:45:45 <benzrf> :(
12:46:10 <lispy> The standard path to avoiding code monkey status is graduate school.
12:46:15 <benzrf> hmmm
12:46:24 <benzrf> i have considered that i might like to go into academia
12:46:28 <benzrf> but i hear it doesnt pay so great
12:46:57 <saeidw> I'm a code monkey, the code is aweful but it makes people happy
12:47:00 <joelteon> being a code monkey can be cool depending on what tree you live in
12:47:11 <saeidw> and every once in a while, I get to do something cool and cutting edge
12:47:16 <lispy> You should thinking of graduate school as apprenticing under a more experienced researcher. With a masters people will see you like an advanced undergraduate, possible with a focus area. With a PhD you'll be seen as trusted to do your own explorations.
12:47:49 <benzrf> i enjoy actual programming too much though :(
12:48:48 <lispy> benzrf: what really matters here is the perception that others have for your abilities. If they trust you to do explorations you can usually negotiate to do that as part of your job.
12:48:52 <benzrf> hmmmmm
12:49:36 <lispy> If you can build a rock solid portfolio that shows you can be trusted then you'll have a much easier time.
12:50:24 <lispy> If they see you as just another undergrad straight out of college, you'll be labeled as junior and you won't get much freedom until you prove yourself.
12:52:49 <Ralith> portfolio is everything
12:52:59 <Eduard_Munteanu> Is there a way to get ghci to load modules for which the cabal file provides default LANGUAGE pragmas, if cabal repl isn't available (1.16)?
12:53:26 <lispy> Eduard_Munteanu: cabal-dev might work for that
12:53:39 <lispy> Eduard_Munteanu: it has a ghci command
12:53:46 <eikke__> Eduard_Munteanu: doesnt using ":set -X..." in ghci help?
12:53:50 <Eduard_Munteanu> Thanks, I'll try it.
12:54:15 <Eduard_Munteanu> eikke__: the code in said modules requires those extensions, not just what I'm typing at the command line
12:54:25 <benzrf> i have written 1 or 2 extremely unfinished ruby gems
12:54:26 <Eduard_Munteanu> And I'd rather not specify them every time.
12:54:29 <lispy> yeah, I wouldn't expect that to work
12:54:34 <benzrf> thats my portfolio
12:54:38 <eikke__> Eduard_Munteanu: put it in .ghci ;)
12:55:17 <Eduard_Munteanu> Hm, I think I'll go with that.
12:57:00 <lispy> benzrf: sounds like you have a long ways to go before you have edwardk's reputation :)
12:57:13 <Eduard_Munteanu> Mmm... can ghci use cabal-built modules directly?
12:57:35 <lispy> Eduard_Munteanu: it's all a matter of getting the options to ghci set correctly
12:57:39 <edofic> rd_Munteanu: put it
12:57:40 <jophish> How is defaulting affected when using a custom numeric hierarchy?
12:57:46 <Eduard_Munteanu> Actually forget that, I have to expose said modules.
12:57:47 <lispy> Eduard_Munteanu: like -package-db and -X flags
12:57:48 <edofic> alias ghci-sandbox="ghci -package-db .cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d/"
12:58:04 <edofic> modify for your arch
12:58:11 <byorgey> jophish: defaulting and custom numeric hierarchies can't work together, unfortunately
12:58:18 <jophish> byorgey: I thought as much
12:58:22 <byorgey> defaulting only applies to certain built-in classes
12:58:30 <jophish> yeah, that's what I thought the problem would be
12:58:50 <jophish> I'm surprised that there isn't an extension for that though
12:58:50 <lispy> byorgey: What about with the extended defaulting extension?
12:59:35 <Eduard_Munteanu> I get 'unknown symbol' errors if I don't expose certain modules, any idea why?
12:59:43 <byorgey> extended defaulting only changes the rules by which defaulting is applied, it does not change which type classes it applies to
13:00:20 <lispy> byorgey: gotcha
13:00:21 <Eduard_Munteanu> ghci -idist/build -package-db dist/package.conf.inplace
13:00:56 <lispy> byorgey: BTW, I've been reading software foundations. Thanks for coauthoring that!
13:01:12 <byorgey> lispy: cool, you're welcome =)
13:01:19 <byorgey> lispy: how's it going?
13:05:40 * hackagebot epub-metadata 4.1 - Library for parsing epub document metadata  http://hackage.haskell.org/package/epub-metadata-4.1 (DinoMorelli)
13:07:37 <fredmorcos> hello, newbie here... So I wrote my own definition of a parser: type ParserRes a p b = Either (ErrorMessage, p) (b, [a], p)  --  data Parser a p b = Parser ([a] -> p -> ParserRes a p b)
13:07:53 <fredmorcos> ErrorMessage is a string
13:08:08 <fredmorcos> and made my parser an instance of Monad to get all the do-notation sweets
13:08:32 <benzrf> what is p
13:08:36 <benzrf> and a, and b
13:08:37 <benzrf> :P
13:08:39 <fredmorcos> :)
13:08:49 <lispy> byorgey: prety good. I applied for OPLSS but I didn't hear back yet. I don't see your name on the list of lecturers, but any chance you'll be there as an organizer?
13:08:58 <fredmorcos> a parser from a to b using p as positioning
13:09:04 <benzrf> ah
13:09:05 <fredmorcos> ie, (Line, Col)
13:09:23 <benzrf> þ
13:10:04 <fredmorcos> but now with GHC 7.8 there's a warning about 7.10 where instances of Monads have to be instance of Applicative as well.. which is fine
13:10:23 <fredmorcos> but I'm having a bit of trouble wrapping it around my head... i defined <*> in terms of ap
13:10:31 <fredmorcos> f1 <*> f2 = f1 `ap` f2
13:10:35 <benzrf> fredmorcos: ok
13:10:59 <fredmorcos> which violates the fact that something has to be an Applicative _BEFORE_ being a Monad
13:11:16 <fredmorcos> which brings me to my question
13:11:30 <Guest87869> eh?
13:11:43 <Guest87869> you can make applicative out of a monad
13:11:56 <srhb> fredmorcos: By the same logic, every Monad is an Applicative.
13:12:02 <quchen> There is no concept of "before" in class hierarchies. It's more of an "is also" thing. It doesn't happen which one is "before" as long as all necessary parent classes are there.
13:12:22 <heatsink> I guess fredmorcos is referring to the Applicative context of the new Monad class
13:12:30 <fredmorcos> heatsink, yes
13:12:52 <fredmorcos> my understanding is Functor => Applicative => Monad
13:12:56 <fredmorcos> and maybe some stuff in between
13:12:58 <srhb> Right.
13:13:06 <fredmorcos> but Functor is a parent of Applicative which is a parent of Monad
13:13:09 <heatsink> You know how you can define mutually recursive functions, right?
13:13:22 <quchen> In order to be an Applicative, you also have to be a Functor. But that doesn't forbid you from defining the Applicative, and then the Functor in terms of it. In the end, all is checked that all Applicatives are also Functors, which is the case no matter in which order you define them.
13:13:31 <fredmorcos> so all Applicatives are functors, right? and all Monads are Applicatives AND Functors
13:13:38 <srhb> The example with mutual recursion is good
13:13:42 <benzrf> fredmorcos: yes
13:13:44 <Guest87869> yeah and you dont even need to write implementations
13:13:48 <srhb> One function can depend on another, which can depend on the first.
13:13:48 <heatsink> let {evens (x:xs) = x : odds xs; evens [] = []; odds (x:xs) = odds xs; odds [] = []} in evens [0, 1,2,3, 4]
13:13:51 <heatsink> > let {evens (x:xs) = x : odds xs; evens [] = []; odds (x:xs) = odds xs; odds [] = []} in evens [0, 1,2,3, 4]
13:13:53 <lambdabot>  [0]
13:13:56 <intrados> Anyone know of a tree-based HTML library that's more modern than Text.Html and less hostile to tree inspection than Blaze?
13:14:03 <benzrf> fredmorcos: but <*> will not automatically be defined in ap because haskell cannot do that
13:14:08 <Guest87869> oh
13:14:11 <heatsink> > let {evens (x:xs) = x : odds xs; evens [] = []; odds (x:xs) = evens xs; odds [] = []} in evens [0, 1,2,3, 4]
13:14:13 <lambdabot>  [0,2,4]
13:14:27 <benzrf> heatsink: those braces are redundant fyi
13:15:10 <Fuco> are there some built-in combinators like (a -> b) -> (x -> y -> z -> ...) -> x -> y -> z -> ... -> b ... that is, combining an n-ary function with unary?
13:15:18 <fredmorcos> is that recursive definition applicable theoretically as well?
13:15:30 <heatsink> Ok.  I haven't learned all the brace-and-semicolon rules.
13:16:32 <edofic> Fuco, you can use ((.).(.))
13:16:38 <quchen> fredmorcos: Take it to an extreme, and don't implement any class functions at all, like so: http://lpaste.net/103592 -- This typechecks and everything. It is not inspected whether the definitions make sense at all. Everything that's required by "Applicative MyType" is that somewhere, there's a "Functor MyType" instance.
13:16:38 <erisco> Fuco, not that I know of.
13:17:01 <hexagoxel> adding a Debug.Trace.trace call creates a memory leak in my application, effectively adding a problem instead of (helping) removing one :(
13:17:09 <Guest87869> :t (.:)
13:17:10 <lambdabot>     Not in scope: ‘.:’
13:17:10 <lambdabot>     Perhaps you meant one of these:
13:17:10 <lambdabot>       ‘.’ (imported from Data.Function),
13:17:14 <Guest87869> :t (:.)
13:17:15 <lambdabot>     Not in scope: data constructor ‘:.’
13:17:15 <lambdabot>     Perhaps you meant one of these:
13:17:15 <lambdabot>       ‘:+’ (imported from Data.Complex),
13:17:16 <Fuco> edofic: yea, I've defined one like that myself
13:17:18 <quchen> fredmorcos: As a next step, replace the 'undefined' with whatever implementations you feel like and that are in scope. Setting "(<*>) = ap" certainly doesn't make things more undefined. :-)
13:17:40 <lispy> fredmorcos: search for "instance Applicative Maybe" http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Applicative.html#%3C%2A
13:17:56 <byorgey> lispy: nope, I'm finishing my dissertation and moving this summer, no time to come hang out in Oregon unfortunately
13:18:08 <fredmorcos> I already am looking Maybe :)
13:18:22 <byorgey> lispy: OPLSS is really awesome though, hope you get in (I expect you will)
13:18:24 <lispy> byorgey: moving? Do you already have a postdoc or tenure track thing lined up?
13:18:27 <fredmorcos> but I thought it was due to the fact that previous to 7.10, Applicative was not a parent class of Monad
13:18:56 <byorgey> lispy: I have a 1-year visiting assistant prof position at http://www.williams.edu/
13:19:26 <lispy> byorgey: congrats!
13:19:33 <byorgey> thanks =)
13:19:33 <fredmorcos> OK then.. thanks guys!
13:19:41 <quchen> fredmorcos: Now take it to an extreme and define the things all scrambled up, like this: http://lpaste.net/103593 -- Still works.
13:20:12 <Guest87869> > undefined == undefined
13:20:13 <lambdabot>  *Exception: Prelude.undefined
13:20:40 <fredmorcos> so only class membership is checked
13:20:54 <fredmorcos> *typeclass
13:21:33 <quchen> Yes. When GHC sees "Applicative", it just checks whether there's also a Functor instance. It doesn't check how that is defined or anything of the likes.
13:21:48 <fredmorcos> but it wouldn't be possible to implement ie fmap in terms of >>= and >>= in terms of fmap, correct?
13:22:01 <lispy> yeah, that could get you into trouble
13:22:12 <fredmorcos> OK so it's clear now
13:22:14 <bennofs> fredmorcos: it would result in a runtime infinite loop
13:22:19 <quchen> That is going to be an infinite loop. But the compiler won't complain.
13:22:23 <fredmorcos> no more magical GHC capabilities :)
13:22:40 <Guest87869> except for the <<loop>> error at runtime ;
13:22:55 <quchen> If we're lucky 7.10 will be able to solve the Halting problem, depending on how fast development goes ;-)
13:22:57 <lispy> fredmorcos: in Eq, (==) has a default definition in terms of (/=) and (/=) has a default in terms of (==). As a result if you make an Eq instance without giving either (==) or (/=) then your program will loop inifinitely at runtime when you call (==) or (/=).
13:23:00 <fredmorcos> so I have been scratching my head at how to implement <*> for my parser without using ap
13:23:08 <bjorkintosh> why does cabal's connection time out at all?
13:23:30 <fredmorcos> lispy, in that case you need to provide at least one or the other
13:23:33 <fredmorcos> it's clear
13:23:33 <lispy> fredmorcos: liftA2 id :)
13:24:03 <fredmorcos> well is saw how ap is implemented as liftM2 id
13:24:09 <fredmorcos> but i don't have the intuition for it
13:24:12 <fredmorcos> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:24:17 <bennofs> lispy: yay for GHC 7.8 MINIMAL pragma :)
13:24:28 <fredmorcos> f (a -> b)
13:24:47 <fredmorcos> well first, ill look at >>=
13:24:50 <byorgey> fredmorcos: for a parser, typically (<*>) is implemented by running the first parser, which produces a function, then running the second parser, which produces a value, and finally returning the result of the function applied to the value
13:25:13 <bennofs> @let instance Eq Test
13:25:14 <lambdabot>  .L.hs:144:10: Warning:
13:25:14 <lambdabot>      No explicit implementation for
13:25:14 <lambdabot>        either ‘==’ or ‘/=’
13:25:14 <lambdabot>      In the instance declaration for ‘Eq Test’
13:25:14 <lambdabot>  
13:25:25 <heatsink> Oh, MINIMAL looks useful
13:25:38 <heatsink> loops are annoying to debug
13:25:49 <benzrf> MINIMAL?
13:25:56 <heatsink> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#minimal-pragma
13:26:00 <fredmorcos> byorgey, my problem is with the part where the parser produces a function...
13:26:02 <lispy> fredmorcos: if you implement <*> in terms of the other Applicative definitions you'll just end up chasing your tail. At some point you'll have to go to the definition of your type and use its constructors.
13:26:31 <byorgey> fredmorcos: what's the problem?
13:26:43 <fredmorcos> well look at >>=:   f1 >>= f2 = Parser $ \i p -> runParser f1 i p >>= (\(x, r, p') -> runParser (f2 x) r p')
13:27:16 <fredmorcos> (Parser p1) --> p1 is already a function
13:28:17 <fredmorcos> the >>= used here is the Either >>=
13:28:27 <fredmorcos> i write poop code
13:28:33 <byorgey> fredmorcos: sure, since parsers are represented as functions of a certain type.  But if  (Parser p1) has type  Parser (a -> b),  it means that when you "run" it (by applying it to some input), it will produce a value of type  (a -> b)
13:28:54 <byorgey> fredmorcos: how is your Parser type defined?
13:29:15 <fredmorcos> type ParserRes a p b = Either (ErrorMessage, p) (b, [a], p)  --  data Parser a p b = Parser ([a] -> p -> ParserRes a p b)
13:29:29 <fredmorcos> p is a position argument
13:29:49 <fredmorcos> parser from a to b
13:30:42 * hackagebot shake 0.11.6 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.6 (NeilMitchell)
13:31:48 <heatsink> Seems like the number of Hackage downloads has really gone up recently
13:32:28 <byorgey> fredmorcos: OK, so suppose you have something of type  ParserRes a p (b -> c).  If you apply it to a list of a's and a position, you'll get a value of type  ParserRes a p (b -> c), which is either an error message, or a triple containing *a function* of type  b -> c, as well as a remaining list of a's and a position
13:32:53 <byorgey> you save that b -> c  function, and then input the remaining a's into the second parser, which will produce a value of type b.  Then apply the function to the value.
13:33:15 <fredmorcos> clearer
13:33:22 <fredmorcos> OK
13:34:39 <fredmorcos> i'll work on it
13:34:43 <fredmorcos> thanks byorgey !
13:35:43 <lispy> fredmorcos: if you want a simpler example to practice on you could define your own state function/applicative/monad.
13:35:50 <vanila> newtype ReadP a = R (forall b . (a -> P b) -> P b)
13:35:52 <lispy> functor*
13:36:08 <vanila> does anyone know what the forall b is for? can you implement ReadP without forall?
13:36:32 <lispy> vanila: if you didn't have the forall there, where would you put it?
13:36:43 <fredmorcos> Right (func, remainder, pos)  and Right (val, remainder2, pos2) and results in Right (func val, remainder2, pos2)
13:36:50 <fredmorcos> or remainder' and pos'
13:36:50 <pranz> vanila: the forall is there so the data type isn't "ReadP a b"
13:37:17 <vanila> I mean what is the reason for it in the implementation of ReadP
13:37:18 <masylum> hi there
13:37:22 <lispy> pranz: oh sure, just give the answer away :)
13:37:49 <fizruk> vanila: if you put b in parameter, you can implement <*>, I guess
13:37:53 <ocharles> If anyone can figure out how to abstract the recursive call in this, I owe you a cold beverage of your choice:
13:37:56 <ocharles> https://www.irccloud.com/pastebin/ONOPiImB
13:37:57 <lispy> vanila: the `a` effectively has a forall on it as well.
13:38:02 <fizruk> vanila: “can’t"
13:38:07 <ocharles> The types keep changing and I can't work out how to abstract it :(
13:38:23 <shachaf> whoa, ReadP is Codensity P
13:38:30 <shachaf> I didn't know they used that in base.
13:38:36 <ocharles> https://gist.github.com/ocharles/2321ec2c37b517dca6af is the whole code, if anyone wants to try
13:38:49 <ocharles> Only needs GHC 7.8, no other dependencies
13:39:32 <vanila> How is codensity different from continuations? What is ti?
13:39:38 <monochrom> vanila: it seems to be setting up for continuation passing style. since we want to allow more freedom for the continuation, we put forall there for the continuation's type
13:40:26 <fizruk> ocharles: tried <|> there (don’t know if that can be applied)?
13:40:31 <shachaf> This type is related to continuations in all sorts of ways.
13:40:43 * hackagebot hourglass 0.1.1 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.1.1 (VincentHanquez)
13:40:47 <ocharles> fizruk: I don't have anything I can use <|> with
13:40:55 <shachaf> "Codensity" would be the word to look up to learn more about it.
13:40:58 <fizruk> vanila: Cont r = Codensity (Const r)
13:42:10 <fredmorcos> is it possible to pass a constraint, something like: data Parser a p b = Positionable p => Parser ([a] -> p -> ParserRes a p b)?
13:42:12 <erisco> jmcarthur, it would be nice to at least have a structure more efficient than [Dict a]
13:42:16 <erisco> jmcarthur, for lookups
13:42:24 <fredmorcos> where a Positionable would implement an "updatePosition" function
13:42:51 <fredmorcos> instead of passing it around to all the parser helpers like satisfy, satisfyMany, etc...?
13:42:54 <shachaf> That syntax is meaning in GHC but it may or may not be the meaning you're going for.
13:43:23 <erisco> jmcarthur, alas Set (Dict a) does not seem to work because Set.member Num dicts fails type check
13:43:27 <fredmorcos> shachaf, me?
13:44:00 <shachaf> Yes.
13:44:12 <vanila> What is the freedom for the continuation?
13:44:13 <fredmorcos> OK, so it probably doesn't mean what I think it means
13:44:28 <erisco> jmcarthur, it seems that a special exception is made for pattern matching so that Num:_ and Show:_ can match [Dict a] because typically it would be a type error
13:44:40 <albeit> I have a working program using Aeson, and I want to check that it is proper Haskell. If anyone wouldn't mind looking at it... http://lpaste.net/103594. Particularily, parseContents feels verbose and repetitive.
13:44:45 <shachaf> vanila: For instance, you can't write callCC for this type.
13:44:46 <erisco> jmcarthur, given that Num :: (Num a) => Dict a  and Show :: (Show a) => Dict a
13:44:50 <jmcarthur> erisco: yeah you would need to use a Map instead of a Set and have some key you can use to look up the dict
13:45:04 <jmcarthur> erisco: that way you aren't trying to construct one but instead just pattern match on the one you get back
13:45:39 <jmcarthur> erisco: the type error is just because it can't tell that Num or Show are valid without the pattern match. it's not a special exception
13:46:02 <vanila> maybe I could use P a instead of ReadP a, would it be the same?
13:46:07 <erisco> jmcarthur, though at this point because of the indirection one may as well toss this out and using dynamically added components
13:46:18 <jmcarthur> erisco: so you would want something like  Map DictKey (Dict a)  where  data DictKey = NumKey | ShowKey
13:46:19 <vanila> but the forall thing makes it more efficient, by CPS
13:46:46 <bennofs> Does anyone know what's the difference between ghc-mod and ghc-modi?
13:47:01 <jmcarthur> erisco: yeah this is a fundamental downside to all this dynamic dispatch stuff
13:47:46 <vanila> I don't understand
13:49:32 <fizruk> ocharles: smth like this? https://gist.github.com/fizruk/5841de260dd78544c8b8
13:49:49 <ocharles> fizruk: that won't type check
13:50:05 <ocharles> fizruk: (try it)
13:50:15 <ocharles> For one, ResultF is a GADT so you have to provide a type signature
13:50:36 <ocharles> But when you do that, GHC won't see that two types are equal :(
13:50:42 <awestroke> albeit: looks great to me
13:52:28 <fizruk> ocharles: is that 8.2?
13:52:35 <ocharles> yea
13:52:42 <fizruk> :(
13:52:48 <ocharles> i live life on the edge!
13:53:05 <vanila> so I think that the ReadP doesn't do anything different than P, it's just optimized - is that right?
13:53:16 <fizruk> well, I have it built..
13:53:24 <ocharles> fizruk: 7.8.2?
13:53:38 <fizruk> ocharles: yeah, 7.8.2 I meant :)
13:53:44 <ocharles> heh, got excited then :)
13:54:19 <albeit> awestroke: Cool, thanks. My next step is to be able to have other modules define their own Contents constructors... so I think I need to make Contents a type class with a parseContents function. Does that make sense?
13:55:27 <lispy> shachaf: on ed's blog about codensity he says, "Codensity m a is effectively forall r. ContT r m a. This turns out to be just enough of a restriction to rule out the use of callCC," Do you know why we want to rule out callCC? Or is that just an aside?
13:56:02 <benzrf> i should make a simple lib for reactive 0mq or some shit
13:57:56 <erisco> jmcarthur, this gets me to here: http://lpaste.net/103595 which might not be awful with a bit of code gen (such as TH)
13:58:06 <bitemyapp> benzrf: that would be really nice actually. What's your use-case?
13:58:23 * benzrf shrugs
13:58:44 <benzrf> i just have this gut feeling like 0mq would work gr8 with FRP
13:58:49 <benzrf> i havent really thought it through
13:58:52 <benzrf> something about it just seems right
13:59:08 <erisco> jmcarthur, all components have to be explicitly given as a sum type, which is not necessarily a bad thing
14:01:00 <saeidw> warnings abouut not doing _ <- foo inside do are kind of cool and annoying at the same time
14:01:05 <benzrf> hmmmmm
14:01:15 <benzrf> like
14:01:24 <benzrf> a sub socket could be an event
14:01:50 <benzrf> for one
14:02:06 <lispy> shachaf: I think it's just meant as an aside so he can use ContT as a more familiar example while explaining why Codensity m a /= ContT r m a (sans quantification)
14:03:38 <lispy> edwardk++ -- Good blog posts, FTW
14:06:49 <ga2arch> hi
14:07:11 <dh__> hey
14:08:58 <ga2arch> i want a job as a developer writting haskell code, is it possibile ?
14:10:22 <shelf> ga2arch: depends on things like location, skill level, etc. jobs exist
14:10:46 <shelf> i don't have one :> many here do!
14:12:27 <fizruk> ocharles: some crazy code you’re working with, huh? :)
14:12:37 <lispy> ga2arch: http://www.haskell.org/haskellwiki/Haskell_in_industry
14:12:48 <ga2arch> got it, right now i'm so desperate about wanting to develop in haskell with other people i would work even for free
14:13:23 <ocharles> fizruk: as always :)
14:13:24 <lispy> ga2arch: in that case, start contributing to open source Haskell projects to build some reputation :)
14:13:36 <ocharles> fizruk: i posted it to SO, but I fear it won't get an answer because of all the other crap in that file
14:13:51 <heatsink> A good way to do that is to work on a bug or feature request in an existing project
14:14:20 <lispy> ga2arch: Of course that assumes you have the resources to work on open source (sufficient free time and/or money to support yourself)
14:14:35 <fizruk> ocharles: yeah, I guess you might have it reduced to “Could not deduce ((Reverse kvs1 ++ '['KV k v]) ~ ('KV k v : Reverse kvs1))”
14:14:51 <ocharles> fizruk: If that's the case, then I could provide a proof
14:14:54 <jmcarthur> erisco: of course now you almost might as well use an ADT like normal
14:14:57 <ocharles> But I can't even get that error now :)
14:15:13 <fizruk> ocharles: that’s what magic gives to me :)
14:15:25 <ocharles> and it has to be (Reverse (kvs1 ++ '['KV k v]) ~ ('KV k v : Revrse kvs), I think
14:15:26 <erisco> jmcarthur, you mean for Entity?
14:15:35 <ocharles> Because otherwise it's not true
14:16:16 <Algebr> I'm confused about ClassyPrelude, is that replacing haskell report based Prelude?
14:16:34 <heatsink> It's an alternative
14:16:48 <heatsink> you can import it instead of Prelude
14:16:49 <ga2arch> lispy: got it, i'm a student and have no job right now
14:16:49 <fizruk> ocharles: I guess the problem is ResultFComp is always prepending, but you want it to append an element to the end of the list
14:16:51 <ocharles> Wait. I mean... (Reverse kvs ++ kv) ~ (Reverse (kv : kvs)
14:17:26 <ocharles> fizruk: yea, what's annoying is that I need to go through that list in both directions... though maybe I could change that
14:17:45 <heatsink> ocharles: missing a parenthesis somewhere
14:17:57 <ocharles> heatsink: right at the end, ta
14:18:24 <fizruk> ocharles: if you could provide a function :: ([(k, v)] -> ResultF kvs a) -> ResultF (kvs ++ '[ 'KV k v ]) a
14:18:36 <fizruk> ocharles: that would’ve solved your problem, I guess
14:18:41 <Algebr> heatsink: Are there many alternative preludes? Shouldn't prelude be the same always?
14:18:52 <ocharles> fizruk: hmm
14:19:02 <fizruk> ocharles: but I’m not sure how to do this (or if that’s possible)
14:19:34 <fizruk> ocharles: the type I gave is very much like ResultFComp, but with appending KV k v rather than appending it
14:19:53 <ocharles> i think i just need to step away from this problem
14:20:00 <lispy> ga2arch: if you're still a student next summer you should apply to the google summer of code. I think that usually happens in March.
14:20:17 <lispy> ga2arch: it works a mentoring program for aspiring open source contributors
14:20:32 <fizruk> ocharles: probably :) I don’t know why you need to Reverse lists at type-level :p
14:20:33 <heatsink> Algebr: Some design choices in the original Prelude do not integrate well with other code.
14:21:01 <zacts> does haskell have to be compiled?
14:21:07 <zacts> or can it also be interpreted?
14:21:14 <zacts> (sorry if this is a totally newbie question)
14:21:27 <trillioneyes> It can also be interpreted, yes
14:21:28 <lispy> @tell edwardk reading your codensity articles. I like that Yoneda Endo forms a monad. That's really beautiful.
14:21:28 <lambdabot> Consider it noted.
14:21:30 <srhb> zacts: It's not really a "language thing" I think. It should be possible to writer a Haskell interpreter
14:21:31 <l0cust> zacts: yes, it can be interpreted
14:21:38 <zacts> ok, thanks.
14:21:39 <srhb> Not sure if that's what ghci does though
14:21:45 <l0cust> zacts: use the command "runhaskell" on the program containing main
14:21:48 <heatsink> Algebr: ClassyPrelude provides similar functionality, with the intent of working better with other libraries.
14:21:51 <jmcarthur> erisco: yeah. you're going to be putting a lot of entries into those maps now and it could be that you might as well just distinguish the types you're injecting into it
14:21:51 <zacts> ok
14:22:16 <heatsink> Algebr: Prelude is a library.  ClassyPrelude is a different library.
14:22:24 <heatsink> library module
14:22:40 <srhb> zacts: Mind, the performance of say runhaskell / runghc is orders of magnitudes worse in most cases than the compiled and optimized version of the same program
14:23:18 <erisco> jmcarthur, this would prevent me from having a collection of [Entity comKey com] which I want
14:23:42 <zacts> srhb: can a compiled haskell program be modified at runtime, or would you need an interpreter for this?
14:23:56 <srhb> zacts: Depends what you mean by modified.
14:24:06 <zacts> something like emacs or Yi.
14:24:10 <zacts> that kind of paradigm
14:24:18 <MagneticDuck> zacts: xD
14:24:22 <srhb> zacts: In those cases I believe they recompile parts of the program and reload them. Like in Yi, that is
14:24:26 <MagneticDuck> well... technically, yes
14:24:28 <Algebr> So is it conceivable that in the next Haskell report (When is the next one due?) that Prelude is replaced with ClassyPrelude
14:24:28 <MagneticDuck> ahahah
14:24:53 <MagneticDuck> zacts: ... I don't get your point though
14:24:53 <srhb> Algebr: That sounds very doubtful. I'm also not aware of one being due
14:24:59 <MagneticDuck> you know what an executable is right?
14:25:04 <zacts> I think that emacs lisp is interpreted.
14:25:07 <srhb> Algebr: People seem to be happy with language extensions rather than formalizing
14:25:12 <srhb> zacts: It can be compiled, too.
14:25:16 <srhb> At least to bytecode.
14:25:19 <MagneticDuck> zacts: yeah, haskell isn't interpreted
14:25:24 <zacts> MagneticDuck: I guess I would want a system that I could extend or modify while it's running
14:25:35 <zacts> just like emacs
14:25:38 <srhb> zacts: It's definitely doable. :)
14:25:40 <Algebr> srhb: But don't extensions eventually become part of the language spec proper?
14:25:44 <zacts> ok, cool!
14:25:46 <srhb> The problems run into are different, though
14:25:58 <srhb> Algebr: with great great gaps in time.
14:26:03 <MagneticDuck> zacts: check xmonad
14:26:09 <heatsink> Algebr: It takes 10-20 years for that to happen
14:26:14 <zacts> oh, yeah I forgot about xmonad
14:26:19 <Algebr> The language has only been out for 20 years.
14:26:24 <zacts> ok, neat
14:26:58 <zacts> my goal is for a vim-like editor using haskell, but maybe I should just contribute to Yi. I'm currently working on emacs' evil-mode.
14:27:05 <srhb> Algebr: Yep. So we have ancient Haskell, Haskell 98 and Haskell 2010
14:27:09 <heatsink> 12 years passed between the most recent two revisions of Haskell.
14:27:14 <vanila> Miranda, Gofer
14:27:14 <zacts> anyway thanks, I just found #Yi
14:27:19 <srhb> zacts: :)
14:27:30 <srhb> zacts: I too am looking for something like that.
14:27:37 <Algebr> Why does ghc-pkg not expose GHC by default?
14:28:00 <zacts> srhb: btw, what would benifits of haskell be for an editor over emacs lisp?
14:28:07 <srhb> zacts: Types, types, types!
14:28:20 <srhb> zacts: All the benefits of Haskell over Lisp really.
14:28:25 <benzrf> they should make an Official Vim Spec
14:28:27 <zacts> ah ok
14:28:30 <benzrf> so that people can make alternative impls
14:28:33 <srhb> zacts: I certainly prefer to work in Haskell over Emacs lisp
14:28:36 <zacts> benzrf: vi is a POSIX standard
14:28:40 <heatsink> emacs lisp doesn't have locally scoped variable names
14:28:50 <zacts> srhb: my main goal with this is to learn haskell with it
14:28:53 <Algebr> elisp is crappy, wish it was guile.
14:28:55 <srhb> zacts: Cool :)
14:29:04 <zacts> Algebr: there is a project guile-emacs
14:29:05 <srhb> zacts: If you want contributors, please do poke.
14:29:15 <zacts> and it has made much progress
14:29:42 <zacts> heatsink: afaik, recent versions of emacs lisp do have lexical scope.
14:30:01 <heatsink> Huh
14:30:40 <zacts> heatsink: http://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html
14:30:51 <benzrf> zacts: not vim though
14:30:58 <benzrf> vi & vim differ significantly o=
14:31:14 <zacts> benzrf: indeed, it was just an FYI reply
14:31:29 <zacts> I would implement a vim-like editor in haskell
14:31:47 <Algebr> zacts: I thought Yi was basically that already.
14:31:52 <benzrf> kk
14:31:52 <jmcarthur> erisco: why would it prevent that? the different kinds of entities would just be different constructors of the same Entity type
14:32:04 <jmcarthur> erisco: anyway, i have to go
14:32:06 <srhb> Yi is probably quite advanced to jump right into
14:32:13 <zacts> Algebr: yeah, that's why I'm thinking about just working on that.
14:32:14 <srhb> While writing a partial Vim clone is pretty easy.
14:32:22 <zacts> srhb: oh interesting..
14:32:36 <Algebr> zacts: are you looking for actual working haskell applications ?
14:32:37 <erisco> jmcarthur, because presumably I do not also ask that all entities be a sum type too
14:32:44 <erisco> jmcarthur, okay thanks for the help. see ya
14:33:13 <zacts> Algebr: I mainly want to learn haskell with a project, but also yes, I wouldn't mind just improving and extending an existing implementation
14:34:20 <srhb> zacts: I personally think it would be hard to start with Yi. But that may just be being bad/slow :-)
14:34:50 <Algebr> Here's the assignment I gave myself and doing it taught me how to actually use haskell. Take a phone number and message and send the message as an sms to that phone number.
14:35:21 <Algebr> So I made a back end using Network.Curl and I made a GUI with gtk2hs
14:35:57 <saeidw_> the ugly part will be interfacing with an SMSC :p
14:36:21 <saeidw_> and getting permission to do that!
14:36:24 <zacts> should I learn C before Haskell?
14:37:02 <benzrf> zacts: it does not matter so much
14:37:03 <benmachine> zacts: I don't think C will be very useful to Haskell
14:37:04 <zacts> my language goals are (scheme)/sicp, elisp, C, haskell, and python.
14:37:05 <benzrf> they are very different
14:37:20 <zacts> someone told me to learn C first, as I will appreciate haskell more.
14:37:21 <benzrf> zacts: nice selection
14:37:33 <benzrf> zacts: i personally prefer ruby over python
14:37:36 <zacts> I also know perl already
14:37:37 <benzrf> but feel free to use python
14:37:56 <quickezed> I'm trying to create a very simple program for playing around with numbers and number functions. In my main = do block I have: x :: Integer
14:38:00 <zacts> benzrf: the only reason for python, is a couple of projects I'm interested in use it, and also we will for sure be covering it in college.
14:38:08 <benzrf> i would like to note that python's OOP is a bit half-baked
14:38:10 <quickezed> The compiler is telling me "Not in scope: `x'"
14:38:29 <benzrf> python is an extremely nice procedural scripting language, but then it has all this OOP tacked on that doesn't really feel like it belongs that much
14:38:36 <Eduard_Munteanu> quickezed: 'x :: Integer' does not declare 'x', if you're thinking of that
14:38:37 <benzrf> ruby has much nicer OOP but it is also kind of a mess
14:38:39 <Philonous> quickezed, Can you put your code into a paste-bin / gist ?
14:38:42 <Philonous> @where hpaste
14:38:43 <lambdabot> http://lpaste.net/new/haskell
14:38:46 <benzrf> which is probably on purpose, since the creator likes perl
14:38:48 <srhb> quickezed: You probably want let x = ...
14:38:50 <Algebr> benzrf: How is it not oop?
14:39:07 <jesyspa> zacts: In my very personal opinion, I'd keep this in mind when learning anything: http://www.paulgraham.com/avg.html
14:39:22 <erisco> jmcarthur, Haskell is also not necessarily the language in which one would use this entity framework. It may just be the implementation language
14:39:23 <jesyspa> (But especially C.)
14:39:23 <quickezed> Philonous, http://lpaste.net/103596
14:39:50 <erisco> jmcarthur, ie additional compilation / code gen is acceptable
14:39:58 <quickezed> srhb, if I only have the "let x = ..." line I get a warning "Defaulting the following constraint(s) to type `Integer'"
14:40:05 <srhb> quickezed: let x = 5 :: Integer
14:40:17 <zacts> jesyspa: oh cool
14:40:28 <srhb> quickezed: Or let x :: Integer; x = 5
14:40:38 <zacts> so if I know a bit of scheme, I already know a lot of perl, can I go ahead and dive into haskell?
14:40:55 <erisco> jmcarthur, I am just after Haskell because it offers the careful mathematical reasoning I need. Practicality of a Haskell API is irrelevant
14:40:57 <quickezed> srhb: ah right. All of these very simple types of expressions on the web tend to be examples typed directly into ghci.
14:41:03 <zacts> and should I start with learn you a haskell?
14:41:07 <srhb> quickezed: Indeed
14:41:09 <Philonous> quickezed, The x :: Integer needs to be in the same let
14:41:12 <srhb> zacts: I really like that book personally
14:41:25 <Philonous> quickezed, like so http://lpaste.net/103597
14:41:31 <jesyspa> zacts: You can always dive into Haskell. :)
14:41:39 <quickezed> Ok great, thanks guys :)
14:41:43 <zacts> ok cool!
14:42:02 <zacts> will a lot of SICP transfer over to haskell?
14:42:08 <quickezed> Can you tell me why the syntax is different for entering this code in ghci as opposed to a file?
14:42:10 <Philonous> quickezed, You could also just annotate the value itself (let x = 123 :: Integer)
14:42:11 <zacts> namely recursion and abstraction techniques?
14:42:14 <benzrf> Algebr: how is what not oop?
14:42:26 <srhb> quickezed: You can imagine that code entered into ghci is in a giant do-block
14:42:27 <benzrf> zacts: some of it
14:42:46 <benzrf> quickezed: except that any non-IO value has a print stuck in front of it
14:42:47 <srhb> quickezed: That's why you can't make top-level-declarations like foo = bar
14:43:26 <Philonous> quickezed, ghci's REPL has some special provisions that make it easier to work interactively.
14:43:55 <quickezed> I see, at least that explains the different behaviour.
14:44:04 <quickezed> Thanks a lot guys for the clarification!
14:44:11 <srhb> quickezed: Sure thing. :) Have fun learning
14:44:17 <benzrf> yes
14:44:20 <benzrf> do that o=
14:44:26 <quickezed> srhb: hehe, this is my second attempt.
14:44:34 <srhb> quickezed: We're here if you need us ;)
14:44:39 <zacts> so, just to double check learn you a haskell is a good intro book?
14:44:46 <zacts> or should I start with something else?
14:44:48 <srhb> lyah is awesome, yeah.
14:44:56 <srhb> And you're more than qualified to start there
14:44:59 <quickezed> Awesome, thanks. No doubt I'll have many more question.
14:45:02 <srhb> In fact you'll probably feel lime skipping a few things
14:45:05 <srhb> like*
14:45:13 <zacts> ok, I'll start with that, and then I'll ask here again for the next thing to learn after that book.
14:45:21 <srhb> zacts: :)
14:45:25 <zacts> thanks guys!
14:47:18 <Philonous> I wish there was SICP for haskell. LYAH is nice, but a bit puerile.
14:47:28 <benzrf> puerile really
14:47:32 <Maior> aaaaac
14:47:56 <Maior> oops sorry
14:48:19 <l0cust> is there a good way to make structured-haskell-mode work with evil
14:48:21 <l0cust> in emacs?
14:48:24 <Algebr> Is Yesod the biggest Haskell framework?
14:48:31 <zacts> l0cust: I'm using evil also
14:48:53 <l0cust> basically, shm doesn't provide the appropriate indentation commands
14:48:53 <zacts> l0cust: I think that's probably more of a question for #emacs or #evil-mode though.
14:48:57 <srhb> Algebr: Do you mean web framework? If so, probably yes
14:49:11 <l0cust> so when I try to change the line, it doesn't put me in insert mode
14:49:17 <l0cust> unless i turn on simple-indent-mode
14:49:25 <l0cust> in which case, the indentation gets screwed up
14:49:59 <l0cust> 'join #evil-mode
14:50:09 <zacts> so what should I read after lyah?
14:50:14 <srhb> zacts: Typeclassopedia
14:50:17 <srhb> :-)
14:50:32 <srhb> and maybe You could have invented monads
14:50:42 <srhb> Depends how easily it comes to you
14:51:19 <srhb> zacts: After that I'd say go where your interests lead you. ie. if you're finding youself working with the state monad, read resources on that.
14:51:28 <shelf> yesod has far more downloads on hackage than happstack or scotty, but downloads != usage
14:51:50 <srhb> Oh, I was thinking in terms of LOC
14:51:53 <srhb> Yesod is a heavy beast.
14:51:54 <quchen> Algebr: The three big ones are Happstack, Yesod, and Snap. Scotty is a lightweight alternative.
14:51:56 <srhb> Thus big.
14:52:13 <quchen> I think all of them are ready to use and well out the experimental stage.
14:52:20 <shelf> oh, i thought he meant w.r.t. network effect
14:52:25 <srhb> Might be very true
14:52:42 <youdontknow> hi i m a newbie
14:52:46 <srhb> youdontknow: Hi there.
14:53:03 <youdontknow> can you tell how to begin in haskell
14:53:07 <srhb> @where lyah
14:53:07 <lambdabot> http://www.learnyouahaskell.com/
14:53:09 <srhb> Read that :)
14:53:16 <quchen> Step 1. Fall in love.
14:53:24 <srhb> That's more or less automatical, though!
14:53:40 <youdontknow> kk
14:53:59 <youdontknow> can you tell me what are its advantages over c
14:54:01 <haasn> It automatically follows after you complete the hard part: Inventing the universe
14:54:11 <youdontknow> ??
14:54:21 <lispy> youdontknow: safety and abstraction
14:54:34 <srhb> youdontknow: It's a much higher abstraction level most of the time, it has a lot of safety and it's a functional paradigm
14:54:36 <haasn> youdontknow: I suggest you learn Haskell and explore their differences yourself
14:54:47 <srhb> But yeah, people can't really tell you this, you need to experience it yourself.
14:54:48 <haasn> Rather than asking other developers, whose opinions are bound to be biased
14:54:50 <haasn> (Including this one)
14:55:03 <youdontknow> k
14:55:16 <quchen> It's very different from C, and none of the explanations we can possibly give you are going to be convincing without you ever having touched the language.
14:55:59 <youdontknow> k will read lyah
14:56:02 <srhb> Enjoy :)
14:56:04 <quchen> We can assure you it's going to be an interesting ride :-)
14:56:23 <zacts> what is yesod?
14:56:32 <srhb> It's a rather large web framework in Haskell
14:56:33 <Philonous> zacts, A web framework
14:56:37 <zacts> oh ok
14:56:58 <l0cust> youdontknow: the main difference is how you write your programs. so, it really isn't a case of advantage/disadvantage - they would be used for completely different things
14:57:19 <Philonous> C doesn't have callCC
14:57:34 <l0cust> youdontknow: for instance, I would never write an OS kernel in Haskell. Likewise, I wouldn't write a math library in C
14:57:37 <benzrf> ruby does !
14:57:41 <haasn> I have never ever used callCC in Haskell
14:57:43 <benzrf> but it's slow as fuck
14:57:51 <Philonous> l0cust, OS kernel in Haskell has been done.
14:58:13 <haasn> So have linux kernel modules in Haskell ;)
14:58:13 <vanila> Philonous, what is it called?
14:58:23 <l0cust> Philonous: not arguing that it isn't possible - I'm saying that it would not be the language I would choose
14:58:24 <haasn> vanila: http://programatica.cs.pdx.edu/House/
14:59:00 <Philonous> vanila, house
14:59:12 <l0cust> youdontknow: In C, you describe how to get from point A to point B. In Haskell, you describe where point B is relative to point A
14:59:14 <Philonous> haasn, Thanks for looking up the link
14:59:52 <Philonous> l0cust, That's a confusing statement.
15:00:28 <l0cust> describing the steps, versus describing the end result
15:00:58 <l0cust> It's a bit like the difference between giving someone directions how to get to your house, as opposed to just telling someone where your house is
15:01:27 <Philonous> l0cust, It's just not clear how that metaphor connects to actual programming practice.
15:01:54 <l0cust> ah
15:02:00 <Algebr> Philonous: why this is subjective, of course, 10cust's point was very clear to me.
15:02:07 <Algebr> the canonical example of course people sql.
15:02:13 <Algebr> being*
15:02:48 <haasn> You're right about this being subjective. Which is why youdontknow has to learn Haskell for him/herself, instead of listening to other people's opinions on languages
15:03:22 <l0cust> Philonous: It's the difference between working backwards and working forwards
15:03:39 <Philonous> Algebr, That's because you already know Haskell (presumably) and can therefore relate it to actual practice. It wouldn't help you at all in understanding Haskell if you where new (at lest so I suspect)
15:03:58 <Algebr> Philonous: ah, yes, very true.
15:06:12 <joneshf-laptop> having a bit of troublle understanding skolem escape errors
15:06:34 <joneshf-laptop> in particular, i'm not sure what the actual error is
15:06:53 <joneshf-laptop> i've read that the variable is trying to be used outside of its scope
15:06:58 <joneshf-laptop> but i don't understand what that means
15:07:24 <srhb> joneshf-laptop: Can you paste the error?
15:07:27 <saeidw> is there like a common Haskell style guide? I keep thinking about where to indent stuff, etc.
15:08:04 <Maior> saeidw: hlint?
15:08:04 <saeidw> if there's an automatic tool that can tell me "no, you need to indent by THIS much here", that would be cool
15:08:06 <joneshf-laptop> srhb, i don't have a haskell example off hand
15:08:08 <srhb> saeidw: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md -- this echos what most do
15:08:22 <l0cust> Philonous: This should clear up the debate: http://blog.rafihecht.com/blog/wp-content/blogs.dir/2/files/2010/03/haskell.jpg
15:08:30 <saeidw> srhb, thanks :D
15:08:36 <saeidw> Maior, does hlint do that?
15:08:56 <Algebr> since prelude's head is partially evaluated, what is partially evaluated with?
15:08:58 <srhb> saeidw: Basically just don't use tabs. Any directly WRONG indentation will cause errors when compiling
15:09:23 <vanila> Algebr, it's not partially evaluated, but it is a partial function - because head (x:xs) breaks
15:09:33 <vanila> a total function would be one that has a result for every input
15:09:40 <vanila> oops
15:09:42 <vanila> i meant head [] breaks
15:09:50 <srhb> saeidw: I personally use two spaces for indentation, minus one for where bindings, and a few other edge cases. Generally I just try to make it "nice to look at" rather than follow an absolute style
15:10:20 <Algebr> vanila: ah, I didn't understand how partial was being used in meaning.
15:10:28 <saeidw> I think "nice to look at" is a good goal, but I find that I'm inconsistent at times
15:11:09 <l0cust> Philonous: https://2.bp.blogspot.com/-nPo8up-CfXc/TmjmkzfY5NI/AAAAAAAAA2o/UD2OM-M1kDI/s1600/haskell.jpg
15:11:44 <Philonous> saeidw, I try to follow https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
15:11:59 <albeit> srhb: That style guide says that constructor fields should usually be strict... is that common?
15:12:17 <quchen> Algebr: Partial function /= partially applied function
15:12:19 <srhb> albeit: It really depends on the type.
15:12:28 <saeidw> albeit, I've never seen that kind of thing before
15:12:53 <Algebr> That as seen by pic is spot on.
15:13:38 <Algebr> quchen: yea, I see that mistake in semantics now
15:13:57 <haasn> Is there ever a good reason *not* to have -funbox-strict-fields enabled?
15:14:25 <roconnor> haasn: sharing?
15:15:27 <quchen> haasn: I believe it's automatic in 7.8 even, for strict fields up to one machine word
15:15:40 <haasn> Like, has somebody come across a real world example where unboxing a strict field was detrimental to performance
15:16:09 <quchen> GHC 7.8.1 changelog: "By default, GHC will now unbox all "small" strict fields in a data type. A "small" data type is one whose size is equivalent to or smaller than the native word size of the machine. This means you no longer have to specify UNPACK pragmas for e.g. strict Int fields. This also applies to floating-point values."
15:16:17 <haasn> Ah, okay
15:17:45 <shachaf> haasn: It depends on how you're using the unboxed field.
15:18:13 <shachaf> If you have to immediately rebox it then you gain nothing and have to allocate the box on every use.
15:18:31 <haasn> srhb: What I find lacking in that style guide is coverage for “where” blocks, eg. I like to write “where x = 12345” on a single line if I'm only introducing a single value, and if I'm only adding a second one or so I might even add “y = foobar” where y and x are aligned
15:18:46 <srhb> haasn: Well, I'd say either are fine
15:19:05 <haasn> shachaf: That makes sense, I guess for “small” fields this is equivalent to the overhead of allocating a slot for the reference that would otherwise be there anyway?
15:19:06 <srhb> haasn: Personally I like to have where on its own line always
15:19:24 <shachaf> haasn: ?
15:19:27 <srhb> Because I often use it to separate the details of implementation from the general overview. And the extra space helps.
15:20:04 <haasn> shachaf: Oh, I think I misunderstood; I was talking about something like f (Foo x) = Foo x
15:20:32 <haasn> shachaf: but you were talking about f (Unboxed x) = Boxed x ?
15:20:56 * hackagebot hsexif 0.2.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.2.0.0 (EmmanuelTouzery)
15:20:57 <shachaf> If I write data Foo = Foo Int Int and I write f :: Foo -> Int; f (Foo x y) = x, then f has to allocate an Int box in general.
15:21:05 <shachaf> (If the Ints are unboxed.)
15:21:36 <ricree> I started writing a set of JQuery bindings for Haste. Anyone mind taking a quick look and see if I'm going the right way with this? I feel like my approach to the FFI imports is awkward.  http://lpaste.net/103599
15:21:47 <shachaf> (If f gets inlined or CPR-transformed or what have you then it might not be an issue in practice, of course. But that's the general problem.)
15:22:03 <haasn> shachaf: Isn't Int boxed even if the Int field itself is unboxed?
15:22:22 <shachaf> Right, which is why f has to allocate a box.
15:23:08 <shachaf> Or maybe I don't understand your question.
15:23:56 <haasn> I don't understand enough about how GHC represents values
15:24:20 <shachaf> [6~[6~"Stepping down" from this abstraction corresponds to choosing a line within this plane.
15:24:37 <shachaf> I forgot to make Foo strict, maybe that's the confusing part. Data Foo = Foo !INnt !Int
15:25:03 <pyon> Is there any function list Data.List.nub, except it only discards consecutive equal members?
15:25:14 <quchen> Aah, the lack of "!" was confusing me as well.
15:25:40 <shachaf> There are four possibilities: Boxed field and you need an Int# --> "dereference"; boxed field and you need an Int --> just use it; unboxed field and you need an Int# --> great, you saved yourself a dereference; unboxed field and you need an Int --> you have to allocate a box.
15:25:55 <Guest87869> map fst . group
15:26:05 <Guest87869> map head . group
15:26:07 <quchen> pyon: `map head . group` discards duplicates. Homework: prove that 'head' is safe to use here.
15:26:15 <shachaf> The question is "how often do I really need a boxed Int"Stepping down" from this abstraction corresponds to choosing a line within this plane."
15:26:20 <shachaf> Er.
15:26:31 <shachaf> The question is "how often do I really need a boxed Int".
15:26:49 <srhb> Guest87869: Hm? Both of those won't give you usual output even if you prepended > so lambdabot would use them.
15:26:55 <pyon> quchen: Oh, right. Each group provides a non-empty list.
15:27:06 <haasn> shachaf: If I have a Foo {-# UNBOX #-} !Int; does the memory representation of this constructor just store the a raw Int# value?
15:27:11 <srhb> Oh
15:27:13 <srhb> Nevermind me
15:27:13 <pyon> Errr, each group returned by `group` *is* a nonempty list.
15:27:29 <benmachine> shachaf: unboxing fields would also decrease the amount of memory you need to store things, wouldn't it?
15:27:46 <benmachine> shachaf: so it's not just about avoiding deref/rebox
15:27:53 <Guest87869> group :: Eq a => [a] -> [NonEmpty a] ;)
15:27:54 <benzrf> shachaf: hey was that a mis-paste from bret victor's article about levels of abstraction
15:28:00 <shachaf> benmachine: Sure, unboxed fields are better in all sorts of ways.
15:28:20 <shachaf> benmachine: The question was in which cases they're worse. 
15:28:24 <benmachine> oh right
15:28:25 <benmachine> fair enough
15:28:44 <johnw> benmachine: you can get some of that pretty easily with -funbox-strict-fields too, but you lose the laziness that boxing gives you
15:29:33 <shachaf> haasn: Yes, an Int# value will be stored in memory where normally there'd be a pointer to an Int box.
15:29:51 <haasn> Oh, okay. What actually happens if I unbox something like !(Maybe Int)?
15:30:06 <shachaf> Not much since GHC can't unbox sums (alas).
15:30:35 <pyon> quchen: Just wanted to compare the relative performance of (Data.Set.size . Data.Set.fromList) vs. (length . group . sort). :-)
15:30:46 <haasn> Does an {-# UNBOX #-} !Int contain some sort of representation for the I# constructor?
15:31:08 <shachaf> pyon: Certainly Data>Set will be better because it's allowed to use Ord rather than just Eq.
15:31:29 <shachaf> haasn: No, that goes away.
15:31:42 <haasn> shachaf: Is this a general rule for single-constructor data types?
15:31:44 <shachaf> haIt's worth it to write some simple programs and look at the generated Cmm if you're interested in this sort of thing.
15:31:49 <pyon> shachaf: Ah!
15:31:55 <haasn> I don't understand much about how to read Cmm
15:32:14 <quchen> pyon: You should have a look at `nub`'s source and try to reimplement it using a `Set` as cache and throw that in the mix as well. (nub has poor performance because it has a general Eq constraint; if that had been Ord, you could use more efficient implementations.)
15:32:27 <shachaf> haasn: Yes, more or less. Unboxing is sort of like inlining.
15:33:22 <quchen> haasn: Isn't I# literally "the box constructor for an Int box"?
15:33:50 <shachaf> So given data Foo = Foo Blah; data Bar = Bar A B C {-# UNPACK #-} !Foo X Y Z, the unboxing is sort of like writing data Bar = Bar A B C Blah X Y Z
15:34:22 <haasn> Oh, I get it now. That's precisely what {-# UNBOX #-} is saying: “Remove the box constructor for this field”?
15:34:39 <haasn> So {-# UNBOX #-} !Int with Int = I# Int# just stores an Int#
15:34:49 <haasn> Instead of a boxed Int
15:34:51 <shachaf> Right.
15:35:02 <haasn> Okay, thanks
15:35:43 <pyon> quchen: Would that not simply be "nubOrd = Data.Set.toList . Data.Set.fromList" ?
15:36:06 <quchen> pyon: That's less lazy. Try using it on an infinite list!
15:36:17 <pyon> Oooh, right!
15:36:47 <shachaf> haasn: Are you used to reading generated code in any language?
15:37:02 <haasn> shachaf: I'm reasonably familiar with reading generated Core
15:37:10 <haasn> But I guess that's not what you're going for
15:37:12 <quchen> And even in the finite case, it has to traverse everything before getting a single element out. The first element of a list is always "new", but your nubOrd will do half the work before returning even that.
15:37:36 <haasn> I sort of theoretically know what kind of assembly typical C implementations produce, but that's about where it stops and I'm not used to reading *actual* assembly
15:37:49 <shachaf> haasn: Even Core will help you here, really.
15:38:03 <xeno> so, is it easy/possible to declare something like a simple HList myself? (I know it's availabe in Data.HList)
15:38:36 <haasn> xeno: What kind of HList?
15:39:21 <shachaf> haasn: Try this, for instance: data Blah = Blah Int; data Foo = Foo Int {-# UNPACK #-} Blah Int; hmm :: Foo -> Int; hmm (Foo _ (Blah x) _) = x
15:39:30 <xeno> haasn: the kind where I can do Cons 42 (Cons "hello world" (Cons True (Cons (OrangeCount 10) Nil)
15:39:34 <haasn> I think the simplest “HList” I know is data HList where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)
15:39:46 <haasn> which certainly permits your expression
15:40:04 <shachaf> haasn: Then try changing the UNPACK to NOUNPACK, or changing Blah to data Blah = Blah {-# UNPACK #-} !Int
15:40:09 <shachaf> And look at the generated Core.
15:40:38 <xeno> haasn: "Illegal type, perhaps you intended to use -DataKinds"
15:40:51 <xeno> []
15:40:58 * hackagebot hsexif 0.2.0.1 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.2.0.1 (EmmanuelTouzery)
15:41:08 <joelteon> xeno: yes, you do want DataKinds
15:41:14 <shachaf> xeno: Perhaps you intended to use -XDataKinds
15:41:28 <xeno> ah yeah
15:41:40 <joelteon> why do you want an HList? why not a tuple?
15:41:53 <Guest87869> HList... what would this ever be used for
15:42:30 <haasn> An example of what HList could be useful for is avoiding the kind of repetition needed to define a given class instance “for all tuple sizes”
15:42:39 <benzrf> what is an           HList
15:42:45 <haasn> “heterogeneous list”
15:42:49 <benzrf> ick
15:42:58 <shachaf> HList is a fancy way of doing tuples.
15:43:06 <benzrf> how could you possibly write the type of an HList
15:43:13 <pyon> quchen: http://lpaste.net/103600 → perhaps like this?
15:43:13 <xeno> ghci -XDataKinds -XTypeOperators => `HList' is applied to too many type arguments
15:43:21 <startling> benzrf: with a list of types
15:43:23 <benzrf> also, homogeneous also starts with H
15:43:29 <benzrf> this is unnecessary
15:43:38 <Guest87869> so the type itself is a list
15:43:48 <shachaf> This channel is too loud to talk about Core.
15:44:15 <xeno> Guest87869: in this case, demo purpose - but I definitely can see uses
15:44:23 <joelteon> xeno: data HList a where {...}
15:44:36 <startling> Guest87869: the type has a list of types as an argument, rather
15:45:00 <Guest87869> oh
15:45:00 <shachaf> The Haskell way of doing tuples is to declare a new type for each sort of tuple you want.
15:45:04 <d1mk0> hello!
15:45:08 <shachaf> (), (a,b), (a,b,c), and so on.
15:45:35 <shachaf> Instead, you could have a more uniform way: (a,(b,(c,(d,()))))
15:45:41 <shachaf> That's the sort of thing that HList does.
15:45:41 <pyon> shachaf: Well, a Ur/Web-like type-level operator for mapping tagged lists of types into tuples/variants would be nice.
15:45:56 <haasn> shachaf: I don't actually see a difference, in any of these
15:46:06 <quchen> pyon: Yes, that looks about right.
15:46:09 <shachaf> haasn: Are you compiling with -O2?
15:46:12 <haasn> Oh, nope
15:46:27 <haasn> Therein lies the difference
15:46:32 <haasn> Does unboxing only work with -O2 or something?
15:46:39 <quchen> pyon: For an interesting exercise, try implementing it as a fold, i.e. "nubOrd = foldr ..."
15:46:44 <shachaf> Probably works with -O too.
15:47:16 <haasn> I see the difference now, and the result works nicely with my new intuition of {-# UNBOX #-}
15:48:00 <jophish> Yo
15:48:09 <shachaf> haasn: Notice how if you give Blah two fields, Foo will get four fields.
15:48:13 <d1mk0> Please, help me: http://pastie.org/9140663
15:48:22 <d1mk0> I'm trying to use encoding package
15:48:23 <jophish> I'm looking for a neat way to do this: Monad m => ((a,b)->c) -> (a, m b) -> m c
15:48:37 <haasn> shachaf: The worst case scenario seems to be “Blah {-# UNPACK #-} !Int” and “Foo Int {-# NOUNPACK #-} !Blah Int”
15:48:45 <haasn> Because now we have to unbox the Blah and then re-box the Int
15:48:46 <benzrf> jophish: probably something with arrows
15:48:50 <benzrf> but also\
15:48:50 <haasn> Int#
15:49:03 <jophish> benzrf: yeah, I lack the arrow-fu to think of what
15:49:13 <d1mk0> and I get error when I try to define ?enc argument in System.IO.Encoding.putStrLn by let statement
15:49:23 <shachaf> jophish: There's a function called "strength". But don't get too complicated.
15:49:24 <benzrf> @djinn (m a -> (a -> m b) -> m b) -> ((a, b) -> c) -> (a, m b) -> m c
15:49:24 <lambdabot> -- f cannot be realized.
15:49:28 <benzrf> lambdabot: u wut m8
15:49:34 <benmachine> djinn can only do so much
15:49:35 <jophish> :t strength
15:49:36 <lambdabot> Not in scope: ‘strength’
15:49:37 <benzrf> laaame
15:49:38 <haasn> And the best case scenario is Blah {-# NOUNPACK #-} !Int and Foo Int {-# UNPACK #-} !Blah Int because now we don't have to dereference the Blah but we already get a boxed Int that we just return
15:49:41 <d1mk0> I'm haskell noob, please help
15:49:45 <benzrf> d1mk0: ok
15:49:46 <joelteon> I don't think strength would be able to do what jophish is looking for.
15:49:57 <joelteon> or maybe it would.
15:49:57 <d1mk0> http://pastie.org/9140663#10,13
15:50:06 <jophish> I can't seem to find it on hoogle
15:50:06 <benzrf> jophish: how about
15:50:12 <shachaf> :t \f (x, my) -> fmap (\y -> f (x,y)) my
15:50:13 <lambdabot> Functor f => ((t, t1) -> b) -> (t, f t1) -> f b
15:50:18 <haasn> shachaf: The generated Core makes it very clear when something is being dereferenced because it gets transformed to case/of expressions. Is that a general rule?
15:50:19 <benmachine> joelteon: I think it would, yeah
15:50:27 <benzrf> :t first
15:50:28 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:50:32 <geekosaur> d1mk0, it should have told you to enable the ImplicitParameters extension
15:50:33 <benmachine> you strength one argument and then fmap the other over it
15:50:42 <haasn> Like if I have case x of y { __DEFAULT -> z } -- is the ‘y’ dereferenced from ‘x’?
15:50:50 <benmachine> that is my clear-as-mud explanation
15:50:51 <benzrf> __DEFAULT???
15:50:52 <benzrf> what is that
15:50:58 <startling> :t uncurry (ap (,)) ._1 return
15:50:59 <lambdabot> (Field1 a b b1 b1, Monad ((,) (b -> a1))) => a -> (b, a1)
15:51:01 <benmachine> benzrf: it is core
15:51:11 <startling> er
15:51:16 <benzrf> :t first pure
15:51:17 <lambdabot> Applicative f => (a, d) -> (f a, d)
15:51:17 <d1mk0> d1mk0, it should have told you to enable the ImplicitParameters extension
15:51:18 <d1mk0> geekosaur, thanks
15:51:18 <benzrf> hmm
15:51:20 <shachaf> haasn: Well, no y *is* x, after it's been forced.
15:51:23 <startling> :t \f -> uncurry f . _1 return
15:51:24 <lambdabot> (Field1 a b b1 b1, Monad ((,) a1)) => (a1 -> b -> c) -> a -> c
15:51:35 <startling> :t \f -> liftM (uncurry f) . _1 return
15:51:35 <lambdabot> (Functor m, Monad m) => (a -> b -> r) -> (a, b) -> m r
15:51:39 <jophish> ahh, I'm overwhelmed
15:51:41 <shachaf> haasn: case serves double duty for forcing thunks and taking them apart.
15:51:42 <geekosaur> first line of the file: {-# LANGUAGE ImplicitParameters #-}
15:51:45 <haasn> shachaf: Oh, okay. So dereferencing only happens if we have something like case x of _ { Ctor y -> ... } ?
15:51:55 <benzrf> first return theTuple >>= theFunc -- jophish
15:52:04 <haasn> I noticed in the versions where dereferencing doesn't happen this whole construct is omitted and ‘x’ is just used in place of ‘y’
15:52:28 <jophish> benzrf: ah, because (,) a is a monad
15:52:32 <benzrf> wait whut
15:52:32 <benzrf> no
15:52:52 <d1mk0> geekosaur, many thanks, but ImplicitParams, not ImplicitParameters {-# LANGUAGE ImplicitParams #-}
15:53:00 <benzrf> :t let theTuple = undefined :: (a, m b); theFunc :: (a, b) -> c in first return theTuple >>= theFunc
15:53:01 <lambdabot>     The type signature for ‘theFunc’ lacks an accompanying binding
15:53:01 <lambdabot> Not in scope: ‘theFunc’
15:53:09 <benzrf> :t let theTuple = undefined :: (a, m b); theFunc = undefined :: (a, b) -> c in first return theTuple >>= theFunc
15:53:10 <lambdabot> (Monad ((,) (m a)), Monad m) => (m a, b)
15:53:14 <benzrf> whoa what
15:53:20 <benzrf> i did something wrong o-o
15:53:27 <benzrf> :t let theTuple = undefined :: (a, m b); theFunc = undefined :: (a, b) -> c in first return theTuple
15:53:27 <lambdabot> Monad m => (m a, m1 b)
15:53:33 <shachaf> This channel is way too noisy to have a useful conversation in.
15:53:38 <joelteon> benzrf: please use a PM
15:53:43 <benzrf> oh wait im an idiot
15:53:45 * benzrf facepalms
15:53:48 <benzrf> joelteon: pls ignore
15:54:14 <benzrf> * jophish
15:54:59 <shachaf> haasn: I encourage you to explore generated code and/or read papers.
15:55:04 <benzrf> hmmm is there a genericised function for taking a structure with an 'm a' in it, and returning that structure with just a, but wrapped in m
15:55:14 <startling> benzrf, lenses
15:55:16 <benzrf> or idiom for that
15:55:25 <benzrf> startling: of course >.<
15:55:33 <benzrf> what func do you use with it?
15:55:37 <startling> :t _1 id
15:55:38 <lambdabot> (Field1 s t (f b) b, Functor f) => s -> f t
15:55:45 <benzrf> >_<
15:55:47 <alorente> I have an IO computation that reads env vars and calculates a string based on them. I would like to test it--is there a way I can set up a mock environment for it?
15:55:48 <shachaf> haasn: Those are the two easiest ways to understand how things work in GHC.
15:55:56 <startling> benzrf: there's a name for it but I forget
15:56:01 <benzrf> >> _1 id (Just 1, 2)
15:56:08 <benzrf> > _1 id (Just 1, 2)
15:56:10 <lambdabot>  Just (1,2)
15:56:15 <benzrf> ugh, #ruby's bot uses >>
15:56:17 <alorente> I guess I could make the IO computation just read a few vars and then pass them to a pure function.
15:56:18 <benzrf> i keep getting mixed up
15:56:24 <benzrf> > _1 id (Nothing, 2)
15:56:26 <lambdabot>  Nothing
15:56:26 <alorente> Yeah I'll do that. Thanks! :O
15:56:27 <benzrf> neato
15:56:30 <quchen> :t T.sequenceA -- startling, benzrf: Traversable? :-)
15:56:31 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:56:46 <startling> :t sequenceOf
15:56:48 <benzrf> what's the traversal for every element in a list again
15:56:49 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
15:56:53 <startling> benzrf: traverse
15:56:57 <benzrf> haha
15:57:03 <startling> > sequenceOf _1 (Just 2, 0)
15:57:03 <benzrf> :t traverse id
15:57:04 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
15:57:04 <lambdabot>  Just (2,0)
15:57:10 <startling> sequenceOf, aha
15:57:18 <benzrf> `traverse id` is a generalized sequence isnt it
15:57:22 <startling> benzrf: yep.
15:57:25 <benzrf> neat
15:57:37 <startling> @src sequenceA
15:57:38 <lambdabot> Source not found. That's something I cannot allow to happen.
15:57:44 <benzrf> :t sequenceA
15:57:45 <lambdabot>     Not in scope: ‘sequenceA’
15:57:45 <lambdabot>     Perhaps you meant one of these:
15:57:45 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
15:57:49 <benzrf> uh?
15:58:15 <startling> :t T.sequenceA
15:58:16 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:58:37 <startling> (the default definition of sequenceA is, in fact, traverse id)
15:59:00 <benzrf> > let invertFst (ma, b) = ma >>= (,b) in invertFst (Just 1, 2)
15:59:01 <lambdabot>  Couldn't match expected type ‘(a, a)’
15:59:01 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
15:59:04 <benzrf> o_o
15:59:27 <startling> > let invertFst (ma, b) = fmap (, b) ma in invertFst (Just 1, 2)
15:59:28 <lambdabot>  Just (1,2)
15:59:29 <benzrf> :T \(ma, b) -> ma >>= (,b)
15:59:37 <benzrf> ooh
15:59:40 <startling> benzrf: it tries to use the Reader instance
15:59:43 <benzrf> :t \(ma, b) -> ma >>= (,b)
15:59:44 <lambdabot> Monad ((,) a) => ((a, a), b) -> (a, b)
15:59:47 <benzrf> w-what?
15:59:53 <benzrf> oh wait fuck
15:59:54 <startling> sorry, Writer
15:59:56 <joelteon> benzrf: please use a PM...
16:00:00 <benzrf> joelteon: sorry
16:00:07 <benzrf> gah i keep forgetting that bind isnt fmap
16:00:09 <benzrf> haha
16:00:23 <startling> > return 2 :: ([String], Int)
16:00:24 <lambdabot>  No instance for (GHC.Base.Monad ((,) [GHC.Base.String]))
16:00:25 <lambdabot>    arising from a use of ‘GHC.Base.return’
16:00:27 <startling> aw.
16:00:34 <startling> I guess not.
16:01:01 * hackagebot hsqml 0.3.0.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.3.0.0 (RobinKay)
16:01:03 * hackagebot hsqml-demo-morris 0.3.0.0 - HsQML-based implementation of Nine Men's Morris  http://hackage.haskell.org/package/hsqml-demo-morris-0.3.0.0 (RobinKay)
16:01:05 * hackagebot hsqml-demo-samples 0.3.0.0 - HsQML sample programs  http://hackage.haskell.org/package/hsqml-demo-samples-0.3.0.0 (RobinKay)
16:02:01 <startling> Why isn't there an instance Monoid e => Monad ((,) e) ?
16:02:23 <Cale> startling: No good reason, that instance can exist
16:02:24 <haasn> There isn't?
16:02:32 <quchen> startling: It's one of those issues that come up periodically on the lists and make everyone angry.
16:02:39 <startling> quchen: haha, how so?
16:02:47 <Cale> In fact, I'm pretty sure that at least at one point, it was in mtl under Control.Monad.Writer
16:02:55 <quchen> "You should never use that, there's Writer for that" -- "But it's a correct instance"
16:03:06 <haasn> Oh, wow, Control.Monad.Instances only defines Functor for it, but not Monad
16:03:10 <startling> quchen: ah, well
16:03:14 <Cale> I actually think it'd be more convenient than using Writer in many cases.
16:03:18 <startling> yeah, agreed.
16:03:25 <quchen> startling: I'm surprised we have an Either e Monad
16:03:32 <startling> :t view _Writer
16:03:33 <lambdabot>     Found hole ‘_Writer’ with type: Getting a s0 a
16:03:33 <lambdabot>     Where: ‘s0’ is an ambiguous type variable
16:03:33 <lambdabot>            ‘a’ is a rigid type variable bound by
16:03:42 <startling> aw. :(
16:04:07 <startling> quchen: "you can use Error for that"?
16:04:13 <benzrf> ooh
16:04:18 <benzrf> :t "foo" ++ _wut
16:04:19 <lambdabot>     Found hole ‘_wut’ with type: [Char]
16:04:19 <lambdabot>     In the second argument of ‘(++)’, namely ‘_wut’
16:04:19 <lambdabot>     In the expression: "foo" ++ _wut
16:04:22 <benzrf> n-neat
16:04:29 <startling> that's a 7.8 thing.
16:04:31 <startling> it's nice.
16:04:35 <startling> (TypeHoles)
16:04:45 <startling> Shouldn't it be ValueHoles?
16:04:48 <benzrf> :t _f (Just 1, 2) == Just (1, 2)
16:04:49 <lambdabot>     Found hole ‘_f’ with type: (Maybe a0, t0) -> Maybe (t1, t2)
16:04:49 <lambdabot>     Where: ‘t0’ is an ambiguous type variable
16:04:49 <lambdabot>            ‘a0’ is an ambiguous type variable
16:04:51 <Cale> startling: It should
16:04:52 <benzrf> sweet
16:04:55 <quchen> startling: It's Type*d*Holes.
16:05:04 <Cale> startling: They originally wanted to allow holes in types
16:05:06 <quchen> It was renamed because of what you mentioned.
16:05:07 <ricree> Can anyone look at this paste and tell me whether there is a better way to handle the ffi imports?  http://lpaste.net/103599
16:05:13 <benzrf> i tried to install djinn on my end so that i could dick around with it with more interesting types
16:05:14 <Cale> But only ended up implementing holes in values
16:05:17 <benzrf> but it just kept erroring
16:05:19 <benzrf> u_u
16:05:29 <startling> quchen: oh, I never noticed
16:05:35 <startling> so, the other thing is KindedHoles? :/
16:05:49 <benzrf> bitemyapp: hey, you there?
16:06:09 <quchen> I think 7.10 will expand on the holes principle to allow partial type signatures. I don't know what it's called though.
16:06:17 <startling> Cool!
16:06:32 <startling> I often find myself deleting type signatures so I can infer them. That will be nice.
16:06:34 <quchen> Oh, https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
16:06:37 <uncleBlazer> Am I right in thinking that free monads seems pretty similar to the definition of a monad as a triple.
16:06:39 <quchen> Partial type sigs it is.
16:06:45 <Cale> In fact, the original proposal didn't have anything to do with the sort of holes which were implemented, it was just to allow holes in types which would be inferred and report what was inferred for that position.
16:06:52 <Cale> But that turned out to be tricky for some reason
16:06:53 <quickezed> Example code dealing with lists use parameters named x and xs, e.g. listLength (x:xs). I'm guessing this similar to "i" being used in a for loop for the "index". Does "xs" stand for anything?
16:06:59 <startling> uncleBlazer, it's a similar idea
16:07:03 <joelteon> quickezed: plural of x
16:07:13 <quickezed> joelteon: awesome, thanks.
16:07:17 <uncleBlazer> @startling, cool, thanks
16:07:17 <lambdabot> Unknown command, try @list
16:07:19 <bitemyapp> benzrf: yeah.
16:07:25 <joelteon> you'll also see y:ys in zips
16:07:26 <joelteon> and so on.
16:07:27 <Cale> Yeah, the partial type signatures stuff
16:07:29 <uncleBlazer> cool thanks*
16:07:43 <benzrf> bitemyapp: since you expressed interest in FRP w/ ØMQ
16:07:50 <benzrf> wanna help me figure out how that would work
16:07:50 <benzrf> :P
16:07:51 <startling> uncleBlazer: a "free x" is mathematical terminology for "the simplest thing that makes some arbitrary structure into an x"
16:08:03 <haasn> :t _Wrapped._Wrapped :: Iso' (Writer s a) (a, s) -- wrong way around :(
16:08:03 <lambdabot> (Profunctor p, Functor f) => p (a, s) (f (a, s)) -> p (Writer s a) (f (Writer s a))
16:08:12 <quickezed> joelteon: makes perfect sense. Do people pronounce it as if it is a plural of x or do they actually say "x" and then "s"?
16:08:15 <bitemyapp> benzrf: I'd be up for that, as long as you understand I'll be busy and won't be able to provide a lot of brute force labor.
16:08:17 <shachaf> For precise values of "simplest" and "makes".
16:08:19 <joelteon> so can you interpret "free" as "with no charge"?
16:08:24 <benzrf> oh certainly
16:08:33 <joelteon> quickezed: I'm sure it varies
16:08:40 <quickezed> joelteon: ok no worries
16:08:43 <lispy> quickezed: I say "xs" as "exes"
16:08:46 <bitemyapp> benzrf: I've got to shift around some documentation in Bloodhound, check in on Purescript+ReactJS, and prepare for a class.
16:09:02 <lispy> quickezed: not to be confused with the plural of exe
16:09:11 <quickezed> Haha yeh, I gotcha.
16:09:15 <bitemyapp> benzrf: but it *is* something I'm interested in. Possibly as a way to test an alternate universe CloudHaskell. Or an alternative to Kafka.
16:09:17 <benzrf> o=
16:10:01 <bitemyapp> benzrf: what did you have in mind for this?
16:10:11 <startling> joelteon: I'm not sure if that's where the terminology comes from, but it definitely *works*
16:10:24 <joelteon> Neato.
16:10:41 <startling> free's tagline is "monads for free"
16:11:08 <startling> free magmas are a cool thing, and probably the simplest example.
16:11:28 <lispy> I always thought it was free as in unconstrained
16:11:42 <lispy> I do like the "no charge" way of looking at it
16:11:43 <bitemyapp> I always thought it was free as in unspecified implementation.
16:11:44 <shachaf> startling: So simple that it misses a lot of the point.
16:11:52 <startling> shachaf: yeah! but it captures a lot of it.
16:12:07 <benzrf> bitemyapp: i am horribly inexperienced in both haskell & FRP
16:12:37 <benzrf> PUB/SUB could obviously work well as output Event / input Event
16:12:43 <benzrf> i am not sure how to model the other socket types though
16:12:57 <benzrf> *also push/pull ofc
16:13:06 <benzrf> REQ/REP seems a bit tricky
16:13:36 <benzrf> i am not sure how you could make it nicely reactive while also enforcing correctness
16:13:36 <bitemyapp> benzrf: I don't really know anything about FRP. I'm more experienced with CSP-esque systems.
16:13:42 <benzrf> hmm
16:13:56 <bitemyapp> I don't know the distinction to be made there either.
16:14:03 <benzrf> made where?
16:14:07 <shachaf> An algebraic structure in universal algebra has a bunch of n-ary closed operations -- e.g. for a monoid you have mult :: (a,a) -> a and unit :: () -> a
16:14:52 <d1mk0> oh, and haskell helped me to forget my ex-girlfriend,,, I didn't feel such a feelings by programming since I learned Delphi at higher secondary school
16:14:56 <shachaf> It also has some laws -- in this case, forall x. mult (x,()) = x and mult ((),x) = x, and forall x y z. mult ((x,y),z) = mult (x,(y,z))
16:15:12 <d1mk0> *I hadn't
16:15:22 <bitemyapp> benzrf: CSP vs. FRP, I don't know the difference yet.
16:15:28 <benzrf> i do not know CSP
16:15:30 <shachaf> Er, s/\(\)/unit \(\)/
16:15:44 <bitemyapp> benzrf: communicating sequential processes. It's more of a family of calculi than a unified system these days.
16:15:44 <benzrf> FRP is mostly a paradigm in which program output is modelled as a function of program inpit
16:15:47 <benzrf> *input
16:15:48 <shachaf> For a "free object" over some set, you start with all the elements of that set, and then you build up all the expressions you can using those elements and the operations you have.
16:16:12 <benzrf> bitemyapp: reactive-banana, at least, uses Events and Behaviors
16:16:33 <benzrf> an Event t a is a stream of discrete-in-time occurences of values of type a
16:16:37 <quchen> shachaf: That sounds a lot like a higher version of a powerset?
16:16:40 <shachaf> So if your set is {A,B}, you make A,B,mult(A,B),mult(B,A),mult(unit (),A), etc.
16:16:46 <benzrf> a Behavior t a is a continuous function of time to value
16:16:51 <benzrf> [at least, conceptually]
16:17:00 <benzrf> they are both functors, idr if monads
16:17:01 <shachaf> But now the laws force you to e.g. make mult(unit (),A) equal to A.
16:17:20 <shachaf> So you declare things that *have* to be equal to be equal. Nothing else.
16:17:23 <benzrf> bitemyapp: so for example you can have a Behavior t String representing the contents of a text box
16:17:49 <benzrf> bitemyapp: and an Event t () whose outputs coincide with pressing an 'ok' buttom
16:17:52 <benzrf> *button
16:18:10 <Zekka> Getting some confusing typechecker errors: to be clear, a function of type (forall m. MonadSpecial m => a -> m b) -> (forall n. MonadSpecial n => a -> n b) (RankNTypes) will take a function a -> m b where m may be any MonadSpecial and result in a function a -> n b where n may be any MonadSpecial, right?
16:18:13 <shachaf> So mult(A,mult(B,A)) is equal to mult(unit (),mult(mult(A,B),a))
16:18:31 <benzrf> bitemyapp: then you can use various combinators to specify that the output stream of posts or whatever is a function of the value of the box as captured when the button is pressed
16:19:11 <dmwit> Zekka: Have you had anyone try to explain this stuff with the gamified version of types?
16:19:22 <Zekka> dmwit - I don't think so.
16:19:23 <shachaf> You usually do that by taking equivalence classes -- so the elements of your free object are {A,mult(A,unit ()),mult(unit (),A),...}, and so on.
16:19:48 <Cale> Zekka: a function of that type *requires* the function you give it to be polymorphic
16:19:56 <Zekka> Cale - Yes, which is what I intend
16:19:57 <dmwit> Zekka: The idea being that there's a caller and an implementor.
16:20:01 <Cale> (and also happens to produce a polymorphic function)
16:20:18 <Zekka> I want a function that can take a polymorphic function fitting that constraint and return another polymorphic function fitting a similar constraint
16:20:28 <dmwit> Zekka: The first "forall" in your type says that the implementor gets to choose "m"; the second says the caller gets to choose "n".
16:20:29 <johnw> Zekka: I don't think you can write such a functions; how can you convert forall m. to forall n.?  You'd need "MonadSpecial m n" in order to have enough knowledge to translate from m to n
16:20:36 <Cale> Zekka: then, yeah, that's the type you likely want
16:21:17 <Zekka> johnw - I assumed that since the first function could operate on any MonadVM m, the second function would be able to operate on any MonadVM
16:21:19 <johnw> more typical would be: (forall a. m a -> n a) -> (a -> m b) -> (a -> n b)
16:21:23 <Zekka> monadVM n*
16:21:23 <cyrusdavid> hi, what does =? mean?
16:21:33 <johnw> which is just an fmapped monad morphism
16:21:38 <Zekka> I used separate names for the type variables toemphasize that they didn't need to be the same type
16:21:41 <dmwit> cyrusdavid: It's just the name of an operator. You'll have to find out what library is defining it to know what it means.
16:21:57 <Zekka> Ideally the function I'm writing has no knowledge of what m is the same way that the functions passed to it have no knowledge of m
16:22:06 <Eduard_Munteanu> (=?) sounds like xmonad, IIRC.
16:22:15 <geekosaur> yes, it's fmapped (==)
16:22:26 <johnw> but you can accept a function which knows how to relate some m with some other n
16:22:40 <Cale> http://hackage.haskell.org/package/xmonad-0.11/docs/XMonad-ManageHook.html#v:-61--63-
16:22:49 <cyrusdavid> Eduard_Munteanu, yep, i'm new to haskell/xmonad
16:22:50 <Cale> yeah, xmonad defines (=?)
16:23:04 <Zekka> johnw - I feel like you're still misunderstanding the problem -- neither m or n is known at this time. I'd like to turn a function fully polymorphic over any MonadVM to another function fully polymorphic over any MonadVM
16:23:07 <Cale> (=?) :: Eq a => Query a -> a -> Query Bool
16:23:13 <Zekka> Either that or I'm misunderstanding your response
16:23:16 <Guest87869> :t fmap (==)
16:23:17 <lambdabot> (Functor f, Eq a) => f a -> f (a -> Bool)
16:23:19 <geekosaur> cyrusdavid, there's #xmonad for xmonad-specific questions
16:23:47 <cyrusdavid> geekosaur, sorry.
16:24:01 <geekosaur> not a problem, just it's a but quieter than this channel :)
16:24:07 <geekosaur> *bit
16:24:28 <Cale> cyrusdavid: It constructs a query which checks to see if the result of the query (on the left) is equal to the given value (on the right).
16:24:41 <Zekka> johnw - Do you know how to describe the type I'm trying to describe?
16:24:52 <lispy> Zekka: BTW, if you wanted you could use m for both due to the scoping.
16:25:09 <Zekka> lispy - I thought so, but I felt like emphasizing the ms didn't need to be the same.
16:25:58 <Cale> cyrusdavid: You could also write q =? x as  fmap (== x) q
16:26:02 <Cale> or:  do v <- q; return (v == x)
16:26:07 <johnw> Zekka: You need to write a function forall m n. (MonadVM m, MonadVM n) => m a -> n a?  The only way would be if MonadVM has a function m a -> a, in which case you could apply that function and then call "return"
16:26:20 <johnw> but then it's not really a Monad
16:26:22 <geekosaur> the managehook carries the window to be managed around, and Queries like title use that to get the title fromt he window. but that means you need to lift (==) to compare to it, so we provide a lifted (==) so you can write `title =? "foo"` instead of `fmap (== "foo") title`
16:26:33 <johnw> you could go from m a -> n (m a)
16:26:35 <Algebr> I just saw code like this:   import qualified Foo.Bar as F; import qualified Something.Else as F. What does F become? A union of items exported by both Foo.Bar and Something.Else? If that's the case, then wouldn't it just be cleaner to make one module from the getgo with everything?
16:26:52 <Zekka> johnw - Can you clarify why that's necessary given what I'm trying to express? Because I don't understand why it would be
16:27:08 <Cale> Algebr: It imports them with the same prefix, yeah
16:27:17 <lispy> Zekka: I think johnw is thinking ahead to how you'll use the result
16:27:28 <Cale> Algebr: Of course, you can decide whether or not to do that on a module-by-module basis
16:27:33 <lispy> (or else I too am not understing what johnw is getting at)
16:27:37 <johnw> Zekka: if you build that function, can you fmap it onto some f -> m a, to get an f -> n a
16:27:54 <Zekka> I'll clarify, as far as I'm aware the identity function should already match the type I'm trying to write
16:28:10 <lispy> johnw: I don't think Zekka cares about changes the instance.
16:28:15 <lispy> changing*
16:28:29 <lispy> johnw: I think it's more about expressing a lack of knowledge about the instance
16:28:35 <johnw> hmm
16:28:41 <lispy> there exists an instance
16:28:46 <johnw> Zekka: can you show us some code?
16:28:48 <Cale> Algebr: F itself isn't really anything on its own. It's just something that the names of things being imported are being qualified by.
16:28:58 <Zekka> johnw - It's hard for me to isolate it from my project, but I can try to write a sample program
16:29:05 <Cale> (F is not a module)
16:29:53 <Algebr> Cale: Ah, that makes it super clear. Thank you!
16:30:22 <geekosaur> as for the second question, no, it doesn't always make sense to just combine everything into a module. although I kinda dislike that particular style specifically because I think it better not to mix modules together into a namespace like that, even if it's permitted
16:31:19 <benzrf> bitemyapp: absorb anything>
16:31:30 <d1mk0> How  to include useful package?
16:32:13 <d1mk0> How  to include useful package?
16:32:24 <d1mk0> sorry
16:32:36 <Guest87869> import Useful
16:32:43 <d1mk0> problem with irc-client
16:32:51 <lispy> d1mk0: I'm wondering, "How to give useful answer?" :)
16:33:00 <d1mk0> I wrote "build-depends: QuickCheck -any, base -any, utf8-string, encoding, useful" at demo.cabal
16:33:00 <lispy> (I don't understand your question...)
16:33:05 <uncleBlazer> Anyone else have problems with building comonad? It complains about not finding dynamic libs
16:33:13 <d1mk0> but compiler says At least the following dependencies are missing:
16:33:13 <d1mk0> useful -any
16:33:39 <lispy> d1mk0: that's because useful is not installed locally
16:34:01 <Algebr> hackage apparently doesn't enforce whether package names need to be all lowercase?
16:34:20 <d1mk0> cabal install useful -> .... Installed Useful-0.0.6
16:34:22 <dmwit> uncleBlazer: lpaste your exact command + the exact error
16:34:26 <Cale> Algebr: Yeah, they're pretty much freeform
16:34:29 <lispy> d1mk0: ah, case sensitive
16:34:30 <dmwit> d1mk0: Package names are case sensitive.
16:34:39 <jmcarthur> hackage is actually case sensitive i think, but cabal-install tries to be "smart"
16:34:41 <d1mk0> oh
16:34:42 <dmwit> d1mk0: (Though "cabal install" tries to hide this fact.)
16:34:43 <d1mk0> sorry
16:34:46 <d1mk0> thanks
16:34:46 <lispy> jmcarthur: gross
16:34:51 <jmcarthur> yeah, very gross
16:34:52 <bitemyapp> benzrf: a bit, talking about it like this isn't going to do much.
16:34:54 <lispy> jmcarthur: I didn't know that and I'm not glad to hear it!
16:35:01 <bitemyapp> benzrf: I need to either read or poke at zeromq from Haskell.
16:35:15 <d1mk0> it works now! great
16:35:16 <jmcarthur> lispy: http://hackage.haskell.org/package/numbers  http://hackage.haskell.org/package/Numbers
16:35:41 <benzrf> hmm
16:35:43 <benzrf> bitemyapp: well
16:36:00 <benzrf> bitemyapp: i figure PUB/SUB and PUSH/PULL at least would work great with Events
16:36:01 <lispy> jmcarthur: right, I know the packages can be case sensitive. And that's bad enough due to examples like that. But having the cli tool be loose and fast with the capitalization is just like adding insult to injury
16:36:09 <jmcarthur> yeah
16:36:53 <Cale> I'm still kind of confused about what zeromq is actually for
16:36:53 <lispy> jmcarthur: copumpkin has convinced me that we need github style heirarchy/namespaces for hackage
16:37:00 <benzrf> Cale: do you know what it does
16:37:19 <lispy> jmcarthur: So we can have things like username/foo and organization/foo as package names
16:37:44 <Cale> benzrf: Sort of. It seems like an incredibly generic sort of network protocol.
16:37:52 <jmcarthur> lispy: we could just adopt the convention of prepending some user or group name to the package
16:37:53 <benzrf> n-not really
16:38:02 <benzrf> Cale: it's more like a generic networking lib
16:38:06 <benzrf> similar to BSD sockets
16:38:11 <benzrf> but at a higher level of abstraction
16:38:40 <Guest87869> i would appreciate a websockets-like protocol that doesnt require http
16:38:46 <Algebr> Cale: Are you familiar with IPython?
16:38:53 <Cale> Algebr: vaguely
16:38:53 <Algebr> or at least heard of it
16:38:58 <benzrf> Guest87869: what do you mean websockets-like
16:39:07 <Guest87869> like websockets
16:39:12 <benzrf> erm
16:39:16 <benzrf> in what way
16:39:17 <Zekka> johnw: Wrote an acceptable approximation of my current structure
16:39:19 <Zekka> lpasting in a second
16:39:21 <Algebr> IPython uses zeromq to communicate with the front end and the back end
16:39:32 <Guest87869> messages but not without the crunchy caveats of UDP
16:39:33 <Zekka> lispy: and if you want to stare on it that's cool too
16:39:41 <lispy> Zekka: I planned on it :)
16:39:41 <Guest87869> s/not without/without/
16:39:45 <Zekka> http://lpaste.net/103603
16:40:16 <Zekka> This doesn't include a function that results in the bizarre errors I got from GHC when writing it mostly because the function that's giving me trouble relies on a lot of details of how my program works and I didn't want to port so much over
16:40:23 <Cale> benzrf: But what sort of application would you write that would use it?
16:40:38 <benzrf> Guest87869: use ØMQ
16:40:39 <benzrf> :-D
16:40:50 <benzrf> Cale: anything that needs to do distributed or communicating computing
16:40:59 <Algebr> Cale: Banks use it too.
16:41:04 <Zekka> I can try to rewrite the error to match that form though if you think 'that looks right, so what's screwing up?'
16:41:05 * hackagebot lio 0.11.4.2 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.4.2 (DeianStefan)
16:41:23 <joneshf-laptop> @pl foo x y = bar >>= \z -> baz z x y
16:41:23 <lambdabot> foo = ((bar >>=) .) . flip . flip baz
16:41:27 <Zekka> the gist of the problem is that followConvention converts the past action into a similar action that does a few more things
16:41:30 <sunw> Hello.  I'm new to Haskell (and FP in general).  I'm facing a problem: to practice, I'd like to get some numbers passed as arguments to the program (getArgs + map read), then increment all those numbers before printing the list with "print", all that in a "forever"; though I don't see how to update these values; in other words, I don't get how I should mutate the list at each iteration so that the old values become the new ones, etc.
16:41:30 <sunw> Do I have to use the State monad?
16:41:33 <Cale> It seems like anything doing distributed computation would want something more specialised like distributed-process, no?
16:41:45 <Cale> Maybe not
16:41:47 <Guest87869> aside from the application-specific protocol, haskell's sockets are very easy to use already
16:41:56 <benzrf> sunw: recurse with args
16:41:56 <benzrf> or you could use an IORef if you really wan t to
16:42:01 <benzrf> Guest87869: link?
16:42:12 <benzrf> anyway
16:42:16 <lispy> Zekka: type MonadSpecial a = (MonadIO a, MonadState Special a)
16:42:21 <shachaf> sunw: You never have to use State.
16:42:22 <joneshf-laptop> sunw, you said the "m" word
16:42:30 <Guest87869> sorry i do not have a link
16:42:31 <saml_> heheh i'm here
16:42:31 <lispy> Zekka: I never trust that
16:42:36 <saml_> so that i'll help haskell programmers
16:42:36 <Zekka> lispy - That's the same way I explained the constraint in the original program
16:42:39 <lispy> Zekka: Does that do what we want?
16:42:51 <Cale> sunw: loop xs = do print xs; loop (map (+1) xs)
16:42:54 <shachaf> sunw: Probably a reasonable way of expressing it is a recursive function that calls itself with the new iteration of the list.
16:42:56 <Zekka> The constraint I wrote in that form previously did what I wanted
16:43:03 <shachaf> The thing Cale just wrote, for instance.
16:43:23 <benzrf> i would say that ØMQ is an abstraction over sockets the same way that sockets are an abstraction over IP
16:43:28 <Zekka> It's not terribly important, I don't think, what constraints are included in MonadSpecial -- I just wanted a constraint that corresponds to the shape of my monad stack
16:43:35 <lispy> Zekka: and followConvention type checks? (I don't have the deps or I would check, but it looks wrong)
16:43:37 <johnw> Zekka: followConvention cannot be written, because you can't "extract" from a monad
16:43:40 <benzrf> or perhaps over CP
16:43:41 <benzrf> *TCP
16:43:47 <Zekka> lispy - It typechecks.
16:43:53 <Zekka> Why wouldn't it?
16:44:01 <Zekka> johnw - So how does the definition I've written there fail to do what I want?
16:44:04 <johnw> it type checks because you haven't used it yet
16:44:30 <Cale> sunw: It's occasionally nice to note that you can use fix from Data.Function for this (though this is an idiom which for whatever reason hasn't really caught on)
16:44:43 <Zekka> johnw - So, how will I write an operation that modifies an existing operation polymorphic over MonadSpecial instances?
16:45:10 <lispy> Zekka: The type of result should be Type2, and you end that block with 'return result'
16:45:29 <Zekka> lispy - Yes, that's correct?
16:45:36 <johnw> Zekka: keep both operations in the same monad
16:46:19 <lispy> Zekka: so, the type of followConvention should be MonadSpecial m => ... -> m Type2
16:46:50 <Cale> sunw: e.g. do args <- mapM readIO =<< getArgs ; fix (\loop xs -> do print xs; loop (map (+1) xs)) args
16:47:13 <Cale> (but most people prefer to just separate the loop into its own definition, putting it in a let or where clause)
16:47:14 <Zekka> lispy - That would still work in my case, but I feel like it says something slightly different
16:47:24 <johnw> why should you need to change the monad?  Isn't MonadSpecial sufficiently generic already?
16:47:28 <Cale> sunw: You could also use an IORef
16:47:34 <Zekka> it says "pass me something that may or may not expect a specific MonadSpecial, and I will return something that returns the same MonadSpecial"
16:47:45 <dmwit> no
16:47:52 <dmwit> That's not what that type says.
16:47:54 <johnw> i mean, you're not doing anything with the underlying monad (you can't, that's the whole benefit of forall), and yet you want to change it for something else?
16:48:11 <Zekka> johnw - I'm trying to write this with a signature as general as possible - I think it would be counterintuitive if someone passed in a function that could take any MonadSpecial and it resulted in a function not polymorphic over any MonadSpecial
16:48:11 <dmwit> If we're still on the type "(forall m. MonadSpecial m => ...) -> (forall n. MonadSpecial n => ...)".
16:48:16 <Zekka> That's sthe specific case I'm trying to avoid
16:48:30 <Zekka> dmwit - I'm referring to the type lispy suggested
16:48:36 <dmwit> Okay.
16:48:47 <johnw> i see, you want to be able to convert from one transformer stack having MonadState Special, to another one
16:49:01 <Zekka> johnw - No, I don't think that's quite it
16:49:17 <benbangert> I don't suppose anyone has any suggestions on how to do a fairly complex algorithm that involves mutating state at various points in a B-Tree? In this case nodes in the tree are navigated to, and updates to the amount of children of each node are done. Due to the various points of access to the various children of each node, I can't really do the typical update/swap thing to construct a new tree since I have have other points of access below that which w
16:49:21 <johnw> can you show me an example of how you'd like to use this code?  I seem to be missing something
16:49:28 <Zekka> I want to convert a function that can operate using any transformer stack meeting MonadSpecial and result in another function polymorphic over any stack containing MonadSpecial
16:49:35 <johnw> I "get" the desire to carry the state over
16:49:47 <johnw> ok, then I think we're saying the same thing
16:49:51 <benbangert> At this point it seems probable the only way is to convert the entire immutable struction to a mutable one for this operation.... then freeze it all up
16:49:55 <Zekka> johnw - I'm not sure how much more specific I can be without just showing you my code, which I don't think will be very helpful
16:49:56 <lispy> Ah, right so the forall n can be moved all the way to the outside
16:50:10 <Cale> benbangert: Your message was cut off at "I have have other points of access below that which "
16:50:18 <johnw> so if I give you StateT Special IO a, you can give me RWST r w Special IO a?
16:50:20 <Cale> (IRC has a silent length limitation)
16:50:23 <Zekka> lispy - But if I move it to the outside, won't that allow users to pass in a function that can only take specific MonadSpecials, and won't it result in a function that can only operate on specific MonadSpecials?
16:50:32 <Eduard_Munteanu> benbangert: got cut off at 'access below that which w'
16:50:35 <lispy> the type is really forall n. MonadSpecial n => (forall m. MonadSpecial m => Type1 -> Type2 -> m Type2) -> Type1 -> Type2 -> n Type2
16:50:37 <dmwit> johnw: You can't give him StateT Special IO a.
16:50:42 <benbangert> Cale: ah
16:50:44 <Zekka> johnw - No, you aren't "giving me" any specific transformer stack -- you're giving me a function that works with any monad stack
16:50:48 <dmwit> johnw: You have to give him something that can work for *any* instance of MonadSpecial.
16:50:50 <johnw> ah, right
16:50:55 <benbangert>  Due to the various points of access to the various children of each node, I can't really do the typical update/swap thing to construct a new tree since I have have other points of access below that which would be done on the 'old' tree...
16:51:11 <pavonia> Is there a library that can do the opposite of Parsec, i.e. transforming a value into a string format that can be read by a parser again?
16:51:17 <Eduard_Munteanu> Zekka: are you looking for 'hoist'? http://hackage.haskell.org/package/mmorph-1.0.2/docs/Control-Monad-Morph.html#v:hoist
16:51:19 <Zekka> The same way that if I define a function (b -> c) -> (a -> b) -> (a -> c) you aren't ever giving me a specific a, b, or c
16:51:24 <johnw> dmwit: ah, right
16:51:33 <Guest87869> whats the type of a function that works with "any monad stack"
16:51:36 <johnw> oops, forgot I said that :)
16:51:39 <Zekka> Eduard_Munteanu: Not as far as I can see.
16:51:58 <Cale> benbangert: It might be a use case for the pure State monad, but I'm really not sure.
16:52:01 <Zekka> Guest87869 - It's not 'any monad stack' but any 'monad transformer stack meeting the given constraint'
16:52:10 <pavonia> Ideally something that can be generated from a parser specification (if that is even possible)
16:52:12 <Zekka> So it's MonadSpecial m => Type1 -> Type2 -> m Type2
16:52:18 <dmwit> Zekka: I think it's possible that I have lost track of your actual question. What is the actual question?
16:52:20 <Cale> Guest87869: "Monad stacks" aren't really a thing. Monads are.
16:52:30 <Guest87869> Cale: yes thats why im curious
16:52:32 <Cale> (I actually hate the term "monad stack"
16:52:33 <Cale> )
16:52:38 <lispy> pavonia: I'm not sure if we have libraries for it but there have been some ICFP papers. Bidirectional parsing?
16:52:44 <Zekka> dmwit - I want to know whether the typesignature I've written says what I think it means and whether I've defined my function correctly if it does
16:52:47 <Eduard_Munteanu> pavonia: you're looking for attribute grammars, but I don't know something useful for that purpose
16:52:49 <benbangert> Cale: yea, at the moment its implemented as a data type using a Vector for the children, so I'm thinking I'll have to convert the entire thing to a mutable one
16:52:50 <Cale> Guest87869: Just use a type variable for the monad
16:53:00 <Cale> Guest87869: e.g. look at the type signature of something like mapM
16:53:02 <Zekka> The followup will be 'OK, so why is GHC giving me these nonsensical errors' if it turns out that it does and I have.
16:53:06 <Cale> It works with an arbitrary monad
16:53:08 <dmwit> Zekka: From what you've been saying, I believe you understand rank-2 types correctly.
16:53:22 <dmwit> Zekka: Whether your function is right or not is hard to say without seeing the function. =)
16:53:31 <Guest87869> right so its a function that works with any monad which also implements the class
16:53:32 <pavonia> lispy: Not sure if it's bidirectional parsing, something like Read and Show
16:53:33 <lispy> dmwit: http://lpaste.net/103603
16:53:35 <Zekka> http://lpaste.net/103603 <- dmwit -- It's very close to the form of followConvention here
16:53:39 <dmwit> thanks
16:53:40 <Zekka> Guest87869: Correct
16:54:02 <Guest87869> i was getting confused thinking your problem was specific to "stacks"
16:54:04 <lispy> Zekka: Do you realize that the forall on the n is actually on the outside of the type?
16:54:05 <Guest87869> which it sounds like its not
16:54:06 <Zekka> (actually a ConstraintKinds constraint if that makes any difference, but if it did I'd think it was a bug)
16:54:08 <Cale> benbangert: *maybe* for efficiency's sake, but you should never *have* to do that.
16:54:17 <sunw> Cale: I think I get it.  I was wondering how I should make a function that returns a modified list then store that list later on, but doing so I'd have two variables (the original list and the one modified), hence I was stuck at the printing part since the list is immutable
16:54:24 <lispy> Zekka: check in ghci if you don't believe me!
16:54:35 <Zekka> lispy - One second
16:54:48 <benbangert> Cale: given that I might tweak the children several levels below, then somewhere else in the structure, short of making the entire thing mutable, I'm not sure of any other way to handle it. its a nasty algo....
16:54:54 <dmwit> Zekka: That code looks reasonable to me.
16:55:01 <benzrf> hmmmm
16:55:04 <Zekka> oh, hold up, GHCi generated a large amount of interesting output
16:55:10 <Cale> sunw: You can use 'let' inside a do-block to locally make new definitions, but you should try to avoid shadowing existing bound variables
16:55:21 <lispy> Zekka: add FlexibleContexts
16:55:22 <jle`> it's not that we ignore questions, it's that sometimes nobody here really knows the answers :/
16:55:29 <Zekka> Lispy - A step ahead of you
16:55:30 <dmwit> Zekka: It also compiles, once I add FlexibleContexts.
16:55:43 <benbangert> Cale: its an iterative algorithm, each iteration moves through the structure in different directions, then changes the children at that layer.
16:56:27 <Zekka> lispy - Yes, I can see that it moves it to the outside, I'm assuming because it doesn't make any difference in this case whether it's on the outside
16:56:36 <dmwit> correct
16:56:42 <Cale> benbangert: Any algorithm involving mutation and pointers can be (at worst) implemented as a pure algorithm which manipulates something like a Data.Map or Data.IntMap to represent the heap
16:57:00 <Cale> benbangert: But usually there's something better you can do than that :)
16:57:09 <lispy> Zekka: right although. I misparsed it earlier as a result. That's why I couldn't figure out how it type checked.
16:57:34 <Cale> benbangert: Your task also sounds rather suitable for something like zippers
16:57:39 <Zekka> For what it's worth I'll admit that it's not really a deep understanding of RankNTypes that led me to put it together that way
16:58:00 <Zekka> I just copied the fully-quantified form of the kind of operation I wanted twice, and changed the name of the variable for clarity
16:58:03 <lispy> I thought the second forall was in a negative position because I didn't pay close enough attention to the fact that the parens scope to the end of the type
16:58:33 <johnw> actually, isn't your followConvention the same thing as MonadSpecial m => (Type1 -> Type2 -> m Type2) -> Type1 -> Type2 -> m Type2?  Since the only lawful thing you can do is to return the same function, which is exactly what you're doing in your paste
16:58:45 <benbangert> Cale: yea.... this takes essentially a b-tree of 'symbols'. and a list of 5 'boxes'. the first box stores the root of the tree. then for N symbols, it looks in each box, and sees if the symbol exists in the children
16:58:49 <dmwit> johnw: lawful?
16:58:50 <lispy> johnw: that's what the inferred type would be like
16:58:52 <dmwit> johnw: what laws?
16:59:02 <Zekka> johnw - (a) How is that the only lawful thing I can do? (b) How is that what I'm doing?
16:59:10 <johnw> parametricity
16:59:30 <benbangert> Cale: if the symbol exists in one of the children, that child is copied to the next box, otherwise a blank spot is copied into the next box. the root is always in the first box in the list.
16:59:53 <Zekka> I'm returning the result of the original function, but I'm also performing additional operations using the same monad it's in, whatever monad I'm under
16:59:55 <benbangert> Cale: thats how it ends up having multiple different points of access to the same main structure, as each iteration goes through
17:00:03 <dmwit> johnw: I think they can be different (though perhaps not with this particular constraint): the explicitly polymorphic one is allowed to call its argument multiple times, with different 'm's.
17:00:08 <Cale> benbangert: That is, imagine splitting your tree representation into a structure which represents the subtree you're "focused" on for this iteration, and something which can be used to efficiently construct the remainder of the surrounding tree (i.e. a tree with a "hole" in it where this subtree goes, and where the nodes closest to that subtree are easiest to manipulate)
17:00:10 <johnw> i.e., that i can't know anything about m except that it can give me a Special and lift actions into IO.  So followConvention can either ignore f and supply some other action entirely, or use f any number of times to augment the result
17:00:27 <johnw> in this case, Zekka is adding effects
17:00:28 <roconnor> @type \f x y -> f x y >> f x y
17:00:29 <lambdabot> Monad m => (t -> t1 -> m b) -> t -> t1 -> m b
17:00:36 <benbangert> Cale: right, so each iteration involves N different 'focused' points *at once*
17:00:39 <dmwit> johnw: So, for example, if IO were an instance of MonadState Special, the code could call (liftIO (f t1 t2)) or something like that.
17:00:41 <johnw> he's taking f, and adding op1-op4, but he's not changing the monad
17:00:50 <benbangert> Cale: zippers seemed feasible with one focus point, but this has multiple
17:00:53 <dmwit> johnw: The rank-2 one could, that is. But the rank-1 one could not.
17:00:59 <johnw> hmm.. ok
17:01:06 <Cale> yeah, that sort of thing can still be done, but tends to be obnoxious
17:01:07 * hackagebot pubnub 1.1.0 - PubNub Haskell SDK  http://hackage.haskell.org/package/pubnub-1.1.0 (tsloughter)
17:01:27 <Cale> At that point, you're probably better off using some kind of graph representation of the structure in terms of a Map
17:01:30 <johnw> dmwit: yes, I see what you mean; scratch what I said
17:01:50 <sunw> Cale: yes, that's what I did.  I even tried a tricky one like:  print values ; let temp = values ; x <- computeValues temp ; let values = x  in a "forever", but  values  was not changing
17:01:52 <johnw> ah!  so he can extract a Special and put it into the new monad
17:02:00 <dmwit> To be clear: the rank-1 type is *more* restrictive than the rank-2 type.
17:02:01 <johnw> yes, ok, this function will work just fine
17:02:06 <dmwit> i.e. inhabited by fewer things
17:02:29 <Cale> sunw: Yeah, you're defining a new variable, not altering the value of the old one.
17:02:48 <dmwit> On the other hand, the rank-2 type can accept fewer things as an argument.
17:03:00 <Zekka> So, so I can make my code freak out and then post the error, does my definition look correct?
17:03:16 <Cale> sunw: Things defined in a 'let' in a do-block scope over just the remainder of that do-block.
17:03:24 <dmwit> Zekka: Well. Your definition type-checks.
17:03:31 <lispy> Zekka: I still haven't really understood what you're doing. So I'm not sure if it's correct.
17:03:31 <dmwit> Correct is a much harder question. =)
17:03:31 <Cale> sunw: So, you probably never even made use of your new 'values'
17:03:32 <Zekka> (Also, yes, by design the rank-2 version will only accept polymorphic functions ever and only produce polymorphic functions ever)
17:03:40 <Zekka> lispy - I'm not sure how I can make it any clearer
17:04:01 <johnw> I think your definition says: "You give me a function that works for any MonadSpecial", and I'll execute it within the particular MonadSpecial you called me from
17:04:04 <Zekka> I want to take a function that can operate under any MonadSpecial and create a new function which, in all cases, can also operate undera ny MonadSpecial
17:04:15 <Maior> are there standard/common typeclasses for generalising "deltas"; things a bit like "deltaplus :: Time -> TimeDelta -> Time" and "deltasub :: Time -> Time -> TimeDelta" etc.?
17:04:21 <johnw> which I have a feeling won't unify when you try to use it
17:04:23 <lispy> Zekka: that's not what you have
17:04:34 <Cale> sunw: (and the code will behave the same way if you rename that latter 'values' to anything else, so long as you change any later occurrences of it as well, throughout the rest of that block)
17:04:35 <lispy> Zekka: n will be fixed at the callsite
17:04:46 <johnw> right, you're going to get errors that the type checker can prove m ~ n
17:04:50 <johnw> can't
17:05:05 <Zekka> lispy - I would like n to be determined at the callsite -- how can I do that?
17:05:09 <dmwit> johnw: That's not what lispy is saying.
17:05:25 <Cale> Maior: there's http://hackage.haskell.org/package/vector-space-0.8.6/docs/Data-AffineSpace.html
17:05:26 <albeit> Is there a way to not use case for this (if/guards)? "let argsObj = case maybeArgs of    Just Obj -> obj       Nothing -> Null"?
17:05:27 <johnw> lispy is saying that the caller fixes n, isn't he?
17:05:49 <dmj`> @typ fromMaybe
17:05:49 <lambdabot> a -> Maybe a -> a
17:05:54 <lispy> johnw: yes. but the thing you pass to followConvention will work for n
17:06:00 <albeit> Ah perfect thanks
17:06:05 <Maior> Cale: hm thanks, that looks a little stricter than what I'm after, but a good starting point for inspiration!
17:06:05 <dmj`> np
17:06:06 <johnw> ah, exactly!
17:06:09 <lispy> johnw: so i don't think you'll get a proof obligation like m ~ n
17:06:09 <johnw> thanks, lispy
17:06:12 <johnw> right
17:06:19 <johnw> it works for any MonadSpecial, which must include n
17:06:24 <Cale> Maior: I've used it for exactly that purpose before
17:06:33 <Maior> Cale: oh nifty, thanks
17:06:41 <Zekka> johnw - Right.
17:06:50 <johnw> ok, I've got it now
17:06:51 <lispy> Zekka: we might be saying the same thing in different ways.
17:07:27 <jle`> :t \x mx -> fromJust (mx <|> return x)
17:07:28 <lambdabot> a -> Maybe a -> a
17:07:31 <benzrf> bitemyapp: still there?
17:07:31 <Cale> Maior: TimeDiffs form an additive group (actually usually a vector space as well)
17:07:33 <jle`> hehe
17:07:40 <lispy> Zekka: the call of followConvention will be a particular MonadSpecial context, let's say, MonadSpecial k. The type checker will need to unify k and n.
17:07:42 <Cale> Maior: and times are an affine space that they act on
17:08:01 <lispy> Zekka: That's what I mean when I say that the callsite fixes n.
17:08:04 <Zekka> lispy - Let's be clear.
17:08:14 <dmwit> I register my guess: adcfdf0d9e86e349aabe8d8aabe1fee3
17:08:17 <Zekka> When f is passed, we receive a function \t1 t2 -> do [...]
17:08:19 <dmwit> Zekka: Show us the code that dies.
17:08:24 <Zekka> In the type of this function, is n fixed?
17:08:31 <lispy> Zekka: no
17:08:32 <Zekka> dmwit - Sure, one moment
17:08:39 <lispy> Zekka: the caller gets to choose n
17:08:54 <Zekka> lispy - Then isn't that what I wanted after all? I think I must have misunderstood you
17:08:59 <nicoo> wg #FlashNews
17:08:59 <Guest87869> Zekka: the returned function has a fixed type
17:09:10 <Guest87869> it cant be polymorphic
17:09:40 <Zekka> Guest - The type of \t1 t2 -> [...]?
17:09:56 <Guest87869> yeah
17:10:37 <Guest87869> it may have closed over something that later would be incompatible with where you want to used it
17:10:48 <dmwit> I suspect the wording people are using to talk about when things go from polymorphic to monomorphic is insufficient to capture what is actually happening.
17:11:13 <Zekka> http://lpaste.net/8652944244723417088 <- this is the code and the error
17:11:18 <bitemyapp> benzrf: yes but kinda busy.
17:11:27 <Guest87869> :t 3
17:11:28 <lambdabot> Num a => a
17:11:30 <Guest87869> :t (+)
17:11:31 <lambdabot> Num a => a -> a -> a
17:11:35 <Guest87869> :t (3+)
17:11:36 <lambdabot> Num a => a -> a
17:11:39 <bitemyapp> benzrf: I was interested in seeing if a nice zeromq library for Haskell could be made. Add me to a github repo if you start one.
17:11:42 <Guest87869> hmm
17:11:58 <Zekka> HaskellFunc expects a function polymorphic over all MonadVM
17:12:08 <Zekka> oh, MonadVMGen VMState Exception is MonadVM, by the way
17:12:22 <sunw> Cale: that makes sense.  So if I want to do some computations with these values then place them back to the list (replacing the old ones), I should compute the results, put them back in a fresh list then recurse on it?
17:12:39 <johnw> you'd need: unclosedFunc :: (forall m. MonadVM m => Variant -> m Variant)
17:13:10 <dmwit> Zekka: What is the type of thunkConvention, please?
17:13:12 <Zekka> johnw - Oh, I think you're right
17:13:38 <dmwit> If johnw was right, I would expect it to complain about "const fn", not about the return type of "thunkConvention".
17:13:38 <Zekka> dmwit - It's about the same as the type of followConvention: thunkConvention :: (MonadVM m => Reference -> Variant -> m Variant) -> (MonadVM n => Reference -> Variant -> n Variant)
17:13:51 <dmwit> Zekka: That type is not the same as followConvention's!
17:14:02 <dmwit> Zekka: You left out the foralls.
17:14:09 <benzrf> bitemyapp: well, tbp i was thinking of an FRP-based one
17:14:18 <Zekka> dmwit - Oh, you're right. One moment, I'll put them back and see if the error changes
17:14:39 <benzrf> bitemyapp: i mean there are probably other ways to bind it
17:14:54 <benzrf> btw i thought of a way of modelling req/rep
17:14:54 <Guest87869> #zeromq
17:15:13 <benzrf> well
17:15:16 <benzrf> REP at least
17:15:28 <saml_> http restful
17:15:41 <benzrf> you register a Behavior whose value is the function used to reply to each requrest
17:15:44 <benzrf> *request
17:15:54 <lispy> bitemyapp, benzrf: You know that there are zeromq libraries on hackage right? (You're welcome to write a new one, but I just want to make sure you know someone already has)
17:16:07 <Guest87869> dmwit: im interested in know where a good explanation of "when things go from polymorphic to monomorphic" is
17:16:09 * hackagebot pubnub 1.1.1 - PubNub Haskell SDK  http://hackage.haskell.org/package/pubnub-1.1.1 (tsloughter)
17:16:17 <benzrf> lispy: yes but they are mostly simple direct api translations
17:16:31 <benzrf> lispy: i am thinking about how an FRP-based interface could work
17:16:37 <lispy> Guest87869: http://web.cecs.pdx.edu/~mpj/thih/ Follow along but implement everything yourself. :)
17:16:52 <Guest87869> ok
17:17:11 <benzrf> like, a PUSH socket could be used by binding an Event to it
17:17:26 <Zekka> lispy, dmwit, johnw: I added foralls to the signature of thunkConvention and to the signature of unclosedFunc: http://lpaste.net/4860261506995978240
17:17:30 <benzrf> and PULL by getting an Event of its recv
17:17:35 <benzrf> same w/ pub/sub
17:17:55 <benzrf> and for REP at least, i was thinking of something based on using a Behavior of a function to reply with
17:18:30 <lispy> Zekka: get rid of the $ for now. Without impredicative types it's likely to further confuse things.
17:18:40 <lispy> (and with impredicative types it most certainly will confuse us all!)
17:18:47 <Zekka> lispy - What effect do you think it has here?
17:18:49 <benzrf> whats impred. types anyway
17:18:56 <dmwit> lispy: ah, good catch
17:19:20 <lispy> dmwit: that was one of the first things I learned when I started my MS project...some lessons become etched in your memory...
17:19:31 <dmwit> Zekka: http://stackoverflow.com/q/9468963/791604
17:19:31 <Zekka> The errors have fallen, like scales from my eyes! (but I still want to know why they happened)
17:19:46 <lispy> :t ($)
17:19:47 <lambdabot> (a -> b) -> a -> b
17:20:06 <lispy> Zekka: that type is rank-1
17:20:10 <Zekka> Oh, so I should avoid $ with rank>1 types so as not to scare the typechecker?
17:20:12 <jle`> :t id `asAppliedTo` (undefined :: a -> b)
17:20:13 <lambdabot> (a -> b) -> a -> b
17:20:14 <lispy> Zekka: so when you use it on a rank-2 type, it restricts it
17:20:46 <dmwit> :t id `asAppliedTo` (\_ -> undefined)
17:20:46 <lambdabot> (t -> t1) -> t -> t1
17:20:57 <dmwit> :t [id, \_ -> undefined]
17:20:58 <lambdabot> [a -> a]
17:21:02 <dmwit> hehe
17:21:11 <jle`> :t id `asAppliedTo` const undefined
17:21:12 <lambdabot> (b -> a) -> b -> a
17:21:37 <lispy> benzrf: an impredicative Foo is a Foo that is self-referential. An impredicative type is one where a type variable may be instantiated to any type, including itself.
17:21:38 <Zekka> Thanks to your handiwork, my code now resembles Lisp
17:21:50 <jle`> > map (`id` 6) [(+3), (*2), (/3), (^2)]
17:21:52 <lambdabot>  [9.0,12.0,2.0,36.0]
17:22:11 <benzrf> lispy: .
17:24:08 <Zekka> Typechecker seems appeased -- thanks
17:24:39 <lispy> benzrf: in haskell terms, -XImpredicativeTypes generalizes -XRankNTypes by allowing forall to appear anywhere in the type. (With -XRankNTypes forall is permitted to the left of a function arrow). For example, (forall a. a -> a) -> b is rank-1, but [forall a. a] is impredicative.
17:24:45 <Zekka> And apologies for any frustration I might hvae caused
17:25:07 <benzrf> uh.
17:25:14 <benzrf> i know some o those words
17:25:14 <lispy> Zekka: no worries! Glad you have some working code now
17:25:25 <Zekka> lispy - Working? I don't think so
17:25:30 <albeit> jle`: In that example, just so I understand, `id` is called on ((+3) 6), correct?
17:25:35 <Zekka> I don't trust anything in a monad stack that large to work first try
17:25:38 <lispy> Zekka: it type checks, surely you can ship it?
17:25:39 <Zekka> monad transformer stack*
17:25:46 <albeit> jle`: Don't fully understand why that works
17:25:53 <Eduard_Munteanu> I think the impredicativity thing is better explained by reference to typesystems such as Coq's or Agda's where there's a proper hierarchy of universes.
17:25:58 <jle`> albeit: do you know about section syntax?
17:25:58 <Zekka> The real answer is that I'm rewriting a project from scratch for which I have about three-hundred lines to go
17:26:03 <dmwit> albeit: No, id is called on (+3) and 6.
17:26:07 <jle`> absence: (+ 3) 6 isthe same as (6 + 3)
17:26:12 <jle`> sorry, albeit
17:26:17 <Zekka> so there's a significant portion of the code that is just undefined again and again with typesigs bolted on
17:26:20 <Eduard_Munteanu> In Agda quantification isn't magic.
17:26:47 <jle`> albeit: so (`id` 6) (+ 3) is the same as (+ 3) `id` 6, which is the same as id (+ 3) 6, which is the same as (id (+3)) 6, which is the same as (+3) 6, which is the same as (6+3)
17:26:51 <Cale> sunw: There is no "replacing the old ones"
17:27:06 <albeit> jle`: Ahh okay
17:27:11 <lispy> Eduard_Munteanu: I think it's just -XImpredicativeTypes that is weird.
17:27:18 <jle`> it was a rather roundabout way to demonstrate that ($) is just id
17:27:26 <Eduard_Munteanu> If you quantify over Set, then that thing is in Set_1. But in Haskell types quantifying over * are still in *.
17:27:55 <Cale> sunw: If you want actual mutation to take place, there's always IORef, but for something like this, you'll usually just see the list made into a function parameter.
17:27:59 <Eduard_Munteanu> Hence "impredicative".
17:28:08 <dmwit> In Haskell, types can't quantify over *.
17:28:17 <dmwit> They quantify over a fictional kind which only permits monomorphic types.
17:28:25 <dmwit> -XImpredicativeTypes permits them to quantify over *.
17:29:04 <Cale> sunw: Applying the function to different arguments results in that parameter being bound to different values then
17:29:08 <Eduard_Munteanu> By "quantify over *" I mean forall (a :: *). ...   ::  *
17:29:26 <dmwit> Eduard_Munteanu: What is the kind of the type "forall a. a"?
17:29:27 <Cale> sunw: and you can even make that recursive of course
17:29:41 <Eduard_Munteanu> dmwit: *
17:29:48 <dmwit> Eduard_Munteanu: Then I mean the same thing you do.
17:30:47 <Cale> Eduard_Munteanu: Despite what :k Maybe says, Maybe (forall a. [a] -> [a]) doesn't actually work
17:31:03 <Cale> (unless you turn on ImpredicativeTypes)
17:31:19 <Eduard_Munteanu> Cale: yeah, I know
17:32:13 <dmwit> Actually, I don't think that's the important bit.
17:32:13 <Eduard_Munteanu> Which is the sensible thing because 'forall a. [a] -> [a]' shouldn't be in *.
17:32:24 <dmwit> That's just a hack to catch cases where you would be quantifying over * earlier.
17:32:31 <Cale> Ah, so that's the disagreement :)
17:32:51 <mada> I'm making this simple simulation/game in haskell. I have two lists, each a team, and they basically shoot each other in turns in a 'last team standing' fashion. So far I've handled state by hand, which is super painful
17:33:37 <mada> I want to use the state monad to keep track of this instead. But I'm not clear on these two levels: the list of teammates, and the teammates themselves. I need to mutate the individual teammates, but never to add or remove one
17:34:26 <Cale> mada: The State monad is equivalent to parameter passing, so where you might've written a function of type  s -> (s,a)  by hand, you now write an action of type  State s a
17:34:49 <Cale> (i.e. where your function would take the initial state, and produce a final state along with some result)
17:34:53 <startling> mada, you could refer to each teammate by index, or name, or some other unique property
17:35:31 <mada> Cale: right. So my state wouldn't be of type [Unit] -> ([Unit], a), but Unit -> (Unit, a) instead, is that correct?
17:35:38 <startling> *unique, immutable property
17:35:42 <Cale> Depends on how your current program works
17:35:56 <mada> the particular modification is some sort of attack performed from one unit to another random enemy unit
17:36:17 <mada> as it attacks it modifies one and only one unit's "HP"
17:36:20 <startling> mada, one way would be "State (Map Identifier Unit)"
17:37:46 <mada> startling: Right, hadn't thought of the entire map
17:38:12 <Cale> Now, sure, this might allow for operations on the state that you don't actually want to make possible
17:38:13 <mada> so far each team is a name and an (IntMap Unit)
17:38:24 <lispy> mada: you could use smart constructors and module level hiding to make it so that once the list of players is passed in it can only be reference through a special function.
17:38:33 <startling> yeah, agreed.
17:38:35 <Cale> But what you can (and perhaps ought to) do is to create a module and hide the implementation of your monad
17:38:48 <mada> right
17:38:52 <Eduard_Munteanu> How many teammates are there?
17:39:06 <lispy> so many teammates
17:39:12 <Eduard_Munteanu> If it's a fixed, small number perhaps a tuple makes sense.
17:39:26 <mada> Eduard_Munteanu: may vary, so far it's fixed but I'd like to extend this small toy program
17:39:33 <mada> in fact, pasting this
17:40:06 <mada> http://lpaste.net/103605
17:40:35 <mada> The idea is that each team takes turns attacking random units from the enemy team.
17:40:39 <Eduard_Munteanu> There are some tricks involving GHC extensions to make a length-indexed list, but that's fairly advanced.
17:40:39 <vermeille> I'm writing a VM in Haskell, and since this stuff deals heavily with low level things, pointers are quite soon a need. How do should I either use them or make it more functional?
17:41:05 <mada> What actually concerned me the most is designing 'good' types.
17:41:13 <dmwit> I really don't think suggesting length-indexed lists to somebody who hasn't grokked State yet is pedagogically sound.
17:41:31 <Eduard_Munteanu> vermeille: what would you need pointers for?
17:41:46 <Eduard_Munteanu> It isn't. :)
17:42:04 <mada> On the other hand, I now know there exists something under that name
17:42:27 <vermeille> Eduard_Munteanu: you always needs pointers in a VM oO the first reason is because the bytecode I use uses them
17:42:41 <Zekka> I'm writing a VM that uses no pointers at all
17:42:49 <Eduard_Munteanu> vermeille: what bytecode?
17:43:15 <lispy> vermeille: there are sooo many design choices here :)
17:44:36 <dmwit> mada: So. Where you currently have Army -> IO Army, one possibility would to use StateT IO Army () instead.
17:45:07 <Cale> vermeille: You could use mutable (unboxed?) arrays or vectors. Or if you care a bit more about presentation than performance, you could use Data.IntMap (which will still be reasonably quick given that it's an immutable structure)
17:45:32 <mada> dmwit: so, shoving the entire two armies inside the state
17:45:49 <dmwit> mada: Yes, everything that can possibly change will need to be inside the state.
17:45:58 <STARTLING> it depends how your pointers look.
17:46:05 <dmwit> mada: I see from a very slightly more careful look that you actually always have exactly two armies, not one.
17:46:09 <mada> my main problem right now is having to randomly select a target unit from the enemy army, doing the 'attack', and 'updating' this very same unit in the enemy army, and then returning the 'new army'
17:46:25 <dmwit> mada: So you would want to use (Army, Army) or similar instead of Army.
17:46:32 <mada> which sounds like state 101, but I wonder if keeping state of the entire thing isn't too broad
17:47:09 <mada> (too broad as in, not much of the plumbing to make a unit attack another would be cleared by adding the monad)
17:47:20 <dmwit> mada: There are tools available to allow you to "focus" on certain bits of the state in a State-ful computation. But I would recommend doing it by hand while getting used to State, then graduating to the fancy ways afterwards.
17:47:32 <dmwit> mada: And yeah, there will be a bit of plumbing.
17:48:03 <dmwit> mada: But when you're ready for it, check out http://twanvl.nl/blog/haskell/overloading-functional-references and then take a look at the "lens" library or similar.
17:48:05 <Cale> mada: Write operations for acting on the various parts of your state, and then use those operations instead of get/put directly
17:48:34 <Cale> (lens will help you write those operations more cleanly, but you should still write them)
17:48:37 <dmwit> Also listen to Cale. He's forgotten more about practical Haskell use than many of us know. =)
17:48:43 <mada> is it possible to focus a lens into a particular element in an IntMap, and then shove a modified element in that place?
17:49:05 <Cale> mada: yes
17:49:06 <Eduard_Munteanu> mada: yes
17:49:09 <benzrf> hmmmmm
17:49:23 <benzrf> State s a <-> s -> (s, a) right
17:49:31 <Cale> benzrf: That's right
17:49:31 <dmwit> ?unmtl State s a
17:49:31 <lambdabot> s -> (a, s)
17:49:35 <benzrf> therefore
17:49:36 <dmwit> WRONGO!
17:49:45 <dmwit> But pretty close. ;-)
17:49:46 <startling> > over _1 (+ 1) (0, 100)
17:49:47 <benzrf> State s (State s a)...
17:49:47 <lambdabot>  (1,100)
17:49:50 <benzrf> @untml State s (State s a)
17:49:50 <lambdabot> Maybe you meant: unpl unmtl
17:49:50 <Cale> dmwit: (a, s) <-> (s, a) as well
17:49:55 <benzrf> @unmtl State s (State s a)
17:49:55 <lambdabot> s -> ((State s a), s)
17:49:59 <dmwit> Cale: yeah =)
17:50:03 <dmwit> unmtl--
17:50:08 <Eduard_Munteanu> '(,) s' would imply (s, a)
17:50:16 <dmwit> ?unmtl s -> ((State s a), s)
17:50:16 <lambdabot> s -> ((State s a), s)
17:50:20 <benzrf> s -> (s -> (a, s), s)
17:50:21 <dmwit> ?unmtl s -> (State s a, s)
17:50:21 <lambdabot> s -> (State s a, s)
17:50:26 <dmwit> seriously??
17:50:34 <mada> Cale: would you please elaborate on 'writing operations for acting on varios parts of the state, and use those instead of get/put'?
17:50:47 <benzrf> therefore join on State s is
17:51:00 <mada> I don't think there's much of the state I need to modify, save the 'hp' of single units
17:51:09 <dmwit> mada: For example, you might try to write modifyFirstArmy :: (Army -> Army) -> StateT IO (Army, Army) ()
17:51:10 <Eduard_Munteanu> mada: get/put work on the entire state, rather than the part you need
17:51:24 <Cale> mada: I mean, whatever sorts of simple operations make sense in the context of your program, like damaging individual units, or checking their hitpoints
17:51:40 <dmwit> mada: or modifyNthSoldier :: Int -> (Soldier -> Soldier) -> StateT IO (Army, Army) ()
17:51:43 <dmwit> or whatever
17:51:48 <mada> right, so these functions would be like super simplified lenses
17:51:53 <dmwit> yes
17:51:58 <benzrf> join m arg = let (a, s) = (m arg) in a s
17:52:00 <mada> (in their 'what-they-do')
17:52:07 <Cale> mada: Or indeed, you can write a more generic operation which acts on an individual part of the state using a function
17:52:09 <benzrf> :t \m arg -> let (a, s) = (m arg) in a s
17:52:09 <lambdabot> (t2 -> (t1 -> t, t1)) -> t2 -> t
17:52:21 <benzrf> neat.
17:52:51 <benzrf> no wait.
17:52:57 <benzrf> oh ok yeap
17:53:03 <mada> ok, I'll give this some more thought and start
17:53:08 <mada> thank you all
17:53:12 <lispy> mada: (at the risk of their being too many chefs in the kitchen) one change I would work towards in your code is removing the IO that you currently have. You appear to use it for two things: a) printing and b) randomRIO. For the latter one, we could plumb through the random number generator (and initialize it in main). To get rid of the prints you'd extend AttackResult or make a data type.
17:53:19 <dmwit> benzrf: You might like http://stackoverflow.com/a/11235218/791604
17:53:30 <lispy> mada: and you'd also need a step a step that takes between turns that prints the results
17:54:00 <vermeille> Eduard_Munteanu: the bytecode I invented (which is almost a plagiarism of .NET's)
17:54:13 <mada> lispy: thanks, that's a good thought. I actually fought a bit with the random parts because there's random in two parts: selecting target units, and getting a random 'damage'
17:54:18 <Guest87869> or put the random generator in the state , or ;)
17:54:19 <Eduard_Munteanu> vermeille: are you interpreting or JIT-ing it?
17:54:41 <vermeille> Eduard_Munteanu: both, I'm just writing the interpret now, the jitter will come after
17:54:47 <dmwit> I think it's quite natural to use MonadRandom to avoid putting the generator in the state.
17:54:50 <mada> I hadn't thought of adding the random generator to the state
17:55:17 <mada> oh I see
17:55:33 <startling> you can use IO instead, if you're already in IO
17:55:34 <Guest87869> monad stacks yummy
17:56:25 <dmwit> I have implemented Cont and still don't understand it. wat do
17:56:31 <vermeille> Cale: an IntMap... why not, I feel like I have the inverse issue: some Haskell objects I need to take the address of (while manipulating my stack for instance)
17:56:49 <lispy> dmwit: write some programs that use iut?
17:56:57 <Cale> vermeille: You can't rely on the addresses of Haskell values. They move around.
17:57:05 <lispy> dmwit: evaluate them by hand?
17:57:06 <dmwit> lispy: I may be forced to! Terrible. =)
17:57:09 <startling> dmwit, writing code in explicit continuation-passing style might help
17:58:04 <Cale> vermeille: (instantaneously and unpredictably at any point respect to the program execution/evaluation)
17:58:37 <Cale> i.e. the garbage collector will move things around on you, and so actual pointers to Haskell values are rarely meaningful
17:59:21 <Cale> If you want a proper pointer, you could use the FFI stuff to allocate memory and poke Storable values into it
17:59:31 <vermeille> Cale: true, there's maybe another way to represent that, so. Like, I may want to return back the eventually modified arguments aside with the return value
17:59:59 <Eduard_Munteanu> Argh, persistent is annoying. Not only you can't derive from existing definitions, but you can't split them in multiple migrations. :(
18:00:01 <Cale> If you're writing a VM, you should have control over how you represent the VM's memory.
18:00:23 <vermeille> Cale: what do you think is the better way? at one point, my bytecode will have to implement something like "push the address of the nth parameter on the stack"
18:00:42 <Cale> Well, in any representation, that shouldn't be too terrible.
18:00:54 <dmwit> I feel like you are mixing VM addresses and host addresses in your mind.
18:00:58 <startling> ^
18:01:01 <lispy> that
18:01:02 <Guest87869> a simple linked list is a stack ;)
18:01:11 <vermeille> that's what will actually be done when jitting, but while dealing with haskell values....
18:01:31 <Cale> IntMap will be nicer to debug and reason about, I believe, but if performance matters to you, or the programs you'll be running are of really significant sizes, will probably not be the nicest choice
18:01:50 <Cale> Likely a mutable unboxed vector would work well
18:03:09 <Cale> (Are you writing a toy, or something real?)
18:03:36 <vermeille> Cale: I'm just prototyping now (the "real" program will be written in C, I'm doing a proof of concept now)
18:04:15 <SparkySparkyBoom>  
18:04:53 <vermeille> It's clearly a toy right now. But since it's done to improve my skills, I'm taking it seriously :) And why not, I have some hope to make something useful (but not with the Haskell implementation)
18:06:15 * hackagebot transformers 0.4.0.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.4.0.0 (RossPaterson)
18:06:22 <Guest87869> vermeille: then implement it in the simplest way
18:06:57 <vermeille> https://bitbucket.org/Vermeille/functionality if you want more information
18:08:06 <vermeille> Guest87869: I don't know what is the simplest way :) I just don't want to go in a wron direction if someone can point me to a better solution
18:08:10 <lispy> vermeille: you might also look at harpy. I dunno if it's still maintained but if nothing else it should give you a roadmap for one way of doingit.
18:08:48 <vermeille> lispy: I already know Harpy (but never used it), that's fairly cool.
18:09:01 <Guest87869> vermeille: you can represent "heap" with a Map and "addresses" are the keys
18:09:46 <vermeille> Guest87869: how would that work for structs? there is not a 1-to-1 mapping
18:10:09 <Guest87869> there not a 1to1 mapping between what and what
18:10:46 <vermeille> You have the adress of the struct, then, few byte away, the address of a field INTO the struct
18:11:08 <vermeille> if you write in one, you have to see the change in the other
18:11:19 <Guest87869> well, if you are emulating pointer arithmetic semantics, then you need to use a giant Vector
18:12:12 <Guest87869> but what language are you designing that would want pointers
18:14:01 <pavonia> I'm trying to parse a file format that has various sections that can occur in arbitrary order into a record type using Parsec. Any suggestions how to deal with the arbitrary order of the secions?
18:14:04 <vermeille> You could want pointers for handling references and stuff, even if you don't exactly expose them in your language
18:15:02 <Guest87869> if the goal is to interpret some program in a language that doesnt have pointers, then you might not need pointers at all anywhere
18:15:29 <Guest87869> whatever the VM is that the language is defined against, implement that instead
18:16:44 <lispy> pavonia: WHile I've never used it, I think that's what this module is for: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Perm.html
18:17:40 <pavonia> Uh, nice
18:17:43 <jophish> If I declare 'i = i' at the top level of a module, does it have type forall a. a?
18:17:54 <vermeille> I don't exactly know what I want, I'm not a VM designer expert (nor I am with languages), I just need a base implementation to manipulate the concepts I wrote on my piece of paper, play with them, what is redundant, which patterns emerges and could be optimized, etc, so that I have a good assembly
18:17:54 <shachaf> jophish: You should ask ghci. :-)
18:18:13 <shachaf> The answer is yes.
18:18:16 <benzrf> :t let a = a in a
18:18:17 <lambdabot> t
18:18:17 <lispy> :t let i = i in i
18:18:17 <jophish> shachaf: How can I guess ghci to give me the quantifiers?
18:18:18 <lambdabot> t
18:18:32 <shachaf> Oh.
18:18:37 <shachaf> -fprint-explicit-foralls or something.
18:18:44 <jophish> ah, super
18:18:46 <jophish> thanks
18:20:44 <lispy> vermeille: Have you considered implementing it as an interpreter/emulator first and then changing it over to jit?
18:21:23 <b3tamax> vermeille: More power to you.
18:22:35 <vermeille> lispy: ofc, for now I just want an interpreter, I just keep in mind that I will want to jit it after I'm satisfied with my assembly
18:23:40 <vermeille> b3tamax: what is more power?
18:23:47 <lispy> vermeille: for an interpreter you could use Vector Word8 for your memory and it would be a nice simple design.
18:24:22 <Guest87869> if the language supports pointer arithmetic
18:24:27 <lispy> (well, you'd want one of the mutable and unboxed vectors technically)
18:24:40 <Guest87869> or not, but would seem to be more complex
18:24:42 <lispy> Guest87869: the language is inspired by .NET CLR
18:25:15 <lispy> at least, I think vermeille said that
18:26:17 <vermeille> Yes, the asm is heavily inspired by .NET CLR, which define both "semantic" instructions (modify the field of that object) and some more low level (push the address of the 3rd parameter on the stack)
18:27:33 <fryguybob> vermeille: I've used  Map Address Word32  for this sort of thing.
18:27:40 <vermeille> That's why the simple array of Word8 does not fit (we are losing semantic information), nor does the IntMap (we lose the low level aspect with pointer offsets and stuff)
18:27:53 <Guest87869> im not familiar with CLR, but modifying "a field" and putting an address onto a stack do not require any pointer support
18:27:59 <Guest87869> necessarily
18:28:04 <fryguybob> vermeille: If you have a sturct just be sure to add all the addresses to the map.
18:29:08 <lispy> vermeille: you'll need to be able to map the CLR objects to bytes in memory.
18:29:26 <lispy> I don't mean by address here, I mean in terms of layout
18:30:00 <vermeille> Guest87869: how would you manipulate an address without pointer support? (real question)
18:30:27 <Guest87869> Map Address Object
18:30:39 <lispy> vermeille: what manipulations do you want to support?
18:30:53 <Guest87869> oops, read manipulate as implement
18:31:41 <vermeille> lispy: I don't know. I think that being able to technically implement C would not be a bad thing. I know that the model is proven to work for decades
18:31:44 <Hafydd> @hoogle (a -> b) -> [a] -> [(b,a)]
18:31:45 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
18:31:45 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
18:31:45 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
18:32:07 <lispy> vermeille: I'd step back and start simpler. And go way simpler than you need to. For instance, go make a brainfuck interpreter that uses Array or Vector for the memory.
18:32:12 <Guest87869> implementing the C vm and a higher level bytecode might be very different
18:32:57 <saurik> Hafydd: (a,b) is probably more common (and then you can reverse the values if you need the opposite)
18:33:11 <vermeille> Guest87869: if I'm able to compile C to my VM's bytecode, I'd be happy. That's a good start.
18:33:34 <vermeille> I will then rework and see what could emerge which could be interesting
18:33:44 <Guest87869> vermeille: in which case, /that/ compiler would be modeling the C vm in its own world, not in haskell
18:34:12 <Guest87869> in terms of CLR
18:34:12 <vermeille> I'm sorry?
18:34:46 <jle`> Hafydd: what would the a in the second part of the tuple be, the original value?
18:35:41 <vermeille> lispy: Brainfuck is way more simple and really straigthforward, I already did it a couple of times in different languages. The problem I have now does not even exists in that case.
18:36:12 <Hafydd> Oh, I actually meant this:
18:36:18 <Hafydd> @hoogle (a -> b) -> [a] -> [(b,[a])]
18:36:19 <lambdabot> No results found
18:36:32 <ReinH> :t \f -> map (id &&& f)
18:36:33 <lambdabot> (c -> c') -> [c] -> [(c, c')]
18:36:40 <ReinH> Hafydd: what should that do?
18:36:46 <fryguybob> vermeille: Do you want a map where the keys are intervals instead of single addresses?
18:37:57 <benzrf> :t (***)
18:37:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:37:59 <benzrf> :t (&&&)
18:37:59 <vermeille> fryguybob: I need a "map" where `addr` maps to a value and `addr + n` to a subpart of this value.
18:37:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:38:03 <Hafydd> It should group the list into sublists, by equality on the value of the given function, tagging each sublist with the value.
18:38:04 <benzrf> i never remember which is which
18:38:06 <benzrf> >.>
18:38:08 <lispy> vermeille: Right. That's actually the point. It's way simpler than the current case. So now, how would you extend the bf interpreter that uses Array/Vector of bytes to encode some simple objects (you know, like a struct { int x; int y; })
18:38:24 <Guest87869> vermeille: any model you implement which is turing complete could in principle have a C implementation, if thats what you are worried about
18:38:34 <ReinH> Hafydd: then you need an Eq b constraint
18:38:40 <Hafydd> It's possible to do using -XTransformListComp and GHC.Exts.the, but since the is not a total function, I dislike that.
18:38:45 <benzrf> is there anything for which it makes sense to have an arrow instance besides functions and trivial wrappers around em
18:39:14 <lispy> benzrf: signal functions in yampa
18:39:16 <Hafydd> Yes.
18:39:53 <fryguybob> vermeille: If you had keys as intervals then the lookup could tell you the offset and the value.  But you can get multiple matching entries so you would want to decide if that is ok or not and what you want to do with it.
18:40:02 <ReinH> Hafydd: seems like Map b [a] would be much more efficient than [(b,[a])]
18:40:07 <ReinH> and easier to write
18:40:48 <ReinH> ofc then you need Ord rather than just Eq
18:41:01 <Hafydd> ReinH: like Data.List.group, it doesn't change the order of any elements.
18:41:32 <fryguybob> vermeille: But I would only do this sort of thing rather then just a vector of bytes or words if I wanted some high-level debugging or checking.
18:41:45 <lispy> vermeille: once you have a way to encode these simple structs you add in a pointer type.
18:41:55 <vermeille> lispy: If I'm in C and targetting x86 or some usual native architecture, I just pack the struct, and consider a bunch of bytes to be my struct. But during the compilation, I lose the total ability to be able to "reconstruct" my struct. My CPU never knows it is manipulating a struct, x86 asm is not typed at all, etc, in that case, the architecture is almost not typed at all, etc
18:41:59 <ReinH> Hafydd: ah
18:42:17 <Fuuzetsu> is there a function somewhere that merges concat . replicate …?
18:42:31 <Fuuzetsu> :t replicate
18:42:31 <lambdabot> Int -> a -> [a]
18:42:48 <fryguybob> vermeille: Well CLR encodes the types
18:42:51 <Fuuzetsu> @hoogle Int -> [a] -> [a]
18:42:51 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:42:52 <lambdabot> Data.List drop :: Int -> [a] -> [a]
18:42:52 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:43:17 <benzrf> what is yampa >.>
18:43:23 <lispy> vermeille: yes, that's correct! ... but remember that the compiler generated the assembly code in a very specific way when it deals with the those structs.
18:43:27 <Iceland_jack> concat . replicate is a type error
18:43:35 <Iceland_jack> :t (concat .) . replicate
18:43:36 <lambdabot> Int -> [a] -> [a]
18:43:50 <vermeille> Guest87869: I'm worried about my asm to be turing complete, useful, and convenient
18:43:52 <Fuuzetsu> actual code: psers = map (string . encodeUtf8 . concat . flip replicate "=") [6, 5 .. 1]
18:44:12 <vermeille> fryguybob: I know they do, though I don't know how.
18:44:34 <Guest87869> vermeille: asm itself hasnt been the convenient way to do stuff for a while
18:45:00 <lispy> benzrf: it's an implementation of frp
18:45:18 <lispy> benzrf: http://www.haskell.org/haskellwiki/Yampa
18:45:30 <benzrf> oh
18:46:26 <vermeille> fryguybob: I suppose they have a something like a "mirror memory" which instead of containing values contains types and points to the "memory of value". Don't have any clue for that.
18:46:27 <lispy> vermeille: you might want to compile some C (or C#) examples and dissassemble them to see what you get.
18:47:11 <fryguybob> vermeille: Well if you want the interval sort of thing you could build it out of the IntervalMap in fingertree package
18:48:52 <lispy> benzrf: keep in mind: one of the tricky things about answer your question about arrows is that some of the things you model in haskell may not be a function but functions are a handy primitive so we're likely to use it in our model.
18:49:45 <lispy> benzrf: in the case of yampa they do use functions for part of the definition of signal functions, but they do it as an implementation detail. SignalFunction is really what they are after.
18:49:53 <blast_hardcheese> I'm starting out in Haskell again, having problems parsing type errors; Could someone please explain how to read this? http://blast.hardchee.se/~/files/2014-05-04/error.log
18:52:12 <benzrf> blast_hardcheese: uh... why are you trying to treat the result of your hanoi function as an IO action
18:52:27 <benzrf> and why are you binding it to x instead of throwing it away
18:53:00 <geekosaur> presumably they want to do something with it later
18:53:24 <geekosaur> but the other part is correct; it looks like your hanoi function is pure, so you want to use let instead of <-
18:53:26 <blast_hardcheese> benzrf: I've got a bunch of other lines commented out right now, they got stripped.
18:53:53 <blast_hardcheese> geekosaur: Ah, hmm
18:54:02 <geekosaur> and the error message is because it's looking at this pure function and seeing that it can find a Monad instance for functions and decompose your tuple into a constructor function
18:54:52 <geekosaur> so it uses the Monad instance for functions in order to get something it can bind, and then gets confused because you told it IO
18:55:27 <blast_hardcheese> That makes sense
18:55:55 <blast_hardcheese> I'm coming from Scala with a little bit of Erlang, so these concepts are not new to me, I just need to re-learn what little Haskell syntax I once knew
18:56:06 <geekosaur> (this is a good example of why we don't use more than 2-tuples very often; the compiler is smarter than most programmers and will try things nobody ever expected if you give it half a chance, leading to this kind of weird type error)
18:56:19 <geekosaur> let x = hanoiEvalRec ...
18:56:30 <geekosaur> in place of x <- hanoiEvalRec ...
18:57:03 <blast_hardcheese> I tried that, but now it's suggesting that I can't use let inside a do block, probably because do is just syntactic sugar
18:57:25 <pyon> blast_hardcheese: Actually, "let x = ..." and "x <- ..." mean different things.
18:57:26 <geekosaur> let works in a do block fine... show actual code and full error?
18:57:30 <geekosaur> @paste
18:57:30 <lambdabot> Haskell pastebin: http://lpaste.net/
18:57:38 <geekosaur> my guess would be indentation
18:58:30 <blast_hardcheese> http://lpaste.net/ is blocked on Coffee Bean's wifi due to "Peer-to-Peer Filesharing"
18:58:32 <blast_hardcheese> awesome.
18:58:45 <geekosaur> cute
18:58:51 <blast_hardcheese> http://blast.hardchee.se/~/files/2014-05-04/hanoiEval.hs
18:58:56 <sunw> is there some neat way to check whether a string is a number rather than checking if it's not null and applying all to Data.Char.isDigit?
18:59:26 <blast_hardcheese> I thought "do" + curlies and semicolons would not rely on indentation, is this incorrect?
18:59:27 <geekosaur> sunw, that's probably the best way (assuming you don't care about floating point or signs)
18:59:46 <Guest87869> sunw: if youre using parsec, you can simply parse it using the integer parser
19:00:09 <geekosaur> oh. it partially disables it. but you have the semicolon at the end of the line and then it inserts another semicolon because of the line break, I think
19:00:21 <Guest87869> > reads "1234" :: Integer
19:00:22 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
19:00:22 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
19:00:32 <Guest87869> > reads "1234" :: [(Integer,String)]
19:00:34 <lambdabot>  [(1234,"")]
19:00:39 <Guest87869> > reads "abcd" :: [(Integer,String)]
19:00:40 <lambdabot>  []
19:00:46 <geekosaur> sunw: there's a readMaybe somewhere, IIRC, otherwise you can use read and trap the exception, or reads but see that result ^^
19:01:16 <Guest87869> > reads "1234abcd" :: [(Integer,String)]
19:01:18 <lambdabot>  [(1234,"abcd")]
19:01:19 <lispy> geekosaur: you need 7.6.x for readMaybe
19:01:22 <lispy> (or newer)
19:01:31 <geekosaur> blast_hardcheese, anyway not only is let permitted in do but there's a variant that fits in specifically with do syntax
19:02:48 <blast_hardcheese> geekosaur: Same syntax, different de-sugar?
19:03:17 <geekosaur> normal let syntax is let {bindings} in {expression}
19:03:24 <geekosaur> in a do you can just have let {bindings}
19:03:39 <lispy> vermeille: I just remember something about jit. You'll probably want to use mmap to allocate the memory. You'll also want to use mprotect on the pages. at first they should be mutable so you can write the assembly to them and before you execute the code you'll need to make them read and execute only.
19:03:44 <dmwit> blast_hardcheese: let is *also* a block herald
19:03:54 <dmwit> blast_hardcheese: so let { x = hanoiEvalRec ... };
19:04:01 <dmwit> blast_hardcheese: Otherwise the ; is part of the let.
19:04:10 <geekosaur> oh, right, that semi is part of the bindings and then it's confused how to parse the resy
19:04:17 <sunw> cool, thanks
19:05:01 <blast_hardcheese> dmwit: So semis are required unless you are running up against the end of a block
19:05:10 <dmwit> uh?
19:05:15 <blast_hardcheese> No?
19:05:20 <dmwit> I don't know what that means.
19:05:27 <dmwit> So I don't know whether you're right or not.
19:05:49 <blast_hardcheese> Oh, I'm actually confused. I read { let x = ... };
19:06:01 <geekosaur> if you use explicit braces then you need to use explicit semicolons as well, but need to then watch out for other things that introduce layout (like let) and generally you are forced to use explicit braces with those as well
19:06:02 <blast_hardcheese> let {x = ...; y = ... }; ?
19:06:09 <dmwit> yes
19:06:16 <blast_hardcheese> that makes sense.
19:06:18 <geekosaur> this is the price you pay for being explicit about braces instead of using layout
19:07:05 <blast_hardcheese> Let me go find a vim plugin for haskell to make my life easier-- Having to space-indent every newline was getting annoying.
19:07:18 <dmwit> I suspect you could put the semicolon on the next line at any indentation that doesn't match "x" and also have it work.
19:07:21 <dmwit> :set ai
19:07:25 <dmwit> (seriously)
19:07:30 <dmwit> see also: http://dmwit.com/tabs
19:07:49 <dmwit> Which has configuration advice that is overkill if you plan on only using spaces but has some suggestions even for space-only people.
19:08:02 <Guest87869> blast_hardcheese: smart tabs ;)
19:08:22 <blast_hardcheese> dmwit: I've got autoindent on already
19:08:38 <blast_hardcheese> indentexpr is empty though, it doesn't know what to do
19:09:00 <dmwit> My indentexpr is also empty.
19:09:04 <blast_hardcheese> Hmm.
19:09:06 <dmwit> So it must be something else that's making ai not work.
19:09:16 <blast_hardcheese> ai is on and newlines go back to ^
19:09:41 <dmwit> Perhaps you *also* have smartindent or cindent on.
19:09:44 <blast_hardcheese> (rather, it goes back to no indent at all, since ^ starts after indent)
19:09:53 <dmwit> (Just guessing after reading the help for "autoindent".)
19:09:55 <blast_hardcheese> I do not
19:10:54 <blast_hardcheese> :qa
19:11:01 <lispy> vermeille: mmap because that lets you avoid the heap (executing code in the heap is bad and selinux will kill your process). You don't want pages of memory with code in them to be both executable and writeable because then an attacker can mutate the code to run whatever they want (such as in traditional buffer overflow exploits)
19:11:03 <blast_hardcheese> whoops.
19:13:28 <nisstyre> lispy: you prefer grsec or selinux?
19:13:46 <lispy> nisstyre: I'm not familiar with grsec
19:14:48 <nisstyre> lispy: it implements a RBAC system (role-based access control) as well as a slew of kernel patches to make things more secure
19:15:11 <nisstyre> it was around before selinux :p
19:15:25 <nisstyre> https://en.wikipedia.org/wiki/Grsecurity
19:15:31 <b3tamax> SELinux is Satanic.
19:18:51 <sunw> how do you use "show" in a function returning an IO since "show" returns a String? is doing:  print . show $ "test " ++ show x  correct?
19:19:23 <dmwit> That's correct, but calls show at least two times more than you probably intended.
19:19:30 <Iceland_jack> there's no need for the first show
19:19:35 <dmwit> putStrLn $ "test " ++ show x -- probably calls show the correct number of times.
19:19:40 <Iceland_jack> :t \x -> print . show $ "test " ++ show x
19:19:41 <lambdabot> Show a => a -> IO ()
19:19:46 <Iceland_jack> :t \x -> print ("test " ++ show x)
19:19:47 <lambdabot> Show a => a -> IO ()
19:19:57 <dmwit> ?src print
19:19:57 <lambdabot> print x = putStrLn (show x)
19:20:07 <Iceland_jack> you'd want putStrLn anyway ↑
19:20:35 <jle`> is there a special name for liftA2 (,)
19:20:46 <dmwit> Also possible: putStr "test " >> print x
19:20:50 <dmwit> jle`: I don't think so.
19:20:57 <lispy> nisstyre: also, as I'm not a sysadmin I don't worry about running selinux :)
19:21:03 <jle`> it's pretty important in the monoidal functor formulation of Applicative
19:21:20 <jle`> it's...basically the monoidal operation in the monoidal functor formulation of applicative
19:21:41 <dmwit> Do you mean a name in mathematics or a name in the extended standard library?
19:21:49 <jle`> some sort of commonly established name
19:21:51 <jle`> in general
19:22:13 <jle`> oh
19:22:22 <jle`> the typeclassopedeia calls it (**)
19:22:50 <dmwit> There is probably a name for it in CT.
19:23:05 <jle`> http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
19:23:13 <sunw> oh nice, thanks
19:23:42 <jle`> yorgey doesn't give it a name :/
19:24:36 <jle`> byorgey: hi, is there a name for (**) ?
19:24:50 <jle`> besides just (**) of course
19:24:52 <jle`> heh
19:24:59 <Guest87869> dont try to pronounce haskell ;)
19:25:21 <jle`> was just looking for something to refer to it by
19:25:23 <dmwit> I guess it's just called "mu".
19:25:58 <jle`> honestly (**) and unit feel like a more natural formulation of Applicative to me
19:26:00 <dmwit> See also http://ncatlab.org/nlab/show/monoidal+functor
19:26:33 <dmwit> To me, too. But Monad and Applicative choose the operations we use most often as programmers rather than the operations that seem most elegant.
19:27:37 <shachaf> Now that we have {-# MINIMAL #-} maybe bigger type classes won't hurt...
19:27:41 <jle`> (**) seems to fit the idea of what Applicative was "meant for"...liftA2, liftA3, etc, for me.
19:28:05 <shachaf> Implementing liftA2 rather than (<*>) seems nicer to me.
19:28:09 <shachaf> Not that there's a big difference.
19:28:20 <dmwit> "Applicative was meant for liftA2, liftA3, etc." [citation needed]
19:28:32 <jle`> :P
19:28:38 <jle`> i used quotes so i am allowed liberties
19:28:42 <jle`> :)
19:28:45 <dmwit> ;-)
19:28:57 <lispy> nisstyre: after skimming the feature sets, it seems that grsec has a lot more interesting features.
19:29:01 <Guest87869> >;)
19:29:18 <jle`> did people really sit down and say "i wonder how we can apply f (a -> b) to f a"
19:29:40 <jle`> i am guessing more likely they thought "i wonder how we can generalize fmap to arbitrary arity"
19:29:49 <jle`> but i was not around
19:30:25 <Guest87869> well you can do it by implementing <*> ;)
19:30:30 <startling> jle`, 'ap' came from parsing
19:30:37 <jle`> startling: oh
19:30:38 <startling> or, rather, the other ap did.
19:30:39 <jle`> hm
19:30:43 <jle`> that makes sense
19:30:51 <jle`> i can see ap coming up in parsing
19:30:55 <startling> then people realized "this is almost a monad, and more than a functor"
19:31:27 <jle`> so i guess before, people were happy with liftM2, liftM3 ... ?
19:31:32 <startling> the old ap was (<*>) :: f a -> f b -> f (a, b)
19:31:37 <jle`> i guess, why wouldn't they be
19:31:48 <startling> jle`: I guess so. that or do notation.
19:32:09 <jle`> i mean, if the idea of applicative as a standalone useful thing wasn't about, there wouldn't be a need to just make a typeclass just for liftM2, liftM3
19:32:17 <startling> well, there was 'ap'
19:32:33 <jle`> was the old ap m a -> m b -> m (a, b) ?
19:32:34 <startling> > (+) `liftM` Just 1 `ap` Just 2
19:32:35 <lambdabot>  Just 3
19:32:44 <startling> jle`: I don't think so.
19:32:48 <jle`> did they really do that :|
19:32:52 <startling> no idea!
19:32:55 <jle`> i would have thought
19:33:03 <jle`> > return (+) `ap` Just 1 `ap` Just 2
19:33:04 <lambdabot>  Just 3
19:33:14 <startling> ooh, fair enough
19:33:14 <jle`> ah i was always under the impression that you were around back in those times
19:33:30 <jle`> > liftM (+) `ap` Just 1 `ap` Just 2
19:33:31 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe (a1 -> a0 -> b)’
19:33:31 <lambdabot>              with actual type ‘m0 a10 -> m0 (a10 -> a10)’
19:33:33 <jle`> er
19:33:40 <jle`> > liftM (+) (Just 1) `ap` Just 2
19:33:42 <lambdabot>  Just 3
19:33:45 <jle`> oh yeah that is sorta awkward huh.
19:34:04 <jle`> well lukcily we live in a more progressive era
19:34:08 <startling> haha
19:34:29 <Guest87869> > liftM2 (+) (Just 1) (Just 2)
19:34:31 <lambdabot>  Just 3
19:34:46 <jle`> but i sometimes still do the return f `ap` x `ap` y `ap` z thing if i only have Monad m
19:34:50 <jle`> but i feel bad
19:35:13 <startling> well
19:35:41 <Guest87869> this makes sense to me with applicative but i cant intuitively understand your expression for monads jle`
19:36:04 <jle`> Guest87869: yes, i would rely on people to mentally substitute `ap` for <*>
19:36:09 <jle`> which is sort of not too desirablr
19:36:24 <Guest87869> ok but what does it mean in terms of >>=
19:36:29 <benzrf> Guest87869: ap is the same type as <*> but implemented over >>=
19:36:31 <benzrf> Guest87869: look
19:36:32 <benzrf> @src ap
19:36:32 <lambdabot> ap = liftM2 id
19:36:36 <jle`> heh
19:36:43 <benzrf> @src liftM2
19:36:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:36:43 <jle`> @src liftM2
19:36:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:36:46 <benzrf> haha
19:36:50 <Guest87869> ok
19:36:51 <jle`> yeah i have done that a few times here
19:37:07 <benzrf> Guest87869: in general, id f x == f xl1
19:37:08 <Guest87869> does x, does y, does z, apply f to them, return
19:37:18 <Guest87869> weird
19:37:20 <jle`> `ap` is an abstraction pretty far removed from (>>=) in my eyes
19:37:33 <jle`> especially if you chain them
19:37:35 * jle` shrugs
19:38:03 <jle`> i am writing an article and i am wondering how harmful it would be to introduce Applicative as only unit and (**)
19:38:11 <benzrf> :t (**)
19:38:12 <lambdabot> Floating a => a -> a -> a
19:38:15 <jle`> well
19:38:15 <benzrf> wah
19:38:19 <jle`> the yorgey (**)
19:38:23 <jle`> exactly >_>
19:38:23 <benzrf> yorgey?
19:38:25 <Guest87869> > 2 ** 0.5
19:38:27 <lambdabot>  1.4142135623730951
19:38:32 <jle`> http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
19:38:38 <dmwit> jle`: I see no harm in it.
19:38:45 <jle`> yorgey's (**) is liftA2 (,)
19:38:54 <dmwit> jle`: Will you also introduce Monad only in terms of return and join? =)
19:39:40 <shachaf> dmwit: And fmap.
19:39:55 <benzrf> join is more intuitive than >>= imo
19:40:05 <benzrf> although i cant deny that the latter is more practically uesful
19:40:07 <benzrf> *useful
19:40:09 <jle`> it's actually a thinly vield reinterpretation of the typical functor/applicative/monad relationships
19:40:23 <jle`> in this sense i'm actually introducing monad in terms of flip (>>=)
19:40:30 <benzrf> frankly
19:40:37 <benzrf> to me >>= seems more based on join than vice versa
19:40:55 <benzrf> to expain >>=, i'd say that you 'unwrap' the left side, feed it to the right side, then join the structures
19:40:58 <benzrf> or something along those lines
19:40:59 <jle`> fmap :: (a -> b) -> (m a -> m b)
19:41:01 <dmwit> jle`: If your argument for (**) over (<*>) is that it is more elegant, then let me suggest that join is more elegant than (=<<).
19:41:02 <benzrf> note on top of join
19:41:08 <jle`> flip (>>=) :: (a -> m b) -> (m a -> m b)
19:41:08 <benzrf> dmwit++
19:41:38 <benzrf> while if i had to describe join, it certainly would not be in terms of >>=!
19:41:38 <jle`> oh flip (>>=) is actually (=<<) >_>
19:41:41 <benzrf> jle`: lol
19:41:50 <benzrf> in two ways, even!
19:42:06 <dmwit> I'm sure that whoever wrote the definition of (=<<) had fun with it. =)
19:42:11 <dmwit> ?src (=<<)
19:42:11 <lambdabot> f =<< x = x >>= f
19:42:15 <dmwit> beautiful
19:42:29 <jle`> well the idea is that you have multiple tools to move functions (a -> b), (a -> b -> c), (a -> m b), etc, into some common form (m a -> m b), (m a -> m b -> m c), etc.
19:42:31 <jle`> dmwit: haha
19:42:38 <Guest87869> dmwit: looks like a dead bird
19:42:55 <dmwit> :t (<*>)
19:42:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:43:05 <dmwit> jle`: But... (<*>) fits that pattern better than (**) does.
19:43:23 <dmwit> It moves functions wrapped "inside" a functor to the common form.
19:43:36 <jle`> the domain of the transformation is functions on unwrapped values
19:43:44 <jle`> (a -> b), unwrapped a and b
19:44:01 <pavonia> Isn't Data.Text.Encoding able to handle BOMs?
19:44:08 <jle`> using the word wrapped loosely...darn, i had told myself i would never use it again
19:44:35 <shachaf> functions wrapped "inside" the functor :-(
19:44:35 <jle`> you can make normal functions like (a -> b) work on (m a -> m b), functions like (a -> b -> c) work on (m a -> m b -> m c), (a -> m b) work on (m a -> m b)
19:44:39 <dmwit> jle`: Right, so you have all these functions that return (m a -> m b), (m a -> m b -> m c), whatever... and then you throw in (**) which returns... m (a, b).
19:44:44 <jle`> well
19:44:46 <dmwit> jle`: That doesn't fit the pattern nearly as well.
19:44:54 <jle`> liftA2 is actually what is more important
19:44:58 <jle`> liftA3
19:45:20 <jle`> but liftA2 is easaily seen as liftA2 f x y = uncurry f (x ** y)
19:45:31 <jle`> i think
19:45:41 <jle`> that makes more sense than liftA2 f x y = f <$> x <*> y
19:45:43 <benzrf> i think (**) might have made more sense to me than (<*>)
19:46:15 <jle`> liftA2 f x y = uncurry f (x ** y) seems kinda neat to me.  the uncurry is unfortunate though
19:46:25 <dmwit> benzrf: By all means. But that doesn't mean it fits the pattern jle` is proposing. =)
19:46:26 <benzrf> don't you mean fmap (uncurry f) (x ** y)
19:46:32 <dmwit> jle`: liftA2 would fit your pattern much better than (**), yes.
19:46:34 <jle`> benzrf: ah yeah
19:46:36 <jle`> i mean that
19:46:40 <benzrf> ;)
19:46:51 <jle`> we should have some sort of operator for fmap . uncurry
19:47:26 <jle`> > let (~$) = fmap . uncurry in (+) ~$ (Just 1 ** Just 2)
19:47:28 <lambdabot>  No instance for (GHC.Show.Show b0)
19:47:28 <lambdabot>    arising from a use of ‘M209717501069774519415699.show_M2097175010697745194...
19:47:28 <lambdabot>  The type variable ‘b0’ is ambiguous
19:47:28 <lambdabot>  Note: there are several potential instances:
19:47:28 <lambdabot>    instance [safe] GHC.Show.Show
19:47:34 <jle`> oh
19:47:43 <jle`> > let (**) = liftA2 (,); (~$) = fmap . uncurry in (+) ~$ (Just 1 ** Just 2)
19:47:45 <lambdabot>  Just 3
19:47:47 <jle`> actually that's kinda silly heh
19:48:18 <jle`> > let (**) = liftA2 (,); (**$) = fmap . uncurry in (+) **$ (Just 1 ** Just 2)
19:48:19 <lambdabot>  Just 3
19:48:25 <ReinH> o_O
19:48:54 <jle`> ReinH: this is yorgey's (**)
19:49:01 <dmwit> The way I see it, you have two (or possible three) possible conflicting goals.
19:49:13 <dmwit> jle`: (By the way, he goes by byorgey on here.)
19:49:58 <jle`> yeah but i don't want to bother him with so many pings heh
19:50:05 <dmwit> whoops =P
19:50:40 <jle`> :t uncurry . uncurry
19:50:41 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
19:50:46 <dmwit> Possible goal 1, current choice in Haskell: reflect the way the thing is commonly used. Applicative in terms of (<*>), Monad in terms of (>>=)
19:51:07 <dmwit> Possible goal 2: reflect the mathematically elegant presentation. Applicative in terms of (**), Monad in terms of join
19:51:38 <dmwit> Possible goal 3: cute pattern in the types, everything returns (f a -> f b -> ... -> f r). Applicative in terms of liftA2, Monad in terms of (=<<)
19:51:50 <enthropy> @where sicp
19:51:50 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
19:51:59 <jle`> my goal is to answer the question "i have a function a -> ...", how do i make it a function "m a -> ..", and thus demonstrate that working on values inside contexts in haskell is no big deal
19:52:17 <dmwit> Doing Applicative in terms of (**) but Monad in terms of (=<<) seems like mixing goals to me.
19:52:23 <jle`> so the "pointed" operators are going to be the more important ones
19:52:36 <ReinH> dmwit: I suspect that if it weren't for do notation we'd be using join and >=> more than >>=
19:52:48 <jle`> i suspect =<<
19:52:55 <benzrf> :t (>=>)
19:52:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:52:58 <jle`> looking at how common ($) is
19:52:58 <dmwit> ReinH: We could argue counterfactuals all day, I'm sure.
19:53:01 <blast_hardcheese> Is >=> pronounced "fish"?
19:53:06 <ReinH> dmwit: we sure could :D
19:53:07 <startling> blast_hardcheese: yes.
19:53:10 <benzrf> fishy
19:53:13 <blast_hardcheese> startling: Excellent.
19:53:14 <jle`> (=<<) vs (<=<) is just ($) vs (.)
19:53:22 <startling> :t (<>~) -- there's this one, too
19:53:23 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
19:53:31 <jle`> we use both, frequently, today
19:53:46 <benzrf> in ruby we use ~> for specific version nums. on gems
19:53:52 <benzrf> i have heard it characterized as the 'spermy operator'
19:53:57 <benzrf> but <>~ is far spermier
19:54:03 <jle`> ~* is kinda spermy
19:54:04 <benzrf> i will let #ruby know that haskell has it beat
19:54:07 <startling> > _2 <>~ [1] $ ("oops", [2])
19:54:09 <lambdabot>  ("oops",[2,1])
19:54:14 <Guest87869> no ruby allowed
19:54:21 <Iceland_jack> @let school = ((<=<), (>=>))
19:54:22 <lambdabot>  .L.hs:141:11:
19:54:22 <lambdabot>      No instance for (Monad m0) arising from a use of ‘<=<’
19:54:22 <lambdabot>      The type variable ‘m0’ is ambiguous
19:54:22 <lambdabot>      Relevant bindings include
19:54:22 <lambdabot>        school :: ((b -> m0 c) -> (a -> m0 b) -> a -> m0 c,
19:54:28 <Iceland_jack> meh
19:54:41 <jle`> today, #haskell discusses operator sperminess
19:55:08 <blast_hardcheese> haha
19:56:09 <pyon> What does it mean for an operator to be "spermy"? :-|
19:56:21 <blast_hardcheese> I was going to say "Wait, <=< would be fish, >=> would be fishr" earlier, but I thought it would have been too OT or silly
19:56:26 <blast_hardcheese> I should have just gone for it
19:56:49 <carter> @tell yitz try -fno-full-laziness
19:56:49 <lambdabot> Consider it noted.
19:56:52 <jle`> > let (**) = liftA2 (,); (**$**$) = fmap . uncurry . uncurry in (\x y z -> x+y+z) **$**$ (Just 1 ** Just 2 ** Just 3)
19:56:54 <lambdabot>  Just 6
19:57:11 <jle`> i guess the (**) formulation is awkward in that it is harder to generalize to arbitrary arity
19:57:18 <jle`> than the <*> formulation
19:58:03 <jle`> > let (**) = liftA2 (,) in uncurry (+) <$> (Just 1 ** Just 2)
19:58:04 <lambdabot>  Just 3
19:58:07 <Guest87869> jle`: but you can provide the <*> as a utility function
19:58:29 <jle`> > let (**) = liftA2 (,); add3 x y z = x+y+z in (uncurry.uncurry) add3 <$> (Just 1 ** Just 2 ** Just 10)
19:58:31 <lambdabot>  Just 13
19:58:54 <jle`> yuck
19:59:24 <benzrf> :t uncurry . uncurry
19:59:24 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
19:59:28 * benzrf flinches
19:59:43 <jle`> well...it is straightforward as an extension of the two-argument version
19:59:44 <copumpkin> it isn't all that gross, honestly
19:59:46 <dmwit> benzrf: Wait until you see some code generated by ArrowSyntax.
19:59:57 * benzrf shudders
20:00:15 <jle`> copumpkin: yeah, it's not that bad looking, the yuck was in reference to how to generalize it to, say, 7-arity functions
20:00:28 <jle`> where for <*> you only just need to tak on another <*>
20:00:32 <copumpkin> :t uncurry . uncurry . uncurry . uncurry
20:00:32 <lambdabot> (a -> b3 -> b2 -> b1 -> b -> c) -> ((((a, b3), b2), b1), b) -> c
20:00:35 <copumpkin> there we go
20:00:39 <jle`> here you need add the ** and the uncurry
20:00:43 <jle`> change things in two places
20:00:49 <jle`> and keep track of how many of each there are
20:01:27 * hackagebot pandoc-citeproc 0.3.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.3.1 (JohnMacFarlane)
20:02:15 <Zekka> Just figured out fundeps, that's an annoying problem solved
20:02:32 <dmwit> Type families are better (tm).
20:02:34 <dmwit> Well.
20:02:38 <dmwit> Type families are newer.
20:02:38 <Guest87869> i like type families
20:02:52 <Zekka> I don't know what type families are, what's the pitch?
20:03:14 <jle`> functions on types -> profit
20:03:45 <Zekka> jle`: How are they different from parametric types? (googling as we speak)
20:04:09 <Zekka> also, we're referring to Haskell type families and not Pokemon type families as Google seems to have suggested, right?
20:04:31 <benzrf> dont be absurd
20:04:35 <benzrf> does this look like #haskell to you
20:04:44 * benzrf sets topic: POKEMON
20:05:01 <dmwit> Parametric types are injective; type families are not.
20:05:14 <dmwit> Your first three unsolvable type errors will be because you do not understand this rule.
20:05:33 <Zekka> By which you mean (let me remember my set theory) parametric types are defined over all types?
20:05:38 <dmwit> s/are not/need not be/
20:05:51 <dmwit> Zekka: No, it means if a /= b, then F a /= F b when F is a parametric type.
20:06:06 <dmwit> Zekka: On the other hand, if F is a type family, you may have F a = F b even when a /= b.
20:07:06 <Zekka> I'm still not sure I understand, then -- going to do some reading, although feel free to try explaining if you like
20:07:14 <jle`> i didn't understand type families until closed type families
20:07:33 <Zekka> Actually, wait, I think I understand after all
20:07:54 <Zekka> applying a type family to two distinct types may result in the same type?
20:07:59 <dmwit> yes
20:08:46 <jle`> type family F a where F Int = Bool; F Bool = Char; F Char = Int; F a = Double
20:08:51 <dmwit> jle`: I don't understand closed type families.
20:08:57 <jle`> it's like pattern matching on types
20:08:57 <dmwit> Perhaps we should team up.
20:09:18 <Zekka> That's straightforward and super cool
20:09:22 <Zekka> I'd heard they were complicated
20:10:22 <jle`> there's this neat article on using type families to have monads with arbitrary constraints
20:10:24 <jle`> like for Set and map
20:10:26 <jle`> Map
20:10:35 <dmwit> jle`: read http://stackoverflow.com/q/19350323/791604 and see if you still think closed type families make sense =P
20:11:33 <jle`> :|
20:11:39 <dmwit> Excerpt: "type family C a b where ...; C a a = [a]"; error: "Couldn't match expected type `C a a' with actual type `[a]'"
20:12:28 <Zekka> I'd be mad but having a type system smart enough to make that kind of mistake is already pretty cool
20:12:44 <dmwit> The kicker is that it is *not a mistake*.
20:13:01 <Zekka> I'm aware, there's probably a good math reason it does the counterintuitive thing here
20:13:19 <Zekka> pretty much every time GHC does something that baffles me I do the research and find out later the math made sense
20:13:36 <Zekka> It's only really a mistake in that it creates a behavior you can't expect
20:14:12 <Guest87869> UndeciableInstances to the rescue
20:14:41 <Zekka> Live dangerously, IncoherentInstances
20:14:43 <dmwit> "undecidable instances caused this problem, why can't it get us out??"
20:15:13 <Zekka> My current project actually uses undecidableinstances but I feel super guilty about it
20:15:28 <Zekka> it's sufficiently insulated that it shouldn't break anything though
20:16:06 <Guest87869> need -XUncomputableReals
20:17:03 <jle`> -XUndecidableCompilation
20:17:46 <dmwit> You don't need any extensions toget undecidable compilation with GHC.
20:18:02 <pyon> -XSemidecidableRealEquality
20:18:05 <Iceland_jack> I want a flag for removing my source code if it doesn't type check :( I should file that as a regression bug
20:18:33 <dmwit> -fnuke-it-from-space
20:18:39 <jle`> dmwit: then how about -XNoUndecidableCompilation
20:18:55 <jle`> -XNoNonterminatingComputations
20:19:12 <Guest87869> -XAgda
20:19:37 <Iceland_jack> -XMixFixOperators
20:19:39 <dmwit> jle`: I think -XNoUndecidableCompilation is spelled -O0 at the moment.
20:19:42 <Zekka> Reminds me, anyone here do general-purpose programming in Agda? I haven't seen much presence for it online but I hear its type system is pretty neat
20:19:49 <dmwit> Though I doubt anybody's tried to prove it. =)
20:19:54 <Iceland_jack> Zekka: Idris is intended for that
20:20:07 <Zekka> I ran into Idris earlier but haven't worked in it
20:20:35 <Iceland_jack> Idris is more similar to Haskell in many ways, of course “general-purpose programming” in a dependently-typed language still warrants scare quotes
20:22:53 <Iceland_jack> Zekka: Check out the tutorial on the website, it's well worth a look
20:23:13 <Iceland_jack> For actual theorem proving you'll probably want to use Coq or Agda though
20:23:13 <Zekka> Iceland - I'm currently in a rush to finish rewriting this project but maybe later tonight I will
20:23:33 <Guest87869> idris seems cool
20:23:45 <Zekka> (well, actually, in about ten minutes I'm in a rush to attend a meeting but forty-five minutes after that what I said before holds)
20:23:52 <Iceland_jack> Of course! When ever you want to of course
20:24:03 <Iceland_jack> (should not have said 'of course' twice there, hm)
20:24:06 <jle`> Guest87869: just curious, do you have a name?  or am i overstepping boundaries of etiquette
20:24:22 <jle`> Iceland_jack: your second of course is qualifying your first of course
20:24:30 <dmwit> jle`: Try /whois. =)
20:24:30 <jle`> perfectly valid
20:24:31 <Iceland_jack> of course
20:24:35 <Guest87869> im only a number
20:24:47 <Zekka> While I'm still here, by the way, anyone around here attending Bayhac?
20:24:48 <Iceland_jack> > read "Guest87869" :: Integer
20:24:49 <lambdabot>  *Exception: Prelude.read: no parse
20:24:50 <Iceland_jack> Hm…
20:25:01 <Zekka> > read "Guest87869" :: Num a => a
20:25:02 <lambdabot>  Could not deduce (GHC.Read.Read a1)
20:25:02 <lambdabot>    arising from a use of ‘Text.Read.read’
20:25:02 <lambdabot>  from the context (GHC.Num.Num a)
20:25:02 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
20:25:02 <lambdabot>  or from (GHC.Num.Num a1)
20:25:28 <Guest87869> > (read . reverse) "Guest87869" :: Integer
20:25:29 <lambdabot>  *Exception: Prelude.read: no parse
20:25:48 <jle`> > read "Guest87869" :: Num a => Maybe a
20:25:49 <lambdabot>  Could not deduce (GHC.Read.Read a1)
20:25:50 <lambdabot>    arising from a use of ‘Text.Read.read’
20:25:50 <lambdabot>  from the context (GHC.Num.Num a)
20:25:50 <lambdabot>    bound by the inferred type of
20:25:50 <lambdabot>             it :: GHC.Num.Num a => Data.Maybe.Maybe a
20:25:50 <Iceland_jack> > read (filter isDigit "Guest87869") :: Integer
20:25:51 <lambdabot>  87869
20:26:26 <jle`> > Guest87869 ^? name
20:26:27 <lambdabot>  Not in scope: data constructor ‘Guest87869’Not in scope: ‘name’
20:26:37 <jle`> aw
20:26:43 <Iceland_jack> no doxxing!
20:26:45 <Iceland_jack> :)
20:27:11 <jle`> fair nuff
20:27:11 <dmwit> > reаd "Guest87869"
20:27:13 <lambdabot>  Just "a number"
20:27:19 <jle`> haha
20:27:20 <Iceland_jack> :t read
20:27:20 <lambdabot> Read a => String -> a
20:28:03 <luzie> :hs "reаd"
20:28:10 <luzie> > "reаd"
20:28:11 <lambdabot>  "re\1072d"
20:28:16 <dmwit> =)
20:28:27 <Guest87869> how did you get lambdabot to do that
20:28:29 * jle` shakes fist
20:28:41 <dmwit> Guest87869: luzie posted spoilers if you don't want to figure it out yourself
20:29:04 <jle`> > reаd "jle`"
20:29:06 <lambdabot>  Just "a number"
20:29:08 <jle`> :/
20:29:12 <jle`> how depressing
20:29:13 <Guest87869> nice
20:29:54 <Zekka> Alright, I'll be back later. See you folks.
20:30:03 <jle`> goodbye Zekka
20:30:38 <dmwit> oh man
20:30:42 <dmwit> I missed an amazing opportunity.
20:31:44 <dmwit> > [reаd "Guest87869", Just 3]
20:31:45 <lambdabot>  No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
20:31:46 <lambdabot>    arising from the literal ‘3’
20:31:58 <dmwit> err
20:31:58 <Dugar> I'm trying to use Data.Either.Unwrap, but it won't let me import it. Cabal install Data.Either.Unwrap isn't working either. How do find the package name Data.Either.Unwrap is in?
20:33:07 <dmwit> > [reаd "Guest87869", Just 3]
20:33:09 <lambdabot>  [Just a number,Just 3]
20:33:17 <dmwit> There we go. Slightly more mysterious. =)
20:33:56 <geekosaur> Dugar: try querying it on hayoo or fpcomplete's hoogle?
20:34:06 <Guest87869> haha idris effects tutorial footnote: 1You do not, however, need to know what a monad is. A correctness property of this tutorial is that the word “monad” should
20:34:08 <dmwit> Dugar: There's no good way to map from module name to package name, but you could try http://hackage.haskell.org/packages/search?terms=Unwrap
20:34:10 <Guest87869> appear exactly twice, both in this footnote
20:34:11 <geekosaur> it would be nice if cabal-install had a query like that though (or maybe it does soemwhere)
20:34:21 <dmwit> Dugar: Which suggests that you should "cabal install either-unwrap".
20:35:43 <Dugar> Thanks guys
20:46:17 <Rovek> Any exploits around mcafee realtime scanning
20:48:16 <geekosaur> Rovek, wrong channel
20:48:41 <Rovek> ahh i see
20:49:27 <Rovek> what channel should i head to
20:53:50 <geekosaur> I don't know but this is a channel about the Haskell programming language not security exploits
21:17:24 <_flatline_> Is it generally bad practice to use the !! operator on a list?
21:17:34 <nisstyre> _flatline_: it can be
21:17:44 <nisstyre> sometimes it's more elegant than the alternative
21:17:47 <benzrf> _flatline_: it's not so much bad practice as not particularly useful
21:17:49 <nisstyre> e.g. if you want the third element
21:17:56 <nisstyre> but that is rare
21:18:42 <benzrf> good night im sleeping now
21:18:59 <startling> goodnight benzrf !
21:19:03 <benzrf> bye
21:21:23 <Lemmih> Goodness gracious, #haskell has certainly become popular.
21:21:48 <copumpkin> Lemmih: you're alive!
21:21:55 <Zekka> Evening
21:22:15 <Lemmih> copumpkin: Sup! Long time, no see. :)
21:22:33 <copumpkin> what brings you back to our little corner of the internet?
21:22:51 <Fuuzetsu> All my types in the module look something like ‘DocH mod sometype’, with sometype different per-function but ‘mod’ never specialised. How can I spare myself writing ‘mod’? I want something like ‘type Doc id = DocH mod id’ but that doesn't work, not even with RankNTypes + forall &c
21:22:55 <Lemmih> srhb: Sarah? You're in Germany now? Or just proxying?
21:22:56 <jle`> _flatline_: it might be more accurate to say that if you need (!!), you should consider the possibility that you are using the wrong data structure
21:23:23 <Lemmih> copumpkin: I read a post about #haskell being less friend on /r/haskell. Had to go see for myself.
21:23:43 <jle`> wrong, or maybe not the best fit :)
21:25:11 <dmwit> Fuuzetsu: CPP ;-)
21:25:12 <copumpkin> Lemmih: GET OUT YOU HORRIBLE PERSON
21:25:16 <copumpkin> (see?)
21:25:30 <Fuuzetsu> dmwit: Thought so. I'll live with writing ‘mod’ everywhere in that module then ;)
21:25:36 <jle`> so much bad press for #haskell these days :/
21:25:47 <Fuuzetsu> There's bad press for #haskell?
21:26:03 <machineslearn> I also came here to see for myself.
21:26:10 <Zekka> I thought this seemed like a pretty friendly channel
21:26:11 <machineslearn> I have been here for hours and everyone seems nice.
21:26:12 <Lemmih> But? But? I want to hear more about these fuzzy monads. :)
21:26:21 <Zekka> What were people complaining about?
21:26:25 <jle`> yeah, Twitter hates it and r/haskell's top at the moment is about how bad #haskell is
21:26:32 <jle`> cold world
21:26:33 <machineslearn> Saying #haskell doesn't answer questions.
21:26:42 <Lemmih> Zekka: Questions going unanswered. Newbies being ignored.
21:26:46 <Zekka> Really? I always come here for tech support
21:26:53 <Zekka> Usually people bend over backwards to figure out what the problem is
21:26:54 <Fuuzetsu> That's rather strange, you usually get about 5 people jumping on your question.
21:27:12 <Zekka> Maybe it's because I've got some proficiency in the language but for the most part I feel like this channel is more active and helpful than any Freenode channel has any right ot be
21:27:27 <benbangert> Zekka: there's definitely a difference in activity depending on the time of day
21:27:32 <benbangert> maybe time zone issues
21:27:37 <machineslearn> (even the bots are helpful)
21:27:42 <jle`> I also have not observed these "one liner non answers"
21:28:19 <jle`> have any of you here?
21:28:37 <Zekka> (Disclosure: I'm pretty new to Haskell by which I mean I've only been working in it for a year or two -- I usually have a lot of questions and a lot of them are already pretty understood)
21:30:18 <startling> Sometimes I see questions, don't know the answer to them, but start playing around with similar things in lambdabot in case it helps me understand.
21:30:31 <startling> Perhaps I should be clearer that I'm not answering.
21:31:55 <Fuuzetsu> Right, if no one knows, they won't speak up, simple as that.
21:32:18 * Fuuzetsu had plenty of questions unanswered but doesn't blame anyone
21:32:31 <jle`> i don't comment on questions I do not know how to answer properly and I think a lot of others feel the same, it's not because they are cold :(
21:32:32 <Zekka> I think I've only had one question unanswered here
21:32:33 <jle`> sometimes questions do get lost in the noise though
21:32:43 <Zekka> generally I'd prefer people acknowledge "this is why that question is really hard to answer"
21:32:53 <Fuuzetsu> jle`: sure, just ask again then
21:33:24 <Fuuzetsu> Zekka: Right, but if you're asking about some obscure library no one used then people might simply not know anything about it.
21:34:08 <Zekka> By the way, etiquette question -- when someone helps me with something and I get it working, I often highlight them to mention "it works now, thanks"
21:34:12 <Zekka> is this considered impolite?
21:34:32 <jmcarthur> i think that's fine
21:35:04 <jmcarthur> i certainly prefer to know my advice helped over just having no feedback
21:35:28 <copumpkin> feedback is always nice
21:35:30 <copumpkin> good or bad
21:35:38 <copumpkin> well, some people don't like the bad feedback
21:35:46 <jle`> I've had several unanswered questions for very understandable reasons
21:35:48 <jle`> but yeah the first time it does feel cold... you don't immediately realize that everyone actually read your question but nobody is comfortable enough to answer
21:35:50 <jle`> maybe we should have a bot to periodically remind people of that
21:35:52 <jle`> "everyone read your question but don't worry, it's not that they are snubbing you, it's that nobody qualified to answer is online"
21:36:08 <jmcarthur> it's sometimes hard to accept bad feedback because irrational
21:36:27 <benbangert> everyone knows irrational people don't use computers
21:36:31 <Fuuzetsu> If anything, maybe a short snippet in topic asking the users to try later and/or on MLs if they have their question unanswered would be best
21:37:25 <startling> Zekka: I always like that.
21:38:35 <Zekka> Is there a standard Default typeclass that's weaker than Monoid, by the way?
21:38:53 <jle`> I see Data.Default used a lot
21:38:58 <Zekka> I have a type that's not monoidal but which has a default value when I perform stateful computations with it
21:39:57 <Zekka> (I know, 'default without monoid' is a bit of a smell)
21:39:59 <jmcarthur> Zekka: most people push back on such type classes because they have no meaningful properties. no laws, nothing you can assume about it. not much point in overloading.
21:40:33 <startling> Zekka, why not just supply the default?
21:40:53 <startling> (In what ways is it special, by being made default?)
21:40:56 <Zekka> startling - There's not really a good reason, it's actually an organizational thing
21:41:07 * michaelt was surprise to see that idris is using a Default class in the effects machinery
21:41:10 <jmcarthur> Zekka: and for that matter, i tend to think the very idea of a default or placeholder is a smell, not just the type class
21:41:13 <startling> Ah.
21:41:17 <Zekka> I might just define a default in a separate module -- it doesn't belong in the only module that would ever use it
21:41:31 <Zekka> There's actually a meaningful monoid instance but actually using it would mean grossly misusing the type
21:41:40 <Zekka> it's designed to be used in stateful computations and pretty much nothing else
21:41:41 <jmcarthur> Zekka: e.g. if i don't know what value to put in that field yet, why am i setting it? why not just return a function instead?
21:41:47 <startling> Zekka: an issue with using a Default typeclass is that it gets hard to supply your own default
21:42:31 <Zekka> jmcarthur - There's actually an almost-meaningful way to return a function here -- hold up, let me do a little type hackery and see if I can expose it
21:42:42 <startling> Zekka: Reader is another way.
21:43:06 <startling> (if you want to avoid passing the default explicitly all the time)
21:43:11 <fragamus> hey guys I *think* this code can never crash; it can produce NaN or Infinity or whatever but that's ok:
21:43:13 <fragamus> http://lpaste.net/103608
21:43:30 <jmcarthur> Zekka: sometimes a rational answer to the question is that you need to be able to access some other fields before the final one has been set. usually this can be fixed by refactoring the data type a bit. if you really believe it can't, knot-tying tricks often work (with usual caveats about knot tying)
21:43:43 <fragamus> I need to know if you concur that this function can never crash my app
21:44:14 <jmcarthur> fragamus: define "crash"
21:44:21 <startling> fragamus, a malicious Num instance can throw an error
21:44:41 <jmcarthur> startling: for that matter i could just pass undefined as an argument
21:44:49 <startling> haha, yesz
21:44:51 <dmwit> fragamus: I see a "/ (otherWeight - weight)" where "otherWeight" and "weight" are parameters.
21:44:57 <jmcarthur> or  unsafePerformIO launchMissiles
21:45:01 <dmwit> fragamus: Looks like a crash to me.
21:45:02 <fragamus> the three inputs are Double
21:45:15 <fragamus> nay dmwit
21:45:25 <fragamus> it can produce Infinity
21:45:33 <flebron> >5/(0::Double)
21:45:37 <startling> fragamus: what's the goal of this queston ?
21:45:37 <fragamus> but that is not a crash
21:45:38 <dmwit> Oh, is that what Doubles do?
21:45:38 <enthropy> jmcarthur: how would you rearrange diagrams to avoid using def?
21:45:39 <dmwit> ugly
21:45:45 <flebron> > 5 / (0::Double)
21:45:46 <lambdabot>  Infinity
21:45:58 <fragamus> yeah
21:46:07 <Zekka> dmwit - Want to see something uglier?
21:46:12 <dmwit> no
21:46:12 <jmcarthur> enthropy: i'm not very familiar with diagrams. is there something i could look at to quickly get up to speed on what you're asking about?
21:46:17 <Zekka> > floor (5 / (0 :: Double))
21:46:18 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:46:19 <fragamus> any other takers, please assume that NaN and Infinity are *just fine*
21:46:33 <fragamus> lol
21:46:38 <enthropy> jmcarthur: pretty much it is about faking keyword arguments
21:46:39 <startling> fragamus: I don't think you will get any useful information out of this question.
21:46:42 <fragamus> that is really ugly
21:46:42 <jmcarthur> fragamus: somebody could pass in an argument that crashes when you evaluate it (via unsafePerformIO or something)
21:47:05 <fragamus> it's all pure code
21:47:07 <jmcarthur> fragamus: or something that doesn't terminate (if that counts as crashing)
21:47:09 <fragamus> no IO
21:47:16 <Zekka> Well, unsafePerformIO doesn't care
21:47:27 <Zekka> it thinks it's totally a pure function
21:47:30 <fragamus> yes that's a problem for sure
21:47:39 <dmwit> jmcarthur: Diagrams uses the "records for multiple arguments" trick extensively.
21:47:39 <jmcarthur> enthropy: well that sounds like asking for trouble already, to me
21:47:49 <dmwit> jmcarthur: For which "def" is a beautiful hack.
21:47:51 <jmcarthur> i see
21:48:00 <jmcarthur> i'll take a look at what this "def" thing is
21:48:07 <fragamus> So I think I'm ok here
21:48:21 <dmwit> jmcarthur: see https://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
21:48:31 <kwf> fragamus: Have you considered restricting yourself to Safe Haskell? That would at least outlaw the unsafePerformIO trick... Joined this thread late, so maybe that's already been suggested / is irrelevant.
21:48:43 <jmcarthur> oh, def is just Default's thing
21:48:55 <jmcarthur> reading
21:49:38 <Zekka> dmwit - I use that pattern all over and it's pretty great.
21:49:39 <fragamus> What exactly is safe haskell
21:50:10 <flebron> Zekka: Why does that ugly thing happen?
21:50:33 <Zekka> flebron - I have no idea, but a friend showed it to me a while back and I feel obligated to make sure the whole world knows
21:50:37 <jmcarthur> i see, this is that pattern for *optional* arguments
21:50:58 <fragamus> Zekka: that sure is important to know about
21:51:03 <Zekka> It changes result between compiler versions and the functions involved werei mplemented in C which to me makes me think something low level that's evil is seeping through
21:51:16 <jmcarthur> i think this is a reasonable case for default values (but still not for the Default class)
21:51:54 <fragamus> I *hate* seeping evil
21:53:07 <Zekka> fragamus - If you're wondering, by the way, just in case it wasn't absolutely confirmed, I can't think of any straightforward ways to make your code die
21:53:17 <Zekka> tricksy things like passing errors and undefined excluded
21:53:22 <dmwit> jmcarthur: What are you proposing, if not the Default type class?
21:53:41 <kwf> fragamus: Safe Haskell (http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/safe-haskell.html) is a language extension which disallows the use of things like unsafePerformIO, unsafeCoerce, and friends, as well as certain language extensions which would let you implement those same unsafe features.
21:53:54 <jmcarthur> dmwit: i haven't intended to propose anything?
21:53:57 <fragamus> i like it
21:54:10 <Zekka> kwf - Does it allow errors?
21:54:17 <dmwit> jmcarthur: "this is a reasonable case for default values" <- what does this mean?
21:54:17 <jmcarthur> dmwit: somebody asked about "Default" style type classes, and i shared my thoughts on them.
21:54:18 <kwf> Yeah
21:54:24 <fragamus> does it allow 1/0
21:54:29 <kwf> It doesn't magically make Haskell provably-terminating ;)
21:54:34 <fragamus> lol
21:54:39 <jmcarthur> dmwit: i mean predefined values you can just change the fields of
21:54:46 <kwf> fragamus: You can do IO
21:54:47 <jmcarthur> dmwit: not necessarily using a type class, though
21:54:51 <kwf> But only in the IO monad
21:54:56 <kwf> That is, no unsafePerformIO
21:54:59 <dmwit> jmcarthur: uh huh
21:55:03 <fragamus> 1 `div` 0
21:55:04 <dmwit> jmcarthur: I don't buy your complaint, then. =)
21:55:09 <fragamus> > 1 `div` 0
21:55:10 <lambdabot>  *Exception: divide by zero
21:55:21 <kwf> And Template Haskell gets disallowed for technical reasons because it lets you break module boundaries and mess with things you shouldn't be able to
21:55:34 <fragamus> > 1.0 / 0.0
21:55:36 <lambdabot>  Infinity
21:55:43 <dmwit> jmcarthur: defFooArgument, defBarArgument, defWibbleArgument... having many names for these things is not better than having one name =)
21:55:46 <jmcarthur> dmwit: why is it worth overloading? would i ever use it polymorphically?
21:55:52 <fragamus> no lenses?
21:56:16 <enthropy> dmwit: instead of accepting a record, you could accept a function that updates the default record
21:56:27 <dmwit> jmcarthur: It is worth overloading as a convenience for the poor programmer that has to type all this nonsense in every time.
21:56:28 <jmcarthur> dmwit: yeah, so now if i want to have different defaults for different functions, i have to actually have different types! :(
21:56:35 <kwf> So, moral of the story, if you force users of your API to use Safe Haskell (no way to do this inside the language, so might be completely irrelevant to you) you can guarantee they don't do certain classes of nasty things, which means you can build more meaningful safety mechanisms on top of that
21:56:58 <dmwit> enthropy: cool idea
21:57:02 <kwf> I heard somewhere that lambdabot itself uses Safe Haskell to ensure you don't blow things up by violating its evaluation sandbox in certain ways
21:57:40 <Zekka> > unsafePerformIO (return "[do evil]")
21:57:41 <jmcarthur> dmwit: as the designer of the API, i would try to find ways to make it more composable instead of just swarms of arguments. not to make a statement about diagrams, since i don't know much about it or how hard it is to design in that space, really.
21:57:42 <lambdabot>  Not in scope: ‘unsafePerformIO’
21:57:58 <kwf> fragamus: Does that make sense?
21:58:20 <fragamus> yes
21:58:35 <fragamus> I like it but im a lense junkie
21:58:40 <dmwit> jmcarthur: I believe most of these functions that accept complicated arguments use them to build stuff from smaller pieces. Diagrams are very composable.
21:58:45 <fragamus> lens even
21:58:59 <dmwit> But sometimes you want convenient functions that are already composed.
21:59:30 <dmwit> I dunno what I'm arguing anymore, to be honest.
21:59:37 <dmwit> Default is neat. I use it from time to time.
21:59:48 <dmwit> I don't think it's evil.
22:00:02 <kwf> fragamus: Is the issue that Safe Haskell would disallow lens because it uses unsafe**** internally?
22:00:04 <jmcarthur> dmwit: e.g. instead of  drawCircle :: Color -> Transparency -> Size -> DistortionThingy -> StuffToPutItOn -> StuffToPutOnIt -> Image  (or the recordified version of it), i would lean toward  circle :: Image; modulate :: Color -> Image -> Image; opacity :: Double -> Image -> Image; etc.
22:00:35 <kwf> Because one other thing is you can say, explicitly, "I trust this module," and override it. But anything you don't explicitly trust gets checked.
22:00:49 <fragamus> Well if I didn't have lens I would have to kill myself
22:00:59 <Ghoul_> hah
22:01:32 <jmcarthur> i don't think Default is evil. i just think it is pointless and a bit smelly.
22:01:35 <kwf> Aha
22:01:42 <jmcarthur> anyway, it's bedtime
22:01:54 <kwf> fragamus: If you go to Hackage, the upper-right-hand box says what the Safe Haskell status of the package is
22:02:11 <kwf> For lens, the modules all seem to be marked "Trustworthy"
22:02:18 <dmwit> jmcarthur: Diagrams chooses to provide both of those.
22:02:26 <kwf> Which is the way the programmer does exactly what I was talking about before
22:02:43 <dmwit> jmcarthur: e.g. there is cat' which takes a CatOpts and there's building blocks to use to construct it.
22:02:55 <fragamus> yeah i have seen that but never quite studied up on it
22:03:23 <kwf> It's only really interesting once you start using it as a framework to build other interesting things.
22:03:41 <fragamus> yep
22:03:48 <NemesisD> are there laws for Iso in lens? says index and measure preserving. would an Iso' [a] (Set a) fail that?
22:03:52 <fragamus> it helps us reason about code
22:04:04 <kwf> For example, I did some work last summer with the LIO library (http://hackage.haskell.org/package/lio) which lets you enforce nifty security constraints using monads
22:04:17 <kwf> And it wouldn't be possible if the user could unsafeCoerce their way out of the constraints
22:04:27 <kwf> Hence, Safe Haskell makes this library mean what it says on the box
22:04:41 <fragamus> i get it
22:04:58 <kwf> Cool :)
22:06:13 <roboguy_> NemesisD: well, for f and g to be an isomorphism, f . g = id and g . f = id
22:07:33 <fragamus> How does something become "Trustworthy"
22:07:50 <fragamus> Is that just Ed Kmett saying yeah its good
22:08:14 <kwf> fragamus: Yeah, pretty much
22:08:29 <startling> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/safe-haskell.html
22:08:51 <Fuuzetsu> better: http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/safe-haskell.html
22:08:58 <roboguy_> NemesisD: I don't know if that's explicitly stated in the Iso docs, but I would imagine that would be implied (that's the categorical definition of an isomorphism)
22:09:01 <kwf> fragamus: But you have to then tell ghc, "Yes, I trust ekmett with this as with all other things," using ghc -fpackagetrust somethingorother
22:09:07 <kwf> I forget the exact syntax; it's been a whle
22:09:16 <kwf> *while
22:09:18 <fragamus> gotcha
22:09:23 <napping> I've upgraded ghc and cabal-install, and I'm no longer getting documentation
22:09:36 <napping> I thought a "documentation: True" line in .cabal/config should be enough
22:09:39 <kwf> But if you mark your package as unsafe, then nobody is allowed to trust it.
22:09:44 <kwf> If I recall correctly.
22:09:47 <fragamus> I *trust* Ed Kmett
22:10:06 <startling> napping: how do you mean?
22:10:07 * Guest87869 marks all source as unsafe
22:10:27 <startling> napping: it's possible ~/.cabal/config got clobbered somehow
22:10:37 <kwf> fragamus: Don't you mean (trust .~ True) fragamus
22:10:37 <startling> (if you mean automatically building haddocks)
22:10:43 <napping> The documentation index in .cabal/share/doc/index.html is no longer updated, and I haven't found anywhere the haddocks are put
22:11:52 <kwf> fragamus: It's just an endoscopic automorphism in the Kleisli category of trustworthiness under reverse composition
22:12:10 <fragamus> ok I think that was a joke
22:12:12 <fragamus> right
22:12:25 <jle`> endoscopic automorphism, i like it
22:12:30 <napping> startling: The current one has a line "documentation: True\n"
22:12:39 <startling> napping: hm, weird
22:12:47 <startling> napping: are you in a sandbox?
22:12:52 <napping> would a reinstall maybe not do that?
22:13:02 <napping> no, I'm actually running it from my .cabal directory
22:13:11 <kwf> (yes, it was a joke - it's late where I am)
22:13:12 <startling> no idea, sorry.
22:15:36 <michaelt> napping, does it make documentation if you use cabal outside the .cabal directory?
22:17:07 <napping> no, that didn't change anything
22:18:04 <kwf> > import Unsafe.Coerce
22:18:05 <lambdabot>  <hint>:1:1: parse error on input ‘import’
22:18:55 <napping> weird, some packages have documentation
22:19:19 <napping> Ah,
22:19:30 <napping> I see an error in the logs about not having hscolour
22:19:43 <startling> napping: oh, interesting
22:19:46 <napping> Rather annoying that it silently fails
22:19:57 <startling> napping: could you paste the relevant logs?
22:19:57 <napping> I guess since I turned on hyperlink-source it's been breaking
22:20:04 <startling> aha
22:20:22 <startling> it is weird that it silently fails.
22:20:24 <napping> relevant bit:
22:20:25 <napping> Running Haddock for lens-4.1.2...
22:20:25 <napping> setup: The program 'hscolour' version >=1.8 is required but it could not be
22:20:26 <napping> found.
22:21:43 <michaelt> oh, 'hyperlink-source' presupposes you have installed hscolour ?
22:23:31 <napping> seems like it
22:28:49 <dmj`> > try $ evaluate 3 :: IO (Either SomeException Int)
22:28:51 <lambdabot>  <IO (Either SomeException Int)>
22:45:20 <redtricycle> Argh, how can I use cabal to install shpider?  I keep getting directory-1.0.0.3 required, which fails to build
22:45:27 <redtricycle> Googling says I need to have base > 4.2 && < 4.6
22:45:34 <redtricycle> and I'm running into dependency issues
22:47:02 <redtricycle> "Failed to install directory 1.0.0.3"
22:48:30 <napping> what's pulling in that?
22:48:56 <redtricycle> web-encodings
22:49:29 <redtricycle> I'm using cabal-dev, let me reinstall and get the error message for you guys
22:50:06 <napping> web-encodings says directory < 1.2, and deprecated
22:51:22 <redtricycle> shpider-0.2.1.1 depends on directory-1.0.0.3 which failed to install.
22:51:29 <redtricycle> web-encodings-0.3.0.9 depends on directory-1.0.0.3 which failed to install.
22:51:33 <redtricycle> Are the two lines
22:51:52 <redtricycle> my goal is to install shpider
22:52:03 <napping> what base do you have?
22:52:12 <redtricycle> How do I check?
22:52:27 <napping> ghc-pkg list | grep base
22:52:37 <redtricycle> base-e4.6.01
22:52:42 <redtricycle> base-4.6.0.1
22:52:47 <dmwit> Can you --constraint "directory installed" and see what it complains about?
22:53:05 <redtricycle> cabal-dev install --constraint "directory installed" you mean, dmwit?
22:53:06 <napping> ah, "ghc-pkg latest base" would show that as well or better
22:53:13 <dmwit> Probably the constraint on directory is upper-bounded too strictly, and relaxing the appropriate upper bound will let it install.
22:53:24 <dmwit> redtricycle: ...sure
22:54:36 <redtricycle> Got a lot more failures now
22:54:50 <redtricycle> text-0.7.2.1 failed to install
22:55:19 <redtricycle> so parsec-3.1.5 fails, shpider-0.2.1.1 fails, tagsoup-0.13.1 fails, tagsoup-parsec-0.0.8 fails (due to text-0.7.2.1), and web-encodings-0.2.3 depends on text-0.7.2.1
22:55:48 <dmwit> text-0.7?
22:56:03 <dmwit> That's like... four years old.
22:56:12 <napping> so is shpider
22:56:12 <redtricycle> Is shpider just really old?
22:56:18 <dmwit> I see. =)
22:56:22 <redtricycle> and I shouldnt try using it? o_o
22:56:28 <redtricycle> maybe I'll ask a different question
22:56:36 <dmwit> Well, "shouldn't try using it" certainly doesn't follow from "is really old".
22:56:36 <napping> Upload dateTue Nov 29 18:26:57 UTC 2011
22:56:41 <redtricycle> i want to use webscraping with cookies...
22:56:49 <dmwit> But it will certainly be harder to build, and you will have to fight with it.
22:56:51 <redtricycle> what do people use nowadays?  I pulled my answer from a Stackoverflow post
22:57:03 <napping> maybe try to loosen some things a bit?
22:57:15 <redtricycle> My cabal file has a build-depends
22:57:19 <redtricycle> and I put only shpider in there
22:57:25 <redtricycle> build-depends: shpider
22:57:39 <redtricycle> Is there a way to loosen it up further?
22:57:41 <srhb> Well, you should probably fetch shpider and loosen its build-depends
22:57:43 <napping> I mean check out shpider and adjust its config
22:57:49 <srhb> cabal unpack shpider
22:57:58 <redtricycle> ah...
22:57:58 <startling> redtricycle: you could try wreq
22:58:01 <redtricycle> how do I do that in a sandbox?
22:58:02 <napping> It looks like it's only the "web-encodings" dependency that's dragging it out of date
22:58:19 <napping> Are you using cabal sandboxes with a pretty recent cabal, or cabal-dev?
22:58:39 <napping> web-encodings is deprecated and last updated 2012, everything else seems to be current
22:58:43 <lahwran> anyone know of a haskell library for *simplex* noise?
22:58:46 <redtricycle> I'm using cabal-dev, because i'm using the latest haskell-platform
22:58:50 <lahwran> I specifically *do not want square perlin noise*
22:58:56 <redtricycle> which is at 1.16, and cabal sandbox comes in 1.18
22:59:20 <napping> lahwran: maybe not
22:59:25 <startling> hi lahwran
22:59:30 <lahwran> hi startling <3
22:59:42 <srhb> redtricycle: You can just update cabal using cabal itself
22:59:46 <srhb> Should be fine with the platform I believe.
22:59:52 <lahwran> the noise library I found doesn't specify whether it's square, classic perlin, or whether it's the newer simplex version
23:00:13 <StoneCypher> lahwran: seems to be this?  http://stackoverflow.com/questions/5707250/optimizing-numerical-array-performance-in-haskell
23:00:18 <napping> redtricycle: shpider doesn't have very tight bounds on its own dependencies
23:00:30 <lahwran> I found that, but that sounds like it's an unoptimized implementation
23:00:36 <napping> redtricycle: I'd suggest getting it with cabal unpack or whatever, removing the web-encoding dependency, and seeing what breaks
23:00:57 <redtricycle> srhb: okay, i will try that
23:01:05 <redtricycle> napping: ok, will try that too
23:01:10 <srhb> redtricycle: I don't think that will change things though
23:01:13 <redtricycle> Um...hmm, maybe i'll do the unpack first
23:01:15 <srhb> redtricycle: Was just a sidenote
23:01:20 <napping> sure would be nice if it mentioned what it was deprecated in favor of
23:01:37 <redtricycle> just need to figure out how to "unpack" in a cabal-dev sandbox
23:01:38 <StoneCypher> lahwran: maybe you should read it before giving up
23:01:46 <srhb> redtricycle: Other way around.
23:01:52 <srhb> redtricycle: unpack first, sandbox after
23:02:02 <lahwran> StoneCypher: oh take your helpfulness elsewhere than ... helping me when I asked for it :)
23:02:05 <napping> redtricycle: I think you just run the cabal unpack normally, then read stuff trying to figure out how to add local source to a sandbox
23:02:23 * StoneCypher shrugs
23:02:44 <redtricycle> napping: ah, ok
23:03:20 <napping> redtricycle: well, hayoo is not too helpful trying to figure out where to get urlencoding and the like from
23:03:21 <redtricycle> bummer, web-encodings constraint looks pretty loose
23:03:24 <redtricycle> it just has "webencodings"
23:03:40 <redtricycle> cabal  unpack shpider
23:04:15 <napping> redtricycle: yeah, I meant to delete the constraint entirely, because web-encodings is deprecated, then try compiler shpider and see where it breaks and what functions from web-encodings it actually used
23:04:26 <napping> and then try to find what replaced it
23:04:33 <redtricycle> ahh, let me try that
23:04:41 <srhb> An easier route may be to unpack web-encodings, fix its constraints and see if it builds
23:04:47 <srhb> Then add the source of that instead.
23:05:05 <redtricycle> So is this a common thing for Haskell packages, btw?
23:05:11 <redtricycle> chasing down dependencies?
23:05:32 <napping> this is more invovled than I've had to do for a while
23:05:34 <redtricycle> or is it pretty uncommon and I should find another web scraping library?
23:05:50 <srhb> redtricycle: This is rather uncommon, only happens with really outdated things.
23:06:04 <srhb> redtricycle: Or when trying to switch to a newer version of GHC just after it came out.
23:06:06 <redtricycle> I am leaning toward finding a more up-to-date web scraper
23:06:19 <napping> I haven't looked at what this shpider actually gives you
23:06:20 <srhb> I'd recommend that, even if it's a very giving exercise :P
23:14:35 <napping> redtricycle: looks like shpider just wants encodeUrl
23:15:26 <redtricycle> I found this answer on SO: https://stackoverflow.com/questions/15059075/haskell-http-conduit-web-scraping-daemon-crashes-with-out-of-memory-error/15062233#15062233 ... maybe I will use a combination of http-conduit, http-conduit-browser, HandsomeSoup, and HXT?
23:15:37 <napping> redtricycle: change web-encodings to HTTP in shpider.cabal, and edit Network/Shipder.hs
23:15:41 <redtricycle> the "use shpider" answer was written in 2010...at least this once was in 2013
23:16:13 <napping> to import Network.HTTP.Base(urlEncode) instead of the line mentioning Encoding
23:16:21 <redtricycle> napping: ah
23:16:46 <napping> and change the two occurances of encodeUrl to urlEncode
23:18:55 <startling> if that fixes things, one of you should submit a pull request or something. :)
23:19:15 <startling> only you can fight hackage entropy!
23:21:10 <napping> redtricycle: that's enough to get it to build anyway, you'll have to try it out
23:21:39 <napping> looks like shpider has some nice settings about visiting domains and authentication and stuff
23:23:47 <redtricycle> this looks nice too: http://hackage.haskell.org/package/http-conduit-browser-1.9.0.2/docs/Network-HTTP-Conduit-Browser.html
23:24:14 <napping> Depends what you're doing
23:25:21 <napping> What are you doing?
23:25:23 <redtricycle> wooo! the build worked with other packages
23:25:34 <napping> With shpider modified as I suggested?
23:25:39 <redtricycle> napping: with another set of packages
23:25:57 <redtricycle> logging into a web page, saving the cookies, then accessing an autheticated page to grab some data
23:26:15 <napping> Do you want to script a particular thing, or spider some pages?
23:26:24 <redtricycle> just script a particular thing
23:26:34 <napping> Oh, then that browser thing sounds fine too
23:26:41 <napping> Guess I should send in the shpider thing
23:29:34 <zRecursive> How to implement "diff(sin(x),x) = cos(x)" using haskell ?
23:29:55 <redtricycle> napping: thanks for the mini-tutorial for unpack/fixing-broken deps
23:30:13 <startling> :t asin
23:30:14 <lambdabot> Floating a => a -> a
23:30:16 <redtricycle> useful skill for my toolbox
23:30:29 <startling> zRecursive: does that help?
23:30:30 <napping> redtricycle: no problem. Most of the time it doesn't go that far, and you'll just want to losen upper bounds
23:31:04 <zRecursive> startling: i mean Symbolic Computing thing
23:31:13 <startling> oh.
23:31:26 <Iceland_jack> > let { ε = 0.005; diff f x = (f (x + ε) - f x) / ε } in diff sin 5
23:31:27 <lambdabot>  0.28605830923118525
23:31:28 <Iceland_jack> > cos 5
23:31:30 <lambdabot>  0.28366218546322625
23:31:34 <Iceland_jack> ;) close enough
23:31:42 <srhb> Iceland_jack: Cheating!
23:31:45 <Iceland_jack> hush!
23:31:45 <napping> redtricycle: I only went that far because web-encodings was marked entirely deprecated. Otherwise you could have just use the --allow-newer option without unpacking anything
23:31:54 <startling> zRecursive, there's http://hackage.haskell.org/package/ad
23:31:57 <srhb> :-)
23:32:30 <napping> zRecursive: Haskell doesn't really do that kind of symbolic computation. Maybe there are some libraries for that sort of thing, but it's not a built-in part of the language
23:32:46 <zRecursive> Iceland_jack: you got value but i want "cos(x)" :)
23:32:51 <startling> zRecursive, you could also do data Differentiable a = Only a | Sin a | Cos a | Sum (Differentiable a) (Differentiable a) | ...
23:33:21 <startling> zRecursive: then diff :: Differentiable a -> Something
23:33:23 <zRecursive> startling: need to think it
23:33:23 <Iceland_jack> zRecursive: That's very easy :)
23:33:23 <Iceland_jack>     diff (Sin x) var
23:33:23 <Iceland_jack>       | x == var = Cos x
23:33:35 <startling> zRecursive: you usually do. :)
23:34:00 <pavonia> zRecursive: Here an example from Oleg: http://www.haskell.org/pipermail/haskell/2004-November/014939.html
23:34:01 <zRecursive> that will be a long match :)
23:41:53 * hackagebot directory-layout 0.6.0.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.6.0.0 (MatveyAksenov)
23:54:54 <johnw> is there a way to stop cabal-install from creating a ~/.cabal/config file?
