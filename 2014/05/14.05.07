00:00:35 <l0cust> cococo: thank you
00:01:26 <l0cust> cococo: It's really handy, and it would certainly be much easier to write than a webserver
00:01:48 <l0cust> Somebody doesn't know how to program a ram counter
00:01:53 <l0cust> http://i.imgur.com/9TY32Yw.png
00:02:17 <sopvop> l0cust: I don't think there is bind difference in case of Mp
00:02:19 <sopvop> Map
00:04:11 <l0cust> jesus - I have 11 GB used on my root partition - 5 of those are Mathematica
00:04:43 <l0cust> sopvop: I don't really know what you are talking about, nor do I know what *I* am talking about
00:04:54 <l0cust> sopvop: So I'm going to shut up
00:05:50 <l0cust> jzl: #archlinux
00:05:55 <l0cust> oops, sorry jzl
00:06:00 <l0cust> tried to type /join #archlinux
00:06:13 <l0cust> stupid autocomplete
00:07:33 <ashnur> i still don't get it. there isn't any haskell-platform which has ghc bundled with it
00:07:41 <ashnur> that Stop! note is very confusing
00:07:52 <l0cust> ashnur: haha
00:07:55 <ashnur> when was that true the last time?
00:08:03 <ashnur> 2011?
00:08:34 <ashnur> i bet if I download those too, i still don't get it with it
00:08:42 <sopvop> I'm not sure what I'm talking about either, need another coffee to wake up
00:09:16 * hackagebot txtblk 0.1.1.0 - A text blocker.  http://hackage.haskell.org/package/txtblk-0.1.1.0 (pharpend)
00:09:16 * hackagebot criterion 0.8.1.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.8.1.0 (BryanOSullivan)
00:10:24 <ashnur> https://github.com/jgm/pandoc/issues/1281
00:10:44 <l0cust> ashnur: Where are you located
00:10:47 <l0cust> @time ashnur
00:10:47 <lambdabot> Local time for ashnur is Wed, 07 May 2014 10:08:54 +0300
00:10:57 <l0cust> oh, so it's morning for you
00:11:09 <ashnur> l0cust: yes
00:11:26 <ashnur> i got up 40 minutes ago
00:11:31 <ashnur> it's eastern europe
00:11:34 <l0cust> In my mind, I'm thinking, why would anyone want to drink caffiene at 1:30 AM?
00:11:44 <ashnur> hope that doesn't disqualify me from using haskell though :-S
00:11:54 <ashnur> l0cust: oh, i do that anyway
00:12:03 <l0cust> *sips tea* yeah, me too
00:12:10 <ashnur> i envy you
00:12:17 <ashnur> anyhow
00:12:17 <l0cust> ashnur: why?
00:12:19 <ashnur> i want Elm
00:12:25 <ashnur> how can I get it
00:12:36 <l0cust> ashnur: maybe try setting up a virtual machine with something like debian
00:12:39 <ashnur> what are these dev versions they talk about in the pandoc issues?
00:12:41 <l0cust> and then installing it there
00:12:49 <ashnur> my machine is too slow for virtual machines
00:13:01 <ashnur> would take another 5-6 hours
00:13:21 <DogeHayashi> Incredibly noobular question: I know how to combine a Lens s t a b and a Lens s t c d to get a Lens (s,s) (t,t) (a,c) (b,d), as it's just alongside, but how does one idiomatically get a Lens s t (a,c) (b,d)?
00:13:21 <l0cust> haha
00:13:25 <DogeHayashi> (Does one?)
00:13:44 <l0cust> DogeHayashi: No experience with lens, so I don't know
00:13:54 <l0cust> DogeHayashi: people talk about it a lot, I should probably figure out what it is
00:14:28 <l0cust> ashnur: it looks like all you have to do is clone pandoc, edit the .cabal file, remove all version numbers from the dependencies, and then run "cabal install"
00:14:37 <ashnur> l0cust: okay
00:14:39 <ashnur> thanks
00:15:01 <DogeHayashi> l0cust: no worries, I should probably be asking in #haskell-lens or something, I'm totally new to the whole lens thing myself so I'm not entirely used to how to find out more about it yet =p
00:15:57 <ashnur> l0cust: and I said I envy you because caffeine is the one single thing from many which I couldn't stop. i am a regular coffee drinker since i was 12 y.o. and that's almost 20 years ago. i don't drink too much, but I can't stop for more than 2 weeks
00:16:24 <l0cust> ashnur: word of advice, don't try heroin, if you can't kick coffee
00:16:29 <cbarrett> DogeHayashi: Does the _Cons lens work for you?
00:16:32 <l0cust> just saying
00:16:48 <l0cust> ashnur: not to imply that you would normally try heroin
00:17:57 <cbarrett> DogeHayashi: May be misunderstanding what you're trying to do
00:17:58 <ashnur> :)
00:18:06 <DogeHayashi> cbarrett: hmm, that looks like it's of type Prism s t (a, s) (b, t), unless I'm missing something =p
00:18:08 <ashnur> l0cust: ok :)
00:18:37 <l0cust> @time DogeHayashi
00:18:37 <lambdabot> Local time for DogeHayashi is Wed May  7 08:16:37 2014
00:18:59 <cbarrett> DogeHayashi: hm. What are you trying to do?
00:19:02 <l0cust> DogeHayashi: What are you doing up at this hour of the night?
00:19:12 * hackagebot compdata 0.8 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8 (PatrickBahr)
00:19:14 * hackagebot compdata-param 0.8 - Parametric Compositional Data Types  http://hackage.haskell.org/package/compdata-param-0.8 (PatrickBahr)
00:19:19 <cbarrett> oh snap
00:19:22 <cbarrett> compdata 0.8
00:19:32 <DogeHayashi> I'm just wondering if I can have two lenses that operate on different bits of a data structure, and combine them in some way to make a lens that operates on a pair of those bits while still targeting the same data structure
00:20:01 <cbarrett> DogeHayashi: Kind of like *** ?
00:20:06 <DogeHayashi> I guess some nefarious combination of & and uncurry could work, but as usual I was wondering if there was a more elegant way
00:21:23 <DogeHayashi> cbarrett: heh, I'm being motivated by seeing a non-lens getter in my code that's literally (foo &&& bar), where foo and bar are record syntax accessors, and wondering if there's a nicer way of doing that in lens
00:21:37 <DogeHayashi> so I guess I'm technically not needing a Lens at the moment, just a Getter
00:21:49 <cbarrett> hm
00:22:13 <cbarrett> I'm still fairly new at lens myself so I'm unable to help more, sorry
00:22:18 <DogeHayashi> ah ok
00:22:48 <kylec01> doge: try #haskell-lens
00:22:56 <kylec01> they would know
00:25:55 <DogeHayashi> kylec01: cheers, will do
00:32:21 <cbarrett> wow, nice, compdata-0.8 has a bunch of cool stuff using the new closed type families in GHC 7.8. Awesome :)
00:33:25 <SrPx> let me ask a silly question, you guys are always talking about how hard it is to get UI right on multiple target platforms... but is there anything wrong with simply skipping OSes UI kits and just use OpenGL?
00:35:12 <ilmig> SrPx: you would basically have to create your own toolkit in opengl
00:35:27 <ilmig> SrPx: i.e. you would need to create all the standard widgets which one needs by yourself
00:35:41 <cbarrett> SrPx: users expect apps to work similarly to other apps
00:35:54 <ilmig> SrPx: and your application wouldn't feel native on any platform
00:36:14 <SrPx> ilmig: sure, but other than the initial difficulty, is there any additional problem in porting? If someone worked hard to make a lib for that in Haskell, would it benefit everyone?
00:36:45 <cbarrett> SrPx: what happens when the next version of the platform's toolkit comes along?
00:36:48 <ilmig> SrPx: it would still feel foreign to the user for most type of applications
00:36:57 <SrPx> cbarrett: pardon?
00:37:00 <ilmig> SrPx: user expect that applications look and behave a certain way on each platform
00:37:12 <SrPx> ilmig: I see, so that is the only problem?
00:37:32 <cbarrett> SrPx: apps built with your custom toolkit would look old and busted, whereas apps built with the native tools would look new / normal
00:37:52 <ashnur> l0cust: yesterday when I was removing all haskelly stuff, i deleted my ~/.cabal dir too. I thought installing cabal-install will recreate it, but it didn't. what creates that?
00:37:56 <SrPx> cbarrett: uh huh makes sense, ty
00:38:13 <ilmig> SrPx: it might also be a problem that you can't always assume that every platform provides proper opengl support
00:38:13 <johnw> ashnur: run "cabal update"
00:38:15 <l0cust> ashnur: shit, I don't know
00:38:22 <l0cust> ashnur: try johnw's idea
00:38:23 <ilmig> SrPx: due to gpu/driver issues
00:38:33 <SrPx> ilmig: what doesn't provide OpenGL support? );
00:38:51 <ashnur> johnw, l0cust that also complains for bash: /home/ashnur/.cabal/bin/cabal: No such file or directory
00:39:13 <ilmig> SrPx: on linux there are still quite a few users which use old onboard graphics, which is very slow and only supports very old versions of opengl
00:39:27 <johnw> do you need to "rehash" or something?
00:39:39 <ashnur> johnw: is that for me?
00:39:39 <ilmig> SrPx: and opengl support of the free drivers for nvidia and amd is sometimes still flaky
00:39:43 <johnw> ashnur: yes
00:39:50 <johnw> ashnur: run "which cabal"
00:39:56 <SrPx> I see, ilmig. What about Android/iOS? Is it possible to make applications for those at all?
00:40:03 <ashnur> johnw: /usr/bin/cabal
00:40:12 <johnw> so try: /usr/bin/cabal update
00:40:15 <johnw> then run: rehash
00:40:30 <ilmig> SrPx: I think so, when you would target OpenGL ES
00:40:43 <ashnur> johnw: thanks. i would've not thought of that
00:40:55 <johnw> bash caches where it has found commands on your PATH
00:41:03 <johnw> starting a new shell would have fixed it too
00:41:20 <SrPx> ilmig: is there any example of an android app made with haskell? How does the interaction with the device itself works? touchscreen, gps etc
00:41:41 <ilmig> SrPx: there are a few applications which are very successfull with their ui written using opengl. XBMC comes to mind for instance...
00:42:17 <SrPx> blender too!
00:42:37 <ashnur> johnw: i see. that's a good piece of knowledge i should've been aware of by now
00:42:54 <ilmig> SrPx: I don't know of any. It believe it could work in principal, but there is still a lot of groundwork to do.
00:43:00 <ilmig> SrPx: which you would have to do by yourself
00:43:05 <SrPx> ):
00:43:24 <cbarrett> SrPx: building GUI applications in a lazy functional programming environment is an open research problem
00:43:29 <cbarrett> see Functional Reactive Programming
00:43:39 <ilmig> SrPx: look at http://www.haskell.org/haskellwiki/Android for starters...
00:44:11 <SrPx> cbarrett: really? I expected it to be so simple
00:44:25 <SrPx> ... what could be so complicated about GUIs?
00:44:46 <johnw> SrPx: lol
00:44:55 <cbarrett> SrPx: well, a GUI is literally a graphical representation of state.
00:44:59 <johnw> everyone who has written a GUI thought that at some point
00:45:22 <cbarrett> and most GUIs need to have shared, mutable state to animate at 60fps
00:45:35 <ilmig> and what cbarrett said. In practice, Haskell isn't quite there yet for (cross-platform) GUI development. In theory it would be a great language, but real life pervasive libraries or bindings are missing.
00:48:20 <ashnur> this ghc. uses both my cpus :(
00:50:08 <l0cust> ashnur: both? what is this, 2006 :)
00:50:25 <johnw> note that he didn't say cores :)
00:50:43 <l0cust> alright, it's 2 AM, so I'm going to sleep - I'll be back around noon, probably
00:50:45 <l0cust> bye
00:53:36 <ashnur> cabal-install-1.20.0.1 depends on Cabal-1.20.0.0 which failed to install.
00:54:11 <ashnur> johnw: well, it's cores. it's a small netbook. not everyone is a rich basterd :P
00:54:52 <ashnur> and even this machine is breaking down in a too rapid pace. scary.
00:55:57 <ashnur> anyhow. isn't haskell scary enough in itself? why are so many problems around the tools?
00:57:36 <johnw> it wasn't designed around the user experience
00:57:36 <cbarrett> it's because tools are software, and software is really hard.
00:57:39 * merijn has never really had many troubles with tools
00:57:46 <johnw> but things are always getting better
00:58:07 <merijn> Clearly anyone who thinks haskell tools are terrible has never worked with any other build system >.>
00:58:42 <merijn> The only ones which are "better" are only better because they have thousands of man years of bugfixing and hard coding special cases in them which cabal has not yet had
00:59:31 <merijn> johnw: I think the problem isn't "haskell tools suck" but "people are coming into haskell from JS and similar where 'solving dependencies' means 'include a copy of the source of all your dependencies in the repo'"
00:59:56 <tdammers> I haven't seen a decent build system, like, *ever8
01:00:09 <tdammers> cabal with sandboxes is probably as good as it gets
01:00:09 * merijn came to use cabal after autotools and Makefile and thinks cabal is fantastic
01:00:12 <merijn> tdammers: Exactly
01:00:15 <cbarrett> yall looked at Nix / NixOS?
01:00:18 <cbarrett> Pretty interesting
01:00:47 <merijn> cbarrett: Interesting yes, but I don't have time for interesting when it doesn't solve any problems I actually have :)
01:01:27 <cbarrett> sure
01:01:33 <cbarrett> just while we're on the subject
01:02:12 <johnw> tdammers: I actually find Nix to be better than even cabal sandboxes
01:02:58 <johnw> now every project I work on is sandboxed, and yet binaries are shared, and *everything*, from the compiler to "ls" is sandboxed along with the cabal libraries
01:03:27 <johnw> it's like having 100 different OS installations, depending on what I'm focused on at the moment
01:04:33 <cbarrett> johnw: are you using Nix or NixOS
01:04:39 <johnw> Nix on OS X
01:04:43 <cbarrett> johnw !!
01:04:46 <cbarrett> I'm very interested
01:04:51 <johnw> join me in #nixos
01:05:06 <cbarrett> done
01:05:42 <tdammers> sounds interesting
01:05:56 <ashnur> johnw, cbarrett it's just strange that for example nodejs tools (in my experience) are the kind where stuff just works out of the box. and I wouldn't think for a second that it's because of the language or because of the developers writing those tools
01:07:23 <tdammers> nodejs "works" in the sense that the compiler doesn't slap you in the face for stupid mistakes, so you can superficially get away with a bunch of shortcuts
01:07:50 <tdammers> the whole duck typing attitude pretty much bleeds into the way they do version "management"
01:08:27 <ashnur> tdammers: you perhaps misunderstood me. i did not say nodejs works :)
01:08:49 <tdammers> I meant the ecosystem, not necessarily node itself
01:08:53 <tdammers> npm, specifically
01:08:55 <ashnur> i said the tools around nodejs work. which I think is different.
01:09:11 <startling> npm is about as sane as cabal, I think.
01:09:27 <ashnur> the problems I've been encountering with haskell tools do not seem to have any relation to the language itself
01:09:31 <tdammers> in my experience, cabal is pickier about incompatible versions
01:09:41 <startling> that's not cabal, i think.
01:09:51 <startling> that's haskell developers being pickier about bounds.
01:10:01 <tdammers> fair point
01:10:24 <ashnur> outdated packages, dependencies which are blocking updates, non-descriptive error messages. like this last one where it only says: Cabal-1.20.0.0 failed during the building phase. The exception was: ExitFailure: -11
01:10:47 <startling> ashnur: yeah, those suck. :(
01:11:02 <startling> sometimes there's a clue somewhere above it, but it's hard to say.
01:11:22 <ashnur> yeah, i am just trying a simple cabal install cabal-install
01:11:32 <startling> anyway, npm had the equivalent of "cabal sandbox" basically forever, which is nice.
01:11:36 <startling> *by default*
01:11:56 <ashnur> if I were doing something exotic, these kinds of issues wouldn't annoy me because I knew I am doing some srtange stuff
01:12:03 <klugez> http://blog.timoxley.com/post/20772365842/node-js-npm-reducing-dependency-overheads - startling already mentioned, but here's some more info.
01:12:20 <ashnur> but this is just one of many steps in getting haskell
01:12:32 <ashnur> so it's very discouraging towards newcomers
01:12:47 <startling> ashnur: if you haven't figured it out, could you paste the entire error message to lpaste.net/new/haskell ?
01:13:04 <klugez> I guess that's a huge part of why they have less dependency trouble. Haskell programs probably also have much bigger dependency graphs, which makes the problem cabal has to solve that much harder.
01:13:16 <klugez> Especially without sandboxes.
01:13:46 <makalu> you specify flags to cabal with "cabal configure -f=flags" right? It doesn't seem to work with cabal 1.20.0.1
01:14:19 <tdammers> there's a certain kind of elitism in the haskell ecosystem, yes
01:14:38 <tdammers> bit like the gruffy unix beard who scoffs at you for not understanding the perfectly concise man page
01:14:43 <ashnur> startling: http://lpaste.net/7171938554971422720
01:14:45 <makalu> interesting, it worked when I did "cabal clean" and then configured it again
01:14:47 <startling> I'm not sure npm-style "silos" are the right solution, especially in the presence of static types.
01:14:52 <juhp> makalu, no = I think
01:15:04 <sgronblo> Isnt npms pickiness about package versions completely up to how you specify the versions in package.json?
01:15:18 <startling> ashnur: wanna do /home/ashnur/.cabal/logs/Cabal-1.20.0.0.log too?
01:15:19 <merijn> ashnur: rerun with "-v3"
01:15:25 <startling> or that
01:15:43 <ashnur> startling: http://lpaste.net/1513550121537634304
01:15:46 <klugez> I don't mean to argue that it's the right solution, but it's better than what we had in the past before sandboxes.
01:15:49 <ashnur> merijn: what that does?
01:16:02 <ashnur> i only want haskell so I can install Elm
01:16:17 <merijn> ashnur: Run with maximum verbosity telling you exactly *what* cabal is doing so you can see where it crashed
01:16:42 <ashnur> merijn: thanks, will do it. brb in 10 minutes, because it takes forever to run
01:16:47 <startling> klugez: yeah, agreed
01:17:09 <startling> I don't know, it feels like we should have a notion of interfaces, and be able to say "package x isn't exposed in this library's interface"
01:17:29 <startling> then we can safely silo that dependency.
01:17:44 <startling> but how useful is that? how many internal-only uses are there?
01:17:48 <startling> it's a hard problem.
01:18:27 <ashnur> there are many things i dislike about nodejs and the ecosystem around it. but npm is not one of them. it's very simple, straightforward, and easy to use. almost no issues whatsoever, and even in those cases, it's usually a user-error
01:18:32 <startling> yeah.
01:18:40 <startling> npm is underrated.
01:19:20 <ashnur> sure, it doesn't solve all problems and stuff, but why should it. I rather have a something which does less but well, then something which aims for more and fails
01:23:30 <ashnur> and being newcomer friendly is something people don't appreciate enough. i would bet anything that the "success" of nodejs (which i doubt will last decades :) ) is mostly a consequence of npm
01:24:31 <danilo2> Hello! Does anybody know how can I contact goldfinger? I've got a very specific instance question and I cannot "catch" him here :(
01:24:56 <supki> ashnur: judging by -11 that looks like OOM
01:25:03 <ashnur> oom_
01:25:06 <ashnur> out of memory?
01:25:09 <supki> yep
01:25:18 <ashnur> could be, i have 3.5G
01:25:29 <ashnur> but it's almost full
01:25:58 <startling> danilo2: who is goldfinger?
01:26:40 <danilo2> startling: goldfinger is somebody working on GHC. I do not exactly know, but yesterday some people on IRC recommended me to contact him
01:26:47 <startling> ah.
01:26:53 <startling> no idea. have you tried #ghc?
01:27:25 <danilo2> startling: Oh not goldfinger, goldfire!
01:27:57 <startling> danilo2, lambdabot's @tell might be useful
01:28:12 <startling> danilo2: ( /msg lambdabot @help tell )
01:28:25 <danilo2> startling: Ok, thank you :)
01:30:03 <ashnur> so, these are the logs http://lpaste.net/520487600335618048 and http://lpaste.net/7918580634690256896 after trying it with -v3
01:31:34 <danilo2> @tell goldfire Hello goldfire! I've got a very specific question connected to haskell type classes. Some people on IRC recommended me to ask you. Would you mind if I ask you a short, but a little complicated question and ask for help?
01:31:34 <lambdabot> Consider it noted.
01:33:01 <merijn> ashnur: Hmm, looks like something got corrupted
01:33:11 <merijn> ashnur: Did you try running "ghc-pkg check" like it suggests?
01:33:52 <solrize> can anyone here update haskell.org homepage to mention bayhac as upcoming event?
01:35:24 <ashnur> merijn: didn't see that suggestion, missed it somehow, trying it now
01:35:58 <ashnur> it lists a bunch of broken packages
01:36:18 <merijn> ashnur: Which OS? Did you use your OS package manager to install things?
01:38:59 <ashnur> merijn: arch linux. i only installed ghc and cabal-install
01:39:18 <visof> hello
01:39:20 <ashnur> although yesterday i still had a lot of crazy things floating around from various repositories and from aur
01:39:25 <ashnur> but i removed everything
01:39:31 <ashnur> and tried from 0
01:39:38 <ashnur> i hope it was 0
01:42:01 <merijn> ashnur: tbh, I'm not really sure how to fix broken packages, as I've never had too. Just installing ghc and cabal-install shouldn't have broken anything
01:42:21 <ashnur> i don't think it did broke anything :)
01:42:23 <merijn> ashnur: What exactly did you remove? Nuking ~/.cabal and ~/.ghc should be sufficient
01:42:28 <ashnur> hmm
01:42:31 <merijn> (for starting from zero)
01:42:32 <visof> there is something we can do in imperative languages which is take some elements from a list and then break "get enough", i'm situation which i need to understand how can i do this in functional approach, example: i have a list of strings which i need only the first match in this list ?
01:42:37 <ashnur> i didn't delete ~/.ghc
01:43:03 <ashnur> will do it now.
01:43:56 <KorriX> Hello!
01:44:28 <KorriX> I'd like to use lens based tree zippers to modify structure of the tree
01:44:31 <KorriX> is that possible?
01:45:13 <KorriX> (I don't mean simple stuff like changing node value - I'd like to insert/remove nodes)
01:45:46 <merijn> ashnur: Ah, then GHC thought things were still installed even after you nuked the actual packages
01:45:51 <merijn> ashnur: This is likely what's wrong
01:46:09 <Arafangion> How do I get haskell to output generic LLVM? (Real question: How do I compile Haskell to Javascript using emscripten?)
01:46:12 <merijn> ashnur: GHC *thinks* dependencies for cabal are installed, but then when it looks for them they're gone
01:46:36 <merijn> Arafangion: Is there a reason for going through LLVM and emscripten as opposed to using ghcjs? :)
01:47:01 <merijn> (Incidentally did ghcjs have an official release yet?)
01:47:20 <Arafangion> merijn: No, actually, other than that I was under the impression that ghc -> LLVM is likely to be a more stable and tested path.
01:47:51 <Arafangion> merijn: And uses the same language.  Isn't ghcjs Haskell '98?
01:47:55 <merijn> Arafangion: ghcjs should have had (or will soon have) their 1.0 release and should be fairly stable
01:48:08 <Arafangion> Nice.
01:48:12 <merijn> Arafangion: No, ghcjs supports all GHC extension
01:48:18 <Arafangion> Very nice.
01:48:36 <merijn> Arafangion: It should also support: lightweight threads and STM :)
01:49:06 <Arafangion> Very, very nice. :)
01:49:18 <Peaker> hmm. someone told me you cannot represent the dependent-pair/sigma type via Pi type.  But why wouldn't   type Sigma a (b:a->*) = (r:*) -> ((x:a) -> b x -> r) -> r     work?
01:49:18 <Arafangion> Considering js doesn't do threads. :)
01:49:44 <Arafangion> merijn: Do you happen to have it installed?
01:49:49 <tdammers> Arafangion: doesn't mean you can't have green threads
01:50:02 <Arafangion> tdammers: I realise that, doesn't make it any less nice. :)
01:50:08 <tdammers> yeah
01:50:15 <kylec01> i'm finding this parody hilarious http://geomblog.blogspot.ca/2004/04/meta-proof.html
01:50:22 <merijn> Arafangion: Clearly the green threads won't run in parallel, but they'll just be timeshared :)
01:50:35 <tdammers> still better than callback hell though
01:50:45 <Arafangion> Indeed.
01:50:46 <merijn> Arafangion: No, I haven't played with it, but luite is here a lot and he's working ghcjs
01:50:59 <tdammers> and if it means we can have per-thread "blocking" calls that translate to async calls under the hood, wheeee!
01:51:05 <Arafangion> merijn: Cool, was just wondering what the initial overhead for 'hello world' was, in terms of app size.
01:51:18 <yitz> merijn: ghcjs uses the ghc runtime? or just compiles down to js?
01:51:34 <merijn> yitz: It has a JS implementation of the GHC runtime
01:52:18 <yitz> merijn: got it. so basically, compiles down to js, but still tries to emulate the entire runtime. sounds ambitious.
01:52:26 <Arafangion> merijn: fyi, the reason I was looking at emscripten was: "It compiles C++ using Clang, and then gets the LLVM bytecode. Hmm, haskell also can produce LLVM bytecode".
01:52:55 <Arafangion> merijn: But apparently organises that bytecode in such a way that it breaks emscripten, as I found out. :)
01:53:24 <merijn> Arafangion: Maybe take a look at for example: http://weblog.luite.com/wordpress/?p=127
01:53:34 <k00mi> Peaker: maybe ask in #agda?
01:53:46 <Peaker> k00mi: good idea :)
01:53:51 <yitz> Arafangion: llvm has a lot of fiddly details. two different backends coming from different languages would not work together unless this was explicitly worked on by the implementors.
01:54:02 <Aetherspawn> well
01:54:07 <Aetherspawn> haskell threads can be done with only 1 OS thread
01:54:18 <Aetherspawn> because they yield at allocations
01:54:21 <Arafangion> yitz: They surely agree on the location of _main
01:55:08 <yitz> Arafangion: truthfull i don't remember the details, but i do remember that there is a *lot* more than that to llvm configurations.
01:55:20 <yitz> *truthfully
01:56:47 <Arafangion> yitz: Enscripten claimed to just operate using the bytecodes.  Note I'm not trying to achieve interoperability.
01:57:01 <Arafangion> yitz: I'm not aiming to mix C++ and Haskell, for instance.
01:58:18 <Arafangion> merijn: That page does look interesting, looks complex though.
01:59:25 <sgronblo> It wasnt easy to either google or duckduckgo for "haskell <|>"
01:59:26 <merijn> Arafangion: There are simpler examples on his blog too, this was just the first I found
01:59:32 <merijn> sgronblo: Use hoogle
01:59:36 <merijn> @hoogle (<|>)
01:59:37 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
01:59:37 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
01:59:37 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
02:00:14 <sgronblo> Yeah I had a vague memory I saw it for applicatives
02:01:14 <Arafangion> merijn: I'm not sure I want to use Haskell for the *actual* UI.
02:01:28 <Arafangion> (Unless it is SDL canvas or something)
02:02:59 <d3lxa> I need to uninstall a package from my big cabal sandbox, I tried ghc-pkg unregister but it says it didnt find the package, any idea?
02:04:51 <merijn> Arafangion: Well, there's should examples of using the JS FFI too, which lets you call handwritten JS from "haskell JS" and vice versa
02:05:33 <bonobo123> @d3lxa: cabal sandbox hc-pkg
02:05:33 <lambdabot> Unknown command, try @list
02:05:48 <Arafangion> merijn: I intend to have the view in 'regular html5', and the business logic and all that in haskell, if feasible.
02:06:01 <bonobo123> d3lxa: cabal sandbox hc-pkg
02:06:05 <Arafangion> Assuming I find time to actually /do/ it.
02:08:07 <merijn> blah
02:08:11 <merijn> haddock is so helpful...
02:08:24 <merijn> "doc comment parse failed"
02:09:09 <danilo2> Hello! I and few friends of mine are facing a big problem right now. We are trying to create a "hackish" haskell function (needed by the generated haskell code) and we cannot get it working. The scratch question and code I've posted here: http://lpaste.net/103731 . Is there anybody, who can help us with fundeps and type families?
02:09:16 <d3lxa> bonobo123: ok, with unregister, thx!
02:19:30 <Cale> danilo2: I'm not sure I understand why you can't just generate type-correct code to begin with
02:22:49 <danilo2> Cale: I did not explained it, because it is a little complicated, please look here (annotation to: http://lpaste.net/103731). It is a little longer version, but does not compile. The function "autolift1" is a generated function and I do not know if it is even possible to provide a sensible type to it (when we comment out the line, the code works)
02:24:04 <danilo2> Cale: So basically, If I generate code, which uses fundeps (like "unFunction") combined with the solution I provided earlier, everything literally explodes. Maybe its easy way to generate signature for functions like "autolift1" ? But so far I did not found any solution
02:24:46 <merijn> danilo2: Why not just have your compiler generate simpler code for what you're trying to do?
02:25:17 <Cale> It seems to me like it would be way easier to just generate the lifts which were appropriate to begin with, rather than trying to oleg all the relevant logic into multiparameter type class instances
02:25:34 <Cale> I mean, you could just as well do that same stuff in your compiler
02:26:42 <merijn> Does anyone know the secret of getting haddock to generate a bold font? The docs say double leading and ending underscore, but that doesn't appear to work?
02:26:51 <danilo2> merijn: It is generating simple code, but it allows to define custom functions. And what I'm doing right now is just writing a "library of functions" using internally by every generated function. We really want users to be able to call any function like (String -> String) with argument in a monad. If the types are known, this lifting should be done
02:27:14 <jophish> Is there a way to search for packages which depend upon a particular package
02:27:15 <merijn> danilo2: So why don't you do it in your compiler?
02:27:34 <merijn> jophish: http://packdeps.haskellers.com/reverse ?
02:27:49 <danilo2> Cale: You may be right, but I would love to use GHC as much as I can. If it is possible to code in GHC, it would help us so, so much ...
02:28:02 <danilo2> merijn: ^^^
02:28:19 <jophish> merijn: Perfect, the package I'm looking for isn't there though :(
02:28:20 <merijn> danilo2: Why would it help you? Tricking GHC into doing what you want is much, MUCH harder than just having your own compiler do it
02:29:30 <hexagoxel> jophish: cabal-db revdeps
02:30:02 <danilo2> merijn: We've got to write a complex type inferencer. Right nwo we have some basic one, but If GHC will handle such situations, even if the type inferencer "does not sound very well", GHC is something, which is working always good. If it is impossible to create such functionality here - maybe its good idea to make it in our compiler though, hmm
02:30:05 <jophish> hexagoxel: I'll give that a try. Thanks
02:30:16 <supki> merijn: I think bold is only supported with the latest haddock?
02:30:23 <hexagoxel> but i guess that will only list the revdeps in the installed packages
02:30:31 <merijn> supki: Yeah, I just saw that :\
02:30:40 <danilo2> merijn, Cale: anyway, could you tell me also - are we even able to write any tyope signature for function "autolift1" ?
02:31:22 <merijn> danilo2: Making GHC do you type checking means your language can only do things which GHC allows and from what I've seen you ask in the past you want to do things which are radically different from what GHC does...
02:31:36 <jophish> hexagoxel: ah, I'll search github for "import Bound"
02:32:24 <merijn> supki: Oh, now I remember what I did in the past...
02:32:29 <jophish> that worked well
02:32:35 <merijn> supki: Horrible, HORRIBLE unicode abuse to fake bold >.>
02:33:17 <supki> merijn: did it work?
02:33:21 <danilo2> merijn: You are right. I'm sorry for asking such "strange" questions sometimes and thank you for a lon-term help you were always providing. Whats funny - at the end, we were able to code everything I was talking in the past using GHC type functions and TH! :)
02:33:37 <merijn> supki: Sure, check the TL;DR after the first heading: http://hackage.haskell.org/package/transformers-supply-0.1.0/docs/Control-Applicative-Supply.html
02:33:53 <merijn> supki: It abuses unicode's support for "blackboard bold" characters :>
02:34:50 <supki> merijn: I'm surprised, IME haddock and unicode do not mix
02:35:02 <supki> It's probably got better with 2.14
02:35:20 <danilo2> merijn: Anyway, do you think, just out of curious, is it possible to create what I wanted in Haskell? (to ask the inferencer to infer the type c out of a and b) using some fundeps / type families / a magic? If not - the last question - is it possible to write a type for function "autolift1"? I was unable to do so :(
02:36:13 <merijn> danilo2: Is it possible? Probably...will it be a Herculean task involving lots of pain and more hacks than you'd wish upon your worst enemy? Probably that too
02:39:43 <danilo2> merijn: Ok, I think we have to built this functionality into our type inferencer then. Anyway - asking as a haskell user - are we even able to write a type for function autolift1 in the example (http://lpaste.net/103731) - It is working - in the main function I'm using its body, which compiles and works fine, but If I create a function out of it, everything crashsh - I'm interested why this happens, because this is very interestin
02:41:10 <danilo2> *point of view
02:42:43 <merijn> danilo2: tbh, I dunno what autolift is supposed to be doing
02:43:28 <dinkarganti> I am having trouble manipulating rose trees (data.tree). I need to represent a hierarchy
02:44:28 * hackagebot hpc-coveralls 0.2.2 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.2.2 (killy971)
02:44:49 <Cale> dinkarganti: What problem are you having?
02:45:36 <danilo2> merijn: Look at it definition - **exactly** the same body is used in main func. It gets a function, like (String -> String) and allows to provide argument with either (String) or (m String) type. An example of this working (it compiels and works after commenting the autolift1 def) is on line 80 and 81. The same function, with arg and arg in monad
02:45:37 <dinkarganti> @Cale: So I tried to go with Data.Tree but I could not find a "findNode" function that would return a Context that I can pass to manipulate the tree. I am sure I am missing something here.
02:45:38 <lambdabot> Unknown command, try @list
02:47:09 <dinkarganti> Cale: I found that HXT's NTree to be a bit more robust, but I could still not find a "find node". So what i wanted to accomplish is to add, children to existing parents, move children one level down etc.
02:47:53 <Cale> You may want to use one of the zipper libraries
02:48:56 <dinkarganti> Cale: For zippers to work, do we have to write our own find function based on equality? Is that the only way: I would have axpected that to be part of the interface?
02:50:27 <Cale> dinkarganti: To be honest, I've never actually used Data.Tree for anything real. In most cases where I've ever wanted a tree type, the nodes had specific meaning to me, and so inventing my own datatype was more convenient.
02:50:56 <Cale> Also note that a lot of the things people use trees for are data structures whose implementations already exist in various libraries (especially Data.Set / Data.Map)
02:51:34 <dinkarganti> Cale: I have these kinds of category trees in a couple places and the tree abstraction seemed to make sense (rose tree). but the interface is not intuitive to me at least.
02:52:44 <dinkarganti> Cale: Also, what I found is that I am interested in maintaining the order, levels etc for the application: so I was not planning to use a set. My initial solution was to associate each node with its parent instance and put it in a map. But that meant that I had to write functions for traversal etc.
02:52:58 <Cale> http://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html
02:53:14 <Cale> You'd still have to write your own find
02:53:48 <dinkarganti> Cale: whew! that is what baffled me a bit. I was expecting it to be part of an interface..because this is a basic usecase.
02:53:49 <Cale> But that provides a data structure related to the trees in Data.Tree in such a way that you can "move the focus around"
02:54:21 <dinkarganti> Cale: rosezipper in version 1.0 did provide a find..i am still not sure why that was taken out.
02:54:58 <dinkarganti> Cale: same is true with lenses: we still have to search for our node: which seems to be boiler plate or because this is a rose tree, we can get multiples?
02:56:07 <dinkarganti> Cale: a find, crumb and subsequently running through a zipper is what i need. I have to put the find part: it seems.
02:56:48 <merijn> hmmm, with Pipes there's no way to detect whether downstream was expecting more input, no?
03:00:22 <dinkarganti> Cale: thank you for the pointers. at least I did not miss something obvious. I know what i need to do now.
03:01:25 <jophish> Yo yo yo
03:01:38 <jophish> Is anyone here familiar with the Bound library?
03:09:31 * hackagebot creatur 5.4.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.4.1 (AmyDeBuitleir)
03:11:25 <danilo2> merijn, Cale: Anywaym, thank you for the help! :)
03:15:18 <ashnur> i read here that installing some dev version of pandoc might solve my issues
03:15:20 <ashnur> https://github.com/jgm/pandoc/issues/1281#issuecomment-42335943
03:15:27 <ashnur> but how is that possible?
03:19:21 <ashnur> please? :) http://i.imgur.com/muXHWKI.png
03:22:20 <Heather> hi
03:22:39 <Heather> is it possible to define operator which will take two arguments from infix?
03:22:56 <Heather> for example: a b ||> c =
03:23:14 <Hafydd> Not in standard Haskell.
03:23:17 <Cale> Heather: ah, no
03:23:28 <flux> (a ||> b) c :)
03:23:29 <Cale> You can have an infix operator which produces a function
03:23:32 <Cale> yeah
03:23:57 <Heather> can I use a b as tuple ?
03:24:01 <Hafydd> (a,b) ||> c -- would also be possible
03:24:04 <Cale> a b ||> c will get parsed as (a b) ||> c
03:24:22 <Cale> yeah, you could use a tuple, like Hafydd shows
03:25:43 <Heather> (||>) :: (a, b) -> ((a, b) -> c) -> c
03:25:50 <Heather> looks fine
03:26:03 <Cale> ashnur: Apparently your problem is an arbitrary and out-of-date upper bound on the version of a dependency
03:26:53 <Cale> But that's just function application with a weird type, and backwards
03:27:23 <Cale> So, you could just write c (a,b) instead of (a,b) ||> c
03:27:59 <eizo> > :t flip ($)
03:28:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:28:12 <Cale> :t flip ($)
03:28:12 <lambdabot> b -> (b -> c) -> c
03:28:22 <eizo> ty
03:29:06 <flux> @djinn (a, b) -> (a -> b -> c) -> c
03:29:07 <lambdabot> f (a, b) c = c a b
03:29:56 <Heather> ahm
03:31:00 <ashnur> Cale: wat? i am not writing haskell, i am trying to install Elm, pandoc is a dependency of that
03:31:00 <Heather> let say <||
03:31:45 <Heather> (<||) :: ((a, b) -> c) -> (a, b) -> c
03:32:03 <Cale> Heather: in that case, it's just ($) :)
03:32:14 <Heather> Cale: it takes tuple....
03:32:17 <Cale> (with a specialised type)
03:32:22 <Heather> or it doesn't matter if it tuple or not
03:32:25 <Cale> Or id
03:32:26 <Cale> :)
03:33:22 <Heather> Cale: will $ work with tuple ?
03:33:44 <Heather> Cale: foo $ a, v ?
03:33:59 <Cale> foo $ (a,v)
03:34:05 <Heather> and without brackets?
03:34:08 <edofic> > id $ (1,'d')
03:34:09 <Cale> Of course, you could just write foo (a,v)
03:34:10 <lambdabot>  (1,'d')
03:34:18 <Cale> You need the brackets to make the tuple
03:34:23 <Heather> damn
03:34:34 <edofic> but left of ($) you can use a complex expression
03:34:39 <Cale> The comma is part of other syntaxes, so it doesn't mean anything on its own
03:35:01 <edofic> of couuse you could do something like (-->) = (,)
03:35:02 <Heather> so such operator will be meaningless
03:35:22 <ashnur> i see there are numerous different possible ways to install pandoc, my question is, are they result in the same thing? if I install it from source, will cabal install elm (which depends on it) find it?
03:35:53 <edofic> ashnur, install from source how? git clone?
03:35:58 <edofic> in that case no it won't find it
03:36:07 <edofic> are you using a cabal sandbox?
03:36:20 <ashnur> edofic: http://hackage.haskell.org/package/pandoc
03:36:55 <Cale> ashnur: You can install it from source by running "cabal install" from the source directory
03:36:59 <ashnur> edofic: i am not doing anything but trying to somehow install elm. no sandboxes, no code, no flags, no magic. just trying to install elm. that's all. and I am trying this since 2 days ago
03:37:04 <Cale> (the directory with the .cabal file in it)
03:37:08 <ashnur> so it's getting friggin frustrating
03:37:11 <Cale> and then other things will see it
03:37:19 <ashnur> Cale: thank you
03:37:39 <edofic> ashnur, try this: mkdir elm-install; cd elm-install; cabal sandbox init; cabal install elm; .cabal-sandbox/bin/elm
03:38:22 <ashnur> edofic: why would that help?
03:38:46 <edofic> ashnur, because it will install all dependencies from source into a clear sandbox
03:38:47 <ashnur> it doesn't seem to solve the issue that pandoc can't be installed with cabal
03:40:13 <edofic> ashnur, sorry didn't catch everything.. what's your problem with pandoc? i have it installed it with cabal
03:40:54 <ashnur> edofic: https://github.com/jgm/pandoc/issues/1281#issuecomment-42335943
03:41:12 <ashnur> well, not just the comment, the whole issue, sry for the too specific link
03:41:15 <Cale> ashnur: Well, he (or whoever else) could fix the trivial problem with the dependency version upper bounds
03:41:23 <Cale> oh
03:41:37 <Cale> er, sorry, got confused about who was who :)
03:42:56 <ashnur> Cale: yeah, i think there are things which could be fixed. for example the totally unrelated but ultimately frustrating outdated not on the GHC page which says that haskell-platform has ghc bundled with it, while the last 3 realeases 2013 and both 2012 do not, so i am guessing that's outdated since 2 years ago
03:43:35 <ashnur> haskell is scary and when someone is new to it like me, and tries to find anything, this channel is the only place where there is reasonable help
03:43:53 <Cale> ashnur: er, what?
03:44:00 <Cale> It's supposed to contain ghc
03:44:04 <ashnur> although, i must say, this is the best channel i've seen on freenode, i always get help here, once I even asked about something not related to haskell and people helped me :)
03:44:20 <Cale> http://www.haskell.org/platform/changelog.html
03:44:23 <sgronblo> How do I translate the description for Applicative's <|> "An associative binary operation" to Snap's more practical definition: "It is simply a binary operator that evaluates its first argument, and if it failed, evaluates the second. If the first argument succeeded, then it stops without evaluating the second argument."?
03:44:30 <pagbk25> hi!
03:44:42 <Cale> ashnur: It contains 7.6.3 according to the changelog at least
03:44:49 <pagbk25> I get a message "##linux :Cannot send to channel" on ##linux...
03:44:54 <pagbk25> can anyone help me please?
03:44:56 <ashnur> Cale: dunno, when I tried ./configure in it, it was complaining about not having ghc
03:45:19 <pagbk25> I get the same on ##crypto
03:45:20 <Cale> sgronblo: By reading the instance which is being used
03:45:21 <seanparsons> pagbk25: Are you posting in the wrong channel?
03:45:34 <ashnur> Cale: maybe should've read the damned README though, will do that next time
03:45:35 <Cale> ashnur: Oh, building from source will of course require ghc
03:45:36 <sgronblo> Cale: I see
03:45:41 <pagbk25> I don't know which one to post, so I come to haskell because it's the last I was on
03:45:45 <pagbk25> seanparsons
03:45:47 <ashnur> Cale: well then.. :)
03:45:48 <Cale> ashnur: ghc is written in Haskell, you need a working ghc to compile it
03:46:02 <ashnur> Cale: i know, but that's the link the site gives out
03:46:04 <Cale> (like most compilers)
03:46:35 <ashnur> sure, i see the point in it :) i mean i understand why it needs it, i imagined that maybe it installs first ghc then the rest
03:46:36 <seanparsons> pagbk25: Probably worth starting here rather than a random IRC channel: http://freenode.net/faq.shtml#gettinghelp
03:46:37 <Cale> Ordinary users are not really meant to use the source version of Haskell Platform
03:46:49 <Cale> The whole point of Haskell Platform is to provide binary versions of stuff
03:46:53 <pagbk25> okay seanparsons, thanks, bye
03:47:02 <sgronblo> I also thought the idea of an Applicative Functor was that the function to fmap was in the same "container" as the value to fmap it to?
03:47:56 <ashnur> yeah, well, then thre is the the other thing, that the support for haskell on arch (once supposed to be great) is lacking, to say the least. i would use harsher words, but I don't want to annoy anyone. there are half a dozen repos, a lot of aur packages, nothing seems to be compatible with anything, and basically each install is a possible step on a landmine
03:47:59 <Cale> In the case of the linux version, the source distribution is used by the people who make packages for various distributions (Ubuntu, Debian, etc.)
03:48:13 <Cale> hm
03:48:38 <Arafangion> There are surely precompiled versions for linux, too.
03:49:30 <Cale> Arafangion: Maybe someone built a generic linux version, but if so, then it's not on the HP site :)
03:49:52 <Cale> But what I do on Linux is just avoid the Haskell Platform and my distribution's Haskell packages
03:49:59 <Arafangion> Yeah, I just noticed. They do have an arch-specific link, but it's broken.
03:50:01 <edofic> ashnur, i ran my command for building elm in a sandbox. and it built and installed successfully. (64bit archlinux & ghc 7.8.2 & cabal-install 1.20)
03:50:04 <ashnur> Arafangion: there are. problem is, even if you just use cabal you can get lot of dependency errors. now imagine that with random packages some maintained, some not.
03:50:04 <Cale> I just install the generic Linux binary GHC from the GHC download page
03:50:08 <Cale> and then cabal install
03:50:19 <edofic> pacman -S ghc cabal-install
03:50:28 <Cale> (which includes a bootstrap.sh script when you download the tarball from Hackage)
03:50:59 <Cale> and once cabal-install is installed, I can just get other packages as I need them (installed as user)
03:51:08 <ashnur> edofic: thank you, i will try that if the pandoc-dev version fails. it's just that having elm sandboxed sounds to me something special, probably has it's own issues, and when I will ask help about Elm, i will have to explain them why my install is different..
03:51:11 <Arafangion> Sounds reasonable.
03:51:58 <Cale> ashnur: The sandbox is only with respect to building the program
03:52:03 <Cale> ashnur: The end result will be the same
03:52:11 <ashnur> Cale: yeah, but i did not know this. if an arch user wants to try out haskell, it gets this: https://wiki.archlinux.org/index.php/Haskell_Package_Guidelines
03:52:15 <ashnur> check the first line
03:52:32 <ashnur> Cale: oh, i didn't know that
03:52:56 <Cale> ashnur: Cabal sandboxes just provide a fresh start for the libraries which get installed
03:52:59 <ashnur> well then. i will still try this pandoc stuff because i am almost done with it, but i will probably do the sandboxy thing anyway
03:53:28 <ashnur> Cale edofic why I don't get, how the sandbox solves the pandoc issue?
03:53:31 <Cale> ashnur: i.e. so that other already-installed dependencies on your system can't interfere, and so that dependencies installed for building the program won't mess with future builds
03:53:50 <Cale> I'm not sure, perhaps the version on Hackage has been updated since those posts?
03:53:56 <ashnur> what I don't get* sorry for the typos
03:54:00 <sgronblo> Ah <|> is not Applicative, it's Alternative?
03:54:05 <Cale> sgronblo: yes
03:54:11 <Cale> sgronblo: (sorry)
03:54:20 <merijn> Any pipes-parse experts around? I for the love of me can't figure out how to create nicely composable parsers
03:54:59 <merijn> Clearly I can't have "Pipe a b m r" for a "Parser a b", as that doesn't detect premature termination
03:55:36 <merijn> But I'll be damned if I can see how I would write something composable like "Pipe a b m r" using the pipes-parse Parser type...
03:58:04 <Cale> ashnur: I wonder if the Arch linux support for Haskell has degraded a bit since Don Stewart got really busy with his life. I recall that back when he was working on it, people talked about how good the Haskell support on Arch was.
03:59:40 <ashnur> Cale probably. Most people who are now using haskell on arch just use cabal
03:59:49 <ashnur> like that's the best option they say
04:00:21 <Cale> Especially if you're writing any Haskell code, you'll certainly want cabal.
04:00:27 <ashnur> the pandoc thing already threw an error because of temporary
04:00:38 <Cale> I'm surprised that Elm has users who are not Haskell programmers
04:00:48 <ashnur> i am sure it can be installed, but first I try the sandbox idea
04:01:34 <ashnur> Cale: well, Elm reaches much beyond the usual haskell scope in the browser/gui domain
04:01:59 <sgronblo> I'm kind of struggling a bit to see the point of Applicative
04:02:27 <Cale> sgronblo: Do you understand what Monad is about?
04:02:58 <merijn> sgronblo: You understand how "fmap" works, right?
04:03:14 <merijn> Now consider this:
04:03:15 <sgronblo> Well how could I prove I understand monads? Should I write a blog post with a great analogy or? :)
04:03:18 <merijn> :t fmap elem
04:03:19 <lambdabot> (Functor f, Eq a) => f a -> f ([a] -> Bool)
04:03:28 <Cale> ashnur: Yeah, but the language itself is very similar to Haskell.
04:03:39 <merijn> sgronblo: Note how the result of fmap is a function within "inside" f
04:03:43 <ashnur> Cale: it is, which is a great thing :)
04:03:56 <merijn> sgronblo: How do we do something useful with that function?
04:04:07 <merijn> :t (<*>)
04:04:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:04:46 <merijn> sgronblo: Applicative's <*> can take an "f (a -> b)" as producded by, for example, "fmap elem" and turn it into a function we can do something useful with
04:05:12 <sgronblo> Wait, what is elem again?
04:05:22 <sgronblo> Test for membership?
04:05:27 <ion> > 5 `elem` [5]
04:05:29 <lambdabot>  True
04:06:22 <ion> @type fmap elem
04:06:23 <lambdabot> (Functor f, Eq a) => f a -> f ([a] -> Bool)
04:06:45 <ion> @type fmap elem (Just 'a')
04:06:46 <lambdabot> Maybe ([Char] -> Bool)
04:09:40 <Cale> ashnur: Of course, the fact that it's not actually Haskell is a bit of a disadvantage. I hope that GHCJS or something like it eventually can become a standard part of GHC.
04:10:57 <ashnur> Cale: i am not familar with any of these techs, i am just beginning to learn them. another one I will spend time in the near future is purescript
04:11:01 <ion> I hope there will be a GHCJS with the size of the generated code reduced by two orders of magnitude, but i’m probably wishing for too much.
04:11:37 <Cale> http://hdiff.luite.com/ghcjs/examples/balls2/out.js :D
04:11:55 <Cale> This runs astoundingly well somehow
04:12:00 <Cale> http://hdiff.luite.com/ghcjs/examples/balls2/
04:14:20 <ion> Heh, it even works with a somewhat reasonable framerate on my phone. :-P
04:14:23 <Cale> It's hard to know what the right things would be to do in order to help the browser implementations to run the javascript more efficiently
04:14:37 <Arafangion> Cale: It's amazing how fast javascript is these days.
04:14:42 <Cale> The code is obviously just high level assembly
04:14:55 <Cale> (It looks pretty much like the C-- code does)
04:14:56 <ion> cale: Taking advantage of asm.js is probably important.
04:14:57 <ashnur> people often underestimate the speed of js
04:15:05 <Arafangion> Cale: Some benchmarks put it at 2x the performance cost of C, for a restricted subset of javascript.
04:15:09 <ashnur> dunno why, haven't you seen unreal4 running in a browser yet?
04:15:10 <Arafangion> Which is... Insane.
04:15:35 <ion> http://hdiff.luite.com/ghcjs/examples/balls2/out.js doesn’t seem to use asm.js
04:15:39 <Cale> ashnur: Well, I haven't seen unreal 4's code
04:15:46 <ashnur> Arafangion: it's already below 2. there are one or two microbenchmarks where asm.js is faster than clang :)
04:15:51 <ashnur> compared to gcc
04:15:58 <Cale> ashnur: But if you look at the generated javascript here, it doesn't *look* like it should be particularly speedy
04:16:04 <Arafangion> unreal4's mkostly C or C++, afaik, anyway it was copmiled using emscripten.
04:16:06 <Philonous> All that effort spent on optimizing a historical accident...
04:16:13 <hpc> it's not speedy where it matters; the source is 4 megs
04:16:21 <ashnur> Cale: it's a friggin modern game engine, compiled to asm.js with emscripten. not much to see there
04:16:46 <hpc> good luck getting that to stay in cache
04:16:50 <ashnur> Cale: well, this isn't asm.js but the JITs are getting better and better anyway.
04:17:06 <Arafangion> ion: Indeed, doesn't look like that's using asm.js
04:18:25 <Cale> I wonder how well this compresses via gzip
04:18:49 <ion> IIRC minified and gzipped GHCJS output was still huge.
04:19:05 <Philonous> Cale "curl http://hdiff.luite.com/ghcjs/examples/balls2/out.js | xz | wc -c " says 188472
04:19:17 <ashnur> i think ghcjs should compile to asm.js
04:19:28 <ashnur> if that's possible of course
04:19:41 <Cale> Philonous: 275562 using gzip rather than xz
04:19:42 <ion> It’s surely possible.
04:19:54 <quicksilver> 188K doesn't strike me as absurdly large for a program which (I imagine) contains large chunks of standard lib
04:20:09 <quicksilver> a statically linked hello world in ELF format is much larger than that.
04:20:39 <ashnur> ion: if you get asm.js, the size doesn't matter much. i mean sure, megabytes of js sounds scary, but it only matters in the network time
04:20:59 <ion> Network time is exactly what i’m concerned about.
04:21:11 <ashnur> well, i don't think you should be too much
04:21:40 <Arafangion> It's not like it's a website. :)
04:21:43 <Cale> Oh no! Megabytes! Hang on while I upload a YouTube video about my outrage.
04:21:46 <Arafangion> These tend to be "applications".
04:21:56 <ion> cale: Youtube supports this thing called streaming. ;-)
04:22:10 <ashnur> ion: there are very sophisticated solutions keeping js source cached in indexeddb and such, only downloading differential updates... etc.
04:22:25 <ion> I’d love to be able to use GHCJS on websites instead of just “applications”.
04:22:37 <ashnur> ion: well, websites are stupid :)
04:23:18 <ashnur> i really really hope websites die out very fast and maybe then we can disband the w3c and other groups of maniacs with their sgml derivatives and DOMs
04:23:52 <ashnur> so we can have real browsers which actually do something interesting, and are fast and easy to use...
04:24:49 <Philonous> ashnur, Chuck out HTML and  replace it with flash and java?
04:24:52 <ashnur> btw, my sandbox install will fail, it already failed to install temporary
04:25:21 <ashnur> Philonous: wtf? so if I don't like markup languages, I am a proponent of even worse things? why do you think that?
04:26:43 <ashnur> there was this idea that we will have a network and we will share static documents on it. it was a good idea, but after 30 years we know we can do much more on it. we should ditch everything based on documents and start anew. this doesn't mean proprietary VMs and ... i don't even know what to say about flash :(
04:27:08 <Philonous> ashnur, I didn't think you where. But that's whats going to happen. Everyone will want their own, over-engineered, proprietary thing with DRM and customer lock-in.
04:28:23 <ashnur> Philonous: i think you are right that most people/companies will want that. but I think there will be some who will not want that. which I hope will be enough
04:28:51 <Philonous> ashnur, We should probably take it to -blah
04:29:14 <Cale> https://www.youtube.com/watch?v=So3srsXfT48 -- I've just started watching it, but this seems really interesting :)
04:30:05 <ion> cale: Thanks
04:31:21 <ashnur> Philonous: wat is blah? :)
04:31:58 <aspidites> http://www.haskell.org/haskellwiki/IRC_channel#Related_channels
04:32:18 <ashnur> hah
04:32:23 <ashnur> there are some channels :-S
04:33:11 <Philonous> ashnur, #haskell-blah . To keep the maount of off-topic noise in here at bearable levels.
04:33:23 <ashnur> i see. i will contain myself :)
04:33:40 <ashnur> there is a haskell llvm compiler?
04:34:14 <Arafangion> ashnur: It's one of the backends ghc seems to support.
04:34:48 <ashnur> because if there is, then haskell can be  compiled to asm.js
04:35:01 <ashnur> with emscripten
04:35:39 <ashnur> damn. edofic left. i would've told him that the sandbox thing failed
04:35:52 <aspidites> what sandbox thing?
04:35:53 <ashnur> same way as the install without sandbox
04:36:00 <ashnur> aspidites: i am trying to install Elm
04:36:16 <Arafangion> ashnur: ghc seems to do something with the bytecode that emscripten doesn't expect.
04:36:18 <ashnur> aspidites: but it's kinda impossible with all the dependencies of the dependencies of the dependencies failing
04:37:00 <Arafangion> ashnur: Mind you, I'm _very_ new to haskell, I had to download a hello world .hs file, even.  But emscripten couldn't cope with it.
04:37:32 <tdammers> compiling haskell to js is a bit more complex than compiling haskell to machine code
04:37:46 <Arafangion> tdammers: You misunderstand.
04:38:43 <Arafangion> tdammers: What ashnur is saying (and what I already worked through earlier today), is that there exists a haskell -> LLVM bytecode compiler. There also exists an LLVM bytecode -> Javascript compiler.
04:38:48 <ashnur> Arafangion: you can't be "newer" than me :P. i am only here because I can't install Elm
04:39:11 <Arafangion> ashnur: Ah, so you've attempted it, then.  I'm still newer. :)
04:39:17 <ashnur> tdammers: llvm is not machine code though :)
04:39:36 <tdammers> Arafangion: yes, I know. And the end result is that you compile hs to js
04:39:50 <tdammers> Arafangion: but that's still more complex than compiling to machine code directly
04:39:59 <Arafangion> Yeah, except it doesn't seem to work.  ghcjs seems to be the recommendation.
04:40:16 <tdammers> yeah
04:40:38 <tdammers> I'm saying this because haskell can be overwhelming for newcomers, even without the added complexity of targeting JS
04:41:52 <ashnur> Arafangion: there is purescript too :)
04:41:58 <Arafangion> ashnur: Bah.
04:42:12 <vijaykiran> hello - I'm getting this error https://gist.github.com/vijaykiran/f46308cdc56dc690215b while trying to init a new cabal project with diagrams library - can anyone give me a hint how to fix this ?
04:42:50 <vijaykiran> I tried cabal install mtl - but it failed with the same error as well
04:43:01 <Arafangion> ashnur: I would prefer the language to also compile to regular binaries, as an option. :)
04:43:35 <aspidites> wow. weren't kidding about elm.
04:44:14 <aspidites> wonder if it has anything to do with the recent cabal 1.20 release
04:44:52 <aspidites> then, i'm not really interested in elm, so am not particularly motivated to investigate
04:45:25 <aspidites> Arafangion: are you sure that trying to install mtl gave the exact same error?
04:45:36 <aspidites> er.. vijaykiran  rather
04:45:39 <aspidites> sorry about that
04:46:14 <vijaykiran> aspidites: yes - https://gist.github.com/vijaykiran/fe6bd0f6083437836a3b
04:46:48 <aspidites> that's a different error ;-)
04:47:10 <aspidites> anyway, i'm poking around to see which version of mtl i hav installed
04:47:41 <vijaykiran> I think I was tricked by ExitFailure 1 under mtl line
04:48:07 <vijaykiran> I'm using sandbox cabal thing
04:48:45 <aspidites> ok. i'm hitting the same error in a sandbox. shouldn't be too hard to track down...hopefully
04:49:02 <aspidites> i know i had diagrams installed before in a sandbox so i'm guessing something changed within the last month or so
04:49:11 <vijaykiran> ah - is this related: http://stackoverflow.com/questions/23510242/cabal-dependency-resolution-fail-for-lens ?
04:50:00 <vijaykiran> says "wait a few days" :(
04:50:06 <ashnur> Arafangion: there is no such thing as regular binaries (for me :) )
04:50:40 <Arafangion> ashnur: I just want the option of going faster. :)
04:52:44 <ashnur> Arafangion: faster? what are you doing, running weather models? :)
04:53:20 <aspidites> vijaykiran: yep. good catch
04:53:36 <yorick> what's the recommended way to make a list of random integers nowadays?
04:53:48 <yorick> replicateM 100000 randomIO is not a good way, it seems :)
04:53:56 <Arafangion> ashnur: Possibly running on the phone.
04:54:16 <vijaykiran> aspidites: thanks! so waiting is in order I guess
04:54:51 <Arafangion> ashnur: (Although haskell would be a bad choice there, but that's one clear place where I'd appreciate the performance).  On the desktop, if I was doing a lot of binary stuff, messing with encryption, compression, and the like, I'd also like the performance.
04:55:49 <mikusp> yorick: did you look at mwc-random package?
04:56:47 <yorick> mikusp: I have not, I just want a random hmatrix vector of a specific size :/
04:58:50 <mikusp> yorick: I don't know in what format hmatrix keeps vectors, but mwc-random has some convenient functions for producing random vectors of given size
04:59:10 <yorick> hmatrix actually has a randomVector function
05:01:04 <aspidites> if you're just playing around, i imagine you could use an older version of diagrams...or much with reverse dependencies until you get a set that doesn't resolve nicely
05:01:16 <aspidites> (vijaykiran)
05:02:10 <aspidites> just when i thought the whole "cabal hell" age was over
05:09:03 <ashnur> pft
05:09:34 <ashnur> i had to git clone someones patched version of temporary so i can install pandoc so i can install elm
05:09:41 <ashnur> still not sure if it will work out ok
05:11:24 <SrPx> > 5
05:11:26 <lambdabot>  5
05:11:35 <SrPx> > import Control.Monad.Omega
05:11:36 <lambdabot>  <hint>:1:1: parse error on input ‘import’
05:11:42 <SrPx> ;(
05:12:21 <SrPx> if anyone is not too busy, could you see what is the right way to do this? http://stackoverflow.com/questions/23515191/how-to-enumerate-a-recursive-datatype-in-haskell/23516414?noredirect=1#23516414
05:12:25 <SrPx> have tried too many things already
05:12:34 <SrPx> monads are confusing
05:24:58 <fizruk> SrPx: still need help?
05:26:22 <SrPx> fizruk: nope someone just solved it! Would never have thought that.... :C
05:27:16 <fizruk> SrPx: ok, my version is enum = pure A <|> B <$> enum <|> C <$> enum <*> enum
05:28:21 <SrPx> fizruk: oh you did it too, thank you (: I'll still learn what those <*> wizardry are all about
05:28:37 <ashnur> OH SHIT. Installed Elm-0.12.1.3
05:28:41 <ashnur> after 2 days
05:28:43 <ashnur> finaly
05:29:22 <SrPx> ashnur: 4 months here and nothing
05:29:36 <ashnur> SrPx: wat?
05:29:44 <SrPx> ashnur: for ghcjs , that is
05:33:12 <ashnur> SrPx: i don't get it
05:33:55 <SrPx> ashnur: 4 months trying to install ghcjs here ...
05:34:06 <ashnur> and you can't? :P
05:34:15 <SrPx> wish I could
05:34:20 <ashnur> what about trying something else?
05:35:35 <SrPx> ah I've tried haste and fay already, those are fine
05:35:40 <ashnur> gardening for example
05:35:52 <SrPx> ): that was mean
05:35:54 <ashnur> :D
05:36:07 <ashnur> i wish i'd become a gardener. i could blame the weather
05:37:40 <ashnur> SrPx: purescript?
05:39:50 * hackagebot ripple 0.3 - Ripple payment system library  http://hackage.haskell.org/package/ripple-0.3 (StephenWeber)
05:41:43 <simon____> ashnur, I suppose computer scientists can always blame cloud computing.
05:42:02 <ashnur> simon____: that must be a pun
05:42:24 <simon____> and a bad one.
05:42:44 <ashnur> there are no "good" puns
05:42:56 <ashnur> well. once I read one in a Terry Pratchett novel
05:43:04 <ashnur> in the Hogfather
05:45:09 <ashnur> simon____: http://pastie.org/private/enggxhtlsj1uugsvsklytq
05:47:21 <t7> groan
05:59:53 * hackagebot dynamic-linker-template 0.1.0.4 - Automatically derive dynamic linking methods from a data type.  http://hackage.haskell.org/package/dynamic-linker-template-0.1.0.4 (SylvainHenry)
06:00:13 <simon____> ashnur, that's a pretty good pun.
06:01:26 <ashnur> simon____: that's the only pun I ever liked :)
06:03:17 <tdammers> oh god... that must be one of the silliest puns I've ever seen
06:09:56 * hackagebot c-dsl 0.3.1 - A higher level DSL on top of language-c  http://hackage.haskell.org/package/c-dsl-0.3.1 (jozefg)
06:10:47 <tdammers> does hackagebot creep anyone else out at times, or is it just me?
06:10:48 <ashnur> tdammers: your standards are messed up :D
06:10:49 <SwashBuckla> ashnur: haha, that's brilliant!
06:11:05 <tdammers> ashnur: granted, I haven't read a lot of pratchett
06:11:07 <ashnur> SwashBuckla: well, Pratchett is brilliant :)
06:11:40 <ashnur> tdammers: it's not about puns though, more about satyre and such
06:12:20 <tdammers> yes, I know
06:12:32 <tdammers> all I said was I find this particular pun pretty lame
06:12:52 <tdammers> the rest of that excerpt is pretty enjoyable actually
06:12:58 <ashnur> :)
06:13:14 <ashnur> http://home.uninet.ee/~ronin/stuhv/Terry%20Pratchett/Discworld%20Novels/Pratchett,%20Terry%20-%20Discworld%2020%20-%20Hogfather.pdf
06:13:26 <merijn> Any pipes-parse experts around? I for the love of me can't figure out how to create nicely composable parsers...
06:13:56 <SwashBuckla> "The number of states in software systems is orders of magnitude larger than the number of states in the nonrepetetive parts of computers. [...] It is a fundamental difference that will not disappear with improved technology" http://dl.acm.org/citation.cfm?id=214961
06:14:56 * hackagebot reified-records 0.2.1 - Reify records to Maps and back again  http://hackage.haskell.org/package/reified-records-0.2.1 (jozefg)
06:14:58 * hackagebot reified-records 0.2.2 - Reify records to Maps and back again  http://hackage.haskell.org/package/reified-records-0.2.2 (jozefg)
06:15:00 * hackagebot generic-church 0.1.0.2 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/generic-church-0.1.0.2 (jozefg)
06:15:05 <SwashBuckla> interesting collection of essays from a automated missile system panel member, who resigned along with handing in these essays
06:15:31 <SwashBuckla> (December 1985)
06:20:18 <SwashBuckla> "Many researchers believe that [logic] can play the role in software engineering that continuous mathematics plays in mechanical and electrical engineering. Unfortunately, this has not yet been verified in practice"
06:20:32 <SwashBuckla> has this been since "verified"?
06:20:48 <yitz> SwashBuckla: paywall :(
06:20:55 <SwashBuckla> yitz: oh, sorry
06:21:13 <SwashBuckla> uno momento
06:22:42 <SwashBuckla> yitz: https://www.dropbox.com/s/is957wf40v1yqt2/p1326-parnas.pdf
06:23:20 <SwashBuckla> (I'm not sure that Parnas' statement is specific enough to be refuted)
06:23:44 <yitz> SwashBuckla: it has now been verified. it's types that play that role. turns out, though, that types are equivalent to (one form of) logic, via curry-howard.
06:23:49 <kylec01> ^
06:24:37 <SwashBuckla> fascinating
06:24:46 <SwashBuckla> I shall read up on Curry-Howard
06:25:24 <SwashBuckla> any recommended introductory papers/resources?
06:26:00 <kylec01> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9A7330B9CB66CDCBA723AEBD8111B5E5?doi=10.1.1.17.7385&rep=rep1&type=pdf
06:26:54 <SwashBuckla> any pages/sections in that you could point me to?
06:26:59 <davd> :t f=f
06:27:00 <lambdabot> parse error on input ‘=’
06:27:05 <davd> :t let f = f
06:27:06 <lambdabot> <no location info>: not an expression: ‘let f = f’
06:27:28 <davd> :t let f=f in f
06:27:29 <lambdabot> t
06:27:35 <SwashBuckla> I suppose you don't know what I know... :P
06:27:35 <kylec01> section 3.1
06:27:36 <kylec01> and 4
06:28:34 <SwashBuckla> thank you kylec01
06:28:48 <kylec01> http://www.thenewsh.com/~newsham/formal/curryhoward/
06:30:31 <kylec01> np swashbuckla
06:32:46 <yitz> SwashBuckla: thanks for the link. interesting essays for their time.
06:49:11 <btcNeverSleeps> For the Emacs gurus: I'm using Emacs with ghc-mod (is ghc-mod only for the REPL?) and structured-haskell-mode.  Does structured-haskell-mode works fine with flymake/hlint?  (I'd like to use both at the same time, but I read something about disabling Flymake)
06:52:36 <mada> ?
06:52:42 <mada> wrong channel
06:55:22 <btcNeverSleeps> mada: is your '?' in the wrong channel or are you saying my questions about Haskell / ghc-mod / SHM / flymake+hlint is in the wrong channel?
06:55:42 <mada> btcNeverSleeps: the first one of course :)
06:56:36 <btcNeverSleeps> mada: : )
07:03:11 <defanor> a similar question: which emacs modes do you guys use (and/or could recommend) for haskell? i have only haskell-mode here, but comparing to agda2-mode, or even some modes for languages without static typing at all, it seems not-that-powerful. it'd be nice to see context/scope, use "holes" and check their types, and so on
07:06:30 <papyrus> hello.
07:06:35 <papyrus> i am new to haskell, and i am sorry for my poor english . :-).
07:06:41 <papyrus> i have a question about functor law, applicative functor law.and monad law.
07:06:46 <papyrus> you define a data , and you instantiate functor ,applicative, moand ,
07:06:56 <papyrus> do you always verify the data for functor law, applicative law, monad law ?
07:07:01 <albeit_> Does anyone from AlphaHeavy frequent this channel?
07:07:04 <papyrus> i think it's a boring.
07:07:12 <papyrus> is there a better way ?
07:08:11 <haasn> http://blog.codinghorror.com/separating-programming-sheep-from-non-programming-goats/ <- They say their test results have shown that novice programmers struggle with assignment and sequence. I wonder if this could be turned into an argument for declarative / pure programming
07:09:13 <fizruk> papyrus: I usually make new monads out of existing ones, so I get instances automatically (with type or GeneralizedNewtypeDeriving)
07:09:49 <papyrus> i don't understand "make new monads out of existing one"
07:10:11 <fizruk> papyrus: e.g. with monad transformers from mtl library
07:10:32 <papyrus> oh...
07:10:37 <Sculptor> hi
07:10:42 <fizruk> papyrus: type GameMonad = StateT GameState IO
07:10:42 <_d0t> Hi guys. I've got a question - does `isSupportedSocketOption' from network even work? I'm asking because it always returns True no matter what option I specify.
07:10:54 <papyrus> is there applicative transformer ?
07:11:02 <papyrus> or functor transformer
07:11:08 <`^_^v> haasn, i dont buy that study. people have tried to reproduce it but couldnt
07:11:21 <bennofs> papyrus: you don't need applicative transformers. The composition of two applicatives / functors is always a applicative / functor too
07:11:24 <fizruk> papyrus: Functors and Applicatives compose naturally
07:11:49 <bennofs> papyrus: i.e. newtype Compose f g a = Compose (f (g a)) is a Applicative / Functor if f and g are Applicative / Functor
07:11:54 <fizruk> papyrus: check out Data.Functor.Compose
07:12:21 <papyrus> oh...very nice.
07:12:24 <haasn> `^_^v: Oh, I'm reading the paper now, there's a footnote on that claim: “Novice declarative programmers' first hurdle appears to be argument substitution. Really the first hurdle is just getting started: ‘orientation’ was the name that Benedict and du Boulay gave it”
07:12:37 <papyrus> thanks a tons. fizruk. bennofs !
07:18:20 <hk3380> non tail-recursive calls are stateful, and tail recursive calls are stateless, right?
07:19:40 <merijn> hk3380: Not using any usual definitions of any of those words
07:20:17 <mr-> haasn: do you have a link to the paper? The one in the article doesn't work for me
07:20:30 <merijn> Anyone know if Renzo Carbonara hangs around here?
07:22:23 <haasn> mr-: http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf is what I used, does that work?
07:23:09 <mr-> It does, thankss
07:25:07 <nh2> hey, is something like this possible?
07:25:08 <nh2> instance forall a . (Generic a, Show a) => Show (IORef a) where
07:25:08 <nh2>   show _ = "IORef " ++ show (from (undefined :: a))
07:26:08 <nh2> basically I want to be able to `show` something of type IORef Int as "IORef (M1 .....)" and so on
07:26:33 <nh2> use the algebraic representation of the data type to write the show instance
07:27:28 <alpounet> nh2: that sounds feasible
07:27:45 <nh2> alpounet: I can't manage to make the above compile though
07:28:06 <alpounet> nh2: what does ghc have to say about that?
07:28:08 <pranz> nh2: try wrapping it in braces
07:28:17 <nh2> I'm getting Could not deduce (Show (Rep a x0)) arising from a use of `show'  from the context (Generic a, Show a)
07:28:25 <pranz> nh2: (forall a... IORef a))
07:28:27 <nh2> pranz: wrapping what exactly in braces?
07:28:29 <nh2> ah
07:28:33 <hk3380> merijn: why not
07:28:44 <nh2> pranz: but I want the a to be in scope for the undefined
07:28:53 <bennofs> nh2: it means that the generic representation also must be showable. You don't include that in your constraint
07:29:12 <nh2> (braces didn't change anything)
07:29:32 <hk3380> merijn: isn't tail-recursive pretty much sending the whole state to the next call, while non tail-recursive makes use of outside values from previous calls (thus stateful) ?
07:29:53 <bennofs> nh2: what if I came along and defined a data Broken and type instance Rep Broken o = Int -> o ?
07:29:59 <merijn> hk3380: No
07:30:03 <hk3380> merijn: why
07:30:10 <hhhhhhhh> hi, `cabal install pandoc` is dying on me with: http://ix.io/c97
07:30:25 <merijn> hk3380: A tail call is one that does not require to do any new computation after the call, how much and which values are passed in is irrelevant
07:30:44 <nh2> bennofs: the thing is I don't really want to enumerate the types I care about (like Int)
07:30:46 <nh2> bennofs: if I add Show (Rep a x) to the constraints, I don't really know how to qualify the x
07:31:01 <merijn> hk3380: "length (x:xs) = 1 + length xs" is not tail recursive because the "1 +" has to happen *after* the recursive call to "length xs"
07:31:30 <bennofs> @hoogle from
07:31:31 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
07:31:31 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
07:31:31 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:31:42 <merijn> hk3380: "length n (x:xs) = length (n+1) xs" is tail recursive because the call to "length is the "last" thing the function does
07:31:50 <hk3380> merijn: isn't the reason for why there is no computation to be done after the call exactyl because it's stateless?
07:31:52 <nh2> alternatively, I would also be OK for the beginning with getting the nominal type name of the a, such that show of an IORef Int just gives me "IORef Int" (and of course for any other type that's not Int)
07:32:14 <bennofs> nh2: as from :: a -> Rep a x, you can choose x freely. Just set x = () ?
07:32:29 <osa1> does cabal --enable-library-profiling pass `-fprof-auto` to GHC?
07:32:34 <bennofs> osa1: no
07:32:42 <osa1> bennofs: ok so I have to use ghc-options for that, right?
07:32:50 <hk3380> merijn: well it's the last thing the function does because it just passed the whole state to the next call
07:32:59 <bennofs> osa1: That's how I do it. Don't know if there's a better way
07:33:02 <merijn> hk3380: But that's irrelevant
07:33:19 <merijn> hk3380: "length (x:xs) = length xs" is also tail recursive
07:33:47 <hk3380> merijn: and stateless
07:34:01 <merijn> hk3380: That is not relevant
07:34:17 <merijn> That's a coincidence of which examples are easy to come up with
07:34:23 <hk3380> merijn: are there stateful tail recursive functions then?
07:34:37 <merijn> Define stateful
07:35:06 <merijn> Actually, I should be working
07:35:09 <hk3380> that changes depending on the state
07:35:12 <supki> hhhhhhhh: --constraint='exceptions < 0.6'
07:35:49 <nh2> osa1: there is an exctra cabal field for profiling options
07:36:03 <merijn> hk3380: I prefer to spend my time more constructive than arguing semantics with someone who isn't willing to specify the semantics they are using
07:36:17 <hhhhhhhh> supki: thanks
07:36:48 <nh2> osa1: https://twitter.com/HaskellTips/status/427281845638533122
07:36:50 <hk3380> merijn: k
07:37:24 <osa1> nh2: great, thanks!
07:37:25 <oma> @help
07:37:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:40:02 <nh2> bennofs: that seems to get me somewhere, but first I have to add some more Show instances for the generic types, I'll report back
07:42:45 <bernalex> I need a haskell game with over 10K lines for my research. anyone? I already have frag & nikki.
07:45:12 <Kron> how does the GHC deal with dead code?
07:45:35 <Kron> normally compilers are conservative with dead code elimination because side effects, but that's impossible in haskell (or maybe it secretly isn't)
07:45:56 <Kron> is dead code automatically exterminated from the resulting compiled program? unused functions, unreferenced variables, etc.
07:46:53 <merijn> Kron: I would assume so, yes.
07:48:06 <fizruk> bernalex: do you want someone to write 10K lines for/with you? :)
07:48:36 <bernalex> fizruk: yes! if you could go ahead and have that done by Thursday, that'd be great.
07:49:24 <fizruk> bernalex: which Thursday? would a year from now do?
07:49:49 <bernalex> fizruk: yeah see that's not gonna work. so if you could go ahead and do it by to-morrow... that'd be greaaat.
07:50:52 <bernalex> fizruk: also if you could go ahead and come in on Saturday... that'd be greaaaat.
07:51:11 <bernalex> fizruk: also, while I have you here, I'm gonna go ahead and ask you to come in on Sunday too. thaaanks.
07:51:22 <chrisseaton> Hi. I'm using the State monad to pass around a record. It's got several fields, and I seem to be repeating myself in functions to read and update (usually increment) the field. Am I blind to some abstraction here? I'm not sure how to abstract as the record name changes. https://gist.github.com/anonymous/35fba84056c33ed2bc2d
07:52:58 <fizruk> bernalex: what? where? also I might have some simple tic-tac-toe-like gists nK lines in total. interested? :)
07:53:24 <bernalex> fizruk: for n>10, I am interested.
07:53:31 <tdammers> chrisseaton: this might be overkill, but lenses solve that problem (among other things)
07:53:38 <nh2> bennofs: that worked; I had to do introduce some `showIO :: a -> IO String` though to peek into the IORef, which makes sense. Now I have another question:
07:53:40 <nh2> What if I don't want to peek into the structure of what's actually inside the IORef, but have `show (... :: IORef Sometype)` return me "IORef Sometype", using the string name of the type?
07:53:57 <tdammers> e.g. data Foo = Foo { _fooCounter :: Integer }
07:54:02 <tdammers> then you derive your lenses
07:54:02 <nh2> I haven't quite figured out if generics (or otherwise) give me access to that, or if I have to use TH
07:54:12 <tdammers> and then inside a MonadState Foo, you can do
07:54:17 <tdammers> fooCounter += 2
07:54:18 <tdammers> or
07:54:23 <tdammers> set fooCounter 15
07:54:32 <tdammers> or the other way around, whatever
07:54:44 <tdammers> or: counter <- use fooCounter
07:54:48 <tdammers> etc. etc.
07:55:09 * hackagebot acme-pointful-numbers 0.1.2.4 - Make more than one point in numeric literals  http://hackage.haskell.org/package/acme-pointful-numbers-0.1.2.4 (AntonNikishaev)
07:55:30 <alpounet> nh2: show . typeOf ?
07:55:32 <chrisseaton> tdammers: what's the canonical lens package called?
07:55:46 <srhb> lens
07:55:48 <tdammers> chrisseaton: lens
07:55:55 <fizruk> bernalex: nah, it’s about 5K
07:55:56 <nh2> chrisseaton: I do it like you do it without lenses, but use `modify` to do get and put in one line
07:56:26 <bernalex> fizruk: get to work then! geez. what am I paying you for.
07:56:31 <nh2> alpounet: ah, typeable, right, that makes sense that I need that
07:56:40 <bennofs> nh2: yeah, this is probably easier to do with typeable instead of GHC.Generics
07:56:53 <alpounet> nh2: it returns a TypeRep which has a Show instance, so maybe that would do the trick for you
07:57:12 <chrisseaton> Thanks everyone
07:59:26 <kill10000> http://lpaste.net/103744
07:59:49 <killy9999> why does GHC not complain that mycompare function is not defined?
08:00:06 <killy9999> it is listed in MINIMAL pragma
08:00:16 <srhb> killy9999: Because it's defined in terms of <=>
08:00:35 <killy9999> what is then the purpose of having MINIMAL?
08:00:43 <tdammers> killy9999: documentation?
08:00:50 <killy9999> if I don;t define something and not declare MINIMAL ghc will fail anyway
08:01:06 <killy9999> just documentation and nothing else?
08:01:47 <bennofs> killy9999: ghc complains for me (using GHC 7.8)
08:01:56 <bennofs> killy9999: with a warning (enabled by default)
08:02:02 <nh2> alpounet, bennofs: ha, this works very nicely! Now I can use this for great evil in my hot code reloading to notice when my persistent state changes its type! :D
08:02:05 <alpounet> nh2: i've just tried, 'instance Typeable a => Show (IORef a) where show = show . typeOf' does what you want
08:02:17 <killy9999> bennofs: hm... interesting
08:02:26 <bennofs> nh2: then you could just compare the TypeRep directly, no?
08:02:39 <alpounet> yeah, TypeReq has an Eq instance
08:02:47 <alpounet> TypeRep *
08:03:13 <killy9999> bennofs: ah, I see the problem. I'm using these definitions inside a TH splice
08:03:32 <bennofs> killy9999: and TypeRep has no Lift?
08:03:35 <nh2> bennofs: you mean instead of its show? For only 1 IORef yes, but my State is some nested record that I unfold using the generics sorcery above
08:03:45 <bennofs> killy9999: oops, sry, got confused
08:07:26 <fizruk> bernalex: seriously, I can’t get the work done by tomorrow. you have to shift the deadline!
08:07:37 <btcNeverSleeps> defanor: was afk... ghc-mod and structured-haskell-mode here and both seems good.  But seeing a Youtube video from "Jekor" using flymake/hlint really made me want to use that too.
08:08:05 <bernalex> fizruk: I'm gonna go ahead and ask you to come in tomorrow and deliver your work, or not come in again ever. ok? yeah thaaaanks.
08:08:24 <fizruk> bernalex: hey, what’s about Saturday?
08:08:38 <bernalex> fizruk: you can still come in Saturday and Sunday. that'd be greaaat.
08:08:45 <btcNeverSleeps> defanor: this video: https://www.youtube.com/watch?v=aj7WF_Zm9zY   worth a watch if you're into Emacs + minor modes for Haskell ^ ^
08:09:51 <fizruk> bernalex: I’m free of dayjob since Friday, so I guess I can make it by Sunday evening…
08:10:06 <bernalex> fizruk: that'd be greaaat
08:10:27 <bernalex> ooh. lambdahack is >10K lines. neat. not a game, but a game engine should be an OK compromise.
08:10:34 <shapr> bernalex: Wait, are you a manager at Raytheon?
08:10:51 <fizruk> bernalex: you should really fix your ‘a’ key
08:11:27 <bernalex> shapr: no I'm a manager at Initrode
08:11:38 <btcNeverSleeps> defanor: as I understand it structured-haskell-mode brings something that'd be like semi-structural editing to Haskell (not unlike, say paredit or smartparens for Lisps, but looks more powerful than paredit).  But flymake+hlint can show errors and warnings directly underlined (or in red) in a .hs buffer. I don't know if you can use *both* structured-haskell-mode + flymake/hlint, which is why I asked the question.
08:12:16 <defanor> btcNeverSleeps: thanks, will check it now
08:12:36 <btcNeverSleeps> defanor: besides that "ace-jump-mode" (but that is not specific to Haskell editing). Nothing beats ace-jump-mode to move the cursor around. This has to be the single biggest timesaver ever invented to move the cursor (I think vim guys invented it, under the name "EasyMotion").
08:12:42 <fizruk> bernalex: why 10K?
08:13:17 <bernalex> fizruk: I wanna look at bigger games to show that my small samples are generalisable to bigger ones, and 10K is the smallest I should go.
08:15:40 <btcNeverSleeps> defanor: btw with ghc-mod you can C-c C-t / ghc-show-type and get the type of what's under the cursor
08:17:36 <manuel__> btcNeverSleeps: thx for that flymake video
08:17:56 <defanor> btcNeverSleeps: sounds neat, going to take some time to try it all :)
08:22:48 <CindyLinz> Hi~
08:23:17 <CindyLinz> Is there a better looking (more generic) expr for  'maybe mzero return' ?
08:24:10 <CindyLinz> Or an already existed function for it?
08:26:38 <fizruk> :t F.msum
08:26:39 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
08:26:59 <fizruk> :t F.msum :: MonadPlus m => Maybe a -> m a
08:27:00 <lambdabot>     Could not deduce (a1 ~ m1 a1)
08:27:00 <lambdabot>     from the context (MonadPlus m1)
08:27:00 <lambdabot>       bound by an expression type signature:
08:27:46 <fizruk> :t msum . fmap return
08:27:47 <lambdabot> MonadPlus m => [a] -> m a
08:27:48 <CindyLinz> Ah.. My underlying monad is (MaybeT IO a)
08:28:09 <fizruk> :t F.msum . fmap return
08:28:10 <lambdabot> (Foldable t, MonadPlus m, Functor t) => t a -> m a
08:28:29 <CindyLinz> I want to execute a (Maybe a) in a (MaybeT IO a).. ^^|
08:29:59 <fizruk> :t maybeT
08:30:00 <lambdabot>     Not in scope: ‘maybeT’
08:30:00 <lambdabot>     Perhaps you meant ‘maybe’ (imported from Data.Maybe)
08:30:07 <fizruk> :t Control.Monad.Maybe.maybeT
08:30:08 <lambdabot> Not in scope: ‘Control.Monad.Maybe.maybeT’
08:30:12 <fizruk> CindyLinz: http://hackage.haskell.org/package/MaybeT-transformers-0.2/docs/Control-Monad-Maybe.html#v:maybeT
08:30:13 * hackagebot compdata-param 0.8.0.1 - Parametric Compositional Data Types  http://hackage.haskell.org/package/compdata-param-0.8.0.1 (PatrickBahr)
08:30:15 * hackagebot compdata 0.8.0.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8.0.1 (PatrickBahr)
08:30:27 <CindyLinz> fizruk: !
08:30:34 <CindyLinz> fizruk: Thank you....
08:30:35 <fizruk> CindyLinz: oh sorry, i thought that’s mtl, but it’s not
08:31:39 <fizruk> :t MaybeT . return
08:31:40 <lambdabot> Not in scope: data constructor ‘MaybeT’
08:31:47 <fizruk> :(
08:32:01 <shapr> @msg hello there
08:32:06 <sigrlami> Hi, everyone. Quick question, what is simplest way to convert string of utf8 char codes to actual chars? smt like this "\1080" to "и"
08:32:07 <shapr> psh
08:32:12 <shapr> @echo hello
08:32:12 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "shapr!~shapr@84.200.228.78", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo hello"]} target:#haskell rest:"hello"
08:32:15 <shapr> ah, spiffy
08:32:33 <CindyLinz> I think I'll use MaybeT . return ^^
08:32:56 <fizruk> CindyLinz: just make your own wrapper for that, yeah
08:35:13 * hackagebot postie 0.5.0.0 - SMTP server library to receive emails from within Haskell programs.  http://hackage.haskell.org/package/postie-0.5.0.0 (alexbiehl)
08:36:18 <michaelt> sigrlami: maybe there are multiple interpretations of the question? The two string literals are the same, as Haskell Strings, or am I wrong
08:37:16 <michaelt> sigrlami: if e.g. you want to see the characters, you can do something like putStrLn "\1080"
08:38:48 <michaelt> > "и" ==  "\1080"
08:38:49 <lambdabot>  True
08:39:27 <michaelt> > text "\1080\1081\1082"
08:39:29 <lambdabot>  ийк
08:40:15 <carter> :t text
08:40:16 <lambdabot> String -> Doc
08:41:48 <djcoin> Is there some good doc about boxed/unboxed thing, what it is, what performance implication it may have, i'm wondering why we don't always work with unboxed datastructure. Thanks for any input!
08:41:59 <carter> djcoin: depends
08:42:04 <carter> djcoin: whats your use case
08:42:22 <carter> also certain data structures can't be unboxed without some overhead
08:42:39 <carter> how would I unboxed a Vector of Either (Maybe String) INt
08:43:01 <sigrlami> michaelt: yes, that's it. I was using 'show' before it, so I don't get it. Thank you.
08:43:23 <carter> @src Doc
08:43:23 <lambdabot> Source not found. Do you think like you type?
08:43:38 <michaelt> Its Text.PrettyPrint , carter
08:43:48 <michaelt> Or some module like that
08:43:59 <carter> @hoogle doc
08:43:59 <lambdabot> package doc-review
08:44:00 <lambdabot> package doccheck
08:44:00 <lambdabot> package docidx
08:44:00 <djcoin> carter: I have no special use case, I just would like to get an insight of boxed vs unboxed type
08:44:11 <carter> djcoin: not everything can be unboxed
08:44:18 <carter> djcoin: look at my example
08:44:32 <carter> how would you unbox it it? it gets pretty subtle1
08:44:50 <carter> theres ways, but you wind up doing the work ghc does for free
08:44:56 <carter> there ARE use cases for unboxed types
08:45:05 <carter> a) you can show it makes code measurably faster
08:45:18 <carter> b) it measurably reduces space usage in a way that matters for your application
08:45:23 <carter> ummm... i think thats it :)
08:45:32 <skyh1gh> Hi!
08:45:41 <skyh1gh> I'm have a hard time with printing from Haskell to stdout
08:45:47 <awestroke> c) you can no longer place the values in other types
08:45:52 <carter> yup
08:45:57 <carter> well said awestroke
08:45:58 <skyh1gh> let's say I have something like "main = do let x = [1,2]"
08:46:10 <skyh1gh> how do I output this to stdout line by line?
08:46:11 <carter> print $ show [1,2]
08:46:15 <carter> > print $ show [1,2]
08:46:16 <lambdabot>  <IO ()>
08:46:23 <carter> > putStrLn $ show [1,2]
08:46:25 <lambdabot>  <IO ()>
08:46:25 <skyh1gh> I meant, each element on a separate line
08:46:38 <Jaak> mapM_ print [1,2]
08:46:39 <carter> mapM_ putStrLn [list]
08:46:43 <michaelt> @type mapM_ print [1,2,3}
08:46:43 <lambdabot> parse error on input ‘}’
08:46:51 <michaelt> bah
08:47:09 <michaelt> @type mapM_ print [1,2,3]
08:47:10 <lambdabot> IO ()
08:47:18 <michaelt> skyh1gh: there's main for you
08:47:31 <carter> main has to have type  IO ()
08:48:01 <michaelt> @type forM_ [1..10] print
08:48:02 <lambdabot> IO ()
08:48:48 <michaelt> skyh1gh: forM_ is in Control.Monad, not the Prelude. It's kind of nice
08:49:12 <n-dolio> It doesn't have to be ()
08:49:37 <awestroke> hmm.. I'm trying to think of a type... you can give something like "map (+2) [a, b, c] :: AST" to lambdabot and it gives back "[a+2,b+2,c+2]"
08:49:42 <skyh1gh> Okay, thanks for the help!
08:50:02 <carter> > map (+2) [a, b, c]
08:50:04 <lambdabot>  [a + 2,b + 2,c + 2]
08:50:09 <carter> :t map (+2) [a, b, c]
08:50:10 <lambdabot> [Expr]
08:50:10 <awestroke> :t a
08:50:11 <lambdabot> Expr
08:50:18 <awestroke> aha!
08:50:27 <michaelt> Does the compiler just add return () so to speak when we give it main :: IO Int
08:50:37 <skyh1gh> I'm still wondering why something like map (\x -> print  x) [list] does not compile
08:50:52 <michaelt> skyh1gh: it's a list of actions, not an action
08:51:00 <awestroke> skyh1gh: the type if [IO ()]
08:51:04 <alpounet> michaelt: i'd be a bit surprised if main :: IO Int works
08:51:05 <awestroke> is*
08:51:10 <srhb> alpounet: It does.
08:51:11 <michaelt> skyh1gh: you can make it an action with sequence_
08:51:12 <l0cust> skyh1gh: type safety
08:51:14 <alpounet> oh really?
08:51:15 <srhb> alpounet: Why does that surprise you?
08:51:20 <michaelt> alpounet: yeah as n-dolio says it does
08:51:27 <l0cust> skyh1gh: use mapM_ print [list]
08:51:36 <l0cust> :t mapM_
08:51:37 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:51:42 <srhb> skyh1gh: Or sequence what you had.
08:51:53 <awestroke> :t sequence . map
08:51:54 <lambdabot>     Couldn't match type ‘[a1] -> [b]’ with ‘[m a]’
08:51:54 <lambdabot>     Expected type: (a1 -> b) -> [m a]
08:51:54 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
08:51:55 <l0cust> by contrast, :t map
08:52:11 <l0cust> :t map
08:52:12 <lambdabot> (a -> b) -> [a] -> [b]
08:52:20 <monochrom> > map (\x -> print x) [1,2,3]
08:52:22 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
08:52:26 <djcoin> carter: sorry I was away, thanks for your answer
08:52:27 <monochrom> compiles for me
08:52:34 <skyh1gh> Thanks!
08:52:35 <carter> djcoin: do you understand the example?
08:53:12 <djcoin> carter: I see the limitation
08:53:13 <n-dolio> If we were being really strict, IO () wouldn't be a good type for main anyway.
08:53:18 <awestroke> @src Expr
08:53:19 <lambdabot> Source not found. It can only be attributed to human error.
08:53:20 <alpounet> srhb: actually yeah, it's not that surprising
08:53:47 <l0cust> n-dolio: why do you say that?
08:53:50 <nh2> main :: IO Int didn't do what I thought it will do
08:53:56 <michaelt> what would it be, IO Void?
08:54:13 <n-dolio> Because a better type is IO a, where a is required to be fully polymorphic.
08:54:29 <n-dolio> Which suggests you're calling exitWith to set your exit code.
08:54:37 <awestroke> > map (+2) [1,2,3] :: [Expr] -- what package provides Expr?
08:54:38 <lambdabot>  [1 + 2,2 + 2,3 + 2]
08:54:51 <michaelt> simple-reflect I think, awestroke
08:55:04 <nh2> what, main :: IO Int even does different things with ghc and runhaskell
08:55:08 <n-dolio> And since those exit calls exist to exit the program, IO () is an overly lax model of an IO computation.
08:55:11 <awestroke> michaelt: thanks!
08:55:22 <monochrom> yes, runghc does a bit more. I think it is a mistake.
08:55:28 <n-dolio> It still has one free variable.
08:55:34 <l0cust> n-dolio: hm. that's an interesting perspective
08:55:50 <nh2> monochrom: that really seems wrong to me, they should have the same output
08:55:58 <monochrom> I agree.
08:56:03 <vanila> is there a set of benchmarks for ReadP parsing?
08:56:07 <nh2> I'll file it
08:58:25 <n-dolio> Of course, there's nothing to prevent you from putting 'return undefined' at the end of your program instead, which would give you the same type, but not the guarantee of exiting 'properly'.
08:59:43 <n-dolio> So Haskell isn't really equipped for enforcing that level of discipline.
09:02:22 <danilo2> Hello dear haskellers! :) Is there any way in Template Haskell to check if a particular instance was defined and is in scope?
09:03:21 <pxqr> :t reifyInstances
09:03:22 <lambdabot> Not in scope: ‘reifyInstances’
09:03:36 <bennofs> danilo2: http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#v:reifyInstances
09:06:41 <danilo2> bennofs: Oh great! I did not notice it. Thank you so much!
09:11:28 <fragamus> Could not find module ‘Data.Hashable’
09:11:28 <fragamus>     Perhaps you haven't installed the "dyn" libraries for package ‘hashable-1.2.1.0’?
09:13:30 <dwcook> fragamus, did you recently update cabal?
09:13:39 <fragamus> yeah
09:14:03 <dwcook> I'm not certain, but I think you might need to rebuild that package with current cabal
09:14:13 <bennofs> fragamus: is that with GHC 7.8?
09:14:18 <fragamus> yes
09:14:39 <fragamus> I just installed 7.8.2
09:14:53 <fragamus> I installed the platform and then 7.8.2
09:15:04 <shapr> Anyone using scotty + persistent + postgresql? Is there any sort of tutorial repo on github?
09:15:38 <bennofs> fragamus: do you use default cabal config or did you change the defaults?
09:15:49 <fragamus> im doing this: cabal install cabal-install
09:15:57 <fragamus> I didn't do that yet
09:16:00 <fragamus> : )
09:16:14 <monochrom> the platform is with 7.6.3, no? 7.8.2 does not even care what libs you had for 7.6.3, no?
09:16:21 <bennofs> fragamus: I mean, do you have anything special in your ~/.cabal/config?
09:16:26 <fragamus> no
09:18:15 <vanila> I want to benchmark ReadP, I suppose I'll look for packages that use it and then make large examples for each... :| i think this is too hard
09:22:35 <Rip> Does haskell language only support higher end software or bots and tools as well?
09:22:48 <visi0n> Any recommended reading on handling IO Errors? Sounds like EitherT is what I want but still working on figuring it out. Exisiting code with examples would be great. Thanks!
09:23:04 <joelteon> Rip: haskell is turing-complete, and has facilities for binding to C libraries
09:23:08 <joelteon> it can do anything that a computer ca nod
09:23:10 <joelteon> can do.
09:23:57 <Rip> @joelteon ty I'm looking at your site right now
09:23:57 <lambdabot> Unknown command, try @list
09:24:32 <davidthomas> joelteon: Always bugs me just a bit when turing completeness is used that way :-P
09:25:14 <prophile> I write all my scripts in rule 110
09:25:32 <dwcook> davidthomas, what's wrong with it?
09:25:52 <davidthomas> dwcook: well, turing complete means that it can perform any *computation* that can be performed
09:26:05 <dwcook> Right.
09:26:14 <davidthomas> but that doesn't mean that it can *do* anything that computers can *do* because it says nothing about encoding
09:26:26 <dwcook> Ah, I understand.
09:26:40 <dwcook> But "anything computers can do" is the ill defined part then, no?
09:26:43 <Rip> Didn't mean to stir up the pot
09:26:50 <davidthomas> heh
09:26:50 <Rip> My bad
09:26:58 <dwcook> Rip, it's a civilized conversation, there's nothing to be sorry about.
09:27:08 <davidthomas> Rip: No worries, just a teaching moment :-P
09:28:19 <fragamus> dang this takes a while: cabal install cabal-install
09:28:20 <hoverbear> I'm looking to make a simple API (with Auth) for querying a MongoDB, the application would respond to RESTful HTTPS calls. I'm looking at yesod and snap, would Haskell be a good fit for this task?
09:28:26 <davidthomas> dwcook: Well, the question is how the system you're talking about (in this case, Haskell) is actually translated into actions beyond the comparatively narrow formal boudnaries of the system
09:28:40 <monochrom> visi0n: for IO Errors, exceptions are just fine
09:28:59 <Rip> First time coming into the IRC in years
09:29:06 <dwcook> davidthomas, is it analogous to how brainfuck is Turing complete but most interpreters for it just do textual IO to/from a user's terminal?
09:29:07 <fizruk> bernalex: seen roguestar? seems like >10K total code
09:29:56 <davidthomas> dwcook: Right.  Of course, you could hook up additional systems *to* that textual IO...
09:30:04 <bernalex> fizruk: ooh. does it use lambdahack?
09:30:09 <bernalex> fizruk: thanks for the tip!
09:30:10 <levi> hoverbear: What do you mean by "a good fit"?
09:30:16 <davidthomas> but at some point it's not brainfuck "doing" it
09:30:49 <fizruk> bernalex: there’s roguestar-engine (~6K loc), so I guess not (haven’t seen it myself actually)
09:30:51 <davidthomas> dwcook: rule 110 is an even better example
09:30:51 <hoverbear> levi: I don't know Haskell, never had a good project to learn it for. This seems like something Haskell might be capable of doing in a nice way.
09:30:57 <michaelt> visi0n: maybe http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html I don't know of anything too systematic
09:30:59 <davidthomas> dwcook: or Conway's life
09:31:30 <levi> hoverbear: Haskell is great for doing web backend work in general, but depending on your expectations you may or may not end up happy with the current libraries/frameworks.
09:32:06 <davidthomas> dwcook: now, the "and there's a C FFI" went a long way toward fleshing out the "it can internally take arbitrary actions"
09:32:11 <hoverbear> levi: All I ~really~ need to do is fire off JSON arrays to a frontend when requested. Ideally I'd also be able to statically serve a site (Already made)
09:32:48 <davidthomas> dwcook: but there's still a step or two missing I think :-P  which isn't a big problem and doesn't bother me a lot, just a bit :-P
09:33:04 <davidthomas> dwcook: obviously, as I said, the *conclusion* was basically correct
09:33:34 <dwcook> davidthomas, even C might not be able to do some things, like if the compiler writers mapped nothing onto a certain CPU instruction
09:34:06 <levi> hoverbear: Both Yesod and Snap are actively developed and have helpful (though small) communities. There's also a Sinatra-style library called Scotty that some people like for simple tasks. Haskell has a nice JSON library called Aeson.
09:34:06 <davidthomas> dwcook: well, that particular example is potentially defeated by inline assembly :-P
09:34:14 <davidthomas> dwcook: but yes
09:34:20 <dwcook> davidthomas, ah, I forgot that existed. Then, it seems C is reasonably complete.
09:34:26 <napping> the FFI is anyways about binding to the system ABI rather than C exactly
09:34:37 <voldyman> How good are Haskell and gtk+-3 bindings?
09:35:24 <fragamus> does it "reinstall" every package when I do this: cabal install cabal-install
09:35:30 <tromp_> turing completeness is being able to compute any partial recursive function from binary strings to binary strings
09:35:34 <dwcook> fragamus, no.
09:35:42 <fragamus> sure seems like it
09:35:48 <dwcook> It just upgrades whatever is necessary for the new version of cabal.
09:35:50 <levi> There's C, and then there's standard and portable C. You can accomplish anything with a particular C implementation, but it might require some grody hacks.
09:35:51 <tromp_> so it requires some convention for beinary input and output
09:36:17 <hoverbear> levi: Thanks for the awesome info. :)
09:36:56 <davidthomas> dwcook: Certainly, with arbitrary amounts of inline assembly, C can encode any sequence of assembly instructions :-P
09:37:12 <napping> voldyman: I think most things are covered, but last I checked there were some missing signals
09:37:43 <voldyman> napping: oh they can still be connected using .notify
09:37:53 <levi> voldyman: Haskell is awesome. It has gtk bindings that are reasonably up-to-date, last I checked, but they're fairly low-level bindings.
09:38:37 <napping> voldyman: Maybe, I didn't see any way to listen to the "cursor-position" property, maybe there's a stronger notify now
09:39:15 <voldyman> Thanks guys, I'll try them
09:39:18 <napping> I was trying to override some basic behavior of the text window, it's probably better for normal uses
09:39:22 <napping> threadscope uses it, for example
09:40:08 <vanila> http://bighow.net/4815325-Correct_ReadP_usage_in_Haskell.html
09:40:10 <vanila> :|
09:40:26 <vanila> thism must be fake
09:41:47 <napping> vanila: what's the problem?
09:42:15 <davidthomas> levi: certainly the case
09:42:24 <vanila> I want a guide to use readp
09:42:37 <davidthomas> levi: particular implementation for a particular target
09:44:21 <fragamus> Perhaps you haven't installed the "dyn" libraries for package ‘hashable-1.2.1.0’?
09:44:32 <fragamus> still getting this error
09:45:24 <napping> Text.ParserCombinators.ReadP is okay
09:45:45 <napping> vanila: what sorts of things do you want a guide about? I think the haddocks are okay.
09:46:02 <vanila> okay
09:46:40 <napping> It's a pretty simple library. That link was just someone not realizing they'd written a parser that produced an exponential number of possible results
09:47:15 <napping> Just test your parser directly with readP_to_S and you'll see that kind of problem right away
09:53:37 <fragamus> OK WTF: I j*just* reinstalled cabal and I get this:  Note: there is a new version of cabal-install available.
09:53:38 <fragamus> To upgrade, run: cabal install cabal-install
09:54:06 <napping> Are you running the new binary? Maybe a path thing?
09:54:08 <geekosaur> fragamus, check $PATH
09:54:28 <geekosaur> `type cabal` the new one is probably ~/.cabal/bin/cabal
09:57:55 <fragamus> my Path is definitely hosed
09:58:14 <fragamus> I have two versions of cabal and the new one is not the one that comes up
09:58:25 <fragamus> i hate PATH crap
09:58:47 <BeardedCoder> I've gotten into a habbit of always checking that my freshly installed cabal is actually what's in path
09:59:22 <joehillen> run: which cabal
09:59:45 <zerokarmaleft> http://lpaste.net/103747 <= what does cabal's 'inappropriate type' error message mean here?
10:00:30 <fragamus> it says  /Users/fragamus/Library/Haskell/bin/cabal
10:00:38 <adas1> how is this valid ...  "fmap Just even"?
10:00:52 <bennofs> adas1: there is a functor instance for ((->) r)
10:01:09 <klrr_> > fmap Just even
10:01:10 <lambdabot>  <Integer -> Maybe Bool>
10:01:29 <klrr_> adas1: a function is a functor
10:01:32 <bennofs> adas1: even :: Num a => a -> Bool   --> even :: Num a => ((->) a Bool)
10:01:44 <michaelt> adas1: on that reading, fmap = (.)
10:01:52 <fragamus> but my new one is in /Users/michaelgough/Library/Haskell/ghc-7.8.2/lib/cabal-install-1.20.0.1/bin/cabal
10:02:00 <fragamus> blah
10:02:19 <adas1> there is a type ((-> a Bool))?
10:02:36 <adas1> so there is a type class called function?
10:02:44 <bennofs> adas1: a -> Bool is the same as ((->) a Bool)
10:02:58 <bennofs> adas1: just like 3 + 4 is the same as (+) 3 4 in haskell
10:03:23 <adas1> i didn't think haskel could get nay deeper. just did
10:03:59 <adas1> actually no. its just normal. all along i didn't see it that way
10:04:22 <bitemyapp> adas1: do you *want* more depth?
10:04:35 <adas1> sure
10:04:49 <bitemyapp> adas1: comfortable with recursion schemes yet?
10:05:00 <ReinH> heh
10:05:06 <adas1> recursion yes. whats 'recursion schemes'?
10:05:56 <bitemyapp> adas1: http://fho.f12n.de/posts/2014-05-07-dont-fear-the-cat.html http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf http://en.wikipedia.org/wiki/Catamorphism
10:06:38 <xeno_> so, I'm a n00b... anyone wanna tell me what the right breakage/intendation for this is? : let for init test update block = let f x = if (test x) then (block x):(f (update x)) else [] in f init
10:07:04 <zerokarmaleft> and somewhere Liam Neeson bellows, "Unleash the zygoHistoPrepo!"
10:07:07 <michaelt> hm, xeno_ maybe put it up on lpaste?
10:07:25 <michaelt> xeno_: lpaste.net, I mean
10:07:49 <bitemyapp> adas1: let me know when you've conquered that.
10:07:56 <xeno_> there, now the one line is there... dunno if that helps: http://lpaste.net/103748
10:08:37 <spott> Installing executable(s) in /Users/spott/.cabal/bin
10:08:40 <spott> ok, this is really annoying: when I do a "which cabal", I get
10:08:45 <spott> sorry, reverse those
10:09:10 <spott> but! which cabal gives: /usr/local/bin/cabal
10:09:36 <spott> and $PATH is Users/spott/.cabal/bin:$PATH
10:09:46 <spott> also, cabal doesn't show up in .cabal/bin
10:09:57 <spott> though it says that it does
10:10:26 <spott> screw it, I'm reinstalling
10:10:58 <michaelt> xeno_: I think you have a lot of scope for bracketing.  Here's a familiar way http://lpaste.net/103748
10:11:05 <jfischoff> spott: /Users not Users
10:11:35 <michaelt> xeno_: note that all parentheses can be removed, as hlint is saying
10:11:47 <xeno_> yeah
10:11:53 <Mathnerd314> how do I make cabal 1.20 tell ghc 7.8 to build with multiple cores?
10:12:01 <spott> ah yes... I had it as "~/.cabal/bin:$PATH" before that
10:12:02 <athan> Hey guys, I got a quesion. Is there a "Listlike" typeclass? I know that foldable creates a list, but I really don't want the wasted cycles for using list's head, pop, locate, insert, etc.
10:12:25 <ReinH> athan: what do you want this typeclass to contain?
10:12:40 <michaelt> xeno_: oh, the brackets around update x are needed I guess
10:12:52 <bjorkintosh> athan, this is the future. spawn more cores!
10:13:47 <athan> ReinH: Hmm... how about the simple head, tail, last, concat, etc?
10:13:54 <bitemyapp> athan: Data.Sequence? Traversable?
10:13:58 <athan> I'm trying to implement an ordered, unique stack, and make it list-like
10:14:26 <ReinH> athan: no, there isn't such a typeclass. Maybe in classy prelude or something.
10:14:32 <athan> bitemyapp: I've neglected traversable :/ I'll have to check it out. Thank you.
10:14:44 <athan> ReinH: I'll check it out. Thanks!
10:14:48 <jfischoff> ReinH: there are many typeclasses like that on Hackage
10:14:54 <binroot> soooooo a recent update of `transformers` package is broken on hackage, causing most libraries to fail installing. wtf.
10:14:58 <jfischoff> whether you should use them is another questino
10:15:04 <athan> bjorkintosh: (doesn't know if he's joking or not...) :P
10:15:31 <jfischoff> athan: I would recommend you make an interface for a ordered queue
10:15:52 <dmj`> athan: http://hackage.haskell.org/package/ListLike-4.0.2/docs/Data-ListLike.html
10:15:58 <athan> jfischoff: I really don't want FIFO behaviour, though, I really need FILO
10:16:10 <ReinH> dmj`: oh there you go
10:16:11 <bjorkintosh> athan, a stack?
10:16:12 <athan> dmj` LIKE A BOSS, thank you :)
10:16:21 <bitemyapp> athan: but if you just want a nicer list, Data.Sequence is probably your bag.
10:16:32 <jfischoff> athan: that is not a queue that is a stack
10:16:38 <athan> bjorkintosh: Like a peano container that demands ordering and eq from it's elements
10:17:17 <jfischoff> what is a peano containter?
10:17:37 <athan> jfischoff: I tried searching hackage for a stack library to no avail :/
10:17:51 <bitemyapp> athan: probably because you can use [] like a stack.
10:17:52 <athan> Peano numbers are just natural numbers, much like a list, too
10:17:57 <athan> they're all the same idea really
10:18:08 <jfischoff> I know
10:18:14 <athan> like a Free monad without an element
10:18:28 <bitemyapp> FILO semantics can be accommodated without resorting to O(n) operations with [] natively. It's just cons and head.
10:18:34 <athan> bitemyapp: I really want to make this whole thing in IDRIS really
10:18:46 <athan> but noobness has my soul at the moment
10:18:47 <bitemyapp> uhm, cool? I'm just saying
10:18:55 <bitemyapp> athan: you're not communicating your needs very effectively.
10:19:06 <bitemyapp> athan: why isn't [] kosher for a FILO data structure?
10:19:06 <bjorkintosh> athan, why idris?
10:19:12 <bitemyapp> bjorkintosh: nifty type system.
10:19:37 <bitemyapp> also Idris is just kinda fun to kick around for silly problems.
10:19:38 <bjorkintosh> really?
10:19:46 <athan> bitemyapp: I want to preserve ordering and uniqueness, as well
10:19:48 <bitemyapp> bjorkintosh: yes? Idris was practically designed to woo Haskellers.
10:19:50 <bjorkintosh> it still uses monads.
10:19:56 <bitemyapp> uhm.
10:20:03 <bjorkintosh> (which is archaic, compared to uniqueness types) :D
10:20:05 <athan> sorry bitemyapp, it's generally hard for me to communicate :P
10:20:09 <bjorkintosh> yes. i like Clean. can you tell?
10:20:16 <bitemyapp> athan: it's okay, I'm just explaining where we're coming form.
10:20:24 <bitemyapp> bjorkintosh: you either misunderstood monads or uniqueness types.
10:20:29 <bitemyapp> bjorkintosh: one doesn't subsume or replace the other.
10:20:32 <athan> hmm...
10:20:46 <bjorkintosh> misunderstood monads. likely.
10:20:50 <bitemyapp> bjorkintosh: this is where I say the word "orthogonal"
10:21:12 <bjorkintosh> this is where i say the word 'huh'?
10:21:20 <athan> bitemyapp: I actually only need a stack that preserves ordering and uniqueness of it's elements, and only allows for `pop` and `push` actions. I think all other list operations can be derived from those
10:21:40 <bitemyapp> athan: okay so for one thing, what does ordering mean here?
10:21:48 <bitemyapp> athan: first you told me FILO which is an operational ordering
10:21:59 <bitemyapp> athan: now you're telling me you want to preserve ordering of...some other kind?
10:22:13 <athan> bitemyapp: Element a (Element b (Nil)) ==> a < b
10:22:14 <ReinH> FILO? Like the dough? I always called it LIFO.
10:22:24 <athan> both, actually :/
10:22:27 <bitemyapp> ReinH: LIFO is normal but I'm trying to reuse athan's words.
10:22:29 <athan> that's why I'm thinking IDRIS
10:22:36 <bitemyapp> athan: okay for one thing, it's Idris
10:22:40 <bitemyapp> it's not COBOL, it's Idris.
10:22:44 <bjorkintosh> athan, so a sorted list?
10:22:53 <ReinH> athan: how can it be both LIFO and sorted?
10:23:03 <bitemyapp> that's what i was getting at :|
10:23:07 <bitemyapp> athan: secondly, do you want dual-ordering with one sorting as a tiebreaker?
10:23:13 <athan> bitemyapp: I did not know either lifo or Idris (manual to blame, I swear!)
10:23:43 <ReinH> we can just call it a queue
10:23:47 <athan> LIFO simply provides pop and push, correct?
10:24:03 <jfischoff> Last In First Out
10:24:05 <athan> and ordering enforces rules regarding the changes, right?
10:24:49 <davidthomas> bitemyapp: For monads and uniqueness types, I'd say "mostly orthogonal" - there are some uses of each where the other can be made to fit...
10:25:02 <athan> thank you guys, I really do appreciate your help. Hopefully I'll have opportunities to pay back.
10:25:27 <ReinH> If you want LIFO you can just use a last with (:)
10:25:31 <athan> ReinH: I don't see how it couln'
10:25:32 <athan> t
10:25:34 <athan> :/
10:25:41 <ReinH> *a list
10:25:42 <bitemyapp> davidthomas: you're not talking about monads or uniqueness types anymore
10:25:51 <athan> right! I would like a restricted, type safe API though :/
10:25:57 <bitemyapp> davidthomas: you're talking about their applications. The things "themselves" are orthogonal.
10:27:05 <davidthomas> bitemyapp: well, applications is a relevant fact about the things
10:27:07 <ReinH> athan: so wrap your list in a newtype and only export the interface you want
10:27:10 <davidthomas> bitemyapp: but sure
10:27:51 <bitemyapp> davidthomas: how somebody uses [] isn't intrinsic or necessarily meaningful about []
10:27:59 <bitemyapp> [] is what [] is. That's it.
10:28:52 <bitemyapp> If I think []'s are the color blue because I have synesthesia that doesn't mean [] is blue.
10:29:46 <davidthomas> bitemyapp: I think there's a clear difference between the synesthesia example, and idiomatic use of things in contexts where the other is missing.
10:30:27 <athan>  ReinH: That's a tactic I'm not familiar with. Thank you!
10:30:57 <bitemyapp> athan: makes you feel any better, I've temporarily forgotten and then been reminded of this tactic multiple times.
10:31:02 <btcNeverSleeps> (first lpaste trial, be induglent)... I came up with that solution right-away for 99 Haskell problems, problem 8:
10:31:12 <btcNeverSleeps> http://lpaste.net/103752
10:31:19 <athan> bitemyapp: :) I smell a blog post...
10:31:40 <dwcook> athan, out of curiosity, how is your hypothetical type more restrictive than []?
10:31:47 <bitemyapp> athan: I need to write the row polymorphism post first.
10:32:18 <btcNeverSleeps> my problem is that I don't understand (yet) the solutions using foldl or foldr: http://www.haskell.org/haskellwiki/99_questions/Solutions/8
10:32:53 <athan> dwcook: Well, it would require dependent typing, so that the element of a Cons is less than the head of the xs... But I'm honestly not sure yet :)
10:32:56 <dwcook> btcNeverSleeps, do you understand what foldr does?
10:33:27 <btcNeverSleeps> dwcook: well, more or less... It's not unlike what Clojure's reduce does!?
10:33:53 <ReinH> @src foldr
10:33:54 <lambdabot> foldr f z []     = z
10:33:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:33:55 <dwcook> athan, oh, I see. Then yeah, keep the possibly precondition destroying code behind a module boundary.
10:34:19 <dwcook> btcNeverSleeps, (looking at the above definition) it replaces (:) with f and [] with z in the list.
10:34:41 <dwcook> > foldr f z [a, b, c]
10:34:43 <lambdabot>  f a (f b (f c z))
10:35:10 <btcNeverSleeps> and f can act as some sort of accumulator?
10:35:26 <ReinH> athan: how can this type function as a stack?
10:35:29 * hackagebot graphene 0.1.0.0 - Graph Library built as a final project for a Graph Theory class  http://hackage.haskell.org/package/graphene-0.1.0.0 (5outh)
10:35:36 <dwcook> You can call it that but I don't know what information you want by asking that question.
10:35:40 <ReinH> athan: does it just restrict your ability to push onto it?
10:36:30 <btcNeverSleeps> is there some way to "expand", say, "foldr f z [a, b, c]", say from ghci, and have it show me: "f a (f b (f c z))" ?
10:36:44 <athan> ReinH: Yes!
10:37:05 <ReinH> athan: you can do that in the push function that you export
10:37:07 <athan> ReinH: If the element isn't smaller than the head of the stack, no changes are made, same with if the head is equal to the element trying to be added
10:37:08 <merijn> btcNeverSleeps: There is the library that lambdabot uses for that, but I forgot what it's called
10:37:15 <merijn> > foldr f z [a, b, c]
10:37:16 <lambdabot>  f a (f b (f c z))
10:37:33 <btcNeverSleeps> merijn: I see, thanks : )
10:37:47 <athan> ReinH: Again, I want to bring this functionality as close as possible to the type system, rather than relying on the functions discretion
10:37:51 <dwcook> merijn, context: I had just had lambdabot eval that exact code :)
10:37:59 <ReinH> athan: well, since you can't do that, you should do it in the function
10:38:01 <athan> But thank you :)
10:38:03 <fizruk> merijn: simple-reflect
10:38:05 <btcNeverSleeps> just Googled and it tells me that Clojure's 'reduce' is actually foldl, not foldr.
10:38:17 <athan> ReinH: Challenge Accepted! >:D
10:38:25 <ReinH> athan: ok...
10:38:27 <dwcook> > foldl f z [a, b, c]
10:38:28 <fizruk> btcNeverSleeps: lisps don’t have right fold
10:38:28 <lambdabot>  f (f (f z a) b) c
10:38:32 <Polarina> How do I get cabal to show what it is actually compiling? All I get is "Building <package name>..."
10:38:33 <dwcook> foldl is a bit weirder
10:38:36 <btcNeverSleeps> is one of foldl / foldr typically more used than the other in Haskell?
10:38:38 <fizruk> only wrong one :)
10:38:43 <ReinH> it's not that much weirder
10:38:45 <dwcook> btcNeverSleeps, foldl should not be used almost ever
10:38:45 <btcNeverSleeps> fizruk: hehe :)
10:38:51 <merijn> btcNeverSleeps: foldr
10:38:52 <dwcook> btcNeverSleeps, foldr and foldl' are both acceptable though
10:38:53 <ReinH> it just brackets a different way
10:39:05 <merijn> Polarina: -v3 ?
10:39:33 <ReinH> (a `f` (b `f` c)) vs ((a `f` b) `f` c)
10:40:00 <fizruk> > foldr (-) z [a, b, c]
10:40:01 <lambdabot>  a - (b - (c - z))
10:40:08 <fizruk> > foldl (-) z [a, b, c]
10:40:10 <lambdabot>  z - a - b - c
10:40:30 * hackagebot graphene 0.1.0.1 - Graph Library built as a final project for a Graph Theory class  http://hackage.haskell.org/package/graphene-0.1.0.1 (5outh)
10:40:32 * hackagebot graphene 0.1.0.2 - Graph Library built as a final project for a Graph Theory class  http://hackage.haskell.org/package/graphene-0.1.0.2 (5outh)
10:41:31 <dwcook> Amusing fact: from what I said somewhere above it follows immediately that foldr (:) [] = id
10:41:33 <btcNeverSleeps> fizruk: my mind is stuck right now in foldl due to Clojure's reduce.  But I take it that I can adapt easily to the other "side" : )
10:41:53 <dwcook> > foldr (:) [] [a, b, c]
10:41:53 <Polarina> merijn, thanks.
10:41:54 <lambdabot>  [a,b,c]
10:41:57 <Rip> I assume everyone in here is on Linux....What is the best Linux Distro for Virtual Security Labs and/or Hosting Personal Servers that are free or inexpensive
10:42:10 <ReinH> dwcook: and from tht it follows that map f = foldr ((:) . f) [] :)
10:42:21 <dwcook> Rip, that's an unreasonable assumption :P
10:42:49 <lahwran> Rip: I think very many will be familiar with linux, but there are many on macs, and I think many on windows as well
10:43:27 <fizruk> btcNeverSleeps: i use clojure at work and rarely use reduce, similarly in haskell I rarely use folds: there are usually a bit more specialized versions I actually need
10:43:31 <merijn> btcNeverSleeps: If you use foldl, use foldl' which is strict
10:43:31 <ReinH> dwcook: from which it follows that map is a special case of foldr: the case that isn't allowed to modify the constructors / shape of the list. ;)
10:43:33 <Rip> lol, Linux just offers so much freedom...
10:43:40 <Rip> How can one not love it :)
10:43:57 <Rip> Point taken though
10:43:57 <merijn> Rip: I fail to see how that relates to Haskell
10:44:05 <lahwran> that's offtopic for this channel
10:44:17 <btcNeverSleeps> Rip: I've had a Debian server reaching an uptime of... 4 years.  : )   Very happy with Debian on my cheap dedicated servers and on my desktop as well.
10:44:21 <dwcook> Rip, you can try asking in #haskell-blah if you like, or a Linux-related channel
10:44:32 <Rip> Linux Distro = Server = Programming
10:44:34 <lahwran> btcNeverSleeps: holy crap, continuous uptime of four years!?
10:44:38 <btcNeverSleeps> lahwran: yup
10:45:03 <ReinH> Rip: I don't think that equality holds.
10:45:16 <btcNeverSleeps> lahwran: and the day it failed, it was funny... Motherboard fried.  But I didn't know it. The hosting company put in a new motherboard and told me there had been an issue.
10:45:39 <lahwran> ah, so it's not 4-years-and-counting
10:45:41 <mmmm_> Hey guys, can anyone point me to the parsec mailing list/issue tracker? (if such a thing exists)
10:45:54 <btcNeverSleeps> lahwran: so I couldn't understand at first why it wouldn't boot correctly.  Turned out the Debian version was so old that whatever chipset on the new motherboard wasn't supported : )
10:45:55 <Rip> @btcNeverSleeps just as good as Suse but at a better price you'd say
10:45:55 <lambdabot> Unknown command, try @list
10:46:57 <btcNeverSleeps> lahwran: nope, 400 days now I think.  During the four years I had two security Java patches to apply, but that didn't require a reboot of the server.  Zero remote vulnerability issue affecting my setup requiring a reboot, so no reboot and four years of uptime ^ ^
10:47:10 <lahwran> Rip: linux isn't as good as you think it is. it's also not bad, and my opinion of it is certainly not net negative. osx is actually a lot nicer to use for a linux nerd than I expected, once I installed iterm2 and gnu coreutils. windows, however, is a royal pain for the sorts of things I do
10:47:19 <merijn> mmmm_: I suspect the issue tracker == mail the maintainer
10:47:40 <merijn> btcNeverSleeps, lahwran: This discussion is rather off topic, I suggest continuing it in -blah or elsewhere
10:47:40 <dwcook> Rip, well looks like everyone's off-topic now :)
10:47:53 <lahwran> merijn: sorry, right
10:48:02 <lahwran> Rip: please do come to #haskell-blah, I want to continue talking
10:48:13 <klrr_> i get "Dependency tree exhaustively searched." error when i try compile idris from git, just installed cabal-install and only installed one package (process), anyone know how to solve this?  http://paste.debian.net/98041/
10:48:15 <btcNeverSleeps> Rip: well yup, you asked for cheap... That's a free Debian an hosting company was OVH (they're amazing for the price IMHO).  But this is off-topic : )
10:48:43 <btcNeverSleeps> so foldl is lazy, and foldl' is strict.  What about foldr?
10:48:46 <klrr_> found this but not sure what the solution for fixing it is https://github.com/haskell/cabal/issues/1811
10:49:09 <spott> where does the haskell platform install to on a mac?
10:49:18 <lahwran> OH THAT'S WHAT YOU MEAN BY STRICT
10:49:25 <lahwran> I thought strict meant "more specific types" ._.
10:49:29 <merijn> spott: Depends, what are you attempting to do?
10:49:31 <Rip> I do agree lahwran that mac's performance is one of kind and it doesn't come cheap, but when it comes to modifications it's limited especially when they make you buy only apple made accessories
10:49:36 <lahwran> Rip: #haskell-blah
10:49:46 <btcNeverSleeps> ah damnit
10:50:03 <lahwran> Rip: that doesn't mean "shut up", it means "seriously please continue this but elsewhere"
10:50:08 <merijn> spott: The package database and installed libraries are put in ~/Library/Haskell, but other things can be elsewhere
10:50:24 <spott> merijn: thanks!
10:50:33 <Rip> No that's good btcNeverSleeps, I've read articles were both debian and suse are compared and both have convincing arguments but for the price, its good
10:51:04 <yitz> Rip, btcNeverSleeps: really #haskell-blah is a great channel and that's what it's for
10:51:07 <Rip> Ok back to haskell
10:51:32 <lahwran> Rip: /join #haskell-blah already. we're telling you to join that channel due to not wanting to stop the conversation.
10:52:00 <btcNeverSleeps> when merijn wrote: "foldl' is strict", it is as opposed to foldl that would be lazy or am I way off?
10:52:19 <btcNeverSleeps> yitz: ok, joined haskell-blah
10:52:50 <ReinH> merijn: right
10:52:59 <ReinH> well, the opposite of strict is non-strict, but yes
10:53:01 <ReinH> it is both
10:55:14 <btcNeverSleeps> it there a function to test if a function is strict or non-strict?
10:55:36 <dwcook> btcNeverSleeps, in what sense of strict/non-strict?
10:55:49 <btcNeverSleeps> if it's lazy evaluated or not
10:56:13 <btcNeverSleeps> say an "infinite" CSPRNG
10:56:18 <dwcook> That's still too vague.
10:56:42 <dwcook> Evaluation in general is non-strict (not necessarily lazy).
10:57:04 <dwcook> You can make a function strict *in a parameter* by various means, however.
10:57:55 <dwcook> Woops, I actually just fell victim to thinking of functions as having more than one parameter.
10:58:17 <monochrom> there is no function to test if a function is strict or non-strict
10:58:36 <davidthomas> dwcook: It can be strict or not-strict in just a part of a parameter, though :-P
10:58:52 <dwcook> That too, thus the need for clarification
10:58:59 <davidthomas> dwcook: aye
10:59:22 <dwcook> There's a hack to handle _|_ but that's probably not what you want either
10:59:29 <dwcook> (and not all _|_ either)
11:00:31 <dwcook> btcNeverSleeps, so the essential question: Why do you want to test for that?
11:00:59 <btcNeverSleeps> dwcook: it's just to try to understand how it all works : )
11:01:00 <klrr_> how to i solve conflicting packages? im trying install a package that depends on containers 0.5 but it uses template-haskell which use a different version
11:01:17 <dwcook> btcNeverSleeps, then I'd suggest looking at documentation and/or source instead.
11:01:29 <johnw> klrr_: are you trying to compile with GHC 7.4.2?
11:01:34 <dwcook> btcNeverSleeps, also reading up on the means of making things strict, like strictness notation (spelled !) and seq
11:01:45 <davidthomas> dwcook: One perfectly legitimate reason might be testing a claim in documentation that a function is strict or not in a particular way
11:02:06 <btcNeverSleeps> dwcook: thx, I'll had that to my long list of Haskell things to read : )
11:02:56 <dwcook> davidthomas, hmm, do you think you could do that by passing in _|_ and checking for a _|_ result?
11:03:07 <btcNeverSleeps> speaking of understanding how things work: it's sometime useful in other language to simply add print statements to understand what's going on.  It's not really possible under Haskell right?  I mean: I can't "add println" to functions here and there without modifying the function's type signature etc.?
11:03:18 <koala_man> btcNeverSleeps: there's Debug.Trace
11:03:45 <davidthomas> dwcook: you can check for evaluation (or lack of it) in certain contexts that way, and that would let you put together tests for particular cases yeah
11:03:50 <stephenjudkins> btcNeverSleeps: yes, and there is unsafePerformIO
11:04:04 <davidthomas> dwcook: not a general proof, but that's not really the domain of tests anyway
11:04:44 <dwcook> btcNeverSleeps, Debug.Trace is fine for quick logging, but if you want something more sophisticated, there are other alternatives, like Writer or WriterT
11:05:10 <dwcook> Writer(T) actually lets you reason about the logging output and do things with it, for example
11:05:44 <monochrom> to be sure, I sometimes discover strictness by passing in bottom and then... not expect the computer to figure it out, but I myself observe computer's behaviour and figure it out
11:06:23 <monochrom> so there is a function that figures out strictness, but I am part of it, you can't just download it from the web.
11:06:49 <dwcook> monochrom, you could teach a program to figure it out the same way you do.
11:07:08 <monochrom> or if you can download it from the web, you still don't want to. refer to the movie Transcendence :)
11:07:13 <dwcook> It wouldn't even be that hard to get a nice approximation – Does it output errors that look a certain way? Is it taking unreasonably long?
11:07:28 <dwcook> ("Unreasonably long" is non-trivial in the general case though)
11:08:35 <monochrom> well, there is a combination of waiting for a bit and analysing the definition. analysing the definition yields "either within 5 seconds or it's bottom". then wait 5 seconds.
11:10:34 * hackagebot highlighting-kate 0.5.7 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.7 (JohnMacFarlane)
11:10:38 <dwcook> monochrom, put another way, you might say there's an IO action, not a function, that determines it :)
11:11:06 <monochrom> well, it's a meta-function
11:11:23 <dwcook> Meta?
11:11:34 <zerokarmaleft> cabal -v configure: http://lpaste.net/103756, explicitly executing the same configure script call: http://lpaste.net/103757
11:11:34 <monochrom> it is outside haskell
11:11:53 <monochrom> I am outside haskell. from haskell's perspective, I am at the meta level
11:11:58 <dwcook> Sure
11:12:21 <davidthomas> dwcook: throw an exception that you haven't exposed a constructor for
11:12:30 <davidthomas> dwcook: catch it in your wrapper
11:12:35 <zerokarmaleft> the "sh: inappropriate type" message seems to imply one of the configure options isn't a file or directory appropriate for that option, but those seem to check out
11:12:39 <davidthomas> dwcook: programmatic check
11:13:23 <dwcook> davidthomas, how about let x = x in x though?
11:13:47 <dwcook> Or maybe I misunderstood
11:16:01 <enthropy> how do people arrange threads so that they all get a chance to finish when the main one is done?
11:16:19 <davidthomas> dwcook: Well, we're wanting to test whether a function we're handed is strict in an argument - so we control that argument
11:16:34 <davidthomas> dwcook: We're not needing to test what that function does for *arbitrary* arguments
11:16:44 <dwcook> davidthomas, oh, sorry, I mixed up the threads of conversation
11:16:57 <davidthomas> dwcook: which - for arbitrary functions - is halting-problem equivalent
11:17:10 <monochrom> my main waits for all threads who must finish
11:17:10 <johnw> enthropy: use the async library and "wait" on them all
11:17:10 <davidthomas> dwcook: no worries
11:17:37 <davidthomas> dwcook: tbh, I'm not sure I wasn't the one who mixed things up - my attention has been jumping around
11:17:59 <davidthomas> dwcook: but the above is what I was trying to *say*, to whatever degree that's relevant to the actual conversation :-P
11:18:12 <dwcook> No worries
11:20:53 <Phillemann> Hmm, there's no wrapper for "show" for Data.Text, or is there?
11:23:22 <monochrom> Data.Text has a Show instance. it may or may not do what you like. there is nothing else.
11:23:34 <dwcook> Phillemann, what would this wrapper do?
11:23:49 <enthropy> maybe the function is    showAsText :: Show a => a -> Text
11:24:05 <dwcook> Try Data.Text.pack
11:24:23 <enthropy> (which doesn't exist as far as I know)
11:24:51 <Phillemann> dwcook: Yeah, that I am doing now. Just wondering if the text package has something like this and I overlooked it.
11:25:14 <dwcook> Nah, (pack .) is pretty straightforward already.
11:25:32 <dwcook> Though you could always use a local definition if you use it a lot
11:27:23 <klrr_> johnw: no ghc 7.4.1
11:27:36 <johnw> ok, then you are using containers 0.4.2.1
11:28:29 <johnw> if the package has a lower-bounds of 0.5 on containers, you may find it very difficult to get it installed; I'd try building it in a sandbox
11:29:53 <klrr_> oke
11:29:59 <klrr_> okey*
11:30:26 <johnw> I've been in your exact position a few times before
11:31:00 <klrr_> hmm, i get same problem in a sandbox
11:32:23 <johnw> can you try adding --constraint 'containers == 0.5' and then show me the error?
11:32:28 <savanni> Hey, guys... I'm reading up on cabal blacklisting.  Do any of you know whether it is actually a feature of cabal-install, or a feature under discussion?
11:33:23 <klrr_> johnw: sure
11:33:28 <savanni> And, if it is a feature under discussion, what's the best way of specifying to avoid a particular package version (in this case, due to a compile error)?
11:35:28 <Saizan> savanni: you can add version constraints with --constraint=
11:35:51 <johnw> you can also put such constraints in your ~/.cabal/config
11:38:22 <savanni> I take it there is no way to say package /= version in the constraint list?
11:38:37 <gilligan_> anyone else attending zurihac next month ? it's ever so lonely over in #zurihac ;)
11:39:18 <johnw> savanni: you could say < 0.5 && > 0.5
11:39:18 <_j> Hi, I used to know it, but how is lazy evaluation actually implemented by the compiler/interpreter?
11:39:23 <savanni> Ah, okay
11:39:26 <johnw> err, ||
11:39:37 <codygman-> How do I get to the vector inside of this monadic type: (CSV Data.ByteString.Internal.ByteString a, MonadIO m) => m (V.Vector a) My inital guess was to use: V.length . liftIO. I'm guessing I don't get the types
11:39:49 <johnw> _j: using "thunks", or functions which are evaluated to do the computation
11:40:01 <savanni> Yay, problem fixed! \o/
11:40:48 <_j> johnw: right indeed https://dspace.mit.edu/bitstream/handle/1721.1/16844/51442780.pdf?sequence=1
11:41:04 <enthropy> johnw: so to rewrite this http://lpaste.net/103759 with async, I would start one thread for every call of the `a -> IO b' function?
11:42:02 <johnw> enthropy: you have a couple of choices
11:42:14 <johnw> if you really want a thread per invocation, just use mapConcurrently
11:42:30 <johnw> that has the "wait on all" semantics built in
11:42:32 <mmmm_> codygman-: If you have a V.Vector then will liftIO not do on its own?
11:42:55 <vanila> is there a way to really limit GHC, so that it wont swamp my system when I screw up and code loops that dont work right?
11:42:58 <johnw> if you want to limit the number of created threads to a pool size, there are other packages for this
11:43:21 <enthropy> johnw: doesn't mapConcurrently have no guarantee about the order of some side effects?
11:43:38 <johnw> enthropy: isn't that true of concurrency in general?
11:43:54 <enthropy> ie. I want    mapM_ writer <=< mapConcurrently worker
11:44:15 <enthropy> so the first half of my IO computation can happen in whatever order
11:44:27 <enthropy> but the second half has to be in order
11:44:29 <mmmm_> actually.. don't you want a function a -> m a so just return?
11:44:30 <vamega> Hi, I'm using attoparsec and was wondering what the best way to repeat a parser a certain number of times is?
11:44:32 <johnw> if you want the results to appear in a specific order, you can use the parallel-io library
11:44:49 <codygman-> mmmm_: It didn't for some reason. I'm using the example on this page: https://github.com/ozataman/csv-conduit#example-1-basics-using-convenience-api I'm just trying to extend it to filter rows that contain a certain column value.
11:45:00 <vamega> If I have a parser called skipLine and I want to skip 3 lines, what would be the best way to do that?
11:45:01 <johnw> enthropy: reading the docs, it looks like mapConcurrently gives you back the proper order
11:45:01 <mmmm_> vamega: replicateM?
11:45:09 <dwcook> I was actually surprised async didn't come equipped with [Async a] -> IO [a], although that's not hard to write yourself.
11:45:21 <mmmm_> replicateM_ then
11:45:39 <johnw> dwcook: sequence . mapM wait?
11:46:05 <dwcook> Yeah that didn't occur to me :P
11:46:11 <enthropy> johnw: yeah the elements of the list are in the right order. But if I do "mapM_ writer <=< mapConcurrently worker", all the workers have to finish before a single writer can happen
11:46:22 <bennofs> johnw: isn't mapM wait already enough?
11:46:23 <johnw> enthropy: ah, correct
11:46:47 <johnw> but you want lazy production from the worker pool, so that as soon as the first result is ready, it appears?
11:46:56 * dwcook thinks of pipes
11:47:09 <johnw> bennofs: oh, maybe you're right
11:47:18 <enthropy> dwcook: do they use thread pools?
11:47:18 <johnw> bennofs: I forgot that mapM = sequence . map
11:47:27 <dwcook> enthropy, pipes isn't tied to IO.
11:47:29 <johnw> enthropy: this could be done easily in conduit
11:47:38 <johnw> enthropy: it's exactly what this function was written to do:
11:47:53 <johnw> http://hackage.haskell.org/package/stm-conduit-2.4.0/docs/Data-Conduit-Async.html
11:47:55 <johnw> see "drainTo"
11:48:02 <enthropy> here I'm tied to IO
11:48:27 <johnw> oh, no, gatherFrom is what you want
11:48:29 <mmmm_> codygman-: I'm not familar sorry, but if you want a -> m a then you need return
11:48:32 <johnw> what do you mean by "tied to IO"?
11:48:45 <dwcook> enthropy, sure, I just mean pipes is more general.
11:48:57 <enthropy> I mean I can't reasonably unsafePerformIO my worker and have things work out
11:49:09 <johnw> if you want both production of a list in IO, and lazy consumption of the result, then you need effectful streaming: aka, unsafeInterleaveIO, conduit, pipes, etc.
11:49:48 <enthropy> right, at the moment I do not create that list at all
11:50:58 <johnw> enthropy: gatherFrom 32 (\queue ->mapConcurrently (\a -> atomically (writeTBQueue queue a))) $$ mapM_C print
11:51:11 <johnw> oh, hmm.. that doesn't have the ordering property at all, n/m
11:51:58 <johnw> enthropy: try this: mapM_ writer <=< unsafeInterleaveIO (mapConcurrently worker)
11:52:14 <johnw> that should give you the first result, in order, as soon as it's ready
11:52:54 <allyraza> hi guys
11:52:55 <fragamus> Control/Monad/Error/Class.hs:93:18: Not in scope: ‘catch’
11:52:55 <fragamus> argh
11:53:05 <fragamus> I got that error when doing    cabal install lens
11:53:14 <joelteon> that sounds like an old mtl
11:53:25 <johnw> fragamus: which GHC?
11:53:32 <fragamus> 7.8.2 of course
11:54:02 <bennofs> fragamus: it's fixed in the github version of exceptions, which doesn't seem to be released yet
11:54:25 <fragamus> thanks
11:54:39 <fragamus> I suppose I should download that
11:54:47 <allyraza> I am new to haskell, have been studying haskell for some time in my spare time wanted to give it spin going thru a book i tried to install a package but  im getting an error
11:54:56 <fragamus> and then im a little hazy...     cabal install?
11:55:03 <bennofs> fragamus: git clone https://github.com/ekmett/exceptions. Then install that or add-source it to your sandbox
11:55:08 <johnw> allyraza: you can show us the error using http://lpaste.net/new/haskell
11:55:27 <mmmm_> you can do cabal install exceptions-0,5 and it should work
11:55:59 <allyraza> johnw: thanks here is the link http://lpaste.net/103760
11:57:06 <bennofs> allyraza: which os?
11:57:17 <klrr_> johnw: it seem to work now, thanks a lot
11:57:20 <johnw> you are using Mavericks
11:57:22 <allyraza> bennofs: I am running mac osx
11:57:33 <allyraza> johnw: yes
11:57:48 <johnw> you can either upgrade to GHC 7.8.2
11:57:54 <johnw> or
11:58:17 <johnw> follow these instructions: https://gist.github.com/cartazio/7131371
11:58:38 <johnw> in short, Mavericks switched to clang, and it's preprocessor is not compatible out-of-the-box with GHC 7.6.3
11:58:41 <allyraza> okay new what do i do with old ghc I have 7.6.2
11:58:51 <allyraza> johnw: I did notice that
11:58:57 <johnw> how did you instll GHC, using the binary installer?
11:58:59 <allyraza> I ran gcc and it says clang
11:59:10 <allyraza> johnw: yes
11:59:17 <johnw> do you have a gcc installation on your machine?
11:59:25 <allyraza> johnw: NO I don't
11:59:31 <johnw> do you want one? :)
11:59:40 <allyraza> I can brew install
11:59:47 <johnw> ok, if you brew install apple-gcc-4.2
11:59:50 <allyraza> I have homebrew installed
11:59:56 <johnw> then it's a very simple change to your settings file
12:00:08 <johnw> as described in that last link
12:00:22 <fragamus> Installed exceptions-0.6
12:00:26 <allyraza> then what do i do with the last ghc
12:00:32 <allyraza> how do uninstall it
12:00:34 <johnw> the GHC you have will work
12:00:45 <johnw> keep your GHC, install apple-gcc-4.2, change your settinsg file
12:00:48 <johnw> and all will be happy
12:00:59 <allyraza> okay sounds good
12:01:00 <allyraza> thanks
12:01:03 <fragamus> but.... still: Control/Monad/Error/Class.hs:93:18: Not in scope: ‘catch’
12:01:03 <allyraza> let me give it a shot
12:01:11 <fragamus> uck-fay
12:01:35 <johnw> fragamus: did you upgrade to mtl 2.2 by chance?
12:01:54 <fragamus> mtl-2.0.1.0
12:02:05 <fragamus> that's what lens tries to get
12:02:30 <johnw> hmm
12:03:10 <bennofs> fragamus: oops, sorry. I read Control.Monad.Catch
12:03:22 <fragamus> doh
12:03:46 <fragamus> so what can I do to get lens up and running
12:03:49 <bennofs> fragamus: I think you might need to force mtl-2.2.0.1
12:04:01 <bennofs> fragamus: try cabal install lens --constraint "mtl == 2.2.0.1"
12:05:07 <c0a8> having trouble getting hscurses-1.3 to build with cabal.. and I'm a haskell noob. can someone help?
12:05:08 <fragamus> http://lpaste.net/103762
12:05:40 * hackagebot graphene 0.1.0.3 - A minimal Graph Theory library.  http://hackage.haskell.org/package/graphene-0.1.0.3 (5outh)
12:05:54 <pavonia> c0a8: What's the problem?
12:06:02 <fragamus> edwardk: lens no workie
12:06:28 <allyraza> In love with Haskell world's best language
12:06:46 <bennofs> fragamus: ok, maybe try cabal install lens --constraint "transformers < 0.4"
12:06:59 <fragamus> ok
12:07:35 <bennofs> I thought I saw lens building against mtl-2.2.0.1 on my travis tests ... weird
12:07:40 <jophish> Would 'TypeLike' be a good term to group together Types, Kinds, SuperKinds etc...
12:07:56 <fragamus> http://lpaste.net/103763
12:08:02 <fragamus> gah
12:08:05 <jophish> I don't think I know a better word,
12:08:29 <c0a8> pavonia: I'm getting build errors. 'Not in scope: data constructor DynException', among others
12:09:33 <fragamus> bennofs: note that im using GHC 7.8.2 and cabal-install version 1.20.0.1
12:09:42 <c0a8> and I don't know how to go about fixing them when using cabal.. does it mean the package itself is broken?
12:11:35 <bennofs> fragamus: let's try: cabal install --constraint "exceptions == 0.5" --constraint "transformers < 0.4" (at least that's what the last travis build for lens used)
12:11:37 <pavonia> c0a8: It looks like it's a version problem, so either one of your packages it too old or too new
12:12:10 <pavonia> c0a8: Could you paste the build log? Maybe that gives more information
12:12:30 <bennofs> This transformers update broke everything :|
12:12:31 <c0a8> pavonia: sure thing. i did notice that 1.3 is old, and I'd prefer it to install the newer version
12:12:58 <pavonia> Yeah, try that first
12:13:06 <jophish> I'm looking for an extension which can do something like this, I apologise for the abuse of syntax here: http://lpaste.net/103764
12:13:09 <fragamus> http://lpaste.net/103766
12:13:10 <c0a8> how can I tell it to do that?
12:13:18 <c0a8> do I need to update the list from hackage?
12:13:18 <jophish> classes for types, I suppose
12:13:35 <fragamus> bennofs: no workie
12:13:50 <fragamus> bennofs: see http://lpaste.net/103766
12:13:54 <pavonia> c0a8: cabal install hscurses-1.4.1.2
12:13:54 <johnw> bennofs: yeah, I'm still avoiding it
12:15:21 <c0a8> pavonia: ah I think I figured it out. I've been using the old cabal-install (v1.18). running 'cabal install cabal-install' doesn't actually update the binary installed by my package manager
12:15:41 * hackagebot resource-pool 0.2.2.0 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.2.0 (BasVanDijk)
12:16:28 <pavonia> c0a8: An outdated cabal-install version shouldn't be the problem here
12:16:44 <pavonia> An outdated package list maybe is
12:16:53 <allyraza> johnw: thanks again
12:17:18 <fragamus> updating my package list
12:18:35 <bennofs> fragamus: ok, I got an environment with a clean ghc 7.8.2, so maybe I can try to reproduce it now :p
12:19:16 <fragamus> Control/Monad/Error/Class.hs:93:18: Not in scope: ‘catch’
12:19:39 <fragamus> I really enjoy build problems
12:19:50 <fragamus> that's why I'm so happy right now
12:20:13 <c0a8> pavonia: still trying to get used to everything. it seems some older haskell libraries were installed by my package manager. because of those, cabal won't let me install the new hscurses
12:20:37 <c0a8> pavonia: is it best practice to only install ghc/cabal through the OS package manager and deal with all haskell libraries through cabal?
12:21:00 <pavonia> I think sp
12:21:03 <pavonia> *so
12:21:07 <c0a8> ok I will try that
12:21:13 <c0a8> thanks for the help
12:21:29 <bennofs> fragamus: hmm, cabal install lens chooses mtl-2.1.3.1 for me
12:21:40 <pavonia> c0a8: What's your GHC version, btw?
12:21:49 <c0a8> 7.8.2
12:21:50 <fragamus> mtl-2.0.1.0
12:21:53 <dmj`> cabal install -j mtl-2.0.1.0 fails
12:21:57 <c0a8> it's the one from arch's haskell-core repo
12:22:11 <dmj`> fragmus: came on IRC just because of this
12:22:24 <fragamus> bennofs: why would my rig be choosing differently
12:22:32 <dmj`> fragmus: Control/Monad/Error/Class.hs:93:18: Not in scope: ‘catch’
12:22:35 <bennofs> fragamus: you could try --constraint "mtl == 2.1.3.1"
12:22:36 <dmj`> ironic :P
12:22:57 <bennofs> fragamus: maybe that gets you at least past the mtl issue :P
12:23:03 <fragamus> but...
12:23:13 <bennofs> I successfully built that version of mtl here
12:23:19 <dmj`> bennofs: cabal sandbox init && cabal install -j mtl-2.0.1.0 fails. W/o any dep. conflict, that's a big deal
12:23:29 <dmj`> bennofs: what os?
12:24:00 <bennofs> dmj`: I'm using nixos, ghc 7.8.2 with no extra packages, cabal install lens in sandbox picks mtl-2.1.3.1 which builts fine
12:24:49 <dmj`> bennofs: I just hard code to the latest version of everything
12:24:59 <bennofs> dmj`: :)
12:25:01 <pavonia> c0a8: The module using DynException seems to be removed in the new base package, so you might have to rewrite the hscurses code to install it :S
12:25:32 <dmj`> bennofs: lens, containers, base, dequeue, safecopy, text, time picks mtl-2.0.1.1,
12:25:38 <dmj`> 2.0.1.0*
12:25:43 * hackagebot shelly 1.5.3.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.3.1 (GregWeber)
12:25:52 <c0a8> pavonia: hmm, I'm hoping that using the newer hscurses version fixes that issue
12:25:52 <bennofs> dmj`: what happens if you give it the --constraint flag? does it complain?
12:26:46 <bennofs> dmj`: base depends on mtl?
12:27:07 <dmj`> bennofs: no, when trying to install a project that has *all* those deps
12:27:07 <c0a8> pavonia
12:27:17 <c0a8> pavonia: http://pastebin.com/h357Prma
12:27:42 <c0a8> this is what happens when I try to manually specify the newer version of hscurses
12:27:52 <bennofs> dmj`: well, try giving it --constraint "mtl == 2.1.3.1". If it's truly impossible, it will complain
12:28:02 <jophish> To clarify, this is something I'd like to do, pattern match over multiple types in the same expression. http://lpaste.net/103764
12:28:11 <jophish> I think that this is what PatternSynonyms are for, right?
12:29:07 <fragamus> bennofs: your machine chose mtl-2.1.3.1 but mine defaults to mtl-2.0.1.0       what is the theory explaining that
12:29:21 <pavonia> c0a8: Okay, so I think you have to goto http://hackage.haskell.org/package/hscurses, download that the source code and patch the .cabal file
12:29:29 <bennofs> fragamus: does it work if you give it an explicit constraint flag?
12:29:43 <fragamus> it is building now, and it appears to be working fine
12:29:53 <mmmm_> jophish: Why can left not have the type Either a b -> Maybe a?
12:29:58 <bennofs> fragamus: well, that is indeed weird then
12:30:09 <fragamus> but I don't want my environment to continue to suck in ways that your environment does not suck
12:30:29 <dmj`> bennofs: shouldn't have to do that
12:30:42 <mmmm_> Did you see my message jophish?
12:30:42 <bennofs> dmj`: yes, I was just wondering if maybe it revals some other issue
12:30:47 <fragamus> maybe it has to do with my PATH variable
12:30:53 <jophish> mmmm_: I did not
12:31:01 <mmmm_> jophish: Why can left not have the type Either a b -> Maybe a?
12:31:10 <mmmm_> What are you trying to do?
12:31:15 <bennofs> dmj`: if it works without reinstalls, then I think its a bug in cabal. If it forces some reinstalls, then maybe cabal is just trying to avoid reinstalls?
12:31:19 <jophish> mmmm_: because I may want to call left with a MyEither
12:31:20 <c0a8> pavonia: okay. what should I change in the .cabal file?
12:31:56 <pavonia> c0a8: First, what's the output of "ghc-pkg list unix"?
12:32:10 <athan> ReinH: Hey so I think I solved that type dependence problem with template haskell, type families, GADT's and multiparam bijections!
12:32:17 <c0a8> pavonia: unix-2.7.0.1
12:32:29 <athan> although the source of the template haskell magic is still kinda type-unsafe :(
12:32:51 <c0a8> so it's too new for the hscurses package hmm
12:33:18 <pavonia> c0a8: Okay, then in line 41 in the cabal file, change line "< 2.7" to "<2.8"
12:33:31 <jophish> mmmm_: see https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms Associated pattern synonyms
12:33:31 <c0a8> pavonia: done. how do I build it with the new cabal file now
12:34:24 <pavonia> c0a8: In the directory of the .cabal file run "cabal install"
12:34:35 <pavonia> and cross your fingers :)
12:34:39 <c0a8> haha okay
12:34:54 <jophish> sadly that's not a thing yet
12:34:56 <bennofs> dmj`: maybe your environment just wasn't fully clean?
12:35:10 <c0a8> well, it fixed the DynException build error. still getting errors about 'block' not being in scope (Perhaps you meant 'blockM')
12:35:46 <pavonia> Could you paste the complete output?
12:35:53 <c0a8> pavonia: coming right up
12:36:17 <dmj`> bennofs: I hate having to specify dependencies in my cabal file I make no use of in the project, but because a another dependency depends on it, and it fails, I have to. Having to specify the latest mtl in my cabal is a great example
12:36:26 <dmj`> bennofs: I'm using sandboxes, it's clean
12:36:48 <bennofs> dmj`: have you recreated your sandbox before your tried? No global packages?
12:37:02 <c0a8> pavonia: http://pastebin.com/CKhydXay
12:37:13 <dmj`> bennofs: of course, cabal sandbox delete, cabal sandbox init
12:37:17 <jophish> Seeing as GHC hasn't implemented this yet, What's the nicest replacement for it? https://ghc.haskell.org/trac/ghc/ticket/8583
12:38:08 <Iceland_jack> jophish: Make a type class
12:38:12 <bennofs> dmj`: that sucks then :( I also had a similar issue with criterion / doctest in the same project
12:38:18 <Iceland_jack> and just include the function as a view pattern
12:38:51 <cwvh> sorry, I'm late to the conversation, but the `catch' bug in mtl builds appears to be something around lens/transformers. I got around it by building aeson before lens. There should be a fix coming down in transformers soon.
12:38:54 <Iceland_jack> For 'Cons' you make
12:38:55 <Iceland_jack>     uncons :: ListLike l => l a -> Maybe (a, l a)
12:39:08 <Iceland_jack> and then you can write
12:39:08 <Iceland_jack>     pattern Cons a as <- (uncons -> Just (a, as))
12:39:26 <bennofs> cwvh: yes, transformers was upgraded from 0.3 to 0.4. This caused lots of breakage
12:39:45 <cwvh> bennofs: good to know, I thought I was going crazy this morning
12:39:52 <Iceland_jack> and Nil could be
12:39:52 <Iceland_jack>     pattern Nil <- (uncons -> Nothing)
12:40:18 <pavonia> c0a8: Hhm, these functions were marked deprectaed in older GHC versions and seem to be removed now. Unfortunately, I don't know how to fix that
12:40:22 <Iceland_jack> jophish: Does that answer your question?
12:40:34 <jophish> Iceland_jack: sounds good! I'll give it a try with my example
12:40:35 <pavonia> c0a8: I guess you have to ask the maintainer for a new version
12:40:49 <c0a8> pavonia: does this mean that the HSCurses project is just mad out of date?
12:40:58 <pavonia> exactly
12:41:08 <bennofs> cwvh: also, exceptions has moved from 0.5 to 0.6 which causes breakage too (I only know of https://github.com/batterseapower/temporary/pull/12, but there is probably more)
12:41:50 <pavonia> c0a8: Maybe there's a recent version in the repo at git://github.com/skogsbaer/hscurses.git
12:41:55 <c0a8> hmm I could use the haskell ncurses package instead.. only thing is that it doesn't seem to be possible to use default colors
12:42:29 <c0a8> unless I'm missing something
12:43:25 <cwvh> bennofs: darn, what a mess, but looks like all will be well soon
12:43:57 <jophish> Iceland_jack: like this: http://lpaste.net/103764
12:44:01 <pavonia> c0a8: For terminal GUIs vty-ui seems to be quite popular
12:44:33 <Iceland_jack> jophish: You need parentheses around the view patterns
12:44:47 <jophish> Iceland_jack: ah yes, thanks
12:44:51 <jophish> I wonder if there is some template Haskell which can generate these...
12:44:57 <c0a8> pavonia: thanks. I will look into that, but i'd certainly prefer an ncurses solution since I'm porting an ncurses app from C
12:45:14 <davidthomas> Is it possible to write the functor *from* Identity?
12:45:14 <Iceland_jack> Template Haskell is very heavyweight for such a thing
12:45:19 <dmj`> bennofs: ok I cabal updated and then reinstalled and it worked
12:45:27 <pavonia> c0a8: Hhm, I see
12:45:29 <dmj`> bennofs: maybe my cabal was jsut out of date...
12:45:40 <jophish> Iceland_jack: or any way to generate these with a little less boilerplate
12:46:09 <Iceland_jack> Which part exactly would you like to generate and from what?
12:46:57 <jophish> I suppose the instances, from [''left, ''MyLeft, ''right, ''MyRight]
12:48:21 <jophish> Iceland_jack: or from the same information that Associated pattern synonyms uses
12:49:08 <Iceland_jack> A better solution is to just write them by hand until the associated pattern drops into GHC :) you only write it once, hidden away from the user and it's not hard to write
12:49:35 <jophish> we've probably spent more time talking about it than they would have taken to write!
12:49:49 <Iceland_jack> Indeed!
12:49:55 <jophish> I guess programmers are suckers for amortised costs!
12:50:03 <Iceland_jack> But why interact with human beings when you could be coding
12:50:47 <jophish> :) exactly
12:50:53 <jophish> Thanks for the help, Iceland_jack!
12:51:29 <Iceland_jack> Hope it actually was of any help :) I've used that very thing as a poor-man's associated patterns for some of my projects already now
12:51:55 <jophish> I'll let you know if I make any use of it
12:52:53 <Iceland_jack> A very cool but impractical feature is being able to write 'map' that works for [], Set, Text, ByteString, ... at the same time
12:53:08 <Iceland_jack> of course not as efficient as some of the specialized functions
12:53:58 <quchen> davidthomas: "Functor from Identity"?
12:54:28 <fragamus> bennofs: i have a funny feeling .....   Foreign/C/Math/Double.hsc:146:11: Not in scope: ‘unsafePerformIO’
12:54:34 <davidthomas> quchen: fmap :: (Identity a -> Identity b) -> a -> b
12:54:41 <bennofs> fragamus: :O=
12:54:44 <Kaidelong> is someBracketFunction $ do { some_IO } considered idiomatic haskell?
12:54:48 <davidthomas> quchen: mathematically, that's still a functor, right?
12:54:48 <jophish> Iceland_jack: fmap, apart from Set though
12:54:52 <fragamus> cabal install cmath
12:55:02 <fragamus> what the functor is going on
12:55:02 <Kaidelong> this seems like the perfect way to deal with glBegin and glEnd
12:55:24 <davd> [Q] why do we need bottom (undefined)? could there be a -XNoBottom flag? can we prevent definitions such as let f = f, i.e. only allow "proper" implementations?
12:55:30 <Iceland_jack> jophish: You misunderstand the point
12:55:36 <davidthomas> quchen: I don't *think* there's a way to give it a Functor instance, but that's far from conclusive :-P
12:55:38 <Iceland_jack> fmap is many different implementations
12:55:50 * hackagebot hsexif 0.4.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.4.0.0 (EmmanuelTouzery)
12:56:01 <bennofs> davd: it's not possible to detect non-termination in a turing complete language in all cases
12:56:14 <Iceland_jack> I could have taken 'filter' as an example if you'd prefer
12:56:29 <pranz> davd: check out the halting problem
12:56:30 <jophish> ah, that makes more sense
12:57:06 <Iceland_jack> Sure you could make a 'Filterable' type class, but each instance could have a completely different implementation
12:57:12 <bennofs> davd: There are however other languages that always guarrante termination. Such languages are called total languages.
12:57:28 <jophish> davd: check out Idris, for example
12:57:48 <quchen> davidthomas: It doesn't have the right type for fmap, that's for sure
12:57:52 <davd> ah, thanks!
12:57:55 <k00mi> Idris is by default not total and the totality checker is a work in progress
12:58:00 <jophish> Iceland_jack: I see what your getting at, I hope associated pattern synonyms help with this
12:58:02 <hexagoxel> Kaidelong: Control.Exception.bracket ?
12:58:16 <bennofs> k00mi: is Adga total?
12:58:23 <k00mi> yes
12:58:42 <mizu_no_oto> I'm trying to cabal install gtk2hs-buildtools, and I'm running into compiler errors caused by the primops changes (https://ghc.haskell.org/trac/ghc/wiki/PrimBool).  Has it not been fixed yet for 7.8, or do I have somthing misconfigured?
12:58:44 <davidthomas> quchen: hm, true!
12:58:58 <fragamus> bennofs can you install cmath and tell me what it says
13:00:50 <bennofs> fragamus: same error
13:01:10 <bjorkintosh> so if haskellers like idris so much, what about agda?
13:01:21 <bjorkintosh> is it not haskelly enough?
13:01:30 <davidthomas> quchen: Is it correct to say "Functor represents functors from Hask to a subcategory of Hask"?
13:01:34 <fragamus> thanks bennofs
13:01:38 <quchen> davidthomas: You can of course write a function like this yourself,
13:01:39 <quchen> :t let idFmap idF x = runIdentity (idF (Identity x)) in idFmap
13:01:40 <lambdabot> (Identity a1 -> Identity a) -> a1 -> a
13:02:03 <davidthomas> quchen: For sure.  Just trying to pin down my theory.
13:02:05 <quchen> davidthomas: I think that's correct, but I'm not an expert on the subject.
13:02:40 <davidthomas> quchen: 'k, thanks :)
13:02:53 <lispy> bjorkintosh: agda is quite nice
13:03:45 <bjorkintosh> i see.
13:03:48 <quchen> davidthomas: In any case, if it's a subcategory it's not necessarily a proper subcategory, since "Identity x" is isomorphic to "x". So the Identity Functor maps Hask to Hask.
13:04:02 <k00mi> bjorkintosh: I think idris is gaining popularity because it focuses more on general purpose programming than being a proof assistant
13:04:34 <savanni> If any of you are familiar with Happstack, I have a question about query parsing that is making me feel stupid right now.
13:04:34 <lispy> I suppose you could say the focus for agda is unclear
13:04:39 <Iceland_jack> Idris also focuses more on allowing syntax extensions and embedding DSLs
13:04:48 <bjorkintosh> k00mi, ah. gotcha.
13:04:55 <Iceland_jack> while Agda has unicode madness going on, if you're into that sort of thing
13:05:01 <cwvh> k00mi: also culture... if I google for "agda tutorials" I get journal articles. The query for "idris tutorial" will turn up vimeo screencasts. This is just in my limited experience.
13:05:02 <n-dolio> Functor represent functors from Hask to Hask.
13:05:05 <stepcut> savanni: what's the question?
13:05:07 <davidthomas> quchen: Yes, for sure it needn't be a proper subcategory.
13:05:08 <savanni> How do I call the `look` operation and get a Maybe result?  Because there is no HasRqData Maybe instance.
13:05:24 <savanni> Like, if I `look` for a parameter, I want to get Nothing if the parameter is absent.
13:05:30 <stepcut> savanni: one moment
13:05:54 <quchen> n-dolio: Hask -> Hask are endofunctors on Hask. Functor in general shouldn't be one, should it?
13:06:10 <stepcut> savanni: like this? http://happstack.com/docs/crashcourse/index.html#looking-up-optional-parameters
13:06:22 <k00mi> lispy: right, but I think in practice agda is used mostly for proof stuff. Prooving everything is total is just a whole lotta work
13:06:51 <davidthomas> quchen: Any functor from Hask to a subcategory of Hask is still a functor from Hask to Hask, right?
13:07:00 <savanni> stepcut: yes!  Exactly like that! (hangs head)
13:07:08 <stepcut> savanni: :p
13:09:07 <lispy> k00mi: I think agda gets used to advance the state of the art :)
13:09:27 <lispy> k00mi: I don't know if very many people 'use' agda who aren't already researchers of dependently typed languages
13:09:54 <lispy> k00mi: a notable exception being copumkin's category theory library
13:10:26 <n-dolio> Functor is always a Hask endofunctor.
13:10:33 <Aetherspawn> cat theory makes me a sad panda
13:10:35 <lispy> k00mi: But that brings me to an interesting use-case for Agda. Using it to explore a mathematical model to improve your understanding.
13:10:52 <n-dolio> Just because you don't 'cover' all the objects in the target category doesn't mean that you're not a functor to that category.
13:10:52 <c_wraith> what?  constructs that exist in the type system are limited to functioning on types?  WHY??!?!
13:10:54 * hackagebot snap-web-routes 0.4.0.0 - Type safe URLs for Snap  http://hackage.haskell.org/package/snap-web-routes-0.4.0.0 (lukerandall)
13:11:20 <k00mi> lispy: that's undoubtly true
13:11:49 <n-dolio> And you can't talk about the restriction of Haskell types to the 'image' of a functor in Haskell.
13:12:46 <n-dolio> And even if you could, Functor takes things of kind * -> *.
13:13:01 <lispy> k00mi: and agda is just about perfect for mathematics exploration. It has decent latex integration and mixfix + unicode lets you make a notation that is both native to agda and yet feels familiar to a math text.
13:13:25 <lispy> k00mi: although, the lack of rationals/reals in the standard lib is problematic sometimes
13:13:40 <davidthomas> n-dolio: You mean "talk about" in Haskell, or "talk about" coherently in English?
13:14:03 <Rip> So how about that linux....
13:14:19 <n-dolio> Talk about in Haskell. That's what my sentence said, though it's hard to tell. :)
13:14:23 <Rip> j/k
13:14:23 <lispy> k00mi: for me, one of the charming aspects of idris is that it's code base is still pretty small and approachable
13:14:35 <napping> n-dolio: why not?
13:14:55 <lispy> k00mi: and the syntax makes it feel like Haskell + some extensions
13:15:04 <napping> any Functor is some f :: * -> *, and we can certainly write types involving f a
13:15:29 <n-dolio> What is the kind that classifies the objects in the image of f?
13:15:38 * lispy like Coq, Agda, Idris, and Isabelle. Is that allowed?
13:15:47 <k00mi> lispy: my main gripe with idris so far is type checking times and bugginess
13:15:50 <n-dolio> And does f have that kind as a codomain?
13:15:51 <lispy> am I supposed to have a favorite? :)
13:16:06 <napping> n-dolio: what's the kind that classifies types that are instances of Show?
13:16:14 <lispy> k00mi: how long until we can rewrite Idris in Idris? :)
13:16:33 <monochrom> instances of Show have kind *
13:16:37 <napping> lispy: just need to depose Goedel ...
13:16:56 <lispy> napping: You can disable totality selectively. So, done :)
13:16:59 <newsham> then you'll have church and turing to deal with
13:17:02 <napping> Oh, I guess so
13:17:02 <n-dolio> There isn't one. How does that prove that you _can_ do it for the other example?
13:17:04 <codygman-> Has anyone here used csv-conduit before? I'm a bit confused at how I'd filter by a specific row. Well more I'm confused about how I'd refer to a certain Row.
13:17:33 <Kaidelong> I am having trouble figuring out cabal-dev
13:17:45 <k00mi> lispy: hehe, I think that's still quite far off
13:17:48 <napping> n-dolio: so does that mean we can't "talk about" types that have Show instances in Haskell?
13:18:06 <k00mi> lispy: but proving basic things about the compiler would really be quite sweet
13:18:20 <Kaidelong> I have "build-depends: base ==4.6.*, glfw-b >=1.4.6, opengl >=2.9.1.0"
13:18:29 <newsham> for that matter when is ghc going to be written in haskell? :)
13:18:37 <lispy> Kaidelong: these days, you should be able to use cabal's built in sandboxes instead of cabal-dev (which is now deprecated)
13:18:44 <ReinH> newsham: lots of it is written in Haskell?
13:18:45 <Kaidelong> when I do "cabal-dev add-source ." and "cabal-dev install" it complains it can't resolve the dependencies
13:18:54 <newsham> reinh: true, but lots of it isnt, too.
13:18:55 <k00mi> it's really annoying when you don't know if that error message is due to you writing nonsense or if it's a bug :(
13:18:57 <napping> newsham: Still resting from getting rid of the perl?
13:19:02 <ReinH> newsham: maybe less than you think?
13:19:08 <jfischoff> newsham: you mean the runtime?
13:19:10 <newsham> napping: i'm more concerned about the C that sticks around in the runtime
13:19:15 <n-dolio> napping: For some purposes, yes.
13:19:26 <lispy> newsham: What should we replace the C with? rust?
13:19:32 <jfischoff> haskell
13:19:46 <newsham> lispy: haskell would be nice.
13:19:49 <ReinH> lispy: rust is actually a very interesting idea
13:19:53 <quchen> There's C in Haskell's runtime? I thought it was C--.
13:19:59 <jfischoff> both
13:20:04 <lispy> quchen: C-- is like the codegen part
13:20:13 <lispy> quchen: the compiler generates C--
13:20:32 <k00mi> rust already has a self-hosting runtime doesn't it?
13:20:38 <ReinH> We talked with SimonM about this a bit on the haskell cast btw </plug shameless=true>
13:20:52 <Kaidelong> lispy: the latest cabal from hackage doesn't have that feature
13:21:01 <newsham> i listened to that yesterday.. i was pleased to hear that some of the obj file lodaer stuff is going away
13:21:01 <napping> lispy: I think some files are parsed by GHC as C--, not that I'm claiming anything about how the runtime is implemented
13:21:10 <lispy> newsham: if the RTS were in Haskell would there be process bootstrapping issues we don't currently have?
13:21:20 <Kaidelong> I would rather use cabal-dev for now until the next haskell-platform is out
13:21:25 <newsham> lispy: *shrug* no idea.
13:21:26 <napping> newsham: What's going away with object loading? Doesn't that weaken ghci?
13:21:41 <lispy> Kaidelong: I installed Cabal and cabal-install from hackage and I have sandboxes.
13:21:43 <newsham> napping: in favor of integrating more traditionally with the c dyn loader
13:21:48 <newsham> provided by each platform
13:21:54 <jophish> How safe is it to sigterm a cabal install?
13:21:58 <napping> lispy: Doing the RTS in Haskell seems to me to require some kind of cons-free subset of Haskell, to avoid needing a runtime
13:22:05 <Kaidelong> well when I try "cabal sandbox init" cabal tells me that sandbox is not a known command
13:22:08 <benzrf> rts?
13:22:17 <quchen> Runtime system.
13:22:22 <benzrf> oh
13:22:24 <Kaidelong> I ran cabal install cabal-install today
13:22:32 <quchen> The thing that has the magic power to run IO :-D
13:22:34 <Kaidelong> after I updated
13:22:35 <napping> jophish: As far as I know it's safe, and the worst case is bounded by reinstalling cabal
13:22:37 <bennofs> Kaidelong: cabal --version?
13:22:41 <benzrf> quchen: whoa
13:22:42 <glguy> Kaidelong: then you need to update your path so you start using the new version
13:22:43 <napping> jophish: reinstlling all your packages, rather
13:22:46 <lispy> Kaidelong: Are you using the one you installed? Is $HOME/.cabal/bin at the front of your path?
13:22:53 <lispy> hash -r
13:22:56 <lispy> lots of things to check
13:23:01 <jophish> yeah, I forgot to add -j16
13:23:09 <n-dolio> napping: It doesn't really matter, though, because even if you came up with a baroque construction that identified exactly the types in the image of f : * -> *, that wouldn't be what Functor is.
13:23:18 <ReinH> FYI ghc is about 82% Haskell and about 12% C
13:23:33 <quchen> Measured by arbitrary number generation.
13:23:35 <newsham> 12% is a good sized chunk.
13:23:35 <Kaidelong> ugh vim is interpolating %
13:23:36 <jxv> Could `machines' be used for constraint propagation?
13:23:45 <ReinH> quchen: arbitrary number generation?
13:23:59 <Kaidelong> also no, I could go change that quickly
13:24:21 <quchen> ReinH: Well, SLOC is one of the maaaany metrics you can use.
13:24:24 <newsham> thats a lot of lines of unsafe code where each bug can violate important safety property
13:24:30 <ReinH> quchen: sure
13:24:46 <quchen> ReinH: See TIOBE. You can make any shit up as long as you have a website. I'm sure we can make GHC look like it's 90% C.
13:24:55 <lispy> napping: the RTS in Haskell does more than just allocations and GC. It also provides lazy evaluation.
13:24:57 * ReinH shrugs
13:24:58 <newsham> and mind you some of that code isnt very pretty, and written by people who would rather be writing code in haskell.
13:25:09 <n-dolio> And, for instance, in category theory, it isn't even correct to say that 'every functor is a functor from some category to exactly the category in its image,' which is essentially what was being asked.
13:25:18 <ReinH> newsham: Yes, the RTS system contains some very hairy C that is very difficult to understand, debug, and change. Not disagreeing.
13:25:26 <quchen> ReinH: My point is that most (all?) of the Haskell parts are written in Haskell, and the part that's close to the hardware is more C-y.
13:25:28 <Kaidelong> C:\Users\kaide_000\AppData\Roaming\cabal\bin is the only thing on my PATH, apparently
13:25:34 <napping> n-dolio: No, but you can say a functor has an image
13:25:38 <ReinH> quchen: The parallel runtime is C
13:25:42 <bitemyapp> newsham: are you here to have your opinions validated by other people or are you asking to be introduced to GHC development?
13:25:54 <benzrf> ReinH:
13:25:55 <ReinH> The spark heap / deques are C, etc
13:25:57 <benzrf> 'rts system'
13:26:03 <bitemyapp> 'atm machine'
13:26:09 <ReinH> benzrf: ?
13:26:13 <quchen> PERSONAL PIN NUMBER
13:26:14 <quchen> What do I win
13:26:20 <ReinH> benzrf: heh woops
13:26:25 <Kaidelong> cabal --version outputs 1.16.0.2
13:26:26 <n-dolio> It has an image, but it is not a functor to that image. There is simply another functor that is a functor to the image that has the same action on objects and morphisms.
13:26:32 <newsham> bitemyapp: i'm on irc chatting about random topics, and "can we get idris written in idris" came up, so I thought I'd mention "ghc written in haskell would be nice, too"
13:26:40 <jophish> I have heard my grandmother say 'personal pin number' before
13:26:44 <newsham> bitemyapp: tl;dr, "neither"
13:26:53 <n-dolio> Those are in general two different functors, though.
13:27:20 <Kaidelong> do I need to restart vim for it to know where the new cabal lives? I installed the new cabal from vim
13:27:26 <napping> n-dolio: sure, but how do you get from there to saying we can't coherently talk about the image of a functor? runState can only be applied to types in the image of State, for example
13:27:34 <jophish> How about parallel cabal installs? Can I start another cabal process whilst another is still installing?
13:28:17 <n-dolio> napping: I didn't make the inference in that direction. The lack of ability to talk about the image of an arbitrary Functor in Haskell is simply another obstacle to the original statement being true.
13:28:19 <Kaidelong> oh, for some reason windows prepends the system path to the user path
13:28:22 <Kaidelong> =/
13:28:25 <newsham> rienh: nice podcasts, btw.. thank you.
13:28:35 <ReinH> newsham: thanks :)
13:28:37 <Kaidelong> so the haskell platform cabal is shadowing my user path, it should be the other way around
13:28:58 <Kaidelong> I guess I'll put what should be in my user environment variable in the system path instead
13:29:09 <newsham> kaidelong: put %home%\bin in the system path?
13:29:50 <Kaidelong> just did
13:31:38 <Kaidelong> okay, I did have to restart vim too
13:31:54 <napping> ReinH: which episode?
13:32:09 <Kaidelong> cabal --version reports the exact same it did before
13:32:20 <ReinH> napping: Did we talk to Simon Marlow about the RTS? It was the Simon Marlow episode iirc. ;)
13:32:30 <ReinH> I think that was 4
13:32:33 <napping> That would do it :)
13:32:40 <napping> Kaidelong: still trying to upgrade cabal?
13:32:48 <Kaidelong> upgraded cabal successfully
13:32:58 <napping> great
13:33:01 <Kaidelong> but the cabal command is using the old cabal AFAICT
13:33:09 <napping> Oh, that's weird
13:33:17 <lispy> Kaidelong: what is your path?
13:33:22 <Kaidelong> what's the windows equivalent of which?
13:33:32 <lispy> Kaidelong: The new cabal is at something like %home%\.cabal\bin
13:33:37 <napping> Kaidelong: what does ghc-pkg list say?
13:33:49 <lispy> Kaidelong: I usually install mingw which comes with which
13:34:13 * lispy needs to go
13:34:44 <Kaidelong> it tells me I need to do a ghc-pkg recache
13:34:55 <Kaidelong> would that maybe solve the problem?
13:35:19 <lispy> that is a good thing to do, but it won't solve this problem
13:36:03 <Kaidelong> I'm going to try to install cabal-install globally
13:36:07 <Kaidelong> I might as well do that anyway
13:36:34 <napping> Kaidelong: I was hoping it would tell you what versions of Cabal the package had been installed
13:37:13 <SrPx> months trying to get GHCJS working on my computer...
13:37:43 <SrPx> you can say what you want about Haskell but the package manager is the worst thing I've ever used in the world
13:38:03 <monochrom> the end of a successful "cabal install cabal-install" session tells you where it is put.
13:38:31 <quchen> SrPx: Haskell has a package manager?
13:38:58 <SrPx> quchen: there is the problem, it needs one
13:39:11 <napping> SrPx: did you try a cabal sandbox (or cabal-dev)?
13:39:19 <monochrom> I disagree, but I have nothing more to add.
13:39:19 <spott> why is cabal so bad?
13:39:24 <Kaidelong> napping: it didn't tell me anything about what packages were installed locally except for mingw packages
13:39:35 <Kaidelong> it did tell me about what packages were installed system-wide
13:39:45 <napping> Kaidelong: sounds pretty confused then, I don't know much about GHC under mingw
13:41:19 <napping> SrPx: Using sandboxes has avoided almost all dependency issues for me (leaving needing C libraries, and needing a particular GHC version)
13:42:10 <Rip> I think I might of unofficially met some admins, but may I know who they
13:42:12 <Rip> are*
13:42:53 <Kaidelong> windows really needs a su-like command, found a utility that provides it, may be useful for other people: http://code.kliu.org/misc/elevate/
13:43:43 <koala_man> Kaidelong: isn't that what runas does?
13:44:14 <roconnor> spott: I'm not a cabal expert but, untill recently, it expect you to be able to install a globally consistent set of packages on your computer, which is actually impossible to do with the way Haskell pacakges are released in practice.
13:44:21 <Kaidelong> koala_man: then you have to set an administrator password, which increases your attack surface
13:44:26 <roconnor> spott: but maybe someone else has a more thoughtful answer.
13:44:26 <Kaidelong> elevate just uses UAC
13:44:49 * n-dolio has been achieving the impossible for years.
13:45:33 <SrPx> napping: I don't know how to.
13:45:52 * monochrom accomplishes global consistency by not being cavalier with "oh new versions"
13:46:11 <spott> roconnor: I guess I was more asking along the lines of: why hasn't it been fixed?  It seems like there are a lot of package managers out there that seem to work pretty well
13:46:15 <SrPx> honestly, at this point I'm willing to hire someone to create a shell script that will get a working GHC 7.8 / GHCJS on mavericks for me. Because I have no idea what to do anymore.
13:46:41 <napping> spott: I think the basic problem is that because of things like re-exports and inlining, you can end up with distinct compiled libraries by building a single version of a library against different versions of dependencies. Plus, ghc can handle having different versions of a package available at once, but not multiple builds of one particular version number of one package
13:47:06 <napping> spott: and that prevents simply recompiling new stuff to satisfy a new build
13:47:16 <monochrom> spott: read my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash . GHC libs face one more challenge than other language libs.
13:47:23 <roconnor> spott: are there.  People tell me that this problem exists in all the language based package managers.  I'm not sure if I believe them, but I have no experience with other managers.
13:47:32 <monochrom> which is what napping says
13:48:20 <SrPx> napping: which, lets say, Node.js/NPM which we laugh so much about actually does right. I never, ever had a problem installing a lib on node.js. It is just a matter of "npm install lib", require("lib.js"). It simply works. Using node.js, you feel like you have a world of code in your hands. Going to install something in Haskell? Good luck, hope you have a free day. Or week.
13:48:46 <napping> Haven't had nearly that much trouble
13:48:47 <monochrom> SrPx: use hugs. it's an interpreter. then problem solved.
13:48:48 <SrPx> I don't understand why the community don't accept this is a problem and keep saying the problem is the user.
13:48:50 <dmj`> SrPx: yea, but then you're using node...
13:49:09 <sm> SrPx: that's not what the community does
13:49:13 <dmj`> SrPx: do you use a sandbox?
13:49:23 <spott> napping: oh yuck,
13:49:33 <monochrom> all of node.js, python, perl, and ruby enjoy easy package stories because they are bloody interpreters
13:49:33 <spott> monochrom: thanks for the link
13:49:38 <SrPx> dmj`: yea, but at least I can get shit done with it? What is better, a terrible language that can do stuff that a divine language where you can't install a lib?
13:50:08 <sm> I'm curious how things work so easily with Node, unless it's that it installs incompatible things which fail at runtime ?
13:50:15 <spott> roconnor: pip isn't perfect, but is better than cabal
13:50:16 <SrPx> dmj`: I have no idea how I'm supposed to do it
13:50:20 <napping> SrPx: try "cabal sandbox init; cabal install" in a fresh clone of ghcjs
13:50:24 <dmj`> SrPx: have you checked out cabal install -j? I have 8 cores installing libs for me
13:50:57 <SrPx> sm: node.js makes a copy of every single dependency of a library using the version that library used initially. At cost of a few mbs that nobody ever care, it NEVER breaks.
13:50:58 <napping> SrPx: still churning throught dependencies, but I guess it at least picked a consistent set
13:51:17 <dmj`> SrPx: what are you trying to do w/ Haskell?
13:51:20 <monochrom> don't get me wrong. I have my beef against cabal too. it should default to disallow multiple versions. that solves all problems. but the cabal devs ignore this simple solution and go out of their ways to sandbox.
13:51:25 <napping> SrPx: Yeah, that's more or less what building packages in sandboxes does. GHC has some extra trouble becaused things need to compile
13:51:38 <roconnor> monochrom: is cross-module inlining why traditional cabal doesn't work?
13:51:47 <SrPx> napping: GHCJS instructions talk about getting a GHCJS version of cabal running. I can't even get that. I follow the instructions and there is no GHCJS listed in "cabal install --help" as it should. And there is nobody to help.
13:52:08 <napping> roconnor: Even without cross-module inlining, just using and rexporting a type from a dependency could expose upstream stuff
13:52:11 <monochrom> however, compiled libs with heavy inlining must face more challenges than interpreted libs. clearly.
13:52:37 <SrPx> dmj`: since months already, trying to use GHCJS to create something as simple as a Hello World site. If I just managed to create a Hello World site using Haskell I'd consider myself happy.
13:53:15 <dmj`> SrPx: GHCJS wasn't supported until 7.8 right?
13:53:17 <napping> SrPx: Using GHCJS once you've installed it is a different question
13:53:28 <napping> That's up to however that tool works
13:53:37 <dmj`> SrPx: what about elm and fay?
13:55:18 <monochrom> roconnor: cross-module inlining, hell cross-package inlining, is why you cannot just swap out one version and swap in another. that is the fundamental axiom. from that, you have several choices and each comes with a complication.
13:55:45 <nanomad> monochrom: I think that the ABI hash issues clearly shows that there are things to be solved far beyond package management
13:55:56 <SrPx> dmj`: elm -> now I have to re-create the same application in 2 different languages. Seriously all I wanted is to create graphical apps in Haskell and easily import them to web/android/ios. That is something even toyish languages around the world have no problems in doing already
13:56:15 <vamega> Hi, when using attoparsec I'm seeing the error
13:56:16 <napping> SrPx: cross-compiling from those languages to JavaScript with an experimental compiler?
13:56:28 <vamega> "Failed reading: takeWith"
13:56:32 <nanomad> monochrom: an ABI shouldn't depend on the optimization level. ever.
13:56:37 <sm> SrPx: you don't want much do you :)
13:56:41 <vamega> What does that mean?
13:56:50 <monochrom> yes absolutely. like I said, I have my beef too, but it is simply not about the false dichotomy of "has / has not package manager". no existing package manager on the world has solved this. except nix.
13:57:00 <SrPx> What are you guys even doing with Haskell? Is nobody here actually trying to create graphical Apps, front-end stuff? Is everyone just coding servers and doing AI research?
13:57:06 <bennofs> monochrom: but reexports also cause problems, no? You'd get weird clashes if lens reexported Set from containers-0.2 while my app uses containers-0.1
13:57:14 <roconnor> SrPx: hledger
13:57:22 <napping> SrPx: It's a lot easier if you actually compile Haskell, rather than trying to cross-compile to JavaScript
13:57:22 <roconnor> is what I do.
13:57:25 <John_Ripper> I am learning for fun
13:57:52 <sm> SrPx: few people are making GUI apps with haskell yet. Easy GUI apps requires massive (ie, corporate) investment in frameworks
13:58:05 <ilmig> SrPx: GUIs are indeed rarely done with Haskell at the moment...
13:58:13 <jle`> SrPx: well i've been working on a game, so i'll update you
13:58:16 <dmj`> SrPx: I'm building a website w/ snap, acid-state, aws, hs-stripe, io-streams
13:58:25 <ilmig> SrPx: in production I think it's mostly used for backend code...
13:58:28 <SrPx> dmj`: the backend of that site, you mean
13:58:45 <jle`> i do do some front-end stuff with Faye
13:58:49 <jle`> do do
13:58:50 <dmj`> SrPx: yes acid-state for backend
13:58:52 <jle`> english is so silly
13:59:00 <SrPx> ):
13:59:30 <sm> also, people who do need GUIs are mostly doing them as web apps
13:59:32 <BeardedCoder> vamega: I'm not sure, but my recent experience debugging Atto parsers was to test each by hand. I still had issues when I combined them, so I commented them one by one and stubbed(faked) the return until I found the issue.
13:59:36 <jle`> um. i do computational/data science research by trade but that probably isn't what you are asking for
14:00:03 <bennofs> monochrom: even nix hasn't solved it. Haskell in nix is basically just a hardcoded list of known-to-work-together versions of packages
14:00:05 <SrPx> sm: that is the problem!
14:00:12 <SrPx> anyway that is not the point
14:00:12 <monochrom> bennofs: at present, ghc distinguishes containers-0.1.Set from containers-0.2.Set. you get a type error at build time, but at least no inconsistency at run time (because you don't even get a run time).
14:00:26 <napping> SrPx: what other languages do you use for client-side javascript?
14:01:10 <SrPx> GUI apart, the fact we don't have a damn package manager that works is alarming. The community is so big, this is the most used pure FP language in the world... yet we present that depredating state in so important things
14:01:12 <bennofs> monochrom: ok, I get a type error, but it's annoying, especially when you add type class instances to that.
14:01:41 <napping> SrPx: do you mean GHCJS doesn't have a working package manager?
14:01:57 <SrPx> napping: ghcjs?
14:02:21 <napping> It sounds like you haven't actually tried to write anything in Haskell compiled as native code
14:02:39 <luite> GHCJS just uses Cabal/cabal-install, but since it's not bne merged upstream it neds to be installed from a different location
14:02:42 <dmj`> SrPx: are you comfortable w/ JS? A lot of the JS -> X people think they're exempt from learning JS, but have fun debugging the generated js output
14:03:08 <bennofs> monochrom: or another example. lens provides an instance for C from containers-0.1. Now my package depends on containers-0.2. Does that mean I cannot use that instance?
14:03:14 <jophish> Error deprecated, use Except instead. What's all this about!
14:03:42 <bennofs> jophish: ?
14:03:52 <bennofs> jophish: is that a question?
14:04:01 <monochrom> sounds like it's about deprecation. do you know deprecation?
14:04:16 <jophish> bennofs: I was a little surprised, and interested in the reason
14:04:19 <SrPx> dmj`: I am absolutely comfortable with JS, it is probably the language I am more familiar with. And I know it sucks
14:04:21 <jle`> economy's not so good these days
14:04:24 <jophish> I presume that it's just a name change
14:04:31 <jophish> monochrom: yes :)
14:05:20 <roconnor> monochrom: in The Pidgeon Drop, why does recompiling moneyholder-1.1 delete the old moneyholder-1.1?
14:05:22 <bennofs> @msg lambdabot :t (>>=) `asAppliedTo` (undefined :: ErrorT e m c)
14:05:23 <lambdabot> Not enough privileges
14:05:24 <raulfpl> when you say a data has a constructor of type "stateUser :: !u" what does the '!' means?
14:05:24 <jle`> SrPx: i think one of the more exciting things about haskell is being able to be a part of building this infrastructure you are talking about :)
14:05:44 <bennofs> jophish: the error monad uses an Error constraint on e
14:05:47 <dmj`> SrPx: yea you can roll your own, that's what's awesome about haskell.
14:05:58 <bennofs> jophish: exceptT doesn't require that
14:06:08 <SrPx> \:
14:06:09 <jophish> ah I see
14:06:16 <monochrom> I don't know what kind of "why" you're looking for. but old cabal-install did it. it's a file replacement.
14:06:37 <SrPx> jle`: dmj` I understand your point, that is true.
14:07:02 <SrPx> shouldn't we have just started with a package manager that works, though? lol
14:07:13 <roconnor> monochrom: >.<
14:07:18 <n-dolio> We have one that works.
14:07:24 <n-dolio> It's just not working for you.
14:07:28 <bennofs> SrPx: it's just not easy
14:07:48 <monochrom> I am not an author of cabal. I don't know why its authors made all kinds of decisions. I can only tell you the consequences and maybe how to fight it, OK? I am not the author of cabal.
14:07:58 <newsham> raulfpl: http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration
14:08:03 <quchen> raulfpl: It's a strictness annotation. It basically says that the "u" will always be stored in WHNF ("evaluated enough so it is distinguishable from non-termination"), instead of an arbitrary thunk.
14:08:07 <dmj`> SrPx: leaving haskell because of cabal is throwing the baby out w/ the bathwater
14:08:50 <monochrom> well, GHC has a hand in this too. if you have N databases, then you can only have N instances of whatever-1.1, one for each database.
14:08:50 <napping> SrPx: You haven't explained what trouble you've had building things with cabal - the instructions I gave you worked for compiling ghcjs here
14:08:56 <newsham> dmj: the baby's head is spinning around and its vommitting green pea soup
14:08:58 <SrPx> dmj`: even when you are almost half a year trying to install a single library?
14:09:00 <acowley> I think the principle is actually sort of understandable, but I don't think cabal / ghc-pkg are that bad
14:09:13 <monochrom> why did the GHC people do this? I don't know. ask SPJ perhaps?
14:09:23 <jophish> Hmm, Except is in transformers, but I was using Error (and some other stuff) from mtl
14:09:29 <SrPx> napping: pardon? what instructions exactly?
14:09:29 <EvanR> haahaha'
14:09:51 <napping> SrPx: "cabal sandbox init; cabal install" in a fresh checkout of ghcjs
14:10:09 <bennofs> jophish: mtl reexports parts of transformers
14:10:12 <dmj`> SrPx: In half a year you could have built your own HS -> JS compiler , or just used JMacro or Fay
14:10:14 <monochrom> why did the Haskell committee make Haskell non-strict? I don't know. can't say I dislike it, but I don't know why they did it. I am the wrong person to ask, OK?
14:10:21 <SrPx> napping: a second
14:10:27 <jophish> bennofs: not Except as far as I can tell
14:10:40 <newsham> i thought non-strict was the raison d'etre of haskell
14:10:43 <newsham> (and miranda)
14:10:46 <napping> monochrom: You can pass a list of package databases as command line options, so maybe something can be done with that
14:11:06 <jle`> SrPx: imagine being around to design bundler, or jquery :)
14:11:07 * hackagebot AES 0.2.9 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/AES-0.2.9 (SveinOveAas)
14:11:09 * hackagebot hsexif 0.4.0.1 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.4.0.1 (EmmanuelTouzery)
14:11:15 <SrPx> dmj`: exactly
14:11:31 <acowley> jophish: That's new, right?
14:11:34 <monochrom> well yeah, like I said, I'm glad they chose it. but if you ask me, not them, "why", is it like I can honestly tell you "they did it because I directed them to"? really?
14:11:36 <napping> Which is to say that some package manager might be able to build a nix-style thing with a wrapper around a stock GHC
14:11:42 <jophish> acowley: it seems that way
14:11:43 <roconnor> the fact that you can have only one version of a versioned package per cabal database appears to be a key difference between Cabal and Nix.
14:12:09 <napping> roconnor: what's this about a cabal database? I thought monochrom said a GHC package databased
14:12:12 <bitemyapp> roconnor: I would really like that to be fixed.
14:12:16 <napping> (may be true for Cabal, of course)
14:12:21 <bennofs> napping: as I said, even nix cannot solve the problem that you can only have one version of each package in your dependency tree
14:12:22 <bitemyapp> napping: Cabal is just ghc-pkg
14:12:24 <nanomad> monochrom: I'm asking you because you seem to be most knowledgable...but why doesn't haskell depend purely on major.minor.bugfix for deps resolution ?
14:12:24 <SrPx> napping: "cabal sandbox init" when inside the ghcjs repo makes a sandbox just for it?
14:12:36 <napping> SrPx: yeah, that's the point of it
14:12:38 <monochrom> in this context, cabal is just a vassal of ghc :)
14:12:41 <acowley> Hm
14:12:43 <bitemyapp> bennofs: I don't want multiple package versions in a single build, I want multi-versions in the package db for *caching*
14:12:46 <acowley> So what's new with ExceptT over ErrorT?
14:12:48 <SrPx> napping: yea just confirming
14:12:49 <pmade> SrPx: I'm coming into this late but from what I understand Haste is much further down the road than GHCJS: http://haste-lang.org/
14:13:00 <roconnor> napping: maybe I got my terminology wrong.
14:13:02 <jophish> aah, I can import mtl and transformers. I thought that would be a problem
14:13:30 <roconnor> napping: the distinction between Cabal and GHC is too fine for me to comprehend at my current level of understanding.
14:13:37 <acowley> Oh, so mtl may need updating if ExceptT is supposed to be the new ErrorT
14:13:43 <bitemyapp> acowley: http://osdir.com/ml/libraries@haskell.org/2013-08/msg00093.html
14:13:49 <newsham> does Haste run on 64-bit x86 machines yet?
14:13:49 <bennofs> bitemyapp: ok, nix can do that :) but as soon as any dependency changes, you'll have to rebuilt all depending packages :| and I found that it happens quite often that the version of some basic package like text or attoparsec changes
14:13:59 <thoughtpolice> roconnor: there is work to begin moving towards this, but it's a fairly invasive change
14:14:03 <napping> roconnor: Well, Cabal might very well maintain it's own database of some kind. But, ghc itself can be pointed at a bunch of package database files. If you do something like having a separate GHC package databse for each package, and some kind of super-cabal to compute the right set of them to pass to GHC, you could probably get multiple versions cached on disk
14:14:11 <bitemyapp> bennofs: I just want to stop having to manually create sandbox caches that I add-source to avoid rebuilds of existing packages.
14:14:19 <bitemyapp> bennofs: I'm doing manually what Cabal should do for me.
14:14:30 <bitemyapp> bennofs: it should be shuffling symlinks in and out of the sandboxes.
14:14:36 <SrPx> pmade: yes I managed to install haste once but now with ghc 7.8 it won't install too.... no idea what to do about the error. It is just frustrating. Really really frustrating
14:14:39 <monochrom> nanomad: actually, if you use hugs, version numbers are all you need.
14:14:40 <napping> bennofs: How do you think you can avoid rebuilding dependant packages when you change something they depend on?
14:14:40 <roconnor> thoughtpolice: nix has a lot of advantage in being able to pick out particular sub-versions of versioned packages.  It does seem to be a difficult problem for Cabal.
14:15:00 <napping> SrPx: telling people the actual error helps
14:15:06 <thoughtpolice> bennofs: that's right, we want Cabal's solver still (because Nix shuffles dependency resolution off to maintainers), but we want multiple instances of a given package
14:15:19 <pmade> SrPx: 7.8 is still really, really new and package authors are still catching up.  If you need something stable you should still be on 7.6.3.
14:15:48 <SrPx> pmade: oh ok... I guess I should go back to 7.6.3, install haste and give up of ghcjs once per all :(
14:15:53 <thoughtpolice> roconnor: there was a GSoC attempt at it. it seems to have informed us as to what we actually need to do, but yeah, it's a big project
14:15:54 <luite> GHCJS depends on 7.8 though
14:16:06 <nanomad> monochrom: and that would solve the "dependency hell", does it? once you enforce that .bugfix are interchangable, .minor only add functionality to the interface and major are breaking or stuff like that
14:16:09 <napping> SrPx: experimental cross-compilers are not the right place to start with any language
14:16:12 <monochrom> is there an old GHCJS for 7.6?
14:16:13 <bennofs> thoughtpolice: but each package only has one instance for a given build? Just multiple instances to allow sharing between projects/builds?
14:16:44 <monochrom> hugs solves dependency hell, yes.
14:17:01 <monochrom> fast, good, cheap: pick two.
14:17:03 <nanomad> monochrom: then I'm puzzled on why haskell/cabal isn't following the same route
14:17:15 <monochrom> do you mean ghc/cabal?
14:17:20 <nanomad> sorry yes
14:17:36 <luite> monochrom: not really a working one, i've been doing the new code generator on 7.8 since about a year ago, since 7.6 was lacking in cross compilation features that ghcjs needed
14:17:38 <monochrom> then because ghc is an aggressively optimization compiler. hugs is an interpreter
14:18:09 <monochrom> s/ation/ing/
14:18:26 <thoughtpolice> bennofs: right, something like that. GHC and Cabal track dependencies/recompilation a bit differently than Nix as it stands. in all honesty, I am not privvy on the actual design. but some of the ground work is being laid
14:18:33 <nanomad> monochrom: I don't get it..no matter the optimization package 1.2.3 is always 1.2.3 (the interface shouldn't change....oh hold on a sec .. )
14:18:35 <acowley> bitemyapp: That doesn't directly explain the deprecation of ErrorT to be replaced by ExceptT, but it's probably not an interesting story :/
14:18:37 * thoughtpolice thinks there's some page describing the GSoC work
14:18:57 <monochrom> have you read my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash ? seriously?
14:19:02 <nanomad> yeah nvm
14:19:07 <nanomad> I'm going thorugh it again
14:19:13 <bitemyapp> acowley: sorry it wasn't as directly topical but I liked Gabriel's thoughts.
14:19:21 <thoughtpolice> the first is that we need to decouble ghc from Cabal a bit more, which will be nice by itself.
14:19:26 <thoughtpolice> *decouple
14:19:38 <SrPx> napping: there is no way in the world today to use a pure functional language to program games and uis that will be exportable to android/ios/js
14:19:43 <SrPx> nanomad: \:
14:19:51 <davidthomas> monochrom: I get *two*?
14:19:53 <acowley> bitemyapp: Yeah, I agree with him on that. It's tempting to massively overload Maybe and Either to stand in for every isomorphic type
14:19:57 <lfairy> nanomad: optimization enables inlining, which exposes implementation details
14:22:29 <monochrom> parsec-3.1.3 binary code may very well contain text-1.1.0.1 binary code, for example. why? because speed. idiomatic haskell, and indeed the style of haskell written in parsec and text, are at such abstract level that non-inlining would be too slow.
14:22:59 <monochrom> the ideal of "ABI must not change under such and such minor internal change" is impractical for speedy haskell.
14:23:04 <napping> nanomad: It's not so much about the interface changing (though method bodies included in .hi files to support inlining might very well changes), but that the compiled binary code changes
14:23:14 <monochrom> fast, good, cheap: pick two.
14:23:45 <monochrom> (well, since you have paid $0 for ghc, you have pretty much chosen "cheap". so: fast, good: pick one)
14:24:05 <newsham> mono: if i give you money will i get fast and good?
14:24:07 <monochrom> perhaps s/good/robust/
14:24:28 <monochrom> yes, but it has to be a lot of money.
14:25:16 <d3lxa> monochrom: is this a new conjuncture? :P
14:25:36 <monochrom> you're making me look up "conjuncture"!
14:25:39 <nanomad> monochrom: then if you can't have a stable ABI ... how can you have package management ?
14:25:54 <newsham> so you're saying I only get two of (reasonable-price, fast, good)
14:25:58 <nanomad> (stable is not the correct word)
14:26:40 <Sonarpulse> anybody know of library that does tests really nice, one that I can shamelessly copy the testing framework from?
14:26:48 <monochrom> oh the ghc+cabal conjuncture has been around for a decade :)
14:26:55 <d3lxa> monochrom: *conjecture sorry
14:27:03 <monochrom> what did I conjecture?
14:27:06 <d3lxa> or conjuncture, i dont know
14:27:25 <ZonJanzon> Hi guys, suppose f :: Integer -> Integer -> Integer, then I write "t1 <- forkIO $ do let r = f 1000; putMVar m r", is there any way to force evaluation of r before storing it in m?
14:27:34 <d3lxa> monochrom: "fast, good, cheap: pick two." << this
14:27:34 <monochrom> anyway, damn those rarely used English words that only appear in TOEFL
14:27:41 <d3lxa> it's like the CAP theorem
14:28:07 <monochrom> oh, this one I learned from someone else. he considers it a rule of thumb.
14:28:13 <ZonJanzon> how do you achieve good & cheap? regardless of time, good doesn't come easy
14:28:36 <peddie> Sonarpulse: I followed https://github.com/kazu-yamamoto/unit-test-example/blob/master/markdown/en/tutorial.md and like it; not sure whether there's a corresponding example outside that tutorial
14:28:41 <Maior> ZonJanzon: that's why it takes time
14:28:49 <newsham> zon: unoptimized high level languages :)
14:29:12 <EvanR> this implementation of Void is wrong right http://www.haskell.org/haskellwiki/Empty_type
14:29:15 <ZonJanzon> aha, i though delivery-time, has been a manager for too long :/
14:29:19 <monochrom> ever heard of "wait for 40 monkeys to eventually type out the complete GHC source code"? :)
14:29:27 <EvanR> newtype Void = Void Void has a non bottom value, fix Void ?
14:29:50 <bennofs> EvanR: how is that non-bottom?
14:29:55 <bennofs> EvanR: remember, it's a newtype
14:30:02 <EvanR> Void (fix Void), then
14:30:08 <Sonarpulse> thanks peddie
14:30:23 <bennofs> @let newtype Void = Void Void+
14:30:23 <prophile> Void (fix Void) == fix Void I suspect
14:30:23 <lambdabot>  Parse failed: Parse error: +
14:30:25 <EvanR> oh, newtype is not lazy
14:30:30 <bennofs> yes
14:30:32 <thoughtpolice> napping: how would a stable ABI help? in the case of recompilation, assuming the binary ABI was stable, a change may result in different code being generated in both the object file and interface file as you noted - dependent packages would *still* need to be recompiled, because the method might do something totally different
14:30:34 <EvanR> nice
14:31:16 <EvanR> still this text says "its the same as id"
14:31:21 <napping> thoughtpolice: well, I wasn't particularly saying a stable ABI would help - but if a dependent package calls the same method, and doesn't want to inline any code from upstream
14:31:53 <napping> thoughtpolice: then any different behavior comes from the function being calls, but the code still wants to make the same calls, so you could potentially re-use the binary from the downstream package, if the upstream one is ABI-compatible
14:32:05 <peddie> Sonarpulse: also note that the doctest-prop and haddock allow you to write QuickCheck properties in your haddock docs and test them; use prop> markdown instead of >>>
14:32:18 <napping> thoughtpolice: In other words, if the ABI doesn't change, than how is recompiling different from relinking?
14:32:47 <napping> "ABI" referreing to something like exact contents of all .hi files, I suppose
14:32:50 <roconnor> thoughtpolice: I'm a little surprised that cabal doesn't recompile everything that depends on foo-1.1.1 when foo-1.1.1 is recompiled.
14:33:24 <Sonarpulse> oh sick
14:33:24 <roconnor> thoughtpolice: maybe the source code is already gone?
14:33:28 <Sonarpulse> thanks a lot peddie
14:33:31 <Sonarpulse> that guide is really good
14:33:34 <monochrom> last year or two years ago, there was a GSoC project on automatic detection and rebuild of the packages higher up in the food chain when you swap out something lower in the food chain. it also does nix-like fine tracking. however, it did not take off.
14:34:09 <thoughtpolice> napping: if you completely throw away inlining, then sure, you get this guarantee. but it fails the moment anything dependent on something inlined is changed.
14:34:39 <napping> thoughtpolice: definitions exposed for inlining have to be considered part of the visible binary interface of a compiled package
14:35:02 <nanomad> roconnor: afaik that's how gentoo handles it ... and I guess gentoo is closest thing we have to ghc in the *nix world
14:35:11 <monochrom> suppose you inline and still *.hi doesn't change. then you're very lucky. :)  but yes then there is no worry.
14:35:26 <PipBoy> Hello!
14:35:54 <napping> Well, for something from a downstream package to show up in your .hi, you need a definition that's still small enough after inilining a thing from upstream to be exported itself
14:36:07 <roconnor> nanomad: nix is similar to gentoo, speaking loosely
14:36:19 <roconnor> nanomad: at least that is my understanding having never used gentoo.
14:36:30 <napping> So I'm not sure if compiling a package against different versions of the upstream packages tends to change to .hi bodies or not
14:36:32 <roconnor> I think gentoo users would be fairly comfortable in nix.
14:36:50 <monochrom> you haven't factored in "fusion" :)
14:37:21 <napping> Yeah, thing that optimize nicely might still end up small, that why I don't have a guess without testing
14:37:53 <thoughtpolice> i'm confused, aren't we just going in circles? the point is that interfaces and the object files together are the ABI, you only get the benefit of a 'stable ABI' if you basically kill inlining (and everything that comes with it) and basically the need for the interfaces, and fix the binary ABI.
14:38:26 <thoughtpolice> either of those would probably be bad, both would be terrible. so you're just back to where we've already been (at least it seems that way to me.)
14:38:46 <napping> thoughtpolice: the only thing I specifically suggests was that some kind of tool could maintain a separate package database file for every build of every version of every package, and splice them together on the ghc commandline
14:38:57 <monochrom> the thing is, if you just look at the source code sans {-# RULES #-}, the code looks too big to be inlined. but the {-# RULES #-} express such fusion that much source code is thrown away altogether, you end up getting things small enough for inlining.
14:38:57 <bennofs> napping: g
14:39:03 <newsham> i'm listening to a podcast now thats talking about the Backpack module system for haskell.. where they use interface specs
14:39:05 <bennofs> napping: that tool is called nix :P
14:39:09 <newsham> sounds similar to what you guys are chatting about
14:39:25 <newsham> http://plv.mpi-sws.org/backpack/
14:39:33 <nanomad> the thing is, why would one recompile *the same* version of a dependency? once it's built and avaible you should just use the binary version. If you really have to ... the only solution is to rebuild every dependant package too
14:39:47 <monochrom> "from lists to streams to nothing" is literally true, even for code size :)
14:39:47 <napping> thoughtpolice: and that basically just so a bunch of sandboxes don't need to compile anything that's ever been compiled *exactly* that way before
14:40:11 <napping> nanomad: you'd hope you could re-use a suitable binary
14:40:27 <napping> nanomad: the probably is that you can have two incompatible binaries from compiling foo-1.1 against different versions of it's own dependencies
14:40:48 <napping> nanomad: Still not so bad if you can just cache both of them and use the right one in different projects that need different versions of the upstream
14:40:48 <nanomad> napping: how can that happen?
14:40:55 * bennofs wonders how often it happens that you compile libraries against *exactly* the same versions of all transitive dependencies
14:41:11 <napping> nanomad: The historical problem has been that ghc/cabal don't like caching multiple compiled versions of a package
14:41:11 <nanomad> actually forget my question napping
14:41:30 <napping> bennofs: well, how often do you have two packages that *force* you do use different versions of something upstream like text?
14:41:41 <acowley> Does anyone have any tips for debugging ghc-mod?
14:42:01 <acowley> I periodically have it crash, and have no idea what I can do at that point
14:42:04 <napping> Hopefully most packages are mostly consistent
14:42:10 <napping> acowley: maybe it's doing that for me too?
14:42:34 <monochrom> nanomad: here is one way it may happen today. you already have containers-0.4. then you see that containers-0.5 is out. you want it. you want it badly. now this has consequences for Cabal, parsec, aeson, everything.
14:43:16 <athan> Master of stupid questions here again: Do newtype declarations create a new type for the type system, while retaining the constructor terms used in the auxiliary type? ie: `newtype Foo a = [a]`, you could still use List pattern matching on functions that take a Foo as an argument?
14:43:35 <dwcook> athan, yeah but you need a constructor for Foo as well.
14:43:38 <nanomad> monochrom: Yeah
14:43:38 <napping> athan: you have to write Foo around the pattern to match
14:43:40 <dwcook> newtype Foo a = Foo [a]
14:43:50 <athan> ahh! Okay, thank you!!
14:43:56 <dwcook> Then you can pattern match: unFoo (Foo xs) = xs
14:44:05 <newsham> you can still pattern match on the list inside:   (Foo (x:xs))
14:44:10 <nanomad> monochrom: in that case you'd have to rebuild every single pacakge depeding on containers against the 0.5 version
14:44:14 <napping> athan: but it's implemented as something like a synonym in the type system, so you don't actually pay for constructing/matching the Foo constructor at runtime
14:44:32 <nanomad> monochrom: and so on, transitively
14:44:47 <athan> That's everything I needed :) you guys rock!!
14:44:55 <athan> napping: Ahh! That's wonderful, perfect
14:45:34 <defanor> acowley: strace/gdb might help there, i think, especially if it crashes because of some IO issue/exception
14:46:03 <acowley> defanor: But then I have to be running ghc-modi under the debugger all along, right?
14:46:08 <acowley> defanor: I was hoping there was a log file somewhere
14:46:24 <roconnor> nanomad: that involves recompiling GHC as well, right?
14:46:32 <monochrom> hehe
14:46:35 <athan> Can you make partially applied types instances of type classes?
14:46:42 <jfischoff> acowley: you can attach. strace is probably the way to go. Watch it be interface files
14:46:44 <dwcook> athan, if they're the right kind, sure.
14:46:46 <acowley> It's a very irregular occurrence
14:46:50 <defanor> acowley: yep. i'm not aware of any logs, but debugger could produce one :)
14:46:52 <nanomad> roconnor: eventually :P
14:46:54 <athan> dwcook: Muahahahaha... perrrrrrfect :P
14:46:58 <dwcook> athan, for example, Monad takes types :: * -> *.
14:47:01 <napping> athan: for example, instance Monad (State s)
14:47:04 <acowley> Okay, I'll see if I come across another file that kills it regularly
14:47:10 <monochrom> containers is an extreme example. template-haskell depends on containers. but ghc doesn't want you to rebuild template-haskell. well, you can, but it will eventually want to use the original one
14:47:15 <athan> great minds haha
14:47:20 <dwcook> Either a is a valid instance of Monad
14:47:24 <acowley> I complain about bugs and missing features after I've worked around them too often
14:47:32 <athan> dwcook: Precisely what my inclination was
14:47:32 <athan> hmm
14:47:36 <athan> awesome, thank you!
14:48:26 <vamega> Hi.
14:48:31 <vamega> I have two Maps
14:48:48 <vamega> from String -> {Int, Int}
14:49:11 <vamega> Or Rather with the type Map String {Int, Int}
14:49:21 <c_wraith> You mean (Int, Int)?
14:49:36 <vamega> No a data type
14:49:48 <vamega> data HistData = HistData {
14:49:49 <vamega>   instances :: Integer,
14:49:49 <vamega>   bytes :: Integer
14:49:49 <vamega>   }
14:49:49 <dmj`> what is the name of the type of your datatype
14:49:54 <vamega> HistData
14:50:19 <monochrom> ok, so it's "Map String HistData"
14:50:22 <c_wraith> vamega: even if you mean to help, posting syntactically invalid things is misleading at best, and plain old lying at worst.
14:50:33 <roconnor> how big is the list of packages that GHC "won't let you upgrade"?
14:50:42 <vamega> c_wraith, will keep that in mind.
14:50:54 <vamega> I didn't realize that {Int, Int wasn't correct}
14:50:54 <roconnor> let's say direct "won't let you update" rather than indirect.
14:51:03 <newsham> (fwiw, your record is very similar to (Int,Int) tuple)
14:51:30 <c_wraith> Depending on the question, the difference between Int and Integer might matter.  But..  What's the real question?
14:51:31 <glguy> vamega: If you'd just have typed out the whole question before pressing enter people might be focused on that instead of picking apart your notation :)
14:51:40 <vamega> So I have a Map with type Map ByteString HistData
14:51:54 <monochrom> roconnor: seems to me about a dozen packages.
14:52:02 <vamega> glguy, alright I guess I'll do that.
14:52:15 <vamega> Thinking about it seems like something StackOverflow might be good for.
14:52:29 <roconnor> monochrom: is it easy to find the list?
14:52:31 <newsham> vamega: or you can ust lpaste (see /topic)
14:52:36 <c_wraith> vamega: Eh.  This place is great for answering questions that are actually *asked*.
14:52:40 <newsham> s/ust/use/
14:53:19 <monochrom> oh, I just entered "ghc-pkg list" on a pretty clean ghc, then eyeballed it and used my experience to decide who are the ones
14:53:31 <dmj`> > Data.Map.mapKeys show (Data.Map.fromList [(1 :: Int,2 :: Int),(2,3)])
14:53:33 <lambdabot>  Not in scope: ‘Data.Map.mapKeys’Not in scope: ‘Data.Map.fromList’
14:53:34 <roconnor> monochrom: ty
14:53:45 <acowley> roconnor: Yeah, you ask monochrom
14:53:52 <roconnor> >.<
14:54:11 <glguy> dmj`: I think lambdabot has that module imported as M or Map
14:54:22 <glguy> > Map.fromList [((),())]
14:54:23 <lambdabot>  Not in scope: ‘Map.fromList’
14:54:23 <lambdabot>  Perhaps you meant one of these:
14:54:23 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
14:54:23 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
14:54:23 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
14:54:26 <glguy> > M.fromList [((),())]
14:54:28 <lambdabot>  fromList [((),())]
14:54:42 <monochrom> when you start "ghci", you already see 3: ghc-prim, integer-gmp, base. And then, find out ghc (the GHC API) depends on whom, find out template-haskell depends on whom. that should be more or less it.
14:54:52 <dmj`> > M.mapKeys show (M.fromList [(1 :: Int,2 :: Int),(2,3)])
14:54:53 <lambdabot>  fromList [("1",2),("2",3)]
14:54:57 <dmj`> glguy: thx
14:55:21 <dmj`> I'm assuming his question is how do I change my keys from ByteString -> String
14:55:46 <monochrom> haha
14:56:12 <dmj`> > M.mapKeys B8.unpack (M.fromList [("a" :: ByteString,"b" :: ByteString)])
14:56:13 <lambdabot>  Not in scope: ‘B8.unpack’
14:56:14 <lambdabot>  Perhaps you meant one of these:
14:56:14 <lambdabot>    ‘BS.unpack’ (imported from Data.ByteString),
14:56:14 <lambdabot>    ‘BSL.unpack’ (imported from Data.ByteString.Lazy),
14:56:14 <lambdabot>    ‘BSC.unpack’ (imported from Data.ByteString.Char8)Not in scope: type const...
14:56:18 <dmj`> meh
14:56:34 <monochrom> perhaps BSC is the one
14:57:02 <newsham> wish you woulda let him finish his question :(
14:57:08 <glguy> I suppose that guessing what the actual question is isn't to far from the norm for this channel :)
14:57:38 <jophish> Iceland_jack: I'm having some trouble compiling that example. Which extensions should I be using, I have PatternSynonyms and ViewPatterns
14:57:48 <monochrom> well, I agree about the "the enter key is used as punctuation" problem
14:59:48 * roconnor agrees with newsham
15:00:00 <c_wraith> He could have finished asking his question at any time
15:00:06 <c_wraith> He chose not to.
15:00:07 <roconnor> maybe reddit is right about this channel being less friendly.
15:00:43 <roconnor> c_wraith: I kinda feel that you were coming off a bit harsh, even if that wasn't your intent.
15:00:54 <glguy> I intended to encourage him to just write the question before he got cut off again, not to shut him down
15:01:01 <Nik05> this channel "less" friendly?
15:01:21 <newsham> mind you this channel used to be super awesome friendly
15:01:56 <dwcook> It still is friendly compared to other channels I've seen
15:02:00 <newsham> (cale, dons, sigfpe, conal, augustss, etc..) answer lots of stupid questions by me and many others without skipping a beat.
15:02:15 <newsham> i need to work off my debt :)
15:02:23 <Kaidelong> sad, after cabal install --global cabal-install, cabal --version still reports 1.16 instead of 1.20
15:02:24 <monochrom> but did you press enter like you're using twitter?
15:02:30 <c_wraith> roconnor: I guess I have lost patience with people communicating especially badly.
15:02:34 <roconnor> it's better to let the newbies slowly ask their question, answer it, and then tell them about how to ask more effectively.
15:02:37 <[swift]> yeah, i still think this channel is pretty friendly as compared to other programming channels on freenode
15:02:55 <roconnor> no everyone has been on IRC forever.
15:02:56 <joelteon> we should invite zhivago here
15:03:03 <Kaidelong> I really need to figure out why this is happening, my %PATH% should already have fixed it by making the local cabal version shadow the global one
15:03:18 <lahwran> [swift]: channels often think that about themselves
15:03:23 <AlephBeth> i read "trolling #haskell" recently - made me smile
15:03:29 <Maior> that's not a high bar (and I mean that as no slight to #haskell)
15:03:36 <lahwran> [swift]: the #python regulars think it's friendly there
15:03:51 <newsham> kade: check out each dir in your path to see which one has the old and which one the new bin?
15:03:55 <merijn> AlephBeth: I've since changed my mind and decided that is not a particularly good way to deal with things
15:04:05 <[swift]> lahwran: heh, i probably don't have perspective now. i can tell you that when i first started programming in haskell i felt much more welcmoed by #haskell than i did by #python when i first started learning that lagnuage
15:04:21 <napping> lahwran: the one complaining on reddit also things #python is helpful
15:04:26 <newsham> lets not use #python as the bar ;-)
15:04:39 <athan> So.... why don't we call them phantom type _variables_, but also show how to use _dummy_ types (as like the dual to that idea?) in the same regard?
15:04:44 <[swift]> newsham: thoroughly agreed
15:04:46 <monochrom> I agree that "we're better than other channels" is not good enough
15:04:48 <lahwran> napping: #python is often hated on r/python; perhaps someone on r/python who hates #python would love #haskell...
15:04:50 <benzrf> [swift]: #haskell is the single most helpful irc channel i have ever been to
15:04:52 <acowley> Why would someone be in a channel they think is unfriendly?
15:04:59 <merijn> Personally I've noticed that while I still don't mind giving in-depth explanations to newbies, questions of the sort "I don't understand X" followed by blatant ignoring of "you should read A, B and C on X" and asking more questions have started to grate on my patience
15:05:00 <acowley> Of course everyone thinks they're friendly
15:05:03 <benzrf> [swift]: #ruby #2 :)
15:05:11 <athan> benzrf: ditto
15:05:20 <roconnor> heh, I remember when I asked a question in #math a few years ago, and they told me they won't do my homework for me.
15:05:22 <[swift]> benzrf: i agree with both of those =)
15:05:26 <Kaidelong> apparently there is no Roaming\ghc\bin at all!
15:05:34 <lahwran> merijn: perhaps they could be extended to "you should read x, but if you find you don't understand it, feel free to ask about a specific thing"
15:05:34 <benzrf> least helpful: #ubuntu
15:05:38 <Kaidelong> I guess cabal is installing the local binaries some other place
15:05:40 <merijn> Although I don't think I'm personally capable of telling people this in a reasonably inoffensive manner, so I just don't respond to them anymore
15:05:42 <athan> acowley: For selfishness / blind faith xD
15:05:48 <benzrf> #python is fairly helpful but kinda unfriendly :(
15:05:53 <newsham> roconnor: we'll only do SOME of their homework here, ;-)
15:06:00 <Maior> merijn: it's been my experience in other channels that a well-maintained FAQ, and people giving gentle directions to it, has been significantly helpful
15:06:02 <monochrom> Kaidelong: is there also Roaming\cabal\bin ?
15:06:14 <skypers> hey, do you know whether freezing an IOVector allocate anything?
15:06:18 <Kaidelong> there is one
15:06:24 <Kaidelong> I'll put that on my path
15:06:36 <athan> merijn: I think a structure more set like, a collection of tutors than an open chat room might be more effective
15:06:37 <merijn> Once quchen's FAQ/mistake guide grows a bit larger it'll work as a decent link in the topic :p
15:06:50 <athan> doesn't mean we are all volunteers, but also frees up the room
15:06:58 <lahwran> perhaps we should take this conversation to #haskell-blah (real channel named "#haskell-blah", please join), because folks are asking non-meta questions
15:07:18 <acowley> skypers: Perhaps a little struct that includes the pointer
15:07:37 <skypers> acowley: ok
15:07:38 <skypers> thank you
15:07:49 <Kaidelong> oh, cabal\bin was what was on my path
15:07:54 <acowley> So, two Ints and the pointer
15:08:03 <Kaidelong> I was so hoping I was on to something
15:08:24 <Kaidelong> maybe I misunderstand how the windows %PATH% works and it's the last entry that shadows any previous ones?
15:08:50 <napping> Kaidelong: have you tried starting? I'm not sure what you need to do to get a modified PATH to take effect
15:08:52 <newsham> the win path is similar ot uni xpath
15:08:56 <napping> restarting, rather
15:09:20 <Kaidelong> I did, it seems all you have to do is restart any app that imported the path but I have rebooted because I was on lunch break
15:09:36 <glguy> vamega: I didn't want you to stop asking your question. I wanted you to keep asking it before someone sidetracked you again so we could see it. Sorry if I contributed to you feeling unwelcome.
15:10:06 <newsham> kaidelong: there's a "where" command you can use
15:10:09 <c_wraith> vamega: I really was just trying to understand your question better.  I guess I was probably a bit mean.
15:10:11 <Kaidelong> I do kind of feel like I am wasting my time and should just figure out how to get cabal-dev to actually work
15:10:31 <napping> Kaidelong: afraid I don't know much about windos - "updatedb" and "locate" are my usual tools on Linux for figuring out why I'm getting the wrong binary
15:10:44 <Kaidelong> c_wraith: the first result is in Roaming\cabal\bin
15:10:46 <Kaidelong> that's good!
15:11:18 <napping> Kaidelong: I can say the cabal sandbox support seems to work really nicely, and completely obsolete cabal-dev (but I think cabal-dev is okay too, just not as integrated)
15:11:36 <Kaidelong> what is not good is that I just checked and that version reports itself as 1.16!
15:11:50 <quchen> merijn: Glad to hear that :-)
15:11:58 <quchen> s/:-)/;-)/
15:12:00 <Kaidelong> I am pretty sure the version I built locally is cabal 1.20!
15:12:10 <newsham> kaidelong: you could use a tool like procmon to watch where "cabal install" is writing the new version
15:12:11 <Kaidelong> does cabal install not overwrite binaries if the existing one is there already?
15:12:20 <newsham> oh, btw, did the file date change?
15:12:32 <vamega> No sorry.
15:12:35 <vamega> My fault.
15:12:40 <newsham> oh, maybe cabal install cant overwrite itself in windows
15:12:45 <vamega> I got called away for my actual job :)
15:12:46 <napping> oh!
15:12:56 <jfischoff> haha
15:12:58 <napping> yeah, I think windows makes files being open more exclusive
15:13:00 <newsham> you cant usually overwrite a file thats being executed
15:13:03 <jophish> Can I get HLint to ignore an entire module?
15:13:10 <newsham> try copying cabal.exe to cabal2.exe and then doing the update?
15:13:13 <napping> Kaidelong: cabal certainly overwrites binaries on windows
15:13:15 <jfischoff> jophish: yesh
15:13:25 <merijn> quchen: I've changed my mind about the parsing loops I had, I decided they're wrong, the pipes-attoparsec ones are right (mines lack of StateT, but I'm adding that one) and my entire thinking was crooked :p
15:13:29 <vamega> Got to head home.
15:13:34 <Kaidelong> newsham: that might be it, cabal can't overwrite itself
15:13:36 <vamega> But will make an lpaste and ask it.
15:13:41 <jophish> hopefully with some kind of ANN
15:13:42 <Kaidelong> I will try that
15:13:43 <vamega> Or write it up on SO and post link here.
15:13:50 <vamega> You guys have been really helpful so far.
15:15:28 <merijn> quchen: On the flipside, I realised that I can change a pipe parser into "Producer a m r -> Producer b m r" and those trivially compose those, magicing my problems away in a puff of smoke:)
15:15:57 <quchen> Isn't "Producer -> Producer" what you had all along?
15:16:36 <quchen> In any case I'm afraid to go, but hold that thought/remark, I'd be interested in hearing about it
15:16:53 <quchen> +I have
15:16:56 <acowley> Don't be afraid
15:17:08 <acowley> Am I helping?
15:17:55 <c_wraith> acowley: depends.  Are you still doing computer vision and robot control in haskell?  If so, you're definitely helping. :)
15:18:07 <athan> Are there any instances of Ord that have elements possibly (a > b && a < b) where a =/= b?
15:18:25 <monochrom> I don't think I've seen one
15:18:29 <athan> maybe, negative & positive theoretical bounds on a number?
15:18:31 <acowley> I think quchen left, so I guess I helped
15:18:36 <c_wraith> athan: I hope not.
15:18:39 <hpc> > (1/0) > (1/0)
15:18:40 <lambdabot>  False
15:18:42 <athan> like negative and positive infinity?
15:18:42 <Kaidelong> newsham: \o/
15:18:44 <codygman-> Did my question get posted at 17:14? I got disconnected/reconnected
15:18:47 <Kaidelong> you are a winnar
15:18:47 <newsham> athan: Ord is supposed to be totally-ordered
15:18:48 <merijn> quchen: I had it all along, but I didn't realise how I wanted to compose those because I had "Pipe a b m r" too and didn't realise I could do "data Preprocessor a b = Parser (forall m r . Monad m => Producer a m r -> Producer b m r) | Pipe (forall m r . Monad m => Pipe a b m r)" and compose those (at least, I think that should work :p
15:18:49 <Kaidelong> thanks
15:18:51 <hpc> > (0/0) > (0/0)
15:18:52 <roconnor> athan: don't forget that Ord has compare
15:18:53 <lambdabot>  False
15:19:01 <Kaidelong> cabal.exe couldn't overwrite itself
15:19:03 <Kaidelong> of course
15:19:03 <hpc> > (0/0) `compare` (0/0)
15:19:03 <mmachenry> athan: It's possible to implement such a thing, I think.
15:19:04 <lambdabot>  GT
15:19:04 <newsham> kaide: woot
15:19:08 <athan> hpc: I see, thank you!
15:19:20 <hpc> athan: that's backwards, but it still breaks the laws
15:19:28 <newsham> kaide: they really should have at least reported an error when that happened.
15:19:35 <hpc> floats suck, but not in the very precise way you describe ;)
15:19:35 <acowley> Hm, Kaidelong's situations seems like something that should be posted clearly somewhere
15:19:39 <roconnor> hpc: I'm willing to let that slide since (0/0) isn't (==) to itself.
15:19:43 <newsham> prob worth a bug report
15:19:48 <monochrom> codygman-: I think it has not appeared
15:19:49 <athan> newsham: Ahhh, I see. Okay, but Eq is not a superclass of Ord, correct?
15:19:59 <roconnor> isn't it?
15:20:00 <monochrom> Eq is a superclass of Ord
15:20:05 <athan> oh!!!
15:20:06 <Kaidelong> how do I delete my old cabal-dev sandbox?
15:20:07 <athan> wow
15:20:08 <codygman-> monochrom: Thanks, I'll repost it.
15:20:10 <codygman-> This shows me how to reverse a csv stream:
15:20:10 <codygman-> https://github.com/ozataman/csv-conduit#example-1-basics-using-convenience-api
15:20:10 <codygman-> I know I can use CL.filter to filter things out of the stream but I don't know how to refer to the column I want to filter on.
15:20:11 <Kaidelong> cabal sandbox is griping about it
15:20:13 <athan> now I feel dumb :) Thank you!
15:20:18 <newsham> "The Ord class is used for totally ordered datatypes."
15:20:25 <newsham> "class Eq a => Ord a where"
15:20:31 <roconnor> Pord would be so nice.
15:20:33 <mmachenry> athan: You could technically implement a pathological instance for a new type but it's probably a very bad idea.
15:20:41 <athan> roconnor: :P
15:20:57 <athan> mmachenry: Yeah I'm not going there haha. Thank you though
15:21:00 <Kaidelong> also I'll report the bug, could someone link me? It's a bit hard to brouws webs on this thing
15:21:08 <Kaidelong> touch screen interacting with small links
15:21:12 <athan> newsham: Or really... totally comparable (makes more sense to me)
15:21:19 <jophish> :( pattern synonyms aren't in haskell-src-exts
15:21:26 <mmachenry> Come to think of it, why isn't compare the only method in the Ord? If it were, it'd be impossible to implement > and < yourself and break the total ordering invariant.
15:21:27 <athan> herm
15:21:30 <athan> nevermind
15:21:34 <athan> thank you!!!
15:21:46 <roconnor> mmachenry: you can just define compare and the others have defaults.
15:21:49 <roconnor> IIRC
15:21:54 <newsham> mmachenry: "Minimal complete definition: either compare or <=. Using compare can be more efficient for complex types."
15:21:59 <mmachenry> roconnor: Yes I know.
15:22:02 <glguy> mmachenry: someone could write compare _ _ = LT and still break things
15:22:17 <mmachenry> roconnor: But I also can implement < and > and cause a problem.
15:22:23 <newsham> mmachenry: the others are prob there for when you can make more efficient impls than the default?
15:22:26 <mmachenry> I suppose it has to do with efficiency.
15:22:31 <roconnor> mmachenry: I'm not sure there is logical sense in which methods are included in a class and which ones are not.
15:22:33 <mmachenry> Yeah
15:22:45 <roconnor> mmachenry: if there is logic behind it, I don't know what it is.
15:22:49 <Kaidelong> hmm, how do I search for a bug in the github bug tracker?
15:23:38 <acowley> You type into the search box?
15:23:48 <newsham> the Data.Ord docs are most enlightening :)
15:24:10 <Kaidelong> https://github.com/haskell/cabal/issues/284 it's a known bug
15:24:13 <Kaidelong> looks like wontfix
15:24:32 <Kaidelong> but it should really at least report this and alert the user that they have to fix manually
15:24:54 <monochrom> interesting
15:25:02 <newsham> yah, why not 1) detect the failure, 2) print an error message, maybe 3) write to an alternate file and tell user how to manually install?
15:25:12 <newsham> #2 seems like it shoudl be its own separate bug report
15:25:28 <EvanR> uhg, ruby's BigDecimal implements a decimal version of ieee floating point, including NaNs and a global floating point environment
15:25:50 <acowley> Yeah, newsham's suggestion seems like a better choice than silent failure
15:26:02 <roconnor> EvanR: I seem to recall reading an article advocating this recently.
15:26:15 <roconnor> EvanR: something about finance.
15:26:16 <jophish> Can I add constraints to types in type families?
15:26:20 <EvanR> >>>__<<<<
15:26:26 <merijn> jophish: Depends what you mean?
15:26:57 <jophish> merijn: class C a where data X :: * -- and Eq X
15:27:01 <EvanR> roconnor: ill take Infinity dollars due to a bank error
15:27:13 <acowley> EvanR: Can I have half?
15:27:23 <roconnor> EvanR: well I don't know about the NaN bit, but decimal version of floating point.
15:27:44 <roconnor> I wouldn't be surprised if it was the whole IEEE
15:27:47 <merijn> jophish: FYI, type families are allowed to return constraints
15:27:51 <EvanR> wouldnt decimal floats have the same weird non associativity etc
15:28:05 <c_wraith> EvanR: depends on the representation
15:28:09 <merijn> jophish: With the extension ConstraintKinds you can write your own constraints using type families
15:28:12 <roconnor> EvanR: surely.
15:28:13 <Kaidelong> before I file the bug, I would need someone to confirm that there is in fact no error message
15:28:21 <Kaidelong> and not that I'm not just stupid and didn't notice it
15:28:21 <acowley> jophish: You can define a type class with an associated type, then put the constraint on the class definition
15:28:30 <merijn> jophish: So I'm not sure you can do quite what you want, but you can probably work around it
15:28:31 <newsham> kaide: hmm.. did they use MOVEFILE_DELAY_UNTIL_REBOOT?
15:28:36 <newsham> maybe it would have fixed itself later?
15:28:52 <EvanR> an integer number of pennies, or smallest units of account makes me sleep better
15:28:56 <Kaidelong> newsham: I did reboot
15:28:57 <newsham> (if that is true, it still would have been nice to say "will replace after reboot")
15:29:00 <newsham> oh
15:29:06 <jophish> acowley: may I have a small example, I'm not quite sure I follow
15:29:51 <merijn> jophish: Not an example of what acowley said, but I love pimping my own example of what I said: https://gist.github.com/merijn/6130082 :)
15:30:40 <jophish> merijn: ahh, my head
15:31:28 <merijn> jophish: :)
15:31:38 <roconnor> EvanR: no kidding.
15:31:49 <roconnor> Data.Fixed.Fixed Data.Fixed.E2
15:31:56 <EvanR> Centi
15:32:09 <merijn> jophish: It's not that complicated, tbh, feel free to ask if you're confused (although you have a 30 min time frame for tonight before I fall asleep :p)
15:32:24 <jophish> I've got to go to bed now, perhaps tomorrow :)
15:32:33 <jophish> thanks!
15:32:37 <EvanR> type Dollars = Centi
15:32:59 <EvanR> prefix ($$) :: a -> a
15:33:07 <EvanR> $$ 3.99
15:35:36 <pavonia> > let pay f = "$" ++ show (f id) ++ " payed" in pay ($ 3.95)
15:35:37 <lambdabot>  "$3.95 payed"
15:36:29 <EvanR> in haskell, constant functions are used as currency
15:36:50 <Kaidelong> okay so cabal install --only-dependencies complains that it cannot resolve opengl
15:36:59 <Kaidelong> but if I try "cabal install opengl" that works fine
15:37:00 <EvanR> their value never changes!
15:37:01 <Kaidelong> why?
15:37:34 <monochrom> EvanR: banks have been using binary-coded decimal forever. it is why intel floating point always has it.
15:38:14 <EvanR> binary floating point?
15:38:20 <EvanR> i mean, decimal floats?
15:38:23 <monochrom> yes
15:38:25 <hpc> it's fixed point
15:38:47 <awestroke> why are banks not using integers?
15:39:22 <Kaidelong> integers are a poor choice for financial calculations but fixed percision is basically like an int anyway
15:39:26 <hpc> optimization, perhaps?
15:39:36 <hpc> in BCD, divide by 10 = bitshift by 4
15:39:49 <monochrom> perhaps no one explained integers to them
15:40:02 <hpc> that too
15:40:14 <Kaidelong> efficient work with decimal data types is part of why IBM is still able to sell mainframes
15:40:21 <awestroke> "Storing money as cents? That's crazy! We need to store out money as $1M = 1.0"
15:40:34 <EvanR> 1.0 million
15:40:44 <Kaidelong> they have specialized instructions for working with them
15:41:10 <Kaidelong> (although you no longer need to program them in COBOL, you can use Java now!)
15:41:18 <monochrom> hehe
15:41:22 * monochrom uses Java now!
15:41:38 <geekosaur> does intel still have the bcd-adjust instructions?
15:43:27 <EvanR> ruby big decimal allows arbitrary digits of precision, so NaN and infinity should be errors
15:43:39 <EvanR> which you can enable, but its a global setting
15:43:40 <EvanR> bah
15:43:49 <EvanR> which rails arbitrarily resetes
15:47:32 <Kaidelong> okay the only explanation I have is that my gldemo.cabal file is somehow borked
15:47:52 <matheus23> This: http://hackage.haskell.org/package/aeson-0.7.0.3/docs/Data-Aeson.html#g:5 doesn't work in my ghci repl
15:48:02 <Kaidelong> I have "build-depends: base ==4.6.*, glfw-b, opengl
15:48:05 <matheus23> It fails with a "no instance for" blah... :/
15:48:10 <Kaidelong> is this incorrect syntax?
15:48:12 <matheus23> Am I missing something?
15:48:46 <matheus23> Kaidelong: it should be...
15:49:33 <geekosaur> that renders wrong here, lines wrapped instead of properly broken
15:49:35 <matheus23> Kaidelong: have you copied the exact lines into here?
15:49:37 <Kaidelong> fail (unknown package: opengl)
15:49:37 <monochrom> matheus23: firstly, the code in the blue boxes seem to be garbled. do you agree?
15:49:46 <matheus23> monochrom: yep
15:50:11 <Kaidelong> geekosaur: I am supposed to put the deps on separate lines?
15:50:14 <jfischoff> matheus23: it is not formatted correctly
15:50:16 <monochrom> ok, so (decode "[1]" :: Maybe [Int]). does that work?
15:50:25 <Kaidelong> I thought it was a comma separated list
15:50:27 <geekosaur> Kaidelong, sorry, talking about matheus23 issue not yours
15:50:31 <Kaidelong> oh okay
15:50:36 <matheus23> jfischoff: monochrom: http://lpaste.net/103779
15:50:45 <Kaidelong> sorry
15:50:55 <geekosaur> the wiki page is wrapping example code, which makes it syntactically incorrect
15:51:05 <matheus23> that's what I typed in.
15:51:27 <matheus23> of course there's also an "import Data.Aeson" in front of that, which I didn't copy...
15:51:57 <monochrom> you also need "instance ToJSON Person where ..."
15:52:09 <jfischoff> instead of import Data.Aeson
15:52:14 <jfischoff> use Data.Aeson.Generic
15:52:21 <matheus23> jfischoff: oh that might be it!
15:52:37 <jfischoff> or even better, don’t use this functionality at all
15:52:48 <jfischoff> and use the TH or Generics way
15:52:56 <matheus23> ah yeah I just got that deprecation warning
15:53:34 <geekosaur> it does say "switch to the Generic module" on that wiki page, but the link goes to the wrong place because haddock's link tags changed at some point
15:57:09 <matheus23> jfischoff: thanks a lot! Template Haskell does a good job, I think :)
15:57:16 <jfischoff> np
15:58:01 <tangentstorm> hey all. does 'main' have to be ':: IO ()' ? or can it be 'IO Something' ? And what would that mean, exactly?
15:58:21 <pavonia> Yeah, it can be IO anthingy
15:58:53 <geekosaur> the value is thrown away, so IO () is conventional because () is pretty much there to be thrown away
15:58:54 <pavonia> I think the retun value is ignored when compiling to binary
15:58:55 <c_wraith> tangentstorm: it can be anything that unifies with IO a, but it ignores the value of that type
15:58:58 <geekosaur> but main :: IO a
15:59:01 <Kaidelong> okay I just tried to open a cabal file in firefox and the result was instead of recognizing it as text and displaying it it went into an infinite loop where it keeps generating new tabs
15:59:02 <benzrf> tangentstorm: just use <$
15:59:08 <benzrf> if u must have IO ()
15:59:15 <c_wraith> err, it ignores the 'a' type
15:59:19 <tangentstorm> oh so it would just be for if i said 'return whatever'?
15:59:23 <tangentstorm> and it wouldn't make a difference?
15:59:59 <pavonia> tangentstorm: It makes a difference if you use your main function from another function in your module
16:00:34 <jfischoff> I think the short anwser is it doesn’t matter
16:01:17 <EvanR> > getZonedTime
16:01:19 <lambdabot>  Not in scope: ‘getZonedTime’
16:01:21 <jfischoff> http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Exit.html#v:exitWith is sometimes the answer to the next question
16:01:37 <EvanR> in Data.Time it seems that the show instance of Day is commented out...
16:02:28 <tangentstorm> oh, duh... it never would have occurred to me to do that, pavonia :)
16:03:00 <pavonia> Yes, same for me :)
16:03:38 <EvanR> alright, showGregorian works
16:04:05 <EvanR> whoever designed this Time library, you are amazing
16:04:25 <EvanR> head explode whenever i think about time keeping
16:11:08 <benzrf> .q
16:11:10 <benzrf> oops
16:19:08 <l0cust> What is the purpose of the >> operator?
16:19:15 <l0cust> I can understand >>=, but what about >>
16:19:21 <l0cust> :i (>>)
16:19:33 <l0cust> :t (>>)
16:19:34 <lambdabot> Monad m => m a -> m b -> m b
16:19:49 <EvanR> >> ignores the result of the left hand action
16:19:59 <EvanR> but its effects still happen
16:20:13 <l0cust> That sounds unsafe
16:20:17 <acowley> locust: Think about statements in a C-like language that don't return anything useful.
16:20:18 <EvanR> nah
16:20:24 <acowley> l0cust: e.g. return void
16:20:30 <l0cust> acowley: ah, I see
16:20:43 <EvanR> > Just 'a' >> Just 'b' >> Just 'c'
16:20:44 <lambdabot>  Just 'c'
16:20:49 <EvanR> > Just 'a' >> Nothing >> Just 'c'
16:20:50 <lambdabot>  Nothing
16:20:55 <benmachine> >> is a possible source of errors when you throw away things you shouldn't
16:20:59 <benmachine> so... don't do that
16:21:05 <roconnor> print 'a' >> print 'b' >> print 'c'
16:21:06 <benmachine> only throw away things you should
16:21:07 <benmachine> then it's fine
16:21:13 <l0cust> EvanR: Thank you
16:21:31 <l0cust> benmachine: thanks to you as well
16:21:46 <l0cust> > print "a" >> print "b" >> print "c"
16:21:48 <lambdabot>  <IO ()>
16:21:53 <EvanR> ignoring results of actions in C is usually pretty bad
16:22:05 <EvanR> since that is how modules often signal error conditions
16:22:09 <l0cust> Well, I can see the idea, like printf returns an int
16:22:11 <EvanR> but haskell has exceptions
16:22:15 <Jaden> why do you people use haskell when you could use a better language like lisp?
16:22:36 <l0cust> But does anyone ever actually use printf's return
16:22:41 <l0cust> Do not engage the troll
16:22:44 <EvanR> i didnt know printf had a return
16:22:57 <l0cust> EvanR: it returns the number of characters printed
16:23:04 <EvanR> huh, boring ;)
16:23:37 <acowley> Not when your terminal runs out of characters
16:24:02 <acowley> My stdout is tired
16:24:14 <EvanR> o_O
16:24:35 <acowley> Don't judge me
16:24:43 <EvanR> at&t called, you only have 4567 characters left on your online account this month
16:24:50 <EvanR> use them wisely
16:25:10 <EvanR> by switching to chinese
16:25:18 <mgsloan> l0cust: One nice thing is that do-notation will actually warn you about places that you're implicitly using ">>" and ignoring the return type (if the warning is enabled, e.g. via -Wall)
16:25:26 <mgsloan> *ignore
16:25:28 <acowley> You better check your printf return value before you wreck ... your... text message allowance
16:26:53 * merijn always promptly disab;es that warning :p
16:27:12 <roconnor> i := printf("Your answer %s\n",answer); if 1000000 < i then print("Sorry for the long answer.\n");
16:28:21 <mgsloan> merijn: Yeah, it can cause a little bit of code bloat, but I know it's caught mistakes for me before, so I end up using "void $" or "_ <- "
16:28:56 <roconnor> I can't beleive they stole the word void
16:28:59 <EvanR> roconnor: answer not defined?
16:29:21 <EvanR> ah it only prints two messages
16:29:22 <acowley> Yeah, I used to not like that warning. But if there's one lesson time is intent on teaching me, it is that I am a fount of infinite mistakes.
16:29:22 <l0cust> roconnor: that is possibly the worst bit of c i've ever seen
16:29:23 <mgsloan> I also actually like having the explicit indication of "I ignored something here", as it's true that ignoring some value can be indicative of a bug
16:29:38 <roconnor> l0cust: really, the worst?
16:29:56 <l0cust> roconnor: it's up there :)
16:30:17 <EvanR> mgsloan: i have a hard time writing IO do notation code while forgetting some return values i need
16:30:18 <acowley> mgsloan: The only time it irks me is when the thing I'm discarding has runtime value isomorphic to ().
16:30:54 <Kaidelong> okay I have no idea how to make cabal install --only-dependencies actually work
16:31:02 <EvanR> mgsloan: so many more IO actions in haskell result in stuff thats actually important than other systems
16:31:04 <Kaidelong> it seems like it doesn't search hackage at all?
16:31:05 <albeit> I want my program to execute lazily and output "123" each time a result is found, but its waiting till the end to output them all at once. Any ideas? http://lpaste.net/103781
16:31:19 <acowley> flush
16:31:26 <mgsloan> EvanR: I know, it's a rather rare thing, but it does happen in practice when writing a large amount of IO code
16:31:52 <Kaidelong> does cabal sandbox expect me to use cabal unpack and then cabal add-source?
16:31:52 <EvanR> mgsloan: id write more pure code, in which case monadic expressions with lots of >> would produce a lot of annoying warnings
16:32:46 <Kaidelong> interestingly if I actually use cabal install inside of the sandbox it works
16:32:53 <Kaidelong> but then cabal repl doesn't
16:33:05 <jfischoff> albiet: the first thing that sticks out at me is foldl’, maybe foldr there
16:33:23 <l0cust> jfischoff: I think you meant albeit
16:33:28 <EvanR> foldl’
16:33:36 <jfischoff> oh yeah
16:33:58 <albeit> But it has to go in forward sequence through the lines... it can't start from the end and work backwards...
16:34:06 <EvanR> “smart fold”
16:34:10 <l0cust> jfischoff: most irc clients have tab-completion, which works on people's nicks
16:34:29 <mgsloan> EvanR: Usually for me it happens in a case where there's something being updated and passed from one function to another.  If there's a function that usually returns the value unchanged, then you might accidentally skip using its result value
16:34:32 <jfischoff> l0cust: good to know
16:34:42 <mgsloan> Sure, this can be fixed by using a State monad or whatnot
16:34:56 <mgsloan> but sometimes that's a bit heavyweight for incidental occurances of this pattern
16:35:05 <XrXr> guys I have a newbie question http://lpaste.net/103782
16:35:21 <EvanR> State is pretty light, and i never use it
16:35:40 <merijn> XrXr: ++ and : are not the same thing
16:35:42 <merijn> XrXr: Witness
16:35:45 <albeit> Just switched it to using foldr, and same issue... I thought using the difference list would let it output the lines as they are found
16:35:45 <merijn> :t (++)
16:35:46 <lambdabot> [a] -> [a] -> [a]
16:35:50 <merijn> :t (:)
16:35:51 <lambdabot> a -> [a] -> [a]
16:36:06 <mgsloan> Sure, its light, but it feels wrong to introduce it to a large block of monadic code just to cleanup one portion
16:36:37 <EvanR> well you can enter and leave State at will
16:36:47 <EvanR> if you have the state
16:36:48 <mgsloan> True
16:37:04 <mgsloan> Ok, I suppose I should say portions :P
16:37:17 <EvanR> just to clean up one portions ;)
16:37:35 <XrXr> hm.. is there no way to append an element using : ?
16:37:48 <EvanR> : is only for prepending
16:37:56 <pavonia> not for lists
16:38:11 <XrXr> okay.
16:38:14 <l0cust> Completely subjective question - friend of mine wants to learn how to program - what languages do you suggest. I was going to suggest C, because I hate Python. Does anyone have any better suggestions?
16:38:56 <pavonia> What about Haskell?
16:38:58 <Iceland_jack> You aren't going to tell us anything about your friend's backgrond?
16:39:02 <Iceland_jack> *background
16:39:05 <Kaidelong> Haskell is good; the denotational semantics are easy, the syntax is simple and consistent
16:39:12 <Kaidelong> it has a REPL
16:39:12 <jfischoff> Haskell
16:39:24 <l0cust> pavonia: Haskell would be what I would suggest, except it doesn't have very good newbie tutorials
16:39:37 <pavonia> That's wrong
16:39:37 <l0cust> even lyah assumes you have some imperative background
16:39:38 <Iceland_jack> l0cust: It doesn't?
16:39:39 <jfischoff> Learn you haskell is fine
16:39:45 <mgsloan> Something that's a bit related to this is a trick I remember Cale mentioning - intentionally using name shadowing in do notation bindings in order to have an "update" that disallows downstream use
16:40:02 <EvanR> a tutorial for haskell that is starting completely from scratch
16:40:03 <EvanR> would be nice
16:40:04 <l0cust> jfischoff: from lyah : "This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python …) but haven't programmed in a functional language before (Haskell, ML, OCaml …). "
16:40:09 <Kaidelong> prolog is also a nice language for beginners if you don't care much about doing useful things in it
16:40:18 <l0cust> Actually, Lisp would be perfect
16:40:28 <covi> In lambda calculus, what's difference between a "lambda-variable" and a "rou-variable" (I think the symbol is \rou, like a p)?
16:40:29 <mark_t> ^said no one ever.
16:40:29 <EvanR> lisp is still confusing to me
16:40:32 <Iceland_jack> For some value of perfect..
16:40:35 <jfischoff> and yet people without that experience have learned through that book
16:40:36 <Kaidelong> l0cust: do you mean lisp or scheme?
16:40:39 <Kaidelong> both have their problems
16:40:45 <Iceland_jack> Python is very nice for a first programming language
16:40:45 <l0cust> Kaidelong: racket, probably
16:40:57 <cjwelborn> so, looking at leksah..and it seems like it would be good for a full on Haskell dev, but I am just starting out and all the automatic test code and package build stuff is clouding my view. Any simple Haskell editors with Syntax Highlighting (possibly autocomplete) besides SublimeHaskell and Leksah?
16:41:07 <pavonia> covi: Do you mean \rho?
16:41:14 <Iceland_jack> cjwelborn: Is Emacs simple? :)
16:41:17 <EvanR> everyone must do mandatory 4 years imperative programming, by law
16:41:20 <covi> pavonia: oh yeah
16:41:20 <l0cust> Iceland_jack: to answer your question, she has some minor experience in HTML/CSS, she intends to teach herself
16:41:25 <EvanR> then they can go free
16:41:39 <l0cust> She isn't super mathematically inclined, although she is very smart
16:41:46 <Kaidelong> l0cust: the need to keep track of state transitions, the parenthesis spam, the lack of consistency (like how compiled expressions are different from other expressions)
16:41:51 <cjwelborn> Iceland_jack: that was my next choice actually. I'm not usually an emacs user but I think i'll give it a shot.
16:41:57 <Kaidelong> all of them can be hangups for beginners
16:42:06 <l0cust> Iceland_jack: nobody ever said Emacs was easy
16:42:14 <Iceland_jack> l0cust: Depends how much of it you use
16:42:16 <Kaidelong> l0cust: if you really don't want to use haskell, prolog is nice, as is sml/nj
16:42:22 <Kaidelong> sml/nj was the first language I learned
16:42:38 <l0cust> Emacs is sort of like Haskell, actually - one fuckmother of a learning curve, but orgasmic once you get past it
16:42:53 <Kaidelong> haskell was incredibly easy for me to learn
16:43:00 <EvanR> she should start with emacs
16:43:15 <Kaidelong> easier than any other language I tried including classic learning languages like VB, logo, scheme, python
16:43:29 <l0cust> EvanR: You say that as an experienced emacs user, probably. I too am a somewhat experienced emacs user, but I still remember how difficult it was to learn
16:43:36 <EvanR> i cant use emacs for shit
16:43:49 <dbelange> the problem with emacs is that it is based on scheme
16:43:51 <dbelange> which has mutation
16:43:53 <cjwelborn> haskell is very different, thats all I can say right now on day 3 (not my first language), but I haven't really made it to Monads yet so we'll see. I really want to learn this language though. I want to know what functional programming is about :)
16:44:04 <l0cust> dbelange: not true, it's based on MacLisp
16:44:10 <dbelange> even worse
16:44:15 <Kaidelong> l0cust: I think haskell only really has a strong learning curve for people who have already learned to program
16:44:26 <l0cust> Kaidelong: that's a very good point
16:44:26 <Kaidelong> for beginners it's fine
16:44:34 <EvanR> cjwelborn: monads are a sideshow to functional programming in general
16:44:47 <l0cust> Kaidelong: I think scheme might be a good choice
16:44:59 <Kaidelong> scheme was language #2 for me
16:45:00 <EvanR> see the bearded Cont
16:45:06 <Kaidelong> I didn't find it easy to learn at all
16:45:08 <l0cust> Kaidelong: Python would be a good choice admittedly. I hate saying that, because I think it is a terrible language
16:45:31 <cjwelborn> EvanR: i do know what you mean by that, I mean they aren't necessary I think. But i do need to find out about them for the things I intend to make once I learn this language called Haskell.
16:45:39 <Kaidelong> Python was harder for me to learn than Java, despite its reputation
16:45:49 <merijn> cjwelborn: The problem is that people hear the term and think "I wanna learn monads" which makes about as much sense as saying "I wanna learn the singleton pattern" (or whatever OO design pattern stuff, I'm not up to date)
16:46:12 <l0cust> Kaidelong: I absolutely hate python, so I refuse to recommend it
16:46:19 <merijn> cjwelborn: The trick is to learn specific datatypes, understand their monad instances and not worry about what they "are" or "mean"
16:46:22 <EvanR> merijn: observer ;)
16:46:24 <jfischoff> mutation is a bizarre concept. However algebra is something most people with a high school education are familiar with. This is why Haskell works well as a first language
16:46:29 <l0cust> Kaidelong: that goes for ruby/perl/all of those "scripting" languages
16:46:33 <jfischoff> it relates to ideas users are familiar with
16:46:43 <l0cust> Kaidelong: they are just so prone to runtime errors
16:46:49 <jfischoff> the problem is that googling for haskell issues is well not that easy
16:46:58 <l0cust> they're nice to use in a shell, but so difficult for actual programming
16:47:04 <jfischoff> and fixing type errors is hard for beginners
16:47:06 <l0cust> Okay, back to the basics - what about C?
16:47:07 <merijn> cjwelborn: Once you're somewhat familiar with Maybe and Either, you may want to read the only "intro" worth reading: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:47:08 <Kaidelong> jfischoff: I think the same goes for prolog
16:47:12 <Kaidelong> it's pretty declarative
16:47:43 <l0cust> I like C - it's crazily unsafe (cough Heartbleed), but it's a solid language, unlike Python
16:47:48 <l0cust> Or Lisp, even
16:47:49 <merijn> Kaidelong: Prolog "pretty declarative"? Dear lord, what does a language have to do to qualify as "declarative" :p
16:47:50 <jfischoff> Kaidelong: perhaps
16:47:52 <cjwelborn> merijn: I wish I knew more about them so I could comment, I don't want to stick my foot in my mouth (too many "Monads are like [insert thing]" articles)..I want to try using them, and find out for myself if they are something I need or want (or something I need to understand). Thanks for the link, I will read it :)
16:48:12 <EvanR> l0cust: perhaps recommend a system you have no experience with and you learn together
16:48:24 <l0cust> EvanR: That's actually a decent idea
16:48:34 <merijn> l0cust: What do you mean by "a solid language"
16:48:35 <Kaidelong> merijn: it does allow the rule database to be mutated and the solution search to be restricted depending on what it hits first
16:48:53 <Kaidelong> but yeah it's probably under-stating it to say it's "pretty declarative"
16:48:57 <l0cust> merijn: It has nice library support, it compiles, it doesn't have as many dumbass runtime errors
16:48:59 <Kaidelong> solidly declarative?
16:49:17 <EvanR> Exception: Dumbass Error
16:49:27 <merijn> l0cust: I just spent some time going over the standard again and I realised that I have probably not written any piece of over 30 lines in C that was bug free in my entire life
16:49:27 <Kaidelong> prolog is a solid language for beginners, haskell too
16:49:48 <l0cust> merijn: Oh yeah, it's a tough language, nobody's debating that
16:49:55 <Kaidelong> l0cust: C is a simple language but the stdlib is anything but
16:49:58 <merijn> l0cust: It's beyond tough
16:50:05 <merijn> Kaidelong: C isn't even simple either
16:50:33 <Kaidelong> you run into the same frustration/discouragement issues you run into with Scheme
16:50:44 <Kaidelong> although for different reasons
16:50:46 <l0cust> This is why I was suggesting Lisp - it has incredibly simple syntax
16:50:58 <EvanR> the syntax is too simple
16:50:58 <l0cust> unlike c
16:51:02 <l0cust> EvanR: lol
16:51:03 <merijn> Kaidelong: "int main (int argc, char **argv) { int a = x * 2; return a; }" according to the spec this is allowed to sometimes format your harddrive
16:51:07 <c_wraith> a variant of C with fully-defined behavior would be pretty simple.
16:51:10 <Kaidelong> common lisp has an incredibly complicated standard libraries
16:51:20 <merijn> c_wraith: I'd settle for "no undefined"
16:51:23 <l0cust> Kaidelong: true - again, this is just to learn the concepts of programming
16:51:26 * hackagebot hledger-lib 0.23.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.23.1 (SimonMichael)
16:51:29 <merijn> c_wraith: I can see how "implementation defined" may have value
16:51:33 <Kaidelong> it also has a frustrating syntax for beginners
16:51:36 <l0cust> Kaidelong: she's not going to be developing large applications in it
16:51:40 <merijn> c_wraith: But undefined is sheer evil
16:51:44 <EvanR> l0cust: and the semantics, dont ask any lisper how something works or they will give you an essay on meta circular evaluation
16:51:50 <l0cust> EvanR: lol
16:51:58 <l0cust> EvanR: you aren't a lisp fan, are you?
16:52:09 <Kaidelong> lisp is a pretty awful language
16:52:33 <EvanR> i would just appreciate a cultural distinction between expressions and values
16:52:45 <Kaidelong> unless you are already an experienced programmer perhaps
16:52:58 <Kaidelong> but for a beginner lisp is a bad choice, someone tried it on me
16:53:02 <Kaidelong> bad idea
16:53:34 <Kaidelong> it actually left a bitter taste for all lisp languages in my mouth and almost put me off programming altogether
16:53:46 <c_wraith> which lisp was it?
16:53:47 <l0cust> Kaidelong: What do you mean
16:54:00 <Kaidelong> c_wraith: some old lisp called ALISP
16:54:01 <l0cust> Kaidelong: Elisp is awful, but Clisp is a nice language
16:54:09 <l0cust> Kaidelong: never tried it
16:54:34 <EvanR> how about purely functional, statically typed lisp with polymorphism ;)
16:54:36 <albeit> Okay I simplified my problem http://lpaste.net/103783... because I'm using difference lists, shouldn't the "Q"s be output as they are found, instead of at the end?
16:54:40 * geekosaur remembers using xlisp a lot
16:54:51 <l0cust> someone kick albeit for being on-topic
16:54:56 <l0cust> and not starting flame wars
16:55:15 <albeit> :)
16:55:17 <c_wraith> albeit: your base case for the fold on line 3 should just be id
16:55:29 <c_wraith> albeit: (that doesn't answer your question, it's just simpler code)
16:56:19 <c_wraith> albeit: also, (["Q"] ++) is just ("Q" :)
16:56:19 <albeit> c_wraith: Okay, I just remove a lot of stuff from my actual code to make it as simple as possible, there was a base case before.
16:56:27 * hackagebot hledger 0.23.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.23.1 (SimonMichael)
16:56:29 * hackagebot hledger-web 0.23.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.23.1 (SimonMichael)
16:56:31 <XrXr> l0cust, Javascript? I know you said you don't like scripting languages
16:56:41 <l0cust> XrXr: javascript is actually a really nice language
16:56:46 <l0cust> XrXr: that isn't a bad idea
16:56:53 <c_wraith> albeit: I'm betting the problem is foldl
16:57:02 <Sonarpulse> when I try to install tf-random, I get an error: "/tmp/pkgConf-tf-random-017471.5: hGetContents: invalid argument (invalid byte
16:57:02 <Sonarpulse> sequence)"
16:57:05 <c_wraith> albeit: I think you need foldr to stream results
16:57:30 <sm> Sonarpulse: set LANG=en_US.utf-8 or your locale
16:57:44 <albeit> c_wraith: I have similar code that uses foldl', and it works fine. I just can't figure out what the difference is to this...
16:57:47 <Sonarpulse> sm i saw https://github.com/nick8325/quickcheck/pull/13
16:57:50 <l0cust> Sonarpulse: What OS are you using?
16:57:54 <Sonarpulse> debian
16:58:00 <XrXr> 10cust, if she knows HTML, Javascript ties in nicely with it
16:58:04 <Jaden> Do you want to teach her to program? Lisp. Do you want to bone her? Python.
16:58:15 <l0cust> XrXr: good point
16:58:16 <XrXr> lol
16:58:22 <l0cust> Jaden: no intention of boning her lol
16:58:37 <Sonarpulse> set LANG=en_US.utf-8 in the shell?
16:58:40 <sm> please keep this channel friendly for all
16:58:41 <Jaden> then use lisp. You won't get any.
16:58:48 <l0cust> Jaden: lol
16:59:30 <EvanR> javascript is a good idea
17:00:02 <EvanR> instant gratification with the browsers abilities
17:00:04 <albeit> c_wraith: I just tried it with foldr, and it still doesn't stream
17:00:10 <l0cust> Jaden: are you saying that this guy isn't drowning in pussy? http://i.imgur.com/Fa8T0dj.jpg
17:00:11 <Jaden> javascript sucks. are you going to have her refresh a browser to run her program?
17:00:34 <EvanR> why not
17:00:37 <sm> Sonarpulse: yes
17:00:50 <sm> or just prefix it to your command
17:01:19 <sm> GHC-compiled programs require that a locale is set or they will die on encountering non-ascii
17:01:23 <c_wraith> albeit: oh.  It can't stream because you're reversing the list.
17:01:31 <Sonarpulse> so set the environment variable LANG?
17:01:31 <l0cust> brb
17:01:34 <Sonarpulse> it didn't do it
17:01:45 <Sonarpulse> but w/e i'll just use export
17:02:00 <sm> ok, worth a try
17:02:07 <Sonarpulse> sm
17:02:08 <Sonarpulse> thanks
17:02:26 <albeit> c_wraith: How do you mean?
17:02:48 <c_wraith> albeit: As you traverse the input list, each new Q you add gets put at the front of the output list
17:02:58 <Sonarpulse> yeah I never remember which flavor of environment-variable-setting does what
17:03:06 <Sonarpulse> but s/set/export/ worked
17:03:13 <c_wraith> albeit: Obviously, it can't tell what the front of the output list is until it's read the whole input list
17:03:30 <geekosaur> "set" wouldn't do anything useful in a Bourne-type shell
17:03:38 <geekosaur> (it sets $*)
17:04:04 <c_wraith> albeit: err, am I wrong again.  Darn it, I need to think more, and test more.  This is what happens when the vm I have GHC on takes forever to start up.
17:04:11 <l0cust> alright - aside from whatshisface's comment about boning her, it sounds like everyone hates Lisp
17:04:34 <albeit> c_wraith: No worries, I appreciate the help regardless! Makes me think about it more...
17:05:08 <benzrf> lisp is neat
17:05:17 <Jaden> lisp is the best language, but until you master Paredit it's a bich for newbies to type.
17:05:18 <benzrf> it has awesome macros
17:05:35 <l0cust> Jaden: yeah, paredit is awesome. I can't imagine working in Lisp with anything other than Emacs
17:05:51 <Jaden> Lisp without paredit is like [insert any other language here] without a keyboard.
17:05:57 <l0cust> Jaden: very true
17:06:28 <Kaidelong> figured out what was the problem with cabal install --only-dependencies
17:06:44 <l0cust> Kaidelong: hm?
17:06:48 <Kaidelong> cabal install opengl  only works because cmd.exe is case insensitive
17:06:50 <Jaden> Once you master Paredit then code flys off your fingers. Complex edits that would not be possible in other languages done instantly. It's a big payoff, but the learnign curve would kill a newbie girl.
17:06:53 <Kaidelong> it should be OpenGL
17:06:59 <Cale> l0cust: The main advantage that scheme/lisp has at this point is that SICP exists. There are not so many lisps with decent type systems though.
17:07:05 <Kaidelong> when it looks in the .cabal file, it cares about case
17:07:21 <l0cust> Cale: the alternative is Python
17:07:25 <l0cust> Cale: or C
17:07:39 <Cale> Well, Python and C also essentially don't have type systems
17:07:39 <l0cust> Cale: Actually, what about C++?
17:07:44 <l0cust> Cale: lol true
17:07:51 <Cale> This is for teaching a beginner?
17:07:56 <l0cust> Cale: yep
17:08:08 <Cale> I wouldn't introduce people to C or C++ at this point.
17:08:10 <Kaidelong> if you want a language without types for teaching a beginner then I suggest Prolog
17:08:14 <Kaidelong> prolog is awesome
17:08:19 <benzrf> Kaidelong: don't be absurd
17:08:20 <benzrf> start with python
17:08:22 <Cale> I don't even think people should be using those languages except to maintain existing projects.
17:08:27 <Jaden> c++ is ok. Use the book accelerated C++. They use the sub-set of c++ that is good.
17:08:32 <benzrf> Jaden: nooooo
17:08:34 <Cale> Why not Haskell?
17:08:42 <benzrf> haskell for fp, python for procedural
17:08:44 <Kaidelong> benzrf: you would seriously take python over prolog?
17:08:58 <Kaidelong> I found it harder to learn
17:08:59 <l0cust> Cale: lyah is the only good haskell tutorial, and it assumes you have previous programming experience
17:09:07 <benzrf> Kaidelong: prolog is interesting, but i assumed they wanted to teach practical programming
17:09:10 <benzrf> :P
17:09:23 <Kaidelong> but you don't really teach that to a beginner
17:09:23 <Jaden> C++14 is a completely different language. A big improvement over the 90's and 2000's c++. It's actually a somewhat nice langauage.
17:09:24 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html
17:09:30 <Kaidelong> although haskell kills both birds with one stone
17:09:45 <Cale> ^^ you might try this book if you're teaching a complete beginner. It's not supposed to assume any previous programming experience.
17:09:49 <Kaidelong> it's a relatively easy to understand and simple language that's consistent and interesting and is also good for practical programming
17:10:46 <Cale> Jaden: Has the size of the specification decreased at all? :)
17:10:56 <Cale> Jaden: Last I checked, it was somewhere around 1500 pages
17:10:59 <Sonarpulse> http://www.ccs.neu.edu/home/matthias/HtDP2e/
17:11:26 <Jaden> C++ only to maintain? it's the only language (with a decent compiler) that gets generics right. Java f**ked generics up. C# is not quite there. Waht other options do you have for production systems deployed on the client side?
17:11:32 <Sonarpulse> Jaden Rust
17:11:46 <Jaden> isnt' rust garbage collected though?
17:11:49 <Sonarpulse> no
17:12:05 <Kaidelong> Jaden: C++ doesn't really have generics, it's based on (potentially unsafe) metaprogramming
17:12:13 <Jaden> oh. Well then maybe i need to look into Rust. I remember hearing it was collected so i didn't bother.
17:12:13 <Cale> Jaden: Haskell
17:12:14 <Sonarpulse> Rust has typeclasses lol
17:12:22 <l0cust> Kaidelong: What about Vala?
17:12:24 <Sonarpulse> and i seriously doubt GC is a problem
17:12:31 <l0cust> Vala is a nice version of C
17:12:32 <Kaidelong> Java's generics are also implemented that way I think but it's type-safe
17:12:46 <Kaidelong> C# has actual runtime parametric polymorphism
17:13:03 <Jaden> Haskell is beter than C++ as a language, but ti's not quite there yet on compilers and efficieny.
17:13:16 <Sonarpulse> http://stackoverflow.com/questions/12404031/how-long-pauses-can-occur-in-a-haskell-program-due-to-garbage-collection
17:13:22 <machineslearn> > "Haskell" > "C++"
17:13:24 <lambdabot>  True
17:13:27 <Jaden> There's still a world where things like garbage collection F you up.
17:13:32 <Sonarpulse> do YOU need < 1 ms latency ?
17:13:36 <sipa> > "c++" > "Haskell"
17:13:37 <lambdabot>  True
17:14:10 <Iceland_jack> > "C++" > "Haskell" -- hmm
17:14:11 <lambdabot>  False
17:14:29 <l0cust> lol lambda bot
17:14:31 <Jaden> C# did generics better than Java. But still a downgrade from C++. I really feel the advantage of C# is the visual studio integration, not so much the langauge itself.
17:14:53 <Kaidelong> it's only a "downgrade" because it is not the same thing at all
17:14:57 <Jaden> and of course java sucks as always.
17:15:04 <Jaden> at the bottom of the heap
17:15:24 <Kaidelong> again, C++ doesn't do it through parametric polymorphism, it mocks it with unrestricted template metaprogramming
17:15:32 <Kaidelong> which is strictly more powerful and extremely unsafe
17:16:34 <Kaidelong> oh, I have to go
17:16:34 <Jaden> Cale. size of the spec doens't matter. If you pick the right book like Accelerated C++ you learn a sub-set of C++. No different than learnign a minimal langauge like shceme.
17:17:16 <Cale> Jaden: It really does matter though. The size of the specification corresponds to the amount of stuff you need to know in order to reason about programs written in the language.
17:17:18 <l0cust> Alright, back to my original question - I've narrowed it down to Lisp, Python or C
17:17:46 <l0cust> I'm leaning towards lisp, because it sucks the least
17:17:51 <kadoban> l0cust: for what purpose/context? I probably missed it
17:17:51 <Cale> l0cust: Use SICP, yeah
17:17:52 <Jaden> which lisp? scheme or common?
17:18:03 <l0cust> kadoban: to teach a newbie
17:18:12 <l0cust> Jaden: common
17:18:34 <Jaden> sicp is not newbie friendly. It's a great book, but was used to weed out college weenies.
17:18:46 <kadoban> l0cust: If they're super motivated and maybe a bit mathematical or otherwise good at logical thought, scheme/SICP.  Otherwise, if they just want to get some stuff done, Python.
17:18:53 <l0cust> Cale: I would use practical common lisp http://www.gigamonkeys.com/book/
17:18:53 <benzrf> kadoban: if you want to teach imperative programming
17:18:55 <benzrf> python
17:18:57 <benzrf> always python
17:19:05 <l0cust> kadoban: eventually she wants to learn Haskell
17:19:11 <benzrf> l0cust: start with haskell
17:19:16 <benzrf> other langs will not make it much easier
17:19:19 <Cale> SICP is a proper introduction to computation.
17:19:27 <benzrf> she's gonna have the same jump either way, so she might as well start with her target
17:19:40 <Jaden> I vote common lisp as the best language. But not the best for her to learn because without Paredit, it's a bich to deal with parens. Big enough a bich to discourage newbies.
17:19:49 <l0cust> Jaden: good point
17:20:06 <Cale> Common lisp is probably my least favourite choice of lisp.
17:20:10 <l0cust> Jaden: Yeah, Lisp is out
17:20:14 <l0cust> Just because of the parens
17:20:21 <Cale> It's frustrating to do any amount of functional programming in CL.
17:20:23 <l0cust> Alright C, or Python
17:20:26 <benzrf> l0cust: python
17:20:34 <Cale> l0cust: Why is C even an option?
17:20:36 <benzrf> c is for losers who need super performance and nothing else
17:20:36 <Jaden> unhygenic macros make common lisp better than scheme. But for newbie girls it's not the way to go.
17:20:41 <kadoban> C is a horrible learning language...it's a fine language for some things, but awful to teach programming.
17:20:42 <benzrf> Jaden: why newbie girls
17:20:46 <benzrf> why not just newbies
17:20:49 <benzrf> why make the distinction
17:21:09 <l0cust> just one newbie girl
17:21:11 <Cale> l0cust: I find it ridiculous that you'd consider teaching someone C, but Haskell isn't beginner friendly enough.
17:21:12 <Jaden> he's tryign to bone some girl by teaching her programming. So you don't want to freak her out with all the paren stuff. Go with something easy and satisfying to her.
17:21:23 <l0cust> lol
17:21:32 <Cale> The extent to which you can (and will) shoot yourself in the foot in C is so much larger than Haskell.
17:21:43 <Iceland_jack> Jaden: Don't be a dick
17:21:50 <l0cust> If I was trying to bone her, the last thing I would do is ask #haskell for advice
17:22:11 <BeardedCoder> huh
17:22:22 <kadoban> The extent to which you'll be completely lost might be larger in Haskell though, than C as a total newbie...but I'm not sure that's actually true.
17:22:25 <copumpkin> Jaden: not appropriate
17:22:32 <benzrf> copumpkin++
17:22:36 <Cale> It's a much more frustrating language to use, and requires a much larger amount of care and comprehension on the part of the programmer while writing programs.
17:22:39 <tommd> Yes, let's keep this channel cleaner than that.
17:22:41 <BeardedCoder> I agree, cut this conversation here.
17:22:47 <benzrf> also, that sounded kinda condescending
17:22:48 <l0cust> oh for fuck's sake, are you really all that sensitive to sex jokes?
17:23:05 <geekosaur> l0cust, they are out of line in this channel
17:23:08 <copumpkin> yes, and take it to #haskell-ops if you have a problem with it
17:23:12 <copumpkin> not worth derailing the conversation in here
17:23:15 <tommd> l0cust: I am sensitive to keeping #haskell as welcoming as it was when I started.
17:23:31 <Cale> Yeah, please keep the tone of this channel professional and welcoming to everyone.
17:23:44 <l0cust> tommd: I would sarcastically debate you, but I don't want to get kicked
17:23:46 <Iceland_jack> Indeed, not that there is much derailing you can do since this topic has been done to death
17:24:07 <l0cust> It sounds like python is the best option, sadly enough
17:24:08 <l0cust> fuck
17:24:15 <benzrf> l0cust: just start wth haskell
17:24:17 <l0cust> fuck it, haskell it is
17:24:24 <l0cust> i fucking hate python
17:24:27 <benzrf> l0cust: if she learns py first it will not benefit her much for learning haskell
17:24:27 <Iceland_jack> wow, what a worthless conversation :)
17:24:32 <benzrf> l0cust: why?!
17:24:50 <mmmm_> If you learn python first it makes you appreciate haskell more
17:25:02 <l0cust> benzrf: no type safety, tons of runtime errors, memory leaks, side effects
17:25:06 <l0cust> no compilation
17:25:10 <benzrf> huh.
17:25:14 <l0cust> slower than all hell
17:25:15 <benzrf> i appreciate some of those things
17:25:15 <benzrf> ;)
17:29:02 <copumpkin> yeah, slower than hell is a great plus
17:29:11 <copumpkin> I don't want my computer to think faster than I do; makes me feel inadequate
17:30:14 <l0cust> copumpkin: lol
17:31:39 <johnw> we should really have the Hell Benchmark
17:31:46 <johnw> to know which things are indeed, slower than hell
17:32:05 <tommd> Well I have a poorly optimized SAT solver in Haskell...
17:34:25 <monochrom> please don't hate mere programming languages :)
17:35:21 <l0cust> johnw: If it's slower than the average rails application
17:37:05 <roconnor> ocharles: why does cabal.mkDerivation ( ... src = ./.;  ... ) work?
17:37:15 <roconnor> I thought src had to be a tar.gz file
17:37:41 <l0cust> roconnor: please take your relevant topic elsewhere
17:37:54 <l0cust> #haskell is only for things completely unrelated to haskell
17:42:49 <dmj`> > do do do do 1 - do 3 + do 5 + do 333 + 4 - do subtract 4 4
17:42:51 <lambdabot>  -344
17:43:15 <hiptobecubic> ...
17:43:21 <dmj`> q.e.d
17:43:28 <dmj`> :P
17:49:15 <stolaruk> My project is set up such that I have a src directory, and a tests directory. I can do a "cabal build" with no problem, as I seem to have managed to set up my cabal file correctly. But when I try to load a file in the tests directory into ghci, it can't find the modules in src that it wants to import. Is there any easy way around this without changing the directory structure?
17:49:56 <geekosaur> -i src ?
17:50:08 <stolaruk> oo
17:50:21 <stolaruk> that's a ghci option?
17:50:29 <geekosaur> and ghc, yes
17:50:53 <enthropy> you can make the stuff in src/ be a library, and the stuff in tests/ can be a separate executable(s)
17:51:16 <enthropy> in which case you can import stuff in the src/ by adding the library to the build-depends: of the executable
17:51:44 <GeraldDev> Hello, I have a ghc-vis installation question.  I followed the instructions for Win 7, and it actually installs without error..but when attempting usage (using the :update command after running some haskell expressions) I get the error: Loading package cairo-0.12.5.3 ... linking ... ghc.exe: unable to load package `cairo-0.12.5.3' ..searched high and low for an intelligble answer in google
17:51:50 <enthropy> then just be sure to load stuff with "cabal repl" or  "caba repl executable_name"
17:52:08 <GeraldDev> cairo did install correctly...anyone know? thanks
17:52:42 <stolaruk> enthropy: ok, cool.
17:53:09 <enthropy> http://code.haskell.org/xmonad/ has that pattern now
17:53:19 <l0cust> If anyone still remembers my non-issue - I'm basically going to tell her, if she wants to learn how to program for the sake of programming, learn Python. If you want to learn for the sake of learning Haskell, then Haskell.
17:53:27 <stolaruk> enthropy: I didn't know about cabal repl. But my cabal file is probably already set up so that I can do that, let's see
17:53:34 <GeraldDev> l0cust sounbds solid
17:53:38 <GeraldDev> I always tell newbies to learn python
17:53:38 <l0cust> GeraldDev: thanks
17:53:42 <GeraldDev> pr Javascript
17:53:45 <GeraldDev> or*
17:54:05 <StoneToad> man, what happened to learning BASIC
17:54:13 <l0cust> GeraldDev: I don't like Python very much, but I know it's good for newbies, so that's why I'm sort of leaving it out there
17:54:23 <l0cust> StoneToad: the 1980's happened
17:54:26 <StoneToad> why is python good for newbies?
17:54:32 <enthropy> GeraldDev: not sure about your specific situation, but there are other times when ghci can't load stuff, but compiling a program with ghc works just fine
17:54:37 <stolaruk> i started with gwbasic
17:54:39 <l0cust> StoneToad: It's really easy to use
17:54:45 <GeraldDev> StoneToad, I think it brings a lot of paradigms into a relatively pain free environment
17:54:47 <[swift]> StoneToad: i learned so much from gorilla.bas
17:54:53 <GeraldDev> garbage collection, no make scripts etc
17:54:56 <l0cust> StoneToad: really it's just a quick/dirty language
17:55:08 <newsham> its only a little dirty :)
17:55:18 <GeraldDev> enthropy, hmm
17:55:32 <StoneToad> lol newsham
17:55:44 <newsham> <- big python fan.
17:55:47 <GeraldDev> enthropy, can you point m e in the right direction? Not sure what to do..I know Haskell on windows is problematic, but VMs run way too slow on my machine
17:56:15 <newsham> why do they run slow?  not enough ram?
17:56:27 <l0cust> GeraldDev: download more ram
17:56:30 <GeraldDev> newsham, Im not sure, but they are unusable..I got 6 GB
17:56:43 <newsham> hmm.. 6GB is plenty ram.
17:57:17 <newsham> try making a 1GB linux guest that doesnt boot into X and only boots to a console
17:57:18 <enthropy> GeraldDev: actually I dunno what this :update command is
17:57:22 <newsham> that should be pretty fast
17:57:49 <vimacs> anyone know of a library function equivalent to:   zip xs (map f xs) ... seems like a common use case. Hoogle didn't help.
17:58:06 <newsham> btw, what virtual machine prog do you use?
17:58:26 <GeraldDev> enthropy, may I link you to a very short example that I used?
17:58:26 <copumpkin> map (id &&& f)
17:58:33 <copumpkin> vimacs: ^
17:58:40 <enthropy> sure
17:58:45 <GeraldDev> http://felsin9.de/nnis/ghc-vis/#more_examples
18:00:03 <GeraldDev> I figure ghc-vis might give me more insight into how haskell evaluates things
18:00:12 <GeraldDev> being a newb at haskell :)
18:00:45 <newsham> one nice thing about tracing haskell eval is that it works pretty well with pencil and paper...  horray for equational reasoning
18:01:00 <newsham> and ref transp
18:01:15 <vimacs> copumpkin: clever, thank you!
18:01:17 <GeraldDev> yeah, thats kind of why I dedicated myself to learning it. I want to be able to do easier static analysis and static testing
18:01:29 <GeraldDev> But there are still occasions where I am not 100% what is happening
18:07:35 <kvda> is anyone else getting a lot more 'could not deduce' errors in ghc 7.8?
18:08:35 <pavonia> With rank n types?
18:11:11 <Yoctogon> as an honest question, and as a relative newbie (of course, euphemism for simply "newbie"), what are rank n types?
18:12:19 <newsham> http://www.haskell.org/haskellwiki/Rank-N_types
18:13:41 <kvda> pavonia, no just stuff like "now <- liftIO getCurrentDateTime" throws could not deduce
18:14:03 <Yoctogon> wow, its exactly as if i've forgotten to use google (sarcasm is optional)
18:14:29 <kvda> even though getCurrentDateTime has correct types, and this program compiled fine under 7.6.3
18:14:30 <newsham> i couldnt have explained it better
18:14:39 <pavonia> kvda: What's the full error message?
18:14:41 <newsham> than the haskell wiki article
18:16:14 <Yoctogon> to be fair, i wasn't necessarily asking for your answer
18:16:51 <Yoctogon> but to be fairer, i'm also lazy
18:17:03 <GeraldDev> It would be nice if there was an environment where HAskell builds just worked, and I could focus on learning haskell instead of building libraries
18:17:12 <kvda> pavonia: http://lpaste.net/8807691370937450496
18:17:13 <l0cust> Yoctogon: never concede to a neckbeard
18:17:15 <fragamus> howdy
18:17:19 <l0cust> fragamus: hey
18:18:11 <pavonia> kvda: Did you package version change for whatever package exports SqlPersistT?
18:18:22 <pavonia> I don'T think it's related to the compiler
18:19:12 <kvda> pavonia, quite possible, SqlPersistT comes from Persistent
18:20:36 <kvda> pavonia, there's also this -> https://ghc.haskell.org/trac/ghc/ticket/8994
18:20:50 <machineslearn> GeraldDev: tried fpcomplete?
18:20:56 <GeraldDev> this is kind of maddening...I run "ghc-pkg list" and it shows cairo
18:21:20 <machineslearn> (re: learning Haskell)
18:21:28 <GeraldDev> machineslearn,  thanks, I will look into that now
18:21:45 <kvda> GeraldDev, also how do you have env setup? what's causing the troubles?
18:21:57 <kvda> *your haskell env
18:22:26 <GeraldDev> kvda, its a win 7 box, with the latest "Haskell Platform" installed.  I havent had problems until trying to get this ghc-vis package installed
18:22:39 <GeraldDev> but then again, I havent installed any packages until now..just been doing learn you a haskell
18:22:46 <pavonia> kvda: Yeah, that ticket involves higher rank types, I'm not sure if this the case in your example too
18:23:14 <kvda> pavonia, i see, thanks for your help :)
18:23:23 <pavonia> no problem
18:23:35 <newsham> cabal hell can be frustrating
18:24:26 <GeraldDev> aye
18:24:29 <MrRacoon> newsham: have you ever used sandboxes?
18:24:39 <MrRacoon> and does that help ward off cabal hell?
18:24:40 <GeraldDev> spent a total of maybe 8 hours on this..reminds me of my old linux admin days...
18:25:23 <GeraldDev> For all of windows faults..one thing you can say for sure, is it does dev tools pretty well
18:25:30 <GeraldDev> meaning VS
18:25:39 <GeraldDev> let me stop whining.
18:25:58 <newsham> mrraccoon: no, i havent
18:26:22 <newsham> geralddev: i cant agree about vs :(
18:26:28 <kvda> GeraldDev, I'm sure a port of any Microsoft products would have equal ore more amount of problems on linux
18:27:05 <kvda> With open source stuff you're always better running it on *nix
18:27:12 <GeraldDev> yeah
18:27:26 <benzrf> vim > all
18:27:27 <GeraldDev> maybe I should just buy a new box if I am serious about HAskell?
18:27:32 <kvda> haskell-platform is too massive for my liking
18:27:34 <GeraldDev> That natively runs ubuntu or mint or something?
18:27:40 <benzrf> GeraldDev: 'natively runs'
18:27:55 <benzrf> as in, has any of the major types of chip
18:27:57 <benzrf> ?
18:28:00 <GeraldDev> um, I mean installed as the main OS I suppose
18:28:11 <GeraldDev> no virtual machine
18:28:15 <benzrf> why does it matter if it's preinstalled
18:28:17 <kvda> GeraldDev, you can dual boot (haha) or just a vm
18:28:45 <GeraldDev> yeah I could do a dual boot
18:28:54 <GeraldDev> I just have an aversion to it
18:29:02 <GeraldDev> because I multi task
18:29:03 <machineslearn> seriously, fpcomplete might be adequate if you're just interested in going through lyah for now
18:29:05 <kvda> yeah dual boot is very 1990s
18:29:10 <GeraldDev> and I dont like not being able to do my windows stuff
18:29:20 <kvda> VM is the solution you're looking for
18:29:22 <GeraldDev> ok machineslearn will do
18:29:25 <GeraldDev> thank you
18:29:58 <kvda> can you save/version control stuff on fpcomplete?
18:29:59 <GeraldDev> kvda, I would, but I dont like the slow performance I am seeing
18:30:05 <GeraldDev> I have a ubuntu VM..and its unbarable
18:30:41 <kvda> does it have enough ram/disk space? if you're computer is fairly new you shouldn't have problems running multiple vm's
18:30:52 <GeraldDev> this box is 4.5 years old
18:30:59 <GeraldDev> longest I ever used the same machine :)
18:31:59 <kvda> right, still i don't see why it should be painfully slow, maybe ubuntu is your problem, install a more minimal distro or something with a lighter Window Manager
18:32:13 <benzrf> just install a better WM
18:32:16 <benzrf> no need to distro hop o_O
18:32:32 <GeraldDev> hmm, that might be the ticket, dump the window manager all together
18:32:35 <kvda> yea true
18:32:36 <GeraldDev> just go console
18:32:42 <kvda> yeap
18:32:51 <GeraldDev> thanks
18:33:22 <machineslearn> kvda: it has integration with github
18:34:37 <machineslearn> there is also https://www.fpcomplete.com/school
18:35:46 <newsham> Failed to install temporary-1.2.0.2
18:39:50 <sohum> hey, so did http://hackage.haskell.org/package/DSH ever go anywhere?
18:40:07 <sohum> the idea behind it, at least?
18:42:47 <GeraldDev> woooo fpcomplete ain't free...just like freedom
18:45:14 <machineslearn> "Free Community Edition"
18:45:58 <machineslearn> https://www.fpcomplete.com/page/project-build
18:46:04 <newsham> who is charging for freedom?
18:46:11 <newsham> you should askfor a refund
18:47:25 <GeraldDev> newsham, some country music guy said that
18:47:38 <GeraldDev> to voice his support for the wars in Iraq and Afghanistan
18:48:00 <newsham> you didnt give him any money, I hope
18:48:02 <GeraldDev> (I was being sarcastic)
18:48:09 <GeraldDev> lol no
18:49:13 <machineslearn> Alos, you can get to the IDE from School of Haskell tutorials.  Just click on the "Open in IDE" link at the top of a box of code and it will load it into the IDE, where you can modify it, etc.
18:50:52 <GeraldDev> oh ok cool
18:53:25 <flazz> how can i specify type signatures for equations in ghci?
18:54:17 <WraithM> flazz: In what sense?
18:54:33 <flazz> the multiline sense
18:54:50 <nisstyre> flazz: I think you can use :{ :} or whatever the syntax is
18:54:52 <nisstyre> I always forget
18:55:18 <flazz> nisstyre: that works :) thanks
18:56:03 <nisstyre> it does?
18:56:07 * nisstyre is actually surprised
18:56:15 <flazz> the first one did
18:56:22 <flazz> :) still figuring out the way to close it
18:56:40 <nisstyre> I don't think it will work, I just tried
18:56:49 <flazz> it actually did
18:56:54 <flazz> :{ ... :}
18:57:01 <nisstyre> okay
18:57:04 <flazz> thanks
18:58:12 <GeraldDev> thats whats awesome
18:58:20 <GeraldDev> You half remember something and it actually works in haskell
18:58:24 <GeraldDev> thats why I am here doing this
18:58:32 <flazz> too bad the up arrow goes line by line instead of input by input
18:59:56 <GeraldDev> so often I am surprised that my haskell works
19:00:07 <GeraldDev> But because haskell is based on good principles, I get very lucky
19:01:51 <c_wraith> GeraldDev: that's not luck.
19:02:01 <GeraldDev> true that
19:02:23 <c_wraith> GeraldDev: that's the whole point of haskell.  One of the regulars here said recently that he frequently writes code he's not smart enough to write. :)
19:02:33 <GeraldDev> hahahah IU like that
19:03:47 <albeit_> Does forcing the evaluation of variable "myVar = printf "%s %s" foo bar"" do anything? Or is it already at WHNF?
19:04:18 <c_wraith> albeit: depends on the type.  printf is return-type polymorphic.
19:05:02 <c_wraith> albeit: if it's generating an IO action, it's already at WHNF.
19:05:26 <albeit_> c_wraith: Let's say myVar :: String, and it's not generating any IO action, just trying to get that string.
19:05:30 <copumpkin> > let myVar = printf "haha %s %d" "oink" 5 in myVar
19:05:32 <lambdabot>  No instance for (GHC.Show.Show a0)
19:05:32 <lambdabot>    arising from a use of ‘M13982137549249470210419.show_M13982137549249470210...
19:05:32 <lambdabot>  The type variable ‘a0’ is ambiguous
19:05:32 <lambdabot>  Note: there are several potential instances:
19:05:32 <lambdabot>    instance [safe] GHC.Show.Show
19:05:37 <copumpkin> > let myVar = printf "haha %s %d" "oink" 5 in myVar :: String
19:05:38 <lambdabot>  "haha oink 5"
19:05:39 <c_wraith> albeit: if it's returning a String, it will do *some* work.  It will do exactly as much work as it needs to do to determine whether the result String is empty or not.
19:05:49 <copumpkin> > let myVar = printf "haha %s %d" "oink" 5 in take 6 (myVar :: String)
19:05:50 <lambdabot>  "haha o"
19:05:55 <copumpkin> > let myVar = printf "haha %s %d" "oink" undefined in take 6 (myVar :: String)
19:05:56 <lambdabot>  Could not deduce (Text.Printf.PrintfArg t0)
19:05:56 <lambdabot>    arising from a use of ‘Text.Printf.printf’
19:05:56 <lambdabot>  from the context (Text.Printf.PrintfType t)
19:05:56 <lambdabot>    bound by the inferred type of
19:05:56 <lambdabot>             myVar :: Text.Printf.PrintfType t => t
19:06:04 <copumpkin> > let myVar = printf "haha %s %d" "oink" (undefined :: Int) in take 6 (myVar :: String)
19:06:05 <lambdabot>  "haha o"
19:06:51 <albeit_> c_wraith: Oh boy. So if I'm concatenating a bunch of slightly different myVar's thousands of times, I'm going to build up a massive number of thunks, even if I force evaluation of them. Correct?
19:07:08 <albeit_> It won't force the evaluation to one long string?
19:07:13 <c_wraith> albeit_: yep.  deepseq is what you want here
19:07:19 <c_wraith> deepseq/rnf
19:07:22 <copumpkin> wait, not necessarily
19:07:26 <copumpkin> if you write for example
19:07:49 <saml_> > printf "%s %d" "a" (undefined :: Int)
19:07:50 <copumpkin> foo = concat (map (printf "haha: %s") [1..1000000])
19:07:50 <lambdabot>  No instance for (GHC.Show.Show a0)
19:07:51 <lambdabot>    arising from a use of ‘M485563962177222753110501.show_M4855639621772227531...
19:07:51 <lambdabot>  The type variable ‘a0’ is ambiguous
19:07:51 <lambdabot>  Note: there are several potential instances:
19:07:51 <lambdabot>    instance [safe] GHC.Show.Show
19:07:57 <copumpkin> nothing wrong with that
19:08:35 <albeit_> copumpkin: But if printf is being passed a number of other variables, I have to deepseq?
19:08:54 <albeit_> copumpkin: Only when it's being passed literals I don't need to deepseq?
19:09:20 <copumpkin> hrm, you should very rarely need to deepseq
19:09:22 <copumpkin> in general
19:10:16 <albeit_> Well, more details about my case, I'm taking each line in a file, generating variables based on that line, and making a new line, all in a fold. And it is extremely quickly overflowing memory
19:10:37 <copumpkin> why a fold?
19:11:04 <albeit_> comboy: It need to maintain a sort of state flag about past lines.
19:11:15 <albeit_> * copumpkin
19:11:21 <copumpkin> can I see the code?
19:11:31 <copumpkin> hard to speak abstractly
19:11:37 <copumpkin> foldl is almost never what you want, if you're using that
19:11:56 <albeit_> No I'm using foldl', I'll grab the code one second
19:12:57 <mikeplus64> when would you ever want Data.List.foldl (as opposed to Foldable's, which might be fine depending on the instance)?
19:13:08 <albeit_> Shoot, I didn't add the folder to Dropbox, don't have the code right now...
19:13:26 <copumpkin> oh wait, so you're accumulating state but effectively a map?
19:13:57 <copumpkin> mapAccumL might be closer to what you want in that case
19:14:08 <copumpkin> and might fix some of your immediate issues
19:14:13 <napping> mikeplus64: I once say someone claim it was the right thing, some tricky buisiness about lazy caching or something
19:14:24 <albeit_> Best way I can describe it, the lines are in sequence "XooYoo", and each o needs to know the most recent capital letter that was found.
19:15:55 <albeit_> mapAccumL looks pretty dead on...
19:16:19 <albeit_> copumpkin: Thanks!
19:16:23 <copumpkin> no problem
19:16:51 <copumpkin> still worth figuring out what was wrong with the original code
19:16:53 <albeit_> copumpkin: Actually, it will make it cleaner, but won't I still run into the same issues with accumulating thunks of printf instead of the actual Strings?
19:16:54 <copumpkin> if you can reconstruct it somehow
19:17:02 <Noldorin> is liftA equivalent to <$> for Applicatives?
19:17:09 <copumpkin> Noldorin: yes
19:17:13 <Noldorin> copumpkin, thanks
19:17:28 <copumpkin> albeit_: I don't _think_ so, but it's hard to say for sure. Accumulating thunks isn't really a problem; accumulating nested ones is
19:18:27 <copumpkin> albeit_: keep in mind that you aren't building up all the thunks at once, either
19:18:33 <copumpkin> they'll get built as you force the list
19:18:37 <copumpkin> and possibly consumed immediately
19:19:00 <albeit_> I'm calling a putStrLn $ unlines myList after the fold
19:19:24 <albeit_> where myList is the second in a pair output from the fold, (accumState, myList)
19:19:35 <copumpkin> that's all lazy. But your fold could easily build up a big pile o' nested thunks
19:20:12 <albeit_> Okay. One thing I tested was just changing the "myVar = printf ..." to "myVar = replicate 100 '1'", and it worked fine
19:20:16 <napping> Noldorin: They might possibly differ if a Functor or Applicative instance is broken - <$> is fmap, liftA f a = pure f <*> a
19:20:35 <Noldorin> mhm
19:20:44 <Noldorin> hopefully won't run into such a case though...
19:21:35 <napping> It's a bug if they aren't the same, but just in case you were having trouble defining your own applicative or something, it might come up
19:22:59 <Noldorin> napping: yeah. just a theoretical question for now, but that's worth bearing in mind, thanks.
19:45:40 <l0cust> what are we all up to
19:46:23 <benzrf> fun stuff
20:45:11 <roconnor> @ask ocharles Is this the right way to override transfomers to 0.4.1? http://lpaste.net/103792
20:45:12 <lambdabot> Consider it noted.
20:46:16 <mcjohnalds> If I have a data type like `data A = A { foo :: Int }`.  Is there a way to rewrite record updates like `\a x -> a { foo = x }` as just `\x -> { foo = x }` (other than lenses)?
20:46:53 <shachaf> No, that's a syntax error.
20:47:28 <mcjohnalds> Yea, sadly that exact way isn't valid, but is there something like it?
20:47:40 <geekosaur> nope
20:48:05 <geekosaur> this deficiency is probably the thing that turns the majority of haskellers onto lens
20:49:00 <mcjohnalds> Yea, record syntax related anything is just a huge eyesore amongst haskell's otherwise clean code. Thanks for the info though!
20:51:40 <shachaf> Or onto lenses in general.
20:52:16 <geekosaur> indeed
20:57:50 <dmj`> mcjohnalds: there's record wild cards as well
20:58:46 <dmj`> let g :: A -> Int; g A{..} = foo + 1
20:58:59 <dmj`> g $ A 4 == 5
20:59:17 <dmj`> g (A 4) == 5
21:00:23 <mcjohnalds> dmj: I have seen those, they're very helpful when accessing data structures with many entries, but sadly they don't help much with updating them
21:01:11 <dmj`> mcjohnalds: yea, when you need to access things at a deeper level it's difficult
21:01:42 <mcjohnalds> I hope some better syntax is on the way soon!
21:01:58 <dmj`> mcjohnalds: lenses aren't too difficult to use
21:05:20 <mcjohnalds> dmj: lenses are apparently the only solution, and they're neat, but I struggle to read half the type signatures
21:11:50 <flebron> Hey, exploring Howard-Curry. Simply typed lambda calculos has no notion of top and bottom, does it?
21:12:15 <flebron> I get how one can construct sums, products, and (obviously) functions, but how are those two created?
21:12:35 <flebron> (In Haskell they'd be () and Void, if I'm not mistaken.)
21:15:05 <YellPika> flebron: Bottom should not exist, seeing as STLC is strongly normalizing.
21:15:32 <YellPika> I don't see why top shouldn't though.
21:17:27 <carter> flebron: hows the install working :)
21:20:55 <flebron> carter: Just fine :) Had some issues with installing Agda this morning, since alex and happy were still in /usr/bin
21:21:01 <carter> hahah
21:21:03 <flebron> Deleted them and everything was fine :)
21:37:53 <Sonarpulse> is there any good way with hspec to run a test on a bunch of files?
21:38:03 <Sonarpulse> I'd like each file to show up as its own test
21:38:57 <Sonarpulse> but the interface relating to IO between tests (needed for getDirectoryContents) is all IO () all the time
21:39:50 <carter> Sonarpulse: theres kinda a thing
21:39:53 <carter> ohh
21:39:56 <carter> wait
21:40:01 <carter> you mean "read a resource in"
21:40:17 <Martty> http://i.imgur.com/PtDTQ4G.png what say you?
21:40:41 <carter> Martty: "boom you die"
21:40:43 <carter> could happen
21:40:50 <Martty> ppff
21:41:07 <Martty> is it pqr or (pqr, prq)?
21:41:13 <carter> i choose 7
21:41:14 <carter> :)
21:41:36 <carter> it could happen if Eve is nearby while adam and jill are talking
21:41:37 <carter> or whatever
21:42:47 <Sonarpulse> carter yeah looks like the data type queues up a bunch of (IO () -> IO () is internally
21:42:59 <Sonarpulse> and runs them later
21:43:15 <carter> Sonarpulse: i know that tasty has some explicit support fo resource loading
21:43:38 <Sonarpulse> is that a competitor? I am find switching
21:44:21 <Sonarpulse> this hspec seems to value being cutsy over being powerful
21:44:43 <carter> @hackage tasty
21:44:44 <lambdabot> http://hackage.haskell.org/package/tasty
21:44:48 <carter> http://documentup.com/feuerbach/tasty
21:45:11 <carter> eh, its good theres several actively deved options
21:46:09 <Sonarpulse> you mean competing test frameworks?
21:47:23 <carter> yes
21:47:29 <carter> DUAL and DUEL both
21:47:37 <Sonarpulse> I guess in theory, but based on what little I have tried over the years, it seems like they all need a lot of work so combining efforts might help
21:47:46 <Sonarpulse> hopefully this tasty will prove me wrong :)
21:51:35 <solirc> Sonarpulse: What exactly do you want to do?
21:51:57 <Sonarpulse> so I am writing a compiler
21:52:24 <Sonarpulse> and as tests I have a directory of programs that shouldn't type-check, a directory taht should, etc
21:53:32 <solirc> Sonarpulse: So you have something like (IO Spec) a some point, I guess?
21:53:59 <Sonarpulse> sure
21:55:13 <Sonarpulse> well IO [Spec]
21:55:26 <Sonarpulse> I could easily make one test that mapped the predicate on all the files
21:55:29 <Sonarpulse> but that wouldn't be so nice
21:55:53 <solirc> Sonarpulse: You can go from [Spec] to Spec
21:57:58 <solirc> Sonarpulse: So if you have
21:58:01 <solirc> spec :: IO [Spec]
21:58:12 <solirc> you can just
21:58:13 <solirc> main = sequence_ spec >>= hspe
21:58:25 <solirc> Sonarpulse: What will not be so nice?
21:58:53 <Sonarpulse> let me look at hspe
21:59:04 <solirc> ^ hspec
21:59:24 <solirc> I'm pretty sure that you can do what you want.
21:59:37 <Sonarpulse> oh I see, you wrote main
21:59:39 <solirc> It may not work with hspec-discover
21:59:47 <Sonarpulse> ^ exactly what i was goign to say
22:00:07 <solirc> but then again, non of the alternatives out there provide anything like hspec-discover
22:00:57 <Sonarpulse> honestly i may just sin and unsafePerformIO
22:01:19 <Sonarpulse> I told carter about this compiler earlier
22:01:22 <Sonarpulse> it is due very soon
22:02:03 <Sonarpulse> and refactoring tests for this, or slapping all the files in one unit test (because Expaction = IO () ===> things are easier with that)
22:02:16 <Sonarpulse> will take longer and give me a less usefull result
22:02:43 <solirc> Sonarpulse: for reflecting the some file names that are in some directory that may work, but of course it's dirty
22:03:34 <Sonarpulse> I hope to mess around with this a bit after it's due
22:03:37 <Sonarpulse> I'll fix it then
22:03:47 <solirc> Sonarpulse: hspec2 will improve a lot of things (say initializing stuff before each test or once before the whole test, or a subtree...)
22:04:09 <Sonarpulse> i was going to say submite a pull request, but maybe they got me covered :)
22:04:13 <solirc> Sonarpulse: But it would be super useful if you open a ticket on github for your exact use case
22:04:27 <solirc> so that we can try to cover this, too
22:05:59 <Sonarpulse> sure
22:06:02 <Sonarpulse> are you on the team?
22:10:26 <solirc> Sonarpulse: yes
22:11:34 <Sonarpulse> ah cool
22:12:07 * hackagebot tls-debug 0.3.3 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.3 (VincentHanquez)
22:12:13 <Sonarpulse> besides this, the other big thing I have yet to see any framework address is testing private stuff in modules
22:12:23 <solirc> Sonarpulse: Also feel free to ask questions in #hspec anytime ;)
22:12:44 <Sonarpulse> sure!
22:14:08 <Sonarpulse> the way your preprocessesor promotes one _Spec.hs for every module might help with that
22:20:39 <redtricycle> How do I read the "haddock" documentation for http-conduit-browser?
22:21:22 <Sonarpulse> solirc the class will be over tomorrow
22:21:32 <Sonarpulse> then I can and will open source compiler
22:21:34 <dmj`> redtricyle: here you are: http://hackage.haskell.org/package/http-conduit-browser-1.9.0.2/docs/Network-HTTP-Conduit-Browser.html
22:21:43 <Sonarpulse> which will hopefully make for a better github issue
22:21:51 <dmj`> that page is generated by the took haddock
22:21:54 <dmj`> tool*
22:22:34 <redtricycle> Do I need to be in the package directory?
22:23:07 <solirc> Sonarpulse: Cool!
22:23:11 <vermeille> Hey guys, I'm trying to compile those two ridiculous lines. I'm pretty new to lenses, so that will certainly look obviously stupid to a more advanced Haskeller http://lpaste.net/103795
22:23:24 <solirc> Sonarpulse: BTW, it's not a preprocessesor, it's a code generator
22:23:48 <solirc> Sonarpulse: We just make creative use of GHC's support for preprocessesors
22:25:07 <Sonarpulse> yeah so GHC's interface here is sort of like an special-case alternative to template haskell?
22:25:08 <dmj`> redtricycle: what do you mean the package directory?
22:25:39 <solirc> Sonarpulse: Haha, if you want to call it like that :D
22:25:57 <solirc> Sonarpulse: The thing is that template-haskell does not allow you to generate imports
22:26:02 <solirc> so you could not do that with th
22:26:06 <Sonarpulse> ah
22:28:33 <Sonarpulse> well I've read something I liked saying TH needed to be split into a couple of macro langauges that operate in different phases, I guess this GHC feature fits in with that idea a bit.
22:29:15 <Sonarpulse> have you thought about how to eventually bypass restricted exports to allow testing of module-private stuff?
22:29:32 <Sonarpulse> or is that not a goal ATM for hspec
22:29:33 <flebron> What's an example of two distinct Sorts?
22:29:54 <Sonarpulse> Int :: *; List :: * -> *
22:30:43 <flebron> Aren't those just different kinds?
22:30:54 <Sonarpulse> oh yeah my bad
22:32:55 <solidus-river> hey all, i have a problem, new to haskell so probably missing an obvouse answer
22:33:08 <solidus-river> i'm using System.Directory to loop over a list of files and esure they all exist
22:33:17 <solidus-river> the problem happens because once i have
22:33:32 <solidus-river> fmap doesFileExist dirList i hav ea list of IO Bool
22:33:51 <solidus-river> and i cant think of how to collapse [IO Bool] -> IO Bool via and
22:33:56 <solidus-river> i keep getting type errors
22:34:07 <dmj`> @typ sequence
22:34:07 <solirc> Sonarpulse: Due to the compiled nature of Haskell/GHC I'm not sure if there is much that we can do in Hspec here.  But there are two approaches that I use here.
22:34:08 <lambdabot> Monad m => [m a] -> m [a]
22:34:56 <solirc> Sonarpulse: Testing package private modules (read: stuff that is listed under other-modules in your cabal file)
22:35:06 <solidus-river> so i should do something like
22:35:10 <solirc> Sonarpulse: Here you can just add the source directory to your test-suite
22:35:21 <solidus-river> fmap and $ sequence [IO Bool]
22:35:21 <Sonarpulse> ok yeah
22:35:23 <dmj`> @typ liftM and . sequence
22:35:24 <lambdabot> Monad m => [m Bool] -> m Bool
22:35:46 <solirc> Sonarpulse: like so: https://github.com/hspec/hspec/blob/master/hspec.cabal#L80
22:36:18 <solidus-river> dmj` thanks for the help :) is it preferred to use fmap or liftM i found some debate saying that liftM should probably not be used anymore
22:36:34 <solirc> Sonarpulse: This has the disadvantages that everything is compiled twice (once for the library, once for the test-suite), but I don't know of any better solution
22:36:46 <dmj`> solidus-river: you could also do something like forM_ filesInDir $ \file -> doesFileExist file >>= \exists -> when exists $ do { .. }
22:37:10 * hackagebot influxdb 0.2.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.2.2 (MitsutoshiAoe)
22:37:13 <solirc> Sonarpulse: Building on top of his, if you want to test private functions you can optionally export them for the test suit with CPP
22:37:52 <Sonarpulse> yeah HTF IIRC did something like that
22:38:17 <solirc> Sonarpulse: like so https://github.com/vimus/vimus/blob/master/src/Command.hs#L8
22:38:53 <solirc> Sonarpulse: and then add something like this to your cabal file https://github.com/vimus/vimus/blob/master/vimus.cabal#L96
22:39:16 <Sonarpulse> nice
22:39:21 <solirc> Not super nice, but I don't know of any better solutions.
22:39:31 <Sonarpulse> one cool thing would be to intersect the export list with non-test modules' import list, to avoid collisions
22:40:26 <solirc> Sonarpulse: I don't understand yet what you mean.  Can you elaborate?
22:40:26 <flebron> what's an example of something of kind (* -> *) -> *?
22:40:31 <dmj`> @typ filterM doesFileExist
22:40:32 <lambdabot> Not in scope: ‘doesFileExist’
22:40:42 <dmj`> solidus-river ^
22:40:46 <Sonarpulse> so say module B imports module A
22:40:57 <Sonarpulse> both define something called asdf
22:41:05 <Sonarpulse> but module A doesn't export asdf
22:41:10 <dmj`> :k StateT Int
22:41:11 <lambdabot> (* -> *) -> * -> *
22:41:22 <supki> flebron: Fix
22:41:43 <Sonarpulse> if you #ifdef the export lists, now any usage of asdf in module B will be unresolvable
22:41:52 <flebron> Cool, thanks :)
22:42:11 <raulfpl> is there an equivalent of >> but that discards the result of the second instead of the first
22:42:11 <raulfpl> ?
22:42:30 <napping> Applicative has a *>
22:42:35 <supki> raulfpl: <* from Control.Applicative
22:42:57 <napping> yeah, that one keeps the left argument
22:44:16 <Sonarpulse> solirc make sense?
22:45:05 <dmj`> @typ (<$)
22:45:06 <lambdabot> Functor f => a -> f b -> f a
22:45:25 <dmj`> > 1 <$ Just 4
22:45:26 <lambdabot>  Just 1
22:45:37 <dmj`> raulfpl ^
22:45:47 <dmj`> @typ (<*)
22:45:48 <lambdabot> Applicative f => f a -> f b -> f a
22:45:59 <dmj`> oh, you probably want the lifted one
22:46:57 <raulfpl> char '(' >> return expr <* char ')'
22:47:01 <raulfpl> will that work?
22:47:24 <solirc> Sonarpulse: ok, got it
22:47:38 <newsham> if you use <$ cant you get rid of the "return"?
22:47:43 <solirc> not sure how one would approach this
22:48:25 <Sonarpulse> yeah will require a stronger tool than CPP
22:48:41 <napping> raulfpl: the precedence is a bit off, <*> and variants bind tighter than >> or >>=
22:49:27 <Sonarpulse> I dunno, maybe something i can submit a pull request for this summer :)
22:51:01 <raulfpl> I'm trying to figure out the most elegant way to write "do{ char ’(’; x <- expr; char ’)’; return x}"
22:52:37 <newsham> oh, expr is a parser.. so you dont need the return
22:52:51 <newsham> char '(' >> (expr <* char ')')   ?
22:53:12 <dmj`> char '(' *> expr <$ char ')'
22:53:12 <newsham> char '(' *> expr <* char ')'  ?   does that work?
22:54:15 <haasn> newsham's last example seems right
22:54:23 <haasn> >> is *>
22:54:42 <haasn> And if you're asking about the parsing: Yes, that parses the way you want it to parse in that example
22:56:49 <raulfpl> Yes, I'm asking about parses. Thank you.
22:57:07 <haasn> raulfpl: To answer your question: “parens expr”
22:57:44 <haasn> Not sure which parsing library you're using, but I think they all have some concept of “parens”
22:58:20 <newsham> parens f = char '(' *> f <* char ')'   ?
22:58:52 <haasn> newsham: usually modulo some whitespace, I guess
22:59:08 <raulfpl> I'm using Parsec and I'm aware of 'parens' but I asked because I'm still getting used to monads and that stuff
22:59:14 <haasn> I think there's a helper for f l r x = l *> x <* r -- too
22:59:33 <haasn> raulfpl: Applicative notation can definitely do great wonders for parsec-style parsers
22:59:44 <haasn> raulfpl: I suggest you learn about that class if you haven't already
23:01:13 <raulfpl> I read about applicative functors in LYAH but I'm not confortable with them yet.
23:01:44 <newsham> have you seen http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/comment-page-1/?
23:02:50 <raulfpl> newsham: not yet
23:04:12 <Sonarpulse> I notices that -fwarn-incomplete-patterns does not care about patterns in lambdas, is there another warning that does?
23:04:47 <Sonarpulse> e.g. "\[a] -> ..." is perfectly legit as far is that warning is concerned
23:05:08 <raulfpl> I'll read it tomorrow, now I need some sleep. Bye. Thanks for the help
23:07:44 <newsham> > ala Sum foldMap [1,2,3]
23:07:45 <lambdabot>  6
23:07:53 <newsham> > ala Sum foldMap [1.0,2.0,3.0]
23:07:54 <lambdabot>  6.0
23:08:22 <newsham> hmm isnt floating point non-assoc?
23:08:37 <newsham> flawed monoid?
23:09:49 <jle`> yea
23:09:52 <jle`> flawed Eq
23:09:54 <jle`> and Ord
23:10:13 <jle`> so...it has bigger problems :)
23:10:31 <jle`> and flawed Num for any reasonable Num laws
23:10:56 <newsham> so dont use floating point in any haskell prog? :)
23:11:11 <jle`> just don't expect it to obey any laws
23:11:13 <jle`> :P
23:11:17 <jle`> it's a triumph of engineering tho
23:11:24 <glguy_> Or at least don't use Floating point in a function that is parameterized over an arbitrary Num/Eq/Ord/etc
23:11:25 <jle`> not so much for math
23:11:31 <Sonarpulse> gbye #haskell
23:11:37 <glguy_> and use it just for the overloading of names
23:11:39 <flebron> Other than parametricity results, what are good invariants that I can have with Haskell which I wouldn't have with, say, C?
23:11:47 <flebron> *static, type invariants
23:12:06 <flebron> *assuming no bottom and no unsafe stuff
23:14:22 <solidus-river> is there an os independent way to concatenate filepaths in haskell?
23:14:58 <solidus-river> or does haskell expect Unix style on all platforms and then the interpretor converts
23:15:00 <johnw> flebron: "uninitialized value" has no meaning
23:15:15 <glguy_> (System.FilePath.</>) :: FilePath -> FilePath -> FilePath
23:18:25 <newsham> > (reverse `mappend` id) "testing "
23:18:27 <lambdabot>  " gnitsettesting "
23:19:01 <newsham> > "usr" </> "local" </> "bin"
23:19:03 <flebron> johnw: Anything else? I'm looking for something I can know by just looking at the type of a function.
23:19:03 <lambdabot>  Not in scope: ‘</>’
23:19:03 <lambdabot>  Perhaps you meant one of these:
23:19:03 <lambdabot>    ‘<*>’ (imported from Control.Applicative),
23:19:03 <lambdabot>    ‘<+>’ (imported from Control.Arrow),
23:19:03 <lambdabot>    ‘<+>’ (imported from Text.PrettyPrint.HughesPJ)Not in scope: ‘</>’
23:19:58 <johnw> flebron: you know what possible effects it may have
23:20:13 <johnw> (assuming no use of unsafePerformIO)
23:21:35 <flebron> Ah, yes, that's good :)
23:22:18 <johnw> also, you know if an argument can mutated "in-place"
23:22:29 <johnw> because it will have been imported from a module like Data.Vector.Mutable
23:22:44 <johnw> or be a data type containing a TVar, etc.
23:23:13 <newsham> you know statically which functions are pure and what all the inputs are (including their types) which allows you to automate generation of test cases
23:23:53 <johnw> by "pure" in that sense, do you mean functions which do not execute in IO?
23:24:20 <johnw> or do you mean any monad without observable side-effects?
23:24:50 <newsham> code that is strictly a function of explicit inputs
23:29:04 <newsham> > sortBy (comparing length ++ compare) (words "here is a bunch of words to sort first by length and then alphabetically")
23:29:05 <lambdabot>  Couldn't match expected type ‘[a0]’
23:29:05 <lambdabot>              with actual type ‘[a1] -> [a1] -> GHC.Types.Ordering’Couldn't ma...
23:29:05 <lambdabot>                                -> GHC.Base.String -> GHC.Types.Ordering’
23:29:05 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a0]’
23:29:05 <lambdabot>              with actual type ‘a2 -> a2 -> GHC.Types.Ordering’
23:29:15 <newsham> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words to sort first by length and then alphabetically")
23:29:16 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
23:29:18 <newsham> cute
23:29:28 <johnw> <> is cuter
23:29:43 <newsham> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort first by length and then alphabetically")
23:29:44 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","first","words",...
23:29:46 <newsham> danke
23:29:51 <jle`> i don't remember the last time i used mappend
23:29:55 <jle`> maybe that's a bad thing
23:30:03 <jle`> even passing functions i use (<>)
23:30:08 <newsham> these derived monoids are nice
23:30:10 <johnw> i use it because I use Data.Semigroup, so I used mappend if I only have a Monoid constraint
23:30:10 <jle`> like foldr (<>) mempty
23:30:29 <jle`> do you have to hide (<>) from Data.Monoid if you use Data.Semigroup?
23:30:36 <startling> yeah.
23:30:42 <jle`> shame
23:30:46 <johnw> just don't import Data.Monoid
23:30:52 <jle`> oh yeah
23:30:53 <startling> I use (<>), unless I'm using Semigroup for some reason.
23:30:57 <jle`> is mempty in prelude?
23:31:02 <newsham> class Semigroup m => Monoid m ?
23:31:03 <startling> no.
23:31:09 <newsham> someday?
23:31:10 <startling> no.
23:31:12 <startling> er
23:31:22 <startling> first no was to jle`, second was to newsham. :)
23:31:33 <johnw> no's all around
23:31:37 <jle`> but because of the transitive property
23:31:44 <jle`> they can commute
23:32:03 <jle`> assuming no-ness forms an equivalence relationship
23:32:22 <jle`> well, i have to import Data.Monoid if i want mempty, so i guess more hiding all around.
23:32:26 <startling> jle`, no.
23:32:32 <jle`> hm?
23:32:54 <startling> I don't think "no" is an equivalence relation. :)
23:33:07 <johnw> I do believe Data.Semigroup re-exports mempty
23:33:15 <jle`> it cna form an equivalence class
23:33:18 <jle`> two distinct ones?
23:33:23 <newsham> no no != yes
23:33:31 <startling> johnw: oh, nice
23:34:40 <newsham> haskell keeps doing this.. they start off with an improperly structure class heirarchy for convenience then slowly over time migrate to a properly structured one
23:34:56 <newsham> isnt it getting a little old? :)
23:35:42 <newsham> ie. functor, applicative, monad
23:35:55 <johnw> they didn't know about applicatives
23:36:11 <johnw> it's not like everything in present day Haskell was available back then and they were just being obtuse
23:36:24 <newsham> *nod*
23:36:26 <johnw> things have evolved
23:37:02 <newsham> but now instead of fixing them all one by one, why not look at what we have and say "ok, lets make Category and Semigroup and Monoid and ...  all fit properly"
23:37:19 <newsham> or i guess just do it all in slow motion like they're gonna do anyway :)
23:37:26 <johnw> :)
23:37:33 <johnw> there are many dimensions of pain
23:37:37 <johnw> pick one
23:37:58 <startling> newsham: bcause we don't know yet whether they're particularly useful for writing programs.
23:38:12 <johnw> people got super excited about Arrows for a while
23:38:22 <johnw> now even the crickets hear crickets
23:38:31 <startling> and backwards-compatibility is nice, and people don't like writing instances they don't care about.
23:38:32 <solidus-river> newsham: that would require either a maintainer to make the decision to break backwords compatability and come up with a deprication warnign system
23:38:57 <solidus-river> newsham: or someone to fork ghc / prelude and have it catch on / surpass other things by some act of amazingness
23:39:28 <newsham> i gotta say, conal's example game in arrows code was beautiful..  i wish there could be programs like that...
23:39:37 <newsham> i've never written a single useful piece of code with arrows
23:39:41 <solidus-river> newsham, link?
23:40:58 <newsham> http://www.thenewsh.com/~newsham/x/machine/paddleball.hs
23:42:45 <solidus-river> newsham: is -< the same as ==< ?
23:44:09 <newsham> i dont know what ==< is
23:44:32 <newsham> x <- f -< y     is do-arrow notation
23:44:47 <newsham> see the arrow head and arrow tail?
23:45:16 <newsham> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/arrow-notation.html
23:47:49 <newsham> the arrow notation takes care of routing for you behind the scenes
23:49:05 <solidus-river> interesting, why did it die
23:49:46 <flebron> Say I use DataKinds, and data Fruit = Banana | Apple. Why can't I say f :: Banana -> Int, f _ = 42? Is it because -> has kind (* -> *) and Banana doesn't kind-check?
23:50:28 <christiaanb> flebron: what values inhabid Banana?
23:50:57 <flebron> _
23:51:00 <flebron> Sorry, undefined.
23:51:01 <newsham> Banana isnt a type
23:51:12 <flebron> Banana is a type, with DataKinds
23:51:13 <newsham> its a constructor for one of the elements of type Fruit
23:51:16 <newsham> oh, sorry
23:51:17 <solidus-river> felbron you could do f :: Fruit -> Int
23:51:35 <flebron> I'm aware solidus-river, that's just not what I wanted to do :p
23:51:58 <christiaanb> flebron: f :: Proxy Banana -> Int, f _ = 42  would work
23:52:11 <christiaanb> but I guess that's not what you want
23:52:12 <flebron> What is Proxy, and what kind does it have?
23:52:20 * hackagebot HTTP 4000.2.15 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.15 (GaneshSittampalam)
23:52:26 <christiaanb> :k Proxy
23:52:27 <lambdabot> k -> *
23:52:50 <christiaanb> there you have it
23:52:58 <christiaanb> Proxy is kind-polymorphic
23:53:28 <christiaanb> It's in Data.Proxy as of base 4.7
23:53:33 <flebron> Ah, OK, it's like an unsafeCoerce :: a -> T at the type level :p
23:54:17 <christiaanb> no… more like: dumbCoerce :: a -> ()
23:55:06 <flebron> Right, the T is fixed :)
23:55:08 <newsham> "data Proxy p = Proxy"   hmmm
23:56:24 <johnw> newsham: it carries a phantom type
23:57:16 <christiaanb> flebron: check out http://hackage.haskell.org/package/singletons if you want to work with datakinds. It has Template Haskell stuff that gives you inhabitants for your datakind stuff
23:57:28 <christiaanb> yeah… lot's of stuff in there :$
