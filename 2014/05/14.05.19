00:00:21 <sloopjohnb> osa1 i think your message got cut off
00:02:53 <louisjb> eventually got vim haskell mode working, all good :) trying leksah out, looks promising - is it used much in the community?
00:03:02 <pavonia> osa1: The translation is quite simple, are you looking for any special information about that?
00:07:06 <tdammers> hmm, I think I should look into some tooling... the time has come...
00:07:22 <tdammers> I have a whole screenful of imports at the beginning of my source file
00:07:33 <tdammers> and completely lost track of which ones I actually need :x
00:08:23 <osa1> sloopjohnb: nope that was the whole message :D
00:08:49 <sloopjohnb> osa1 o i c, i looked suspiciously at that ...
00:09:08 <osa1> pavonia: I'm profiling a code that uses LambdaCase syntax and -fprof-auto puts a cost-centre for each case in \case ... expression. I'm trying to figure out why.
00:09:23 * hackagebot elm-get 0.1.2 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.2 (EvanCzaplicki)
00:09:23 * hackagebot transformers-compat 0.3.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3.2 (EdwardKmett)
00:09:36 <osa1> pavonia: so I want to know what Haskell expression are \case ... expressions converted to.
00:09:46 <edwardk> hackagebot is experiencing deja vu
00:12:09 <osa1> hmm wait, that may not be related with LambdaCase synta.
00:12:13 <osa1> syntax*
00:16:20 <osa1> it would still be useful to know where in the GHC source do those syntax extensions get desugared :D
00:17:01 <jle`> you can dump the desugared code but it isn't quite meant to be readable
00:18:11 <osa1> jle`: do you mean dumping Haskell code or Core/STG/Cmm?
00:19:18 * hackagebot iteratee 0.8.4.6 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.6 (JohnLato)
00:19:19 <jle`> it's haskell i think...
00:19:24 <jle`> -ddump-ds
00:20:35 <osa1> jle`: I don't know what it is but it's definitely not Haskell :)
00:20:53 <jle`> it might just not be idiomatic haskell :)
00:20:53 <osa1> it says "desugarer output" in man page
00:21:52 <osa1> jle`: well I'm sure this is not a valid Haskell top-level syntax: "Rec { Main.fib' [Occ=LoopBreaker] :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer ..."
00:22:00 <osa1> or is it? :P
00:22:03 <tdammers> also, I'm in string-like-type hell
00:22:20 <tdammers> I have lazy and strict Texts, Strings, and both lazy and strict bytestrings in the same module
00:22:21 <jle`> well GHC.Integer.Type.Integer is the fully qualified Integer I think
00:22:40 <jle`> heh
00:22:47 <jle`> but you can find the desugaring for sure
00:22:51 <jle`> just don't expect it to be pretty :)
00:23:07 <osa1> tdammers: we once had a typeclass for converting all string types to each other in our code base.
00:23:17 <osa1> jle`: right.
00:23:50 <tdammers> osa1: yeah, except that with bytestrings, the conversion isn't always the same
00:24:06 <osa1> tdammers: do you mean because of different encodings?
00:24:10 <tdammers> yes
00:24:26 <tdammers> although using utf-8 for everything should work
00:24:29 <osa1> yeah you need to use a default for that I guess
00:24:41 <tdammers> because "everything" in my case should amount to "utf-8 or ascii"
00:24:42 <osa1> yup, I think utf-8 what we had
00:25:14 <tdammers> so yeah, I might make a little glue module for that
00:25:25 <tdammers> Data.String.fromString, except both ways
00:26:34 <osa1> tdammers: make the method name "s", inline it and wrap everything with it and you're good to go :D
00:28:42 <tdammers> :D sounds like a plan
00:29:07 <tdammers> except it's not going to be a method, really
00:29:17 <tdammers> more like a fromString and toString as methods
00:29:21 <jtcwang12> a
00:29:22 <tdammers> and then s = fromString . toString
00:29:24 <tdammers> or somesuch
00:29:49 <tdammers> although, hmm, making it a method means I could special-case a few things
00:29:57 <tdammers> lazy/strict conversion and such
00:30:11 <tdammers> -XMultiParamTypeClasses, but oh well
00:30:36 <osa1> tdammers: I had something like "class StringConv from to where s :: from -> to" in mind
00:32:04 <tdammers> well, yes, except it means I'd need, uhm, 120 instances
00:32:24 <tdammers> every possible combination of any out of 5 string types
00:32:35 <kqr> is there a way in Haskell or GHC to specify a partial type, in the sense that I have a value "a :: Map _ (Tree _ _)"? i want inference on the underscores, but I want to make clear that it's a map of trees
00:33:24 <jle`> well you can leave them as type variables if you don't reference it i think
00:33:36 <jle`> there was a proposal a couple of months ago about partial type signatures
00:34:05 <bergmark> yeah, other than that there are typed holes but not type holes :-)
00:34:59 <shachaf> kqr: Alas, no.
00:35:02 <tdammers> "kinded holes"? :x
00:35:08 <osa1> tdammers: but can't you make GHC search for possible solutions of s? like "instance StringConv a b, StringConv b c => StringConv a c where ..."
00:35:17 <tdammers> ah yeah
00:35:29 <kqr> suspected so
00:35:30 <bergmark> tdammers: check out the string-conversions package by the way
00:35:31 <kqr> thanks
00:35:39 <tdammers> bergmark: yeah, I remember that one
00:36:10 <tdammers> bergmark: haven't used it so far, but will revisit
00:37:03 <bergmark> felt a bit hacky to use it for some reason, but on second thought i don't see why not
00:37:30 <osa1> "instance StringConv a b, StringConv b c => StringConv a c where s = s . s" I wonder if that would work
00:37:47 <Fuuzetsu> jle`: not that I know of
00:37:50 <jtcwang1> k
00:37:51 <bergmark> osa1: that would probably be ambiguous
00:38:29 <bergmark> osa1: there was a proposal from conal elliot to allow type signatures like s . (:: Text -> ByteString) . s
00:39:41 <bergmark> but it just desugars to (id :: x) so i'm not sure if it's worth it ;o
00:40:01 <osa1> bergmark: if the problem is ambiguity of s does that work: "s = (s :: b -> c) . (s :: a -> b)" ?
00:40:14 <bergmark> osa1: yeah
00:41:18 <tdammers> the multi-parameter typeclass approach would work if it could default to going through String without causing overlapping instances
00:41:58 <tdammers> i.e., there could be a default instance (IsString a, ToString b) => StringConvertible b a
00:42:00 <bergmark> or you can do `convertVia :: (C a b, C b c) => b -> a -> c' where b is a dummy argument that you call with undefined/Proxy Foo
00:42:20 <tdammers> bergmark: I took a similar route with my SQL mapping module
00:42:37 <tdammers> the query string builders take an unused argument to derive the table schema from its type
00:42:52 <bergmark> i think we do that too
00:43:03 <bergmark> also for sql :-)
00:43:04 <tdammers> it feels dirty, but I haven't found a more elegant way
00:43:53 <bergmark> if you use Proxy it's not bad i think
00:44:13 <tdammers> anyway, the problem with the string convertible is I don't really care what the intermediate type is; I want the instance to default to the most efficient way that it knows about
00:44:25 <tdammers> so if there's a direct conversion, I want that (e.g. lazy from strict)
00:44:32 <osa1> what does Proxy do? I remember using it while using a lib(probably tasty) but don't remember what's that for
00:44:33 <tdammers> and if there isn't, I want it to go through String
00:44:53 <tdammers> but the problem is that I get overlapping instances if I implement both the specialized instances and the generic one
00:46:49 <bergmark> osa1: Proxy Foo is the same as  (undefined :: Foo), but there's no value so you won't accidentally evaluate it
00:47:19 <bergmark> tdammers: overlapping instances aren't bad if you know what you are doing
00:48:16 <tdammers> bergmark: I'm not sure I do :D
00:49:05 <osa1> bergmark: what packages defines Proxy?
00:49:09 <bergmark> osa1: tagged
00:49:14 <osa1> thanks
00:49:21 * hackagebot simd 0.1.0.0 - simple interface to GHC's SIMD instructions  http://hackage.haskell.org/package/simd-0.1.0.0 (MikeIzbicki)
00:49:35 <bergmark> tdammers: you'll likely get the "suggestion" to use incorehent instances if you mess something up
00:49:50 <bergmark> and i would recommend avoiding that
00:50:14 <bergmark> anyway, you can read the ghc docs
00:50:27 <tdammers> yeah, before we know it I'll be enabling OverlySelfConsciousInstances and SplitPersonalityTypeClasses and all that
00:50:45 <DogeHayashi> GodModeTypeClasses
00:51:41 <Eelis> {-# LANGUAGE iddqd #-}
00:53:30 <DogeHayashi> {-# LANGUAGE ICanSeeThroughTime #-}
00:54:21 * hackagebot simd 0.1.0.1 - simple interface to GHC's SIMD instructions  http://hackage.haskell.org/package/simd-0.1.0.1 (MikeIzbicki)
00:54:23 * hackagebot compdata 0.8.1.0 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8.1.0 (PatrickBahr)
00:58:16 <tdammers> also, wondering how I should do sql schema migrations
00:58:36 <tdammers> my usual approach so far was to write scripts by hand and throw them into an SQL script manager
00:58:56 <tdammers> but for this project, the SQL data types can emit schema definitions themselves
00:59:07 <tdammers> so I'm tempted to try and do automatic migrations
01:08:04 <mayski> what's this LLVM thing now that I'm told I need
01:09:04 <Polarina> mayski, who said you need them?
01:09:10 <mayski> cabal ; _ ;
01:09:22 * hackagebot utf8-string 0.3.8 - Support for reading and writing UTF8 Strings  http://hackage.haskell.org/package/utf8-string-0.3.8 (EricMertens)
01:09:24 * hackagebot latest-npm-version 0.3.1 - Find the latest version of a package on npm  http://hackage.haskell.org/package/latest-npm-version-0.3.1 (passy)
01:10:08 <merijn> mayski: What were you trying to install?
01:10:20 <mayski> package called hF2
01:11:06 <mayski> http://hackage.haskell.org/package/hF2 this thing
01:11:33 <merijn> heh, I don't see why that would require LLVM...
01:12:38 <mayski> I get "Couldn't figure out LLVM version! Make sure you have installed LLVM"
01:13:54 <__dash__> hi
01:16:50 <mayski> actually looking at the source it looks like overkill for what I need
01:19:23 * hackagebot NetSNMP 0.3.1.0 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.1.0 (PavloKerestey)
01:25:41 <bartavelle> argh there are 80 irc libraries on hackage
01:26:12 <merijn> bartavelle: That's because everyone implements IRC bots as practice :p
01:26:29 <bartavelle> yes indeed
01:27:48 <bartavelle> I'll go back to XMPP, choice is easier :)
01:50:05 <{AS}> What happened to Haskell platform? Is it not updated any more?
01:50:50 <merijn> {AS}: It was put on hold due to difficulties with OSX 10.9, it should be restarting Real Soon (TM)
01:50:57 <{AS}> Ah, thanks
01:51:38 <Aetherspawn> HP for windows will come in like 2025
01:51:48 <Aetherspawn> and it'll be a type family backport
01:51:56 <merijn> {AS}: In short, Apple dropped GCC for clang, which broke pre 7.8 GHC. So the question was "Wait for 7.8 release and start release cycle then OR rerelease a 7.6 platform and OSX users won't be able to use it"
01:53:13 <{AS}> Ah, so they waited for 7.8. Thanks
01:56:33 <merijn> I don't suppose there's a version of guard/when/unless/whatever that returns "mempty" instead of ()?
01:59:13 <{AS}> @hoogle (Monoid (m a), Monad m) => Bool -> m a -> m a
01:59:16 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
01:59:16 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
01:59:16 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
01:59:34 <Taneb> mempty <$ guard?
02:00:03 <Taneb> guard does return mempty, just not for your monoid :)
02:00:17 <merijn> Actually, I guess guard will have the wrong semantics for my type anyway
02:09:33 * Polarina can't decide whether to use (>>=) or (=<<).
02:11:42 <merijn> Polarina: Compromise and use ">>=<<" :)
02:12:23 <Polarina> I wonder what type that would have.
02:13:33 <Polarina> (>>=<<) :: Monad m => Either (m a -> (a -> m b)) ((a -> m b) -> m a) -> m b
02:13:38 <Polarina> Perfect!
02:14:25 * Kinnison 's brain confused
02:15:46 <eizo> @src (>>=<<)
02:15:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:16:00 <eizo> >_<
02:20:49 <merijn> eizo: It was a joke :p
02:21:28 <eizo> oh hadn't seen the message before yours
02:21:37 <DogeHayashi> reminds me of that cartesian closed comic
02:21:47 <DogeHayashi> don't play with your monads too much, or you'll go bind
02:26:29 <DogeHayashi> wow, such bitonic
02:26:33 <DogeHayashi> so underscore
02:26:34 <merijn> bah
02:27:05 <merijn> If we're stuck with having "fail" in Monad couldn't it at least have accepted a proper exception instead of just String? :(
02:28:12 <Aetherspawn> fail is kind of lackluster
02:28:19 <Aetherspawn> it would be nice if we could fail ()
02:28:27 <Aetherspawn> to prevent allocations and stuff.
02:29:41 <merijn> I need to throw an error from a Monad that doesn't have something like MonadThrow/whatever so they only thing I can use is "fail" :\
02:29:50 <merijn> Which means I can't control what error it throws :\
02:36:54 <augur> merijn: make your own monad!
02:36:58 <Polarina> The use of "fail" should be banned.
02:38:16 <bartavelle> it's useful for  parsing libraries
02:38:17 <augur> so much for haskell purity, ey? :(
02:38:19 <merijn> augur: By reimplementing all of attoparsec? :(
02:38:27 <augur> merijn: yes
02:38:33 <tdammers> merijn: why not?
02:38:42 <augur> accept no exceptions!
02:38:53 <tdammers> merijn: once you have the core down, it's mostly a matter of pumping out the combinators you need
02:38:54 <merijn> bartavelle: I'd rather have "fail :: (Exception e, Monad m) => e -> m a" :p
02:38:59 <bartavelle> heh
02:39:17 <merijn> tdammers: Because my implementation would suck in terms of performance compared to attoparsec? :p
02:39:30 * hackagebot ghc-imported-from 0.2.0.3 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.3 (CarloHamalainen)
02:39:40 <tdammers> merijn: and performance is a deal breaker?
02:40:24 <augur> merijn: why not have   fail :: MonadError m => e -> m a
02:40:30 <tdammers> because personally, I wouldn't mind trading a bit of performance off of attoparsec to increase development comfort
02:40:33 <augur> or whatever the type is for monaderror's failure thing
02:40:58 <merijn> tdammers: Except that it won't be an increase of development comfort, it would mean duplicating all the testing and development of attoparsec...
02:41:23 <merijn> augur: Sure, but that requires splitting of "fail" from Monad, which I'm in favour of, but don't think likely
02:41:36 <tdammers> merijn: yeah, well, I'm more thinking you might want to with an alternative
02:41:43 <tdammers> merijn: not necessarily implement your own
02:41:56 <merijn> tdammers: I'm open to alternatives for attoparsec
02:42:15 <tdammers> merijn: I hear trifecta is awesome Lx
02:42:32 <merijn> I think the only serious contenders are parsec (disqualified due to lack of incremental parsing) or trifecta (disqualified because I can't figure out how the hell to use it)
02:42:57 <edwardk> i'm currently working on a trifecta rebuild
02:43:00 <tdammers> I'd plug my own lib, but it's pretty much just something I wrote for my own use cases
02:43:19 <tdammers> it's far from ready for prime time, and I doubt it will ever be :P
02:43:37 <Polarina> merijn, edwardk wrote trifecta, no wonder you can't figure out how to use it.
02:44:01 <edwardk> Polarina: to be fair, it was a fairly rushed edward who didn't get much chance to polish it up before needing it
02:44:48 <Polarina> edwardk, don't even try. You are the mastermind of difficulty. :)
02:44:52 <edwardk> In practice though most of trifecta s factored out into 'parsers' which can be used with almost everything
02:45:10 <edwardk> and which _is_ thoroughly documented
02:45:56 <bartavelle> parsers is fairly obvious to use once you have used parsec and/or attoparsec
02:46:00 <bartavelle> and the api is nicer
02:47:15 <merijn> Sure, but that's pretty much the bit I don't care too much about due to combinators for parsers being fairly trivial and me only needing really simple parsing, atm
02:48:31 <tdammers> edwardk is not a synonym for difficulty nor complexity. It's a synonym for maximum possible abstraction
02:49:28 <tdammers> merijn: if very simple parsing is all you need, how much time would it take you to roll a custom parser-combinator module yourself? Highly specific, no need to go overboar dwith the abstractions
02:49:58 <tdammers> if you don't abstract over the input type, for example, making better use of efficient prefix tests is a breeze
02:50:27 <{AS}> or how about using something like Happy?
02:50:59 <osa1> ha! found where LambdaCase syntax is desugared while looking for something else https://github.com/ghc/ghc/blob/master/compiler/deSugar/DsExpr.lhs#L212 (I had asked this in the channel several hours ago)
02:51:31 <merijn> tdammers: The parser-combinator stuff isn't the problem, doing the actual parsing fast is
02:51:49 <tdammers> merijn: so performance is an issue, huh
02:51:51 <merijn> I fail to see what the possible gain could be other than exception bit
02:51:56 <{AS}> merijn: parser generators are usually faster than combinators
02:52:26 <merijn> tdammers: No, properly handling edge cases, testing and bug fixing is a huge time sink
02:52:38 <tdammers> {AS}: isn't that more a matter of staying away from the inefficient parts of parser-combinators, and a decent optimizing compiler?
02:52:54 <{AS}> Yes, theoretically
02:53:16 <{AS}> it is very easy to overuse lookahead using parser combinators
02:53:34 <{AS}> and much easier to express common things in a grammar style
02:54:26 <merijn> {AS}: Stateful parsing is an utter pain using parser generators, though
02:54:40 <{AS}> Oh, you need state. Then, yes.
03:08:16 <ZettaBlade> I'm a college drop out. How do I get a job programming in Haskell?
03:09:26 <nclarke_> ZettaBlade: Do you know Haskell?
03:09:38 <shelf> many many months of unpaid study and practise
03:10:03 <augur> i wouldnt mind a job programming haskell. could be fun!
03:10:03 <bartavelle> wasn't there an executable that parsed haskell expressions and applied them in "interact" ?
03:10:22 <shelf> I dream of a Haskell job
03:10:36 <ZettaBlade> I can read and write Haskell functions!
03:10:58 <Polarina> ZettaBlade, but can you read and write Haskell types?
03:10:59 <tdammers> ZettaBlade: have you ever written a nontrivial real-world application in Haskell?
03:11:38 <rhaps0dy> are you sure haskell reduces complexity and increases code readability?
03:11:48 <rhaps0dy> I'm having doubts
03:12:00 <tdammers> rhaps0dy: in terms of big-O, it does, kind of
03:12:08 <rhaps0dy> big O ?
03:12:11 <tdammers> yeah
03:12:20 <rhaps0dy> as in very large program?
03:12:22 <tdammers> overall maintenance effort per lines-of-code
03:12:23 <ZettaBlade> I know a fair share of the language. But truth be told, I wouldn't trust myself with a high paying programming job, like with Haskell.
03:12:40 <tdammers> something like Python is O(n^2)
03:12:47 <tdammers> or maybe even O(2^n)
03:12:54 <ZettaBlade> I'd want to internship for a bit before I took on any responsibility
03:13:14 <tdammers> but with proper encapsulation and static type checks, you can keep the codebase at roughly O(n)
03:14:01 <rhaps0dy> tdammers: hm
03:14:27 <rhaps0dy> maybe. I'm still a bit new to Haskell, maybe it's that.
03:14:46 <rhaps0dy> Static type checking is really really nice, who would even come up with dynamic typing
03:14:56 <tdammers> it's a philosophy thing
03:15:01 <tdammers> youngsters, really
03:15:48 <ZettaBlade> Web developers
03:16:16 <drupzky> can someone please point me to a resource where I can read up on "wired" types like:  f :: Num (a -> b) => [a] -> [b] arising from f xs = map 3 xs or tell me a little bit about it?
03:16:28 <tdammers> well, there is the observation that static type checks "cause" compiler errors, and if you get rid of them, the application appears to still work, only you don't have those pesky error messages
03:16:39 <tdammers> which leads people to believe that with dynamic typing one can develop faster
03:16:45 <tdammers> which, for very small codebases, is true
03:16:47 <diginet> what is the point of type inference? just saving time typing (as in writing a keyboard)
03:17:06 <tdammers> but it doesn't really scale well
03:17:15 <tdammers> and the usual remedy is "write more unit tests"
03:17:49 <tdammers> but then, if you think about it, a unit test pretty much just confirms the semantics of the types you are building informally
03:18:03 <tdammers> which is pretty much what a type checker does
03:18:10 <diginet> I've mostly worked with traditional static languages, and never have felt like declaring the types was any sort of burden
03:18:32 <tdammers> the difference however is that the type checker is already done, it has a thorough theoretical foundation behind it, and it's been tested very rigorously
03:18:36 <tdammers> iow, it works
03:19:10 <tdammers> diginet: it's nice to make the type declarations optional, for when they don't add anything
03:19:11 <rhaps0dy> tdammers: so in the end dynamic typing is more work
03:19:25 <rhaps0dy> that's kind of common knowledge, however the history behind isn't
03:19:26 <tdammers> rhaps0dy: yes, that's my stance. At least if you value code correctness.
03:19:36 <rhaps0dy> webdev is incredibly hard for me
03:19:36 <rhaps0dy> like
03:19:39 <rhaps0dy> no.
03:19:48 <ZettaBlade> Is rust better than Haskell?
03:20:00 <tdammers> ironically, I think web dev is one of the areas where Haskell can really shine
03:20:03 <diginet> ZettaBlade: solves a different problem
03:20:03 <rhaps0dy> it's different
03:20:13 <rhaps0dy> tdammers: very likely
03:20:16 <ZettaBlade> But which is better
03:20:26 <tdammers> ZettaBlade: both
03:20:27 <diginet> "better" means different things for different people
03:20:33 <rhaps0dy> python is considered pretty good, and haskell is kind of an static-typed compiled python imo
03:20:34 <ZettaBlade> :O
03:20:40 <rhaps0dy> in terms of high-levelness
03:20:42 <diginet> do you enjoy using it? are you productive with it? then that is "best"
03:20:44 <tdammers> rhaps0dy: no
03:20:52 <tdammers> rhaps0dy: python is much more low-level than Haskell
03:21:06 <rhaps0dy> lel
03:21:23 <rhaps0dy> hm, now that I think about it
03:21:31 <rhaps0dy> you have a point
03:21:35 <ZettaBlade> Isn't Haskell way better than rust tho? I mean, moands...
03:21:35 <rhaps0dy> but still no
03:21:50 <tdammers> an frankly, apart from a few syntax quirks, I don't think Haskell and Python have all that much in common
03:22:05 <rhaps0dy> tdammers: I compare them because they're the high level languages I know
03:22:10 <sgronblo> most people who complain about "verbose" static typing 1) think that static typing == like java and 2) go on to write 4 times as much test code in addition to their normal code
03:22:24 <rhaps0dy> well, javascript too but that's like python almost
03:23:02 <tdammers> javascript is closer to Haskell than Python IMO
03:23:15 <rhaps0dy> how so?
03:23:25 <rhaps0dy> python's functions are first-class too
03:23:48 <sgronblo> rhaps0dy: they are limited somehow
03:23:48 <rhaps0dy> but in a way, so are C's
03:23:51 <tdammers> better closures, non-crippled lambdas, doesn't try to keep you from using higher-order constructs
03:24:16 <tdammers> try to write a generic curry() in JavaScript, then do the same in Python
03:24:30 <tdammers> (or partial(), for that matter - same difference)
03:24:43 <tdammers> JavaScript is secretly a functional language
03:24:45 <rhaps0dy> tdammers: still, all the {"key":value}
03:24:49 <rhaps0dy> and accessing by []
03:25:00 <tdammers> rhaps0dy: yes, so? that's just a syntax quirk
03:25:01 <rhaps0dy> being imperative mostly
03:25:20 <sgronblo> I dont think Javascript being functional is a secret to many programmers anymore
03:25:36 <rhaps0dy> tdammers: does haskell have arrays?
03:25:46 <tdammers> rhaps0dy: haskell can implement arrays as a library
03:25:53 <tdammers> rhaps0dy: and there is one, yes
03:25:54 <rhaps0dy> can implement arrays of course
03:26:07 <rhaps0dy> but they're not the most used thing
03:26:15 <tdammers> arrays are somewhat less useful in a pure functional paradigm
03:26:16 <rhaps0dy> and accessing by position on lists is not encouraged
03:26:24 <rhaps0dy> tdammers: and that's why js is closer to python
03:26:27 <tdammers> no
03:26:30 <rhaps0dy> agh
03:26:50 <aloiscochard> how hard you guys think it would be to add a functionality to show "Core" from an expression in ghc-mod?
03:26:55 <drupzky> how can this possibly typecheck? f xs = map 3 xs  ??!!
03:27:04 <tdammers> js is closer to pythong because they're both dynamically typed, designed with an interpreter in mind, subscribe to the mutable-state paradigm, and use objects to bundle state with behavior
03:27:15 <tdammers> lol, I typed "pythong" :D
03:27:21 <drupzky> map needs an (a -> b) as first argument but we give it a Num a => a
03:27:23 <rhaps0dy> it's a thong now
03:27:29 <drupzky> shouldn't this give a typeerror?
03:27:37 <drupzky> I'm confused big time xD
03:27:38 <rhaps0dy> but yeah, they behave very similarly
03:27:38 <tdammers> it has always been one
03:28:24 <tdammers> inappropriate, ugly, uncomfortable, but nevertheless, quite popular and with a weird sex appeal to it
03:28:53 <rhaps0dy> hahahaha
03:29:12 <rhaps0dy> it was a good introduction to programming. Python I mean
03:29:23 <rhaps0dy> well, gtg
03:29:27 <tdammers> idk, my first language was Pascal, then C
03:29:29 <rhaps0dy> was nice talking to you
03:29:33 <tdammers> o/
03:29:40 <rhaps0dy> later
03:31:42 <Phlogistique> drupzky: 3 could be a Num (a -> b) => (a -> b)
03:31:56 <Phlogistique> drupzky: if you define a Num instance for functions
03:32:37 <Philonous> > map 3 [1..4]
03:32:40 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
03:32:40 <lambdabot>    arising from the ambiguity check for â€˜e_1314â€™
03:32:40 <lambdabot>  from the context (GHC.Num.Num (a -> b),
03:32:40 <lambdabot>                    GHC.Num.Num a,
03:32:40 <lambdabot>                    GHC.Enum.Enum a)
03:33:29 <drupzky> Phlogistique: is it then right to say, that Num (a -> b) => [a] -> [b] requires numbers to behave as functions? somehow that makes more sense to me than to say, that functions need to behave as numbers
03:34:12 <DogeHayashi> pythong was the first language I really got to know
03:34:34 * hackagebot http-test 0.2 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2 (glutamate)
03:34:44 <tdammers> DogeHayashi: you make me feel old
03:34:45 <Phlogistique> drupzky: no, it requires you to define a way for functions to behave as numbers
03:34:51 <Philonous> drupzky, The literal "3" is desugared to (fromInteger 3). And you can overload fromInteger for any type you like
03:34:56 <tdammers> when I started programming, pythong had yet to be invented
03:35:38 <DogeHayashi> heh
03:35:46 <tdammers> no wait, guido had just started hacking on it
03:35:52 <DogeHayashi> I feel like a neophyte now, as ISTR I'm only a few years older than python myself
03:36:12 <tdammers> pascal was the best choice for a beginner back then
03:36:20 <tdammers> around 1990 that must've been
03:36:24 <Philonous> drupzky, So you can have for example (instance Num String where fromInteger = show)
03:36:44 <DogeHayashi> I played around with turbo pascal a short while ago, it seemed like a pretty nice environment given that the version I was using was from the late 80s
03:36:52 <hpc> Philonous: there's a certain module which does have that :D
03:37:17 <Philonous> drupzky, (You could even set (+) to be (++) on strings, mimicking the behaviour of certain other languages. Then 3 + "abc" ==> "3abc")
03:37:36 <drupzky> Phlogistique: now, when functions can behave as numbers, what would that mean in the context of map 3 [1,2,3], what would happen (i know it depends on how one makes functions a member of Num, but maybe you can illustrate a little bit more)
03:38:20 <drupzky> Philonous: ahh okay, that might help, let me think about it
03:39:32 <Philonous> drupzky, One way to implement a Num instance for Functions is (instance Num (a -> Integer) where fromInteger i = const i) . Then (map 3 [1..4]) would be (map (const 3) [1..4])  and that evaluates to [3,3,3,3]
03:41:47 <drupzky> Philonous: Ahh, I start to understand now
03:42:10 <Philonous> drupzky, Note, though, that not dynamic typing is going on. It's a purely syntactic trick that merely hides the application of fromInteger.
03:53:34 <merijn> Is there a cheap way to temporarily hide/delete a key from a Map? Or would I be best off just having a Set of keys to ignore and checking that before checking the map?
03:55:09 <Polarina> merijn, delete the key, then add it back later.
03:56:12 <Philonous> Or just keep the original map?
03:56:38 <Polarina> merijn, you can also make a data structure that holds two Maps. One real, and one for ignored keys.
04:02:50 <merijn> Polarina: The problem is that I'd be reconstructing the map *a lot*
04:03:22 <merijn> So I fear repeatedly deleting a bunch of keys may be rather expensive
04:04:23 <merijn> i.e., I'm doing CPP substitution but CPP doesn't allow recursive substitution, so while substituting macro FOO, the definition of FOO should be hidden, although I will need it again immediately after substitution ends
04:06:13 <quchen> If you're doing this a lot, then I guess an "excluded keys" Set is a good idea.
04:06:20 <Polarina> merijn, how about a Map and a Set data structure, and make your own functions that behave appropriately?
04:06:40 <killy9999> http://lpaste.net/104302
04:06:53 <killy9999> I have a problem deriving an instance of Show
04:07:06 <killy9999> somehow the use of type family seems to prevent that
04:07:15 <killy9999> help?
04:07:24 <merijn> Polarina: That was my other suggestion, yes. I was just checking whether that made sense :)
04:10:08 <danilo2> Hello! :) I would love to ask a very interesting (at last for me) Haskell question. I'm trying to implement a dataflow machine, with parametrized time variable, but I've got problem with the order of IO actions. A detailed question including the code I've just posted here: (http://lpaste.net/104303) . Would you be so nice, and look at it? I'm scratching my head very long loojking for a proper implementation of the problem.
04:21:49 <srhb> danilo2: I think you might want to restructure your program so you get rid of the StateT Int IO Image -> ... parts, and rather have them operate on pure values, ie. the result of each stateful computation
04:22:42 <srhb> danilo2: Then your test will be something like do { i1 <- readImage1; j1 <- readImage2; i2 <- blurImg i1; ... }
04:26:39 <srhb> danilo2: I'm not completely sure I understand what you're doing, but if you let blurImg = return . blurImg' -- I think the types will guide you the rest of the way
04:30:53 <danilo2> srhb: That will not going to wrok. I'm keeping the StateT to be able to create function TimeShift - look, it "shifts" the time for a particular dataflow. If I get rid of the StaeT, the timneShift will shift the time for all dataflows - see the output of main function - do you see it?
04:55:20 <Algebr> is it the case that whereever i have a monad, i can use a do block there?
04:55:33 <tdammers> Algebr: yes
04:56:14 <tdammers> Algebr: I'm not 100% positive about this, but IIRC there is even a way to have do blocks desugar to arbitrary implementations of >>=
04:56:42 <tdammers> Algebr: but the usual idea is that they desugar into monadic >>=
04:57:07 <quchen> (tdammers: RebindableSyntax)
04:57:53 <Algebr> awesome.
04:58:29 <quchen> For the record, don't use RebindableSyntax. It's mainly there for trying out new things, e.g. indexed monads with do-notation etc.
04:59:03 <quchen> And for mauke to write obfuscated code ;-)
05:02:47 <Algebr> What happens behind the scenes for deriving anyway?
05:03:08 <merijn> Algebr: GHC generates code for the instance at compile time
05:03:31 <Algebr> merijn: generates haskell code or like core or c--?
05:03:56 <merijn> Algebr: Probably it generates some AST format like Core, but I'm not sure
05:04:00 <quchen> I think it's Haskell. It certainly isn't C--.
05:04:51 <ivanm> there's a -ddump-deriv flag for ghc; so maybe it spits them out as Haskell code?
05:05:00 <merijn> Algebr: You could write your own "deriving" functions with some Template Haskell, alternatively read up on generics, which let you do "deriving (Generic)" and then specifying "Generic" implementations that work for any Generic datatype
05:05:37 <quchen> The compilation pipeline is roughly "Haskell -> Core -> STG -> Cmm -> ASM". Writing instances etc. is Haskell-level, so I suppose that's where this happens.
05:06:07 <ivanm> yup, -ddump-deriv spits them out in Haskell, albeit with explciitly quantified names
05:06:19 <ivanm> there's also tools like drift that can generate instances for you
05:07:55 <Algebr> I wish I could buy everyone in this channel a round of beer
05:07:57 <tdammers> quchen: ah, yeah. And indeed, I wouldn't recommend it
05:08:07 <ivanm> Algebr: eh, I'll pass ;-)
05:08:09 <Yuu_chan> Good morning
05:08:21 * ivanm waves idly in Yuu_chan's general direction
05:09:03 <bernalex> what's a generic way of doing map ($ 5) [(+1), (+2)]? i.e. that works with higher kinds. I tried just doing fmap ($ getLine) [reverse, length] but that didn't work very well
05:09:51 <Yuu_chan> I'm parsing a log file with attoparsec. I've built a parser for a single line, and parse the whole with sepBy endOfLine. But I actually need only a part of each line, and need to skip anything until its EOL, what's the appropriate way to do that?
05:09:58 <ivanm> bernalex: well, there's mapM ...
05:10:06 <ivanm> @type mapM (=<< getLine)
05:10:08 <lambdabot> [String -> IO b] -> IO [b]
05:10:27 <ivanm> but that would get a newline for every function in that list
05:11:04 <quchen> bernalex: There are no "higher kinds" involved here, that's something different. However, you can first build up a list of IO actions like "map (\f -> fmap f getLine)" and then 'sequence' that to execute all the actions.
05:11:13 <quchen> There's also "traverse" to combine sequence and map.
05:11:26 <quchen> (traverse = mapM)
05:11:27 <bernalex> basically I want the BASH builtin tee
05:12:06 <quchen> :t traverse (\f -> fmap f getLine) [reverse, reverse]
05:12:07 <bernalex> to short down e.g. getLine >>= \l -> putStrLn l >> putStrLn l to getLine `tee` [putStrLn, putStrLn]
05:12:07 <lambdabot> IO [[Char]]
05:12:43 <bernalex> that's not nicer than just doing >>= in most cases though
05:12:57 <bernalex> I guess I could make a tee function though
05:13:25 <ivanm> isn't tee something like: do { line <- getLine; putStrLn line; doSomething line } ?
05:13:32 <ivanm> (and repeat)
05:15:08 <bernalex> ivanm: yes, but I mean just applying several functions to the same value really
05:15:32 <bernalex> like map ($ 5) [(*3), (*2)]
05:15:59 <quchen> I gave you the effectful translation of that above, in terms of traverse.
05:16:19 <quchen> Oh, you only want to read once
05:16:26 <bernalex> it's uglier than just doing foo >>= \x -> f x >> g x >> h x most of the time
05:16:37 <bernalex> that too, yours will do getLine twice I assum
05:16:40 <bernalex> e
05:17:26 <ivanm> @type \ fs -> getLine >>= \ line -> sequence (map ($line) fs
05:17:27 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:17:30 <ivanm> @type \ fs -> getLine >>= \ line -> sequence (map ($line) fs)
05:17:31 <lambdabot> [String -> IO a] -> IO [a]
05:17:55 <simukis_> Yuu_chan: many' (yourParser <* skipWhile  (not . isEndOfLine) <* endOfLine) -- Sounds like something that would work.
05:24:52 <benzrf> hey
05:25:15 <benzrf> i just sudo apt-get installed haskell-platform on my crouton install of lubuntu
05:25:21 <benzrf> but there is no ghci command
05:25:30 <benzrf> and (precise)benzrf@localhost:~$ ghc --interactive
05:25:30 <benzrf> <command line>: not built for interactive use
05:25:35 <Yuu_chan> simukis_: I'm using Char8 version (blame me for that), and isEndOfLine strangely wants Word8 even there
05:25:39 <benzrf> what's going on here?
05:26:49 <ivanm> benzrf: which architecture?
05:26:56 <simukis_> Yuu_chan: use skipWhile from Data.Attoparsec, not Data.Attoparsec.Char8.
05:26:59 <ivanm> crouton == arm-based chrome books or something, doesn't it?
05:27:21 <ivanm> if so, I don't know if GHC has interactive support for ARMs
05:27:24 <Yuu_chan> simukis_: I'll try, thanks
05:28:05 <Yuu_chan> Btw, my current version was skipWhile (not . isEndOfLine . unsafeCoerce), blame me for THAT
05:28:23 <benzrf> ivanm: ARM
05:28:32 <ivanm> yeah, then you may be out of luck
05:29:00 <benzrf> ;-;
05:29:11 <fizruk> how might unsafeCoerce be useful (in general)?
05:29:12 <ivanm> benzrf: https://ghc.haskell.org/trac/ghc/wiki/Platforms
05:29:40 <ivanm> fizruk: by making your program blow up
05:29:42 <ivanm> :p
05:30:15 <ivanm> I think it's mainly used for low-level dealings with FFI, etc.
05:30:22 <fizruk> ivanm: sure, I just see people using it here and there (didnâ€™t pay close attention though)
05:30:36 <ivanm> benzrf: what version of GHC does it have?
05:30:46 <ivanm> 7.4.2 apparently has ghci support
05:30:57 <ivanm> (that's what they said in May 2012 anyway)
05:31:03 <benzrf> The Glorious Glasgow Haskell Compilation System, version 7.4.1
05:31:24 <ivanm> then you might be just one point-release too old to have interactive support
05:31:46 <ivanm> ahhh, looks like there were issues so it wasn't included: http://www.haskell.org/haskellwiki/ARM
05:31:50 <benzrf> T_T
05:32:09 <benzrf> so not only am i stuck on a cruddy chromebook but i cant even REPL
05:33:24 <ivanm> use hugs?
05:33:30 <ivanm> ssh into another machine?
05:33:34 <ivanm> don't use a chromebook? :p
05:34:33 <tdammers> chromebooks are for, uhm, idk, people who don't really need a computer, just an affordable www browsing device thingie
05:34:42 <tdammers> or really even just a facebook machine
05:34:44 * hackagebot tasty-ant-xml 1.0.0.7 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.7 (OliverCharles)
05:34:59 <ivanm> tdammers: the pixel seemed rather nice and you could upgrade the SSD IIRC
05:35:08 <ivanm> but it was almost the price of a "proper" laptop
05:35:17 <rhaps0dy> chromebooks
05:35:18 <ivanm> and there won't be another one with that high level of specs
05:35:29 <rhaps0dy> you can brogram outside your house with them
05:35:32 <rhaps0dy> yay
05:35:49 <rhaps0dy> but for a pixel, better get a fagbook
05:36:06 <ivanm> que?
05:36:07 * Kinnison looks confused at your language
05:36:17 <Kinnison> how will a packet of cigarettes help you?
05:36:27 <ivanm> @wn brogram
05:36:29 <lambdabot> No match for "brogram".
05:37:04 <rhaps0dy>  Kinnison hahhaaha
05:37:08 <rhaps0dy> puta vida tete
05:37:23 * ivanm passes rhaps0dy a dictionary
05:37:44 <rhaps0dy> ivanm: eh dejame ver... Thank you
05:38:02 <ivanm> is that more bad English, or actually a different language now?
05:38:03 * rhaps0dy fucked up the grammar didn't he ?
05:38:11 <rhaps0dy> ivanm: half and half
05:38:21 <ivanm> right
05:38:32 <ivanm> I still can't understand what you said about chromebooks though...
05:41:32 <rhaps0dy> ivanm: that macbooks (fagbooks) are better and at the same price
05:41:43 <ivanm> I didn't mention macbooks
05:41:48 <rhaps0dy> compared to the pixel
05:41:51 <quchen> rhaps0dy: Keep your homophobia to yourself, or better, don't keep it at all. Thank you.
05:41:51 <ivanm> I said "proper" laptop
05:41:52 <augur> !mods
05:41:55 <augur> @mods
05:41:55 <lambdabot> Maybe you meant: todo more docs
05:41:58 <ivanm> macbooks are a bit more expensive still
05:41:58 <augur> whats the mods thing?
05:41:59 <ivanm> @where mods
05:42:00 <lambdabot> I know nothing about mods.
05:42:03 <ivanm> @where ops
05:42:03 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
05:42:08 * ivanm finally learns to /topic
05:42:11 <augur> oh ops, doh.
05:42:24 <ivanm> augur: yeah; too much forum nomenclature :p
05:42:27 <augur> oh yes, its in the topic too
05:42:35 <augur> ivanm: yeah. im tired. gimme a break :p
05:42:54 <ivanm> augur: hey, I immediately thought of mods as well (though that _might_ have been influenced by what you said)
05:45:21 <rhaps0dy> quchen: no need to be upset
05:45:22 <rhaps0dy> I love my fagbook
05:46:07 <Kinnison> rhaps0dy: casual homophobia just increases the acceptability of the less casual form.  Please cease
05:46:11 <tdammers> rhaps0dy: nobody is upset about you loving or hating on macbooks
05:46:20 <tdammers> rhaps0dy: the upheaval is about your choice of words
05:46:33 <rhaps0dy> but it's a common idiom
05:46:41 <rhaps0dy> but if you don't like it I'll stop, alright
05:46:55 <tdammers> just because everyone does it doesn't make it right
05:47:15 <quchen> It's not a common idiom. This isn't /b/.
05:47:27 <Kinnison> rhaps0dy: thank you
05:47:43 <rhaps0dy> No need to thank me, I didn't know it would hurt sensibilities
05:48:14 * Kinnison happens to be gay and dislikes being likened to Apple products
05:48:22 <ivanm> I don't think I've heard it before, so it can't be at all that common
05:52:54 <benj_> I have a £200 crappy Acer chromebook. I do quite a bit of Haskell hacking on it.
05:53:07 <tdammers> rhaps0dy: why, you didn't expect gay people here?
05:53:07 <Algebr> If you don't give a name to a module, say just one script, will ghc just give it the name Main anyway?
05:53:26 <tdammers> rhaps0dy: or did you honestly think the term "fag" wouldn't insult any of them?
05:54:26 <ivanm> benj_: but is it an ARM or x86-based one?
05:54:38 <ivanm> Algebr: yup
05:54:46 <benj_> ivan`, it's a dual-core intel Celeron
05:55:05 <ivanm> > "ivanm" == "ivan`" -- for benj_ :p
05:55:07 <lambdabot>  False
05:55:13 <benj_> ivanm, sorry!
05:55:24 <ivanm> benj_: yeah, benzrf has an ARM-based one, which is why he can't use ghci
05:55:52 <benj_> ivanm, oh I see, I missed that.
05:56:01 <Algebr> Trying to do a simple: main = hPutStrLn stdout "hello", but getting lexical error (UTF-8 decoding error)
05:56:25 <Algebr> is it because haskell is UTF by default and my output is ASCII?
05:56:28 <ivanm> Algebr: you sure you don't have fancy quotes?
05:56:33 <ivanm> (for the "hello"
05:56:35 <ivanm> )
05:56:40 <Algebr> I used regular quotes on my keyboard
05:56:44 <ivanm> that's a common issue if you copy-pasted code from somewhere
05:56:54 <Algebr> I didn't, I just wrote it
05:57:07 <Cale> Algebr: You're getting that message at compile time?
05:57:16 <Cale> (presumably...)
05:57:35 <Cale> Perhaps you could post the file somewhere? Something weird is going on.
05:57:40 <Algebr> Cale: No, at runtime
05:57:48 <Algebr> ghci will run it, but runghc doesn't
05:57:58 <Algebr> doing this in emacs
05:58:05 <ivanm> that's weird... ASCII is a subset of UTF-8
05:58:12 <rhaps0dy> tdammers: I don't associate it with homosexuality really
05:58:14 <ivanm> Algebr: how are you running runghc in emacs?
05:58:28 <rhaps0dy> it's used casually so often ones does not stop to think
05:58:31 <Algebr> ivanm: I don't, in emacs I use ghci, but from shell I use runghc
05:58:41 <rhaps0dy> but I will now
05:59:18 <Algebr> http://lpaste.net/104307
05:59:20 <ivanm> well, then what other reason is there for using the term if not to derogately imply that it's somehow akin to homosexuality (which must be bad, or it wouldn't be a slur)?
05:59:30 <ivanm> the only other use of "fag" is for cigarettes and lollies
05:59:42 <ivanm> and whilst cigarettes _are_ bad, they're not normally used in a derogatory fashion :p
06:00:11 <ivanm> Algebr: which OS is this?
06:00:15 <Algebr> OS X
06:00:51 <ivanm> hmmmm.... not sure if the LANG variable makes sense then
06:01:02 <ivanm> Algebr: what happens if you compile it and then run the executable?
06:01:25 <ivanm> I wonder whether it's because the handle is in binary mode by default or something....
06:01:29 <Algebr> ivanm: ridiculous! The executable runs fine
06:01:49 <ivanm> I don't get any error
06:01:54 <ivanm> so it _may_ be an OSX issue
06:01:56 <Cale> Algebr: Redownload  http://lpaste.net/raw/104307  and do runghc on it. It works for me (but on linux)
06:02:09 <ivanm> or a your-specific-system-and-hence-probably-unreproducable issue :p
06:02:49 <Algebr> Cale: Ha, now works as well.
06:03:01 <Cale> Okay, so there's some weird character in your file
06:03:07 * ivanm waves at araujo 
06:03:11 <Algebr> maybe emacs did it?
06:03:34 <ivanm> Algebr: are you using the unicode operators in emacs or something?
06:03:34 <Cale> I honestly have no idea :)
06:03:48 <ivanm> try opening the file in another editor maybe...
06:03:51 <ivanm> or just cat it
06:03:55 <Algebr> There are other editors?
06:04:14 <ivanm> yeah: you use nano to get your system configured so you can install emacs :p
06:04:31 <Algebr> lol, in any case  gotta run to day job. Thanks guys, as always
06:04:46 <Cale> Or perhaps do od -xc on it and compare the result with the file you downloaded
06:04:50 <araujo> ivanm!! :)
06:04:55 * Polarina wonders if people prefer functions such as { IO (Maybe Error) } or { IO (Either Error a) } instead of exceptions.
06:05:08 <ivanm> Cale: I take it od does byte-level diffing?
06:05:22 <Cale> ivanm: It just displays the bytes in hexadecimal
06:05:26 <ivanm> Polarina: depends on composability I think
06:05:29 <ivanm> Cale: ahhh, right
06:06:02 <Polarina> ivanm, I can't think of much than can easily be composed. These are bindings to a C library.
06:06:34 <tdammers> Polarina: depends... can always translate relatively trivially
06:06:48 <Cale> Polarina: I suppose the main thing to consider is whether people will usually want to handle the error where it occurs, or usually let it percolate up to either kill their program or be dealt with at a higher level
06:06:52 <ivanm> Polarina: if you use exceptions, it's easier to use them in a do-block, etc. without always dealing with the Maybe/Either, and then at the end you can catch any exceptions and produce a Maybe or Either
06:07:15 <tdammers> bergmark: yo, think I got it \o/
06:07:56 <Cale> Control.Exception is actually a really nice exceptions system, but we don't use it perhaps as much as it deserves because Haskell programmers tend to be really cautious about handling failure cases.
06:09:28 * Polarina has to think about this.
06:10:46 <S11001001> whoops, I took the successful value to nf, there was an error
06:12:23 <merijn> Polarina: My personal opinion is: Non-exceptional return values for any external API
06:13:09 <merijn> Polarina: It's really frustrating that the presence of exceptions is not exposed in types of an API and if I *do* want to use exceptions in my code then translating "Either Error a" to an exception is trivial
06:13:39 <ivanm> merijn: yeah, as annoying as it is to write all the time that's one advantage of Java-style exceptions
06:16:52 <Polarina> merijn, I was thinking of providing a function such as { lucky :: Either Error a -> a } that can help with that. I don't particularly like exceptions myself, I always forget to catch them.
06:18:00 <Cale> Polarina: There's a big difference between throwing an exception with error and throwing it from IO though. Exceptions thrown from pure code are tricky to catch, to the extent that they probably shouldn't be caught.
06:18:16 <ivanm> Polarina: lucky = either throw id ?
06:18:38 <Polarina> ivanm, yes.
06:18:47 <ivanm> Cale: oh? I've managed to throw and catch exceptions from pure code (usually parsing errors)
06:18:50 <merijn> Cale: That's what the exceptions library is for :)
06:19:01 <merijn> ivanm: The problem is that your exceptions can escape your handlers
06:19:06 <Cale> Well, it's *possible*, but I don't think it should be done except as a last resort, generally.
06:19:13 <ivanm> merijn: how so?
06:19:29 <merijn> ivanm: Because "throw" does not raise an exception until forced
06:19:42 <ivanm> ahhhhh
06:19:42 <Cale> ivanm: It's hard to control the evaluation order of expressions in such a way that you can ensure the exception is thrown inside the catch.
06:19:47 * hackagebot parsers 0.11.0.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.11.0.1 (EdwardKmett)
06:20:10 <Cale> Or at least, forcing users to reason about the evaluation order in this way is bad style.
06:20:16 <merijn> ivanm: "throw 'blah' `catch` someHandler", so here catch can decide "oh, no exceptions, here's your thunk for "throw 'blah'"" and then you evaluate it and you're boned
06:20:30 <merijn> ivanm: Hence you should always use throwIO or exceptions' throwM
06:20:39 <ivanm> never thought of it that way
06:20:54 <ivanm> merijn: or do a deepseq?
06:21:04 <ivanm> though that usually wouldn't be the greatest of ideas :p
06:21:07 <Cale> Yeah, along with Control.Exception.evaluate
06:21:15 <Cale> :t Control.Exception.evaluate
06:21:16 <merijn> ivanm: That's not very nice though, and making sure deepseq gets done, etc. is not trivial either
06:21:17 <lambdabot> a -> IO a
06:21:35 <ivanm> yeah, I wasn't serious with that suggestion :)
06:21:39 <Cale> The tools are there if you *need* to do it, but it's not fun
06:23:37 <Cale> But for IO actions, exceptions are actually pretty cool. You don't see people using them really extensively very often, but the way in which you can arbitrarily add new superclasses and subclasses of exceptions by defining new types and implementing toException and/or fromException by hand is really neat.
06:24:47 * hackagebot hack2-contrib 2014.5.19 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2014.5.19 (JinjingWang)
06:24:49 * hackagebot geek 1.0.0.9 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.9 (JinjingWang)
06:25:15 <yitz> i once really did need deepseq. it involved contacting a number of different authors of hackage libraries, politely requesting that they add an NFData instance to various types and upload new versions, then dealing with the resulting cabal hell.
06:25:58 <bennofs> yitz: in those cases, it might be easier to just put a package nfdata-instances on hackage :)
06:26:31 <yitz> bennofs: orphan instances cause me digestion problems.
06:27:04 <bennofs> Yeah, I don't like them either. :(
06:27:23 <Polarina> @quote yitz orphan instances cause me digestion problems.
06:27:23 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
06:27:30 <yitz> bennofs: anyway, there was the additional side effect of causing those NFData instances to be created, for the benefit of everyone.
06:27:32 <Cale> yitz: There's also the option of just grabbing the sources for the packages, constructing patches against them, and getting on with your work while sending the patches upstream
06:28:09 <bennofs> yitz: but then all those packages have to depend on deepseq too, which causes one more dependency to be installed even if people might not need it
06:28:12 <yitz> Cale: yes, risking that if someone refuses you need to regroup.
06:28:30 <yitz> bennofs: it's bundled with ghc and hasn't changed for about a decade.
06:28:41 <bennofs> oh, didn't know that it's bundled with ghc
06:28:56 <Cale> Is deepseq really a decade old?
06:29:06 <yitz> Cale: plus or minus six years
06:29:10 <Cale> hehe
06:29:35 <Cale> It would be getting close now...
06:30:45 <edwardk> yitz++ # for the patience of chasing after the maintainers
06:31:33 <bennofs> Should instances for the template-haskell Lift class also be provided by the package itself or does it make sense to have them in another package?
06:31:55 <bennofs> For example, containers, text, bytestring, vector and base all miss them for some types I was using
06:32:01 <Cale> bennofs: It's generally a good idea to try to keep instances in either the module where the class is defined or the module where the type is defined
06:32:04 <ivanm> bennofs: it can be a good idea to have it in a separate package
06:32:11 <ivanm> as TH isn't usable on all architectures
06:32:20 <Cale> Oh, that is a good point though
06:33:00 <ivanm> though it does lead to dirty orphan instances... :p
06:33:03 <bennofs> I have a package for them now, just wondering if it might make sense to try to get them moved upstream
06:34:44 <yitz> edwardk: tnx!
06:43:19 <yoeight> did something happen on hackage ? after a cabal update I'm unable to install a package now
06:43:33 <yoeight> cabal: Could not resolve dependencies:
06:43:33 <yoeight> Dependency tree exhaustively searched.
06:44:04 <merijn> yoeight: It means you're trying to install something that has conflicting dependencies. Presumably because some maintainer screwed up his version bounds
06:45:48 <yoeight> merijn: thanks, too bad we can't figure out easily which package is causing trouble
06:46:16 <dcoutts> yoeight: you can get details from the solver if you run with -v3
06:46:18 <merijn> yoeight: Have you tried running cabal with increased verbosity? -v3
06:46:40 <yoeight> dcoutts:merijn: let's figure this out
06:46:43 <merijn> It should at least mention which versions conflict
06:48:06 <yoeight> [__1] trying: base-4.7.0.0/installed-018... (dependency of dhek-1.0.6)
06:48:07 <yoeight> [__2] trying: rts-1.0/installedbuil... (dependency of base-4.7.0.0/installed-018...)
06:48:07 <yoeight> [__3] trying: integer-gmp-0.5.1.0/installed-dc4... (dependency of base-4.7.0.0/installed-018...)
06:48:07 <yoeight> [__4] trying: ghc-prim-0.3.1.0/installed-948... (dependency of base-4.7.0.0/installed-018...)
06:48:07 <yoeight> [__5] trying: process-1.2.0.0/installed-eaf... (dependency of dhek-1.0.6)
06:48:07 <yoeight> [__6] trying: unix-2.7.0.1/installed-2a4... (dependency of process-1.2.0.0/installed-eaf...)
06:48:09 <yoeight> [__7] trying: time-1.4.2/installed-9c2... (dependency of unix-2.7.0.1/installed-2a4...)
06:48:12 <yoeight> [__8] trying: old-locale-1.0.0.6/installed-be1... (dependency of time-1.4.2/installed-9c2...)
06:48:13 <yoeight> [__9] trying: directory-1.2.1.0/installed-b17... (dependency of process-1.2.0.0/installed-eaf...)
06:48:15 <yoeight> [_10] trying: deepseq-1.3.0.2/installed-716... (dependency of process-1.2.0.0/installed-eaf...)
06:48:17 <yoeight> [_11] trying: Cabal-1.18.1.3/installed-0e9... (dependency of dhek-1.0.6)
06:48:20 <yoeight> [_12] trying: pretty-1.1.1.1/installed-947... (dependency of Cabal-1.18.1.3/installed-0e9...)
06:48:23 <yoeight> [_13] trying: text-1.1.1.2 (dependency of dhek-1.0.6)
06:48:25 <Kinnison> please use a pastebin
06:48:26 <yoeight> [_14] trying: text-1.1.1.2:-integer-simple
06:48:26 <albeit> http://lpaste.net/new/haskell
06:48:28 <yoeight> [_15] trying: text-1.1.1.2:-developer
06:48:30 <yoeight> [_16] trying: text-1.1.1.2:!test
06:48:32 <yoeight> [_17] trying: shakespeare-2.0.0.3 (dependency of dhek-1.0.6)
06:48:34 <yoeight> [_18] trying: shakespeare-2.0.0.3:-test_roy
06:48:36 <yoeight> [_19] trying: shakespeare-2.0.0.3:-test_export
06:48:37 <yoeight> [_20] trying: shakespeare-2.0.0.3:-test_coffee
06:48:38 <ion> please
06:48:39 <albeit> http://lpaste.net/new/haskell
06:48:39 <yoeight> [_21] trying: shakespeare-2.0.0.3:!test
06:48:42 <yoeight> [_22] trying: transformers-0.3.0.0/installed-7df... (dependency of shakespeare-2.0.0.3)
06:48:43 <yoeight> [_23] trying: exceptions-0.6.1 (dependency of shakespeare-2.0.0.3)
06:48:45 <yoeight> [_24] trying: exceptions-0.6.1:!test
06:48:47 <yoeight> [_25] trying: blaze-html-0.7.0.2 (dependency of shakespeare-2.0.0.3)
06:48:50 <yoeight> [_26] trying: blaze-html-0.7.0.2:!test
06:48:52 <albeit> yoeight: Please stop
06:48:53 <yoeight> [_27] trying: blaze-builder-0.3.3.2 (dependency of blaze-html-0.7.0.2)
06:48:55 <yoeight> [_28] trying: blaze-markup-0.6.1.0 (dependency of shakespeare-2.0.0.3)
06:48:58 <yoeight> [_29] trying: blaze-markup-0.6.1.0:!test
06:48:59 <yoeight> [_30] trying: parsec-3.1.5 (dependency of shakespeare-2.0.0.3)
06:49:02 <yoeight> [_31] trying: parsec-3.1.5:+base4
06:49:03 <yoeight> [_32] trying: template-haskell-2.9.0.0/installed-dcc... (dependency of shakespeare-2.0.0.3)
06:49:06 <yoeight> [_33] trying: system-fileio-0.3.13 (dependency of shakespeare-2.0.0.3)
06:49:08 <yoeight> [_34] trying: system-filepath-0.4.11 (dependency of shakespeare-2.0.0.3)
06:49:09 <yoeight> [_35] trying: system-filepath-0.4.11:!test
06:49:11 <yoeight> [_36] trying: free-4.7.1 (dependency of dhek-1.0.6)
06:49:12 <brisbin> yikes
06:49:14 <yoeight> [_37] trying: semigroups-0.14 (dependency of free-4.7.1)
06:49:16 <yoeight> [_38] trying: semigroups-0.14:+unordered-containers
06:49:16 <linduxed> what in the...
06:49:17 <yoeight> [_39] trying: semigroups-0.14:+text
06:49:20 <yoeight> [_40] trying: semigroups-0.14:+hashable
06:49:20 <albeit> Maybe he can't stop it...
06:49:22 <brisbin> someone kick him
06:49:23 <DogeHayashi> wat
06:49:24 <yoeight> [_41] trying: semigroups-0.14:+containers
06:49:26 <yoeight> [_42] trying: semigroups-0.14:+bytestring
06:49:28 <yoeight> [_43] trying: unordered-containers-0.2.4.0 (dependency of semigroups-0.14:+unordered-containers)
06:49:30 <yoeight> [_44] trying: unordered-containers-0.2.4.0:-debug
06:49:32 <yoeight> [_45] trying: unordered-containers-0.2.4.0:!bench
06:49:33 <merijn> I think this is freenode's rate limiting
06:49:34 <yoeight> [_46] trying: unordered-containers-0.2.4.0:!test
06:49:36 <yoeight> [_47] trying: hashable-1.2.2.0 (dependency of unordered-containers-0.2.4.0)
06:49:36 <merijn> @where ops
06:49:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:49:38 <yoeight> [_48] trying: hashable-1.2.2.0:-sse41
06:49:40 <yoeight> [_49] trying: hashable-1.2.2.0:+sse2
06:49:41 --- mode: ChanServ set +o dcoutts
06:49:42 <yoeight> [_50] trying: hashable-1.2.2.0:+integer-gmp
06:49:42 <ivanm> albeit: yeah, you get stuff like that when pasting a huge thing
06:49:44 <yoeight> [_51] trying: hashable-1.2.2.0:!bench
06:49:46 <yoeight> [_52] trying: hashable-1.2.2.0:!test
06:49:46 <DogeHayashi> aaaand
06:49:48 <yoeight> [_53] trying: nats-0.2 (dependency of semigroups-0.14)
06:49:49 * hackagebot geek 1.1 - Geek blog engine  http://hackage.haskell.org/package/geek-1.1 (JinjingWang)
06:49:50 <yoeight> [_54] trying: nats-0.2:+hashable
06:49:51 * hackagebot geek-server 1.1 - Geek blog engine server  http://hackage.haskell.org/package/geek-server-1.1 (JinjingWang)
06:49:52 --- mode: ChanServ set +o geekosaur
06:49:53 <dcoutts> yoeight: use a paste service
06:49:54 <yoeight> [_55] trying: semigroupoids-4.0.2 (dependency of free-4.7.1)
06:49:56 <yoeight> [_56] trying: contravariant-0.6 (dependency of semigroupoids-4.0.2)
06:49:56 <albeit> ivanm: Good to know. Poor guy haha
06:49:57 <jesyspa> It's not Freenode's rate, it's a bad client that auto-throttles so that autokick doesn't set in.
06:49:58 <yoeight> [_57] trying: contravariant-0.6:+tagged
06:50:00 <yoeight> [_58] trying: transformers-compat-0.3.2 (dependency of contravariant-0.6)
06:50:02 <yoeight> [_59] trying: transformers-compat-0.3.2:-transformers3
06:50:03 --- kick: yoeight was kicked by geekosaur (yoeight)
06:50:04 <DogeHayashi> BANG
06:50:13 --- mode: geekosaur set -o geekosaur
06:50:22 <merijn> dcoutts: He couldn't stop, he already pasted everything, it's just freenode rate limiting slowing stuff down
06:50:29 * linduxed breathes a sign of relief
06:50:37 <bennofs> maybe unban him?
06:50:37 --- mode: ChanServ set -o dcoutts
06:50:47 <dcoutts> bennofs: he was not banned, just kicked
06:50:49 <geekosaur> I did not ban, just kicjk
06:51:00 <dcoutts> feel free to explain when he gets back
06:51:01 <bennofs> ah, I thought freenode has some kind of autoban if you kick
06:51:10 <dcoutts> not afaik
06:51:15 <Guest56643> actually a short ban without a kick might work for cases like that
06:51:29 <Guest56643> since the ban also mutes you
06:51:31 <ivanm> maybe /msg him to let him know what happened
06:51:35 <dcoutts> (but I'm not well versed with freenode policy)
06:51:36 <geekosaur> just did
06:51:36 <bennofs> Guest56643: or just mute :)
06:51:45 <dcoutts> geekosaur: ta
06:51:45 <Guest56643> oh, freenode has that
06:58:35 <ion> I donâ€™t get why every IRC client author implements buffering in such a stupid way. The list of buffered messages yet to be sent should be displayed separately below the chat and whenever there is such a list, it should indicate a key to pause/clear the buffer.
07:00:14 <albeit> Is there a way to get every field of a record into a tuple? Something like :: Foo -> (Int, String, Int, ....)?
07:00:31 <ivanm> albeit: maybe using generics...
07:00:44 <ivanm> (assuming you don't want to write an explicit function just for your one use-case)
07:01:36 <ion> albeit: Better response: why? :-P
07:02:21 <albeit> I'm trying to update a row using mysql_simple, and it wants the row to update in a tuple for parameter substitution, but it's current a record.
07:02:43 <ivanm> so it's too simple? :p
07:03:06 <ion> You could just do ad-hoc conversion.
07:03:13 <albeit> ivanm: Ha, guess so. Explicit function is easy enough, I'll just do that
07:03:39 <ivanm> yeah, if it's just for one type then doing a one-off function isn't too bad
07:03:54 <ivanm> if you were doing it for lots of types then I can see where having a function to do it for you would be handy :p
07:04:50 * hackagebot graphviz 2999.17.0.1 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.17.0.1 (IvanMiljenovic)
07:04:51 <yoeight> sorry for my last spams
07:05:03 <yoeight> everything has been handled now
07:05:24 <albeit> Taught me something new about freenode! ;)
07:06:23 <yoeight> albeit: you're always seeing the bright side :-)
07:08:02 <Sculptor> hi
07:09:57 <byorgey> yoeight: no worries
07:10:03 <byorgey> hi Sculptor
07:11:16 <jesyspa> albeit: Err, Freenode had nothing to do with it.
07:11:30 <jesyspa> It's a client "feature"; Freenode just kicks you.
07:12:04 <yoeight> jesyspa: I use hexchat
07:13:41 <jesyspa> yoeight: http://hexchat.readthedocs.org/en/latest/settings.html it's controlled by the net_throttle variable.
07:14:06 <albeit> jesyspa: Okay
07:14:40 <yoeight> jesyspa:thanks
07:15:22 <albeit> It's like an arms race... freenode learns to auto-kick spammers, clients learn to rate-limit to not get kicked, freenode... hopes admins are active!
07:16:26 <tdammers> albeit: not an arms race, no
07:16:32 <yoeight> albeit:Actually, I've been kicked by a human :-)
07:16:55 <tdammers> albeit: if everyone rate-limits automatically, spammers are reduced to a nuisance and can be dealt with more easily
07:25:58 <yoeight> does anyone know a way to make cabal display package that it can solved ?
07:26:20 <yoeight> being in -v3 yield too much packages
07:27:18 <yoeight> s/can/can't
07:28:11 <bennofs> yoeight: -v2?
07:29:04 <yoeight> bennofs:doesn't display any useful information
07:30:02 <yoeight> [__0] fail (backjumping, conflict set: ) --> I don't understand this
07:34:54 * hackagebot string-convert 0.1.0.0 - Provide universal string conversions between any two string-like types  http://hackage.haskell.org/package/string-convert-0.1.0.0 (TobiasDammers)
07:35:59 <ion> Uh, i need to log in to see <https://bitbucket.org/tdammers/string-convert>?
07:36:45 <bennofs> ion: I am logged in, but still can't see it
07:38:20 <tdammers> ion: yeah, haha
07:38:24 <tdammers> it's still private
07:38:25 <tdammers> hold on
07:38:43 <tdammers> aight, should be public now
07:38:58 <tdammers> highly unpolished, mind ya
07:39:05 <tdammers> basically hacked this together on the side
07:39:07 <tdammers> for fun
07:40:11 <xtofs> Hello everybody I have a question about the GHC API is there somebody who could help me with that ?
07:40:34 <bennofs> xtofs: don't ask to ask, just ask :)
07:42:02 <xtofs> I have something of type Type and I want to get the basic type
07:42:04 <napping> yoeight: doesn't it say something about what failed even without options?
07:42:23 <xtofs> i found out that it is of type TyConApp
07:43:18 <xtofs> http://www.haskell.org/ghc/dist/current/docs/html/libraries/ghc-7.7.20120902/src/TypeRep.html
07:44:01 <xtofs> The thing I want is to get something of the TypeRep and convert it to an internal representation I can work with as there is few documentation about TypeRep it is very confusing ...
07:44:18 <xtofs> I can't seem to find where the basic types are like Int Integer String etc...
07:45:43 <yoeight> napping:it does but with ~50 packages
07:53:18 <yoeight> well apparently, free package can't be install
07:57:26 <joeyh> I just had a user report a really strange error: Conflicting definitions for `_'
07:57:28 <joeyh> in yesod code that does DataType _ _ _ _ -> in a case expression
07:57:30 * joeyh is struggling to understand how any ghc could fail like that
07:58:28 <quchen> That's odd. But in any cases, you could do that using an empty record match, like "DataType {} ->".
07:58:32 <quchen> -s
07:58:34 <joeyh> hm, true
07:58:39 <joeyh> I forget about that syntax
07:58:44 <joeyh> often better, too
07:58:58 <quchen> That error is still strange though.
07:59:08 <bennofs> joeyh: might be related to the TypeHoles extension?
07:59:31 <joeyh> hmm, I have QuasiQuote, TypeFamilies, OverloadedStrings, only
07:59:41 <joeyh> unless hamlet code runs with more, which I don't think so
08:00:38 <joeyh> also, it's ghc 7.6.3, which is too old for type holes
08:06:19 <guymann> h
08:06:51 <benzrf> h
08:09:57 * hackagebot on-demand-ssh-tunnel 0.1.0.3 - Program that sends traffic through SSH tunnels on-demand  http://hackage.haskell.org/package/on-demand-ssh-tunnel-0.1.0.3 (pedja)
08:15:58 <c_wraith> Is there some class that's purely the intersection of profunctor and category?
08:16:23 <c_wraith> Or at least some term for that specific combination?
08:20:15 <benzrf> hey
08:20:19 <Polarina> Hello.
08:20:27 <benzrf> is there any declarative debugger for hs that is not long dead
08:22:33 <bennofs> benzrf: what's a
08:22:43 <bennofs> benzrf: 'declarative debugger'
08:22:51 <benzrf> bennofs: 1 sec
08:23:38 <pseudolio> benzrf: Don't think so.
08:23:39 <benzrf> http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf <- i read part of this
08:23:57 <benzrf> bennofs: the basic idea is to make an expression tree and calculate a timeline of reductions
08:24:10 <benzrf> then use something along the lines of git-bisect to locate the reduction that introduces a false equality
08:24:26 <bennofs> benzrf: the only debugger for haskell that I know is GHCi's integrated debugger
08:24:31 <benzrf> it suuuuuuuuucks
08:24:47 <benzrf> the paper i linked says that 'buddha' is a thing based off of the stuff in the paper
08:24:53 <benzrf> but buddha appears to be long dead
08:24:59 * hackagebot air 2014.5.19 - air  http://hackage.haskell.org/package/air-2014.5.19 (JinjingWang)
08:25:01 <pseudolio> Yes, buddha is dead.
08:25:03 <pseudolio> So is hat.
08:25:04 <benzrf> perhaps it will be reborn
08:25:07 <benzrf> :-O
08:25:35 <bennofs> benzrf: there is an emacs frontend for the ghci debugger: http://chrisdone.com/posts/ghci-debugger
08:25:39 <AlainODea> pseudolio: I'm sad hat is dead.  I could *really* have used it to debug an IO issue recently
08:25:47 <benzrf> bennofs: >emacs
08:26:06 <benzrf> >implying i use dynamically scoped languages
08:26:36 <pseudolio> I don't think it matters what front end you put on the ghci debugger, it won't do what buddha did.
08:26:51 <benzrf> =[
08:26:57 <benzrf> it never reached enlightenment
08:27:30 <n-dolio> The ghc debugger is just a step debugger with breakpoints and such.
08:29:59 * hackagebot air-th 2014.5.19 - air  http://hackage.haskell.org/package/air-th-2014.5.19 (JinjingWang)
08:30:01 * hackagebot OpenGLRaw 1.5.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.5.0.0 (SvenPanne)
08:30:03 * hackagebot nemesis 2014.5.19 - a task management tool for Haskell  http://hackage.haskell.org/package/nemesis-2014.5.19 (JinjingWang)
08:30:05 * hackagebot GLURaw 1.4.0.1 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.4.0.1 (SvenPanne)
08:30:07 * hackagebot nemesis-titan 2014.5.19 - A collection of Nemesis tasks to bootstrap a Haskell project with a focus on continuous integration  http://hackage.haskell.org/package/nemesis-titan-2014.5.19 (JinjingWang)
08:33:55 <Polarina> Still no KHR_debug in OpenGLRaw. :(
08:35:09 * hackagebot miku 2014.5.19 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2014.5.19 (JinjingWang)
08:35:11 * hackagebot geek 1.1.0.1 - Geek blog engine  http://hackage.haskell.org/package/geek-1.1.0.1 (JinjingWang)
08:35:13 * hackagebot sort-by-pinyin 2014.5.19 - Sort simplified Chinese by PinYin  http://hackage.haskell.org/package/sort-by-pinyin-2014.5.19 (JinjingWang)
08:35:15 * hackagebot OpenGL 2.9.2.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.9.2.0 (SvenPanne)
08:35:17 * hackagebot http-reverse-proxy 0.3.1.7 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.1.7 (MichaelSnoyman)
08:38:00 <solidus-1iver> is it normal to generalize types of data via your own classes within your module, are there good / bad ways to do that? I'm guessing you want to fully encapsulate your own classes so that no one else has to think about them
08:40:07 <{AS}> $/quit
08:40:12 <{AS}> sorry
08:40:29 <AlainODea> solidus-1iver: I'm inexperienced with Haskell design, but I think it is wise to limit how much you export generally.  What you export is your interface.
08:41:41 <AlainODea> solidus-1iver: the level of encapsulation depends on what you are happy committing to remaining stable in a semantic versioning sense. http://www.haskell.org/haskellwiki/Package_versioning_policy
08:43:35 <benzrf> typeclasses are converted to method dicts in Core, right
08:44:37 <AlainODea> solidus-1iver: from what I have seen discussed an read about, new type classes should be created infrequently and informed by a good understanding of those already available. http://www.haskell.org/haskellwiki/Typeclassopedia
08:46:12 <user`> what to do if I don't want to exit at end of file?
08:46:25 <benzrf> user`: ?
08:47:10 <AlainODea> user`: what are you running and hiw do you run it now?
08:48:31 <AlainODea> solidus-1iver: explore the design space with type classes absolutely.  If you find it fun or enlightening and it keeps you at it, there's nothing to lose but a bit of time refactoring
08:49:40 <user`> benzrf  http://pastebin.com/2XeXiDNm
08:50:01 * hackagebot GLUT 2.5.1.1 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.5.1.1 (SvenPanne)
08:50:13 <user`> I compiled it and run it like: ./programName < inputFile
08:50:40 <AlainODea> user`: right.  As in you want to stay running after STDIN is exhausted
08:51:00 <user`> I want it to wait for new things to come
08:51:07 <user`> from stdin
08:51:22 <user`> for example if the file will grow
08:52:12 <AlainODea> user`: sounds like you are implementing tail in Haskell.  That's definitely doable
08:52:54 <AlainODea> user`: it's a bit tricky though because you need to keep the original offset of EOF and retry
08:53:50 <jle`> is liftA2 (++) (take n) (drop n) an identity?
08:53:53 <oconnore> user`: You could use inotify or similar -> http://hackage.haskell.org/package/fsnotify
08:54:41 <user`> yes, I want something like tail
08:54:48 <jle`> @check (\(xs,n) -> (take n xs ++ drop n xs) == xs)
08:54:50 <lambdabot>  +++ OK, passed 100 tests.
08:55:00 <jle`> neat
08:55:11 <oconnore> user`: but I don't think you will be able to do ./programName < inputFile, because the shell will close the pipe on EOF.
08:55:44 <user`> ok
08:55:55 <user`> I will do it other way then
08:56:02 <user`> with handle or something
08:56:18 <benzrf> :t traverse
08:56:20 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:56:23 <benzrf> o=
08:57:35 <AlainODea> user`: taking the filename as an argument and using GHC.IO.Handle is a good option.  There are functions for open, seek, and close. Combined with notification as recommended by oconnore you should be set
08:58:43 <user`> ok
08:59:00 <user`> is there command for running external programs?
09:01:27 <AlainODea> user`: definitely. http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
09:02:07 <AlainODea> user`: Have you seen Hoogle yet? It's amazing. http://www.haskell.org/hoogle/?hoogle=runInteractive
09:03:03 <Ankhers> I'm trying to understand Arrows. Would someone please show me some example input / output of using first and second?
09:03:39 <allsystemsarego> > "hello" ^.. (traversed.indices (<3))
09:03:41 <lambdabot>  Couldn't match expected type â€˜(a
09:03:41 <lambdabot>                                 -> Control.Applicative.Const (Data.Monoid.End...
09:03:41 <lambdabot>                                -> p0 GHC.Types.Char (Control.Applicative.Const
09:03:41 <lambdabot>                                                        (Data.Monoid.Endo [a])...
09:03:41 <lambdabot>              with actual type â€˜[i0]â€™Couldn't match expected type â€˜GHC.Arr.Arr...
09:03:54 <byorgey> > first (*10) (1,2)
09:03:55 <lambdabot>  (10,2)
09:03:58 <byorgey> > second (*10) (1,2)
09:04:00 <lambdabot>  (1,20)
09:04:28 <byorgey> Ankhers: the (->) instance of Arrow comes in handly frequently, and can give you some good intuition for other instances
09:05:36 <Ankhers> byorgey: That is a lot more simple than I thought it was. Thank you.
09:09:14 <suppi> can anyone help me with Snap framework?
09:09:53 <suppi> I would like to catch an error from a sql query and display an error message on page but i don't really know how to
09:10:10 <suppi> how should i approach it?
09:11:20 <Ankhers> suppi: May want to ask in #snapframework
09:11:52 <suppi> I have, some time ago. still waiting for a response. thought I'd try here too
09:11:58 <suppi> thanks Ankhers :)
09:12:26 <user`> thanks :)
09:13:03 <AlainODea> user`: my pleasure :)
09:14:08 <_root_> http://dpaste.cc/paste/537a2d31435ccc5962000001
09:14:23 <_root_> It is like this almost 2hrs now
09:14:30 <_root_> in terminal
09:14:36 <_root_> what's wrong?
09:18:32 <_root_> anyone?
09:19:57 <AlainODea> _root_: what were you running?
09:20:03 * hackagebot VKHS 0.5.1 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.5.1 (SergeyMironov)
09:25:04 * hackagebot mangopay 1.6.0 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.6.0 (JeanPhilippeMoresmau)
09:25:05 * hackagebot hack2-contrib 2014.5.19.1 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2014.5.19.1 (JinjingWang)
09:29:36 <_root_> AlainODea, FreeBSD 10
09:30:06 <AlainODea> _root_: is that the GHC build?
09:31:12 <_root_> AlainODea, Yup
09:31:37 <deweyvm> @hoogle [(a,b)] -> [(a, [b])]
09:31:40 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
09:31:44 <_root_> AlainODea, a part of it .
09:31:59 <deweyvm> i guess ill write it myself
09:32:11 <_root_> AlainODea, `my terminal is like this for 2hrs now`
09:32:38 <AlainODea> _root_: It should definitely not take that long. http://haskell.inf.elte.hu/builders/freebsd-amd64-head/263.html
09:33:56 <AlainODea> _root_: it takes 1hr 45min for Karel Gardas from git clone to fully tested
09:36:36 <deweyvm> this works: MMap.assocs $ MMap.fromList xs
09:37:17 <deweyvm> hmm but i want them in order..
09:40:05 * hackagebot yesod-mangopay 1.6 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.6 (JeanPhilippeMoresmau)
09:43:59 <saep> > fmap (fmap (:[])) [(1,2),(3,4)]
09:44:01 <lambdabot>  [(1,[2]),(3,[4])]
09:45:05 * hackagebot cabal-cargs 0.6.1 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.6.1 (DanielTrstenjak)
09:45:14 <deweyvm> > fmap (fmap (:[])) [(1,2),(1,4)]
09:45:16 <lambdabot>  [(1,[2]),(1,[4])]
09:45:25 <deweyvm> but i want that to be [(1, [2, 4])]
09:45:55 <jfischoff> > Data.Map.empty
09:45:57 <lambdabot>  Not in scope: â€˜Data.Map.emptyâ€™
09:46:05 <jfischoff> > M.empty
09:46:07 <lambdabot>  fromList []
09:46:28 <deweyvm> i used MultiMap, but i also want to preserve ordering. ie [2,4] and not [4,2]
09:46:54 <jfischoff> > foldlâ€™ (\(k, v) -> M.insertWith (++) k [v]) [(1, 2), (1, 4)]
09:46:55 <lambdabot>  <hint>:1:6: lexical error at character '\8217'
09:47:04 <jfischoff> :x
09:47:19 <deweyvm> aha!
09:47:22 <deweyvm> thats neat
09:47:23 <deweyvm> thanks
09:50:05 * hackagebot HaTeX 3.13.0.1 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.13.0.1 (DanielDiaz)
09:50:10 <jfischoff> > foldl' (\h (k, v)-> M.insertWith (++) k [v] h) M.empty [(1, 2), (1, 4)]
09:50:12 <lambdabot>  fromList [(1,[4,2])]
09:50:17 <jfischoff> \o/
09:55:49 <k0ral> Hello, how can I retrieve information about the version of GHC installed in the user environment to have cabal perform some checks in the 'Setup.hs' build script ?
10:00:09 <hunt> how do i profile my project? its way too slow
10:00:35 <hunt> i dont think its the algorithms that are slow as much as the data structures or unneccessary inefficiencies
10:00:36 <jfischoff> kOral: you can use this to find what version the Setup.hs is run with: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Version.html
10:00:42 <alpounet> hunt: there's a nice chapter about this in real world haskell, and a couple of wiki pages & stackoverflow answers
10:00:53 <S11001001> hunt: the first alpounet stated being http://book.realworldhaskell.org/read/profiling-and-optimization.html
10:01:02 <hunt> thanks guys
10:01:18 <alpounet> (by wiki pages, I meant haskellwiki pages)
10:01:28 <jfischoff> oh wait k0ral ^^^
10:01:54 <jfischoff> k0ral: I linked to this http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Version.html but spelled your name wrong :(
10:05:05 <k0ral> jfischoff: this provides the version of the package one is currently installing; I'm interested in GHC's version; also, I'd like to know with which options GHC was compiled
10:05:40 <jfischoff> oh wait bad link
10:05:42 <jfischoff> one sec
10:08:59 <imalsogreg> I'm stuck on a networking problem, in linux, if anyone has some advice: http://lpaste.net/104316
10:10:15 <imalsogreg> I'm trying to recreate the behavior of a Pub socket from ZMQ (a server sends copies of data from a stream to all listeners)
10:10:48 <imalsogreg> So rather than giving each client a new thread, I just keep a list of client Handles in a TVar [Handle].
10:10:56 <jcapik> Good evening
10:11:10 <jcapik> I'm searching for help with the ghc bootstrap
10:11:21 <jcapik> anyone who can guide me?
10:11:33 <jcapik> the wiki seems to be obsolete
10:11:35 <imalsogreg> What I'm experiencing is that, if a single client quits, the server stops in its tracks, despite my attempt at catching the error on line 36
10:11:39 <jcapik> and the process doesn't work
10:12:36 <imalsogreg> jcapik: What system are you on  - where is the process breaking?
10:12:43 <jcapik> imalsogreg: ppc64le
10:12:50 <hunt> convert float to int?
10:12:58 <jcapik> imalsogreg: I'm trying to follow the wiki
10:13:13 <jcapik> imalsogreg: the configure command on the target doesn't work like expected
10:13:38 <jcapik> imalsogreg: ./configure --enable-hc-boot --enable-hc-boot-unregisterised
10:13:40 <imalsogreg> hunt: floor :: (Integral b, RealFrac a) => a -> b
10:13:51 <jcapik> imalsogreg: ^ ^ the above says, the second switch doesn't exist
10:14:19 <jcapik> imalsogreg: I tried without and even with updated config.guess and config.sub, the build/host/target is not detected correctly
10:15:11 <jcapik> imalsogreg: after forcing these, I get
10:15:12 <jcapik> configure: Building in-tree ghc-pwd
10:15:13 <jcapik> ./configure: line 3897: : command not found
10:15:13 <jcapik> checking for path to top of build tree... ./configure: line 3907: utils/ghc-pwd/dist-boot/ghc-pwd: No such file or directory
10:15:13 <jcapik> configure: error: cannot determine current directory
10:15:17 <jcapik> imalsogreg: ^ ^
10:15:30 <jcapik> imalsogreg: that's the target side
10:15:43 <jcapik> imalsogreg: moreover there's no configure.in anymore
10:16:00 <geekosaur> wiki is out of date, unregisterized doesn't work any more
10:16:10 <jcapik> geekosaur: hello
10:16:21 <jfischoff> k0ral: http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Info.html there we go
10:16:23 <geekosaur> I think the current bootstrap path involves -fllv,
10:16:27 <geekosaur> er -fllvm
10:16:29 <jcapik> geekosaur: so how does one bootstrap a new architecture?
10:16:35 <jfischoff> compilerVersion is what you want
10:16:42 <jcapik> geekosaur: I would appreciate a step by step howto
10:16:45 <geekosaur> you should probably ask in #ghc, I don't know current details
10:17:02 <geekosaur> alternately ask on the glasgow-haskell-users mailing list
10:17:27 <jcapik> geekosaur: had no idea about the channel
10:17:55 <jcapik> geekosaur: the channel doesn't exist
10:18:18 <k0ral> jfischoff: right, thank you; now I 'just' need to find the options used to compile GHC as well :)
10:18:43 <jcapik> sorry .... tried wrong server
10:20:09 * hackagebot language-glsl 0.0.1 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.0.1 (VoMinhThu)
10:20:25 <k0ral> basically I need to know whether GHC is using integer-gmp or integer-simple as big integer library
10:20:26 <skypers> hey, Iâ€™m looking for the function that applies n times a parser
10:20:35 <skypers> does it exist, or is it just replicateM p?
10:20:41 <skypers> replicateM n p
10:22:03 <dwcook> Yeah, that's it
10:22:23 <skypers> hm
10:22:30 <skypers> I thought there was an Applicative form as well
10:22:32 <skypers> like times
10:22:35 <skypers> :t times
10:22:37 <lambdabot> Not in scope: â€˜timesâ€™
10:22:42 <jle`> well replicateM is not inherently monadic
10:22:48 <skypers> :t replicateM
10:22:50 <lambdabot> Monad m => Int -> m a -> m [a]
10:22:53 <skypers> it is :(
10:22:55 <jle`> i mean, its source
10:22:59 <jle`> it doesn't use anything monad-specific
10:23:03 <skypers> @src replicateM
10:23:03 <jle`> you could write an Applicative version
10:23:03 <lambdabot> replicateM n x = sequence (replicate n x)
10:23:11 <skypers> oh
10:23:12 <skypers> yeah, sure
10:23:18 <skypers> but why doesnâ€™t it exist yet?
10:23:19 <jle`> :t \n x -> T.sequenceA (replicate n x)
10:23:20 <lambdabot> Applicative f => Int -> f a -> f [a]
10:23:29 <jle`> it might in Traversable somewhere hm.
10:23:47 <dwcook> :t Data.Traversable.sequenceA
10:23:48 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
10:24:08 <jle`> welp guess not
10:24:12 <dwcook> Though if you're not writing general combinators it hardly matters which you choose, I'd say
10:24:23 <dwcook> jle`: what do you mean guess not? I just showed it
10:24:23 <skypers> dwcook: Iâ€™m using parsec
10:24:30 <skypers> and I love keeping using applicative forms
10:24:42 <jle`> guess ont that there's tno built in replicateA
10:24:44 <jle`> *not
10:24:50 <dwcook> Oh, replicateA
10:24:51 <skypers> I didnâ€™t find a function you pass the number of times you want the parser applied
10:25:09 * hackagebot apiary-websockets 0.4.3.4 - websockets supper for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.4.3.4 (HirotomoMoriwaki)
10:25:15 <dwcook> skypers: for Applicative I doubt that's defined, even though it could be. Define your own or use replicateM.
10:25:29 <skypers> yeah, ParsecT is in Monad
10:25:32 <skypers> so I use replicateM :)
10:25:38 <skypers> it was just a curious question :)
10:25:52 <dwcook> It's definitely something that would reasonably exist, it just doesn't seem to
10:25:55 <jle`> sequenceA is foldr (liftA2 (:)) (pure []) i think
10:26:05 <jle`> well, there are probably optimized versions
10:26:12 <jle`> for general Traversable
10:26:56 <skypers> ok, thank you guys
10:28:09 <imalsogreg> In other words, when client quits, I never get to see the "error" message (re: http://lpaste.net/104316)
10:29:23 <benzrf> hey
10:29:32 <jle`> hi benzrf
10:29:37 <benzrf> Traversable is for things that can be sequenced?
10:29:50 <jle`> um. that's how i think about it
10:29:54 <geekosaur> imalsogreg, my guess is you aren't handling SIGPIPE
10:29:54 <jle`> in my day to day
10:29:58 <benzrf> ok o=
10:30:01 <jle`> :t sequenceA
10:30:02 <lambdabot>     Not in scope: â€˜sequenceAâ€™
10:30:02 <lambdabot>     Perhaps you meant one of these:
10:30:02 <lambdabot>       â€˜T.sequenceAâ€™ (imported from Data.Traversable),
10:30:07 <jle`> :t T.sequenceA
10:30:08 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
10:30:10 <jfischoff> k0ral: perhaps this will work: http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-Environment.html
10:30:38 <jle`> by extension, they are things that can be mapM'd...but mapM f is just sequence . map f
10:30:49 <imalsogreg> geekosaur: That's true here. In the bigger program that the lpaste was modeling, I treated the sigPIPE by Ignore-ing it through installHandler in main.
10:30:52 <wondiws> I'm new to haskell and I want to compile an example, I get "Could not find module 'Data.Binary.Strict.Get'. How can I find out if there's a package for this in Debian?
10:30:54 <geekosaur> imalsogreg, this is not a Haskell issue, for whatever reason (probably because of how 4.2BSD implemented pipes)  various unixlikes send a signal for write on a pipe with no reader
10:31:04 <wondiws> is this a common module that is likely to be included in a distribution?
10:31:22 <jle`> wondiws: not quite; it's actually discouraged to get your modules through your os's package manager
10:31:25 <jle`> cabal is the recommended tool
10:31:32 <benzrf> why constrain Traversable to Functors?
10:32:04 <benzrf> why not make traverse a separate function that constrains Functor as well as Traversable
10:32:08 <k0ral> jfischoff: already tried that one, it gives me the commandline options used to call GHC
10:32:15 <k0ral> jfischoff: but thanks for the effort :)
10:32:25 <jfischoff> wait is that not what you want?
10:32:26 <dwcook> benzrf: the Traversable methods give rise to Functor with no extra work
10:32:34 <jle`> benzrf: well...a shallow answer would be also that the Traversable laws involve fmap
10:32:42 <benzrf> jle`: oh wait
10:32:44 <benzrf> haha
10:32:49 <benzrf> dwcook: how so
10:32:56 <jle`> but that probably is not a satisfying answer :)
10:32:56 <dwcook> benzrf: look at fmapDefault
10:33:42 <jle`> fmapDefault f = runIdentity . traverse (Identity . f)
10:33:48 <dwcook> So really I mean traverse gives rise to fmap
10:34:16 <benzrf> dwcook: well that's trivial o=
10:34:19 <imalsogreg> geekosaur: I don't know much about these signals though - do you expect if I read more about the Handlers, I'll be able to figure out which pipe got closed, and cancel the correct hPut?
10:34:23 <benzrf> 01:30 < benzrf> why not make traverse a separate function that constrains Functor as well as Traversable
10:34:33 <benzrf> then keep sequenceA as the method
10:34:50 <jle`> traverse doesn't require fmap; it can be used to implement fmap
10:35:07 <benzrf> i mean use the default impl
10:35:24 <jle`> oh
10:35:26 <jle`> hm
10:35:31 <geekosaur> imalsogreg, if you ignore SIGPIPE then the corresponding write should throw EPIPE or similar error instead, so you need an exception handler
10:35:37 <jle`> like have Traversable only provide sequenceA ?
10:35:40 <benzrf> ye
10:35:48 <jle`> and have traverse be a separate fuction that is implemented in terms of fmap and sequenceA
10:35:53 <benzrf> precisely
10:35:57 <dwcook> Any way you put it, the current notion of Traversable lets you define Functor for free. You'd have to have a different notion of Traversable for that not to be the case.
10:36:17 <dwcook> So is the question really "Why do we call this particular notion Traversable?"
10:36:24 <jle`> so i guess Traversable really isn't "things you can sequence", like I said before
10:36:25 <imalsogreg> geekosaur: Oh. Thanks!! That's enough to get me going on the rest of my search.
10:36:30 <jle`> they are things you can sequence and traverse
10:36:31 <jle`> heh.
10:36:52 <benzrf> lame
10:37:05 <jle`> presumably being able to write a traversable-specific traverse/mapM has major performance benefits
10:37:10 <benzrf> 'things you can traverse' is just 'things you can sequence that are functors'
10:37:25 <jle`> like a traverse specific to your Traversable
10:37:32 <dwcook> benzrf: so you want a separate class just for things that you can sequence?
10:37:34 <jle`> might be faster than a sequence . fmap f
10:37:54 <benzrf> dwcook: i dunno m8
10:38:01 <benzrf> it just seems simpler
10:38:04 <benzrf> more elegant
10:38:07 <dwcook> I'm just not sure I understand the question
10:38:10 <benzrf> like monad in terms of join instead of bind
10:38:21 <benzrf> :o
10:38:25 <dwcook> For some value of "elegant" I suppose
10:38:38 <benzrf> =_=
10:38:39 <jle`> it is more minimal while providing the same functionality
10:38:42 <jle`> i guess
10:38:43 <benzrf> jle`++
10:38:47 <benzrf> minimalism ftw
10:38:49 <jle`> i'll stand by my performance statement though
10:38:54 <benzrf> wweh
10:39:00 <dwcook> Minimalism in the definition might lead to complexity elsewhere
10:39:12 <dwcook> I'd rather stare at a bunch of (>>=)s than a bunch of joins, generally
10:39:14 <jle`> just like why mconcat is a part of the Monoid typeclass for some reason
10:39:29 <benzrf> you can make >>= in terms of join though
10:39:36 <benzrf> and join makes more sense as the typeclass method
10:39:55 <jle`> nah (<=<) should be the typeclass method
10:39:55 <benzrf> join is the minimal method unique to monads
10:39:58 <dwcook> Sure. And then there's a question of "Does performance matter? What has the right balance of performance and other factors?"
10:40:03 <benzrf> :t (<=<)
10:40:05 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:40:06 <benzrf> dwcook: =[
10:40:19 <jle`> the laws are derived from the behavior of (<=<)
10:40:24 <jle`> so...
10:40:47 <dwcook> Plus some things might be formulated more simply in terms of (>>=) than join
10:40:58 <dwcook> I couldn't say what but it's conceivable
10:41:01 <skypers> hm
10:41:02 <jle`> (my point is that you can argue all day about this :) )
10:41:06 <dwcook> I'm mostly playing devil's advocate here
10:41:11 <skypers> isnâ€™t CharParser able to handle user states?
10:41:38 <benzrf> dwcook: i appreciate it
10:41:40 <dwcook> But fortunately we'll get some of the best of both worlds soon when join becomes a method
10:41:45 <benzrf> arguing is fun :-D
10:41:58 <jle`> i wouldn't mind join becoming a part of the typeclass actually, alongside (>>=)
10:42:10 <skypers> hm, maybe a ParsecT is in MonadState only if the underlying monad is in MonadState
10:42:13 <dwcook> It's happening. 7.10 I think, along with Monad-Applicative
10:42:14 <skypers> and ChareParser hosts an Identity
10:42:21 <jle`> i would argue for (=<<) replacing (>>=) but because (>>=) is used in desugaring do notation, that might not be ideal
10:42:21 <skypers> Char*
10:42:40 <dwcook> So make (=<<) a method too :)
10:42:52 <jle`> add all the methods!
10:43:01 <jle`> by the way is method the correct term for this
10:43:12 <jle`> i always have problems picking the right word
10:43:12 <dwcook> Yes.
10:43:16 <jle`> okay, cool
10:43:25 <fuzzyhorns> hello haskell
10:43:29 <jle`> hello fuzzyhorns
10:43:31 <Welkin> hallo
10:43:39 <dwcook> In "class Foo a where foo :: â€¦", "method" is a correct term for "foo".
10:43:42 <fuzzyhorns> anyone used mflow?
10:43:44 <dwcook> Woops gotta catch a bus bye
10:44:33 <benzrf> wots mflow
10:44:35 <benzrf> :t mflow'
10:44:37 <lambdabot> Not in scope: â€˜mflow'â€™
10:44:38 <benzrf> :t mflo
10:44:38 <lambdabot> Not in scope: â€˜mfloâ€™
10:44:40 <fuzzyhorns> http://mflowdemo.herokuapp.com/
10:44:40 <benzrf> gah
10:44:42 <benzrf> :t mflow
10:44:43 <lambdabot> Not in scope: â€˜mflowâ€™
10:44:44 <jle`> it's a library
10:44:46 <benzrf> oh
10:44:55 <jle`> er, a web framework
10:44:58 <fuzzyhorns> a friend recommended i try snap framework
10:44:59 <benzrf> omg
10:45:00 <fuzzyhorns> which is cool so far
10:45:05 <fuzzyhorns> but i was also curious about it vs mflow
10:45:06 <benzrf> i was asking about something like seaside in here like 2 days ago
10:45:11 <FUZxxl> jle`: Hello jle` !
10:45:11 * hackagebot apiary-cookie 0.6.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.6.0.0 (HirotomoMoriwaki)
10:45:11 <benzrf> fuzzyhorns: thx for showing me this o=
10:45:13 * hackagebot apiary 0.6.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.6.0.0 (HirotomoMoriwaki)
10:45:18 <fuzzyhorns> i wasnt sure if mflow was a lighter framework
10:45:23 <jle`> hi FUZxxl!
10:45:36 <jle`> fuzzyhorns: it looks interesting, but I havne't used it
10:45:39 <fuzzyhorns> benzrf:  :)
10:46:17 <FUZxxl> Didn't realize there is a user called fuzzyhorns.
10:46:43 <fuzzyhorns> FUZxxl: im trying to hang out here a bit more often but i am sure you are #1 fuz
10:46:51 <alpounet> 'scotty' is a nice simple framework too
10:47:20 <jle`> i've used scotty in the past and it was nice to work with
10:47:27 <jle`> probably because i came from sinatra and ruby
10:47:43 * benzrf fistbumps jle` 
10:47:55 <jle`> o/
10:47:57 <fuzzyhorns> jle`: im a ruby person atm
10:47:58 <fuzzyhorns> for work
10:48:04 <napping> I'm not sure mflow and snap are similar at all
10:48:08 <fuzzyhorns> jle`: any advice on a good first app to write to learn haskell?
10:48:15 <benzrf> fuzzyhorns: write a lisp!
10:48:16 <benzrf> :-D
10:48:17 <fuzzyhorns> napping: they might be totally different
10:48:17 <jle`> well, my second app was my blog engine
10:48:22 <jle`> er, my second haskell project
10:48:26 <fuzzyhorns> benzrf: a lisp?
10:48:31 <benzrf> fuzzyhorns: implementing a lisp is always fun
10:48:32 <benzrf> :-O
10:48:33 <napping> It seems like mflow is a fancy approach for keeping state/interactions in a website
10:48:42 <napping> while snap/scotty/yesod/etc. are more like traditional frameworks
10:48:47 <benzrf> napping: have you never seen a continuation-based web framework
10:48:51 <benzrf> smh'
10:48:54 <fuzzyhorns> benzrf: you mean writing an interpreter for lisp or something?
10:49:01 <jle`> i like to make the comparison, yesod ~ rails, scotty ~ sinatra
10:49:04 <benzrf> fuzzyhorns: a scheme, if you prefer
10:49:05 <benzrf> o=
10:49:15 <fuzzyhorns> napping: yeah snap was quite recognizable to me from my working life
10:49:16 <benzrf> jle`: i should probably learn rails at some point
10:49:26 <fuzzyhorns> napping: mflow seems different and interesting
10:49:37 <jle`> scheme Ïµ lisp
10:49:40 <benzrf> fuzzyhorns: there's seaside for if you wanna try smalltalk
10:49:42 <napping> benzrf: sure, but I think at this point mflow has the contiunations but not so much of the framework part
10:49:46 <benzrf> napping: haha
10:50:11 <napping> or even better, a neat approach that avoids needing to serialize continuations
10:50:11 <jle`> benzrf: nah. i used it for a hackathon because my entire team only knew it, and it wasn't anything too spectacular
10:50:11 <fuzzyhorns> rails is alright, i think people tend to turn it into their entire app
10:50:19 <fuzzyhorns> rather than just using it to handle the rest api which it is ideal for
10:50:38 <fuzzyhorns> napping: sorry what do you mean by continuations in this context?
10:50:52 <jle`> fuzzyhorns: have you done web apps in ruby?
10:50:58 <napping> Well, writing your code like sending a form to a user and asking a reply is a blocking action
10:51:12 <jle`> a web app might be a bit diving-head-first for a first or second haskell project
10:51:19 <benzrf> fuzzyhorns: traditionally continuations are snapshots of the stack that can be called like a function
10:51:20 <jle`> it took me a full three months or or less to get a handle on everything
10:51:25 <jle`> just for that second project
10:51:37 <jle`> so i can't fully endorse it :)  but if you have a lot of determination, go for it
10:51:40 <fuzzyhorns> jle`: my working life is all rails + ruby
10:51:46 <napping> That's very far from an actual definiton of continuations, but it's what they are used for in web applications - and mflow provides a similar interface without actually using continuations
10:51:56 <fuzzyhorns> benzrf: ok that is what i thought
10:52:09 <jle`> yesod is like rails in that it sort of comes with all of the scaffolding included
10:52:14 <fuzzyhorns> napping: continuations like goto satements?
10:52:19 <fuzzyhorns> ruby has continuations but i have never used them
10:52:31 <benzrf> fuzzyhorns: continuation-passing style (in webapps, at least) is similar to node.js-like callbacks but without explicitly wrapping the handler in a lambda
10:52:34 <napping> kinda like a goto with an argument, I suppose
10:52:40 <jle`> where scotty is more, you set up methods that return html pages, and hook them up to routes
10:52:45 <fuzzyhorns> it was interesting to me to read oreillys guide on rest apis, then work on rails, which basically implements it point by point
10:52:47 <napping> or setjmp/longjump
10:52:56 <fuzzyhorns> napping: i would think those are terrible :x
10:53:11 <fuzzyhorns> yknow the joke the "wherefrom" function
10:53:12 <napping> they can get very confusing
10:53:36 <benzrf> i read the rest stuff
10:53:40 <benzrf> it's a cool idea yo
10:53:43 <napping> but you use them so when you call the "render page and wait for response" function, it saves up a continuation to come back, and then puts that on a list or something
10:53:49 <fuzzyhorns> it definitely simplifies things
10:53:58 <napping> and then the server calls the continuation to continue running your logic once the user replies
10:54:21 <fuzzyhorns> napping: yeah, makes sense, but seems dangerous and bad :x
10:54:41 <napping> well, that's why they are used carefully inside a library, then you don't have to mess with them yourself
10:54:58 <jle`> what sort of other projects have you done? in ruby or otherwise
10:55:02 <benzrf> fuzzyhorns: you should try seaside
10:55:07 * benzrf has not actually used seaside
10:55:12 * hackagebot language-glsl 0.0.2 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.0.2 (VoMinhThu)
10:55:12 <napping> mflow uses a different idea anyway - if you save all the user input, you can fast-forward through actually sending pages to them to pick up where you left off
10:55:39 <fuzzyhorns> jle`: mostly just web stuff, this weekend i did an irc bot heh
10:55:40 <jle`> who actually uses anything
10:55:41 <alpounet> oh, there's also 'simple'
10:55:41 <napping> then there are some tricks about pruning and folding the log back on itself to make it more efficient if they browse around in circles
10:55:45 <alpounet> @hackage simple
10:55:46 <lambdabot> http://hackage.haskell.org/package/simple
10:56:01 <jle`> fuzzyhorns: an irc bot in haskell might be an interesting project
10:56:09 <fuzzyhorns> jle`: id enjoy writing another
10:56:10 <jle`> i have one up and running using frp-like principles
10:56:17 <benzrf> frp yo
10:56:18 <fuzzyhorns> jle`: my current bot is demobot in #demobot
10:56:31 <jle`> (i'm still figuring out what to call the set of semantics)
10:56:35 <fuzzyhorns> jle`: makes sense, id like to try something in frp
10:56:44 <jle`> (but i have been told i am not allowed to call it frp because it doesn't have continuous time semantics)
10:56:49 <jle`> (so i can just say inspired-by-frp)
10:56:57 <fuzzyhorns> oh hah, i dont know it that well
10:57:01 <fuzzyhorns> so i wouldnt be one to critique
10:57:13 <conal> jle`: thanks! "inspired by" works.
10:58:36 <jle`> conal: np! i had a feeling about it anyway.  trying to figure out a concrete set of semantics for this domain at the moment actually.  and then maybe a name.  did you happen to be there during my #haskell-game conversation with ertugrul?
10:58:44 <conal> Not that "FRP" is a great name, but I hate to see confusion spread when people apply the term to systems that don't follow the two fundamental properties I designed FRP around (continuous time and precise denotation -- http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language/5878525#5878525)
10:59:04 <jle`> conal: of course; i am no stranger to your papers :)
10:59:12 <jle`> great work btw, i don't think i've told you directly
10:59:20 <teknokratsevilla> FRP ?
10:59:22 <conal> jle`: thanks! :)
10:59:28 <conal> teknokratsevilla: see the link
10:59:43 <conal> jle`: no. i missed that #haskell-game cha.
11:00:12 * hackagebot scientific 0.3.2.1 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.2.1 (BasVanDijk)
11:00:19 <jle`> i do notice that you aren't on there now; do you not idle there?  i always thought you did for some reason
11:00:48 <conal> jle`: i'm glad for the reminder about #haskell-game. i just re-joined. is that chat room logged/archived?
11:01:02 <fryguybob> conal: It is on irc-browse
11:01:11 <fryguybob> http://ircbrowse.net/
11:01:54 <conal> fryguybob: thanks!
11:02:23 <conal> cool! i didn't know about irc-browse
11:02:28 <fryguybob> chrisdone++
11:02:34 <conal> amen!
11:02:52 <jle`> conal: http://ircbrowse.net/browse/haskell-game?id=58554&timestamp=1400392132#t1400392132 is where it starts
11:03:01 <benzrf> shit
11:03:03 <benzrf> ran out of charge
11:03:04 <benzrf> >_>
11:03:19 <jle`> ignore my "frp w/out behaviors", that was a bad attempt at stating what i was going for
11:03:21 <teknokratsevilla> 'reactivity' does exist
11:03:21 <jle`> heh.
11:03:23 <teknokratsevilla> and it's an issue
11:03:31 <conal> jle`: coincidentally, i just wrote some notes on "why continuous time matters", following a talk i gave yesterday. https://github.com/conal/talk-2014-bayhac-denotational-design
11:03:54 <benzrf> hmm
11:04:03 <benzrf> do you guys know if there's anything like that in new england
11:04:09 <jle`> conal: i tweeted your article on that subject :) but glad the talk is up and online
11:04:10 <benzrf> *like bayhac
11:04:19 <jle`> wans't there that NY event?
11:04:32 <jle`> a couple of months back?
11:04:47 <toki78> hi folks
11:04:52 <jle`> hello toki78
11:05:02 <conal> jle`: ah!
11:05:25 <benzrf> jle`: hell if i know
11:06:03 <toki78> I will write another lib for hacakge
11:06:07 <toki78> hackage
11:06:18 <toki78> a learning algorithm
11:06:21 <conal> benzrf: there's been HacPhi: http://www.haskell.org/haskellwiki/Hac_%CF%86
11:06:41 <benzrf> >not typing out Ï†
11:06:47 <teknokratsevilla> a bit hard for me,...
11:06:58 <teknokratsevilla> discrete calculus + haskell
11:07:21 <benzrf> is there gonna be another one this year?
11:07:24 <jle`> i wonder if there is anything like it in the LA area
11:07:49 <jle`> but maybe i can convince my university to pay for a trip to the bay area next year
11:07:54 <benzrf> i need something close enough that my parents might consider paying for travel
11:08:59 <jle`> benzrf: http://www.haskell.org/haskellwiki/Hac_NYC
11:09:24 <jfischoff> conal: I realized something about your talk last night. Understanding homomorphisms is a prerequisite to the talk
11:09:32 <toki78> if I want to upload to hackage, does the package need to have a certain file structure ?
11:10:18 <benzrf> mhmmm
11:10:25 <jle`> toki78: presumably, cabal init should take care of most of the structure for you
11:10:26 <Heffalump> toki78: if it was made with cabal sdist and passes cabal check it ought to be fine (there are exceptions)
11:10:26 <benzrf> what's a homomorphism in haskell
11:10:27 <conal> jfischoff: ah, interesting. hm. what would someone have to (or want to) understand about homormorphisms other than what I showed?
11:10:32 <benzrf> something like
11:10:34 <benzrf> f a -> g a?
11:10:58 <toki78> Heffalump, jle` thanks
11:11:03 <benzrf> i dont know a lot of the math behind haskell >.>
11:11:09 <conal> jfischoff: i'm wondering whether to improve by toning down the terminology (maybe just mentioning "homomorphism" at the end) or by saying more about it up front.
11:11:16 <jle`> f a -> g a would be more like a natural transformation
11:11:45 <jfischoff> conal: More I think. I think much of how the meaning functions works is from is because it is homomorphism
11:11:47 <benzrf> :I
11:12:05 <benzrf> i know the teensiest bit of abstract algebra
11:12:05 <jle`> a monoid homomorphism would be...if you have a monoidal structure and you map it to another structure, that new structure is also a monoid, with the original identity mapping to the new identity
11:12:09 <jle`> ...i think
11:12:13 <benzrf> typeclass instances would be structures right?
11:12:29 <benzrf> while classes themselves are types of structures
11:12:50 <vanila> important thing about a homomorphism is it preserves structure .e.g f(x+y) = f(x)+f(y)
11:12:50 <jfischoff> for instance the distribution of meaning, e.g. meaning (f . g) = meaning f . meaning g is just restated that meaning must be a homomorphism
11:12:51 <benzrf> so let me read about the abstract alg. definition of a homomorphism
11:12:55 <jfischoff> conal: right?
11:13:25 <saml> right
11:13:47 <jfischoff> conal: but there is an abuse of syntax there. The â€˜.â€™ and different on each side of the =
11:13:49 <jle`> i think...length is a monoid homomorphism, with the monoid formed by (+,0) over the Ints
11:13:53 <conal> jfischoff: specifically, the requirement is that the meaning function is a homomorphism for *all* type classes (algebraic abstractions) that the data type inhabits.
11:14:00 <jfischoff> yes
11:14:25 <conal> jfischoff: indeed, the two notions of (.) differ. they belong to different instances of the same abstraction / type-class.
11:14:29 <jle`> so with length you go from [a] -> Int; both are monoids, and the identity of [a] gets mapped to the identity of Int in (+,0), 0
11:14:33 <jfischoff> yes
11:14:34 <vanila> jle`, yeah
11:14:57 <conal> jfischoff: it's the same "abuse" (i.e. overloading) that we use all the time with type classes. not ambiguous in my examples, but requires some type inference.
11:15:04 <jfischoff> I think it is worth working through a simple example in a very precise sense perhaps
11:15:16 <jfischoff> I could be wrong
11:15:22 <jle`> so xs <> ys <> [] maps to length xs <> length ys <> length []
11:15:31 <jfischoff> but there were two questions I think that were related to that
11:15:39 <jle`> abusing <>
11:15:48 <conal> for the benefit of others, we're discussing the "denotational design" talk i gave yesterday, which can be found at https://github.com/conal/talk-2014-bayhac-denotational-design
11:17:11 <jfischoff> marks â€œdoes it always work this wayâ€ I think was about meaning distributing over the type class method arguments, and the answer is yes
11:17:19 <conal> jfischoff: hm. simple example precisely worked is what i was trying to do with 1D linear transformations, but it sounds like it didn't quite work.
11:17:24 <benzrf> hmm
11:17:30 <benzrf> so would a homomorphism over a
11:17:32 <benzrf> monoid
11:17:34 <benzrf> be like
11:17:40 <teknokratsevilla> I thought that prolog DCG was nearly the top of complex things...
11:17:40 <fuzzyhorns> ty conal
11:17:45 <conal> fuzzyhorns: :)
11:17:55 <jfischoff> conal: I think it needs more background on homomorphism
11:17:56 <teknokratsevilla> and then appears this FRP
11:17:56 <benzrf> homo a <> homo b = homo (a <> b)
11:18:22 <conal> jfischoff: yes. whenever the meaning function doesn't distribute, it's an abstraction leak.
11:18:22 <ReinH> conal: great to meet you btw
11:18:27 <conal> ReinH: :)
11:18:56 <jfischoff> which makes perfect sense when you really understand that it is homomorphism and why it must be
11:19:22 <jfischoff> also there is another part of homomorphisms that I forget, that is helpful
11:19:27 <conal> jfischoff: thanks for that feedback. i'm going to expand the talk to a 2.5 hour workshop at the Chicago LambdaJam in July.
11:19:31 <jle`> benzrf: yes, with the condition that homo id  is the identity in the codomain
11:19:37 <ReinH> jfischoff: ?
11:19:41 <jfischoff> yeah I remember you saying that
11:20:00 <jfischoff> the other thing I forget sometimes is that a homomorphism is not an isomorphism
11:20:15 <ReinH> jle`: the free monoid is an initial object, so there are morphisms to all other monoids.
11:20:20 <jfischoff> so the meaning can move into a â€œbiggerâ€ type, e.g. reals
11:20:34 <jfischoff> but it doesnâ€™t have to go the other way
11:21:38 <conal> jfischoff: hm. i could focus on abstraction leak-free-ness and later mention homomorphisms as a crisp definition. or start with homomorphism and explain how it makes for non-leaky abstractions. the former is on firmer ground, while i expect the latter to be more relatable to programmers, many of whom don't like math.
11:22:25 <jfischoff> conal: good point, you could derive a leak free abstraction and show it is homomorphism
11:22:27 <conal> i really want to inspire these programmers to embrace math.
11:22:31 <ReinH> conal: I'm a big fan of starting with concretions as long as they don't introduce extraneous laws/properties that might lead to wrong intuitions
11:22:41 <teknokratsevilla> I think haskell would be a great metaprogramming language
11:22:56 <teknokratsevilla> you could use it to create python code
11:23:03 <teknokratsevilla> out of abstract models
11:23:03 <ReinH> This (one reason) is why free objects are useful pedagogic tools: their properties are exactly those defined by the laws and no others.
11:23:03 <jfischoff> â€œwhat would a leak free abstraction look like? It would have to â€¦â€ etc
11:23:16 <jfischoff> ReinH: yeah
11:23:23 <conal> jfischoff: i think i tried to do just that in the talk by not using "id" and "(.)" at first. then switch to Category, and show that the spec now has a special form, which we call "homomorphism".
11:23:53 <ReinH> conal: if you can define that form for the concretion without refering to properties that are extrinsic to the abstraction
11:23:53 <conal> jfischoff: i think you're saying that i could execute this plan better. thanks!
11:23:55 <teknokratsevilla> homomorphism is a polysemic meaning
11:23:58 <jfischoff> yeah the talk is compressed cause of the time
11:24:00 <ReinH> like "wrapping" and "unwrapping" for monads
11:24:05 <ReinH> then I think it works quite well
11:24:42 <jfischoff> conal: Oh I am not critizing. Each time you talk I understand things a little better, just trying to help with the bridge to the lost
11:25:19 <ReinH> conal: Mac Lane introduces categories from sets, for instance, because categories are "just" sets with identity and composition. The issue is that this leads to the wrong intuition that all categories are concrete, so one must be aware of this.
11:25:25 <jfischoff> conal: I really feel like you are fighting the good fight, spent last night thinking how you could reach more people
11:25:28 <conal> jfischoff: i welcome and appreciate the criticism! i know i don't know how to get my message across as effectively as i want to.
11:25:57 <jfischoff> :)
11:26:13 <Philonous> ReinH, But categories aren't even (necessarily)  sets, are they?
11:26:24 <conal> jfischoff: i'm going to play with your suggestion: â€œwhat would a leak free abstraction look like? It would have to â€¦â€ etc. sounds like a great starting point in rethinking my presentation!
11:26:26 <ReinH> Philonous: exactly
11:26:39 <ReinH> Philonous: concrete categories are those whose objects are members of some set, basically
11:26:43 <jfischoff> conal: Iâ€™m giving you credit for it :)
11:27:02 <ReinH> Philonous: so this introduction causes people to think that all categories are concrete, and this wrong intuition has to be fixed later on
11:27:16 <ReinH> by introducing non-concrete categories
11:27:17 <Philonous> ReinH, Ah, I didn't know that "concrete" in the setting has a precise definition.
11:27:19 <conal> jfischoff: oh? funny. i like that kind of synergy -- both thinking that a good idea came from the other.
11:27:29 <conal> s/both/each/
11:27:30 <teknokratsevilla> I think you should explain all the notation, conal
11:27:32 <jfischoff> :)
11:27:34 <teknokratsevilla> every single operator
11:27:49 <ReinH> (The technical definition is that a concrete category is equipped with a faithful functor to the category of sets)
11:28:32 <conal> teknokratsevilla: i hope i did (in the talk), except for basic haskell itself, since it was a haskell gathering. at lambdajam i'll explain more haskelisms.
11:28:47 <ReinH> Philonous: now, you can introduce categories "perfectly" by building them from directed (multi)graphs without causing this leak, because categories are free directed multigraphs.
11:28:48 <teknokratsevilla> what about going in several steps of abstraction?
11:29:01 <conal> hopefully we'll have videos to share soon. thanks to zaki.
11:29:11 <Philonous> ReinH, What's the distinction between a small category and a concrete one?
11:29:12 <teknokratsevilla> this talk jumps directly to the topmost
11:29:22 <ReinH> So the process of building abstractions from concretions is useful but somewhat fraught :)
11:29:22 <Philonous> ReinH, distinction/difference
11:29:48 <ReinH> Philonous: a category is small if both objects and arrows are sets
11:30:34 <ReinH> Philonous: another way of looking at concrete categories is that they are a set with some additional structure where arrows respect that structure
11:30:52 <conal> teknokratsevilla: right-on about metaprogramming. it's a big application area for haskell.
11:31:39 <teknokratsevilla> the problem with imperative languages, even with python is that it seems you are doing the same thing over and over again
11:31:43 <teknokratsevilla> with small variations
11:32:14 <ReinH> conal: I suspect that you could introduce a significant amount of algebra by climbing the abstraction ladder using free functors. I wonder how effective this would be.
11:32:15 <teknokratsevilla> and the "problem" is not "well represented"
11:32:20 <teknokratsevilla> just implemented
11:33:29 <conal> ReinH: perhaps so. but keep in mind that i'm trying to address an audience who's not as interested in algebra as you & i are. i want to inspire them to want it in order to help them with something they already want.
11:33:51 <ReinH> conal: Absolutely. I'm just thinking about how this might translate into the construction of other abstraction ladders
11:33:56 <ReinH> conal: like the one you're introducing
11:34:19 <ReinH> At the least it might motivate the use of concretions that don't "lie" as much as others
11:34:36 <ReinH> i.e. have less extrensic properties that cause wrong intuitions
11:35:00 <Philonous> ReinH, Can you give an example of a category that's concrete but not small?
11:35:22 <ReinH> Philonous: all small categories are concretizable :)
11:35:45 <conal> jle`: i like Ertugrul's succinct & relatable quote on continuous-time FRP (https://twitter.com/ertesx/status/462100396211978240). i wonder if he got that angle from my old fran tutorial (http://conal.net/fran/tutorial.htm).
11:35:46 <ReinH> Philonous: http://en.wikipedia.org/wiki/Concrete_category
11:36:10 <ReinH> Philonous: so they are very similar concepts indeed
11:36:23 <conal> jle`: maybe not, as his emphasis on continuous time is clearer.
11:36:32 <jle`> conal: :)
11:36:36 <ReinH> Philonous: small categories are in a sense smaller than concrete categories
11:38:01 <teknokratsevilla> conal: your tutorial fran link is broken
11:38:44 <jle`> teknokratsevilla: hm, it's working for me :|
11:38:45 <conal> teknokratsevilla: odd. works for me.
11:41:32 <conal> jle`: wherever you go with your FRP-like explorations, i'm glad you're applying semantic precision. that discipline will let you evaluate different possibilities (including discrete vs continuous time) without deceiving yourself. if people applied semantic rigor to their discrete-time designs, they'd do better designs (and perhaps switch to continuous time). Otherwise, complexities and ambiguities go easily unnoticed.
11:42:18 <Philonous> ReinH, Thanks.
11:43:09 <teknokratsevilla> it works now
11:43:23 <teknokratsevilla> it had a final bracket or something
11:44:24 <jle`> conal: thanks for the endorsement; i'll continue exploring semantic precision.  this is all quite new to me actually --- caring about semantics, that is ... but it might just go to show how much haskell has affected the way i think about things
11:44:46 <conal> jle`: :)
11:45:48 <shapr> I want a bumper sticker that says "I'd rather be writing Haskell"
11:46:31 <mmachenry> shapr: http://www.cafepress.com/+bumper-stickers
11:47:44 <awestroke> heh http://www.cafepress.com/mf/80908155/monad-ale_sticker?productId=913297441
11:47:56 <teknokratsevilla> hmmm, Fran ,... aparently seems ol' good functional programming...
11:48:15 <fran> me?
11:48:21 <conal> just as using "FRP" to refer to discrete-time (and/or non-denotative) systems spreads confusion, i see using "purely functional" to refer to Haskell-with-IO as doing the same. that's why i've been promoting peter landin's recommended replacement of "functional" by "denotative". not to bash IO, but to clarify that it's qualitatively different from other types in Haskell and doesn't have the same benefits of semantic
11:48:22 <conal>  precision and consequent strong equational reasoning.
11:48:38 <geekosaur> heh
11:48:46 <conal> shapr: "I'd rather be writing *denotative* Haskell"
11:48:56 <geekosaur> fran: I think they're talking about http://conal.net/fran/
11:49:26 <fran> hmm, I see... :P
11:50:07 <teknokratsevilla> hmmm
11:50:27 <conal> reconnecting to teknokratsevilla's remark about meta-programming, i like to think of IO as exactly that: a metaprogramming DSEL for imperative programming. in the way the C preprocessor is, but more powerfully. (http://conal.net/blog/posts/the-c-language-is-purely-functional/)
11:50:36 <teknokratsevilla> I think haskell is always denotative and functional...
11:51:07 <teknokratsevilla> when is it not ?
11:52:33 <conal> teknokratsevilla: when it parts ways with what "denotative" means, including IO.
11:53:07 <conal> teknokratsevilla: see http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882 and follow the reference to "The Next 700 Programming Languages".
11:53:08 <Philonous> conal, That's a notion I appreciate much more since I learned (e)lisp, because macros are actually working on code rather than just some wonky text replacement system
11:53:58 <conal> Philonous: exactly! macros are another great canonical example of non-denotative programming.
11:54:35 <teknokratsevilla> I think that you mean denotative when you mean "straight effect" without any "hidden effect"
11:54:41 <conal> The foundational importance of Peter Landin's work---and this paper in particular---to our field is hard to overstate. I see *denotative* as the heart of what's powerful and elegant about what we used to mean by "purely functional programming" before non-denotative techniques like Haskell's IO type muddied the waters.
11:54:58 <conal> teknokratsevilla: no. i mean exactly what landin said.
11:55:56 <conal> teknokratsevilla: there's also a bit of explanation in my talk from yesterday (https://github.com/conal/talk-2014-bayhac-denotational-design)
11:57:09 <conal> teknokratsevilla: it's important to replace "functional" by a well-defined term, rather than another fuzzy one. there are already enough subjective debates on the internet about whose language is more "functional", without having a clear (let-along agreed-upon) definition as a basis.
11:59:55 <teknokratsevilla> one question, does it work ? I mean, can you just denote an IO operation and it would work ?
12:00:10 <teknokratsevilla> I mean, haskell is not like prolog
12:00:13 <teknokratsevilla> no backtracking
12:00:26 <teknokratsevilla> or you denote every single possibility ...
12:00:39 <teknokratsevilla> or you denote the "patterns"
12:01:02 <teknokratsevilla> I agree that C is functional in the inner workings
12:01:11 <jfischoff> denote in this case means that there is mapping of IO to mathematical precise idea
12:01:26 <bitemyapp> '
12:01:35 <vanila> teknokratsevilla, haskell can do backtracking, that's what the list monad gives you
12:01:46 <teknokratsevilla> but only with lists ?
12:02:09 <jfischoff> some people have suggested IO could denote a â€˜random variableâ€™ http://en.wikipedia.org/wiki/Random_variable
12:02:10 <bitemyapp> teknokratsevilla: not necessarily.
12:02:13 <companion_cube> there's a logic monad for backtracing
12:02:30 <bitemyapp> teknokratsevilla: there's a sharp distinction drawn in Haskell between an abstract interface and its manifestations.
12:02:31 <jfischoff> but this is all post ad-hoc attempts to understand what the IO monad is
12:02:56 <bitemyapp> teknokratsevilla: sometimes there are relatively easy to understand "collections oriented" manifestations of those abstract interfaces but you shouldn't confuse the pointing finger with the moon being pointed at.
12:03:46 <conal> teknokratsevilla: i'm confused about who you're agreeing with about C. i don't think it's me.
12:03:58 <bitemyapp> conal: great seeing you again at BayHac btw. you too jfischoff :)
12:04:13 <jfischoff> bitemyapp: likewise
12:05:14 <conal> bitemyapp: i have trouble correlating irc nicks and IRL. what's your irl handle?
12:05:38 <bitemyapp> conal: Chris Allen, I went to only one of the Haskell meetups before moving to Texas. I came over from Clojure.
12:06:03 <conal> bitemyapp: ah. thanks. :) glad you could come.
12:06:09 <bitemyapp> conal: we only ran into each other for a moment at BayHac, don't sweat it if you don't remember. I just write boring libraries and teach :)
12:06:39 <bitemyapp> conal: there's a discussion happening around delineating reactive marketing and FRP, your work is being used to define the latter :)
12:07:55 <conal> about IO lacking denotation and what to do about it, see http://conal.net/blog/posts/notions-of-purity-in-haskell and comments, including the "Toxic Avenger" remark.
12:08:02 <conal> jfischoff: ^^
12:08:06 <teknokratsevilla> conal, in your blog , you said Cpp was functinoal
12:08:16 <conal> teknokratsevilla: exactly. rather than C.
12:08:23 <teknokratsevilla> well....
12:08:35 <teknokratsevilla> hmmm
12:08:43 <klrr_> @where tapl
12:08:44 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:08:47 <klrr_> @where eopl
12:08:47 <lambdabot> I know nothing about eopl.
12:08:48 <conal> and I related CPP+C to Haskell+IO
12:08:52 <teknokratsevilla> and haskell metaprogramming haskell
12:08:54 <bitemyapp> @where pfpl
12:08:55 <lambdabot> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
12:08:57 <bitemyapp> good.
12:08:59 <teknokratsevilla> I mean, that'd be really samrt
12:09:04 <teknokratsevilla> smart
12:09:22 <teknokratsevilla> usually metaprogramming is the best way to ignore details, always works
12:09:26 <bitemyapp> conal: somebody said they really liked your "apology" of laziness, do you have a link for that?
12:09:31 <conal> bitemyapp: if you have pointers to these discussions, i'd appreciate you sending a few of them my way.
12:09:42 <bitemyapp> conal: well, caveat, it's twitter :)
12:09:46 <bitemyapp> but yes, link forthcoming.
12:09:53 <bitemyapp> hope you like 140 characters...
12:10:09 <bitemyapp> conal: https://twitter.com/jonsterling/status/468451043186343936
12:10:12 <conal> bitemyapp: hm. i referred to *Why Functional Programming Matters*: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
12:10:49 <conal> bitemyapp: and then noted that continuous time carries exactly the same benefit further.
12:11:15 <teknokratsevilla> well continuous time means no time at all
12:11:28 <teknokratsevilla> since time is just "the continous sequence"
12:11:31 <bvad> bitemyapp: As a sidenote to the twitter thing, I thorougly enjoy yours :)
12:11:34 <bitemyapp> oh, Chalmers. Naturally.
12:11:50 <bitemyapp> I should just start googling "Chalmers ${TOPIC}" first.
12:12:01 <bitemyapp> bvad: thank you! :)
12:12:12 <teknokratsevilla> you could "fake" continuous time by "recording" any change, a kind of aspect programming
12:12:18 <conal> bitemyapp: thanks. now following @jonsterling . i like what he's saying here! i cringe whenever i hear people muddle Rx in with FRP. :(
12:13:09 <teknokratsevilla> I think I need a couple of months to digest conal's blog
12:13:45 <conal> teknokratsevilla: enjoy! i'm usually happy to chat on #haskell about questions that arise.
12:13:59 <bitemyapp> conal: indeed :)
12:14:06 <teknokratsevilla> as you say in your blog, these things are not only theoretical
12:14:21 <bitemyapp> bvad: I'm surprised you can tolerate my twitter feed, I shed about as many people as I gain in any given week.
12:14:23 <teknokratsevilla> but imply a competitive technical advantage
12:14:57 <LordBrain> conal, humbly i ask, what is Rx?
12:14:58 <bvad> bitemyapp: Well.. That's why I enjoy it :) You're telling people what you think
12:14:58 <conal> teknokratsevilla: exactly! i like to build solid, efficient implementations with precise definitions. the denotative discipline lets me do so.
12:14:59 <Polarina> What is time?
12:15:03 <bvad> bitemyapp: Especially when they're wrong
12:15:37 <bitemyapp> bvad: I won't stop being stubborn, but I am trying to learn how to be more convincing.
12:15:46 <bitemyapp> but I won't lie in order to "flip" somebody.
12:16:11 <jle`> lie now ask later
12:16:13 <conal> teknokratsevilla: in contrast, what i see over & over is designs that prematurely commit to an operational bias, and are then locked into it. prevents both elegance *and* the sort of radical re-implementations that allow excellent performance.
12:16:15 <teknokratsevilla> wassap guys make an empire just by taking advantage of erlang message passing
12:16:40 <bvad> bitemyapp: Oh sure, it's not like you're just taking the piss on someone just for the sake of it.. I don't see why people feel hurt or insulted when they're told they're wrong, how else will they ever know?
12:17:17 <conal> for instance, whenever someone describes a purportedly FRP-like system or computer graphics system in terms of "graphs", i know they're stuck in a clumsy system that's hard to optimize.
12:17:19 <Phillemann> QuickCheck won't install on my machine. cabal says ghc-7.6.3 will likely be broken by the install. What do I do here?
12:17:43 <teknokratsevilla> conal, actually things are worse, different layers just gets mixed and code is awfully messy, I am talking about web frameworks...
12:17:44 <LordBrain> where's a link i can catch up to understand the convo in here?
12:17:54 <teknokratsevilla> software is out of control nowadays
12:18:29 <bitemyapp> bvad: well, then the tone projection/policing comes in. I haven't figured out yet how to reliably juke around that.
12:18:33 <bitemyapp> bvad: I'm sure it'll come with time.
12:18:34 <conal> teknokratsevilla: yep. and ironically, sometimes people defend these messy operationally-entangled designs as for efficiency.
12:18:36 <monochrom> Phillemann: read my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:18:44 <bvad> teknokratsevilla: I've been having that thought as of late as well, so many projects are a complete mess
12:18:58 <bitemyapp> conal: worse, they'll use this sub-optimal system and attribute its flaws to "FRP"
12:19:08 <bitemyapp> conal: you see this pattern over and over in other parts of CS too.
12:19:09 <conal> bitemyapp: ouch :/
12:19:13 <LordBrain> where's conal's blog?
12:19:17 <bitemyapp> conal: I see it all the time with Scala and "FP"
12:19:20 <conal> http::/conal.net
12:19:22 <bvad> bitemyapp: Just look at Tony, he seems to get it right.. It might be the Australian accent though!
12:19:24 <bitemyapp> http://conal.net
12:19:25 <conal> http://conal.net
12:19:42 <LordBrain> ty
12:19:54 <bitemyapp> bvad: hahaha, I was told I looked like Tony this weekend. Think we have some things in common besides too.
12:20:18 <teknokratsevilla> anyway, it's weird, I thought that graphics were the most optimized part of  computer programming
12:20:30 <jle`> conal: do you and prezi get along in real life
12:20:43 <teknokratsevilla> I mean , graphics is the biggest chunk of computing
12:20:54 <teknokratsevilla> videogames and  movie making
12:21:03 <teknokratsevilla> literally , billions of dollars
12:21:29 <companion_cube> network is the biggest chunk of computing ;)
12:21:29 <bvad> teknokratsevilla: The nextbigthing(tm) is bigdata, not graphics ;)
12:21:33 <teknokratsevilla> I know that using python was a great leap in some companies
12:21:38 <conal> jle`: i like evan, and I wrote to him this morning to start an exploration of how we can clear up the confusion around referring to Elm as "FRP".
12:21:59 <LordBrain> what is Elm?
12:22:15 <bitemyapp> LordBrain: frontend lang.
12:22:38 <LordBrain> frontend to what?
12:22:48 <fuzzyhorns> what background info in haskell do i need to know to understand arrows?
12:23:01 <bitemyapp> LordBrain: compiles to JS.
12:23:05 <jle`> fuzzyhorns: presumably, typeclasses
12:23:05 <LordBrain> fuzzyhorns, i don't think you need much at all really
12:23:18 <bitemyapp> LordBrain: http://elm-lang.org/
12:23:27 <conal> jle`: i was glad to hear that evan came up with the elm ideas independently from FRP, rather than that he misunderstood it. i don't know how he got the impression that he'd rediscovered FRP rather than coming up with something (quite) different.
12:23:34 <LordBrain> oh thanks bitemyapp
12:23:46 <bitemyapp> jle`: do you really need to understand typeclasses?
12:23:47 <fuzzyhorns> conal: how are they different? i am curious
12:23:51 <fuzzyhorns> my boyfriend has used elm a bit
12:24:07 <jle`> conal: i wonder if you guys have talked at all about this, because this has been an outstanding issue for a decent amount of time
12:24:14 <bvad> conal: If I was to learn 'real' FRP, where should I go look for material on the subject?
12:24:18 <bitemyapp> conal: a clear explanation here would help me avoid getting it wrong in future if I am asked about this again.
12:24:25 <klrr_> conal: is elm not FRP as classical FRP?
12:24:26 <FUZxxl> Is fuzziness inherent?
12:24:39 <jle`> bitemyapp: well, Arrow is a typeclass...so...if you don't know what typeclasses were, it'd be hard to know what the thing is in the first place
12:24:43 <FUZxxl> or just irreversible?
12:24:52 <LordBrain> are arrows really that useful? I mean couldn't we accomplish it all using lens?
12:25:01 <klrr_> meh, how do i write.. i mean: is elm not the same kind of FRP as classical FRP ?
12:25:04 <conal> A starting point for what FRP is/was: http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language/5878525#5878525
12:25:10 <bitemyapp> jle`: oh right. well, I think there's a continuum for understanding typeclasses. A lot of people can get away with a relatively superficial understanding.
12:25:17 <bvad> conal: Thank you :)
12:25:22 <fuzzyhorns> jle`: i know what a typeclass is, but probably not so deep
12:25:23 <jle`> LordBrain: Arrow and Lens are somewhat more or less different things for different purposes
12:25:28 <LordBrain> lenses weren't as much on the scene when arrows came out.. but now that we have lenses, i am not sure i see the point of arrows
12:25:37 <conal> klrr_: no. elm lacks the two fundamental FRP properties mentioned in the SO link above.
12:25:50 <jle`> bitemyapp: ah, right.  i was speaing on it the same way as you would need to know about typeclasses to understand what Monad is
12:25:54 <jle`> (capital M)
12:26:05 <bitemyapp> jle`: yeah I think that's a good equivalent.
12:26:34 <bitemyapp> jle`: case in point re: continuum, got blasted with some interesting stuff that could happen to typeclasses by kmett this weekend, didn't fully understand the implications.
12:26:44 <bitemyapp> possibly in 7.10 I guess.
12:26:51 <jle`> black magic
12:27:02 <fuzzyhorns> do you guys think the explanations here are on point: http://learnyouahaskell.com/types-and-typeclasses ?
12:27:12 <bitemyapp> fuzzyhorns: I don't like LYAH as a primary means for learning Haskell.
12:27:15 <chexxor> coworker got mad at me for using foldl and map. "Now you're the only one who can maintain it. :( Lets just keep the design pattern to oop from now on ok?"
12:27:22 <fuzzyhorns> bitemyapp: i dont think it is good for primary
12:27:22 <jle`> heh
12:27:33 <bitemyapp> fuzzyhorns: I've been teaching Haskell and I've had better luck with the guide I've been hammering out: https://gist.github.com/bitemyapp/8739525
12:27:41 <bitemyapp> chexxor: :\
12:27:41 <vanila> chexxor, inwhat language?
12:27:44 <fuzzyhorns> bitemyapp: neat thanks!
12:27:47 <chexxor> Javascript
12:28:09 <jle`> ...
12:28:21 <Philonous> bitemyapp, I cringed at "Installing Haskell"
12:28:28 <bitemyapp> jle`: believe it or not, some people actually don't like _. in JS.
12:28:32 <FUZxxl> bitemyapp: I liked Real World Haskell a lot.
12:28:36 <bitemyapp> Philonous: why? Some people don't have it installed.
12:28:42 <bitemyapp> FUZxxl: lYAH and RWH fall under "supplementary" in my guide.
12:29:19 <fuzzyhorns> Arrows, or Freyd-categories, are a generalization of Monads.
12:29:19 <fuzzyhorns> "They can do everything monads can do, and more. They are roughly comparable to monads with a static component." However "Arrows do have some problems"
12:29:21 <fuzzyhorns> true/false?
12:29:28 <jle`> er
12:29:38 <agamble> could someone explain to me why foldr is written like the first example rather than the second example in this link?
12:29:39 <agamble> http://lpaste.net/104317
12:29:41 <fuzzyhorns> straight from wiki :/ http://www.haskell.org/haskellwiki/Arrows
12:29:49 <quchen> I don't see how "installing Haskell" is cringeworthy. I can also buy "a car", although there are many manufacturers of cars.
12:30:11 <shachaf> agamble: Because of how GHC does inlining.
12:30:26 <jle`> fuzzyhorns: i don't think it's a useful way of thinking about Arrow
12:30:36 <LordBrain> jle`, here is what i am looking at... arrows are good for computations which act on a part, but may leave another part unchanged, arrows models this all with the pair (a,b), but lens and views let us do the same thing only we aren't limited to the pair.
12:30:57 <klrr_> conal: (not checked if its contiuous since i dont know what that means) but do you means something like this? https://github.com/the-real-blackh/hyperreactive they try to "standarize" FRP
12:31:06 <jle`> LordBrain: oh.  yeah, using first and second are actually sort of abuses of the Arrow typeclass
12:31:10 <LordBrain> so in that sense lens and views looks like a generalization of arrows, what's wrong with that picture?
12:31:12 <shachaf> quchen: GHC is not Haskell.
12:31:16 <jle`> that's not really the spirit of what Arrow is meant to be
12:31:40 <Philonous> quchen, That would be "a Haskell compiler". It's like buying "Engineering".
12:31:45 <shachaf> Whereas a quchen-car is a car.
12:31:52 <jle`> people who just used Arrow to modify parts of tuples are kinda sorta abusing it kinda maybe
12:31:52 <Philonous> quchen, But never mind. It's really not worth discussing.
12:32:08 <bitemyapp> Philonous: do you have a constructive edit to suggest?
12:32:13 <chexxor> bitemyapp, Good list there. I read the motivation for Lens in that Stanford course. First time I've began to understood them.
12:32:16 <bitemyapp> Philonous: it's written for a beginner audience.
12:32:17 <conal> klrr_: i hadn't heard of it. i don't know whether they're trying to follow those two FRP principles (denotative & continuous-time).
12:32:37 <klrr_> okey so by denotative you dont mean standarize
12:33:17 <shachaf> I think the best view for what a lens "is" is the isomorphism view (exists e. s ~~ (e,a)).
12:33:30 <conal> klrr_: wha? for "denotative", start with http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882 and follow the link.
12:34:15 <jle`> denotative can be said to contrast imperative; instead of saying "do this then this then that", you say "this is how things are", and the system figures out what to do in order to make that happen
12:34:32 <jle`> but the actual actions and commands are abstracted far away from the semantics and language/thought
12:34:40 <conal> klrr_: also, slide # 5 of my talk (https://github.com/conal/talk-2014-bayhac-denotational-design)
12:34:48 <LordBrain> i use the term declaritive for that, is that a synonym for denotative?
12:35:46 <conal> LordBrain: see the Landin paper (starting with the blog link above). Landin proposes "denotative" as a clear & substantive replacement for the ill-defined terms "functional" and "declarative".
12:35:54 <LordBrain> excuse the spelling, i type too fast for my mind to correct i guess
12:36:09 <LordBrain> oh i see
12:36:15 <jle`> ah, thanks
12:36:35 <companion_cube> why not 'equational' ?
12:36:40 <conal> If we say "functional" or "declarative" people will attach some fuzzy thinking to it and mistakenly think they know what we're talking about.
12:37:06 <conal> companion_cube: equational reasoning is a consequence of denotative, not a synonym for it.
12:37:06 <klrr_> is there any super-book that teach all fundementals so you dont need to get into all these rabbit holes of things to learn when you try understand stuff in haskell?
12:37:16 <Philonous> bitemyapp, No. There's nothing wrong with "Download Haskell". As a matter of fact, it's a great formulation. It just offends my personal taste.
12:37:20 <conal> klrr_: not that i know of. :/
12:37:45 <jle`> klrr_: just be prepared to always find out that you are always wrong :)
12:37:49 <jle`> that's what has helped me
12:37:59 <bitemyapp> Philonous: new people don't know or care what "GHC" is.
12:39:11 <bvad> bitemyapp: you could go with "Getting set up" or the like
12:39:13 <klrr_> hehe
12:39:23 <bvad> bitemyapp: "Before you start"
12:39:30 <bitemyapp> Sure.
12:39:51 <bvad> bitemyapp: Just be as vague as possible, then noone can correct you!
12:40:07 <teknokratsevilla> elm seems cool
12:40:32 <teknokratsevilla> it's along the trend of scratch and snapp
12:40:39 <teknokratsevilla> but functional instead of smalltalk-ish
12:40:42 <conal> I like this quote from David R MacIver: "Of course, once you start defining the term people will start arguing about the definitions. This is pretty tedious, I know. But as tedious as arguing about definitions is, it canâ€™t hold a candle to arguing without definitions." ( http://www.drmaciver.com/2009/05/a-problem-of-language/ )
12:41:21 <teknokratsevilla> yeah, if you go to IKEA shop ,everything has a name
12:41:52 <bitemyapp> bvad: dunzo: https://gist.github.com/bitemyapp/8739525
12:41:54 <teknokratsevilla> everything named can be handled
12:42:18 <teknokratsevilla> handled, grouped, transformed,... naming things is the basic of maths, I think
12:42:27 <klrr_> could the point of CPS be descibed in one sentence?
12:42:45 <bitemyapp> klrr_: the...point?
12:42:48 <bvad> bitemyapp: Great :) Now put it in an actual repo so you can get merge requests!
12:42:55 <bitemyapp> klrr_: you want control flow to depend on values.
12:43:11 <bitemyapp> bvad: I keep grumbling about incorporating into my site, which is on github.
12:43:28 <klrr_> okey, why is that useful as intermidiate language in compilers? o.o
12:43:29 <bitemyapp> I'll make a repo now.
12:44:08 <bitemyapp> klrr_: I can't speak to compiler writer needs, but it was a fairly standard way to handle yield/continue'ish stuff in languages like Scheme for a long time.
12:44:51 <geekosaur> cps can enable certain kinds of optimizations, as I understand it
12:45:07 <vanila> klrr, it's useful in compilers because it turns all function calls into tail calls - which can be implemented using jumps
12:45:19 <klrr_> omg
12:45:20 <klrr_> thanks
12:45:28 <klrr_> so that is the connection between CPS and TCO
12:45:35 <jle`> huh i never thought about it that way
12:45:41 <bitemyapp> bvad: dunzo: https://github.com/bitemyapp/learnhaskell
12:45:47 <klrr_> next thing is to understand why that is , time to read on
12:46:29 <bvad> bitemyapp: So, you just seem to be doing what I tell you.. How are your sandwich making skills?
12:46:30 <vanila> You still have to implement TCO by translating a source language tail call into a different CPS form than you would a normall procedure call
12:47:28 <bitemyapp> bvad: I make really good steak, fish, eggs, and home-style indian curries.
12:47:47 <bitemyapp> bvad: I can do a decent job with chicken and tex-mex as well. Not really a sammich person.
12:47:47 <bvad> bitemyapp: I can work with that
12:48:18 <user`> I have a code (f handle) `catch` (handler handle) , and it doesn't copmile
12:48:54 <klrr_> vanila: what do you mean?
12:49:26 <user`> what do I need to do?
12:49:40 <user`> in order to pass handler argument to handler?
12:49:53 <vanila> TCO is a different thing
12:50:55 <klrr_> but if i got a compiler that translate AST to CPS form then i can find TCO and translate that as GOTOs or loops to optimize, or do i miss the whole point?
12:51:09 <klrr_> TC;s*
12:51:14 <klrr_> tail calls*
12:51:21 <vanila> you should translate source language tail calls into CPS in a different way than you translate normal procedure calls
12:51:59 <klrr_> so you translate some parts of the AST to cps?
12:52:09 <klrr_> or is it just that its hard to transform into CPS form?
12:52:23 <vanila> everything is translated to CPS, but tail calls can be translated in a more optimized way than normal calls
12:52:29 <AlainODea> user`: catch is for exceptions. It should funcUsingH `catch` funcThatUsesExc
12:52:29 <user`> this don't work either: (line <- hGetLine handle) `catch` handler
12:53:18 <klrr_> okey
12:53:22 <user`> what us usingH?
12:53:30 <user`> what is usingH?
12:55:16 <ion> (line <- hGetLine handle) is not a valid expression.
12:55:34 <mcbears> user`: "line <- hGetLine handle" isn't a proper expression, it can only be an intermediate statement in a do block. You probably want "do { line <- hGetLine handle `catch` handler; {- code using line -} }"
12:56:20 <user`> it is in a  do block, I just didn't write the whole thing
12:56:57 <user`> there is a do a line before, and few more statements in the lines below
12:57:29 <Guest63908> hi all
12:57:33 <user`> is the brackets a problem?
12:57:58 <Guest63908> can seomeone tell me what is the probelm in the code here: http://lpaste.net/104319
12:58:11 <user`> because I put them because I didnt' know how it would be parsed with out brackets
12:58:49 <mcbears> user`: The brackets are probably not an issue, I just used them to type it on one line. If you want, you can post the code to lpaste (link in the topic) and tell us the specific error you're getting
12:59:15 <croyd> :t intersperse
12:59:16 <lambdabot> a -> [a] -> [a]
12:59:21 <croyd> :t ','
12:59:22 <lambdabot> Char
12:59:26 <benzrf> sup haskell peeps
12:59:31 <croyd> :t ["cc"]
12:59:31 <bitemyapp> > interperse ',' "1234"
12:59:32 <lambdabot> [[Char]]
12:59:32 <lambdabot>  Not in scope: â€˜interperseâ€™
12:59:32 <lambdabot>  Perhaps you meant one of these:
12:59:32 <lambdabot>    â€˜BS.intersperseâ€™ (imported from Data.ByteString),
12:59:32 <lambdabot>    â€˜BSL.intersperseâ€™ (imported from Data.ByteString.Lazy),
12:59:33 <lambdabot>    â€˜intersperseâ€™ (imported from Data.List)
12:59:35 <user`> ok
12:59:40 <bitemyapp> > intersperse ',' "1234"
12:59:41 <bitemyapp> sigh.
12:59:42 <lambdabot>  "1,2,3,4"
12:59:46 <bitemyapp> benzrf: hi!
12:59:52 <benzrf> hows it goin m8
12:59:55 <jle`> Guest63908: try giving a type signature to your intersperse
13:00:08 <Guest63908> jle`, ok
13:00:14 <bitemyapp> benzrf: upgrading a dependency that I was stupid about.
13:00:20 <benzrf> fuckin monomorphism restriction
13:00:23 * hackagebot puzzle-draw 0.1.0.3 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.1.0.3 (vollmert)
13:00:29 <jle`> Guest63908: and then see why you are acalling it with the wrong types
13:01:03 <bitemyapp> benzrf: I shut it off in my ghci :P
13:01:10 <benzrf> what an oddly specific package
13:01:15 <benzrf> bitemyapp: ha
13:01:31 <benzrf> bitemyapp: my laptop broke, now i am in a crouton install of lubuntu
13:01:34 <benzrf> on a chrombook
13:01:37 <benzrf> *chromebook
13:01:45 <benzrf> i have a freaking 11.5" screen
13:01:45 <benzrf> ;-
13:01:47 <benzrf> * ;-;
13:02:07 <LordBrain> conal, been reading some, When you said Rx, is that basically the same thing as "reactive" but not necessarily "functional reactive" ?
13:02:18 <user`> http://lpaste.net/3160831394230304768
13:02:41 <conal> LordBrain: which Rx remark?
13:03:48 <pavonia> user`: Remove the parentheses in line 9
13:03:51 <LordBrain> May 19 15:10:34 <conal> bitemyapp: thanks. now following @jonsterling . i like what he's saying here! i cringe whenever i hear people muddle Rx in with FRP. :(
13:04:12 <benzrf> ugh look at this miniscule screen http://i.imgur.com/ponMCck.png
13:04:21 <benzrf> what's Rx?
13:05:09 <jxv> benzrf, a reactive  framework (in java)?
13:05:27 <user`> pavonia: removed and now the error is: Couldn't match type `()' with `[Char]'
13:05:42 <pavonia> :t catch
13:05:43 <conal> LordBrain: thx. Rx is about "reactive" programming in some sense. Far from the fundamental FRP principles. Sadly, people have used "FRP" for Rx & ilk. Sadly, other people believed it.
13:05:43 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
13:06:05 <pavonia> user`: Yeah, handler has to return a String too
13:06:07 <LordBrain> i see
13:06:21 <LordBrain> so i should be a bit skeptical when i hear claims of FRP
13:06:36 <conal> LordBrain: and how!
13:06:48 <user`> pavonia: return?
13:07:08 <pavonia> Yes
13:07:36 <mcbears> handle should have type Exception e => (e -> IO String), since catch's first argument (hGetLine handle) has type IO String
13:07:38 <user`> this handler is from http://learnyouahaskell.com/input-and-output#exceptions
13:07:41 <mcbears> handler*
13:09:25 <benzrf> dont use exceptions
13:09:32 <benzrf> exceptions are dumb and stupid
13:09:38 <user`> t: putStrLn "Whoops, had some trouble!"
13:09:40 <benzrf> use Maybe or Either monads
13:09:52 <jle`> exceptions make sense in an IO context
13:09:53 <vandenoever> is there a way to do xml -> xml with haskell similar to xslt but with type checks?
13:09:54 <user`> I want to catch EOF
13:09:57 <benzrf> meh
13:09:59 <jle`> but not in pure code
13:09:59 <klrr_> do i understand this correctly, but converting a function into CPS is simply making it take an extra argument (the continuation) and to make it call that with the result of the function?
13:10:10 <benzrf> klrr_: something like that
13:10:36 <benzrf> klrr_: it's like callbacks but you dont have to explicitly lambda-ify the callback
13:10:42 <benzrf> at least, that's how it works in imperative langs
13:10:45 <mcbears> :t putStrLn "Whoops, had some trouble!"
13:10:47 <lambdabot> IO ()
13:10:48 <benzrf> in haskell, do-notation does that for you
13:10:50 <benzrf> :-)
13:11:05 <DogeHayashi> isn't it about time haskell got don't-notation?
13:11:10 <benzrf> DogeHayashi: :{
13:11:11 <klrr_> okey, well that seems rather trivial, in my head i imagene you needed to track the first call of the program and build a structure of all calls in order to make it work
13:11:18 <benzrf> klrr_: idk man
13:11:22 <benzrf> i dont know conts that well
13:11:28 <quchen> @hackage acme-dont -- DogeHayashi
13:11:28 <lambdabot> http://hackage.haskell.org/package/acme-dont -- DogeHayashi
13:11:34 <mcbears> user`: first of all, the "catch" that LYAH is using is now called catchIOError in System.IO.Error, not catch from Control.Exception
13:11:34 <benzrf> take what i say with a big heaping bowl of salt
13:11:42 <DogeHayashi> don't notation: declaratively expressing a program by specifying all the states it can't take
13:11:58 <joelteon> so that would introduce the <!- anti-bind operator
13:12:00 <jle`> DogeHayashi: http://hackage.haskell.org/package/acme-dont-1.1/docs/Acme-Dont.html
13:12:15 <DogeHayashi> heh ok
13:12:29 <LordBrain> conal, i looked at FRP in haskell many years ago, unfortunately, i do not remember much, but i do remember that the implementation did not perform as well as i would have liked, and that there were some demo games written using it. Ultimately I decided it wasn't worth it for that tho.  But as it has been some years, and so forth, i wonder if the state of the art has come far enough that something like 3d games written in FRP is practic
13:12:29 <LordBrain> al and competitive?
13:12:52 <benzrf> jle`: thats gr8
13:12:52 <quchen> klrr_: I always like to think as CPS as putting the return value in a lambda parameter instead of a simple value. For example, "fooCPS \k ->" is pretty much the same as "let k = foo".
13:13:32 <quchen> klrr_: Functions you've probably used that use CPS style include withAsync and bracket.
13:13:39 <klrr_> quchen: isnt it "let k = k foo"?
13:13:43 <benzrf> quchen: bracket?
13:13:47 <quchen> :t bracket
13:13:48 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:13:48 <benzrf> klrr_: thats recursive unko
13:13:51 <benzrf> *uknow
13:13:59 <klrr_> oh
13:14:03 <quchen> bracket (openFile "foo") hClose $ \handle -> â€¦
13:14:08 <klrr_> lol
13:14:15 <klrr_> sorry for my stupidness
13:14:15 <user`> how to return IO String?
13:14:25 <benzrf> @src bracket
13:14:26 <lambdabot> bracket before after thing = block $ do
13:14:26 <lambdabot>     a <- before
13:14:26 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
13:14:26 <lambdabot>     after a
13:14:26 <lambdabot>     return r
13:14:42 <jle`> wow it is weird to see haskell code use actually useful variable names
13:14:51 <quchen> "bracket init release action" runs init, passes the result to action, and runs release when action is finished or throws.
13:14:58 <benzrf> jle`: ha
13:15:16 <klrr_> so transforming code into CPS is not hard, what would this special CPS transformation for making TCO be?
13:15:50 <Guest63908> jle`, thank you, reasoning about the types found the problem
13:16:11 <jle`> Guest63908: you're welcome...that's actually how most haskell problems are solved :)
13:16:14 <jle`> fsvo most
13:16:18 <jle`> fsvo haskell
13:16:20 <jle`> fsvo solved
13:16:45 <DogeHayashi> also, there should totally be an alternative to format that introduces ALGOL-style syntax to haskell
13:16:51 <DogeHayashi> do â€¦ od
13:16:52 <jle`> ...actually i'm not sure if those qualifications were necessary
13:17:05 <DogeHayashi> if â€¦ then â€¦ else â€¦ fi
13:17:08 <jle`> it really is, although the way that it helps your problems will change from situation from situation
13:17:08 <user`> how to return IO String?
13:17:09 <benzrf> fsvo
13:17:14 <benzrf> user`: what do you mean
13:17:37 <user`> the handler want IO String
13:17:46 <DogeHayashi> module Acme.Algol where â€¦ erehw?
13:17:51 <jle`> you can use `return` to turn a String into an IO String
13:17:58 <LordBrain> actually, in general, i get the impression that there is still an unfortunate gap between theory and practice when it comes to leveraging purity to take advantage of parallelizing hardware...  i'm sometimes we aren't further along on these fronts.
13:18:13 <LordBrain> surprised
13:18:16 <Kaidelong> is the default behavior of modern cabal not "fetch the package, make a sandbox, install  the dependencies, register the result"?
13:18:39 <bitemyapp> LordBrain: there are a lot of very difficult details involved in efficient parallelization that go above and beyond running anything pure concurrently.
13:18:40 <jle`> i remember coming to haskell and being surprised that there was no magic compiler that could automatically make my code maximally parallel
13:18:50 <DogeHayashi> ^ this
13:18:52 <Kaidelong> are there any consequences if I do this myself?
13:19:06 <aalevy> the ghc bugtracker is convinced I'm a spam bot when I try to register. I promise, I'm not! How do I prove it wrong?
13:19:26 <quchen> Ask an admin?
13:19:29 <DogeHayashi> I remember going to a seminar at my uni about the state of parallelisation in haskell and leaving slightly disappointed >=P
13:19:35 <DogeHayashi> but this was, like, two years ago
13:19:48 <alevy> quchen, do you know where they are listed?
13:19:49 <user`> thanks jle`
13:19:50 <quchen> alevy: If you're trying to submit a new bug, maybe you'll find more GHC devs in #ghc.
13:20:02 <alevy> quchen: ah, you're right. Thanks!
13:20:03 <Kaidelong> when you consider that all you need are par and pseq, the state is actually pretty good compared to most PLs
13:20:05 <jle`> user`: it's important to remember that `return` is not a keyword like it is in other languages, and is just a normal function
13:20:12 <quchen> alevy: That channel is GHC development only, so it's much less busy than here, and some devs are only there.
13:20:19 <Kaidelong> (and then there is forkIO and Orc)
13:20:24 * hackagebot iterable 3.0 - API for hierarchical multilevel collections.  http://hackage.haskell.org/package/iterable-3.0 (MichalGajda)
13:20:26 * hackagebot hPDB 1.2.0 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0 (MichalGajda)
13:20:36 <user`> now it print what I retrned, but I didn't put any command to print, so .. why does it print?
13:20:52 <benzrf> user`: what are you talking about?
13:20:55 <benzrf> Kaidelong: i've seen orc
13:20:57 <jle`> user`: if you are in ghci, it automatically prints the returned value
13:20:58 <benzrf> it's interesting o=
13:21:18 <user`> I compiled and run it from command line
13:21:23 <user`> am I in ghci?
13:21:25 <jle`> hm. can you give us some source code?
13:21:31 <user`> yes
13:21:45 <jle`> ghci is the interactive prompt/repl, entered the ghci executable/command
13:24:01 <user`> http://lpaste.net/9074580260753768448
13:24:21 <LordBrain> i'd like a mature data parallel haskell, that actually uses the gpu  on vectors. Are we there yet?
13:24:40 <jle`> user`: you do have a print statement
13:24:43 <jle`> on line 9
13:24:51 <user`> oh
13:25:23 <jophish> LordBrain: Seen Accelerate?
13:25:24 <user`> but it print "A"
13:25:34 <user`> the print is for the line
13:25:43 <user`> did "A" get into the line?
13:25:43 <jle`> :t catchIOError
13:25:44 <lambdabot>     Not in scope: â€˜catchIOErrorâ€™
13:25:44 <lambdabot>     Perhaps you meant â€˜catchErrorâ€™ (imported from Control.Monad.Error)
13:26:12 <jle`> user`: if your IO action failed, then it will return whatever handler returned instead of the normal return
13:26:38 <jle`> so it looks like hGetLine handle error'd, so it falls back on what handler returns
13:26:55 <jle`> unless "test.txt" contains the string "A"
13:26:56 <davd> LordBrain: Accelerate is a good fit for flat data parallelism,  there are a few papers with benchmarks etc
13:27:13 <user`> text.txt don't have A
13:27:21 <user`> test.txt
13:27:35 <wondiws> bitInterval :: (Bits a) => a -> Int -> Int -> a
13:27:35 <wondiws> bitInterval word start size = (word `shiftR` start) .&. ((1 `shiftL` size) - 1)
13:27:48 <wondiws> I don't get the error I get with these two lines
13:27:50 <LordBrain> ok, i'll investigate it
13:28:23 <wondiws> Could not deduce (Num a) arising from use of '-'
13:28:29 <LordBrain> one thing is i have an AMD ATI video adapter, is that supported?
13:29:02 <jle`> user`: try leaving out the catchIOError...what happens?
13:29:24 <skypers> huhu
13:30:05 <skypers> is Parsecâ€™s State strict?
13:30:13 <skypers> I think so, because I pass it a cycled list
13:30:16 <skypers> and it takes forever to parse
13:30:22 <benzrf> skypers: literally forefver?
13:30:26 <skypers> yes
13:30:27 <user`> jle` it will get to end of file and stop
13:30:29 <benzrf> kk
13:30:31 <skypers> it doesnâ€™t end
13:30:36 <johnw__> I recall it saying so in the docs, skypers
13:30:51 <jle`> user`: does it print anything out?
13:30:56 <skypers> ar
13:30:58 <skypers> arf*
13:31:02 <skypers> itâ€™s going to be hell then
13:31:14 <johnw__> Wrap your state in the Identity monad
13:31:38 <skypers> yeah, indirection
13:31:39 <skypers> but hm
13:31:47 <skypers> isnâ€™t there a way to cycle a list another way?
13:31:50 <skypers> the list is finite
13:32:00 <skypers> I guess something like
13:32:10 <skypers> (x:xs) = xs ++ [x]
13:32:12 <skypers> will make it
13:32:15 <davd> LordBrain: there has been some work on an OpenCL backend, but it's not officially supported yet.
13:32:53 <user`> jle` test.exe: test.txt: hGetLine: end of file
13:32:59 <skypers> @let fcycle :: [a] -> [a]; fcycle [] = []; fcycle (x:xs) = xs ++ [x]
13:33:00 <davd> LordBrain: e.g. https://github.com/HIPERFIT/accelerate-opencl
13:33:03 <lambdabot>  Defined.
13:33:08 <skypers> > fcycle "hello"
13:33:10 <lambdabot>  "elloh"
13:33:15 <jle`> user`: well then...it errors, so that's why the handler is being called
13:33:16 <benzrf> :t fcycle
13:33:17 <lambdabot> [a] -> [a]
13:33:19 <benzrf> oh
13:33:23 <jle`> user`: what is in the file?
13:33:30 <skypers> benzrf: I just defined it
13:33:30 <user`> the world hello
13:33:35 <user`> it print it too before
13:33:47 <jle`> then what happened? :/
13:34:06 <skypers> I guess my fcycle is quite slow though
13:34:15 <skypers> since it will requires O(n) each time
13:34:21 <johnw__> I wonder how many times programmers have greeted the world through their programs...
13:34:23 <user`> it print hello, get to the end of file, and exit with exception end of file
13:34:52 <user`> I try to catch it, so it will continue to try to read from the end
13:34:56 <skypers> johnw__: a lot of times
13:36:45 <skypers> I guess cycle = concat . repeat ?
13:36:49 <skypers> @src cycle
13:36:49 <lambdabot> cycle [] = undefined
13:36:49 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:36:52 <skypers> oh
13:37:14 <skypers> > concat (repeat [])
13:37:18 <lambdabot>  mueval-core: Time limit exceeded
13:37:51 <quchen> That's [] ++ [] ++ [] ++ â€¦
13:37:53 <jle`> user`: hm
13:38:01 <jle`> does it even print "hello" at all, with the handler?
13:38:08 <jophish> Is there a way to hide imported instances?
13:38:32 <awestroke> jophish: don't import them?
13:38:45 <johnw__> cycle xs = xs ++ cycle xs, no?  That should be lazy enough, shouldn't it?
13:38:51 <jophish> awestroke: If they are mixed in with the rest of the library
13:38:54 <jophish> in the same module
13:38:54 <quchen> jophish: Nope. Known as the "Open world assumption".
13:39:02 <skypers> > take 3 $ concat (repeat [])
13:39:06 <lambdabot>  mueval-core: Time limit exceeded
13:39:08 <jophish> quchen: ah I see
13:39:19 <jophish> I think it's a little weird that Wire is an instance of Num
13:39:28 <skypers> I guess concat needs to evaluate the whole thing
13:40:35 <quchen> skypers: Well, concat (x:xs) = x ++ concat xs.
13:40:50 <quchen> When x is empty, that evaluates to "concat xs" again.
13:41:39 <quchen> concat (repeat []) = concat ([] : repeat []) = [] ++ concat (repeat []) = concat (repeat []) = infinite loop
13:41:57 <skypers> yeah :)
13:42:04 <skypers> ok well, now the parse ends
13:42:10 <skypers> it was that :)
13:43:56 <johnw__> skypers: It doesn't evaluate the whole thing, it goes into infinite recursion trying to evaluate the first element
13:44:22 <johnw__> Or rather, enough of the spine to determine a first element
13:44:51 <johnw__> Haha
13:45:15 <johnw__> My laptop has been shipped off for service, so I'm on my iPad
13:45:33 <arcke> does cabal verify signatures or use ssl, anything other than plain connections to hackage?
13:48:23 <jle`> quchen: how do you pronounce quchen ?
13:48:49 <bitemyapp> I heard at least 2 or 3 different pronunciations of quchen at #BayHac
13:48:52 <bitemyapp> I'd like to know the answer too.
13:49:11 <jle`> i would suspect it as...like...some sort of mixed pinyin/wade gyles pronunciation
13:49:17 <structuralist> if I have a record with two fields, and I use an accessor to get the first field, does that mean the second field gets evaluated or not?
13:49:30 <quchen> It's pronounced ËˆkuËÏ‡nÌ©
13:49:45 <jle`> so i am way off
13:49:50 <quchen> (I wasn't even at BayHac, why are people trying to pronounce me?)
13:50:04 <bitemyapp> quchen: referencing contributions or something. It wasn't anything negative :)
13:50:17 <bitemyapp> quchen: BayHac was one big love-fest.
13:50:17 <jle`> structuralist: i don't believe so
13:50:22 <jle`> > fst (3,undefined)
13:50:24 <lambdabot>  3
13:50:27 <ciaranm> quchen: we were plotting to have you killed
13:50:34 <bitemyapp> yes, that was the real reason.
13:50:37 <Redz> where can i find a simple md5sum function?
13:50:39 <jle`> unless you have strict fields of course, but it would have been valuated long before that
13:50:41 <quchen> Don't mention hackathons to me, thinking about ZuriHac makes me sad because I can't be there
13:50:45 <johnw__> structuralist: Only the record itself is evaluated in order to access its members
13:50:51 <bitemyapp> quchen: I'm sorry :(
13:51:05 <bitemyapp> how does an English speaker proniunce Ï‡nÌ© ?
13:51:14 <bitemyapp> pronounce*
13:51:24 <jle`> i would suspect like kine
13:51:47 <jle`> wait
13:51:49 <jle`> oh are you actually greek
13:51:54 <jle`> so those letters actually mean something to you
13:52:06 <quchen> This is a little offtopic. #haskell-blah?
13:52:19 <rhaps0dy> heh
13:55:51 <Athas> Is there a Haskell array library that provides easy row access?  That is, if I have a two-dimensional array, I want to be able to easily access the rows as one-dimensional arrays.  Data.Array does not support this elegantly.
13:56:07 <benzrf> something about matrices, maybe?
13:56:19 <Athas> Yes, I suppose I really only need matrices.
13:56:30 <hpc> hmatrix is the standard answer
13:57:22 <hmax_> Is platform dead?
13:57:27 <bitemyapp> hmax_: wut
13:57:35 <hmax_> bitemyapp, haskell-platform, i mean
13:57:38 <bitemyapp> hmax_: wut
13:57:42 <hmax_> wut wut
13:57:43 <rhaps0dy> platform is kill
13:57:43 <Cale> hmax_: Why do you ask?
13:57:45 <rhaps0dy> why would it be kill
13:57:54 <bitemyapp> kill platform kill
13:58:02 <Cale> hmax_: It's not dead
13:58:14 <hmax_> Cale, i'm looking at haskell.org/platform and latest release is 2013.2
13:58:17 <Clint> it's just sleeping
13:58:27 <Cale> It doesn't release very often
13:58:42 <hmax_> It was released twice a year at first :(
13:58:57 <hmax_> so, for now if i'm trying to develop on windows - i should go with standalone ghc and stuff?
13:59:37 <Cale> It was probably delayed by the very long delay in the GHC release
14:00:20 <ciaranm> there isn't a new GHC release until SPJ needs it
14:00:33 <Cale> Well, that's not true...
14:01:13 <Cale> There were just a bunch of blocking issues which came up
14:01:38 <Cale> hmax_: I don't know what people do on Windows, but I tend to ignore the platform on Linux.
14:01:48 <johnw__> I wonder which transformers will be in the next HP
14:01:48 <bitemyapp> hmax_: it depends on what libraries you need.
14:01:50 <Cale> Just get the GHC binary release, and then cabal-install
14:02:07 <bitemyapp> hmax_: I try to direct people away from platform unless they're on windows and want things that will be hard to compile. OpenGL maybe?
14:02:08 <hmax_> yeah, linux is pretty easy - gentoo's haskell overlay is working perfectly
14:02:12 <benzrf> >gentoo
14:02:25 <hmax_> bitemyapp, i'm ok with compiling stuff
14:02:43 <hmax_> and no, i don't think i'm going to need something that requires c compiler
14:02:54 <bitemyapp> hmax_: just get the GHC and Cabal binaries then.
14:03:08 <bitemyapp> I may even amend the windows section on my guide to drop the mention of platform for Windows.
14:03:16 <bitemyapp> and just wait to see if anything actually breaks for anybody.
14:03:22 <bitemyapp> ...yeah I'm just going to do that.
14:03:29 <johnw__> The HP is a pretty convenient way of deciding what the lowest bounds you have to support for the core libraries should be
14:03:43 <hmax_> kk, thx
14:04:02 <thoradam> Is there a way in ghci to lookup what constructors there are for a type?
14:04:21 <benzrf> thoradam: :i maybe
14:04:48 <bitemyapp> johnw__: end-users don't need to care about that.
14:05:54 <johnw__> bitemyapp: True enough
14:06:20 <hexagoxel> for debugging purposes, is there a way to tell cabal to compile every module as if it had a "import Debug.Trace" statement?
14:06:57 <thoradam> benzrf: I was thinking more like ":??? Maybe" would give "Nothing | Just a"
14:07:04 <johnw__> hexagoxel: No
14:07:07 <benzrf> thoradam: :i Maybe
14:07:36 <benzrf> :i will also tell you typeclass instances, the meaning of type synonyms, and several other things
14:08:02 <thoradam> Ah, of course, thanks ^_^
14:08:25 <benzrf> np
14:08:36 <hexagoxel> so suppose that i just freely add "import Debug.Trace" to every module. then, in general, i will get tons of "unused import" warnings. there is no way to disable those for specific modules, either, correct?
14:09:07 <Cale> hexagoxel: You only need to import it where you're using it
14:09:21 <johnw__> hexagoxel: Move the import into a common module and then tell GHC to disable that warning in that module
14:09:29 <hexagoxel> yeah but when debugging, i need it only until i find the problem
14:10:28 * hackagebot apiary 0.6.0.1 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.6.0.1 (HirotomoMoriwaki)
14:10:32 <gdoteof> this isn't my paste but i think i have hte same problem: http://lpaste.net/report/102156
14:10:32 <hexagoxel> johnw__: make sense, thanks
14:10:51 <napping> hexagoxel: Isn't adjusting flags to suppress warnings in specific modules just as much work as adjusting whether those modules import Debug.Trace?
14:10:53 <gdoteof> cannot get yesod-bin to install.. tried it in a sandbox and it's getting stuck on unix-compat
14:11:18 <gdoteof> invalid bytesequence to hgetcontents
14:11:42 <johnw__> Can you paste the whole error?
14:12:28 <gdoteof> http://lpaste.net/104325
14:12:29 <hexagoxel> napping: not if it was possible to disable any unused "import Debug.Trace" globally
14:13:40 <gdoteof> johnw__: fwiw, this is inside of a docker image.  14.04 ubuntu
14:14:36 <johnw__> gdoteof: I haven't seen that one before. Is the file system read only or anything?
14:15:15 <johnw__> Also, look at the generated file yourself to see if it looks weird
14:15:24 <gdoteof> johnw__: i don't think so.. hm.  any guesses where it might be trying to write?
14:15:42 <arthurz> Hi all, does Haskell have an equivalent to the .net FileWatcher (used to raise an event upon file arrival/change)?
14:16:30 <gdoteof> johnw__: there is nothing written in the /tmp/pkgConf-unix-compat-0.4.122805.1  `ls /tmp` is empty but i can write to it
14:17:30 <johnw__> I think you can ask cabal to leave build products behind
14:17:58 <johnw__> arthurz: inotify, fsnotify
14:18:15 <arthurz> thx johnw__
14:21:45 <acowley> bitemyapp: I think network is another package that can be slightly involved to build on Windows
14:22:32 <carter> autoderivetypable is 7.8 only right?
14:22:44 <bitemyapp> acowley: fuck it, we're doing it live.
14:22:54 <bitemyapp> acowley: dropped all mention of platform, I'll wait for somebody on windows to say something broke.
14:23:22 <acowley> bitemyapp: That's probably a good course to take
14:23:47 <acowley> bitemyapp: We have a lot of theorizing about how things work on Windows, but not a lot of data :/
14:24:10 <carter> whats going live?
14:24:19 <acowley> carter: everything
14:24:27 <merijn> carter: DeriveTypeable was already pre-7.8
14:24:35 <carter> merijn: yay, so in 7.6 ? woot
14:24:41 <merijn> carter: In 7.8 it just became the only way, i.e. no more handwritten instances
14:24:53 <merijn> carter: I think at least since 7.4, but probably even older?
14:24:58 <carter> cool
14:25:00 <bitemyapp> acowley: part of the problem is that the windows users will get as far as reporting something broke but nobody from that platform seems to be capable of contributing to the tools they use.
14:25:03 <carter> happily i only care about 7.6 an ewer
14:25:24 <bitemyapp> 7.6.3++ here for my library.
14:25:38 <Kinnison> Hi all, I am investigating running multiple subprocesses simultaneously from a haskell parent and wondered if anyone had a recommendation for something to look to for examples?  Each subprocess may produce output which needs gathering up, and I need to coordinate from some kind of central "thread" in my imperative thinking model :-)
14:26:13 <hexagoxel> johnw__: but that requires a common module that i always use in some way. my project does not have such a module. so i am back to square one, as i get unused warnings for the new module that re-exports Debug.Trace..
14:26:17 <napping> b
14:26:57 <acowley> bitemyapp: Yeah, part of the issue is that things get fragmented between MinGW, and whatever Unixy environments people manage to get on their WIndows installs. It means that what little data there is isn't entirely consistent.
14:26:59 <merijn> Kinnison: Do you mean actual processes or just "multiple threads within the same program"?
14:27:16 <Kinnison> I mean actual processes
14:27:30 * Kinnison has found System.Process.createProcess and friends
14:27:32 <bitemyapp> acowley: again, not enough work being put into the ecosystem, just outside our wheelhouse.
14:27:36 <merijn> Kinnison: A central thread communicating with worker threads through channels/mvar/stm makes perfect sense as a design, IMO
14:27:43 <Kinnison> But I'm more after hints as to how to structure the haskell parent
14:27:52 <hexagoxel> there is one other solution: modifying Prelude... but that feels rather ugly
14:27:56 <Kinnison> channels? hmm
14:27:58 <merijn> Kinnison: You could maybe just spawn one thread per subprocess and have those threads communicate with a "master" thread?
14:28:01 <acowley> bitemyapp: It's not entirely different to how Mac users can get split across fink, macports, and brew. It's just that there are enough vocal brew users that a relatively clear signal emerges.
14:28:07 <Kinnison> merijn: I'm fine with that as a core ide
14:28:19 <Kinnison> merijn: providing that those threads and fork()ing don't get confused :-)
14:28:27 <merijn> Kinnison: It kinda depends what you want the master to do
14:28:32 <acowley> bitemyapp: I do think it's regrettable. I'm envious of how good a job the Racket team does with packaging.
14:28:46 <Kinnison> merijn: the master is deciding when to launch off new subprocesses, and reporting to the terminal based on the results of the subprocesses
14:28:51 <Kinnison> merijn: think something "like" make
14:28:51 <merijn> Kinnison: No, spawning a subprocess from any thread should "just work"
14:29:03 <Kinnison> (note, I am *NOT* writing a build system :-)
14:29:38 <merijn> Kinnison: Right, so I would have one thread per subprocess and then have a single Chan for results and have the subprocess threads write to that Chan and a main thread reading from the Chan and writing to the terminal
14:30:03 <bitemyapp> acowley: their stuff is better isolated by dint of not relying on the compiler infra like gcc.
14:30:03 <Kinnison> Okay, in this instance, what package does 'Chan' come from?
14:30:14 <Kinnison> (Control.Concurrent.Chan ?)
14:30:26 <merijn> Kinnison: Yeah, should be in base, I think
14:30:30 * hackagebot prefix-units 0.1.0.1 - A basic library for SI/binary prefix units  http://hackage.haskell.org/package/prefix-units-0.1.0.1 (IustinPop)
14:30:46 <carter> bitemyapp: acowley  yeah, racket is the gold standard of ease of install
14:30:47 <merijn> Kinnison: In general, it can't hurt to give everything in Control.Concurrent a quick look :)
14:30:48 <Kinnison> merijn: looks good
14:30:52 <Kinnison> yay
14:30:57 <Kinnison> one more problem on this plan resolved
14:30:59 <Kinnison> thank you
14:31:03 <acowley> bitemyapp: Yeah, but they've earned it! They still use someone else's JIT (lightning)
14:31:10 * Kinnison now sets about seeing if there's something like python-ttystatus for haskell
14:31:13 <merijn> Kinnison: Chan is basically a safe multiple reader, multiple writer safe communication channels
14:31:22 <carter> @google lightning jit
14:31:23 <lambdabot> http://www.gnu.org/s/lightning/
14:31:23 <lambdabot> Title: GNU lightning - GNU Project - Free Software Foundation (FSF)
14:31:29 <carter> i thought they were using their own jit...
14:32:20 <Kinnison> merijn: Chans look perfect, thank you
14:32:59 <Kinnison> merijn: don't suppose you have any ttystatus like things up your sleeve?  (http://code.liw.fi/ttystatus/docs/)
14:33:10 <carter> oh you're right https://github.com/plt/racket/blob/6af65ee19aaaddd184d2bd15a4254157746e3a0a/racket/src/racket/src/lightning/arm/core-common.h#L15
14:33:10 <Tordek> I know it's'probably an implementation defined thing, but... if I have something like (Just 5) >>= (lift foo) >>= (lift bar) >>= (lift baz) is the compiler going to merge that into (Just 5) >>= lift (foo . bar . baz) [or, heck, Just (foo . bar . baz $ 5)], or is that kind of thing just mentioned by hlint and handfixed?
14:34:17 <quchen> Tordek: What's "lift"? Anyway, there is no general rewrite rule for class-based laws (like the Monad laws).
14:34:31 <merijn> Kinnison: Actually, I did start a library for dealing with pty's for use in another program that I never finished :p
14:34:40 <merijn> Kinnison: http://hackage.haskell.org/package/posix-pty-0.1.0/docs/System-Posix-Pty.html
14:35:03 <acowley> Honestly, Matthew Flatt is an incredible programmer
14:35:42 <acowley> Every big compiler project could use a clone of him
14:36:51 <carter> i've heard stories
14:36:54 <carter> of his epicness
14:37:02 <carter> haven't personally seen it, but def heard of it
14:37:07 <carter> what examples do you have in mind?
14:37:16 <acowley> one sec
14:39:40 <acowley> So you've got the scope of the Racket compiler itself and it's macro expander, the fact that it transitioned to the JIT almost invisibly, supports unboxed primops, that he's packaged a fork of wx that just works on Windows, Mac, and Linux... and *then* if you use Racket and encounter a bug, send a message to the mailing list and he fixes it in what always seems like a matter of hours
14:39:54 <carter> yup
14:40:03 <acowley> I don't know how he combines such a sprawling engineering effort with his level of responsiveness
14:40:21 <carter> speaking of which, why can't we reuse their gui work to have a decent gui toolkit that just worksâ„¢ for haskell?
14:40:45 <acowley> A part of the reason is that we can't agree on how to write a GUI
14:41:13 <acowley> That shouldn't stop us from having lower level bindings, but it doesn't help
14:41:49 <acowley> Also, I think Qt and QML are a good way to go today. You can do a lot of GUI things with just QML if you don't turn up your nose at the first sight of Javascript.
14:42:18 <acowley> I'm not sure how nicely the Haskell interop works, though
14:43:33 <shachaf> structuralist: What was your non-IRC name? I think you mentioned your IRC name at BayHac.
14:43:52 <lispy> acowley: In my experience, GUI stuff is unpleasant in Haskell for a lot of little reasons. None of which are fundamental or show stopping.
14:44:23 <carter> what are the pain points lispy ?
14:44:24 <lispy> acowley: just stupid stuff like, I don't like how gtk looks on windows, build it is annoying, etc
14:49:52 <lispy> carter: I'm probably forgetting some stuff, but the last time I looked into it there are all the chicken 'n egg things (lots of rough edges because no one is using it, no one is using it because of rough edges). Build issues (especially on windows). APIs tend to be 'gross' to work with from Haskell. Look 'n Feel stuff (gtk on windows). Interop stuff (gtk on osx requires an X server, last I checked).
14:50:09 <carter> yeah
14:50:19 <lispy> carter: All of those things stop me from actually trying it. If I tried it I'm sure I'd have a different set of complaints.
14:50:33 <lispy> wx is probably the way to go at the moment
14:50:47 <Kinnison> merijn: Worth me looking, or is it very "new" ?
14:51:05 <Kinnison> merijn: Okay, not what I was looking for
14:51:06 <carter> lispy: the tricky bit seems to be "overly portable engineering"
14:51:07 <merijn> Kinnison: It doesn't do very much
14:51:14 <Kinnison> merijn: I don't need ptys for the subprocesses
14:51:15 <carter> like.... maybe the right choice is having native per OS
14:51:16 <carter> idk
14:51:25 <merijn> Kinnison: Right, then it's not worth it
14:51:25 <Kinnison> merijn: I need a neat way to report the progress of the operation to the controlling tty and thus the user :-)
14:52:01 <lispy> I think having reasonable native suppor per OS is a great place to start. I bet if we had that then we could follow the design of wx from pure Haskell and get something decent if people wanted cross-platform.
14:52:27 <lispy> carter: or maybe see what happens with rust and use that?
14:52:37 <Kinnison> merijn: something like a progress bar crossed with a terminal-based log, which python-ttystatus gives me in python
14:53:11 <Kinnison> merijn: terminal-progress-bar is partway there
14:53:17 <carter> merijn: acowley  cabal-1.20: The package numerical-core-0.1.0.0 requires the following language
14:53:17 <carter> extensions which are not supported by ghc-7.6.3: AutoDeriveTypeable
14:53:31 <carter> lispy: i dont understand the rust remark
14:53:32 <carter> explain please?
14:53:56 <Kinnison> merijn: I'd like something which handles the nitty-gritty of things like SIGWNCH for me :-)
14:54:25 <carter> booo,  no autoderivepowers
14:55:20 <lispy> carter: Isn't the rust community making a cross platform GUI lib as one of their first real projects?
14:55:31 <carter> lispy: .... really?
14:55:36 <merijn> carter: Oh, I'm not familiar with AutoDeriveTypeable, that automatically makes instances for every datatype?
14:55:38 <carter> i mean, browser sure
14:55:41 <carter> yup
14:55:55 <carter> merijn: so either I swallow LOTS of CPP
14:55:57 <carter> or drop 7.6
14:56:06 <merijn> carter: 7.6 does support just normal "DeriveTypeable" where you make a "deriving" annotation
14:56:18 <merijn> Or did 7.8 drop the DeriveTypeable extension?
14:56:24 <carter> no, it has that too
14:56:25 <merijn> That seems silly
14:56:31 <carter> it has both
14:56:42 <merijn> carter: Then you could just as easily add "deriving (Typeable)" everywhere, no?
14:56:48 <carter> i could
14:56:50 <carter> but do i want to
14:56:56 <merijn> Why not?
14:57:02 <carter> or maybe I should just drop 7.6 support period
14:57:04 <merijn> Beats ugly CPP :p
14:57:11 <Sculptor> cpp is ugly?
14:57:34 <merijn> Sculptor: As someone who spend the better part of last week studying the C standard on the CPP spec: Yes. :p
14:57:37 <napping> Does
14:57:45 <napping> Does that just derive Typeable, or also Data?
14:57:55 <Sculptor> thanks for sharing
14:57:56 <carter> deriving (Data)
14:59:50 <carter> any standard things aside from Read missing when i do
14:59:51 <carter>     deriving (Show,Eq,Typeable,Data)
15:00:01 <napping> maybe Ord
15:00:06 <merijn> Enum, Ord, Bounded? :p
15:00:10 <merijn> Depends on the datatype
15:00:43 <napping> Do you want the H98 list? Eq, Ord, Enum, Ix, Bounded, Read, and Show.
15:01:04 <carter> yeah, most of my stuff cant have those
15:01:32 <carter> heck, a HUGE part of my work on numerical-core could be viewed as being an enriched Enum/Ord/Ix for array formats
15:01:36 <napping> GHC adds Typeable Data Generic Generic1 Functor Foldable Traversable
15:01:55 <carter> Generic... does that have a magic derivver?
15:02:10 <napping> DeriveGeneric?
15:02:14 <carter> oh yeah :)
15:03:26 <benzrf> sup yo
15:10:33 * hackagebot hcwiid 0.0.4 - Library to interface with the wiimote  http://hackage.haskell.org/package/hcwiid-0.0.4 (IvanPerez)
15:23:07 <kakos> Could not deduce (t ~ t1)
15:23:17 <kakos> Any hints on fixing these kinds of errors?
15:23:23 <benzrf> kakos: context?
15:24:01 <kakos> benzrf: https://gist.github.com/lambdaknight/107d31559ea1a92d3fe1
15:24:09 <kakos> Working with reactive-banana
15:24:41 <coppro> kakos: basically it's saying it has two types that it cannot prove are the same
15:25:53 <luite> kakos: are you using the name t1 in the actual sig for interpretEvent?
15:26:41 <kakos> luite: Nope. Using 't'
15:26:57 <luite> kakos: k, it's because that 't' is actually a different t than the outer one
15:27:13 <luite> kakos: use ScopedTypeVariables and forall t. on the outer sig to make it the same
15:27:14 <coppro> kakos: can you paste the relevant code?
15:27:28 <luite> otherwise it introduces a fresh t, even if it has the same name
15:27:39 <coppro> oh, luite got it :)
15:28:05 <kakos> luite: That did it
15:28:13 <kakos> luite: Thanks!
15:28:16 <luite> :)
15:28:29 <kakos> <3 #haskell
15:29:08 <kakos> Best IRC channel ever. :)
15:35:50 <MitchellSalad> so, you guys know the "haskell is useless" video...
15:36:11 <MitchellSalad> some guy who goes to my university is arguing that even the "creator of haskell thinks it's useless"
15:36:21 <MitchellSalad> and doesnt agree with me telling him it's more or less tongue in cheek
15:36:27 <benzrf> kakos: u r correct
15:36:29 <MitchellSalad> just wanted everyone to know that he exists
15:36:53 <hiptobecubic> That's fine. Hopefully he stays away and doesn't ruin anything here.
15:36:55 <benzrf> MitchellSalad: tell this person that a random internet stranger said that he is a butt
16:09:02 <Eduard_Munteanu> Is there a way to split the output of a conduit into two streams?
16:09:49 <Eduard_Munteanu> Basically I want something that looks like ---<===
16:10:03 <Eduard_Munteanu> (from left to right)
16:10:08 <ion> Thatâ€™s a great operator name.
16:11:47 <Eduard_Munteanu> I sometimes wonder if there's a Curry-Howard-Lambek-Kmett correspondence between types and lens operator names. :P
16:12:42 <LordBrain> like a tee operator
16:13:13 <Eduard_Munteanu> Hm, that would do. Or really, a conduit with two outputs.
16:13:43 <LordBrain> the thing about conduits is they have pull semantics, not push. So i agree it would be nice, but you have to adapt tee to that kind of semantics
16:14:30 <quchen> Eduard_Munteanu: I've catalogued part of that correspondence here, https://github.com/quchen/articles/blob/master/lens-infix-operators.md
16:14:33 <LordBrain> i guess it would be nice if some conduits were push
16:15:16 <LordBrain> so you pull in from one side, but in order to satisfy your request, it triggors some pushes down some other pipes
16:15:23 <Eduard_Munteanu> I figure something like "ConduitM i m (Either o o') a" would fit.
16:15:45 * hackagebot combobuffer 0.2 - Various buffer implementations  http://hackage.haskell.org/package/combobuffer-0.2 (JohnLato)
16:16:01 <grache28> I got a little bit of a grasp on map with function that normally take 1 argument - but i;m a little lost when trying to apply map to a function that takes an Int and [Int]
16:16:21 <Eduard_Munteanu> Though conduits like that would have to handle both cases.
16:16:21 <dwcook> grache28: what are you trying to do? What have you tried?
16:16:34 <LordBrain> right
16:16:55 <LordBrain> you think it is too complicated?
16:17:20 <quchen> map (+) [1,2,3] = [(+) 1, (+) 2, (+) 3] -- grache28
16:17:25 <quchen> Does that make sense?
16:17:30 <Eduard_Munteanu> LordBrain: well, the original motivation was to split the input earlier and not care about it later.
16:18:08 <grache28> dwcook: well i have a function: foo :: Int -> [Int] -> [(Int,Int)] - so I wanted to use map to pass the function a list instead of just 1 Int at a time
16:18:21 * Eduard_Munteanu wonders if Conduits are Arrows.
16:18:54 <dwcook> grache28: Are you sure map is what you want? It seems like you should just apply foo to your list, from your description.
16:18:55 <grache28> quchen: yea, maybe map isn't the right option'
16:19:33 <Eduard_Munteanu> Hm, ConduitM doesn't seem to.
16:20:22 <dwcook> grache28: one way to put it: If you have foo, and you have something :: [Int], and you have something else :: Int, the natural thing to do would be to just apply foo to those things.
16:22:01 <LordBrain> well, whatever the original motivation, it would be  handy if conduits could do that
16:22:24 <LordBrain> maybe they wouldnt be called conduits any more, i am okay with that
16:23:21 <LordBrain> maybe the underlying pipe type can do it, i am not sure
16:26:07 <grache28> dwcook: kinda -- I just wanna apply foo to each element in the list
16:28:35 <dwcook> grache28: so, you want to use each element in some [Int] as the first parameter? Or is it that you have a [[Int]]?
16:29:00 <dwcook> grache28: showing a paste (e.g., lpaste) might be helpful at this point.
16:29:44 <grache28> dwcook: not ignoring you - will paste in a few min, brb
16:30:32 <dwcook> I didn't think you were ignoring me. Responses over IRC can take time.
16:32:49 <grache28> dwcook: pastebin ok?
16:33:11 <grache28> nvm - using lpaste.net
16:33:14 <dwcook> I don't see why not.
16:34:37 <shachaf> I'd encourage you to use anything other than pastebin.com, which is a rather unpleasant website. hpaste.org/lpaste.net works.
16:35:07 <grache28> dwcook: I *think* I got it working - but it's not the final result I want, just  step closer :)
16:35:09 <grache28> http://lpaste.net/104329
16:35:46 * hackagebot iteratee-compress 0.3.3.1 - Enumeratees for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.3.3.1 (JohnLato)
16:35:48 * hackagebot iter-stats 0.1.0.3 - iteratees for statistical processing  http://hackage.haskell.org/package/iter-stats-0.1.0.3 (JohnLato)
16:36:52 <dwcook> grache28: that's missing some things â€“ tails I'm assuming is from Data.List, though including the import declaration would help, but I don't know what dosQueSumen is at all.
16:37:34 <dwcook> grache28: if you can, it's also helpful to provide what you think the types are, in the form of type signatures.
16:38:06 <dwcook> Of the top-level bindings, that is. It's good practice in general, at least.
16:38:52 <dwcook> However I notice that foo cannot have the type you mentioned if you're using Data.List.tails.
16:38:55 <dwcook> @type tails
16:38:57 <lambdabot> [a] -> [[a]]
16:39:17 <dwcook> tails take a list, not an Int as you mentioned the first parameter would be.
16:40:47 * hackagebot iteratee 0.8.9.6 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.6 (JohnLato)
16:41:01 <grache28> dwcook: http://lpaste.net/104329
16:41:37 <grache28> dwcook: with corrections - twoThatAddUp takes an Int (as you can now see), my mistake
16:41:55 <dwcook> Okay good, now we have something runnable. Now what was it you were having trouble doing?
16:43:08 <grache28> dwcook: that - I was just trying to get there - I just showed you sense your words gave me the inspiration to find the solution.
16:43:44 <grache28> The problem isn't finished by I'm one step closer - I'll continue working on the problem and almost definitely be back with questions later :)
16:43:52 <dwcook> Okay. Glad I helped then.
16:44:00 <grache28> thanks
17:00:34 <orbital> there isn't a central repository of cool but not always apparent Haskell tricks, is there? For example, this weekend I learned (thanks to Bob Ippolito) about enumerating inhabitants of Ord types with [..] and function application with $ (zipWith ($) [(1+),(2*)] [4,5]). Simple yet fascinating.
17:00:57 <orbital> wish i could have one of those at breakfast every day
17:03:34 <quchen> ".." uses Enum, not Ord.
17:04:48 <shachaf> .. doesn't enumerate all inhabitants, either.
17:06:37 <orbital> ah
17:06:44 <orbital> Ord was my assumption
17:06:50 <quchen> orbital: These things may seem fancy at first, but they're quite basic, and you'll get used to them quite quickly.
17:07:03 <quchen> In other words, they'll stop being "tricks" soon.
17:07:55 <orbital> quchen: sure. On the other hand, I still enjoy visiting http://www.commandlinefu.com/commands/browse, despite having years of bash experience.
17:08:07 <orbital> it's like candy for the brain
17:08:31 <enthropy> @quote evar
17:08:31 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
17:08:54 <quchen> orbital: This is a nice ressource in general, but may be a tad too advanced for an absolute beginner: http://dev.stephendiehl.com/hask/
17:08:57 <orbital> the term "trick" was chosen poorly, i admit
17:08:59 <quchen> It's useful to bookmark it somewhere
17:09:06 <orbital> quchen: thanks!
17:09:25 <quchen> And then there are tons and tons of interesting but uncatalogued articles spread all over the internet, of course.
17:09:31 <orbital> quchen: ah, have that one bookmarked already :)
17:09:36 <quchen> And IRC osmosis.
17:09:45 <quchen> Spend time here, learn things you didn't plan on learning.
17:09:57 <orbital> just like to be dazzled every once in a while
17:10:27 <orbital> *nod*
17:10:38 <quchen> ?quote fmap.fix.return
17:10:38 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
17:10:51 <benzrf> :t fmap.fix.return
17:10:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:10:57 <benzrf> wuh
17:10:57 <shachaf> Don't trust #haskell too much. It's full of misinformation.
17:11:03 <benzrf> :t fmap.fix.fmap
17:11:04 <lambdabot> Functor f => (b -> b) -> f a -> f b
17:11:07 <benzrf> ok...
17:11:13 <benzrf> :t fmap.fix
17:11:14 <lambdabot> Functor f => ((a -> b) -> a -> b) -> f a -> f b
17:11:17 <benzrf> @_@
17:11:23 <quchen> Try it as the quote quotes it.
17:11:35 <benzrf> huh?
17:11:37 <dwcook> @type fmap fix return
17:11:38 <lambdabot> b -> b
17:11:41 <benzrf> oic
17:11:46 <benzrf> yo what the fuck
17:11:55 <benzrf> > fmap fix return $ 3
17:11:56 <lambdabot>  3
17:12:00 <benzrf> :(
17:12:12 <benzrf> :t fix
17:12:13 <lambdabot> (a -> a) -> a
17:12:47 <benzrf> > fix (return 3)
17:12:49 <lambdabot>  3
17:12:53 <benzrf> o:
17:13:04 <benzrf> > fix (return 3 :: IO Int)
17:13:06 <lambdabot>  can't find file: L.hs
17:13:09 <benzrf> wtf
17:13:10 <benzrf> > fix (return 3 :: IO Int)
17:13:12 <lambdabot>  Couldn't match expected type â€˜a -> aâ€™
17:13:12 <lambdabot>              with actual type â€˜GHC.Types.IO GHC.Types.Intâ€™
17:13:13 <enthropy> > (fix . const) 3
17:13:15 <lambdabot>  3
17:13:18 <benzrf> o_O
17:13:19 <quchen> How about a private session
17:13:25 <benzrf> gaaah my headdd
17:13:52 <quchen> Try figuring out what the involved Functors/Monads are.
17:14:39 <dwcook> Just solve the type puzzle
17:14:39 <benzrf> :|
17:14:41 <benzrf> @src fix
17:14:42 <lambdabot> fix f = let x = f x in x
17:14:44 <enthropy> you can get ghci to tell you what those types are
17:14:52 <benzrf> ok...
17:14:53 <benzrf> :t fix
17:14:54 <lambdabot> (a -> a) -> a
17:14:57 <quchen> :t (fmap, fix, return)
17:14:58 <lambdabot> (Functor f, Monad m) => ((a -> b) -> f a -> f b, (a1 -> a1) -> a1, a2 -> m a2)
17:15:09 <benzrf> well fmap is just composing here
17:15:22 <benzrf> that's
17:15:26 <benzrf> fix (return x) == x
17:15:31 <benzrf> right?
17:16:11 <benzrf> ohhhh i see
17:16:24 <benzrf> > (return 3) "wut"
17:16:26 <lambdabot>  3
17:16:29 <benzrf> :-D
17:16:31 <benzrf> igetit
17:16:36 <benzrf> lazy eval yay
17:16:55 <quchen> That's not lazy evaluation, that's just a constant function.
17:17:13 <hpc> it makes a lot more sense when it's written out in a way that makes sense
17:17:16 <LordBrain> i you trying to understand what fix is?
17:17:19 <LordBrain> are
17:17:41 <quchen> The key here is figuring out what the Functor/Monad are, and substituting fmap and return with readable implementations.
17:17:45 <quchen> And then it's trivial.
17:17:51 <LordBrain> the major use case for fix is it lets you write a recursive lambda
17:18:28 <hpc> only once have i ever seriously wanted a recursive lambda
17:18:29 <dwcook> If we didn't have recursive bindings, we could get away with using fix for everything (though obviously it'd be noisier)
17:18:30 <hpc> it was in perl :(
17:19:15 <benzrf> quchen: it's lazy eval
17:19:24 <benzrf> with eager eval, it would infinitely recurse
17:19:56 <quchen> The line before you said the thing with laziness was `(return 3) "wut"`, so I thought you meant that.
17:20:05 <benzrf> oh
17:20:11 <benzrf> sorry mb
17:20:27 <quchen> dwcook: In fact the Report defines recursive let using fix
17:20:31 <grache28> I'm getting an error because of mismatched types [Integer] and [Int] - should I do something like typecasting?
17:20:40 <hpc> the report also defines fix using recursive let, doesn't it?
17:20:44 <roconnor> quchen: is that really true?
17:20:46 <dwcook> Next, explain why const (putStrLn "Hello, world!") fireTheMissiles would never fire the missiles, even if expressions were strictly evaluated.
17:20:50 * hackagebot Elm 0.12.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.12.3 (EvanCzaplicki)
17:21:05 <quchen> roconnor: Section 3.12, "Let expressions"
17:21:55 * roconnor feels like the Haskell report is an eleborate joke
17:23:45 <quchen> I don't see how you would conclude that from the definition of 'let', but OK.
17:23:56 <roconnor> quchen: what's the definition of fix?
17:24:08 <quchen> "where fix is the least fixpoint operator."
17:24:09 <dwcook> (It was a trick question â€“ Evaluation doesn't have side effects (unless you're using a backdoor))
17:24:24 <quchen> dwcook: To be fair, firing the missiles is almost certainly unsafe :-Ã¾
17:24:42 <roconnor> quchen: hmm
17:24:45 <dwcook> quchen: I don't get the connection with what I said.
17:25:19 <quchen> dwcook: I just meant that since firing the missiles is unsafe, the code above may actually launch because there's "usafe*" stuff involved.
17:25:25 <hpc> i always use safeFireMissles (Password "000000")
17:25:46 <quchen> Bad password, needs at least one letter
17:25:56 <dwcook> quchen: heh
17:26:12 <mister_i_> for many years, "00000000" was the actual password
17:26:28 <mister_i_> for the US nuclear launch routines
17:26:41 <hpc> now the password is 11111111
17:26:56 <roconnor> I wonder where I can find a joke password filter that poses more and more elaborate password rules as you try to pick a password.
17:27:12 <LordBrain> > map (fix $ \f -> flol hpc
17:27:13 <lambdabot>  <hint>:1:26:
17:27:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:27:15 <LordBrain> oops
17:27:24 <LordBrain> sorry, i had trash on my line
17:27:25 <tsani> I'm sorry, but your password must contain at least one hieroglyph and the blood of a virgin.
17:27:26 <dwcook> "Your password must contain at least one letter, one digit, and a goat sacrifice to Zeus almighty."
17:28:11 <roconnor> must use at least 1 letter must use at least 1 symbol, cannot have two consecutive letters, cannot have three consecutive characters of the same type, must have one non-ascii character, must use at least 1 ctrl character ...
17:28:14 <hpc> roconnor: write it!
17:28:51 <hpc> roconnor: use the unicode codepoint data, require one thing from each type of character
17:29:12 <roconnor> must use at least one non-breaking whitespace character.
17:29:14 <LordBrain> http://xkcd.com/936/
17:29:19 <hpc> require no consecutive characters, then require no consecutive characters from the same block, then no repeated subsequences
17:29:28 <hpc> no alternating characters
17:29:41 <tombert> Hi there
17:29:52 <hpc> must be at least 12 characters long, unless you start with a capital letter in which case 16
17:30:00 <tombert> to anyone listening, I need a bit of help getting started
17:30:04 <hpc> cannot contain a character that looks like a regex
17:30:13 <roconnor> tombert: on IRC you can just ask. :)
17:30:36 <tombert> I'm just having trouble actually knowing where to start
17:30:50 <tombert> I want to build a game with haskell
17:30:51 * hackagebot ListLike 4.1.0 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.1.0 (JohnLato)
17:30:58 <grache28> so for typecasting from Integer to Int - should I use fromIntegral?
17:31:09 <quchen> tombert: https://github.com/quchen/articles/blob/master/fbut.md#how-to-start-learning-haskell
17:31:09 <roconnor> tombert: have you written hello world?
17:31:10 <tombert> I read through Learn You A Haskell
17:31:23 <tombert> and I've done the examples
17:31:24 <dwcook> grache28: sure. "Typecasting" isn't really the term for that though.
17:31:26 <roconnor> tombert: oh good.
17:31:32 <tombert> but I don't really know where to start in making "real" stuff
17:31:35 <hpc> tombert: have you ever made a game before?
17:31:45 <tombert> I've made a game before with C++ and Flash
17:32:24 <tombert> I guess I'm asking "Do you guys recommend using something like the SDL bindings?"
17:32:24 <hpc> you can join #haskell-game
17:32:37 <tombert> that sounds more appropriate
17:32:42 <hpc> they'll have better advice on particular libraries and such
17:33:07 <grache28> dwcook: ok - in my module file I have the var definition: 'g = ([12,11,8],[1,3,9,6,7,5],[])'
17:33:54 <grache28> once loaded if I do ':t g' I get: 'g :: ([Integer],[Integer],[a])'
17:34:06 <dwcook> grache28: that can be polymorphic if you want. Though just keep in mind that for each type you instantiate it at it's a distinct value.
17:34:22 <grache28> I already have a user defined type which is: type Node = ([Int],[Int],[(Int,Int)])
17:34:54 <augur> @seen saizazn
17:34:54 <lambdabot> 5aiZasn
17:34:58 <augur> doh
17:35:00 <augur> @seen saizan
17:35:00 <lambdabot> 54IZaN
17:35:05 <augur> :|
17:35:07 <hpc> haha
17:35:10 <augur> oh, its preflex
17:35:16 <augur> who did that to lambdabot? you're evil
17:35:19 <augur> preflex: seen saizan
17:35:26 <augur> >_<
17:35:29 <hpc> augur: it's the levenstein distance messing with you
17:35:34 <geekosaur> seen was removed long ago, you're getting an edit correct to @leet
17:35:41 <hpc> it's the same bit of hilarity that led to vixen correcting to nixon
17:35:42 <geekosaur> as for preflex, also gone :(
17:35:54 <augur> hpc: lolol
17:36:22 <augur> damnit. i need to get ahold of Saizan and he's been awol for the last few days :|
17:36:59 <quchen> Preflex was Mauke's bot, wasn't it?
17:37:24 <geekosaur> yes
17:37:38 <quchen> Mauke is gone as well, it seems. Hm.
17:37:46 <dwcook> I thought mauke changed nick at some point.
17:37:59 <geekosaur> mauke changed nick, preflex didn't follow
17:38:09 <geekosaur> nor did the paste redirection bot
17:38:35 <quchen> Oh! You wouldn't happen to know his new nickname?
17:39:02 <geekosaur> corgifex
17:39:08 <geekosaur> at least for the moment
17:39:34 <grache28> I can figure out how to do: typedef int my_type; mytype x = 5; in haskell
17:39:56 <grache28> s/mytype/my_type/
17:39:56 <dwcook> grache28: type MyType = Int
17:40:04 <dwcook> x :: MyType ; x = 5
17:40:18 <grache28> dwcook: aha! had the first line, not the 2nd :)
17:40:39 <dwcook> (The two things I semicoloned together are usually written on separate lines)
17:41:45 <LordBrain> technically, you might warn him that this version of = is definition really, not a store command like in c
17:41:50 <dwcook> Note that, while it's generally suggested to give your top-level definitions explicit type annotations, in the majority of cases they're not required, unlike in C.
17:42:29 <Eduard_Munteanu> Hm, I just implemented (-<=) and (=||=) for conduits, seems doable.
17:42:43 <hpc> what's =||=?
17:42:48 <LordBrain> = in haskell is always a binding definition, <- is a bit closer to c versions of =
17:43:04 <Eduard_Munteanu> hpc: Conduit i m o -> Conduit i' m o' -> Conduit (Either i i') m (Either o o')
17:43:07 <benzrf> :t (<<)
17:43:08 <lambdabot>     Not in scope: â€˜<<â€™
17:43:08 <lambdabot>     Perhaps you meant one of these:
17:43:08 <lambdabot>       â€˜=<<â€™ (imported from Control.Monad.Writer),
17:43:14 <benzrf> Eduard_Munteanu: that looks kinda dumb imo
17:43:33 <LordBrain> by dumb you mean inefficient?
17:43:36 <benzrf> :t (++>)
17:43:37 <lambdabot>     Not in scope: â€˜++>â€™
17:43:38 <lambdabot>     Perhaps you meant one of these:
17:43:38 <lambdabot>       â€˜++â€™ (imported from Data.List),
17:43:47 <enthropy> @type (|||)
17:43:48 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
17:43:53 <benzrf> LordBrain: by dumb i was filling in a sentence to make a lame pun
17:44:01 <dwcook> Haskell doesn't have syntax directly analogous to C's =. C variables are like IORefs, and those come with writeIORef, among other functions.
17:44:08 <Eduard_Munteanu> Well, yeah, I suspect they can be arrows, but conduits aren't at the moment AFAICT.
17:44:20 <dwcook> Even that analogy isn't completely accurate, but it's a closer approximation.
17:44:34 <Eduard_Munteanu> benzrf: what do you mean?
17:44:57 <benzrf> Eduard_Munteanu: i was poorly punning on the i m o in the type sig
17:45:03 <Eduard_Munteanu> Oh. :)
17:45:57 <LordBrain> damn it
17:46:12 <LordBrain> i dont understand the pun
17:46:17 <LordBrain> lol
17:46:26 <benzrf> it's not good trust me
17:46:40 <benzrf> 08:41 < Eduard_Munteanu> hpc: Conduit i m o -> Conduit i' m o' -> Conduit (Either i i') m (Either o o')
17:46:46 <benzrf> a bunch of i m o there
17:46:52 <benzrf> so i wrote a sentence ending in 'imo'
17:46:56 <benzrf> :y
17:47:27 <Eduard_Munteanu> (=>-) seems the easiest, hm.
17:48:06 <enthropy> to make Conduits arrows I think they would have to change the type parameters to Conduit m i o
17:48:13 <LordBrain> you should install a filter-bad-puns plugin into your irc client
17:48:24 <enthropy> which probably doesn't buy you much anyways
17:48:24 <Eduard_Munteanu> They're all basically variations on  probe c i = lift (yield i $= c $$ await) >>= mapM_ yield
17:48:30 <benzrf> o_o
17:48:40 <LordBrain> lol
17:51:20 <roconnor> curse you Data.Functor.Sum
17:51:22 <Eduard_Munteanu> For some reason this looks an awful lot like an indexed state monad.
17:52:57 <spott> If I have a data type: N = I Integer | F Double, and I want to create a function that is (Integer -> Integer -> Integer) -> (N -> N -> N) OR (Double -> Double -> Double) -> (N -> N -> N), by "raising" Integer to Double arguments, how would I do that?
17:53:10 <Eduard_Munteanu> Splitting 'o' involves a pair of probes, splitting 'i' involves either one of probes and connecting them involves something a lot like a bimap.
17:53:39 <spott> my initial guess:  (t -> t -> t) -> N -> N -> N
17:54:05 <Eduard_Munteanu> spott: you'd have to provide each one of those
17:54:14 <spott> raise op (I a) (F b) = F $ op (fromIntegral a) b
17:54:39 <spott> but the problem is with the integer integer version:
17:54:56 <int-e> @hoohle String -> Maybe a
17:54:59 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
17:54:59 <lambdabot> Prelude fail :: Monad m => String -> m a
17:54:59 <lambdabot> Control.Monad fail :: Monad m => String -> m a
17:55:02 <spott> raise op (I a) (I a) = I $ op a b -- This doesn't seem to work
17:55:18 <dwcook> This sounds like a logic problem. Do you want to truncate? Pick one of the arguments to return? Something else?
17:55:56 <spott> it says "can't match expected type t with actual type "Integer" in the return of op
17:56:03 <Eduard_Munteanu> spott: assuming a, b :: Num a => a, op a b :: Num a => a, clearly not an Integer to fill the I parameter.
17:56:27 <Eduard_Munteanu> spott: whereas if one of them is an Integer, op's type forces the other one to be an integer too.
17:57:20 <Eduard_Munteanu> And you probably did not provide a type signature, I guess.
17:57:24 <spott> I did
17:57:32 <spott> provide the type signature
17:57:42 <Eduard_Munteanu> spott: what is it?
17:57:43 <spott> well, I have *a* type signature
17:58:03 <spott> raise :: (t -> t -> t) -> N -> N -> N
17:58:57 <spott> since t doesn't have a value I assume that only says that they all have to be the same
17:59:55 <Eduard_Munteanu> spott: they have to, yes. But also it's a very boring function, if you try to provide one to raise yourself.
18:00:36 <spott> the idea is to apply it to things like (+)
18:00:44 <spott> so I can do nice things like:
18:00:51 <LordBrain> you could do it with a type class, and just make an instance for double and an instance for integer
18:00:52 <spott> raise (+) 1 1.2
18:01:11 <LordBrain> class Raise where
18:01:19 <spott> LordBrain: I'm still learning, and while I'm pretty sure that is the case, I feel like it isn't necessary
18:01:26 <dwcook> LordBrain: that's probably overkill.
18:01:37 <Eduard_Munteanu> spott: if you want it to work for Ns of the same kind, you can't. If you want conversions to happen, then it's possible.
18:01:46 <LordBrain> maybe i missunderstood what you mean to learn
18:01:48 <dwcook> spott: try writing the functions without the lift. Then note the common elements and try to combine them.
18:02:17 <spott> Eduard_Munteanu: why is that?
18:02:22 <Eduard_Munteanu> I'd also do what dwcook says.
18:02:52 <grache28> dwcook: this is the next step I'm working towards - http://lpaste.net/104329
18:03:05 <grache28> got an idea of how to do it, just need to wrangle through the syntax
18:03:07 <LordBrain> There are other methods, you could use generic programming techniques, ie typeable, dynamic.. but that seems worse to me
18:03:08 <Eduard_Munteanu> spott: the N type doesn't provide enough information to align all types.
18:03:41 <Eduard_Munteanu> spott: so you could only define a partial lifting function if you don't want conversions.
18:03:47 <spott> Eduard_Munteanu: I don't understand?
18:04:16 <Eduard_Munteanu> spott: do you want to allow 'raise f (I a) (F b)' ?
18:04:25 <spott> yes
18:04:41 <Eduard_Munteanu> Alright, then it's ok as long as you pick a conversion.
18:04:43 <spott> and `raise f (I a) (I b)'
18:04:51 <LordBrain> oh
18:05:03 <spott> which shouldn't really do anything
18:05:08 <Eduard_Munteanu> spott: you want a Num constraint on 't' in the type then.
18:05:11 <LordBrain> would you tolerate a constraint on the type of the operation? for example only operations on Num types?
18:05:18 <spott> yea
18:05:32 <Eduard_Munteanu> raise :: Num t => (t -> t -> t) -> N -> N -> N
18:05:45 <spott> tried that... doesn't work
18:06:03 <LordBrain> lpaste
18:06:27 <spott> https://gist.github.com/spott/63ecf11f60ad2059be4b
18:06:48 <spott> (in the paste, the function's name is integerize... which is about as shitty a name as raise)
18:06:56 <LordBrain> that's the error, but i mean the code
18:07:01 <spott> ah
18:07:03 <spott> sorry
18:07:11 <spott> let {integerize :: Num t => (t -> t -> t) -> N -> N -> N; integerize op (I a) (I b) = I $ op a b }
18:07:28 <spott> that is what failed... I defined `data N = Integer I | F Double` earlier
18:07:33 <LordBrain> you used the I constructor
18:07:43 <LordBrain> oh wait
18:07:54 <spott> because I'm getting an integer out of that... and I want it to be an N
18:07:55 <LordBrain> that's fine actually
18:08:03 <enthropy> you actually wrote "Integer I" and not "I Integer"?
18:08:08 <dwcook> spott: you don't mean `data N = I Integer | F Double`, do you?
18:08:18 <spott> enthropy: nope I wrote I Integer
18:08:20 <spott> dwcook: yea
18:08:21 <spott> I do
18:08:24 <spott> mean that
18:09:31 <Eduard_Munteanu> spott: er, you want  :: (Num t => t -> t -> t) -> N -> N -> N
18:09:55 <Eduard_Munteanu> spott: you need {-# LANGUAGE Rank2Types #-} for that
18:10:01 <enthropy> and a forall in there
18:10:20 <Eduard_Munteanu> Don't you get it for free in that context?
18:10:27 <enthropy> no
18:11:01 <LordBrain> could he get away with putting a restricting type signature on op
18:11:03 <LordBrain> ?
18:11:05 <enthropy> or the simpler  integerize :: (Integer -> Integer -> Integer) -> N -> N -> N -- might actually work
18:11:08 <LordBrain> that way not needing rank2
18:11:09 <Eduard_Munteanu> Oh, right, it could still be quantified in the outer scope.
18:12:11 <spott> enthropy: the problem is that I also want it to work for integerize op (F a) (I b) = F $ a `op` (fromInteger b)
18:12:22 <LordBrain> that is, I (op::Integer -> Integer -> Integer) a b
18:13:01 <LordBrain> i guess that wouldn't work
18:13:14 <gamegoblin> I think spj is potentially the most british person I have ever seen.
18:13:22 <enthropy> another alternative can be  integerize :: (Integer -> Integer -> Integer) -> (Double -> Double -> Double) -> N -> N -> N
18:13:42 <TallerGhostWalt> is there a way to force an error or a warning when someone does an unsafe pattern match on a sumtype?
18:13:45 <enthropy> you only use op at two different types, so it's not that painful to just take an opFloat and an opDouble?
18:13:55 <TallerGhostWalt> just spent about 2 hours hunting this down
18:14:12 <Eduard_Munteanu> TallerGhostWalt: -Wall?
18:14:38 <monochrom> what is an unsafe pattern match on a sumtype?
18:14:51 <TallerGhostWalt> (x:_) <- someList
18:14:59 <TallerGhostWalt> (Just a) <- someMaybe
18:15:36 <spott> enthropy: you mean on opInteger and an opDouble, and then just apply one of them?
18:15:41 <Eduard_Munteanu> TallerGhostWalt: well, <- is a bit different due to 'fail', so I wouldn't be surprised if -Wall doesn't warn about it
18:16:05 <TallerGhostWalt> yeah it doesn't
18:16:13 <TallerGhostWalt> frustrating
18:17:09 <monochrom> have you read the GHC user's guide? there may be an option for that.
18:17:42 <enthropy> spott: probably that leads to shorter code in total, since enabling Rank2Types and the resulting type annotations will take up more space than just passing around two arguments instead of one
18:18:06 <Eduard_Munteanu> Would be nice to have the compiler inspect fail's definition when doing instance resolution and warn if fail itself is partial, perhaps.
18:18:10 <LordBrain> or there's the type class solution
18:19:07 <spott> enthropy: the annoying thing... that would work, but most calls would look like "integerize (+) (+)" or similar
18:19:08 <LordBrain> actually, would the type class idea have hte same issue?
18:19:25 <TallerGhostWalt> looking right now
18:19:38 <TallerGhostWalt> So it is cause of fail ?
18:19:41 <enthropy> TallerGhostWalt: you can probably use -XRebindableSyntax and import Prelude hiding (fail) to see where you're using fail
18:20:03 <enthropy> probably you're using other modules that export fail too
18:20:25 <monochrom> I can't find one. even -fwarn-incomplete-uni-patterns doesn't care
18:20:27 <Eduard_Munteanu> TallerGhostWalt: if the pattern fails, 'fail' gets called with a String describing that situation.
18:20:50 <Eduard_Munteanu> TallerGhostWalt: this is sometimes convenient when using e.g. ErrorT
18:22:39 <LordBrain> spott, here's an alternative, write a Num instance for N
18:22:55 <mnemon> are there any nice brief haskell tutorials / syntax references / cheat sheets ? the syntax is quite unlike the other langs i've used and while there are tutorials out there, going through 15 pages of text to find the line some part of the syntax is explained is quite slow.
18:22:57 <LordBrain> more work, but you get nice looking code...
18:23:11 <Eduard_Munteanu> @where report
18:23:11 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
18:23:14 <Eduard_Munteanu> mnemon: ^
18:23:31 <Eduard_Munteanu> @where gentle
18:23:31 <lambdabot> http://www.haskell.org/tutorial/
18:23:33 <Eduard_Munteanu> ^
18:23:58 <enthropy> LordBrain: it looks like integerize is for writing that Num instance in the first place...
18:24:15 <LordBrain> oh
18:24:40 <TallerGhostWalt> EduardMunteanu: I dont see anything , oh well ... back to tests I suppose
18:24:41 <mnemon> thanks, i'll take a look at those
18:25:20 <spott> LordBrain: thanks.  I'm actually taking the two operations approach
18:25:31 <spott> it makes things work for (/) and div as well
18:25:32 <LordBrain> actually... you could use traversable
18:25:45 <spott> which is a nice side effect
18:25:50 <spott> LordBrain: what do you mean?
18:26:00 <LordBrain> use the extension derivingTraversable
18:26:20 <enthropy> N has the wrong kind for that
18:27:01 <enthropy> but that one is still a nice extension
18:27:54 <spott> thanks for the help guys
18:28:39 <LordBrain> yeah i guess that idea is a no go actually
18:31:40 <jowens> hey, thereâ€™s an interesting talk on pandoc here:
18:31:42 <jowens> https://github.com/jgm/BayHac2014
18:32:03 <jowens> Iâ€™m trying to build it
18:32:06 <jowens> what is â€œHighlight"?
18:32:12 <jowens> just checkin'
18:35:44 <aupiff> hi all, I have these two packages installed in my ~/.ghc dir: fay-0.20.0.3-77a3d10d63a89be5824008ae3c0ed8d6.conf
18:35:48 <aupiff> fay-base-0.19.1.2-618ecbeed49716028ef612e2deee217d.conf
18:35:48 <aupiff> but
18:35:59 <aupiff> I get this error: fay: ghc: <command line>: cannot satisfy -package fay-base-0.19.1.2:
18:36:03 <aupiff>     fay-base-0.19.1.2-618ecbeed49716028ef612e2deee217d is unusable due to missing or recursive dependencies:
18:36:04 <LordBrain> jowens, in what context?
18:36:05 <aupiff>       fay-0.20.0.3-77a3d10d63a89be5824008ae3c0ed8d6
18:36:08 <aupiff>     (use -v for more information)
18:36:14 <begriffs> Has anyone used hscope to index symbols in Haskell files?
18:36:25 <jowens> @LordBrain the makefile for that talk calls â€œHighlightâ€
18:36:26 <lambdabot> Unknown command, try @list
18:36:28 <aupiff> why might ghc think that fay-0.20.03 is missing?
18:36:59 <jowens> @LordBrain Iâ€™m just checking if this is some magic Haskell package I donâ€™t know about
18:36:59 <lambdabot> Unknown command, try @list
18:37:45 <tigrennatenn> Question about the GHCi debugger: is there a way to break on the Nth time a line is hit?
18:37:49 <monochrom> aupiff: "ghc -v" will say more
18:38:27 <aupiff> monochrom: yeah, but I'm calling fay and not ghc
18:38:27 <aupiff> ..
18:38:57 <aupiff> do you know a way to pass the -v to ghc via fay perhaps?
18:39:07 <monochrom> no
18:40:37 <LordBrain> jowens, i dont know, do you have pandoc installed?
18:40:48 <jowens> yes. pandoc works fine.
18:41:05 <LordBrain> i thought Highlight was a pandoc command
18:41:08 <LordBrain> maybe
18:41:12 <jowens> hm really
18:41:12 <jowens> ?
18:41:16 <LordBrain> no
18:41:21 <LordBrain> i am just learning of pandoc now
18:41:27 <LordBrain> from you, so i'm not an authority here
18:41:32 <jowens> heh
18:41:55 <jowens> itâ€™s a pretty good example of haskell being used to do something eminently practical
18:42:37 <jowens> it might be this: http://www.andre-simon.de/
18:42:43 <jowens> but the error message is â€œcanâ€™t handle JSONâ€
18:43:03 <jowens> if this strikes no oneâ€™s mind quickly, iâ€™ll just assume itâ€™s not a supercommon issue here
18:48:04 <Hafydd> @hoogle Ordering -> Ordering
18:48:06 <lambdabot> Language.Haskell.TH.Syntax thenCmp :: Ordering -> Ordering -> Ordering
18:48:06 <lambdabot> Prelude id :: a -> a
18:48:06 <lambdabot> Data.Function id :: a -> a
18:54:05 <benzrf> http://stackoverflow.com/posts/234535/revisions
19:07:34 <definity> Hi, I got a problem, I downloaded Haskell in Windows and I am trying to loada  file in GHCI but fro some reason it cant find it. do I have to use this syntax to load: :l dirToFile
19:08:56 <benzrf> definity: 1. dont use windows
19:08:59 <benzrf> definity: 2. whats the exact error
19:16:37 <benzrf> :t sequence `asAppliedTo` [id]
19:16:38 <lambdabot> [a -> a] -> a -> [a]
19:17:05 <sellout> s
19:17:06 <LordBrain> definity, you should be able to be able to specify the file at the prompt: ghci MyProgram.hs
19:18:08 <LordBrain> :t asAppliedTo
19:18:09 <lambdabot> (a -> b) -> a -> a -> b
19:18:45 <benzrf> @src asAppliedTo
19:18:45 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
19:18:50 <benzrf> huh
19:19:07 <benzrf> LordBrain: it's just const with a signature that concrete-ifies polymorphic functions
19:20:02 <LordBrain> so, the second parameter of type a there, would just be a sort of dummy to give the type to concretify?
19:20:11 <flebron> Is there a practical use for Yoneda in Haskell?
19:20:50 <benzrf> man whats yoneda again
19:20:52 <benzrf> LordBrain: yep
19:21:25 <agibiansky> Hey guys. I'm having some issues with `cabal-install`. Namely, my package is installable via --solver=topdown, but --solver=modular fails to resolve dependencies. Does anyone know of any tools to help figure out what's going on and what dependencies are confusing it, or have any other suggestions?
19:21:48 <augur> benbangert: yoneda is this iso:   f a   ~   forall r. (a -> r) -> f r
19:22:17 <augur> damnit
19:22:19 <augur> benzrf: ^
19:22:20 <sloopjohnb> whats the best resource to learn about maps?
19:22:31 <augur> sloopjohnb: what do you mean?
19:22:43 <sloopjohnb> learn how to use maps in haskell
19:22:53 <sloopjohnb> im not sure how complicaterd they are
19:22:57 <augur> like... the map function?
19:23:00 <sloopjohnb> i could just go throuhgh the docs if theyre simple
19:23:04 <sloopjohnb> like key value maps
19:23:08 <augur> oh
19:23:15 <augur> like Data.Map
19:23:21 <sloopjohnb> yea i think soi
19:23:29 <sloopjohnb> is it easy?
19:24:00 <LordBrain> sloopjohnb, you know about hoogle right?
19:24:12 <augur> yeah, they're not too bad. it might be useful/insightful/whatever to try to implement your own Map type to get a sense of what the motivations are, tho
19:27:34 <sloopjohnb> augur: im learning then for my own uses, not academically
19:31:12 <tigrennatenn> sloopjohnb: this page might be helpful... http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:map%20package%3Acontainers
19:32:50 <yhvh> hey, got build fails with gpipe, Vec-Boolean, hints? http://lpaste.net/104340
19:36:37 <jle`> what does `view` do in lens(-family), and how does it relate to pipes? :|
19:36:58 <joelteon> :t view
19:36:59 <lambdabot> MonadReader s m => Getting a s a -> m a
19:37:09 <joelteon> :t view _1
19:37:10 <lambdabot> (Field1 s s a a, MonadReader s m) => m a
19:37:21 <joelteon> it's like asks, but using a lens instead
19:37:25 <jle`> oh
19:37:28 <jle`> hm.
19:37:42 <jle`> yeah that's what i sort of got from the type signature when looking
19:37:56 <jle`> but i'm not totally sure what it does when used with pipes
19:38:26 <jle`> if i have a Producer that outputs Word8
19:38:32 <jle`> i can use view pack prod
19:38:40 <jle`> to turn it into a producer that outputs bytestrings
19:38:57 <jle`> and i eventually send it to a sink writing to a file
19:39:26 <jle`> i have heard from Tekmo that this is more efficient that writing a pipe that individually packs every incoming Word8
19:39:39 <jle`> but I don't know how this new version works, if not that
19:40:46 <jle`> because if it just packs a bunch of word8s as they come out...how does that work in constant space?
19:40:54 <jle`> so many questions, i should probably just ask the mailing list.
19:47:38 <int-e> . o O ( oh no, new versions of network and mtl that have to trickle through all of hackage, that will be fun )
19:47:55 <jle`> is there a new mtl?
19:48:30 <int-e> 2.2 is 2 weeks old
19:48:43 <jle`> ah i didn't even realize it, i see
19:48:47 <int-e> but I'm just reinstalling stuff and encountered it for the first time
19:49:09 <agibiansky> random crap with transformers and mtl seems to be breaking my package, so i'm also having issues with it :(
19:49:55 <jle`> hm
19:49:59 <jle`> hey...
19:50:41 <jle`> why isn't State a MonadReader
19:51:11 <jle`> or is it?
19:51:47 <definity> I have written a simple file all it is: fst (1,2). But when i go to load it i get a parse error: naked expression at top level, why?
19:52:07 <int-e> jle`: So that a stack of state + reader will have the reader's MonadReader instanct: instance MonadReader r m => MonadReader r (StateT s m)
19:52:14 <jle`> ah, i see
19:52:16 <enthropy> jle`: because you might like to access the 'r' in a  StateT s (Reader r) without lift
19:52:28 <int-e> jle`: also, 'local' seems a bit awkward in connection with state
19:52:31 <jle`> i was just thinking that actually.
19:52:39 <jle`> that, too
19:53:36 <jle`> definity: you can only put declarations at the top level in a file
19:53:43 <jle`> if you want to evaluate it, you can type it into ghci
19:53:55 <jle`> or you can do myValue = fst (1,2), and load it into ghci, and check myValue
19:54:02 <benzrf> ugh
19:54:07 <benzrf> mflow looks really neat
19:54:15 <benzrf> but the tutorial is written in such broken english
19:54:17 <benzrf> it's hard to read
19:54:18 <benzrf> :{
19:55:35 <dmj`> cabal drives me to drink
19:55:47 <WraithM> hahaha
19:55:49 <agibiansky> dmj`: ditto ditto ditto
19:55:50 <benzrf>  dmj` im sorry m8
19:56:08 <dmj`> I needed a brewski anyways
19:57:06 <excarna> Can you negate an Expectation in HSpec?
19:58:18 <agibiansky> can you include package flags in a build-depends?
20:00:20 <dmj`> agibiansky: you can do platform flags like if os(windows) /n build-depends: blah
20:00:49 <agibiansky> dmj`: i mean, can you specify flags for OTHER packages?
20:01:02 <agibiansky> like, install transformers-compat with required transformers3 flag
20:02:00 <dmj`> Oh, no I don't think so
20:02:18 <dmj`> just install w/o then reinstall w/ the flag
20:02:35 <dmj`> I have to do the same w/ snap-server, add the -fopenssl or -fdevelopment flag
20:02:46 <agibiansky> i see
20:02:54 <agibiansky> yeah, im hitting some sort of cabal bug, bahhh
20:03:18 <dmj`> People keep telling me to go to NixPkgs, they say cabal hell can be fixed
20:03:54 <dmj`> I don't know if nixpkgs has a lot of ghc 7.8.2 stuff
20:04:59 <joelteon> GHC 7.8.2 on nix isn't good right now
20:06:49 <dmj`> joelteon: really, good to know I guess. Would it be too much work to make my own nix pkgs and put them up?
20:06:59 <joelteon> that would be welcome
20:07:02 <rosslazer> Anybody have any experience with Fay?
20:07:35 <dmj`> joelteon: is there a 7.8.2 channel to subscribe to or something?
20:08:11 <joelteon> no, there's nixpkgs.haskellPackages_ghc782
20:12:05 <enthropy> agibiansky: you can include flags in cabal-meta sources.txt
20:12:28 <agibiansky> enthropy: cool, nice to know
20:12:39 <dmj`> joelteon: thanks
20:12:40 <enthropy> though it only works if you don't have two flags with the same name
20:12:50 <enthropy> and want them set in opposite directions
20:13:12 <agibiansky> enthropy: That seems somewhat reasonable
20:18:36 <codygman> has anyone used persistent with mongo here? How about the mongoDB bindings? I would like to query both mysql and mongo and thought using persistent for both would be easiest. I'll also be comparing the mongo/mysql results and figured it would output something similiar. Any thoughts?
20:20:14 <int-e> beautiful. > cabal install --dry-run mueval lens --> Resolving dependencies... cabal: Could not resolve dependencies: Dependency tree exhaustively searched.
20:20:46 <int-e> (that's on top of a fresh ghc-7.8.2 installation)
20:20:56 <agibiansky> int-e: add --reorder-goals
20:21:55 <agibiansky> int-e: or --solver=topdown
20:22:11 <c_wraith> int-e: --constraint="transformers < 0.4" would probably work, too
20:22:15 <Guest46028> Can you paste the exact error?
20:22:28 <agibiansky> (Just had this exact same issue, or at least one that looked really similar)
20:22:31 <int-e> c_wraith: that didn't work, I tried that.
20:22:35 <int-e> agibiansky: thanks!
20:23:30 <agibiansky> int-e: I think this is a cabal-install bug, actually, they have some bug reports along those lines
20:29:45 <cgag> i built an executable I want to distribute, is there a way for me to compile targeting other architectures like i686 if i'm on x86_64?
20:31:03 <yhvh> the words you want  are 'cross compile'
20:33:07 <dmj`> cgag: http://stackoverflow.com/questions/6171429/cross-compilation-with-ghc
20:46:07 * hackagebot http-kit 0.4.0 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.4.0 (SimonHengel)
20:51:51 <bitemyapp> acowley: I think brew has owned the market for awhile now, but there *was* initial confusion.
20:52:09 <user`> how does this parse? : if IO.isEOFError e then return [] else ioError e
20:52:26 <cgag> dmj: damn, much more painful than i'd hoped
20:53:16 <user`> why is there no need for brackets in over "IO.isEOFError e" ?
20:53:33 <cgag> if one person has built a x64_64  -> x386 compiler, i should be able to download that and use it right
20:53:43 <Maxdamantus> user`: because the 'if' and 'then' delimits it.
20:53:51 <user`> aha
20:55:35 <carter> copumpkin: is posting a "heres how to evade the transformers cabal solver breakage" an ok /r/haskell post?
20:56:35 <carter> anyone have thoughts? i've never posted to r/haskell before :)
20:56:54 <agibiansky> carter: i think it is
20:56:56 <carter> ok
20:58:46 <carter> http://www.reddit.com/r/haskell/comments/26045a/if_youre_finding_cabal_cant_build_your_project/
20:58:48 <carter> agibiansky: thoughts?
21:00:15 <agibiansky> carter: looks good, hopefully will save a few people from needless banging head against walls
21:00:27 <carter> UP BOAT IS PEOPLES
21:00:27 <carter> :)
21:00:29 <carter> *it
21:00:58 <binroot> how do I convert an IP address [192.168.1.1] :: [Int] to a Word32 number?
21:04:24 <solirc> excarna: Do you mean specifying a spec item as an expected failure?
21:05:19 <solirc> or just testing for e.g. unequality?
21:05:32 <solirc> that you could do with e.g.
21:06:16 <solirc> actual `shouldSatisfy` (not . (== x))
21:07:51 <binroot> what's the easiest way to convert a list of 4 bytes into a 32bit number?
21:08:32 <user`> what does this mean? Couldn't match expected type `System.Posix.Types.Fd' with actual type `Handle'
21:08:55 <user`> does it mean that what Ihave is Handle, and what I need is Fd?
21:09:06 <user`> how do I get Fd?
21:09:17 <ion> binroot: foldl'
21:10:21 <ion> user: I think there was something for converting back and forth in the unix package.
21:10:44 <solirc> user`: Try hoogle
21:10:46 <solirc> System.Posix.IO
21:12:22 <user`> found handleToFd
21:12:28 <user`> thanks
21:14:38 <user`> it is here : http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-IO-ByteString.html#v:handleToFd
21:14:45 <user`> but I don't manage to import it
21:15:15 <lispy> > shiftL 1 1
21:15:16 <lambdabot>  2
21:15:20 <lispy> > shiftL 2 1
21:15:21 <lambdabot>  4
21:15:51 <user`>  Could not find module `System.Posix.IO.ByteString'
21:15:52 <user`>  
21:16:04 <user`> Could not find module `System.Posix.IO'
21:16:21 <m09> did you install it?
21:16:39 <user`> no
21:16:50 <user`> do I need to install it?
21:16:53 <geekosaur> what platform is this? the unix package is not too helpful on windows
21:17:04 <user`> I am on windows
21:17:33 <geekosaur> and in particular handle-to-fd/fd-to-handle has some weird corner cases because of e.g. sockets
21:17:47 <geekosaur> (which on windows are NOT related to fd-s)
21:17:57 <user`> aha
21:18:15 <user`> I just want to wait for new input on the handle
21:18:20 <ion> Why do you need an fd?
21:18:27 <geekosaur> hrm, usually we just fork a thread for that
21:18:39 <geekosaur> and let the thread block and wake up when input is available
21:19:59 <ion> XY problem
21:20:09 <carter> mvar?
21:20:18 <user`> I used the threadWaitRead but didn't fork anything, because I don't mind the whole program to block
21:20:45 <user`> does block work on files after the EOF is read?
21:21:02 <user`> and anyway I need an Fd
21:21:07 <user`> so I am on windows
21:21:20 <user`> can I still get an Fd, or not?
21:23:41 <ion> What makes you think you need an Fd anyway? You can just read from a Handle, it will block.
21:25:02 <tigrennatenn> anyone here familiar with Helm?
21:27:05 <geekosaur> user`, Haskell's I/O system is designed around using threads for that kind of thing, trying to do it by hand is not easy and not portable and probably going to fail in lots of weird ways
21:35:06 <user`> ion when it read EOF it raise exception
21:35:16 <user`> so it doesn't block
21:35:38 <lispy> binroot: are you still trying to convert [Word8] -> Word32 ?
21:36:16 <dmj`> Trying to cabal install one of my packages in a fresh sandbox, cabal files silently "Could not resolve dependencies" here is the verbose output: http://lpaste.net/104342
21:36:23 <lispy> binroot: the hint is, that if you're using foldr, you might want to look at this \b (acc,offset) -> (acc + b `shiftL` offset, offset+8)
21:36:26 <carter> dmj`: have you looked on /r/haskell ?
21:36:27 <carter> :)
21:36:38 <lispy> binroot: switch the order of b and (acc, offset) if you're using foldl'
21:36:40 <carter> i just put directions to fix tthat there
21:36:50 <dmj`> carter: figures
21:36:54 <carter> read em, test em, upvoate them
21:37:05 <dmj`> thank you, thank you
21:37:08 <agibiansky> well glad im not the only one who was bitten by it... schadenfreude or something?
21:37:09 <dmj`> carter++
21:37:20 <carter> now i'm just going to ask "have you read /r/haskell " instead of explaining things again and again
21:37:25 <carter> agibiansky: its hitting EVERYONE
21:37:30 <carter> you're just louder
21:37:42 <agibiansky> woohoo being loud
21:37:46 <carter> at least everyoen who's using sandboxes
21:37:47 <Welkin> why would anyone read /r/haskell?
21:37:48 * carter is lazy
21:37:56 <carter> Welkin: because i'm not gonna repeat myself
21:37:57 <carter> :P
21:38:24 * Welkin watches carter's brain overflow with thunks
21:38:31 <carter> nah
21:38:35 <carter> i'm pretty strick
21:40:25 <carter> dmj`: fixed?
21:40:25 <dmj`> this is ridiculous
21:40:42 <dmj`> almost...
21:40:45 <carter> :)
21:40:48 <carter> meaning?
21:40:59 <dmj`> ha, there it goes, whaddya know
21:41:14 <carter> i knew
21:41:36 <dmj`> have you heard rumors of nixpkgs solving cabal hell
21:41:53 <dmj`> carter: and thank you again btw
21:42:16 <carter> i've heard rumors that the price of nixpkgs is yakshaving nix expressions for EVERYTHING
21:42:31 <carter> you still have to pick the build plan
21:42:46 <carter> if the solver is stuck, you're hosed anyways for constructing that build plan
21:43:25 <carter> dmj`: you had no idea how to come up wiht a build plan given that error
21:43:27 <carter> now you do
21:43:30 <carter> because the solver did some work
21:44:12 <dmj`> true true
21:44:45 <carter> if you look at recent activity on github.com/cabal/issues you'll see people have been working on this issue
21:45:17 <carter> https://github.com/haskell/cabal/issues?state=open
21:45:24 <carter> https://github.com/haskell/cabal/pull/1879
21:45:27 <carter> https://github.com/haskell/cabal/pull/1878
22:10:19 <Welkin> the new ddg is great
22:10:48 <Welkin> @where ops
22:10:48 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:11:06 <carter> Welkin: why'd you summon ops?
22:11:15 <Welkin> a spammer
22:11:17 <Welkin> zztoo,
22:11:25 <carter> ah
22:11:25 <Welkin> PM url spam
22:11:38 <carter> yuk
22:11:55 <StoneCypher> /msg Welkin http://obviously.not.microsoft.com/virus.cgi?fallforit=please
22:12:07 <Welkin> contact network ops?
22:12:23 <carter> nah, pinging ops is valid
22:12:37 <carter> @where ops
22:12:37 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:12:42 <carter> got spammed now too
22:13:00 --- mode: ChanServ set +o edwardk
22:13:06 --- mode: edwardk set +b *!~ircap@90.174.0.172
22:13:08 --- kick: zztoo was kicked by edwardk (Your behavior is not conducive to the desired environment.)
22:13:16 --- mode: edwardk set -o edwardk
22:13:20 <carter> ok, the person seems to be off channel now
22:13:24 <carter> or kicked
22:13:56 * edwardk whistles innocently
22:14:14 <carter> :)
22:14:21 <carter> @karma edwardk  ++
22:14:21 <lambdabot> edwardk has a karma of 37
22:14:27 <carter> @karma edwardk ++
22:14:27 <lambdabot> edwardk has a karma of 37
22:14:30 <carter> @karma edwardk++
22:14:30 <lambdabot> edwardk++ has a karma of 0
22:14:38 <carter> hah
22:14:44 <Quashie> is karma immutable?
22:14:53 <carter> Quashie++
22:14:56 <m09> it should be in #haskell
22:15:02 <carter> i forget the syntax
22:15:03 <Quashie> no kidding, right?
22:15:14 <Welkin> edwardk++
22:15:23 <Welkin> there is no ++ in haskell
22:15:26 <StoneCypher> ++preincrement
22:15:28 <carter> @karma edwardk
22:15:28 <lambdabot> edwardk has a karma of 38
22:15:31 <StoneCypher> @karma ++preincrement
22:15:31 <lambdabot> ++preincrement has a karma of 0
22:15:33 <StoneCypher> nope.
22:15:34 <Welkin> except string concat
22:15:47 <carter> Welkin++
22:15:51 <carter> @karma Welkin
22:15:51 <lambdabot> Welkin has a karma of 1
22:15:54 <carter> Welkin++
22:15:55 <carter> @karma Welkin
22:15:55 <lambdabot> Welkin has a karma of 2
22:15:58 <carter> done
22:16:14 * hackagebot kmeans-par 1.2.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.2.0 (vi)
22:16:24 <Quashie> foldl enlightenment birth life
22:17:05 <Welkin> how do you like the new interface for ddg?
22:17:49 <Welkin> they fixed a lot of issues that were brought up during the testing, such as *not* having the searchbar/header be fixed in-place
22:18:32 <grache28> i need to sleep, but before I go, anyone got a second to help me wrap my head around solving a simple problem? http://lpaste.net/104329
22:18:46 <carter> whats ddg
22:18:51 <Welkin> duck duck go
22:18:54 <carter> @google ddg
22:18:55 <lambdabot> https://duckduckgo.com/
22:19:04 <StoneCypher> dance dance grevolution
22:19:07 <Welkin> you can search hoogle with !h
22:19:21 <grache28> ^^ wanna figure out how to recursively handle all the tuples dosQueSumen gives me - in this particular case with const. g, there are 2 tuples
22:19:22 <Welkin> and many other sites using similar shortcut "bangs"
22:19:34 <carter> http://www.haskell.org/hoogle/?hoogle=a-%3Eb
22:24:56 <sarva> Hi everyone. What do the slashes and dots in a ghc profile output signify? http://lpaste.net/104343
22:25:20 <StoneCypher> braille
22:25:25 <shachaf> You mean the backslashes?
22:25:28 <shachaf> Probably lambdas.
22:25:30 <sarva> :)
22:25:52 <shachaf> Can you check e.g. where mgr' is defined in createReferenceStack?
22:26:12 <shachaf> If that's a name that exists in your code.
22:26:17 <sarva> Yes. There is a lambda there. Thanks.
22:31:15 * hackagebot eq 4.0.2 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0.2 (EdwardKmett)
22:36:21 * hackagebot pointed 4.1 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.1 (EdwardKmett)
22:38:25 <sarva> Is there a Haskell users group in Mumbai, India?
22:42:29 <bitemyapp> is there a way to express type inequality in Haskell?
22:44:04 <bitemyapp> preferably one that doesn't involve making a witness for every pair.
22:44:15 <c_wraith> yes.  But I don't remember how.
22:44:27 <supki> bitemyapp: http://stackoverflow.com/a/17756741/972985
22:44:44 <bitemyapp> supki: INequality
22:44:49 <c_wraith> that is inequality
22:44:54 <c_wraith> that's using closed type families
22:44:54 <bitemyapp> it is?
22:45:00 <c_wraith> so it only works with GHC 7.8+
22:45:16 <c_wraith> But it's way cleaner than the hacks to do it with older versions of GHC
22:45:30 <c_wraith> Err, ok, that's equality, but whatever.  Just flip the boolean
22:45:59 <c_wraith> The important part is the closed type families let you write type functions like that.
22:47:19 <c_wraith> Of course, a constraint to test for that would look like ('False ~ Equal a b)...  kinda ugly.
22:48:44 <bitemyapp> hrm, parse error.
22:49:04 <bitemyapp> why does using this code lead to a parse error? I'm using 7.8.2 - http://stackoverflow.com/questions/17749756/idiomatic-haskell-type-inequality/17756741#17756741
22:49:33 <glguy> probably old syntax
22:49:40 <bitemyapp> fak.
22:49:50 <glguy> drop line 2
22:50:07 <bitemyapp> glguy: line 2 is blank.
22:50:15 <bitemyapp> glguy: you mean the type instance where?
22:50:15 <glguy> http://lpaste.net/104345
22:50:24 <bitemyapp> thank you.
22:51:22 <enthropy> ghc defines a type family (==)
22:51:45 <enthropy> import Data.Type.Equality
22:51:56 <bitemyapp> I need inequality.
22:52:08 <enthropy> yes so you do   Not (a == b)
22:52:25 <bitemyapp> where would I put this anyway?
22:52:38 <enthropy> put what?
22:52:43 <bitemyapp> the constraint
22:52:53 <bitemyapp> type of a constructor? of a separate function?
22:52:55 <enthropy> well you have a .hs file?
22:53:11 <bitemyapp> h/o
22:53:34 <bitemyapp> enthropy: http://lpaste.net/8019667229782048768
22:53:57 <c_wraith> enthropy: I don't see how Not helps, if you need to make it a constraint.  Wouldn't the constraint need to be False ~ a == b ?
22:54:16 <c_wraith> (possibly with some extra parens)
22:55:14 <glguy> I know it's just a name, but you inequal type family implements equal /:-)
22:55:31 <bitemyapp> glguy: I know
22:55:35 <bitemyapp> glguy: I wanted to see it break before I fixed it.
22:55:42 <bitemyapp> I just don't know how to apply it to my types and I'd like to know how.
22:56:09 <c_wraith> bitemyapp: you mean the thing I've mentioned twice now?
22:56:36 <bitemyapp> c_wraith: I've been reading what you're saying but I can't connect the dots.
22:56:45 <bitemyapp> Please don't be mean, I've never used type families or GADTs before.
22:57:02 <c_wraith> wait, looking at your example
22:57:04 <enthropy> dunno, maybe you want something like http://lpaste.net/8019667229782048768 ?
22:57:15 <bitemyapp> I'm lifting the mana values into types right now.
22:57:35 <enthropy> why?
22:57:39 <bitemyapp> orrrr I can just use Proxy
22:57:45 <c_wraith> This approach doesn't make much sense
22:57:53 <c_wraith> Unless you have full dependent types
22:58:39 <c_wraith> Because you can't normalize combinations
22:59:08 <c_wraith> Well, you can, but it's a huge mess.
22:59:36 <bitemyapp> enthropy: parse error in constructor in data/newtype declaration: (a :: Mana) (b :: Mana)
22:59:51 <bitemyapp> c_wraith: it's just a demonstration, there's a more sensible example already.
23:00:15 <glguy> You'd "only" need 15 constructors to just enumerate the combinations of them and get perfect safety that no one built a red/red hybrid
23:00:41 <bitemyapp> glguy: this is just a demonstration for its own sake.
23:00:55 <bitemyapp> glguy: I side-stepped the combinations problem with a different representation.
23:01:11 <enthropy> bitemyapp: works here (actually I forgot TypeOperators)
23:01:37 <bitemyapp> enthropy: type operators didn't do it :(
23:01:45 <bitemyapp> same error.
23:01:59 <enthropy> did you take my annotation verbatim?
23:02:04 <bitemyapp> yeah, copy pasta.
23:02:08 <bitemyapp> data MyHybrid = (a :: Mana) (b :: Mana) = MyHybrid deriving (Eq, Show)
23:02:11 <enthropy> which ghc do you have?
23:02:15 <bitemyapp> enthropy: 7.8.2
23:02:54 <solidus-river> hey all, where do you put your type classes in a library?
23:03:03 <solidus-river> the actually instances seem to fit well into Lib.Data.Blah
23:03:10 <solidus-river> but where do you put the type clas definitions?
23:03:20 <solidus-river> or i guess just class definitons
23:04:21 <enthropy> solidus-river: put the class where all the instances are
23:06:02 <enthropy> that way you avoid orphan instances, which are bad
23:06:02 <solidus-river> enthropy kk
23:06:27 * hackagebot yesod-platform 1.2.11 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.11 (MichaelSnoyman)
23:10:51 <gabor> c_wraith: you can always write a constraint synonym "type a /~ b = False ~ Equal a b
23:11:06 <c_wraith> gabor: good point
23:11:28 <shachaf> Oh boy, type inequality.
23:12:30 <bitemyapp> c_wraith: enthropy settled on using a validator function + Maybe
23:12:35 <bitemyapp> thanks for your help everyone.
23:17:39 <shachaf> I still would like to know what the simplest GHC extension would be that lets you write foo :: Is Char Bool -> Void
23:17:52 <shachaf> GADTs/TypeFamilies is surely not the answer.
