00:04:18 <mr-> halvorg: I don't think so. What would it do?
00:06:34 <halvorg> mr-: I made it myself,  expandVec (L.V3 a b c) d = L.V4 a b c d
00:06:43 <halvorg> just to expand a vector to a new dimension
00:07:27 <halvorg> Not a big function I grant you, but I try not to reimplement stuff when I can avoid it : )
00:08:29 * hackagebot smtps-gmail 1.2.1 - Gmail SMTP Client  http://hackage.haskell.org/package/smtps-gmail-1.2.1 (EnzoHaussecker)
00:08:29 * hackagebot kmeans-par 1.5.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.5.0 (vi)
00:14:13 <minikomi> here’s what I came up with in the end.. http://lpaste.net/2688351151622979584   thanks to who suggested IORef.
00:21:50 <MagneticDuck> uh.. what about a state monad?
00:21:56 <MagneticDuck> state monad > IORef magic
00:22:21 <MagneticDuck> aw he left
00:22:25 <minikomi> it was for an exercise site which had a specific test suite which needed to pass. .
00:22:49 <MagneticDuck> hm.
00:22:51 <minikomi> yeah..
00:23:14 <minikomi> not super happy with it but, onto the next one.
00:23:20 <johnw> NEXT!
00:23:27 <minikomi> YEAH!
00:25:12 <MagneticDuck> project euler is cool
00:25:17 <MagneticDuck> and they're not all about number theory!
00:25:21 <MagneticDuck> they are about graph theory too
00:25:25 <MagneticDuck> and geometry (?) sometimes
00:25:29 <minikomi> haha
00:26:22 <MagneticDuck> https://projecteuler.net/thread=5;page=8
00:26:27 <MagneticDuck> scroll to bottom
00:26:45 <MagneticDuck> my attempt at trolling project euler a bit ^^
00:26:53 <MagneticDuck> but seriously, all the first page seems to be one liners
00:27:03 <MagneticDuck> I jumped into the more interesting stuff
01:20:46 <opqdonut> johnw: thanks for the ReifyExample.hs
01:21:02 <johnw> you're welcome
01:27:27 <absence> :t para
01:27:28 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
01:27:35 <absence> where is this from?
01:27:56 <johnw> lens
01:28:19 <absence> ah, thanks!
01:41:01 <thatonegentry>  who wants massive doge tips? if you're registered join #theboffin they love new people!!
01:51:29 <kazagistar> ew, thats unintuative
01:51:38 <kazagistar> > [100..1]
01:51:39 <lambdabot>  []
01:52:29 <Lethalman> > [ 100, 99..1]
01:52:30 <lambdabot>  [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76...
01:54:04 <kazagistar> Lethalman: right, I figured it out, but it feels a bit ugly
01:55:58 <kazagistar> are there any types where something is an Enum and not an ord, where this couldn't be checked?
02:06:46 <Ruth18>  You can find funny videos here. http://bit.ly/1ptSokN
02:09:03 <piotr_> hi guys
02:11:27 <jle`> hello piotr_
02:30:10 <Heather> hi
02:30:17 <NinjaPenguin> Lo.
02:30:18 <Heather> how to pass Bool as Char
02:30:25 <Heather> I mean false will be 0
02:30:40 <Heather> so I need Char 0 ...and how can I declare it ... ? let x : Char = ?
02:31:18 <Heather> e.g. I call C library and there is no bool in C and Hakell thinks there is Char but Char in haskell terms is Char...
02:32:12 <Phlogistique> Heather: '\0'
02:33:40 <Heather> works!
02:33:42 <Heather> thanks
02:33:50 <Heather> I used chr 0 anyways
02:44:35 <Heather> got ideas how to implement SplitOn on Idris?
02:47:30 <fizruk> @unpl join . liftM2
02:47:30 <lambdabot> (\ h f -> (\ d e -> d >>= \ b -> e >>= \ a -> return (h b a)) f f)
02:47:37 <fizruk> @pl join . liftM2
02:47:37 <lambdabot> join . liftM2
02:48:56 <|akh|> Hi. I'm trying to run a priviously working Aeson parser, but I get an error (http://pastebin.com/gXDZqrpH) about the used bytestring module (Data.ByteString.Lazy.Char8) being version 0.10.4 and not 0.10.2 as expected, even though only version 0.10.2 is installed with cabal-install (since I just purged everything).
02:49:02 <fizruk> > let sqr m = join (liftM2 (,)) in sqr [1, 2, 3]
02:49:04 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a10)
02:49:04 <lambdabot>    arising from a use of ‘M461184850610515437420104.show_M4611848506105154374...
02:49:04 <lambdabot>  The type variable ‘a10’ is ambiguous
02:49:04 <lambdabot>  Note: there are several potential instances:
02:49:04 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
02:50:30 <Athas> Is there a way to make Cabal/GHC compile several modules of my application in parallel?
02:50:48 <Athas> I noticed that cabal-install is able to compile several packages simultaneously, which is nice, but not really what I need most of the time.
02:51:46 <supki> |akh|: you need to  ghc-pkg unregister  the bytestring version you installed locally
02:52:00 <Kinnison> add ghc-options: -j
02:52:01 <Kinnison> ?
02:52:07 <supki> |akh|: bytestring comes with ghc and is, basically, non-upgradable
02:55:08 <|akh|> supki: ghc-pkg list --user only lists bytestring-0.10.2.0, but indeed the library in /usr/lib/ghc-7.8.2 contains the newer version. Will it not break other things to run ghc-pkg unregister bytestring-0.10.4.0 ?
02:56:09 <supki> |akh|: it will break things; unregister the one in --user
02:56:44 <supki> then reinstall everything that breaks with --constraint='bytestring installed'
02:57:20 <|akh|> supki: That is version 0.10.2.0 which is required by aeson.
02:57:48 <|akh|> supki: So reinstalling aeson with --constraint='bytestring installed' might force it to use the new bytestring version?
02:58:20 <supki> yes
02:58:23 <supki> it actually will
02:58:47 <|akh|> Okay, thank you. I'll try that.
03:02:53 <mirpa> Athas: Look here: http://blog.johantibell.com/2014/04/announcing-cabal-120.html
03:04:18 <prinsen> How do I use the forall keywork with classes? http://lpaste.net/104699
03:05:36 <merijn> prinsen: Are you sure you want a class for that?
03:06:11 <merijn> This seems like a typical case of typeclassing for the sake of typeclassing
03:06:33 <prinsen> merijn: well Im quite new to this
03:06:56 <|akh|> supki: Great that fixed it! Thanks once again. Only text-1.0.0.1 appears broken with ghc-pkg list.
03:07:20 <merijn> prinsen: It's usually easier to replace a class like this with just a record
03:07:22 <merijn> prinsen: See http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
03:07:36 <merijn> prinsen: That has an example of how to replace typeclasses with records
03:11:48 <fizruk> > ala ZipList traverse [[1, 2, 3], [4, 5, 6]]
03:11:49 <fizruk> [[1,4],[2,5],[3,6]]
03:11:50 <lambdabot>  [[1,4],[2,5],[3,6]]
03:12:12 <prinsen> merijn: Good article, but is it possible to use a forall in a class?
03:12:13 <fizruk> :t ala
03:12:14 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
03:13:01 <prinsen> merijn: The OAuth2ProviderRefresh extends the OAuth2Provider class and doesn't care about one of its type parameters
03:14:31 <tristanStrange> hah I've just written one of my first bits of haskell...
03:14:49 <tristanStrange> it works beatifully but it looks ugly as hell
03:14:55 <tristanStrange> https://gist.github.com/triss/1de097609dbe9fc4921b
03:15:16 <tristanStrange> any one care to show me how tobreak this up over a few lines?
03:15:52 <tristanStrange> the indentation in haskell is driving me a bit potty and allergic to ugly code
03:16:25 <tristanStrange> its only tiny!
03:17:40 <frerich> tristanStrange: Instead of '[1] ++ ...' you could also write '1 : ...'
03:18:39 <awestroke> @pl \hitSpacing length -> take length (cycle (1 : replicate (hitSpacing - 1) 0))
03:18:39 <lambdabot> flip take . cycle . (1 :) . flip replicate 0 . subtract 1
03:18:49 <tristanStrange> cheers frerich
03:19:20 <awestroke> ok that's way too point-free
03:19:30 <bjornars> its called pointless for a reaason
03:20:01 <tristanStrange> awestroke wow... looks crazy that
03:20:40 <tristanStrange> oh! that was lamdabot!
03:20:47 <tristanStrange> ?
03:21:36 <frerich> tristanStrange: I sometimes like to use the function composition operator (.) for that, and then have each function being composed on its own line. Like in https://gist.github.com/triss/1de097609dbe9fc4921b
03:22:21 <frerich> tristanStrange: It gets rid of the parentheses and at the same time adds a nice point at which to insert a linebreak.
03:22:43 <mirpa> frerich: I do that with (Control.Arrow) >>> operator
03:23:58 <frerich> mirpa: I guess that works as well. I like '.' because it's a single char and as thus aligns nicely with the '=' :-)
03:24:35 <frerich> mirpa: '>>>' is like 'flip (.)' if I read it correctly?
03:24:50 <mirpa> I like that I can read it top-down, left to right
03:24:52 <mirpa> yes
03:25:06 <frerich> mirpa: Yeah the top-down reading direction is indeed nice.
03:25:22 <mirpa> so... subtract 1 >>> flip replicate 0 >>> (1:) >>> cycle >>> flip take
03:25:25 <frerich> mirpa: Good idea, I'll try to remember it next time I do this. I can well imagine taht I like your style even better :-)
03:25:32 <tristanStrange> thanxs frerich.... got to get my head round this syntax
03:25:48 <tristanStrange> mirpa. can you show an example with >>>?
03:26:28 <mirpa> wait
03:27:15 <jle`> do people actually use (>>>) in real life?
03:27:22 <mirpa> tristanStrange: http://lpaste.net/104701 I wrote this recently
03:27:44 * frerich thinks '\n -> take n . cycle' is so common, there surely must be a ready-made function for this?
03:28:01 <mirpa> (my paste is malformed)
03:28:49 <jle`> (>>>) and (>>=) stand out so weirdly against the rest of haskell, with (.) and ($) and (<$>) and the likes happening so often.
03:29:10 <tristanStrange> cheers mirpa. might take minute to digest this one.
03:29:15 <jle`> having both on the same expression/line makes me kind of dizzy :/
03:29:46 <mirpa> tristanStrange: it is some hashing function rewritten from C
03:30:21 * frerich always thinks of 'fast-forward' whenever he sees some function with '>>' in its name.
03:31:07 <jle`> the best benefit i think with the rightwards-reading functions is that they align with the -> in lambda syntax
03:32:19 <jle`> f >>> \x -> y  might look a bit more coherent than (\x -> y) <<< f, or (\x -> y) . f
03:33:12 <jle`> but (.) just seems to feel more at home in general
03:33:14 <mirpa> jle`: but something like return . either error id is better than either error id >>> return
03:33:31 <jle`> yeah, without the lambda syntax, (.) just feels more natural
03:33:38 <jle`> i think it's because f . g    is f(g(x))
03:34:04 <jle`> (f . g . h) x is f (g (h x)), so that's nice.
03:34:24 <jle`> and (.) reads in the same "direction" as the also commonly used ($)
03:34:54 <jle`> f . g . h $ x, as opposed to h >>> g >>> f $ x
03:35:08 <jle`> hm
03:35:41 <mirpa> to me (>>>) looks similar to unix shell pipe '|'
03:36:13 <jle`> (>>>) and (>>=) and (>>) etc. are semantically similar to the unix shell pipe...so if you are using them alone, that's fine
03:36:51 <jle`> but the majority of haskell code is (.)/($)-leaning, so it is rare that you use them alone i think
03:38:06 <jle`> i see a lot of x >>= f . g . h in the wild, but it could just be f . g . h =<< x, and no eyes jump back and forth
03:38:49 <jle`> or i guess you could do x >>= (h >>> f >>> g) and keep everything the smae direction :)
03:38:57 <jle`> er, h >>> g >>> f
03:38:57 <mirpa> and >=> also
03:40:10 <jle`> i would campaign for the dominance of the right-to-left operators :D  but it's just that >>= and lambda syntax look just too darn good ogether
03:40:42 <jle`> oh well, it's late and i should sleep v.v
03:41:13 <mirpa> night >>= good
03:41:35 <jle`> haha
03:48:50 * hackagebot sqlite-simple 0.4.8.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.8.0 (JanneHellsten)
04:00:33 <tristanStrange> ok guys, thanks for that.
04:00:49 <tristanStrange> still haven't got my head around the . operator it seems
04:00:57 <vanila> it's simple
04:01:01 <vanila> (f . g) = f (g x)
04:01:11 <vanila> it's just for putting two functions together
04:01:30 <tristanStrange> ok i get that (i think)
04:01:30 <mirpa> vanila: (f . g) x = f (g x)
04:01:38 <tristanStrange> but why doesn't this work
04:01:40 <vanila> thanks mirpa!
04:01:49 <tristanStrange> let add (x, y) = x + y
04:02:04 <tdammers> tristanStrange: define "doesn't work"
04:02:05 <mirpa> let add = \(x,y) -> x + y
04:02:16 <tristanStrange> map add . zip [1, 2, 3] [4, 5, 6]
04:02:24 <tristanStrange> doesn't work
04:02:30 <vanila> > (map add . zip [1, 2, 3]) [4, 5, 6]
04:02:32 <lambdabot>  Not in scope: ‘add’
04:02:32 <lambdabot>  Perhaps you meant one of these:
04:02:32 <lambdabot>    ‘odd’ (imported from Prelude), ‘and’ (imported from Data.List),
04:02:32 <lambdabot>    ‘F.and’ (imported from Data.Foldable)
04:02:39 <vanila> > let add (x, y) = x + y in (map add . zip [1, 2, 3]) [4, 5, 6]
04:02:41 <lambdabot>  [5,7,9]
04:02:42 <tdammers> > let add (x, y) = x + y in map add (zip [1,2,3] [4,5,6])
04:02:43 <lambdabot>  [5,7,9]
04:02:43 <tristanStrange> but map add (zip [1,2,3] [4,5,6])
04:02:46 <t7> > let f . g = \x -> f (g x) in ((+ 10) . (+ 20)) 0
04:02:47 <lambdabot>  30
04:03:00 <tdammers> > let add (x, y) = x + y in (map add $ zip [1,2,3] [4,5,6])
04:03:01 <t7> vanila: thats not a valid pattern
04:03:02 <vanila> tridactyla, it's just that you wrote   f . g x   but you need  (f . g) x
04:03:02 <lambdabot>  [5,7,9]
04:03:23 <vanila> t7: it seems to work here
04:03:24 <tristanStrange> erm...but this does: map add (zip [1,2,3] [4,5,6])
04:04:00 <vanila> tridactyla, compare:  f . g x   but you need  (f . g) x
04:04:12 <vanila> tridactyla, compare:  map add . zip [1,2,3] x   but you need  (map add . zip [1,2,3]) x
04:04:21 <vanila> it was just a bracketing problem
04:06:13 <tristanStrange> ah thanx vanila
04:06:22 <bjornars> you might also want zipWith instead
04:06:28 <vanila> so the trick in haskell for this is $ operator
04:06:31 <vanila> you normally write
04:06:35 <vanila> f . g . h $ x
04:06:38 <vanila> rather than (f . g . h) x
04:07:18 <vanila> "$" just does the bracketing for you (of course you don't need to use it but it's conventional)
04:08:38 <tristanStrange> cheers vanila. I'm finally getting it!
04:09:56 <tristanStrange> am i a heathen if i prefer the brackets?
04:10:11 <absence> yes!!!
04:10:17 <absence> :)
04:10:18 <srhb> tristanStrange: Not at all.
04:10:40 <vanila> haha
04:10:46 <vanila> well what I like to do often is write code like this:
04:10:50 <vanila> f = g . h . i . j
04:10:59 <srhb> But just to make it clear, there's nothing (this is a lie, but disregard that) special about the $ operator
04:11:01 <merijn> parenthesis instead of $ is acceptable, however, braces and ; instead of layout are heresy
04:11:13 <srhb> It's just very low-precedence application
04:11:15 <merijn> srhb: Why is it a lie? There is nothing special about the $ operator
04:11:29 <merijn> Not even it's precedence
04:11:39 <srhb> merijn: There's nothing special about the precedence no.
04:11:54 <merijn> srhb: What is the special bit, then?
04:12:05 <srhb> merijn: Something about polymorphism and do blocks, afaik
04:12:28 <srhb> It's not relevant to the discussion though.
04:13:22 <srhb> merijn: I don't remember the exact TRAC right now, and searching for $ is a pain :P
04:13:41 <merijn> :)
04:13:50 <vanila> scary stuff
04:13:54 * hackagebot spatial-math 0.2.0.1 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.0.1 (GregHorn)
04:13:56 <absence> does lambdabot have recursion-schemes tucked away in some namespace?
04:14:28 <absence> or can i query it myself?
04:15:49 <merijn> absence: You could just try the relevant functions in privmsg to see if they're imported
04:18:27 <srhb> I think the point was finding the qualifier name.
04:19:02 <absence> that's right. it's not imported unqualified. but maybe it would suggest the qualified name if it was available at all?
04:25:31 <jbetzend> Hey people! Anyone else have problems installing the library pointless-haskell-0.0.9?
04:27:09 <Yuu_chan> @pl prod x y = [1 .. x] >>= \x' -> [1 .. y] -> \y -> (x', y')
04:27:09 <lambdabot> (line 1, column 43):
04:27:09 <lambdabot> unexpected '>'
04:27:09 <lambdabot> expecting operator
04:27:17 <Yuu_chan> @pl prod x y = [1 .. x] >>= \x' -> [1 .. y] >>= \y -> (x', y')
04:27:17 <lambdabot> prod = (. ((. (const . flip (,) y')) . (>>=) . enumFromTo 1)) . (>>=) . enumFromTo 1
04:29:13 <Yuu_chan> Hm, is it possible to write very laconic cartesian product with arrows or something?
04:30:02 <FireFly> Sounds like a job for Taneb
04:30:10 <vanila> > liftM2 (,) "abc" "123"
04:30:11 <lambdabot>  [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...
04:30:40 <Taneb> FireFly, hold on, why me?
04:30:41 <FireFly> Too readable :P
04:31:03 <FireFly> Taneb: because you like doing weird things with lens
04:31:18 <FireFly> unless I misremember..
04:31:30 <Yuu_chan> Neat, thanks :)
04:31:33 <Taneb> Well, I do, but...
04:32:29 <Yuu_chan> @pl k x y -> x y y
04:32:29 <lambdabot> (line 1, column 9):
04:32:29 <lambdabot> unexpected '>'
04:32:29 <lambdabot> expecting operator
04:32:34 <Yuu_chan> @pl \k x y -> x y y
04:32:34 <lambdabot> const join
04:34:21 <supki> > curry (both id) "abc" "123"
04:34:23 <lambdabot>  [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...
04:37:55 <Yuu_chan> > const join (+) 1
04:37:56 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
04:37:57 <lambdabot>    arising from a use of ‘M729498948862658641921425.show_M7294989488626586419...
04:37:57 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
04:37:57 <lambdabot>  Note: there are several potential instances:
04:37:57 <lambdabot>    instance [safe] GHC.Show.Show a =>
04:38:03 <Yuu_chan> > const join (+) 1 :: Int
04:38:04 <lambdabot>  Couldn't match type ‘m0 a0’ with ‘GHC.Types.Int’
04:38:04 <lambdabot>  Expected type: m0 (m0 a0) -> GHC.Types.Int
04:38:04 <lambdabot>    Actual type: m0 (m0 a0) -> m0 a0
04:38:25 <Yuu_chan> Did lambdabot deceive me?
04:39:35 <int-e> > join (+) 1
04:39:37 <lambdabot>  2
04:39:50 <alpounet> that's (const join (+)) 1
04:39:52 <int-e> Yuu_chan: you had an extra 'k' paramter there
04:39:53 <alpounet> i.e join 1
04:41:20 <Yuu_chan> Silly me!
04:41:25 <Yuu_chan> @pl \x y -> x y y
04:41:25 <lambdabot> join
04:43:23 <simon> :t both
04:43:25 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
04:54:00 * hackagebot jacobi-roots 0.2.0.4 - Roots of two shifted Jacobi polynomials (Legendre and Radau) to double precision  http://hackage.haskell.org/package/jacobi-roots-0.2.0.4 (GregHorn)
05:02:25 <t7> why does it store them as an String :S
05:02:52 <t7> save space maybe
05:11:57 <benedikt> porting a restful web api to haskell as a project to get hands on experince with haskell; good idea or bad idea?
05:12:21 <Maior> benedikt: what Haskell have you done so far?
05:12:43 <benedikt> lyah and some basic programming challenges
05:13:03 <benedikt> basically got stuck because i had nothing "real" to do with it
05:13:09 <Maior> (I personally found it useful to start with "purer" things (a chess library and a game solver), but ymmv)
05:13:11 <benedikt> i'm best at learning by doing
05:13:19 <Maior> sure, same
05:13:32 <Maior> basically "yes"
05:13:35 <benedikt> and i have no real motivation to write e.g. a chess library, although it sounds intersting
05:13:38 <Maior> nodnod
05:13:41 <Maior> understandable
05:13:50 <benedikt> any particular library i should look into?
05:13:55 <merijn> benedikt: How about a simple programming language? :)
05:14:17 <benedikt> a programming language to write web apis? :)
05:14:23 <merijn> Well, any
05:14:47 <merijn> "Write Yourself a Scheme in 48 Hours" is a fairly popular more advanced haskell tutorial implementing a minimal Scheme
05:14:54 <Maior> benedikt: #haskell-web  + http://www.haskell.org/haskellwiki/Web/Frameworks
05:15:22 <Maior> benedikt: (yesod, snap, happstack seem to be "the big names")
05:15:38 <bergmark> benedikt: a rest api sounds like a good idea!
05:15:56 <warpy> scotty
05:16:02 <warpy> dont forget scotty
05:16:08 <benedikt> merijn: i actually started out with that one a while back but i think i only go through the first chapter.
05:16:36 <bergmark> i'd advertise our rest library, but we still need to write a lot of documentation :-( but that'll happen at zurihac!
05:16:37 <benedikt> Maior: hmm. thats three big names. I'll pick one at random.
05:16:51 <benedikt> bergmark: zurihac?
05:17:00 <benedikt> bergmark: link to the library? i'd like to check it out at least
05:17:05 <benedikt> warpy: scotty. noted.
05:17:10 <warpy> bergmark: which one?
05:17:13 <Pythonfant> I want to convert an rss feed to markdown. I have done this in python using regex but looking around it seems that regex are not really what one would use to accomplish such a task in haskell. Should I go for parsec?
05:17:42 <simon> benedikt, I've found making a RISC-like simulator an entertaining exercise.
05:17:46 <warpy> i am also in process of writing a simple REST API and after going through all the web frameworks, i found scotty to be easiest
05:17:46 <merijn> Pythonfant: parsec or attoparsec seems reasonable if you want to code the parser by hand. Alternatively use an xml parser to parse the RSS?
05:17:57 <warpy> very bare bone
05:17:59 <bergmark> benedikt: https://github.com/silkapp/rest
05:18:04 <benedikt> i have a feeling that the type system in haskell will be useful to write a rest api
05:18:18 <benedikt> simon: got any tutorials on that?
05:18:22 <bergmark> benedikt: http://www.haskell.org/haskellwiki/ZuriHac2014
05:18:44 <bergmark> benedikt: yes we use a lot of type magics for it :-)
05:18:54 <benedikt> bergmark: nice. everyone seems to be going to cool conferences, i should do that some time.
05:19:05 <bergmark> benedikt: zurihac is more of a code fun time than conference
05:19:13 <bergmark> also it's free so you totally should :)
05:19:15 <benedikt> bergmark: even more interesting
05:20:24 <bergmark> there are at least four this year in EU+US
05:20:33 <Pythonfant> merijn: ok, I already use feed to parse the rss. I think I'm going to go for parsec (have to look what attoparsec is) to parse the feedItemDescriptions  into markdown
05:21:09 <merijn> Pythonfant: attoparsec is just a more minimal (but more efficient) version of parsec
05:21:16 <Pythonfant> ok
05:21:24 <warpy> hence atto?
05:22:28 <alpounet> bergmark: oh you'll be at zurihac too?
05:22:28 <Pythonfant> right, had to look up the meaning of atto
05:25:48 <benedikt> warpy: scotty seems nice
05:28:19 <benedikt> happstacks seems to be more like a traditional MVC with views and everything to make a webpage
05:44:06 * hackagebot hnetcdf 0.2.0.0 - Haskell NetCDF library  http://hackage.haskell.org/package/hnetcdf-0.2.0.0 (IanRoss)
05:59:08 * hackagebot casadi-bindings-core 1.9.0.3 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-1.9.0.3 (GregHorn)
05:59:10 * hackagebot casadi-bindings-ipopt-interface 1.9.0.3 - low level bindings to casadi-ipopt_interface  http://hackage.haskell.org/package/casadi-bindings-ipopt-interface-1.9.0.3 (GregHorn)
05:59:12 * hackagebot casadi-bindings-snopt-interface 1.9.0.3 - low level bindings to casadi-snopt_interface  http://hackage.haskell.org/package/casadi-bindings-snopt-interface-1.9.0.3 (GregHorn)
05:59:14 * hackagebot casadi-bindings 1.9.0.3 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.3 (GregHorn)
06:09:01 <benzrf> @hoogle (s -> (a, s)) -> State s a
06:09:03 <lambdabot> No results found
06:09:09 <benzrf> @hoogle (s -> (a, s)) -> StateT s m a
06:09:09 <lambdabot> Control.Monad.Trans.State.Lazy state :: Monad m => (s -> (a, s)) -> StateT s m a
06:09:09 <lambdabot> Control.Monad.Trans.State.Strict state :: Monad m => (s -> (a, s)) -> StateT s m a
06:09:17 <benzrf> oh neat
06:09:26 <benzrf> it's polymorphic?
06:09:37 <benzrf> i assumed it was just for Identity o=
06:33:23 <osa1> I'm getting cabal error "ExitFailure (-11)" with no error messages printed to stdout/log file. any ideas why that might be happening?
06:33:41 <dcoutts> osa1: yay! the new process signal stuff works
06:33:49 <dcoutts> osa1: that means your process was terminated with signal 11
06:34:09 <dcoutts>        SIGSEGV      11       Core    Invalid memory reference
06:34:14 <osa1> dcoutts: so GHC got segfault?
06:34:20 <dcoutts> apparently
06:34:24 <osa1> awful
06:34:26 <dcoutts> osa1: linux?
06:34:54 <dcoutts> osa1: or could have been something else cabal called, not necessarily ghc, would have to look at the detailed log carefully
06:34:55 <osa1> dcoutts: yes, but GHCJS :-)
06:35:27 <dcoutts> osa1: I only asked because some signal numbers are different on different POSIX OSs
06:35:31 <Maior> osa1: ulimit -c unlimited ; $previous_command
06:35:31 <Maior> ?
06:35:33 <osa1> dcoutts: log file ends like this "[112 of 202] Compiling ModuleName (... )" with no useful error messages
06:35:55 <osa1> Maior: my ulimit is already unlimited
06:36:09 <osa1> OH WAIT
06:36:13 <osa1> now it failed at different module
06:39:11 <Kinnison> space leak in ghcjs?
06:39:12 * hackagebot ekg-statsd 0.2.0.0 - Push metrics to statsd  http://hackage.haskell.org/package/ekg-statsd-0.2.0.0 (JohanTibell)
06:40:05 <osa1> but I still have free RAM space when that happens
06:40:45 <albeit> I have a program that reads a file line by line, does come calculations, then writes out to a new file. By far and away the slowest part is writing the file, taking 60% of time and allocations. It's just a hPrintf called often... is there any way to speed it up?
06:40:54 <albeit> *some calculations
06:41:15 <Kinnison> Is your output file buffered?
06:41:24 <dmilith> albeit: buffer output, write chunks/blocks
06:41:33 <albeit> Kinnison: I don't know. Nothing explicit for sure
06:42:00 <dmilith> or write once after calculations
06:42:24 <albeit> The files are gigabytes in size, so I'd like to be able to semi-stream the data
06:42:33 <albeit> I'll look into buffering by blocks
06:44:34 <dmilith> albeit: just limit writes amount
06:45:07 <dmilith> cause it's expensive to open file, write, close file, open file .. over and over
06:45:13 <latro`a> let's say I have a directed graph with weighted edges. After I sort the edges from each node by weight, I want to find the cycles which are made by the first edge from each node (easy), then pretend that the cycle is one node in a reduced network
06:45:24 <latro`a> then I want to repeat
06:45:31 <albeit> Ah so if I handle to a file, but write at seperate times, its actually opening and closing it every time?
06:45:38 <BoR0> what's the best way to represent a 2D matrix in haskell?
06:45:50 <BoR0> by best I mean that is easy to manipulate
06:46:29 <Maior> BoR0: in my limited experience, an Array with index of (Int, Int)
06:55:48 <mirpa> Is there better way howto do this? (lift . ErrorT . return) :: Either String a -> ErrorT String IO a
06:56:54 <Kinnison> BoR0: possibly with the matrix or hmatrix packages?
07:01:10 <mirpa> never mind...
07:01:46 <KorriX_> Hello! How to apply multiple fragment shaders onto the texture in haskell OpenGL?
07:02:57 <KorriX> Hello! How to apply multiple fragment shaders onto the same texture in haskell OpenGL ?
07:03:14 <mirpa> KorriX: is that even possible?
07:04:43 <KorriX> mirpa: I think so. I just want to load texture and apply first shader to it saving the result into some kind of canvas, finally applying second shader to that canvas
07:05:01 <KorriX> mirpa: I'm trying to implement two-pass gaussian blur
07:06:25 <Jaxan> KorriX: might be easier in openCL, but you can do it: just draw a quad to invoke the fragment shader
07:06:36 <Jaxan> and render to some fbo
07:09:25 <SrPx> Does anyone know where I can find the specification of languages such as system F and MLTT, including typing rules etc? Something condensed and objective, for someone trying to implement them
07:09:58 <benzrf> quick question
07:10:06 <benzrf> can identity be considered the 'free functor'
07:10:08 <KorriX> mirpa: Jaxan: I've never before used HOpenGL so It would be easier if You could look on my code: http://lpaste.net/5089505970535530496
07:10:16 <benzrf> same as lists are free monoids
07:10:25 <benzrf> or is that wrong p:
07:10:36 <KorriX> mirpa: Jaxan: I have no clue how to initialize and use FBO
07:10:56 <benzrf> or
07:11:02 <benzrf> would something involving compositon
07:11:09 <Jaxan> KorriX: I only know the c API, so I guess I cannot really help here...
07:11:10 <fuzzyhorns> howdy haskell
07:11:11 <benzrf> > undefined :: FreeFunctor
07:11:13 <lambdabot>  Not in scope: type constructor or class ‘FreeFunctor’
07:11:14 <benzrf> hmm
07:11:27 <fuzzyhorns> i am reading http://en.wikibooks.org/wiki/Haskell/Category_theory and had a quick question
07:11:37 <benzrf> oh wait
07:11:39 <fuzzyhorns> join :: Monad m => m (m a) -> m a
07:11:40 <fuzzyhorns> join x = x >>= id
07:11:50 <KorriX> Jaxan: Ok. Thanks for help :)
07:11:56 <fuzzyhorns> what is id in the second line? where is it coming from? i dont know haskell syntax well enough to translate yet :c
07:12:04 <barrucadu> fuzzyhorns: id is the identity function
07:12:04 <benzrf> fuzzyhorns: id a = a
07:12:05 <barrucadu> id x = x
07:12:12 <benzrf> > id 3
07:12:14 <lambdabot>  3
07:12:28 <fuzzyhorns> ah thanks! :) hah i shouldve just tried it in ghci
07:12:37 <klrr_> what are these kind of functional references called? "data Ref a b = Ref { get :: s -> a, set :: a -> s -> s }"
07:12:49 <mirpa> KorriX: I am using OpenGLRaw since OpenGL binding is still changing and some parts are not implemented
07:12:51 <klrr_> is it just functional refereneces?
07:12:53 <benzrf> @let FreeFunctor a0 a = FreeFunctor a0 (a0 -> a)
07:12:54 <lambdabot>  Parse failed: Parse error in expression: a0 -> a
07:12:55 <klrr_> or is it lens?
07:12:55 <fuzzyhorns> thanks benzrf and barrucadu
07:13:03 <geekosaur> that's just record syntax
07:13:06 <benzrf> @let data FreeFunctor a0 a = FreeFunctor a0 (a0 -> a)
07:13:09 <lambdabot>  Defined.
07:13:16 <benzrf> oh wait
07:13:26 <benzrf> would you only need the r -> functor for free functor?
07:13:31 <benzrf> you don't need a base value at all do you
07:13:37 <BoR0> consider I have readCh :: String -> Channel. i.e. readCh s = read s :: Channel. it works fine if type Channel = Int, but it fails when I change Channel to String. I see why it fails and that's okay. but, is there a way to generalize readCh so that whenever I change type Channel it will automatically work?
07:13:38 <benzrf> or do you?
07:14:16 * hackagebot shake 0.13 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.13 (NeilMitchell)
07:15:09 <benzrf> @let instance Functor (FreeFunctor a0) where fmap f (FreeFunctor base def) = FreeFunctor base (def . f)
07:15:11 <lambdabot>  .L.hs:150:59:
07:15:11 <lambdabot>      Couldn't match type ‘a’ with ‘b’
07:15:11 <lambdabot>        ‘a’ is a rigid type variable bound by
07:15:11 <lambdabot>            the type signature for
07:15:11 <lambdabot>              fmap :: (a -> b) -> FreeFunctor a0 a -> FreeFunctor a0 b
07:15:28 <benzrf> @let instance Functor (FreeFunctor a0) where fmap f (FreeFunctor base def) = FreeFunctor base (f . def)
07:15:31 <lambdabot>  Defined.
07:16:12 <benzrf> @let functorify v = FreeFunctor v id
07:16:14 <lambdabot>  Defined.
07:16:19 <benzrf> :t functorify
07:16:21 <lambdabot> a -> FreeFunctor a a
07:16:23 <benzrf> cool
07:17:08 <benzrf> :t fmap show `asAppliedTo` functorify 2
07:17:09 <lambdabot> (Show a, Num a) => FreeFunctor a a -> FreeFunctor a String
07:17:55 <FreeFull> So this free functor type just stores an initial value and transformations applied to it?
07:18:31 <benzrf> FreeFull: well
07:18:34 <bennofs> :t Context
07:18:36 <lambdabot> (b -> t) -> a -> Context a b t
07:18:37 <benzrf> that was my guess as to what a free functor is
07:18:49 <benzrf> FreeFull: i half understand free monads
07:18:50 <FreeFull> Identity is a free functor
07:18:53 <benzrf> oh
07:18:57 <benzrf> i thought so?
07:19:00 <benzrf> i was not sure
07:19:31 <FreeFull> At least, as far as Haskell's functors are concerned
07:19:35 <benzrf> weeellll
07:19:49 <benzrf> the free monad and monoid that i am familiar with both 'defer' operations on them
07:20:15 <benzrf> so that it is possible to 'retroactively change what the operation means'
07:20:27 <benzrf> and for that to work for a free functor, you'd need to do what i just did
07:20:28 <benzrf> afaict
07:20:34 <identity> FreeFull: Master must give Functor a sock before he can be free.
07:20:44 <identity> I really need to change my nick or stop idling in here
07:20:50 <latro`a> lol
07:21:12 <FreeFull> identity: Any piece of clothing works
07:21:17 <identity> oh, yeah
07:21:23 <bennofs> > fmap show `asAppliedTo` Context id 2
07:21:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
07:21:25 <lambdabot>                     Control.Lens.Internal.Context.Context)
07:21:25 <lambdabot>    arising from a use of ‘M235062799378324144523300.show_M2350627993783241445...
07:21:31 <bennofs> :t fmap show `asAppliedTo` Context id 2
07:21:33 <lambdabot> (Show a, Num a1) => Context a1 a a -> Context a1 a String
07:21:39 * identity punishes himself for his ignorance
07:22:33 <benzrf> hmm
07:22:46 <benzrf> i've noticed something between haskell and, say, ruby
07:23:11 <benzrf> in ruby, most tools that libraries provide are reasonably complicated semi-opaque abstractions with useful interfaces
07:23:23 <benzrf> whereas in haskell, the tools tend to be actually quite simple
07:23:29 <benzrf> and most of the power lies in understanding how to use them
07:23:51 <benzrf> i.e. monads, van laarhoven lenses
07:24:10 <FreeFull> Haskell has a lot of deviously, deceptively simple abstractions
07:24:18 <benzrf> like
07:24:22 <benzrf> less like a car and more like a hammer
07:24:38 <benzrf> hammers are simple objects
07:24:44 <benzrf> but if you understand the correct way to apply them
07:24:47 <benzrf> they are very useful :-)
07:24:56 <benzrf> cars, otoh, are complicated beasts
07:25:10 <benzrf> they also do something useful if you understand how to use them
07:25:20 <benzrf> but their internals are quite complex
07:25:29 <Welkin> benzrf, when you said "car" I thought "cdr"
07:25:33 <benzrf> Welkin: haha
07:25:52 <benzrf> also, cars are harder to use as something other than cars
07:26:01 <benzrf> hammers can act as non-hammers
07:26:09 <benzrf> their usage is more given by what you use them for
07:26:16 <benzrf> whether that's a good thing or a bad thing is up to you i guess
07:26:32 <benzrf> like, you can treat a van laarhoven lens as purely an abstraction and only use over and so ons
07:26:38 <benzrf> or you can directly apply it as a function
07:26:48 <benzrf> it's more...
07:26:49 <benzrf> concrete?
07:27:11 <benzrf> whereas a lens-like thing in ruby would probably be more black-box-ish
07:27:22 <benzrf> i guess that's kind of a principle of oop
07:27:22 <benzrf> hmm
07:29:06 <benzrf> i suppose the difference arises from packaging behaviors w/ data vs. shipping them separately
07:29:35 <benzrf> when you can see the actual data used by the behaviors it seems more like a bunch of simple parts and less like a useful black box
07:30:25 <latro`a> a rule of thumb question: if I have a procedure that can be thought of as repeatedly compressing a data structure, where all I ultimately only need to know what was was compressed into what, is it better to actually build the new data structures, or to operate with the original only?
07:30:42 <lechip> yellow everyone, can anyone hel me understand how to get the least fixed point of a funciton?
07:31:09 <latro`a> which "least"?
07:31:14 <latro`a> that is, wrt which order?
07:31:25 <latro`a> type specificity?
07:31:40 <lechip> respect to definedness
07:31:52 <latro`a> are you asking "how does fix work"?
07:31:57 <lechip> nope
07:31:59 <latro`a> because fix is the answer to your question
07:32:03 <lechip> im trying to understand the denotational semantics
07:32:52 <lechip> and in order to give semantics to a function i see that i need the least fixpoint of a function thatt gives it the semantics
07:33:08 <Freundlich> What do you mean by "get the least fixed point"?
07:33:32 <lechip> say i got a higher order funciton ee and i want to know its least fixed point
07:34:04 <lechip> does that make sense at all?
07:34:21 <Tjr> lechip: how would oyu know one fixed point is "lesser" than the other?
07:34:40 <armlesshobo> i don't know what fixed point means
07:34:47 <latro`a> fixed point means f x = x
07:35:02 <lechip> Tjr: It would be less defined, i am trying to find it in respect to the definedness order
07:35:06 <armlesshobo> looks like a definition to me :\
07:35:07 <benzrf> hmm
07:35:18 <vanila> lechip, take the limit of the sequence undefined, f undefined, f (f undefined), f (f (f undefined)), ...
07:35:19 <benzrf> whats the proof of fmap distributing over function comp given fmap id = id
07:35:19 <latro`a> I should say ==
07:35:45 <lechip> vanila: exactly, but how I know is the limit?
07:36:09 <latro`a> benzrf, why would there be one? contravariant functors satisfy that too but they do not satisfy fmap (f . g) = fmap f . fmap g
07:37:12 <vanila> lechip, You can see Dana Scotts construction of the domain D = [D -> D]
07:37:28 <benzrf> latro`a: huh...
07:37:35 <benzrf> i couldve sworn i saw somewhere that that works
07:37:49 <latro`a> take fmap = flip (.)
07:38:40 <latro`a> er no, sorry, that's not fully right
07:38:57 <benzrf> do you mean (.)
07:39:27 <bennofs> :t fmap `asTypeOf` (.)
07:39:29 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
07:39:29 <latro`a> (.) makes a valid functor, I was attempting to write down the contravariant version
07:39:34 <Walther> I'm a bit confused on fold syntaxes. Trying to e.g. implement sum:
07:39:44 <Walther> > foldr (+) [3,3,3,3]
07:39:46 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
07:39:46 <lambdabot>    arising from a use of ‘M537866049765079287923506.show_M5378660497650792879...
07:39:46 <lambdabot>  The type variable ‘t0’ is ambiguous
07:39:46 <lambdabot>  Note: there are several potential instances:
07:39:46 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:40:02 <benzrf> Walther: do you mean foldr1?
07:40:11 <Walther> > foldr1 (+) [3,3,3,3]
07:40:12 <lambdabot>  12
07:40:21 <Walther> :t foldr1
07:40:22 <lambdabot> (a -> a -> a) -> [a] -> a
07:40:23 <benzrf> Walther: ((->) r) is not a contravariant
07:40:25 <benzrf> you got to flip the args
07:40:33 <Walther> :t foldr
07:40:35 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:40:35 <benzrf> * latro`a
07:40:37 <benzrf> not Walther
07:41:23 <barrucadu> Walther: You need to give foldr a starting value, foldr1 takes it from the list (but dies on empty lists)
07:42:00 <barrucadu> > foldr (+) 3 []
07:42:02 <lambdabot>  3
07:42:06 <barrucadu> >foldr1 (+) []
07:42:11 <barrucadu> > foldr1 (+) []
07:42:13 <lambdabot>  *Exception: Prelude.foldr1: empty list
07:42:36 <Welkin> > foldr1 (+) [1]
07:42:38 <lambdabot>  1
07:42:44 <lechip> vanila: I have a problem, say my funciton defines something like (ff(g))(x)= _|_ if x = _|_, otherwise g(x+1) or something like that. Wow do i go with the application of  f _|_, f (f _|_), f (f (f _|_)), ... if applying ff on x= _|_ yields _|_
07:43:21 <latro`a> if f _|_ = _|_ then _|_ is the least defined fixed point
07:44:20 <latro`a> (of f)
07:44:31 <vanila> lechip, yes
07:44:55 <lechip> vanila: so my lfp would be... _|_ ???
07:45:01 <vanila> yes
07:45:13 <latro`a> that's actually "typical", in some sense
07:45:22 <vanila> a function cannot tell whether it's input is _|_ or not
07:45:26 <latro`a> in that it's characteristic of strictness
07:45:27 <vanila> that's why functions are continuous
07:45:42 <vanila> and this is crucial to the existence of least fixed points
07:46:20 <lechip> so in general the lfp its always going to be _|_ as long as the function is monotonic?
07:46:40 <latro`a> which monotonic? decreasing or increasing?
07:46:48 <lechip> increasing
07:46:58 <lechip> i mean... converging
07:47:02 <vanila> lechip, no
07:47:10 <allsystemsarego> @pl f t1 t2 = snd t1 == snd t2
07:47:11 <lambdabot> f = (. snd) . (==) . snd
07:47:18 <latro`a> try f = const x for a first example
07:47:34 <Tjr> LYAH quote "Having your whole program be just one I/O action seems kind of limiting."
07:47:50 <Tjr> The guy must have had a sense of humor.
07:49:06 <latro`a> LYAH is full of jokes
07:49:40 <frerich> allsystemsarego: I think a nicer point-free version is '(==) `on` snd'.
07:50:50 <BoR0> what is the point of writing point-free versions of a function?
07:51:01 <tromp> no point
07:51:01 <BoR0> to me they are much more cryptic
07:51:02 <allsystemsarego> frerich, thanks, I'll try it
07:51:14 <barrucadu> BoR0: Sometimes you get an easier to read result
07:51:15 <Welkin> sometimes they are easier to read
07:51:20 <bennofs> BoR0: sometimes, they allow you to avoid a lambda
07:51:29 <Welkin> they look cleaner too
07:51:33 <BoR0> what's wrong with lambdas? :D
07:51:45 <bennofs> BoR0: you need to think of names for the variables :=)
07:51:51 <Welkin> it makes it easier to create a pipeline
07:51:52 <BoR0> haha! nice
07:52:06 <bennofs> compare (\x y -> snd x == snd y) and ((==) `on` snd)
07:52:18 <bennofs> IMO, the second is easier to read
07:52:25 <BoR0> @src on
07:52:26 <lambdabot> (*) `on` f = \x y -> f x * f y
07:52:36 <rwbarton> lechip: f _|_ isn't always _|_ (even when f is continuous and monotone)
07:53:03 <rwbarton> for example f could be a constant function, f x = 3
07:53:21 <rwbarton> more generally f could "produce output before consuming any of its input"
07:54:08 <rwbarton> f x = 1 : x
07:54:11 <ArisFr> Hi, I know this may seem stupid, but am I wrong to think that groupBy looks like a generalized version of filter?
07:55:01 <vanila> ArisFr, it's not generalized filter
07:55:02 <frerich> ArisFr: What does 'generalized' mean in this context? Do you mean that 'filter' could be implemented in terms of 'groupBy'?
07:55:13 <ali_pang> does anyone know if there's a haskell parser written in a combinator library? ideally parsec
07:55:35 <BoR0> @src groupBy
07:55:35 <lambdabot> groupBy _  []       =  []
07:55:35 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:55:35 <lambdabot>     where (ys,zs) = span (eq x) xs
07:55:38 <ali_pang> somelike like what's in haskell-src / haskell-src-exts, but not using alex
07:56:10 <allsystemsarego> ali_pang, hxt is written in parsec
07:56:18 <allsystemsarego> I meant on top of parsec
07:57:08 <ali_pang> allsystemsarego: i meant for the haskell language itself. hxt is for XML, no?
08:00:34 <geekosaur> ali_pang, I am under the impression that parsec does not handle indentation sensitivity (as in haskell or python) well
08:00:56 <vanila> parser combinators are bad :(
08:01:02 <geekosaur> bah
08:01:11 <pjdelport> There is http://hackage.haskell.org/package/IndentParser
08:01:35 * Kinnison hugs parsec
08:01:49 <benzrf> via https://hackage.haskell.org/package/base-4.2.0.0/docs/Data-Functor.html
08:01:55 <benzrf> Functor [::]
08:01:59 <simon> vanila, why?
08:02:01 <benzrf> under Functor instances
08:02:05 <benzrf> what the heck is [::]
08:03:12 <vanila> simon, combinatorial explosion makes my parser take seconds for a few bytes
08:05:23 * geekosaur tries to remember what that is
08:05:29 <geekosaur> but [: :] are brackets
08:06:00 <michaelt> parallel arrays
08:06:05 <geekosaur> ah, right
08:06:07 <benzrf> o_O
08:06:09 <geekosaur> dph
08:07:10 <Welkin> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/dph-par-0.4.0/Data-Array-Parallel.html
08:07:18 <geekosaur> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
08:08:37 <byorgey> vanila: are you using parsec?  or did you make your own parser combinator library?
08:09:08 <vanila> ReadP
08:09:28 <rwbarton> well...
08:09:36 <geekosaur> ReadP is ... not exactly a sterling example
08:09:37 <byorgey> vanila: ReadP is basically a toy.
08:09:53 <vanila> ok
08:10:08 <geekosaur> in fact if someone says they're using it, people usually point them to parsec or attoparsec
08:10:33 <byorgey> it's convenient if you need to parse something small and don't want to incur some big dependency.
08:11:27 <benzrf> :t ReadP
08:11:28 <lambdabot> Not in scope: data constructor ‘ReadP’
08:11:30 <benzrf> wait
08:14:20 <Yuu_chan> :info ReadP
08:14:31 <benzrf> Yuu_chan: sadly lambdabot does not support :i yet
08:14:31 <benzrf> ;-;
08:14:39 <Welkin> ?info ReadP
08:14:40 <lambdabot> ReadP
08:14:48 <Welkin> how informative
08:14:54 <benzrf> @info is echo
08:14:54 <lambdabot> is echo
08:14:57 <benzrf> no wait
08:15:01 <benzrf> @info gets corrected to undosdf
08:15:01 <lambdabot> gets corrected to undosdf
08:15:02 <benzrf> *undo
08:15:08 <Welkin> ?info I love you
08:15:08 <lambdabot> I love you
08:15:13 <Welkin> I love you too lambdabot
08:15:17 <benzrf> @info do {this; that; other;}
08:15:17 <lambdabot> this >> that >> other
08:15:25 <benzrf> undo -> info
08:15:31 <benzrf> autocorrect feature
08:16:15 <benzrf> there should be a band called Run GHC
08:16:53 <Yuu_chan> undo $ do putStrLn "Hi!" must be return () %)
08:17:33 <Welkin> > putStrLn "hello"
08:17:34 <lambdabot>  <IO ()>
08:22:42 <BoR0> > do {  putStrLn "hello" }
08:22:43 <lambdabot>  <IO ()>
08:23:25 <Welkin> ?i lambda
08:23:25 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
08:23:42 <Welkin> ?
08:23:48 <Welkin> ??
08:23:51 <Welkin> ?.
08:23:51 <lambdabot> Not enough arguments to @.
08:24:03 <Welkin> ?@
08:25:46 <int-e> @. djinn type maybe
08:25:48 <lambdabot> f a b c =
08:25:48 <lambdabot>     case c of
08:25:48 <lambdabot>     Nothing -> a
08:25:48 <lambdabot>     Just d -> b d
08:25:58 <Welkin> djinn??
08:26:04 <ArisFr> frerich: yes, I mean that you could easily implement filter by groupBy: group into Bool and discard False
08:26:06 <Welkin> haskell has genies??
08:26:28 <int-e> Welkin: djinn conjures up implementations from types
08:26:34 <ArisFr> vanilla: couldn't you easily implement filter by groupBy: group into Bool and discard False
08:26:52 <Welkin> @.
08:26:52 <lambdabot> Not enough arguments to @.
08:26:57 <Welkin> what is @. for?
08:27:05 <int-e> and @. composes commmands in lambdabot
08:27:15 <int-e> @type maybe
08:27:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:27:20 <Welkin> > djinn type maybe
08:27:22 <lambdabot>  <hint>:1:7: parse error on input ‘type’
08:27:26 <int-e> @djinn b -> (a -> b) -> Maybe a -> b
08:27:26 <lambdabot> f a b c =
08:27:27 <lambdabot>     case c of
08:27:27 <lambdabot>     Nothing -> a
08:27:27 <lambdabot>     Just d -> b d
08:27:56 <rwbarton> ArisFr: how would you "discard False"
08:29:17 <ArisFr> rwbarton: mmm, using filter? :) ok, let me think a bit more about this
08:33:15 <albeit> Is there any way for two records in the same module to have identical field names?
08:34:17 <ArisFr> rwbarton: I'm writing some data filtering and grouping functions, and as part of that I am trying to create matcher functions. I would prefer to be able to somewhat unify them so that I can use the same functions for both grouping and filtering where that makes sense. If groupBy was a genralization of filter (which I now see it is not) this tacks would be easier.
08:35:19 <michaelt> albeit not as things stand; there is an extension coming http://www.well-typed.com/blog/84/ , and various ways of doing as well or better anyway with lenses.
08:36:20 <albeit> michaelt: Thanks
08:37:04 <joshkirklin> I have a basic question
08:37:10 <joshkirklin> Is there a  computational difference between repeated function application and composition  of several functions and then application? For example, ``(*9) . (+2) . (/6) $ 19`` vs `` (*9) $ (+2) $ (/6) $ 19``
08:37:48 <michaelt> albeit, if you are fretting about haskell records you might look into the lens world, if you don't know about it, e.g. #haskell-lens
08:37:50 <joshkirklin> stylistically I prefer the former, but I'm not sure whether either has computational benefits over the other in certain situations
08:38:11 <vanila> joshkirklin, I think that there's no difference
08:38:28 <albeit> michaelt: I've had a cursory look, but not much at all. Need to start sometime though...
08:38:30 <vanila> there is a difference between like  map f . map g   and   map (f . g),  but nothing like that here
08:38:52 <joshkirklin> ok, thanks
08:39:19 <joshkirklin> would the difference between map f . map g and map (f . g) be that with the former you have to traverse twice?
08:39:27 * hackagebot senza 0.0 - An HTML building library without the need for pesky operators.  http://hackage.haskell.org/package/senza-0.0 (ChrisDone)
08:39:28 <joshkirklin> whereas the latter only once
08:39:51 <Welkin> haskell is lazy
08:39:57 <int-e> joshkirklin: on the surface, yes. ghc implements list fusion which should make the two equivalent
08:39:59 <michaelt> joshkirklin: in principle yes. ghc 's list machinery will in theory take care of it.
08:40:01 <Welkin> so they should both only traverse once
08:40:18 <joshkirklin> mmk
08:40:36 <rwbarton> it depends on what you mean by "traverse once" vs "traverse twice"
08:41:03 <int-e> Welkin: the question is whether an intermediate list is constructed (even though it will never be held in memory in full, it would be consumed as it's being traversed. but the allocations themselves are not free)
08:41:42 <vanila> oh yeah
08:41:55 <vanila> so bad example from me because GHC has special techniques to optimize it
08:42:23 <vanila> what i had in mind was combinator parsers
08:42:38 <vanila> in the normal way you write them, you end up with loads of map f . map g . map h type stuff
08:42:50 <vanila> but there's a trick that optimizes that out too (different than the lists thing)
08:44:45 <danilo2> Hello! :) I would love to ask you one question - Why ghc (7.8) tells me, that I've got here functional dependencies even enabling IncoherentInstances (or OverlappingInstances) flag? Is it not supposed to choose the instance ,which is less generic over more generic one? http://lpaste.net/104708
08:48:04 <danilo2> Ah I know! The problem is not with overlapping instances but with conflict in type inference when providing the types to fundeps :)
08:51:46 <edwardk> @tell reinh http://alexbowe.com/succinct-debruijn-graphs/#our-repr might be useful
08:51:47 <lambdabot> Consider it noted.
08:52:19 <klrr_> how do i enable an extensions while in a interactive ghc session?
08:53:10 <bennofs> klrr_: :set -XExtensionName
08:53:37 <klrr_> thanks!
08:55:41 <klrr_> why does this this yields an error with Rank2Types enabled? "let f g = g 1 + g "2" :: (forall a. a -> Int) -> Int"
08:56:15 <rwbarton> you put the type signature on the result of f
08:56:24 <rwbarton> not on f itself
08:56:46 <klrr_> oh
08:57:19 <klrr_> maybe if i write a lambda..
08:57:44 <klrr_> yay, thanks
09:08:19 <fread2282> @pl t a b = pure a <*> b
09:08:20 <lambdabot> t = (<*>) . pure
09:08:51 <Walther> > foldr (+) 0 [1..5]
09:08:53 <lambdabot>  15
09:09:03 <Walther> > foldr1 (+) [1..5]
09:09:05 <lambdabot>  15
09:09:09 <klrr_> fread2282: thats fmap :P
09:09:11 <benzrf> fread2282: fmap
09:09:14 <fread2282> yep
09:11:55 <albeit> If I enabled existential types, and make something like data Foo = Foo { bar = [Maybe a] }, can I later pattern match on bar to narrow down its type?
09:11:55 <bennofs> fread2282: that's just (<$>)
09:11:59 <bennofs> fread2282: or fmap
09:12:06 <fread2282> bennofs: yep
09:12:15 <klrr_> bennofs: two people already pointed out ;)
09:12:32 <bennofs> klrr_: oh, I looked but somehow I didn't see it (was searching for (<$>) though :)
09:12:43 <klrr_> hehe :)
09:12:51 <benzrf> albeit: i do not think so
09:12:52 <benzrf> i may be wrong
09:13:04 <Walther> :t foldr'
09:13:06 <lambdabot>     Not in scope: ‘foldr'’
09:13:06 <lambdabot>     Perhaps you meant one of these:
09:13:06 <lambdabot>       ‘BS.foldr'’ (imported from Data.ByteString),
09:13:16 <benzrf> albeit: afaik existentials are only useful when used with constraints
09:13:25 <benzrf> but i am not certain
09:13:38 <c_wraith> benzrf: not strictly true
09:13:52 <c_wraith> benzrf: they can also be useful when you have several values with related types
09:14:14 <benzrf> c_wraith: example?
09:14:15 <c_wraith> benzrf: data Coyoneda f a = Coyoneda (b -> a) (f b)
09:14:28 <c_wraith> benzrf: that's one that I've even used recently
09:14:34 <benzrf> oic
09:14:38 <benzrf> yeah i forgot about that one
09:14:44 <c_wraith> err, make it existential appropriately
09:15:03 <rwbarton> (s, a -> s -> (b, s))
09:15:04 <benzrf> i guess i meant that the actual values are only useful when you have a typeclass constraint
09:15:18 <rwbarton> where a and b are fixed and s is existential
09:15:20 <benzrf> if you ignore the other stuff in the thing
09:15:35 <benzrf> i.e. if you only took one of the things from your coyoneda, it would be useless
09:15:52 <albeit> So if I need a record field of type [Maybe a], where a is one of a few similar but different datatypes, and I need to eventually know what type a is, what is the recommended way to do that?
09:16:02 <c_wraith> benzrf: indeed.  Like I said, the important there is that multiple things have types that are related
09:16:12 <benzrf> oright
09:16:17 <rwbarton> albeit, a sum type
09:17:16 <albeit> rwbarton: Oh man, of course, overcomplicating things for myself
09:18:01 <benzrf> haha
09:18:05 <benzrf> albeit: lol
09:27:08 <simon> anyone know of any Haskell learning material that differentiates between the uses of monad return types and writer monads?
09:28:37 <benzrf> simon: w-what?
09:28:41 <benzrf> simon: what does that mean?
09:28:42 <c_wraith> simon: I don't know of any Haskell learning material that conflates them
09:29:08 <c_wraith> simon: given that they're complete non-comparable...
09:29:14 <klrr_> what is the Const type in applicative used for?
09:29:25 <klrr_> Control.Applicative.Const
09:29:33 <c_wraith> klrr_: most notably, it's used by Lens
09:30:33 <klrr_> simon: return is a way to "lift" a value into a monadic context, writer monad is a monad of type (a, w)
09:31:07 <klrr_> ok, dont listen to me
09:31:25 <klrr_> c_wraith: that is exactly where i encountered it :)
09:31:42 <simon> benzrf, c_wraith: let's say I want to write a state-machine that emits results. I could either make some monadic combinators that use the return type as this list of results, or I could use a writer monad so that I can simultaneously use the monadic return type for other purposes.
09:31:47 <klrr_> im just trying to wrap my head around what it does, does it simply "drop" an argument of a function?
09:32:21 <benzrf> simon: writer is for outputting from any point in a monadic computation
09:32:30 <benzrf> return type is for a value to pass to the next step
09:33:05 <simon> benzrf, right.
09:33:10 <c_wraith> klrr_: it's a data type that carries around a value of one type, and has a phantom type paramenter of another type
09:33:32 <klrr_> simon: if you are unfamiliar with monads (or maybe i just missunderstand what you try to say) this one is consider to be very good: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:33:45 <benzrf> klrr_: it's for functors where fmap is a no-op but you can carry around a value anyway
09:33:50 <simon> klrr_, I did read that one. :)
09:35:00 <klrr_> i dont quite understand
09:35:07 <klrr_> no-op?
09:35:13 <Fernandos> hi
09:36:07 <c_wraith> klrr_: fmap (+7) (Const "hello") === Const "Hello"
09:36:08 <simon> fmap f (Carry x) = Carry x?
09:36:23 <klrr_> oh
09:36:34 <klrr_> so its a indestructable container?
09:36:57 <Fernandos> there's a question growing in me.. it's about mutability. Could we avoid mutability using "Monadid Reflection" (with continuations)?
09:37:11 <benzrf> Fernandos: Monadic reflection?
09:37:42 <c_wraith> klrr_: I have no idea what you mean by indestructable.
09:37:44 <Fernandos> benzrf: there is a really difficult to grasp slide about it.. not sure if it would help at all to explain what I mean
09:38:08 <Fernandos> benzrf: http://cs.ioc.ee/mpc-amast06/msfp/filinski-slides.pdf
09:38:31 <c_wraith> klrr_: Const doesn't really do anything at all, except ignore one of its type parameters.
09:38:52 <yepyep> I guess this is a more general purpose question not geared towards Haskell, but I curious what the FP crowd will have for a response.  Are there any functional programming alternatives to design patterns such as MVC, especially geared towards web stuff?
09:39:34 <klrr_> > fmap (+42) $ Const 0
09:39:36 <lambdabot>  No instance for (GHC.Show.Show (Control.Applicative.Const a0 b0))
09:39:36 <lambdabot>    arising from a use of ‘M637606653361544865625162.show_M6376066533615448656...
09:39:36 <lambdabot>  The type variable ‘a0’ is ambiguous
09:39:36 <lambdabot>  Note: there are several potential instances:
09:39:36 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
09:39:43 <yepyep> I just find MVC way overkill for a lot of stuff I'm doing, but I don't want to do inline variable interpolation a la PHP
09:39:53 <klrr_> > getConst  $ fmap (+42) $ Const 0
09:39:55 <lambdabot>  0
09:39:59 <klrr_> oh nice
09:40:03 <klrr_> c_wraith: thanks
09:40:34 <Yuu_chan> Has anyone used Bloodhound?
09:41:21 <klrr_> yepyep: i dont quite know what MVC is, and when this was released there was quite a lot of comments claiming it was not real MVC, but you might be interested in this http://www.haskellforall.com/2014/04/model-view-controller-haskell-style.html
09:41:24 <c_wraith> klrr_: the purpose of Const is that it can work with interfaces that are polymorphic over type variables with a Functor functor constraint to just carry a value through them.
09:41:45 <benzrf> klrr_: you can use it with van Laarhoven lenses to get a value!
09:41:54 <c_wraith> klrr_: or with an Applicative constraint, to just combine values monoidally
09:42:00 <Yuu_chan> I can't define the instance To/FromJson UTCTime which it does use.
09:42:02 <c_wraith> benzrf: that's where the discussion started. :)
09:42:08 <Yuu_chan> s/define/find
09:42:18 <klrr_> so it is so you should be able to make "(s -> a)" become "(s -> f a)" in larrhoven lenses?
09:42:33 <Fernandos> benzrf: creating "self-modifying code" to work with safe-guards when processing mutable input/data
09:42:46 <c_wraith> klrr_: no, it's about making (s -> f a) approximately (s -> s)
09:43:05 <klrr_> isnt get s -> a?
09:43:20 <klrr_> oh wait
09:43:20 <c_wraith> yes, but Const is set, not get
09:43:32 <klrr_> really? set is defined in terms of modify
09:43:34 <c_wraith> or rather, used in set
09:43:42 <klrr_> and get in terms of Const in the tutorial im reading
09:43:45 <benzrf> c_wraith: no, Const is used in get
09:43:49 <benzrf> c_wraith: const is used in set
09:43:55 <c_wraith> oh, do I have that backwards again?
09:43:58 <benzrf> c_wraith: yes
09:44:03 <klrr_> okey, thanks!
09:44:09 <c_wraith> klrr_: watch https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
09:44:19 <benzrf> Const is used as the functor in a von Laarhoven lens so that the fmap does not reapply the context
09:44:31 <benzrf> const is used as the mapped function in a modify to set the value
09:44:35 <benzrf> same as fmap const
09:44:47 <benzrf> *fmap (const x), i mean
09:45:28 <klrr_> yeah ive seen it but i dont quite like videos for some reason, i prefer switching back and forth between repl, editor and learning material and text works better for that so i use this tutorial http://twanvl.nl/blog/haskell/cps-functional-references
09:46:50 <Fernandos> gotta go home. cu later
09:47:55 <klrr_> also i like twnvl style for some reason, looks so un-boring while also being very readable
09:50:30 <fread2282> why isn't ifThenElse in Prelude?
09:50:58 <weihsiu> how do i use regex to match a recurring substring?  i am on a mac and i tried “abcabc” =~ “(.*)\1” :: (String, String, String, [String]) to no avail.  the result is ("ABCABC”,””,””,[]).
09:52:00 <awestroke> weihsiu: that regex works as intended. (.*) means "anything, 0 or more"
09:52:01 <Cale> weihsiu: Probably the right answer to this is "don't use regex"
09:52:06 <zomg> weihsiu: I'm not quite sure if you can actually do that with regex
09:52:14 <Clint> which regex?
09:52:18 <weihsiu> i tried it with Text.Regex (Posix, PCRE, TDFA).  they all return the same thing
09:52:45 <bennofs> fread2282: because nobody can agree on a name or the argument order? (if', bool, ifThenElse, whatever)
09:52:47 <awestroke> and you get the correct answer back
09:53:15 <weihsiu> “(.+)\1” does not help
09:53:18 <Cale> The language { ww | w in Σ*} is not a regular language for any alphabet Σ with more than 1 element.
09:53:28 <rwbarton> try \\1
09:53:28 <fread2282> bennofs: but RebindableSyntax uses ifThenElse :: Bool -> a -> a -> a
09:53:33 <awestroke> weihsiu: do you understand what "." matches?
09:53:36 <zomg> if you want to match an arbitrary repeating substring, you would probably need to use a parser and not regex
09:53:55 <zomg> how would the regex parser know when you want to stop matching and start matching substrings instead?
09:54:00 <zomg> err I mean repeats
09:54:12 <Maior> weihsiu: I am unfamiliar with haskell regex libs, but PCRE: /(.*?){2,}/
09:54:13 <weihsiu> rwbarton: same result
09:54:34 <Maior> you might not need the ? given that
09:54:35 <awestroke> weihsiu: do you even read the answers you get? jesus
09:54:50 <bennofs> fread2282: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Bool.html Data.Bool has bool :: a -> a -> Bool -> a since GHC 7.8
09:55:08 <zomg> Maior: interesting, that might actually work... but it could be pretty slow depending on the string length etc. :P
09:55:11 <Cale> With a proper parser combinator library, you could write something like  do x <- many anyChar; string x
09:55:16 <klrr_> what is 'b' in "Const a b" type in the function application  "r Const" in the definition of 'get' "get r = getConst . r Const" "get :: RefF a b -> a -> b
09:55:19 <klrr_> "
09:55:19 <Maior> zomg: I make no comments about efficiency ;)
09:55:34 <weihsiu> awestroke: yes, it matches any char
09:57:11 <klrr_> wait i think i kinda get it
09:57:50 <Cale> :t readP_to_S -- is this in scope?
09:57:51 <lambdabot> Not in scope: ‘readP_to_S’
09:58:08 <Cale> ghci> readP_to_S (do x <- many get; string x) "abcabc"
09:58:08 <Cale> [("","abcabc"),("abc","")]
09:58:13 <rwbarton> weihsiu: Prelude Text.Regex.PCRE> "abcabc" =~ "(.*)\\1" :: (String,String,String,[String])
09:58:14 <bennofs> @let import Text.Read
09:58:16 <lambdabot>  Defined.
09:58:17 <rwbarton> ("","abcabc","",["abc"])
09:58:19 <Cale> This is with Text.ParserCombinators.ReadP
09:58:41 <klrr_> i dont quite get how getConst can be applied to the RefF itself
09:58:50 <bennofs> @let import Text.ParserCombinators.ReadP
09:58:52 <lambdabot>  Defined.
09:59:03 <n-dolio> Cale: Most parser combinator libraries are not proper, I take it?
09:59:06 <Cale> You can see there are two possible parses there: it can match the empty string, leaving "abcabc" as the remaining input, or it can match "abc" and leave nothing remaining
09:59:13 <Cale> n-dolio: hm? :)
09:59:13 <bennofs> klrr_: what's the type of r?
09:59:26 <rwbarton> weihsiu: it also works with Text.Regex.Posix
09:59:35 <klrr_> bennofs: its a "(a -> f a) -> (b -> f b)"
09:59:45 <klrr_> is that equaliant to Const a b somehow?
09:59:48 <Cale> ghci> readP_to_S (do x <- many get; string x; eof; return x) "abcabc"
09:59:49 <Cale> [("abc","")]
10:00:01 <Cale> ^^ we can also insist on finding the end of input like that
10:00:05 <n-dolio> Cale: Your code will not work in most of the libraries designed for speed, if I'm not mistaken.
10:00:15 <bennofs> klrr_: ok, so now: r Const :: b -> Const x b  -- we don't know what x is yet
10:00:50 <bennofs> oh, we already know that x must be a, sorry
10:00:51 <n-dolio> Or, not just speed. Non-exponential resource usage.
10:00:53 <klrr_> is b == (b -> f b)?
10:01:31 <weihsiu> rwbarton: so what result are you getting?  i want to verify if its a bug on mac
10:01:36 <klrr_> i dont get how the second f can become Const automatically with Rank2Types
10:01:38 <bennofs> @let _example f (a,b) = fmap (,b) $ f a
10:01:40 <lambdabot>  Defined.
10:01:45 <bennofs> :t _example
10:01:47 <lambdabot> Functor f => (t -> f a) -> (t, t1) -> f (a, t1)
10:01:50 <klrr_> does rank2types work like rank1types if not required?
10:02:03 <rwbarton> weihsiu: I showed it on the next line, ("","abcabc","",["abc"])
10:02:06 <bennofs> klrr_: note that the 'forall' scopes over the whole definition
10:02:07 <Cale> n-dolio: hm, I suppose in Parsec, you'd have to be more cautious
10:02:15 <rwbarton> weihsiu: I am not on a mac, so it could be I suppose...
10:02:27 <bennofs> klrr_: it's not (forall f. a -> f a) -> b -> f b, but it is forall f. (a -> f a) -> b -> f b
10:02:30 <klrr_> bennofs: well, i mean forall is not really needed in *this* particular case?
10:02:48 <klrr_> so f can be inferenced to the first f in this case?
10:02:53 <klrr_> infered*
10:03:06 <n-dolio> Cale: I think you'd need to write a many that tried at each step for Parsec, for instance.
10:03:14 <Cale> yeah
10:03:39 <bennofs> klrr_: I think the forall is needed because you're defining a type synonym.
10:03:42 <bennofs> klarh: yes, it can
10:04:09 <klrr_> sry for logging in and logging out, problem with router
10:04:11 <weihsiu> rwbarton: are you on linux?  i am on a mac
10:04:17 <bennofs> klrr_: I think the forall is needed because you're defining a type synonym.
10:04:19 <bennofs> klrr_: it's not (forall f. a -> f a) -> b -> f b, but it is forall f. (a -> f a) -> b -> f b
10:04:32 <rwbarton> weihsiu: yes, I am
10:04:35 <bennofs> klrr_: and yes, the f is the same in both cases
10:04:37 * hackagebot probable 0.1.0.0 - Easy and reasonably efficient probabilistic programming and random generation  http://hackage.haskell.org/package/probable-0.1.0.0 (AlpMestanogullari)
10:04:38 <klrr_> yes but i thought forall is if you want different f's, here they're the same right?
10:04:41 <klrr_> ok
10:05:06 <weihsiu> rwbarton: ok, thanks.  i know what the problem is.
10:05:35 <bennofs> klrr_: the forall introduces the type variable f
10:05:46 <rwbarton> weihsiu: just to make sure, did you try copy-pasting my input?
10:05:48 <bennofs> @let type Example = a -- this doesn't work, because a is not in scope
10:05:49 <lambdabot>  .L.hs:152:16: Not in scope: type variable ‘a’
10:06:15 <bennofs> @let type Example = forall a. a -> a -- this works, because we used 'forall' to introduce the type variable
10:06:17 <lambdabot>  Defined.
10:07:47 <kazagistar> bennofs: well, that explination worked for me, I finally think I get forall...
10:07:48 <weihsiu> rwbarton: ha, it works with PCRE but not Posix on my mac
10:08:13 <StoneCypher> ah, irregular expressions
10:08:30 <klrr_> ok, so (not quite) (a -> f a) -> (b -> f b) becomes (a -> Const a b) -> (b -> Const a b) then later it becomes (b -> a)
10:08:45 <weihsiu> StoneCypher: indeed
10:08:59 <bennofs> klrr_: yes
10:09:11 <klrr_> awesome, thanks for the walktrough!
10:09:28 <rwbarton> weihsiu: I see that backreferences aren't a standard feature of POSIX extended regular expressions
10:09:38 * hackagebot refcount 0.1.1 - Container with element counts  http://hackage.haskell.org/package/refcount-0.1.1 (BenFoppa)
10:09:40 * hackagebot nonce 1.0 - Generate cryptographic nonces.  http://hackage.haskell.org/package/nonce-1.0 (FelipeLessa)
10:09:46 <kazagistar> what is the difference between (type Example = forall a . a -> a) (type Example a = a -> a) and where would the former be used over the latter?
10:11:27 <rwbarton> oddly enough POSIX basic regular expressions do support backreferences
10:11:45 <bennofs> kazagistar: a function of type Example has to work for all types a. For example, (+1) :: Int -> Int would not be of type Example, because it only works for one specific a, which is Int
10:12:26 <bennofs> kazagistar: however, (+1) :: Int -> Int is of type Example Int (using the latter definition of Example).
10:13:20 <roa_> Hi. I need to access the nth element of a Set (on ghc 7.6). Is there any way of doing this?
10:13:21 <weihsiu> rwbarton: Posix works on linux though, right?
10:14:00 <rwbarton> weihsiu: yes, it seems that the linux implementation supports backreferences even though it's not part of the standard
10:14:20 <rwbarton> http://stackoverflow.com/questions/13322996/do-extended-regexes-support-back-references
10:14:28 <rwbarton> has some good information
10:15:52 <rwbarton> kazagistar: let's rename your second Example to Example2 (type Example2 a = a -> a)
10:16:20 <kazagistar> rwbarton: sure, no problem
10:16:34 <rwbarton> the type declarations "f :: Example", "g :: Example2 a" are equivalent because free variables in type declarations are implicitly universally quantified
10:17:26 <pavonia> roa_: What do you want to do? Sets are usually unordered
10:17:42 <rwbarton> but in most other situations, "Example" and "Example2 a" will be inequivalent
10:18:06 <rwbarton> "f :: Example -> a", "g :: Example2 a -> a", "h :: Example2 a -> b" -- these are all inequivalent
10:18:34 <ReinH> roa_: sets do not have an "nth" element so you probably want a different data structure.
10:18:34 <roa_> pavonia: i have a set of graph edges and i need to select a random one. sets are implemented using some sort of binary tree based on the ordering of the elements so you can think of them as ordered (as far as the implementation goes).
10:18:42 <kazagistar> rwbarton: I didnt see any foralls there at all...
10:18:56 <rwbarton> kazagistar: if we expand the type synonyms then we have
10:19:02 <kazagistar> rwbarton: oh, I see, sorry nvm
10:19:16 <rwbarton> f :: (forall a0. a0 -> a0) -> a -- this is higher rank polymorphism; I renamed the inner a for clarity
10:19:22 <roa_> pavonia: the ghc-7.8 Data.Set has a elemAt method. I thought that more people had this issue before and found an easy fix.
10:19:26 <rwbarton> g :: (a -> a) -> a -- just an ordinary type (e.g. type of fix)
10:19:32 <rwbarton> h :: (a -> a) -> b -- a different ordinary type
10:22:39 <kazagistar> so on a somewhat related subject why does Endo have to be a newtype wrapper? is there some other way of creating a (a -> a) monoid, like for Sum/Product or Any/All?
10:23:07 <ReinH> kazagistar: Those are all newtype wrappers
10:23:53 <ReinH> So it is a exactly like Sum/Product/Any/All
10:23:56 <kazagistar> ReinH: right, but for the Sum/Product, they exist to disambiguate between two possible Monoid definitions
10:24:12 <ReinH> kazagistar: And for Endo it exists to make it possible to define a monoid
10:24:15 <ReinH> a -> b does not form a monoid
10:24:29 <ReinH> You need to be able to restrict the type to endomorphisms, a -> a
10:24:37 <simon> kazagistar, why it has to be a newtype wrapper, I suppose: otherwise you'd need to use TypeSynonymInstances.
10:25:29 <kazagistar> simon: ah, I see, thanks... lemme look into that extention
10:26:27 <ReinH> You could use TypeSynonymInstances for any of those
10:26:59 <simon> that extension scares me a little.
10:27:22 <rwbarton> If it scares you, then you don't understand what it does
10:27:24 <kazagistar> ReinH: Um, how would the compiler know if you wanted to sum or product?
10:27:26 <rwbarton> which many people don't
10:27:40 <rwbarton> (or, you are scared that other people won't understand what it does)
10:27:47 <ReinH> kazagistar: because you'd use the Sum or Product type synonym?
10:28:29 <ReinH> The problem is that you need FlexibleInstances or UndecidableInstances
10:29:05 <rwbarton> no, it just wouldn't work at all
10:29:17 <rwbarton> defining an instance for a type synonym is exactly the same as defining an instance for the expansion of the synonym
10:29:27 <rwbarton> (assuming it's permitted by enabling TypeSynonymInstances)
10:29:42 <simon> rwbarton, it scares me because it looks too much like typecasting to me.
10:29:45 <kazagistar> ReinH: are type synonyms mutually exclusive like that? Just because you have a String -> String function does not mean it can chose between using a [Char] or String function...
10:29:52 <ReinH> rwbarton: Ah right
10:30:22 <simon> rwbarton, sorry, type coercion
10:30:50 <rwbarton> simon: the point is the thing you are scared of doesn't actually happen
10:30:57 <rwbarton> if it did, then it would indeed be scary
10:32:02 <simon> rwbarton, I don't know what I'm saying now. it reminds me that my program does something unexpected because of missing type annotations.
10:32:11 <simon> s/does/might do/
10:32:34 <rwbarton> if you have x :: Int and you had a type synonym type Sum a = a then you could write x :: Sum Int, but it would never select a different instance than you would get without the annotation
10:32:39 <rwbarton> because Int and Sum Int are the same type
10:34:41 * hackagebot directory-layout 0.7.0.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.0.0 (MatveyAksenov)
10:34:49 <simon> isn't TypeSynonymInstances what allows me to declare typeclass instances over type synonyms rather than their origin type? then 'show (x :: Int)' and 'show (x :: Foo)' might give different results when type Foo = Int?
10:35:02 <rwbarton> first sentence, yes
10:35:04 <rwbarton> second sentence, no
10:35:27 <rwbarton> you can define an instance Show Foo, but it means exactly the same thing as if you wrote instance Show Int
10:35:45 <rwbarton> if you try to define both instances then you have conflicting instances
10:35:50 <simon> oh!
10:37:18 <roa_> In case anyone needs an ordered indexable set you can (probably) use Data.IxSet
10:39:38 <rwbarton> roa_: you could write the function you want with Data.Set with the right asymptotics using 'splitRoot' (pretty new I think) and 'size'
10:39:42 * hackagebot haskoin 0.0.2 - Implementation of the Bitcoin protocol.  http://hackage.haskell.org/package/haskoin-0.0.2 (PhilippeLaprade)
10:40:02 <ReinH> rwbarton: It exists in 7.8, just not 7.6
10:40:41 <KatZilla> guys, how to enable in ghci -XScopedTypeVariables
10:40:44 <KatZilla> onfly i mean
10:40:50 <kazagistar> with the typeinstance version of Endo, code like this (foldr f z t = appEndo (foldMap (Endo . f) t) z) could be code like this (foldr f z t = foldMap f t z) right?
10:41:33 <glguy_> KatZilla: use :set to add flags like that
10:47:54 <rwbarton> kazagistar: in a hypothetical (and impossible) world like that, yes
10:48:32 <rwbarton> kazagistar: see http://www.reddit.com/r/haskell/comments/26dshj/why_doesnt_haskell_allow_type_aliases_in_the/ for the most recent discussion of this subject
10:50:17 <ReinH> There are nice ways of dealing with newtype wrappers
10:50:18 <ReinH> > ala Endo foldMap [(+1),(+2)] $ 0
10:50:21 <lambdabot>  3
10:50:42 <glguy_> > ala Endo foldMap [(+1),(+2)] 0
10:50:43 <lambdabot>  3
10:51:11 <cschneid> :t ala
10:51:13 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:51:31 <glguy_> > foldBy (.) id [(+1),(+2)] 0
10:51:33 <lambdabot>  3
10:52:04 <cschneid> > ala Sum mconcat [1,2,3,4]
10:52:06 <lambdabot>  Couldn't match type ‘[[t0] -> Data.Monoid.Sum b1]’
10:52:06 <lambdabot>                with ‘Control.Lens.Wrapped.Unwrapped (Data.Monoid.Sum b)
10:52:06 <lambdabot>                      -> Data.Monoid.Sum b’
10:52:06 <lambdabot>  Expected type: (Control.Lens.Wrapped.Unwrapped (Data.Monoid.Sum b)
10:52:06 <lambdabot>                  -> Data.Monoid.Sum b)
10:52:45 <glguy_> > ala Sum (\f -> mconcat . fmap f) [1,2,3,4]
10:52:47 <lambdabot>  10
10:53:50 <cschneid> why's the fmap required
10:54:21 <cschneid> or was it turning it into Sum [1,2,3,4] instead of [Sum 1, Sum 2...]
10:55:07 <glguy_> ?type ala
10:55:08 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:55:18 <glguy_> You need something that fits the type: ((Unwrapped t -> t) -> e -> s)
10:55:21 <glguy_> like traverse or foldMap
10:55:29 <rwbarton> roa_: wait; aren't these "Indexed" functions exactly what you're looking for? http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Set.html#g:8
10:55:46 <glguy_> ?type traverse
10:55:47 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:55:48 <glguy_> ?type foldMap
10:55:49 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
10:56:16 <cschneid> so instead of mconcat, foldMap would do it?
10:56:21 <cschneid> > ala Sum foldMap [1,2,3]
10:56:23 <lambdabot>  6
10:56:40 <cschneid> and foldMap is logically the same as your (mconcat . fmap)?
10:57:17 <glguy_> yeah
10:58:59 <rwbarton> roa_: (oh, those are new in 7.8 also)
10:59:43 <cschneid> > ala Sum traverse [1,2,3]
10:59:45 <lambdabot>  Could not deduce (Control.Applicative.Applicative Data.Monoid.Sum)
10:59:45 <lambdabot>    arising from a use of ‘Data.Traversable.traverse’
10:59:45 <lambdabot>  from the context (GHC.Num.Num b)
10:59:45 <lambdabot>    bound by the inferred type of
10:59:45 <lambdabot>             it :: GHC.Num.Num b =>
11:00:05 <cschneid> was mostly just curious what traverse could do to that. Apparently nothing :) which makes sense
11:00:14 <benzrf> :t ala
11:00:15 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
11:00:22 <benzrf> swag
11:00:47 <benzrf> [no ide awhat that does -.-]
11:01:00 <bennofs> > ala Sum foldMap [1,2,3]
11:01:02 <lambdabot>  6
11:01:16 <bennofs> > sumOf traverse [1,2,3]
11:01:19 <lambdabot>  6
11:02:07 <bennofs> > ala Sum (views traverse) [1,2,3] -- so many ways to do it :)
11:02:10 <lambdabot>  6
11:03:08 <KatZilla>  > pl \x y -> x y
11:03:18 <KatZilla> > pl \x y -> x y
11:03:19 <lambdabot>  <hint>:1:4: parse error on input ‘\’
11:03:22 <Iceland_jack> @pl \x y -> x y
11:03:23 <lambdabot> id
11:03:33 <KatZilla> thx)
11:03:53 <KatZilla> @pl \entities -> M.fromList $ map (\x -> (entity2Id x, x)) entities
11:03:53 <lambdabot> M.fromList . map ((,) =<< entity2Id)
11:07:11 <fragamus> http://lpaste.net/104713
11:07:28 <fragamus> why does cmath have problems installing
11:08:51 <rwbarton> unsafePerformIO is no longer exported from ... something
11:08:54 <rwbarton> Foreign.IO I think
11:09:46 * hackagebot text 1.1.1.3 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.1.3 (BryanOSullivan)
11:11:26 <shapr> Does Johan Tibell still visit #haskell ?
11:11:43 <johnw> shapr: from time to time
11:12:10 <shapr> I'll email him if I get sufficiently motivated.
11:12:15 <fragamus> rwbarton: what would I do about it
11:12:33 <shapr> I'm having fun with Johan Tibbel's cassava library :-)
11:13:11 <geekosaur> fragamus: http://hackage.haskell.org/package/base/docs/Foreign-Marshal-Unsafe.html#v:unsafeLocalState
11:13:17 <tommd> shapr: If it's a library _issue_ then consider the github issue tracker - Johan is rather attentive.
11:13:32 <zebr> hi all. does anyone know if there's a name for the transformation, (let f = (let g = s in t) in ... f ...) -> (let f = (\g -> t) in ... f s ...) ?
11:13:50 <klrr_> whay are lenses so difficult to undestand...
11:13:53 <zebr> that is, pulling a let out of the top of a function and making it parametric instead.
11:14:24 <shapr> tommd: Nah, it's more a suggested use kind of question, thus its low importance.
11:15:05 <johnw> zebr: I'm not sure if that form of term rewriting has a specific name
11:16:36 <zebr> johnw: hm, okay. i might have to give it a name then. :p
11:16:40 <fragamus> I am completely baffled
11:16:51 <johnw> "let lifting" :)
11:17:07 <fragamus> what do I need to do do get cmath working
11:17:18 <rwbarton> fragamus, well, either use an old GHC or edit it
11:17:48 <fragamus> I'm using The Glorious Glasgow Haskell Compilation System, version 7.8.2
11:17:56 <fragamus> It was a bitch to install
11:18:00 <albeit> If I'm constructing a datatype with Foo <$> f <*> f <*> f ... with >3 fs (so liftAN wont work), is there a way to automatically use enough fs, based on the number of fields in the data record?
11:18:07 <geekosaur> I suppose this is some "never change the ecosystem" argument
11:18:18 <geekosaur> that use of unsafePerformIO went away with haskell2010
11:19:47 * hackagebot quandl-api 0.2.0.0 - Quandl.com API library  http://hackage.haskell.org/package/quandl-api-0.2.0.0 (PeterVanDenBrand)
11:19:49 * hackagebot haskoin 0.0.2.1 - Implementation of the Bitcoin protocol.  http://hackage.haskell.org/package/haskoin-0.0.2.1 (PhilippeLaprade)
11:21:52 <rwbarton> it is annoying that these minor changes to make GHC adhere more closely to various specs trickle out gradually
11:22:50 <rwbarton> so that it seems like every new GHC version has one
11:23:50 <fragamus> Donald Stewart's email address no workie:
11:23:51 <fragamus> https://hackage.haskell.org/package/cmath
11:24:13 <fragamus> freeking out
11:24:57 <fragamus> I can't go back to an older GHC because I had to upgrade to get something working (my hashable instance)
11:25:06 <fragamus> I think I'm screwed
11:25:36 <rwbarton> what do you need cmath for?
11:25:49 <fragamus> cbrt
11:26:09 <rwbarton> you could just FFI import it
11:26:12 <Welkin> cuberoot?
11:26:35 <Welkin> just take a power of 1/3
11:27:28 <johnw> albeit: you'd need to use generics and template haskell to do that
11:27:29 <fragamus> hmmm Welkin why didn't I think of that
11:27:35 <johnw> more work than it's worth, imho
11:27:53 <Welkin> look for the simplest solution
11:27:59 <johnw> but the whole "generate calls based on the data type" is something I've done before; @mgsloan showed me the trick
11:28:04 <fragamus> I shall try it
11:28:17 <kini> cabal-install is failing to install tf-random-0.5 for me (on ghc 7.8.2) -- can anyone replicate?
11:28:19 <johnw> egads, how did that twitterism creep into my fingers...
11:28:40 <kini> I get a linker error saying "cannot find -lHSrandom-1.0.1.1-ghc7.8.2"
11:29:02 <Welkin> johnw, #lambdabotknowsbest #totallyfunctionaltuesday
11:29:34 <Welkin> I mean
11:29:37 <Welkin> @johnw
11:29:37 <lambdabot> Not enough privileges
11:30:11 <rwbarton> johnw is a restricted operation
11:30:32 <shapr> ha
11:30:35 <johnw> hmm :)
11:30:53 * shapr swears at @hackage strptime
11:31:18 <shapr> I should probably be swearing at the glibc for not handling in strptime %z
11:33:12 <kini> hmm, never mind. `cabal --reinstall install random` did the trick. Weird.
11:42:16 <klrr_> can someone help me understanding lenses? http://lpaste.net/104717 im trying to evaluate each step of "get fstF (1, 2)" but im not sure how to evaluate
11:44:07 <fizruk> klrr_: error in: getConst . fmap (\a' -> (a', b)) (Const a) $ (1, 2)
11:44:24 <fizruk> where does a in Const a come from?
11:44:37 <bennofs> klrr_: getConst . fstF Const $ (1,2) is getConst . fmap (\a' -> (a', b)) $ Const (1,2)
11:44:54 <bennofs> klrr_: Const is a_to_fa
11:44:59 <sshine> klrr_, did you read https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial ?
11:45:02 <klrr_> fizruk: from "fstF Const"
11:45:53 <klrr_> bennofs: yes
11:45:54 <Tjr> What's the state of the art regarding parallel programming? Popular, hard, academics-only?
11:46:16 <klrr_> im using Const as a_to_fa in the code?
11:46:22 <klrr_> looks like that to me o.o
11:46:24 <Tjr> Is haskell the right tool for parallel programming?
11:46:51 <pjdelport> "depends what you're doing"?
11:46:58 <bennofs> klrr_: you should make a lambda then
11:47:24 <bennofs> klrr_: like: getConst . (\a -> fmap (\a' -> (a', b)) (Const a)) $ (1, 2) -- note the lambda to get a
11:47:25 <KatZilla> @pl \entity -> dbKey2String $ Db.entityKey entity
11:47:25 <lambdabot> dbKey2String . Db.entityKey
11:47:28 <klrr_> bennofs: i dont understand :/ i thought Const was (a -> f a)
11:47:37 <Tjr> I'm just asking in general, as in: is it worth it exploring parallel programming.
11:47:50 <klrr_> hmm
11:47:53 <bennofs> klrr_: then you can apply that lambda and get what I said earlier
11:47:55 <klrr_> bennofs: thanks, gonna use that
11:48:00 <KatZilla> @pl \a -> WS.json $ DataJson $ PaginatorJson a $ length a
11:48:00 <lambdabot> WS.json . DataJson . ap PaginatorJson length
11:48:08 <pjdelport> Tjr: Haskell certainly has fine support for it.
11:48:47 <Tjr> pjdelport: What would be a good starting point, both as in technical tutorials and which problem domains merit it?
11:48:49 <KatZilla> @pl \sx -> WS.json $ DataJson $ PaginatorJson a $ length sx
11:48:50 <lambdabot> WS.json . DataJson . PaginatorJson a . length
11:49:08 <KatZilla> @pl \sx -> WS.json $ DataJson $ PaginatorJson sx $ length sx
11:49:09 <lambdabot> WS.json . DataJson . ap PaginatorJson length
11:49:30 <pjdelport> Tjr: As I hinted earlier, it probably depends a very great deal on what you're doing: parallel/concurrent programming is a very wide field.
11:50:03 <yyyyy> Tjr: there's a quite good and readable book by Simon Marlow available online.
11:50:08 <pjdelport> Tjr: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html has a taste
11:50:43 <KatZilla> @pl \a -> WS.json $ DataJson a
11:50:43 <lambdabot> WS.json . DataJson
11:51:14 <pjdelport> Tjr: You can read Simon Marlow's book here: http://chimera.labs.oreilly.com/books/1230000000929/index.html
11:51:21 <klrr_> bennofs: im still doing something wrong :/ http://lpaste.net/104717
11:52:17 <klrr_> bennofs: nvm, i saw the mistake, thanks for all help!
11:53:08 <bennofs> klrr_: yeah, you need to pattern match in the lambda. sorry, I overlooked that :D
11:53:44 <warpy> pjdelport: do hackage libraries use all the par stuff?
11:53:48 <Tjr> pjdelport, yyyyy thank you, that's exactly the kind of answer I was looking for.
11:54:01 <warpy> does real work haskell code use it? i dont see it anywhere
11:54:29 <pjdelport> warpy: Depends on the library, probably.
11:56:06 <KatZilla> u
11:57:06 * Tjr is interested in the details.
11:57:52 <warpy> i am reading simon's book now. it is pretty interesting
11:58:17 <warpy> Tjr: what are you building in haskell? if you dont mind telling
11:58:44 <Tjr> I started learning haskell for real last weekend.
12:00:19 <Tjr> So far, my first pet project will be a "package" that turns "take a random number and do things" into "generate the underlying probability distribution". Then I'd like to use it to compute some things related to the roguelike game NetHack.
12:00:32 <Tjr> This parallel stuff is just thinking long term.
12:00:51 <warpy> great
12:00:54 <pjdelport> Tjr: I'm no expert, but there's probably three kinds of parallelism/concurrency you want to know about: first is simply parallel evaluation of an otherwise normal program, a la par-based evaluation strategies; second is actual concurrent programming, involving explicit threads and communication; third is data-parallel programming, which involves operating on
12:00:54 <pjdelport> large data structures geared for parallel processing.
12:01:19 <warpy> the book explains all three
12:01:32 <Tjr> Yes, I'm loosely aware of that.
12:01:46 <pjdelport> Oh, and (Software Transactional Memory) too, which is another approach to concurrency.
12:02:02 <Welkin> does anyone know if there is any NLP activity in haskell?
12:02:13 <Tjr> I've heard parallel programming is hard to get right, but necessary in the future because of the limitations of Moore's law. Both points are appealing :-)
12:02:17 <pjdelport> (There was supposed to be an "STM" in there.)
12:02:25 <klrr_> Welkin: what's that?
12:02:31 <Welkin> natural language processing
12:02:36 <StoneCypher> Tjr: what you are asking is "are cars the right answer for transit?"  the question is too vague to be meaningful, and people will just throw large piles of random, disconnected options at you.
12:02:42 <pjdelport> Tjr: There's not necessarily a right or wrong; just many approaches, depending on what's appropriate for the problem. :)
12:02:44 <klrr_> okey
12:03:15 <carter> Welkin: some, but we also get away with SIN because we have great parsing tools + lens
12:03:25 <klrr_> Tjr: probably already mentioned but in case not: simon marlow have a book on the subject, i only read the concurrency part so cant comment on the parrallel stuff but its supposed to be great :)
12:03:50 <Welkin> so are there any toolkits I could use?
12:04:06 <Welkin> particularly for chinese
12:04:27 <Tjr> Yes, I've got it loaded. Hopefully, I'll be asking better questions when I've read a bit of it.
12:04:31 <savanni> openssl x509 -purpose -in apps.savannidgerinel.com.2014-06.crt
12:04:31 <savanni> Certificate purposes:
12:04:31 <savanni> SSL client : Yes
12:04:31 <savanni> SSL client CA : No
12:04:31 <savanni> SSL server : No
12:04:33 <savanni> SSL server CA : No
12:04:36 <savanni> Netscape SSL server : No
12:04:38 <savanni> Netscape SSL server CA : No
12:04:41 <savanni> S/MIME signing : No
12:04:43 <savanni> S/MIME signing CA : No
12:04:44 <warpy> Welkin: there is this book, dunno how good it is http://nlpwp.org/book/
12:04:46 <savanni> S/MIME encryption : No
12:04:48 <savanni> S/MIME encryption CA : No
12:04:51 <savanni> CRL signing : No
12:04:52 <klrr_> spam
12:04:53 <savanni> CRL signing CA : No
12:04:56 <savanni> Any Purpose : Yes
12:04:58 <savanni> Any Purpose CA : Yes
12:05:01 <savanni> OCSP helper : Yes
12:05:03 <savanni> OCSP helper CA : No
12:05:06 <savanni> Time Stamp signing : No
12:05:06 <warpy> uh, no flood control here?
12:05:07 --- mode: ChanServ set +o geekosaur
12:05:08 <savanni> Time Stamp signing CA : No
12:05:11 <savanni> err
12:05:13 --- kick: savanni was kicked by geekosaur (savanni)
12:05:18 <Welkin> warpy, that looks like a good resource. Thanks
12:05:30 <geekosaur> hm, guess I did that just as they finished
12:05:50 --- mode: geekosaur set -o geekosaur
12:06:13 <warpy> Welkin: also http://hackage.haskell.org/packages/#cat:Natural Language Processing
12:06:34 <Welkin> I'm aware that stanford has a NLP toolkit for chinese and arabic (written in java) but it was hacked together over many years
12:06:43 <Welkin> and it is in java...
12:06:43 <warpy> Welkin: and this http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics
12:09:52 <Welkin> warpy, haskellwiki seems to have many gems
12:10:14 <carter> Welkin: theres some HMM stufff, but not really quite enough probability tooling for a probabilistic parser suite for haskell as yet
12:10:40 <warpy> what is a probabilistic parser?
12:11:54 <Tjr> if probability tooling is missing, my first learning project might be actually useful.
12:12:39 <joelteon> given a value of type SomeException, is there any way to figure out what specific type of exception it is without providing the compiler with type information?
12:13:00 <Welkin> Tjr, what is your project?
12:14:10 <Tjr> Welkin: So far, my first pet project was intended to become a "package" that turns "take a random number and do things" into "generate the underlying probability distribution".  I have a usage scenario for that in mind, but I'm not insisting on it. I'd rather do something that people actually use.
12:14:49 <Tjr> That said, I'm a newbie to haskell.
12:14:56 * hackagebot highlighting-kate 0.5.8.2 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.2 (JohnMacFarlane)
12:15:03 <rwbarton> joelteon: you can pattern match the SomeException constructor and then use the Typeable instance
12:15:16 <rwbarton> (Typeable being a superclass of Exception)
12:15:21 <joelteon> oooh, can I
12:15:23 <joelteon> that's exciting
12:16:08 <joelteon> thanks rwbarton, that's what I needed
12:16:35 <Tjr> Welkin: this is one of the probability distributions I intend to model: http://nethackwiki.com/wiki/Rnz#Mathematical_analysis
12:17:30 <carter> Tjr: thats actually super tricky problem
12:17:32 <mmachenry> Tjr: I missed most of the conversation but Simon Marlow's book is amazing.
12:17:40 <carter> like the stuff PHDs are made off
12:17:49 <carter> @google venture probabilistic programming
12:17:49 <mmachenry> Tjr: The conversation from before about concurrent/parallel programming.
12:17:50 <lambdabot> http://probcomp.csail.mit.edu/venture/
12:17:50 <lambdabot> Title: Venture -- an interactive, Turing-complete probabilistic programming platform.
12:17:56 <carter> is one example
12:17:59 <carter> theres some others too
12:18:45 <warpy> @run case toException UserInterrupt of SomeException e -> typeOf e
12:18:47 <lambdabot>  SomeAsyncException
12:18:58 <warpy> joelteon: ^
12:19:20 <Tjr> oooh, neat. They have done much, much more than I was ever dreaming to start.
12:19:36 <joelteon> also, does anyone know if there's a good xml-producing library like blaze-html?
12:19:58 <warpy> blaze-xml?
12:20:00 <Welkin> it's always helpful to find and read theses before starting
12:20:03 <orzo> xml-conduit
12:20:16 <joelteon> oh, blaze-markup might do it
12:20:26 <joelteon> orzo, xml-conduit renders a list of Events, which is from xml-types and isn't a good way to build XML
12:20:34 <joelteon> warpy: that doesn't exist, blaze-markup might be the name for it
12:24:14 <warpy> hackage needs a rating system for libraries
12:24:36 <joelteon> indeed
12:24:41 <warpy> it is really difficult to find good libraries among those hundred of things
12:24:44 <johnw> hi joelteon!
12:24:49 <joelteon> hello
12:25:58 <pavonia> warpy: http://packdeps.haskellers.com/reverse can be a hint
12:28:29 <Sawny> How can does this function work `numbers1 = 1 : map (+1) numbers1`. I get that it generates a list with all numbers from 1 to infinity. But it never do `: []`
12:28:34 <warpy> cpan has ratings, pypi doesnt
12:28:50 <Iceland_jack> Sawny: there is no “end” []
12:29:09 <Iceland_jack> You can also do
12:29:09 <Iceland_jack>     let ones = 1 : ones
12:29:12 <Iceland_jack> > let ones = 1 : ones
12:29:14 <lambdabot>  not an expression: ‘let ones = 1 : ones’
12:29:17 <Iceland_jack> > let ones = 1 : ones in ones
12:29:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:29:42 <warpy> does that crash lambdabot
12:29:48 <bennofs> no
12:29:49 <Iceland_jack> no
12:29:55 <absence> is there a library function that abstracts away the explicit loop in go x = do x' <- f x; go x'?
12:29:59 <bennofs> > let ones = 1 : ones in ones -- doesn't crash
12:30:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:30:32 <ReinH> :t forever
12:30:33 <lambdabot> Monad m => m a -> m b
12:30:35 <bennofs> :t iterateM
12:30:37 <lambdabot>     Not in scope: ‘iterateM’
12:30:37 <lambdabot>     Perhaps you meant one of these:
12:30:37 <lambdabot>       ‘iterate’ (imported from Data.List),
12:31:03 <bennofs> absence: http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html#v:iterateM_
12:31:07 <Sawny> But how can haskell know that it's a list?
12:31:16 <Sawny> I mean I can't write 1:2:3
12:31:19 <ReinH> Probably something from monad-loops. oh. yep.
12:31:20 <Sawny> I need to write 1:2:3:[]
12:31:24 <roa_> rwbarton, thanks for pointing me to splitRoot :)
12:31:35 <johnw> Sawny: (:) identifies it as a list
12:31:35 <roa_> rwbarton, it's what i wanted.
12:31:39 <johnw> :t (:)
12:31:40 <lambdabot> a -> [a] -> [a]
12:31:51 <absence> bennofs: thanks!
12:32:17 <RyanGlScott> I'm trying to use "extra-lib-dirs: lib" in a .cabal file. When I do that, I get the error:
12:32:20 <RyanGlScott> hermit-bluetooth-0.1.0: library-dirs: lib is a relative path which makes no sense (as there is nothing for it to be relative to). You can make paths relative to the package database itself by using ${pkgroot}. (use --force to override)
12:32:27 <byorgey> Sawny: the reason you can't write 1:2:3  is that the types don't match, not because Haskell can't tell it's a list
12:32:30 <RyanGlScott> What is ${pkgroot}?
12:33:22 <mmachenry> Sawny: Your example, "numbers1 = 1 : map (+1)" doesn't type check.
12:33:22 <byorgey> RyanGlScott: ${pkgroot} is a special variable you can use in your path which corresponds to the top-level directory of your package
12:33:29 <ReinH> Sawny: you can write 1:2:3:xs when xs is a list. since this returns a list, you can write xs = 1:2:3:xs
12:34:06 <Iceland_jack> > let alt = 1:2:alt in alt
12:34:08 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
12:34:25 <RyanGlScott> When I try using "extra-lib-dirs: ${pkgroot}/lib", I get a different error:
12:34:31 <RyanGlScott> cabal.exe: hermit-bluetooth.cabal:43: unexpected span: "/lib"
12:35:12 <RyanGlScott> Is ${pkgroot} only supported on recent versions of cabal? I have version 16, I believe.
12:35:31 <Sawny> > let xs = 1:2:3:xs
12:35:32 <byorgey> RyanGlScott: https://github.com/haskell/cabal/issues/1317
12:35:33 <lambdabot>  not an expression: ‘let xs = 1:2:3:xs’
12:35:43 <Iceland_jack> > let xs = 1:2:3:xs in xs
12:35:46 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
12:36:24 <RyanGlScott> byorgey: Huh. Why does cabal recommend it if it's not functional? :P
12:36:52 <byorgey> RyanGlScott: if you read further, it seems the message is coming from ghc-pkg, not cabal
12:37:08 <ReinH> It might help to walk through how that expression is evaluated.
12:37:11 <byorgey> though clearly the situation is not ideal
12:37:36 <RyanGlScott> What's the alternative? Would I have to do some trickery with Setup.hs?
12:38:02 <byorgey> RyanGlScott: I don't know anything beyond what's in that ticket.  I just found it by googling your error message.
12:40:29 <Sawny> let fibs a b = a:b:fibs (a+b) (a+b+b) in fibs 0 1
12:40:33 <Sawny> > let fibs a b = a:b:fibs (a+b) (a+b+b) in fibs 1 2
12:40:35 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
12:40:38 <RyanGlScott> byorgey: Do you happen to know what hooks Setup.hs uses to determine extra-lib-dirs? I can find the directory pretty easily with Haskell.
12:40:38 <Sawny> YAY!
12:41:07 <vanila> > let fibs a b = a:fibs b (a+b) in fibs 1 2
12:41:09 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
12:41:29 <kalloc> hi
12:41:42 <kalloc> please, recomend me rest framework
12:42:24 <johnw> kalloc: to write rest servers, or rest clients?
12:42:52 <kalloc> servers
12:42:57 <kalloc> snap?
12:43:05 <johnw> that's a bit heavy for just doing a REST service
12:43:06 <carter> sure
12:43:10 <johnw> I'd say look at scotty first
12:43:25 <kalloc> thank you
12:43:29 <johnw> also, there is a new api-tools library from Well-Typed
12:43:41 <johnw> that can automate generation of the REST API from your data types
12:45:04 <carter> wat
12:45:06 <carter> linkey?
12:45:13 <carter> @google api-tools well typed
12:45:14 <lambdabot> https://hackage.haskell.org/package/api-tools
12:45:41 <kalloc> this is nice for me
12:45:47 <kalloc> i
12:45:52 <kalloc> i'm glad :D
12:45:52 <johnw> carter: it was presented at https://skillsmatter.com/meetups/6201-fun-and-profit-with-stongly-typed-data-schemas
12:47:09 <latro`a> is there a fast way to, given a connected graph, identify the connected components which are present after deletion of an edge?
12:47:47 <johnw> latro`a: is your graph is represented as an adjacency list?
12:47:57 <johnw> latro`a: if so, your information should be mostly already there, no?
12:48:10 <Cale> latro`a: Start from one of the vertices of the edge which was removed and search for a path to the other one
12:48:30 <kalloc> johnw: do you use api-tools?
12:48:34 <Cale> If there is such a path, the graph is still connected. If not, then it has two connected components, one for each endpoint.
12:48:39 <johnw> kalloc: I haven't yet used it, no
12:48:46 <latro`a> I know it has two, I want to compute what those two are
12:48:47 <warpy> fun and profit with haskell? what else do you need!
12:48:55 <kalloc> ))
12:48:57 <latro`a> (rather, I know that for my specific network, there will be two)
12:49:10 <Cale> latro`a: I don't believe there's any easier way than the usual way
12:49:23 <latro`a> my intuition is that there's a way to do this by updating spanning trees
12:49:43 <latro`a> because the edge that I am removing is the highest weight edge in the graph
12:52:03 <Forgetaboutit> Hey guys, imagine I had some arbitrary data types in a module.  Where would you create the lenses for them?  If I'd put them in the same module, I'd have to export them manually.  On the other hand, recreating them in each depending module also seems wasteful.  Do you have any thoughts on how to solve this?
12:52:24 <edwardk> if you use makeClassy you get one class that holds all the lenses HasFoo
12:52:36 <edwardk> then you can export HasFoo(..)
12:52:54 <latro`a> the reason I need this to be reasonably quick is that I need to do it recursively, building a tree of connected components which in the worst case will reach down to single nodes
12:53:03 <Forgetaboutit> edwardk: I haven't seen that, I will look into it - thank you!
12:53:57 <latro`a> johnw: I can interchange representations, but it begins as an adjacency list, yes
12:54:54 <michaelt> wow idrisbot has syntax highlighting
12:55:50 <AnalogFile> I'm 99% convinced that I do want to learn haskell :P
12:55:57 <philed> michaelt: What's idris?
12:56:04 <mmachenry> AnalogFile: It's worth it.
12:56:25 <michaelt> philed: a programming language with 'dependent types' and Haskell syntax.
12:56:47 <michaelt> or haskelly syntax. strict evaluation. various new-model bells and whistles.
12:56:49 <philed> michaelt: Scare-quotes?
12:57:06 <AnalogFile> yep. but it may be a chore. I'm 47, no formal training and, worse of all, I did some imperative programming (even if that was almost 20 years ago)
12:57:14 <michaelt> oh, no, it's really dependent types, philed
12:57:40 <orzo> probably most haskellers come from an imperitive background
12:57:43 <ajcoppa> AnalogFile: welcome. i'm not worried about anything you said, and you shouldn't be either
12:58:18 <edwardk> AnalogFile: i found haskell after a pretty long career of imperative programming. it took me months to fully switch gears, but I'll never look back and do not regret the transition.
12:58:31 <AnalogFile> I'm not. worried. Being old just gives a more literal meaning to "do it or die trying" lol
12:59:01 <edwardk> AnalogFile: average life expectancy is ~78 these days. You have a long career ahead of you. It isn't like we're going to be able to retire ;)
12:59:10 <ajcoppa> AnalogFile: bitemyapp (and others) put together a great guide to help people learn haskell here: https://github.com/bitemyapp/learnhaskell
12:59:31 <michaelt> philed: the usual thing to say to distinguish it from the 'average' dependently typed language, is that it is oriented to practical use.  Another interesting feature is a somewhat coq-like proof helper in the repl
12:59:57 <mmachenry> AnalogFile: I found something deeply irritating about imperative programming that I didn't realize what it was until I learned functional programming. I had the same feeling when I moved out of the suburbs and into the city :)
13:00:01 * hackagebot FixedPoint-simple 0.6 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.6 (ThomasDuBuisson)
13:00:31 <philed> michaelt: That's a distiction I'm interested in. I got the impression from Connor McBride that, even in Agda, you wanted to avoid the "green" as much as possible.
13:00:39 <johnw> AnalogFile: I only started learning functional programming, Haskell and mathematics at age 41
13:01:35 <johnw> I do wish my life hadn't been wasted on C, but it also created a profound appreciation of the differences
13:01:36 <AnalogFile> yea. thanks all for the warm wellcome.
13:01:38 <orzo> i played with idris a while ago, and the error messages were just not good enough to make it worth doing anything practical with
13:01:51 <johnw> orzo: Idris is like Haskell was a long while back
13:01:55 <michaelt> the error messages can be pretty deadly in idris, yes.
13:02:11 <freezerburnv> ajcoppa: Glad you pasted that link. I’ve been trying to work through the NICTA course, and definitely struggling. Good to see that there’s something I shoudl be doing BEFORE NICTA
13:02:29 <AnalogFile> I'm not super new. I read a lot of stuff. And actually tried some haskell in the past (like, for 2 weeks before having to do something else). Now I'm unemployed, so I guess I'll have the time.
13:03:00 <philed> michaelt: I think that in order to make this crazy powerful typing to work, we need a culture of programming where we allow core parts of our programs to be swapped, and so demand really strong types on the stuff that can be swapped in.
13:03:05 <mmachenry> AnalogFile: I assume you've found "Learn You a Haskell" ?
13:03:39 <johnw> AnalogFile: you've got to learn to appreciate that feeling of beating your head to a pulp against a brick wall to do even the simplest things.  That pain is what it feels like to unlearn what must be unlearned, and to burn new pathways into your brain. :)
13:04:00 <AnalogFile> yes. not read it all yet. and RWH too.
13:04:11 <ajcoppa> freezerburnv: yep, NICTA is pretty advanced IMO, or at least it teaches you things that are a little abstract if it's your intro
13:04:24 <philed> I'm pretty good with HOL Light, and I really love tactic systems. But I haven't really figured out in what sense Idris does tactics.
13:04:25 <ajcoppa> byorgey's CIS194 course is excellent
13:05:21 <AnalogFile> I'm doing a lot of reading of more advanced stuff. no math background, so it's taking me time. But I love it (the parts I do understand). I see Haskell as a good way to play with the math concepts in a programming setting.
13:05:43 <AnalogFile> As i liked programming and now I discovered I sort of like math, that fits.
13:05:45 <freezerburnv> ajcoppa: I definitely feel like I’m starting to understand some of the concepts of Haskell due to bashing my brains against the first couple of parts of it. Particularly getting through Functors, and parts of Applicative (though I still don’T know what the ((->) t) thing is)
13:06:17 <johnw> AnalogFile: yeah, I can actually read math papers for pleasure now, because of Haskell
13:06:39 <Tjr> latro`a: regarding your graph question ... Maybe it's a good idea to pick one root of your graph, and then annote every node with the minimal number of steps needed to get there from the root (and from which vertex that came). Your graph will break up in disconnected components only if the removed edge used to connect vertices whose annotation differed by one. The real question becomes: how to update the annotations with minimal work, i.e. how to r
13:06:40 <Tjr> as much of the bigger graph's annotations.
13:06:47 <AnalogFile> edwardk: your comonad reader site is an example of the advanced stuff I get only in part, but like. And sigfpe blog is another.
13:06:53 <freezerburnv> ajcoppa: It seems like a very well thought-out series of functions to implement that really stretch your brain to understanding Haskell, but I think my brain is just too crusty with imperative to get it, at least on my own, right now. Somethign a little more gentle is appreciated
13:07:09 <Iceland_jack> freezerburnv: would you like a quick explanation of ((->) r)?
13:07:14 <philed> freezerburnv: Think of (->) as a function, then ((->) t) is its partial application. It sends a type to a function type with domain t.
13:07:14 <Tjr> latro`a: ... (and from which vertiCES those came, allowing for several)
13:07:37 <philed> Like you got with ((+) 1).
13:07:39 <AnalogFile> ops, seems edward just left
13:07:41 <michaelt> philed: the tactic commands are explained in the tutorial http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf section 8.4 a little too briefly. I assume the system is comparatively primitive, but don't know much about coq, hol light etc.
13:08:40 <philed> michaelt: I've gone through it, and it does seem pretty primitive, but maybe that's just for the purposes of the tutorial. My understanding of tactics is really tied up in old-school LCF theorem proving, where they were this stupidly powerful combinator langugae.
13:08:49 <freezerburnv> philed: So it’s just a generalization of partila application, in a sense?
13:08:56 <freezerburnv> partial, even
13:09:09 <Iceland_jack> freezerburnv: It rather captures environments
13:09:12 <edwardk> my feeling is with idris that 1.) without laziness by default i can't write programs i want to write in it, 2.) what they call typeclasses aren't, they are implicits so i can't reason about them, hedge unions are out, the core trick we use in haskell of moving dictionaries to use sites is only really truly sound when we have coherence of instance resolution and 3.) the style of code i have to write doesn't refactor as well as
13:09:12 <edwardk>  Haskell. the first two are things that are theoretically fixable by moving to something near idris in the design space, the third is more of a complaint about how few things you can reuse and how much you have to rebuild every time in a dependently typed setting.
13:09:15 <AnalogFile> my current delusion is with the state of HP. I'm considering the very recent "self contained GHC for Mac"
13:10:42 <edwardk> AnalogFile: didn't leave, just a bit distracted, in and out in real life
13:10:46 <AnalogFile> but I have a couple of HPs already installed in the past. I'll have to dig some info and figure out any possible bad interactions
13:11:13 <philed> freezerburnv: Not a generalisation. It's just the same thing that you can pull off with partial application on values, such as with ((+) 3), but now it's going on at the type-level, and so instead of the value (+), you have the type-constructor (->).
13:11:17 <freezerburnv> Iceland_jack: I think I sorta get a bit of what ((->) t) is, but I feel like I need to see some code using it or something in order to get it
13:11:21 <AnalogFile> edwardk: oh. for some reason it did not highlight your name, which it generally means you left.
13:11:36 <Iceland_jack> freezerburnv: you mostly see it used for some choice functions
13:11:41 <Iceland_jack> like
13:11:41 <Iceland_jack>     join f x == f x x
13:11:54 <edwardk> johnw: the 'can read math for fun' part is a big boon
13:12:04 <johnw> it really is, I had no idea what I was missing
13:12:06 <michaelt> edwardk: I have to say, I do find idris's strictness 'impossible to reason about'
13:12:08 <Iceland_jack> > map (join replicate) [1..]
13:12:10 <lambdabot>  [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8,...
13:12:19 <AnalogFile> edwardk: did you manage to retrieve more of the articles you lost a few years ago (I'm talking of the recursion schemes series)?
13:12:33 <yyyyy> you can always use Lazy in idris
13:12:43 <Iceland_jack> > (fst<*>snd) (succ, 15)
13:12:44 <lambdabot>  16
13:12:53 * eikke__ wishes there'd be a jvm target for ghc
13:12:56 <michaelt> edwardk just printing a tree clearly involves: developing the giant tree, developing the string, feeding it to stdout.
13:13:02 <philed> edwardk: On things like hedge unions in Scala, is the problem that you can override an implicit so that you break (?) parametericity?
13:14:15 <michaelt> yyyyy: yes of course.  It just takes you by surprise this strictness.  I totally get bitten by it!
13:16:18 <ion> > [1..] >>= (replicate >>= id)
13:16:20 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
13:16:43 <freezerburnv> philed: Is there an example somewhere? Because I look at your explanation, then I look at how it’s used in NICTA (specifically: ((*) <*> (+2)) 3 == 15, where <*> has to be implemented), and I just get more confused. (no offense intended, Haskell confuses me a lot) Unless it’s something along the lines of: (+2) is partially applied to (*). Which I’m not sure what to make of that, exactly
13:17:50 <michaelt> edwardk: I also think I agree about refactoring, and so on.
13:18:19 <yyyyy> michaelt: i know what you mean. but unless you're dealing with codata, it surprises you in a good way i think.
13:18:49 <philed> yyyyy: I've done a lot of programming with laziness in Ocaml, and I found it mostly unpleasant with it not being the default. Too much explicit forcing, and too much thinking about when to explicitly force or not. I'd rather laziness was the default, just because I find myself writing far fewer functions.
13:19:29 <Rarrikins> > [1..] >>= replicate >>= id
13:19:30 <lambdabot>  Couldn't match type ‘[[b]]’ with ‘a0 -> [a0]’
13:19:31 <lambdabot>  Expected type: GHC.Types.Int -> [[b]]
13:19:31 <lambdabot>    Actual type: GHC.Types.Int -> a0 -> [a0]
13:20:05 * hackagebot list-fusion-probe 0.1.0.1 - testing list fusion for success  http://hackage.haskell.org/package/list-fusion-probe-0.1.0.1 (JoachimBreitner)
13:20:50 <michaelt> edwardk: I see the difference with type implementation of type-classes, but aren't there plenty of objections to the way we do it. I mean, in avoiding orphans and so on?  There needs to be a type class/instance registry
13:20:56 <yyyyy> philed: you could say the same about forcing NFs in parallel haskell code, so in the end it's probably just a matter of taste in the design choices.
13:21:05 <philed> freezerburnv: So there, you're applicative instance is functions which have the same input type. That's what ((->) a) means. The notation just means functions with input type a.
13:21:20 <yyyyy> (i'm not partial to any. i found both interesting)
13:21:25 <yyyyy> find*
13:22:37 <kalloc> 2nd question
13:22:52 <kalloc> what is the best solution for working with db?
13:22:54 <kalloc> haskelldb ?
13:23:01 <kalloc> persistant?
13:23:15 <kalloc> I use 2nd
13:23:26 <philed> yyyyy: Yeah, I need more experience on that front to compare headaches. :)
13:24:15 <freezerburnv> philed: Ooooh. So it really isn’t about partial application (in a sense?), but instead more about guaranteeing types? So it’s just saying that the functions have to have the same input type? I’m curious about the use of that, considering Haskell’s type system. (and how does that relate to choice functions, Iceland_jack?)
13:24:58 <johnw> kalloc: i definitely recommend persistent and then esqueleto
13:25:05 <albeit> Just looking into lenses, a little overwhelmed... all I want to do is concisely increment an Int record field that is part of a State. Any points on where to look?
13:26:02 <MitchellSalad> albeit: i think there's an operator called +=
13:26:07 <johnw> field += 1
13:26:22 <eikke__> (+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
13:26:33 <ReinH> > (1,2) &~ _1 += 1
13:26:35 <lambdabot>  (2,2)
13:26:50 <michaelt> > runState (do {_1 += 4; _2 *= 3} ) (1,2)
13:26:52 <lambdabot>  ((),(5,6))
13:27:14 <albeit> Awesome... looks simple enough, thanks
13:27:26 <MitchellSalad> :t (&~)
13:27:27 <lambdabot> s -> State s a -> s
13:27:46 <ReinH> It's flip evalState
13:28:00 <ReinH> or execState I can never remember which
13:28:01 <MitchellSalad> so it is :P
13:28:05 <ReinH> :t evalState
13:28:07 <lambdabot> State s a -> s -> a
13:28:07 <michaelt> it's pretty amazing, I just noticed it not long ago, &~
13:28:12 <MitchellSalad> exec
13:28:19 <ReinH> Yep
13:28:21 <MitchellSalad> why is it amazing? haha
13:28:22 <michaelt> you can do imperative style pure arithmetic.
13:29:43 <michaelt> It's not a miractly, just amusing in the presence of lenses
13:29:46 <philed> freezerburnv: It's partial application in the sense that you have this function on types called "->". You apply this function to two type arguments "a" and "b", and you get back the type of all functions from "a" to "b". In Haskell (unlike other wonderful languages such as Standard ML), you can partially apply this function on types, so that, for instance, "(->) Int" is a function that takes a type "a" and gives back the type "Int ->
13:29:46 <philed> a". So you can think of it as the type of functions with Int as the domain.
13:30:21 <michaelt> MitchellSalad: It's not a miracle, rather
13:31:34 <albeit> cabal gurus: Trying to install data-lens on 7.8, and getting this error http://lpaste.net/104722. Most relevant line I can find: "Could not find module: Control.Comonad with any suffix:["dyn_hi"] in the search path: ["dist/build"]". Any ideas?
13:31:44 <freezerburnv> philed: …ow. I think you broke a part of my brain. That’s a really good explanation, and I think I’m starting to understand it now
13:32:11 <Forgetaboutit> philed: This is the same with "(,) a" resulting in "b -> (a, b)", isn't it?
13:32:38 <philed> Forgetaboutit: Right.
13:33:23 <Forgetaboutit> philed: I recently discovered this in the Functor instance for (,), but only now I think I undestand why it's there.
13:34:38 <kini> More cabal errors... "Loading package text-1.1.1.3 ... <command line>: can't load .so/.DLL for: libHStext-1.1.1.3.so (libHStext-1.1.1.3.so: cannot open shared object file: No such file or directory)"
13:34:45 <kini> (while trying to install uniplate-1.6.12)
13:34:55 <Forgetaboutit> philed: I have, however, an unrelated question: what's the reason `fmap` only works on the second element of a tuple?
13:35:01 <kini> `cabal info text` tells me that text-1.1.1.3 is installed. Any idea what's going on?
13:35:33 <johnw> kini: are you on Mac?
13:35:38 <michaelt> kini: does ghc-pkg list text say anything
13:35:40 <kini> nope, ubuntu linux
13:35:45 <philed> Forgetaboutit: Unless the components were of the same type, it would have to pick one of the two regardless. I'm not sure why it picks the second. Maybe for the same reason that the functor instance of Either always works on Right.
13:36:09 <AnalogFile> Forgetaboutit: exactly because of the way the functor instance is defined.
13:36:21 <kini> michaelt: `ghc-pkg list text` gives two lines, namely /opt/ghc/7.8.2/lib/ghc-7.8.2/package.conf.d and $HOME/.ghc/x86_64-linux-7.8.2/package.conf.d
13:36:37 <rwbarton> kini: so ghc-pkg thinks text isn't installed
13:36:41 <michaelt> that should mean that it is not registered
13:36:45 <philed> Monopoly of right-handed people?
13:36:46 -ChanServ(ChanServ@services.)- ski removed Isabella18!*@* from the AKICK list.
13:36:46 --- mode: ChanServ set -b Isabella18!*@*
13:37:16 <kini> hmm. I tried `cabal --reinstall install text` but got a scary warning about a bunch of packages probably breaking
13:37:19 <Forgetaboutit> philed: Ah, I see.  AnalogFile: I'm asking myself why that is :D.
13:37:21 --- mode: ChanServ set -q *!*@67.221.255.97
13:37:23 <michaelt> kini: cabal info -- or am I wrong -- just tells you about the package as it is on hackage
13:37:51 <kini> michaelt: ah, I was referring to the line "Versions installed: 1.1.1.3" in the output of `cabal info text`
13:37:55 <AnalogFile> philed: yes. it is possible to define the functors to work on the other type. they will just be another functor (some types permit multiple functors, but haskell allows one only, unless you use a newtype to define another)
13:38:10 <AnalogFile> then the most obvious one is the "curried" one.
13:38:29 <michaelt> kini: hm something is wrong , does ghc-pkg check say anything horrible?
13:38:46 <kini> a bunch of warnings about haddock and html directories
13:38:50 <ski> AnalogFile : "some types permit multiple functors" ?
13:38:53 <kini> but that's it
13:39:24 <rwbarton> those warnings are normal enough
13:39:25 <michaelt> kini: hm. did you install a lot of packages with the package manager?
13:39:26 <philed> Forgetaboutit: Thing is, when you look at the state monad, it sends type a to a -> (a, s), and so that's kinda weird with the way that the monad for ((->) a) and ((,) b) are defined. Shouldn't it be a -> (s, a)
13:39:35 <michaelt> kini: yeah the haddock things are nothing
13:39:51 <kini> michaelt: you mean the system's package manager? no, in fact I only have ghc-7.8.2 installed in /opt and nothing else haskell-related from the package manager
13:39:58 <ski> philed ?
13:40:07 * hackagebot happstack-static-routing 0.4.0 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.4.0 (MagnusCarlsson)
13:40:16 <AnalogFile> Forgetaboutit: think it like currying. Think "(a,b)" as someting like "(,) a b". A type constructor taking two arguments. By a sort of currying "(,) a" is a type constructor taking just one argument.
13:40:39 <michaelt> kini, so maybe you should just unregister the stuff that is in local (registered in $HOME/.ghc/x86_64-linux-7.8.2/package.conf.d) and start over with cabal update?
13:40:42 <AnalogFile> which is what a functor needs to be
13:41:08 <michaelt> kini: that can be delicate if some of the stuff in global is from the system package manager.
13:41:12 <ski> folone : `\b -> (,) a b' can be eta-reduced to `(,) a' as AnalogFile says. `\a -> (,) a b' can't be eta-reduces, and so can't be (directly) expressed in Haskell
13:41:13 <philed> AnalogFile: I'm still playing around with doing functors and monads in Ocaml, and one thing I like in that world is that because of the module system, I get to pick my functors and monads, without having them tied uniquely to a type. I need to figure out whether wrapping things in Newtype in Haskell is more/less a pain in the arse than all the syntactic mess I have in Ocaml with applying Ocaml functors.
13:41:15 <ski> er
13:41:18 <ski> Forgetaboutit ^
13:41:18 <philed> ski: ski?
13:41:20 <michaelt> or the haskell platform on os x and windows
13:41:43 <Forgetaboutit> philed, AnalogFile: Thanks!  I think I get it :)
13:41:53 <ski> philed : wondering what you mean by "when you look at the state monad, it sends type a to a -> (a, s), ... Shouldn't it be a -> (s, a)"
13:42:10 <Forgetaboutit> ski: What does eta-reduction mean? Is it just omitting stuff on both sides?
13:42:29 <michaelt> Forgetaboutit: yes, basically
13:42:39 <ski> Forgetaboutit : eta-reduction is simpifying `\x -> (...) x' to `...', in case `...' doesn't mention `x' (freely)
13:42:40 <kini> michaelt: well, I deleted ~/.cabal and ~/.ghc a little earlier and tried to build everything from scratch (except ghc itself), and I got this text problem
13:42:42 <kini> I can try it again though
13:43:05 <philed> ski: Yeah, like somehow, State should be a composition of the
13:43:06 <philed>  ((->) a) and ((,) a) monads, and so the state component should be switched in that output pair.
13:43:07 <AnalogFile> ski: yes. this happens often. some types admit multiple valid innstances of a class. you can only define one, unless you use a newtype.
13:43:23 <ski> Forgetaboutit : sometimes one also (slightly incorrectly) uses this term for simpifying `f x = (...) x' to `f = ...' (still assuming `...' doesn't mention `x' freely)
13:43:44 <ski> AnalogFile : yes. however, i'm not sure this is the case for `Functor'. do you have an example ?
13:44:23 <albeit> Anyone know why cabal cant find "dyn_hi" in the search path when trying to install comonad?
13:44:27 <Forgetaboutit> ski: How does it compare to point-free style?
13:44:30 <ski> philed : yes, i agree, i was just wondering why you apparently had flipped around the traditional meanings of the variable names `a' and `s' here
13:44:37 <michaelt> certainly hlint thinks that "f xs = foldr (+) 0 xs" needs to be "eta-reduced"
13:44:41 <AnalogFile> Forgetaboutit: check out wikipedia for lambda calculus. eta reduction, beta reduction and alfa equivalence are explained quite well.
13:44:55 <ski> Forgetaboutit : eta-reduction is one step that goes toward making code more pointless
13:45:08 * hackagebot list-fusion-probe 0.1.0.2 - testing list fusion for success  http://hackage.haskell.org/package/list-fusion-probe-0.1.0.2 (JoachimBreitner)
13:45:16 <ski> (where "pointless" is just a synonym for "pointfree")
13:45:34 <vanila> what if you added a type level lambda to haskell?
13:45:38 <Forgetaboutit> AnalogFile: I will definitely check it our! ski: I figured that out already :)
13:45:54 <Forgetaboutit> s/our/out/
13:46:05 <ski> Forgetaboutit : strictly speaking, going from `f x = (...) x' to `f = ...' is function extensionality -- however, it's closely related to eta-equivalence
13:46:06 <edwardk> albeit: did you build with -j?
13:46:22 <kini> michaelt: fwiw I'm following this guide http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
13:46:24 <AnalogFile> ski: many parametric types with more than one type argument can be defined as functors on any of the arguments
13:46:25 <albeit> edwardk: Nope
13:46:32 <edwardk> albeit: no idea
13:46:36 <ski> AnalogFile : yes
13:47:21 <edwardk> albeit: maybe you built comonad without the dynamic stuff then built data-lens after changing your config?
13:47:55 <ski> AnalogFile : still, you then have to rewrite somewhat to be able to arrange the argument to be functorial in to be the last argument, so strictly speaking, we're talking about different types here
13:48:01 <albeit> edwardk: I've had dynamic enabled the entire time. Just tried to install lens, which broke when trying to install comonad...
13:48:27 <ski> AnalogFile : it sounded like you implied there was some type `F' which could (validly) be made a `Functor' in more than one way
13:48:34 <Forgetaboutit> edwardk: makeClassy is awesome!  Thanks for the hint!
13:48:43 <AnalogFile> ski: "(a,b)" or "a->b" or Either or in fact any Arrow and other similar stuff.
13:48:47 <albeit> One possible thing I found online is I may need to cabal-install 1.18, but I can't seem to get it with cabal update and then cabal install cabal-install. Just goe back to 1.16
13:48:54 <AnalogFile> ski: that's exactly why in Haskell you generally define the functor on the last argument as the main one, and eventually use a newtype if you need a functor on another argument
13:49:15 <edwardk> albeit: when you cabal install cabal-install you may want to check that your ~/.cabal/bin is first in your PATH
13:49:47 <ski> AnalogFile : no, not in the `a -> b' case
13:50:06 <albeit> edwardk: Ah I have my ghc 7.8 path as the first thing. I'll try throwing the cabal in front
13:50:23 <michaelt> albeit: it may be that cabal-install-1.18 needs to be explicitly specified.  or just install from the git repo ;)
13:50:25 * ski isn't sure what "you generally define the functor on the last argument as the main one" means
13:51:23 <ski> (nor for instances of `Arrow' .. both these and the `a -> b' case are contravariant in the first argument and covariant in the second. `Functor' only captures covariant functors (from `Hask' to `Hask'))
13:51:31 <michaelt> albeit: oh wait, the new version is 1.20
13:51:36 <AnalogFile> sky: in some sense the state monad is a functor of (,), with some extra tools to access and set the state. And it's defined on the first argument because that leaves us the normal functor of (,)
13:51:37 <albeit> michaelt: If I specify a cabal-install version, how can I make the cabal command use that specific version?
13:51:38 <kini> michaelt: failed again :(
13:51:57 <albeit> michaelt: Ah okay I'll try the newest version then
13:51:57 <rwbarton> 1.18 (or newer) is the version you need (mostly sure)
13:52:13 <michaelt> albeit: that is a question of $PATH. if you want more than one version there are the usual expedients
13:52:25 <kini> what I did: `cabal update ; cabal install cabal-install ; cabal install happy alex ; cabal install ghc-mod structured-haskell-mode stylish-haskell`
13:52:25 <AnalogFile> sky: why not in the a->b case?
13:52:29 <michaelt> I just realized I have 1.21, very advanced
13:52:34 <AnalogFile> I mean, ski
13:53:21 <albeit> michaelt: So presumable when I specify a 1.20 installation, it will overwrite preveious versions and I'll be defaulting to 1.20?
13:53:42 <AnalogFile> hmm, ski, you may have a point about functor needing to be convariant
13:54:27 <michaelt> albeit: if you installed cabal-install with your package manager it won't be overwritten, it will be in ~/.cabal/bin
13:55:08 <michaelt> albeit: so you will need to get rid of the old one or arrange for $HOME/.cabal/bin to precede opt/whatever in your bashrc or whatever
13:55:16 <vanila> what about making a newType From b a = From (a -> b)
13:55:24 <vanila> instance ContraFunctor From ?
13:55:47 <michaelt> albeit: which ghc are you using?
13:56:14 <albeit> michaelt: 7.8.2. Modifying path right now, I'll see if it works
13:56:32 <michaelt> albeit: ah okay, it should work
13:57:26 <ski> AnalogFile : i don't know what "is a functor of (,)" means, either :/
13:57:47 <albeit> michaelt: Well, cabal-install is now version 1.20, which is great. But lens/comonad is still failing to to find "dyn_hi" in the search path
13:58:24 <ski> AnalogFile : "why not in the a->b case?" -- because you can't any sensible define `fmap :: (a0 -> a1) -> ((a0 -> b) -> (a1 -> b))'
13:58:45 <ski> vanila : will work
13:59:38 <michaelt> albeit: are you building it in a sandbox?
14:00:06 <albeit> michaelt: No I've been hoping to keep everything global, but I should probably stop that
14:00:10 * hackagebot Ketchup 0.1.2 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.1.2 (Hamcha)
14:00:58 <michaelt> albeit: oh oh, yes, this is out of my depth. I think I recommend against it. You dont want e.g. to overwrite the libs you got with ghc, for example.
14:01:28 <albeit> michaelt: Recommend against global, recommend using sandboxes, ya?
14:02:01 <michaelt> I use local cabal and sandboxes; sandboxed for projects, ~/.cabal for random haskell stuff.
14:02:31 <michaelt> then everything can be readily unregistered or deleted
14:03:19 <michaelt> doing everything in sandboxes is a bit of a pain, e.g. I just tried comonad in one, and it built the text package for example
14:04:52 <michaelt> albeit: could it be that there is a config file for cabal somewhere other than in HOME/.cabal/config
14:05:07 <michaelt> albeit: I'm not sure how that works
14:05:11 * hackagebot hcwiid 0.0.5 - Library to interface with the wiimote  http://hackage.haskell.org/package/hcwiid-0.0.5 (IvanPerez)
14:06:24 <rwbarton> I think there is, .cabal-sandbox/config ?
14:07:18 <michaelt> rwbarton: right. it was that albeit was using --global that had me thinking. But I think it was a muddle. Certainly you can use a local one in a sandbox
14:07:33 <awestroke> :t liftM
14:07:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:07:36 <awestroke> :t fmap
14:07:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:08:01 <albeit> michaelt: Oh I may have misspoken, I wasn't using "--global" explicitly, I was just installing pacakges into the "global" / user-wide package database, not a local sandbox
14:08:18 <michaelt> rwbarton: I was wondering if there was one thing telling him to make dyn-hi nonsense and another not
14:08:31 <rwbarton> that sounds plausible
14:08:50 <michaelt> albeit: oh, sandboxes have given a new meaning to 'global' I guess.
14:08:54 <awestroke> what would be the drawback of defining liftM as     liftM = fmap    ?
14:09:01 <rwbarton> alternatively an aborted build might have left a .hi file but not a .dyn_hi file
14:09:31 <rwbarton> and maybe that has somehow survived
14:09:45 <albeit> Well installing everything in a sandbox, so I'll see if that fixes it all
14:09:58 <jhance> awestroke: Nothing really... in fact now I think we have a proper class hierarchy for monad/functor/applicative so you can use fmap for all of your monads
14:10:14 <joelteon> can someone explain why this doesn't compile? http://lpaste.net/104724
14:10:55 <albeit> Ah it worked in the sandbox, awesome. Thanks guys
14:10:55 <glguy_> joelteon: Did the compiler not give you any output or is this a quiz?
14:11:03 <michaelt> joelteon: because its a record?
14:11:07 <rwbarton> joelteon: which type should it pick for x
14:11:09 <joelteon> glguy_: there's no instance for "Show a0"
14:11:23 <joelteon> rwbarton: Show a => a
14:11:27 <glguy_> joelteon: because it's ambiguous?
14:11:41 <joelteon> but it should be showable
14:11:49 <rwbarton> you probably wanted an existential
14:12:00 <rwbarton> given the fact that you are confused about the error
14:12:34 <joelteon> ok
14:12:38 <joelteon> is that not an existential
14:12:43 <rwbarton> here x is a value that I can make have type a for *any* type a that is an instance of Show
14:13:00 <joelteon> ok
14:13:52 <rwbarton> data Foo = forall a. Show a => Foo { attr :: Maybe a } -- should be the syntax for an existential
14:14:14 <rwbarton> and you don't need RankNTypes then
14:14:17 <michaelt> yes I see it will be trouble constructing the first case Just x ->  ...
14:14:31 <glguy_> joelteon: and you won't be able to use the record selector
14:14:35 <rwbarton> yes
14:14:40 <rwbarton> (to what glguy_ said)
14:14:52 <schell> is there a netwire Wire that collects all previously unique values in a list?
14:16:25 <michaelt> Oh, I see joelton intended the existential. I missed that
14:16:46 <vise890> hi all! quick question. is there a CLI library (or bunch of libraries) similar to python's click [ http://click.pocoo.org/ ] or ruby's thor [ https://github.com/erikhuda/thor ]
14:18:20 <glguy_> vise890: http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Console-GetOpt.html This module will do the argument parsing and usage info generation
14:19:08 <glguy_> (all I know about Click is glancing at the page you linked to, so if you're looking for more than that, I don't know)
14:19:27 <michaelt> vise890: are you looking for argument parsing or some deeper form of interaction
14:19:47 <vise890> it may be enough, arg parsing and help generation are the main thing
14:20:13 <albeit> @hoogle (+=)
14:20:15 <lambdabot> No results found
14:20:57 <vise890> glguy_: thanks, much appreciated
14:20:58 <michaelt> vise890: there are a number of competing libraries, in addition to the base module glguy_ mentioned, e.g. optparse-applicative cmdargs etc
14:21:08 <Forgetaboutit> vise890: there's an article on the wiki about CLI parsing: http://www.haskell.org/haskellwiki/Command_line_option_parsers
14:21:13 <michaelt> vise890: and my favorite, the tawdry ReadArgs
14:24:02 <michaelt> ah nice, ReadArgs is mentioned on the wiki-page, and excoriated for using OverlappingInstances
14:24:09 <vise890> is it fair to say that getopt is the most used or it's a question of what you like most?
14:25:08 <michaelt> vise890: http://packdeps.haskellers.com/reverse says cmdargs is more used, but optparse-applicative is used a lot.
14:25:12 <joelteon> ok, I need more type related help. I've included the compiler error this time. http://lpaste.net/104728
14:25:37 <glguy_> More used than the "base" package?
14:25:53 <michaelt> glguy_: oh, i meant to have a clause taking that for granted
14:26:08 <arlenik> could someone please explain this code to me:  http://lpaste.net/104729
14:26:23 <joelteon> it seems like GHC is complaining that Nothing doesn't inhabit forall a. Show a => Maybe a
14:26:32 <joelteon> but I must be misunderstanding
14:26:32 <vise890> michaelt: /reverse is cool
14:27:55 <michaelt> vise890: here's a little tutorial for one of them http://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html
14:27:56 <vise890> all right, thanks guys.
14:28:00 <rwbarton> joelteon: it is another ambiguity issue
14:28:21 <joelteon> can you elaborate?
14:28:31 <rwbarton> you need to pick a type like mkFoo = Foo (Nothing :: Maybe Int)
14:28:38 <vise890> i'm off to write my world domination CLI app now
14:28:40 <vise890> :P
14:28:41 <joelteon> okay
14:28:52 <rwbarton> alternatively, maybe you really wanted an existential inside the Maybe
14:29:02 <k00mi> arlenik: if we look at f, it takes each value of the first list, then, for each of those, it takes each value of the second list (that's what the list monad does), and conses the element of the first to the element of the second
14:29:04 <joelteon> well, that still makes me curious
14:29:13 <rwbarton> i.e. get rid of Maybe in the definition of Foo, and then use Maybe Foo
14:29:35 <glguy_> joelteon: Are you just playing around with existential quantification and universal quantification? Are you trying to do something in particular?
14:29:51 <joelteon> glguy_: what I'm trying to do is expose an API to users where they can optionally attach some metadata to a configuration
14:30:15 <joelteon> so in this case it would be any metadata you can Show
14:30:35 <k00mi> arlenik: so binding in the list monad basically means, "for each element of this list, do what comes next, then concat the results back together"
14:30:56 <k00mi> arlenik: which is exactly what the concatMap function does, if you're familiar with that
14:31:28 <glguy_> joelteon: If all you can do with something is turn it into a string, it's probably simpler to store the String
14:32:31 <joelteon> well, i want them to be able to provide different types of web requests
14:32:39 <joelteon> this is for an airbrake reporter
14:32:49 <michaelt> arlenik: it's the same as the list comprehension f a b = [x:xs | x <- a , xs <- b]
14:32:53 <joelteon> and for web requests you need to be able to fetch metadata like url, env variables, etc.
14:32:59 <joelteon> so it's not as simple as just Show
14:33:15 <joelteon> and I don't want to force the user to extract all those little bits from their request datatype
14:33:35 <michaelt> arlenik: it says, 'pick a thing from a, then pick a thing from b, prefix the one to the other, and go on like that through all the possibilities'
14:36:16 <McManiaC> how do i get cabal/haddock to link to file:// urls so i can use the generated doc files on my webserver?
14:36:45 <McManiaC> i have rewrite rules, so the full path wouldnt be an issue, i just have to somehow avoid the file:// part
14:36:55 <arlenik> ok, got it, thanks k00mi and michaelt
14:43:19 <albeit> Are lenses slow? Would the equivalent (but more verbose) non-lens code by noticeably faster than lens code?
14:44:50 <zomg> At least in my limited experience they don't seem to have much of an impact
14:45:17 <zomg> Maybe there's a difference in some very performance critical case, but at least for me they haven't ever had much of an impact
14:45:55 <edwardk> lens code using concrete lenses and concrete types should desugar to the same thing
14:46:07 <albeit> Great, thanks
14:46:12 <edwardk> gotta run
14:47:51 <enthropy> McManiaC: I suggest using https://github.com/feuerbach/standalone-haddock instead
14:48:04 <enthropy> it makes the links all relative
14:48:31 <benzrf> >User bloat: the unspoken problem facing the linux community
14:48:34 <benzrf> oops
14:58:07 <hiptobecubic> benzrf, That's a stretch. Some of us *like* having working drivers and native apps.
14:58:41 <benzrf> hiptobecubic: no, it was a comment on this image http://i.imgur.com/4xThP.jpg
14:58:46 <benzrf> ugh wrong img
14:58:55 <benzrf> http://i.imgur.com/xoevXXf.jpg this one
14:59:56 <hiptobecubic> :D
15:00:03 <monochrom> I prefer cowsay
15:00:12 <Eelis> what do they serve at this symposium? seems unhealthy
15:00:24 <monochrom> http://www.vex.net/~trebla/tmp/moo-nad.txt
15:01:59 <Iceland_jack> a moonad is just a moonoid in the cowtegory of...
15:02:06 <monochrom> hehe
15:02:33 <monochrom> lactofunctors? :)
15:02:50 <Iceland_jack> bovine functors
15:03:04 <benzrf> btw
15:03:19 <benzrf> applicatives seem more monoidal to me?
15:03:26 <benzrf> you have 2 values & a binary op
15:03:40 <benzrf> whereas join is an op on a nested value
15:03:48 <benzrf> is this a more mathy sense of monoid
15:04:18 <Iceland_jack> benzrf: Applicatives could just as well be defined by
15:04:19 <Iceland_jack>     unit ∶ A ()
15:04:19 <Iceland_jack>     mult ∶ A a → A b → A (a, b)
15:04:25 <benzrf> precisely
15:05:17 * hackagebot HUnit-Plus 0.3.3 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.3 (emc2)
15:08:43 <awestroke> Iceland_jack: how could that define applicatives? that just looks a multiplicative monoid.. how could mult :: Applicative m => m a -> m b -> m (a, b)  ever be used to define <*> ?
15:09:05 <Iceland_jack> awestroke: first try to define 'pure'
15:09:38 <Iceland_jack> the other case needs a bit of thinking
15:09:59 <awestroke> oh
15:10:18 * hackagebot Ketchup 0.2.0 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.2.0 (Hamcha)
15:10:18 <awestroke> cool
15:10:31 <shachaf> There is a Functor superclass.
15:10:52 <Iceland_jack> yes, that's crucial
15:11:44 <McManiaC> enthropy: i get the error
15:11:44 <McManiaC> standalone-haddock: protobuf: canonicalizePath: does not exist (No such file or directory)
15:12:07 <McManiaC> enthropy: http://npaste.de/p/AGWv/
15:12:11 <McManiaC> anything wrong?
15:13:27 <tobyp> hello all / bitemyapp, going through the Yorgey course and wondering about a ghci warning https://gist.github.com/toby/a0bb20282066f1976ac0 (warning in comment)
15:13:37 <tobyp> I would think I'm matching against that pattern
15:14:03 <johnw> it doesn't know that your equations are exhaustive at runtime
15:14:23 <johnw> instead of the second equation, try using "otherwise"
15:15:11 <tobyp> you rule :)
15:15:18 * hackagebot unification-fd 0.8.1 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.8.1 (WrenThornton)
15:15:29 <Feuerbach_> McManiaC: protobuf must be an existing directory, not just a package name
15:15:32 <Feuerbach_> see the readme
15:16:16 <shachaf> > magic_value <= 5
15:16:17 <lambdabot>  False
15:16:18 <shachaf> > magic_value > 5
15:16:20 <lambdabot>  False
15:16:44 <Iceland_jack> > isNaN magic_value
15:16:45 <lambdabot>  True
15:16:47 <Iceland_jack> b00m
15:17:15 <Iceland_jack> I actually played a game with a friend of mine yesterday through lambdabot
15:17:33 <Iceland_jack> I made a Haskell function that only revealed a secret on a single input
15:18:02 <McManiaC> Feuerbach_: oh :)
15:18:54 <awestroke> > magic_value == magic_value
15:18:56 <lambdabot>  False
15:19:16 <Iceland_jack> > let magic_value = 0.0/0.0 in magic_value == magic_value
15:19:18 <lambdabot>  False
15:20:56 <awestroke> a == b
15:20:58 <awestroke> > a == b
15:21:00 <lambdabot>  False
15:21:11 <awestroke> > a == a
15:21:13 <lambdabot>  True
15:21:16 <Rarrikins> > a + 5
15:21:17 <lambdabot>  a + 5
15:21:37 <pavonia> > a + 5 - a
15:21:39 <lambdabot>  a + 5 - a
15:21:47 <sipa> > a - a
15:21:49 <lambdabot>  a - a
15:21:52 <Rarrikins> > (a + 5)*a == a*a + 5*a
15:21:54 <lambdabot>  False
15:21:58 <Rarrikins> Lies.
15:22:26 <Rarrikins> > (a + 5)*a
15:22:28 <lambdabot>  (a + 5) * a
15:22:49 <pavonia> Seems to be symbolic only
15:22:58 <awestroke> :t a
15:22:59 <lambdabot> Expr
15:23:31 <haasn> The Eq instance should be removed
15:24:40 <Rarrikins> > a < b
15:24:41 <lambdabot>  True
15:25:18 <Rarrikins> > a^a
15:25:19 * hackagebot HCodecs 0.4.2 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.4.2 (GeorgeGiorgidze)
15:25:23 <lambdabot>  mueval-core: Time limit exceeded
15:25:44 <awestroke> haasn: it's nice when doing something like
15:25:45 <awestroke> > filter (/=c) [a,b,c,d,e,f]
15:25:47 <lambdabot>  [a,b,d,e,f]
15:26:03 <Rarrikins> I wish they'd defined things like (^) as typeclass functions with defaults instead of standalone.
15:26:18 <sipa> :t (^)
15:26:19 <lambdabot> (Num a, Integral b) => a -> b -> a
15:26:39 <Rarrikins> gcd too is messed up
15:26:44 <Rarrikins> > gcd a b
15:26:48 <lambdabot>  mueval-core: Time limit exceeded
15:27:23 <Rarrikins> Hmm
15:28:02 <savanni> So, I just noted that transformers-4.0 has an ExceptT that looks *suspiciously* like EitherT from the errors package.  Was that added specifically to deprecate the errors package?
15:29:47 <Feuerbach_> savanni: to be more precise, to deprecate the either and EitherT packages
15:30:36 <Feuerbach_> the errors package contains lots of utility functions for error handling
15:31:05 <solidus-river> hey all, i'm having trouble wrapping my head around comonads
15:31:13 <solidus-river> is it safe to think of them in a way like
15:31:58 <solidus-river> if a monad is an operation with a context that can be combined with like contexts as a monoid
15:32:19 <solidus-river> then a comonad is a function that takes a set of monadic contexts and constructs a function based on them?
15:32:47 <savanni> Feuerbach_: am I going to be writing code that will inspire hatred of me if I publish new code that uses EitherT instead of switching to ExceptT?
15:34:08 <Feuerbach_> savanni: that's unlikely
15:43:25 <fizruk> solidus-river: just think of them as coburritos ;)
15:45:25 <latro`a_> with monads, you care about what a -> m b is, and about why you want a -> m b to become m a -> m b
15:46:04 <latro`a_> for example, with Maybe, a -> m b are functions that can fail, and the m a -> m b that you get from >>= keeps track of whether you've already failed
15:46:20 <latro`a_> with comonads, you care about what m a -> b is, and about why you want m a -> b to become m a -> m b
15:47:09 <solidus-river> latro`a_: so would they be usefull for heuristic based branching on accumulators?
15:47:16 <latro`a_> for example, with Store, m a -> b plays with one entry, namely the one at the cursor, and the m a -> m b that you get from =>> plays with the whole thing instead
15:47:57 <latro`a_> I'm not sure, I'm not an expert :)
15:48:14 <fizruk> solidus-river: what is “heuristic based branching on accumulators”?
15:48:32 <solidus-river> fizruk: example i'm thinking of is an A* algorithm or some sort
15:49:06 <solidus-river> where you could have a bunch of monads piling up each representing an accumulation of one aspect of state you care about
15:49:22 <solidus-river> then you havea  comonad that takes a state and decides where to branch based on existing state
15:49:53 <solidus-river> which eventually would break out of the monadic context if all paths converged
15:52:08 <fizruk> I would write some code first, say a prototype
15:52:13 <fizruk> and then stare at the code
15:52:38 <fizruk> and try to think if there’s something comonadic about it
15:53:11 <fizruk> or even ask someone else if I don’t see a thing
15:53:33 <latro`a_> my first question to you would be: are there any m a -> b that mean anything?
15:53:40 <latro`a_> if not, then you don't have a useful comonad
15:53:50 <fizruk> solidus-river: that is, I don’t immediately see how comonads could be useful here
15:54:05 <acowley> m a -> b doesn't sound like a promising type on its own
15:54:22 <c_wraith> acowley: well, can you write functions that unify with m a -> b that do something
15:54:35 <acowley> "something" yes
15:54:44 <c_wraith> something useful.  :)
15:54:59 <fizruk> it could be difficult to spot `(w a -> b) -> (w a -> w b)` in the code I think
15:55:22 <fizruk> it could be simpler to identify (w a -> b) part first :)
15:55:31 <c_wraith> fizruk: in my experience, it is.  I wrote code that did exactly that and didn't realize it was extend until someone else pointed it out to me.
15:55:49 <c_wraith> fizruk: in my defense, it was for [], which isn't actually a comonad!
15:55:50 <latro`a_> Store seems to be the canonical example: an m a -> b is basically an a -> b that gets applied to the cursor value
15:55:59 <solidus-river> fizruk: well, m a -> b would signify a convergence of an aspect of the heuristic
15:56:18 <solidus-river> but i mean this is all theoretical, i'm not writing this, i'm just trying to wrap my head about comonads
15:56:37 <solidus-river> i think this has helped a bit, i should go read the laws in Control.Monad.Comonad tonight
15:57:23 <solidus-river> i'll look up store tonight too then :)
15:57:30 <latro`a_> Store is the dual of State
15:57:56 <latro`a_> (I mention this because it might be easier to find that way)
16:00:04 <fizruk> c_wraith: I once detected comonad, but it was not interesting - just renamed some func to extend
16:00:25 <c_wraith> fizruk: with any specific comonad, that's all you can do.
16:00:28 <solidus-river> how doe people feel about the ST monad, i know its wrapped / isolated through runST and the thread reference, but is it considered bad to use
16:00:57 <solidus-river> i guess my main question about haskell now is how do you think about runtime performance in it
16:01:01 <c_wraith> fizruk: until you start writing code that's polymorphic over comonads, the abstraction is just using a pre-existing function instead of writing your own.
16:01:43 <solidus-river> and how does ST work on a lower level, does it reinitialize memory for every runST or does it initialize a section of memory thats available for that type of runST
16:01:55 <acowley> Are there many pre-existing functions over arbitrary comonads anywhere?
16:02:04 <fizruk> solidus-river: i don’t reason about performance until it hurts :p
16:02:29 <solidus-river> fizruk: but if you know its going to be a priority that could make it hurt a lot more
16:02:30 <c_wraith> solidus-river: neither.  ST and IO are the same.
16:02:45 <solidus-river> i thought ST initialized mutable state memory
16:02:51 <latro`a_> so does IO
16:03:04 <c_wraith> solidus-river: ST works exactly the same as IO.  Creating an IORef is the same as creating an STRef.  Creating an STArray is the same as creating an IOArray
16:03:25 <solidus-river> interesting, so in the lens library, where they alwasy have an ST context going for the records
16:03:37 <solidus-river> is the whole record in that context wrapped in an IO throughout the program
16:03:42 <solidus-river> or does the context come and go as it's used
16:04:02 <c_wraith> ST works the same as IO, but it doesn't have the same properties as far as types go.
16:04:53 <solidus-river> and then my last question for the day, is how do functional reactive libraries stay performant on input changes / what mechanism of haskell do they use to signal a change in an input
16:05:15 <solidus-river> is there a way you can listen to an IORef similarly to how you'd listen to a bus?
16:05:24 * hackagebot Ketchup 0.2.1 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.2.1 (Hamcha)
16:05:34 <solidus-river> and then trigger a functoin on a signal through the bus?
16:08:28 <porrifolius> Hi.  Anyone have ghc-mod working with cabal sandboxes?  I'm trying it out but can't get any type recognition or info results.
16:11:10 <dwcook> solidus-river: not familiar with buses, but it sounds like you might want MVar. Those you get to block on until a value's available.
16:11:26 <dwcook> An MVar is basically a queue of length at most one.
16:13:16 <solidus-river> dwcook, i'm about to make the commute home for the night, but that sounds close, guessing its a mutex, i'm wondering whta technique reactive banana uses to trigger the "on signal change" function part where you associate a continues input with descreet sampling events over time
16:13:58 <solidus-river> there must be something in haskell that lets you effeciently poll an input for change for them to do that without a big performance hit
16:14:21 <dreams> Anyone got Hat to work? I've been trying for the past three days.
16:14:30 <copumpkin> the debugger?
16:15:05 <dreams> copumpkin: yes
16:15:20 <copumpkin> haven't heard anyone mention that in years
16:15:24 <dreams> copumpkin: Not exactly a debugger, a tracer.
16:15:25 <copumpkin> doubt it'll work without lots of work
16:15:27 <copumpkin> yeah
16:15:47 <geekosaur> hat was kinda specific to ancient ghc versions
16:16:00 <geekosaur> hood is a newer one, and I think there are still newer things around?
16:18:44 <dwcook> solidus-river: my stance is "Why poll when you could split off a thread and block?"
16:19:17 <dreams> geekosaur: well cabal install hat-2.7.0.12 compiles but then there are run-time errors when I run the tool. Annoying. I actually fixed one of the errors by modifying Hat' source code but then another error showed up.
16:19:57 <heatsink> Can someone help me understand this type class error? http://lpaste.net/104732
16:20:21 <stapler> hello
16:20:23 <heatsink> I think it's possible to deduce the goal from the constraint using the instance on line 23.
16:21:19 <dwcook> heatsink: ts from useList's signature does not scope to isNil's signature.
16:22:39 <dwcook> heatsink: by which I mean, you're referring to different variables named ts on lines 35 and 37.
16:22:39 <geekosaur> dreams: yes, exactly. hat works by instrumenting haskell code, this means among other things that it parses ghc's interface files (.hi) which change with every ghc version and back then there was no way to dump them or work with them in a version-portable way
16:23:21 <heatsink> dwcook: Where is the quantifier for the `ts' on line 37?
16:23:26 <dwcook> heatsink: I might also add you have an empty forall on line 37.
16:23:32 <dwcook> heatsink: it's implicit.
16:23:56 <heatsink> dwcook: An empty forall prevents implicit quantification at that point
16:24:08 <dwcook> heatsink: my mistake. I was unfamiliar with that. I don't know then.
16:24:38 <heatsink> okay
16:25:10 <dwcook> heatsink: could you point to a source on that, by the way? It seems odd to me.
16:25:22 <dwcook> It seems to me like an empty forall should just be a no-op.
16:25:27 * hackagebot Win32-errors 0.2.1 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2.1 (MichaelSteele)
16:28:55 <dwcook> Hmm, I believe it now. I just tried it in ghci. Interesting.
16:29:50 <dreams> geekosaur: It seems to me that there are many things that changes with every GHC version. And this way Haskell tools keep breaking. Well I'm new to Haskell so I'm not very sure.
16:30:59 <geekosaur> hat is a special case because it's messing with compiler internals. there have been tools that worked that way for other languages, and like hat they were abandoned as unmaintainable
16:31:05 <geekosaur> I pointed you to hood for a reason
16:32:29 <heatsink> I can't find a source describing that behavior.
16:32:41 <geekosaur> (The C version was called ctrace, and I think the last anyone saw of it was on Ultrix)
16:32:43 <dreams> geekosaur: I'm stuck with Hat. Hood is not an option but thanks for the suggestions.
16:33:10 <geekosaur> (it only worked with some pcc versions)
16:35:11 <Kazagistar> I am trying to write (for learning purposes) a Ix i => (list of list of list of... a) -> [(i, a)], and am getting stuck and looking for tips http://lpaste.net/104733
16:36:52 <heatsink> It looks okay so far
16:37:19 <heatsink> Oh
16:37:27 <heatsink> ([] t) is [t]
16:37:44 <Iceland_jack> :k []
16:37:45 <lambdabot> * -> *
16:37:50 <Iceland_jack> :k forall t. [] t
16:37:51 <heatsink> You want (\a. [t a]), but you can't make type-level lambdas
16:37:51 <lambdabot> *
16:38:15 <Kazagistar> heatsink: yes
16:39:15 <Kazagistar> there has to be a way to get around this, right? lenses do something vaugely like this afaik (though I am a total noob in that area)
16:40:32 <rwbarton> hmm? can't you do this just like you have laid it out so far
16:41:04 <rwbarton> oh I see what you did
16:41:58 <rwbarton> maybe "class Ix i => Indexable s a i where indexed :: s -> [(i,a)]", "instance Indexable [a] a Int" etc.
16:42:13 <akurilin> Quick question: if I have a 2 part cabal project, one being the library and the other one an executable exercising the library, is it safe to assume that the executable part of the build shouldn't rebuild the library a 2nd time, right?
16:42:29 <Kazagistar> rwbarton: I am running into kind level problems, haha
16:42:36 <rwbarton> just simplify your problem
16:42:58 <glguy_> akurilin: you'll need to make sure that the library and executable use separate src dirs
16:43:11 <glguy_> so that the library modules don't appear in the executable's source directory
16:43:17 <glguy_> and then yes, you only compile the library once
16:43:42 <akurilin> glguy_: aaah shoot, no wonder yesod was doing that, I just ignored it
16:44:09 <akurilin> I always have to get creative, don't I? :)
16:45:30 * hackagebot Win32-junction-point 0.2 - Support for manipulating NTFS junction points.  http://hackage.haskell.org/package/Win32-junction-point-0.2 (MichaelSteele)
16:45:39 <Kazagistar> sorry, my client freaked out, did anyone suggest something while it was being silly?
16:46:00 <glguy_> You have a kind error because ([] t) a.k.a. [t] has kind *
16:46:11 <glguy_> but your class takes a *->* for its first parameter
16:46:25 <akurilin> glguy_: that worked thank you!
16:46:33 <glguy_> You're welcome :)
16:46:53 <Kazagistar> glguy_: yeah, I understand that, but I don't know how to solve it... should I add a third type parameter and make all my kinds *, like Indexable t a i?
16:47:37 <rwbarton> yeah that's what I suggested, the annoying part is that you might need a lot of type annotations when you use indexed
16:47:39 <glguy_> Kazagistar: First you need to figure out what it was supposed to do in the first place.
16:47:59 <glguy_> If you give it a [[a]] and you need to pick just one way to interpret that
16:48:27 <glguy_> either as a [(Int,[a])]  or a [((Int,Int),a)]
16:48:43 <glguy_> it looks like you're on track to have some ambiguity with what you were writing
16:49:00 <Kazagistar> glguy_: ah, I see, hmm
16:49:32 <dmj`> if I'm using setCurrentDirectory from the directory pkg with multiple threads, does each thread have their own understanding of what the current working directory is, or is each thread's understanding of the cwd isolated?
16:50:01 <kini> well this is strange. I have a haskell project here that only depends on base, filepath, hakyll, and MissingH, but `cabal install` tries to pull in really ancient versions of some packages
16:50:06 <dmj`> oops, I meant to say, "or is each thread's understanding of the cwd the same"
16:50:37 <geekosaur> dmj`, on most OSes it's an attribute of the process, not individual threads
16:50:53 <kini> it pulls in hakyll-2.4.4, which then pulls in pandoc-1.6.0.1, which then fails with "Not in scope: 'catch'" (which is coming from that thing where catch was removed from the prelude quite a while ago)
16:50:59 <Kazagistar> glguy_: but if I used { Indexable [[a]] a (Int, Int) } it should be unambiguous?
16:51:07 <owlglass> I'm using a single record mvar to represent the state of an application, and I have some functions that take the state, and update it in IO. I end up doing things like this everywhere:
16:51:09 <owlglass> modifyMVar_ options $ \opts -> return $ opts {someThing = x, other = y}
16:51:23 <owlglass> is there something more concise?
16:51:37 <dmj`> geekosaur: I was afraid of that
16:51:50 <ziman> lens
16:52:00 <kini> anyone have any idea why this might be happening?
16:53:59 <dmj`> kini: go to your project dir and do "cabal install -v3 >> install_summary.txt" and paste that file on lpaste then link it here
16:54:08 <rwbarton> dmj`: well a per-OS thread cwd would be even worse, since you typically don't have control over what OS thread your Haskell thread runs on
16:54:44 <rwbarton> (unless the GHC runtime managed this for you)
16:55:40 <dmj`> rwbarton: yea, I want each thread to act autonomously as to the file system. So changing the current working directory only affects one thread.
16:56:14 <rwbarton> well... GHC doing a chdir call on every Haskell thread context switch sounds a bit nuts
16:56:26 <rwbarton> so I don't think that's very realistic unfortunately
16:56:29 <kini> dmj`: http://lpaste.net/1874640670791041024
16:58:01 <rwbarton> "cabal install --dry-run hakyll mtl-2.2.0.1" with no user package db fails for me (ghc 7.8)
16:58:08 <rwbarton> kini: I guess that is somehow the source of your problem
16:58:28 <dmj`> kini: do a cabal update, then try "cabal install --solver=topdown"
16:59:20 <glguy_> Kazagistar: well, you'll have overlapping instances and won't get to pick which one you mean
16:59:26 <glguy_> notice the difference in how lens does things
16:59:41 <glguy_> there is no special instance for lists of lists. A separate operator merges the indexes
16:59:42 <glguy_> > itoListOf (traversed <.> traversed) ["ab","cde"]
16:59:44 <lambdabot>  [((0,0),'a'),((0,1),'b'),((1,0),'c'),((1,1),'d'),((1,2),'e')]
16:59:46 <dmj`> rwbarton: yea... none of the threads need to communicate. I just need each one to spawn a process from a different directory
16:59:51 <kini> dmj`: http://lpaste.net/871699741988093952
16:59:59 <rwbarton> hm
17:00:16 <benzrf> :t (<.>)
17:00:17 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
17:00:26 <dmj`> kini: can you paste your cabal file
17:00:27 <benzrf> guess how i know that's from len
17:00:28 <benzrf> *lens
17:00:40 <glguy_> Because you've been studying the library recently
17:00:44 <benzrf> glguy_: that too =p
17:01:08 <Kazagistar> glguy_: sooo another hint that I need to learn lenses cause they are useful for everything :P
17:02:25 <kini> dmj`: nothing mysterious there... http://lpaste.net/1222461113937952768
17:02:41 <rwbarton> dmj`: you're in luck: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#t:CreateProcess
17:02:58 <monochrom> current hakyll doesn't like current mtl, it seems. care to settle with older mtl?
17:03:23 <kini> I have no problem with that, but how do I achieve it?
17:04:09 <rwbarton> probably you have something with a newer mtl in your per-user package db
17:04:20 <dmj`> rwbarton: ah nice. Yea, I guess I can download files and make directories concurrently w/o changing the directory
17:04:20 <rwbarton> with no per-user package db "cabal install --dry-run filepath hakyll MissingH" succeeds for me
17:04:21 <kini> this is supposed to all be in a sandbox, isn't it?
17:04:37 <rwbarton> isn't your per-user db visible in the sandbox too?
17:04:44 * rwbarton doesn't really use sandboxes
17:05:06 <kini> I'm not sure. `cabal install --dry-run filepath hakyll MissingH` works fine for me too, it just says I'm going to need those old versions of pandoc and hakyll
17:05:16 <kini> (which happen not to build with ghc 7.8)
17:05:30 <rwbarton> oh, well, I see pandoc-1.12.4.2 at least...
17:05:38 <rwbarton> not pandoc-1.6.0.1
17:05:41 <monochrom> cabal sandbox mode disables user
17:05:51 <rwbarton> hmm
17:06:03 <kini> I do have a .cabal in $HOME with some stuff in it, because I wanted to build ghc-mod, structured-haskell-mode, etc. for permanent use
17:06:28 <kini> should I unregister all the things there with ghc-pkg? (I guess I only need the final executables for ghc-mod et al.)
17:06:29 <rwbarton> what version of cabal?
17:06:40 <rwbarton> before you do that just try a mv ~/.ghc ~/.ghc-tmp
17:08:01 <kini> uhhh... `cabal info cabal` tells me that 1.18.1.3 is installed (from the project dir)
17:08:01 <kini> but from my homedir it tells me that both 1.18.1.3 and 1.20.0.0 are installed
17:08:17 <kini> meanwhile `ghc-pkg list cabal` only contains directory names
17:08:19 <rwbarton> what does "cabal --version" say
17:08:44 <kini> cabal-install version 1.20.0.2 using version 1.20.0.0 of the Cabal library
17:09:01 <rwbarton> hmm, I only have cabal-install version 1.20.0.1 :)
17:09:11 <kini> wow, you're so retro ;)
17:10:16 <rwbarton> well what happens if you explicitly ask for pandoc-1.12.4.2
17:10:30 <rwbarton> cabal install --dry-run filepath hakyll MissingH --constraint 'pandoc ==1.12.4.2'
17:11:11 <kini> backjump limit reached, lol
17:11:16 <rwbarton> weird
17:11:24 <rwbarton> maybe 1.20.0.2 has some solver change
17:11:28 <rwbarton> you did cabal update recently right?
17:11:32 <kini> yup
17:11:43 <kini> does cabal update also get sandboxed, btw?
17:13:02 <savanni> kini: I don't think so, but I don't think it's needed.  cabal update mostly just downloads a new list of available packages.
17:13:11 <kini> right, I thought so too
17:13:40 <yuriy_> anyone on windows have a working installation of 'network'?
17:15:07 <porrifolius> Anyone here use ghc-mod?
17:15:34 <porrifolius> I think I'm doing something stupid... can't get it to work for me.
17:19:49 <rwbarton> kini: I get the same results with 1.20.0.2 so I don't know what the difference is between our systems any more
17:37:04 <hcaulfield57> I'm trying to figure out why >=cabal-install-1.20.0.0 fail with bootstrap-sh? I have ghc-7.8.2 and haddock-2.14.2, bootstrap-sh fails on creating documentation for Cabal which it finishes compiling, does anyone know why?
17:49:50 <td123> hcaulfield57: is this relevant? http://goo.gl/6Rw80C
17:50:40 * hackagebot sunlight 0.6.0.0 - Test Cabalized package against multiple dependency versions  http://hackage.haskell.org/package/sunlight-0.6.0.0 (OmariNorman)
17:51:18 <Kazagistar> welp, here is my arbitrary nesting indexing, in all of its sillyness: http://lpaste.net/104733
17:54:19 <Kazagistar> I am especially proud of and disturbed by this line of code { indexed = (:[]).(,)() }
17:54:25 <ajcoppa> anyone go through the NICTA course recently, particularly State? having some trouble where even the posted solution doesn't do what it should, and trying to figure out what i messed up
17:57:10 <enthropy> > map length ["\\x->((),[x])","(:[]).(,)()"]
17:57:12 <lambdabot>  [12,11]
17:58:13 <enthropy> oh it's actually \x -> [((),x)]
17:59:47 <Kazagistar> enthropy: clearly, that extra character was worth it <_<
18:00:01 <Kazagistar> ... ill make it better. Any other advice?
18:01:09 <enthropy> make it work without specifying the :: [((Int,(Int,(Int,()))), Char)]
18:03:58 <Kazagistar> enthropy: is there some way to do that without specifying a typeclass for each supported case, or using the command repeatedly like lens?
18:07:58 <enthropy> Kazagistar: you can try stuff like rewriting:  instance (Indexable f a i, result ~ (Int,i)) => Indexable [f] a result
18:08:34 <enthropy> this makes that instance match whenever 'f' looks like a list of something
18:08:39 <hithisismyname> Hi, I'm playing around with the singletons library, and I'm not sure how get something from the term level to the type level. I have : data CoolNat (n :: Nat) = CoolNat Int deriving Show  and let g :: (Min 1 n ~ 1, Max 10 n ~ 10) => CoolNat n -> CoolNat (n+1); g (CoolNat x) = (CoolNat (x+1)) :: CoolNat (n+1) That all works ok, but what I want is something like toType :: (Int -> Maybe (CoolNat n)); toType 0 = (CoolNat 0 :: Cool
18:09:07 <enthropy> same for the final instance
18:09:16 <Kazagistar> enthropy: is that magic in ~?
18:09:37 <enthropy> instance (a ~ b, c ~ ()) => Indexable a b c
18:09:49 <enthropy> well you're already using magic :p
18:10:43 <Kazagistar> enthropy: no, I am just wondering what ~ is, ill go look it up
18:11:54 <rwbarton> that would overlap with everything
18:12:13 <enthropy> yes. Maybe that's a bad idea
18:15:43 * hackagebot shadower 0.1.0.3 - An automated way to run doctests in files that are changing  http://hackage.haskell.org/package/shadower-0.1.0.3 (karun012)
18:17:52 <sloopjohnb> how can i recursively call a lambda function?
18:17:55 <sloopjohnb> is that possible?
18:19:06 <haasn> Not directly
18:19:22 <haasn> But you could use “fix” as a helper function to pass a lambda to itself
18:19:46 <haasn> You could also use something like let f x = ... (f x) ... in f
18:20:09 <sloopjohnb> i was under the impression that fixed functions couldnt terminate
18:20:13 <roconnor> I find the interaction between callCC and state confusing.
18:20:24 <sloopjohnb> unless lazily right?
18:20:26 <haasn> sloopjohnb: That's not true, at least not in Haskell
18:20:49 <haasn> An example:
18:21:15 <haasn> > let countFrom n = n : countFrom (n+1) in countFrom 3
18:21:17 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
18:21:25 <haasn> > fix (\f n -> n : f (n+1)) 3
18:21:27 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
18:32:53 <dmwit> Can we take our favorite fast PRNG with bad properties, compose it with a hash function, and get a PRNG with good properties?
18:33:42 <rwbarton> at a minimum, you still need to seed the bad PRNG well
18:33:43 <koala_man> dmwit: depends what the bad properties are. if it's predictable, then hashing won't help
18:34:11 <rwbarton> also: it doesn't work if your input PRNG is given by successively applying the same hash function you are using to "improve" it :)
18:34:48 <dmwit> ah, right
18:35:24 <dmwit> As for properties, I was thinking like uniformity, or that test where you plot your points on a 2D lattice and see if you get diagonal lines.
18:35:28 <dmwit> That kind of thing.
18:35:45 * hackagebot cartel 0.2.0.0 - Specify your Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.2.0.0 (OmariNorman)
18:35:48 <dmwit> But it's clear to me now why the question is ill-formed.
18:36:15 <dmwit> Naturally you can't really hope to answer such a question without instantiating the PRNG, the hash function, and the property. =)
18:41:28 <rwbarton> there was some recent paper about splittable random numbers where split applies two different cryptographic hash functions, so people certainly do this sort of thing
18:42:07 <dmwit> cute
18:52:49 <heatsink> I'm starting to suspect that my problem is because class constraints from an instance's context are unavailable when you're using the class.
18:57:25 <geekosaur> heatsink, that would make sense to me, there are circumstances where the compiler cannot know the instance until runtime
18:57:27 <monochrom> my mind has melted haskell with java. I keep writing in java "public class XXX where"
18:58:22 <heatsink> geekosaur: In my case, a GADT pattern match introduces a local constraint that should resolve the instance at compile time
19:03:02 <rwbarton> if you're getting the constraint from pattern-matcihng on a GADT then the type isn't known at compile time
19:03:22 <rwbarton> it may not even exist at the time you compile your module
19:03:47 <rwbarton> but maybe that's not what you mean
19:04:49 <heatsink> Pattern matching on the GADT introduces an equality constraint (a ~ T b c)
19:05:11 <rwbarton> oh, I was thinking of a class constraint
19:05:20 <heatsink> In the same context, there's a class constraint (C a)
19:05:36 <heatsink> and there happens to be a class instance defined for C (T d e)
19:05:41 <rwbarton> aha
19:06:52 <rwbarton> ghc doesn't do any reasoning that would assume that instances are distinct
19:06:54 <rwbarton> er
19:06:57 <rwbarton> unique
19:08:06 <heatsink> I see
19:08:24 <heatsink> That is for safety in case overlapping instances are used?
19:09:42 <brrrrrrrrian> hello
19:09:58 <jle`> hello brrrrrrrrian
19:11:48 <heatsink> Well I'm glad to finally have an answer to that
19:11:54 <heatsink> rwbarton++
19:12:23 <brrrrrrrrian> I have a value of type IO Char... how can I print it in the IO monad?  putStrLn takes a value that is _not_ "inside" the IO monad
19:12:31 <brrrrrrrrian> I think...
19:12:44 <monochrom> putChar
19:12:45 <ion> @hoogle Char -> IO ()
19:12:47 <lambdabot> Prelude putChar :: Char -> IO ()
19:12:48 <lambdabot> System.IO putChar :: Char -> IO ()
19:12:48 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
19:12:59 <rwbarton> heatsink: that's one issue, but in fact it is not just a type safety issue
19:13:05 <ion> @hoogle IO Char -> (Char -> IO ()) -> IO ()
19:13:06 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:13:06 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:13:06 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:13:11 <heatsink> brrrrian: First run the action to get the char, then print it
19:13:21 <ion> Well, that wasn’t useful.
19:13:22 <monochrom> also, read my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
19:13:26 <heatsink> do {c <- getChar; print c}
19:14:05 <rwbarton> heatsink: ghc needs to somehow actually produce a dictionary for whatever context you have on the C (T d e) instance, for the variables b & c
19:14:19 <heatsink> ok
19:14:23 <rwbarton> heatsink: and all it has to work with is the dictionary for C a
19:14:38 <rwbarton> and "you can't get there from here"
19:14:41 <brrrrrrrrian> OK sorry I must rephrase
19:14:47 <brrrrrrrrian> I have a value of type IO String
19:14:53 <brrrrrrrrian> and I would like to print it
19:15:04 <monochrom> you really read my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
19:16:15 <brrrrrrrrian> doh
19:16:28 <brrrrrrrrian> I needed to do a bind / >>= on putStrLn
19:16:47 <monochrom> yes
19:17:17 <platz> I was just trying to remember where I had seen that "Prerequisite for Learning Haskell" post today..
19:17:30 <platz> good timing
19:17:59 <monochrom> thank you for choosing monochrom!
19:18:31 <brrrrrrrrian> that was basic monad stuff that i should have recognized
19:18:35 <brrrrrrrrian> thx
19:19:06 <heatsink> Ah, the instance context is only used to construct the class methods
19:22:49 <rwbarton> heatsink: right, and it might not even really be needed at all
19:23:13 <benzrf> monochrom: > Upon seeing that name, you are bound to try to guess what it means. Well, since its name is “return”, it is going to be muddy water again (actually worse than last time), I am sure your guess is right in some sense and wrong in some other sense, and I am not getting into it. I will just say, this came from a foreign word that rhymes with English “return” by coincidence.
19:23:18 <rwbarton> or part of it might get inlined
19:23:22 <benzrf> monochrom: huh?
19:23:37 <monochrom> what do you not understand?
19:23:46 <benzrf> what word does it come from
19:23:56 <t4nk171> hello
19:24:10 <jle`> hello t4nk171
19:24:24 <monochrom> it comes from a foreign language
19:25:47 <rwbarton> an ancient Buddhist word that represents the unchanging of all things
19:25:54 <t4nk171> I am wondering how I can compile some haskell files
19:26:06 <monochrom> you need a compiler. do you have one?
19:26:37 <benzrf> monochrom: is that a literal thing, or is it a joke on language as in programming language
19:26:50 <t4nk171> I have a compiler, but when I compile it says it cannot locate a module
19:26:55 <t4nk171> they are in the same directory
19:27:54 <monochrom> please show directory listing, your command, and file contents unabridged verbatim. use lpaste.net/new/haskell
19:28:21 <monochrom> it is neither. it is my wish.
19:29:24 <t4nk171> wait I probably need a main, don't I
19:29:47 <monochrom> not always. only when you want an executable.
19:29:52 <t4nk171> I'm trying to compile to something that acts like ghci
19:30:02 <t4nk171> so that I can type in commands
19:38:18 <pavonia> How do you debug when hsc2hs fails with "hsc2hs: Char.intToDigit: not a digit 148"? -v doesn't give any extra output
19:42:45 <pavonia> So it fails before the .c file is written :/
19:44:42 <t4nk293> whoops
19:45:18 <t4nk293> I was the guy asking earlier how I could compile a program
19:45:22 <t4nk293> to act like the ghci prompt
19:45:50 <monochrom> you will have to write your own code
19:46:31 <monochrom> the library "haskeline" may help
19:47:50 <t4nk293> I just want to be able to call functions in my library
19:47:56 <t4nk293> from the program
19:48:01 <t4nk293> would I have to use a library?
19:49:17 <monochrom> can you settle for: stick with ghci, :load your file, then call your functions
19:52:26 <pavonia> Found the problem, it fails if one of my comments (!) includes the acute accent character, which is extremely weird ...
19:52:36 <t4nk293> that works for me
19:52:52 <t4nk293> the only reason I want to compile is so that my teacher can look at it easily
19:53:06 <t4nk293> but said he is fine with installing ghc
19:53:53 <rwbarton> > chr (148 + ord '0')
19:53:55 <lambdabot>  '\196'
19:54:00 <rwbarton> > text [chr (148 + ord '0')]
19:54:01 <lambdabot>  Ä
19:54:23 <monochrom> there is no conflict between compiling and using ghci
19:54:55 <monochrom> read the GHC user's guide section 2.3
19:55:23 <pavonia> > ord '´'
19:55:24 <lambdabot>  180
19:55:34 <jle`> > text . map chr . enumFrom $ 148 + ord '0'
19:55:38 <lambdabot>  mueval-core: Time limit exceeded
19:55:42 <jle`> huh
19:56:03 <t4nk293> ?
19:56:06 <t4nk293> I dont understaand
19:56:29 <benzrf> :t text
19:56:30 <lambdabot> String -> Doc
19:56:37 <benzrf> > text "lol wut"
19:56:38 <lambdabot>  lol wut
19:56:46 * benzrf glares at lambdabot 
19:56:50 <napping> jle`: Char has a decently long range
19:57:05 <jle`> napping: i would expect laziness to only like...show when necessary
19:57:23 <jle`> > map chr . enumFrom $ ord 'A'
19:57:24 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129...
19:57:33 <jle`> but i guess text needs everything
19:57:34 <napping> I think text isn't that lazy
19:57:42 <Iceland_jack> > ['A'..]
19:57:44 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129...
19:57:47 <napping> It could be, but it's not usually implemented that way
19:57:50 <Iceland_jack> Slightly shorter way of doing that :)
19:58:06 <pavonia> Interestingly, it fails if I put an 'Ä' too
19:58:20 <jle`> Iceland_jack: heh. wanted to parallel my previous one which parelled rwbarton
19:58:42 <monochrom> Data.Text is eager. Data.Text.Lazy is coarse-grain lazy, i.e., something about one large buffer at a time
19:58:59 <t4nk293> so there is no easy way for my instructor to use the functions of my program without installing ghc (easily)?
19:59:28 <rwbarton> t4nk293, correct
19:59:39 <t4nk293> okay, thank you
20:00:02 <jle`> you can have some sort of faux-repl loop if you want to parse a limited subset of commands
20:00:51 <pavonia> While a 'µ', which comes after '´' but before 'Ä', works fine
20:01:06 <rwbarton> pavonia: can you paste the input file? I couldn't reproduce easily
20:01:19 <rwbarton> or at least the relevant parts
20:02:07 <pavonia> rwbarton: The relevant part was a comment "-- acute accent (´)"
20:02:34 <rwbarton> that doesn't seem to be enough to cause the issue on its own
20:03:04 <pavonia> Hhm, I'm using an old version, I may already be fixed in newer versions
20:03:11 <pavonia> *it may
20:03:34 <pavonia> hsc2hs version 0.67
20:05:20 <dolio> Are we talking about the 'text' function from pretty printing? Because that needs to determine information about the string for layout purposes.
20:05:49 <dolio> It's not just a function for printing out a string without quotes in it in lambdabot.
20:06:52 <monochrom> oh, that one, yeah
20:12:30 <jle`> oh yeah
20:12:57 <pavonia> Could be related to this bug https://ghc.haskell.org/trac/ghc/ticket/3837, though according to the code I can't see why it would fail for small-value characters
20:23:20 <Mathnerd314> so how many times does one have to use a language extension before it's worthwhile to turn it on by default (w/ cabal)? 10? 40?
20:25:03 <pavonia> 42, of course
20:29:53 <Mathnerd314> that seems a bit high (only FlexibleContexts and TypeFamilies). What about 20 (MultiParamTypeClasses is 21)?
20:30:21 <Mathnerd314> UndecidableInstances is 16 so that's probably the lower limit
20:34:35 <carter> Mathnerd314: i like including the extensions per file so i can run the file from ghci
20:34:42 <jle`> > let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x) in fix (fixer cos) 1
20:34:43 <lambdabot>  0.7391301765296711
20:34:59 <carter> jle`: wtf is that
20:35:02 <carter> :)
20:35:14 <jle`> procrastination heh.
20:35:19 <jle`> using fix to find a fixed point
20:35:23 <jle`> of cosine >_>
20:35:33 <carter> hah
20:35:42 <Mathnerd314> carter: and cabal repl doesn't work?
20:35:43 <carter> cutes
20:35:44 <jle`> > let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x) in fix (fixer exp) 0
20:35:48 <lambdabot>  mueval-core: Time limit exceeded
20:35:56 <jle`> oh exp doesn't have a fixed point
20:35:57 <carter> Mathnerd314: cabal repl is a new thing
20:36:06 <carter> jle`: exp -1 has one :)
20:36:22 <jle`> > let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x) in fix (fixer (\x -> 1/x + 1) 1
20:36:23 <lambdabot>  <hint>:1:102:
20:36:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:36:25 <Mathnerd314> carter: ok... your point?
20:36:26 <jle`> > let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x) in fix (fixer (\x -> 1/x + 1)) 1
20:36:28 <lambdabot>  1.6179775280898876
20:36:35 <jle`> cool i calculated the golden ratio
20:36:40 <jle`> er, 1 + phi
20:36:50 <carter> Mathnerd314: its nice to have stuff that can be tested with Ghci sometimes
20:36:53 <carter> cabal repl is new
20:36:55 <carter> my habits are old
20:37:06 <carter> i do use cabal repl sometimes
20:37:25 <jle`> Mathnerd314: i mostly include extensions in the file so that people can understand what's going on without having to check an outside context
20:37:30 <carter> yes that too
20:37:37 * Mathnerd314 writes off carter as a fogie
20:37:49 <carter> Mathnerd314: nah, look at JLE's point
20:38:10 <Mathnerd314> FlexibleInstances, FlexibleContexts, MultiParamTypeClasses, and TypeFamilies are all pretty obvious things
20:38:15 <carter> oh yeah
20:38:21 <carter> those might be nice to have in the cabal file
20:38:28 <jle`> @let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x)
20:38:30 <lambdabot>  Defined.
20:38:33 <carter> otoh, its also nice to list all the extensions in the file
20:38:38 <carter> Mathnerd314: OH
20:38:41 <carter> theres another reason
20:38:53 <carter> cabal files warn when you list extensions it doesn't know
20:39:13 <carter> so if you wanna make it usable fr someone who has a slightly old cabal for some sad reason, yoiu can't put em all in there
20:39:42 <jle`> i think i saw it in a "how to write obfuscated haskell" guide once --- "put all your extensions in your cabal file"
20:40:10 <carter> oh yeah
20:40:21 <carter> jle`: and then use unicode names that look like roman letters but arent
20:40:29 <Iceland_jack> > let a = 0.7390851332151607 in cos a == a
20:40:31 <lambdabot>  True
20:41:06 <jle`> what are functions with interseting fixed points
20:41:11 <Mathnerd314> well, if the code uses ConstraintKinds, then I doubt anyone is going to use the 2011 edition of cabal
20:41:26 <knrafto> > fix error
20:41:27 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:41:36 <Iceland_jack> > fix (1:)
20:41:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:41:38 <jle`> i only know tan and (\x -> 1/x - 1)
20:41:44 <jle`> i mean functions on reals, heh
20:41:46 <jle`> s/tan/cos
20:42:14 <enthropy> Mathnerd314: I prefer to put everything except CPP and OverlappingInstances on by default
20:42:30 <Mathnerd314> enthropy: even UndecidableInstances? :p
20:42:40 <enthropy> yeah
20:43:31 <jle`> > fix (fixer sqrt) 0.5
20:43:33 <lambdabot>  0.9998307889319291
20:43:41 <jle`> ok back to hw
20:44:17 <Mathnerd314> > fix (fixer (\x -> 1-x*x)) 0.1
20:44:21 <lambdabot>  mueval-core: Time limit exceeded
20:45:07 <enthropy> > fix (fixer id) 42
20:45:09 <lambdabot>  42.0
20:46:24 <Mathnerd314> > fix (fixer (\x -> 1-x*x)) 0.6
20:46:28 <lambdabot>  mueval-core: Time limit exceeded
20:46:36 <Mathnerd314> hmm, I thought that converged
20:46:57 <jle`> > (\x -> 1 - x*x) 0.6
20:46:59 <lambdabot>  0.64
20:47:28 <jle`> > (\x -> 1 - x*x) 0.64
20:47:29 <Mathnerd314> I guess not
20:47:30 <lambdabot>  0.5904
20:47:41 <Mathnerd314> > iterate (fixer (\x -> 1-x*x)) 0.6
20:47:43 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
20:47:43 <lambdabot>    arising from a use of ‘M26333143924982621864039.show_M26333143924982621864...
20:47:43 <lambdabot>  The type variable ‘a0’ is ambiguous
20:47:43 <lambdabot>  Note: there are several potential instances:
20:47:43 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:48:10 <Mathnerd314> > iterate (fixer (\x -> 1-x*x)) (0.6 :: Double)
20:48:12 <lambdabot>  Couldn't match expected type ‘a -> a’
20:48:12 <lambdabot>              with actual type ‘GHC.Types.Double’
20:48:16 <jle`> > iterate (\x -> 1 - x*x) 0.6
20:48:17 <lambdabot>  [0.6,0.64,0.5904,0.65142784,0.5756417692729344,0.6686365534683257,0.55292515...
20:48:26 <jle`> it looks like it converges very, very slowly
20:48:38 <jle`> wait
20:48:45 <jle`> what's even going on
20:48:48 <rwbarton> to a 2-cycle
20:48:50 <Mathnerd314> no, it should converge to 0.61..., it's diverging
20:48:55 <jle`> yeah, it's diverging
20:49:14 <rwbarton> > iterate ((\x -> 1 - x*x) . (\x -> 1 - x*x)) 0.6
20:49:15 <lambdabot>  [0.6,0.5904,0.5756417692729344,0.5529251593659987,0.5179839348725677,0.46462...
20:49:27 <rwbarton> maybe just the 2-cycle 0 <-> 1
20:50:27 <Mathnerd314> solutions to x == 1-x*x are -1.61803 and 0.618034. neither converge
20:51:07 <rwbarton> > iterate (\x -> sqrt (1 - x)) 0.6
20:51:10 <lambdabot>  [0.6,0.6324555320336759,0.6062544581001645,0.6274914675912617,0.610334770768...
20:51:47 <jle`> > fix (fixer (\x -> sqrt (1-x)) 0.6
20:51:48 <lambdabot>  <hint>:1:34:
20:51:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:51:52 <jle`> > fix (fixer (\x -> sqrt (1-x))) 0.6
20:51:54 <lambdabot>  0.6179865360261874
20:52:55 <Mathnerd314> > iterate (fixer (\x -> 1-x+x*x/2)) (0.6 :: Double)
20:52:57 <lambdabot>  Ambiguous occurrence ‘+’
20:52:57 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:200:3
20:52:57 <lambdabot>                        or ‘GHC.Num.+’,
20:52:59 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
20:53:00 <Mathnerd314> > fix (fixer (\x -> 1-x+x*x/2)) (0.6 :: Double)
20:53:01 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
20:53:03 <lambdabot>  Ambiguous occurrence ‘+’
20:53:05 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:200:3
20:53:07 <lambdabot>                        or ‘GHC.Num.+’,
20:53:09 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
20:53:11 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
20:53:27 <jle`> ...did someone define their own (+)
20:53:40 <Mathnerd314> @type (+)
20:53:42 <lambdabot>     Ambiguous occurrence ‘+’
20:53:44 <lambdabot>     It could refer to either ‘L.+’,
20:53:45 <jle`> > 1 + 4
20:53:45 <Mathnerd314> yep
20:53:46 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:200:3
20:53:48 <lambdabot>  Ambiguous occurrence ‘+’
20:53:49 <jle`> come on people
20:53:50 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:200:3
20:53:52 <lambdabot>                        or ‘GHC.Num.+’,
20:53:54 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
20:53:55 <Mathnerd314> @undefine
20:53:56 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
20:53:58 <lambdabot> Undefined.
20:54:18 <Mathnerd314> @let fixer f = \f' x -> if abs (f x - x) < 0.0001 then x else f' (f x)
20:54:20 <lambdabot>  Defined.
20:54:24 <Mathnerd314> > fix (fixer (\x -> 1-x+x*x/2)) (0.6 :: Double)
20:54:25 <lambdabot>  0.5857570698553087
20:54:30 <Mathnerd314> yay!
20:54:41 <Mathnerd314> > 2 - sqrt 2
20:54:43 <lambdabot>  0.5857864376269049
20:55:05 <jle`> @undefine
20:55:05 <lambdabot> Undefined.
20:55:24 <jle`> @let fixer' f t = \f' x -> if abs (f x - x) < t then x else f' (f x)
20:55:25 <lambdabot>  Defined.
20:55:32 <jle`> oh i probably didn't need to undefine everything
20:55:49 <Mathnerd314> better safe than sorry
20:55:56 <jle`> > fix (fixer' (\x -> 1-x+x*x/2) 0.00000001) 0.6
20:55:57 <lambdabot>  0.5857864332604898
20:59:31 <Mathnerd314> > fix (fixer' (\x -> 1-x+x*x/2) 0.00000000000000001) 0.6
20:59:32 <lambdabot>  0.585786437626905
21:00:18 <Mathnerd314> > (fix (fixer' (\x -> 1-x+x*x/2) 0.00000000000000001) 0.6) - (2 - sqrt 2)
21:00:20 <lambdabot>  1.1102230246251565e-16
21:00:28 <Mathnerd314> close enough for me :-)
21:00:51 <jle`> floating point numbers are weird
21:00:59 <Mathnerd314> > (fix (fixer' (\x -> 1-x+x*x/2) 0.00000000000000001) 0.6) - (2 - sqrt 2) :: CReal
21:01:03 <lambdabot>  mueval-core: Time limit exceeded
21:01:31 <Mathnerd314> > (fix (fixer' (\x -> 1-x+x*x/2) 0.00000000000000001) 0.5857864376269) - (2 - sqrt 2) :: CReal
21:01:34 <lambdabot>  -0.0000000000000000042904696960051571839793
21:02:35 <Mathnerd314> > 1.1102230246251565e-16 :: Creal
21:02:37 <lambdabot>  Not in scope: type constructor or class ‘Creal’
21:02:37 <lambdabot>  Perhaps you meant ‘CReal’ (imported from Data.Number.CReal)
21:02:38 <Mathnerd314> > 1.1102230246251565e-16 :: CReal
21:02:40 <lambdabot>  0.00000000000000011102230246251565
21:06:23 <Mathnerd314> you can have fast, you can have accurate; you can even have fast followed by accurate. but you can't have fast *and* accurate without shelling out a lot more cash
21:06:55 <Mathnerd314> (or waiting for Moore's law, which amounts to the same thing)
21:07:09 <samba1> could anybody help me with a few questions about cabal/sandboxes with some errors i'm getting? lpaste is slow, but i will send a link in soon
21:08:15 <samba1> http://lpaste.net/1417101464060297216
21:08:30 <samba1> i've done cabal sandbox init and cabal install --dependencies-only
21:08:58 <benzrf> speed * goodness * cheapness = k
21:09:08 <samba1> i get an error now about clock not being available. i think it's from the executable part - why can't i have the executable reference my library as a dependency to get all the dependencies it has?
21:09:50 <jle`> i don't see clock, but i think the executable you have to list all the dependencies of the parts of the libaries that i uses
21:09:51 <jle`> *it
21:10:23 <samba1> you don't see clock as a dependency of the library?
21:10:40 <samba1> http://stackoverflow.com/questions/10163604/how-to-reduce-duplication-in-the-build-depends-fields-of-a-cabal-file
21:10:48 <samba1> this is what gave me the idea to do it this way
21:11:46 <johnw> > 4 * fix (\f k b i -> if i > 1000000 then k else let y = (if b then (-) else (+)) k (1/i) in f y (not b) (i + 2)) 1 True 3
21:11:50 <lambdabot>  3.141590653589692
21:11:56 <johnw> that algorithm sure doesn't converge very quickly
21:12:11 <johnw> funny how many digits past the wrong digit are correct, though
21:14:19 <samba1> well, my other problem is it gives me an error too about the test, but not about clock, about the test libraries. it says they aren't installed
21:15:28 <samba1> i don't know why they aren't installed with cabal install --only-dependencies
21:15:57 <samba1> if i do cabal configure --enable-tests
21:16:28 <samba1> i get 'at least the following dependencies are missing' listing all the test-framework ones
21:18:31 <supki> samba1: cabal install --only-dependencies won't install tests dependencies, you need cabal install --enable-tests --only-dependencies
21:20:05 <samba1> i see... that is somewhat strange, that cabal configure --enable-tests doesn't do that, instead cabal install --enable-tests --only-dependencies
21:20:06 <supki> samba1: also dependencies aren't transitive
21:20:08 <samba1> but thank you
21:20:41 <samba1> so this answer is wrong? http://stackoverflow.com/questions/12305970/how-to-make-a-haskell-cabal-project-with-libraryexecutables-that-still-run-with/12305972#12305972
21:20:45 <supki> samba1: so executables will need to depend on your library and on every package they use besides your library
21:22:02 <samba1> people on stackoverflow seem to have success though
21:22:27 <supki> samba1: no, it solves a different problem, namely double recompilation
21:22:40 <pyry`> wondering if someone can help me think through this thing, it's probably stupid and simple, and i have a paste.
21:23:06 <pyry`> http://dpaste.com/1PZJW1Y/ - i'm trying to chunk external API calls due to a limit on the amount of things i can fetch with one call
21:23:35 <pyry`> but because i misunderstand something, i end up with things like "Couldn't match expected type `Response B.ByteString' with actual type `[Response B.ByteString]'"
21:23:39 <samba1> well, i came to there from here, which is specifically about that http://stackoverflow.com/a/18310327
21:23:42 <pyry`> and i can't seem to fix it by adjusting the return type
21:25:12 <samba1> or this https://github.com/Toxaris/pts/blob/master/pts.cabal
21:26:00 <samba1> but now that one lists things multiple times... i don't know, maybe this changed
21:31:40 <rwbarton> pyry`, what monad do you think that do notation is for
21:31:54 <rwbarton> if any
21:32:13 <pyry`> IO?
21:32:33 <rwbarton> then you need IO in the type declaration
21:32:45 <rwbarton> fetchChunks :: [[Integer]] -> IO [Response B.ByteString]
21:33:29 <pyry`> same issue with type problems that i'm not sure how to fix yet
21:33:46 <pyry`> "Couldn't match expected type `[Response B.ByteString]' with actual type `IO [Response B.ByteString]'"
21:33:53 <rwbarton> if you changed that then now you have a different issue, I promise :)
21:34:10 <pyry`> oh, i believe you ;)
21:34:11 <rwbarton> ah yes on line 5, you need to run the action fetchChunks rest
21:34:38 <rwbarton> fetchChunks rest isn't a list
21:34:44 <pyry`> ahhh, right
21:35:03 <rwbarton> (also, this whole function can be replaced by a common library function)
21:35:18 <pyry`> it's not map, or fmap is it?
21:35:25 <rwbarton> it's mapM
21:35:54 <pyry`> hmhmm, reading the type description
21:36:08 <pyry`> i knew there had to be a simpler way, but didn't really know what it might be
21:36:24 <rwbarton> probably a good exercise to get this working without mapM first though
21:38:28 <pyry`> rwbarton: you're probably right. ;)
21:38:40 <pyry`> i understand now that it's an action, not the type i'm expecting
21:39:14 <pyry`> but do i really want to just do another action before returning the results?
21:40:08 <pyry`> oh, i guess it was really that simple ;D
21:40:13 <pyry`> derrrr
21:40:47 <pyry`> goodness
21:42:06 <kalloc> hi
21:42:12 <pyry`> also at least the type signature to mapM is making sense now-- last time i was working on learning haskell it was opaque to me
21:42:21 <kalloc> why is my cabal without sandbox?
21:42:38 <kalloc> i'm work on macosx and I installed cabal by brew
21:58:17 <begriffs> kalloc: what version is your cabal?
22:30:11 <warpy> kalloc: run cabal update && cabal install cabal-install
22:30:23 <warpy> that should get you latest version of cabal with sandbox
22:57:02 <b0bbi10> hello there, sorry to bother you with a not directly haskell-related question, but does someone here is a dev/mod/user with more than 10K on Stack Overflow? I bookmarked a nice Haskell post https://stackoverflow.com/questions/1012573/getting-started-with-haskell/101698 but that post was deleted -.-
22:58:25 <mzero> I don't have that kind of karma!
22:59:51 <mzero> Oy! Haskell Platform sure takes a fair bit of time to build from scratch on my system.....
23:00:08 <b0bbi10> I don't even have an account there Oo I don't really get it why they deleted such a valueble post
23:00:20 <mzero> at least it builds now totally repeatably under control of shake
23:00:26 <Welkin> just look in google cache
23:00:31 <Welkin> or the web archive
23:11:24 * hackagebot scotty 0.7.3 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.7.3 (SimonHengel)
23:36:30 * hackagebot shadower 0.1.0.4 - An automated way to run doctests in files that are changing  http://hackage.haskell.org/package/shadower-0.1.0.4 (karun012)
23:37:05 <fredsir> clear
23:46:02 <warpy> b0bbi10: what do you want?
23:47:02 <b0bbi10> warpy: thanks for asking, I got that already :-) https://stackoverflow.com/questions/1012573/getting-started-with-haskell
23:47:43 <warpy> b0bbi10: the post is deleted. can you see it?
23:48:09 <b0bbi10> warpy: someone recommended me stackprinter
23:48:50 <warpy> ah nice
23:48:57 <warpy> didnt know about stackprinter
23:49:21 <b0bbi10> me neither but really useful
23:49:41 <warpy> b0bbi10: you may like this http://dev.stephendiehl.com/hask/
23:53:55 <b0bbi10> especially since the mods are apparently deleting informative posts randomly...
23:53:55 <b0bbi10> thanks, will have a look at it
23:54:07 <b0bbi10> looks advanced or pretty intermediate to me. guess have to go through the classics LYAH and RWH first ;-)
23:59:10 <warpy> b0bbi10: ya, they have deleted many such good posts
23:59:32 <warpy> if i had enough rep, i'd undelete it and change it to locked
23:59:55 <Kaidelong> @src ask
23:59:55 <lambdabot> Source not found. Maybe if you used more than just two fingers...
