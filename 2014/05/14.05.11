00:00:09 <johnw> http://hackage.haskell.org/package/logging
00:00:20 <johnw> it was designed for "end-user" use of monad-logger in the simplest way possible
00:00:54 <btubbs> runStdoutLoggingT ?
00:00:58 <johnw> ah yes
00:01:02 <johnw> or runNoLoggingT, etc.
00:01:29 <btubbs> getting closer: Couldn't match type `IO' with `LoggingT IO'
00:01:46 <btubbs> cover over it with a return ()?
00:01:47 <johnw> swap it with runResourceT
00:01:50 <johnw> runResourceT . runNoLoggingT
00:01:53 <btubbs> ok
00:02:44 <btubbs> hm
00:03:41 <btubbs> now Couldn't match type `ResourceT IO' with `NoLoggingT (ResourceT IO)'
00:03:48 <johnw> argh
00:04:53 <johnw> ok, do this
00:05:58 <johnw> this may or may not work: https://gist.github.com/d972a339b6f3b7c5f834
00:08:53 <btubbs> trying to find what I need to import for it to know what a MonadResource is
00:09:03 <johnw> Control.Monad.Trans.Resource
00:09:38 * hackagebot snaplet-sqlite-simple 0.4.7 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.7 (JanneHellsten)
00:09:38 * hackagebot exceptions 0.6.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.6.1 (EdwardKmett)
00:10:12 <johnw> yay, exceptions 0.6.1!
00:10:17 <btubbs> blew up a little more verbosely this time http://lpaste.net/103969
00:10:37 <johnw> btubbs: ok, i'm going to have to install some things so I can try this locally
00:11:00 <btubbs>  i can paste my cabal file if that helps
00:11:27 <btubbs> http://lpaste.net/103970
00:14:08 <johnw> btubbs: https://gist.github.com/7a14c94a6cf79e43e975
00:14:11 <johnw> that compiles here
00:15:39 <btubbs> here too
00:15:56 <btubbs> going to stare at it for a minute
00:21:52 <btubbs> johnw: things looking good now.  thank you!
00:21:53 <toki78> hi
00:22:00 <johnw> btubbs: sure, sorry for the false starts
00:22:03 <johnw> hi toki78
00:22:36 <toki78> johnw, need help, wanna write a sat generator for ersatz
00:23:06 <toki78> johnw, no help in haskell-lens
00:23:40 <johnw> I'm afraid I have none to offer you either; I don't know much about sat solvers
00:23:56 <startling> toki78: that's a broad topic to ask about.
00:24:03 <startling> especially without a specific question.
00:24:26 <toki78> startling, a first primitive sat generator would help
00:25:03 <edwardk> toki78: read up on DPLL / CDCL to start
00:25:12 <toki78> edwardk, okay
00:25:49 <toki78> edwardk, I will also look into the examples directory of ersatz and contribute my own examples
00:26:17 <toki78> edwardk, I allready forked ersatz into my github account
00:26:40 <toki78> edwardk, I will send a PullRequest soon
00:26:41 <edwardk> toki78: anyways you'd want to write a Solver SAT m -- for whatever monad m your solver runs in
00:27:16 <toki78> edwardk, that was yesterday. Today the first approach would be a Generator
00:27:17 <edwardk> take a look at the type of Solver, and http://hackage.haskell.org/package/ersatz-0.2.6/docs/Ersatz-Problem.html#t:SAT
00:27:28 <edwardk> Generator?
00:27:41 <toki78> edwardk, like sudoku
00:27:48 <edwardk> we have sudoku in there
00:28:26 <toki78> edwardk, yes, and I have new ideas about generators, and I take sudoku as an example
00:28:41 <edwardk> fair nuff. more examples are welcome
00:28:59 <toki78> edwardk, that is great
00:29:38 <edwardk> you might want to look at something like http://www-users.cs.york.ac.uk/~jc/teaching/arin/sat.pdf as a starting point when you want to switch to solving
00:29:49 <edwardk> naive, simple, but gets you going
00:30:08 <johnw> link doesn't load here
00:30:46 <toki78> edwardk, works here, thanks !
00:30:59 <johnw> oh, just did
00:31:00 <johnw> odd
00:32:19 <edwardk> then i'll stop trying to stuff it into google docs for you ;)
00:33:03 <toki78> edwardk, does ersatz work with hugs, too, or only ghc ?
00:33:24 <edwardk> ersatz uses observable sharing tricks that only work in ghc
00:33:35 <edwardk> i can't think of much of _anything_ that works with hugs
00:33:44 <edwardk> maybe transformers ;)
00:36:27 <darthdeu> guys do you think yesod is beginner friendly? I've been playing around with simple and scotty, and now i'm looking at snap/yesod ... and I just cant decide ... I've tried both and I think I like yesod more, but it also seems much larger, so i'm not sure if it's a good choice :\
00:37:10 <johnw> I think yesod is pretty user friendly, in that it comes with an excellent book
00:37:26 <johnw> scotty's scope is much narrower, so it's also much simpler in that respect
00:37:32 <dmj`> darthdeu: what is simple?
00:37:59 <darthdeus> dmj`: http://simple.cx/
00:38:27 <dmj`> darthdeu: cool!
00:38:35 <darthdeus> johnw: my biggest concern is that i'll get swallowed in the complexity, since it's a big framework (though I'm a rails dev, so I kinda have some feel about the structure) ... but on the other hand as you say, there's a book and screencasts and so much more
00:39:10 <startling> darthdeus: I've heard yesod is more railsy
00:39:15 <johnw> another way of looking at it that yesod is just a set of DSLs around WAI, and WAI is quite simple
00:39:17 <edwardk> scotty is very simple, so if you want to understand everything about what you are doing all the way down its a good place to get going. yesod has a lot more magic from the typeclasses involved, and sometimes you'll just need to ask for help because you won't know what signature to put on something to make it work, but it provides a ton of EDSLs for routing/page templates/etc in template-haskell that make it very strongly typed. snap
00:39:18 <edwardk>  provides fewer edsls, but might be closer to scotty in reducing "magic", but it doesn't have yesod's book going for it.
00:39:45 <darthdeus> johnw: yeah scotty and simple are both almost like wai, though my problem with them is that now i'd like to actually build something bigger :)
00:40:27 <edwardk> so it depends on what you are looking for. snap's snaplets and lens use appeals to me. yesod seems to do a better job of static typechecking a bit, but feels more like ruby on rails than haskell at times.
00:40:28 <darthdeus> edwardk: yeah my biggest frustration with snap so far is that i can't find much in the docs
00:40:35 <edwardk> they all have different trade-offs
00:40:39 <darthdeus> hmm
00:40:47 <edwardk> the #snapframework channel is a pretty good resource.
00:40:53 <darthdeus> i'm there :)
00:40:56 <johnw> and #yesod
00:41:01 <darthdeus> but it seems very idle
00:41:06 <edwardk> and yeah, #yesod is also key
00:41:23 <joelteon> yesod is very not-rails
00:41:36 <edwardk> darthdeus: what timezone are you in?
00:41:40 <startling> haskell is an oral culture. :)
00:41:58 <edwardk> darthdeus: a lot of the snap folks are in US timezones
00:41:59 <darthdeus> apart from the TH magic, how much bigger is yesod than snap? at first i thought yesod was like this gigantic thing, but now that i'm looking at snap it seems they're both similar in some sense ... at least compared to scotty
00:42:13 <edwardk> darthdeus: they both have similar scope in my experience
00:42:26 <joelteon> yesod's community is I think bigger
00:42:28 <darthdeus> cool
00:42:34 <edwardk> yesod has more users definitely
00:42:47 <joelteon> also I'm in there and I'm very helpful
00:42:55 <darthdeus> joelteon: :D
00:42:59 <joelteon> and my mom says i'm handsome
00:43:06 <edwardk> yes, but, snap uses lens ;)
00:43:33 <darthdeus> thanks guys, i'll go with yesod then :P ... mostly because I have this snap book lying around, spent all yesterday trying to figure out stuff and got nowhere, so let's see how it goes with yesod
00:44:06 <dmj`> darthdeus: I use snap and I like it
00:44:16 <dmj`> https://github.com/raimohanska/snap-mongo-rest might help
00:44:34 <darthdeus> dmj`: then you can probably answer my question :) how can i get something like wai-handler-devel for snap, so that it recompiles automatically?
00:45:01 <dmj`> darthdeus: snap has built-in auth, that's why I went with it. Snap's templates auto reload if you compile with -fdevelopment flag I believe
00:45:16 <dmj`> that's just template recompilation
00:45:17 <darthdeus> dmj`: what about the application code?
00:46:02 <johnw> yeah, but dmj` uses acid-state and likes it too... ;)
00:46:07 <dmj`> darthedeus: A lot of my testing is done with ghci, so reloading w/ Ctrl-C isn't that big of a deal.
00:46:11 <dmj`> johnw: shhhh!!
00:46:28 <johnw> um, yesod has yesod-auth
00:46:33 <darthdeus> hmm :( that's not really an answer I was looking for :)
00:46:57 <johnw> I think darthdeus is wanting the convenience of "yesod devel"
00:47:02 <darthdeus> yeah
00:47:09 <darthdeus> or wai-handler-devel
00:47:33 <johnw> well, for working on a yesod app, you'd use the higher-level one
00:47:42 <darthdeus> after having automatic  reloading for the past ~6 years I dont think I can live without it
00:49:34 <dmj`> darthdeus: have the languages you used previously for web dev been dynamic? If so you might find that ghc catches a lot of errors up front for you, your main problem being logic errors rather than runtime errors
00:49:43 <solidus-river> darthdeus: you can emulate automatic reloading in almost any framework with grunt! and while your at it add auto tests / docs / coverage reports :)
00:50:02 <solidus-river> also, hats off to haskell
00:50:15 <solidus-river> i just finished the first chunk of my program thats enough to run alone and something amazing happened
00:50:25 <dmj`> johnw: I don't believe the yesod-auth package integrates w/ a db backend like snap's postgres backend or json-backend. It seems like its all openID auth
00:51:02 <solidus-river> it took me 4 - 5 days to work through writing the first real haskell program, but on first run, it not only did exactly what i expected it to, but it warned me of a type clash between loaded configs and what i was expecting in my data that would have caused problems later
00:51:22 <johnw> dmj`: at fpco we used it to do just that
00:52:42 <darthdeus> solidus-river: grunt is just wrong! I've used watchr in the past, but then after finding wai-handler-devel it's just so much more ... reasonable
00:54:25 <solidus-river> darthdeus: well, nothing is going to beat a native solution to the framework / language your using :P
00:54:49 <dmj`> darthdeus, johnw: spoke too soon, looks like snap does support code reloading. http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.1/docs/Snap-Loader-Dynamic.html
00:55:02 <solidus-river> darthdeus: but having to decide between javascript and ruby i'd probably go wtih javascript imo (maybe i spent a little too much time dealign with monkeypatched rails stuff)
00:55:03 <toki78> Sudoku/Problem.hs:7:8:
00:55:03 <toki78>     Could not find module `Control.Monad.State'
00:55:14 <johnw> dmj`: I didn't say snap wouldn't do that!
00:55:41 <johnw> I don't know anything about snap, so I don't talk about what it can and can't do
00:55:49 <dmj`> johnw: you didn't, but I almost did :P
00:55:59 <johnw> ah, I misread your colon
00:56:44 <solidus-river> dmj` i'm pretty sure it farts rainbows :)
00:57:00 <toki78> edwardk, is sudoku compatible with the latest ghc ?
00:57:08 <darthdeus> solidus-river: if I could erase one thing from computer history it would be javascript, there's just so much wrong in it, and there's also this node.js thing which is even more wrong
00:57:16 <edwardk> not sure. haven't compiled ersatz in a while
00:57:31 <johnw> darthdeus:
00:57:35 <solidus-river> darthdeus: no complaints here, but imo some of ruby is worse
00:57:40 <toki78> edwardk, I'll try to adjust sudoku
00:57:50 <johnw> Node.js reminds of those people who killed themselves when they claimed a spaceship was approaching Earth from behind an asteroid
00:57:51 <solidus-river> darthdeus: at least javascript never claims to have classes
00:58:11 <edwardk> toki78: did you build it with cabal? or just try to run it by hand?
00:58:40 <edwardk> it just built for me on 7.8.2
00:58:57 <darthdeus> johnw: haha
00:59:32 <edwardk> johnw: it is useful for running ghcjs test suites ;)
00:59:40 <toki78> edwardk, run it by hand
00:59:57 <johnw> oh, I'm sure those folks had a lot of useful things going for them too!
01:00:07 <edwardk> toki78: 'cabal install ersatz' -- then ersatz-sudoku should be installed as an executable
01:00:35 <solidus-river> darthdeus: have you checked out haste?
01:00:47 <edwardk> toki78: the error you are getting by running it by hand is probably that you are missing a dependency or it is hidden in ghc-pkg
01:01:02 <toki78> edwardk, okay thanks
01:01:11 <darthdeus> solidus-river: is that new? I've only played around with elm
01:01:19 <solidus-river> darthdeus: going to try to convince our front end web guy its a good idea
01:01:42 <solidus-river> https://github.com/valderman/haste-compiler
01:01:48 <darthdeus> solidus-river: does your frontend guy endorse haskell?
01:01:53 <darthdeus> yeah i'm looking at the repo
01:02:10 <darthdeus> is it "production ready(tm)"?
01:02:27 <solidus-river> darthdeus: nope, its going to be an uphill battle
01:08:28 <solidus-river> darthdeus: i'm not sure, it doesnt support som low level ops
01:09:01 <solidus-river> darthdeus: but as far as the size of the code it produces, its pretty far ahead of other haskell -> javascript compilers
01:44:14 <exicer_> If I want to just get the id from a row, using postgres-simple, is there some easy way to do that? Or do I have to create a datatype to represent the id ?
02:35:25 <jle`> a/b 13
02:35:56 <jle`> i wonder if i can make a plugin for my irc client that detects when i might have misstyped a command
02:36:04 <jle`> and not send it as a message >_>
02:40:47 <zcd> is there a clean way to do \(u, v) -> (Just u, v)
02:41:09 <pyon> @ty Just *** id
02:41:10 <lambdabot> (a, c') -> (Maybe a, c')
02:41:29 <pyon> zcd: that
02:41:50 <zcd> what's the *** ?
02:42:02 * zcd didn't know id can do that
02:42:15 <jle`> *** applies both functions in parallel to a tuple
02:42:24 <jle`> > ((+2) *** (*9)) (5,6)
02:42:26 <lambdabot>  (7,54)
02:42:45 <jle`> but `f *** id` is the same as `first f`
02:42:46 <pyon> zcd: *** is from Control.Arrow
02:42:54 <jle`> > first Just (2,3)
02:42:56 <lambdabot>  (Just 2,3)
02:42:57 <pyon> jle`: Oh, right, missed that.
02:43:08 <jle`> yeah, hlint actually complains on it :)
02:43:22 <zcd> arrow hmm
02:43:25 <zcd> thanks
02:44:00 <jle`> zcd: if you can think in type signatures, you can think of (***) as (***) :: (a -> b) -> (c -> d) -> ((a,c) -> (b,d))
02:44:26 <jle`> it takes an a1 -> b1, and a a2 -> b2, and returns an (a1,a2) -> (b1,b2)
02:44:32 <zcd> puts two functions side by side in the tuple?
02:44:38 <zcd> is there a name for this operator
02:44:42 <jle`> um
02:45:02 <jle`> i read it as "parallel"
02:45:11 <jle`> but i don't think that's official or anything
02:45:31 <jle`> f *** g applies f and g "in parallel" to both halves of the tuple
02:45:32 <zcd> the sparkles operator
02:45:42 <zcd> fair enough
02:45:51 <jle`> Control.Arrow also has (&&&)
02:45:55 <jle`> which might be called "split"
02:46:19 <jle`> it is (a -> b1) -> (a -> b2) -> (a -> (b1,b2))
02:46:28 <jle`> > ((+2) &&& (*9)) 7
02:46:29 <lambdabot>  (9,63)
02:46:52 <jle`> or maybe, if keeping in line with "parallel", you can call it "fork"
02:47:03 <jle`> keep in mind that it doesn't actually have to do with actual parallelism heh
02:47:11 <jle`> so maybe i shouldn't be spreading these names around
02:47:23 <zcd> as long as that's in mind, it's a good analogy
02:47:45 <zcd> the haskell docs page mentions category
02:47:52 <zcd> how much category theory is needed?
02:47:58 <jle`> hm. none, really
02:47:59 <pyon> zcd: Arrow is a sub-class of Category
02:48:11 <jle`> well, you are only using the (->) instance of Arrow/Category in this case
02:48:40 <jle`> so it's like learning fmap and (>>=) for only Maybe...which doesn' require understanding monads at all
02:48:45 <jle`> "at all"
02:48:59 <jle`> "understanding"
02:49:25 <jle`> for now, you are only using the (->) instances for Arrow and Category, which provide your (***) and (&&&) and first and second for (->)
02:49:51 <zcd> so an arrow might not refer to ->
02:50:00 <jle`> there are other Arrows that have their own (***) and (&&&) and first and second, but you don't really need to know about that in order to use the (->) instance
02:50:18 <jle`> it's like you can use fmap for lists without understanding that there are other Functors out there
02:50:30 <zcd> fair enough
02:53:47 <zcd> is the makefile system commonly used for haskell projects?
02:54:43 <jle`> zcd: hm. no, not really
02:54:50 <jle`> from what i know
02:55:54 <jle`> i think some large systems might still use it, but usually, some combination of cabal, ghc, and other build dsl's like shake are used
02:55:59 <ion> You use cabal for building Haskell projects.
02:56:17 <ion> in general
02:56:41 <jle`> i use cabal mostly, and cabal+shake for some automation
02:59:11 <zcd> oh my cabal is convenient
03:00:53 <kristi_kodare> In https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon, what does the * in (data Move a :: *) mean? ^^
03:02:45 <k00mi> kristi_kodare: that's a kind signature, it means 'Move a' is a type
03:02:49 <k00mi> * is the kind of types
03:03:08 <kristi_kodare> ok thanks but does it mean "any type"?
03:04:31 <k00mi> every type has kind *
03:04:46 <k00mi> a type constructor, like Move, has kind * -> *
03:05:38 <kristi_kodare> k00mi thanks i never knew that
03:36:22 <jle`> > (0$0 !!)
03:36:24 <lambdabot>  The operator ‘GHC.List.!!’ [infixl 9] of a section
03:36:24 <lambdabot>      must have lower precedence than that of the operand,
03:36:24 <lambdabot>        namely ‘GHC.Base.$’ [infixr 0]
03:36:24 <lambdabot>      in the section: ‘0 $ 0 !!’
03:36:29 <jle`> sneaky
03:36:36 <deni> anyone uses vim with dag/vim2hs script? is there a way to make it not fold stuff by default?
03:43:14 <rtpg> may
03:43:17 <rtpg>  huh, did the haskell platform packaging stall recently? The main page says that 2013.4 is expected for November 2013 and we're already in
03:48:27 <merijn> rtpg: What happened is the following:
03:49:20 <merijn> rtpg: OSX 10.9 ditched gcc and thereby broke GHC, this was being fixed in GHC, so people wanted to wait for release of that so that the haskell platform would actually work on OSX
03:50:09 <fizruk> deni: set nofoldenable ?
03:50:32 <merijn> Then, the fix turned out to be more complex than would work in 7.6, so it was punted to 7.8. At which point there was a question: Should HP re-release 7.6, knowing it's broken on OSX or wait for 7.8, after a discussion it was decided that 7.8 fixing OSX and having several other highly anticipated features platform would be postponed until 7.8
03:51:00 <merijn> rtpg: So now that 7.8 has been released people started working on a platform release again, but I believe there are still some issues slowing down progress
03:51:15 <merijn> So it's "any moment now"
03:55:04 * hackagebot profunctors 4.0.4 - Profunctors  http://hackage.haskell.org/package/profunctors-4.0.4 (EdwardKmett)
04:02:36 <Jefffrey> Morning.
04:04:03 <identity> deni: I use vim2hs, and I believe there is a way to do this, because I found it annoying as well and managed to make it stop
04:04:58 <identity> deni: I added: "let g:haskell_conceal = 0" and "autocmd FileType haskell setlocal nofoldenable"
04:09:10 <smiller2> Hey guys, which FRP library would you recommend for GUI?
04:14:03 <deni> identity: fizruk ok tnx that worked
04:20:07 * hackagebot Spock 0.4.4.1 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.4.1 (AlexanderThiemann)
04:27:57 <lechip> hello all, im truing to make a funciton to generate rational numbers that map to natural numbers like Cantors diagonal argument using lazy evluation but im having trouble generating the sequence
04:29:10 <lechip> so far i got this http://pastebin.com/raw.php?i=FVpFDhvf
04:29:32 <lechip> but i think i went away from the lazy evaluation
04:32:39 <lechip> the cantor goes like this http://imgur.com/5FelZtf
04:34:35 <vanila> lechip, you could build a tree of rational numbers, then use a lazy breadth first traversal to get the list
04:35:14 <vanila> if you want to go with the grid you could just enumerate the coordinates, then map the function over that list
04:35:33 <lechip> naturally the grid is just to show how it goes
04:35:47 <lechip> i could use the tree but how could i generate it?
04:35:59 <lyxia> lechip, what you are doing looks like a filter.
04:36:08 <lyxia> generate all pairs (x,y)
04:36:17 <lyxia> Take out all those that aren't coprime pairs
04:36:20 <lechip> thats what im having problem with
04:36:23 <lechip> how to generate them
04:36:37 <lechip> because i dont know what to use to make all the combinations
04:36:41 <lyxia> map (uncurry (%))
04:36:57 <lechip> im using rational
04:37:02 <lechip> thats where the % comes from
04:37:14 <lyxia> > [(x,y) | x <- [1..], y <- [1..]]
04:37:15 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
04:37:19 <lyxia> uh
04:37:33 <lyxia> nevermind that please ^
04:37:54 <lechip> tried that but never switches to the pairs that go like (2,1) (2,2)...
04:37:55 <pyon> > [(n,d) | s <- [1..], n <- [0..s-1], d = s-n, gcd n d == 1]
04:37:56 <lambdabot>  <hint>:1:39: parse error on input ‘=’
04:38:07 <pyon> Aw, there is no let?
04:38:30 <pyon> I mean, in list comprehensions.
04:38:32 <merijn> abot>  <hint>:1:39: parse error on input ‘=’
04:38:35 <merijn> hmm
04:38:38 <merijn> misspaste
04:39:07 <merijn> > [(n,d) | s <- [1..], n <- [0..s-1], let d = s-n in gcd n d == 1]
04:39:09 <lambdabot>  [(0,d),(1,d),(1,d),(2,d),(1,d),(3,d),(1,d),(2,d),(3,d),(4,d),(1,d),(5,d),(1,...
04:39:28 <merijn> hah
04:39:33 <ion> > [(n,d) | s <- [1..], n <- [0..s-1], let d = s-n, gcd n d == 1]
04:39:34 <lambdabot>  [(0,1),(1,1),(1,2),(2,1),(1,3),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(5,1),(1,...
04:39:41 <pyon> That.
04:39:53 <merijn> pyon: There are no implicit let's, no
04:40:06 <pyon> I just realized I had forgotten to type the keyword let!
04:40:08 <pyon> My bad.
04:40:29 <merijn> lyxia: Right, because the second list infinite it never terminates to move on to the second entry of the first list :)
04:40:44 <lyxia> Yeah ^^'
04:41:01 <merijn> Actually, if you restrict yourself to Int it'd work
04:41:05 <lechip> damn, i am having a problem wrapping my ead around it
04:41:23 <pyon> > tail [(m,d) | s <- [1..], n <- [0..s-1], let d = s-n, gcd n d == 1, m <- [n,-n]]
04:41:24 <lambdabot>  [(0,1),(1,1),(-1,1),(1,2),(-1,2),(2,1),(-2,1),(1,3),(-1,3),(3,1),(-3,1),(1,4...
04:43:38 <merijn> > drop maxBound [(n,d) | s <- ([1..] :: [Int]), n <- [0..s-1], let d = s-n, gcd n d == 1]
04:43:42 <lambdabot>  mueval-core: Time limit exceeded
04:43:45 <merijn> awww
04:43:56 <pyon> :-(
04:43:58 <merijn> oh
04:43:59 <merijn> Wait
04:44:03 <merijn> lambdabot is 64 bit xD
04:44:08 <merijn> > maxBound
04:44:09 <lambdabot>  ()
04:44:11 <merijn> > maxBound :: Int
04:44:12 <lambdabot>  9223372036854775807
04:44:19 <merijn> That might take a while...
04:44:39 <rhaps0dy> so umm
04:44:49 <rhaps0dy> I'm reading learn you a haskell
04:44:56 <rhaps0dy> and am in the 'solving problems functionally' part
04:44:58 <lechip> that book rocks
04:45:05 <rhaps0dy> and I decided to try them on my own before reading further
04:45:07 <rhaps0dy> http://hastebin.com/zahalibose.coffee
04:45:16 <rhaps0dy> how do I fix this ?
04:45:46 <lechip> that book rocks'
04:45:54 <lechip> why r u doing show?
04:45:56 <rhaps0dy> yeah
04:46:00 <rhaps0dy> umm
04:46:03 <rhaps0dy> is it not good?
04:46:12 <rhaps0dy> it's the way I found of printing whatever output my functions give to screen
04:46:15 <rhaps0dy> for testin'
04:46:45 <rhaps0dy> err the 'do' is kind of superfluous but I used to have two lines and I left it there
04:46:49 <lechip> print already does the show
04:47:00 <lechip> as far as i knpw
04:47:09 <ion> Try removing the type signature and looking at the inferred type.
04:47:24 <lechip> ^
04:47:30 <lechip> is easier that way
04:47:42 <ion> print = putStrLn . show
04:47:59 <rhaps0dy> ion: oh, thanks
04:48:06 <rhaps0dy> the problem is that length returns Int
04:48:15 <rhaps0dy> and the compiler expects a Num
04:48:34 <ion> There's also genericLength
04:48:56 <rhaps0dy> right
04:49:02 <Cale> and/or you could use fromIntegral to convert the Int
04:49:20 <rhaps0dy> Cale: thanks, this is what I was looking for
04:49:33 <rhaps0dy> but I thought Int /= Integral ?
04:49:44 <Cale> Integral is a type class which Int is an instance of
04:49:54 <merijn> :t fromIntegral
04:49:55 <lambdabot> (Num b, Integral a) => a -> b
04:50:09 <rhaps0dy> ooh alright
04:50:11 <Cale> fromIntegral converts from any instance of Integral to any instance of Num at all
04:50:20 <merijn> @quote who.do.you.call
04:50:20 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
04:50:26 <Cale> ahaha
04:50:45 <rhaps0dy> hehe
04:50:59 <lechip> take 10 [(n,d) | s <- [1..], n <- [1..s-1], let d = s-n]
04:51:07 <rhaps0dy> yep, it works perfectly now, thank you
04:51:37 <lechip> can somebody explain to me the comprehension on that expression?
04:51:43 <merijn> rhaps0dy: Note, that if you compile with -Wall (which you should!) it is probably complaining about "defaulting "Num a => Maybe a" to "Maybe Int"
04:51:53 <lechip> im confused on how to interpret lets into comprehensions
04:52:00 <rhaps0dy> merijn: it gave me an error on that
04:52:02 <rhaps0dy> that was my problem
04:52:08 <rhaps0dy> now I use fromIntegral
04:52:14 <rhaps0dy> oh myabe that gives the warning
04:52:41 <merijn> rhaps0dy: It will still give a warning if you compile with -Wall (which does other neat things like warning you about missing cases!)
04:52:58 <Cale> lechip: The definitions made in the let scope over all following generators and guards, as well as the term before the |
04:53:35 <rhaps0dy> merijn: ghc -Wall rpn gives no warning with this code http://hastebin.com/rimeyabavi.coffee
04:53:45 <lechip> Cale: wi si like doing a where?
04:53:46 <Cale> lechip: It means exactly what you'd expect it to mean here: d is defined to be equal to s - n, and it's allowed to show up in the (n,d) before the |
04:53:47 <ion> let a = b in a list comprehension is equivalent to a <- [b]
04:53:56 <merijn> hmm, that's actually surprising to me
04:53:58 <lechip> Cale: ty
04:53:59 <Cale> It's like doing a where, only you have access to the variables bound by the comprehension
04:54:12 <merijn> I would expect print to default
04:54:23 <Cale> That comprehension is the same as take 10 [(n,s-n) | s <- [1..], n <- [1..s-1]]
04:54:23 <lechip> excellent
04:54:44 <merijn> rhaps0dy: It does here :)
04:55:02 <ion> merijn: length returns an Int, there's no defaulting involved.
04:55:04 <rhaps0dy> ip
04:55:07 <rhaps0dy> rip *
04:55:18 <merijn> ion: He uses fromIntegral to return Num a in that snippet
04:55:20 <ion> Oh, that one
04:55:22 <merijn> rhaps0dy: http://lpaste.net/103975
04:55:57 <lechip> now my question is why take 10 [(n,d) | s <- [1..], n <- [1..s-1], let d = s-n] does not generate pairs like (0,something)
04:55:59 <merijn> rhaps0dy: Basically, it's saying "You only told me this is both 'Num a' and 'Show a', but not what 'a' is, so I'm arbitrarily selecting 'Integer'"
04:56:18 <rhaps0dy> welp
04:56:23 <rhaps0dy> I swear it doesn't give me anything
04:56:24 <Cale> lechip: n is never 0
04:56:29 <rhaps0dy> there is something wrong maybe?
04:56:32 <Cale> lechip: because the list [1..s-1] never contains 0
04:56:56 <Cale> (and n is picked from that list)
04:57:03 <merijn> rhaps0dy: I just wanted to clarify in case that happened. You can solve this problem by annotating the result of solveRPN to tell GHC explicitly what you expect of it
04:57:11 <rhaps0dy> Cale: but s-n can be zero
04:57:17 <Cale> yes
04:57:18 <lechip> but d is s - n and both get the value 1 at some point dont they?
04:57:25 <rhaps0dy> merijn: wait
04:57:29 <rhaps0dy> so what should I do?
04:57:30 <lechip> so actually the question is why is it never (something, 0)
04:57:57 <rhaps0dy> merijn: did you give it a type signature?
04:57:58 <merijn> rhaps0dy: for example "print (solveRPN "10 4 3 + 2 * -" :: Maybe Double)" (or whatever you wanted it to print
04:58:00 <Cale> lechip: aha!
04:58:21 <Cale> lechip: when s = 1, you have n <- [1..1-1] which is [1..0]
04:58:26 <Cale> But [1..0] is an empty list
04:58:29 <merijn> rhaps0dy: In fact, try that code an try replacing Double with different types, like Int, Ratio Int, etc. and compare the difference!
04:58:41 <Cale> because there aren't very many numbers which are both greater than or equal to 1, and less than or equal to 0
04:58:41 <rhaps0dy> b-but I don't get warnings
04:58:48 <rhaps0dy> I'll try it anyways
04:58:56 <lechip> Cale: GENIUS i did not noticed that!
04:58:57 <merijn> rhaps0dy: Without warnings it should still change what happens :)
04:58:57 <Cale> > [1..0]
04:58:59 <lambdabot>  []
04:59:18 <lechip> Cale: absolutely!
04:59:25 <merijn> rhaps0dy: And if it doesn't, then you're not running the code you think you're running :)
04:59:52 <rhaps0dy> ugh
05:06:13 <lechip> is this awesome or what? http://lpaste.net/103976
05:09:36 <rhaps0dy> lechip: couldn't you reduce the whole list to just one number?
05:09:44 <rhaps0dy> as it doesn't dpeend on previous calculations
05:09:49 <rhaps0dy> or maybe ghc does that for you?
05:10:11 <lechip> it gives one number
05:10:21 <lechip> hene the !! in the end
05:10:22 <rhaps0dy> I mean
05:10:29 <lechip> hence*
05:10:33 <rhaps0dy> write it as a direct calculation
05:10:35 <rhaps0dy> give me a second
05:10:38 <lechip> allright
05:10:43 <rhaps0dy> oh wait
05:10:56 <rhaps0dy> it does depend on previous members
05:10:58 <rhaps0dy> sorry
05:11:11 <rhaps0dy> because it depends on the number of primes until then
05:11:16 <lechip> yeah thats why i was so confused before
05:15:00 <vanila> lechip, have you seen this
05:15:12 <vanila> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:15:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:16:17 <lechip> vanila: brilliant!
05:19:17 <rhaps0dy> vanila: holy shit
05:19:33 <Cale> Yeah, that's the standard trick :)
05:20:28 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
05:20:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:21:08 <Cale> > fix ((0:) . scanl (+) 1)
05:21:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:22:38 <Cale> > nubBy (\x y -> gcd x y /= 1) [2..]
05:22:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:22:48 <Cale> ^^ much slower, but cute nonetheless
05:23:38 <darthdeus> guys anyone here using hdevtools? I'm getting "Import.hs:18:2: lexical error at character 'i'" on #if
05:24:24 <Cale> darthdeus: are you on Mac OS?
05:24:28 <darthdeus> yes
05:24:51 <Cale> I think this is supposed to help? http://www.haskell.org/platform/mac.html
05:25:14 * hackagebot temporary 1.2.0.3 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.2.0.3 (MaxBolingbroke)
05:25:30 <Cale> I'm not on a mac, but if I recall correctly the problem has to do with the CPP being different
05:25:47 <rhaps0dy> yes it is
05:25:53 <rhaps0dy> it only preprocesses half of the things
05:25:55 <darthdeus> Cale: hmm, so I basically need to recompile everything with gcc instead of clang?
05:25:58 <rhaps0dy> or so
05:26:18 <Cale> There's a wrapper script
05:27:39 <Cale> I think just installing that script should hopefully fix things, though you could install gcc and point GHC at it
05:27:55 <Cale> https://gist.github.com/cartazio/7131371 -- the instructions for how to do that
05:28:04 <darthdeus> thanks, though I already had gcc when I installed haskell platform
05:28:33 <darthdeus> i'll dig into this
05:30:02 <darthdeus> hmm this is weird, I already have gcc-4.2 set as the C compiler command in the settings
05:34:22 <darthdeus> Cale: now that i've added the wrapper, do i need to reinstall all of the packages right?
05:35:04 <Cale> darthdeus: I honestly don't knwo
05:35:29 <darthdeus> i guess nothing bad can really happen if i try
05:35:51 <FUZxxl> What's #haskell's stance on this article? http://techblog.bozho.net/?p=1423
05:37:04 <vanila> looks like spam
05:37:13 <darthdeus> didn't seem to help, still getting that lexical error :\
05:37:46 <Maior> FUZxxl: I am not #haskell, and I haven't finished the article, but ime code written by academic scientists has tended to be the worst I've seen
05:38:09 <darthdeus> but I guess I can just ignore this for now
05:38:11 <Cale> FUZxxl: It's somewhat true. Scientists are often interested in just getting things done in their domains, and don't really have much time to care about code quality.
05:38:27 <Maior> FUZxxl: I have finished the article. I agree with it mostly.
05:38:59 <Cale> Of course, they'd like things to be correct...
05:39:24 <Maior> (modulo some nuance about reasons / incentives - it's rarely been (ime) about "lack of concern", rather, lack of time / resources)
05:39:59 <Maior> "I would like to make this code suck less but I've no idea how, no idea who to ask, and no time because I need to sort experiments and funding and stuff"
05:40:14 <Cale> right
05:40:17 * hackagebot binary 0.7.2.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.2.0 (LennartKolmodin)
05:40:24 <tremon> but it's hurting the scientific effort as well, though. When I did my MSc, there were ten copies of the codebase lying around, because every PhD student broke the code while working on their own "domain".
05:40:27 <Maior> and lots of it being relatively self-contained
05:40:52 <Maior> tremon: absolutely, but it's viewed as a secondary cost that's hard to justify
05:41:08 <Maior> tremon: try telling a small tech startup that they should invest in HR and managers
05:41:32 <interpol_agent> hackagebot: hire someone
05:41:34 <Cale> Wouldn't it be great to have high performance numerical stuff integrated into a system like Coq or Agda where you could also prove things about it? :)
05:42:01 <tremon> of course, but the result of it was that every new student had to reinvent the wheel, even though the "theory" had already been published, they still had to reimplement all those things
05:42:09 <Maior> interpol_agent: ...eh?
05:42:12 <Maior> tremon: yep
05:42:54 <joe_k> [HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions]
05:42:54 <interpol_agent> just that you said you'd like to fix the code but have no time...hence, hire another programmer to do it
05:43:46 <Maior> interpol_agent: it was the fact you addressed it to hackagebot that threw me
05:44:10 <interpol_agent> ya, not sure why that happened...can be the coffee jitters
05:44:34 <Maior> interpol_agent: meanwhile, that's perhaps viable for "industry academics" (even then, from what I've seen, they rarely have the budget) and it's absolutely not for, well, "academics"
05:45:30 <darthdeus> hmm it seems ghc 7.8 is compatible with xcode5 and clang ... anyone knows an easy way to upgrade when i have 7.6.x installed via homebrew?
05:46:31 <rhaps0dy> brew update? I honestly have no idea, I'm fairly new to os x
05:46:50 <darthdeus> i'm a bit confused why there is only the rc2 in the formula though https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ghc.rb since 7.8.2 seemed to be released a month ago
05:46:53 <interpol_agent> yes true, more for non academics...mind you, it can be surprising what you get when you ask for help
05:46:54 <saml_> osx is good for photoshop
05:47:24 <interpol_agent> sometimes a programmer is just looking for experience so will do it for little or no cost
05:47:28 <darthdeus> rhaps0dy: yeah though that says only 7.6.3 as stable and 7.8.0 as devel
05:47:58 <darthdeus> but here it says 7.8.2 released https://www.haskell.org/ghc/ :(
05:48:20 <rhaps0dy> darthdeus: maybe the homebrew maintainers are sloppy? hehe
05:48:28 <rhaps0dy> there has to be a force option
05:48:30 <darthdeus> yeah :\ but i'm scared to compile it myself
05:48:46 <saml_> darthdeus, tried this? http://www.haskell.org/ghc/download_ghc_7_8_2#macosx_x86_64
05:49:04 <saml_> add that to your PATH, and recompile cabal-install and all other packages you use
05:49:21 <darthdeus> saml_: but i have haskell-platform installed, isn't that like all entangled together?
05:50:08 * darthdeus has no clue how haskell-platform works
05:52:03 <saml_> then wait until haskell paltform upgrades ghc
05:52:32 <darthdeus> when does that usually happen?
05:52:45 <saml_> i don't know.. i'm not using haskell platform
05:58:11 <awestroke> saml_: what's your setup? custom-compiled ghc + cabal and the rest as cabal packages?
05:58:35 <saml_> yes
05:58:40 <saml_> not custom compiled ghc
05:59:02 <saml_> i use archlinux. has ghc and cabal as package
06:05:20 * hackagebot persistent 1.3.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.1 (MichaelSnoyman)
06:15:07 <pyon> Is it possible to have "higher-kinded constraints"?
06:16:10 <pyon> e.g., something like "instance (Show a, (Show a => Show (f a))) => Show Free f a where"
06:18:37 <ddere> pyon: wouldnt "instance (Show a, Show (f a)) => Show Free f a where" work in that case?
06:20:34 <pyon> ddere: I haven't really thought this through.
06:20:59 <ddere> pyon: hehe, well i think it will
06:21:00 <pyon> ddere: But I think I will need a "Show (f (Free f a))" instance as an intermediate result.
06:21:13 <ddere> oh
06:21:18 <ddere> yeh true
06:22:22 <ddere> i might not be the best to comment, but im not sure its possible, in that that constraint doesnt look to me like it reduces
06:22:39 <johnchen902> @pl (\x->(length x, head x))
06:22:40 <lambdabot> liftM2 (,) length head
06:23:25 <pyon> So, basically, there is no way to make a "Show (Free f a)" instance, even if "Show a" and "Show b => Show f b" ? :-(
06:24:06 <ddere> pyon: I don't *think* so, but i hope someone can correct me if i am wrong
06:25:01 <ddere> pyon: are you sure you need the show instance for the generic f?
06:25:38 <pyon> ddere: Yes. "data Free f a = Pure a | Roll (f (Free f a))"
06:25:55 <pyon> ddere: "f" is applied to "Free f a", not to "a" directly.
06:26:15 <ddere> pyon: oh i see, you are writing your own free monad definition as an exercise or something?
06:26:33 <ddere> pyon: sorry thought you were working with the one on hackage
06:27:42 <pyon> ddere: Isn't the one from Hackage just like that? (The one from Control.Monad.Free, not the one from Control.Monad.Free.Church)
06:28:25 <ddere> pyon: yeh it just names things differently
06:28:29 <pyon> Ah!
06:28:56 <ddere> pyon: you can probably get away with "instance (Show a, (Show a => Show (f (Free f a)))) => Show Free f a where"
06:29:43 <ddere> err
06:29:44 <pyon> Gonna try that!
06:30:36 <ddere> pyon: sorry i mean: "instance (Show a, Show (f (Free f a))) => Show Free f a where"
06:31:02 <ddere> pyon: that reduces
06:32:01 <pyon> :-O So instances can be recursive? (not instance methods, instances themselves)
06:35:49 <merijn> pyon: Yes
06:36:24 <merijn> pyon: Consider 'instance Show a => Show (Maybe a) where show (Just x) = "Just " ++ show x'
06:37:02 <darthdeus> hmm so i've just installed ghc from the download page (and uninstalled old ghc and haskell platform), should I now download cabal-install and build it manually?
06:37:06 <merijn> Which is also effectively recursive already, since "Maybe (Maybe Int)" is an instance of Show due to Maybe Int being one
06:37:07 <darthdeus> since I dont seem to have it
06:37:28 <merijn> darthdeus: Yes, there are plans to provide a binary download for cabal, but I don't think it exists yet
06:37:38 <darthdeus> merijn: actually there is http://www.haskell.org/cabal/download.html :)
06:38:00 <merijn> darthdeus: FYI, if you just wanted to use a new GHC you could actually just have installed a new GHC and used your old cabal to install cabal for your new GHC
06:38:07 <Eduard_Munteanu> pyon: not general recursion though (as in "might not terminate"), unless you enable certain compiler flags.
06:38:30 <darthdeus> merijn: hmm, but I got told to recompile all the packages, so I thought it's easier to just wipe it clean :) i didn't have much installed
06:39:09 <merijn> darthdeus: GHC maintains separate databases per GHC version, so it's actually trivial to have multiple GHCs installed in parallel (you would indeed have to install everything from scratch again for the new GHC)
06:39:22 <darthdeus> hmm
06:39:27 <darthdeus> that's smart
06:39:29 <darthdeus> but too late :D
06:40:18 <merijn> darthdeus: Usually I will have a version of the platform installed and then keep the next GHC version and/or HEAD installed in ~/ghc, which lets me switch by just adding ~/ghc/bin to my PATH (cabal will automatically use whatever comes first in your path)
06:40:24 * hackagebot digest-pure 0.0.3 - Pure hash functions for bytestrings  http://hackage.haskell.org/package/digest-pure-0.0.3 (DanielDeKok)
06:40:32 <merijn> darthdeus: Something to keep in mind for the future :)
06:40:49 <darthdeus> merijn: so i can have one cabal for multiple ghc installs?
06:41:06 <merijn> darthdeus: Yes
06:41:08 <pyon> ddere: merijn: Whoa, thanks! Success!
06:41:15 <darthdeus> awesome :O
06:41:38 <pyon> http://ideone.com/ym3OTE
06:42:44 <ddere> pyon: no problem :)
06:42:50 <merijn> pyon: You can put pretty arbitrary constraints on your typeclass instances :)
06:43:02 <merijn> And with some GHC extensions you can do even funkier things :p
06:43:36 <pyon> For some reason, I expected to need a constraint like "forall b. Show b => Show f b", and internally make it so that "b = Free f a".
06:43:48 <pyon> s/=/~/
06:44:03 <merijn> pyon: You can encode equality as a constraint too
06:44:06 <Eduard_Munteanu> pyon: you might want Show (f a)
06:44:22 <pyon> Eduard_Munteanu: How would "Show f a" help?
06:44:23 <ddere> pyon: is that Functor f constraint required in your Show instance?
06:44:33 <ddere> pyon: it doesnt look to me like it gets used
06:44:58 <merijn> pyon: "(b ~ Free f a) => <something>" <- this requires 'b' to unify with 'Free f a'
06:44:59 <pyon> ddere: Ah, right.
06:46:19 <merijn> > let foo :: (a ~ Int) => a -> a; foo = (+1) in foo 3
06:46:21 <lambdabot>  4
06:46:25 <darthdeus> this is probably another dumb question, but i've rm -rfed ~/.ghc and ~/.cabal, but if i do something like cabal install yesod, it tells me that it's already installed ... did i miss something?
06:46:34 <darthdeus> i remember last time i did something like ghc-pkg unregister on all the packages
06:46:35 <merijn> darthdeus: OSX?
06:46:37 <darthdeus> yes
06:46:40 <ddere> pyon: btw. just out of curiousity, how did you choose the name "Roll"?
06:46:49 <ddere> pyon: (it looks like cool work btw :) )
06:47:05 <merijn> darthdeus: OSX uses different default directories to match the OS layout, check under ~/Library/Haskell
06:47:35 <merijn> darthdeus: FYI, the platform comes with an uninstaller for OSX
06:47:41 <pyon> ddere: I saw that name elsewhere.
06:47:51 <ddere> pyon: ah ok :)
06:47:59 <darthdeus> merijn: I installed it via homebrew though, so it was in /usr/local/Cellar/{haskell-platform,ghc}, I've got nothing in my ~/Library or /Library
06:48:06 <simon____> darthdeus, I think some people recommend placing the yesod libraries in a cabal sandbox. I personally couldn't make the damn thing work before I did it.
06:48:11 <merijn> darthdeus: ah, I have no clue about homebrew
06:48:22 <pyon> With ConstraintKinds, anything that has kind Constraint can be used in an instance head, right?
06:48:24 <klrr_> anyone know how you hide information in optparse-applicative?
06:48:30 <merijn> pyon: Yes
06:48:32 <darthdeus> simon____: yeah i have it in sandbox in my app, but i still want to have it globally for the generator
06:48:41 <ddere> pyon: anyway it looks cool, free monads are awesome :)
06:48:51 <darthdeus> merijn: is there a way to find out via ghc-pkg where the packages are being cached?
06:48:56 <merijn> pyon: Or rather, anything with kind Constraint can be used anywhere you can use constraints... :p
06:48:58 <darthdeus> because i'm like 99% sure it was in ~/.ghc
06:49:16 <merijn> darthdeus: It print the location before the packages, no?
06:49:28 <merijn> first line shows a path for me when I run "ghc-pkg list"
06:49:32 <rhaps0dy> >simon____
06:49:33 <rhaps0dy> holy shit
06:49:44 <rhaps0dy> 2many underscores
06:50:06 <merijn> pyon: Lemme once again pimp my neat ConstraintKinds abuse example: https://gist.github.com/merijn/6130082
06:50:15 <Eduard_Munteanu> pyon: er, nevermind, I misread
06:50:20 <merijn> (7.8 only)
06:50:25 * hackagebot cond 0.4.1 - Basic conditional and boolean operators with monadic variants.  http://hackage.haskell.org/package/cond-0.4.1 (AdamCurtis)
06:50:27 * hackagebot tagged-transformer 0.6.5 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6.5 (MatveyAksenov)
06:50:39 <darthdeus> merijn: yeah, but ... check this out https://gist.github.com/darthdeus/7534b1db1a786fb6e473
06:50:50 <pyon> merijn: let me see :-)
06:51:07 <darthdeus> if i try to install it it tells me that it would have to reinstall, then ghc-pkg list shows the 7.8.2 path, and ghc-pkg unregister tells me it can't unregister it
06:51:17 <merijn> darthdeus: Try just nuking that path and then reinstalling?
06:51:23 <pyon> "<ddere> pyon: anyway it looks cool, free monads are awesome :)" yes :-)
06:51:33 <darthdeus> yeah I guess :(
06:51:42 <darthdeus> oh never mind i'm retarded
06:51:54 <darthdeus> it only tells me that HTTP-4000.2.15 would get broken
06:51:54 <ddere> merijn: nice :)
06:52:01 <darthdeus> yesod itself isn't installed
06:53:34 <merijn> ddere: Or, a binary tree that allows no more than 3 children total: https://gist.github.com/merijn/9530680 :)
06:53:40 <darthdeus> so the only way to do this correctly is to re-download and re-compile everything in each sandbox every time? isn't there a way to cache big things like yesod, so that each sandbox can just reuse the cache?
06:54:18 <merijn> darthdeus: You can share sandboxes, yes
06:54:20 <Eduard_Munteanu> darthdeus: btrfs snapshots perhaps? :)
06:54:32 <merijn> darthdeus: Don't ask me how, though
06:54:44 <smiller2> Would anybody here who has any experience with FRP suggest I choose something other than netwire for a GUI program?
06:54:49 <simon____> darthdeus, I haven't figured out a way, so I just did a naked sandbox with yesod which I'd copy in as my base for new projects. it was a little tedious as it was 200M+
06:54:55 <merijn> smiller2: Yes
06:55:08 <pyon> Mmm, apparently, this is not a valid kind: forall b. Show b -> Show b :-(
06:55:10 <merijn> smiller2: Including the guy who wrote netwire ;)
06:55:39 <Eduard_Munteanu> pyon: sure it isn't, it's mixing stuff from different levels.
06:55:43 <merijn> smiller2: mm_freak's recommendation is: reactive-banana for GUI frameworks, netwire for games, networking, etc.
06:55:44 <darthdeus> simon____: does that actually work?
06:56:02 <merijn> Eduard_Munteanu: No, that should be a correct type given some extensions
06:56:04 <simon____> darthdeus, well, sure. a sandbox with just yesod and all its dependencies is as good as another sandbox with the same content.
06:56:04 <Eduard_Munteanu> pyon: Show b :: Constraint, (->) :: * -> * -> *
06:56:14 <pyon> Eduard_Munteanu: Oh.
06:56:17 <merijn> Eduard_Munteanu: That's not the kind of (->)
06:56:27 <merijn> :kind (->)
06:56:30 <Eduard_Munteanu> Well, if you mean PolyKinds I suppose so.
06:56:33 <merijn> @kind (->)
06:56:34 <lambdabot> * -> * -> *
06:56:37 <merijn> hmm
06:56:39 <merijn> That's not right
06:56:46 <darthdeus> simon: awesome, thanks :)
06:56:52 <darthdeus> Eduard_Munteanu: i have no clue what btrfs is :)
06:57:03 <Eduard_Munteanu> But the forall looks impredicative.
06:57:07 <merijn> Eduard_Munteanu: Even without PolyKinds -> is more general than that
06:57:08 <smiller2> merijn: That's brilliant, thanks!  I'm also curious why netwire wouldn't work for GUIs.  Is there some fundamental flaw that prevents it from being general enough?
06:57:29 <klrr_> anyone know how to modify the "Usage <prog> BLABLALBA" message in optparse-applicative? because mine is approximatly 150 collums :/
06:57:47 <Eduard_Munteanu> darthdeus: a filesystem with copy-on-write snapshots
06:57:53 <merijn> smiller2: Not really, but most GUI frameworks rely on callbacks and they don't integrate cleanly with netwire. reactive-banana was designed around callbacks (and is therefore cumbersome for networking, etc.)
06:58:19 <merijn> Eduard_Munteanu: Consider the paste I just linked which has a kind signature for a GADT without PolyKinds enabled
06:58:51 <merijn> Eduard_Munteanu: https://gist.github.com/merijn/9530680 Here I have a kind signature "Nat -> * -> *", which wouldn't work if (->) was "* -> *"
06:58:51 <simon> darthdeus, "btrfs" = better filesystem, some new Linux filesystem project
06:58:56 <merijn> errr
06:59:00 <merijn> "* -> * -> *"
06:59:01 <darthdeus> ah, i dont haz linux :)
06:59:05 <Eduard_Munteanu> Ah, yeah.
06:59:16 <pyon> In any case, what I want to do is "parametrize an instance over another parametrized instance".
06:59:25 <merijn> Eduard_Munteanu: I believe the report or GHC manual describing -> as having kind "? -> ?? -> *"
06:59:32 <no-n> some say zfs is the best
06:59:53 <no-n> i don't really have an opinion
06:59:56 <Eduard_Munteanu> merijn: that's pretty old though, and it refers to *-like kinds.
07:00:09 <Eduard_Munteanu> Like * and #.
07:00:23 <merijn> pyon: Like have a function "(* -> Constraint) -> (* -> Constraint)"
07:00:26 * hackagebot HueAPI 0.1.4 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.1.4 (SjoerdVisscher)
07:00:33 <merijn> pyon: ?
07:01:07 <pyon> merijn: An instance with a head is, in a sense, a function from instances to instances, right?
07:01:37 <pyon> What I want is a higher-order function.
07:01:38 <merijn> pyon: tbh, for this kind of hackery it's probably easier to use TypeFamilies than using complicated instance definitions
07:01:57 <Eduard_Munteanu> pyon: you could read 'instance <X> => <Y>' as '<Y> = <X>'
07:02:00 <pyon> Ah!
07:02:06 <merijn> pyon: TypeFamilies gives you type level functions (which can do things like returning constraints, for example)
07:02:35 <merijn> pyon: Did you see my example using Restrict?
07:02:50 <pyon> merijn: Yes, but I am afraid I do not understand what is going on in there. :-(
07:02:59 <Eduard_Munteanu> Not an actual equality but it lets you reason about recursion.
07:03:14 <merijn> pyon: Basically, it's defining a type level function that takes a type and a list of types and returns a Constraint
07:03:32 <merijn> pyon: I then use applications of that function as a Constraint on functions
07:03:43 <Eduard_Munteanu> E.g. Show (Maybe (Maybe a)) ~= Show (Maybe a) ~= Show a
07:03:48 <merijn> pyon: So "Restrict :: * -> [*] -> Constraint"
07:04:15 <pyon> merijn: Ah!
07:04:27 <merijn> "Restrict Int [Char]" computes to "()" (or the empty Constraint which is always true)
07:05:00 <merijn> pyon: "Restrict Int [Int]" computes to "("Error!" ~ "Tried to apply a restricted type!")" which can never hold because those two never unify
07:05:24 <pyon> merijn: Makes sense!
07:05:29 <merijn> So if the type checker infers 'a' is 'Int' in my example, it will produce a type error about the Constraint not holding
07:05:51 <pyon> This is a closed type family, right?
07:06:13 <merijn> pyon: FYI, the "Fun with Type Functions" paper explains TypeFamilies and is very readable, if you wanna explore with these things I recommend reading it
07:06:16 <merijn> pyon: Yes
07:06:43 <Eduard_Munteanu> Also note instance resolution normally picks the right hand side of '=>' irrespective of the lhs, so you can put something which will never check in the lhs to trigger an error message.
07:07:03 <merijn> pyon: The difference being that with open type families other people can define their own instances (like with typeclasses), closed type families prohibit the creation of new instances (the recursion I use would break if you use open families)
07:07:04 <pyon> merijn: I do understand type families. (Although normally I only use associated families. Free-floating families look to me like they break parametricity. :-|)
07:07:48 <merijn> pyon: And due to the fixed set of instances it means the instances can have an "order" that is check in sequence (like here), so overlap is not an issue
07:07:59 <pyon> Ah!
07:08:08 <pyon> So, basically, pattern-matching with types, right?
07:08:14 <merijn> pyon: Yeah
07:08:25 <johnchen902> @pl (\b -> (replicate (fst b) (head.snd $ b)) ++ (decode.tail.snd $ b))
07:08:26 <lambdabot> ap ((++) . liftM2 replicate fst (head . snd)) (decode . tail . snd)
07:08:36 <Eduard_Munteanu> pyon: type functions literally, more or less
07:09:06 <merijn> pyon: Anyway, you could easily define your own family like that that parameterises a Constraint like you wanted
07:09:08 <pyon> Eduard_Munteanu: My main issue with free-floating families is that they are (in general) partial functions.
07:09:18 <Eduard_Munteanu> pyon: btw, families and class instances can also pattern-match kinds, for some more fun :)
07:09:34 <merijn> pyon: But partial type functions just produce compile time type errors, so that's not necessarily bad
07:10:27 * hackagebot webdriver 0.5.3.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.3.3 (AdamCurtis)
07:11:16 <merijn> Something like "type family Parameterise (f :: * -> Constraint) x :: Constraint where Parameterise f x = (f x, Show x)" or whatever?
07:11:33 <merijn> I dunno exactly how you wanted to parameterise the constraint
07:11:56 <pyon> merijn: "not necessarily bad" --> That is more or less like saying C++ templates fail at compile time if instantiation fails, so it is not that bad. :-|
07:12:40 <merijn> pyon: Well, I meant that "causing a type error" might be the intended behaviour of said type family?
07:12:50 <merijn> pyon: i.e. to only allow some things?
07:13:25 <merijn> pyon: Consider https://gist.github.com/merijn/9530680 here it causes a compile error when you try to nest a tree with more than 3 values, which is exactly what it is intended to do
07:14:13 <merijn> You're strengthening the type system's ability to decide what is good and bad
07:14:36 <merijn> pyon: on the other hand, that "Parameterise" example is clearly a total type family
07:14:45 <pyon> Ah!
07:16:39 <merijn> pyon: Allow me to exaggerate: Saying it's bad that partial type families cause type errors, is basically moving in the direction of "-fdefer-type-errors is good, because your program compilation never fails due to type errors" ;)
07:17:41 <pyon> I do like the idea of making the type checker enforce more things.
07:19:46 <_Vi> Does Capri work? Or it is abandoned? After fixing one error with a patch I see another error...
07:20:28 * hackagebot free-functors 0.6.3 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.3 (SjoerdVisscher)
07:23:02 <_Vi> How to build old projects that depend on many old dependencies with version ceilings?
07:23:42 <EvanR> phooey at opengl being defined in terms of a different Double type which is essentially the same thing as normal Double but not
07:24:41 <EvanR> should the entire program use the GL Double or convert in the rendering code
07:25:29 * hackagebot free-functors 0.6.3.1 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.3.1 (SjoerdVisscher)
07:29:13 <ajf> Ugh, why doesn’t the Haskell Platform add cabal’s bin directory to the path? :/
07:29:39 <klrr_> anyone know how to modify the "Usage <prog> BLABLALBA" message in optparse-applicative to only show "Usage: idris [OPTIONS] [FILE]"? because mine is approximatly 150 collums :/
07:30:01 <klrr_> it shows all options available in that collumn so to speak, AND below sturctured and with help info
07:31:28 <klrr_> ajf: just put this in your bashrc
07:31:30 <klrr_> PATH=$PATH:~/.cabal/bin
07:31:31 <klrr_> export PATH
07:32:09 <EvanR> yeah i dont like when things modify my bashrc
07:32:23 <ajf> klrr_: Well, for me it’s ~/Library/Haskell/bin
07:32:42 <ajf> EvanR: Would be nice if it gave you the option, though
07:32:49 <EvanR> global cabal?
07:32:57 <ajf> global?
07:33:19 <EvanR> mine actually worked without me modifying anything, my cabal is stored in ~/.cabal
07:33:23 <EvanR> on osx
07:33:33 <ajf> Hmm
07:33:48 <klrr_> hmm no idea how osx deals with things
07:33:50 <ajf> Yes, the cabal bins are there
07:33:50 <EvanR> maybe i didnt use haskell platform
07:33:57 <ajf> The problem is bins cabal installs
07:34:14 <ajf> Some packages install command-line tools, but you need to modify your path to be able to use them :/
07:34:27 <klrr_> ajf: doesnt osx use bash? the same would probably work but with the path you said instead
07:34:31 <EvanR> i havent used those, i figured they would be in ~/.cabal/bin
07:34:33 <ajf> yeah
07:34:39 <ajf> modifying my bashrc isn’t a problem
07:34:44 <klrr_> okey
07:34:47 <ajf> I’m just mad that I have to do it myself :P
07:35:31 <klrr_> hmm, well modifying your bash sounds like a side effect , ofc haskell wont do that ;)
07:35:39 <ajf> hahaha
07:35:58 <EvanR> joking aside i agree with that behavior
07:36:05 <merijn> EvanR: That's because platform on OSX installs cabal in /usr/bin
07:36:18 <ajf> it does?
07:36:19 <EvanR> gross
07:36:27 <merijn> EvanR: If you ever upgrade cabal then you will need to add ~/Library/Haskell/bin to your path
07:36:32 <ajf> Huh, they’re there too
07:36:38 <ajf> I wonder if they’re symlinks
07:36:57 <EvanR> merijn: oh, this all changed since i installed haskell? is that what all this chatter was about last week?
07:37:02 <ajf> Wait no, there’s no ~/.cabal/bin actually
07:37:31 <ajf> You know, here’s something I don’t get. Why doesn’t the Haskell Platform simply bootstrap cabal and have cabal install everything?
07:37:35 <merijn> EvanR: No, but running "cabal install cabal-install" to update will install ~/Library/Haskell, because cabal doesn't touch your global stuff (the platform installer does)
07:37:58 <merijn> EvanR: The platform also installs an uninstaller for all that junk, though
07:37:59 <EvanR> so not .cabal
07:38:15 <EvanR> uhg
07:38:18 <EvanR> whatever
07:38:21 <merijn> EvanR: Yeah, by default ~/.cabal is only used for the config file on OSX
07:38:49 <EvanR> great
07:39:00 <EvanR> im yet again in a working, ancient environment
07:39:15 <EvanR> because i hate upgrading, because it breaks stuf
07:39:25 <ajf> This is why nobody takes Haskell seriously :P
07:39:42 <merijn> I fail to see what this has to do with breaking or even Haskell
07:40:03 <merijn> The platform people made a choice to follow OSX layout and expectations on OSX
07:40:03 <EvanR> i dont take upgrading for the same of version number e-pene seriously
07:40:14 <EvanR> sake of
07:40:33 <jkarni> anyone seen this: “cabal: tar file has trailing junk”?
07:40:55 <jkarni> started happening with all cabal commands
07:41:28 <edwardk> jkarni: are you behind a firewall or something?
07:41:36 <jkarni> nope
07:42:59 <edwardk> jkarni: if you nuke ~/.cabal/packages/hackage.haskell.org/ and cabal update before trying again what happens?
07:43:18 <jkarni> edwark: yeah, was just doing that
07:44:45 <jkarni> edwardk: yup, even just removing the cabal sandbox worked fine
07:44:51 <jkarni> edwardk: thanks
07:44:55 <edwardk> np
07:45:04 <edwardk> something corrupted your 00-index i think
07:45:46 <jkarni> edwardk: makes sense
07:46:15 <klrr_> anyone know how to modify the "Usage: <prog> BLABLALBA" message in optparse-applicative to only show "Usage: <prog> [OPTIONS] [FILE]"? because mine is approximatly 150 collums :/
07:46:32 <klrr_> e.i it shows ALL options
07:46:39 <klrr_> in one collumn
07:55:32 * hackagebot unfoldable 0.8.1 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.8.1 (SjoerdVisscher)
07:59:51 <_Vi> What does mean "only already installed instances can be used"? I'm trying to do "cabal-dev install base-4.4.0"?
08:01:02 <_Vi> BTW how do I query the package database that gets downloaded with "cabal[-dev] update"? I.e. search packages, list versions of a package, list dependencies...
08:01:14 <monochrom> ghc-pkg list
08:01:51 <monochrom> GHC uses its own base only. there is no "let me put on a new base". base is on hackage just for your convenience of browsing docs.
08:01:57 <benmachine> _Vi: you can't install new versions of base, it's tied too closely to your GHC installation
08:02:01 <_Vi> monochrom, I suppose it lists _installed_ packages, not _available for download_.
08:02:18 <benmachine> _Vi: to inspect the package list, you can use "cabal list", but to be honest I tend to use the hackage website instead
08:02:21 <_Vi> benmachine, Can "cabal-dev" or something keep parallel older GHC installation?
08:02:33 <benmachine> _Vi: I have several GHC versions installed
08:02:35 <benmachine> it's not a problem at al
08:02:42 <monochrom> "cabal list" can list packages on hackage
08:02:47 <_Vi> benmachine, Where the information that gets downloaded by "cabal update" gets stored and how to dump it as text?
08:03:17 <benmachine> cabal list
08:03:29 <benmachine> but see also, ~/.cabal/packages/hackage.haskell.org
08:04:56 <monochrom> enter "cabal --help" some time for amusement
08:05:58 <_Vi> "cabal list" shows packages, but not their dependencies...
08:07:09 <monochrom> browse http://hackage.haskell.org/ to see dependencies
08:07:24 <_Vi> What's easiest way to install legacy GHC on Linux into "cabal-dev" without affecting the whole system?
08:08:10 <geekosaur> don't use cabal-dev. you need hsenv for that
08:09:13 <benmachine> _Vi: GHC installations are pretty good about keeping separate, I have never used anything special
08:09:16 <benmachine> it Just Worked
08:09:43 <jdiez> hi guys, I'm new to haskell and I'm trying to figure out the best way to do JSON. I've come across Aeson, and I noticed I have to declare each data type as an instance of FromJSON
08:09:50 <jdiez> for it to be unmarshalled
08:10:08 <jdiez> I was wondering if there was a way to make a data type automatically derive the properties from the name
08:10:16 <jdiez> much in the way that "deriving Show" works
08:10:39 <Eduard_Munteanu> jdiez: yes, see the generics stuff
08:10:44 <jdiez> this might not be possible, but declaring the data type + declaring the instance seems like repeating work that should be automatic
08:10:55 <jdiez> Eduard_Munteanu: I can't find that here: http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html
08:11:15 <heatsink> Looks like generic-aeson does it
08:11:31 <_Vi> benmachine, Is there a Debian repository or Ubuntu PPA with various legacy GHC version? Or are there other ways to just quickly install it without building from source?
08:11:56 <jdiez> the docs for data.aeson.generic seem rather bare
08:11:58 <jdiez> http://hackage.haskell.org/package/aeson-0.6.0.2/docs/Data-Aeson-Generic.html
08:12:08 <benmachine> _Vi: oh, I don't know, sorry, I always build from source anyway >_>
08:12:18 <heatsink> Also aeson-smart and Data.Aeson.TH
08:12:19 <benmachine> (because I'm impatient and source turns up first)
08:12:25 <Eduard_Munteanu> jdiez: you need to derive Generic on the data type, then simply declare an instance of FromJSON
08:12:34 <jdiez> can I just say `data Thing = Thing { blah :: String }; decode "{'blah': 'asdf'}" Thing?
08:12:46 <monochrom> I use the binaries from GHC's website
08:12:52 <_Vi> (trying to find out less legacy analogue of the project to play with)
08:13:10 <benmachine> monochrom: I would do that but they tend to disagree with my system on the version of libgmp
08:13:14 <Eduard_Munteanu> jdiez: e.g.   data Foo = ... deriving Generic   instance FromJSON Foo
08:13:25 <monochrom> yes, actually I built from source once for that.
08:13:26 <Eduard_Munteanu> jdiez: note there's no where clause or definition for the instance
08:13:38 <jdiez> Eduard_Munteanu: hmm, that seems cool
08:13:52 <jdiez> is Generic a builtin?
08:13:54 <Eduard_Munteanu> jdiez: see the documentation of FromJSON
08:14:28 <Eduard_Munteanu> jdiez: Generic provides a representation of the type and it can be derived by GHC
08:14:56 <jdiez> Eduard_Munteanu: I see
08:15:08 <Eduard_Munteanu> jdiez: and FromJSON provides defaults which inspect said representation
08:15:09 <jdiez> I see it's actually a language feature
08:15:20 <jdiez> so {-# LANGUAGE DeriveGEneric #-} etc
08:15:29 <rhaps0dy> Is it possible to specify the type signature of a function and bind it to a value in the same line?
08:15:34 <rhaps0dy> inside of a let
08:15:45 <monochrom> not always
08:15:50 <Eduard_Munteanu> jdiez: yeah... there's also Data.Aeson.TH for an alternative approach
08:16:18 <jdiez> I'm reading the class FromJSON info and it's a bit confusing
08:16:20 <jdiez> http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:FromJSON
08:16:25 <jdiez> as far as I can tell, I have three options:
08:16:37 <jdiez> Data.Aeson.TH, which will generate the instance at compile time
08:16:43 <Eduard_Munteanu> jdiez: which you could use like   deriveJSON defaultOptions 'Foo   at the toplevel if you provide {-# LANGUAGE TemplateHaskell #-}
08:16:48 <jdiez> Data.Aeson.Generic, which works on an instance of Generic
08:16:53 <jdiez> and... the other option, which I don't understand
08:17:08 <Eduard_Munteanu> jdiez: there's also the Data.Data approach, IIRC
08:17:32 <jdiez> right, I definitely don't understand the Data.Aeson.TH approach
08:17:39 <jdiez> I think I do understand the Data.Aeson.Generic approach
08:18:00 * flan3002 is confused by all the numbertypes (RealFloat and stuff). Any good overview?
08:18:02 <rhaps0dy> monochrom: could you please expand?
08:18:26 <Eduard_Munteanu> jdiez: deriveJSON simply runs a TH function that inspects your type and generates definitions at compile-time.
08:18:30 <tremon> what's the status of language features like TH and Generic? are they ghc-specific, and/or proposed standards?
08:18:53 <monochrom> "let x = (1 :: Num a => a) in ..." does not always give you x :: Num a => a
08:18:56 <jdiez> Eduard_Munteanu: afaik, Data.Aeson.Generic uses Data.Data
08:18:58 <Eduard_Munteanu> flebron: Typeclassopedia covers them IIRC
08:19:02 <jdiez> Eduard_Munteanu: see here: http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson-Generic.html
08:19:35 <Eduard_Munteanu> jdiez: yeah... that module is deprecated though
08:19:37 <jdiez> I think DeriveGeneric is the simplest approach
08:19:40 <Eduard_Munteanu> http://hackage.haskell.org/package/aeson-0.7.0.2/docs/Data-Aeson-Generic.html
08:19:53 <jdiez> Eduard_Munteanu: cool
08:20:03 <jdiez> so I should forget about .Generic
08:20:34 <monochrom> example of failure:
08:20:41 <monochrom> > let x = (1 :: Num a => a) in (x :: Int, x :: Integer)
08:20:43 <lambdabot>  (1,1)
08:20:58 <monochrom> eh? I guess lambdabot has removed the monomorphism restriction
08:21:26 <Taneb> > let x = 1 in (x :: Int, x :: Integer)
08:21:27 <lambdabot>  (1,1)
08:21:29 <jdiez> man, I really like what I'm learning about haskell, but it seems like the simplest tasks are pretty difficult and there are lots of options that seemingly do the same thing :)
08:21:51 <skypers> hey
08:21:59 <skypers> I want to pass size in bytes to allocaArray
08:22:04 <skypers> is there a simple way to do that?
08:22:18 <skypers> the resulting pointer must be Ptr Word8
08:22:33 <skypers> can I assert that the number of elements passed == number of bytes?
08:23:56 <EvanR> > if True then "OK" else error "you fool! not ok!"
08:23:58 <lambdabot>  can't find file: L.hs
08:24:01 <EvanR> > if True then "OK" else error "you fool! not ok!"
08:24:02 <lambdabot>  "OK"
08:24:12 <EvanR> skypers: ^ ;)
08:24:28 <flan3002> Eduard_Munteanu: Assuming you meant me instead of flebron, and assuming you meant http://www.haskell.org/haskellwiki/Typeclassopedia as Typeclassopedia: I can't seem to find an overview over numbertypes in there...
08:24:59 <skypers> EvanR: what.
08:25:09 <EvanR> re assertions
08:25:29 <monochrom> skypers: I don't understand the question. it looks misstated or confused.
08:25:35 * hackagebot hasktags 0.69.0 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.69.0 (MarcWeber)
08:25:36 <skypers> monochrom: well
08:25:47 <skypers> I want to allocate an array
08:25:51 <skypers> of a specific bytes size
08:25:54 <skypers> how would I do that?
08:26:21 <skypers> and I _thought_ I could assert that bytes == number of elements if we have for instance [Word8]
08:26:22 <darthdeus> hmm so now i've installed haskell-platfrom via the mac .pkg, and i also have the newer version of ghc already installed, so if i put the haskell-platform binaries earlier in PATH it should work with the cabal i have out of the box, right?
08:26:49 <monochrom> you want 10 bytes? then it's allocaArray 10 (...). the ... inside will enforce the "it's 10 Word8's" constraint
08:27:08 <monochrom> or rather, the ... inside will enforce the "I'm talking about Word8" constraint
08:27:18 <Zekka> Non-mathematician currently trying to learn a little algebra through screwing around with Haskell: does this pseudocode look accurate? http://lpaste.net/5550889117161619456
08:27:30 <Zekka> (er, line 7 should say 'c m')
08:27:33 <monochrom> what [Word8]? there is no [a] in the type of allocaArray
08:28:10 <Zekka> sorry, there need to be a lot of changes here
08:28:15 <Zekka> I'll mention when it's fixed
08:28:30 <Zekka> I was experimenting with a few definitions earlier and didn't remove all the vestiges
08:29:07 <Zekka> Try now, with this rendition: http://lpaste.net/5550889117161619456
08:29:28 <skypers> 17:25 < monochrom> what [Word8]? there is no [a] in the type of allocaArray
08:29:31 <skypers> it was an example
08:29:34 <dwcook> Zekka: you can do c :: Constraint. GHC will tell you which extension to enable if you try that.
08:29:38 <Zekka> (Main worry is that list is the only free structure I feel like I have very much intuition for and I haven't tried to generalize it)
08:29:44 <skypers> I just want to allocate memory for Ptr Word8
08:29:47 <skypers> if you prefer :)
08:29:53 <Zekka> dwcook - ConstraintKinds, maybe? I haven't tried feeding it to GHC
08:30:05 <monochrom> [Word8] is a misleading example
08:30:36 * hackagebot one-liner 0.2.2 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.2.2 (SjoerdVisscher)
08:30:38 * hackagebot persistent 1.3.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.1.1 (MichaelSnoyman)
08:30:39 <monochrom> allocaArray 10 (...) already gives you Ptr Word8, if your ... forces type variable 'a' to become Word8.
08:30:40 <Zekka> I'm less concerned with 'will it compile' than with 'is the math accurate, and if not, can someone help me make it more accurate'
08:31:04 <Zekka> (er, adding question marks as necessary in the previous statement)
08:31:33 <skypers> 17:27 < monochrom> [Word8] is a misleading example
08:31:36 <skypers> yeah yeah
08:31:39 <skypers> forget about that
08:31:43 <skypers> in the end
08:31:55 <djahandarie> edwardk, so I'm thinking about switching newtype to use coerce, what do you think about that? It should get you the performance gains you were asking for every so long ago. I assume you already have them with the lens version though.
08:31:56 <skypers> I want to copy some arrays to a general arrays
08:31:58 <monochrom> you should also press <enter> less often
08:32:18 <skypers> I have something like ([Float],[Word32]), and I’d like to put that in a Ptr Word8
08:32:43 <skypers> so, I compute the total bytes I need, then copy the [Float], casting ptr, then the [Word32]
08:32:51 <skypers> wait
08:33:20 <Zekka> One thought I had is whether it might be better to express the signature of unfree as c m => t m -> m -- whether the a -> m step is cursory
08:33:23 <skypers> monochrom: http://lpaste.net/7478935653284052992
08:33:39 <Zekka> In that case unfree would be mconcat for [].
08:34:22 <dwcook> Zekka: it would be instructive to write more instances to help you see the pattern.
08:34:45 <dwcook> Try the Free Monad, for example.
08:34:51 <Zekka> dwcook - What else do you think I should instantiate free for? I've toyed with free monads but I don't know offhand any others
08:34:59 <Zekka> Sure, give me a moment and I'll see if it still works
08:35:13 <Zekka> I'll try the simpler c m => t m -> m formulation and see if that breaks anything
08:35:46 <klrr_> anyone know how to modify the "Usage: <prog> BLABLALBA" message in optparse-applicative to only show "Usage: <prog> [OPTIONS] [FILE]"? because mine is approximatly 150 collums :/
08:36:07 <Eduard_Munteanu> flan3002: oops, I guess I was thinking of something else... see Figure 5 here: http://www.haskell.org/onlinereport/basic.html#standard-classes
08:36:09 <dwcook> Zekka: I think you're incorporating features of Traversible into this class. Not saying it's wrong (I don't know), but it's something to be aware of.
08:36:42 <Zekka> dwcook - I basically started with folds and decided to generalize from there -- doesn't Traversable extend Foldable?
08:36:54 <dwcook> Or Foldable, maybe that's what I meant
08:37:26 <dwcook> Yeah, look at fold versus foldMap and then your proposed type signatures
08:37:47 <dwcook> They represent different subsets of the Foldable functionality
08:38:07 <Eduard_Munteanu> Zekka: yes
08:38:16 <Eduard_Munteanu> :t Data.Foldable.mapM_
08:38:17 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:38:26 <Zekka> I think Foldable might be Free for Monoids. I'm not sure Free is Free for anything other than Monoids quite yet though
08:38:27 <a> hello
08:38:27 <Eduard_Munteanu> :t Data.Traversable.mapM
08:38:28 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
08:38:33 <Eduard_Munteanu> For example.
08:38:37 <a> is good to learn haskell? yes/no? why?
08:38:50 <Zekka> a - You may be dealing with a slightly biased sample here.
08:38:59 <flan3002> a: Good for what, if I may ask?
08:39:00 <monochrom> I do not condone casting yourself, there are already libs "binary" and "cereal" for putting a lot of Floats and Word32s into a lot of bytes. but if you have found a way to do it yourself then you have found a way to do it yourself, ticket closed.
08:39:15 <dwcook> Guest13495: try reading Learn You A Haskell and deciding for yourself.
08:39:39 <Guest13495> okay
08:41:32 <dwcook> Guest13495: Real World Haskell is also a good book, in case you were inclined to read another.
08:41:35 <skypers> monochrom: ok… thank you
08:42:08 <Guest13495> dwcook: okay, thanks I will read that book ;)
08:42:12 <EvanR> are these two things, LYAH and RWH being updated at all?
08:42:19 <EvanR> they first came out a million years ago
08:42:21 <Zekka> I thought LYAH was finished
08:42:43 <EvanR> all of the standard support libs have evolved and accumulated more features
08:42:48 <monochrom> they have not been updated
08:42:56 <benmachine> LYAH has been published as a book
08:43:18 <dwcook> I'm not going to call them timeless, but they still teach useful knowledge about the language, in my opinion.
08:43:30 <dwcook> Even if LYAH is a little bit metaphor-heavy for my tastes.
08:43:37 <EvanR> "why's guide"
08:45:16 <EvanR> ill tell you, it would be nice to have a book that describes "real world" practical stuff related to using the big name libraries, time, atto/parsec, some good json lib, STM, maybe the hottest web based thing at the moment
08:45:28 <EvanR> etc
08:45:40 <EvanR> assuming you already know basics of haskell
08:45:47 <benmachine> the tragedy of haskell: we innovate so quickly our books go out of date :P
08:46:23 <EvanR> "haskell: the good parts" ;)
08:46:59 <dwcook> Haskell: The Good Parts would describe a large subset of the language. :)
08:47:19 <EvanR> all the better
08:47:25 <dwcook> Actually, it wouldn't describe a subset of the language, since it'd also be worth mentioning GHC extensions.
08:47:34 <EvanR> right
08:47:44 <EvanR> ones that should be considered part of the language, by this point
08:48:08 <dwcook> Maybe we need a new Haskell 201x? :)
08:48:26 <Jefffrey> Is there any chance that Haskell will fix that "Monad is not an Applicative" thingy and that "map, mapM, mapM_, fmap, etc..." madness?
08:48:33 <dwcook> Jefffrey: GHC 7.10
08:48:46 <Zekka> dwcook - How does this make you feel? (minding that it only works with Foldable functors) http://lpaste.net/230540388316741632
08:48:47 <dwcook> For the first thing anyhow
08:49:08 <Zekka> I don't think I can generalize this to Free functors as I've currently defined it without providing a foldMap analogue, but I'm not sure
08:49:17 <Zekka> er, there's a typo
08:49:35 <Zekka> should be corrected
08:49:46 <dwcook> Zekka: honestly I'm probably not the best person to ask. I don't have a strong concept of the theoretical underpinnings of free constructions.
08:50:04 <DEA7TH> I just started learning Haskell. How come this code works: [main2 = show 2 \n main = print 3], but if I rename 'main2' to 'main' and 'main' to 'main2', it stops working?
08:50:14 <Zekka> dwcook - I might bug someone else later then. (Any category theorists? Anywhere?)
08:50:29 <DEA7TH> https://gist.github.com/anonymous/c3e033fb84aed80c61e9 Doesn't work
08:50:30 <dwcook> DEA7TH: because show 2 does not have an IO type.
08:50:41 <dwcook> Try replacing show with print.
08:50:48 <DEA7TH> main must return an IO type? hmm that makes sense
08:50:59 <EvanR> main :: IO ()
08:51:01 <EvanR> or IO a
08:51:01 <dwcook> main :: IO a for any a you choose
08:51:29 <EvanR> running the program is necessarily an IO action
08:51:46 <Yaniel> :t show
08:51:47 <lambdabot> Show a => a -> String
08:51:53 <DEA7TH> yeah I just won't use 'main' to name my functions
08:52:02 <dwcook> Good idea.
08:52:08 <deni> i'm not sure how to use aeson to decode a list of my data types...the function has this type signature: :: IO (Maybe [DockerContainer]
08:52:25 <deni> and i do this: decode (r ^. responseBody) :: Maybe [DockerContainer]
08:52:54 <deni> this principle worked well when i just had one object in the json response...but now that i have a list it fails
08:53:02 <tremon> can I define limited-range integer types in haskell? e.g. a type that can only represent values 1..20?
08:53:03 <deni> fails in the sense that i get Nothing back
08:53:05 <deni> any ideas?
08:53:45 <Yaniel> oh so show is basically the haskell equivalent of toString
08:53:59 <dwcook> Yaniel: that seems like a reasonable approximation.
08:54:06 <EvanR> :t show
08:54:07 <lambdabot> Show a => a -> String
08:54:10 <EvanR> yes ;)
08:55:29 <dwcook> tremon: sort of. One way would be to export only functions for your type (let's say it's a newtype on Integer) that preserve that restriction. However you'd run into problems if you gave it a Num instance and used any numeric literals outside that range.
08:55:39 * hackagebot tidal 0.3.9 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.3.9 (AlexMcLean)
08:56:03 <dwcook> tremon: another way would be to define a type with twenty different constructors, which would be laborious by hand but you could use Template Haskell.
08:56:15 <dwcook> Same problem with numeric literals though.
08:56:58 <EvanR> tremon: youd need dependent types ;)
08:57:11 <tremon> yes, I considered that and decided against it. But I guess exporting the type without data constructors and including the check in the module will do for now
08:58:21 <tremon> ("that" being the data enumeration thing)
08:59:20 <k00mi> tremon: http://hackage.haskell.org/package/data-fin
08:59:44 <EvanR> oh nice
09:00:22 <dwcook> Hmm, was this made before DataKinds?
09:00:31 <dwcook> No, guess not.
09:00:33 <deni> from what i've read this should just work....ie the decode functon should now that it need to return a list of data types
09:00:37 <deni> i'm stumped
09:00:52 <tremon> k00mi: thanks, that looks useful
09:01:36 <EvanR> deni: yeah, but your type is Maybe [X], which will use a different lib instance than [X]
09:01:50 <eyebloom> If I have two unsigned Word8 s that represent sequential bytes in a signed Int16 how can I accurately combine them in Haskell?
09:01:57 <k00mi> dwcook: it doesn't seem to use TypeLits
09:02:06 <dwcook> I see that library doesn't even bother with Num. That seems wise.
09:02:08 <EvanR> deni: nevermind, Maybe is outside it all
09:02:43 <Jefffrey> Hmm. How do you make proposals for the Haskell language? (specifically for changes on the Prelude)
09:02:46 <deni> EvanR: the parsing works fine when i have just Maybe MyData
09:02:57 <deni> but when i have Maybe [MyData] it fails
09:03:11 <EvanR> deni: im going to try it on the console to see the behavior
09:03:29 <deni> EvanR: tnx
09:06:26 <Zekka> dwcook: I wrote up a quick paste that includes all the progress I made, not that I expect you to really work wiht it: http://lpaste.net/4645791786789240832
09:06:46 <Zekka> oh, forgot to make FreeMonad a MonadPlus
09:07:50 <EvanR> deni: yeah, i got it to work with a list of Int
09:07:56 <EvanR> ill try a more complex data type
09:09:03 <dwcook> Zekka: You can tear down a Free Monad without Foldable. http://hackage.haskell.org/package/free-4.7.1/docs/Control-Monad-Free.html#v:iter
09:09:42 <Zekka> dwcook - How? I'm not sure how to deal with the structure f provides if f isn't Foldable
09:09:58 <dwcook> I don't know, I just looked at the types. Check the source maybe?
09:09:59 <Zekka> Just realized that I don't actually need foldMap though because f provides fmap
09:10:07 <deni> EvanR: yeah the example with List of Ints should work.....i'm not sure what could be wrong with the more complicated data type
09:10:18 <EvanR> deni: http://codepad.org/xLXPIXer
09:10:32 <EvanR> i used a list of Maybe (Maybe String Int)
09:10:43 <EvanR> so maybe your instance is bustede?
09:11:13 <mm_freak> hi there
09:11:37 <mm_freak> let y = f x {-# INLINE y #-} in y + y
09:11:43 <mm_freak> is sharing lost here?
09:12:28 <deni> EvanR: yeah i might need to see what code was generated by TH
09:12:37 <deni> EvanR: tnx for your help
09:13:09 <deni> btw is there a way to set a flag in the repl so that when i do :l MyModule it prints the generated code?
09:13:32 <EvanR> i dont know how to use TH
09:14:50 <carter> mm_freak: does't it depend on how its optimized?
09:15:09 <mm_freak> carter: well, you could view both as optimization, but they seem incompatible
09:15:22 <mm_freak> the question is whether the thunk is inlined or the expression is inlined
09:15:31 <carter> mm_freak: i think CSE can ahppen at the use site
09:17:10 <mm_freak> GHC is very conservative about doing CSE
09:17:28 <mm_freak> in general i assume that it doesn't do it
09:17:36 <carter> oh
09:17:43 <carter> in 7.8 its a bit more agressive
09:17:57 <carter> had some FUN bugs from careless unsafefreeze/unsafethaw there
09:18:33 <heatsink> Why would you want to inline a non-lambda term?
09:18:38 <mm_freak> most of those kinds of bugs don't occur when you use storable vectors and unsafeWith
09:19:03 <mm_freak> heatsink: good point
09:19:15 <carter> mm_freak: no, this was with storable vectors
09:19:35 <carter> no crashing, just getting really weird answers to matrix mults
09:19:48 <carter> because of too much accidental sharing
09:20:19 <mm_freak> carter: does 7.8 produce measurably faster code in general?
09:20:32 <carter> idk
09:20:36 <mm_freak> with -fasm that is
09:21:10 <carter> honestly i don't know
09:21:13 <carter> its not ideal
09:21:18 <carter> and theres room for work to make it better
09:21:25 <carter> jsut haven't had the time to dig in
09:21:38 <mm_freak> i'm actually quite happy with 7.6-produced code
09:21:44 <mm_freak> it's only slow in some edge cases
09:23:25 <carter> once i stabilize numerical-core, i'll want to do some work to bring fasm up to parity with llvm for my use cases
09:24:40 <mm_freak> carter: do you have a fast FFT implementation somewhere?  or perhaps an idea for a different approach to writing a bandpass filter
09:25:03 <carter> oh, have you seen ian rosses arb-fft lib?
09:25:07 <mm_freak> (there are existing libraries, but they're either slow or bind to a non-haskell library)
09:25:16 <carter> @hackage arb-fft
09:25:16 <lambdabot> http://hackage.haskell.org/package/arb-fft
09:25:23 <carter> its within ~ 10x of fftw
09:25:31 <carter> complex only currently
09:25:55 <mm_freak> hmm…  i'll need to benchmark it
09:26:10 <mm_freak> but 10 is quite a huge factor
09:26:10 <carter> i was really happy he was convinced to bsd it
09:26:20 <carter> could be smaller
09:26:23 <carter> i don't recall
09:26:32 <carter> i'll be messing with fft stuff myself this summer at some point i imagine
09:26:59 <mm_freak> ideally there'd be a way to do it without FFT
09:27:12 <carter> ohhh
09:27:14 <carter> convolutions?
09:27:20 <carter> or ohhh
09:27:26 <carter> you just want band pass filters
09:27:29 <mm_freak> yeah
09:27:38 <mm_freak> or individual high/low pass filters…  i can combine them to a band-pass
09:27:43 <carter> hrmmm
09:28:14 <carter> i think one way you can construct the filters is by using an FFT to figure out the coefficients
09:30:01 <carter> but the issue is
09:30:09 <carter> mm_freak: you want a continuous time filter?
09:30:33 <mm_freak> carter: that would be amazing, but i'd have no idea how to do that
09:30:39 <carter> physics!
09:30:58 <mm_freak> carter: all physics i've seen to do that involve integration
09:31:03 <heatsink> This isn't my area of expertise, but don't you want to use an FIR or IIR filter to do it without FFTs?
09:31:08 <carter> yes
09:31:08 <carter> those
09:31:38 <carter> i think that mm_freak  wants to have something not tied to the sampling rate somehow though...?
09:32:12 <grache28> hi what does this mean: f [] y = y
09:32:29 <haasn> it means that f [] y = y, no more, no less
09:32:30 <heatsink> grache28: When you call f with two arguments, and the first is an empty list, return the second
09:32:35 <carter> sam as \ _  x -> x
09:32:37 <carter> *same as
09:32:48 <haasn> carter: no
09:32:54 <carter> haasn: i know
09:32:59 <carter> depends on what other cases there are :)
09:33:08 <mm_freak> heatsink: what's the advantage of those?  the algorithms seem to have similar complexity
09:33:11 <haasn> I cannot think of a context in which those two mean the same
09:33:18 <mm_freak> similar to FFT that is
09:33:27 <mm_freak> grache28: read it like an equation
09:33:33 <grache28> heatsink: thanks
09:34:07 <heatsink> FFT has O(n log n) complexity in the size of the signal
09:34:10 <heatsink>   FIR and IIR filters have O(n * w) complexity in the size of the signal and window
09:34:10 <grache28> ok and this for example: f :: Int -> Int -> Int -> Bool
09:34:22 <heatsink> When the window is small, it's faster to avoid FFT
09:34:23 <haasn> It means that f has type Int -> Int -> Int -> Bool
09:35:43 * Osz see this one :D https://www.youtube.com/watch?v=QlIDnsce0z4
09:35:46 <mm_freak> heatsink: just a quick question before i read:  can i (reasonably) implement a complete equalizer using that?
09:36:00 <mm_freak> that's what i'll need in the end
09:36:38 <grache28> from what I've seen in other examples it's seems like: input -> output. So with multiple -> does that mean each the first is an input to the second, the second to the third..
09:37:11 <mm_freak> grache28: argument -> result
09:37:19 <heatsink> You can do it.  It may or may not be more efficient, depending on how sharp the filter needs to be
09:37:23 <grache28> tks mm_freak
09:37:46 <EvanR> :t (+)
09:37:47 <lambdabot> Num a => a -> a -> a
09:37:51 <EvanR> :t (+1)
09:37:52 <lambdabot> Num a => a -> a
09:37:52 <simukis_> l
09:37:58 <heatsink> mm_freak: You would precompute filter coefficients for each frequency band, sum them together with weights to get the filter, then do a scan-like operation to apply the filter to a signal
09:38:01 <mm_freak> heatsink: as sharp as is still reasonably fast to compute in real-time
09:38:21 <mm_freak> oh, that sounds nice
09:38:48 <mm_freak> the filters are pretty much constant throughout the application
09:39:07 <mm_freak> this is about reflection characteristics of certain materials
09:39:12 <mm_freak> sound that is
09:42:52 <EvanR> :t otherwise
09:42:53 <lambdabot> Bool
09:43:38 <heatsink> You're doing real-time physics simulation?
09:44:17 <simon> :t ala
09:44:18 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
09:44:55 <Baughn> I'll admit I don't understand the types in the lens library - working on that - but, hm.
09:45:14 <Baughn> It has *some* support for monads. Which I don't comprehend. :X
09:45:25 <mm_freak> heatsink: not physics, just close-to-physics
09:45:32 <mm_freak> heatsink: i'm working on a sound engine
09:45:37 <Baughn> Would it be possible to use lens on structures where some intermediate element is, say, a TVar?
09:46:35 <shachaf> Baughn: Not really, or at least not in the way you'd want.
09:46:38 <Eduard_Munteanu> Baughn: yeah, you could pick IO for the functor
09:47:10 <carter> mm_freak: the IIR and FIR stuff is covered decently in various DSP books
09:47:22 <Eduard_Munteanu> It wouldn't be a polymorphic lens anymore, though.
09:47:39 <Baughn> Aww.. all right.
09:48:06 <shachaf> It wouldn't be a lens at all anymore.
09:48:29 <shachaf> You can sort of fake reading from it but writing is even worse.
09:48:43 <Baughn> So I'll drop out of lens mode and do the tvar manipulation the normal way.
09:49:23 <Baughn> Possibly I should be using an sqlite wrapper anyway.
09:49:51 <Eduard_Munteanu> Baughn: you can still make a lens for the TVar itself
09:49:58 <Eduard_Munteanu> In case that wasn't clear.
09:50:00 <Taslem> Is there a complete description of the layout indentation rules which is less verbose than the Haskell standard?
09:50:22 <Baughn> Eduard_Munteanu: Thanks, but that much is clear. :)
09:51:14 <hseg> Taslem, https://en.wikibooks.org/wiki/Haskell/Indentation is a good informal introduction
09:51:33 <hseg> Taslem, and it should work for 99% of the cases you'll see
09:51:36 <mm_freak> carter: reading =)
09:51:49 <mm_freak> thanks everybody…  i'll see if i can make something useful
09:53:09 <enthropy> with "class C (a :: (*, *))", shouldn't   instance C '(x,y)  be as willing to commit to selecting an instance as   instance (z ~ '(x,y)) => C z?
09:54:45 <enthropy> since ghc knows the kind, it should be able to assume that there is only one type constructor
09:55:01 <enthropy> '(,) or whatever you want to call it
09:55:17 <c_wraith> it should, but GHC doesn't do any reasoning of that sort at the moment
09:55:30 <skypers> :t V2
09:55:31 <lambdabot> Not in scope: data constructor ‘V2’
09:55:51 <enthropy> c_wraith: do you know if there's a bug for this one? These things are hard to search for
09:55:59 <c_wraith> I don't know
09:56:53 <bennofs> Is putStrLn thread-safe or will multiply calls to it get intermixed?
09:57:22 <c_wraith> it's very not-thread-safe
09:57:27 <EvanR> AAABBBABABABAAA ;)
09:57:32 <c_wraith> it will interleave chaaracter by character
09:57:38 <geekosaur> the important part is it's still lazy in some sense, so ^^
09:57:39 <Baughn> bennofs: It won't crash your program, so in that sense it's thread-safe
09:57:53 <Baughn> bennofs: But you probably want some sort of logging library
09:58:15 <EvanR> or start a thread listens on a Chan for messages
09:59:30 <c_wraith> that's a good way to run out of memory and crash. :P
09:59:56 <c_wraith> I've done this before.  I know how it doesn't work.
10:00:13 <EvanR> dont you want your parallel computations to print out debug info as fast as possible?!
10:00:19 <EvanR> without blocking
10:00:25 <EvanR> jk
10:00:38 <c_wraith> It's very easy to generate log messages far faster than they can be written.
10:00:48 <c_wraith> A bounded chan is ok
10:00:52 <c_wraith> Unbounded is not
10:01:07 <EvanR> MVar i guess is the simplest way to get a bounded chan
10:01:13 <EvanR> bound=1
10:01:36 <c_wraith> You end up with contention issues in excess of the writing time, then.
10:01:50 <c_wraith> You really want multiple loggers with striping across them
10:02:01 <c_wraith> To reduce contention per logger
10:02:33 <c_wraith> And you want each logger to have a queue bounded at a couple thousand messages, which blocks on adds if it's full
10:02:43 <EvanR> not crashing is one thing, but being prepared to run the nasdaq with your haskell program is something else ;)
10:03:04 <c_wraith> Like I said, I've run programs where this matters.  In haskell, yes. :)
10:03:14 <Baughn> And by this point your logging routines are getting pretty complex, which means you don't want to write it yourself if you don't have to. :P
10:03:37 <EvanR> by this point, use erlang ;)
10:03:39 <c_wraith> It's easy to write an http server that handles hundreds of requests per second.  It's a lot harder to log them well. :)
10:03:50 <c_wraith> Then you have the problem that you're using erlang.
10:04:19 <dagle> Somebody needs to create a webframework for elm called terror on elm street.
10:04:46 <c_wraith> ... a web framework for.. a language that compiles to javascript?
10:04:53 <c_wraith> nodelm
10:05:40 <dagle> Well, create what ever you want, the name stays.
10:07:04 <DEA7TH> should I name my function is_mod or isMod?
10:07:17 <DEA7TH> http://www.haskell.org/haskellwiki/Programming_guidelines#Naming_Conventions this is unclear
10:07:39 <Baughn> DEA7TH: Use camelCase.
10:07:40 <Taneb> isMod
10:07:40 <EvanR> isMod
10:10:25 <hseg> Question. I've seen Applicative functors characterised as strong lax monoidal functors. However, looking at nLab's definition of a lax monoidal functor, it says that (among other things) the domain and codomain of the functor must be strict monoidal. i.e., we should have (().x) = x, not just ((), x) ~ x. But this isn't true of Hask. So what gives?
10:19:02 <DEA7TH> given f, a function which takes two arguments: f a b is equivalent to a `f` b correct?
10:19:29 <hseg> DEA7TH, Yes, except for precedence rules
10:19:42 <ion> dea7th: Given that f takes two or more arguments, (f a b) = (a `f` b).
10:20:48 * hackagebot effin 0.1.0.0 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.1.0.0 (AnthonyVandikas)
10:20:54 <Fuco> can I somehow make ghci automatically add packages like Control.Monad/Applicative/Arrow to the interactive sessions?
10:21:03 <ion> fuco: Add import lines to ~/.ghci
10:21:20 <Fuco> oh, there's a .ghci! could've figured that myself :D
10:21:30 <Fuco> thanks
10:21:39 <hseg> Fuco, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
10:22:44 <hseg> Question. How does Haskell get around the fact that monoidal functors demand that their domains/codomains be *strict* monoidal when saying that Applicatives are lax monoidal functors?
10:23:02 <copumpkin> hseg: which proofs require that?
10:23:40 <hseg> copumpkin, I'm not sure. However, I do know that nLab defines monoidal functors that way.
10:23:50 <copumpkin> yeah, not sure that's a huge deal
10:23:52 <hseg> copumpkin, Still, I admit it's slightly nitpicky.
10:24:06 <copumpkin> if we have proofs that rely on that property, perhaps we have a problem
10:24:35 <ion> http://reproducibility.cs.arizona.edu/tr.pdf 4.3.13 “We can’t release our source because Haskell”
10:25:03 <hseg> Especially since the proofs can easily be weakened to explicitly using the isomorphism ((), x) = x = (x, ()), (x, (y,z)) = ((x,y),z)
10:25:14 <copumpkin> ion: nice
10:26:12 <EvanR> Hask includes or doesnt include bottom?
10:26:32 <copumpkin> Hask is poorly defined
10:26:33 <jmcarthur> not even sure Hask is really defined anywhere
10:29:18 <hseg> EvanR, Hask is usually informally defined in ways that make it lack all sorts of nice properties.
10:30:15 <copumpkin> there's that CPO_\bot category that has bottoms
10:30:28 <copumpkin> which sort of resembles actual haskell
10:31:34 <rhaps0dy> So guys
10:31:50 <rhaps0dy> is it possible to make an if statement that decides on different courses if you have a Left or a Right ?
10:32:07 <vanila> either does this
10:32:08 <vanila> :t either
10:32:09 <rhaps0dy> uh wait something occured to me
10:32:09 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:32:09 <EvanR> yeah but use a case with pattern matching instead
10:32:10 <rhaps0dy> yes
10:32:12 <hseg> :t either
10:32:13 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:32:13 <rhaps0dy> Either is what I'm using
10:32:24 <rhaps0dy> EvanR: yeah, this. How do I use it?
10:32:41 <orzo> why prefer a caes to either
10:32:42 <orzo> ?
10:32:43 <rhaps0dy> oh
10:32:49 <EvanR> or use either, above
10:32:50 <hseg> either f g (Left x) = f x; either f g (Right x) = g x
10:32:53 <rhaps0dy> I thought Either was the type?
10:32:59 <rhaps0dy> oh
10:33:00 <ion> orzo: also, vice versa
10:33:05 <rhaps0dy> either is a function
10:33:06 <hseg> rhaps0dy, It is. Haskell is case-sensitive
10:33:11 <rhaps0dy> This is exactly what I Was looking for
10:33:12 <rhaps0dy> thank you
10:33:20 <orzo> that reminds me, i had some code that sent something like this, case if null cs then ds else cs of ...
10:33:24 <Maior> @src either
10:33:24 <lambdabot> either f _ (Left x)     =  f x
10:33:24 <lambdabot> either _ g (Right y)    =  g y
10:33:37 <orzo> does common sesnse demand i put that if in parenthesis?
10:34:13 <EvanR> orzo: better to use a case with pattern matching instead of if null xs
10:34:14 <Maior> orzo: I use parentheses much more than hlint approves of, just because I would rather the slight "noise" over brain effort
10:34:39 <ion> Common sense demands you don’t write it like that. ;-)
10:35:27 <mlen> Hello fellow Haskellers!
10:35:32 <mlen> Please correct me if I'm wrong: can GATDs be thought of as a poor man's dependent types?
10:35:40 <hseg> mlen, greetings to you!
10:35:50 * hackagebot cake3 0.5.0.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.5.0.0 (SergeyMironov)
10:36:01 <ReinH> orzo: isn't that case cs of [] -> ...
10:36:37 <YellPika> mlen: Yes
10:36:52 <orzo> heh, surely you dont want me to embed a case within my case
10:37:06 <ReinH> GADTs by themselves?
10:37:13 <YellPika> mlen: We can use them to implement singleton types, which provide much of the same benefits as dependent types.
10:37:21 <YellPika> But they're clunky
10:37:35 <ion> fallback [] ys = ys; fallback xs _ = xs
10:37:37 <ReinH> orzo: the if is unnecessary
10:37:42 <ion> case cs `fallback` ds of …
10:37:51 <YellPika> And also somewhat incomplete until we get kind equality constraints in 7.10 (!)
10:37:52 <orzo> :t fallback
10:37:53 <lambdabot> Not in scope: ‘fallback’
10:38:29 <hseg> :t maybe
10:38:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:39:04 <ReinH> orzo: ah I see. Never mind.
10:39:25 <orzo> ReinH: was it ion's suggestion that made it more clear?
10:39:56 <ReinH> Yep. I just misread it :)
10:40:13 <orzo> proving ion's point i guess
10:40:51 <ReinH> It's an unusual construct. :)
10:41:21 <mlen> YellPika: Thanks. I was reading TMR22 on GATDs and the example of RB trees looked suspiciously similar to dependent types :)
10:42:43 <ReinH> YellPika: it's interesting to see GHC moving towards dependent types
10:44:11 <mlen> ReinH: You mean Data.Type.Equality in base 4.7?
10:44:38 <fizruk> can anyone explain, how quotient types help “safely expose module internals”? I found such a claim in this post http://blog.jbapple.com/2007/01/quotient-types-for-information-hiding.html
10:45:47 <c_wraith> mlen: well, and the type-level nat stuff, which keeps improving every release.  GHC 7.10 is supposed to have an SMT solver for doing arithmetic with them at the type level.
10:47:27 <ReinH> fizruk: have you read the linked papers? :)
10:48:25 <fizruk> ReinH: looked through the second one
10:48:32 <aristid> quickcheck really is unreasonably effective at finding bugs
10:48:39 <aristid> 4 properties, 2 bugs:D
10:48:47 <fizruk> ReinH: first one I can’t access
10:50:52 * hackagebot snaplet-fay 0.3.3.6 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.6 (AdamBergmark)
10:54:19 <fizruk> ReinH: found the first paper, nothing there on modules too
11:00:27 <mzarella> I work with node.js everyday, and I'm starting to wonder, does everything have to be async? I've heard people say that everything should be async going forward, but it's frustrating when I think about how simple it was prior to everything being async
11:01:01 <mzarella> Haskell isn't async by default, but should it be?
11:01:10 <mzarella> Should have you have implicit async?
11:01:10 <c_wraith> mzarella: GHC's IO system is async.  But the language is powerful enough to hide that from you.
11:01:31 <mzarella> c_wraith: Oh, that sounds great.
11:02:07 <heatsink> What does it mean to be async?
11:03:11 <heatsink> Just that I/O is asynchronous?
11:03:23 <c_wraith> Yeah, that's sufficient.
11:03:39 <heatsink> alright
11:03:54 <kgadek> hi all. I'm wondering: (how) is it possible to write Knuth's algorithm X (aka. dancing links) in Haskell. Is ST monad the only option? The basis: sparse 2D array, *lots* of hiding & unhiding of columns/rows; in C implementation, that's done with clever operations on double-linked list. OR should I do FFI?
11:04:33 <kgadek> I did a quick google-fu, but only some very naïve implementation found
11:04:48 <kgadek> (with O(n^2) operations instead of O(n) etc)
11:04:55 <mikusp> kgadek: do you have some algorithm explanation available?
11:05:04 <mzarella> Is that really how you would define async? In node.js, for instance (since this is what I'm most familiar with currently), if you have about 5 functions and you call all of them, they will all be executed simulatenously, regardless if they perform IO
11:05:24 <kgadek> the best one is probably the one from Knuth: http://www-cs-faculty.stanford.edu/~uno/papers/dancing-color.ps.gz
11:05:24 <EvanR> nodejs is different because its not concurrent
11:05:35 <grache28> hi - just getting started with haskell - not sure why I can't pass a function as a parameter - here's a pastebin: http://pastebin.com/BCLyygBk
11:05:42 <kgadek> wikipedia has strange one, but it's probably "okay" as well: https://en.wikipedia.org/wiki/Algorithm_X
11:06:14 <FireFly> mzarella: I don't think that's correct
11:06:18 <kgadek> mikusp: is that okay for you? that's a bit tl;dr probably
11:06:34 <mzarella> EvanR: I think it is concurrent, but I might be wrong.
11:06:37 <EvanR> its not
11:06:51 <c_wraith> grache28: That function doesn't have the right type to be passed there.
11:07:09 <mzarella> EvanR: Within node.js, you can spin up a new process and run your code in as many node processes as your hardware supports
11:07:18 <mikusp> kgadek: it's ok, reading it now
11:07:20 <c_wraith> grache28: also, your addList function could be defined as addList = (:)
11:07:39 <EvanR> let me try again, a single nodejs program, process is not concurrently executing any more than 1 thing at a time
11:07:42 <c_wraith> grache28: since it's just a type-restricted version of that operation.
11:08:15 <EvanR> you are not talking about spawning multiple haskell processes
11:08:17 <mzarella> In reality, every app I spin up though is using as more processes as it can.
11:08:35 <mzarella> I use pm2 to launch everything, https://github.com/unitech/pm2
11:09:22 <grache28> c_wraith: tks, as far as the right type, I still don't see it. addUp returns (not sure if that's the right nomenclature) (Int, Int) and addList takes (Int,Int) as it's first param. What am I missing?
11:09:56 <tremon> grache28: evaluation order. Try adding parentheses around addup 7 2 5
11:10:17 <EvanR> mzarella: this sort of thing is not necessary in ghc, thanks to the concurrent runtime
11:10:19 <kgadek> grache28: as tremon said - try: addList (addUp 7 2 5) []
11:10:31 <c_wraith> grache28: oh, is that what you mean to be doing?  Yeah, f a b c d  means (((((f) a) b) c) d)
11:10:54 * hackagebot effin 0.1.0.1 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.1.0.1 (AnthonyVandikas)
11:10:58 <mzarella> EvanR: this sounds nice
11:11:05 <c_wraith> grache28: if you want to use the result of a function call as an argument to another function call, parenthesize it.
11:11:13 <tremon> grache28: but note that that's not "passing a function as a parameter"
11:11:19 <warpy> is it recommended to use acid-state as the datastore in real world applications?
11:11:19 <EvanR> mzarella: you dont need an explicit callback and answer the question of what the worker will do next immediately, because your action will block and let other things happen while the action completes
11:11:34 <warpy> or is it not?
11:11:44 <EvanR> mzarella: then the thing requesting the result gets it normally
11:11:51 <EvanR> something i really miss in node
11:11:58 <grache28> tremon: tks for parenthesis, yea I guess it's passing the result
11:12:43 <c_wraith> warpy: acid-state still has issues scaling with huge data sets or high load.  There are a lot of cases where you'll never see either of those, though, in which case it's fine.
11:13:01 <warpy> c_wraith: how huge?
11:13:19 <c_wraith> warpy: I don't recall - I didn't do the benchmarking myself.
11:13:35 <grache28> is there a way to return an empty pair?
11:13:43 <kgadek> grache28: also, note that instead of `addList x (y:ys) = x:y:ys` you could write `addList x ys | ys != [] = x:ys` but that's probably not what you want
11:13:44 <shachaf> What is an empty pair?
11:13:52 <EvanR> :t (,)
11:13:53 <lambdabot> a -> b -> (a, b)
11:13:58 <warpy> c_wraith: i see. is it ok for a small app just using the localstore?
11:14:03 <tremon> grache28: yes, but an empty pair () is not of the same type as (Int, Int)
11:14:03 <kgadek> grache28: read about Maybe
11:14:13 <kgadek> in short
11:14:22 <kgadek> you' have to change the type of the function to:
11:14:22 <grache28> ok ill read about maybe
11:14:32 <EvanR> () is not empty, a pair, or an empty pair
11:14:34 <kgadek> Int -> Int -> Int -> Maybe (Int, Int)
11:14:51 <kgadek> and then you could return either some value by `Just (x,y)` or nothing by… well, `Nothing`
11:14:54 <c_wraith> warpy: for a small app, that should be fine.
11:15:06 <kgadek> there's a bit of more bloat to do, since you have to read that
11:15:24 <warpy> c_wraith: i see. thanks.
11:15:27 <kgadek> but soon you'll realize that it's the best way to solve the 'null-problem'
11:15:48 <kgadek> and you'll probably never encounter 'null-pointer exception'
11:16:14 <warpy> error "Null Pointer Exception"
11:16:19 <warpy> :P
11:16:30 <EvanR> uhg
11:16:44 <kgadek> *uhc
11:17:11 <EvanR> you dont get null pointer exceptions in haskell because null pointers are ok ;)
11:17:48 <warpy> can you get null pointer exception while using FFI?
11:17:54 <c_wraith> yes
11:18:00 <c_wraith> though it's more of a segfault
11:18:03 <DEA7TH> For variable naming, should I do everything like in Java/Scala? i.e. camelCase for most things, UpperCamelCase for classes
11:18:16 <warpy> DEA7TH: yes
11:18:38 <c_wraith> haskell libraries do prefer CamelCase.  The compiler enforces uppercase starting letters on things that need it, and prevents them otherwise.
11:19:02 <c_wraith> the case of the leading character of an identifier is significant in haskell.
11:19:06 <DEA7TH> I see
11:19:15 <c_wraith> ...  and : counts as uppercase for operator characters.
11:19:18 <mzarella> So not everything in Haskell is executed in parallel, only IO and parts where you explicity invoke threaded operations?
11:19:30 <warpy> c_wraith: is using Data.Typeable or Data.Data frowned upon in general?
11:19:53 <c_wraith> mzarella: IO isn't automatically executed in parallel either...  There needs to be something else running for it to be in parallel *with*
11:20:28 <c_wraith> mzarella: that's really not all that different from node.  Node doesn't run *everything* asynchronously, just things that are run by callbacks.
11:21:40 <c_wraith> warpy: Data.Typeable is fine, though it's kind of rare to actually need it.  Data.Data is..  Eh, it's used sometimes.  It's powerful when you can take advantage of it, but I've never needed it.
11:22:42 <warpy> i am storing values in a map as Dynamic because i dont know that type it will be
11:22:59 <warpy> i feel like there should be a better way to do this, but i dont know
11:23:12 <grache28> bleh - i'm using hugs (not able to install any other interpreter) let doesn't work - anyone know of any equivalent?
11:23:19 <c_wraith> warpy: yeah, that's usually wrong. :P
11:23:35 <kgadek> grache28: what do you mean "let doesn't work " ?
11:23:52 <c_wraith> warpy: not always!  It depends on what you are doing, specifically.
11:23:53 <warpy> i get all sorts of weird compilers errors if i try to use a typeclass of my own
11:23:54 <grache28> Main> let a = 4+5      ERROR - Syntax error in expression (unexpected end of input)
11:23:55 <EvanR> warpy: that will make it very interesting for things that much use the map for something
11:24:15 <EvanR> must*
11:24:26 <mzarella> Thanks to everyone for your feedback
11:24:44 <warpy> EvanR: a map where the values can be of any type. the types of values is not decided by me.
11:25:06 <EvanR> just for the sake for it, or are you trying to solve a particular problem
11:25:17 <mikusp> kgadek: do you have some idea how to represent dlx using st monad?
11:25:19 <warpy> so i am using Map Int Dynamic
11:25:36 <kgadek> grache28: try `let a = 4+5 in a`
11:25:40 <kgadek> and report results
11:25:46 <warpy> EvanR: nah. i ran across this writing an irc bot :)
11:25:49 <kgadek> mikusp: only to imitate C implementation
11:25:59 <kgadek> but I don't know how GC would behave
11:26:04 <grache28> kgadek: that works, thanks
11:26:10 <warpy> everyone has to write an irc bot to graduate to real haskell
11:26:12 <kgadek> since there's a bit of pointer arithmetic
11:26:29 <lebek> anyone know how to cycle through previous commands in emacs inf-haskell interpreter?
11:26:34 <kgadek> grache28: that works because `let … in …` is an expression
11:26:49 <EvanR> warpy: so irc bots probably only handle a small family of data types, not Typeable. for instead it has to be representable as text, but thats just an example of ways to narrow down the scope of the program
11:26:52 <kgadek> and `let …` is something very similar BUT used in some monad
11:26:59 <kgadek> note that in GHCi that works
11:27:03 <kgadek> and in my understanding
11:27:16 <kgadek> that *should* work in Hugs as well
11:27:23 <kgadek> but… well, never used Hugs
11:27:30 <grache28> kgadek: yea when I try in Hugs with a list it gives an infinite list: et lista = addList (addUp 7 3 4) lista in lista
11:27:46 <rhaps0dy> kgadek: what's hugs?
11:27:52 <grache28> (recursively keeps calling the function with the new result I'd imagine)
11:27:52 <rhaps0dy> another haskell compiler?
11:28:17 <warpy> EvanR: ya, i could do it that way but i want to let each handler keep any type of state it wants
11:28:24 <lebek> M-p did the trick
11:28:29 <EvanR> warpy: ah, you can do this without Dynamic
11:28:39 <warpy> how? please tell
11:28:50 <EvanR> theres a few ways
11:29:03 <kgadek> rhaps0dy: yes
11:29:20 <grache28> so here's what I'm actually trying to figure out - I want to keept a list: lista that keeps track of the results from the function addList
11:29:22 <kgadek> but note that many people consider GHC as the 'de facto compiler'
11:29:29 <EvanR> warpy: one way is to have a Handler type to represent the interface to a handler. you can put this in a map for example
11:29:36 <pleek> 'de facto compiler' lol
11:29:48 <warpy> EvanR: i do have it
11:29:54 <EvanR> warpy: to construct a value of this type, you can have different constructors for the different types of state
11:30:08 <EvanR> warpy: Int -> Handler, String -> Handler, () -> Handler, etc
11:30:15 <warpy> oh, do you mean a typeclass?
11:30:30 <dos> Hi to all , this is the library base of haskell http://www.haskell.org/ghc/docs/7.6-latest/html/libraries/index.html# ??
11:30:32 <EvanR> if you want to modify the state, use a TVar or IORef or something for your state
11:30:37 <EvanR> warpy: no
11:30:43 <rhaps0dy> kgadek: yeah, me for starters
11:30:49 <kgadek> grache28: what you've written is `let lista = addList (addUp 7 3 4) lista in lista`
11:30:56 <kgadek> and to read that aloud:
11:30:57 <warpy> EvanR: but i cant have an infinite number of such functions
11:31:01 <fizruk> dos: http://hackage.haskell.org/package/base
11:31:07 <EvanR> warpy: uhm, no you cant. so?
11:31:14 <warpy> it cant be "any" type then
11:31:18 <warpy> only a fixed number
11:31:25 <kgadek> create "lista" that is defined as adding something to itself"
11:31:25 <dos> fizruk thanks
11:31:29 <dos> fizruk: thanks
11:31:55 <EvanR> warpy: i dont think youre characterizing the use case correctly, not only you wont, but no one will create an infinite number of handlers for the bot
11:32:09 <fizruk> dos: for ghc 7.6 you might be interested in 4.6.0.1 rather than 4.7
11:32:13 <EvanR> what youre saying is that you want it to be dynamically extensible at runtime maybe?
11:32:29 <EvanR> dynamic wont help with that
11:32:36 <EvanR> by itself anyway
11:32:41 <warpy> EvanR: that is true but i dont want to dictate that. if the handler itself can dictate that then it is alright
11:32:58 <EvanR> what i described lets it do that
11:33:25 <kgadek> mikusp: any ideas about that?
11:33:27 <warpy> class Handler h where toHandler :: a -> h
11:33:31 <EvanR> no
11:33:34 <warpy> are you talking about that
11:34:19 <grache28> kgadek: yea I see that - i'm trying to use vars from imperative programming, haven
11:34:22 <mikusp> not really, I don't see an easy way of implementing it outside of io/st
11:34:28 <grache28> t figured out how to do that in haskell
11:35:04 <kgadek> grache28: haskell is easy, that's the transition from imperative/OO to functional that's difficult
11:35:34 <StoneCypher4k> i actually disagree with that pretty strongly
11:35:40 <EvanR> warpy: you would define Handler as a type to represent the things a handler can do, but it would not mention what the type of the state is, if any. if you are hiding that raw state from the user of the interface, thats fine. if you want to provide a standard view of the state, thats also fine.
11:35:49 <StoneCypher4k> i think what's difficult is the transition from anything, including functional, to pure functional
11:36:06 <lispy> What is the correct solution to the problem "clang's cpp doesn't work well for Haskell code but I still need conditional compilation"?
11:36:07 <StoneCypher4k> i've been doing erlang for seven years, which is an impure functional language, and ramping up to haskell has still been difficult for me
11:36:10 <DEA7TH> I'm transitioning from Scala to Haskell right now, just learned how to assign variables today
11:36:16 <DEA7TH> looks really easy to far
11:36:33 <DEA7TH> (I could write purely functional and immutable Scala before I started this)
11:36:43 <StoneCypher4k> erlang's immutable :)
11:36:47 <warpy> DEA7TH: there is no assignment. only initialization
11:36:55 <StoneCypher4k> it's been the dealing with IO that has been hard for me, specifically
11:36:57 <DEA7TH> well, I'm referring to x = 0
11:37:03 <StoneCypher4k> then again i haven't yet put in much time
11:37:08 <dwcook> x = 0 is a definition that says you can replace x with 0 where it appears.
11:37:13 <kgadek> grache28: so don't be sad, that's really difficult
11:37:21 <DEA7TH> figuratively speaking anyway
11:37:22 <kgadek> and the results will be good for you
11:37:28 <dwcook> It's different from many other programming languages' concept of assignment to a variable, in which variables are mutable containers for values.
11:37:29 <grache28> int a = 1; int b[3] ; for(int x=0;x<3;x++){ b[x] = a + x; a++}
11:37:44 <spott> if i'm trying to build something with cabal, and some dependency of some dependency fails to build, how do I force it build a different version?
11:37:45 <grache28> that blurb of c code is something like what I wanna do
11:38:02 <warpy> EvanR: i am not sure what you mean. i'll try to look around for a better solution
11:38:12 <grache28> kgadek: yea I see that, I'm just trying to figure out 'variables' or state
11:38:55 <warpy> grache28: add 1 for each element of a list?
11:38:58 <EvanR> warpy: this idea not just a way to get around a type system restriction, its a really useful way to structure your code
11:39:22 <warpy> EvanR: can you show me a small example
11:39:29 <EvanR> yeah
11:39:39 <grache28> warpy: that code does a bit more than that - it was to illustrate modify all variables each iteration..
11:39:53 <EvanR> warpy: can you describe some of the things a handler must do
11:40:11 <warpy> EvanR: i could show you my code if you want
11:40:15 <EvanR> ok
11:40:26 <grache28> I want to start with an emptyy list and add a pair to it, then add another pair to it, etc.
11:40:44 <warpy> EvanR: https://github.com/abhin4v/hask-irc/blob/master/Network/IRC/Types.hs
11:40:51 <dwcook> grache28: what will the list ultimately end up containing?
11:41:12 <warpy> grache28: where are the pairs coming from
11:41:25 <grache28> dwcook: [] then [(2,3)] then [(2,3),(3,4)]
11:41:31 <grache28> dwcook: for example
11:41:33 <dwcook> grache28: what do you mean by "then"?
11:41:47 <dwcook> grache28: lists are immutable.
11:41:48 <grache28> warpy, dwcook: http://pastebin.com/BCLyygBk
11:41:51 <Rarrikins> zipWith (+) [0..2] [1..]
11:41:53 <Rarrikins> > zipWith (+) [0..2] [1..]
11:41:55 <lambdabot>  [1,3,5]
11:42:01 <grache28> dwcook: the english word then, not the keyword
11:42:03 <mikusp> spott: did you try to install this failing package explicitly with given version? cabal install package-1.0
11:42:24 <kgadek> grache28: let foo = aux a []
11:42:25 <kgadek>   where bar a (x:xs) = (x+a):(bar (a+1) xs)
11:42:25 <kgadek>         bar _ []     = []
11:42:29 <dwcook> grache28: I didn't think you were talking about the keyword. But the English word "then" here doesn't have a single obvious meaning.
11:42:32 <ryantrinkle> is there an Applicative instance for accumulating non-fatal errors?
11:42:41 <spott> yup, and then when I try to install the rest of the packages, it tries to install package-1.0.4, which fails
11:42:43 <warpy> EvanR: also, example of a handler https://github.com/abhin4v/hask-irc/blob/master/Network/IRC/Handlers/MessageLogger.hs see the toDyn and fromDynamic scattered around
11:42:49 <dwcook> ryantrinkle: perhaps you want Writer with a list?
11:42:51 <EvanR> warpy: erm, so im going to simplify and say that a handler is a stateful thing that takes an IRC message and does some arbitrary IO with it, and returns a message to display in response
11:42:56 <kgadek> grache28: that's exactly what your code does
11:43:02 <warpy> EvanR: exactly
11:43:07 <EvanR> alright
11:43:08 <binroot> I really want to play around with cabal sandboxes. I'm on Ubuntu 14.04, and my cabal version is only 1.16. How do I upgrade?
11:43:11 <grache28> dwcook: showing that I want to go from continuing adding to the same list
11:43:16 <grache28> kgadek: sec to read that
11:43:19 <warpy> EvanR: and the state types can be different for different handlers
11:43:23 <ryantrinkle> dwcook: almost; if a subcomputation produces an error, then it can't continue to the next one
11:43:27 <dwcook> binroot: cabal install cabal-install, then add $HOME/.cabal/bin to your PATH.
11:43:30 <EvanR> warpy: right, thats the point of this exercise
11:43:38 <binroot> dwcook: on it! thanks!
11:43:43 <ryantrinkle> dwcook: i think the thing i'm asking for can't be a monad, because bind requires the actual value
11:43:47 <dwcook> ryantrinkle: then what do you mean "accumulating non-fatal errors"?
11:44:06 <warpy> ya. i spent so much time to figure it out but i couldnt. finally i resorted to using Dynamic
11:44:16 <warpy> which works fine btw
11:44:26 <EvanR> warpy: in this case, im going simplify even further and only talk about privmsg
11:44:27 <spott> awesome, it looks like '--constraint "package installed"' works
11:44:37 <ryantrinkle> dwcook: well, suppose you have something like (,) <$> a <*> b
11:44:41 <ryantrinkle> either a or b can fail
11:44:45 <ryantrinkle> (or both)
11:44:48 <kgadek> grache28: I make few typos, of course aux<->bar and there should be no "let"
11:44:49 <EvanR> you can define more parts of the interface that have other semantics for other messages
11:45:03 <dwcook> ryantrinkle: and what do you want to do when there's failure?
11:45:18 <ryantrinkle> get all the errors
11:45:27 <ryantrinkle> writer can handle the case where one fails
11:45:49 <dwcook> But if a fails, how could you possibly proceed to b?
11:45:49 <ryantrinkle> but if a fails, there's no way to proceed on to b, in a monadic context
11:45:52 <ryantrinkle> exactly
11:46:00 <ryantrinkle> but you can, if it's only applicative, i think
11:46:06 <dwcook> This sounds like a conceptual problem.
11:46:11 <dwcook> Monad is more powerful than Applicative.
11:46:22 <dwcook> If Monad can't do something, Applicative can't either.
11:46:23 <ryantrinkle> correct; and that's what prevents this from working :)
11:46:27 <binroot> dwcook: thanks for your help upgrading cabal! Can people with older version of cabal still use my new and cool cabal sandbox?
11:46:33 <ryantrinkle> i'll take a shot at implementing it
11:46:39 <kgadek> mikusp: OK, I give up, will use FFI or ∅MQ or something. thanks anyway :)
11:47:23 <dwcook> binroot: older versions of cabal don't look for the sandboxes, I think. Though I don't think people usually distribute sandboxes.
11:47:50 <binroot> oh, then what the best way to distribute dead-simple code?
11:49:08 <dwcook> Probably make a cabal package and either upload it to Hackage or at least provide it in some repository. I'm not sure what "dead-simple" would mean here so that it makes a difference.
11:49:44 <binroot> dwcook: should I include a Makefile that basically does 'cabal install' ?
11:50:21 <dwcook> I don't think that would be necessary.
11:50:48 <dwcook> Just distribute a directory with cabal configuration so that cabal can do that work.
11:51:06 <dwcook> It can be as easy as git init ; cabal init # and then follow the prompts
11:51:23 <binroot> why is git necessary here?
11:51:26 <dwcook> Or whatever versioning system you like
11:51:28 <EvanR> warpy: http://codepad.org/R7jXeJsx
11:51:36 <binroot> k
11:51:40 <binroot> thanks dwcook!
11:51:44 <dwcook> It's just a convenience – Then someone can go `git clone your-repository`
11:51:57 <warpy> EvanR: checking
11:52:05 <dwcook> Assuming it's somewhere they can reach it, like an internet server
11:53:00 <EvanR> warpy: well its actually wrong at the bottom
11:53:02 <dwcook> Oh and I left out the step of making a commit but that's pretty much a given for most versioning systems
11:53:42 <warpy> dwcook: not if you use dropbox for versioning!
11:53:56 <dwcook> "most" :)
11:54:05 <simon> be on the safe side like so many students at my department: put your git dir in dropbox!
11:54:15 <EvanR> warpy: http://codepad.org/FQOgvQX9
11:55:53 <ryantrinkle> dwcook: http://lpaste.net/103986
11:55:55 <EvanR> warpy: the Handler type can easily be made into a record with several IO actions, functions or not, representing the interface. lists or maps of such handlers can be used without having to deal with each of the cases by code that uses the interface
11:57:00 <grache28> alright - how do i concat lists?
11:57:01 <angerman> what's the proper way to pad a string? f 6 "foo" -- "000foo"?
11:57:12 <dwcook> @type (++)
11:57:13 <lambdabot> [a] -> [a] -> [a]
11:57:15 <dwcook> grache28: ^
11:58:27 <EvanR> > concat [[1,2],[],[3],[4,5,6]]
11:58:29 <lambdabot>  [1,2,3,4,5,6]
11:59:00 <warpy> EvanR: wow, that is a clever trick
11:59:00 <Yaniel> angerman: depends
11:59:06 <dwcook> > foldr (++) [] [[1,2],[],[3],[4,5,6]]
11:59:07 <lambdabot>  [1,2,3,4,5,6]
11:59:17 <angerman> Yaniel: on?
11:59:21 <Yaniel> or did you mean pad "foo" with zeros
11:59:31 <EvanR> warpy: theres a lot of nice things about it, for example you cant have an uninitialized state like c++
11:59:32 <warpy> EvanR: i get it. this will work. but what if you want to expose the handlers' states to the caller
11:59:35 <DNNX> > let f n s = replicate (n - length s) '0' ++ s
11:59:36 <lambdabot>  not an expression: ‘let f n s = replicate (n - length s) '0' ++ s’
11:59:37 <Yaniel> or whatever string
11:59:41 <vanila> > reverse . take 6 . reverse . (++ repeat '0') $ "foo"
11:59:46 <lambdabot>  mueval: ExitFailure 1
11:59:55 <vanila> oh
11:59:55 <angerman> Yaniel, yes, pad anystring with zeros to length to 6.
12:00:00 <vanila> cant reverse infinitely long lists
12:00:10 <vanila> > reverse . take 6 . (++ repeat '0') . reverse $ "foo"
12:00:11 <lambdabot>  "000foo"
12:00:14 <ryantrinkle> dwcook: imho, the power of monads is a double-edged sword
12:00:42 <DNNX> (\n s -> replicate (n - length s) '0' ++ s) 6 "foo"
12:00:47 <DNNX> > (\n s -> replicate (n - length s) '0' ++ s) 6 "foo"
12:00:48 <lambdabot>  "000foo"
12:00:55 <dwcook> ryantrinkle: why is that?
12:00:58 <simon> ryantrinkle, whereas the power of arrows is a triple-edged sword!
12:01:01 <EvanR> warpy: you can directly return the state itself, in these cases IORef a's for different a's, as part of the interface. do you have a good reason to do that?
12:01:05 * hackagebot effin 0.1.1.0 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.1.1.0 (AnthonyVandikas)
12:01:05 <angerman> vanila, DNNX thanks.
12:01:09 <EvanR> warpy: s/can/cannot/
12:01:30 <dwcook> simon: Is this a reference to how asterisks look kind of pointy? :)
12:01:40 <ryantrinkle> simon: lol
12:01:52 <warpy> EvanR: no i dont. that is exactly why i am having this problem. i am exposing the handlers' states. i dont need to.
12:01:52 <ryantrinkle> dwcook: wrapping the RHS of every bind in a lambda makes it difficult to inspect
12:01:56 <ryantrinkle> (impossible)
12:02:10 <dwcook> ryantrinkle: oh I see. You do have a point.
12:02:14 <warpy> EvanR: but just saying, if you have to do that, this approach will not work.
12:02:23 <EvanR> warpy: right so youre good. i mean, semantically the handler may have no state, like the echo handler shown.
12:02:30 <ryantrinkle> dwcook: the code i pasted does what i was mentioning - but it can't be written as a monad
12:02:32 <warpy> right
12:02:46 <warpy> as i said, this will work. it makes perfect sense.
12:02:55 <warpy> i'll fix my code
12:03:08 <grache28> bleh whjat's the difference in Int and Integer?
12:03:19 <EvanR> > maxBound :: Int
12:03:20 <lambdabot>  9223372036854775807
12:03:26 <EvanR> > maxBound :: Integer
12:03:27 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
12:03:28 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
12:03:29 <dwcook> ryantrinkle: it's kind of like the pesky arr method of Arrow.
12:03:34 <angerman> whats the difference between Process and System.Cmd?
12:03:37 <angerman> which one to use?
12:03:37 <DNNX> I have a string which consists of a number N, followed by N tokens (str1, .. strN), followed by a number M, followed by M tokens (y1...yM). Tokens are separated by whitespace. How do I parse this line into two lists with parsec?
12:04:06 <EvanR> grache28: Int is implemented as a machine word of some sort
12:04:19 <warpy> angerman: the one which is more updated and has more downloads?
12:04:39 <ryantrinkle> dwcook: yes, exactly
12:04:41 <angerman> warpy: mmm. ok.
12:04:54 <grache28> EvanR: tks - i wanna typecast to Int, but not sure why I need to or how: lista = [(1,2)] getting a type error saying it's an Integer
12:04:54 <dwcook> grache28: Integer is arbitrary-size. Int has the abovementioned upper bound as well as a lower one.
12:05:02 <ryantrinkle> dwcook: i used to use arrows... then i took an arr to the knee
12:05:05 <avaritia> DNNX: wouldnt count work?
12:05:11 * dwcook facepalms
12:05:33 <DNNX> avaritia, let me show an example
12:05:43 <warpy> EvanR: thanks a lot for your help!
12:05:44 <ryantrinkle> dwcook: haha yeah, i'm bringing that one back
12:05:57 <EvanR> warpy: and this pattern is good outside haskell
12:06:08 <DEA7TH> https://gist.github.com/anonymous/cab26323e80602f31d51 Why doesn't this work? Apparently it isn't happy with the type of Data.Set?
12:06:18 <DEA7TH> Set.empty *
12:06:19 <warpy> ya, now that you have shown me, i recall it from other places
12:06:27 <DNNX> input string: "2 abc def 3 xxx yyy zzz". result I want as output: (["abc", "def"], ["xxx", "yyy", "zzz"])
12:06:57 <grache28> listb = [(3,4)]        *** Type           : [(Integer,Integer)]         *** Does not match : [(Int,Int)]
12:07:12 <avaritia> DNNX: count is doing exactly what you want
12:07:36 <DEA7TH> Should I specify the type of s?
12:08:35 <dwcook> DEA7TH: at a glance, length looks like it shouldn't be applied to s
12:08:53 <dwcook> Perhaps you wanted Set.size?
12:08:57 <DEA7TH> Ah.
12:08:58 <EvanR> grache28: which one do you want to use
12:09:26 <grache28> Int
12:09:36 <DEA7TH> dwcook: You're correct.
12:09:51 <warpy> EvanR: MVar and IORef seem to have similar APIs. what is the diff between them
12:10:10 <EvanR> warpy: they have different apis, MVar can be 'empty' and IORef cant
12:10:23 <EvanR> reading from an MVar will block if its empty, until something fills it in
12:10:37 <EvanR> use for communication between concurrent processes
12:10:55 <warpy> i think i need MVar then
12:10:57 <EvanR> TVar and IORef are more similar
12:11:19 <EvanR> for holding the state of a handler, i would use IORef or TVar
12:11:26 <EvanR> theres no reason for it to be empty
12:12:21 <warpy> that makes sense
12:12:32 <warpy> that is the diff between IORef and TVar then
12:12:37 <warpy> s/that/what/
12:12:43 <EvanR> you can atomically read/update sets of tvars
12:12:50 <EvanR> from multiple threads
12:13:06 <Gurkenglas> If I have a list of pairs whose set would be a left-total and right-unique relation, does Haskell-Style encourage making the left side a type and turning the list into a function?
12:13:15 <Gurkenglas> (Order is irrelevant.)
12:13:20 <warpy> but IORef has atomicModifyIORef
12:13:35 <EvanR> thats a very limited version of what TVars an do
12:13:38 <Gurkenglas> If so, how do I go about making a subset of instances of a type its own type?
12:13:50 <EvanR> you can only modify one IORef at a time that way
12:14:33 <Gurkenglas> *"subset of a type" would be more proper terminology, I guess
12:14:34 <warpy> hmm. i see
12:15:22 <warpy> IORef seems good enough for my use case
12:15:28 <EvanR> TVars are just way cooler so i default to them
12:15:39 <EvanR> and yes IORef may be good enough
12:15:47 <Gurkenglas> Simpler: How would I make the integers from 1 to 1000 a type?
12:15:58 <vanila> you can't really do that in haskell
12:16:11 <vanila> what works is   type UpToOneThousand = Int
12:16:15 <vanila> then just try not to screw up
12:16:37 <bms1> Gurkenglas: You can make a Newtype
12:17:15 <bms1> hide the Constructor, and make a function which constructs your restricted type, but throws an error when the value is not what you want
12:17:35 <bms1> And then make sure any functions involving your newtype don't allow you to reintroduce undesired values!
12:20:25 <Gurkenglas> @hoogle [a]->[(a,Int)]
12:20:25 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:20:25 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:20:25 <lambdabot> Data.Graph.Inductive.Query.BFS level :: Graph gr => Node -> gr a b -> [(Node, Int)]
12:20:51 <Gurkenglas> How do I go about counting how often a key appears in a list?
12:21:17 <Gurkenglas> (Without low-level implementation.)
12:21:31 <EvanR> length . filter (==k) . map fst
12:21:59 <EvanR> a table of keys and their counts?
12:22:00 <quchen> Gurkenglas: You mean like a histogram?
12:22:02 <Gurkenglas> How would you do map fst when the input is a list of a
12:22:15 <EvanR> group by the key and map to lengths of groups
12:22:32 <Gurkenglas> quchen, *googles histogram* exactly.
12:23:08 <Gurkenglas> How do you group by the key?
12:23:12 <Gurkenglas> :t group
12:23:13 <lambdabot> Eq a => [a] -> [[a]]
12:23:14 <EvanR> :t groupBy
12:23:15 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:23:17 <Gurkenglas> :3
12:23:21 <EvanR> :t comparing
12:23:22 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:23:38 <EvanR> hrm
12:23:58 <Gurkenglas> >group [1,2,1,1]
12:24:04 <Gurkenglas> > group [1,2,1,1]
12:24:06 <lambdabot>  [[1],[2],[1,1]]
12:24:10 <EvanR> sort first
12:24:36 <EvanR> :t on
12:24:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:24:51 <Gurkenglas> > groupBy (==) [1,2,1,1]
12:24:52 <lambdabot>  [[1],[2],[1,1]]
12:25:31 <Gurkenglas> :t sort
12:25:32 <lambdabot> Ord a => [a] -> [a]
12:25:48 <quchen> Data.Map has functions to do this sort of thing.
12:25:58 <quchen> > M.fromListWith (+) . flip zip (repeat 1) $ [1,  2,2,  3,3,3,  4,4,4,4,  5,5,5,5,5]
12:25:59 <warpy> EvanR: i am yet to figure out TVar
12:25:59 <lambdabot>  fromList [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:26:01 <EvanR> > groupBy (on (==) fst) [(1,'a'), (1,'b'), (1,'c'), (2,'d')]
12:26:03 <lambdabot>  [[(1,'a'),(1,'b'),(1,'c')],[(2,'d')]]
12:26:55 <EvanR> warpy: its the same as IORef, until you want to modify one. in which case use atomically
12:27:14 <EvanR> you can also atomically read from several tvars to get a consistent snapshot
12:28:15 <EvanR> atomically (modifyTVar tv (+1)), example
12:28:37 <EvanR> atomically (modifyTVar tv1 (+1) >> modifyTVar tv2 (-1))
12:28:54 <EvanR> well not (-1), pred
12:29:00 <quchen> (subtract 1)
12:30:14 <DR6> with the new type level nats
12:30:21 <DR6> how can I prove that
12:30:35 <DR6> if 1+a ~ n and 1+bñ
12:31:04 <DR6> *1+a~n and 1+b~n ==> a~b
12:31:17 <DR6> I thought it would be done automatically
12:31:21 <DEA7TH> What is a shorter way to write the following lambda: (\x -> not (x == 2))
12:31:34 <DR6> not . (==2)
12:31:35 <Gurkenglas> not . (==2)
12:31:40 <EvanR> @pl (\x -> not (x == 2))
12:31:41 <lambdabot> (2 /=)
12:31:47 <EvanR> ;)
12:31:48 <Gurkenglas> @pl (\x -> not (x == 2))
12:31:48 <lambdabot> (2 /=)
12:31:50 <Gurkenglas> Dammit
12:31:59 <Gurkenglas> Will you stop ninjaing me
12:32:06 <quchen> Gurkenglas: Did you see my histogram solution above?
12:36:37 <pavonia> DR6: Not sure if you can, AFAIK (+) is a type family so it's not necessarily injective
12:36:54 <DR6> yes, so that's why ghc can't do it automatically
12:36:56 <DR6> I know
12:37:15 <DR6> but is there some way to mingle with type equalities to get a type level proof?
12:37:32 <DR6> With something like data.type.equality?
12:38:35 <Gurkenglas> quchen, oic. What can lambdabot tell me about how to work with things like M.Map?
12:39:42 <quchen> Gurkenglas: Lambdabot doesn't tell you much about that. But Map is fairly simple: it's a Key -> Value data structure with unique keys. It's basically a hash map.
12:40:06 <quchen> You can read the API docs, it's well-documented. http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
12:40:13 <EvanR> by is not implemented by hashing anything
12:40:18 <Gurkenglas> Ah well. *reads last line* oh yes thatll do
12:41:03 <quchen> EvanR: Sure it does. The hash function is the identity.
12:41:15 <EvanR> nice
12:42:12 <quchen> Gurkenglas: You can view "Map k v" as an efficient implementation of "[(k, v)]" with a nice API that supplies lookup, insertion, folds etc.
12:42:31 <Gurkenglas> kk
12:42:33 <warpy> EvanR: starting converting my handlers to use IORef and already found an compilation error with Dynamic!
12:42:36 <Algebr> What's the easiest to use pretty printer?
12:42:42 <ajf> I have a double and an int and want to multiply them and get a double
12:42:43 <ajf> how do?
12:42:59 <quchen> > fromIntegral (2 :: Int) * (3.14 :: Double)
12:43:01 <lambdabot>  6.28
12:43:13 <ajf> quchen: thanks
12:43:27 <EvanR> warpy: meh good thing you dont need dynamic
12:44:01 <haskeel> i can get a grip on inmutable variables - how can add more and more to a list
12:44:16 <quchen> @hackage pretty -- Algebr
12:44:17 <lambdabot> http://hackage.haskell.org/package/pretty -- Algebr
12:44:31 <EvanR> > "more" : []
12:44:32 <lambdabot>  ["more"]
12:44:34 <DEA7TH> [1:999] returns type [Integer], how can I make it return [Int] instead?
12:44:50 <quchen> DEA7TH: Explicit type annotation.
12:44:58 <vanila> [1..999] or [1,999]
12:45:02 <DEA7TH> I could do {a :: Int}; {a = [1:999]} but that's a bit long
12:45:12 <quchen> That's not valid Haskell.
12:45:18 <DEA7TH> {} is a line
12:45:34 <quchen> :t [1..10] :: [Int]
12:45:35 <lambdabot> [Int]
12:45:35 <DEA7TH> a :: Int \n a = [1:999]
12:45:40 <quchen> :t [1 :: Int ..10]
12:45:41 <lambdabot> [Int]
12:45:58 <quchen> (1 : 999 is probably also not valid Haskell.)
12:46:02 <DEA7TH> ah, that should work
12:46:40 <DEA7TH> yeah my bad
12:47:09 <quchen> DEA7TH: Haskell has a defaulting mechanism. If a class needs to be decided, such as Show when you're printing "1", then there are a couple of default types looked at. Integer and Double are the standard ones, I believe. If one of them typechecks, they're used automatically.
12:47:21 <quchen> -Wall warns you about this kind of defaulting.
12:47:33 <quchen> -fwarn-defaults is the precise flag for the warnings, I believe.
12:48:09 <katsupnfries> What is the proper way to store API client id/secret information in a separate file? http://stackoverflow.com/q/23596884/1470114
12:49:03 <EvanR> katsupnfries: i use environment variables
12:49:20 <EvanR> but you can just as easily read from a file
12:50:21 <katsupnfries> evanr: how do you read from a file?
12:51:57 <darthdeus> anyone here using hdevtools?
12:52:35 <identity> I used to use it with vim -- I dropped it in favor of ghc-mod
12:52:50 <darthdeus> i'm trying to make it work with a simple yesod project, but it doesn't seem to be loading things properly
12:52:59 <quchen> katsupnfries: Are you familiar with Haskell IO?
12:53:23 <darthdeus> identity: I'm getting 'Could not find module ‘Yesod’' and 'Could not find module ‘Database.Persist.Quasi’ ... and it also shows errors on #if :\ any thoughts?
12:53:36 <katsupnfries> quchen: not familiar with the use of Haskell IO
12:53:53 <identity> darthdeus: Unfortunately, I didn't use it very much.
12:54:02 <quchen> Then you should probably have a look at the IO chapter of one of the standard Haskell books.
12:54:14 <darthdeus> identity: oh sorry i didn't notice you said you dropped it for ghc-mod, i read it the other way around
12:54:25 <quchen> katsupnfries: https://github.com/quchen/articles/blob/master/fbut.md#how-to-start-learning-haskell
12:54:31 <darthdeus> i'll take a look at ghc-mod :)
12:55:42 <kristi_kodare> darthdeus is yesod installed properly?
12:55:55 <awestroke> how do I fully evaluate something without using/printing it?
12:56:10 <quchen> awestroke: evaluate, deepseq
12:56:41 <awestroke> quchen: evaluate is WHNF though
12:56:48 <ajf> setTimeout ((fromRational (1000 / 30)) :: Int) main
12:56:54 <ajf> It should be obvious what I’m trying to do
12:56:56 <kristi_kodare> awestroke: strict '!'? :)
12:56:58 <ajf> but it doesn’t work
12:57:09 <ajf> how do I divide 1000/30 and round down?
12:57:15 <merijn> ajf: Use div
12:57:18 <merijn> :t (/)
12:57:19 <lambdabot> Fractional a => a -> a -> a
12:57:21 <merijn> :t div
12:57:22 <lambdabot> Integral a => a -> a -> a
12:57:23 <identity> ajf: div, truncate, ceiling, floor,
12:57:24 <ajf> ah
12:57:25 <ajf> thanks :)
12:57:26 <quchen> awestroke: That's what the deepseq part is for. (evaluate . force :: NFData a => a -> IO ()) will force the argument fully.
12:57:34 <ajf> So 1000 `div` 30?
12:57:37 <identity> yes.
12:57:39 <merijn> ajf: / is only for fractional types, div is for integral division :)
12:57:47 <ajf> Thanks
12:57:53 <darthdeus> kristi_kodare: yes, cabal repl works, but hdevtools check shows errors
12:57:58 <haskeel> http://pastebin.com/jwRUMgr7 -- can't figure out how to solve this problem without oop/imperative style variables
12:58:02 <quchen> awestroke: Evaluating (force x) to WHNF evaluates x to NF.
12:58:09 <quchen> Or Haskell's version of NF anyway.
12:58:53 <kristi_kodare> darthdeus: can you create a bare yesod project with no database connectivity?
12:59:11 <kristi_kodare> it asks you when you create a new project and you can choose "no" or something like it
12:59:25 <darthdeus> kristi_kodare: yeah
13:00:14 <darthdeus> kristi_kodare: though I still get a lexical error at #if
13:00:47 <kristi_kodare> darthdeus: then i don't know :(
13:01:02 <ajf> Oh, fantastic. setTimeout doesn’t work properly
13:01:29 <darthdeus> kristi_kodare: i'll try ghc-mod :) it seems hdevtools hasn't been updated in 2 years anyway
13:01:36 <sveit> i have looked on the wiki for memoization, but it is not clear to me that it is possible in Haskell to write some recursive function f x, then have some function memoize f that memoizes over the argument?
13:01:51 <sveit> and causes the recursive calls to be to the original memoized version?
13:02:30 <identity> ajf: where is that function from?
13:02:33 <identity> @hoogle setTimeout
13:02:33 <lambdabot> No results found
13:02:43 <ajf> Haste. Haskell -> JS compiler
13:02:49 <identity> ah.
13:02:59 <ajf> It should be on hackage though
13:03:09 <ajf> Unless my PC exists in a parallel universe
13:04:26 <EvanR> sveit: it seems to me that you might want some configurability of memoization rather than a one size fits all memo higher order function
13:04:27 <ion> ‌@hoogle exists in a parallel universe
13:04:34 <identity> if that is the case, then irc must be an interdimensional communication medium. But yes, it's on hackage, but I've never used it so I can't really help you.
13:04:40 <EvanR> sveit: have you looked at https://hackage.haskell.org/package/data-memocombinators
13:04:53 <ajf> Maybe hoogle’s index is limited or something
13:05:05 <quchen> When Hoogle doesn't work, try Hayoo.
13:06:01 <ajf> Aha
13:06:04 <ajf> Hayoo finds it
13:06:07 <darthdeus> identity: is it normal that ghc-mod takes like 3-5 seconds to run a command?
13:06:12 * hackagebot operational 0.2.3.2 - Implementation of difficult monads made easy  with operational semantics.  http://hackage.haskell.org/package/operational-0.2.3.2 (HeinrichApfelmus)
13:06:16 <ajf> @hayoo does this work
13:06:16 <lambdabot> Unknown command, try @list
13:06:20 <ajf> aw
13:06:40 <identity> darthdeus: I've only ever used it as a plugin for vim, and it definitely does not take that long for me.
13:06:47 <sveit> EvanR: no I have not, looking now
13:06:52 <darthdeus> identity: yeah i just installed the plugin in vim as well, and it's really slow
13:07:12 <darthdeus> like compared to hdevtools which wsa instant this is taking like a few seconds for everything i tried so far :( maybe i missed something
13:07:27 <identity> darthdeus: I'm not sure. It is pretty fast for me
13:07:28 <sveit> EvanR: but why would I not want a "one size fits all" function? i know the argument "i can make it in another language" has problems, but that is basically what I am thinking right now :)
13:07:30 <identity> like less than a second.
13:07:49 <EvanR> sveit: because you might might like the amount of memory it uses
13:07:50 <lispy> I posted my CPP question to reddit: http://www.reddit.com/r/haskell/comments/25aw7o/solutions_with_respect_to_conditional_compilation/
13:08:17 <DEA7TH> If I have a collection of (a :: Int, b :: Int) tuples, and I want the tuple with the max b, what is the most elegant way to get it? I've already tried maximumBy, is there something better?
13:08:46 <DEA7TH> collection -> maximumBy (compare `on` snd) collection
13:08:57 <quchen> If you've got a [(Int, Int)], that looks like the proper solution.
13:09:11 <enthropy> lispy: you can make cabal pick completely different files depending on OS etc.
13:09:44 <identity> I like 'comparing' from Data.Ord
13:09:48 <ajf> Maybe I’m missing something obvious and it’s my Haskell at fault
13:09:48 <ajf> hmmm
13:09:55 <identity> > maximumBy (comparing snd) [(1,2), (3, 4)]
13:09:57 <lambdabot>  (3,4)
13:10:13 <sveit> on a related note, does haskell have a solution to defining functions with numbers of arguments on the end? i.e. zipWithN? again, I understand Haskell makes this difficult, but is there a "clean" way to handle this sort of thing?
13:10:25 <EvanR> sveit: really, it seems that this library does just that, memoizes whatever your function is, but doesnt let you control the space usable...
13:10:26 <enthropy> lispy: template haskell is another option (but I'm not sure people actually use it for conditional compilation)
13:10:27 <srhb> sveit: Not really.
13:10:39 <prophile> sveit: in that particular case, yes - ZipList plus the applicative instance
13:10:51 <EvanR> usage*
13:10:58 <ajf> https://gist.github.com/TazeTSchnitzel/04efd36ca2055a818f20#file-haskell-wars-hs-L8
13:11:02 <ajf> Here’s my problem
13:11:12 <ajf> It’s likely Haste at fault, but maybe I’m missing something obvious
13:11:21 <quchen> sveit: The clean way is not having a function with a variable amount of arguments.
13:11:22 <ajf> I’m telling it to run main in 1/30s
13:11:25 <ajf> It’s not working
13:11:43 <prophile> there are also printf-style horrendous hax
13:11:49 <EvanR> sveit: a function that takes a Data.Data as argument ;)
13:12:06 <identity> I understand printf is black magic
13:12:07 <benzrf> oh boy is somebody trying to make a variadic function
13:12:08 <lispy> enthropy: what are the pros&cons to TH? con: it doesn't work everywhere and requires GHC and you have to learn that part of the language. Pros: ?
13:12:09 * benzrf leans back
13:12:14 <identity> but it's really convenient
13:12:18 <benzrf> lispy: macros
13:12:27 <benzrf> lispy: you have the nick lispy, you should understand
13:12:28 <benzrf> :-O
13:12:37 <ajf> Variadics are possible in Haskell, just inconvenient, right?
13:12:45 <lispy> benzrf: :) I meant in the context of this question: http://www.reddit.com/r/haskell/comments/25aw7o/solutions_with_respect_to_conditional_compilation/
13:13:15 <benzrf> ajf: if by inconvenient you mean 'a terrifyingly awful hack', then yes
13:13:25 <int-e> ajf: with some limitations. Text.Printf is the canonical examplee, I guess.
13:13:25 <ajf> something like that :P
13:13:26 <byorgey> ajf: yes, for a good example see http://hackage.haskell.org/package/base-4.7.0.0/docs/Text-Printf.html
13:13:34 <benzrf> who wants a variadic function anyway :-O
13:13:52 <EvanR> benzrf: when zipWith7 isnt good enough ;)
13:13:52 <enthropy> lispy: I'm pretty sure you can do stuff like "unless this instance exists, generate this instance"
13:14:02 <enthropy> which is probably more reliable than version numbers
13:14:19 <benzrf> EvanR: just use this
13:14:24 <benzrf> @src zipWithN
13:14:24 <lambdabot> Source not found. You type like i drive.
13:14:28 <benzrf> actually
13:14:30 <benzrf> ignore that
13:14:33 <benzrf> use transpose!
13:14:40 <EvanR> yeah
13:14:46 <enthropy> especially if it's for a package you don't directly depend on (and you don't want to add that package to the dependencies: ex. you depend on mtl but not on transformers)
13:15:20 <benzrf> > transpose ["this", "isli", "keva", "riad", "iczi", "p!!!"]
13:15:21 <lambdabot>  ["tikrip","hseic!","ilvaz!","siadi!"]
13:15:26 <ajf> How does Printf manage to not break Haskell’s type system?
13:15:31 <benzrf> ajf: type class bullshit
13:15:39 <prophile> *TERRIFYING type class bullshit
13:15:43 <benzrf> :t printf
13:15:44 <lambdabot> PrintfType r => String -> r
13:15:49 <ajf> :t r
13:15:50 <lambdabot> Expr
13:15:54 <benzrf> > r
13:15:54 <ajf> hehe
13:15:55 <lambdabot>  r
13:16:02 <ajf> I’m being silly, guys
13:16:06 <int-e> prophile: it's not that bad
13:16:07 <ajf> I knew fine well that wouldn’t work
13:16:09 <benzrf> ajf: PrintfType includes certain functions
13:16:12 <ajf> :r PrintfType
13:16:16 <benzrf> ajf: so it can yield a string or a func
13:16:17 <ajf> :k PrintfType
13:16:18 <lambdabot> * -> Constraint
13:16:20 <prophile> int-e: tell that to the families of its victims
13:16:21 <benzrf> its complicated
13:16:46 <enthropy> ajf: you can't really composable variadic functions. You could keep the "collect N arguments" and "apply function of N arguments" kind of separate as in http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-Keyword.html
13:16:52 <enthropy> *compose
13:17:33 <quchen> Variadic functions on the Haskell wiki: http://www.haskell.org/haskellwiki/Varargs
13:18:59 <int-e> prophile: It's an instructive lesson about the power of type classes, but one should not imitate it without a very good reason.
13:19:12 <EvanR> "just accumulate the IO monad" ;)
13:23:41 <edwardk> djahandarie: coerce has the problem that it locks you into 7.8
13:24:08 * lispy thinks int-e's advice generalizes to about 90% of cool programming tricks, especially in Haskell
13:24:51 <lispy> edwardk: you got some CPP error building OpenGL stuff on your mac, is that right?
13:25:25 <djahandarie> edwardk, yeah. I wasn't thinking of doing it now, but a while after the platform including it is out.
13:25:48 <edwardk> lispy:  src/Graphics/Rendering/OpenGL/Raw/EXT/SceneMarker.hs:30:44: parse error on input ‘glBeginScene’
13:25:53 <edwardk> parse error
13:26:58 <lispy> edwardk: so what does lens do about CPP on osx?
13:27:52 <edwardk> we use clang
13:28:03 <edwardk> it just has a slightly stricter interpretation of the ANSI spec
13:28:16 <edwardk> so there are a few cases where it differs in interpretation from gcc.
13:28:26 <lispy> So you just change your macros to match?
13:28:45 <edwardk> i change my macros to be more ANSI compliant and then I'm all set. ;)
13:29:05 <lispy> edwardk: I don't know if you saw, this but I just posted this question. I'm trying to understand things better: http://www.reddit.com/r/haskell/comments/25aw7o/solutions_with_respect_to_conditional_compilation/
13:29:10 <edwardk> I had one set of macros get appreciably uglier. All the others just worked.
13:29:37 <lispy> clang has a traditional mode for CPP but it's not full implemented (according to their sources)
13:29:44 <merijn> Speaking of which
13:29:56 <lispy> I don't really know the difference between ansi CPP and K&R.
13:29:59 <lispy> I guess I Need to look that up.
13:30:10 <merijn> I'm working on a composable preprocessor that has support for HPP, i.e. CPP but with haskell tokenization instead of C tokenisation
13:30:44 <merijn> The only problem is how many warnings I wanna generate for scenarios where MagicHash collides with the CPP stringify and concat commands
13:31:07 <djahandarie> edwardk, BTW, I've recently been going pretty heavy into math, trying to learn whatever I can from it. Right now my sequence is pretty standard (here's my reading list: http://pastebin.com/7KnyGUiR). As someone who has done exactly this, I was curious if you had any pointers on areas that have been particularly valuable to you that I should try to specifically integrate.
13:31:31 <merijn> In standard CPP "#define CONCAT(a, b) a## b" is valid syntax for concatenation but a## is a valid identifier with MagicHash
13:31:53 <merijn> I'm thinking of just requiring a space between tokens and ## to work as concat and anything else being treated as MagicHash token
13:32:20 <hpc> merijn: would this work?
13:32:28 <hpc> #define CONCAT(a, b) a\
13:32:28 <hpc> b
13:32:38 <lispy> djahandarie: make sure you're studying effectively. That's really step 0 and lots of people overlook it or think they know and get it wrong.
13:32:42 <merijn> hpc: No
13:32:56 <merijn> hpc: All CPP tokens are considered space separated after initial parse
13:33:02 <hpc> :(
13:33:05 <merijn> hpc: So "a/**/b" is also two tokens
13:33:40 <merijn> Although this won't be able to be used as a CPP replacement for GHC anyway as it would have too many dependencies to ship with GHC
13:33:43 <lispy> edwardk: do you know where I can find the differences between ansi cpp and k&r? Google thinks I want ansi C vs. K&R C and so searching is useless
13:33:48 <djahandarie> lispy, good point.
13:34:40 <edwardk> hpc: conct waas one macro i couldn't figure out with the clang approach in my quick test
13:34:43 <edwardk> er concat
13:34:52 <merijn> lispy: Why do you care about the difference between those two?
13:35:03 <merijn> lispy: The real problem is -traditional vs modern CPP
13:35:08 <lispy> merijn: it will help me understand what I need to change
13:35:44 <merijn> The fact that GHC needs -traditional mode is an ugly hack due to GHC using a C compilers CPP anyway
13:36:00 <merijn> If you have a preprocessor with proper haskell tokenisation the problem disappears
13:36:12 <lispy> merijn: https://github.com/haskell-opengl/OpenGLRaw/blob/master/src/Graphics/Rendering/OpenGL/Raw/EXT/SceneMarker.hs
13:36:31 <lispy> that EXTENSION_ENTRY macro is giving us problems on clang
13:36:57 <lispy> merijn: defined here https://github.com/haskell-opengl/OpenGLRaw/blob/master/include/HsOpenGLRaw.h
13:37:03 <edwardk> djahandarie: skimming your list, I'd add: Algebra by Serge Lang, Foundations of Differential Geometry by Kobayashi & Nomizu...
13:37:11 <EvanR> im having issues styling this function, it shouldnt be hard to read, but it is right now http://lpaste.net/103989
13:37:39 <edwardk> djahandarie: i can give a better list of additions when i get home and can look at my shelf
13:37:49 <edwardk> djahandarie: but that'll be a week or so
13:37:56 <merijn> lispy: Those /**/ are wrong
13:38:08 <merijn> lispy: That won't concatenate
13:38:14 <merijn> At least not on a modern CPP
13:38:24 <merijn> Not sure about -traditional mode, but I'd be surprised
13:38:29 <djahandarie> Heh, I think I'm going to have read every book on Algebra in existence by the end of this...
13:38:34 <identity> djahandarie: that's a pretty big reading list
13:38:47 <djahandarie> edwardk, alright, thanks. Will poke you again some time later.
13:38:54 <merijn> lispy: FYI, if that macro works on GCC, that's a gcc bug
13:39:00 <edwardk> lispy: anyways the one thing i can't find a way to do with clang cpp that i could do with gcc's is glue together identifiers
13:39:00 <djahandarie> identity, yeah. Two years or so at my current rate.
13:39:16 <lispy> edwardk: isn't that just ## ?
13:39:19 <merijn> edwardk: What's wrong with ## ?
13:39:21 <identity> djahandarie: ah, yeah, that sounds like a meaningful timeframe
13:39:32 <edwardk> does that work on clang?
13:39:36 <merijn> edwardk: Yes
13:39:41 <edwardk> if so i'll feel really dumb ;)
13:39:50 <edwardk> i guess i missed the obvious fix somehow
13:39:51 <merijn> edwardk: # and ## are standard and I tested both of them in clang and gcc last friday
13:40:07 <exicer_> If I've got a cabal file with multiple executables, is it possible to import from one executable to the other ?
13:40:31 <merijn> exicer_: No, but you can define a library for shared code and import that library into the different executables
13:40:59 <edwardk> merijn: i had #define CAT(a, b) a##b but it didn't work in a macro for http://hackage.haskell.org/package/lens-4.0/docs/src/Control-Lens-Internal-Reflection.html
13:41:23 <edwardk> merijn: so something is mismatched between the claim ## just works and my getting it to work on clang in lens
13:41:36 <exicer_> merijn: Cool, cheers.
13:42:05 <merijn> edwardk: Which clang? Which flags?
13:42:25 <edwardk> don't remember any more it was ~lens 4
13:43:05 <merijn> Works with both -traditional and without for me
13:45:20 <edwardk> then something else went wrong. *shrug* i just remember having to rewrite those macros to get it all to work
13:45:37 <lispy> merijn: so you think I should use ## instead of /**/ or something else?
13:45:49 <lispy> I don't get why the /**/ is even in there
13:46:06 <lispy> ah, _entry is a macro parameter
13:46:28 <lispy> it wants to build dyn_foo
13:46:59 <benzrf> edwardk: so what hypothetical advantage do machines have over pipes anyway
13:47:02 <benzrf> i feel like ive asked this before...
13:47:04 <benzrf> sorry :P
13:47:34 <merijn> lispy: Right, but after initial parse and tokenisation (which find 'a' and 'b' as seperate tokens in "a/**/b") token are not ever pasted together
13:47:42 <merijn> lispy: Hence why ## exists
13:48:05 * merijn spend half of friday reading the C11 CPP spec to figure out exactly how things worked >.>
13:49:37 <lispy> I feel bad that I didn't pay more attention when this first came up. I know about # and ## for CPP and just figured everyone else did too and that they decided they won't work here.
13:49:49 <lispy> I bet it's that they didn't know and found /**/ work in traditional mode
13:49:59 <lispy> oh, nope parse error
13:50:06 <merijn> lispy: Parse error?
13:50:07 <merijn> lolwut
13:50:14 <lispy> I need spaces around the ##, I bet
13:50:20 <lispy> And that's probably what edwardk did wrong
13:51:10 <merijn> lispy: It parses fine in both clang and gcc here, but it does as the standard specifies and doesn't concatenate
13:51:12 <lispy> merijn: even with the spaces it's still a parse error.
13:51:25 <merijn> lispy: pastebin the exact CPP please?
13:51:34 <lispy> BTW, it's a parse error at the use site not the definition
13:55:34 <lispy> merijn: http://lpaste.net/103991
13:57:25 <merijn> lispy: Ah, I was testing clang/gcc directly
13:57:36 <merijn> I know the GHC bollockses up ## and #
13:57:40 <merijn> But I don't know why
13:57:42 <joelteon> bolloxes
13:57:58 <merijn> I tried looking up how CPP was called from ghc
13:58:11 <lispy> merijn: http://lpaste.net/103992  <-- the .h file in case you wonder
13:58:18 <merijn> I'm now writing my own CPP program, that should indicate how well that went
13:58:25 <merijn> Well, HPP
13:58:55 <enthropy> benmachine: is haskell-src-meta broken: http://lpaste.net/103957 ?
14:00:48 <benmachine> enthropy: usually.
14:00:54 <lispy> merijn: calling cpp directly I get: include/HsOpenGLRaw.h:21:36: error: '#' is not followed by a macro parameter
14:01:35 <lispy> oh
14:01:41 <lispy> merijn: yeah, so #-} is bad
14:01:41 <benmachine> enthropy: thanks. I'd guess I uploaded something wrong
14:01:55 <lispy> merijn: hence your comment about tokenization
14:02:24 <merijn> lispy: You can't start a line with #-}
14:02:27 <merijn> oh
14:02:42 <lispy> merijn: and {-# NOINLINE is probabl also bad
14:02:55 <lispy> can # be escaped in cpp?
14:03:10 <benmachine> enthropy: nope, I'm just terrible at programming
14:03:25 <merijn> lispy: No
14:03:44 <merijn> lispy: Yeah, the NOINLINE fails
14:03:52 <merijn> That will produce "NOINLINE"
14:04:05 <joelteon> would Haskell benefit from its own preprocessor?
14:04:26 <lispy> joelteon: cpphs exists, but I guess it's non-standard
14:04:41 <merijn> lispy: To many dependencies although people of thinking of moving to it
14:04:54 <merijn> cpphs is also pretty damn inefficient
14:05:02 <merijn> It's triple (!!!!) pass and keeps everything in memory
14:05:11 <merijn> CPP should be single pass
14:05:48 <benmachine> enthropy: reuploaded
14:06:04 <lispy> joelteon: For context: http://www.reddit.com/r/haskell/comments/25aw7o/solutions_with_respect_to_conditional_compilation/
14:06:19 * hackagebot boolean-normal-forms 0.0.0.1 - Boolean normal form: NNF, DNF & CNF  http://hackage.haskell.org/package/boolean-normal-forms-0.0.0.1 (phadej)
14:06:21 * hackagebot haskell-src-meta 0.6.0.7 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.7 (BenMillwood)
14:06:21 <Fuuzetsu> say I have 2 packages which provide a module with the same name, what now?
14:06:38 <Fuuzetsu> (a module that I want to use)
14:06:41 <benmachine> enthropy: I don't understand all the errors though
14:07:02 <lispy> merijn: I hate to be "that guy" but I'll go ahead and say it. If cpphs weren't GPL'd, I'd be willing to contribute.
14:07:05 <benmachine> enthropy: IfAlt was added in HSE 1.15, which is what I think I'm requiring
14:07:48 <benmachine> enthropy: any idea what you're building against?
14:09:23 <lispy> merijn: #define HASH # and change the comments to {-HASH NOINLINE
14:09:35 <lispy> merijn: that works for cpp in modern mode
14:09:38 <lispy> now to test with ghc
14:10:13 <lispy> merijn: so now with ghc it fails because ## is being ignored
14:10:34 <merijn> lispy: Right, but as I said I have no clue what's happening with regards to how GHC calls CPP
14:10:43 <lispy> they add -traditional
14:10:57 <lispy> you can use ghc -v3 to see
14:11:01 <merijn> I spend 2 full working days and 3 hours of ranting at a colleague trying to figure out why GHC's CPP and manually calling CPP with the same flags differ
14:11:10 <merijn> I still have no fucking clue
14:11:48 <merijn> lispy: That's not it, clang and gcc *both* support ## even in -traditional mode
14:12:00 <Fuuzetsu> CPP issues every day
14:12:15 <lispy> There are more flags to try then. -x assembler-with-cpp looks fishy
14:18:53 <awestroke> I can't benchmark my functions because my data type isn't instance of NFData. I can't derive NFData. I can't make my type instance of NFData because "`rnf' is not a (visible) method of class `NFData'". what
14:19:22 <merijn> Anyone know when Tekmo is usually around?
14:20:28 <carter> lispy: the assembler with cpp thing is to make CLANG work as a cpp
14:22:16 <dwcook> merijn: Anytime I've looked for him here in the past several weeks I haven't seen him.
14:22:30 <dwcook> merijn: He has, however, replied to various emails I've sent him in the meantime.
14:22:48 <merijn> I guess I should just mail the mailing list, but that means first coherently being able to formulate what I want, which is a problem atm >.>
14:23:14 <merijn> Alternatively, is there a nice FreeT tutorial? Maybe pipes-group does what I want, but I don't really grok FreeT yet
14:23:25 <dwcook> I think he posted one on his blog, no?
14:24:02 <dwcook> I know he at least posted on Free but maybe also FreeT
14:24:03 <awestroke> does anyone know?
14:24:06 <merijn> His blogs never quite cover what I care about
14:24:19 <merijn> The pipes-parse tutorial for example doesn't tell me much useful
14:24:47 <lispy> merijn: FWIW, -traditional is the only flag that gives me grief here.
14:24:54 <hpc> merijn: you know how Free works?
14:25:41 <merijn> hpc: I think so? >.>
14:25:54 <lispy> merijn: in fact, as long as I pass -traditional and -x assembler-with-cpp I'm getting the same output as when ghc runs cpp (module path separators)
14:26:06 <dwcook> http://www.haskellforall.com/2012/07/free-monad-transformers.html
14:26:35 <Algebr> byorgey: You around?
14:27:20 <hpc> merijn: at a very very rough level, it lifts a functor into a monad by making it act somewhat like Maybe
14:27:46 <shachaf> hpc: ?
14:28:26 <benzrf> merijn: inasmuch as i understand free monads, the idea is that you provide a meaningless instance that does nothing more than track bindings
14:28:34 <benzrf> which can be useful so that you can later replace it with real bindings
14:28:47 <benzrf> i.e. simulate IO with a fake IO datatype with FreeFull
14:28:49 <benzrf> *Free
14:28:55 <benzrf> then later replace the free binds with IO binds
14:29:11 <hpc> shachaf: that's what FreeF is
14:29:22 <dwcook> @src Free
14:29:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:29:32 <FreeFull> With me
14:29:35 <FreeFull> With meeee
14:29:43 <benzrf> similarly, free monoids just put the value into a 1-element list
14:29:58 <benzrf> so mconcat just builds up a list of mappended stuff
14:29:59 <Ralith> FreeFull: putStrLn "Hello, world!"
14:30:24 <shachaf> hpc: Where did FreeF come up? I thought you were talking about Free.
14:30:29 <merijn> Right, I think I get how pipes-group uses FreeT
14:30:30 <shachaf> And how is FreeF like Maybe?
14:30:33 <benzrf> what is FreeF?
14:30:47 <merijn> And I think what I want/need is FreeT
14:30:56 <hpc> FreeT is defined in terms of FreeF
14:31:47 <EvanR> im glad i rendered some test text with graphics drawing combinators to see that it is all upside down because i tried to write whole game in terms of a coordinate system where y=0 was at the top and increased downwards
14:32:07 <EvanR> before i tried to write the whole game...*
14:32:11 <benzrf> hey so
14:32:27 <benzrf> i'm starting in on this paper http://www.berniepope.id.au/docs/BerniePope.PhD.Thesis.pdf
14:32:33 <ajf> OH I’m an idiot
14:32:34 <benzrf> and declarative debugging looks pretty interesting
14:32:44 <ajf> I confused the type of a monad with it’s type constructor
14:32:47 <benzrf> but buddha, the one it mentions, looks out of date
14:32:56 <benzrf> is there anything like what the paper discusses that i can actually use practically?
14:32:59 <ajf> an IO () contains a lot more info than an empty tuple :)
14:33:11 <ajf> Well, usually :D
14:33:24 <shachaf> I'm not sure what you're going for at this point.
14:33:24 <merijn> ajf: "IO ()" is "an IO action that eventually produces a ()"
14:33:37 <ajf> merijn: right
14:34:12 <merijn> ajf: This blog post is a decent explanation, although you may already realise most of what it says: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
14:35:27 <ajf> merijn: Thanks, though I have a pretty good understanding of what a monad is. I just confused types and constructors, that’s all :)
14:35:28 <shachaf> "FreeF" isn't very important
14:35:37 <shachaf> You could easily write newtype FreeT f m a = FreeT { runFreeT :: m (Either a (f (FreeT f m a))) }
14:35:40 <FreeFull> I get highlighted by FreeF
14:35:43 <FreeFull> Maybe I should fix that
14:35:52 <shachaf> GHC has something like that.
14:36:26 <bacon1989> so has there been any cool projects any of you ahve done with ghcjs yet?
14:36:35 <bacon1989> i'm curious to know what kinds of things have been made possible
14:36:49 <ajf> ghcjs? Another GHC -> JS compiler?
14:37:16 <bacon1989> yeah... there's more than one?
14:37:28 <srhb> Not that I know of.
14:37:42 <Maior> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
14:37:44 <Maior> etc.
14:38:19 <spott> hey, has anyone actually installed ihaskell lately?
14:39:12 <merijn> srhb: The Utrecht haskell compiler supports JS too
14:39:30 <merijn> And then there are Fay and a few others that compile "haskell-like" language to JS
14:40:58 <bacon1989> hmm
14:41:08 <bacon1989> i've been interested in haskell as a server
14:41:17 <bacon1989> but I thought ghcjs would be neat
14:42:12 <fuzzyhorns> hello haskell
14:42:17 <rhaps0dy> hello fuzzyhorns
14:42:30 <Tony32> Can anyone help me change this so that it prompts the user for a string instead of having to enter the string in the source? - http://lpaste.net/2368800117307211776
14:42:43 <fuzzyhorns> I am having an issue doing cabal install cabal-install on mavericks
14:42:45 <Tony32> It's supposed to count a string for the occurences of words
14:42:58 <fuzzyhorns> i see someone else posted the same error i see online, but I dont see a solution for it
14:42:59 <fuzzyhorns> http://lpaste.net/103948
14:43:13 <Iceland_jack> Tony32:
14:43:13 <Iceland_jack>     main = do str <- getLine
14:43:13 <Iceland_jack>               print (hist str)
14:43:16 <FUZxxl> rhaps0dy: Hello rhaps0dy !
14:43:33 * FUZxxl gets pinged every time someone writes a message containing fuz
14:43:35 <Tony32> Thanks Jack, whereabouts do I use that?
14:43:45 <Iceland_jack> Tony32: You replace 'main' with it
14:43:46 <fuzzyhorns> lol sorry FUZxxl
14:44:10 <Algebr> I'm finding that its taking me longer to write haskell code intitially but once its written, I don't come back to it as often to tweak or fix it as I do with Python.
14:44:26 <Iceland_jack> if you want to prompt the user with some string you can do
14:44:27 <Iceland_jack>     main = do
14:44:27 <Iceland_jack>         putStrLn "Enter a sentence2
14:44:27 <Iceland_jack>         line <- getLine ...
14:44:29 * Algebr assumes this is somewhat common.
14:44:29 <Iceland_jack>       
14:44:45 <Maior> Algebr: yep; also how many others are you writing code with?
14:44:55 <Algebr> Maior: What do you mean others?
14:44:56 <Iceland_jack> You can also replace the last part with
14:44:56 <Iceland_jack>     print . hist =<< getLine
14:44:56 <Iceland_jack> if you want to be fancy
14:45:07 <Tony32> Iceland_jack: Like this? - http://lpaste.net/2678710251418550272
14:45:16 <Tony32> That gives me an error when compiling
14:45:26 <Iceland_jack> Tony32: don't indent main
14:45:39 <Maior> Algebr: I help clients grow their tech teams and infrastructure; lots find languages with very weak type systems to be incredibly problematic as the team grows in size
14:45:58 <fuzzyhorns> anyone else had trouble upgrading 1.16 to 1.20 for cabal? :c
14:46:17 <Algebr> Maior: Oh, for haskell, I'm on my own, with Python, I'm on a team of about 15.
14:46:26 <Tony32> Iceland_jack: It says Not in scope: str
14:46:42 <Tony32> After removing the ident
14:46:53 <Iceland_jack> Tony32: You must remove the indentation from both lines
14:47:12 <Iceland_jack> It must look as it did before
14:47:26 <Tony32> Now it says Parse error: naked expression at top level
14:47:40 <Iceland_jack> Show me the code
14:47:43 <Tony32> http://lpaste.net/2678710251418550272
14:48:02 <Iceland_jack> Right, the lines must look like it did before
14:48:04 <Iceland_jack> *like they
14:48:20 <Iceland_jack> I'll edit it
14:48:28 <Tony32> Thanks
14:48:32 <Iceland_jack> http://lpaste.net/2678710251418550272
14:48:33 <Iceland_jack> there you go
14:49:04 <Iceland_jack> I also added an annotation for prompting a user for input
14:49:10 <Tony32> Okay that compiles fine thanks :) but it doesn't prompt the user for a string?
14:49:16 <spott> fuzzyhorns: I didn't
14:49:25 <spott> how did you install haskell-platform?
14:49:31 <Iceland_jack> Tony32: Try the annotation
14:49:45 <fuzzyhorns> https://www.haskell.org/platform/mac.html
14:50:08 <rhaps0dy> FUZxxl: lol really?
14:50:22 <Tony32> Which annotation?
14:50:44 <Iceland_jack> Tony32: I added an annotation to the paste
14:50:44 <Tony32> When I run it now it comes up with cmd but after entering anything it closes straight away
14:50:50 <Tony32> Ok 1 sec :)
14:50:53 <spott> hrm.  I installed haskell-platform from brew, and didn't run into that problem
14:50:57 <spott> do you have GCC installed?
14:51:17 <fuzzyhorns> spott: gcc-4.8
14:51:28 <spott> ok
14:51:37 <fuzzyhorns> i have regular gcc installed too
14:51:52 <Tony32> It shows the annotation but it doesn't do anything after you type something and hit enter
14:51:53 <fuzzyhorns> right now i have haskell configured to use gcc-4.8 as i thought that might resolve my issue
14:52:11 <Tony32> before that you had to type hist "words words words" and then it would tell you how many times each word occured
14:52:12 <spott> yea, I don't know
14:52:22 <Iceland_jack> Tony32: Are you sure you're using the same code I pasted?
14:52:22 <spott> sorry... I'm still learning
14:52:28 <fuzzyhorns> np
14:52:32 <fuzzyhorns> maybe i need to do the clang wrapper
14:52:36 <fuzzyhorns> since im on mavericks
14:52:38 <fuzzyhorns> i will try that :x
14:52:49 <geekosaur> fuzzyhorns, this is not the clang issue
14:52:58 <Tony32> Iceland_jack: yes, cmd comes up and says Enter a sentence:    Then after I enter a sentence and hit enter it closes
14:53:01 <fuzzyhorns> geekosaur: no? what is it, do you think?
14:53:08 <geekosaur> I am under the impression it's a botched dependency somewhere but I'm not sure of the fix
14:53:12 <fuzzyhorns> this was my error in case you didnt see before http://lpaste.net/103948
14:53:16 <Iceland_jack> Tony32: How are you running it?
14:53:18 <geekosaur> I did see it, yes
14:53:34 <fuzzyhorns> i wouldnt be surprised if that were the ish
14:53:48 <Tony32> I compiled it in GHCi
14:53:56 <Tony32> Then opened the .exe
14:53:59 <geekosaur> <command line>: cannot satisfy -package-id HTTP-4000.2.8-cdf033f9d7051824f52cd5101df67509
14:54:09 <geekosaur> is not a clang issue, it is a package versioning issue
14:54:09 <Iceland_jack> okay so you're using Windows
14:54:17 <Tony32> Yes
14:54:21 <FUZxxl> rhaps0dy: no big deal
14:54:27 <Iceland_jack> you can add
14:54:27 <Iceland_jack>     getChar
14:54:27 <Iceland_jack> after the print statement
14:54:28 <fuzzyhorns> geekosaur: hm what does that mean
14:54:33 <FUZxxl> I get triggered about 5 times a day from "warm and fuzzy"
14:54:49 <Iceland_jack> Tony32: Did it work before, when you didn't prompt the user?
14:54:50 <FUZxxl> It always makes me all warm and fuzzy seeiing yet another soul learning the magics of Monads.
14:55:11 <geekosaur> fuzzyhorns, specifically in this case cabal thinks a package is installed but ghc does not
14:55:12 <Algebr> So apparently it is bad style to use: head, tail, last, init, and !!?
14:55:14 <Tony32> The .exe didn't work before, but the .hs did
14:55:20 <fuzzyhorns> geekosaur: ah
14:55:23 <fuzzyhorns> geekosaur: shoot
14:55:24 <Iceland_jack> Algebr: Generally yes
14:55:48 <solidus-river> i'm having problems with types and read again
14:55:50 <solidus-river> http://lpaste.net/103995
14:55:54 <Algebr> Iceland_jack: So why can't next haskell report remove them from Prelude?
14:56:00 <Iceland_jack> Algebr: Why should it?
14:56:12 <Algebr> Because these are crappy partial functions
14:56:17 <Tony32> It's working! Thanks so much Iceland_jack
14:56:27 <Iceland_jack> Good!
14:56:36 <Algebr> And if its bad style, then all the more reason to jettison them.
14:56:54 <geekosaur> sadly the keepers of the Prelude do not think that way
14:57:02 <Iceland_jack> It is sometimes bad style, here it's not bad style
14:57:02 <Iceland_jack>     map head . group
14:57:46 <geekosaur> people have been trying to fix Functor->Applicative->Monad for years and it's only finally happening in ghc in the next major release, and *then* we get to fight with the language committee about making it part of a standard...
14:57:51 <solidus-river> how do i tell read that it should be reading a Version Float in that function
14:57:57 <Tony32> Iceland_jack: s it difficult to make it ignore punctuation? At the moment "test" and "test." are counted as different. Here's the latest version if it helps - import Data.CaseInsensitive import qualified Data.Map as M import Data.List import System.Environment  hist :: String -> M.Map (CI String) Int hist = foldl' (\m word -> M.insertWith (+) (mk word) 1 m) M.empty . words  main = do    putStrLn "Enter a sentence:"   str <- getLine   p
14:58:02 <Tony32> Woops
14:58:07 <Tony32> *http://lpaste.net/2379304155614281728
14:58:35 <Maior> solidus-river: what is the type of extractVersion?
14:58:41 <Maior> oops
14:58:56 <Maior> (sorry, missed it)
14:59:11 <Tony32> Iceland_jack: Accidentally pasted the source instead of the lpaste link! I'm basically wondering how to make the program ignore punctuation
14:59:23 <solidus-river> aye, I'm open to switch that to something else though
14:59:32 <solidus-river> i used to have read in the extractVersion
14:59:36 <solidus-river> but that complained as well
14:59:43 <solidus-river> actually, read makes more sense to be in the extract version
14:59:52 <solidus-river> otherwise the types of extractVersion are inconsistent
14:59:55 <solidus-river> er the type
14:59:56 <Iceland_jack> Tony32: One way is to define a newtype for strings without punctuation and things like that, but it's probably not what you want
15:00:09 <Iceland_jack> You should either preprocess the input
15:00:31 <Tony32> Iceland_jack: Whatever the simplest solution is, the solution you gave me to my last problem was simple enough for me to understand (I'm a haskell noob)
15:00:31 <Maior> solidus-river: I don't think that code will do what you want it to, and it's not just because of "read and types"
15:00:38 <Algebr> geekosaur: I don't understand, if ghc will get Functor => blah.. fixed, then doesn't that de facto mean that it ought to go into the language standard as well? I mean, didn't the competitors to ghc basically all die?
15:00:51 <solidus-river> Maior: well i have a problem then, i'm allowing them to pass a float as an optional 3rd argument
15:00:52 <Iceland_jack> Tony32: It depends on whether you want to store the unpreprocessed values
15:00:57 <solidus-river> Maior: how would you recommend handling that?
15:01:13 <solidus-river> getArgs returns [String] so i have to read it but it could not be there so Maybe seemed appropriate
15:01:23 <Iceland_jack> so if you have “test” and “TeSt.”, are you only interested that “test” appears twice?
15:01:25 <Tony32> No don't worry about storing them, unless that's simpler than storing
15:01:37 <Tony32> Yes
15:01:37 <geekosaur> Algebr, some are still alive, jhc just got a new release a couple hours ago
15:01:43 <Iceland_jack> okay, then the easy way is to filter punctuation
15:01:49 <Tony32> At the moment case isn't an issue, but punctuation is
15:01:49 <geekosaur> but no, ghc does not define the language standard, and shouldn't
15:01:58 <Tony32> okay :)
15:02:08 <Algebr> geekosaur: Why shouldn't it?
15:02:08 <Iceland_jack> > filter (not . isPunctuation) "!!this@ is: a test."
15:02:09 <lambdabot>  "this is a test"
15:02:15 <geekosaur> however having a change in a working Haskell implementation is a prerequisite to getting it into the standard
15:02:24 <Maior> solidus-river: can you document parseVersion for me please?
15:02:28 <Tony32> oh cool bot!
15:02:32 <geekosaur> Algebr, should jhc just pack up and die because ghc defines the only acceptable standard?
15:02:33 <lispy> carter: So if you're using clang's cpp in -traditional mode, how do you accomplish string concatenation in a macro?
15:02:47 <Iceland_jack> Ideally you'd do this after applying ‘words’ but it's not very important
15:02:50 <Algebr> geekosaur: It would remove a redundancy of effort.
15:02:58 <geekosaur> should the fact that there aren't many Haskell implekentations be enshrined in the standard as there must only ever be one Haskell implementation?
15:03:04 <Maior> solidus-river: oh, right, I see what you're trying to do
15:03:14 <Iceland_jack> Tony32: Instead of 'CaseInsensitive' you can just do 'map toLower'
15:03:20 <Iceland_jack> where 'toLower' is from Data.Char
15:03:27 <geekosaur> so your argument is that GHC should be the standard, period.
15:03:28 <solidus-river> Maior: oh, d'oh my problem is in my data declaration, i didn't know you had to derive Read and Show
15:03:36 <solidus-river> Maior: i thought deriving Show gave you Read
15:03:39 <Tony32> Okay I'll try that after I get the punctuation working
15:03:42 <Maior> solidus-river: right, no
15:03:42 <Tony32> Where do I add filter (not . isPunctuation) ?
15:03:46 <Iceland_jack> > map toLower (filter (not . isPunctuation) "THiS.. Is A TeST!!")
15:03:47 <lambdabot>  "this is a test"
15:04:00 <Algebr> geekosaur: I'm not making an argument, I'm just thinking since the community is relatively small, why spread talent around instead of focusing on one compiler.
15:04:01 <Iceland_jack> Tony32: To begin with you can compose it after ‘words’
15:04:10 <Iceland_jack> > (words . filter (not . isPunctuation) "THiS.. Is A TeST!!"
15:04:11 <lambdabot>  <hint>:1:59:
15:04:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:04:14 <Iceland_jack> oops
15:04:16 <Iceland_jack> > (words . filter (not . isPunctuation)) "THiS.. Is A TeST!!"
15:04:17 <lambdabot>  ["THiS","Is","A","TeST"]
15:04:38 <geekosaur> because ghc has its own issues, and is not ever going to sensibly support (for example) the embedded platforms that jhc targets
15:04:45 <Tony32> Here's the current source if it helps - http://lpaste.net/2379304155614281728
15:04:52 <geekosaur> which has been a hole in the haskell ecosystem since nhc98 died
15:05:25 <Iceland_jack> Tony32: (note that you have to add 'import Data.Char' to the top)
15:06:10 <Iceland_jack> Tony32: After adding it you should have
15:06:10 <Iceland_jack>     hist = foldr' (…) M.empty . words . filter (not . isPunctuation)
15:06:22 <Algebr> geekosaur: I see, okay, then I concede whatever point I might have had.
15:06:40 <Iceland_jack> and running main should give you something like
15:06:40 <Iceland_jack>     ghci> main
15:06:40 <Iceland_jack>     Enter a sentence:
15:06:40 <Iceland_jack>     hello. hello! hello
15:06:43 <Iceland_jack>     fromList [("hello", 3)]
15:06:59 <Tony32> Like this- http://lpaste.net/2379304155614281728  ?
15:07:19 <DEA7TH> how do I import something I added from hackage? https://hackage.haskell.org/package/primes / "import Primes" didn't work
15:07:33 <DEA7TH> I installed it with cabal install primes
15:07:55 <vanila> import Data.Numbers.Primes
15:08:14 <DEA7TH> ah, that was under Modules. silly me
15:08:41 <Iceland_jack> Tony32: No
15:09:03 <Iceland_jack> The part that I elided was supposed to be just like the previous version
15:09:42 <Iceland_jack> and it should replace the previous version as well: you still have the old definition for 'hist'
15:10:31 <Tony32> Can you edit the lpaste so I know what you mean please?
15:10:57 <Iceland_jack> done
15:11:15 <hpc> feature request: real-time paste editing
15:11:21 <Iceland_jack> heh
15:11:26 <Iceland_jack> Tony32: something like (…) was just a shorthand because I didn't want to repeat what the code already said
15:11:37 <Tony32> Oh I see
15:11:48 <Iceland_jack> It can be valid Haskell but not in that case
15:11:51 <Tony32> Still doesn't seem to work
15:12:10 <Iceland_jack> What is the error?
15:12:11 <Tony32> using - http://lpaste.net/2379304155614281728
15:12:28 <Tony32> Not in scope: foldr
15:12:58 <Iceland_jack> change it to foldl'
15:13:22 <Iceland_jack> > let n … m = [n..m] in 5 … 10
15:13:24 <lambdabot>  [5,6,7,8,9,10]
15:13:41 <Tony32> Iceland_jack: Thanks so much :)
15:13:46 <Iceland_jack> You're welcome Tony32
15:13:57 <Iceland_jack> You can also do away with the CaseInsensitive thing
15:13:59 <hpc> much nicer than enumFromTo
15:14:06 <Tony32> Yeah I'll look into that now
15:14:18 <Iceland_jack> hpc: It's what Feldspar (and my own EDSL) uses
15:14:18 <solidus-river> interesting
15:14:40 <solidus-river> haskell jus tlet me mix an IO monad and a Maybe monad in a do block, how does it know how to combine those?
15:14:46 <Iceland_jack> Tony32: You can use 'map toLower' in a similar way as 'filter (not . isPunctuation)'
15:14:48 <solidus-river> *Just
15:15:28 <Iceland_jack> solidus-river: That's a type error
15:15:43 <solidus-river> Iceland_jack: why did it let me write it?
15:15:46 <Iceland_jack> It is possible to combine them using transformers
15:15:46 <monochrom> is that true? show unabridged working code
15:16:27 <Iceland_jack> :t do (undefined :: IO a); (undefined :: Maybe a) -- solidus-river: like this?
15:16:28 <lambdabot>     Couldn't match type ‘Maybe’ with ‘IO’
15:16:28 <lambdabot>     Expected type: IO b
15:16:28 <lambdabot>       Actual type: Maybe b
15:16:54 <solidus-river> hmm, no i did it in main, here let me make a la
15:16:58 <Tony32> Iceland_jack: For my homework I'm supposed to "Identify any features of the languages which might have an adverse effect on the quality of the program" but I'm stumped. Any ideas?
15:17:01 <solidus-river> OH, i'm loading the sub module not the program
15:17:13 <solidus-river> I'm sure it will complain at me if i main
15:17:14 <rhaps0dy> Tony32: repeating yourself
15:17:36 <rhaps0dy> useless / boilerplate code
15:17:45 <Iceland_jack> Tony32: Are you supposed to answer the same question for other languages?
15:17:53 <rhaps0dy> need complicated constructs for solving problems
15:17:57 <rhaps0dy> too many features
15:18:04 <Tony32> yes I wrote a program to do the same purpose in java
15:18:25 <Tony32> rhaps0dy: Thanks, going to take note of your suggestions
15:18:52 <rhaps0dy> http://harmful.cat-v.org has some interesting rants on languages
15:19:07 <Iceland_jack> So depending on what you call features and what is actually a result of them, some things like graphs are annoying to model without side-effects
15:19:13 <Iceland_jack> *without using mutable references
15:19:13 <rhaps0dy> not terribly informative but a good place to start
15:19:27 <Tony32> rhaps0dy: Thanks I'll check that out
15:19:28 <Iceland_jack> Of course it is possible to use mutable references in Haskell
15:19:34 <rhaps0dy> Iceland_jack: enlighten me?
15:19:48 <EvanR> Tony32: otherwise strongly typed variables which can nontheless be NULL for some reason ;)
15:19:54 <Tony32> Iceland_jack: I'm not sure if discussing graphs matters because the program doesn't need to produce any graps. It only needs to count occurrences of words in a string
15:20:11 <Iceland_jack> Tony32: So only in the context of this problem?
15:20:18 <Tony32> Yes
15:20:23 <rhaps0dy> Tony32: java and c# and similar forced oop languages force boilerplate on this exact problem
15:20:27 <rhaps0dy> Iceland_jack: please enlighten me
15:20:32 <rhaps0dy> well I'll google D:
15:20:34 <Tony32> "Identify any features of the languages which might have an adverse effect on the quality of the programs"
15:20:57 <Tony32> So, I think only pertaining to the program's purposes (specifically to java and haskell)
15:21:19 <Iceland_jack> rhaps0dy: Well you can naively define graphs by using variables in languages like C
15:21:19 <Tony32> rhaps0dy: Thanks again :)
15:21:27 * hackagebot eager-sockets 0.1 - Socket operations with timeouts  http://hackage.haskell.org/package/eager-sockets-0.1 (ToralfWittner)
15:21:39 <Iceland_jack> but in Haskell one node is the same as another node so you need to tag it with some identifier
15:21:59 <Iceland_jack> You can use PHOAS to deal with that, but it's more involved
15:22:31 <Gurkenglas> quchen, what do I have to prepend to my code to be able to use M.fromListWith?
15:22:34 <Tony32> Thanks all
15:22:36 <Iceland_jack> Tony32: For such a simple program there are few features of a language that have advers effects
15:22:38 <vanila> I think you mean HOAS not PHOAS?
15:22:48 <Iceland_jack> No parametric HOAS
15:22:52 <Tony32> Iceland_jack: That's what I thought, it's a tough question
15:23:18 <Iceland_jack> Tony32: One problem might be that Map is not mutated in place
15:24:05 <Tony32> What does that mean in simpler terms? lol
15:24:18 <Tony32> I don't understand what a Map not mutated in place means
15:24:35 <Iceland_jack> Well in Java you have some map object and when you add a new member to the map, you change it
15:24:41 <Iceland_jack> in Haskell you create a new map
15:25:05 <Tony32> Oh ok
15:25:07 <Tony32> Thanks
15:25:42 <EvanR> usually thought of as a good thing, not adverse
15:25:56 <Iceland_jack> EvanR: For that example you get none of the benefits
15:25:58 <EvanR> i struggle to avoid the default behavior in ruby
15:26:17 <EvanR> since every time i have tried to be clever and modify a structure i get ridiculous hard to understand bugs
15:26:45 <Gurkenglas> How do I paste something into the GHCi window? Ctrl-V doesn't work, Rightclick doesn't work. Windows here.
15:27:06 <EvanR> in cmd.exe, try the edit menu
15:27:09 <Iceland_jack> Tony32: Since data structures like Map are purely functional in Haskell some of their complexities are worse than they could have
15:27:16 <Iceland_jack> ah, gone
15:27:30 <Gurkenglas> EvanR, it's ghci.exe
15:27:34 <quchen> Gurkenglas: import qualified Data.Map as M
15:27:51 <monochrom> ghci.exe is still implicitly run inside a cmd.exe
15:28:08 <Gurkenglas> Oh wait Im stupid I put a :: there instead of a =
15:28:22 <Gurkenglas> That's why all the import lines I found on the internet didnt make it compile
15:28:32 <Philonous> Gurkenglas, Maybe shift+insert ?
15:28:45 <Gurkenglas> Philonous, nope
15:29:00 <Gurkenglas> (There's 3 Phils in the room o.o)
15:32:38 <timthelion> Hm, forkIO does not work on armhf in Hugs
15:32:50 <spott_> in ghci, how do I declare the type of a function?
15:32:59 <timthelion> The new thread never starts...
15:33:11 <_Vi> Is there some Debian repository which serves everything from Hackage as deb packages? Like "cabal-install", but integrated with dpkg?
15:33:21 <Iceland_jack> spott_: you can do
15:33:21 <Iceland_jack>     ghci> let { plusOne :: Int -> Int; plusOne x = x + 1 }
15:33:34 <spott_> Iceland_jack: thanks!
15:33:51 <EvanR> im about to use non ascii letters in a constructor name
15:33:58 <EvanR> and see what happens
15:34:01 <timthelion> _Vi: not really, Joey Hess just packages random things he needs for building git annex, but those are in the main repos
15:34:06 <_Vi> In general, is "cabal-install --global" the only way to auto-retrieve-and-install deps from Hackage?
15:34:26 <Iceland_jack> EvanR: (⊂) = Data.Set.isSubsetOf -- :)
15:34:29 <timthelion> _Vi: what do you mean?
15:34:45 <merijn> EvanR: Should just work, GHC accepts any unicode input
15:35:35 <EvanR> merijn: right.. so the first letter needs to be capital, im guessing that is well defined in unicode ;)
15:35:41 <merijn> EvanR: Yes
15:35:43 <Iceland_jack> EvanR: or :
15:35:44 <merijn> See isUpper
15:35:56 <Iceland_jack>     data Expr = Expr :+ Expr | Expr :* Expr | …
15:35:59 <_Vi> timthelion, To resolve missing dependencies, one typically issues "cabal install whatever", which automatically downloads&installs deps. Is it the only way? Are there other automatic alternatives? For example, that creates a deb for each package and install it instead of directly copying files to /usr/local?
15:36:19 <merijn> > isUpper 'Λ'
15:36:21 <lambdabot>  True
15:36:30 <merijn> > isUpper 'λ'
15:36:32 <lambdabot>  False
15:36:35 <Iceland_jack> merijn: Ah, the famous steeple character :)
15:37:27 <Tony32> Can anyone help me with pseudo code for this? - http://lpaste.net/7598873010161844224
15:37:45 <timthelion>  _Vi: missing dependencies for a program you are writting or missing dependencies for a program you found on the internet?
15:38:19 <EvanR> merijn: right
15:38:22 <Iceland_jack> Tony32: I assume you want imperative pseudo code?
15:38:33 <Tony32> Iceland_jack: Ideally, yes
15:38:45 <_Vi> timthelion, Mostly the second, but the first can be too (like in "found cool new simpler thing... Oops, it says no such package... 'cabal install --global' -> many deps get downloaded and installed -> works")
15:39:07 <Gurkenglas> @unpl hist = foldl' (\m word -> M.insertWith (+) (mk word) 1 m) M.empty . words . filter (not . isPunctuation)
15:39:07 <lambdabot> hist c = foldl' (\ m word -> M.insertWith (+) (mk word) 1 m) M.empty (words (filter (\ i -> not (isPunctuation i)) c));
15:39:35 <Iceland_jack> Tony32: You need some code for initializing the map (that's what M.empty does)
15:40:00 <Tony32> Okay
15:40:13 <Iceland_jack> you read input, use a for statement to iterate through all the words in the input
15:40:50 <Iceland_jack> check for each word in the dictionary, if it exists then you add one to it and write that back
15:41:27 <Tony32> Okay
15:41:35 <Gurkenglas> What do you recommend I use to convert Data.Map maps into a histogram/function-graph graphical image?
15:41:38 <Iceland_jack> otherwise you write 1 back to the dictionary (with the word being the key in both cases): in all these cases you should have modified your word to remove punctuation and making it lower-case
15:41:38 <timthelion> _Vi: um, you should be writting cabal files for the programs you are writting and then passing cabal install --only-dependencies is what you want: http://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
15:42:44 <identity> after the introduction of sandboxes, I kind of wonder why cabal ever worked by installing into a global 'repository' to begin with
15:42:49 <identity> for application development it just makes no sense
15:42:50 <Iceland_jack> I.e. basically write Python :)
15:42:50 <Iceland_jack>         
15:43:15 <Maior> identity: have you ever used Maven?
15:43:21 <_Vi> Where do most Haskell users install their development dependencies? Into the system or into user account?
15:43:40 <Iceland_jack>     for word in words input:
15:43:41 <Iceland_jack>         processedWord = removePunctuation(toLower(word))
15:43:41 <Iceland_jack>         if processedWord in dict:
15:43:41 <Iceland_jack>             ...
15:43:43 <identity> Maior: nope. I do some java(for school) but maven looked so complex(for my rather small projects) that I never felt like getting into it.
15:43:52 <Tony32> Iceland_jack: How's this? -	Read input -	Use a for statement to iterate through all the words in the input -	Check for each word in the dictionary -	If it exists then add one to it and write that back, otherwise write 1 back to the dictionary  -	Remove case and punctuation  -	Return words with occurences
15:43:54 <identity> _Vi: Ideally, you should be installing package on an application-basis
15:44:01 <identity> that is, in a sandbox
15:44:16 <identity> packages*
15:44:19 <_Vi> identity, And de-duplication should be handled by filesystem?
15:44:22 <Iceland_jack> Tony32: You should process the word (remove punctuation and such) first
15:44:33 <Iceland_jack> In the Haskell code you had before, you did that to the original string
15:44:39 <identity> _Vi: Hmm? I'm not sure what you mean
15:44:41 <_Vi> identity, How to avoid re-compiling everything in this case?
15:44:47 <Maior> identity: one of my favourite things about maven is that it installs _everything_ to a "user global" repository (~/.m2/repository) but constructs a classpath at "runtime" including only the right bits
15:44:57 <Iceland_jack> It depends on whether you want
15:44:58 <Iceland_jack>     "hi.hi"
15:44:58 <Iceland_jack> to be [("hi", 2)] or [("hihi", 1)]
15:45:05 <identity> Maior: That works as well, I guess. and is a bit smarter, too
15:45:16 <Maior> identity: i.e. rather than the common Python approach (which aiui is a bit like cabal sandboxes) where you end up installing things again and again and again for every project you work on
15:45:27 <Tony32> Oh I didn't think about that. I guess hi.hi would be hihi
15:45:30 <Iceland_jack> sorry, "hi. hi"
15:45:45 <_Vi> identity, With per-app sandboxes you may end up downloading (network resources), compiling (CPU resources) and storing (disk resources) heavy dependency more than once, even if they are shared between projects.
15:45:46 <identity> Well, at any rate, having a global repo for packages for application development makes no sense
15:45:55 <Tony32> "hi. hi" would be [("hi", 2)]
15:46:05 <identity> _Vi: Yes. Currently, as far as I know, there's no way of avoiding that.
15:46:09 <_Vi> Also I often just run "ghci" outside any project and expect it to be "rich" and ready to experiment on various things...
15:46:19 <Maior> _Vi: I know the feeling
15:46:21 <identity> though I feel like cabal should be caching built packages and copying if they're already built, etc
15:46:25 <timthelion> _Vi: into a sandbox in the directory where they are developing their program
15:46:29 <identity> (though you'd have to take profiling and such into account)
15:46:35 <Iceland_jack> Tony32: What about "hi.hi"?
15:46:49 <identity> _Vi: Yes, I do the same thing. For quick and dirty stuff.
15:46:50 <_Vi> Also in some article it is said "cabal is not a [proper] package manager"... But where is proper Hackage-savvy package manager?
15:46:51 <Tony32> That would have to be hihi
15:46:55 <Iceland_jack> okay
15:47:00 <Iceland_jack> then it doesn't matter much
15:47:03 <Tony32> :)
15:47:19 <identity> _Vi: That's the thing -- it isn't a package manager, but it kind of tried(/tries) to be when it's installing into the global repo
15:47:26 <Iceland_jack> Yes, iterate through the list of words: create a new word that is lower-case and has no punctuation
15:47:40 <_Vi> (Currently I consider creating *.cabal files as "heavyweight" and only do it if the project grows to something more complex)
15:47:49 <timthelion> _Vi: cabal is the weakest point in the haskell ecosystem.  So if you get non-ideal solutions, don't waste too much of your time trying to find better ones.
15:47:51 <Iceland_jack> otherwise what you already had Tony32
15:48:11 <Lethalman> _Vi, nix maybe
15:48:13 <timthelion> _Vi: really, if it seems like utter crap, then it is...
15:48:13 <identity> I do precisely the same thing. The only reason I can do it simply because I had already installed a good deal of packages before sandboxes / before i started using them.
15:48:29 <Lethalman> some people use it for programming in haskell, and sandboxing hackages and ghc itself
15:48:30 <_Vi> timthelion, "cabal is the weakest point in the haskell ecosystem" -> Are there alts that also can fetch from Hackage?
15:48:46 <timthelion> _Vi: No, unfortunately
15:48:51 <Lethalman> though it has a steep learning curve
15:48:54 <_Vi> Lethalman, "nix maybe" -> Nix is on my "to be played with" list already...
15:49:10 <_Vi> Lethalman, Can Nix recursively fetch deps and install from Hackage?
15:49:18 <timthelion> _Vi: just don't try it as your main OS if you like things like fonts and icons.
15:49:55 <Lethalman> _Vi, well that's something cabal does too no?
15:51:12 <_Vi> I try to think about this assertions: 1. To fetch deps and install then is a package manager's work; 2. cabal[-install] fetchs and installs deps; 3. "Cabal is not a package manager"...
15:51:22 <_Vi> s/then/them/
15:52:07 <_Vi> Lethalman, Cabal installs them _directly_, without intermediate *.deb or whatever package-manager things.
15:52:30 <Lethalman> right
15:52:40 <_Vi> Can cabal-install create *.deb for each package it downloads and builds and install it (instead of copying files somewhere directly)?
15:52:50 <identity> no.
15:53:06 <Maior> _Vi: I've been meaning to add cabal support to fpm for some time, fwiw
15:53:11 <_Vi> This way it will delegate at least uninstallation thing to proper package manager...
15:53:43 <Lethalman> _Vi, I suggest you to take a look at nix, it's installable on your os without installing nixos... I believe it will do most of things you expect
15:54:07 <_Vi> Lethalman, Are there any special integration between cabal (or Hackage) and Nix?
15:54:25 <_Vi> Lethalman, Is Nix haskell-savvy or just written in Haskell?
15:54:26 <Lethalman> _Vi, yes, in the sense that nix uses cabal files to create packages
15:54:36 <timthelion> Lethalman: do you use nix?
15:54:38 <Lethalman> _Vi, nix has nothing to do with haskell, except it's pure and lazy
15:54:44 <Lethalman> timemage, I use nixos, yes
15:55:12 <identity> Lethalman: So you'd have to create a package manually for every package from hackage(and possibly different versions) you'd like to manage sanely?
15:55:19 <Lethalman> I don't do heavy haskell things though, here for listening :)
15:55:36 <Lethalman> identity, yes, but there's a bunch of haskell packages already
15:55:39 <timthelion> Lethalman: could you stop with the "it's pure and lazy stuff?"  it's totally meaningless BS.
15:55:40 <_Vi> Lethalman, Can Nix add "easy uninstalling" to what cabal-install does? (I don't understand how Nix and Cabal interact)
15:55:41 <identity> I see.
15:55:52 <solidus-river> is `data Version = Latest | Float deriving (Read)` not a valid data type? I cant `read "1.0" :: Version`
15:56:13 <Lethalman> timemage, calm down, I only stated things common with haskell, since he asked if nix had something to do with haskell
15:57:23 <Lethalman> _Vi, nix installs packages in well known directories separated each other
15:57:29 <Maior> solidus-river: it's a valid data type, but it doesn't do what you think it does
15:57:51 <timthelion> Lethalman: well, I dislike these claims.  Even if the directories are separate, the separation is in no way enforced.
15:57:54 <Maior> solidus-river: you probably mean "data Version = Latest | NotLatest Float"
15:58:06 * timthelion wonders what ever happened to https://github.com/db81/hellno
15:58:07 <_Vi> Lethalman, And does it mix well with "cabal install --global"?
15:58:11 <Lethalman> timthelion, I dislike your tone
15:58:16 <Maior> solidus-river: because otherwise that Float becomes a data constructor shadowing the type
15:58:26 <Lethalman> _Vi, no, once you use nix, you better keep using only nix
15:58:39 <Maior> solidus-river: and that is nasty
15:58:39 <solidus-river> Maior: ah
15:58:48 <identity> timthelion: That is exactly the kind of solution I was talking about, basically
15:58:52 <_Vi> Lethalman, So how to fetch a package + deps from Hackage and install it into Nix?
15:58:55 <timthelion> Lethalman: I tried installing nixos, and I frankly felt my time was wasted by over the top claims that turned out to not hold water.
15:59:04 <identity> why didn't this catch on?
15:59:21 <solidus-river> Maior: could i make it a custom instance of Read and solve things that way?
15:59:26 <Lethalman> timemage, sorry for that, but you can leave the discussion and let other people try and see
15:59:27 <timthelion> identity: I don't know.  I just remember, that I didn't have time to play with it when it came out.
15:59:28 <EvanR> solidus-river: data Version = Latest | Old Float could work, though a Float is usually not a good use for a version number
15:59:33 <Lethalman> timthelion, ^^
15:59:50 <Maior> solidus-river: oh yeah and what EvanR said
15:59:56 <timthelion> Lethalman: No, I don't want to leave the discussion and let other people waste their time with something that I believe is poorly described and overhyped.
16:00:03 <Maior> solidus-river: I think you might want to think about your types more
16:00:41 <solidus-river> Maior: why is Float a bad type for a version number, i need to have an idea of Ord so i can migrate up and down
16:00:47 <Lethalman> timthelion, then you better start explaining why it's not good, instead of saying you just felt losing time
16:00:54 <EvanR> solidus-river: well, how about Integer then
16:01:10 <Maior> solidus-river: because conventionally "1.3.0" is a version number, and "1.13" > "1.2"
16:01:24 <identity> solidus-river: Floats .. well, unpredictable, so to speak. And they don't fit version numbers very well
16:01:49 <Lethalman> _Vi, this is an example package: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/libraries/haskell/arrows/default.nix
16:01:50 <Maior> solidus-river: in fact, from a Pragmatic Software Engineering Perspective, I'd say "if you don't follow something as well thought about as semver / the Python versioning scheme / similar, aaargh"
16:01:59 <arnob> Hi all
16:02:01 <_Vi> Lethalman, As far as I remember, Nix can have multiple version of the same package (i.e. library) installed and available. It is a good thing for Haskell, as version ceilings are common... But is there a way to make Nix calculate_deps->download->build->install from Hackage (with or without Cabal)?
16:02:02 <Maior> (or more realistically "argh please semver")
16:02:39 <solidus-river> Maior: well, i'm just doing this for versioning Migrations of a database so i'm not likely to have to deal with revisions and stability etc
16:02:47 <arnob> I am trying to get MongoDB persistent working... I can't seem to find a simple tutorial like for Sql connections
16:02:49 <Maior> solidus-river: then why not integers?
16:02:50 <arnob> any pointers?
16:02:59 <Lethalman> _Vi, I'm not really sure how cabal fits in nix, but I guess it's used to install an hackage, and then the builder moves stuff into its own directory
16:03:09 <Lethalman> _Vi, and yes I believe it downloads stuff from hackage, let me see
16:03:27 <Lethalman> _Vi, indeed it does
16:03:33 <solidus-river> Maior: because i want the developers to be able to "restart" their Migration history logically at major revisions of the software
16:03:34 <identity> timthelion: I really can't get why something like that hellno scheme didn't catch on <.<
16:03:52 <Maior> solidus-river: then why not (integer, integer)s
16:03:53 <Maior> ?
16:03:53 <timthelion> Lethalman: I dislike nix, because it uses symlinks to try to create a fake environement, when it should use a chroot.  This poor design leads to breakage, and it also shows how amature the design is.  There is a claim in the manual, that patching elfs to make the symlink hack work works great, but then again, none of gnome works because patching elfs doesn't work great.
16:03:59 <EvanR> Maior: the degree to which X.Y.Z numbers never reflect something significant besides time ordering in projects... is why i cant tell why people dont just use integers ;)
16:04:08 <Maior> EvanR: haha
16:04:16 <timthelion> identity: it's because marketing is everything
16:04:19 <timthelion> identity: does it still build?
16:04:22 <Lethalman> timthelion, I just have a screenshot of gnome3 if you want
16:04:32 <identity> timthelion: didn't fetch it
16:04:32 <solidus-river> Maior: thats pretty solid
16:04:38 <identity> timthelion: let me give it a whirl, sec
16:04:46 <Maior> EvanR: I know the feeling, but I do actually work with plenty of things for which it's useful
16:04:59 <Lethalman> timthelion, I'm not sure you are talking because you have the knowledge, or because you just don't like it and refuse to see anything further
16:05:02 <EvanR> solidus-river: (Integer, Integer) then, and you can define your own Ord for it
16:05:06 <Lethalman> timthelion, also nix uses chroots when building
16:05:22 <Lethalman> timthelion, if you're just a hater, please step aside
16:05:25 <Maior> EvanR: actually I think the derived Ord would work sensibly
16:05:29 <EvanR> oh
16:05:30 <timthelion> Lethalman: When I tried it, none of the icons showed up in any gtk application.  But that is besides the point.  The point I'm trying to make, is that the developers, make significant claims that are not backed by their actual product
16:05:39 <Lethalman> timthelion, simply because it wasn't properly packaged
16:05:45 <Maior> > (1, 13) > (2,0)
16:05:47 <lambdabot>  False
16:05:57 <Lethalman> timthelion, http://i.imgur.com/Gufl2HN.png
16:06:05 <EvanR> lexicographic ordering
16:06:06 <Lethalman> timthelion, that's not even the most recent shot
16:06:21 <Maior> EvanR: which is "basically" how primitive version numbering works, right?
16:06:30 <EvanR> yeah, its the version ordering
16:06:39 <timthelion> Lethalman: the problem, is not technical, it's cultural.  You guys repeatedly make claims that are not true, like that "nix is purely functional"
16:06:40 <identity> timthelion: nah, doesn't build. dependencies are off. going to try fixing the cabal file
16:06:43 <EvanR> give that to solidus-river  ;)
16:06:43 <identity> (7.6.3)
16:06:56 <Lethalman> timthelion, you are claiming something that's not true, there is gnome with icons
16:07:11 <timthelion> Lethalman: when I tried it there were not.
16:07:13 <solidus-river> do you have to instance something to Show and Read seperately?
16:07:16 <Lethalman> timthelion, because it wasn't worked on
16:07:22 <Lethalman> timthelion, and you're just hating without good reasons
16:07:24 <timthelion> Lethalman: But it should have just worked.
16:07:34 <EvanR> > show (1, 13)
16:07:36 <lambdabot>  "(1,13)"
16:07:40 <Lethalman> timthelion, and why?
16:07:46 <Maior> solidus-river: yes
16:07:49 <EvanR> > read "(1,13)" :: (Integer, Integer)
16:07:50 <lambdabot>  (1,13)
16:07:58 <solidus-river> and is there a way to get ghci to print out the class definitions?
16:08:10 <Maior> solidus-river: http://pastebin.com/28h4V67Z
16:08:10 <EvanR> solidus-river: try :i Type
16:08:24 <Lethalman> timthelion, also why isn't it pure functional?
16:08:25 <timthelion> Lethalman: because, if it was "purely functional" than the problem with the icon paths not being resolved correctly would not have needed to been solved with special hacks in the build scripts
16:08:38 <Lethalman> timthelion, mh no that's not a good answer sorry
16:08:42 <Maior> granted I didn't show that the other way
16:08:45 <timthelion> Lethalman: it's not purely functional, because there is no actual isolation!
16:08:46 <Lethalman> that's nothing informative
16:09:02 <identity> timthelion: yeah, removing the upper bounds on the packages made it work
16:09:02 <Lethalman> mah, whatever
16:09:09 <fuzzyhorns> still cant break through this problem: http://lpaste.net/103948 :c
16:10:11 <timthelion> identity: perhaps if you get it working you can advertize it a bit :)
16:10:17 <identity> timthelion: seems to work fine.
16:10:20 <solidus-river> wow, it looks not so easy to make something an instance of Read manually
16:10:27 <identity> timthelion: I may try it out, yeah
16:10:37 <EvanR> solidus-river: you should use a real parser anyway
16:10:38 <Maior> solidus-river: I also don't like read being partial, so I DIY it
16:11:00 <timthelion> identity: go on reddit and start ranting about it being purely functional and moimizing, that should get some attention :)
16:11:17 <Maior> timthelion / identity: I don't suppose you'd like to have this fight elsewhere would you please?
16:11:29 <identity> Maior: um, what? What fight?
16:11:39 <fuzzyhorns> i followed this and no dice: http://stackoverflow.com/questions/19579577/installing-building-ghc-with-osx-mavericks-ghc
16:11:41 <timthelion> identity: he was refering to my argument with Lethalman
16:11:46 <identity> I see.
16:11:50 <identity> <- not lethalman
16:11:53 <timthelion> Maior: sorry
16:11:59 <Maior> identity: oops sorry
16:12:07 <timthelion> Maior: think it's over now
16:12:21 <Maior> my bad
16:12:28 <identity> timthelion: I think I shall go on reddit and ask about it
16:12:29 <identity> no worries
16:12:34 <identity> though minus purely functional, etc
16:15:14 <arnob> I am trying to get MongoDB persistent working... I can't seem to find a simple tutorial like for Sql connections
16:16:02 <EvanR> solidus-river: with parsec, the parser for XXX.YYY version number (into (Integer,Integer)) would be something like do{ x <- number; char '.'; y <- number; return (x,y); }
16:16:16 <EvanR> though not exactly i suspect
16:16:23 <EvanR> since i cant find the number parser in the docs
16:17:36 <benzrf> :t scanl
16:17:37 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:17:48 <benzrf> how does scan again
16:17:50 <benzrf> o_o
16:18:03 <Maior> EvanR: one day I'll learn parsec; till then I'll produce abominations like https://github.com/doismellburning/hess/blob/master/src/Hess/Core.hs#L213-L252
16:18:13 <quchen> scan* is fold*, keeping intermediate lists.
16:18:21 <Maior> @src scanl
16:18:21 <lambdabot> scanl f q ls = q : case ls of
16:18:21 <lambdabot>     []   -> []
16:18:21 <lambdabot>     x:xs -> scanl f (f q x) xs
16:18:33 <EvanR> attoparsec... do{ x <- decimal; char '.'; y <- decimal; return (x,y); }
16:18:36 <quchen> Well, intermediate values, not necessarily intermediate lists.
16:18:58 <benzrf> hmmm
16:19:07 <benzrf> > scanl1 (+) [1, 2, 3]
16:19:08 <quchen> (,) <$> decimal <* char '.' <*> decimal -- :-)
16:19:09 <lambdabot>  [1,3,6]
16:19:13 <EvanR> Maior: haha nice
16:19:19 <EvanR> quchen: thx
16:19:24 <EvanR> much clearer
16:19:46 <Maior> EvanR: there's lots of ugliness in that code, it's only really the second Reasonable Chunk Of Haskell I've written
16:19:50 <NemesisD> anyone have any experience with the unix package? i'm curious how i'd change a process's stdout/in/err fds to point elsewhere
16:19:55 <Maior> so don't look too hard, it'll probably hurt ;)
16:19:57 <startling> quchen, "keeping intermediate lists; name only, the list of intermediate values"? :)
16:20:04 <startling> *namely one, heh
16:20:27 <quchen> startling: That's why I corrected myself later to "intermediate values". But yes. :-þ
16:20:36 <EvanR> Maior: yeah ive had success using parsec for programming language source text, and attoparsec for simpler streams of data
16:20:46 <startling> vacuous truths are the best. :)
16:21:03 <quchen> That's because they are the best.
16:21:06 <spopejoy> hi. typeclassopedia q … newb q obv.  implementing functor for ITree … but even dumber q.
16:21:26 <timthelion> NemesisD: doesn't it suffice to simply forkIO a process that reads from the descriptor and then writes to where yo want to write?
16:22:00 <identity> timthelion: it has been put before the council.
16:22:30 <NemesisD> timthelion: i'm not sure. i'm planning on doing a fork/exec. i'm actually spawning a new process, but i need to connect its standard streams to say a logger process, /dev/null, etc
16:22:38 <spopejoy> data ITree a = Leaf (Int -> a) \n | Node [ITree a]. In GHC, i issue let t = Leaf (1+).
16:22:49 <Maior> NemesisD: System.Process lets you do that
16:22:55 <NemesisD> timthelion: i'm assuming the answer is probably pretty close to whatever the answer is in C
16:23:13 <spopejoy> Now for the dumb q: how would I evaluate that (1+) function in t? ’t 1’  blows up.
16:23:17 <Maior> NemesisD: check out http://hackage.haskell.org/package/process-1.0.0.0/docs/System-Process.html
16:23:30 <identity> well, it is way past my bedtime. thank god for coffee. g'night
16:23:33 <NemesisD> Maior: yeah. i actually use that in the current version of what i'm working on. the problem is process abstracts away a lot of the guts in the name of cross platform, which i don't need
16:23:47 <solidus-river> EvanR: Maior: thanks for the help, its cool to know more about instances, your right though i'm switching the internal representation into a tuple
16:23:49 <dwcook> spopejoy: can you post relevant code links?
16:23:55 <spopejoy> k
16:24:08 <NemesisD> Maior: for instance, i'd like in the forked process to potentially run under a different UID/GID. which as far as I know needs to happen in the child proc
16:24:09 <EvanR> doThing file = forkIO (hGetContents >>= destination) ;)
16:24:14 <EvanR> doh
16:24:36 <NemesisD> Maior: but process doesn't let me hook into the child just after fork
16:24:44 <EvanR> solidus-river: Read is just not too solid for real use
16:24:54 <Maior> NemesisD: ah right ok
16:25:02 <Maior> NemesisD: check out the source of System.Process?
16:25:07 <EvanR> > read "foo" :: (Integer, Integer)
16:25:09 <lambdabot>  *Exception: Prelude.read: no parse
16:25:10 <Maior> (this may not be useful, sorry)
16:25:18 <tac`> > map (*2) [1..]
16:25:19 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
16:25:32 <tac`> @type map
16:25:33 <lambdabot> (a -> b) -> [a] -> [b]
16:25:57 <Philonous> NemesisD, (dupTo stdout <target> >> hclose stdout ) IIRC
16:25:58 <NemesisD> man it would be super nice if google actually indexed the most recent versions of packages. always drops me into some ancient version of the haddocks
16:26:08 <Maior> NemesisD: agreed
16:27:17 <Philonous> NemesisD, stdOutput, not stdout, but you get the idea.
16:27:33 <NemesisD> Philonous: ah that may work!
16:27:35 <NemesisD> thanks
16:27:54 <Philonous> Oh, and of course you can't hClose an FD, so you closeFd instead :>
16:28:01 <Philonous> use*
16:28:38 <NemesisD> now to strap all this crap to a free monad so I can actually test it
16:28:55 <NemesisD> evalThroneOfLies
16:29:20 <dwcook> spopejoy: my mistake, I missed your previous line.
16:29:31 <mmmm_> NemesisD: You know about this? https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf?hl=en-US
16:29:46 <dwcook> spopejoy: (although a paste link might still be useful as the channel moves)
16:30:06 <NemesisD> mmmm_: yeah. that's a good one. definitely been a time saver
16:30:33 <mmmm_> but ye it is bad
16:30:40 <spopejoy> http://lpaste.net/103999
16:30:52 <spopejoy> two q’s in there.
16:31:12 <dwcook> spopejoy: so let me get this straight – You want to use the knowledge that you have a Functorial value to turn the Leaf (1+) into a Leaf 2?
16:31:13 <NemesisD> anyone had difficulty with ghc 7.8 installing happy
16:31:52 <spopejoy> Dumber. I just want to evaluate the function in Leaf. Something like (Leaf (1+)) 2 => 3
16:31:54 <dwcook> spopejoy: oh, you have to actually _implement_ the instance. Got it. Well, are you familiar with pattern matching?
16:32:13 <dwcook> Seems like it since you used it for Show.
16:32:26 <spopejoy> It’s more a GHCi q.
16:32:43 <dwcook> Ah, then maybe you want a case expression?
16:32:48 <spopejoy> I wanted to verify my fmap results and realized i coulnd’t even verify my first.
16:33:29 <spopejoy> :) I’m just wondering what one does with Leaf (Int -> a). At some point wouldn’t we want to evaluate (Int -> a)?
16:33:40 <dwcook> Sure. That's what fmap is for.
16:34:19 <dwcook> I'm confused about what you're asking. Are you having trouble implementing fmap?
16:34:44 <spopejoy> well yes but that’s not the question. I successfully implemented the Leaf part of fmap.
16:35:14 <spopejoy> Now I want to try it out in GHCi.
16:35:26 <dwcook> In that case you already know how to grab the value from a Leaf, right?
16:36:05 <spopejoy> No. That’s my dumb q.
16:36:08 <dwcook> You can either use multiple clauses of a function or a case expression.
16:36:31 <spopejoy> For instance: in GHCi, I issue ’t = Leaf (1+)’
16:36:32 <dwcook> A case expression might look like case myTree of Leaf x -> … ; Node xs -> …
16:36:43 <spopejoy> Then i issue: ‘let s = fmap (2+) t'
16:36:58 <spopejoy> How do I check that s evaluates (1+ (2+ foo))?
16:37:29 <dwcook> That doesn't typecheck.
16:38:02 <spopejoy> which, the 2nd ‘let s …’ stmt?
16:38:03 <dwcook> Well, it might. But there's not a sane instance for Num for functions.
16:38:16 <BMeph> spopejoy: Your sentence doesn't .!@#>!@&(%&$!3 any sense.
16:38:22 <spopejoy> :)
16:38:27 <BMeph> ;)
16:38:30 <dwcook> fmap (2+) (Leaf (1+)) would lead you to Leaf ((2+) (1+)).
16:38:42 <dwcook> (For a valid instance of fmap for this type.)
16:38:45 <spopejoy> my fmap:
16:38:48 <dwcook> s/instance/definition/
16:38:56 <spopejoy>     fmap g (Leaf f) = Leaf (g . f)
16:39:10 <dwcook> Oh!
16:39:13 <dwcook> Never mind, I'm confused.
16:39:18 * BMeph nods
16:39:19 <spopejoy> :)
16:39:24 <dwcook> This is a more specialized tree than I realized.
16:39:32 <spopejoy> It’s actually a pretty mind-bending exercise. Typeclassopedia ftw
16:40:14 <BMeph> spopejoy: You need some kind of "iApply (Leaf f) i = f i" function.
16:40:26 <spopejoy> ah.
16:41:17 <spopejoy> sweet. let ia (Leaf f) i = f i
16:41:24 <spopejoy> ia t 2 evaluates to 3.
16:41:33 <BMeph> spopejoy: Actually, I guess you need some kind of "{iApply (Leaf f) i = f i; iApply (Node xs) i = map (`iApply i`) xs}" function.
16:42:08 <BMeph> Er, * iApply (Node xs) i = map (`iApply` i) xs
16:42:44 <spopejoy> Er, still getting to Node :)
16:43:23 * BMeph waves his hand: "There is not examply of using the Node case yet..." ;)
16:43:58 <spopejoy> most importantly able to check my work now: ‘ia (fmap (2+) t) 3’ evals to 6. victory
16:44:37 <EvanR> > [1..4] ::[Double]
16:44:38 <lambdabot>  [1.0,2.0,3.0,4.0]
16:44:43 * BMeph sets (spell-check ((iPhone-mode :OFF))) ;þ
16:45:00 <benzrf> BMeph: is that... lisp???
16:45:04 <benzrf> in MY #haskell???
16:45:07 <spopejoy> anyone for my second q? Why ‘instance Show (ITree a) where’ but ‘instance Functor (ITree) where’? That is, why ITree a, then just ITree?
16:45:27 <benzrf> spopejoy: Show and Functor take different kinds
16:45:31 <benzrf> :k Show
16:45:32 <lambdabot> * -> Constraint
16:45:33 <benzrf> :k Functor
16:45:34 <lambdabot> (* -> *) -> Constraint
16:45:38 <BMeph> benzrf: Hey! You just got Haskell in my ##elisp! ;þ
16:46:12 <benzrf> ewwww, dynamic scoping
16:47:08 <BMeph> spopejoy: because Functor members have kind (* -> *), but Show members are kind *...FSVO 'are', 'have' and 'member'. :)
16:47:24 <spopejoy> oof.
16:48:16 <spopejoy> And yet: instance Functor (Either e) where ...
16:48:51 <dwcook> Either :: * -> * -> *. Either e :: * -> *
16:49:48 <BMeph> spopejoy: Yes, you get it, then! ;þ
16:50:42 <spopejoy> I didn’t … but making some sense. Liking that lambdabot.
16:51:59 <spopejoy> thank you for the help!
16:58:33 <albeit> If I'm using a pair (a,b) as an accumlator for a foldr, is it almost alway necessary to force evaluation (!a, !b) each step?
16:59:53 <saml_> why?
17:00:10 <pyon> albeit: If you want a strict fold, probably you want a Data.List.foldl'.
17:01:31 <albeit> But wouldn't foldl' just evaluate it down the pair, so the inner components would remain unevaluated?
17:01:38 <albeit> *down to the pair
17:02:02 <quchen> Both foldl and bangs are what you probably want.
17:02:35 <quchen> foldr doesn't really have an accumulator, I don't think that picture is very fruitful.
17:02:54 <quchen> The "accumulator" in foldr is really the rest of the fold, i.e. what's still to be done.
17:03:04 * BMeph agrees w/ quchen
17:03:23 <spopejoy> BMeph: couldn’t resist:  (\(Leaf f) i -> f i) (Leaf (1+)) 2
17:04:51 <quchen> Oh, when I said "foldl" above that should've been "foldl'".
17:05:22 <pyon> What purpose does the lazy foldl serve?
17:05:26 <pyon> Completeness?
17:05:41 <quchen> Few people know. I'm not one of them.
17:06:02 <saml_> :t foldr
17:06:02 <quchen> I've heard rumors of places where foldl was strictly better than foldl' or foldr.
17:06:03 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:06:12 <pyon> :-O
17:06:50 <saml_> > foldr (\x (a,b) -> (a+x, b-x)) (0,0) [1..10]
17:06:52 <lambdabot>  (55,-55)
17:07:00 <saml_> hehehehehe what's wrong with that?
17:11:15 <Redz> is there a dummy type? something like undefined, but just as a type.
17:11:21 <benzrf> Redz: a
17:11:37 <EvanR> i wish noticing that a giant monad stack involving IO doesnt actually need any IO, and then removing the IO from the type, simplified the code at all :(
17:13:15 <Redz> benzrf: but that can't be used in a type definition without being a variable.
17:14:11 <dwcook> Redz: (), Void, depending on what you need
17:14:15 <dwcook> Both are trivial in some sense
17:14:43 <Redz> () . thats what i looked for. thanks. ;)
17:14:55 <dwcook> (Either Void a ~ a and ((), a) ~ a, ignoring _|_)
17:15:22 <Redz> () is too obvious. :p
17:15:48 <EvanR> whats wrong with being a variable
17:17:53 <Redz> data MyType = MyType Int a
17:17:54 <Redz> wouldnt work.
17:18:05 <dwcook> data MyType = forall a. MyType Int a
17:18:14 <EvanR> heh
17:18:23 <dwcook> Though I'm not sure why you'd need either one
17:18:25 <EvanR> i was wondering about how to deal with those
17:18:30 <quchen> Redz: For similar reasons as "f = 2 + x" wouldn't work: x isn't in scope.
17:18:33 <djahandarie> pyon, I guess you could say completeness. The one place that foldl is 'useful' is when the first argument of your combining function is lazy, and you are folding over things which have bottoms in them.
17:19:18 <djahandarie> pyon, allowing you to avoid the result being bottom when it needn't be. But I don't think I've ever seen a real-world case where this was required.
17:19:35 <pyon> Heh.
17:19:47 <Redz> at the end, a will be implemented as a specific type. it should be nothing more than a placeholder and not a polymorph type.
17:20:23 <quchen> Redz: Why not define your own placeholder type so you don't forget? data Placeholder = Placeholder
17:20:27 * djahandarie AFK
17:20:31 <benzrf> polymorph other
17:21:20 <dwcook> I hate it when somebody turns me into a type variable
17:21:28 <Redz> because i like standards. i defined a `data Undefined = Undefined` but i would be happy to find such things already defined in the standard libs. so i simply ask for, before i use an own placeholder.
17:22:17 <EvanR> interesting to not even have an idea of what the eventual type's name will be
17:22:22 <jmcarthur> i still don't see what's wrong with a type variable
17:22:34 <DEA7TH> how can I tell Haskell I don't care about the types of my numbers and just want it to compile? I have the following program:
17:22:35 <DEA7TH> pow = 5
17:22:36 <DEA7TH> sumDigitPowers a = if a == 0 then 0 else ((a `mod` 10) ** pow) + sumDigitPowers (quot a 10)
17:22:50 <albeit> I have a program that is loading a 1MB file, and processing it line by line. But my program uses >100MB of memory, and I don't know why.. in foldl' loops with nested accumulators, I evaluate the nest components. Where are some areas I can look to fix it? I've tried looking at the heap analysis graphs, but I don't know how to interpret them correctly...
17:23:06 <jmcarthur> DEA7TH: what's going wrong? (if you're going to paste a lot, but it on lpaste)
17:23:07 <DEA7TH> it works if I have (...) ** 5 (...) instead of (...) ** pow (...)
17:23:09 <EvanR> DEA7TH: you should use top level type declarations
17:23:10 <pyon> DEA7TH: Are you sure you want to use the floating-point power?
17:23:32 <DEA7TH> pyon: I don't care, I just want numbers. Of any type.
17:23:34 <quchen> albeit: For proper IO streaming I suggest you have a look at the pipes package. That's as much as I can say without code.
17:23:35 <pyon> DEA7TH: "a ^ b" computes an integer power
17:23:36 <EvanR> haha
17:23:43 <DEA7TH> hm I'll try that
17:23:52 <pyon> DEA7TH: Using exponentiation by squaring.
17:23:52 <BMeph> DEA7TH: I'd use either rem instead of mod, or div instead of quot.
17:24:01 <EvanR> suddenly ghc arbitrarily gives you Complex number results
17:24:09 <quchen> mumble mumble if you don't care about which numbers why not take integers modulo 1
17:24:10 <albeit> quchen: I actually don't think it's the file loading, because it seems like each line is being evaluated properly.
17:24:19 <DEA7TH> Nope, ^ doesn't work either
17:24:28 <DEA7TH> And it works if I use ** 5 instead of ** pow - wtf
17:24:28 <jmcarthur> quchen: that's a case for a Num () instance :)
17:24:43 <EvanR> > () + ()
17:24:44 <lambdabot>  No instance for (GHC.Num.Num ()) arising from a use of ‘GHC.Num.+’
17:25:04 <jmcarthur> DEA7TH: you keeps saying it works or doesn't work but you aren't saying what it's actually complaining about
17:25:21 <quchen> DEA7TH: What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?
17:25:54 <DEA7TH> Using rem and div didn't make it work
17:25:57 <pyon> DEA7TH: Oh, your problem is that pow is not a variable!
17:26:04 <albeit> Here's a big paste, showing the main program function and how its being called... http://lpaste.net/104002. Much obliged to anyone that takes to the time to look at it. (Issue is massive memory usage)
17:26:15 <jmcarthur> DEA7TH: i'm very confused what you mean by "doesn't work"
17:26:22 <DEA7TH> quchen: I have pasted all my source code. It works if I use '5' instead of 'pow'.
17:26:36 <DEA7TH> I want to use a variable, instead of the number '5'.
17:26:36 <jmcarthur> DEA7TH: please put on lpaste your complete source code and what the compiler is telling you
17:26:45 <pyon> DEA7TH: What is that variable supposed to stand for?
17:26:50 <carter> lispy: did anyone answer your CPP question?
17:26:51 <pyon> DEA7TH: A function argument?
17:26:56 <dwcook> pyon: pow = 5 on the previous line.
17:27:09 <dwcook> But yes a paste would be good for this sort of reason
17:27:10 <DEA7TH> pyon: a number. pow = 5 in my case
17:27:11 <pyon> DEA7TH: Do you want a loop counter?
17:27:24 <pyon> DEA7TH: Must it always stand for the same number?
17:27:32 <DEA7TH> No, I want this program: sumDigitPowers a = if a == 0 then 0 else ((a `rem` 10) ** 5) + sumDigitPowers (div a 10)
17:27:36 <DEA7TH> This program works.
17:27:49 <jmcarthur> DEA7TH: really, are you just ignoring me? you aren't making this more clear.
17:27:52 <pyon> DEA7TH: Who supplies that number?
17:27:57 <DEA7TH> When I replace '** 5' with '** pow', where pow = 5 declared earlier, it stops working
17:28:10 <jmcarthur> "it stops working" <-- what does that mean?
17:28:33 <DEA7TH> jmcarthur: sorry, but I really don't feel it is unclear. I can't even imagine anything clearer than "I want to use a variable instead of a primitive"
17:28:34 <pyon> DEA7TH: "let pow = 5" and then "let foo 0 = 0 ; foo a = (r ^ pow) + q where (q,r) = a `quotRem` 10" works just fine on ghci.
17:28:41 <DEA7TH> I even gave working code
17:28:50 <geekosaur> DEA7TH, sounds to me like you're tripping over the monomorphism restriction
17:28:56 <jmcarthur> DEA7TH: what is the error?
17:28:58 <geekosaur> and (extended) defayulting
17:29:08 <geekosaur> if you use the nuber in that expression it is inferred as Double
17:29:09 <jmcarthur> DEA7TH: i have directly asked that question a few times now, and you just say it doesn't work and that's it
17:29:18 <jmcarthur> DEA7TH: type errors are not booleans
17:29:19 <geekosaur> if you split it out, pow is inferred as Integer and then won't typecheck when used with **
17:29:40 <quchen> albeit: What's the type of runQuote? Presumably not a basic type like Int, is it?
17:29:41 <DEA7TH> ah, I'm not sure how to paste the input from ghci.exe
17:29:44 <DEA7TH> output*
17:29:47 <DEA7TH> sec.....
17:29:48 <geekosaur> but. i would like to see the actual error, as jmcarthur keeps asking uyou for and you keep not providing
17:30:31 <albeit> quchen: runQuote :: Simmer -> FileQuote -> Simmer, its the stepping function for the fold
17:30:32 <jmcarthur> i was about to say the monomorphism restriction wouldn't bite in this case, since if a toplevel value is used only once in a module it will be inferred to have whatever concrete type it is used as anyway, but now that i realize this is in ghci, that's probably not true
17:30:54 <jmcarthur> uh, sorry, not monomorphism restriction... defaulting
17:30:55 <albeit> quchen: And Simmer is a data type with a bunch of fields
17:30:58 <quchen> albeit: Do you know how seq works? Forcing a "Simmer" to WHNF doesn't do much.
17:31:16 <quchen> albeit: The foldl' doesn't really make a lot of things strict there.
17:31:44 <quchen> albeit: I'm not sure this is the problem, but it may very well be related.
17:31:52 <DEA7TH> I'll paste the error message as soon as I figure out how to run my code in a way which lets me to select and copy the error messages
17:33:26 <geekosaur> ghci on windows? if you can't instal; winghci, you should be able to copy and paste from cmd.exe the usual way. then paste into the textbox at http://lpaste.org
17:33:33 <geekosaur> @paste
17:33:33 <lambdabot> Haskell pastebin: http://lpaste.net/
17:33:39 <geekosaur> sorry lpaste.net
17:33:50 <albeit> quchen: Yes, I understand the fold strictness isn't doing anything. I just don't know what I need to make strict within the function that manipulates Simmer
17:34:21 <jmcarthur> DEA7TH: based on what you've said i'm going to make a wild guess that what geekosaur suggested is probably the actual problem.   instead of "pow = 5" try "pow = 5 :: Num a => a"
17:34:24 * geekosaur just back from store, and as indicated by earlier typing is still recovering. (not sure I want to know why I need to recover that way...)
17:34:30 <quchen> Ask the other way round: which parts need to be lazy? Things like Int and Double rarely need to be.
17:34:44 <jmcarthur> DEA7TH: i didn't realize it would be difficult for you to copy and paste the type error
17:35:05 <DEA7TH> jmcarthur: nope, didn't work
17:35:07 <jmcarthur> ah
17:35:17 <albeit> quchen: Aha! For whatever reason that just sparked something, and if I evalaute all the individual components of Simmer during the "<- get", the memory is back to normal!
17:35:23 <geekosaur> then we really need to see that error...
17:35:39 <quchen> albeit: You mean by adding lots of bangs there?
17:35:48 <albeit> quchen: Yeah...
17:37:05 <EvanR> im kind of confused about what "needs to be lazy" anyway
17:37:18 <pyon> DEA7TH: http://lpaste.net/104003 -- does this not work for you?
17:37:53 <DEA7TH> This is the source code + the error messages
17:37:54 <DEA7TH> http://lpaste.net/104004
17:37:56 <EvanR> avoiding literally undefined and infinite loops in my code seems like theres bugs
17:38:06 <quchen> albeit: By the way, your foldl' business looks like you could achieve the same thing with 'sequence'.
17:38:43 <albeit> quchen: Ah yes, okay
17:39:06 <DEA7TH> pyon: I'm not sure, I just started learning Haskell today
17:40:01 <quchen> = runState (traverse simulateOneUpdate fileQuotes) s -- albeit: Something like that for the first line. The idea is that you build up a list of all the State actions you want, and then evaluate them in order.
17:40:08 <Ralith> DEA7TH: use type declarations
17:40:18 <Ralith> just because you CAN omit them doesn't mean you SHOULD
17:40:18 <albeit> quchen: Awesome, thanks a lot
17:40:36 <EvanR> top level type definitions help people, including you, read your code
17:40:37 <pyon> DEA7TH: The main problem I can see is that (**) works only for floating-point numbers, but `quot` and `rem` (or `mod`) work only for integers.
17:40:42 <Ralith> including the compiler
17:41:26 <DEA7TH> Ralith: I tried declaring everything a Num (pow = 5 :: Num \n sumDigitPowers :: Num a => a -> a) but it still won't work
17:41:48 <DEA7TH> pyon: replacing ** with ^ doesn't change anything
17:42:31 <EvanR> if you are using **, then you want more than just NUm
17:42:32 <EvanR> Num
17:42:39 <DEA7TH> huh. it worked now, when I replaced it with ^
17:42:48 <DEA7TH> EvanR: I thought Num was a superclass of all numericals
17:42:51 <EvanR> no
17:42:56 <DEA7TH> Which one is it then?
17:43:14 <EvanR> :t (**)
17:43:14 <lambdabot> Floating a => a -> a -> a
17:43:45 <pyon> DEA7TH: The problem is that ** only works on Floatings, which are a subset of all Nums.
17:44:06 <pyon> DEA7TH: And div/quot/mod/rem work on Integrals, which are a (disjoint) subset of all Nums.
17:44:08 <pyon> s/are a/are another/
17:44:19 <DEA7TH> ok, I made a very stupid mistake. I think `^` instead of `**` worked at the beginning, but I tested for that incorrectly and gave a false negative. Sorry about that
17:44:42 <EvanR> :t (^)
17:44:42 <lambdabot> (Num a, Integral b) => a -> b -> a
17:45:21 * EvanR wonders about the idea of "give me numbers i dont care which"
17:45:27 <pyon> DEA7TH: It's okay :-) -- It takes some time to get used to reasoning in terms of types
17:45:44 * EvanR gives DEA7TH Nats
17:45:51 <pyon> DEA7TH: By the way, normally pattern-matching is preferable to "if/then/else".
17:46:30 <DEA7TH> pyon: yeah, I also did that. I'm trying to write varied code
17:48:03 <Hijacker2> Hi! Typical ~homework question~ about list comprehensions (no map, filter, concat, pattern matching allowed). f2 receives a list of lists of Integers. There, it removes odd numbers, eliminates lists that still have >2 elements after the previous operation and then flattens the list. So far I have everything but the >2 elements list elimination covered with this: f2 xs = [b | a <- xs, b <- a, odd b] . Example input: f2 [[1,2,3,4,5],[6,
17:51:18 <XrXr> is there a way to refer to the value that you are currently constructing? like (somethinga, somethingb, somethinga+somethingb)
17:51:40 <EvanR> use a where clause
17:51:54 <XrXr> oh right!
17:51:54 <EvanR> the names you define in there are mutually recursive
17:52:32 <lispy> carter: no, but I don't think it has an answer
17:52:44 <tsani> Hijacker2: you could do something ugly like: (not . null) xs && (not . null . tail) xs && (not . null . tail . tail) xs
17:54:20 <pyon> > [x | n <- [1..20], let xs = [x | x <- [1..n], even x], length xs <= 2, x <- xs] -- Perhaps something like this, Hijacker2?
17:54:21 <lambdabot>  [2,2,2,4,2,4]
17:54:22 <Hijacker2> tsani: the list can be of arbitrary length
17:55:05 <tsani> ah, sorry, my function does the opposite of what you asked.
17:55:09 <tsani> Just prefix it with "not"
17:55:10 <tsani> :)
17:55:28 <tsani> Using length is a bad idea in my opinion since it'll hang if you have any infinite lists.
17:56:00 <carter> lispy: the solution is don't use clang :)
17:56:03 <carter> or ummmm
17:56:14 <pyon> tsani: Oh, right.
17:56:22 <carter> lispy: in 7.8.3 onwards, can set the HS CPP seperately from GHC CC
17:56:34 <carter> but that doesn't help with 7.8.2 support
17:56:38 <carter> or 7.6 on mac
17:57:32 <lispy> carter: I'd prefer it if we could disable -traditional.
17:57:42 <carter> context?
17:57:44 <pyon> > let helper [] = True ; helper [a] = True; helper [a,b] = True ; helper _ = False in [x | n <- [1..20], let xs = [x | x <- [1..n], even x], helper xs, x <- xs] -- Then perhaps like this, tsani and Hijacker2 ?
17:57:45 <lispy> carter: it's not that hard to get rid of #s
17:57:45 <lambdabot>  [2,2,2,4,2,4]
17:57:50 <carter> C99 CPP?
17:57:55 <carter> explain more
17:58:06 <lispy> carter: context http://www.reddit.com/r/haskell/comments/25aw7o/solutions_with_respect_to_conditional_compilation/
17:58:07 <carter> lispy: you can totally override it
17:58:18 <carter> have -optP in your cabal file
17:58:19 <tsani> pyon: yeah, that's a lot nicer.
17:58:55 <lispy> carter: "I tried adding -optP-ansi but it gets ignored because -traditional is also on the command line. "
17:59:21 <carter> lispy: if you explicitly set pgmP too, it drops the traditioanl stuff
17:59:32 <carter> lispy: it'll be easier to customize / overload in 7.8.3
17:59:41 <lispy> carter: "I can get rid of -traditional by using -pgmP gcc -optP-E -optP-ansi, but that is wrong because it may not be the same gcc that ghc is using."
17:59:57 <carter> lispy: you can test with a custom setup.hs
18:00:05 <carter> for what the default system settings are
18:00:14 <carter> and then do some test shell invocations
18:00:21 <carter> and update the configure suitably
18:00:56 <zq_> > [x+y|x<-Nothing, y<-Just 3]
18:00:57 <lambdabot>  Couldn't match expected type ‘[t]’
18:00:57 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
18:00:57 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
18:00:57 <lambdabot>  Relevant bindings include x :: t (bound at <interactive>:1:6)
18:01:05 <lispy> carter: assuming they have gcc
18:01:14 <carter> well, you can test
18:01:26 <carter> lispy: if you set to clang, you can do c99 cpp too
18:01:43 <carter> point being, explicitly setting pgmp to ANYTHING should make the default optP blank
18:02:01 <carter> you'll have to -fnowarnd the various cpp clang things
18:02:05 <carter> though
18:02:43 <lispy> carter: Well, if I could detect that it was clang's CPP from inside the .h file I could do some stuff too.
18:02:59 <carter> lispy: might be easier to do that in the setup.hs file :)
18:03:06 <lispy> carter: __llvm__ and __clang__ are not defined. Probably because of the -undef that ghc passes
18:03:16 <lispy> Ith is build type simple
18:03:16 <NemesisD> anyone aware of a function thats like Monad a => Maybe a -> (a -> m ()) -> m ()
18:03:50 <EvanR> @hoogle Monad a => Maybe a -> (a -> m ()) -> m ()
18:03:51 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:03:52 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:03:52 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:03:54 <carter> lispy: .... theres no good solution unless you do build type custom
18:03:56 <carter> or maybe autoconf
18:04:32 <EvanR> NemesisD: i just wrote one
18:04:38 <NemesisD> i can implement it as maybe (return ())
18:04:38 <benzrf> EvanR: theres mzero
18:04:47 <benzrf> and like
18:04:48 <benzrf> stuff
18:04:49 <lispy> carter: right. so I'm currently rewriting the code so that it doesn't use token concatenation. If I could just disable -traditional then I wouldn't even need to do that.
18:04:52 <EvanR> :t mzero
18:04:53 <lambdabot> MonadPlus m => m a
18:04:55 <benzrf> :t maybe (return ())
18:04:56 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
18:05:02 <benzrf> oh thats for if u want it to terminate
18:05:09 <benzrf> mzero i mean
18:05:10 <benzrf> :t guard
18:05:11 <lambdabot> MonadPlus m => Bool -> m ()
18:05:29 <benzrf> > Just 3 >> guard False >> Just 2
18:05:31 <lambdabot>  Nothing
18:05:36 <benzrf> > Just 3 >> guard True >> Just 2
18:05:38 <lambdabot>  Just 2
18:05:41 <benzrf> @src guard
18:05:41 <lambdabot> guard True  =  return ()
18:05:41 <lambdabot> guard False =  mzero
18:05:52 <EvanR> :t guard . isJust
18:05:53 <lambdabot> MonadPlus m => Maybe a -> m ()
18:06:13 <NemesisD> guard has always seemed sketchy to me
18:06:22 <lispy> NemesisD: can you use for_?
18:06:27 <lispy> :t F.for_
18:06:28 <lambdabot> (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
18:06:46 * hackagebot dns 1.2.3 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.2.3 (KazuYamamoto)
18:06:46 <dwcook> NemesisD: why so?
18:07:30 <lispy> > for_ (Just 1) (\x -> print x)
18:07:32 <lambdabot>  Not in scope: ‘for_’
18:07:32 <lambdabot>  Perhaps you meant one of these:
18:07:32 <lambdabot>    ‘F.for_’ (imported from Data.Foldable),
18:07:32 <lambdabot>    ‘forM’ (imported from Control.Monad.Writer),
18:07:32 <lambdabot>    ‘T.forM’ (imported from Data.Traversable)
18:07:37 <lispy> > F.for_ (Just 1) (\x -> print x)
18:07:39 <lambdabot>  <IO ()>
18:07:47 <NemesisD> dwcook: you use it for the sake of safety, like you're going to do something partial in the rest of the monad, but if you ever accidentally factor it out you're in trouble
18:08:03 <NemesisD> like its sort of a flimsy precaution, not sure if that makes sense
18:08:14 <dwcook> Good point. I'd prefer the safety of an exhaustive case expression.
18:08:35 <pavonia> > Right 10 >> guard False >> Right 20
18:08:37 <lambdabot>  No instance for (GHC.Show.Show a0)
18:08:37 <lambdabot>    arising from a use of ‘M363962919830192128221690.show_M3639629198301921282...
18:08:37 <lambdabot>  The type variable ‘a0’ is ambiguous
18:08:37 <lambdabot>  Note: there are several potential instances:
18:08:37 <lambdabot>    instance [safe] GHC.Show.Show
18:08:59 <pavonia> :t Right 10 >> guard False >> Right 20
18:09:00 <lambdabot> (Error a, Num b) => Either a b
18:09:15 <EvanR> you shouldnt have tried to use a M363962919830192128221690.show_M3639629198301921282...
18:09:22 <pavonia> > Right 10 >> guard False >> Right (20 :: Int)
18:09:24 <lambdabot>  No instance for (GHC.Show.Show a0)
18:09:24 <lambdabot>    arising from a use of ‘M421133159874591755521717.show_M4211331598745917555...
18:09:24 <lambdabot>  The type variable ‘a0’ is ambiguous
18:09:24 <lambdabot>  Note: there are several potential instances:
18:09:24 <lambdabot>    instance [safe] GHC.Show.Show
18:09:30 <pavonia> Come on
18:10:17 <pavonia> > Right 10 >> guard False >> Right 20 :: Either String Int
18:10:18 <lambdabot>  Left ""
18:10:26 <pavonia> Here we are
18:10:44 <EvanR> Error a ...
18:15:03 <EvanR> while the non ascii letters in my code do work
18:15:10 <EvanR> github barfs ;) https://github.com/evanrinehart/functional_pacman/blob/master/Fruit.hs
18:15:19 <hughfdjackson> :) morning
18:15:34 <dwcook> hughfdjackson: :0 I haven't seen you on IRC in ages
18:15:41 <hughfdjackson> ;) well
18:15:55 <hughfdjackson> where else am i going to come for my very noobish haskell Qs?
18:16:08 <XrXr> ^
18:16:30 <hughfdjackson> (how've you been? :D)
18:16:54 <dwcook> All right. Don't let me stop you from asking your noobish Haskell question. :)
18:18:11 <hughfdjackson> i'm being really dumb here - i'm going to write a little wrapper around Network.HTTP.Client to make a function with the signature `get :: String -> IO (ByteString)`
18:18:43 <hughfdjackson> I want to unwrap that bytestring and supply it to Muku.text in a Mike.get handler
18:18:46 <hughfdjackson> https://gist.github.com/hughfdjackson/01e7937e4162c69a0dd1
18:19:32 <hughfdjackson> I've added the compiler error to the gist
18:19:51 <hughfdjackson> I'm aware that do notation depends on *which* monad you're in - and that Muku doesn't run in the IO monad directly
18:20:00 <hughfdjackson> *Miku
18:20:38 <carter> lispy: if you wanna try out  a ghc + the easy to have the CC and CPP be different build
18:20:45 <carter> i can link you to my mac bindist
18:20:51 <carter> that has the patches in question applied
18:21:34 <hughfdjackson> i'm just a bit lost on how to unpack the ByteString from the IO (ByteString) into Miku.text :/
18:22:28 <hughfdjackson> (updated to the gist to make the test case more minimal)
18:22:43 <carter> hughfdjackson:  use the power of bind!
18:22:59 <pavonia> hughfdjackson: Maybe you need a liftIO?
18:23:07 <carter> :t (undefined :: IO (Bytestring)) >>=
18:23:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:23:24 <carter> :t (undefined :: IO (Bytestring)) `(>>=)`
18:23:25 <lambdabot> parse error on input ‘(’
18:23:26 <dmwit> carter: You should read the error first.
18:23:48 <carter> dmwit: would help if i understood which ( :)
18:24:20 <dmwit> pavonia++
18:25:56 <EvanR> hughfdjackson: youre trying to write the get function, or trying to use it because it already works in the console
18:26:53 <hughfdjackson> EvanR: trying to write one :) just as a hello world of web programming
18:27:04 <hughfdjackson> pavonia: looking into that possibility now :D
18:28:12 <tinyghost> is there a parsec combinator that always succeeds without consuming any input
18:28:19 <dmwit> return ()
18:28:22 <hughfdjackson> pavonia: it compiles
18:28:28 <tinyghost> oh lovely thanks
18:28:35 <hughfdjackson> ;) i don't see the point in testing it further - it's clearly now flawless
18:28:36 <hughfdjackson> thanks :D
18:29:26 <lispy> carter: Well, I did this for now: https://github.com/haskell-opengl/OpenGLRaw/pull/22
18:29:46 <dmwit> tinyghost: Do you need it to succeed in the Parsec sense of succeed (i.e. commit)?
18:29:52 <lispy> carter: how do you configure your ghc to do stuff?
18:29:55 <dmwit> I don't think return does that.
18:30:04 <carter> lispy: you mean my build?
18:30:17 <tinyghost> commit?
18:30:18 <carter>  ,("C compiler command","clang")
18:30:19 <carter>  ,("C compiler flags"," -m64 -fno-stack-protector")
18:30:19 <carter>  ,("C compiler link flags"," -m64")
18:30:19 <carter>  ,("Haskell CPP command","gcc")
18:30:19 <carter>  ,("Haskell CPP flags","-E -undef -traditional ")
18:30:20 <carter>  ,("ld command","/usr/bin/ld")
18:30:21 <lispy> carter: yeah, what do you mean by " the easy to have the CC and CPP be different build" ?
18:30:28 <lispy> ah
18:30:41 <carter> thats what i'm still waiting to get merged in will let you do
18:30:53 <tinyghost> http://lpaste.net/104007 this is the combinator I made
18:30:57 <hughfdjackson> pavonia: i'm looking at the type signature of liftIO
18:31:11 <carter> https://ghc.haskell.org/trac/ghc/ticket/8683 is the associated ticket (skip most of th comments, i got a bit..... verbose)
18:31:31 <lispy> carter: I just want an easy way to say, "ansi cpp, please"
18:31:38 <hughfdjackson> doesn't seem to be very illuminating :/ are there any posts out there anyone'd recommend on understanding this?
18:31:44 <carter> lispy: thats a valid requestion
18:31:50 <EvanR> hughfdjackson: you shouldnt need liftIO to write the get function
18:31:51 <tinyghost> I was thinking it might be nice to have it so you could pass a combinator that always succeeded as the second argument so it'd try the first one and if it failed it'd always return Nothing
18:31:52 <carter> and an intersting one
18:31:54 <dmwit> hughfdjackson: Have you done much with monad transformers before?
18:32:08 <dmwit> tinyghost: There's already "optional", isn't there?
18:32:10 <dmwit> :t optional
18:32:11 <lambdabot> Alternative f => f a -> f (Maybe a)
18:32:14 <carter> lispy: eg, maybe we should have  Language HPP and CPP and ANSICPP
18:32:15 <carter> and stuff
18:32:27 <carter> lispy: i think the best solution going forward is figure out an HSPP
18:32:41 <carter> notice how i call that fild "("Haskell CPP command","gcc") "
18:32:54 <carter> *field
18:32:57 <lispy> carter: notice that I had to #define HASH #
18:33:06 <carter> ewww and sads
18:33:17 <carter> lispy: hence why i think we need to have a haskell PP
18:33:37 <lispy> carter: what was wrong with cpphs?
18:33:44 <lispy> carter: (other than being GPL)
18:33:45 <carter> its CPP based
18:33:59 <carter> we should figure out how to evolve what we want to work for haskell
18:34:01 <lispy> have you talked to merijn lately?
18:34:05 <carter> hahah
18:34:15 <carter> i promised him a debt of beer when he's less grumpy
18:34:22 <carter> lispy: 'm WELL aware of all the CPP issues currently
18:34:30 * lispy notes the clever way to never have to pay him
18:34:50 <lispy> programmer grumpiness is monotonically non-decreasing
18:34:52 <dmwit> hughfdjackson: Well. If you haven't, play with them some. When you've written your 16th lift, come back here and we will explain liftIO.
18:35:01 <lispy> as in, it may stay the same but it never goes down
18:35:08 <hughfdjackson> dmwit: okay ;) will do
18:35:12 <dmwit> hughfdjackson: If you have, then the explanation is simple: liftIO is the typeclass way to write "lift" the right number of times when IO is the base monad.
18:35:26 <startling> :t liftIO
18:35:27 <lambdabot> MonadIO m => IO a -> m a
18:35:56 <startling> :t liftIO getLine >>= put
18:35:57 <lambdabot> (MonadState String m, MonadIO m) => m ()
18:36:20 <lispy> carter: as I understand it, the only reason to use -traditional is so that cpp ignores #s
18:36:31 <startling> :t liftIO getLine >>= IdentityT
18:36:32 <lambdabot>     Not in scope: data constructor ‘IdentityT’
18:36:32 <lambdabot>     Perhaps you meant ‘Identity’ (imported from Control.Monad.Identity)
18:36:38 <startling> aw. :(
18:36:38 <carter> lispy: my take on it is differnet
18:36:48 <carter> we need a HPP that understands haskell tokens
18:37:20 <carter> tradmode isn't as general / flexible as a "proper" cpp for HS would be
18:37:29 <carter> because its not haskell token based
18:38:02 <lispy> What are we missing out on?
18:38:27 <lispy> I'm actually glad that people don't write a lot of crazy macros
18:38:29 <hoverbear> carter: So I should grab GHC here http://www.haskell.org/ghc/download_ghc_7_8_2 and then get cabal here http://www.haskell.org/cabal/download.html ? Not use Haskell Platform?
18:38:29 <carter> things get narly with mulitple args and any haskell pragmas
18:38:35 <carter> sure
18:38:39 <carter> hoverbear: sounds good
18:38:41 <lispy> multiple args?
18:38:46 <lispy> you mean, like varargs cpp?
18:38:49 <carter> no
18:38:50 <carter> more than 1
18:38:52 <carter> wait
18:38:53 <carter> umm
18:38:55 <carter> i don't remember
18:39:03 <carter> i blacked out my CPP knownledge :)
18:39:16 <lispy> okay, think about it and let me know if you remember
18:39:32 <carter> lispy: sure
18:39:45 <carter> after i'm done with my release checklist and making sure income for the next month is sorted
18:39:51 <lispy> carter: CPP does try to parse commas so I have a vague idea that I might know waht you mean.
18:39:52 <carter> ... which is very turbulent
18:39:52 <hoverbear> carter: Why not use Haskell Platform?
18:39:59 <carter> hoverbear: because reasons
18:40:00 <carter> like
18:40:06 <carter> you're not on windows, so no gain from using HP
18:40:14 <carter> hoverbear: the only time that HP helps you
18:40:16 <hoverbear> Okay, I see.
18:40:28 <hoverbear> ANd using Homebrew is ludicris
18:40:31 <carter> yes
18:40:41 <carter> :)
18:40:45 <carter> just install the official binaries
18:41:22 <hoverbear> Cabal has binaries?
18:41:23 <lispy> Well, the one time when I would recommend HP is for beginners. They already have enough new stuff to learn.
18:41:29 <carter> yup
18:41:34 <carter> @google cabal binaries
18:41:35 <lambdabot> http://www.haskell.org/haskellwiki/Cabal-Install
18:41:35 <lambdabot> Title: Cabal-Install - HaskellWiki
18:41:39 <carter> @google cabal binary
18:41:40 <lambdabot> http://www.haskell.org/cabal/download.html
18:41:40 <lambdabot> Title: The Haskell Cabal
18:41:48 <carter> hoverbear: http://www.haskell.org/cabal/download.html
18:42:03 <carter> lispy: I like giving people some basic fishing skills and cabal 1.20 :)
18:42:03 <Platz> ahh, using Data.Sequence instead of List brought my mergesort from 30s to .30s . I think next I'll try a direct translation using STUArray
18:42:16 <carter> lispy: the default cabal.config in HP is a bit crufty
18:42:30 <lispy> carter: fishing skills are good. I aim to do that as well. Just have to balance overwhelm.
18:42:35 <carter> yes
18:42:37 <hoverbear> carter: okay I see, nice.
18:42:40 <startling> carter: we're at 1.20.0.1 now !
18:42:43 <carter> yup
18:42:49 <carter> startling: but current HP release is 1.6
18:42:51 <carter> *1.16
18:42:55 <startling> ouch.
18:42:58 <carter> soooo yeah
18:43:05 <carter> sequential builds and no sadnboxes
18:43:10 <lispy> Platz: nice! What are you implementing?
18:43:58 <Sonarpulse> I am using llvm-general, which is otherwise pretty great, but causes ghci to segault on loading my (haskell) module.
18:44:00 <Platz> just homework for the coursera algorithms course.  implementing a mergesort wich also counts the "inversions" as a by-product
18:44:32 <Sonarpulse> anybody else have this problem? or know of a fix?
18:44:49 <carter> Sonarpulse: i know whyyyy
18:44:56 <carter> @hackage llvm-general
18:44:57 <lambdabot> http://hackage.haskell.org/package/llvm-general
18:44:57 <Sonarpulse> oooooo
18:45:09 <carter> build with -fshared-llvm
18:45:10 <carter> :)
18:45:21 <carter> what ghc version are you on?
18:45:24 <Sonarpulse> 7.8
18:45:27 <carter> cool
18:45:48 <Sonarpulse> is cabal install llvm-general with that flag?
18:45:57 <carter> just that
18:45:58 <carter> yup
18:46:06 <Sonarpulse> ok great.
18:46:12 <carter> Sonarpulse: what OS
18:46:19 <Sonarpulse> debian wheezy
18:46:21 <carter> k
18:46:29 <carter> you'll be set
18:46:34 <Sonarpulse> excellent
18:46:41 <BMeph> wheezy wendigo? ;þ
18:47:50 <SrPx> Does anyone know the name of a paper suggesting lists based on concat instead of cons, for friendler parallel operations?
18:48:03 <syzygy> ?
18:48:52 <carter> SrPx: its call use a tree
18:49:14 <carter> have you linguistic default be a tree data structure
18:49:16 <carter> not a list
18:49:22 <lispy> SrPx: it might be in here: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
18:49:29 <lispy> SrPx: lots of good lazy data structures in there
18:49:32 <Iceland_jack> @google guy steele cons
18:49:32 <lambdabot> https://groups.google.com/d/topic/comp.lang.lisp/Yr6aF7Rw3Fg
18:49:38 <SrPx> yes, there is a paper suggesting you to use trees instead of lists, and showing some algorithms (filter / map / fold / etc) on them. I'm looking fo rit
18:49:42 <carter> nah, its in teh guy steele fortress talks
18:50:03 <carter> its an experience report on designing fortran
18:50:06 <carter> *fortress
18:51:40 <SrPx> carter: yes that is the idea, but all I can find is guy's talk. There is an actual paper a little older, though... damn I should've saved it
18:51:59 <carter> doesnt matter, the idea  is simple, doesn't need a apper
18:52:02 <carter> only benchmarks :)
18:52:15 <carter> recursive decomposition for parallel computation is generally a good way to roll
18:54:50 <hoverbear> carter: Cool, ghc is working. Cabal next.
18:54:59 <carter> hoverbear: copy it into your path
18:55:06 <carter> eg usr/local/bin
18:55:08 <carter> or something
18:55:20 <carter> also add ~/.cabal/bin to your path (~ expanded to your homedir)
18:55:47 <lispy> SrPx: This seems to be the paper, but I can't find the pdf http://www.citeulike.org/user/spl/article/5734083
18:55:47 <carter> then as a test, try cabal update ; cabal install cabal-install
18:56:46 <SrPx> carter: ah I see I just wanted the paper to see their implementation of filter. Specifially, I'm dealing with a problem here, in which the "rebalancing and nil-removing" operation should be separed
18:56:55 <zcd> is it a good idea to use show/read for data serialization?
18:57:07 <blaenk> there a function to get [[(a, b)]] into [(a, [b])], such that all of the equal a's in the input are grouped with a list of the b's that correspond?
18:57:09 <SrPx> so the identity function over lists does that rebalancing, and now the filter becomes much simpler (it is just a map that returns either nil or the same element)
18:57:18 <lispy> SrPx: ah, it used to be hosted here but then Sun was taken over by Oracle: https://research.sun.com/projects/plrg/Publications/ICFPAugust2009Steele.pdf
18:57:43 <blaenk> right now I wrote my own with something like map (\items@((a, _):_) = (a, map snd items))
18:58:12 <SrPx> lispy: nah it was not guy the author :{ but thanks. nevermind that
18:58:13 <blaenk> forgot to say, the input is already grouped, such that any inner [(a, b)] is all the same a's
18:58:40 <Sonarpulse> carter: our llvm (not from libs, debian is too old) had only static libs in it's lib dir. will we need to build it again?
18:59:01 <carter> you tell me :)
18:59:13 <carter> can you / dare you dy link to a static lib?
18:59:50 <Sonarpulse> well cabal would just lib-not-found us when only presented with static libs and -fshared-llvm
18:59:57 <carter> sooo
18:59:59 <tsani> hm speaking of static libs, can ghc link statically ?
19:00:00 <carter> you tell me :)
19:00:06 <carter> yes
19:00:07 <carter> it can
19:00:07 <carter> it does by default
19:00:16 <Sonarpulse> oh well I know it can buidl
19:00:22 <Sonarpulse> because we did earlier
19:00:24 <carter> Sonarpulse: i thinkyou know the answer
19:00:25 <Sonarpulse> but then the ghci problem
19:00:49 <carter> if you want llvm-general to wokr in ghci... you have to __________
19:01:02 <carter> a) -fshared-llvm and b) _________
19:01:20 <Sonarpulse> rebuild llvm
19:01:35 <carter> rebuild it so that _____ ?
19:01:49 <Sonarpulse> we have dynamic libraries
19:01:52 <carter> yay
19:02:02 <hughfdjackson> d'oh - Network.HTTP.Client vs Network.Http.Client
19:02:21 <carter> Sonarpulse: i'm trying out this "teach fishing so i don't have to use my net" approach
19:02:31 <carter> i hope it results in me using CAPs on IRC less
19:02:43 <Sonarpulse> fair enough
19:03:11 <carter> so all i did was help you get more comfortable in knowing the answer arleady
19:03:13 <Hafydd> Network.HtTp.Client
19:03:17 <carter> you just needed that one flag trick
19:03:24 <carter> or something
19:03:26 <Sonarpulse> I was wondering whether shareds libs is /a/ solution or the /only/ solution, as I have used static libs and ghci beofre.
19:03:40 <carter> Sonarpulse: with C++ codes?
19:03:45 <Sonarpulse> C
19:03:46 <carter> or just C codes?
19:03:52 <carter> yeah... thats the tricky thing
19:03:57 <carter> C++
19:04:01 <Sonarpulse> ahhh
19:04:21 <carter> you got some sort of static constructor error before right?
19:04:44 <Sonarpulse> nope
19:04:53 <carter> what was the linker error before?
19:05:15 <Sonarpulse> segfault without explanation
19:05:30 <Sonarpulse> different than what you posted on your github issue
19:05:34 <carter> ok
19:05:38 <carter> well, i also was on a mac
19:05:54 <Sonarpulse> well that always makes building more fun
19:06:24 <mizu_no_oto> I'm trying to install hscurses via cabal in a sandbox using cabal version 1.18.1.3 and ghc version 7.8.2 on OSX Mavericks.  Cabal can't install any version of the unix package : http://lpaste.net/104008
19:06:30 <mizu_no_oto> Any suggestions?
19:06:58 <carter> mizu_no_oto: unix should be installed already
19:07:13 <hughfdjackson> :) thanks for the help, all - v. satisfying to see it working as expected
19:07:15 <carter> mizu_no_oto: ghc-pkg list
19:07:21 <carter> shoudl have a unix version listed
19:07:56 <mizu_no_oto>    unix-2.6.0.1, it says
19:08:42 <mizu_no_oto> When I tried cabal installing, it said "rejecting: unix-2.6.0.1, 2.6.0.0 (conflict: base==4.7.0.0/installed-a33...,"
19:08:51 <carter> mizu_no_oto: what was the GOAL that led to this
19:08:59 <carter> agda?
19:09:14 <carter> or what
19:09:33 <mizu_no_oto> I made this sandbox originally using 7.8.0 and then installed 7.8.2; should I just blow it away and recreate it?
19:09:40 <carter> oh
19:09:41 <carter> yup
19:09:48 <carter> when a sandbox is weird, KILL it
19:11:28 <mizu_no_oto> Hmm.  Didn't seem to help
19:12:06 <mizu_no_oto> Anyways, the final goal is a simple game I'm writing; something along the lines of 2048
19:12:08 <carter> how did you kill it
19:12:10 <carter> ok
19:12:17 <mizu_no_oto> cabal sandbox delete
19:12:19 <mizu_no_oto> then
19:12:24 <mizu_no_oto> cabal sandbox init
19:12:30 <carter> mizu_no_oto: ... could you ahve bad version bounds in you rcabal file?
19:12:37 <mizu_no_oto> cabal install --dependencies-only
19:12:45 <carter> add --allow-newer
19:12:48 <carter> mizu_no_oto: ohhh
19:12:49 <carter> nvm
19:12:53 <carter> first update to cabal 1.20
19:13:06 <carter> cabal update ; cabal install cabal-install
19:13:08 <carter> THEN
19:13:13 <carter> the --allow-newer is a thing
19:13:18 <carter> so you can ignore version bounds
19:13:25 <carter> i bet you were hitting a verson constraint conflict
19:13:44 <mizu_no_oto> probably
19:13:53 <pyon> What does --allow-newer do?
19:14:01 <carter> it say "ignore upper bounds"
19:14:16 <carter> it basically means you have no reason NOT to include upperboudns now :)
19:14:41 <carter>    --allow-newer[=PKGS]            Ignore upper bounds in dependencies on some
19:14:41 <carter>                                     or all packages.
19:14:44 <carter> is teh full thing
19:14:48 <pyon> carter: It ignores upper bounds in package dependency descriptions, right?
19:15:03 <carter> vs what?
19:15:19 * pyon wonders if lens will be compatible with transformers-0.4.1.0 that way.
19:15:41 * pyon should backup his ~/.ghc and ~/.cabal directories.
19:16:07 <carter> pyon: you enver evereeeer have to delete .ghc
19:16:11 <carter> i mean .cabal
19:16:12 <carter> only .ghc
19:16:23 <carter> its always safe to  wipe .ghc
19:16:25 <carter> not .cabal
19:16:41 <carter> pyon: i think lens is now friends wiht .4
19:16:45 <carter> but... wait a week :)
19:17:19 <pyon> carter: While the whole transition to transformers-0.4.1.0 and mtl-2.2.0.1 happens?
19:17:25 <carter> yes
19:17:44 <carter> if you really need some abstractions in the mean time, copy and paste them into a private module in your codes :)
19:18:10 <carter> i actually have that in some of my code, partly because i need a version of some transformers ops, where I need to have unconditional inlining guaranteed
19:20:56 <sveit> htis is probably trivial for experienced people, but I am having trouble wrapping my head around what the proper datatype is to represent the contents of a large file:
19:21:17 <EvanR> the raw contents should be ByteString
19:21:31 <sveit> basically, I want to parse it with parsec. the file is organized so that there are 4 lines of "stuff" at the beginning, and then commentlines, command lines, and data lines
19:21:45 <EvanR> you probably want attoparsec
19:21:51 <sveit> EvanR: yep, that's what i'm using
19:21:54 <pyon> Is there anything like a STByteString ?
19:22:06 <sveit> i guess I haven't expressed my confusion well
19:22:11 <pyon> (A fixed-length string whose individual bytes are mutable, inside ST.
19:22:19 <pyon> )
19:22:20 <EvanR> and you might want to read the lines of the file incrementally
19:22:25 <EvanR> if its really big
19:22:32 <sveit> oh yes, i am sorry, that is not my confusion
19:22:39 <sveit> it is not in the mechanics
19:22:55 <sveit> my confusion is that after i have parsed the file, i need to represent the contents as a Haskell datatype
19:23:02 <sveit> (obviouslY)
19:23:09 <EvanR> well, you need to decide that during the parsing, not after
19:23:18 <sveit> the thing is, the file has comment lines, data lines, and command lines interspersed
19:23:20 <EvanR> unless its two stages
19:23:20 <sveit> but the order matters
19:23:35 <sveit> so it would seem to me that the correct thing to do would be to store these lines in a list
19:23:45 <sveit> but lists can only be of elements of a single type
19:24:01 <EvanR> if there are three kinds of lines, you can have a sum type
19:24:14 <EvanR> data Line = A ... | B ... | C ...
19:24:23 <EvanR> and the list is a [Line]
19:24:26 <sveit> yes, but is that the "good" solution?
19:24:26 <dwcook> Is there a convenient way to specify per-sandbox which GHC to use?
19:24:32 <EvanR> yes
19:24:37 <sveit> the thing is the different types of lines are VERY different
19:24:51 <sveit> it doesn't make "logical" sense to me to treat them as the same kidn of object
19:25:34 <EvanR> well from the perspective of parsing, you can just use that Line type to represent the result of parsing, if its wrapping three really different things, thats fine because you can split it up later to send them to where they need to go
19:26:03 <EvanR> and drop the Line
19:26:51 <sveit> EvanR: so just to clarify, your solution explicitly is to define data CommentLine = CommentLine ..., data CommandLine = CommandLine ..., data DataLine = DataLine ..., and finally data Line = CLine CommandLine | DLine DataLine | ...
19:27:14 <EvanR> yeah
19:27:40 <EvanR> possibly renaming all that so its more clear whats its for
19:27:43 <sveit> ok. first thank you. second, that is a little surprising since it seems less "elegant" than simple inheritance, for example, in python
19:28:22 <EvanR> im genuinely lost when it comes to "simple inheritance" can you explain how that would work
19:28:59 <sveit> so the idea is that i could define, for example, a Line object that had an associated line number and text, for example
19:29:31 <sveit> then I could define a CommentLine object SEPARATELY that had different information, but was still considered a Line
19:29:44 <EvanR> so the three lines are not "wildly" different are they?
19:29:54 <sveit> in Haskell I have to do something like data Line = Line ... | CommentLine ... | ...
19:30:02 <carter> pyon: storable ST arrays
19:30:26 <EvanR> first issue i see with that python way is that the Line object actually doesnt make sense by itself, at least for your application
19:31:04 <sveit> EvanR: well in my case, there are also lines I don't care about that get stored as simple "Line"s
19:31:30 <EvanR> secondly, since the three things are different, why do they need to be a child class of the same class? are they implementing some standard interface?
19:33:27 <EvanR> if they should all be associated with line numbers, they you might want to keep that line wrapper and represent it there
19:33:52 <sveit> EvanR: ok, i guess i should be more clear
19:34:09 <sveit> EvanR: in my specific case (not the examples) each line has completely different information required from it
19:34:36 <sveit> EvanR: comment lines need the literal text, data lines need to be parsed into timestamps and arrays of doubles, and command lines need the type/arguments of the command
19:34:50 <sveit> this is the reason I don't think they should be of the same class
19:35:33 <sveit> but I need to put them into some arbitrarily large order-preserving container since that is also important, and in Haskell it appears this means the have to ahve the same type
19:35:34 <EvanR> right
19:35:48 <EvanR> right again
19:36:03 <zq_> is [x..y] syntactic sugar?
19:36:23 <EvanR> yes
19:36:32 <EvanR> :t enumFromTo
19:36:33 <lambdabot> Enum a => a -> a -> [a]
19:36:37 <mizu_no_oto> carter: Ever see "cabal: sh: inappropriate type" before?
19:36:45 <zq_> EvanR: yes i know about that function
19:36:47 <carter> wat
19:36:51 <carter> whats your system config
19:36:52 <sveit> EvanR: I have no idea what a "good" way to do this is :) you suggested the data Line = A ... | B ... | ..., but to me this seems clunky
19:36:53 <carter> what OS
19:36:55 <carter> what ghc --info
19:36:56 <carter> what clang --info
19:36:59 <zq_> the question is whether it's sugar or something monad-y like list comprehensions
19:37:02 <carter> what gcc --info
19:37:04 <carter> what shell
19:37:05 <carter> whats your code
19:37:29 <EvanR> sveit: its pretty good, because then you can safely use that list, for whatever it is you want, while having the compiler tell you if you screwed up
19:37:31 <kazagistar> zq_: http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#t:Enum
19:38:09 <EvanR> sveit: if you dont need them in the same list, then you can also return ([A], [B], [C]) from the parser instead, where A B and C are different types
19:38:36 <sveit> EvanR: I wish, but their relative order matters :)
19:39:00 <EvanR> you can attach a number
19:39:02 <zq_> :T I#
19:39:03 <zq_> :t I#
19:39:04 <lambdabot>     Not in scope: data constructor ‘I#’
19:39:05 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
19:39:07 <EvanR> we dont have to put stuff that is ordered into a list
19:39:42 <EvanR> sveit: of course this is all very abstract since you havent explained what youre doing with these three types
19:40:12 <EvanR> zq_: its just sugar
19:40:34 <sveit> EvanR: well, for example, I might want all the DataLines that occur in between two specific CommandLines
19:40:44 <EvanR> heh
19:40:57 <EvanR> in what form, ([A],[B],[C]) ?
19:41:11 <zq_> EvanR: huh? I# is a constructor
19:41:25 <EvanR> zq_: i was answering your earlier question
19:42:02 <sveit> EvanR: so for three line types of A,B,C, I would want, with type [A], all the lines that occur between two particular lines of type B
19:42:25 <EvanR> sveit: i know of a library that would be good for doing these kinds of queries
19:42:35 <sveit> EvanR: so your suggestion of attaching line numbers to each one might actually work as well
19:42:38 <DEA7TH> how do I get permutations with a reduced length? e.g. ABC -> AB, AC, BC
19:42:47 <EvanR> sveit: right
19:43:05 <DEA7TH> Data.List.permutations doesn't allow me to reduce the length
19:44:09 <EvanR> sveit: https://hackage.haskell.org/package/ixset sounds like youre talking about an indexed set
19:44:26 <dwcook> Where can I find documentation for the fields of ~/.cabal/config? I've found some cabal page but it's not obvious where that specific information would be.
19:44:58 <EvanR> sveit: if each record has a "line number" and a record of one of three variants, you can put them all in a set that can be indexed in various ways, including a range
19:45:17 <EvanR> sveit: at this point it seems clear you want a single type for all three (with three cases)
19:45:49 <EvanR> sveit: like "gimme all lines between 10 and 20, and type A or B"
19:48:15 <sveit> EvanR: cool! i'll look into it. thanks
19:48:50 <benzrf> :t right
19:48:51 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
19:48:54 <benzrf> o:
19:51:14 <Sonarpulse> carter: we recompiled LLVM and it seems to be working, thanks!
19:51:24 <carter> YAY
19:59:45 <lispy> I have ghc with clang and ghc without clang
19:59:57 <lispy> Dare I install things with the former?
19:59:58 <carter> i have done such
20:00:09 <carter> lispy: i like my setup
20:00:13 <carter> clang for c / asm
20:00:15 <carter> gcc for CPP
20:00:59 <EvanR> hold on, modules can import each other without any special settings?
20:01:13 <lispy> I patched up GLURaw and OpenGLRaw to build with clang.
20:01:25 <lispy> Now just waiting for those patches to be reviewed.
20:01:47 <lispy> EvanR: what do you mean?
20:01:54 <EvanR> A imports B, B imports A
20:01:55 <lispy> EvanR: you can import an entire module if that's what you mean.
20:02:11 <lispy> oh yeah, that's allowed to...but ghc requires you to use hs-boot files.
20:02:20 <EvanR> im not using any such file though
20:02:21 <lispy> It's usually not worth it.
20:02:38 <lispy> Oh, maybe they made it optional for cases where it can figure it out?
20:02:47 <lispy> I did hear someone suggest that change once
20:02:49 <EvanR> thats interesting
20:03:02 <EvanR> now i dont know if im doing something somehow wrong
20:03:12 <EvanR> terribly convenient though
20:05:05 <lispy> I can't find anything on google that says stuff changed
20:05:14 <EvanR> about to do a sanity test
20:06:17 <lispy> EvanR: I just tried it on 7.8.2 and it says I have a cycle
20:07:06 <EvanR> youre right
20:08:22 <EvanR> i have A imports B, A imports C, and B imports C
20:08:28 <EvanR> not a cycle
20:11:26 <lispy> carter: that setup seems unsafe. What if gcc and clang disagree as to the proper definition of some bit of CPP? Then you expand it out using gcc's definition but compile the result using clang?
20:11:39 <carter> lispy: nope
20:11:51 <carter> hsCPP only gets invoked on .hs / .lhs failes
20:11:57 <StoneCypher4K> if gcc and clang disagree on the proper definition, either one of them is wrong or both are.  the standard defines it or it doesn't.
20:12:14 <carter> lispy: Haskell CPP is ONLY invoked on haskell files
20:12:18 <carter> not C / C++ files
20:12:25 <lispy> StoneCypher4K: I mean things that are defined in CPP. For example, with #define.
20:13:03 <carter> lispy: i've built lense and pandoc with this setup both
20:13:25 <carter> heck, this setup works better than GCC only for certain mac specfici libs
20:13:36 <carter> like hfsevents
20:13:57 <pqmodn> did Data.Map.lookup used to have type (Monad m, Ord k) => k -> Map k a -> m a, or is that a different operation?
20:14:05 <carter> :t DM.lookup
20:14:05 <lambdabot>     Not in scope: ‘DM.lookup’
20:14:06 <lambdabot>     Perhaps you meant one of these:
20:14:06 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
20:14:12 <carter> :t M.lookup
20:14:13 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
20:14:18 <carter> hrmm
20:14:37 <lispy> @hoogle  k -> Map k a -> m a
20:14:38 <lambdabot> Data.Map.Lazy lookup :: Ord k => k -> Map k a -> Maybe a
20:14:38 <lambdabot> Data.Map.Strict lookup :: Ord k => k -> Map k a -> Maybe a
20:14:38 <lambdabot> Data.Map.Lazy (!) :: Ord k => Map k a -> k -> a
20:14:40 <glguy> I'm pretty sure that one used to work over any Monad and was fixed to work on Maybe
20:14:50 <pqmodn> yeah, good!
20:14:54 <carter> @hackage containers
20:14:54 <lambdabot> http://hackage.haskell.org/package/containers
20:15:19 <carter> yup http://hackage.haskell.org/package/containers-0.1.0.0/docs/Data-Map.html
20:15:35 <carter> in 0.1
20:15:52 <lispy> carter: and what cpp gets invoked when you use hsc2hs?
20:15:55 <pqmodn> wow, didn't realize it was that long ago.
20:16:13 <carter> lispy: what libs use that? i'll try it
20:16:29 <carter> give me a fuzzer list to test
20:16:37 <carter> and i'll install ALL of them in a sadnbox
20:16:38 <lispy> carter: might be easier to make an empty .hsc module
20:16:46 <carter> nah, i wanna just build things
20:17:06 <lispy> My thought is that you could just do a quick verbose build to see which cpp is invoked.
20:17:30 <lispy> the freetype2 bindings using hsc2hs
20:17:33 <carter> does hsc pick up ghc settings at all?
20:17:43 <lispy> I'm not sure
20:17:54 <carter> some stuff has gcc hard coded in
20:18:55 <lispy> it may use $PATH
20:19:08 <enthropy> Fuuzetsu: can haddock document GADT constructors: http://lpaste.net/104009 ?
20:21:41 <lispy> carter: it calls System.Directory.findExecutable. Uses $PATH modulo some windows caveats.
20:23:44 <glguy> http://trac.haskell.org/haddock/ticket/43
20:24:06 <glguy> That ticket is 6 years old, but the current milestone is the next version of haddock, so who knows :)
20:24:15 <glguy> "Comments on GADT constructors"
20:24:17 * hackagebot dns 1.2.3 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.2.3 (KazuYamamoto)
20:24:17 * hackagebot faceted 0.0.1.0 - Faceted computation for dynamic information flow security  http://hackage.haskell.org/package/faceted-0.0.1.0 (KennKnowles)
20:25:59 <enthropy> glguy: great it's soon to be fixed
20:26:32 <augur> jonsterling: ping
20:26:40 <stephenmac7> .pf hello a = putStrLn . (++) a
20:27:14 <jonsterling> augur: Hey
20:27:56 <augur> jonsterling: i asked what i did specifically because NuPRL rejects (or at least Harper (in so many words) claims NuPRL rejects) Martin-Lof's meaning explanations
20:28:18 <jonsterling> augur: Where did he say that? I've heard him say the opposite before...
20:28:48 <augur> jonsterling: MLTT is defined, at least by ML, in a purely formal/inferential way, whereas harper insists that NuPRL and type theory more generally is about some other notion of semantics
20:29:22 <augur> ive heard PER semantics as relevant, or something to that effect. something people call "realizability semantics" (but which SEP seems to have weird information on)
20:29:38 <augur> none of it being at all like ML's own statements on what meanings are
20:30:44 <jonsterling> My understanding is that PER semantics and realizability are sort of an inductive-recursive metamathematical version of Martin-Löf's meaning explanations. The distinction is that the ML's meaning explanations are support to be "premathematically" justified, whereas the realizability stuff is a way to study them from within a mathematical metalanguage.
20:31:21 <jonsterling> augur: This is where I heard RWH talk about NuPRL & meaning semantics: http://uf-ias-2012.wikispaces.com/file/view/IAS%20-%20MEANING%20EXPLANATION%20DISCUSSION/390300226/IAS%20-%20MEANING%20EXPLANATION%20DISCUSSION
20:32:04 <augur> jonsterling: that might be true, but there's a big difference between the two perspectives. the whole point of ML's approach is to eliminate the idea that meaning is anything other than inferential in nature
20:32:18 <jonsterling> I don't see how this conflicts with that.
20:32:41 <augur> they dont conflict, they're just different approaches to what meaning is
20:33:05 <jonsterling> augur: Can you elaborate how they're different?
20:33:17 <jonsterling> (Or is it just the premathematical vs metamathematical bit)
20:33:30 <augur> well, how can be not different? "meaning = rules of use" vs "meaning = denotations"
20:33:35 <augur> theres areas different as it gets
20:34:11 <augur> furthermore, MLTT takes meaning as being ascribed to judgments, not to anything else
20:34:30 <jonsterling> Right, but how are the PER semantics not "meanings = rules of use"?
20:34:58 <augur> because a PER is not a rule of use? PERs dont tell you anything about rules of use
20:35:11 <augur> i mean, how are they?
20:35:15 <stephenmac7> Why can't I use fmap with IO?
20:35:20 <augur> stephenmac7: you can
20:35:32 <stephenmac7> fmap putStrLn getLine
20:35:36 <stephenmac7> Doesn't seem to work
20:35:39 <augur> stephenmac7: ofcourse not
20:35:44 <augur> stephenmac7: the types dont line up
20:36:01 <augur> :t putStrLn
20:36:01 <lambdabot> String -> IO ()
20:36:06 <augur> :t getLine
20:36:07 <lambdabot> IO String
20:36:11 <augur> :t fmap
20:36:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:36:38 <augur> :t fmap putStrLn getLine
20:36:38 <lambdabot> IO (IO ())
20:36:44 <stephenmac7> Ah.
20:36:53 <augur> oh, well, there you go, the types do line up, but not as you expected probably
20:37:06 <stephenmac7> That must be why I didn't get an error
20:37:25 <augur> jonsterling: i mean, if PERs ~ rules of use, it ought to be easy enough to explain how this is true
20:37:29 <stephenmac7> augur: Guess I'm stuck with getLine >>= putStrLn
20:37:35 <jonsterling> augur: Perhaps you could direct me to a precise definition of "rules of use"—the foggy one I have in my head seems to not be problematic for PER semantics.
20:37:54 <augur> jonsterling: http://www.csie.ntu.edu.tw/~b94087/ITT.pdf demonstrates what is meant
20:38:16 <jonsterling> augur: A C-F for "Rules of Use" turns up nothing...
20:38:18 <augur> jonsterling: consider
20:38:29 <augur>    (1) a set A is defined by prescribing how a canonical element of A is formed as well as how two equal canonical elements of A are formed.
20:38:32 <augur> This is the explanation of the meaning of a judgement of the form A is a set.
20:38:39 <augur> those last two are quoted
20:40:50 <augur> later he talks about meanings of connectives too, of course
20:42:01 <stephenmac7> augur: So, I guess this would be a correct use of the functor instance of IO: let n = return "55" in fmap ((++) "Test") n
20:42:57 <augur> jonsterling: the point is, really, that meaning is understood as _precisely_ a collection of inference rules of a certain sort
20:43:19 <jonsterling> augur: In the PER semantics for NuPRL, this is indeed accomplished. However, instead of inductively giving how to form a canonical element of A and when those are equal, it is gone about slightly differently. Untyped terms are reduced by primitive computation to "canonical" (but still untyped terms). Then the PER semantics describes when two canonical
20:43:19 <jonsterling> untyped terms are equal in a type A.
20:43:20 <augur> thats what i mean by rules of use -- inference rules oriented towards judgements of various sorts
20:43:46 <augur> jonsterling: sure thats fine, but thats missing the point entirely
20:44:12 <jonsterling> The PER semantics indeed give *precisely* a collection of inference rules to show how to construct a canonical element of A and when two are equal. I'm afraid I simply don
20:44:16 <jonsterling> *don't see your point.
20:44:37 <augur> jonsterling: i think you're conflating a bunch of things
20:45:01 <jonsterling> augur: Hmm, like what?
20:45:22 <augur> a collection of inference rules are syntactic objects in a formal system. PER semantics does not say that the meaning of, say, `Top` is just a collection of inference rules, namely Top-F Top-I, Top-= etc
20:46:10 <augur> PER semantics assigns to `Top` a particular relational structure in a particular kind of model/denotation
20:46:18 <augur> but there are no models/denotations in MLTT
20:46:21 <augur> there is just inference rules
20:49:37 <jonsterling> augur: Right. You can indeed say that to translate the syntax given by meaning explanations into a model is not worth doing—since MLTT is self-contained and doesn't need any semantics beyond the standard ones. However, you must see that semantics like PERs and realizability are very much in the spirit of the meaning explanations, and yet they are
20:49:37 <jonsterling> metamathematical. If you don't like metamathematics, then you don't like metamathematics: but these exist very clearly in parallel to the meaning explanations.
20:50:02 <augur> they're not even _remotely_ like meaning explanations
20:50:16 <augur> they're the exact opposite of meaning explanations!
20:51:56 <augur> the meaning of |N is a set contains precisely four things. "0 : |N", "a : |N => a' : |N", "0 = 0 : |N", and "a = b : |N => a' = b' : |N"
20:52:17 <augur> that is to say, the meaning of "|N is a set"
20:53:18 <augur> its a purely formal, syntactic notion that cannot be equated to PERs in any obvious way, because these rules themselves are dependent on a background system which _uses_ them
20:53:38 <augur> PER semantics has no conception of "use" of a rule, or even of "a rule"
20:53:50 <jonsterling> augur: I think, if you haven't already, you might find it useful to read the link I sent you.
20:54:32 <augur> im not going to argue with people who aren't here to argue back. im making a point to _you_, not people from the past
20:54:34 <jonsterling> augur: PER semantics inductively describes a family of **judgments** for the inhabitation and equality of types. That is quite literally all.
20:55:29 <augur> jonsterling: perhaps we're thinking of different things when we say "PER semantics"
20:55:40 <jonsterling> augur: That would seem to be the most likely explanation.
20:56:00 <augur> jonsterling: can you point me to a canonical reference for your understanding of the phrase?
20:59:07 <jonsterling> augur: Can't find the canonical one right away, but here's a very (very) short exposition of what it means in the context of NuPRL: http://www.nuprl.org/documents/Anand/ATypeTheoryWithPartialEquivalenceRelationsAsTypes.pdf
20:59:34 <jonsterling> augur: I have to go make dinner though. Feel free to email me if you have any comments or questions, or think of something to convince me
21:00:38 <augur> jonsterling: immediately that pdf shows why MLTT's meaning explanations are not the same as PER semantics
21:10:47 <AfC> Hm. This ring any bells? Compiler is telling me ""Can't make a derived instance of `Generic Blah" "You need -XDeriveGeneric to derive..." which is weird, since I have {-# LANGUAGE DerviveGeneric #-} enabled.
21:11:04 <glguy> afc: misspelled
21:11:11 <glguy> Dervive?
21:12:01 <AfC> glguy: mistyped here. It's correct in source.
21:12:24 <c_wraith> AfC: did you misspell LANGUAGE?  I did that recently, and it took me a while to find.
21:12:41 <AfC> c_wraith: holy moses
21:12:51 <AfC> c_wraith: yes I did. Wow. You can do that?
21:13:02 <carter> what was the typo?
21:13:13 <c_wraith> in my case, it was LANGAUGE
21:13:17 <AfC> carter: LANGAUGE
21:13:19 <AfC> yeah
21:13:28 <carter> :)
21:13:29 <c_wraith> GHC apparently just ignores LANGAUGE pragmas. :)
21:13:33 <carter> haahahah
21:13:35 <AfC> heh
21:13:48 <carter> oh yeah, its a backwards compat thing, ignoring bad pragmas
21:13:52 <AfC> Jeez. You'd think it'd error out if it gets a pragma it doesn't understand.
21:14:44 <AfC> Well. Back to work. c_wraith, you score a beer. And glguy gets an honourary beer for having the right idea on the wrong token.
21:15:00 <AfC> And carter doesn't get any beer.
21:15:17 <carter> AfC: warnign woudl beo ok
21:15:55 <AfC> carter: Ah, you've been reading texts on redundancy in information theory again, haven't you? :)
21:16:10 <carter> :)
21:16:28 <carter> more like why i don't care if i typo on irc
21:17:00 <carter> AfC: in the middle of writing a generic Pair of Vectors Vector type for any base Vector type instances
21:24:34 <EvanR> drawing combinators is cool, wonder if theres something with a little more control over the pixels though
21:24:47 <zq_> what the heck
21:24:59 <zq_> since when are typeclasses declared with "typeclass" and not "class"?
21:25:07 <EvanR> kind of tricky to get a clean line after all the affine transformations
21:25:12 <copumpkin> zq_: where you seeing that?
21:25:17 <zq_> copumpkin: http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html#%2824%29
21:25:39 <copumpkin> zq_: probably someone misremembering?
21:25:52 <thoughtpolice> it's almost certainly a typo
21:26:13 <zq_> cool, haven't gone mad yet
21:26:33 <lispy> carter: if it makes you feel any better, cabal has a similar 'sometimes uses the wrong C compiler' issue as your proposed ghc changes would allow: https://github.com/haskell/cabal/issues/1858
21:27:00 <carter> lispy: ... just setting pgmP would do the same thing
21:28:43 <lispy> carter: Subtely all the way down.
21:28:50 <carter> yeah
21:28:52 <lispy> (instead of turtles)
21:28:56 <carter> well
21:29:06 <carter> if you have any suggestions on refining my patch i'm all ears
21:39:12 <zq_> hm
21:39:27 <zq_> how would i go about getting the core dump of library functions?
21:39:34 <zq_> say, seq or const
21:45:55 <lispy> zq_: const is defined here: http://git.haskell.org/packages/base.git/blob/HEAD:/GHC/Base.lhs#l552
21:46:17 <lispy> zq_: you could try to find that in the ghc build system and add the flags
21:46:44 <lispy> zq_: seq might be a builtin
21:47:59 <zq_> lispy: actually, it unfolds into a core case expression
21:48:06 <zq_> but i still would like to see
21:51:18 <lispy> zq_: https://github.com/ghc/ghc/blob/master/compiler/prelude/PrelRules.lhs#L896
21:57:12 <augur> jonsterling: lemme know when you're back, ey?
22:00:56 <carter> lispy: the hybride clang + GCC setup isnt the default for my build, its just my personal setup
22:19:13 <sveit> how do you have a parser in attoparsec fail instead of returning "Nothing"? i.e. I currently have a parser with type "Parser (Maybe UTCTime)", but I want "Parser UTCTime"
22:19:43 <sveit> so that if whatever i am parsing is not a time, it will fail properly with respect to <|>
22:20:32 <copumpkin> how did you get the Maybe there in the first place?
22:22:10 <sveit> copumpkin: i am using parseTime, which takes a string and returns Maybe UTCTime
22:22:16 <sveit> so i lift it into the Parser context
22:22:43 <copumpkin> you could feed that Maybe back into the parser
22:23:00 <copumpkin> case thatMaybe of None -> fail "didn't parse"; Some x -> return x
22:23:06 <copumpkin> or use maybe
22:23:07 <copumpkin> :t maybe
22:23:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:23:21 <copumpkin> :t maybe (fail "onoes") return
22:23:22 <lambdabot> Monad m => Maybe a -> m a
22:23:39 <copumpkin> with a parser, "fail", hated as it is, will do what you want
22:26:52 <Shockk> I'm trying to do something and I can't for the life of me figure out how to, and wondered if anyone here could help me,
22:27:07 <Shockk> I've got a type: type InputCB = Ptr () -> GuiBufferPtr -> String -> IO RC
22:27:41 <Shockk> and I have a type in the same module scope, API.InputCB, which is the same except the String is a CString in it
22:28:23 <Shockk> and I want to write a function: wrapInputCB :: InputCB -> API.InputCB
22:28:34 <Shockk> I can't figure out how to do this though
22:29:01 <lispy> carter: I figured. I'm not trying to tear it apart or anything. I just want to make sure I understand it and the ramifications.
22:29:03 <enthropy> @hoogle peekCString
22:29:04 <lambdabot> Foreign.C.String peekCString :: CString -> IO String
22:29:04 <lambdabot> Foreign.C.String peekCStringLen :: CStringLen -> IO String
22:29:28 <carter> lispy: you're right that it allows for extra generality
22:29:41 <Shockk> enthropy: I've got the function, newCString, but I can't figure out how to take an InputCB and return something with newCString applied to the string
22:29:54 <carter> and i kinda view that as an opporunity to fuzz/ stress test a lot of corners  / baked in assumptions we've had in ghc / haskell codes
22:30:43 <carter> i agree some combos wont work
22:30:56 <enthropy> Shockk: consider "wrap :: InputCB -> API.InputCB", is the same type as "wrap :: InputCB ->  Ptr () -> GuiBufferPtr -> CString -> IO RC"
22:31:56 <carter> but i also like that it be comes possible to mor easily find those weird combos
22:32:06 <enthropy>  wrap f a b cstring = f a b =<< peekCString cstring
22:32:44 <enthropy> or maybe you're right and you need newCString (though a function like withCString would be better)
22:32:49 <Shockk> hmm
22:33:09 <Shockk> ah, I can't use withCString because I need it not to be freed after the call
22:33:51 <enthropy> so really you are looking to write  wrapInputCB :: API.InputCB -> InputCB?
22:34:08 * Shockk shakes head
22:34:45 <Shockk> I want to pass it a callback function I've written, and... hang on while I get my head around that
22:35:23 <Shockk> wait, you're right
22:35:56 <Shockk> I'm thinking of this from the wrong side, I don't know why but I was treating the callback as if it's something which is creating the CString, rather than receiving it
22:38:12 <Shockk> thanks enthropy
22:39:08 <Javran> I have a question regarding parsec, is `try p <|> try q` the same as `try (p <|> q)`?
22:39:48 <sveit> copumpkin: i have tried to do this, but it seems the types don't work out
22:39:55 <sveit> my Maybe is on the inside of the Parser
22:40:00 <Javran> I think I was wrong..
22:40:00 <johnw> Javran: no
22:40:01 <sveit> so Parser (Maybe UTCTime)
22:40:07 <copumpkin> sveit: sure
22:40:13 <Total_1mmersion> Javran, I don't think so. try (p <|> q) could fail to match p, and not attempt to match q.
22:40:16 <johnw> Javran: in try (p <|> q), p can consume tokens that would cause q to fail, where it wouldn't fail in the first case
22:40:24 <copumpkin> sveit: yourParserMaybeUTCTime >>= maybe (fail "whoops") return
22:40:50 <copumpkin> :t (>>= maybe (fail "whoops") return)
22:40:51 <lambdabot> Monad m => m (Maybe b) -> m b
22:40:59 <Javran> I see, thanks all of you :)
22:42:16 <sveit> copumpkin: oh that's what I ended up doing. is there a way to do this in the applicative style?
22:42:22 <sveit> I suspect no, since i depend on the value of my output
22:42:28 <copumpkin> sveit: no
22:42:56 <copumpkin> alas :)
22:59:01 <lispy> copumpkin: I wouldn't use maybe in fix, but I do like how it reads in this case: (fail "whoops") `maybe` return
23:09:32 * hackagebot wai-routes 0.5.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.5.1 (AnupamJain)
23:11:33 <l0cust> what's up
23:12:24 <lispy> l0cust: a command line tool to generate paths for moving up in the filesystem (according to hackage) :)
23:13:40 <l0cust> what does "moving up in the filesystem" mean?
23:14:35 <lispy> l0cust: I guess they mean cd ..
23:14:42 <l0cust> haha
23:14:43 <lispy> I don't know why someone would need a command for that
23:14:46 <Cale> It means tying thousands of ballons to your home, according to imdb.
23:14:47 <l0cust> you need a library to do that?
23:15:14 <lispy> https://hackage.haskell.org/package/up-0.1.0.1/src/Up.hs
23:15:53 <lispy> I guess if you need to go ../../../../../ it might be easier to say up 5
23:16:02 <lispy> cd $(up 5)
23:17:23 <startling> cd /
23:18:11 <shachaf> That's why it takes a conatural as an argument.
23:20:15 <pyon> A conatural is "data CoNat = T (CoNat -> Maybe CoNat)" right?
23:22:07 <shachaf> Is it?
23:22:12 <shachaf> Where did that type come from?
23:23:17 <pyon> no, wait, I screwed up
23:23:35 <pyon> I was thinking of "data Nat where { Z :: () -> Nat ; S :: Nat -> Nat }"
23:23:59 <pyon> But I did not quite get the arrow-flipping right.
23:25:25 <pyon> It should be more like "data CoNat = T { coZ :: (), coS :: CoNat }"
23:27:34 <triliyn> Disregarding bottoms, isn't that type inhabited solely by something like an infinite list of ()?
23:32:07 <pyon> triliyn: I think it is kinda like "CoFree Identity ()".
23:44:57 <shachaf> pyon: A conatural is data Conat = Z | S Conat
23:45:10 <shachaf> Where you allow the infinite value S (S (S (S ...
23:45:37 <shachaf> It's the greatest fixed point of Maybe.
23:45:38 <shachaf> A natural is the same thing where you don't allow that value.
23:45:55 <pyon> shachaf: Why would it be a sum, instead of a product?
23:46:11 <shachaf> Why would it be a product, instead of a sum?
23:49:24 <pyon> shachaf: So that CoNat's eliminators ("coZ :: CoNat -> ()" and "coS :: CoNat -> CoNat") are dual to Nat's constructors ("Z :: () -> Nat" and "S :: Nat -> Nat")... or so I thought.
23:50:20 <shachaf> As far as I know it's called "co" because it's the greatest rather than the least fixed point.
23:50:36 <pyon> Ah!
23:54:37 * hackagebot semigroups 0.14 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.14 (EdwardKmett)
23:55:14 <jle`> anyone know that recent article about the different ways to idiomatically handle errors in haskell?
23:56:14 <johnw> how recent?
23:56:43 <johnw> do you mean http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/?
