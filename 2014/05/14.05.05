00:09:09 * hackagebot pandoc-citeproc 0.3.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.3.1 (JohnMacFarlane)
00:09:09 * hackagebot directory-layout 0.6.0.0 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.6.0.0 (MatveyAksenov)
00:10:56 <AfC> johnw: touch (an empty file) there first?
00:11:27 <johnw> i just set HOME=$PWD
00:14:33 <cbarrett> and nothing breaks when you do that? impressive
00:14:39 <johnw> no, it worked
00:15:25 <AfC> I suppose that's one way to do sandboxes
00:15:35 <AfC> (eeek)
00:42:51 <jle`> @tell dmj` you should really find some way to be persistently on :)
00:42:51 <lambdabot> Consider it noted.
00:43:20 <jle`> i wonder if there is some trig library
00:43:27 <jle`> hm.
00:43:31 <jle`> or a fourier transform library
00:43:51 <jle`> that represents functions by sums of sinusoidal functions parameterized by amplitude and period
00:44:12 <jle`> and phrase
00:44:14 <jle`> phase
00:58:09 <makalu> I have a database column type "Column a" where a is the type of values in the column. The table type should have a list of columns. How should I represent it? I know people don't like heterogeneous lists but I don't know of a better way.
00:58:36 <makalu> s/the table type/the table constructor
00:59:53 <Iceland_jack> Simplest way is
00:59:53 <Iceland_jack>     data Column = ValI Int | ValS String ...
00:59:53 <Iceland_jack>     data Table  = Table [Column]
01:00:10 <Iceland_jack> I assume you don't intend to have the 'a' appear in the Table type
01:00:46 <enthropy> or you can write one data type per table you expect to see
01:01:21 <enthropy> data Table3 a b c d = Table3 (Column a) (Column b) (Column c) (Column d)
01:03:37 <makalu> there's no constraints on what type and number of columns the tables have
01:04:02 <Iceland_jack> You can also do
01:04:02 <Iceland_jack>     type a + b = Either a b
01:04:02 <Iceland_jack> and then define each table as
01:04:05 <Iceland_jack>     type SomeTable = Column ID + Column Name + Column Age + Column Salary
01:04:23 <freeman42> hey, what is the best Haskell IDE? ( I will take first answer as the one true correct one ^^ )
01:04:28 <Iceland_jack> ed
01:04:33 <enthropy> Iceland_jack: that would be called a "heterogeneous list"
01:04:44 * freeman42 goes to install ed
01:04:58 <makalu> Iceland_jack: but let's say I want to read the column into Haskell. "read :: Column -> IO ??"
01:04:59 <enthropy> though I guess you're missing a Nil at the end
01:05:21 <makalu> sorry not "read" in the Read sense
01:05:54 <edwardk> now to start slogging through all the things that need to get fixed in the presence of transformers 0.4
01:05:58 <edwardk> freeman42: unmodified vim
01:06:04 <edwardk> Iceland_jack: I'm flattered that you think I'm the best Haskell editor, but I'm pretty hard to install.
01:06:11 <Iceland_jack> heh :)
01:06:55 <freeman42> edwardk, unmodified vim = vim terminal mode or vim non-terminal?
01:07:22 <nomeata> @djinn (a -> b) -> (b -> c) -> (a -> c)
01:07:22 <lambdabot> f a b c = b (a c)
01:09:10 * hackagebot linux-kmod 0.1.0.1 - Linux kernel modules support  http://hackage.haskell.org/package/linux-kmod-0.1.0.1 (NicolaSquartini)
01:09:36 <makalu> I think I'll go with heterogeneous lists
01:14:26 <matematikaadit> freeman42, emacs?
01:15:40 <zacts> freeman42: you may want to also try emacs' evil-mode
01:15:49 <zacts> that's what I'm currently using
01:16:02 <zacts> but I would say it's more of a personal decision
01:17:43 <freeman42> Iceland_jack, edwardk, matematikaadit, zacts: looking for a Haskell IDE / plugin that can do at least find references, go to definition and refactor rename
01:18:30 <matematikaadit> freeman42, well, using emacs could do that.
01:19:12 <matematikaadit> *you
01:19:12 <freeman42> thanks, I will give it a try, was trying to test HaRe Vim plugin but it seems to be very outdated
01:20:55 <edwardk> freeman42: i just use vim in a terminal
01:21:18 <edwardk> freeman42: to find references i use hasktags
01:21:20 <edofic> edwardk, any plugins specific to haskell?
01:21:39 <edwardk> for refactor/renaming I don't have anything. I'm just relatively quick with regular expressions
01:22:08 <freeman42> I think too many people watched The Matrix, and think using a terminal is cool cause of that :)
01:22:09 <edwardk> edofic: i have a key bound to running hasktags, and a syntax highlighting file i grabbed from somewhere. that's about it
01:22:36 <edwardk> freeman42: i think it is more that some of us have been using terminals for a very very long time ;)
01:22:52 <freeman42> yeah, good point :)
01:23:25 <freeman42> but... it's like that joke from Seinfeld: I don't understand chinese people, how they can eat with those sticks after seeing THE FORK, cmom people...
01:24:54 <edofic> actually for some types of food sticks are much better. non chinese person here
01:25:17 <freeman42> well, ofc, who said they are not?
01:27:23 <bartavelle> freeman42, edwardk, the matrix was out 15 years ago, so it might be both
01:27:52 <jle`> i remeber when i first started using linux
01:27:57 <jle`> i had my terminal be green on black
01:28:08 <jle`> i thought it was the only legitimate way to use a terminal
01:28:31 <Iceland_jack> jle`: it isn't?
01:28:52 <Iceland_jack> cmatrix~
01:28:56 <jle`> no, this is
01:28:58 <jle`> https://github.com/hyperlogic/riftty
01:29:28 <Iceland_jack> dear lord
01:29:33 <cdrlx> Hey guys, I want to know your opinion about functional programming. How did it made you better programmers than before learning it?
01:29:56 <Iceland_jack> cdrlx: Maybe it made us worse ;)
01:30:27 <jle`> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
01:30:33 <cdrlx> How so, @Iceland_jack ?
01:30:52 <Iceland_jack> cdrlx: It didn't for me, but you shouldn't presuppose it
01:31:05 <freeman42> cdrlx, I have lost my faith in functional programming when I heard to many functional programmers don't use proper haskell IDE's / plugins :'(
01:31:15 <freeman42> *too many
01:31:36 <Iceland_jack> freeman42: What an odd thing to say
01:31:41 <sipa> i don't use IDE's for other languages either...
01:31:43 <jle`> actually this question is harder than i thought it would be
01:31:44 * freeman42 is partially kidding.
01:31:49 <edwardk> freeman42: look at it this way. there are folks who can maintain 50+ packages in the ecosystem without needing to lean on such a tool at all. ;)
01:32:12 <edwardk> freeman42: that may tell you something about how much more effective functional programming is at organizing your namespace/thinking
01:32:34 <freeman42> edwardk, I would not call that a smart decision ^^
01:32:52 <edwardk> in OOP every object is its own namespace. You need to know how to find the meaning of each verb in a context sensitive way.
01:33:05 <freeman42> imagine how much that person might achieve if it would let the IDE / plugin do its thing and that programmer would actually use his brain to do stuff
01:33:17 <freeman42> instead of wasting time to find references manually and stuff
01:33:20 <Iceland_jack> freeman42: You're used to languages like Java and C++ right?
01:33:26 <edwardk> In Haskell you deal with far fewer contexts. Classes are shared, names are punned less often and if they are they are punned for the same purpose with the same API in general.
01:33:29 <cdrlx> I asked because some part of me is interested in functional programming, I read some articles about the benefits of functional programming and I wanted to confirm if it made you become better programmers.
01:33:31 <Iceland_jack> Programming in Haskell makes things like mutability and state more explicit, and makes you structure your code into pure and effectful parts
01:33:31 <freeman42> defer as much as possible to the machine
01:33:36 <jle`> cdrlx: i think for me fp helped me learn how to really reason about programs
01:33:53 <jle`> hm.
01:34:02 <freeman42> cdrlx, it will certainly make you a better programmer :)
01:34:03 <edwardk> freeman42: i routinely go off on multi-day refactorings when no machine is going to be able to point me to an unbroken chunk of code
01:34:06 <sipa> it makes you think about data flow as some independent from control flow
01:34:12 <jle`> ^^
01:34:23 <edwardk> freeman42: i'd rather not optimize for small changes and make big ones intractable ;)
01:34:25 <sipa> *something
01:34:32 <freeman42> Iceland_jack, that does not matter when you need to understand a new codebase and you don't have go to definition or find references...
01:34:51 <edwardk> freeman42: hasktags gives you that
01:35:02 <edwardk> freeman42: we just don't have good refactoring browsers
01:35:21 <edwardk> codex will even give you cross project tags files
01:35:28 <cdrlx> @jle` That's interesting, one of my goals in programming is to explain my programs in my own way...
01:35:28 <lambdabot>  Parse failed: Parse error: of
01:35:31 <freeman42> yes, I am only speaking about people who don't choose to use things like that, or rather... why hashtags? that should be automatically be dealt by the IDE in a language service
01:35:38 <edwardk> aloiscochard made a rather nice tol there
01:36:01 <olydis> @djinn a -> a
01:36:01 <lambdabot> f a = a
01:36:31 <olydis> @djinn (a -> a) -> a
01:36:31 <lambdabot> -- f cannot be realized.
01:36:39 <edwardk> freeman42: there is an eclipse plugin for haskell, fpcomplete has a whole web-based toolchain for doing haskell development, we used to have visual haskell, there is leksah...
01:36:40 <Iceland_jack> cdrlx: I suggest you spend your time learning Haskell rather than convincing yourself that it will definitely make you a better programmer :)
01:36:43 <bartavelle> freeman42, I do use an IDE when I have to edit java code, but that's mostly because I have to jump all over the place all the time. This is not comparable with Haskell, where I usually can get away with having 3 files open at a given time
01:36:44 <freeman42> edwardk, eh? "freeman42: i'd rather not optimize for small changes and make big ones intractable ;)"
01:37:08 <bartavelle> but I agree that having "integrated haddocks" would be nice
01:37:12 <edwardk> freeman42: i don't find any of them is compelling enough to make me give up the ability to set up from scratch or pair program with anyone on their computer
01:37:24 <olydis> @djinn (b -> a) -> a
01:37:24 <lambdabot> -- f cannot be realized.
01:37:34 <olydis> @djinn (b -> a) -> b -> a
01:37:34 <lambdabot> f a = a
01:37:43 <cdrlx> @Iceland_jack, I will, I needed some sentences that will motivate me in learning fp.
01:37:43 <lambdabot> Unknown command, try @list
01:37:44 <jle`> cdrlx: i think i do try to look at my programs from a higher level after learning haskell
01:37:54 <jle`> but
01:37:54 <edwardk> freeman42: i routinely work in large codebases that aren't in a working state while i refactor/redesign is what i'm talking about. most of the time heavily integrated IDEs basically offer me no support
01:37:55 <Iceland_jack> cdrlx: omg it's so awesome, you should totes learn it
01:37:56 <Iceland_jack> :)
01:37:57 <jle`> that's such a vague thing to say
01:38:05 <jle`> and wholly meaningless
01:38:11 <jle`> without quantification
01:38:15 <jle`> (referring to what i said earlier)
01:38:22 <olydis> @djinn a -> a -> a
01:38:22 <lambdabot> f _ a = a
01:38:32 <olydis> @djinn a -> (a -> a) -> a
01:38:32 <lambdabot> f a b = b a
01:38:33 <edwardk> bartavelle: integrated haddocks is one thing where the fpcomplete toolbox works nicely
01:38:35 <cdrlx> I'll come back here after my first lesson. :D
01:38:42 <sipa> olydis: you can PM lambdabot
01:38:54 <Iceland_jack> Everyone in #haskell will tell you to learn Haskell ;) if you're interested then learn, if not then don't
01:39:04 <Iceland_jack> cdrlx: Check out Learn You a Haskell, that's a good start
01:39:06 <Iceland_jack> @where lyah
01:39:07 <lambdabot> http://www.learnyouahaskell.com/
01:39:42 <cdrlx> What a coincidence, that's the one I am going to read :)
01:40:10 <edofic> Then just start reading :) totally worth it.
01:40:27 <bartavelle> cdrlx, if you already have a background with several other languages, just be prepared to spend a little more time with this one, as it is really different
01:40:42 * Iceland_jack . o O ( I didn't want to say it before but learning Haskell will actually raise your IQ by 20 and make you better looking )
01:40:54 <sipa> damn
01:41:01 <freeman42> cdrlx, asking here if you should go with Haskell is like going to a church and asking if you should believe in god :)
01:41:05 <sipa> i learnt haskell without lyah :(
01:41:47 <Iceland_jack> freeman42: “Father, which religion is the right one? There are so many.” -- “This one.” -- “Oh great!”
01:42:20 <freeman42> so lucky I got it right ^^
01:42:22 <enthropy> is this benchmarking code reasonable: http://code.haskell.org/~aavogt/HList-benchmark/a.html#criterion-code ?
01:42:23 <bartavelle> freeman42, the other religions do not give you superpowers
01:42:28 <cdrlx> freeman42: I wasn't asking if I should choose haskell, that's bad to ask here. I was asking the benefits of fp.
01:42:42 <cdrlx> bfn.
01:42:51 <sipa> cdrlx: it's a different perspective
01:43:14 <sipa> cdrlx: which is useful, even when you're not actually programming in a functional language
01:43:34 <sipa> and perhaps even when you're programming in a functional way
01:43:41 <sipa> *not
01:44:10 <edofic> in other words: haskell makes you think
01:45:09 <freeman42> cdrlx, for me it translated in "should I learn fp?" which automatically went to the extreme instance which is Haskell
01:46:02 <edofic> i used scala as gateway drug. since it's less radical but still makes you learn stuff
01:46:11 <exicer_> What does "import qualified Data.Text" do? I thought you had to put "as Something" at the end ?
01:46:33 <edofic> no. tthis just means you always have to refer to it as Data.Text
01:46:57 <freeman42> edofic, I use scala also and it has a lot of cool tool support
01:46:57 <edofic> "as Something" is optional to make your life easier by less typing
01:46:59 <exicer_> Ah, good to know
01:47:02 <exicer_> cheers
01:47:11 <freeman42> now I am struggling to find the same level of tool support in Haskel IDE's / plugins
01:47:36 <Iceland_jack> freeman42: How much Haskelling have you done?
01:47:40 <Iceland_jack> out of curiosity
01:47:53 <edofic> freeman42, i'm using sbt and intellij for scala, but i find a simple text editor enough for haskell
01:48:18 <edofic> that and ghci of course
01:48:32 <freeman42> Iceland_jack, until now I have written 0 lines of haskell... no wait, I am lieing, I wrote 1 line today for a hello world, and another line some months ago, also in a hello world :p
01:48:37 <Iceland_jack> yes GHCi is vital for programming
01:48:48 <freeman42> but I am reading my 2nd haskell book now :)
01:49:09 <edofic> less reading more practice. you will learn much faster
01:49:18 <Iceland_jack> freeman42: I suggest you don't get stuck on that now, going through an entire book without a single line of code^W^W^W^Wtwo linses of code is not a good way
01:49:31 <Iceland_jack> Pick up the simplest text editor and a terminal
01:49:34 <freeman42> Intellij IDEA + Scala plugin works great, it is probably availalbe in the Community Edition of IDEA also
01:50:16 <cdrlx> I am back for now, I encountered something new: `5 \= 5`. What does `\=` mean?
01:50:19 <freeman42> Iceland_jack, yeah, I totally agree with what you said, ehm, except the simple text editor part
01:50:21 <edofic> freeman42, scala plugin is available but not PlayFramework plugin
01:50:22 <Iceland_jack> cdrlx: !=
01:50:29 <Iceland_jack> freeman42: Start simple
01:50:38 <Iceland_jack> cdrlx: inequality
01:50:39 <Iceland_jack> > 5 != 5
01:50:41 <lambdabot>  Not in scope: ‘!=’
01:50:41 <lambdabot>  Perhaps you meant one of these:
01:50:41 <lambdabot>    ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
01:50:41 <lambdabot>    ‘IM.!’ (imported from Data.IntMap)
01:50:43 <Iceland_jack> oops
01:50:44 <freeman42> Iceland_jack, I am trying to do some work on snowdrift, someone from that project said I could help
01:50:46 <Iceland_jack> > 5 /= 5
01:50:47 <lambdabot>  False
01:50:49 <cdrlx> Thanks, Iceland_jack.
01:50:56 <jle`> what is \= tho
01:51:01 <jle`> :t (\=)
01:51:01 <lambdabot>     Not in scope: ‘\=’
01:51:02 <lambdabot>     Perhaps you meant one of these:
01:51:02 <lambdabot>       ‘/=’ (imported from Data.Eq), ‘<=’ (imported from Data.Ord),
01:51:21 <Iceland_jack> I'm guessing it was (/=)
01:51:40 <jle`> you are smarter than lambdabot
01:51:51 <Iceland_jack> cdrlx: analogous how you'd write it in math ≠ if it helps you remember
01:52:28 <sipa> freeman42: it's not like you need an IDE to write simole example prpgrams, right?
01:52:48 <sipa> freeman42: the onky way you'll learn a language is by using it
01:52:57 <Iceland_jack> sipa++
01:52:59 <freeman42> sipa, but why waste time and not learn the IDE / plugin also from the start?
01:53:18 <Iceland_jack> freeman42: Wasting time is what you're doing when you go through an entire book without coding, imho
01:53:32 <sipa> Iceland_jack++
01:53:33 <freeman42> yeah, I agree ^^
01:53:59 <freeman42> I will have to reread them, but I caught some ideas... I hope
01:54:14 <Iceland_jack> Hell, start out with lambdabot :) it's better than nothing
01:54:21 <Iceland_jack> > map toUpper "Hello, World!"
01:54:23 <lambdabot>  "HELLO, WORLD!"
01:54:52 <sipa> if you're learning a language through an IDE, i think you pay less attention to the code itself and why things are written the way they are
01:55:12 <sipa> an IDE is a productivit tool for dealing with engineering problems in larger code bases
01:55:22 <sipa> i don't think it helps you learn the language
01:55:24 <freeman42> > map toLower "ABC"
01:55:26 <lambdabot>  can't find file: L.hs
01:55:38 <sipa> but i'm biased; i never used an IDE except for java
01:55:38 <jle`> try again
01:55:43 <jle`> > map toLower "ABC"
01:55:44 <lambdabot>  "abc"
01:55:55 <freeman42> > map toLower "ABC"
01:55:56 <lambdabot>  "abc"
01:56:21 <Iceland_jack> > [ toLower ch | ch <- "ABC" ]
01:56:22 <lambdabot>  "abc"
01:56:24 <freeman42> somehow it does not bring too much satisfaction :) but it is cool nonetherless
01:57:31 <freeman42> sipa, imo the IDE helps me not have to remember a lot of useless things (as long as I have an IDE), like method names and stuff
01:57:40 <freeman42> or in which module / namespace something is found
01:57:54 <sipa> freeman42: agree, to an extent
01:57:55 <cdrlx> I am back from my first lesson. Haskell is really explicit.
01:57:59 <Iceland_jack> in any case you generally have to write a lot less boring stuff in Haskell
01:58:23 <Iceland_jack> I probably wouldn't write any Java or C♯ without an IDE
01:58:37 <Iceland_jack> cdrlx: Welcome back!
01:58:37 <sipa> freeman42: just not sure whether that's worth it
01:58:49 <freeman42> I like LINQ from C# a lot, and that should be pretty close to how Haskell code might look like
01:59:38 <sipa> freeman42: when in rome, do as the romans do :)
01:59:40 <freeman42> sipa, imo it is best to let the machine do as much of the thinking as possible, and then the programmer can focus more brain power on the real problems
02:00:10 <freeman42> if I don't have to remember in which module some function is or how exactly it is called... the better
02:00:12 <cdrlx> Haskell is interesting. It considers operators as functions and the way that functions are called without parenthesis.
02:00:12 <Iceland_jack> freeman42: Yes you've said that, and all the Haskellers here have told you that it's secondary for beginner projects
02:00:35 <sipa> freeman42: or perhaps the language should try to not let the programmer deal with the boring parts at all
02:00:55 <freeman42> that is not possible :)
02:00:56 <cdrlx> Iceland_jack : Do Haskell programmers call themselves Haskellers?
02:00:56 <sipa> freeman42: yes, there are some built in function names to remember, and your own code structure
02:01:08 <Iceland_jack> cdrlx: Or Haskellites!
02:01:14 <sipa> freeman42: but you rarely have to gontrace things through dozens of layers
02:01:28 <freeman42> how could code tell you where it is found? or autocomplete itself?
02:01:29 <cdrlx> Iceland_jack : Does that depend on gender?
02:01:42 <Iceland_jack> cdrlx: Haskell is invariant under gender :)
02:01:45 <sipa> freeman42: not saying you're wrong, just that the benefit is maybe less than what you would expect
02:01:58 <freeman42> cdrlx, I like repeating things when I am not given convincing enough arguments, just in case better arguments are shows :)
02:02:08 <sipa> freeman42: learn haskell for now, and learn an ide when the necessity is there
02:02:13 <Iceland_jack> I dunno, I don't think there is any single demonym
02:02:31 <Iceland_jack> > take 3 "hello world"
02:02:32 <lambdabot>  "hel"
02:03:01 <sipa> freeman42: if not knowing or being able to use an IDE is a blocker for you learning haskell... then learn an IDE firsr, or don't learn haskell :)
02:03:09 <cdrlx> That's cool, freeman42
02:03:16 <freeman42> sipa, sorry, I will pass on that :) got no time to delay something that will be needed in the future anyway, and I could start learning now
02:03:34 <freeman42> sipa, learn both at the same time, that is best imo
02:03:41 <sipa> i think they're independent
02:03:54 <Iceland_jack> Unless the secondary thing blocks the main thing :)
02:04:00 <cdrlx> bfn.
02:04:28 <freeman42> Iceland_jack, yeah, you got a point with that ^^ but it will be worth it
02:04:30 <jle`> cdrlx: i call myself a haskelleur
02:04:35 <sjy> cdrlx: operators 'really' are functions anyway, the difference is only whether you can write them using infix notation, right?
02:04:36 <Iceland_jack> If you say so
02:04:36 <freeman42> just need to find that good IDE / plugin first
02:04:56 <freeman42> Iceland_jack, xD no need to be... dunno what the word is
02:05:19 <sipa> put otherwise: if they're not independent, it means you'll be at a disadvantage when you suddenly need to write code but wit a different IDE/editor than the one you're used to... compared to someone who never used one at all?
02:05:56 <freeman42> sipa, yes, that is true, but usually you are not forced to use a certain IDE
02:06:08 <cdrlx> Jle`: Can I call my self a Haskellist?
02:06:09 <Iceland_jack> freeman42: I'm not trying to be snarky or condescending, it sounds to me like you're putting off learning Haskell and are using this as an excuse
02:06:11 <sipa> if you want to use an IDE, go ahead, but it's an area that is very much in flux, and i think you lose time by making it a priority
02:06:24 <sipa> it's a tool you can use tok code faster once you know the lanfuage
02:06:24 <Iceland_jack> Which would be a shame :)
02:06:42 <Iceland_jack>     main = do
02:06:43 <Iceland_jack>       line <- getLine
02:06:43 <Iceland_jack>       putStrLn ("You entered: " ++ line)
02:06:45 <Iceland_jack> there, Haskell
02:07:21 <freeman42> Iceland_jack, no, lol xD (not being conscient of it anyway) but I do need a good IDE or else I will give up on learning Haskell, it is hard to learn an awesome language (so they say) but with bad IDE's
02:07:55 <sipa> i never gave up on learning perl, haskell, c, c++, python, ...
02:08:02 <sipa> and i never used any ide for those
02:08:08 <sipa> just never seemed worth it
02:08:12 <sjy> yeah, i've never heard "them" say that at all!
02:08:28 <freeman42> sipa, well, each with his own expectations
02:08:47 <sjy> the people I know who like IDEs like them because they like writing C# in VS, or java in IDEA/eclipse
02:09:08 <sjy> most polyglot programmers i know prefer not to use an IDE at all
02:09:45 <Okasu> freeman42: If you're not considering Emacs a good IDE for Haskell, then there is no good IDE for Haskell(at least still maintained).
02:09:52 <Iceland_jack> Emacs works fine for me working on huge Haskell codebases, you can then extend it as you go
02:10:11 <freeman42> Okasu, does it have find references?
02:10:17 <Iceland_jack> All the Haskell people I know use Emacs save for one vim user
02:10:18 <sjy> freeman42: yes, use ctags
02:10:21 <sipa> in opensourcd projects it is a burden, as jt means maintaining project files that remain in sync witht the codebase, while other contributors don't care about it
02:10:26 <Iceland_jack> and one who uses evil-mode
02:11:01 <freeman42> let's rephrase, does it have `find references` without having to manually regenerate some stuff before performing the command?
02:11:15 <sjy> Iceland_jack: are you talking about icelanders? i'm from australia and i've noticed that vim seems to be far more popular than emacs here (i've only ever met one emacs user who was a very old-school unix hacker), which seems to be unusual
02:11:28 <Iceland_jack> sjy: Actually international students in Sweden
02:11:50 <Iceland_jack> Haskell and Agda are both very Emacs centric around here
02:12:14 <Iceland_jack> in that it's almost impossible to use Agda without
02:12:17 <sjy> freeman42: i'm sure there is a plugin to achieve that; i use vim-easytags
02:13:08 <freeman42> sjy, do you use vim terminal or non-terminal? I am not even sure how to install vim in Ubuntu
02:13:52 <Iceland_jack> doesn't matter
02:14:02 <sipa> aptitude install vim
02:14:15 <sjy> terminal, and i'm horrified that ubuntu doesn't come with vim
02:14:33 <sipa> maybe it does; i never use vim :)
02:14:34 <freeman42> sipa, is gvim the command to start it?
02:14:45 <sipa> no clue
02:15:36 <sjy> gvim is GUI (non-terminal) vim
02:18:55 <sipa> freeman42: the time learning haskell will be spent on trying to understand the type system and some high level abstractions that are used
02:19:15 <sipa> freeman42: i doubt you'll waste much time on trying to find some function names
02:20:09 <cdrlx> Guys, I am getting an <interactive>:99:14: parse error on input '=' when I do: conan'OBrien = "It's a-me, Conan O'Brien!".
02:20:15 <cdrlx> What does that mean?
02:20:46 <sipa> > a'b = 5
02:20:47 <lambdabot>  <hint>:1:5: parse error on input ‘=’
02:20:53 <k00mi> cdrlx: use let
02:20:59 <k00mi> let conan'OBrien = "It's a-me, Conan O'Brien!"
02:21:20 <cdrlx> Thanks k00mi
02:21:55 <cdrlx> wait a minute...
02:22:19 <k00mi> cdrlx: that only works in do blocks (and ghci) though, elsewhere you have to do let a = 1 in someCode
02:23:55 <cdrlx> Oops, silly me. It was supposed to be a function. And it seems I can't make functions in the Haskell interpreter.
02:23:56 <_flatline_> can you nest guards?
02:25:29 <cdrlx> I love the way how functions are made straightforwardly.
02:25:50 <quchen> _flatline_: No.
02:27:21 <_flatline_> k
02:28:08 <DanielDiaz> cdrlx: You actually can define functions in GHCi, but they will go away in each reload. Try "let f x = x + 1".
02:29:19 * hackagebot network-msg 0.4 - Recvmsg and sendmsg bindings.  http://hackage.haskell.org/package/network-msg-0.4 (sickmind)
02:30:34 <cdrlx> Thanks DianielDiaz.
02:32:29 <freeman42> hm hmmm, might be interesting https://github.com/jetaggart/light-haskell
02:33:01 <freeman42> I installed haskell-mode into Emacs, and I can't find a way to find references
02:33:04 <DanielDiaz> cdrlx: you are welcome. :)
02:34:14 <DanielDiaz> Can somebody tell me what are the changes in the new version of transformers? Or do I have to take a look at the diff?
02:34:38 <DanielDiaz> oh, wait, I just realized there is a changelog in Hackage, silly me
02:34:45 <cdrlx> Can someone tell me the difference of '++' operator and ': operator?'
02:34:56 <vanila> cdrlx,
02:34:58 <vanila> :t (:)
02:34:59 <lambdabot> a -> [a] -> [a]
02:35:00 <vanila> :t (++)
02:35:01 <lambdabot> [a] -> [a] -> [a]
02:35:01 <vanila> so
02:35:10 <vanila> > 'h' : "ello world"
02:35:11 <lambdabot>  "hello world"
02:35:12 <vanila> vs
02:35:20 <vanila> > "hello " ++ "world"
02:35:21 <lambdabot>  "hello world"
02:36:05 <cdrlx> so the ':' operator is only used for concatenating one character to another string?
02:36:55 <vanila> yes and it works for any list, not just strings
02:37:30 <edwardk> > 1:[2,3,4]
02:37:31 <DanielDiaz> > 1 : [2,3]
02:37:32 <lambdabot>  can't find file: L.hs
02:37:32 <lambdabot>  [1,2,3,4]
02:37:43 <DanielDiaz> haha
02:37:59 <DanielDiaz> L.hs?
02:39:16 <cdrlx> I guess it's not possible to use concatenate a string to another string. It has to be `char : string`
02:39:41 <quchen> (++) is concatenation. (:) is prepending.
02:40:02 <quchen> … of a single element.
02:40:31 <cdrlx> Thanks quchen.
02:40:33 <DanielDiaz> > "it is" ++ " possible"
02:40:34 <lambdabot>  "it is possible"
02:41:03 <cdrlx> "It is" ++ " possible..."
02:41:37 <cdrlx> Hmmm... is lambdabot an actual bot?
02:41:40 <jle`> cdrlx: a common exercise is to write (++) yourself :)
02:41:46 <jle`> actually lambdabot is a person
02:41:57 <DanielDiaz> haha
02:42:03 <cdrlx> jle`, I did. I tried both ++ and : operator.
02:42:09 <quchen> We work hard shifts to make Lambdabot responsive
02:42:12 <jle`> cdrlx: nice :)
02:42:22 <jle`> congrats
02:42:40 <jle`> you'll find that a lot of the useful Prelude functions are actually a joy to implement
02:42:56 <cdrlx> DanielDiaz : I thought lambdabot is a bot that evaluate expressions :| epic fail for me.
02:43:23 <cdrlx> jle` LYAH says that it's good to use when handling big data.
02:43:42 <DanielDiaz> cdrlx: it is: try "> 1+2". Do not forget the ">".
02:43:53 <cdrlx> > 1+2
02:43:55 <lambdabot>  3
02:43:59 <cdrlx> Cool
02:44:03 <cdrlx> one more.
02:44:24 <cdrlx> > "Test" ++ "ing"
02:44:25 <lambdabot>  "Testing"
02:44:50 <cdrlx> That's awesome let me try one last code.
02:45:12 <cdrlx> "IE" : "XPECT AN ERROR"
02:45:23 <cdrlx> > "IE" : "XPECT AN ERROR"
02:45:25 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
02:45:25 <lambdabot>  Expected type: [[GHC.Types.Char]]
02:45:25 <lambdabot>    Actual type: [GHC.Types.Char]
02:45:39 <jle`> cdrlx: you can always /q lambdabot :)
02:45:56 <jle`> lambdabot can fix errors too but that feature seems to be broken
02:45:58 <jle`> > fix error
02:45:59 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:46:03 <jle`> hm still broken
02:46:28 <cdrlx> I have a fear that lambdabot would be used to hack this channel...
02:46:57 <jle`> cdrlx: lambdabot has been battle tested over many years
02:47:23 <jle`> also "hack this channel"?
02:47:37 <jle`> s/also/also,
02:48:43 <cdrlx> Something like "hack". Something that would hack the user accounts.
02:49:11 <cdrlx> I have one more question for now. What's syntactic sugar?
02:49:59 <jophish> Is there any way to export a constructor so I can pattern match over it, but not use it to construct values of its data-type?
02:50:02 <jle`> it's a general term in programming languages...some syntax feature that makes things a little easier to read
02:50:12 <pyon> cdrlx: it's more convenient syntax for specific cases of already existing functionality
02:50:18 <jle`> cdrlx: like being able to write [1,2,3] instead of 1:2:3:[]
02:50:27 <jle`> even though you could have always gotten away with 1:2:3:[]
02:50:38 <bitonic> jophish: no.  use a view
02:51:08 <Aetherspawn> well, it has been done before in places like #haskell-blah
02:51:21 <Aetherspawn> getting 2 bots to perpetually bounce off each other using @where
02:51:38 <cdrlx> Is it something that represents a list like [1,2,3] in a way that makes sense reading it?
02:52:06 <Aetherspawn> [1..3]
02:52:08 <pyon> cdrlx: using [1,2,3] instead of 1:2:3:[] is an example of syntactic sugar
02:52:38 <Aetherspawn> :t enumFromTo
02:52:39 <lambdabot> Enum a => a -> a -> [a]
02:52:48 <Aetherspawn> > enumFromTo 0 10
02:52:49 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
02:52:59 <Aetherspawn> [1..10] is sugar for that.
02:53:05 <Aetherspawn> well, 0..10
02:53:30 <pyon> cdrlx: another example is "[baz | x <- foo ; y <- bar]", instead of "foo >>= \x -> bar >>= \y -> return baz"
02:53:42 <pyon> errr, that semicolon should've been a comma
02:53:57 <cdrlx> So it's a more readable way to write code?
02:54:17 <Aetherspawn> Why do you add sugar to coffee?
02:54:27 <Aetherspawn> (and it's not to get fat)
02:54:35 <cdrlx> To make it sweeter.
02:54:44 <Aetherspawn> So why might you add sugar to code?
02:54:48 <pyon> cdrlx: it's an alternative, more convenient syntax for something that can already be done in another way... usually that "something" is a specific case, albeit a very common one
02:55:13 <pyon> is a specific case of another more general thing*
02:55:33 <cdrlx> @Aetherspawn so it's easier to do?
02:55:33 <lambdabot> Unknown command, try @list
02:55:48 <Aetherspawn> easier, not always, sweeter, sure.
02:56:20 <quchen> pyon: No, list comprehensions are not sugar for list monad syntax.
02:56:33 <quchen> It's one way of implementing them, but not required to be done this way.
02:56:42 <cdrlx> I think I'll find the meaning to "sweeter" as I learn about fp more.
02:56:49 <cdrlx> BFN.
02:57:04 <Aetherspawn> /r/haskell/
02:57:09 <pyon> quchen: what would be another way? :-o
02:57:59 <pyon> (map/pure/join doesn't count btw... it's basically the same)
02:58:00 <pyon>  
02:58:04 <cdrlx> \help
02:58:09 <quchen> pyon: See the chapter about list comprehensions in the Haskell report. They're defined in terms of behaviour.
02:58:29 <pyon> ok checking
02:59:10 <quchen> [ e | True ] = [e]; [ e | q ] = [ e | q, True ], …
02:59:23 * hackagebot jsaddle-hello 1.0.0.0 - JSaddle Hello World, an example package  http://hackage.haskell.org/package/jsaddle-hello-1.0.0.0 (HamishMackenzie)
03:00:20 <quchen> I think one reason GHC does not use monadic functions by default here is for easier optimizations, or so I've heard.
03:01:06 <vanila> > [ (x,y) | x <- "abc", y <- [1,2,3] ]
03:01:08 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
03:01:11 <vanila> > [ (x,y) | x <- "abc" | y <- [1,2,3] ]
03:01:12 <lambdabot>  [('a',1),('b',2),('c',3)]
03:02:19 <jophish> super, thanks bitonic
03:02:52 <pyon> quchen: ah!
03:04:24 * hackagebot latest-npm-version 0.1.0 - Find the latest version of a package on npm  http://hackage.haskell.org/package/latest-npm-version-0.1.0 (passy)
03:08:09 <cdrlx> I am surprised about list comprehensions.
03:08:30 <cdrlx> I did that on python but I never that making it in Haskell is easier than in Python.
03:08:53 <_flatline_> everything is easier in this language
03:09:25 * hackagebot time-lens 0.4 - Lens-based interface to Data.Time data structures  http://hackage.haskell.org/package/time-lens-0.4 (RomanCheplyaka)
03:14:25 * hackagebot flock 0.3.1.7 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.7 (ErikHesselink)
03:19:26 * hackagebot http-client 0.3.2.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.2.2 (MichaelSnoyman)
03:24:27 * hackagebot deeplearning-hs 0.1.0.0 - Deep Learning in Haskell  http://hackage.haskell.org/package/deeplearning-hs-0.1.0.0 (ajtulloch)
03:24:29 * hackagebot deeplearning-hs 0.1.0.1 - Deep Learning in Haskell  http://hackage.haskell.org/package/deeplearning-hs-0.1.0.1 (ajtulloch)
03:29:27 * hackagebot html-conduit 1.1.0.5 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.5 (MichaelSnoyman)
03:29:29 * hackagebot bumper 0.6.0.2 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.6.0.2 (ErikHesselink)
03:29:31 * hackagebot halberd 0.1.2.6 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.6 (ErikHesselink)
03:30:03 <merijn> jophish: Actually, bitonic lied in 7.8 there *is* a view to export a constructor that can't be used to construct a value :)
03:30:14 <merijn> jophish: errr s/view/way
03:30:56 <merijn> jophish: The PatternSynonyms lets you define pattern which can be pattern matched on like normal, but which can be restricted to "match only"
03:33:49 <sopvop> should I use ReifiedLens or ALens to store lens in record field?
03:34:26 <edwardk> ReifiedLens is a more efficient storage format especially if you'll be converting back and forth
03:34:49 <sopvop> thanks
03:36:03 <quchen> merijn: ViewPatterns allowed this even before 7.8.
03:36:31 <cdrlx> Do loops exist in Haskell?
03:36:54 <vanila> cdrlx, yeah
03:36:57 <quchen> Depends on what you mean with loop. Probably yes.
03:37:11 <Taneb> cdrlx, recursion does and you can make loops with that
03:37:13 <cdrlx> Loops like for loops, while loops, etc..
03:37:41 <cdrlx> Taneb: So recursion is like the loop of Haskell?
03:38:14 <Taneb> Sooooort of
03:38:22 <Tordek> can someone exmplain comonads a bit for me? I'm really not understanding what they're for... or link me to somewhere clearish?
03:38:26 <Taneb> You can use recursion to do loops in almost any language with recursion
03:39:07 <makalu> is Agda a language that can (and should) actually be used or is it more of a verification thing?
03:39:18 <edwardk> Tordek: http://comonad.com/haskell/Comonads_1.pdf is a starting point for understanding where they come from
03:39:24 <cdrlx> Taneb: I heard of functions but I am not good at them, I always end up in an infinite recursion.
03:39:36 <cdrlx> * recursions
03:39:38 <Taneb> cdrlx, practise!
03:39:51 <Taneb> Make sure you always have a base case that is where it stops
03:39:54 <quchen> edwardk: That subtitle
03:40:00 <cdrlx> Let me rephrase that statement
03:40:08 <cdrlx> Taneb: I heard of recursion but I am not good at them, I always end up in an infinite recursion.
03:40:30 <Taneb> cdrlx, always start with where the recursion will stop
03:40:47 <Taneb> "if x == 0 then 1 else ..."
03:40:51 <edwardk> quchen: it was an homage to http://www.cs.rit.edu/~swm/cs561/All_About_Monads.pdf
03:41:16 <edwardk> I knew Jeff Newbern was going to be in the audience, so it seemed appropriate ;)
03:41:31 <Tordek> edwardk: cool, thanks
03:41:35 <Taneb> cdrlx, then think about what you want to do otherwise
03:42:01 <cdrlx> Taneb: Thanks for the tip Taneb.
03:42:07 <Algebr> :q
03:42:20 <Taneb> cdrlx, practise a bit! Try to write a factorial function, for example
03:42:43 <Marquis> cdrlx: my favourite example is factorial. fac 0 = 1, fac x = x* fac (x-1)
03:42:45 <cdrlx> Yes... The factorial function is the easiest.
03:43:04 <cdrlx> Are recursions more efficient than regular for-loops or while-loops?
03:43:10 <Marquis> it looks recursive but if you do fac 10000 you get an result imediately
03:43:33 <Algebr> Marquis: because of tco?
03:44:05 <osa1> what's a "constructor class" in Haskell? is this like data constructor but for GADTs?
03:44:46 <merijn> osa1: Where did you encounter the term?
03:45:06 <cdrlx> One for question for now. Do recursions give you a result of big inputs faster than loops from imperative programming?
03:45:08 <srhb> cdrlx: Well-written recursion tends to get optimized into loops by the compiler
03:45:09 <osa1> merijn: Oleg's "Typed Tagless Final Interpreters" paper/lecture notes
03:45:28 <srhb> cdrlx: But it depends on what you're doing.
03:46:04 <Taneb> cdrlx, recursion is more flexible, and it's easy to write it so that it's hard to optimize. For when they're similar, loops use less stack space than (non-optimized) recursion
03:47:07 <cdrlx> Thanks for the answers. BFN.
03:47:11 <vanila> cdrlx, because of lazyness, yes you can get the initial results faster in some cases
03:47:12 <srhb> BFN?
03:47:15 <merijn> osa1: hmm, not familiar with that
03:47:45 <Marquis> bye for now ?
03:47:47 <srhb> Ah!
03:47:50 <srhb> o/
03:48:09 <cdrlx> Yes. Bye for now. I need to finish another part of the chapter.
03:48:29 <Marquis> coma back and ask us, i am pretty sure we like to do some of the simple stuff
03:49:08 <osa1> merijn: I think he meant to say "type classes" because he's using this term with ML's functors: "... as realized in variants of ML (as functors) and Haskell (as constructor classes)
03:51:13 <Algebr> hayoo is amazing, wish it was shown to me sooner.
03:52:49 <k00mi> if it's not currently down ;)
03:53:57 <makalu> GHC 7.6 doesn't have closed type families?
03:54:11 <pyon> I think it is a GHC 7.8 addition.
03:54:13 <k00mi> correct
03:54:14 <merijn> makalu: Nope
03:54:20 <makalu> :'(
03:54:26 <merijn> makalu: Word :)
03:54:34 <merijn> makalu: Time to update to 7.8 :p
03:59:00 <makalu> if I use GADTs and generalized let is disabled, it's also disabled on top level?
03:59:33 <makalu> actually, nvm :)
04:00:31 <cdrlx> \nickserv
04:02:44 <cdrlx> test
04:03:09 <srhb> cdrlx: ?
04:06:46 <Algebr> What does the unsafe in unsafe* functions mean?
04:07:52 <skypers_> ohai! I’m looking for some help with happstack! :) I’m discovering it, and serveDirectory fails with Server error: /tmp/: openBinaryTempFile: does not exist (No such file or directory)
04:07:59 <skypers_> any idea of that kind of issue?
04:08:13 <_ctc_> > take 3 [1..]
04:08:14 <lambdabot>  [1,2,3]
04:08:26 <_ctc_> > [1..]
04:08:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:09:00 <_ctc_> > let x = x in x
04:09:03 <quchen> Algebr: "Unless you *know* this function is what you need, do not ever use it"
04:09:03 <lambdabot>  mueval-core: Time limit exceeded
04:09:14 <merijn> Algebr: It means "don't use unless you're an expert", usually it means it violates purity, so if you do something wrong and the compiler shifts your code around things break
04:09:48 <Algebr> does the existence of unsafe* func mean that there was no way to do this in a safe way?
04:09:57 <merijn> Algebr: for example, "unsafePerformIO :: IO a -> a", throws away the "IO" part, which means that GHC can decided to run your IO 0 upto fifteen billion times
04:10:32 <merijn> Algebr: Usually unsafe* is an escape hatch "I know that if you do it this way, it'll be faster, so just do it, I know this is safe"
04:10:37 <srhb> skypers: Does /tmp exist and is it writable? JUst a guess.
04:10:48 <_ctc_> > print ("> [1..]")
04:10:49 <lambdabot>  <IO ()>
04:11:07 <merijn> @quote is.not.a.bug
04:11:07 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:11:12 <_ctc_> > "> [1..]"
04:11:14 <lambdabot>  "> [1..]"
04:11:34 <merijn> _ctc_: lambdabot doesn't support running IO actions, for obvious reasons :)
04:11:36 <Algebr> much appreciated.
04:12:42 <merijn> Algebr: For example, imagine the C function "double sin(double)", this should obviously be a pure function, right? Normally FFI functions result in IO (since C can mutate state), but in this case you may want to tell GHC "don't worry, this is pure, so treat it like a pure haskell function", unsafe* is for situations like that
04:13:33 <merijn> Algebr: The flip side is, if you lied to GHC, GHC may have done optimisations/transformations/what not that cause really weird bugs and segfaults
04:13:52 <Algebr> Crystal clear example, awesome.
04:14:25 <Deewiant> (Beware that the C standard "double sin(double)" isn't actually pure because it can modify errno.)
04:14:33 * hackagebot time-lens 0.4.0.1 - Lens-based interface to Data.Time data structures  http://hackage.haskell.org/package/time-lens-0.4.0.1 (RomanCheplyaka)
04:14:40 <quchen> Wat
04:14:51 <merijn> quchen: Welcome to the wonderful world of C!
04:15:00 <merijn> quchen: We hope you enjoy your stay!
04:15:02 <quchen> sin :: Double -> IO Double  ಠ_ಠ
04:15:21 <merijn> errno was a huge mistake >.>
04:15:36 <quchen> Does that make everything that can error impure?!
04:15:40 <srhb> quchen: It's unsafe because it has to ask the gnomes that live in math, and they might not be in, or make mistakes on certain holidays.
04:15:47 <merijn> quchen: Everything that errors via errno, yes
04:16:07 <Samoi> eh kinda a necessary evil imo
04:16:21 <quchen> The advantage of having 'sin' in IO that you can implement a webscale cloud-based solution.
04:16:28 <srhb> :P
04:16:44 <merijn> srhb: sin is IO and IO is sin, nice symmetry :)
04:16:47 <merijn> err
04:16:53 <merijn> I meant quchen, but oh well
04:16:58 <srhb> I find it funny, too!
04:17:03 <merijn> Typing is hard!
04:17:04 <quchen> quchen is IO and IO is quchen?
04:17:06 <skypers_> simpler question: in happstack, what does "/" refer to?
04:17:17 <skypers_> is it the same directory as the executable?
04:17:31 <skypers_> is there a place where I can set that
04:17:32 <srhb> skypers_: That depends, in routes it's completely independent of your directory structure
04:17:42 <hpc> skypers_: do you mean "/" the file path, or the url path?
04:17:48 <freeman42> :) http://i0.wp.com/sapiengames.com/wp-content/uploads/2014/03/haskell-spock.png?resize=685%2C600
04:17:49 <skypers_> the url path
04:17:52 <skypers_> I’m on windows now
04:17:55 <srhb> It has no special meaning then.
04:18:07 <hpc> it's just whatever your site index is
04:18:08 <skypers_> srhb: well to me its the root of the public dir
04:18:27 <skypers_> I try to use serveDirectory
04:18:41 <skypers_> but it fails when calling openTempBinaryFile
04:18:45 <Algebr> Deewiant: What is errno?
04:18:53 <skypers_> maybe I need to create a tmp file somewhere
04:18:59 <skypers_> but I don’t know where :(
04:19:10 <Deewiant> Algebr: man 3 errno: http://linux.die.net/man/3/errno
04:19:16 <srhb> skypers_: Show us some code. :)
04:19:18 <skypers_> Server error: /tmp/: openBinaryTempFile: does not exist (No such file or directory)
04:19:21 <skypers_> srhb: sure
04:19:22 <skypers_> wait
04:19:38 <srhb> I know what is going wrong, because /tmp/ doesn't exist on Windows afaik :P
04:19:40 <Deewiant> skypers_: That looks like it thinks it's on a posix system
04:19:46 <skypers_> http://lpaste.net/103620
04:19:57 <skypers_> it’s the code from the happstack-lite tutorial
04:20:00 <skypers_> Deewiant: yeah.
04:20:02 <Aetherspawn> freeman42: the number of times I've seen that
04:20:06 <skypers_> so I tried to alter the ServerConfig
04:20:08 <skypers_> but same issue
04:20:24 <Aetherspawn> but everyone knows the enterprise was programmed in SPARK :)
04:20:27 <srhb> skypers_: I believe that "." will be interpreted as "wherever you launched Happstack from"
04:20:43 <skypers_> ok, so do I
04:21:07 <hpc> skypers_: by the way, your code should be more specificc with how it calls homepage
04:21:13 <srhb> skypers_: What does tmpDir say?
04:21:21 <skypers_> srhb: on what?
04:21:26 <hpc> skypers_: right now, it will show it for any old whatever, so /alksdjhlaksjdhlkajsdhfkjhasdf would still be a 200
04:21:28 <skypers_> on the default config?
04:21:32 <srhb> skypers_: Yes
04:21:34 <hpc> skypers_: search engines are going to deinde you for that
04:21:37 <skypers_> srhb: /tmp/
04:21:45 <srhb> skypers_: And you tried modifying that to no avail?
04:22:19 <skypers__> dammit timeout
04:22:22 <skypers__> so yeah
04:22:35 <skypers__> I’ve been learning happstack since this very morning
04:22:52 <skypers__> I’ll try to change the default config to something more windowsish
04:22:55 <srhb> skypers__: did you try serve (Just (defaultConfig { tmpDir = "whateveritisonWindows" }) ... ?
04:23:04 <skypers__> like C:\tmp
04:23:10 <skypers__> srhb: not yet, I will
04:23:11 <srhb> No idea if that's it.
04:23:17 <hpc> the tmpdir on windows is %temp%
04:23:32 <skypers__> is it possible to escape that in Haskell?
04:23:38 <hpc> which expands to C:\Users\%username%\AppData\Local\Temp
04:24:03 <hpc> or rather, %appdata%\Local\Temp
04:24:28 <skypers__> main = serve (Just $ defaultServerConfig { tmpDir = "%temp%" }) myApp
04:24:33 <skypers__> ok, let’s try this out
04:24:34 <hpc> i think if you just use that as your tmpDir value it will just work
04:24:40 <hpc> same way you can use ~ on linux
04:25:05 <skypers__> yeah on linux /tmp is quite okay to me
04:25:35 <skypers__> Server error: %temp%: openBinaryTempFile: does not exist (No such file or directory)
04:25:36 <skypers__> :D
04:25:50 <skypers__> I guess it’s not escaped
04:26:03 <skypers__> maybe with getEnv
04:27:07 <srhb> skypers__: At least the error message changed. :p
04:27:16 <skypers__> yep :)
04:27:35 <hpc> http://stackoverflow.com/questions/1317399/getting-the-local-appdata-folder-in-haskell
04:28:04 <skypers__> main = getEnv "temp" >>= \tmp -> serve (Just $ defaultServerConfig { tmpDir = tmp }) myApp
04:28:06 <skypers__> now it works :)
04:28:11 <skypers__> thank you guys
04:28:41 <hpc> oh cool, it's in the environment
04:28:44 <skypers__> now, I need to understand how serveDirectory works
04:28:55 <skypers__> because it only prints me a weird thing
04:29:10 <skypers__>  /file\
04:30:09 <hpc> how do you mean print?
04:30:35 <hpc> what url, what http status?
04:30:52 <skypers__> hpc: file
04:30:57 <skypers__>  /file
04:31:04 <skypers__> I get a 200
04:32:38 <hpc> can you view source?
04:33:49 <hpc> anyway, the way serveDirectory works is that if the remaining URL part stops on a directory, resolve to any of that dir's index files
04:33:53 <cdrlx> Tuples are interesting here. When making ordered pairs, the lengths must be the same or else it will return an error...
04:33:55 <hpc> otherwise resolve to the file in that directory
04:34:12 <hpc> it automatically figures out the mime type from the extension
04:34:21 <hpc> which you can configure
04:34:35 * hackagebot optparse-applicative 0.8.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.8.1 (PaoloCapriotti)
04:35:05 <skypers__> hpc: hm
04:35:14 <skypers__> maybe I don’t understand the use of that then
04:35:17 <hpc> i have to leave for work, but you're very close
04:35:30 <skypers__> I’ll experiment
04:35:33 <skypers__> thank you a lot :)
04:35:52 <hpc> make sure it's resolving "." to the right directory, maybe make it explicit
04:36:12 <hpc> definitely move the binary out of there if it is in that dir, and change it to some deeper directory to serve, like "files/" or something
04:36:22 <hpc> for security
04:36:54 <hpc> and make sure your directory has the right file contents and that you're not correctly serving wrong files
04:36:59 <hpc> that's about all i can think of
04:38:34 <whald> hi! is there a way to make this code: http://lpaste.net/103621 (only 9 loc) typecheck? I think I understand why the first variant is ambiguous, but I fail to understand why the commented-out variant is problematic, too.
04:39:49 <whald> (Location basically wraps an Rational in [0..1])
04:43:22 <supki> whald: type variables are not scoped by default
04:44:01 <supki> whald: you'll need to add ScopedTypeVariables language pragma and to prepend  forall a.  to the type signature
04:44:03 <whald> supki, this means the ":: a" is futile, right?
04:44:18 <supki> yeah,  :: a  means  :: forall a. a
04:45:03 <whald> supki, is "ScopedTypeVariables" considered "good and stable" or will I regret this?
04:45:12 <supki> it's ok
04:45:12 <zipper> So I was updating when I got an option to replace "haskell-transformers with extra/ghc?" Shoud I want to replace haskell-transformers with extra/ghc?
04:45:38 <srhb> zipper: Say what? Is this an Arch question?
04:45:53 <ion> whald: You don’t need ScopedTypeVariables, you could use hasLocToInteger (hasLocMax `asTypeOf` x)
04:46:24 <zipper> srhb: Yes
04:46:38 <whald> supki, thanks, this works! :-)
04:46:38 <srhb> zipper: Right. Personally I don't install anything but cabal and ghc globally
04:46:43 <zipper> srhb: Haskell on arch question
04:46:43 <srhb> zipper: And the rest with cabal install
04:47:07 <zipper> srhb: I don't remember installing those
04:47:18 <srhb> zipper: You probably installed something else that depended on it.
04:47:45 <bjobjo> zipper: the release of 7.8 on Arch changed a bit of the packaging
04:47:56 <whald> ion, whew, "asTypeOf" is nifty!
04:48:02 <bjobjo> I think it was mostly due to the maintainer wanting to concentrate on ghc and cabal
04:48:15 <bjobjo> there is some more information on the mailing lists, as well as the front page: https://www.archlinux.org/news/managing-haskell-packages-with-ghc-782/
04:48:51 <bjobjo> (I personally use the arch-haskell repository, so I don't know the specifics)
04:51:06 <zipper> bjobjo: 7.8 of what?
04:51:16 <bjobjo> Oh, I'm sorry, GHC version 7.8 :)
04:51:49 <zipper> bjobjo: Heck I'll say yes
04:54:18 <zipper> bjobjo: Thanks for that link
04:54:39 <bjobjo> zipper: no problem :)
04:54:52 <bjobjo> the frontpage usually has an announcement when "big" things happen
04:55:00 <bjobjo> there's also the arch-announce mailing list
04:57:56 <cdrlx> Haskell is an enjoying language. And this channel is full of friendly folks.
04:58:13 <srhb> cdrlx: Glad you think so :)
04:59:37 * hackagebot deeplearning-hs 0.1.0.2 - Deep Learning in Haskell  http://hackage.haskell.org/package/deeplearning-hs-0.1.0.2 (ajtulloch)
05:14:48 <yac> data X = X { x1 :: Int }
05:14:50 <yac> data Y = Y { x1 :: Int }
05:14:52 <yac> how do I deal with this?
05:15:00 <hpc> this was just too good to not link here: http://thecodelesscode.com/case/143
05:15:01 <yac> I'm getting a Multiple declarations error for x1
05:15:13 <FreeFull> yac: The namespace for record field names is global
05:15:18 <vanila> can you change it to y1?
05:15:22 <yac> not really
05:15:54 <FreeFull> So not much you can do other than renaming, putting them into separate modules, or using some alternative to the built-in records
05:16:06 <yac> In real code I've got Compensation { salary :: Double } and Args { salary :: Double }
05:16:36 <vanila> you could use Compensation Double, Args Double
05:16:37 <tdammers> I usually end up putting them in separate modules
05:16:49 <vanila> then make a typeclass for salary
05:16:50 <tdammers> and then import qualified when needed
05:16:53 <bergmark> yac: use qualified imports
05:17:00 <yac> How come it the salary :: Compensation -> Double and salary :: Args -> Double can't coexist?
05:17:06 <vanila> they can
05:17:17 <tdammers> name clash, plain and simple
05:17:21 <vanila> class Salary a where salary :: a -> Double
05:17:22 <srhb> yac: We don't have that kind of resolution (yet)
05:17:31 <vanila> instance Salary Compensation where ...
05:17:38 <vanila> instance Salary Args where ...
05:18:47 <Okasu> yac: Wait for OverloadedRecordFields GHC extension.
05:18:47 <pi3r> I have a function `score` :: a -> s -> Either String (b, s)
05:18:47 <pi3r> I would like to have a function `scores` :: [a] -> -> s -> Either String ([b], s)
05:18:47 <pi3r> In my code `s` is Board, `a` is Int and `b` is Int
05:18:47 <pi3r> I currently use StateT and mapM to do the trick:
05:18:47 <pi3r> scores = mapM _score as `S.runStateT` b
05:18:48 <pi3r>     where
05:18:48 <pi3r>         _score a = S.StateT $ \s -> score a s
05:18:49 <pi3r> Is this idiomatic ?
05:19:06 <yac> vanila: what goes in the ... part of instance?
05:19:31 <yac> oh wait, it's type declaration only too?
05:19:33 <vanila> yac, oh i assumed those are two different data types
05:19:38 <vanila> instance Salary Compensation where salary (Compensation x) = x
05:19:41 <yac> yes they are
05:19:45 <vanila> instance Salary Args where salary (Args x) = x
05:22:34 <yac> vanila: now I need to change the Args definition too, right?
05:25:08 <yac> vanila: I got it working but now I can't use the record syntax for the rest of the fields of those data types, right?
05:25:13 <vanila> yes
05:25:29 <yac> so I have to write the accessors myself
05:25:55 <vanila> you could add them to the typeclass
05:26:03 <vanila> maybe
05:27:21 <Marquis> hello i got a questions that reading old stack overflow threads coudl not answer
05:27:41 <Marquis> i got a type named token looking like this : data Token = 	S String    	|     Atom String     | 	Int Integer     |     B Bool          |     Sep Char 	deriving (Eq,Show)
05:28:13 <Marquis> now i would like to use the fromList function from the Data. Vector.Unboxed module
05:28:18 <Marquis> how do i do it?
05:29:00 <quchen> You neither have a list nor a vector here, I doubt that's the function you want.
05:29:46 <Marquis> i wrote a lexer that gives me output as a list and i would like to use that
05:29:55 <Marquis> ahh, i got an idea
05:31:02 <benzrf> Marquis: why are you writing a lexer
05:31:05 <benzrf> WHEN U COULD BE WRITING A PARSER
05:31:08 <benzrf> parsec woot woot
05:31:34 <quchen> Parsec includes a lexer.
05:31:36 <Marquis> parsec was too difficult for my task. the lexer took just a few hours to write and i get the perfect output
05:31:53 <Marquis> i used alex and was finished in no time
05:33:43 <Marquis> but i want to use the output for the kmeans algorithm that runs with the vector type, but my tokens are not unboxed
05:35:22 <maybefbi> anyone every used the fix-imports package?
05:35:26 <maybefbi> *ever
05:44:36 <suls> anyone around with recent "real world haskell" book experience?
05:46:02 <Marquis> yes
05:46:04 <srhb> suls: A lot of people have read that book. Anything specific?
05:47:38 <suls> yes, chapter 15, where we write a MonadSupply instance .. i am getting "SupplyInstance.hs:15:39: Not in scope: `runMySupply'" and am a bit lost ..
05:48:31 <ThePawnBreak> hi; is there any way to fix my htfpp output? http://pastebin.com/g7ckCb9x
05:50:41 <srhb> suls: How does your MySupply newtype look?
05:52:04 <suls> http://lpaste.net/103622#line17
05:52:15 <suls> srhb: this one? http://lpaste.net/103622#line17
05:52:57 <srhb> suls: And that's giving you an error that runMySupply is not in scope?
05:55:37 <srhb> suls: I would expect a different error.
05:56:15 <srhb> suls: Namely that the record syntax is illegal there (you can't have the e and a parameters outside like that)
05:57:34 <srhb> suls: So newtype MySupply e a = MySuppy { runMySupply :: Reader e a } deriving Monad
05:58:06 <suls> yes. I am running it with ghci and then :l SupplyInstance.hs
05:58:06 <suls> v 7.6.3
05:58:09 <zomg> Oh damn, 1 gb is not enough ram to compile Text.Regex.TDFA now :\
05:58:44 <srhb> suls: I think the error is wrong then. I don't understand why it would give you that. Either way, remove the parameters e and a after MySupply
06:00:04 <pi3r2> Hi there, is this an idiomatic use of StateT ? http://lpaste.net/103623
06:01:27 <srhb> suls: Did that help?
06:02:31 <bernalex> what do I need to do to print a prompt? like putStr " >" but uhm actually output it at once?
06:02:45 <bernalex> "do prompt; input <- getLine"
06:03:23 <benmachine> bernalex: hFlush stdout after the putStr
06:03:28 <srhb> bernalex: You probably need to change buffering with hSetBuffering if that isn't working
06:03:43 <bernalex> benmachine: I kind of guessed it was that simple, but didn't remember the function name. thanks.
06:04:50 <maybefbi> how to exit from the getContents prompt?
06:05:16 <bernalex> maybefbi: ^D for instance
06:05:17 <benmachine> pi3r2: I think it would be more usual to use get and put rather than the StateT constructor directly
06:05:34 <benmachine> pi3r2: am I right in thinking that basically the reason you use StateT is for mapM?
06:05:46 <maybefbi> bernalex, will that add a character to getContents return value?
06:05:56 <yac> how do I use typeclass in function signature?
06:06:09 <deni> i'm confused as to what the relation between the monad type class and the monoid type class is?
06:06:14 <pi3r2> yes I only use stateT to be able to apply x times score
06:06:18 <bernalex> maybefbi: uhm \0 I would guess, but IDR
06:06:19 <deni> anyone care to share some insights?
06:06:22 <bernalex> maybefbi: TIAS
06:07:43 <yac> ooooh
06:07:48 <srhb> deni: The old answer is something like monads are just monoids in the category of endofunctors. Doesn't help much unless your CT is quite good, I guess :P
06:07:58 <yac> is typeclass a monad?
06:08:03 <srhb> yac: What?
06:08:06 <deni> srhb: yeah i know that one
06:08:08 <yac> or just some kind of box
06:08:17 <srhb> yac: Neither. I don't understand the question
06:08:33 <srhb> Monads are implemented via typeclasses, if that's what you mean.
06:08:52 <maybefbi> bernalex, thanks
06:08:59 <deni> srhb:  i'm really just asking in terms of these constructs in haskell....i don't see the relation really. ie nowhere does monad inherit something from monoid or anything like that. or does it?
06:09:19 <srhb> deni: No indeed, and since all functors in Haskell are endofunctors, I don't think it would make sense either.
06:09:34 <merijn> deni: Correct, in haskell this explanation is not helpful at all
06:10:06 <bernalex> in this really simple guess the number game, what would be the most idiomatic (yet terse) way of guessing until the correct answer is reached? http://lpaste.net/7567696723028475904
06:10:15 <spockshock> yac: there might be a reason in lyah they put the monoids chapter Before the monad chapters...you really need to understand monoids, then monads, imho
06:10:19 <bernalex> note that I want to keep guess out of IO
06:10:34 <srhb> yac: When you want to add a constraint to a function, you use =>. Like (*) :: Num a => a -> a -> a
06:10:38 <merijn> deni: This explanation is fairly good: https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
06:10:57 <yac> I figured it by removing type signature, doing the definition and then :t ...
06:11:09 <srhb> yac: This means that (*) is a function of two arguments, they must be the same (as with the return value) and must have an instance of the Num typeclass
06:11:31 <pi3r2> benmachine I know I can express a single score with _score by doing S.runStateT (_score a) b but I actually don't need a State monad until I implement scores ::  [Int] -> Board -> Either String ([Int], Board)
06:11:36 <deni> merijn: seen that one...but it doesn't really talk about haskell....
06:11:48 <merijn> deni: Right, because in haskell the relation is non-existent
06:11:51 <deni> merijn: what i'm asking is how these 2 constructs relate in haskell? and the answer seems to be they don't
06:11:57 <deni> merijn: correct
06:12:17 <benmachine> pi3r2: well, you don't *need* it at all, it's only there to help clarify your meaning
06:12:39 <deni> merijn: so these are 2 separate entities isolated from each other completely....kinda like Applicative and Monad....altough kinda similar...they are 2 separate things
06:12:46 <merijn> deni: You can get part of the symmetry back in haskell by using a different definition of the monad typeclass
06:13:01 <srhb> deni: Applicative does relate to Monad in Haskell
06:13:14 <benmachine> pi3r2: seems like your scoring thing is meant to be understood as a computation that updates a state, so make it one
06:13:29 <pi3r2> benmachine: I guess I can do this without StateT. I am just woindering if this is ok, idiomatic ? is there an alternative to mapM ?
06:13:43 <deni> srhb: in theory yes. but is there anywhere that Monad inherits anything from applicative? they even don't use pure....but rather return
06:13:54 <benmachine> pi3r2: sec, I'm trying something out
06:13:54 <merijn> deni: By comparing "mempty :: Monoid a => a" with "return :: a -> m a" and "mappend :: Monoid a => a -> a -> a" with "(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)"
06:14:02 <srhb> deni: They will in 7.10, but unlike with monoid the relationship is actual in Haskell, even if not implicit yet
06:14:10 <srhb> Er, explicit
06:14:16 <merijn> deni: The lack of relation between Applicative and Monad is that the Applicative typeclass wasn't invented until years after Monad
06:14:20 <deni> merijn: srhb ah ok. tnx
06:14:34 <merijn> deni: GHC 7.10 will add Applicative as superclass for Monad (finally!)
06:14:37 <srhb> deni: So every Monad may not have an Applicative instance yet, but it _can_ be made one
06:14:42 <pi3r2> benmachine: the full code is here: https://github.com/PierreR/afgame/blob/master/haskell/src/Afgame.hs
06:14:49 <srhb> deni: But every Monad cannot be made a Monoid in Haskell, I believe
06:15:10 <srhb> (what is the IO monoid?)
06:15:32 <merijn> deni: Simple example, "fmap f x = x >>= return . f"
06:15:39 <merijn> :t fmap
06:15:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:15:41 <deni> merijn: so Applicative came after monad (historically) but is a lower level construct?
06:15:46 <shachaf> merijn: (>=>) isn't really what people mean when they say monads are monoids.
06:15:52 <benmachine> pi3r2: http://lpaste.net/103623 this is how I would do it
06:16:21 <benmachine> pi3r2: but I do not promise that this way is better than yours, just another way
06:16:30 <merijn> deni: Applicatives are more general than monads, yes. (As in, Applicatives have "less" power, but more things can be Applicative than can be Monad)
06:16:34 <benmachine> pi3r2: "traverse" from Data.Traversable is a generalisation of mapM
06:16:45 <benmachine> pi3r2: but not really necessary here; mapM is better-known
06:16:58 <merijn> shachaf: I know, hence the original SO link, but that symmetry doesn't translate to haskell at all, IMO
06:17:18 <shachaf> Well, bringing up (>=>) just confuses things.
06:17:29 <merijn> deni: In other words, things that can be monads are a strict subset of things that can be applicative
06:17:41 <shachaf> You have a bunch of monoids, one for each type a that you choose.
06:18:18 <FreeFull> shachaf: Bringing up how monad transformers are higher level monads probably doesn't help anyone either
06:18:23 <pi3r2> benmachine that is amazing because that's what I had before ... (if you look at this historic of the github repo). Then I wanted to express the fact that I only need StateT for the list and I change it. Thanks for your help. Very much appreciated.
06:18:50 <bennofs> FreeFull: well, mmorph is quite useful
06:19:28 <merijn> People should probably listen to shachaf anyway, I'm very beginner at all this stuff :)
06:19:43 <FreeFull> bennofs: True
06:19:51 <shachaf> Uh oh.
06:20:52 <merijn> shachaf: That's what you get for being smart, people start listening to you, whether you want them to or not :p
06:22:47 <arj> Assume I have a data type data Term = Var String | Symbol String | App Term Term. Now if I want to create a 'map' over all Symbols of an instance, how would I do that? I tried using Functor for that, but this only works if Term has kind * -> * which it doesn't have. Any ideas/
06:22:51 <quchen> Does (>=>) even have anything to do with monoids? The definitions seem to (have to) obey monoid laws, but I can't tell whether that's just coincidence.
06:23:10 <shachaf> (>=>) gives you a category (with return).
06:23:13 <quchen> It certainly isn't the "monoid in the category of ..."-monoid operation.
06:23:15 <Iceland_jack> quchen: Monads are monoids in the category of endofunctors :)
06:23:28 <Iceland_jack> return is the identity
06:23:31 <shachaf> If you pick any particular type a, (>=>) :: (a -> m a) -> (a -> m a) -> (a -> m a) gives you a monoid.
06:24:02 <spockshock> heavy read: http://www.haskell.org/haskellwiki/What_a_Monad_is_not
06:24:20 <FreeFull> instance (Monad m) => Monoid (a -> m a) where mempty = return; mappend = (>=>)
06:24:23 <quchen> shachaf: That's a specialized case though. Can something similar be said about the (a -> m b) case?
06:24:33 <shachaf> It can be said that it's a category.
06:24:43 <quchen> Fair enough.
06:24:46 <shachaf> Which is just a generalized monoid.
06:24:59 <FreeFull> I wonder, a -> b is a profunctor, what about a -> m b?
06:25:21 <bennofs> FreeFull: I think that's UpStar
06:25:29 <shachaf> When people say monads are like monoids, they mean something like this by associativity: Given foo :: m1 (m2 (m3 a)), I can "join" it into m12 (m3 a) and then "join" it again into m123 a. Or I can "fmap join" it into m1 (m23 a), and then "join" it into m123 a.
06:25:34 <shachaf> I have to end up with the same result.
06:25:35 <fizruk> FreeFull: a -> f b is profunctor if f is Functor
06:25:43 <shachaf> (Of course m1/m2/m3 are the same m here.)
06:25:44 <FreeFull> bennofs: And f a -> b would be DownStar?
06:25:49 <bennofs> FreeFull: yes
06:25:56 <bennofs> FreeFull: http://hackage.haskell.org/package/profunctors-4.0.3/docs/Data-Profunctor.html#v:UpStar
06:26:07 <FreeFull> f a -> f b?
06:27:09 <quchen> When you said "categories are generalized monoids", is that in the sense that monoids are categories with only one object?
06:27:12 <fizruk> FreeFull: f should be Contravariant and Functor at the same time, iiuc it can be only (Const a)
06:27:27 <shachaf> That is the sense in which monoids are a special case of categories.
06:27:29 <shachaf> Sure. Yes.
06:27:45 <bernalex> where do I need a typesig to make this work on one line: input <- read <$> getLine; let n = read input :: Int; ?
06:28:21 <bernalex> ooops, meant input <- getLine; let n = read input :: Int
06:28:22 <fizruk> bernalex: why double read?
06:28:31 <bennofs> fizruk: there is Functor f => Profunctor (UpStar f) and Functor f => Profunctor (DownStar f)
06:28:42 <bernalex> so read <$> getLine is what I *want* to do, but I need :: Int somewhere or something
06:28:47 <quchen> Step 1, don't use read, use readMaybe. Step 2, type signature worries.
06:28:49 <prophile> input <- (read <$> getLine) :: IO Int presumably?
06:28:58 <spockshock> from what Monads are Not: "They also know of bind, but don't use it a lot because, unlike programmers, they don't do any actual productive work."  had to laugh at that
06:29:02 <Iceland_jack> :t :t readLn
06:29:03 <lambdabot> parse error on input ‘:’
06:29:04 <Iceland_jack> :t readLn
06:29:05 <lambdabot> Read a => IO a
06:29:07 <bernalex> quchen: this is a tiny example where I permit myself to not use readMaybe.
06:29:16 <fizruk> bennofs: hm.. yeah, I confused things
06:29:44 <quchen> unsafePerformIO also works similarly great for tiny examples, and it makes your code pure.
06:29:49 <FreeFull> spockshock: Some monads are easier to define in terms of join
06:30:12 <prophile> quchen: would you advocate "unsafeRead"?
06:30:17 <merijn> prophile: Yes
06:30:21 <bernalex> prophile: ah! thanks
06:30:24 <merijn> prophile: Together with unsafeHead and unsafeTail
06:30:27 <quchen> I would advocate not having "read" at all.
06:30:40 * shapr asks lambdabot to hold his beer and runs 'unsafePerform'
06:30:50 <quchen> And then renaming readMaybe to read. (Or maybe readEither)
06:30:52 <FreeFull> reads is safe but a bit inconvienient
06:31:02 <merijn> FreeFull: That's why 7.6 and later have readMaybe
06:31:03 <prophile> k
06:31:18 <merijn> FreeFull: Text.Read.readMaybe :: Read a => String -> Maybe a
06:31:19 <FreeFull> Does it return a list because Maybe didn't exist?
06:31:40 <prophile> FreeFull: I think the list is for ambiguous parses
06:31:53 <prophile> (iirc)
06:31:56 <FreeFull> prophile: Ah, I never saw it have more than one element
06:32:54 <quchen> You typically read only very basic types anyway.
06:33:13 <FreeFull> And for anything else use a parse library?
06:33:43 <srhb> Yes.
06:34:07 <deni> shachaf: merijn srhb tnx for the clarification...still have much to read up on....10 years ago I've never thought I'd say this ... but... i wish i learned more math :D
06:34:14 <srhb> deni: ++
06:34:25 <quchen> That's what I recommend, yes. Read is mostly an inverse to Show. Show is not for prettyprinting, and similarly Read is not for parsing stuff. It's for quick-and-dirty "converting strings to things", which is what parsing does but without seatbelts.
06:35:02 <bernalex> so now I have a function that returns an IO Bool. I want to run this (in main) until it returns True, then print "bye" or something. what's a nice way to do this?
06:35:22 <edofic> runMaybeT $ forever yourAction
06:35:23 <srhb> bernalex: Something like untilM
06:35:57 <merijn> deni: Story of my life, I keep running into "man, I should've gone into math instead of CS then CS would've been much easier" ;)
06:35:58 <bernalex> srhb: where is that?
06:36:04 <bernalex> hoogle didn't return anything useful
06:36:13 <merijn> bernalex: monad-loops?
06:36:18 <merijn> @hackage monad-loops
06:36:18 <lambdabot> http://hackage.haskell.org/package/monad-loops
06:36:27 <bernalex> merijn: thanks
06:36:42 <bernalex> I actually have that installed. wonder why hoogle did not return anything.
06:37:07 <deni> merijn: :)
06:38:32 <bernalex> I don't get this, what is the m a?
06:38:47 <bernalex> m a is what I want to do and m Bool is what I want to check, or something?
06:38:53 <srhb> bernalex: Yes
06:38:58 <bernalex> oh, but they're the same lol
06:39:04 <srhb> bernalex: then use return () for m a
06:39:22 <bernalex> yes that's what I thought I'd do, though it looks a bit silly
06:39:31 <srhb> Well you can always do this explicitly
06:39:45 <quchen> Maybe try implementing the loop by hand for practice?
06:39:49 * hackagebot mtl 2.2 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.2 (EdwardKmett)
06:39:51 * hackagebot HTTP 4000.2.14 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.14 (GaneshSittampalam)
06:39:56 <srhb> foo = a <- my bool; doStuff, if a then foo else bye
06:40:02 <bernalex> quchen: that doesn't sound like something short and nice in an example
06:40:03 <srhb> erm, do
06:40:15 <bernalex> srhb: yes that's what I have originally
06:40:25 <srhb> bernalex: Nothing wrong with that.
06:40:26 <ThePawnBreak> hey guys; I'm having some problems with scoping; could somebody please take a look? http://pastebin.com/Bjt29u48
06:40:51 <bernalex> srhb: I guess. it's short enough. :-)
06:41:04 <bernalex> thanks for pointing me to monad loops though! I knew something like that had to exist.
06:41:25 <srhb> ThePawnBreak: What's the problem? You're importing Board twice and the name is conflicting
06:41:32 <quchen> ThePawnBreak: Qualified imports ("import qualified Data.Foo as Foo") solve that issue.
06:41:32 <srhb> ThePawnBreak: You could qualify one of the imports.
06:41:58 <quchen> (This is a namespace issue, not a scoping one.)
06:44:50 * hackagebot exceptions 0.6 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.6 (EdwardKmett)
06:46:04 <ThePawnBreak> srhb: if I don't import it, it doesn't find the previous instance
06:46:35 <ThePawnBreak> look at the first lines, it says it doesn't find it at all
06:46:36 <srhb> ThePawnBreak: I'm not saying don't import it. I'm saying you need to disambiguate one Board from the other. You can do this by importing qualified as quchen demonstrated.
06:47:23 <ThePawnBreak> what I'm saying is that if I import it and then don't redefine it, it doesn't find it at all, and if I redefine it, it finds it twice
06:47:49 <geekosaur> and what ypu are being told is how to fix that last part
06:48:12 <ThePawnBreak> but I don't want to redefine it at all
06:48:29 <srhb> Then make sure it's properly reexported/imported from Board?
06:49:11 <ThePawnBreak> import Board
06:49:14 <ThePawnBreak> this should work, right?
06:50:23 <srhb> If Board is defined in Board, yes.
06:50:35 <ThePawnBreak> well, that's the problem; it doesn't work
06:50:45 <srhb> ThePawnBreak: Time to post some code :)
06:50:50 <ThePawnBreak> ok
06:51:17 <ThePawnBreak> second file: http://pastebin.com/7402H2ge
06:51:34 <ThePawnBreak> first file: http://pastebin.com/vxCRJ7Tw
06:54:22 <ThePawnBreak> srhb: did you take a look at the code?
06:55:36 <srhb> ThePawnBreak: I don't recall but don't you need Board(..) to export its constructors?
06:55:49 <srhb> Otherwise just the type is exported, right?
06:56:27 <srhb> Its value constructors, that is
06:58:01 <jackdempsey> hey folks, I'm working through the CIS 194 homework from UPenn as a way to learn Haskell. It's been great so far but one bit has me confused
06:58:15 <jackdempsey> in http://www.seas.upenn.edu/~cis194/hw/02-ADTs.pdf we're tasked with reading in an error.log file and processing it
06:58:33 <jackdempsey> but the types the professor lays out never mention IO so I fail to see how to wire things together correctly
06:59:10 <jackdempsey> think maybe he's assuming we'll wrap things in a main with a do block and do the readFile in there? anyone else work through these assignments?
06:59:19 <srhb> jackdempsey: I would assume as you do
06:59:29 <srhb> Keep everything pure and just use one IO action to get everything started.
07:00:09 <monochrom> no, I think the prof will do the I/O for you. you write the required pure functions, prof's tester will call yours.
07:00:13 <ajcoppa> jackdempsey: if you take a look at the Log.hs file that is included with the homework, you can use some of those functions for inspiration
07:01:05 <jackdempsey> thanks all! Yeah, I saw testParse and it doing the readFile but was unclear how to use them etc. e.g. testParse wants an int to see how many
07:01:12 <jackdempsey> dammit baby on lap
07:01:19 <jackdempsey> T}}}}}p now
07:01:38 <jackdempsey> getting him inyo FP early :-
07:01:56 <srhb> Good job!
07:01:57 <ajcoppa> jackdempsey: there's an example usage of testParse in the middle of page 3
07:03:13 <jackdempsey> ajcoppa: so assumption is that we use testParse to grab out the messages and then flow through the tree building etc with it's output huh
07:04:43 <jackdempsey> but yea actually i tried that, but testParse has a type that returns IO [message]
07:04:58 <jackdempsey> and he explains elsewhere to write functions that take [message]
07:05:24 <jackdempsey> so it seems like he either forgot or confused things (highly unlikely) or i'm supposed to get something out of the IO monad (not the way to do it right?) or…i don't know :-)
07:05:31 <dmwit> edwardk: I think you missed something big in your mtl-2.2 CHANGELOG
07:05:35 <ajcoppa> jackdempsey: which exercise are you trying to do?
07:05:44 <dmwit> edwardk: runWriterT and runStateT (at least) are gone...
07:06:04 <FUZxxl> .pl
07:06:14 <quchen> dmwit: Replaced with what? runWriter?
07:06:23 <dmwit> quchen: Dunno. That's why I'm pinging him.
07:07:59 <dmwit> Also, my local haddocks are totally broken. They claim "Control.Monad.Writer" comes from the "base-unicode-symbols" package.
07:08:08 <jackdempsey> ajcoppa: Exercise 3
07:08:11 <jackdempsey> build :: [LogMessage] -> MessageTree
07:08:35 <spockshock> anyone here programming in pascal also?
07:08:37 <jackdempsey> I can't see how to get a value of [LogMessage] only IO [LogMessage] through his functions or my own
07:09:02 <jackdempsey> and so I started rewriting everything to handle IO but that feels wrong too
07:09:06 <dmwit> jackdempsey: Writing a function of type [LogMessage] -> MessageTree does not require you to get a value of [LogMessage], I wouldn't think.
07:09:40 <dmwit> Also also, why didn't cabal rebuild the documentation for mtl when I installed mtl-2.2?
07:11:06 <jackdempsey> dmwit: not sure I follow. If I don't have a value with type [LogMessage] how would i ever use that build function?
07:11:20 <dmwit> Well, *using* the build function is a different story of course.
07:11:40 <napping> jackdempsey: are you just getting started with IO?
07:11:42 <dmwit> But, note that fmap :: ([LogMessage] -> MessageTree) -> (IO [LogMessage] -> IO MessageTree).
07:11:47 <ajcoppa> jackdempsey: are you just trying to work out how to test if your build function is correct?
07:11:57 <dmwit> So in particular fmap build :: IO [LogMessage] -> IO MessageTree
07:12:28 <napping> usually you write some [LogMessage] -> whatever, and hook it up with an IO [LogMessage] with >>= or fmap or seomthing
07:13:37 <exicer_> If I have a package that has both a library and executable, how can I, in another .cabal file, put a dependency on the library only ?
07:13:47 <dmwit> can't
07:13:51 <exicer_> bah
07:13:52 <dcoutts> exicer_: build-depends are only on libraries
07:14:00 <exicer_> Hm, really ?
07:14:10 <dcoutts> exicer_: but when a package is installed, all parts of it do get installed, so exe too
07:14:32 <jackdempsey> napping: ahh interesting
07:14:34 <exicer_> Okay, that is a bit annoying. I'm basically just using the executable for testing, is there some more appropriate way to do it ?
07:14:45 <dcoutts> exicer_: make it into a test-suite
07:14:54 * hackagebot MiniAgda 0.2014.5.5 - A toy dependently typed programming language with type-based termination.  http://hackage.haskell.org/package/MiniAgda-0.2014.5.5 (AndreasAbel)
07:14:55 <jackdempsey> ajcoppa: yeah kind of trying to use it for real. I can build a [LogMessage] directly in ghci to test but i want to run on real data
07:15:02 <jackdempsey> which brought into play the whole IO thing
07:15:05 <dcoutts> exicer_: the simplest type of testsuite is basically just an executable
07:15:24 <LysergicDreams> jackdempsey: UPenn course, wk2 ex3?
07:15:28 <exicer_> dcoutts: Fair enough.
07:15:41 <jackdempsey> LysergicDreams: yep!
07:16:02 <jackdempsey> just surprised IO mentioned no where in assignment…so either i'm doing it very wrong or missed something somewhere?
07:16:26 <napping> jackdempsey: sounds find so far - make your function take [LogMessage] and you'll be able to test it easily, and combine it into a bigger IO thing
07:16:43 <humanoyd> Hey, I'm trying to understand the isomorphism between "(forall b. (a -> b) -> f b)" and "f a". If I'm given "f a" and "(a -> b"), I simply apply fmap in order to get "f b". But I don't understand the reverse direction.
07:16:59 <jackdempsey> yea i think I'll have to proceed with an assumed "use these in a main = do wrapper" to really test
07:17:05 <ajcoppa> jackdempsey: well, you can test it without doing IO by constructing a few LogMessages manually if you like. i wrote doctests that exercise a few different cases to ensure my build method worked correctly
07:17:07 <jackdempsey> thanks very much all! Super helpful
07:17:20 <LysergicDreams> jackdempsey: I used the testParse function mention in exercise 1 to make LogMessages from the error.log
07:17:23 <ajcoppa> (not to discourage you playing around with IO to read from the log too if that's what you'd like to do)
07:17:28 <jackdempsey> ajcoppa: yeah that's pretty much where i'm at. will continue there and then see if the whole "if it compiles it works" thing holds :-)
07:17:38 <jackdempsey> LysergicDreams: right but that gives you IO [LogMessage]
07:17:42 <jackdempsey> which you couldn't just pass to build
07:17:59 <jackdempsey> so maybe he's assuming we're smart enough to know how to >>= that or something…..i'm not a student there just using these as a guide :-)
07:18:18 <jackdempsey> i think i'll continue with fake/test data and then wire together all functions…see how that goes
07:18:25 <jackdempsey> thanks again!
07:18:25 <spockshock> Gofer Standard Prelude no monads...thats a solution for some
07:18:32 <dmwit> jackdempsey: I suspect there are non-IO ways to build LogMessage's.
07:18:45 <napping> dmwit: and some have been used for testing
07:18:47 <dmwit> jackdempsey: e.g. is the data type itself completely exposed? You can just build them with the constructors, probably.
07:18:55 <ajcoppa> it is
07:18:55 <LysergicDreams> jackdempsey: In ghci you could run "x <- testParse parse..." then do "build x"
07:19:06 <dmwit> right
07:19:09 <ajcoppa> he just wants to test with the "real data" in the log files instead of made up data.
07:19:17 * dmwit nods
07:19:27 <napping> so testParse >>= build, or testParse >>= print . build
07:19:43 <napping> (depending whether build has a type like ... -> IO (), or ... -> b)
07:20:02 <ajcoppa> jackdempsey: this is orthogonal to the exercises themselves, but i highly recommend learning a bit about doctest if you haven't used it before
07:20:06 <dmwit> jackdempsey: If you're feeling motivated, write an Arbitrary instance for it and QuickCheck your function. ;-)
07:20:41 <dmwit> yaaay, haddock is working again
07:20:42 <benzrf> monads r funfunctor
07:20:43 <benzrf> *fun
07:20:56 <benzrf> i thot of a explanation
07:20:58 <napping> monads r functor too
07:21:01 <funfunctor> lol
07:21:12 <benzrf> applicatives let u join 2 functor vals into one
07:21:16 <bernalex> here's my current "guess the number" game implementation: http://lpaste.net/3253563083930468352 if anyone has ideas to make it more idiomatic and nice -- without making it much longer (preferably under 25 lines), that would be real nice!
07:21:24 <benzrf> monads let u join a NESTED functor val into a non-nested one
07:21:45 <benzrf> monads subsume applicatives becoz you can just stick one of your outer ones inside the other one and then do a monadic join\
07:21:52 <jackdempsey> ajcoppa: ok sounds good
07:22:03 <jackdempsey> dmwit: yea i definitely need to look into QC more
07:22:05 <ajcoppa> https://github.com/sol/doctest-haskell
07:22:21 <ajcoppa> you can start with doctest without heading down the quickcheck rabbit hole to start, and get into quickcheck later
07:23:04 <napping> bernalex: looks fine, besides not using some functions
07:23:14 <napping> randomRIO :: Random a => (a, a) -> IO a
07:23:30 <napping> maybe readLn :: Read a => IO a
07:24:55 * hackagebot gtk-traymanager 0.1.4 - A wrapper around the eggtraymanager library for Linux system trays  http://hackage.haskell.org/package/gtk-traymanager-0.1.4 (TristanRavitch)
07:25:43 <benzrf> lazy IO is weird
07:27:06 <ChongLi> lazy IO would be totally fine if there were no such thing as resources limits (open file handles)
07:28:12 <bernalex> napping: I was considering using RIO
07:30:47 <alanz> edwardk: I have a question about your Mealy machines
07:32:18 <napping> bernalex: it's better than using newStdGen and then just taking one value
07:32:26 <roconnor> Anyone know why Ross removed the record-style newtypes in transformers-0.4?
07:32:36 <bernalex> napping: I had some issues where the number was ridiculous... I'll reinvestigate.
07:33:21 <napping> should be the same, except randomRIO just draws from the global generator instead of splitting it
07:33:43 <jackdempsey> ajcoppa: interesting. Not familiar with doctest concepts. Cool stuff!
07:33:45 <bernalex> napping: omg I found the problem. entirely unrelated. :-P I was comparing ans to n and so outputting "too high" when it was "too low"
07:33:48 <napping> readLn is more or less just a predefined read <$> getLine
07:34:19 <dmwit> lazy IO isn't weird, just misnamed
07:34:42 <dmwit> roconnor: Was just complaining about that a few seconds ago.
07:34:54 <dmwit> roconnor: Have you managed to work out what the replacement for run*T is yet?
07:34:56 <bernalex> napping: yeah I amended that as well, to get rid of the applicative import
07:35:00 <dmwit> (Still trying to build the documentation myself.)
07:35:44 <roconnor> dmwit: it is still run*T AFAIU
07:35:54 <dmwit> ...oh?
07:36:11 <roconnor> dmwit: it just is defined outside the newtype declaration
07:36:19 <napping> roconnor: is it something to do with record overloading?
07:36:26 <roconnor> napping: is it?
07:36:43 <dmwit> roconnor: Oh, huh! But those aren't re-exported by mtl any more.
07:36:50 <benzrf> whats this about a run*T replacement
07:36:57 <roconnor> mtl
07:37:00 <napping> Well, moving an acessor from a label in a trivial record to a separate function might be done to avoid getting other overloading stuff
07:37:52 <leourbina> hello, I'm currently trying to install yesod using GHC 7.6.3 and cabal 1.20.0.0 and I'm getting the following error
07:37:58 <leourbina> http://lpaste.net/103626
07:38:38 <leourbina> authenticate fails to install for some reason
07:38:41 <roconnor> dmwit: blame edwardk
07:38:49 <leourbina> the only error it says is ExitFailure
07:38:53 <dmwit> edwardk: Okay, I understand my complaint from before now. The export WriterT(..) doesn't export runWriterT any more because of changes to transformers.
07:38:57 <dmwit> roconnor: right
07:38:58 <leourbina> not sure why
07:39:09 <dmwit> roconnor: Though, really, a subtle change like that... I still blame Ross. =)
07:39:15 <GeneralMayhem> How do I debug 'Exception: <<loop>>'?
07:39:19 <napping> leourbina: is that the install output, or from a log?
07:39:27 <roconnor> dmwit: that's fair
07:39:34 <GeneralMayhem> I've tried ghci -fbreak-on-exception with :hist, but it doesn't tell me anything super interesting
07:39:37 <tdammers> GeneralMayhem: my approach is to remove code until I know where it loops
07:40:11 <napping> leourbina: do you have a .cabal/logs/ directory?
07:40:17 <GeneralMayhem> tdammers: I've tried that
07:40:27 <GeneralMayhem> tdammers: the place it loops is retrieving a value from a record
07:40:49 <tdammers> where does that value come from?
07:40:51 <GeneralMayhem> tdammers: which makes me think it's probably something that's being compiled away when i don't use that, and i'm having trouble tracing it any farther
07:41:14 <roconnor> GeneralMayhem: typically this is caused by shadowing a variable, or making a typo.
07:41:18 <alpounet> GeneralMayhem: have you checked that you're not doing smth like: let x = ... x ...
07:41:54 <tdammers> yeah, there's probably a recursive definition somewhere that you didn't intend
07:42:38 <GeneralMayhem> yeah
07:42:47 <GeneralMayhem> just wondering if there are any other tricks to help track it down
07:43:01 <GeneralMayhem> i've been awake for about 30 hours now so maybe the trick is sleep
07:43:01 <tdammers> staring at the code sometimes works
07:43:08 <tdammers> sleep, too, yeah
07:43:18 <tdammers> and sometimes, just rewriting the thing
07:51:32 <leourbina> napping: I have a .caba
07:51:46 <leourbina> napping: I had a .cabal logs directory
07:52:04 <leourbina> napping: currently trying to do the install again on a(nother) fresh sandbox
07:52:14 <leourbina> napping: I'll post the results once it fails
07:52:40 <napping> leourbina: look in the authentication log in that directory
07:52:55 <leourbina> napping: ok, will do
08:00:03 <erisco> is TypeRep 7.8 only?
08:10:35 <kosmikus> erisco: the function "typeRep" is new in 7.8, the "TypeRep" type is not new, and is also produced by "typeOf".
08:10:50 <benzrf> :t typeOf
08:10:51 <lambdabot> Typeable a => a -> TypeRep
08:10:55 <erisco> okay thanks
08:10:59 <benzrf> :t typeRep
08:11:00 <lambdabot> Typeable a => proxy a -> TypeRep
08:11:02 <benzrf> o_o
08:11:12 <benzrf> > typeOf (Just 1)
08:11:13 <lambdabot>  Maybe Integer
08:11:18 <benzrf> o_O
08:11:23 <benzrf> :t typeOf (Just 1)
08:11:24 <lambdabot> TypeRep
08:11:27 <benzrf> yo what
08:12:15 <shachaf> Yay, lowercase proxy.
08:12:43 <benzrf> wait is that forall proxy
08:12:47 <cwraith> no
08:12:52 <benzrf> i uh what
08:12:59 <c_wraith> it's an "I don't care" proxy
08:13:00 <benzrf> > typeRep (Just 1)
08:13:02 <lambdabot>  Integer
08:13:03 <shachaf> c_wraith: ?
08:13:03 <benzrf> o_O
08:13:05 <bennofs> benzrf: lowercase proxy means it doesn't care about the proxy
08:13:11 <benzrf> > typeRep (Nothing)
08:13:12 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
08:13:12 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeRep’
08:13:12 <lambdabot>  The type variable ‘a0’ is ambiguous
08:13:12 <lambdabot>  Note: there are several potential instances:
08:13:12 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:13:15 <prophile> a potentially silly question: does GHC have any _actually_ uninhabited types (as in, excluding _|_)?
08:13:16 <c_wraith> the only thing you know about proxy is that it has kind k -> *
08:13:16 <benzrf> oO_O
08:13:23 <benzrf> u_U
08:13:24 <shachaf> typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep
08:13:31 <c_wraith> prophile: yes.  all types with kind other than *
08:13:51 <prophile> a fair observation
08:13:54 <bennofs> c_wraith: you cannot take them as function arguments though, can you?
08:13:56 <benzrf> prophile: also, Void!
08:14:05 <benzrf> data Void
08:14:07 <bennofs> > undefined :: Void
08:14:08 <lambdabot>  Not in scope: type constructor or class ‘Void’
08:14:10 <benzrf> ^uninhabited
08:14:14 <bennofs> @let data Void
08:14:14 <prophile> Void _is_ inhabited by _|_ isn't it?
08:14:15 <lambdabot>  Defined.
08:14:17 <bennofs> > undefined :: Void
08:14:18 <lambdabot>  No instance for (GHC.Show.Show L.Void)
08:14:19 <lambdabot>    arising from a use of ‘M147522281113678856029258.show_M1475222811136788560...
08:14:35 <benzrf> can _|_ truly inhabit things tho
08:14:40 <shachaf> prophile: GHC has unlifted types but they are generally inhabited.
08:14:44 <c_wraith> bennofs: that's correct. the kind of (->) requires that you be able to pass arguments to a function
08:14:45 <benzrf> what about newtypes
08:15:04 <prophile> shachaf: iirc, they're also not kinded * as c_wraith also pointed out
08:15:17 <benzrf> :k StateT
08:15:18 <lambdabot> * -> (* -> *) -> * -> *
08:15:22 <benzrf> huh
08:15:40 <prophile> shachaf: but that was the kind of thing I had in mind
08:15:44 <benzrf> @let newtype SeriouslyVoid
08:15:44 <lambdabot>  Parse failed: newtype declaration must have exactly one constructor.
08:15:47 <benzrf> laaame
08:16:28 <prophile> newtypes let you construct types that are "represented the same as" another type I think
08:16:41 <prophile> so it doesn't make sense for it to have no constructors, because there's nothing for it to have the same representation as
08:16:54 <prophile> you could do newtype SeriouslyVoid = SeriouslyVoid Void but that probably defeats the point
08:17:11 <shachaf> That's a popular pre-Haskell-2010 definition of Void.
08:17:19 <spockshock> monads are fortiori endofunctors...need a tshirt with that written on it...sure to get some blank looks
08:18:55 <benzrf> @let newtype SeriouslyVoid = SeriouslyVoid SeriouslyVoid
08:18:56 <shachaf> Yes, the main reason to learn Haskell is to confuse other people and make yourself feel smart, obviously.
08:18:56 <erisco> 1 + 1 = 2... need a tshirt with that on it. sure to get some looks :D
08:18:57 <lambdabot>  Defined.
08:18:59 <benzrf> :-D
08:19:07 <benzrf> > undefined :: SeriouslyVoid
08:19:08 <lambdabot>  No instance for (GHC.Show.Show L.SeriouslyVoid)
08:19:08 <lambdabot>    arising from a use of ‘M431221432124459994729328.show_M4312214321244599947...
08:19:11 <benzrf> aw.
08:19:35 <shachaf> prophile: Er, I misread. Never mind.
08:20:02 <prophile> benzrf: *blink*
08:20:16 <prophile> interesting
08:20:48 <spockshock> shachaf: lol, was more thinking to see if anyone m
08:27:56 <spockshock> might actually say something
08:28:14 <spockshock> but what you said is perfect
08:32:48 <spockshock> erisco: you mean 1+1 = 11
08:33:08 <erisco> is this base 1?
08:33:43 <spockshock> doesn't that happen in perl?
08:33:48 <CindyLinz> I think it is String concat.. @@"
08:33:56 <tdammers> spockshock: javascript maybe
08:33:58 <vozz> When working with the FFI, what type do you use for a pointer to something you don't need to know about? There's a function that returns a pointer to a huge struct, and I need to then pass it to another function, but I don't need to play with the struct in Haskell, so I don't want to make a huge datatype for this huge struct.
08:34:00 <tdammers> "1" + "1"
08:34:13 <tdammers> still makes more sense than PHP
08:34:26 <CindyLinz> 1 + 1 = 2 in perl, "1"+"1" = 2, too.  1 . 1 eq '1' in perl
08:34:38 <CindyLinz> eq '2'.. XD
08:34:43 <CindyLinz> eq '11'... orz
08:34:49 <tdammers> in PHP, "1" + "pizza" == 1
08:36:13 <spockshock> lol
08:36:38 <spockshock> should bring this to #proramming
08:37:02 <spockshock> oops... hungry baby on lap too
08:39:04 <identity> tdammers: That makes sense. some"one" + pizza = no more pizza.
08:39:13 <identity> That's definitely true in my case, at any rate.
08:49:09 <saml> hello
08:49:29 <albeit> Does it make sense to have a State monad a record field of another datatype? Like "data Foo = Foo { size :: Int, ...}; type FooState  = State Foo; data Bar = { type :: String, fooS :: FooState }; type BarState = State Bar"?
08:49:50 <albeit> Or is that probably leading down the wrong path?
08:50:30 <saml> where is State monad?
08:50:42 <bennofs> albeit: that very much depends on what you want to do
08:51:56 <albeit> I have a module Bar that has to maintain a Foo state, but it just calls utility functions in the Foo module over that state. It seems unncessary to wrap FooState in a BarStateT
08:52:27 <albeit> Because BarState is already wrapping another state monad (NetworkState, which itself wraps IO).
08:55:05 <saml> states are hard
08:57:04 <Javran> is MonadPlus just a Monad plus a notion of "the computation might fail"?
08:57:26 <erisco> Javran, it is Monad plus a monoid
08:57:36 <erisco> Javran, or sort of Monad + Alternative
08:58:15 <Maior> I feel uncomfortable with the definition of mplus for Maybe
08:58:58 <Javran> erisco: yeah, actually I'm trying to understand Alternative, but I can even make a simple function and pass it to "many" or "some" to see what it does
08:59:29 <erisco> well, MonadPlus is unrelated to Alternative
08:59:41 <erisco> oh sorry
08:59:50 <erisco> I read "Alternative" and my brain said "Applicative"
09:00:01 <erisco> :t many
09:00:01 <lambdabot> Alternative f => f a -> f [a]
09:00:11 <erisco> > many (Just 5)
09:00:15 <lambdabot>  mueval-core: Time limit exceeded
09:00:25 <erisco> mhm, I remember those functions were a tad strange
09:00:30 <humanoyd> Maior: It is probably because there are several possible definitions
09:00:35 <erisco> @src many
09:00:35 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:00:53 <n-dolio> Maybe isn't a type with useful many and some.
09:01:01 <awestroke> why does "many (Just 5)" time out?
09:01:27 <erisco> some v = (:) <$> v <*> many v; many v = some v <|> pure []
09:01:28 <erisco> that is why
09:01:40 <Javran> I think there's two obvious ways of making a Maybe Monoid, namely Data.Monoid.{First,Last}
09:01:46 <awestroke> is there anything that "many" does not infinite loop on?
09:01:56 <erisco> yes
09:02:00 <bennofs> > many [1]
09:02:04 <lambdabot>  mueval-core: Time limit exceeded
09:02:05 <bennofs> :|
09:02:20 <Javran> I know  "many" and "some" are used in parsec, but I can't find it anywhere else..
09:02:25 <erisco> for example, if you are writing an applicative parser, 'many' and 'some' do * and +
09:02:37 <bennofs> > many Nothing
09:02:38 <erisco> because <*> can "fail"
09:02:39 <lambdabot>  Just []
09:02:40 <bennofs> > some Nothing
09:02:42 <lambdabot>  Nothing
09:03:35 <awestroke> > some [Nothing]
09:03:39 <lambdabot>  mueval-core: Time limit exceeded
09:04:16 <awestroke> I can see no use of "many" at all right now, it times out on good input and returns some kind of mzero on "bad" input
09:04:27 <benzrf> :t many
09:04:28 <lambdabot> Alternative f => f a -> f [a]
09:04:31 <Javran> wait, all Alternatives are MonadPluses right?
09:04:32 <benzrf> o_o
09:04:34 <jorr> :i many
09:04:43 <n-dolio> You can use it with parsers, as already mentioned.
09:04:49 <benzrf> > many (Just 1)
09:04:50 <jorr> aww
09:04:52 <lambdabot>  mueval-core: Time limit exceeded
09:04:53 <erisco> Javran, no because not all Applicatives are Monads
09:04:56 <benzrf> ?!
09:04:56 <lambdabot> Maybe you meant: v @ ? .
09:05:04 <awestroke> > head $ many (Just 1)
09:05:05 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
09:05:05 <lambdabot>  Expected type: [a]
09:05:05 <lambdabot>    Actual type: Data.Maybe.Maybe a
09:05:12 <awestroke> > head $ some (Just 1)
09:05:14 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
09:05:14 <lambdabot>  Expected type: [a]
09:05:14 <lambdabot>    Actual type: Data.Maybe.Maybe a
09:05:27 <n-dolio> You can also use it with other combinations of types where you don't put something that will 'succeed forever' in as the input.
09:05:49 <Javran> erisco: but the other way around is correct?
09:06:05 <benzrf> what does many do o_o
09:06:07 <benzrf> > many Nothing
09:06:08 <erisco> Javran, all MonadPlus types can be Alternative, yes
09:06:08 <lambdabot>  Just []
09:06:24 <benzrf> @src many
09:06:24 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
09:06:28 <Javran> erisco: I see
09:06:28 <benzrf> o-o
09:06:32 <benzrf> @src Maybe many
09:06:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:06:38 <benzrf> gluh
09:06:55 <ajcoppa> lambdabot is getting pretty sassy
09:06:59 <n-dolio> erisco gave the definition 6 minutes ago.
09:07:58 <erisco> the expansion grows as follows, starting with some v:   (:) <$> v <*> (((:) <$> v <*> (some v <|> pure [])) <|> pure [])
09:09:44 <Javran> it's like the Data.Function.fix, you can't simply pass some values to it and figure out what it does..
09:09:44 <erisco> a right-biased alternative should be a simple example
09:10:00 <benzrf> what does some do then
09:10:01 <benzrf> @src some
09:10:01 <lambdabot> some v = some_v
09:10:01 <lambdabot>   where many_v = some_v <|> pure []
09:10:01 <lambdabot>         some_v = (:) <$> v <*> many_v
09:10:23 <benzrf> eh
09:10:32 <benzrf> > some (Just 1)
09:10:36 <lambdabot>  mueval-core: Time limit exceeded
09:10:38 <benzrf> :t some
09:10:38 <lambdabot> Alternative f => f a -> f [a]
09:10:42 <benzrf> :{
09:10:52 <benzrf> i fail to understand
09:10:53 <benzrf> ;-;
09:11:08 <benzrf> > fmap (take 10) $ some (Just 1)
09:11:12 <lambdabot>  mueval-core: Time limit exceeded
09:11:15 <benzrf> fie
09:11:49 <Javran> :t Text.ParserCombinators.Parsec.many
09:11:50 <lambdabot> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
09:12:25 <erisco> some (Just 1) = (:) <$> (Just 1) <*> (((:) <$> (Just 1) <*> many (Just 1)) <|> pure []) -- benzrf
09:12:47 <benzrf> u-uh
09:12:49 <benzrf> what
09:12:51 <jophish> Why isn't there a semigroup class, superclass of monoid?
09:12:57 <pranz> take 5 $ some [1,2,3]
09:12:57 <jophish> historical oversight?
09:13:03 <pranz> > take 5 $ some [1,2,3]
09:13:06 <lambdabot>  mueval-core: Time limit exceeded
09:13:08 <n-dolio> > let wat = StateT $ \l -> case l of x:xs -> Just (x,xs) ; _ -> Nothing in runStateT (many wat) [1..10]
09:13:09 <lambdabot>  Just ([1,2,3,4,5,6,7,8,9,10],[])
09:13:10 <pranz> wtf
09:13:16 <erisco> lol
09:13:17 <Lethalman> jophish, there is semigroup
09:13:21 <erisco> follow the expansion
09:13:22 <Javran> http://hackage.haskell.org/package/semigroups
09:13:29 <erisco> stop being random XD
09:14:09 <jophish> leourbina: ah, I was looking here http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Monoid.html
09:14:11 <benzrf> :t (<|>)
09:14:11 <lambdabot> Alternative f => f a -> f a -> f a
09:14:20 <benzrf> > (+1) <|> (+2)
09:14:21 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:14:21 <lambdabot>    arising from a use of ‘M458548240430623633530126.show_M4585482404306236335...
09:14:21 <lambdabot>  The type variable ‘a0’ is ambiguous
09:14:21 <lambdabot>  Note: there are several potential instances:
09:14:21 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
09:14:25 <benzrf> dang
09:14:34 <benzrf> > (++"foo") <|> (++"bar")
09:14:35 <lambdabot>  No instance for (Control.Applicative.Alternative
09:14:36 <lambdabot>                     ((->) [GHC.Types.Char]))
09:14:36 <lambdabot>    arising from a use of ‘Control.Applicative.<|>’
09:14:38 <benzrf> :|
09:14:51 <benzrf> i suppose that does not necessarily make sense
09:14:54 <pranz> functions are not alternatives
09:15:07 <pranz> [] <|> [1,2,3]
09:15:10 <pranz> > [] <|> [1,2,3]
09:15:12 <lambdabot>  [1,2,3]
09:15:20 <pranz> > [1] <|> [1,2,3]
09:15:20 <Javran> maybe Alternatives needs to "consume something"?
09:15:21 <lambdabot>  [1,1,2,3]
09:15:34 <humanoyd> If I have a function "fw :: (Functor f) => (forall b. (a -> b) -> f b) -> f a", what would be an example function that is suitable for the first argument? I can't think of any...
09:15:38 <erisco> > many []
09:15:38 <pranz> uhu
09:15:39 <lambdabot>  [[]]
09:15:43 <erisco> there is your terminating usage :P
09:15:47 <Javran> > Just 1 <|> Nothing
09:15:48 <lambdabot>  Just 1
09:15:53 <pranz> > some []
09:15:54 <lambdabot>  []
09:15:59 <Javran> > Just 1 <|> undefined
09:16:01 <lambdabot>  Just 1
09:17:16 <Javran> humanoyd: that signature looks like yoneda lemma?
09:17:22 <humanoyd> yes
09:17:24 <n-dolio> @type (`fmap` [1..10])
09:17:25 <lambdabot> (Num a, Enum a) => (a -> b) -> [b]
09:18:17 <benzrf> what is yoneda lemma >>>
09:18:19 <pranz> uh
09:18:23 <benzrf> i cannot read that type sig it confuses mero
09:18:24 <benzrf> *m
09:18:27 <pranz> forall b is a hard one
09:18:28 <benzrf> ugh typos
09:18:55 <pranz> humanoyd: can you even construct such a function?
09:19:22 <n-dolio> @type (`fmap` Just 5)
09:19:24 <lambdabot> Num a => (a -> b) -> Maybe b
09:19:25 <humanoyd> Javran: I'm reading through http://www.haskellforall.com/2012/06/gadts.html and I'm stuck with the "fw" function
09:19:43 <n-dolio> @type (`fmap` Nothing)
09:19:44 <lambdabot> (a -> b) -> Maybe b
09:19:54 <humanoyd> pranz: I don't know...but in the link above, such a function is applied to id so I guess there must be suitable functions
09:20:01 <albeit> @hoogle mzero
09:20:01 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
09:20:22 <erisco> n-dolio, you know that (`fmap` x) is (flip fmap x) or (\f x -> fmap f x) right?
09:20:42 <n-dolio> Those are all longer than (`fmap` x) :)
09:21:02 <erisco> yes I was just wondering since you were checking the types of various things :P
09:21:06 <pranz> but id is (a -> a)
09:21:12 <Javran> humanoyd: I'm also trying to understand that, now I just know (Functor f) => (forall b. (a -> b) -> f b) is somehow "the same as" f a. But this is all I have.
09:21:29 <pranz> aha
09:21:43 <merijn> Javran, humanoyd: It's actually not that tricky to see why it's "isomorphic" to 'f a'
09:21:50 <n-dolio> (`fmap` x) are all things with types of the form (forall b. (a -> b) -> f b) for some functor f.
09:21:50 <pranz> humanoyd: it says that (forall b. (a -> b) -> fb) is isomorphic
09:21:58 <Javran> f = Maybe
09:21:59 <pranz> not that the signature is (Functor f) => (forall b. (a -> b) -> f b) -> f a"
09:22:16 <merijn> Javran, humanoyd: Consider this: How many functions could possibly be "a -> b"?
09:22:27 <shachaf> pranz: Why Functor f =>?
09:22:28 <humanoyd> merijn: b^a
09:22:56 <merijn> humanoyd: How so? You're forgetting parametricity, I think
09:23:02 <pranz> shachaf: because else you wouldn't have any information at all
09:23:16 <merijn> humanoyd: 'a' and 'b' here are completely polymorphic type variables
09:23:16 <pranz> shachaf: and then it would be isomorphic to the empty type, i think
09:23:18 <Javran> forall a b. a -> b is inhabitable
09:23:30 <merijn> Javran: By what?
09:23:50 <humanoyd> merijn: I was thinking of http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
09:24:14 <merijn> humanoyd: Yes, but that is thinking of concrete, but unspecified types
09:24:32 <Javran> merijn: that's just some naive intuition like "you can't convert any type to any type"
09:25:00 <merijn> humanoyd: If I wrote "Int -> Double" then yes you could say there's any number of implementations like "f 1 = 2", etc.
09:25:12 <merijn> But now we're talking about "a -> b" for any type 'a' and 'b'
09:25:36 <humanoyd> Okay, trying to follow you :-)
09:25:37 <merijn> Personally, I see only two things that could possibly have that type "undefined" and "const undefined"
09:25:44 <merijn> :t undefined
09:25:44 <lambdabot> a
09:25:55 <merijn> :t undefined :: a -> b
09:25:56 <lambdabot> a -> b
09:26:00 <merijn> :t const undefined
09:26:01 <lambdabot> b -> a
09:26:05 <shachaf> pranz: Perhaps I barged into this conversation without context.
09:26:25 <Javran> :t (`fmap` [1,2,3])
09:26:26 <lambdabot> Num a => (a -> b) -> [b]
09:26:27 <merijn> shachaf: The Functor f came from Tekmo's blogpost
09:26:34 <pranz> hmm, what I don't understand is the id thing
09:26:46 <pranz> > id ::(forall b. a -> b)
09:26:47 <lambdabot>  Not in scope: type variable ‘a’
09:26:54 <merijn> pranz: That doesn't type check
09:26:55 <pranz> > id :: forall a. (forall b. a -> b)
09:26:57 <lambdabot>  Couldn't match type ‘a1’ with ‘b1’
09:26:57 <lambdabot>    ‘a1’ is a rigid type variable bound by
09:26:57 <lambdabot>         an expression type signature: a1 -> b1 at <interactive>:1:1
09:26:57 <lambdabot>    ‘b1’ is a rigid type variable bound by
09:26:57 <lambdabot>         an expression type signature: a1 -> b1 at <interactive>:1:1
09:27:02 <pranz> thought so
09:28:19 <merijn> pranz: So, question to you, given that there are no (sane) functions of type "a -> b" what have we learned about "f b" in "forall b. (a -> b) -> f b"
09:28:24 <Javran> I'm trying to make it more concrete by saying (Int->String) -> [String] ~ [Int]
09:29:26 <pranz> merijn: it can not be constructed, hence it is iso to the empty type?
09:29:46 <merijn> pranz: Well, I don't dare say it can't be constructed
09:29:50 <merijn> pranz: Consider
09:29:55 <merijn> :t Nothing :: Maybe a
09:29:56 <lambdabot> Maybe a
09:30:14 <shachaf> Javran: That's certainly not true.
09:30:18 <pranz> ah right
09:30:23 <merijn> pranz: You could certainly construct an "f b", provided you don't expect an actual 'b' to be inside :)
09:30:31 <shachaf> Javran: The polymorphism is the whole trick.
09:30:35 <pranz> merijn: but
09:30:50 <pranz> the type sig has forall b inside parantheses
09:30:59 <pranz> (forall b. a -> b) -> f b
09:31:15 <pranz> merijn: doesn't that mean that the function must be ismomorphic to all types?
09:31:15 <merijn> pranz: No, the parentheses for forall scope further
09:31:25 <merijn> (forall b . (a -> b) -> f b)
09:31:26 <pranz> uh
09:31:28 <pranz> polymorphic
09:31:30 <pranz> for all b
09:31:44 <merijn> The 'f b' is inside the forall
09:31:54 <pranz> oh, right
09:32:32 <Javran> shachaf: but I thought that should hold, because all the thing I did is just fix some parameters
09:32:44 <pranz> okay so, it can be constructed
09:33:08 <pranz> hmmm
09:33:35 <merijn> pranz: Basically, I say that if *you* give me a function that can take an "(a -> b)" and return a "f b", then I will give you an "f a". But your function has to work for *any* 'b' and I won't tell you which 'b' I'm picking
09:34:04 <pranz> right
09:34:37 <merijn> pranz: Now in the example "fw" I then call your function with "f id" and since "id :: a -> a" your function is going to give me exactly the "f a" I'm supposed to return
09:35:44 <merijn> Since your function "(a -> b) -> f b" had to work for "any b", it will also work if I choose 'b' to be 'a'
09:36:25 <mroman_> Need some help with System.Plugins.Load
09:36:30 <mroman_> I keep getting Prelude.undefined
09:36:50 <mroman_> I don't know why
09:37:01 <mroman_> All I know is that I have a square in my plugin.hs
09:37:12 <mroman_> and objdump -t doesn't show any entry "square" in the symbol table
09:37:34 <merijn> pranz: Although please don't ask me how this all relates to Yoneda, because I don't quite understand that yet. This is just what I figured out from the types :)
09:37:38 <shachaf> Javran: There's only one function of type (forall a. a -> a)
09:37:44 <shachaf> Javran: There are many functions of type (Int -> Int)
09:38:00 <lispy> mroman_: hi
09:38:22 <lispy> mroman_: does objdump show anything similar to square?
09:38:23 <merijn> s/only one/only one *sane*/
09:39:14 <mroman_> lispy: no, not really
09:39:33 <lispy> mroman_: can you show me your plugin.hs?
09:39:33 <Javran> but saying that a = Int, how can I make a function of type (forall r. Int -> r) at the first place?
09:39:39 <humanoyd> merijn: The problem I had with "fw" was how I could possibly define a function (forall b. (a -> b) -> f b) but I believe n-dolio gave an answer above: "`fmap` someFunctor"
09:39:48 <merijn> Javran: That was my point, you can't make one that is non-bottom
09:39:53 <lispy> mroman_: one thing you should know is that plugins has a tendency to break when new ghcs are released.
09:39:54 <Lara> Hi, not sure if this is the right place to ask, but where can I get the list of lambdabot's slap responses?  I've seen it before but it was hard to find.
09:39:58 <lispy> mroman_: what version of ghc are you using?
09:40:13 <lispy> Lara: the source for lambdabot is on github now
09:40:16 <lispy> @source
09:40:16 <lambdabot> Unknown command, try @list
09:40:18 <lispy> @list
09:40:18 <lambdabot> What module?  Try @listmodules for some ideas.
09:40:21 <merijn> humanoyd: Yeah, I was stilly playing with that too
09:40:22 <int-e> @version
09:40:22 <lambdabot> lambdabot 5.0-int-e
09:40:22 <lambdabot> git clone git://github.com/int-e/lambdabot.git
09:40:30 <albeit> If I want to pattern match against an empty Data.Vector, is there a better way than against (Data.Vector.fromList [])?
09:40:45 <int-e> (which is a fork, but github will tell you that)
09:40:57 <lispy> albeit: you can't pattern match on an empty vector.
09:41:04 <lispy> albeit: what you could do instead is use view patterns
09:41:05 <joseph07> albeit: you might want to use a guard
09:41:15 <lispy> and yeah, guards are good
09:41:20 <albeit> Okay
09:41:24 <Javran> merjin: does that mean that (forall r. a -> r) have no other sane choice but id?
09:41:25 <mroman_> lispy: 7.4.1
09:42:21 <Lara> lispy: Thanks, I'm seeing a few results for it and am not sure which the right one is, but am looking...
09:42:25 <int-e> mroman_: the obvious question is whether the module exports 'square' at all.
09:42:27 <merijn> Javran: No, that's not what it means. It means that you're not "actually" using 'r' anywhere
09:42:40 <mroman_> int-e: oh. I have to export that :D
09:42:44 <mroman_> hm. let me try that
09:42:50 <lispy> mroman_: Hmm...I need to get going. Some things to try: a) does haskell think square is exported b) do you need additional ghc flags like -dynamic c) maybe someone else here has better ideas :)
09:42:52 <shachaf> Everything makes much more sense when you start thinking of "forall" as a sort of function.
09:43:00 <lispy> Lara: the @version command
09:43:03 <lispy> @version
09:43:03 <lambdabot> lambdabot 5.0-int-e
09:43:03 <lambdabot> git clone git://github.com/int-e/lambdabot.git
09:43:09 <merijn> Javran: You can't pick "id" as id can't return "Bool" if I give it an Int
09:43:25 <int-e> mroman_: the symbol should look something like this: Plugin_square_closure
09:43:35 <mroman_> int-e: Yeah
09:43:39 <lispy> Lara: https://github.com/int-e/lambdabot/blob/master/lambdabot-novelty-plugins/src/Lambdabot/Plugin/Novelty/Slap.hs
09:43:44 <mroman_> I can see Plugin_square_closure and Plugin_square_info
09:43:53 <mroman_> loading however still yields undefined
09:44:06 <Lara> lispy: Thanks :)
09:44:28 <lispy> mroman_: good luck! sorry I couldn't stick around to help
09:44:36 <humanoyd> What would be an example for (forall r. a -> r)? Only undefined?
09:44:46 <vozz> Anyone know anything about using the FFI with a C library?
09:45:00 <Lara> I'm trying to get yano to add this to jenni
09:45:12 <Lara> Oh he's here too lol
09:45:13 <mroman_> int-e: Can System.Plugins.Load even load functions?
09:45:17 <yano> Lara: hi
09:45:19 <yano> lol
09:45:24 <jophish> So, I have a bunch of variables which each need to have their own unique number which is constant throughout the lifetime of the program. I'd also like to be able to query how many unique numbers they use.
09:45:34 <Lara> yano: Hi, the link is above, as you can see. :P
09:45:39 <prophile> humanoyd: depends on a
09:45:44 <int-e> mroman_: in principle, yes. functions are values.
09:45:48 <merijn> prophile: Not really
09:45:57 <prophile> merijn: if a = Void
09:45:57 <jophish> This seems like a good job for a state monad, at program startup assign them their numbers. I'm wondering if there's a nicer way of doing this
09:46:12 <merijn> prophile: Suppose 'a' is Bool, then what? "forall r. Bool -> r" is still a problem
09:46:13 <prophile> it's inhabited by absurd as well as _|_
09:46:21 <vanila> jophish, I was just thinking state monad too
09:46:31 <mroman_> hm
09:46:43 <mroman_> well... Prelude.undefined is a pretty useless "error message"
09:46:56 <vanila> jophish, you could actually define your own monad just as a wrapper for state but treat it as abstract
09:47:03 <jophish> It's a slight pain to have to access them through that monad though when they're essentially pure
09:47:08 <prophile> merijn: yes, it contains only _|_ if a is inhabited
09:47:09 <vanila> so that  the only opreations you export are ones that give a good interface
09:47:19 <merijn> prophile: Not so
09:47:28 <merijn> prophile: "const undefined" too :)
09:47:28 <jophish> I suppose I could construct them in a big list purely
09:47:37 <vanila> well reader monad if you never change them.. but it will be the same notation to use
09:47:37 <prophile> merijn: an excellent point
09:47:58 <merijn> prophile: Which, afaik, is what "absurd" is, no?
09:48:09 <prophile> I'm not certain?
09:48:26 <Javran> merijn: so I'm trying to understand the "isomorphic" part. so what we can do with "f a" can also be done with "forall r. (a -> r) -> f r" ?
09:48:35 <prophile> well, I guess they're equivalent, so yes
09:48:40 <prophile> with absurd just having a more restricted type
09:49:03 <int-e> I wish cabal-install came with a "run ghci in sandbox" command.
09:49:14 <humanoyd> Javran: You can obtain one from the other
09:49:17 <mroman_> especially because load doesn't return undefined
09:49:22 <merijn> Javran: isomorphic is math speak for "can losslessly be converted"
09:50:16 <merijn> Javran: natural numbers are isomorphic to [()], for example. Just define 0 to be [], 1 to be [()], 2 to be [(),()], etc. Now it's trivial to convert a natural number to [()] and vice versa
09:50:20 <Javran> (g.f.g) a = a and (f.g.f) b = b?
09:50:42 <prophile> Javran: just (f.g) a = a and (g.f) a = a
09:50:49 <ReinH> Javran: f . g = id and g . f = id
09:51:04 <ReinH> (and id a = a)
09:51:45 <humanoyd> int-e: Have you tried "cabal repl"?
09:52:01 <pranz> would "Data T = forall b. T b; f (T x) = x" be of type forall r. a -> r ?
09:52:09 <Javran> ok, so "fw" and "bw" in that blog "prove" that "(forall r . (a -> r) -> f r) ~ f a" ?
09:52:24 <merijn> Javran: right
09:52:31 <supki> int-e: latest cabal-install runs ghci in the sandbox with  cabal exec ghci
09:52:38 <int-e> humanoyd: Hmm, thanks. From its description I had not expected it to work.
09:52:44 <pranz> Javran: there is no proof in the blog that they are each others inverses, but supposedly they are
09:53:12 <supki> cabal repl also loads the whole project in it
09:53:54 <Javran> pranz: I meant you can prove in a sense because you can construct one from the other
09:54:58 <pranz> Javran: just because there are morphism between types doesn't mean they are isomorphic
09:54:58 <Eduard_Munteanu> How do you uncouple Haskell types from {database | storage}-specific definitions and access patterns when using something like 'persistent'? Any sensible alternatives to lazy I/O?
09:55:46 <Javran> pranz: I see you point, bw . fw = id and fw . bw = id is also a requirement.
09:55:48 <ReinH> Javran: head and (: []) are two such morphisms. Do they create an isomorphism?
09:56:13 <ocharles> Can any smart people see how to stop these instances overlapping? https://gist.github.com/ocharles/ddb4c006c0b0eedd42b6
09:56:15 <shachaf> in the good old days we used to say "function"
09:56:24 <ocharles> I feel like it would be obvious if I could say that two types *aren't* equal
09:57:12 <int-e> mroman_: hmm, a quick test worked fine (but using ghc 7.6.3)
09:57:47 <vanila> ocharles, what is the aim here? You don't have to explain if its complex, just curious
09:57:56 * shapr does a Quick Check
09:57:57 <Javran> ReinH: I guess no because sometimes (:[]) . head x = _|_  but head . (:[]) is safe
09:58:15 <int-e> mroman_: module Plugin (square) where square :: Integer; square=42  and then I did this in ghci: load "Plugin.o" [] [] "square" >>= \(LoadSuccess _ v) -> print (v :: Integer)
09:58:26 <ocharles> vanila: Hard to summarise... but if you're familiar with lightweight monadic regions - it's very similar to that
09:58:33 <shachaf> ocharles: Type inequality isn't really going to work.
09:58:36 <ChongLi> ocharles: github's syntax hilighting really chokes on those 's
09:58:37 <shapr> Does anyone here use Haskell on heroku, OpenStack, etc? What option has the best support for Haskell?
09:58:37 <Eduard_Munteanu> ocharles: you can't express non-equality without overlapping stuff
09:58:49 <Javran> ReinH: (:[]) . head actually drops some info as well
09:58:52 <ocharles> Eduard_Munteanu: I don't mind overlapping, but here the choice is ambiguous - that's what I want to solve
09:58:55 <ReinH> Javran: right
09:59:05 <ocharles> I have a function (withQuery) that introduces a new layer of scope, and I need to be able to use things from a parent scope in my inner scope
09:59:23 <ocharles> (or maybe it's the other way round)
09:59:35 <ocharles> So to do that I need to extend the reference so it matches the larger environment
09:59:36 <mroman_> ah
09:59:43 <mroman_> load requires a .hi file present
09:59:44 <pranz> also, head has a forall
10:00:11 <pranz> oh, but Identity a ~ a
10:00:21 <pranz> of course
10:00:30 <int-e> mroman_: Ah, I would say "obviously" but it's not that obvious.
10:01:04 <Eduard_Munteanu> ocharles: did you enable OverlappingInstances?
10:01:05 <ocharles> My first instance there is to allow me to say "Somewhere [b, c] [b, c] b = Here", while my second instance will let me say "Somewhere [a, b, c] [b, c] b = There somewhere", which would then use the first instance
10:01:10 <mroman_> int-e: "obviously?"
10:01:19 <mroman_> I would say obviously if the documentation would mention it
10:01:23 <ocharles> Eduard_Munteanu: yes, the instances overlap as the error mentions - both instances are valid once you have matching lists
10:01:31 <mroman_> I looked through the source code to find that out
10:01:51 <int-e> mroman_: "obviously" because plugins uses the ghc library to load things, just like ghci, which expects .hi-files.
10:02:07 <mroman_> I see
10:02:16 <mroman_> Well... wasn't so obvious to me then ;)
10:02:26 <int-e> mroman_: As already indicated, in retrospect it's not obvious.
10:02:42 <mroman_> Neat.
10:02:47 <int-e> mroman_: I just never expected anything different.
10:03:01 <mroman_> Now I can add module/plugin support to my interpreter
10:03:25 <mroman_> at least I hope so
10:05:13 * hackagebot directory-layout 0.6.0.1 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.6.0.1 (MatveyAksenov)
10:05:29 <int-e> mroman_: the .hi file is used to look up the actual module name; you can rename Plugin.{o,hi} to p.{o,hi} and the "square" symbol ("Plugin_square_closure") will still be found
10:06:10 <int-e> mroman_: I suppose that plugins also checks that the symbol is actually supported (rather than being included for other reasons, like supporting inlinining) but that's just guessing on my part.
10:09:23 <merijn> ocharles: That looks like it needs more type families
10:09:33 <ocharles> merijn: what are you thinking of?
10:09:37 <int-e> supki: thanks for the pointer to 'cabal exec', that will simplify testing lambdabot (I can get rid of a shell script that sets up environment variables and leave the task to cabal-install)
10:10:08 <merijn> ocharles: I'm still staring at it, trying to see what exactly it does :)
10:10:28 <ocharles> merijn: appreciated :) I can make some pretty ascii art if it would help
10:10:54 <merijn> ocharles: Basically, you're trying to recursively add "There ." until you find two environments that match, right?
10:10:59 <ocharles> that's right
10:12:06 <ocharles> https://www.irccloud.com/pastebin/pcB071pg
10:12:10 <hunt> is there a default function to map f onto (a,b)
10:12:15 <ocharles> There's a full code listing, if anyone wants to sing^wcode along
10:12:26 <hunt> or sorry (a,a)
10:12:28 <merijn> ocharles: You could use something like my type family here and trivially extend it with a value: https://gist.github.com/merijn/6130082
10:13:22 <merijn> ocharles: Lemme see if I can translate your example
10:13:44 <ocharles> merijn: I think that will just cause the overlap to have a different error, it wouldn't make GHC try another instance
10:14:16 <merijn> ocharles: My point is, I don't think you need the overlapping instance with type families
10:14:25 <ocharles> That may well be true
10:16:00 <ocharles> merijn: oh, here's an idea! a type family that chooses which of *two* type classes. If the lists are the same length, then it would use a type class that knows that, but if they are different lengths, then it would use a type class that adds "There" until they are equal
10:16:09 <ocharles> so a type family that delivers a constraint
10:17:11 <merijn> ocharles: So what exactly is this doing, other than wrapping stuff in a bunch of "There" and "Where"?
10:17:38 <ocharles> merijn: did you see the full code listing?
10:17:50 <Soft> hunt: Not sure but I think Control.Arrow might have something for that
10:18:07 <ocharles> The idea is "withQuery" introduces a new level of scope and a marker into the general environment. You can put keys in the environment, and then withQuery batches the query for you and distributes the result
10:18:48 <merijn> ocharles: I saw the link, but I was to lazy to figure out what so many lines of code were doing, so I was hoping for the executive summary
10:19:01 <ocharles> yea, understandable
10:20:08 <merijn> The recursively adding of "There" just seems so...useless?
10:20:10 <ocharles> oh damn, the two type class approach is cute, but then there's no way to actually call the method in the type class
10:20:15 * hackagebot resourcet 1.1.2.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.2.1 (MichaelSnoyman)
10:20:17 * hackagebot JuicyPixels-canvas 0.1.0.0 - Functions for drawing lines, squares and so on pixel by pixel  http://hackage.haskell.org/package/JuicyPixels-canvas-0.1.0.0 (eax)
10:20:51 <merijn> ocharles: My main point is that this looks like it's more complicated than it should be, but I can't really tell what you're *actually* trying to do
10:20:55 <ocharles> merijn: if the outer scope is [a] then the inner scope is [b, a]. If I have a pointer to [a], then I need to extend that to be [b, a]
10:21:06 <ocharles> because the environment has to be the same size
10:22:18 <zcd> if i'm getting a build error of "ambiguous usage of catch (Prelude.catch vs Control.Exception.catch)" in a cabal install, is there a way to resolve this by changing the source?
10:22:44 <ReinH> zcd: import Prelude hiding (catch) if you want Control.Exception.Catch
10:22:46 <ReinH> or vice versa
10:23:03 <zcd> where can i find the src for the package?
10:23:15 <ReinH> zcd: the source of what?
10:23:29 <zcd> i'm trying to install xmobar through cabal
10:23:40 <zcd> so the source should be around somewhere
10:23:56 <srhb> zcd: cabal unpack xmobar
10:24:02 <ocharles> merijn: think I got it
10:24:22 <ocharles> nstance (EmptyKeyList kvs', kvs ~ kvs') => Somewhere ('KV k v ': kvs) ('KV k v ': kvs') ('KV k v) where
10:24:27 <srhb> zcd: Also cabal-install fetches everything from hackage, so you can also find it there manually.
10:24:29 <ocharles> The key seems to be to expand kv to ('KV k v)
10:24:41 <zcd> ok, thanks
10:24:52 <ChongLi> zcd: you might actually want to pull from github
10:24:56 <ChongLi> https://github.com/jaor/xmobar
10:25:10 <ChongLi> and then make a branch and submit a pull request
10:25:17 <ChongLi> if it's not already fixed by the author, of course
10:26:17 <merijn> ocharles: \o/
10:26:17 <zcd> hmm good idea
10:26:45 <ocharles> merijn: if this actually works, then I've just solved 18 hours work in about 2 hours by rewriting it ~_~
10:27:38 <jophish> vanila: I came up with this: http://lpaste.net/103630
10:27:57 <jophish> It's pretty ugly though because it separates the variable name and the string it represents
10:28:36 <jophish> (and having to provide a type for each of them is a little sucky)
10:31:15 <ocharles> merijn: holy shit, it *does* work
10:31:21 <ReinH> ocharles: sounds pretty standard
10:31:25 <ocharles> ReinH: haha
10:32:48 <albeit> Is there a simpler way to get multiple fields from a State Monad than "foo <- gets getFoo; bar <- gets getBar; baz <- gets getGaz"? (Without getting the entire structure)
10:33:32 <Eduard_Munteanu> albeit: 'lens' gives you a bunch of State-related combinators
10:33:41 <Eduard_Munteanu> :t (.=)
10:33:42 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
10:34:03 <Eduard_Munteanu> :t uses
10:34:04 <lambdabot> (MonadState s m, Profunctor p) => Optical p (->) (Const r) s s a a -> p a r -> m r
10:34:12 <awestroke> :t using
10:34:13 <lambdabot> Not in scope: ‘using’
10:34:13 <jophish> For anyone else interested, I'm trying to generate a list of identifiers from a list of unique numbers and some other data. Here's what I've got so far, but I think it's pretty ugly: http://lpaste.net/103630
10:34:17 <awestroke> :t use
10:34:18 <lambdabot> MonadState s m => Getting a s a -> m a
10:34:50 <albeit> Okay
10:35:06 <awestroke> :t gets
10:35:07 <lambdabot> MonadState s m => (s -> a) -> m a
10:36:20 <Eduard_Munteanu> > runState (_1 .= 5) (1, 3)
10:36:21 <lambdabot>  ((),(5,3))
10:36:35 <awestroke> :t %=
10:36:36 <lambdabot> parse error on input ‘%=’
10:36:43 <awestroke> :t (%=)
10:36:43 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
10:36:47 <Eduard_Munteanu> > runState (do { _1 .= 5; _2 .= 7 }) (1, 3)
10:36:48 <lambdabot>  ((),(5,7))
10:41:37 <bernalex> uhm what's "<-" called? I've never needed to name it before.
10:41:44 <prophile> paul
10:42:01 <bitemyapp> bernalex: it's sugar for bind.
10:42:11 <ChongLi> bernalex: yeah I've always called it bind
10:42:12 <bernalex> bitemyapp: yes I know, but what is it called?
10:42:17 <ChongLi> despite >>= also being bind
10:42:18 <bitemyapp> bernalex: ...bind?
10:42:30 <bernalex> OK I call >>= bind but have never called <- bind before
10:42:39 <Ralith> <- is just sugar for >>=, so...
10:42:51 <Cale> "is the result of executing"?
10:42:58 <Eduard_Munteanu> <- is also a binder. :)
10:43:01 <MagneticDuck1> no, it's sugar for >>= \<value> ->
10:43:03 <Cale> "left arrow"?
10:43:04 <MagneticDuck1> so...
10:43:13 <MagneticDuck1> bind 'n' lambda
10:43:13 <Cale> "from"?
10:43:14 <bernalex> I'm writing a commit msg
10:43:28 <Cale> "<-"?
10:43:31 <bernalex> I want to say that the foo in "foo <- bar" is misleading
10:43:53 <bernalex> so if it were let foo = bar, I'd say "Fix misleading let expression"
10:44:04 <bernalex> so maybe just "Fix misleading bind" or something
10:44:14 <Eduard_Munteanu> Misleading assignment perhaps.
10:44:22 <bernalex> it's not assignment
10:44:33 <Eduard_Munteanu> Or binder / binding.
10:45:00 <albeit> If I have "data Foo = Bar | BazBee", is there a way to automatically implement Read and Show, but have the string versions lower camel case? Like "bar" and "bazBee"
10:45:11 <ChongLi> then again
10:45:13 <Cale> albeit: no
10:45:18 * hackagebot monad-logger 0.3.6.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.6.1 (MichaelSnoyman)
10:45:41 <ChongLi> I call let ... = ... in "binding"
10:45:44 <ChongLi> "let binding"
10:45:56 <ChongLi> err
10:46:08 <ChongLi> that maybe a bit confusing way to word it
10:46:39 <ChongLi> basically everything in Haskell is either a type, a pattern, a variable binding or an expression
10:46:42 <vozz> Anyone good with FFI? If I've got a C function that takes a uint8_t array, what should I be passing it in the FFI in haskell?
10:46:55 <ChongLi> or a declaration of some kind, obviously
10:47:06 <ChongLi> (data type, new type, class, instance)
10:47:23 <roconnor> dmwit: I think maybe I'll blame cabal for not telling edwardk that his export list has changed.
10:47:45 <ReinH> ChongLi: then I guess you should call it a "let expression"? :p
10:47:52 <merijn> vozz: Word8
10:47:59 <ChongLi> ReinH: the whole thing is the let expression
10:48:04 <merijn> vozz: Well, "Ptr Word8"
10:48:09 <ChongLi> but each use of = is a binding
10:48:14 <ReinH> ChongLi: that's fair
10:48:21 <vozz> merijn: How do I convert a [Word8] to Ptr Word8?
10:48:47 <merijn> vozz: Foreign.Marshal.Utils
10:49:10 <vozz> merijn: aahhhh, thanks!
10:49:15 <merijn> vozz: And Foreign.Marshal.Array and Foreign.Marshal.Alloc
10:51:03 <awestroke> albeit: sounds trivial to implement yourself
10:51:11 <mausch> about aeson + generics: isn't it unsafe to tie record field names to JSON output?
10:51:13 <awestroke> nvm that was a while ago
10:51:49 <mausch> can't refactor without making a breaking change in JSON output
10:52:48 <mausch> but I couldn't find anyone mentioning this, which seems weird
10:52:59 <albeit> awestroke: I just have a bunch of data constructors, was hoping not to have type them all out.
10:54:21 <heath> when should you use a where statement versus just using a definition that is already in the file?
10:54:38 <albeit> Is there a way to "overlap" Show and Read implementations? To simplify "instance Show Foo where show Bar = "bar"; instance Read Foo where readsPrec _ "bar" = [(Bar, "")]"?
10:54:44 <heath> alos, hello #haskell! :)
10:55:53 <shapr> heath: it's mostly a matter of style
10:56:03 <shapr> heath: but also depends on whether you want to reuse that chunk of code in other functions in the file
10:56:20 <pranz> heath: if the function is trivial enough or does not have a use case outisde I would say
10:56:22 <shapr> heath: where or let are local to that function definition, maybe you don't want that.
10:56:36 <mmachenry> heath: It can be a matter of style but where (like let) provides encapsulation
10:56:51 <mmachenry> Top-level definition provides the ability to, for example, write a separate unit test.
10:57:01 <lambdabot> heath: hello from #haskell
10:59:48 <heath> thanks for the feedback shapr, pranz, and mmachenry
11:00:12 <mausch> anyone using aeson + GHC.generics ?
11:00:26 <mmachenry> heath: I generally will use where if my expression depends on stuff passed into the function and a top-level otherwise.
11:00:33 <jfischoff> mausch: all the time
11:00:44 <bjorkintosh> has anyone here read hutton's programming in haskell?
11:00:56 <jfischoff> mausch: what’s your question?
11:01:03 <leourbina> I'm still having issues trying to install yesod
11:01:12 <mausch> jfischoff: don't you have issues tying record field names to JSON output? it doesn't seem to be refactor-safe
11:01:13 <leourbina> under the .cabal-sandbox/logs/build.log I get the following
11:01:25 <leourbina> http://lpaste.net/103631
11:01:39 <leourbina> any clues why authenticate would fail to install?
11:01:42 <mmachenry> If it's dependent you need to use where or pass arguments and passing arguments is going to muddle the clarify not to mention it's a tad less efficient. But top-level if it's not dependent is nice because I can test separately and also won't need to refactor if I need it elsewhere.
11:01:43 <mausch> jfischoff: can't refactor without making a breaking change in JSON output, right?
11:01:44 <jfischoff> mausch: not it not refactor safe.
11:01:45 <pranz> bjorkintosh: only skimmed it in my public library
11:01:57 <leourbina> I'm doing it in a fresh sandbox using GHC 7.6.3 and cabal 1.20.0.0
11:01:59 <bjorkintosh> i was wondering why it had a chapter on functional parsers.
11:02:01 <pranz> bjorkintosh: seemed to cover a lot
11:02:38 <pranz> bjorkintosh: because parsers are a great example where functional programming works wonders
11:02:40 <mausch> jfischoff: do you start with generics to speed up coding, then switch to manually defined instances later?
11:02:49 <jfischoff> mausch: yes
11:02:54 <bjorkintosh> hmm. i see.
11:03:23 <mausch> jfischoff: thanks for confirming my thoughts about it! :)
11:03:27 <jfischoff> np
11:03:42 <leourbina> does anyone have experience installing yesod?
11:04:18 <jfischoff> leourbina: yes
11:04:40 <leourbina> jfischoff: I have been trying to install it for a while now
11:04:45 <jfischoff> leourbina: are you using a sandbox?
11:04:49 <leourbina> jfischoff: yes
11:04:58 <jfischoff> what version of ghc?
11:05:05 <leourbina> jfischoff: I'm using cabal 1.20.0.0 using a fresh sandbox and GHC 7.6.3
11:05:23 <jfischoff> paste the error
11:05:25 <jfischoff> @hpaste
11:05:25 <lambdabot> Haskell pastebin: http://lpaste.net/
11:05:29 <leourbina> jfischoff: Looking at the logs I get this
11:05:35 <leourbina> jfischoff: http://lpaste.net/103631
11:06:15 <leourbina> jfischoff: the terminal output is this http://lpaste.net/103626
11:06:49 <jfischoff> heh yeah something the bounds are bad … somewhere
11:07:16 <leourbina> jfischoff: that's what I figured but I haven't been able to actually figure out where
11:07:26 <jfischoff> let me look
11:07:29 <jfischoff> one sec
11:07:31 <leourbina> jfischoff: thanks
11:07:34 <skypers> ok
11:07:36 <skypers> I have to admit
11:07:45 <skypers> happstack rocks so HARD
11:07:56 <srhb> skypers: Yeah, it's awesome. :)
11:08:18 <jfischoff> leourbina: did you `cabal update` ?
11:08:21 <jfischoff> before installing?
11:08:25 <skypers> I might have an issue with stylesheets, then I just create a route for them, serveDirectory
11:08:30 <skypers> I’m not sure it’s the correct way to do
11:08:41 <srhb> skypers: Just so.
11:08:48 <skypers> oh? nice then
11:09:01 <leourbina> jfischoff: I did and installed the latest version of cabal-install available
11:09:05 <srhb> skypers: I generally have a static/ url path that I serve all that kind of stuff from
11:09:08 <skypers> I really love the way I can use Blaze and work on reponse as an ease
11:09:12 <leourbina> jfischoff: that was last night, I can try again though...
11:09:18 <skypers> srhb: yeah, I use assets
11:09:22 <jfischoff> well cabal install is not what concerns me …
11:10:02 <leourbina> jfischoff: agreed, but still
11:10:13 <sagittarian> is there a way to automatically get a list of the constructors for a typeclass?
11:10:21 * hackagebot mtl 2.2.0.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.2.0.1 (EdwardKmett)
11:10:23 <skypers> constructors, typeclass?
11:10:35 <jfischoff> I think you need the latest version authenticate, 1.3.2.8
11:10:38 <skypers> you might want to say methods?
11:10:50 <leourbina> ok
11:10:58 <leourbina> let me try to force that
11:11:02 <leourbina> I'll try
11:11:09 <sagittarian> like if i have data Suit = Clubs | Diamonds | Hearts | Spades, I want to get [Clubs, Diamonds, Hearts, Spades] without retyping all that
11:11:42 <srhb> sagittarian: I don't know if that's possible.
11:11:51 <ChongLi> sagittarian: make it an instance of the Enum class
11:11:58 <Eduard_Munteanu> sagittarian: derive Enum and Bounded, then do [minBound..maxBound]
11:12:03 <srhb> Oh, right.
11:12:14 <sagittarian> thanks, Eduard_Munteanu!
11:12:26 <skypers> huhu
11:12:42 <skypers> > [minBound..maxBound] :: [Maybe Int]
11:12:43 <lambdabot>  No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Types.Int))
11:12:44 <lambdabot>    arising from the arithmetic sequence ‘GHC.Enum.minBound .. GHC.Enum.maxBou...
11:12:44 <lambdabot>    arising from a use of ‘GHC.Enum.minBound’
11:12:48 <skypers> > [minBound..maxBound] :: [Bool]
11:12:49 <lambdabot>  [False,True]
11:13:09 <skypers> > [minBound..maxBound] :: [Either ()]
11:13:11 <lambdabot>  Expecting one more argument to ‘Data.Either.Either ()’
11:13:11 <lambdabot>  Expected kind ‘*’, but ‘Data.Either.Either ()’ has kind ‘* -> *’
11:13:12 <skypers> > [minBound..maxBound] :: [Either () ()]
11:13:13 <lambdabot>  No instance for (GHC.Enum.Enum (Data.Either.Either () ()))
11:13:14 <lambdabot>    arising from the arithmetic sequence ‘GHC.Enum.minBound .. GHC.Enum.maxBou...
11:13:14 <lambdabot>    arising from a use of ‘GHC.Enum.minBound’
11:13:29 <skypers> > [minBound..maxBound] :: [()]
11:13:30 <lambdabot>  [()]
11:13:43 <ChongLi> > [minBound..maxBound] :: [Word8]
11:13:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:14:03 <jfischoff> what is the flag for telling cabal for using a special constraint? —constraint=? or something
11:14:51 <srhb> jfischoff: Not sure, but a simpler way might be to explicitly add that package version to the list of packages requested for installation
11:15:51 <jfischoff> leourbina: cabal install —allow-newer=authenticate --constraint="authenticate==1.3.2.8" yesod
11:16:08 <jfischoff> —max-backjumps=-1 might help too
11:16:38 <sagittarian> huh, something like [Clubs..Spades] doesn't work, but [(Clubs)..(Spades)] does
11:16:46 <sagittarian> is that fixable or do I just have to live with it?
11:17:51 <jfischoff> sagittarian: try [Clubs .. Spades]
11:17:52 <Eduard_Munteanu> sagittarian: that sounds really odd
11:18:02 <Eduard_Munteanu> Oh.
11:18:05 <Eduard_Munteanu> Right.
11:18:11 <Gurkenglas> () represents the empty tuple rite?
11:18:28 <sagittarian> jfischoff, that works, thanks
11:18:44 <srhb> ô_o
11:18:58 <Eduard_Munteanu> Gurkenglas: I wouldn't call it empty tuple, rather "unit".
11:19:14 <sagittarian> what is it talking about when it says a section must be enclosed in parentheses?
11:19:15 <pranz> Gurkenglas: you can see it that way, but the purpose of () is to have a type with only one value
11:19:16 <srhb> Doesn't matter much what you call it though.
11:19:43 <Gurkenglas> Yes, that's the only thing I would use empty tuples for and it makes a whole lot of sense so I hoped this was true
11:19:52 <Gurkenglas> Any reason I should think of it as "unit" instead?
11:20:14 <Eduard_Munteanu> sagittarian: it interprets A..B as A.. B, as in (.) from A.
11:20:33 <roconnor> Gurkenglas: if you think of types as algebra then () is 1.
11:20:44 <Eduard_Munteanu> > id Prelude..id $ 2
11:20:45 <lambdabot>  2
11:20:56 <Gurkenglas> Oh, that meaning of unit. Yea okay.
11:21:02 <Eduard_Munteanu> > [Prelude..id]
11:21:03 <lambdabot>  A section must be enclosed in parentheses thus: (Prelude.. id)
11:21:10 <Gurkenglas> Is there an empty type?
11:21:25 <roconnor> Gurkenglas: not in the prelude, but it is called Void.
11:21:25 <Eduard_Munteanu> Gurkenglas: Void, but it's not standard
11:21:28 <pranz> Gurkenglas: also that () is the unit object in the monoidal category (Hask, (,), ())
11:21:37 <sagittarian> as in A.. is interpreted as (.) ((.) A)?
11:21:46 <Eduard_Munteanu> {-# LANGUAGE EmptyDataDecls #-}   data Void
11:22:02 <Eduard_Munteanu> sagittarian: no
11:22:12 <roconnor> Eduard_Munteanu: no pragma needed for haskell 2010?
11:22:25 <Eduard_Munteanu> sagittarian: it interprets it as a qualified name for (.), from A.
11:22:45 <sagittarian> oh i see
11:22:46 <Eduard_Munteanu> Oh, it's in 2010? Nice.
11:22:47 <sagittarian> thanks
11:22:52 <Gurkenglas> The group theory group (Haskell expressions, comma operator, empty tuple)? Huh...
11:23:01 <Gurkenglas> > ((2,3),4)
11:23:03 <lambdabot>  ((2,3),4)
11:23:05 <Eduard_Munteanu> :t (Prelude..) -- sagittarian
11:23:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:23:15 <Gurkenglas> *monoid
11:23:26 <Gurkenglas> > (,) (2,3) (4)
11:23:27 <lambdabot>  ((2,3),4)
11:23:31 <pranz> :k () -- Gurkenglas
11:23:32 <lambdabot> *
11:23:36 <pranz> :k (,) -- Gurkenglas
11:23:38 <lambdabot> * -> * -> *
11:23:41 <Eduard_Munteanu> :t (Control.Monad.>>=) -- sagittarian
11:23:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:23:42 <pranz> * is Hask
11:23:46 <Gurkenglas> :k
11:23:53 <Gurkenglas> @k
11:23:53 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind v @ ? .
11:23:56 <Gurkenglas> @help k
11:23:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:24:00 <Gurkenglas> :help k
11:24:02 <Gurkenglas> :h k
11:24:07 <Gurkenglas> :k --help
11:24:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:24:09 <Eduard_Munteanu> @kind Maybe
11:24:10 <lambdabot> * -> *
11:24:17 <Gurkenglas> @help kind
11:24:17 <lambdabot> kind <type>. Return the kind of a type
11:24:25 <Gurkenglas> Well thank you lambdabot
11:24:39 <tobiasgw> hoogle doesn't seem to support searches like "all functions that return a ByteString", or "all functions that takes Text as one of its arguments". Is that correct?
11:25:02 <pranz> Gurkenglas: 5 :: Int :: *
11:25:17 <Gurkenglas> :t *
11:25:18 <lambdabot> parse error on input ‘*’
11:25:24 <vozz> merijn: I tried to call new on a [Word8], but it says there's no instance for storable [Word8]... What am I doing wrong?
11:25:24 <pranz> Gurkenglas: so * is the kind of haskell types
11:25:26 <Gurkenglas> :t Int
11:25:27 <lambdabot>     Not in scope: data constructor ‘Int’
11:25:27 <lambdabot>     Perhaps you meant one of these:
11:25:27 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
11:25:30 <Gurkenglas> :k *
11:25:31 <lambdabot> parse error on input ‘*’
11:25:36 <ion> > 5 :: (Int :: *)
11:25:37 <prinsen> If you have a list of actions (IO ()) and the interval in which they each should be run, how would you solve that? The actions can't block the other actions from starting
11:25:37 <lambdabot>  5
11:25:47 <Eduard_Munteanu> tobiasgw: for the latter, 'Text -> a' might work
11:25:59 <Gurkenglas> > 5 :: (Int::(*::*))
11:26:00 <lambdabot>  <hint>:1:13: parse error on input ‘*::*’
11:26:01 <Eduard_Munteanu> @hoogle Text -> a
11:26:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:26:02 <lambdabot> Prelude id :: a -> a
11:26:02 <lambdabot> Data.Function id :: a -> a
11:26:03 <pranz> Gurkenglas: you can see (*) as a category
11:26:06 <Eduard_Munteanu> :/
11:26:12 <pranz> and types as it's object
11:26:20 <Gurkenglas> *objects
11:26:23 <ion> > 5 :: (Int :: (* -> *))
11:26:23 <tobiasgw> Eduard_Munteanu:
11:26:24 <lambdabot>  Expecting one more argument to ‘GHC.Types.Int’
11:26:24 <lambdabot>  Expected a type, but ‘GHC.Types.Int’ has kind ‘* -> *’
11:26:40 <tobiasgw> Eduard_Munteanu: :/
11:26:45 <ion> lambdabot: liar
11:26:50 <Gurkenglas> > (*2) :: (Int->Int::(*->Int*))
11:26:51 <lambdabot>  <hint>:1:21: parse error on input ‘*->’
11:26:52 <Gurkenglas> > (*2) :: (Int->Int::(*->*))
11:26:54 <lambdabot>  <hint>:1:21: parse error on input ‘*->*’
11:27:01 <Gurkenglas> > (*2) :: ((Int->Int)::(*->*))
11:27:02 <lambdabot>  <hint>:1:23: parse error on input ‘*->*’
11:27:09 <Gurkenglas> > (*2) :: ((Int->Int)::( * -> * ))
11:27:10 <lambdabot>  Expecting one more argument to ‘GHC.Types.Int -> GHC.Types.Int’
11:27:10 <lambdabot>  Expected a type,
11:27:10 <lambdabot>    but ‘GHC.Types.Int -> GHC.Types.Int’ has kind ‘* -> *’
11:27:29 <ion> Int -> Int :: *
11:27:30 <tobiasgw> Eduard_Munteanu: I think that kind of functionality would be awesome. The syntax could be ":: -> ByteString" for anything that returns ByteString
11:27:46 <pranz> :k ((->) Int)
11:27:47 <lambdabot> * -> *
11:27:52 <tobiasgw> and ":: Text ->" for anything that takes a Text arg
11:27:56 <pranz> :k (String -> Int)
11:27:57 <lambdabot> *
11:28:17 <Gurkenglas> :k ((->) String Int)
11:28:18 <lambdabot> *
11:28:24 <prinsen> If you have a list of actions (IO ()) and the interval in which they each should be run, how would you solve that? The actions can't block the other actions from starting
11:28:25 <Gurkenglas> :k (->)
11:28:26 <lambdabot> * -> * -> *
11:28:55 <tobiasgw> prinsen: interval as in time interval?
11:29:03 <Gurkenglas> Guessing: main = map main' eriugvnhreigt
11:29:04 <prinsen> tobiasgw: yes
11:29:09 <Gurkenglas> main' x = ...
11:29:13 <pranz> Gurkenglas: type constructors are just morphisms on *
11:29:30 <prinsen> tobiasgw: a list with 100 actions that needs to be run every thenth second
11:30:09 <tobiasgw> prinsen: but you don't care about the time interval *between* the 100 actions?
11:30:20 <Gurkenglas> pranz, are functions objects as well as morphisms?
11:30:23 * hackagebot yesod-core 1.2.15.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.15.1 (MichaelSnoyman)
11:30:31 <Gurkenglas> *elements of objects
11:30:51 <pranz> Gurkenglas: yes
11:30:59 <napping> Gurkenglas: should be, having exponentials
11:31:02 <pranz> since functions can map functions to other functions
11:31:05 <ReinH> or no, depending on what category you are talking about
11:31:16 <Gurkenglas> napping, "having exponentials"?
11:31:17 <ReinH> in the category of kinds they are neither
11:31:19 <tobiasgw> prinsen: like so: Wait 10 secs; do 100 actions; wait 10 secs; do 100 actions; ?
11:31:20 <prinsen> tobiasgw: think [(a, 10), (b, 1)], a should be run every thenth second, b should be run every second
11:31:30 <tobiasgw> prinsen: ahaaa
11:31:36 <tobiasgw> :)
11:31:44 <vozz> What would be the easiest way to turn a String into [Int8]?
11:31:47 <Gurkenglas> ReinH, Iirc they were talking about the category * of types
11:32:06 <prinsen> if the actions themselfs take longer than the interval there might be a problem, but that *wont* happen
11:32:17 <ReinH> * is a kind
11:32:21 <pranz> well, the category of kinds only exist of * and Constraint
11:32:51 <ReinH> pranz: what category are you refering to then?
11:33:10 <Gurkenglas> vozz, guessing: \string -> map f string where f is some way to turn the chars into the correct numbers?
11:33:10 <pranz> ReinH: the category of types, *
11:33:19 <napping> Gurkenglas: an exponential object for objects A,B is some object B^A which is more or less equivalent to the morphisms from A -> B
11:33:40 <ion> prinsen: Spawn a thread for each.
11:33:57 <Eduard_Munteanu> :t map fromEnum :: String -> [Int8]
11:33:58 <lambdabot>     Couldn't match type ‘Int’ with ‘Int8’
11:33:58 <lambdabot>     Expected type: Char -> Int8
11:33:58 <lambdabot>       Actual type: Char -> Int
11:34:00 <ReinH> pranz: ok, then functions are not objects or arrows in the category of types.
11:34:07 <prinsen> ion: a flare?
11:34:08 <vozz> Eduard_Munteanu: thanks!
11:34:26 <Eduard_Munteanu> :t map fromIntegral :: String -> [Int8]
11:34:27 <lambdabot>     No instance for (Integral Char)
11:34:27 <lambdabot>       arising from a use of ‘fromIntegral’
11:34:27 <lambdabot>     In the first argument of ‘map’, namely ‘fromIntegral’
11:34:27 <pranz> ReinH: yes, they are
11:34:28 <Gurkenglas> napping, "more or less equivalent"? If I have an isomorphism from A to A', is A'->A' an exponential object for A,A?
11:34:31 <Eduard_Munteanu> Gr.
11:34:34 <ReinH> pranz: how?
11:34:38 <pranz> ReinH: types are objects in the category of types, obviously
11:34:46 <Eduard_Munteanu> :t map (fromIntegral . fromEnum) :: String -> [Int8]
11:34:47 <ReinH> pranz: functions are values
11:34:47 <lambdabot> String -> [Int8]
11:35:00 <ReinH> (->) is a type constructor
11:35:02 <tobiasgw> prinsen: I'm no expert in this, but I think Control.Concurrent is highly relevant
11:35:06 <tobiasgw> prinsen: http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent.html
11:35:17 <merijn> Eduard_Munteanu: ...
11:35:27 <ion> Also potentially http://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html
11:35:42 <merijn> Eduard_Munteanu: Did you seriously just recommend fromEnum as a way to get from String to [Int8]?
11:35:46 <tobiasgw> prinsen: you could spark off one thread for each action and use threadDelay or something like that for the waiting
11:35:51 <ReinH> `id' is not an object or a morphism of *
11:35:55 <pranz> ReinH: oh right
11:35:58 <ReinH> (->) is
11:36:25 <Eduard_Munteanu> merijn: um, I did... any issues with that?
11:36:45 <prinsen> tobiasgw ion: It seems like a good solution
11:36:53 <Eduard_Munteanu> Actually I can't think of another way right now.
11:36:54 <pranz> well, (a -> b) is atleast
11:37:05 <skypers> dammit
11:37:06 <skypers>     Couldn't match type `GLModel'
11:37:07 <skypers>                   with `ID SurfaceRenderer -> f0 (ID SurfaceRenderer)'
11:37:16 <skypers> is there anyway to know how GHC infers type?
11:37:23 <ReinH> pranz: are the objects types of kind *?
11:37:26 <skypers> I have _no_ idea where it takes the function from
11:37:55 <pranz> ReinH: you can't have a value of (->)
11:38:02 <Gurkenglas> There should be an IRC client that keeps track of who has been replying to whom and prepend colors to the posts from parallel conversations
11:38:08 <pranz> ReinH: so (->) isn't really a type on it's own, right?
11:38:22 <jfischoff> it is a type
11:38:31 <tobiasgw> prinsen ion: async looks easier to use, but I'm not sure how to achieve waiting for a given time with it
11:38:37 <Eduard_Munteanu> (->) :: * -> * -> *, more or less
11:38:45 <pranz> but is it a type then?
11:38:54 <skypers> I know where it expects the function, but I don’t know why it expects that
11:39:00 <pranz> I thought only things with kind * are types
11:39:01 <merijn> Eduard_Munteanu: Well, it's going to result in blatantly wrong behaviour, for one
11:39:04 <Eduard_Munteanu> Depends on the meaning of "type". Some use "type" for inhabited types only.
11:39:18 <ion> You don’t use async for the timing, you use it for handling potential exceptions nicely.
11:39:21 <jfischoff> values can only have type *
11:39:25 <ReinH> Eduard_Munteanu: this is why I'm trying to clarify
11:39:40 <ion> You do the timing using the usual IO stuff.
11:39:40 <napping> Gurkenglas: Here's a real definition: http://ncatlab.org/nlab/show/exponential+object
11:39:44 <Eduard_Munteanu> > map (fromIntegral . fromEnum) "ABC"
11:39:45 <lambdabot>  [65,66,67]
11:39:47 <pranz> well, undefined can't be a value of something with a higher type, can it?
11:39:48 <merijn> Eduard_Munteanu: I don't think telling people to do something that is very obviously wrong is very constructive, unless you're an evil djinn trying to fullfill the letter of the law without the spirit
11:39:49 <vozz> Hmm... Complaining that [CUChar] isn't storable, I thought that would work given that CUChar is storeable
11:40:00 <pranz> > undefined :: Maybe
11:40:01 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
11:40:02 <lambdabot>  Expected a type, but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
11:40:03 <ReinH> Only types of kind * are inhatibed.
11:40:09 <ReinH> *inhabited
11:40:16 <pranz> > undefined :: (Maybe :: * -> *)
11:40:18 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
11:40:18 <lambdabot>  Expected a type, but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
11:40:26 <pranz> allright
11:40:37 <ReinH> So are the objects of this category types of kind *?
11:40:42 <Eduard_Munteanu> merijn: why are you saying it's wrong? (I didn't suggest bad things on purpose, in case that turns out to be the case.)
11:40:45 <merijn> Eduard_Munteanu: So someone asking how to pass a "uint8_t array" from haskell followed by asking "How do I convert String into [Int8]" is probably doing something wrong
11:41:04 <merijn> Eduard_Munteanu: Well, It will silently truncate everything > 127, for one
11:41:19 <merijn> > 9759275 :: Int8
11:41:20 <lambdabot>  43
11:41:28 <ion> vozz: [CUChar] is not a continuous block of CUChars in memory, it’s a linked list.
11:41:28 <pranz> ReinH: I was thinking so
11:41:35 <Eduard_Munteanu> > 257 :: Int8
11:41:36 <lambdabot>  1
11:41:36 <codygman> How difficult would it be to make something that translates mongo/mysql queries back and forth?
11:41:38 <merijn> > fromEnum (maxBound :: Char)
11:41:39 <lambdabot>  1114111
11:41:42 <ReinH> pranz: and morphisms are type constructors (kind * -> *)
11:41:45 <Eduard_Munteanu> > 254 :: Int8
11:41:46 <lambdabot>  -2
11:41:54 <merijn> > fromIntegral fromEnum (maxBound :: Char) :: Int8
11:41:56 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Char -> GHC.Int.Int8))
11:41:56 <lambdabot>    arising from a use of ‘GHC.Real.fromIntegral’No instance for (GHC.Enum.Enu...
11:41:56 <lambdabot>    arising from a use of ‘GHC.Enum.fromEnum’
11:41:56 <lambdabot>  The type variable ‘a0’ is ambiguous
11:41:56 <lambdabot>  Note: there are several potential instances:
11:42:04 <pranz> ReinH: ah, I see
11:42:08 <merijn> > fromIntegral (fromEnum (maxBound :: Char)) :: Int8
11:42:09 <lambdabot>  -1
11:42:10 <pranz> ReinH: that leads to a contradiction
11:42:14 <ReinH> pranz: how so?
11:42:15 <vozz> ion: Hmm.. how do I go about storing an array of chars?
11:42:23 <ion> vozz: In what encoding?
11:42:25 <Eduard_Munteanu> merijn: I missed the uint8_t thing.
11:42:34 <pranz> because then (* -> * -> *) can't be a morphism, if (* -> *) isn't a type
11:42:43 <merijn> vozz: Foreign.Marshal.Array has "Storable a => [a] -> Ptr a"
11:43:00 <vozz> merijn: Ah, that's what I'm looking for, thanks!
11:43:06 <codygman> Maybe I could abuse (just use?) persistent somehow to translate mongo/sql queries?
11:43:19 <ion> Note: that may not be what you’re looking for.
11:43:24 <merijn> Eduard_Munteanu: Any answer of "Char" to "anything other than Integer" should probably involve ByteString/encoding at some point
11:43:27 <pranz> I guess the only natural way to look at it is to treat higher-kinded things as types too
11:43:34 <ReinH> pranz: not in this category, no
11:43:39 <ReinH> pranz: but I wasn't sure what category you meant by *
11:43:43 <ReinH> so I have defined one
11:43:46 <ReinH> well, started to
11:43:50 <ReinH> we haven't defined composition yet
11:44:12 <merijn> vozz: The problem you will encounter is that Char in haskell is a unicode codepoint which can have values of up to 65k (or whatever it is nowadays), however uint8_t in C will only accept values between 0 and 255
11:44:23 <merijn> vozz: So you need to decide how to combine these world views
11:44:46 <Guest61598> http://lpaste.net/65486 <- i get exactly this error when i try to generalize my IO function to MonadIO
11:44:46 <ReinH> > maxBound :: Char
11:44:47 <merijn> vozz: Do you really have a String to begin with?
11:44:48 <lambdabot>  '\1114111'
11:44:58 <Guest61598> any idea why? i dont understand it :(
11:45:13 <Gurkenglas> > maxbound
11:45:14 <lambdabot>  Not in scope: ‘maxbound’
11:45:14 <lambdabot>  Perhaps you meant ‘maxBound’ (imported from Prelude)
11:45:19 <Gurkenglas> > maxBound
11:45:21 <lambdabot>  ()
11:45:22 <pranz> ReinH: data H f g x = H (f (g x))
11:45:25 <pranz> works I suppose?
11:45:38 <merijn> Gurkenglas: readProcess is IO, not MonadIO
11:45:42 <merijn> eh
11:45:49 <merijn> s/Gurkenglas/abh
11:46:06 <pranz> but that has a strange kind
11:46:13 <abh> merijn: what does that mean
11:46:13 <pranz> so maybe not
11:46:17 <sebzim4500> How come there are so few properties in Data.ZZ ?
11:46:18 <Gurkenglas> Ooh, a nice abbreviation that probably expresses sorrow over mishighlighting me
11:46:19 <abh> sorry, i am a noob
11:46:26 <Eduard_Munteanu> Guest33246: you need to liftIO
11:46:31 <abh> i thought IO implements MonadIO
11:46:33 <Eduard_Munteanu> Er.
11:46:37 <merijn> abh: Well, your type signature claims to return "MonadIO m => m (Title,Body)"
11:46:38 <Eduard_Munteanu> It does.
11:47:03 <sebzim4500> oops wrong irc
11:47:10 <Eduard_Munteanu> abh: you can instantiate MonadIO to IO but not the other way around, not directly anyway.
11:47:25 <abh> Eduard_Munteanu: then should changing all IO t to MonadIO m => m t work automatically?
11:47:30 <merijn> abh: Whereas readProcess is "IO whatever", so your type signature has to be IO, OR you need to lift the IO to be "more general"
11:47:55 <Eduard_Munteanu> abh: no, because a lot of functions still use IO directly, and need liftIO
11:47:57 <Eduard_Munteanu> :t liftIO
11:47:58 <lambdabot> MonadIO m => IO a -> m a
11:48:03 <merijn> abh: This should be simplest: http://lpaste.net/65486
11:48:13 <ion> vozz: Data.Text.Foreign.withCStringLen :: Text -> (CStringLen -> IO a) -> IO a encodes into UTF-8 before calling the function. Or if you have already encoded the text into the encoding of your choice, Data.ByteString.useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a, or the Unsafe variant if your IO action doesn’t mutate the value.
11:48:15 <Eduard_Munteanu> It's also more complex if they take IO arguments.
11:48:18 <merijn> abh: Rather than lifting the result, lift the entire computation
11:48:27 <abh> Eduard_Munteanu: oh, so i put a liftIO in front of all IO functions and that should fix it?
11:48:44 <abh> merijn: like liftIO $ do --- rest of code ?
11:48:57 <Eduard_Munteanu> abh: yes, or you could write getBOFHExcuses = liftIO $ do ... in this case
11:48:58 <merijn> abh: Yeah, see my annotation on your code
11:49:08 <abh> checking
11:49:09 <Gurkenglas> :t (->)
11:49:09 <lambdabot> parse error on input ‘->’
11:49:25 <ReinH> Gurkenglas: (->) is not a value
11:49:33 <Gurkenglas> Yes, I was testing that
11:49:46 <merijn> abh: The beauty of the way do notation works is that you can just treat the block as values and call lift/liftIO on an entire block :)
11:50:25 * hackagebot transformers-compat 0.2 - A small compatibility shim exposing the new types from transformers 0.3 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.2 (EdwardKmett)
11:50:30 <Gurkenglas> If we have a category with all types as objects and (->) gives a morphism from each object, then the kind *->* must also be an object, since (->) leads there from any object
11:50:36 <Gurkenglas> *from any type
11:50:39 <saml> yes
11:51:11 <YellowOnion> Am I missing something "Module `Network.Socket.ByteString.Lazy' does not export `send'"
11:51:12 <ReinH> pranz: btw, type constructors do not have kind * -> *. That was a mistake. They have kind P -> Q where P and Q are kinds.
11:51:19 <ReinH> pranz: so (->) is a type constructor
11:51:41 <ReinH> where P = * -> * and Q = *
11:51:58 <ReinH> er the other way around
11:52:03 <abh> merijn: thanks. let me change my code and see if it works
11:52:03 <ReinH> P = * and Q = * -> *
11:52:46 <ReinH> Gurkenglas: what is this category? What are its objects and morphisms? What is composition?
11:52:48 <pranz> ReinH: ah, right
11:53:11 <abh> merijn: also, which MonadIO to use? the one in Control.Monad.Trans or the one in Control.Monad.IO.Class ?
11:53:48 <Gurkenglas> ReinH, I was assuming that the types are some of the objects and the (->) are some of the morphisms and trying to deduce a closure
11:54:48 <ReinH> Gurkenglas: (->) is not the arrow in * -> *
11:55:30 <Gurkenglas> Is * -> * included in *?
11:55:40 <Eduard_Munteanu> Gurkenglas: no
11:55:42 <merijn> abh: They're the same
11:55:52 <merijn> abh: One just re-exports the other :)
11:56:06 <Gurkenglas> How do we call the union of all terms generated by combinations of (, ), * and ->?
11:56:11 <merijn> abh: Personally I prefer Control.Monad.Trans, but it doesn't matter
11:56:24 <ReinH> Gurkenglas: where does (,) come in?
11:56:47 <Gurkenglas> "( ) * ->", no (,)
11:56:52 <ReinH> ah
11:57:06 <ReinH> Gurkenglas: * is a kind. * -> * is a kind.
11:57:22 <rschulman> since posixSecondstoUTCTime takes POSIXTime, but getPOSIXTime returns IO POSIXTime, what's the best way to chain them together? Still trying to wrap my head around IO monad.
11:57:23 <abh> merijn: it worked!
11:57:43 <abh> i dont understand this monad transformer stuff well enough yet
11:57:44 <ReinH> abh: now you can remove the liftIO and just use IO! :D
11:57:47 <Eduard_Munteanu> Note * -> k unifies with both * -> * and * -> * -> * though.
11:57:57 <abh> ReinH: why?
11:58:02 <Gurkenglas> I can't think of a polite way to say "I don't think that answer my question." except this one.
11:58:07 <Gurkenglas> *ed
11:58:19 <YellowOnion> is there a way to 'send' LazyByteStrings over a socket?
11:58:20 <ReinH> abh: because you don't need MonadIO for this.
11:58:21 <roconnor> rschulman: trick question!  Use getCurrentTime. :P
11:58:42 <abh> ReinH: why?
11:58:53 <Gurkenglas> How do we call the union of all kinds that unify with k?
11:59:01 <ReinH> abh: because you're just doing IO, and if someone else wants to lift that to MonadIO they can use liftIO themselves.
11:59:19 <pranz> Gurkenglas: the category of kinds, perhaps?
11:59:22 <ReinH> you aren't making any use of the generality of MonadIO
11:59:27 <Eduard_Munteanu> MonadIO is more convenient if you already use MonadIO for other stuff though.
11:59:33 <Gurkenglas> pranz, I mean the category of elements of kinds
11:59:55 <abh> ReinH: oh, the function is a plugin kind of thing, i decide the type sig and others write it
12:00:00 <abh> so i want it to be general
12:00:02 <pranz> Gurkenglas: aha
12:00:02 <ReinH> Eduard_Munteanu: I guess I'm thinking like a library writer :)
12:00:21 <merijn> abh: Well, the problem you had was as follows: Your type signature "MonadIO m => m (Title, Body)" claimed to work for *any* instance of MonadIO. However, since readProcess returned a value of type "IO String" (or whatever, too lazy to check) the entire do block has to be "IO" (the entire do-block must be in the same monad), do you see how that is a problem?
12:00:28 <abh> ReinH: does that make sense?
12:00:30 <pranz> Gurkenglas: types and type constructors, but I don't think they form a category
12:00:42 <roconnor> rschulman: see http://hackage.haskell.org/package/time-1.1.4/docs/src/Data-Time-Clock.html#getCurrentTime if you want to know the answer to your question.
12:00:43 <pranz> or well
12:00:43 <ReinH> abh: Yes, although I don't understand why IO isn't general enough
12:00:45 <pranz> yes, they probably do
12:00:48 <merijn> abh: What the error was saying is "you said this'd be polymorphic, but it isn't because readProcess is in IO!"
12:00:53 <rschulman> roconnor: Hah, I will try that.
12:00:59 <Eduard_Munteanu> ReinH: I wish lib writers used MonadIO more often :(
12:01:00 <rschulman> roconnor: still in IO, though
12:01:10 <ReinH> Eduard_Munteanu: but it means an extra dep...
12:01:11 <pranz> also constraints are included in that group
12:01:20 <roconnor> rschulman: no value can ever leave the IO.
12:01:22 <abh> merijn: hmm. that makes sense.
12:01:23 <ReinH> pranz: how?
12:01:33 <roconnor> rschulman: you just keep on binding more and more functions onto it.
12:01:36 <abh> merijn: how does liftIO fix that though?
12:01:37 <pranz> ReinH: Constraint is a kind
12:01:37 <merijn> abh: So the solution in this case is to, either specify the type IO OR lift the entire do block into MonadIO m, by liftIO. Or third option, specify the entire do block as IO and then liftIO the entire thing in one go
12:01:42 <Eduard_Munteanu> ReinH: a rather conservative dep though
12:01:43 <merijn> :t liftIO
12:01:43 <ReinH> afaik kinds form a monoid
12:01:44 <lambdabot> MonadIO m => IO a -> m a
12:02:01 <rschulman> roconnor: So if I'm trying to take that time and put it in a data structure, I have to make the data be IO UTCTime, I take it?
12:02:04 <ion> rschulman: See fmap
12:02:08 <ReinH> er, since * isn't *-> *, they form a category, yes
12:02:14 <roconnor> rschulman: nope
12:02:41 <roconnor> rschulman: you will bind a function to produce an IO YourDataStructure.
12:02:46 <pranz> I think I must take a walk now, a little bit too tired :)
12:02:49 <merijn> abh: liftIO can lift an IO action into *any* MonadIO type, so since you're entire block has as result a value of "IO (Title, Body)" liftIO turns that into "MonadIO m => m (Title, Body)"
12:02:54 <pranz> ReinH, Gurkenglas: thanks for the interesting discussion
12:03:08 <ReinH> Eduard_Munteanu: good to know :)
12:03:17 <Gurkenglas> Soo, was distracted. Now for a chat archive binge.
12:03:29 <abh> merijn: that makes sense. i am starting to understand this transformer business now
12:04:14 <roconnor> rschulman: this is easier with do notation:  do { currentTime <- getCurrentTime;  return (MyConstructor currentTime) } :: IO MyDataStructure
12:04:30 <ReinH> the category of kinds is pretty boring though
12:04:33 <abh> ReinH: what if the implementer wants to use StateT IO monad in their function? MonadIO will work but not IO
12:04:41 <vamega> Hi
12:04:53 <ReinH> abh: why wouldn't IO work?
12:04:54 <Gurkenglas> Okay in that category of elements of kinds, the homomorphisms shall include (->) which goes from each object to an object that unifies with k->l, correct me if I'm inconsistent
12:05:05 <abh> ReinH: uh, because state?
12:05:08 <ReinH> abh: if you can liftIO then so can they
12:05:08 <vamega> I was wondering why cabal repl would suggest that a function I've defined doesn't exist.
12:05:15 <ion> fmap :: (UTCTime -> MyDataStructure) -> IO UTCTime -> IO MyDataStructure
12:05:29 <vamega> I cant seem to autocomplete it when I do :t and hit tab.
12:05:34 <vamega> Main.main shows up
12:05:37 <ReinH> although IO is a trivial MonadIO so it's not a *problem* to use MonadIO since it can still be used for IO
12:05:40 <Gurkenglas> *to every object that unifies with k->l
12:05:41 <merijn> abh: The implementer could just call liftIO on your function, though? :)
12:05:41 <vamega> but Main.getCssMap doesn't
12:05:57 <roconnor> rschulman: this do block is means "getCurrentTime >>= (\currentTime -> return (MyConstructor currentTime))".
12:06:19 <vamega> Nvm
12:06:26 <vamega> Did a clean and built again and it worked
12:08:21 <abh> merijn: hmm. i need to think about this carefully
12:08:25 <rschulman> roconnor: Yeah, ok, I think I get that. What I can't do is just use Message {timestamp = getUTCTime, ... }
12:08:43 <abh> rschulman: because nothing escapes from IO
12:08:47 <pranz> ReinH: oh right, the reason i restricted the categories objects to * kinded types was because they then form a monoidal category with (,) and ()
12:09:05 <roconnor> rschulman: right, you have to use do notation or some equivalent.
12:09:22 <ReinH> pranz: the category if kinds is as boring as it is simple. Objects are kinds. Arrows are... arrows. if P and Q are kinds then P -> Q is also a kind.
12:09:25 <EvanR> you can store getUTCTime in a record, if you want
12:09:28 <ReinH> *of
12:09:35 <EvanR> but not execute it
12:09:43 <roconnor> rschulman: (\time -> Message {timestamp = time}) <$> getUTCTime -- another solution.
12:09:49 <ReinH> composition is done in the obvious way
12:09:54 <Gurkenglas> Scratch that last line. The homomorphisms shall include all objects that unify with a->b, going from a to b
12:10:10 <roconnor> EvanR: I didn't want to confuse the issue with IO callbacks at this point. :)
12:10:28 * hackagebot hsexif 0.3.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.3.0.0 (EmmanuelTouzery)
12:10:30 * hackagebot contravariant 0.5.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.5.1 (EdwardKmett)
12:10:42 <rschulman> roconnor: Ok, thanks. I'll try a couple things and see what I can make work.
12:10:47 <EvanR> i find this aspect of haskell very useful
12:10:52 <abh> roconnor: or fmap Message getUTCTime
12:11:09 <Gurkenglas> The composition of two homomorphisms shall be simple function composition
12:11:19 <Gurkenglas> So. I don't see where this blows up.
12:11:52 <ReinH> iow the category of kinds is just a free category iinm
12:12:06 <Gurkenglas> "iow", "iiinm"?
12:12:10 <Gurkenglas> -i
12:12:14 <ReinH> in other words, if I'm not mistaken
12:12:16 <roconnor> rschulman: abh's suggestion of "Message <$> getUTCTime" is fairly concise.
12:12:49 <Gurkenglas> free category=easy to obtain and/or probably devoid of useful theorems?
12:13:11 <Gurkenglas> Also I think you mean the category of elements of kinds.
12:13:32 <ReinH> Gurkenglas: the free category is the category that results from freely concatenating arrows together whenever the target of one arrow is the source of the next
12:13:39 <rschulman> I have to rethink anyway. What I'm doing now is just a placeholder, eventually the entire structure is going to come from parsing json that came from an http request, so the entire thing is going to have to be in IO, I'm guessing.
12:13:57 <Gurkenglas> ReinH, ayup
12:14:10 <roconnor> rschulman: do notation is probably the way to go.
12:14:48 <ReinH> Gurkenglas: it is free because it is constructed by a free functor
12:15:13 <ReinH> the free functor from quivers to small strict categories
12:15:30 <ReinH> (a quiver is a multidigraph)
12:16:02 <Dynetrekk> hi, how can I build pandoc reasonably painlessly on Arch linux? cabal install fails (some random package crashes); pacman does not contain pandoc; etc etc
12:16:56 <EvanR> im getting a lot of papers using language of dependent types, is there a good introduction of typical features assumed to exist in a dependent type system?
12:17:08 <Gurkenglas> The back of my brain is telling me that if I was told of a heuristic that tells me my idea isn't useful, I shouldn't try to target the measure (by doing something like deliberately restricting the homomorphisms that can be concatenated according to some elegant-in-hindsight rule) because otherwise the measures will cease to be effective and I'll have nothing to tell me when to change direction. So I'll probably stop here un
12:17:09 <Gurkenglas> til I find an actual reason to bring category theory into this
12:18:23 <roconnor> Dynetrekk: you can install Nix, then nix-env -i haskell-pandoc-ghc7.6.3 :D
12:19:27 <Gurkenglas> (Or wait. Is there any useful theory built up around free categories?)
12:20:31 <Dynetrekk> roconnor: nix? that keeps popping up every few years. is it in an interesting/useful state now?
12:21:08 <cwraith> let me just double-check this..  Cofree Maybe is a non-empty list?
12:21:11 <roconnor> Dynetrekk: I've been using NixOS for 3-4 years
12:21:22 <srhb> Dynetrekk: pandoc installs for me on Arch with everything up to date
12:21:27 <srhb> (as far as I can see)
12:21:50 <Dynetrekk> roconnor: the actual Linux distro?
12:22:05 <Dynetrekk> srhb: wtf, how? did you add extra mirrors/pacman servers?
12:22:10 <roconnor> natuurlijk
12:22:15 <Dynetrekk> srhb: using the default mirrors, no
12:22:18 <Dynetrekk> roconnor: dutch?
12:22:24 <roconnor> naturally
12:22:27 <srhb> Dynetrekk: Which ghc/cabal version?
12:22:40 <roconnor> sorry; I like that word.
12:22:46 <Dynetrekk> srhb: don't know, lemme see... 7.8.2
12:22:49 <Dynetrekk> ghc
12:22:57 <Dynetrekk> roconnor: no worries, I understand
12:23:45 <srhb> Dynetrekk: Ah yes, I have the haskell-core repo. Not sure what difference it should make though
12:24:20 <merijn> roconnor: Can you pronounce it properly too? I have yet to see the mythical native English speaker that doesn't bollocks it up :p
12:24:28 <Dynetrekk> srhb: breaking and complaining, is what it did for me
12:24:43 <Dynetrekk> haskell-core, that is, so I removed it and uninstalled the packages, srhb
12:24:46 <srhb> Dynetrekk: Tried installing it in a sandbox?
12:24:51 <srhb> pandoc, that is
12:24:52 <Dynetrekk> srhb: sandbox? new to me
12:25:06 <roconnor> merijn: I wouldn't be able to tell if I could;
12:25:09 <Dynetrekk> srhb: sorry, not a haskell programmer (dabbled a bit in 2008, but no more)
12:25:12 <srhb> Dynetrekk: cabal unpack pandoc; cd pandoc-...; cabal sandbox init; cabal install -j
12:25:25 <Dynetrekk> srhb: hm. this is too complex
12:25:29 * hackagebot quickcheck-property-monad 0.2.1 - quickcheck-property-monad  http://hackage.haskell.org/package/quickcheck-property-monad-0.2.1 (BennoFuenfstueck)
12:25:37 <srhb> Dynetrekk: Three commands. :)
12:25:38 <Dynetrekk> srhb: it's not just for me. I'm looking for a way for others to install it
12:25:42 <srhb> Ah
12:25:49 <Dynetrekk> srhb: building from source is suboptimal in itself
12:25:56 <Dynetrekk> srhb: perhaps on non-arch distros, it is fine
12:25:57 <roconnor> merijn: The word convey's a certain sense that "of course" doesn't.
12:26:00 <Dynetrekk> with e.g. apt-get
12:26:03 <srhb> Dynetrekk: I would think so, yes
12:26:04 <roconnor> merijn: at least to me.
12:26:17 <merijn> roconnor: Well, I'd translate it as "Naturally" rather than "of course"
12:26:52 <Dynetrekk> srhb: weird that the haskell-core repo fucks everything up so badly
12:27:05 <srhb> Dynetrekk: I haven't had problems with it.
12:27:14 <Dynetrekk> srhb: I get 100 lines of error messages iwth pacman after installing pandoc, and pandoc itself is broken, too
12:27:21 <roconnor> merijn: I don't think "Naturally" is used so often in this way in North American English.
12:27:53 <merijn> roconnor: That's a loss for the people speaking North American English ;)
12:28:00 <roconnor> indeed.
12:29:16 <roconnor> merijn: I always think of it being said in the voice of the girl from the Postbank commercial.
12:29:21 <roconnor> Grrrr...
12:29:23 <Dynetrekk> srhb: I'm currently at home, will have a look at work instead
12:29:38 <roconnor> merijn: ... it appears there is no more Postbank
12:29:43 <roconnor> :(
12:30:50 <merijn> roconnor: It's ING nowadays, and they replaced my nice 7 digit bank number with this IBAN atrocity being perpetrated on us innocent civilians...
12:31:49 <tdammers> they replaced *all* the nice bank account numbers
12:31:59 <tdammers> and frankly, they did a shitty job
12:32:12 <tdammers> because the postbank/ING account numbers *still* don't have a checksum
12:32:45 <tdammers> you'd think that with bank account numbers that long, a single extra digit couldn't have hurt
12:32:56 <pavonia> Don't all IBANs have a checksum?
12:32:59 <tdammers> but noooooo, we need a billion zeroes in there
12:33:05 <tdammers> pavonia: you wish
12:33:10 <merijn> tdammers: But then I would have to actually memorise a new number rather than a stupid fixed prefix for my old number
12:33:15 <Eduard_Munteanu> Or they could use hex digits.
12:33:43 <pavonia> tdammers: I thought that's what the two digits after the country code are for
12:33:56 <Eduard_Munteanu> (or any alphanumeric digits really)
12:35:30 * hackagebot th-lift-instances 0.1.2 - Lift instances for template-haskell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1.2 (BennoFuenfstueck)
12:35:57 <slashfoo> hey guys, I'm having a bit of trouble trying to install 'temporary-1.2.0.2 package and I wanted to know if there were any pointers on where to look to solve this. I'm kinda new to haskell. gist: https://gist.github.com/slashfoo/6e525a178ca60e3f7e88
12:36:23 <slashfoo> 'temporary' isn't the target really, but that's what's failing from me wanting to install pandoc via cabal
12:39:32 <predator117> slashfoo: if you only want to install pandoc, using cabal sandboxes might be easier
12:39:59 <predator117> not sure if this helps in that case though
12:40:31 * hackagebot tagged-transformer 0.6.4 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6.4 (MatveyAksenov)
12:41:21 <supki> slashfoo: cabal install temporary --constraint='exceptions < 0.6'
12:41:36 <slashfoo> supki: let me try
12:42:35 <slashfoo> supki: that worked, I guess I should open an issue on the github for temporary, no?
12:43:48 <supki> slashfoo: yeah, they should update the package to build with the latest exceptions
12:46:31 <defanor> http://hackage.haskell.org/package/invertible-syntax seems very nice, but it also seems to be unfinished/abandoned/just a proof of concept; why is that? are there any alternatives, or caveats, or smth?
12:47:41 <tdammers> pavonia: nope... afaik, those are just a code for the bank or some such IIRC
12:47:45 <ReinH> Gurkenglas: btw I'm pretty sure that category is isomorphic to the natural numbers with addition: 0 ~ *, 1 ~ * -> *, 2 ~ * -> * -> *, ... I think there's a name for this sort of category. Simplex? Something?
12:48:48 <pdxleif> So, how does this explain monads, again? https://pbs.twimg.com/media/Bm5SIQOIcAAoc5Q.jpg:large
12:48:51 <pavonia> tdammers: I checked the wiki page, it is a checksum :p
12:49:01 <Eduard_Munteanu> ReinH: what is (* -> *) -> * ?
12:49:12 <ReinH> Eduard_Munteanu: oh yeah. Crap.
12:49:32 <tdammers> pavonia: ok then, I stand corrected
12:49:38 <ReinH> Eduard_Munteanu: um. Annoying? :p
12:49:40 <slashfoo> supki: thanks for the help
12:49:51 <Eduard_Munteanu> :D
12:49:55 <ReinH> pdxleif: it's obviously a space burrito. I don't see what the problem is.
12:50:00 <ReinH> Not sure why there's a cat though.
12:50:58 <abh> CatT
12:51:03 <ReinH> Ah right.
12:55:52 <pdxleif> ReinH: I guess I'm just so used to cats as the tool to explain FP that I didn't even notice. http://spl.smugmug.com/Humor/Lambdacats/
12:58:39 <vozz> I'm writing a binding to a C library, and something that should be fairly simple is spitting out gobbledygook: https://github.com/ollieh/haskell-tox-core/blob/master/Tox/Core.hs c_tox_get_address takes two pointers, and writes a string to the second one. toxGetAddress is supposed to return that string, which is 64 alphanumeric characters, but its returning weird symbols and undrenderable characters... Can anyone spot what I've 
12:58:44 <Yaniel> <3 taht ghc kitteh
13:00:53 <albeit> @hoogle isNothing
13:00:53 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
13:01:59 <Gurkenglas> ReinH, (*->*)->* = *->(*->*)?
13:02:09 <Gurkenglas> Oh, I should have read that first.
13:02:11 <Anders_> <html></html>
13:02:42 <Sculptor> that looks like pinocchio asci art
13:02:52 <zq_> http://spl.smugmug.com/Humor/Lambdacats/i-4TGvqCj
13:02:59 <zq_> :t foldl
13:03:00 <lambdabot> (b -> a -> b) -> b -> [a] -> b
13:03:04 <Gurkenglas> Well, let's see what we can identify the kinds with, forgetting for the moment that we are actually operating on the elements of kinds as the objects, not the kinds as the pbjects
13:03:08 <Gurkenglas> *objects
13:03:21 <ReinH> Gurkenglas: nope, the arrow isn't associative
13:04:28 <Gurkenglas> * is the inductive start. Any two objects generate a third object that is different from all objects generated by any other pair.
13:06:18 <Gurkenglas> Lets call K0={*} and Kn+1=Kn union {a->b|a,b from Kn}
13:06:27 <Gurkenglas> *for all n
13:06:49 <Gurkenglas> Our set of objects is the union over all n of Kn
13:08:37 <Gurkenglas> Sooo its countable at least
13:08:49 <Gurkenglas> (Obviously since each object corresponds to a string)
13:09:59 <dmwit> Surely in a category whose objects are kinds, the obvious choice for arrows would be *types*.
13:10:18 <dmwit> By analogy to the category Hask, where objects are types and arrows are values.
13:10:36 <Gurkenglas> Not constructors?
13:10:49 <dmwit> No. Otherwise composition isn't well defined.
13:10:56 <Gurkenglas> Sure, we can put that down as another category to talk about. Never enough categories.
13:11:01 <dmwit> (The composition of two constructors is not a constructor.)
13:11:08 <Gurkenglas> It is not?
13:11:26 <dmwit> Not the way the Report defines constructors.
13:11:55 <Gurkenglas> Well the obvious fix would be to have the arrows be all finite compositions of constructors, but that would be a little cheaty.
13:11:55 <dmwit> You say: "another category to talk about". I wasn't aware that a first one had been defined. What is the first proposal?
13:12:25 <dmwit> One may turn any graph into a category by considering paths in the graph to be the arrows, yes.
13:12:56 <Gurkenglas> Not sure, we're pinning it down (I was actually talking about the category of all the elements of kinds, with the homomorphisms being functions, but people keep overhearing the elements of part)
13:13:43 <Gurkenglas> Wait, what I was actually wanting to talk about has already been defined as Hask? Yay.
13:14:41 <vandenoever> to get an idea of haskell file parse speed, i tried this simple program: http://paste.kde.org/p1a3iu7ak
13:14:52 <vandenoever> unf, it's 20x as slow as the c equivalent
13:15:07 <vandenoever> are there ways to speed it up?
13:15:35 <dmwit> Did you compile with -O2? Did you get the same answer as the C equivalent?
13:15:45 <Gurkenglas> So, about your first point: you mean (*->)->*->* has an arrow named A->B to *->*?
13:16:13 <Gurkenglas> (correction: (*->*)->*->* has an arrow named A->B to *->*?)
13:16:13 <dmwit> (*->)->*->* doesn't look like a well-formed kind to me.
13:16:39 <vandenoever> dmwit: yes and yes
13:16:40 <dmwit> But I suspect the answer to your question is "no".
13:16:52 <Gurkenglas> Make me get it then :3
13:16:58 <vanila> what's the fromIntegral for? are you just adding up the bytes of a file
13:17:02 <Rhayve> Hey, might I ask some Haskell noob questions with regards to a simple function I'm trying to write?
13:17:05 <bennofs> vandenoever: try adding a type signature to the 0, like (0 :: Int). I suspect it's defaulting to Integer
13:17:14 <monochrom> vandenoever: use LS.foldl' , not LS.foldl
13:17:14 <dmwit> vandenoever: Also, why foldl instead of ldl'?
13:17:25 <dmwit> lost a few characters there
13:17:35 <dmwit> Gurkenglas: Maybe is an arrow from * to *.
13:17:48 <Gurkenglas> Rhayve, I guess we won't be offended any more by that than by metaquestions
13:18:04 <vandenoever> bennofs: wow, that is big difference indeed! from 2s to 400ms
13:18:11 <Gurkenglas> dmwit, does * contain *->*?
13:18:16 <vandenoever> dmwit: because i'm a beginner at haskell
13:18:18 <dmwit> Gurkenglas: No.
13:18:22 <bennofs> vandenoever: I think GHC warns about that with -Wall
13:18:28 <srhb> Rhayve: Ask away!
13:18:32 <vanila> bennofs++ awesome
13:18:33 <Gurkenglas> Is Maybe also an arrow from *->* to *->*?
13:18:47 <dmwit> Gurkenglas: No.
13:18:49 <dmwit> :k Maybe
13:18:49 <lambdabot> * -> *
13:18:56 <dmwit> :k StateT
13:18:57 <lambdabot> * -> (* -> *) -> * -> *
13:19:02 <Rhayve> Well, I'm trying to write a function that returns an Element from a list at the n-th index, but I keep getting compiler errors: safeIndex :: [b] -> Integer -> Maybe b safeIndex xs n = 	if n `elem` xs then (xs !! (n-1)) 		else Nothing
13:19:08 <Gurkenglas> :t Maybe (+2)
13:19:09 <lambdabot> Not in scope: data constructor ‘Maybe’
13:19:14 <dmwit> Gurkenglas: So StateT is an arrow from * to (* -> *) -> (* -> *).
13:19:15 <Gurkenglas> Huh. Weird.
13:19:25 <dmwit> Maybe is a type. (+2) is a value.
13:19:30 <dmwit> Levels can't mix.
13:19:32 <dmwit> But perhaps you wanted
13:19:32 <Rhayve> It can't match the Integer type with Maybe and with Int
13:19:34 <monochrom> Integer is slow than Int. But Integer is more correct than Int.
13:19:35 <dmwit> :t Just (+2)
13:19:36 <lambdabot> Num a => Maybe (a -> a)
13:19:45 <Gurkenglas> Dammit brain you failed me again
13:19:49 <srhb> Rhayve: Maybe try dropping the elem bit
13:19:58 <Gurkenglas> I really shouldnt have made that mistake at this point ._.
13:20:00 <srhb> Rhayve: Consider what the case is for the empty list
13:20:19 <Rhayve> But if the n is not within the index range of the list, wouldn't I get an error when calling the function?
13:20:25 <Gurkenglas> :k a->a
13:20:26 <lambdabot> Not in scope: type variable ‘a’
13:20:26 <lambdabot> Not in scope: type variable ‘a’
13:20:34 <Gurkenglas> :k (+2)
13:20:35 <lambdabot> parse error on input ‘2’
13:20:43 <Gurkenglas> :k A->B
13:20:44 <lambdabot> Not in scope: type constructor or class ‘A’
13:20:44 <lambdabot> Not in scope: type constructor or class ‘B’
13:20:51 <srhb> :t (!!)
13:20:52 <lambdabot> [a] -> Int -> a
13:20:53 <vandenoever> foldl vs foldl' makes no measurable speed difference in this program
13:20:53 <dmwit> Rhayve: n `elem` xs doesn't check that the list has length at least n. =)
13:21:01 <dmwit> Rhayve: It checks that one of the *elements* of xs is n.
13:21:03 <srhb> Rhayve: (!!) takes an Int, not an Integer
13:21:05 <benzrf> :k * -> *
13:21:06 <lambdabot> parse error on input ‘*’
13:21:09 <benzrf> :s * -> *
13:21:15 <benzrf> aww, no sort
13:21:17 <yitz> Rhayve: why do you care whether n is an *element* of the list? to make it safe, you want to know *how many* elements are in the list.
13:21:26 <Rhayve> oh, so I'd have to go with n == length b ?
13:21:36 <dmwit> Rhayve: n < length b, I would suppose
13:21:36 <srhb> Rhayve: Or you could just define it recursively
13:22:02 <dmwit> Rhayve: And possibly n >= 0, too. ;-)
13:22:06 <Rhayve> yeah, I'm not too good at recursion yet, would that be easier?
13:22:11 <monochrom> this is an example of the failure of meaningful identifiers. there are so many meanings to choose from.
13:22:22 <vandenoever> so now run duration is haskell:c : 3:1
13:22:43 <srhb> Rhayve: safeIndex [] _ = Nothing -- to start with
13:23:29 <Rhayve> ah yeah, that makes sense
13:23:33 <srhb> Rhayve: Now you have two more cases to consider. One where there is at least one element and n == 0, and one where there is at least one element and n > 0
13:23:57 <joseph07> :t :
13:23:58 <lambdabot> parse error on input ‘:’
13:24:01 <joseph07> :t/
13:24:22 <Rhayve> so safeIndex xs 0 and safeIndex xs n as patterns?
13:24:42 <srhb> Rhayve: You will want to pattern match on the list head and tail
13:24:53 <joseph07> :t null
13:24:54 <lambdabot> [a] -> Bool
13:25:04 <srhb> So (x:_) in one case and (_:xs) in the other
13:25:21 <yitz> > let f xs n -> head . drop n . (++ repeat Nothing) . map Just . init . tails in map (f [1..5]) [1..10]
13:25:22 <lambdabot>  <hint>:1:12: parse error on input ‘->’
13:25:32 <yitz> > let f xs n = head . drop n . (++ repeat Nothing) . map Just . init . tails in map (f [1..5]) [1..10]
13:25:33 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
13:25:33 <lambdabot>    arising from a use of ‘M41452222859073562871200.show_M41452222859073562871...
13:25:33 <lambdabot>  The type variable ‘a0’ is ambiguous
13:25:33 <lambdabot>  Note: there are several potential instances:
13:25:33 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
13:25:41 <Rhayve> I get the head, but why the tail as well?
13:25:53 <yitz> > let f xs n = head . drop n . (++ repeat Nothing) . map Just . init $ tails xs in map (f [1..5]) [1..10]
13:25:54 <lambdabot>  [Just [2,3,4,5],Just [3,4,5],Just [4,5],Just [5],Nothing,Nothing,Nothing,Not...
13:25:55 <srhb> Rhayve: Because if n > 0 then we want to recurse with n-1 and only the tail
13:26:00 <srhb> Rhayve: Shortening the list for each recursive call
13:26:05 <Rhayve> ah, okay
13:26:32 <vandenoever> ok got speed up to 1/3 of equivalent c now: http://paste.kde.org/pgvlsydzh
13:26:48 <srhb> Rhayve: Also pattern matching on x:xs in both these cases is good style because it ensures there's at least one element, even though our first pattern should make sure nothing else is the case
13:26:54 <yitz> > let f xs n = head . drop n . (++ repeat Nothing) . map (Just . head) . init $ tails xs in map (f [1..5]) [1..10]
13:26:56 <lambdabot>  [Just 2,Just 3,Just 4,Just 5,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing]
13:27:30 <yitz> vandenoever: 1/3 of C is quite good
13:27:31 <srhb> Rhayve: Think you've got it now? :)
13:27:35 <Rhayve> I see -- I'm still trying to get used to Haskell since I come from a Java/C# background
13:27:42 <srhb> Rhayve: Sure! It takes a while :)
13:28:00 <Rhayve> I'll play around with the code a bit - thanks a lot for the help so far
13:28:06 <srhb> Sure thing. :)
13:29:32 <zq_> yitz: i think you can do better with bang patterns on your summation function
13:29:45 <zq_> uh, vandenoever
13:30:13 <yitz> zq_: hehe bang pattern might help me too, but mine is just for fun.
13:36:41 <sellout> I have a compiler (already written in Haskell) and I want to add an OpenCL target. Looks like accelerate is the thing to use … anyone know which OpenCL backend is in better shape?
13:37:16 <Rhayve> srhb: Cool, I got it to work! Thank you very much :)
13:37:22 <srhb> Rhayve: Good job :)
13:37:26 <vandenoever> zq_: i'll look up what a bang pattern is and will try rewrite the code to use it
13:43:43 <bennofs> zq_: vandenoever bang patterns should not be needed in this case. foldl' already handles this
13:45:11 <maxiepoo> so are there any examples of people using the bidirectionality of Pipes?
13:45:38 * hackagebot transformers-compat 0.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.3 (EdwardKmett)
13:48:07 <davidfetter> there must be more to these than meets the eye
13:48:41 <zq_> bennofs: foldl doesn't look inside your function
13:48:51 <zq_> bennofs: foldl', rather
13:49:21 <niao> vozz: geekosaur says: "possibilities I could think of without knowing about the C library in question include that (a) some of your allocated strings might need to be kept until you deallocate the C object, because it saves the pointer instead of the content; (b) you may need to force evaluation of addrArray"
13:49:24 <bennofs> zq_: ? you'd need to use bang patterns if he was accumulating a pair, but foldl' already forces WHNF of the accumulator, which is NF in the case of Int
13:49:49 <ReinH> zq_: but (+) is already strict in its first argument
13:50:39 * hackagebot contravariant 0.5.2 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.5.2 (EdwardKmett)
13:51:14 <ReinH> that would be a concern for something non-strict like (,)
13:51:52 <edofic> how about strict tuples?
13:51:59 <ReinH> (you would want data Pair = Pair !a !b instead)
13:52:07 <ReinH> er data Pair a b = Pair !a !b
13:52:10 <edofic> http://hackage.haskell.org/package/strict-0.3.2/docs/Data-Strict-Tuple.html
13:52:23 <ReinH> right that
13:52:35 <bitemyapp> ReinH: hacky row polymorphism demonstration in Haskell. Typeclass-per-field + existential types?
13:53:07 <ReinH> bitemyapp: hmm
13:53:54 <dagle> When application dependent signals are sent in haskell, I often see in haskell bindings just copy pasting the not exported signal api in gtk2hs to be able to add these signals and while it's a bit ugly I think it's acceptable. Now I'm using a standard signal missing in gtk2hs, should gtk2hs include all signals that gtk defines and I should send a patch for it or should I just add support for it in my app?
13:54:35 <srhb> Patch I'd say. iirc they are quite honest about not having full coverage yet, and that leads me to suspect they do want it.
13:54:36 <dagle> s/application/gtk-application/
13:54:48 <dagle> K.
13:55:39 * hackagebot hourglass 0.1.2 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.1.2 (VincentHanquez)
13:55:41 * hackagebot distributive 0.4.4 - Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4.4 (EdwardKmett)
13:56:36 <bitemyapp> ReinH: am I on the right track?
13:58:51 <skypers> moi je fais juste S-M-2
13:58:53 <skypers> ou 3 ou 4
13:59:00 <bitemyapp> skypers: vut.
13:59:12 <geekosaur> guh, I am reproducing that issue with cabal putting things in the wrong place.. in reverse. (freebsd, using cabal-install from ports) it sticks -L/usr/local/lib at the end of the command line and thereby gets the system version of a library with the headers from the ports version
13:59:23 <vamega> Hi, I was wondering if anyone here has used hxt and gotten it to follow redirects?
13:59:36 <skypers> bitemyapp: wrong window, sorry :D
14:00:40 * hackagebot comonad 4.2 - Comonads  http://hackage.haskell.org/package/comonad-4.2 (EdwardKmett)
14:00:42 * hackagebot derive 2.5.16 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.16 (NeilMitchell)
14:00:53 <orion> If I am writing a binding for a C library which is asynchronous but /not/ thread safe, what things do I need to keep in mind?
14:01:56 <ReinH> bitemyapp: dunno
14:06:18 <albeit> @pl \x -> x+3 == 5
14:06:18 <lambdabot> (5 ==) . (3 +)
14:10:20 <sclv> orion: well you probably need to have a lock to enforce that it doesn’t get accessed in a not-thread-safe manner?
14:11:45 <orion> sclv: Using basic things like MVars?
14:11:47 <Gurkenglas> @pl \x->x+2==x+3
14:11:48 <lambdabot> liftM2 (==) (2 +) (3 +)
14:11:55 <Gurkenglas> :t liftM2
14:11:57 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:12:03 <sclv> well it depends on the access pattern you want to enforce..
14:12:42 <sclv> also you can just bind with “safe” i think
14:12:51 <sclv> in your foreign import statements
14:12:57 <vamega> Regarding HXT and redirects.
14:13:09 <vamega> I figured it out.
14:13:17 <vamega> Needed to use the withRedirect option.
14:13:25 <sclv> when you do that its a blocking call so it locks up the whole IO thread untill it returns
14:13:36 <sclv> so if they’re fast cheap calls and you want to make sure only one happens at once that’s good enough :-)
14:13:38 <sclv> i think
14:15:43 <orion> sclv: I see. What other patterns are available to me?
14:16:22 <sclv> well you can use the evil toplevel mvar trick to create a global lock
14:16:58 <sclv> or you can just slap a big warning up on your haddocks :-)
14:17:11 <mmachenry> orion: I just stepped in. Mind msging me the original question?
14:17:16 <sclv> and honestly the general pattern with bindings is write the most straightforward raw ones possible
14:17:21 <sclv> then build a safer high level api on top
14:18:20 <napping> orion: do you have to make all calls from the same OS thread?
14:18:54 <EvanR> the ability to construct a value of a type is a proof...
14:19:01 <EvanR> of what?
14:19:32 <sclv> a proof of the type
14:19:39 <EvanR> so a type is a proposition
14:20:00 <EvanR> ?
14:20:04 <sclv> yes
14:20:11 <EvanR> head explode
14:20:26 <awestroke> > head explode
14:20:27 <lambdabot>  Not in scope: ‘explode’
14:20:42 * hackagebot shake 0.11.7 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.7 (NeilMitchell)
14:20:48 <edofic> > head explode where explode = undefined
14:20:50 <lambdabot>  <hint>:1:14: parse error on input ‘where’
14:20:53 <EvanR> what do values of the type represent then?
14:20:55 <sclv> EvanR: this is known as the “curry howard correspondence”
14:21:03 <awestroke> > head "explode"
14:21:04 <sclv> values represent proofs!
14:21:04 <lambdabot>  'e'
14:21:05 <edofic> EvanR, proofs
14:21:06 <t4nk136> Guys, how do you comment on haskell?
14:21:09 <EvanR> ok
14:21:10 <orion> mmachenry: I want to write a binding for a thread unsafe library, that's all.
14:21:12 <awestroke> t4nk136: -- comment
14:21:25 <awestroke> t4nk136: {- inline comment -}
14:21:33 <orion> I quote:
14:21:33 <sclv> a -> b — a implies b
14:21:39 <sclv> (a, b) — a and b
14:21:40 <orion> "The libutp interface is not thread-safe. It was designed for use in a single-threaded asyncronous context, although with proper synchronization it may be used from a multi-threaded environment as well." <-- sclv napping mmachenry
14:21:48 <sclv> Either a b — a or b
14:21:49 <mmachenry> Ah. And you're okay with it being thread unsafe? Seems okay if you document well and tell users they must lock when they need to.
14:21:57 <t4nk136> Thanks a lot, awestroke! :D
14:22:03 <sclv> Either a b -> c — a or b implies c
14:22:05 <sclv> etc.
14:22:12 <t4nk136> The LYAH book didn't introduce comments yet.
14:22:51 <mmachenry> orion: I echo what sclv said then. Make the lib as is not thread safe, document that fact well, then provide a safe one that locks if you'd like.
14:23:11 <awestroke> orion: doesn't the lack of thread safety also remove determinism?
14:23:11 <EvanR> these are the productions of propositions, and i can start with some primitives like () which is auto true, and Void which is auto false?
14:23:18 <joehillen> LYAH is not a good beginner book. It skips over so many basics on get you neck deep in concepts
14:23:47 <awestroke> joehillen: I disagree. Any example?
14:24:00 <EvanR> > undefined :: Void
14:24:01 <lambdabot>  Not in scope: type constructor or class ‘Void’
14:24:02 <sclv> well, if you want to say “a is false” then you have “a -> Void”
14:24:16 <EvanR> i mean, a false proposition
14:24:20 <sclv> but yeah you start with unit and void
14:24:38 <EvanR> would be an empty data declaration
14:24:46 <EvanR> is this of any use
14:24:59 <sclv> empty data declarations, or curry howard in general?
14:25:03 <sclv> both are useful
14:25:07 <EvanR> empty data
14:25:13 <orion> mmachenry: When I am using a binding and I see that the author wrote, "These functions are not thread safe", how does that change the way my Haskell application is designed?
14:25:17 <awestroke> :t (,)
14:25:18 <lambdabot> a -> b -> (a, b)
14:25:33 <awestroke> :t (,).(,)
14:25:34 <lambdabot> a -> b -> (b1 -> (a, b1), b)
14:26:42 <EvanR> sclv: what is a -> b -> c
14:26:48 <sclv> a function type
14:26:58 <mada> I have a datatype that holds some state. I want to add an infinite list to it:  turns = fst : snd : turns  :: [(a, a) -> a]
14:27:00 <EvanR> a implies (b implies c)
14:27:04 <sclv> right
14:27:12 <benzrf> mada: ok
14:27:15 <sclv> which is also: a and b implies c
14:27:19 <benzrf> mada: andrewsw_ ?
14:27:19 <sclv> ?ty curry
14:27:19 <EvanR> ah
14:27:20 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:27:21 <mada> but since the type constructor doesn't have a type parameter I can't use 'a' in that type
14:27:21 <benzrf> * and
14:27:23 <sclv> ?ty uncurry
14:27:24 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:27:26 <EvanR> nice
14:27:32 <benzrf> mada: ok, so what's the problem
14:27:40 <mada> data FightState = FightState { armies :: (Army, Army) , turns :: [(a, a) -> a] }
14:27:43 <sclv> so curry and uncurry witness well known principles of logic
14:27:46 <sclv> ?ty ($)
14:27:47 <lambdabot> (a -> b) -> a -> b
14:27:48 <mada> that won't compile.
14:27:55 <benzrf> mada: have you tried?
14:28:04 <mada> benzrf: I have just tried to import it, yes
14:28:04 <EvanR> haha, the existence of uncurry.... proves that a -> b -> c means a and b implies c
14:28:11 <benzrf> kk
14:28:11 <sclv> and application witnesses modus tolens or the like
14:28:12 <EvanR> i am floored
14:28:15 <mada> the error is 'not in scope type variable 'a''
14:28:17 <sclv> its pretty nifty
14:28:20 <benzrf> hmmm interesting
14:28:24 <benzrf> mada: just make 'a' Army
14:28:33 <edofic>  data FightState a = FightState { armies :: (Army, Army) , turns :: [(a, a) -> a] }
14:28:42 <eitan> does m have to be a Monad for ContT r m to be a Functor/Applicative/Monad?
14:28:44 <mada> benzrf: right
14:28:53 <benzrf> mada: ok?
14:28:59 <mada> benzrf: trying that, thank you
14:28:59 <sclv> curry howard is the basis of modern proof assitants like agda and coq
14:29:06 <sclv> and a whole school of program verification
14:29:11 <benzrf> im kinda surprised that doesnt work...
14:29:13 <benzrf> i feel like it should
14:29:18 <benzrf> maybe there needs to be a forall there
14:29:37 <EvanR> sclv: i have been doing haskell for at least 4 years now, and only just groking this
14:29:58 <EvanR> though still not clear how it would help with application programming, yet
14:30:48 <EvanR> does it make sense to design types which obviously prove that a video game follows certain game rules
14:31:05 <hpc> if you don't plan on changing those rules
14:31:25 <EvanR> hmm
14:31:32 <hpc> not that you can't change them, but it's easy to design a system where certain changes are very hard
14:31:47 <roconnor> EvanR: things really only get interesting when you and universal quantification to the "logic" (via dependent function types)
14:31:49 <EvanR> well, that happens without an advanced degree in mathematics
14:32:24 <gdoteof> http://lpaste.net/103635  trying to install filelock package and running into dependency issues; i don't seem to be able to install base 4.5.1.0
14:32:33 <EvanR> roconnor: when you what universal quantification?
14:33:16 <EvanR> will read as apply
14:33:30 <sclv> edwin brady has hangman and space invaders in idris as dependently typed programs: https://github.com/edwinb/idris-demos
14:33:35 <roconnor> s/and/add
14:33:37 <sclv> but i think he’s mainly demonstrating effect sysems
14:33:47 <EvanR> yeah...
14:33:58 <sclv> EvanR: universal quantification is “forall” and existential is “exists"
14:34:40 <EvanR> i am wondering if that effects system has anything to do with this http://lambda-the-ultimate.org/node/4525 paper
14:34:58 <EvanR> sclv: i have heard of this, but still do not fully understand it
14:35:01 <awestroke> gdoteof: try --upgrade-dependencies
14:35:19 <gdoteof> awestroke: i did that; it is the same error.  i am reading that i shouldn't be upgrade base at all
14:35:23 <supki> gdoteof: the only way to upgrade base is to upgrade ghc
14:35:23 <sclv> we use existential quantification all the time even though we don’t always write it out.
14:35:29 <EvanR> ok
14:35:30 <sclv> for example in uncurry
14:35:32 <sclv> ?ty uncurry
14:35:33 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:35:40 <awestroke> gdoteof: try an older version of filelock
14:35:45 <sclv> implicitly we have “forall a b c.” before that type
14:35:54 <benzrf> :where test
14:35:55 <sclv> since we say it holds true for all types that someone picks
14:35:56 <EvanR> and thats existential
14:35:57 <benzrf> hmm
14:36:01 <sclv> that’s universa
14:36:04 <EvanR> oh
14:36:18 <sclv> we don’t have explicit existentials in haskell, we simulate them with universals
14:36:37 <EvanR> simulate?
14:36:42 <ohitsjackk> what is this channel for
14:36:46 <awestroke> gdoteof: last resort: upgrade to newer GHC and start over from scratch with your cabal install
14:36:48 <sclv> so if I have data Foo = Foo (forall a. Show a => a)
14:36:51 <awestroke> ohitsjackk: everything haskell
14:36:55 <EvanR> ok ive seen that
14:37:00 <sclv> we call that “existential” even though its introduced with a universal quantifier
14:37:05 <spockshock> ohitsjackk: but mainly star trek talk
14:37:11 <EvanR> so its just a missing syntax
14:37:22 <sclv> because we say “an a that I can show exists” but we don’t say which one
14:37:38 <sclv> its not just missing syntax — you can write either in terms of the other if i recall
14:37:43 <sclv> the translation is a bit silly tho
14:37:54 <EvanR> objection
14:38:06 <sclv> (nb you can’t _always_ do this translation — you can in the logic that haskell happens to represent)
14:38:21 <EvanR> you have to have at least one type satisfying Show for that to make sense/
14:38:28 <EvanR> "exists"
14:38:47 <sclv> right and so the construction of an actual thing of type Foo
14:38:51 <sclv> gives witness to the existance of one
14:38:54 <sclv> but you don’t know which!
14:38:58 <EvanR> what if there are no instances
14:39:07 <sclv> then i can’t construct a Foo
14:39:16 <EvanR> oh
14:39:21 <supki> gdoteof: you can try to relax the lower bound with the usual cabal unpack incantation but it probably makes sense to upgrade to 7.6 anyway
14:39:22 <EvanR> interesting
14:39:34 <awestroke> when is "forall" ever useful? if forall is the default anyway
14:39:47 <EvanR> so if i have no instances, a lot of propositions fail
14:39:54 <EvanR> but i mean, they will still type check
14:39:56 <EvanR> in haskell at least
14:40:13 <EvanR> i dont recall classes ever being required to have instances
14:40:23 <sclv> (forall a. a -> (a,a)) -> Int -> String -> ((Int,Int),(String,String))
14:40:36 <sclv> forall is by default all the way at the left
14:40:43 <sclv> btu sometimes you want it “inside” some type
14:40:46 <gdoteof> okay, what would be the recommend upgrade path for ubuntu 12.04lts ?
14:40:58 <sclv> if it is inside a type we call the whole thing a “higher ranked type"
14:41:10 <dmj`> awestroke: http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
14:41:17 <EvanR> sclv: is that the same as RankN type
14:41:20 <sclv> yes
14:41:42 <sclv> if you omit undefined an nontermination, no, things won’t typecheck
14:41:46 <sclv> since you can’t create a Foo
14:41:56 <sclv> you can wrie a function that says “if i had a Foo then i could..."
14:42:08 <sclv> but then Foo is going to be to the left of a function arrow somewhere
14:42:21 <sclv> so you need a Foo to imply the things to the right of the arrow
14:42:24 <sclv> and if you can’t construct one
14:42:28 <sclv> you can’t discharge the proof obligations
14:42:39 <EvanR> yes thats what i missed, at some point in the program youd have to write the Showable thing
14:42:51 <EvanR> or it doesnt matter
14:42:54 <t4nk136> Let me ask another question: How did you guys apply Haskell in your career?
14:43:24 <Ginto8> awestroke: coming from a much-less-functional background, I'd intuitively interpret sclv's type as requiring that the first argument is polymorphic on a
14:43:53 <dmj`> t4nk136: why limit it to career, it permeates all facets of life :P
14:44:06 <sclv> its done wonders for my golf swing
14:44:14 <dmj`> ^
14:44:22 <roconnor> you reall need quantification over values to make this all useful.
14:44:30 <yitz> and yet again we feel the lack of the old lambdabot @faq
14:45:01 <t4nk136> dmj: Well, how did you apply Haskell in your life as a programmer?
14:45:17 <sclv> roconnor: i don’t want to disparage dependent types, but even without them curry howard is extremely useful
14:45:33 <EvanR> sclv: let met get this straight data Foo = Foo (exists e. Show e => e), means "there exists at least one instance of Show"
14:45:35 <sclv> t4nk136: via programming in it?
14:45:59 <EvanR> t4nk136: i have more friends now (tm)
14:46:04 <sclv> well its constructive existence
14:46:46 <sclv> it means “there is a type that show applies to (we can think of typeclasses as predicates) and furthermore I have that type and a value of that type, but I’m not telling you which one it is”
14:47:01 <t4nk136> sclv: How do you make programs in Haskell? GUI, console-based, mobile, OS, or etc?
14:47:11 <sclv> i use a text editor
14:47:13 <sclv> and a compiler
14:47:30 <sclv> there are many text editors
14:47:41 <sclv> and the recomended compiler is ghc, which you can install with the haskell platform
14:47:51 <sclv> and it will compile for windows, linux, or mac.
14:48:06 <sclv> and also can target llvm, and can cross-compile to iOS with some work
14:48:19 <codygman> t4nk136: I'm not sure what exactly you are asking. You make programs in Haskell similar to how you'd make them in another compile language.
14:48:27 <sclv> haskell is a general purpose programming language and bindings exist to many GUI toolkits
14:48:37 <sclv> sometimes i don’t use a text editor
14:48:40 <sclv> i use a notepad
14:48:42 <sclv> or just my brain
14:48:47 <EvanR> i use IRC
14:48:47 <sclv> and i write the haskell program there
14:48:51 <sclv> and then i don’t compile it
14:48:54 <sclv> except in my brain
14:48:57 <EvanR> and #haskell compiles it
14:48:58 <sclv> but its still a good program
14:49:51 <acowley> I wish packages defining abstractions didn't depend on so many data type-defining packages
14:50:18 <acowley> Everything seems to break down at that point, and you're left with installing everything in every sandbox.
14:50:19 <tac_> acowley: yeah
14:50:36 <t4nk136> let me rephrase my question: Do you make programs in Haskell that have GUI?
14:50:46 <tac_> Like, how many algebraic types do you really need?
14:50:54 <roconnor> acowley: how do you mean?
14:51:03 <vanila> t4nk136, I don't think thre's any good way
14:51:10 <tac_> Does my program really need to be defined in terms of semi-nearrings? :P
14:51:20 <acowley> roconnor: I mean, I was going to use free so I can used Free, but found that would require i install text and unordered-containers
14:51:36 <EvanR> t4nk136: im using GLFW bindings for opengl graphics and input
14:51:46 <roconnor> acowley: ah
14:51:49 <t4nk136> I see...
14:51:52 <acowley> roconnor: But it's easier for me to just copy the definition of Free and the primary instances into my own code
14:52:07 <t4nk136> Can you guys tell me the awesome projects you did with Haskell?
14:52:09 <acowley> roconnor: The package's weight is greater than its utility in this case
14:52:13 <roconnor> acowley: yeah.  For this reason I'm a big fan of orphan instances.
14:52:18 <acowley> roconnor: Me, too
14:52:21 <EvanR> t4nk136: yeah
14:52:40 <orion> Is there a way to "reexport" types?
14:53:16 <acowley> I think edwardk is servicing the haskell-platform audience at the expense of the cabal crowd with these dependencies
14:53:25 <acowley> orion: Yes, just like any other export
14:53:25 <orion> For example, I have a type that is both "Internal" to my library and "External" in that I want to expose it to the public.
14:53:27 <mzarella> Can anyone see what it is that I am trying to do with this? https://pastee.org/zz374 It's simple, but it isn't quite working, and I'm hoping someone can give me a hint on what to do
14:53:28 <t4nk136> EvanR: so... what is/are the cool project(s) you made in Haskell?
14:53:37 <yitz> orion: 3 ways
14:53:44 <orion> Is this the mark of bad design?
14:53:49 <yitz> orion: 1. if you have an export list, export the type.
14:54:20 <yitz> orion: 2. if you want to export the entire module it comes from, put module Foo on the export list.
14:54:34 <acowley> orion: It's a fine design, and very common
14:54:38 <dmj`> t4nk136: what would you consider a "cool" project?
14:54:44 <yitz> orion: 3. with no export list, you can import qualified as your own module name and it will be exported.
14:54:51 <acowley> mzarella: Look at the types
14:54:55 <orion> Interesting
14:55:03 <orion> I didn't know I can export entire modules.
14:55:17 <acowley> yitz: I didn't know about your option 3!
14:55:34 <yitz> orion: it's actully quite common. for example:
14:55:58 <sclv> acowley: “what is the ‘cabal corwd’ and how does it differ from the “platform” ?
14:56:07 <yitz> orion: you want to split up your library into small modules, but you want users to be able to import a single module name and get everything.
14:56:09 <sclv> ah i see
14:56:14 <t4nk136> dmj: It doesn't have to be a complex project. Something like Guess the number, Hangman, Ciphers, letter frequencies, console based games. calculator, etc...
14:56:19 <mzarella> acowley: updated https://pastee.org/9j8ns
14:56:20 <acowley> sclv: The people who install things with cabal
14:56:26 <sclv> so now my question for acowley is: “why didn’t you install the entire platform globally”?
14:56:31 <orion> Interesting
14:56:38 <sclv> and then use cabal for everything else?
14:56:51 <acowley> sclv: I'm on a no globals diet
14:56:59 <dmj`> t4nk136: here's a game of hangman: https://github.com/dmjio/Hangman/blob/master/Hangman.hs
14:57:02 <sclv> sounds like its a self made problem :-p
14:57:04 <yitz> acowley: you mean people who install packages that are in HP using cabal
14:57:12 <orion> If I don't have an export list, does that export *everything* including the modules I import?
14:57:14 <benzrf> HP?
14:57:18 <acowley> sclv: No, because the HP is also not worth its weight if you want to use the latest versions of things
14:57:21 <yitz> acowley: if it's not in HP, then installing with cabal is the only option.
14:57:23 <benzrf> orion: yes
14:57:28 <sclv> latest versions are for losers
14:57:34 <sclv> stable platforms all the way!
14:57:38 <acowley> sclv: Due to how things work, you quickly have to reinstall a multitude of packages to avoid having broken packages
14:57:39 <orion> oh wow
14:57:43 <dmwit> So, a minor light bulb went off today. Mersenne Twister has a period of 2^20K, right? Does that mean it has to store 20K of state?
14:57:47 <orion> So it's generally a bad idea NOT to have an export list.
14:58:06 <sclv> no you don’t automatically reexport your imports
14:58:07 <yitz> acowley: no you don't. use sandboxes.
14:58:13 <ziman> at least that much
14:58:14 <sclv> even without an explicit import list
14:58:19 <sclv> or export list rather
14:58:22 <benmachine> dmwit: I don't know the definitive answer but your logic sounds sound to me
14:58:36 <sclv> you _need_ explicit exports to manually declare what modules you want to reexport actually
14:58:40 <acowley> Well, I don't want to recapitulate the whole HP vs. non-HP argument
14:58:41 <benmachine> if it's got a period that long, it's got to have at least as many states as that
14:58:42 <roconnor> orion: for serious code I always use explicit imports and exports everywhere.
14:58:42 <ziman> it cannot store less
14:58:48 <benmachine> (if not more)
14:58:50 <t4nk136> Thanks, dmj`. I can't read the code well but at least I know that I can make simple games with it.
14:58:51 <sclv> wait what?
14:58:57 <sclv> that logic on MT makes no sense to me
14:59:26 <yitz> sclv: there is the import qualified OtherModule as MyModule trick
14:59:32 <acowley> yitz: I do use sandboxes.
14:59:39 <orion> roconnor: What do you mean by "explicit" imports? You mean qualified?
14:59:42 <dmwit> orion: benzrf is wrong
14:59:54 <sclv> yitz: oh cute, didn’t know about that
14:59:59 <mzarella> updated the paste with helpful information: https://pastee.org/rfh5a
15:00:01 <benmachine> sclv: if you have less than 20K of state, you have fewer than 2^20K possible values of that state
15:00:09 <dmwit> orion: Having no export list is the same as having the export list (module Whatever.Your.Module.Name.Is).
15:00:13 <dmj`> t4nk136: haskell can do much much more than just simple games
15:00:18 <orion> ah
15:00:25 <benmachine> sclv: therefore you have to revisit one sooner than 2^20K iterations time
15:00:27 <ziman> well, if we're talking 20K bits
15:00:54 <roconnor> orion: import Data.Monoid ((<>), mempty)
15:00:57 <dmwit> ziman: aaaah, yes
15:01:03 <dmwit> ziman: I had actually made that error in my head, thanks.
15:01:16 <dmwit> So only 2.5K state.
15:01:17 <roconnor> > 20*1024/8
15:01:18 <lambdabot>  2560.0
15:01:23 <orion> Must you import something before it can be reexported?
15:01:33 <dmwit> orion: yes, or define it
15:01:43 <orion> ok
15:02:13 <roconnor> according to wikipedia the state is about 624 ints
15:02:23 <roconnor> > 624 * 4
15:02:24 <dmwit> > 624*64
15:02:25 <lambdabot>  can't find file: L.hs
15:02:26 <lambdabot>  39936
15:02:30 <cdrlx> Do I have to learn a certain math to understand fp?
15:02:41 <johnw> no, you don't
15:02:41 <edofic> cdrlx, no
15:02:42 <dmwit> > 624*32
15:02:43 <lambdabot>  19968
15:02:46 <EvanR> i have a jargon question, when a paper says "let X be a set and Y be a set over the set X" what does that mean
15:02:46 <dmwit> Sounds right. =)
15:02:50 <dmwit> About 20K bits.
15:03:01 <roconnor> probably 624 32-bit ints, but it is written in pesudo-C, so, who knows.
15:03:09 <EvanR> let X be a set and let Y be a family of sets over X
15:03:11 <EvanR> ?
15:03:19 <cdrlx> edofic : Phew, I thought I have to learn one since I saw the "Lambda" as haskell's logo.
15:03:26 <sclv> EvanR: i would assume that Y is composed of sets that are subsets of X
15:03:38 <sclv> but it is a slightly ambiguous turn of phrase
15:03:39 <edofic> cdrlx, I helps though.
15:03:42 <EvanR> yeah
15:03:58 <mzarella> feedback appreciated: https://pastee.org/rfh5a
15:04:04 <cdrlx> e
15:05:38 <EvanR> sclv: maybe it means there is a set Y (composed of who knows what) for each value of X, like a function with domain X
15:06:19 <yitz> mzarella: first of all, you need a | before each x ==
15:06:37 <yitz> mzarella: to indicate different cases. those are called "guards".
15:06:56 <EvanR> actually thats probably it
15:07:02 <EvanR> confusing
15:07:22 <yitz> mzarella: second: this won't type check. since you are mapping foo over a list of characters, foo itself only applies to a single character at a time
15:07:56 <yitz> mzarella: so it should be foo x instead of foo (x:xs)
15:08:35 <yitz> mzarella: finally, the fallback case at the end is written like this: | otherwise = x
15:09:02 <mzarella> yitz: is a fallback case necessary?
15:09:03 <yitz> mzarella: (instead of foo xs)
15:09:16 <roboguy_> cdrlx: that's just a greek letter someone decided to use for a certain programming thing
15:09:33 <Rhayve> Excuse me, if I'm allowed to ask another question: I'm trying to write a function that recursively goes through list of double values and then returns the minimum and maximum values within the list as a tuple in the form of (minimum, maximum) without using any of the standard library's functions
15:09:39 <cdrlx> thanks for the tipcs, roboguy
15:09:56 <Rhayve> But I can't even get my code to return either the maximum or minimum value
15:10:03 <mzarella> yitz: updated per your feedback https://pastee.org/j94k2
15:10:04 <yitz> mzarella: it is necessary if you will ever get a character that you don't handle. and in general, it's a good idea to include it.
15:10:11 <cdrlx> edofic, what mathematics involves the lambda?
15:10:25 <johnw> cdrlx: lambda calculus
15:10:49 <johnw> which fits into category theory via "closed cartesian  categories"
15:10:59 <croyd> Rhayve: want to post your code?
15:11:00 <croyd> @paste
15:11:00 <lambdabot> Haskell pastebin: http://lpaste.net/
15:11:03 <cdrlx> Too bad for me... I am still a high school student.
15:11:03 <yitz> mzarella: remove the = in foo x =
15:11:08 <Rhayve> Yeah, sorry: seekMaxMin :: [Double] -> (Double,Double) seekMaxMin [] = (0,0) seekMaxMin [x,y] = (x,y) seekMaxMin (x:xs) 	| x > seekMaxMin xs = (x,x) 	| otherwise = seekMaxMin xs
15:11:15 <acowley> Well, anyway, I get that the HP motto is as sclv said, "latest versions are for losers," but I think this is a pretty unhelpful approach to things.
15:11:31 <Rhayve> just trying to get one side to work, but to no avail
15:11:36 <edofic> cdrlx, if you want to understand formalism behind haskell you start with lambda calculus and work from there. you might want to know some category theory for advanced concepts
15:11:44 <acowley> I'd rather people accepted orphan instances, or were more aggressive about getting dependencies pointed in the right direction.
15:12:23 <cdrlx> edofic: I'll make sure to study harder to better understand lambda calculus.
15:12:24 <sclv> orphan instances are the devil
15:12:25 <acowley> I think cabal sandboxes have been a real boon to working on multiple projects, and I hate to see that squandered
15:12:32 <cdrlx> Thanks for the help guys.
15:12:43 <sclv> in my day we installed everything globally twice a day and we liked it
15:12:56 <edofic> cdrlx, don't get distracted. you don't *need* to understand this to understand haskell code
15:12:56 <sclv> :-P
15:13:04 <yitz> sclv: maybe you liked it
15:13:05 <roconnor> nix is like cabal sandboxes for everything
15:13:06 <acowley> sclv: That's a pretty accurate description :)
15:13:08 <Rhayve> croyd: sorry, here's the paste https://pastee.org/4xghq
15:13:31 <mzarella> yitz: thanks, I've updated the paste again
15:13:32 <mzarella> https://pastee.org/u4esf
15:13:36 <acowley> When I was your age, we passed around copies of the SoE code and manually edited it to make it work on our machines :(
15:14:02 <acowley> I like living in the future of my past
15:14:06 <sclv> little known fact, the first edition of SoE came with punchcards!
15:14:07 <roconnor> acowley: what does "dependencies pointed in the right direction" mean?
15:14:10 <acowley> haha
15:14:19 <acowley> roconnor: text should depend on semigroups!
15:14:27 <cdrlx> I see, thanks for the tip edofic
15:14:34 <sclv> talk about significant whitespace!
15:14:41 <sclv> *rimshot*
15:14:44 <Rhayve> croyd: just trying to get at least the maximum value for now, but I keep getting "Couldn't match expected type" errors
15:14:55 <croyd> Rhayve: maybe it would be helpful to write just a 'max' or a 'min' function
15:15:04 <edwardk> acowley: ultimately some user loses out the one who wants minimal dependencies or the one who just wants everything to work
15:15:21 <edwardk> given that i rarely know where my code will be used, i favor the 'everything should work scenario'
15:15:22 <roconnor> acowley: oh
15:15:24 <yitz> mzarella: oh. instead of y <- write let y = (because that calculation is pure, not IO)
15:15:35 <acowley> edwardk: Yes, I am expressing self-interest
15:15:42 <EvanR> sclv: whats an example in haskell of... given a set of types, some other type which is "false", which theres no way to come up with a value for
15:15:48 <acowley> edwardk: Also, I have compiled text too many times
15:15:51 <EvanR> which uses those
15:16:00 <Rhayve> croyd: I'm trying to achieve the same effect via recursion to practice recursive functions
15:16:10 <mzarella> yitz: Wow, it worked
15:16:21 <yitz> acowley: Semigroup should be a superclass of Monoid
15:16:27 <yitz> mzarella: yay!
15:16:30 <sclv> evanR you need to explain that a bit more clearly
15:16:30 <acowley> yitz: I am aware
15:16:36 <edwardk> this sort of 'please oh my god don't give me a dependency' lifestyle is what makes me despair over the curent sandboxing craze
15:16:41 <mzarella> Thank you!
15:16:49 <acowley> haha, oh no, now it's a craze
15:16:59 <croyd> Rhayve: ok. So, what is the return type of seekMaxMin?
15:17:00 <glguy> I like that it was a lifestyle
15:17:01 <acowley> You and sclv are working from the same playbook
15:17:19 <EvanR> sclv: there are basic productions like -> (,) Either, but i cant see how arbitrarily combining some primitive types will ever result in an empty type
15:17:23 <edwardk> gotta run. bbiab =)
15:17:26 <yitz> edwardk: our projects typically have well over 100 indirect dependencies
15:17:29 <sclv> EvanR I would hope not!
15:17:30 <croyd> Rhayve: (max, min) or (min, max)?
15:17:35 <sclv> otherwise you could prove false!
15:17:37 <Rhayve> croyd: I'd like it to return a (double, double) tuple, with the first value being the minimum of the list and the second value the maximum of the list
15:17:43 <Rhayve> croyd: (min, max)
15:17:51 <sclv> but you can prove that something _implies_ false
15:17:59 <roconnor> what did edwardk mean by "please don't give me a dependnecy" and the current sandboxing craze?
15:18:09 <sclv> and that is what it means to prove that another statement is false.
15:18:11 * roconnor hasn't used cabal sandboxes
15:18:19 <edwardk> yitz: which means 1000 ways things can go wrong if we don't layer them right and supply instances for everything ;)
15:18:24 <sclv> so lets prove “not (a and not-a)"
15:18:33 <EvanR> sclv: uhm, like... yeah
15:18:35 <edwardk> ok, off to breakfast
15:18:35 <croyd> Rhayve: ok. So when you pattern match on a list- `(x:xs)` with type [a], what is the type of x?
15:18:37 <napping> roconnor: I think that people using sandboxes don't like dependencies because then lots of things need to be (re)compiled
15:18:37 <Rhayve> croyd: oh, just noticed I had the < the wrong way around, but yeah
15:18:44 <sclv> (a, a -> void) -> void
15:18:47 <sclv> that’s easy right.
15:18:48 <yitz> edwardk: we feel the pain of that every day.
15:18:57 <EvanR> so how is that true
15:19:00 <sclv> you can just feed the first half of the tuple into the second
15:19:03 <roconnor> napping: do cabal sandboxes do excessive recompiling?
15:19:13 <sclv> so \(x,f) -> f x
15:19:16 <roconnor> napping: I suppose cabal sandboxes are not shared like the nix-store.
15:19:22 <napping> No, not yet
15:19:27 <Rhayve> croyd: a double, I suppose
15:19:27 <sclv> this proves that you cannot create a value of type (a, a -> void)
15:19:27 <roconnor> yet!
15:19:42 <napping> I don't think it's excessive given that limitation
15:19:44 <sclv> so we can prove certain types are uninhabited
15:19:53 <napping> but still a bit of compiling to start up a fresh one
15:20:01 <yitz> roconnor: we couldn't survive without sandboxes
15:20:08 <acowley> roconnor: sandboxes have been great at virtually eliminating cabal breakage, but they do so by giving each project its own copy of everything
15:20:33 <croyd> Rhayve: right. So take a closer look at the types on the two sides of the (>) operator in the first guard.
15:20:45 <croyd> :t (>)
15:20:45 <lambdabot> Ord a => a -> a -> Bool
15:21:04 <croyd> Rhayve: ^ they need to be the same type
15:21:04 <napping> roconnor: I think I've heard there is actually work going to let ghc-pkg handle multiple installed copies of exactly the same version of a package
15:21:08 <EvanR> sclv: ok, so the proof exists of a proposition being false
15:21:11 <EvanR> ?
15:21:19 <EvanR> uh
15:21:38 <EvanR> ok (\(x,f) -> f x) is the proof
15:21:56 <Rhayve> croyd: hm, yeah, but if I want to handle empty lists with (0,0) as default return value, how would I avoid having my x compared to that pattern?
15:21:57 <sclv> exactly
15:21:59 <EvanR> that value is weird
15:22:00 <napping> And maybe even that wouldn't be necessary, if you just splice together a suitable package database
15:22:08 <Tordek> I think I asked already, but... if I'm implementing a monad, I get the Applicative definition for free, right? Any reason I should manually define fmap and stuff?
15:22:18 <sclv> that claim is known i believe as the “weak excluded middle”
15:22:24 <napping> well, I'm off too
15:22:29 <sclv> not (a /\ not a)
15:22:38 <Rhayve> croyd: add it as after an additional guard instead?
15:23:04 <EvanR> sclv: and so if no proof exists, its not a proof of falsehood
15:23:14 <croyd> Rhayve: sorry, I'm not quite following. You want to handle (0, 0) separately?
15:23:18 <EvanR> you need a proof of something one way or the other
15:24:16 <Rhayve> croyd: well, if I give the function a list like [1.0,3.0,5.0,7.0] it should return (1.0,7.0) but if I call the function with an empty list instead, it should return (0,0) as a default value
15:24:24 <Rhayve> croyd: basically error handling
15:25:18 <EvanR> wait, how is "not a" encoded
15:25:44 <johnw> Tordek: you don't get Applicative for free
15:25:54 <johnw> Tordek: some monads could have multiple Applicatives
15:26:22 <Tordek> johnw: oh?
15:26:32 <johnw> such as lists
15:26:51 <johnw> that's why we have the ZipList newtype, to represent the other Applicative for []
15:27:17 <acowley> That's a different question, though, isn't it?
15:27:26 <ReinH> johnw: then what is the Applicative you get from return and ap?
15:27:29 <acowley> For a given Monad instance, we expect the Applicative instance for that type to be consistent
15:27:30 <johnw> I was just mentioning why you can't get Applicative for free
15:27:35 <johnw> it can involve choice
15:27:40 <johnw> oh, wait, duh
15:27:42 <ReinH> johnw: and aren't those two different monad instances too?
15:27:42 <acowley> But Tordek is starting with a Monad instance
15:27:49 <johnw> if you have the Monad, pure = return and (<*>) = ap
15:27:50 <acowley> You're starting with a type
15:27:55 <croyd> Rhayve:  ok, first let's fix the type error
15:28:01 <EvanR> sclv: i missed how "not a" is a defined
15:28:04 <johnw> acowley: thanks, I misread the question
15:28:10 <croyd> :t snd
15:28:11 <lambdabot> (a, b) -> b
15:28:19 <johnw> supki: you were right, I got the effects in the wrong order
15:28:20 <sclv> EvanR. not a == a -> Void
15:28:20 * Tordek is now conused
15:28:29 <Rhayve> croyd: thanks for taking the time to help out
15:28:30 <sclv> gotta bounce now tho. laters.
15:28:32 * Tordek hurt himself in his confusion
15:28:39 <EvanR> hrm
15:28:48 <croyd> Rhayve: np
15:28:52 <sclv> read as “a implies False”
15:28:55 <EvanR> right
15:28:57 <acowley> Instructions unclear, Tordek has become a stuck term
15:29:02 <EvanR> weird
15:29:02 <Tordek> haha
15:29:16 <EvanR> Void -> Void would be true because
15:29:38 <monochrom> you may write "instance Applicative where pure = return; (<*>) = ap"
15:29:40 <EvanR> any function?
15:29:41 <croyd> Rhayve: here's a version that compiles: https://pastee.org/7g6pu
15:29:45 <ziman> > :t id :: Void -> Void
15:29:45 <sclv> forall a. Void -> a
15:29:46 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:29:48 <croyd> Rhayve: do you understand why?
15:29:49 <acowley> Tordek: I think there are Applicative instances that are more efficient than the exact Monad definition would be.
15:29:50 <sclv> ex falso quodlibet
15:29:51 <ziman> bah
15:30:00 <monochrom> err, typo. "instance Applicative MyType where pure = return; (<*>) = ap"
15:30:05 <EvanR> id
15:30:16 <EvanR> f x = x
15:30:18 <mzarella> yitz: Hmm, this won't work if it is fed a string
15:30:30 <acowley> monochrom: Does AMP as is going into 7.10 do exactly that?
15:30:36 <monochrom> no
15:30:41 <yitz> Tordek: what we meant was that the Applicative instance isn't automatically defined. you have to write it. but if you already wrote the Monad instance, you automatically get the functions you need to write the Applicative instance.
15:30:55 <Rhayve> croyd: I assume that, rather than comparing the x to one of the patterns, the snd function returns only a single double from the list for comparison, so it's double > double
15:30:59 <monochrom> I don't know. I do not know AMP.
15:31:14 <acowley> There've been various proposals for default superclass instances
15:31:18 <Tordek> yitz: ah, makes sense; otherwise Applicative'd depend on Monad, derp
15:31:19 <acowley> I don't know what the state is
15:32:21 <yitz> mzarella: you mean a different string than your original one?
15:32:58 <croyd> Rhayve: right. So what next?
15:34:32 <mzarella> Well, I guess it works, but it doesn't work if you leave out the map function
15:35:21 <yitz> mzarella: that's right. and if you want to change the string to a different one that might contain other characters, you need to add the fallback case for foo.
15:35:39 <Rhayve> croyd: rather than use snd, perhaps I could get the head by recursively calling it via seekMaxMin y:xs?
15:37:29 <Rhayve> croyd: but I guess y wouldn't be in scope, then... hm
15:39:32 <roboguy_> EvanR: you can have uninhabited types in haskell (ignoring bottom)
15:39:51 <croyd> Rhayve: 'y' belongs to a different pattern match. Might I ask why a two-element list ([x,y]) results in min=x, max=y?
15:41:06 <samrad> Hey
15:41:21 <Rhayve> croyd: well, I'm not sure how to temporarily store found values - I have a background in Java and C# so I'm not sure how to approach it in Haskell
15:41:49 <Rhayve> croyd: guess I would have to pattern match both values in the same guard to be able to place them in a tuple
15:42:14 <croyd> Rhayve: time to learn about let/where!
15:43:07 <croyd> > let x = snd (2, 3) in x + 1
15:43:09 <lambdabot>  4
15:43:31 <Rarrikins> > let 3 = (4, 5) in 3 + 4
15:43:32 <lambdabot>  Could not deduce (GHC.Num.Num (t0, t1))
15:43:33 <lambdabot>    arising from the literal ‘3’
15:43:33 <lambdabot>  from the context (GHC.Num.Num a)
15:43:33 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
15:43:33 <lambdabot>  The type variables ‘t0’, ‘t1’ are ambiguousCould not deduce (GHC.Num.Num t0)...
15:43:42 <LysergicDreams> I'm trying to learn haskell from the UPenn course, would anyone mind critiquing my code? http://sleepanarchy.com/p/9qnYRM
15:43:56 <Rhayve> croyd: I've read about let and where before, but I'm honestly stumped how I'd use let in this scenario... in where's case I guess I could just write where max = seekMaxMin xs for better readability
15:44:08 <croyd> Rhayve: http://learnyouahaskell.com/syntax-in-functions is a nice introduction
15:44:10 <Rhayve> croyd: unless there are better applications for it in this case
15:44:13 <LysergicDreams> Exercise 2 from: http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf
15:44:45 <abh> @pl flip runReaderT bot . flip execStateT botStatus . _runIRC
15:44:45 <lambdabot> (line 1, column 51):
15:44:45 <lambdabot> unexpected "_"
15:44:45 <lambdabot> expecting space or simple term
15:44:50 <croyd> Rhayve: you can still pattern match, e.g. `... where (minRest, maxRest) = seekMaxMin xs)
15:44:54 <abh> @pl flip runReaderT bot . flip execStateT botStatus . runIRC
15:44:54 <lambdabot> flip runReaderT bot . flip execStateT botStatus . runIRC
15:44:58 <prophile> LysergicDreams: looks pretty good actually
15:45:37 <yitz> @unpl flip runReaderT bot . flip execStateT botStatus . runIRC
15:45:37 <lambdabot> (\ i -> runReaderT (execStateT (runIRC i) botStatus) bot)
15:45:48 <Rhayve> croyd: That's the guide I've been using, but I'm trying to wrap my head around the Haskell syntax with these problems
15:45:58 <roboguy_> LysergicDreams: well, I'd personally line things up more, but I'm a little obsessive about that sometimes
15:46:06 <roboguy_> other than that it looks pretty good to me
15:46:29 <abh> @pl \bot botStatus -> flip runReaderT bot . flip execStateT botStatus . runIRC
15:46:29 <lambdabot> (. ((. runIRC) . flip execStateT)) . (.) . flip runReaderT
15:46:34 <abh> woah!
15:46:48 <abh> not doing that ..
15:46:54 <LysergicDreams> prophile: cool thanks, I wasn't sure if there was a better way to do the inserts, maybe without having to recalculate the heights
15:47:06 <croyd> Rhayve: ok, let's start by adding a where clause. `(minRest, maxRest) = seekMaxMin xs` will tell you the min/max of the rest of the list
15:47:17 <LysergicDreams> roboguy_: great, just trying to make sure I'm not falling down the wrong rabbit hole :)
15:47:22 <hae> Too many (.)s.
15:49:10 <Rhayve> croyd: so for that to work I'll have to filter out all the values between the min and the max and then order the list?
15:50:02 <croyd> Rhayve: I don't think so.
15:50:05 <Rhayve> croyd: ah wait... I think I may have misunderstood that part, sorry
15:50:41 <Rhayve> croyd: so I'd have to define minRest and maxRest after where
15:50:52 <croyd> Rhayve: right
15:52:22 <heatsink> What's the best way to encode the dependent sum (n :: Nat, S^n -> T) ?
15:52:56 <heatsink> That is, a function that takes a list of exactly n values, for some n
15:53:24 <Rhayve> croyd: is there a way to iterate over the individual values of the list without using snd to call seekMaxMin xs, so I can compare them for minRest and maxRest respectively?
15:53:35 <Rhayve> croyd: would I use let in this case?
15:53:53 <Algebr`> What is the point of "hidden packages"?
15:53:55 <dmj> question: If I have a library where one module re-exports a ton of other modules, is there any extra overhead incurred when I import the module that re-exports many other modules into a file? Would I be better off importing individual modules explicitly?
15:54:06 <Algebr`> err, sorry I meant hidden modules.
15:54:29 <heatsink> They are for internal parts of a library.
15:54:41 <roboguy_> heatsink: do you have a vector type?
15:54:50 <heatsink> no
15:55:31 <dmj> like suppose module A re-exports modules B - Z. Is there a cost incurred during compilation if I import A (only to use module D let's say), as opposed to just importing module D
15:55:55 <Algebr`> heatsink: I don't understand, why make them hidden?
15:56:20 <croyd> Rhayve: I don't think I understand what you're asking. But I think you can answer this question: If I tell you the first element of a list, x, and the maximum of all the elements in the list following x, maxRest, can you tell me the maximum of the entire list, x:xs?
15:57:38 <heatsink> Algebr`: You may want to ensure that users do not violate invariants established by exported modules.  You may want to ensure that users of a library don't depend on incidental details of the library implementation that may change in future releases.
15:58:08 <Rhayve> croyd: um, either x or maxRest, depending on which one is larger
15:58:20 <roboguy_> heatsink: I'd start with something like this http://lpaste.net/103640
15:58:21 <Algebr`> heatsink: So during development, how do I unhide them? ghc-pkg expose ?
16:00:01 <heatsink> Algebr`, are you using the modules in ghci?
16:00:50 <croyd> Rhayve: right, and our function seekMaxMin will tell us maxRest (along with minRest)
16:01:12 <Algebr`> heatsink: yes.
16:01:36 <Algebr`> I basically have some code that I want to load into ghci but the module keeps crapping out because one of the modules is hidden.
16:02:05 <Algebr`> I had a similiar problem with the module GHC and fixed that with ghc-pkg expose ghc
16:02:28 <croyd> Rhayve: so we can get them in a where clause like so: https://pastee.org/kk7ap
16:02:36 <heatsink> Well, I thought the modules wouldn't be hidden until the package is built and installed.
16:03:43 <roboguy_> heatsink: does that make sense?
16:03:48 <Algebr`> heatsink: hmm, I did do cabal install.
16:03:53 <Rhayve> croyd: yeah, I grasped that part, but I'm not entirely sure how to implement seekMaxMin properly so maxRest and minRest return the right values
16:03:56 <Algebr`> in the directory of the project.
16:04:24 <Rhayve> croyd: sorry for being slow on the uptake ._.
16:04:39 <heatsink> roboguy_, I don't suppose there's a convenient pattern matching syntax for vectors?
16:04:41 <croyd> Rhayve: you're almost there =)
16:05:01 <heatsink> My typical use case is (forall 3 $ \[x,y,z] -> foo z x y)
16:05:05 <roboguy_> heatsink: what do you mean? it's pretty much the same as othe rpattern matching
16:05:09 <tulloch> Is there a recommended way of doing a fold over a heterogenous list in Haskell?  I have a set of 'layers' that produce arbitrary dimension Repa arrays (e.g. DIM3 transformed into DIM2 transformed into DIM2), and I'd like to store the individual functions, map over them, etc.
16:05:20 <heatsink> s/forall/nonReservedKeyword/
16:05:31 <benzrf> tulloch: dont use hlists
16:05:42 <croyd> Rhayve: assuming that maxRest and minRest are correct, can you write the rest of the (x:xs) case?
16:06:10 <heatsink> roboguy_: Cons x (Cons y (Cons z Nil)) is less convenient syntactically.  So is x :*: y :*: z :*: Nil
16:06:35 <roboguy_> heatsink: well, you might be able to get sort of close with pattern synonyms
16:07:15 <tulloch> benzrf: yeah, a doable way is just to have each layer taking DIM1 to DIM1 and performing the reshaping internally
16:08:19 <tulloch> but it would be nice to be able to statically verify that the input/output dimensions are correct
16:09:27 <heatsink> roboguy_: I'll play with vectors to see if I can get a convenient interface
16:09:41 <Rhayve> croyd: I'm guessing I'd add a | x <= minRest and a | x >= maxRest to compare the values and then overwrite minRest and maxRest or so, not entirely sure
16:10:07 <roboguy_> heatsink: not a whole lot better, but this is a possibility http://lpaste.net/103640
16:10:54 <heatsink> Hmm, that doesn't look too bad
16:11:50 <heatsink> Algebr`, You should be able to load package modules without installing it.  I think cabal has a way to do it.
16:12:06 <heatsink> then modules won't be hidden
16:12:40 <croyd> Rhayve: you're on the right track. so `| x <= minRest = ...`
16:13:56 <bitemyapp> Axman6: replied to you on lobste.rs
16:14:07 <bitemyapp> Axman6: if you want me to change something, ping me on IRC. it'll happen faster that way.
16:14:50 <Rhayve> croyd: perhaps | x <= minRest = minRest 	| x > minRest = minRest 	| x >= maxRest = maxRest 	| x < maxRest = maxRest ?
16:15:32 <Rhayve> croyd: overwrite minRest or maxRest respectively, depending on whether x is the more appropriate value
16:15:56 <bitemyapp> Axman6: I was able to improve the article as a result, so thanks for the feedback :)
16:16:09 <Rhayve> croyd: ah wait, nevermind... doesn't work that way
16:16:58 <croyd> Rhayve: right, but you need to return the (min, max) pair in each case
16:17:25 <croyd> Rhayve: so you might start by writing `| x < minRest = (x, maxRest)`
16:17:32 <Rhayve> croyd: so | x <= minRest = (x,maxRest)?
16:17:38 <Rhayve> croyd: ah yeah, thanks
16:19:17 <Rhayve> croyd: okay, so 	| x < minRest = (x,maxRest) 	| x >= minRest = (minRest,maxRest) 	| x > maxRest = (minRest,x) 	| x <= maxRest = (minRest,maxRest) should work then, yes?
16:20:17 <croyd> Rhayve: almost, but not quite
16:20:26 <Rhayve> croyd: darn
16:20:27 <croyd> Rhayve: guards are tested in order
16:20:53 <croyd> Rhayve: so first (x < minRest) would be tested
16:21:11 <croyd> Rhayve: and then if that fails (x >= minRest) is tested
16:21:26 <croyd> Rhayve: is it possible for both of those expressions to test false?
16:22:27 <Rhayve> croyd: ah, since they can't both test false, there's no point in testing both cases
16:23:38 <croyd> Rhayve: right. So you can remove the second and fourth guard
16:23:40 <Rhayve> croyd: I could just put the return value of (minRest, maxRest) after otherwise to avoid redundancy
16:23:54 <croyd> Rhayve: exactly
16:24:35 <Rhayve> croyd: I've gotta say, you're a pretty awesome teacher ;)
16:25:02 <croyd> Rhayve: you're not finished yet, but thanks :)
16:25:33 <gamerguy> How do I pass the `-threaded` flag in a cabal file?
16:25:34 <Rhayve> croyd: yeah, but it deserves being mentioned - not many would be this patient with a random stranger
16:25:39 <solrize> how do hackage categories work?  are the categories assigned as part of the cabal info by the package authors?  i don't see it in any package descriptions
16:25:54 <gamerguy> I thought this would do it:   ghc-options: -rtsopts -threaded "-with-rtsopts=-M500m -N"
16:26:05 <heatsink> Is it an executable, gamerguy?
16:26:11 <gamerguy> yes
16:26:32 <heatsink> solrize: Categories are part of the package description file written by the authors
16:27:26 <gamerguy> ah, it works now. Knew I just had to complain somewhere :)
16:27:49 <gamerguy> No idea why it wasn't working before
16:28:01 <heatsink> you weren't trying hard enough!
16:28:06 <heatsink> idk
16:28:10 <solrize> ah, ok, found it
16:28:13 <solrize> thanks heath
16:28:19 <solrize> s/heath/heatsink/
16:28:22 <solrize> stupid autocomplete
16:28:55 <croyd> Rhayve: there's a lot of very helpful people in the haskell community. I think everyone in #haskell-beginners is waiting to help someone like you. But let's finish tackling your problem. Want to paste what you have now?
16:30:01 <Rhayve> croyd: hm, when I came via Reddit I only saw mention of #haskell and the advanced haskell IRC - didn't know about the beginner channel
16:30:21 <bitemyapp> Rhayve: I started it recently after a conversation about #haskell not being helpful enough.
16:31:40 <Rhayve> bitemyapp: ah, I see - thanks! I'm sure it'll come in handy soon
16:33:40 <ricree> Is there a function that's like Prelude.map, except strict?
16:34:00 <bitemyapp> ricree: just wondering, why would it need to be strict?
16:34:00 <Rhayve> croyd: https://pastee.org/9f34b
16:34:12 <johnw> ricree: can't you just map a strict function?
16:34:15 <johnw> map (f $!) xs
16:34:27 <heatsink> You also have to force evaluation of the spine of the list
16:34:35 <Rhayve> croyd: tried to come up with a minRest and maxRest before pasting, sorry for the delay^^;
16:35:15 <johnw> I think a strict fold would be easy to write
16:35:18 <croyd> Rhayve: minRest and maxRest are the result of seekMaxMin xs
16:35:46 <ricree> thank you
16:35:57 <heatsink> ricree: You can define a forceList function that evaluates each element of its list argument
16:36:04 <croyd> Rhayve: let's revist that in a moment and work out the base case
16:36:05 <johnw> foldl' (\a x -> let y = f x in a `seq` y `seq` y:a) [] xs
16:36:11 <Rhayve> croyd: oh yeah, my bad
16:36:16 <johnw> that may need to be foldr
16:36:28 <croyd> Rhayve: so we've already established that the result for an empty list should be (0,0).
16:36:38 <croyd> Rhayve: what should it be for a single-element list?
16:36:42 <Rhayve> croyd: sorry, it's already past 1:30am here - I'm not at my best at the moment ._.
16:36:46 <heatsink> > let forceList xs = foldr seq () xs in last $ forceList [0, undefined, 1]
16:36:47 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘()’
16:37:27 <heatsink> > let forceList xs = foldr seq () xs `seq` xs in last $ forceList [0, undefined, 1]
16:37:28 <lambdabot>  *Exception: Prelude.undefined
16:37:29 <Rhayve> croyd: (0,x) or (x,0) depending on whether x is negative or not
16:39:21 <Nolrai66> So can someone compare contrast the Prompt monad and the Free monad for me? I think I am getting how they work conflated.
16:39:27 <croyd> Rhayve: hm. so seekMaxMin [100] is either (0, 100) or (100, 0) ?
16:39:38 <ricree> Been having some weird interaction with ffi, but it's in Haste, so it's ffi with a javascript function. I thought it was a strictness issue, since I ran into one of those earlier, but now I'm thinking it might be something different
16:39:39 <roboguy_> Nolrai66: there's more than one Free monad
16:39:51 <roboguy_> Nolrai66: depending on your choice of Functor
16:40:19 <Nolrai66> roboguy: Yes. I shouldn't have really said "the" free monad.
16:40:24 <ricree> might just take the lazy way out for now and skip to the ffi evan function
16:40:49 <johnw> isn't the Prompt monad the "church encoding" of the Free monad?
16:41:36 <johnw> Free f a = Pure a | Free (f (Free f a)); Prompt p r = forall b. (r -> b) -> (forall a. p a -> (a -> b) -> b) -> b
16:41:38 <Rhayve> croyd: well no, if the list has only one element, the function would return (0,x) for positive x and (x,0) for negative x
16:41:48 <roboguy_> johnw: that's just what I was thinking
16:43:03 <defanor> how to include an empty directory into a cabal package?
16:43:46 <Nolrai66> Well that would be why I couldn't figure out how they were differnt.
16:44:20 <croyd> Rhayve: huh, maybe I misunderstood you. I thought we were trying to find both the maximum and minimum elements of a list. In which case I don't see why we should care if x is negative or not.
16:45:34 <Rhayve> croyd: oh, what you're saying that a single-element list wouldn't matter, since it wouldn't be able to return both a min and a max
16:45:46 <Rhayve> croyd: yeah, I guess that works
16:46:27 <croyd> Rhayve: I'm trying to say that if x is the only element of a list, it is both the minimum and maximum element
16:46:42 <Nolrai66> Hmm. Free on GADT is a little weird to me.
16:46:47 <Rhayve> croyd: ugh, yeah -- sorry, being retarded
16:47:14 <Rhayve> croyd: that was my original thought as well, but for some reason I got stuck on the 0, even though that wouldn't even be part of a single element list in the first place
16:47:44 <croyd> Rhayve: can you complete the function now?
16:49:40 <jmcarthur> Nolrai66: you can de-CPS Prompt a bit to get something that looks a bit closer to Free (and a lot like operational):       Prompt p a = Return a | forall e. Bind (p e) (e -> Prompt p a)
16:50:22 <Rhayve> croyd: I think/hope this ought to be more or less right: https://pastee.org/44xkk getting a parse error on where though, trying to figure out what the issue is
16:50:39 <Nolrai66> jmcarthur: If I understand how to use prompt is there a reason to use free or operational instead?
16:51:00 * hackagebot semigroupoids 4.0.2 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0.2 (EdwardKmett)
16:51:16 <jmcarthur> Nolrai66: and you can relate those two things using   data Coyoneda f a = forall e. Coyoneda (f e) (e -> a)   something like this:   Prompt p a = Free (Coyoneda p) a
16:51:30 <jmcarthur> Nolrai66: personal preference
16:51:31 <geekosaur> Rhayve, probably indentation but I'm not sure which direction in that case
16:51:35 <croyd> Rhayve: are you using tabs?
16:51:55 <Rhayve> croyd: SublimeText 3 with tabs, yeah
16:52:00 <roboguy_> Rhayve: tabs can cause some unintuitive problems with haskell
16:52:06 <roboguy_> I'd suggest just using spaces
16:52:40 <roboguy_> alternatively, try putting at least one space before where, after the tab (but I'd really recommend not using any tabs)
16:52:53 <Rhayve> Doesn't seem to work just with spaces either
16:52:55 <roboguy_> and also you need an = after otherwise
16:53:04 <Rhayve> oh yeah
16:53:06 <Rhayve> that's it
16:53:11 <roboguy_> otherwise is another name for True
16:53:13 <Rhayve> mea culpa
16:53:31 <Rhayve> yep, that fixed it
16:54:18 <Rhayve> Thank you everyone for your help and time, especially you, croyd!
16:54:53 <quchen> Rhayve: Concerning tabs-vs-spaces in Haskell, give these handful of points a read. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
16:54:58 <benzrf> ST is dumb use vim
16:55:04 <dmj> use emacs
16:55:05 <croyd> Rhayve: yvw
16:55:20 <dmj> haskell-mode ++
16:55:39 <Rhayve> quchen: it doesn't seem like ST3's tabs caused any issues, it was just the missing = but I'll give that a read nonethless, ty
16:56:06 <quchen> The editor is not the issue here. Sublime is fine, as is any other text editor you're comfortable with.
16:57:10 <Rhayve> quchen: I see the problem - yeah, I'll keep using spaces from now on, thanks for the heads-up
16:57:36 <Twey> How do I get the determinant of a matrix of unknown dimensions in Linear?
17:04:15 <machineslearn> use TECO
17:07:31 <Tordek> so, I'm practicing a bit making a little "emulator" for a very simple assembly language (it's got, like, 10 instructions), and since (almost) every instruction changes the state somehow, it looks like a good place to use State
17:08:22 <Tordek> so, the thing is... some instructions, like "get" are "get user input", that one should be State (Memory) (IO a)
17:08:50 <Tordek> but others don't need IO... so, should I make everything IO for easy chaining, or only IO things IO and lift as appropiate?
17:08:56 <machineslearn> (not ignoring anyone, I just do not know the answers to any questions)
17:08:58 <Tordek> should I use StateT Memory IO a?
17:09:12 <Twey> machineslearn: But I'm doing machine learning :<
17:09:17 <Twey> Tordek: I would, yes
17:09:36 <Tordek> Twey: so, make everything IO even if it's not IO?
17:10:35 <Twey> Tordek: You can do that.  You could also represent your commands by a sum type: data Command = Pure (State Memory a) | SideEffectful (StateT Memory IO a)
17:11:04 <Twey> Er, data Command a = …
17:12:09 <acowley> I'd probably do everything in StateT
17:12:19 <acowley> Just make the pure commands StateT m
17:12:35 <acowley> The parametricity over m prevents funny business.
17:13:17 <eitan> is there a library for a continuation transformer type with exceptions (error -> m r) -> (success -> m r) -> mr ???
17:14:19 <benzrf> eitan: can't you use Either with ContT
17:14:22 <acowley> Could you do that with EitherT
17:14:58 <roboguy_> eitan: that sort of looks like a church encoding of EitherT to me
17:15:13 <eitan> yes, it is the church encoding of EitherT
17:15:23 <eitan> is there a library that deals with it directly?
17:17:20 <acowley> What is the advantage to that vs using MonadError and ExceptT, for example, then finishing with either?
17:18:17 <arnoblalam> Hi all
17:18:51 <arnoblalam> Pardon my poor netiquette, as I am both new to Haskell and IRC
17:19:02 <arnoblalam> I am looking for a good Parsec tutorial
17:19:12 <arnoblalam> for the new version of Parsec (PArsec 3)
17:20:03 <eitan> acowley: I'm not sure if there's a speed advantage or anything. It's more idiomatic for my use case right now (Ajax calls that have error and success callbacks)
17:21:16 <acowley> arnoblalam: I guess you've seen RWH: http://book.realworldhaskell.org/read/using-parsec.html
17:22:07 <Twey> … for that matter, how do I even talk about matrices of unknown length in Linear?  There's the ‘V’ type, but Dim doesn't seem to provide Suc or anything
17:22:43 <acowley> Twey: I don't think linear supports that use particularly well
17:23:35 <arnoblalam> Hi acowley, yes I have... but that is for the older version of Parsec
17:23:42 <acowley> Twey: Any reason not to just use f (g a) with constraints on f and g (e.g. Each)?
17:24:06 <acowley> arnoblalam: Yeah, well google finds this: https://variadic.me/posts/2012-02-24-adventures-in-parsec.html
17:24:26 <Twey> acowley: I'm trying to write a determinant function.  So the dimension of the matrix changes (decreases by one) at each recursive step
17:24:45 <twanvl_> arnoblalam: Parsec 2 and Parsec 3 are almost identical
17:24:50 <acowley> Don't we have something for that in linear?
17:25:11 <Twey> acowley: There's det22 for two-by-two matrices and det33 for three-by-three matrices, but nothing else as far as I can see
17:25:40 <Twey> There don't seem to be any functions for working with arbitrary-sized matrices
17:25:52 <acowley> Twey: There are a couple things
17:26:01 <acowley> Twey: Like the Trace class
17:26:15 <arnoblalam> ah ok... I am not sure why I am having difficulty having my code compile. Perhaps because I am using Text instead of String, and the character Parsers don't work with text...
17:26:50 <arnoblalam> I will check out the 'veriadic' post you linked to
17:27:01 <acowley> Twey: But you're right that support for arbitrary sizes isn't good
17:27:09 <Twey> Ah, yes
17:27:23 <Twey> Mm, I don't think either Trace or Each are sufficient, though
17:33:07 <monochrom> arnoblalam: Parsec works fine with Text, you can do Char things fine, you just need the right imports, see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#text
17:34:04 <brewster_> Where should I get started in Haskell?
17:34:14 <brewster_> I would like to start writing file utilites and such
17:34:21 <brewster_> Move my files around and such, you know?
17:34:49 <brewster_> I tried LYAH, but too much theory....
17:34:58 <brewster_> Any suggestions, nice people of haskell?
17:34:59 <Tordek> Twey: sorry I was AFK, thanks!
17:34:59 <sm> brewster_: have a search for shell scripting with haskell
17:35:17 <monochrom> if LYAH is too much theory, then there is no such thing as practice
17:35:40 <sm> which turns up http://book.realworldhaskell.org/read/systems-programming-in-haskell.html eg
17:36:24 <brewster_> monochrom: I understand the book is great. However I would much prefer Learn Hasekll the Hard way
17:36:41 <brewster_> sm: Thank you very much.
17:37:05 <brewster_> sm: I’ve programming Ruby for awhile now, and have a bunch of programs I want to translate into haskell and see how it works out.
17:37:14 <carter> brewster_: cool!
17:37:27 <carter> brewster_: bear in mind the idioms wil be different
17:37:35 <brewster_> I also want to test some finanacial models, and am wondering what you guys think of that
17:37:35 <monochrom> translation usually ends badly. imagine translating ruby to cobol.
17:37:43 <carter> brewster_: oooo
17:37:47 <carter> brewster_: what sort of math
17:37:54 <arnoblalam> monochrom: Hey, I was just looking at that tutorial yesterday! I will examine more closely...
17:39:05 <brewster_> carter: The program needs to look at the closing dates and opening dates of historical stock data and try to see if selling and buying according to predescribed methods would work
17:39:13 <carter> oh
17:39:20 <carter> you mean you have back testing
17:39:24 <carter> what would the methods be?
17:39:26 <brewster_> carter: No math is really involved. But it would be cool to see it represented in various forms.
17:39:40 <carter> well, if the methods dont have math, well :*(
17:39:43 <carter> naively
17:39:49 <carter> hrm
17:39:59 <carter> so you'd have a time series model
17:40:06 <carter> and using the "events so far"
17:40:10 <monochrom> if it doesn't use math, then does it use computer intuition?
17:40:22 <carter> monochrom: it uses feelings and gum and stuff
17:40:28 <carter> brewster_: we kid
17:40:36 <brewster_> monochrom: It translate chart patterns into algorithms
17:40:42 <carter> so it does math!
17:41:00 <carter> "the derivative of the smoothed event data is positive or negative ish"
17:41:11 <brewster_> carter: Yeah, but not the smart kind. I didn’t want to call that math. But yes essentially it is pure math.
17:41:21 <carter> brewster_: all math is dumb
17:41:22 <carter> so dumb
17:41:25 <carter> that a computer can do it!
17:41:37 <brewster_> It would take percantages of the price movement.
17:41:38 * carter should disclose he's authoring "numerical haskell" tool suite
17:41:43 <carter> yes
17:41:47 <carter> so ratio of it
17:41:51 <carter> math
17:42:03 <carter> math is math, whether your call it so or not :)
17:42:28 <sm> brewster_: you might be interested in hledger[-lib]
17:42:45 <carter> oh yeah!
17:42:53 <carter> SM is that your lib?
17:42:57 <sm> yup
17:43:21 <sm> me and my minions
17:43:21 <carter> coool
17:43:36 <carter> i hear johnw  is wanting to merge ledger and hledger?
17:44:02 <sm> he wants to rewrite the core of hledger
17:44:11 <carter> so that...?
17:44:22 <sm> best ask him :)
17:44:28 <sm> I think he'll have to stop working to do it, though
17:44:40 <carter> hah
17:46:00 <brewster_> carter: “Math is maths…” Yes that’s true.
17:46:06 <carter> :)
17:46:30 <carter> brewster_: i'd suggest trying to write the code in haskell the dumbest way possible, then assking for refactoring / cleanup suggestiions
17:46:32 <carter> and iterate
17:46:38 <brewster_> Alright.
17:46:43 <carter> the type system is a powerful automated crutch
17:46:48 <carter> dont' worry if it looks ugly
17:46:52 <carter> get something dumb and basic that works
17:47:07 <carter> and we can slowly iterate it into a generic time series db
17:47:10 <carter> k?
17:47:16 <carter> but not for the firs tone
17:47:19 <carter> *first one
17:47:25 <carter> maybe the 5th iteration
17:47:37 <brewster_> carter: I’ve been trying to get into haskell, ever since I learned mathematica, but hit a wall everytime.
17:47:48 <carter> #numerical-haskell is full of fun people!
17:47:50 <carter> and me
17:47:53 <carter> i never shuttup
17:48:01 <brewster_> carter: That’s good. Hah
17:48:05 <carter> no its not
17:48:14 <carter> i should finishi getting numerical haskell ready for release :)
17:48:23 <carter> ttyl!
17:48:32 <brewster_> carter: “no it’s not.” I’m beginning to feel that way.
17:48:36 <brewster_> JK
17:48:51 <carter> please don't troll me, when i'm coding i get very literal
17:49:02 <Cale> brewster_: Feel free to ask lots of questions here
17:49:09 <Cale> (when you get stuck)
17:49:22 <carter> yes
17:49:27 <Cale> (or even if not!)
17:49:34 <carter> @lpaste will be where you should paste the code
17:49:34 <lambdabot> Haskell pastebin: http://lpaste.net/
17:49:39 <carter> and then ashre the linke
17:52:12 <brewster_> Alright.
18:10:23 <carter> srhb: was happy to hear your chime in that #haskell is a positive place on reddit :)
18:12:03 <hpc> carter: it is?
18:12:09 <hpc> irc.reddit.com/#haskell :P
18:12:18 <carter> wat?
18:12:37 <hollisbrown> I have somewhat of a newbie question; fmap works on 2-tuples, but only the second coordinate... Why? Are they in the functor typeclass? Is there a generalized way of discovering such information?
18:12:58 <carter> hollisbrown: your asking a questions which is both deep and simple
18:13:06 <carter> Functors just act on the last parameter of a type
18:13:06 <hpc> hollisbrown: use the types, luke
18:13:07 <roboguy_> hollisbrown: the Functor instance is for ((,) a)
18:13:53 <hollisbrown> hps: I guess I'm asking: what's different between (1, 2) and (1, 2, 3)?
18:13:59 <hollisbrown> In the type system, that is.
18:14:12 <roboguy_> hollisbrown: the first is of type (Int, Int) and the second is of type (Int, Int, Int)
18:14:16 <roboguy_> (if we specialize to Int)
18:14:52 <monochrom> type (a, b, c) is not the same as type (a, (b,c)), and therefore not a special case of type (a, x)
18:15:34 <roconnor> @where TTFP
18:15:34 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
18:16:24 <hollisbrown> carter: I understand functors just fine. (mathematician). It's really a simple newbie question.
18:16:37 <carter> hollisbrown: cool
18:16:41 <carter> i'm tired and pedantic
18:16:45 <carter> :)
18:17:24 <hollisbrown> So, for example, why doesn't: fmap (+1) (1, 2, 3) return (1, 2, 4)
18:17:25 <hpc> shortening it to just terminology then, fmap acts on the last type parameter
18:17:27 <hollisbrown> or whatever
18:17:41 <hpc> > fmap (+1) (1, 2, 3)
18:17:43 <lambdabot>  No instance for (GHC.Show.Show t1)
18:17:43 <lambdabot>    arising from a use of ‘M77508460274973545334907.show_M77508460274973545334...
18:17:43 <lambdabot>  The type variable ‘t1’ is ambiguous
18:17:43 <lambdabot>  Note: there are several potential instances:
18:17:43 <lambdabot>    instance [safe] GHC.Show.Show
18:17:49 <roconnor> hollisbrown: No one has bothered to make a functo instance for ((,,) a b)
18:17:52 <roconnor> *functor
18:18:03 <hollisbrown> roconnor: as simple as that?
18:18:07 <hpc> that simple
18:18:09 <roconnor> let me try
18:18:33 <hpc> very few people give an ass rat about anything greater than 2-tuples, since they get unwieldy in types very quickly
18:19:03 <roconnor> *Main> fmap (+1) (1,2,3)
18:19:05 <roconnor> (1,2,4)
18:19:11 <hpc> hollisbrown: http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:shows -- scroll up a bit
18:19:13 <roconnor> $ cat /tmp/Tri.hs
18:19:15 <roconnor> instance Functor ((,,) a b) where fmap f (x,y,z) = (x, y, f z)
18:19:18 <roconnor> hollisbrown: as simple as that.
18:19:30 <hpc> hollisbrown: that's show instances for tuples up to 15
18:20:04 <roconnor> hollisbrown: it is certainly a legitimate complaint about Haskell that it cannot generically give a functor instance for tuples of all sizes.
18:20:30 <hollisbrown> :roconnor I am too much of a newbie to make a complaint. Just wanted to make sure I didn't miss something key.
18:20:31 <roconnor> hollisbrown: but what do you expect from 20th century techonology.
18:20:35 <roconnor> :)
18:21:00 * johnw wonders if anyone has actually used a 15-tuple
18:21:13 <roconnor> hollisbrown: another legitmate complaint is that you can only make functor instances in the last argument.
18:21:24 <hpc> lots of generic tuple handling for things is going to fall out of research with stuff like kind polymorphism
18:21:33 <roconnor> hollisbrown: to work around this you need to use newtypes to rearrange the order of the type arguments.
18:21:34 <athan> roconnor: I feel like that would make it somewhat fundamentally different, like how certain lisp functions can take infinite arguments
18:21:53 <hpc> but that's getting higher up and there are more interesting ways to use that research anyway ;)
18:21:53 <athan> I feel like that would imply that functions could be allowed to take infinite arguments as well, and breaking (->) itself
18:22:07 <hollisbrown> :roconnor that does sound awkward
18:22:09 <carter> hollisbrown: what sort of mathematician?
18:22:23 <hollisbrown> :carter C*-algebras
18:22:23 <carter> hollisbrown: its akward, but its reasonable choice / constraint in some ways
18:22:27 <carter> functional analysis!
18:22:28 <carter> woo
18:22:34 <carter> pure or applied?
18:22:49 <roconnor> hollisbrown: It was a big breakthrough to have classes for things that are not themselves types.
18:22:53 <hollisbrown> :carter Pure
18:23:00 <carter> hah
18:23:03 <jmcarthur> yeah the functor instance only in the last argument thing really irks me sometimes
18:23:15 <carter> jmcarthur: how else would it work though?
18:23:19 <carter> i'm curious
18:23:21 <johnw> roconnor: there are types that *could* be both a Monad and an Arrow, but the arrangement of the type variables makes it impossible to write
18:23:37 <carter> what would be a strawman appraoch?
18:23:44 <jmcarthur> carter: it irks me partly because while there are various half solutions, none of them i can think of are really satisfying
18:23:55 <carter> hollisbrown: i do finite dim functional analysis these days a lot
18:24:03 <carter> (aka matrix math)
18:24:15 <johnw> roconnor: or maybe I'm thinking of a monad transformer and an Arrow
18:24:18 <carter> i really wanna dig into the modern crayz stuff sometime
18:24:26 <hollisbrown> :carter By now, I've lapsed into the bad habit of considering everythign as a matrix. :)
18:24:27 <roconnor> jmcarthur: it prevented me from noticing that a KleeneStore/Baazar was Traversable in its first argument.
18:24:42 <carter> hollisbrown: you should lurk on #numerical-haskell
18:24:52 <carter> eigenvalue a functional analysis there
18:24:56 <wjad> what do you guys use haskell for?
18:24:59 <carter> *analyst
18:25:02 <carter> wjad: EVERYTHING
18:25:04 <jmcarthur> roconnor: there are soooo many things we could do if we could get around this problem that are not immediately obvious to those of us only used to thinking of functors as being tied to their last argument :\
18:25:05 <hollisbrown> :carter Didn't even know about it 'til now :)
18:25:32 <carter> jmcarthur: just need to abuse newtypes more :)
18:25:39 <carter> hollisbrown: soke, i don't publicize too much yet
18:25:42 <carter> well
18:25:44 <carter> ish
18:25:52 <jmcarthur> roconnor: i think the pipes library is a pretty decent example of how the type constructors don't line up perfectly for the type classes
18:26:01 <Ginto8> wjad: I haven't done a lot yet, but I'm trying to use it for OpenGL and Arduino (ie. haskell on arduino controlling an OpenGL game over USB)
18:26:15 <jmcarthur> there are monads and categories everywhere in it, and you can't just use Category and Monad for them
18:26:17 <hollisbrown> Is this constraint about functors related to implementation details? Or is there a type-theoretic reason?
18:26:18 <Cale> hollisbrown: It's a little bit awkward, but it also makes many things regarding natural transformations easier, because you get this nice notation where the objects at which you're taking components is implicit
18:26:23 <Ginto8> wjad: currently I'm just making Pong to learn the Haskell SDL/OpenGL libraries
18:26:35 <jmcarthur> Cale: ibe
18:26:42 <roboguy_> hollisbrown: the last argument thing is an implementation detail
18:26:44 <jmcarthur> ugh, sorry, that was a mistake
18:26:52 <hollisbrown> :roboguy Thanks. :)
18:26:58 <Cale> (having at most one instance means that the computer can infer unambiguously which functors are being talked about)
18:28:31 <jmcarthur> wjad: anything i can
18:30:20 <Cale> hollisbrown: (That is, fmap f will apply whichever is the appropriate functor to f, which isn't ambiguous because you're allowed at most one)
18:30:37 <carter> and having good type inference IS really nice
18:30:58 <Cale> Similarly, the distinction between μ and μT in the categorical notation gets left out, you can write both of those as join.
18:31:02 <Cale> :t join
18:31:02 <lambdabot> Monad m => m (m a) -> m a
18:31:32 <Cale> (but Tμ you write as  fmap join)
18:32:55 <Cale> :t join . fmap join
18:32:56 <lambdabot> (Functor m, Monad m) => m (m (m a)) -> m a
18:32:59 <Cale> :t join . join
18:33:00 <lambdabot> Monad m => m (m (m a)) -> m a
18:33:03 <roboguy_> also, there is only at most one valid Functor instance for any given type
18:33:13 <Cale> roboguy_: Yeah, kinda
18:33:20 <roboguy_> Cale: kinda?
18:33:41 <Cale> roboguy_: That's true, but it's the artificial restriction due to the way things are set up that we're talking about :)
18:33:50 <roboguy_> right
18:40:38 <hollisbrown> :Cale That makes perfect sense, but surely it's a speed tradeoff? Or am I just really missing something?
18:43:00 <carter> its not a speed tradoff
18:43:16 <carter> its a "type inference working sanely given what we know about how to do good type inference"
18:43:17 <carter> tradeoff
18:43:45 <roboguy_> if you can have two Functor instances for (,), what does fmap (*10) (1, 2) do?
18:44:21 <roboguy_> (or three for that matter)
18:45:54 <carter> segfault :)
18:46:00 <carter> well
18:46:01 <carter> nop
18:46:05 <Cale> There's perhaps a very small speed tradeoff you make in order to be able to support the actual polymorphism in some cases, because you need to pass around the implementation of fmap or other type class methods.
18:46:07 <hollisbrown> how is that related to the last argument thing?
18:46:38 <Cale> However, in many cases, the instance to be used is fixed at compile time, and things can be specialised/inlined.
18:47:17 <Cale> (It's possible using polymorphic recursion to write a program which uses infinitely many different Functor instances though.)
18:47:52 <Cale> (and which runs forever ;)
18:55:12 <carter> Cale: i've some pretty evil inlining heavy functor / applicative/ traversable /foldable
18:55:17 <carter> in some of my code
18:56:39 <Cale> Yeah, frequently not as much of it happens automatically as you might like, requiring lots of care
18:56:45 <roboguy_> Cale: don't you need infinitely many functor instances to do that?
18:56:46 <Cale> (and pragmas)
18:57:55 <Cale> roboguy_: Well, I mean that you use fmap at infinitely many specific types. You'd really be using the same instances over and over :)
18:59:13 <roboguy_> hmm so something like infFunctors x = fmap snd . strength $ infFunctors (1, x)
19:01:00 <nisstyre> so, uh, it seems like https://hackage.haskell.org/package/base-4.2.0.0/docs/Foreign-ForeignPtr.html#v%3AunsafeForeignPtrToPtr was removed from 7.8.2?
19:01:28 <nisstyre> some stuff is using it like gtk-traymanager
19:01:38 <nisstyre> should I just use an old version to build that stuff?
19:01:43 <johnw> nisstyre: https://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-ForeignPtr-Unsafe.html
19:01:56 <nisstyre> johnw: oh it just moved?
19:02:04 <johnw> yes, it looks like it
19:02:17 <nisstyre> okay great, easy fix then
19:02:20 <johnw> now with extra unsafeness :)
19:05:09 <joelteon> Does anybody have examples of incorporating netwire with, say, an ncurses interface?
19:05:53 <fragamus> type Schlock = Data.HashMap.HashMap Double Double
19:05:53 <fragamus>     Deprecated: "HashMap is deprecated. Please use Map instead."
19:05:59 <orion> I have two types "ServerNonce" and "ClientNonce" that are type aliases for ByteStrings. Will Haskell guarantee that those types are not interchangable?
19:06:15 * hackagebot boundingboxes 0.2 - The type for 2D bounding box  http://hackage.haskell.org/package/boundingboxes-0.2 (FumiakiKinoshita)
19:06:16 <orion> Or will Haskell allow it because they're type aliases?
19:06:17 * hackagebot free-game 1.1 - Create games for free  http://hackage.haskell.org/package/free-game-1.1 (FumiakiKinoshita)
19:06:19 * hackagebot hspec-webdriver 0.2.1 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.2.1 (JohnLenz)
19:06:21 * hackagebot webdriver-angular 0.1.4 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.4 (JohnLenz)
19:06:27 <fragamus> how do I define Schlock
19:06:57 <saml_> type Schlock = Data.Map
19:07:39 <saml_> > fromList [(1.0, 1.0)] :: Data.Map Double Double
19:07:40 <lambdabot>  Not in scope: type constructor or class ‘Data.Map’Not in scope: ‘fromList’
19:07:41 <lambdabot>  Perhaps you meant one of these:
19:07:41 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
19:07:41 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
19:07:41 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
19:08:03 <saml_> :t M.fromList[(1.0,1.0)]
19:08:04 <lambdabot> (Ord k, Fractional a, Fractional k) => M.Map k a
19:08:27 <ricree> So, this might be a bad idea, but I'm trying to mirror an api in ffi that has a couple functions with optional parameters. You can kind of do this with typeclasses, but only if you want to run into a ton of "no instance for" errors whenever ambiguity shows up
19:08:38 <carter> maybe types!
19:08:44 <carter> Maybe a
19:08:58 <carter> or have a records thingy
19:09:36 <ricree> is there a decent way to do this, or should I just export a bunch of different functions
19:12:56 <roboguy_> ricree: I think carter's Maybe idea would probably be the nicest way
19:13:43 <fragamus> how do I get rid of this Deprecated: "HashMap is deprecated. Please use Map instead."
19:13:56 <fragamus> What does it want from me
19:14:08 <saml_> Data.Map
19:14:08 <ricree> thanks carter and roboguy_  . Not the answer I was hoping to hear, but thank you for answering.
19:14:10 <roboguy_> fragamus: sounds like it wants you to use Map
19:14:20 <carter> theres other styles
19:14:23 <carter> but tahts the simplest one
19:14:28 <fragamus> type Schlock = Data.HashMap.HashMap Double [Double]
19:14:42 <carter> roboguy_: you could have a record type with a default value for all the fileds
19:14:44 <carter> *fields
19:14:47 <carter> *ricee
19:15:08 <pavonia> How is "Please use Map instead" unclear?
19:15:20 <fragamus> it is unclear
19:15:39 <fragamus> because I tried type Schlock = Data.HashMap.Map Double [Double]
19:15:46 <fragamus> and many other variants
19:15:48 <ricree> In this case, I think I'm going to go with exporting multiple functions to keep the most common case simple
19:15:53 <fragamus> I just don't know what it wants
19:16:06 <pavonia> Data.Map
19:16:27 <fragamus> oops it my imports
19:16:28 <pavonia> or Data.Map.Map in a type
19:18:33 <saml_> fragamus, you have code/testcase?
19:19:04 <fragamus> I'm just going with the deprecated message because I have tons of code based on HashMap
19:19:15 <saml_> try  import Data.Map;   type Schlock = Map Double Double
19:19:35 <saml_> import Data.Map; type HashMap = Map
19:24:32 <Tordek> Twey: so... I have "Instruction a = Pure (S.State Mem a) | SideEff (S.StateT Mem IO a)"... but I can't define a Monad Instruction for that, right?
19:25:36 <Tordek> I mean... Pure s >> t depends on what type of instruction T returns, so I can't know if I need to make a Pure or a SideEff before actually executing t... or am I missing something?
19:25:56 <Tordek> >>= not >>
19:27:45 <Welkin> since I started learning haskell I have had nightmares about programming
19:27:50 <Welkin> is this common?
19:28:11 <Welkin> the most vivid involved a lot of folding functions
19:28:14 <manuel_> what’s the nightmare about
19:28:19 <Tordek> it's a side effect
19:28:23 <Welkin> just me trying to reason about the code
19:29:12 <Welkin> all that existed was the code and my mind, nothing else
19:29:24 <Welkin> I could see the letters floating in a vacuum
19:29:47 <saml_> Welkin, i prescribe withdraw from haskell
19:29:58 <saml_> and take 2 node.js per day
19:30:17 <Welkin> I haven't had them lately
19:30:25 <Welkin> it was certainly bad when I started haskell though
19:30:56 <saml_> try not to use fold
19:31:40 <shergill> have there been proposals for laziness type annotations?
19:33:59 <LysergicDreams> Welkin: embrace the folds, let them flow through your mind and body, kiss the snake
19:34:45 <shergill> or any reason why currently there aren't any supported strictness type annotations?
19:36:40 <Welkin> that makes sense coming from someone named LysergicDreams
19:37:40 <carter> shergill: its too hard
19:38:15 <shergill> carter: hardness over and above having to deal with the status quo?
19:38:41 <shergill> (not to discount it, merely to understand cause of said hardness)
19:38:44 <carter> well, come up with a good design
19:38:46 <carter> :)
19:38:54 <carter> thats also compositional!
19:38:58 <shergill> i'm looking at how clean does it right now, or trying to
19:40:20 <shergill> or do you know of an a priori reason why the same approach wouldn't work?
19:40:25 <nisstyre> shergill: Clean does a lot of things very elegantly but unfortunately the libraries aren't there
19:41:57 <GeraldDev> Hello, I have a lazy eval question....lets say I have this function: all' func xs = foldl (&&) True $ map func xs  What is on the right of the '$' will be evaluated strictly, right?
19:42:21 <dolio> No.
19:42:40 <GeraldDev> hi, thanks, thats what I thougt..but then I tried this: temp   = foldl (&&) True $ map (<10) [1..]
19:42:43 <GeraldDev> And I ran out of ram
19:42:49 <GeraldDev> what am I missing here?
19:43:08 <benzrf> GeraldDev: $ is just precedence
19:43:10 <dolio> Well, I suppose it depends what you mean. Technically it will be evaluated strictly, because foldl demands it.
19:43:11 <benzrf> not strictness
19:43:16 <dolio> But that's not your problem.
19:43:19 <GeraldDev> ok
19:43:35 <dolio> Your problem is that foldl builds up a big structure in memory, and doesn't reduce it.
19:43:59 <GeraldDev> oh..so it is still lazy? but I am wrongheaded in what i did?
19:44:03 <dolio> True && 1 < 10  ----> (True && 1 < 10) && 2 < 10 ----> ...
19:44:34 <dolio> And it never needs to evaluate those, so the equivalent of a huge && keeps growing.
19:44:55 <dolio> You should use foldl'
19:44:59 <dolio> But that will still never finish.
19:45:03 <GeraldDev> hmm
19:45:06 <dolio> So you should actually use foldr.
19:45:13 <GeraldDev> I see
19:45:21 <GeraldDev> thank you
19:45:44 <Welkin> or use foldl'
19:45:53 <Welkin> (strict)
19:46:05 <dolio> That won't finish on infinite lists, though.
19:47:04 <shergill> nisstyre: agreed (based on wikipedia skimming)
19:47:11 <Kaidelong> so haskell platform hasn't been updated since 2012 because?
19:47:18 <Kaidelong> is GHC 7.8 to blame?
19:47:21 <carter> Kaidelong: wait a few weeks and a new one should be out
19:47:21 <GeraldDev> my haskell platform is from 2013
19:47:29 <carter> github.com/haskell/haskell-platform
19:47:53 <newsham> random thought wandering question of the day..   if I have "newtype Foo x = Cons { unCons :: somethingof a }"   does haskell have any mechanisms for me to get a "withCons f = Cons . f . unCons" for free?  or to make use of such of a construct for free?
19:47:53 <nisstyre> shergill: I tried using it and the syntax is quite similar except they use [a,b] for matching lists instead of (a:b)
19:47:57 <carter> https://github.com/haskell/haskell-platform/branches
19:48:02 <nisstyre> shergill: also they have uniqueness types
19:48:12 <newsham> I guess the generic deriving stuff kind of has some of that under the covers
19:48:18 <nisstyre> but I couldn't find any libraries...
19:48:19 <Kaidelong> well I'm on win64 and I know 7.8 has problems on it
19:48:27 <nisstyre> other than the stuff in the stdlib which was very basic
19:48:48 <nisstyre> there is a TCP/IP implementation with sockets I guess
19:48:55 <carter> Kaidelong: no, 7.8 is out and should be fine on win64
19:48:56 <Kaidelong> I'm just kind of hoping that cabal-dev isn't broken there, it crashes here when I try to use it for glfw-b-examples and tells me to report a bug
19:48:58 <nisstyre> you don't get anything higher level than that
19:49:11 <carter> Kaidelong: Kaidelong  have you reported bugs?
19:49:20 <shergill> carter: <http://wiki.clean.cs.ru.nl/download/html_report/CleanRep.2.2_7.htm#_5.1.5_Strictness_Annotations>. it also uses nocker's strictness analysis so this gets inferred
19:49:31 <nisstyre> shergill: oh also there is just a compiler, no repl or anything
19:49:34 <Kaidelong> carter: not sure what the ettiquite is on reporting bugs on 7.6 while devs are working on 7.8
19:49:45 <carter> no, use 7.8!
19:49:46 <carter> :)
19:49:56 <carter> there should be a basic windows installer now afaik
19:50:31 <nisstyre> carter: I've had a few things break with 7.8, not too hard to fix but annoying
19:50:34 <Kaidelong> cabal-dev is deprecated with the next haskell platform anyway isn't it?
19:50:43 <carter> heck,oh dont use cabal-dev
19:50:43 <nisstyre> I should say there were nowhere near the stdlib
19:50:45 <carter> no one maintains it
19:50:47 <carter> use cabal
19:50:51 <Kaidelong> the replacement is cabal sandbox or something?
19:50:54 <nisstyre> s/there/they/
19:51:10 <carter> yup
19:51:11 <nisstyre> Kaidelong: sandboxes are good to use if you don't want your code to break
19:51:45 <roboguy_> newsham: Coericble
19:51:51 <shergill> nisstyre: not necessarily a fan of uniqueness types per se, but i do crave the ability to specify such constraints. others include: linear and affine types
19:51:59 <Kaidelong> nisstyre: I'm kind of forced into using cabal-dev for this because of the conflict between glfw and glfw-b, I need both
19:52:13 <nisstyre> shergill: it is kind of cool, did you read the vending machine example on wikipedia?
19:52:13 <Kaidelong> cabal sandbox is not an option for my current version of cabal
19:52:21 <newsham> robo: is that a cabal hackage?
19:52:25 <Kaidelong> and cabal-dev doesn't work and crashes when I try to build
19:52:30 <roboguy_> newsham: https://ghc.haskell.org/trac/ghc/wiki/Roles
19:52:37 <roboguy_> newsham: no, it's a ghc 7.8 thing
19:52:43 <newsham> robo: danke!
19:53:32 <carter> Kaidelong: theres a windows binary for cabal 1.20.1 up
19:54:11 <carter> http://www.haskell.org/cabal/download.html
19:54:18 <carter> http://www.haskell.org/cabal/release/cabal-install-1.20.0.1/cabal-x86_64-unknown-mingw32.tar.gz
19:54:21 <shergill> nisstyre: not that i recall, but i understand how uniqueness types work
19:54:37 <newsham> so for example you would make Coercible ([] a) (ZipLis a)  and Coercible (ZipList a) ([] a)  ?
19:54:48 <newsham> and then would you just use   coerce . f . coerce?
19:54:53 <carter> why isn't the ziplist functor instance the defualt
19:54:57 <nisstyre> shergill: https://en.wikipedia.org/wiki/Linear_logic#The_resource_interpretation
19:54:57 <roboguy_> newsham: oh, I misread your question. the newtype package might be what you want
19:55:04 <carter> i mean applicative
19:55:05 <nisstyre> shergill: that was enlightening for me
19:55:05 <carter> err
19:55:08 <carter> i'm tired
19:56:14 <newsham> ahh, NewType seems pretty applicable to this
19:56:33 <carter> Kaidelong: that help? :)
19:56:47 <shergill> nisstyre: related, http://en.wikipedia.org/wiki/Affine_type_system
19:57:11 <shergill> nisstyre: http://en.wikipedia.org/wiki/Affine_type_system#Different_substructural_type_systems specifically
19:57:15 <carter> @hackage alms
19:57:15 <lambdabot> http://hackage.haskell.org/package/alms
19:57:24 <carter> alms is an affine typed lang
19:58:05 <nisstyre> shergill: I think linear types would be better for allocating memory because you know everything will be used exactly once right?
19:58:17 <nisstyre> but of course it doesn't necessarily matter
19:58:26 <newsham> ?type ala
19:58:27 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
19:58:40 <newsham> > ala Sum foldMap [1,2,3]
19:58:42 <lambdabot>  6
19:59:29 <shergill> nisstyre: and that it will definitely be used. in certain cases you want to allow at most one use. eg. when you double the size needed by a data structure preemptively. linear type systems with their no-cloning property are also of interest when looking at quantum programming models
19:59:31 <newsham> > over (*10) (ZipList [1,2,3])
19:59:32 <lambdabot>  Couldn't match type ‘(->) a’ with ‘Control.Applicative.ZipList’
19:59:32 <lambdabot>  Expected type: a -> b
19:59:32 <lambdabot>    Actual type: Control.Applicative.ZipList b
20:00:00 <newsham> > over unZipList (*10) (ZipList [1,2,3])
20:00:02 <lambdabot>  Not in scope: ‘unZipList’
20:00:02 <roboguy_> newsham: lambdabot's over uses lens I think
20:00:13 <roboguy_> lens incorporates some stuff from newtype
20:00:16 <newsham> > over getZipList (*10) (ZipList [1,2,3])
20:00:17 <lambdabot>  Couldn't match type ‘[Data.Functor.Identity.Identity a0]’
20:00:17 <lambdabot>                with ‘Control.Applicative.ZipList a1
20:00:17 <lambdabot>                      -> Data.Functor.Identity.Identity t’
20:00:17 <lambdabot>  Expected type: Control.Lens.Setter.Setting
20:00:17 <lambdabot>                   (->) (Control.Applicative.ZipList a1) t a0 a0
20:00:23 <newsham> blah, spammy, sorry
20:00:30 <roboguy_> :t over
20:00:31 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:00:35 <newsham> I will have to play with this some.
20:01:18 <nisstyre> shergill: on a somewhat related note apparently SSA languages can do register allocation in polynomial time because the dependencies form a chordal graph (which you can k-color easier)
20:01:26 <djahandarie> Hey, at least the version from the newtype package gives you less frightening errors.
20:02:08 <Ralith> nisstyre: optimal register allocation?
20:02:13 <nisstyre> Ralith: yeah
20:02:15 <Ralith> nice
20:02:22 <nisstyre> I'm waiting for someone to make a super duper fast compiler
20:02:35 <newsham> djhanderie: opportunity: error parser.  potential name: unkmett
20:03:11 <djahandarie> Hahaha.
20:03:38 <monochrom> hehe
20:03:48 <carter> newsham: Ralith  coloring quickly != optimal coloring
20:04:14 <newsham> carter: thats probably not for me (I teach my son that lesson all the time)
20:04:22 <Ralith> carter: that's why I asked.
20:04:27 <carter> i mean nisstyre
20:04:36 <Tordek> so... I have "Instruction a = Pure (S.State Mem a) | SideEff (S.StateT Mem IO a)"... but I can't define a Monad Instruction for that, right? (it's a simple 'emulator')
20:04:40 <carter> Ralith: yeah
20:05:02 <Tordek> whether Pure s >>= t is Pure or SideEff depends on what type of instruction t returns, so I can't know if I need to make a Pure or a SideEff before actually executing t... or am I missing something?
20:05:08 <carter> if it were that easy, llvm wouldnt have a an integerprogram solver for experimental allocator
20:05:08 <shergill> nisstyre: sure, but isn't that merely delegating the problem? in that i would think writing the SSA program which makes optimal use of registers is what becomes hard in that case
20:05:19 <carter> jah
20:05:23 <Ralith> carter: though obviously if you can totally k-color quickly enough, you can just start at k=1 and work your way up...
20:05:31 <carter> Kaidelong: :P
20:05:37 <nisstyre> shergill: well yeah then you have to write an SSA program well
20:05:37 <carter> imean Ralith  :P
20:05:45 <nisstyre> but maybe that's a bit more tractable? idk
20:05:47 <carter> newsham: ssa is used in pretty much every compiler
20:05:52 <carter> nisstyre:
20:05:54 <carter> damn autocomplete
20:06:01 <nisstyre> here's a reference http://www.cs.ucla.edu/~palsberg/paper/aplas05.pdf
20:06:01 * Ralith wonders if carter's IRC client is drunk
20:06:19 <shergill> nisstyre: why would it be more tractable, or is that what the reference is for?
20:06:33 <nisstyre> shergill: that's not what the reference is for, I'm just speculating
20:06:38 <shergill> ok
20:06:44 <nisstyre> I know it probably won't result in magical speedups of all programs
20:06:48 <nisstyre> I'm not a quack :p
20:07:03 <newsham> tordek: for the sake of argument, cant it always just return SideEffect alternative?
20:07:20 <newsham> and still form a legal monad
20:07:23 <shergill> nisstyre: well the thing is that compilers do reduce program to SSA intermediate form
20:07:32 <nisstyre> shergill: yeah that is true
20:07:36 <carter> nisstyre: so it heuristically works better
20:07:40 <carter> not "always works better"
20:07:47 <nisstyre> shergill: but for a different reason I think, because it is closer to the actual machine
20:07:50 <Tordek> newsham: sure, I mean.. that was my original idea, but people here told me to separate pure and impure stuff :/
20:08:16 <newsham> tordek: also when defining the >>=, you can peek at the second action and see if it is also Pure
20:08:17 <Ralith> Tordek: it's not obvious to me that you can't define a monad for that
20:08:22 <shergill> nisstyre: it was my understanding it was because analysis on SSA forms becomes easier
20:08:23 <Ralith> as nisstyre says.
20:08:25 <Ralith> er
20:08:27 <Ralith> newsham:.
20:08:39 <shergill> #haskell is drunk tonight :P
20:08:41 <Ralith> damn, whatever carter's got is catching.
20:08:41 <nisstyre> shergill: probably that too, I'm not an expert
20:08:48 <shergill> or just dyslexic with the name completions
20:08:59 <carter> LOL
20:09:07 <carter> that was my biggest laugh today
20:09:09 * Ralith concedes to the forces of the universe and gets a drink
20:10:16 <Tordek> newsham: how can I do that?
20:10:53 <newsham> tordek:    ((Pure ..) >>= f = case (f ...) of    ?
20:12:06 <newsham> also.. you might not even need to peek
20:13:20 <newsham> is there a reason you're trying to separate Pure and SideEff?
20:13:39 <newsham> I think perhaps when people told you to keep those things sepearate they might have meant something else
20:13:44 <Tordek> newsham: other than to learn stuff, no, not really
20:13:54 <Ralith> newsham: perhaps to keep IO out of places it's not needed?
20:14:19 <newsham> ralith: right, but his monad instance probably doesnt need to have two alternatives for those two cases
20:14:46 <newsham> probably what people meant is to define a monad instance for your side effects and then to avoid using it for the pure stuff (instead just use pure code)?
20:16:23 * hackagebot tianbar 0.4.3.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.3.0 (AlexeyKotlyarov)
20:20:55 <joelteon> how are you supposed to use netwires with non-netwire services?
20:21:24 * hackagebot language-c-inline 0.5.0.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.5.0.0 (ManuelChakravarty)
20:22:18 <joelteon> like, how do you get a useful result out of a Wire, or compose it with a function that can do IO?
20:22:37 <joelteon> the only function in the documentation that mentions using the result of a wire is testWire
20:25:25 <carter> joelteon: ask mm_freak when hes on
20:28:15 <joelteon> will do
20:29:45 <carter> or email him!
20:29:49 <carter> yeah
20:29:50 <carter> do that
20:29:53 <joelteon> but that takes so long
20:30:13 <carter> so does waiting 12hrs and rememberng to ask him on irc then
20:34:23 <Yoctogon> i managed to write a prime-generating algorithm in haskell that, for some reason, had 25 pop up as a prime for no clear reason (and the /only/ composite outlier up to at least 100,000)
20:34:41 <carter> Yoctogon: thats a cool bug
20:34:42 <Yoctogon> found it kind of amusing, 5, of all things. why not 3^2? etc
20:35:18 <Yoctogon> and i haven't even bothered pinpointing exactly why, i just threw in a small hack to stomp it out
20:40:49 <sm> that's the spirit! :)
20:41:16 <Yoctogon> in this case, i don't blame haskell, i blame those darn patternless primes
20:41:39 <kylec0> @where ops
20:41:39 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:41:41 <carter> Yoctogon: what sort of sieve?
20:41:50 <carter> kylec0: what happened?
20:41:58 <johnw> is an op needed?
20:42:01 <Yoctogon> eratosthenes
20:42:08 <carter> Yoctogon: neat
20:42:20 <carter> kylec0: ... you pinged ALL the ops, something wrong?
20:42:31 <Cale> Yoctogon: are you somehow missing the square root?
20:42:51 <Yoctogon> well
20:43:02 <Yoctogon> you don't need the square root for this sieve
20:43:07 <Cale> Yeah
20:43:39 <Cale> (are you really sure it's the only incorrect one? What about 49?)
20:43:57 <kylec0> carter: sorry, no, nothing's wrong
20:43:58 <Yoctogon> yes
20:44:02 <Yoctogon> i checked up to 100,000
20:44:06 <Cale> Hard to imagine why :)
20:44:13 <Cale> I suppose I'd have to see the code
20:44:14 <Yoctogon> me too
20:44:24 <Yoctogon> although, for some reason it runs a lot slower than my other implementation that does simply trial division using the list of primes so far..
20:44:48 <johnw> Yoctogon: can you paste this slow implementation?
20:45:01 <Cale> Are you using !! for any reason?
20:45:03 <carter> please
20:45:14 <jle`> code sounds interesting
20:45:15 <Yoctogon> cale: no, using Data.Sequence, etc
20:45:27 <carter> Cale: i've a crazy idea to do a binary tree on infiinite sequences
20:45:32 <Yoctogon> and not even indexing in that deeply too (which is logn)
20:45:40 <Cale> Ah, well, even Data.Sequence has a lot of overhead, even if it's asymptotically quite good
20:46:09 <Yoctogon> i'll post it after i clean it up a little
20:46:26 <carter> nah, share the ugly
20:46:30 <kylec0> q: Is haskell an ok first language to learn assuming minimal programming background? (elementary java, python)
20:46:35 <Yoctogon> just a couple more where clauses
20:46:50 <carter> kylec0: sure
20:46:59 <carter> some would say its better to learn then
20:47:02 <Yoctogon> kylec0: depends on your background in other things
20:47:33 <kylec0> yoctogon: what kind of background do you mean?
20:47:57 <orion> How can I accomplish this?: module My.Module (module Something.I.Want.To.Export (someFunction))
20:48:06 <orion> where -- ...
20:48:08 <Yoctogon> kylec0: abstract mathematical thinking, for example
20:48:38 <kylec0> yoctogon: I'm a grad math student, so that seems applicable
20:48:39 <carter> Yoctogon: not really
20:48:45 <carter> kylec0: go crazy
20:48:47 <carter> you'll be fine
20:48:55 <carter> the math abstractions help
20:49:02 <johnw> kylec0: in that case, I highly recommend Haskell as a first language for you
20:49:04 <carter> but just writing code and asking for feedbackhelps more
20:49:06 <johnw> you'll feel right at home in some ways
20:49:13 <Yoctogon> i'm not arguing against, just that haskell might actually be too steep for beginning programmers
20:49:14 <carter> kylec0: what sort of math!
20:49:20 <carter> Yoctogon: nope, learned it in high school
20:49:24 <carter> on my own time
20:49:27 <carter> very boring haskell
20:49:29 <kylec0> carter: differential geometry, topology
20:49:33 <carter> neat!
20:49:33 <jle`> kylec0: if you are a graduate math school then haskell might be more suitable for you than other languages
20:49:35 <carter> applied or pure?
20:49:38 <Yoctogon> carter: you're the exception :p
20:49:39 <carter> jle`: nope
20:49:40 <kylec0> pure
20:49:45 <carter> kylec0: boo
20:49:45 <jle`> darn
20:50:08 <Yoctogon> i probably wouldn't recommend haskell to a randomly chosen aspiring programming
20:50:10 <carter> jle`: pure mathematicians should try coq
20:50:13 <Yoctogon> programmer*
20:50:17 <carter> Yoctogon: :)
20:50:24 <kylec0> my undergrad senior thesis was on PDE's tho
20:50:28 <jle`> o
20:50:28 <carter> kylec0: i think you'll have fun
20:50:41 <carter> kylec0: come lurk on #numerical-haskell too
20:50:43 <Ralith> kylec0: carter's advice is good
20:50:58 <carter> i'm usually not wrong, except when i am
20:51:00 <cwraith> I would like to recommend haskell to random programmers.  But I need to find a way to do so without sounding like a raving lunatic.
20:51:20 <Yoctogon> kylec0: i'd say go for it then, noting your background
20:51:21 <carter> c_wraith: "you like nice thigns, use this or I wont shutup"
20:51:31 <carter> Yoctogon: *despite* the background
20:51:43 <carter> its really not that hard to write naive haskell code that works
20:51:46 <Welkin> I know a CS PhD that doesn't program
20:51:47 <carter> same as any other language
20:51:53 <Welkin> but he uses Coq  lot
20:51:56 <c_wraith> The problem is that random programmers don't understand what they're doing, and as such have no context for understanding what haskell offers.
20:51:58 <carter> then he programs
20:52:06 <carter> c_wraith: well, then they're not programmsers
20:52:08 <Welkin> not other than in Coq
20:52:09 <carter> or at least not engineerins
20:52:14 <carter> Welkin: coq is programming
20:52:18 <Yoctogon> carter: but it might be too hard to do "useful" things in haskell for a beginner, which might make them lose interest
20:52:24 <carter> Yoctogon: false
20:52:26 <carter> really easy
20:52:47 <c_wraith> carter: My experience is that most programmers work primarily on a strategy of copy and paste from online sources until it works.
20:52:47 <jle`> c_wraith: well, then why haskell less than other languages?
20:53:05 <orion> You can export an entire module within another module's export list. Can you export specific functions within a module from another module?
20:53:07 <carter> c_wraith: so we need to write a good copy paste your way to a working CLI program tutorial
20:53:14 <Welkin> c_wraith, and that is [recisely why most "programmers" are incompetent
20:53:17 <carter> orion: sure, just write them down
20:53:18 <Yoctogon> carter: i only claim that because i know that it's pretty true for.. myself
20:53:34 <johnw> Yoctogon: can you paste your slow algorithm?
20:53:36 <carter> Yoctogon: heres the secret: throw stuff on the wall, and then fix the type errors
20:53:39 <Yoctogon> oh right
20:53:47 <carter> after a while you'll get a design sense
20:53:49 <c_wraith> sadly, haskell is a really good language for copying and pasting random sources until it works.  But it's hard to convince people of that. :)
20:53:55 <Samoi> when I type a function into hugs and it displays a result how is it displaying that result
20:53:59 <Samoi> the show function?
20:54:15 <orion> carter: Like this?: module My.Module (module Something.I.Want.To.Export (someFunction))
20:54:15 <carter> yes
20:54:16 <jle`> Samoi: the interpreter? yes
20:54:24 <jle`> um
20:54:25 <Yoctogon> haskell is the best possible language for copy pasting, heh, seeing as there isn't far-flung state to worry about
20:54:26 <c_wraith> Samoi: yes, show is used implicitly to produce printable values in interpreters
20:54:28 <carter> orion: just , someFunction
20:54:30 <Samoi> yea the interpreter
20:54:40 <Samoi> how come when I use show in my code it's different?
20:54:47 <Samoi> shows escape characters
20:55:04 <carter> ti should!
20:55:07 <carter> show != print
20:55:07 <c_wraith> Samoi: it sounds like you're using print (show x)  instead of putStrLn (show x)
20:55:14 <carter> oh that too
20:55:24 <jle`> print (show x) is putStrLn (show (show x))
20:55:29 <Samoi> ah thanks
20:55:41 <c_wraith> You could just use print x
20:55:44 <jle`> > show 7
20:55:46 <lambdabot>  "7"
20:55:47 <jle`> > show (show 7)
20:55:49 <lambdabot>  "\"7\""
20:55:52 <jle`> > show (show (show 7))
20:55:54 <lambdabot>  "\"\\\"7\\\"\""
20:56:04 <jle`> or if you have a string, putStrLn str
20:59:04 <Samoi> just removed my extra show
20:59:07 <Samoi> :)
21:00:50 <jle`> > iterate show 7
21:00:51 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
21:00:52 <lambdabot>    arising from the literal ‘7’
21:04:23 <Samoi> hrmm another noob questions sorry, how do I spread strings across multiple lines
21:04:42 <Samoi> I'm writing literate haskell btw, a quick google search didn't help
21:04:54 <Welkin> in your source or in the output?
21:05:00 <Samoi> in my source
21:05:05 <Welkin> I think you can use \
21:05:13 <Samoi> hmm I'll give that another go then
21:06:09 <sclv> you need \ to end one line and also at the start of the continued line if i recall
21:06:23 <sclv> its irritating
21:06:24 <Samoi> ah got it
21:06:27 <Samoi> yea that was right
21:09:54 <Yoctogon> johnw: sorry for the wait: http://lpaste.net/103648
21:10:14 <Yoctogon> probably the worst haskell code ever
21:11:06 <orion> hmm
21:12:31 <johnw> Yoctogon: replace foldl with foldl'
21:12:43 <Yoctogon> inb4 magically fast
21:13:12 <lahwran> I've seen the quote in a few places, what does it do?
21:13:23 <lahwran> I mean, I know it doesn't Do A Thing
21:13:26 <johnw> it is part of the name
21:13:27 <lahwran> it's part of the name
21:13:30 <johnw> it doesn't have specific meaning
21:13:35 <lahwran> but what does it me... oh
21:13:37 <johnw> it's often used by convention to mean "the strict version"
21:13:41 <lahwran> (..mean when it's part of the name)
21:13:44 <lahwran> ah, I see
21:14:01 <Yoctogon> johnw: nope
21:14:20 <kimiaki> Hello Wold
21:14:26 <kimiaki> こんにちわ世界
21:14:42 <kimiaki> exit
21:15:32 <orion> If I have "myfunc :: IO (Maybe Int)", how can I avoid chaining case/Just/Nothing statements together?
21:16:27 <Yoctogon> transformer?
21:16:31 <johnw> Yoctogon: I've not seen Sequence used for this before
21:17:33 <Yoctogon> actually, the sequence might be overkill
21:17:54 <orion> Is a transformer strictly necessary?
21:17:54 <Yoctogon> maybe.
21:18:27 <johnw> Yoctogon: here's my sieve: https://gist.github.com/11553190
21:18:51 <johnw> I ended up not using it
21:19:04 <Yoctogon> i should probably switch to Vector instead
21:20:20 <johnw> if you know the bound of the highest prime you will search for, it's fast; if you don't know, it can be slow
21:20:53 <Yoctogon> you mean, like using the square root?
21:21:29 <johnw> i mean, allocating the vector for your sieve
21:21:57 <Yoctogon> oh i see
21:22:12 <Yoctogon> yeah, i'm trying to achieve infinite lazy lists though
21:23:13 <Yoctogon> i'm probably overlooking an important optimization, or not using Sequence optimally
21:24:19 <Yoctogon> orien: i think, pretty much yes.
21:24:35 <Yoctogon> the only alternative i can think of is by moving the Maybe code into pure code
21:25:16 <johnw> Yoctogon: have you profiled the code?  checked allocation?
21:26:05 <newsham> ?type curry
21:26:06 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:26:10 <Yoctogon> johnw: not in detail, i'm actually rather inexperienced with profiling haskell code
21:26:18 <orion> hm
21:26:29 <johnw> it's quite easy, but you'll need to rebuild everything with library-profiling enabled
21:26:45 <orion> In attoparsec, is it possible to induce failure based on an arbitrary function returning a bool?
21:26:47 <newsham> ?hoogle (f,x) -> f x
21:26:47 <lambdabot> Prelude snd :: (a, b) -> b
21:26:47 <lambdabot> Data.Tuple snd :: (a, b) -> b
21:26:47 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
21:27:05 <johnw> orion: I'm pretty sure you can use "guard <Bool>"
21:27:10 <orion> oh crap!
21:27:11 <orion> yes
21:27:52 <orion> guard is in Control.Monad, not Attoparsec, which is why I wasn't finding anything
21:27:57 <cwc> anybody use yesod?
21:28:10 <johnw> there is a #yesod
21:28:13 <johnw> but some of us do, yes
21:28:28 <cwc> ah cool
21:29:36 <orion> johnw: Can guard reduce a do block to "Nothing" instead of ()?
21:30:13 <johnw> by "Nothing" do you mean "return Nothing'?
21:30:22 <orion> hm, I think so
21:30:31 <johnw> Nothing <$ guard <Bool>
21:30:42 <johnw> no, that's won't work
21:30:55 <johnw> well, the Nothing will never be returned
21:31:21 <johnw> > 10 <$ guard (1 == 2) :: Maybe Int
21:31:22 <lambdabot>  Nothing
21:31:33 <johnw> > Nothing <$ guard (1 == 1) :: Maybe Int
21:31:34 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
21:31:34 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
21:32:31 <johnw> > Nothing <$ guard (1 == 2) :: Either String (Maybe Int)
21:32:32 <lambdabot>  Left ""
21:32:35 <johnw> > Nothing <$ guard (1 == 1) :: Either String (Maybe Int)
21:32:36 <lambdabot>  Right Nothing
21:32:58 <johnw> the Nothing is returned if it succeeds
21:33:24 <orion> ok, thank you
21:37:33 <voldyman> hey guys, i am learning haskell, wanted to write an application to parse Json from an api, the tutorials have blown me away, applicative functors? what are they?
21:37:44 <voldyman> is there any easier tutorial?
21:39:22 <johnw> good thing you didn't read the one that does it with lenses!
21:39:32 <johnw> @where lyah
21:39:32 <lambdabot> http://www.learnyouahaskell.com/
21:40:09 <johnw> the thing is, once you know what it all is, parsing json is simply a breeze
21:40:16 <johnw> but getting there, I admit, is no quick road
21:40:50 * lispy mumbles about skipping the tutorials and going to the source http://strictlypositive.org/IdiomLite.pdf
21:41:16 <johnw> well, you could do that too
21:41:23 <johnw> depends on your inclination
21:41:36 <lispy> reading papers takes practice, but in the case of applicative it was the only thing that worked for me.
21:42:16 <lispy> Plus, anything by Conor McBride is worth reading.
21:43:02 <lispy> "Just go read the paper" is advice I would have scoffed at 10 years ago. Now it's my go-to.
21:43:20 <johnw> plus a lot of the papers are really excellent, deserving of multiple reads
21:43:48 <voldyman> hmm, why not both :)
21:44:29 <lispy> voldyman: you mean tutorial and paper?
21:45:04 <voldyman> yes, first lyah (i've read half already) then the paper
21:45:14 <lispy> you are very welcome to do that :)
21:45:29 <lispy> lyah is considered by some to be very weak theoretically
21:45:35 <lispy> (I haven't read it)
21:45:39 <voldyman> :/
21:45:53 <lispy> The thing it seems to do well is getting people engaged by being cute and light hearted.
21:45:58 <lispy> For that I'm grateful
21:46:13 <johnw> i found it fun
21:48:40 <lispy> johnw: I've been meaning to make a list of papers that shaped my PL/Haskell understanding (or are otherwise insightful)
21:49:00 <lispy> A haskell reading list, if you will
21:49:19 <johnw> i'd love to see it
21:50:38 <mmachenry> lispy: johnw Benjamin Pierce made one
21:50:45 <lispy> voldyman: BTW, have you learned about functors yet?
21:51:17 <lispy> mmachenry: oh, cool. Do you have a link? I'm not finding it on google.
21:51:19 <mmachenry> http://www.cis.upenn.edu/~bcpierce/courses/670Fall04/GreatWorksInPL.shtml
21:51:26 <lispy> Thanks!
21:51:34 <orion> Is there a better way to rewrite the function "foo" located here?: http://ideone.com/i1Wr30
21:51:49 <mmachenry> He wrote the epic book Types and PL
21:52:39 <lispy> mmachenry: these papers are more broad and older than I had in mind, but having said that I recoginize some of these as quite good.
21:52:48 <lispy> mmachenry: yes, I has that book :)
21:53:01 <m09> orion: you can at least factorize the return (return $ case decode x of…)
21:53:22 <orion> No syntactic sugar for that?
21:53:36 <mmachenry> orion: does returning y and () work?
21:53:46 <voldyman> lispy: nope.
21:53:58 <orion> mmachenry: I think that's what I'm supposed to do for attoparsec, am I wrong?
21:54:29 <lispy> voldyman: functors, applicative functors, and monads are ideas we've borrowed from a branch of math known as category theory.
21:54:30 <mmachenry> No clue. Seems odd. What's the type of case
21:54:46 <orion> Maybe SomeType
21:54:54 <lispy> voldyman: luckily for Haskell beginners, do you don't need to understand (or study) category theory to use them in your code
21:55:05 <orion> Oh
21:55:19 <orion> The case should evaulate to "Parser SomeType", I think.
21:55:25 <voldyman> lispy: yeah, i've heard that sentence many times.
21:55:44 <m09> orion: but () is not of type SomeType
21:55:51 <mmachenry> orion: Is () :: Sometype?
21:56:02 <voldyman> lispy: coming from clojure, your name sounds comforting :)
21:56:07 <Welkin> > :t ()
21:56:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:56:12 <lispy> voldyman: I don't know what order they are introduced in lyah, but I listed them in order of increasing conceptual complexity.
21:56:12 <Welkin> :t ()
21:56:13 <lambdabot> ()
21:56:51 <Welkin> in LYAH they are introduced as: functors, applicative functors, monoids, then monads
21:56:57 <lispy> voldyman: heh. I started with common lisp but it turns out I'm not smart enough (or disciplined enough) to program in a dynamicly typed language
21:57:01 <orion> This is true, m09 / mmachenry.
21:57:06 <voldyman> lispy: i read a lot about monads a few months ago, been trying to learn haskell froever.
21:57:11 <orion> I am not sure how to tell the parser to fail in this case.
21:57:29 <m09> I really like the way Tony Morris introduces the typeclasses: Functor, Apply, Applicative, Bind, Monad
21:57:40 <m09> it's really progressive and comprehensive
21:57:51 <voldyman> lispy: not smart enough to trust yourself with dynamic types but smart enough to do haskell ? :)
21:58:22 <lispy> voldyman: haskell allows programming to be much easier and more to the point
21:58:44 <lispy> Mind you, you can write fortran in any language
21:59:18 <voldyman> the amount of python code i've read that made me cry is too damn high
22:00:00 <voldyman> my friends have a startup which works on robotics, those guys are embeded C programmers and when they write python or java or any other language it makes me cry
22:00:24 <Welkin> well, someone programmers try to write in their preferred style no matter the language
22:00:29 <voldyman> everything is a global variable, 😢
22:00:31 <Welkin> and many languages make it too easy to write poorly
22:01:00 <Welkin> use the right tool for the job
22:01:26 <lispy> voldyman: I think this article puts systems/embedded programming in scope: http://research.microsoft.com/en-us/people/mickens/thenightwatch.pdf
22:01:55 <Welkin> The Knight's Watch
22:02:22 <carter> hah
22:02:27 <carter> mickens writes magic
22:04:03 <orion> mmachenry: I guess I am having trouble trying to force the parser to fail if I get a Nothing as opposed to a Just
22:04:24 <lispy> orion: is your Parser a MonadPlus?
22:04:41 <lispy> :t guard
22:04:42 <lambdabot> MonadPlus m => Bool -> m ()
22:04:45 <orion> lispy: Data.Attoparsec.ByteString...
22:05:05 <mmachenry> Well I don't know that parser…what type is failure
22:05:16 <orion> :t Parser
22:05:17 <lambdabot> Not in scope: data constructor ‘Parser’
22:05:19 <orion> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Types.html#t:Parser
22:05:45 <orion> The "Instances" at the above URL doesn't seem to indicate that Parser is a MaybePlus.
22:06:02 <lispy> orion: Search for MonadPlus
22:06:02 <orion> oh wait
22:06:06 <orion> "This type is an instance of the following classes... "
22:06:10 <lispy> Never heard of MaybePlus :)
22:06:26 <orion> ah typo
22:06:34 <lispy> Monoid t => MonadPlus (Parser t)
22:06:41 <orion> yup, I missed it
22:06:43 <lispy> orion: can your SomeType be a Monoid?
22:07:02 <orion> no
22:07:13 <lispy> Then no MonadPlus for you.
22:07:25 <lispy> It's a shame too, guard would be a nice way to do this
22:08:20 <orion> newtype SomeType = ST ByteString deriving (Eq, Ord) <-- this is the definition of SomeType I am working with.
22:08:23 <orion> And I have no control over it.
22:09:33 <Heffalump> is something known to be wrong with code.haskell.org?
22:10:46 <lispy> Heffalump: it's working for me
22:10:49 <lispy> Heffalump: what are you seeing?
22:10:51 <Heffalump> can you ssh it it?
22:10:56 <lispy> Heffalump: I know there was a dns change today
22:10:59 <Heffalump> oh, my conenction finally worked
22:11:10 <lispy> But I think the dns change shouldn't affect this domain name
22:11:12 <Heffalump> I guess that's inevitable when I asked about it :-)
22:11:45 <td123> I updated ghc to 7.8.2 and I get the following when trying to install keter into a fresh install with no cabal packages: http://pastie.org/pastes/9144628/text
22:11:48 <Heffalump> sorry for the noise
22:12:05 <td123> is there an easy way to figure out why unix 2.7 needs a downgrade?
22:12:43 <lispy> orion: I think you use fail
22:12:44 <Heffalump> td123: try rerunning the cabal install with --constraint unix>2.7.0.1'
22:12:52 <Heffalump> then it'll tell you what doesn't like that
22:13:00 <Heffalump> or --constraint 'unix installed'
22:13:03 <lispy> Heffalump: no worries
22:13:10 <Heffalump> my first line should have a single quote before unix too
22:13:53 <orion> lispy: Will that kill my application?
22:14:28 <Heffalump> orion: not in a parser, typically, it'll just cause a parse failure
22:15:39 <lispy> orion: I don't see it in the attoparsec docs, but it would be nice to have a function (a -> Maybe b) -> a -> Parser b
22:16:03 <td123> Heffalump: it went ahead with the install correctly with that flag.
22:16:27 <orion> lispy: It wouldn't be hard to write one, right?
22:16:44 <lispy> orion: no and it may actually exist at some other (polymorphic) type
22:17:02 <lispy> ?hoogle (a -> Maybe b) -> a -> Parser b
22:17:02 <lambdabot> No results found
22:17:17 <lispy> ?hoogle (a -> f b) -> a -> m b
22:17:17 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
22:17:18 <lambdabot> Data.IntMap.Strict mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
22:17:18 <lambdabot> Data.IntMap.Lazy mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
22:17:24 <Heffalump> td123: oh, ok :-) Normally if that were possible it would prefer that
22:17:37 <Heffalump> it's possible something else ended up needing to be reinstalled instead
22:18:00 <td123> Heffalump: it's a brand new folder, no packages installed :)
22:18:29 <lispy> orion: foo mb a = case mb a of Nothing -> fail "foo saw Nothing"; Just b -> return b
22:19:24 <Welkin> A Heffalump!
22:19:27 <Heffalump> td123: hmm, don't know then
22:19:29 <Welkin> watch out for the Woozles!
22:19:39 <lispy> I wish haddock had an index that listed the types
22:20:06 <td123> Heffalump: thanks for solving the problem, even though we're not sure why that worked :)
22:20:44 <Heffalump> in general I find telling cabal what I want it to do with --constraint is quite useful
22:21:00 <Welkin> a heffalump that writes Haskell
22:21:04 <td123> thanks for that trip
22:21:08 <td123> trick
22:21:08 <Welkin> what do woozles program in?
22:21:16 <lahwran> erlang?
22:24:34 <Heffalump> Welkin: perhaps I'm just here for the honey
22:25:34 <orion> lispy: That worked, thank you. :)
22:28:11 <lispy> orion: BTW, I wasn't sure if attoparsec used fail for failure. Do you know how I figured it out?
22:30:19 <orion> lispy: You read the source/docs?
22:30:36 <lispy> orion: yeah, but it was more directed than that
22:30:48 <johnw> I do believe he simply tried it :)
22:31:02 <lispy> orion: from the haddocks I went to a function that I knew could fail (satisfy) and chased the definitions until I found a use of fail
22:31:21 <mada> I created a lens using makeLenses on a type that has a function as one of its fields. How can I use the lens focused on this function to execute it?
22:31:33 <johnw> lispy: couldn't you have just tried an impossible pattern match?
22:31:35 <lispy> johnw: It worked on paper so I stopped there :)
22:31:49 <lispy> johnw: I don't have attoparsec installed
22:32:14 <johnw> mada: (foo^.functionField) argument
22:32:30 <johnw> there are still machines without attoparsec installed out there?
22:32:31 <johnw> who knew
22:32:41 <orion> lispy: ahh, good point
22:33:26 <lispy> johnw: I work out of sandboxes so I would have had to make a throw away cabal file and installed it there.
22:33:37 <lispy> johnw: I've been meaning to script that process for doing stuff like this...
22:33:50 <lispy> or have a "try stuff out" sandbox
22:34:36 <johnw> this is one area where Nix shines pretty well
22:35:13 <johnw> i have a global "GHC 7.8.2" environment that I load, then from within there I can use nix-shell to drop into environments tuned to a particular project; it's like layered sandboxes
22:37:45 <mada> johnw: thank you
22:42:41 <lispy> johnw: I wonder how much of hackage could be installed in a single sandbox...
22:43:02 <srhb> Probably not very much.
22:43:27 <dmj> lispy: only one way to find out :P
22:43:40 <srhb> cabal install ALLTheThings
22:43:50 <johnw> lispy: I've wondered that before too
22:43:57 <lispy> What would be interesting is to find the maximal subset of hackage
22:44:06 <johnw> all of stackage can be, that's a starting point
22:44:12 <lispy> (and trying your best to stick to the latest packages)
22:44:26 <lahwran> lispy: do things conflict?
22:44:34 <lahwran> if not, then it's just a matter of disk space
22:44:47 <lahwran> I'm not familiar enough to know if they can conflict, though
22:44:49 <johnw> things conflict
22:45:32 <johnw> one package may need aws 0.9 to compile, another has a constraint on aws <0.9
22:45:35 <redtricycle> I'm using a cabal-dev sandbox, how do I let runghc know its location so I can use the libraries in it?
22:45:56 <redtricycle> I'm using the "quickrun" vim plugin, and my goal is to use quickrun in the sandbox
22:48:14 <lispy> redtricycle: cabal-dev ghci
22:48:49 <lispy> redtricycle: cabal-dev has been deprecated now that cabal has sandboxes. You'll want to upgrade when you have time.
22:49:20 <redtricycle> I'm using haskell-platform, which has cabal 1.16, cabal sandbox is in 1.18, is it ok for me to update cabal to 1.18 without updating haskell-platform?
22:49:47 <dmj> redtricycle: yes
22:49:56 <abh> hi predator117 redtricycle yes
22:50:03 <redtricycle> ok
22:50:47 <redtricycle> cabal install cabal-install, correct?
22:50:56 <abh> cabal update first
22:51:41 * hackagebot snap 0.13.2.5 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.5 (DougBeardsley)
22:52:14 <lispy> redtricycle: and add a magic -j to make it go fast
22:52:57 * lispy _ = Bed
22:53:16 <johnw> lipsy: does that mean that all arguments result in you going to bed?
22:53:30 <srhb> Trivially, yes!
22:53:44 <johnw> lispy's sleeptime is const
22:53:53 <abh> redtricycle: also: runghc -package-db=.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d/
22:54:24 <srhb> abh: What's that for?
22:54:38 <abh> to make runghc use the packages installed in cabal sandbox
22:55:31 <dmj> abh: why not just use cabal?
22:56:08 <abh> redtricycle: is uding quickrun vim pluging which uses runghc
22:56:34 <newsham> how long does haskell platform lag behind ghc releases?  whats the estimate for when the latest ghc 7.8.* line will make its way into haskell platform?
22:57:09 <abh> afaik, there is one release of haskell-platform every year
22:57:44 <Guest87869> what does the notation mean...  x : X   y : Y  /  x = y : Z, written out on two lines, i see everywhere
22:58:14 <Guest87869> something about denotational semantics
22:58:27 <lahwran> I'm trying to learn haskell without actually reading through a tutorial; it is going badly and I should probably finish reading the tutorial
22:58:34 <dmj> newsham: haskell platform is just a package, you can get ghc-7.8 now, https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal
22:58:42 <newsham> the latest release was about a year ago
22:59:27 <dmj> lahwran: what tutorial?
22:59:36 <lahwran> dmj: that's the problem!
22:59:43 <lahwran> nah, I was reading "learn you a haskell" or something like that
22:59:55 <kylec01> q: i used 'cabal install ad' but i get this error: cabal: Error: some packages failed to install: ad-4.2.0.1 depends on distributive-0.4.3.2 which failed to install.
23:00:07 <lahwran> but dropped it after like half of the first page because I wanted gloss and I wanted it NOW
23:00:08 <lahwran> :>
23:00:09 <tac_> lahwran: heh, I know that feeling
23:00:33 <lahwran> and so I've been blindly swinging my way through trying to make something with gloss without actually knowing what half the syntax meants
23:00:34 <lahwran> means*
23:00:35 <lahwran> :D
23:00:42 <lahwran> I'm kinda doing it!
23:01:02 <lahwran> right now I have a type mismatch, I'm pretty sure I know why, but I don't know how to resolve it
23:01:34 <tac_> What's the error? (Also, do you know about hpaste?)
23:01:36 <tac_> @hpaste
23:01:37 <lambdabot> Haskell pastebin: http://lpaste.net/
23:01:42 * hackagebot conduit 1.1.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.2 (MichaelSnoyman)
23:01:57 <kylec01> no, i didn't, let me paste the full error
23:01:57 <lahwran> uh, nope. I generally use gist
23:02:08 <lahwran> heh, could have been to either of us
23:02:09 <supki> kylec01: the real error is somewhere higher in the build log
23:02:17 <supki> kylec01: yeah, a paste would help
23:02:32 <lahwran> tac_: let me paste my code and the error
23:02:36 <tac_> sure
23:03:01 <lahwran> is it bad practice to use unqualified imports?
23:03:12 <kylec01> http://lpaste.net/103649
23:03:16 <lahwran> it's considered bad practice to do import * in python, so I'm surprised the tutorials are recommending it in haskell
23:03:46 <lahwran> I googled import, and it gave me a bunch of ways to do qualified names, so I'm just curious why example code and stuff doesn't usually use them
23:03:49 <tac_> lahwran: Haskell modules are kludgy.
23:04:07 <tac_> You get lots of name clashes, so qualified is good practice, probably.
23:04:18 <tac_> But overall, there's no good way to do it, since package names are also obnoxiously long in Haskell
23:04:36 <lahwran> "as" imports?
23:04:36 <lahwran> https://gist.github.com/lahwran/d1f413fa8534ff502b04
23:04:39 <tac_> (Most people use import qualified PackageName as PN, but I don't care for that either)
23:04:41 <mmachenry> tac_: You can give an alias using as
23:04:50 <lahwran> tac_: yeah that looks gross to me
23:05:15 <lahwran> in python I usually do from twisted.internet import reactor, so in haskell I'd do import qualified Numeric.Noise as Noise
23:05:32 <tac_> ah, it looks like you have to coerce between floats and doubles
23:05:39 <tac_> @hoogle Float -> Double
23:05:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:05:40 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
23:05:40 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
23:05:42 <lahwran> yep, I can tell! I just don't know how
23:05:47 <tac_> lol, unsafeCoerce....
23:05:52 <lahwran> I don't know how to read lambdabot's output :x
23:06:07 <lahwran> OH wait
23:06:14 <lahwran> I also need to scale the output
23:06:15 <tac_> It's an art to read GHC's error messages
23:06:27 <tac_> but yeah, you just need to coerce the numeric types here
23:06:31 <lahwran> ghc's error messages I kinda understood, lambdabot confused me
23:06:34 <tac_> I'm not sure how you do that, though
23:06:45 * lahwran googles "haskell convert float to double"
23:06:53 <lahwran> er. wait, I said that backwards. probably the same answer though
23:06:59 <tac_> yeah
23:07:06 <tac_> They are probably just fromFractional or something like that
23:07:10 <tac_> @type fromFractional
23:07:11 <lambdabot>     Not in scope: ‘fromFractional’
23:07:12 <lambdabot>     Perhaps you meant ‘fromRational’ (imported from Prelude)
23:07:15 <supki> kylec01: do you have those libraries at all? they should be somewhere under ~/.cabal/lib
23:07:15 <tac_> or whatever
23:07:27 <tac_> (Haskell's numeric tower is pretty terrible and hard to remember :<
23:07:44 <Guest87869> just remember fromIntegral and realToFrac
23:07:49 <lahwran> wtf how am I supposed to define float2Double?http://www.haskell.org/haskellwiki/Converting_numbers
23:07:56 <lahwran> er, pretend I said a space after ?
23:08:04 <lahwran> Guest87869: haskell has a fraction type? :D
23:08:07 <Guest87869> > realToFrac (3.14 :: Float)
23:08:09 <lambdabot>  3.140000104904175
23:08:14 <Guest87869> > :t realToFrac (3.14 :: Float)
23:08:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:08:21 <Guest87869> :t realToFrac (3.14 :: Float)
23:08:22 <lambdabot> Fractional b => b
23:08:26 <tac_> @type realToFrac
23:08:27 <lambdabot> (Real a, Fractional b) => a -> b
23:08:50 <tac_> (Seriously, who the hell thought that Real and Fractional were meaningful classes D:
23:08:54 <Guest87869> lahwran: 3 % 4 would be a rational number
23:09:00 <lahwran> is Fractional different than Real in any usage manner, or just internal representation?
23:09:02 <Guest87869> tac_: yeah...
23:09:25 <tac_> and RealFrac too >___>
23:09:28 <Guest87869> lahwran: these are two type classes which have arbitrarily assigned operations
23:09:39 <Guest87869> you can look them up
23:10:18 <Guest87869> :t sin
23:10:19 <lambdabot> Floating a => a -> a
23:10:22 <lahwran> wah
23:10:33 <Guest87869> :t recip
23:10:34 <lambdabot> Fractional a => a -> a
23:10:41 <Guest87869> :t isNaN
23:10:42 <lambdabot> RealFloat a => a -> Bool
23:10:45 <Guest87869> heh
23:11:00 <tac_> So Real gives you things that can be... turned into Rational... ok good....
23:11:05 <tac_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Real
23:11:27 <tac_> Fractional gives you division and fromRational.. I guess that makes actual sense:
23:11:28 <tac_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Fractional
23:11:29 <lahwran> this does not look like simplex noise! http://imgur.com/8KJk93G
23:11:34 <lahwran> or perlin noise
23:11:34 <lahwran> w/e
23:11:38 <Guest87869> Floating, Fractional, RealFloat, Real, and RealFrac
23:11:42 <lahwran> wtfdidIdo
23:11:42 <klugez> lahwran: Fractional has division but might be represented as a ratio or something. Floating are floating point numbers. Or something like that.
23:12:18 <Guest87869> Floating is more like "Real-like" which gives you sqrt and sin
23:12:26 <Guest87869> Real is almost pointless
23:13:08 <Guest87869> RealFloat is floating point related
23:13:52 <Guest87869> Fractional supports Rational-like operations
23:14:02 <ReinH> jfischoff: hai
23:15:27 <Guest87869> Real only has toRational, which doesnt seem to make sense for anything that would be like Reals
23:15:44 <Guest87869> unless the implication is toApproximateRational
23:16:15 <ReinH> Guest87869: well it would be a partial function, wouldn't it
23:16:17 <Guest87869> nonetheless all of this is standard for converting fractional numbers between different types
23:16:26 <bgwines> 'hoy, there — apparently this is a good place to go to if you want to figure out something Haskelly.
23:16:29 <bgwines>  I was hoping to banter a bit about infinite types and the y combinator; is this the right place to ask about that?
23:16:30 <bgwines> (thanks in advance)
23:16:47 <johnw> if it relates the Y combinator to Haskell, sure
23:16:48 <ReinH> (considering the actual real numbers rather than the real numbers that are representable on binary architectures...)
23:16:52 <tac_> bgwines: here or #haskell-blah if it's less haskelly stuff
23:17:17 <ReinH> bgwines: go ahead and ask and then we will know
23:17:20 <Guest87869> ReinH: i dont know what happens when you convert a computable real which is irrational into a rational
23:17:30 <bgwines> johnw: and tac_: reasonably so. Thanks! Basically, I was noticing that
23:17:45 <Guest87869> > toRational (pi :: CReal)
23:17:46 <lambdabot>  *Exception: CReal.toRational
23:17:48 <bgwines> so, like, you'd expect a fixed point combinator to have the type (a -> a) -> a
23:17:51 <bgwines> and if you do
23:18:01 <Guest87869> > toRational (3.14 :: CReal)
23:18:02 <bgwines> `y f = let x = f x in x'
23:18:02 <lambdabot>  *Exception: CReal.toRational
23:18:05 <bgwines> *`
23:18:06 <bgwines> then you get that
23:18:07 <tac_> Thankfully, no one has ever actually bothered to implement arbitrary precision reals and at later wanted to execute them in any program.
23:18:10 <ReinH> Guest87869: perhaps you are mistaking computable with representable
23:18:11 <Guest87869> nevermind, CReal isnt Real ;)
23:18:16 <bgwines> likewise with `let y f = f $ y f`
23:18:21 <ReinH> Guest87869: i.e. representable on actual modern architectures
23:18:23 <Guest87869> im just saying the name of the class is wrong
23:18:28 <ReinH> vs. theoretically computable
23:18:32 <bgwines> but if you try and stick in the standard lambda calculus version,
23:18:34 <Guest87869> ReinH: pi :: CReal works fine
23:18:43 <bgwines> `y = \f -> (\x -> f (x x)) (\x -> f (x x))`,
23:18:53 <bgwines> then you get an error that you're trying to construct an infinite type
23:18:53 <ReinH> Guest87869: it can't possibly "work fine" for any definition of same that includes "is accurate"
23:18:54 <bgwines> .
23:19:06 <Guest87869> its as accurate as you like
23:19:09 <ReinH> Guest87869: oh, where CReal is the computable reals, ok
23:19:11 <Guest87869> unless uncomputable reals
23:19:17 <newsham> chasing down links in the typeclassopedia is very rewarding
23:19:17 <Guest87869> unlike*
23:19:25 <johnw> bgwines: also see: http://stackoverflow.com/questions/4273413/y-combinator-in-haskell
23:19:34 <johnw> and http://programmers.stackexchange.com/questions/215712/type-checking-and-recursive-types-writing-the-y-combinator-in-haskell-ocaml
23:19:35 <bgwines> johnw: thanks! I'll take a look :)
23:19:51 <ReinH> when in doubt search stackoverflow
23:19:52 <bgwines> it makes sense that you'd get an infinite type, since effectively what it's doing is passing the function to itself
23:19:54 <bgwines> haha
23:19:55 <johnw> the latter is exactly about your question
23:20:08 <tac_> bgwines: infinite types break type inference in Haskell. You have to use recursion and pattern-matching :<
23:20:10 <bgwines> so I'm almost surprised that it works with the first two implementations
23:20:23 <ReinH> Guest87869: is CReal an actual thing somewhere?
23:20:31 <bgwines> anyway, I'll check those out. Thanks, guys! This was super-helpful.
23:20:32 <ReinH> Guest87869: and do you have a name other than "guest"?
23:20:38 <newsham> > showCReal 100 pi
23:20:39 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
23:20:54 <ReinH> huh, where does CReal come from?
23:21:01 <newsham> ?hoogle CReal
23:21:02 <lambdabot> No results found
23:21:04 <johnw> numbers
23:21:06 <ReinH> hoogle was... yes, unsuccessful
23:21:11 <johnw> http://hackage.haskell.org/package/numbers
23:21:15 <ReinH> thanks
23:21:18 <johnw> I maintain it now :)
23:21:24 <ReinH> johnw: oh ok then <
23:21:26 <ReinH> <3
23:22:06 <ReinH> anyway there is still a difference between "representable on some architecture" and computable
23:22:14 <ReinH> 100 digits of pi != pi
23:22:47 <ReinH> and for any n digits of pi
23:23:25 <ReinH> since, you know, that is what it means for a number to be trancendental
23:23:47 <Guest87869> ReinH: the result of showCReal is a string, not a number
23:23:59 <klrr_> "A is isomorphic to B" means they are equal in "A and B have same type" but not talking about types?
23:24:01 <tac_> It's kinda silly anyway because the existence of noncomputable reals has more to do with the fact you've defined your turing machine in terms of your set theory.
23:24:07 <Guest87869> and no, fininte non zero digits of something isnt transcendental
23:24:14 <johnw> klrr_: it means that there exist functions A -> B and B -> A
23:24:25 <klrr_> okey
23:24:31 <johnw> and that these compose to identity in both directions
23:24:34 <newsham> whats the difference between pi and forall n . showCREal n pi   ?
23:24:39 <johnw> f . g = id, and g . f = id
23:24:46 <ReinH> newsham: really?
23:24:53 <ReinH> there is a pretty obvious difference.
23:24:58 <klrr_> so if i say "Option type from Scala is isomorphic to Haskell's Maybe" does that mean there is a function from the first to the second?
23:25:05 <newsham> i'm not a mathematician and it doesnt seem obvious to me
23:25:19 <johnw> klrr_: it means you could lossly translate from one to the other and back again
23:25:22 <mmachenry> ReinH: It's an honest question. There's no shame in not knowing.
23:25:24 <johnw> losslessly
23:25:24 <ReinH> newsham: Pick an n. Any n. pi has more digits than that n.
23:25:37 <ReinH> mmachenry: I'm not trying to shame anyone...
23:25:43 <johnw> "equivalent for all intents and purposes"
23:25:51 <newsham> reinh: right so for any n I pick its less than pi, but the algorithm can always do an n larger than that
23:25:59 <klrr_> johnw: oh okey, so Int is isomorphic to Double but Double isnt isomorphic to Int?
23:25:59 <newsham> since the algorithm works for all n
23:26:12 <johnw> Int and Double are not isomorphic
23:26:18 <ReinH> newsham: infinity is not a number
23:26:18 <tac_> Yeah. pi and forall n. showCReal n pi seem to be observationally equivalent.
23:26:24 <ReinH> there is no `n' that is equal to infinity
23:26:31 <johnw> you would need lossless translation in both directions for all values of Int and all values of Double
23:26:35 <newsham> i didnt even mention infinity.
23:26:36 <Guest87869> its like there is no such thing as an infinite list because i lose patience watching the list print out in finite time
23:26:54 <klrr_> > fromInteger 5 :: Double
23:26:56 <lambdabot>  5.0
23:27:24 <klrr_> > toInteger (fromInteger 5 :: Double)
23:27:25 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Double)
23:27:25 <lambdabot>    arising from a use of ‘GHC.Real.toInteger’
23:27:30 <klrr_> okey
23:27:34 <ReinH> pi = forall n. showCReal n pi is equivalent to disproving cantor's diagonalization
23:27:36 <johnw> it has to work for all values of both A and B
23:27:39 <newsham> for any small size you pick, i can get a representation of pi that is closer than that size to the real value of pi
23:27:41 <tac_> ReinH: What about this infinity?
23:27:48 <klrr_> johnw: okey i think i kinda get it, thanks!
23:27:57 <ReinH> newsham: that might be true, but that representation is not pi
23:27:58 <tac_> @type Natural
23:27:59 <lambdabot> Not in scope: data constructor ‘Natural’
23:28:01 <johnw> in set theory, it's called a bijection, if that helps
23:28:01 <ReinH> and limits do not work that way
23:28:02 <tac_> do we have natural? damn...
23:28:25 <tac_> ω :: Natural; ω = S ω    if we did have it
23:28:26 <ReinH> if this is true then the natural numbers are in bijection with the reals
23:28:28 <ReinH> which is not true
23:28:52 <newsham> reinh: hmm.. how does it disprove his diagonalization?  (is that a proof that reals are larger than naturals?)
23:29:02 <ReinH> there is no natural number n for which showCReal n pi is *equal to* pi
23:29:06 <newsham> reinh: wouldnt it only mean that CReals are not larger than naturals?
23:29:16 <tac_> ReinH: Only if your logic is strong enough to construct such a bijection though.
23:29:26 <ReinH> tac_: well it isn't my logic, is it :p
23:29:43 <newsham> i thought constructive math uses definitions of reals similar to that (ie dedekind cuts and such)?
23:29:46 <ReinH> because that would imply that the representation of pi is finite
23:29:48 <ReinH> which is not true
23:30:10 <newsham> reinh: the representation of pi is definitely finite.  two ascii chars.. only 1 unicode char.
23:30:24 <ReinH> newsham: really...
23:30:26 <newsham> its just not finite in any base
23:30:28 <Guest87869> forall n, this isnt finite
23:30:35 <tac_> https://en.wikipedia.org/wiki/Skolem's_paradox
23:30:39 <ReinH> Guest87869: yes it is.
23:30:45 <ReinH> any given n is finitary
23:30:53 <Guest87869> the whole set isnt finite
23:30:54 <ReinH> infinity is not among the natural numbers
23:30:58 <ReinH> it doesn't matter
23:31:04 <ReinH> we're talking about *fixing* some n
23:31:11 <Guest87869> no
23:31:11 <tac_> ZFC, even though it contains the reals, has a countable model.
23:31:17 <ReinH> yes.
23:31:23 <tac_> Thus, informally "the reals are both countable and uncountable"
23:31:26 <Guest87869> for all, not for one
23:31:44 <ReinH> Ok, if you want to be pedantic
23:31:52 <tac_> The model represents them as a countable set. But in the target logic, they are uncountable.
23:31:53 <newsham> reinh: i think he means the construct "forall n . ...." is not finite
23:32:05 <ReinH> yes, and that construct doesn't produce a value anyway
23:32:10 <ReinH> so it's meaningless
23:32:21 <Guest87869> im going to ask what forall n. f n means anyway
23:32:28 <Guest87869> a set?
23:32:30 <tac_> Infinity is a perfectly good conatural number.
23:33:02 <ReinH> the idea that you can via through any enumeration of the naturals construct an irrational number is... wrong.
23:33:05 <ReinH> s/via //
23:33:30 <Guest87869> ReinH: you arent arguing that pi isnt computable, you are arguing that infinity doesnt exist because a machine cant be infinite, or a document cant be infinite
23:33:37 <ReinH> no, I am not
23:33:49 <newsham> reinh: you didnt define what "wrong" means.
23:33:53 <ReinH> ...
23:33:55 <ReinH> you know what
23:34:00 <ReinH> this is already too ridiculous to even bother
23:34:14 <tac_> It's only ridiculous with your logic ;P
23:34:17 <newsham> it seems to me that you are arguing against constructive math
23:34:20 <ReinH> I'm meant to argue that forall n. f n is somehow able to produce a real number
23:34:21 <ReinH> I don't even
23:34:29 <newsham> in a philosophical way perhaps?
23:34:30 <Guest87869> its a set
23:34:31 <newsham> *shrug*
23:34:39 <ReinH> what does that even mean
23:34:48 <Guest87869> and theres a program to show all the sets
23:34:53 <Guest87869> i mean all the elements
23:35:05 <ReinH> what does it actually mean to say that forall n. f n can construct a real number
23:35:07 <Guest87869> map [1..] (showCReal pi)
23:35:13 <tac_> The existence of uncomputable reals is somewhat like the non-existence of a set of all sets.
23:35:30 <abh> hslogger does not seem to support rolling log files on its own
23:35:32 <ReinH> Guest87869: is that what you think it means?
23:35:32 <tac_> You can certainly define a collection of all sets. It's just not itself a "set" as you have formalized it.
23:35:37 <ReinH> because that one's pretty trivial to do away with
23:35:39 <abh> any idea how i do that
23:35:44 <newsham> reinh: i think it means that you can use such constructs to represent SOME reals and that the construct behaves in every way the same as the reals they represent
23:35:51 <Guest87869> ReinH: yeah i think its talking about a set of approximations
23:35:56 <ReinH> newsham: I don't even understand what that construct is supposed to mean in this context
23:36:00 <ReinH> it's meaningless to me
23:36:10 <tac_> 'dually(?)', you can define all the reals on a turing machine, but not 'all' the reals as ZFC admits.
23:36:19 <newsham> reinh: it means a function from a natural to a finite string of digits
23:36:26 <ReinH> oh does it?
23:36:31 <ReinH> then obviously it can't construct pi
23:36:31 <tac_> But you surely can't come up with an example of a non-computable real without appealing to something a turing machine can't 'make sense of'
23:36:34 <ReinH> or any other trancendental
23:36:37 <ReinH> that was easy
23:36:46 <tac_> (Like appealing to the construction in terms of its digits based on some halting problem)
23:36:58 <newsham> reinh: I think you are confusing the intention.. the intention is not that the finite string of digits is pi
23:37:06 <newsham> the intention is that the function itself represents pi
23:37:21 <ReinH> Ok, a non-terminating function represents pi
23:37:25 <johnw> are you just saying that pi has no operational definition?
23:37:28 <ReinH> I'm glad we agree that pi isn't computable
23:37:28 <tac_> In some sense, all existence is representation, don't you think?
23:37:39 <Guest87869> yeah, any given finite approximation is not pi, but thats not the same as the entire set of possible approximations, which itself is infinite
23:37:41 <tac_> (At least, that's what my type theoretical upbringing has taught me)
23:37:42 <newsham> reinh: i said finite :)
23:37:56 <tac_> Pi is computable :X
23:37:57 <Guest87869> ReinH: heh, that function terminates for all n
23:38:02 <abh> i suppose i'll ask some other time. people are busy with their pies here
23:38:09 <ReinH> Guest87869: and for any n it does not compute pi
23:38:16 <Guest87869> true
23:38:23 <ReinH> then we're done
23:38:40 <newsham> reinh: the function doesnt compute pi.  the function is a representation of pi
23:38:45 <ReinH> what does that even mean
23:38:46 <Guest87869> but the fact that the program gets arbitrarily close to pi is the whole point of computable
23:38:53 <ReinH> Guest87869: no, it isn't.
23:38:53 <newsham> you can use it to compute representations of functions of pi
23:38:58 <ReinH> I can't even
23:39:00 <tac_> ReinH: newsham is right here. You can represent pi with a function.
23:39:04 <newsham> those functions are also represented by functions
23:39:16 <tac_> rather, any 'computable' real
23:39:16 <newsham> http://en.wikipedia.org/wiki/Construction_of_the_real_numbers
23:39:22 <ReinH> tac_: ok. That doesn't make pi computable.
23:39:37 <tac_> If you can enumerate the digits, then you have a computable real.
23:40:05 <newsham> I should be very clear -- i'm not a mathemagician, i am just parrotting my limited udnerstanding from reading stuff thats over my head
23:40:06 <kylec01> can someone help me with this error? http://lpaste.net/103649
23:40:14 <ReinH> what makes pi computable is that you can find an algorithm to show the nth digit of pi
23:40:22 <ReinH> forall n. f n ~ pi doesn't make pi computable
23:40:42 <ReinH> I don't even understand what that construction is supposed to mean
23:40:45 <Guest87869> the CAF `pi' is pi
23:40:52 <Guest87869> (in CReal at least)
23:40:56 <tac_> That notation is off, but the idea is more or less right.
23:41:01 <johnw> kylec01: i've not seen that problem before
23:41:11 <ReinH> tac_: I don't even understand what that notation is supposed to mean
23:41:23 <ReinH> I'm not arguing that pi isn't computable. It certainly is.
23:41:24 <grohne> is there an existing datatype isomorphic to data AltList a b = Cons a b (AltList a b) | Nil a | Empty (apart from constructs such as Maybe (a, [(a, b)]))?
23:41:37 <ReinH> I just don't understand how anything I've heard is a proof that pi is computable
23:41:50 <johnw> grohne: forall r. Monoid r => (a -> r) -> r
23:42:02 <johnw> oh, wait, you have an additional parameter on your Cons
23:42:02 <kylec01> http://bellard.org/pi/pi_bin.pdf
23:42:10 <tac_> The idea was that, if you have a function which gives you, for any desired natural number n, a list of n digits of a number, the type of such functions forms a valid representation of the real numbers.
23:42:40 <tac_> These kinds of things are actually done in dependently typed languages, even.
23:42:41 <ReinH> tac_: of the computable numbers.
23:42:44 <tac_> Right
23:42:52 <ReinH> almost no reals are computable
23:42:56 <grohne> johnw: elements should be sequences of the form (), (a), (a,b,a), (a,b,a,b,a), ...
23:43:01 <ReinH> in fact, only a countable subset of the reals are computable
23:43:03 <Guest87869> how do you know that a program actually computes the digits of pi itself, good question ;) im sure theres an interesting answer to this
23:43:05 <ReinH> since they can be godel numbered
23:43:11 <newsham> function: given delta, get back  pi' where  |pi - pi'| < delta
23:43:23 <johnw> grohne: forall r. Monoid r => (a -> b -> r) -> (a -> r) -> r
23:43:36 <tac_> ReinH: Except, you can't define a COMPUTABLE bijection between that type and the naturals.
23:43:47 <johnw> grohne: what do you need the isomorphism for?
23:44:04 <ReinH> tac_: yep
23:44:07 <grohne> johnw: I thought I could use something existing rather than inventing my own
23:44:22 <tac_> ReinH: You end up with two different versions of the same story: Your ambient set theory says that "you're missing some reals"
23:44:31 <tac_> but in your internal logic, you have "nope, we've got all of them"
23:44:37 <tac_> And both are correct, from their point of view.
23:44:50 <tac_> neither sees their story as inconsistent.
23:44:51 <AfC> Is there a way to run e.g. `cabal install --only-dependencies` and have it return a non-zero exit code if, for instance, there IS something to do?
23:44:53 <newsham> tac: cant you get a bijection between computable-reals and naturals?   ie. godel number?
23:45:12 <ReinH> newsham: the computable reals are countable, yes
23:45:26 <Guest87869> tac_: i find your ideas intriguing
23:45:28 <ReinH> since you can godel number the turing machines that produce them
23:45:32 <tac_> newsham: Yes and no.
23:45:56 <tac_> newsham: If you look at programs as their source code, equality is decidable and you can surely enumerate them godel-style
23:46:16 <atondwal> How can I write a function of type ((a->b->c) -> e -> f -> g) -> (a->b->M c) -> e -> f > M g
23:46:19 <atondwal> for some monad M?
23:46:25 <ReinH> tac_: the thing that I object to is "can compute the nth digit" is NOT the same thing as "can enumerate all the digits"
23:46:33 <abh> AfC: run it, catch output, parse and return a non zero exit code
23:46:34 <newsham> equality of src code is not numeric equality
23:46:42 <ReinH> tac_: the latter rules out all the irrationals and many rations too!
23:46:47 <Guest87869> ReinH: well that doesnt make too much sense
23:46:48 <tac_> newsham: but when you look at their meanings, and quotient them by functional extensionality, you can't any more "internally"
23:47:15 <Guest87869> ReinH: if they are not the same, then what is the maximum n which i am allowed to compute?
23:47:27 <ReinH> ...
23:47:27 <atondwal> I'm trying to use JuicyPixels generateImage with a funtion that returns in (ErrorT IO)
23:47:36 <newsham> reinh: sure.. there is not even such thing as "all the digits"
23:47:36 <tac_> ReinH: Each digit is only finitely far away from the 0th digit. You can always enumerate as many as you want.... but you're right in that you can't get a literal explicit list of all of them.
23:47:42 <tac_> And so the reals won't have a "computable equality"
23:48:10 <ReinH> I really don't know how to answer that question. Sorry.
23:48:28 <Guest87869> all the digits makes sense
23:48:35 <tac_> But the problem here is the problem with any argument looking like this one
23:48:41 <atondwal> Did my messages not go through before I identified?
23:48:41 <tac_> People are using two logics at the same time
23:48:44 <tac_> And they confuse them.
23:48:57 <johnw> grohne: also: AltList a b = Free ((,,) a b) (Maybe a)
23:49:12 <tac_> What does "countable" mean? You have two logics, and each has their own notion of what the word means.
23:49:30 <ReinH> tac_: which logics?
23:49:57 <tac_> Ostensibly, some kind of set theory and some kind of turing machine equivalent thingy
23:50:03 <tac_> Maybe ZF and Haskell.
23:50:16 <tac_> Or ZF and turing machines if you like
23:50:21 <Guest87869> bijection with naturals
23:50:25 <atondwal> seriously does anyone know? I have a project due in 12 hours and this is the only thing keeping me from finishing :(
23:50:37 <ReinH> tac_: there are a few equivalent definitions of computable numbers
23:51:00 <ReinH> using Turing machines, lambda calculus, μ-recursive functions
23:51:10 <Guest87869> tac_: something based purely on turing machines, wouldnt this rely on church-turing thesis
23:51:23 <Guest87869> seems weaker
23:51:42 <Guest87869> if different, definitely weaker ;)
23:51:47 <tac_> The church-turing thesis is also a philosophical assertion, rather than a theorem :)
23:51:51 <Guest87869> right
23:51:54 <atondwal> Is it just straight up not possible to pass sideeffectful HOFs?
23:52:02 <atondwal> (in general)
23:52:07 <ReinH> well, you can pick Turing or Church and come up with a reasonable definition
23:52:10 <Guest87869> so if it leads to contraditions with sane notions of countable, dispense with it ;)
23:52:13 <ReinH> so it doesn't really matter
23:52:32 <johnw> atondwal: I don't think you can
23:52:41 <mmachenry>  atondwal: No you can have a funtion that take an IO function
23:52:43 <johnw> atondwal: you're essentially asking for a way to turn a -> m b into a -> b
23:52:51 <tac_> But the ambient logic (your set theory) bleeds heavily into your thinking, and you need to be aware of it
23:52:53 <mmachenry> :t mapM_
23:52:54 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
23:53:18 <ReinH> the usual definition is that a real number n is computable if it can be approximated by some computable function f : N -> Z such that (insert formal definition of "approximate")
23:53:23 <grohne> johnw: thanks for your ideas, but this seems all more complex than going with some custom variant of AltList.
23:53:28 <atondwal> machineslearn: I want something more general than that
23:53:30 <tac_> Even the basic premise of the theory of computability: can you define a turing machine that can tell you when another will halt?
23:53:34 <johnw> grohne: I'd say you're right :)
23:53:40 <tac_> How do you even know every turing machine will halt or it won't?
23:54:01 <newsham> ?djinn ((a->b->c) -> e -> f -> g) -> (a->b->M c) -> e -> f -> M g
23:54:01 <lambdabot> Error: Undefined type M
23:54:02 <Guest87869> you cant
23:54:08 <Guest87869> know that for "all"
23:54:08 <atondwal> oops
23:54:12 <newsham> ?djinn ((a->b->c) -> e -> f -> g) -> (a->b->c) -> e -> f -> g
23:54:13 <lambdabot> f a = a
23:54:13 <tac_> Not without LEM at least!
23:54:13 <johnw> grohne: you almost want a list of tuples, except that it can end with half a tuple
23:54:16 <atondwal> that typesignature is backwards
23:54:19 <atondwal> oops
23:54:22 <atondwal> haha
23:54:27 <Guest87869> LEM?
23:54:32 <tac_> Law of Excluded Middle
23:54:35 <Guest87869> haha
23:54:47 <atondwal> ((a->b->M c) -> e -> f -> M g) ->  (a->b->c) -> e -> f -> g
23:55:02 <Guest87869> yeah so halting problem is an even bigger problem than decidability
23:55:18 <atondwal> johnw: oops, meant to say ((a->b->M c) -> e -> f -> M g) ->  (a->b->c) -> e -> f -> g
23:55:29 <atondwal> err no
23:55:38 <atondwal> ((a->b->c) -> e -> f -> g) -> (a->b->M c) -> e -> f -> M g
23:55:43 <atondwal> is what I meant
23:56:08 <Guest87869> does it make sense for any given machine to ask the question, does it halt
23:56:36 <lahwran> a restricted subset of the halting problem is solveable, see also dafny
23:56:51 <johnw> atondwal: the only one you can write is: foo :: Monad m => ((a -> b -> m c) -> e -> f -> g) -> (a -> b -> c) -> e -> f -> m g
23:56:52 <Guest87869> i would like a proof of a particular machine, that there exists no proof either way ;)
23:56:53 <newsham> atondwal: how did you get yourself into this situation?
23:57:16 <newsham> perhaps there's an easier solution by backtracking
23:57:21 <atondwal> johnw: not foo :: Monad m => ((a -> b -> c) -> e -> f -> g) -> (a -> b -> m c) -> e -> f -> m g
23:57:30 <johnw> that doesn't work either
23:57:58 <Cale> Guest87869: does what halt?
23:58:27 <atondwal> newsham: writing an scheme interpreter, want to pass a scheme function to a native haskell library, but the scheme function has side effects
23:58:41 <Guest87869> that machine with some input, or the combination as one thing, or whatever
23:58:46 <Yoctogon> I don't accept LEM, or do I?
23:59:19 <Cale> Guest87869: Sorry, I don't know which machine you're speaking of :)
23:59:48 <newsham> atondwal: you can get a handle on the output of a side-effecting computation in a do-block, and pass it to pure functions
23:59:54 <Guest87869> an example machine, with a concrete description, where the proof shows that no proof exists either way?
