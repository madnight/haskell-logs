00:02:26 <Tene> The feature u-ou is asking for is referencing bash history expansion quick substitution, where ^foo^bar re-runs the last-entered command, but with 'foo' replaced with 'bar'
00:19:58 <michi7x7> < _1 ^~ 9 $ (2,3)
00:20:13 <michi7x7> lambdabot: < _1 ^~ 9 $ (2,3)
00:20:41 <michi7x7> > _1 ^~ 9 $ (2,3)
00:20:43 <lambdabot>  (512,3)
00:21:52 * hackagebot Hoed 0.1.0.1 - Debug anything without recompiling everything!  http://hackage.haskell.org/package/Hoed-0.1.0.1 (faddegon)
00:21:56 <michi7x7> why is this doing 2^9 instead of a lens-set ?
00:22:37 <michi7x7> > _1 %~ const 9 $ (2,3)
00:22:40 <lambdabot>  (9,3)
00:27:21 <supki> michi7x7: the convention is  l op~ x = l %~ (op x)
00:27:46 <supki> there's a couple of exceptions, e.g. .~ or //~
00:28:18 <michi7x7> supki: but (^~) is in the docs as infix set
00:28:32 <supki> then the docs are wrong
00:28:37 <supki> where are you seeing tht?
00:29:45 <michi7x7> supki: oh, Google pointed me to a terribly old version. Sorry :)
00:31:07 <michi7x7> _1 .~ 9 $ (2,3)
00:31:14 <michi7x7> > _1 .~ 9 $ (2,3)
00:31:15 <lambdabot>  (9,3)
00:33:36 <michi7x7> supki: just curious, why //~ instead of just /~ ?
00:39:05 <supki> michi7x7: the state monad version (op=) would clash with the existing (/=) otherwise
00:39:09 <supki> :t (/=)
00:39:10 <lambdabot> Eq a => a -> a -> Bool
00:40:14 <michi7x7> ah, forgot about the not equal ...
01:06:43 <jle`> um
01:06:58 <jle`> so pandoc, the haskell library, can't generate any standalone latex files without a latex template
01:07:14 <jle`> but latex templates are apprently text files in the home directory or something
01:07:23 <jle`> not sure what to do here in the case of a server instance
01:08:27 <jle`> oh it's in the cabal data directory
01:08:39 <jle`> sort of unfortunate, would have liked to have been able to do it purely
01:47:02 * hackagebot javasf 0.1.0 - A utility to print the SourceFile attribute of one or more Java class files.  http://hackage.haskell.org/package/javasf-0.1.0 (TonyMorris)
01:54:15 <Marquis> preflex alpountet++
01:54:22 <Marquis> :preflex alpountet++
01:54:47 <jle`> preflex has left us
01:54:56 <Marquis> i am just too stupid to read
01:57:04 * hackagebot tasty 0.8.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.1 (RomanCheplyaka)
02:21:39 <michi7x7> > runState ((_2 <<.=) =<< use _1) (5, 0)
02:21:41 <lambdabot>  (0,(5,5))
02:22:07 <michi7x7> these operators still feel a little awkward
02:28:10 <supki> > runState (_2 <~ use _1) (5, 0)
02:28:11 <lambdabot>  ((),(5,5))
02:29:19 <Pythonfant> I'm looking for a function that does (Monad m) => (m a, m a) -> m (a, a) so it should pull the monad out of the tuple
02:29:25 <Pythonfant> does something like this exist?
02:31:56 <merijn_> Pythonfant: No, but you can write it just fine
02:32:33 <merijn_> :t \(x, y) -> x >>= \x' -> y >>= \y' -> return (x, y)
02:32:34 <lambdabot> Monad m => (m a, m a1) -> m (m a, m a1)
02:32:39 <merijn_> hmm
02:32:42 <merijn_> oh, duh
02:32:47 <merijn_> :t \(x, y) -> x >>= \x' -> y >>= \y' -> return (x', y')
02:32:49 <lambdabot> Monad m => (m t, m t1) -> m (t, t1)
02:32:53 <Pythonfant> thx
02:33:13 <supki> :t both id
02:33:14 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => r (f b) (f b) -> f (r b b)
02:40:32 <Pythonfant> merijn_: is -> in the lambda functions right associative?
02:41:35 <bergmark> Pythonfant: yes
02:42:01 <Pythonfant> ok then I understood it thx
02:43:26 <phaazon> woah, traversals from lens are so handy
02:43:35 <phaazon> (traverseOf, mapMOf, and so on)
02:43:56 <phaazon> I discovered _Left, it’s so great :)
03:09:51 <adas> the functions isLeft and isRight don't seem to exist in Data.Either even though hayoo says it does..
03:10:00 <adas> am i looking at the wrong documentation?
03:10:17 <bitemyapp> adas: version?
03:10:50 <adas> latest haskell platform. with ghc -v 6.3
03:12:15 <bitemyapp> adas: ...ghc 6.3?
03:12:59 <adas> bitemyapp: so sorry. its 7.6.3
03:13:09 <adas> I forgot to add in teh first number
03:14:31 <adas> so its ghc -v 7.6.3
03:15:29 <phaazon> hey
03:16:24 <solarus> :t uncurry (liftM2 (,))
03:16:25 <lambdabot> Monad m => (m a1, m a2) -> m (a1, a2)
03:17:57 <eizo> > liftM2 (,) [1,2,3] [4,5]
03:17:59 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
03:18:47 <jle`> > both id (Identity 1, Identity 2)
03:18:48 <lambdabot>  Identity {runIdentity = (1,2)}
03:23:34 <bergmark> fixing bugs in stringily typed haskell code :-((
03:42:15 * hackagebot hpc-coveralls 0.4.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.4.0 (killy971)
04:08:09 <Maxdamantus> Hmm .. would Haskell be significantly without (enforced) kinds?
04:08:36 <Maxdamantus> Presumably it would just mean you'd be able to write things like more type classes that can never be instantiated.
04:08:54 <Maxdamantus> class Foo a where bar :: a; baz :: a Int
04:09:30 <Maxdamantus> significantly different*
04:09:35 <vanila> it would be broken :P
04:09:54 <vanila> the kind system is necessary to make sure types are well formed
04:10:21 <vanila> you woldn't be able to do typechecking though
04:10:42 <Maxdamantus> Why wouldn't you be able to do type checking?
04:10:57 <Maxdamantus> Types would still be enforced.
04:11:07 <Maxdamantus> Types themselves would just be less restricted.
04:11:24 <vanila> it's just that types would be nonsensical
04:11:49 <vanila> you could have things like Maybe (->) y
04:12:14 <Ainieco> hello
04:12:18 <Maxdamantus> but you'll never have a value (assuming bottoms don't count) of that type.
04:12:19 <vanila> it's just nonsense terms to the typechecker, so it has no way of knowing if it's right or not
04:12:23 <vanila> hi
04:12:32 <Ainieco> Wreq library throws exceptions, so sad...
04:12:36 <Maxdamantus> So it doesn't introduce any runtime type errors.
04:15:12 <Ainieco> is there http library which will not throw exeptions?
04:15:33 <darthdeus> http://stackoverflow.com/questions/23844312/why-cant-cabal-keep-multiple-versions-of-the-same-package
04:16:38 <Ainieco> or how to catch excpetions?
04:16:56 <Ainieco> meh, it reminds me of programming in java, shame on you BoS...
04:21:19 <Feuerbach> Ainieco: learning about exceptions will be a good step forward
04:22:15 <akamala> darthdeus: cabal supports multiple versions
04:22:26 <darthdeus> akamala: then why do i get the reinstall error?
04:22:39 <Ainieco> Feuerbach: actually it looks like step back, since it's used inapropriately - when response code is 301 it throws excpetion, wtf
04:23:00 <akamala> darthdeus: which error? i just saw your link to so
04:23:33 <darthdeus> akamala: the one when installing a package which says "will be broken by a reinstall"
04:23:48 <Ainieco> exception shouldn't ever escape to top level in well designed application
04:24:33 <Ainieco> StatusCodeException rediculus
04:24:49 <darthdeus> akamala: for example this
04:24:50 <darthdeus> parsec-3.1.5 (reinstall) changes: mtl-2.1.3.1 -> 2.2.0.1
04:24:50 <darthdeus> network-2.5.0.0 (reinstall)
04:24:50 <darthdeus> HTTP-4000.2.15 (reinstall) changes: network-2.5.0.0 added, parsec-3.1.5 added
04:25:24 <darthdeus> and then it says "cabal: The following packages are likely to be broken by the reinstalls" and lists all the packages that'll get borken because i try to install something with incompatible version, no?
04:25:35 <akamala> maybe a -v3 helps?
04:25:53 <pyon> What version of lens should I install? The latest one (4.1.2.1) seems to have no documentation for its modules.
04:26:43 <darthdeus> -v3 doesn't tell me why it is broken
04:28:04 <Feuerbach> Ainieco: I think it's a bug that that exception type isn't exported
04:28:06 <akamala> darthdeus: cabal sandbox is no options?
04:28:31 <Feuerbach> that said, using exceptions like this is a valid API design
04:28:38 <darthdeus> akamala: but why do i even need the sandbox? I understand that it fixes it, but what i dont understand is why i need to compile every project separately
04:28:54 <Feuerbach> you should be able to catch them if you don't want them to propagate
04:29:33 <Ainieco> Feuerbach: but why status code should ever throw anything? if 301 doesn't have body then body should be "Maybe body".
04:30:22 <Ainieco> exception based control flow is a worst nightmare since java, i won't call it "valid API design"
04:30:48 <Feuerbach> Ainieco: right, I don't know what exactly is going on there — this could be just a bug
04:31:18 <Feuerbach> (I'm not too familiar with wreq)
04:31:34 <Feuerbach> my point is that there's nothing wrong with exceptions
04:31:40 <Feuerbach> in general
04:31:53 <Feuerbach> as a way to structure a program or a library interface
04:32:34 <Ainieco> Feuerbach: yeah, they are inevitable in some cases like file handling clean up
04:32:57 <Ainieco> but it should be super internal and never hit end user :(
04:33:12 <Feuerbach> ok, but wreq is not an application
04:33:16 <Feuerbach> it's a library
04:33:24 <Feuerbach> presumably you're the author of the app
04:33:35 <Ainieco> Feuerbach: it doesn'
04:33:40 <Ainieco> t matter app or library
04:33:46 <Ainieco> now i'm a user of library
04:34:09 <Feuerbach> yes, you're a user of a library. so you have to learn the interface of the library you're using
04:34:27 <Feuerbach> and if exceptions are part of that interface, catch them
04:37:37 <fruit_frenzy> Hey, I have a small question. Is it me or hasn't Haskell Platform been updated for quite a bit?
04:38:24 <TheFuzzball> How would you pronounce f' vs f?
04:38:33 <TheFuzzball> F apostrophe?
04:38:35 <Feuerbach> fruit_frenzy: it's them, not you
04:38:35 <fruit_frenzy> f prime
04:38:48 <Taneb> f prime, yeah
04:38:49 <fruit_frenzy> f' = f prime
04:39:06 <Feuerbach> fruit_frenzy: unless you are Mark?
04:39:13 <fruit_frenzy> lol
04:39:16 <Taneb> (I've also heard f dash)
04:39:55 <TheFuzzball> I've seen others, like _f and f+, do they have alternate pronunciations? Am I even remembering the affixes correctly?
04:40:16 <Feuerbach> f+ is two lexems, f and +
04:40:31 <Feuerbach> _f is "underscore f"
04:41:16 <fruit_frenzy> anybody knows the reason why Haskell Platform hasn't been updated for a while?
04:41:54 <Feuerbach> there were a few (mostly related to GHC release cycle)
04:42:05 <Feuerbach> you can look it up in the mailing list archive
04:42:25 <Feuerbach> fruit_frenzy: do you care because you're on Windows?
04:42:57 <fruit_frenzy> yes
04:43:04 <Feuerbach> and you want ghc 7.8?
04:43:12 <fruit_frenzy> yes
04:43:25 <Feuerbach> well, GHC 7.8 came out very recently
04:43:47 <Feuerbach> so even if HP was released a couple of months ago, that wouldn't save you :)
04:44:14 <fruit_frenzy> ok, you have a point
04:47:08 <akamala> darthdeus: from what i know, you get these reinstall isuses if something the package you try to install depends on mtl/2.1.3.1 but parsec wants mtl-2.2.0.1 so two different packages that are going to be installed depend on the same package but different versions of it and you cannot build one thing with multiple versions of a single package
04:47:22 <akamala> someone correct me please if i'm wrong
04:51:04 <darthdeus> hmm that makes sense
04:58:40 <mirpa> Is there list of options that you can use in .cabal file?
05:00:40 <mirpa> got it...
05:28:48 <adas> is there a functino to get a RIght value from and Either type?
05:29:06 <bernalex> adas: what if there isn't a Right?
05:29:34 <sipa> :t (case (Right x) -> x)
05:29:35 <lambdabot> parse error on input ‘->’
05:29:43 <hpc> bernalex: then you error
05:29:49 <sipa> :t (\y -> case y of (Right x) -> x)
05:29:50 <lambdabot> Either t t1 -> t1
05:29:50 <hpc> using Either, of course
05:29:52 <bernalex> hpc: errors are not nice.
05:29:55 <adas> bernalex: so how might a handle the situation?
05:30:00 <vanila> :t either undefined id
05:30:01 <lambdabot> Either a c -> c
05:30:04 <bernalex> adas: case expressions are nice
05:30:20 <hpc> case x of (Right x) -> Left x; (Left _) -> Right (error "not defined") -- :D
05:30:23 <sipa> :t fromEither
05:30:24 <lambdabot> Not in scope: ‘fromEither’
05:30:34 <hpc> (note: don't actually do that)
05:30:59 <adas> i dont think theres a fromEither although there is a fromMaybe
05:31:07 <vanila> :t fromJust
05:31:09 <lambdabot> Maybe a -> a
05:31:11 <hpc> ... that might need to go into acme-php
05:31:26 <adas> bernalex: thansk. ill try them out
05:31:51 <bernalex> adas: typically you want to do what hpc wrote, except something more sane for the Left noe.
05:31:53 <bernalex> *one
05:32:04 <adas> either undefine id , looks fine as well.. but looks  hackish and can fail
05:32:22 <vanila> "can fail"?
05:32:34 <bergmark> adas: write a function `fromRight :: Either a b -> Maybe b'
05:32:39 <hpc> technically, it's fail that can undefined
05:32:51 <bernalex> just like you'd do case x of (Just v) -> handle value; _ -> handle no value.
05:32:55 <vanila> there is no total function Either a b -> b
05:34:06 <bernalex> writing fromRight as per bergmark's suggestion is quite possible, altough rarely useful. if you have an Either value, typically you have it because you want to do either foo or bar, not because you want to do foo or nothing. that's what Maybe is for.
05:35:42 <bergmark> you quite often don't care about the error, e.g. aesons `decode' that just throws away the attoparsec error message
05:37:29 * hackagebot Ketchup 0.1.0 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.1.0 (Hamcha)
05:38:39 <madjestic> > map (+1) [1..10]
05:38:41 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:38:53 <madjestic> > map (+1) [1..]
05:38:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
05:39:19 <madjestic> .
05:39:44 <u-ou> > iterate (+1) 0
05:39:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:49:52 <darthdeus> what should I do when i need to map a function that's String -> String onto a list of ByteString?
05:50:43 <darthdeus> ByteString.Lazy returns only Word8
05:50:51 <luite> darthdeus: you first have to decide what kind of text data is in the ByteString
05:51:14 <darthdeus> it's most likely just file paths, so US-ASCII
05:51:42 <adas> > iterate (+2) 18
05:51:44 <lambdabot>  [18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,...
05:51:50 <luite> oh file paths are rather system dependent, i think they have unspecified encoding on unix, unicode on windows?
05:52:12 <luite> but not sure about the encoding in windows
05:52:28 <adas> > iterate (++"vroom ") ""
05:52:29 <lambdabot>  ["","vroom ","vroom vroom ","vroom vroom vroom ","vroom vroom vroom vroom ",...
05:52:35 <luite> darthdeus: system-filepath tries to deal with them properly
05:53:13 <darthdeus> luite: uhm it's not specifically filepaths, just something like "check some/file/somewhere"
05:54:17 <luite> darthdeus: okay, well, you could use the decoders in Data.Text.Encoding (Data.Text.Encoding.Lazy for lazy), then unpack the text
05:54:44 <darthdeus> ah sweet, thanks :)
05:54:51 <darthdeus> wasn't sure if going through Text was the right thing
05:55:28 <luite> it's most likely better than using the ByteString Char8 modules, unless you're really really really sure that you only get 0-127 codepoints
06:04:30 <teneen> what's the most efficient way to convert an Int to Double?
06:04:47 <teneen> is there anything better than fromIntegral?
06:05:17 <hpc> there may be a ghc primitive for it?
06:05:26 <luite> as long as you compile with optimization, things like fromIntegral usually optimize away nicely
06:05:34 <luite> at least for monomorphic code
06:06:33 <teneen> fromIntegral is just (fromInteger . toInteger) which is inefficient I guess
06:06:50 <luite> only if it actually uses that
06:07:21 <teneen> luite: but that's how it's defined
06:07:43 <luite> teneen: compile something that uses fromIntegral for that task with -O or -O2, use -ddump-stg and check what it does. you might just find the int2Double primop there
06:08:30 <teneen> luite: that would be great really
06:08:58 <hpc> luite: well, you'll definitely find int2Double, but how much wrapping of class dictionaries and such will there be too ;)
06:22:33 <mjburgess> I'm looking at http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types  and came across:  newtype Pair a b=Pair (forall c.(a->b->c)->c)
06:22:53 <mjburgess> which gives,   Pair :: (forall c. (a -> b -> c) -> c) -> Pair a b
06:23:07 <mjburgess> can any one explain how to use Pair?
06:23:40 <vanila> mjburgess, consider first the following:
06:23:55 <vanila> unpair (x,y) f = f x y
06:24:21 <vanila> if you couldn't pattern match on pairs, and you only had "unpair".. you could still write any function on pairs
06:24:21 <vanila> e.g.
06:24:30 <vanila> fst p = unpair p (\x y -> x)
06:24:36 <vanila> snd p = unpair p (\x y -> y)
06:25:00 <vanila> Does that make sense? (before seeing how this relates to the newtype Pair)
06:25:08 <mjburgess> yeah
06:25:38 <vanila> so the idea of this newtype is that instead of having a constructor for pairs at all, you just have some applies the selector function ((\x y -> x) was the selector function in fst)
06:26:26 <vanila> so if you want to implement fst :: Pair a b -> a, you can go  fst (Pair p) = p (\x y -> x)
06:27:13 <vanila> to construct a pair you use makePair x y = Pair (\selector -> selector x y)
06:28:19 <eizo> vanila: the reason we don't define it by a -> b -> Pair a b is that we couldn't destruct the pair?
06:28:44 <vanila> eizo,, what definition do you mean exactly?
06:32:38 <mjburgess> so "containing" an annoymous function in Pair is what enables the heterogeneous type grouping?
06:33:47 <vanila> well let me emphasize something
06:33:53 <vanila> fst p = (unpair p) (\x y -> x)
06:33:58 <vanila> snd p = (unpair p) (\x y -> y)
06:34:30 <vanila> the unpaired version of p can be used to implement any function on pairs
06:34:41 <vanila> :t let unpair (x,y) f = f x y in unpair
06:34:42 <lambdabot> (t1, t2) -> (t1 -> t2 -> t) -> t
06:35:14 <vanila> so this type (t1 -> t2 -> t) -> t "apply a selector function" is all you need to do anything you want with pairs
06:35:42 <mjburgess> ah, i see
06:35:44 <vanila> the trick they are doing is implementing pair itself as "unpaired" values
06:36:16 <vanila> you could also implement data types with multiple constructors, if you just have multiple selector functions
06:36:22 <hpc> it's also worth noting that unpair = curry
06:37:33 <mjburgess> cool, tx
07:22:41 * hackagebot urn 0.1.0.0 - Universal Resource Names  http://hackage.haskell.org/package/urn-0.1.0.0 (SamTruzjan)
07:23:09 <mjburgess> suppose i have some concrete type,   data Person = Person String String      and there's a sense in which it's reasonable to fmap across it.. fmap $ Person "Michael" "John"     what typeclass should Person be in?
07:24:02 <mjburgess> i ask, because Functor takes a type constructor... so instance Functor Person  isnt going to work, right?
07:24:05 <Cale> mjburgess: It doesn't make sense to fmap across that type
07:24:08 <Cale> right
07:24:22 <mjburgess> yeah, so what am i missing here? why doesnt it semantically make sense?
07:24:34 <Cale> Well, what would the type of fmap be?
07:24:48 <mjburgess> Person -> Person  ?
07:24:53 <Cale> Normally, the type of fmap is  (a -> b) -> f a -> f b
07:25:07 <Cale> fmap takes an arbitrary function as its parameter
07:25:14 <vanila> you can define a new function,  stringMap f (Person a b) = Person (f a) (f b)
07:25:19 <mjburgess> well i'd be  (String -> String) -> Person -> Person   here
07:25:37 <Cale> right, so you could just define a separate function like vanila suggests
07:25:45 <Cale> But it doesn't fit into the abstraction
07:25:53 <Cale> (because it's too restricted)
07:25:56 <mjburgess> yeah, i was just wondering what class that function (stringMap) would imply?
07:26:00 <mjburgess> if any
07:26:03 <Cale> Nothing standard
07:27:43 <Algebr> In point free style, am I limited to only taking one argument?
07:27:59 <mjburgess> no arguments, no?
07:28:34 <geekosaur> no *named* arguments. getting more than one argument can be done but is painful
07:28:49 <dwcook> Algebr: a point-free function can have as many nestings of (->) as you want.
07:29:13 <geekosaur> @pl \x y -> y + 6 * x
07:29:13 <lambdabot> (+) . (6 *)
07:29:20 <geekosaur> but
07:29:26 <geekosaur> @pl \x y -> x + 6 * y
07:29:26 <lambdabot> (. (6 *)) . (+)
07:29:42 <dwcook> That second one I'd definitely avoid.
07:29:44 <geekosaur> much fancier than that and it turns into a flipstorm
07:29:57 <vanila> haha a flipstorm
07:30:16 <dwcook> And just wait till you want to *reuse* a parameter.
07:30:23 <geekosaur> yep
07:30:39 <dwcook> @pl \x y -> x + x
07:30:39 <lambdabot> const . join (+)
07:30:52 <vanila> @pl \x -> f x x x
07:30:53 <lambdabot> join (join f)
07:31:14 <xcv_> Is it possible to convince GHC that ReaderT r (ReaderT r' m) a  is an instance of MonadReader r and MonadReader r'?
07:31:16 <dwcook> Woops, didn't mean to include the y. Though it still gets across the point
07:31:54 <dwcook> xcv_: MonadReader is constrained by a functional dependency that forbids that.
07:32:16 <xcv_> oops
07:32:21 <xcv_> dwcook: any workaround?
07:32:31 <dwcook> You could write a newtype and define your own instance that gives you (r, r')
07:32:50 <dwcook> Or simply use one ReaderT with (r, r')
07:33:01 <xcv_> I'm using readers from different modules and combining them in different orders
07:33:47 <dwcook> That might eliminate the second thing I mentioned, but not the first.
07:34:06 <xcv_> What if I put another transformer in the middle?
07:34:11 <dwcook> Wouldn't matter.
07:34:55 <dwcook> The problem is that in general you can only access the shallowest reader without doing anything special.
07:35:21 <xcv_> I see. I'll try that out right now and come back if I have difficulties
07:35:40 <geekosaur> xcv_: practically, it can't determine which one to use solely from the type *and* do type inference, so if it didn't have the fundep then you would have to annotate every use of the MonadReader with a type saying which one to access
07:35:53 <geekosaur> at ewhich point there's no reason to bother trying to have both
07:37:01 <xcv_> geekosaur: It seems quite reasonable to infer the type in all my uses though, I'm just using specialized functions on the reader type
07:38:18 <geekosaur> "seems"
07:38:34 <xcv_> oh, okay
07:39:03 <xcv_> dwcook: How would that newtype work so that I can add and remove one reader at any time and reorder them in any order? I would need to write derived instances for every monad transformer ever too, right?
07:39:47 <geekosaur> I'd have to hand you off to someone who knopws the details better, but (a) even the easy case can turn out to be hard, because it's only easy if you approach it from a different direction than ghc (or in general type inference algorithms) do; (b) even when it *is* easy in some cases, it cant tell the easy cases from the impossible ones so it can't special case the easy ones
07:39:50 <bakibour> Greetings
07:40:31 <hexagoxel> xcv_: in my current project, i have a new transformer type that basically encapsulated a "stack" of ReaderT's or StateT's
07:40:49 <xcv_> dwcook: I think I'm going to newtype one of them (the other one is used locally in just one module). I just hate having a bunch of repeated instances from the mtl
07:41:09 <hexagoxel> xcv_: but i have not yet taken the time to publish it..
07:41:10 <xcv_> geekosaur: Some day I'd like to learn more about GHC, it sounds really interesting
07:41:18 <bakibour> Im using simpleHTTP and getResponseBody to retrieve a webpage that i happen to parse using Regex.Posix. I dumped the file and saw that newlines are actually \n's. How do i convert that file into a properly excaped string?
07:41:36 <xcv_> hexagoxel: That sounds awesome. What are you doing to achieve that?
07:41:50 <hexagoxel> it does not require lifting to get an arbitrary type from the reader
07:42:53 <xcv_> hexagoxel: How? I'm really interested in this
07:43:18 <hexagoxel> xcv_: basic idea is a heterogenous list as the "state"
07:44:20 <xcv_> hexagoxel: How do you get a particular one out of the heterogenous lies (assuming existental quantificaiton)? Generics?
07:44:26 <xcv_> list*
07:46:38 <hexagoxel> xcv_: i am using type families and GADTs, plus a type class to do the extraction
07:47:01 <xcv_> Oh I see
07:47:24 <xcv_> Well, for now it seems simpler for my use case to simply newtype one of my ReaderT's
07:47:53 <xcv_> Oh, wait. It's not going to work
07:48:44 <xcv_> I'd have two different instances of MonadReader for my type too...
07:49:41 <hexagoxel> you'd need a new type class as well, correct
07:50:23 <dwcook> xcv_: what I was thinking of was manually defining a MonadReader instance that unwraps the stack enough to use the innermost instance and construct a tuple of both reader states
07:50:32 <dwcook> It's not exactly pretty and probably not that composable though
07:50:57 <xcv_> That's the problem. I need to use both of them individually and separately
07:51:12 <xcv_> Goodbye MonadReader, welcome MonadScope!
07:51:23 <Tjr> Dear experts, what's your favorite tutorial for somebody with a strong maths background and experience in other programming languages (e.g. Mathematica)?
07:52:17 <xcv_> I'll simply write my own specialized with different functions and classes (somewhat equivalent to MonadReader)
07:53:00 <dwcook> Tjr: to learn Haskell? I'm not sure a math background is terribly relevant for that
07:53:11 <dwcook> Tjr: Learn You A Haskell is often suggested in general
07:53:14 <Tjr> dwcook: yes, to learn haskell.
07:53:30 <dwcook> Though some complain that it's a little bit dated
07:53:43 * Tjr googles.
07:56:12 <Tjr> dwcook: thanks. From chapter 11 on, the concepts covered are new to me.
07:57:47 <dwcook> Tjr: If you're not familiar with Haskell in particular you might benefit from skimming the others as well
07:58:04 <Tjr> yes, certainly.
07:58:20 <onielfa> Hello, I need to write a really simple http server (GET/POST requests only). I don't need to serve html or controlling sessions, just respond to http requests. What library should I use?
07:58:28 <Tjr> Right now I'm just looking for good resources.
07:59:26 <dwcook> There are lots of good disconnected sources if you want to learn specific things about the language. Here's one on IO for example if that interests you http://www.vex.net/~trebla/haskell/IO.xhtml
07:59:32 <takemitsu> onielfa: scotty is pretty simple to use.
07:59:57 <onielfa> takemitsu: thanks, I am going to take a look
08:02:46 * hackagebot HUnit-Plus 0.3.2 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.2 (emc2)
08:04:44 <begriffs> How do I combine two Eithers? I have two Either values x and y and I would like to get x's right or y's right, or a concatenation of their left values if they are both left.
08:05:54 <dwcook> begriffs: what's the type of the function you're describing?
08:06:38 <begriffs> Hmm, I guess Either a b -> Either a b -> Either [a] b
08:07:35 <ion> How about Monoid a => Either a b -> Either a b -> Either a b?
08:08:23 <Tjr> dwcook: thanks, it looks interesting.
08:08:29 <begriffs> ion: sure even better
08:09:44 <ion> begriffs: Write a function with the appropriate pattern matches.
08:10:08 <dwcook> \x y -> case x of { Right x' -> Right x' ; Left x' -> case y of { Right y' -> Right y' ; Left y' -> Left (x' `mappend` y') } } -- Feel free to spread out and remove braces and semicolons
08:10:14 <dwcook> Something like that
08:10:45 <begriffs> K I'll give it a try. Thought there might be some basic thing in the standard library for this pattern.
08:11:12 <dwcook> There's the either function too
08:11:21 <dwcook> It's equivalent to pattern matching on both cases of Either
08:11:25 <dwcook> @type either
08:11:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
08:12:15 <dwcook> You can probably even use the Alternative instance for Either here
08:12:36 <dwcook> That would probably make it cleaner
08:13:09 <dwcook> Oh, it doesn't have one? That's odd
08:13:42 <dwcook> Oh of course
08:13:46 <dwcook> You can't implement empty
08:24:25 <jle`> empty might make sense if you use mempty
08:24:42 <jle`> it violates the MonadPlus law though
08:24:47 <jle`> but that isn't particularly relevant here
08:28:05 <dwcook> Wouldn't you have to make up a Left value to implement empty?
08:28:48 <dwcook> empty = Left undefined
08:28:54 <jle`> if you had Monoid e => Alternative ...
08:29:08 <dwcook> Ah, I see.
08:29:15 <jle`> but that's based on a different Applicative instance of Either e in general
08:29:18 <jle`> i guess
08:30:08 <jle`> sounds like that Validation instance
08:30:10 <jle`> http://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html
08:42:14 <halvorg> Hey, with a Makefile at ./Makefile and with code in src/Main.hs, what command do I pass to ghc to "change directory" to src/ before compiling
08:43:00 <slack1256> You could that inside the Makefile, let me recall how to do that
08:43:46 <geekosaur> cd foo; ghc ...
08:43:51 <geekosaur> but it has to be on one line
08:43:57 <halvorg> then cd .. after?
08:43:58 <slack1256> compile:
08:43:59 <slack1256> 	cd src; \
08:44:00 <slack1256> 		ghc --make -outputdir ../build -o ../build/rss2torrent ./Main.hs
08:44:31 <geekosaur> halvorg, each line is its own command with its own environment, so no, it'll reset after. (on unix at least. cd on Windows is weird)
08:44:56 <slack1256> You have to put a \ after the 'cd src;' so that is in the same environment
08:45:14 <geekosaur> yeh, that keeps it on the same logical line even though it's a different physical line
08:45:53 <halvorg> That's great
08:45:55 <halvorg> thanks guys
08:46:02 <slack1256> http://lpaste.net/8407249712842801152
08:46:09 <slack1256> is an example I did
08:55:26 <hasky> hey guys!! big problem with eclipse FP
08:55:32 <hasky> could you help?
08:55:33 <benzrf> hasky: why are you using eclipse
08:55:45 <hasky> shouldn't I?
08:55:53 <hasky> what do you suggest?
08:56:01 <hasky> I am  a newbie...
08:56:06 <benzrf> i just use vim with the extension for ghc-mod
08:56:11 <benzrf> but  i guess you could use eclipse
08:56:17 <benzrf> it always struck me as unwieldy
08:56:27 <benzrf> i only used it because java is a nightmare otherwise
08:56:36 <hasky> Ok. just 2 things:
08:56:38 <benzrf> but having a REPL solves a lot of those problems
08:56:45 <hasky> autocompletion and rename refactor
08:56:52 <benzrf> hmm, true =p
08:56:59 <hasky> can i have those with vim?
08:57:07 <armed> Sublime Text with SublimeHaskell plugin is good for non vim/emacs users
08:57:18 <benzrf> probably, altho it wasnt designed to be an ide
08:57:25 <benzrf> unix-as-ide mastur race \o/
08:57:51 <hasky> i read it is tough for newcomers
08:58:06 <hasky> seems that who needs it cannot write it, and vice versa...
08:59:21 <hasky> any other suggestion?
08:59:31 <benzrf> hasky: what is tough for newcomers
08:59:34 <yac> https://gist.github.com/yaccz/2f6944b76d0ab6e01902 what's the problem there?
08:59:52 <hasky> well, to try things out
08:59:58 <hasky> with a new language
09:00:25 <yac> configure --user fixed it
09:00:35 <armed> hasky: try Sumlime Text, it's more like general text editor
09:00:47 <hasky> ok thanks
09:01:14 <benzrf> hasky: don't listen to the evil ones!!!
09:01:20 <benzrf> hasky: vim is the 1 tru editor
09:01:28 <benzrf> ST is proprietary for heavens' sake
09:01:49 <hasky> ok ok , just teach me autocompletion and Co...
09:02:10 <benzrf> hasky: vim has built in purely-textual autocompletion
09:02:13 <benzrf> which is usually enough for me
09:02:17 <benzrf> but it is not very smart, of course
09:02:36 <benzrf> as for by-name refactoring, that's a trickier one
09:02:38 <hasky> ok i'll see both!!
09:02:40 <benzrf> vim knows text, not code
09:02:47 <benzrf> there is probably a plugin for that
09:02:53 <benzrf> but at that point, why not use emacs?
09:02:54 <benzrf> :_)
09:02:58 <benzrf> emacs is also pretty cool
09:03:02 <benzrf> i just dont use it
09:29:08 <yac> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Add_some_automated_testing:_QuickCheck
09:29:17 <yac> how does QuickCheck knows where to look for haqify function?
09:31:12 <roconnor> yac: main says to mapM_ tests
09:31:30 <roconnor> yac: tests contains "test prop_haq"
09:31:35 <kttm> hello, why is getLine >>= (read :: String -> Int) not valid?
09:31:41 <roconnor> yac: prop_haq has the definition of haqify
09:33:13 <yac> roconnor: oh, so in real world I need to normaly import the function from my package?
09:33:18 <roconnor> kttm: read doesn't return an IO value.  You want to use fmap instead of bind in this case.
09:33:28 <ski> kttm : the right argument of `kttm' must have type `A -> M B' for some types `A',`B',`M', `M' being a monad
09:33:54 <ski> in your case, the monad must be `IO', since the left argument `getLine' has type `IO String' (so `A' is here `String' as well)
09:34:13 <roconnor> yac: you need to references your functions you want to test in the property (prop_) functions you define.
09:34:15 <kttm> ah i see :t (>>=)
09:34:16 <ski> kttm : `getLine >>= (return . read)' would be ok
09:34:55 <ski> kttm : or `return . read =<<', which perhaps reads nicer. or `liftM read getLine', or with `fmap' instead of `liftM'
09:35:44 <roconnor> or (read <$> getLine)
09:35:46 <kttm> where should the type indication :: goes within an expression such as getLine >>= (return . read) ?
09:36:13 <ski> kttm : however, you migt want to prefer `readLn' instead, since it will raise any parse error as an `IO' exception, instead of giving the error when you access the resulting string
09:36:17 <ski> @type readLn
09:36:18 <lambdabot> Read a => IO a
09:37:03 <ski> kttm : you could do `(return . read :: String -> IO Int)', or `return . (read :: String -> Int)' -- doesn't matter
09:37:22 <bernalex> anyone happen to know if ghc ios stuff transcompiles to objective-c or not?
09:38:26 <benzrf> @src readLn
09:38:26 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
09:38:33 <ski> kttm : or, if the context forces the monadic result to be of type `Int', then you don't need a type ascription at all
09:38:34 <Cale> bernalex: Pretty sure it has nothing to do with Objective C
09:38:34 <benzrf> @src readIO
09:38:34 <lambdabot> Source not found.
09:38:39 <benzrf> @src read
09:38:39 <lambdabot> read s = either error id (readEither s)
09:38:43 <Cale> bernalex: It's just generating ARM code
09:38:54 <bernalex> Cale: ah OK so no transcompilation. thanks.
09:38:54 <benzrf> @src readEither
09:38:54 <lambdabot> Source not found. Whoa.
09:38:59 <benzrf> wweh=
09:39:02 <benzrf> @src Intt readEither
09:39:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:39:02 <ski> @inded readEither
09:39:03 <lambdabot> bzzt
09:39:04 <benzrf> @src Int readEither
09:39:05 <lambdabot> Source not found. Take a stress pill and think things over.
09:39:08 <benzrf> @inded
09:39:08 <lambdabot> bzzt
09:39:12 <benzrf> yo what
09:39:12 <ski> @index readEither
09:39:12 <lambdabot> bzzt
09:39:18 <benzrf> @inde
09:39:18 <lambdabot> bzzt
09:39:19 <ski> @hoogle readEither
09:39:21 <lambdabot> No results found
09:39:22 <ski> @help index
09:39:23 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
09:39:24 <benzrf> @ksdfsdf
09:39:24 <lambdabot> Unknown command, try @list
09:39:32 <Cale> @index sort
09:39:33 <lambdabot> Data.List
09:39:38 <benzrf> @index sorts
09:39:38 <lambdabot> bzzt
09:39:40 <benzrf> lame
09:39:44 <geekosaur> but @index uses a small database, like @src does, and is missing a lot of stuff
09:39:49 <ski> yes
09:44:40 <xxx-man> Cale: hi
09:44:53 <Cale> hello
09:48:27 * hackagebot HUnit-Plus 0.3.2 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.2 (emc2)
09:48:27 * hackagebot ruff 0.3.2.1 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.3.2.1 (ClaudeHeilandAllen)
10:03:22 * hackagebot hath 0.2.1 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.2.1 (MichaelOrlitzky)
10:05:29 <xxx-man> Cale: hi, I am back now
10:05:43 <xxx-man> are you still there?
10:05:48 <Cale> I'm not sure I need to be made aware of that? :)
10:16:13 <yac> what is the proper way to turn "/tmp" to "/tmp/" ?
10:16:50 <yac> I get "/tmp" from getTemporaryDirectory and then passing it into mkstemp but that needs to be ended with the trailing slash
10:18:36 <quchen> yac: There's System.FilePath.addTrailingPathSeparator, that sounds like what you want.
10:19:02 <Saizan_> try </> "" from System.FilePath
10:19:15 <darthdeus> guys can someone explain to me what is the "Paths_ghc_mod" import doing there? https://github.com/kazu-yamamoto/ghc-mod/blob/master/src/GHCMod.hs#L13 i dont see any module with that name defined in the repo
10:19:47 <enthropy> darthdeus: it gets generated by cabal. If you cabal build, you can find a dist/build/autogen/Paths_ghc_mod.hs
10:20:16 <darthdeus> enthropy: does that happen for every "library" target?
10:21:17 <enthropy> not sure. I thought you could only have one library per .cabal file
10:22:32 <monochrom> yes, one library only.
10:26:02 <Smilex> #join #sdl
10:26:15 <Smilex> whoops, sorry
10:26:28 <darthdeus> but i dont need to specify anything to have it generated?
10:26:36 <darthdeus> i mean in other cabal projects
10:28:27 * hackagebot xml-html-conduit-lens 0.3.1.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.1.0 (MatveyAksenov)
10:28:28 <enthropy> you might have to list it in other-modules: or exposed-modules:
10:29:06 <enthropy> darthdeus: but no, you don't have to do anything special to make cabal generate that module
10:33:08 <yac> quchen: cool, thanks.
10:33:44 <darthdeus> awesome
10:36:23 <darthdeus> is it possible that the order of import matters in some case?
10:36:29 <darthdeus> i'm getting a weird linker error and not really sure why
10:36:56 <carter> bernalex: it just usess lellvm
10:37:16 <johnw> le llvm, mais oui
10:37:49 <yac> I'm getting git-yrp: <<loop>>
10:37:52 <yac> how do I debug that?
10:38:05 <johnw> you probably have let x = ... x ... somewhere
10:39:09 <yac> can I just run some command and get the function name that is looping?
10:39:17 <johnw> no
10:39:27 <johnw> it may not be a function that's looping
10:39:48 <johnw> i see what you mean
10:39:55 <johnw> you could turn on profiling
10:39:59 <johnw> and see where it's spending all the time
10:40:05 <johnw> oh, no, <<loop>> exits right away, n/m
10:40:18 <carter> i use do x <- return $ blah
10:40:19 <carter> to avoid that
10:41:22 <johnw> i use version control to review what I wrote recently
10:41:51 <carter> you're also really orgnized :)
10:42:26 <yac> johnw: I'm just learning so I'm lax with proper vcsing
10:42:39 <Cale> Well, turning on profiling can help anyway
10:42:49 <Cale> because you can then run the program with +RTS -xc
10:42:59 <Cale> and get a cost-centre trace for where the exception occurred
10:43:03 <yac> I believe it has something to do with SIO.hClose tmph which I just added but who knows
10:43:06 <Cale> which is occasionally useful and occasionally not
10:43:11 <xxx-man> Cale: :(
10:43:43 <freeman42> anyone knows of any Haskell meetups/events in Dublin?
10:51:31 <monochrom> @let x::Int; x = x + 1 in x+1
10:51:31 <lambdabot>  Parse failed: Parse error: in
10:51:36 <monochrom> > let x::Int; x = x + 1 in x+1
10:51:40 <lambdabot>  mueval-core: Time limit exceeded
11:01:34 <pavonia> Are there any tools that help creating Storable instances from C types? I feel like writing a lot of boilerplate
11:03:30 * hackagebot linux-mount 0.2.0.0 - Mount and unmount filesystems  http://hackage.haskell.org/package/linux-mount-0.2.0.0 (NicolaSquartini)
11:08:57 <yac> is there some other way to move file than System.Directory.renameFile ?
11:09:02 <yac> as this one doesn't work across fs
11:10:09 <vova> hi. I have a few questions about lists. For example I have list [1..10]. I know how to get the one element (!!). But how to get multiple elements?
11:10:30 <pavonia> :t take
11:10:31 <lambdabot> Int -> [a] -> [a]
11:10:35 <pavonia> :t drop
11:10:36 <lambdabot> Int -> [a] -> [a]
11:11:04 <vova> How to get for example the elements 4 and 10?
11:11:27 <Twey> vova: You don't want to do that
11:11:30 <ion> You don’t want to use lists for that.
11:11:58 <Twey> vova: You can make a list [xs !! 4, xs !! 10] of course.  But Haskell lists aren't used the same way as arrays in other languages
11:12:03 <monochrom> I don't understand the question. what is the type of "4 and 10"?
11:12:42 <Twey> vova: They're more like a sort of control structure.  If you're not iterating them in order, you probably ought to be using a different data structure, like a Map or an actual Array
11:14:02 <ReinH> probably Vector or Array for dense structures, IntMap for sparse.
11:14:08 <Twey> Right
11:17:22 <ski> @type MkContI (\k -> [k 4,k 10])  -- monochrom ?
11:17:24 <lambdabot> Num a => ContI [t] t a
11:17:40 <johnw> > zipWith (!!) [4,10] (repeat [1,2,3,4,5])
11:17:41 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
11:17:42 <lambdabot>              with actual type ‘[t0]’
11:17:45 <johnw> > zipWith (!!) (repeat [1,2,3,4,5]) [4,10]
11:17:46 <lambdabot>  [5,*Exception: Prelude.(!!): index too large
11:17:55 <johnw> > zipWith (!!) (repeat [1,2,3,4,5]) [2,4]
11:17:56 <lambdabot>  [3,5]
11:18:04 <vova> thank you very much for the answers.
11:18:39 <greg_> I stumbled on a blog entry whose theme was: "getting beyond beginner is hard because there are few authoritative tutorials about key subjects, here is my list".  I didn't bookmark the entry.  Can anyone supply a link?
11:19:28 <m09> greg_: http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html
11:19:57 <monochrom> I have never seen that blog. (I never read blogs anyway.) but I have authoritative tutorials. http://www.vex.net/~trebla/haskell/
11:20:40 <greg_> haskellforall -- that was it.  many thanks.
11:20:53 <enthropy> greg_: I think for "advanced" stuff you can just read the manual (or the associated papers if there are some)?
11:27:15 <hunt> where can i find a nice explanation of what lenses are
11:28:26 <quchen> monochrom: I wonder whether someone can confirm the authoritativity of that source.
11:28:51 <johnw> hunt: http://ftp.newartisans.com/pub/Lenses.mp4
11:28:53 <monochrom> my http://www.vex.net/~trebla/humour/lmcify.html will help you! :)
11:29:40 <quchen> :-)
11:30:14 <johnw> I wonder why there is no Control.Burrito module yet...
11:30:43 <monochrom> forget burrito. currito is the new trend.
11:31:24 <monochrom> one day, I passed by an Indian restaurant. it was promoting its new invention: currito = curry burrito. I was enlightend at once. these are Applicatives!
11:32:21 <croyd> hunt: http://www.scs.stanford.edu/14sp-cs240h/slides/lenses.html
11:35:58 <johnw> :)
11:36:16 <benzrf> monochrom: top lel
11:38:41 <darthdeus> guys is there something to help with linker errors? i'm pretty noob at this, so not sure how to read it
11:38:46 <darthdeus> Undefined symbols for architecture x86_64:  "_ghczmmodzm4zi1zi0_Pathszughczumod_version1_closure", referenced from:      _r1uv2_info in libHSghc-mod-4.1.0.a(Evaluator.o)
11:39:54 <darthdeus> like for example, how can i figure out what the thing that's missing is?
11:41:29 <int-e> it helps to know that zm = -, zi = ., zu = _ and zz = z.
11:42:44 <darthdeus> that does help :) thanks
11:45:44 <Jefffrey> Hello
11:45:59 <vanila> hi
11:46:24 <meiji11> I'm playing around with the singletons library and am having some trouble converting a function I've written to use an implicit singleton argument.
11:46:35 <vanila> what's a singleton?
11:47:09 <meiji11> singletons are a way of converting terms of a type to a family of terms.
11:47:12 <meiji11> er, family of types.
11:47:32 <vanila> ohh
11:47:33 <meiji11> such that the family of types is isomorphic to the values of the original type.
11:48:06 <Jefffrey> What do you guys think of the choice of linked lists as "default" container?
11:48:12 <Rembane> Does it just share the name with the Design Pattern singleton or do they have something more in common?
11:48:35 <meiji11> Rembane, just the name.
11:48:41 <vanila> I don't know what you mean Jefffrey, are you designing a language
11:48:47 <Rembane> meiji11: Interesting.
11:48:57 <benzrf> Jefffrey: they work well for FP
11:49:08 <benzrf> as far as ive seen
11:49:13 <Jefffrey> vanila: Nope. I'm questioning Haskell's choice.
11:49:30 <int-e> darthdeus: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames has a full list.
11:49:31 <benzrf> O(n) ops could be worse :l
11:49:34 <vanila> i dont really think this is a choice of haskell
11:49:37 <meiji11> they enable a style of dependently typed programming in haskell.
11:49:49 <meiji11> anyway, this implicit argument is being passed to a type family..
11:50:00 <johnw> Jefffrey: a lot of time the linked list you think you see in code doesn't even exist at runtime
11:50:00 <darthdeus> int-e: is there something that can decode this automatically?
11:50:01 <c_wraith> Jefffrey: linked lists are a great encoding of loops for a lazy language.  however, I would not have gone with type String = [Char]
11:50:09 <Jefffrey> benzrf: They are inherently one of the worst containers that exists (yes, even for inserting in the middle and at the beginning). :/
11:50:10 <meiji11> erm, type function. and it seems to be messing things up, somehow.
11:50:25 <benzrf> Jefffrey: cool 'pinions bro
11:50:28 <benzrf> :-)
11:50:28 <vanila> lists are great
11:50:32 <c_wraith> Jefffrey: you're not really thinking of the consequences of laziness, are you?
11:50:49 <int-e> darthdeus: there used to be a bot 'preflex' here that could do it, but it seems to be gone
11:51:10 <Jefffrey> c_wraith: probably not. What am I missing?
11:51:37 <johnw> "<johnw> Jefffrey: a lot of time the linked list you think you see in code doesn't even exist at runtime"
11:51:39 <Jefffrey> johnw: I don't see how that's relevant. The same would apply to any container.
11:51:53 <meiji11> the code is here: http://lpaste.net/104551
11:51:54 <c_wraith> Jefffrey: that in many cases, the list element is created at the same time it's consumed, and the whole thing is optimized out
11:52:08 <vanila> Jefffrey, in no way are lists 'default' in haskell or anything, there is special syntax for them but the language would not be different in any important way if it had no lists at all. you'd just define them when you wanted to use them
11:52:43 <c_wraith> Jefffrey: lists are often just an encoding of a loop in a lazy language.  They're not really used as "data structures" by any traditional measure.
11:53:19 <Jefffrey> vanila: The `String` type (one of the most used types) is a list of char. I'd say they are the default of the language. The fact that they have a "special syntax" enforces my point.
11:53:39 <darthdeus> int-e: though even knowing that the symbol is "4.1.0_Paths_ghc_mod_version1_closure" doesn't help me :\
11:53:59 <Jefffrey> c_wraith: I see.
11:54:01 <darthdeus> i mean there is the auto-generated Paths_ghc_mod module, but that has nothing like that in there
11:54:03 <vanila> no
11:55:34 <int-e> darthdeus: the _closure is added by ghc. I'm not sure about the 1, but the function it refers to is probably just 'version'.
11:56:20 <Jefffrey> c_wraith: Do you think there's any chance for `String` to change to some other container in the near future?
11:56:29 <darthdeus> int-e: so the whole message "_ghczmmodzm4zi1zi0_Pathszughczumod_version1_closure", referenced from: _r1uv2_info in libHSghc-mod-4.1.0.a(Evaluator.o)" is basically saying that i'm using Path_ghc_mod.version inside Evaluator.hs, and that it's not available when it's being linked?
11:56:45 <c_wraith> Jefffrey: No chance of String ever changing.  However, you're free to use the OverloadedStrings extension to create Text literals
11:57:02 <johnw> Jefffrey: I would love it to be Text, but I doubt it will ever change; you should see how much work it's been to change even wronger things at that level of the language
11:57:12 <darthdeus> (there are two executable targets linking against the same lib, and one of them works, and one throws this linker error)
11:57:16 <johnw> that said, many modern libraries have moved away from String
11:57:23 <johnw> and using OverloadedStrings has become more common
11:57:24 <int-e> darthdeus: yes, that's how I would read it. and it's odd. does libHSghc-mod-4.1.0.a contain the Paths.o file?
11:57:33 <int-e> darthdeus: err, Paths_ghc_mod.o, of course
11:57:54 <darthdeus> int-e: that seems to be auto-generated in dist/build/autogen
11:58:04 <Jefffrey> johnw: What "wronger things at that level of the language" are you talking about?
11:58:16 <johnw> Applicative being a superclass of Monad, for one
11:58:35 <c_wraith> you mean *not* being a superclass.
11:58:46 <johnw> yes, I mean that it wasn't
11:59:09 <c_wraith> Actually, the AMP fix seems to be going pretty cleanly overall.  It's just very slow.
11:59:15 <int-e> darthdeus: Oh wait. ghc-mod does not list Paths_ghc_mod under Other-Modules: in the library section. That would explain things.
11:59:18 <johnw> yep
11:59:27 <ReinH> One of the advantages of Haskell is that the String type is not treated specially and you are free to implement your own replacements.
11:59:29 <c_wraith> I think removing Eq and Show as superclasses of Num was a lot more painful.
11:59:38 <meiji11> I think because of the lack of injectivity of type families. also seems to bite me.
11:59:38 <darthdeus> int-e: this is my modified .cabal file https://github.com/darthdeus/ghc-mod/blob/server/ghc-mod.cabal#L114-L137
11:59:43 <c_wraith> Just because it was a surprise for most people.
11:59:45 <johnw> in the real world you just use pack/unpack more than you'd like to
11:59:52 <darthdeus> int-e: ghc-modi builds, ghc-mod doesn't
11:59:58 <c_wraith> But it's another thing that absolutely was an improvement in the language
12:00:26 <darthdeus> int-e: why does it need to be listed in there?
12:00:35 <darthdeus> hmm though aparently it fixes the linker error
12:00:47 <enthropy> Rembane, meiji11: it looks like they picked the name singletons because one type has one value only, which makes it very similar to having 1 instance per class in the design pattern in that respect
12:00:59 <int-e> darthdeus: because otherwise it doesn't get added to the library's [4~.a file.
12:01:11 <Jefffrey> c_wraith: What do you think about all the duplicated functions? (things like map vs mapM)
12:01:32 <c_wraith> Jefffrey: those aren't the same.  Maybe you meant map vs fmap
12:01:36 <Rembane> enthropy: That is a very good reason. Picking the same name is confusing though.
12:01:43 <int-e> darthdeus: I guesghc-modi gets lucky in that it doesn't use any functionality that depends on the Paths module.
12:01:45 <darthdeus> int-e: but then i shouldn't be able to build the ghc-modi target, no?
12:01:49 <darthdeus> ah
12:01:50 <darthdeus> lol
12:01:51 <int-e> (sorry, I'm lagging)
12:02:09 <darthdeus> is there somewhere where i can read how this whole thing works?
12:02:18 <darthdeus> like the Other-modules etc
12:02:28 <c_wraith> Rembane: it's the same name for the same thing.  A singleton type in an OO language is a type with only one value.  A singleton type in haskell is a type with only one value.  It just so happens that there's a far better reason for doing it in haskell. :)
12:02:36 <ReinH> map and fmap are not duplicates.
12:02:38 <Jefffrey> c_wraith: yeah, fmap vs map
12:02:45 <Rembane> c_wraith: As usual then. :)
12:03:24 <c_wraith> Jefffrey: Regrettable, but not a huge flaw.  And many of the issues (sequenceA vs sequence, for instance) are the result of Applicative not being a superclass of Monad, which is, in fact, being fixed up.
12:03:26 <Jefffrey> ReinH: They are if the functor in question is a list.
12:03:36 <benzrf> ml;
12:03:37 <ReinH> Yes, and not otherwise.
12:04:03 <int-e> darthdeus: http://www.haskell.org/cabal/users-guide/developing-packages.html sort of explains this, but I don't know of a discoverable place that warns of this as a pitfall (in particular in connection with generated modules that are easily forgotten)
12:04:08 <zwer> c_wraith what better reasons are those?
12:04:15 <yac> I seem to have an unicode problem with mkstemp ... sscce https://gist.github.com/yaccz/15d2238ed892c79006df
12:04:18 <gdoteof> if i have type  `data Foo = Foo` data Foo2 = Foo2 and both Foo and Foo2 are instance of FromJSON  can i define a new type data Bar = Foo | Foo2    and   Baz = Baz String Bar
12:04:19 <meiji11> I have this code using singletons that fails to type check only after attempting to use an implicit singleton argument, using withSing..
12:04:24 <meiji11> with an explicit singleton argument, everything is a-ok
12:04:30 <ReinH> do you also object to having both (++) and (<>)?
12:04:39 <meiji11> and the type error the implicit function uses is pretty cryptic.
12:04:47 <c_wraith> zwer: singleton types in haskell allow you to encode most dependently-typed programming.
12:04:58 <int-e> darthdeus: perhaps RWH touches on this. The problem comes up regularly on haskell-cafe, which puts it firmly into folklore.
12:05:29 <Jefffrey> ReinH: I think there should be a generic `append` function for `Container`s.
12:05:30 <int-e> (Or perhaps haskell-beginners now? I actually can't remember the last time I saw it.)
12:05:32 <gdoteof> the problem i'm having is decoding json from a websocket .  i am trying to use something like {'command': 'do_something', 'data': {/*someobject that command may need*/}
12:05:51 <Jefffrey> Or at least for containers in which make sense as an operation.
12:05:59 <Jefffrey> *makes
12:06:08 <ReinH> That's basically what monoid's (<>) gives you, except not over "containers"
12:06:45 <Mia18>  You can find funny videos here. http://bitly.com/1kdRPeV
12:06:52 <ReinH> or not *just* over containers
12:06:54 <gdoteof> in this case, i basically want `data` to get type checked and cast into some defined "Foo" based off the value of `command`.
12:07:09 <Jefffrey> ReinH: I can't seem to find it on Hoogle.
12:07:09 <ReinH> but there is at least value in map and (++) as pedagogic tools
12:07:15 <johnw> Jefffrey: what is "append" for two maps?
12:07:22 <pavonia> yac: What problem?
12:07:28 <meiji11> is it generally bad practice to pass implicit arguments to type functions that aren't injective, ie. those defined by type families?
12:07:33 <Jefffrey> johnw: "Or at least for containers in which make sense as an operation."
12:07:37 <johnw> :)
12:07:38 <meiji11> I realize that I don't quite understand how implicit arguments work.
12:07:46 <johnw> actually, Map does have a Monoid instance, it's simply left-biased
12:07:51 <ReinH> johnw: union :p
12:07:57 <meiji11> they're determined by the calling environment somehow? I guess?
12:08:04 <johnw> yeah, i'd prefer unionWith (<>) myself too
12:08:10 <ReinH> left-biased union, yes
12:08:29 <johnw> Map's left-biased union is rarely the behavior I want
12:08:30 --- mode: ChanServ set +q *!*@67.221.255.97
12:08:48 <Jefffrey> I also don't like the whole spread of "operators for almost everything". I think that readable code should be a priority over pretty code.
12:08:50 <ReinH> johnw: indeed.
12:09:11 <ReinH> some people find the operators more readable
12:09:18 <ReinH> It depends on your familiarity
12:09:32 <yac> pavonia: the a.hs generates garbage
12:09:40 <johnw> Jefffrey: are you here today to tell us what you don't like about Haskell?
12:09:53 --- mode: ChanServ set -q *!*@67.221.255.97
12:10:05 <Jefffrey> With "readable" I mean "for anyone to be able to grasp what a function does without taking a look at the documentation" (also called: self-documenting-code)
12:10:15 <Jefffrey> johnw: Yup :)
12:10:21 <johnw> fair enough
12:10:24 <ReinH> that doesn't seem like a very useful definition of readable
12:10:25 <johnw> you must _love_ lens :)
12:10:32 <ReinH> since it completely fails to account for context
12:10:38 <Jefffrey> ReinH: It definitely is if you read code :P
12:10:43 <pavonia> yac: Could you be a bit more specific? I can't try your example here
12:10:56 <johnw> when I was first exposed to Haskell code, I had Jefffrey's same reaction regarding the use of operators
12:11:07 <johnw> but once you are familiar with them all, the complaint goes away
12:11:11 <ReinH> I strongly disagree
12:11:14 <darthdeus> int-e: thanks, i'll check it out
12:11:19 <darthdeus> i guess cabal manual might also cover this
12:11:24 <ReinH> and I read a *lot* of code
12:11:29 <ReinH> context always matters
12:12:02 <johnw> at least the context is never further than the module import list; in C++ context can be buried *deep* inside macro expansions within system headers
12:12:18 <Jefffrey> Like `(<|)` or `(><)`. Are they mathematically accepted symbols or something?
12:12:23 <ReinH> johnw: I mean the context of the person doing the reading :)
12:12:34 <johnw> <| and >< are in somebody's library somewhere
12:12:37 <yac> pavonia: reload the gist, I updated it with the outputs
12:12:41 <ReinH> why would they need to be?
12:12:42 <johnw> they have whatever meaning that library author chose for them
12:12:49 <ReinH> they are mutually understood
12:12:51 <johnw> they are just "names", like any other name
12:12:53 <ReinH> that's what matters
12:13:20 <Jefffrey> That's not what I consider readable code. Operators overuse to make things shorter is a bad idea IMHO.
12:13:25 <johnw> for truly abstract operators, there is often no "name", but just a symbol to refer to the abstraction, like ">>=" (even though we call it "bind", that's just convention)
12:13:29 <ReinH> everything is illegible to people who don't speak the language
12:13:34 <ReinH> context is crucial
12:13:39 <johnw> ReinH++
12:13:54 <ReinH> you can't just say "X is more readable" as some universal
12:13:57 <theorbtwo> ...and people call Perl unreadable!
12:14:07 <johnw> you can't say a language is intelligible simply because it's meaning is not obvious to those who barely know the language
12:14:24 <pavonia> yac: writeFile/readFile and mkstemp seem to use different file encodings
12:14:38 <Jefffrey> ReinH: I consider Brainfuck to be unreadable "as some universal"
12:14:56 <Jefffrey> Some Haskell code can get near that level of unreadability.
12:15:05 <ReinH> The implied question is "readable *to whom*?"
12:15:11 <ReinH> and the whom definitely matters
12:15:14 <Saizan_> johnw: intelligible = comprehensible
12:15:31 <Jefffrey> ReinH: To those that know English
12:15:34 <johnw> oops
12:15:38 <johnw> I mean unintelligible
12:15:41 <zwer> the point is, you can give the function a meaningful, self-describing name. try to do that with an operator
12:15:50 <ReinH> That's not a meaningful metric
12:15:52 <theorbtwo> It is true, IMHO, that Haskel is unreadable to more people then many languages, simply because it doesn't follow the same conventions as many other languages.
12:15:53 <yac> pavonia: the problem should go away if I convert String to bytes and then write it right?
12:16:02 <ReinH> we've tried English-like languages
12:16:06 <ReinH> they are terrible
12:16:09 <johnw> zwer: what's the self-describing name for <>?
12:16:11 <Jefffrey> lol
12:16:25 <theorbtwo> If >>= is called "bind" by convention, then why isn't there a function named "bind" that is the same as >>=?
12:16:40 <johnw> theorbtwo: good question, I've wanted it before
12:16:46 <Jefffrey> >>= is mathematically accepted
12:16:50 <Jefffrey> even C++ has it
12:16:57 <johnw> "9 out of 10 mathematicians agree"
12:17:05 <Jefffrey> he he
12:17:07 <ReinH> And I'm afraid I'm all out of patience for contrarianism today.
12:17:12 <theorbtwo> Jefffrey: >>= in C++ is something completely different to >>= in haskel?
12:17:13 <pavonia> yac: Yes, but make sure the default text encoding doesn't mess up these bytes as well
12:17:23 <johnw> theorbtwo: 100% different
12:17:25 <Jefffrey> theorbtwo: yes
12:17:28 <zwer> johnw what is your point?
12:17:43 <johnw> zwer: some operators don't have "self-describing names"
12:17:49 <zwer> johnw, because you can't think of a reasonable name for a single operator, it renders my claim invalid?
12:18:11 <zwer> johnw most do
12:18:12 <pavonia> yac: I would use Data.Text.Encoding for encoding and decoding text to a ByteString and then use ByteString's readFile/writeFile
12:18:13 <johnw> no, your claim is not invalid
12:18:41 <ReinH> We are all drinking from a poisoned well. :(
12:18:51 <ReinH> let's go back to talking about Haskell please
12:18:52 <Jefffrey> My point is: you can't do self-describing code with operator overuse.
12:19:11 <Jefffrey> that's the tl;dr
12:19:20 <johnw> ok, point made, let's move on
12:19:32 <bvad> Jefffrey: Do you expect to be able to read code without knowing the language?
12:19:50 <Jefffrey> I don't understand. What's wrong with talking about the downsides of Haskell? Why do you get mad?
12:20:08 <ReinH> contrarianism is frustrating
12:20:11 <johnw> we aren't mad, it's just not very interesting
12:20:15 <ReinH> I'm not mad. I'm bored.
12:20:21 <Jefffrey> bvad: The value of self-documenting code is not related to "knowing" or not the language
12:20:21 <bvad> Jefffrey: Oh, I don't get mad, I just feel that it's not unique to haskell
12:20:26 <johnw> if you want to fix Haskell, we aren't the people you need to convince
12:20:38 <theorbtwo> bvad: I find I can do so fairly well for a fair number of languages.
12:20:39 <vanila> Jefffrey, it's just how weak and invalid your arguments are and how you don't take any input
12:20:57 <yac> Jefffrey: so you dislike chinesse as well?
12:20:58 <Jefffrey> vanila: take input != agree
12:21:07 <Jefffrey> yac: lol
12:21:21 <ReinH> Can we stop now?
12:21:34 <ReinH> nothing good has or will come of this
12:21:39 <bvad> theorbtwo: Because you've been taught 'C-like' syntax or because it's more natural?
12:21:46 <johnw> I agree with ReinH
12:22:09 <johnw> let's all just agree that nothing is perfect and move on to writing some code
12:22:23 <theorbtwo> Jefffrey: the value of self-documenting code is not related, but there's a whole plethora of ways in which a thing can be more or less self-documenting.
12:22:28 <theorbtwo> bvad: Some of both, I think.
12:22:49 <danking> Hi there, I'm completely new to Haskell so this is likely largely due to my own ignorance. I have a cabal project with a `.cabal' file. My `build-depends' contains `transformers' at versions >= 0.4.1.0. I'm trying to `import Control.Monad.Trans.Cont' in this project.
12:22:55 <theorbtwo> bvad: It certianly is the case that I've been learning a more C-like then haskell-like syntax since a very young age.
12:23:07 <johnw> danking: what error are you seeing?
12:23:07 <Jefffrey> I'm not doing contrarianism at all. Disagreeing leads to interesting discussions IMHO.
12:23:15 <ReinH> Hi danking
12:23:21 <bvad> theorbtwo: I think almost everyone has :)
12:23:26 <danking> However, cabal informs me that "Could not find module `Control.Monad.Trans.Cont'", and then tells me that its part of a hidden package `transformers-0.4.1.0', which seems wrong, since it's in my build-depends.
12:23:31 <danking> johnw: ^
12:23:39 <ReinH> not when one side of the dialog just keeps saying the same things over and over
12:23:48 <Jefffrey> ReinH: If you don't like this one, just stop talking. I won't ping you or anything. :)
12:23:55 <johnw> danking: can you paste your cabal file for us?
12:23:55 <Jefffrey> Just don't talk for everybody else.
12:24:03 <johnw> using a pasting service, like mentioned in the topic?
12:24:08 <enthropy> danking: do you have an executable + library?
12:24:21 <ReinH> you are very aggressive and confrontational
12:24:27 <ReinH> it is tedious
12:24:31 <danking> johnw: Certainly: http://lpaste.net/104554
12:24:37 <danking> enthropy: Just an executable.
12:24:44 <enthropy> anybody know how to address http://lpaste.net/104553 ?
12:24:57 <johnw> danking: your test suite may need it also?
12:25:41 <zwer> ReinH I find you and several others more aggressive than him
12:25:56 <danking> johnw: Ahah, thank you.
12:26:35 <danking> I guess since the tests build the main project they need to have everything that the main project has. Have I structured my cabal project in a weird way? It seems redundant to list the packages twice.
12:27:01 <johnw> it seems that way to everyone :)
12:27:12 <johnw> i think there is a solution in more modern cabals, but I have forgotten how
12:27:16 <hpc> enthropy: i would have to stare at it for a while to get exactly what's going on, but perhaps instance Fail (FieldNotFound e1) => HFind1 e1 '[] (Proxy e1)?
12:27:33 <Jefffrey> ReinH: How am I aggressive?
12:27:56 <danking> johnw: Alright, thank you for your help.
12:28:03 <enthropy> danking: you can make a library section, then depend on that library in your test-suite and a little stub executable that is just  main = ScientificPL.main
12:28:21 <ReinH> Well, you're giving me orders. But I'd really prefer to drop it.
12:28:38 <Jefffrey> As you wish, milord.
12:28:41 * hackagebot simplessh 0.2.0.3 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.3 (thoferon)
12:28:44 <enthropy> quite possibly you have to make "hs-source-dirs: src", to keep the test-suite/executable from finding the .hs files
12:28:47 <vanila> you probably have to drop it, he's not going to stop trolling if people keep replying
12:28:58 <ReinH> vanila: good point
12:29:00 <zwer> ReinH that one is easy - just stop talking about it. you seem to want to get the last word in, though
12:29:15 <enthropy> hpc: yes if only the kinds weren't getting in the way
12:29:20 <ReinH> zwer: you might be right.
12:29:24 <vanila> zwer, that's because you initially give people the benefit of the doubt and assume they're reasonable/interested in discussion
12:29:38 <Jefffrey> (I am?)
12:29:41 <enthropy> hmm, maybe it'll be a better message if HFind uses PolyKinds
12:30:16 <hpc> enthropy: doh, yes
12:30:51 <hpc> neat code, though
12:32:34 <Jefffrey> By the way Haskell is one of my favorites languages. I love most of it, but there are just few things I don't consider right. I've been wrong before in judging Haskell's choices, that's why I come here and discuss it with other people.
12:32:53 <Yoctogon> what are they?
12:33:34 <ReinH> Please not again.
12:33:57 <Hodapp> I totally have black friends.
12:34:25 <Jefffrey> Like that time (at the very beginning) where I couldn't stand the a -> b syntax. Then I read about currying and everything made sense.
12:35:39 <Yoctogon> so, in other words, you don't consider anything that you don't understand right, right.
12:36:22 <johnw> Jefffrey: well, for some this is the Nth time we've had a similar discussion with no positive outcome, so maybe we're just weary
12:36:59 <Jefffrey> Yoctogon: I might consider something, that I'm unknowingly ignorant about, wrong
12:37:10 <Jefffrey> That's what I'm trying to fix.
12:37:48 <ReinH> I don't find repeatedly re-asserting my own position to be an effective way to learn.
12:37:58 <ReinH> usually listening works better for that
12:38:08 <Yoctogon> Jeffrey: it's quite simple: simply be open minded and try not to assume that you know any more than you actually do
12:38:16 <vanila> oh god its still happening
12:38:26 <ReinH> I'm going to go do something else.
12:38:26 <johnw> vanila: lol
12:38:33 <johnw> me too, bye guys!
12:38:40 <vanila> I'm never coming back!
12:38:40 <Jefffrey> johnw: Tbh we can stop the discussion on "bad-haskell". It's just boring, IMHO, to be here all praising how haskell is good and nice.
12:38:42 * hackagebot obdd 0.3.1 - Ordered Reduced Binary Decision Diagrams  http://hackage.haskell.org/package/obdd-0.3.1 (JohannesWaldmann)
12:39:50 <Hodapp> I've been in various language channels, and this channel is about 1/100 of the idiotic language circle-jerk that you'll find in the likes of ##c and ##c++.
12:40:10 <vanila> 1/100th of ##c is way way too much
12:40:12 <shapr> It's due to regular enforcement of the cultural rules.
12:40:26 <Hodapp> vanila :P
12:40:31 <Hodapp> vanila: I see you've been there too?
12:41:13 <prophile> ##c is banned in 78 countries
12:41:39 <prophile> including every european nation except norway
12:41:55 <Hodapp> o_O
12:42:04 <Hodapp> why's Norway still allow them?
12:42:22 <prophile> trolls are native to Norway
12:42:27 <oleo> lol
12:42:31 <Jefffrey> lol
12:43:12 <LT1MH> Hello every1!
12:43:27 <Jefffrey> hi
12:43:43 * hackagebot Ketchup 0.1.1 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.1.1 (Hamcha)
12:51:09 <enthropy> hpc: got it. The trick is to change the final 'type' into 'class'
13:07:41 <jophish> @tell edwinb Did the llvm-general builder monad ever make its way out of Idris into its own package?
13:07:42 <lambdabot> Consider it noted.
13:32:10 <elfenlaid_> hi :) I'm kind of new with cabal, packages & etc. I'm trying to build examples from a book and get this error https://gist.github.com/anonymous/0dae3939b3601303234b. Please suggest a way to resolve base dependency
13:32:53 <StoneCypher> by blasting off all zig
13:33:24 <michaelt> elfenlaid_: it looks like the cabal file is not up to date for your purposes just a sec
13:34:18 <elfenlaid_> michaelt: from my point of view, package requires base < 4.7, but on my system installed only 4.7.0 base
13:35:18 <elfenlaid_> may be it could be resolve with applying "sandbox" or something
13:35:28 <michaelt> elfenlaid_: yes, the base you have is engraved in stone. I think you should maybe not install it anyway, since it's for study? You might just clone https://github.com/simonmar/parconc-examples
13:37:04 <elfenlaid_> michaelt: oh, thanks for solution
13:38:09 <klarh> Is it possible to install haste-compiler with an updated (with respect to whatever came with the system GHC installation) version of cabal?
13:39:23 <mmmm> cabal install haste-compiler ?
13:41:16 <michaelt> elfenlaid_: there should be an issue on the github site, but  a patch would be a little bit of a pain I see from all the little executables.
13:41:33 <mmmm> klarh: What is your exact problem?
13:41:48 <klarh> mmmm: well, the initial installation works, but then haste-boot dies when it can't find cabal-1.16
13:42:17 <mmmm> cabal --version ?
13:42:33 <klarh> mmmm: cabal-install version 1.20.0.2
13:42:54 <klarh> I've updated locally, but it wants to find the version that ghc originally had, it seems
13:43:45 <mmmm> have you added ~/.cabal/bin to path?
13:43:48 <monochrom> I don't know haste-compiler. but usually PATH is enough to determine what you get
13:43:52 <klarh> yes
13:44:16 <monochrom> order is important
13:44:37 <mmmm> "which cabal" resolves to the correct version?
13:44:55 <klarh> "which cabal" gives me the one in ~/.cabal/bin
13:45:07 <monochrom> then again, since "cabal --version" gives you the right answer, your PATH is already right
13:45:22 <klarh> /usr/bin/cabal is 1.20.0.1, incidentally
13:46:12 <klarh> I assumed haste-boot was ignoring both more up-to-date versions of cabal on purpose
13:46:32 <klarh> or rather, the cabal library, I guess I should say
13:47:09 <klarh> actually, I guess I shouldn't even say that it's the cabal library, but rather the dependencies of the cabal-1.16 library
14:54:51 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
14:54:51 --- topic: set by johnw on [Mon Feb 17 18:32:10 2014]
15:14:34 <ReinH> johnw: So you're giving a workshop on using math in Haskell right?
15:15:06 <ReinH> johnw: I'm currently using the game 2048 to explore basic group theory :)
15:19:03 <benzrf> ReinH: o-o
15:21:24 <ReinH> benzrf: basically D_8 lets you rotate the square using compositions of transposes and reverses
15:22:03 <benzrf> D_8?
15:22:14 <ReinH> dihedral group of order 8
15:22:18 <benzrf> also i am aware of transpose/reverse for rotation o=
15:22:24 <benzrf> i do not know group theory =[
15:22:24 <ReinH> http://groupprops.subwiki.org/wiki/Dihedral_group:D8
15:22:29 <benzrf> i know what a group /is/
15:22:34 <ReinH> benzrf: you have an intuition for group theory then :)
15:22:48 <benzrf> what is an order
15:23:12 <benzrf> as in, order 8
15:23:16 <ReinH> if M1 is vertical mirror and D1 is top-left to bottom-right diagonal mirror then M1 <> D1 = R1 (90 degree clockwise rotation)
15:23:38 <benzrf> what does a group do to extend upon a monoid aga9in?
15:23:40 <benzrf> *again
15:23:40 <ReinH> so rotate = map reverse . transpose
15:23:44 <ReinH> benzrf: adds inverses
15:23:53 <benzrf> how is that formally defined?
15:24:10 <benzrf> why not transpose . reverse
15:24:16 <ReinH> a^-1 <> a = unit
15:24:16 <benzrf> wait hnn
15:24:27 <ReinH> a^-1 being the inverse of a
15:24:29 <benzrf> where unit is like mempty?
15:24:31 <benzrf> kk
15:24:32 <ReinH> yes
15:24:48 <ReinH> I should have just said mempty
15:24:59 <ReinH> left- and right-inverse
15:25:12 <ReinH> a^-1 <> a = mempty = a <> a^-1
15:26:06 <epta> Could someone please point me to a guide how to install ghc from a sources inside a cygwin?
15:26:14 <ReinH> benzrf: yes, map reverse . transpose = transpose . reverse :)
15:26:21 <tremon> is <> here a placeholder for a group-specific operator, or an actual operator?
15:26:40 <hpc> (<>) is the commonly used infix name for mappend
15:26:46 <hpc> so, "yes"
15:26:58 <tremon> ah. an haskell operator even :)
15:28:33 <halvorg> :t mappend
15:28:34 <lambdabot> Monoid a => a -> a -> a
15:28:38 <benzrf> >tfw i realize i dont know shit about mathemancer
15:28:41 <benzrf> *math
15:28:54 <ReinH> benzrf: which means that M1 <> D1 = D1 <> M2, where M2 is vertical flip :)
15:29:18 <benzrf> i dont know calculus beyond what ders/ints are, i dont know abstract algebra beyond what algebraic structures are, i have almost 0 knowledge of matrices
15:29:28 <benzrf> ;-;
15:30:33 <ReinH> benzrf: this comes in handy because it lets you reason about "what's the most efficient way to rotate a square by 90 degrees n times"
15:30:52 <teknokratsevilla> what ?
15:30:55 <ReinH> benzrf: so rotate1 = transpose . reverse
15:31:05 <ReinH> benzrf: and a naive rotate3 would be rotate1 . rotate1 . rotate1
15:31:44 <ReinH> benzrf: but then you can use the fact that D1 <> M1 = R3 to define rotate3 as transpose . map reverse instead :)
15:32:02 <tremon> where does the order 8 come from? With rotations, I only see 4 board states. Does it include flips?
15:32:12 <ReinH> tremon: flips, yes
15:32:17 <ReinH> 4 rotations, 4 flips
15:32:35 <ReinH> another way to look at it is the permutation of ways to send each vertice to another vertice
15:33:44 <ReinH> not quite, because it has to preserve symmetry
15:33:45 <ReinH> sorry
15:33:47 <ReinH> let me try to rephrase
15:34:36 <ReinH> it's a permutation *group*
15:36:55 <ReinH> The 8 elements of the group are (with e being unit, a being a single rotation, x being a single flip): { e, a, aa, aaa, ax = xaaa, aax, aaax = xa}
15:37:18 <ReinH> oh I forgot x
15:39:50 <tremon> that's clear. I'm interpreting it as reversing either axis, or swapping x/y axes, giving 3 (binary) degrees of freedom, does that make sense?
15:40:32 <ReinH> tremon: yep
15:40:41 <tremon> yay :)
15:40:54 <ReinH> tremon: and it's an algebra, so you have some nice properties
15:41:10 <ReinH> a^2 = aa, a^3 = aaa
15:41:55 <ReinH> tremon: and x^2 = 1 so x = x^-1, so x is an involution
15:42:28 <ReinH> you have identities a^4 = x^2 = e
15:42:30 <ReinH> etc
15:42:32 * tremon goes googling for involution
15:42:42 <ReinH> tremon: an involution is a self-inverse
15:42:54 <ReinH> x is an involution if xx is the identity
15:43:05 <ReinH> flipping and flipping again gets you back to where you started
15:43:14 <tremon> ah. Needed to parse that twice
15:43:35 <ReinH> and two 180 degree turns give you a 360 degree turn
15:43:48 <ReinH> so (a^2)^2 = e, so a^4 = e
15:44:14 <ReinH> since (a^2)^2 = a^{2+2} = a^4
15:44:16 <ReinH> algebra!
15:44:33 <teknokratsevilla> e = unit = initial state ?
15:44:51 <ReinH> teknokratsevilla: e = unit = 1 = the "do nothing" transformation
15:44:55 <ReinH> = the identity
15:45:18 <ReinH> it's called empty, unit, neutral, 1, or 0 depending on context :D
15:45:50 <teknokratsevilla> e = The zero ...
15:45:55 <ReinH> 1 is used because it has properties like 1^n = 1 implies that you can do it as many times as you want without changing things
15:46:08 <ReinH> 0 is used because 0n = 0
15:46:20 <ReinH> it depends on if you're treating things additively or multiplicatively
15:46:48 <ReinH> remember that addition is to multiplication as multiplication is to exponentiation :)
15:47:24 <freeman42> anyone here an Emacs guru (HaRe and ghc-mod)? ^^ I am trying to figure out how to performa that 'initializer hook' step: http://i.imgur.com/E0C1mfh.png
15:47:58 <freeman42> from here: https://github.com/alanz/HaRe
15:48:57 <ReinH> benzrf: another way to get a 270 degree rotation is to note that it's the same as a -90 degree rotation
15:49:01 <ReinH> so aaa = -a
15:49:38 <ReinH> and then to note that xax = -a, so reverse . rotate . reverse = rotate . rotate . rotate
15:55:01 <ReinH> benzrf: can I show you one last thing?
15:56:41 <benzrf> oki
15:56:46 <ReinH> benzrf: http://lpaste.net/2902999306246029312
15:57:01 <ReinH> benzrf: notice anything special about `transform'?
15:57:26 <coppro> is there an easy way to handle an Either in IO
15:57:37 <teknokratsevilla> real world haskell seems to me a very good book
15:57:55 <coppro> oh wait, that's EitherT, derp
15:57:57 <ReinH> coppro: what kind of handling do you have in mind?
15:59:33 <Cale> coppro: EitherT exists, but most of the time, you just want a case expression
15:59:43 <ski> or an `either'
16:00:00 <ReinH> Oh. The obvious kind of handling.
16:00:03 <coppro> I have a bunch of those in a row though
16:00:11 <coppro> I want short-circuiting
16:00:22 <ReinH> coppro: use another do block in the Either monad?
16:00:34 <ski> sounds like `EitherT' could possibly be helpful, then
16:00:37 <coppro> hmm... actually that might work here
16:00:42 <coppro> since I only do IO in one place
16:00:53 <ReinH> EitherT is useful if you need to "interleave" IO
16:00:57 <ReinH> If not, you can just use Either
16:01:19 <ski> interleave how ?
16:02:00 <ReinH> ski: That was a bad word choice. If you want to use liftIO while you're in a monad with Either-like behavior.
16:02:10 <ReinH> *in a do block
16:02:23 <meiji11> I'm having trouble getting a function that uses implicit arguments for singleton types to compile. code is here: http://lpaste.net/104551
16:02:34 <ReinH> benzrf: give up? :D
16:02:39 <meiji11> indexI is the culprit, everything absent indexI compiles fine.
16:02:48 <benzrf> crud
16:02:49 <benzrf> i was budy
16:02:51 <benzrf> *busy
16:02:52 <benzrf> hold on p:
16:02:52 <ReinH> benzrf: :p
16:03:06 <ski> ReinH : mhm
16:03:34 <ReinH> ski: I guess my scare quotes weren't scary enough ;)
16:03:52 <ski> i just wondered what you meant
16:03:59 <ReinH> ski: ok :)
16:04:39 <ReinH> benzrf: here's a hint: what happens to the identity of the Dih8 monoid
16:05:19 <benzrf> ReinH: this is interesting but i cant read it cuz i dont know what the Dih8 values mean
16:05:27 <benzrf> or is that the puzzle?
16:05:32 <ReinH> benzrf: Rs are rotations, Ms are mirrors, Ds are diagonal mirrors
16:05:37 <ReinH> I should write some ascii diagrams
16:06:18 <ski> why isn't it called `Dih_4' ?
16:06:47 <Isabella18>  Here some videos. I hope you like them! http://bit.ly/1otJNif
16:06:56 <jp`> @help
16:06:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:07:10 <jp`> @help list
16:07:10 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:07:37 -ChanServ(ChanServ@services.)- ski added Isabella18!*@* to the AKICK list.
16:07:37 --- mode: ChanServ set +b Isabella18!*@*
16:07:37 --- kick: Isabella18 was kicked by ChanServ (Banned: spam)
16:07:52 <ReinH> benzrf: like this except I prefer clockwise rotation http://www.cs.umb.edu/~eb/d4/
16:08:16 <ReinH> benzrf: does that make sense?
16:09:02 <benzrf> yeah
16:09:07 <ski> jp` : i take you were looking for `@where ops' ?
16:09:43 <benzrf> oic
16:09:44 <benzrf> interesting
16:09:50 <benzrf> why are they called 'symmetries'/
16:10:08 <ReinH> benzrf: a symmetry is an operation you can perform on something so that it looks the same before and after
16:10:16 <ReinH> so rotate a square by 90 degrees
16:10:19 <ReinH> any rotation of a circle
16:10:21 <ReinH> etc
16:10:26 <benzrf> ahihi:
16:10:27 <benzrf> *ah
16:10:35 <benzrf> i was thinking of the arrangement of the contents
16:10:38 <benzrf> not the general shape p:
16:11:01 <ReinH> benzrf: right, I see what you mean
16:11:20 <jp`> ski, i was just trying to figure out IRC command
16:11:27 <jp`> i'm new to it
16:11:30 <ski> ok
16:11:46 <ReinH> benzrf: so the group's identity is R0. What is transpose R0?
16:12:04 <ski> @listmodules
16:12:04 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:12:11 <ski> @list dict
16:12:11 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
16:12:43 <ski> jp` : anyway, these aren't IRC commands, but lambdabot commands
16:13:05 <jp`> ah ok, thanks, ski
16:13:40 <jp`> @list haddock
16:13:40 <lambdabot> haddock provides: index
16:13:47 <ReinH> benzrf: so another way to look at it is to number the vertices of the square from the top-left, clockwise as (1,2,3,4). Then R1 sends (1,2,3,4) to (2,3,4,1). 1 becomes 2, 2 becomes 3, etc.
16:13:57 <ReinH> benzrf: so does that help explain how it's being used here?
16:14:54 <awestroke> @pointful sum . map (+2) . filter (> 3) . (0:) $ xs
16:14:54 <lambdabot> (sum (map (\ a -> a + 2) (filter (\ b -> b > 3) (0 : xs))))
16:14:59 <ReinH> benzrf: another way of saying this is that the rotations of the square are the same as the cycle group of order 4
16:15:19 <ReinH> benzrf: but I wanted to show you something about morphisms :)
16:15:33 <benzrf> i dont know anything about cycle groups
16:15:37 <benzrf> or any kind of group -.-
16:15:39 <ReinH> benzrf: I just showed you one :)
16:15:43 <benzrf> well
16:15:44 <ReinH> benzrf: but anyway, do you know monoids?
16:15:45 <benzrf> besides that one =p
16:15:58 <benzrf> i mean groups that arent discussed in lower maths
16:16:28 <ReinH> benzrf: (groups came out of the study of symmetries like this, so talking about symmetries *is* talking about groups ;)
16:16:32 <benzrf> i.e. i am sure that there is a monoid of sets with union
16:16:37 <benzrf> but i do not know about symmetries
16:16:40 <benzrf> etc
16:16:46 <benzrf> or what the order of a group is
16:16:47 <benzrf> :u
16:16:47 <ReinH> benzrf: so forget about symmetries, let's just talk about monoids
16:16:54 <benzrf> hold on, i am going to read the code
16:17:01 <benzrf> im just refreshing my knowledge of groups :u
16:17:09 <ReinH> benzrf: I've only defined the monoid so far :)
16:17:22 <ReinH> benzrf: A group is a monoid with inverses, so if you forget about the inverses you can just talk about the monoid
16:17:33 <ReinH> benzrf: so let's just talk about the monoid
16:17:45 <benzrf> ik
16:17:47 <benzrf> o=
16:17:56 <benzrf> l-let me read the code
16:18:00 <ReinH> benzrf: ok :)
16:18:17 <ReinH> Maybe we should take this to #haskell-overflow?
16:18:54 <ReinH> I don't want to disrupt other conversations.
16:19:04 <ReinH> But no one else is really talking, so...
16:19:21 <ReinH> benzrf: actually let's forget about this code and talk about monoids in general
16:21:23 <jp`> can functions in haskell return multiple values, or must they be returned as tuples?
16:22:22 <ReinH> jp`: the latter
16:22:29 <ReinH> jp`: or some other value that represents multiple values
16:22:36 <ReinH> (a,b) represents exactly two values
16:22:43 <ReinH> Maybe a represents 0 or 1 value
16:22:47 <ReinH> [a] represents 0 or more values
16:22:48 <ReinH> etc
16:22:53 <jp`> got it
16:22:56 <jp`> thanks, sir
16:23:02 <ReinH> jp`: np
16:23:27 <coppro> ugh, what's the best way to associate a piece of data with a type?
16:23:34 <benzrf> coppro: use agda
16:23:39 <coppro> benzrf: thanks
16:23:47 <coppro> I'll just rewrite my project in Agda
16:23:51 <ReinH> Depending on what you mean by "associate"
16:23:53 <benzrf> coppro: or a typeclass =)
16:24:06 <ReinH> there might be zero or more answers to your question ;)
16:24:23 <benzrf> coppro'sAnswer :: Maybe Answer
16:24:30 <ReinH> [Answer] :p
16:24:44 <ReinH> has the right denotation :p
16:25:02 <ReinH> benzrf: anyway can we talk about monoids? because this is really cool
16:25:16 <benzrf> 1 sec
16:25:19 <benzrf> i am savoring this code
16:26:16 <benzrf> okay go on
16:26:47 <ReinH> benzrf: so generally, a monoid is a set with some structure: an associative binary operation and an identity element.
16:27:05 <benzrf> y
16:27:21 <ReinH> benzrf: so generally a function f : X -> Y takes an element in X to an element in Y right?
16:27:28 <ReinH> so functions are mappings from set to set
16:28:05 <ReinH> benzrf: what if you want a mapping between monoids?
16:28:53 <ReinH> benzrf: you probably don't want just any function on the underlying sets, right? You want one that "knows about" identity and associativity, right?
16:29:43 <benzrf> uh huh
16:29:44 <ReinH> you want a function that is "well behaved" for the monoid laws
16:29:46 <benzrf> is this about functors
16:29:52 <benzrf> like cat theory ones
16:29:55 <ReinH> benzrf: something simpler!
16:29:58 <benzrf> homomorphism
16:30:06 <ReinH> sort of!
16:30:12 <magthe> hackage won't accept the tar-ball I'm trying to upload, despite having created it using `./Setup.hs sdist`... why would it complain on it being "in the non-standard GNU tar format"?
16:30:27 <ReinH> in algebra, we say that a morphism is a *structure preserving* mapping between objects
16:31:01 <ski> ("is this about functors" is a funny question when introducing homomorpisms)
16:31:12 <ReinH> benzrf: so a monoid can be represented by the tuple <M,<>,id>, where M is the set, <> is the product, e is the identity
16:31:28 <ion> id
16:31:30 <benzrf> ski: homomorphisms are to algebraic structures as functors are to cats, no
16:31:32 <ReinH> ok
16:31:39 <benzrf> ReinH: using <> for tuples?
16:31:41 <benzrf> how mathy
16:31:45 <ReinH> ok fine :)
16:31:46 <ski> "no" ?
16:31:54 <benzrf> ski: is that a response or a question
16:32:03 <ski> a question
16:32:05 <benzrf> ski: the no at the end is a prompt for confirmation
16:32:15 <benzrf> i left off a qmark
16:32:15 <benzrf> ;p
16:32:20 <ReinH> a morphism between monoids (M,+,id) and (M',+',id') is one that sends M to M', + to +' and id to id' in the following way:
16:32:26 <ReinH> call the morphism f
16:32:27 <ski> benzrf : confirmed
16:32:31 <benzrf> ski: :-)
16:32:32 <ion> That would be "no?" :-P
16:32:34 <benzrf> so they sound kinda similar
16:32:34 <ReinH> f(M) = M'
16:32:38 <ReinH> f(id) = id'
16:32:44 <benzrf> therefore i thought at first it was about functor
16:32:45 <benzrf> :-o
16:32:47 <danking> Hi, I'm rather new to Haskell coming from Scheme. I decided to change one of my functions to accept a "short-circuiting" continuation so I could break out of a series of recursive calls. Now all my code has to use `do' and `>>='. Is there some way to make it so that I can still write something like: `DataConstructor (foo a k) (foo b k)'?
16:32:53 <ReinH> f(x + y) = f(x) +' f(y)
16:32:58 <ReinH> benzrf: does that look familiar?
16:33:01 <benzrf> ReinH: yep!
16:33:03 <benzrf> :-)
16:33:09 <ReinH> it's a lot like the functor laws
16:33:10 <benzrf> vaguely
16:33:13 <ski> ReinH : "f(M) = M'" ?
16:33:27 <vanila> danking, I think not but i would like to see more code
16:33:28 <ReinH> ski: f : M -> M' if you prefer
16:33:43 <ski> danking : perhaps you meant to write in CPS ?
16:33:46 <glguy> danking: You can use the Applicative operators to write: DataConstructor <$> foo a k <*> foo b k
16:34:10 <ReinH> benzrf: note that id and id' are different, and + and +' are different
16:34:10 <benzrf> danking: applicatives r fun !
16:34:11 <danking> Hi, I'm rather new to Haskell coming from Scheme. I decided to change one of my functions to accept a "short-circuiting" continuation so I could break out of a series of recursive calls. Now all my code has to use `do' and `>>='. Is there some way to make it so that I can still write something like: `DataConstructor (foo a k) (foo b k)'?
16:34:13 <ski> ReinH : i do prefer :)
16:34:16 <danking> oops sorry
16:34:17 <ReinH> ski: ok :)
16:34:18 <benzrf> ReinH: yeah
16:34:22 <glguy> which isn't exactly what you asked for , but it's the closest I can think of without restructucturing what I think your code looks like
16:34:35 <ReinH> benzrf: so what this says, intuitively, is that f sends the id of M to the id of M'
16:34:40 <benzrf> sure
16:34:46 <ReinH> benzrf: and f sends the + of M to the + of M'
16:34:46 <danking> glguy, benzrf: Interesting, that's basically what I want. I'll look into those.
16:34:52 <benzrf> and that it distributes over +
16:34:57 <ReinH> benzrf: yes
16:35:00 <benzrf> is that a ring?
16:35:09 <ReinH> benzrf: no
16:35:10 <ski> it's a monoid homomorphism
16:35:21 <ReinH> it's a monoid morphism, a.k.a. a monoid homomorphism
16:35:33 <benzrf> oh wait f is unary
16:35:34 * benzrf headdsks
16:35:44 <ReinH> benzrf: so, let's look at my code again
16:35:54 <ski> "it distributes over +" doesn't sound wrong
16:36:02 <benzrf> ski: yeah, but calling it a group does
16:36:04 <benzrf> ;)
16:36:07 <ReinH> ski: I don't think it is :)
16:36:11 <benzrf> * a ring
16:36:15 <ReinH> benzrf: so, let's look at my code again. What's the identity for Dim8?
16:36:20 <ski> ReinH : it is what ?
16:36:23 <benzrf> ReinH: R0
16:36:27 <danking> vanila: It's rather long and ugly. It's an interpreter for a simple language, I'd like the continuation to short-circuit interpretation if the interpreter cannot take a step. This seemed (at first) easier than having my return type be `Either Bad Value' and then always checking if I got a bad and propogating that up.
16:36:28 <ReinH> ski: it does distribute :)
16:36:35 <ReinH> benzrf: where does transpose send R0?
16:36:37 <ReinH> er transform
16:36:39 <benzrf> but my parents are getting increasingly strident in their demands fvor me to join dinner
16:36:40 <ReinH> sorry
16:36:44 <ReinH> where does transform send R0?
16:36:47 <benzrf> id
16:36:48 <ReinH> benzrf: 2 minutes!
16:36:50 <danking> ski: I'd rather CPS convert everything, that sounds rather painful.
16:36:59 <vanila> danking, I think you should return Either
16:37:04 <ReinH> benzrf: and note that, e.g., R1 + R1 = R2
16:37:20 <benzrf> danking: why not use the Either monad
16:37:23 <ski> danking : do you mean *manually* CPS-translate everything ?
16:37:29 <ReinH> benzrf: and that transform R1 = transform R1 . transform R1
16:37:34 <danking> ski: Yes?
16:37:35 <benzrf> ReinH: so tranform is a homomorphism to the function monoid?
16:37:38 <ReinH> benzrf: so what this says is that transform is a monoid morphism
16:37:47 <benzrf> ok my dad is getting upset
16:37:49 <ski> danking : then you can do so, if you want to
16:37:50 <benzrf> bbl :I
16:37:52 <glguy> danking: You don't have to manually check that the result is Left or not, you can use the same monadic approach and use Either to short circuit like exceptions
16:38:01 <ReinH> benzrf: from the monoid that underlies the group Dim8 to the monoid of functions that transpose grids
16:38:03 <danking> Fascinating.
16:38:16 <ReinH> transpose, transform, w/e
16:38:43 <ReinH> benzrf|offline: so because if this you know that if an identity holds for the group it also holds for the transformations :D
16:38:47 <ReinH> so you can reason equationally
16:39:06 <danking> glguy, vanila, benzrf, ski: I'm not really sure how to do what you're suggesting exactly.. Perhaps I should undrestand monads more first. Do you know of any resources/examples that directly talk about using Either to propgate up failures values?
16:39:31 <danking> ski: I meant to see I'd rather *not* above.
16:39:47 <vanila> I woud need to see more code
16:40:07 <glguy> > do { x <- Right 1; y <- Right 2; return (1+2) }
16:40:09 <ski> danking : oh
16:40:09 <lambdabot>  Right 3
16:40:12 <glguy> > do { x <- Right 1; y <- Left "whoops"; return (1+2) }
16:40:14 <lambdabot>  Left "whoops"
16:40:29 <danking> wow
16:40:56 <danking> Ok well. I have to go now but thanks for the tips guys.
16:41:02 <ski> danking : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> might be the earliest monad tutorial. it has `Maybe', but there's not a huge difference between it and `Either e'
16:41:13 <danking> ski: Thanks!
16:41:37 <ski> danking : if you don't want to manually CPS, but still want CPS effects, you have to use `Cont' or `ContT' or something similar
16:42:58 <ReinH> ski: So I've been thinking about nice presentations of "algebraic" Haskell and I think this one has potential. Using the group of symmetries of the square to reason about transforming the board for the game 2048 efficiently.
16:43:18 * ski doesn't know that game
16:43:57 <ReinH> ski: Ah. I won't link you since it might destroy your free time.
16:44:14 * hackagebot cblrepo 0.11.2 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.11.2 (MagnusTherning)
16:44:23 <ReinH> ski: suffice it to say that you can manipulate a grid in ways that involve needing to rotate and "unrotate" it to calculate the next game state
16:45:05 <ReinH> ski: basically depending on the direction, you rotate, perform an operation, and unrotate. The operation performed is always the same, but it is performed in different directions based on the rotation.
16:45:34 <ReinH> ski: so you've got this profunctorial thing that can be expressed quite nicely using group symmetries
16:46:27 <ion> CABAL is an acronym?
16:46:54 <ReinH> if R1, R2, R3 are the rotational symmetries, you want right = transform (inv R0) . go . transform R0. For down, you want transform (inv R1) . go . transform R1. And so on.
16:47:42 <ReinH> and since inv R0 is R0 and transform id is id that optimizes nicely to right = go
16:47:55 <ReinH> er transform R0 is id
16:48:23 <ski> ReinH : sounds related to group conjugation
16:48:28 <ReinH> ski: yep :)
16:48:42 <ReinH> ski: which is to say, I think so but I haven't gotten there yet
16:49:08 <ReinH> ski: so far it's just a nice example of using algebraic axioms to reason about and optimize Haskell code :)
16:50:01 <ReinH> since you can define, e.g., transform R3 in a more efficient (but provably equivalent way) than transform R1 . transform R1 . transform R1
16:51:30 <ReinH> so transform (inv R1) becomes transpose . map reverse instead of the naive transpose . reverse . transpose . reverse . transpose . reverse
16:51:50 <ReinH> and you can get Haskell to do that for you
16:55:44 <benzrf> sup yo
16:55:55 <benzrf> god damn i lost the game
16:58:30 <ski> ReinH : nice
16:59:05 <ReinH> ski: the main benefit being I don't have to remember in my head if I'm doing it correctly. I just check the laws.
16:59:26 <ReinH> and it's also exhaustively quickcheckable :)
17:00:04 <ReinH> since if it holds for grids of dimension 2 then it holds for grids of all dimensions :)
17:00:05 <ski> does QC know it's exhaustive ?
17:00:09 <ReinH> ski: no, but I do
17:00:24 <ReinH> at least I don't think it does
17:00:31 <ReinH> I don't know how it would verify that
17:00:37 <ReinH> uniformly
17:00:50 <enthropy> @hackage smartcheck
17:00:50 <lambdabot> http://hackage.haskell.org/package/smartcheck
17:00:51 <yitz> ion: Common Architecture for Building Applications and Libraries http://www.haskell.org/cabal/
17:00:57 <ReinH> enthropy: oh that might be a better choice
17:01:03 <ReinH> although I know the enumeration that I need to check
17:02:06 <ReinH> which is to say, I can just check on the value [[1,2],[3,4]]
17:02:10 <ReinH> and if it works there it works everywhere!
17:02:30 <ReinH> but I can't tell quickcheck or smartcheck that, I don't think
17:05:49 <ReinH> Heh, so I actually don't need quickcheck at all
17:08:18 <coppro> anyone here familiar with Aeson? How do I parse a sum type as "foo" or "bar"?
17:08:37 <coppro> just with return?
17:09:43 <platz> coppro: http://bitemyapp.com/posts/2014-04-17-parsing-nondeterministic-data-with-aeson-and-sum-types.html
17:28:39 <ion> yitz: TIL. Thanks.
17:29:52 <yitz> coppro: you can just use <|>
17:34:20 * hackagebot graphene 0.1.0.4 - A minimal Graph Theory library.  http://hackage.haskell.org/package/graphene-0.1.0.4 (5outh)
17:36:45 <yitz> coppro: e.g. fromJson (Object v) = Left (v .: "foo") <|> Right (v .: "bar")
17:38:40 <yitz> coppro: oops, sorry. more like this: fromJson (Object v) = (Left <$> v .: "foo") <|> (Right <$> v .: "bar")
17:40:11 <darthdeus> anyone knows what color scheme is this? https://github.com/dag/vim2hs/raw/master/screenshots/quasi.png
17:44:59 <coppro> yitz: ah, ok. Hmm... I'm not sure that's quite what I need here, but thanks
17:45:44 <coppro> Hrm... great. The corners I run into sometimes.
17:46:15 <coppro> are type contexts OK to get at a type family in the context?
17:46:39 <coppro> e.g. class Foo a where type Bar a; data (Foo a) => FooBar (Bar a)
17:46:55 <coppro> or are they still evil?
18:05:43 <tapuu> Why doesn't haskell have copatterns
18:05:51 <tapuu> They seem really useful
18:06:09 <Anne18>  Here some videos. I hope you like them! http://bitly.com/1gsfGYd
18:12:35 <coppro> actually what I really want is a way for a type family to have an associated constraint
18:16:04 <enthropy> coppro: "type family" is different from "data (Foo a) => FooBar (Bar a)"
18:17:04 <coppro> enthropy: I figured it out. I can put the constraint on the class
18:17:07 <enthropy> the latter (DatatypeContexts) doesn't help you write more programs than you can without it
18:17:10 <coppro> and that does what I want
18:17:41 <coppro> class (Show (Bar a)) => Foo a where type Bar a
18:17:49 <ski> ("help you write more programs than you can without" isn't everything, though)
18:18:52 <enthropy> yeah, in my opinion they kind of help with documentation
18:19:48 * ski isn't sure whether they like them or not
18:36:45 <scb> How can I apply a function over the first element of each tuple of a list? basically [(a, b)] -> [(c, b)]. I'm sure there must be a simple way I'm overlooking
18:38:15 <geekosaur> :t map . fmap
18:38:17 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
18:38:51 <geekosaur> @src (,) fmap
18:38:51 <lambdabot> fmap f (x,y) = (x, f y)
18:38:58 <geekosaur> oh crud
18:39:03 <scb> :(
18:39:13 <geekosaur> thought functor was on the first element?
18:39:26 <startling> > (+ 1) &&& id $ (1, 2)
18:39:27 * hackagebot dns 1.3.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.3.0 (KazuYamamoto)
18:39:28 <lambdabot>  No instance for (GHC.Show.Show t1)
18:39:28 <lambdabot>    arising from a use of ‘M428909641590693515401.show_M428909641590693515401’
18:39:28 <lambdabot>  The type variable ‘t1’ is ambiguous
18:39:28 <lambdabot>  Note: there are several potential instances:
18:39:28 <lambdabot>    instance [safe] GHC.Show.Show
18:39:33 <geekosaur> there is probably something arrowy
18:39:36 <startling> > ((+ 1) &&& id) (1, 2)
18:39:38 <lambdabot>  No instance for (GHC.Show.Show t1)
18:39:38 <lambdabot>    arising from a use of ‘M47768275556082500645413.show_M47768275556082500645...
18:39:38 <lambdabot>  The type variable ‘t1’ is ambiguous
18:39:38 <lambdabot>  Note: there are several potential instances:
18:39:38 <lambdabot>    instance [safe] GHC.Show.Show
18:39:50 <haasn> :t map . first
18:39:51 <lambdabot> (b -> c) -> [(b, d)] -> [(c, d)]
18:39:53 <startling> :t (&&&) -- ??
18:39:55 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:40:16 <startling> > (+ 1) &&& id $ (1, 2) :: (Int, Int)
18:40:18 <lambdabot>  Couldn't match type ‘(t0, t1)’ with ‘GHC.Types.Int’
18:40:18 <lambdabot>  Expected type: (t0, t1) -> (GHC.Types.Int, GHC.Types.Int)
18:40:18 <lambdabot>    Actual type: (t0, t1) -> ((t0, t1), (t0, t1))
18:40:26 <startling> > ((+ 1) &&& id) (1, 2) :: (Int, Int)
18:40:28 <lambdabot>  Couldn't match type ‘(t0, t1)’ with ‘GHC.Types.Int’
18:40:28 <lambdabot>  Expected type: (t0, t1) -> (GHC.Types.Int, GHC.Types.Int)
18:40:28 <lambdabot>    Actual type: (t0, t1) -> ((t0, t1), (t0, t1))
18:40:40 <haasn> geekosaur: That can't be the case because (,) :: * -> * -> * and Functor :: (* -> *) -> Constraint; so the only possible instance we can write without newtypes has the form Functor ((,) x) which means the variable is on the right
18:40:49 <startling> oh, I'm wrong about &&&
18:40:50 <scb> first is in Control.Arrow?
18:40:54 <haasn> scb: Yes
18:40:55 <startling> scb: yeah.
18:41:02 <geekosaur> :t (***)
18:41:03 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:41:10 <startling> geekosaur: ah, that's what I meant
18:41:12 <haasn> :t over (mapped._1)
18:41:13 <lambdabot> (Field1 a b a1 b1, Functor f) => (a1 -> b1) -> f a -> f b
18:41:18 <startling> > (+ 1) *** id $ (1, 2)
18:41:20 <lambdabot>  (2,2)
18:43:11 <scb> Another silly question is there an equivalent to concatMap for monads?
18:43:19 <scb> concatMapM perhaps?
18:44:59 <haasn> scb: What do you mean? Can you give a type signature?
18:45:18 <shachaf> Even concatMap isn't really justified.
18:45:26 * [ check this out ] *
18:45:31 <StoneCypher> ahahahahaha
18:45:36 * [ i can talk like this] *
18:45:38 <ReinH> Or you could use the _1 lens
18:45:42 <StoneCypher> how have i been on irc this long and never seen that before
18:45:45 * [ shit i lost a space ] *
18:45:53 <Guest49448> crud
18:45:59 <StoneCypher> benzrf: pro mode
18:46:05 <benzrf> :^)
18:46:10 <benzrf> sadly nick is registered
18:47:19 <ReinH> geekosaur: the Functor instance must be on (,) a to have the right kind :)
18:47:35 <benzrf> kinds!
18:47:40 <ReinH> Oh that was mentioned.
18:55:24 <ski> would you be so kind ?
18:58:27 <halvorg> If I have several tuples (Maybe a, Maybe b, Maybe c) and want make set of lists ([a],[b],[c]). How would I go about it?
18:58:53 <halvorg> unzip3 $ map (fmap  maybeToList)
18:58:56 <halvorg> or something like that?
18:59:17 <halvorg> :t maybeToList
18:59:18 <lambdabot> Maybe a -> [a]
18:59:30 <Hafydd> I don't think "set" is the word you want.
19:00:08 <halvorg> not set as in Data.Set
19:00:29 <halvorg> but as several lists
19:00:34 <ski> @type \(ma,mb,mc) -> (maybeToList ma,maybeToList mn,maybeToList mc)
19:00:36 <lambdabot>     Not in scope: ‘mn’
19:00:36 <lambdabot>     Perhaps you meant one of these:
19:00:36 <lambdabot>       ‘ma’ (line 1), ‘mb’ (line 1), ‘mc’ (line 1)
19:00:42 <ski> @type \(ma,mb,mc) -> (maybeToList ma,maybeToList mb,maybeToList mc)
19:00:44 <lambdabot> (Maybe a, Maybe a1, Maybe a2) -> ([a], [a1], [a2])
19:00:45 <enthropy> f :: [(Maybe a, Maybe b, Maybe c)] -> ([a],[b],[c]) -- or this?
19:00:52 <dmj``> > (\(a,b,c) -> (maybeToList a, maybeToList b, maybeToList c)) (Just 1, Nothing, Just [1..10])
19:00:56 <ski> hm
19:00:57 <lambdabot>  mueval-core: Time limit exceeded
19:01:02 <Hafydd> [[Maybe a, Maybe b, Maybe c]] -> [[a],[b],[c]] -- seems easier
19:01:25 <dmj``> @typ uncurry3
19:01:26 <lambdabot>     Not in scope: ‘uncurry3’
19:01:27 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
19:01:29 <ski> Hafydd ?
19:01:44 <Hafydd> Er... never mind. I sometimes forget that lists are homogeneous.
19:01:58 <dmj``> @def uncurry3 f ~(a,b,c) = f a b c
19:02:02 <lambdabot>  Defined.
19:02:23 <dmj``> oh, that's not it...
19:02:36 <ski> @let fst3 (a,b,c) = a; snd3 (a,b,c) = b; thd3 (a,b,c) = c
19:02:39 <lambdabot>  Defined.
19:03:20 <dmj``> @let over3 f (a,b,c) = (f a, f b, f c)
19:03:24 <lambdabot>  Defined.
19:03:36 <dmj``> > over3 maybeToList (Just 1, Just 3, Just 5)
19:03:39 <lambdabot>  ([1],[3],[5])
19:03:39 <ski> @type \ts -> (catMaybes (map fst3 ts),catMaybes (map snd3 ts),catMaybes (map thd3 ts))
19:03:40 <lambdabot> [(Maybe a, Maybe a1, Maybe a2)] -> ([a], [a1], [a2])
19:04:30 * hackagebot encoding 0.7.0.1 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.7.0.1 (DanielWagner)
19:04:45 <dmj``> @hoogle (a -> b) -> (a,a,a) -> (b,b,b)
19:04:47 <lambdabot> No results found
19:05:03 <halvorg> dmj``: isnt that just fmap? or am I wrong here
19:05:18 <dmj``> halvorg: fmap only works on the first element of a tuple
19:05:22 <halvorg> oh
19:05:24 <dmj``> > fmap (+1) (1,2)
19:05:26 <lambdabot>  (1,3)
19:05:29 <ski> dmj`` : last
19:05:31 <dmj``> I mean second :)
19:05:44 <ski> > fmap succ (0,0,0)
19:05:46 <lambdabot>  No instance for (GHC.Show.Show t1)
19:05:46 <lambdabot>    arising from a use of ‘M66677675158407398725870.show_M66677675158407398725...
19:05:46 <lambdabot>  The type variable ‘t1’ is ambiguous
19:05:46 <lambdabot>  Note: there are several potential instances:
19:05:46 <lambdabot>    instance [safe] GHC.Show.Show
19:06:09 <ski> @let instance Functor ((,,) a b) where fmap f (a,b,c) = (a,b,f c)
19:06:10 <dmj``> yea last is more correct
19:06:13 <lambdabot>  Defined.
19:06:14 <ski> > fmap succ (0,0,0)
19:06:17 <lambdabot>  (0,0,1)
19:07:58 <dmj``> over both (+1) $ (1,2)
19:08:02 <dmj``> > over both (+1) $ (1,2)
19:08:04 <lambdabot>  (2,3)
19:08:18 <dmj``> there's probably a lens that can do over 3 of em
19:13:09 <edwardk> > over each (+1) (1,2,3)
19:13:11 <lambdabot>  (2,3,4)
19:13:23 <edwardk> > (1,2,3) & each +~ 1
19:13:25 <lambdabot>  (2,3,4)
19:17:44 <dwcook> newtype Triple a = Triple (a, a, a) deriving (Functor)
19:18:07 <startling> or even data Triple a = Triple a a a deriving Functor. :)
19:18:11 <dmj``> edwardk: ah cool! :)
19:18:22 <startling> (there's also V3)
19:18:33 <dwcook> Sure, I just wanted to clearly show the idea of a restricted triple as functor
19:25:28 <benzrf> :t eachnnnn
19:25:29 <lambdabot> Not in scope: ‘eachnnnn’
19:25:31 <benzrf> :t each
19:25:32 <lambdabot> (Each s t a b, Applicative f) => (a -> f b) -> s -> f t
19:25:38 <benzrf> o:
19:26:15 <benzrf> > over each (++", ok") ["leave me alone", "get back to you", "ok"]
19:26:17 <lambdabot>  ["leave me alone, ok","get back to you, ok","ok, ok"]
19:26:32 <benzrf> > over each (++", ok") ("leave me alone", "get back to you", "ok", "go away")
19:26:34 <lambdabot>  ("leave me alone, ok","get back to you, ok","ok, ok","go away, ok")
19:26:36 <benzrf> neat
19:33:58 <ReinH> ski: holy crap I think I'm starting to understand algebra!
19:51:50 <Tekmo> ski: I found the language I was looking for
19:51:53 <Tekmo> ski: Idris
19:54:35 * hackagebot universe-instances-trans 1.0.0.1 - Universe instances for types from the transformers and mtl packages  http://hackage.haskell.org/package/universe-instances-trans-1.0.0.1 (DanielWagner)
19:57:10 <michaelt> Idris is, or will be, the language everyone is looking for, surely.
19:58:38 <benzrf> lol
19:58:58 <michaelt> Tekmo: I was just haskellizing and trying to figure out this 'space' problem from StackOverflow.
20:01:17 <platz> Idris has a pre-req on already knowing Haskell, it will be interesting to wait and see what happens
20:05:57 <Elton18>  You can find funny videos here. http://bit.ly/1jQzQMj
20:06:13 <benzrf> Elton18: spammer pls go
20:06:59 <rwbarton> can we just ban all usernames ending in 18
20:08:49 <Tekmo> michaelt: Which problem?
20:09:23 <Tekmo> The thing that blew me away at Idris was the compile-time computation
20:09:35 <Tekmo> I've been looking for that for so long
20:11:45 <michaelt> Tekmo: yes, the whole this is increasingly amazing. If I try a quasi practical program it doesn't usually run nearly as fast as a Haskell quasi equivalent, but that doesn't mean much
20:12:21 <michaelt> Tekmo: oh, I just noticed a Stackoverflow problem linked on the pipes mailing list.
20:12:29 <michaelt> mentioned rather
20:13:01 <Tekmo> michaelt: Oh, I thought I already answered that question, unless it's a different one
20:13:08 <michaelt> Tekmo, I meant, about Idris, 'the whole thing is increasingly amazing'...
20:13:39 <Tekmo> There was some question about a space leak and it turned out to be an issue in `pipes-aeson`
20:14:02 <ReinH> ski: ping
20:14:22 <michaelt> Tekmo: yeah I built the changed pipes-aeson, but there is still the quadratic problem with zoom it seems
20:14:56 <michaelt> Tekmo: or I guess it's the same quadratic problem that arose earlier.
20:15:21 <Tekmo> Oh, yeah, that problem will probably stay
20:15:28 <arthurz> Hi, is there a way to run a Haskell program like daemon/Windows Service (need to constantly watch for new files arriving)?
20:15:36 <Tekmo> The `zoom` issue requires a huge overhaul that greatly complicates the `pipes-parse` API
20:16:21 <michaelt> Tekmo: he is expect too much of pipes-parse, he should be applying some attoparsec thing directly to the producer. Or so it was seeming, I've only been investigating for 15 minutes
20:16:36 <michaelt> Tekmo: "he is expecting" rather
20:17:37 <michaelt> Tekmo, enough time to verify 'quadraticity' empirically.
20:19:05 <ReinH> Tekmo: DUDE
20:19:12 <Tekmo> ReinH: Hey
20:19:12 <edwardk> Tekmo: what is the issue?
20:19:22 <Tekmo> edwardk: One second
20:19:26 <edwardk> k
20:20:35 <Tekmo> edwardk: This is a `pipes-parse`-specific issue and not a `lens`, issue, but I'll still summarize it
20:20:49 <michaelt> Tekmo: oh the other test in his github repo just used view, fold max 0 id . view decoded on a big bytestring
20:20:51 <Tekmo> edwardk: Basically, this has quadratic time complexity: `forever (zoom id m)`
20:20:59 <Tekmo> edwardk: Oops, that's wrong
20:21:02 <coppro> I feel like there should be a function for this
20:21:09 <coppro> I have a (Monad m) => m (Maybe a)
20:21:11 <Tekmo> edwardk: But imagine a lens less trivial than `id` and then you get the quadratic time complexity
20:21:15 <edwardk> k
20:21:16 <ReinH> Tekmo: I am bothering you in pm please respond :p
20:21:21 <coppro> and a -> m b
20:21:31 <coppro> how do I get a m (Maybe a) -> m (Maybe b) out of this?
20:22:04 <benzrf> coppro: are you trying to write an MT
20:22:05 <Tekmo> michaelt: That was the `pipes-aeson` issue
20:22:10 <Tekmo> michaelt: Did you install the latest `pipes-aeson`?
20:22:16 <edwardk> coppro: mma >>= mapM f
20:22:18 <michaelt> Tekmo: yes
20:22:55 <michaelt> Tekmo: of course I may have messed something up.
20:22:57 <benzrf> edwardk: wheres the list
20:23:01 <coppro> edwardk: nope
20:23:18 <coppro> benzrf: I'm trying to use one without going through the extra work of using one since it's only for one line ;)
20:23:31 <dmj`> arthurz: new files arriving from where?
20:23:35 <benzrf> lol if u say so
20:23:36 <edwardk> coppro: are you using the correct mapM?
20:23:43 <edwardk> coppro you need the one from Data.Traversable not Prelude
20:23:48 <benzrf> edwardk: oh
20:23:57 <benzrf> bye yall
20:24:04 <edwardk> benzrf: that old mapM is dead to me ;)
20:24:16 <arthurz> dmj`: a SFTP process would dump 'em
20:24:24 <edwardk> mma >>= Data.Traversable.mapM f
20:24:43 <Tekmo> One thing still bothers me about Idris
20:24:52 <StoneCypher> its name?
20:24:59 <Tekmo> Ha
20:25:06 <edwardk> StoneCypher: the name is a cute reference to a dragon on a kids show
20:25:15 <StoneCypher> i ...
20:25:18 <StoneCypher> HNGGGGG
20:25:20 <StoneCypher> want to not like
20:25:21 <Tekmo> I would have preferred recursive data types to be represented as anamorphisms or catamorphisms
20:25:24 <StoneCypher> TREMENDOUSLY DIFFICULT
20:25:31 <edwardk> far more innocent than agda ;)
20:25:32 <Tekmo> That way it could fully take advantage of compile-time computation for optimization purposes
20:25:41 <StoneCypher> edwardk: i'll bite; do tell
20:26:04 <michaelt> I was irritated to find that out, Idris is also the arabic/Islamic name for the patriarch Enoch
20:26:20 <carter> StoneCypher: look up "agda the hen"
20:26:27 <StoneCypher> michaelt: why is that irritating?
20:26:37 <carter> its a song with some terrible puns on Coq
20:26:38 <edwardk> https://www.youtube.com/watch?v=zPY42kkRADc
20:26:46 <coppro> edwardk: much thanks
20:26:50 <dmj`> arthurz: could you open up a socket, have the other program listen. This way you wouldn't need to poll the file system. On successful SFTP dump send a msg.
20:27:01 <michaelt> StoneCypher: the cartoon dragon is irritating; a language named after the mysterious Enoch, I can approve of...
20:27:11 <StoneCypher> edwardk: i get the impression that i'm going to regret this
20:27:26 <edwardk> StoneCypher: it was named by Catarina Coquand in reference to that song as a bit of a joke about Coq.
20:27:45 <StoneCypher> does "cock" have the same dual meaning in that language
20:28:00 <carter> StoneCypher: listen to the song :)
20:28:06 <StoneCypher> am
20:28:07 <edwardk> no. but they are well aware of the discomfort it causes in other communities ;)
20:28:13 <StoneCypher> ah
20:28:42 <michaelt> I use Idris to avoid this moronic tide of double-entendres
20:29:40 <edwardk> and there is a bit of a 'which culture?' question going on with a swedish song and french coq reference ;)
20:29:49 <StoneCypher> huh.
20:30:10 <edwardk> michaelt: idris was named for a dragon that hatched inside ivor's boiler.
20:30:21 <edwardk> it _sings_
20:30:39 <michaelt> edwardk: yes I learned from the list
20:31:02 <arthurz> dmj`: the other program is not under my control
20:31:27 <michaelt> The dragon is named after Enoch from the book of Genesis though.
20:31:39 <nisstyre> someone should name a dependently typed language Elminster or something
20:31:43 <nisstyre> I would use that
20:31:48 <edwardk> https://www.youtube.com/watch?v=G5ZMNyscPcg&t=4m12s
20:31:56 <michaelt> nisstyre: a dependently typed Elm?
20:32:02 <nisstyre> and put drawings of wizards everywhere
20:32:07 <nisstyre> michaelt: idk, perhaps
20:32:19 <nisstyre> I just like the wizardry image
20:32:55 <dmj`> arthurz: this watches the filesystem: http://hackage.haskell.org/package/fsnotify
20:33:02 <nisstyre> dependently typed programming doesn't feel enough like casting spells
20:34:09 <michaelt> Haskell is more like casting spells.
20:34:13 <arthurz> dmj`: thx, but how to make it part of a WindowsService/Daemon?
20:35:34 <dmj`> arthurz: you need to explicitly hook into the win services api. This is what I use: https://hackage.haskell.org/package/Win32-services
20:35:50 <dmj`> there's a nice wrapper program for it too: https://hackage.haskell.org/package/Win32-services-wrapper
20:36:20 <dmj`> arthurz: it's a lot of cruft
20:36:59 <michaelt> Tekmo was the recommended repair to pipes-aeson supposed to fix one of his programs, the view decode one, but leave the other, with zoom decode in its state of baleful quadraticity?
20:38:58 <arthurz> dmj`: awesome, this is great, thanks a lot for your help
20:39:37 <dmj`> arthurz: np, good luck, let me know how it goes
20:40:57 <arthurz> dmj`: I am slow, LOL, thanks!
20:42:56 <nisstyre> What is a could infix symbol to represent unification? triple equal sign?
20:43:03 <nisstyre> s/could/good/
20:43:07 <nisstyre> >.>
20:43:47 <nisstyre> this is only for documentation btw
20:44:13 <dmj`> arthurz: this too: http://lpaste.net/104567, https://hackage.haskell.org/package/Win32-notify
20:46:17 <ReinH> nisstyre: ~ ?
20:46:39 <nisstyre> ReinH: oh derp, that would be a good one since GHC uses it to report errors too right?
20:46:53 <ReinH> I think so
20:47:01 <nisstyre> yeah ~ is good, thanks
20:47:19 <ReinH> no
20:47:34 <ReinH> np thanks autocorrect
20:47:38 <nisstyre> lol
20:47:47 <nisstyre> are you on your phone?
20:48:35 <ReinH> yep
20:48:46 <ReinH> Irccloud is win
20:49:07 <Tekmo> michaelt: It should have fixed both
20:49:16 <ReinH> oh I'm also on a plane fwiw
20:49:23 <Tekmo> michaelt: A single `zoom` will not trigger a quadratic time complexity
20:49:49 <michaelt> Tekmo, ah.
20:49:52 <cads> hey guys, are there any haskell based business process modelling, analysis, and execution/support systems?
20:50:16 <michaelt> Tekmo: I think I'm using the newly patched pipes-aeson and https://github.com/reuk/haskell-space-explosion
20:50:17 <Lutin`> ReinH: What airline?
20:50:29 <carter> cads: process modelling and analsysi for what?
20:50:48 <cads> general business processes, in the flavor of BPMN
20:50:58 <cads> but let me give a case example?
20:50:59 <carter> oh
20:51:01 <carter> you mean ERP?
20:51:03 <michaelt> Tekmo: it is quadratic in the length of the lazy ByteString that corresponds to the producer
20:51:05 <carter> or hwatever?
20:51:43 <cads> carter: BPMN and related disciplines are graphical ways of representing the order of steps that multiple actors must undertake to perform a business process
20:51:58 <carter> cads: ok
20:52:00 <carter> and?
20:53:06 <ReinH> Lutin`: Delta
20:53:27 <Tekmo> michaelt: Double-check that you have the latest `pipes-aeson` using `ghc-pkg list | grep pipes-aeson`.  It should be pipes-aeson-0.4
20:53:28 <dmj`> cads: if all you need are boxes and arrows you can use diagrams: http://projects.haskell.org/diagrams/gallery/SymmetryCube.html
20:53:39 <Lutin`> I wouldn't mind some free on-flight WiFi..
20:54:28 <cads> I'd like to be able to design business processes then automatically generate web pages or android apps that will interact with human agents for the parts of the process that cannot be fully automated
20:55:06 <cads> The input would be flow charts like this: http://blog.bpmn.info/wp-content/uploads/2008/10/chor1.png
20:55:50 <carter> cads: have you seen lgtk lib?
20:55:53 <carter> @hackage lgtk
20:55:53 <lambdabot> http://hackage.haskell.org/package/lgtk
20:55:58 <cads> and the output is a network of interactive programs that supports the agents
20:57:29 <cads> that's neat!
20:57:51 <michaelt> Tekmo, yes, I just compared pipes-aeson-0.3, which is in my main ~/.cabal, with pipes-aeson-0.4 , which is in my little pipes sandbox
20:57:59 <michaelt> Tekmo: the behaviour is the same
20:58:16 <Tekmo> michaelt: Give me a second.  I'm still compiling it
20:58:20 <carter> cads: it does some stuff interacting with diagrams
20:58:47 <michaelt> Tekmo: sorry, I didn't mean to be causing trouble! I'm looking at the revisions.
20:58:59 <cads> carter: I bet it could target android in time
20:58:59 <ReinH> Ah baggage claim we meet once again
20:59:19 <carter> sure... just requires cads  or someone to write that patch :)
21:00:04 <cads> god help any library that gets any of my code patched in :)
21:00:39 <chirpsalot> So, with a cabal sandbox... How do you actually tell cabal / GHC to use a specific one? Do you have to be in a subdirectory, or symlink the .cabal-sandbox/ directory? I think I am not understanding something :(.
21:01:01 <cads> I guess I might be selling myself short, but the idea of implementing the system I have in mind is really daunting
21:02:04 <cads> but the business process execution frameworks out there tend to be expensive to buy and more expensive to develop for, so maybe?
21:02:20 <carter> cads: only one way to find out
21:02:24 <carter> what would the ROI be for you?>
21:02:31 <carter> who uses thsi stuff
21:03:19 <cads> huge companies that can afford to model their business processes, and have processes that are of large enough scale and generate enough data that they can then use analytics
21:04:00 <cads> it's for the most part too expensive to use formal business process tech if you're not already a large company
21:04:14 <carter> same with math
21:04:21 <Tekmo> I mean, who at the company actually uses the software to model the business process?
21:04:29 <carter> that too
21:04:46 <cads> process engineers and analysts - it's an actual well defined discipline, with supporting organizations
21:05:12 <cads> hehe, I just made BS come out of my mouth...
21:05:25 <carter> :p
21:05:29 <carter> we need real infos
21:06:11 <cads> Lemme see if I can find case studies from IBM's business process framework
21:07:03 <Tekmo> michaelt: I found the problem
21:07:07 <Tekmo> michaelt: It wasn't a pipes issue
21:07:16 <Tekmo> I will upload a pull request to github showing my changes
21:07:33 <cads> carter, what I said wasn't false, but my actual exposure to how the technology is used in industry is small
21:07:44 <carter> fair
21:07:45 <carter> :)
21:08:20 <michaelt> Tekmo, oh what is it?
21:08:33 <Tekmo> michaelt: He was building up the bytestring all at once strictly
21:08:48 <Tekmo> michaelt: Once I replaced it with a lazy bytestring then the program runs in constant space
21:09:17 <michaelt> hm, just a sec
21:09:42 <cads> carter: anyways, I, a more or less inexperienced programmer and student of math, business and economics, have fallen in love with the idea of formally modelling the work and administrative processes that a business uses to make its revenue
21:09:55 <Tekmo> michaelt: Actually, I misspoke
21:10:00 <Tekmo> michaelt: But let me just upload the commit
21:10:02 <cads> on the one hand this means I'm /not/ going to get any investment
21:10:05 <Tekmo> michaelt: It will be clearer when you see the diff
21:10:19 <cads> and on the other hand, I don't want to target large companies
21:10:41 <cads> but instead to help small businesses automate tasks that currently happen with a lot paper shuffling
21:10:59 <cads> or happen without any record keeping or accountability at all
21:11:19 <cads> and I want to be able to do it on a charitable basis
21:12:40 <Tekmo> michaelt: Here's the diff: https://github.com/reuk/haskell-space-explosion/pull/1/files
21:12:53 <Tekmo> michaelt: I'll upload the profile images in just a second
21:13:24 <carter> neat
21:16:37 <Tekmo> michaelt: Here's the heap profile: https://github.com/reuk/haskell-space-explosion/pull/1#issuecomment-44111058
21:16:44 <Tekmo> michaelt: Now it runs in 5 KB constant space
21:50:41 <michaelt> ah, Tekmo vanished
21:51:55 <michaelt> @tell Tekmo Yes, and the time is now linear in the length of the string.
21:51:55 <lambdabot> Consider it noted.
22:10:18 <Adeon> what's up with the lens documentation on hackage
22:10:25 <Adeon> none of the modules have documentation
22:12:41 <glguy> Adeon: Just use the docs from 4.1.2
22:12:53 <glguy> There was an issue with some of the lens dependencies when I uploaded the package
22:12:56 <glguy> and hackage didn't build the docs
22:13:20 <Adeon> oh you can see them like that
22:13:23 <Adeon> this is revolutionary
22:13:29 <glguy> but the only thing that changed was a version upper bound
22:13:56 <Adeon> do you if that's also why hayoo doesn't seem to index lens at the moment
22:34:54 * hackagebot yesod-bin 1.2.9.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.9.4 (MichaelSnoyman)
22:49:30 <johnw> on the command-line, can I specify different --ghc-option values for libraries and for executables?
22:52:42 <johnw> that question was re: cabal
23:11:02 <fragamus> hey folks I have messed a bit with comonads but always in a way similar to that cellular automata example
23:11:04 <fragamus> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
23:11:18 <fragamus> now I want to do stuff with a graph
23:12:18 <fragamus> is there anyone out there that has done work with comonadic operations on graphs
23:12:38 <fragamus> plugh
23:30:31 <lispy> fragamus: maybe talk to edwardk? http://lpaste.net/24570
23:31:15 <fragamus> sweet!
23:31:24 <fragamus> thanks lispy
23:35:11 <lispy> fragamus: this also looks interesting and gives one example using graphs: http://www.cl.cam.ac.uk/~dao29/publ/codo-notation-orchard-ifl12.pdf
23:35:37 <fragamus> nice
23:40:01 * hackagebot language-c-inline 0.6.0.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.6.0.0 (ManuelChakravarty)
23:45:02 * hackagebot hoauth2 0.3.7 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.7 (HaishengWu)
