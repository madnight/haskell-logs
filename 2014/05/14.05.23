00:04:01 <jle`> hm. how do i use hex (which i think is a prism) on "15" to get something like "f"
00:07:03 <jle`> oh
00:07:17 <jle`> > "15" ^? hex
00:07:19 <lambdabot>  Just 21
00:08:03 * hackagebot fay 0.20.0.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.0.4 (AdamBergmark)
00:08:03 * hackagebot file-embed 0.0.7 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.7 (MichaelSnoyman)
00:08:23 <newsham> ?type (^?)
00:08:24 <lambdabot> s -> Getting (First a) s a -> Maybe a
00:08:30 <newsham> ?type hex
00:08:31 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
00:12:21 <jle`> oh wait that was backwards
00:13:40 <jle`> i remember seing a way to keep it inside the string
00:15:24 <kxra> would it be possible to create a http://explainshell.com/ for lines of haskell code?
00:17:05 <kazagistar> kxra: dunno if the documentation is quite there, but it might be possible to at least track types a bit or something...
00:19:23 <kazagistar> kxra: take this juicy line for example, how do you imagine it being explained? foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
00:20:22 <dmj`> kxra: that'd be interesting, I suppose you could have on hover the type and source of each function.
00:20:34 <dmj`> take replicate
00:20:37 <dmj`> @src replicate
00:20:38 <lambdabot> replicate n x = take n (repeat x)
00:20:58 <dmj`> then continue to dissect take and repeat, it'd be like a rose tree
00:21:34 <dmj`> @src appEndo
00:21:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:21:45 <dmj`> wtf how does lambdabot know my name
00:21:52 <kazagistar> how about as you mouse or click over each "atom", it shows you the type of that subexpression evaluated up to that point, and gives you more detailed documentation on that specific type?
00:22:12 <kazagistar> @src appEndo
00:22:13 <lambdabot> Source not found.
00:22:16 <kxra> a visual hierarchy representing the nesting would be cool too
00:22:24 <kazagistar> I am not as important I guess :P
00:22:40 <kxra> i just think this could be an invaluable tool to get more people learning haskell
00:22:49 <jle`> > "4e" & hex %~ (*2)
00:22:51 <lambdabot>  "9c"
00:23:16 <dmj`> jle`: how would lambdabot know my name
00:23:31 <jle`> it knows all
00:23:32 <kazagistar> dmj`: probably hardcoded by someone as a joke? :P
00:23:45 <jle`> (it's from space oddesy)
00:23:46 <dmj`> kazagistar: must've been lol :P
00:23:48 <jle`> odessy
00:24:02 <jle`> odyssey
00:24:11 <kazagistar> @src appEndo
00:24:12 <lambdabot> Source not found. Take a stress pill and think things over.
00:24:16 <kazagistar> ah I get it
00:24:32 <kazagistar> wittey random remarks, and the name was an accident
00:24:45 <jle`> https://www.youtube.com/watch?v=HwBmPiOmEGQ
00:24:58 <jle`> an explainshell for haskell would be neat
00:25:23 <jle`> i mean, haskell's syntax is well defined enough to be easy breakuppable
00:25:48 <kxra> it seems like there's a lot of interest
00:25:56 <kazagistar> also, jle`, if you actually care, http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-Monoid.html#Endo
00:25:58 <dmj`> jle`: hahaaha "affirmative Dave"
00:26:05 <kxra> the question is there someone(s) who can work on it
00:26:15 <jle`> kazagistar: hm?
00:26:20 <dmj`> kxra: you can!!!!!
00:26:31 <kxra> dmj`: don't have the skills sadly
00:26:35 <kxra> just starting to learn now myself
00:26:37 <kxra> hence the idea
00:26:43 <kazagistar> erm, I meant to dmj` oops
00:26:59 <dmj`> kxra: what a great way to learn haskell, by writing tools to help others learn haskell
00:27:21 <kxra> dmj`: hah, fair, but i'm supposed to be working full time on plugins-ng for GSoC
00:27:39 <kazagistar> I might take a look at it later myself, though the level of AST and compiler fiddling that might take seems scary
00:29:47 <dmj`> could represent each haskell expression as a graph
00:30:07 <kazagistar> not to mention some kind of frontend like a webserver to make it pretty, digging through documentation programmatically, etc
00:31:04 <kazagistar> ... time to dust off my D3 skillz?
00:31:59 <dmj`> kazagistar: if we had a graph database and each top-level function had links to the functions that it was defined in terms of
00:32:16 <dmj`> we'd have to manually populate it tho
00:33:04 <kazagistar> dunno, I was thinking more directly like explainshell
00:34:00 <kazagistar> like in your example, replicate n x = take n (repeat x)...
00:34:09 <alpounet> https://github.com/bmillwood/stepeval might be of interest
00:34:13 <dmj`> kazagistar: explainshell just looks up the man pages, for this we'd need a running version of ghc
00:35:43 <kazagistar> if you moused over "n", it would show you that n is a Int, and take n is an [a] -> [a] function, and maybe "take n, applied to a list xs, returns the prefix of xs of length n, or xs itself if n > length xs:" and "click here for source"
00:36:29 <dmj`> kazagistar: but it also syntax checks, so we'd need both, a way to retrieve the source and type check user expressions
00:37:18 <dmj`> kazagistar: that sounds just like haddocks
00:37:38 <kazagistar> I copied that comment from there, presumably I would just look it up
00:38:08 <kazagistar> the idea was to explain full haskell expressions consisely on one page, right?
00:39:36 <dmj`> kazagistar: basically haddocks, but sexier since it'd be interactive
00:40:22 <kazagistar> sexier and more convenient, cause it is all in one place
00:41:15 <kazagistar> though, what might be interesting is "documentation for expressions at different levels of currying", though I am going to have to think about that one
00:42:31 <dmj`> i dunno, I say start small w/ source code pop-ups for functions. Just try to make it work w/ prelude only first
00:43:21 <dmj`> im out
00:43:31 <kazagistar> I mean sure, this is something I might get time to do in like a month at the earliest if I were to give it a go
00:44:54 <kazagistar> I still have to figure out how to use lens and zipper and fingertrees to finish one project, and do some reverse regular expression matching  for another
00:55:14 <ski> @where stepeval
00:55:14 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
00:55:36 <ski> @where+ stepeval <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
00:55:37 <lambdabot> Done.
00:55:41 <exicer_> I am experiencing cabal woes.. ran cabal update in my sandbox, now nothing works ;(
00:56:05 <exicer_> Presumably some of my constraints in build-depends were just too lenient ?
00:56:28 <bitemyapp> exicer_: use lpaste to show the build error
00:56:36 <bitemyapp> exicer_: how'd you install Haskell?
00:56:46 <ski> @paste
00:56:46 <lambdabot> Haskell pastebin: http://lpaste.net/
00:57:03 <exicer_> bitemyapp: Hm, I think via homebrew
00:57:28 <exicer_> to be honest, I probably should have spent more time understanding cabal
00:57:29 <exicer_> http://lpaste.net/104502
00:57:33 <yogurt_truck> where could I search for the cause of a "collect2: error: ld returned 1 exit status" error while installing with cabal? https://groups.google.com/forum/?fromgroups#!topic/elm-discuss/OY3xWaCAP6M
00:58:14 <akurilin> What's the right package to use if I want to play around with a UTCTime and get things such as "beginning of month", "beginning of day" etc? Thyme?
01:01:18 <supki> exicer_: could you try with --constraint="transformers < 0.4" ?
01:04:14 <exicer_> supki: This is the result: http://lpaste.net/104503
01:05:15 <supki> interesting, for some reason cabal does not try to flip -three flag
01:06:34 <exicer_> what is that ?
01:07:41 <supki> the flag in transformers-compat that chooses which transformers to depend on:  http://hackage.haskell.org/package/transformers-compat-0.3.3/transformers-compat.cabal
01:08:13 <exicer_> ah
01:08:48 <exicer_> Any idea how I should go about solving this ?
01:09:40 <supki> at this point I would first install transformers-compat with -fthree, then try to install mailcapture again
01:10:19 <exicer_> cabal install transformers-compat -three ?
01:10:33 <exicer_> ah no, fthree
01:10:43 <supki> probably there's a clever combination of cabal options to convince it to use three automatically
01:13:10 <bergmark> exicer_: cabal install foo --constraint="transformers-compat +two" or +three
01:13:20 <bergmark> not sure which you want
01:14:16 <exicer_> Ok, so that gives a new error: http://lpaste.net/104504
01:14:57 <bergmark> exicer_: try without any constraints and with --reorder-goals
01:16:33 <bergmark> exicer_: or maybe there just isn't a valid build plan
01:16:35 <exicer_> http://lpaste.net/104505
01:16:43 <exicer_> bergmark: In that case.. what do I do ?
01:16:55 <exicer_> Find the problem package and update it ?
01:17:02 <bergmark> is mailcapture your own package?
01:17:06 <exicer_> yeah
01:17:26 <exicer_> It was working prior to my updating cabal
01:17:39 <exicer_> so presumably there must be some valid combination of packages
01:17:48 <bergmark> ah well i see it now
01:18:02 <bergmark> snaplet-persistent needs lens <4.1 and wreq needs >4.1
01:18:16 <exicer_> hmm
01:18:24 <bergmark> so you can try to build anyway with --allow-newer=lens
01:18:48 <exicer_> that..seems to have worked
01:19:06 <bergmark> ok, then you can send a PR to snaplet-persistent with the dependency bumps, or just open an issue
01:19:28 <exicer_> Cool, will do it later this weekend.
01:20:32 <bergmark> exicer_: this seemed like the recent cabal bug because of transformers-compat being involved https://github.com/haskell/cabal/issues/1855 but it wasn't :-)
01:23:06 * hackagebot tls 1.2.8 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.8 (VincentHanquez)
01:23:22 <exicer_> bergmark: I see. Well thanks for your help, anyway :)
01:28:06 * hackagebot tls-debug 0.3.4 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.4 (VincentHanquez)
01:37:53 <Itkovian> jle` nice blog post (the inside my world one)
02:03:25 <BoR0> I'm trying to write a pubsub like service in haskell using sockets. I have a list of connection handles that's in my socket accept loop. how can I pass this same list to all forkIO'd context? not sure if this makes any sense or it's the right way to do it
02:04:48 <BoR0> basically I somehow need a global variable that will be modified (when subscribing) and visible to all connections
02:05:16 <Rembane> BoR0: MVar or something like that. This page has some quite nice resources https://www.haskell.org/haskellwiki/Concurrency I think Tackling the Ackward Squad is the best of them.
02:05:19 <BoR0> I looked at Network.Socket.ByteString.sendAll but this won't do it for me
02:05:42 <BoR0> ok, I'll check that out. thanks
02:05:50 <Rembane> No worries.
02:06:34 <bergmark> BoR0: i usually run everything in a ReaderT containing stm variables
02:07:50 <BoR0> I don't have any experience with ReaderT so I'll have to check that out as well :)
02:09:52 <bergmark> BoR0: you can start out with just passing this as arguments, and if that becomes bothersome switch to ReaderT
02:15:06 <deni> is using code generations tools like TH and Generics frowned upon? I mean, on one hand i'm happy that i don't have to write a massive amount of boilerplate code...but on the other hand i'm kinda worried that it's a bad idea to generate code like that....feels bad like when java was generating js and such nonsense
02:15:11 <Yuu_chan> Please help me with transformers. I wrote http://lpaste.net/104507 and feel that I'm doing it wrong.
02:15:28 <deni> (i have no understaing how those tools work internally mind you, just asking for advice)
02:16:28 <Yuu_chan> I thought that a wrapper monad (List in this case) doesn't need some explicit things, but simple hour <- [0 .. 24] doesn't compile
02:20:28 <ski> ugh, `ListT' on a non-commutative monad (`IO')
02:20:52 <ski> @wiki ListT done right
02:20:52 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
02:24:28 <bernalex> what do I need to do in my cabal file when I want to make a release of my package (and eventually put it on hackage)?
02:24:47 <bernalex> (if anything)
02:24:54 <ski> Yuu_chan ^
02:25:11 <bernalex> I kind of assume I'm supposed to use tag in some way
02:26:06 <Yuu_chan> ski: I saw that page, but I don't want to reimplement it! >_>
02:26:37 <supki> bernalex: nothing; to make a release you run  cabal sdist  which gives you a tarball to upload to hackage
02:27:00 <Yuu_chan> In fact, non-commutativity doesn't matter in my case
02:27:07 <bernalex> supki: really? you're not supposed to have e.g. a commit hash for the release listed? I mean, I have that anyway via git, but that's odd to me.
02:33:59 <merijn> bernalex: Hackage is way less secure than you're thinking
02:34:46 <bernalex> merijn: maybe. It seemed obvious to me.
02:35:44 <bernalex> merijn: then again I was completely shocked when I learned that git doesn't let you pgp-sign/encrypt your email, and that darcs has no way of pgp-signing anything in its patchwork. :-]
02:38:01 <bernalex> haddock question: https://secure.plaimi.net/works/plailude/doc/ how do you make it not be like that? :-P
02:38:20 <bernalex> all the module descriptions for all my packages are into the module name. so "FooThe Foo package does blah"
02:42:40 <ski> you mean the module name is written directly next to the description, with no intervening space ?
02:45:35 <bernalex> ski: yes
02:46:10 <BoR0> bergmark, can you explain? I want to try first by passing arguments
02:46:33 <BoR0> bergmark, here's what I have so far http://lpaste.net/2077569440211271680
02:47:21 <KorriX_> Hello. Is there any way to define class instance for something which is a type family instance?
02:47:24 <teneen> Is it possible to read a Data.Text value to a [Int] without creating an intermediate string?
02:48:30 <KorriX_> i have type family Diff. And type instance Diff ByteString = ByteString. I would like to define instance Monoid (Diff ByteString) - is it possible?
02:51:06 <bergmark> BoR0: start out with something like data Vars = Vars { var1 :: TVar Foo } that you initialize in main, then pass it around
02:51:56 <BoR0> I tried it with a list. but user 1 gets [], user 2 gets [user1Handle], user 3 gets [user2Handle, user1Handle] when I pass that same list to forkIO
02:52:12 <BoR0> say I want to pass the handle only
02:52:29 <BoR0> er, the list of handles*
02:55:14 <bergmark> BoR0: don't pass the list directly, pass a TVar containing the list
02:55:17 <merijn> KorriX_: It is possible if your type family instance is fully defined
02:55:24 <BoR0> bergey, what's a TVar ?
02:55:29 <BoR0> bergmark, *
02:55:39 <bergmark> it's a thread safe variable
02:55:54 <KorriX_> merijn: What does it mean?
02:55:57 <merijn> KorriX_: So, suppose you have "Foo :: * -> * -> *" then "instance MyClass (Foo Int Char) where" is valid, but "instance Functor (Foo Int) where" is not
02:56:29 <teneen> Is it possible to read a Data.Text value to a [Int] without creating an intermediate string?
02:56:33 <merijn> KorriX_: Basically, you can't have partially applied type families as those are equivalent to type level lambda's which break Haskell's type system in nasty ways
02:56:49 <merijn> teneen: Well, which Int values are you expecting?
02:57:38 <merijn> AFAIK it's not even guaranteed every unicode codepoint will fit into an Int
02:57:39 <teneen> merijn: what do you mean?
02:57:39 <KorriX_> but I'm fully applying my type family and ghc complains: Illegal type synonym family application in instance: Diff ByteString In the instance declaration for ‘Monoid (Diff ByteString)’
02:58:15 <merijn> KorriX_: hmm, that's odd, that should work afaik. Do you have a minimal paste of the code?
02:58:23 <teneen> merijn: I just want an efficient counterpart to read :: String -> [Int]
02:58:39 <merijn> teneen: Right, that's an utterly different problem :)
02:59:01 <merijn> teneen: So you want to parse comma-separated sequences of digits and turn those into numbers?
02:59:07 <Yuu_chan> n00b question: how to truncate Double into Float?
02:59:22 <ski> bernalex : i've also been annoyed by that. unfortunately, i don't know how to tell Haddock to avoid doing that
02:59:24 <merijn> Yuu_chan: I don't think there is a Float type
02:59:25 <ivanm> juhp: you around?
02:59:27 <teneen> merijn: yes, efficiently without using Strings
02:59:31 <ivanm> @hoogle Double -> FLoat
02:59:31 <ski> @kind Float
02:59:33 <lambdabot> Did you mean: Double -> Float
02:59:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:59:33 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
02:59:34 <merijn> teneen: Take a look at attoparsec
02:59:34 <lambdabot> *
02:59:39 <ivanm> @hoogle Double -> Float
02:59:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:59:39 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
02:59:39 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
03:00:02 <ski> @type realToFrac :: Double -> Float  -- Yuu_chan
03:00:03 <lambdabot> Double -> Float
03:00:05 <ski> @type realToFrac
03:00:06 <lambdabot> (Real a, Fractional b) => a -> b
03:00:08 <teneen> merijn: great I'll loock into it
03:00:11 <merijn> teneen: Attoparsec has a set of parser that work directly on Text
03:00:21 <Yuu_chan> ski: thank you!
03:00:34 <KorriX_> merijn: http://lpaste.net/104508
03:00:35 <ski> Yuu_chan : i assume you already know about `fromIntegral'
03:00:53 <Yuu_chan> ski: yes :)
03:00:58 <ski> @type fromIntegral :: Int -> Integer
03:01:00 <lambdabot> Int -> Integer
03:01:11 <ski> @type fromIntegral :: Integer -> Int32
03:01:13 <lambdabot> Integer -> Int32
03:01:14 <ski> @type fromIntegral
03:01:15 <lambdabot> (Num b, Integral a) => a -> b
03:01:33 <Yuu_chan> merijn: what do you mean by "there is no Float type"?
03:03:33 <merijn> Yuu_chan: Like I said, I wasn't sure there was a Float type, but turns out I'm wrong
03:03:51 <merijn> KorriX_: hmm, odd, I'm not sure enough about the details to see what you can do to fix that
03:06:02 <KorriX_> merijn: Thank you :)
03:07:04 <nebnesknarf> Hi there, anyone here who might be able to help me with a lens problem?
03:08:08 <nebnesknarf> I am trying to use C.L.TH.makeFields but it doesn't produce anything
03:08:12 <juhp> ivanm, yes
03:08:56 <ivanm> juhp: with Fedora packages, is it possible to have a live package? specifically, a version of xmonad (and contrib) that pulls from darcs and refreshes regularly (say weekly)
03:09:07 <ivanm> I'm used to source-based distros where this is definitely possible :p
03:09:14 <ivanm> nebnesknarf: #haskell-lens ?
03:09:23 <juhp> live package, hmm
03:09:34 <juhp> ivanm, I think short answer is no :)
03:09:39 <nebnesknarf> ivanm: thanks, I'll ask there
03:09:48 <ivanm> juhp: yeah, that's what I figured :)
03:10:13 <juhp> ivanm, but scripts a rebuild should not be hard
03:10:19 <juhp> scripting
03:10:23 <ivanm> *nod*
03:10:48 <juhp> maybe it could be an rfe for cabal-rpm
03:11:42 <juhp> ivanm, even with gentoo it is manual update no?
03:12:03 <ivanm> well, at least when using paludis, you can tell it to rebuild scm packages weekly
03:12:08 <juhp> ah okay
03:12:09 <ivanm> (or daily, monthly, etc.)
03:12:14 <juhp> fair enough
03:40:39 <maybefbi> ParahSailin, didn't know you were into haskell as well
03:48:58 <BoR0> @pl (\x -> snd x == "")
03:48:58 <lambdabot> ([] ==) . snd
03:49:02 <BoR0> @pl (\x -> snd x == "a")
03:49:02 <lambdabot> ("a" ==) . snd
03:50:36 <bajtek> interesting, a lot of people joining, and not much talk going on
03:53:20 <Geraldus> I assume this is because of absence of questions. :)
03:53:30 * hackagebot websockets 0.8.2.3 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.3 (JasperVanDerJeugt)
04:02:51 <akegalj> can i somwehow convert Int64 to Int?
04:03:13 <hpc> :t fromIntegral
04:03:14 <lambdabot> (Num b, Integral a) => a -> b
04:03:41 <hpc> the usual warning about the size of Int, etc etc
04:09:00 <akegalj> hpc: thnx, i'm sure it will be 64 bit int on that machine
04:09:55 <bajtek> hm, while we're at questions then, is there a "standard" way to structure modules that are an inner part of a library, but are not exported?
04:10:33 <identity> bajtek: I see "LibraryName.Internal.Foo.Bar" often
04:10:37 <identity> and have used it myself, when appropriate
04:10:43 <identity> if that's what you're referring to
04:11:16 <bajtek> identity: yeah, something like that. So just "Internal"
04:11:49 <bajtek> I presume there's a way to tell Haddock to skip those
04:13:44 <merijn> akegalj: Realise that Int is only guaranteed to be 28 (or was it 30? I forget...) bits, everything beyond that is implementation dependent (which does not matter that much, given the fact that the implementation is basically always GHC, but still!)
04:14:08 <merijn> bajtek: It's simpler, actually
04:14:28 <merijn> bajtek: Your cabal file specifies which modules are exposed, unexposed modules should not have documentation generated
04:14:50 <bajtek> merijn: oh, even better then.
04:14:55 <merijn> bajtek: People usually only use Internal if the module is exposed but internal
04:15:15 <merijn> bajtek: i.e. stuff like ByteString that wants to expose unsafe internals for library authors to do unsafe things for high performance
04:15:32 <bajtek> merijn: ah, was going to ask what purpose would that server
04:15:33 <merijn> bajtek: If you don't expose the module there is no particular reason to name it "Internal"
04:16:00 <merijn> bajtek: The implication being that anything labelled "Internal/Unsafe" is not portable, reliable, etc.
04:16:17 <bajtek> merijn: I see.
04:17:23 <akegalj> merijn: oh, didn't know that. thnx. It will be for small ints ( < 100 ) so it will be safe enough. thanks
04:27:55 <BoR0> @src lift
04:27:55 <lambdabot> Source not found. There are some things that I just don't know.
04:27:57 <BoR0> @src liftM
04:27:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:29:17 <BoR0> how can I achieve something like this? "publish"   -> (hPutStrLn h "p") >> Just s          i.e. transform IO to maybe
04:30:18 <lieven_> you can't safely escape from IO
04:33:24 <zwer> why is 1e6 fractional instead of Num?
04:33:28 <zwer> :t 1e6
04:33:29 <lambdabot> Fractional a => a
04:35:41 <merijn> zwer: Because Num doesn't accept that notation
04:35:55 <merijn> zwer: 7.8 has an extension that allows it for Num too, but it's not standard
04:37:55 <zwer> merijn I was interested in reasoning for making that notation a Fractional instead of Num
04:38:15 <merijn> zwer: Probably "No one realised that might be useful"
04:39:20 <holzensp> zwer: methinks it's mostly because it's "standard" to only use exponent-notation for floating point types
04:40:00 <holzensp> zwer: If you look at the grammars of other languages (C, Matlab, VHDL, etc.) you'll see that 1e6 will be considered a floating point literal
04:40:23 <holzensp> (leaving room for choice between, e.g. float or double)
04:40:30 <zwer> holzensp yeah, and 1 in those languages is usually an int or similar
04:40:49 <zwer> anyway, I tried to do threadDelay 1e6. no big deal, but I was surprised it didn't work
04:40:57 <holzensp> yes; basically, the integer types were typically too limited to warrant exponent notation
04:41:51 <tremon> that's more because of "no implicit coercion" than "1e6 is Fractional" though
04:42:19 <zwer> if 1e6 was Num a => a it would work
04:42:20 <merijn> tremon: The point is that there is no reason for "1e6" to require coercion
04:42:40 <merijn> 1e6 is perfectly unambiguous as an Integral value
04:42:51 <merijn> Also, as I pointed out, 7.8 should be able to do this with an extension
04:42:53 <holzensp> tremon: coercion comes only after a type was chosen
04:43:03 <holzensp> any integer literal is (fromInteger x) anyway
04:43:11 <holzensp> same for exponent things
04:43:13 <holzensp> fromRational
04:43:25 * holzensp afk
04:44:40 <tremon> I understand, just pointing out that msleep(1e6) in C works because of implicit coercion, regardless of which base type is "interpreted" for the literal
04:49:09 <identity> Sometimes I really wish Java had ADTs.
04:58:45 <pavonia> Using Text.PrettyPrint.Boxes, is it somehow possible to overlay two boxes or the same size?
04:59:16 <pavonia> Or even of different sizes
05:00:00 <pavonia> I guss the move* functions might be helpful, but from the documentation I don't understand how to use them properly
05:01:15 <Tjr> Hi everybody.
05:01:15 <Tjr> I've got an elementary question, trying to understand some example code. Are such discussions appropriate here?
05:01:59 <bajtek> Tjr: I see no reasons why they shouldn't,
05:02:13 <Tjr> It's from http://bartoszmilewski.com/2014/05/05/understanding-products-and-universal-constructions/
05:02:22 <Tjr> The line "churchToPair f = f (\x y -> (x, y))"
05:02:48 <Tjr> which should be the inverse to "pairToChurch (x, y) = \g -> g x y"
05:03:19 <Tjr> In the churchToPair line, I don't understand where the second argument to f goes.
05:03:36 <bajtek> Tjr: to be fair... that's hardly elementary. Formal category theory isn't something a lot of people learn.
05:04:14 <Tjr> bajtek: oh, sorry.
05:04:37 <bajtek> Tjr: don't be. Anyway, isn't it just point-free basing on f?
05:04:50 <Tjr> Now you're over my head.
05:05:09 <bajtek> c f x = f (\...) x     =>   c f = f (\....)
05:05:22 <Tjr> I'm just reading up on haskell, I did the tutorial "learn haskell the hard nad fast way"
05:06:01 <ZettaBlade> Basing?
05:06:12 * Tjr thinks about bajtek's answer.
05:06:13 <bajtek> poor wording on my part, I guess.
05:06:25 <ZettaBlade> Like, making f the, uh, primary object?
05:07:16 <Tjr> Say I have this ChurchPair: "\g -> g x y"
05:07:33 <bajtek> ZettaBlade: I've no idea what a primary object is. It just looked like stripping the 2nd argument from churchToPair.
05:07:36 <Tjr> Then I stick it into "churchToPair f = f (\x y -> (x, y))"
05:07:41 <vlads> how does lambdabot's `@check' work? because it gives some strange things:
05:07:42 <vlads>  @check (\ x y -> x == y)
05:07:54 <vlads> @check (\ x y -> x == y)
05:07:56 <lambdabot>  +++ OK, passed 100 tests.
05:08:34 <ski> @check \x y -> x == (y :: Bool)
05:08:36 <lambdabot>  *** Failed! Falsifiable (after 1 test):
05:08:36 <Tjr> And I end up with "(\g -> g x y)  (\u v -> (u, v))"
05:08:36 <lambdabot>  False True
05:08:46 <ski> vlads : it defaulted to `()'
05:09:20 <Tjr> However, in my naive attempt, the anonymous funciton "\g -> g x y" is passed only one argument, instead of the two it needs. What am I doing wrong?
05:09:55 <ski> Tjr : it needs one argument
05:10:20 <bajtek> Tjr: again, point-free style
05:10:31 <bajtek> it gets partially applied on the second lambda
05:10:52 <bajtek> oh wait, maybe I am dumb here / can't read
05:11:11 <Tjr> it gets partially applied, wouldn't that mean the conventional pair "(u,v)" is produced only after it's applied to yet another argument?
05:11:45 <bajtek> yes, you're right; I misread the signature of churchToPair
05:11:50 <ZettaBlade> bajek: thought you were explaining point-free style, something I haven't really learned about to in-depthly.
05:12:51 <bajtek> full point-free style is a complete eta-reduction, I guess there's not much more about it.
05:13:10 <Tjr> ski: Hmm, I don't understand. The signature is "churchToPair :: ChurchPair a b -> (a, b)". I'd read that as two arguments.
05:13:37 <ski> Tjr : the one argument to `churchToPair' has the type `ChurchPair a b'
05:13:51 <Tjr> ski: ahhh, thank you.
05:14:04 * Tjr thinks.
05:14:15 <ski> Tjr : `\g -> g x y' itself further takes one argument
05:14:38 <ski> Tjr : `churchToPair' applies it (under the name `f') to one argument
05:16:12 <Tjr> `churchToPair' applies it (under the name `f') to  (ChurchPair a b). So how are the three things "ChurchPair a b" and the two things "x y" matched up?
05:16:56 * Tjr is stuck, probably wide beside the road in the mud.
05:17:19 <ski> Tjr : "`churchToPair' applies it (under the name `f') to  (ChurchPair a b)" -- no
05:17:35 <ski> `f' in the definition of `churchToPair' has type `ChurchPair a b'
05:17:46 <ski> `ChurchPair a b' is the type of one single thing
05:18:18 * Tjr thinks.
05:18:22 <ski>   type ChurchPair a b = forall c. (a -> b -> c) -> c  -- is probably the definition of `ChurchPair a b'
05:18:25 <mm_freak> hi there
05:18:41 <mm_freak> has anyone ever used a right scan?
05:18:58 <ski> `churchToPair' applies `f' to `\u v -> (u, v)', which is one single thing
05:18:58 <Tjr> ski: I took that as the type of ChurchPair.
05:19:29 <ski> Tjr : no, `ChurchPair a b' itself is a type. that declaration gives what type this type is defined to be equal to
05:20:26 * Tjr thinks.
05:20:41 <ZettaBlade> Eta reduction is sexy, and confirms my idea of how point free works. I don't get why it's called point free is, but I get that point free style has variables removed.
05:20:58 <mm_freak> i'm writing an API for which a right scan is really awkward to write, so if nobody uses it anyway, i'll just omit it
05:21:37 <merijn> ZettaBlade: "points" refers to names (i.e. variables)
05:21:59 <merijn> mm_freak: I would just omit it until someone complains :p
05:22:17 <merijn> mm_freak: Assuming you can omit/add it independently from everything else
05:22:25 <zwer> how can I programatically close a window in gtk2hs?
05:22:40 <Tjr> ZettaBlade: http://www.haskell.org/haskellwiki/Pointfree claims the name is from point-free topology, a branch of topology where they try to eliminate variables alltogether
05:22:43 <ZettaBlade> merjin: Then functions would just be lines?
05:23:25 <mm_freak> merijn: that's what i thought, and yes, i can add it at any point in time
05:23:39 <mm_freak> i just want to provide a more or less complete list-like interface
05:23:47 * hackagebot plailude 0.1.0 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.1.0 (alexander)
05:23:51 <ski> merijn : i thought it primarily referred to elements
05:24:58 <ski> mm_freak : perhaps you could write a documentation line saying that a right scan would be possible, but that you haven't done it yet because of laziness
05:25:05 <ski> (or something like that)
05:25:27 <vlads> ski: that makes sense, thank you
05:25:35 <mm_freak> "because of laziness", yeah =)
05:25:54 * ski grins
05:28:49 <canta> what am I doing wrong if I cannot get rid of 'Expected Type: B.ByteString' 'Actual Type: bytestring-0.10.0.2:Data.ByteString.Internal.ByteString'?
05:29:40 <tremon> canta: check lazy vs strict bytestrings, that's what bit me last time
05:29:41 <Jeanne-Kamikaze> lazy vs strict ?
05:29:44 <merijn> canta: Looks like you're linking two different versions of the bytestring package into your executable
05:29:59 <merijn> That or lazy vs strict
05:32:09 <canta> I try to run this example: https://github.com/anchor/rados-haskell/blob/master/examples/monadic_read_write.hs I already tried adding Lazy do the import line with no success. That double linking could be the issue though.
05:32:22 <Tjr> ski: I think I understood now how "churchToPair pairToChurch" evaluates:
05:32:45 <Tjr> ski: "f (\u v -> (u, v))", "(\g -> g x y)  (\u v -> (u, v))", "(\u v -> (u, v)) x y", "(x, y)". Right?
05:33:13 <ski> Tjr : yes
05:33:39 <Tjr> ski, bajtek thank you.
05:35:11 <canta> ah it works after ghc-pkg unregister, thanks. I definitely need to learn how to properly manage dependency issues
05:36:50 <bergmark> canta: if you use cabal you won't run across that problem
05:38:38 <wunki> I there a command in GHCI which tells me which typeclasses a type is part of?
05:38:54 <merijn> wunki: :i will tell you the instances that are in scope
05:38:58 <benzrf> wunki: :i
05:39:14 <wunki> thanks!
05:42:50 <osa1> http://lpaste.net/104514
05:43:33 <osa1> should I report this or is this known?
05:59:41 <Maior> argh http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9
06:00:15 <Maior> does anyone know where the wrapper source went?
06:00:30 <bajtek> doesn't Haskell have its own CPP already?
06:01:14 <geekosaur> sort of
06:01:16 <geekosaur> license issues
06:01:37 <geekosaur> http://is.gd/H4sEub as per the /topic
06:01:57 <Maior> ...sorry, my bad
06:02:03 <Maior> cheers
06:11:53 <wunki> anyone read this piece by Julia Evans: http://jvns.ca/blog/2014/05/12/computers-are-fast/ ?
06:12:19 <wunki> just for kicks, I'm trying to do the same in Haskell
06:13:02 <wunki> currently on 18s for a 1GB file
06:13:27 <wunki> https://gist.github.com/wunki/13535b7f02993c65732d
06:23:39 <eizo> wunki: 18s this is a bit sad
06:30:15 <rien> I'm trying to cabal install aeson-0.7.0.3 and I keep getting this error: http://lpaste.net/104515
06:30:53 <yactmp> I have sometimes problems defining lists in IO monads
06:31:03 <yactmp> let xs = [ "fooo"\n, "bar" ]
06:31:16 <yactmp> I'm getting syntax errors, any idea why? What can I do about it?
06:31:27 <simukis_> let xs = ["fooo\n", "bar"] in print xs
06:31:36 <simukis_> your \n is outside the string.
06:31:50 <yactmp> simukis_: it is a newline in the source genius
06:33:22 <suppi> yactmp, then maybe you need to align spaces right
06:34:17 <ski> yactmp : paste your exact code ?
06:34:22 <geekosaur> @lpaste
06:34:23 <lambdabot> Haskell pastebin: http://lpaste.net/
06:34:51 <ski> @help lpaste
06:34:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:35:13 <geekosaur> it's actually @paste, I'm abusing edit correction :p
06:35:25 * ski noticed
06:37:43 <yactmp> ski: https://gist.github.com/yaccz/dfa467a186b61ae85371 here's a sscce
06:38:23 <yactmp> oh, it's indent
06:38:45 <yactmp> inteersting. Two indents work, one doesn;t
06:39:51 <ski> yactmp : must be indented more than the `xs'
06:40:36 <yactmp> ski: I see, one more space makes it work. Why is that?
06:40:56 <ski> if it's indented the same as the `xs', it's interpreted as the start of another definition inside the `let', and an implicit `;' is assumed just before that -- that implicit `;' gives your parse error
06:41:15 <yactmp> ah, thanks ski
06:41:35 <ski> np
06:43:30 <merijn> yactmp: I recommend spending a few minutes reading the exact way indentation works (https://en.wikibooks.org/wiki/Haskell/Indentation), it's not quite the same as for example python and reading that will avoid future confusion :)
06:47:43 <benzrf> yactmp: pls listen to merijn on this one
06:47:55 <yactmp> yeah, thanks merijn benzrf
06:49:47 <Maior> yactmp: what they said (column _matters_)
06:51:38 <wcaleb> haskell n00b here, trying to grok parsec
06:52:07 <wcaleb> using RWH chapter 16 on csv parsing, I'm trying to write a parser for Mutt alias file
06:52:23 <wcaleb> what I have so far: https://github.com/wcaleb/muttells/blob/master/aliascheck.hs
06:52:56 <wcaleb> question i have is this: when i run ghci tests parsing groupAlias, seems to work
06:53:13 <wcaleb> but when i parse aliasFile with same input, i get an empty list back
06:53:32 <wcaleb> i guess i'm not understanding how try works, would appreciate any pointers
06:56:03 <johnw> line probably has to be: try validAlias <|> try groupAlias <|> comment
06:56:41 <johnw> also, swap the order of angEmail and emailAddress
06:57:52 <armlesshobo> anyone here use vim to code in haskell?
06:57:56 <johnw> put parsers which can determine invalidity based on the very first character first
06:58:09 <wcaleb> i've tried try before groupAlias, no dice
06:58:18 <armlesshobo> rather, anyone encounter spacing issues within vim?
06:58:55 <yactmp> no
06:59:16 <yactmp> my vim is fine
06:59:26 <Maior> armlesshobo: yes, no
06:59:33 <Maior> (pro-tip: stop using tabs)
06:59:55 <armlesshobo> i've replaced tabs, but it seems I have to indent really far in
07:00:17 <armlesshobo> whereas, when I edit it in nano, i don't have this issue.
07:01:25 <atohs_> armlesshobo: the vim channel is a better place to ask for this question
07:01:43 <albeit> Why is "f :: Foo a => Maybe a; f = g bar" different from "f = g bar :: Foo a => Maybe a"? It seems like the latter forces f to be of a single type, instead of just any a.
07:01:45 <wcaleb> johnw: so, put comment parser first?
07:01:59 <armlesshobo> I asked here since I only have this issue with Haskell in vim
07:02:18 <yactmp> armlesshobo: https://en.wikibooks.org/wiki/Haskell/Indentation maybe?
07:02:51 <johnw> wcaleb: I don't know if that's the problem; what "try" says is: if you couldn't parse this, rewind the token stream to before you attempted it
07:05:58 <Philonous> Is there a package for patricia trees that handles Text and/or ByteStrings  ?
07:06:08 <wcaleb> johnw: i think the problem may be within my groupAlias parser
07:06:49 <ski> albeit : probably MR
07:06:51 <johnw> Philonous: http://hackage.haskell.org/package/bytestring-trie-0.1.4/docs/Data-Trie.html?
07:06:53 <ski> DMR
07:07:11 <wcaleb> johnw: when i test in ghci, it works unless i end the string with a newline character, probably because it starts looking for spaces >> char ',' >> spaces
07:08:12 <Philonous> johnw, I looked at that, but it has some problems. The submap operation doesn't clip the prefix from the keys.
07:08:30 <albeit> ski: DRM = Dynamic Monomorphism Restriction?
07:08:36 <albeit> *DMR
07:09:13 <Philonous> johnw, I would add the function myself, but seeing that it's not in github and the last version is 3 years old I have doubts that my patch would be merged any time soon.
07:09:50 <ski> albeit : Dreaded Monomorphism Restriction
07:10:47 <albeit> I'm reading the Haskell wiki on it, and it seems like MR just requires that an explicit type signature is required. But I do give an explicit type signature in the second example, just not seperate, as part of the definitino.
07:11:18 <ski> no, in the second form, you have a type ascription, not a type signature
07:11:52 <albeit> Ah, didn't know even know that was a term, got it
07:12:06 <ski> a type signature is a declaration
07:12:26 <ski> an expression with a type ascription attached to it is an expression
07:12:45 <Philonous> johnw, list-tries looks promising, though
07:13:53 <ski> so the expression `g bar' probably gets assigned the type `forall a. Foo a => Maybe a' -- but right after, there's an implicit specialization of that to `Maybe T' for some type `T' that should be an instance of `Foo'
07:14:12 <ski> if it can't find a suitable default type `T', it'll give an error
07:14:46 <ski> albeit : in practice, people often suggest turning DMR off
07:15:07 <albeit> Yep, I try to use it with type T, then with type P, and it errors out then, saying basically T /= P
07:15:13 <ski> (but you should understand why it was introduced in the first place)
07:15:38 <albeit> Its easy enough to just have a type signature, so I'll play it safe ;)
07:15:55 <ski> if `f = g bar :: Foo a => Maybe a' typechecks, then you can use `:t f' in the interactor to see which type it inferred for `f'
07:16:52 <albeit> ski: Wouldn't it be just any a, and then when I first try and use it with instance T, it infers it is only for T?
07:17:16 <albeit> Well, I guess not use it, but have the function in an expression where it forces inferences to T
07:18:19 <puta> Please teach me how to export Parametric Polymorphism
07:18:39 <johnw> export?
07:19:00 <puta> export from module I made
07:19:01 * hackagebot openssl-streams 1.1.0.2 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.1.0.2 (GregoryCollins)
07:19:19 <johnw> i don't understand the question
07:19:28 <Sculptor> hi
07:19:36 <johnw> if you have a function that's parametrically polymorphic, just export the function
07:20:26 <puta> data Vector a = Vector a a a deriving (Show) <- how to export?
07:21:20 <johnw> that is simply a data type.  You would export it as: module Foo (Vector(..)) where...
07:21:21 <Maior> I'm starting to use cabal sandboxes + hakyll both for the first time; http://jaspervdj.be/hakyll/tutorials/01-installation.html has me run ghc, but obviously that's not "inside" the sandbox, so can't find my sandbox install of Hakyll; what do I do exactly?
07:21:25 <johnw> replace Foo with your module name
07:21:37 <Maior> (or, better: what's The Recommended Sandbox Equivalent, perhaps)
07:21:41 <puta> thank you
07:23:04 <wcaleb> johnw: sorta fixed by replacing spaces in line 23 with skipMany (char ' '), though it looks pretty ugly to me
07:23:46 <Maior> oh, `cabal exec ghc`, thanks
07:24:28 <wcaleb> johnw: thanks for the tips
07:26:25 <danilo2> Hello! :) I've got a (I think) very simple Haskell question. I'm wondering if is there any nice way to create a Map from String to a "Channel a" type, but "a" could be different per key (like "red" would point to (Channel Float) and "id" to (Channel Int)). Are existential datatypes the only solution for something like that?
07:27:24 <johnw> danilo2: is the number of different 'a' a fixed set?
07:27:46 <danilo2> johnw: If it would be we can make a datatype of it, but it isnt :(
07:28:17 <johnw> and I imagine that once you have the key, you'll want to know the particular a
07:28:20 <k00mi> danilo2: what do you intend to do with the 'a's?
07:28:31 <danilo2> johnw: that would be really useful
07:29:52 <danilo2> k00mi: channels are parts of an image. I want to for example read image with channels "r", "g" and "b", whcih are Floats and "id" which is Int - and then make some strange and complex computations, like cutting objects of particular id etc - so I would love to read the "id" channel and know it is Int
07:30:01 <danilo2> johnw: ^^^
07:30:21 <ryantrinkle> does anyone know of a way (perhaps using vacuum?) to determine what is retaining a particular value?
07:31:11 <johnw> ryantrinkle: hello!  do you mean, preventing it from being GC'd?
07:33:10 <johnw> danilo2: do you know at the time you have the key which 'a' you expect it to map to?
07:34:20 <ski> puta : that type definition doesn't by itself make use of parametric polymorphism
07:34:28 <danilo2> johnw: I'm sorry I do not understand your question. Would you be so nice and reformat it? I basically am reading images form disk and while reading I know what kind of data each channel has got inside.
07:35:11 <ryantrinkle> johnw: yes, exactly
07:35:29 <ski> danilo2 : one option would be to use a GADT for the key
07:35:46 <ryantrinkle> johnw: ideally, i'd like to get some sort of path from a GC root to the node, so that i can examine what's going on
07:36:08 <danilo2> ski: Hmm, could you elaborate a little more on this topic please? How cabn I use GADT for the key?
07:37:00 <ski> danilo2 : can you determine beforehand (i.e. statically) all the possible keys, and all their corresponding `a' types to be used in associated `Channel a's ?
07:37:43 <luite> ryantrinkle: i haven't used it myself, but GHC has retainer profiling, section 5.4.2
07:38:13 <luite> ryantrinkle: if you annotate the thing with a cost center, would that work for you?
07:38:17 <ryantrinkle> luite: yeah, that's kind of what i'm looking for, but iirc, it works at hte type level, not a particular object
07:38:29 <MagneticDuck> ghc-mod is failing with the error "unable to load package ghc-prim"
07:38:31 <MagneticDuck> what should I do?
07:38:42 <MagneticDuck> cabal install ghc-prim --reinstall --force-reinstalls also fails
07:38:45 <ryantrinkle> luite: also, i'd need ghcjs to support it ;)
07:39:02 <danilo2> ski: I think I am able to statically determine all the possible 'a'-types (I want users to be able to define their custom types, but all user files are known at compile time), but we cannot assign channel names to the types - in one image the "red" could be Float in other it could be Int
07:39:05 <MagneticDuck> =P
07:39:13 <ski> danilo2 : what do you call your identification thingies .. the ones which you denoted by `"r"',`"g"',`"b"',`"id"' above ?
07:39:24 <luite> ryantrinkle: sure, I'll just tell osa1 i expect it to be done first thing tomorrow morning
07:39:32 <ryantrinkle> hahaha
07:39:43 <ski> hm
07:39:57 <mm_freak> hi again
07:40:06 <MagneticDuck> but anyway, what should I do?
07:40:15 <ski> "but we cannot assign channel names to the types - in one image the \"red\" could be Float in other it could be Int" sounds more complicated
07:41:18 <mm_freak> is there a way to get custom defaulting or anything that resembles it?
07:41:52 <mm_freak> the problem is:  in f . g . h, i'll need not only an initial/final type signature, but even intermediary ones
07:42:41 <ski>   f . (id :: X -> X) . g  -- ?
07:42:43 <mm_freak> and f . isY . g . isX . h is really awkward
07:43:15 <mm_freak> (or rather "asX" and "asY")
07:43:18 <ski> hm, sectioning `::' could be funny
07:44:17 <mm_freak> perhaps automatically written specialized functions would be helpful
07:44:41 <mm_freak> write fGen :: (Blah a, Blubb b) => a -> b, derive f :: Int -> String
07:45:01 <MagneticDuck> http://ix.io/cC6
07:45:07 <MagneticDuck> waht shoulds I do
07:46:57 <danilo2> ski: All the thingss like "r", "g" etc are matrixes of values (repa matrixes), but for simplicity we can think of them like lists of values
07:47:51 <danilo2> ski: The channel names are assigned by the user of different applciations - there is no convention that "red" is always float
07:48:22 <ski> danilo2 : but is the set of channel names fixed ?
07:48:23 <k00mi> ski: augustss proposed that recently: http://augustss.blogspot.de/2014/04/a-small-haskell-extension.html
07:49:04 * hackagebot HUnit-Plus 0.3.1 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-0.3.1 (emc2)
07:49:45 <MagneticDuck> nobody has any ideas about my problem? :<
07:49:46 <danilo2> ski: some kind of - it can be any string name with max 256 characters
07:50:59 <ski> k00mi : nice
07:51:23 <MagneticDuck> kind of a big problem, ghc-mod is quite important to me =P
07:52:10 <ski> danilo2 : ok. how about the possible types that can be used for the `a' in `Channel a' -- are they fixed statically ?
07:53:33 <MagneticDuck> okay never mind problem fixed by reinstalling
07:57:06 <johnw> ski: heh, that was my first question :)
07:57:36 <danilo2> ski: Yes, I want users to be able to define custom types, but yes, we can know them statically - for example every type, which is instance of some class, or using other mechanism, but while compiling the program ,we would know all the types
07:58:40 <mm_freak> rules do fire after inlining, don't they?
07:59:01 <mm_freak> let flat = id {-# INLINE flat #-} in flat . f
07:59:11 <mm_freak> should become 'f', right?
07:59:16 <sm> morning all
07:59:36 <sm> HUnit-Plus, hmm
07:59:37 <johnw> hi sm!
07:59:45 <sm> o/ johnw
08:00:33 <sm> I am going crazy for lack of haskell hacking
08:01:04 <johnw> quick, fix some hledger bugs!
08:04:50 <sm> right! to the bugmobile
08:06:22 <ski> danilo2 : hm, so you only know the full set when you have the whole program ?
08:08:29 <danilo2> ski: Yes. But I think the best way is to limit the possible types to limited set of them right now. I do not see other possibility. It is impossible to store something in (Map String a) where a coudl be anything not known statically - here we can use only existential datatypes, so we can provide a common interface for all the types, but nothing more - am I right?
08:10:15 <mm_freak> danilo2: an existential type can always be unfolded
08:10:27 <mm_freak> Map String (a, a -> a -> a)
08:10:48 <mm_freak> and that's basically what happens at compile time
08:12:14 <danilo2> mm_freak: what do you mean by unfolding existential type?
08:12:40 <mm_freak> danilo2: let data X = forall a. (Monoid a) => X a
08:12:59 <mm_freak> then Map String X ≃ Map String (a, a, a -> a -> a)
08:13:15 <mm_freak> uh, no
08:13:48 <mm_freak> nevermind, i was thinking of something else
08:14:07 * hackagebot rest-gen 0.12 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.12 (AdamBergmark)
08:14:19 <mm_freak> class constraints can be unfolded within an existential type
08:15:07 <ski> danilo2 : you could have something like `Map1 Id Channel', i.e. with existentials inside
08:16:22 <ski> where `Map1 Id Channel' is more or less a set of pairs of type `exists i. (Id i,Channel i)', with at most one pair with a given key/id
08:16:57 <danilo2> ski: Yes, but then I can do with them only what is declared as constrains to these existentials. I mean, if Channel is defined as "data Channel = forall a. (Something a) => [a]" then I can do only things allowed by Something, which is a little restrictive - for example not all channels allow multiplication (Int allow, String does not)
08:17:10 <danilo2> ski: Anyway I think this is the best we can achive here
08:18:42 <ski> danilo2 : no, in my case `Channel :: * -> *'
08:18:50 <SrPx> > 5*5
08:18:52 <lambdabot>  25
08:19:05 <SrPx> > pointFree (\x->x*x)
08:19:07 <lambdabot>  Not in scope: ‘pointFree’
08:19:17 <SrPx> > help
08:19:19 <lambdabot>  Not in scope: ‘help’
08:19:33 <ski> @pointless \x->x*x
08:19:33 <lambdabot> join (*)
08:19:39 <ski> @help pointless
08:19:40 <lambdabot> pointless <expr>. Play with pointfree code.
08:19:42 <jophish> Has anyone else noticed that GHC doesn't recompile a program if the source hasn't changed, even if the compiler flags have changed?
08:20:51 <ski> danilo2 : the point being that your code could discover at run-time that the type is `Int', e.g., and then perform operations pertaining only to `Int'
08:21:04 <skilpat> I've got a GHC implementation question regarding type classes. Anyone around who could help me with that?
08:21:45 <ski> danilo2 : however, if the set of types `a' you allow is more or less unrestricted, then the above would only amount to a few special cases -- the rest would have to be handled generically -- though maybe that's ok with you
08:23:56 <ski> skilpat : you could try here, and possibly also try in #ghc
08:24:13 <ski> jophish : perhaps mention it in #ghc ?
08:24:16 <skilpat> Ah, didn't know about #ghc, thanks!
08:26:22 <jophish> ski: I've just noticed that this was 'fixed' several years ago
08:30:46 <MagneticDuck> how do I get ghci to show me the instances a type is member of?
08:31:11 <Clint> :i Double
08:31:22 <MagneticDuck> thanks
08:38:44 <danilo2> ski: Hmm, could you tell me more what you are thinking about? How could it be done ?
08:38:53 <danilo2> ski: sorry, I've got a phone call
08:40:47 <danilo2> ski: I would love to be able to define further extensions to it - like other channel types, but without modyfing a general datatype
08:42:25 <armlesshobo> what are ((->) e) and ((,) e) called, and where can I read more about them?
08:43:09 <armlesshobo> the way they look mystifies me, when it's probably something simple.
08:43:13 <danilo2> ski: Is this something like Dynamic in Haskell
08:43:15 <danilo2> ?
08:44:20 <Faucelme> armlesshobo: ((->) e) is a functor, the functor of functions with domain e.
08:44:29 <MagneticDuck> armlesshobo: well, (,) is a type constructor
08:44:38 <MagneticDuck> (,) a a is the same as (a, a)
08:44:50 <armlesshobo> for a tuple?
08:44:55 <armlesshobo> or n-ple?
08:44:55 <MagneticDuck> the (,) form is used in the same way you'd use it as a data constructor
08:44:57 <armlesshobo> heh
08:44:59 <Clint> pair
08:45:14 <MagneticDuck> ..when you want to parameritize it
08:46:02 <MagneticDuck> anyway, I'm having a bit of fun going through some project euler problems working on my management of laziness and stuff
08:46:03 <kazagistar> (,) is only for a 2-tuple, there is no n-tuple type
08:46:07 <MagneticDuck> (,,)
08:46:10 <MagneticDuck> ;)
08:46:12 <MagneticDuck> (,,,,,)
08:46:30 <MagneticDuck> @kind (,,,)
08:46:31 <lambdabot> * -> * -> * -> * -> *
08:46:35 <MagneticDuck> taa daa
08:47:18 <MagneticDuck> but if your question is, is there an n-tuple type constructor whose "size" is determined by a parameter, then no
08:47:20 <MagneticDuck> not easily
08:47:50 <MagneticDuck> brainstorm: can the printf magic be moved up a level to types?
08:47:58 <MagneticDuck> what kind of language extensions are out there for that? :D
08:48:09 <MagneticDuck> haskell gets pretty crazy with all these fun language extensions
08:48:27 <shapr> BUT IT'S WORTH EVERY PRAGMA!
08:48:38 <MagneticDuck> yeah!
08:48:42 <MagneticDuck> mostly
08:48:52 <miniBill> Say I have a transformer stack like ReaderT (Filename, Verbosity, Optimization) (FallibleT IO) a
08:49:09 <miniBill> how do I take a value of type Fallible Program and "put it into the stack"
08:49:20 <miniBill> Fallible is FallibleT Identity
08:49:26 <danilo2> ski: I think your solution could perfectly work here - how can I implement it?
08:52:06 <armlesshobo> so
08:52:12 <armlesshobo> ((->) e) is a functor
08:52:19 <armlesshobo> and (,) is a type constructor
08:52:20 <armlesshobo> ok
08:52:46 <monochrom> some type constructors are functors too. for example Maybe
08:53:07 <armlesshobo> is ((->) e) also a type?
08:53:11 <MagneticDuck> armlesshobo: ((->) e) is a type constructor
08:53:33 <MagneticDuck> Faucelme was talking about how that type constructor can be implemented as a functor
08:53:37 <miniBill> anyone?
08:53:43 <Faucelme> miniBill: for ErrorT, you could use funcion mapErrorT to turn that Identity into IO.
08:53:44 <MagneticDuck> a Functor is just a certain type of type constructor
08:54:09 <Faucelme> something like "mapErrorT $ return . runIdentity"
08:54:10 <miniBill> Faucelme: FallibleT is a kind of ErrorT. I'll have a look at mapErrorT
08:54:48 <Faucelme> miniBill: look also the "hoist" function from package http://hackage.haskell.org/package/mmorph
08:55:04 <Faucelme> Which does a similar thing in a more general manner.
08:57:13 <kazagistar> armlesshobo: it is currying at the type level... (,) has a kind of * -> * -> * (takes 2 types to return a type), ((,) Int) has a kind of * -> * (takes 1 type to return a type) and ((,) Int String), also written as (Int, String), is a type, since its kind is *
08:59:17 <armlesshobo> kazagistar: oh I see
08:59:33 <armlesshobo> because (->) also has a kind * -> * -> *
09:00:05 <armlesshobo> and since 'e' is given
09:00:09 <armlesshobo> in ((->) e)
09:00:16 <armlesshobo> it now has kind of * -> *
09:01:14 <kazagistar> armlesshobo: exactly, and when you write (Int -> Int -> Int), for example, it is just simplified infix notation for ((->) Int ((->) Int Int))
09:01:24 <armlesshobo> right
09:01:35 <armlesshobo> because (->) is a type
09:01:43 <armlesshobo> and one of the types it takes in can be itself
09:01:45 <armlesshobo> recursively
09:02:01 <MagneticDuck> it's a type constructor
09:02:05 <MagneticDuck> there is no value that is of type (->)
09:02:17 <kazagistar> armlesshobo: once you pass it two types as parameters it becomes a type
09:02:24 <armlesshobo> ahh right
09:02:28 <dwcook> armlesshobo: careful with "itself" – You can't have infinite types. You can however nest function types.
09:02:44 <dwcook> Or nest any type constructors.
09:02:53 <MagneticDuck> infinite types are pretty useless anyway =P
09:02:57 <MagneticDuck> unless you want to use types as values
09:03:00 <dwcook> Maybe (Maybe Int), [[Int]], etc.
09:03:07 <MagneticDuck> but why would you want to do that, we have values for being values
09:03:08 <armlesshobo> thank you for your help all
09:03:12 <armlesshobo> gotta run for now
09:03:13 <armlesshobo> bbl
09:03:14 <armlesshobo> :)
09:04:13 * hackagebot effin 0.2.1.2 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.2.1.2 (AnthonyVandikas)
09:04:59 <dwcook> MagneticDuck: you can have a form of infinity with things like Fix f = Fix (f (Fix f)).
09:06:00 <monochrom> "when you think that you know everything, you can get a Bachelor's"
09:06:21 <dwcook> monochrom: if that were all it took I'd be done by now
09:06:53 <dwcook> After all, it's easier to convince myself I know everything than to do all this busy work
09:06:57 <monochrom> true, there are a few annoying exams to take
09:09:23 <dwcook> Woops, forgot the word "newtype" above.
09:14:26 <monochrom> what would "new type" be in German and in French?
09:15:08 <MitchellSalad> nouveau type
09:15:53 <ski> MitchellSalad : "Neue Typ" in german, i think
09:15:57 <ski> er
09:16:02 <ski> monochrom ^
09:16:05 <ski> MagneticDuck : "((->) e) is a type constructor" -- i don't agree with this terminology. however i would say it's a type function (as well as a type)
09:16:43 <MitchellSalad> doesn't type constructor just mean type with kind != * ?
09:16:44 <monochrom> I think it's best to just use kinds and say ((->) e) :: * -> *
09:16:47 <dwcook> ski: A type constructor is the unapplied thing, no? Like (->) or [] or Maybe?
09:17:13 <dwcook> MitchellSalad: constraints are type constructors?
09:17:13 <monochrom> the kind system eliminates false dichotomies and true dilemmas
09:17:35 <MitchellSalad> dwcook: types that have the (->) kind constructor
09:17:37 <MitchellSalad> how about that
09:17:47 <dwcook> Maybe's not a type constructor?
09:17:57 <MitchellSalad> maybe :: * -> *
09:18:14 <dwcook> (->) :: * -> * -> *
09:18:19 <ski> MitchellSalad : that's old (i think) terminology (some still seems to prefer it). i prefer using "type" for all type expressions, "concrete type" for types which are capable of having values, like types with kind `*', and "type constructor" for things like `Int',`Maybe',`(->)',`Either' (but not e.g. `Either String')
09:18:50 <dwcook> MitchellSalad: sorry, I misparsed "kind constructor".
09:18:54 <rwbarton> presumably you wouldn't call "Just True" a "data constructor"
09:18:59 <dwcook> MitchellSalad: you'd still have * -> Constraint
09:19:01 <ski> MitchellSalad : further, a "type function" is one with kind of the shape `... -> ...' (possibly wrapped in a `forall', if we allow type polymorphism)
09:19:25 <MitchellSalad> dwcook: true
09:19:45 <ski> MitchellSalad : one reason i prefer this terminology is that here "type constructor" corresponds much closer to "data constructor"
09:20:17 <ski> dwcook : `Int' is also unapplied
09:21:44 <MitchellSalad> what do you apply Int to?
09:21:59 <ski> nothing
09:22:10 <ski> therefore, it's not applied, so unapplied
09:22:49 <ReinH> heh
09:23:01 <ReinH> it's a unary type function!
09:23:03 * ReinH ducks
09:23:06 <ReinH> nullary, sorry
09:23:15 * MitchellSalad shoots
09:23:15 <dwcook> ski: If we're using terminology analogous to data constructors, I'd be okay calling Int a type constructor.
09:23:18 <MitchellSalad> dang you ducked
09:23:34 * monochrom chickens
09:23:48 * MitchellSalad blue footed boobies
09:23:52 * MitchellSalad you heard me
09:23:58 <ski> (one could perhaps argue that it doesn't make sense to consider applying `Int' to anything (because of its kind), and so therefore the term "unapplied" would be undefined when applied to the type `Int')
09:24:26 <MitchellSalad> ski: yeah, i see what you are saying
09:24:28 * monochrom leaves "unapplied" unapplied
09:24:36 <MitchellSalad> it's analogous to a data constructor with no fields
09:24:59 * monochrom unapplies those who don't unapply themselves!
09:25:00 <ReinH> does it make sense to call the value 3 fully saturated?
09:25:23 <monochrom> yes, until "Num (a -> a)" comes along :)
09:25:25 <dwcook> That seems like more a statement of syntax to me
09:25:27 <kazagistar> isn't a data constructor with no fields just... data?
09:25:41 <Pythonfant> Is there any other http library than http-conduit-browser that offers some kind of session object and url form encoding? Sadly http-conduit-browser seems to be outdated and I run into dependency conflicts
09:25:47 <dwcook> kazagistar: well it is, but it's also a data constructor :)
09:25:55 <dwcook> kazagistar: ("data"'s not a technical term here)
09:25:57 <ReinH> monochrom: argh, ok, the value (3 :: Int)
09:26:31 <kazagistar> are we going to call functions "value constructors" from now on? :P
09:26:39 <dwcook> kazagistar: also consider that there are from one viewpoint an infinite number of Nothings
09:27:16 <dwcook> Nothing :: Maybe Int, Nothing :: Maybe String, Nothing :: Maybe (Maybe Char)…
09:27:26 <Pythonfant> ah http seems to offer what I want
09:27:52 <ReinH> monochrom: so Mac Lane's Algebra talks about nullary functions on a set S as being functions from 1 -> S, so I guess now I can start saying that all values in Haskell are functions again!
09:28:01 <dwcook> kazagistar: I don't get the comparions – Why would functions be called "value constructors"?
09:28:09 <dwcook> comparison*
09:28:32 <dwcook> ReinH: only up to isomorphism, and not even that since 1 is actually doubly inhabited
09:28:32 <MagneticDuck> hmm
09:28:46 <ReinH> dwcook: that's true
09:29:05 <ReinH> dwcook: but now I have a principled way to troll people about nullary functions. (I won't actually do this)
09:29:09 <dwcook> :D
09:29:17 <MagneticDuck> kazagistar: well there is obviously a need to distinguish between types with kind * with types with other kinds
09:29:27 <dwcook> MagneticDuck: those are called concrete types.
09:29:31 <MagneticDuck> yeah I know
09:29:44 <ReinH> At least Haskell doesn't have sorts
09:29:45 * monochrom prefers happy constructors to value constructors, happy meals to value meals
09:29:49 <MagneticDuck> I'm a bit confused about the problem with using the term "type constructors" though
09:29:57 <dwcook> In Haskell, types of kind *, concrete types, and inhabited types all mean the same thing.
09:30:11 <MagneticDuck> yes I got that
09:30:25 <dwcook> Though "inhabited" can be used to mean "inhabited besides bottom".
09:30:47 <cococo> What can I do about the error "Couldn't match type `Maybe String` with `[Char]`?
09:31:10 <dwcook> cococo: show code
09:31:21 <dwcook> cococo: but you are trying to match up a String with a Maybe String
09:31:41 <napping> MagneticDuck: what's the question about "type constructors"?
09:31:48 <ReinH> dwcook: "up to isomorphism" is Mac Lane's favorite ambient equality system ;)
09:32:13 <cococo> dwcook: line 24 http://lpaste.net/1894311672546328576
09:33:12 <kazagistar> question: why is the State monad formulated as (result, state) rather then (state, result)?
09:33:42 <prophile> convention?
09:33:53 <dwcook> cococo: this would be easier with explicit type annotations
09:33:58 <prophile> I don't know that there would be a reason to prefer one over the other
09:34:04 <dwcook> (for top-levels that is)
09:34:41 <cococo> dwcook: could you help a prehaskooler out?
09:34:46 <napping> I can't imagine there's any practical difference
09:34:57 <cococo> dwcook: that was a bad pun. What I mean is I'm brand new to Haskell and don't understand what you mean.
09:35:10 <ReinH> Maybe having state in positive position is useful somehow
09:35:19 <napping> both tuple arguments are positive
09:35:22 <kazagistar> prophile: then it would work like the Monad ((->) a)?
09:35:22 <dwcook> cococo: it's considered good practice to write the types of your top-level bindings, e.g., ccTlds :: [String]
09:35:37 <napping> if anything making it a bit more obviously a composition of (->) a and (,) a would be more elegant
09:35:39 <dwcook> cococo: I'm trying to work through the types regardless, it's just faster with them written in
09:35:48 <ReinH> napping: positive in the type
09:36:31 <MitchellSalad> (a -> (b -> c) -> d) -> e -> f
09:36:32 <MitchellSalad> (p -> (n -> p) -> n) -> n -> p
09:36:38 <napping> do you mean a later constructor argument in the pairs? I can't make any sense of what you said in terms of the usual notion of positive and negative positions in a type
09:36:46 <cococo> dwcook: I'll add types now, but I don't think that's causing this problem
09:36:55 <dwcook> cococo: it's not, but it's a valuable programmer aide
09:36:59 <cococo> sure, thanks
09:37:24 <MitchellSalad> could someone please explain why b is negative in that function?
09:37:33 <hexagoxel> if i am only interested in the compile-time errors (and not the resulting executable), what is the cheapest way to run cabal?
09:37:35 <Pythonfant> I get this error: http://sprunge.us/SECP here's the code http://sprunge.us/GeDj . It seems to be that somehow it's trying to use network 2.4. I have network 2.4 installed but it's not in the sandbox. cabal sandbox hc-pkg list shows only version 2.5. What I'm I doing wrong and how do I do it right?
09:37:37 <MitchellSalad> or why you get a flippy floppy thing when functions are passed as arguments
09:38:46 <ReinH> Is that implementation of state necessary for the Functor instance?
09:38:53 <kazagistar> ((,) a) is already a functor, and a monad of ((,) a) would be equivalent to the state monad, right?
09:39:27 <hexagoxel> cabal build does not seem to provide any flags that allow stopping after a certain phase..
09:40:17 <cococo> dwcook: http://lpaste.net/7824423604258340864
09:40:17 <cococo> dwcook: but do you know how to fix "Couldn't match type `Maybe String' with `[Char]'"?
09:40:18 <geekosaur> figure out what's giving you the Maybe String and pattern match against it (preferably handling possible Nothing)
09:40:41 <ski> kazagistar : using `(state,result)' would be better imo (also for `Writer' and `ReadS' and the operations in `Random' and `RandomGen')
09:40:44 <dwcook> cococo: how about this: what are the types of isAvailable and of knockKnock?
09:40:44 <dwcook> You can ask the compiler and/or ghci
09:40:44 <dwcook> cococo: I suspect getWhois has a Maybe in its output, is that right?
09:41:03 <dwcook> Ah never mind I didn't think that through
09:41:19 <ReinH> ski: but you want to fmap over the state, right?
09:41:25 <hexagoxel> and cabal repl is fast (interpretation-time-wise), but i cannot extract the error output in a nice fashion
09:41:28 <dwcook> cococo: does the compiler certify that those types you wrote are correct?
09:41:28 <cococo> dwcook: btw I forgot the "::" on line 22 of the most recent link i gave you
09:41:31 <napping> cococo: it's not causing the problem, but if you have type annotations on the top level functions then you only have to worry about the definition with the type error plus the other signatures to understand the problem
09:41:47 <cococo> dwcook: yeah it does
09:42:00 <hexagoxel> sorry for asking, i gotta go
09:42:03 <ski> cococo : writing explicit type annotations can often make finding the reason for a type error faster
09:42:15 <ReinH> Nevr mind
09:42:19 <ski> ReinH ?
09:42:23 <ReinH> ski: never mind.
09:42:41 <ski> you don't mind ?
09:42:44 <Eelis> we should move toward inferring more terms, not inferring more types ;)
09:42:46 <ReinH> You're defining the Functor instance on the State type constructor, not on the tuple type constructor.
09:42:51 <ReinH> So what I said makes no sense
09:42:53 <ReinH> so never mind
09:43:13 <dwcook> cococo: I'm not sure about that other error but you seem to be mixing up which Monad you're working with
09:43:32 <cococo> dwcook: which one?
09:43:50 <dwcook> I see uses of both [] and IO here
09:43:59 <dwcook> So main won't type check
09:44:21 <dwcook> cococo: wait, no, that's not right. You're clearly doing IO in getWhois
09:44:24 <dwcook> That type signature is wrong
09:44:39 <cococo> dwcook: should it be [String] -> [IO String]?
09:44:43 <int-e> @free (a -> a) -> a -> a
09:44:43 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
09:44:52 <int-e> @free num :: (a -> a) -> a -> a
09:44:52 <lambdabot> f . g = h . f => f . num g = num h . f
09:45:45 <dwcook> cococo: try this: take out the type signatures you wrote, comment out main, go into ghci and load your file. Then ask ghci: :type getWhois
09:46:20 <dwcook> The rest at least at a glance looks like it should typecheck
09:46:36 <cococo> dwcook: thanks, it should be String -> IO (Maybe String) according to ghci
09:46:42 <dwcook> Aha, therein lies the problem
09:46:43 <ReinH> or defer type checking
09:46:44 <cococo> dwcook: so do I not need brackets around String?
09:46:48 <kazagistar> class Mainable a where mainify :: a -> IO (); instance Show a => Mainable a where mainify = print
09:47:00 <dwcook> cococo: the problem is you're getting Maybe String but trying to treat it like String
09:47:19 <kazagistar> er
09:47:25 <dwcook> isAvailable takes [String], not [Maybe String]
09:48:01 <dwcook> So you either need to handle the Nothings yourself or else use something like fromMaybe to pick a default
09:48:04 <dwcook> @type fromMaybe
09:48:05 <lambdabot> a -> Maybe a -> a
09:48:12 <cococo> dwcook: what's the difference between [Char] and String? (Going through all functions right now adding propper type)
09:48:16 * ski . o O ( isn'tUnavailable )
09:48:17 <Iceland_jack> cococo: none
09:48:20 <ski> cococo : tey are equal
09:48:23 <dwcook> cococo: there is no difference whatsoever to the type checker.
09:48:25 <ski> s/tey/they/
09:48:32 <cococo> ty
09:48:34 <dwcook> type String = [Char] -- This is how String is defined
09:48:42 <Iceland_jack> > ("test" :: String) == ("test" :: [Char])
09:48:44 <lambdabot>  True
09:48:46 <mirpa> cococo: different name for same data type
09:48:49 <cococo> dwcook: isAvailable is String -> [Data.Text.Internal.Text] <---- WTF is that :/
09:49:06 <ReinH> cococo: String -> [Text]
09:49:22 <kazagistar> cococo: if you run into performance issues ever, you just switch to Text, which is the more optimized string library
09:49:35 <ski> imo, GHCi ought to report type names with regard to how one has imported them
09:49:43 <dwcook> Text is about correctness as well as performance.
09:50:09 <rwbarton> ski: doesn't it?
09:50:13 <cococo> Err... "Not in scope: type constructor or class `Data.Text.Internal.Text'"
09:50:15 <geekosaur> although if it really wanted to be correct, it should be ByteString -> [Text]
09:50:26 <cococo> How can my function be returning that type if it's not even in scope/
09:50:29 <cococo> *?
09:50:34 <geekosaur> cococo: you can't use that type directly by that name, it's re-exported as Text
09:50:35 <ski> rwbarton : somehow i doubt that cococo has explicitly imported `Data.Text.Internal', above
09:50:40 <dwcook> cococo: pack outputs it, I believe
09:50:47 <geekosaur> Data.Text.Text to be precise
09:51:00 <rwbarton> cococo didn't import anything from Data.Text at all
09:51:15 <dwcook> import Data.Text (isInfixOf, toLower, pack
09:51:18 <cococo> Yeah I'm confused, unless I set that to String I get a scope error
09:51:23 <dwcook> Woop, cut off the last paren
09:51:42 <dwcook> cococo: you only imported certain things from Data.Text. You could also import Text from there if you wanted.
09:51:52 <rwbarton> oh whoops
09:51:58 <geekosaur> so it sounds like the real source of that type is Network.Whois
09:52:06 <rwbarton> yes
09:52:13 <napping> kazagistar: a monad on just (s,a) would be Writer s a, and need Monoid s
09:52:18 <geekosaur> but you never imported the type itself, so all your ghc knows about it right then is that it's a type used in an imported function
09:52:20 <ReinH> I am starting to dislike this Network.Whois library
09:53:46 <cococo> I am mega confused right now. What should my isAvailable type thingy be and how can I fix the original error?
09:54:16 <kazagistar> napping: ah, right, because you need to define a return/pure... state is like a Monad on... um ((->) a) . ((,) a)
09:54:19 <ski> hmm .. i suppose possibly one could argue against a module automatically exporting types mentioned in type signatures of exported operations ?
09:54:20 <rwbarton> geekosaur: oh, no
09:54:41 <rwbarton> the source of the type is Data.Text's pack
09:55:12 <ReinH> If you're going to use Text in your library, just use it everywhere imo
09:55:30 <rwbarton> cococo: normally people do a qualified import of Data.Text
09:55:34 <rwbarton> import qualified Data.Text as T
09:55:35 <geekosaur> everywhere that it is appropriate
09:55:55 <rwbarton> rather than picking out functions individually to import
09:56:13 <ReinH> geekosaur: Fine =)
09:56:13 <cococo> rwbarton: I hate to do this, but I am so confused right now as to what you're talking about... think you could show me? My most recent code: http://lpaste.net/2114381549070712832
09:56:31 <rwbarton> also there's no real reason to use Text at all in this code
09:56:35 <rwbarton> cococo: okay
09:56:39 <cococo> thanks a bunch
09:56:43 <dwcook> cococo: if you do what rwbarton suggested, you should write the type of isAvailable like so: isAvailable [String] -> [T.Text], according to what you said ghci told you.
09:56:46 <rwbarton> replace "import Data.Text (isInfixOf, toLower, pack)
09:56:53 <rwbarton> " by "import qualified Data.Text as T"
09:57:02 <MitchellSalad> or just add Text to the list of imports
09:57:07 <rwbarton> then replace every isInfixOf, toLower, pack by T.isInfixOf, T.toLower, T.pack
09:57:20 <rwbarton> then, do what dwcook said
09:57:52 <kazagistar> but yeah, there is little reason to touch Text
09:57:59 <kazagistar> in this case
09:58:29 <dwcook> cococo: woops, I mistyped. isAvailable :: [String] -> [T.Text]
09:58:54 <cococo> I don't want to change every to T.<whatever> though
09:59:05 <cococo> I've added Text like this: import Data.Text (isInfixOf, toLower, pack, Text)
09:59:07 <kazagistar> rwbarton: I suggest you just switch to http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Char.html#v:toLower and http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:isInfixOf
09:59:14 <cococo> But I'm still getting errors that way
09:59:16 <kazagistar> er, that was meant for cococo
09:59:17 <cococo> String -> [Text]
09:59:18 <rwbarton> kazagistar: you mean cococo, but yes
09:59:19 * hackagebot aivika 1.2.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-1.2.1 (DavidSorokin)
09:59:39 <rwbarton> cococo: T.Text not Text
10:00:18 <whald> I think I've hit a bug in concurrent-extra's ReadWriteLock. maybe someone would be so kind and check if this: https://gist.github.com/waldheinz/dfb56be1d9b19f24eafc fails for her/him, too? (bug is already filed at https://github.com/basvandijk/concurrent-extra/issues/8, but I just now came around creating a simple test case)
10:00:23 <dwcook> cococo: okay, in that case just add Text to the imports list.
10:00:27 <cococo> rwbarton: doesn't work with "import Data.Text (isInfixOf, toLower, pack, Text)"
10:00:47 <dwcook> cococo: imported that way, you can just write Text rather than T.Text
10:00:47 <rwbarton> oh okay
10:00:48 <cococo> rwbarton: I have the above imports and [T.Text]. Doesn't work :/
10:00:52 <cococo> k
10:01:02 <cococo> with brackets?
10:01:23 <dwcook> [These brackets?] They mean "list of". So yes, if you're returning a list of Text.
10:01:35 <shapr> Has anyone used aws-sdk for checking cloudwatch alarms?
10:01:48 <cococo> Alright. I really GTG though... I'll be back on later. Thanks for the help
10:02:02 <dwcook> No problem. Maybe we can figure out the other types later.
10:02:23 <dwcook> Knowing how the types fit together is pretty much vital, so a good thing to learn.
10:02:34 <dwcook> Oh, already left. Oh well.
10:04:31 <Qfwfq> cococo: http://lpaste.net/104520 might do it.
10:04:37 <Qfwfq> Oh, already left. Oh well.
10:04:46 <LT1MH> WASSUP!
10:04:47 <shapr> Anyone using Haskell to interface with amazon web services?
10:05:01 <shapr> Hi LT1MH, hows' code?
10:05:03 <bergmark> shapr: yes we are
10:05:10 <shapr> bergmark: ooh, tell me more!
10:05:17 <shapr> I'm trying to find some demo code I can steal.
10:05:19 <bergmark> ... we are totally doing it?
10:05:31 <bergmark> we are using the aws package
10:05:31 <shapr> ha, so useful :-P
10:05:31 <Qfwfq> hS3 is okay.
10:05:37 <shapr> bergmark: Ever tried aws-sdk?
10:05:43 <shapr> I was hoping to check cloudwatch alarms.
10:05:47 <LT1MH> lol
10:05:53 <bergmark> i don't think we've tried that one
10:06:15 <shapr> LT1MH: Written any cool Haskell code lately?
10:07:00 <shapr> bergmark: Are you using aws to check cloudwatch alarms?
10:07:58 * LT1MH Is Writin Codez!
10:08:04 <jle`> @tell Itkovian thanks :)
10:08:05 <lambdabot> Consider it noted.
10:08:07 <shapr> LT1MH: Awesome! what are you writing?
10:08:36 <bergmark> shapr: i asked our devops guy he said "sometimes it submits things and sometimes it works and it's pretty shitty"
10:08:39 * dwcook is now slightly more convinced that LT1MH is not a bot.
10:08:40 <shapr> haha
10:08:58 <shapr> dwcook: Do you think I'm abot?
10:09:10 <dwcook> shapr: no. I just think that of LT1MH.
10:09:11 <shapr> LT1MH: Are you in college?
10:09:17 <LT1MH> *dwcook just mite be a bot!
10:09:24 <shapr> dwcook: good to know, some people have thought I am a bot in the past :-(
10:09:42 <dwcook> shapr: why would that be?
10:09:43 <jle`> kazagistar: not sure what you mean by that earlier statement, that a monad of ((,) a) would be equivalent to the state monad?
10:09:48 <Qfwfq> shapr: As you're so reasonable?
10:09:48 <savanni> I have... a riddle... about QuickCheck
10:09:50 <shapr> dwcook: I think I reply too quickly and with too much detail.
10:09:54 <shapr> Qfwfq: that's also possible
10:09:55 <dwcook> Haha.
10:09:57 <shapr> savanni: ooh, what is it?
10:10:12 <shapr> LT1MH: Have you read "learn you a haskell" ?
10:10:13 <bergmark> shapr: personally i've only used things related to s3
10:10:22 <savanni> shapr: I warn you... this will be basic and is the riddle which has kept me from digging into QuickCheck so far
10:10:24 <kazagistar> Jag kдnner en bott, hon heter Anna, Anna heter hon
10:10:26 <shapr> bergmark: Ok, thanks for the info.
10:10:38 <shapr> kazagistar: and I do love that bot and that song. I was listening to it this week!
10:10:45 <savanni> Suppose, however, that I have some mathematical function that I need to calculate correctly.  I know certain inputs and I know the corresponding correct outputs.
10:10:59 <savanni> How would I QuickCheck them without, really, running the calculation directly in my code?
10:11:04 <savanni> my test code, that is
10:11:16 <shapr> savanni: That's not really a property is it?
10:11:34 <kazagistar> shapr: I was surprised by the lyrics when I looked them up, but they are amusing for sure
10:11:55 <Qfwfq> savanni: I think something like hspec is more appropriate for that case. QuickCheck says, here's a property of the function, here's hot to generate values in the domain, do they always hold? Here, your property is the function definition.
10:11:57 <savanni> shapr: actually, that may be where my understanding fails...
10:12:05 <shapr> kazagistar: Yeah, it's very punny that "boat in a canal" is the same as "bot in a channel" in Swedish.
10:12:13 <bergmark> the important thing is to prounce the artist name as bass (as in the fish) hunter
10:12:27 <Maior> bergmark: ...
10:12:31 <Maior> can't tell if pun or not
10:12:50 <shapr> savanni: You're thinking of checking specific inputs to give correct outputs.
10:12:52 <savanni> Oh, but, Qfwfq, would it be a property for me to say that "the answer is an array in ascending order with a certain number of negatives and a certain number of positives"?  Because that I can say and have been thinking abotu using *that* for testing.
10:12:56 <bergmark> i just assumed that he was not clever enough to make it a pun
10:13:06 <kazagistar> jle`: I was wrong, but State might be somewhat similar to ((->) a) . ((,) a)
10:13:07 <shapr> savanni: You can generalize that into a property
10:13:24 <shapr> savanni: for example a * b == b* a, right?
10:13:29 <savanni> shapr: Ah.  So, QuickCheck is good for generalizations like that, but I need to resort to something more like unit testing if I need to check specific results?
10:13:39 <Qfwfq> Precisely.
10:13:51 <savanni> Ah.  Now I think I know how to proceed!
10:13:53 <kazagistar> shapr: ah, I didn't know that bit, it all makes so much more sense now. :)
10:13:59 <LT1MH> my computer is really slow
10:14:11 <savanni> Thank you, shapr and Qfwfq, both
10:14:21 <LT1MH> bert?
10:15:06 <Qfwfq> savanni: QuickCheck's useful when you have laws. Assertion frameworks are useful when you have terms and results.
10:15:38 <tomejagu1r> > let (+) = 5 in (+)
10:15:40 <lambdabot>  5
10:15:46 <tomejagu1r> ^^ ???
10:16:01 <LT1MH> ur welcome
10:16:01 <tomejagu1r> Since when was that valid Haskell?
10:16:13 <Qfwfq> savanni: If you want a simple assertion framework, I wrote https://github.com/fmap/assert. Otherwise: hspec let's you express assertions and properties in the same DSL, and is quite handy.
10:16:28 <LT1MH> if any1 asks
10:16:46 <savanni> Qfwfq: Oh, I've been using HUnit for a long time and am rather comfortable with it.  I have learned so many new frameworks this week that I'd rather not replace it completely.
10:16:53 <Qfwfq> :-)
10:17:00 <LT1MH> tomejaguar
10:17:21 <savanni> Although, I've not read the QuickCheck API yet and thus don't know whether I can use it seemlessly with HUnit.
10:17:27 <LT1MH> r u there?
10:17:51 <bergmark> it seems to me that hspec is some middle ground between a test framework and a testing library
10:18:03 <tomejaguar> LT1MH: I am here
10:18:21 <Qfwfq> savanni: hspec integrates with hunit and quickcheck, and you can use both of their APIs together. http://hspec.github.io/
10:18:24 <ski> @check 1 + 1 == 2
10:18:26 <lambdabot>  +++ OK, passed 1 tests.
10:18:32 <savanni> \o/ Woot!
10:18:36 <bergmark> Qfwfq: but test-framework and tasty also let you do that
10:18:43 <kazagistar> tomejaguar: I dont see why that shouldn't be valid exactly... do you think temporary shadowing is bad?
10:18:43 <bergmark> and then there's tasty-hspec which makes me really confused :-)
10:18:48 <ski> @check length "four" == 4
10:18:50 <lambdabot>  +++ OK, passed 1 tests.
10:19:04 <tomejaguar> kazagistar: I thought operators could only be of type a -> b -> c
10:19:08 <ski> interesting that it doesn't run more than one test, here
10:19:18 <napping> @check \x y -> x + y == y + x :: Int
10:19:20 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
10:19:20 <lambdabot>  with actual type ‘GHC.Types.Bool’
10:19:22 * hackagebot Hoed 0.1.0.0 - Debug anything without recomping everything!  http://hackage.haskell.org/package/Hoed-0.1.0.0 (faddegon)
10:19:26 <napping> @check \x y -> x + y == y + (x :: Int)
10:19:27 <lambdabot>  +++ OK, passed 100 tests.
10:19:45 <ski> @check \x -> (x :: Void) == x
10:19:47 <lambdabot>  Not in scope: type constructor or class ‘Void’
10:19:50 <ski> hmpf
10:20:17 <Qfwfq> @check let data Void in \x -> (x :: Void) == x
10:20:18 <lambdabot>  <unknown>.hs: 1: 5:Parse error: data
10:20:18 <ski> hm, `Void' could be in `Coarbitrary', no ?
10:20:45 <bergmark> tomejaguar: there's no difference between an identifier and its infix counterpart
10:20:49 <ski> @type coarbitrary
10:20:52 <lambdabot> CoArbitrary a => a -> Gen b -> Gen b
10:21:04 <bergmark> (except syntax)
10:21:20 <napping> Is Void -> _ different from ()?
10:21:37 <Qfwfq> bergmark: I was surprised you could redefine functions supplied by a typeclass, independently of a typeclass instance.
10:21:43 <newsham> "Whatever it says in your Java textbook, revenge is the only way anyone truly learns to code."
10:21:45 <ski> napping : they are different types, just like `(a,a)' is different from `Bool -> a'
10:21:47 <newsham> http://www.theverge.com/2014/5/22/5742654/watch-dogs-ubisoft-launch-trailer-revealed
10:21:58 <dwcook> napping: including bottom or no?
10:21:59 <bergmark> Qfwfq: that's just shadowing
10:22:16 <napping> including bottom
10:22:24 <xenomachina> dwcook: I started reading http://www.haskell.org/tutorial/classes.html that you recommended to me yesterday
10:22:31 <Qfwfq> bergmark: Point.
10:22:33 <napping> oh, I guess you could apply it to bottom and get something
10:22:57 <dwcook> napping: okay, what's the _ mean? Any type I choose? Then sure, Void -> a has as many values as a does.
10:23:01 <bergmark> :-)
10:24:15 <xenomachina> dwcook: I am now confused as to how "5 == 5" can even be evaluated. Does it end up invoking integerEq or floatEq?
10:24:35 <bergmark> xenomachina: lambdabot/ghci has its own defaulting rules
10:24:45 <kazagistar> is there a point to Void being defined?
10:24:52 <Qfwfq> xenomachina: The type system shouldn't be able to decide.
10:25:00 <bergmark> you can get the same behavior normally using -XExtendedDefaultRules
10:25:05 <Qfwfq> xenomachina: Without an annotation on either value.
10:25:19 <n-dolio> 5 == 5 does not depend on extended defaulting.
10:25:26 <n-dolio> It defaults to Integer.
10:25:43 <bergmark> oh ok
10:25:52 <Qfwfq> I didn't know that. Is the defaulting hierarchy specified in the report?
10:26:00 <dwcook> kazagistar: it's useful for passing as an argument to type functions
10:26:23 <dwcook> For example, IO Void cannot have a useful result.
10:26:24 <n-dolio> The classes that have to be involved for things to default is specified in the report somewhere.
10:26:28 <LT1MH> who wantz me to record this?
10:26:47 <n-dolio> Extended defaulting does defaulting for more classes.
10:27:00 <dwcook> [Void] cannot have useful elements, only structure.
10:27:16 <Qfwfq> kazagistar: 'forever :: Monad m => m a -> m Void' was brought up yesterday.
10:27:25 <ReinH> Also Void is an initial object
10:27:36 <dwcook> (I should note that "useful" is only approximate here.)
10:27:42 <Qfwfq> ReinH: What do you mean by that?
10:28:37 <LT1MH> I AM THE NSA!
10:28:38 <kazagistar> Qfwfq: ah, ok, that one makes sense...
10:28:47 <ReinH> In the same way that the empty set is the unique initial object in the category of sets, Void is the unique initial type in the category of types. (standard hand waves about bottoms apply)
10:28:47 <tomejaguar> Is LT1MH a bot?
10:28:51 <Qfwfq> LT1MH: Quiet, you.
10:28:57 <ReinH> tomejaguar: I'm not sure, but it has never said anything useful
10:29:07 <LT1MH> No I am not.
10:29:09 <xenomachina> Is there a way to specify defaults for your own typeclasses?
10:29:13 <Qfwfq> ReinH: Oh, that's useful.
10:29:19 <merijn> xenomachina: Yes, up to a point
10:29:38 <merijn> xenomachina: You can provide default implementations (like the default implementations of == and /= in Eq)
10:30:20 <geekosaur> you can specify the types subject to defaulting, but not the typeclasses eligible for it
10:30:24 <dwcook> Hmm, is there a way to say "If this typeclass relation is also met, use these methods from it to implement this typeclass's methods"?
10:30:28 <Qfwfq> And defaults can be expressed in terms of other parts of the implementations, so there's a minimal overridable definition of each typeclass. E.g. 'mconcat = foldr mappend mempty'.
10:30:43 <dwcook> For example, fmap f x = pure f <*> x
10:30:54 <ReinH> Qfwfq: I've found often get useful things when you parameterize over an initial or terminal object, e.g. Free Void ~ Identity and Free () is a sort of "delayed computation" monad, iso to data Delay a = Now a | Later (Delay a)
10:30:59 <merijn> dwcook: Nope
10:31:06 <dwcook> Disappointing.
10:31:06 <ReinH> Qfwfq: or when you instantiate with same, rather
10:31:10 <rwbarton> there is something like that in a GHC extension
10:31:10 <n-dolio> xenomachina: You can put a top-level statement 'default (T1, T2, T3 ...)' in a module to specify the defaulting order for that module.
10:31:11 <kazagistar> wasn't there a ghc feature added recently that lets you specify complex minimal definitions?
10:31:17 <LT1MH> NSA
10:31:19 <dwcook> rwbarton: what's it called?
10:31:21 <merijn> dwcook: Well, you can get a part of the way
10:31:34 <xenomachina> Where can I see the default implementations of == and /= in Eq?
10:31:36 <Qfwfq> dwcook: Applicative is further down the hierarchy, though, I don't know how you'd express an Applicative constraint in that functor definition.
10:31:44 <merijn> dwcook: The DefaultSignatures extensions allows for default implementations that are *less* general than the actualy function
10:31:52 <rwbarton> DefaultSignatures
10:31:52 <ski> LT1MH : please try to stay on-topic
10:32:06 <dwcook> Sweet
10:32:14 <tomejaguar> LT1MH: If you're not a bot, please tell me what animal this is a picture of: http://i.imgur.com/riUVT6S.jpg
10:32:33 <merijn> dwcook: So, you can write "class PrettyPrint a where pretty :: a -> String; default pretty :: Show a => a -> String; pretty = show"
10:32:35 <etrepum> bitemyapp: http://ghcformacosx.github.io/
10:32:39 <j`ey> tomejaguar: a frog
10:32:41 <Qfwfq> tomejaguar: That's a simple computer vision problem, and a useless Turing test.
10:32:55 <ReinH> tomejaguar: but does it float on water?
10:33:02 <LT1MH> no
10:33:07 <merijn> dwcook: Note, that this does not allow "automatic" instances, you'd still have to write "instance PrettyPrint Int", but you could leave out the implementation, since Int is a Show instance
10:33:17 <ReinH> Qfwfq: I doubt most irc bots include computer vision algorithms...
10:33:20 <dwcook> merijn: right, that's all I wanted.
10:33:25 <tomejaguar> ReinH++
10:33:39 <merijn> dwcook: Also, you can combine this using Generic
10:33:41 <ReinH> Nor would I call much of anything a "simple" computer vision problem
10:34:09 <ReinH> Maybe perceptual hashing is a simple computer vision problem.
10:34:19 <ReinH> Detecting if an image contains a goat is not what I would call simple
10:34:31 <Qfwfq> I should say "one that's been solved with some success." And now I want to write an IRC bot to classify animal pictures.
10:34:39 <ReinH> Qfwfq: :p
10:34:41 <felixsch> :D
10:34:45 <ReinH> Qfwfq: I knew something productive would come from this discussion
10:35:24 <t4nk694> Need help!
10:35:26 <ReinH> So this probably-bot is frustratingly below the noise level that would warrant a kick :/
10:35:41 <ReinH> Which is probably by design
10:35:52 <newsham> oops, sorry for the earlier paste, was in the wrong window
10:36:01 <dwcook> ReinH: very high noise:signal proportion however
10:36:14 <ReinH> dwcook: indeed
10:36:15 <dwcook> s/proportion/ratio/
10:36:21 <ReinH> dwcook: plus it's got us adding to the noise now
10:36:30 <ski> xenomachina : <https://www.haskell.org/onlinereport/basic.html#sect6.3.1>
10:36:31 <dwcook> … It has won
10:36:34 <ReinH> indeed
10:36:36 <ReinH> moving on
10:36:36 <jle`> it is a noise production virus
10:36:36 <kazagistar> so, if its build for trolling it is successful
10:36:38 <n-dolio> So stop talking about it.
10:36:45 <ReinH> t4nk694: it's easier to provide answers if you ask questions :)
10:37:08 <ReinH> n-dolio: doing so
10:38:12 <kazagistar> stop talking about LT1MH? also did someone say [Thunderfury, Blessed Blade of the Windseeker]?
10:38:24 <kazagistar> ... sorry, I'm done
10:42:49 <xenomachina> ski: thanks. I was actually just reading th ghc implementation. I see it has a comment, "Minimal complete definition: either '==' or '/='.". Is that actually enforced by the compiler in any way, or is that just going to be a runtime error?
10:43:38 <ski> it's gonna be an infinite loop (or perhaps a space exhaustion)
10:43:39 <n-dolio> It is not enforced, but in 7.8 a feature was added to issue a warning.
10:44:19 <kazagistar> n-dolio: I remember seeing that, what was it called again?
10:44:48 <n-dolio> It is a pragma {-# MINIMAL ... #-}
10:46:44 <kazagistar> it is a bit surprising that it is only a warning...?
10:46:54 <xenomachina> thanks.
10:47:06 <xenomachina> Completely unrelated question: why does head throw an exception on empty lists rather than using Maybe?
10:47:14 <n-dolio> You can turn warnings into errors if you want.
10:47:42 <n-dolio> Also, fully implementing a type class is never enforced.
10:47:52 <n-dolio> Even if there are no defaults.
10:47:55 <prophile> xenomachina: history, I believe
10:48:08 <n-dolio> Head returning a maybe is pointless.
10:48:15 <Cale> xenomachina: If you wanted to handle the failure case, you'd be pattern matching anyway
10:48:18 <prophile> a lot of people want head to disappear entirely, at least for lists
10:48:18 <rwbarton> though, there is listToMaybe
10:48:23 <pjdelport> xenomachina: That's just how it's defined; there are other versions that return Maybe.
10:48:31 <pjdelport> :t listToMaybe
10:48:33 <lambdabot> [a] -> Maybe a
10:48:40 <Cale> You don't *usually* want head or tail, but they're very very convenient things to have when you *know* the list is nonempty.
10:48:44 <pjdelport> ^- That's basically a safe head
10:48:44 <etrepum> the Prelude isn't so careful about ensuring that all functions are total
10:48:49 <Cale> and they're part of idioms like  map head . group . sort
10:48:58 <kazagistar> xenomachina: if you want that, use Safe (https://hackage.haskell.org/package/safe-0.3.4/docs/Safe.html)
10:49:00 <merijn> xenomachina: In some case it can be useful to compose head in a functional pipeline where you know it will only get a nonempty list
10:49:25 <Cale> All the lists in the list that group produces are guaranteed to be nonempty, so it's perfectly safe to map head over that list
10:49:57 <rwbarton> there are lots of great partial functions, don't be afraid of partiality
10:50:05 <Cale> Using head/tail is like saying "I guarantee that this list will never ever be empty, and if it is, I don't mind my program being killed outright."
10:50:34 <rwbarton> however, if the question is "why is the name 'head' attached to the particular function that it is and not listToMaybe", then yeah that's ultimately a question of history
10:51:08 <kazagistar> clearly it would be more intuitive if it was called "car" <_<
10:51:10 <Qfwfq> Using head/tail means "my function isn't total, and so unsafe, and shouldn't be trusted"
10:51:19 <xenomachina> Cale: but I noticed that even pattern matching doesn't seem to enforce handling of all cases.
10:51:35 <geekosaur> hm?
10:51:45 <Cale> Qfwfq: The function may be total anyway!
10:51:45 <jle`> i think head and tail should just be moved to Data.List
10:51:47 <etrepum> xenomachina: compile with -Wall to get warnings about that
10:51:53 <Qfwfq> Pattern matching is a procedure for case analysis, totality should be provided by the case analysis.
10:52:07 <rwbarton> we don't have totality anyways
10:52:11 <Cale> Qfwfq: head and tail aren't total, but that doesn't mean they can't be used to build total functions
10:52:22 <xenomachina> Cale: for example, `myhead (x:_) = x` blows up with an exception when given an empty list just like head
10:52:31 <Cale> xenomachina: That is true
10:52:40 <Qfwfq> Cale: In the case you can guarantee the argument has length > 1, yeah.
10:52:43 <rwbarton> I can always just add a case "_ -> let loop = loop in loop"
10:52:55 <Cale> Qfwfq: and those are the only cases you're likely using head/tail in the first place
10:53:01 <jle`> xenomachina: at least in that case, it is more obvious that you intend a partial function
10:53:20 <Cale> > map head . group . sort $ "mississippi"
10:53:21 <lambdabot>  "imps"
10:53:32 <Qfwfq> Cale: That was an unfair generalisation. I'm in the habit of misusing them if I do at all, is the problem. :P
10:53:39 <geekosaur> xenomachina, if you have warnings enabled that pattern match will warn you that you are missing patterns
10:53:55 <Qfwfq> > map head . group . sort $ []
10:53:56 <Cale> Qfwfq: If you're not 100% sure, it's always better to use something like (\(x:xs) -> x)
10:53:56 <lambdabot>  []
10:54:04 <xenomachina> jle`: as a user of the function I don't see how that would be obvious.
10:54:17 <Cale> Qfwfq: Because when the lambda pattern match fails, you'll get a line number in the error at least :)
10:54:46 <Qfwfq> Cale: I've grown into the habit of defining Prelude.Maybe, and letting the 'Nothing's propagate up. But that's a neat hack.
10:54:48 <Cale> (of course, it's better still to use case to match properly and handle the failure, but there are cases where you're almost entirely sure)
10:54:53 <Qfwfq> Prelude.Safe, rather.
10:54:55 <xenomachina> geekosaur: can I enable these sorts of warnings in ghci?
10:55:27 <rwbarton> letting Nothings propagate up is the worst of all worlds
10:55:42 <geekosaur> xenomachina, seems to work (I tried :set -Wall)
10:55:51 <Qfwfq> Anyway, I've papers to read before tomorrow. Love to all.
10:55:54 <rwbarton> because (a) you have to write a bunch of extra code to handle a condition that should be impossible, (b) when the condition turns out to be possible after all (due to a bug) you still don't know what caused it
10:56:01 <Cale> Yeah, sometimes the lambda match failure with the line number in it is a better result than getting Nothing and having no idea why
10:56:13 <Cale> (because it could have come from many different places)
10:56:38 <Cale> Of course, it means that your program was terminated, but sometimes that's acceptable
10:56:52 <kazagistar> I took up the habit of using "error "This case should never happen because..."" :P
10:57:38 <xenomachina> geekosaur: thanks!
10:58:12 <rwbarton> :t mapException
10:58:13 <lambdabot> (Exception e2, Exception e1) => (e1 -> e2) -> a -> a
11:01:11 <yogurt_truck> why can't one reason by induction in Haskell?
11:02:02 <yogurt_truck> because haskell doesn't actually have _inductive_ types like, say, Coq does?
11:02:21 <n-dolio> One can. Just not by set induction.
11:02:21 <dwcook> yogurt_truck: undefined :: forall a. a
11:02:29 <dwcook> Wait, I misread
11:02:38 <n-dolio> Because types in Haskell aren't sets.
11:03:58 <yogurt_truck> right
11:04:04 <ski> coinduction ?
11:05:08 <yogurt_truck> dwcook: it started because I ranted against people who are against haskell for introductory teaching
11:05:17 * hackagebot metadata 0.2.0.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.2.0.0 (KatsutoshiItoh)
11:05:18 <yogurt_truck> dwcook: then someone got bob harper involved :D
11:06:07 <mmachenry> yogurt_truck: What are your points backing up Haskell for intro teaching?
11:06:29 <mmachenry> What languages being used to teach now would you say are worse and why?
11:06:32 <yogurt_truck> dwcook: and I was just given this https://twitter.com/jonsterling/status/469898658696028161
11:08:07 <yogurt_truck> mmachenry: I like that there aren't lots of annoying obstacles I have to get through in order to explain basic concepts of computation to others
11:08:27 <napping> yogurt_truck: I'm not sure that's even true - you should be able to reason by induction on finite inputs if you remeber to consider bottom
11:08:32 <yogurt_truck> mmachenry: compared to something like, say, Javascript, where I don't even have tools for making abstractions
11:08:59 <yogurt_truck> mmachenry: or I can't even "pretend" to have inductive types
11:09:27 <napping> and I think infinite input is covered by finite approximations, though I'm not sure if you need to explicitly appeal to continuity in places
11:10:02 <napping> I think harper is just upset that what you have to reason on by induction isn't just the cases you wrote because there are bottoms
11:10:16 <mmachenry> yogurt_truck: How do you feel about Scheme vs. Haskell for an intro class?
11:10:19 * ski realizes that "jonsterling" (probably) isn't some kind of play on "monsterling"
11:10:54 <n-dolio> Yes, it's more complicated induction.
11:11:12 <n-dolio> Prove P for bottom, prove P for your constructors, prove P for limits.
11:11:29 <napping> yogurt_truck: and because expressions can certainly fail to terminate even in a strict language, you can't pretend ML is total either, if you care about ever actually writing and reasoning about programs
11:11:45 <napping> like, justifying equational reasoning principles and stuff
11:11:51 <vanila> you can pretend it is total
11:11:57 <yogurt_truck> mmachenry: also, I think there's demonstration of Haskell being ultra friendly for beginners, in things like Hudak's Haskell School of Music, and in the super light intro to computing by Chakravarty http://chak.web.cse.unsw.edu.au/papers/intro-computing.pdf
11:12:15 <napping> then again, not minding a side-effects either, I guess harper doesn't care about equational laws holding on code either
11:12:47 <napping> So the induction you have to do in Haskell to account for laziness is more or less what you'd have to do anyway if you actually wanted to reason about the validity of transformations on code
11:13:05 <yogurt_truck> napping: I see
11:13:21 <Kerry-Anne18>  Here some videos. I hope you like them! http://bit.ly/S0CEdA
11:13:39 <rwbarton> clearly Coq and Agda are the only languages suitable for teaching new programmers
11:14:00 <kazagistar> I would prefer scheme just to get syntax out of the way faster
11:14:08 <napping> and if you are willing to pretend things are total, you can do that just as well in Haskell
11:14:29 <bbopen> yogurt_truck mmachenery: I like this 10 minute intro the best https://www.youtube.com/watch?v=RqvCNb7fKsg
11:14:35 <kazagistar> though, I still stand by the idea that lua is a quite excellent language for introduction
11:14:35 <MitchellSalad> welp, don't click Kerry-Anne18's link if you are at work
11:14:51 <MitchellSalad> fortunately I'm in a public coffee shop so I'm safe
11:15:04 <bbopen> rwbarton: will Coq help me pass a Real Analysis course?
11:15:05 <napping> MitchellSalad there's been a fair amount of spam like that recently
11:15:11 <rwbarton> heh
11:15:24 <MitchellSalad> i thought it would be haskell videos =(
11:15:34 <napping> bbopen: maybe you'll learn great theorems like that every function defined on an interval is continuous on that interval
11:16:09 <napping> Isabelle might be better if you want to actually pass the real analysis class :)
11:18:37 <ski> n-dolio : hm, istr Sparkle <https://web.archive.org/web/20110807103851/http://www.cs.ru.nl/Sparkle/> had such induction
11:19:03 <n-dolio> ski: That would make sense.
11:19:17 <kazagistar> bbopen: that video is the video, along with a nice Rich Hickey video, is what finally got me into haskell
11:19:23 <n-dolio> Man, this is some late 90s web design.
11:19:30 <ski> (Sparkle was a theorem prover for Clean)
11:19:55 <yogurt_truck> n-dolio: right, so I can still do some "pretending" and teach inductive reasoning in introductory Haskell, can't I? that's what HSoM and intro-computing do
11:19:57 <ski> n-dolio : isn't it beautiful ? ;)
11:19:58 <kazagistar> this one: http://www.infoq.com/presentations/Simple-Made-Easy
11:20:33 <ski> kazagistar : Scheme is nice
11:20:40 <n-dolio> yogurt_truck: Yes, you can pretend.
11:20:49 <n-dolio> You can even write types that are almost like sets.
11:20:57 <napping> yogurt_truck: you could also teach Agda :)
11:20:57 <n-dolio> Although most people don't do that.
11:21:44 <n-dolio> If you only care about total, finite values (that's what you're pretending), then there's no reason you can't use induction.
11:21:52 <n-dolio> Or, normal set induction.
11:22:20 <ski> functions values are commonly not finite
11:22:31 <n-dolio> You can't do induction on functions anyway.
11:23:16 <ski> well, you can try doing induction on modulus of continuity, like Escardó
11:23:33 <n-dolio> Functions are where things get weird in the languages that people tout as being good for doing induction, anyway.
11:23:39 <n-dolio> Because they lift their codomain.
11:23:48 * ski nods
11:23:58 <napping> n-dolio: do you mean strict languages, or total?
11:23:59 <n-dolio> Or, non-total languages.
11:24:04 <n-dolio> Strict and non-total.
11:24:14 <napping> yeah
11:24:28 <n-dolio> Some languages genuinely are good. :)
11:25:01 <savanni> Is there a way for me to, given a particular label, ask ghc how evaluated that label is?  It's the kind of thing that could be helpful for me in understanding the degree of laziness in my code.
11:25:47 <Cale> savanni: You can use :print in ghci
11:27:11 <savanni> Cale: Thanks!  I didn't know about print.
11:31:10 <hunt> is there a nice way to tell where a number lies realtive to a range using Ord?
11:33:53 <kazagistar> hunt: that is what Ix is for
11:35:18 <kazagistar> the Ix typeclass has range :: (a, a) -> [a], index :: (a, a) -> a -> Int, etc
11:38:41 <kazagistar> (I still think that Ix is missing a findBounds :: [a] -> (a, a))
11:42:22 <awestroke> @instances Ix
11:42:24 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
11:42:52 <kazagistar> @help instances-importing
11:42:52 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
11:43:53 <kazagistar> @instances-importing Data.Ix Ix
11:43:55 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
11:44:28 <awestroke> range 1 (-1)
11:44:32 <awestroke> > range 1 (-1)
11:44:34 <lambdabot>  Couldn't match expected type ‘a1 -> t’ with actual type ‘[a0]’
11:44:47 <awestroke> > range (1, (-1))
11:44:49 <lambdabot>  []
11:46:01 <kazagistar> > rangeSize ( (1, False), (5, True) )
11:46:02 <halvorg> hm, is it hard to pass a struct to GLSL through openGL? (c) floats and ints is trivial, but I guess I have to make my own data type for each struct?
11:46:03 <lambdabot>  10
11:46:07 <bitemyapp> etrepum: pretty. Could the PATH instructions be added to the website as well?
11:46:12 <bitemyapp> etrepum: am I clear to start posting this?
11:46:29 <etrepum> bitemyapp: I'd rather not, since it's dependent on where they move it to
11:46:45 <etrepum> bitemyapp: yeah, I went ahead and posted it already
11:46:55 <bitemyapp> etrepum: fair enough, do the instructions it gives depend on where it was placed?
11:47:10 <etrepum> bitemyapp: yes
11:47:19 <bitemyapp> etrepum: awesome. That's pretty much perfect then. :)
11:47:23 <bitemyapp> etrepum: posting it on twitter.
11:47:36 <f-a> is there a way to bind shortcuts key in ghci (I am using debian linux). I would like, as an example, C-c to call :!clear
11:47:41 <etrepum> bitemyapp: https://twitter.com/etrepum/status/469907092523216896
11:48:12 <bitemyapp> etrepum: this is great, thank you so much.
11:48:25 <fss7546> I'm trying to install shpider with cabal, but it tells that these packages are likely to be broken by reinstalls: parsec-3.14, network-2.4.1.2, HTTP-4000.2.8
11:48:37 <fss7546> what would be the best thing to do in order to install it?
11:49:00 <dmwit> f-a: I think it uses readline, so check out readline's documentation maybe?
11:49:06 <geekosaur> f-a: no, and ctrl-c would be a bad choice anyway since it's the system interrupt character unless you changed it
11:49:09 <dmwit> f-a: I'm pretty sure there is a readline config file that gets loaded and used.
11:49:20 <geekosaur> dmwit: not for a while, and haskeline is much simpler
11:49:27 <dmwit> Ah, too bad.
11:49:28 <bitemyapp> etrepum: so, we've got a good story for Ubuntu and the Mac. I could probably contrive one that works for non-Ubuntu Linux users but realisically - do they need the help>
11:49:31 <bitemyapp> ?
11:49:33 <geekosaur> (readline posed too many portability problems on windows and os x)
11:50:17 <etrepum> bitemyapp: sometimes they do, especially if they go down the road of installing from some horrible distro that breaks GHC into a million pieces
11:50:21 <bergey> halvorg: I've used vinyl-gl to marshal points, matrices and stuff between Haskell and GLSL.
11:50:48 <f-a> thanks geekosaur and dmwit
11:51:08 <bergey> I haven't tried defining more complicated structs.  I assume it's possible, but just grouping a bunch of (named) V3s is pretty close to a struct.
11:51:09 <f-a> I think I recall having the option on win, but whatever, I can live w/o it
11:52:15 <halvorg> bergey: v3s and primitives are no problem. But I need an array of structs, dunno where to start really.
11:52:49 <rwbarton> f-a: rebind your brain, use C-l to clear :)
11:53:17 <f-a> oh, so there *is* something like that
11:53:29 <f-a> rwbarton: thanks, I must have missed it reading the documentation
11:53:52 <geekosaur> I suspect you need the docs for haskeline instead of the docs for ghci
11:53:55 <benbangert> etrepum: how does the .app interact with haskell platform? or should I remove haskell platform pkg first?
11:53:56 <rwbarton> Well, I have no idea whether it is documented anywhere
11:55:31 <bergey> halvorg: https://github.com/acowley/GLUtil/blob/master/src/Graphics/GLUtil/BufferObjects.hs has code to buffer arbitrary Storables.  Can you write a Storable instance for your struct?
11:55:51 <skypers> openFile: resource exhausted (Too many open files)
11:55:52 <skypers> :(
11:56:02 <skypers> is this a platform limitation, or the GHC runtime?
11:56:16 <halvorg> I think so bergey, that looks great thanks.
11:56:45 <geekosaur> skypers, it could be your ulimits, it could also be that your program is leaking file descriptors due to laziness
11:57:12 <skypers> geekosaur: yeah well
11:57:14 <skypers> I use readFile
11:57:16 <skypers> and it’s lazy
11:57:21 <skypers> in a recursive function
11:57:25 <skypers> so I guess it leaks out
11:57:40 <napping> you only read part of the file?
11:57:50 <skypers> the whole
11:57:53 <skypers> not a part
11:58:15 <napping> If you consume the whole output, it should eventually get collected and closed
11:58:32 <skypers> yeah well
11:58:41 <skypers> I don’t _really_ consume the whole thing right now
11:58:50 <skypers> I read the file till I encounter a special line
11:58:52 <napping> well, that's the problem
11:58:58 <skypers> then I return the parsed line, and the rest of the file
11:59:00 <skypers> ok
11:59:08 <napping> if you don't finish reading it but hold onto the contents, the handle remains open
11:59:09 <skypers> so hm, I have to put some strictness in there?
11:59:13 <kxra> kazagistar: on the note of an explainshell.com for haskell, i just discovered this and the projects in the "similar efforts" section: http://peaker.github.io/lamdu/
11:59:23 <skypers> napping: yeah, but why does it leak?
11:59:33 <skypers> it eventually closes at some point, right?
11:59:34 <geekosaur> that's a long story
11:59:35 <napping> because the returned string is really some kind of fancy unsafeInterleaveIO thing that only reads from disk as you demand valueds
11:59:47 <geekosaur> it closes when you have evaluated the last character of the file
11:59:56 <napping> yeah, but if you're returning the rest of the file, and hanging on to a lot of values like that, you are keeping lots of files open
12:00:07 <c_wraith> still, the default fd limit is like 1024
12:00:17 <napping> now if you are not keeping those references very long, it's possible the GC is just not keeping up
12:00:18 <geekosaur> and the string is lazy, so if you return "the rest of the file", it's a thunk that will keep reading from the file as contents are demanded
12:00:20 <c_wraith> You need to be opening files in a loop to do hit that, more or less
12:00:28 <geekosaur> this is why lazy I/O is dangerous
12:00:34 <skypers> c_wraith: it’s in a recursive function
12:00:38 <skypers> launched on my ~
12:00:40 <kazagistar> kxra: yeah, I've seen lamdu before, unfortunately I failed to compile it and the last commit to master was last year
12:00:40 <skypers> so yeah
12:00:43 <skypers> not surprising
12:00:58 <napping> so I don't see how you would be saving all the tails of the file
12:01:07 <napping> unless your recusive function builds a bit tree or something?
12:01:19 <napping> why do you even return the rest?
12:01:23 <kxra> kazagistar: seems like light table is in good shape and someone has been maintaining a haskell plugin for it
12:01:25 <skypers> napping: well
12:01:25 <napping> a big tree
12:01:31 <skypers> I handle resources in files
12:01:34 <skypers> there’s a header
12:01:40 <skypers> for each file representing a resource
12:01:52 <skypers> I use it to determine the name and the type of the resource
12:02:00 <skypers> then I take the rest of the file
12:02:07 <skypers> and I pass that to the corresponding parser
12:02:16 <skypers> in order to obtain a value
12:03:02 <skypers> yeah well
12:03:08 <skypers> no, I’m mistaken
12:03:12 <skypers> in the first pass
12:03:21 <skypers> I sort files by resource types reading the header
12:03:38 <skypers> yeah, quite the same thing
12:03:42 <napping> so that's basically a first pass that returns a header plus an open file descriptor to each resource
12:03:53 <halvorg> bergey: https://github.com/acowley/GLUtil/blob/master/src/Graphics/GLUtil/Linear.hs#L58, hm could I just pass multiple lists of vectors using this?
12:03:54 <napping> and you're just legitimately running up against system resource limits
12:03:56 <skypers> napping: some kinda that, indeed
12:04:12 <napping> maybe not realizing that's what you were doing because it was hidden behind lazy IO
12:04:13 <skypers> I guess I can use withFile?
12:04:42 <etrepum> benbangert: it shouldn't interact with the haskell platform, different versions of GHC so they don't install to the same folders inside ~/.ghc and ~/.cabal
12:04:43 <skypers> or is withFile lazy as well?
12:04:45 <rwbarton> you still need to use strict IO, also
12:04:52 <napping> If you use something like hGetContents in it, and return it from the withFile before it's entirely forced, you'll get an error later on when you try to read too far
12:04:52 <shapr> @get-shapr
12:04:52 <lambdabot> shapr!!
12:04:56 <kxra> kazagistar: https://github.com/jetaggart/light-haskell
12:04:56 <shapr> INFINITE LOOP
12:04:59 <etrepum> benbangert: so it shouldn't matter, as long as you put the one you want on the PATH first, then that should be it
12:05:09 <benbangert> etrepum: ah cool. a bunch of packages fail to install with, "requires Cabal library version
12:05:09 <napping> maybe better to just return the header info and the filename and reparse?
12:05:12 <benbangert> >=1.19.2 && >=1.6 but no suitable version is installed."
12:05:22 <benbangert> etrepum: is there something special I need to add?
12:05:22 <napping> or parse it in the first place?
12:05:26 <hae> light-haskell. I need this in my life.
12:05:29 <etrepum> benbangert: I'm gonna need more information than that.
12:05:41 <skypers> napping: I can’t parse in the first place
12:05:51 <skypers> I want my stuff to be really simple
12:05:53 <skypers> so basically
12:05:59 <skypers> you ask my engine to load resources
12:06:05 <skypers> it first sorts resources by type
12:06:16 <skypers> in order to break dependencies cycles
12:06:21 <rwbarton> (or write the super smart IO manager that gets around open filehandle limits!! I sort of want to do this using the trick of passing fds over unix sockets)
12:06:23 <skypers> and then parses the less dependent resources
12:06:25 <skypers> and so on
12:06:59 <skypers> in my case
12:07:07 <Pythonfant> I get this line “unix-2.7.0.1 (reinstall) changes: bytestring-0.10.4.0 -> 0.10.2.0” when trying to install http-streams. Can I somehow avoid downgrading bytestrings?
12:07:10 <skypers> my project doesn’t have that many files
12:07:19 <skypers> but in theory, it’d be better to have something simpler
12:07:20 <benbangert> etrepum: try to install mmorph
12:07:26 <skypers> maybe you’re right
12:07:29 <skypers> I should get the header
12:07:30 <Pythonfant> or the reinstall of unix-2.7.0.1
12:07:33 <skypers> and the path
12:07:36 <skypers> and reparse
12:07:37 <Pythonfant> I have exactly the same version installed
12:07:58 <skypers> because keeping the rest of the file is not a great idea
12:08:05 <skypers> if I have a lot of heavy files
12:08:10 <rwbarton> Pythonfant: can you paste the entire output of the cabal install command you're trying to do -- lpaste.net
12:08:13 <skypers> which is very likely since it’s a 3D engine
12:08:26 <skypers> I’ll destroy the RAM :D
12:08:38 <benbangert> etrepum: ah, its an issue with the lovely gcc, need to switch it to the right one
12:08:45 <Pythonfant> rwbarton: http://lpaste.net/104523
12:09:06 <etrepum> benbangert: it should all work with just clang, since we're on 7.8.2
12:09:23 <Pythonfant> I tried using --force-reinstall but I ended up with conflicts between the two bytestring versions
12:09:29 <skypers> hm
12:09:36 <skypers> I ran that in a very small directory
12:09:36 <benbangert> etrepum: this is the error, http://paste.ofcode.org/qv8eM9QvMv7g358Qej2Eqj
12:09:39 <skypers> still the same issue
12:09:53 <skypers> though I use a filterM to discard "." and ".."
12:09:58 <skypers> it’s weird
12:10:07 <rwbarton> Pythonfant: hmm I get the same behavior
12:10:19 <etrepum> benbangert: what's the output of "which cabal; which ghc"?
12:10:31 <Pythonfant> rwbarton: I don't really understand why it's trying to reinstall anything
12:10:40 <skypers> ok, away ; thank you for your help
12:10:43 <benbangert> etrepum: the right ones, in the ghc-7.8.2 app
12:10:45 <rwbarton> Pythonfant: it looks like it will work though with "cabal install http-streams --constraint='bytestring ==0.10.4.0'"? which is very odd
12:11:04 <etrepum> benbangert: are you in a sandbox there?
12:11:08 <benbangert> yup
12:11:18 <etrepum> benbangert: try nuking the sandbox
12:11:31 <etrepum> benbangert: rm -rf .cabal-sandbox cabal.sandbox.config; cabal sandbox init
12:11:41 <Pythonfant> rwbarton: thx, that seems to work.
12:11:46 <Pythonfant> any idea what could cause this?
12:11:52 <benbangert> etrepum: yea, same thing
12:12:03 <Pythonfant> I workaround is nice but I'd like to know why this problem occurs in the first place
12:12:13 <etrepum> benbangert: what's "gcc --version" do?
12:12:22 <benbangert> etrepum: i686-apple-darwin11-llvm-gcc-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
12:12:50 <etrepum> benbangert: that doesn't look right, I expect to see clang there
12:13:11 <etrepum> benbangert: Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)
12:13:16 <benbangert> hmm
12:13:26 <etrepum> benbangert: do you have Xcode 5 installed?
12:13:45 <jfischoff> I also have what etrepum has (clang)
12:13:56 <benbangert> etrepum: apparently not
12:14:11 <rwbarton> Pythonfant: not really. I would guess maybe something has a flag on the version of bytestring and cabal is picking the value we don't want. Ask on #hackage
12:14:22 <etrepum> benbangert: it's possible you might also be overriding it with some homebrew stuff or something if you do have Xcode 5 installed
12:14:30 <Pythonfant> rwbarton: ok
12:14:46 <etrepum> benbangert: make sure "which gcc" is /usr/bin/gcc
12:14:52 <benbangert> yea, it is
12:15:05 <benbangert> installing xcode now, see if that fixes it
12:16:29 <jfischoff> is unix an upgradeable package? reinstalling it against other versions of ByteString seems probablematic.
12:17:14 <jfischoff> oh wait I don't think it is " The following packages are likely to be broken by the reinstalls: ... ghc ..."
12:17:56 <jfischoff> "Use --force-reinstalls if you want to install anyway." should be changed to something more informative
12:18:36 <rwbarton> I mean, in some sense cabal found a valid build plan, it's just that some build plans are more valid than others...
12:19:52 <jfischoff> I assume if you break the ghc package you are also breaking ghc in some way (most likely at least)
12:20:14 <rwbarton> right it's certainly a Bad Idea
12:21:16 <jfischoff> what are the valid use cases of --force-reinstalls? You are reinstalling your own packages into a sandbox?
12:21:19 <roconnor> "Use --force-reinstalls if you want to break every other package"
12:21:52 <bvad> Evening guys, I'm going from an imperative background and I'm trying to learn how to do things in a purely functional way, but I'm having an issue trying to translate my mental model of a system I've written into a functional style.. How would you typically handle a system that is driven by external 'events' such as data on a serial port or network connection?
12:21:54 <jfischoff> "Use --force-reinstalls if you would like nothing to work anymore"
12:23:08 <jfischoff> bvad: you would seperate it into a pure "logic" piece and then some imperative glue, is the typical way. There are other less popular more "functional" ways
12:23:45 <jfischoff> by imperative I mean writing code in the IO monad that looks like what you would write in any other language
12:24:00 <bvad> jfischoff: Okay, I guess I was not too far off then
12:24:20 <benbangert> etrepum: think its working now, though its odd that the -j8 flag that worked fine before now makes things explode
12:24:27 <benbangert> when installing
12:24:33 <jfischoff> I think one different is Haskell has a great STM solution
12:24:42 <bvad> jfischoff: But I'm having trouble understanding how you would do your typical "polling read thread" in the IO monad
12:25:16 <jfischoff> like for a tcp server?
12:25:17 <dwcook> bvad: I think in general you'd use blocking operations and threads rather than polling
12:25:28 <jfischoff> bvad:^
12:25:39 <etrepum> benbangert: how would I reproduce that?
12:26:02 <dwcook> bvad: you might be familiar with threads in other languages, but don't be afraid. Haskell threads are quite nice
12:26:04 <benbangert> etrepum: well, my gozer repo, make sandbox, cabal install -j8 --only-dependencies --allow-newer=base
12:26:07 <bvad> dwcook, jfischoff: Thanks!
12:26:19 <jfischoff> bvad: kick off a thread and block on the read
12:26:36 <bvad> dwcook: I'm not really afraid of threads, I'm just afraid to push my own imperative ideas into a place it doesn't fit :)
12:26:37 <jfischoff> bvad: you should read PCPH
12:26:46 <bvad> jfischoff: PCPH?
12:26:56 <rwbarton> is there a guide somewhere to interpreting the strictness information in interface files?
12:27:05 <rwbarton> e.g. what does " Strictness: <L,1*U(U,U,U,U,U,U,U,U,U,U,U)>m" mean
12:27:11 <jfischoff> bvad: http://chimera.labs.oreilly.com/books/1230000000929/ch12.html#sec_server-trivial
12:27:20 <bvad> jfischoff: Thanks a lot! :)
12:27:52 <jfischoff> bvad: that is currently the best Haskell book IMO
12:28:07 <etrepum> benbangert: the one on groovie or is it somewhere else now?
12:28:19 <benbangert> etrepum: the one on groovie is fine
12:28:24 <bvad> jfischoff: I'll make sure to read it after I feel I'm done with RWH
12:29:14 <benbangert> etrepum: its on github as well, https://github.com/bbangert/gozer
12:29:16 <jfischoff> PCPH doesn't really cover the syntax of the language, but is more "Real World" then RWH IMO
12:30:01 <jfischoff> bvad: Also I wouldn't worry about finishing RWH
12:30:20 <bvad> jfischoff: How come?
12:30:27 <benbangert> etrepum: is there a list of Haskell Platform libs so I can cabal install those for my user with ghc 7.8? (don't want to keep installing these in every sandbox)
12:30:28 * hackagebot hsbencher 1.8.0.4 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.8.0.4 (RyanNewton)
12:30:30 * hackagebot hsbencher-fusion 0.1.0.0 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.1.0.0 (RyanNewton)
12:30:32 <bvad> I feel like the whole JSON part of the book was a bit off
12:30:46 <bvad> But other than that it has been a great read
12:30:50 <jfischoff> its a little out of date lots of disconnected material
12:31:05 <jfischoff> FWIW it is what I started with
12:31:05 <etrepum> benbangert: yeah, although the best advice I've gotten on that is to just do "cabal install lens --enable-library-profiling", which pretty much pulls in the universe that you would care about
12:31:16 <koala_man> haha
12:32:11 <etrepum> benbangert: https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal
12:32:16 <benbangert> etrepum: lol, ok
12:32:51 <etrepum> benbangert: that advice was from edwardk himself at BayHac, I was surprised but I've been trying it and it seems to mostly work :)
12:33:15 <bvad> jfischoff: The chapter you linked in PCPH looks very interesting!
12:33:22 <bitemyapp> jle`: jle.im is you?
12:33:28 <bitemyapp> jle`: if so, very good post :)
12:33:38 <dwcook> etrepum: you reminded me of this article, which suggests putting the enabling profiling flag in your config http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
12:34:10 <jfischoff> bvad: good explaination of lazyness http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
12:34:28 <etrepum> dwcook: yeah, that's a reasonable thing to do as well
12:34:31 <bvad> jfischoff: I should probably just start from page one :D
12:34:42 <edwardk> etrepum: hahaha
12:34:55 <etrepum> jfischoff: I have linked to that section like a thousand times in exercism.io code reviews
12:35:11 * jfischoff nods
12:35:17 <ski> kazagistar : interesting presentation
12:35:23 <etrepum> benbangert: sadly I wasn't able to make -j8 explode here…
12:35:29 * hackagebot xdot 0.2.4.3 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4.3 (DennisFelsing)
12:35:31 * hackagebot ghc-vis 0.7.2.2 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.7.2.2 (DennisFelsing)
12:35:48 <mm_freak_> hi there…  i'd like to announce this here as well:  http://hub.darcs.net/ertes/fuse/
12:36:01 <mm_freak_> since it's not yet going on hackage
12:36:04 <jfischoff> bvad: you can probably skip all the parallel stuff. Not as practical as the concurrent stuff
12:36:22 <jle`> bitemyapp: it is me, and thanks :)
12:36:44 <bvad> jfischoff: I just really enjoy reading about Haskell, so I'm not sure I will
12:36:54 <jfischoff> :)
12:37:24 <ski> bvad : post ?
12:37:55 <bvad> ski: Post what? :o
12:38:12 <jfischoff> ski: PCPH by Marlow
12:38:13 <ski> bvad : exactly, what post ?
12:38:21 <bvad> ski: what jfischoff said
12:38:35 <mm_freak_> the final step is to improve the breakByte function for ByteString
12:38:57 <jle`> mm_freak_: interesting
12:39:04 <mm_freak_> the last step to achieving C performance with high-level stream processing
12:39:33 <bitemyapp> jle`: well explained, very attractive and easy to read. Approachable.
12:39:40 <bitemyapp> jle`: demonstrates the pain of not doing things right well.
12:40:14 <ski> bvad,jfischoff : the whole book, or those particular chapters ?
12:40:30 <mm_freak_> jle`: i'm interested in whatever bitemyapp is talking about =)
12:40:52 <bvad> ski: jfischoff was recommending me some chapters :) I'm probably going to read most of the book though
12:41:18 <jfischoff> ski: I think the first and last chapters are more valuable then the middle chapters
12:42:04 <jfischoff> Basically parallel stuff I think is less useful then the lazyness, exception, async, stm stuff
12:42:22 <jle`> bitemyapp: thanks :) i did struggle a lot with verbosity and finding that balance, and i'm not altogether satisfied with how long the last one ended up.  i have been silently removing/rewriting things here and there.
12:42:31 <jle`> jfischoff: unless you're in scientific computing maybe :)
12:43:17 <jfischoff> possibly, but even then one of the points of the book is that it most efficent to perform parrallization at the highest level
12:44:06 <jle`> ah
12:44:31 <jle`> mm_freak_: he's talking about my last blog post heh.
12:44:45 <jle`> mm_freak_: the fuse library seems interesting; i'll be looking over the source this weekend
12:44:47 <jle`> :)
12:45:01 <jle`> the API is appealing
12:45:57 <mm_freak_> jle`: thanks, and i must have missed your tweet…  reading it now =)
12:46:19 <mm_freak_> jle`: the most appealing thing about fuse is this:  yield (yield 1 >> yield 2) >> yield (yield 3 >> yield 4)
12:46:26 <mm_freak_> which corresponds to [[1, 2], [3, 4]]
12:46:32 <mm_freak_> and is horribly difficult to express with pipes
12:47:00 <mm_freak_> (or equivalently:  each [each [1, 2], each [3, 4]])
12:49:27 <etrepum> I wonder how many of these pipes/conduit/machines/fuse libraries we'll end up with :)
12:49:56 <jfischoff> I don't understand why the streaming libraries use data types instead of continuation passing style encodings
12:50:21 * monochrom is stunned at "yield (yield 1 >> yield 2) >> yield (yield 3 >> yield 4)". great cunning code.
12:51:19 <warpy> is pipes/conduit good for writing a streaming parser?
12:51:29 <warpy> is there one already?
12:51:57 <alpounet> yeah there are a few parsers for common formats (csv, json)
12:52:08 <alpounet> conduit has some for html/xml too and probably other formats
12:52:10 <joebobjoe> Hi. Can anyone explain what a Trampoline is to me? I've read a couple articles and I don't understand.
12:52:22 <jfischoff> why the capital T?
12:52:23 <mm_freak_> jfischoff: because the CPS-transformed version was slower and a lot more awkward to work with
12:52:26 <Fuuzetsu> only -h profiling option is available to be but none of the variants (-hm, -hd, …), what did I screw up? 7.6.3, profiling executable
12:52:39 <mm_freak_> jfischoff: initially i started with F (from 'free')
12:52:53 <mm_freak_> warpy: yes and yes
12:53:08 <n-dolio> Slower for what?
12:53:27 <mm_freak_> warpy: attoparsec and trifecta support incremental parsing and are easy to turn into consumers/sinks
12:53:31 <monochrom> jfischoff: could be worse. I was in math channels where people wrote "I have a homework question in ALGEBRA"
12:53:33 <n-dolio> There's usually some things it's slower for and other things it's faster for.
12:54:01 <edwardk> attoparsec is much better at incremental parsing than trifecta .. for now ;)
12:54:01 <n-dolio> So you need both.
12:54:15 <jfischoff> monochrom: :)
12:54:24 <mm_freak_> warpy: for some applications pipes may be a better choice, because it allows you to delimit a stream (pipes-group)
12:54:47 <mm_freak_> conduit allows something similar, but with a more awkward API:  resumable sources
12:54:49 <jfischoff> mm_freak: that surprises me, because there is only perform one traversal
12:54:59 <jfischoff> s/only perform/only
12:55:56 <n-dolio> joebobjoe: A trampoline is a technique for implementing proper tail calls, where instead of functions calling other functions in the tail position, they arrange to return a reference to the function they want to call, and then you run such things in a loop that doesn't use any stack.
12:56:14 <n-dolio> Or something roughly like that.
12:56:14 <jfischoff> mm_freak: ah the church encoded free monad
12:56:26 <mm_freak_> jfischoff: you do mean this, don't you:  newtype List f m r = List { foldList :: forall a. (m (List f m r) -> a) -> (f (List f m r) -> a) -> (r -> a) -> a }
12:57:20 <mm_freak_> jfischoff: or do you mean the fully church-encoded variant?
12:57:26 <jfischoff> mm_freak: I haven't thought through the details
12:57:42 <monochrom> joebobjoe: I have an example of trampolining in javascript. see its source code. http://www.vex.net/~trebla/tail.html
12:57:53 <mm_freak_> jfischoff: the alternative is something like this:  newtype List f m r = List { foldList :: forall a. (m a -> a) -> (f a -> a) -> (r -> a) -> a }
12:58:04 <jfischoff> whenever I see a data structure being made and then immediantly destroyed I think, "that's not right"
12:59:08 <mm_freak_> jfischoff: i'll try the head-transformed variant (the former)
12:59:22 <mm_freak_> it might give me a slight speed improvement at the expense of a more awkward API
13:00:08 <mm_freak_> the fully transformed variant is just too difficult to work with…  for example 'take' would be very difficult to write
13:00:11 <jfischoff> well full disclosure I don't really know this stuff, but I would be interested in understanding the results
13:01:02 <jfischoff> probably tail is hard too
13:01:54 <mm_freak_> jfischoff: well, to explain why stream processing abstractions use ADTs:  it makes the interface a lot nicer and there isn't really a speed difference
13:02:29 <jfischoff> fair enough
13:02:50 <ReinH> mm_freak_: Hmm, one of those is coyoneda?
13:03:07 <ski> ReinH ?
13:03:34 * ski ponders how to write `take' on church lists
13:03:54 <mm_freak_> ReinH: i don't think so, but might be by accident
13:04:12 <mm_freak_> i really just right-fold-CPSed the list
13:04:35 <mm_freak_> ("list" being something abstract)
13:04:38 <ReinH> mm_freak_: Hmm, so Cont is similar to Codensity...
13:04:51 <mm_freak_> ReinH: codensity is cont without cont effects
13:04:55 <ReinH> right
13:05:06 <ReinH> without callcc basically?
13:05:16 <mm_freak_> yeah, and without abort, etc.
13:05:20 <ReinH> right
13:05:34 * hackagebot http-test 0.2.1.0 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.1.0 (glutamate)
13:05:39 <mm_freak_> it only makes sure that (>>=) is right-associated, but this is not an issue with stream processing
13:05:50 <ReinH> mm_freak_: right
13:05:56 <warpy> mm_freak_: say there is a stream which has multiple items in parts but they are interleaved
13:06:01 <warpy> how would you parse that
13:06:29 <mm_freak_> warpy: you mean like "(x1, y1, z1), (x2, y2, z2), …"?
13:06:37 <ReinH> edwardk: I need to get that notebook from you :)
13:06:59 <edwardk> ReinH: the fm-index notes?
13:07:06 <mm_freak_> warpy: where you want to get x1, x2, etc.
13:07:07 <warpy> mm_freak_: like "A a B b C c" where upppercase letters are parts of one message and lowercase letters are part of another message
13:07:11 <ReinH> edwardk: and the codensity notes
13:07:32 <edwardk> ReinH: remind me later and i'll snap pics and send them
13:07:59 <ReinH> edwardk: beautiful, thanks. Maybe I'll try to turn them into a blog post or something.
13:08:02 <warpy> mm_freak_: can you parse such a stream without keeping a state?
13:08:05 <ReinH> or a few blog posts, more likely
13:08:05 <ski> mm_freak_ : surely `Codensity (const Nothing) :: Codensity Maybe a' is an abortion ?
13:08:14 <mm_freak_> warpy: if that's the grammar, i'd split into words, then filter, then flatten
13:08:29 <mm_freak_> ski: but not a Cont abortion
13:08:34 <warpy> mm_freak_: it is not a grammer, it is just a stream of parts of messages
13:08:44 <warpy> imagine xml tags, but interleaved
13:08:48 <ski> mm_freak_ : i don't see how ?
13:08:57 <ReinH> warpy: you should be able to do that by keeping a parse state
13:09:13 <ReinH> Not sure how you might do it without
13:09:38 <ski> ReinH : notes ?
13:09:39 <teknokratsevilla> how can you keep a state in a functional language ?
13:09:47 <warpy> ya, i thought so too. wondering how to do this is a clean way
13:09:50 <warpy> in haskell
13:09:55 <benzrf> �
13:09:59 <ReinH> ski: edwardk tried to give me some learnings while we were at BayHac
13:09:59 <ski> teknokratsevilla : an accumulator is an easy way
13:10:02 <warpy> thats why i was looking into pipes
13:10:02 <ReinH> It was moderately successful.
13:10:32 <teknokratsevilla> I mean, you haven't got but flows...
13:10:35 <edwardk> braindumped a bunch of stuff on kan extensions, free things, fm-indices, etc.
13:10:37 <warpy> ReinH: are pipes stateful
13:10:45 <jfischoff> teknokratsevilla: you can thread it. A function takes the initial state returns the next state
13:11:04 <mm_freak_> ski: well, you're ignoring the continuation to get Nothing, but it's not a Cont abortion, because that's impossible with Codensity
13:11:10 <ski> edwardk : "fm-indices" ?
13:11:13 <teknokratsevilla> you can model the states
13:11:28 <ski> mm_freak_ : what do you mean by "Cont abortion" ?
13:11:33 <ReinH> teknokratsevilla: the most obvious way to keep state is to pass it around as an argument
13:11:35 <edwardk> http://en.wikipedia.org/wiki/FM-index
13:11:45 <jfischoff> teknokratsevilla: not sure what you mean by model
13:11:47 <edwardk> it can be implemented very nicely with a wavelet tree
13:11:54 <ReinH> surprisingly nicely in fact
13:11:59 <mm_freak_> :t ContT . const . return
13:12:00 <lambdabot> Monad m => r -> ContT r m a
13:12:04 <mm_freak_> ski: that
13:12:05 <jfischoff> I guess you mean approximate mutable references
13:12:26 <ski> edwardk : sounds interesting
13:12:29 <augur> erik meijer is really confused about probability theory :(
13:12:42 <jfischoff> augur: yes
13:12:45 <edwardk> augur: was a bit surprised myself. *shrugs*
13:12:47 <ski> @type Cont . const
13:12:49 <lambdabot>     Not in scope: data constructor ‘Cont’
13:12:49 <lambdabot>     Perhaps you meant one of these:
13:12:49 <lambdabot>       ‘Const’ (imported from Control.Lens),
13:12:53 <ski> @type cont . const
13:12:54 <lambdabot> r -> Cont r a
13:12:55 <ReinH> augur: what happened?
13:13:00 <mm_freak_> ski: if you ignore the continuation you're still getting Maybe effects, not Cont effects
13:13:03 <augur> ReinH: check twitter :P
13:13:08 <ReinH> augur: :/
13:13:11 <ski> @type cont (const Nothing) ::
13:13:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:13:15 <ski> @type cont (const Nothing)
13:13:17 <lambdabot> Cont (Maybe a1) a
13:13:28 <augur> jfischoff, edwardk: more voices might help convince him to sit down and read some more foundational stuff
13:13:28 <edwardk> what effects are you trying to model?
13:13:55 <ReinH> Ok, Erik's "use of the word monad" card has been revoked.
13:13:57 <jfischoff> augur: the thread was moving too fast
13:14:11 <augur> jfischoff: just a nudge in the right direction is all thats needed, i think
13:14:15 <edwardk> augur: i pinged him about it on facebook, but then wadler spoke up and i figured it was all good.
13:14:27 <mm_freak_> ski: i'm not entirely sure about this, but i believe that you can always get the same effect by using the underlying monad
13:14:34 <augur> jfischoff: its going in circles at this point so i dont know if ill make any progress
13:14:35 <jfischoff> augur: "the truth will set you free"
13:14:39 <ski> ReinH,mm_freak_ : i'd prefer to say that `Codensity' is like `Cont' or `ContT', but with a *restriction* on what kind of continuation effects you can have (the restriction being specified by the `m' parameter of `Codensity m')
13:14:53 <augur> edwardk: on facebook? :|
13:15:04 <ReinH> ski: well, you can't call the same continuation twice, right?
13:15:12 <mm_freak_> ski: that seems fair
13:15:26 <mm_freak_> ReinH: you can
13:15:30 <ReinH> mm_freak_: hmm
13:15:48 <ski> mm_freak_,ReinH : to make this restriction maximal, one can use `forall o. Cont o a', iow `forall o. (a -> o) -> o', which then completely removes all possibility for continuation effects
13:16:07 <mm_freak_> ReinH: Codensity (\k -> k 1 >> k 2) :: (Monad m, Num a) => Codensity m a
13:16:08 <edwardk> augur: i'm pretty much platform neutral. i talk to people with whatever is the most efficient way to reach them. twitter's 140 character limit rarely makes it my most effective mechanism for communicating complex ideas. ;)
13:16:20 <ski> (alternatively `forall m o. Monad m => ContT o m a', i suppose)
13:16:25 <augur> edwardk: thats true. but _facebook_? horrible
13:16:38 <edwardk> Codensity f is bigger than f for many choices of f.
13:17:02 <edwardk> Codensity = ContT without access to callCC or to supply your own continuation
13:17:13 <ski> mm_freak_ : "if you ignore the continuation you're still getting Maybe effects, not Cont effects" -- yes, that's the effect of it all (if you pardon the pun). but i still think it's fair to say that the *mechanism* is in essence a continuation effect
13:17:33 <mm_freak_> ski: fair enough
13:18:27 <ski> i think "you can always get the same effect by using the underlying monad" is true as well
13:18:44 <edwardk> ski: for codensity?
13:19:04 <ski> iow, for a monad `m', `Codensity m' is iso to `m' (perhaps modulo a few bottoms, like not having function extensionality)
13:19:14 <edwardk> no
13:19:24 <edwardk> Codensty ((->) e) is State e
13:19:29 <mm_freak_> ski: actually i'm not so sure about that anymore…  you can still apply the continuation multiple times
13:19:36 <edwardk> forall r. (a -> e -> r) -> e -> r
13:19:52 * ski ponders
13:20:12 <edwardk> Codensity f is bigger than f for many choices of f. if f has a left adjoint it is the size of the monad given by that adjunction
13:20:47 <ski> ok. ty for correcting me here
13:20:59 <ski> (i believe this was a false analogy with `CoYoneda')
13:21:06 <edwardk> Ran f g a is basically walking 'backwards' along the right adjoint of f as an approximation of its inverse
13:21:52 <edwardk> er i think i flipped adjoints there
13:21:56 <augur> edwardk: oh FFS...
13:22:08 * ski doesn't have much intuition for Kan extensions yet
13:22:12 <augur> edwardk: https://twitter.com/headinthebox/status/469934786627129344
13:23:59 <mm_freak_> edwardk: you're saying that Codensity ((,) e) is as big as ((->) e)?
13:26:18 <ReinH> ski: That's why I need edwardk's notes ;)
13:26:35 <lucky> http://lpaste.net/104525 the last line here gives me a " No instance for (Num B) arising from the literal `1'" which I'm having trouble figuring out why
13:27:07 <mm_freak_> edwardk_: are you saying that Codensity ((,) e) is as big as ((->) e)?
13:28:49 <edwardk_> er i think i flipped adjoints there
13:28:51 <edwardk_> i sai that but then got disconnected
13:28:57 <edwardk_> lets play a game
13:28:59 <edwardk_> Ran ((->) e) Identity a
13:29:01 <edwardk_> that is
13:29:03 <edwardk_> forall r. (a -> e -> r) -> r
13:29:05 <edwardk_> which is a cps'd tuple
13:29:07 <edwardk_> which is the left adjoint of ((->) e)
13:29:12 <edwardk_> Given f -| g then Ran g Id ~ f
13:30:14 <mm_freak_> ah
13:30:16 <mm_freak_> i see it now
13:30:18 <mm_freak_> thanks
13:30:23 <edwardk_> f -| g then Ran g h ~ h.f   so Ran g g ~ g.f which is the monad given by the adjunction f -| g.
13:30:36 * hackagebot http-types 0.8.5 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.5 (AristidBreitkreuz)
13:31:17 <edwardk_> the fact that Ran and Rift can be used to 'turn something around' is powerful. Rift is how you get that comonad-to-monad transformer i blogged about
13:31:18 <napping> hmm, isn't the cps'd tuple a tiny bit bigger?
13:31:36 <edwardk_> napping: i'm ignoring bottom issues with the lifting of the tuple
13:31:47 <edwardk_> as that gets in the way of most categorical presentations
13:31:49 <napping> forall r . (Int -> Int -> r) -> r allows odd things like \f -> f 0 0 `seq` f 10 12
13:32:13 <napping> that's a good idea
13:33:03 <wunki> I'm trying to see how fast I can traverse a 1Gb binary file (just for fun), fastest right now is 18s.
13:33:10 <ski> teknokratsevilla : we can also abstract out the state-threading that results from generalizing accumulators to also being returns as (often extra) results. (nothing extra needs to be done to do this in Prolog. the traditional implementation of DCG can be used to abstract the state-threading here, but it's not as composable)
13:33:15 <edwardk_> it matters in other situations, when folks go to argue you should use effect systems but don't see they can't cover lazy state or lazy writer -- as those monads don't exist through that 'ignoring _|_ behavior lens' but not here.
13:33:16 <wunki> anyone have any pointers on how to make it faster. See code: https://gist.github.com/wunki/9361c2d0172036bfe53b
13:34:05 <edwardk_> napping: http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html motivates why it is acceptable to pretend seq doesn't exist while reasoning much of the time
13:34:45 <teknokratsevilla> wow
13:34:50 <johnw> wunki: sum is equiv to foldl' (+) 0
13:34:59 <ski> edwardk_ : `Rift' ?
13:35:02 <teknokratsevilla> @type max
13:35:03 <lambdabot> Ord a => a -> a -> a
13:35:08 <edwardk_> ski: right kan lift
13:35:16 <ReinH> wunki: you want foldl' (+) 0 to avoid the thunk chains, although unpacking a bytestring is never going to be fast
13:35:19 <napping> johnw: isn't sum still like foldl (+) 0?
13:35:23 <ski> edwardk_ : which is ?
13:35:28 <wunki> johnw: ah, yes..
13:35:29 <johnw> napping: is it really still?
13:35:37 * hackagebot clafer 0.3.6 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.6 (mantkiew)
13:35:39 * hackagebot claferIG 0.3.6 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.6 (mantkiew)
13:35:41 * hackagebot claferwiki 0.3.6 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.6 (mantkiew)
13:35:44 <johnw> I think the report says that, but the real sum isn't implemented that way
13:35:44 <edwardk_> newtype Rift g h a = Rift (forall r. g (a -> r) -> h r)
13:35:47 <wunki> ReinH: what should I be using to make it faster?
13:35:59 <ReinH> wunki: L.foldl' probably
13:36:00 <johnw> wunki: well, try foldl' then
13:36:04 <johnw> maybe it does beat sum
13:36:10 <ion> gha!
13:36:13 <teknokratsevilla> Rift is another mathematical construct, right ?
13:36:16 <edwardk_> http://hackage.haskell.org/package/kan-extensions-4.0.2/docs/Data-Functor-Kan-Rift.html
13:36:23 <ReinH> johnw: creating the intermediate list with L.unpack is a bad idea.
13:36:27 <johnw> teknokratsevilla: Right is a Right-Lift
13:36:30 <johnw> Rift*
13:36:40 <napping> sum     l       = sum' l 0 where sum' []     a = a; sum' (x:xs) a = sum' xs (a+x)
13:36:41 <ReinH> ByteString already offers a foldl' over Word8 without the need to unpack
13:36:49 <johnw> ReinH: I'm pretty sure there is no intermediate list in the -O Core
13:36:52 <edwardk_> teknokratsevilla: technically its the same categorical construct when you take the 2 category you find kan extensions in an flip around just the 2-morphisms
13:36:56 <wunki> could you guys place comments on the Gist? I'm also writing a blog post about it, would love to incorporate your sugestions
13:36:57 <ski> is `Ran f g a = forall r. (a -> f r) -> g r' and `Lan f g a = exists s. f s * (g s -> a)' ? maybe swapping `f' and `g' in the latter ?
13:37:02 <ReinH> johnw: perhaps you're right
13:37:11 <ReinH> johnw: still, the unpack is unnecessary
13:37:23 <edwardk_> data Lan g h a where
13:37:24 <edwardk_>   Lan :: (g b -> a) -> h b -> Lan g h a -- is what i use
13:37:31 <edwardk_> so yes
13:37:47 <edwardk_> Lift is unfortunately uglier
13:37:49 <ski> @where fast-and-loose
13:37:50 <lambdabot> I know nothing about fast-and-loose.
13:37:52 <johnw> ReinH, wunki: yeah, I think Data.ByteString provides its own fold
13:38:00 <napping> johnw: so only if it gets inlined and specialized to a strict + and strictness analyzed
13:38:03 <edwardk_> because Rift and those 2 encodings of Ran/Lan relied on particulars of Hask.
13:38:05 <edwardk_> newtype Lift g f a = Lift { runLift :: forall z. Functor z => (forall x. f x -> g (z x)) -> z a }
13:38:05 <ReinH> johnw: yes, BS.Lazy.foldl' :)
13:38:16 <napping> otherwise it builds as many thunks as foldl (+) 0 would
13:38:17 <edwardk_> that is the sort of cheesy encoding of Lift by writing down the universal property
13:38:21 <wunki> ReinH: that way I don't need to unpack?
13:38:23 <ReinH> johnw: if I keep saying it maybe it'll stick ;)
13:38:25 <ReinH> wunki: yep
13:38:27 <johnw> wunki: right
13:38:30 <ski> @where+ fast-and-loose "Fast and Loose Reasoning is Morally Correct" by Nils Anders Danielsson,John Hughes,Patrik Jansson,Jeremy Gibbons in 2006 at <http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html>
13:38:30 <lambdabot> It is forever etched in my memory.
13:38:33 <teknokratsevilla> forgive my ignorance, but what's the use of kan lifts ?
13:38:42 <wunki> ReinH, johnw: ah, awesome
13:38:48 <johnw> wunki: always use "specific folds" if you can, since they can sometimes do custom optimizations
13:39:01 <edwardk_> You could write Rift as Rift g f a = (forall x. g (z x) -> f x) (z a)
13:39:05 <edwardk_> er
13:39:25 <edwardk_> data Rift g f a = forall z. Functor z => Rift (forall x. g (z x) -> f x) (z a)
13:39:44 <edwardk_> its a fun exercise to prove that is equivalent to the rift i wrote above
13:39:51 <ReinH> teknokratsevilla: http://comonad.com/reader/2008/kan-extensions/
13:40:05 <edwardk_> similarly you can encode Ran via its universal property:
13:40:05 <ReinH> teknokratsevilla: I'm it's not going to be easy going without some understanding of category theory
13:40:11 <edwardk_> data Ran' g h a = forall z. Functor z => Ran' (forall x. z (g x) -> h x) (z a)
13:40:13 <ReinH> *I'm afraid
13:40:21 <teknokratsevilla> it seems I have to learn lots of maths...
13:40:22 <ski> edwardk_ : hm, `Rift' looks strange .. reminds me of `gfoldl' for some reason
13:40:34 <edwardk_> notice the symmetry between Ran and Rift
13:40:45 <ReinH> teknokratsevilla: You *get to* learn a lot of maths. ;)
13:40:58 <johnw> wunki: will unpacking to [Word8] "box" every byte in the ByteString?  I see that Word8 is W8# Word#, but I'm not sure if that's an unboxed constructor
13:40:59 <edwardk_> when given in terms of their universal properties
13:41:00 <ReinH> teknokratsevilla: but really you can just make use of the fruits of edwardk_'s research into kan extensions
13:41:12 <ReinH> you don't need to understand them to use libraries that use them
13:41:24 <geekosaur> johnw: the Word# is unboxed, but the W8# is a box
13:41:25 <teknokratsevilla> forgive my ignorance, but has this any "direct" use in practical problems ?(I guess so.. but I can't see the connection )
13:41:43 <johnw> geekosaur: ok; though presumably fusion will eliminate the wrap/unwrap
13:42:06 <johnw> either way, BS.Lazy.foldl' avoids all of those issues
13:42:09 <ReinH> teknokratsevilla: No forgiveness needed. The answer is yes, but not in an obvious way.
13:42:20 <edwardk_> teknokratsevilla: you don't need to understand any of this to work with haskell. but when you run into a situation where you get stuck and in most communities would have to give up, this math is a great tool to get you out of a jam, and the beauty of the haskell community is it is full of people who know how to use such tools. ;)
13:42:29 <wunki> johnw, ReinH: L.foldl gives a stack space overflow also
13:42:33 <ski> edwardk_ : ok
13:42:36 <ReinH> wunki: L.foldl'
13:42:37 <johnw> foldl'
13:42:39 <johnw> not foldl
13:42:49 <wunki> ah, excuse me... Trying again...
13:42:52 <ReinH> wunki: you need to avoid the thunk chain of (+) applications so you need a strict accumulator
13:42:59 <teknokratsevilla> I agree, haskell community is just impressive
13:43:10 <johnw> teknokratsevilla: you've already used the ideas before without knowing it; edwardk just gave us code to implement the concepts given by math
13:43:13 <augur> edwardk_: and now, it seems, he's trying to browbeat me into submission by using slurs like "dynamic typing"! how preposterous
13:43:24 <ReinH> johnw: I'm not sure we've used the ideas from kan extensions before ;)
13:43:26 <johnw> one thing math does is it identifies when disparate groups are solving the same problem over and over
13:43:29 <edwardk_> teknokratsevilla: 'Ran' (through a special case, Codensity) can be used as a form of 'enforced (>>=)' fusion. that can make computations over monads much cheaper. making an asymptotic difference in the performance of your code. often orders of magnitude in real wallclock time
13:43:32 <johnw> kan extensions generalize adjunctions
13:43:34 <bitemyapp> augur: wasn't me this time :)
13:43:37 <johnw> and adjunctions are *everywhere*
13:43:42 <ReinH> johnw: generalize?
13:44:06 <wunki> johnw, ReinH: new record, 12s :-)
13:44:11 <edwardk_> teknokratsevilla: it can also be used through Yoneda to get a form of 'type enforced fmap-fusion' which will fuse maps for you into one pass
13:44:17 <johnw> ReinH: http://comonad.com/reader/2008/kan-extensions-ii/
13:44:26 <ReinH> wunki: are you compiling with optimizations?
13:44:43 <wunki> ReinH: I'm using -O2
13:44:48 <ReinH> Ok
13:45:00 <edwardk_> teknokratsevilla: it also provides ways to talk about certain operations when mapping data back and forth between database schemes while preserving invariants, etc.
13:45:11 <wunki> ReinH: trying to approach the 0.25s here: http://jvns.ca/blog/2014/05/12/computers-are-fast/
13:45:13 <BeardedCoder> Is it valid to have something like data Foo = Foo String and export Foo(..) ?
13:45:18 <ReinH> johnw: Ok, I see what you're saying.
13:45:40 <edwardk_> teknokratsevilla: it is the kind of thing that once you know how it works you can move from 'hey here is generalized continuation passing style' to lifting results across a wide array of domains into/out of haskell.
13:45:48 <johnw> heh, in this book, http://www.math.harvard.edu/~eriehl/cathtpy.pdf, the author's first Chapter is titled "All concepts are Kan extensions"
13:46:22 <ReinH> wunki: Are you using mmap?
13:46:26 <edwardk_> johnw: that is pretty much the note that Mac Lane ends CftWM on as well.
13:46:37 <ReinH> The real speedup comes from vector intrinsics iirc
13:46:44 <ReinH> wunki: this might be interesting to you http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
13:46:56 <wunki> ReinH: no. Maybe it good to say mention I'm a complete Haskell beginner
13:47:19 <ReinH> johnw: added to my reading list thanks :)
13:47:24 <johnw> I never really grokked the link between Galois connections and adjunctions, until I was reading a paper on GC the other day and found that all the equations looked damn familiar... :)  Then it hit me
13:47:43 <ReinH> johnw: Heh edwardk_ has a thing using that too
13:47:44 <johnw> ReinH: my pleasure!
13:47:49 <ReinH> edwardk_: has a thing for everything
13:48:28 <ReinH> johnw: btw I found a 400+MB torrent of category theory (and related subjects) books, papers, etc o_O
13:48:34 <johnw> ReinH: link!!!
13:48:41 <johnw> I am a CT literature hoarder
13:48:45 <wunki> ReinH: thanks, looking into mmap and trying to read the paper
13:48:50 <ReinH> It is of.. dubious legality.
13:48:51 <edwardk_> johnw: you know those succinct structures i like to talk bout? select -| rank     gives another galois connection
13:49:01 <johnw> oh, that is just sweet, edwardk
13:49:03 <ReinH> But I've already bought some of the books so I don't feel terrible
13:49:24 <ReinH> johnw: see what I mean about edwardk_? It's insane.
13:49:27 <edwardk_> johnw: not only that, there is a one-sided inverse going in the other direction
13:49:28 <johnw> when it comes to PDFs, I purchase before I read, though I will skim it before buying to see if I like the material
13:49:53 <ReinH> johnw: I've already bought quite a few of the books in there so I feel morally meh about it
13:50:00 <edwardk_> rank (select i) = i; select (rank i) <= i
13:50:56 <napping> anything interesting with succinct data structures?
13:51:37 <ReinH> napping: yes!
13:51:40 <napping> I was wondering the other day if they might help indexing into unicode strings
13:51:45 <ReinH> fm-indexes
13:52:16 <ReinH> napping: I need to implement fm-indexes for my codesearch project, so they'll happen one way or another
13:52:23 <ReinH> just a question of whether edwardk gets fed up with me and writes it first
13:53:04 <napping> oh, I didn't remember that those used rank/select dictionaries
13:53:05 <edwardk> napping: you can build a full text index into unicode strings that takes about as much space as it fully bzipped but which can be used directly as the index without decompression using a basic wavelet tree and BWT.
13:53:33 <edwardk> napping: so i think that is a resounding 'yes you can use succinct structures for that' ;)
13:53:40 <johnw> edwardk: you would know, is this already in one of your libraries: https://github.com/jwiegley/notes/blob/master/Update.hs
13:53:59 <napping> I was thinking of smaller data - like pairing a Text with a rank/select dictionary for O(1) take/drop
13:54:42 <edwardk> napping: that is something i also played with
13:55:34 <edwardk> you can put a cheap rank/select structure on Text and get a lot of easy take/drop/count operations
13:55:58 <edwardk> select is completely optional of course
13:56:07 <edwardk> as with rank going from n to log n for select is good enough ;)
13:56:31 <ski> edwardk> :t select
13:56:33 <ski> edwardk> :t rank
13:57:08 <edwardk> http://en.wikipedia.org/wiki/Succinct_data_structure gives the definition right away
13:57:13 <augur> edwardk: what frustrates me now is that meijer's complaint about bayes' theorem is _by his own admission_ a complaint about his particular reformulation of probability that is completely distinct from standard probability theory
13:57:30 <augur> edwardk: thus making his "complaint" a giant strawman
13:58:02 <bitemyapp> augur: I think he just likes trolling.
13:58:23 <ReinH> augur: you don't get to make up your own definitions and then continue to engage in the same argument
13:58:33 * ReinH sighs
13:58:51 <augur> ReinH: i know, that was what i said to him originally -- that he was redefining things and then critiqueing bayes' theorem based on his redefinition
13:59:32 <ReinH> "Ok, look, we can talk about whatever this system is that you just defined, but we aren't talking about Bayes' Theorem any more"
13:59:41 <ReinH> augur: this happens to me a lot as well. So frustrating.
13:59:49 <ReinH> I just try to avoid internet arguments on principle now
14:00:28 <ReinH> I'd usually rather let someone be wrong than waste hours of my life in a futile and frustrating effort to correct them.
14:00:36 <bitemyapp> ReinH: the problem is he has a voice.
14:00:41 <ReinH> bitemyapp: that's true
14:01:22 <etrepum> bitemyapp: sometimes I can't tell if he's trolling or not
14:01:33 <bitemyapp> etrepum: me either.
14:01:45 <ReinH> Never attribute to trolling that which can be adequately explained by stupidity?
14:01:50 <dino-> I'm having a problem figuring out how to do something with cabal sandbox.
14:01:53 <augur> ReinH: i avoid arguments with people who arent worth arguing with, you know?
14:01:59 <ReinH> augur: sure
14:02:03 <ReinH> augur: I guess my threshold is different :)
14:02:09 <dino-> I have a project I'm building with a different ghc, so used the -w switch on `cabal install --only-dep`
14:02:12 <augur> ReinH: erik meijer isnt an idiot, so ..
14:02:24 <ReinH> augur: that's the thing. He's obviously not an idiot, which makes this even more frustrating.
14:02:44 <dino-> So that failed because of missing alex, I fixed that, and then when I issue the install command again, I'm getting a failure of figuring out deps..
14:02:54 <vanila> oh boy, what's erik meijer saying this time?
14:03:02 <augur> ReinH: but it also makes it possible for him to be corrected, if he's not so stubborn as to ignore people's responses
14:03:11 <dino-> So I wanted to try to unregister one or more of the things it's complaining about, but I can't figure out how to get `cabal sandbox hc-pkg` directed at the not-default ghc
14:03:12 <ReinH> vanila: he seems to be demonstrating his fundamental misunderstanding of probability theory
14:03:20 <etrepum> ReinH: maybe these sorts of stunts are good for his enterprise scala/java/c# business :)
14:03:25 <dino-> -w switch doesn't seem to work with `cabal sandbox ...` commands
14:03:33 <vanila> well probability theory is hard, what's the issue?
14:03:52 <ReinH> vanila: making wrong claims to certainty?
14:04:06 <dino-> Any idea how I can direct cabal sandbox to the right ghc version?
14:04:26 <napping> dino-: maybe check out the cabal.sandbox.config file?
14:05:35 <dino-> napping: Ah, maybe hack package-db in there. Will try that, thank you!
14:05:41 <ReinH> vanila: I'm all for getting things wrong, just don't be so damned confident that you're right. Especially in the face of multiple smart people telling you that you're wrong. ;)
14:06:11 <vanila> ok so interpretation of random variables
14:06:16 <napping> dino-: I was thinking maybe something about the ghc path instead, I'm pretty sure it already sets the package-db to point into the sandbox correctly (though it might bake in the wrong compiler version name?)
14:07:35 <vanila> no idea how to work twitter
14:08:22 <vanila> what is it exactly people are taking exception to?
14:09:37 <dino-> napping: It did, but only because the initial `cabal sandbox init` only knew about the ghc in the PATH I think. This is working, I was able to unreg a series of offending things and get the install --only-dep to continue.
14:09:41 <dino-> napping: thanks!
14:10:13 <vanila> https://twitter.com/headinthebox/status/469864436497276930 I can't see any of the messages he is responding to
14:11:37 <vanila> lol "I know some fp & logic" - Philip Wadler
14:13:28 <napping> not quite as impressive as Atkey's stuff on typing conservation laws
14:14:00 <vanila> I'm really not following any of this
14:14:27 <vanila> it looks interesting and I'd like to read the actual conversation, but I don't know if twitter lets you do that
14:17:28 <vanila> ReinH, He says he's writing a paper on it
14:17:37 <ReinH> I look forward to that peer review
14:17:53 <vanila> well if you all think he's wrong it seems like he'll realize that in writing
14:18:11 <vanila> so I wouldn't worry to much about forcing him to realize it right now
14:18:47 <vanila> random variables always bugged me, has anyone done them right?
14:22:50 <vanila> so what's new with haskell
14:22:58 <vanila> (I am bored)
14:23:21 <fuzzyhorns> been reading the old hopl books
14:23:27 <fuzzyhorns> dry but kinda interesting
14:23:48 <vanila> HOPL
14:23:57 <vanila> History of Programming Languages
14:24:05 <vanila> I'm not familiar with this
14:24:22 <fuzzyhorns> last one was in 2007
14:24:35 <fuzzyhorns> so prob wont be another till 2025ish i imagine
14:25:03 <hexagoxel> when my cabal project does not compile, i would like to print the first and second error message in the console. what is the most lightweight way to achieve this?
14:25:31 <hexagoxel> by lightweight i mean "preferably without running a full 'cabal build'"
14:26:09 <hexagoxel> i am willing to write a small utility that takes the full error stream and forwards only the first messages
14:28:20 <hexagoxel> (i asked this, or a similar question earlier, but had to go offline; sorry again if anyone had started working on a reply)
14:32:55 <hunt_> how to compare a number to a range? see if its below in or above? i looked at Ix and it doesnt seem to do that
14:34:03 <vanila> hunt_, do you have a range type, or is it just a pair of integers?
14:34:11 <fread2282> > let x = 3 in if 2 < x && x < 4 then "foo" else "bar"
14:34:13 <lambdabot>  "foo"
14:34:19 <fread2282> hunt_: ^
14:34:42 <vanila> :t compare
14:34:44 <lambdabot> Ord a => a -> a -> Ordering
14:34:54 <hunt_> id rather return an Ord type depending on its position relative to the range
14:34:54 <vanila> is there some structure on Ordering?
14:34:54 <teknokratsevilla> so cathegory theory is basically the maths of maths...
14:34:55 <teknokratsevilla> great
14:35:14 <hpc> @src Ordering
14:35:14 <lambdabot> data Ordering = LT | EQ | GT
14:35:21 <vanila> but I mean is it a monoid or something
14:35:39 <vanila> I want to write   compareWithRange x (min,max) = compare x min `magic` compare max x
14:35:41 <hpc> it is a monoid and many other things
14:35:45 <vanila> to implement your function
14:36:29 <hunt_> well we know that if its LT for both upper and lower bounds it shouhld return LT
14:36:38 <hunt_> and if its GT for both it should return GT
14:36:46 <hunt_> and if theyre different i guess it should be EQ?
14:38:06 <vanila> yeah
14:38:08 <vanila> that makes sense
14:38:17 <hunt_> it seems like there should be a good way to do that
14:38:20 <vanila> so I wonder if there's a funtion for that already.. probaly not but you can implement it easily
14:38:28 <vanila> f LT LT = LT
14:38:31 <vanila> f GT GT = GT
14:38:32 <hunt_> like if two things are equal, return the things
14:38:33 <vanila> f _ _ = EQ
14:39:08 <vanila> I guess you could just leave it defined in a where clause, and if someone discvers it one day you can improve that code
14:39:35 <ski> teknokratsevilla : CT can be seen as (mostly) a language used to talk about and compare different areas of math at the same time (including making general definitions of concepts that occur in specific instances over and over again in different areas)
14:39:38 <chrisdotcode> guys, how can I download GHC docs?
14:39:45 <chrisdotcode> for base and ghc internals
14:39:48 <hunt_> vanila: i wish i could do it now, how frustrating
14:39:53 <hunt_> vanila: but yea, i guess i will
14:39:56 <axm1> how I miss Haskell. only coded in it in uni for a semester and sadly I've never had the chance since then
14:40:03 <fread2282> > let {num = 3; min = 2; max = 4; f LT LT = LT; f GT GT = GT; f _ _ = EQ} in f (compare num min) (compare num max)
14:40:05 <lambdabot>  EQ
14:40:08 <vanila> don't worry hunt_ it's all good :)
14:46:42 <ReinH> ski, teknokratsevilla: I like Awodey's "Category Theory is an (abstract) algebra of (abstract) functions"
14:47:27 <ReinH> Which helps explain why it's such a fruitful tool for reasoning about Haskell
14:47:49 <teknokratsevilla> the theory of "transformation" , actually
14:47:59 <vanila> how is category theory applied to haskell?
14:48:12 <teknokratsevilla> haskell uses function to transform things...
14:49:14 <dmj`> vanila: the types in haskell form a category (called Hask). The types are the objects and the functions between them morphisms.
14:49:16 <ski> vanila : functors, monads, edwardk
14:49:23 <ReinH> heh
14:49:35 <dmj`> http://www.haskell.org/haskellwiki/Hask
14:49:36 <ReinH> Every so often edwardk goes up to the mountain of CT and brings us some new tablets
14:49:48 <dmj`> ReinH: lol
14:50:02 <edwardk> hear that dolio? we're going to start calling you the mountain.
14:51:41 <ski> @remember ReinH <ReinH> Every so often edwardk goes up to the mountain of CT and brings us some new tablets  <edwardk> hear that dolio? we're going to start calling you the mountain.
14:51:41 <lambdabot> I will remember.
14:51:45 <ReinH> conal: hi!
14:51:57 <ReinH> ski: heh
14:52:00 <edwardk> =)
14:53:07 <ptrtoptr> jaskell, does it exist? Haskell on the jvm.
14:53:36 <teknokratsevilla> yes
14:54:27 <ptrtoptr> why isnt it killing scala?
14:55:02 <tdammers> not enough macbook latte with wannabe-nerd-but-trying-too-hard glasses?
14:55:38 <freeman42> anyone of you know if I could download from somewhere a Vmware or Virtualbox image prepackaged with Haskell including IDE's and other related stuff?
14:55:47 * hackagebot usb 1.2.0.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.2.0.1 (BasVanDijk)
14:57:49 <augur> tdammers: we should totally try to make that a thing
14:57:57 <augur> tdammers: jaskell hipster programmers
14:58:28 <frank_> > map(/0) [1..]
14:58:30 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
14:58:32 <augur> tdammers: secretly an entryist group of actual haskell nerds whove gone undercover as hipster programmers!
14:58:51 <augur> > 1/(1/0)
14:58:53 <lambdabot>  0.0
14:58:57 <augur> huh!
14:59:04 <augur> now thats interesting
14:59:10 <augur> :t 1/0
14:59:12 <lambdabot> Fractional a => a
14:59:30 <frank_> > 1/0 - 1/0
14:59:31 <lambdabot>  NaN
14:59:48 <dmj`> freeman42: you can build it yourself quite easily
15:00:44 <hpc> augur: yeah, that's one of the lesser known parts of the spec
15:00:48 * hackagebot bytestring-from 0.3 - A type-class to convert values from ByteString.  http://hackage.haskell.org/package/bytestring-from-0.3 (ToralfWittner)
15:01:04 <hpc> and a neat trick to detect NaN if you don't have the right functions available
15:01:14 <hpc> > maxBound / (1/0) :: Double
15:01:15 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
15:01:15 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
15:01:23 <hpc> >:(
15:01:52 <freeman42> dmj`, I have very limited internet right now so I would like something prepackaged, can't afford to screw up the downloads or experiment
15:02:36 <vanila> freeman42, a shell might be better (if you have someone who can set it up)
15:02:53 <vanila> oh wait that is stupid, forget that
15:02:57 <dmj`> freeman42: if you don't want to worry about any of that just use fp complete's IDE
15:03:19 <dmj`> https://www.fpcomplete.com/
15:03:21 <ReinH> hpc: er, how do you use that to detect NaN?
15:03:24 <dolio> edwardk: I'll allow it.
15:03:30 <ReinH> dolio: <3
15:03:35 <freeman42> vandenoever, it is rather problematic, fp complete downloads some stuff each time it opens
15:03:45 <freeman42> not sure how much or what
15:03:52 <freeman42> it is magic to me as a beginner
15:04:09 <hpc> ReinH: divide the max defined float by your number
15:04:14 <hpc> if it's zero, you got NaN
15:04:22 <dmj`> freeman42: it downloads stuff?
15:04:23 <ReinH> hpc: huh.
15:04:33 <ReinH> That's... odd.
15:04:52 <hpc> > 2**50 / (2**-5)
15:04:53 <lambdabot>  Not in scope: ‘**-’
15:04:54 <lambdabot>  Perhaps you meant one of these:
15:04:54 <lambdabot>    ‘**’ (imported from Prelude), ‘***’ (imported from Control.Arrow),
15:04:54 <lambdabot>    ‘**=’ (imported from Control.Lens)
15:04:59 <hpc> > 2**50 / (2** (-5))
15:05:00 <lambdabot>  3.602879701896397e16
15:05:25 <hpc> i am misremembering the size of Double...
15:05:50 <rwbarton> > 2 ** 1024
15:05:52 <lambdabot>  Infinity
15:05:54 <rwbarton> > 2 ** 1023
15:05:56 <lambdabot>  8.98846567431158e307
15:06:04 <hpc> right
15:06:21 <hpc> and yeah, the tricky part is you might get infinity if you have a number < 1 and > 0
15:06:27 <hpc> but infinity /= 0 anyway
15:06:37 <freeman42> dmj`, yeah, I am not sure what... each time I open a project it updates some things... I do not know what exactly
15:06:56 <hpc> (also there are better ways to detect NaN than a potentially expensive division op)
15:08:01 <monochrom> @type isNaN
15:08:03 <lambdabot> RealFloat a => a -> Bool
15:08:07 <monochrom> :)
15:08:14 <monochrom> @botsnack
15:08:14 <lambdabot> :)
15:08:15 <hpc> monochrom: i mean in situations where you don't have that
15:08:22 <monochrom> oops :)
15:08:32 <hpc> misbehaving scripting languages and such
15:08:35 <monochrom> hmm, how do you that then?
15:08:52 <dmj`> freeman42: don't know what to tell ya
15:09:01 <phaazon> I changed my nickname ; I guess no one gives a *****, but well, I’d rather like saying.
15:09:03 <monochrom> do you use the "x == x" test?
15:09:30 <hpc> yes, that's the better way :)
15:09:54 <monochrom> phaazon, I care, it's important for me to keep track of famous people.
15:10:12 <phaazon> monochrom: yeah, that was my point: I’m not famous at all ;)
15:10:38 <monochrom> you are famous to me. for better or worse.
15:10:39 <vanila> what was your previous nick
15:10:40 <phaazon> I’m just a random guy who loves Haskell and everything built with it
15:10:43 <hpc> is this a dread pirate roberts kind of thing?
15:10:46 <phaazon> vanila: skypers
15:10:47 <hpc> do i get to be skypers now?
15:10:53 <phaazon> ahah, no :D
15:10:54 <vanila> so who is skypers
15:10:58 <phaazon> yeah, you see
15:11:02 <vanila> I've never seen this guy
15:11:05 <phaazon> who is skypers
15:11:06 <monochrom> but vanila is new
15:11:19 <hpc> who is monochrom?
15:11:32 <monochrom> "who is Bird? we just don't know." :)
15:11:37 <phaazon> monochrom: I think you only know me because I started – and I regret that – a few dramas in the past
15:11:38 <vanila> lol
15:11:41 <hpc> bird is the word, obviously
15:11:59 <vanila> I'm so bored, I wish I could do something haskell or something
15:12:00 <phaazon> I do some stuff for Haskell, like the FModEx 1:1 binding and a 3D engine
15:12:04 <phaazon> but it’s not famous at all
15:12:17 <dmj`> hpc: this is truth
15:12:23 <phaazon> but well, anyway, now you can track my nick :)
15:13:11 <ski> > encodeFloat ((\[(n,"")] -> n) (readHex "1c000000000000")) 971
15:13:13 <lambdabot>  1.5729814930045264e308
15:14:00 <ski> > encodeFloat ((\[(n,"")] -> n) (readHex "1c000000000000")) 971 * 2
15:14:02 <lambdabot>  Infinity
15:14:34 <hpc> > floor (1/0) :: Integer
15:14:36 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
15:14:40 <vanila> haha
15:14:58 <vanila> > length . show . floor $ (1/0)
15:14:59 <lambdabot>  309
15:15:13 <monochrom> > maxBound :: Int
15:15:15 <lambdabot>  9223372036854775807
15:15:22 <vanila> :t floor
15:15:24 <lambdabot> (RealFrac a, Integral b) => a -> b
15:15:49 * hackagebot purescript 0.5.2.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.2.1 (PhilFreeman)
15:16:24 <ski> phaazon : i recall the nick skypers
15:17:29 <hpc> fwiw, i remember the nicks of just about anyone who speaks semi-regularly here
15:17:41 <ski> (i have no idea why i do, but i do)
15:18:45 <freeman42> dmj`, no problem, I will try to set up a Vmware VM
15:19:42 <dmj`> freeman42: cool
15:20:42 <phaazon> ski: because I talk a lot here
15:20:47 <phaazon> and on #haskell-games
15:20:50 <phaazon> :)
15:24:44 <bbopen> kazagistar: which Rich Hickey video?
15:25:19 <lucky> http://lpaste.net/104525 the last line here gives me a " No instance for (Num B) arising from the literal `1'" which I'm having trouble figuring out why
15:25:52 <glguy> lucky: You need (C (B 1) (B 2) (B 3))
15:26:04 <lucky> ahh
15:26:04 <lucky> okay
15:27:36 <merijn_> lucky: Basically, in haskell literals are polymorphic (i.e. '1 :: Num a => a'), so in this case it knows C expects B's as argument, but sees as '1' so it concludes "oh, you must have meant to use a Num instance for B, but that doesn't exist"
15:30:49 <lucky> thanks :) i see why it wasn't working now
15:35:57 <ski> bbopen : kazagistar has left, but they mentioned <http://www.infoq.com/presentations/Simple-Made-Easy> earlier
15:42:08 <bbopen> ski: thank you
15:47:32 <benbangert> etrepum: were you able to run install with -j8?
15:47:39 <etrepum> benbangert: yep
15:47:43 <benbangert> hmm
15:51:07 <benbangert> etrepum: I wonder if the -j8 is doing something special that messes up the environment in the other builders
15:51:21 <etrepum> it could also be a race that I just didn't hit.
15:51:35 <etrepum> or something else that was toggled in your environment that I haven't done
15:56:42 <benbangert> etrepum: something about -j8 is tweaking the environment, and things are trying to build with the wrong ghc
15:57:00 <etrepum> well that's odd
15:57:21 <benbangert> ie, http://paste.ofcode.org/6MtadFWgmrUdcraWrJMKmp
15:57:29 <benbangert> if I don't use -j8, then its fine
15:57:41 <benbangert> but its definitely picking up old stuff when using -j8
15:58:14 <benbangert> maybe its executing subcommands in a different shell that doesn't have the same environ info
15:58:50 <benzrf> benbangert: there can only be oooooone
15:59:16 <benbangert> benzrf: apparently... was hoping I could just try out 7.8 at the same time
15:59:23 <benbangert> and I can, if I don't use -j8 with cabal
16:00:20 <benzrf> benbangert: i meant bens ;p
16:00:38 <benbangert> lol
16:02:11 <benbangert> etrepum: yea, its definitely running in a very different environment when using -j
16:02:21 <benbangert> its using the wrong ghc and wrong cabal
16:03:14 <vanila> wish i had some haskell code to write
16:18:51 <altern_> Hi all! I have a problem with multiparam typeclasses.
16:18:58 <altern_> here is my definition:
16:19:07 <geekosaur> @paste
16:19:07 <altern_> class A a b where
16:19:07 <lambdabot> Haskell pastebin: http://lpaste.net/
16:19:53 <altern_> http://lpaste.net/104535
16:20:27 <Cale> altern_: okay
16:20:34 <altern_> when I try to run " funA 2 'a' ", ghci says  No instance for (A Char b0) arising from a use of `funA'     The type variable `b0' is ambiguous
16:20:46 <Cale> altern_: That's correct, because it is ambiguous
16:20:56 <Cale> try  funA 2 'a' :: (Int, Char)
16:21:19 <Cale> You might want to add the functional dependency  class A a b | a -> b where
16:21:20 <ski> there could be an instance `A Char String', for all it knows
16:21:42 <Cale> but this will prohibit you from defining more than one instance of the class for any given type 'a'
16:22:14 <ski> the FD means that for each `a', there can be at most one `b' with an instance `A a b'
16:22:31 <ski>   forall a. unique b. A a b
16:22:32 <altern_> Cale: it helped
16:22:35 <ski> which is equivalent to
16:22:44 <altern_> Cale: funA 2 'a' :: (Int, Char)
16:22:50 <ski>   forall a b0 b1. (A a b0,A a b1) => b0 = b1
16:22:50 <Cale> altern_: yep
16:23:33 <altern_> Cale: do I need to mention return type for all my function calls from now on?
16:23:35 <ski> iow, if you have two instances `A a b0' and `A a b1', then `b0' and `b1' must actually be the same (can't be different) -- that's what the FD `a -> b' on `A a b' means
16:23:35 <Cale> altern_: You could also define an instance like   instance A Char String where funA n c = c : show n
16:23:44 <ski> altern_ : not if you add the FD
16:24:08 <Cale> The functional dependency removes your right to do that, but helps the compiler to infer which type 'b' is given the type 'a'
16:24:29 <ski> altern_ : but you should take a moment to consider whether you really want to have the FD, conceptually
16:25:45 <etrepum> benbangert: not sure how to explain that…
16:25:52 <altern_> ski: I am not sure I understand why it is not enough to have existing definition funA num char = (num, char)
16:26:52 <ski> altern_ : because someone might add `instance A Char String where funA n c = c : show n' somewhere else, and then it's not clear in  funA 2 'a'  which instance you want to use
16:28:19 <ski> type classes in Haskell uses Open World Assumption (OWA), it should still work in the presence of more instances than is currently known
16:28:34 <altern_> ski: ohhh, I see now..
16:29:23 <ski> (however, using the FD above explicitly forbids instances for `A Char b', for `b's other than the already known one `(Int,Char)')
16:30:19 <ski> (so therefore it is impossible to add more such instances in that case, and therefore  funA 2 'a'  is unambiguous, since there can be at most one `b' for `A Char b')
16:30:49 <altern_> ski: Cale: what would be the workaround to avoid using :: type in function calls? Is it possible to prohibit instantiation of my class with String return type ?
16:34:21 <ski> altern_ : yes, that is what the suggested FD does
16:34:53 <ski> altern_ : it forbids there to be more than `b' involved in instances `A a b', for a common given `a'
16:35:59 <ski> altern_ : an alternative to using a type ascription (`<expression> :: <type>') is to make sure the context of the `<expression>' forces the intended return type
16:36:36 <ski> e.g.
16:36:43 <jtcwang> has anyone every encountered this error when installing system-fileio?
16:36:54 <jtcwang> lib\hssystemfileio-win32.c:10:17:
16:36:54 <jtcwang>      error: storage size of 'st' isn't known
16:37:18 <ski>   let (n,c) = funA 2 'a' in n > length [c]
16:37:48 <ski> hm, no say instead
16:37:53 <ski>   let (n,c) = funA 2 'a' in n > length (c : "")
16:37:55 <ski> is a (silly) way to force the return type to `(Int,Char)'
16:38:31 * ski isn't sure what a non-silly example would be -- though the class `A' itself appears a bit silly
16:40:36 <Fuuzetsu> jtcwang: you should probably let the maintainer know
16:40:49 <jtcwang> Fuuzetsu, is this part of ghc?
16:41:24 <jtcwang> Fuuzetsu, hmm maybe not
16:41:26 <Fuuzetsu> no
16:42:33 <Fuuzetsu> jtcwang: there's a 0.4.11 version on the maintainer's page but not on Hackage, could try with that
16:43:30 <jtcwang> Fuuzetsu, in this case, this is part of the install of conduit-combinators
16:43:58 <jtcwang> Fuuzetsu, so I'm not sure whether its API has changed from ver 3 to 4. But I'll look it up. cheers
16:46:36 <Fuuzetsu> jtcwang: doesn't seem it did (looking at changes) but it doesn't seem like the relevant header got touched either
16:46:41 <Fuuzetsu> to confirm, you are on windows right?
16:46:47 <jtcwang> Fuuzetsu, correct
16:47:15 <Fuuzetsu> I guess you should try compiling system-fileio yourself and if that fails then report an issue
16:47:45 <jtcwang> Fuuzetsu, I'll give it a try
16:47:48 <Fuuzetsu> if it doesn't fail, try bumping version bounds and getting your packages to use 0.4.11
16:47:49 <Fuuzetsu> alright
16:47:51 <Fuuzetsu> good luck
16:51:24 <cococo> Why am I getting so many "Couldn't match expected type `Char' with actual type `[Char]'" errors? http://lpaste.net/9123785858523070464
16:53:13 <hpc> what line numbers?
16:53:31 <benzrf> cococo: well clearly you are getting strings where you want chars
16:53:34 <cococo> hpc: It's a very long list... can you run it in ghci?
16:54:07 <pavonia> cococo: TwoLetters is a string, so a is a Char which can'T be used with ++
16:54:35 <ski> > take_ 3 [0 .. 9]
16:54:37 <lambdabot>  [0,1,2]
16:54:40 <ski> > take_ 3 [0 ..]
16:54:41 <lambdabot>  [0,1,2]
16:54:57 <ski> > take_ 3 (0 : 1 : 2 : error "bottom !")
16:54:58 <lambdabot>  can't find file: L.hs
16:55:09 <ski> > take_ 3 (0 : 1 : 2 : error "bottom !")
16:55:11 <lambdabot>  [0,1,2*Exception: bottom !
16:55:14 <ski> > take 3 (0 : 1 : 2 : error "bottom !")
16:55:14 <pavonia> :t [[a, b] | a <- ['a'..'z'], b <- ['a'..'z']]
16:55:15 <lambdabot> [[Char]]
16:55:16 <lambdabot>  [0,1,2]
16:55:30 <ski> hm, apparently it's off-by-one
16:55:51 <cococo> nvm fixed it, thanks :)
16:56:08 <haasn> What's take_?
16:56:20 <ski> @type replicateM 2 ['a'..'z']  -- pavonia
16:56:22 <lambdabot> [[Char]]
16:56:33 <ski> haasn : a variant implementation
16:56:57 <pavonia> ski: I know, that was from cococo's code
16:57:05 <haasn> ski: I figured, but what's the implementation?
16:57:35 <ski>   take_ :: Int -> [a] -> [a]; take_ n as = foldr (\a loop n -> if n <= 0 then [] else a : loop (n-1)) (\n -> []) as n
16:57:48 <darthdeus> how can i properly uninstall ghc after installing it manually?
16:57:50 <darthdeus> there's no make uninstall
16:57:57 <ski> it's more or less "leaned so far right they came back as left"
16:58:03 <ski> @src take
16:58:04 <lambdabot> take n _      | n <= 0 =  []
16:58:04 <lambdabot> take _ []              =  []
16:58:04 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:58:23 <ski> i'm pondering if there's a nice way to make it not off-by-one
16:58:39 <haasn> ski: Oh, because the foldr needs to get the next cons element to hit the (<=) case
16:58:44 <ski> yes
16:59:17 <ski> i could check `(<= 0)' on `n-1' in the `loop' call -- but that seems an unprincipled change
16:59:27 <ski> (i'd have to add it at the top as well)
17:01:02 * hackagebot haskore-vintage 0.2 - The February 2000 version of Haskore.  http://hackage.haskell.org/package/haskore-vintage-0.2 (IavorDiatchki)
17:02:02 <ski> .. perhaps thinking in terms of alternating coroutines would work here as well
17:03:01 <cococo> Okay, so I'm having trouble with types, especially "Maybe"s. Can anyone take a look at this and tell me what's wrong? I've commented the error's it's getting at the bottom. http://lpaste.net/8971956952133271552
17:03:10 <ski> or maybe introducing a wrapping functional -- i'm not sure
17:04:01 <ski>       whosThere <- mapM isAvailable knockKnock
17:04:04 <ski> should be
17:04:12 <ski>       let whosThere = map isAvailable knockKnock
17:05:22 <ski> also, `knockKnock' is a `[Maybe String]', but `map isAvailable' wants a `[String]'
17:05:36 <ski> so you need to do some more change to decide what to do with the `Maybe's
17:05:39 <ski> cococo ^
17:06:13 <cococo> ski: thanks, how can I give it a [String] when knockKnock is a [Maybe String]?
17:06:18 <ski> cococo : what do you want to do in case executing `getWhois' on a domain yields `Nothing' ?
17:06:51 <ski> maybe you want to do something else (instead of calling `map isAvailable'), in case you get at least one `Nothing' ?
17:07:07 <ski> maybe you want to do something else only in case you get only `Nothing's ?
17:07:13 <cococo> ski: Really I just want it to return an empty string in that case, but it won't let me
17:07:17 <ski> maybe you just want to ignore the `Nothing's ?
17:07:23 <ski> maybe something else ?
17:07:36 <cococo> ski: Nothing -> "" gives me errors :(
17:07:50 <ski> you want *what* to return an empty string ?
17:08:03 <cococo> ski: Case serverFor s of Nothing
17:08:20 <ski> do you want to pass an empty string to `isAvailable' in case the corresponding `getWhois' action resulted in `Nothing' ?
17:08:33 <cococo> ski: yes
17:08:47 <ski> or would you prefer not calling `isAvailable' at all for such `getWhois' actions ?
17:08:59 <cococo> ski: I guess that would be prefered, yes, though they would both work
17:09:48 <cococo> ski: I'm very new to Haskell (obviously) and the only thing I could get working was giving an error
17:09:55 <ski> well, if doing nothing is more natural than passing an empty string (and then having to make sure that passing that "does nothing"), then imnsho, you *should* opt for the "do nothing" case
17:10:01 <ski> iow, remove `Nothing's from the list
17:10:05 <ski> @type catMaybes
17:10:06 <lambdabot> [Maybe a] -> [a]
17:10:24 <ski> cococo : you can use that ^ to remove the `Nothing's, and to strip the wrapping `Just's on the remaining elements
17:10:37 <ski> cococo : so try that ?
17:10:59 <ski> > catMaybes [Just 0,Just 1,Nothing,Just 3,Nothing,Nothing,Just 6]
17:11:01 <lambdabot>  [0,1,3,6]
17:11:34 <ski> cococo : yes, if you want to give some kind of warning or error message for the `Nothing's, that would also be possible
17:11:56 <ski> cococo : would you prefer that to merely ignoring the `Nothing's (as the `catMaybes' solution will do) ?
17:11:58 <altern_> How could I do qualified import with prefix except for certain functions? For example, I am doing import qualified Data.Aeson as JSON and I do not want to have JSON prefix for .= operator defined in the imported package
17:12:00 <cococo> ski: so I've removed the "Nothing" line, and just left "Just serv -> whois1 s serv"
17:12:26 <cococo> ski: yeah for now I'd prefer to do that
17:12:53 <cococo> ski: This is a small program I'm mostly using to learn, don't want to get _too_ complicated
17:13:02 <ski> cococo : hm, why do you call `error' in `getWhois' ?
17:13:07 <ski> are you sure you want to do that ?
17:13:18 <cococo> ski: no I've now removed that line entirely
17:13:19 <ski> why not
17:13:24 <ski>   Nothing -> return Nothing
17:13:25 <ajcoppa> cococo: do you understand why Nothing -> "" gave you errors?
17:13:26 <ski> ?
17:14:08 <cococo> ski: sure.. i'll do that | ajcoppa something about IO
17:14:43 <ajcoppa> cococo: well, kind of
17:14:59 <ajcoppa> getWhois has to provide a result that is an IO (Maybe String)
17:15:16 <ajcoppa> and the value "" doesn't match that
17:15:31 <ajcoppa> (tell me if this is too obvious, just want to be very explicit about what's happening)
17:15:42 <cococo> ajcoppa: Oh I see it now, and it's impossible to have multiple different return options?
17:16:01 <cococo> ajcoppa: not too obvious for me, I understand about 1.2% of what I'm doing right now
17:16:15 <ajcoppa> no worries, it is hard to get used to this at first. we were all there
17:16:21 <cococo> :)
17:16:27 <ajcoppa> but yes, every result from getWhois needs to have that type
17:16:29 <bergey> altern_: if you want to refer to most of Data.Aeson with a prefix but .= without, you can use two import lines, one qualified as JSON, and one unqualified but with an explicit import list ((.=))
17:16:39 <ski> cococo : you can have multiple different return options .. if i understand properly what you mean
17:17:04 <cococo> ski: thanks, just wondering if it's even possible
17:17:09 <cococo> gtg afk for a bit, be back later
17:17:10 <ski> cococo : `""' wouldn't work there, but `return (Just "")' would, as would `return Nothing'
17:17:25 <ajcoppa> okay cococo, let ski or me know if you'd like more help when you get back
17:17:57 <ski> cococo : anyway, the simplest way to, for each result in `knockKnock' of the corresponding `getWhois' actions, eiter call `isAvailable' on a result, or print a message in case of `Nothing', might be to make a new function, perhaps call it `isMaybeAvailable :: Maybe String -> IO (Maybe [Text])'
17:18:08 <ski> s/eiter/either/
17:18:24 * ski 's `h' key is weak, for some reason
17:26:29 <joelteon> is it generally considered bad practice to have an explicit import list for every module?
17:27:18 <eazar001> joelteon: It gennerally helps actually
17:27:54 <eazar001> joelton: knowing what you are calling, and from which module it resides, aids me when i code. So IMO, I don't think it's a bad thing.
17:28:45 <eazar001> however, if you are importing an entire module, then, of course, don't explicitly import the entire thing.
17:29:00 <eazar001> but you probably already knew that. [=
17:32:05 <hexagoxel_> joelteon: have you read 4 on http://www.haskell.org/haskellwiki/Import_modules_properly
17:36:10 <altern_> I have another question. Is there function similar to show that I can instantiate to define conversion of string to object instead of object to string defined by show?
17:36:38 <eazar001> read?
17:36:56 <eazar001> @hoogle read
17:36:58 <lambdabot> Prelude read :: Read a => String -> a
17:36:58 <lambdabot> Text.Read read :: Read a => String -> a
17:36:59 <lambdabot> GHC.IO.Device read :: RawIO a => a -> Ptr Word8 -> Int -> IO Int
17:37:25 <altern_> eazar001: right! thanks :)
17:37:37 <eazar001> altern_: yw [=
17:37:40 <ski> > (reads :: ReadS Integer) "123"
17:37:42 <lambdabot>  [(123,"")]
17:37:43 <ski> > (reads :: ReadS Integer) "123.45"
17:37:45 <lambdabot>  []
17:37:46 <ski> > (reads :: ReadS Integer) "-123.45"
17:37:48 <lambdabot>  []
17:37:58 <ski> > (reads :: ReadS Integer) "-123 .45"
17:38:00 <lambdabot>  [(-123," .45")]
17:38:17 <ski> > (reads :: ReadS Integer) "-123abc"
17:38:18 <lambdabot>  [(-123,"abc")]
17:38:25 <ski> altern_ ^
17:38:40 <ski> > (reads :: ReadS Double) "-123.45"
17:38:41 <lambdabot>  [(-123.45,"")]
17:40:37 <benzrf> whats a ReadS
17:40:42 <benzrf> :t reads
17:40:43 <lambdabot> Read a => ReadS a
17:40:47 <benzrf> pfft
17:40:51 <hpc> @src ReadS
17:40:52 <lambdabot> Source not found. Abort, Retry, Panic?
17:41:04 <hpc> ReadS a = String -> a
17:41:05 <benzrf> > reads "13df"
17:41:06 <lambdabot>  []
17:41:12 <hpc> er
17:41:20 <hpc> String -> [(String, a)]
17:41:22 <benzrf> > (reads :: Reads Int) "34ef"
17:41:24 <lambdabot>  Not in scope: type constructor or class ‘Reads’
17:41:24 <lambdabot>  Perhaps you meant one of these:
17:41:24 <lambdabot>    ‘ReadS’ (imported from Prelude), ‘Read’ (imported from Prelude)
17:41:27 <benzrf> > (reads :: ReadS Int) "34ef"
17:41:28 <lambdabot>  [(34,"ef")]
17:41:33 <benzrf> o=
17:41:39 <benzrf> > (reads :: ReadS String) "34ef"
17:41:40 <lambdabot>  []
17:41:44 <benzrf> > (reads :: ReadS String) "\"34ef\""
17:41:45 <lambdabot>  [("34ef","")]
17:41:48 <benzrf> sweet
17:44:49 <ski> benzrf : `ReadS' and `reads' is for being able to catch parse failure, and to (rarely used) allow multiple parses, and to allow returning the remaining unparsed part of the string (useful if you want to keep on parsing the rest as something else)
17:45:08 <ski> altern_ : that ^ might be interesting for you as well
17:45:25 <benzrf> > (reads :: ReadS String) "3443 54"
17:45:27 <lambdabot>  []
17:45:33 <benzrf> > (reads :: ReadS Int) "3443 54"
17:45:35 <lambdabot>  [(3443," 54")]
17:45:35 <eazar001> @type reads
17:45:37 <lambdabot> Read a => ReadS a
17:45:42 <benzrf> how do i get multiple parses o_o
17:45:50 <ski> `reads' will return a list of answers, one for each possible parse. if the list is empty, then there was no parse
17:46:03 <eazar001> @hoogle reads
17:46:05 <lambdabot> Prelude reads :: Read a => ReadS a
17:46:05 <lambdabot> Text.Read reads :: Read a => ReadS a
17:46:05 <lambdabot> Prelude readsPrec :: Read a => Int -> ReadS a
17:46:25 <ski> the list will contain pairs of the form `(parsedValue,stringRemainder)'
17:46:41 <benzrf> 'each possible parse'?
17:46:43 <benzrf> u wot?
17:46:49 <ski> benzrf : by defining your own operations with `ReadS' in their result type
17:47:00 <benzrf> ah
17:47:07 <benzrf> so reads itself never has more than one item?
17:47:30 <ski> it can have, if you define an instance for `Read' to do that
17:47:42 <ski> but i think the standard instances doesn't do that
17:48:14 <benzrf> > (reads :: ReadS Char) "'f''g'"
17:48:16 <lambdabot>  [('f',"'g'")]
17:48:19 <eazar001> @src reads
17:48:19 <benzrf> meh
17:48:19 <lambdabot> reads = readsPrec minPrec
17:48:25 <benzrf> @src readsPrec
17:48:25 <lambdabot> Source not found. You speak an infinite deal of nothing.
17:48:29 <benzrf> o:
17:48:31 <benzrf> :t readsPrec
17:48:32 <lambdabot> Read a => Int -> ReadS a
17:48:35 <Fuuzetsu> huh, encountered a case where I couldn't turn ‘foo $ bar $ baz x’ into ‘foo . bar $ baz x’ as I usually do
17:48:39 <Fuuzetsu> something sketchy must be going on
17:48:44 <benzrf> Fuuzetsu: pls elaborate
17:48:52 <ski> (also, i'm not sure there's any situation where i would think `reads' returning multiple results would be ok .. perhaps internally for data types with non-canonical representations or something)
17:49:47 <Fuuzetsu> using free-game, ‘draw $ translate undefined $ bitmap undefined’ OK
17:49:54 <Fuuzetsu> ‘draw . translate undefined $ bitmap undefined’ not OK
17:50:08 <ski> @let data Expr = Lit Integer | Add Expr Expr deriving (Show,Read,Eq)
17:50:09 <lambdabot>  .L.hs:173:17:
17:50:09 <lambdabot>      Ambiguous occurrence ‘Expr’
17:50:09 <lambdabot>      It could refer to either ‘L.Expr’, defined at .L.hs:172:1
17:50:09 <lambdabot>                            or ‘Debug.SimpleReflect.Expr’,
17:50:09 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
17:50:21 <ski> @let data IExpr = Lit Integer | Add IExpr IExpr deriving (Show,Read,Eq)
17:50:24 <lambdabot>  Defined.
17:56:30 <ski> @let parseIExpr :: ReadS IExpr; parseIExpr = runStateT parse where parse = do {i <- StateT reads; return' (Lit i)}; return' ie0 = return ie0 `mplus` (do "+" <- StateT lex; ie1 <- parse; return' (Add ie0 ie1))
17:56:33 <lambdabot>  Defined.
17:57:54 <ski> > [ie | (ie,"") <- parseIExpr "2 + 3 + 5"]
17:57:56 <lambdabot>  [Add (Add (Lit 2) (Lit 3)) (Lit 5),Add (Lit 2) (Add (Lit 3) (Lit 5))]
17:58:12 <ski> benzrf : ^ that's an example
17:58:39 <benzrf> o_O
17:59:39 <benzrf> is readsPrec a method
18:00:47 <ski> @let parseIExpr' :: ReadS IExpr; parseIExpr' = runStateT parse where parse = do {i <- StateT reads; return' (Lit i)} `mplus` do {"(" <- StateT lex; ie <- parse; ")" <- StateT lex; return' ie}; return' ie0 = return ie0 `mplus` (do "+" <- StateT lex; ie1 <- parse; return' (Add ie0 ie1))
18:00:51 <lambdabot>  Defined.
18:00:53 <ski> benzrf : yes
18:01:01 <ski> > [ie | (ie,"") <- parseIExpr' "2 + 3 + 5"]
18:01:03 <lambdabot>  [Add (Add (Lit 2) (Lit 3)) (Lit 5),Add (Lit 2) (Add (Lit 3) (Lit 5))]
18:01:05 <ski> > [ie | (ie,"") <- parseIExpr' "(2 + 3) + 5"]
18:01:07 <lambdabot>  [Add (Add (Lit 2) (Lit 3)) (Lit 5)]
18:01:08 <ski> > [ie | (ie,"") <- parseIExpr' "2 + (3 + 5)"]
18:01:10 <lambdabot>  [Add (Lit 2) (Add (Lit 3) (Lit 5))]
18:01:13 <benzrf> :t lex
18:01:14 <lambdabot> ReadS String
18:01:26 <benzrf> > lex "foo"
18:01:27 <lambdabot>  [("foo","")]
18:01:33 <benzrf> > lex "foo bar baz"
18:01:35 <lambdabot>  [("foo"," bar baz")]
18:01:41 <ski> `readsPrec' is the primary method of `Read', just like `showsPrec' is the primary method of `Show'
18:01:42 <benzrf> > lex "(foo + bar)"
18:01:44 <lambdabot>  [("(","foo + bar)")]
18:01:49 <benzrf> i did not know either of those thigns
18:01:54 <benzrf> *things
18:04:26 <ski> benzrf : exercise : figure out how to change the above parser (or rewrite it from scratch, if you prefer) to make it only parse `+' in a left-associated way -- also figure out how to make it only parse `+' in a right-associated way
18:04:43 <ski> (you may include or omit parsing brackets, as you see fit)
18:06:00 <benzrf> i dont even grasp how that one works
18:06:02 <benzrf> >.<
18:06:05 <benzrf> @src lex
18:06:05 <lambdabot> Source not found.
18:06:08 <benzrf> huh
18:06:28 <ski> `lex' parses (more or less) one Haskell token
18:07:29 <ski> it also automatically ignores leading whitespace
18:07:46 <cococo> How can I use "toLower" with type `Maybe String` (or is there a better way to solve this?) http://lpaste.net/7734791888808443904
18:07:52 <cococo> btw back from being afk ;)
18:07:58 <ajcoppa> hi again
18:08:03 <ski> (but for some reason it doesn't skip comments -- presumably because `Show' instances aren't expected to generate such)
18:08:19 <ski> cococo : `fmap toLower', perhaps ?
18:08:35 <ski> @type fmap toLower :: Maybe String -> Maybe String
18:08:37 <lambdabot>     Couldn't match type ‘Char’ with ‘[Char]’
18:08:37 <lambdabot>     Expected type: String -> String
18:08:37 <lambdabot>       Actual type: Char -> Char
18:08:46 <ski> oh, right, it wants a single `Char'
18:08:47 <ski> then
18:08:54 <ski> @type fmap (map toLower) :: Maybe String -> Maybe String
18:08:55 <lambdabot> Maybe String -> Maybe String
18:09:02 <cococo> ski: or of course I may be looking at it all wrong and that's the wrong solution
18:09:06 <ski> which is the same as `(fmap . map) toLower'
18:09:08 <cococo> *maybe I'm
18:09:12 <ajcoppa> cococo: well, let's back up a bit
18:09:27 <ajcoppa> what would you like isAvailable to return when you give it Nothing?
18:09:50 <cococo> ajcoppa: an empty array, seeing as none of the three "keywords" are in Nothing
18:11:15 <ajcoppa> do you know how to use pattern matching? that seems like it could be a good way to specify what behavior you want when s = Nothing, and to extract the value out of a Just otherwise
18:12:18 <cococo> ajcoppa: oh yeah
18:12:23 <cococo> i forgot about pattern matching, I can do that
18:12:36 <cococo> isAvailable Nothing = []
18:12:39 <cococo> like that, I think
18:12:43 <ajcoppa> yep, exactly
18:12:54 <ajcoppa> ski's solution is great too, but it may rely on concepts you're not familiar with yet
18:13:03 <cococo> though I'm still getting the same error, now just one line lower
18:13:14 <ajcoppa> yep
18:13:32 <ajcoppa> you'll need to pattern match for the other case too, not just when you get a Nothing
18:13:37 <benzrf> cococo: fyi, they're called lists in haskell
18:13:39 <benzrf> not arrays ;)
18:13:49 <cococo> benzrf: I keep making that mistake... thanks for the reminder
18:14:52 <ski> (Haskell has arrays as well)
18:15:10 <cococo> ajcoppa: I don't understand how I could use pattern matching to fix the "Couldn't match type `Maybe String' with `[Char]'" error
18:15:13 <cococo> ski: hmm?
18:15:34 <ajcoppa> cococo: okay, i'll try to guide you through it
18:15:46 <cococo> ty
18:16:51 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = array ix [(i,f i) | i <- range ix]
18:16:55 <lambdabot>  Defined.
18:17:19 <ajcoppa> if you know that s isn't Nothing (because it fell through that pattern and moved onto the next one)
18:17:22 <eazar001> you can also use liftM if you want to
18:17:27 <eazar001> and liftA
18:17:30 <ajcoppa> then you know that it has to be a String value wrapped in a Just
18:17:35 <eazar001> but fmap better
18:17:45 <eazar001> or >>=
18:18:06 <tnks> bitemyapp: did something weird happen to #haskell-beginner?
18:18:16 <tnks> seems like I'm the only one there.
18:18:18 <ajcoppa> tnks: #haskell-beginners
18:18:22 <tnks> oh.
18:18:24 <ajcoppa> :)
18:18:34 <ski> @let memoArr :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArr ix f i = tabulate ix f ! i
18:18:36 <lambdabot>  Defined.
18:18:58 <benzrf> :t tabulate
18:18:59 <lambdabot> Ix i => (i, i) -> (i -> e) -> Array i e
18:19:03 <benzrf> o=
18:19:17 <benzrf> > tabulate (1, 2) show
18:19:19 <lambdabot>  array (1,2) [(1,"1"),(2,"2")]
18:19:27 <benzrf> huh?
18:19:35 <ajcoppa> cococo: understand what i said above?
18:19:38 <ski> > let n0 = 12; (memoArr (0,m0) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib n0
18:19:40 <lambdabot>  Not in scope: ‘m0’
18:19:40 <lambdabot>  Perhaps you meant ‘m’ (imported from Debug.SimpleReflect)
18:19:50 <ski> > let n0 = 12; (memoArr (0,n0) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib n0
18:19:52 <lambdabot>  Not in scope: ‘n0’
18:19:52 <lambdabot>  Perhaps you meant ‘n’ (imported from Debug.SimpleReflect)
18:20:01 <ski> hmm
18:20:11 <ski> > let n0 = 12 in let (memoArr (0,n0) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib n0
18:20:13 <lambdabot>  144
18:20:14 <ski> interesting
18:20:27 <cococo> ajcoppa: looking through it..
18:20:54 <ski> > let n0 = 12 in let (tabulate (0,n0) -> fibArr) = \n -> case n of 0 -> 0; 1 -> 1; n -> fibArr ! (n-1) + fibArr ! (n-2) in fibArr
18:20:56 <lambdabot>  array (0,12) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34)...
18:21:04 <altern_> Guys. I have problem with parsing string into object: http://lpaste.net/104540 I get  Not in scope: `num' error. How could I fix it?
18:21:17 <cococo> ajcoppa: I understand what you've said
18:21:32 <cococo> ajcoppa: but I may have missed your last message cause I can't find a conclusion :/
18:21:42 <ski> > tabulate (3,9) (\n -> n^2)  -- benzrf
18:21:44 <lambdabot>  array (3,9) [(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
18:21:52 <ajcoppa> okay. do you know how to use a pattern match to "unwrap" the value inside the Just, so that it can be a String instead of a Maybe String?
18:21:58 <ski> @type tabulate (3 :: Int,9) (\n -> n^2 :: Int)
18:22:00 <lambdabot> Array Int Int
18:22:22 <eazar001> case (Just X) of z -> X
18:22:27 <eazar001> I think you can do something like that
18:22:27 <cococo> ajcoppa: I assume it's something like taking a value out of a list, but I don't know how to do that specifically
18:23:28 <ajcoppa> isAvailable (Just s) = ...
18:23:48 <eazar001> someFunction a | a == Just x = x
18:23:49 <cococo> ajcoppa: what is that magic
18:24:10 <eazar001> or i mean ...
18:24:37 <ajcoppa> cococo: it's a pattern match that will match the value wrapped inside a Just, and give the name "s" to the value inside the Just
18:24:49 <cococo> thanks ajcoppa
18:24:55 <cococo> and ty everyone who helped
18:25:27 <cococo> I can load my code into ghci with no errors :)
18:25:32 <ajcoppa> hurray
18:25:37 <cococo> "my" code
18:25:52 <ajcoppa> cococo: just out of curiosity, what learning resources are you using to get started?
18:26:00 <ajcoppa> and are you doing this for a class, or just self-study?
18:26:06 <cococo> ajcoppa: self study
18:26:29 <ski> > let someFunction a | Just x <- a = x; someFunction _ = "wrong" in map someFunction [Just "left",Just "right",Nothing]
18:26:31 <lambdabot>  ["left","right","wrong"]
18:26:32 <cococo> ajcoppa: I've read a bit of "learn you haskell" but got bored and decided to make this program to "jump right in"
18:26:36 <ski> eazar001 ^
18:27:00 <cococo> Functional programming is harder to jump right into than I expected
18:27:23 <ski> cococo : probably because you haven't used an FP language before
18:27:29 <eazar001> ski: i was actually (in my head) trying to express --> someFunction x | isJust x = fromJust x
18:27:30 <cococo> ^
18:27:35 <cococo> ski: yeah
18:27:44 <ski> cococo : learning a new programming paradigm is a bit like learning to program from scratch all over again
18:27:44 <eazar001> but i forgot that required outside lib, plus is generally hated
18:27:52 <ajcoppa> cococo: it's certainly a bit different. LYAH will start to cover what we did in the "making our own types and typeclasses" chapter
18:27:57 <ajcoppa> you may not have gotten that far yet
18:28:06 <cococo> ski: that's exactly how I feel
18:28:12 <eazar001> I thought haskell was weird ...
18:28:16 <eazar001> until i saw prolog
18:28:22 <ski> Prolog is fun :D
18:28:27 <eazar001> prolog is awesome
18:28:32 <eazar001> but it makes me REALLY think
18:28:49 <cococo> ajcoppa: I'll make myself trudge through it ;) Though it's definitely one of the easier to digest programming books I've read in a while, with all the soothing artwork etc
18:28:52 <eazar001> it makes me realize how terse and straightforward haskell is
18:29:05 <eazar001> prolog is a very "pure" language
18:29:20 <eazar001> with exception of cuts, and other stuff
18:29:20 <ski> (Mercury is more "pure" as well as more "practical")
18:29:31 <ajcoppa> cococo: no worries. taking breaks to try and reinforce the concepts is a good idea
18:29:34 <eazar001> ski: this is true... i am lurking on their channel right  now
18:29:45 <ajcoppa> has anyone told you about brent yorgey's course?
18:29:48 <eazar001> but unfortunately mercury is very underpopulated
18:29:56 <ski> Mercury needs more love
18:30:03 <cococo> ajcoppa: no, I assume you recommend it?
18:30:05 <eazar001> most definitely
18:30:16 <ski> (as does Prolog, and LP in general -- also CLP needs more love)
18:30:41 <ajcoppa> cococo: yep, i found it helpful while i was learning
18:30:44 <ajcoppa> http://www.seas.upenn.edu/~cis194/lectures.html
18:30:54 <eazar001> i think most people dislike efficiency in LP
18:31:10 <cococo> ajcoppa: thanks, i'll check it out
18:31:10 <ski> (for innocent bystanders, there are channels ##prolog and #mercury here on this network)
18:31:19 <eazar001> though efficiency isn't the number one priority in LP, however mercury claims to address those issues
18:31:20 <ajcoppa> the homework exercises are great -- they give you a little more guidance than striking out to write a full program on your own
18:31:38 <ajcoppa> so you don't end up wandering off into complexity land by accident
18:31:46 <Kaidelong> ski: is the C for Constraint or Coinductive?
18:31:56 <ski> Constraint Logic Programming
18:32:04 <cococo> It's funny how much easier the artwork+friendly_font+humorous_code_samples Learn you a Haskell makes learning Haskell seem
18:32:14 <ski> (Coinductive Logic Programming is abbreviated Co-LP, afaik)
18:32:33 <cococo> I suppose that's why it's so successful in it's niche
18:32:52 <Kaidelong> I actually forgot what their respective strengths were
18:33:07 <ski> afaict, Co-LP is very experimental
18:33:27 <Kaidelong> I think constraint logic programming was an easy way to express difficult problems, so that you could use a clever solver that solves them efficient generalized for all hard problems?
18:33:53 <Kaidelong> and coinductive logic programming is analogous to total functional programming for functional programming and deals with avoiding infinite loops?
18:34:30 <ski> CLP is good for declaratively stating constraints that a solution to a problem must satisfy -- the constraint solver will automatically take care of propagating information forwards and backwards over the posted constraints, thereby computing the solution(s)
18:35:35 <ski> (the "forwards and backwards" part is important .. you don't necessarily know beforehand in which direction information will flow)
18:36:40 <ski> the constraints can e.g. involve equalities and inequalities over arithmetic expressions
18:36:46 <altern_> Second try :) I am kinda stuck on parsing problem. I need to parse string into object: http://lpaste.net/104540 I get  Not in scope: `num' error. How could I fix it?
18:37:21 <cococo> Debugging in Haskell seems weird. Do I need to wrap everything in "do" to output my program's process?
18:37:31 <Kaidelong> @ty decimal
18:37:32 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
18:37:35 <prophile> cococo: you might enjoy Debug.Trace
18:37:38 <ski> or constraints stating that all elements in a list must be distinct, or that all the elements from some given finite set must occur somewhere in the list
18:37:50 <prophile> http://hackage.haskell.org/package/base-4.7.0.0/docs/Debug-Trace.html
18:38:03 <Kaidelong> altern_: you need to introduce the free variable num somehow
18:38:15 <gdoteof> using Data.Aeson I am trying to simplify some parsing.  If I have data Foo1 = Foo1.  data Foo2 = Foo2.  I want to have a type that is "Either a Foo1 or a Foo2 (or a Foo3, or Foo4)"
18:38:16 <Kaidelong> a lambda expression would do it, but you also need to get it out of the decimal parser
18:38:20 <Kaidelong> you can do that like this:
18:38:29 <Kaidelong> decimal >>= \num -> return (Number num)
18:38:35 <ski> altern_> :t decimal
18:38:40 <cococo> prophile: assuming I didn't want to use any external libraries
18:38:51 <gdoteof> I tried `data Bar = Foo1 | Foo2 but I think I am actually just creating new constructors
18:38:52 <ajcoppa> cococo: Debug.Trace is definitely the way to go
18:38:57 <prophile> cococo: 'base' hardly qualifies as an external library
18:38:58 <etrepum> altern_: and another way to write that would be Number <$> decimal
18:39:24 <Kaidelong> altern_: another alternative is do { num <- decimal; return (Number num) }
18:39:26 <ski>   <|> ( decimal >>= \num -> return (Number num) )  -- altern_, i suspect tis
18:39:33 <ski> s/tis/this/
18:39:35 <eazar001> altern_: I could  b wrong here but .... that _ might be nullifying your "num"
18:39:44 <gdoteof> basically I have a bunch of commands coming in and I have defined the datatype for each command.  But i'd like to have a higher level type of 'Command' that could be any of those individual ones
18:39:50 <ski> Kaidelong's solution is equivalent to what i said
18:39:52 <eazar001> >> is logically equivalent to >>= \_
18:40:02 <eazar001> so your num seems like it's getting trashed
18:40:10 <eazar001> oh, and hence why ski's answer is right [=
18:40:19 <Kaidelong> ski: so's yours! I meant that as being an alternative to what I said =p
18:40:56 <ski> Kaidelong : my solution is equivalent to what i said ? :)
18:41:02 <Tekmo> I need a programming language buff
18:41:13 <eazar001> hahaha
18:41:19 <Kaidelong> I proposed decimal >>= \num -> return (Number num) already at that point
18:41:24 <ski> Kaidelong : oh, i missed your earlier solution
18:41:24 <eazar001> have a wizard cast a spell for you
18:41:26 <benzrf> Tekmo: i know some languages, what do u need help with
18:41:47 <Tekmo> Is there a strongly normalizing dependently typed functional language?
18:41:58 <benzrf> k i dont know this one
18:42:01 * ski didn't win this time ..
18:42:02 <benzrf> but imsure somebody here does
18:42:12 <Tekmo> Ideally, this language would forbid recursion of any kind (so strong normalization would be trivial, I think)
18:42:25 <Tekmo> It would just inline everything by default, unconditionally
18:42:31 <benzrf> doesnt agda have something like that but milder
18:42:34 <ski> Tekmo : hm .. Charity isn't dependently typed
18:42:50 <Tekmo> Dependently typed is not explicitly necessary, but it's a plus
18:42:57 <Tekmo> The normalization property is more important for me
18:42:57 <etrepum> altern_: http://lpaste.net/104540
18:43:12 <ski> Charity has no recursion, though it has built-in syntax for catamorphisms and anamorphisms
18:43:18 <ski> @where Charity'
18:43:18 <lambdabot> I know nothing about charity'.
18:43:19 <ski> @where Charity
18:43:20 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
18:44:02 <ski> Tekmo : not sure whether you'd count `cata's and `ana's under "recursion of any kind"
18:44:11 <Tekmo> What I'm looking for, though, is a language that inlines everything at compile time
18:44:28 <Tekmo> In other words, if two computations are equal (via equational reasoning) then they both normalize to the same term at compile time
18:44:35 <ski> Tekmo : so it doesn't accept user-input ?
18:44:52 <ski> or could it be staged ?
18:44:54 <Tekmo> Let me clarify
18:45:07 <Tekmo> So the type of the `main` would be:
18:45:31 <Tekmo> main : Free IOF () -- where `IOF` is some base functor signature corresponding to all IO operations
18:45:40 <Tekmo> ... and the `Free` type would be implemented using the unfolds
18:45:57 <Tekmo> i.e. what charity calls coinductive data types
18:46:23 <Tekmo> So the idea is that each step of the loop would be inlined completely at compile time
18:46:44 <Tekmo> Ideally, the unfold would be encoded using this representation of the greatest fixed point:
18:46:45 <ski> ok. sounds staged
18:46:50 <Tekmo> Yeah, staged, then
18:47:02 <Tekmo> exists x . (x, x -> F x)
18:47:08 <ski> how would you encode `getChar' using this `IOF' ?
18:47:28 <Tekmo> data IOF x = GetChar (Char -> x) | PutChar Char x
18:47:59 <altern_> Kaidelong: thanks! your solution with \num -> return (Number num) works. But I have another problem now. When I try to run ' print $ parseOnly stringToVersionNumber "X" ', I get Couldn't match expected type `Data.ByteString.Internal.ByteString'  with actual type `[Char]' even though I have {-# LANGUAGE OverloadedStrings #-} declaration at the beginning of my file
18:48:01 <Tekmo> Actually, let me just throw in `Return` to simplify this and avoid the intermediate `Free` type
18:48:18 <Tekmo> data IOF r x = GetChar (Char -> x) | PutChar Char x | Return r
18:48:25 <ski> Tekmo : could the I/O layer contain (potentially) infinite loops ?
18:48:26 <altern_> Kaidelong: any thoughts on how to solve it?
18:48:35 <Tekmo> data IO r = exists x . (x, x -> IOF r x)
18:48:46 <Tekmo> ^ That's the type I have in mind for `main`
18:49:22 <Tekmo> So the idea is that `IO` per se is a finite representation of a single step of the unfold
18:49:30 <Tekmo> But the runtime will then be responsible for unfolding it repeatedly
18:49:43 <ski> "the unfold would be encoded using this representation of the greatest fixed point" suggests that the depth of the `Free' structure may be infinite
18:49:46 <Tekmo> The programmer is not given access to recursion.  Only the runtime can do it through the specially sanctioned `main`
18:50:15 <Tekmo> Just stick to the last two type definitions I gave.  Forget the `Free` for a second
18:50:25 <Tekmo> data IOF r x = GetChar (Char -> x) | PutChar Char x | Return r
18:50:27 <Tekmo> data IO r = exists x . (x, x -> IOF r x)
18:50:30 <Tekmo> main :: IO ()
18:50:34 <ski> Tekmo : but are servers allowed ?
18:50:37 <Tekmo> Yes
18:50:40 <ski> ok
18:50:54 <Kaidelong> altern_: could you pastebin the whole type error?
18:51:08 <Tekmo> The runtime takes the `IO ()` assigned to `main` and then unfolds it infinitel
18:51:10 * ski is reminded of a list representation he was thinking about for some time ago
18:51:23 <Tekmo> However, the programmer is never allowed to right any recursive code at all
18:51:35 * ski nods
18:51:59 <Tekmo> The idea is that if you eliminate programmer-introduced recursion you can greatly simplify the compiler
18:52:08 <ski> the program terminates when your function of type `x -> IOF r x' yields a value constructed by `Return'
18:52:13 <Tekmo> Exactly
18:52:24 <ski> (the completely inlined and reduced program, i.e.)
18:52:27 <Tekmo> Right
18:52:30 <Tekmo> That's what I would like
18:52:49 <Tekmo> The goal is that there should be no abstraction penalty
18:52:51 <Kaidelong> @ty parseOnly
18:52:52 <lambdabot> Not in scope: ‘parseOnly’
18:52:54 <Tekmo> ... since everything is inlined
18:53:01 <Tekmo> Well, let me rephrase that
18:53:08 <Tekmo> You only pay for abstraction at compile time, not run-time
18:53:13 <ski> `exists s. (s,s -> f s)' is an interesting representation of `nu s. f s'
18:53:19 <Tekmo> I stole it from Wadler
18:53:33 <Tekmo> It's from this: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
18:53:56 * ski can't recall where he saw it -- possibly on this channel
18:53:56 <Tekmo> The idea is you use the `exists` version for anamorphisms, and you use this for catamorphisms:
18:54:04 <Tekmo> forall x . (F x -> x) -> x
18:54:06 <Tekmo> Or something like that
18:54:13 <Tekmo> I always forget exactly how it's universally quantified
18:54:21 <ski> yes, like that
18:54:27 <ski> that's `mu r. F r'
18:55:06 <Tekmo> By encoding things as anamorphisms or catamorphisms you remove the recursion and greatly simplify the compiler's job
18:55:12 <ski> Tekmo : you can use the `exists' version for an interesting encoding of (inductive) lists
18:55:24 <Tekmo> Yeah, you can encode lists using both versions
18:55:37 <yyyyy> is development of the haskell platform dead?
18:55:43 * ski was experimenting with that to be able to fuse loops
18:55:45 <Tekmo> The catamorphisms have the nice property that (if you forbid recursion) you can evaluate them completely at compile time and guarantee that they terminate
18:55:55 <ReinH> Tekmo: hi!
18:56:00 <Tekmo> In fact, if you loop over a list encoded as a catamorphism and inline it you get an unrolled loop
18:56:03 <Tekmo> ReinH: Hi!
18:56:23 <Tekmo> Whereas if you use the anamorphism you get a "traditional" loop
18:57:23 <ski> Tekmo : in my case, at least for certain list-operating functions, if i make a pipeline from one that constructs an initial list, through list-transforming ones, til a list-consuming one, it'll automatically fuse together into a single loop
18:57:36 <Tekmo> ski: That's exactly right
18:57:38 <Tekmo> That's another reason I want this
18:57:42 <ski> i tried this with staged programming, and the generated code contained just one recursive loop
18:57:43 <Tekmo> So that I get things like stream fusion for free
18:57:59 <ski> (i tried it in MetaML, to be specific)
18:58:20 <Tekmo> The goal is that if two programs are denotationally equal, then they should generate the exact same code when strongly normalized
18:58:43 <Tekmo> I want there to be zero runtime penalty for abstractions
18:58:58 <Tekmo> Abstractions only increase compile time
18:59:17 <Tekmo> There's another nice benefit of eliminating recursion
18:59:23 <Tekmo> You don't have to worry about laziness
18:59:23 <ski> (just one recursive loops, e.g. as opposed to essentially one recursive loop, but indirected through multiple separately defined functions, with or without calling each other indirectly)
18:59:38 <Tekmo> You can safely strictly evaluate everything at compile time since it's guaranteed to terminate
18:59:56 <Tekmo> Anamorphisms take the place of what Haskell traditionally uses laziness for
19:00:16 <Tekmo> Well, sort of
19:00:19 <Tekmo> I'm oversimplifying
19:00:23 <ski> hm, .. i'm not sure anamorphisms can be used for by-need ?
19:00:24 <Tekmo> Haskell's laziness is more powerful than that
19:00:53 <ski> (consider e.g. top-down dynamic programming with an (immutable) array with lazy elements)
19:00:56 <Tekmo> Yeah
19:01:02 <Tekmo> That's something that this does not solve well
19:01:11 <ski> (or a tree instead of an array, if you prefer)
19:01:49 <ski> anyway, i haven't thought about such things in the context of dependent typing
19:01:50 <Tekmo> So what I want is a non-recursive "inlining engine"
19:01:53 <Tekmo> Not even a compiler
19:01:56 <Kaidelong> altern_: Yeah you need to show us more code, lateral thinking about that type error is not cutting it for me at least. Give us the whole module
19:02:05 <Tekmo> The source and destination language are the same (basically lambda calculus)
19:02:11 <Tekmo> I just want it to strongly normalize things and that's it
19:02:19 <ski> Tekmo : possibly lessons from partial evaluation could be useful here ..
19:02:36 <cococo> Sorry people I thought I was done here... What does this exception mean when printing "whosThere"? (output at bottom) http://lpaste.net/7634513890029600768
19:02:50 <Tekmo> There's yet another reason I want this
19:03:05 <Tekmo> I want to be able to statically analyze program performance and resource usage easily
19:03:17 <Tekmo> I know that it's still not possible in general, but for some things it is easier
19:04:05 <Tekmo> I suppose I can write this up myself, but I just wanted to see if there was prior work I could study
19:04:17 <yyyyy> i'm only asking since it seems some packages build against GHC 7.8 now, and i'm having to manually check the maximum upper bound for the latest haskell platform.
19:05:04 <yyyyy> while when i tried to upgrade to GHC 7.8 some older packages stopped working and i've moved back. in particular, i couldn't build agda anymore.
19:05:47 <yyyyy> is anyone experiencing the same thing? i haven't been on IRC these last months, so maybe i'm just very late to some obvious news.
19:06:00 <ski> cococo : .. seems someone is calling `hGetContents'
19:06:14 <ski> Tekmo : *nod*
19:06:56 <yyyyy> (or maybe i should finally learn nix to have multiple environments since there's no other choice?)
19:07:47 <cococo> ski: Well I'm certainly not calling it on purpose..
19:08:20 <vanila> GHC is 7 gigabytes yet doesn't even come with state monad??
19:08:26 <vanila> what the hell is going on
19:08:46 <benzrf> 7 gigs?
19:08:48 <benzrf> since when?
19:08:54 <ski> Tekmo : as you can gather, i've thought a little bit about some related loops fusion issues, and i'm interested in the topic. if you find any interesting paper/resource or come up with some relevant hunch/idea, i'd be interested in hearing/discussing it
19:08:55 <benzrf> the platform is only 0.5 gigs
19:09:35 <yyyyy> vanila: i think the download for GHC is around 150 MB. how did you get to this?
19:10:04 <monochrom> yyyyy, Agda has not been officially updated for GHC 7.8. but you may manually change its bound on base and give it a try
19:10:36 <ski> cococo : i suspect, but aren't sure, that `whois1' perhaps only supports one socket at a time (by reusing some global resource) -- you could attempt to force the string returned by it, to check
19:10:37 <monochrom> perhaps vanila's "7 gigabytes" is hyperbole, not literal
19:11:14 <Tekmo> ski: I'll probably just write this up and blog about it.  I find that the easiest way to learn is to just do it and have tons of people tell me I'm an idiot :)
19:11:36 <yyyyy> monochrom: i've tried, but some further error precluded me from building. it seems the next release will support 7.8, so i'll probably just wait using the platform for the moment.
19:12:00 <ski> Tekmo : if you remember to, you could perhaps notify me when/if you do so
19:12:03 <cococo> ski: Sorry I don't understand what you mean :(
19:12:07 <yyyyy> is mostly everyone running 7.8 nowadays?
19:13:01 <Tekmo> ski: I will! :)
19:13:26 <ski> cococo : try replacing `whois1 s serv' by `whois1 s serv >>= maybe Nothing (\s -> seq (length s) (Just s))'
19:14:08 <ski> hm
19:14:46 <cococo> ski: getting some IO Maybe String errors with that
19:14:47 <ski> cococo : sorry, by `whois1 s serv >>= maybe (return Nothing) (\s -> seq (length s) (return (Just s)))'
19:14:47 <monochrom> I still use 7.6.3 most of the time.
19:14:55 <cococo> k one min
19:14:57 <ski> @type (>>= maybe (return Nothing) (\s -> seq (length s) (return (Just s))))
19:14:59 <lambdabot> Monad m => m (Maybe [a]) -> m (Maybe [a])
19:15:03 * ski nods
19:16:10 <cococo> ski: I got "*** Exception: <socket: 9>: hGetContents: resource vanished (Connection reset by peer)" during the first "Getting whois..."
19:16:17 * hackagebot logic-TPTP 0.4.1.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.4.1.0 (DanielSchuessler)
19:16:30 <ski> cococo : ok .. so it appears something else is amiss, then
19:16:45 <ski> cococo : sorry for wasting your time
19:17:00 <cococo> ski: np, I appreciate all the help
19:18:34 <ski> (what my addition did is make sure that the whole string returned by `whois1' is actually fetched before `getWhois' completes -- that's why you're now getting the error corresponding to the first `whois1' call at the first `getWhois' call, rather at the `print' call)
19:19:10 <cococo> got it, thanks
19:19:32 <ski> (one can do that in nicer ways. the above was a quick fix, to check it)
19:19:39 <ski> cococo : anyway, i don't know that much about sockets, so i'm not sure where to continue looking for problems
19:19:54 <ski> perhaps someone else can help further
19:20:50 <cococo> ^ Anyone? (output at bottom)  `getWhois' completes -- that's why you're now getting the error corresponding
19:20:55 <cococo> shit pasted wrong
19:20:56 <cococo> ugh
19:20:59 <cococo> http://lpaste.net/7734791888808443904
19:21:14 <cococo> linux middle click has some weird pasting behaviour
19:21:18 * hackagebot HaskellNet-SSL 0.2.4 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.4 (DanielWright)
19:21:59 <ajcoppa> cococo: that's the wrong paste isn't it?
19:22:31 <cococo> ajcoppa: oh yeah ugh
19:22:33 <cococo> hold on
19:22:40 <cococo> ffs
19:23:17 <cococo> ta da http://lpaste.net/3059258132099235840
19:25:06 <ajcoppa> yep, that's the right one. i can't help though -- haven't had to troubleshoot an issue like that before
19:25:34 <dpld> @djinn ((a -> a) -> a) -> (a -> a) -> a
19:25:34 <lambdabot> f a = a
19:31:42 <benzrf> @djinn a
19:31:42 <lambdabot> -- f cannot be realized.
19:31:44 <benzrf> @djinn a -> a
19:31:44 <lambdabot> f a = a
19:31:48 <benzrf> @djinn a -> a -> a
19:31:48 <lambdabot> f _ a = a
19:31:58 <benzrf> @djinn a -> b -> c
19:31:58 <lambdabot> -- f cannot be realized.
19:32:21 <benzrf> @djinn (a -> b) -> (b -> a)
19:32:21 <lambdabot> -- f cannot be realized.
19:36:22 <mada> does @djin provide an implementation that satisfies the type signature?
19:36:26 <mada> if possible?
19:36:31 <mada> @djinn*
19:36:31 <lambdabot> Cannot parse command
19:36:35 <benzrf> mada: to a limited extent
19:36:46 <ski> > let take :: Int -> [a] -> [a]; take n as = check n (foldr (\a loop n -> a : check (n-1) loop) (\n -> []) as) where check n loop = if n <= 0 then [] else loop n in take 3 (0:1:2:error "")
19:36:47 <lambdabot>  [0,1,2]
19:37:18 <benzrf> @djinn (a -> b) -> (a0 -> a) -> (a0 -> b)
19:37:19 <lambdabot> f a b c = a (b c)
19:37:32 <ski> hm, i don't quite like that. the body of `check' have been factored, but there's still two `check' calls. and `check' is "superior" to the first argument of `foldr'
19:37:34 <benzrf> it doesnt have recursive types tho
19:40:51 <flebron> armlesshobo: ((->) e) could be called Hom(e, -) or [e, -].
19:41:07 <ion> Home alone
19:41:08 <flebron> Err nevermind, was scrolled waaaaaay up. Sorry.
19:43:01 <ski> @let newtype T a = Mk {un :: Int -> T a -> [a]}
19:43:03 <lambdabot>  Defined.
19:43:08 <ski> > let take :: Int -> [a] -> [a]; take n as = un check n (foldr (\a loop -> Mk $ \n chk -> a : un chk (n-1) loop) (Mk $ \n chk -> []) as) where check = Mk $ \n loop -> if n <= 0 then [] else un loop n check in take 3 (0:1:2:error "")
19:43:10 <lambdabot>  Ambiguous occurrence ‘un’
19:43:10 <lambdabot>  It could refer to either ‘L.un’, defined at L.hs:209:18
19:43:10 <lambdabot>                        or ‘Control.Lens.Review.un’,
19:43:10 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:41:1-43
19:43:10 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
19:43:20 <ion> If i ever wrote an IRC client, i’d copy the idea the Irssi author had (but never got around to implementing in the form of Irssi2, i think) and have scrolling automatically split the screen to the area you have scrolled to and any the few newest lines of output that were added after you started scrolling.
19:43:38 <ski> > let take :: Int -> [a] -> [a]; take n as = L.un check n (foldr (\a loop -> Mk $ \n chk -> a : L.un chk (n-1) loop) (Mk $ \n chk -> []) as) where check = Mk $ \n loop -> if n <= 0 then [] else L.un loop n check in take 3 (0:1:2:error "")
19:43:40 <lambdabot>  [0,1,2]
19:43:41 <ion> s/and any/and/
19:43:45 <ski> that's better
19:44:10 <ion> @type L.un
19:44:11 <lambdabot> T a -> Int -> T a -> [a]
19:44:33 <ion> Ah, i missed the @let
19:45:04 <ski> (really, i'd like to define that `T' in the `where', as it's a temporary type. but alas, i can't :/ )
19:45:16 <ion> Yeah, that would be convenient.
19:46:03 <ski> this version is "nicer" than the earlier one, because not `check' calls itself, rather than being called by the lambda
19:46:22 <Cale> ion: What I really want is the ability to temporarily filter the display to lines by a few selected nicks
19:46:59 <Cale> (e.g. so that I can look back on a low-frequency conversation that some people were having)
19:47:26 <ski> (so this corresponds better to two interacting, but separated, coroutines. where in this case one of the coroutines is more dummy than the other, in that it doesn't carry a state of its own)
19:48:37 <ski> Cale : yea, but it'd be easy to miss other people who make comments, if they're not addressing one of the main participants
19:48:54 <ski> (s/addressing/explicitly addressing/)
19:49:31 <flebron> So polymorphism in Hask can be interpreted as natural transformations. Is there a notion of horizontal and vertical composition that can be modelled in terms of polymorphism? (I think horizontal composition would be just polymorphism function composition)
19:50:35 <ion> ski, cale: Perhaps show the discussion you’re interested in in white and everything else in gray. It’ll be easy to follow the discussion but you still have the ability to see any relevant comments you may have filtered out.
19:51:05 <ion> Assuming a dark background. :-P
19:53:07 <ski> @type let foo :: Functor g1 => (forall a. f0 a -> g0 a) -> (forall b. f1 b -> g1 b) -> (forall a. f1 (f0 a) -> g1 (g0 a)); foo eta epsilon = fmap eta . epsilon in foo
19:53:08 <lambdabot> Functor g1 => (forall a1. f0 a1 -> g0 a1) -> (forall b. f1 b -> g1 b) -> f1 (f0 a) -> g1 (g0 a)
19:53:38 <ski> @type let bar :: Functor f1 => (forall a. f0 a -> g0 a) -> (forall b. f1 b -> g1 b) -> (forall a. f1 (f0 a) -> g1 (g0 a)); bar eta epsilon = epsilon . fmap eta in bar
19:53:40 <lambdabot> Functor f1 => (forall a1. f0 a1 -> g0 a1) -> (forall b. f1 b -> g1 b) -> f1 (f0 a) -> g1 (g0 a)
19:54:20 <ski> @type let baz :: (forall a. f a -> g a) -> (forall a. g a -> h a) -> (forall a. f a -> h a); baz eta epsilon = epsilon . eta in baz
19:54:22 <lambdabot> (forall a1. f a1 -> g a1) -> (forall a1. g a1 -> h a1) -> f a -> h a
19:54:39 <ski> flebron : like those ^ ?
19:55:14 <ski> or did you have a different kind of answer in mind ?
19:56:34 <flebron> So the last one is vertical composition, correct?
19:56:45 <ski> (hm, it might be nice if one could say that some piece of code requires either a constraint `Functor f1' or a constraint `Functor g1' -- one problem would be ensuring semantics stays the same, in case both obtains)
19:57:01 * ski can never recall which is which of vertical and horizontal composition
19:57:05 <flebron> (Since it's componentwise, everything works out nicely by just writing out the composition of the fmaps.)
19:57:28 <xxx-man> ski: hi
19:58:19 <ski> xxx-man : lo
20:06:15 <fuzzyhorns> i have seen a lot of confusing info on static typing, can someone show me a code example in haskell?
20:06:50 <hskl> hey everyone.. anyone know why exactly there are so many ERESTARTSYS/sigvtalrm/rt_sigreturn/futex syscalls when i'm stracing some threaded code.. i'm using hinotify on several directories. Each directory is addWatch'd, in the hinotify code this just adds my 'event handler' to some map etc.. it only seems like 2 threads are created, regardless of how many directories im watching.. so, when I strace, the process is just going nuts.. any ideas? I'm compiling with -Wall -
20:10:24 <monochrom> fuzzyhorns: try my http://lpaste.net/52480
20:11:52 <fuzzyhorns> monochrom: ty ill take a look!
20:13:18 <fuzzyhorns> monochrom: so what am i seeing here re: typing?
20:13:53 <ajcoppa> fuzzyhorns: what are you trying to get out of said code example?
20:14:21 <fuzzyhorns> i asked before for an example of what static typing lets me do or not do
20:14:45 <fuzzyhorns> given the explanations ala google are somewhat mixed
20:14:47 <geekosaur> qrada, thread switching and sometimes garbage collection happen according to a timeer signal, specifically that SIGVTALRM
20:14:51 <qrada> as a quick test, i compiled a getLine loop into it.. so none of the inotify/thread code gets hit etc.. the ERESTARTSYS's stop.. when input a line, i'll see several of them fire then it'll block again.. which seems good
20:15:55 <geekosaur> because ghc uses an N:M thread model (that is, there's a pool of Haskell threads multiplexed on a pool of OS threads; plus the I/O manager uses a separate thread of its own)
20:16:05 <blaenk> yeah it has to do with the runtime. what's the problem? you think ERESTARTSYS is bad or something?
20:16:05 <qrada> geekosaur: ah... is there something I can do to quiet it down though? I read online that '-threaded' made it silent for some old ghc's.. it just seems like an excess amount of restarted syscalls.. ~1k in a minute or so
20:16:22 <qrada> nah
20:16:30 <blaenk> if you just want to be able to see other stuff, I think that'd involve strace functionality. I think you can filter out specifically what you want
20:17:04 <qrada> nah i'm just trying to see if this is normal/unavoidable or if it's something I can fix
20:17:10 <qrada> by fix i mean quiet it down
20:17:11 <blaenk> ah okay
20:17:26 <geekosaur> qrada: maybe +RTS -V0 will help?
20:17:50 <qrada> for example if I am receiving 100k inotify events in a few minutes, all of those erestartsys's just make me feel like i'm that much closer to my inotify queue filling up and events overflowing
20:17:54 <qrada> just because of the extra overhead
20:17:59 <qrada> cool geekosaur let me try
20:18:07 <geekosaur> (may need to compile with --rtsopts) it'll impact thread scheduling but should disable the itimer
20:18:33 <geekosaur> alternately you could play with other -V values to change how often the itimer fires, IIRC
20:19:10 <qrada> cool thanks, going to check it out
20:19:12 <qrada> appreciate it folks
20:19:38 <geekosaur> there are some other RTS timing options that will also be in play; try "ghc +RTS --help" to see a list
20:19:45 <geekosaur> also see the ghc manual
20:19:45 <qrada> nice
20:19:59 <qrada> ya i'm checking the manpage, my / searches didn't yield anything like this
20:20:09 <ski> fuzzyhorns : Haskell has type-inference, which means that (most of the time), you don't have to specify the types of variables, function arguments and function result -- the compiler is smart to figure them out for itself, from the usage. it will complain if you have inconsistent usage somewhere
20:20:14 <geekosaur> the manpage is ... sparse
20:20:19 <qrada> ya, just now noticing that
20:20:20 <qrada> ;f
20:20:41 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
20:21:06 <geekosaur> ^ RTS options page from the online full manual
20:21:20 <geekosaur> ghc's manpage would be huge and unmanageable if it were complete
20:21:25 <qrada> nice ya im checking ghc +RTS --help .. hadn't seen any of that
20:21:32 <geekosaur> (compare the old rn manual :)
20:21:37 <ski> fuzzyhorns : you can notice that the only place monochrom specified any types in that example is for the constants `init_lo' and `init_hi'
20:22:42 <ski> fuzzyhorns : naturally, most of us here think that having static typing with (for the most part) type inference is a good thing
20:22:58 <qrada> eh.... +RTS -V0 worked... excellent
20:23:03 <qrada> thanks alot geekosaur
20:23:32 <ski> fuzzyhorns : it catches some whole classes of bugs at compile-time, so you can fix them before the program is shipped and is running at a client
20:23:32 <qrada> now I just need to see if this impacts my code in any undesirable way.. but this inotify code only uses one thread so..
20:24:27 <geekosaur> there are also some ghc versions which fired the itimer much too often, notably ghc 7.4.x
20:24:33 <ski> fuzzyhorns : obviously it doesn't catch every bug (so you still need testing), but you can often code in a style which makes more potential bugs into type errors
20:24:58 <ski> fuzzyhorns : do you have any specific things you're wondering about ?
20:25:18 <qrada> -B sound the bell at the start of each garbage collection. <- never seen that in any langs with garbage collector's, sounds useful
20:25:29 <cococo> Can anyone figure out why I'm getting this socket error? (Output in comment at bottom) http://lpaste.net/3059258132099235840
20:25:40 <qrada> geekosaur: ya my searches resulted in lots of 7.4.x results and xmonad stuff
20:26:19 <geekosaur> yeh, we saw it a lot since xmonad is quite useful on laptops but the 7.4.x bug meant it ate batteries for lunch :/
20:27:05 <altern_> I have another problem with JSON parsing: http://lpaste.net/104543 interpreter says Couldn't match type `Data.Text.Internal.Text' with `[Char]'     Expected type: String       Actual type: Data.Text.Internal.Text. How can I fix this?
20:27:28 <roconnor> @pl \f -> fmap partitionEithers . traverse ((fmap . uncurry) (\b -> if b then Left else Right) . _1 id . (f &&& id))
20:27:28 <lambdabot> (line 1, column 95):
20:27:28 <lambdabot> unexpected '_'
20:27:28 <lambdabot> expecting simple term
20:28:11 <roconnor> oh please
20:28:18 <roconnor> @pl \f -> fmap partitionEithers . traverse ((fmap . uncurry) (\b -> if b then Left else Right) . underscore1 id . (f &&& id))
20:28:18 <lambdabot> (fmap partitionEithers .) . traverse . ((fmap (uncurry (flip (flip if' Left) Right)) . underscore1 id) .) . (&&& id)
20:28:24 <qrada> i got my haskell shirt from spreadshirt.de today... ;f
20:29:41 <ion> It doesn’t have the Haskell logo?
20:30:13 <qrada> i guess not, it has a lambda
20:31:55 <roconnor> @hoogle a -> a -> Bool -> a
20:31:57 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
20:31:58 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
20:31:58 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
20:32:26 <ion> monthAndDayToDayOfYear was a really useful answer.
20:32:52 <ion> Also, a good example of bad overloading of booleans. :-P
20:36:10 <altern_>   I have another problem with JSON parsing: http://lpaste.net/104543 interpreter says Couldn't match type `Data.Text.Internal.Text' with `[Char]'     Expected type: String       Actual type: Data.Text.Internal.Text. How can I fix this?
20:40:29 <saml_> :t fromString
20:40:31 <lambdabot>     Not in scope: ‘fromString’
20:40:31 <lambdabot>     Perhaps you meant one of these:
20:40:31 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
20:40:41 <saml_> @hoogle Text -> String
20:40:43 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
20:40:44 <lambdabot> Data.Text.Internal showText :: Text -> String
20:40:44 <lambdabot> Data.Text.Lazy unpack :: Text -> String
20:41:15 <saml_> maybe you don't need pack  in ( pack v )
20:48:14 <Mathnerd314> so GHC 7.8 has value-level holes (1 + _); does it have type level holes (Int -> _ -> Bool)?
20:49:18 <SrPx> Can every recursive function in any arbitrary datatype be defined with the fold operator of that type?
20:49:33 <SrPx> non-recursively
20:49:38 <carter> Mathnerd314: nopes, not yet
20:49:59 <carter> SrPx: mebe
20:50:08 <SrPx> carter: )=
20:50:16 <carter> SrPx: thats not a helpfu emoticon
20:50:25 <SrPx> carter: ):
20:50:25 <carter> @google fold complete for frees
20:50:26 <lambdabot> http://free-fold.com/
20:50:27 <lambdabot> Title: Free Fold | Suit Carrier and Commuter Travel System
20:50:31 <cococo> Can anyone figure out why I'm getting this socket error? (Output in comment at bottom) http://lpaste.net/3059258132099235840
20:50:32 <carter> @google fold complete for tree data stypes
20:50:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Other_data_structures
20:50:33 <lambdabot> Title: Haskell/Other data structures - Wikibooks, open books for an open world
20:50:33 <startling> SrPx, not all recursive functions terminate, for one
20:50:43 <carter> up,
20:50:44 <startling> SrPx: (but I guess not all data structures are finite :P )
20:50:44 <SrPx> carter: thanks!
20:50:55 <carter> yes, startling  is right
20:51:08 <carter> SrPx: for boring tree shaped things, if you don't care about sharing or something, probably
20:51:10 <SrPx> actually, what?? free-fold.com is ... I don't know what it is
20:51:11 <startling> SrPx: btw, these are sometimes called "eliminators"
20:51:17 <carter> nor do i
20:51:21 <carter> i just gogoled for words
20:51:38 <SrPx> Freefold is Removable, Recyclable lightweight and waterproof.
20:51:46 <SrPx> maybe the answer lies somewhere on the waterproof
20:51:58 <carter> hah
20:52:25 <SrPx> startling: these = folds ?
20:52:37 <startling> SrPx: yeah.
20:52:46 <carter> @google tree eliminators type theory
20:52:47 <lambdabot> http://www.cs.ru.nl/~freek/talks/lc-2012/lambda8.pdf
20:52:47 <lambdabot> Title: Martin-Löf type theory
20:52:59 <startling> e.g. the eliminator for Nat is a -> (a -> a) -> a
20:53:05 <startling> er
20:53:16 <startling> a -> (a -> a) -> Nat -> a :P
20:54:01 <startling> :t foldr
20:54:02 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:54:13 <startling> ^ the same thing, with an additional parameter
20:54:25 <startling> :t maybe
20:54:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:54:28 <startling> :t either
20:54:29 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:55:02 <startling> Sometimes I think automatically deriving eliminators might be more useful than deriving field accessors or lenses or whatever,
20:55:30 <startling> but I guess unwieldy for large structures.
21:10:21 <altern_> @hoogle Text -> ByteString
21:10:23 <lambdabot> Data.Text.Encoding encodeUtf16BE :: Text -> ByteString
21:10:23 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16BE :: Text -> ByteString
21:10:23 <lambdabot> Data.Text.Encoding encodeUtf16LE :: Text -> ByteString
21:11:11 <altern_> @hoogle String -> ByteString
21:11:13 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
21:11:13 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
21:11:13 <lambdabot> Prelude error :: [Char] -> a
21:20:11 <altern_> @hoogle IO String -> String
21:20:13 <lambdabot> Data.Data tyconModule :: String -> String
21:20:13 <lambdabot> Data.Data tyconUQname :: String -> String
21:20:13 <lambdabot> Test.QuickCheck.Text bold :: String -> String
21:20:26 <altern_> @hoogle (IO String) -> String
21:20:26 <lambdabot> Data.Data tyconModule :: String -> String
21:20:26 <lambdabot> Data.Data tyconUQname :: String -> String
21:20:26 <lambdabot> Test.QuickCheck.Text bold :: String -> String
21:20:40 <carter> @hoogle a->b
21:20:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:20:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:20:41 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
21:20:45 <carter> thats my fave :)
21:21:04 <carter> a->b makes anything possible
21:21:07 <carter> :t unsafeCoerce
21:21:08 <lambdabot> Not in scope: ‘unsafeCoerce’
21:21:20 <carter> :t Unsafe.Coerce.unsafeCoerce
21:21:21 <lambdabot> a -> b
21:21:23 <joelteon> hey, has anyone here gotten haskellmode-vim to index multiple haddocks locations?
21:21:52 <carter> > (Unsafe.Coerce.unsafeCoerce "seven") +  (8 ::Int)
21:21:54 <lambdabot>  Not in scope: ‘Unsafe.Coerce.unsafeCoerce’
21:22:14 <carter> > (Unsafe.Coerce.unsafeCoerce "seven") +  (8 ::Int)
21:22:16 <lambdabot>  Not in scope: ‘Unsafe.Coerce.unsafeCoerce’
21:22:20 <carter> darn sandboxes
21:22:53 <carter> i just wanna get some memory addresses and corrupt the bot
21:24:43 <jle`> carter: lambdabot is tempered with the experience of quite a few years of people trying to do just that
21:24:52 <carter> jle`: i know
21:24:54 <jle`> but i'm interested in what you can do
21:25:03 <carter> i was just surprised that i can type check unsafe coerce
21:25:05 <carter> but i can't use it
21:25:24 <carter> jle`: try doing the expression i did above inyour own ghci
21:25:43 <jle`> i'm scurred
21:25:46 <carter> nope
21:26:18 <carter> try it
21:26:45 <carter> Prelude Unsafe.Coerce> (unsafeCoerce "seven") + (8 ::Int)
21:26:46 <carter> 1152921504624645864
21:26:48 <carter> :)
21:27:06 <carter> basically it treats the heap address of the first char in the list as an Int#
21:27:24 <jle`> ah
21:27:41 <jle`> because it's a boxed value and just contains the pointer?
21:27:49 <carter> yeah
21:28:26 <jle`> i would have thought unsafeCoerce attempts to coerce the value at the end of the pointer
21:28:30 <carter> nope
21:28:45 <carter> unsafe coerce is just "X is this type"
21:28:45 <carter> nothing more
21:28:48 <carter> the RTS is fully type errased
21:29:06 <carter> the only way to recover the type at runtime is if typeable is lying around
21:29:16 <carter> which is the same as threading the info in at compile time
21:29:16 <jle`> but why would it assume X is an Int# and not an Int
21:29:30 <carter> because Int = Int Int#
21:29:39 <carter> so Cons will be like the Int constructor
21:29:50 <jle`> ah
21:29:52 <jle`> cute
21:30:24 <carter> amusingly
21:30:25 <carter> Prelude Unsafe.Coerce> (unsafeCoerce "") + (8 ::Int)
21:30:25 <carter> 4546487632
21:30:31 <carter> always gives the same annswer
21:30:32 <carter> but
21:30:38 <carter> Prelude Unsafe.Coerce> (unsafeCoerce "seven") + (8 ::Int)
21:30:38 <carter> -5764607523016466308
21:30:39 <carter> doesn't
21:30:51 <jle`> is it because it's a Nil cell
21:30:51 <carter> 1729382256928082606
21:30:53 <carter> yup
21:30:56 <carter> and theres only one
21:31:20 <jtcwang> hey, can anyone try a fresh install of "conduit-combinators" for me? (in a sandbox, ideally)
21:31:35 <carter> why can't you? :)
21:31:38 <jtcwang> build is failing for me on the package system-fileio
21:31:42 <carter> with what
21:31:45 <jtcwang> just wanna see if it's me
21:31:46 <carter> @lpaste the error
21:31:46 <lambdabot> Haskell pastebin: http://lpaste.net/
21:31:48 <jle`> what if I tried to do (unsafeCoerce "seven") + (8 :: Int#) ... hm.
21:31:53 <jle`> or whatever the unboxed version of (+) is
21:31:56 <carter> jle`: that won't work
21:32:09 <carter> +# would work mebe
21:32:23 <carter> jtcwang: @lpaste it
21:32:31 <jtcwang> sec
21:32:40 <jtcwang> I lost my SO question
21:32:44 <jle`> initially i jus did ghci> unsafeCoerce "seven" and i got some sort of segfault
21:32:45 <jtcwang> i'll be back!
21:32:55 <jle`> even though i have NoMonomorphismRestriction on
21:33:04 <carter> jle`: you can't use unlifed types in ghci :)
21:33:06 <jle`> oh
21:33:15 <carter> also you can't write TC instances for unlifted types
21:33:16 <jle`> did it try to use it as an IO String
21:33:20 <carter> no
21:33:26 <carter> idk
21:33:47 <carter> :t Unsafe.Coerce.unsafeCoerce "seven"
21:33:48 <lambdabot> b
21:34:04 <carter> :t Unsafe.Coerce.unsafeCoerce "seven" ++ "eight"
21:34:05 <lambdabot> [Char]
21:34:07 <carter> :)
21:34:13 <jle`> because if you wrote "return 6" in ghci, it takes it as an IO Integer
21:34:21 <jle`> because it assumes you're in the IO monad
21:34:44 <jle`> and then it attempts to show what the IO action returns
21:34:53 <carter> return id
21:34:59 <carter> > return id
21:35:01 <lambdabot>  No instance for (GHC.Show.Show (m0 (a0 -> a0)))
21:35:01 <lambdabot>    arising from a use of ‘M290578863286571334522235.show_M2905788632865713345...
21:35:02 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
21:35:02 <lambdabot>  Note: there are several potential instances:
21:35:02 <lambdabot>    instance [safe] GHC.Show.Show a =>
21:35:08 <jle`> return id does nothing
21:35:10 <jle`> er
21:35:12 <carter> :)
21:35:12 <jle`> prints nothing
21:35:16 <jle`> nothing in my mental model can account for this
21:35:18 <jle`> :)
21:35:19 <carter> because aint no show
21:35:36 <jle`> heh.
21:35:39 <joelteon> does hint have the GHCi-ish capability to figure out where a function is defined?
21:35:42 <jle`> x <- return id
21:35:52 <jle`> :t x  -- x :: GHC.Prim.Any * -> GHC.Prim.Any *
21:35:53 <lambdabot> Expr
21:36:07 <carter> joelteon: if it doesn't, that'd be a neat patch
21:36:29 <carter> joelteon: you prolly don't wanna do andy
21:36:31 <carter> *any
21:36:56 <jle`> does x <- return y force monomorphism or something
21:37:06 <carter> idk
21:37:09 <carter> test it :)
21:37:15 <jle`> and what is GHC.Prim.Any * even mean
21:37:17 <jle`> so many questions
21:37:24 <carter> @google GHC ANY
21:37:25 <lambdabot> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
21:37:26 <lambdabot> Title: GHC.Prim
21:37:46 <carter> data Any k Source
21:37:46 <carter> The type constructor Any is type to which you can unsafely coerce any lifted type, and back.
21:37:47 <carter> It is lifted, and hence represented by a pointer
21:37:48 <carter> It does not claim to be a data type, and that's important for the code generator, because the code gen may enter a data value but never enters a function value.
21:38:21 <jle`> what do you mean by lifted type
21:38:36 <carter> "It's also used to instantiate un-constrained type variables after type checking. For example, length has type"
21:38:42 <carter> joelteon: not Int# or Word#
21:38:49 <carter> er jle`
21:38:55 <carter> FOo# is unlifted
21:39:00 <jle`> is that like a boxed type?
21:39:09 <carter> not quite
21:39:18 <carter> you can have unboxed things in stricted types right?
21:40:12 <jle`> er, yes
21:41:35 <carter> its not that they're unboxed... but rather that they live in registers
21:41:38 <carter> when you work on em
21:41:41 <carter> roughly
21:41:53 <jtcwang> carter, here's the error while trying to install system-fileio
21:41:54 <jtcwang> http://lpaste.net/104544
21:42:06 <carter> joelteon: you on windows?
21:42:09 <carter> jtcwang:
21:42:15 <jtcwang> yeap
21:42:18 <carter> what version of cabal and ghc
21:42:22 <jtcwang> 1.20
21:42:27 <jtcwang> ghc is 7.6.2
21:42:33 <jle`> carter: i'm going to read up on this before i can engage in a meaningful discourse
21:42:33 <carter> ummm, try 7.8
21:42:37 <jle`> also i am watching 24
21:42:41 <jle`> and it is getting intense
21:42:41 <carter> ha
21:42:52 <carter> jtcwang: i have no fucking clue how haskell + windows work
21:43:00 <carter> if you were a mac, i'm your god, windows, no clue
21:43:13 <jtcwang> jtcwang, I really wish ppl told me not to install haskell platform
21:43:14 <carter> jtcwang: i'm told that 7.8 ghc works nice on windows
21:43:23 <carter> jtcwang: people DO
21:43:34 <carter> go try 7.8
21:43:49 <carter> though this seems like a c side thing
21:43:51 <carter> email cafe
21:43:53 <jtcwang> carter, guess it's a good time to get rid of haskell platform on my computer
21:44:03 <jtcwang> I've contacted the author
21:44:10 <carter> cool
21:44:15 <carter> good ulck
21:44:21 <jtcwang> carter, the thing is though, it install fine before
21:44:27 <carter> what changed
21:44:36 <jtcwang> carter, but I'm reinstalling with profiling turned on
21:44:41 <carter> ohhhh
21:44:45 <carter> but.... hrm
21:44:46 <carter> idk
21:44:50 <carter> i can't help wrt windows
21:45:07 <jtcwang> carter, no worries. I'm switching to linux soon
21:45:08 <carter> jtcwang: solution: do profiling on another os :)
21:45:33 <carter> yay
21:45:33 <carter> ok
21:45:36 <carter> have fun
21:46:48 <jtcwang> I will. cheers
21:47:21 <altern_> How could I let interpreter know that I use type alias?
21:47:50 <altern_> For example, I use data type 'type Timestamp = Integer'
21:48:05 <altern_> but interpreter would not resolve it to Int
21:48:30 <carter> Integer!= Int :)
21:48:34 <carter> altern_: k?
21:48:43 <altern_> I mean Integer
21:48:45 <carter> oh
21:48:52 <carter> it tries to preserve names
21:49:17 <carter> so eg, some lib authors use type Foo = Baz
21:49:22 <carter> to give better error messages
21:50:36 <altern_> but when want to parse values, it does not resolve alias types: "timestamp" JSON..= JSON.Number timestamp
21:50:57 <carter> oh yeah
21:51:06 <carter> then you want newtype :)
21:51:12 <carter> newtype Timestampe = TS Integer
21:51:16 <carter> then define a new instance
21:51:17 <altern_> http://lpaste.net/104545
21:51:40 <carter> whats the error message?
21:51:51 <altern_>     Expected type: Data.Scientific.Scientific       Actual type: Timestamp
21:51:55 <carter> hah
21:51:57 <carter> well
21:52:03 <carter> lets look at the actuall type :)
21:52:10 <carter> @hackage scientific
21:52:10 <lambdabot> http://hackage.haskell.org/package/scientific
21:52:37 <carter> http://hackage.haskell.org/package/scientific-0.3.2.0/docs/src/Data-Scientific.html#Scientific
21:52:49 <carter> altern_: if you look, its clearly not an Integer :)
21:53:30 <altern_> carter: ok, I see.. this type probably is not going to work for me.
21:53:57 <carter> nah
21:54:00 <carter> you can make it work
21:54:07 <carter> but... you need to mapp between the two
21:54:18 <carter> also JSON is a terrible format :)
21:54:49 <altern_> how could I map those two types?
21:55:20 <altern_> is there more simple way to let JSON library know that my value is of type Integer?
21:55:34 <supki> altern_: "timestamp" JSON..= timestamp
22:04:36 <joelteon> so here's my problem...
22:04:46 <joelteon> I need to take a haskell module and find all the names in it that aren't defined in that module
22:05:44 <joelteon> does anyone know of an existing way to do that? I *really* don't want to myself
22:08:15 <audiodude> is the Haskell platform a command line or GUI tool?
22:09:07 <hiptobecubic> audiodude, it's a collection of libraries with fixed version numbers that are known to be useful and play nicely together, as well as some commandline tools that are commonly needed
22:09:37 <audiodude> cool, thanks…..so it’s not like some IDLE thing or some awfulness like that I gather
22:09:49 <hiptobecubic> no.
22:10:44 <archblob> joelteon, I think you could do it using the ghc-api, get a module and look for all external names
22:11:55 <joelteon> is there any GHC API documentation
22:12:43 <carter> joelteon: :)
22:12:47 <carter> lol
22:12:49 <johnw> hohoho
22:13:03 <carter> :) amiright johnw  :)
22:13:09 <johnw> yeah
22:13:17 <johnw> it's a party all around
22:13:25 <carter> if there were docs as youd hope, thatd be like a promise that the ghc api should be stable :)
22:13:46 <archblob> :-P
22:14:28 <archblob> take a look in compile/main/InteractiveUI
22:14:41 <archblob> lots of example of ghc api functions usage
22:14:52 <carter> and as archblob knows, freedom to change the ghc api is important!
22:16:03 <archblob> excuse me, it's ghc/InteractiveUI
22:26:51 <archblob> joelteon, i think something like fmap (filter Name.isExternalName) InteractiveEval.getNamesInScope, in an interactive context will work
22:27:09 <carter> archblob: yer an expert now :)
22:27:12 <carter> yay
22:27:48 <archblob> carter, :)) nah, i just spent a month looking at these modules
22:28:16 <carter> thats what makes someone an expert :)
22:28:56 <archblob> :-P
22:29:22 <carter> spend a month or
22:29:23 <carter> two years
22:29:25 <carter> on something
22:29:35 <carter> you realize  how little ANYONE knows on a topic
22:44:38 <phy1729> for  (^) <$> [1..4] <*> [1..4]  what if I want to apply to the right side first so I get [1,2,3,4,1,4,9,16,...] ?
22:45:31 <kazagistar> phy1729: parens?
22:47:00 <phy1729> I want to get [(^1),(^2),(^3),(^4)]  not  [1^),(2^),(3^),(4^)] as (^) <$> [1...4] gives
22:47:03 <bitemyapp> tnks: not as far as I know?
22:48:09 <kazagistar> phy1729: how about (flip (^)) instead of (^)
22:48:58 <phy1729> thanks kazagistar that's exactly what I wanted
22:53:52 <kazagistar> phy1729: your welcome, thanks to the lovely and horrible Forth for learning that one :D
23:06:44 * hackagebot cabal-install 1.20.0.2 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.20.0.2 (JohanTibell)
23:07:19 <carter> sweet
23:14:36 <archblob> omg there's fixity info displayed in haddock docs
23:15:19 <carter> oh yeah
23:15:25 <carter> :)
23:16:11 <archblob> I remember when they announced the new haddock, but this is the first time i've seen it :)
23:16:24 <archblob> sweet
23:17:07 <jle`> when did the new minimal instance definitions begin showing up?
23:18:13 <archblob> jle`, http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#g:4
23:18:34 <jle`> i meant, when did they start?
23:18:55 <archblob> i think 7.8
23:18:55 <jle`> like how recently did this happen, heh
23:18:59 <jle`> on the haddocks
23:19:05 <archblob> oh
23:19:33 <archblob> a couple of months ago, when the last big version came out, or maybe less
23:19:37 <jle`> oh neat
23:19:42 <jle`> that's handy :)
23:19:49 <archblob> indeed
23:21:46 * hackagebot cabal-install 1.18.0.4 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.4 (JohanTibell)
23:22:40 <archblob> does anyone know why precedence strength values are not the other way around ? with 0 beeing the strongest ?
23:23:04 <archblob> fells more natural, and it always confuses me the way they are now
23:23:20 <shachaf> I read "precedence" as "stickiness".
23:24:06 <archblob> yeah, but still nothing beats 0 :-P
23:26:52 <archblob> i guess i always associated it with distance from the thing that binds the tightest, but stickiness works with the way it is in haskell
23:36:47 * hackagebot http2 0.3.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.3.0 (KazuYamamoto)
23:45:42 <u-ou> ^sl^ls # is there something like this for ghci
