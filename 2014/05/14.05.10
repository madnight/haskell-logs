00:12:10 <toki78> Hi folks
00:12:31 <toki78> I rejoin Haskell now
00:12:50 <toki78> Is there a SAT solver in Haskell allready ?
00:13:10 <Total_1mmersion> Cale, then gsel does have its uses. Unfortunately, I wasted time debugging the problem when the documentation could have been more explicit. Thanks for clarifying it for me though.
00:13:24 <toki78> I'd like som proposal about what to program
00:13:37 <Saizan> there are bindings to SAT solvers
00:14:02 <toki78> I would like to do it in native haskell
00:15:04 <toki78> where would I publish it ?
00:15:14 <edwardk> toki78: ersatz will gather a SAT problem in a form suitable for solving, but doesn't yet have a solver
00:15:31 <edwardk> if you wrote one, you could send us a patch for it into there for instance
00:15:38 <toki78> performance does not matter -> prove of concept
00:16:16 <edwardk> toki78: a basic DPLL/CDCL solver is pretty easy to write
00:16:45 <toki78> do you know minisat ?
00:16:53 <edwardk> yes
00:16:56 <toki78> afk for 5 minutes
00:17:06 <edwardk> ersatz right now binds to external solvers
00:30:32 <toki78> back again
00:30:56 <toki78> okay, so I write a basic sat solver for ersatz now
00:32:07 <toki78> ersatz looks a bit complicated. Is there a tutorial
00:32:35 <toki78> In the past I tried to  solve the sat problem with PID controllers
00:35:06 <toki78> edwardk, I read, you are the developer. Can you help me a bit getting started with ersatz ?
00:35:48 <edwardk> Somewhat. I'm a bit scattered this week, but over on #haskell-lens there are a few other folks who also work on it, so if I'm not around, someone shoul be able to help.
00:36:13 <toki78> cool !
00:36:37 <edwardk> toki78: there are some worked examples of ersatz problms, e.g. for the MIT regex crossword, and i think a sudoku solver or something
00:39:33 <toki78> edwardk, how about porting my https://github.com/toki78/TKSatgen to ersatz ?
00:40:07 <toki78> edwardk, I better fork ersatz and extend it, right ?
00:49:06 <jtobin_> edwardk: i'm getting CPP errors when trying to cabal repl on a freshly pulled/built ad
00:49:25 <jtobin_> i see the .ghci file but can't figure out how to pass those args to the repl.. any ideas?
00:52:13 <solidus-river> <3 monad transforms for error handling
00:52:29 <solidus-river> is there a better way than that to handle errors in haskell?
00:54:29 <dmj`> solidus-river: http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
01:03:12 <Hafydd> Heheh, "hysterical raisins."
01:05:16 <dmj`> Data.IntMap destroys Data.Map
01:05:20 <solidus-river> Hafydd get out of my computer! i just read that
01:05:22 <dmj`> on lookup and insertion
01:05:33 <carminemlt> Hello everyone. I'm experimenting with monad transformers, and I'm having difficulties with this code: http://lpaste.net/103916. Please help me wrap my poor brain around that transformer :)
01:09:11 <jle`> :t lift
01:09:12 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
01:09:14 <jle`> :t tell
01:09:15 <lambdabot> MonadWriter w m => w -> m ()
01:09:36 <jle`> carminemlt: you can only "tell" values of the underlying monoid
01:09:45 <jle`> but isn't x a String, and not a [String] ?
01:09:57 <carminemlt> indeed
01:10:14 <carminemlt> x is a string
01:10:43 <jle`> yes, so you can only tell [String]
01:10:54 <jle`> because you have  WriterT [String]
01:11:06 <dmj`> carminemlt: do you understand kinds?
01:11:11 <jle`> do you know about the semantics of Writer?
01:11:19 <carminemlt> dmj:very little
01:11:31 <carminemlt> jle: just approaching monads and transformers
01:12:01 <dmj`> carminemlt: kinds are the types of types, you can learn transformers by playing connect the dots
01:12:02 <jle`> so Writer sort of keeps an underlying monoid and mappens new results onto it
01:12:25 <dmj`> carminemlt: all transformers have a similar api (at least the ones in mtl)
01:12:25 <jle`> um, there's a good LYAH section on it, and that adit tutorial is nice too
01:13:01 <dmj`> carminemlt: quiz: what is the kind of Int?
01:13:27 <carminemlt> dmj: Ok, indeed, if I replace WriterT [String] [] () with WriterT [String] String (), ghci complains about String not being of kind * -> * and I understand that it has to be a monad, hence the []. B
01:13:35 <carminemlt> dmj: it's *
01:14:01 <carminemlt> jle: Will peek at LYAH for sure. By the way, what's the "adit tutorial"?
01:14:08 <jle`> (x, a) >> (y, b) gives you (y, a <> b)
01:14:10 <jle`> for Writer
01:14:31 <dmj`> carminemlt: good, ok no cheating, what are the kinds of Maybe and Maybe Int
01:14:31 <jle`> (x, a) >> (y, b) >> (z, c) will gives you (z, a <> b <> c)
01:14:39 <jle`> where (<>) is mappend. for lists, it's (++)
01:14:51 <carminemlt> dmj: Maybe is * -> *. Maybe Int is *
01:15:15 <jle`> and "tell a" is ((), a) in that sense
01:15:34 <Wizek> Good morning, Ladies and Gentlemen.
01:15:34 <dmj`> carminemlt: what is the kind of WriterT, don't use ghci
01:15:56 <dmj`> Wizek: good morning, 3am here :P
01:15:59 <jle`> so tell [1] >> tell [2] >> tell [3] gives you ((),[1]) >> ((),[2]) >> ((),[3]), which as we know, is ((),[1] <> [2] <> [3]), which is
01:16:00 <carminemlt> dmj: Not sure
01:16:03 <jle`> > [1] <> [2] <> [3]
01:16:04 <lambdabot>  [1,2,3]
01:16:25 <carminemlt> dmj: all I know is that it requires a base monad, a wrapped monad and a result
01:16:42 <jle`> carminemlt: 2/3
01:16:44 <jle`> :)
01:16:44 <carminemlt> dmj: so it should be: * -> * -> * -> * -> *?
01:17:31 <carminemlt> jle: That's the behaviour I wanted and it is exactly what I achieve if I remove my type declaration
01:18:48 <jle`> carminemlt: so, x has to be [String]
01:19:02 <Wizek> I am learning about GHCi's :break feature. JS has a built in statement called `debugger;` which acts as a breakpoint if debugging is in progress, noop otherwise. Is there a similar statement/function for Haskell/GHCi?
01:20:40 <dmj``> :k ErrorT
01:20:41 <lambdabot> * -> (* -> *) -> * -> *
01:20:41 <carminemlt> jle: Indeed if I replace "tell x" with "tell [x]" the code compiles but I get a return of ((),[String])
01:21:04 <carminemlt> jle: which is not what I intended
01:24:02 <solidus-river> hmm, i have a function thats type is f a b and a list of [a] and i want to apply each element in the list to the function but the argument order is wrong to use fmap
01:25:08 <toki78> okay bye folks
01:25:09 <toki78> !
01:26:08 <solidus-river> carminemlt: you figure it out? you just need ot change the type signature of yoru function, your telling it exlicitly that your going to tell [x] but you want to tell x, so tell it explicitly your going to do that :)
01:27:16 <carminemlt> solidus-ri: I got to the same conclusion. The point is, I don't want a result of ((),[String]) but a ((),String) which I obtain with the same code if i remove my type signature and let the compiler infer it.
01:27:37 <solidus-river> carminemlt: right, because the type your telling it is more constrictive
01:28:54 <carminemlt> solidus-ri: Ok, then what type am I supposed to use in order to achieve my goal?
01:29:00 <solidus-river> http://lpaste.net/103916
01:29:09 <carminemlt> solidus-ri: will look
01:29:53 <jle`> carminemlt: Writer w a is actually just a type synonym for (a, w)
01:30:07 <jle`> so your ((), [String]) is really Writer [String] ()
01:30:14 <jle`> (not a type synonym, but a newtype wrapper)
01:30:23 <carminemlt> jle and solidus-ri: thanks, I'm an idiot.
01:30:25 <jle`> you can't have a Writer [String] a be (a, String)
01:30:32 <jle`> because Writer w a is literally just a wrapped (a,w)
01:30:52 <jle`> sometimes i think these newtype wrappers do more harm than good :/
01:31:04 <jle`> or well, the good they do is that we can actually write monad instances for them
01:31:12 <jle`> but they definite detract from understanding
01:31:52 <carminemlt> jle: maybe you're right. Haskell definitely has quite a steep learning curve for many of us
01:32:00 <jle`> whenever you see "State s a" you should really see (s -> (a, s))
01:32:09 <jle`> and then State is suddenly no longer a mystery
01:32:18 <jle`> StateT s m a is really s -> m (a, s)
01:32:24 <jle`> @unmtl StateT s m a
01:32:25 <lambdabot> s -> m (a, s)
01:32:25 <carminemlt> jle: I almost bled to death when encountered State for the first time ... :)
01:32:49 <solidus-river> i'm still confused about my function ordering problem, i want to mape but i cant because the function ois of type f -> b -> a instead of f -> a -> b
01:33:08 <carminemlt> solidus-ri: couldn't a flip solve the issue?
01:33:12 <solidus-river> should i just write a function that expects the opposite order of params?
01:33:26 <dmj``> solidus-river: if he curried the first parameter, then flipped possibly
01:33:37 <solidus-river> carminemlt: aye, is there a easy way to do that or is it just write another function that flips them
01:33:54 <dmj``> solidus-river: what does you code look like
01:33:55 <jle`> carminemlt: it's actaully not that complicated, but it's hard to see through all of the syntax and noise and be able to achieve the zen
01:33:56 <solidus-river> my instinct is to define a new function that reverses the parameters i can curry to map
01:34:11 <Wizek> http://stackoverflow.com/questions/23578836/is-there-a-debugger-statement-for-haskell-ghci-something-else
01:34:19 <solidus-river> but defining a new function just for a flip / map seems like a lot
01:34:35 <carminemlt> flip :: (a -> b -> c) -> b -> a -> c
01:35:03 <carminemlt> solidus-river: map . flip f
01:35:17 <carminemlt> solidus-river: should work, shouldn't it?
01:36:04 <solidus-river> yes it should :), didn't know about flip
01:36:30 <carminemlt> solidus-river: :)
01:36:39 <jle`> hlint always bugs me about using flip
01:36:42 <dmj``> carminemlt: are you comfortable stacking monads yet?
01:36:59 <carminemlt> dmj: not at all. Just learning
01:37:01 <jle`> it says that i should always use (`f` x) instead of (flip f x)
01:37:05 * jle` shrugs
01:37:11 <jle`> it's peculiar in a lot of ways
01:37:56 <dmj``> :k StateT
01:37:57 <lambdabot> * -> (* -> *) -> * -> *
01:37:57 <carminemlt> dmj: I am looping within books and tutorials, trying to grasp haskell
01:37:59 <dmj``> :k ErrorT
01:38:00 <lambdabot> * -> (* -> *) -> * -> *
01:38:03 <dmj``> :k WriterT
01:38:04 <lambdabot> * -> (* -> *) -> * -> *
01:38:07 <dmj``> see a pattern?
01:38:18 <carminemlt> dmj``: yes
01:38:38 <jle`> :t MonadTrans
01:38:39 <lambdabot> Not in scope: data constructor ‘MonadTrans’
01:38:56 <jle`> shame
01:39:03 <dmj``> carminemlt: the second parameter of the kind signature is a type constructor
01:39:30 <dmj``> any type w/ a kind of * is a concrete type, o/w it's a type constructor
01:39:44 <dmj``> carminemlt: still here?
01:39:49 <carminemlt> dmj``: yes, I am
01:40:13 <dmj``> ok
01:40:22 <dmj``> :k WriterT Int
01:40:23 <lambdabot> (* -> *) -> * -> *
01:40:46 <dmj``> :k WriterT Int Maybe
01:40:47 <lambdabot> * -> *
01:41:01 <solidus-river> carminemlt: for me learn you a haskell and then diving in has been working out ok
01:41:04 <dmj``> carminemlt: does that make sense? Maybe :: * -> * filled it
01:41:05 <carminemlt> dmj``: now it just requires a concrete type
01:41:21 <dmj``> ok here's the stacking magic
01:41:37 <dmj``> :k WriterT Int (WriterT Int (WriterT Int Maybe))
01:41:38 <lambdabot> * -> *
01:41:50 <dmj``> :k WriterT Int (WriterT Int (WriterT Int (Writer Int Maybe)))
01:41:50 <lambdabot>     Expecting one more argument to ‘Maybe’
01:41:51 <lambdabot>     The second argument of ‘Writer’ should have kind ‘*’,
01:41:51 <lambdabot>       but ‘Maybe’ has kind ‘* -> *’
01:42:09 <dmj``> > WriterT Int (WriterT Int (WriterT Int (WriterT Int Maybe)))
01:42:10 <lambdabot>  Not in scope: data constructor ‘Int’
01:42:10 <lambdabot>  Perhaps you meant one of these:
01:42:10 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
01:42:10 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)Not in scope: d...
01:42:10 <lambdabot>  Perhaps you meant one of these:
01:42:15 * hackagebot quandl-api 0.1.0.0 - Quandl.com API library  http://hackage.haskell.org/package/quandl-api-0.1.0.0 (PeterVanDenBrand)
01:42:27 <dmj``> sorry I'm bad w/ lambdabot
01:42:33 <carminemlt> solidus-river: I went through LYAH then Haskell the craft, and now Beginning Haskell. Still I have difficulties when dealing with complex and/or convoluted code
01:42:40 <solidus-river> :k WriterT Int (WriterT Int (WriterT Int (Writer Int Maybe Int)))
01:42:41 <lambdabot>     ‘Writer’ is applied to too many type arguments
01:42:41 <lambdabot>     In a type in a GHCi command:
01:42:41 <lambdabot>       WriterT Int (WriterT Int (WriterT Int (Writer Int Maybe Int)))
01:42:44 <carminemlt> dmj``: No problems. You've been very clear
01:42:49 <solidus-river> :k WriterT Int (WriterT Int (WriterT Int (Writer Int (Maybe Int))))
01:42:50 <lambdabot>     The second argument of ‘WriterT’ should have kind ‘* -> *’,
01:42:50 <lambdabot>       but ‘Writer Int (Maybe Int)’ has kind ‘*’
01:42:50 <lambdabot>     In a type in a GHCi command:
01:42:50 <dmj``> carminemlt: do you see how you can next arbitraty monad stacks?
01:42:58 <dmj``> I put a Writer, instead of WriterT
01:43:01 <solidus-river> damn, those were my 2 wiffs
01:43:08 <dmj``> :k WriterT Int
01:43:09 <lambdabot> (* -> *) -> * -> *
01:43:13 <dmj``> :k WriterT Int Maybe
01:43:14 <lambdabot> * -> *
01:43:22 <dmj``> :k WriterT Int (WriterT Int Maybe)
01:43:23 <lambdabot> * -> *
01:43:33 <dmj``> :k WriterT Int (WriterT Int (WriterT Int Maybe))
01:43:34 <lambdabot> * -> *
01:43:36 <dmj``> Now!!!!
01:43:45 <dmj``> instead of just WriterT let's mix it up
01:43:47 <carminemlt> dmj``: nesting at its finest form :)
01:44:17 <dmj``> :k ErrorT String (StateT Int IO) ()
01:44:18 <lambdabot> *
01:44:30 <dmj``> :k WriterT String (ReaderT Int Maybe) ()
01:44:31 <lambdabot> *
01:44:36 <carminemlt> dmj``: of course that implies a lot of lifting to pick values from inner computations and bring them to the required levels
01:45:34 <dmj``> carminemlt: no lifting needed
01:45:58 <dmj``> unless you are using a two of the same kind of monads
01:46:05 <dmj``> the lifting is implicit
01:46:19 <dmj``> if you use StateT Int (StateT String IO) () then yes you'll need to explicitly lift
01:46:25 <dmj``> threading two states
01:46:50 <mmmm_> If you nest states like that, is it not better to use one stateT with a record?
01:47:14 <carminemlt> dmj``: then [String] -> WriterT String [] () shouldn't need a lift too?
01:47:50 <dmj``> carminemlt: I don't think so, someone correct me if I'm wrong
01:48:06 <dmj``> mmmm_: yea that's possible
01:48:08 <jtobin> has anyone used cabal repl w/a library that uses CPP?  can't get it to work for the life of me.
01:48:15 <carminemlt> dmj``: ghci complains if I remove the lift from my code
01:48:25 <dmj``> ghci always complains
01:48:29 <carminemlt> dmj``: :))
01:48:49 <mmmm_> You don't need the lift for the standard functions like tell, get.. etc
01:48:59 <carminemlt> mmmm_: ah, ok!
01:49:12 <carminemlt> mmmm_: i had to use lift to extract values from []
01:49:22 <carminemlt> mmmm_: and bring them to Writer's level
01:49:56 <mmmm_> see here in mtl https://hackage.haskell.org/package/mtl-2.0.1.0/docs/src/Control-Monad-Writer-Class.html#MonadWriter
01:50:10 <mmmm_> The instances are defined for you
01:51:56 <dmj``> the typeclass abstracts out the lifting I believe
01:52:23 <dmj``> exactly, the instance includes lifting
01:52:25 <dmj``>  tell   = lift . tell
01:53:56 <carminemlt> dmj``: ok, but I don't see any instance of MonadWriter w for [], so that means lift is still required, right?
01:54:46 <halvorg> anyone got an example using shaders with the OpenGL package?
01:55:00 <halvorg> Only example I could find is from 2011 and doesn't compile
01:55:27 <jtobin> edwardk: just in case it's of any use, i had to replace the contents of .ghci in ad with the simpler ':set -optP-include -optPdist/build/autogen/cabal_macros.h' in order to get a repl running
01:56:25 <solidus-river> can you use where within a do block?
01:56:38 <solidus-river> or is that considered bad? most places i see people using let bindings
01:56:39 <ivanm> no
01:56:47 <ivanm> where is top-level only
01:57:16 <dmj``> carminemlt: what specifically are you trying to do
01:58:08 <Saizan> solidus-river: do-notation only has let bindings, "where" in general is something you attach to declarations
01:58:08 <carminemlt> dmj``: nothing fancy. Just wanted to fetch strings from a list and put them in a writer
01:58:39 <carminemlt> dmj``: my error was I wrote WriterT [String] ... in place of WriterT String ...
01:58:50 <Saizan> solidus-river: not necessarly top-level though, e.g. you can nest them
02:01:30 <ivanm> Saizan: oh, right, I meant top-level in the "you can't put it inside a definition" sense
02:03:48 <hexagoxel> ivanm: i don't think where is top-level only
02:06:37 <solidus-river> haskell, where 6 lines of code is an hour of work :P
02:07:42 <hexagoxel> and those 6 lines are just the type signature, no implemenation
02:08:04 <hexagoxel> > (let x = y where y = 3 in x)
02:08:05 <lambdabot>  3
02:08:44 <hexagoxel> ivanm: ^
02:13:31 <halvorg> Any way to resolve package import ambiguity=
02:13:31 <halvorg> ?
02:14:32 <halvorg> Ambiguous module name "pckg"; "it was found in multiple packages: pckg1-1.0.0 pckg2-1.2.3"
02:15:06 <halvorg> resolve when importing, not fix/delete any of the packages.
02:18:53 <simon____> if I upgrade GHC from 7.6.3 to 7.8.2, it seems that I need to re-install all my cabal packages?
02:20:33 <aristid> simon____: yes.
02:21:15 <hexagoxel> halvorg: ghc -ignore-package?
02:22:20 * hackagebot language-lua 0.4.4 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.4 (OmerAgacan)
02:23:25 <supki> halvorg: with -XPackageImports you can qualify module names by the package name
02:24:58 <solidus-river> oy
02:25:01 <solidus-river> http://lpaste.net/103920
02:25:12 <solidus-river> overloadedStrings is giving me a headache with types
02:25:51 <solidus-river> https://hackage.haskell.org/package/yaml-config-0.2.2/docs/Data-Yaml-Config.html <- hackage page for the function thats raising the error
02:33:11 <Merovius> Hi
02:34:12 <Merovius> I'm just starting out with haskell and this gave me a headscratch: http://p.nnev.de/4391 -- can someone explain to me as a beginner, why this doesn't give "Num b => [b] -> [b] ?
02:34:28 <SrPx> newbie question but, "Could not find module ‘JavaScript.JQuery’" <- how do I know the name of the module I should install with cabal? It is not just JavaScript.JQuery
02:34:39 <Merovius> (and I know that I should just put a signature, if I want that, but I'm interested in *why* in this case ;) )
02:35:34 <dmj``> @typ map (subtract 10)
02:35:34 <lambdabot> Num b => [b] -> [b]
02:35:35 <aristid> Merovius: it's due to the monomorphism restriction. it has something to do with the performance of compile programs. you can turn it off with :set -XNoMonomorphismRestriction
02:36:04 <dmj``> @typ map (`subtract` 10)
02:36:05 <lambdabot> Num b => [b] -> [b]
02:36:30 <leggo> isn't this just ghci anomaly? if you typed `foo = map (10 -)' in the source, the type would still be `Num a => [a] -> [a]', no?
02:36:47 <solidus-river> i am completely los ton this error
02:36:56 <solidus-river> i think it has something to do with me enabling OverloadedStrings
02:36:56 <Merovius> aristid: thanks, that should give me enough to google my way through
02:37:16 <solidus-river> But i cant give a type declaration to my values to help
02:37:20 <aristid> Merovius: every declaration of the form foo = bar without any arguments and without type signature gets a non-polymorphic type
02:37:25 <leggo> no I was wrong, it is still [Integer] -> [Integer]
02:37:40 <aristid> Merovius: basically the reason is that if you do pi = 3.141, you don't want it to be slow:)
02:38:10 <FreeFull> leggo: On the other hand,  foo xs = map (10 -) xs   will be polymorphic
02:38:22 <leggo> FreeFull, hmm
02:38:40 <aristid> everybody loves the monomorphism restriction
02:38:43 <FreeFull> I would recommend just disabling the monomorphism restriction though
02:38:43 <Merovius> aristid: makes some sort of sense
02:38:50 <Merovius> reading http://www.haskell.org/haskellwiki/Monomorphism_restriction now =D
02:38:53 <aristid> certainly in ghci
02:39:17 <aristid> in regular haskell you're supposed to put type signatures on your top-level things anyways
02:39:28 <aristid> unless you're oleg
02:40:02 <klrr_> anyone got experience with optparse-applicative? i have a chain of parsers using its alternative instance but according to this issue https://github.com/pcapriotti/optparse-applicative/issues/53 there is a way to get a default value for some of the parsers if they dont occure, without this work around it will stack overflow, but i dont understand how to apply this workaround to my particular case, since i dont have a "many $ arguments blablalb" but a whole chai
02:44:47 <merijn> klrr_: lpaste your code?
02:45:16 <solidus-river> oh i'm using sequence wrong
02:45:34 <solidus-river> i need something to take [IO a] -> IO [a]
02:45:50 <merijn> :t sequence :: [IO a] -> IO [a]
02:45:51 <lambdabot> [IO a] -> IO [a]
02:46:03 <solidus-river> oh, then i'm using it right
02:46:06 <solidus-river> well.. balls
02:46:15 <merijn> solidus-river: What's going wrong
02:46:35 <solidus-river> merijn: http://lpaste.net/103920
02:47:18 <merijn> Merovius: The problem with the DMR (Dreaded Monomorphism Restriction) is that enabling it produces really obvious failures (i.e. type errors about functios not being polymorphic enough) whereas disabling it produces very subtle and hard to find space leaks in some cases. So the standard opted for the former
02:47:41 <solidus-river> merijn: it doesnt like sequence $ fmap (`DYC.lookup` envConfig) environmentList
02:47:51 <merijn> Merovius: But the restriction doesn't apply to definitions that have a type signature anyway, so in practice it's not a very big problem
02:49:53 <solidus-river> merijn: i think its having trouble determining the type of environmentList which should be [DYC.Key]
02:49:57 <merijn> solidus-river: I suspect your types aren't quite right? But it's hard to tell since I don't know the types of the yaml functions
02:50:14 <solidus-river> https://hackage.haskell.org/package/yaml-config-0.2.2/docs/Data-Yaml-Config.html
02:50:27 <solidus-river> yeagh i'm trying to figure that out
02:50:29 <merijn> solidus-river: My usual debug approach is to start adding type signatures I think things should have until GHC complains :)
02:50:49 <solidus-river> merijn: it complained on my first attempt :P
02:50:54 <solidus-river> i tried to change the let to
02:51:13 <solidus-river> let environmentList :: [DYC.Key] = DYC.keys envConfig
02:51:25 <solidus-river> and it complained about using a scoped Type in a pattern match
02:51:47 <merijn> solidus-river: Well, let's start with a simple change
02:51:57 <merijn> "sequence (map f x)" == mapM f x
02:51:59 <merijn> :t mapM
02:52:00 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:54:00 <merijn> solidus-river: Oh, actually it's much simpler
02:54:34 <merijn> solidus-river: The first argument of loadEnvironment is a Config, right?
02:54:55 <merijn> Which means "environmentConfs :: [DYC.Config]"
02:55:44 <solidus-river> aye
02:55:48 <merijn> I should read the error better :p lookup returns a value of type "FromJSON a => m a", the error is saying that DYC.Config is not an instance of FromJSON
02:55:58 <merijn> So lookup can't return DYC.Config
02:56:13 <solidus-river> AAAAARG
02:56:17 <solidus-river> lookup should be subconfig
02:56:18 <merijn> solidus-river: That's what line 58/59 say :)
02:56:42 <merijn> solidus-river: The rest of the error is just explaining why GHC inferred that DYC.Config needs to be a FromJSON instance
02:57:09 <kqr> what's the recommended way to download a page via http in haskell? (similar to urlopen() in python)
02:57:24 <merijn> kqr: I was rather happy with the simplicity of http-conduit
02:57:46 <merijn> And as a bonus html-conduit plays nicely with it and was fairly easy to scrape pages with
02:58:26 <kqr> simpleHttp from http-conduit says it should be avoided in production though
02:58:39 <solidus-river> merijn: someday i'll learn to pay closer attention to return types :X for some reason i glossed over the fromAESOn stuff
02:58:40 <kqr> otherwise, i've been liking http-conduit as well
02:59:09 <solidus-river> is there a way to search for a function by a type def?
02:59:32 <merijn> kqr: BEcause it doesn't help you with fancy error handling, etc.
02:59:35 <merijn> solidus-river: Hoogle
02:59:46 <merijn> @hoogle (a -> m b) -> [a] -> m [b]
02:59:47 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:59:47 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:59:47 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
02:59:54 <merijn> @where hoogle
02:59:55 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
02:59:55 <kqr> merijn, ah okay
03:00:06 <merijn> kqr: So it depends on what you wanna do
03:00:21 <merijn> kqr: If you wanna scrape some sites from your desktop for fun, I wouldn't worry about that
03:02:08 <kqr> yeah that's it
03:03:12 <merijn> kqr: If you wanna implement a browser or google webscraper you might want to grab for more sophisticated tools than simpleHttp ;)
03:03:27 <kqr> haha yeah, you're right
03:04:00 <skypers> hm
03:04:17 <skypers> MonadBase IO MyIOStuff
03:04:23 <skypers> the instance for that is quite simple, right?
03:04:35 <skypers> something like liftIO?
03:04:59 <skypers> if MyIOStuff is in MonadIO
03:24:19 <exicer_> Is there a way to give a do block a type signature? In the same way that you might do let a = "test" :: Text
03:25:19 <leggo> > do print 10; print 20 :: IO ()
03:25:21 <lambdabot>  <IO ()>
03:25:43 <exicer_> Ah, that actually makes sense.. I was trying to put it at the top
03:25:47 <exicer_> Thanks!
03:26:21 <leggo> I am not quite sure if :: IO () refers to just print 20 or the whole do block. parens will help if it is the former
03:29:42 <Guest33014> are any of the higher level haskell GUI libraries usable? like reactive-banana and similar
03:30:12 <Guest33014> or should i stick with gtk?
03:33:01 <ivanm> Guest33014: I think threepenny-gui is meant to be, but it runs in the browser IIRC
03:33:50 <linduxed> hey guys
03:33:54 <kqr> what's the state of random number generation in haskell? i've heard complaints about system.random, but that's the only generator i know of that lets me specify a range to generate within
03:34:07 <linduxed> i was wondering, if i do a cabal sandbox, i've got some binaries residing in .cabal-sandbox/bin
03:34:26 <linduxed> do i add that path to my path, or does cabal have something like ruby's "bundle exec"?
03:35:26 <simon____> linduxed, there's "cabal run", but I don't know the answer to your question.
03:35:41 <linduxed> simon____: i'll try and see if that works!
03:36:08 <klrr_> hmm, i dont know if there is, but if you dont wanna mess around with PATh you can always do ".cabals-sandbox/bin/<bin> --args"
03:36:26 <pavonia> kqr: What kind of complaints?
03:36:33 <simon____> linduxed, that might work if your project is itself a cabal project that you installed in your sandbox (and not just incidentally lying there)
03:37:04 <kqr> pavonia, slow, unsafe, the class has bad support for alternative implementations
03:37:23 <linduxed> simon____: right, it is
03:37:29 <linduxed> hmmm
03:37:37 <linduxed> unfortunately i just ran into this: https://gist.github.com/linduxed/02e6b9f73945e9b6a83b
03:37:46 <linduxed> when running cabal install --only-dependencies
03:38:45 <pavonia> kqr: I've never heard of these, I think it's fine for simple things. For more complex random number generator, there's the random-fu package
03:39:26 <numberten> is there a clean way to wrap a common type like Maybe String with semantically clear value constructors, without declaring an equivalent datatype?
03:40:36 <kqr> numberten, not that i know of, no
03:40:43 <kqr> numberten, why do you not want to declare a data type?
03:41:04 <numberten> would just prefer not to lose predefined function on Maybe
03:41:07 <numberten> like fromJust and such
03:41:20 <numberten> it's not a big deal, just figured I'd ask and see if there was something I was missing
03:42:49 <pavonia> You could wrap the whole Maybe into a newtype
03:43:17 <kqr> numberten, there are a few more general things that deal with failure, such as Alternative
03:43:26 <kqr> numberten, if those are enough, you don't need fromJust
03:45:08 <numberten> yeah I think that would be overkill in this use case
03:45:17 <numberten> but thanks, i hadn't heard of Alternative
03:46:02 <startling> :t maybe empty pure
03:46:03 <lambdabot> Alternative f => Maybe a -> f a
03:46:13 <startling> numberten: ^ or you could use something like that
03:46:23 <startling> I feel like it has a name but I can't remember it.
03:46:43 <startling> numberten: (fwiw fromJust is a bad idea)
03:49:51 <hexagoxel> linduxed: i use "cabal install --bindir=$MYDIRTHATISINPATH"
03:51:04 <solidus-river> can you use gaurd syntax within a do block?
03:51:23 <dmj``> what is guard syntax
03:51:29 <numberten> startling: alright thanks
03:51:31 <dmj``> oh
03:52:29 <dmj``> solidus-river: let g | g > 4 = 0, something like that, or see multiway if lang ext
03:53:58 <dmj``> > case 4 > 5 of { x | x == True -> 99; otherwise -> 88 }
03:53:59 <lambdabot>  88
03:54:14 <pavonia> >  let g | g > 4 = 0 in g
03:54:18 <lambdabot>  mueval-core: Time limit exceeded
03:54:25 <pavonia> >  let g | g > 4 = 5 in g
03:54:29 <lambdabot>  mueval-core: Time limit exceeded
03:56:58 <happy0> :o
03:58:10 <linduxed> hexagoxel: ok, thx
03:58:35 <deni> ok so I have this: r :: IO (Response Data.ByteString.Lazy.Internal.ByteString)
03:58:48 <deni> and i want to use a lens on it like so: r ^. responseBody
03:59:16 <deni> but it's complaining about Response a being wrapped in an IO monad
03:59:52 <deni> any ideas?
04:00:04 <ivanm> if I have multiple ghcs installed, how does Cabal choose which one to use? /usr/bin/ghc points to 7.6.2, but "runhaskell Setup configure" seems to want to use 7.8.2 :s
04:00:19 <deni> (note: i'm using wreq to make the http calls)
04:02:52 <Saizan> ivanm: it picks the ghc/ghc-pkg on the $PATH
04:03:07 <Saizan> ivanm: you can specify one using -w btw
04:03:19 <dmj``> deni: do { resp <- r; print (r ^. responseBody) }
04:03:37 <dmj``> do { resp <- r; print (resp ^. responseBody) } ***
04:04:10 <ivanm> Saizan: well, it's still picking 7.8.2 despite both ghc and ghc-pkg pointing to 7.6.2
04:04:27 <ivanm> (and in this case it's my package manager doing it, so I can't just add -w)
04:04:39 * ivanm checks how said package manager does it to make sure it isn't doing something stupid
04:05:33 <ivanm> bah, nvm, seems the package manager is choosing the highest available GHC for some reason :s
04:06:18 <deni> dmj``: how is printing it going to help?
04:07:09 <deni> I'm trying to make the http call in a do block. return a response wrapped in an IO, can i use that response later outside of a do block?
04:07:33 * hackagebot Etage 0.1.12 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.12 (MitarMilutinovic)
04:07:35 <spot35> hi all, which room is for web development?
04:08:33 <WraithM> j #happstack
04:08:45 <deni> i'm missing something very fundamental here, i know :/
04:09:20 <ivanm> deni: if this is for lens, maybe try #haskell-lens ?
04:09:40 <deni> it's not that specific to lens really
04:09:53 <WraithM> spot35: So, there are 3 major webframeworks in Haskell. #snapframework for Snap, #happs for happstack, and #yesod for Yesod.
04:11:54 <spot35> hmm, I'm just looking at basic CSS now Wraith
04:11:55 <hexagoxel> deni: you cannot get the a out of IO a, but you can use stuff like liftM to apply pure computations to the contained value
04:12:28 <spot35> I'm trying to handcode a document (cv)
04:12:34 * hackagebot Etage-Graph 0.1.8 - Data-flow based graph algorithms  http://hackage.haskell.org/package/Etage-Graph-0.1.8 (MitarMilutinovic)
04:13:52 <deni> hexagoxel: ok i'm familiar with lift/bind but for some reason that doesn't work with lenses....or I'm doing something horribly wrong
04:14:09 <deni> hexagoxel: i was trying to use >>= i mean
04:18:44 <hexagoxel> deni: i think you need to be a bit more specific about what you want/what the exact error is
04:19:48 <Shockk> I'm having some trouble with calling Haskell code from C code and wondered if anyone could help me with it,
04:20:11 <hpc> can you paste your code?
04:20:25 <Shockk> one moment
04:20:32 <hpc> @hpaste
04:20:32 <lambdabot> Haskell pastebin: http://lpaste.net/
04:20:35 <deni> hexagoxel: http://pastebin.com/2sFigBpA
04:22:26 <hexagoxel> deni: so what about "liftM (^. responseBody) r"
04:23:55 <Shockk> ah, the problem I'm having isn't with the haskell code itself - specifically it's with hs_exit when the program exits
04:24:00 <Shockk> https://gist.github.com/shockkolate/49a4909793d06500fc32
04:26:06 <deni> hexagoxel: ok that works very well indeed. thank you
04:27:19 <Shockk> the program segfaults on exit, and it doesn't seem to have any helpful indications of why it does, in the backtrace
04:27:29 <Shockk> https://gist.github.com/shockkolate/a5c105536fb213972ff1
04:27:30 <hexagoxel> deni: it is equivalent to do { x <- r; return $ x^.responseBody }
04:27:45 <hexagoxel> dmj pointed in that direction (the print was just an example)
04:27:52 <Shockk> actually I think I just figured out why it happens, so I might not need help
04:28:25 <Walther> Shockk: the magical "thinking out loud" -solution :)
04:28:32 <Shockk> exactly
04:29:34 <deni> hexagoxel: ok i did not realize that.
04:29:39 <deni> hexagoxel: dmj: tnx
04:34:12 <ivanm> Walther: AKA rubber duck debugging?
04:34:43 <Walther> ivanm: Quack.
04:34:58 <Shockk> okay I have one more question -- is it safe to hs_init and hs_exit in a program, but call haskell code from a dynamically-linked library?
04:35:09 <Shockk> (the library being linked at runtime to the program)
04:39:15 <kqr> what's the best way to write the function (a, a) -> (a -> m b) -> m (b, b) ?
04:40:15 <supki> :t both
04:40:16 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
04:40:42 <kqr> that's fantastic
04:40:56 <kqr> i actually searched hoogle for "both" but didn't get any relevant hits
04:41:21 <kqr> i see now that hayoo did better with that search
04:51:25 <benneh> I'm trying to install SDL with cabal, but get the following error: Graphics/UI/SDL/Events.hsc:56:23: Module ‘Data.Typeable’ does not export ‘Typeable(typeOf)’
04:52:23 <awestroke> benneh: ghc version?
04:53:07 <benneh> awestroke: 7.8.2
04:56:38 <awestroke> benneh: ghc-pkg check
04:57:19 <benneh> awestroke: there's no output
04:58:12 <deni> how come i do an import Data.ByteString.Lazy but when I try and use it in a type signature the compiler complains the Data.ByteString.Lazy is not in scope? (sorry for the noob questions :) )
05:00:01 <deni> bah nvm...figure it out. importing lazy as qualified now and the constructor is actually L.ByteString
05:00:07 <awestroke> benneh: ok good, try ghc-pkg list base
05:00:33 <awestroke> which version is installed
05:00:51 <benneh> awestroke: base-4.7.0.0
05:02:33 <awestroke> benneh: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html see, the old version has "typeOf", but this new verison doesn't: http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Typeable.html
05:03:14 <awestroke> the problem is that the SDL package does not know that base-4.7.0.0 breaks the code, so the cabal install thinks all dependencies are in order
05:03:37 <benneh> so I need to downgrade base? :/
05:04:06 <awestroke> I don't know the best way to solve this, but I'd make a hsenv or cabal sandbox and install base-4.6.x.x there if possible
05:04:22 <awestroke> I think base comes with ghc
05:04:25 <awestroke> though
05:05:24 <Freundlich> I made the following patch which works for both ghc-7.6 and 7.8: https://github.com/freundlich/freundlich-gentoo/blob/master/dev-haskell/sdl/files/sdl-0.6.5-ghc7.8.patch
05:05:40 <awestroke> benneh: or use that ^
05:06:08 <benneh> Freundlich: thanks a lot :)
05:28:26 <linduxed> so guys, if i use Data.Random.Extras.choice [1,2,3], it gives me back 1, 2 or 3, inside an RVar monad
05:28:34 <linduxed> i'd like to take it out from there
05:28:40 <linduxed> how would i acomplish that?
05:39:50 <joe_k> the rest of your program will depend on that output thus entering that monad, no?
05:50:34 <sritchie> bitemyapp: I see you're permanently over here, now :)
05:52:59 <awestroke> linduxed: http://hackage.haskell.org/package/random-fu-0.1.0.0/docs/Data-Random-RVar.html#v:runRVar
05:55:54 <awestroke> linduxed: I'd use this as a RandomSource (it gives back your result in IO though): http://hackage.haskell.org/package/random-fu-0.1.0.0/docs/Data-Random-Source-DevRandom.html#t:DevRandom
05:55:57 <linduxed> awestroke: found it, thx
06:04:05 <ktosiek> hmm, I have corosync 2.3.0 at 100% CPU utilization after other node of 2 node cluster disappeared (I can ping the broken node, but it seems no other connections work)
06:05:03 <Athas> Does anyone have experience writing compilers using a De Bruijn (or similar) name representation?
06:05:19 <ktosiek> argh, wrong channel
06:06:25 <BlankVerse> when I enable profiling and do a cabal install --reinstall, it does not work since it requires even the transitively dependent packages to have been installed with profiling enabled
06:07:08 <BlankVerse> I want to profile my benchmarks using cabal bench, how to do it without reinstalling everything?
06:08:06 <awestroke> BlankVerse: did you get haskell-platform-prof before trying the cabal install --reinstall ?
06:08:20 <ajf> So, I want to represent a tiled map for a game. Should I use a list of lists, or an array?
06:08:28 <BlankVerse> no, I am using cabal sandboxes
06:08:31 <BlankVerse> awestroke: ^
06:08:59 <awestroke> BlankVerse: I have no experience with cabal sandboxes, sorry
06:09:08 <Athas> ajf: two-dimensional array.
06:09:15 <ajf> ok
06:09:33 <Athas> A list of lists is not only slow to access, but also not necessarily regular.
06:09:51 <ajf> Yeah
06:09:58 <Athas> Alternatively: a hashmap with tuples of integers as the key, which would give you a more efficient sparse representation, as well as more efficient updates.
06:09:59 <ajf> and using tuples is impractical
06:10:07 <BlankVerse> awestroke: ok, but it should not matter if its inside a sandbox or outside
06:10:16 <ajf> Athas: In my case, I don’t need sparse representation
06:10:28 <ajf> The map will always be of some fixed size with every tile filled
06:10:30 <Athas> The biggest problem with the array solution is that it will be expensive to update.  There probably is some more advanced implementation that can deal with that.
06:10:32 <ajf> For the base map, anyway
06:10:54 <awestroke> BlankVerse: does cabal install packages such as "base" in the cabal sandbox? if it only installs packages not installed as system packages, you can try getting haskell-platform-prof from your OS package manager
06:13:02 <awestroke> assuming your haskell install is based on haskell-platform
06:13:04 <merijn> awestroke: I would hope it doesn't install the "base" package...
06:13:10 <merijn> awestroke: base is wired into GHC
06:13:25 <awestroke> merijn: ah
06:14:45 <merijn> BlankVerse: For future reference, I recommend adding both "library-profiling: True" and "documentation: True" to ~/.cabal/config (I don't know why these are not default, I think that's a bug with the default config)
06:16:27 <awestroke> merijn: why documentation: true ?
06:19:11 <merijn> awestroke: Builds and installs local haddock documentation for everything
06:19:21 <awestroke> merijn: how do I use that documentation?
06:19:45 <merijn> awestroke: Should be a doc library in either .ghc or .cabal which has an index.html file
06:19:58 <merijn> It just contains a list of all hierarchical modules of installed packages
06:20:23 <merijn> And you can click to the haddocks from there
06:23:30 <ajf> Is using data as a glorified enum a good idea?
06:23:32 <awestroke> any way to reinstall all packages with profiling and documentation?
06:23:56 <ajf> like
06:24:01 <ajf> I want to represent map tiles
06:24:20 <ajf> should I do data MapTile = Grass | River | Mountain | Beach
06:24:21 <ajf> ?
06:24:35 <awestroke> ajf: that looks good to me
06:24:39 <ajf> OK
06:24:41 <tremon> probably add deriving (Enum, Eq)
06:24:42 <BlankVerse> If I just want to profile an executable and don't need to get profile info of its dependent libraries, is it possible to not have to reinstall everything?
06:24:54 <ajf> tremon: Oh, right, good idea
06:25:31 <merijn> BlankVerse: You need profiling info of all dependent libraries to profile an executable
06:25:34 <ajf> I’m not sure I want Enum, though. Each is different, nothing is a predecessor or successor
06:25:48 <merijn> ajf: You may want Show/Read, though :)
06:25:54 <ajf> right
06:25:54 <merijn> Else GHC can't print them
06:25:58 <merijn> err, ghci
06:26:17 <merijn> ajf: But having enums like that is encouraged, yeah
06:26:27 <BlankVerse> merijn: why can't the profiling info for libraries be just blackholes i.e we don't get the detailed stats inside libraries?
06:26:44 <merijn> ajf: What would you use as alternative if not an enum?
06:26:50 <merijn> BlankVerse: GHC does cross library inlining
06:26:53 <tremon> does Enum already imply ordering? I intentionally left out deriving Ord
06:27:12 <ajf> merijn: I have no idea. If I was writing this in something like C#, I’d use its enums
06:27:15 <merijn> BlankVerse: There is no real separation between "libraries" and "executable" for profiling
06:27:49 * hackagebot standalone-haddock 1.1.4.2 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.4.2 (RomanCheplyaka)
06:27:50 <merijn> BlankVerse: Imagine a non-trivial amount of library code getting inlined into your program, now how would you get sane profiling results without profiling info of said libraries?
06:27:59 <BlankVerse> merijn: oh, that means profiler has no idea that a particular instruction belongs to which library or exec
06:28:07 <merijn> BlankVerse: Right
06:28:17 <BlankVerse> unless the libraries have been built with profiling on
06:28:44 <merijn> BlankVerse: GHC inlines *much* more aggressively than say, gcc, since with haskell's purity it is much easier to do safe inlining
06:29:08 <Heffalump> does purity really make much difference to inlining safety?
06:29:09 <BlankVerse> merijn: what would be "unsafe" inlining?
06:30:11 <merijn> Actually, now I'm not sure whether that's even that relevant...
06:30:46 <merijn> I guess it's more of a local vs whole-program optimisation type of deal
06:31:27 <BlankVerse> I am unable to think of examples where the decision to inline has anything to do with its side-effects/impurity
06:31:44 <merijn> BlankVerse: Yeah, now that I rethink it, that may just have been a thinko
06:31:47 <BlankVerse> doesn't inlining just depend on the size of the code to be inlined?
06:32:20 <ajf> So, now that I have my enums, is using functions a good way for specifying constant info about each type of thing?
06:32:21 <merijn> BlankVerse: Well, it depends on another thing, the unit of compilation
06:32:21 <BlankVerse> inline is always faster due to lesser function call overhead but tradeoff is increased size of executable
06:32:31 <ajf> *my data types
06:32:34 <Heffalump> I think the main reason GHC inlines so much is that (a) it really needs to get good performance and (b) inlining is most valuable when it exposes other optimisations, and pure code really does make a difference there
06:32:36 <merijn> BlankVerse: Generally C compiles 1 file at a time
06:32:44 <Heffalump> BlankVerse: not true, it can screw up caches if your code is too big
06:32:52 <ajf> Say I have: data Team = RedTeam | BlueTeam | GreenTeam
06:33:01 <Heffalump> and also branch predictors won't learn as fast
06:33:05 <merijn> BlankVerse: So it can only inline within a file
06:33:15 <ajf> To store data about team colours, should I define getTeamColour :: Team -> Colour
06:33:31 <ajf> getTeamColour RedTeam = “#ff0000”
06:33:44 <ajf> Does that sound like a good idea?
06:34:07 <merijn> BlankVerse: GHC fakes whole-program optimisation as follows: 1) while compiling a library it will identify good inlining candidates (based on pragma's, code size, etc.) and dump special version of those into .hi interface files.
06:34:52 <merijn> BlankVerse: When compiling another library dependent on the first, it will look in the interface and if you're using a function that's in the "inline candidates" it will just inline the library functions directly.
06:34:56 <bvad> Hello there, I'm looking for a reference on formal verification where FP is concluded "easier to verify" or something in that direction.. Does anyone know of any such reference?
06:34:57 <awestroke> ajf: that looks good, you can always change it later (if you decide to store such things in a config file for example).
06:35:02 <merijn> ajf: Sure
06:35:21 <ajf> Right, OK
06:35:38 <merijn> bvad: I don't know a concrete reference, but you may want to include "equational reasoning" in your search
06:36:09 <merijn> bvad: You can only do equational reasoning in a purely functional language and it's one of the easier ways to do formal verification
06:36:36 <bvad> merijn: Thanks, that might help!
06:44:16 <ajf> type MapTiles = IArray (Int, Int) MapTile
06:44:26 <ajf> That’s the right type for a 2D array of MapTiles, right?
06:45:06 <merijn> ajf: Correct
06:45:11 <ajf> I see
06:45:21 <ajf> Aren’t Arrays basically hashmaps, then?
06:45:38 <merijn> No
06:45:59 <merijn> Arrays should have O(1) lookup, hashmaps (despite dumb claims on the internet otherwise) do not
06:46:06 <ajf> ah
06:46:07 <Thooms> @pl \x -> (++ [[x]]) . map (++ [x])
06:46:07 <lambdabot> ap ((.) . flip (++) . return . return) (map . flip (++) . return)
06:46:22 <ajf> So internally it’s implemented as a 2D array, despite the interface?
06:46:45 <merijn> ajf: Consider arrays to be hashmaps with 1 bucket per possible key and a constant time hasing function (i.e. pretty much a 2D array)
06:47:01 <ajf> OK
06:47:26 <merijn> ajf: Hashmaps have <1 bucket per possible key (because, if not why not use an array) and thus the worst case lookup for a hashmap is O(n) in most cases. Plus the hashing function may have a non-constant time
06:48:07 <ajf> I see
07:05:57 <Algebr> not sure if my previous message went through.
07:07:06 <FireFly> Algebr: when did you send it?
07:07:29 <FireFly> I'm not seeing anything from you in the past half hour, so probably it didn't get through
07:17:54 * hackagebot geojson 1.1.0 - A thin GeoJSON Layer above the aeson library  http://hackage.haskell.org/package/geojson-1.1.0 (domdere)
07:20:28 <question1234> Suppose I allocate some memory in haskell via Foreign.Marshal.Alloc.malloc .. If I pass that pointer to a C function, can I then free that memory via a call in C to free()?
07:21:37 <question1234> Nevermind. The definition in Foreign.Marshal.Alloc is a very thin wrapper around free.
07:25:32 <awestroke> why is there an ap :: Monad m => m (a -> b) -> m a -> m b when there already is (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:26:42 <dario> probably because Applicative isn't a superclass of Monad (yet)
07:26:56 <FireFly> Because (until very recently) the Monad typeclass doesn't have an Applicative constraint, so if you have a  Monad m => m  value and wanted to use (<*>) you'd need to add a  Applicative m  constraint to it as well
07:27:22 <awestroke> dario: in principle it is, I've never seen a monad that isn't also an applicative
07:27:34 <dario> in principle yes, but not yet in typesystem
07:27:35 <awestroke> FireFly: oh, constraints
07:27:41 <awestroke> dario: ok ok
07:28:51 <dario> but it'll soon be, see http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
07:33:14 <enthropy> awestroke: (<*>) could be "zipWith ($)", and you wouldn't be breaking any laws that are currently part of the classes
07:33:29 <awestroke> :t zipWith
07:33:30 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:33:50 <awestroke> only applies to [] then
07:34:00 <enthropy> I mean as a specific instance
07:34:37 <enthropy> you could have the instance Applicative ZipList done without a newtype
07:35:41 <fizruk> > traverse ZipList [[1, 2, 3], [4, 5, 6]]
07:35:43 <lambdabot>  ZipList {getZipList = [[1,4],[2,5],[3,6]]}
07:35:44 <enthropy> but anyways, I don't think there are any cases where replacing ap with <*> will change the program's output (if it compiles)
07:38:32 <dwcook> There certainly can be. All it takes is for a library to define incompatible Applicative and Monad instances.
07:40:35 <leggo> could a library do that and still follow Monad and Applicative laws? :P
07:40:41 <dwcook> No.
07:41:17 <dwcook> Well, wait. I was thinking Monad's laws mention Applicative, but I'm not sure they do. Let me check.
07:41:44 <fizruk> dwcook: why not? e.g. ZipList-like Applicative and NonDet-like Monad for []
07:42:12 <dwcook> fizruk: I know, but I was thinking the canonical Monad laws said "If Applicative is defined, then also…" but I'm not sure they do.
07:42:20 <dwcook> Surely people do agree that Applicative and Monad instances should agree, though.
07:42:33 <fizruk> although Applicative instance is expected to follow Monad (if latter exists)
07:42:54 <dwcook> Sure, Functor can be defined entirely in terms of Applicative and Applicative in terms of Monad.
07:43:41 <dwcook> fmap f x = pure f <*> x
07:43:41 <dwcook> pure = return
07:43:41 <dwcook> x <*> y = x `ap` y
07:44:28 <dwcook> (or just (<*>) = ap)
07:44:51 <enthropy> "If f is also a Monad, it should satisfy pure = return and (<*>) = ap (which implies that pure and <*> satisfy the applicative functor laws)."
07:45:04 <enthropy> is part of the documentation for Control.Applicative
07:45:19 <dwcook> Ah, guess I was looking in the wrong place. :) That's good to know.
07:45:35 <awestroke> in which GHC version is the Appliative m => Monad m constraint introduced?
07:45:46 <enthropy> then again "should" is not as "must"
07:45:52 <enthropy> *as strong as
07:46:49 <dwcook> 7.10 I think?
07:47:04 <dwcook> Yeah
07:54:30 <awestroke> :t (.)
07:54:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:55:16 <oleo> :t (.)(.)
07:55:16 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
07:55:21 <oleo> lol
07:56:16 <awestroke> @pl flip (.)
07:56:17 <lambdabot> flip (.)
07:57:44 <FreeFull> @pl \x y -> y . x
07:57:44 <lambdabot> flip (.)
07:59:28 <awestroke> my brains wants  (a -> b) -> (b -> c) -> a -> b
07:59:36 <awestroke> oops.. should be (a -> b) -> (b -> c) -> a -> c
07:59:47 <FreeFull> :t (.)
07:59:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:00:01 <FreeFull> :t flip (.)
08:00:02 <lambdabot> (a -> b) -> (b -> c) -> a -> c
08:00:13 <FreeFull> awestroke: flip (.) is what you want
08:00:17 <awestroke> yeah
08:00:19 <FreeFull> You can assign it to a new operator
08:00:42 <awestroke> .__$@_// = flip (.)
08:00:50 <awestroke> perfect
08:03:39 <FireFly> It's too bad `` doesn't allow arbitrary expressions, so that `flip (.)` would work as an infix operator
08:03:47 <ajf> AWTypes.hs:1:1:    File name does not match module name:    Saw: `Main'    Expected: `AWTypes'
08:03:51 <ajf> What am I doing wrong?
08:03:58 <ajf> I have main.hs that imports AWTypes
08:04:05 <ajf> AWTypes.hs defines the module AWTypes
08:04:22 <ajf> Oh
08:04:27 <mmmm_> is ghc-mod meant to work out the box with cabal sandboxes?
08:04:31 <ajf> Does the line “module” have to be first-thing in the file?
08:04:37 <hakujin> mmmm_: yep
08:04:57 <mmmm_> ok, so any common reasons why it wouldn't?
08:05:05 <hakujin> are you using emacs and haskell-mode?
08:05:13 <mmmm_> I'm using vim
08:05:31 <awestroke> ajf: language pragmas first, then module x where, then it's standard to have imports, then defs
08:05:31 <mmmm_> but ghc-mod check <path> doesn't pick up the sandbox
08:05:33 <hakujin> do you have a .cabal file defined for your current sandboxed directory?
08:05:44 <hakujin> (are you using syntastic?)
08:05:46 <ajf> awestroke: ah
08:05:50 <ajf> I had my imports before module
08:05:51 <mmmm_> yes, yes
08:05:57 <enthropy> awestroke, FreeFull you can use Control.Arrow.>>>
08:06:28 <hakujin> :pwd returns something sane?
08:06:34 <FreeFull> enthropy: True
08:06:43 <FreeFull> Although that's more general than (.)
08:07:35 <Maior> @hoogle [a] -> (a -> Bool) -> [a]
08:07:36 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:07:36 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
08:07:36 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
08:08:31 <mmmm_> using ghc-mod from the command line doesn't work either, ie being in the directory with the .cabal file and running ghc-mod check <path>
08:09:04 <hakujin> what is your ghc-mod --version?
08:09:06 <mmmm_> well it works but complains about missing all the sandboxed libraries..
08:09:08 <mmmm_> 4.1.0
08:10:42 <hakujin> running out of ideas, sorry. maybe kill your sandbox, reinit, and reinstall --only-dependencies
08:11:13 <mmmm_> thanks for your help
08:11:58 <awestroke> can I force cabal to use makefile to build and not build to dist/ ?
08:15:19 <geekosaur> "can I make cabal not be cabal?"
08:16:05 <monochrom> I know how. I go into cabal-install source code and replace its main by "main = return ()" :)
08:16:18 <awestroke> geekosaur: I like the dependency management, but I don't like having no control of the build process
08:16:37 * monochrom read cabal-install source code and discovered "optimization: 2" :)
08:17:48 <Maior> awestroke: what does "no control of the build process" mean? what do you want?
08:19:25 <awestroke> Maior: I want to be able to build 2 separate executables, and I have html and css asset targets in my makefile, and one of my executables re-runs "make" and reloads the other executable on code change (a poor-mans hot code reload)
08:20:42 <awestroke> it's a development wrapper that proxies HTTP requests to the real server (to be able to server static files too, which the real program should not do), and displays compile errors in HTML format, and reloads everything on sucessful recompile
08:21:41 <awestroke> perhaps I can make it run "cabal install" instead but then I'd still have a makefile for the assets
08:31:03 <c_wraith> wait, what the heck is ghci telling me here?  Prelude Data.Functor.Foldable> :i Prim     type role Prim nominal nominal       data family Prim t $a
08:31:19 <c_wraith> Why is that $a?
08:31:34 <benzrf> hey
08:32:13 <benzrf> going from 98 to 2010, the only significant additions to the language are empty data decls and pattern guards, right?
08:32:37 <hpc> didn't GADTs make it in too?
08:32:38 <deweyvm> is there a haskell program that can parse date strings into some common Date format, similar to the unix program `date` ?
08:32:41 <benzrf> dont think so
08:32:41 <deweyvm> library*
08:32:42 <merijn> hpc: No
08:32:43 <benzrf> https://ghc.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
08:32:59 <merijn> hpc: GADTs would require existential quantification and rankntypes into the standard
08:33:25 <EvanR> deweyvm: you mean format them?
08:33:34 <EvanR> yes
08:33:44 <deweyvm> EvanR: i jsut dont want to have to parse them myself
08:33:53 <enthropy> -XDoAndIfThenElse is enabled when you don't specify a language in the cabal file
08:34:08 <EvanR> deweyvm: http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html
08:34:31 <deweyvm> EvanR: thanks!
08:34:31 <EvanR> this lets you parse and format date strings
08:34:59 <EvanR> the "date" type is called Day in here
08:35:18 <EvanR> look in Data.Time.Calendar
08:36:03 <c_wraith> @hoogle Const
08:36:04 <lambdabot> Control.Applicative Const :: a -> Const a b
08:36:04 <lambdabot> Control.Applicative newtype Const a b
08:36:04 <lambdabot> Data.Data data Constr
08:36:18 <c_wraith> I wouldn't have guessed that's in Applicative.  huh.
08:36:27 <benzrf> wait, how can Const be a functor
08:36:39 <merijn> benzrf: Trivially?
08:36:43 <benzrf> or rather, how can 'Const b' be a functor
08:36:47 <benzrf> the a is a phantom type..
08:36:55 <merijn> "fmap (Const a) = Const a
08:36:57 <merijn> eh
08:36:58 <c_wraith> That doesn't prevent it from being a functor
08:37:01 <merijn> Insert an f there
08:37:06 <c_wraith> as merijn shows
08:37:13 <EvanR> > showGregorian (fromGregorian 2014 05 05)
08:37:14 <lambdabot>  Not in scope: ‘showGregorian’Not in scope: ‘fromGregorian’
08:37:21 <c_wraith> It just makes fmap purely type-changing
08:37:21 <benzrf> oh right.
08:37:22 <benzrf> haha
08:37:30 <c_wraith> it doesn't apply the function, it just changes types
08:37:33 <benzrf> never even occurred to me >.<
08:38:06 <c_wraith> phantom types can be instances of Functor *and* of Contravariant!
08:38:08 <merijn> benzrf: It's why Const can be Applicative, but not Monad
08:38:28 <c_wraith> and in fact, being an instance of both is of those necessarily implies the type parameter is phantom
08:38:28 <benzrf> merijn: eh?
08:38:32 <EvanR> Day, UTCTime, and AbsoluteTime form affine spaces respectively
08:38:41 <merijn> "Const x (a -> b) -> Const x a -> Const x b" requires no actual a
08:38:49 <benzrf> ah right
08:38:58 <merijn> Well iff x is a monoid
08:39:00 <benzrf> i was thinking of join to be precise
08:39:17 <merijn> "Const a <*> Const b = Const (mappend a b)"
08:39:18 <c_wraith> if it's a monoid, I think it can be a monad just fine
08:39:23 <merijn> c_wraith: No
08:39:26 <merijn> Consider
08:39:35 <benzrf> Const r (Const r a) -> Const r a
08:39:39 <merijn> "Const x a -> (a -> Const x b) -> Const x b"
08:39:51 <benzrf> do the fmap trick
08:39:55 <merijn> c_wraith: You cannot call f with 'a'
08:39:58 <benzrf> never call the func
08:40:02 <merijn> Because there is no a
08:40:05 <merijn> benzrf: You have to
08:40:08 <benzrf> why?
08:40:18 <c_wraith> ah, right.  That means you can't combine the x values as required to be consistent with the applicative interface
08:40:19 <merijn> benzrf: Because you can't return a "Const b" otherwise
08:40:24 <benzrf> oh, functor laws
08:40:28 <benzrf> of course >.<
08:40:31 <benzrf> *monad laws
08:40:47 <c_wraith> merijn: you can certainly return a value of the right type - but it will break laws
08:40:54 <merijn> c_wraith: Right
08:41:10 <benzrf> so a non-calling functor is valid, but a non-calling monad breaks the laws
08:41:19 <c_wraith> not completely
08:41:29 <c_wraith> data T a = T
08:41:33 <c_wraith> that can be made a monad
08:41:47 <benzrf> i suppose
08:41:50 <merijn> benzrf: Functor laws just require "fmap id == id" which is trivial with const :p
08:42:10 <hpc> fun fact: you can't write fmap _ x = x with that type
08:42:14 <hpc> it has to be fmap _ T = T
08:42:37 <c_wraith> hpc: yep!  That's type safety, right there!
08:42:51 <c_wraith> hpc: well, actually.  fmap _ _ = T will also work
08:43:00 <c_wraith> hpc: with different strictness properties
08:43:16 <hpc> c_wraith: fmap id _|_ = T breaks the laws
08:43:33 <c_wraith> only if you disallow fast and loose reasoning
08:43:44 <merijn> hpc: Don't care, fast and loose reasoning is morally correct!
08:43:51 <hpc> ;)
08:43:57 <Maior> is there a convenient way to get a ghci instance with `hs-source-dirs` from my .cabal file?
08:44:08 <hpc> i figure might as well make bottoms crashy just so you notice they are there
08:44:20 <merijn> Maior: "cabal repl" or something like that?
08:44:23 <Maior> (i.e. I have a library with `hs-source-dirs: src`; I'd like to not have to manually `ghci -isrc`)
08:44:39 <Maior> merijn: that looks plausible, but my cabal doesn't have that
08:44:47 <merijn> Maior: Update your cabal? :>
08:44:52 <c_wraith> then install a new cabal!
08:45:02 <c_wraith> cabal repl has some annoying issues at the moment, though
08:45:04 <Maior> hm thought I was running latest, thanks
08:45:12 <XrXr> I manage to break ghci http://lpaste.net/103928 I don't know if I can reproduce it though. And its not the newest version of ghc
08:45:13 <merijn> Maior: Latest is 1.20
08:45:14 <c_wraith> the latest is now 1.20.0.1
08:45:34 <Maior> :s
08:45:41 * Maior replaces 1.16
08:45:42 <Maior> thanks
08:45:51 <benzrf> > fmap id undefined
08:45:52 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
08:45:53 <lambdabot>    arising from a use of ‘M178000339163147312924413.show_M1780003391631473129...
08:45:53 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
08:45:53 <lambdabot>  Note: there are several potential instances:
08:45:53 <lambdabot>    instance [safe] GHC.Show.Show a =>
08:45:56 <benzrf> i dont know what i expected
08:46:26 <c_wraith> XrXr: that's impressive.  Blocking indefinitely on an MVar during compilation?  Are you doing any compile-time coding?
08:46:37 <c_wraith> XrXr: like template haskell or quasiquoting?
08:46:58 <XrXr> I'm not doing anything special.. just typing in ghci
08:47:30 <merijn> XrXr: Using MVars?
08:47:32 <c_wraith> Both of those can be done typing in ghci. :)
08:47:39 <Maior> :s
08:47:53 <Maior> well this is great; `cabal install cabal-install && cabal --version` -> 1.16
08:48:03 <c_wraith> Maior: path issue?
08:48:07 <hakujin> Maior: update your path
08:48:09 <monochrom> ghci creates a few of its own threads and uses a few of its own MVars too
08:48:09 <merijn> Maior: Probably path :)
08:48:17 <merijn> Maior: "which cabal"
08:48:18 <XrXr> I don't even know what MVars is ... and I can't reproduce it.. all I did was press enter a bunch of time and type in numbers
08:48:22 <benzrf> > [|foo|]
08:48:23 <lambdabot>  <hint>:1:2: parse error on input ‘|’
08:48:29 <hakujin> ~/.cabal/bin should be near the front
08:48:30 <merijn> XrXr: Pastebin what you entered?
08:48:36 <c_wraith> XrXr: MVar is a primitive for communicating between threads.
08:49:06 <Maior> yeah cheers; presumably a path issue, but I have no ~/.cabal/bin
08:49:21 <Maior> ah, ~/Library/Haskell/bin
08:50:01 <EvanR> does it make sense to collect STM () actions from various places in the program, accumulating them with >> and then use atomically on it later
08:50:02 <monochrom> in fact! here is what happens daily: when you enter "1+1", a forkIO is done, the child thread does the "1+1", the main thread waits on an MVar for that answer.
08:50:13 <merijn> EvanR: Maybe, maybe not
08:50:18 <XrXr> http://lpaste.net/103929 werid
08:50:26 <monochrom> this is why entering gtk2hs commands into ghci by hand fails
08:50:29 <c_wraith> EvanR: it makes sense if you want to run all of those actions as a single transaction
08:50:36 <EvanR> yes
08:50:40 <Maior> much better, thanks
08:52:11 <EvanR> i just have a hard time imagining the result working
08:52:32 <EvanR> like a failed transaction will auto retry, but will its effect make sense at that point?
08:52:47 <XrXr> hm.. map.head didn't response on line 506, that's probably where it broke. Probably just a fluke http://lpaste.net/103929
08:53:28 <EvanR> i guess if IO was done between the STM ()s being computed, it might not make sense
08:54:16 <monochrom> EvanR, grouping them has a different semantics from separating them, as you have just noticed. you must choose which semantics you want, and group/separate accordingly. it must be an intelligent design.
08:54:46 <XrXr> OMG I can reproduce the bug consistently now
08:54:54 <EvanR> interesting
08:55:03 <monochrom> interesting. which version? on which OS and hardware?
08:55:29 <XrXr> GHCi, version 7.6.3 on Windows 7
08:58:01 <XrXr> yep. just hold control c for a few seconds, then type anything and press enter and it blows up..
08:58:27 <merijn> Ctrl c is supposed to be broken on windows, no?
08:58:31 <merijn> I remember something along those lines
08:58:43 <merijn> You can't use ctrl-c to interrupt processing on Windows, afaik
08:59:00 <XrXr> I works fine normally
08:59:16 <XrXr> if I type something then press control c it just switch to a new line
08:59:16 <EvanR> ctrl-z on windows
08:59:42 <XrXr> ctrl-z doesn't work for me
08:59:59 <EvanR> windows 7, i have no idea
09:00:17 <XrXr> I can do [1..] and ctrl-c will stop it with an Interrupted
09:00:19 <merijn> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/ghci-windows.html ?
09:00:25 <merijn> oh, wait
09:00:29 <merijn> stupid old google link
09:00:39 <XrXr> maybe its time to switch to the Linux master race
09:00:47 <merijn> lthough latest says the same thing
09:02:06 <XrXr> I don't know if I did something special to my shell, but ctrl c doesn't kill the ghci process
09:02:17 <monochrom> just replace 0.4 by 6.3 in that url :)
09:02:35 <XrXr> oh nvm its for Cygwin or MSYS, I'm using powershell
09:02:50 <monochrom> true
09:03:07 * hackagebot simple-neural-networks 0.2.0.1 - Simple parallel neural networks implementation  http://hackage.haskell.org/package/simple-neural-networks-0.2.0.1 (eax)
09:03:27 <monochrom> well, I agree that it is a bug, especially since it is inconsistent. there is likely very little you can do about it.
09:05:18 <XrXr> hm. seems pretty consistent to me. I can reliably crash ghci now. I tested in 2 different consoles too. Not a big deal though.
09:06:21 <echaozh> hi. I've switched to ghc 7.8 today, and then a whole bunch of packages fail to install due to "hGetContents: invalid argument (invalid byte sequence)", as in "/tmp/pkgConf-enclosed-exceptions-1.0.08581.1: hGetContents: invalid argument (invalid byte sequence)"
09:06:57 <echaozh> looks like the author/maintainer fields include non-latin letters
09:06:58 <merijn> Is there a sensible way to turn "StateT s m a" into "StateT (f s) m a" i.e. a library is using StateT and I wanna piggyback my own StateT in there
09:07:43 <merijn> Or should I just "StateT MyState (StateT s m) a" for this?
09:07:52 <quchen> Isn't that what Lens' 'zoom' does?
09:08:30 <benzrf> :t zoom
09:08:31 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
09:08:34 <benzrf> wut
09:08:39 <echaozh> Is it only me?
09:08:43 <benzrf> god damn am i unable to read lens types
09:09:21 <benzrf> omg
09:09:31 <monochrom> I am unable, too.
09:09:47 <merijn> I don't think anyone other than edwardk and his inner circle can read it :p
09:10:01 <merijn> According to haddock " zoom :: Monad m             => Lens' s t      -> StateT t m a -> StateT s m a"
09:10:08 <quchen> :t zoom _2 (do x <- get; put (x+1); return x) :: State (a, Int) Int
09:10:09 <lambdabot> State (a, Int) Int
09:10:18 <merijn> So I think this should work
09:11:13 <quchen> In my example above, the entire thing has state (a, Int). Using 'zoom', I can write a 'do' block that works as if the state type was only Int.
09:11:40 <quchen> Don't leave the type sig away or hell will break loose though.
09:12:22 <jmcarthur> it's like local for Reader
09:12:40 <jmcarthur> but for State instead
09:13:08 <hpc> how does the (Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) constraint resolve in that case?
09:15:03 <merijn> Although pipes isn't making me write types much better than lens
09:15:27 <merijn> (StateT (s, forall x . Producer a m x) m (Either b (Producer b m s))) or something
09:16:20 <quchen> That looks like a parser type.
09:16:44 <merijn> quchen: Parser with my own type spliced in
09:16:57 <quchen> Your own state type?
09:17:03 <quchen> (The "s"?)
09:17:11 <merijn> I still haven't quite figured out how to use pipes-parse, though
09:17:44 <benzrf> pipes only has a few types
09:17:48 <merijn> Turning "Parser a m b" into "Producer b m r" is somehow not built in
09:17:53 <benzrf> lens is a massive clusterfuck of typeclases
09:18:28 <merijn> And figuring out how exactly I want to do that is not obvious atm, as I need a way to "temporarily" switch producers while running
09:18:35 <edwardk_> benzrf: Zoom falls into the handful of ad hoc overloading classes that lens offers for convenience. Most of lens is about using standard classes to do interesting things
09:18:48 <edwardk_> Zoom is hideous because it has a hard problem to solve
09:19:11 <edwardk_> It has to solve "How do you walk into a monad transformer stack and swap out the state type for another type"
09:19:21 <edwardk_> That probem had been previously intractable.
09:19:37 <benzrf> o-o
09:20:19 <edwardk_> If you look at all other lens libraries they only ever let you do that to a state on the outside of a transformer stack if at all.
09:20:54 <edwardk_> so if you wanted errors, etc. or needed some state to backtrack with you you were out of luck
09:24:38 <merijn> Argh
09:25:03 <merijn> Partially applied type synonyms are wrong so I can't have "Parser a m" as monad for a transformer :\
09:28:33 <benzrf> merijn: sadly :(
09:28:37 <benzrf> there IS an extension for it tho
09:28:53 <EvanR> > 3.14 :: Rational
09:28:54 <lambdabot>  157 % 50
09:29:11 <merijn> benzrf: Which one?
09:29:34 <deweyvm> whats the difference between Data.Time.Clock.UTCTime and Data.Time.Clock.UTC.UTCTime
09:29:46 <merijn> deweyvm: Local and UTC time?
09:30:47 <deweyvm> i dont understand
09:32:11 * merijn Doesn't even see a Data.Time.Clock.UTC module
09:32:24 <deweyvm> well my problem is:
09:32:45 <deweyvm> im importing Data.Time.Clock to get UTCTime, and i get an error if i try to convert it to an sql value with ODBC
09:32:49 <deweyvm> Couldn't match expected type `time-1.4.0.1:Data.Time.Clock.UTC.UTCTime' with actual type `UTCTime'
09:33:14 <jmcarthur> i bet UTCTime is actually defined in that internal module, but it's rexported from the public module
09:33:30 <jmcarthur> and your error is actually that you are trying to use two different versions of the time package
09:34:37 <deweyvm> i only have "time" in my cabal file
09:34:46 <deweyvm> er, only one version
09:34:48 <jmcarthur> try time == 1.4.0.1
09:34:59 <jmcarthur> it sounds like one of your other dependencies is using that version of time
09:35:04 <jmcarthur> but you are using some other one
09:35:08 <jmcarthur> so the types are not compatible
09:35:20 <deweyvm> you are correct, oh boy
09:35:21 <deweyvm> package HDBC-2.4.0.0 requires time-1.4.0.1
09:35:21 <deweyvm> package time-lens-0.4.0.1 requires time-1.4.2
09:35:50 <deweyvm> looks like only time-lens uses the newer version, is there a way to fix this or can i just not use that library?
09:36:09 <jmcarthur> maybe try making a new cabal sandbox and install those packages together. see if it can use the same version of time
09:36:33 <jmcarthur> actually, it sounds like you already have a cabal project
09:36:38 <jmcarthur> so just do this:
09:36:52 <jmcarthur> in your projects directory:   cabal sandbox init; cabal install
09:36:57 <jmcarthur> *project
09:37:14 <deweyvm> cabal.exe: unrecognised command: sandbox
09:37:24 <jmcarthur> you must be using an old version of cabal-install
09:37:46 <deweyvm> im using the windows version of haskell platform, maybe its not out yet for this?
09:37:57 <jmcarthur> the haskell platform is getting a bit out of date now
09:38:07 <jmcarthur> you should still be able to update cabal-install though, using cabal
09:38:15 <jmcarthur> cabal install cabal-install
09:38:25 <deweyvm> yea, just did, still no sandbox unfortunately :(
09:38:38 <jmcarthur> are you sure your hackage cache is up to date?
09:38:40 <jmcarthur> cabal update?
09:38:55 <deweyvm> pretty sure, just did it the other day. ill try again though
09:39:22 <benzrf> the answer is
09:39:25 <benzrf> don't use windows
09:39:26 <benzrf> :-)
09:39:28 <bergmark>  deweyvm check if cabal --version changed, otherwise you need to update your PATH
09:39:40 <jmcarthur> ah yeah, it is likely to be a PATH thing
09:39:55 <jmcarthur> benzrf: that's not particularly helpful :\
09:40:54 <deweyvm> went from 1.16.0 to 1.20.0.1
09:41:08 <deweyvm> cabal --version still says 1.16.0
09:41:46 <Polarina> deweyvm, did you install the new cabal version with cabal?
09:41:51 <deweyvm> i did
09:42:04 <Polarina> deweyvm, Does ~/.bin/cabal --version say anything?
09:42:13 <merijn> quchen: There really is quite some room left for utility streaming parsing functions for pipes-parse >.>
09:42:17 <jmcarthur> Polarina: i think this is on windows
09:42:28 <jmcarthur> deweyvm: i think you need to make sure the new cabal executable is in your path
09:42:42 <jmcarthur> i don't remember off the top of my head how to do this in windows
09:42:48 <sm> its \Users\X\AppData\*\cabal\bin or similar
09:43:02 <merijn> I've been wrestling a day to figure out which types I want and everything I come up with is horrifically Frankensteinian >.>
09:43:08 <EvanR> i made a map of the Data.Time types http://imagebin.org/310080
09:43:22 <EvanR> interesting you cant convert UniversalTime to UTC
09:43:22 <sm> I would have thought the Haskell Platform windows installer would add that to the path for you
09:43:28 <EvanR> directly
09:44:06 <monochrom> %appdata%\cabal\bin
09:44:16 <jmcarthur> EvanR: this diagram makes me confused about the difference between LocalTime vs ZonedTime
09:44:25 <sm> that's a nice start EvanR
09:44:36 <EvanR> yeah what do the arrows mean
09:44:41 <sm> should be added to time's haddock
09:44:41 <deweyvm> yes it looks like the haskell platform default cabal comes before the appdata one
09:45:00 <jmcarthur> LocalTime is UTCTime+TimeZone, so why does it look like the difference between LocalTime and ZonedTime is also a TimeZone?
09:45:02 <sm> deweyvm: that seems a bug worth reporting against the HP
09:45:25 <deweyvm> actually i dont see the appdata one in %PATH% at all
09:45:32 <EvanR> jmcarthur: local time is Day + TimeOfDay
09:45:33 <deweyvm> but weirdly it is in cygwin's $PATH
09:45:36 <jmcarthur> maybe the fact that the arrow between UTCTime and ZonedTime is unlabelled is what is confusing me
09:46:25 <Zearen> (a -> c -> d) -> (a -> b -> c) -> a -> b -> d -- Look familiar to anyone ?
09:46:45 <hpc> @djinn (a -> c -> d) -> (a -> b -> c) -> a -> b -> d
09:46:46 <lambdabot> f a b c d = a c (b c d)
09:47:23 <hpc> looks like ap
09:47:25 <monochrom> @pl \a b c d -> a c (b c d)
09:47:25 <lambdabot> liftM2 (.)
09:47:29 <benzrf> was gonna say ThatOtherPerson
09:47:31 <benzrf> *that
09:47:33 <EvanR> no label means they are interconvertible with no additional information provided
09:48:22 <Zearen> I've been seeing this pattern a lot, and was wondering  if there was a more elegant solution than (\a -> f a . g a)
09:48:34 <Zearen> Oh !  ap might do it.
09:49:24 <benzrf> :t (<*>) `asAppliedTo` (undefined :: a -> c -> d)
09:49:24 <sm> EvanR: for v2, how about spicing it up with the diagrams package and adding awesome hover text explaining everything
09:49:24 <lambdabot> (a -> c -> d) -> (a -> c) -> a -> d
09:49:35 <deweyvm> okay cabal sandbox works now, thanks all
09:49:51 <monochrom> liftM2 (.) x y = (liftM (.) x) `ap` y
09:50:03 <benzrf> now that is just readable
09:50:06 <EvanR> sm: i thought of adding tooltips, this is from draw.io i didnt delve too deep into the tool because it was annoying me. diagrams packages huh
09:50:07 <benzrf> let it be
09:50:22 <monochrom> this is why I would stick with liftM2 (.)
09:50:35 <sm> EvanR: yup it's awesome, http://projects.haskell.org/diagrams/
09:50:39 <monochrom> (or is it "stick to"?)
09:50:53 <quchen> I would stick with the lambda. It has the benefit of being readable.
09:50:58 <benzrf> quchen++
09:51:01 <Maior> so transpose is great, but I have a [Maybe [Maybe a]] - is there a monadic transpose?
09:51:12 <EvanR> holy ... this is a boss awesome app ;)
09:51:29 <Zearen> Maybe I should just obfuscate^W enhance by defining :.:
09:51:29 <benzrf> :t transpose
09:51:30 <lambdabot> [[a]] -> [[a]]
09:51:33 <deweyvm> how do i attempt to reinstall those packages with the newer version of time? the older didnt work
09:51:36 <benzrf> jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
09:51:38 <benzrf> oops
09:51:58 <deweyvm> i set it to time == 1.4.2 and re-ran cabal install which succeeded, but they are stiljl using 1.4.0.1
09:52:07 <FreeFull> @check (\x -> transpose (transpose x) == x)
09:52:09 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
09:52:09 <lambdabot>  [[]]
09:52:12 <Zearen> What's the fork syntax in J again ?
09:52:28 <FreeFull> > transpose [[]]
09:52:31 <lambdabot>  []
09:52:37 <Maior> :s
09:52:37 <FreeFull> > transpose (transpose [[]])
09:52:39 <lambdabot>  []
09:52:59 <Maior> that feels like a bug :s
09:54:11 <Zearen> :p I guess it's non-obvious trickery no matter which way, so I'll just stick with the more readable, as quchen pointed out, lambda.
09:54:29 <Maior> @src transpose
09:54:29 <lambdabot> transpose []             = []
09:54:29 <lambdabot> transpose ([]   : xss)   = transpose xss
09:54:29 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:54:57 <benzrf> wah
09:55:33 <benzrf> hmmmm
09:55:47 <benzrf> is there a sequence on applicatives
09:55:55 <quchen> sequenceA
09:56:00 <quchen> From Traversable
09:56:25 <benzrf> > sequenceA ["this", "that", "four"]
09:56:26 <lambdabot>  Not in scope: ‘sequenceA’
09:56:26 <lambdabot>  Perhaps you meant one of these:
09:56:26 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
09:56:26 <lambdabot>    ‘sequence’ (imported from Control.Monad.Writer),
09:56:26 <lambdabot>    ‘T.sequence’ (imported from Data.Traversable)
09:56:31 <benzrf> > T.sequenceA ["this", "that", "four"]
09:56:33 <lambdabot>  ["ttf","tto","ttu","ttr","thf","tho","thu","thr","taf","tao","tau","tar","tt...
09:56:38 <benzrf> > T.sequenceA $ ZipList ["this", "that", "four"]
09:56:39 <lambdabot>  No instance for (Data.Traversable.Traversable
09:56:39 <lambdabot>                     Control.Applicative.ZipList)
09:56:39 <lambdabot>    arising from a use of ‘Data.Traversable.sequenceA’
09:56:42 <benzrf> o=
09:57:04 <quchen> Oh. Well that instance should be there.
09:57:14 <magicman> > T.sequenceA $ map ZipList ["this","that","four"]
09:57:15 <lambdabot>  ZipList {getZipList = ["ttf","hho","iau","str"]}
09:59:00 <benzrf> @let zipN = getZipList . T.sequenceA . map ZipList
09:59:02 <lambdabot>  Defined.
09:59:18 <benzrf> > zipN [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
09:59:20 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
09:59:32 <c_wraith> that looks a lot like transpose
09:59:36 <benzrf> it *is* transposr
09:59:38 <benzrf> *transpose
09:59:45 <c_wraith> Well, no
09:59:49 <benzrf> well it is very close
10:00:00 <c_wraith> > zipN [[1],[2,3,4,5]]
10:00:01 <lambdabot>  [[1,2]]
10:00:07 <c_wraith> > transpose [[1],[2,3,4,5]]
10:00:08 <lambdabot>  [[1,2],[3],[4],[5]]
10:00:12 <benzrf> it is equal for actual squares
10:00:12 <benzrf> :p
10:00:15 <benzrf> *rects
10:00:17 <deweyvm> it works! thanks all
10:00:48 <benzrf> > transpose [[1,2],[3],[4],[5]]
10:00:50 <lambdabot>  [[1,3,4,5],[2]]
10:00:52 <benzrf> hmmm
10:01:21 <Maior> I have a square I need to transpose + flip
10:01:25 <Maior> it's a pain
10:01:50 <eizo> given data SomeType = One | Two | Three, can i pattern match on Two and Three within the same pattern (without using guards)?
10:01:53 <benzrf> FliPPeh: ?
10:01:54 <benzrf> *flip
10:01:59 <benzrf> eizo: eh?
10:02:06 <benzrf> explain what you mean pls
10:02:10 <quchen> Maior: Are you sure lists are a good representation for your data?
10:03:08 <benzrf> eizo: oic what you meandi__
10:03:09 <benzrf> *mean
10:03:10 <benzrf> why not use ==
10:03:16 <Maior> quchen: ultimately it ends up as an `Array (BoardSquare, BoardSquare) (Maybe Piece)`
10:03:42 <Maior> quchen: the lists are an intermediate step
10:03:45 <eizo> benzrf: in a guard pattern? i want haskell to still be able to tell me whether my pattern matching is exhaustive or not
10:03:53 <Maior> for my diy-hacky-parsing
10:06:14 <Maior> (with ALL THE MAYBES)
10:06:24 <eizo> > data SomeType = One | Two | Three; f (Two|Three) = 0
10:06:25 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:06:33 <eizo> something like that
10:06:33 <quchen> Transposing lists is hard. Transposing an Array you can do by specifying a transposed accessor function.
10:06:44 <Maior> quchen: oooh
10:06:54 <quchen> (And don't write code using lists and later refactor it. Use the proper structure from the beginning.)
10:07:23 <Maior> quchen: I'm not convinced starting with lists is a terrible approach
10:08:46 <Maior> given that the surrounding type is String -> AboveArray, and the Strings I'm "parsing" look like "rnbqkbnr/8/8/1B6/8/8/8/RNBQK1NR"
10:09:00 <Maior> a split/map -> listArray seemed sensible
10:09:52 <Chosen> hello #haskell. I have a wierd request, unrelated to haskell, but I want to hear what haskellers opinion.
10:10:25 <Chosen> what budget friendly, fuel efficeint car woudl you buy in 2014?
10:10:35 <enthropy> Chosen: #haskell-blah would be more appropriate
10:11:01 <Chosen> but, haskellers are the smartest people in the world. I need them to make deceisions for me.
10:11:14 <FireFly> #ahskell-blah has plenty of haskellers in it
10:11:19 <FireFly> well, at least plenty of #haskellers
10:11:24 <Chosen>  using #haskell as my cloud based decision service.
10:12:02 <EvanR> sm: you were saying you can have hover text?
10:12:17 <Chosen> ok i'll join blah
10:13:08 <ReinH> quchen: what if you don't know the proper structure from the beginning but suspect that it's list-like? :p
10:14:22 <quchen> Singly list like?
10:14:26 <quchen> +linked
10:14:39 <Maior> granted, it could use some love
10:14:47 <quchen> If you suspect that your data is singly-linked-list-like, use lists, sure
10:16:04 <Maior> (https://github.com/doismellburning/hess/blob/feature/stalemate/src/Hess/Core.hs#L188-L228 for context; apologies for the horrors within)
10:16:59 <deweyvm> how do i get some arbitrary "zero" value for a UTCTime? i dont even care what the value is really
10:17:07 <deweyvm> been trying to figure this out for 20 minutes heh
10:17:20 <deweyvm> i can only find a way to get an IO UTCTime
10:18:52 <supki> deweyvm: posixSecondsToUTCTime 0
10:19:18 <supki> (from Data.Time.Clock.POSIX)
10:19:30 <deweyvm> ahh thanks so much
10:19:44 <EvanR> deweyvm: UTCTime is represented in the library as having no origin, though various epochs are availble
10:20:45 <EvanR> hrm i guess they arent exported, since the choice makes no difference
10:20:50 <deweyvm> i just needed an arbitrary starting time that would be immediately overwritten
10:21:02 <EvanR> what about the current time?
10:21:18 <deweyvm> where i get the seed value im not in the IO monad
10:21:35 <EvanR> im confused why you need a value if its going to be overwritten
10:21:48 <deweyvm> for foldlM
10:21:56 <EvanR> wouldnt the choice matter then?
10:22:06 <deweyvm> doesnt
10:22:29 <deweyvm> i basically have a list of Either Day (Hour,Minute)
10:22:34 <deweyvm> and day always comes first in the data
10:22:35 <EvanR> interesting, well you can also pick an arbitrary UTCTime by parsing a string representation
10:22:46 <EvanR> "2014-01-01 00:00:00"
10:22:53 <deweyvm> then i set the hour/minute for each pair
10:22:58 <deweyvm> until a new Day shows up
10:23:12 <EvanR> sounds like LocalTime to me
10:23:45 <monochrom> do you mind undefined?
10:23:48 <simon____> oh man... I just found by reading a mailing list post from 2011 that the example in Database.MySQL.Simple is wrong. what's up with that!
10:23:49 <deweyvm> i dont actually know what timezone its in so i just picked something arbitrarily. UTCTime may have been the wrong choice
10:23:56 <simon____> it's the one single example that's easily available.
10:24:00 <EvanR> if you have no timezone, use LocalTime
10:24:24 <deweyvm> roger that
10:26:34 <EvanR> which can be constructed directly, using calendar functions to pick the Day
10:28:27 <deweyvm> looks like undefined does work hehe
10:28:50 <deweyvm> itll be easier to catch malformed data that way too
10:30:03 <EvanR> if you have an empty list to fold over, should be noticable without resorting to an undefined error
10:30:43 <EvanR> i am loving (a,[a]) representation of non-empty list of a
10:36:13 <deweyvm> yea i should do something like that once ive cleaned this up a bit
10:36:54 <ion> There's a type for that in a package. You don't have nice instances for (a, [a]). (But i admit i didn't use it in CycList in quadratic-irrationals.)
10:37:38 <meretrix> Is there a nicer way to test equality of a value to a Maybe value?
10:37:40 <meretrix> > maybe False (== 2) (Just 2)
10:37:42 <lambdabot>  True
10:37:46 <meretrix> > maybe False (== 2) (Just 3)
10:37:47 <lambdabot>  False
10:38:43 <pavonia> > Just 3 == Just 2
10:38:44 <lambdabot>  False
10:38:53 <pavonia> Like so?
10:39:36 <benzrf> :-)
10:39:53 <meretrix> Oh.. yup :)
10:40:14 <Kaidelong> I feel like I'm doing cargo cult programming right now
10:40:25 <Kaidelong> but it doesn't seem you can do much better with netwire given the state of the documentation
10:40:52 <ion> http://hackage.haskell.org/package/semigroups-0.13.0.1/docs/Data-List-NonEmpty.html
10:43:11 <Kaidelong> @hoogle maybe
10:43:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:43:12 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:43:12 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))
10:44:47 <bddy_> ..
10:45:06 <bddy_> We can't pattern match to functions in haskell, only to data constructors?
10:45:14 <macron> Kaidelong: what you up to with netwire?
10:45:16 <monochrom> that is right
10:45:34 <Kaidelong> macron: I'm trying to make bindings to GLFW-b for reactive graphics and input
10:45:51 <Kaidelong> there was an existing project that did something like this on github but the solution was too ugly for me to understand
10:46:25 <Maior> bddy_: what are you trying to do?
10:46:33 <gage> Hi haskellers, I'm brand new to haskell and I was wondering what would be your recomended way to install haskell on debian. I mostly ask because it seems that whenever I try to use cabal to install hoogle it fails (I'm using the debian package)
10:48:06 <pavonia> Have you installed the Haskell Platform?
10:48:51 <Kaidelong> http://pastebin.com/Afu5N3Z8 does this look wrong to anyone who knows netwire?
10:49:12 <Kaidelong> @instances Real
10:49:13 <lambdabot> Double, Float, Int, Integer
10:49:39 <bddy_> Maior: Just exploring Haskell. The question was obviously dumb since pattern matching over a function would cause finding inverse.
10:50:07 <kfcChicken> Hey...how come when I browse Data.Word in ghci, byteSwap* functions aren't in scope? I see them on hoogle...
10:50:13 <Kaidelong> I am thinking I should perhaps not use getTime from GLFW because there is a single time elapsed since GLFW was initialized and it's counterintuitive to have all the GLFW windows sharing the same underlying clock
10:50:43 <Kaidelong> OTOH because it's a time delta it shouldn't matter, so long as the user doesn't set the GLFW clock
10:51:03 <pavonia> kfcChicken: Are you browsing the same package version you have installed?
10:51:19 <Kaidelong> maybe I should check for that and throw an error to spank the programmer if they do
10:51:29 <kfcChicken> how can I check my installed version?
10:51:41 <pavonia> "ghc-pkg list base"
10:51:53 <gage> pavonia: I installed haskell from the debian repository... is that the "haskell platform?"
10:52:14 <pavonia> gage: Hhm, I don't know
10:52:29 <gage> it seemed to be what the website recommended
10:52:34 <gage> is there any way to check?
10:53:00 <kfcChicken> I see..I'm on 4.6, and they come in at 4.7. Guess I'll stick to my shift functions. Thanks!
10:53:31 <pavonia> gage: Could you paste the errors you get when installing a package?
10:53:34 <pavonia> @lpaste
10:53:34 <lambdabot> Haskell pastebin: http://lpaste.net/
10:53:51 <Kaidelong> maybe I should also *not* parameterize it on a specific window and not have the session swap the double buffer
10:54:13 <Kaidelong> and have a single glfwSession
10:54:51 <Maior> @hoogle m [m a] -> (a -> b) -> m [m b]
10:54:51 <lambdabot> No results found
10:55:20 <Kaidelong> actually that seems to be best for now
10:57:33 <Enigmagic> :t flip (fmap.fmap.fmap)
10:57:34 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (f2 a)) -> (a -> b) -> f (f1 (f2 b))
10:57:46 <Enigmagic> Maior: ^^^
10:57:59 <Maior> Enigmagic: oh, lists are functors?
10:58:03 <Enigmagic> yes
10:58:22 <Enigmagic> > fmap id [1..4]
10:58:23 <lambdabot>  [1,2,3,4]
10:58:53 <Maior> thanks
10:58:55 <Maior> I feel so dirty
10:59:36 <gage> pavonia: I found haskell-platform in the debian repository verses just haskell so I'm going to try that
10:59:36 <outinputput> @src id
10:59:36 <lambdabot> id x = x
10:59:53 <outinputput> whats the point of the id function?
10:59:57 <mmmm_> How do you escape semi-colons?
11:00:25 <skypers> I’d like to present my sincere apologizes to all folks that were there when we talked about arrays representations some weeks ago; I realize how stupid I was, and might have offended some people. Again, sorry for that, I’ll try to be a nice kid from now! I
11:00:35 <pavonia> mmmm_: Escape where?
11:00:52 <mmmm_> The error is "Unexpected semi-colons in conditional:"
11:00:54 <shachaf> More precisely, lists aren't functors, but [] is a functor.
11:01:09 <Maior> shachaf: can you explain that a little more please?
11:01:24 <mmmm_> the line is takeWhile (/= ';')
11:01:27 <c_wraith> outinputput: say you want to compose together a list of functions.  Well, that's obviously a fold, so you can do something like foldr (.)
11:01:38 <c_wraith> outinputput: but what's the base case?  What's the function when the list is empty?
11:01:50 <c_wraith> outinputput: well, obviously, it must be a function that does nothing
11:01:53 <pavonia> mmmm_: Is that a GHC error?
11:01:55 <skypers> c_wraith: isn’t that equivalent to sequence ?
11:01:55 <shachaf> Maybe is a functor. None of these are functors: Maybe Int, Nothing, Just, Just 5
11:02:05 <c_wraith> :t foldr (.) id -- outinputput
11:02:06 <lambdabot> [b -> b] -> b -> b
11:02:41 <mmmm_> pavonia: nvm, it was a different line ha
11:03:00 <skypers> oh, outinputput is learning, nevermind then
11:03:11 <skypers> > sequence [(*2),(+1)] 3
11:03:12 <lambdabot>  [6,4]
11:03:22 <skypers> > sequence [(*2),(+1)] id 3
11:03:24 <lambdabot>  Couldn't match type ‘[a0 -> a0]’ with ‘a1 -> t’
11:03:24 <lambdabot>  Expected type: (a0 -> a0) -> a1 -> t
11:03:24 <lambdabot>    Actual type: (a0 -> a0) -> [a0 -> a0]
11:03:27 <c_wraith> skypers: so no, not the same at all.
11:03:30 <Maior> @pl \a x -> (fmap . fmap . fmap $ a) x
11:03:30 <lambdabot> fmap . fmap . fmap
11:03:32 <skypers> yeah, might not
11:03:34 <skypers> yeah indeed :)
11:03:51 <c_wraith> > foldr (.) id [(*2), (+1)] 3
11:03:53 <lambdabot>  8
11:03:57 <skypers> :t sequence [(*3)]
11:03:58 <lambdabot> Num a => a -> [a]
11:04:13 <Maior> @pl \x -> (fmap . fmap . fmap $ digitToInt) x
11:04:13 <lambdabot> fmap (fmap (fmap digitToInt))
11:04:37 <skypers> I’m pretty sure there’s something simple for that
11:04:45 <skypers> I did it in the Haskell1Day
11:04:48 <skypers> in a*
11:06:12 <c_wraith> outinputput: generically, though, there are many times where a higher order function takes different functions to apply in different cases.  Sometimes, the function you want to apply in a particular case is "do nothing".  That's what id is for.
11:08:47 <ReinH> yay monoids
11:09:42 <benmachine> yay
11:10:00 <ReinH> > ala Endo foldMap [(*2),(+1)] $ 3
11:10:02 <lambdabot>  8
11:11:05 <bddy_> > (1,2,3,4,5,6,7,8,9,1,2,3,4,5,6)
11:11:07 <lambdabot>  (1,2,3,4,5,6,7,8,9,1,2,3,4,5,6)
11:11:11 <bddy_> > (1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7)
11:11:12 <lambdabot>  No instance for (GHC.Show.Show
11:11:12 <lambdabot>                     (t0,
11:11:12 <lambdabot>                      t1,
11:11:12 <lambdabot>                      t2,
11:11:12 <lambdabot>                      t3,
11:11:32 <skypers> :)
11:11:59 <bddy_> So tuple size are limited
11:12:19 <ReinH> bddy_: that error is trying to *show* the tuple, not constructing it
11:12:59 <simon____> :t Endo
11:13:00 <lambdabot> (a -> a) -> Endo a
11:13:04 <hakujin> tuples that large are usually suspect
11:13:20 <geekosaur> at one point the tuple size limit was 127, larger would make ghc dump core (!)
11:13:27 <simon____> :t foldMap
11:13:28 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:13:43 <geekosaur> but instances are not provided for larger than 15-tuples, iirc
11:13:58 <bddy_> ReinH: Ah, right, I see it here https://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-Show.html#Show if scroll down
11:14:10 <geekosaur> (mostly because why the **** are you using something that large and unwieldy and relatively untyped)
11:14:17 <benmachine> you can write your own instances for 17-tuples if you want them
11:14:23 <dwcook> What do people even use non-pairs for?
11:14:55 <benmachine> dwcook: one thing I have seen is people using e.g. mapM_ to run a computation many different times with a few varying parameters
11:15:47 <quchen> [ (x, model x, exact x) | x <- candidates ] -- Ad hoc triples
11:16:03 <dwcook> Hmm, I guess it makes sense.
11:16:06 <quchen> The only library I know that uses triples in its API is Network.
11:16:20 <dwcook> Or for when you have a function result that's meant to be deconstructed immediately, perhaps.
11:16:49 <geekosaur> there's something in System.Process that uses a 4-tuple
11:16:55 <dwcook> I've only ever returned 2-tuples like that but I can see how one might want to use n>2
11:16:57 <osa1> where is the body part of this function: http://hackage.haskell.org/package/HUnit-1.2.5.2/docs/src/Test-HUnit-Lang.html#assertFailure ?
11:17:05 <ReinH> simon____: and `ala' is a wrap/unwrap transform for newtypes from lens. `ala Endo foldMap' is equivalent to `appEndo . foldMap Endo'
11:17:13 <geekosaur> (processHandle, stdinHandle, stdoutHandle, stderrHandle)
11:17:14 <monochrom> yeah, the example in Network is IO (X,Y,Z), and you are expect to "(x,y,z) <- action" right away
11:17:16 <dwcook> osa1: assertFailure msg = msg `deepseq` E.throwIO (HUnitFailure msg)
11:17:31 <yesthisisuser> What is a more nice way of writing e.g., concatMap (splitOn "[") . splitOn "]"
11:17:37 <osa1> dwcook: where is that part written?
11:17:53 <dwcook> osa1: below. Use your browser search for assertFailure. That's what I did.
11:18:21 <dwcook> osa1: oh, it's in an ifdef.
11:18:34 <ReinH> yesthisisuser: does that typecheck?
11:18:35 <simon____> :t ala
11:18:37 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
11:18:41 <simon____> ReinH, cool!
11:19:15 <yesthisisuser> ReinH: yes, it works but it feels .. clumsy
11:19:22 * quchen just realized "ala" is very similar to Idris' {} notation
11:19:25 <ReinH> :t splitOn
11:19:26 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:19:29 <osa1> so what would happen if I print stuff in my Assertion function? are stdout/stderr somehow suppressed by this HUnit?
11:19:46 <ReinH> :t splitOn "[" . splitOn "]"
11:19:47 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Char’
11:19:47 <lambdabot>     Expected type: [Char] -> [Char]
11:19:47 <lambdabot>       Actual type: [Char] -> [[Char]]
11:19:54 <ReinH> that's what I thought...
11:20:10 <yesthisisuser> :t (splitOn "[") . splitOn "]"
11:20:11 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Char’
11:20:11 <lambdabot>     Expected type: [Char] -> [Char]
11:20:11 <lambdabot>       Actual type: [Char] -> [[Char]]
11:20:27 <yesthisisuser> Wait.. that must be a different "splitOn"
11:20:27 <ReinH> yesthisisuser: those brackets are redundant
11:20:33 <quchen> yesthisisuser: What problem are you trying to solve anyway?
11:20:35 <ReinH> yesthisisuser: ah no I see
11:20:42 <dwcook> @type concatMap (splitOn "[") . splitOn "]"
11:20:43 <lambdabot> [Char] -> [[Char]]
11:20:45 <ReinH> yesthisisuser: it's the concatMap
11:20:46 <dwcook> Typechecks fine
11:20:56 <ReinH> I misread the parens
11:21:06 <quchen> Data.List.Split may have a better alternative to this.
11:21:15 <yesthisisuser> :t concatMap (splitOn "[") . splitOn "]"
11:21:16 <lambdabot> [Char] -> [[Char]]
11:22:50 <quchen> > splitOneOf "[]" "lorem [ipsum] dolor [sit amet]"
11:22:51 <lambdabot>  ["lorem ","ipsum"," dolor ","sit amet",""]
11:23:29 <quchen> yesthisisuser: ^ does that work for you?
11:24:39 <CindyLinz> Hi, all~~ ^^
11:25:17 <CindyLinz> Why Haskell or GHC disallowed us to define a data type inside a function definition?
11:26:09 <yesthisisuser> quchen: yes, that is "it"
11:26:16 <benmachine> CindyLinz: I don't think there is a fundamental reason, but on the other hand it isn't that useful
11:26:21 <magthe> why would hackage refuse to accept a source package generated with `./Setup.hs sdist`?
11:26:43 <benmachine> CindyLinz: I can't think of any circumstances under which it wouldn't be equally good to define the type outside the definition
11:26:56 <dwcook> CindyLinz: if you have a use case for that I'm sure people would be interested in hearing
11:26:58 <monochrom> "cabal sdist" may tell you why
11:27:34 <dwcook> CindyLinz: on the other hand, the hard part to establish would be "there is a use case"
11:27:36 <CindyLinz> Sometimes I'd like to name the fields of my tuples
11:27:40 <quchen> dwcook: A local record type would be a candidate for something like this.
11:27:41 <magthe> monochrom: I don't have cabal installed... hackage says the generated tar-ball is invalid
11:28:10 <CindyLinz> When the same shape of the data appear many times.
11:28:10 <dwcook> quchen: explain?
11:28:33 <quchen> dwcook: Well, suppose you want to use a 3-tuple in a larger function, but give its elements useful names.
11:28:35 <dwcook> CindyLinz: okay – is a module-local type deficient in some way for what you want?
11:28:50 <CindyLinz> dwcook: function local.. XD
11:29:09 <dwcook> quchen: I guess I'd probably write something like usefulName (x, _, _) = x and its two analogs.
11:29:19 <CindyLinz> dwcook: yeah, today I'll move this function into a module alone.. @@"
11:29:28 <dwcook> CindyLinz: Right, I understand you want function-local, but I'm suggesting module-local as an alternative.
11:29:42 <quchen> dwcook: The use cases are sparse, but I've seen a couple. The usual Haskell solution is having a top-level datatype that's only used within one function. Not pretty, but rarely needed.
11:30:08 <CindyLinz> Is it a good practice in Haskell to generate many modules? @@"
11:30:14 <dwcook> Yeah, agreed it might not be optimal. I like to limit the scope of my bindings to where they're needed.
11:30:24 <CindyLinz> One function - one module.. @_@"
11:30:39 <dwcook> CindyLinz: that might be a bit extreme, but it's all right having many modules.
11:31:09 <benmachine> CindyLinz: the trouble is, you can't return your named tuples, or accept them as arguments, because the data type doesn't exist outside the function (or at least, that's how I would imagine it would work)
11:31:09 <dwcook> In my opinion, a module should conceptually "do one thing". However, that is largely up for interpretation.
11:31:33 <CindyLinz> benmachine: Yes. The data type should be opaque outside.
11:31:33 <dwcook> benmachine: sure you can, you can manipulate values of an unexported type
11:31:46 <dwcook> Or, wait
11:31:51 <dwcook> I might be confused
11:31:55 <quchen> (Idris allows local data definitions, by the way.)
11:32:09 <benmachine> dwcook: it's not inconceivable, but you'd have to export the type name even if not the constructors in that case
11:32:21 <benmachine> CindyLinz: well, there just aren't so many functions that need to do that
11:32:28 <monochrom> I sometimes make my field names highly unique or special
11:32:57 <CindyLinz> monochrom: That makes ugly and long names @__@"
11:33:16 <quchen> There is at least one case of such a local data definition in one of the basic Haskell modules, I wish I remembered which one. I think it was effectively a way of giving a Boolean type more suitable names.
11:33:23 * hackagebot sandi 0.3.0 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.0 (MagnusTherning)
11:34:46 <quchen> Ah, here it is, the "Lift" type: http://hackage.haskell.org/package/parallel-3.2.0.4/docs/src/Control-Parallel-Strategies.html#rparWith
11:34:55 <quchen> dwcook: ^
11:35:54 <dwcook> quchen: I don't get it.
11:36:17 <quchen> Neither do I :-þ
11:36:20 <CindyLinz> dwcook: The Lift a is only used in the function rparWith
11:36:29 <dwcook> Ah, I see.
11:37:45 <dwcook> Though I'm curious why it's useful.
11:37:54 <EponymicCycloid> Hahaha
11:37:54 <quchen> Was about to ask that too.
11:38:18 <EponymicCycloid> (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) == (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15) is True
11:38:30 <EponymicCycloid> (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) is not defined
11:38:38 <quchen> Maybe to get proper laziness. The lift data (!) type creates a non-strict container for all "a".
11:38:49 <CindyLinz> When the a is undefined?
11:39:01 <EponymicCycloid> Someone was writing out the prelude, and at 15 elements they said “screw this, I’m done writing tuple comparisons”
11:39:04 <ziggystar> Hi. I'm trying to install the helm game library from github. But when I do `cabal configure` it demands for SDL2 >= 0.1 < 1. When I search Hackage, I only find version >= 1.0.0. I'm a Haskell newb and probably missing something.
11:40:01 <quchen> ziggystar: Helm depends on SDL, not SDL2.
11:40:26 <quchen> At least that's what the Hackage page says.
11:40:35 <ziggystar> It says:
11:40:36 <ziggystar> cabal: At least the following dependencies are missing:
11:40:36 <ziggystar> SDL2 >=0.1 && <1
11:41:17 <ziggystar> Sorry for spamming. I'm not using this client often.
11:42:22 <PhineasRex> What does your cabal file look like?
11:42:24 <CindyLinz> dwcook: There surely exists at least one use case now.. (no matter useful or not) XD
11:42:49 <dwcook> CindyLinz: it's worth searching whether a proposal has been made for it
11:42:56 <quchen> ziggystar: Oh, you checked out Helm from Github. It seems it's broken there. The latest release on Hackage is 0.5, Github has 0.6.
11:42:58 <CindyLinz> mmm
11:43:15 <benzrf> helm?
11:43:21 <ziggystar> Right, I checked out from github. You know how to get the demos over cabal?
11:43:34 <ziggystar> I only cloned github to get the demos folder.
11:44:23 <quchen> ziggystar: The 0.6 cabal file on Github indeed states "SDL2 >= 0.1 && < 1", which seems incorrect.
11:44:37 <quchen> If you just want to get Helm, why not use Cabal to get it from Hackage?
11:44:50 <quchen> (cabal sandbox init && cabal install helm)
11:45:16 <ziggystar> Yeah, I already have 0.5 installed. But I also want the demos. Just checking whether they are new.
11:45:23 <benzrf> whats helm
11:45:41 <ziggystar> Reactive game library based on SDL and cairo graphics.
11:48:05 <CindyLinz> The requested features list is soooo long... /_\ # https://ghc.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&type=feature+request&order=priority
11:48:22 <ziggystar> Ok, looking on Github, the demos were already there for 0.5. Now If I check out some library with cabal, where would I have to look for demo projects?
11:49:46 <spott> I'm having problems installing temporary using cabal, anyone else had this problem?
11:49:51 <CindyLinz> Most of them are marked _|_ on milestone... XD
11:50:22 <Industrial> Is there a website to search cabal packages like http://eirikb.github.io/nipster/ for nodejs? (it sorts on popularity)
11:50:36 <quchen> ziggystar: The Hackage version might not include the demo files.
11:50:48 <quchen> ziggystar: There is a release tag in the Helm repo though: https://github.com/switchface/helm/releases/tag/v0.5.0
11:51:17 <quchen> So just clone Helm, checkout that tag, and proceed from there.
11:51:23 <quchen> (0.6 seems to be WIP.)
11:51:37 <ziggystar> That's a good idea. Thank you.
11:58:11 <benzrf> > undefined :: Void
11:58:12 <lambdabot>  Not in scope: type constructor or class ‘Void’
11:58:18 <benzrf> @data Void
11:58:18 <lambdabot> Unknown command, try @list
11:58:22 <benzrf> @let data Void
11:58:24 <lambdabot>  Defined.
11:58:27 <benzrf> > undefined :: Void
11:58:28 <lambdabot>  No instance for (GHC.Show.Show L.Void)
11:58:28 <lambdabot>    arising from a use of ‘M146656969861988956927101.show_M1466569698619889569...
11:58:47 <benzrf> @let data Void deriving (Show, Eq)
11:58:48 <lambdabot>  .L.hs:152:1:
11:58:48 <lambdabot>      Multiple declarations of ‘Void’
11:58:48 <lambdabot>      Declared at: .L.hs:150:1
11:58:48 <lambdabot>                   .L.hs:152:1
11:58:55 <benzrf> meh
11:58:58 <ajf> OH BOY
11:59:00 <ajf> NET SPLITS
11:59:02 <benzrf> @unlet Void
11:59:02 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:59:05 <benzrf> o_O
11:59:07 <benzrf> @unlet data Void
11:59:08 <lambdabot>  .L.hs:152:1:
11:59:08 <lambdabot>      Multiple declarations of ‘Void’
11:59:08 <lambdabot>      Declared at: .L.hs:150:1
11:59:08 <lambdabot>                   .L.hs:152:1
11:59:11 <benzrf> whoa
11:59:12 <ajf> I JUST LOVE HEARING COLLOQUY’S “DOOR CLOSE” SOUND REPEATED
11:59:13 <quchen> @undef
11:59:13 <lambdabot> Undefined.
11:59:43 <spott> how do I get cabal to install temporary (which everything I want to install seems to depend on)?
11:59:56 <quchen> "cabal install temporary"
12:00:32 <monochrom> ajf: are you alright?
12:01:18 <spott> quchen: tried that... I get a failure
12:01:18 <ajf> Yes :P
12:01:27 <spott> https://gist.github.com/spott/2b5579ce05144b5978c6
12:03:11 <spott> I don't think I have successfully installed ANYTHING with cabal
12:15:58 <spott> can someone walk me through how I should be dealing with cabal?  indiscriminately installing things with "cabal install" is failing me
12:16:34 <spott> I've completely removed haskell off my machine, how should I install it, and use cabal so that things don't fail miserably
12:18:12 <pavonia> spott: The recommended way is to install the Haskell Platform, I think
12:18:27 <Saizan> spott: temporary is currently broken wrt the new exceptions version, iiuc
12:18:38 <spott> pavonia: from brew (I'm on a mac), or online?
12:18:59 <spott> Saizan: so everything that depends on temporary just won't install?
12:19:03 <pavonia> Uh, I don't knoe about Mac
12:19:08 <spott> isn't this what versioning is for?
12:19:21 <Saizan> spott: try with --constraint="exceptions < 0.6"
12:19:46 <Saizan> spott: it is, but cabal relies on the info people put in the .cabal files, and the one for temporary is not precise enough
12:20:14 <spott> Saizan: thank you, i'll try that, when I reinstall haskell platform
12:20:35 <spott> Saizan: that is frustrating
12:23:28 <Saizan> spott: yeah, it sucks, when it comes to upper bounds there's a tension between pessimism and hopeful agnosticism, the latter hopes to minimize the number of releases that just deal with relaxing constraints
12:23:56 <Saizan> but will break horribly if the dependency changes enough
12:25:25 <spott> Saizan: what is preventing automatic checking of APIs?
12:25:47 <Lemmih> I'm looking for libraries that would make good benchmarks.
12:25:53 <Lemmih> http://www.reddit.com/r/haskell/comments/258695/benchmarking_haskell_compilers/
12:26:03 <Saizan> spott: you mean like in autotools?
12:26:32 <Lemmih> If anyone has any suggestions, feel free to pm me.
12:27:33 <Saizan> spott: otherwise there is a project that's about specifying interfaces for packages etc.. called backpack, it's fairly recent but should help with this
12:27:52 <spott> I guess what I figured was that there is an API to some library: the functions and their type signatures
12:28:11 <spott> and then when a library updates, its type signatures, or its functions should change
12:28:30 * hackagebot th-alpha 0.1.0.0 - Alpha equivalence for TH Dec and Exp  http://hackage.haskell.org/package/th-alpha-0.1.0.0 (jkarni)
12:28:59 <Saizan> spott: the question is mostly how much change the dependent package can tolerate
12:30:19 <Saizan> i guess you could go and preemptively try to compile packages against new versions and discover they won't match, but noone went there, I'd fear some combinatorial explosion myself, but maybe it can be tamed
12:30:52 <spott> or just look at the source, and compile a list of all functions called by the package
12:31:00 <spott> then check that against changed type signatures
12:31:56 <Saizan> there i think you easily bump into undecidability walls wrt type inference, but again icbw
12:32:19 <spott> icbw?
12:32:25 <Saizan> i could be wrong
12:35:36 <monochrom> IANACT = I am not a computability theorist :)
12:35:52 <spott> backpack looks like what I was thinking about... only I figured interfaces could be figured out automatically
12:37:29 <Saizan> maybe we should ask dreyer :)
12:38:07 <spott> who is that?
12:39:30 <spott> nevermind, he is on the paper
12:51:29 <Kaidelong> what's the convention for a module that contains implementation details not intended to be exposed to the application programmer, only extenders of the library?
12:51:33 <Kaidelong> Foo.Bar.Core?
12:52:38 <fryguybob> Kaidelong: Foo.Bar.Internal is also common.
12:54:02 <deni> when doing a new data type using record syntax can't the parameters have first capital letters?
12:55:00 <deni> i'm asking cause I'm trying to use generics to generate my fromJson and toJson types but the json i'm trying to parse has keys starting with capital letters
13:00:01 <Hafydd> deni: they cannot.
13:00:46 <deni> Hafydd: so i can't have this: http://pastebin.com/iHx3yf4a but with first capital letters for "Version" and so on?
13:01:11 <Hafydd> deni: correct. Capitalised identifier names are reserved for constructors.
13:01:21 <deni> Hafydd: indeed.
13:02:32 <deni> Hafydd: any ideas how can I leverage what Generics or TH do for parsing json or am i doomed to writing my own toJson and fromJson functions just because the json has keys that start with a capital letter?
13:02:41 <deni> * a starting capital letter
13:03:16 <Hafydd> deni: no, but I'm not overly familiar with Generics or TH.
13:03:37 * hackagebot hmemdb 0.4.0.0 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.4.0.0 (MiguelMitrofanov)
13:08:03 <deni> oh man this is a stupid problem to have :D
13:15:43 <Kaidelong> https://github.com/barendventer/netwire-glfw-b/blob/master/src/Graphics/UI/GLFW/Netwire/Window/Core.hs I'm a little bit scared of this
13:19:00 <awestroke> focusedWindowRef = unsafePerformIO $ newIORef Nothing <--- is that frowned upon or an accepted way to write haskell?
13:19:12 <Kaidelong> it's the unsafePerformIO trick
13:19:19 <Kaidelong> it's controversial
13:19:42 <dwcook> awestroke: it's reasonably acceptable if slightly dubious.
13:19:45 <Kaidelong> for my purposes it seems appropriate since after this subsystem gets initialized there will be a global variable pointing to the window currently focused, if there is one
13:19:53 <awestroke> an there's the pragma that refers to the wrong function just above too
13:20:05 <Kaidelong> ah, thanks for catching that
13:20:31 <awestroke> I've though about doing exactly that in my current project though ;)
13:20:52 <awestroke> but I went with initializing a reader object full of IOrefs in the beginning of main
13:25:36 <rhaps0dy> Hello
13:25:41 <l0cust> rhaps0dy: hi
13:26:07 <rhaps0dy> l0cust: do you know about SmartOS and Haskell
13:26:09 <rhaps0dy> ?
13:26:22 <l0cust> rhaps0dy: never heard of smartos, so I'm guessing no
13:26:25 <rhaps0dy> I'm trying to install cabal and dependencies on a SmartOS machine and I can't
13:26:27 <rhaps0dy> :C
13:26:29 <rhaps0dy> thank you
13:26:35 <l0cust> rhaps0dy: I do know a little bit about Haskell tho
13:27:04 <rhaps0dy> maybe you know what cabal uses ld for?
13:27:26 <rhaps0dy> because it gives an error about permission denied on /usr/bin/ld
13:27:34 <rhaps0dy> maybe because /usr/bin is read-only ?
13:27:48 <rhaps0dy> l0cust: I'm still a Haskell newbie but working to be better
13:27:51 <rhaps0dy> so far it's amazing
13:28:01 <l0cust> rhaps0dy: it is a wonderful language
13:28:08 <rhaps0dy> I know right?
13:28:17 <l0cust> rhaps0dy: well, running pacman -Qo, ld is owned by binutils
13:28:24 <rhaps0dy> only thing I don't like is the huge size of the compiler
13:28:28 <rhaps0dy> l0cust: y-yeah
13:28:33 <rhaps0dy> binutils is a basic package
13:28:43 <l0cust> rhaps0dy: well, it exists to build binaries
13:28:47 <rhaps0dy> I'll ask in smartos too
13:28:53 <l0cust> rhaps0dy: so I would guess it's pretty essential
13:28:54 <rhaps0dy> l0cust: but nobody takes built binaries nowadays
13:28:59 <rhaps0dy> they all like the source
13:29:07 <rhaps0dy> but it's a non-issue really
13:29:21 <l0cust> rhaps0dy: Good point, but developers like it - and to compile Haskell code, ,you need to be able to compile binaries
13:29:37 <l0cust> rhaps0dy: what is SmartOS like?
13:29:38 <rhaps0dy> it's expected to be like this, all the static analysis and laziness and lots of things I don't know about
13:29:44 <solidus-river> how do you type a read that you arent assigning to a value
13:29:51 <l0cust> solidus-river: what?
13:29:52 <solidus-river> in a gaurd expression i want a guard to be
13:29:54 <rhaps0dy> l0cust: depends
13:30:04 <l0cust> rhaps0dy: on what?
13:30:11 <rhaps0dy> on what you need it for
13:31:22 <rhaps0dy> it's a bit crappy for compatibility with things
13:31:22 <rhaps0dy> but good to have many users
13:31:22 <rhaps0dy> and for data
13:31:22 <rhaps0dy> ZFS and zones mang
13:31:22 <rhaps0dy> I'll ask on #smartos too
13:31:23 <l0cust> rhaps0dy: well, I'm an Arch user, and I love Arch (I assume you've heard of it), so that might give you a basic idea of what my needs are
13:33:39 <solidus-river> (String a) => read -> a -> Maybe Int
13:33:39 <solidus-river> read a :: Int?
13:33:39 <solidus-river> is that valid
13:33:39 <solidus-river> without the questionmark
13:34:11 <dwcook> solidus-river: read a is a type constructor applied to a type, not a value
13:34:12 <rhaps0dy> l0cust: I used to run ARch
13:34:12 <rhaps0dy> until it broke my ZFS
13:34:12 <rhaps0dy> then I switched to FreeBSD
13:34:12 <rhaps0dy> and then to Funtoo
13:34:12 <rhaps0dy> I'm quite the distro-hopper it seems ;_;
13:34:12 <rhaps0dy> SmartOS is not for the desktop
13:34:12 <solidus-river> :t read Int
13:34:12 <dwcook> solidus-river: at least in the context of what you gave
13:34:12 <solidus-river> :t read
13:34:12 <lambdabot>     Not in scope: data constructor ‘Int’
13:34:12 <lambdabot>     Perhaps you meant one of these:
13:34:12 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
13:34:12 <lambdabot> Read a => String -> a
13:34:12 <dwcook> In Prelude it's indeed a value
13:34:13 <dwcook> solidus-river: so the real question is what are you trying to express?
13:34:13 <solidus-river> dwcook: i have a string that is either a number or a name
13:35:01 <Tommyvc> Can anyone lend me a hand?
13:35:02 <solidus-river> comes from config structure
13:35:02 <solidus-river> if its a number i want to do one thing
13:35:02 <solidus-river> if its a name i want to do another
13:35:02 <solidus-river> i thought you could use read on a String to contstruct a value
13:35:15 <dwcook> solidus-river: actually sorry, something I told you was wrong, because I was confused about something you seemed to be confused about. :P Let's start over from what you just said.
13:35:18 <dwcook> solidus-river: so you want to be able to read either a numerical value or a string value?
13:35:35 <Tommyvc> Can anyone help me make this case insentitive:
13:35:41 <Tommyvc>     import qualified Data.Map as M     import Data.List     import           Data.CaseInsensitive  ( CI )          hist :: String -> M.Map String Int     hist = foldl' (\m word  -> M.insertWith (+) word 1 m) M.empty . words
13:35:57 <dwcook> solidus-river: well one thing you could do is try to read an Int and if that fails, it's a String. You'd end up with an Either String Int.
13:36:39 <dwcook> case readMaybe data :: Int of Nothing -> Left data ; Just n -> Right n
13:36:40 <Tommyvc> @where ops
13:36:40 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:36:42 <awestroke> Tommyvc: please use http://lpaste.net/new/haskell to paste code
13:36:51 <Tommyvc> Will do, ty
13:36:54 <dwcook> Tommyvc: that's for emergencies, not getting help with a problem.
13:36:58 <monochrom> how may I help you?
13:37:02 <awestroke> dwcook: ?
13:37:08 <awestroke> dwcook: ah ok
13:37:17 <Tommyvc> Oh, if I can't use lpaste for getting help where should I go?
13:37:30 <monochrom> you can use lpaste for getting help
13:37:30 <dwcook> Tommyvc: no, I was referring to your use of @where ops
13:37:30 <awestroke> Tommyvc: he meant "@where ops", not lpaste
13:37:43 <Tommyvc> Oh!
13:38:31 <dwcook> solidus-river: sorry, I misparened the above
13:38:37 <Tommyvc> If anyone is able to help I'd appreciate it, but I'm not sure how easy the solution is. I found this helpful script on reddit and I'm trying to improve it to be case insensitive - http://lpaste.net/7365891401088761856
13:38:42 <dwcook> or rather missed a constructor
13:38:46 <dwcook> case readMaybe data :: Maybe Int of Nothing -> Left data ; Just n -> Right n
13:39:39 <monochrom> Tommyvc: hist :: CI String -> M.Map (CI String) Int. or at least, hist :: String -> M.Map (CI String) Int
13:40:09 <monochrom> and if you choose the latter, the code inside hist has to be editted as well
13:40:16 <Tommyvc> Ok 1 min I'll try that, thanks @monochrom
13:40:35 <solidus-river> dwcook: aye, sorry, this whole mess made me think its time to restructure how i'm pulling in this config stuff, trying to move it to a filter / fold on a list to screen out each type before i get into the IO mess
13:40:39 <monochrom> if you choose the former, the caller has to be editted
13:43:21 <Tommyvc> @monochrom I replaced it with hist :: CI String -> M.Map (CI String) Int and it threw an error
13:43:21 <lambdabot> Unknown command, try @list
13:43:54 <Tommyvc> @monochron Like this? http://lpaste.net/7365891401088761856
13:43:54 <lambdabot> Unknown command, try @list
13:44:01 <monochrom> yes, there are more changes necessary
13:44:12 <Tommyvc> Any pointers?
13:44:19 <wojtekM_> Is it possible to ignore multiple arguments in a match?
13:44:24 <Tommyvc> I'm quite new to Haskell but keen to pick it up and improve this script
13:44:32 <deni> apparently deriveJson takes a function to change field names. would that work for my issue with json keys having first capital letters?
13:44:46 <dwcook> wojtekM_: a parameter you don't care about can be matched with _, which doesn't bind any variables
13:45:01 <monochrom> I guess it should be String -> M.Map (CI String) Int after all
13:45:04 <deni> this i mean: http://hackage.haskell.org/package/aeson-0.3.2.12/docs/Data-Aeson-TH.html#v:deriveJSON
13:45:23 <wojtekM_> dwcook: Yes, but is there something like __ meaning ignore all the following?
13:45:44 <wojtekM_> dwcook: I do not want _ _ _ _
13:45:45 <dwcook> wojtekM_: can you show an example?
13:45:46 <Tommyvc> monochrom, any pointers on what to do next?
13:46:07 <Tommyvc> Currently looks like this http://lpaste.net/7365891401088761856
13:46:09 <monochrom> hist = foldl' (\m word -> M.insertWith (+) (mk word) 1 m) M.empty . words
13:46:20 <monochrom> mk comes from Data.CaseInsensitive
13:46:22 <dwcook> wojtekM_: well all your clauses have to have the same number of parameters, but other than that you can choose whatever number you like, as long as the thing on the right side is the right type.
13:46:32 <wojtekM_> dwcook: (Want __) instead of (Want _ _ _ _ _ _)
13:46:45 <Tommyvc> monochrom: that still throws an error
13:46:46 <pavonia> wojtekM_: use (Want {})
13:47:01 <Tommyvc> Looks like this now http://lpaste.net/7365891401088761856
13:47:03 <dwcook> wojtekM_: no, show me an example function where you want that. Try writing it with bunches of _ if necessary.
13:47:51 <monochrom> eh? where is the "Int"?
13:48:19 <monochrom> (which is exactly what the error message says)
13:48:41 <Tommyvc> Got it working, thanks monochrom
13:48:45 <wojtekM_> pavonia: Yeah! Thanks.
13:49:47 <Tommyvc> monochrom: Thanks for the help :)
13:49:56 <monochrom> you're welcome
14:01:03 <enthropy> if I have a GADT constructor that wants evidence that  x ~ [t1, t2], is there a way to provide this evidence with a `class T x'?
14:02:24 <deni> wow every single example on the internet doesn't cover this edge case. :(
14:02:38 <deni> anyone have the time to point me in the right direction here?
14:04:00 <pavonia> deni: What are you looking for?
14:05:29 <benmachine> deni: I don't know about your specific problem, but you may find the GHC option -ddump-splices helpful
14:06:31 <rhaps0dy> so, guys
14:06:33 <rhaps0dy> haskell newbie here
14:06:34 <benmachine> deni: it does look like it will help you do what you want
14:06:38 <deni> pavonia: i'm trying to use generics or TH to parse json but the json has keys with first capital letters and haskell's record style sytnax doesn't allow that
14:06:42 <rhaps0dy> I just got linked to this page http://codecha.org/
14:06:52 <rhaps0dy> and am trying to find error on this one function
14:06:59 <benmachine> deni: e.g. with ucFirst "" = ""; ucFirst (x:xs) = toUpper x : xs
14:07:32 <deni> benmachine: yeah i have a capitalize function that's not the issue :)
14:07:49 <deni> i'm having trouble using generics or TH to generate a parsers for my json
14:08:00 <benmachine> deni: so, you're having a problem using deriveJSON?
14:08:06 <deni> benmachine: yes
14:08:14 <macron> enthropy: I'm not sure I understand your question. But you can add the equality constraint in the type of any function that invokes the constructor in question.
14:08:15 <rhaps0dy> Anyone knows what's wrong with this? http://hastebin.com/zamoyohego.pas
14:08:46 <deni> benmachine: not cusre what -ddump-splices does....looking it up
14:09:00 <enthropy> macron: http://lpaste.net/103941
14:09:22 <rhaps0dy> oh duh
14:09:24 <rhaps0dy> nevermind
14:09:32 <benmachine> deni: basically when using TH it will show you the generated code
14:09:51 <enthropy> macron: my question is about whether I can somehow push that equality constraint into a class
14:10:04 <Baughn> What's the state of the art in maintaining application state? Anything much nicer than manually keeping track and de/serializing state to be had?
14:10:39 <Baughn> Not quite sure what I'm asking for, honestly.. I have a lot of vague ideas involving template haskell and/or STM
14:11:01 <deni> benmachine: i know what the issue is...the generated code will have lower case first letter as i've defined in the new data type's record syntax
14:11:08 <jmcarthur> Baughn: so by maintaining do you mean persisting?
14:11:20 <deni> benmachine: i'm trying to get deriveJson to capitalize that but am failing
14:11:23 <Baughn> Yes
14:11:35 <benmachine> Baughn: hackage 2 uses acid-state
14:11:37 <jmcarthur> Baughn: what is the nature of this state. will you typically read the whole thing in at once?
14:11:44 <benmachine> http://hackage.haskell.org/package/acid-state
14:11:54 <jmcarthur> Baughn: if you do, i was going to recommend acid-state as benmachine already has
14:12:13 <Baughn> Whole thing at once, yes.
14:12:19 <Baughn> Thanks for the pointer. I'll have a look. :)
14:12:42 <deni> benmachine: do you have an example where deriveJSON is used this way?
14:12:47 <benmachine> deni: nope
14:12:49 <jmcarthur> Baughn: see also safecopy
14:12:54 <benmachine> deni: but what have you tried?
14:13:08 <benmachine> deni: what's wrong with the examples in the docs?
14:13:17 <jmcarthur> Baughn: it's meant to accompany acid-state for when you might have to do some sort of migrations
14:13:29 <jmcarthur> Baughn: versioning, etc.
14:13:36 <macron> enthropy: I believe it can. Equality constraints are constraints like any other, so can appear as super class constraints. However, you'll have to bring t1, t2, t3 in scope in the class definition, by making them extra parmaters to PInv.
14:13:48 <Baughn> jmcarthur: Right at the moment, state consists of a single set. :P
14:13:59 <Baughn> jmcarthur: Plus the contents of four directories, but that's a different matter.
14:14:11 <jmcarthur> Baughn: well, what i mean is that this makes it easy to make changes
14:14:29 <jmcarthur> Baughn: the fact that you know what your type is right now is not relevant to this ;)
14:14:45 <deni> benmachine: i've tried this: $(deriveJSON defaultOptions ''MyDataType) which fails because the generated code has lower case first letters for keys
14:14:51 <deni> nothing get's parsed
14:15:10 <Baughn> jmcarthur: My point is, this is very close to a toy app and I barely need to care about such things. :)
14:15:25 <deni> benmachine: i've tried replacing defaultOption with a function because that's what i read from the docs (String -> String) but that didn't work
14:15:40 <benmachine> deni: ok so the version of the docs you linked to is seriously old
14:15:43 <deni> benmachine: a function to upperCase like to wrote up there i mean
14:15:53 <benmachine> deni: this is a problem that google often has, sadly, it doesn't link to the latest version
14:16:01 <benmachine> deni: http://hackage.haskell.org/package/aeson-0.7.0.3/docs/Data-Aeson-TH.html here's 0.7.0.3
14:16:11 <benmachine> deni: is that example more helpful?
14:16:20 <solidus-river> i'm confused
14:16:22 <benmachine> see the use of fieldLabelModifier
14:16:23 <jmcarthur> Baughn: got it. just making sure you're aware
14:16:29 <enthropy> macron: you're saying there's no way to do it without having to mention t1 t2 t3 in the type of inv?
14:16:33 <solidus-river> why would f $ g x
14:16:39 <solidus-river> ever be valid when f . g x is invalid
14:16:57 <jmcarthur> > succ $ succ 5
14:16:59 <lambdabot>  7
14:17:00 <jmcarthur> > succ . succ 5
14:17:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:17:01 <lambdabot>    arising from a use of ‘M617013262570944723128703.show_M6170132625709447231...
14:17:01 <lambdabot>  The type variable ‘a0’ is ambiguous
14:17:01 <lambdabot>  Note: there are several potential instances:
14:17:01 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
14:17:01 <solidus-river> ooh, maybe i need (f . g) x
14:17:07 <jmcarthur> > (succ . succ) 5
14:17:09 <lambdabot>  7
14:17:13 <Baughn> jmcarthur: Well, it's nice to know I have the option.
14:17:44 <orzo> > succ maxBound
14:17:45 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
14:17:46 <napping> solidus-river: f . g x == \y -> f (g x y)
14:17:51 <napping> f $ g x = f (g x)
14:17:57 <deni> benmachine: wow i really missed that completely....freaking google. gonna search directly on hackage from now on. lookin at the docs now.
14:18:06 <napping> or, \y -> f (g x) y if f can take another argument
14:18:21 <rhaps0dy> solidus-river: or f . g $ x
14:18:22 <rhaps0dy> works too
14:18:30 <benmachine> deni: I didn't notice the first three times I looked at it, only checked because you gave an example with defaultOptions and I thought, hmm, that doesn't sound like a function :)
14:18:32 <rhaps0dy> you need to de-prioritise the function application
14:18:40 <rhaps0dy> f . g x is the same as f . (g x)
14:19:00 <deni> benmachine: yeah....the new docs make much more sense :D
14:19:57 <macron> enthropy: well, you could define instance PInv a (t1, [t2, t3]) I guess, but that depends on what PInv means.
14:20:25 <enthropy> that doesn't work
14:20:27 <mm_freak_> hi there
14:20:51 <mm_freak_> does anyone know why alsa-pcm doesn't implement a Handle interface?
14:20:52 <enthropy> constraints on the instance don't turn into superclass constraints
14:21:17 <macron> enthropy: are what you trying to say is that b is always of the form (t1, [t2, t3])?
14:21:48 <enthropy> if anything, I would expect    instance ( b ~ (t1, [t2, t3]) ) => PInv a b -- to let ghc invent that superclass constraint
14:21:58 <enthropy> macron: yes b always has that form
14:22:30 <enthropy> err, with a leading quote
14:22:30 <macron> enthropy: I see, so then you're trying to express something a bit different.
14:22:39 <macron> enthropy: I agree the above won't work.
14:22:51 <macron> enthropy: you'll need UndecidableInstances
14:22:53 <napping> enthropy: those two constraints behave pretty differently
14:23:04 <napping> What are you trying to do?
14:23:12 <enthropy> napping: http://lpaste.net/103941
14:27:00 <felixn> hey there, after checking out rust, the programmer can inline testing in the source, which is awesome...  are there anyways I can do this in haskell?
14:27:20 <enthropy> felixn: there is a doctest-haskell
14:27:35 <enthropy> @hackage doctest
14:27:35 <lambdabot> http://hackage.haskell.org/package/doctest
14:27:40 <felixn> off by one errors are really easy to make, so making test super simple for testing these things is awesome, plus it prevents code from compiling
14:27:53 <felixn> which is*
14:28:24 <enthropy> there is no requirement for doctests to be run (or to pass), so maybe it's a bit less disciplined
14:28:48 * hackagebot Spock 0.4.4.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.4.0 (AlexanderThiemann)
14:29:14 <napping> enthropy: I don't see what that constraint is for, but if it's supposed to hold for every instance of PInv then adding it to the context in the class definition looks right
14:29:17 <felixn> no worries, the idea of inline tests is still very compelling to me
14:31:39 <mm_freak_> felixn: you can always just couple the tests with the implementation
14:32:24 <mm_freak_> just like everything else tests are regular values, and defining them elsewhere is just a convention
14:32:36 <enthropy> https://github.com/pseudonom/phantheck is possibly closer to what rust does?
14:32:40 --- mode: leguin.freenode.net set +o ChanServ
14:33:08 <felixn> mm_freak_: how do you mean?
14:33:22 <b0bbi10> hi, in Haskell Fast & Hard, it says " I'll say <error msg> will simply take the needed type (here IO ())." as IO a
14:33:30 <b0bbi10> but the type of error is [Char] -> a
14:33:40 <b0bbi10> what does the author mean by that?
14:33:42 <enthropy> napping: the constraint is for making code that pattern matches on DMat more convenient
14:33:53 <mm_freak_> felixn: i don't know exactly what rust does, but haskell doesn't place any constraints on where to put tests
14:34:09 <mm_freak_> felixn: you can do something as crazy as this:
14:34:12 <felixn> mm_freak_: yayaya
14:34:15 <felixn> mm_freak_: show me crazy
14:34:27 <mm_freak_> type Testable a = (a, Property)
14:34:29 <felixn> mm_freak_: not sure what you meant by "couple the tests with the implementation"
14:34:32 <tremon> b0bbi10: afaiu, the a in that defition is undefined which means that it typechecks against every type. [Char] aka String is error's single parameter
14:34:47 <mm_freak_> (myFunc, myFuncTest) :: Testable (Int -> Double)
14:34:54 <mm_freak_> (myFunc, myFuncTest) = …
14:35:44 <shachaf> b0bbi10: error returns a value of any type you'd like.
14:35:51 <b0bbi10> tremon: does it mean the a can be any type? what is its real type in that case then?
14:35:56 <b0bbi10> "IO ()"?
14:35:58 <mm_freak_> then some template haskell (like in test-framework or tasty) can collect all tests into a single Property
14:36:03 <b0bbi10> shachaf: ah ok
14:36:05 <b0bbi10> thanks
14:36:06 <deni> benmachine: ok finally got it working...just replaced the fieldLabelModifier from id to my toUpper function and it worked
14:36:06 <shachaf> In GHC we'd write the type as error :: forall a. String -> a
14:36:21 <shachaf> Which means you can choose what a is. If you choose a=IO (), then error :: String -> IO ()
14:36:29 <tremon> b0bbi10: there is no "real type" as error does not return to the calling site
14:36:31 <shachaf> If you choose a=Int, then error :: String -> Int
14:37:12 <b0bbi10> ok, thanks you two
14:37:16 <mm_freak_> felixn: oh, and flip the order:  type Testable a = (Property, a)
14:37:31 <mm_freak_> then Testable is a functor, comonad, etc…  all the usual things that you might want
14:37:44 <napping> felixn: Did anyone mention cabal has a target for running tests?
14:38:13 <mm_freak_> napping: i believe this is about a coding style where tests are closely coupled with the implementation
14:38:30 <napping> Sure, there's nothing quite like that
14:38:47 <mm_freak_> cabal really only helps in /executing/ the tests
14:38:48 <tremon> b0bbi10: to be complete, a is a type variable (a placeholder). The compiler is free to fill in any type that makes sense
14:38:55 <felixn> mm_freak_: I think I get it, will ghc remove it from the binary since it does nothing as well?  after it compiles?
14:39:25 <napping> but if there's any interest in how easy you can make it to run tests.
14:39:26 <felixn> napping: nope!
14:39:28 <mm_freak_> felixn: if you compile it such that the tests aren't referenced in the production binary, then yes
14:39:28 <b0bbi10> tremon: I see
14:39:48 <felixn> mm_freak_: so rad, I'll give that a try
14:40:14 <napping> felixn: If you're looking for nice ways to include evidence, dependent types are worth a look
14:40:18 <mm_freak_> felixn: in libraries the tests will remain though
14:40:30 <napping> http://pozorvlak.livejournal.com/162233.html
14:40:33 <felixn> mm_freak_: eh?  what if I don't export?
14:40:53 <mm_freak_> felixn: you need to export the tests somehow, otherwise there is no way to run them
14:41:06 <felixn> mm_freak_: they're ran on compilation ?
14:41:27 <mm_freak_> felixn: nope, you will need a separate executable for the tests
14:41:40 <mm_freak_> some template haskell magic could do that, but there is nothing like that i know of
14:41:47 <felixn> napping: I've peaked at idris, but testing will always be needed for logic errors, like off by one
14:41:56 <napping> felixn: check out the link
14:42:03 <felixn> livejournal!?
14:42:11 <mm_freak_> felixn: off by one errors are best captured via types
14:42:13 <napping> yeah, whatever
14:42:21 <napping> decent little note anyway
14:42:42 <napping> If anything, it's interaction with the environment that may need tests
14:42:44 <felixn> mm_freak_: no way, u cray
14:43:06 <napping> Actually requesting particular test cases to be evaluated at compile time is super easy with dependent types
14:43:52 <mm_freak_> felixn: in a sufficiently expressive language everything can be captured in types…  haskell is not quite that language, but length information is easy to capture in types
14:44:01 <mm_freak_> so off-by-one errors become type errors
14:44:30 <deni> if i have something that is IO (Maybe MyDataType) and I have a function that only works on MyDataType how to I apply it to the former?
14:44:36 <felixn> napping: hmmmm, can idris do something similar?  I may have to check this out more before fully understanding it
14:44:40 <napping> felixn: In something like Idris you could of course write proofs that your functions behave correctly in various ways
14:44:48 <deni> that's some kind of double bind or something
14:44:52 <napping> felixn: but if you just what to check that "foo x y z == w" for some concrete arguments
14:45:05 <mm_freak_> deni: fmap :: (MyType -> A) -> (Maybe MyType -> Maybe A)
14:45:08 <napping> then the proof can be just "refl" -- "dude, these are the same thing"
14:45:28 <napping> So it's exactly like evaluating a fixed set of test cases
14:45:38 <napping> or one particular test case, rather
14:45:39 <mm_freak_> deni: fmap :: (Maybe MyType -> Maybe A) -> (IO (Maybe MyType) -> IO (Maybe A))
14:45:49 <mm_freak_> deni: in other words:  fmap (fmap f)
14:46:14 <napping> napping: don't even need to use dependent types at all inside the functions you want to "test" for this approach to work
14:46:18 <deni> mm_freak_: double fmap..nice. tnx
14:47:33 <deni> wow but this is getting unwieldy pretty fast...not sure if I'm going something wrong if this is the way i need to parse the data
14:48:23 <no-n> what would be a good data structure for representing a board in the board game Go?
14:48:24 <mm_freak_> deni: you will eventually learn all the combinators and types that make this pretty transparent, but for now go with the "unwieldy" and figure out why it isn't actually so bad =)
14:48:35 <napping> felixn: "cabal install --run-tests" is probably the most automatic way to run tests on builds
14:48:43 <mm_freak_> no-n: V2 Int -> Maybe Stone
14:48:49 <napping> Not sure if you can set that as a default somewhere
14:48:59 <no-n> mm_freak_: what's the V2?
14:49:08 <Baughn> 2D vector
14:49:20 <no-n> ahh
14:49:22 <no-n> thanks
14:49:27 <mm_freak_> no-n: it's from the 'linear' library
14:49:27 <Baughn> ..which sounds to me like an array, but oh well. :P
14:49:27 <no-n> @hoogle V2
14:49:28 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays V2f :: InterleavedArrays
14:49:28 <lambdabot> package bindings-linux-videodev2
14:49:28 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays C4ubV2f :: InterleavedArrays
14:49:35 <no-n> okay
14:49:52 <mm_freak_> no-n: you may also want to choose something more precise than Int
14:50:11 <no-n> not sure what you mean by precise
14:50:22 <mm_freak_> no-n: 30000 :: Int
14:50:33 <mm_freak_> but i doubt that you will ever play on a board that is that large =)
14:50:34 <no-n> "something more precies than float would have made sense to me
14:50:50 <no-n> lol, ahh
14:50:53 <mm_freak_> "precise" in the sense that it reflects actually possible coordinates on the board
14:50:59 <no-n> yeah
14:51:23 <mm_freak_> type Board a = V2 Int -> a
14:51:31 <no-n> we won't be using boards that large :P
14:51:46 <no-n> cool
14:51:56 <deni> mm_freak_: is it bad that a function from a library returns a type like that? meaning the user of the library needs to figure out how to deal with it? or should the library perhaps return something better and easier to manage?
14:52:17 <mm_freak_> no-n: for the underlying representation you can use anything you want really…  just start with something you're comfortable with…  later you can switch to a more efficient representation without changing the interface
14:52:39 <no-n> mm_freak_: indeed :)
14:53:05 <mm_freak_> deni: not sure what you mean
14:54:56 <mm_freak_> deni: the convention is to expose the simplest interface and let algebraic magic perform all the lifting
14:55:18 <mm_freak_> for example if you give me an A -> B and i have a Maybe A, i'll know how to lift it to a Maybe A -> Maybe B
14:55:51 <mm_freak_> and i would prefer if you don't prelift it for me =)
14:56:07 <mm_freak_> even if you expect that pretty much always i'll be dealing with a Maybe A
14:58:12 <felixn> mm_freak_: napping: hey thanks for they information, I'm going to do some experimenting with these ideas
14:59:03 <deni> mm_freak_: ok that's exactly what i needed to know. no prelifting then
15:00:15 <enthropy> mm_freak_: do you use template haskell?
15:00:39 <enthropy> the library for that has everything with liftM3 or whatever pre-applied
15:00:43 <enthropy> it is rather convenient
15:01:14 <mm_freak_> enthropy: i don't write TH code, if that's what you're asking
15:01:37 <mm_freak_> my exposure to TH is pretty much limited to deriveSafeCopy and makeAcidic
15:01:46 <mm_freak_> and in some rare cases makeLenses
15:02:39 <mm_freak_> enthropy: for TH it may make sense, but for regular APIs it doesn't really
15:02:58 <mm_freak_> for example if you give me an IO-lifted version of A -> B, what if i have an A instead of an IO A?
15:04:39 <enthropy> then everything goes into IO a bit earlier
15:05:47 <mm_freak_> enthropy: it would be frustrating to have to turn my pure code into IO code just because a library author thought that it would be a good idea to prelift
15:06:15 <enthropy> sure
15:14:13 <no-n> ,("C compiler flags"," -m32 -fno-stack-protector  -m32") <- I saw this line in my ghc --info. wouldn't -fno-stack-protector be a bad thing?
15:15:03 <donncha_> I've no idea, I'm a n00b
15:15:31 <rhaps0dy> no-n: not really
15:15:46 <rhaps0dy> because the stack protector sometimes puts bugs
15:15:54 <rhaps0dy> and it's not that important
15:18:07 <no-n> rhaps0dy: when would it be important?
15:19:16 <rhaps0dy> when security is very important or never
15:19:24 <rhaps0dy> depends on the effectiveness of the stack protector
15:20:36 <rhaps0dy> if you don't have remote data it's worthless
15:21:57 <macron> no-n: it's my understanding that the stack protector is mainly intended to protect against buffer overflows and the like. Such things normally cannot happen in Haskell, because all memory accesses are checked.
15:23:15 <tanmaig> Hi all. I want to write a FromJSON instance for TimeOfDay
15:23:34 <tanmaig> So the parseJSON looks like: parseJSON (DA.String x) =
15:23:43 <no-n> rhaps0dy: what did you mean by remote data?
15:23:49 <tanmaig> But I don't know what to write after that.
15:24:07 <no-n> macron: okay, so it would be a bit like running 2 firewalls
15:24:27 <no-n> +?
15:24:49 <joelteon> yes
15:25:43 <no-n> were you saying yes to me? :p
15:26:25 <rhaps0dy> no-n: as in if you process data from the network
15:26:36 <rhaps0dy> if you get users sending data mainly
15:26:51 <rhaps0dy> it's supposed to avoid buffer overflow attacks and those don't happen if you control the input
15:27:00 <no-n> ok
15:27:07 <macron> no-n: yes, that's a good analogy.
15:28:07 <pavonia> tanmaig: TimeOfDay is an instace of ParseTime, so you could use that for parsing the time. Parser combinators like Parsec are also quite popular
15:45:18 <joneshf-laptop> FunFunCtor :)
15:46:01 <funfunctor> hello?
15:46:22 <cin> functor?  i 'ardly know 'er!
15:48:48 <Anarchos> is there a bytecode language for haskell as for ocaml ?
15:56:41 <Weaving_Spider> Anyone here?
15:57:22 <Weaving_Spider> Anyone here??
15:58:46 <Hafydd> No, the channel is completely empty.
15:58:52 <rhaps0dy> we're all idling
15:58:54 <BMeph_> There are many here; we just like Lurking...and Patience. ;)
16:08:57 <awestroke> some people give up so fast... no answer in 1m? better quit the client
16:15:42 <EponymicCycloid> Hi guys. What is the design justification behind type synonyms not being allowed in instance declarations? (Without a flag specifically enabling it)
16:16:16 <EponymicCycloid> e.g.: type Point a = (a,a); instance (Num a) => Num (Point a) where…
16:16:37 <EponymicCycloid> As a toy example
16:17:07 <benmachine> EponymicCycloid: that's one of the least controversial extensions, to be fair
16:18:06 <benmachine> EponymicCycloid: one possible reason is that in Haskell 98, instance declarations are only allowed for types that are the application of a constructor to some variables
16:18:25 <benmachine> if you permit type synonyms, it's no longer possible to determine this just by looking at it
16:18:36 <benmachine> e.g. instance Eq String is not permitted
16:18:57 <benmachine> because String is secretly [Char] and hence an application of a constructor to a concrete type, not a variable
16:19:23 <benmachine> however this is me figuratively scraping the barrel of possible explanations, it seems just as likely that it's only because it wasn't in the standard because no-one put it there
16:19:57 <EponymicCycloid> got it
16:20:01 <covi> How can I type set the ML style variable  'a  in latex?
16:20:23 <EponymicCycloid> thanks
16:23:29 <joelteon> Is there a class for random values that might require IO to be generated?
16:24:45 <lyxia> covi: I haven't read enough papers to know how common it is, but I've seen greek letters used to denote types
16:24:59 <awestroke> joelteon: http://hackage.haskell.org/package/random-fu-0.2.5.0/docs/Data-Random-RVar.html  don
16:25:02 <lyxia> alpha for type variables, tau for some type
16:25:03 <covi> Yes, there's also 'a
16:25:03 <awestroke> 't know if relevant
16:44:06 * hackagebot th-alpha 0.1.0.1 - Alpha equivalence for TH Exp  http://hackage.haskell.org/package/th-alpha-0.1.0.1 (jkarni)
16:53:51 <Maior> I have lots of functions returning Maybe Maybe Things :(
16:54:08 <Ralith> :t join
16:54:09 <lambdabot> Monad m => m (m a) -> m a
16:54:11 <Ralith> Maior: ^
16:54:46 <benmachine> Maior: sometimes that is really what they are
16:57:19 <Maior> Ralith: they really really are though
16:57:21 <Maior> benmachine: yeah
16:57:34 <benmachine> Maior: so why the long face?
16:57:35 <Maior> I could probably use a more expressive type
16:57:36 <Ralith> Maior: well then what's the problem
16:57:39 <Maior> it feels icky
16:57:43 <Ralith> ...
16:57:44 <benmachine> Either Bool?
16:57:55 <benmachine> or Either MyTypeWithTwoConstructorsThatSaysWhatTheyMean
16:58:00 <Maior> pieceAtSquare :: Board -> Square -> Maybe Maybe Piece
16:58:11 <benmachine> oh, you'll want Maybe (Maybe Piece) at least
16:58:25 <benmachine> what's Just Nothing?
16:58:27 <Maior> it's Nothing if the square isn't on the board, Just Nothing if it is but the square is empty, and Just Just Piece if, yeah
16:58:30 <benmachine> oh
16:58:33 <Maior> oops forgot brackets
16:59:02 <Zearen> Is Piece an enum ?
16:59:07 * hackagebot pointfree 1.0.4.7 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4.7 (BenMillwood)
16:59:09 * hackagebot th-alpha 0.1.0.2 - Alpha equivalence for TH Exp  http://hackage.haskell.org/package/th-alpha-0.1.0.2 (jkarni)
16:59:39 <Maior> Zearen: not exactly, it's a (PieceType,Side), each of which are Enums though
16:59:40 <awestroke> @src join
16:59:40 <lambdabot> join x =  x >>= id
17:01:10 <Zearen> Ah.  I was going to suggest adding a constructor like Empty to reduce obfuscation, but that doesn't quite work with a product :/
17:01:12 <benmachine> Maior: what's Square?
17:01:31 <benmachine> Zearen: it also doesn't let you exclude that case when it's not reasonable
17:01:51 <Maior> benmachine: currently a (Rank, File) which are newtypes for Char / Int
17:01:54 <benmachine> Zearen: e.g. when asking a question like "can this piece move in this direction"
17:02:28 <benmachine> Maior: hmm. how about you use a smart constructor to ensure all constructed Ranks and Files are valid, and then drop one of the Maybes?
17:02:58 <benmachine> Maior: as in, you make it impossible to have a square that isn't on the board
17:03:40 <Maior> mmm yes actually I should just have some Maybe Squares here
17:03:48 <Maior> that would be significantly nicer
17:04:15 <meretrix> Is there any standard function of the form (a -> b -> c) -> [a] -> IO b -> IO [c]?
17:04:28 <Zearen> I'm not sure what the game is, so I can't comment further.  benmachine's advice is better anyway.
17:04:48 <Maior> @hoogle (a -> b -> c) -> m a -> m1 b -> m1 m c
17:04:49 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
17:04:49 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)
17:04:49 <lambdabot> Data.Map.Lazy insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
17:05:00 <Maior> well there goes that idea
17:05:05 <Maior> Zearen: Chess, but yeah, cheers
17:05:46 <Maior> well, and some variants
17:06:03 <hpc> meretrix: go at it a bit differently; instead of passing an action as a parameter, do b <- foo; yourFunction (f b) list
17:06:22 <hpc> @hoogle (a -> c) -> [a] -> IO [c]
17:06:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
17:06:23 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
17:06:23 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:07:08 <enthropy> is there a way to make the two instances of ScaleRecip1 here http://lpaste.net/103943 just one class? The issue is that ghc seems unable to work out the rs' ~ '[ t1 ] and rs' ~ '[] itself
17:08:14 <meretrix> hpc: But that would use a single value of "b". I want to call "IO b" for each element of [a].
17:08:48 <shlevy> Is there a good package for listening for changes to a file? Strictly only needs to work on OSX but cross-platform would be nice
17:09:01 <hpc> meretrix: ah, you'll have to write that yourself then
17:09:26 <meretrix> Ok thanks.
17:09:26 <hpc> see sequence, or if you feel like being more imperative mapM and forM
17:10:30 <awestroke> shlevy: I'm using System.FSNotify
17:10:53 <shlevy> awestroke: Cool thanks
17:14:01 <benmachine> :t \f xs iob -> mapM (\x -> f x =<< iob) xs
17:14:02 <lambdabot> Monad m => (a -> a1 -> m b) -> [a] -> m a1 -> m [b]
17:14:08 <benmachine> oops
17:14:12 <benmachine> :t \f xs iob -> mapM (\x -> f x <$> iob) xs
17:14:13 <lambdabot> (Functor m, Monad m) => (a -> a1 -> b) -> [a] -> m a1 -> m [b]
17:14:29 <benmachine> :t \f xs iob -> traverse (\x -> f x <$> iob) xs
17:14:30 <lambdabot> (Traversable t, Applicative f) => (a -> a1 -> b) -> t a -> f a1 -> f (t b)
17:14:53 <shlevy> Is "Text" the proper project category for a collaborative text editor?
17:15:55 <benmachine> shlevy: I have no idea, the project categories have always been a bit of a mess
17:17:01 <alpounet> shlevy: there's https://hackage.haskell.org/packages/#cat:Editor
17:22:00 <carter> sure
17:22:07 <carter> shlevy: you can be in more than one category
17:22:16 <shlevy> alpounet: carter: ah thanks
17:22:33 <carter> and you can always change the category between version s:)
17:34:05 <solidus-river> http://lpaste.net/103945
17:34:16 <solidus-river> its illegal to match type match against Float?
17:35:04 <pavonia> You need to enable an extension to do that
17:35:13 <[swift]> does anyone here know how to successfully get comments to wrap when editing a file with haskell-mode? i can't figure out to set up auto-fill-mode so that haskell-mode's indentation doesn't screw up the comments
17:35:25 <solidus-river> pavonia: why is it a toggleable extension, is there bad that can come of it?
17:36:22 <alpounet> solidus-river: you could just do "people :: Float \n people = ..." and then you wouldn't need this extension
17:37:25 <pavonia> people =  ... :: Float should also work in that case
17:37:42 <pavonia> I don't know why it's not in the standard
17:38:57 <[swift]> ScopedTypeVariables is something i never hesitate to use personally
17:41:58 <carter> does require explicit foralls to be enabled too
17:42:32 <enthropy> no it's included in that extension
17:43:09 <shlevy> Is either of Control.Concurrent.Chan.readChan or Control.Concurrent.Chan.getChanContents more idiomatic?
17:50:01 <[swift]> shlevy: i can only offer my own opinion, but I try to avoid unsafeInterleaveIO-like things, so I have a mild preference for readChan
17:50:24 <carter> yeah, the style is "whatever makes your use case behave correctly"
17:50:25 <carter> :)
17:50:28 <carter> for concurrent stuff
17:54:13 * hackagebot haskell-src-meta 0.6.0.6 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.6 (BenMillwood)
18:10:33 <Algebr> Is there a way for me to selectively partially apply a part of a function?
18:10:43 <Algebr> instead of it naturally going from left to right.
18:11:11 <Algebr> python's partial is able to do this...
18:13:18 <Zearen> Algebr: All funtions are automatically curried.  That is that by, e.g. applying a three parameter function to one argument, you get a two parameter function.
18:13:57 <grache28> Just getting started with haskell - playing around with lists. I've been trying to take in a list of integers and return a list (the parameter with each element squared) up to 2 elements it's working: sqr :: [Int] -> [Int]     sqr [] = [0]    sqr [x, y] = [x^2, y^2]
18:14:20 <Algebr> I understand that, what I'm saying that I want a paritcular part of the function to get a value that is say the third argument.
18:14:31 <grache28> skipped this line: sqr [x] =[ x^2]
18:15:01 <Zearen> Algebr: It's not always that easy.  But:
18:15:05 <Zearen> :t flip
18:15:06 <lambdabot> (a -> b -> c) -> b -> a -> c
18:15:06 <grache28> Anyway for list with more than 2 elements I've tried: sqr (x:xs) = [x^2 ,sqr xs]   but I'm getting type errors
18:15:24 <Zearen> Will get you the second.
18:15:31 <Algebr> hmm, will play with flip, thank you!
18:15:32 <apples> it's usually nicer to just be explicit: \x y -> f x y 3
18:17:06 <apples> otherwise you end up with something like "flip flip 3 . f"
18:17:18 <byorgey> grache28: [x^2, sqr xs] is a two-element list with x^2 as its first element and  sqr xs  as its second
18:17:50 <byorgey> grache28: this doesn't work since  x^2  is a number and  sqr xs  is a list
18:18:27 <byorgey> grache28: you are on the right track though.  The question is: how do you put together a single element (x^2) and a list (sqr xs) to make an extended list?
18:18:55 <Zearen> What's that package that has 'uncurry3' and what not ?
18:19:05 <Zearen> I can't seem to find it.
18:19:31 <byorgey> Zearen: did you search on Hayoo?  http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:uncurry3
18:19:39 <_Vi> Where shall I file issues for packages in the Hackage?
18:20:35 <byorgey> _Vi: it depends on the package.  If the package lists an issue tracker, file it there.  Otherwise, if it lists a maintainer, you can email the maintainer
18:20:47 <byorgey> _Vi: which package are you looking at?
18:21:24 <Zearen> Because with TupleSections, you could
18:21:25 <Zearen> uncurry3 f . (,,0)
18:21:27 <_Vi> vector-fftw . Looks like there's Github repository for it. Going to file the issue there.
18:21:38 <Algebr> byorgey: Are you the professor for CIS 194?
18:21:58 <Zearen> byorgey: I had tried Hoogle, but I didn't get any results.
18:22:04 <byorgey> _Vi: yes, that sounds like the right place
18:22:11 <byorgey> Algebr: I was, yes
18:22:30 <byorgey> Zearen: yeah, Hoogle only searches selected standard packages
18:22:35 <byorgey> Hayoo searches all of Hackage
18:22:53 <Algebr> byorgey: I'm working through the course, its really fun.
18:22:58 <Zearen> Aaaaahhhh, I never knew that distinction.  Thanks :)
18:23:02 <byorgey> (but Hoogle is better at searching by type)
18:23:03 <shlevy> Is System.Notify.watchDir expected to loop indefinitely?
18:23:11 <byorgey> Algebr: thanks, glad you're enjoying it =)
18:25:50 <grache28> byorgey: tks. I was thinking something along those lines because of the type error, you just put it into a better question. will check the syntax now
18:26:31 <geekosaur> shlevy, I think it just registers a callback; you're not supposed to call it repeatedly, from what I see
18:27:00 <Algebr> Does everyone just write their code first and then think about efficiency? I'm finding it hard to reason about haskell code.
18:27:21 <geekosaur> pretty much, yes
18:27:40 <Algebr> =/
18:27:42 <zomg> I write all my code without thinking about efficiency no matter the language :P
18:27:50 <shlevy> geekosaur: That was my expectation... But I'm calling watchDir inside a withManager and the program is just exiting successfully with no events
18:27:53 <Zearen> Er wait, you need a (.:) for above.  I.e. uncurry3 f .: (,,3) where (.:) = (.).(.)
18:28:07 <zomg> There's been very few cases ever where I actually have needed to get really high performance
18:28:31 <zomg> I think only times been mostly related to rendering, or getting some ridiculous thing working on low end mobile devices =)
18:28:55 <Algebr> zomg: I mean I sort of do as well, but say you're doing a nested for loop, you immediately have some kind of intuition about the efficiency. I'm not getting that kind of knee-jerk intuition on my haskell code, and the lazy answer, pardon the pun, is to just say, oh well the language is lazy so its all constant memory usage.
18:29:03 <geekosaur> shlevy, from what I see, if you want it to stick around, you need at least a dummy action (like threadDelay) --- the idea is it receives events while something else is going on and acts on them
18:29:08 <geekosaur> you need that something else going on
18:29:24 <Zearen> Optimization in Haskell is kind of a black art.  There are some basic patterns that are emerging, but coding then profiling is still your best bet.
18:29:29 <geekosaur> if the whole point is just monitoring those changes, you'll need to sleep
18:29:54 <zomg> Algebr: I think if you use builtins like fold etc. and don't go reinventing things too much they tend to perform pretty well
18:29:56 <shlevy> geekosaur: Ah! thanks
18:29:56 <benzrf> hey
18:30:34 <Zearen> Though even foldl' can be tricky if you use a non strict constructor.
18:30:35 <shlevy> geekosaur: How do I sleep :D
18:30:38 <zomg> it's easier to accidentally write some kind of crap recursion that doesn't handle TCO or such properly if you're not used to thinking about those, and using builtins deals with that for you mostly
18:30:44 <Ralith> Algebr: there are the obvious things like "don't use a list for a table of six million items that you need random access in"
18:33:17 <cjwelborn> I following 'Real World Haskell, Chapter 7', but detoured to look at some stuff. Is this the way 'when' and 'unless' are normally used? (31 line simple program) http://welbornprod.com/paste/?id=dbzx
18:33:43 <startling> cjwelborn: yep.
18:33:47 <shlevy> I'm writing a program that just does an indefinite (or, until ^C) watch on a file using System.FSNotify. How to I sleep indefinitely in the main thread after starting the watcher?
18:34:09 <startling> cjwelborn: you could also do "if null args then x else y"
18:34:22 <startling> and put 'x' and 'y' in a where clause.
18:34:38 <startling> but what you've got is fine.
18:35:03 <cjwelborn> startling: thanks :) I am really trying to get into this Haskell mode.
18:35:10 <startling> cjwelborn: you've got a race condition, though.
18:35:20 <cjwelborn> startling: oh no. like what?
18:35:24 <startling> cjwelborn: in general, you shouldn't say "if this file exists, read it"
18:35:25 <grache28> I know this is a very broad, and may even seem like a loaded question, but: what niche does haskell (or other functional languages) fill? They aren't for systems programming, and it seems (to me who knows very little about functional langs) like other languages are better suited for scripting. When do you use haskell?
18:35:38 <startling> cjwelborn, you should say "try to read this file, and do x if it doesn't work"
18:35:54 <Algebr> grache28: I'll bite. Its a general purpose programming langugage. You can do do anything with it.
18:35:55 <cjwelborn> startling: in Python I would trap exceptions, would 'catch' be helpful here?
18:35:55 <startling> cjwelborn: the issue is that the file may be modified in between "does this file exists" and "read it"
18:35:57 <zomg> grache28: I use haskell for web development myself
18:36:12 <solidus-river> is there a cleaner way of writing this
18:36:19 <grache28> zomg: how's that?
18:36:27 <solidus-river> loadMigrationTable =<< (DYC.load $ baseName </> "config.yaml")
18:36:42 <startling> cjwelborn: yeah, or tryJust.
18:37:05 <startling> cjwelborn: it's not super important, but it's good practice to try not to do it.
18:37:19 <zomg> grache28: works quite fine, plenty of nice libraries and the language itself lends itself to it pretty nicely
18:37:23 <grache28> Algebr: not to be rude, but assembler is a general puprose prog. lang.; I wouldn't want to write userland applications with it tho
18:37:25 <cjwelborn> startling: got it. thanks again :)
18:37:34 <Zearen> shlevy: main = do { block <- newEmptyMVar ; action ; takeMVar block} -- Is how I would do it.  It'll gives you a way to terminate gracefully if you want to do that later on.
18:37:36 <startling> cjwelborn: no problem!
18:37:41 <grache28> zomg: what kinda web stuff exactly?
18:37:53 <shlevy> Zearen: Thanks!
18:37:57 <startling> grache28: what do you mean by "systems programming"?
18:38:04 <startling> (I ask because there's two definitions).
18:38:26 <zomg> grache28: like web app backend stuff, eg. db access, data models related to it, serving pages, then also for frontend scripting by using Fay which allows me to compile Haskell code into JavaScript
18:38:29 <grache28> so far to me, it looks great for math stuff, like project euler, but I know it must have many more uses
18:39:00 <startling> grache28, Haskell has been pretty good for everything I've tried to do with it (excepting cases where libraries I would want don't exist)
18:39:04 <grache28> startling: the real definition of course :)
18:39:13 <grache28> interacting with hardware
18:39:45 <shlevy> Zearen: Perfect!
18:39:48 <startling> grache28: Haskell is exceptionally good for things like parsing and manipulating trees.
18:40:00 <startling> grache28: right, it's a bit of a mess to do things like that with Haskell in (but it's been done)
18:40:01 <grache28> zomg: cool - didn't realize people used it for that kinda stuff
18:40:20 <startling> grache28: "halvm" and "house" are two things you might look at.
18:41:22 <startling> but for me anyway, parsing was the thing that sold me on the language.
18:41:33 <shlevy> Anyone know of a haskell library for google drive API? https://code.google.com/p/hgdata/ says no
18:42:04 <grache28> startling: looking at halvm github - brings up a question. I think I read GHC can output C code, or did I dream that up?
18:42:41 <grache28> startling: what kind of parsing exactly?
18:43:04 <startling> grache28, GHC used to output C; I forget if it can anymore. it's not the default in any case.
18:44:20 <startling> grache28, I use it for programming language stuff mostly. I've done more practical stuff with it, though.
18:44:59 <grache28> startling: cool - I'm just getting my feet wet
18:45:47 <zomg> grache28: sure, if you compare it to something more "mainstream" in web dev like say Ruby on Rails, it's maybe not quite as fast for development, but that's mainly because there's less libraries
18:46:23 <rtpg> I just recently install haskell-platform (OS X) and get this error when trying to cabal install cabal-install http://lpaste.net/103948
18:46:23 <zomg> grache28: the language itself is quite good in comparison as it saves your bacon from a variety of issues thanks to the nice type system and such
18:47:14 <startling> rtpg: I think carter helped someone with this last time, but I forget what it was.
18:47:19 <startling> ping carter
18:47:23 <carter> duh
18:47:26 <carter> DON"T USE HP
18:47:27 <grache28> I'm taking a programming language theory course and functional programming is a small part of it. We have to write a function in haskell that takes in a list of 'results' and a list of 'sumandos'(is that how you say it?) which then returns the possible ways to add the sumandos up to the results using each sumando one time. Using graph and backtracking
18:47:42 <carter> startling: look at the topic link :)
18:47:51 <carter> you can point people to my gist via that
18:47:56 <carter> http://is.gd/H4sEub
18:48:00 <rtpg> oh xcode 5
18:48:02 <carter> then click on the second link
18:48:04 <carter> and land on my gist
18:48:11 <carter> https://gist.github.com/cartazio/7131371
18:48:12 <startling> grache28: "summand", maybe?
18:48:12 <carter> https://gist.github.com/cartazio/7131371
18:48:12 * carter https://gist.github.com/cartazio/7131371
18:48:13 <carter> https://gist.github.com/cartazio/7131371
18:48:14 <carter> https://gist.github.com/cartazio/7131371
18:48:14 <carter> https://gist.github.com/cartazio/7131371
18:48:19 <startling> carter: :)
18:48:23 <rtpg> thanks :)
18:48:24 <carter> startling: NOW YOU DO IT
18:48:26 <carter> please
18:48:34 <carter> i'm tired of having to read the direcctions to people :)
18:48:38 * startling https://gist.github.com/startling/122c2ca336f5fdc9d90e
18:48:44 <grache28> zomg: cool - ive not done any web stuff, i will be in the future tho
18:48:51 <rtpg> I'm very sorry ;)
18:48:57 <rtpg> thanks for the help
18:49:45 <carter> rtpg: don't appolgize
18:49:48 <grache28> startling: hehe, i'm tired, english is my first language but the project is in spanish - couldn't remember the english. Just looked in the dictionary 'addend' heh
18:49:52 <carter> just make fun of startling  for not clicking a link for you
18:50:13 <startling> :)
18:50:20 <rtpg> who reads instructions anyways
19:00:29 <eyebloom> If I have two unsigned Word8 s that represent sequential bytes in a signed Int16 how can I accurately combine them in Haskell?
19:02:38 <johnw> do you know the host's byte order?
19:04:14 <startling> who reads the /topic anyway is what I want to know
19:06:01 <carter> startling: you do,... now
19:06:13 <startling> :>
19:15:01 <_Vi> Why Hoogle can't find Control.Arrow.(>>>) when queried "(a -> b) -> (b -> c) -> a -> c" ?
19:15:57 <pavonia> @hoogle (a -> b) -> (b -> c) -> a -> c
19:15:58 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
19:15:58 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
19:15:58 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
19:16:03 <_Vi> (Looks like it's type is some complicated one, not just reversed "(.)")
19:16:06 <joelteon> wouldn't that require instance resolution?
19:16:49 <_Vi> Maybe there should be simpler, function-specific >>> just for Hoogle to be able to find one by signature?
19:16:57 <pavonia> @hoogle (a ~> b) -> (b ~> c) -> a ~> c
19:16:57 <lambdabot> Warning: Unknown type ~>
19:16:58 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
19:16:58 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
19:17:18 <pavonia> Seems to be too specific
19:17:20 <_Vi> ~>   ?
19:17:43 <pavonia> It's a type constructor
19:18:11 <_Vi> @hoogle a ~> b
19:18:11 <lambdabot> Warning: Unknown type ~>
19:18:11 <lambdabot> Control.Applicative unwrapArrow :: WrappedArrow a b c -> a b c
19:18:11 <lambdabot> Data.Graph.Inductive.Graph empty :: Graph gr => gr a b
19:18:35 <pavonia> "a ~> b", "(~>) a b", "cat a b" are all equivalent
19:18:46 <pavonia> It's like infix operator but on type level
19:18:53 <_Vi> OK. Probably I'll understand this someday.
19:19:48 <carter> sclv_: sclv why sin't this months meetup online yet?
19:20:06 <gamegoblin> @pl \x -> (!!x)
19:20:06 <lambdabot> flip (!!)
19:27:25 <sclv> carter: because i need to double confirm with the speakers plus lock down the abstracts
19:27:30 <carter> kk
19:27:31 <sclv> i suppose i could put up a placeholder with the date
19:27:33 <sclv> but whatever
19:27:35 <carter> fair
19:27:39 <carter> wed 28th?
19:28:19 <sclv> yep
19:28:23 <sclv> 4th wed of the month
19:33:32 <gamegoblin> How would I translate this list comprehension from python to haskell: [a+b+c for a in range(0,8) for b in range(a+1,9) for c in range(b+1,10)]
19:35:20 <c_wraith> There's...  no real trick there.
19:35:44 <gamegoblin> I feel like I am being dumb here
19:36:00 <gamegoblin> Do multiple assignments in haskell list comprehensions bind left to right?
19:36:09 <c_wraith> > [ a + b + c | a <- [0..7], b <- [a + 1 .. 8], c <- [b + 1 .. 9] ]
19:36:11 <lambdabot>  [3,4,5,6,7,8,9,10,5,6,7,8,9,10,11,7,8,9,10,11,12,9,10,11,12,13,11,12,13,14,1...
19:36:21 <no-n> replace for with | and in with <- ..ok
19:36:24 <gamegoblin> Ahhh k, for some reason I thought they didn’t bind left to right
19:36:30 <c_wraith> the only real difference is that the upper bounds all change
19:36:42 <gamegoblin> Yeah no worries. I just misunderstood the semantics
19:36:47 <gamegoblin> thanks
19:36:47 <c_wraith> because of the difference between range and [1..n]
19:37:40 <pavonia> What is the Haskell equivalent for range(x, y)?
19:38:08 <Eckleck> pavonia: [x .. y]
19:38:35 <Eckleck> Oh wait, range is [x .. y - 1]
19:39:03 <pavonia> That's somewhat weird
19:39:12 <Eckleck> How so?
19:39:34 <pavonia> It starts with x but ends with y-1
19:40:38 <Eckleck> It's actually more convenient that way. Gives you exactly (y - x) elements.
19:42:09 <dmj`> Does ghc Main.hs --ddump-to-file work? -ddump-parsed/rn/tc/ds all work, but for some reason can't get --ddump-to-file to output compilation stages to a file
19:42:42 <XrXr> Oh noes.... github is down
19:45:23 <dmj`> also, when optimization flags are specified in ghc, like -O2 do those just increase the # of Core->Core trasnformations?
19:45:26 <carter> local clones / local hackage chaching by cabal
19:45:39 <carter> dmj`: it also increase the chance ghc will eat all your ram :)
19:45:53 <carter> theres some core to core stuff that gets enable
19:45:57 <carter> and some CMM stuff too i think
19:46:04 <carter> forget if it also trips llvm doing O2
19:46:05 <carter> or not
19:46:43 <dmj`> hmmmm
19:47:03 <carter> dmj`: try building idris wiht O2
19:47:12 <dmj`> what happens?
19:47:24 <carter> unless you also do -fno-spec-constr, you'll run out of ram before it can finish
19:47:34 <carter> something about the javascript backend module makes ghc need LOTS fo ram
19:49:31 <dmj`> hmmmmmm
19:56:31 <XrXr> is the difference between foldl' and foldl that foldl' is not lazy?
19:57:16 <johnw> foldl' is strict in its accumulator
19:58:43 <XrXr> what does that mean?
19:59:17 <johnw> if that doesn't make sense, can I ask why you are asking about the difference?
20:00:05 <XrXr> I heard that I should always be using foldl' since it doesn't break when operating on a big list
20:01:04 <johnw> there are problems it won't solve, but in general it should always be preferred over foldl
20:01:35 <XrXr> okay.
20:02:20 <enthropy> is it a feature that you cannot get ghc to listen to -fno-warn-dodgy-exports when building with cabal?
20:04:19 <johnw> XrXr: to really grasp the difference, the best way is to implement them both :)
20:06:16 <XrXr> D: maybe later. Thanks johnw :)
20:29:32 * hackagebot snaplet-sqlite-simple 0.4.7 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.7 (JanneHellsten)
20:40:50 <flebron> What would be a situation where Yoneda is useful to simplify code?
20:41:02 <flebron> (Or, really, useful in some way.)
20:42:11 <arnob> Hi all. Parsec question for you
20:42:44 <arnob> I am trying to parse a document of the format, and trying to get out a list of key, value pairs
20:42:56 <arnob> The file looks like this
20:44:35 <arnob> <NOTICE>\n<NAME>value\n<DESC>value\n<LINK>\n<URL>value\n<DESC>value\n</NOTICE>
20:45:25 * geekosaur wonders if some tagsoup-y thing would be more appropriate
20:45:27 <arnob> as you can see, I have two keys called the link is sort of a complex field, which has a <URL> and <DESC> asscoaited with it
20:45:58 <YellPika> flebron: I'm not really sure, but the usual advantage to these CPS-like encodings is performance.
20:46:59 <arnob> I made a parser for simple fields, and another parser for the link field, like so
20:47:10 <arnob> simpleField = do key <- fieldIdentifier                  value <- fieldValue                  return (key, value)                  <?> "field"
20:47:33 <arnob> linkField = do string "\n<LINK>\n<URL>"; url <- manyTill anyChar newline;desc <- manyTill anyChar newline;return [("URL", url), ("URLDESC", desc)]
20:48:24 <arnob> but I cannot seem to combine them, as linkField returns a list of key value pairs, while simpleField returns only a single key value pair
20:48:45 <arnob> any suggestions on how to soleve this issue?
20:49:12 <arnob> (by combine them, I mean manyTill (simpleField <|> linkField) (try closingTag)
20:49:30 <arnob> sorry, if I have done something silly on IRC or Haskell
20:49:33 <arnob> I am new to both :-)
20:50:40 <dmj`> arnob: <NAME> has no closing tag?
20:50:55 <arnob> no closing tag
20:51:00 <arnob> it's a weird format
20:51:15 <arnob> only <NOTICE> has a closing tag </NOTICE>
20:51:47 <dmj`> arnob: what constitutes a key in this format?
20:52:24 <arnob> a key always starts on it's own line, and is of the form <UPPER>
20:52:36 <arnob> where UPPER is an uppercase string
20:53:17 <dmj`> arnob: you're going to have to show more, doesn't make much sense
20:53:25 <arnob> I could give you an example of the format
20:54:06 <geekosaur> arnob: I would say you want simpleField to do: return [(key, value)]
20:54:12 <dmj`> why is DESC mentioned twice
20:54:24 <geekosaur> a 1-element list, hence compatible with the type of the 2-element list
20:54:37 <arnob> one DESC is associated with the top level description of the notice
20:55:00 <arnob> and another "DESC" is associated with the link
20:55:34 <dmj`> <LINK> has no value?
20:55:41 <arnob> no
20:55:45 <arnob> it does not
20:56:03 <arnob> I guess it's just an indicator that <URL> and <DESC> follow
20:56:04 <dmj`> is there a specification for this format
20:56:07 <arnob> here is an example format
20:56:11 <arnob> sorry
20:56:12 <arnob> example file
20:56:14 <arnob> ftp://ftp.fbo.gov/FBOFeed19991231
20:58:23 <arnob> specification: https://web.archive.org/web/20120927164554/https://www.fbo.gov/index?s=generalinfo&mode=list&tab=list&tabmode=list&static=interface&ss=Presolicitation
20:58:33 <arnob> that is the specification for a presoliciation notice...
20:58:38 <arnob> but there are various types of notices
20:58:49 <arnob> with different fields
20:58:52 <dmj`> <LINK> "A structural tag" "No data required or accepted"
21:00:02 <arnob> yes, looking at the notice, it looks like the documents have "<LINK>\n<URL>value\n<DESC>value\<ANOTHER FIELD>
21:00:27 <arnob> so link just alerts you that there will be a URL and a DESCRIPTION coming up, I guess...
21:01:08 <dmj`> it'd be hard to parse w/o knowing what the intentions are, how and if things are recursive
21:01:57 <arnob> I am not sure what you mean by recursive? LIke if a notice can have another notice inside it?
21:02:55 <YellPika> arnob: Can the values have newlines in them?
21:03:00 <arnob> yes
21:03:25 <dmj`> "<LINK>, <URL>, and <DESC> are a group data and should be provided or omitted together", well that helps I guess
21:03:58 <arnob> YellPika, the thing separating a field from the next one is the field idenitfier
21:04:10 <arnob> something of the form "\n<UPPER>"
21:05:03 <YellPika> arnob: The "\n" before the next field is not optional?
21:05:09 <arnob> no
21:05:19 <arnob> fields always start on their own line
21:06:16 <arnob> so for example, a description can be "<DESC>Hi I am a multi-\n line description\n Yay\n<NEXTFIELD>"
21:06:43 <arnob> I guess I am trying to get a list of key value pairs for each "notice"
21:07:03 <YellPika> Okay, I think I've got the format. I was thinking the it was simple enough that a hacked-together function would be enough, but I guess it's time for me to brush up on my Parsec :)
21:07:23 <arnob> and if there is a <LINK><UR><DESC>, I want to get back the key value pairs <URL>value1<URLDESC>value2
21:08:58 <arnob> ... so skip the "<LINK>"tag... and rename <DESC> to URLDESC...
21:09:02 <arnob> if that makes sense
21:11:37 <napping> arnob: is that SGML?
21:11:46 <arnob> no it is not
21:11:58 <arnob> it's like a terrible version of XML
21:12:05 <arnob> https://web.archive.org/web/20120927164554/https://www.fbo.gov/index?s=generalinfo&mode=list&tab=list&tabmode=list&static=interface&ss=Presolicitation
21:12:26 <YellPika> "terrible version of XML". Didn't know it was possible.
21:12:57 <napping> Are you sure that's not an SGML instance?
21:14:04 <geekosaur> there are a lot of crappy not-quite-sgml data formats out there. back in the 90s one of the things I got to write was a parser for the not-quite-sgml then used for Dodge reports
21:14:09 <dmj`> arnob: http://lpaste.net/103958, I'd go w/ TagSoup on this one, parsec seems overkill
21:14:42 <arnob> let me try that
21:14:51 <arnob> although the tags are not HTML
21:14:57 <dmj`> arnob: http://lpaste.net/103959
21:15:02 <dmj`> there's the gen'd output
21:15:16 <geekosaur> doesn't matter, tagsoup is (and has to be) pretty lenient
21:15:31 <napping> geekosaur: not-quote-sgml? ick
21:15:42 <arnob> oh
21:15:50 <arnob> that output seems nice
21:15:56 <carter> > (1/0/0 - 1/0.0) `compare` (1/0/0 - 1/0.0)
21:15:58 <lambdabot>  GT
21:16:01 <carter> saness
21:16:05 <carter> saddddnessss
21:16:07 <arnob> thank you dmj` !
21:16:13 <dmj`> arnob: that will be $50
21:16:40 <arnob> check is in the mail :-)
21:16:52 <dmj`> arnob: don't worry I got your IP I'll be ip-faxing you an invoice, payment by bitcoin please
21:17:15 <dmj`> arnob: alright I'm not funny
21:17:21 <dmj`> arob: what is the for anyways?
21:17:24 <dmj`> this*
21:17:45 <YellPika> World domination!
21:17:55 <dmj`> YellPika: :P
21:17:56 <arnob> I am trying to do some data mining on government contracting data
21:18:06 * YellPika steps away
21:18:25 <dmj`> arnob: Also, you might want to use iteratees if you'll be reading this data from file first, or via an http-request, can I recommend http-streams? Just did
21:18:53 <arnob> see if there are any patterns in terms of whether where a vendor does business is related to how often they win contracts
21:19:37 <dmj`> alright, hacking the system
21:19:40 <dmj`> :P
21:20:24 <YellPika> Wait, so I wasn't far off?
21:20:44 <arnob> I have to check out http-streams, have not heard of it before
21:20:57 <napping> I doubt you need to bother for thiz
21:21:11 <napping> Unless those files can get much bigger than the example?
21:22:04 <dmj`> arnob: how do you determine how often someone wins a contract?
21:22:53 <arnob> The description field for the notices mention if an award has been made to avendor
21:22:58 <napping> streaming stuff is only necessary if you don't want to read the whole file into memory at once, and the maximum size of that format is about 256kb
21:23:30 <arnob> so I am going to check how often a vendor is mentioned, going through each of these notices
21:23:32 <napping> and three of the 64k fields are for things like addresses and contact information that shouldn't be that big
21:26:31 <dmj`> arnob: If I were you I'd forkIO all of the things to grab the files via http-streams, parse w/ TagSoup, then evaluate each Tag and stick the date into some IntMap stored in acid-state or a TVar IntMap, then perform analysis on the data structures there. Be careful or you might ddos them
21:26:51 <napping> :t get
21:26:52 <lambdabot> MonadState s m => m s
21:27:05 <dmj`> IntMaps are waaaaay faster than Data.Map
21:27:24 <copumpkin> except if you call size on them
21:27:29 <copumpkin> don't call size on them
21:27:31 <dmj`> data*
21:27:36 <copumpkin> (I think that should be fixed)
21:28:05 <arnob> dmj` would you recommend acid-state over postgres or some other SQL store?
21:28:23 * johnw awaits dmj` answer with an evil smile
21:28:36 <dmj`> arnob: I would, but I guarantee I am the *only* one in the world who would :P
21:28:36 <dmj`> johnw: hahaha
21:30:08 <arnob> I have a looked at a bit of the acid state tutorial, but I am still learning the whole Haskell thing
21:30:42 <johnw> acid-state has several costs, and I'm not sure that anyone has really proven that the benefits are worth it
21:32:12 <dmj`> arnob: It depends on your situation. If you can store the data efficiently, like represent a city or state as an Int, and keep the data small, then yes. It sounds like this isn't performance critical so I think you'd be fine w/ mysql, postgres, mongo etc, and for your app you could just monitor a bunch of threads that poll a government website.... threads <- forM [1..10] $ \_ -> forkIO $ forever $ { threadDelay (secs 10) ... ge
21:32:13 <dmj`> update db } etc.
21:32:49 <arnob> yes, this data is updated only nightly
21:32:58 <arnob> and I have a local copy of the data up to date...
21:33:19 <johnw> better: workers <- replicateM 10 $ async $ forever $ ...
21:34:08 <johnw> maybe even 'link' all the workers together, so that an exception in one brings them all down
21:34:39 <dmj`> johnw: that's right I was paying attention to your talk at the hackathon... :P
21:34:48 <dmj`> @typ mapConcurrently
21:34:49 <lambdabot> Not in scope: ‘mapConcurrently’
21:34:50 <johnw> aka: sequence_ $ foldl1' link workers
21:35:11 <carter> dmj`: were you at hac nyc?
21:35:20 <johnw> (sequence_ may not be needed)
21:35:21 <johnw> he was!
21:35:27 <carter> who is dmj` ?
21:35:30 <johnw> Dave
21:35:31 <arnob> dmj` I am not sure what tag soup is needed for in your code?
21:35:31 <dmj`> carter: yea dude !!
21:35:40 <carter> did we talk? i don't remembe
21:35:51 <dmj`> arnob: parseTags
21:36:05 <napping> arnob: that's the parser that splits things up into tags. It's the only important thing out of all the suggestions
21:36:29 <dmj`> carter: we talked about windows stuff, I showed that website thing
21:36:36 <carter> oooo
21:36:38 <carter> chicago dude
21:36:41 <napping> All the rest is about pulling it from a website, or parsing several files in parallel, or stuff like that
21:36:55 <napping> nice, but not necessary if you're just getting started
21:37:00 <napping> not too hard either
21:37:30 <dmj`> carter: yeaaa cad file stuff
21:37:41 <carter> was neat
21:38:36 <dmj`> carter: you should come to lambda jam in chicago
21:38:46 <carter>  depends on cash flow
21:38:56 <carter> which is still on the paltry but not zero side
21:39:02 <carter> needs to be a bit bigger for me to do much travel
21:40:05 <dmj`> carter: such is life
21:40:05 <dmj`> you spent all your money publishing that haskell numeric computing article on forbes didn't you... http://arstechnica.com/science/2014/05/scientific-computings-future-can-any-coding-language-top-a-1950s-behemoth/
21:40:13 <carter> dmj`: nah
21:40:16 <carter> i think the article is crap
21:40:18 <carter> :)
21:41:48 <dmj`> or arstechnica :P
21:42:37 <YellPika> Does anyone mind reviewing an effects library I wrote?
21:42:56 <dmj`> hah didn't even read it to be honest
21:43:03 <YellPika> https://github.com/YellPika/effin if anyone's interested.
21:44:02 <carter> dmj`: basically people who like using R / matlab are excited about julia
21:44:12 <carter> but only the folks who don't have real code in r/ matplat
21:48:28 <XrXr> hm.. is it the tendency that functional code takes longer to understand than imperative code? I'm rewriting some stuff I did in imperative language in Haskell, and even though they are shorter, they are less likely to pass the drunk test
21:49:06 <carter> drunk test is ?
21:50:29 <pyon> XrXr: I normally find my Haskell code easier to understand than my code in most other languages. But perhaps it is just the fact that my "understanding" is "ghci-enhanced understanding".
21:50:33 <startling> XrXr, there's definitely a learning curve
21:50:39 <XrXr> carter: basically if some code is simple enough, someone can read it even when they are a bit drunk
21:50:50 <carter> depends on whos reading it
21:50:59 <startling> I find Haskell is *denser* than imperative code.
21:51:05 <startling> I think this is a good thing.
21:52:14 <kvitebjorn> exit
21:52:25 <startling> kvitebjorn: whoops
21:52:34 <johnw> I deny your exit request
21:52:36 <XrXr> I definitely feel smarter and more accomplished when I write Haskell code though. :)
21:52:58 <LordBrain> well, i prefer haskell too, but if i am honest i will admit that you have a better idea what comes out of the other end of hte compiler in a lower level language
21:53:24 <johnw> you mean, if you *also* knew the processor architecture intimately?
21:53:25 <LordBrain> i mean... more readily you can discern that
21:53:30 <carter> i've some code thats 2k LOC in haskell... that would probably be 10-20k in c++ and friends
21:54:24 <LordBrain> john, but haskell does a lot more than abstract over the architecture, so i would say that is not really what i mean
21:56:37 <startling> I mean, that's the whole point of abstraction.
21:56:48 <carter> LordBrain: i'm a bit weird, but i'm also managing to write codes in haskell where I have a pretty clear idea what the result code should look like
21:57:05 <LordBrain> i suppose if there were machines actually didn't run programs as lists of instructions at all at the low level, so you know... your low level langauge was actually declarative, then the story would be different, but that also just moves the blur, because you would still have a harder time knowing order of events etc.
21:57:29 <carter> i mean i actually know what sort of code i'll get at the asm level
21:57:31 <carter> roughly
21:57:41 <napping> STG?
21:58:34 <dbelange> Star Trek: Galactica
21:58:35 <LordBrain> i love haskell, its my favorite language, so dont get me wrong here.. i am definitely not saying it is futile or impossible or something like that, but there are some things that are obviously obscured the higher level we go... so managed memory, lazy semantics... etc
21:59:39 <LordBrain> we are gearing the langauge toward communicating mathematical objects more than actual programs... and having the computer try to figure out how to generate the programs from these descriptions.
21:59:43 <johnw> I suppose could have said that about register allocation and memory addressing, 40 years ago, too.  Even in today's assembly you are dealing with abstractions over the hardware you cannot control.  It's a question then of where is the most effective place to draw the line.
22:00:36 <LordBrain> yeah and the answer is it depends
22:02:06 <napping> LordBrain: laziness and memory management leads to reasonably stylized code at lower levels
22:02:44 <LordBrain> can you give me an example of what you mean by that, because i don't really know what you are saying
22:02:48 <Ralith> not to mention that even machine code is an abstraction over the realities of modern CPUs
22:02:53 <carter> yup
22:02:55 <Ralith> virtual registers, etc
22:02:59 <napping> It's hard to predict when you'll have to GC, or what will happen when forcing a value, but the code to fetch more memory or enter a thunk is fixed
22:03:25 <carter> idk, depending on your workload those can be pretty predictable
22:03:31 <Ralith> pipeline and cache behavior can get pretty weird too
22:03:34 <carter> yeah
22:03:37 <carter> those require measurements
22:03:39 <LordBrain> ok, i think i see what you are saying
22:03:52 <napping> compared to something like a virtual function call
22:03:54 <carter> cache / pipelining requre lots of measuring
22:04:05 <johnw> Ralith: or instruction stream sequencing to take advantage of prefetch and speculative branching
22:04:10 <carter> yeah
22:04:42 <napping> Core down to STG code leaves a reasonably straightforward operational reading
22:04:46 <johnw> the one time I did any RISC assembly coding, I found it to be kind of freaky
22:05:29 <carter> napping: i've atually read disassembled ghc asm
22:05:36 <carter> its easier for me to understand that that core :)
22:09:16 <LordBrain> i sometimes wish i could get the whole rts of my compiled program spit out in pretty c++. Is that a really weird desire?
22:10:16 <Enigmagic> not as weird as my haskell fetishes.
22:10:41 * Enigmagic puts the butter back in the fridge
22:10:55 <carter> Enigmagic: did you ever get  the lambda calc in dwarf tricks?
22:11:04 <LordBrain> i mean, i see c++ as a lower level language, that would be useful for debugging etc
22:11:23 <Enigmagic> carter: i read teh paper yeah
22:11:27 <carter> LordBrain: ... the RTS is written in C
22:11:30 <jfischoff> does ghc make the package-id, or is it ghc-pkg or cabal?
22:11:34 <Enigmagic> the turing machine in dwarf one
22:11:41 <LordBrain> is it just linked in, or is it modified?
22:11:46 <carter> linked in
22:12:01 <KatZilla> Hi there!)
22:12:06 <KatZilla> Need help with this! http://lpaste.net/103961
22:12:11 <carter> LordBrain:  look in /ls /usr/local/lib/ghc-7.8.2/rts-1.0/
22:12:14 <carter>  in ls /usr/local/lib/ghc-7.8.2/rts-1.0/
22:12:18 <KatZilla> ToJSON -> Insert another object
22:12:37 <jfischoff> also split-objs, are they used for deadstriping or something else
22:12:58 <johnw> deadstriping?
22:12:59 <carter> jfischoff: you've neverused split objs?
22:13:10 <jfischoff> I have
22:13:13 <carter> its for doing a split the lib into one object file perfunction
22:13:20 <carter> so you only link in the bit syou need
22:13:35 <KatZilla> Please help with ToJSON !) Need help with this! http://lpaste.net/103961
22:13:49 <pavonia> KatZilla: If you'd insert the whole object again, you'd get an infinite nesting
22:14:09 <jfischoff> johnw: http://en.wikipedia.org/wiki/Dead_code_elimination dead code stripping
22:14:21 <johnw> ah
22:14:30 <jfischoff> I said it wrong :p
22:14:56 <jfischoff> carter: okay that’s what I thought. I wasn’t sure positive
22:14:59 <johnw> I thought it was something cool I hadn't heard of yet
22:15:05 <jfischoff> ha
22:15:16 <carter> johnw: its like a hacky version of function/gc-sections
22:15:23 <carter> which we should add
22:15:28 <KatZilla> pavonia: I dont want to create new data structure UserWithClient. Is there any elegant way to pass it there?
22:15:43 <jfischoff> but I’ll ask again who makes the package-ids and why are they non-deterministic?
22:15:56 <carter> they're not nondet
22:16:02 <carter> if you find they are, please report a bug
22:16:23 <carter> they're kinda the hash of all the module deps
22:16:33 <pavonia> KatZilla: Oh wait, I mixed up Client and User ... Where does you client object come from?
22:18:01 <KatZilla> pavonia: I query DB for User.. If there is any client_id, I query DB once more for Client
22:18:48 <pavonia> But you need it in the User value
22:19:28 <jfischoff> Enigmagic: what is your take on Nix like approach to package management?
22:21:16 <KatZilla> pavonia: I will update code on lpaste
22:21:23 <KatZilla> pavonia: w8 1min plz
22:21:35 <johnw> jfischoff: pure awesomeness is my take
22:22:03 <jfischoff> johnw: yeah, I’m trying to find a counter argument
22:22:24 <jfischoff> the only one I’ve heard is that cache might grow to big
22:22:31 <johnw> it can and does
22:22:32 <carter> upfront cost of planning
22:22:36 <carter> how big?
22:22:39 <johnw> but there's a garbage collector
22:22:54 <johnw> well, I'm on generation 242
22:22:54 <joelteon> you mean like apt?
22:23:10 <johnw> and my /nix is... 17G
22:23:25 <joelteon> oh, nix
22:23:35 <johnw> most of which is taken up by texlive-full, and _complete_ environment installations of GHC 7.6.3 and 7.8.2, and every Haskell package I ever use or might think I'll use
22:23:37 <jfischoff> johnw: what do you think about have ghc-pkg work Nix like?
22:23:47 <joelteon> does nix work on OSX?
22:23:52 <johnw> joelteon: it does indeed
22:23:57 <carter> jfischoff: theres plans
22:24:00 <carter> towards that
22:24:03 <joelteon> ooh
22:24:05 <joelteon> should I switch from brew?
22:24:07 <johnw> jfischoff: i think functional package managers are the future
22:24:08 <Enigmagic> jfischoff: for dev teams i think it's better to just dist binaries
22:24:08 <jfischoff> I don’t think a garbage collector is useful there
22:24:16 <johnw> joelteon: if you're willing to roll up your sleeves, yes
22:24:23 <joelteon> i love rolling up my sleeves
22:24:30 <johnw> then come to #nixos and join the fun
22:24:42 <johnw> i've been putting in a ton of work this month to improve OS X support
22:24:43 <jfischoff> carter: the plans are taking too long to come into fruition
22:24:50 <johnw> would like collaborators
22:24:51 <carter> jfischoff: then sponsor the time
22:25:06 <johnw> carter: except that Nix obviates the need for ghc-pkg to do it fro me
22:25:09 <jfischoff> carter: you are witnessing that
22:25:15 <carter> oh?
22:25:48 <carter> haveyou spoken with tibbe/dcoutts?
22:25:58 <jfischoff> me? no not yet
22:26:22 <jfischoff> johnw: how are you using Nix with ghc?
22:26:31 <johnw> I have GHC "environments"
22:26:47 <johnw> so that when I run "load-env-ghc763", I'm inside a shell with complete visibility of GHC 7.6.3 and a ton of packages
22:27:09 <johnw> but additionally, every Haskell package I work on has its own Nix expression, so that I can drop into a subshell with visibility of only its dependencies
22:27:17 <edwardk> johnw has almost sold me on switching even
22:27:41 <johnw> in fact, I have load-env-ghc763, load-env-ghc782 and load-env-ghcHEAD
22:27:49 <johnw> whichever one I start my Emacs from inside of, is the world I work in that day
22:27:50 <LordBrain> what do you use now edwardk ?
22:28:05 <edwardk> just brew
22:28:19 <KatZilla> pavonia: http://lpaste.net/103961
22:28:20 <edwardk> i don't do much dev outside of haskell currently
22:28:23 <jfischoff> johnw: so every package you work on does, but is every haskell package period managed by Nix?
22:28:29 <johnw> no
22:28:42 <johnw> each time I run into a package that isn't managed by Nix yet, I submit a PR
22:28:43 <jfischoff> if that an issue?
22:28:47 <johnw> no
22:28:52 <johnw> you can always create local Nix expressions
22:28:57 <jfischoff> I see
22:29:01 <johnw> you don't have to wait for anything to happen upstream in order to continue on with your work
22:29:19 <jfischoff> you rollup your sleeves so to speak
22:29:25 <jfischoff> and write the nix expression
22:29:39 <johnw> here's a list of what I use, and which is now in Nix: https://gist.github.com/96c17df6dc0e69d0dc30
22:29:54 <LordBrain> i treid to install nix the package manager on debian, using a deb they distribute.. but it just didnt work out of the box, and there was no documentation about how to get it working
22:30:01 <johnw> (the commented out ones don't work yet)
22:30:57 <jfischoff> This is probably obvious to a Nix user, but how does Nix + GHC allow multiple instances of the same package version with different dependencies?
22:31:10 <pavonia> KatZilla: Can't you write an instance ToJSON (Entity (User, Client))?
22:31:14 <johnw> everything uses absolute paths into /nix/store
22:31:24 <johnw> Nix expressions will rewrite paths/provide wrappers to make this ttrue
22:31:46 <LordBrain> jfischoff, there are environments and when you change your enviornment, it sets up symlinks for you or whatever so the correct ghc is in your path
22:32:16 <jfischoff> are you still using ghc-pkg to manage things?
22:32:22 <johnw> no
22:32:25 <johnw> I no longer use ghc-pkg or cabal
22:32:25 <jfischoff> ah
22:32:33 <jfischoff> okay cool
22:32:41 <johnw> note: ghc-pkg list will still work
22:32:45 <johnw> but registering/unregistering will not
22:32:45 <jfischoff> sure
22:32:50 <johnw> because the store is read-only, by design
22:33:15 <carter> so impossoble to bork
22:33:16 <carter> ?
22:33:23 <jfischoff> plus ghc-pkg cabal are strickly less powerful as far as I can tell
22:33:29 <johnw> the golden rule of Nix is: if a thing works, it always works
22:33:49 <jfischoff> so the builds are setup soley through nix expressions?
22:33:54 <johnw> it is an invariant of the system that a correctly installed thing ever becomes incorrect
22:33:59 <johnw> never*
22:34:00 <KatZilla> pavonia: I have not tried yet. But the main question is: is there any elegant way? Because now I have foreign key on client. Its ok to write another instance for ToJSON. But… What If I will have 100+ FK for different data structures? Should I write ToJSON instances for each FK ?
22:34:16 <johnw> jfischoff: correct; except that Nix expressions are extremely flexible
22:34:29 <johnw> jfischoff: they can be "smart" and Nix-y, or they can just be shell scripts effectively
22:34:58 <johnw> it's the only time you get to modify the store -- by adding something to it
22:35:02 <carter> can i do normal cabal install still?
22:35:11 <jfischoff> this all sounds very compelling
22:35:13 <johnw> you could, but it wouldn't go into the Nix store
22:35:19 <pavonia> KatZilla: IMHO, you should have a field :: Maybe Client in User
22:35:32 <jfischoff> so what is missing from replacing cabal?
22:35:34 <johnw> it would go into ~/.cabal/lib as before, and have all the evils inherent
22:35:49 <johnw> jfischoff: well, it does replace cabal for me
22:35:49 <jfischoff> or is building off nix the wrong way forward
22:35:57 <jfischoff> but what about hackage?
22:35:59 <johnw> oh, you mean for everyone
22:36:03 <jfischoff> yes
22:36:28 <johnw> hmm... the lack of docs for one
22:36:34 <johnw> Nix is like playing with Haskell in 2005
22:36:44 <jfischoff> sure, but what about functionality
22:36:55 <pavonia> KatZilla: Or create a wrapper type that takes a User and a Maybe Client, produces the JSON code for user and adds the line for the client
22:37:06 <jfischoff> is there a way to package nix say int the haskell platform
22:37:15 <johnw> well, it manages not just Haskell, but also any libraries that that Haskell code uses
22:37:21 <jfischoff> sure
22:37:27 <johnw> jfischoff: I haven't considered that
22:37:30 <jfischoff> but is something like that feasible
22:37:44 <jfischoff> “embedding” it so to speak
22:37:45 <johnw> it certainly could be
22:37:56 <johnw> where installing HP means a simple Nix installation pre-loaded with GHC and the HP
22:38:04 <jfischoff> right
22:38:08 <LordBrain> thats an interesting idea
22:38:20 <jfischoff> and basically we drop cabal
22:38:25 <johnw> i mean, a bare-bones Nix installation is incredibly small
22:38:36 <johnw> pretty much just a directory and 8 binaries
22:38:44 <carter> you still need cabal to manage the builds
22:38:52 <carter> cabal the lib
22:38:52 <jfischoff> why?
22:38:54 <johnw> Nix expressions use cabal to do the package builds
22:39:00 <LordBrain> well we can have the cabal interface if we want... i think having every project under the sun using one config file format is really nice... look at the benefits for ides like leksah etc
22:39:07 <carter> cabal the lib, not caba-install the binary
22:39:08 <johnw> there is too much intelligence inside the .cabal files to want to replicate in Nix
22:39:14 <johnw> (at least, at this point in time)
22:39:18 <glguy> KatZilla: just build up a Data.Map.Map with the fields you want and hand that to jsonData
22:39:32 <jfischoff> hmm
22:39:37 <glguy> KatZilla: You don't need to write any FromJSON instances yourself
22:39:43 <johnw> right, Nix does "cabal build", and then "cabal copy" into the temp directory that will get copied into the store
22:40:13 <jfischoff> so we keep cabal
22:40:35 <johnw> we keep Cabal as a Haskell-oriented 'make'
22:40:44 <jfischoff> for now
22:40:44 <KatZilla> pavonia: You solution seems legit. I will write a demo code. Can you review it,  if I am on right way?
22:40:47 <johnw> right
22:40:54 <KatZilla> glguy: Template Haskell ?
22:41:20 <glguy> o.O No, shouldn't need that
22:42:28 <pavonia> KatZilla: Yes, but I'm still around for half an hour or so
22:43:30 <jfischoff> johnw: think about it. The Haskell Platform idea. I was talking to mzero tonight, and he is of the mind that Nix style fingerprints, are where all builds systems tend to evolve to. So he might be open to it
22:44:09 <johnw> jfischoff: I'm totally open to helping with that idea
22:44:13 <johnw> I think it has real promise
22:44:19 <jfischoff> johnw: me too
22:44:28 <johnw> plus, I'd like for there to be an easy way to "just get going" with using Nix to improve the Haskell experience
22:44:29 <carter> hows the windows support?
22:45:04 <KatZilla> pavonia: Thank you for your time! I appreciate it!) I will be quick
22:45:07 <johnw> carter: I think it uses mingw
22:45:28 <carter> johnw: jfischoff  if you can get it to setup ghc nicely on windows, you'll win mark
22:45:36 <jfischoff> hmm I think if as community, we can solve the reproducible build issue, well that would be awesome
22:45:47 <jfischoff> carter: true
22:45:48 <glguy> KatZilla: http://lpaste.net/103961
22:46:10 <jfischoff> it must work well on all three tier one platforms
22:46:32 <carter> heck any approach that makes ghc *just work* installation wise on windows would win a lot of people
22:47:01 <carter> and any HP formulee for nix would be decomposable
22:47:06 <carter> so that'd be neat too
22:47:07 <jfischoff> johnw: what is tricky about getting nix to work on OSX?
22:47:20 <johnw> jfischoff: nothing trick that I know of now
22:49:18 <jfischoff> johnw: cool downloading
22:55:08 <KatZilla> glguy: I very thank you! Its cool! Good for Quickwin… But I will try to write some code for ` UserWithJoins` data type. I will contain `User` itself and array of tuples (keyInUserObject, JoinedObject).. For ex: UserWithJoin userFromDb [('client', clientFromDb)]
22:57:00 <KatZilla> glguy: And make ToJSON instance, to insert `"keyInUserObject": (decode clientFromDb)`
23:02:30 <KatZilla> glguy: Is it possible to iterate inside Aeson: object ?
23:02:40 <KatZilla> glguy: for ex:
23:06:26 <KatZilla> glguy: http://lpaste.net/103964
23:10:19 <glguy> \a b -> object ("user" .= a : map (uncurry (.=)) b)
23:10:21 <glguy> would do that
23:10:41 <glguy> or: \a b -> object ("user" .= a : [k .= v | (k,v) <- b])
23:11:59 <KatZilla> glguy: `:` char between `a` and `[k .= …` - is simple concatenation of lists ? like []:1:2 ?
23:12:19 <glguy> (;) is called "cons"
23:12:21 <glguy> ?type (:)
23:12:23 <lambdabot> a -> [a] -> [a]
23:12:30 <glguy> Different from
23:12:32 <glguy> ?type (++)
23:12:33 <lambdabot> [a] -> [a] -> [a]
23:12:48 <KatZilla> glguy: Thank you, my guru )
23:12:50 <glguy> one takes a list and the other takes a single element
23:13:12 <KatZilla> glguy: Its so sad, that domain "http://haskell.guru" is taken ((
23:24:53 * hackagebot exceptions 0.6.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.6.1 (EdwardKmett)
23:25:44 <jle`> i feel almost guilty that ghc was so easy for me to install and get working
23:25:51 <jle`> and i recommend it to my friends and they have the hardest time for some reason
23:25:52 <startling> heh
23:26:33 <jle`> i can't even pretend to sympathize :/
23:26:41 <jle`> emphathise
23:26:47 <jle`> empathize
23:26:54 <jle`> english is so weird
23:27:18 <l0cust> How's it going?
23:44:29 <no-n> :t Infinity
23:44:29 <lambdabot> Not in scope: data constructor ‘Infinity’
23:45:01 <no-n> > 1/0
23:45:02 <lambdabot>  Infinity
23:45:08 <no-n> :t 1/0
23:45:09 <lambdabot> Fractional a => a
23:46:25 <no-n> 0*Infinity is still 0 so how can 1/0 be Infinity?
23:46:46 <sagittarian> :i Fractional
23:47:02 <sagittarian> doesn't work?
23:47:11 <no-n> lambdabot doesn't do :i
23:47:17 <sagittarian> guess not
23:47:27 <no-n> probably because it the output can be huge
23:48:49 <sagittarian> > (-1)/0
23:48:50 <lambdabot>  -Infinity
23:49:02 <sagittarian> > 1/0 + (-1)/0
23:49:03 <lambdabot>  NaN
23:53:43 <no-n> > gcd 0 0
23:53:45 <lambdabot>  0
23:53:49 <no-n> that should be Infinity :P
23:54:00 <sagittarian> > 0 * (1/0 + (-1/0))
23:54:01 <lambdabot>  NaN
23:54:17 <btubbs> I'm trying to get this Scotty + Persistent gist to work: https://gist.github.com/egonSchiele/5400694.  I've fixed a couple import problems, resulting in http://lpaste.net/103846, but am now stumped by this "No instance for (MonadLogger IO)" error: http://lpaste.net/103847 .  help?
23:56:51 <no-n> > let ☕ 💋 = 💋 in ☕ 7
23:56:52 <lambdabot>  <hint>:1:5: parse error on input ‘☕’
23:57:18 <no-n> > let ☕ = 7 in ☕
23:57:19 <lambdabot>  <hint>:1:5: parse error on input ‘☕’
23:57:22 <no-n> :/
23:58:03 <johnw> btubbs: you need to use: runStdoutLogging $ ...
23:58:08 <johnw> at the very least
23:58:15 <btubbs> where?
23:58:30 <johnw> around whichever action has a MonadLogger constraint
23:59:07 <johnw> persistent does
23:59:10 <btubbs> has there been some change in Control.Monad.Logger?  I've seen a other examples like this from around a  year ago that fail the same way
23:59:18 <btubbs> e.g. http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
23:59:18 <johnw> put it in your runDb function
23:59:30 <johnw> runStdoutLogging . runResourceT ...
23:59:38 <btubbs> oki
23:59:51 <johnw> yes, a long time ago there was a MonadLogger instance for IO
23:59:56 <johnw> my logging package provides one, btw
