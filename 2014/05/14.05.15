00:09:55 * hackagebot highlighting-kate 0.5.8.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.8.1 (JohnMacFarlane)
00:09:55 * hackagebot cabal-test-quickcheck 0.1.2 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.2 (TimothyJones)
01:06:51 <Dawid> can someone tell me if leksah is still in development?
01:22:24 <pharaun> i love it when this language guides me to the right answer via types
01:33:21 <hvr> pharaun: it's just like gravity bending space...
01:45:04 <pharaun> indeed
01:45:11 * hackagebot apiary 0.3.2.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.3.2.0 (HirotomoMoriwaki)
02:00:13 * hackagebot yesod-bin 1.2.9.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.9.3 (MichaelSnoyman)
02:10:14 * hackagebot wordpass 0.1.0.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.1.0.0 (MichalGajda)
02:20:15 * hackagebot azure-acs 0.0.1.1 - Windows Azure ACS  http://hackage.haskell.org/package/azure-acs-0.0.1.1 (kapilash)
02:20:17 * hackagebot wordpass 0.2.0.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.2.0.0 (MichalGajda)
02:40:17 * hackagebot ixmonad 0.56 - Embeds effect systems into Haskell using parameteric effect monads  http://hackage.haskell.org/package/ixmonad-0.56 (DominicOrchard)
02:56:26 <ldrndll> Does anyone know if there is a way to insert curly braces in haddock documentation?
02:57:36 <awestroke> ldrndll: tried \{ \} ?
02:58:04 <ldrndll> Yes, unfortunately it interprets that the same as a straight { }
02:58:14 <quchen> Those are curly braces.
02:59:00 <ldrndll> quchen: what I want is for the curly braces to appear in the output
02:59:02 <quchen> Unfortunately, Haddock sometimes requires choosing between HTML documentation and plain code readability. I think there were efforts to make it support markdown, but those did not work very well, for good reasons I believe, but I can't recall them.
03:00:08 <ldrndll> Fair enough. I’ll just use square brackets and note that they should be curly.
03:00:09 <ldrndll> Thanks
03:00:19 * hackagebot api-tools 0.4 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.4 (AdamGundry)
03:01:22 <quchen> Or you could just use curly braces.
03:01:23 <quchen> http://lpaste.net/104165
03:01:46 <quchen> The documentation says "Reverse {a list}.", literally.
03:01:52 <quchen> HTML, that is.
03:03:26 <ldrndll> quchen: aha, I suppose then I should add that this is inside a code block in a cabal description. It seems to be parsed differently as \{ a list \} comes out as \ a list \
03:03:51 <awestroke> ldrndll: what about {{ ?
03:05:07 <zq_> hm
03:05:10 <ldrndll> awestroke: unexpected ‘{‘
03:05:21 <tdammers> quchen: the markdown thing was shot down because it'd produce way too many clashes with existing syntax, and because it wouldn't really fit the data model well
03:05:22 <awestroke> ldrndll: what kind of error? cabal or haddock?
03:06:01 <ldrndll> $ cabal haddock
03:06:02 <ldrndll> cabal: snaplet-sass.cabal:15: unexpected '{'
03:07:24 <quchen> tdammers: I was *this* close to suggesting a new Haddock tag to use markdown like -- ||, but each time I thought someone probably tried that already.
03:08:19 <bonobo123> hi
03:08:33 <bonobo123> return value vs return $! value
03:09:10 <bonobo123> I dimly remember somebody in the internets arguing that (return $! value) is better than (return value)
03:09:18 <bonobo123> what were the reasons?
03:09:28 <tdammers> you can't say that outright
03:09:33 <tdammers> it depends on your strictness needs
03:09:43 <tdammers> :t ($!)
03:09:44 <lambdabot> (a -> b) -> a -> b
03:09:51 <tdammers> :t seq
03:09:52 <lambdabot> a -> b -> b
03:10:03 <bonobo123> how do I know what are my strictness needs?
03:10:20 * hackagebot snaplet-sass 0.1.0.0 - Sass integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-sass-0.1.0.0 (lukerandall)
03:10:21 <bonobo123> in what circumstances (return $! value) is better than the alternative?
03:10:47 <tdammers> when you need `value` to be evaluated strictly
03:10:50 <alpounet> bonobo123: the $! version will force the evaluation of value before calling return
03:11:27 <awestroke> I think the question is when it is beneficial to force the evaluation of a value
03:11:31 <bonobo123> what does this evaluation buy me?
03:11:53 <tdammers> when you're in some sort of stateful monad, e.g. a StateT something, or IO, and you're expecting imperative-like behavior, strict evaluation avoid building up thunks
03:12:39 <tdammers> consider, in a State monad: `do { put "foo"; put "bar"; put "baz"; f <- get; return f }`
03:12:46 <alpounet> bonobo123: imagine that value has been retrieved from a json document. at the moment you call return, your value hasn't necessarily actually been retrieved yet
03:13:01 <alpounet> hecause of laziness
03:13:31 <alpounet> so you might not even have run the json parser yet
03:13:59 <bonobo123> I see
03:14:12 <alpounet> but that means that if you combine a lot of functions doing data retrieval from a json document, well, the actual values you retrieve may be computed all at once, in the end, when you want to say print that value
03:14:39 <bonobo123> does (return $! value) break some monad laws? or is it well behaved?
03:14:48 <tdammers> it's well behaved
03:14:55 <tdammers> it just changes evaluation order
03:15:15 <tdammers> but because the functions that are involved are all pure, this doesn't change the outcome
03:15:42 <bonobo123> (return undefined) >> (return 15) vs (return $! undefined) >> (return 15) ?
03:15:53 <tdammers> undefined breaks everything ;D
03:16:10 <bonobo123> I’m OK with that :)
03:16:16 <quchen> It changes strictness, not necessarily evaluation order. https://github.com/quchen/articles/blob/master/fbut.md#seq-does-not-specify-an-evaluation-order
03:16:24 <bonobo123> actually I owuld like it to break things earlier than it does now
03:17:12 <bonobo123> is there a monad instance somewhere that defines return a = return $! a
03:17:13 <bonobo123> ?
03:18:25 <rekahsoft> hi all..when i upgrade ghc i have to reinstall all cabalized packages..is there any way to automate this?
03:18:48 <quchen> No, that would break Monad laws: "return' undefined >>= f = undefined", but the law requires "return x >>= f = f x" for all x.
03:19:47 <quchen> rekahsoft: Your 'world' file contains all packages you have installed I think, it's somewhere in your .cabal. You can use that as a starting point.
03:19:49 <awestroke> the Eval monad "is a strict identity monad: that is, in (m >>= f) m is evaluated before the result is passed to f." http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html#t:Eval
03:21:01 <quchen> ^ That said, violating Monad laws in the presence of ⊥ is something you're semi-allowed to do, if it's really necessary. (Reader does this too, for example.)
03:21:13 <bonobo123> awestroke: that is what I was looking for
03:22:21 <jophish> Do people every use the Reader monad or does everyone use ((-> a)?
03:22:54 <bonobo123> I use Reader as (->) does not give enough hints about what is going on
03:22:57 <awestroke> jophish: what's ((->a)
03:23:17 <bonobo123> is there something like EvalT? it seems I need a strictness monad transformer…
03:23:21 <quchen> Reader is (a ->) with abuse of notation.
03:23:25 <Iceland_jack> jophish: I use both
03:23:50 <quchen> Reader works well in transformer stacks, bare functions are good for golfing, mostly.
03:24:18 <Iceland_jack> 'join' is one of the few reader instances that I use in non-private code
03:24:35 <Iceland_jack> that's ‘reader’ with lower-case
03:24:53 <fikusz> I'm doing some work on vectors and want to differentiate coordinates (which point somewhere) and offsets (which represent the difference between two coordinates) in the type system. Should I just create a newtype for both and add all the functions I need?
03:25:03 <awestroke> bonobo123: what is your concrete use-case?
03:25:22 * hackagebot RefSerialize 0.3.1.2 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.1.2 (AlbertoCorona)
03:25:23 <quchen> Every time you read "join" you have to think "oh wait is this applied to a function, yes, okay, it's Reader, so it means fx -> fxx". I'm not sure whether that's clearer than, say, a lambda.
03:26:25 <bonobo123> awestroke: my use case is thunks accumulating and exploding stack
03:26:39 <bonobo123> awestroke: I would like them to be evaluated earlier
03:27:10 <bonobo123> awestroke: on top of that there might be some ‘undefined’ or ‘error’ or ‘throw xx’ and I would like it to be thrown earlier than it happens how
03:27:38 <awestroke> bonobo123: rather than forcing evaluation on everything, all the time, I'd try to find the reason for the stack overflow and try making that strict
03:27:58 <awestroke> enforcing strictness everywhere seems like overkill
03:28:21 <bonobo123> awestroke: finding exact place of issue is problematic
03:28:58 <bonobo123> awestroke: on the other hand my style of programming ensures that everything will be needed anyway
03:30:59 <jophish> awestroke: sorry, I meant ((->) a)
03:31:56 <awestroke> jophish: so, passing it as a parameter to the function instead of returning Reader a ?
03:32:09 <tdammers> I like reader monads
03:32:22 <tdammers> but yeah, mostly as part of a stack
03:32:52 <tdammers> current use case is passing stuff through a cascade of HTML templates in a web app
03:33:33 <alpounet> but then you can abstract over the reader monad you want, too, with the MonadReader class
03:33:40 <jophish> awestroke: yeah, just avoiding the Reader newtype
03:33:48 <tdammers> alpounet: true
03:33:58 <tdammers> alpounet: in this particular case, I chose to fix the type though
03:34:08 <tdammers> I have way too much instance magic going on as it stands
03:34:15 <jophish> I've always used Reader because it makes things a little more explicit, I used ((->)a) a little bit the other day and liked the way things looked
03:34:29 <jophish> but I wouldn't want to do it it people would always get surprised whens seeing it
03:34:31 <tdammers> fixing the template monad stack to concrete types makes for easier debugging and more useful eror messages
03:34:33 <alpounet> tdammers: yeah sure, I was pointing it out for jophish mostly, in case he had never heard of it :)
03:34:39 <tdammers> ah, right
03:35:02 <alpounet> tdammers: i've seen your nick around for long enough to guess that you didn't need that information
03:35:07 <tdammers> :D
03:35:43 <tdammers> btw, it does sometimes annoy me that StateT doesn't provide MonadReader
03:35:53 <tdammers> and on other occasions, I am thankful that it doesn't
03:35:54 <tdammers> :P
03:36:19 <alpounet> well, there's MonadReader r m => MonadReader r (StateT s m)
03:36:33 <tdammers> there is? hmm
03:36:46 <tdammers> oh wiat yeah
03:36:51 <tdammers> that's not what I mean
03:37:11 <tdammers> sometimes I want to use functions that want a MonadReader r on a MonadState r
03:37:25 <tdammers> with ask = get
03:37:42 <alpounet> ah yeah ok
03:37:44 <jophish> tdammers: that sounds useful
03:37:53 <jophish> why wouldn't you want that?
03:38:07 <alpounet> but if you ask twice and modify in between, you might be surprised
03:38:17 <jophish> I suppose it conflates state and reader
03:38:35 <tdammers> also, sometimes you have stacks that have both
03:38:43 <tdammers> StateT s (Reader r)
03:39:05 <tdammers> get and put work on the `s` part, but ask reads from the `r`
03:39:09 <jophish> It would be nice to have local in State though
03:39:42 <tdammers> there's `state`
03:39:47 <tdammers> :t state
03:39:48 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:40:24 * hackagebot ixmonad 0.57 - Embeds effect systems into Haskell using parameteric effect monads  http://hackage.haskell.org/package/ixmonad-0.57 (DominicOrchard)
03:40:37 <jophish> ah yes, of course
03:43:40 <fikusz> can I create a functor instance for a simple type (i.e. for one which doesn't have a type parameter)?
03:44:11 <edofic> no
03:44:27 <edofic> standard haskell functors require a type parameter
03:44:44 <fikusz> edofic: is it because the way functor is defined in haskell?
03:45:06 <nclarke> I'm not sure what it would mean for a simply type
03:45:14 <nclarke> A functor maps from Hask -> Hask
03:45:19 <edofic> nclarke, somethink of kind *
03:45:26 <fikusz> nclarke: simply * (and not * -> *)
03:45:52 <edofic> A categorical functor maps from Hask to Hask. But the Functor you get in base is a bit weaker
03:46:07 <nclarke> edofic: To clarify: I know what that means, but I don't know what it would mean to call one a 'Functor'
03:46:58 <fikusz> nclarke: I meant the functor in base (fmap, etc.)
03:47:37 <edofic> fikusz, if you could define a functor say for Int(which hask kind *) what would be the type of fmap when specialized then?
03:47:48 <edofic> i cannot think of anything reasonable
03:48:38 * quchen just spent two hours to realize 10e6 isn't quite 1*10^6. I need Nats. :-x
03:49:27 <fikusz> edofic: I understand, I created a container type and wanted to deal with it like a functor (but it isn't parametrized)
03:49:52 <fikusz> edofic: I'll have to create my type-specific fmap then (I guess)
03:55:51 <edofic> fikusz, you have something like IntSet?
03:57:07 <fikusz> edofic: I want to differentiate between an absolute extent and an offset with newtype, so I don't mix them up accidentally (both are just Int wrapped in a newtype)
03:58:46 <edofic> fikusz, i don't understand. where is your functor?
04:00:41 <fikusz> edofic: there is none, I thought about using fmap to apply functions directly to the Int in my newtype
04:02:09 <edofic> i see. the problem is because a function applied through fmap could return something other than Int. and you could not repackage this
04:02:32 <edofic> you essentially want something like liftWrapper f (Wrapper n) = Wrapper (f n)
04:02:36 <fikusz> edofic: yes
04:02:51 <fikusz> edofic: it looked like a Functor at first glance
04:03:09 <edofic> bescause it in fact is. but not in haskell.
04:03:38 <awestroke> :t Hask
04:03:39 <lambdabot> Not in scope: data constructor ‘Hask’
04:03:42 <awestroke> :k Hask
04:03:43 <lambdabot> Not in scope: type constructor or class ‘Hask’
04:03:47 <fikusz> edofic: thanks, good to know: you learn something here every day
04:04:04 <edofic> Hask is just a name for the categorical notion of haskell types and functions
04:17:59 <jamie_h> I'm trying to return a different type depending on the format of a string input. If it begins with "E 21" I want it to return Error 21
04:18:08 <jamie_h> how can you pattern match strings in a case statement?
04:18:34 <jamie_h> case (head s) of 'E' -> (Error ???)
04:18:55 <quchen> You cannot return a type depending on a value.
04:19:12 <quchen> What type did you imagine your function should have?
04:19:54 <jamie_h> String -> LogMessage
04:20:03 <jamie_h> where LogMessage = Error | Info | Message
04:20:36 <quchen> Ah, so you want to return a different *data constructor* depending on the input. That is something different, and very common to do.
04:21:30 <jamie_h> yeah
04:21:54 <jamie_h> I'm having trouble getting the arg to supply to the Error data constructor
04:21:58 <jamie_h> it needs to be an Int
04:22:08 <jamie_h> but it involves parsing the input string some how
04:22:11 <jamie_h> in a case statement
04:22:43 <awestroke> jamie_h: case (words s) of ("E":code) -> Error code
04:23:02 <yitz> awestroke: 'E'
04:23:12 <jamie_h> but when code will be " 21 foofoofooo....etc"
04:23:13 <quchen> No, "e".
04:23:13 <yitz> oh i see
04:23:34 <awestroke> jamie_h: or rather: case (words s) of ("E":code:_) -> Error code
04:23:51 <Iceland_jack> and remove all parentheses :)
04:24:13 <awestroke> Iceland_jack: I always let hlint decide that stuff
04:24:19 <jamie_h> there's a space before and after the int
04:24:27 <jamie_h> plus the int can be more than 1 digit
04:24:56 <jamie_h> "E 99 foo"
04:24:58 <byorgey> jamie_h: check out the 'words' and 'read' functions
04:25:06 <awestroke> jamie_h: yeah, words splits a string into many strings on
04:25:09 <awestroke> ' '
04:25:11 <jamie_h> ah okay
04:25:14 <quchen> My advice here is to learn how to write parsers, using Parsec or Attoparsec, for example.
04:25:29 <jamie_h> words looks ideal - i forgot it ignores spaces
04:25:43 <byorgey> no, jamie_h is clearly doing my assignment #2, and the point is to NOT use a parser combinator library =)
04:25:56 <jamie_h> haha! I am byorgey
04:26:17 <jamie_h> good course, by the way :)
04:26:27 <byorgey> thanks, glad you're enjoying it =)
04:26:31 <jamie_h> I have to run - thanks for everyone's help
04:28:26 <yitz> heh i wonder if jamie_h having to run was related to byorgey showing up
04:28:45 <byorgey> hehe
04:29:22 <byorgey> I mean, I am not actually teaching the class right now, and even when I do I encourage my students to ask questions on IRC =)
04:29:58 <yitz> byorgey: it can still be a bit embarassing though
04:30:06 <byorgey> yes, I suppose so
04:50:32 * hackagebot scientific 0.3.1.0 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.1.0 (BasVanDijk)
04:55:32 * hackagebot instant-generics 0.4 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.4 (JosePedroMagalhaes)
04:58:32 <remib> Hi.
05:00:24 <remib> I'm trying some haskell and have written a function taking "random" bits and generating a corresponding graph : http://lpaste.net/2817631638622568448 . Can somebody judge my code ?
05:01:26 <nh2> remib: your nested lets are not necessary
05:01:35 <nh2> you can collapse them together
05:04:20 <remib> nh2, right, thanks
05:04:41 <nh2> remib: also you can write `reverse [1 .. (n-1)] ` as `[n-1,n-2..1]` which will be a good bit faster
05:05:11 <byorgey> remib: instead of  map snd $ filter fst $ zip r $ reverse [1 .. (n-1)]  you can write   map snd . filter fst . zip r . reverse $ [1 .. (n-1)]  which is generally considered better style
05:05:33 * hackagebot FComp 1.0 - Compose music  http://hackage.haskell.org/package/FComp-1.0 (JosePedroMagalhaes)
05:08:08 <nh2> remib: and your llist might look nicer with a list comprehension, like [ i | (p, i) <- zip r [n-1,n-2..1], b ] (you can put bools in the right hand side of list comps and they act as filter predicates
05:12:09 <remib> nice! for the [n-1, n-2 ..1] part: I tried to do "[n-1 .. 1]" instead of "reverse [1 .. n-1]" but it returned the empty list. Why does this version work ?
05:16:38 <saep> remib: By default the steps for the elements in the list are (+1) (or succ). Also, you won't always get an empty list.
05:16:39 <eizo> remib: if you don't put the second element i think it assumes that you're going up
05:16:53 <saep> > let f n = [n-1 .. 1] in f 0
05:16:54 <lambdabot>  [-1,0,1]
05:21:48 <skypers> hi
05:22:02 <skypers> do you know a way to construct naturals?
05:22:06 <skypers> nats?
05:22:18 <skypers> I’d like the typechecker to fail on -2
05:22:20 <skypers> for instance
05:23:05 <DanielDiaz> skypers: the typical way is: data Nat = Zero | Succ Nat
05:23:40 <skypers> ok
05:23:42 <skypers> sounds great
05:23:45 <DanielDiaz> skypers: where Zero is 0, Succ Zero is 1, Succ (Succ Zero) is 2, etc
05:23:54 <skypers> I’m gonna have a look to nats
05:24:04 <DanielDiaz> skypers: as you can see, it is impossible to construct negative numbers
05:24:19 <skypers> :t Natural
05:24:20 <lambdabot> Not in scope: data constructor ‘Natural’
05:24:30 <skypers> > 0 :: Natural
05:24:32 <lambdabot>  0
05:24:38 <skypers> > 0 - 2 :: Natural
05:24:39 <lambdabot>  *Exception: Natural: (-)
05:24:50 <skypers> huhu, it’s not compile time
05:25:16 <merijn> skypers: That won't work i you want to use the Num typeclass
05:25:22 <skypers> I don’t
05:25:27 <merijn> So you have to pick, Num typeclass or typechecking
05:25:29 <skypers> I just want to represent numbers
05:25:33 <skypers> without arithmetic at all
05:25:39 <skypers> (to express numeric semantic)
05:25:45 <merijn> For what?
05:25:57 <skypers> merijn: GLSL semantics
05:26:21 <skypers> I turn the semantic to Word8
05:26:27 <skypers> there’re restrictive semantics
05:26:28 <skypers> for instance
05:26:32 <skypers> [0..16] is reserved
05:26:50 <skypers> the user can build a semantic with a function sem :: Word8 -> Semantic
05:26:55 <skypers> and this is an issue
05:27:00 <skypers> because he can do that:
05:27:03 <skypers> sem (-2)
05:27:28 <skypers> sem x = 16 + x
05:27:33 <skypers> it’s the same issue with
05:27:36 <skypers> sem x = 16 + abs x
05:27:43 <skypers> it’ll be even worse
05:27:59 <merijn> I was looking at an efficient way to deal with this, but it's not anywhere close to usable yet
05:28:26 <skypers> merijn: I think the simpler way is to detach numeric literals from Num
05:28:28 <skypers> in GHC
05:29:40 <skypers> a Word8 can be negative
05:29:44 <skypers> can’t*
05:29:45 <skypers> so h
05:29:46 <skypers> hm
05:30:10 <skypers> I could wrap it in Semantic
05:30:21 <skypers> and not implement Num
05:33:01 <skypers> @newtype NumSem = NumSem { sem :: Word8 } deriving (Eq,Ord,Read,Show)
05:33:01 <lambdabot> Unknown command, try @list
05:33:07 <skypers> @data NumSem = NumSem { sem :: Word8 } deriving (Eq,Ord,Read,Show)
05:33:07 <lambdabot> Unknown command, try @list
05:33:15 <skypers> @let newtype NumSem = NumSem { sem :: Word8 } deriving (Eq,Ord,Read,Show)
05:33:17 <lambdabot>  Defined.
05:33:35 <skypers> @let offSem :: NumSem -> Word8; offSem (NumSem s) = 16 + s
05:33:36 <lambdabot>  Defined.
05:33:49 <skypers> > NumSem (-1)
05:33:51 <lambdabot>  NumSem {sem = 255}
05:34:00 <skypers> this is not really great, but it’s a start I guess
05:34:15 <skypers> yeah well
05:34:18 <skypers> an exception would be better
05:34:21 <skypers> I’m gonna use nats.
05:35:23 <exfalso> hi, i have a cabal project which has an executable that generates haskell sources needed for a library (same project). Is there a way to express this using cabal? for example an option to run a shell command before compilation?
05:35:47 <exfalso> the generator is custom, not c2hs or cpphs
05:36:42 <merijn> exfalso: No, cabal can't really automatically install build tools atm
05:37:25 <skypers> merijn: is it planned?
05:37:28 <remib> Thanks all for the help
05:37:31 <skypers> it can run hsc2hs
05:37:37 <skypers> or hapy
05:37:40 <skypers> happy*
05:37:43 <skypers> or that kind of stuff
05:38:07 <merijn> skypers: Only if they're installed
05:38:15 <nh2> exfalso: you could write a custom Setup.hs
05:38:15 <merijn> skypers: If happy is not installed cabal will just fail
05:38:21 <exfalso> merijn: yeah, just found this: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/Builtin.hs
05:38:42 <exfalso> nh2: true, will try that, thx
05:39:01 <skypers> nice idea, the custom Setup.hs
05:39:33 <nh2> exfalso: if you get something reliably working with that, please send :)
05:46:21 <exfalso> solved it without the need for a custom Setup.hs
05:46:34 <exfalso> you can say cabal build exe:generator
05:46:55 <exfalso> then your (non-cabal) build system will build the files
05:47:02 <exfalso> then cabal build lib:whatever
05:47:11 <exfalso> with the now existing sources
05:50:39 * hackagebot kure 2.16.0 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.0 (NeilSculthorpe)
05:55:40 * hackagebot kure 2.16.1 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.1 (NeilSculthorpe)
06:01:29 <jophish> Are there any reasons other than 'convention' as to why shadowing variables is a warning rather than an error?
06:02:30 <bennofs> jophish: shadowing is valid in Haskell2010, which is what GHC accepts by default if you don't set any flags (with some minor exceptions)
06:03:08 <bennofs> jophish: you can make warnings behave like errors by setting -Werror
06:03:10 <tdammers> shadowing is well-defined and unambiguous... it's just not a good idea in terms of readability and reasoning
06:03:35 <jophish> bennofs: sure, I was asking what reasons are there for it to be defined in Haskell2010
06:04:02 <bennofs> also, it's controvers. Some people believe that disallowing shadowing leads to less readable code, and I some cases, I found myself giving less-descriptive names to identifiers to avoid shadowing
06:04:13 <jophish> tdammers: I suppose so. Although I wonder how many libraries there are in hackage which have shadowed variables in
06:04:33 * merijn always disables the shadowed variable warning
06:04:35 <jophish> bennofs: but then ghc -Wall shouts at you
06:04:47 <merijn> jophish: You can just silence the warning...
06:04:52 <bennofs> jophish: you can use -fno-warn-name-shadowing
06:05:23 <tdammers> either way, making it an error by default would be bad, because then it would break if you use it intentionally
06:05:32 <nh2> exfalso: ah, yes - I thought you needed the whole thing to work automatically when you just call "cabal install"
06:05:41 * hackagebot ideas 1.2 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-1.2 (BastiaanHeeren)
06:07:21 <jophish> I'd not considered that it could lead to more readable code. I guess that's the case some of the time.
06:07:37 <jophish> Thanks all
06:10:41 * hackagebot wordpass 0.3.0.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.3.0.0 (MichalGajda)
06:45:36 <jophish_> When AMP hits in ghc 7.10 is everyone going to 's/return/pure/g'?
06:47:15 <albeit> I seem to have two different versions of the package bytestring installed... 0.10.4 in ~/ghc (where the ghc executable is), and 0.10.2 in ~/.ghc. How can I "merge" them? Different imports and importing different ones, then conflicting.
06:47:28 <albeit> *are importing
06:47:31 <merijn> jophish_: Why bother?
06:47:45 <merijn> albeit: You can't
06:48:01 <merijn> albeit: You will need to rebuild one of your two dependencies to use the same ByteString as the other
06:48:06 <jophish_> merijn: It's less characters to type :) (for future code)
06:48:15 <albeit> merijn: Okay
06:48:26 <tdammers> merijn: I'd love to see some sort of mechanism that could resolve this
06:48:29 <merijn> albeit: 'ghc-pkg unregister' can unregister packages so you can safely recompile
06:48:46 <tdammers> I just got bitten by the Data.Map -> Data.Map.Strict/Lazy shift between containers-0.4 and 0.5
06:48:54 <merijn> tdammers: I believe there are plans to allow libraries to have different dependency versions as long as they are quarantined
06:49:06 <tdammers> "quarantine", yeah, that's a good term
06:49:07 <merijn> tdammers: i.e. you can depend on multiple ByteString versions as long as they never get exchanged
06:49:13 <tdammers> exactly
06:49:26 <merijn> Which well improve things a little
06:49:40 <merijn> albeit: Alternatively, you can try compiling dependencies in a sandbox
06:50:08 <merijn> albeit: Depends on how badly things are broken. Also, it's of course possible that your dependencies really do have incompatible constraints (although not highly likely)
06:51:30 <albeit> merijn: I'll try rebuilding one of the dependencies, except... I can't tell what the dependency is. This is the error message on compile: http://lpaste.net/104169 It looks like it's saying this ByteString != ByteString!
06:52:06 <tdammers> albeit: several modules export a ByteString type
06:52:31 <dmwit> This looks like you have linked two different versions of ByteString.
06:52:46 <tdammers> yeah, hehe... this is not the typical Strict/Lazy confusion
06:52:46 <dmwit> The ByteString types from the two versions are not considered the same type.
06:53:05 <albeit> I only import one ByteString, but I also import Data.Aeson and Data.Aeson.Types... possible conflict with ByteSTrings there?
06:53:40 <tdammers> yeah
06:53:45 <merijn> albeit: You're package is trying to depend on version A of ByteString while Aeson (or something else) is trying to depend on version B of ByteString
06:53:47 <tdammers> are you building with cabal, or just plain ghc?
06:53:56 <dmwit> Possibly. cabal should warn you if you try to build with multiple versions of a single package.
06:53:56 <merijn> albeit: And version A and B of ByteString are not compatible
06:54:01 <albeit> tdammers: cabal
06:54:24 <tdammers> weird... it usually refuses to compile at all when that happens
06:54:29 <albeit> Well, I did --forcereinstalls when I installed aeson :S
06:54:34 <dmwit> don't do that
06:54:37 <albeit> Which probably wasnta  great idea
06:54:41 <albeit> dmwit: Yeah...
06:54:51 <dmwit> ghc-pkg check
06:54:53 <dmwit> now
06:55:09 <tdammers> sandboxed build?
06:55:15 <tdammers> if so, delete sandbox and try again
06:55:23 <albeit> A few packages are broken... void semigroups nats conduit.
06:55:35 <albeit> tdammers: It wasn't sandboxed
06:56:02 <dmwit> The usual correct solution to this problem is: cabal install --reinstall list all packages you want installed at all ever, including the one that currently is not building, here
06:56:28 <dmwit> And then hope the constraint solver agrees it's possible to have them all installed at once. =)
06:56:32 <albeit> dmwit: Okay, I'll do that.
06:56:36 <dmwit> Or at least tells you clearly why it's not possible.
06:56:55 <albeit> dmwit: For future reference, if I need to install a package that won't install with --forcerecompile, should I then just do the same cabal --reinstall [everything]?
06:57:05 <dmwit> albeit: right
06:57:34 <dmwit> albeit: Although in most cases cabal will tell you which packages would break, and then you can just reinstall those.
06:58:24 <ManateeLazyCat> Hi all, long time no see. ;)
06:58:31 <dmwit> welcome back!
06:58:51 <ManateeLazyCat> dmwit: Haha, how are you? ;)
06:59:31 <dmwit> Pretty good. I am deep in technical writing.
06:59:46 <dmwit> Have you been staying busy?
07:00:37 <ManateeLazyCat> dmwit: http://www.linuxdeepin.com/index.en.html My own Linux operating system. ;)
07:00:53 <dmwit> ...whoa
07:01:02 <ManateeLazyCat> dmwit: Just release Deepin 2014 beta today: http://planet.linuxdeepin.com/archives/6335
07:01:51 <dmwit> you dream big!
07:03:27 <ManateeLazyCat> dmwit: Thanks, I'm develop Linux Deepin from 2011 to 2014, have been too much code on Python/C/Golang/CoffeeScript ...
07:03:45 <albeit> dmwit: When I try and doing the full reinstall, it warns me that ghc-7.8.2 and Cabal-1.18.1.3 are likely to be broken, and offers doing --force-reinstalls. But breaking ghc doesn't sound good.
07:04:14 <dmwit> No, don't break ghc.
07:04:32 <albeit> Actually the only actual reinstall is it is changing all bytestring 10.4 to bytestring 10.2
07:04:32 <dmwit> You can add --constraint "foo installed" if it's trying to reinstall foo and that's what's breaking things.
07:05:01 <dmwit> e.g. if it's trying to reinstall "directory" or another core library.
07:05:02 <albeit> Exact message: "(reinstall) changes: bytestring-0.10.4.0 -> 0.10.2.0"
07:05:12 <dmwit> Maybe paste full output somewhere.
07:05:15 <dmwit> ?lpaste
07:05:16 <lambdabot> Haskell pastebin: http://lpaste.net/
07:05:28 <dmwit> But I've got to run. (sorry)
07:05:49 <albeit> No worries. For anyone else that knows this stuff: http://lpaste.net/104170
07:06:04 <albeit> It looks like I just need to downgrade bytestring, can I do that directly instead of reinstalling everythign?
07:06:08 <albeit> dmwit: Thanks!
07:09:40 <ManateeLazyCat> dmwit: What Haskell happend in 3 years?
07:10:14 <ManateeLazyCat> dmwit: I think i miss so much in 3 years. ;)
07:12:55 <byorgey> albeit: no, downgrading bytestring will break those other things.
07:13:20 <byorgey> albeit: can you paste the output of  cabal install --reinstall --dry-run -v3 aeson network  ?
07:13:31 <byorgey> albeit: also, why are you trying to reinstall aeson and network?
07:14:24 <albeit> byorgey: Because I had multiple versions of bytestring installed that broke some imports... it was suggested I reinstall all packages I need. Actually just tried the reinstall again and everything is working magically...
07:14:35 <byorgey> hehe, ok
07:16:48 <klrr_> does operators "in the middle" like >>= + == etc. called precisly?
07:16:54 <klrr_> what*
07:17:09 <benzrf> klrr_: infix operators?
07:17:26 <klrr_> benzrf: thanks, exactly the word i was seeking
07:17:56 <merijn> albeit: "--force-reinstalls" is pretty much almost always wrong
07:18:15 <merijn> albeit: Does your code depend on cabal/ghc?
07:18:23 <albeit> merijn: Yep, learning that the hard way!
07:18:46 <albeit> merijn: Not quite sure... it depends on base and uses ghc to compile, but not the source of ghc.
07:19:19 <merijn> albeit: Which packages are you using? Can you lpaste your cabal file?
07:19:47 <albeit> merijn: Everything is working now, but yes I can.... but what is my cabal file?
07:20:07 <albeit> Is it .cabal/world?
07:20:49 <tdammers> usually myproject.cabal
07:21:05 <tdammers> (where 'myproject' is the name of your project/package)
07:21:34 <ion> ManateeLazyCat: Cool! Welcome back.
07:21:40 <albeit> tdammers: Ah, I don't have one ;)
07:22:06 <ManateeLazyCat> ion: Thanks. ;)
07:23:30 <ManateeLazyCat> RMS in China: http://ww1.sinaimg.cn/bmiddle/7d22f047gw1egf2atmmzaj215o0rsq8b.jpg
07:30:21 <sm> yes welcome back ManateeLazyCat
07:31:14 <hunt> is there a way to refer to the result of the last call in ghci?
07:31:45 <imalsogreg> hunt: it
07:35:53 * hackagebot wai-digestive-functors 0.3 - Helpers to bind digestive-functors onto wai requests  http://hackage.haskell.org/package/wai-digestive-functors-0.3 (StephenWeber)
07:41:54 <jle`> it only orks on things that don't error
07:42:00 <jle`> unfortunately
07:42:32 <jle`> which discludes (uninludes? does not include?) things that are valid results but error on the Show part
07:42:47 <vise890> hey all. I'm writing a [ coloredStr :: Color -> String -> String ] function that wraps  System.Console.ANSI . The color type constructor is defined in System.Console.ANSI . coloredStr is in a module called TodoList.Utils where i `import System.Conosle.ANSI` . The problem i'm facing is that whenever i import TodoList.Utils, I also have to import System.Console.ANSI or i don't get the data constructors (Red|Blue|etc.). what can i do? thanks fo
07:42:47 <vise890> r the help
07:43:28 <bitraten> Is there a better way to model this: https://gist.github.com/bitraten/8394edbbd183d06bc4cf ?
07:45:42 <chrra> vise890: You add an explicit export of Color in TodoList.Utils. "module TodoList.Utils (module TodoList.Utils, Color(..)) where ..."
07:48:06 <vise890> yup i *just* figured it out. I was missing the `(..)`
07:48:27 <vise890> chrra: thanks tho
07:48:33 <chrra> Np.
07:50:26 <hunt> guys what does irreducible constraint mean
07:50:27 <hunt> ?
07:51:07 <yubrew> do any of you guys use haskell for web dev?
07:51:24 <yubrew> (or gals)
07:51:44 <jle`> aye
07:52:29 <benzrf> hmmm
07:53:18 <benzrf> is there a framework for haskell that takes advantage of do-notation to achieve something like Seaside?
07:53:35 <CindyLinz> yubrew: There are many in channel #yesod and #snapframework
07:53:47 <kamila> hello, I have a newbie question: I have a function of type (Float, Float) -> Color that represents an image, and I'd like to display it in a viewport that can be zoomed and panned, could anyone point me to a good library or something? I am currently looking into Gloss, but I can't find a simple way to do this...
07:54:17 <yubrew> CindyLinz: thanks!
07:54:36 <CindyLinz> ^^
07:55:27 <DanielDiaz> if I do not change the exposed functions in a package, but I do change its dependencies, do I have to increase the major version component?
07:55:39 <benzrf> DanielDiaz: in semver?
07:55:57 <DanielDiaz> benzrf: semver?
07:56:01 <benzrf> semantic versioning
07:56:21 <benzrf> iirc x.y.z z is for bugfixes, y is for backwards compatible extensions, and x is for backwards incompatible changes
07:56:31 <benzrf> *in semver
07:56:47 <DanielDiaz> exactly
07:56:59 <benzrf> well
07:57:15 <benzrf> how do you define backwards incompt
07:57:17 <benzrf> *incompat
07:57:47 <DanielDiaz> well, I am not changing anything in the interface, so any code using it should still build with no changes
07:58:07 <DanielDiaz> however, since I am depending in another package now, I am not sure about the consequences of this
07:59:31 <DanielDiaz> the PVP states "Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change."
08:02:00 <DanielDiaz> so it seems I should increase the major version, but it seems too radical to me because the users of my library would think I have made some backwards incompatible changes that I actually haven't done
08:03:35 <merijn> benzrf: Hackage uses PVP, not semantic versioning
08:04:11 <benzrf> whats PVP?
08:04:17 <DanielDiaz> http://www.haskell.org/haskellwiki/Package_versioning_policy
08:04:21 <benzrf> oh
08:05:46 <plosi> Could not deduce (a1 ~ [a1])
08:05:46 <plosi>     from the context (Ord a)
08:05:46 <plosi>       bound by the type signature for bubbleSort :: Ord a => [a] -> [a]
08:05:50 <plosi> Hey, I am new to haskell, and I am having trouble discerning the meaning of this error message
08:06:01 <benzrf> plosi: ~ is the type equality operator
08:06:01 <c_wraith> plosi: ~ is the type equality operator
08:06:05 <c_wraith> jinx!
08:06:05 <benzrf> c_wraith: whoa
08:06:37 <c_wraith> plosi: that error message means that you're using a value as both a single element of a list, and as a list of elements of that same type
08:06:44 <bennofs> plosi: can you show the code that produced this error? (if it's more than one line, please use:
08:06:47 <bennofs> ?lpaste
08:06:47 <lambdabot> Haskell pastebin: http://lpaste.net/
08:06:52 <albeit> If I have a function "runListener :: StateT Network IO ()", and another function "runNetwork :: StateT Network IO ()", how I can fork a thread to run runListener from runNetwork?
08:06:54 <c_wraith> plosi: that usually is the result of confusing (:) and (++), for beginners
08:08:08 <benzrf> plosi: lrn2homogeneouslist
08:08:40 <c_wraith> albeit: first, you'll have to be aware that StateT and concurrency don't mix, and figure out if that's what you really want at all.
08:09:05 <plosi> bennofs: http://lpaste.net/104174
08:09:43 <c_wraith> albeit: anything you do will result in the forkIO'd part running an independent StateT computation, and any changes it makes won't be reflected in the context that forkIO'd it
08:10:00 <albeit> c_wraith: Ah, okay, then that is not what I want.
08:11:02 <tdammers> State(T) is actually kind of a misnomer, it doesn't really implement mutable state, just wraps dragging some state along as return values / extra arguments
08:11:03 <albeit> c_wraith: Rought sketch of what I'm trying to do... I have a StateT computation that needs to start a thread that can update the initial StateT... is there a way to pass values from a new thread back to the thread that started it?
08:11:09 <tdammers> well, misnomer, maybe not
08:11:32 <tdammers> the point being, despite the apparent semantics, it does not mutate any variables; it's still all pure
08:11:56 <c_wraith> albeit: MVar, TVar, IORef..  Any of the mutable structures.
08:12:39 <c_wraith> albeit: but in that case, you're better off using ReaderT over a (collection of) mutable value(s)
08:12:51 <albeit> Ahhh gotcha. Using a Control.Concurrent.Chan for some other inter-thread stuff, guess I could use that here as well
08:13:02 <albeit> I'll look at ReaderT
08:13:26 <benzrf> dert
08:14:13 <c_wraith> plosi: the problem is line 5
08:14:27 <plosi> Yeah, I just figured out that my pattern matching was wrong
08:14:30 <c_wraith> plosi: you want to match against (x:y:ys), not [x:y:ys]
08:14:43 <c_wraith> plosi: the latter is a valid pattern, but it doesn't mean what you want
08:15:01 <sruz25> so I've matched a list of tuples like this: ((a,b):rest) but when I want to see whether rest is empty with "rest == []" it throws error saying that there's no function (Eq myType) whre myType is the second element of tuple. Any idea what's wrong?
08:15:04 <c_wraith> plosi: it means "a list containing a single element, that is a list that matches..."
08:15:26 <c_wraith> sruz25: to check if a list is empty, use null instead of (== [])
08:15:30 <c_wraith> :t null
08:15:31 <lambdabot> [a] -> Bool
08:15:35 <c_wraith> :t (== [])
08:15:36 <lambdabot> Eq t => [t] -> Bool
08:15:40 <sruz25> c_wraith: ah, thanks
08:16:16 <c_wraith> sruz25: the difference is that == needs to be able to handle when the lists are non-empty, so it puts extra restrictions on the element type..  That is, it restricts them to be things that can be tested for equality
08:16:20 <plosi> c_wraith: Ah, okay, I think i've got it now.
08:17:08 <c_wraith> plosi: that's one of the most common gotchas for beginners.  List matching sugar is easy to make that mistake with until you're comfortable with it.
08:18:21 <plosi> c_wraith: Yeah, I've just gotta get more comfortable with the language. It's quite different from writing code in C. haha.
08:18:30 <sruz25> I see, that's good to know
08:20:28 <r4pha> I can use GHCI to that [] is an instance of Functor, that is, it implements fmap. Is there a way to see _how_ [] 'implements' fmap in GHCI?
08:20:34 <r4pha> too see that*
08:20:39 <dgpratt> I'm looking for a function :: (a -> Bool) -> [a] -> [[a]] that would begin a new sub-sequence whenever the predicate was true for an element of the original sequence
08:20:45 <c_wraith> r4pha: no, ghci can't tell you about source
08:20:53 <dgpratt> hoogle doesn't seem to know of such a thing
08:20:57 <c_wraith> r4pha: (though in the case of [], fmap is just map)
08:21:00 <bennofs> dgpratt: splitWhen from the split package
08:21:00 <dgpratt> does anyone else?
08:21:03 <bennofs> @hoogle splitWhen
08:21:03 <lambdabot> No results found
08:21:06 <bennofs> :o
08:21:30 <bennofs> dgpratt: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:splitWhen
08:21:36 <c_wraith> dgpratt: whenever you want that sort of thing, check the split package.
08:21:56 <dgpratt> ah, very good, thanks bennofs, c_wraith
08:22:14 <r4pha> c_wraith: thanks. I can see in GHCI that the definition is in GHC.base. The most efficient way to view it would be to go on hoogle and check it out, then?
08:22:43 <dgpratt> funny, I created a LINQ extension method to do this and I was wondering if there was a better name than what I came up with: "SplitWhen"
08:23:04 <dgpratt> maybe my subconscious knew about the Haskell version already :)
08:23:18 <c_wraith> r4pha: when that works, yes.  Sadly, sometimes it doesn't, and you're not going to do any better than browsing the library source.
08:23:44 <kamila> I have a function of type (Float, Float) -> Color that represents an image, and I'd like to display it in a viewport that can be zoomed and panned, could anyone point me to a good library or something?
08:23:53 <r4pha> c_wraith: thanks a lot :)
08:24:20 <c_wraith> r4pha: though for the specific case of Functor, there's only one correct implementation for any Haskell type that can be an instance of it..  You learn to just intuit what that implementation is based on the definition of the type.
08:25:48 <r4pha> c_wraith: interesting. I was specifically looking for functor implementations because I'm still not comfortable with its type signature. I just wanted to check out some real implementations
08:26:28 <c_wraith> r4pha: ah.  Then yeah, exploring the definitions for the types in base is a good idea
08:27:26 <r4pha> c_wraith: thanks
08:35:23 <bergey> kamila: I think JuicyPixels can take such a function to an image.  See http://hackage.haskell.org/package/JuicyPixels-3.1.5.2/docs/Codec-Picture.html#v:generateImage  I'd probably use OpenGL or Gtk for the UI
08:37:57 <jle`> @src [] fmap
08:37:57 <lambdabot> fmap = map
08:38:08 <jle`> ^^ r4pha
08:38:38 <kamila> bergey: thanks a lot, I'll look into it :)
08:39:11 <jle`> i think repa might have libraries for rendering things like that?
08:39:18 <jle`> er, modules
08:51:03 * hackagebot apiary 0.4.0.0 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.0.0 (HirotomoMoriwaki)
08:51:05 * hackagebot apiary-cookie 0.4.0.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.0.0 (HirotomoMoriwaki)
09:01:04 * hackagebot hpc-coveralls 0.3.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.3.0 (killy971)
09:06:46 <Fuuzetsu> @src Maybe fmap
09:06:46 <lambdabot> fmap _ Nothing       = Nothing
09:06:46 <lambdabot> fmap f (Just a)      = Just (f a)
09:06:48 <Fuuzetsu> cool
09:07:08 <Fuuzetsu> @src (->) f fmap
09:07:08 <lambdabot> Source not found. Just try something else.
09:15:19 <pranz> @src ((->) e) fmap
09:15:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:17:02 <bernalex> what do I do when I want to compose a function that gives strict text, with a function that takes lazy text?
09:19:37 <lispy> bernalex: there is a conversion function
09:19:43 <bernalex> lispy: do you remember its name?
09:19:50 <bernalex> lispy: I have used it but can't remember it
09:20:01 <pseudolio> fromChunks?
09:20:26 <lispy> http://hackage.haskell.org/package/text-1.1.1.2/docs/Data-Text-Lazy.html#v%3afromStrict ?
09:20:37 <bernalex> lispy: ah, probably. thanks!
09:21:43 <lispy> it's pretty inefficient to do that
09:21:49 <lispy> So, only do it as necessary
09:31:15 <albeit> I'm getting a type error "Could not deduce" in a function implementation... the relevant code and error message are here: http://lpaste.net/104176. Why can't it deduce that NetworkStatusUpdate is an instance of MsgContents, when its explicitly instanced?
09:32:19 <r4pha> jle`: cool! thanks
09:33:05 <jfischoff> albeit: the signature says you can take all a’s that have a MsgContents constraint, but the implementation only works a particular instance
09:33:42 <albeit> I forgot one line in that paste... I also have an implementation "process Message _ _ = return False"
09:33:53 <albeit> Shouldn't that last one cover all other instances?
09:33:54 <geekosaur> albeit: remember that if you claim "any a where ..." you are not saying you are free to produce any such a, but the caller can demand any such a
09:34:16 <glguy> If you want different implementations for different types you'll need to make that method a part of your class
09:34:28 <glguy> or write your method in terms of methods in your class that make that distinction
09:34:40 <pseudolio> Don't use the word "any". :)
09:34:44 <lispy> bernalex: I have the efficiency issue backwards. It's lazy to strict that is not so great.
09:36:56 <albeit> jfischoff: So processMessage has to be a method of MsgContents, and NetworkMessage has to implement processMessage when instancing MsgContents?
09:37:30 <jfischoff> albeit: probably, or some subset of the functionality of processMessage
09:37:51 <chirpsalot> This is a silly little program: http://is.gd/WgAvwt could I have done better?
09:37:54 <jfischoff> albeit: back to your comment about the case statement
09:38:06 <jfischoff> albeit: I see your confusion there. You can’t pattern match on a polymorphic value. Pattern matching is tied to a specific type.
09:38:45 <yitz> lispy: i don't think there's one direction or the other that's inherently inefficient. the problem is when you need one kind but convert to the other.
09:39:00 <jfischoff> polymorphic value is probably not the most precise phrasing, but hopefully the point is still understandable
09:39:05 <chirpsalot> Basically takes a file of firstname:email entries and a file of full names and generates a file of email entries for only those names (with some choices because some first names have multiple entries). Prof wanted it to e-mail the people who had accepted papers.
09:39:20 <glguy> converting from strict to lazy is a matter of wrapping in a chunk constructor
09:39:31 <albeit> jfischoff: If I can't pattern match, can I case on "a" (whatever I call it), and have one case clause match against NetworkStatusUpdate? Or is that effectively just pattenr matching...
09:39:33 <glguy> going lazy to strict can require concatenating the chunks together
09:39:36 <pseudolio> It says it costs O(c).
09:39:38 <chirpsalot> I haven't done much Haskell, so some feedback would be nice :).
09:39:39 <yitz> lispy: so if you need lazy because you are reading a big stream, and you convert to strict (without extra care), you get the whole big stream in memory.
09:40:05 <jfischoff> albeit: they are both pattern matches, so not luck there
09:40:14 <yitz> lispy: whereas if you need to avoid building up thunks, converting from strict to lazy will defeat that unless you take care.
09:41:43 <hakujin> chirpsalot: grab hlint (cabal install hlint) and run it on your program
09:42:03 <hakujin> it should help show you things like sequence . map = mapM_
09:42:16 <chirpsalot> hakujin: ah, okay! Sounds good.
09:42:29 <hakujin> try to avoid using !! to index into lists. deconstruct the list with pattern matching to find what you want.
09:42:39 <albeit> jfischoff: If I implement processMessage as a method of the typeclass, I could then pattern match on the specific data constructor, ya?
09:42:41 <yitz> glguy: ah you mean the extra copy? right, that's true. but in the other direction it needs to copy too, doesn't it? can you just point to different regions in the same memory to create the chunks?
09:42:56 <glguy> yitz: strict to lazy requires no copy
09:43:07 <glguy> A lazy bytestring is a linked list of strict bytestrings
09:43:16 <yitz> glguy: oh because it initially makes it just one chunk of whatever size?
09:43:17 <jfischoff> albeit: well you can write a different instance for each type.
09:43:32 <chirpsalot> hakujin: that didn't occur to me... !! seemed gross, but I didn't realize I could just pattern match >_<. Thanks!
09:43:34 <glguy> yeah, it takes the strict bytestring and it uses that as the singleton chunk
09:43:52 <yitz> glguy: even if bigger or smaller than the standard chunk size.
09:44:16 <jfischoff> albeit: are you familar with the function maybe?
09:44:20 <glguy> fromStrict bs | S.null bs = Empty
09:44:20 <glguy>               | otherwise = Chunk bs Empty
09:44:24 <jfischoff> > :t maybe
09:44:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:44:34 <jfischoff> :t maybe
09:44:35 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:44:37 <albeit> jfischoff:  Yes
09:44:55 <glguy> yitz: fromStrict is documented to be O(1), toStrict is documented to be O(n)
09:45:06 <yitz> ok
09:45:07 <jfischoff> albeit: do you see how it is similar to pattern matching on a Maybe?
09:45:28 <chirpsalot> hakujin: [emailFile, inviteFile, outputFile] <- getArgs sooooooooo much better. Thank you :).
09:45:38 <albeit> jfischoff: Beginning to!
09:46:37 <jfischoff> albeit: so ‘case m of { Just x -> print x; }’ is the same as ‘maybe undefined print’
09:46:53 <hakujin> chirpsalot: happy to help
09:46:53 <jfischoff> albeit: does that make sense?
09:46:59 <albeit> jfischoff: Yes
09:47:56 <jfischoff> albeit: every type has a function like ‘maybe’ I think you can call them ‘folds’
09:48:13 <chirpsalot> hakujin: now I'm just waiting for hlint to finish installing :). Thanks!
09:48:43 <jfischoff> albeit: now imagine that ‘case’ is just sugar for those functions.
09:49:54 <jfischoff> albeit: So you can’t ‘case’ on two different types. You need a type to know which way tear it down.
09:51:04 <jfischoff> the types `Show a => a` and Bool are different, even if Bool can be used anywere that requires a ‘Show a => a’
09:51:55 <shachaf> The type "Show a => a" is uninhabited.
09:52:32 <shachaf> Note that "Show a => a" is not part of "Show a => a -> String" except as a substring.
09:52:40 <glguy> ?type undefined :: Show a => a
09:52:41 <lambdabot> Show a => a
09:52:52 <jle`> :P
09:53:17 <shachaf> Maybe you mean "Show a *> a".
09:54:37 <jfischoff> shachaf: you free to suggest a better way to talk about the ‘a’ in the type
09:54:55 <jfischoff> s/you/you are
09:55:05 <shachaf> I did.
09:55:21 <shachaf> Another way: "a, where a is an instance of Show"
09:55:31 <jfischoff> yes
09:55:41 <glguy> What does Show a *> a" mean?
09:56:00 <jfischoff> anyway, more importantly albeit is any of this explanation helping?
09:57:05 <glguy> (Not trying to be difficult if it was just a typo)
09:57:16 <shachaf> I think a wrong explanation doesn't help much, and this is a very widespread mistake that I'd rather not see proliferate.
09:57:25 <shachaf> glguy: *> is like a tuple where => is a function.
09:57:31 <albeit> jfischoff: To be honest, not really. But I appreciate the effort
09:57:33 <shachaf> E.g. (exists a. Show a *> a) ~~ String
09:57:55 <shachaf> Oh, albeit is the name of the person you're talking to. Now I understand that sentence.
09:58:04 <jfischoff> ha
09:58:06 <jle`> haha
10:00:05 <jle`> is there some sort of semantic word for describing (a -> m b) -> (m a -> m b)
10:00:26 <jle`> if (a -> b) -> (m a -> m b) is a "lift"... and (a -> m b) -> (m a -> m b) only lifts "one side"....
10:00:31 <jle`> is it like a "pre-lift"? >_>
10:00:40 <glguy> ?type (=<<)
10:00:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:00:44 <albeit> Maybe I'm approachingwhat I'm trying to do wrong. The big idea is I'm reading in messages in JSON format from a socket, converting them to a type based on their contents, and then processing them one by one in the context of a StateT. I was trying to have one main "processMesages" loop that would match on the message type, but that isnt' right.
10:01:48 <albeit> I think instead I need each message to have its own processMessage method as an instance of the Mesage typeclass, and provide a StateT context for it run under?
10:02:10 <klrr_> can you explain the original problem?
10:02:20 <klrr_> you recieve JSON messages of unknown type?
10:02:39 <yitz> @hoogle (a -> m b) -> (m a -> m b)
10:02:40 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:02:40 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:02:40 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:02:52 <albeit> klrr_: Yes. Well, they are definitely JSON, the type (what contents the message holds) is determined by the "msgType" key in the message.
10:03:15 <klrr_> okey
10:03:56 <klrr_> you know all different types that msgType may specify? if so then just write a record for them then make a fromJSON instance
10:04:04 <klrr_> (if you use Aeson at least)
10:04:16 <jfischoff> albeit: the simplest approah is to have a sum type that includes all the possible options
10:04:56 <albeit> klrr_: Yes, I know all the possible types. But how do I get the specific types fromJSON to be called when reading in the message?
10:05:11 <klrr_> hmm
10:05:24 <yitz> jfischoff: if albeit is using aeson, the usual technique is a separate type for each (unless there is some other need to combine them into a sum type)
10:06:00 <klrr_> just a sec gonna see if i have encounter something similar
10:06:01 <albeit> jfischoff: That is sort of what I was doing. NetworkMessage was a type that had a bunch of data constructors that generated other types, each of which was a formJSON isntance.
10:06:13 <albeit> *fromJSON
10:06:38 <yitz> albeit: oh so do you have fromJSON instance for NetworkMessage?
10:06:39 <jfischoff> yitz: I don’t think we are talking about the same thing
10:07:13 <klrr_> i have a hard time understand what your problem is tbh, if you have fromJSON for each type then it should figure that out by itself right?
10:07:26 <shachaf> glguy: Oh, and *> isn't actual syntax in any Haskell implementation, just imaginary syntax.
10:07:30 <shachaf> Since no implementation supports it.
10:07:43 <albeit> yitz: Not quite, my NetworkMessage has a parseContents method that takes the bytestring, and generates a specific type.
10:08:00 <albeit> And that specific type is an instance of fromJSON
10:08:12 <shachaf> Anyway, the point is that "Show a => a -> Int" doesn't take an argument of type "Show a => a", the same way that "Char -> a -> Int" doesn't take an argument of type "Char -> a".
10:08:54 <albeit> klrr_: Well, how does it figure it out by itself? If I have a bunch of types that implement fromJSON, only one of them at any time is going to match to the actual JSON.
10:09:04 <klrr_> albeit: the type of decode is "FromJSON a => ByteString -> Maybe a", so if you make an instance of your type it should figure out the rest, that is you specify msgType in the fromJSON instance
10:09:09 <glguy> shachaf: and (*>) represents some tuple constructor with kind Constraint -> * -> *, then?
10:09:21 <glguy> so you can uncurry the => ?
10:09:23 <yitz> albeit: what do you mean by a "method" of NetworkMessage?
10:09:37 <shachaf> glguy: Right.
10:09:52 <shachaf> @let data k *> a = k => Foo a
10:09:52 <lambdabot>  Parse failed: Illegal class assertion
10:10:18 <yitz> brb
10:10:21 <shachaf> Well, something like that. Except in theory it works without the type wrapper, like => does.
10:10:29 <klrr_> maybe you can paste some code it could be easier to see what the problem is
10:10:33 <glguy> We've had  a bit of a dry spell for new operators in lens. Maybe you can find a reason to fit it in ;-)
10:10:37 <albeit> yitz: NetworkMessage implemented a typeclass called MsgContents, which had a method parseContents. But I don't think it is right ;)
10:11:08 <albeit> klrr_: I think I may reorganize and try some of the suggestions out, dont want to burden everyone with this atrocity
10:11:14 <klrr_> is NetworkMessage from a library ?
10:11:44 <klrr_> albeit: burden is also a good practice oppurtunity
10:11:51 <klrr_> ;)
10:11:57 <albeit> klrr_: No, a type I defined, that implements the MsgContents (a customer typeclass)
10:11:57 <klrr_> (for others that is)
10:12:35 <klrr_> a customer should probably be a datatype, they're not that general
10:12:46 <klrr_> if you mean customer in the litteral sense
10:13:00 <albeit> *custom, not customer sorry
10:13:08 <klrr_> haha sry xD
10:13:25 <klrr_> what is the type of parseContent?
10:14:19 <albeit> parseContents :: String -> Value -> Parser a
10:14:32 <klrr_> okey
10:14:41 <albeit> Here is the relevant code: http://lpaste.net/104177
10:14:46 <klrr_> oh nice
10:14:49 <albeit> (Warning... beginner stuff)
10:15:26 <albeit> The reason I made the MsgContents type class, was I need other modules that use this underlying logic to implement their own message types.
10:18:37 <klrr_> albeit: maybe i missunderstand but some of the content is parsed by a "custom" paresr? if so then it might be easier to have an intermidiate type and then parse that again to the correct type
10:19:08 <klrr_> meh nvm
10:19:31 <albeit> klrr_: Well the intermediate parser was to extract the msgType, then send on the rest to create a specific type.
10:20:09 <albeit> The messages are of the form {msgType: foo, args:{....}}
10:20:32 <hakujin> how much should I be concerned with an orphan instance warning for Monoid (Either a b) in one of my modules?
10:20:34 <albeit> And I'm trying to load the {...} (the args) into types I define
10:20:39 <klrr_> yeah just me who is stupid
10:20:55 <klrr_> it looks right to me hmm
10:21:13 * hackagebot attoparsec 0.11.3.2 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.3.2 (BryanOSullivan)
10:24:52 <klrr_> albeit: try enable this and see if its fixes it {-# LANGUAGE ScopedTypeVariables #-}
10:25:18 <glguy> hakujin: It's not a good idea and it will be incompatible with other modules to make the same mistake, but it won't break anything
10:26:02 <albeit> klrr_: It gives the same error
10:26:14 * hackagebot ghc-imported-from 0.2.0.0 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.0 (CarloHamalainen)
10:26:16 * hackagebot Object 1.0 - Object oriented programming for haskell using multiparameter typeclasses.  http://hackage.haskell.org/package/Object-1.0 (yokto)
10:26:28 <glguy> hakujin: Why did you need a Monoid instance for it?
10:28:05 <klrr_> albeit: have you tried write out the whole explicit type for processMessage? (just trying to come up with ideas, no idea what the issue is tbh)
10:29:18 <albeit> klrr_: As in, put the NetworkMessage type into the function type declaration? Wouldn't that prevent me from using other instances of MsgContents in that function?
10:29:44 <klrr_> albeit: yes but just to see if inference is the issue
10:30:20 <albeit> klrr_: Yep, it worked if I declare the type to be NetworkMessage instead of 'a' (but I had to remove the (MsgContents a) => as well.
10:30:45 <klrr_> okey
10:31:14 * hackagebot ghc-imported-from 0.2.0.1 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.1 (CarloHamalainen)
10:32:03 <klrr_> albeit: try with the general type signature and enable MonoLocalBinds
10:32:56 <albeit> klrr_: Same error with that extension.
10:33:08 <darthdeus> guys anyone knows the color scheme for emacs that fpcomplete has? it's in this video for example https://www.youtube.com/watch?v=-QMBVMMmaCU
10:33:13 <glguy> albeit: I'm not following along exactly, but some point you will have to write a function that knows ALL of the possible message types that it's able to parse
10:33:18 <darthdeus> as in ... what is the name of this scheme? :)
10:33:20 <glguy> and will parse them
10:33:29 <klrr_> meh, strange
10:33:37 <glguy> and return all of those types in a single sum type or equivalent
10:33:40 <hakujin> glguy: I want to use mconcat to fold across a list of Either String (Sum a)
10:34:40 <hakujin> should I wrap this up in a newtype to avoid the warning?
10:34:47 <albeit> glguy: True.. so for each module Foo that has a FooMessage type, it just needs a processMessage function that takes a FooMessage type instead of (MsgContents a) =>... sounds good
10:35:11 <klrr_> albeit: i would either ungeneralize processMessage or define a fromJSON for each datatype instead, no idea why it doesnt work with the generalized type signature. one last thing to test is without type signature and check in with ":t processMessage" in repl to see what type it infers to ;)
10:36:07 <albeit> klrr_: repl says :t = "processMessage :: t -> NetworkMessage -> ..."
10:36:12 <albeit> So it isn't generalizing.
10:36:32 <albeit> I think I'll degeneralize processMessage. Thanks for the help klrr_ glguy!
10:36:52 <klrr_> not much help sry xD but gl!
10:36:53 <glguy> hakujin: You should probably just write the function you want rather than an instance of Monoid. But if you're set on a monoid instance a newtype would be better
10:37:26 <glguy> is the function that if you find a [Left e] to return the first [Left e] otherwise right the Right of the sum?
10:37:33 <hakujin> yep
10:38:52 <glguy> ?type \f xs -> case partitionEithers xs of (e:_,_) -> Left e; ([],xs) -> Right (mconcat xs)
10:38:53 <lambdabot> Monoid b => t -> [Either a b] -> Either a b
10:39:45 <hakujin> yeah lots of ways to solve that problem
10:40:26 <glguy> even: (fmap mconcat . sequence)
10:41:15 * hackagebot attoparsec 0.11.3.3 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.3.3 (BryanOSullivan)
10:41:17 * hackagebot apiary 0.4.0.1 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.0.1 (HirotomoMoriwaki)
10:41:19 * hackagebot apiary-cookie 0.4.1.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.4.1.0 (HirotomoMoriwaki)
10:41:37 <glguy> > let f = fmap mconcat . sequence in (f [Right "a", Left 1, Left 2, Right "b"], f [Right "a", Right "b"])
10:41:39 <lambdabot>  (Left 1,Right "ab")
10:42:36 <ReinH> fmap fold . sequence is quite nice for that
10:42:43 <hakujin> glguy: I overlooked sequence, thanks!
10:42:57 <ReinH> (fold is mconcat for Foldable ofc)
10:44:20 <shapr> giantDrill: nice nickname
10:45:19 <Fuuzetsu> agreed
10:45:49 <glguy> Yeah, if we're going for maximum generality:
10:45:51 <glguy> ?type fmap fold . sequenceA
10:45:52 <lambdabot>     Not in scope: ‘sequenceA’
10:45:52 <lambdabot>     Perhaps you meant one of these:
10:45:52 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
10:45:53 <glguy> ?type fmap fold . T.sequenceA
10:45:54 <lambdabot> (Monoid b, Traversable t, Applicative f) => t (f b) -> f b
10:47:17 <Fuuzetsu> :t fold
10:47:18 <lambdabot> (Monoid m, Foldable t) => t m -> m
10:48:14 <shapr> :t (<+>)
10:48:15 <lambdabot>     Ambiguous occurrence ‘<+>’
10:48:15 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
10:48:15 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:35:1-20
11:13:43 <darthdeus> anyone here got flymake working with haskell-mode?
11:13:46 <darthdeus> in emacs
11:14:00 <darthdeus> it's showing me errors on import statements, so i assume it doesn't recognize my cabal project :\
11:14:06 <darthdeus> not sure how to fix it though
11:16:19 * hackagebot hermit 0.5.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.5.0.0 (AndrewFarmer)
11:16:47 <albeit> If I do execStateT on a stateful computation :: StateT Network IO a, I get a return value of :: IO Network. How can I extract the Network data from that?
11:17:07 <michi7x7> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
11:17:07 <lambdabot>   Hello World!
11:17:15 <michi7x7> cool... but why?
11:17:35 <jle`> michi7x7: you're asking in #haskell? :P
11:18:07 <yitz> albeit: do that calculation inside IO. if it's in a do block you can bind it to a variable: netdata <- execStateT ...
11:18:17 <monochrom> albeit: do not think in terms of "extract". have you read my I/O tutorial? http://www.vex.net/~trebla/haskell/IO.xhtml
11:18:59 <albeit> I'll read it now. I now extract was wrong, should have said "perform the computation" and get the result
11:19:02 <albeit> *know
11:19:34 <yitz> albeit: IO Network *is* the result. you can use it inside an IO computation.
11:19:39 <hakujin> darthdeus: Tim Dysinger has an example config with flymake working. I don't use emacs but maybe this helps: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
11:20:02 <darthdeus> hakujin: thanks!
11:21:20 * hackagebot rest-types 1.10 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10 (AdamBergmark)
11:21:36 <michi7x7> albeit: you have to be in IO anyway to wrap StateT around. runStateT will return "IO (Network, a)"
11:22:52 <albeit> Ah actually realized the do block I was execStateT'ing in wasn't wrapping IO, so I couldn't actually do an IO computation anywhere
11:23:25 <monochrom> that's right, that do block has type StateT etc
11:26:20 * hackagebot rest-stringmap 0.1.0.0 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.1.0.0 (AdamBergmark)
11:26:22 * hackagebot rest-snap 0.1.17.9 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.9 (AdamBergmark)
11:26:24 * hackagebot rest-client 0.2.3.3 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.2.3.3 (AdamBergmark)
11:26:26 * hackagebot rest-core 0.30 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.30 (AdamBergmark)
11:26:28 * hackagebot rest-gen 0.10.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.10.0.2 (AdamBergmark)
11:31:30 * hackagebot rest-happstack 0.2.9.8 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.8 (AdamBergmark)
11:31:32 * hackagebot wordpass 0.4.0.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.4.0.0 (MichalGajda)
11:34:08 <chuchao333> Hello everyone, just started my journey of haskell and want to try the IRC. Thanks!
11:34:43 <vamega> Hi chuchao333
11:35:08 <a3gis> chuchao333: hello (:
11:35:22 <monochrom> IRC is good
11:36:47 <ccandcc> exit
11:38:17 <hakujin> when would I want to use sequence instead of sequenceA?
11:39:04 <pseudolio> When you're using other stuff that requires a Monad m constraint, and you don't want to type Applicative m.
11:39:06 <ion> When using GHC ≤ 7.10 and your value having an Applicative constraint in addition to a Monad constraint (coming from something else) would be unpleasant.
11:39:43 <hakujin> assuming the correct (7.10) relationship between Applicative and Monad*
11:39:45 <zzing> I have a code base that I got to work with cabal, but as to be configured with --ghcjs (using the latest). Now the problem is that one of the source files is generated from a templating system that I also need to build, and run before building this. Is there any way I can have cabal build something natively, run it in a certain way, and then compile the rest for the ghcjs target?
11:40:09 <pseudolio> hakujin: Post 7.10, you should use sequence because it's a better name than sequenceA.
11:40:59 <hakujin> pseudolio: so true. I assume Prelude's sequence will be updated to Traversable's sequenceA?
11:41:07 <pseudolio> Yes.
11:41:19 <hakujin> thanks
11:41:22 * hackagebot wordpass 0.4.1.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.4.1.0 (MichalGajda)
11:42:55 <tayacan> Hey all
11:42:58 <tayacan> Quick question
11:44:00 <Nahra> Hello. Which way to reinstall every cabal packages?
11:44:05 <tayacan> canonicalizePath throws an exception if the path doesn't exist (on some platforms, at least), but it doesn't seem to be specified what exception... What would be a good way to handle this?
11:45:14 <hakujin> tayacan: all Exceptions are instances of SomeException so you could always catch that
11:45:24 <monochrom> Nahra: read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
11:46:06 <hakujin> (at least they're all supposed to be)
11:46:14 <tayacan> I could, but documentation says it's a bad idea :P
11:46:28 <tayacan> I was just wondering if there was a better way
11:46:55 <Nahra> monochrom: I have to uninstall and then install?!
11:47:05 <monochrom> no. read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
11:47:16 <srhb> tayacan: Because its behaviour is undefined (and the exception is probably a bug, probably) you probably should not trust the exception type either
11:47:22 <srhb> tayacan: ie. I'd go with SomeException
11:47:23 <monochrom> close IRC and start reading.
11:47:31 <Nahra> lol
11:47:56 <tayacan> srhb: Ok, I'll stick with that
11:48:17 <srhb> tayacan: Maybe it'd be better to roll your own canonicalizePath. :-)
11:48:43 <Nahra> what's that shit
11:48:49 <monochrom> tayacan: if you like to read the source code, read it to find out what type it throws. If not, first catch SomeException but make it print the real type, then refine to that type
11:49:03 <tayacan> srhb: I could do that too - it's for a sort-of-big assignment, though, so I'd rather not spend a lot of time reimplementing things that already exist
11:49:15 <srhb> tayacan: Righto.
11:49:39 <monochrom> catch ... (\ (SomeException e) -> print (typeOf e)) may give you useful information
11:49:41 <Nahra> OK. How to easily reinstall every cabal packages?
11:49:43 <hakujin> tayacan: looking at the source it throws an IOError
11:49:44 <tayacan> monochrom: Thanks!
11:49:53 <tayacan> hakujin: Also thanks!
11:50:53 <tayacan> Works with IOError on my laptop - we'll see if I get in trouble when I run it on a different box later on
11:51:00 <tayacan> Thanks, everyone :D
11:52:34 <azumoro> Nahra: u can get a list of all installed pkgs with cabal list --installed, then delete .cabal and .ghc in your $HOME and the install the packages again (not sure if this works though)
11:52:51 <azumoro> after cabal update
11:54:22 <rribeiro> Hello to all! I'm having some problems on install the llvm-general package. I'm using the latest ghc on macosx
11:54:38 <Nahra> azumoro: I need a process that works and that is sure! Why telling me something that prehaps does not work?
11:55:04 <geekosaur> mebiro: if it's not the usual xcode 5 issue then you need to find a full LLVM somewhere --- Apple does not ship the full LLVM, only the parts that Xcode uses
11:55:07 <dgpratt> so I have this method in C# the Haskell equivalent of which is essentially "split . keepDelimsL . whenElt"
11:55:26 <geekosaur> er
11:55:41 <dgpratt> and I noticed an interesting bug in the C# version based on strictness and statefulness
11:55:43 <geekosaur> rribeiro, if it's not the usual xcode 5 issue then you need to find a full LLVM somewhere --- Apple does not ship the full LLVM, only the parts that Xcode uses
11:55:47 <dgpratt> and it got me thinking
11:56:22 <rribeiro> geekosaur: I'm not using xcode. I've installed llvm using brew
11:56:39 <dgpratt> about the inherent strictness of that function
11:58:10 <dgpratt> (trying to think of an example of my thought/question...)
11:58:53 <azumoro> Nahra: u didn't tell, that it has to be safe...
12:00:18 <Nahra> lol
12:01:11 <monochrom> process already comes with GHC and already works. attempts to "cabal install process" are misguided.
12:01:56 <monochrom> err nevermind, it doesn't come with GHC
12:01:59 <benzrf> writer and state are the same except that state replaces and writer mappends, right?
12:03:49 --- mode: ChanServ set +o Cale
12:04:41 <klrr_> so, this qusetion have probably been asked many times, but icouldnt find an answer where kmett's trifecta library were counted.
12:05:14 <klrr_> so which is the best parsing combinator library, parsec, attoparsec or trifecta, if you want to parse a programming language (C-like)
12:06:45 <michi7x7> klrr_: It's always the library you feel most comfortable with, except when you have to use one for certain reasons
12:06:51 <merijn> parsec and attoparsec are pretty similar, parsec comes with slightly more builtin combinators and is a transformer for your monad stack
12:07:20 <merijn> trifecta seems neat, but I have no idea how to actually use it. It appears to be from the era where edwardk didn't yet believe in documentation :p
12:08:08 <klrr_> how is trifecta performance wise? i want good error messages but i dont like being bound to [Char]
12:10:05 <peddie> @hackage language-c
12:10:05 <lambdabot> http://hackage.haskell.org/package/language-c
12:10:13 <peddie> klrr_: ^ this is even better :P
12:10:25 <bennofs> What does PINNED in a -hc heap profile mean? It shows up as type ARR_WORDS in the -hy profile
12:11:02 <tayacan> Anyone have an opinion on http-libraries? A quick hoogle-search reveals an overwhelming amount of http-related packages.
12:11:19 <merijn> tayacan: http libraries to do what?
12:11:20 <Fuco> I have a state monad with state "State", I'm trying to modify one of the fields. Is there something nicer than modify (\s@(State { handles = h }) -> s { handles = handle:h }) ?
12:11:25 * hackagebot clash-lib 0.3.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.3.1 (ChristiaanBaaij)
12:11:38 <merijn> Fuco: lenses :)
12:12:29 <bennofs> Could an IntMap create a PINNED region of memory?
12:12:40 <tayacan> merijn: I'm mostly worried about parsing requests and responses
12:13:14 <tayacan> merijn: But one that takes care of sending and recieving stuff as well would be ok
12:13:49 <shachaf> Fuco: For instance, with lens, "yourHandlesLens %= (handle:)"
12:14:21 <merijn> tayacan: http-conduit was pretty good for fetching things, but I never really tried to parse response directly. I've heard wreq or something like that is the new fancy HTTP library on the block, but I'm not familiar with it
12:14:49 <tayacan> merijn: Thanks, will look it up
12:15:17 <Fuco> seems like I should read up on lenses
12:15:59 <quchen> I recommend SPJ's talk on lenses, Fuco.
12:16:26 * hackagebot clash-ghc 0.3.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.1 (ChristiaanBaaij)
12:16:31 <quchen> (You'll need a dummy account.) https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
12:17:20 <Fuco> thanks
12:17:55 <quchen> It's more of an introduction to the concept than a tutorial, but it is great at lowering the barrier of entry (to "very low").
12:20:18 <tayacan> Hmm. Wreq looks nice, but kinda big and complex for my purpose.
12:21:28 * hackagebot active 0.1.0.14 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.14 (bergey)
12:21:30 * hackagebot monoid-extras 0.3.3.3 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3.3 (bergey)
12:21:32 * hackagebot dual-tree 0.2.0.3 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.3 (bergey)
12:21:34 * hackagebot diagrams-core 1.1.0.3 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.1.0.3 (bergey)
12:21:36 * hackagebot diagrams-lib 1.1.0.7 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.1.0.7 (bergey)
12:24:43 <benbangert> is there a hackage bug on building docs? I'm seeing more and more projects that have haddock's, but hackage isn't building them
12:26:28 * hackagebot diagrams-contrib 1.1.1.5 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.1.5 (bergey)
12:27:56 <merijn> benbangert: Haddock requires the package compiles, so any package whose build fails on the hackage server has no docs unless the maintainer manually uploads them
12:28:12 <merijn> benbangert: Also, doc generation is a batch process and can take something like 24 hours after updates
12:28:16 <benbangert> ahhhh
12:30:02 <enthropy> merijn: I don't think there's much delay anymore. For example http://hackage.haskell.org/package/diagrams-contrib-1.1.1.5 uploaded 10 minutes ago has docs
12:30:27 <bennofs> enthropy: maybe the docs were uploaded manually?
12:30:30 <merijn> enthropy: The maintainer could have uploaded those
12:30:38 <benbangert> ah, http://hackage.haskell.org/package/dual-tree-0.2.0.3 did not have docs built
12:30:40 <enthropy> bergey: did you manually upload docs?
12:30:40 <merijn> Uploading your own docs is of course instant :p
12:30:44 <bergey> No
12:30:47 <vlads> hi all. I've got a merge sort (probably, I'm not sure its implementation is correct) here http://lpaste.net/104183 and I need to modify it to count inversions (when element from b is chosen upon merge, sum lengths of A part). I see, that monad should fit right for this task, but I can not understand, how to implement it.
12:34:45 <quchen> vlads: Not "monad" in general, there's a special Monad that is made for logging values. Are you familiar with the basic Monad instances?
12:35:06 <bitraten> Is there a better way to model this: https://gist.github.com/bitraten/8394edbbd183d06bc4cf ?
12:35:58 <quchen> data Item = Item ItemType ItemContents; data ItemType = WikiText | WikiURI | …
12:36:29 * hackagebot rollbar 0.3 - error tracking through rollbar.com  http://hackage.haskell.org/package/rollbar-0.3 (GregWeber)
12:37:05 <quchen> Whether that's better often depends on your taste and varies case-by-case, I think. It's very close to "factoring out the common parts".
12:38:30 <akurilin> Quick question: should I be installing happy through the package manager or should happy be ideally set up through cabal itself?
12:40:58 <vlads> quchen: only basics and since I had not much practise with them, I'm not very fluent in using them. I recognise Monad.Writer use-case, but not sure how to inject it into code.
12:42:19 <michi7x7> bitraten: probably yes
12:43:18 <NemesisD> has anyone worked out a good way to embed free monads in other free monads, such as with a monad transformer?
12:44:06 <fizruk> NemesisD: FreeT f (Free g) ?
12:44:11 <NemesisD> i've got free monad FooM and BarM, i want to embed a computation in BarM in FooM but i want to defer specifying the interpreter to use till i choose it for the outer FooM
12:44:35 <fizruk> NemesisD: you could use data types a la carte approach alternatively
12:44:44 <fizruk> NemesisD: e.g. Free (f :+: g)
12:45:05 <Cale> NemesisD: What do you mean by "embed"? If it's possible, you should be able to write a function BarM a -> FooM a
12:45:33 <Cale> Which is effectively an interpreter for BarM which produces computations in FooM
12:46:30 <Eduard_Munteanu> What package do I need for syntax highlighting on Debian Jessie?
12:47:12 <chrisdone> is someone in here trying to scrape lpaste.org?
12:47:16 <Cale> NemesisD: It might help to be a bit more concrete about the problem you're trying to solve
12:47:29 <NemesisD> fizruk: that's a tough function to google ;)
12:47:42 <fizruk> NemesisD: :+: you mean?
12:47:50 <carter> chrisdone: someone ddosing it?
12:47:51 <chrisdone> i'm seeing DDoS-like connections scrolling up my screen in the access logs, memory usage through the roof and postgres too many connections
12:48:00 <carter> whats the IP?
12:48:04 <carter> what country?
12:48:06 <chrisdone> look at all these different IP's requesting the same page: http://lpaste.net/raw/235122676039942144
12:48:17 <fizruk> @hackage compdata
12:48:18 <lambdabot> http://hackage.haskell.org/package/compdata
12:48:19 <NemesisD> Cale: sure. so i've got a free monad for dealing with some system commands getting stuff like uids, gids, etc. i also have a free monad that limits the commands available when you for ka process
12:48:21 <NemesisD> fizruk: yeah
12:48:26 <fizruk> @where data types a la carte
12:48:27 <lambdabot> I know nothing about data.
12:48:35 <carter> chrisdone: do you have a robots.txt?
12:48:38 <chrisdone> it's not constant enough to be a DDoS, i think. it seems like someone is trying to write a distributed scraper or something
12:48:46 <fizruk> NemesisD: http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
12:49:04 <fizruk> NemesisD: the corresponding library is compdata
12:49:13 <NemesisD> Cale: so my outer command set is SeraphProcess next = ... | ForkProcess (SeraphChild ProcessID -> next),
12:49:14 <carter> is there a way to geotrack ips?
12:49:16 <Cale> NemesisD: So, one monad is simply a restricted version of the other?
12:49:18 <chrisdone> carter: no, googlebot and yahoo and such are acceptable (they're how i google lpaste), they scrape one page every couple seconds. this is… ridiculous
12:49:34 <carter> chrisdone: probaby post to r/haskell
12:49:37 <carter> or cafe
12:49:44 <carter> is the right way to make sure they get the message
12:49:48 <bennofs> btw, try http://178.175.139.142/
12:49:53 <bennofs> (one of the ips)
12:49:55 <Cale> NemesisD: It shouldn't be so difficult to write a function which goes from the "small" monad to the "large" one
12:50:22 <chrisdone> they're still doing it. now with random pages
12:50:25 <NemesisD> Cale: not quite. the SeraphChild monad has a completely different set of operations in it than in SeraphProcess, its just that its only useful inside a fork call
12:50:59 <NemesisD> Cale: they share no operations
12:51:02 <fizruk> NemesisD: so you want to merge the capabilities or interpret ones in terms of others?
12:51:40 <Cale> NemesisD: Okay, so one doesn't really embed into the other
12:51:44 <michi7x7> chrisdone: do you run a bigger webserver or directly a haskell app on 80 ?
12:52:07 <Cale> Unless you can interpret the operations of the small one somehow
12:52:21 <chrisdone> michi7x7: all my haskell services run behind nginx
12:52:23 <NemesisD> fizruk: i'm still working it out. i guess what i envision is that in order to create an interpreter for SeraphProcess (outer), you must supply one for SeraphChild (inner), not sure about the types
12:53:12 <michi7x7> chrisdone: good decision imho
12:54:02 <NemesisD> i could put it all in one big free monad/interpreter but i really like the idea of isolating commands you can execute ind the child process from those in the parent
12:54:42 <NemesisD> Cale: you'd be able to provide an interpreter for both at the same time, i.e. there will be one for IO and one for test. im just not sure how to express that in the definition of the command set
12:54:54 <Eduard_Munteanu> Though given lpaste's traffic, I'd expect the bandwidth provisions to be small enough to make coping with DoS not very difficult.
12:55:25 <NemesisD> Cale: such that a function that's defining a SeraphProcessM a can internally execute a SeraphChildM b and satisfy the type checker
12:55:25 <Eduard_Munteanu> At least the unintentional kind of DoS.
12:55:36 <fizruk> NemesisD: so you have at least 3 opportunities: FreeT f (Free g), Free (f :+: g) and f ~> g
12:56:37 <NemesisD> fizruk: seems like i have some learning to do. i don't quite understand those. i've seen some of those symbols but i don't know what they mean
12:56:47 <Cale> NemesisD: Are you using free monads?
12:57:03 <NemesisD> Cale: yes. the free package with Control.Monad.Free.TH specifically
12:57:52 <fizruk> NemesisD: do you have code for functors to paste?
12:58:15 <NemesisD> i derive functors but yeah i can link to what i'm working with now just a sec
12:59:08 <Eduard_Munteanu> Oh, hm, I just needed to ':syntax enable'.
12:59:40 <chrisdone> oh well, lpaste can handle it. it's just lame. going to bed. ciao~
12:59:55 <NemesisD> Cale: fizruk https://github.com/MichaelXavier/Seraph/blob/free/src/Seraph/Free.hs#L30 there's my free monad. here's where i use undefined https://github.com/MichaelXavier/Seraph/blob/free/src/Seraph/Process.hs#L83
13:01:41 <fizruk> NemesisD: so in ForkProcess why do you have what you have?
13:02:53 <NemesisD> fizruk: it could very well be incorrect. forkProcess should run in the SeraphChild free monad and result in a ProcessID
13:03:42 <NemesisD> fizruk: shuld it instead be like ForkProcess (child ProcessId -> next) and I could parameterize on child?
13:04:15 <fizruk> NemesisD: i suggest ForkProcess :: Free SeraphChild a -> (a -> next) -> SeraphProcess next
13:04:51 <fizruk> NemesisD: so that you could write forkProcess $ do { … child process code here … }
13:05:01 <smiller2> myStrat (a,b) = do { a' <- rpar a; b' <- rseq b; return (a',b') } (http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html#t:Eval).  How is this different from myStrat (a,b) = do { a' <- rpar a; b' <- rpar b; return (a',b') }?  Why should last component be evaluated with rseq rather than rpar?
13:05:13 <fizruk> NemesisD: or maybe that is not what you want?
13:06:05 <fizruk> NemesisD: forget for a second about ForkProcess data constructor and tell me what forkProcess command would you like?
13:06:22 <NemesisD> fizruk: that forkProcess code is actually how it looks, so it is what i want. so in the ADT it would be ForkProcess (SeraphChildM ProcessID -> ProcessID next) ?
13:07:09 <fizruk> NemesisD: no, it’s not, can you paste result of “:t forkProcess”
13:07:16 <NemesisD> fizruk: just like you said pid <- forkProcess $ do { commands only available in SeraphChildM}
13:07:59 <NemesisD> fizruk: forkProcess :: MonadFree SeraphProcess m0 => m0 (SeraphChild ProcessID)
13:08:03 <dmwit> Hit my pain point for waiting for vim #haskell.log to load today.
13:08:16 <fizruk> NemesisD: so you’re wrong :)
13:08:23 <dmwit> 392M; last pain point was ~250M
13:08:28 <dmwit> So I'm getting stronger. =P
13:08:34 <fizruk> NemesisD: your forkProcess currently does not accept any parameters
13:08:34 <dmwit> And you guys talk a lot!
13:09:07 <NemesisD> fizruk: ahh you're right!
13:10:00 <fizruk> NemesisD: there’s an example similar to what I suggest here: https://github.com/ekmett/free/blob/master/examples/RetryTH.hs
13:10:13 <enthropy> would it be reasonable to overload 'name to be a call to   class IsName s a where fromName :: Proxy (s :: Symbol) -> Name -> a? where the 's' type variable becomes "name" of course (cross-post from #ghc)
13:11:23 <NemesisD> fizruk: wait this type looks right to me: ForkProcess (SeraphChildM ProcessID) (ProcessID -> next), forkProcss :: MonadFree SeraphProcess m0 => SeraphChildM ProcessID -> m0 ProcessID
13:11:32 <bennofs> enthropy: what is Name ?
13:11:41 <enthropy> bennofs: template haskell Name
13:12:21 <fizruk> NemesisD: should be ForkProcess (SeraphChildM a) (ProcessID -> next) then, no?
13:12:40 <fizruk> NemesisD: or are you receiving ProcessID as a *result* of child process?
13:13:03 <NemesisD> fizruk: precisely. ProcessID is the outcome of forking
13:13:11 <fizruk> NemesisD: alternatively ForkProcess (SeraphChildM ()) (ProcessID -> next) to get rid of existential
13:13:28 <fizruk> NemesisD: of *forking*, but not *child process*, right? :)
13:13:51 <NemesisD> fizruk: ah you're right
13:14:59 <vlads> quchen: I'm pretty sure, I need to rewrite inner `merge' function in order to count inversion, only I am at total loss as to how to use it afterwards.
13:15:11 <fizruk> is DeriveFunctor mechanism working for GADTs in 7.8 already?
13:15:25 <fizruk> i know it works in HEAD
13:16:00 <NemesisD> fizruk: thanks! things are making a lot more sense
13:16:22 <fizruk> NemesisD: cool :)
13:16:35 * hackagebot HaTeX 3.13.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.13.0.0 (DanielDiaz)
13:19:45 <EponymicCycloid> What is the technical term for assignment from a non-trivial expression? E.g. `x = <if .. then .. else ..>` or `x = <pattern match>`, as opposed to `x = 5` or `x = foo 5`. Intuitively, I would use “complex expression”, but that has mathematical connotations I don’t want
13:20:09 <Cale> EponymicCycloid: Definition by cases?
13:20:36 <Cale> Or piecewise definition
13:20:52 <EponymicCycloid> I don’t think that quite captures the idea I’m looking for. I want to describe the entire concept of “control flow structures can return a value that can be assigned to things"
13:21:29 <fizruk> rhs?
13:21:42 <Cale> EponymicCycloid: Well, it's multiple things you're talking about -- "assignment" isn't something that mathematics frequently talks about
13:21:46 <monochrom> I don't think it has anything to do with assignment. the expression on the right hand side can be called "compound expression"
13:22:14 <sclv_> definition
13:22:16 <EponymicCycloid> Cale: Just the idea that control flow structures can have values, instead of just being things that tell the instruction pointer where to go
13:22:16 <sclv_> not assignment
13:22:16 <Cale> (at least not in the sense of imperative programming languages)
13:22:38 <monochrom> well it has nothing to do with definition either.
13:22:41 <sclv_> sometimes we talk about "piecwise definition of functions"
13:22:51 <sclv_> well "x = y" i would tend to say that this is a definition
13:22:53 <dgpratt> at least in Haskell, pattern matching always yields a value, no? why can't this be referred to simply as "pattern matching"?
13:22:53 <sclv_> of x to be y
13:22:55 <sclv_> in haskell
13:22:58 <monochrom> you have an expression. it is not atomic. then what is it? that is the question. the answer is compound.
13:23:00 <sclv_> sorry, not in haskell, in math
13:23:14 <Cale> Yeah, compound expression perhaps
13:23:16 <carter> Cale: sclv_  is https://hackage.haskell.org/package/lattices-1.2.1.1 the best lattice lib on hackage?
13:23:17 --- mode: Cale set -o Cale
13:23:24 <carter> or are there others i should also check out::
13:23:32 <monochrom> it does not matter you use this compound expression in a definition, or assignment, or an essay, or whatever
13:23:40 <Cale> carter: I've never had the occasion to use a library for lattices in Haskell
13:23:43 <EponymicCycloid> dgpratt: I want to include *all* kinds of expressions, including if/else statements and such
13:23:52 <carter> Cale: i'm messing around with CRDTs this afternoon
13:24:07 <carter> and a lattice can be viewed as being like a commutative monoid
13:24:07 <sclv_> monochrom: no lets argue about definitions of words some more, please!
13:24:10 <dgpratt> technically all that boils down to pattern matching I think, but I get your point
13:24:30 <EponymicCycloid> Honestly, I think “complex expression” is alright, I just don’t want people to think I’m talking about math
13:24:44 <sssilver> Guys, why won’t putStrLn "Hello, " ++ name ++ "!" work, but putStrLn ("Hello, " ++ name ++ "!") does?
13:24:49 <Cale> EponymicCycloid: Then just "expression" will do, won't it?
13:24:55 <monochrom> I have never heard "complex expression"
13:24:56 <sssilver> does it attempt to concatenate name to the result of putStrLn “Hello” instead?
13:25:04 <sssilver> which is an IO?
13:25:07 <Cale> EponymicCycloid: If you want to include all kinds of expressions, the word "expression" will suffice ;)
13:25:10 <EponymicCycloid> Cale: I want to differentiate from “simple expression”, like `foo = 5`, where you’re assigning from just 1 thing
13:25:10 <Lethalman> sssilver, exactly
13:25:16 <sssilver> OK, makes sense
13:25:18 <Lethalman> :t putStrln "foo" ++ "bar"
13:25:19 <lambdabot>     Not in scope: ‘putStrln’
13:25:19 <lambdabot>     Perhaps you meant one of these:
13:25:19 <lambdabot>       ‘putStrLn’ (imported from Prelude),
13:25:23 <glguy> expressiods
13:25:23 <Lethalman> right
13:25:39 <Cale> sssilver: Yeah, it's important to remember that function application binds more tightly than any infix operator
13:25:54 <sclv_> well 5 and "if true then 5 else 12" are both "just one thing" semantically
13:25:55 <Cale> sssilver: So  f x ++ y always means (f x) ++ y
13:26:04 <sclv_> you're looking for a syntactic criteria
13:26:08 <sssilver> yeah, gotta keep that in mind Cale
13:26:23 <sssilver> I’ll just use a whole lot of parentheses to be explicit
13:26:28 <EponymicCycloid> sclv_: I want to differentiate from languages like C where e.g. if statements and case/switches don’t return values, but just direct program flow
13:26:51 <sclv_> "in haskell, every expression has a value"
13:26:55 <bennofs> EponymicCycloid: just say that if statements and case/switches are expressions?
13:27:13 <EponymicCycloid> bennofs: yeah, but is there no cool word to describe that concept?
13:27:25 <monochrom> compound expression is the cool word
13:27:26 <sclv_> "in imperative languages, we distinguish between statements and expressions, with the latter having values, and the former just doing things"
13:27:29 <EponymicCycloid> “metaexpressions” or something
13:27:34 <EponymicCycloid> Compount expressions might work
13:27:41 <carter> haskell is a lovely imperative language
13:27:58 <sclv_> "in functional languages we only have definitions and expressions, no 'statements'"
13:28:31 <monochrom> it is the word used in books and papers on parsing and formal languages
13:29:06 <monochrom> atomic and compound
13:29:16 <glguy> sure, books, but what do they use on Twitter?
13:29:27 <sclv_> emoticons
13:29:30 <EponymicCycloid> BigData Hadoop Cloud expression?
13:29:32 <pseudolio> "Compound" almost certainly refers to things besides 'case' and 'if', because there's no reason to single those out.
13:29:55 <sclv_> right "1 + 2" and "if x then y" aren't really different
13:30:11 <EponymicCycloid> sclv_: yes, in Haskell as opposed to, say, C
13:30:48 <sclv_> well we would say "in haskell, if and case are part of expressions, in C, if and switch are control flow constructs that exist at the level of _statements_
13:30:49 <sclv_> "
13:31:06 <monochrom> I took liberty to generalize from "if, case" to everything not atomic. I am sure this is the X problem, not the Y problem.
13:32:48 <smiller2> I'm confused by parallelism in Haskell.  Looking at http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel.html, it looks like when one wants to evaluate an expression in parallel, one writes "(,,) <$> rpar a <*> rpar b<*> rseq c".  The "rseq" is confusing me.  Why is it "rseq" rather than "rpar"?   Should the last component need to be rseq instead of rpar for some reason?
13:33:48 <carter> smiller2: have you read simon marlows book?
13:33:56 <carter> @google concurrent and parallel haskell
13:33:57 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
13:33:57 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
13:34:38 <sssilver> I’m trying to write a very simple program that asks for name and writes “Hello ” ++ name if name is Alice. What’s the proper way to structure it? Consider the conditional inside a function greet? Or call function greet depending on the name given
13:34:41 <sssilver> I guess 2nd
13:34:44 <sssilver> right?
13:34:53 <smiller2> carter: I hadn't heard of it; I appreciate the suggestion =)
13:35:08 <carter> good :)
13:36:31 <Welkin> sssilver, take a look at LYAH
13:36:37 <Welkin> @lyah
13:36:37 <lambdabot> Unknown command, try @list
13:36:46 <Welkin> @google learnyouahaskell
13:36:47 <lambdabot> http://learnyouahaskell.com/
13:36:47 <lambdabot> Title: Learn You a Haskell for Great Good!
13:36:59 <pjdelport> sssilver: Only if the name is alice? You can do that with a conditional inside a function, yes.
13:37:06 <Welkin> there is an example for exactly what you want to do
13:37:32 <sssilver> pjdelport: but that doesn’t seem to be right. Why would a function be aware of such restriction? A greet function would just greet anyone.
13:37:44 <sssilver> Restriction would better be applied at the place where greet is called, no?
13:37:55 <sssilver> Welkin: thanks!
13:37:55 <pjdelport> sssilver: Well, it depends what you want it to do, of course. It sounded like that's what you want. :)
13:38:20 <pjdelport> If you want the restriction outside of the greet function, that's perfectly fine too.
13:38:39 <sssilver> I just thought it’d make more sense, and make greet a more universal function
13:38:44 <pjdelport> It matters less for a toy program; in a real program, you'll usually have additional restrictions that determine how it makes sense to structure things.
13:39:54 <pjdelport> You could have: greeting name = "Hello " ++ name (or if you're feeling point-free: greeting = ("Hello " ++) )
13:41:41 <pjdelport> You could have a separate function that actually prints the greeting, or you could just do the printing in your main.
13:42:02 <pjdelport> Same for the conditional processing.
13:43:26 <amarks> I cannot use functions that return IO in a non IO function correct?
13:43:50 <a3gis> amarks: i.e.?
13:44:10 <amarks> I want to rawSystem some command for each string in a list
13:44:31 <amarks> so say I have a function that takes a string, then rawSystem cmd [mystring]
13:44:38 <amarks> but I don't care about the output
13:44:43 <carter> mapM_
13:44:46 <carter> :t mapM_
13:44:47 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
13:44:59 <carter> :)
13:45:54 <Welkin> :t mapM
13:45:55 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:46:38 * hackagebot apiary 0.4.0.2 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.4.0.2 (HirotomoMoriwaki)
13:46:40 * hackagebot rest-stringmap 0.1.0.1 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.1.0.1 (AdamBergmark)
13:47:32 <a3gis> I am planning to start a haskell beginner group next year at my university, would anyone have good introductory slides I could take inspiration from?
13:47:54 <a3gis> it would be targeted at people who have no experience whatsoever with programming
13:48:07 <Welkin> @google learnyouahaskell
13:48:08 <lambdabot> http://learnyouahaskell.com/
13:48:08 <lambdabot> Title: Learn You a Haskell for Great Good!
13:48:10 <Welkin> use that
13:48:17 <Rembane> a3gis: Do you speak swedish?
13:48:24 <a3gis> yep I know that one already :p
13:48:26 <a3gis> Rembane: haha no.
13:48:31 <Rembane> a3gis: Darn.
13:48:41 <Rembane> a3gis: There are quite good slides in swedish.
13:49:01 <a3gis> Rembane: there seems to be a lot going on in Sweden for FP related stuffs
13:49:31 <Welkin> don't use slides...
13:49:40 <a3gis> how hard is it to learn Swedish? ^_^
13:49:41 <Welkin> those are the worst presentations
13:49:53 <Welkin> engage your audience rather than put them to sleep
13:50:15 <a3gis> Welkin: we have a course on haskell, using that book. The idea would be to have a bimonthly meetup with a few 15min talks
13:50:34 <Welkin> yeah, just talk and perhaps show some code in an editor
13:50:38 <Welkin> there is no need for slides
13:50:46 <Welkin> they are a waste of time to make and boring to watch/read
13:50:52 <a3gis> the slides were more for me to find inspiration for topics/examples
13:51:02 <a3gis> I completely agree that slides are boring
13:51:16 <Rembane> a3gis: There is. Chalmers University is a quite nice place to be. :)
13:51:39 * hackagebot zip-archive 0.2.3 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3 (JohnMacFarlane)
13:51:41 <a3gis> Rembane: how hard is it to learn Swedish? ^^'
13:51:56 <bitemyapp> a3gis: how hard is it to survive a Swedish winter?
13:52:00 <bergmark> if you learn norweigan first it's quite easy probably
13:52:42 <a3gis> bitemyapp: meh, I kind of enjoy cold weather
13:52:43 <sssilver> so is it an accepted practice to use an `if` in Haskell?
13:52:46 <smiller2> Huh.  I'm reading through http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf , and in ghci I type "let x = 1 + 2", "seq x ()", and then ":sprint x", ghci prints out "x = _"!  Shouldn't x be evaluated?
13:52:48 <sssilver> it just makes me feel imperative
13:53:14 <smiller2> (On a remote server, though, I'm getting the correct "x = 3".)
13:53:19 <sssilver> don’t wanna write something like `if name == “Alice” greet name`
13:53:27 <Welkin> generally you can avoid conditionals by using guards
13:53:38 <Welkin> and/or pattern matching
13:53:48 <fizruk> :t when -- sssilver
13:53:49 <lambdabot> Monad m => Bool -> m () -> m ()
13:53:56 <a3gis> bergmark: alright, I've got a goal for next year
13:53:57 <joelteon> case name of "Alice" -> ...; _ -> "not alice"
13:54:04 <bitemyapp> a3gis: actually I do too, but most don't
13:54:17 <sssilver> Welkin: pattern matching souds awesome, but then I have to write a separate function just to execute the conditional
13:54:24 <Rembane> a3gis: It's very hard to learn swedish. Swedish is what you get if you merge german and somekind of strange scandic language.
13:54:27 <carter> smiller2: what ghci versions are you using for eadch machine :)
13:54:30 <sssilver> *sounds
13:54:31 <joelteon> sssilver: just use case
13:54:33 <Rembane> a3gis: So nothing really makes sense.
13:54:49 <a3gis> Rembane: :/ my mother tong is french
13:54:56 <Rembane> a3gis: Won't help you. :)
13:54:58 <joelteon> > case "Alice" of "Alice" -> "it's alice!"; "Bob" -> "it's bob!"; _ -> "it's someone else!"
13:54:59 <c_wraith> sssilver: well, if expressions are fully redundant in haskell, but occasionally they're a convenient way to write something
13:55:00 <lambdabot>  "it's alice!"
13:55:10 <a3gis> Rembane: indeed. I should probably take on German first
13:55:18 <smiller2> carter: Local (fails): 7.8.2.  Remote (works): 7.4.2.
13:55:48 <sssilver> case seems very nice
13:56:09 <Rembane> a3gis: Do it! :D
13:56:32 <a3gis> Rembane: or I could marry a Swede
13:56:39 * hackagebot attoparsec 0.11.3.4 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.3.4 (BryanOSullivan)
13:56:41 * hackagebot aeson 0.7.0.5 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.5 (BryanOSullivan)
13:56:42 <sssilver> “If it falls through the whole case expression and no suitable pattern is found, a runtime error occurs.” — why o.O
13:56:43 * hackagebot sox 0.2.2.4 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2.4 (HenningThielemann)
13:57:01 <identity> sssilver: what else should happen?
13:57:02 <sssilver> that’s kinda weird
13:57:06 <sssilver> umm.. nothing?
13:57:10 <identity> nothing?
13:57:13 <identity> what kind of nothing?
13:57:21 <geekosaur> it has to return something, it is an expression
13:57:28 <geekosaur> not a statement
13:57:31 <Rembane> a3gis: You could indeed.
13:57:33 <sssilver> hm
13:58:28 <carter> smiller2: I KNOW WHATS HAPPENING
13:58:44 <carter> smiller2: do :t x
13:58:46 <carter> on both ghcis
13:58:47 <carter> :)
13:59:05 <carter> smiller2: anything that hs a type  Num a => a
13:59:12 <carter> is kinda actually a function
13:59:20 <carter> instead of just an int
13:59:38 <carter> 7.8 ghci has defualting disabled by default
14:01:02 <carter> smiller2: am i right?
14:01:14 <smiller2> carter: Aha!  7.4.2's x is Integer, and 7.8.2's x is Num a => a.  There's the issue.  Go you =)
14:01:32 <carter> do you understand how the Num a => a  is like a function?
14:01:53 <carter> if you :: Integer 'd it
14:01:57 <carter> you'd get the same beahvioar
14:02:42 <sssilver> OK so this is my Alice greeter now — http://bpaste.net/show/KqC5i0ipOX1zBYqxudRr/ — but it seems ugly, especially line 6
14:03:11 <sssilver> I wish I could just delete line 6
14:03:15 <sssilver> but I can’t
14:03:38 <smiller2> *nod*
14:04:04 <sssilver> so what, as long as I hit that case, there _has_ to be output?
14:04:07 <budrose> Is it possible to reverse a list (or do some modification on it) before you begin pattern matching within a function?
14:04:32 <Welkin> reverse
14:04:44 <ziman> you can use view patterns
14:05:03 <Welkin> > reverse [1..10]
14:05:04 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:05:22 <Welkin> you can use case too
14:06:00 <Welkin> someFunc xs = case reverse xs of ->
14:06:21 <budrose> I guess this is what I have currently and just wanted to reverse the list before doing anything else...i'm pretty new to Haskell so I really appreciate the help: https://gist.github.com/JulianGindi/aa4ee096987e48b0d3e8
14:06:30 <vendethiel> sssilver: `when (name == "Alice") (greet name)` ?
14:06:32 <bts-> sssilver: you could replace (putStrLn "") with (return ()), which is an IO action that doesn't do anything
14:07:02 <sssilver> bts-: but that seems like an unnecessary dummy
14:07:06 <sssilver> unless I’m not getting something
14:07:49 <vendethiel> sssilver: or maybe I'm missing a reason you don't use when
14:08:53 <awestroke> @src when
14:08:53 <lambdabot> when p s = if p then s else return ()
14:09:03 <sssilver> vendethiel: I guess I haven’t gotten there yet :)
14:09:10 <Welkin> this nth prime number problem is taking longer than I thought it would...
14:09:34 <a3gis> vendethiel: o/
14:09:39 <sssilver> vendethiel: also, http://www.haskell.org/haskellwiki/Keywords doesn’t seem to list when
14:10:01 <geekosaur> it's not a keyword
14:10:01 <Welkin> I want to implement a prime counting function to reduce the solution space so that I can then use a sieve to find the primes within th reduced space and the nth prime
14:10:01 <vendethiel> sssilver: that's not a keyword :)
14:10:05 <vendethiel> > :type when
14:10:07 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:10:13 <identity> :t when
14:10:13 <lambdabot> Monad m => Bool -> m () -> m ()
14:10:22 <bts-> sssilver: when comes from Control.Monad http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad.html
14:10:42 <vendethiel> a boolean, something to do if true, and in the other case it just `return ()`s
14:10:45 <sssilver> oh. Monads are on the very last chapters of everything I read
14:11:27 <Welkin> sssilver, use this http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/#monads
14:11:31 <vendethiel> a3gis: o/
14:11:34 <Welkin> it is a brief introduction to monads
14:11:44 <Welkin> it is helpful before you go into the details
14:12:09 <Welkin> lyah explains then well, anyway
14:12:12 <Welkin> them*
14:13:09 <a3gis> sssilver: http://www.quickmeme.com/img/44/44b0bd758f8ee5c81362923f0d5c8e017c9ddf623925e60c29a4c015b89fbb45.jpg
14:13:14 <a3gis> sorry, couldn't help
14:13:45 <Rembane> That one so looks like the old Wikipedia page for isomorphisms!
14:15:11 <vendethiel> "An important remark: The first element in the sequence being evaluated to Nothing will stop the complete evaluation. This means you don’t execute all lines. You get this for free, thanks to laziness." I remembered reading otherwise, uh
14:15:36 <sssilver> a3gis: I feel like I’ve suddenly shifted my existence into a parallel reality where a monad being “a monoid in the category of endofunctions” is suddenly quite a straightforward and common concept.
14:15:53 <identity> endofunctors*, tho
14:16:06 <sssilver> yeah, that
14:16:14 <sssilver> netsplit doesn’t make it easy
14:16:53 <a3gis> sssilver: I know right? at some point it starts to make sense and you're like "I'm never going to make friends again"
14:16:56 <identity> I was at the bar last tuesday, where I met this guy from my school who's studying some finance stuff. He was considering switching to CS. He asked me which programming languages I was proficient in, and I mentioned Haskell, he said "oh shit, then you must be like a genius"
14:17:22 <Welkin> perception is worth a lot
14:17:22 <carter> lol
14:17:26 <identity> this guy doesn't even program and that notion about Haskell has still reached him
14:17:32 <carter> thats cute / neat
14:17:33 <Welkin> tell him you charge $5000 per hour
14:17:36 <carter> identity: where you a student
14:17:42 <carter> *where are
14:18:29 <bitemyapp> identity: wow
14:18:31 * vendethiel overheard one guy explaining monoids to someone else in a bus ...
14:18:41 <bitemyapp> vendethiel: I was explaining monoids earlier to my coworkers :P
14:18:47 <identity> was it on a bus?
14:19:04 <vendethiel> identity: the one that's correct
14:19:19 <identity> I was asking bitemyapp
14:19:19 <monochrom> I am not a genius. I am dumb. it is why Haskell is easier to me. look at C, or BASIC. "x = x+1", how can that be a true sentence? I am dumb, I can't figure it out.
14:19:37 <bitemyapp> identity: no, in our office. I avoid public transport as much as possible.
14:19:50 <vendethiel> identity: but then you're leaving me hanging. is it "on a bus" or "in a bus" :)?
14:19:59 <Welkin> in a house with a mouse!
14:20:07 <Welkin> or in a box with a fox!
14:20:13 <vendethiel> I can't speak english for the life of me
14:20:23 <bitemyapp> monochrom: eh. on the one hand, I agree, on the other, there's a ramp up of working through unfamiliar concepts before the simplicity of reasoning comes through.
14:20:43 <identity> I choose to imagine public transport as me having a private chauffeur and that I'm just such a nice guy a let a lot of other people hitch a ride for a small fee. Then it's not too bad.
14:20:56 <identity> vendethiel: I think it's "on a bus"
14:21:10 <vendethiel> bitemyapp: but don't these concepts exist in other languages too :) ? I think we just became so accustomed to them, we're used to teach them now
14:21:14 <identity> but I still think "in a bus" makes more sense, really. Unless you were on top of the bus.
14:21:27 <sssilver> monochrom: that’s just an increment
14:21:30 <vendethiel> (which doesn't mean they weren't as hard to newcomers when people didn't know it)
14:21:42 * hackagebot ncurses 0.2.10 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.10 (JohnMillikin)
14:21:47 <sssilver> monochrom: you have to look at the parts after the equal sign and before the equal sign separately
14:21:57 <bitemyapp> vendethiel: not meaningfully.
14:22:01 <quchen> monochrom: It's simple! "x = x+1" is "let y = x in let x = y+1 in the rest of your program".
14:22:08 <bitemyapp> vendethiel: people manage to make these awful languages that break "truth" all over the place.
14:22:12 <bitemyapp> vendethiel: at the type and term level.
14:22:19 <sssilver> monochrom: it basically says — “take the value of x, add 1 to it, assign the result back to x”
14:22:27 <bitemyapp> if people read books more often before hacking on a compiler, we wouldn't have these problems.
14:22:44 <sssilver> much simpler than something in the category of endofunctors, at least by the sound of it
14:23:34 <identity> sssilver: I think he was kidding. For the most part.
14:23:35 <bitemyapp> yeah, monads are complicated than x += 1
14:23:35 <vendethiel> bitemyapp: implementing a compiler with arrows ? What are you, a PhD student ? :)
14:23:45 <bitemyapp> but basic immutable values are not.
14:23:56 <sssilver> This is quite amusing… #php has 645 members, #haskell has 1292. I am in an alternate reality afterall.
14:24:01 <bitemyapp> vendethiel: hurrr what.
14:24:15 <quchen> sssilver: There are *lots* of idlers here that never say anything though.
14:24:25 <Cale> sssilver: Formalising the interaction between that and everything else in all but the most trivial of programming languages will be much more complicated than the entire exposition explaining how monads on C are monoid objects in the monoidal category of endofunctors on C.
14:24:35 <Hafydd> That's because Haskell programmers are lazy.
14:24:37 <vendethiel> bitemyapp: nothing, nothing
14:25:03 <vendethiel> (just a reminder that the new scala thingie's phases return Unit)
14:25:10 <Cale> Typically, anyway
14:25:22 <bitemyapp> vendethiel: oh fuck them
14:25:32 <monochrom> here is another example. suppose you give me f(x)=x+x. so I can plug in, right? f(rand(6)) = rand(6)+rand(6). Haskell says that's true. C and BASIC say that's not always true, and there is a long explanation for that. I am dumb, if something ought to be simply true but there is a long explanation why it ain't, I can't figure it out. Haskell is simpler, f(x)=x+x, f(rand(6)) = rand(6)+rand(6), one consistent rule period.
14:25:51 <Cale> But that's a strawman, because you don't need to understand any of that in order to understand the application of monads in Haskell.
14:26:47 <sssilver> I just realized there’s a domain where Haskell would be a horrible choice
14:26:54 <sssilver> Video game programming
14:26:59 <identity> not really.
14:27:00 <sssilver> it’s like 99% side effects
14:27:16 <bitemyapp> sssilver: but I can constrain which effects are allowed in certain functions in Haskell.
14:27:21 <peddie> sssilver: all the more reason to have the type system help you keep track of them
14:27:32 <bitemyapp> sssilver: I can't in Haskell. There are reasons game programming might be painful in Haskell but they have nothing to do with *Haskell*
14:27:37 <Cale> sssilver: Actually, I strongly disagree, having worked on a video game in Haskell.
14:27:39 <bitemyapp> sssilver: and everything to do with industry and tooling.
14:27:44 <bitemyapp> Cale: raincat
14:27:45 <bitemyapp> ?
14:28:08 <bitemyapp> errrr, I can't do that if I'm not using Haskell.
14:28:13 <sssilver> bitemyapp: tooling as in, OpenGL bindings and such?
14:28:22 <bitemyapp> sssilver: nooooo, it goes way further than that.
14:28:31 <Cale> bitemyapp: BloodKnight. We didn't quite get it to the point where we could release something before running out of funding, but the usage of Haskell allowed us to get a lot farther than we'd otherwise have been able to get.
14:28:33 <bitemyapp> sssilver: if you're a game dev, you don't even really want to touch OpenGL if you can help it.
14:28:59 <bitemyapp> sssilver: if C# can work for Unity, so could've Haskell.
14:29:06 <sssilver> bitemyapp: what do you wanna touch then? Most real time graphics rendering goes either via DX or OpenGL
14:29:10 <identity> Cale: Really? Is that because you were more familiar with Haskell than some other alternatives, or is it because of some intrinsic attribute of Haskell?
14:29:16 <bitemyapp> sssilver: look at something like Unity and UDK to see how most people work.
14:29:17 <identity> that the alternatives didn't have, that is
14:29:29 <bitemyapp> sssilver: they'll use a mixture of scripting/systems langs in a framework.
14:29:39 <bitemyapp> sssilver: they don't futz around with OGL themselves. Really. They don't.
14:29:45 <bitemyapp> that's how division of labor works.
14:29:49 <sssilver> bitemyapp: I’d argue about “most” :)
14:29:50 <Cale> identity: We developed our own FRP system, and that helped make writing a lot of the game logic much nicer.
14:29:55 <bitemyapp> Engine devs work on the engine, not game devs.
14:29:58 <identity> Cale: I see. Interesting.
14:30:00 <sssilver> most game development companies have their own engines
14:30:07 <bitemyapp> sssilver: everybody licenses their tooling, engine, and frameworks.
14:30:10 <bitemyapp> sssilver: bullshit.
14:30:20 <Cale> Basically, the fact that Haskell doesn't have effects *everywhere* means that you can design your own libraries for managing which effects are meant to happen when.
14:30:22 <bitemyapp> sssilver: only a handful of the more well known companies write their own engines on AAA platforms.
14:30:38 <bitemyapp> sssilver: they relicense those out to the 90% of other dev shops.
14:30:41 <Cale> Most of the bugs in games have to do with updating state incorrectly.
14:30:52 <bitemyapp> ^^ yep @ updating state incorrectly
14:30:58 <bitemyapp> Cale: is BK OSS'd anywhere?
14:31:00 <Cale> e.g. state is updated in the wrong order, or updates are lost
14:31:24 <bitemyapp> Cale: did the work on BK influence the 7.8 iOS support?
14:31:26 <Cale> bitemyapp: no, but Ryan and I really should get together at some point and chop out the FRP system and open source that at least
14:31:29 <Cale> yes
14:31:29 <sssilver> bitemyapp: Blizzard? Bethesda? EA? Steam? Firaxis?
14:31:35 <bitemyapp> Cale: that would be amazing.
14:31:39 <Cale> Stephen Blackheath was working for us
14:31:43 <bitemyapp> sssilver: Bethesda doesn't use their own engine, doofus.
14:31:47 <Cale> and he's responsible for a lot of that work
14:31:50 <bitemyapp> sssilver: Steam isn't a company, it's a platform.
14:31:58 <joejev> volvo is the company
14:32:02 <bitemyapp> sssilver: EA relicenses their engine
14:32:04 <sssilver> bitemyapp: Valve sorry
14:32:08 <bitemyapp> sssilver: Valve relicenses their engine
14:32:20 <bitemyapp> sssilver: you're missing that most companies aren't Valve and EA and most games aren't made by them
14:32:21 <GrooveStomp> LOL.  volvo.  Nice. :-)
14:32:26 <jcurbo> Bethesda didn't use their own engine for Morrowind or Oblivion, but they did for Skyrim
14:32:26 <bitemyapp> GrooveStomp: standard gamer speak these days.
14:32:39 <sssilver> bitemyapp: lets take a sample game like Trine
14:32:45 <Cale> There are very few game developers who write their own engine -- we were daring enough to try it, and were almost successful ;)
14:32:48 <sssilver> you’re saying they didn’t write Trine’s engine from scratch?
14:32:48 <bitemyapp> jcurbo: they didn't for Fallout 3 and NV either.
14:32:57 <jcurbo> well, it was all based on gamebryo
14:33:11 <bitemyapp> sssilver: I don't know what to tell you man. *Most* games aren't made custom.
14:33:12 <identity> Wasn't fallout 3, NV and oblivion the same engine?
14:33:18 <jcurbo> yeah
14:33:21 <bitemyapp> sssilver: you can either believe me or you can realize not every game is AAA developed.
14:33:25 <Cale> It's a big risk-reward gamble
14:33:26 <quchen> Cale: Is there a place to take a look at that game? Concepts, screenshots? So I can weep it wasn't released?
14:33:30 <sssilver> bitemyapp: I choose to believe you
14:33:31 <jcurbo> probably with slight mods
14:33:32 <identity> (well, with updates I presume etc)
14:33:35 <identity> yeah.
14:33:46 <Cale> quchen: I don't know, I don't think our website is even still running
14:33:47 <bitemyapp> sssilver: but that's the problem, people aren't writing their own physics engines or tree generators
14:33:49 <identity> Same with the battlefield games and medal of honor etc. That was all frostbite
14:33:57 <jcurbo> but basically the same framework (well, they all kinda work the same on the inside since morrowind)
14:33:57 <bitemyapp> sssilver: they're using middleware licensed from other companies.
14:34:26 <identity> The Unreal engine gets used a lot by a lot of different companies and even completely different games/genres
14:34:35 <sssilver> that’s true
14:34:52 <identity> and even across platforms
14:34:57 <identity> IIRC.
14:35:02 <joejev> Not that I mind too much, but what sparked the conversation about game engins
14:35:08 <bitemyapp> Unreal is all over the place. At one time, so was the Quake engine
14:35:13 <jcurbo> I think the greater point here is that the number of engines in use by the gamedev community has dropped quite a bit over the past few years
14:35:15 <identity> joejev: Haskell + game dev etc
14:35:16 <bitemyapp> joejev: "is haskell appropriate for making games?"
14:35:29 <bitemyapp> joejev: the answer is, it's probably fine for situations where you'd use C# like in the case of Unity.
14:35:36 <Cale> quchen: Basically, it was an isometric view ARPG similar Diablo, with a hero that had a gigantic hammer to smash things and then use the blood on the ground for magic.
14:35:42 <bitemyapp> joejev: you'd still have some C/C++ sub-structure for the direct gfx bindings.
14:35:53 <quchen> Cale: Sounds similar to Bastion
14:35:54 <jcurbo> someone just needs to write something like Unity or UE4 in Haskell (well, there's helm)
14:35:56 <bitemyapp> Cale: oh nifty. I used to play Diablo a ton.
14:35:59 <identity> jcurbo: Probably has, yeah. There seem to be engines out there that are flexible enough to accomodate almost any type of game now, so there is probably little reason to roll your own, I assume
14:36:05 <bitemyapp> quchen: maybe, Bastion had puzzles.
14:36:09 <identity> though I don't really know very much about this whole industry/field
14:36:14 <jcurbo> identity: basically
14:36:22 <jcurbo> plus the commodiziation of game tech
14:36:30 <bitemyapp> right.
14:36:42 <bitemyapp> you pick your physics stack, plug it into the rest of it. Your tree generator middleware, plug it in.
14:36:47 <joejev> just get carmack to finish working in haskell
14:36:49 <jcurbo> id started a lot of that with licensing quake/q2
14:37:01 <bitemyapp> If you use Unity there's a whole marketplace of textures, assets, scripts, and middleware you can buy to get started quickly
14:37:08 <bitemyapp> There are whole starter packs for *kinds* of games like FPS, RTS, etc.
14:37:20 <Cale> We got it to the point where it had a reasonably fun combat system and a big map (with a map editor which let the artists design everything and place props and spawners and stuff), but most of the stuff which would really make it an RPG wasn't done, and the engine still needed some work to be efficient enough for the phones we wanted it to run on. (It ran pretty well on desktop machines)
14:37:25 <bitemyapp> which usually provide a "demo" starter game that is very simple but has the basic mechanics and assets to get you going.
14:38:06 <jcurbo> Cale: sounds interesting.  I wrote a very simple OpenGL + FRP app once, using reactive-banana
14:38:10 <identity> Maybe games would be better, though, if people were rolling their own all the time. It's all about time to market these days it seems
14:38:17 <identity> "let's spit out as much crap as we can"
14:38:19 <GrooveStomp> Cale: How does tuning Haskell for performance compare vs. C++?  I guess that's not just a gamedev related question.
14:38:21 <Cale> anyway, writing AIs is a lot more fun when you only have to describe how things depend on one another declaratively and have the system take care of the order in which to do the updates consistently, and all the caching and whatnow
14:38:22 <Cale> not*
14:38:38 <Cale> GrooveStomp: I don't know a heck of a lot about tuning C++ code
14:39:00 <GrooveStomp> Cale: What other languages have you done significant development with?
14:39:02 <bitemyapp> vendethiel: you're in the bay area aren't you?
14:39:11 <quchen> Cale: How large was your team? How long did the project last, when did it end?
14:39:19 <Cale> GrooveStomp: But GHC has a pretty good profiler, though at the scale of our application, the ability to do more with the reports it generates would have been really useful
14:39:51 <identity> Cale: When you say 'more', what specifically?
14:39:54 <bitemyapp> Cale: is the new stuff well typed released any help?
14:40:04 <identity> that was basically what I was going to ask
14:40:50 <Cale> identity: Especially since they put in the new "stack simulation", the profiles in really large programs can end up being split up into many many many pieces, each of which is tiny, and figuring out where the time is going can be tricky.
14:41:14 <Cale> I have some .prof files which are hundreds of megabytes
14:41:19 <identity> holy shit.
14:41:25 <benzrf> jjjjjjjjjjjjjjjjjjjjjjj
14:41:28 <benzrf> oops :{
14:41:35 <Cale> benzrf: in vim, yeah
14:41:38 <benzrf> haha
14:41:54 <identity> Cale: so ghc-events-analyze or w/e wouldn't have helped in this case, or?
14:42:12 <Cale> identity: I'd love to be able to say "add up all the cost stacks which contain this particular SCC"
14:42:23 <Cale> Maybe some of the newer developments would have helped
14:42:27 <Cale> I'm not as familiar with them
14:42:42 <identity> ah, okay
14:46:03 <a3gis> bitemyapp: nah, he's on Paris
14:46:27 <Cale> GrooveStomp: To be completely honest, past a certain level of significance, it's all Haskell for me :)
14:47:40 <Cale> GrooveStomp: But I've written a toy compiler in Java, and done minor work in a lot of languages. I spent a while maintaining some absolutely horrible Groovy/Grails code before we replaced it with Haskell. :)
14:49:09 <Cale> GrooveStomp: I did write a bunch of C++ in highschool, perhaps the most complicated thing I wrote was a networked tetris game, but I didn't really make use of all the tools available to me -- I never used the profiler, for instance.
14:49:10 <GrooveStomp> Cale: That's an interesting background. :-)
14:50:29 <Cale> But yeah, my degree is in pure mathematics, and I consider myself a mathematician who happens to take work as a programmer. :)
14:51:20 <a3gis> Cale: I nearly went into pure math; still considering switching...
14:53:20 <GrooveStomp> Cale: Ah, that makes sense, then.
14:53:59 <GrooveStomp> Cale: I'm super interested in Haskell these days, but definitely regret not having pursued mathematics more thoroughly.
15:21:50 * hackagebot pipes-safe 2.2.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.2.0 (GabrielGonzalez)
15:23:11 <ion> Does anyone know offhand how to include a { character in a code example in a foo.cabal description field? Thanks.
15:23:46 <ion> At least \{ does not work and i fail to find the information in the Cabal user guide.
15:29:12 <pmade> ion: make sure you don't have any blank lines in the description.  Instead of blank lines you have to have a lone period `.' on the line.
15:30:22 <ion> pmade: Yes, i am using ., thanks anyway.
15:30:35 <amarks> how can I turn [(String, String)] to [String]?  map fst [(String, String)]?
15:30:40 <pmade> Hmmm.  And the line starts with `>' too?
15:31:20 <Hafydd> const [] :: [(String,String)] -> [String]
15:31:39 <ion> pmade: Yes, the full line is "  > {-# OverloadedStrings #-}" and without it it renders fine. "  > {" and "  > { }" are minimal-ish failing examples (which fail in different ways).
15:32:33 <pmade> ion: Weird.  I don't have any other suggestions.
15:32:35 <bergey> :t map snd
15:32:35 <lambdabot> [(a, b)] -> [b]
15:32:41 <bergey> :t map (uncurry (++))
15:32:42 <lambdabot> [([a], [a])] -> [[a]]
15:33:55 <ion> pmade: Thanks anyway.
15:35:16 <amarks> are there fst,snd equivalents for (String, String, String)?
15:35:49 <ion> amarks: You almost certainly will want to do something else, such as pattern matching or not using a tuple in the first place.
15:36:27 <jle`> tuples with more than 2 elements are usually a sign that something could be done differently
15:36:35 <jle`> but sometimes i cheat
15:36:36 <pmade> ion: Sure.  The cabal docs don't help here, they just say you can use haddock format in the description field.
15:36:36 <jle`> >_>
15:36:48 <jle`> and do something like ((String,String),String)
15:36:51 <jle`> don't tell anyone though.
15:37:00 <amarks> ion: so how should I group three related strings together in an array if not tuples?
15:37:07 <jle`> amarks: a record type
15:37:18 <jle`> er wait, an array?
15:37:22 <amarks> list*
15:37:33 <jle`> what are you using it for?
15:37:50 <jle`> (a,a,a) is neither an array nor a list
15:37:55 <jle`> and is not a substitute for either
15:38:07 <amarks> [(a,a,a)] is
15:38:35 <jle`> what do you plant to do with your [(a,a,a)] ?
15:38:38 <jle`> plan
15:39:13 <ion> Nice, the Cabal.Distribution.PackageDescription prettyprinter outputs "foo\nbar\n> {-# baz #-}" as description:\n    foo\n    bar\n    > {-# baz #-}\n which then fails to parse.
15:40:31 <amarks> jle`: I'm migrating a bunch of git repositories, [(a,b,c)] a is working directory, b is origin, c is new remote
15:41:08 <Eduard_Munteanu> amarks: the working dir seems like it could be split off
15:41:46 <amarks> (a,(b,c))?
15:41:47 <ion> amarks: data Repo = Repo { workingDirectory :: Blah, origin :: Blah, newRemote :: Blah }
15:41:56 <jle`> data Repo = Repo { repoWD :: FilePath, repoOrigin :: String }, then you have [(Repo,String)].  or you could put all three of them in one record
15:41:58 <Eduard_Munteanu> Also the two remotes could perhaps be separate arguments to a function.
15:41:59 <jle`> like what iom did
15:42:08 <amarks> thanks
15:42:08 <jle`> ion
15:42:09 <jle`> sorry ion
15:42:47 <Eduard_Munteanu> How about migrateRepo :: FilePath -> String -> String?
15:42:50 <Eduard_Munteanu> Er.
15:42:56 <Eduard_Munteanu> migrateRepo :: FilePath -> String -> String -> ...
15:46:19 <ion> λ> parsePackageDescription . showPackageDescription $ emptyPackageDescription{ package = PackageIdentifier (PackageName "foo") (Version [42] []), description = "foo\nbar\n> {" }
15:46:21 <ion> ParseFailed (FromString "opening brace '{'has no matching closing brace '}'" (Just 8))
15:52:37 <Eduard_Munteanu> Any idea how I'd set a schema in 'persistent' + Postgresql? I know I can set 'search_path', but I wonder if there's explicit support for it somehow.
15:56:01 <amarks> with my cool new type, how do I apply a function like a -> b -> IO () where a and b are members of my type, I can only get so far as a list of partially applied functions [b -> IO ()]  how do I map that? or do I?
15:56:12 <patchtag> exit
15:56:38 <shachaf> Where does the list come from?
15:58:09 <shachaf> Oh, there is history.
15:58:28 <shachaf> Doesn't help.
15:59:04 <amarks> nevermind, I can just have my function take my data type
15:59:15 <Eduard_Munteanu> I was going to mention that.
15:59:33 <amarks> I'll get there, it will be slow and painful...
15:59:47 <Eduard_Munteanu> amarks: alternatively just apply the function and eliminate the datatype if you don't really need it
16:16:53 <Eduard_Munteanu> :t let f :: a -> b -> c -> (); f _ _ _ = () in f ?x `flip` ?z $ do ?y
16:16:54 <lambdabot> (?z::b, ?y::s, ?x::a) => ()
16:17:08 <Eduard_Munteanu> Does the above seem too unorthodox style-wise?
16:18:02 <Eduard_Munteanu> I like it a bit because flip looks like a placeholder there.
16:20:22 <enthropy> @type (??)
16:20:23 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:20:46 <Eduard_Munteanu> Hm.
16:21:21 <Eduard_Munteanu> enthropy: is that in any standard-ish lib?
16:21:21 <enthropy> > (,) (??) 1 2
16:21:22 <lambdabot>  Couldn't match expected type ‘a1 -> t’
16:21:22 <lambdabot>              with actual type ‘(f0 (a0 -> b1) -> a0 -> f0 b1, b0)’
16:21:31 <ion> lens
16:21:37 <Eduard_Munteanu> Ah, explains it. :)
16:21:48 <ion> I.e. *the* standard lib. ;-)
16:22:03 <Eduard_Munteanu> :t \f -> f ?a ?? ?c $ ?b
16:22:04 <lambdabot> (?c::a, ?b::s, ?a::t) => (t -> s -> a -> b) -> b
16:22:04 <ion> -ish
16:22:26 <Eduard_Munteanu> Heh, indeed.
16:22:41 <enthropy> > (,) ?? 1 $ 2
16:22:42 <lambdabot>  (2,1)
16:23:23 <Eduard_Munteanu> Ah, it is flip, just generalized from (->) r
16:28:37 * Eduard_Munteanu . o O ((??) :: (Profunctor p, Functor f) => f (p a b) -> p a (f b) -- looks a bit interesting for some reason, I wonder if it's possible)
16:29:45 <augur> Eduard_Munteanu: it is for some bifunctors. i dont remember the definition of profunctor tho
16:29:53 <augur> @hoogle profunctor
16:29:54 <lambdabot> package profunctor-extras
16:29:54 <lambdabot> package profunctors
16:29:54 <lambdabot> package representable-profunctors
16:29:59 <augur> no links :(
16:30:02 <augur> @where profunctor
16:30:03 <lambdabot> I know nothing about profunctor.
16:30:04 <Eduard_Munteanu> augur: it's just contravariant in the first arg
16:30:24 <augur> aha ok
16:31:11 <Eduard_Munteanu> p :: *^op -> * -> *, you could say.
16:31:42 <augur> sure
16:32:25 <Eduard_Munteanu> :t Data.Traversable.sequence
16:32:26 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
16:32:27 <augur> well for only certain bifunctors its true, so i imagine its also only true for certain profunctors
16:32:33 <augur> since profunctors and bifunctors are the same thing!
16:32:46 <augur> its functorial strength, fwiw
16:32:57 <Eduard_Munteanu> Er, what do you mean the same?
16:33:34 <augur> well, the profunctors from a to b are just the bifunctors from a^op to b
16:33:39 <augur> and vice versa
16:33:51 <augur> category theoretically, i mean
16:34:00 <Eduard_Munteanu> Ah, ok.
16:34:01 <acowley> Undefined symbol: "_ghczmprim_GHCziTuple_Z90T_static_info"
16:34:03 <augur> haskell cant represent that, but mathemtically
16:34:04 <acowley> what have I done?
16:34:26 <augur> so that means that it is possible to give that, but only for some profuctors
16:35:32 <augur> and/or for some functors. whichever its a property of :p
16:36:18 <Eduard_Munteanu> I suppose it is for stuff like A (x) F B -> F (A (x) B).
16:36:32 <augur> Eduard_Munteanu: but its only going to be true of particular pairs of functors
16:36:40 <augur> its almost never generally true, i dont think. maybe never so.
16:37:01 * hackagebot aeson-utils 0.2.1.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.1.1 (AdamBergmark)
16:37:06 <Eduard_Munteanu> Well, yeah, not all functors are traversable.
16:37:18 <augur> i dont think its trictly about traversability tho
16:37:22 <augur> maybe it is, i dont know
16:37:53 <augur> the type you gave before was for traversables and monads tho
16:38:11 <augur> in general there is a much larger class of functors that have this property
16:38:29 <Eduard_Munteanu> All monads are traversable in Haskell, no? (i.e. they're all strong)
16:38:43 <shachaf> Do you mean costrong?
16:38:45 <augur> i think. it'd be interesting if it turned out that _only_ traversables and monads had this property
16:38:48 <augur> probably isnt true tho
16:39:04 <shachaf> Costrong is kind of like Traversable.
16:39:20 <Eduard_Munteanu> shachaf: sequence is strength, so... :/
16:40:03 <jle`> not all monads are traversable, i don't think
16:40:04 <Eduard_Munteanu> Oh, wait, the functor is traversable or not, not the monad.
16:40:14 <jle`> IO is not traversable
16:40:19 <Eduard_Munteanu> And it's with respect to all monads.
16:40:22 <jle`> er, you mean the Traversable, right?
16:40:28 <jle`> from Data.Traversable?
16:40:34 <Eduard_Munteanu> jle`: yes
16:40:38 <acowley> Nobody recognizes my undefined symbol: _ghczmprim_GHCziTuple_Z90T_static_info
16:40:44 <jle`> yeah, it makes no sense IO (m a) -> m (IO a)
16:40:52 <jle`> at least in haskell
16:40:57 <ion> UnsafeTraversable
16:41:00 <jle`> heh
16:41:10 <joelteon> unsafeTraverseIO
16:41:54 <shachaf> acowley: A 90-tuple?
16:42:17 <coltfred>  I was trying to do a simple app that would decompress snappy files. It appears there is a package in cabal that does it, but when I run it I get this:  http://lpaste.net/104193 Is this an indication that it cannot find the installed snappy library or something else entirely?
16:42:17 <acowley> How did I end up referencing that?
16:42:19 <joelteon> well, what else would you use if you needed to return 90 values from a function?
16:42:32 <acowley> shachaf: Is that seriously what that decodes to?
16:42:54 <shachaf> acowley: Maybe?
16:43:05 <shachaf> Look up the Z-encoding, compare to other tuples, etc.
16:43:15 <coltfred> and by "run it" I mean run something that uses it.
16:43:15 <monochrom> "undefined symbol" is a linking error that highly depends on context
16:43:33 <acowley> monochrom: I usually can use the name to figure out what went wrong
16:43:37 <acowley> monochrom: But this name is funny
16:43:58 * monochrom frowns. do you run into undefined symbols systematically?
16:44:17 <acowley> What do you mean, systematically?
16:44:23 <bergmark> coltfred: sometimes this works: cabal clean; ghc-pkg unregister snappy; install and try again
16:44:29 <shachaf> I like to think of undefined symbols as a dialogue with my linker, not something that goes wrong.
16:44:32 <shachaf> copumpkin knows.
16:45:54 <catalyst> I like to think of undefined symbols as a good way to avoid runtime errors
16:46:32 <monochrom> put it this way. suppose your gum bleeds daily. bleeding is the rule, not bleeding is the exception. then you have an overarching problem.
16:46:38 <Eduard_Munteanu> -fdefer-link-errors sounds doable, hm. :P
16:46:42 <coltfred> bergmark: Hmmmm... didn't help
16:46:49 <joelteon> -fcompile-no-matter-what
16:46:59 <coltfred> it did install again which I assume means it was uninstalled
16:47:34 <acowley> monochrom: My gums are okay?
16:47:40 <bergmark> joelteon: i think the commonly used alias for that is `php'
16:47:51 <acowley> monochrom: It's a particular piece of code that won't link
16:47:59 <acowley> monochrom: I wiped out its sandbox and reinstalled
16:48:01 <coltfred> bergmark: I'm running it in GHCI
16:48:10 <joelteon> bergmark: silly, PHP isn't a compiler.
16:48:12 <coltfred> bergmark: Is that a problem?
16:50:06 <bergmark> coltfred: i have no clue what the actual problem is, but you can always try compiling it instead
16:50:06 <acowley> Oh dear me I do seem to have done something
16:50:28 <acowley> I guess I need to upgrade to 7.8 as I don't want to debug this
16:50:50 <bergmark> my experience with linker errors is that either a module isn't listed in the cabal file, or it's just some random thing that i can never figure out and it fixes itself eventually ;o
16:51:09 <acowley> bergmark: That was my first, second, and third guess
16:51:32 <bergmark> the third option would be that the package is just broken i suppose :-)
16:51:52 <acowley> It's my package!
16:52:02 <bergmark> oh :-D :-o
16:52:03 * hackagebot rest-client 0.2.3.4 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.2.3.4 (AdamBergmark)
16:52:14 <acowley> This is super annoying
16:52:50 <darthdeus> hey guys, anyone knows how can I tell haskell-mode in emacs to not automatically pop up the help telling me to enable some indentation mode?
16:52:52 <acowley> So, when I add the module in a cabal repl that loads the library package, it says it can't find: ghczmprim_GHCziTuple_Z90T_con_info or ghczmprim_GHCziTuple_Z90T_static_info
16:53:05 <bergmark> darthdeus: do you want to enable an indentation mode?
16:53:18 <darthdeus> bergmark: no, I have structured-haskell-mode
16:53:36 <darthdeus> bergmark: and for some reason when using evil-mode, when I press "o" or "O" it tries to indent and opens that popup
16:53:55 <darthdeus> because it's calling indent-according-to-mode
16:55:59 <darthdeus> i guess it's haskell-mode-suggest-indent-choice
16:56:09 <bergmark> darthdeus: ok, i can't be of much help i'm afraid, haven't used structured-*
16:56:54 <darthdeus> bergmark: uhm i think i found where this is being set up, but i'm not sure how to override this
16:57:21 <darthdeus> i found the following in haskell-mode.el (set (make-local-variable 'indent-line-function) 'haskell-mode-suggest-indent-choice)
17:04:32 <hakujin> darthdeus: did you get autocompletion working? (does auto-complete need ghcmod in emacs?)
17:05:35 <acowley> Hm, I think this is a case of me making a change, getting it to type check, and then not running it
17:05:42 <acowley> I should have noticed this linker problem yesterday
17:05:48 <darthdeus> hakujin: ghcmod has it's separate autocompletion it seems, but yeah, i have it working kinda magically
17:07:13 <hakujin> darthdeus: what packages did you end up using for it? I'm considering evil-mode too
17:07:35 <darthdeus>  hakujin evil-mode is really amazing, I've been actually trying to find things it can't do and so far it's very usable
17:08:03 <darthdeus> hakujin: auto-complete, ghc, haskell-mode and shm (structured-haskell-mode)
17:08:25 <hakujin> do you have to have a repl open for completion?
17:09:05 <coltfred> bergmark: I made the linking thing go away... then the library didn't work.
17:09:12 <darthdeus> hakujin: nope, it runs something on the background ... there is one completion from ghc-mod which kinda completes a lot of things, and then i have the regular completion which works with what is loaded in the buffers
17:09:21 <coltfred> bergmark: Thanks for your help though!
17:09:35 <darthdeus> hakujin: but i haven't really played around with that yet
17:09:52 <hakujin> darthdeus: yeah I'm interested in the ghc-mod completion. is it smart enough to give you both local and ghc-mod suggestions depending on context?
17:10:29 <darthdeus> hakujin: i'm not sure, i currently have them completely separate
17:10:43 <hakujin> YouCompleteMe is separate as well, as far as I can tell
17:10:50 <ananda> Hi, please help me with this: What is the ideomatic way to write something like transf :: [Maybe a] -> Maybe [a] so that it extracts everything from the [Maybe a] and if at least one Nothing is within that [Maybe a], transf of that should be Nothing as well I have something working, but it is extremly ugly: http://pastebin.com/kf1MU41e
17:11:08 <darthdeus> hakujin: i've spent like 6 hours today trying to make syntax checking work :) if i get everything setup the way i want i'll probably do autocomplete next
17:11:36 <hakujin> darthdeus: throw together a blog once you have a working setup!
17:11:43 <darthdeus> hakujin: i will
17:12:05 * hackagebot ghc-mod 4.1.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.1 (KazuYamamoto)
17:12:28 <jle`> ananda: sequence
17:12:40 <jle`> @src sequence
17:12:41 <lambdabot> sequence []     = return []
17:12:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:12:41 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:13:00 <jle`> :t sequence
17:13:01 <hakujin> ananda: sequenceA from Data.Traversable is an option as well
17:13:01 <lambdabot> Monad m => [m a] -> m [a]
17:13:19 <jle`> :t sequence `asAppliedTo` [Nothing]
17:13:20 <lambdabot> [Maybe a] -> Maybe [a]
17:13:34 <ananda> haha, okay thank you very much, I will play with it! :))
17:13:44 <jle`> :t T.sequenceA `asAppliedTo` [Nothing]
17:13:44 <lambdabot> [Maybe a] -> Maybe [a]
17:14:54 <acowley> I think this was a compiler bug :(
17:17:29 <jle`> ananda: if you can, try to understand how it works before you settle on using it :)
17:17:59 <darthdeus> anyone got a nice collection of yasnippet snippets for haskell?
17:18:03 <darthdeus> the default ones are pretty lame
17:18:07 <ananda> jle`: yes, I'm sitting on the implementation at the moment, trying to understand it
17:18:58 <startling> aw, there's not an instance (Bounded b, Enum b) => Enum (b, b) ?
17:19:00 <jle`> ananda: it might be tricky if you aren't familiar with the Monad instance for Maybe
17:20:11 <jle`> startling: there's an Ix instance for Ix a => Ix (a,a), if that works for you
17:20:28 <startling> it might
17:20:35 <ananda> jle`: I know, but I know there was a monad tutorial which explained them in terms of maybe, I think it was this one http://www.haskell.org/haskellwiki/All_About_Monads#Maybe_a_monad , though which I am going now :), thanks for your kindness
17:22:32 <jle`> np!
17:23:27 <vamega2> Hi. I'm thinking of writing an email filtering system.
17:23:49 <vamega2> Just something that can move emails to folders based on a set of rules.
17:24:06 <vamega2> I'm thinking of implementing some sort of rules DSL for this.
17:24:44 * Cale notices that it says "A list is also a monad" and replaces that with "List is also a monad"
17:24:53 <vamega2> But I'd like to know if anyone here has interacted with IMAP with haskell
17:28:54 <jle`> anyone care to look over my didactic blog post explaining how useful Functor and Monad are for certain applications?  i flirt with some language that might cross over into dangerous territory, misleading wise...i took much precaution but it's hard to know for sure.  also it's slightly long.
17:28:56 <jle`> http://blog.jle.im/entry/inside-my-world
17:29:26 <c_wraith> jle`: sure, I'm especially pedantic that way
17:29:46 <jle`> perfect
17:29:48 <jle`> :)
17:34:00 <c_wraith> jle`: my first objection is to "If I gave you something of type Maybe Int, would you know for sure if that Int was there or not? You wouldn’t!".  That's not really true, given tools like pattern matching.  I think, though, you could get the desired meaning across with something like "If I had a value of type Maybe Int, would you know if..." which... at least avoids that pedantic issue. :)
17:34:34 <c_wraith> jle`: phrasing it that way removes their agency to analyze the value!
17:34:36 <gamegoblin> Hey guys, I made a toy haskell web server which serves the directories on my box. Fool around with it a bit and tell me what you think: http://grantslattontestdomain.com/
17:36:00 <jle`> c_wraith: you're right; for the purposes of the post, i sort of treated Maybe as if it did not export its constructors (except when defining utility functions).  but it's not true to life and it does appease the pedantry
17:36:10 <jle`> gamegoblin: contrats :) you've been working on that for a while, i remember
17:36:35 <gamegoblin> jle` : Indeed I have. I’ve just about memorized the URI and HTTP specs at this point
17:36:55 <gamegoblin> I’ve finally gotten it working well enough to serve stuff, but the serving right now is a quick demo hack
17:37:08 <jle`> haha
17:37:10 * hackagebot zip-archive 0.2.3.1 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.1 (JohnMacFarlane)
17:37:33 <Eduard_Munteanu> gamegoblin: split it off into a parser package! I hate it that Haskell HTTP stuff keeps reimplementing that without exposing it. :)
17:38:14 <gamegoblin> Eduard_Munteanu: Alrighty. The HTTP parser is pretty comprehensive. You can go explore the code actually since it’s in the directory I’m serving
17:38:27 <gamegoblin> It’s at JustServe/src/JustServe/Http/Parsers/Http
17:38:31 <gamegoblin> Or something like that
17:39:09 <hakujin> Eduard_Munteanu: bos implemented a HTTP parser on his blog: https://bitbucket.org/bos/attoparsec/src/tip/examples/RFC2616.hs
17:39:44 <c_wraith> jle`: Your alternative definition of ageFromId is the first place (.) is used, if I was paying attention. Maybe it deserves a note that it's the function composition operator.  Not a long story, just a quick phrase.  I think that's appropriate for your intended audience.
17:40:11 <gamegoblin> hakujin: That doesn’t truly parse the requests, since it doesn’t check the content of the header fields
17:40:36 <gamegoblin> hakujin: I could do something liek “Date: lolwtfisdis” and it would parse just fine, even though that isn’t a valid http-date
17:40:40 <gamegoblin> like*
17:41:19 <gamegoblin> That being said, *most* web servers do that. They just pass the full header fields on to whatever end-program is using them (php, rails, whatever)
17:41:56 <gamegoblin> I went ahead and parsed every single header field down to the letter of the spec
17:42:25 <hakujin> gamegoblin: cool, agreed with Eduard_Munteanu that it would be a useful package
17:42:28 <c_wraith> jle`: also, the fact that inMaybe uses a where clause seems totally unnecessarily complex at that point.
17:42:49 <Eduard_Munteanu> gamegoblin: nice... it's a rather annoying protocol to parse
17:43:12 <gamegoblin> Eduard_Munteanu: You’re telling me. It took me a good two weeks of hobby hacking to get it done.
17:43:31 <gamegoblin> Probably ~10 hours or so of coding time
17:43:58 <Eduard_Munteanu> I have no idea how they parsed it back when they came up with HTTP, it's seems poorly designed for its purpose IMO.
17:44:05 <c_wraith> jle`: I'd say that legitimate functor instances "must" obey those rules, rather than "should ideally".
17:44:27 <Eduard_Munteanu> They're either masochistic or I don't know.
17:44:50 <gamegoblin> Eduard_Munteanu: The first URI spec was particularly bad for most parsers. Luckily they updated it to be more parser-friendly.
17:45:38 <Eduard_Munteanu> gamegoblin: well, there are reasons URIs need a human-readable, textual representation, but no reason to make HTTP do that as well.
17:46:36 <Eduard_Munteanu> Clearly the intended server or proxy was a human operator. :P
17:46:51 <gamegoblin> Eduard_Munteanu: I just mean stuff like the original regex for a domain name was something like “alphanum” (“alphanum or dash “)* “alphanum”
17:46:57 <gamegoblin> So your parser had to have lookahead capability
17:47:11 <jle`> c_wraith: the reason why I used a where clause was to emphasize the fact that it returns a function
17:47:13 <monochrom> customers should pay tips to servers
17:47:18 <gamegoblin> Which is particularly bad judgement for something that should be quickly parsable as it comes out of a socket
17:47:29 <negatratoron> what is the difference between a pure language and a total language?
17:47:42 <Eduard_Munteanu> gamegoblin: also the various rules like 'FOO = TEXT except this and that' :(
17:48:21 <negatratoron> looks like pure just excludes mutability
17:48:24 <gamegoblin> Indeed. If you read my URI parser or HTTP parser I have a lot of rules like “textWithoutXYZ”
17:48:25 <Eduard_Munteanu> negatratoron: totality is about something else, it's about termination
17:48:45 <c_wraith> jle`: Oh.  That makes sense.  But in that case, I wouldn't name it "go".  Name it something more related to the domain, like "lifted" or something.
17:48:50 <Eduard_Munteanu> negatratoron: a total language needn't be pure, or vice-versa
17:48:58 <jle`> ah
17:49:12 <negatratoron> I believe totality just means a function has to return a value in finite time for any input in its domain
17:49:32 <Eduard_Munteanu> negatratoron: yeah, pretty much
17:49:42 <c_wraith> jle`: and the same with liftInput, etc
17:49:42 <negatratoron> although returning a value in infinite time makes no sense
17:49:45 <Eduard_Munteanu> Or at least pieces of it, if you add coinduction.
17:49:49 <negatratoron> so it just has to return for any input
17:49:59 <negatratoron> yeah, I've heard of coinduction
17:50:37 <Eduard_Munteanu> negatratoron: you could return an infinite list (colist actually) just fine, though, because your consumer is only interested in finite bits of that list.
17:51:17 <c_wraith> jle`: your halfOfAge implementation uses =<< before your huge discussion of it, which is slightly confusing.
17:51:27 <negatratoron> I think I get that data is the minimum fixed point and codata is the maximum fixed point of a recursive definition
17:51:48 <negatratoron> I'm not convinced there would only ever be two fixed points
17:51:54 <negatratoron> why not more?
17:52:12 <monochrom> yes, there can be many more fixed points
17:52:27 <negatratoron> are we just not interested in them?
17:52:42 <monochrom> I am sometimes interested in them
17:52:47 <negatratoron> ohh
17:52:52 <Eduard_Munteanu> I don't see how the greatest fixed point with respect to bottomness makes sense.
17:53:07 <jle`> c_wraith: oh, did i accidentally use (=<<) instead of liftInput
17:53:13 <jle`> i did
17:53:15 <jle`> heh.
17:53:20 <negatratoron> What metric is being used to define "maximum" and "minimum"?
17:53:27 <negatratoron> cardinality?
17:53:30 <Eduard_Munteanu> negatratoron: definedness
17:53:53 <negatratoron> definedness?
17:54:12 <Eduard_Munteanu> negatratoron: e.g. _|_ < Just _|_ < Just (Just _|_)
17:55:08 <negatratoron> oh interesting
17:55:34 <negatratoron> so you're taking application as <
17:55:42 <negatratoron> it's not a total order
17:56:01 <monochrom> in a suitable setting, "does not answer" is one fixed point, the lowest one; "answers 5 at time infinity" is another fixed point, a bit higher up than the lowest one. this also explains why we are more interested in lowest fixed points: it already covers all observable behaviours.
17:56:33 <Eduard_Munteanu> Er, actually the least fixed point didn't make sense to me.
17:57:17 <Eduard_Munteanu> negatratoron: application of a *constructor*, I think
17:57:23 <negatratoron> ahhh good point
17:59:34 <negatratoron> so I guess when we are looking for fixed points of a set of constructors we're just looking for sets that are closed under application of the constructors
18:00:37 <negatratoron> Eduard_Munteanu: what doesn't make sense to you about least fixed point?
18:00:46 <negatratoron> chances are it doesn't make sense to me either, and I don't know it yet
18:01:20 <SrPx> Is there any library I can use to draw geometrical stuff (circles, etc) in a canvas, and it will promptly display the result on the terminal/on a window?
18:01:28 <dwcook> SrPx: gloss
18:01:39 <Eduard_Munteanu> negatratoron: you can't take the least fixed point of an arbitrary functor in a total language
18:02:22 <Eduard_Munteanu> It doesn't seem to me you can ascribe that to induction (not general induction).
18:03:21 <c_wraith> jle`: I actually like that way of looking at it.  I'm not confident it will actually help anyone, but only because it's still a tremendously abstract topic.
18:03:40 <Eduard_Munteanu> I suspect it might relate to the strict positivity requirement on inductive types, but I'm unsure.
18:03:58 <Eduard_Munteanu> (because you can't define inductive types with arbitrary structure either)
18:04:10 <jle`> c_wraith: "that way", the post's point?
18:04:24 <c_wraith> jle`: but I like that you managed to (mostly) ignore the monad laws and an explanation of higher-kinded types, and still not lie about the topic.
18:05:05 <ReinH_> Not lying about monads is quite an accomplishment ;)
18:05:15 <c_wraith> jle`: I like, in particular, that no higher-kinded type variables appear in there.
18:05:23 <pdxleif> travis can test your software on all the GHC versions?
18:05:28 <pdxleif> I'm thinking I need to support 7.4, 7.6, and 7.8?
18:06:17 <Eduard_Munteanu> And in languages like Agda you can define types which are partly inductive and partly coinductive.
18:06:28 <monochrom> you can unify "my recursion terminates" and "my recursion is productive" by: my recursion has a unique fixed point. equivalently, the least fixed point equals the greatest fixed point.
18:06:43 <erikc> is there a way to statically link libgmp and libgcc_s with ghc (on osx)? -static isn’t doing it
18:06:44 <Eduard_Munteanu> Oh.
18:07:11 <jle`> c_wraith, ReinH_: yeah, there are way too many lies already :|  i was hoping i wasn't contributing
18:07:29 <jle`> c_wraith: thanks for the review, it's a bit of a long piece i know :) perhaps out of the range for a casual reader looking into haskell
18:08:30 <jle`> i think the main pitfall i tried to avoid was saying "monads are ___", and saying "these are things; you can use the monad instance to do this."
18:08:46 <Eduard_Munteanu> monochrom: you mean when said recursive function is both coinductive and has a finite result?
18:09:31 <Eduard_Munteanu> (corecursivity doesn't exclude finiteness)
18:10:27 <monochrom> I don't need neither restrictions "coinductive" or "finite result"
18:10:45 <monochrom> continuous function is all I need
18:11:07 * Eduard_Munteanu needs some sleep, *goes away*
18:11:36 <negatratoron> 'night
18:12:38 <c_wraith> jle`: I would add one thing.  In the aside where you mention return, you should mention that there are also rules for return and =<< that monads must follow.  I wouldn't enumerate them, but I think the fact that those rules exist deserves a bit more attention than just the footnote.
18:12:41 <acowley> Noooooooo, still a 90 tuple linker error with 7.8.2
18:12:48 <acowley> All that compiling, for what?
18:13:07 <monochrom> jle`: are you writing a monad tutorial?
18:13:12 <jle`> not a monad tutorial
18:13:14 <jle`> :)
18:13:23 <jle`> a domain of problems where monads are useful
18:13:39 <jle`> still i am woried about pedantry
18:13:49 <jle`> because there is enough misunderstanding floating around and i could easily add to it
18:15:26 <acowley> Ugh, extracting a bug report for 2500 lines of code
18:15:30 <acowley> Good luck, me
18:15:33 <ananda> I want to built something like mapM for tuples: mapMTuple :: (Monad m) => (t -> m g) -> (t,t) -> m (g,g). which is fine, but I want something more like this. mapMTuple :: (Monad m) => (t1 -> m g1) -> (t2 -> m g2) -> (t1, t2) -> m (g1, g2), which is also fine. BUT now imagine t1 and t2 are different types are both instances of a typeclass which has a function foo.  if I want to mapM on this tuple with foo, so that I get something of t
18:16:19 <dwcook> ananda: you cut off at "something of t"
18:17:06 <dwcook> But generally if you want to pass a polymorphic function you need an explicit forall. Though I'm not convinced you're trying to solve the right problem.
18:17:08 <ananda> I want to build something like mapM for tuples: mapMTuple :: (Monad m) => (t -> m g) -> (t,t) -> m (g,g). which is fine, but I want something more like this. mapMTuple :: (Monad m) => (t1 -> m g1) -> (t2 -> m g2) -> (t1, t2) -> m (g1, g2), which is also fine. BUT now imagine t1 and t2 are different types which are both instances of a typeclass which has a function foo.  if I want to mapM on this tuple with foo, so that I get somethin
18:17:17 <ananda> I would have to wirte "MapMTuple foo foo" which seems stupid. Is there a better way to do this?
18:17:19 <dwcook> Now you cut off at "get somethin".
18:18:19 <monochrom> what is the name of your type class, so I can actually use it?
18:18:21 <dwcook> Instead of (t1 -> m g1) and (t2 -> m g2), (forall t g. (Foo t) => t -> g)
18:18:28 <dwcook> (If your typeclass is called Foo)
18:18:49 <ananda> thank you dwcook, I'll try that
18:19:26 <monochrom> oh well
18:19:36 <dwcook> monochrom: did you have another idea?
18:20:04 <monochrom> no, I want to use an actual name, not a made-up name, much less a made-up name made up by me
18:20:13 <dwcook> Haha, fair enough
18:20:22 <ananda> :)
18:20:40 <monochrom> made up by the asker, that's ok, it's the asker's code.
18:22:17 * hackagebot generic-aeson 0.1.0.2 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.0.2 (AdamBergmark)
18:22:27 <ananda> dwcook: did I understand you right? I have something like "mapMTuple' :: (forall t g. (XmlSer t) => t -> g) -> (t1,t2) -> m (g1, g2)" now, but ghc says Illegal symbol '.' in type
18:23:08 <dwcook> ananda: does it also tell you what extension you need to enable?
18:23:09 <ananda> ahh
18:23:48 <jle`> monochrom: feel free to scan for lies if you have interest http://blog.jle.im/entry/inside-my-world :)  but i understand it is longer than a casual read.
18:23:57 <ReinH_> Is it the one where forall means forall or the one where it means exists? :/
18:24:11 <ananda> yes it gives me flags which I should use, is this also possible with language pragmas?
18:24:30 <dwcook> ananda: yes, before your module header, {-# LANGUAGE RankNTypes #-}
18:24:45 <ReinH_> I understand not wanting to add a reserved word. But still. :/
18:25:21 <dwcook> ReinH_: are the uses of forall even fundamentally different?
18:25:49 <ReinH_> One is existential...
18:26:07 <dwcook> I understand that. The question still stands.
18:26:15 <ReinH_> forall and exists are pretty different?
18:26:33 <dwcook> But can you quantify the difference? (No pun intended)
18:26:37 <c_wraith> ReinH_: they're duals.  You can encode either with the other.
18:27:12 <ReinH_> c_wraith: that's true.
18:28:29 <codygman> Can anyone tell me 1) Why this won't get results from the bigger citylots.json and how to debug it (https://github.com/zemirco/sf-city-lots-json/blob/master/citylots.json) 2) why it takes so long (17 seconds) to print out "no results": http://lpaste.net/104160
18:30:21 <monochrom> they are duels in that the person entitled to choose how to instantiate a forall and the person entitled to choose how to instantiate an exist are opponents in a two-person game.
18:31:05 <dwcook> They are also duels in that they involve pistols and showdowns at sunrise
18:31:10 <monochrom> I don't know how fundamental you want, but "I have a winning strategy" and "I don't have a winning strategy" are fundamentally different to me.
18:32:21 <monochrom> the difference translates to "my program is correct" and "my program is incorrect". is there a fundamental difference between a correct program and an incorrect program?
18:32:41 <dwcook> Depends on the notion of correctness I suppose?
18:33:10 <monochrom> pick any notion of correctness that doesn't say "every program is correct" or "every program is incorrect"
18:33:32 <dwcook> "It compiles"
18:33:59 <monochrom> that is good enough. are "a program that compiles" and "a program that doesn't compile" fundamentally different?
18:34:28 <ananda> dwcook: sry, but I'm still having problems with this: I have now mapMTuple' :: Monad m => (forall t g. (XmlSer t) => t -> g) -> (t1,t2) -> m (g1, g2). I think the type is correct now, but there has to be a mistake in my implementation. Can you help me one more time please?:   mapMTuple' f (c,d) = do {c' <- f c; d' <- f d; return (c',d')}
18:34:31 <dwcook> I'm not even sure what information is needed here. Maybe my concept of "fundamental" was ill-formed.
18:34:34 <monochrom> if you edit your program to replace one "forall" by one "exist", you can already cross over that boundary.
18:34:55 <ananda> dwcook: I get Could not deduce (XmlSer t2) arising from a use of `f'     from the context (Monad m)       bound by the type signature for
18:35:32 <dwcook> ananda: you didn't tell it that t1 and t2 are XmlSer
18:36:03 <monochrom> according to one philosophy, "a program that does not compile" does not even exist, it should be properly called "a text that is not a legal program". I forgot whether it's Church's or Curry's.
18:37:15 <monochrom> I am pretty sure that even subjectively, "a program" and "an illegal text file" are fundamentally different
18:37:32 <dwcook> monochrom: agreed.
18:38:21 <dwcook> ananda: By the way, you can get away with weaker than Monad here. For that matter, you don't even need m be it a Monad or anything else.
18:39:00 <ananda> dwcook: okay thanks, I'll look at that later, first I have to get my head around the forall syntax :)
18:45:12 <yaymukund> I'm trying to wrap my head around this "Hello world" code -- https://gist.github.com/yaymukund/205715d91db1e294e01f
18:45:54 <yaymukund> what's this a:t@(b:_) business?
18:46:06 <bergmark> yaymukund: a pattern
18:46:06 <albeit_> Question about threads: This article (http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html) says that context-switching between a forkOS thread (which main program threads are) and forkIO threads is expensive. So should the main program thread really do nothign except launch the other threads and terminate the program when they complete?
18:46:20 <pingu> yaymukund: eah, that's pretty for a "hello world"
18:46:24 <bergmark> yaymukund: you can probably read about this in learn you a haskell or something
18:46:34 <yaymukund> bergmark: yup, I haven't seen the @ before. I think that's what's tripping me up
18:46:43 <yaymukund> okay, I'll look for @ under patterns
18:46:47 <pingu> yaymukund: wow, my sentence didn't quite make it there, I meant:
18:46:47 <yaymukund> thanks
18:46:53 <pingu> that's pretty eseoteric for a "hello world"
18:47:22 <bergmark> yaymukund: ok, that binds an outer pattern, so if you have t@(x:y) and match against [1,2,3], t=[1,2,3], x=1, y=[2,3]
18:47:22 <yaymukund> well I'm working through euler and I was stubborn about doing fibonacci with a recursive list
18:48:02 <yaymukund> bergmark: oooooo. that makes sense.
18:48:07 <bergmark> indeed :D
18:48:39 <yaymukund> ty all!
18:51:21 <bergmark> yaymukund: it's called an "as" pattern by the way
18:53:34 <bergmark> maybe you'd read it as "bind x cons y as t"
18:53:35 <yaymukund> haha, I won't try to google that
18:54:34 <yaymukund> it's just syntactic sugar, right?
18:54:59 <bergmark> hmmm i'm not sure if it desugars to something else
18:55:14 <yaymukund> https://gist.github.com/yaymukund/205715d91db1e294e01f
18:55:24 <yaymukund> there's my version below it without the t@
18:55:58 <bergmark> haskell report says
18:56:10 <bergmark> case e of { xs@(x:rest) -> if x==0 then rest else xs } is equivalent to: let { xs = e } in  case xs of { (x:rest) -> if x==0 then rest else xs }
18:57:05 <bergmark> yaymukund: your version is slightly different, it may construct a new cons cell
18:58:03 <yaymukund> ah
18:58:13 <bergmark> not that it matters in practice
18:58:18 <bergmark> might be optimized away too
19:01:13 <yaymukund> hmm, I think I see
19:01:29 <yaymukund> you mean if the matched list has fewer than 3 elements?
19:06:32 <dwcook> albeit_: Note the last paragraph under http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#g:8
19:06:49 <dwcook> (Starting "Note in particular…")
19:06:59 <bergmark> yaymukund: no that would mean you get a pattern match failure
19:07:22 * hackagebot postgresql-simple 0.4.2.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.2.2 (LeonSmith)
19:07:22 <albeit_> dwcook: Yep, I read that for sure, I just didn't know what they meant by "repeated communication". I'm guessing that means anything except launching and shutting down threads?
19:07:29 <bergmark> yaymukund: i investigated, if you compile with -O2 it does optimize it away :-)
19:07:42 <albeit_> Actually, rereading it, that is what it says.
19:07:46 <dwcook> albeit_: Also in particular the last sentence of that same paragraph.
19:07:53 <albeit_> Thanks for making me reread dwcook ;)
19:07:58 <dwcook> No problem. :)
19:10:33 <monochrom> when two threads do "repeated communication" with each other, it implies repeated switching between the two threads. if switching is expensive, then repeated switching is repeatedly expensive. switch is expensive when at least one thread is bound.
19:11:17 <albeit_> Got it, so basically: do nothing except the absolute bare minimum in a bound thread.
19:11:27 <monochrom> or, do everything
19:11:36 <albeit_> Ha, fair enough!
19:12:05 <bergmark> yaymukund: this was my overkill/fun for the day, here's the extra cons if you don't do -O2 https://gist.github.com/bergmark/792058a0af0a26775612#file-fib2-core-hs-L29
19:13:51 <yaymukund> bergmark: haha
19:14:37 <yaymukund> I should mention at this point that this is my second day learning Haskell.
19:14:41 <yaymukund> but I will stare at this
19:15:11 <monochrom> oh, communication means e.g. "I putMVar, you takeMVar". also "I readTVar and keep retrying until you writeTVar a value I want"
19:17:04 <monochrom> I guess most programmers don't quite realize that synchronization is a special case of communication.
19:17:23 * hackagebot assertions 0.1.0.3 - A simple testing framework.  http://hackage.haskell.org/package/assertions-0.1.0.3 (vi)
19:17:25 * hackagebot clippings 0.1.1 - A parser/generator for Kindle-format clipping files (`My Clippings.txt`),  http://hackage.haskell.org/package/clippings-0.1.1 (vi)
19:17:46 <bergmark> yaymukund: :-) this is the intermediate Core language that ghc uses, i've never needed to look at it...
19:18:00 <monochrom> I had it easy because I took a course that partitions "concurrency + parallelism" a different way and IMO cleaner.
19:19:26 <monochrom> its concurrency = possible parallelism, period. the threads don't talk to or wait for each other at all. well, except at fork and at join.
19:20:23 <monochrom> then, it has another chapter called "communication" for message passing, shared variables, locks, etc. it sends you the message that locks are communication too. but of course, it communicates 1 bit of information "I am done"
19:21:14 <heath> Good evening everyone!
19:21:38 <heath> Finally a night to relax and play with Haskell
19:22:08 <heath> Is it possible to instruct lambdabot to store a quote?
19:22:09 <albeit_> monochrom: So you were taught that to do concurrency without thread communication? How does that work? Lots of threads ending and new ones launching?
19:22:15 <heath> or do you need certain privs?
19:22:24 * hackagebot kmeans-par 1.0.2 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.0.2 (vi)
19:22:26 * hackagebot markov-processes 0.0.2 - Hidden Markov processes.  http://hackage.haskell.org/package/markov-processes-0.0.2 (vi)
19:22:28 * hackagebot metric 0.1.4 - Metric spaces.  http://hackage.haskell.org/package/metric-0.1.4 (vi)
19:22:49 <monochrom> no, I was taught that concurrency and communication are two orthogonal tools. of course I can use them together.
19:24:39 <monochrom> if I getLine, that's message passing. if I readTChan, that's also message passing. the commands are pragmatically different. the proof of correctness is the same. one single theory of message passing covers both.
19:24:52 <heath> lambdabot: @quote writeScheme48Hours  In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise.
19:24:52 <lambdabot> No quotes for this person. And you call yourself a Rocket Surgeon!
19:25:04 <heath> lambdabot: @quote writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:25:04 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
19:25:14 <heath> lambdabot @quote writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:25:20 <heath> @quote writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:25:20 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
19:25:34 <heath> lambdabot @quote writeScheme48Hours
19:25:41 <heath> lambdabot: @quote writeScheme48Hours
19:25:41 <lambdabot> No quotes match. It can only be attributed to human error.
19:25:46 <heath> indeed
19:27:25 * hackagebot wright 0.1.0.2 - Colour space transformations and metrics.  http://hackage.haskell.org/package/wright-0.1.0.2 (vi)
19:28:07 <bergmark> heath: i think you want @remember
19:28:31 <heath> lambdabot: @remember writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:28:31 <lambdabot> Done.
19:28:35 <heath> thanks bergmark
19:28:36 <monochrom> why do you want lambdabot to remember it?
19:29:28 <heath> monochrom: because it would be nice to see this again later?
19:29:48 <monochrom> that begs the question. in which sense of nice?
19:29:54 <heath> :)
19:30:06 <monochrom> because the typical thing we use @quote for is like this:
19:30:17 <monochrom> @quote lens
19:30:17 <lambdabot> shachaf says: The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
19:30:31 <heath> is that a random quote?
19:30:33 <jle`> @quote ls
19:30:33 <lambdabot> dibblego says: everyone else's code is fixed by teaching them haskell too!
19:30:36 <heath> @quote lens
19:30:36 <lambdabot> pdxleif says: see s.p. jones & h.p. lovecraft's paper on the subject: "generic programming with lenses, barbed wire, and the fibres of sanity"
19:30:46 <jle`> @quote finger
19:30:46 <lambdabot> dalaing says: going from doing a fair bit of haskell recently to doing javascript today... sigh... it feels like the difference between typing at a keyboard and typing with a pair of those sporting-event-foam-hands-with-a-pointing-finger on
19:30:50 <heath> so you use @quote for random quote generation
19:30:58 <jle`> @quote finger monad
19:30:58 <lambdabot> No quotes for this person. Abort, Retry, Panic?
19:31:10 <jle`> @quote moon
19:31:11 <lambdabot> dmead says: Here on the moon, our weekends are so advanced they encompass the entire week
19:31:40 <monochrom> do you think that "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise." is quite in the same genre as "it feels like the difference between typing at a keyboard and typing with a pair of those sporting-event-foam-hands-with-a-pointing-finger on"?
19:32:12 <monochrom> if you are wondering, useful facts are put under @where, not @remember
19:32:31 <monochrom> funny things are put under @remember, not @where
19:36:01 <monochrom> I guess your answer is "yes"
19:38:24 <bergmark> what, seriously? i think "you should use @where for these kinds of things" would have sufficed
19:39:04 <heath> monochrom: Is there a command for removing an @remember quote?
19:39:11 <heath> I don't mind moving it
19:39:36 <monochrom> bergmark: then you should have said it earlier than I did
19:40:05 <monochrom> it is called @forget
19:40:54 <heath> lambdabot: @forget writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:40:54 <lambdabot> Done.
19:41:24 <heath> lambdabot: @where writeScheme48Hours  "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:41:24 <lambdabot> I know nothing about writescheme48hours.
19:41:47 <ion> “@where+” i think
19:42:29 <ion> Also, that might not be the best title for a @where.
19:42:44 <jle`> lambdabot: serious business
19:43:13 <monochrom>  @where is a key-value store. if you say "@where+ x y", then next time to retrieve it, you have to say "@where x"
19:43:17 <heath> >> and and >>= are both called bind right?
19:43:26 <heath> a title like BindVsDo might work
19:43:32 <albeit_> If I pass a record Foo { bar :: Int, baz :: MVar Int } to two threads, and both threads modify bar and baz in their version of Foo (baz with take/putMVar), bar is likely to be different, but the value contained in baz's mvar should be the same, correct?
19:44:12 <ion> >> is called “then” or “and then”.
19:44:31 <jle`> albeit_: hm. well you can't really modify bar
19:44:32 <Cale> albeit_: bar is simply an Int, it makes no sense to modify it
19:44:51 <jle`> you can't modify baz either, technically
19:44:53 <Cale> albeit_: You could construct a new record which has a different value for bar
19:45:33 <Cale> Right, well, to the extent that which MVar has been sent to each thread can't be somehow changed after the fact.
19:45:35 <albeit_> I guess a mean each threads version of Foo will likely have a differnet value for bar, but the value in the baz mbar will the same?
19:45:54 <heath> lambdabot: @where+ thenBindOrDo "In general, use >> if the actions don't return a value, >>= if you'll be immediately passing that value into the next action, and do-notation otherwise."
19:45:54 <lambdabot> Nice!
19:46:04 <jle`> the value referenced by baz exists outside of the threads
19:46:13 <albeit_> So baz isn't changing, but the value "pointed to" by baz is?
19:46:17 <Cale> albeit_: The value of bar will only differ if you send a different record to each thread?
19:46:51 <jle`> the value at the locaiton that baz points to does, yes
19:47:06 <Cale> and yeah, baz is a mutable cell whose value may be updated by takeMVar/putMVar/etc. but baz itself is as immutable as bar is
19:47:39 <Cale> (i.e. *which* MVar it is won't change)
19:48:12 <jle`> baz is the immutable arrow/reference/"pointer" to that location, and the location it points to won't change
19:48:13 <Cale> Unless, for instance, the entire record is the contents of another MVar which you can then update
19:48:29 <albeit_> Great thanks. Is it proper to pass a StateT MyState IO to each thread, and inside MyState have MVars that you want synced between the threads?
19:48:44 <jle`> if MyState just has MVars
19:48:47 <jle`> you are better off using Reader
19:48:48 <Cale> I'm not sure I'd ever do that myself
19:48:56 <jle`> which is State where you can't modify the state
19:49:08 <jle`> it's better off to just...pass the mystate directly
19:49:11 <jle`> as a function argument
19:49:25 <Cale> I wouldn't even bother with Reader, just pass the thing explicitly. You'll probably even create the MVars just before forking the threads, so they'll already be in scope, you may not even need explicit function parameters for them
19:49:40 <jle`> ^^
19:49:53 <Cale> (but if you want to separate out the definition of what IO action is being forked, you can just make them function parameters)
19:50:12 <albeit_> Okay. Is it okay to pass the structure if it contains a mix of MVars and "config" constant values?
19:50:29 <jle`> you might as well pass it as a function argument
19:50:32 <jle`> explicitly
19:50:35 <Cale> What do you mean by "okay"?
19:50:45 <Cale> Of course it'll work, but whether it'll do what you want is another thing?
19:50:56 <jle`> @unmtl ReaderT r IO b
19:50:56 <lambdabot> r -> IO b
19:51:00 <Cale> It'll probably do what you'd expect
19:51:09 <albeit_> By "okay" I mean if I one of you looked at the code would you think "what in the world is this guy doing"
19:51:16 <Cale> I practically never use monad transformers over IO
19:51:27 <Cale> But that's just me
19:51:31 <Cale> Lots of people do it
19:51:55 <jle`> pass it explicitly if you can.  it's usually not much trouble
19:52:01 <bergmark> albeit_: sure i do that all the time
19:52:27 * hackagebot haskell-course-preludes 0.0.0.1 - Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.  http://hackage.haskell.org/package/haskell-course-preludes-0.0.0.1 (gibiansky)
19:52:34 <Cale> and if I'm using monad transformers at all, I newtype the result, and make sure to construct a clean interface for the new monad so that you can't tell I'm using monad transformers from outside the module defining them
19:53:12 <yaymukund> maybe some code golf, but is there some way to clean up the main in this: https://gist.github.com/yaymukund/a303d4f47de23f890c9b ?
19:53:13 <jle`> i usually use Reader if I want to compose/use/write a bunch of separate functions that all want that structure.  the point where Reader makes things more expressive than just explicitly having all of those functions have that structure as their argument is debatable
19:53:32 <jle`> @src even
19:53:32 <lambdabot> even n = n `rem` 2 == 0
19:53:34 <albeit_> Awesome, thanks for all the advice.
19:53:36 <yaymukund> oh
19:53:37 <yaymukund> ha
19:53:38 <jle`> ^^ yaymukund
19:54:05 <albeit_> jle`: And by reading you mean a ReaderT r IO b?
19:54:16 <jle`> main = print . sum . filter isEven . takeWhile (<4000000) $ fibonacci, heh.
19:54:25 <Cale> fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)
19:54:41 <jle`> albeit_: by Reader I mean ReaderT etc, yeah.
19:56:21 <jle`> it sounds like your main thread function is the only one that will use the mvars, so...just pass it explicitly.  but if your thread calls a lot of functions which call a lot of functions which all reference that mvar, then (at some point) ReaderT might be more expressive.  that point is up for debate, but at least people will understnad why you are doing it and understand what you are writing
19:56:59 <jle`> some people wouldn't think Reader is worth it at any depth though
19:57:26 <ion> doesEven lift
19:57:38 <jle`> heh
19:58:34 <albeit_> So, a ReaderT becomes useful in similar circumstances to when a State monad becomes useful... why the same thing is being passed among many functions
19:58:36 <bergmark> recently all I'm using is ReaderT with a config+stm vars, long live rwst :-h
19:58:37 <albeit_> *when the same thing
19:58:40 <jle`> response bro | doesEven lift bro = Respect
19:58:50 <jle`>              | otherwise       = Derision
19:59:11 <jle`> albeit_: State monad becomes useful a lot sooner than ReaderT does
19:59:30 <Cale> albeit_: Especially if you can build a little language's worth of primitives to be combined, so that you don't end up using 'lift' everywhere explicitly
19:59:59 <Cale> If you're going to be using lift a lot, it often ends up being more verbose than just passing the parameter
20:02:20 <yaymukund> Cale: thanks!
20:02:28 * hackagebot haskell-course-preludes 0.0.0.2 - Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.  http://hackage.haskell.org/package/haskell-course-preludes-0.0.0.2 (gibiansky)
20:03:34 <sayuke> anyone know how to darcs clone "darcs 2.9.1"
20:05:08 <bergmark> i just tried to compile darcs.... didn't work :-(
20:07:00 <sayuke> bergmark: thats why I'm hoping 2.9 will work
20:07:11 <sayuke> Just don't know how to get it
20:07:13 <sayuke> the docs are up...
20:15:44 <spott> I want to create a function that adds two numbers together, say an Integer and a Double, and returns the "greater" type.  (in this case a Double)
20:15:58 <spott> How do I do that?
20:16:55 <pavonia> You could create a new typeclass that has an add function
20:17:19 <pavonia> and create instances according to the possible combinations
20:17:20 <ion> fromIntegral a + b
20:17:30 * hackagebot rest-client 0.2.3.5 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.2.3.5 (AdamBergmark)
20:17:32 * hackagebot rest-core 0.30.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.30.0.1 (AdamBergmark)
20:17:34 * hackagebot rest-gen 0.10.0.3 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.10.0.3 (AdamBergmark)
20:17:37 * hackagebot rest-happstack 0.2.9.9 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.9.9 (AdamBergmark)
20:17:39 * hackagebot rest-snap 0.1.17.10 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.10 (AdamBergmark)
20:17:39 <bergmark> yeah i was also thinking about a multiparam typeclass
20:18:00 <glguy_> spott: keep in mind that neither Double nor Integer is "greater"
20:18:18 <spott> glguy_: I know
20:18:52 <pavonia> Well, in Haskell Integer actually is greater
20:18:53 <spott> ion: that works for the specific example I used, but not for the oposite
20:19:07 <glguy_> But if you're going to pick an arbitrary thing you'll probably need a three-parameter type class and want to use functional dependencies to constrain the result type
20:19:48 <spott> I'm trying to add Double's to a toy scheme compiler I'm writing
20:20:09 <spott> I've made the decision that Double + Integer = Double
20:20:24 <spott> but I'm not sure how to implement it... I have to use a typeclass?
20:20:32 <glguy_> Do you have a single Value type with a constructor for Double and a constructor for Integers?
20:20:43 <spott> glguy_: yup
20:20:51 <spott> data N = Integer | Double
20:20:55 <glguy_> You'll just need to implement the 4 cases in your code
20:20:56 <jle`> you can just pattern match then
20:21:08 <jle`> er, do you mean data N = I Integer | D Double
20:21:15 <spott> jle`: yea
20:21:15 <spott> I do
20:21:17 <glguy_> add (Integer i) (Double d) = Double (fromIntegral i + d)
20:21:18 <glguy_> etc
20:21:28 <spott> glguy_: thanks!
20:21:32 <spott> I didn't think about that
20:22:41 * hackagebot rest-types 1.10.0.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.0.1 (AdamBergmark)
20:29:07 <jle`> yaymukund: isn't it cool that that code only does one pass through the list to sum and filter the fib numbers
20:29:30 <jle`> yaymukund: even if you did sum . map (^2) . filter even, it would only look at each necessary element in the fib list once.
20:36:02 <redtricycle> How do I subtract a number from everymember of the list?
20:36:10 <redtricycle> map (-7) [10,11,12]
20:36:16 <redtricycle> and return... [3,4,5]
20:36:59 <triliyn> That's kind of a syntactic special case
20:37:18 <redtricycle> list comprehension works
20:37:19 <triliyn> (-7) doesn't mean flip (-) 7, it means "the opposite of 7"
20:37:24 <redtricycle> ah
20:37:31 <triliyn> map (subtract 7) instead
20:39:26 <toki78> hi
20:39:37 <toki78> I wouldw like to prot this to haskell
20:39:41 <toki78> http://toki.burn3r.de/qzeronn.html
20:39:48 <toki78> prot -> port
20:40:22 <toki78> hackage has no reinforcement algo, is that right ?
20:49:09 <spott_> glguy, jle`: Thanks btw. I appreciate the help.
20:56:55 <codygman> Using ghc 7.8.1 why isn't -p giving me any profiling information? Did it change? http://lpaste.net/104194
21:00:03 <didy_kithz> hello, nice meet you
21:01:10 <Cale> didy_kithz: hello!
21:02:22 <Cale> codygman: Did your program terminate?
21:02:36 * hackagebot errors 1.4.7 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.7 (GabrielGonzalez)
21:02:39 <EvanR2> (a,a,[a]) -> [(a,a)]
21:02:52 <didy_kithz> i began haskell from 2 month ago
21:03:14 <Cale> didy_kithz: Cool! Feel free to ask any questions you might have :)
21:05:39 <codygman> Cale: Yes my program terminated.
21:05:59 <toki78> Cale, is there a RL algo package ?
21:06:11 <Cale> RL algo?
21:06:24 <toki78> Cale, Reinforcement Learning algorithm
21:06:32 <Cale> I don't know
21:06:36 <Cale> You should check hackage
21:06:50 <Cale> I don't see anything immediately...
21:06:53 <Cale> http://hackage.haskell.org/packages/
21:07:00 <codygman> Cale: I think it's a ghc 7.8.1 thing. Because the example from: http://book.realworldhaskell.org/read/profiling-and-optimization.html doesn't show info when run with "time ./A 1e7 +RTS -p"
21:07:19 <Cale> toki78: there are a few things under the machine learning section there
21:08:03 <toki78> Cale no Reinforcement Learning there :(
21:08:15 <toki78> Cale, how can I contribute one ?
21:08:37 <Cale> toki78: http://hackage.haskell.org/accounts
21:08:46 <toki78> Cale, great !!
21:09:17 <toki78> Cale, I hope,, it will be useful :)
21:10:39 <Cale> codygman: You have -fprof-auto as well, I can't see any reason why it ought not to work.
21:23:51 <toki78> Cale, hackage has no user account page ?!?
21:24:20 <Cale> toki78: hm?
21:24:46 <Cale> toki78: Your account gives you the ability to upload packages, that's about all there is to it
21:25:38 <toki78> Cale, okay
21:26:40 <bergmark> toki78: there's http://hackage.haskell.org/user/DonaldStewart
21:28:24 <redtricycle> how do I get a sublist?  I am doing this [xs !! idx | idx < [5..7]] (seems silly)
21:28:37 <toki78> bergmark, I contacted http://industry.haskell.org/
21:29:04 <bergmark> ok? :-)
21:29:08 <toki78> bergmark, I want a team for that
21:29:31 <bergmark> a team, what do you mean?
21:29:32 <toki78> sveral developers for - let's say RL.hs
21:29:53 <toki78> I have a github account
21:30:22 <toki78> no reinforcement learning available for haskell -- that is intersting :)
21:32:28 <redtricycle> found it
21:32:37 <redtricycle> drop 5 . take 7 $ xs
21:32:39 * hackagebot vector-th-unbox 0.2.1.0 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2.1.0 (LiyangHu)
21:37:54 <EvanR2> > 0 % 1
21:37:56 <lambdabot>  0 % 1
21:37:57 <EvanR2> > 0 % 2
21:37:59 <lambdabot>  0 % 1
21:38:18 <EvanR2> > -0 % 1
21:38:20 <lambdabot>  0 % 1
22:12:13 <redtricycle> Why doesn't mapM_ work with arguments?
22:12:15 <redtricycle> like,
22:12:26 <redtricycle> mapM_ (myfunc xs) [1,2,3,4,5]
22:12:52 <LordBrain> what'st he type of myfunc there?
22:13:27 <LordBrain> if the types are right, that should be fine
22:13:43 <ReinH> @tell edwardk ping me please :)
22:13:43 <lambdabot> Consider it noted.
22:14:01 <ReinH> :t mapM_
22:14:02 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
22:14:40 <ReinH> redtricycle: what are you trying to do?
22:17:19 <redtricycle> myFunc :: [String] -> String -> String
22:17:25 <redtricycle> it makes a message
22:17:28 <redtricycle> so I can call
22:17:37 <Iceland_jack> redtricycle: It needs to return an IO action
22:17:37 <redtricycle> myFunc xs "dog"
22:17:38 <redtricycle> and it
22:17:40 <ReinH> redtricycle: what monad are you working with?
22:17:41 <Iceland_jack> @ty mapM_
22:17:42 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
22:17:45 * hackagebot thyme 0.3.5.1 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.1 (LiyangHu)
22:17:48 <redtricycle> [String] -> String -> IO String
22:18:14 <Iceland_jack> redtricycle: But you're mapping it over a list of numbers
22:18:16 <Iceland_jack> not Strings
22:18:52 <redtricycle> er, let them be strings
22:19:12 <Iceland_jack> :t mapM_ ((undefined :: [String] -> String -> IO String) ?xs) (map show [1,2,3,4,5])
22:19:13 <lambdabot> (?xs::[String]) => IO ()
22:19:17 <Iceland_jack> Then it works redtricycle
22:19:27 <redtricycle> trying to have mapM_ (print . myFunc "a") ["lots","of","things"]
22:19:37 <kmspriyatham> I did cabal install regex-posix to get Text.Regex.Posix but when I try to import it in ghci it says it can't find the module
22:19:38 <redtricycle> is what I'm trying to do basically
22:19:46 <redtricycle> and I want it to say
22:19:49 <redtricycle> "a lots"
22:19:50 <redtricycle> "a of"
22:19:52 <redtricycle> "a things"
22:20:07 <Iceland_jack> redtricycle: If all you've said is true that should work
22:20:08 <redtricycle> Is my syntax off?  the error is:
22:20:16 <Iceland_jack> assuming myFunc does return an IO String
22:20:31 <redtricycle> hm
22:20:53 <Iceland_jack> redtricycle: Type this into your GHCi session
22:20:53 <Iceland_jack>     mapM_ (print . ("a " ++)) ["lots","of","things"]
22:21:33 <Iceland_jack> Although something like
22:21:33 <Iceland_jack>     mapM_ (putStrLn . ("a " ++)) ["lots","of","things"]
22:21:33 <Iceland_jack> might also be what you want
22:22:56 <redtricycle> that worked, my function is not hmmm
22:23:32 <Iceland_jack> You can paste your code to lpaste
22:23:34 <Iceland_jack> @where lpaste
22:23:34 <lambdabot> http://lpaste.net/new/haskell
22:23:43 <Iceland_jack> and I'll take a closer look at ‘myFunc’
22:23:46 <redtricycle> sure
22:23:50 <redtricycle> give me a sec to paste it in
22:23:59 <Iceland_jack> I'll give you 3
22:24:13 <redtricycle> :p
22:27:46 * hackagebot kmeans-par 1.1.0 - Sequential and parallel implementations of Lloyd's algorithm.  http://hackage.haskell.org/package/kmeans-par-1.1.0 (vi)
22:28:29 <redtricycle> Iceland_jack: http://lpaste.net/2522354277700075520
22:29:31 <carter> who's vi?
22:29:53 <Iceland_jack> redtricycle: So you're trying to show an action
22:30:01 <redtricycle> ya
22:30:22 <LordBrain> just remove print
22:30:39 <LordBrain> or
22:30:45 <Iceland_jack> If you really want to print it
22:30:53 <LordBrain> use print =<<
22:30:59 <Iceland_jack> you can do
22:31:00 <Iceland_jack>     mapM_ (print <=< conversionText td) nc
22:31:00 <LordBrain> instead of print .
22:31:03 <LordBrain> oh
22:31:09 <LordBrain> <=< then
22:31:11 <Iceland_jack> LordBrain: that won't work
22:31:38 <redtricycle> Not in scope
22:31:42 <redtricycle> where is <=< imported from?
22:31:42 <Iceland_jack> import Control.Monad
22:31:52 <Iceland_jack> redtricycle: I wonder why conversionText needs to be an IO action though
22:32:01 <redtricycle> That totally workekd
22:32:11 <Iceland_jack> there is no reasno for it to be IO redtricycle
22:32:17 <redtricycle> it kept giving me type errors when I was printing it to be debug, let me take it out
22:32:38 <redtricycle>     Couldn't match type `[]' with `IO' Expec
22:32:38 <redtricycle> ted type: String -> IO Char
22:32:38 <redtricycle>       Actual type: String -> String
22:32:38 <redtricycle>     In the return type of a call of `conversionText' In
22:32:38 <redtricycle> the second argument of `(<=<)', namely `(conversionText td)'
22:32:41 <redtricycle>     In the first argument of `mapM_', namely
22:32:43 <redtricycle>       `(print <=< (conversionText td))'
22:32:58 <Iceland_jack> Rewrite it to be
22:32:59 <Iceland_jack>     conversionText :: [String] -> String -> String
22:32:59 <Iceland_jack> and use it as
22:32:59 <Iceland_jack>     mapM_ (print . conversionText td) nc
22:34:54 <redtricycle> laptop battery dead,will hesd hone ti try out iceland_jack thanks!
22:35:08 <Iceland_jack> sure thing
22:42:02 <yaymukund> what does f'*g' mean in the context of composing functions?
22:42:10 <yaymukund> I'm trying to understand http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
22:42:25 <yaymukund> googling "asterisk" haskell doesn't bring up anything much.
22:42:42 <Iceland_jack> yaymukund: It's just syntax the author made up
22:42:46 <yaymukund> oh gotcha
22:42:50 <yaymukund> duh
22:42:51 <yaymukund> :D
22:43:11 <yaymukund> "Call this" shoulda given that away. thanks, Iceland_jack !
22:43:22 <Iceland_jack> indeed!
22:44:56 <Iceland_jack> yaymukund: What would the type of (*) be?
22:45:32 <Iceland_jack> assuming it's defined as
22:45:32 <Iceland_jack>     f * g = bind f . g
22:46:04 <ivanm> @type let f * g = (f >>=) . g in (*)
22:46:05 <lambdabot> Monad m => m a1 -> (a -> a1 -> m b) -> a -> m b
22:46:17 <ivanm> assuming bind == >>=
22:46:21 <Iceland_jack> ivanm: I was not asking a question
22:46:26 <Iceland_jack> and bind ≠ >>=
22:46:45 <ivanm> Iceland_jack: oh, right, mixed you and yaymukund up :/
22:49:25 <yaymukund> o.O
22:51:13 <solidus-1iver> if you dont designate a tuple before the where clause does it export everything from the module?
22:51:28 <LordBrain> yeah
22:51:55 <solidus-1iver> is there a way to do a hiding tupe before a where clause?
22:53:34 <LordBrain> if you use the tuple notation, you can specify the exports explicitly, anything not specified will not be exported (except instances, they just go no matter what, somewhat unfortunate)
22:54:45 <LordBrain> if you don't give an export list, then everything is exported
22:56:15 <LordBrain> if you mean, is there a way to say, export everything except such and such? Then no.
23:00:00 <bergmark> one way is to have module ReExport (module Export) where import Export hiding (a,b,c)
23:02:37 <arboris> is there a guide somewhere that explains how to deal with C structs without using a preprocessor like hsc?
23:02:45 <pavonia> bergmark: Does that really only export everything imported form module Export?
23:02:50 * hackagebot lensref 0.1.0.3 - References which can be joined and on which lenses can be applied  http://hackage.haskell.org/package/lensref-0.1.0.3 (PeterDivianszky)
23:04:04 <nisstyre> arboris: deal with them how? Like as part of the FFI?
23:04:26 <arboris> i'm writing a wrapper for linenoise, and everything except setting the completion callback is trivial to wrap
23:04:57 <bergmark> pavonia: yes...
23:05:25 <arboris> the struct involved is struct completions { size_t len, char **vec };, so fairly trivial
23:05:43 <arboris> nisstyre: yes as part of a ffi
23:06:14 <arboris> i've tried to look through the readline wrapper, but found it fairly incomprehensible
23:07:50 * hackagebot lgtk 0.8.0.1 - Lens GUI Toolkit  http://hackage.haskell.org/package/lgtk-0.8.0.1 (PeterDivianszky)
23:07:52 * hackagebot OrPatterns 0.1 - A quasiquoter for or-patterns  http://hackage.haskell.org/package/OrPatterns-0.1 (AdamVogt)
23:07:54 * hackagebot lgtk 0.8.0.2 - Lens GUI Toolkit  http://hackage.haskell.org/package/lgtk-0.8.0.2 (PeterDivianszky)
23:09:03 <enthropy> arboris: if you don't use hsc2hs how are you going to get the offsets right every time?
23:09:23 <arboris> enthropy, well how is hsc2hs getting them right?
23:09:37 <enthropy> hsc2hs compiles a file with the c compiler
23:09:55 <arboris> so it looks at the header file?
23:09:55 <enthropy> so it gets the right number for sizeof(size_t)
23:10:06 <arboris> hm ok
23:10:33 <m00nlight> Is there a equivalent function in haskell like scheme's list? function to check whether the argument is a list or not ?
23:10:43 <Iceland_jack> n00b
23:10:46 <Iceland_jack> oops!
23:10:51 <Iceland_jack> m00nlight: There is no need!
23:10:53 <shachaf> m00nlight: Not really.
23:10:54 <sgronblo> m00nlight: thats a job for the compiler?
23:10:56 <nisstyre> m00nlight: the type system does that statically
23:11:00 <enthropy> typeOf
23:11:13 <nisstyre> m00nlight: however there is a similar concept of programming with contracts
23:11:28 <cococo> What do people mean _exactly_ when they say Haskell has no side effects?
23:11:31 <nisstyre> Haskell programmers would sometimes rather push a lot of that functionality to the compiler, but still
23:11:44 <shachaf> Usually when people say something they don't mean anything exactly.
23:11:47 <nisstyre> cococo: the answer to that question is a bit complex
23:12:13 <sgronblo> cococo: yeah i think you would first need to spend a long time defining exactly what you mean when you say exactly and underline it too.
23:12:19 <bergmark> cococo: that's ill phrased, i'd say
23:12:21 <nisstyre> cococo: but note that things of type IO a aren't really "impure"
23:12:41 <m00nlight> sgronblo Iceland_jack:thanks
23:12:51 * hackagebot lgtk 0.8.0.3 - Lens GUI Toolkit  http://hackage.haskell.org/package/lgtk-0.8.0.3 (PeterDivianszky)
23:13:09 <Iceland_jack> m00nlight: You can do
23:13:10 <Iceland_jack>     isList :: [a] -> Bool
23:13:10 <Iceland_jack>     isList = const True
23:13:10 <Iceland_jack> :)
23:13:44 <Iceland_jack> (and for the record I was trying to autocomplete your nick when I typed 'n00b', my bad)
23:14:02 <enthropy> > (typeOf1 "hi", typeOf1 Nothing)
23:14:03 <lambdabot>  ([],Maybe)
23:14:14 <m00nlight> Iceland_jack: thanks
23:14:28 <zRecursive> :t typeOf
23:14:29 <lambdabot> Typeable a => a -> TypeRep
23:14:30 <sgronblo> m00nlight: the question is why would you need to check the type
23:14:36 <Iceland_jack> enthropy: It's /possible/ but it's not the right answer to the question, in the sense that you would never use Typeable when you use list? in Scheme
23:15:32 <m00nlight> sgronblo: to write an flatten with accumulator
23:15:39 <enthropy> oh I thought the direct translation of list? was   \x -> typeOf1 x == typeOf1 ""
23:16:28 <nisstyre> Iceland_jack: you'd normally use list? in Scheme to have some kind of contract, i.e. a runtime assertion
23:16:36 <Iceland_jack> nisstyre: That's what I'm saying
23:16:41 <Iceland_jack> You don't need that in Haskell
23:16:42 <nisstyre> you can of course do something like that in Haskell but there's no need for lsits
23:16:44 <nisstyre> *lists
23:16:53 <nisstyre> Maybe is useful for doin
23:16:57 <nisstyre> *doing things like that
23:17:28 <nisstyre> smart constructors are probably the analogous thing here
23:17:51 * hackagebot http-kit 0.3.0 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.3.0 (SimonHengel)
23:19:13 <nisstyre> m00nlight: you can't really write a list flattener in Haskell to an arbitrary depth because the depth of lists is part of their type
23:19:20 <nisstyre> [[a]] != [a]
23:19:45 <Iceland_jack> You can easily make a tree of lists or values though and fold that
23:19:50 <nisstyre> yeah
23:20:54 <Iceland_jack> lists in lisp essentially double as trees and many other data types, they're more similar to Haskell's tuple than Haskell's lists in that sense
23:21:13 <Iceland_jack> nil = (), cons = (,)
23:21:38 <solidus-1iver> damn, elm was so close yet so far
23:21:43 <nisstyre> yeah they are basically tuples with special magic to print them as lists when you do (a,(b,False)) or something like that
23:21:46 <solidus-1iver> looks like in my search so far Fay is the winner
23:22:15 <nisstyre> that is actually a tricky part for beginners in Scheme
23:22:24 <nisstyre> cons isn't what they think
23:22:33 <nisstyre> I can imagine people coming from Haskell would be confused too
23:23:12 <SrPx> Is it possible to have a record with functions?
23:23:20 <bergmark> SrPx: yes
23:23:22 <m00nlight> Iceland_jack: nisstyre: thanks for the explanation
23:23:33 <SrPx> bergmark: would you tell me the syntax? (:
23:23:34 <Iceland_jack> SrPx: Certainly
23:23:48 <bergmark> SrPx: just put the function where the type goes
23:23:51 <Iceland_jack>     data Isos a b = Isos { from :: a -> b, to :: b -> a }
23:23:53 <bergmark> the function type*
23:24:22 <Iceland_jack> just like you'd make a record out of any other type
23:24:52 <sgronblo> yeah theres nothing magical about function types compared to other types right?
23:25:00 <Iceland_jack> no
23:25:10 <Iceland_jack>     data Num a = Num { add :: a -> a -> a }
23:25:10 <Iceland_jack>     intNum = Num (+) :: Num Int
23:25:10 <Iceland_jack>     main = print (add intNum 5 10)
23:25:15 <Iceland_jack> prints '15'
23:25:45 <enthropy> you can't show functions
23:26:13 <Iceland_jack> What function?
23:26:29 <Iceland_jack> If you're referring to my example I don't show any functions
23:26:39 <solidus-1iver> how does Ord derive Records
23:26:45 <LordBrain> i think he means there's no Show (a -> b) instance
23:26:53 <solidus-1iver> is it the first field compared with other first feild, then second if they dont match etc
23:26:59 <enthropy> I mean it is a reason to avoid putting functions into your data types
23:27:03 <Iceland_jack> LordBrain: Yes but that doesn't mean that there is anything magical about them
23:27:07 <solidus-1iver> er, the first field thats an instance of Ord
23:27:19 <Iceland_jack> I put functions in data types all the time
23:27:19 <enthropy> in spite of the flexibility they give you
23:27:28 <nisstyre> enthropy: sometimes it can be annoying for people trying to learn your API...
23:27:38 <SrPx> okay guys, worked perfectly, even without the record syntax. Thanks! I didn't know that was possible at all.
23:27:39 <nisstyre> "dammit I just want to see what's in this"
23:27:51 <nisstyre> but people should get used to doing :t foo rather than foo
23:28:03 <Iceland_jack> nisstyre: You can be creative with your show instance if you must :)
23:28:03 <enthropy> or you trying to debug, or trying to make things serializable between runs etc.
23:28:44 <LordBrain> i would say avoiding using functions can give you more flexibility in certain ways... because then you can treat it as if it were an AST.
23:28:51 <SrPx> so, another question, regarding this: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html -- what is the accepted opinion on that? Would it be acceptable to completely ignore typeclasses on Haskell, in favor of types? Are there libraries supporting this?
23:29:15 <Iceland_jack> SrPx: That post does _not_ tell you to completely ignore type classes
23:29:15 <nisstyre> SrPx: it's more or less how you'd implement type classes if you were writing a compiler
23:29:28 <nisstyre> but instead doing it by hand, arguably it can be more flexible
23:29:47 <enthropy> LordBrain: ok I mean more flexibility for the person supplying the Record. You're looking at it from the other direction?
23:29:48 <Iceland_jack> Type classes are very useful and very powerful
23:30:05 <LordBrain> yeah, i certainlly didn't mean to contradict you
23:30:06 <lispy> SrPx: as a beginner you probably don't want to design your own type classes but you shouldn't avoid the ones other people have made. As you gain more experience you'll learn when it's good to make a type class. It's kind of hard to explain.
23:30:19 <nisstyre> I'll echo what Iceland_jack said, it's not saying type classes are bad
23:30:21 <LordBrain> serialization is a boon
23:30:26 <nisstyre> just the brand of type classes in GHC
23:31:44 <lispy> typeclasses work best where there is just one way of doing something per type.
23:32:31 <SrPx> lispy: oh okay then, that is what I wanted to know
23:32:49 <lispy> otherwise you run into that weird thing where you end up using a lot of newtypes just to pick your instances
23:33:45 <lispy> I wish I could go back in time and add a DebugShow to the prelude.
23:34:11 <lispy> Then "correct" usage of Show would be more obvious...
23:34:15 <Iceland_jack> lispy: So that Show would be for pretty printing?
23:34:21 <lispy> (where, "correct" is my pet definition)
23:34:31 <lispy> Iceland_jack: Well, DebugShow would be the human readable one
23:34:37 <Iceland_jack> yeah
23:34:41 <lispy> Iceland_jack: and Read/Show would be for round tripping
23:34:51 <lispy> And I'm sure there are better names than DebugShow
23:35:11 <Iceland_jack> DebugShow would be the thing GHCi would display
23:35:18 <Iceland_jack> it would have been a nice way to go about things
23:35:30 <lispy> the haskell report basically says to avoid making your own Show instances, or at least make them compatible with the Read instance.
23:35:54 <LordBrain> agreed lispy
23:36:40 <Iceland_jack> there are a ton of things that would be nice to change about Haskell tbh :)
23:36:45 <lispy> Iceland_jack: I bet we could still convince ghc to adopt that even if it doesn't end up in the prelude. I bet you could add a thing that looks for a DebugShow instance and falls back to normal Show.
23:36:49 <Iceland_jack> Something, something String
23:37:00 <LordBrain> Could call lit PrettyPrint
23:37:09 <Iceland_jack> lispy: You can define your own display function for GHCi
23:37:14 <lispy> or PrettyShow
23:37:19 <LordBrain> yeah
23:37:27 <Iceland_jack> Yes there are several pretty printing type classes on Hackage
23:37:28 <lispy> I have to run off to bed
23:37:36 <Iceland_jack> they haven't really caught on though
23:37:37 * lispy waves
23:37:41 <Iceland_jack> tc li
23:37:43 <Iceland_jack> tc lispy*
23:51:21 <enthropy> byorgey: is this example a fair comparison with first-class-patterns http://hackage.haskell.org/package/OrPatterns ?
23:52:22 <carter> i don't think byorgey  is awake righ tnow
23:52:30 <enthropy> probably not
23:52:51 <carter> he's got a kid + a thesis to finish, if he's not sleeping, i'd be worried
23:52:59 * hackagebot fsnotify 0.1.0.2 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.1.0.2 (RomanCheplyaka)
23:53:35 <MasterMastic> Hey people
23:53:46 <carter> hey entity
23:54:36 <MasterMastic> Anybody knows of a GUI library for Haskell that's actually up to date?
23:54:37 <carter> sup
23:54:39 <carter> oh
23:54:41 <carter> well
23:54:43 <carter> a bunch
23:54:46 <carter> what OS
23:54:50 <MasterMastic> I'm desperate with it ._.
23:54:53 <carter> no
23:54:54 <carter> what OS
23:54:56 <MasterMastic> Windows, but cross would work out greatly
23:54:59 <carter> ok
23:55:04 <carter> how fancy
23:55:06 <carter> or simple and quick
23:55:10 <carter> which do you want more
23:56:19 <MasterMastic> How fancy
23:56:19 <carter> do you want a quick basic gui
23:56:19 <carter> or do lots and lots of time polishing things
23:56:19 <rhaps0dy> does it have glossy plain <insert buzzword here> look or is it Tk ?
23:56:19 <MasterMastic> Quick & basic
23:56:20 <carter> ok
23:56:20 <carter> @hackage threepenny-gui
23:56:20 <lambdabot> http://hackage.haskell.org/package/threepenny-gui
23:56:20 <carter> MasterMastic: thats probably the best quick+basic one that'll just work on every major OS you'd want
23:56:36 <carter> works by having mini sever talk with a page in the browser
23:56:46 <carter> you just treat the browser page as a gui
23:56:48 <MasterMastic> I see; but got something more native to the system?
23:57:01 <carter> theres plenty
23:57:06 <carter> but you want quick+basic :)
23:57:19 <carter> how many hours are you wanting to work on gui engineering?
23:57:24 <carter> theres QT based tools
23:57:29 <carter> theres everal gtk based tools
23:57:35 <carter> whats the application?
23:57:47 <carter> you could probably do something wiht Opengl/SDL if you wanted
23:58:17 <MasterMastic> Aye, not that much though. My main issue is that just about everything fails to build (both on Linux and Windows machines), and I'm getting the idea stuff are out-dated
23:58:24 <MasterMastic> That includes GTK
23:58:27 <carter> nah
23:58:28 <MasterMastic> Not so interested in Qt
23:58:33 <carter> GTK just had a release
23:58:38 <carter> and theres also lgtk too
23:59:00 <carter> if you want something thats easy to get working on all the OSes, see how far you can push three-penny
23:59:09 <carter> then onc eyou know what you care about supporting, figure out from there?
23:59:21 <carter> if you wanna see a fancy gtk program, albeit linux only
23:59:25 <carter> @hackage hoodle is pretty neat
23:59:26 <lambdabot> http://hackage.haskell.org/package/hoodle is pretty neat
23:59:39 <carter> ok
23:59:40 <carter> i'm done
23:59:40 <Iceland_jack> even lambdabot seems to think so
23:59:40 <carter> night
23:59:44 <carter> :)
23:59:45 <MasterMastic> Thanks a bunch carter
23:59:46 <Iceland_jack> night carter :)
23:59:52 <MasterMastic> Much appreciated ^^
23:59:56 <carter> MasterMastic: now just make magic stuff master mastic
